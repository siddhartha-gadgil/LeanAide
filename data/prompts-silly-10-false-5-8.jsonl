{"text":"Every prime number is `2` or odd.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p : Prop)], (p % 2 = 1 : Prop) ↔ (p ≠ 2 : Prop)\"},\n {\"role\": \"user\", \"content\": \"`2` is not a factor of an odd natural number. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {m : ℕ} {n : ℕ} (hn : Odd n) (hm : m ∣ n), m ≠ 2\"},\n {\"role\": \"user\",\n  \"content\": \"The only prime factor of prime `p` is `p` itself. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ} {q : ℕ} (hp : Nat.Prime p) (h : ↑(Nat.factorization p) q ≠ 0), p = q\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (n : ℕ), (Nat.factorization n = 0 : Prop) ↔ ((n = 0 : Prop) ∨ (n = 1 : Prop) : Prop)\"},\n {\"role\": \"user\",\n  \"content\": \"A natural number is odd iff it has residue `1` or `3` mod `4`\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {n : ℕ}, (n % 2 = 1 : Prop) ↔ ((n % 4 = 1 : Prop) ∨ (n % 4 = 3 : Prop) : Prop)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The only prime factor of prime `p` is `p` itself, with multiplicity `1` \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ} (hp : Nat.Prime p), Nat.factorization p = Finsupp.single p 1\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\",\n  \"content\": \"Set.InjOn Nat.factorization (setOf fun (x : ℕ) ↦ x ≠ 0)\"},\n {\"role\": \"user\", \"content\": \"Every prime number is `2` or odd.\"}]"}
{"text":"There are infinitely many odd natural numbers.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"`2` is not a factor of an odd natural number. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {m : ℕ} {n : ℕ} (hn : Odd n) (hm : m ∣ n), m ≠ 2\"},\n {\"role\": \"user\",\n  \"content\": \"Infinitely many natural numbers are equal to `d` mod `n`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {n : ℕ} (h : n ≠ 0) (d : ℕ), Filter.Frequently (fun (m : ℕ) ↦ m ≡ d [MOD n]) Filter.atTop\"},\n {\"role\": \"user\", \"content\": \"The infinite pigeonhole principle \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {β : Type u} {α : Type u} (f : (a : β) → α) (h₁ : Cardinal.aleph0 ≤ Cardinal.mk β)\\n  (h₂ : Cardinal.mk α < Ordinal.cof (Cardinal.ord (Cardinal.mk β))), ∃ (a : α), Cardinal.mk ↑(f ⁻¹' {a}) = Cardinal.mk β\"},\n {\"role\": \"user\",\n  \"content\": \"A sum of numbers is infinite iff one of them is infinite \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {s : Finset α} {f : (a : α) → ENNReal},\\n  ((Finset.sum s fun (x : α) ↦ f x) = ⊤ : Prop) ↔ (∃ (a : α), (a ∈ s : Prop) ∧ (f a = ⊤ : Prop) : Prop)\"},\n {\"role\": \"user\",\n  \"content\": \"A sum of numbers is infinite iff one of them is infinite \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_2} {M : Type u_1} [inst : AddCommMonoid M] {s : Finset ι} {f : (a : ι) → WithTop M},\\n  ((Finset.sum s fun (i : ι) ↦ f i) = ⊤ : Prop) ↔ (∃ (i : ι), (i ∈ s : Prop) ∧ (f i = ⊤ : Prop) : Prop)\"},\n {\"role\": \"user\",\n  \"content\": \"If `n` is odd and `a` is even, then `n % a` is odd. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n : ℕ} {a : ℕ} (hn : Odd n) (ha : Even a), Odd (n % a)\"},\n {\"role\": \"user\",\n  \"content\": \"A natural number is odd iff it has residue `1` or `3` mod `4`\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {n : ℕ}, (n % 2 = 1 : Prop) ↔ ((n % 4 = 1 : Prop) ∨ (n % 4 = 3 : Prop) : Prop)\"},\n {\"role\": \"user\", \"content\": \"There are infinitely many odd natural numbers.\"}]"}
{"text":"The smallest odd prime is `3`.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"`2` is not a factor of an odd natural number. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {m : ℕ} {n : ℕ} (hn : Odd n) (hm : m ∣ n), m ≠ 2\"},\n {\"role\": \"user\",\n  \"content\": \"A natural number is odd iff it has residue `1` or `3` mod `4`\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {n : ℕ}, (n % 2 = 1 : Prop) ↔ ((n % 4 = 1 : Prop) ∨ (n % 4 = 3 : Prop) : Prop)\"},\n {\"role\": \"user\",\n  \"content\": \"The only prime factor of prime `p` is `p` itself. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ} {q : ℕ} (hp : Nat.Prime p) (h : ↑(Nat.factorization p) q ≠ 0), p = q\"},\n {\"role\": \"user\",\n  \"content\": \"A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p : Prop)], (p % 2 = 1 : Prop) ↔ (p ≠ 2 : Prop)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `1 < p`, then `q p`, the smallest prime factor of `mersenne p`, is more than 2. \"},\n {\"role\": \"assistant\", \"content\": \"∀ (p' : ℕ), 2 < LucasLehmer.q (p' + 2)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (n : ℕ), (Nat.factorization n = 0 : Prop) ↔ ((n = 0 : Prop) ∨ (n = 1 : Prop) : Prop)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The only prime factor of prime `p` is `p` itself, with multiplicity `1` \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ} (hp : Nat.Prime p), Nat.factorization p = Finsupp.single p 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The square of the smallest prime factor of a composite number `n` is at most `n`.\\n\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {n : ℕ} (w : 0 < n) (h : ¬(Nat.Prime n : Prop)), Nat.minFac n ^ 2 ≤ n\"},\n {\"role\": \"user\",\n  \"content\": \"The only divisors of prime powers are prime powers. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [dec_irr : (p : Associates α) → Decidable (Irreducible p : Prop)]\\n  [inst_1 : UniqueFactorizationMonoid α] [dec : DecidableEq α] [dec' : DecidableEq (Associates α)] {a : Associates α}\\n  {p : Associates α} (hp : Irreducible p) [inst_2 : (n : ℕ) → Decidable (a ∣ p ^ n : Prop)] {n : ℕ} (h : a ∣ p ^ n),\\n  a = p ^ Nat.find ((Exists.intro n h=:∃ (n : ℕ), (fun (n : ℕ) ↦ a ∣ p ^ n) n)=:∃ (n : ℕ), (fun (n : ℕ) ↦ a ∣ p ^ n) n)\"},\n {\"role\": \"user\", \"content\": \"The multiplicity of prime `p` in `p` is `1` \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {p : ℕ} (hp : Nat.Prime p), ↑(Nat.factorization p) p = 1\"},\n {\"role\": \"user\", \"content\": \"The smallest odd prime is `3`.\"}]"}
{"text":"There are infinitely many odd prime numbers.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"`2` is not a factor of an odd natural number. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {m : ℕ} {n : ℕ} (hn : Odd n) (hm : m ∣ n), m ≠ 2\"},\n {\"role\": \"user\",\n  \"content\": \"The only prime factor of prime `p` is `p` itself. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ} {q : ℕ} (hp : Nat.Prime p) (h : ↑(Nat.factorization p) q ≠ 0), p = q\"},\n {\"role\": \"user\",\n  \"content\": \"A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p : Prop)], (p % 2 = 1 : Prop) ↔ (p ≠ 2 : Prop)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A version of `Nat.exists_infinite_primes` using the `Set.Infinite` predicate. \"},\n {\"role\": \"assistant\",\n  \"content\": \"Set.Infinite (setOf fun (p : ℕ) ↦ Nat.Prime p)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (n : ℕ), (Nat.factorization n = 0 : Prop) ↔ ((n = 0 : Prop) ∨ (n = 1 : Prop) : Prop)\"},\n {\"role\": \"user\", \"content\": \"The infinite pigeonhole principle \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {β : Type u} {α : Type u} (f : (a : β) → α) (h₁ : Cardinal.aleph0 ≤ Cardinal.mk β)\\n  (h₂ : Cardinal.mk α < Ordinal.cof (Cardinal.ord (Cardinal.mk β))), ∃ (a : α), Cardinal.mk ↑(f ⁻¹' {a}) = Cardinal.mk β\"},\n {\"role\": \"user\", \"content\": \"There are infinitely many odd prime numbers.\"}]"}
{"text":"If a vector space has dimension `2` then it is finite dimensional.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a vector space has a finite basis, then it is finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\\n  [inst_3 : Finite ι] (h : Basis ι K V), FiniteDimensional K V\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a vector space has a basis indexed by elements of a finite set, then it is\\nfinite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\\n  {s : Set ι} (h : Basis (↑s) K V) (hs : Set.Finite s), FiniteDimensional K V\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A subspace of a finite-dimensional space is also finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K { x : V // x ∈ S }\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a vector space has a finite dimension, the index set of `Basis.ofVectorSpace` is finite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  (h : Module.rank K V < Cardinal.aleph0), Set.Finite (Basis.ofVectorSpaceIndex K V)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A vector space with a nonzero vector `v` has dimension 1 iff `v` spans.\\n\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (v : V)\\n  (nz : v ≠ 0), (FiniteDimensional.finrank K V = 1 : Prop) ↔ (Submodule.span K {v} = ⊤ : Prop)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The dimension of a finite dimensional space is preserved under linear equivalence. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} {M : Type u_2} {M₂ : Type u_3} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : AddCommGroup M₂]\\n  [inst_3 : Module R M] [inst_4 : Module R M₂] (f : M ≃ₗ[R] M₂),\\n  FiniteDimensional.finrank R M = FiniteDimensional.finrank R M₂\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a vector space has dimension `2` then it is finite dimensional.\"}]"}
{"text":"Every field is a division ring.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"A subfield is closed under division. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} [inst : Field K] (s : Subfield K) {x : K} {y : K} (a : x ∈ s) (a : y ∈ s), x / y ∈ s\"},\n {\"role\": \"user\",\n  \"content\": \"All ideals in a division (semi)ring are trivial. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} [inst : DivisionSemiring K] (I : Ideal K), (I = ⊥ : Prop) ∨ (I = ⊤ : Prop)\"},\n {\"role\": \"user\", \"content\": \"A subring of a domain is a domain. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {S : Type v} (s : S) {R : Type u_1} [inst : Ring R] [inst_1 : IsDomain R] [inst_2 : SetLike S R]\\n  [inst_3 : SubringClass S R], IsDomain { x : R // x ∈ s }\"},\n {\"role\": \"user\", \"content\": \"A subring of a domain is a domain. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : Ring R] [inst_1 : IsDomain R] (s : Subring R), IsDomain { x : R // x ∈ s }\"},\n {\"role\": \"user\",\n  \"content\": \"A normed division ring is a topological division ring. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : NormedDivisionRing α], TopologicalDivisionRing α\"},\n {\"role\": \"user\",\n  \"content\": \"Natural division is always less than division in the field. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : LinearOrderedSemifield α] {m : ℕ} {n : ℕ}, ↑(m / n) ≤ ↑m / ↑n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A subring of a ring with no zero divisors has no zero divisors. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : Ring R] [inst_1 : NoZeroDivisors R] (s : Subring R), NoZeroDivisors { x : R // x ∈ s }\"},\n {\"role\": \"user\", \"content\": \"A subfield is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} [inst : Field K] (s : Subfield K) {x : K} {y : K} (a : x ∈ s) (a : y ∈ s), x * y ∈ s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For a semiring to be a field, it must have two distinct elements. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : Semiring R] (self : IsField R), ∃ (x : R), ∃ (y : R), x ≠ y\"},\n {\"role\": \"user\", \"content\": \"`R[X]` is never a field for any ring `R`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : Ring R], ¬(IsField (Polynomial R) : Prop)\"},\n {\"role\": \"user\", \"content\": \"Every field is a division ring.\"}]"}
{"text":"If a space has dimension `2` then it is finite dimensional.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A subspace of a finite-dimensional space is also finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K { x : V // x ∈ S }\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a vector space has a finite basis, then it is finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\\n  [inst_3 : Finite ι] (h : Basis ι K V), FiniteDimensional K V\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a vector space has a basis indexed by elements of a finite set, then it is\\nfinite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\\n  {s : Set ι} (h : Basis (↑s) K V) (hs : Set.Finite s), FiniteDimensional K V\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a vector space has a finite dimension, the index set of `Basis.ofVectorSpace` is finite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  (h : Module.rank K V < Cardinal.aleph0), Set.Finite (Basis.ofVectorSpaceIndex K V)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The dimension of a finite dimensional space is preserved under linear equivalence. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} {M : Type u_2} {M₂ : Type u_3} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : AddCommGroup M₂]\\n  [inst_3 : Module R M] [inst_4 : Module R M₂] (f : M ≃ₗ[R] M₂),\\n  FiniteDimensional.finrank R M = FiniteDimensional.finrank R M₂\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A quotient of a finite-dimensional space is also finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K (V ⧸ S)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The image under an onto linear map of a finite-dimensional space is also finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {V₂ : Type v'}\\n  [inst_3 : AddCommGroup V₂] [inst_4 : Module K V₂] [inst_5 : FiniteDimensional K V] (f : V →ₗ[K] V₂)\\n  (hf : LinearMap.range f = ⊤), FiniteDimensional K V₂\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A finite dimensional space is nontrivial if it has positive `finrank`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : Ring K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] [inst_3 : Nontrivial K]\\n  [inst_4 : NoZeroSMulDivisors K V] (h : 0 < FiniteDimensional.finrank K V), Nontrivial V\"},\n {\"role\": \"user\",\n  \"content\": \"If a space has dimension `2` then it is finite dimensional.\"}]"}
{"text":"Every natural number has a successor.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `n : ℕ+` is different from `1`, then it is the successor of some `k : ℕ+`. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n : ℕ+} (x : n ≠ 1), ∃ (k : ℕ+), n = k + 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {m : ℕ} {n : ℕ}, (∀ (a : ℕ), (m ∣ a : Prop) ↔ (n ∣ a : Prop) : Prop) ↔ (m = n : Prop)\"},\n {\"role\": \"user\", \"content\": \"Successor powers behave as expected \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_1} {A : (a : ι) → Type u_2} [inst : AddMonoid ι] [self : GradedMonoid.GMonoid A] (n : ℕ)\\n  (a : GradedMonoid A),\\n  GradedMonoid.mk (Nat.succ n • Sigma.fst a) (GradedMonoid.GMonoid.gnpow (Nat.succ n) (Sigma.snd a)) =\\n    a * { fst := n • Sigma.fst a, snd := GradedMonoid.GMonoid.gnpow n (Sigma.snd a) }\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\",\n  \"content\": \"Set.InjOn Nat.factorization (setOf fun (x : ℕ) ↦ x ≠ 0)\"},\n {\"role\": \"user\",\n  \"content\": \"`a ≤ b` as natural numbers if and only if `a ≤ b` in `Fin n`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {n : ℕ} {a : Fin n} {b : Fin n}, (↑a ≤ ↑b : Prop) ↔ (a ≤ b : Prop)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {m : ℕ} {n : ℕ}, (∀ (a : ℕ), (a ∣ m : Prop) ↔ (a ∣ n : Prop) : Prop) ↔ (m = n : Prop)\"},\n {\"role\": \"user\", \"content\": \"Every ordinal has a fundamental sequence. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (a : Ordinal),\\n  ∃ (f : (b : Ordinal) → (a : b < Cardinal.ord (Ordinal.cof a)) → Ordinal),\\n    Ordinal.IsFundamentalSequence a (Cardinal.ord (Ordinal.cof a)) f\"},\n {\"role\": \"user\",\n  \"content\": \"`a < b` as natural numbers if and only if `a < b` in `Fin n`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {n : ℕ} {a : Fin n} {b : Fin n}, (↑a < ↑b : Prop) ↔ (a < b : Prop)\"},\n {\"role\": \"user\", \"content\": \"Every natural number has a successor.\"}]"}
{"text":"Every natural number is less than its successor.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"`a ≤ b` as natural numbers if and only if `a ≤ b` in `Fin n`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {n : ℕ} {a : Fin n} {b : Fin n}, (↑a ≤ ↑b : Prop) ↔ (a ≤ b : Prop)\"},\n {\"role\": \"user\",\n  \"content\": \"`a < b` as natural numbers if and only if `a < b` in `Fin n`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {n : ℕ} {a : Fin n} {b : Fin n}, (↑a < ↑b : Prop) ↔ (a < b : Prop)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `n : ℕ+` is different from `1`, then it is the successor of some `k : ℕ+`. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n : ℕ+} (x : n ≠ 1), ∃ (k : ℕ+), n = k + 1\"},\n {\"role\": \"user\", \"content\": \"The relation `≤` on a preorder is transitive. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : Preorder α] {a : α} {b : α} {c : α} (a_1 : a ≤ b) (a_2 : b ≤ c), a ≤ c\"},\n {\"role\": \"user\",\n  \"content\": \"Any element of a set is more than the set infimum. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [self : CompleteLattice α] (s : Set α) (a : α) (a_1 : a ∈ s), infₛ s ≤ a\"},\n {\"role\": \"user\",\n  \"content\": \"Any element of a set is more than the set infimum. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [self : CompleteSemilatticeInf α] (s : Set α) (a : α) (a_1 : a ∈ s), infₛ s ≤ a\"},\n {\"role\": \"user\",\n  \"content\": \"Any element of a set is more than the set infimum. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [self : CompleteBooleanAlgebra α] (s : Set α) (a : α) (a_1 : a ∈ s), infₛ s ≤ a\"},\n {\"role\": \"user\",\n  \"content\": \"Every natural number is less than its successor.\"}]"}
{"text":"Every set is Lebesgue measurable.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"A singleton is a measurable set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : MeasurableSpace α] [self : MeasurableSingletonClass α] (x : α), MeasurableSet {x}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The image of a measurable set under a measurable embedding is a measurable set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : MeasurableSpace α] [inst_1 : MeasurableSpace β] {f : (a : α) → β}\\n  (self : MeasurableEmbedding f) ⦃s : Set α⦄ (a : MeasurableSet s), MeasurableSet (f '' s)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every set has a measurable superset. Declare this as local instance as needed. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {m : MeasurableSpace α} (s : Set α),\\n  Nonempty { t : Set α // (s ⊆ t : Prop) ∧ (MeasurableSet t : Prop) }\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A piecewise function on countably many pieces is measurable if all the data is measurable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {β : Type u_2} {mβ : MeasurableSpace β} {x : MeasurableSpace α} {f : (a : ℕ) → (a : α) → β}\\n  {p : (a : ℕ) → (a : α) → Prop} [inst : (n : ℕ) → DecidablePred (p n)] (hf : ∀ (n : ℕ), Measurable (f n))\\n  (hp : ∀ (n : ℕ), MeasurableSet (setOf fun (x : α) ↦ p n x)) (h : ∀ (x : α), ∃ (n : ℕ), p n x),\\n  Measurable fun (x : α) ↦ f (Nat.find ((h x=:∃ (n : ℕ), p n x)=:∃ (n : ℕ), p n x)) x\"},\n {\"role\": \"user\",\n  \"content\": \"A measurable equivalence is a measurable embedding. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : MeasurableSpace α] [inst_1 : MeasurableSpace β] (e : α ≃ᵐ β),\\n  MeasurableEmbedding ↑e\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a function coincides with a measurable function outside of a countable set, it is\\nmeasurable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {β : Type u_2} {f : (a : α) → β} {g : (a : α) → β} {m : MeasurableSpace α} {mβ : MeasurableSpace β}\\n  [inst : MeasurableSingletonClass α] (hf : Measurable f) (h : Set.Countable (setOf fun (x : α) ↦ f x ≠ g x)),\\n  Measurable g\"},\n {\"role\": \"user\",\n  \"content\": \"A measurable embedding is a measurable function. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : MeasurableSpace α] [inst_1 : MeasurableSpace β] {f : (a : α) → β}\\n  (self : MeasurableEmbedding f), Measurable f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The inverse function of a measurable equivalence is measurable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : MeasurableSpace α] [inst_1 : MeasurableSpace β] (self : α ≃ᵐ β),\\n  Measurable ↑(Equiv.symm (MeasurableEquiv.toEquiv self))\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The complement of a measurable set is a measurable set. Use `MeasurableSet.compl` instead. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} (self : MeasurableSpace α) (s : Set α) (a : MeasurableSpace.MeasurableSet' self s),\\n  MeasurableSpace.MeasurableSet' self (sᶜ)\"},\n {\"role\": \"user\", \"content\": \"Every set is Lebesgue measurable.\"}]"}
{"text":"Every set of Borel measure zero is Lebesgue measurable.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"A singleton is a measurable set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : MeasurableSpace α] [self : MeasurableSingletonClass α] (x : α), MeasurableSet {x}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The image of a measurable set under a measurable embedding is a measurable set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : MeasurableSpace α] [inst_1 : MeasurableSpace β] {f : (a : α) → β}\\n  (self : MeasurableEmbedding f) ⦃s : Set α⦄ (a : MeasurableSet s), MeasurableSet (f '' s)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The empty set is a measurable set. Use `MeasurableSet.empty` instead. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} (self : MeasurableSpace α), MeasurableSpace.MeasurableSet' self ∅\"},\n {\"role\": \"user\",\n  \"content\": \"A measurable equivalence is a measurable embedding. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : MeasurableSpace α] [inst_1 : MeasurableSpace β] (e : α ≃ᵐ β),\\n  MeasurableEmbedding ↑e\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A piecewise function on countably many pieces is measurable if all the data is measurable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {β : Type u_2} {mβ : MeasurableSpace β} {x : MeasurableSpace α} {f : (a : ℕ) → (a : α) → β}\\n  {p : (a : ℕ) → (a : α) → Prop} [inst : (n : ℕ) → DecidablePred (p n)] (hf : ∀ (n : ℕ), Measurable (f n))\\n  (hp : ∀ (n : ℕ), MeasurableSet (setOf fun (x : α) ↦ p n x)) (h : ∀ (x : α), ∃ (n : ℕ), p n x),\\n  Measurable fun (x : α) ↦ f (Nat.find ((h x=:∃ (n : ℕ), p n x)=:∃ (n : ℕ), p n x)) x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every set has a measurable superset. Declare this as local instance as needed. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {m : MeasurableSpace α} (s : Set α),\\n  Nonempty { t : Set α // (s ⊆ t : Prop) ∧ (MeasurableSet t : Prop) }\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The complement of a measurable set is a measurable set. Use `MeasurableSet.compl` instead. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} (self : MeasurableSpace α) (s : Set α) (a : MeasurableSpace.MeasurableSet' self s),\\n  MeasurableSpace.MeasurableSet' self (sᶜ)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a function coincides with a measurable function outside of a countable set, it is\\nmeasurable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {β : Type u_2} {f : (a : α) → β} {g : (a : α) → β} {m : MeasurableSpace α} {mβ : MeasurableSpace β}\\n  [inst : MeasurableSingletonClass α] (hf : Measurable f) (h : Set.Countable (setOf fun (x : α) ↦ f x ≠ g x)),\\n  Measurable g\"},\n {\"role\": \"user\", \"content\": \"A measurable embedding is injective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : MeasurableSpace α] [inst_1 : MeasurableSpace β] {f : (a : α) → β}\\n  (self : MeasurableEmbedding f), Function.Injective f\"},\n {\"role\": \"user\",\n  \"content\": \"A measurable embedding is a measurable function. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : MeasurableSpace α] [inst_1 : MeasurableSpace β] {f : (a : α) → β}\\n  (self : MeasurableEmbedding f), Measurable f\"},\n {\"role\": \"user\",\n  \"content\": \"Every set of Borel measure zero is Lebesgue measurable.\"}]"}
{"text":"Every prime number is `2` or odd.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 2 = 1 ↔ p ≠ 2\"},\n {\"role\": \"user\", \"content\": \"`2` is not a factor of an odd natural number. \"},\n {\"role\": \"assistant\", \"content\": \"∀ {m n : ℕ}, Odd n → m ∣ n → m ≠ 2\"},\n {\"role\": \"user\",\n  \"content\":\n  \"`2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare 2 ↔ p % 8 = 1 ∨ p % 8 = 7)\"},\n {\"role\": \"user\",\n  \"content\": \"The only prime factor of prime `p` is `p` itself. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {p q : ℕ}, Nat.Prime p → ↑(Nat.factorization p) q ≠ 0 → p = q\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (n : ℕ), Nat.factorization n = 0 ↔ n = 0 ∨ n = 1\"},\n {\"role\": \"user\",\n  \"content\": \"A natural number is odd iff it has residue `1` or `3` mod `4`\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n : ℕ}, n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3\"},\n {\"role\": \"user\",\n  \"content\":\n  \"`-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare (-2) ↔ p % 8 = 1 ∨ p % 8 = 3)\"},\n {\"role\": \"user\", \"content\": \"Every prime number is `2` or odd.\"}]"}
{"text":"There are infinitely many odd natural numbers.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"`2` is not a factor of an odd natural number. \"},\n {\"role\": \"assistant\", \"content\": \"∀ {m n : ℕ}, Odd n → m ∣ n → m ≠ 2\"},\n {\"role\": \"user\",\n  \"content\": \"Infinitely many natural numbers are equal to `d` mod `n`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {n : ℕ}, n ≠ 0 → ∀ (d : ℕ), ∃ᶠ (m : ℕ) in Filter.atTop, m ≡ d [MOD n]\"},\n {\"role\": \"user\",\n  \"content\": \"Odd Bernoulli numbers (greater than 1) are zero. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n : ℕ}, Odd n → 1 < n → bernoulli' n = 0\"},\n {\"role\": \"user\", \"content\": \"The infinite pigeonhole principle \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {β α : Type u} (f : β → α),\\n  Cardinal.aleph0 ≤ Cardinal.mk β →\\n    Cardinal.mk α < Ordinal.cof (Cardinal.ord (Cardinal.mk β)) → ∃ a, Cardinal.mk ↑(f ⁻¹' {a}) = Cardinal.mk β\"},\n {\"role\": \"user\",\n  \"content\": \"A sum of numbers is infinite iff one of them is infinite \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {s : Finset α} {f : α → ENNReal}, (Finset.sum s fun x => f x) = ⊤ ↔ ∃ a, a ∈ s ∧ f a = ⊤\"},\n {\"role\": \"user\",\n  \"content\": \"A sum of numbers is infinite iff one of them is infinite \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_2} {M : Type u_1} [inst : AddCommMonoid M] {s : Finset ι} {f : ι → WithTop M},\\n  (Finset.sum s fun i => f i) = ⊤ ↔ ∃ i, i ∈ s ∧ f i = ⊤\"},\n {\"role\": \"user\",\n  \"content\": \"If `n` is odd and `a` is even, then `n % a` is odd. \"},\n {\"role\": \"assistant\", \"content\": \"∀ {n a : ℕ}, Odd n → Even a → Odd (n % a)\"},\n {\"role\": \"user\",\n  \"content\": \"A natural number is odd iff it has residue `1` or `3` mod `4`\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n : ℕ}, n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3\"},\n {\"role\": \"user\", \"content\": \"There are infinitely many odd natural numbers.\"}]"}
{"text":"The smallest odd prime is `3`.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"`2` is not a factor of an odd natural number. \"},\n {\"role\": \"assistant\", \"content\": \"∀ {m n : ℕ}, Odd n → m ∣ n → m ≠ 2\"},\n {\"role\": \"user\",\n  \"content\": \"A natural number is odd iff it has residue `1` or `3` mod `4`\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n : ℕ}, n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3\"},\n {\"role\": \"user\",\n  \"content\":\n  \"`2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare 2 ↔ p % 8 = 1 ∨ p % 8 = 7)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"`-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare (-2) ↔ p % 8 = 1 ∨ p % 8 = 3)\"},\n {\"role\": \"user\", \"content\": \"**Lifting the exponent lemma** for odd primes. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ},\\n  Nat.Prime p →\\n    Odd p →\\n      ∀ {x y : ℤ},\\n        ↑p ∣ x - y →\\n          ¬↑p ∣ x → ∀ (n : ℕ), multiplicity (↑p) (x ^ n - y ^ n) = multiplicity (↑p) (x - y) + multiplicity p n\"},\n {\"role\": \"user\",\n  \"content\": \"The only prime factor of prime `p` is `p` itself. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {p q : ℕ}, Nat.Prime p → ↑(Nat.factorization p) q ≠ 0 → p = q\"},\n {\"role\": \"user\",\n  \"content\": \"A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 2 = 1 ↔ p ≠ 2\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `1 < p`, then `q p`, the smallest prime factor of `mersenne p`, is more than 2. \"},\n {\"role\": \"assistant\", \"content\": \"∀ (p' : ℕ), 2 < LucasLehmer.q (p' + 2)\"},\n {\"role\": \"user\", \"content\": \"The smallest odd prime is `3`.\"}]"}
{"text":"There are infinitely many odd prime numbers.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For any positive `k : ℕ` there are infinitely many primes `p` such that `p ≡ 1 [MOD k]`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {k : ℕ}, k ≠ 0 → Set.Infinite {p | Nat.Prime p ∧ p ≡ 1 [MOD k]}\"},\n {\"role\": \"user\", \"content\": \"**Lifting the exponent lemma** for odd primes. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ},\\n  Nat.Prime p →\\n    Odd p →\\n      ∀ {x y : ℤ},\\n        ↑p ∣ x - y →\\n          ¬↑p ∣ x → ∀ (n : ℕ), multiplicity (↑p) (x ^ n - y ^ n) = multiplicity (↑p) (x - y) + multiplicity p n\"},\n {\"role\": \"user\", \"content\": \"`2` is not a factor of an odd natural number. \"},\n {\"role\": \"assistant\", \"content\": \"∀ {m n : ℕ}, Odd n → m ∣ n → m ≠ 2\"},\n {\"role\": \"user\",\n  \"content\": \"The only prime factor of prime `p` is `p` itself. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {p q : ℕ}, Nat.Prime p → ↑(Nat.factorization p) q ≠ 0 → p = q\"},\n {\"role\": \"user\",\n  \"content\": \"A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 2 = 1 ↔ p ≠ 2\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For any positive `k : ℕ` there exists an arbitrarily large prime `p` such that\\n`p ≡ 1 [MOD k]`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {k : ℕ} (n : ℕ), k ≠ 0 → ∃ p, Nat.Prime p ∧ n < p ∧ p ≡ 1 [MOD k]\"},\n {\"role\": \"user\", \"content\": \"There are infinitely many odd prime numbers.\"}]"}
{"text":"If a vector space has dimension `2` then it is finite dimensional.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a vector space has a finite basis, then it is finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\\n  [inst_3 : Finite ι], Basis ι K V → FiniteDimensional K V\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a vector space has a basis indexed by elements of a finite set, then it is\\nfinite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\\n  {s : Set ι}, Basis (↑s) K V → Set.Finite s → FiniteDimensional K V\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A subspace of a finite-dimensional space is also finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K { x // x ∈ S }\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a vector space has a finite dimension, the index set of `Basis.ofVectorSpace` is finite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\\n  Module.rank K V < Cardinal.aleph0 → Set.Finite (Basis.ofVectorSpaceIndex K V)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A vector space with a nonzero vector `v` has dimension 1 iff `v` spans.\\n\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (v : V),\\n  v ≠ 0 → (FiniteDimensional.finrank K V = 1 ↔ Submodule.span K {v} = ⊤)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The dimension of a finite dimensional space is preserved under linear equivalence. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} {M : Type u_2} {M₂ : Type u_3} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : AddCommGroup M₂]\\n  [inst_3 : Module R M] [inst_4 : Module R M₂],\\n  (M ≃ₗ[R] M₂) → FiniteDimensional.finrank R M = FiniteDimensional.finrank R M₂\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a vector space has dimension `2` then it is finite dimensional.\"}]"}
{"text":"Every field is a division ring.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"A subfield is closed under division. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} [inst : Field K] (s : Subfield K) {x y : K}, x ∈ s → y ∈ s → x / y ∈ s\"},\n {\"role\": \"user\",\n  \"content\": \"An intermediate field is closed under division. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\\n  {x y : L}, x ∈ S → y ∈ S → x / y ∈ S\"},\n {\"role\": \"user\",\n  \"content\": \"All ideals in a division (semi)ring are trivial. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} [inst : DivisionSemiring K] (I : Ideal K), I = ⊥ ∨ I = ⊤\"},\n {\"role\": \"user\", \"content\": \"A valued division ring is separated. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u_1} [inst : DivisionRing K] {Γ₀ : Type u_2} [inst_1 : LinearOrderedCommGroupWithZero Γ₀]\\n  [inst_2 : Valued K Γ₀], SeparatedSpace K\"},\n {\"role\": \"user\", \"content\": \"A subring of a domain is a domain. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {S : Type v} (s : S) {R : Type u_1} [inst : Ring R] [inst_1 : IsDomain R] [inst_2 : SetLike S R]\\n  [inst_3 : SubringClass S R], IsDomain { x // x ∈ s }\"},\n {\"role\": \"user\", \"content\": \"A subring of a domain is a domain. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : Ring R] [inst_1 : IsDomain R] (s : Subring R), IsDomain { x // x ∈ s }\"},\n {\"role\": \"user\",\n  \"content\": \"A normed division ring is a topological division ring. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : NormedDivisionRing α], TopologicalDivisionRing α\"},\n {\"role\": \"user\",\n  \"content\": \"Natural division is always less than division in the field. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : LinearOrderedSemifield α] {m n : ℕ}, ↑(m / n) ≤ ↑m / ↑n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A subring of a ring with no zero divisors has no zero divisors. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : Ring R] [inst_1 : NoZeroDivisors R] (s : Subring R), NoZeroDivisors { x // x ∈ s }\"},\n {\"role\": \"user\", \"content\": \"A subfield is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} [inst : Field K] (s : Subfield K) {x y : K}, x ∈ s → y ∈ s → x * y ∈ s\"},\n {\"role\": \"user\", \"content\": \"Every field is a division ring.\"}]"}
{"text":"If a space has dimension `2` then it is finite dimensional.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A subspace of a finite-dimensional space is also finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K { x // x ∈ S }\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a vector space has a finite basis, then it is finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\\n  [inst_3 : Finite ι], Basis ι K V → FiniteDimensional K V\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a vector space has a basis indexed by elements of a finite set, then it is\\nfinite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\\n  {s : Set ι}, Basis (↑s) K V → Set.Finite s → FiniteDimensional K V\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a vector space has a finite dimension, the index set of `Basis.ofVectorSpace` is finite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\\n  Module.rank K V < Cardinal.aleph0 → Set.Finite (Basis.ofVectorSpaceIndex K V)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The dimension of a finite dimensional space is preserved under linear equivalence. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} {M : Type u_2} {M₂ : Type u_3} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : AddCommGroup M₂]\\n  [inst_3 : Module R M] [inst_4 : Module R M₂],\\n  (M ≃ₗ[R] M₂) → FiniteDimensional.finrank R M = FiniteDimensional.finrank R M₂\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A quotient of a finite-dimensional space is also finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K (V ⧸ S)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Adding a point to a finite-dimensional subspace increases the dimension by at most one. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] (s : AffineSubspace k P) (p : P),\\n  FiniteDimensional.finrank k { x // x ∈ vectorSpan k (insert p ↑s) } ≤\\n    FiniteDimensional.finrank k { x // x ∈ AffineSubspace.direction s } + 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Adding a point to a set with a finite-dimensional span increases the dimension by at most\\none. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (k : Type u_2) {V : Type u_3} {P : Type u_1} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] (s : Set P) (p : P),\\n  FiniteDimensional.finrank k { x // x ∈ vectorSpan k (insert p s) } ≤\\n    FiniteDimensional.finrank k { x // x ∈ vectorSpan k s } + 1\"},\n {\"role\": \"user\",\n  \"content\": \"If a space has dimension `2` then it is finite dimensional.\"}]"}
{"text":"Every natural number has a successor.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `n : ℕ+` is different from `1`, then it is the successor of some `k : ℕ+`. \"},\n {\"role\": \"assistant\", \"content\": \"∀ {n : ℕ+}, n ≠ 1 → ∃ k, n = k + 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {m n : ℕ}, (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n\"},\n {\"role\": \"user\", \"content\": \"Successor powers behave as expected \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_1} {A : ι → Type u_2} [inst : AddMonoid ι] [self : GradedMonoid.GMonoid A] (n : ℕ) (a : GradedMonoid A),\\n  GradedMonoid.mk (Nat.succ n • a.fst) (GradedMonoid.GMonoid.gnpow (Nat.succ n) a.snd) =\\n    a * { fst := n • a.fst, snd := GradedMonoid.GMonoid.gnpow n a.snd }\"},\n {\"role\": \"user\", \"content\": \"Successor powers behave as expected \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_1} {A : ι → Type u_2} [inst : AddMonoid ι] [inst_1 : (i : ι) → AddCommMonoid (A i)]\\n  [self : DirectSum.GSemiring A] (n : ℕ) (a : GradedMonoid A),\\n  GradedMonoid.mk (Nat.succ n • a.fst) (DirectSum.GSemiring.gnpow (Nat.succ n) a.snd) =\\n    a * { fst := n • a.fst, snd := DirectSum.GSemiring.gnpow n a.snd }\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\", \"content\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\"},\n {\"role\": \"user\",\n  \"content\": \"`a ≤ b` as natural numbers if and only if `a ≤ b` in `Fin n`. \"},\n {\"role\": \"assistant\", \"content\": \"∀ {n : ℕ} {a b : Fin n}, ↑a ≤ ↑b ↔ a ≤ b\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {m n : ℕ}, (∀ (a : ℕ), a ∣ m ↔ a ∣ n) ↔ m = n\"},\n {\"role\": \"user\", \"content\": \"Every ordinal has a fundamental sequence. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (a : Ordinal.{u}), ∃ f, Ordinal.IsFundamentalSequence a (Cardinal.ord (Ordinal.cof a)) f\"},\n {\"role\": \"user\", \"content\": \"Every natural number has a successor.\"}]"}
{"text":"Every natural number is less than its successor.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"`a ≤ b` as natural numbers if and only if `a ≤ b` in `Fin n`. \"},\n {\"role\": \"assistant\", \"content\": \"∀ {n : ℕ} {a b : Fin n}, ↑a ≤ ↑b ↔ a ≤ b\"},\n {\"role\": \"user\",\n  \"content\": \"`a < b` as natural numbers if and only if `a < b` in `Fin n`. \"},\n {\"role\": \"assistant\", \"content\": \"∀ {n : ℕ} {a b : Fin n}, ↑a < ↑b ↔ a < b\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `n : ℕ+` is different from `1`, then it is the successor of some `k : ℕ+`. \"},\n {\"role\": \"assistant\", \"content\": \"∀ {n : ℕ+}, n ≠ 1 → ∃ k, n = k + 1\"},\n {\"role\": \"user\", \"content\": \"The relation `≤` on a preorder is transitive. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : Preorder α] {a b c : α}, a ≤ b → b ≤ c → a ≤ c\"},\n {\"role\": \"user\",\n  \"content\": \"Any element of a set is more than the set infimum. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [self : CompleteBooleanAlgebra α] (s : Set α) (a : α), a ∈ s → sInf s ≤ a\"},\n {\"role\": \"user\",\n  \"content\": \"Any element of a set is more than the set infimum. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [self : CompleteLattice α] (s : Set α) (a : α), a ∈ s → sInf s ≤ a\"},\n {\"role\": \"user\",\n  \"content\": \"Any element of a set is more than the set infimum. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [self : CompleteSemilatticeInf α] (s : Set α) (a : α), a ∈ s → sInf s ≤ a\"},\n {\"role\": \"user\",\n  \"content\": \"Every natural number is less than its successor.\"}]"}
{"text":"Every set is Lebesgue measurable.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"In a `BorelSpace` all open sets are measurable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α],\\n  OpensMeasurableSpace α\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a set is a right-neighborhood of all of its points, then it is measurable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α]\\n  [inst_3 : LinearOrder α] [inst_4 : OrderTopology α] [inst_5 : TopologicalSpace.SecondCountableTopology α] {s : Set α},\\n  (∀ (x : α), x ∈ s → s ∈ nhdsWithin x (Set.Ioi x)) → MeasurableSet s\"},\n {\"role\": \"user\",\n  \"content\": \"The graph of a measurable function is a measurable set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : MeasurableSpace α] {f : α → ℝ}, Measurable f → MeasurableSet {p | p.snd = f p.fst}\"},\n {\"role\": \"user\", \"content\": \"A singleton is a measurable set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : MeasurableSpace α] [self : MeasurableSingletonClass α] (x : α), MeasurableSet {x}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A measurable set of negative measure has a negative subset of negative measure. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : MeasurableSpace α] {s : MeasureTheory.SignedMeasure α} {i : Set α},\\n  ↑s i < 0 →\\n    ∃ j,\\n      MeasurableSet j ∧\\n        j ⊆ i ∧ MeasureTheory.VectorMeasure.restrict s j ≤ MeasureTheory.VectorMeasure.restrict 0 j ∧ ↑s j < 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For the outer measure coming from a content, all Borel sets are measurable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type w} [inst : TopologicalSpace G] (μ : MeasureTheory.Content G) [inst_1 : T2Space G] [S : MeasurableSpace G]\\n  [inst_2 : BorelSpace G], S ≤ MeasureTheory.OuterMeasure.caratheodory (MeasureTheory.Content.outerMeasure μ)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For every set there exists a measurable superset of the same measure. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : MeasurableSpace α] (μ : MeasureTheory.Measure α) (s : Set α),\\n  ∃ t, s ⊆ t ∧ MeasurableSet t ∧ ↑↑μ t = ↑↑μ s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The image of a measurable set under a measurable embedding is a measurable set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : MeasurableSpace α] [inst_1 : MeasurableSpace β] {f : α → β},\\n  MeasurableEmbedding f → ∀ ⦃s : Set α⦄, MeasurableSet s → MeasurableSet (f '' s)\"},\n {\"role\": \"user\", \"content\": \"A simple function is measurable \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_2} {β : Type u_1} [inst : MeasurableSpace α] [inst_1 : MeasurableSpace β]\\n  (f : MeasureTheory.SimpleFunc α β), Measurable ↑f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every set has a measurable superset. Declare this as local instance as needed. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {m : MeasurableSpace α} (s : Set α), Nonempty { t // s ⊆ t ∧ MeasurableSet t }\"},\n {\"role\": \"user\", \"content\": \"Every set is Lebesgue measurable.\"}]"}
{"text":"Every set of Borel measure zero is Lebesgue measurable.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"In a `BorelSpace` all open sets are measurable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α],\\n  OpensMeasurableSpace α\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For the outer measure coming from a content, all Borel sets are measurable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type w} [inst : TopologicalSpace G] (μ : MeasureTheory.Content G) [inst_1 : T2Space G] [S : MeasurableSpace G]\\n  [inst_2 : BorelSpace G], S ≤ MeasureTheory.OuterMeasure.caratheodory (MeasureTheory.Content.outerMeasure μ)\"},\n {\"role\": \"user\",\n  \"content\": \"The set of Liouville numbers has Lebesgue measure zero. \"},\n {\"role\": \"assistant\",\n  \"content\": \"↑↑MeasureTheory.volume {x | Liouville x} = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A measurable set of negative measure has a negative subset of negative measure. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : MeasurableSpace α] {s : MeasureTheory.SignedMeasure α} {i : Set α},\\n  ↑s i < 0 →\\n    ∃ j,\\n      MeasurableSet j ∧\\n        j ⊆ i ∧ MeasureTheory.VectorMeasure.restrict s j ≤ MeasureTheory.VectorMeasure.restrict 0 j ∧ ↑s j < 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any Polish Borel space is measurably equivalent to a subset of the reals. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (α : Type u_1) [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : PolishSpace α]\\n  [inst : BorelSpace α], ∃ s, MeasurableSet s ∧ Nonempty (α ≃ᵐ ↑s)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a set is a right-neighborhood of all of its points, then it is measurable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α]\\n  [inst_3 : LinearOrder α] [inst_4 : OrderTopology α] [inst_5 : TopologicalSpace.SecondCountableTopology α] {s : Set α},\\n  (∀ (x : α), x ∈ s → s ∈ nhdsWithin x (Set.Ioi x)) → MeasurableSet s\"},\n {\"role\": \"user\",\n  \"content\": \"The Haar measure equals the Lebesgue measure on `ℝ`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"MeasureTheory.Measure.addHaarMeasure TopologicalSpace.PositiveCompacts.Icc01 = MeasureTheory.volume\"},\n {\"role\": \"user\",\n  \"content\": \"Every set of Borel measure zero is Lebesgue measurable.\"}]"}
{"text":"No prime number is a perfect square.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"There are no perfect squares strictly between m² and (m+1)² \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {n m : ℕ}, m * m < n → n < (m + 1) * (m + 1) → ¬∃ t, t * t = n\"},\n {\"role\": \"user\",\n  \"content\": \"The only prime factor of prime `p` is `p` itself. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {p q : ℕ}, Nat.Prime p → ↑(Nat.factorization p) q ≠ 0 → p = q\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The square of the smallest prime factor of a composite number `n` is at most `n`.\\n\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n : ℕ}, 0 < n → ¬Nat.Prime n → Nat.minFac n ^ 2 ≤ n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Lagrange's **four squares theorem** for a prime number. Use `Nat.sum_four_squares` instead. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ}, Nat.Prime p → ∃ a b c d, a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = p\"},\n {\"role\": \"user\",\n  \"content\":\n  \"`2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare 2 ↔ p % 8 = 1 ∨ p % 8 = 7)\"},\n {\"role\": \"user\", \"content\": \"No prime number is a perfect square.\"}]"}
{"text":"Every odd prime number is greater than `2`.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 2 = 1 ↔ p ≠ 2\"},\n {\"role\": \"user\", \"content\": \"`2` is not a factor of an odd natural number. \"},\n {\"role\": \"assistant\", \"content\": \"∀ {m n : ℕ}, Odd n → m ∣ n → m ≠ 2\"},\n {\"role\": \"user\",\n  \"content\":\n  \"`2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare 2 ↔ p % 8 = 1 ∨ p % 8 = 7)\"},\n {\"role\": \"user\",\n  \"content\": \"A natural number is odd iff it has residue `1` or `3` mod `4`\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n : ℕ}, n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3\"},\n {\"role\": \"user\", \"content\": \"**Lifting the exponent lemma** for odd primes. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ},\\n  Nat.Prime p →\\n    Odd p →\\n      ∀ {x y : ℤ},\\n        ↑p ∣ x - y →\\n          ¬↑p ∣ x → ∀ (n : ℕ), multiplicity (↑p) (x ^ n - y ^ n) = multiplicity (↑p) (x - y) + multiplicity p n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"`-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare (-2) ↔ p % 8 = 1 ∨ p % 8 = 3)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `1 < p`, then `q p`, the smallest prime factor of `mersenne p`, is more than 2. \"},\n {\"role\": \"assistant\", \"content\": \"∀ (p' : ℕ), 2 < LucasLehmer.q (p' + 2)\"},\n {\"role\": \"user\",\n  \"content\": \"The only prime factor of prime `p` is `p` itself. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {p q : ℕ}, Nat.Prime p → ↑(Nat.factorization p) q ≠ 0 → p = q\"},\n {\"role\": \"user\", \"content\": \"Every odd prime number is greater than `2`.\"}]"}
{"text":"The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2\"},\n {\"role\": \"user\", \"content\": \"**Four squares theorem** \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (n : ℕ), ∃ a b c d, a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n\"},\n {\"role\": \"user\",\n  \"content\": \"The sum of two squares is zero iff both elements are zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : LinearOrderedRing α] {x y : α}, x * x + y * y = 0 ↔ x = 0 ∧ y = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"**Euler's four-square identity**, a version for natural numbers. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (a b c d x y z w : ℕ),\\n  Int.natAbs (↑a * ↑x - ↑b * ↑y - ↑c * ↑z - ↑d * ↑w) ^ 2 + Int.natAbs (↑a * ↑y + ↑b * ↑x + ↑c * ↑w - ↑d * ↑z) ^ 2 +\\n        Int.natAbs (↑a * ↑z - ↑b * ↑w + ↑c * ↑x + ↑d * ↑y) ^ 2 +\\n      Int.natAbs (↑a * ↑w + ↑b * ↑z - ↑c * ↑y + ↑d * ↑x) ^ 2 =\\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2)\"},\n {\"role\": \"user\", \"content\": \"**Euler's four-square identity**. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : CommRing R] (a b c d x y z w : R),\\n  (a * x - b * y - c * z - d * w) ^ 2 + (a * y + b * x + c * w - d * z) ^ 2 + (a * z - b * w + c * x + d * y) ^ 2 +\\n      (a * w + b * z - c * y + d * x) ^ 2 =\\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2)\"},\n {\"role\": \"user\", \"content\": \"The square commutes. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {C : Type u_1} [inst : CategoryTheory.Category C] {W X Y Z : C} {f : W ⟶ X} {g : W ⟶ Y} {h : X ⟶ Z} {i : Y ⟶ Z},\\n  CategoryTheory.CommSq f g h i → CategoryTheory.CategoryStruct.comp f h = CategoryTheory.CategoryStruct.comp g i\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares.\"}]"}
{"text":"Every compact topological space is locally compact.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a locally compact space every point has a compact neighborhood. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] (x : α), ∃ K, IsCompact K ∧ K ∈ nhds x\"},\n {\"role\": \"user\", \"content\": \"A proper space is locally compact \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] [inst_1 : ProperSpace α], LocallyCompactSpace α\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a locally compact space, every compact set is contained in the interior of a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] {K : Set α},\\n  IsCompact K → ∃ K', IsCompact K' ∧ K ⊆ interior K'\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a nonempty locally compact space, there exists a compact set with nonempty interior. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : Nonempty α],\\n  Nonempty (TopologicalSpace.PositiveCompacts α)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a locally compact T₂ space, every compact set has an open neighborhood with compact closure.\\n\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α] {K : Set α},\\n  IsCompact K → ∃ V, IsOpen V ∧ K ⊆ V ∧ IsCompact (closure V)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a locally compact T₂ space, every point has an open neighborhood with compact closure \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α] (x : α),\\n  ∃ U, IsOpen U ∧ x ∈ U ∧ IsCompact (closure U)\"},\n {\"role\": \"user\",\n  \"content\": \"Every compact topological space is locally compact.\"}]"}
{"text":"Every continuous function is uniformly continuous.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"A uniform limit of continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\\n  [inst_1 : TopologicalSpace α],\\n  TendstoUniformly F f p → (∀ᶠ (n : ι) in p, Continuous (F n)) → ∀ [inst_2 : Filter.NeBot p], Continuous f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Heine-Cantor: a continuous function on a compact uniform space is uniformly\\ncontinuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : CompactSpace α] {f : α → β},\\n  Continuous f → UniformContinuous f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Heine-Cantor: a continuous function on a compact set of a uniform space is uniformly\\ncontinuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] {s : Set α} {f : α → β},\\n  IsCompact s → ContinuousOn f s → UniformContinuousOn f s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A function which can be uniformly approximated by continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} [inst_1 : TopologicalSpace α],\\n  (∀ (u : Set (β × β)), u ∈ uniformity β → ∃ F, Continuous F ∧ ∀ (y : α), (f y, F y) ∈ u) → Continuous f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Each function of a uniformly equicontinuous family is uniformly continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_1} {α : Type u_2} {β : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] {F : ι → β → α},\\n  UniformEquicontinuous F → ∀ (i : ι), UniformContinuous (F i)\"},\n {\"role\": \"user\", \"content\": \"A Lipschitz function is uniformly continuous \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : PseudoEMetricSpace α] [inst_1 : PseudoEMetricSpace β] {K : NNReal} {f : α → β},\\n  LipschitzWith K f → UniformContinuous f\"},\n {\"role\": \"user\", \"content\": \"Uniform continuity of the function \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] (self : α ≃ᵤ β),\\n  UniformContinuous self.toFun\"},\n {\"role\": \"user\",\n  \"content\": \"Every continuous function is uniformly continuous.\"}]"}
{"text":"`6` is not the sum of two distinct prime numbers.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"The only prime factor of prime `p` is `p` itself. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {p q : ℕ}, Nat.Prime p → ↑(Nat.factorization p) q ≠ 0 → p = q\"},\n {\"role\": \"user\", \"content\": \"`2` is not a factor of an odd natural number. \"},\n {\"role\": \"assistant\", \"content\": \"∀ {m n : ℕ}, Odd n → m ∣ n → m ≠ 2\"},\n {\"role\": \"user\", \"content\": \"The sine of `π / 6` is `1 / 2`. \"},\n {\"role\": \"assistant\", \"content\": \"Real.sin (Real.pi / 6) = 1 / 2\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (n : ℕ), Nat.factorization n = 0 ↔ n = 0 ∨ n = 1\"},\n {\"role\": \"user\",\n  \"content\": \"`6` is not the sum of two distinct prime numbers.\"}]"}
{"text":"No integer is irrational.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"The golden ratio is irrational. \"},\n {\"role\": \"assistant\", \"content\": \"Irrational goldenRatio\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `x^n`, `n > 0`, is integer and is not the `n`-th power of an integer, then\\n`x` is irrational. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {x : ℝ} (n : ℕ) (m : ℤ), x ^ n = ↑m → (¬∃ y, x = ↑y) → 0 < n → Irrational x\"},\n {\"role\": \"user\", \"content\": \"**Irrationality of the Square Root of 2** \"},\n {\"role\": \"assistant\", \"content\": \"Irrational (Real.sqrt 2)\"},\n {\"role\": \"user\", \"content\": \"A transcendental real number is irrational. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {r : ℝ}, Transcendental ℚ r → Irrational r\"},\n {\"role\": \"user\",\n  \"content\": \"The conjugate of the golden ratio is irrational. \"},\n {\"role\": \"assistant\", \"content\": \"Irrational goldenConj\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `x + y` is irrational, then at least one of `x` and `y` is irrational. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {x y : ℝ}, Irrational (x + y) → Irrational x ∨ Irrational y\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `x^n = m` is an integer and `n` does not divide the `multiplicity p m`, then `x`\\nis irrational. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {x : ℝ} (n : ℕ) {m : ℤ} (hm : m ≠ 0) (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  x ^ n = ↑m → Part.get (multiplicity (↑p) m) (_ : multiplicity.Finite (↑p) m) % n ≠ 0 → Irrational x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (n : ℕ), Nat.factorization n = 0 ↔ n = 0 ∨ n = 1\"},\n {\"role\": \"user\",\n  \"content\": \"The ring of integers of a number field is not a field. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (K : Type u_1) [inst : Field K] [nf : NumberField K], ¬IsField { x // x ∈ NumberField.ringOfIntegers K }\"},\n {\"role\": \"user\",\n  \"content\":\n  \"There is an irrational number `r` between any two reals `x < r < y`. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {x y : ℝ}, x < y → ∃ r, Irrational r ∧ x < r ∧ r < y\"},\n {\"role\": \"user\", \"content\": \"No integer is irrational.\"}]"}
{"text":"The identity element in a ring is a unit.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"An ideal which contains an element within `1` of `1 : R` is the unit ideal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] (I : Ideal R) {x : R}, x ∈ I → ‖1 - x‖ < 1 → I = ⊤\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two non-unital subrings are equal if they have the same elements. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : NonUnitalNonAssocRing R] {S T : NonUnitalSubring R}, (∀ (x : R), x ∈ S ↔ x ∈ T) → S = T\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A prime that does not divide the cardinality of a finite commutative ring `R`\\nis a unit in `R`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (p : ℕ) [inst_2 : Fact (Nat.Prime p)],\\n  p ∣ Fintype.card R → ¬IsUnit ↑p\"},\n {\"role\": \"user\",\n  \"content\":\n  \"An element of a ring multiplied by the additive inverse of one is the element's additive\\ninverse. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : MulOneClass α] [inst_1 : HasDistribNeg α] (a : α), a * -1 = -a\"},\n {\"role\": \"user\",\n  \"content\": \"Units of a monoid divide any element of the monoid. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u_1} [inst : Monoid α] {a u : α}, IsUnit u → u ∣ a\"},\n {\"role\": \"user\", \"content\": \"Nonzero elements have multiplicative inverses. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : Semiring R], IsField R → ∀ {a : R}, a ≠ 0 → ∃ b, a * b = 1\"},\n {\"role\": \"user\", \"content\": \"The identity element in a ring is a unit.\"}]"}
{"text":"Every subgroup of a group is a group.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A subgroup is either the trivial subgroup or contains a non-identity element. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), H = ⊥ ∨ ∃ x, x ∈ H ∧ x ≠ 1\"},\n {\"role\": \"user\",\n  \"content\": \"A subgroup is either the trivial subgroup or nontrivial. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), H = ⊥ ∨ Nontrivial { x // x ∈ H }\"},\n {\"role\": \"user\",\n  \"content\": \"A subgroup is either the trivial subgroup or nontrivial.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] (H : AddSubgroup G), H = ⊥ ∨ Nontrivial { x // x ∈ H }\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A subgroup is either the trivial subgroup or contains a nonzero element.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] (H : AddSubgroup G), H = ⊥ ∨ ∃ x, x ∈ H ∧ x ≠ 0\"},\n {\"role\": \"user\",\n  \"content\": \"The subgroup generated by a set includes the set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] {k : Set G}, k ⊆ ↑(Subgroup.closure k)\"},\n {\"role\": \"user\",\n  \"content\": \"Two subgroups are equal if they have the same elements. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] {H K : Subgroup G}, (∀ (x : G), x ∈ H ↔ x ∈ K) → H = K\"},\n {\"role\": \"user\", \"content\": \"A subgroup is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x ∈ H → y ∈ H → x * y ∈ H\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If the quotient by a subgroup gives a singleton then the subgroup is the whole group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u} [inst : Group G] (H : Subgroup G), Subsingleton (G ⧸ H) → H = ⊤\"},\n {\"role\": \"user\", \"content\": \"A subgroup contains the group's 1. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), 1 ∈ H\"},\n {\"role\": \"user\", \"content\": \"A subgroup is closed under inverse. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x : G}, x ∈ H → x⁻¹ ∈ H\"},\n {\"role\": \"user\", \"content\": \"Every subgroup of a group is a group.\"}]"}
{"text":"The sum of two natural numbers is a natural number.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {m n : ℕ}, (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A natural number `m` divides the sum `m + n` if and only if `m` divides `n`.\"},\n {\"role\": \"assistant\", \"content\": \"∀ {m n : ℕ}, m ∣ m + n ↔ m ∣ n\"},\n {\"role\": \"user\",\n  \"content\": \"A sum of numbers is infinite iff one of them is infinite \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {s : Finset α} {f : α → ENNReal}, (Finset.sum s fun x => f x) = ⊤ ↔ ∃ a, a ∈ s ∧ f a = ⊤\"},\n {\"role\": \"user\",\n  \"content\": \"A sum of numbers is infinite iff one of them is infinite \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_2} {M : Type u_1} [inst : AddCommMonoid M] {s : Finset ι} {f : ι → WithTop M},\\n  (Finset.sum s fun i => f i) = ⊤ ↔ ∃ i, i ∈ s ∧ f i = ⊤\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A natural number `m` divides the sum `n + m` if and only if `m` divides `n`.\"},\n {\"role\": \"assistant\", \"content\": \"∀ {m n : ℕ}, m ∣ n + m ↔ m ∣ n\"},\n {\"role\": \"user\", \"content\": \"A sum of finite numbers is still finite \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_2} {M : Type u_1} [inst : AddCommMonoid M] [inst_1 : LT M] {s : Finset ι} {f : ι → WithTop M},\\n  (∀ (i : ι), i ∈ s → f i ≠ ⊤) → (Finset.sum s fun i => f i) < ⊤\"},\n {\"role\": \"user\", \"content\": \"A sum of finite numbers is still finite \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_2} {M : Type u_1} [inst : AddCommMonoid M] [inst_1 : LT M] {s : Finset ι} {f : ι → WithTop M},\\n  (Finset.sum s fun i => f i) < ⊤ ↔ ∀ (i : ι), i ∈ s → f i < ⊤\"},\n {\"role\": \"user\", \"content\": \"A sum of finite numbers is still finite \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {s : Finset α} {f : α → ENNReal}, (Finset.sum s fun a => f a) < ⊤ ↔ ∀ (a : α), a ∈ s → f a < ⊤\"},\n {\"role\": \"user\", \"content\": \"A sum of finite numbers is still finite \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {s : Finset α} {f : α → ENNReal}, (∀ (a : α), a ∈ s → f a ≠ ⊤) → (Finset.sum s fun a => f a) < ⊤\"},\n {\"role\": \"user\",\n  \"content\": \"The sum of two natural numbers is a natural number.\"}]"}
{"text":"The identity element of a group has finite order.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"A group element has finite order iff its order is positive. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x ↔ IsOfFinOrder x\"},\n {\"role\": \"user\",\n  \"content\": \"Inverses of elements of finite order have finite order. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x → IsOfFinOrder x⁻¹\"},\n {\"role\": \"user\",\n  \"content\": \"Inverses of elements of finite order have finite order. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x⁻¹ ↔ IsOfFinOrder x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A group element has finite additive order iff its order is positive.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : AddMonoid G] {x : G}, 0 < addOrderOf x ↔ IsOfFinAddOrder x\"},\n {\"role\": \"user\",\n  \"content\": \"The image of an element of finite order has finite order. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_2} {H : Type u_1} [inst : Monoid G] [inst_1 : Monoid H] (f : G →* H) {x : G},\\n  IsOfFinOrder x → IsOfFinOrder (↑f x)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Inverses of elements of finite additive order have finite additive order.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] {x : G}, IsOfFinAddOrder x → IsOfFinAddOrder (-x)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Inverses of elements of finite additive order\\nhave finite additive order.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] {x : G}, IsOfFinAddOrder (-x) ↔ IsOfFinAddOrder x\"},\n {\"role\": \"user\",\n  \"content\": \"Elements of finite order are closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : CommMonoid G] {x y : G}, IsOfFinOrder x → IsOfFinOrder y → IsOfFinOrder (x * y)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Commuting elements of finite order are closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Monoid G] {x y : G}, Commute x y → IsOfFinOrder x → IsOfFinOrder y → IsOfFinOrder (x * y)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The image of an element of finite additive order has finite additive order.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_2} {H : Type u_1} [inst : AddMonoid G] [inst_1 : AddMonoid H] (f : G →+ H) {x : G},\\n  IsOfFinAddOrder x → IsOfFinAddOrder (↑f x)\"},\n {\"role\": \"user\",\n  \"content\": \"The identity element of a group has finite order.\"}]"}
{"text":"`7` is a prime number.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"The only prime factor of prime `p` is `p` itself. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {p q : ℕ}, Nat.Prime p → ↑(Nat.factorization p) q ≠ 0 → p = q\"},\n {\"role\": \"user\",\n  \"content\":\n  \"`2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare 2 ↔ p % 8 = 1 ∨ p % 8 = 7)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (n : ℕ), Nat.factorization n = 0 ↔ n = 0 ∨ n = 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a small natural number is divisible by a larger natural number,\\nthe small number is zero. \"},\n {\"role\": \"assistant\", \"content\": \"∀ {a b : ℕ}, a ∣ b → b < a → b = 0\"},\n {\"role\": \"user\",\n  \"content\": \"All composite numbers are Fermat pseudoprimes to base 1.\\n\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n : ℕ}, 1 < n → ¬Nat.Prime n → FermatPsp n 1\"},\n {\"role\": \"user\",\n  \"content\": \"The only divisors of prime powers are prime powers. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [dec_irr : (p : Associates α) → Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid α] [dec : DecidableEq α] [dec' : DecidableEq (Associates α)] {a p : Associates α},\\n  Irreducible p →\\n    ∀ [inst_2 : (n : ℕ) → Decidable (a ∣ p ^ n)] {n : ℕ} (h : a ∣ p ^ n),\\n      a = p ^ Nat.find (_ : ∃ n, (fun n => a ∣ p ^ n) n)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"**Wilson's Theorem**: For `n ≠ 1`, `(n-1)!` is congruent to `-1` modulo `n` iff n is prime. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {n : ℕ}, n ≠ 1 → (Nat.Prime n ↔ ↑(Nat.factorial (n - 1)) = -1)\"},\n {\"role\": \"user\", \"content\": \"`2` is not a factor of an odd natural number. \"},\n {\"role\": \"assistant\", \"content\": \"∀ {m n : ℕ}, Odd n → m ∣ n → m ≠ 2\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The only prime factor of prime `p` is `p` itself, with multiplicity `1` \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ}, Nat.Prime p → Nat.factorization p = Finsupp.single p 1\"},\n {\"role\": \"user\", \"content\": \"`7` is a prime number.\"}]"}
{"text":"There are `3` prime numbers below `8`.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"The only prime factor of prime `p` is `p` itself. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {p q : ℕ}, Nat.Prime p → ↑(Nat.factorization p) q ≠ 0 → p = q\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A prime natural number is prime in `ℤ[i]` if and only if it is `3` mod `4` \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)], Prime ↑p ↔ p % 4 = 3\"},\n {\"role\": \"user\",\n  \"content\":\n  \"`2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare 2 ↔ p % 8 = 1 ∨ p % 8 = 7)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For any natural numbers n, a, and b, one of the following holds:\\n1. n < a\\n2. n ≥ b\\n3. n ∈ Ico a b\\n\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (n a b : ℕ), n < a ∨ b ≤ n ∨ n ∈ List.Ico a b\"},\n {\"role\": \"user\",\n  \"content\":\n  \"`-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare (-2) ↔ p % 8 = 1 ∨ p % 8 = 3)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The square of the smallest prime factor of a composite number `n` is at most `n`.\\n\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n : ℕ}, 0 < n → ¬Nat.Prime n → Nat.minFac n ^ 2 ≤ n\"},\n {\"role\": \"user\", \"content\": \"There are `3` prime numbers below `8`.\"}]"}
{"text":"The empty set is contained in every finite set.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"There are finitely many subsets of a given finite set \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {a : Set α}, Set.Finite a → Set.Finite {b | b ⊆ a}\"},\n {\"role\": \"user\",\n  \"content\": \"The (open) thickening of the empty set is empty. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : PseudoEMetricSpace α] (δ : ℝ), Metric.thickening δ ∅ = ∅\"},\n {\"role\": \"user\", \"content\": \"The upper shadow of the empty set is empty. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : DecidableEq α] [inst_1 : Fintype α], Finset.upShadow ∅ = ∅\"},\n {\"role\": \"user\", \"content\": \"The shadow of the empty set is empty. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u_1} [inst : DecidableEq α], Finset.shadow ∅ = ∅\"},\n {\"role\": \"user\", \"content\": \"`⊥`, coerced to a set, is the empty set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (k : Type u_2) (V : Type u_3) (P : Type u_1) [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [S : AddTorsor V P], ↑⊥ = ∅\"},\n {\"role\": \"user\", \"content\": \"The supremum of the empty set is `⊥` \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [self : ConditionallyCompleteLinearOrderBot α], sSup ∅ = ⊥\"},\n {\"role\": \"user\",\n  \"content\": \"The closed thickening of the empty set is empty. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : PseudoEMetricSpace α] (δ : ℝ), Metric.cthickening δ ∅ = ∅\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If all sets in a collection are either `∅` or `Set.univ`, then so is their union. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {S : Set (Set α)}, S ⊆ {∅, Set.univ} → ⋃₀ S ∈ {∅, Set.univ}\"},\n {\"role\": \"user\", \"content\": \"The empty set is contained in every finite set.\"}]"}
{"text":"Every infinite set contains a finite set.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"There are finitely many subsets of a given finite set \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {a : Set α}, Set.Finite a → Set.Finite {b | b ⊆ a}\"},\n {\"role\": \"user\",\n  \"content\": \"The set of finite subsets of a countable set is countable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {s : Set α}, Set.Countable s → Set.Countable {t | Set.Finite t ∧ t ⊆ s}\"},\n {\"role\": \"user\", \"content\": \"Finite product of finite sets is finite \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {δ : Type u_1} [inst : Finite δ] {κ : δ → Type u_2} {t : (d : δ) → Set (κ d)},\\n  (∀ (d : δ), Set.Finite (t d)) → Set.Finite (Set.pi Set.univ t)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `s : Set α` is a proper subset of `α` and `f : s → α` is surjective, then `α` is infinite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {s : Set α}, s ≠ Set.univ → ∀ {f : ↑s → α}, Function.Surjective f → Infinite α\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A finite union of sets which are all bounded above is still bounded above.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : SemilatticeSup α] [inst_1 : Nonempty α] {I : Set β} {S : β → Set α},\\n  Set.Finite I → (BddAbove (⋃ (i : β) (_ : i ∈ I), S i) ↔ ∀ (i : β), i ∈ I → BddAbove (S i))\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `s : Set α` is a proper subset of `α` and `f : α → s` is injective, then `α` is infinite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {s : Set α}, s ≠ Set.univ → ∀ {f : α → ↑s}, Function.Injective f → Infinite α\"},\n {\"role\": \"user\", \"content\": \"A finite set is bounded \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α}, Set.Finite s → Metric.Bounded s\"},\n {\"role\": \"user\", \"content\": \"Every infinite set contains a finite set.\"}]"}
{"text":"Every commutative ring is a monoid.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a monoid with zero, if zero equals one, then zero is the only element. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {M₀ : Type u_1} [inst : MulZeroOneClass M₀], 0 = 1 → ∀ (a : M₀), a = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The set of natural number powers of an element of a monoid is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {M : Type u_1} [inst : Monoid M] {x y z : M}, y ∈ powers x → z ∈ powers x → y * z ∈ powers x\"},\n {\"role\": \"user\",\n  \"content\": \"Right multiplication in a ring is an additive monoid morphism. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {γ : Type u_1} [inst : NonUnitalNonAssocSemiring γ] (x : γ), IsAddMonoidHom fun y => y * x\"},\n {\"role\": \"user\",\n  \"content\": \"Left multiplication in a ring is an additive monoid morphism. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {γ : Type u_1} [inst : NonUnitalNonAssocSemiring γ] (x : γ), IsAddMonoidHom fun y => x * y\"},\n {\"role\": \"user\",\n  \"content\":\n  \"An additive monoid with one has characteristic zero if the canonical map `ℕ → R` is\\ninjective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : AddMonoidWithOne R] [self : CharZero R], Function.Injective Nat.cast\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a monoid with zero, either zero and one are nonequal, or zero is the only element. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {M₀ : Type u_1} [inst : MulZeroOneClass M₀], 0 ≠ 1 ∨ ∀ (a : M₀), a = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a monoid with zero, zero equals one if and only if all elements of that semiring\\nare equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {M₀ : Type u_1} [inst : MulZeroOneClass M₀], 0 = 1 ↔ Subsingleton M₀\"},\n {\"role\": \"user\",\n  \"content\":\n  \"An element of a monoid is in the set of that element's natural number powers. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {M : Type u_1} [inst : Monoid M] {x : M}, x ∈ powers x\"},\n {\"role\": \"user\",\n  \"content\": \"If `R` is a monoid, an element in `Rˣ` is regular. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {R : Type u_1} [inst : Monoid R] (a : Rˣ), IsRegular ↑a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Multiplication is monotone in an ordered cancellative commutative monoid. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [self : OrderedCancelCommMonoid α] (a b : α), a ≤ b → ∀ (c : α), c * a ≤ c * b\"},\n {\"role\": \"user\", \"content\": \"Every commutative ring is a monoid.\"}]"}
{"text":"There is no field of order `10`.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"`ℤ` with its usual ring structure is not a field. \"},\n {\"role\": \"assistant\", \"content\": \"¬IsField ℤ\"},\n {\"role\": \"user\",\n  \"content\": \"The ring of integers of a number field is not a field. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (K : Type u_1) [inst : Field K] [nf : NumberField K], ¬IsField { x // x ∈ NumberField.ringOfIntegers K }\"},\n {\"role\": \"user\", \"content\": \"A subfield contains the field's 0. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {K : Type u} [inst : Field K] (s : Subfield K), 0 ∈ s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A `Fintype` can be given a field structure iff its cardinality is a prime power. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : Fintype α], Nonempty (Field α) ↔ IsPrimePow (Fintype.card α)\"},\n {\"role\": \"user\", \"content\": \"A subfield contains the field's 1. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {K : Type u} [inst : Field K] (s : Subfield K), 1 ∈ s\"},\n {\"role\": \"user\",\n  \"content\": \"The only closed subfields of `ℂ` are `ℝ` and `ℂ`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Subfield ℂ}, IsClosed ↑K → K = RingHom.fieldRange Complex.ofReal ∨ K = ⊤\"},\n {\"role\": \"user\", \"content\": \"A discrete valuation ring `R` is not a field. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (R : Type u) [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R], ¬IsField R\"},\n {\"role\": \"user\",\n  \"content\":\n  \"There is a field structure on type if and only if its cardinality is a prime power. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u}, Nonempty (Field α) ↔ IsPrimePow (Cardinal.mk α)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The number of embeddings of a number field is equal to its finrank. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (K : Type u_2) [inst : Field K] [inst_1 : NumberField K] (A : Type u_1) [inst_2 : Field A] [inst_3 : CharZero A]\\n  [inst_4 : IsAlgClosed A], Fintype.card (K →+* A) = FiniteDimensional.finrank ℚ K\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a finite field of odd characteristic, not every element is a square. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F ≠ 2 → ∃ a, ¬IsSquare a\"},\n {\"role\": \"user\", \"content\": \"There is no field of order `10`.\"}]"}
{"text":"Every odd natural number is the sum of two distinct natural numbers.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"`2` is not a factor of an odd natural number. \"},\n {\"role\": \"assistant\", \"content\": \"∀ {m n : ℕ}, Odd n → m ∣ n → m ≠ 2\"},\n {\"role\": \"user\",\n  \"content\": \"If `n` is odd and `a` is even, then `n % a` is odd. \"},\n {\"role\": \"assistant\", \"content\": \"∀ {n a : ℕ}, Odd n → Even a → Odd (n % a)\"},\n {\"role\": \"user\",\n  \"content\": \"If `a` is even, then `n` is odd iff `n % a` is odd. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n a : ℕ}, Even a → (Odd (n % a) ↔ Odd n)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {m n : ℕ}, (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n\"},\n {\"role\": \"user\",\n  \"content\": \"A sum of numbers is infinite iff one of them is infinite \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_2} {M : Type u_1} [inst : AddCommMonoid M] {s : Finset ι} {f : ι → WithTop M},\\n  (Finset.sum s fun i => f i) = ⊤ ↔ ∃ i, i ∈ s ∧ f i = ⊤\"},\n {\"role\": \"user\",\n  \"content\": \"A sum of numbers is infinite iff one of them is infinite \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {s : Finset α} {f : α → ENNReal}, (Finset.sum s fun x => f x) = ⊤ ↔ ∃ a, a ∈ s ∧ f a = ⊤\"},\n {\"role\": \"user\",\n  \"content\": \"A natural number is odd iff it has residue `1` or `3` mod `4`\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n : ℕ}, n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n : ℕ}, IsSquare (-1) → ∃ x y, n = x ^ 2 + y ^ 2\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every odd natural number is the sum of two distinct natural numbers.\"}]"}
{"text":"Every element in the trivial group has finite order.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"A group element has finite order iff its order is positive. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x ↔ IsOfFinOrder x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A group element has finite additive order iff its order is positive.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : AddMonoid G] {x : G}, 0 < addOrderOf x ↔ IsOfFinAddOrder x\"},\n {\"role\": \"user\",\n  \"content\": \"The image of an element of finite order has finite order. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_2} {H : Type u_1} [inst : Monoid G] [inst_1 : Monoid H] (f : G →* H) {x : G},\\n  IsOfFinOrder x → IsOfFinOrder (↑f x)\"},\n {\"role\": \"user\",\n  \"content\": \"Inverses of elements of finite order have finite order. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x⁻¹ ↔ IsOfFinOrder x\"},\n {\"role\": \"user\",\n  \"content\": \"Inverses of elements of finite order have finite order. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x → IsOfFinOrder x⁻¹\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The image of an element of finite additive order has finite additive order.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_2} {H : Type u_1} [inst : AddMonoid G] [inst_1 : AddMonoid H] (f : G →+ H) {x : G},\\n  IsOfFinAddOrder x → IsOfFinAddOrder (↑f x)\"},\n {\"role\": \"user\",\n  \"content\": \"Elements of finite order are closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : CommMonoid G] {x y : G}, IsOfFinOrder x → IsOfFinOrder y → IsOfFinOrder (x * y)\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is simple.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleAddGroup α\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is simple. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleGroup α\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a direct product has finite order then so does each component. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {η : Type u_1} {Gs : η → Type u_2} [inst : (i : η) → Monoid (Gs i)] {x : (i : η) → Gs i},\\n  IsOfFinOrder x → ∀ (i : η), IsOfFinOrder (x i)\"},\n {\"role\": \"user\",\n  \"content\": \"Every element in the trivial group has finite order.\"}]"}
{"text":"The square of an even number is even.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"If `n` is odd and `a` is even, then `n % a` is odd. \"},\n {\"role\": \"assistant\", \"content\": \"∀ {n a : ℕ}, Odd n → Even a → Odd (n % a)\"},\n {\"role\": \"user\",\n  \"content\": \"If `n` is even and `a` is even, then `n % a` is even. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n a : ℕ}, Even n → Even a → Even (n % a)\"},\n {\"role\": \"user\",\n  \"content\": \"If `a` is even, then `n` is odd iff `n % a` is odd. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n a : ℕ}, Even a → (Odd (n % a) ↔ Odd n)\"},\n {\"role\": \"user\",\n  \"content\": \"If `a` is even, then `n` is even iff `n % a` is even. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n a : ℕ}, Even a → (Even (n % a) ↔ Even n)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"`2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare 2 ↔ p % 8 = 1 ∨ p % 8 = 7)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n : ℕ}, IsSquare (-1) → ∃ x y, n = x ^ 2 + y ^ 2\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a finite field of odd characteristic, not every element is a square. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F ≠ 2 → ∃ a, ¬IsSquare a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `-1` is a square modulo `n` and `m` divides `n`, then `-1` is also a square modulo `m`. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {m n : ℕ}, m ∣ n → IsSquare (-1) → IsSquare (-1)\"},\n {\"role\": \"user\", \"content\": \"The square of an even number is even.\"}]"}
{"text":"Every commutative division ring is a field.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"All ideals in a division (semi)ring are trivial. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} [inst : DivisionSemiring K] (I : Ideal K), I = ⊥ ∨ I = ⊤\"},\n {\"role\": \"user\", \"content\": \"A subfield is closed under division. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} [inst : Field K] (s : Subfield K) {x y : K}, x ∈ s → y ∈ s → x / y ∈ s\"},\n {\"role\": \"user\",\n  \"content\": \"An intermediate field is closed under division. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\\n  {x y : L}, x ∈ S → y ∈ S → x / y ∈ S\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The quotient of a ring by an ideal is a field iff the ideal is maximal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I ↔ IsField (R ⧸ I)\"},\n {\"role\": \"user\",\n  \"content\": \"A normed division ring is a topological division ring. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : NormedDivisionRing α], TopologicalDivisionRing α\"},\n {\"role\": \"user\", \"content\": \"A subfield is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} [inst : Field K] (s : Subfield K) {x y : K}, x ∈ s → y ∈ s → x * y ∈ s\"},\n {\"role\": \"user\", \"content\": \"A valued division ring is separated. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u_1} [inst : DivisionRing K] {Γ₀ : Type u_2} [inst_1 : LinearOrderedCommGroupWithZero Γ₀]\\n  [inst_2 : Valued K Γ₀], SeparatedSpace K\"},\n {\"role\": \"user\", \"content\": \"Fields are commutative. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : Semiring R], IsField R → ∀ (x y : R), x * y = y * x\"},\n {\"role\": \"user\", \"content\": \"A subring of a domain is a domain. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {S : Type v} (s : S) {R : Type u_1} [inst : Ring R] [inst_1 : IsDomain R] [inst_2 : SetLike S R]\\n  [inst_3 : SubringClass S R], IsDomain { x // x ∈ s }\"},\n {\"role\": \"user\", \"content\": \"A subring of a domain is a domain. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : Ring R] [inst_1 : IsDomain R] (s : Subring R), IsDomain { x // x ∈ s }\"},\n {\"role\": \"user\", \"content\": \"Every commutative division ring is a field.\"}]"}
{"text":"The image of the identity element under the identity map is the identity element.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"The identity map is a monoid homomorphism. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u} [inst : MulOneClass α], IsMonoidHom id\"},\n {\"role\": \"user\", \"content\": \"The identity map is a ring homomorphism. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u} [inst : Ring α], IsRingHom id\"},\n {\"role\": \"user\", \"content\": \"The identity map preserves multiplication. \"},\n {\"role\": \"assistant\", \"content\": \"∀ {α : Type u} [inst : Mul α], IsMulHom id\"},\n {\"role\": \"user\", \"content\": \"The identity is a group homomorphism. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u} [inst : Group α], IsGroupHom id\"},\n {\"role\": \"user\",\n  \"content\": \"The identity map is an additive monoid homomorphism.\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u} [inst : AddZeroClass α], IsAddMonoidHom id\"},\n {\"role\": \"user\", \"content\": \"The identity map preserves addition\"},\n {\"role\": \"assistant\", \"content\": \"∀ {α : Type u} [inst : Add α], IsAddHom id\"},\n {\"role\": \"user\", \"content\": \"`map` of `f` preserves the identity morphism. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {f : Type u₀ → Type u₁} [self : EquivFunctor f] (α : Type u₀), EquivFunctor.map (Equiv.refl α) = id\"},\n {\"role\": \"user\", \"content\": \"The identity is an additive group homomorphism.\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u} [inst : AddGroup α], IsAddGroupHom id\"},\n {\"role\": \"user\", \"content\": \"The identity map is a semiring homomorphism. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u} [inst : Semiring α], IsSemiringHom id\"},\n {\"role\": \"user\", \"content\": \"The identity affine map acts as the identity. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (k : Type u_3) {V1 : Type u_2} {P1 : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V1] [inst_2 : Module k V1]\\n  [inst_3 : AddTorsor V1 P1] (p : P1), ↑(AffineMap.id k P1) p = p\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The image of the identity element under the identity map is the identity element.\"}]"}
{"text":"Every point is a fixed point of the identity function on a space.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"Every point is a fixed point of `id`. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u} (x : α), Function.IsFixedPt id x\"},\n {\"role\": \"user\", \"content\": \"For the identity map, all points are periodic. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u_1} (n : ℕ) (x : α), Function.IsPeriodicPt id n x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `x` is a fixed point of `f`, then it is a fixed point of `f^[n]`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {f : α → α} {x : α}, Function.IsFixedPt f x → ∀ (n : ℕ), Function.IsFixedPt f^[n] x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `x` is a fixed point of `f ∘ g` and `g`, then it is a fixed point of `f`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {f g : α → α} {x : α}, Function.IsFixedPt (f ∘ g) x → Function.IsFixedPt g x → Function.IsFixedPt f x\"},\n {\"role\": \"user\",\n  \"content\": \"The set of fixed points of a continuous map is a closed set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : T2Space α] {f : α → α},\\n  Continuous f → IsClosed (Function.fixedPoints f)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A fixed point of `f` is a periodic point of `f` of any prescribed period. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {f : α → α} {x : α}, Function.IsFixedPt f x → ∀ (n : ℕ), Function.IsPeriodicPt f n x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any map `f` sends fixed points of `g ∘ f` to fixed points of `f ∘ g`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} (f : α → β) (g : β → α),\\n  Set.MapsTo f (Function.fixedPoints (g ∘ f)) (Function.fixedPoints (f ∘ g))\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `x` is a fixed point of `f` and `g`, then it is a fixed point of `f ∘ g`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {f g : α → α} {x : α}, Function.IsFixedPt f x → Function.IsFixedPt g x → Function.IsFixedPt (f ∘ g) x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `x` is a fixed point of `f` and `g` is a left inverse of `f`, then `x` is a fixed\\npoint of `g`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {f g : α → α} {x : α}, Function.IsFixedPt f x → Function.LeftInverse g f → Function.IsFixedPt g x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every point is a fixed point of the identity function on a space.\"}]"}
{"text":"The diameter of a singleton space is `0`.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"A singleton has zero diameter \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0\"},\n {\"role\": \"user\", \"content\": \"The diameter of a singleton vanishes \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : PseudoEMetricSpace α] {x : α}, EMetric.diam {x} = 0\"},\n {\"role\": \"user\", \"content\": \"The diameter of the empty set vanishes \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : PseudoEMetricSpace α], EMetric.diam ∅ = 0\"},\n {\"role\": \"user\", \"content\": \"The empty set has zero diameter \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u} [inst : PseudoMetricSpace α], Metric.diam ∅ = 0\"},\n {\"role\": \"user\", \"content\": \"The diameter of a subsingleton vanishes. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : PseudoEMetricSpace α] {s : Set α}, Set.Subsingleton s → EMetric.diam s = 0\"},\n {\"role\": \"user\", \"content\": \"The diameter of a set is always nonnegative \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α}, 0 ≤ Metric.diam s\"},\n {\"role\": \"user\",\n  \"content\": \"The diameter is monotonous with respect to inclusion \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : PseudoEMetricSpace α] {s t : Set α}, s ⊆ t → EMetric.diam s ≤ EMetric.diam t\"},\n {\"role\": \"user\",\n  \"content\": \"An isometry preserves the diameter in pseudometric spaces. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : PseudoMetricSpace α] [inst_1 : PseudoMetricSpace β] {f : α → β},\\n  Isometry f → ∀ (s : Set α), Metric.diam (f '' s) = Metric.diam s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The minimal distance to a singleton is the distance to the unique point in this singleton \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {x y : α}, Metric.infDist x {y} = dist x y\"},\n {\"role\": \"user\", \"content\": \"The diameter of a singleton space is `0`.\"}]"}
{"text":"Every group is non-empty.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"The inverse of `0` in a group with zero is `0`. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {G₀ : Type u_1} [self : CommGroupWithZero G₀], 0⁻¹ = 0\"},\n {\"role\": \"user\",\n  \"content\": \"The inverse of `0` in a group with zero is `0`. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {G₀ : Type u} [self : GroupWithZero G₀], 0⁻¹ = 0\"},\n {\"role\": \"user\",\n  \"content\": \"The inverse of `0` in a group with zero is `0`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [self : LinearOrderedCommGroupWithZero α], 0⁻¹ = 0\"},\n {\"role\": \"user\",\n  \"content\": \"The inverse of `0` in a group with zero is `0`. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u_1} [self : Semifield α], 0⁻¹ = 0\"},\n {\"role\": \"user\",\n  \"content\": \"The inverse of `0` in a group with zero is `0`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [self : CanonicallyLinearOrderedSemifield α], 0⁻¹ = 0\"},\n {\"role\": \"user\",\n  \"content\": \"The inverse of `0` in a group with zero is `0`. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u_1} [self : LinearOrderedSemifield α], 0⁻¹ = 0\"},\n {\"role\": \"user\",\n  \"content\": \"The inverse of `0` in a group with zero is `0`. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u_1} [self : DivisionSemiring α], 0⁻¹ = 0\"},\n {\"role\": \"user\", \"content\": \"The category of groups has all limits. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"CategoryTheory.Limits.HasLimitsOfSize.{v, v, max u v, max (u + 1) (v + 1)} GroupCatMax\"},\n {\"role\": \"user\",\n  \"content\": \"Two subsemigroups are equal if they have the same elements. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {M : Type u_1} [inst : Mul M] {S T : Subsemigroup M}, (∀ (x : M), x ∈ S ↔ x ∈ T) → S = T\"},\n {\"role\": \"user\",\n  \"content\": \"Two subgroups are equal if they have the same elements. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] {H K : Subgroup G}, (∀ (x : G), x ∈ H ↔ x ∈ K) → H = K\"},\n {\"role\": \"user\", \"content\": \"Every group is non-empty.\"}]"}
{"text":"All connected components of a topological space are connected.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"Each connected component of the category is connected. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {J : Type u₁} [inst : CategoryTheory.Category J] (j : CategoryTheory.ConnectedComponents J),\\n  CategoryTheory.IsConnected (CategoryTheory.Component j)\"},\n {\"role\": \"user\", \"content\": \"A connected space is nonempty. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [self : ConnectedSpace α], Nonempty α\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A space is totally disconnected iff its connected components are singletons. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α], TotallyDisconnectedSpace α ↔ ∀ (x : α), connectedComponent x = {x}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A space is totally disconnected iff its connected components are subsingletons. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α],\\n  TotallyDisconnectedSpace α ↔ ∀ (x : α), Set.Subsingleton (connectedComponent x)\"},\n {\"role\": \"user\",\n  \"content\": \"The image of a connected set is connected as well. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {s : Set α},\\n  IsConnected s → ∀ (f : α → β), ContinuousOn f s → IsConnected (f '' s)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The image of a connected component in a totally disconnected space is a singleton. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {β : Type u_1} [inst_1 : TopologicalSpace β]\\n  [inst_2 : TotallyDisconnectedSpace β] {f : α → β}, Continuous f → ∀ (a : α), f '' connectedComponent a = {f a}\"},\n {\"role\": \"user\",\n  \"content\": \"The closure of a connected set is connected as well. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, IsConnected s → IsConnected (closure s)\"},\n {\"role\": \"user\",\n  \"content\": \"A clopen set is the union of its connected components. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {Z : Set α}, IsClopen Z → ⋃ (x : α) (_ : x ∈ Z), connectedComponent x = Z\"},\n {\"role\": \"user\",\n  \"content\": \"Each connected component of the category is nonempty. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {J : Type u₁} [inst : CategoryTheory.Category J] (j : CategoryTheory.ConnectedComponents J),\\n  Nonempty (CategoryTheory.Component j)\"},\n {\"role\": \"user\",\n  \"content\": \"All connected components of a topological space are connected.\"}]"}
{"text":"The ring of integers has a maximal ideal.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"Krull's theorem: a nontrivial ring has a maximal ideal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (α : Type u) [inst : Semiring α] [inst_1 : Nontrivial α], ∃ M, Ideal.IsMaximal M\"},\n {\"role\": \"user\",\n  \"content\": \"When a ring is not a field, the maximal ideals are nontrivial. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : CommSemiring R] [inst_1 : Nontrivial R] {M : Ideal R}, Ideal.IsMaximal M → ¬IsField R → M ≠ ⊥\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If the quotient by an ideal is a field, then the ideal is maximal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : CommRing R] (I : Ideal R), IsField (R ⧸ I) → Ideal.IsMaximal I\"},\n {\"role\": \"user\",\n  \"content\": \"This ideal is maximal in the collection of proper ideals. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {P : Type u_1} [inst : LE P] {I : Order.Ideal P} [self : Order.Ideal.IsMaximal I] ⦃J : Order.Ideal P⦄,\\n  I < J → ↑J = Set.univ\"},\n {\"role\": \"user\",\n  \"content\": \"Nonzero fractional ideals contain a nonzero integer. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\\n  [inst_3 : IsFractionRing R K] {I : FractionalIdeal (nonZeroDivisors R) K} [inst_4 : Nontrivial R],\\n  I ≠ 0 → ∃ x x_1, ↑(algebraMap R K) x ∈ I\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The quotient of a ring by an ideal is a field iff the ideal is maximal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I ↔ IsField (R ⧸ I)\"},\n {\"role\": \"user\",\n  \"content\": \"The only constant in a maximal ideal over a field is `0`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : Ring R],\\n  IsField R → ∀ (I : Ideal (Polynomial R)) [hI : Ideal.IsMaximal I] (x : R), ↑Polynomial.C x ∈ I → x = 0\"},\n {\"role\": \"user\",\n  \"content\": \"Maximal ideals in complete normed rings are closed. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] {I : Ideal R} [hI : Ideal.IsMaximal I], IsClosed ↑I\"},\n {\"role\": \"user\", \"content\": \"The ring of integers has a maximal ideal.\"}]"}
{"text":"The numbers `3`, `4` and `5` form a Pythagorean triple.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"**Formula for Pythagorean Triples** \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {x y z : ℤ},\\n  PythagoreanTriple x y z →\\n    (PythagoreanTriple x y z ↔\\n      ∃ k m n,\\n        (x = k * (m ^ 2 - n ^ 2) ∧ y = k * (2 * m * n) ∨ x = k * (2 * m * n) ∧ y = k * (m ^ 2 - n ^ 2)) ∧\\n          (z = k * (m ^ 2 + n ^ 2) ∨ z = -k * (m ^ 2 + n ^ 2)))\"},\n {\"role\": \"user\",\n  \"content\":\n  \"`(k*x, k*y, k*z)` is a Pythagorean triple if and only if\\n`(x, y, z)` is also a triple. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {x y z : ℤ} (k : ℤ), k ≠ 0 → (PythagoreanTriple (k * x) (k * y) (k * z) ↔ PythagoreanTriple x y z)\"},\n {\"role\": \"user\", \"content\": \"The zeroth Pythagorean triple is all zeros. \"},\n {\"role\": \"assistant\", \"content\": \"PythagoreanTriple 0 0 0\"},\n {\"role\": \"user\", \"content\": \"**Four squares theorem** \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (n : ℕ), ∃ a b c d, a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"**Euler's four-square identity**, a version for natural numbers. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (a b c d x y z w : ℕ),\\n  Int.natAbs (↑a * ↑x - ↑b * ↑y - ↑c * ↑z - ↑d * ↑w) ^ 2 + Int.natAbs (↑a * ↑y + ↑b * ↑x + ↑c * ↑w - ↑d * ↑z) ^ 2 +\\n        Int.natAbs (↑a * ↑z - ↑b * ↑w + ↑c * ↑x + ↑d * ↑y) ^ 2 +\\n      Int.natAbs (↑a * ↑w + ↑b * ↑z - ↑c * ↑y + ↑d * ↑x) ^ 2 =\\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2)\"},\n {\"role\": \"user\",\n  \"content\": \"The numbers `3`, `4` and `5` form a Pythagorean triple.\"}]"}
{"text":"A vector space with the empty set as basis is trivial. ","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A vector space with a nonzero vector `v` has dimension 1 iff `v` spans.\\n\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (v : V),\\n  v ≠ 0 → (FiniteDimensional.finrank K V = 1 ↔ Submodule.span K {v} = ⊤)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The span of the empty set is the bottom of the lattice of subspaces. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\\n  Projectivization.Subspace.span ∅ = ⊥\"},\n {\"role\": \"user\",\n  \"content\": \"Any basis is a maximal linear independent set.\\n\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_2} {R : Type u_1} {M : Type u_3} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : Nontrivial R] (b : Basis ι R M), LinearIndependent.Maximal (_ : LinearIndependent R ↑b)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For a non-trivial space, the affine span of a set is `⊤` iff its vector span is `⊤`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (k : Type u_2) (V : Type u_3) (P : Type u_1) [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [S : AddTorsor V P] {s : Set P} [inst_3 : Nontrivial P], affineSpan k s = ⊤ ↔ vectorSpan k s = ⊤\"},\n {\"role\": \"user\", \"content\": \"The affine span of a nonempty set is nonempty. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (k : Type u_1) {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] {s : Set P} [inst_4 : Nonempty ↑s], Nonempty { x // x ∈ affineSpan k s }\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a vector space has a basis indexed by elements of a finite set, then it is\\nfinite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\\n  {s : Set ι}, Basis (↑s) K V → Set.Finite s → FiniteDimensional K V\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a vector space has a finite basis, then it is finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\\n  [inst_3 : Finite ι], Basis ι K V → FiniteDimensional K V\"},\n {\"role\": \"user\", \"content\": \"The span of the empty set is `⊥`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (k : Type u_2) (V : Type u_3) (P : Type u_1) [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [S : AddTorsor V P], affineSpan k ∅ = ⊥\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If scalar multiplication yields zero, either the scalar or the vector was zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} {M : Type u_2} [inst : Zero R] [inst_1 : Zero M] [inst_2 : SMul R M] [self : NoZeroSMulDivisors R M]\\n  {c : R} {x : M}, c • x = 0 → c = 0 ∨ x = 0\"},\n {\"role\": \"user\",\n  \"content\": \"A vector space with the empty set as basis is trivial. \"}]"}
{"text":"Every prime number is `2` or odd.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"There are infinitely many odd natural numbers.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"The smallest odd prime is `3`.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"There are infinitely many odd prime numbers.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"If a vector space has dimension `2` then it is finite dimensional.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every field is a division ring.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"If a space has dimension `2` then it is finite dimensional.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every natural number has a successor.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every natural number is less than its successor.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every set is Lebesgue measurable.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every set of Borel measure zero is Lebesgue measurable.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"No prime number is a perfect square.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every odd prime number is greater than `2`.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every compact topological space is locally compact.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every continuous function is uniformly continuous.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"`6` is not the sum of two distinct prime numbers.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"No integer is irrational.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"The identity element in a ring is a unit.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every subgroup of a group is a group.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"The sum of two natural numbers is a natural number.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"The identity element of a group has finite order.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"`7` is a prime number.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"There are `3` prime numbers below `8`.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"The empty set is contained in every finite set.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every infinite set contains a finite set.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every commutative ring is a monoid.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"There is no field of order `10`.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every odd natural number is the sum of two distinct natural numbers.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every element in the trivial group has finite order.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"The square of an even number is even.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every commutative division ring is a field.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"The image of the identity element under the identity map is the identity element.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every point is a fixed point of the identity function on a space.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"The diameter of a singleton space is `0`.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every group is non-empty.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"All connected components of a topological space are connected.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"The ring of integers has a maximal ideal.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"The numbers `3`, `4` and `5` form a Pythagorean triple.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every prime number is `2` or odd.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"There are infinitely many odd natural numbers.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"The smallest odd prime is `3`.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"There are infinitely many odd prime numbers.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"If a vector space has dimension `2` then it is finite dimensional.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every field is a division ring.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"If a space has dimension `2` then it is finite dimensional.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every natural number has a successor.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every natural number is less than its successor.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every set is Lebesgue measurable.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every set of Borel measure zero is Lebesgue measurable.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"No prime number is a perfect square.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every odd prime number is greater than `2`.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every compact topological space is locally compact.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every continuous function is uniformly continuous.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"`6` is not the sum of two distinct prime numbers.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"No integer is irrational.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"The identity element in a ring is a unit.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every subgroup of a group is a group.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"The sum of two natural numbers is a natural number.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"The identity element of a group has finite order.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"`7` is a prime number.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"There are `3` prime numbers below `8`.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"The empty set is contained in every finite set.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every infinite set contains a finite set.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every commutative ring is a monoid.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"There is no field of order `10`.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every odd natural number is the sum of two distinct natural numbers.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every element in the trivial group has finite order.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"The square of an even number is even.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every commutative division ring is a field.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"The image of the identity element under the identity map is the identity element.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every point is a fixed point of the identity function on a space.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"The diameter of a singleton space is `0`.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every group is non-empty.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"All connected components of a topological space are connected.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"The ring of integers has a maximal ideal.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"The numbers `3`, `4` and `5` form a Pythagorean triple.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"A vector space with the empty set as basis is trivial.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every prime number is `2` or odd.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"There are infinitely many odd natural numbers.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"The smallest odd prime is `3`.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"There are infinitely many odd prime numbers.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"If a vector space has dimension `2` then it is finite dimensional.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every field is a division ring.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"If a space has dimension `2` then it is finite dimensional.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every natural number has a successor.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every natural number is less than its successor.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every set is Lebesgue measurable.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every set of Borel measure zero is Lebesgue measurable.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"No prime number is a perfect square.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every odd prime number is greater than `2`.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every compact topological space is locally compact.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every continuous function is uniformly continuous.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"`6` is not the sum of two distinct prime numbers.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"No integer is irrational.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"The identity element in a ring is a unit.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every subgroup of a group is a group.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"The sum of two natural numbers is a natural number.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"The identity element of a group has finite order.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"`7` is a prime number.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"There are `3` prime numbers below `8`.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"The empty set is contained in every finite set.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every infinite set contains a finite set.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every commutative ring is a monoid.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"There is no field of order `10`.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every odd natural number is the sum of two distinct natural numbers.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every element in the trivial group has finite order.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"The square of an even number is even.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every commutative division ring is a field.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"The image of the identity element under the identity map is the identity element.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every point is a fixed point of the identity function on a space.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"The diameter of a singleton space is `0`.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every group is non-empty.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"All connected components of a topological space are connected.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"The ring of integers has a maximal ideal.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"The numbers `3`, `4` and `5` form a Pythagorean triple.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"A vector space with the empty set as basis is trivial.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every prime number is `2` or odd.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"There are infinitely many odd natural numbers.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"The smallest odd prime is `3`.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"There are infinitely many odd prime numbers.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"If a vector space has dimension `2` then it is finite dimensional.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every field is a division ring.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"If a space has dimension `2` then it is finite dimensional.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every natural number has a successor.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every natural number is less than its successor.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every set is Lebesgue measurable.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every set of Borel measure zero is Lebesgue measurable.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"No prime number is a perfect square.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every odd prime number is greater than `2`.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every compact topological space is locally compact.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every continuous function is uniformly continuous.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"`6` is not the sum of two distinct prime numbers.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"No integer is irrational.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"The identity element in a ring is a unit.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every subgroup of a group is a group.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"The sum of two natural numbers is a natural number.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"The identity element of a group has finite order.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"`7` is a prime number.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"There are `3` prime numbers below `8`.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"The empty set is contained in every finite set.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every infinite set contains a finite set.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every commutative ring is a monoid.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"There is no field of order `10`.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every odd natural number is the sum of two distinct natural numbers.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every element in the trivial group has finite order.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"The square of an even number is even.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every commutative division ring is a field.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"The image of the identity element under the identity map is the identity element.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every point is a fixed point of the identity function on a space.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"The diameter of a singleton space is `0`.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every group is non-empty.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"All connected components of a topological space are connected.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"The ring of integers has a maximal ideal.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"The numbers `3`, `4` and `5` form a Pythagorean triple.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"A vector space with the empty set as basis is trivial.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every prime number is `2` or odd.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"There are infinitely many odd natural numbers.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"The smallest odd prime is `3`.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"There are infinitely many odd prime numbers.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"If a vector space has dimension `2` then it is finite dimensional.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every field is a division ring.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"If a space has dimension `2` then it is finite dimensional.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every natural number has a successor.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every natural number is less than its successor.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every set is Lebesgue measurable.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every set of Borel measure zero is Lebesgue measurable.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"No prime number is a perfect square.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every odd prime number is greater than `2`.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every compact topological space is locally compact.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every continuous function is uniformly continuous.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"`6` is not the sum of two distinct prime numbers.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"No integer is irrational.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"The identity element in a ring is a unit.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every subgroup of a group is a group.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"The sum of two natural numbers is a natural number.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"The identity element of a group has finite order.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"`7` is a prime number.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"There are `3` prime numbers below `8`.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"The empty set is contained in every finite set.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every infinite set contains a finite set.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every commutative ring is a monoid.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"There is no field of order `10`.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every odd natural number is the sum of two distinct natural numbers.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every element in the trivial group has finite order.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"The square of an even number is even.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every commutative division ring is a field.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"The image of the identity element under the identity map is the identity element.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every point is a fixed point of the identity function on a space.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"The diameter of a singleton space is `0`.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every group is non-empty.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"All connected components of a topological space are connected.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"The ring of integers has a maximal ideal.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"The numbers `3`, `4` and `5` form a Pythagorean triple.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"A vector space with the empty set as basis is trivial.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every prime number is `2` or odd.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"There are infinitely many odd natural numbers.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"The smallest odd prime is `3`.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"There are infinitely many odd prime numbers.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"If a vector space has dimension `2` then it is finite dimensional.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every field is a division ring.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"If a space has dimension `2` then it is finite dimensional.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every natural number has a successor.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every natural number is less than its successor.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every set is Lebesgue measurable.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every set of Borel measure zero is Lebesgue measurable.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"No prime number is a perfect square.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every odd prime number is greater than `2`.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every compact topological space is locally compact.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every continuous function is uniformly continuous.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"`6` is not the sum of two distinct prime numbers.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"No integer is irrational.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"The identity element in a ring is a unit.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every subgroup of a group is a group.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"The sum of two natural numbers is a natural number.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"The identity element of a group has finite order.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"`7` is a prime number.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"There are `3` prime numbers below `8`.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"The empty set is contained in every finite set.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every infinite set contains a finite set.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every commutative ring is a monoid.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"There is no field of order `10`.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every odd natural number is the sum of two distinct natural numbers.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every element in the trivial group has finite order.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"The square of an even number is even.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every commutative division ring is a field.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"The image of the identity element under the identity map is the identity element.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every point is a fixed point of the identity function on a space.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"The diameter of a singleton space is `0`.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every group is non-empty.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"All connected components of a topological space are connected.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"The ring of integers has a maximal ideal.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"The numbers `3`, `4` and `5` form a Pythagorean triple.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"A vector space with the empty set as basis is trivial.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every prime number is `2` or odd.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"There are infinitely many odd natural numbers.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"The smallest odd prime is `3`.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"There are infinitely many odd prime numbers.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"If a vector space has dimension `2` then it is finite dimensional.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every field is a division ring.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"If a space has dimension `2` then it is finite dimensional.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every natural number has a successor.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every natural number is less than its successor.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every set is Lebesgue measurable.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every set of Borel measure zero is Lebesgue measurable.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"No prime number is a perfect square.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every odd prime number is greater than `2`.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every compact topological space is locally compact.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every continuous function is uniformly continuous.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"`6` is not the sum of two distinct prime numbers.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"No integer is irrational.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"The identity element in a ring is a unit.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every subgroup of a group is a group.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"The sum of two natural numbers is a natural number.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"The identity element of a group has finite order.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"`7` is a prime number.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"There are `3` prime numbers below `8`.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"The empty set is contained in every finite set.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every infinite set contains a finite set.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every commutative ring is a monoid.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"There is no field of order `10`.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every odd natural number is the sum of two distinct natural numbers.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every element in the trivial group has finite order.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"The square of an even number is even.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every commutative division ring is a field.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"The image of the identity element under the identity map is the identity element.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every point is a fixed point of the identity function on a space.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"The diameter of a singleton space is `0`.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every group is non-empty.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"All connected components of a topological space are connected.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"The ring of integers has a maximal ideal.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"The numbers `3`, `4` and `5` form a Pythagorean triple.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"A vector space with the empty set as basis is trivial.","fullPrompt":"No prompt (maybe using cached data)"}
{"text":"Every prime number is `2` or odd.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a finite field of characteristic `2`, all elements are squares. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {F : Type u_3} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 → ∀ (a : F), IsSquare a\"},\n {\"role\": \"user\",\n  \"content\": \"The only prime factor of prime `p` is `p` itself. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {p q : ℕ}, Nat.Prime p → (Nat.factorization p) q ≠ 0 → p = q\"},\n {\"role\": \"user\",\n  \"content\":\n  \"`-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare (-2) ↔ p % 8 = 1 ∨ p % 8 = 3)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A prime natural number is prime in `ℤ[i]` if and only if it is `3` mod `4` \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)], Prime ↑p ↔ p % 4 = 3\"},\n {\"role\": \"user\",\n  \"content\": \"The only divisors of prime powers are prime powers. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [dec_irr : (p : Associates α) → Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid α] [dec : DecidableEq α] [dec' : DecidableEq (Associates α)] {a p : Associates α},\\n  Irreducible p →\\n    ∀ [inst_2 : (n : ℕ) → Decidable (a ∣ p ^ n)] {n : ℕ} (h : a ∣ p ^ n),\\n      a = p ^ Nat.find (_ : ∃ n, (fun n => a ∣ p ^ n) n)\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\", \"content\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (n : ℕ), Nat.factorization n = 0 ↔ n = 0 ∨ n = 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"`2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare 2 ↔ p % 8 = 1 ∨ p % 8 = 7)\"},\n {\"role\": \"user\",\n  \"content\": \"A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 2 = 1 ↔ p ≠ 2\"},\n {\"role\": \"user\", \"content\": \"`2` is not a factor of an odd natural number. \"},\n {\"role\": \"assistant\", \"content\": \"∀ {m n : ℕ}, Odd n → m ∣ n → m ≠ 2\"},\n {\"role\": \"user\", \"content\": \"Every prime number is `2` or odd.\"}]"}
{"text":"There are infinitely many odd natural numbers.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"A transcendental real number is irrational. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {r : ℝ}, Transcendental ℚ r → Irrational r\"},\n {\"role\": \"user\",\n  \"content\": \"Every finite convergent corresponds to a rational number. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K) (n : ℕ),\\n  ∃ q, GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n = ↑q\"},\n {\"role\": \"user\",\n  \"content\": \"Infinite ordinals that are cardinals are unbounded. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"Set.Unbounded (fun x x_1 => x < x_1) {b | Cardinal.ord (Ordinal.card b) = b ∧ Ordinal.omega ≤ b}\"},\n {\"role\": \"user\", \"content\": \"A product of finite numbers is still finite \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_1} {R : Type u_8} [inst : CommMonoidWithZero R] [inst_1 : NoZeroDivisors R] [inst_2 : Nontrivial R]\\n  [inst_3 : DecidableEq R] [inst_4 : LT R] {s : Finset ι} {f : ι → WithTop R},\\n  (∀ i ∈ s, f i ≠ ⊤) → (Finset.prod s fun i => f i) < ⊤\"},\n {\"role\": \"user\", \"content\": \"A sum of finite numbers is still finite \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {s : Finset α} {f : α → ENNReal}, (∀ a ∈ s, f a ≠ ⊤) → (Finset.sum s fun a => f a) < ⊤\"},\n {\"role\": \"user\",\n  \"content\": \"A natural number is odd iff it has residue `1` or `3` mod `4`\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n : ℕ}, n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3\"},\n {\"role\": \"user\", \"content\": \"There is an infinite base \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {M : Matroid α} [self : Matroid.InfiniteRk M], ∃ B, M.Base B ∧ Set.Infinite B\"},\n {\"role\": \"user\",\n  \"content\": \"Infinitely many natural numbers are equal to `d` mod `n`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {n : ℕ}, n ≠ 0 → ∀ (d : ℕ), ∃ᶠ (m : ℕ) in Filter.atTop, m ≡ d [MOD n]\"},\n {\"role\": \"user\",\n  \"content\": \"A sum of numbers is infinite iff one of them is infinite \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_1} {M : Type u_4} [inst : AddCommMonoid M] {s : Finset ι} {f : ι → WithTop M},\\n  (Finset.sum s fun i => f i) = ⊤ ↔ ∃ i ∈ s, f i = ⊤\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\", \"content\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\"},\n {\"role\": \"user\", \"content\": \"There are infinitely many odd natural numbers.\"}]"}
{"text":"The smallest odd prime is `3`.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"The only prime factor of prime `p` is `p` itself. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {p q : ℕ}, Nat.Prime p → (Nat.factorization p) q ≠ 0 → p = q\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The square of the smallest prime factor of a composite number `n` is at most `n`.\\n\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n : ℕ}, 0 < n → ¬Nat.Prime n → Nat.minFac n ^ 2 ≤ n\"},\n {\"role\": \"user\", \"content\": \"A minimal polynomial is prime. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\\n  IsIntegral A x → Prime (minpoly A x)\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\", \"content\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"`2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare 2 ↔ p % 8 = 1 ∨ p % 8 = 7)\"},\n {\"role\": \"user\",\n  \"content\": \"A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 2 = 1 ↔ p ≠ 2\"},\n {\"role\": \"user\",\n  \"content\":\n  \"`-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare (-2) ↔ p % 8 = 1 ∨ p % 8 = 3)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (n : ℕ), Nat.factorization n = 0 ↔ n = 0 ∨ n = 1\"},\n {\"role\": \"user\",\n  \"content\": \"A natural number is odd iff it has residue `1` or `3` mod `4`\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n : ℕ}, n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A prime natural number is prime in `ℤ[i]` if and only if it is `3` mod `4` \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)], Prime ↑p ↔ p % 4 = 3\"},\n {\"role\": \"user\", \"content\": \"The smallest odd prime is `3`.\"}]"}
{"text":"There are infinitely many odd prime numbers.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"To prove Fermat's Last Theorem, it suffices to prove it for odd prime exponents.\\n\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"(∀ (p : ℕ), Nat.Prime p → Odd p → FermatLastTheoremFor p) → FermatLastTheorem\"},\n {\"role\": \"user\", \"content\": \"A finite field has prime power cardinality. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : Fintype α] [inst_1 : Field α], IsPrimePow (Fintype.card α)\"},\n {\"role\": \"user\",\n  \"content\": \"A sum of numbers is infinite iff one of them is infinite \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_1} {M : Type u_4} [inst : AddCommMonoid M] {s : Finset ι} {f : ι → WithTop M},\\n  (Finset.sum s fun i => f i) = ⊤ ↔ ∃ i ∈ s, f i = ⊤\"},\n {\"role\": \"user\",\n  \"content\": \"The exponential characteristic is a prime number or one. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (R : Type u) [inst : Semiring R] (q : ℕ) [hq : ExpChar R q], Nat.Prime q ∨ q = 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (n : ℕ), Nat.factorization n = 0 ↔ n = 0 ∨ n = 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For any positive `k : ℕ` there are infinitely many primes `p` such that `p ≡ 1 [MOD k]`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {k : ℕ}, k ≠ 0 → Set.Infinite {p | Nat.Prime p ∧ p ≡ 1 [MOD k]}\"},\n {\"role\": \"user\",\n  \"content\": \"The only divisors of prime powers are prime powers. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [dec_irr : (p : Associates α) → Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid α] [dec : DecidableEq α] [dec' : DecidableEq (Associates α)] {a p : Associates α},\\n  Irreducible p →\\n    ∀ [inst_2 : (n : ℕ) → Decidable (a ∣ p ^ n)] {n : ℕ} (h : a ∣ p ^ n),\\n      a = p ^ Nat.find (_ : ∃ n, (fun n => a ∣ p ^ n) n)\"},\n {\"role\": \"user\", \"content\": \"There is an infinite base \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {M : Matroid α} [self : Matroid.InfiniteRk M], ∃ B, M.Base B ∧ Set.Infinite B\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\", \"content\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\"},\n {\"role\": \"user\", \"content\": \"There are infinitely many odd prime numbers.\"}]"}
{"text":"If a vector space has dimension `2` then it is finite dimensional.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"Two linearly equivalent vector spaces have the same dimension. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : Ring R] {M : Type v} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {M₁ : Type v}\\n  [inst_3 : AddCommGroup M₁] [inst_4 : Module R M₁], (M ≃ₗ[R] M₁) → Module.rank R M = Module.rank R M₁\"},\n {\"role\": \"user\", \"content\": \"A finite-dimensional subspace is complete. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : NontriviallyNormedField 𝕜] [inst_1 : CompleteSpace 𝕜] [inst_2 : AddCommGroup E]\\n  [inst_3 : UniformSpace E] [inst_4 : T2Space E] [inst_5 : UniformAddGroup E] [inst_6 : Module 𝕜 E]\\n  [inst_7 : ContinuousSMul 𝕜 E] (s : Submodule 𝕜 E) [inst_8 : FiniteDimensional 𝕜 ↥s], IsComplete ↑s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A subspace of a finite-dimensional space is also finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K ↥S\"},\n {\"role\": \"user\",\n  \"content\": \"The `vectorSpan` of a finite set is finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (k : Type u_1) {V : Type u_2} {P : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] {s : Set P}, Set.Finite s → FiniteDimensional k ↥(vectorSpan k s)\"},\n {\"role\": \"user\", \"content\": \"A finite-dimensional subspace is closed. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : NontriviallyNormedField 𝕜] [inst_1 : CompleteSpace 𝕜] [inst_2 : AddCommGroup E]\\n  [inst_3 : TopologicalSpace E] [inst_4 : T2Space E] [inst_5 : TopologicalAddGroup E] [inst_6 : Module 𝕜 E]\\n  [inst_7 : ContinuousSMul 𝕜 E] (s : Submodule 𝕜 E) [inst_8 : FiniteDimensional 𝕜 ↥s], IsClosed ↑s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a vector space has a finite dimension, the index set of `Basis.ofVectorSpace` is finite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\\n  Module.rank K V < Cardinal.aleph0 → Set.Finite (Basis.ofVectorSpaceIndex K V)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a vector space has a basis indexed by elements of a finite set, then it is\\nfinite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\\n  {s : Set ι}, Basis (↑s) K V → Set.Finite s → FiniteDimensional K V\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a vector space has a finite basis, then it is finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\\n  [inst_3 : Finite ι], Basis ι K V → FiniteDimensional K V\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a vector space has dimension `2` then it is finite dimensional.\"}]"}
{"text":"Every field is a division ring.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"A subfield is closed under division. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} [inst : Field K] (s : Subfield K) {x y : K}, x ∈ s → y ∈ s → x / y ∈ s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For a semiring to be a field, it must have two distinct elements. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {R : Type u} [inst : Semiring R], IsField R → ∃ x y, x ≠ y\"},\n {\"role\": \"user\",\n  \"content\": \"All ideals in a division (semi)ring are trivial. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} [inst : DivisionSemiring K] (I : Ideal K), I = ⊥ ∨ I = ⊤\"},\n {\"role\": \"user\",\n  \"content\": \"A normed division ring is a topological division ring. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : NormedDivisionRing α], TopologicalDivisionRing α\"},\n {\"role\": \"user\",\n  \"content\": \"Natural division is the floor of field division. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_2} [inst : LinearOrderedSemifield α] [inst_1 : FloorSemiring α] (m n : ℕ), ⌊↑m / ↑n⌋₊ = m / n\"},\n {\"role\": \"user\",\n  \"content\": \"An intermediate field is closed under division. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u_1} {L : Type u_2} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\\n  {x y : L}, x ∈ S → y ∈ S → x / y ∈ S\"},\n {\"role\": \"user\", \"content\": \"An intermediate field contains the ring's 0. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u_1} {L : Type u_2} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\\n  0 ∈ S\"},\n {\"role\": \"user\", \"content\": \"An intermediate field contains the ring's 1. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u_1} {L : Type u_2} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\\n  1 ∈ S\"},\n {\"role\": \"user\", \"content\": \"A field is a valuation ring. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (K : Type u) [inst : Field K], ValuationRing K\"},\n {\"role\": \"user\", \"content\": \"A valued division ring is separated. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u_1} [inst : DivisionRing K] {Γ₀ : Type u_2} [inst_1 : LinearOrderedCommGroupWithZero Γ₀]\\n  [inst_2 : Valued K Γ₀], SeparatedSpace K\"},\n {\"role\": \"user\", \"content\": \"Every field is a division ring.\"}]"}
{"text":"If a space has dimension `2` then it is finite dimensional.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The space of continuous linear maps between finite-dimensional spaces is finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [inst : Field 𝕜] [inst_1 : TopologicalSpace 𝕜] [inst_2 : AddCommGroup E]\\n  [inst_3 : Module 𝕜 E] [inst_4 : TopologicalSpace E] [inst_5 : AddCommGroup F] [inst_6 : Module 𝕜 F]\\n  [inst_7 : TopologicalSpace F] [inst_8 : TopologicalAddGroup F] [inst_9 : ContinuousSMul 𝕜 F]\\n  [inst_10 : FiniteDimensional 𝕜 E] [inst_11 : FiniteDimensional 𝕜 F], FiniteDimensional 𝕜 (E →L[𝕜] F)\"},\n {\"role\": \"user\", \"content\": \"A finite-dimensional subspace is complete. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : NontriviallyNormedField 𝕜] [inst_1 : CompleteSpace 𝕜] [inst_2 : AddCommGroup E]\\n  [inst_3 : UniformSpace E] [inst_4 : T2Space E] [inst_5 : UniformAddGroup E] [inst_6 : Module 𝕜 E]\\n  [inst_7 : ContinuousSMul 𝕜 E] (s : Submodule 𝕜 E) [inst_8 : FiniteDimensional 𝕜 ↥s], IsComplete ↑s\"},\n {\"role\": \"user\", \"content\": \"A compact discrete space is finite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X] [inst : DiscreteTopology X], Finite X\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a linear map has determinant different from `1`, then the space is finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {M : Type u_2} [inst : AddCommGroup M] {𝕜 : Type u_7} [inst_1 : Field 𝕜] [inst_2 : Module 𝕜 M] (f : M →ₗ[𝕜] M),\\n  LinearMap.det f ≠ 1 → FiniteDimensional 𝕜 M\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A quotient of a finite-dimensional space is also finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K (V ⧸ S)\"},\n {\"role\": \"user\", \"content\": \"A finite space is bounded. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_4} [inst : Bornology α] [inst_1 : Finite α], BoundedSpace α\"},\n {\"role\": \"user\", \"content\": \"A finite-dimensional subspace is closed. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : NontriviallyNormedField 𝕜] [inst_1 : CompleteSpace 𝕜] [inst_2 : AddCommGroup E]\\n  [inst_3 : TopologicalSpace E] [inst_4 : T2Space E] [inst_5 : TopologicalAddGroup E] [inst_6 : Module 𝕜 E]\\n  [inst_7 : ContinuousSMul 𝕜 E] (s : Submodule 𝕜 E) [inst_8 : FiniteDimensional 𝕜 ↥s], IsClosed ↑s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A subspace of a finite-dimensional space is also finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K ↥S\"},\n {\"role\": \"user\", \"content\": \"All hom spaces are finite dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {k G : Type u} [inst : Field k] [inst_1 : Monoid G] (V W : FdRep k G), FiniteDimensional k (V ⟶ W)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a vector space has a finite basis, then it is finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\\n  [inst_3 : Finite ι], Basis ι K V → FiniteDimensional K V\"},\n {\"role\": \"user\",\n  \"content\": \"If a space has dimension `2` then it is finite dimensional.\"}]"}
{"text":"Every natural number has a successor.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `n : ℕ+` is different from `1`, then it is the successor of some `k : ℕ+`. \"},\n {\"role\": \"assistant\", \"content\": \"∀ {n : ℕ+}, n ≠ 1 → ∃ k, n = k + 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The canonical map from ℕ to a graded semiring respects successors.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_1} {A : ι → Type u_2} [inst : AddMonoid ι] [inst_1 : (i : ι) → AddCommMonoid (A i)]\\n  [self : DirectSum.GSemiring A] (n : ℕ),\\n  DirectSum.GSemiring.natCast (n + 1) = DirectSum.GSemiring.natCast n + GradedMonoid.GOne.one\"},\n {\"role\": \"user\",\n  \"content\": \"A Cauchy sequence on the natural numbers is bounded. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {u : ℕ → α}, CauchySeq u → ∃ R > 0, ∀ (m n : ℕ), dist (u m) (u n) < R\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {m n : ℕ}, (∀ (a : ℕ), a ∣ m ↔ a ∣ n) ↔ m = n\"},\n {\"role\": \"user\", \"content\": \"Every ordinal has a fundamental sequence. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (a : Ordinal.{u}), ∃ f, Ordinal.IsFundamentalSequence a (Cardinal.ord (Ordinal.cof a)) f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {m n : ℕ}, (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n\"},\n {\"role\": \"user\",\n  \"content\": \"Every finite convergent corresponds to a rational number. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K) (n : ℕ),\\n  ∃ q, GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n = ↑q\"},\n {\"role\": \"user\",\n  \"content\":\n  \"This result shows that there always exists a next term in the sequence. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (K : Type u_1) [inst : Field K] [inst_1 : NumberField K] (w₁ : NumberField.InfinitePlace K) {B : ℕ},\\n  NumberField.mixedEmbedding.minkowskiBound K < NumberField.mixedEmbedding.convexBodyLTFactor K * ↑B →\\n    ∀ {x : ↥(NumberField.ringOfIntegers K)},\\n      x ≠ 0 → ∃ y, y ≠ 0 ∧ (∀ (w : NumberField.InfinitePlace K), w ≠ w₁ → w ↑y < w ↑x) ∧ |(Algebra.norm ℚ) ↑y| ≤ ↑B\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\", \"content\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\"},\n {\"role\": \"user\", \"content\": \"Every natural number has a successor.\"}]"}
{"text":"Every natural number is less than its successor.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"A Cauchy sequence on the natural numbers is bounded. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {u : ℕ → α}, CauchySeq u → ∃ R > 0, ∀ (m n : ℕ), dist (u m) (u n) < R\"},\n {\"role\": \"user\", \"content\": \"A finite set is bounded below.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : Preorder α] [inst_1 : IsDirected α fun x x_1 => x ≥ x_1] [inst_2 : Nonempty α] {s : Set α},\\n  Set.Finite s → BddBelow s\"},\n {\"role\": \"user\", \"content\": \"Zero is less than or equal to one. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_2} [inst : Zero α] [inst_1 : One α] [inst_2 : LE α] [self : ZeroLEOneClass α], 0 ≤ 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a small natural number is divisible by a larger natural number,\\nthe small number is zero. \"},\n {\"role\": \"assistant\", \"content\": \"∀ {a b : ℕ}, a ∣ b → b < a → b = 0\"},\n {\"role\": \"user\",\n  \"content\": \"Natural division is always less than division in the field. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : LinearOrderedSemifield α] {m n : ℕ}, ↑(m / n) ≤ ↑m / ↑n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The digits in the base b+2 expansion of n are all less than b+2 \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {b m d : ℕ}, d ∈ Nat.digits (b + 2) m → d < b + 2\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The digits in the base b expansion of n are all less than b, if b ≥ 2 \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {b m d : ℕ}, 1 < b → d ∈ Nat.digits b m → d < b\"},\n {\"role\": \"user\", \"content\": \"Any element is less than the top one. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u_9} [self : CompleteLattice α] (x : α), x ≤ ⊤\"},\n {\"role\": \"user\", \"content\": \"Any lower bound is less than the set infimum. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_9} [self : CompleteSemilatticeInf α] (s : Set α) (a : α), (∀ b ∈ s, a ≤ b) → a ≤ sInf s\"},\n {\"role\": \"user\",\n  \"content\": \"Any element of a set is less than the set supremum. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_9} [self : CompleteSemilatticeSup α] (s : Set α), ∀ a ∈ s, a ≤ sSup s\"},\n {\"role\": \"user\",\n  \"content\": \"Every natural number is less than its successor.\"}]"}
{"text":"Every set is Lebesgue measurable.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The set of points for which a measurable sequence of functions converges is measurable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_2} {γ : Type u_3} {β : Type u_4} [inst : MeasurableSpace β] [inst_1 : TopologicalSpace γ]\\n  [inst_2 : PolishSpace γ] [inst_3 : MeasurableSpace γ] [hγ : OpensMeasurableSpace γ] [inst_4 : Countable ι]\\n  {l : Filter ι} [inst_5 : Filter.IsCountablyGenerated l] {f : ι → β → γ},\\n  (∀ (i : ι), Measurable (f i)) → MeasurableSet {x | ∃ c, Filter.Tendsto (fun n => f n x) l (nhds c)}\"},\n {\"role\": \"user\",\n  \"content\": \"The graph of a measurable function is a measurable set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : MeasurableSpace α] {f : α → ℝ}, Measurable f → MeasurableSet {p | p.2 = f p.1}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a set is a right-neighborhood of all of its points, then it is measurable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α]\\n  [inst_3 : LinearOrder α] [inst_4 : OrderTopology α] [inst_5 : SecondCountableTopology α] {s : Set α},\\n  (∀ x ∈ s, s ∈ nhdsWithin x (Set.Ioi x)) → MeasurableSet s\"},\n {\"role\": \"user\",\n  \"content\": \"In a `BorelSpace` all open sets are measurable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_6} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α],\\n  OpensMeasurableSpace α\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For every set there exists a measurable superset of the same measure. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : MeasurableSpace α] (μ : MeasureTheory.Measure α) (s : Set α),\\n  ∃ t, s ⊆ t ∧ MeasurableSet t ∧ ↑↑μ t = ↑↑μ s\"},\n {\"role\": \"user\",\n  \"content\": \"The set of Liouville numbers has Lebesgue measure zero. \"},\n {\"role\": \"assistant\",\n  \"content\": \"↑↑MeasureTheory.volume {x | Liouville x} = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For the outer measure coming from a content, all Borel sets are measurable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type w} [inst : TopologicalSpace G] (μ : MeasureTheory.Content G) [inst_1 : T2Space G] [S : MeasurableSpace G]\\n  [inst_2 : BorelSpace G], S ≤ MeasureTheory.OuterMeasure.caratheodory (MeasureTheory.Content.outerMeasure μ)\"},\n {\"role\": \"user\", \"content\": \"Borel-measurable sets are measurable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_6} [inst : TopologicalSpace α] [h : MeasurableSpace α] [self : OpensMeasurableSpace α], borel α ≤ h\"},\n {\"role\": \"user\",\n  \"content\": \"The measurable sets are exactly the Borel-measurable sets. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_6} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [self : BorelSpace α], inst_1 = borel α\"},\n {\"role\": \"user\", \"content\": \"Every set is Lebesgue measurable.\"}]"}
{"text":"Every set of Borel measure zero is Lebesgue measurable.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Left invariant Borel measures on an additive measurable group are unique (up to a scalar). \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : AddGroup G] [inst_2 : MeasurableAdd₂ G]\\n  (μ ν : MeasureTheory.Measure G) [inst_3 : MeasureTheory.SigmaFinite ν] [inst_4 : MeasureTheory.SigmaFinite μ]\\n  {s : Set G} [inst_5 : MeasurableNeg G] [inst_6 : MeasureTheory.Measure.IsAddLeftInvariant μ]\\n  [inst_7 : MeasureTheory.Measure.IsAddLeftInvariant ν],\\n  MeasurableSet s → ↑↑ν s ≠ 0 → ↑↑ν s ≠ ⊤ → μ = (↑↑μ s / ↑↑ν s) • ν\"},\n {\"role\": \"user\",\n  \"content\": \"In a `BorelSpace` all open sets are measurable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_6} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α],\\n  OpensMeasurableSpace α\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Left invariant Borel measures on a measurable group are unique (up to a scalar). \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Group G] [inst_2 : MeasurableMul₂ G]\\n  (μ ν : MeasureTheory.Measure G) [inst_3 : MeasureTheory.SigmaFinite ν] [inst_4 : MeasureTheory.SigmaFinite μ]\\n  {s : Set G} [inst_5 : MeasurableInv G] [inst_6 : MeasureTheory.Measure.IsMulLeftInvariant μ]\\n  [inst_7 : MeasureTheory.Measure.IsMulLeftInvariant ν],\\n  MeasurableSet s → ↑↑ν s ≠ 0 → ↑↑ν s ≠ ⊤ → μ = (↑↑μ s / ↑↑ν s) • ν\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For the outer measure coming from a content, all Borel sets are measurable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type w} [inst : TopologicalSpace G] (μ : MeasureTheory.Content G) [inst_1 : T2Space G] [S : MeasurableSpace G]\\n  [inst_2 : BorelSpace G], S ≤ MeasureTheory.OuterMeasure.caratheodory (MeasureTheory.Content.outerMeasure μ)\"},\n {\"role\": \"user\", \"content\": \"Borel-measurable sets are measurable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_6} [inst : TopologicalSpace α] [h : MeasurableSpace α] [self : OpensMeasurableSpace α], borel α ≤ h\"},\n {\"role\": \"user\",\n  \"content\": \"The measurable sets are exactly the Borel-measurable sets. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_6} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [self : BorelSpace α], inst_1 = borel α\"},\n {\"role\": \"user\",\n  \"content\": \"The set of Liouville numbers has Lebesgue measure zero. \"},\n {\"role\": \"assistant\",\n  \"content\": \"↑↑MeasureTheory.volume {x | Liouville x} = 0\"},\n {\"role\": \"user\",\n  \"content\": \"Every set of Borel measure zero is Lebesgue measurable.\"}]"}
{"text":"No prime number is a perfect square.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The square of the smallest prime factor of a composite number `n` is at most `n`.\\n\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n : ℕ}, 0 < n → ¬Nat.Prime n → Nat.minFac n ^ 2 ≤ n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The real square root is at most the natural square root plus one \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {a : ℕ}, Real.sqrt ↑a ≤ ↑(Nat.sqrt a) + 1\"},\n {\"role\": \"user\",\n  \"content\": \"The only divisors of prime powers are prime powers. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [dec_irr : (p : Associates α) → Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid α] [dec : DecidableEq α] [dec' : DecidableEq (Associates α)] {a p : Associates α},\\n  Irreducible p →\\n    ∀ [inst_2 : (n : ℕ) → Decidable (a ∣ p ^ n)] {n : ℕ} (h : a ∣ p ^ n),\\n      a = p ^ Nat.find (_ : ∃ n, (fun n => a ∣ p ^ n) n)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 ≠ 3`. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {p n : ℕ}, Nat.Prime p → p ∣ n → IsSquare (-1) → p % 4 ≠ 3\"},\n {\"role\": \"user\", \"content\": \"No zero divisors. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_2} [self : CanonicallyOrderedCommSemiring α] {a b : α}, a * b = 0 → a = 0 ∨ b = 0\"},\n {\"role\": \"user\", \"content\": \"The prime ideal is not the entire ring. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : Semiring α] {I : Ideal α} [self : Ideal.IsPrime I], I ≠ ⊤\"},\n {\"role\": \"user\", \"content\": \"`2` is not a factor of an odd natural number. \"},\n {\"role\": \"assistant\", \"content\": \"∀ {m n : ℕ}, Odd n → m ∣ n → m ≠ 2\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\", \"content\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a finite field of odd characteristic, not every element is a square. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {F : Type u_3} [inst : Field F] [inst_1 : Finite F], ringChar F ≠ 2 → ∃ a, ¬IsSquare a\"},\n {\"role\": \"user\",\n  \"content\": \"There are no perfect squares strictly between m² and (m+1)² \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {n m : ℕ}, m * m < n → n < (m + 1) * (m + 1) → ¬∃ t, t * t = n\"},\n {\"role\": \"user\", \"content\": \"No prime number is a perfect square.\"}]"}
{"text":"Every odd prime number is greater than `2`.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A prime natural number is prime in `ℤ[i]` if and only if it is `3` mod `4` \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)], Prime ↑p ↔ p % 4 = 3\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `1 < p`, then `q p`, the smallest prime factor of `mersenne p`, is more than 2. \"},\n {\"role\": \"assistant\", \"content\": \"∀ (p' : ℕ), 2 < LucasLehmer.q (p' + 2)\"},\n {\"role\": \"user\",\n  \"content\": \"A natural number is odd iff it has residue `1` or `3` mod `4`\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n : ℕ}, n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3\"},\n {\"role\": \"user\",\n  \"content\": \"The only divisors of prime powers are prime powers. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [dec_irr : (p : Associates α) → Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid α] [dec : DecidableEq α] [dec' : DecidableEq (Associates α)] {a p : Associates α},\\n  Irreducible p →\\n    ∀ [inst_2 : (n : ℕ) → Decidable (a ∣ p ^ n)] {n : ℕ} (h : a ∣ p ^ n),\\n      a = p ^ Nat.find (_ : ∃ n, (fun n => a ∣ p ^ n) n)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (n : ℕ), Nat.factorization n = 0 ↔ n = 0 ∨ n = 1\"},\n {\"role\": \"user\",\n  \"content\": \"A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 2 = 1 ↔ p ≠ 2\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\", \"content\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\"},\n {\"role\": \"user\", \"content\": \"`2` is not a factor of an odd natural number. \"},\n {\"role\": \"assistant\", \"content\": \"∀ {m n : ℕ}, Odd n → m ∣ n → m ≠ 2\"},\n {\"role\": \"user\", \"content\": \"Every odd prime number is greater than `2`.\"}]"}
{"text":"The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Pythagorean theorem, if-and-if vector inner product form using square roots. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {F : Type u_3} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] {x y : F},\\n  ‖x + y‖ = Real.sqrt (‖x‖ * ‖x‖ + ‖y‖ * ‖y‖) ↔ inner x y = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {m n : ℕ}, (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n\"},\n {\"role\": \"user\",\n  \"content\": \"Expressing the product of two polynomials as a double sum. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : Semiring R] {p q : Polynomial R},\\n  p * q =\\n    Finset.sum (Polynomial.support p) fun i =>\\n      Polynomial.sum q fun j a => (Polynomial.monomial (i + j)) (Polynomial.coeff p i * a)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The product of two Chebyshev polynomials is the sum of two other Chebyshev polynomials. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (R : Type u_1) [inst : CommRing R] (m k : ℕ),\\n  2 * Polynomial.Chebyshev.T R m * Polynomial.Chebyshev.T R (m + k) =\\n    Polynomial.Chebyshev.T R (2 * m + k) + Polynomial.Chebyshev.T R k\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n : ℕ}, IsSquare (-1) → ∃ x y, n = x ^ 2 + y ^ 2\"},\n {\"role\": \"user\", \"content\": \"**Four squares theorem** \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (n : ℕ), ∃ a b c d, a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n\"},\n {\"role\": \"user\", \"content\": \"**Euler's four-square identity**. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : CommRing R] (a b c d x y z w : R),\\n  (a * x - b * y - c * z - d * w) ^ 2 + (a * y + b * x + c * w - d * z) ^ 2 + (a * z - b * w + c * x + d * y) ^ 2 +\\n      (a * w + b * z - c * y + d * x) ^ 2 =\\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"**Euler's four-square identity**, a version for natural numbers. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (a b c d x y z w : ℕ),\\n  Int.natAbs (↑a * ↑x - ↑b * ↑y - ↑c * ↑z - ↑d * ↑w) ^ 2 + Int.natAbs (↑a * ↑y + ↑b * ↑x + ↑c * ↑w - ↑d * ↑z) ^ 2 +\\n        Int.natAbs (↑a * ↑z - ↑b * ↑w + ↑c * ↑x + ↑d * ↑y) ^ 2 +\\n      Int.natAbs (↑a * ↑w + ↑b * ↑z - ↑c * ↑y + ↑d * ↑x) ^ 2 =\\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2)\"},\n {\"role\": \"user\",\n  \"content\": \"The sum of two squares is zero iff both elements are zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : LinearOrderedRing α] {x y : α}, x * x + y * y = 0 ↔ x = 0 ∧ y = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares.\"}]"}
{"text":"Every compact topological space is locally compact.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A topological group which is weakly locally compact is automatically locally compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type w} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G]\\n  [inst_3 : WeaklyLocallyCompactSpace G], LocallyCompactSpace G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a point in a topological group has a compact neighborhood, then the group is\\nlocally compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type w} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] {K : Set G},\\n  IsCompact K → ∀ {x : G}, K ∈ nhds x → LocallyCompactSpace G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every point of a weakly locally compact space admits a compact neighborhood. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u_4} [inst : TopologicalSpace X] [self : WeaklyLocallyCompactSpace X] (x : X), ∃ s, IsCompact s ∧ s ∈ nhds x\"},\n {\"role\": \"user\",\n  \"content\": \"A weakly locally compact Hausdorff space is locally compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : WeaklyLocallyCompactSpace X] [inst_2 : T2Space X],\\n  LocallyCompactSpace X\"},\n {\"role\": \"user\", \"content\": \"The underlying topological space is compact.\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (self : CompHaus), CompactSpace ↑self.toTop\"},\n {\"role\": \"user\", \"content\": \"Finite topological spaces are compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : Finite X], CompactSpace X\"},\n {\"role\": \"user\",\n  \"content\": \"Every compact topological space is locally compact.\"}]"}
{"text":"Every continuous function is uniformly continuous.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"A Lipschitz function is uniformly continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : PseudoEMetricSpace α] [inst_1 : PseudoEMetricSpace β] {K : NNReal} {f : α → β},\\n  LipschitzWith K f → UniformContinuous f\"},\n {\"role\": \"user\",\n  \"content\": \"Each function of an equicontinuous family is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_1} {X : Type u_3} {α : Type u_6} [inst : TopologicalSpace X] [inst_1 : UniformSpace α] {F : ι → X → α},\\n  Equicontinuous F → ∀ (i : ι), Continuous (F i)\"},\n {\"role\": \"user\", \"content\": \"Uniform continuity of the function \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_4} {β : Type u_5} [inst : UniformSpace α] [inst_1 : UniformSpace β] (self : α ≃ᵤ β),\\n  UniformContinuous self.toFun\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A constant sequence of functions is uniformly integrable in the probability sense. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {β : Type u_2} {ι : Type u_3} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α}\\n  [inst : NormedAddCommGroup β] {p : ENNReal} {g : α → β},\\n  1 ≤ p → p ≠ ⊤ → MeasureTheory.Memℒp g p → MeasureTheory.UniformIntegrable (fun x => g) p μ\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A function which can be locally uniformly approximated by continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} [inst_1 : TopologicalSpace α],\\n  (∀ (x : α), ∀ u ∈ uniformity β, ∃ t ∈ nhds x, ∃ F, ContinuousAt F x ∧ ∀ y ∈ t, (f y, F y) ∈ u) → Continuous f\"},\n {\"role\": \"user\",\n  \"content\": \"A locally uniform limit of continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\\n  [inst_1 : TopologicalSpace α],\\n  TendstoLocallyUniformly F f p → (∀ᶠ (n : ι) in p, Continuous (F n)) → ∀ [inst_2 : Filter.NeBot p], Continuous f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A function which can be uniformly approximated by continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} [inst_1 : TopologicalSpace α],\\n  (∀ u ∈ uniformity β, ∃ F, Continuous F ∧ ∀ (y : α), (f y, F y) ∈ u) → Continuous f\"},\n {\"role\": \"user\", \"content\": \"A constant function is uniformly integrable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {β : Type u_2} {ι : Type u_3} {m : MeasurableSpace α} (μ : MeasureTheory.Measure α)\\n  [inst : NormedAddCommGroup β] {p : ENNReal} {g : α → β},\\n  1 ≤ p → p ≠ ⊤ → MeasureTheory.Memℒp g p → MeasureTheory.UnifIntegrable (fun x => g) p μ\"},\n {\"role\": \"user\",\n  \"content\": \"A uniform limit of continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\\n  [inst_1 : TopologicalSpace α],\\n  TendstoUniformly F f p → (∀ᶠ (n : ι) in p, Continuous (F n)) → ∀ [inst_2 : Filter.NeBot p], Continuous f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Each function of a uniformly equicontinuous family is uniformly continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_1} {α : Type u_6} {β : Type u_7} [inst : UniformSpace α] [inst_1 : UniformSpace β] {F : ι → β → α},\\n  UniformEquicontinuous F → ∀ (i : ι), UniformContinuous (F i)\"},\n {\"role\": \"user\",\n  \"content\": \"Every continuous function is uniformly continuous.\"}]"}
{"text":"`6` is not the sum of two distinct prime numbers.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"`cyclotomic' n R` is different from `0`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (n : ℕ) (R : Type u_2) [inst : CommRing R] [inst_1 : IsDomain R], Polynomial.cyclotomic' n R ≠ 0\"},\n {\"role\": \"user\",\n  \"content\": \"Harmonic series is not unconditionally summable. \"},\n {\"role\": \"assistant\", \"content\": \"¬Summable fun n => 1 / ↑n\"},\n {\"role\": \"user\", \"content\": \"`cyclotomic n R` is different from `0`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (n : ℕ) (R : Type u_1) [inst : Ring R] [inst_1 : Nontrivial R], Polynomial.cyclotomic n R ≠ 0\"},\n {\"role\": \"user\",\n  \"content\": \"The ring of integers of a number field is not a field. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (K : Type u_1) [inst : Field K] [nf : NumberField K], ¬IsField ↥(NumberField.ringOfIntegers K)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 ≠ 3`. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {p n : ℕ}, Nat.Prime p → p ∣ n → IsSquare (-1) → p % 4 ≠ 3\"},\n {\"role\": \"user\", \"content\": \"A minimal polynomial is not `1`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (A : Type u_1) {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B)\\n  [inst_3 : Nontrivial B], minpoly A x ≠ 1\"},\n {\"role\": \"user\",\n  \"content\": \"The n-th harmonic number is not an integer for n ≥ 2. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n : ℕ}, 2 ≤ n → ¬Rat.isInt (harmonic n) = true\"},\n {\"role\": \"user\",\n  \"content\": \"Adjacent letters are not from the same summand. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_1} {M : ι → Type u_2} [inst : (i : ι) → Monoid (M i)] (self : Monoid.CoprodI.Word M),\\n  List.Chain' (fun l l' => l.fst ≠ l'.fst) self.toList\"},\n {\"role\": \"user\", \"content\": \"`2` is not a factor of an odd natural number. \"},\n {\"role\": \"assistant\", \"content\": \"∀ {m n : ℕ}, Odd n → m ∣ n → m ≠ 2\"},\n {\"role\": \"user\",\n  \"content\": \"`6` is not the sum of two distinct prime numbers.\"}]"}
{"text":"No integer is irrational.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If an integer with larger absolute value divides an integer, it is\\nzero. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {a b : ℤ}, a ∣ b → Int.natAbs b < Int.natAbs a → b = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"There is an irrational number `r` between any two reals `x < r < y`. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {x y : ℝ}, x < y → ∃ r, Irrational r ∧ x < r ∧ r < y\"},\n {\"role\": \"user\", \"content\": \"No zero divisors. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_2} [self : CanonicallyOrderedCommSemiring α] {a b : α}, a * b = 0 → a = 0 ∨ b = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every terminating continued fraction corresponds to a rational number. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] {v : K},\\n  GeneralizedContinuedFraction.Terminates (GeneralizedContinuedFraction.of v) → ∃ q, v = ↑q\"},\n {\"role\": \"user\",\n  \"content\": \"The conjugate of the golden ratio is irrational. \"},\n {\"role\": \"assistant\", \"content\": \"Irrational goldenConj\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A rational number has only finitely many good rational approximations. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (ξ : ℚ), Set.Finite {q | |ξ - q| < 1 / ↑q.den ^ 2}\"},\n {\"role\": \"user\",\n  \"content\": \"Nonzero fractional ideals contain a nonzero integer. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : CommRing R] {K : Type u_3} [inst_1 : Field K] [inst_2 : Algebra R K]\\n  [inst_3 : IsFractionRing R K] {I : FractionalIdeal (nonZeroDivisors R) K} [inst_4 : Nontrivial R],\\n  I ≠ 0 → ∃ x, x ≠ 0 ∧ (algebraMap R K) x ∈ I\"},\n {\"role\": \"user\",\n  \"content\": \"Every finite convergent corresponds to a rational number. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K) (n : ℕ),\\n  ∃ q, GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n = ↑q\"},\n {\"role\": \"user\", \"content\": \"A transcendental real number is irrational. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {r : ℝ}, Transcendental ℚ r → Irrational r\"},\n {\"role\": \"user\",\n  \"content\": \"If a rational is not a p-adic integer, it is not an integer. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (p : ℕ) {a : ℚ} [hp : Fact (Nat.Prime p)], 1 < padicNorm p a → ¬Rat.isInt a = true\"},\n {\"role\": \"user\", \"content\": \"No integer is irrational.\"}]"}
{"text":"The identity element in a ring is a unit.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"The identity is a group homomorphism. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u} [inst : Group α], IsGroupHom id\"},\n {\"role\": \"user\", \"content\": \"A ring isomorphism sends one to one. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_4} {S : Type u_5} [inst : NonAssocSemiring R] [inst_1 : NonAssocSemiring S] (f : R ≃+* S), f 1 = 1\"},\n {\"role\": \"user\",\n  \"content\": \"The characteristic of a finite ring cannot be zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (R : Type u_1) [inst : NonAssocRing R] (p : ℕ) [inst : CharP R p] [inst : Finite R], p ≠ 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"An element of a ring multiplied by the additive inverse of one is the element's additive\\ninverse. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : MulOneClass α] [inst_1 : HasDistribNeg α] (a : α), a * -1 = -a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The composition of the unit and the counit is equal to the identity up to unitors. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {B : Type u} [inst : CategoryTheory.Bicategory B] {a b : B} {f : a ⟶ b} {g : b ⟶ a}\\n  (self : CategoryTheory.Bicategory.Adjunction f g),\\n  CategoryTheory.Bicategory.leftZigzag self.unit self.counit =\\n    CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.leftUnitor f).hom\\n      (CategoryTheory.Bicategory.rightUnitor f).inv\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The group of units of a complete normed ring is an open subset of the ring. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R], IsOpen {x | IsUnit x}\"},\n {\"role\": \"user\", \"content\": \"A subring contains the ring's 1. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {R : Type u} [inst : Ring R] (s : Subring R), 1 ∈ s\"},\n {\"role\": \"user\",\n  \"content\": \"The units of a complete normed ring form a Lie group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] {𝕜 : Type u_2} [inst_2 : NontriviallyNormedField 𝕜]\\n  [inst_3 : NormedAlgebra 𝕜 R], LieGroup (modelWithCornersSelf 𝕜 R) Rˣ\"},\n {\"role\": \"user\", \"content\": \"The identity map is a ring homomorphism. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u} [inst : Ring α], IsRingHom id\"},\n {\"role\": \"user\",\n  \"content\": \"The chosen element of the base group itself is the identity \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_1} {G : ι → Type u_2} {H : Type u_3} [inst : (i : ι) → Group (G i)] [inst_1 : Group H]\\n  {φ : (i : ι) → H →* G i} (self : Monoid.PushoutI.NormalWord.Transversal φ) (i : ι),\\n  1 ∈ Monoid.PushoutI.NormalWord.Transversal.set self i\"},\n {\"role\": \"user\", \"content\": \"The identity element in a ring is a unit.\"}]"}
{"text":"Every subgroup of a group is a group.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"A subgroup is either the trivial subgroup or nontrivial. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), H = ⊥ ∨ Nontrivial ↥H\"},\n {\"role\": \"user\",\n  \"content\": \"Two subgroups are equal if they have the same elements. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] {H K : Subgroup G}, (∀ (x : G), x ∈ H ↔ x ∈ K) → H = K\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A subgroup is finitely generated if and only if it is finitely generated as a submonoid. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_3} [inst : Group G] (P : Subgroup G), Subgroup.FG P ↔ Submonoid.FG P.toSubmonoid\"},\n {\"role\": \"user\", \"content\": \"A subgroup is closed under inverse. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x : G}, x ∈ H → x⁻¹ ∈ H\"},\n {\"role\": \"user\",\n  \"content\": \"Subgroups of torsion groups are torsion groups. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G → ∀ (H : Subgroup G), Monoid.IsTorsion ↥H\"},\n {\"role\": \"user\", \"content\": \"A subgroup contains the group's 1. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), 1 ∈ H\"},\n {\"role\": \"user\",\n  \"content\": \"The subgroup generated by a set includes the set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] {k : Set G}, k ⊆ ↑(Subgroup.closure k)\"},\n {\"role\": \"user\", \"content\": \"A subgroup is closed under division. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {M : Type u_5} {S : Type u_6} [inst : DivInvMonoid M] [inst_1 : SetLike S M] [hSM : SubgroupClass S M] {H : S}\\n  {x y : M}, x ∈ H → y ∈ H → x / y ∈ H\"},\n {\"role\": \"user\", \"content\": \"A subgroup is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x ∈ H → y ∈ H → x * y ∈ H\"},\n {\"role\": \"user\", \"content\": \"Every subgroup of a group is a group.\"}]"}
{"text":"The sum of two natural numbers is a natural number.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The sum of ordinals as games corresponds to natural addition of ordinals. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (a b : Ordinal.{u}), Ordinal.toPGame a + Ordinal.toPGame b ≈ Ordinal.toPGame (Ordinal.nadd a b)\"},\n {\"role\": \"user\", \"content\": \"The sum of two `C^n`functions is `C^n`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type uE} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {n : ℕ∞}\\n  {f g : E → F}, ContDiff 𝕜 n f → ContDiff 𝕜 n g → ContDiff 𝕜 n fun x => f x + g x\"},\n {\"role\": \"user\",\n  \"content\": \"A sum of numbers is infinite iff one of them is infinite \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_1} {M : Type u_4} [inst : AddCommMonoid M] {s : Finset ι} {f : ι → WithTop M},\\n  (Finset.sum s fun i => f i) = ⊤ ↔ ∃ i ∈ s, f i = ⊤\"},\n {\"role\": \"user\",\n  \"content\": \"Pre-games defined by natural numbers are numeric. \"},\n {\"role\": \"assistant\", \"content\": \"∀ (n : ℕ), SetTheory.PGame.Numeric ↑n\"},\n {\"role\": \"user\",\n  \"content\": \"The sum of two finite adèles is a finite adèle. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} {K : Type u_2} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\\n  [inst_3 : Field K] [inst_4 : Algebra R K] [inst_5 : IsFractionRing R K]\\n  {x y : DedekindDomain.ProdAdicCompletions R K},\\n  DedekindDomain.ProdAdicCompletions.IsFiniteAdele x →\\n    DedekindDomain.ProdAdicCompletions.IsFiniteAdele y → DedekindDomain.ProdAdicCompletions.IsFiniteAdele (x + y)\"},\n {\"role\": \"user\", \"content\": \"A sum of finite numbers is still finite \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {s : Finset α} {f : α → ENNReal}, (∀ a ∈ s, f a ≠ ⊤) → (Finset.sum s fun a => f a) < ⊤\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {m n : ℕ}, (∀ (a : ℕ), a ∣ m ↔ a ∣ n) ↔ m = n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {m n : ℕ}, (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n\"},\n {\"role\": \"user\",\n  \"content\": \"The sum of two natural numbers is a natural number.\"}]"}
{"text":"The identity element of a group has finite order.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is simple. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleGroup α\"},\n {\"role\": \"user\",\n  \"content\": \"The chosen element of the base group itself is the identity \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_1} {G : ι → Type u_2} {H : Type u_3} [inst : (i : ι) → Group (G i)] [inst_1 : Group H]\\n  {φ : (i : ι) → H →* G i} (self : Monoid.PushoutI.NormalWord.Transversal φ) (i : ι),\\n  1 ∈ Monoid.PushoutI.NormalWord.Transversal.set self i\"},\n {\"role\": \"user\",\n  \"content\": \"Elements of finite order are closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : CommMonoid G] {x y : G}, IsOfFinOrder x → IsOfFinOrder y → IsOfFinOrder (x * y)\"},\n {\"role\": \"user\", \"content\": \"The identity is a group homomorphism. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u} [inst : Group α], IsGroupHom id\"},\n {\"role\": \"user\",\n  \"content\": \"Elements of finite order are of finite order in submonoids.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : AddMonoid G] {H : AddSubmonoid G} {x : ↥H}, IsOfFinAddOrder ↑x ↔ IsOfFinAddOrder x\"},\n {\"role\": \"user\",\n  \"content\": \"Inverses of elements of finite order have finite order. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x⁻¹ ↔ IsOfFinOrder x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The image of an element of finite additive order has finite additive order.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} {H : Type u_2} [inst : AddMonoid G] [inst_1 : AddMonoid H] (f : G →+ H) {x : G},\\n  IsOfFinAddOrder x → IsOfFinAddOrder (f x)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A group element has finite additive order iff its order is positive.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : AddMonoid G] {x : G}, 0 < addOrderOf x ↔ IsOfFinAddOrder x\"},\n {\"role\": \"user\",\n  \"content\": \"The image of an element of finite order has finite order. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} {H : Type u_2} [inst : Monoid G] [inst_1 : Monoid H] (f : G →* H) {x : G},\\n  IsOfFinOrder x → IsOfFinOrder (f x)\"},\n {\"role\": \"user\",\n  \"content\": \"A group element has finite order iff its order is positive. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x ↔ IsOfFinOrder x\"},\n {\"role\": \"user\",\n  \"content\": \"The identity element of a group has finite order.\"}]"}
{"text":"`7` is a prime number.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"`ζ - 1` is prime if `ζ` is a primitive `p ^ (k + 1)`-th root of unity. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ+} {k : ℕ} {K : Type u} [inst : Field K] [inst_1 : CharZero K] {ζ : K} [hp : Fact (Nat.Prime ↑p)]\\n  [inst_2 : IsCyclotomicExtension {p ^ (k + 1)} ℚ K] (hζ : IsPrimitiveRoot ζ ↑(p ^ (k + 1))),\\n  Prime (IsPrimitiveRoot.toInteger hζ - 1)\"},\n {\"role\": \"user\", \"content\": \"A minimal polynomial is prime. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\\n  IsIntegral A x → Prime (minpoly A x)\"},\n {\"role\": \"user\",\n  \"content\": \"The only prime factor of prime `p` is `p` itself. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {p q : ℕ}, Nat.Prime p → (Nat.factorization p) q ≠ 0 → p = q\"},\n {\"role\": \"user\",\n  \"content\": \"The only divisors of prime powers are prime powers. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [dec_irr : (p : Associates α) → Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid α] [dec : DecidableEq α] [dec' : DecidableEq (Associates α)] {a p : Associates α},\\n  Irreducible p →\\n    ∀ [inst_2 : (n : ℕ) → Decidable (a ∣ p ^ n)] {n : ℕ} (h : a ∣ p ^ n),\\n      a = p ^ Nat.find (_ : ∃ n, (fun n => a ∣ p ^ n) n)\"},\n {\"role\": \"user\",\n  \"content\": \"`ζ - 1` is prime if `ζ` is a primitive `p`-th root of unity. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ+} {K : Type u} [inst : Field K] [inst_1 : CharZero K] {ζ : K} [hp : Fact (Nat.Prime ↑p)]\\n  [h : IsCyclotomicExtension {p} ℚ K] (hζ : IsPrimitiveRoot ζ ↑p), Prime (IsPrimitiveRoot.toInteger hζ - 1)\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\", \"content\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\"},\n {\"role\": \"user\",\n  \"content\": \"The exponential characteristic is a prime number or one. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (R : Type u) [inst : Semiring R] (q : ℕ) [hq : ExpChar R q], Nat.Prime q ∨ q = 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (n : ℕ), Nat.factorization n = 0 ↔ n = 0 ∨ n = 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"`2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare 2 ↔ p % 8 = 1 ∨ p % 8 = 7)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A prime natural number is prime in `ℤ[i]` if and only if it is `3` mod `4` \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)], Prime ↑p ↔ p % 4 = 3\"},\n {\"role\": \"user\", \"content\": \"`7` is a prime number.\"}]"}
{"text":"There are `3` prime numbers below `8`.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"`2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare 2 ↔ p % 8 = 1 ∨ p % 8 = 7)\"},\n {\"role\": \"user\", \"content\": \"The factors of `n` are the prime divisors \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (n : ℕ), List.toFinset (Nat.factors n) = Finset.filter Nat.Prime (Nat.divisors n)\"},\n {\"role\": \"user\",\n  \"content\": \"The only divisors of prime powers are prime powers. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [dec_irr : (p : Associates α) → Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid α] [dec : DecidableEq α] [dec' : DecidableEq (Associates α)] {a p : Associates α},\\n  Irreducible p →\\n    ∀ [inst_2 : (n : ℕ) → Decidable (a ∣ p ^ n)] {n : ℕ} (h : a ∣ p ^ n),\\n      a = p ^ Nat.find (_ : ∃ n, (fun n => a ∣ p ^ n) n)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The square of the smallest prime factor of a composite number `n` is at most `n`.\\n\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n : ℕ}, 0 < n → ¬Nat.Prime n → Nat.minFac n ^ 2 ≤ n\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\", \"content\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"`-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare (-2) ↔ p % 8 = 1 ∨ p % 8 = 3)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The product of the prime factors of `n` that are less than `N` is an `N`-smooth number. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (n N : ℕ), List.prod (List.filter (fun x => decide (x < N)) (Nat.factors n)) ∈ Nat.smoothNumbers N\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A prime natural number is prime in `ℤ[i]` if and only if it is `3` mod `4` \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)], Prime ↑p ↔ p % 4 = 3\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (n : ℕ), Nat.factorization n = 0 ↔ n = 0 ∨ n = 1\"},\n {\"role\": \"user\", \"content\": \"There are `3` prime numbers below `8`.\"}]"}
{"text":"The empty set is contained in every finite set.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"The shadow of the empty set is empty. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u_1} [inst : DecidableEq α], Finset.shadow ∅ = ∅\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In an infinite graph, the set of components out of a finite set is nonempty. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {V : Type u} (G : SimpleGraph V) [inst : Infinite V] (K : Finset V), Nonempty (SimpleGraph.ComponentCompl G ↑K)\"},\n {\"role\": \"user\",\n  \"content\": \"Uniform convergence on the empty set is vacuously true \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι},\\n  TendstoUniformlyOn F f p ∅\"},\n {\"role\": \"user\",\n  \"content\": \"There are finitely many subsets of a given finite set \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {a : Set α}, Set.Finite a → Set.Finite {b | b ⊆ a}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every finite subset of a linearly independent set is linearly independent. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_2} {M : Type u_4} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (s : Set M),\\n  LinearIndependent (ι := { x // x ∈ s }) R Subtype.val → ∀ (t : Finset ↑s), LinearIndependent R Subtype.val\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any uncountable closed set in a second countable space contains a nonempty perfect subset.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] {C : Set α} [inst_1 : SecondCountableTopology α],\\n  IsClosed C → ¬Set.Countable C → ∃ D, Perfect D ∧ Set.Nonempty D ∧ D ⊆ C\"},\n {\"role\": \"user\", \"content\": \"A finite union of finsets is finite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} (f : α → Finset β), Set.Finite (Set.range f) → Set.Finite (⋃ a, ↑(f a))\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every finite subset of an algebraically independent set is algebraically independent. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_3} {A : Type u_5} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] (s : Set A),\\n  AlgebraicIndependent R Subtype.val → ∀ (t : Finset ↑s), AlgebraicIndependent R Subtype.val\"},\n {\"role\": \"user\", \"content\": \"The empty set is concyclic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : NormedSpace ℝ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P], EuclideanGeometry.Concyclic ∅\"},\n {\"role\": \"user\",\n  \"content\": \"The set of finite subsets of a countable set is countable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {s : Set α}, Set.Countable s → Set.Countable {t | Set.Finite t ∧ t ⊆ s}\"},\n {\"role\": \"user\", \"content\": \"The empty set is contained in every finite set.\"}]"}
{"text":"Every infinite set contains a finite set.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For every open cover of a compact set, there exists a finite subcover. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u} {ι : Type u_1} [inst : TopologicalSpace X] {s : Set X} {b : Set ι} {c : ι → Set X},\\n  IsCompact s → (∀ i ∈ b, IsOpen (c i)) → s ⊆ ⋃ i ∈ b, c i → ∃ b' ⊆ b, Set.Finite b' ∧ s ⊆ ⋃ i ∈ b', c i\"},\n {\"role\": \"user\",\n  \"content\": \"The semilatice generated by a finite set is finite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_2} [inst : SemilatticeSup α] {s : Set α}, Set.Finite s → Set.Finite (supClosure s)\"},\n {\"role\": \"user\", \"content\": \"A finite set is bounded below.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : Preorder α] [inst_1 : IsDirected α fun x x_1 => x ≥ x_1] [inst_2 : Nonempty α] {s : Set α},\\n  Set.Finite s → BddBelow s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every finite subset of an algebraically independent set is algebraically independent. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_3} {A : Type u_5} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] (s : Set A),\\n  AlgebraicIndependent R Subtype.val → ∀ (t : Finset ↑s), AlgebraicIndependent R Subtype.val\"},\n {\"role\": \"user\", \"content\": \"Finite product of finite sets is finite \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {δ : Type u_1} [inst : Finite δ] {κ : δ → Type u_2} {t : (d : δ) → Set (κ d)},\\n  (∀ (d : δ), Set.Finite (t d)) → Set.Finite (Set.pi Set.univ t)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every finite subset of a linearly independent set is linearly independent. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_2} {M : Type u_4} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (s : Set M),\\n  LinearIndependent (ι := { x // x ∈ s }) R Subtype.val → ∀ (t : Finset ↑s), LinearIndependent R Subtype.val\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In an infinite graph, the set of components out of a finite set is nonempty. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {V : Type u} (G : SimpleGraph V) [inst : Infinite V] (K : Finset V), Nonempty (SimpleGraph.ComponentCompl G ↑K)\"},\n {\"role\": \"user\",\n  \"content\": \"There are finitely many subsets of a given finite set \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {a : Set α}, Set.Finite a → Set.Finite {b | b ⊆ a}\"},\n {\"role\": \"user\", \"content\": \"A finite union of finsets is finite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} (f : α → Finset β), Set.Finite (Set.range f) → Set.Finite (⋃ a, ↑(f a))\"},\n {\"role\": \"user\",\n  \"content\": \"The set of finite subsets of a countable set is countable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {s : Set α}, Set.Countable s → Set.Countable {t | Set.Finite t ∧ t ⊆ s}\"},\n {\"role\": \"user\", \"content\": \"Every infinite set contains a finite set.\"}]"}
{"text":"Every commutative ring is a monoid.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"Left multiplication in a ring is an additive monoid morphism. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {γ : Type u_1} [inst : NonUnitalNonAssocSemiring γ] (x : γ), IsAddMonoidHom fun y => x * y\"},\n {\"role\": \"user\",\n  \"content\": \"The category of commutative rings has all limits. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"CategoryTheory.Limits.HasLimitsOfSize.{v, v, max u v, max (u + 1) (v + 1)} CommRingCatMax\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If all prime ideals in a commutative ring are principal, so are all other ideals. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : CommRing R],\\n  (∀ (P : Ideal R), Ideal.IsPrime P → Submodule.IsPrincipal P) → IsPrincipalIdealRing R\"},\n {\"role\": \"user\", \"content\": \"1 is of finite order in any monoid. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder 1\"},\n {\"role\": \"user\",\n  \"content\": \"Composition of monoid homomorphisms is associative. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {M : Type u_3} {N : Type u_4} {P : Type u_5} {Q : Type u_9} [inst : One M] [inst_1 : One N] [inst_2 : One P]\\n  [inst_3 : One Q] (f : OneHom M N) (g : OneHom N P) (h : OneHom P Q),\\n  OneHom.comp (OneHom.comp h g) f = OneHom.comp h (OneHom.comp g f)\"},\n {\"role\": \"user\",\n  \"content\": \"The category of commutative monoids has all limits. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"CategoryTheory.Limits.HasLimitsOfSize.{v, v, max u v, max (u + 1) (v + 1)} CommMonCatMax\"},\n {\"role\": \"user\", \"content\": \"A group homomorphism is a monoid homomorphism. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : Group β] {f : α → β}, IsGroupHom f → IsMonoidHom f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The composite of two monoid homomorphisms is a monoid homomorphism. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : MulOneClass α] [inst_1 : MulOneClass β] {f : α → β},\\n  IsMonoidHom f → ∀ {γ : Type u_1} [inst_2 : MulOneClass γ] {g : β → γ}, IsMonoidHom g → IsMonoidHom (g ∘ f)\"},\n {\"role\": \"user\", \"content\": \"A monoid is a submonoid of itself. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {M : Type u_1} [inst : Monoid M], IsSubmonoid Set.univ\"},\n {\"role\": \"user\",\n  \"content\": \"The center of a monoid acts commutatively on that monoid. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {M : Type u_1} [inst : Monoid M], SMulCommClass M (↥(Submonoid.center M)) M\"},\n {\"role\": \"user\", \"content\": \"Every commutative ring is a monoid.\"}]"}
{"text":"There is no field of order `10`.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"The empty set is nowhere dense. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {X : Type u_4} [inst : TopologicalSpace X], IsNowhereDense ∅\"},\n {\"role\": \"user\", \"content\": \"In a dense order, nothing covers anything. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : LT α] {a b : α} [inst_1 : DenselyOrdered α], ¬a ⋖ b\"},\n {\"role\": \"user\", \"content\": \"The order of the `0` power series is infinite.\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {R : Type u_1} [inst : Semiring R], PowerSeries.order 0 = ⊤\"},\n {\"role\": \"user\", \"content\": \"An intermediate field contains the ring's 0. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u_1} {L : Type u_2} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\\n  0 ∈ S\"},\n {\"role\": \"user\", \"content\": \"No points are in `⊥`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (k : Type u_1) (V : Type u_2) {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [S : AddTorsor V P] (p : P), p ∉ ⊥\"},\n {\"role\": \"user\",\n  \"content\": \"`ℤ` with its usual ring structure is not a field. \"},\n {\"role\": \"assistant\", \"content\": \"¬IsField ℤ\"},\n {\"role\": \"user\",\n  \"content\": \"Infinite ordinals that are cardinals are unbounded. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"Set.Unbounded (fun x x_1 => x < x_1) {b | Cardinal.ord (Ordinal.card b) = b ∧ Ordinal.omega ≤ b}\"},\n {\"role\": \"user\", \"content\": \"Fields are commutative. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : Semiring R], IsField R → ∀ (x y : R), x * y = y * x\"},\n {\"role\": \"user\", \"content\": \"Ordinals that are cardinals are unbounded. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"Set.Unbounded (fun x x_1 => x < x_1) {b | Cardinal.ord (Ordinal.card b) = b}\"},\n {\"role\": \"user\",\n  \"content\": \"The ring of integers of a number field is not a field. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (K : Type u_1) [inst : Field K] [nf : NumberField K], ¬IsField ↥(NumberField.ringOfIntegers K)\"},\n {\"role\": \"user\", \"content\": \"There is no field of order `10`.\"}]"}
{"text":"Every odd natural number is the sum of two distinct natural numbers.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"A natural number is odd iff it has residue `1` or `3` mod `4`\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n : ℕ}, n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3\"},\n {\"role\": \"user\", \"content\": \"A sum of finite numbers is still finite \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {s : Finset α} {f : α → ENNReal}, (∀ a ∈ s, f a ≠ ⊤) → (Finset.sum s fun a => f a) < ⊤\"},\n {\"role\": \"user\",\n  \"content\": \"Every finite convergent corresponds to a rational number. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K) (n : ℕ),\\n  ∃ q, GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n = ↑q\"},\n {\"role\": \"user\",\n  \"content\": \"The sum of two finite adèles is a finite adèle. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} {K : Type u_2} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\\n  [inst_3 : Field K] [inst_4 : Algebra R K] [inst_5 : IsFractionRing R K]\\n  {x y : DedekindDomain.ProdAdicCompletions R K},\\n  DedekindDomain.ProdAdicCompletions.IsFiniteAdele x →\\n    DedekindDomain.ProdAdicCompletions.IsFiniteAdele y → DedekindDomain.ProdAdicCompletions.IsFiniteAdele (x + y)\"},\n {\"role\": \"user\", \"content\": \"`2` is not a factor of an odd natural number. \"},\n {\"role\": \"assistant\", \"content\": \"∀ {m n : ℕ}, Odd n → m ∣ n → m ≠ 2\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\", \"content\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {m n : ℕ}, (∀ (a : ℕ), a ∣ m ↔ a ∣ n) ↔ m = n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {m n : ℕ}, (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every odd natural number is the sum of two distinct natural numbers.\"}]"}
{"text":"Every element in the trivial group has finite order.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A group element has finite additive order iff its order is positive.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : AddMonoid G] {x : G}, 0 < addOrderOf x ↔ IsOfFinAddOrder x\"},\n {\"role\": \"user\",\n  \"content\": \"Elements of finite order are of finite order in submonoids.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : AddMonoid G] {H : AddSubmonoid G} {x : ↥H}, IsOfFinAddOrder ↑x ↔ IsOfFinAddOrder x\"},\n {\"role\": \"user\",\n  \"content\": \"Elements of finite order are closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : CommMonoid G] {x y : G}, IsOfFinOrder x → IsOfFinOrder y → IsOfFinOrder (x * y)\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is cyclic.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsAddCyclic α\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is cyclic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α\"},\n {\"role\": \"user\",\n  \"content\": \"The image of an element of finite order has finite order. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} {H : Type u_2} [inst : Monoid G] [inst_1 : Monoid H] (f : G →* H) {x : G},\\n  IsOfFinOrder x → IsOfFinOrder (f x)\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is simple.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleAddGroup α\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is simple. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleGroup α\"},\n {\"role\": \"user\",\n  \"content\": \"A group element has finite order iff its order is positive. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x ↔ IsOfFinOrder x\"},\n {\"role\": \"user\",\n  \"content\": \"Inverses of elements of finite order have finite order. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x⁻¹ ↔ IsOfFinOrder x\"},\n {\"role\": \"user\",\n  \"content\": \"Every element in the trivial group has finite order.\"}]"}
{"text":"The square of an even number is even.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"`2` is a square in `F` iff `#F` is not congruent to `3` or `5` mod `8`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F], IsSquare 2 ↔ Fintype.card F % 8 ≠ 3 ∧ Fintype.card F % 8 ≠ 5\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The finite field `F` has even cardinality iff it has characteristic `2`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {F : Type u_3} [inst : Field F] [inst_1 : Fintype F], ringChar F = 2 ↔ Fintype.card F % 2 = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"`2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare 2 ↔ p % 8 = 1 ∨ p % 8 = 7)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Commutativity of a square is preserved when taking quotients by an ideal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} {S : Type v} [inst : CommRing R] [inst_1 : CommRing S] {R' : Type u_5} {S' : Type u_6}\\n  [inst_2 : CommRing R'] [inst_3 : CommRing S'] {f : R →+* S} {f' : R' →+* S'} {g : R →+* R'} {g' : S →+* S'}\\n  (hfg : RingHom.comp f' g = RingHom.comp g' f) (I : Ideal S'),\\n  let leq := (_ : Ideal.comap f (Ideal.comap g' I) ≤ Ideal.comap g (Ideal.comap f' I));\\n  RingHom.comp (Ideal.quotientMap I g' (_ : Ideal.comap g' I ≤ Ideal.comap g' I))\\n      (Ideal.quotientMap (Ideal.comap g' I) f\\n        (_ : Ideal.comap f (Ideal.comap g' I) ≤ Ideal.comap f (Ideal.comap g' I))) =\\n    RingHom.comp (Ideal.quotientMap I f' (_ : Ideal.comap f' I ≤ Ideal.comap f' I))\\n      (Ideal.quotientMap (Ideal.comap f' I) g leq)\"},\n {\"role\": \"user\", \"content\": \"The square commutes. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {C : Type u_1} [inst : CategoryTheory.Category.{u_2, u_1} C] {W X Y Z : C} {f : W ⟶ X} {g : W ⟶ Y} {h : X ⟶ Z}\\n  {i : Y ⟶ Z},\\n  CategoryTheory.CommSq f g h i → CategoryTheory.CategoryStruct.comp f h = CategoryTheory.CategoryStruct.comp g i\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a finite field of odd characteristic, not every element is a square. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {F : Type u_3} [inst : Field F] [inst_1 : Finite F], ringChar F ≠ 2 → ∃ a, ¬IsSquare a\"},\n {\"role\": \"user\",\n  \"content\": \"The sum of two squares is zero iff both elements are zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : LinearOrderedRing α] {x y : α}, x * x + y * y = 0 ↔ x = 0 ∧ y = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a finite field of characteristic `2`, all elements are squares. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {F : Type u_3} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 → ∀ (a : F), IsSquare a\"},\n {\"role\": \"user\",\n  \"content\": \"The convolution of two even functions is also even. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {𝕜 : Type u𝕜} {G : Type uG} {E : Type uE} {E' : Type uE'} {F : Type uF} [inst : NormedAddCommGroup E]\\n  [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedAddCommGroup F] {f : G → E} {g : G → E'} {x : G}\\n  [inst_3 : NontriviallyNormedField 𝕜] [inst_4 : NormedSpace 𝕜 E] [inst_5 : NormedSpace 𝕜 E'] [inst_6 : NormedSpace 𝕜 F]\\n  (L : E →L[𝕜] E' →L[𝕜] F) [inst_7 : MeasurableSpace G] {μ : MeasureTheory.Measure G} [inst_8 : NormedSpace ℝ F]\\n  [inst_9 : AddCommGroup G] [inst_10 : MeasureTheory.Measure.IsAddLeftInvariant μ]\\n  [inst_11 : MeasureTheory.Measure.IsNegInvariant μ] [inst_12 : MeasurableNeg G] [inst_13 : MeasurableAdd G],\\n  (∀ᵐ (x : G) ∂μ, f (-x) = f x) → (∀ᵐ (x : G) ∂μ, g (-x) = g x) → convolution f g L (-x) = convolution f g L x\"},\n {\"role\": \"user\", \"content\": \"The square of an even number is even.\"}]"}
{"text":"Every commutative division ring is a field.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every nonarchimedean ring is naturally a nonarchimedean additive group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (R : Type u_1) [inst : Ring R] [inst_1 : TopologicalSpace R] [t : NonarchimedeanRing R], NonarchimedeanAddGroup R\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The multivariate polynomial ring over an integral domain is an integral domain. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} {σ : Type v} [inst : CommRing R] [inst_1 : IsDomain R], IsDomain (MvPolynomial σ R)\"},\n {\"role\": \"user\",\n  \"content\": \"An intermediate field is closed under division. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u_1} {L : Type u_2} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\\n  {x y : L}, x ∈ S → y ∈ S → x / y ∈ S\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A cyclotomic finite extension of a number field is a number field. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (S : Set ℕ+) (K : Type w) (L : Type z) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] [h : NumberField K]\\n  [inst_3 : Finite ↑S] [inst : IsCyclotomicExtension S K L], NumberField L\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A field is perfect if every irreducible polynomial is separable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u_1} [inst : Field K] [self : PerfectField K] {f : Polynomial K}, Irreducible f → Polynomial.Separable f\"},\n {\"role\": \"user\", \"content\": \"A field is a valuation ring. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (K : Type u) [inst : Field K], ValuationRing K\"},\n {\"role\": \"user\",\n  \"content\": \"The category of commutative rings has all limits. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"CategoryTheory.Limits.HasLimitsOfSize.{v, v, max u v, max (u + 1) (v + 1)} CommRingCatMax\"},\n {\"role\": \"user\",\n  \"content\": \"An algebraically closed field is also separably closed. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (k : Type u) [inst : Field k] [inst_1 : IsAlgClosed k], IsSepClosed k\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The quotient of a ring by an ideal is a field iff the ideal is maximal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I ↔ IsField (R ⧸ I)\"},\n {\"role\": \"user\", \"content\": \"Fields are commutative. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : Semiring R], IsField R → ∀ (x y : R), x * y = y * x\"},\n {\"role\": \"user\", \"content\": \"Every commutative division ring is a field.\"}]"}
{"text":"The image of the identity element under the identity map is the identity element.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"The identity map preserves addition\"},\n {\"role\": \"assistant\", \"content\": \"∀ {α : Type u} [inst : Add α], IsAddHom id\"},\n {\"role\": \"user\", \"content\": \"The identity is a group homomorphism. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u} [inst : Group α], IsGroupHom id\"},\n {\"role\": \"user\", \"content\": \"The identity is an isometry \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u} [inst : PseudoEMetricSpace α], Isometry id\"},\n {\"role\": \"user\",\n  \"content\": \"The chosen element of the base group itself is the identity \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_1} {G : ι → Type u_2} {H : Type u_3} [inst : (i : ι) → Group (G i)] [inst_1 : Group H]\\n  {φ : (i : ι) → H →* G i} (self : Monoid.PushoutI.NormalWord.Transversal φ) (i : ι),\\n  1 ∈ Monoid.PushoutI.NormalWord.Transversal.set self i\"},\n {\"role\": \"user\", \"content\": \"The identity affine map acts as the identity. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (k : Type u_1) {V1 : Type u_2} (P1 : Type u_3) [inst : Ring k] [inst_1 : AddCommGroup V1] [inst_2 : Module k V1]\\n  [inst_3 : AddTorsor V1 P1], ⇑(AffineMap.id k P1) = id\"},\n {\"role\": \"user\",\n  \"content\": \"The identity map is an additive monoid homomorphism.\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u} [inst : AddZeroClass α], IsAddMonoidHom id\"},\n {\"role\": \"user\", \"content\": \"The identity map is a semiring homomorphism. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u} [inst : Semiring α], IsSemiringHom id\"},\n {\"role\": \"user\", \"content\": \"The identity map preserves multiplication. \"},\n {\"role\": \"assistant\", \"content\": \"∀ {α : Type u} [inst : Mul α], IsMulHom id\"},\n {\"role\": \"user\", \"content\": \"The identity map is a monoid homomorphism. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u} [inst : MulOneClass α], IsMonoidHom id\"},\n {\"role\": \"user\", \"content\": \"The identity map is a ring homomorphism. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u} [inst : Ring α], IsRingHom id\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The image of the identity element under the identity map is the identity element.\"}]"}
{"text":"Every point is a fixed point of the identity function on a space.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"An affinely independent set of points can be extended to such a\\nset that spans the whole space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] {s : Set P},\\n  (AffineIndependent k fun p => ↑p) → ∃ t, s ⊆ t ∧ (AffineIndependent k fun p => ↑p) ∧ affineSpan k t = ⊤\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two points in a projective space are dependent if and only if they are equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u_2} {V : Type u_3} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  (u v : Projectivization K V), Projectivization.Dependent ![u, v] ↔ u = v\"},\n {\"role\": \"user\", \"content\": \"For the identity map, all points are periodic. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u_1} (n : ℕ) (x : α), Function.IsPeriodicPt id n x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"An affine-independent subset of a finite-dimensional affine space is finite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (k : Type u_1) {V : Type u_2} {P : Type u_3} {ι : Type u_4} [inst : DivisionRing k] [inst_1 : AddCommGroup V]\\n  [inst_2 : Module k V] [inst_3 : AddTorsor V P] [inst_4 : FiniteDimensional k V] {s : Set ι} {f : ↑s → P},\\n  AffineIndependent k f → Set.Finite s\"},\n {\"role\": \"user\",\n  \"content\": \"Two inseparable points in a T₀ space are equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u} [inst : TopologicalSpace X] [self : T0Space X] ⦃x y : X⦄, Inseparable x y → x = y\"},\n {\"role\": \"user\", \"content\": \"All hom spaces are finite dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {k G : Type u} [inst : Field k] [inst_1 : Monoid G] (V W : FdRep k G), FiniteDimensional k (V ⟶ W)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A point is in the affine span of a single point if and only if they are equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (k : Type u_1) (V : Type u_2) {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [S : AddTorsor V P] {p₁ p₂ : P}, p₁ ∈ affineSpan k {p₂} ↔ p₁ = p₂\"},\n {\"role\": \"user\",\n  \"content\":\n  \"An affine-independent family of points in a finite-dimensional affine space is finite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (k : Type u_1) {V : Type u_2} {P : Type u_3} {ι : Type u_4} [inst : DivisionRing k] [inst_1 : AddCommGroup V]\\n  [inst_2 : Module k V] [inst_3 : AddTorsor V P] [inst_4 : FiniteDimensional k V] {p : ι → P},\\n  AffineIndependent k p → Finite ι\"},\n {\"role\": \"user\",\n  \"content\": \"The set of fixed points of a continuous map is a closed set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : T2Space α] {f : α → α},\\n  Continuous f → IsClosed (Function.fixedPoints f)\"},\n {\"role\": \"user\", \"content\": \"Every point is a fixed point of `id`. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u} (x : α), Function.IsFixedPt id x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every point is a fixed point of the identity function on a space.\"}]"}
{"text":"The diameter of a singleton space is `0`.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The one point compactification of a `T0Space` space is a `T0Space`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T0Space X], T0Space (OnePoint X)\"},\n {\"role\": \"user\", \"content\": \"A singleton in a T₁ space is a closed set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u} [inst : TopologicalSpace X] [self : T1Space X] (x : X), IsClosed {x}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A nonempty set is scaled by zero to the singleton set containing 0. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_2} {β : Type u_3} [inst : Zero α] [inst_1 : Zero β] [inst_2 : SMulWithZero α β] [inst_3 : DecidableEq β]\\n  {s : Finset β}, Finset.Nonempty s → 0 • s = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A space is totally disconnected iff its connected components are singletons. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α], TotallyDisconnectedSpace α ↔ ∀ (x : α), connectedComponent x = {x}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The image of a connected component in a totally disconnected space is a singleton. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {β : Type u_3} [inst_1 : TopologicalSpace β]\\n  [inst_2 : TotallyDisconnectedSpace β] {f : α → β}, Continuous f → ∀ (a : α), f '' connectedComponent a = {f a}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A (finite dimensional) space that is a subsingleton has zero `finrank`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : Ring K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] [inst_3 : Nontrivial K]\\n  [inst_4 : NoZeroSMulDivisors K V] [h : Subsingleton V], FiniteDimensional.finrank K V = 0\"},\n {\"role\": \"user\", \"content\": \"The diameter of the empty set vanishes \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : PseudoEMetricSpace α], EMetric.diam ∅ = 0\"},\n {\"role\": \"user\", \"content\": \"The empty set has zero diameter \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u} [inst : PseudoMetricSpace α], Metric.diam ∅ = 0\"},\n {\"role\": \"user\", \"content\": \"The diameter of a singleton vanishes \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : PseudoEMetricSpace α] {x : α}, EMetric.diam {x} = 0\"},\n {\"role\": \"user\", \"content\": \"A singleton has zero diameter \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0\"},\n {\"role\": \"user\", \"content\": \"The diameter of a singleton space is `0`.\"}]"}
{"text":"Every group is non-empty.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The cartesian product of two nonarchimedean groups is nonarchimedean. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : NonarchimedeanGroup G] {K : Type u_3}\\n  [inst_3 : Group K] [inst_4 : TopologicalSpace K] [inst_5 : NonarchimedeanGroup K], NonarchimedeanGroup (G × K)\"},\n {\"role\": \"user\", \"content\": \"A non-cyclic additive group is non-trivial.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : AddGroup α], ¬IsAddCyclic α → Nontrivial α\"},\n {\"role\": \"user\",\n  \"content\": \"The intrinsic interior of a nonempty convex set is nonempty. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {V : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : NormedSpace ℝ V] [inst_2 : FiniteDimensional ℝ V] {s : Set V},\\n  Convex ℝ s → Set.Nonempty s → Set.Nonempty (intrinsicInterior ℝ s)\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [self : LinearOrderedCommGroupWithZero α] (a : α), a ≠ 0 → a * a⁻¹ = 1\"},\n {\"role\": \"user\", \"content\": \"The affine span of a nonempty set is nonempty. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (k : Type u_1) {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] {s : Set P} [inst_4 : Nonempty ↑s], Nonempty ↥(affineSpan k s)\"},\n {\"role\": \"user\",\n  \"content\": \"The set in the definition of division is nonempty. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {a b : Ordinal.{u_4}}, b ≠ 0 → Set.Nonempty {o | a < b * Order.succ o}\"},\n {\"role\": \"user\", \"content\": \"A connected space is nonempty. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [self : ConnectedSpace α], Nonempty α\"},\n {\"role\": \"user\", \"content\": \"The ideal is nonempty. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {P : Type u_2} [inst : LE P] (self : Order.Ideal P), Set.Nonempty self.carrier\"},\n {\"role\": \"user\",\n  \"content\": \"Each connected component of the category is nonempty. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {J : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} J] (j : CategoryTheory.ConnectedComponents J),\\n  Nonempty (CategoryTheory.Component j)\"},\n {\"role\": \"user\", \"content\": \"Every group is non-empty.\"}]"}
{"text":"All connected components of a topological space are connected.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"Each connected component of the category is nonempty. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {J : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} J] (j : CategoryTheory.ConnectedComponents J),\\n  Nonempty (CategoryTheory.Component j)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any two points in a path-connected space must be joined by a continuous path. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u_4} [inst : TopologicalSpace X] [self : PathConnectedSpace X] (x y : X), Joined x y\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A space is totally disconnected iff its connected components are subsingletons. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α],\\n  TotallyDisconnectedSpace α ↔ ∀ (x : α), Set.Subsingleton (connectedComponent x)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A space is totally disconnected iff its connected components are singletons. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α], TotallyDisconnectedSpace α ↔ ∀ (x : α), connectedComponent x = {x}\"},\n {\"role\": \"user\",\n  \"content\": \"A space with discrete topology is a locally connected space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (α : Type u_3) [inst : TopologicalSpace α] [inst_1 : DiscreteTopology α], LocallyConnectedSpace α\"},\n {\"role\": \"user\", \"content\": \"A connected space is nonempty. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [self : ConnectedSpace α], Nonempty α\"},\n {\"role\": \"user\", \"content\": \"Finite topological spaces are compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : Finite X], CompactSpace X\"},\n {\"role\": \"user\",\n  \"content\": \"Each connected component of the category is connected. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {J : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} J] (j : CategoryTheory.ConnectedComponents J),\\n  CategoryTheory.IsConnected (CategoryTheory.Component j)\"},\n {\"role\": \"user\", \"content\": \"The underlying topological space is compact.\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (self : CompHaus), CompactSpace ↑self.toTop\"},\n {\"role\": \"user\",\n  \"content\": \"All connected components of a topological space are connected.\"}]"}
{"text":"The ring of integers has a maximal ideal.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The class number is `1` iff the ring of integers is a principal ideal domain. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\\n  [inst_3 : Fintype (ClassGroup R)], Fintype.card (ClassGroup R) = 1 ↔ IsPrincipalIdealRing R\"},\n {\"role\": \"user\",\n  \"content\": \"This ideal is maximal in the collection of proper ideals. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {P : Type u_1} [inst : LE P] {I : Order.Ideal P} [self : Order.Ideal.IsMaximal I] ⦃J : Order.Ideal P⦄,\\n  I < J → ↑J = Set.univ\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The ring of integers of a `p`-th cyclotomic extension of `ℚ` is a cyclotomic extension. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ+} {K : Type u} [inst : Field K] [inst_1 : CharZero K] [hp : Fact (Nat.Prime ↑p)]\\n  [inst_2 : IsCyclotomicExtension {p} ℚ K], IsCyclotomicExtension {p} ℤ ↥(NumberField.ringOfIntegers K)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If the quotient by an ideal is a field, then the ideal is maximal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : CommRing R] (I : Ideal R), IsField (R ⧸ I) → Ideal.IsMaximal I\"},\n {\"role\": \"user\",\n  \"content\": \"Multiplicativity of the ideal norm in number rings. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {S : Type u_1} [inst : CommRing S] [inst_1 : IsDomain S] [inst_2 : IsDedekindDomain S] [inst_3 : Module.Free ℤ S]\\n  [inst_4 : Module.Finite ℤ S] (I J : Ideal S), Submodule.cardQuot (I * J) = Submodule.cardQuot I * Submodule.cardQuot J\"},\n {\"role\": \"user\",\n  \"content\": \"Maximal ideals in complete normed rings are closed. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] {I : Ideal R} [hI : Ideal.IsMaximal I], IsClosed ↑I\"},\n {\"role\": \"user\",\n  \"content\": \"Krull's theorem: a nontrivial ring has a maximal ideal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (α : Type u) [inst : Semiring α] [inst_1 : Nontrivial α], ∃ M, Ideal.IsMaximal M\"},\n {\"role\": \"user\",\n  \"content\": \"When a ring is not a field, the maximal ideals are nontrivial. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : CommSemiring R] [inst_1 : Nontrivial R] {M : Ideal R}, Ideal.IsMaximal M → ¬IsField R → M ≠ ⊥\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The quotient of a ring by an ideal is a field iff the ideal is maximal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I ↔ IsField (R ⧸ I)\"},\n {\"role\": \"user\", \"content\": \"The ring of integers has a maximal ideal.\"}]"}
{"text":"The numbers `3`, `4` and `5` form a Pythagorean triple.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"`(k*x, k*y, k*z)` is a Pythagorean triple if and only if\\n`(x, y, z)` is also a triple. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {x y z : ℤ} (k : ℤ), k ≠ 0 → (PythagoreanTriple (k * x) (k * y) (k * z) ↔ PythagoreanTriple x y z)\"},\n {\"role\": \"user\",\n  \"content\": \"Pythagorean theorem, if-and-only-if vector inner product form. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {F : Type u_3} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] (x y : F),\\n  ‖x + y‖ * ‖x + y‖ = ‖x‖ * ‖x‖ + ‖y‖ * ‖y‖ ↔ inner x y = 0\"},\n {\"role\": \"user\",\n  \"content\": \"Pythagorean theorem, subtracting vectors, vector angle form. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] (x y : V),\\n  InnerProductGeometry.angle x y = Real.pi / 2 → ‖x - y‖ * ‖x - y‖ = ‖x‖ * ‖x‖ + ‖y‖ * ‖y‖\"},\n {\"role\": \"user\",\n  \"content\": \"Pythagorean theorem, if-and-only-if vector angle form. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] (x y : V),\\n  ‖x + y‖ * ‖x + y‖ = ‖x‖ * ‖x‖ + ‖y‖ * ‖y‖ ↔ InnerProductGeometry.angle x y = Real.pi / 2\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Pythagorean theorem, if-and-if vector inner product form using square roots. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {F : Type u_3} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] {x y : F},\\n  ‖x + y‖ = Real.sqrt (‖x‖ * ‖x‖ + ‖y‖ * ‖y‖) ↔ inner x y = 0\"},\n {\"role\": \"user\",\n  \"content\": \"Pythagorean theorem, vector inner product form. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  (x y : E), inner x y = 0 → ‖x + y‖ * ‖x + y‖ = ‖x‖ * ‖x‖ + ‖y‖ * ‖y‖\"},\n {\"role\": \"user\", \"content\": \"Pythagorean theorem, vector angle form. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] (x y : V),\\n  InnerProductGeometry.angle x y = Real.pi / 2 → ‖x + y‖ * ‖x + y‖ = ‖x‖ * ‖x‖ + ‖y‖ * ‖y‖\"},\n {\"role\": \"user\", \"content\": \"The zeroth Pythagorean triple is all zeros. \"},\n {\"role\": \"assistant\", \"content\": \"PythagoreanTriple 0 0 0\"},\n {\"role\": \"user\", \"content\": \"**Formula for Pythagorean Triples** \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {x y z : ℤ},\\n  PythagoreanTriple x y z ↔\\n    ∃ k m n,\\n      (x = k * (m ^ 2 - n ^ 2) ∧ y = k * (2 * m * n) ∨ x = k * (2 * m * n) ∧ y = k * (m ^ 2 - n ^ 2)) ∧\\n        (z = k * (m ^ 2 + n ^ 2) ∨ z = -k * (m ^ 2 + n ^ 2))\"},\n {\"role\": \"user\",\n  \"content\": \"The numbers `3`, `4` and `5` form a Pythagorean triple.\"}]"}
{"text":"A vector space with the empty set as basis is trivial.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a vector space has a finite dimension, the index set of `Basis.ofVectorSpace` is finite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\\n  Module.rank K V < Cardinal.aleph0 → Set.Finite (Basis.ofVectorSpaceIndex K V)\"},\n {\"role\": \"user\",\n  \"content\": \"Two linearly equivalent vector spaces have the same dimension. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : Ring R] {M : Type v} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {M₁ : Type v}\\n  [inst_3 : AddCommGroup M₁] [inst_4 : Module R M₁], (M ≃ₗ[R] M₁) → Module.rank R M = Module.rank R M₁\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a one-dimensional space, any vector is a multiple of any nonzero vector \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\\n  FiniteDimensional.finrank K V = 1 → ∀ {x : V}, x ≠ 0 → ∀ (y : V), ∃ c, c • x = y\"},\n {\"role\": \"user\", \"content\": \"The empty set is collinear. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (k : Type u_1) {V : Type u_2} (P : Type u_3) [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P], Collinear k ∅\"},\n {\"role\": \"user\", \"content\": \"A strict vector subspace has measure zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ℝ E] (μ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] (s : Submodule ℝ E), s ≠ ⊤ → ↑↑μ ↑s = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a vector space has a basis indexed by elements of a finite set, then it is\\nfinite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\\n  {s : Set ι}, Basis (↑s) K V → Set.Finite s → FiniteDimensional K V\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a vector space has a finite basis, then it is finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\\n  [inst_3 : Finite ι], Basis ι K V → FiniteDimensional K V\"},\n {\"role\": \"user\",\n  \"content\": \"A vector space with the empty set as basis is trivial.\"}]"}
{"text":"Every prime number is `2` or odd.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a finite field of characteristic `2`, all elements are squares. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {F : Type u_3} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 → ∀ (a : F), IsSquare a\"},\n {\"role\": \"user\",\n  \"content\": \"The only prime factor of prime `p` is `p` itself. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {p q : ℕ}, Nat.Prime p → (Nat.factorization p) q ≠ 0 → p = q\"},\n {\"role\": \"user\",\n  \"content\":\n  \"`-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare (-2) ↔ p % 8 = 1 ∨ p % 8 = 3)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A prime natural number is prime in `ℤ[i]` if and only if it is `3` mod `4` \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)], Prime ↑p ↔ p % 4 = 3\"},\n {\"role\": \"user\",\n  \"content\": \"The only divisors of prime powers are prime powers. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [dec_irr : (p : Associates α) → Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid α] [dec : DecidableEq α] [dec' : DecidableEq (Associates α)] {a p : Associates α},\\n  Irreducible p →\\n    ∀ [inst_2 : (n : ℕ) → Decidable (a ∣ p ^ n)] {n : ℕ} (h : a ∣ p ^ n),\\n      a = p ^ Nat.find (_ : ∃ n, (fun n => a ∣ p ^ n) n)\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\", \"content\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (n : ℕ), Nat.factorization n = 0 ↔ n = 0 ∨ n = 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"`2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare 2 ↔ p % 8 = 1 ∨ p % 8 = 7)\"},\n {\"role\": \"user\",\n  \"content\": \"A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 2 = 1 ↔ p ≠ 2\"},\n {\"role\": \"user\", \"content\": \"`2` is not a factor of an odd natural number. \"},\n {\"role\": \"assistant\", \"content\": \"∀ {m n : ℕ}, Odd n → m ∣ n → m ≠ 2\"},\n {\"role\": \"user\", \"content\": \"Every prime number is `2` or odd.\"}]"}
{"text":"There are infinitely many odd natural numbers.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"A transcendental real number is irrational. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {r : ℝ}, Transcendental ℚ r → Irrational r\"},\n {\"role\": \"user\",\n  \"content\": \"Every finite convergent corresponds to a rational number. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K) (n : ℕ),\\n  ∃ q, GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n = ↑q\"},\n {\"role\": \"user\",\n  \"content\": \"Infinite ordinals that are cardinals are unbounded. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"Set.Unbounded (fun x x_1 => x < x_1) {b | Cardinal.ord (Ordinal.card b) = b ∧ Ordinal.omega ≤ b}\"},\n {\"role\": \"user\", \"content\": \"A product of finite numbers is still finite \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_1} {R : Type u_8} [inst : CommMonoidWithZero R] [inst_1 : NoZeroDivisors R] [inst_2 : Nontrivial R]\\n  [inst_3 : DecidableEq R] [inst_4 : LT R] {s : Finset ι} {f : ι → WithTop R},\\n  (∀ i ∈ s, f i ≠ ⊤) → (Finset.prod s fun i => f i) < ⊤\"},\n {\"role\": \"user\", \"content\": \"A sum of finite numbers is still finite \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {s : Finset α} {f : α → ENNReal}, (∀ a ∈ s, f a ≠ ⊤) → (Finset.sum s fun a => f a) < ⊤\"},\n {\"role\": \"user\",\n  \"content\": \"A natural number is odd iff it has residue `1` or `3` mod `4`\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n : ℕ}, n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3\"},\n {\"role\": \"user\", \"content\": \"There is an infinite base \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {M : Matroid α} [self : Matroid.InfiniteRk M], ∃ B, M.Base B ∧ Set.Infinite B\"},\n {\"role\": \"user\",\n  \"content\": \"Infinitely many natural numbers are equal to `d` mod `n`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {n : ℕ}, n ≠ 0 → ∀ (d : ℕ), ∃ᶠ (m : ℕ) in Filter.atTop, m ≡ d [MOD n]\"},\n {\"role\": \"user\",\n  \"content\": \"A sum of numbers is infinite iff one of them is infinite \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_1} {M : Type u_4} [inst : AddCommMonoid M] {s : Finset ι} {f : ι → WithTop M},\\n  (Finset.sum s fun i => f i) = ⊤ ↔ ∃ i ∈ s, f i = ⊤\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\", \"content\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\"},\n {\"role\": \"user\", \"content\": \"There are infinitely many odd natural numbers.\"}]"}
{"text":"The smallest odd prime is `3`.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"The only prime factor of prime `p` is `p` itself. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {p q : ℕ}, Nat.Prime p → (Nat.factorization p) q ≠ 0 → p = q\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The square of the smallest prime factor of a composite number `n` is at most `n`.\\n\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n : ℕ}, 0 < n → ¬Nat.Prime n → Nat.minFac n ^ 2 ≤ n\"},\n {\"role\": \"user\", \"content\": \"A minimal polynomial is prime. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\\n  IsIntegral A x → Prime (minpoly A x)\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\", \"content\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"`2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare 2 ↔ p % 8 = 1 ∨ p % 8 = 7)\"},\n {\"role\": \"user\",\n  \"content\": \"A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 2 = 1 ↔ p ≠ 2\"},\n {\"role\": \"user\",\n  \"content\":\n  \"`-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare (-2) ↔ p % 8 = 1 ∨ p % 8 = 3)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (n : ℕ), Nat.factorization n = 0 ↔ n = 0 ∨ n = 1\"},\n {\"role\": \"user\",\n  \"content\": \"A natural number is odd iff it has residue `1` or `3` mod `4`\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n : ℕ}, n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A prime natural number is prime in `ℤ[i]` if and only if it is `3` mod `4` \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)], Prime ↑p ↔ p % 4 = 3\"},\n {\"role\": \"user\", \"content\": \"The smallest odd prime is `3`.\"}]"}
{"text":"There are infinitely many odd prime numbers.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"To prove Fermat's Last Theorem, it suffices to prove it for odd prime exponents.\\n\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"(∀ (p : ℕ), Nat.Prime p → Odd p → FermatLastTheoremFor p) → FermatLastTheorem\"},\n {\"role\": \"user\", \"content\": \"A finite field has prime power cardinality. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : Fintype α] [inst_1 : Field α], IsPrimePow (Fintype.card α)\"},\n {\"role\": \"user\",\n  \"content\": \"A sum of numbers is infinite iff one of them is infinite \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_1} {M : Type u_4} [inst : AddCommMonoid M] {s : Finset ι} {f : ι → WithTop M},\\n  (Finset.sum s fun i => f i) = ⊤ ↔ ∃ i ∈ s, f i = ⊤\"},\n {\"role\": \"user\",\n  \"content\": \"The exponential characteristic is a prime number or one. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (R : Type u) [inst : Semiring R] (q : ℕ) [hq : ExpChar R q], Nat.Prime q ∨ q = 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (n : ℕ), Nat.factorization n = 0 ↔ n = 0 ∨ n = 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For any positive `k : ℕ` there are infinitely many primes `p` such that `p ≡ 1 [MOD k]`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {k : ℕ}, k ≠ 0 → Set.Infinite {p | Nat.Prime p ∧ p ≡ 1 [MOD k]}\"},\n {\"role\": \"user\",\n  \"content\": \"The only divisors of prime powers are prime powers. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [dec_irr : (p : Associates α) → Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid α] [dec : DecidableEq α] [dec' : DecidableEq (Associates α)] {a p : Associates α},\\n  Irreducible p →\\n    ∀ [inst_2 : (n : ℕ) → Decidable (a ∣ p ^ n)] {n : ℕ} (h : a ∣ p ^ n),\\n      a = p ^ Nat.find (_ : ∃ n, (fun n => a ∣ p ^ n) n)\"},\n {\"role\": \"user\", \"content\": \"There is an infinite base \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {M : Matroid α} [self : Matroid.InfiniteRk M], ∃ B, M.Base B ∧ Set.Infinite B\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\", \"content\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\"},\n {\"role\": \"user\", \"content\": \"There are infinitely many odd prime numbers.\"}]"}
{"text":"If a vector space has dimension `2` then it is finite dimensional.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"A finite-dimensional subspace is complete. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : NontriviallyNormedField 𝕜] [inst_1 : CompleteSpace 𝕜] [inst_2 : AddCommGroup E]\\n  [inst_3 : UniformSpace E] [inst_4 : T2Space E] [inst_5 : UniformAddGroup E] [inst_6 : Module 𝕜 E]\\n  [inst_7 : ContinuousSMul 𝕜 E] (s : Submodule 𝕜 E) [inst_8 : FiniteDimensional 𝕜 ↥s], IsComplete ↑s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A subspace of a finite-dimensional space is also finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K ↥S\"},\n {\"role\": \"user\",\n  \"content\": \"The `vectorSpan` of a finite set is finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (k : Type u_1) {V : Type u_2} {P : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] {s : Set P}, Set.Finite s → FiniteDimensional k ↥(vectorSpan k s)\"},\n {\"role\": \"user\", \"content\": \"A finite-dimensional subspace is closed. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : NontriviallyNormedField 𝕜] [inst_1 : CompleteSpace 𝕜] [inst_2 : AddCommGroup E]\\n  [inst_3 : TopologicalSpace E] [inst_4 : T2Space E] [inst_5 : TopologicalAddGroup E] [inst_6 : Module 𝕜 E]\\n  [inst_7 : ContinuousSMul 𝕜 E] (s : Submodule 𝕜 E) [inst_8 : FiniteDimensional 𝕜 ↥s], IsClosed ↑s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a vector space has a finite dimension, the index set of `Basis.ofVectorSpace` is finite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\\n  Module.rank K V < Cardinal.aleph0 → Set.Finite (Basis.ofVectorSpaceIndex K V)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a vector space has a basis indexed by elements of a finite set, then it is\\nfinite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\\n  {s : Set ι}, Basis (↑s) K V → Set.Finite s → FiniteDimensional K V\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a vector space has a finite basis, then it is finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\\n  [inst_3 : Finite ι], Basis ι K V → FiniteDimensional K V\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a vector space has dimension `2` then it is finite dimensional.\"}]"}
{"text":"Every field is a division ring.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"A subfield is closed under division. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} [inst : Field K] (s : Subfield K) {x y : K}, x ∈ s → y ∈ s → x / y ∈ s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For a semiring to be a field, it must have two distinct elements. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {R : Type u} [inst : Semiring R], IsField R → ∃ x y, x ≠ y\"},\n {\"role\": \"user\",\n  \"content\": \"All ideals in a division (semi)ring are trivial. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} [inst : DivisionSemiring K] (I : Ideal K), I = ⊥ ∨ I = ⊤\"},\n {\"role\": \"user\",\n  \"content\": \"A normed division ring is a topological division ring. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : NormedDivisionRing α], TopologicalDivisionRing α\"},\n {\"role\": \"user\",\n  \"content\": \"Natural division is the floor of field division. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_2} [inst : LinearOrderedSemifield α] [inst_1 : FloorSemiring α] (m n : ℕ), ⌊↑m / ↑n⌋₊ = m / n\"},\n {\"role\": \"user\",\n  \"content\": \"An intermediate field is closed under division. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u_1} {L : Type u_2} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\\n  {x y : L}, x ∈ S → y ∈ S → x / y ∈ S\"},\n {\"role\": \"user\", \"content\": \"An intermediate field contains the ring's 0. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u_1} {L : Type u_2} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\\n  0 ∈ S\"},\n {\"role\": \"user\", \"content\": \"An intermediate field contains the ring's 1. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u_1} {L : Type u_2} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\\n  1 ∈ S\"},\n {\"role\": \"user\", \"content\": \"A field is a valuation ring. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (K : Type u) [inst : Field K], ValuationRing K\"},\n {\"role\": \"user\", \"content\": \"A valued division ring is separated. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u_1} [inst : DivisionRing K] {Γ₀ : Type u_2} [inst_1 : LinearOrderedCommGroupWithZero Γ₀]\\n  [inst_2 : Valued K Γ₀], SeparatedSpace K\"},\n {\"role\": \"user\", \"content\": \"Every field is a division ring.\"}]"}
{"text":"If a space has dimension `2` then it is finite dimensional.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The space of continuous linear maps between finite-dimensional spaces is finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [inst : Field 𝕜] [inst_1 : TopologicalSpace 𝕜] [inst_2 : AddCommGroup E]\\n  [inst_3 : Module 𝕜 E] [inst_4 : TopologicalSpace E] [inst_5 : AddCommGroup F] [inst_6 : Module 𝕜 F]\\n  [inst_7 : TopologicalSpace F] [inst_8 : TopologicalAddGroup F] [inst_9 : ContinuousSMul 𝕜 F]\\n  [inst_10 : FiniteDimensional 𝕜 E] [inst_11 : FiniteDimensional 𝕜 F], FiniteDimensional 𝕜 (E →L[𝕜] F)\"},\n {\"role\": \"user\", \"content\": \"A finite-dimensional subspace is complete. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : NontriviallyNormedField 𝕜] [inst_1 : CompleteSpace 𝕜] [inst_2 : AddCommGroup E]\\n  [inst_3 : UniformSpace E] [inst_4 : T2Space E] [inst_5 : UniformAddGroup E] [inst_6 : Module 𝕜 E]\\n  [inst_7 : ContinuousSMul 𝕜 E] (s : Submodule 𝕜 E) [inst_8 : FiniteDimensional 𝕜 ↥s], IsComplete ↑s\"},\n {\"role\": \"user\", \"content\": \"A compact discrete space is finite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X] [inst : DiscreteTopology X], Finite X\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a linear map has determinant different from `1`, then the space is finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {M : Type u_2} [inst : AddCommGroup M] {𝕜 : Type u_7} [inst_1 : Field 𝕜] [inst_2 : Module 𝕜 M] (f : M →ₗ[𝕜] M),\\n  LinearMap.det f ≠ 1 → FiniteDimensional 𝕜 M\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A quotient of a finite-dimensional space is also finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K (V ⧸ S)\"},\n {\"role\": \"user\", \"content\": \"A finite space is bounded. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_4} [inst : Bornology α] [inst_1 : Finite α], BoundedSpace α\"},\n {\"role\": \"user\", \"content\": \"A finite-dimensional subspace is closed. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : NontriviallyNormedField 𝕜] [inst_1 : CompleteSpace 𝕜] [inst_2 : AddCommGroup E]\\n  [inst_3 : TopologicalSpace E] [inst_4 : T2Space E] [inst_5 : TopologicalAddGroup E] [inst_6 : Module 𝕜 E]\\n  [inst_7 : ContinuousSMul 𝕜 E] (s : Submodule 𝕜 E) [inst_8 : FiniteDimensional 𝕜 ↥s], IsClosed ↑s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A subspace of a finite-dimensional space is also finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K ↥S\"},\n {\"role\": \"user\", \"content\": \"All hom spaces are finite dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {k G : Type u} [inst : Field k] [inst_1 : Monoid G] (V W : FdRep k G), FiniteDimensional k (V ⟶ W)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a vector space has a finite basis, then it is finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\\n  [inst_3 : Finite ι], Basis ι K V → FiniteDimensional K V\"},\n {\"role\": \"user\",\n  \"content\": \"If a space has dimension `2` then it is finite dimensional.\"}]"}
{"text":"Every natural number has a successor.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `n : ℕ+` is different from `1`, then it is the successor of some `k : ℕ+`. \"},\n {\"role\": \"assistant\", \"content\": \"∀ {n : ℕ+}, n ≠ 1 → ∃ k, n = k + 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The canonical map from ℕ to a graded semiring respects successors.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_1} {A : ι → Type u_2} [inst : AddMonoid ι] [inst_1 : (i : ι) → AddCommMonoid (A i)]\\n  [self : DirectSum.GSemiring A] (n : ℕ),\\n  DirectSum.GSemiring.natCast (n + 1) = DirectSum.GSemiring.natCast n + GradedMonoid.GOne.one\"},\n {\"role\": \"user\",\n  \"content\": \"A Cauchy sequence on the natural numbers is bounded. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {u : ℕ → α}, CauchySeq u → ∃ R > 0, ∀ (m n : ℕ), dist (u m) (u n) < R\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {m n : ℕ}, (∀ (a : ℕ), a ∣ m ↔ a ∣ n) ↔ m = n\"},\n {\"role\": \"user\", \"content\": \"Every ordinal has a fundamental sequence. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (a : Ordinal.{u}), ∃ f, Ordinal.IsFundamentalSequence a (Cardinal.ord (Ordinal.cof a)) f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {m n : ℕ}, (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n\"},\n {\"role\": \"user\",\n  \"content\": \"Every finite convergent corresponds to a rational number. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K) (n : ℕ),\\n  ∃ q, GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n = ↑q\"},\n {\"role\": \"user\",\n  \"content\":\n  \"This result shows that there always exists a next term in the sequence. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (K : Type u_1) [inst : Field K] [inst_1 : NumberField K] (w₁ : NumberField.InfinitePlace K) {B : ℕ},\\n  NumberField.mixedEmbedding.minkowskiBound K < NumberField.mixedEmbedding.convexBodyLTFactor K * ↑B →\\n    ∀ {x : ↥(NumberField.ringOfIntegers K)},\\n      x ≠ 0 → ∃ y, y ≠ 0 ∧ (∀ (w : NumberField.InfinitePlace K), w ≠ w₁ → w ↑y < w ↑x) ∧ |(Algebra.norm ℚ) ↑y| ≤ ↑B\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\", \"content\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\"},\n {\"role\": \"user\", \"content\": \"Every natural number has a successor.\"}]"}
{"text":"Every natural number is less than its successor.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"A Cauchy sequence on the natural numbers is bounded. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {u : ℕ → α}, CauchySeq u → ∃ R > 0, ∀ (m n : ℕ), dist (u m) (u n) < R\"},\n {\"role\": \"user\", \"content\": \"A finite set is bounded below.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : Preorder α] [inst_1 : IsDirected α fun x x_1 => x ≥ x_1] [inst_2 : Nonempty α] {s : Set α},\\n  Set.Finite s → BddBelow s\"},\n {\"role\": \"user\", \"content\": \"Zero is less than or equal to one. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_2} [inst : Zero α] [inst_1 : One α] [inst_2 : LE α] [self : ZeroLEOneClass α], 0 ≤ 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a small natural number is divisible by a larger natural number,\\nthe small number is zero. \"},\n {\"role\": \"assistant\", \"content\": \"∀ {a b : ℕ}, a ∣ b → b < a → b = 0\"},\n {\"role\": \"user\",\n  \"content\": \"Natural division is always less than division in the field. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : LinearOrderedSemifield α] {m n : ℕ}, ↑(m / n) ≤ ↑m / ↑n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The digits in the base b+2 expansion of n are all less than b+2 \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {b m d : ℕ}, d ∈ Nat.digits (b + 2) m → d < b + 2\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The digits in the base b expansion of n are all less than b, if b ≥ 2 \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {b m d : ℕ}, 1 < b → d ∈ Nat.digits b m → d < b\"},\n {\"role\": \"user\", \"content\": \"Any element is less than the top one. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u_9} [self : CompleteLattice α] (x : α), x ≤ ⊤\"},\n {\"role\": \"user\", \"content\": \"Any lower bound is less than the set infimum. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_9} [self : CompleteSemilatticeInf α] (s : Set α) (a : α), (∀ b ∈ s, a ≤ b) → a ≤ sInf s\"},\n {\"role\": \"user\",\n  \"content\": \"Any element of a set is less than the set supremum. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_9} [self : CompleteSemilatticeSup α] (s : Set α), ∀ a ∈ s, a ≤ sSup s\"},\n {\"role\": \"user\",\n  \"content\": \"Every natural number is less than its successor.\"}]"}
{"text":"Every set is Lebesgue measurable.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The set of points for which a measurable sequence of functions converges is measurable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_2} {γ : Type u_3} {β : Type u_4} [inst : MeasurableSpace β] [inst_1 : TopologicalSpace γ]\\n  [inst_2 : PolishSpace γ] [inst_3 : MeasurableSpace γ] [hγ : OpensMeasurableSpace γ] [inst_4 : Countable ι]\\n  {l : Filter ι} [inst_5 : Filter.IsCountablyGenerated l] {f : ι → β → γ},\\n  (∀ (i : ι), Measurable (f i)) → MeasurableSet {x | ∃ c, Filter.Tendsto (fun n => f n x) l (nhds c)}\"},\n {\"role\": \"user\",\n  \"content\": \"The graph of a measurable function is a measurable set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : MeasurableSpace α] {f : α → ℝ}, Measurable f → MeasurableSet {p | p.2 = f p.1}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a set is a right-neighborhood of all of its points, then it is measurable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α]\\n  [inst_3 : LinearOrder α] [inst_4 : OrderTopology α] [inst_5 : SecondCountableTopology α] {s : Set α},\\n  (∀ x ∈ s, s ∈ nhdsWithin x (Set.Ioi x)) → MeasurableSet s\"},\n {\"role\": \"user\",\n  \"content\": \"In a `BorelSpace` all open sets are measurable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_6} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α],\\n  OpensMeasurableSpace α\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For every set there exists a measurable superset of the same measure. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : MeasurableSpace α] (μ : MeasureTheory.Measure α) (s : Set α),\\n  ∃ t, s ⊆ t ∧ MeasurableSet t ∧ ↑↑μ t = ↑↑μ s\"},\n {\"role\": \"user\",\n  \"content\": \"The set of Liouville numbers has Lebesgue measure zero. \"},\n {\"role\": \"assistant\",\n  \"content\": \"↑↑MeasureTheory.volume {x | Liouville x} = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For the outer measure coming from a content, all Borel sets are measurable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type w} [inst : TopologicalSpace G] (μ : MeasureTheory.Content G) [inst_1 : T2Space G] [S : MeasurableSpace G]\\n  [inst_2 : BorelSpace G], S ≤ MeasureTheory.OuterMeasure.caratheodory (MeasureTheory.Content.outerMeasure μ)\"},\n {\"role\": \"user\", \"content\": \"Borel-measurable sets are measurable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_6} [inst : TopologicalSpace α] [h : MeasurableSpace α] [self : OpensMeasurableSpace α], borel α ≤ h\"},\n {\"role\": \"user\",\n  \"content\": \"The measurable sets are exactly the Borel-measurable sets. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_6} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [self : BorelSpace α], inst_1 = borel α\"},\n {\"role\": \"user\", \"content\": \"Every set is Lebesgue measurable.\"}]"}
{"text":"Every set of Borel measure zero is Lebesgue measurable.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Left invariant Borel measures on an additive measurable group are unique (up to a scalar). \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : AddGroup G] [inst_2 : MeasurableAdd₂ G]\\n  (μ ν : MeasureTheory.Measure G) [inst_3 : MeasureTheory.SigmaFinite ν] [inst_4 : MeasureTheory.SigmaFinite μ]\\n  {s : Set G} [inst_5 : MeasurableNeg G] [inst_6 : MeasureTheory.Measure.IsAddLeftInvariant μ]\\n  [inst_7 : MeasureTheory.Measure.IsAddLeftInvariant ν],\\n  MeasurableSet s → ↑↑ν s ≠ 0 → ↑↑ν s ≠ ⊤ → μ = (↑↑μ s / ↑↑ν s) • ν\"},\n {\"role\": \"user\",\n  \"content\": \"In a `BorelSpace` all open sets are measurable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_6} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α],\\n  OpensMeasurableSpace α\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Left invariant Borel measures on a measurable group are unique (up to a scalar). \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Group G] [inst_2 : MeasurableMul₂ G]\\n  (μ ν : MeasureTheory.Measure G) [inst_3 : MeasureTheory.SigmaFinite ν] [inst_4 : MeasureTheory.SigmaFinite μ]\\n  {s : Set G} [inst_5 : MeasurableInv G] [inst_6 : MeasureTheory.Measure.IsMulLeftInvariant μ]\\n  [inst_7 : MeasureTheory.Measure.IsMulLeftInvariant ν],\\n  MeasurableSet s → ↑↑ν s ≠ 0 → ↑↑ν s ≠ ⊤ → μ = (↑↑μ s / ↑↑ν s) • ν\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For the outer measure coming from a content, all Borel sets are measurable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type w} [inst : TopologicalSpace G] (μ : MeasureTheory.Content G) [inst_1 : T2Space G] [S : MeasurableSpace G]\\n  [inst_2 : BorelSpace G], S ≤ MeasureTheory.OuterMeasure.caratheodory (MeasureTheory.Content.outerMeasure μ)\"},\n {\"role\": \"user\", \"content\": \"Borel-measurable sets are measurable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_6} [inst : TopologicalSpace α] [h : MeasurableSpace α] [self : OpensMeasurableSpace α], borel α ≤ h\"},\n {\"role\": \"user\",\n  \"content\": \"The measurable sets are exactly the Borel-measurable sets. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_6} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [self : BorelSpace α], inst_1 = borel α\"},\n {\"role\": \"user\",\n  \"content\": \"The set of Liouville numbers has Lebesgue measure zero. \"},\n {\"role\": \"assistant\",\n  \"content\": \"↑↑MeasureTheory.volume {x | Liouville x} = 0\"},\n {\"role\": \"user\",\n  \"content\": \"Every set of Borel measure zero is Lebesgue measurable.\"}]"}
{"text":"No prime number is a perfect square.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The square of the smallest prime factor of a composite number `n` is at most `n`.\\n\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n : ℕ}, 0 < n → ¬Nat.Prime n → Nat.minFac n ^ 2 ≤ n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The real square root is at most the natural square root plus one \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {a : ℕ}, Real.sqrt ↑a ≤ ↑(Nat.sqrt a) + 1\"},\n {\"role\": \"user\",\n  \"content\": \"The only divisors of prime powers are prime powers. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [dec_irr : (p : Associates α) → Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid α] [dec : DecidableEq α] [dec' : DecidableEq (Associates α)] {a p : Associates α},\\n  Irreducible p →\\n    ∀ [inst_2 : (n : ℕ) → Decidable (a ∣ p ^ n)] {n : ℕ} (h : a ∣ p ^ n),\\n      a = p ^ Nat.find (_ : ∃ n, (fun n => a ∣ p ^ n) n)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 ≠ 3`. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {p n : ℕ}, Nat.Prime p → p ∣ n → IsSquare (-1) → p % 4 ≠ 3\"},\n {\"role\": \"user\", \"content\": \"No zero divisors. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_2} [self : CanonicallyOrderedCommSemiring α] {a b : α}, a * b = 0 → a = 0 ∨ b = 0\"},\n {\"role\": \"user\", \"content\": \"The prime ideal is not the entire ring. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : Semiring α] {I : Ideal α} [self : Ideal.IsPrime I], I ≠ ⊤\"},\n {\"role\": \"user\", \"content\": \"`2` is not a factor of an odd natural number. \"},\n {\"role\": \"assistant\", \"content\": \"∀ {m n : ℕ}, Odd n → m ∣ n → m ≠ 2\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\", \"content\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a finite field of odd characteristic, not every element is a square. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {F : Type u_3} [inst : Field F] [inst_1 : Finite F], ringChar F ≠ 2 → ∃ a, ¬IsSquare a\"},\n {\"role\": \"user\",\n  \"content\": \"There are no perfect squares strictly between m² and (m+1)² \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {n m : ℕ}, m * m < n → n < (m + 1) * (m + 1) → ¬∃ t, t * t = n\"},\n {\"role\": \"user\", \"content\": \"No prime number is a perfect square.\"}]"}
{"text":"Every odd prime number is greater than `2`.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A prime natural number is prime in `ℤ[i]` if and only if it is `3` mod `4` \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)], Prime ↑p ↔ p % 4 = 3\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `1 < p`, then `q p`, the smallest prime factor of `mersenne p`, is more than 2. \"},\n {\"role\": \"assistant\", \"content\": \"∀ (p' : ℕ), 2 < LucasLehmer.q (p' + 2)\"},\n {\"role\": \"user\",\n  \"content\": \"A natural number is odd iff it has residue `1` or `3` mod `4`\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n : ℕ}, n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3\"},\n {\"role\": \"user\",\n  \"content\": \"The only divisors of prime powers are prime powers. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [dec_irr : (p : Associates α) → Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid α] [dec : DecidableEq α] [dec' : DecidableEq (Associates α)] {a p : Associates α},\\n  Irreducible p →\\n    ∀ [inst_2 : (n : ℕ) → Decidable (a ∣ p ^ n)] {n : ℕ} (h : a ∣ p ^ n),\\n      a = p ^ Nat.find (_ : ∃ n, (fun n => a ∣ p ^ n) n)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (n : ℕ), Nat.factorization n = 0 ↔ n = 0 ∨ n = 1\"},\n {\"role\": \"user\",\n  \"content\": \"A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 2 = 1 ↔ p ≠ 2\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\", \"content\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\"},\n {\"role\": \"user\", \"content\": \"`2` is not a factor of an odd natural number. \"},\n {\"role\": \"assistant\", \"content\": \"∀ {m n : ℕ}, Odd n → m ∣ n → m ≠ 2\"},\n {\"role\": \"user\", \"content\": \"Every odd prime number is greater than `2`.\"}]"}
{"text":"The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Pythagorean theorem, if-and-if vector inner product form using square roots. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {F : Type u_3} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] {x y : F},\\n  ‖x + y‖ = Real.sqrt (‖x‖ * ‖x‖ + ‖y‖ * ‖y‖) ↔ inner x y = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {m n : ℕ}, (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n\"},\n {\"role\": \"user\",\n  \"content\": \"Expressing the product of two polynomials as a double sum. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : Semiring R] {p q : Polynomial R},\\n  p * q =\\n    Finset.sum (Polynomial.support p) fun i =>\\n      Polynomial.sum q fun j a => (Polynomial.monomial (i + j)) (Polynomial.coeff p i * a)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The product of two Chebyshev polynomials is the sum of two other Chebyshev polynomials. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (R : Type u_1) [inst : CommRing R] (m k : ℕ),\\n  2 * Polynomial.Chebyshev.T R m * Polynomial.Chebyshev.T R (m + k) =\\n    Polynomial.Chebyshev.T R (2 * m + k) + Polynomial.Chebyshev.T R k\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n : ℕ}, IsSquare (-1) → ∃ x y, n = x ^ 2 + y ^ 2\"},\n {\"role\": \"user\", \"content\": \"**Four squares theorem** \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (n : ℕ), ∃ a b c d, a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n\"},\n {\"role\": \"user\", \"content\": \"**Euler's four-square identity**. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : CommRing R] (a b c d x y z w : R),\\n  (a * x - b * y - c * z - d * w) ^ 2 + (a * y + b * x + c * w - d * z) ^ 2 + (a * z - b * w + c * x + d * y) ^ 2 +\\n      (a * w + b * z - c * y + d * x) ^ 2 =\\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"**Euler's four-square identity**, a version for natural numbers. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (a b c d x y z w : ℕ),\\n  Int.natAbs (↑a * ↑x - ↑b * ↑y - ↑c * ↑z - ↑d * ↑w) ^ 2 + Int.natAbs (↑a * ↑y + ↑b * ↑x + ↑c * ↑w - ↑d * ↑z) ^ 2 +\\n        Int.natAbs (↑a * ↑z - ↑b * ↑w + ↑c * ↑x + ↑d * ↑y) ^ 2 +\\n      Int.natAbs (↑a * ↑w + ↑b * ↑z - ↑c * ↑y + ↑d * ↑x) ^ 2 =\\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2)\"},\n {\"role\": \"user\",\n  \"content\": \"The sum of two squares is zero iff both elements are zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : LinearOrderedRing α] {x y : α}, x * x + y * y = 0 ↔ x = 0 ∧ y = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares.\"}]"}
{"text":"Every compact topological space is locally compact.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A topological group which is weakly locally compact is automatically locally compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type w} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G]\\n  [inst_3 : WeaklyLocallyCompactSpace G], LocallyCompactSpace G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a point in a topological group has a compact neighborhood, then the group is\\nlocally compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type w} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] {K : Set G},\\n  IsCompact K → ∀ {x : G}, K ∈ nhds x → LocallyCompactSpace G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every point of a weakly locally compact space admits a compact neighborhood. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u_4} [inst : TopologicalSpace X] [self : WeaklyLocallyCompactSpace X] (x : X), ∃ s, IsCompact s ∧ s ∈ nhds x\"},\n {\"role\": \"user\",\n  \"content\": \"A weakly locally compact Hausdorff space is locally compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : WeaklyLocallyCompactSpace X] [inst_2 : T2Space X],\\n  LocallyCompactSpace X\"},\n {\"role\": \"user\", \"content\": \"The underlying topological space is compact.\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (self : CompHaus), CompactSpace ↑self.toTop\"},\n {\"role\": \"user\", \"content\": \"Finite topological spaces are compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : Finite X], CompactSpace X\"},\n {\"role\": \"user\",\n  \"content\": \"Every compact topological space is locally compact.\"}]"}
{"text":"Every continuous function is uniformly continuous.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"A Lipschitz function is uniformly continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : PseudoEMetricSpace α] [inst_1 : PseudoEMetricSpace β] {K : NNReal} {f : α → β},\\n  LipschitzWith K f → UniformContinuous f\"},\n {\"role\": \"user\",\n  \"content\": \"Each function of an equicontinuous family is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_1} {X : Type u_3} {α : Type u_6} [inst : TopologicalSpace X] [inst_1 : UniformSpace α] {F : ι → X → α},\\n  Equicontinuous F → ∀ (i : ι), Continuous (F i)\"},\n {\"role\": \"user\", \"content\": \"Uniform continuity of the function \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_4} {β : Type u_5} [inst : UniformSpace α] [inst_1 : UniformSpace β] (self : α ≃ᵤ β),\\n  UniformContinuous self.toFun\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A constant sequence of functions is uniformly integrable in the probability sense. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {β : Type u_2} {ι : Type u_3} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α}\\n  [inst : NormedAddCommGroup β] {p : ENNReal} {g : α → β},\\n  1 ≤ p → p ≠ ⊤ → MeasureTheory.Memℒp g p → MeasureTheory.UniformIntegrable (fun x => g) p μ\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A function which can be locally uniformly approximated by continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} [inst_1 : TopologicalSpace α],\\n  (∀ (x : α), ∀ u ∈ uniformity β, ∃ t ∈ nhds x, ∃ F, ContinuousAt F x ∧ ∀ y ∈ t, (f y, F y) ∈ u) → Continuous f\"},\n {\"role\": \"user\",\n  \"content\": \"A locally uniform limit of continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\\n  [inst_1 : TopologicalSpace α],\\n  TendstoLocallyUniformly F f p → (∀ᶠ (n : ι) in p, Continuous (F n)) → ∀ [inst_2 : Filter.NeBot p], Continuous f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A function which can be uniformly approximated by continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} [inst_1 : TopologicalSpace α],\\n  (∀ u ∈ uniformity β, ∃ F, Continuous F ∧ ∀ (y : α), (f y, F y) ∈ u) → Continuous f\"},\n {\"role\": \"user\", \"content\": \"A constant function is uniformly integrable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {β : Type u_2} {ι : Type u_3} {m : MeasurableSpace α} (μ : MeasureTheory.Measure α)\\n  [inst : NormedAddCommGroup β] {p : ENNReal} {g : α → β},\\n  1 ≤ p → p ≠ ⊤ → MeasureTheory.Memℒp g p → MeasureTheory.UnifIntegrable (fun x => g) p μ\"},\n {\"role\": \"user\",\n  \"content\": \"A uniform limit of continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\\n  [inst_1 : TopologicalSpace α],\\n  TendstoUniformly F f p → (∀ᶠ (n : ι) in p, Continuous (F n)) → ∀ [inst_2 : Filter.NeBot p], Continuous f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Each function of a uniformly equicontinuous family is uniformly continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_1} {α : Type u_6} {β : Type u_7} [inst : UniformSpace α] [inst_1 : UniformSpace β] {F : ι → β → α},\\n  UniformEquicontinuous F → ∀ (i : ι), UniformContinuous (F i)\"},\n {\"role\": \"user\",\n  \"content\": \"Every continuous function is uniformly continuous.\"}]"}
{"text":"`6` is not the sum of two distinct prime numbers.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"`cyclotomic' n R` is different from `0`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (n : ℕ) (R : Type u_2) [inst : CommRing R] [inst_1 : IsDomain R], Polynomial.cyclotomic' n R ≠ 0\"},\n {\"role\": \"user\",\n  \"content\": \"Harmonic series is not unconditionally summable. \"},\n {\"role\": \"assistant\", \"content\": \"¬Summable fun n => 1 / ↑n\"},\n {\"role\": \"user\", \"content\": \"`cyclotomic n R` is different from `0`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (n : ℕ) (R : Type u_1) [inst : Ring R] [inst_1 : Nontrivial R], Polynomial.cyclotomic n R ≠ 0\"},\n {\"role\": \"user\",\n  \"content\": \"The ring of integers of a number field is not a field. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (K : Type u_1) [inst : Field K] [nf : NumberField K], ¬IsField ↥(NumberField.ringOfIntegers K)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 ≠ 3`. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {p n : ℕ}, Nat.Prime p → p ∣ n → IsSquare (-1) → p % 4 ≠ 3\"},\n {\"role\": \"user\", \"content\": \"A minimal polynomial is not `1`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (A : Type u_1) {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B)\\n  [inst_3 : Nontrivial B], minpoly A x ≠ 1\"},\n {\"role\": \"user\",\n  \"content\": \"The n-th harmonic number is not an integer for n ≥ 2. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n : ℕ}, 2 ≤ n → ¬Rat.isInt (harmonic n) = true\"},\n {\"role\": \"user\",\n  \"content\": \"Adjacent letters are not from the same summand. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_1} {M : ι → Type u_2} [inst : (i : ι) → Monoid (M i)] (self : Monoid.CoprodI.Word M),\\n  List.Chain' (fun l l' => l.fst ≠ l'.fst) self.toList\"},\n {\"role\": \"user\", \"content\": \"`2` is not a factor of an odd natural number. \"},\n {\"role\": \"assistant\", \"content\": \"∀ {m n : ℕ}, Odd n → m ∣ n → m ≠ 2\"},\n {\"role\": \"user\",\n  \"content\": \"`6` is not the sum of two distinct prime numbers.\"}]"}
{"text":"No integer is irrational.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If an integer with larger absolute value divides an integer, it is\\nzero. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {a b : ℤ}, a ∣ b → Int.natAbs b < Int.natAbs a → b = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"There is an irrational number `r` between any two reals `x < r < y`. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {x y : ℝ}, x < y → ∃ r, Irrational r ∧ x < r ∧ r < y\"},\n {\"role\": \"user\", \"content\": \"No zero divisors. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_2} [self : CanonicallyOrderedCommSemiring α] {a b : α}, a * b = 0 → a = 0 ∨ b = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every terminating continued fraction corresponds to a rational number. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] {v : K},\\n  GeneralizedContinuedFraction.Terminates (GeneralizedContinuedFraction.of v) → ∃ q, v = ↑q\"},\n {\"role\": \"user\",\n  \"content\": \"The conjugate of the golden ratio is irrational. \"},\n {\"role\": \"assistant\", \"content\": \"Irrational goldenConj\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A rational number has only finitely many good rational approximations. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (ξ : ℚ), Set.Finite {q | |ξ - q| < 1 / ↑q.den ^ 2}\"},\n {\"role\": \"user\",\n  \"content\": \"Nonzero fractional ideals contain a nonzero integer. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : CommRing R] {K : Type u_3} [inst_1 : Field K] [inst_2 : Algebra R K]\\n  [inst_3 : IsFractionRing R K] {I : FractionalIdeal (nonZeroDivisors R) K} [inst_4 : Nontrivial R],\\n  I ≠ 0 → ∃ x, x ≠ 0 ∧ (algebraMap R K) x ∈ I\"},\n {\"role\": \"user\",\n  \"content\": \"Every finite convergent corresponds to a rational number. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K) (n : ℕ),\\n  ∃ q, GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n = ↑q\"},\n {\"role\": \"user\", \"content\": \"A transcendental real number is irrational. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {r : ℝ}, Transcendental ℚ r → Irrational r\"},\n {\"role\": \"user\",\n  \"content\": \"If a rational is not a p-adic integer, it is not an integer. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (p : ℕ) {a : ℚ} [hp : Fact (Nat.Prime p)], 1 < padicNorm p a → ¬Rat.isInt a = true\"},\n {\"role\": \"user\", \"content\": \"No integer is irrational.\"}]"}
{"text":"The identity element in a ring is a unit.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"The identity is a group homomorphism. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u} [inst : Group α], IsGroupHom id\"},\n {\"role\": \"user\", \"content\": \"A ring isomorphism sends one to one. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_4} {S : Type u_5} [inst : NonAssocSemiring R] [inst_1 : NonAssocSemiring S] (f : R ≃+* S), f 1 = 1\"},\n {\"role\": \"user\",\n  \"content\": \"The characteristic of a finite ring cannot be zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (R : Type u_1) [inst : NonAssocRing R] (p : ℕ) [inst : CharP R p] [inst : Finite R], p ≠ 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"An element of a ring multiplied by the additive inverse of one is the element's additive\\ninverse. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : MulOneClass α] [inst_1 : HasDistribNeg α] (a : α), a * -1 = -a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The composition of the unit and the counit is equal to the identity up to unitors. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {B : Type u} [inst : CategoryTheory.Bicategory B] {a b : B} {f : a ⟶ b} {g : b ⟶ a}\\n  (self : CategoryTheory.Bicategory.Adjunction f g),\\n  CategoryTheory.Bicategory.leftZigzag self.unit self.counit =\\n    CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.leftUnitor f).hom\\n      (CategoryTheory.Bicategory.rightUnitor f).inv\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The group of units of a complete normed ring is an open subset of the ring. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R], IsOpen {x | IsUnit x}\"},\n {\"role\": \"user\", \"content\": \"A subring contains the ring's 1. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {R : Type u} [inst : Ring R] (s : Subring R), 1 ∈ s\"},\n {\"role\": \"user\",\n  \"content\": \"The units of a complete normed ring form a Lie group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] {𝕜 : Type u_2} [inst_2 : NontriviallyNormedField 𝕜]\\n  [inst_3 : NormedAlgebra 𝕜 R], LieGroup (modelWithCornersSelf 𝕜 R) Rˣ\"},\n {\"role\": \"user\", \"content\": \"The identity map is a ring homomorphism. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u} [inst : Ring α], IsRingHom id\"},\n {\"role\": \"user\",\n  \"content\": \"The chosen element of the base group itself is the identity \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_1} {G : ι → Type u_2} {H : Type u_3} [inst : (i : ι) → Group (G i)] [inst_1 : Group H]\\n  {φ : (i : ι) → H →* G i} (self : Monoid.PushoutI.NormalWord.Transversal φ) (i : ι),\\n  1 ∈ Monoid.PushoutI.NormalWord.Transversal.set self i\"},\n {\"role\": \"user\", \"content\": \"The identity element in a ring is a unit.\"}]"}
{"text":"Every subgroup of a group is a group.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"A subgroup is either the trivial subgroup or nontrivial. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), H = ⊥ ∨ Nontrivial ↥H\"},\n {\"role\": \"user\",\n  \"content\": \"Two subgroups are equal if they have the same elements. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] {H K : Subgroup G}, (∀ (x : G), x ∈ H ↔ x ∈ K) → H = K\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A subgroup is finitely generated if and only if it is finitely generated as a submonoid. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_3} [inst : Group G] (P : Subgroup G), Subgroup.FG P ↔ Submonoid.FG P.toSubmonoid\"},\n {\"role\": \"user\", \"content\": \"A subgroup is closed under inverse. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x : G}, x ∈ H → x⁻¹ ∈ H\"},\n {\"role\": \"user\",\n  \"content\": \"Subgroups of torsion groups are torsion groups. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G → ∀ (H : Subgroup G), Monoid.IsTorsion ↥H\"},\n {\"role\": \"user\", \"content\": \"A subgroup contains the group's 1. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), 1 ∈ H\"},\n {\"role\": \"user\",\n  \"content\": \"The subgroup generated by a set includes the set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] {k : Set G}, k ⊆ ↑(Subgroup.closure k)\"},\n {\"role\": \"user\", \"content\": \"A subgroup is closed under division. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {M : Type u_5} {S : Type u_6} [inst : DivInvMonoid M] [inst_1 : SetLike S M] [hSM : SubgroupClass S M] {H : S}\\n  {x y : M}, x ∈ H → y ∈ H → x / y ∈ H\"},\n {\"role\": \"user\", \"content\": \"A subgroup is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x ∈ H → y ∈ H → x * y ∈ H\"},\n {\"role\": \"user\", \"content\": \"Every subgroup of a group is a group.\"}]"}
{"text":"The sum of two natural numbers is a natural number.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The sum of ordinals as games corresponds to natural addition of ordinals. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (a b : Ordinal.{u}), Ordinal.toPGame a + Ordinal.toPGame b ≈ Ordinal.toPGame (Ordinal.nadd a b)\"},\n {\"role\": \"user\", \"content\": \"The sum of two `C^n`functions is `C^n`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type uE} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {n : ℕ∞}\\n  {f g : E → F}, ContDiff 𝕜 n f → ContDiff 𝕜 n g → ContDiff 𝕜 n fun x => f x + g x\"},\n {\"role\": \"user\",\n  \"content\": \"A sum of numbers is infinite iff one of them is infinite \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_1} {M : Type u_4} [inst : AddCommMonoid M] {s : Finset ι} {f : ι → WithTop M},\\n  (Finset.sum s fun i => f i) = ⊤ ↔ ∃ i ∈ s, f i = ⊤\"},\n {\"role\": \"user\",\n  \"content\": \"Pre-games defined by natural numbers are numeric. \"},\n {\"role\": \"assistant\", \"content\": \"∀ (n : ℕ), SetTheory.PGame.Numeric ↑n\"},\n {\"role\": \"user\",\n  \"content\": \"The sum of two finite adèles is a finite adèle. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} {K : Type u_2} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\\n  [inst_3 : Field K] [inst_4 : Algebra R K] [inst_5 : IsFractionRing R K]\\n  {x y : DedekindDomain.ProdAdicCompletions R K},\\n  DedekindDomain.ProdAdicCompletions.IsFiniteAdele x →\\n    DedekindDomain.ProdAdicCompletions.IsFiniteAdele y → DedekindDomain.ProdAdicCompletions.IsFiniteAdele (x + y)\"},\n {\"role\": \"user\", \"content\": \"A sum of finite numbers is still finite \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {s : Finset α} {f : α → ENNReal}, (∀ a ∈ s, f a ≠ ⊤) → (Finset.sum s fun a => f a) < ⊤\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {m n : ℕ}, (∀ (a : ℕ), a ∣ m ↔ a ∣ n) ↔ m = n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {m n : ℕ}, (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n\"},\n {\"role\": \"user\",\n  \"content\": \"The sum of two natural numbers is a natural number.\"}]"}
{"text":"The identity element of a group has finite order.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is simple. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleGroup α\"},\n {\"role\": \"user\",\n  \"content\": \"The chosen element of the base group itself is the identity \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_1} {G : ι → Type u_2} {H : Type u_3} [inst : (i : ι) → Group (G i)] [inst_1 : Group H]\\n  {φ : (i : ι) → H →* G i} (self : Monoid.PushoutI.NormalWord.Transversal φ) (i : ι),\\n  1 ∈ Monoid.PushoutI.NormalWord.Transversal.set self i\"},\n {\"role\": \"user\",\n  \"content\": \"Elements of finite order are closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : CommMonoid G] {x y : G}, IsOfFinOrder x → IsOfFinOrder y → IsOfFinOrder (x * y)\"},\n {\"role\": \"user\", \"content\": \"The identity is a group homomorphism. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u} [inst : Group α], IsGroupHom id\"},\n {\"role\": \"user\",\n  \"content\": \"Elements of finite order are of finite order in submonoids.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : AddMonoid G] {H : AddSubmonoid G} {x : ↥H}, IsOfFinAddOrder ↑x ↔ IsOfFinAddOrder x\"},\n {\"role\": \"user\",\n  \"content\": \"Inverses of elements of finite order have finite order. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x⁻¹ ↔ IsOfFinOrder x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The image of an element of finite additive order has finite additive order.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} {H : Type u_2} [inst : AddMonoid G] [inst_1 : AddMonoid H] (f : G →+ H) {x : G},\\n  IsOfFinAddOrder x → IsOfFinAddOrder (f x)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A group element has finite additive order iff its order is positive.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : AddMonoid G] {x : G}, 0 < addOrderOf x ↔ IsOfFinAddOrder x\"},\n {\"role\": \"user\",\n  \"content\": \"The image of an element of finite order has finite order. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} {H : Type u_2} [inst : Monoid G] [inst_1 : Monoid H] (f : G →* H) {x : G},\\n  IsOfFinOrder x → IsOfFinOrder (f x)\"},\n {\"role\": \"user\",\n  \"content\": \"A group element has finite order iff its order is positive. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x ↔ IsOfFinOrder x\"},\n {\"role\": \"user\",\n  \"content\": \"The identity element of a group has finite order.\"}]"}
{"text":"`7` is a prime number.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"`ζ - 1` is prime if `ζ` is a primitive `p ^ (k + 1)`-th root of unity. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ+} {k : ℕ} {K : Type u} [inst : Field K] [inst_1 : CharZero K] {ζ : K} [hp : Fact (Nat.Prime ↑p)]\\n  [inst_2 : IsCyclotomicExtension {p ^ (k + 1)} ℚ K] (hζ : IsPrimitiveRoot ζ ↑(p ^ (k + 1))),\\n  Prime (IsPrimitiveRoot.toInteger hζ - 1)\"},\n {\"role\": \"user\", \"content\": \"A minimal polynomial is prime. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\\n  IsIntegral A x → Prime (minpoly A x)\"},\n {\"role\": \"user\",\n  \"content\": \"The only prime factor of prime `p` is `p` itself. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {p q : ℕ}, Nat.Prime p → (Nat.factorization p) q ≠ 0 → p = q\"},\n {\"role\": \"user\",\n  \"content\": \"The only divisors of prime powers are prime powers. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [dec_irr : (p : Associates α) → Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid α] [dec : DecidableEq α] [dec' : DecidableEq (Associates α)] {a p : Associates α},\\n  Irreducible p →\\n    ∀ [inst_2 : (n : ℕ) → Decidable (a ∣ p ^ n)] {n : ℕ} (h : a ∣ p ^ n),\\n      a = p ^ Nat.find (_ : ∃ n, (fun n => a ∣ p ^ n) n)\"},\n {\"role\": \"user\",\n  \"content\": \"`ζ - 1` is prime if `ζ` is a primitive `p`-th root of unity. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ+} {K : Type u} [inst : Field K] [inst_1 : CharZero K] {ζ : K} [hp : Fact (Nat.Prime ↑p)]\\n  [h : IsCyclotomicExtension {p} ℚ K] (hζ : IsPrimitiveRoot ζ ↑p), Prime (IsPrimitiveRoot.toInteger hζ - 1)\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\", \"content\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\"},\n {\"role\": \"user\",\n  \"content\": \"The exponential characteristic is a prime number or one. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (R : Type u) [inst : Semiring R] (q : ℕ) [hq : ExpChar R q], Nat.Prime q ∨ q = 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (n : ℕ), Nat.factorization n = 0 ↔ n = 0 ∨ n = 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"`2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare 2 ↔ p % 8 = 1 ∨ p % 8 = 7)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A prime natural number is prime in `ℤ[i]` if and only if it is `3` mod `4` \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)], Prime ↑p ↔ p % 4 = 3\"},\n {\"role\": \"user\", \"content\": \"`7` is a prime number.\"}]"}
{"text":"There are `3` prime numbers below `8`.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"`2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare 2 ↔ p % 8 = 1 ∨ p % 8 = 7)\"},\n {\"role\": \"user\", \"content\": \"The factors of `n` are the prime divisors \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (n : ℕ), List.toFinset (Nat.factors n) = Finset.filter Nat.Prime (Nat.divisors n)\"},\n {\"role\": \"user\",\n  \"content\": \"The only divisors of prime powers are prime powers. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [dec_irr : (p : Associates α) → Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid α] [dec : DecidableEq α] [dec' : DecidableEq (Associates α)] {a p : Associates α},\\n  Irreducible p →\\n    ∀ [inst_2 : (n : ℕ) → Decidable (a ∣ p ^ n)] {n : ℕ} (h : a ∣ p ^ n),\\n      a = p ^ Nat.find (_ : ∃ n, (fun n => a ∣ p ^ n) n)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The square of the smallest prime factor of a composite number `n` is at most `n`.\\n\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n : ℕ}, 0 < n → ¬Nat.Prime n → Nat.minFac n ^ 2 ≤ n\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\", \"content\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"`-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare (-2) ↔ p % 8 = 1 ∨ p % 8 = 3)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The product of the prime factors of `n` that are less than `N` is an `N`-smooth number. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (n N : ℕ), List.prod (List.filter (fun x => decide (x < N)) (Nat.factors n)) ∈ Nat.smoothNumbers N\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A prime natural number is prime in `ℤ[i]` if and only if it is `3` mod `4` \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)], Prime ↑p ↔ p % 4 = 3\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (n : ℕ), Nat.factorization n = 0 ↔ n = 0 ∨ n = 1\"},\n {\"role\": \"user\", \"content\": \"There are `3` prime numbers below `8`.\"}]"}
{"text":"The empty set is contained in every finite set.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"The shadow of the empty set is empty. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u_1} [inst : DecidableEq α], Finset.shadow ∅ = ∅\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In an infinite graph, the set of components out of a finite set is nonempty. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {V : Type u} (G : SimpleGraph V) [inst : Infinite V] (K : Finset V), Nonempty (SimpleGraph.ComponentCompl G ↑K)\"},\n {\"role\": \"user\",\n  \"content\": \"Uniform convergence on the empty set is vacuously true \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι},\\n  TendstoUniformlyOn F f p ∅\"},\n {\"role\": \"user\",\n  \"content\": \"There are finitely many subsets of a given finite set \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {a : Set α}, Set.Finite a → Set.Finite {b | b ⊆ a}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every finite subset of a linearly independent set is linearly independent. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_2} {M : Type u_4} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (s : Set M),\\n  LinearIndependent (ι := { x // x ∈ s }) R Subtype.val → ∀ (t : Finset ↑s), LinearIndependent R Subtype.val\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any uncountable closed set in a second countable space contains a nonempty perfect subset.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] {C : Set α} [inst_1 : SecondCountableTopology α],\\n  IsClosed C → ¬Set.Countable C → ∃ D, Perfect D ∧ Set.Nonempty D ∧ D ⊆ C\"},\n {\"role\": \"user\", \"content\": \"A finite union of finsets is finite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} (f : α → Finset β), Set.Finite (Set.range f) → Set.Finite (⋃ a, ↑(f a))\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every finite subset of an algebraically independent set is algebraically independent. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_3} {A : Type u_5} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] (s : Set A),\\n  AlgebraicIndependent R Subtype.val → ∀ (t : Finset ↑s), AlgebraicIndependent R Subtype.val\"},\n {\"role\": \"user\", \"content\": \"The empty set is concyclic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : NormedSpace ℝ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P], EuclideanGeometry.Concyclic ∅\"},\n {\"role\": \"user\",\n  \"content\": \"The set of finite subsets of a countable set is countable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {s : Set α}, Set.Countable s → Set.Countable {t | Set.Finite t ∧ t ⊆ s}\"},\n {\"role\": \"user\", \"content\": \"The empty set is contained in every finite set.\"}]"}
{"text":"Every infinite set contains a finite set.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For every open cover of a compact set, there exists a finite subcover. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u} {ι : Type u_1} [inst : TopologicalSpace X] {s : Set X} {b : Set ι} {c : ι → Set X},\\n  IsCompact s → (∀ i ∈ b, IsOpen (c i)) → s ⊆ ⋃ i ∈ b, c i → ∃ b' ⊆ b, Set.Finite b' ∧ s ⊆ ⋃ i ∈ b', c i\"},\n {\"role\": \"user\",\n  \"content\": \"The semilatice generated by a finite set is finite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_2} [inst : SemilatticeSup α] {s : Set α}, Set.Finite s → Set.Finite (supClosure s)\"},\n {\"role\": \"user\", \"content\": \"A finite set is bounded below.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : Preorder α] [inst_1 : IsDirected α fun x x_1 => x ≥ x_1] [inst_2 : Nonempty α] {s : Set α},\\n  Set.Finite s → BddBelow s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every finite subset of an algebraically independent set is algebraically independent. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_3} {A : Type u_5} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] (s : Set A),\\n  AlgebraicIndependent R Subtype.val → ∀ (t : Finset ↑s), AlgebraicIndependent R Subtype.val\"},\n {\"role\": \"user\", \"content\": \"Finite product of finite sets is finite \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {δ : Type u_1} [inst : Finite δ] {κ : δ → Type u_2} {t : (d : δ) → Set (κ d)},\\n  (∀ (d : δ), Set.Finite (t d)) → Set.Finite (Set.pi Set.univ t)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every finite subset of a linearly independent set is linearly independent. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_2} {M : Type u_4} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (s : Set M),\\n  LinearIndependent (ι := { x // x ∈ s }) R Subtype.val → ∀ (t : Finset ↑s), LinearIndependent R Subtype.val\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In an infinite graph, the set of components out of a finite set is nonempty. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {V : Type u} (G : SimpleGraph V) [inst : Infinite V] (K : Finset V), Nonempty (SimpleGraph.ComponentCompl G ↑K)\"},\n {\"role\": \"user\",\n  \"content\": \"There are finitely many subsets of a given finite set \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {a : Set α}, Set.Finite a → Set.Finite {b | b ⊆ a}\"},\n {\"role\": \"user\", \"content\": \"A finite union of finsets is finite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} (f : α → Finset β), Set.Finite (Set.range f) → Set.Finite (⋃ a, ↑(f a))\"},\n {\"role\": \"user\",\n  \"content\": \"The set of finite subsets of a countable set is countable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {s : Set α}, Set.Countable s → Set.Countable {t | Set.Finite t ∧ t ⊆ s}\"},\n {\"role\": \"user\", \"content\": \"Every infinite set contains a finite set.\"}]"}
{"text":"Every commutative ring is a monoid.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"Left multiplication in a ring is an additive monoid morphism. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {γ : Type u_1} [inst : NonUnitalNonAssocSemiring γ] (x : γ), IsAddMonoidHom fun y => x * y\"},\n {\"role\": \"user\",\n  \"content\": \"The category of commutative rings has all limits. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"CategoryTheory.Limits.HasLimitsOfSize.{v, v, max u v, max (u + 1) (v + 1)} CommRingCatMax\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If all prime ideals in a commutative ring are principal, so are all other ideals. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : CommRing R],\\n  (∀ (P : Ideal R), Ideal.IsPrime P → Submodule.IsPrincipal P) → IsPrincipalIdealRing R\"},\n {\"role\": \"user\", \"content\": \"1 is of finite order in any monoid. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder 1\"},\n {\"role\": \"user\",\n  \"content\": \"Composition of monoid homomorphisms is associative. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {M : Type u_3} {N : Type u_4} {P : Type u_5} {Q : Type u_9} [inst : One M] [inst_1 : One N] [inst_2 : One P]\\n  [inst_3 : One Q] (f : OneHom M N) (g : OneHom N P) (h : OneHom P Q),\\n  OneHom.comp (OneHom.comp h g) f = OneHom.comp h (OneHom.comp g f)\"},\n {\"role\": \"user\",\n  \"content\": \"The category of commutative monoids has all limits. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"CategoryTheory.Limits.HasLimitsOfSize.{v, v, max u v, max (u + 1) (v + 1)} CommMonCatMax\"},\n {\"role\": \"user\", \"content\": \"A group homomorphism is a monoid homomorphism. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : Group β] {f : α → β}, IsGroupHom f → IsMonoidHom f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The composite of two monoid homomorphisms is a monoid homomorphism. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : MulOneClass α] [inst_1 : MulOneClass β] {f : α → β},\\n  IsMonoidHom f → ∀ {γ : Type u_1} [inst_2 : MulOneClass γ] {g : β → γ}, IsMonoidHom g → IsMonoidHom (g ∘ f)\"},\n {\"role\": \"user\", \"content\": \"A monoid is a submonoid of itself. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {M : Type u_1} [inst : Monoid M], IsSubmonoid Set.univ\"},\n {\"role\": \"user\",\n  \"content\": \"The center of a monoid acts commutatively on that monoid. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {M : Type u_1} [inst : Monoid M], SMulCommClass M (↥(Submonoid.center M)) M\"},\n {\"role\": \"user\", \"content\": \"Every commutative ring is a monoid.\"}]"}
{"text":"There is no field of order `10`.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"The empty set is nowhere dense. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {X : Type u_4} [inst : TopologicalSpace X], IsNowhereDense ∅\"},\n {\"role\": \"user\", \"content\": \"In a dense order, nothing covers anything. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : LT α] {a b : α} [inst_1 : DenselyOrdered α], ¬a ⋖ b\"},\n {\"role\": \"user\", \"content\": \"The order of the `0` power series is infinite.\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {R : Type u_1} [inst : Semiring R], PowerSeries.order 0 = ⊤\"},\n {\"role\": \"user\", \"content\": \"An intermediate field contains the ring's 0. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u_1} {L : Type u_2} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\\n  0 ∈ S\"},\n {\"role\": \"user\", \"content\": \"No points are in `⊥`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (k : Type u_1) (V : Type u_2) {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [S : AddTorsor V P] (p : P), p ∉ ⊥\"},\n {\"role\": \"user\",\n  \"content\": \"`ℤ` with its usual ring structure is not a field. \"},\n {\"role\": \"assistant\", \"content\": \"¬IsField ℤ\"},\n {\"role\": \"user\",\n  \"content\": \"Infinite ordinals that are cardinals are unbounded. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"Set.Unbounded (fun x x_1 => x < x_1) {b | Cardinal.ord (Ordinal.card b) = b ∧ Ordinal.omega ≤ b}\"},\n {\"role\": \"user\", \"content\": \"Fields are commutative. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : Semiring R], IsField R → ∀ (x y : R), x * y = y * x\"},\n {\"role\": \"user\", \"content\": \"Ordinals that are cardinals are unbounded. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"Set.Unbounded (fun x x_1 => x < x_1) {b | Cardinal.ord (Ordinal.card b) = b}\"},\n {\"role\": \"user\",\n  \"content\": \"The ring of integers of a number field is not a field. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (K : Type u_1) [inst : Field K] [nf : NumberField K], ¬IsField ↥(NumberField.ringOfIntegers K)\"},\n {\"role\": \"user\", \"content\": \"There is no field of order `10`.\"}]"}
{"text":"Every odd natural number is the sum of two distinct natural numbers.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"A natural number is odd iff it has residue `1` or `3` mod `4`\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n : ℕ}, n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3\"},\n {\"role\": \"user\", \"content\": \"A sum of finite numbers is still finite \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {s : Finset α} {f : α → ENNReal}, (∀ a ∈ s, f a ≠ ⊤) → (Finset.sum s fun a => f a) < ⊤\"},\n {\"role\": \"user\",\n  \"content\": \"Every finite convergent corresponds to a rational number. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K) (n : ℕ),\\n  ∃ q, GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n = ↑q\"},\n {\"role\": \"user\",\n  \"content\": \"The sum of two finite adèles is a finite adèle. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} {K : Type u_2} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\\n  [inst_3 : Field K] [inst_4 : Algebra R K] [inst_5 : IsFractionRing R K]\\n  {x y : DedekindDomain.ProdAdicCompletions R K},\\n  DedekindDomain.ProdAdicCompletions.IsFiniteAdele x →\\n    DedekindDomain.ProdAdicCompletions.IsFiniteAdele y → DedekindDomain.ProdAdicCompletions.IsFiniteAdele (x + y)\"},\n {\"role\": \"user\", \"content\": \"`2` is not a factor of an odd natural number. \"},\n {\"role\": \"assistant\", \"content\": \"∀ {m n : ℕ}, Odd n → m ∣ n → m ≠ 2\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\", \"content\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {m n : ℕ}, (∀ (a : ℕ), a ∣ m ↔ a ∣ n) ↔ m = n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {m n : ℕ}, (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every odd natural number is the sum of two distinct natural numbers.\"}]"}
{"text":"Every element in the trivial group has finite order.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A group element has finite additive order iff its order is positive.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : AddMonoid G] {x : G}, 0 < addOrderOf x ↔ IsOfFinAddOrder x\"},\n {\"role\": \"user\",\n  \"content\": \"Elements of finite order are of finite order in submonoids.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : AddMonoid G] {H : AddSubmonoid G} {x : ↥H}, IsOfFinAddOrder ↑x ↔ IsOfFinAddOrder x\"},\n {\"role\": \"user\",\n  \"content\": \"Elements of finite order are closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : CommMonoid G] {x y : G}, IsOfFinOrder x → IsOfFinOrder y → IsOfFinOrder (x * y)\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is cyclic.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsAddCyclic α\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is cyclic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α\"},\n {\"role\": \"user\",\n  \"content\": \"The image of an element of finite order has finite order. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} {H : Type u_2} [inst : Monoid G] [inst_1 : Monoid H] (f : G →* H) {x : G},\\n  IsOfFinOrder x → IsOfFinOrder (f x)\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is simple.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleAddGroup α\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is simple. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleGroup α\"},\n {\"role\": \"user\",\n  \"content\": \"A group element has finite order iff its order is positive. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x ↔ IsOfFinOrder x\"},\n {\"role\": \"user\",\n  \"content\": \"Inverses of elements of finite order have finite order. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x⁻¹ ↔ IsOfFinOrder x\"},\n {\"role\": \"user\",\n  \"content\": \"Every element in the trivial group has finite order.\"}]"}
{"text":"The square of an even number is even.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"`2` is a square in `F` iff `#F` is not congruent to `3` or `5` mod `8`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F], IsSquare 2 ↔ Fintype.card F % 8 ≠ 3 ∧ Fintype.card F % 8 ≠ 5\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The finite field `F` has even cardinality iff it has characteristic `2`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {F : Type u_3} [inst : Field F] [inst_1 : Fintype F], ringChar F = 2 ↔ Fintype.card F % 2 = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"`2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare 2 ↔ p % 8 = 1 ∨ p % 8 = 7)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Commutativity of a square is preserved when taking quotients by an ideal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} {S : Type v} [inst : CommRing R] [inst_1 : CommRing S] {R' : Type u_5} {S' : Type u_6}\\n  [inst_2 : CommRing R'] [inst_3 : CommRing S'] {f : R →+* S} {f' : R' →+* S'} {g : R →+* R'} {g' : S →+* S'}\\n  (hfg : RingHom.comp f' g = RingHom.comp g' f) (I : Ideal S'),\\n  let leq := (_ : Ideal.comap f (Ideal.comap g' I) ≤ Ideal.comap g (Ideal.comap f' I));\\n  RingHom.comp (Ideal.quotientMap I g' (_ : Ideal.comap g' I ≤ Ideal.comap g' I))\\n      (Ideal.quotientMap (Ideal.comap g' I) f\\n        (_ : Ideal.comap f (Ideal.comap g' I) ≤ Ideal.comap f (Ideal.comap g' I))) =\\n    RingHom.comp (Ideal.quotientMap I f' (_ : Ideal.comap f' I ≤ Ideal.comap f' I))\\n      (Ideal.quotientMap (Ideal.comap f' I) g leq)\"},\n {\"role\": \"user\", \"content\": \"The square commutes. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {C : Type u_1} [inst : CategoryTheory.Category.{u_2, u_1} C] {W X Y Z : C} {f : W ⟶ X} {g : W ⟶ Y} {h : X ⟶ Z}\\n  {i : Y ⟶ Z},\\n  CategoryTheory.CommSq f g h i → CategoryTheory.CategoryStruct.comp f h = CategoryTheory.CategoryStruct.comp g i\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a finite field of odd characteristic, not every element is a square. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {F : Type u_3} [inst : Field F] [inst_1 : Finite F], ringChar F ≠ 2 → ∃ a, ¬IsSquare a\"},\n {\"role\": \"user\",\n  \"content\": \"The sum of two squares is zero iff both elements are zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : LinearOrderedRing α] {x y : α}, x * x + y * y = 0 ↔ x = 0 ∧ y = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a finite field of characteristic `2`, all elements are squares. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {F : Type u_3} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 → ∀ (a : F), IsSquare a\"},\n {\"role\": \"user\",\n  \"content\": \"The convolution of two even functions is also even. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {𝕜 : Type u𝕜} {G : Type uG} {E : Type uE} {E' : Type uE'} {F : Type uF} [inst : NormedAddCommGroup E]\\n  [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedAddCommGroup F] {f : G → E} {g : G → E'} {x : G}\\n  [inst_3 : NontriviallyNormedField 𝕜] [inst_4 : NormedSpace 𝕜 E] [inst_5 : NormedSpace 𝕜 E'] [inst_6 : NormedSpace 𝕜 F]\\n  (L : E →L[𝕜] E' →L[𝕜] F) [inst_7 : MeasurableSpace G] {μ : MeasureTheory.Measure G} [inst_8 : NormedSpace ℝ F]\\n  [inst_9 : AddCommGroup G] [inst_10 : MeasureTheory.Measure.IsAddLeftInvariant μ]\\n  [inst_11 : MeasureTheory.Measure.IsNegInvariant μ] [inst_12 : MeasurableNeg G] [inst_13 : MeasurableAdd G],\\n  (∀ᵐ (x : G) ∂μ, f (-x) = f x) → (∀ᵐ (x : G) ∂μ, g (-x) = g x) → convolution f g L (-x) = convolution f g L x\"},\n {\"role\": \"user\", \"content\": \"The square of an even number is even.\"}]"}
{"text":"Every commutative division ring is a field.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every nonarchimedean ring is naturally a nonarchimedean additive group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (R : Type u_1) [inst : Ring R] [inst_1 : TopologicalSpace R] [t : NonarchimedeanRing R], NonarchimedeanAddGroup R\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The multivariate polynomial ring over an integral domain is an integral domain. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} {σ : Type v} [inst : CommRing R] [inst_1 : IsDomain R], IsDomain (MvPolynomial σ R)\"},\n {\"role\": \"user\",\n  \"content\": \"An intermediate field is closed under division. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u_1} {L : Type u_2} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\\n  {x y : L}, x ∈ S → y ∈ S → x / y ∈ S\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A cyclotomic finite extension of a number field is a number field. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (S : Set ℕ+) (K : Type w) (L : Type z) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] [h : NumberField K]\\n  [inst_3 : Finite ↑S] [inst : IsCyclotomicExtension S K L], NumberField L\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A field is perfect if every irreducible polynomial is separable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u_1} [inst : Field K] [self : PerfectField K] {f : Polynomial K}, Irreducible f → Polynomial.Separable f\"},\n {\"role\": \"user\", \"content\": \"A field is a valuation ring. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (K : Type u) [inst : Field K], ValuationRing K\"},\n {\"role\": \"user\",\n  \"content\": \"The category of commutative rings has all limits. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"CategoryTheory.Limits.HasLimitsOfSize.{v, v, max u v, max (u + 1) (v + 1)} CommRingCatMax\"},\n {\"role\": \"user\",\n  \"content\": \"An algebraically closed field is also separably closed. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (k : Type u) [inst : Field k] [inst_1 : IsAlgClosed k], IsSepClosed k\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The quotient of a ring by an ideal is a field iff the ideal is maximal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I ↔ IsField (R ⧸ I)\"},\n {\"role\": \"user\", \"content\": \"Fields are commutative. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : Semiring R], IsField R → ∀ (x y : R), x * y = y * x\"},\n {\"role\": \"user\", \"content\": \"Every commutative division ring is a field.\"}]"}
{"text":"The image of the identity element under the identity map is the identity element.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"The identity map preserves addition\"},\n {\"role\": \"assistant\", \"content\": \"∀ {α : Type u} [inst : Add α], IsAddHom id\"},\n {\"role\": \"user\", \"content\": \"The identity is a group homomorphism. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u} [inst : Group α], IsGroupHom id\"},\n {\"role\": \"user\", \"content\": \"The identity is an isometry \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u} [inst : PseudoEMetricSpace α], Isometry id\"},\n {\"role\": \"user\",\n  \"content\": \"The chosen element of the base group itself is the identity \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_1} {G : ι → Type u_2} {H : Type u_3} [inst : (i : ι) → Group (G i)] [inst_1 : Group H]\\n  {φ : (i : ι) → H →* G i} (self : Monoid.PushoutI.NormalWord.Transversal φ) (i : ι),\\n  1 ∈ Monoid.PushoutI.NormalWord.Transversal.set self i\"},\n {\"role\": \"user\", \"content\": \"The identity affine map acts as the identity. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (k : Type u_1) {V1 : Type u_2} (P1 : Type u_3) [inst : Ring k] [inst_1 : AddCommGroup V1] [inst_2 : Module k V1]\\n  [inst_3 : AddTorsor V1 P1], ⇑(AffineMap.id k P1) = id\"},\n {\"role\": \"user\",\n  \"content\": \"The identity map is an additive monoid homomorphism.\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u} [inst : AddZeroClass α], IsAddMonoidHom id\"},\n {\"role\": \"user\", \"content\": \"The identity map is a semiring homomorphism. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u} [inst : Semiring α], IsSemiringHom id\"},\n {\"role\": \"user\", \"content\": \"The identity map preserves multiplication. \"},\n {\"role\": \"assistant\", \"content\": \"∀ {α : Type u} [inst : Mul α], IsMulHom id\"},\n {\"role\": \"user\", \"content\": \"The identity map is a monoid homomorphism. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u} [inst : MulOneClass α], IsMonoidHom id\"},\n {\"role\": \"user\", \"content\": \"The identity map is a ring homomorphism. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u} [inst : Ring α], IsRingHom id\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The image of the identity element under the identity map is the identity element.\"}]"}
{"text":"Every point is a fixed point of the identity function on a space.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"An affinely independent set of points can be extended to such a\\nset that spans the whole space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] {s : Set P},\\n  (AffineIndependent k fun p => ↑p) → ∃ t, s ⊆ t ∧ (AffineIndependent k fun p => ↑p) ∧ affineSpan k t = ⊤\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two points in a projective space are dependent if and only if they are equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u_2} {V : Type u_3} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  (u v : Projectivization K V), Projectivization.Dependent ![u, v] ↔ u = v\"},\n {\"role\": \"user\", \"content\": \"For the identity map, all points are periodic. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u_1} (n : ℕ) (x : α), Function.IsPeriodicPt id n x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"An affine-independent subset of a finite-dimensional affine space is finite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (k : Type u_1) {V : Type u_2} {P : Type u_3} {ι : Type u_4} [inst : DivisionRing k] [inst_1 : AddCommGroup V]\\n  [inst_2 : Module k V] [inst_3 : AddTorsor V P] [inst_4 : FiniteDimensional k V] {s : Set ι} {f : ↑s → P},\\n  AffineIndependent k f → Set.Finite s\"},\n {\"role\": \"user\",\n  \"content\": \"Two inseparable points in a T₀ space are equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u} [inst : TopologicalSpace X] [self : T0Space X] ⦃x y : X⦄, Inseparable x y → x = y\"},\n {\"role\": \"user\", \"content\": \"All hom spaces are finite dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {k G : Type u} [inst : Field k] [inst_1 : Monoid G] (V W : FdRep k G), FiniteDimensional k (V ⟶ W)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A point is in the affine span of a single point if and only if they are equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (k : Type u_1) (V : Type u_2) {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [S : AddTorsor V P] {p₁ p₂ : P}, p₁ ∈ affineSpan k {p₂} ↔ p₁ = p₂\"},\n {\"role\": \"user\",\n  \"content\":\n  \"An affine-independent family of points in a finite-dimensional affine space is finite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (k : Type u_1) {V : Type u_2} {P : Type u_3} {ι : Type u_4} [inst : DivisionRing k] [inst_1 : AddCommGroup V]\\n  [inst_2 : Module k V] [inst_3 : AddTorsor V P] [inst_4 : FiniteDimensional k V] {p : ι → P},\\n  AffineIndependent k p → Finite ι\"},\n {\"role\": \"user\",\n  \"content\": \"The set of fixed points of a continuous map is a closed set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : T2Space α] {f : α → α},\\n  Continuous f → IsClosed (Function.fixedPoints f)\"},\n {\"role\": \"user\", \"content\": \"Every point is a fixed point of `id`. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u} (x : α), Function.IsFixedPt id x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every point is a fixed point of the identity function on a space.\"}]"}
{"text":"The diameter of a singleton space is `0`.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The one point compactification of a `T0Space` space is a `T0Space`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T0Space X], T0Space (OnePoint X)\"},\n {\"role\": \"user\", \"content\": \"A singleton in a T₁ space is a closed set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u} [inst : TopologicalSpace X] [self : T1Space X] (x : X), IsClosed {x}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A nonempty set is scaled by zero to the singleton set containing 0. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_2} {β : Type u_3} [inst : Zero α] [inst_1 : Zero β] [inst_2 : SMulWithZero α β] [inst_3 : DecidableEq β]\\n  {s : Finset β}, Finset.Nonempty s → 0 • s = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A space is totally disconnected iff its connected components are singletons. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α], TotallyDisconnectedSpace α ↔ ∀ (x : α), connectedComponent x = {x}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The image of a connected component in a totally disconnected space is a singleton. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {β : Type u_3} [inst_1 : TopologicalSpace β]\\n  [inst_2 : TotallyDisconnectedSpace β] {f : α → β}, Continuous f → ∀ (a : α), f '' connectedComponent a = {f a}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A (finite dimensional) space that is a subsingleton has zero `finrank`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : Ring K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] [inst_3 : Nontrivial K]\\n  [inst_4 : NoZeroSMulDivisors K V] [h : Subsingleton V], FiniteDimensional.finrank K V = 0\"},\n {\"role\": \"user\", \"content\": \"The diameter of the empty set vanishes \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : PseudoEMetricSpace α], EMetric.diam ∅ = 0\"},\n {\"role\": \"user\", \"content\": \"The empty set has zero diameter \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u} [inst : PseudoMetricSpace α], Metric.diam ∅ = 0\"},\n {\"role\": \"user\", \"content\": \"The diameter of a singleton vanishes \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : PseudoEMetricSpace α] {x : α}, EMetric.diam {x} = 0\"},\n {\"role\": \"user\", \"content\": \"A singleton has zero diameter \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0\"},\n {\"role\": \"user\", \"content\": \"The diameter of a singleton space is `0`.\"}]"}
{"text":"Every group is non-empty.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The cartesian product of two nonarchimedean groups is nonarchimedean. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : NonarchimedeanGroup G] {K : Type u_3}\\n  [inst_3 : Group K] [inst_4 : TopologicalSpace K] [inst_5 : NonarchimedeanGroup K], NonarchimedeanGroup (G × K)\"},\n {\"role\": \"user\", \"content\": \"A non-cyclic additive group is non-trivial.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : AddGroup α], ¬IsAddCyclic α → Nontrivial α\"},\n {\"role\": \"user\",\n  \"content\": \"The intrinsic interior of a nonempty convex set is nonempty. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {V : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : NormedSpace ℝ V] [inst_2 : FiniteDimensional ℝ V] {s : Set V},\\n  Convex ℝ s → Set.Nonempty s → Set.Nonempty (intrinsicInterior ℝ s)\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [self : LinearOrderedCommGroupWithZero α] (a : α), a ≠ 0 → a * a⁻¹ = 1\"},\n {\"role\": \"user\", \"content\": \"The affine span of a nonempty set is nonempty. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (k : Type u_1) {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] {s : Set P} [inst_4 : Nonempty ↑s], Nonempty ↥(affineSpan k s)\"},\n {\"role\": \"user\",\n  \"content\": \"The set in the definition of division is nonempty. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {a b : Ordinal.{u_4}}, b ≠ 0 → Set.Nonempty {o | a < b * Order.succ o}\"},\n {\"role\": \"user\", \"content\": \"A connected space is nonempty. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [self : ConnectedSpace α], Nonempty α\"},\n {\"role\": \"user\", \"content\": \"The ideal is nonempty. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {P : Type u_2} [inst : LE P] (self : Order.Ideal P), Set.Nonempty self.carrier\"},\n {\"role\": \"user\",\n  \"content\": \"Each connected component of the category is nonempty. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {J : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} J] (j : CategoryTheory.ConnectedComponents J),\\n  Nonempty (CategoryTheory.Component j)\"},\n {\"role\": \"user\", \"content\": \"Every group is non-empty.\"}]"}
{"text":"All connected components of a topological space are connected.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"Each connected component of the category is nonempty. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {J : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} J] (j : CategoryTheory.ConnectedComponents J),\\n  Nonempty (CategoryTheory.Component j)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any two points in a path-connected space must be joined by a continuous path. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u_4} [inst : TopologicalSpace X] [self : PathConnectedSpace X] (x y : X), Joined x y\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A space is totally disconnected iff its connected components are subsingletons. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α],\\n  TotallyDisconnectedSpace α ↔ ∀ (x : α), Set.Subsingleton (connectedComponent x)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A space is totally disconnected iff its connected components are singletons. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α], TotallyDisconnectedSpace α ↔ ∀ (x : α), connectedComponent x = {x}\"},\n {\"role\": \"user\",\n  \"content\": \"A space with discrete topology is a locally connected space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (α : Type u_3) [inst : TopologicalSpace α] [inst_1 : DiscreteTopology α], LocallyConnectedSpace α\"},\n {\"role\": \"user\", \"content\": \"A connected space is nonempty. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [self : ConnectedSpace α], Nonempty α\"},\n {\"role\": \"user\", \"content\": \"Finite topological spaces are compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : Finite X], CompactSpace X\"},\n {\"role\": \"user\",\n  \"content\": \"Each connected component of the category is connected. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {J : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} J] (j : CategoryTheory.ConnectedComponents J),\\n  CategoryTheory.IsConnected (CategoryTheory.Component j)\"},\n {\"role\": \"user\", \"content\": \"The underlying topological space is compact.\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (self : CompHaus), CompactSpace ↑self.toTop\"},\n {\"role\": \"user\",\n  \"content\": \"All connected components of a topological space are connected.\"}]"}
{"text":"The ring of integers has a maximal ideal.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The class number is `1` iff the ring of integers is a principal ideal domain. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\\n  [inst_3 : Fintype (ClassGroup R)], Fintype.card (ClassGroup R) = 1 ↔ IsPrincipalIdealRing R\"},\n {\"role\": \"user\",\n  \"content\": \"This ideal is maximal in the collection of proper ideals. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {P : Type u_1} [inst : LE P] {I : Order.Ideal P} [self : Order.Ideal.IsMaximal I] ⦃J : Order.Ideal P⦄,\\n  I < J → ↑J = Set.univ\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The ring of integers of a `p`-th cyclotomic extension of `ℚ` is a cyclotomic extension. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ+} {K : Type u} [inst : Field K] [inst_1 : CharZero K] [hp : Fact (Nat.Prime ↑p)]\\n  [inst_2 : IsCyclotomicExtension {p} ℚ K], IsCyclotomicExtension {p} ℤ ↥(NumberField.ringOfIntegers K)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If the quotient by an ideal is a field, then the ideal is maximal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : CommRing R] (I : Ideal R), IsField (R ⧸ I) → Ideal.IsMaximal I\"},\n {\"role\": \"user\",\n  \"content\": \"Multiplicativity of the ideal norm in number rings. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {S : Type u_1} [inst : CommRing S] [inst_1 : IsDomain S] [inst_2 : IsDedekindDomain S] [inst_3 : Module.Free ℤ S]\\n  [inst_4 : Module.Finite ℤ S] (I J : Ideal S), Submodule.cardQuot (I * J) = Submodule.cardQuot I * Submodule.cardQuot J\"},\n {\"role\": \"user\",\n  \"content\": \"Maximal ideals in complete normed rings are closed. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] {I : Ideal R} [hI : Ideal.IsMaximal I], IsClosed ↑I\"},\n {\"role\": \"user\",\n  \"content\": \"Krull's theorem: a nontrivial ring has a maximal ideal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (α : Type u) [inst : Semiring α] [inst_1 : Nontrivial α], ∃ M, Ideal.IsMaximal M\"},\n {\"role\": \"user\",\n  \"content\": \"When a ring is not a field, the maximal ideals are nontrivial. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : CommSemiring R] [inst_1 : Nontrivial R] {M : Ideal R}, Ideal.IsMaximal M → ¬IsField R → M ≠ ⊥\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The quotient of a ring by an ideal is a field iff the ideal is maximal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I ↔ IsField (R ⧸ I)\"},\n {\"role\": \"user\", \"content\": \"The ring of integers has a maximal ideal.\"}]"}
{"text":"The numbers `3`, `4` and `5` form a Pythagorean triple.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"`(k*x, k*y, k*z)` is a Pythagorean triple if and only if\\n`(x, y, z)` is also a triple. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {x y z : ℤ} (k : ℤ), k ≠ 0 → (PythagoreanTriple (k * x) (k * y) (k * z) ↔ PythagoreanTriple x y z)\"},\n {\"role\": \"user\",\n  \"content\": \"Pythagorean theorem, if-and-only-if vector inner product form. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {F : Type u_3} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] (x y : F),\\n  ‖x + y‖ * ‖x + y‖ = ‖x‖ * ‖x‖ + ‖y‖ * ‖y‖ ↔ inner x y = 0\"},\n {\"role\": \"user\",\n  \"content\": \"Pythagorean theorem, subtracting vectors, vector angle form. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] (x y : V),\\n  InnerProductGeometry.angle x y = Real.pi / 2 → ‖x - y‖ * ‖x - y‖ = ‖x‖ * ‖x‖ + ‖y‖ * ‖y‖\"},\n {\"role\": \"user\",\n  \"content\": \"Pythagorean theorem, if-and-only-if vector angle form. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] (x y : V),\\n  ‖x + y‖ * ‖x + y‖ = ‖x‖ * ‖x‖ + ‖y‖ * ‖y‖ ↔ InnerProductGeometry.angle x y = Real.pi / 2\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Pythagorean theorem, if-and-if vector inner product form using square roots. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {F : Type u_3} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] {x y : F},\\n  ‖x + y‖ = Real.sqrt (‖x‖ * ‖x‖ + ‖y‖ * ‖y‖) ↔ inner x y = 0\"},\n {\"role\": \"user\",\n  \"content\": \"Pythagorean theorem, vector inner product form. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  (x y : E), inner x y = 0 → ‖x + y‖ * ‖x + y‖ = ‖x‖ * ‖x‖ + ‖y‖ * ‖y‖\"},\n {\"role\": \"user\", \"content\": \"Pythagorean theorem, vector angle form. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] (x y : V),\\n  InnerProductGeometry.angle x y = Real.pi / 2 → ‖x + y‖ * ‖x + y‖ = ‖x‖ * ‖x‖ + ‖y‖ * ‖y‖\"},\n {\"role\": \"user\", \"content\": \"The zeroth Pythagorean triple is all zeros. \"},\n {\"role\": \"assistant\", \"content\": \"PythagoreanTriple 0 0 0\"},\n {\"role\": \"user\", \"content\": \"**Formula for Pythagorean Triples** \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {x y z : ℤ},\\n  PythagoreanTriple x y z ↔\\n    ∃ k m n,\\n      (x = k * (m ^ 2 - n ^ 2) ∧ y = k * (2 * m * n) ∨ x = k * (2 * m * n) ∧ y = k * (m ^ 2 - n ^ 2)) ∧\\n        (z = k * (m ^ 2 + n ^ 2) ∨ z = -k * (m ^ 2 + n ^ 2))\"},\n {\"role\": \"user\",\n  \"content\": \"The numbers `3`, `4` and `5` form a Pythagorean triple.\"}]"}
{"text":"A vector space with the empty set as basis is trivial.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a vector space has a finite dimension, the index set of `Basis.ofVectorSpace` is finite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\\n  Module.rank K V < Cardinal.aleph0 → Set.Finite (Basis.ofVectorSpaceIndex K V)\"},\n {\"role\": \"user\",\n  \"content\": \"Two linearly equivalent vector spaces have the same dimension. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : Ring R] {M : Type v} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {M₁ : Type v}\\n  [inst_3 : AddCommGroup M₁] [inst_4 : Module R M₁], (M ≃ₗ[R] M₁) → Module.rank R M = Module.rank R M₁\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a one-dimensional space, any vector is a multiple of any nonzero vector \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\\n  FiniteDimensional.finrank K V = 1 → ∀ {x : V}, x ≠ 0 → ∀ (y : V), ∃ c, c • x = y\"},\n {\"role\": \"user\", \"content\": \"The empty set is collinear. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (k : Type u_1) {V : Type u_2} (P : Type u_3) [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P], Collinear k ∅\"},\n {\"role\": \"user\", \"content\": \"A strict vector subspace has measure zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ℝ E] (μ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] (s : Submodule ℝ E), s ≠ ⊤ → ↑↑μ ↑s = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a vector space has a basis indexed by elements of a finite set, then it is\\nfinite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\\n  {s : Set ι}, Basis (↑s) K V → Set.Finite s → FiniteDimensional K V\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a vector space has a finite basis, then it is finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\\n  [inst_3 : Finite ι], Basis ι K V → FiniteDimensional K V\"},\n {\"role\": \"user\",\n  \"content\": \"A vector space with the empty set as basis is trivial.\"}]"}
{"text":"Every prime number is `2` or odd.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a finite field of characteristic `2`, all elements are squares. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {F : Type u_3} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 → ∀ (a : F), IsSquare a\"},\n {\"role\": \"user\",\n  \"content\": \"The only prime factor of prime `p` is `p` itself. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {p q : ℕ}, Nat.Prime p → (Nat.factorization p) q ≠ 0 → p = q\"},\n {\"role\": \"user\",\n  \"content\":\n  \"`-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare (-2) ↔ p % 8 = 1 ∨ p % 8 = 3)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A prime natural number is prime in `ℤ[i]` if and only if it is `3` mod `4` \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)], Prime ↑p ↔ p % 4 = 3\"},\n {\"role\": \"user\",\n  \"content\": \"The only divisors of prime powers are prime powers. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [dec_irr : (p : Associates α) → Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid α] [dec : DecidableEq α] [dec' : DecidableEq (Associates α)] {a p : Associates α},\\n  Irreducible p →\\n    ∀ [inst_2 : (n : ℕ) → Decidable (a ∣ p ^ n)] {n : ℕ} (h : a ∣ p ^ n),\\n      a = p ^ Nat.find (_ : ∃ n, (fun n => a ∣ p ^ n) n)\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\", \"content\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (n : ℕ), Nat.factorization n = 0 ↔ n = 0 ∨ n = 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"`2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare 2 ↔ p % 8 = 1 ∨ p % 8 = 7)\"},\n {\"role\": \"user\",\n  \"content\": \"A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 2 = 1 ↔ p ≠ 2\"},\n {\"role\": \"user\", \"content\": \"`2` is not a factor of an odd natural number. \"},\n {\"role\": \"assistant\", \"content\": \"∀ {m n : ℕ}, Odd n → m ∣ n → m ≠ 2\"},\n {\"role\": \"user\", \"content\": \"Every prime number is `2` or odd.\"}]"}
{"text":"There are infinitely many odd natural numbers.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"A transcendental real number is irrational. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {r : ℝ}, Transcendental ℚ r → Irrational r\"},\n {\"role\": \"user\",\n  \"content\": \"Every finite convergent corresponds to a rational number. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K) (n : ℕ),\\n  ∃ q, GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n = ↑q\"},\n {\"role\": \"user\",\n  \"content\": \"Infinite ordinals that are cardinals are unbounded. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"Set.Unbounded (fun x x_1 => x < x_1) {b | Cardinal.ord (Ordinal.card b) = b ∧ Ordinal.omega ≤ b}\"},\n {\"role\": \"user\", \"content\": \"A product of finite numbers is still finite \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_1} {R : Type u_8} [inst : CommMonoidWithZero R] [inst_1 : NoZeroDivisors R] [inst_2 : Nontrivial R]\\n  [inst_3 : DecidableEq R] [inst_4 : LT R] {s : Finset ι} {f : ι → WithTop R},\\n  (∀ i ∈ s, f i ≠ ⊤) → (Finset.prod s fun i => f i) < ⊤\"},\n {\"role\": \"user\", \"content\": \"A sum of finite numbers is still finite \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {s : Finset α} {f : α → ENNReal}, (∀ a ∈ s, f a ≠ ⊤) → (Finset.sum s fun a => f a) < ⊤\"},\n {\"role\": \"user\",\n  \"content\": \"A natural number is odd iff it has residue `1` or `3` mod `4`\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n : ℕ}, n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3\"},\n {\"role\": \"user\", \"content\": \"There is an infinite base \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {M : Matroid α} [self : Matroid.InfiniteRk M], ∃ B, M.Base B ∧ Set.Infinite B\"},\n {\"role\": \"user\",\n  \"content\": \"Infinitely many natural numbers are equal to `d` mod `n`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {n : ℕ}, n ≠ 0 → ∀ (d : ℕ), ∃ᶠ (m : ℕ) in Filter.atTop, m ≡ d [MOD n]\"},\n {\"role\": \"user\",\n  \"content\": \"A sum of numbers is infinite iff one of them is infinite \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_1} {M : Type u_4} [inst : AddCommMonoid M] {s : Finset ι} {f : ι → WithTop M},\\n  (Finset.sum s fun i => f i) = ⊤ ↔ ∃ i ∈ s, f i = ⊤\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\", \"content\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\"},\n {\"role\": \"user\", \"content\": \"There are infinitely many odd natural numbers.\"}]"}
{"text":"The smallest odd prime is `3`.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"The only prime factor of prime `p` is `p` itself. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {p q : ℕ}, Nat.Prime p → (Nat.factorization p) q ≠ 0 → p = q\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The square of the smallest prime factor of a composite number `n` is at most `n`.\\n\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n : ℕ}, 0 < n → ¬Nat.Prime n → Nat.minFac n ^ 2 ≤ n\"},\n {\"role\": \"user\", \"content\": \"A minimal polynomial is prime. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\\n  IsIntegral A x → Prime (minpoly A x)\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\", \"content\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"`2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare 2 ↔ p % 8 = 1 ∨ p % 8 = 7)\"},\n {\"role\": \"user\",\n  \"content\": \"A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 2 = 1 ↔ p ≠ 2\"},\n {\"role\": \"user\",\n  \"content\":\n  \"`-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare (-2) ↔ p % 8 = 1 ∨ p % 8 = 3)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (n : ℕ), Nat.factorization n = 0 ↔ n = 0 ∨ n = 1\"},\n {\"role\": \"user\",\n  \"content\": \"A natural number is odd iff it has residue `1` or `3` mod `4`\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n : ℕ}, n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A prime natural number is prime in `ℤ[i]` if and only if it is `3` mod `4` \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)], Prime ↑p ↔ p % 4 = 3\"},\n {\"role\": \"user\", \"content\": \"The smallest odd prime is `3`.\"}]"}
{"text":"There are infinitely many odd prime numbers.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"To prove Fermat's Last Theorem, it suffices to prove it for odd prime exponents.\\n\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"(∀ (p : ℕ), Nat.Prime p → Odd p → FermatLastTheoremFor p) → FermatLastTheorem\"},\n {\"role\": \"user\", \"content\": \"A finite field has prime power cardinality. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : Fintype α] [inst_1 : Field α], IsPrimePow (Fintype.card α)\"},\n {\"role\": \"user\",\n  \"content\": \"A sum of numbers is infinite iff one of them is infinite \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_1} {M : Type u_4} [inst : AddCommMonoid M] {s : Finset ι} {f : ι → WithTop M},\\n  (Finset.sum s fun i => f i) = ⊤ ↔ ∃ i ∈ s, f i = ⊤\"},\n {\"role\": \"user\",\n  \"content\": \"The exponential characteristic is a prime number or one. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (R : Type u) [inst : Semiring R] (q : ℕ) [hq : ExpChar R q], Nat.Prime q ∨ q = 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (n : ℕ), Nat.factorization n = 0 ↔ n = 0 ∨ n = 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For any positive `k : ℕ` there are infinitely many primes `p` such that `p ≡ 1 [MOD k]`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {k : ℕ}, k ≠ 0 → Set.Infinite {p | Nat.Prime p ∧ p ≡ 1 [MOD k]}\"},\n {\"role\": \"user\",\n  \"content\": \"The only divisors of prime powers are prime powers. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [dec_irr : (p : Associates α) → Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid α] [dec : DecidableEq α] [dec' : DecidableEq (Associates α)] {a p : Associates α},\\n  Irreducible p →\\n    ∀ [inst_2 : (n : ℕ) → Decidable (a ∣ p ^ n)] {n : ℕ} (h : a ∣ p ^ n),\\n      a = p ^ Nat.find (_ : ∃ n, (fun n => a ∣ p ^ n) n)\"},\n {\"role\": \"user\", \"content\": \"There is an infinite base \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {M : Matroid α} [self : Matroid.InfiniteRk M], ∃ B, M.Base B ∧ Set.Infinite B\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\", \"content\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\"},\n {\"role\": \"user\", \"content\": \"There are infinitely many odd prime numbers.\"}]"}
{"text":"If a vector space has dimension `2` then it is finite dimensional.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"Two linearly equivalent vector spaces have the same dimension. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : Ring R] {M : Type v} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {M₁ : Type v}\\n  [inst_3 : AddCommGroup M₁] [inst_4 : Module R M₁], (M ≃ₗ[R] M₁) → Module.rank R M = Module.rank R M₁\"},\n {\"role\": \"user\", \"content\": \"A finite-dimensional subspace is complete. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : NontriviallyNormedField 𝕜] [inst_1 : CompleteSpace 𝕜] [inst_2 : AddCommGroup E]\\n  [inst_3 : UniformSpace E] [inst_4 : T2Space E] [inst_5 : UniformAddGroup E] [inst_6 : Module 𝕜 E]\\n  [inst_7 : ContinuousSMul 𝕜 E] (s : Submodule 𝕜 E) [inst_8 : FiniteDimensional 𝕜 ↥s], IsComplete ↑s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A subspace of a finite-dimensional space is also finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K ↥S\"},\n {\"role\": \"user\",\n  \"content\": \"The `vectorSpan` of a finite set is finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (k : Type u_1) {V : Type u_2} {P : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] {s : Set P}, Set.Finite s → FiniteDimensional k ↥(vectorSpan k s)\"},\n {\"role\": \"user\", \"content\": \"A finite-dimensional subspace is closed. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : NontriviallyNormedField 𝕜] [inst_1 : CompleteSpace 𝕜] [inst_2 : AddCommGroup E]\\n  [inst_3 : TopologicalSpace E] [inst_4 : T2Space E] [inst_5 : TopologicalAddGroup E] [inst_6 : Module 𝕜 E]\\n  [inst_7 : ContinuousSMul 𝕜 E] (s : Submodule 𝕜 E) [inst_8 : FiniteDimensional 𝕜 ↥s], IsClosed ↑s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a vector space has a finite dimension, the index set of `Basis.ofVectorSpace` is finite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\\n  Module.rank K V < Cardinal.aleph0 → Set.Finite (Basis.ofVectorSpaceIndex K V)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a vector space has a basis indexed by elements of a finite set, then it is\\nfinite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\\n  {s : Set ι}, Basis (↑s) K V → Set.Finite s → FiniteDimensional K V\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a vector space has a finite basis, then it is finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\\n  [inst_3 : Finite ι], Basis ι K V → FiniteDimensional K V\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a vector space has dimension `2` then it is finite dimensional.\"}]"}
{"text":"Every field is a division ring.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"A subfield is closed under division. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} [inst : Field K] (s : Subfield K) {x y : K}, x ∈ s → y ∈ s → x / y ∈ s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For a semiring to be a field, it must have two distinct elements. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {R : Type u} [inst : Semiring R], IsField R → ∃ x y, x ≠ y\"},\n {\"role\": \"user\",\n  \"content\": \"All ideals in a division (semi)ring are trivial. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} [inst : DivisionSemiring K] (I : Ideal K), I = ⊥ ∨ I = ⊤\"},\n {\"role\": \"user\",\n  \"content\": \"A normed division ring is a topological division ring. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : NormedDivisionRing α], TopologicalDivisionRing α\"},\n {\"role\": \"user\",\n  \"content\": \"Natural division is the floor of field division. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_2} [inst : LinearOrderedSemifield α] [inst_1 : FloorSemiring α] (m n : ℕ), ⌊↑m / ↑n⌋₊ = m / n\"},\n {\"role\": \"user\",\n  \"content\": \"An intermediate field is closed under division. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u_1} {L : Type u_2} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\\n  {x y : L}, x ∈ S → y ∈ S → x / y ∈ S\"},\n {\"role\": \"user\", \"content\": \"An intermediate field contains the ring's 0. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u_1} {L : Type u_2} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\\n  0 ∈ S\"},\n {\"role\": \"user\", \"content\": \"An intermediate field contains the ring's 1. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u_1} {L : Type u_2} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\\n  1 ∈ S\"},\n {\"role\": \"user\", \"content\": \"A field is a valuation ring. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (K : Type u) [inst : Field K], ValuationRing K\"},\n {\"role\": \"user\", \"content\": \"A valued division ring is separated. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u_1} [inst : DivisionRing K] {Γ₀ : Type u_2} [inst_1 : LinearOrderedCommGroupWithZero Γ₀]\\n  [inst_2 : Valued K Γ₀], SeparatedSpace K\"},\n {\"role\": \"user\", \"content\": \"Every field is a division ring.\"}]"}
{"text":"If a space has dimension `2` then it is finite dimensional.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The space of continuous linear maps between finite-dimensional spaces is finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [inst : Field 𝕜] [inst_1 : TopologicalSpace 𝕜] [inst_2 : AddCommGroup E]\\n  [inst_3 : Module 𝕜 E] [inst_4 : TopologicalSpace E] [inst_5 : AddCommGroup F] [inst_6 : Module 𝕜 F]\\n  [inst_7 : TopologicalSpace F] [inst_8 : TopologicalAddGroup F] [inst_9 : ContinuousSMul 𝕜 F]\\n  [inst_10 : FiniteDimensional 𝕜 E] [inst_11 : FiniteDimensional 𝕜 F], FiniteDimensional 𝕜 (E →L[𝕜] F)\"},\n {\"role\": \"user\", \"content\": \"A finite-dimensional subspace is complete. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : NontriviallyNormedField 𝕜] [inst_1 : CompleteSpace 𝕜] [inst_2 : AddCommGroup E]\\n  [inst_3 : UniformSpace E] [inst_4 : T2Space E] [inst_5 : UniformAddGroup E] [inst_6 : Module 𝕜 E]\\n  [inst_7 : ContinuousSMul 𝕜 E] (s : Submodule 𝕜 E) [inst_8 : FiniteDimensional 𝕜 ↥s], IsComplete ↑s\"},\n {\"role\": \"user\", \"content\": \"A compact discrete space is finite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X] [inst : DiscreteTopology X], Finite X\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a linear map has determinant different from `1`, then the space is finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {M : Type u_2} [inst : AddCommGroup M] {𝕜 : Type u_7} [inst_1 : Field 𝕜] [inst_2 : Module 𝕜 M] (f : M →ₗ[𝕜] M),\\n  LinearMap.det f ≠ 1 → FiniteDimensional 𝕜 M\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A quotient of a finite-dimensional space is also finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K (V ⧸ S)\"},\n {\"role\": \"user\", \"content\": \"A finite space is bounded. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_4} [inst : Bornology α] [inst_1 : Finite α], BoundedSpace α\"},\n {\"role\": \"user\", \"content\": \"A finite-dimensional subspace is closed. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : NontriviallyNormedField 𝕜] [inst_1 : CompleteSpace 𝕜] [inst_2 : AddCommGroup E]\\n  [inst_3 : TopologicalSpace E] [inst_4 : T2Space E] [inst_5 : TopologicalAddGroup E] [inst_6 : Module 𝕜 E]\\n  [inst_7 : ContinuousSMul 𝕜 E] (s : Submodule 𝕜 E) [inst_8 : FiniteDimensional 𝕜 ↥s], IsClosed ↑s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A subspace of a finite-dimensional space is also finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K ↥S\"},\n {\"role\": \"user\", \"content\": \"All hom spaces are finite dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {k G : Type u} [inst : Field k] [inst_1 : Monoid G] (V W : FdRep k G), FiniteDimensional k (V ⟶ W)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a vector space has a finite basis, then it is finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\\n  [inst_3 : Finite ι], Basis ι K V → FiniteDimensional K V\"},\n {\"role\": \"user\",\n  \"content\": \"If a space has dimension `2` then it is finite dimensional.\"}]"}
{"text":"Every natural number has a successor.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `n : ℕ+` is different from `1`, then it is the successor of some `k : ℕ+`. \"},\n {\"role\": \"assistant\", \"content\": \"∀ {n : ℕ+}, n ≠ 1 → ∃ k, n = k + 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The canonical map from ℕ to a graded semiring respects successors.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_1} {A : ι → Type u_2} [inst : AddMonoid ι] [inst_1 : (i : ι) → AddCommMonoid (A i)]\\n  [self : DirectSum.GSemiring A] (n : ℕ),\\n  DirectSum.GSemiring.natCast (n + 1) = DirectSum.GSemiring.natCast n + GradedMonoid.GOne.one\"},\n {\"role\": \"user\",\n  \"content\": \"A Cauchy sequence on the natural numbers is bounded. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {u : ℕ → α}, CauchySeq u → ∃ R > 0, ∀ (m n : ℕ), dist (u m) (u n) < R\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {m n : ℕ}, (∀ (a : ℕ), a ∣ m ↔ a ∣ n) ↔ m = n\"},\n {\"role\": \"user\", \"content\": \"Every ordinal has a fundamental sequence. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (a : Ordinal.{u}), ∃ f, Ordinal.IsFundamentalSequence a (Cardinal.ord (Ordinal.cof a)) f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {m n : ℕ}, (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n\"},\n {\"role\": \"user\",\n  \"content\": \"Every finite convergent corresponds to a rational number. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K) (n : ℕ),\\n  ∃ q, GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n = ↑q\"},\n {\"role\": \"user\",\n  \"content\":\n  \"This result shows that there always exists a next term in the sequence. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (K : Type u_1) [inst : Field K] [inst_1 : NumberField K] (w₁ : NumberField.InfinitePlace K) {B : ℕ},\\n  NumberField.mixedEmbedding.minkowskiBound K < NumberField.mixedEmbedding.convexBodyLTFactor K * ↑B →\\n    ∀ {x : ↥(NumberField.ringOfIntegers K)},\\n      x ≠ 0 → ∃ y, y ≠ 0 ∧ (∀ (w : NumberField.InfinitePlace K), w ≠ w₁ → w ↑y < w ↑x) ∧ |(Algebra.norm ℚ) ↑y| ≤ ↑B\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\", \"content\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\"},\n {\"role\": \"user\", \"content\": \"Every natural number has a successor.\"}]"}
{"text":"Every natural number is less than its successor.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"A Cauchy sequence on the natural numbers is bounded. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {u : ℕ → α}, CauchySeq u → ∃ R > 0, ∀ (m n : ℕ), dist (u m) (u n) < R\"},\n {\"role\": \"user\", \"content\": \"A finite set is bounded below.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : Preorder α] [inst_1 : IsDirected α fun x x_1 => x ≥ x_1] [inst_2 : Nonempty α] {s : Set α},\\n  Set.Finite s → BddBelow s\"},\n {\"role\": \"user\", \"content\": \"Zero is less than or equal to one. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_2} [inst : Zero α] [inst_1 : One α] [inst_2 : LE α] [self : ZeroLEOneClass α], 0 ≤ 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a small natural number is divisible by a larger natural number,\\nthe small number is zero. \"},\n {\"role\": \"assistant\", \"content\": \"∀ {a b : ℕ}, a ∣ b → b < a → b = 0\"},\n {\"role\": \"user\",\n  \"content\": \"Natural division is always less than division in the field. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : LinearOrderedSemifield α] {m n : ℕ}, ↑(m / n) ≤ ↑m / ↑n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The digits in the base b+2 expansion of n are all less than b+2 \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {b m d : ℕ}, d ∈ Nat.digits (b + 2) m → d < b + 2\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The digits in the base b expansion of n are all less than b, if b ≥ 2 \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {b m d : ℕ}, 1 < b → d ∈ Nat.digits b m → d < b\"},\n {\"role\": \"user\", \"content\": \"Any element is less than the top one. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u_9} [self : CompleteLattice α] (x : α), x ≤ ⊤\"},\n {\"role\": \"user\", \"content\": \"Any lower bound is less than the set infimum. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_9} [self : CompleteSemilatticeInf α] (s : Set α) (a : α), (∀ b ∈ s, a ≤ b) → a ≤ sInf s\"},\n {\"role\": \"user\",\n  \"content\": \"Any element of a set is less than the set supremum. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_9} [self : CompleteSemilatticeSup α] (s : Set α), ∀ a ∈ s, a ≤ sSup s\"},\n {\"role\": \"user\",\n  \"content\": \"Every natural number is less than its successor.\"}]"}
{"text":"Every set is Lebesgue measurable.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The set of points for which a measurable sequence of functions converges is measurable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_2} {γ : Type u_3} {β : Type u_4} [inst : MeasurableSpace β] [inst_1 : TopologicalSpace γ]\\n  [inst_2 : PolishSpace γ] [inst_3 : MeasurableSpace γ] [hγ : OpensMeasurableSpace γ] [inst_4 : Countable ι]\\n  {l : Filter ι} [inst_5 : Filter.IsCountablyGenerated l] {f : ι → β → γ},\\n  (∀ (i : ι), Measurable (f i)) → MeasurableSet {x | ∃ c, Filter.Tendsto (fun n => f n x) l (nhds c)}\"},\n {\"role\": \"user\",\n  \"content\": \"The graph of a measurable function is a measurable set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : MeasurableSpace α] {f : α → ℝ}, Measurable f → MeasurableSet {p | p.2 = f p.1}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a set is a right-neighborhood of all of its points, then it is measurable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α]\\n  [inst_3 : LinearOrder α] [inst_4 : OrderTopology α] [inst_5 : SecondCountableTopology α] {s : Set α},\\n  (∀ x ∈ s, s ∈ nhdsWithin x (Set.Ioi x)) → MeasurableSet s\"},\n {\"role\": \"user\",\n  \"content\": \"In a `BorelSpace` all open sets are measurable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_6} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α],\\n  OpensMeasurableSpace α\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For every set there exists a measurable superset of the same measure. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : MeasurableSpace α] (μ : MeasureTheory.Measure α) (s : Set α),\\n  ∃ t, s ⊆ t ∧ MeasurableSet t ∧ ↑↑μ t = ↑↑μ s\"},\n {\"role\": \"user\",\n  \"content\": \"The set of Liouville numbers has Lebesgue measure zero. \"},\n {\"role\": \"assistant\",\n  \"content\": \"↑↑MeasureTheory.volume {x | Liouville x} = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For the outer measure coming from a content, all Borel sets are measurable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type w} [inst : TopologicalSpace G] (μ : MeasureTheory.Content G) [inst_1 : T2Space G] [S : MeasurableSpace G]\\n  [inst_2 : BorelSpace G], S ≤ MeasureTheory.OuterMeasure.caratheodory (MeasureTheory.Content.outerMeasure μ)\"},\n {\"role\": \"user\", \"content\": \"Borel-measurable sets are measurable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_6} [inst : TopologicalSpace α] [h : MeasurableSpace α] [self : OpensMeasurableSpace α], borel α ≤ h\"},\n {\"role\": \"user\",\n  \"content\": \"The measurable sets are exactly the Borel-measurable sets. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_6} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [self : BorelSpace α], inst_1 = borel α\"},\n {\"role\": \"user\", \"content\": \"Every set is Lebesgue measurable.\"}]"}
{"text":"Every set of Borel measure zero is Lebesgue measurable.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Left invariant Borel measures on an additive measurable group are unique (up to a scalar). \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : AddGroup G] [inst_2 : MeasurableAdd₂ G]\\n  (μ ν : MeasureTheory.Measure G) [inst_3 : MeasureTheory.SigmaFinite ν] [inst_4 : MeasureTheory.SigmaFinite μ]\\n  {s : Set G} [inst_5 : MeasurableNeg G] [inst_6 : MeasureTheory.Measure.IsAddLeftInvariant μ]\\n  [inst_7 : MeasureTheory.Measure.IsAddLeftInvariant ν],\\n  MeasurableSet s → ↑↑ν s ≠ 0 → ↑↑ν s ≠ ⊤ → μ = (↑↑μ s / ↑↑ν s) • ν\"},\n {\"role\": \"user\",\n  \"content\": \"In a `BorelSpace` all open sets are measurable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_6} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α],\\n  OpensMeasurableSpace α\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Left invariant Borel measures on a measurable group are unique (up to a scalar). \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Group G] [inst_2 : MeasurableMul₂ G]\\n  (μ ν : MeasureTheory.Measure G) [inst_3 : MeasureTheory.SigmaFinite ν] [inst_4 : MeasureTheory.SigmaFinite μ]\\n  {s : Set G} [inst_5 : MeasurableInv G] [inst_6 : MeasureTheory.Measure.IsMulLeftInvariant μ]\\n  [inst_7 : MeasureTheory.Measure.IsMulLeftInvariant ν],\\n  MeasurableSet s → ↑↑ν s ≠ 0 → ↑↑ν s ≠ ⊤ → μ = (↑↑μ s / ↑↑ν s) • ν\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For the outer measure coming from a content, all Borel sets are measurable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type w} [inst : TopologicalSpace G] (μ : MeasureTheory.Content G) [inst_1 : T2Space G] [S : MeasurableSpace G]\\n  [inst_2 : BorelSpace G], S ≤ MeasureTheory.OuterMeasure.caratheodory (MeasureTheory.Content.outerMeasure μ)\"},\n {\"role\": \"user\", \"content\": \"Borel-measurable sets are measurable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_6} [inst : TopologicalSpace α] [h : MeasurableSpace α] [self : OpensMeasurableSpace α], borel α ≤ h\"},\n {\"role\": \"user\",\n  \"content\": \"The measurable sets are exactly the Borel-measurable sets. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_6} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [self : BorelSpace α], inst_1 = borel α\"},\n {\"role\": \"user\",\n  \"content\": \"The set of Liouville numbers has Lebesgue measure zero. \"},\n {\"role\": \"assistant\",\n  \"content\": \"↑↑MeasureTheory.volume {x | Liouville x} = 0\"},\n {\"role\": \"user\",\n  \"content\": \"Every set of Borel measure zero is Lebesgue measurable.\"}]"}
{"text":"No prime number is a perfect square.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The square of the smallest prime factor of a composite number `n` is at most `n`.\\n\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n : ℕ}, 0 < n → ¬Nat.Prime n → Nat.minFac n ^ 2 ≤ n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The real square root is at most the natural square root plus one \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {a : ℕ}, Real.sqrt ↑a ≤ ↑(Nat.sqrt a) + 1\"},\n {\"role\": \"user\",\n  \"content\": \"The only divisors of prime powers are prime powers. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [dec_irr : (p : Associates α) → Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid α] [dec : DecidableEq α] [dec' : DecidableEq (Associates α)] {a p : Associates α},\\n  Irreducible p →\\n    ∀ [inst_2 : (n : ℕ) → Decidable (a ∣ p ^ n)] {n : ℕ} (h : a ∣ p ^ n),\\n      a = p ^ Nat.find (_ : ∃ n, (fun n => a ∣ p ^ n) n)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 ≠ 3`. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {p n : ℕ}, Nat.Prime p → p ∣ n → IsSquare (-1) → p % 4 ≠ 3\"},\n {\"role\": \"user\", \"content\": \"No zero divisors. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_2} [self : CanonicallyOrderedCommSemiring α] {a b : α}, a * b = 0 → a = 0 ∨ b = 0\"},\n {\"role\": \"user\", \"content\": \"The prime ideal is not the entire ring. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : Semiring α] {I : Ideal α} [self : Ideal.IsPrime I], I ≠ ⊤\"},\n {\"role\": \"user\", \"content\": \"`2` is not a factor of an odd natural number. \"},\n {\"role\": \"assistant\", \"content\": \"∀ {m n : ℕ}, Odd n → m ∣ n → m ≠ 2\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\", \"content\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a finite field of odd characteristic, not every element is a square. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {F : Type u_3} [inst : Field F] [inst_1 : Finite F], ringChar F ≠ 2 → ∃ a, ¬IsSquare a\"},\n {\"role\": \"user\",\n  \"content\": \"There are no perfect squares strictly between m² and (m+1)² \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {n m : ℕ}, m * m < n → n < (m + 1) * (m + 1) → ¬∃ t, t * t = n\"},\n {\"role\": \"user\", \"content\": \"No prime number is a perfect square.\"}]"}
{"text":"Every odd prime number is greater than `2`.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A prime natural number is prime in `ℤ[i]` if and only if it is `3` mod `4` \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)], Prime ↑p ↔ p % 4 = 3\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `1 < p`, then `q p`, the smallest prime factor of `mersenne p`, is more than 2. \"},\n {\"role\": \"assistant\", \"content\": \"∀ (p' : ℕ), 2 < LucasLehmer.q (p' + 2)\"},\n {\"role\": \"user\",\n  \"content\": \"A natural number is odd iff it has residue `1` or `3` mod `4`\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n : ℕ}, n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3\"},\n {\"role\": \"user\",\n  \"content\": \"The only divisors of prime powers are prime powers. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [dec_irr : (p : Associates α) → Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid α] [dec : DecidableEq α] [dec' : DecidableEq (Associates α)] {a p : Associates α},\\n  Irreducible p →\\n    ∀ [inst_2 : (n : ℕ) → Decidable (a ∣ p ^ n)] {n : ℕ} (h : a ∣ p ^ n),\\n      a = p ^ Nat.find (_ : ∃ n, (fun n => a ∣ p ^ n) n)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (n : ℕ), Nat.factorization n = 0 ↔ n = 0 ∨ n = 1\"},\n {\"role\": \"user\",\n  \"content\": \"A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 2 = 1 ↔ p ≠ 2\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\", \"content\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\"},\n {\"role\": \"user\", \"content\": \"`2` is not a factor of an odd natural number. \"},\n {\"role\": \"assistant\", \"content\": \"∀ {m n : ℕ}, Odd n → m ∣ n → m ≠ 2\"},\n {\"role\": \"user\", \"content\": \"Every odd prime number is greater than `2`.\"}]"}
{"text":"The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Pythagorean theorem, if-and-if vector inner product form using square roots. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {F : Type u_3} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] {x y : F},\\n  ‖x + y‖ = Real.sqrt (‖x‖ * ‖x‖ + ‖y‖ * ‖y‖) ↔ inner x y = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {m n : ℕ}, (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n\"},\n {\"role\": \"user\",\n  \"content\": \"Expressing the product of two polynomials as a double sum. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : Semiring R] {p q : Polynomial R},\\n  p * q =\\n    Finset.sum (Polynomial.support p) fun i =>\\n      Polynomial.sum q fun j a => (Polynomial.monomial (i + j)) (Polynomial.coeff p i * a)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The product of two Chebyshev polynomials is the sum of two other Chebyshev polynomials. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (R : Type u_1) [inst : CommRing R] (m k : ℕ),\\n  2 * Polynomial.Chebyshev.T R m * Polynomial.Chebyshev.T R (m + k) =\\n    Polynomial.Chebyshev.T R (2 * m + k) + Polynomial.Chebyshev.T R k\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n : ℕ}, IsSquare (-1) → ∃ x y, n = x ^ 2 + y ^ 2\"},\n {\"role\": \"user\", \"content\": \"**Four squares theorem** \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (n : ℕ), ∃ a b c d, a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n\"},\n {\"role\": \"user\", \"content\": \"**Euler's four-square identity**. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : CommRing R] (a b c d x y z w : R),\\n  (a * x - b * y - c * z - d * w) ^ 2 + (a * y + b * x + c * w - d * z) ^ 2 + (a * z - b * w + c * x + d * y) ^ 2 +\\n      (a * w + b * z - c * y + d * x) ^ 2 =\\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"**Euler's four-square identity**, a version for natural numbers. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (a b c d x y z w : ℕ),\\n  Int.natAbs (↑a * ↑x - ↑b * ↑y - ↑c * ↑z - ↑d * ↑w) ^ 2 + Int.natAbs (↑a * ↑y + ↑b * ↑x + ↑c * ↑w - ↑d * ↑z) ^ 2 +\\n        Int.natAbs (↑a * ↑z - ↑b * ↑w + ↑c * ↑x + ↑d * ↑y) ^ 2 +\\n      Int.natAbs (↑a * ↑w + ↑b * ↑z - ↑c * ↑y + ↑d * ↑x) ^ 2 =\\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2)\"},\n {\"role\": \"user\",\n  \"content\": \"The sum of two squares is zero iff both elements are zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : LinearOrderedRing α] {x y : α}, x * x + y * y = 0 ↔ x = 0 ∧ y = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares.\"}]"}
{"text":"Every compact topological space is locally compact.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A topological group which is weakly locally compact is automatically locally compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type w} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G]\\n  [inst_3 : WeaklyLocallyCompactSpace G], LocallyCompactSpace G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a point in a topological group has a compact neighborhood, then the group is\\nlocally compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type w} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] {K : Set G},\\n  IsCompact K → ∀ {x : G}, K ∈ nhds x → LocallyCompactSpace G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every point of a weakly locally compact space admits a compact neighborhood. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u_4} [inst : TopologicalSpace X] [self : WeaklyLocallyCompactSpace X] (x : X), ∃ s, IsCompact s ∧ s ∈ nhds x\"},\n {\"role\": \"user\",\n  \"content\": \"A weakly locally compact Hausdorff space is locally compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : WeaklyLocallyCompactSpace X] [inst_2 : T2Space X],\\n  LocallyCompactSpace X\"},\n {\"role\": \"user\", \"content\": \"The underlying topological space is compact.\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (self : CompHaus), CompactSpace ↑self.toTop\"},\n {\"role\": \"user\", \"content\": \"Finite topological spaces are compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : Finite X], CompactSpace X\"},\n {\"role\": \"user\",\n  \"content\": \"Every compact topological space is locally compact.\"}]"}
{"text":"Every continuous function is uniformly continuous.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"A Lipschitz function is uniformly continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : PseudoEMetricSpace α] [inst_1 : PseudoEMetricSpace β] {K : NNReal} {f : α → β},\\n  LipschitzWith K f → UniformContinuous f\"},\n {\"role\": \"user\",\n  \"content\": \"Each function of an equicontinuous family is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_1} {X : Type u_3} {α : Type u_6} [inst : TopologicalSpace X] [inst_1 : UniformSpace α] {F : ι → X → α},\\n  Equicontinuous F → ∀ (i : ι), Continuous (F i)\"},\n {\"role\": \"user\", \"content\": \"Uniform continuity of the function \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_4} {β : Type u_5} [inst : UniformSpace α] [inst_1 : UniformSpace β] (self : α ≃ᵤ β),\\n  UniformContinuous self.toFun\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A constant sequence of functions is uniformly integrable in the probability sense. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {β : Type u_2} {ι : Type u_3} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α}\\n  [inst : NormedAddCommGroup β] {p : ENNReal} {g : α → β},\\n  1 ≤ p → p ≠ ⊤ → MeasureTheory.Memℒp g p → MeasureTheory.UniformIntegrable (fun x => g) p μ\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A function which can be locally uniformly approximated by continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} [inst_1 : TopologicalSpace α],\\n  (∀ (x : α), ∀ u ∈ uniformity β, ∃ t ∈ nhds x, ∃ F, ContinuousAt F x ∧ ∀ y ∈ t, (f y, F y) ∈ u) → Continuous f\"},\n {\"role\": \"user\",\n  \"content\": \"A locally uniform limit of continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\\n  [inst_1 : TopologicalSpace α],\\n  TendstoLocallyUniformly F f p → (∀ᶠ (n : ι) in p, Continuous (F n)) → ∀ [inst_2 : Filter.NeBot p], Continuous f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A function which can be uniformly approximated by continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} [inst_1 : TopologicalSpace α],\\n  (∀ u ∈ uniformity β, ∃ F, Continuous F ∧ ∀ (y : α), (f y, F y) ∈ u) → Continuous f\"},\n {\"role\": \"user\", \"content\": \"A constant function is uniformly integrable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {β : Type u_2} {ι : Type u_3} {m : MeasurableSpace α} (μ : MeasureTheory.Measure α)\\n  [inst : NormedAddCommGroup β] {p : ENNReal} {g : α → β},\\n  1 ≤ p → p ≠ ⊤ → MeasureTheory.Memℒp g p → MeasureTheory.UnifIntegrable (fun x => g) p μ\"},\n {\"role\": \"user\",\n  \"content\": \"A uniform limit of continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\\n  [inst_1 : TopologicalSpace α],\\n  TendstoUniformly F f p → (∀ᶠ (n : ι) in p, Continuous (F n)) → ∀ [inst_2 : Filter.NeBot p], Continuous f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Each function of a uniformly equicontinuous family is uniformly continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_1} {α : Type u_6} {β : Type u_7} [inst : UniformSpace α] [inst_1 : UniformSpace β] {F : ι → β → α},\\n  UniformEquicontinuous F → ∀ (i : ι), UniformContinuous (F i)\"},\n {\"role\": \"user\",\n  \"content\": \"Every continuous function is uniformly continuous.\"}]"}
{"text":"`6` is not the sum of two distinct prime numbers.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"`cyclotomic' n R` is different from `0`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (n : ℕ) (R : Type u_2) [inst : CommRing R] [inst_1 : IsDomain R], Polynomial.cyclotomic' n R ≠ 0\"},\n {\"role\": \"user\",\n  \"content\": \"Harmonic series is not unconditionally summable. \"},\n {\"role\": \"assistant\", \"content\": \"¬Summable fun n => 1 / ↑n\"},\n {\"role\": \"user\", \"content\": \"`cyclotomic n R` is different from `0`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (n : ℕ) (R : Type u_1) [inst : Ring R] [inst_1 : Nontrivial R], Polynomial.cyclotomic n R ≠ 0\"},\n {\"role\": \"user\",\n  \"content\": \"The ring of integers of a number field is not a field. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (K : Type u_1) [inst : Field K] [nf : NumberField K], ¬IsField ↥(NumberField.ringOfIntegers K)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 ≠ 3`. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {p n : ℕ}, Nat.Prime p → p ∣ n → IsSquare (-1) → p % 4 ≠ 3\"},\n {\"role\": \"user\", \"content\": \"A minimal polynomial is not `1`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (A : Type u_1) {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B)\\n  [inst_3 : Nontrivial B], minpoly A x ≠ 1\"},\n {\"role\": \"user\",\n  \"content\": \"The n-th harmonic number is not an integer for n ≥ 2. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n : ℕ}, 2 ≤ n → ¬Rat.isInt (harmonic n) = true\"},\n {\"role\": \"user\",\n  \"content\": \"Adjacent letters are not from the same summand. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_1} {M : ι → Type u_2} [inst : (i : ι) → Monoid (M i)] (self : Monoid.CoprodI.Word M),\\n  List.Chain' (fun l l' => l.fst ≠ l'.fst) self.toList\"},\n {\"role\": \"user\", \"content\": \"`2` is not a factor of an odd natural number. \"},\n {\"role\": \"assistant\", \"content\": \"∀ {m n : ℕ}, Odd n → m ∣ n → m ≠ 2\"},\n {\"role\": \"user\",\n  \"content\": \"`6` is not the sum of two distinct prime numbers.\"}]"}
{"text":"No integer is irrational.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If an integer with larger absolute value divides an integer, it is\\nzero. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {a b : ℤ}, a ∣ b → Int.natAbs b < Int.natAbs a → b = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"There is an irrational number `r` between any two reals `x < r < y`. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {x y : ℝ}, x < y → ∃ r, Irrational r ∧ x < r ∧ r < y\"},\n {\"role\": \"user\", \"content\": \"No zero divisors. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_2} [self : CanonicallyOrderedCommSemiring α] {a b : α}, a * b = 0 → a = 0 ∨ b = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every terminating continued fraction corresponds to a rational number. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] {v : K},\\n  GeneralizedContinuedFraction.Terminates (GeneralizedContinuedFraction.of v) → ∃ q, v = ↑q\"},\n {\"role\": \"user\",\n  \"content\": \"The conjugate of the golden ratio is irrational. \"},\n {\"role\": \"assistant\", \"content\": \"Irrational goldenConj\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A rational number has only finitely many good rational approximations. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (ξ : ℚ), Set.Finite {q | |ξ - q| < 1 / ↑q.den ^ 2}\"},\n {\"role\": \"user\",\n  \"content\": \"Nonzero fractional ideals contain a nonzero integer. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : CommRing R] {K : Type u_3} [inst_1 : Field K] [inst_2 : Algebra R K]\\n  [inst_3 : IsFractionRing R K] {I : FractionalIdeal (nonZeroDivisors R) K} [inst_4 : Nontrivial R],\\n  I ≠ 0 → ∃ x, x ≠ 0 ∧ (algebraMap R K) x ∈ I\"},\n {\"role\": \"user\",\n  \"content\": \"Every finite convergent corresponds to a rational number. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K) (n : ℕ),\\n  ∃ q, GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n = ↑q\"},\n {\"role\": \"user\", \"content\": \"A transcendental real number is irrational. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {r : ℝ}, Transcendental ℚ r → Irrational r\"},\n {\"role\": \"user\",\n  \"content\": \"If a rational is not a p-adic integer, it is not an integer. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (p : ℕ) {a : ℚ} [hp : Fact (Nat.Prime p)], 1 < padicNorm p a → ¬Rat.isInt a = true\"},\n {\"role\": \"user\", \"content\": \"No integer is irrational.\"}]"}
{"text":"The identity element in a ring is a unit.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"The identity is a group homomorphism. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u} [inst : Group α], IsGroupHom id\"},\n {\"role\": \"user\", \"content\": \"A ring isomorphism sends one to one. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_4} {S : Type u_5} [inst : NonAssocSemiring R] [inst_1 : NonAssocSemiring S] (f : R ≃+* S), f 1 = 1\"},\n {\"role\": \"user\",\n  \"content\": \"The characteristic of a finite ring cannot be zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (R : Type u_1) [inst : NonAssocRing R] (p : ℕ) [inst : CharP R p] [inst : Finite R], p ≠ 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"An element of a ring multiplied by the additive inverse of one is the element's additive\\ninverse. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : MulOneClass α] [inst_1 : HasDistribNeg α] (a : α), a * -1 = -a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The composition of the unit and the counit is equal to the identity up to unitors. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {B : Type u} [inst : CategoryTheory.Bicategory B] {a b : B} {f : a ⟶ b} {g : b ⟶ a}\\n  (self : CategoryTheory.Bicategory.Adjunction f g),\\n  CategoryTheory.Bicategory.leftZigzag self.unit self.counit =\\n    CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.leftUnitor f).hom\\n      (CategoryTheory.Bicategory.rightUnitor f).inv\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The group of units of a complete normed ring is an open subset of the ring. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R], IsOpen {x | IsUnit x}\"},\n {\"role\": \"user\", \"content\": \"A subring contains the ring's 1. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {R : Type u} [inst : Ring R] (s : Subring R), 1 ∈ s\"},\n {\"role\": \"user\",\n  \"content\": \"The units of a complete normed ring form a Lie group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] {𝕜 : Type u_2} [inst_2 : NontriviallyNormedField 𝕜]\\n  [inst_3 : NormedAlgebra 𝕜 R], LieGroup (modelWithCornersSelf 𝕜 R) Rˣ\"},\n {\"role\": \"user\", \"content\": \"The identity map is a ring homomorphism. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u} [inst : Ring α], IsRingHom id\"},\n {\"role\": \"user\",\n  \"content\": \"The chosen element of the base group itself is the identity \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_1} {G : ι → Type u_2} {H : Type u_3} [inst : (i : ι) → Group (G i)] [inst_1 : Group H]\\n  {φ : (i : ι) → H →* G i} (self : Monoid.PushoutI.NormalWord.Transversal φ) (i : ι),\\n  1 ∈ Monoid.PushoutI.NormalWord.Transversal.set self i\"},\n {\"role\": \"user\", \"content\": \"The identity element in a ring is a unit.\"}]"}
{"text":"Every subgroup of a group is a group.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"A subgroup is either the trivial subgroup or nontrivial. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), H = ⊥ ∨ Nontrivial ↥H\"},\n {\"role\": \"user\",\n  \"content\": \"Two subgroups are equal if they have the same elements. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] {H K : Subgroup G}, (∀ (x : G), x ∈ H ↔ x ∈ K) → H = K\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A subgroup is finitely generated if and only if it is finitely generated as a submonoid. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_3} [inst : Group G] (P : Subgroup G), Subgroup.FG P ↔ Submonoid.FG P.toSubmonoid\"},\n {\"role\": \"user\", \"content\": \"A subgroup is closed under inverse. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x : G}, x ∈ H → x⁻¹ ∈ H\"},\n {\"role\": \"user\",\n  \"content\": \"Subgroups of torsion groups are torsion groups. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G → ∀ (H : Subgroup G), Monoid.IsTorsion ↥H\"},\n {\"role\": \"user\", \"content\": \"A subgroup contains the group's 1. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), 1 ∈ H\"},\n {\"role\": \"user\",\n  \"content\": \"The subgroup generated by a set includes the set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] {k : Set G}, k ⊆ ↑(Subgroup.closure k)\"},\n {\"role\": \"user\", \"content\": \"A subgroup is closed under division. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {M : Type u_5} {S : Type u_6} [inst : DivInvMonoid M] [inst_1 : SetLike S M] [hSM : SubgroupClass S M] {H : S}\\n  {x y : M}, x ∈ H → y ∈ H → x / y ∈ H\"},\n {\"role\": \"user\", \"content\": \"A subgroup is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x ∈ H → y ∈ H → x * y ∈ H\"},\n {\"role\": \"user\", \"content\": \"Every subgroup of a group is a group.\"}]"}
{"text":"The sum of two natural numbers is a natural number.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The sum of ordinals as games corresponds to natural addition of ordinals. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (a b : Ordinal.{u}), Ordinal.toPGame a + Ordinal.toPGame b ≈ Ordinal.toPGame (Ordinal.nadd a b)\"},\n {\"role\": \"user\", \"content\": \"The sum of two `C^n`functions is `C^n`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type uE} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {n : ℕ∞}\\n  {f g : E → F}, ContDiff 𝕜 n f → ContDiff 𝕜 n g → ContDiff 𝕜 n fun x => f x + g x\"},\n {\"role\": \"user\",\n  \"content\": \"A sum of numbers is infinite iff one of them is infinite \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_1} {M : Type u_4} [inst : AddCommMonoid M] {s : Finset ι} {f : ι → WithTop M},\\n  (Finset.sum s fun i => f i) = ⊤ ↔ ∃ i ∈ s, f i = ⊤\"},\n {\"role\": \"user\",\n  \"content\": \"Pre-games defined by natural numbers are numeric. \"},\n {\"role\": \"assistant\", \"content\": \"∀ (n : ℕ), SetTheory.PGame.Numeric ↑n\"},\n {\"role\": \"user\",\n  \"content\": \"The sum of two finite adèles is a finite adèle. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} {K : Type u_2} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\\n  [inst_3 : Field K] [inst_4 : Algebra R K] [inst_5 : IsFractionRing R K]\\n  {x y : DedekindDomain.ProdAdicCompletions R K},\\n  DedekindDomain.ProdAdicCompletions.IsFiniteAdele x →\\n    DedekindDomain.ProdAdicCompletions.IsFiniteAdele y → DedekindDomain.ProdAdicCompletions.IsFiniteAdele (x + y)\"},\n {\"role\": \"user\", \"content\": \"A sum of finite numbers is still finite \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {s : Finset α} {f : α → ENNReal}, (∀ a ∈ s, f a ≠ ⊤) → (Finset.sum s fun a => f a) < ⊤\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {m n : ℕ}, (∀ (a : ℕ), a ∣ m ↔ a ∣ n) ↔ m = n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {m n : ℕ}, (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n\"},\n {\"role\": \"user\",\n  \"content\": \"The sum of two natural numbers is a natural number.\"}]"}
{"text":"The identity element of a group has finite order.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is simple. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleGroup α\"},\n {\"role\": \"user\",\n  \"content\": \"The chosen element of the base group itself is the identity \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_1} {G : ι → Type u_2} {H : Type u_3} [inst : (i : ι) → Group (G i)] [inst_1 : Group H]\\n  {φ : (i : ι) → H →* G i} (self : Monoid.PushoutI.NormalWord.Transversal φ) (i : ι),\\n  1 ∈ Monoid.PushoutI.NormalWord.Transversal.set self i\"},\n {\"role\": \"user\",\n  \"content\": \"Elements of finite order are closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : CommMonoid G] {x y : G}, IsOfFinOrder x → IsOfFinOrder y → IsOfFinOrder (x * y)\"},\n {\"role\": \"user\", \"content\": \"The identity is a group homomorphism. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u} [inst : Group α], IsGroupHom id\"},\n {\"role\": \"user\",\n  \"content\": \"Elements of finite order are of finite order in submonoids.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : AddMonoid G] {H : AddSubmonoid G} {x : ↥H}, IsOfFinAddOrder ↑x ↔ IsOfFinAddOrder x\"},\n {\"role\": \"user\",\n  \"content\": \"Inverses of elements of finite order have finite order. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x⁻¹ ↔ IsOfFinOrder x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The image of an element of finite additive order has finite additive order.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} {H : Type u_2} [inst : AddMonoid G] [inst_1 : AddMonoid H] (f : G →+ H) {x : G},\\n  IsOfFinAddOrder x → IsOfFinAddOrder (f x)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A group element has finite additive order iff its order is positive.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : AddMonoid G] {x : G}, 0 < addOrderOf x ↔ IsOfFinAddOrder x\"},\n {\"role\": \"user\",\n  \"content\": \"The image of an element of finite order has finite order. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} {H : Type u_2} [inst : Monoid G] [inst_1 : Monoid H] (f : G →* H) {x : G},\\n  IsOfFinOrder x → IsOfFinOrder (f x)\"},\n {\"role\": \"user\",\n  \"content\": \"A group element has finite order iff its order is positive. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x ↔ IsOfFinOrder x\"},\n {\"role\": \"user\",\n  \"content\": \"The identity element of a group has finite order.\"}]"}
{"text":"`7` is a prime number.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"`ζ - 1` is prime if `ζ` is a primitive `p ^ (k + 1)`-th root of unity. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ+} {k : ℕ} {K : Type u} [inst : Field K] [inst_1 : CharZero K] {ζ : K} [hp : Fact (Nat.Prime ↑p)]\\n  [inst_2 : IsCyclotomicExtension {p ^ (k + 1)} ℚ K] (hζ : IsPrimitiveRoot ζ ↑(p ^ (k + 1))),\\n  Prime (IsPrimitiveRoot.toInteger hζ - 1)\"},\n {\"role\": \"user\", \"content\": \"A minimal polynomial is prime. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\\n  IsIntegral A x → Prime (minpoly A x)\"},\n {\"role\": \"user\",\n  \"content\": \"The only prime factor of prime `p` is `p` itself. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {p q : ℕ}, Nat.Prime p → (Nat.factorization p) q ≠ 0 → p = q\"},\n {\"role\": \"user\",\n  \"content\": \"The only divisors of prime powers are prime powers. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [dec_irr : (p : Associates α) → Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid α] [dec : DecidableEq α] [dec' : DecidableEq (Associates α)] {a p : Associates α},\\n  Irreducible p →\\n    ∀ [inst_2 : (n : ℕ) → Decidable (a ∣ p ^ n)] {n : ℕ} (h : a ∣ p ^ n),\\n      a = p ^ Nat.find (_ : ∃ n, (fun n => a ∣ p ^ n) n)\"},\n {\"role\": \"user\",\n  \"content\": \"`ζ - 1` is prime if `ζ` is a primitive `p`-th root of unity. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ+} {K : Type u} [inst : Field K] [inst_1 : CharZero K] {ζ : K} [hp : Fact (Nat.Prime ↑p)]\\n  [h : IsCyclotomicExtension {p} ℚ K] (hζ : IsPrimitiveRoot ζ ↑p), Prime (IsPrimitiveRoot.toInteger hζ - 1)\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\", \"content\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\"},\n {\"role\": \"user\",\n  \"content\": \"The exponential characteristic is a prime number or one. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (R : Type u) [inst : Semiring R] (q : ℕ) [hq : ExpChar R q], Nat.Prime q ∨ q = 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (n : ℕ), Nat.factorization n = 0 ↔ n = 0 ∨ n = 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"`2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare 2 ↔ p % 8 = 1 ∨ p % 8 = 7)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A prime natural number is prime in `ℤ[i]` if and only if it is `3` mod `4` \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)], Prime ↑p ↔ p % 4 = 3\"},\n {\"role\": \"user\", \"content\": \"`7` is a prime number.\"}]"}
{"text":"There are `3` prime numbers below `8`.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"`2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare 2 ↔ p % 8 = 1 ∨ p % 8 = 7)\"},\n {\"role\": \"user\", \"content\": \"The factors of `n` are the prime divisors \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (n : ℕ), List.toFinset (Nat.factors n) = Finset.filter Nat.Prime (Nat.divisors n)\"},\n {\"role\": \"user\",\n  \"content\": \"The only divisors of prime powers are prime powers. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [dec_irr : (p : Associates α) → Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid α] [dec : DecidableEq α] [dec' : DecidableEq (Associates α)] {a p : Associates α},\\n  Irreducible p →\\n    ∀ [inst_2 : (n : ℕ) → Decidable (a ∣ p ^ n)] {n : ℕ} (h : a ∣ p ^ n),\\n      a = p ^ Nat.find (_ : ∃ n, (fun n => a ∣ p ^ n) n)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The square of the smallest prime factor of a composite number `n` is at most `n`.\\n\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n : ℕ}, 0 < n → ¬Nat.Prime n → Nat.minFac n ^ 2 ≤ n\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\", \"content\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"`-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare (-2) ↔ p % 8 = 1 ∨ p % 8 = 3)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The product of the prime factors of `n` that are less than `N` is an `N`-smooth number. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (n N : ℕ), List.prod (List.filter (fun x => decide (x < N)) (Nat.factors n)) ∈ Nat.smoothNumbers N\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A prime natural number is prime in `ℤ[i]` if and only if it is `3` mod `4` \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)], Prime ↑p ↔ p % 4 = 3\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (n : ℕ), Nat.factorization n = 0 ↔ n = 0 ∨ n = 1\"},\n {\"role\": \"user\", \"content\": \"There are `3` prime numbers below `8`.\"}]"}
{"text":"The empty set is contained in every finite set.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"The shadow of the empty set is empty. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u_1} [inst : DecidableEq α], Finset.shadow ∅ = ∅\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In an infinite graph, the set of components out of a finite set is nonempty. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {V : Type u} (G : SimpleGraph V) [inst : Infinite V] (K : Finset V), Nonempty (SimpleGraph.ComponentCompl G ↑K)\"},\n {\"role\": \"user\",\n  \"content\": \"Uniform convergence on the empty set is vacuously true \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι},\\n  TendstoUniformlyOn F f p ∅\"},\n {\"role\": \"user\",\n  \"content\": \"There are finitely many subsets of a given finite set \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {a : Set α}, Set.Finite a → Set.Finite {b | b ⊆ a}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every finite subset of a linearly independent set is linearly independent. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_2} {M : Type u_4} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (s : Set M),\\n  LinearIndependent (ι := { x // x ∈ s }) R Subtype.val → ∀ (t : Finset ↑s), LinearIndependent R Subtype.val\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any uncountable closed set in a second countable space contains a nonempty perfect subset.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] {C : Set α} [inst_1 : SecondCountableTopology α],\\n  IsClosed C → ¬Set.Countable C → ∃ D, Perfect D ∧ Set.Nonempty D ∧ D ⊆ C\"},\n {\"role\": \"user\", \"content\": \"A finite union of finsets is finite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} (f : α → Finset β), Set.Finite (Set.range f) → Set.Finite (⋃ a, ↑(f a))\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every finite subset of an algebraically independent set is algebraically independent. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_3} {A : Type u_5} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] (s : Set A),\\n  AlgebraicIndependent R Subtype.val → ∀ (t : Finset ↑s), AlgebraicIndependent R Subtype.val\"},\n {\"role\": \"user\", \"content\": \"The empty set is concyclic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : NormedSpace ℝ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P], EuclideanGeometry.Concyclic ∅\"},\n {\"role\": \"user\",\n  \"content\": \"The set of finite subsets of a countable set is countable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {s : Set α}, Set.Countable s → Set.Countable {t | Set.Finite t ∧ t ⊆ s}\"},\n {\"role\": \"user\", \"content\": \"The empty set is contained in every finite set.\"}]"}
{"text":"Every infinite set contains a finite set.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For every open cover of a compact set, there exists a finite subcover. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u} {ι : Type u_1} [inst : TopologicalSpace X] {s : Set X} {b : Set ι} {c : ι → Set X},\\n  IsCompact s → (∀ i ∈ b, IsOpen (c i)) → s ⊆ ⋃ i ∈ b, c i → ∃ b' ⊆ b, Set.Finite b' ∧ s ⊆ ⋃ i ∈ b', c i\"},\n {\"role\": \"user\",\n  \"content\": \"The semilatice generated by a finite set is finite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_2} [inst : SemilatticeSup α] {s : Set α}, Set.Finite s → Set.Finite (supClosure s)\"},\n {\"role\": \"user\", \"content\": \"A finite set is bounded below.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : Preorder α] [inst_1 : IsDirected α fun x x_1 => x ≥ x_1] [inst_2 : Nonempty α] {s : Set α},\\n  Set.Finite s → BddBelow s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every finite subset of an algebraically independent set is algebraically independent. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_3} {A : Type u_5} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] (s : Set A),\\n  AlgebraicIndependent R Subtype.val → ∀ (t : Finset ↑s), AlgebraicIndependent R Subtype.val\"},\n {\"role\": \"user\", \"content\": \"Finite product of finite sets is finite \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {δ : Type u_1} [inst : Finite δ] {κ : δ → Type u_2} {t : (d : δ) → Set (κ d)},\\n  (∀ (d : δ), Set.Finite (t d)) → Set.Finite (Set.pi Set.univ t)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every finite subset of a linearly independent set is linearly independent. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_2} {M : Type u_4} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (s : Set M),\\n  LinearIndependent (ι := { x // x ∈ s }) R Subtype.val → ∀ (t : Finset ↑s), LinearIndependent R Subtype.val\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In an infinite graph, the set of components out of a finite set is nonempty. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {V : Type u} (G : SimpleGraph V) [inst : Infinite V] (K : Finset V), Nonempty (SimpleGraph.ComponentCompl G ↑K)\"},\n {\"role\": \"user\",\n  \"content\": \"There are finitely many subsets of a given finite set \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {a : Set α}, Set.Finite a → Set.Finite {b | b ⊆ a}\"},\n {\"role\": \"user\", \"content\": \"A finite union of finsets is finite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} (f : α → Finset β), Set.Finite (Set.range f) → Set.Finite (⋃ a, ↑(f a))\"},\n {\"role\": \"user\",\n  \"content\": \"The set of finite subsets of a countable set is countable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {s : Set α}, Set.Countable s → Set.Countable {t | Set.Finite t ∧ t ⊆ s}\"},\n {\"role\": \"user\", \"content\": \"Every infinite set contains a finite set.\"}]"}
{"text":"Every commutative ring is a monoid.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"Left multiplication in a ring is an additive monoid morphism. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {γ : Type u_1} [inst : NonUnitalNonAssocSemiring γ] (x : γ), IsAddMonoidHom fun y => x * y\"},\n {\"role\": \"user\",\n  \"content\": \"The category of commutative rings has all limits. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"CategoryTheory.Limits.HasLimitsOfSize.{v, v, max u v, max (u + 1) (v + 1)} CommRingCatMax\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If all prime ideals in a commutative ring are principal, so are all other ideals. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : CommRing R],\\n  (∀ (P : Ideal R), Ideal.IsPrime P → Submodule.IsPrincipal P) → IsPrincipalIdealRing R\"},\n {\"role\": \"user\", \"content\": \"1 is of finite order in any monoid. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder 1\"},\n {\"role\": \"user\",\n  \"content\": \"Composition of monoid homomorphisms is associative. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {M : Type u_3} {N : Type u_4} {P : Type u_5} {Q : Type u_9} [inst : One M] [inst_1 : One N] [inst_2 : One P]\\n  [inst_3 : One Q] (f : OneHom M N) (g : OneHom N P) (h : OneHom P Q),\\n  OneHom.comp (OneHom.comp h g) f = OneHom.comp h (OneHom.comp g f)\"},\n {\"role\": \"user\",\n  \"content\": \"The category of commutative monoids has all limits. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"CategoryTheory.Limits.HasLimitsOfSize.{v, v, max u v, max (u + 1) (v + 1)} CommMonCatMax\"},\n {\"role\": \"user\", \"content\": \"A group homomorphism is a monoid homomorphism. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : Group β] {f : α → β}, IsGroupHom f → IsMonoidHom f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The composite of two monoid homomorphisms is a monoid homomorphism. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : MulOneClass α] [inst_1 : MulOneClass β] {f : α → β},\\n  IsMonoidHom f → ∀ {γ : Type u_1} [inst_2 : MulOneClass γ] {g : β → γ}, IsMonoidHom g → IsMonoidHom (g ∘ f)\"},\n {\"role\": \"user\", \"content\": \"A monoid is a submonoid of itself. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {M : Type u_1} [inst : Monoid M], IsSubmonoid Set.univ\"},\n {\"role\": \"user\",\n  \"content\": \"The center of a monoid acts commutatively on that monoid. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {M : Type u_1} [inst : Monoid M], SMulCommClass M (↥(Submonoid.center M)) M\"},\n {\"role\": \"user\", \"content\": \"Every commutative ring is a monoid.\"}]"}
{"text":"There is no field of order `10`.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"The empty set is nowhere dense. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {X : Type u_4} [inst : TopologicalSpace X], IsNowhereDense ∅\"},\n {\"role\": \"user\", \"content\": \"In a dense order, nothing covers anything. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : LT α] {a b : α} [inst_1 : DenselyOrdered α], ¬a ⋖ b\"},\n {\"role\": \"user\", \"content\": \"The order of the `0` power series is infinite.\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {R : Type u_1} [inst : Semiring R], PowerSeries.order 0 = ⊤\"},\n {\"role\": \"user\", \"content\": \"An intermediate field contains the ring's 0. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u_1} {L : Type u_2} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\\n  0 ∈ S\"},\n {\"role\": \"user\", \"content\": \"No points are in `⊥`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (k : Type u_1) (V : Type u_2) {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [S : AddTorsor V P] (p : P), p ∉ ⊥\"},\n {\"role\": \"user\",\n  \"content\": \"`ℤ` with its usual ring structure is not a field. \"},\n {\"role\": \"assistant\", \"content\": \"¬IsField ℤ\"},\n {\"role\": \"user\",\n  \"content\": \"Infinite ordinals that are cardinals are unbounded. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"Set.Unbounded (fun x x_1 => x < x_1) {b | Cardinal.ord (Ordinal.card b) = b ∧ Ordinal.omega ≤ b}\"},\n {\"role\": \"user\", \"content\": \"Fields are commutative. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : Semiring R], IsField R → ∀ (x y : R), x * y = y * x\"},\n {\"role\": \"user\", \"content\": \"Ordinals that are cardinals are unbounded. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"Set.Unbounded (fun x x_1 => x < x_1) {b | Cardinal.ord (Ordinal.card b) = b}\"},\n {\"role\": \"user\",\n  \"content\": \"The ring of integers of a number field is not a field. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (K : Type u_1) [inst : Field K] [nf : NumberField K], ¬IsField ↥(NumberField.ringOfIntegers K)\"},\n {\"role\": \"user\", \"content\": \"There is no field of order `10`.\"}]"}
{"text":"Every odd natural number is the sum of two distinct natural numbers.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"A natural number is odd iff it has residue `1` or `3` mod `4`\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n : ℕ}, n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3\"},\n {\"role\": \"user\", \"content\": \"A sum of finite numbers is still finite \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {s : Finset α} {f : α → ENNReal}, (∀ a ∈ s, f a ≠ ⊤) → (Finset.sum s fun a => f a) < ⊤\"},\n {\"role\": \"user\",\n  \"content\": \"Every finite convergent corresponds to a rational number. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K) (n : ℕ),\\n  ∃ q, GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n = ↑q\"},\n {\"role\": \"user\",\n  \"content\": \"The sum of two finite adèles is a finite adèle. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} {K : Type u_2} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\\n  [inst_3 : Field K] [inst_4 : Algebra R K] [inst_5 : IsFractionRing R K]\\n  {x y : DedekindDomain.ProdAdicCompletions R K},\\n  DedekindDomain.ProdAdicCompletions.IsFiniteAdele x →\\n    DedekindDomain.ProdAdicCompletions.IsFiniteAdele y → DedekindDomain.ProdAdicCompletions.IsFiniteAdele (x + y)\"},\n {\"role\": \"user\", \"content\": \"`2` is not a factor of an odd natural number. \"},\n {\"role\": \"assistant\", \"content\": \"∀ {m n : ℕ}, Odd n → m ∣ n → m ≠ 2\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\", \"content\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {m n : ℕ}, (∀ (a : ℕ), a ∣ m ↔ a ∣ n) ↔ m = n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {m n : ℕ}, (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every odd natural number is the sum of two distinct natural numbers.\"}]"}
{"text":"Every element in the trivial group has finite order.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A group element has finite additive order iff its order is positive.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : AddMonoid G] {x : G}, 0 < addOrderOf x ↔ IsOfFinAddOrder x\"},\n {\"role\": \"user\",\n  \"content\": \"Elements of finite order are of finite order in submonoids.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : AddMonoid G] {H : AddSubmonoid G} {x : ↥H}, IsOfFinAddOrder ↑x ↔ IsOfFinAddOrder x\"},\n {\"role\": \"user\",\n  \"content\": \"Elements of finite order are closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : CommMonoid G] {x y : G}, IsOfFinOrder x → IsOfFinOrder y → IsOfFinOrder (x * y)\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is cyclic.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsAddCyclic α\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is cyclic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α\"},\n {\"role\": \"user\",\n  \"content\": \"The image of an element of finite order has finite order. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} {H : Type u_2} [inst : Monoid G] [inst_1 : Monoid H] (f : G →* H) {x : G},\\n  IsOfFinOrder x → IsOfFinOrder (f x)\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is simple.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleAddGroup α\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is simple. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleGroup α\"},\n {\"role\": \"user\",\n  \"content\": \"A group element has finite order iff its order is positive. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x ↔ IsOfFinOrder x\"},\n {\"role\": \"user\",\n  \"content\": \"Inverses of elements of finite order have finite order. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x⁻¹ ↔ IsOfFinOrder x\"},\n {\"role\": \"user\",\n  \"content\": \"Every element in the trivial group has finite order.\"}]"}
{"text":"The square of an even number is even.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"`2` is a square in `F` iff `#F` is not congruent to `3` or `5` mod `8`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F], IsSquare 2 ↔ Fintype.card F % 8 ≠ 3 ∧ Fintype.card F % 8 ≠ 5\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The finite field `F` has even cardinality iff it has characteristic `2`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {F : Type u_3} [inst : Field F] [inst_1 : Fintype F], ringChar F = 2 ↔ Fintype.card F % 2 = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"`2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare 2 ↔ p % 8 = 1 ∨ p % 8 = 7)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Commutativity of a square is preserved when taking quotients by an ideal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} {S : Type v} [inst : CommRing R] [inst_1 : CommRing S] {R' : Type u_5} {S' : Type u_6}\\n  [inst_2 : CommRing R'] [inst_3 : CommRing S'] {f : R →+* S} {f' : R' →+* S'} {g : R →+* R'} {g' : S →+* S'}\\n  (hfg : RingHom.comp f' g = RingHom.comp g' f) (I : Ideal S'),\\n  let leq := (_ : Ideal.comap f (Ideal.comap g' I) ≤ Ideal.comap g (Ideal.comap f' I));\\n  RingHom.comp (Ideal.quotientMap I g' (_ : Ideal.comap g' I ≤ Ideal.comap g' I))\\n      (Ideal.quotientMap (Ideal.comap g' I) f\\n        (_ : Ideal.comap f (Ideal.comap g' I) ≤ Ideal.comap f (Ideal.comap g' I))) =\\n    RingHom.comp (Ideal.quotientMap I f' (_ : Ideal.comap f' I ≤ Ideal.comap f' I))\\n      (Ideal.quotientMap (Ideal.comap f' I) g leq)\"},\n {\"role\": \"user\", \"content\": \"The square commutes. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {C : Type u_1} [inst : CategoryTheory.Category.{u_2, u_1} C] {W X Y Z : C} {f : W ⟶ X} {g : W ⟶ Y} {h : X ⟶ Z}\\n  {i : Y ⟶ Z},\\n  CategoryTheory.CommSq f g h i → CategoryTheory.CategoryStruct.comp f h = CategoryTheory.CategoryStruct.comp g i\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a finite field of odd characteristic, not every element is a square. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {F : Type u_3} [inst : Field F] [inst_1 : Finite F], ringChar F ≠ 2 → ∃ a, ¬IsSquare a\"},\n {\"role\": \"user\",\n  \"content\": \"The sum of two squares is zero iff both elements are zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : LinearOrderedRing α] {x y : α}, x * x + y * y = 0 ↔ x = 0 ∧ y = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a finite field of characteristic `2`, all elements are squares. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {F : Type u_3} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 → ∀ (a : F), IsSquare a\"},\n {\"role\": \"user\",\n  \"content\": \"The convolution of two even functions is also even. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {𝕜 : Type u𝕜} {G : Type uG} {E : Type uE} {E' : Type uE'} {F : Type uF} [inst : NormedAddCommGroup E]\\n  [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedAddCommGroup F] {f : G → E} {g : G → E'} {x : G}\\n  [inst_3 : NontriviallyNormedField 𝕜] [inst_4 : NormedSpace 𝕜 E] [inst_5 : NormedSpace 𝕜 E'] [inst_6 : NormedSpace 𝕜 F]\\n  (L : E →L[𝕜] E' →L[𝕜] F) [inst_7 : MeasurableSpace G] {μ : MeasureTheory.Measure G} [inst_8 : NormedSpace ℝ F]\\n  [inst_9 : AddCommGroup G] [inst_10 : MeasureTheory.Measure.IsAddLeftInvariant μ]\\n  [inst_11 : MeasureTheory.Measure.IsNegInvariant μ] [inst_12 : MeasurableNeg G] [inst_13 : MeasurableAdd G],\\n  (∀ᵐ (x : G) ∂μ, f (-x) = f x) → (∀ᵐ (x : G) ∂μ, g (-x) = g x) → convolution f g L (-x) = convolution f g L x\"},\n {\"role\": \"user\", \"content\": \"The square of an even number is even.\"}]"}
{"text":"Every commutative division ring is a field.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every nonarchimedean ring is naturally a nonarchimedean additive group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (R : Type u_1) [inst : Ring R] [inst_1 : TopologicalSpace R] [t : NonarchimedeanRing R], NonarchimedeanAddGroup R\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The multivariate polynomial ring over an integral domain is an integral domain. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} {σ : Type v} [inst : CommRing R] [inst_1 : IsDomain R], IsDomain (MvPolynomial σ R)\"},\n {\"role\": \"user\",\n  \"content\": \"An intermediate field is closed under division. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u_1} {L : Type u_2} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\\n  {x y : L}, x ∈ S → y ∈ S → x / y ∈ S\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A cyclotomic finite extension of a number field is a number field. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (S : Set ℕ+) (K : Type w) (L : Type z) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] [h : NumberField K]\\n  [inst_3 : Finite ↑S] [inst : IsCyclotomicExtension S K L], NumberField L\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A field is perfect if every irreducible polynomial is separable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u_1} [inst : Field K] [self : PerfectField K] {f : Polynomial K}, Irreducible f → Polynomial.Separable f\"},\n {\"role\": \"user\", \"content\": \"A field is a valuation ring. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (K : Type u) [inst : Field K], ValuationRing K\"},\n {\"role\": \"user\",\n  \"content\": \"The category of commutative rings has all limits. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"CategoryTheory.Limits.HasLimitsOfSize.{v, v, max u v, max (u + 1) (v + 1)} CommRingCatMax\"},\n {\"role\": \"user\",\n  \"content\": \"An algebraically closed field is also separably closed. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (k : Type u) [inst : Field k] [inst_1 : IsAlgClosed k], IsSepClosed k\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The quotient of a ring by an ideal is a field iff the ideal is maximal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I ↔ IsField (R ⧸ I)\"},\n {\"role\": \"user\", \"content\": \"Fields are commutative. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : Semiring R], IsField R → ∀ (x y : R), x * y = y * x\"},\n {\"role\": \"user\", \"content\": \"Every commutative division ring is a field.\"}]"}
{"text":"The image of the identity element under the identity map is the identity element.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"The identity map preserves addition\"},\n {\"role\": \"assistant\", \"content\": \"∀ {α : Type u} [inst : Add α], IsAddHom id\"},\n {\"role\": \"user\", \"content\": \"The identity is a group homomorphism. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u} [inst : Group α], IsGroupHom id\"},\n {\"role\": \"user\", \"content\": \"The identity is an isometry \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u} [inst : PseudoEMetricSpace α], Isometry id\"},\n {\"role\": \"user\",\n  \"content\": \"The chosen element of the base group itself is the identity \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_1} {G : ι → Type u_2} {H : Type u_3} [inst : (i : ι) → Group (G i)] [inst_1 : Group H]\\n  {φ : (i : ι) → H →* G i} (self : Monoid.PushoutI.NormalWord.Transversal φ) (i : ι),\\n  1 ∈ Monoid.PushoutI.NormalWord.Transversal.set self i\"},\n {\"role\": \"user\", \"content\": \"The identity affine map acts as the identity. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (k : Type u_1) {V1 : Type u_2} (P1 : Type u_3) [inst : Ring k] [inst_1 : AddCommGroup V1] [inst_2 : Module k V1]\\n  [inst_3 : AddTorsor V1 P1], ⇑(AffineMap.id k P1) = id\"},\n {\"role\": \"user\",\n  \"content\": \"The identity map is an additive monoid homomorphism.\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u} [inst : AddZeroClass α], IsAddMonoidHom id\"},\n {\"role\": \"user\", \"content\": \"The identity map is a semiring homomorphism. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u} [inst : Semiring α], IsSemiringHom id\"},\n {\"role\": \"user\", \"content\": \"The identity map preserves multiplication. \"},\n {\"role\": \"assistant\", \"content\": \"∀ {α : Type u} [inst : Mul α], IsMulHom id\"},\n {\"role\": \"user\", \"content\": \"The identity map is a monoid homomorphism. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u} [inst : MulOneClass α], IsMonoidHom id\"},\n {\"role\": \"user\", \"content\": \"The identity map is a ring homomorphism. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u} [inst : Ring α], IsRingHom id\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The image of the identity element under the identity map is the identity element.\"}]"}
{"text":"Every point is a fixed point of the identity function on a space.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"An affinely independent set of points can be extended to such a\\nset that spans the whole space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] {s : Set P},\\n  (AffineIndependent k fun p => ↑p) → ∃ t, s ⊆ t ∧ (AffineIndependent k fun p => ↑p) ∧ affineSpan k t = ⊤\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two points in a projective space are dependent if and only if they are equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u_2} {V : Type u_3} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  (u v : Projectivization K V), Projectivization.Dependent ![u, v] ↔ u = v\"},\n {\"role\": \"user\", \"content\": \"For the identity map, all points are periodic. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u_1} (n : ℕ) (x : α), Function.IsPeriodicPt id n x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"An affine-independent subset of a finite-dimensional affine space is finite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (k : Type u_1) {V : Type u_2} {P : Type u_3} {ι : Type u_4} [inst : DivisionRing k] [inst_1 : AddCommGroup V]\\n  [inst_2 : Module k V] [inst_3 : AddTorsor V P] [inst_4 : FiniteDimensional k V] {s : Set ι} {f : ↑s → P},\\n  AffineIndependent k f → Set.Finite s\"},\n {\"role\": \"user\",\n  \"content\": \"Two inseparable points in a T₀ space are equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u} [inst : TopologicalSpace X] [self : T0Space X] ⦃x y : X⦄, Inseparable x y → x = y\"},\n {\"role\": \"user\", \"content\": \"All hom spaces are finite dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {k G : Type u} [inst : Field k] [inst_1 : Monoid G] (V W : FdRep k G), FiniteDimensional k (V ⟶ W)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A point is in the affine span of a single point if and only if they are equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (k : Type u_1) (V : Type u_2) {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [S : AddTorsor V P] {p₁ p₂ : P}, p₁ ∈ affineSpan k {p₂} ↔ p₁ = p₂\"},\n {\"role\": \"user\",\n  \"content\":\n  \"An affine-independent family of points in a finite-dimensional affine space is finite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (k : Type u_1) {V : Type u_2} {P : Type u_3} {ι : Type u_4} [inst : DivisionRing k] [inst_1 : AddCommGroup V]\\n  [inst_2 : Module k V] [inst_3 : AddTorsor V P] [inst_4 : FiniteDimensional k V] {p : ι → P},\\n  AffineIndependent k p → Finite ι\"},\n {\"role\": \"user\",\n  \"content\": \"The set of fixed points of a continuous map is a closed set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : T2Space α] {f : α → α},\\n  Continuous f → IsClosed (Function.fixedPoints f)\"},\n {\"role\": \"user\", \"content\": \"Every point is a fixed point of `id`. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u} (x : α), Function.IsFixedPt id x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every point is a fixed point of the identity function on a space.\"}]"}
{"text":"The diameter of a singleton space is `0`.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The one point compactification of a `T0Space` space is a `T0Space`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T0Space X], T0Space (OnePoint X)\"},\n {\"role\": \"user\", \"content\": \"A singleton in a T₁ space is a closed set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u} [inst : TopologicalSpace X] [self : T1Space X] (x : X), IsClosed {x}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A nonempty set is scaled by zero to the singleton set containing 0. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_2} {β : Type u_3} [inst : Zero α] [inst_1 : Zero β] [inst_2 : SMulWithZero α β] [inst_3 : DecidableEq β]\\n  {s : Finset β}, Finset.Nonempty s → 0 • s = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A space is totally disconnected iff its connected components are singletons. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α], TotallyDisconnectedSpace α ↔ ∀ (x : α), connectedComponent x = {x}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The image of a connected component in a totally disconnected space is a singleton. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {β : Type u_3} [inst_1 : TopologicalSpace β]\\n  [inst_2 : TotallyDisconnectedSpace β] {f : α → β}, Continuous f → ∀ (a : α), f '' connectedComponent a = {f a}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A (finite dimensional) space that is a subsingleton has zero `finrank`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : Ring K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] [inst_3 : Nontrivial K]\\n  [inst_4 : NoZeroSMulDivisors K V] [h : Subsingleton V], FiniteDimensional.finrank K V = 0\"},\n {\"role\": \"user\", \"content\": \"The diameter of the empty set vanishes \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : PseudoEMetricSpace α], EMetric.diam ∅ = 0\"},\n {\"role\": \"user\", \"content\": \"The empty set has zero diameter \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u} [inst : PseudoMetricSpace α], Metric.diam ∅ = 0\"},\n {\"role\": \"user\", \"content\": \"The diameter of a singleton vanishes \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : PseudoEMetricSpace α] {x : α}, EMetric.diam {x} = 0\"},\n {\"role\": \"user\", \"content\": \"A singleton has zero diameter \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0\"},\n {\"role\": \"user\", \"content\": \"The diameter of a singleton space is `0`.\"}]"}
{"text":"Every group is non-empty.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The cartesian product of two nonarchimedean groups is nonarchimedean. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : NonarchimedeanGroup G] {K : Type u_3}\\n  [inst_3 : Group K] [inst_4 : TopologicalSpace K] [inst_5 : NonarchimedeanGroup K], NonarchimedeanGroup (G × K)\"},\n {\"role\": \"user\", \"content\": \"A non-cyclic additive group is non-trivial.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : AddGroup α], ¬IsAddCyclic α → Nontrivial α\"},\n {\"role\": \"user\",\n  \"content\": \"The intrinsic interior of a nonempty convex set is nonempty. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {V : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : NormedSpace ℝ V] [inst_2 : FiniteDimensional ℝ V] {s : Set V},\\n  Convex ℝ s → Set.Nonempty s → Set.Nonempty (intrinsicInterior ℝ s)\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [self : LinearOrderedCommGroupWithZero α] (a : α), a ≠ 0 → a * a⁻¹ = 1\"},\n {\"role\": \"user\", \"content\": \"The affine span of a nonempty set is nonempty. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (k : Type u_1) {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] {s : Set P} [inst_4 : Nonempty ↑s], Nonempty ↥(affineSpan k s)\"},\n {\"role\": \"user\",\n  \"content\": \"The set in the definition of division is nonempty. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {a b : Ordinal.{u_4}}, b ≠ 0 → Set.Nonempty {o | a < b * Order.succ o}\"},\n {\"role\": \"user\", \"content\": \"A connected space is nonempty. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [self : ConnectedSpace α], Nonempty α\"},\n {\"role\": \"user\", \"content\": \"The ideal is nonempty. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {P : Type u_2} [inst : LE P] (self : Order.Ideal P), Set.Nonempty self.carrier\"},\n {\"role\": \"user\",\n  \"content\": \"Each connected component of the category is nonempty. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {J : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} J] (j : CategoryTheory.ConnectedComponents J),\\n  Nonempty (CategoryTheory.Component j)\"},\n {\"role\": \"user\", \"content\": \"Every group is non-empty.\"}]"}
{"text":"All connected components of a topological space are connected.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"Each connected component of the category is nonempty. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {J : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} J] (j : CategoryTheory.ConnectedComponents J),\\n  Nonempty (CategoryTheory.Component j)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any two points in a path-connected space must be joined by a continuous path. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u_4} [inst : TopologicalSpace X] [self : PathConnectedSpace X] (x y : X), Joined x y\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A space is totally disconnected iff its connected components are subsingletons. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α],\\n  TotallyDisconnectedSpace α ↔ ∀ (x : α), Set.Subsingleton (connectedComponent x)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A space is totally disconnected iff its connected components are singletons. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α], TotallyDisconnectedSpace α ↔ ∀ (x : α), connectedComponent x = {x}\"},\n {\"role\": \"user\",\n  \"content\": \"A space with discrete topology is a locally connected space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (α : Type u_3) [inst : TopologicalSpace α] [inst_1 : DiscreteTopology α], LocallyConnectedSpace α\"},\n {\"role\": \"user\", \"content\": \"A connected space is nonempty. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [self : ConnectedSpace α], Nonempty α\"},\n {\"role\": \"user\", \"content\": \"Finite topological spaces are compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : Finite X], CompactSpace X\"},\n {\"role\": \"user\",\n  \"content\": \"Each connected component of the category is connected. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {J : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} J] (j : CategoryTheory.ConnectedComponents J),\\n  CategoryTheory.IsConnected (CategoryTheory.Component j)\"},\n {\"role\": \"user\", \"content\": \"The underlying topological space is compact.\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (self : CompHaus), CompactSpace ↑self.toTop\"},\n {\"role\": \"user\",\n  \"content\": \"All connected components of a topological space are connected.\"}]"}
{"text":"The ring of integers has a maximal ideal.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The class number is `1` iff the ring of integers is a principal ideal domain. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\\n  [inst_3 : Fintype (ClassGroup R)], Fintype.card (ClassGroup R) = 1 ↔ IsPrincipalIdealRing R\"},\n {\"role\": \"user\",\n  \"content\": \"This ideal is maximal in the collection of proper ideals. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {P : Type u_1} [inst : LE P] {I : Order.Ideal P} [self : Order.Ideal.IsMaximal I] ⦃J : Order.Ideal P⦄,\\n  I < J → ↑J = Set.univ\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The ring of integers of a `p`-th cyclotomic extension of `ℚ` is a cyclotomic extension. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ+} {K : Type u} [inst : Field K] [inst_1 : CharZero K] [hp : Fact (Nat.Prime ↑p)]\\n  [inst_2 : IsCyclotomicExtension {p} ℚ K], IsCyclotomicExtension {p} ℤ ↥(NumberField.ringOfIntegers K)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If the quotient by an ideal is a field, then the ideal is maximal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : CommRing R] (I : Ideal R), IsField (R ⧸ I) → Ideal.IsMaximal I\"},\n {\"role\": \"user\",\n  \"content\": \"Multiplicativity of the ideal norm in number rings. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {S : Type u_1} [inst : CommRing S] [inst_1 : IsDomain S] [inst_2 : IsDedekindDomain S] [inst_3 : Module.Free ℤ S]\\n  [inst_4 : Module.Finite ℤ S] (I J : Ideal S), Submodule.cardQuot (I * J) = Submodule.cardQuot I * Submodule.cardQuot J\"},\n {\"role\": \"user\",\n  \"content\": \"Maximal ideals in complete normed rings are closed. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] {I : Ideal R} [hI : Ideal.IsMaximal I], IsClosed ↑I\"},\n {\"role\": \"user\",\n  \"content\": \"Krull's theorem: a nontrivial ring has a maximal ideal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (α : Type u) [inst : Semiring α] [inst_1 : Nontrivial α], ∃ M, Ideal.IsMaximal M\"},\n {\"role\": \"user\",\n  \"content\": \"When a ring is not a field, the maximal ideals are nontrivial. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : CommSemiring R] [inst_1 : Nontrivial R] {M : Ideal R}, Ideal.IsMaximal M → ¬IsField R → M ≠ ⊥\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The quotient of a ring by an ideal is a field iff the ideal is maximal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I ↔ IsField (R ⧸ I)\"},\n {\"role\": \"user\", \"content\": \"The ring of integers has a maximal ideal.\"}]"}
{"text":"The numbers `3`, `4` and `5` form a Pythagorean triple.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"`(k*x, k*y, k*z)` is a Pythagorean triple if and only if\\n`(x, y, z)` is also a triple. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {x y z : ℤ} (k : ℤ), k ≠ 0 → (PythagoreanTriple (k * x) (k * y) (k * z) ↔ PythagoreanTriple x y z)\"},\n {\"role\": \"user\",\n  \"content\": \"Pythagorean theorem, if-and-only-if vector inner product form. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {F : Type u_3} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] (x y : F),\\n  ‖x + y‖ * ‖x + y‖ = ‖x‖ * ‖x‖ + ‖y‖ * ‖y‖ ↔ inner x y = 0\"},\n {\"role\": \"user\",\n  \"content\": \"Pythagorean theorem, subtracting vectors, vector angle form. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] (x y : V),\\n  InnerProductGeometry.angle x y = Real.pi / 2 → ‖x - y‖ * ‖x - y‖ = ‖x‖ * ‖x‖ + ‖y‖ * ‖y‖\"},\n {\"role\": \"user\",\n  \"content\": \"Pythagorean theorem, if-and-only-if vector angle form. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] (x y : V),\\n  ‖x + y‖ * ‖x + y‖ = ‖x‖ * ‖x‖ + ‖y‖ * ‖y‖ ↔ InnerProductGeometry.angle x y = Real.pi / 2\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Pythagorean theorem, if-and-if vector inner product form using square roots. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {F : Type u_3} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] {x y : F},\\n  ‖x + y‖ = Real.sqrt (‖x‖ * ‖x‖ + ‖y‖ * ‖y‖) ↔ inner x y = 0\"},\n {\"role\": \"user\",\n  \"content\": \"Pythagorean theorem, vector inner product form. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  (x y : E), inner x y = 0 → ‖x + y‖ * ‖x + y‖ = ‖x‖ * ‖x‖ + ‖y‖ * ‖y‖\"},\n {\"role\": \"user\", \"content\": \"Pythagorean theorem, vector angle form. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] (x y : V),\\n  InnerProductGeometry.angle x y = Real.pi / 2 → ‖x + y‖ * ‖x + y‖ = ‖x‖ * ‖x‖ + ‖y‖ * ‖y‖\"},\n {\"role\": \"user\", \"content\": \"The zeroth Pythagorean triple is all zeros. \"},\n {\"role\": \"assistant\", \"content\": \"PythagoreanTriple 0 0 0\"},\n {\"role\": \"user\", \"content\": \"**Formula for Pythagorean Triples** \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {x y z : ℤ},\\n  PythagoreanTriple x y z ↔\\n    ∃ k m n,\\n      (x = k * (m ^ 2 - n ^ 2) ∧ y = k * (2 * m * n) ∨ x = k * (2 * m * n) ∧ y = k * (m ^ 2 - n ^ 2)) ∧\\n        (z = k * (m ^ 2 + n ^ 2) ∨ z = -k * (m ^ 2 + n ^ 2))\"},\n {\"role\": \"user\",\n  \"content\": \"The numbers `3`, `4` and `5` form a Pythagorean triple.\"}]"}
{"text":"A vector space with the empty set as basis is trivial.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a vector space has a finite dimension, the index set of `Basis.ofVectorSpace` is finite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\\n  Module.rank K V < Cardinal.aleph0 → Set.Finite (Basis.ofVectorSpaceIndex K V)\"},\n {\"role\": \"user\",\n  \"content\": \"Two linearly equivalent vector spaces have the same dimension. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : Ring R] {M : Type v} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {M₁ : Type v}\\n  [inst_3 : AddCommGroup M₁] [inst_4 : Module R M₁], (M ≃ₗ[R] M₁) → Module.rank R M = Module.rank R M₁\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a one-dimensional space, any vector is a multiple of any nonzero vector \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\\n  FiniteDimensional.finrank K V = 1 → ∀ {x : V}, x ≠ 0 → ∀ (y : V), ∃ c, c • x = y\"},\n {\"role\": \"user\", \"content\": \"The empty set is collinear. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (k : Type u_1) {V : Type u_2} (P : Type u_3) [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P], Collinear k ∅\"},\n {\"role\": \"user\", \"content\": \"A strict vector subspace has measure zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ℝ E] (μ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] (s : Submodule ℝ E), s ≠ ⊤ → ↑↑μ ↑s = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a vector space has a basis indexed by elements of a finite set, then it is\\nfinite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\\n  {s : Set ι}, Basis (↑s) K V → Set.Finite s → FiniteDimensional K V\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a vector space has a finite basis, then it is finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\\n  [inst_3 : Finite ι], Basis ι K V → FiniteDimensional K V\"},\n {\"role\": \"user\",\n  \"content\": \"A vector space with the empty set as basis is trivial.\"}]"}
