cont_mdiff I I' n f â†” continuous f âˆ§ âˆ€ (x : M) (y : M'), cont_diff_on ğ•œ n (â‡‘(ext_chart_at I' y) âˆ˜ f âˆ˜ â‡‘((ext_chart_at I x).symm)) ((ext_chart_at I x).target âˆ© â‡‘((ext_chart_at I x).symm) â»Â¹' (f â»Â¹' (ext_chart_at I' y).source))
category_theory.has_lifting_property i p â†” âˆ€ {e : i.right âŸ¶ p.right}, âˆƒ (l : i.right âŸ¶ p.left), l â‰« p.hom = e
witt_vector.is_poly p (Î» (R : Type u_1) (_Rcr : comm_ring R), witt_vector.verschiebung_fun)
tendsto_locally_uniformly F f p â†” âˆ€ (Îµ : â„), Îµ > 0 â†’ âˆ€ (x : Î²), âˆƒ (t : set Î²) (H : t âˆˆ nhds x), âˆ€á¶  (n : Î¹) in p, âˆ€ (y : Î²), y âˆˆ t â†’ has_dist.dist (f y) (F n y) < Îµ
deriv_within (Î» (u : â„), âˆ« (x : â„) in a..u, f x) s b = c
â‡‘S (ğŸ™ X) â†” S = âŠ¤
âŠ¥ < f.ker
â‡‘f =áµ[Î¼] â‡‘g
continuous (Î» (x : X), âˆ« (t : â„) in a..b, F x t âˆ‚Î¼)
function.injective â‡‘(f.ker_lift)
submodule.span R (â‡‘(algebra_map R S) '' a) = submodule.map (algebra.linear_map R S) (submodule.span R a)
l <+ l' â†” âˆƒ (f : â„• â†ªo â„•), âˆ€ (ix : â„•), l.nth ix = l'.nth (â‡‘f ix)
â‡‘Î¼ (f '' s) = 0
category_theory.has_lifting_property i (category_theory.arrow.mk (f â‰« g))
âˆƒ (t : set Î±) (H : t âŠ† s), t.countable âˆ§ s âŠ† â‹ƒ (x : Î±) (H : x âˆˆ t), f x
set.eq_on f g (complex.im â»Â¹' set.Icc a b)
category_theory.limits.colimit.Î¹ (category_theory.curry.obj (category_theory.prod.swap K J â‹™ F) â‹™ category_theory.limits.lim) k â‰« category_theory.limits.colimit_limit_to_limit_colimit F â‰« category_theory.limits.limit.Ï€ (category_theory.curry.obj F â‹™ category_theory.limits.colim) j = category_theory.limits.limit.Ï€ ((category_theory.curry.obj (category_theory.prod.swap K J â‹™ F)).obj k) j â‰« category_theory.limits.colimit.Î¹ ((category_theory.curry.obj F).obj j) k
âˆ« (x : â„) in a..X, real.exp (-b * x) â‰¤ real.exp (-b * a) / b
(âˆ€ (x : K), x âˆˆ s â†’ is_integral F x âˆ§ polynomial.splits (algebra_map F L) (minpoly F x)) â†’ nonempty (â†¥(algebra.adjoin F â†‘s) â†’â‚[F] L)
s.pairwise r â†’ pairwise (Î» (x y : â†¥s), r â†‘x â†‘y)
âˆƒá¶  (n : â„•) in filter.at_top, âˆ€ (k : â„•), k < n â†’ u k < u n
emetric.ball x âŠ¤ = set.univ
let PR : Î± â†’ nat.partrec.code â†’ nat.partrec.code â†’ Ïƒ â†’ Ïƒ â†’ Ïƒ := Î» (a : Î±) (cf cg : nat.partrec.code) (hf hg : Ïƒ), pr a (cf, cg, hf, hg), CO : Î± â†’ nat.partrec.code â†’ nat.partrec.code â†’ Ïƒ â†’ Ïƒ â†’ Ïƒ := Î» (a : Î±) (cf cg : nat.partrec.code) (hf hg : Ïƒ), co a (cf, cg, hf, hg), PC : Î± â†’ nat.partrec.code â†’ nat.partrec.code â†’ Ïƒ â†’ Ïƒ â†’ Ïƒ := Î» (a : Î±) (cf cg : nat.partrec.code) (hf hg : Ïƒ), pc a (cf, cg, hf, hg), RF : Î± â†’ nat.partrec.code â†’ Ïƒ â†’ Ïƒ := Î» (a : Î±) (cf : nat.partrec.code) (hf : Ïƒ), rf a (cf, hf), F : Î± â†’ nat.partrec.code â†’ Ïƒ := Î» (a : Î±) (c : nat.partrec.code), c.rec_on (z a) (s a) (l a) (r a) (PR a) (CO a) (PC a) (RF a) in computable (Î» (a : Î±), F a (c a))
a âŠ“ has_Sup.Sup s = â¨† (t : finset Î±) (H : â†‘t âŠ† s), a âŠ“ t.sup id
category_theory.cover_lifting J J (ğŸ­ C)
t.orthocenter = 3 â€¢ (finset.centroid â„ finset.univ t.points -áµ¥ affine.simplex.circumcenter t) +áµ¥ affine.simplex.circumcenter t
Â¬a â‹– b â†’ (âˆƒ (c : Î±), a < c âˆ§ c < b)
directed ge (Î» (Î³â‚€ : Î“â‚€Ë£), filter.principal {Î³ : Î“â‚€ | Î³ < â†‘Î³â‚€})
(ğŸ™ X - p) â‰« (ğŸ™ X - p) = ğŸ™ X - p
p ^ (n + 1) âˆ£ fintype.card â†¥(H.normalizer)
(Î» (t : Î¹), âˆ« (x : â„) in u t..v t, f x âˆ‚Î¼ - (â‡‘Î¼ (set.Ioc (u t) (v t))).to_real â€¢ c) =o[lt] Î» (t : Î¹), (â‡‘Î¼ (set.Ioc (u t) (v t))).to_real
0.lf x â†” âˆƒ (i : x.left_moves), 0 â‰¤ x.move_left i
(â‡‘witt_vector.verschiebung^[i] x * â‡‘witt_vector.verschiebung^[j] y).coeff (i + j) = x.coeff 0 ^ p ^ j * y.coeff 0 ^ p ^ i
emetric.inf_edist x s â‰  âŠ¤
âˆ¥x + yâˆ¥ = âˆ¥xâˆ¥ + âˆ¥yâˆ¥ â†” inner_product_geometry.angle x y = 0
measure_theory.integrable F' Î¼ âˆ§ has_fderiv_at (Î» (x : H), âˆ« (a : Î±), F x a âˆ‚Î¼) (âˆ« (a : Î±), F' a âˆ‚Î¼) xâ‚€
g =áµ[Î¼] measure_theory.condexp m Î¼ f
âˆ¥âŸ¨continuous_map.to_ae_eq_fun Î¼ f.to_continuous_map, _âŸ©âˆ¥ â‰¤ â†‘(measure_theory.measure_univ_nnreal Î¼) ^ (p.to_real)â»Â¹ * âˆ¥fâˆ¥
âˆ¥âˆ® (z : â„‚) in C(c, R), f zâˆ¥ < 2 * real.pi * R * C
filter.tendsto f la lb.small_sets â†” âˆ€ (t : set Î²), t âˆˆ lb â†’ (âˆ€á¶  (x : Î±) in la, f x âŠ† t)
S = âŠ¥ âˆ¨ nontrivial â†¥S
cont_mdiff_on I I' n f s â†” continuous_on f s âˆ§ âˆ€ (x : M) (y : M'), cont_diff_on ğ•œ n (â‡‘(ext_chart_at I' y) âˆ˜ f âˆ˜ â‡‘((ext_chart_at I x).symm)) ((ext_chart_at I x).target âˆ© â‡‘((ext_chart_at I x).symm) â»Â¹' (s âˆ© f â»Â¹' (ext_chart_at I' y).source))
category_theory.presieve.is_sheaf_for P â‡‘S â†” nonempty (category_theory.limits.is_limit (category_theory.limits.fork.of_Î¹ (category_theory.equalizer.fork_map P â‡‘S) _))
vector_span â„ (s.points '' â†‘(finset.univ.erase i)) â‰¤ ((s.altitude i).direction)á—®
(submodule.map â†‘f s).topological_closure = âŠ¤
(â‹ƒ (j : Î¹'), â‹‚ (i : Î¹), s i j) âŠ† â‹‚ (i : Î¹), â‹ƒ (j : Î¹'), s i j
|a| = a âˆ§ 0 â‰¤ a âˆ¨ |a| = -a âˆ§ a < 0
reflexive (Î» (a b : M), âˆƒ (c : M), semiconj_by c a b)
âˆƒ (s : finset L) (b : basis â†¥s K L), âˆ€ (x : â†¥s), is_integral A (â‡‘b x)
(â¨† (n : Î²), f n) âˆˆ â‹‚ (n : Î²), set.Icc (f n) (g n)
spectrum â„‚ a = coe âˆ˜ complex.re '' spectrum â„‚ a
has_Sup.Sup S = con_gen (Î» (x y : M), âˆƒ (c : con M), c âˆˆ S âˆ§ â‡‘c x y)
finset.univ.sum (Î» (j : J), category_theory.limits.biproduct.Ï€ f j â‰« category_theory.limits.biproduct.Î¹ f j) = ğŸ™ (â¨ f)
orthonormal ğ•œ â‡‘(v.map f.to_linear_equiv)
âˆ¥a ^ nâˆ¥ â‰¤ âˆ¥aâˆ¥ ^ n
T.morâ‚‚ â‰« T.morâ‚ƒ = 0
is_open_map â‡‘(prime_spectrum.comap polynomial.C)
cont_diff_on ğ•œ n (f âˆ˜ â‡‘g) (â‡‘g â»Â¹' s)
D.diagram_over_open_Ï€ U i â‰« D.Î¹_inv_app_Ï€_eq_map U â‰« D.Î¹_inv_app U = ğŸ™ (category_theory.limits.limit (D.diagram_over_open U))
âˆ¥â‡‘(fr.to_linear_map.extend_to_ğ•œ') xâˆ¥ â‰¤ âˆ¥frâˆ¥ * âˆ¥xâˆ¥
m âˆˆ f' '' set.Icc a b
âˆƒ (U : set Î±), is_open U âˆ§ x âˆˆ U âˆ§ U Ã—Ë¢ U âŠ† s
(category_theory.nat_trans.right_derived Î± n).app X = (F.right_derived_obj_iso n P).hom â‰« (homology_functor D (complex_shape.up â„•) n).map ((category_theory.nat_trans.map_homological_complex Î± (complex_shape.up â„•)).app P.cocomplex) â‰« (G.right_derived_obj_iso n P).inv
P (â‡‘f' âˆ˜ g âˆ˜ â‡‘(e'.symm)) (e'.to_local_equiv.target âˆ© â‡‘(e'.symm) â»Â¹' (s âˆ© g â»Â¹' f'.to_local_equiv.source)) (â‡‘e' x)
function.involutive â‡‘(reflection K)
filter.tendsto (â‡‘Î¼ âˆ˜ s) (nhds_within a (set.Ioi a)) (nhds (â‡‘Î¼ (â‹‚ (r : Î¹) (H : r > a), s r)))
âˆƒ (K : subgroup G), fintype.card â†¥K = p ^ n
(Î» (t : Î¹), âˆ« (x : â„) in u t..v t, f x âˆ‚Î¼ - âˆ« (x : â„) in u t..v t, c âˆ‚Î¼) =o[lt] Î» (t : Î¹), âˆ« (x : â„) in u t..v t, 1 âˆ‚Î¼
tendsto_uniformly F f p â†” âˆ€ (Îµ : ennreal), Îµ > 0 â†’ (âˆ€á¶  (n : Î¹) in p, âˆ€ (x : Î²), has_edist.edist (f x) (F n x) < Îµ)
âŠ¥ = âŠ¤
f =o[l] g' â†’ (f =o[l] Î» (x : Î±), âˆ¥g' xâˆ¥)
measurable g â†’ âˆ«â» (a : Î±), g a âˆ‚Î¼.with_density f = âˆ«â» (a : Î±), (f * g) a âˆ‚Î¼
nonempty (a âŸ¶ b) â†’ nonempty (quiver.path (symgen a) (symgen b))
âˆƒ (g : V â†’â‚—[K] V'), g.comp p.subtype = f
has_inner.inner (measure_theory.indicator_const_Lp 2 hs hÎ¼s 1) f = âˆ« (x : Î±) in s, â‡‘f x âˆ‚Î¼
simplex_category.Ïƒ (â‡‘fin.cast_succ i) â‰« simplex_category.Ïƒ j = simplex_category.Ïƒ j.succ â‰« simplex_category.Ïƒ i
filter.tendsto (Î» (i : Î¹), âˆ« (x : Î±) in s i, f x âˆ‚Î¼) l (nhds 0)
t.Î¹.app j â‰« k = t.Î¹.app j â‰« l
simplex_category.Î´ (â‡‘fin.cast_succ i) â‰« simplex_category.Ïƒ j.succ = simplex_category.Ïƒ j â‰« simplex_category.Î´ i
continuous â‡‘g
set.eq_on â‡‘f â‡‘g â†‘(submonoid.closure s)
âˆƒ (Z : multiset (prime_spectrum A)), (multiset.map coe Z).prod â‰¤ I âˆ§ (multiset.map coe Z).prod â‰  âŠ¥
cardinal.mk â†¥(set.range â‡‘v) â‰¤ cardinal.mk â†¥J
is_add_submonoid (â‹ƒ (i : Î¹), s i)
(â‹ƒ (i : Î¹') (H : i âˆˆ s), â†‘(g i)).pairwise_disjoint f
âˆ¥x + yâˆ¥ * âˆ¥x + yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + âˆ¥yâˆ¥ * âˆ¥yâˆ¥
category_theory.inv (category_theory.limits.coprod_comparison F A B) â‰« category_theory.limits.coprod.map (F.map f) (F.map g) = F.map (category_theory.limits.coprod.map f g) â‰« category_theory.inv (category_theory.limits.coprod_comparison F A' B')
is_open_map â‡‘f
algebra.adjoin R (add_monoid_algebra.of' R M '' â‹ƒ (f : add_monoid_algebra R M) (H : f âˆˆ S), â†‘(f.support)) = âŠ¤
S.functor_inclusion â‰« h.extend f = f
I.is_prime â†” (âˆƒ (p : ideal R), p.is_prime âˆ§ I = p.prod âŠ¤) âˆ¨ âˆƒ (p : ideal S), p.is_prime âˆ§ I = âŠ¤.prod p
âˆ« (x : â„ Ã— â„) in set.Icc a b, â‡‘(f' x) (1, 0) + â‡‘(g' x) (0, 1) = (((âˆ« (x : â„) in a.fst..b.fst, g (x, b.snd)) - âˆ« (x : â„) in a.fst..b.fst, g (x, a.snd)) + âˆ« (y : â„) in a.snd..b.snd, f (b.fst, y)) - âˆ« (y : â„) in a.snd..b.snd, f (a.fst, y)
f.app (opposite.op (simplex_category.mk n)) â‰« algebraic_topology.dold_kan.hÏƒ' q n m hnm = algebraic_topology.dold_kan.hÏƒ' q n m hnm â‰« f.app (opposite.op (simplex_category.mk m))
uniformity (uniform_space.completion Î±) = â¨… (Îµ : {Îµ // 0 < Îµ}), filter.principal {p : uniform_space.completion Î± Ã— uniform_space.completion Î± | has_dist.dist p.fst p.snd < Îµ.val}
âˆ€áµ (x : Î±) âˆ‚Î¼, âˆƒ (c : ennreal), filter.tendsto (Î» (a : set Î±), â‡‘Ï a / â‡‘Î¼ a) (v.filter_at x) (nhds c)
mul_action.fixed_points â†¥(supr P) Î± = â‹‚ (i : Î¹), mul_action.fixed_points â†¥(P i) Î±
â‡‘(Î¼.prod Î½) (s Ã—Ë¢ t) = â‡‘Î¼ s * â‡‘Î½ t
finite_dimensional.finrank â„ â†¥((s.altitude i).direction) = 1
cont_mdiff (model_with_corners_self â„ (euclidean_space â„ (fin n))) (model_with_corners_self â„ E) âŠ¤ coe
âˆƒ (s : finset Ïƒ) (qâ‚ qâ‚‚ : mv_polynomial â†¥s R), pâ‚ = â‡‘(mv_polynomial.rename coe) qâ‚ âˆ§ pâ‚‚ = â‡‘(mv_polynomial.rename coe) qâ‚‚
has_inner.inner x y â‰¤ âˆ¥xâˆ¥ * âˆ¥yâˆ¥
[measure_theory.smul_invariant_measure G Î± Î¼, âˆ€ (c : G) (s : set Î±), measurable_set s â†’ â‡‘Î¼ (has_scalar.smul c â»Â¹' s) = â‡‘Î¼ s, âˆ€ (c : G) (s : set Î±), measurable_set s â†’ â‡‘Î¼ (c â€¢ s) = â‡‘Î¼ s, âˆ€ (c : G) (s : set Î±), â‡‘Î¼ (has_scalar.smul c â»Â¹' s) = â‡‘Î¼ s, âˆ€ (c : G) (s : set Î±), â‡‘Î¼ (c â€¢ s) = â‡‘Î¼ s, âˆ€ (c : G), measure_theory.measure.map (has_scalar.smul c) Î¼ = Î¼, âˆ€ (c : G), measure_theory.measure_preserving (has_scalar.smul c) Î¼ Î¼].tfae
âˆ«â» (a : Î±), f a âˆ‚Î¼ + âˆ«â» (a : Î±), g a âˆ‚Î¼ â‰¤ âˆ«â» (a : Î±), f a + g a âˆ‚Î¼
0 < n â†’ âˆ¥a ^ nâˆ¥â‚Š â‰¤ âˆ¥aâˆ¥â‚Š ^ n
f + g = category_theory.limits.biprod.lift (ğŸ™ X) (ğŸ™ X) â‰« category_theory.limits.biprod.desc f g
function.injective f â†” setoid.ker f = âŠ¥
has_edist.edist x y < âŠ¤
âˆƒ (a : â„) (H : a âˆˆ set.Ioo 0 1) (C : â„) (H : C > 0), âˆ€ (y : E), y âˆˆ metric.ball 0 â†‘r' â†’ âˆ€ (n : â„•), âˆ¥f (x + y) - p.partial_sum n yâˆ¥ â‰¤ C * (a * (âˆ¥yâˆ¥ / â†‘r')) ^ n
â‡‘Î¼ {x : Î± | âˆƒá¶  (n : â„•) in filter.at_top, p n x} = 0
affine_independent k p â†” linear_independent k (Î» (i : {x // x â‰  i1}), p â†‘i -áµ¥ p i1)
âˆƒ (a : Î±), Î¸ â‰¤ cardinal.mk â†¥(f â»Â¹' {a})
function.injective â‡‘(polynomial.gal.restrict_prod p q)
direct_sum.is_internal V â†” (supr V)á—® = âŠ¥
âˆƒ (C : nnreal) (H : C > 0), âˆ€ {u : E â†’L[ğ•œ] F} (M : nnreal), (âˆ€ (i : Î¹), âˆ¥â‡‘u (â‡‘v i)âˆ¥â‚Š â‰¤ M) â†’ âˆ¥uâˆ¥â‚Š â‰¤ C * M
p âˆ£ fintype.card (â†¥(H.normalizer) â§¸ subgroup.comap H.normalizer.subtype H)
âˆƒ (iâ‚€ iâ‚ : fin (fintype.card Fq ^ âŒˆ-real.log Îµ / real.log â†‘(fintype.card Fq)âŒ‰â‚Š).succ), iâ‚€ â‰  iâ‚ âˆ§ â†‘(â‡‘polynomial.card_pow_degree (A iâ‚ % b - A iâ‚€ % b)) < â‡‘polynomial.card_pow_degree b â€¢ Îµ
is_preconnected (â‹ƒ (n : Î²), s n)
has_Sup.Sup s = eqv_gen.setoid (has_Sup.Sup (setoid.rel '' s))
cauchy f â†” f â‰  âŠ¥ âˆ§ âˆ€ (Îµ : ennreal), Îµ > 0 â†’ (âˆƒ (t : set Î±) (H : t âˆˆ f), âˆ€ (x : Î±), x âˆˆ t â†’ âˆ€ (y : Î±), y âˆˆ t â†’ has_edist.edist x y < Îµ)
â‡‘Î¼ ((Î» (h : G), g + h) â»Â¹' A) = â‡‘Î¼ A
âˆƒ (u : â„• â†’ Î³), âˆ€ (n : â„•), P (u n) (u '' set.Iio n)
âˆ® (z : â„‚) in C(c, R), f z / (z - w) = 2 * â†‘real.pi * complex.I * f w
f =áµ[Î¼] function.const Î± (â¨ (x : Î±), f x âˆ‚Î¼) âˆ¨ â¨ (x : Î±), f x âˆ‚Î¼ âˆˆ interior s
âˆ¥xâˆ¥ â‰¤ M
box_integral.has_integral I l f vol y â†” âˆ€ (Îµ : â„), Îµ > 0 â†’ (âˆƒ (r : nnreal â†’ (Î¹ â†’ â„) â†’ â†¥(set.Ioi 0)), (âˆ€ (c : nnreal), l.r_cond (r c)) âˆ§ âˆ€ (c : nnreal) (Ï€ : box_integral.tagged_prepartition I), l.mem_base_set I c (r c) Ï€ â†’ Ï€.is_partition â†’ has_dist.dist (box_integral.integral_sum f vol Ï€) y â‰¤ Îµ)
continuous (Î» (f : (Î  (j : Î¹), Ï€ j) Ã— Ï€ i), function.update f.fst i f.snd)
has_sum (Î» (n : Î¹), âˆ« (a : Î±), F n a âˆ‚Î¼) (âˆ« (a : Î±), f a âˆ‚Î¼)
K âŠ” Ká—® = âŠ¤
âˆƒ (f : Î± â†’ â†¥(lp (Î» (n : â„•), â„) âŠ¤)), isometry f
f.liminf u = â¨† (s : set Î²) (H : s âˆˆ f), â¨… (a : Î²) (H : a âˆˆ s), u a
â‡‘h (f.prod g) = f.prod (Î» (a : Î±) (b : M), â‡‘h (g a b))
âˆƒ (g : â†¥A), âˆ¥â†‘g - fâˆ¥ < Îµ
asymptotics.is_O_with c l f g â†’ (âˆ€á¶  (x : Î±) in l, âˆ¥f xâˆ¥ â‰¤ c * âˆ¥g xâˆ¥)
tropical.untrop (s.sum (Î» (i : S), f i)) = â¨… (i : â†¥s), tropical.untrop (f â†‘i)
(b â€¢ g).sum (Î» (a : Î±), â‡‘(h a)) = g.sum (Î» (i : Î±) (c : M), â‡‘(h i) (b â€¢ c))
collinear k s â†” âˆƒ (v : V), âˆ€ (p : P), p âˆˆ s â†’ (âˆƒ (r : k), p = r â€¢ v +áµ¥ pâ‚€)
âˆƒ (M : â„), 0 â‰¤ M âˆ§ âˆ«â» (x : Î±), â†‘âˆ¥{x : Î± | M â‰¤ â†‘âˆ¥f xâˆ¥â‚Š}.indicator f xâˆ¥â‚Š âˆ‚Î¼ â‰¤ ennreal.of_real Îµ
filter.tendsto (Î» (n : â„•), ennreal.of_real (âˆ¥a ^ nâˆ¥ ^ (1 / â†‘n))) filter.at_top (nhds (spectral_radius â„‚ a))
box_integral.integral I l â‡‘f Î¼.to_box_additive.to_smul = measure_theory.simple_func.integral (Î¼.restrict â†‘I) f
â†‘-â‡‘(is_add_unit.lift_right (f.restrict S) h) y = z
(Î±â‚ â‰« Î±â‚‚).right = (Î²â‚ â‰« Î²â‚‚).left
is_bounded_linear_map ğ•œ â‡‘f
I.jacobson = I â†” âŠ¥.jacobson = âŠ¥
(Î» (t : Î¹), (âˆ« (x : â„) in u t..v t, f x) - (v t - u t) â€¢ c) =o[lt] (v - u)
bdd_below (â‹ƒ (i : Î²) (H : i âˆˆ I), S i) â†” âˆ€ (i : Î²), i âˆˆ I â†’ bdd_below (S i)
âˆ¥xâˆ¥ â‰¤ r â†” âˆ€ (i : Î¹), âˆ¥x iâˆ¥ â‰¤ r
âˆ¥f.mk_continuous C hâˆ¥ â‰¤ C
convex_independent ğ•œ (Î» (x : â†¥(set.range p)), â†‘x) â†” convex_independent ğ•œ p
g '' set.image2 f s t = set.image2 f' (g' '' t) s
con.comap â‡‘f _ c = con.ker (c.mk'.comp f)
cont_diff ğ•œ âŠ¤ â‡‘((equiv.prod_assoc E F G).symm)
continuous â‡‘f
â‡‘(measure_theory.measure.hausdorff_measure d) (f '' s) â‰¤ â†‘K ^ d * â‡‘(measure_theory.measure.hausdorff_measure d) s
let F : Î± â†’ nat.partrec.code â†’ Ïƒ := Î» (a : Î±) (c : nat.partrec.code), c.rec_on (z a) (s a) (l a) (r a) (pr a) (co a) (pc a) (rf a) in primrec (Î» (a : Î±), F a (c a))
measure_theory.measure.map â‡‘(quotient_add_group.mk' Î“) (Î¼.restrict ğ“•) = â‡‘Î¼ (ğ“• âˆ© â‡‘(quotient_add_group.mk' Î“) â»Â¹' â†‘K) â€¢ measure_theory.measure.add_haar_measure K
(â‹‚ (i : Î²) (H : i âˆˆ is), s i) âˆˆ f â†” âˆ€ (i : Î²), i âˆˆ is â†’ s i âˆˆ f
_.mpr p = p â‰« category_theory.eq_to_hom _
galois_connection â‡‘oi â‡‘(oi.symm)
s âˆˆ finset.up_shadow^[k] ğ’œ â†” âˆƒ (t : finset Î±) (H : t âˆˆ ğ’œ), t âŠ† s âˆ§ t.card + k = s.card
âˆ« (x : â„) in set.interval_oc a b, |x - a| ^ n = |b - a| ^ (n + 1) / (â†‘n + 1)
s = âŠ¤
filter.tendsto (Î» (t : â„), âˆ« (x : â„) in 0..t, g x) filter.at_bot filter.at_bot
T.morâ‚ƒ â‰« (category_theory.shift_equiv C 1).functor.map T.morâ‚ = 0
(â‹‚ (i : â„•), Z i).nonempty
B.separating_left â†” B.ker = âŠ¥
â‡‘Î¼ U = â¨† (F : set Î±) (H : F âŠ† U) (h : is_closed F), â‡‘Î¼ F
category_theory.is_cofiltered.inf_to O H mX â‰« f = category_theory.is_cofiltered.inf_to O H mY
filter.tendsto (Î» (s : finset Î²), âˆ‘' (b : {x // x âˆ‰ s}), f â†‘b) filter.at_top (nhds 0)
â‡‘(clifford_algebra.Î¹ Q) a * â‡‘(clifford_algebra.Î¹ Q) b + â‡‘(clifford_algebra.Î¹ Q) b * â‡‘(clifford_algebra.Î¹ Q) a = â‡‘(algebra_map R (clifford_algebra Q)) (quadratic_form.polar â‡‘Q a b)
function.injective â‡‘(con.ker_lift f)
lie_ideal.map f â…Iâ‚,Iâ‚‚â† â‰¤ â…lie_ideal.map f Iâ‚,lie_ideal.map f Iâ‚‚â†
H = âŠ¥ âˆ¨ âˆƒ (x : G) (H : x âˆˆ H), x â‰  1
is_fraction_ring â†¥(integral_closure A L) L
(âˆ€ (i : Î¹), is_compact (s i)) â†’ is_compact {x : Î  (i : Î¹), Ï€ i | âˆ€ (i : Î¹), x i âˆˆ s i}
(âˆ¥u - vâˆ¥ = â¨… (w : â†¥â†‘K), âˆ¥u - â†‘wâˆ¥) â†” âˆ€ (w : F), w âˆˆ K â†’ has_inner.inner (u - v) w = 0
category_theory.is_pullback 0 0 0 (ğŸ™ X)
âˆ‘' (n : â„•), r ^ n = (1 - r)â»Â¹
witt_vector.is_polyâ‚‚ p (Î» (_x : Type u_1) (_x_1 : comm_ring _x), has_mul.mul)
âˆ« (x : Î±), g (f x) âˆ‚Î¼ â‰¤ g (âˆ« (x : Î±), f x âˆ‚Î¼)
add_group.fg G â†” âˆƒ (S : set G), add_subgroup.closure S = âŠ¤ âˆ§ S.finite
âˆƒ (t : set Î±) (r : Î± â†’ â„), t.countable âˆ§ t âŠ† s âˆ§ (âˆ€ (x : Î±), x âˆˆ t â†’ r x âˆˆ f x) âˆ§ (s âŠ† â‹ƒ (x : Î±) (H : x âˆˆ t), metric.closed_ball x (r x)) âˆ§ âˆ‘' (x : â†¥t), â‡‘Î¼ (metric.closed_ball â†‘x (r â†‘x)) â‰¤ â‡‘Î¼ s + Îµ
has_inner.inner (câ‚‚ -áµ¥ câ‚) (pâ‚‚ -áµ¥ pâ‚) = 0
(Î» (i : Î¹), âˆ« (x : Î±) in s i, f x âˆ‚Î¼ - m i â€¢ f a) =o[li] m
(âˆƒ (fs : finset Î¹) (hfs : â†‘fs âŠ† s) (w : Î¹ â†’ k) (hw : fs.sum (Î» (i : Î¹), w i) = 0), v = â‡‘(fs.weighted_vsub p) w) â†” âˆƒ (fs : finset â†¥s) (w : â†¥s â†’ k) (hw : fs.sum (Î» (i : â†¥s), w i) = 0), v = â‡‘(fs.weighted_vsub (Î» (i : â†¥s), p â†‘i)) w
(f â»Â¹' s).subsingleton
measure_theory.ae_strongly_measurable' m â‡‘f Î¼ â†’ P f
â‡‘Î¼ A = â¨… (U : set Î±) (h : A âŠ† U) (h2 : is_open U), â‡‘Î¼ U
filter.tendsto (Î» (n : â„•), âˆ« (a : Î±), F n a âˆ‚Î¼) filter.at_top (nhds (âˆ« (a : Î±), f a âˆ‚Î¼))
lâ‚ <+~ lâ‚‚ â†” âˆ€ (x : Î±), x âˆˆ lâ‚ â†’ list.count x lâ‚ â‰¤ list.count x lâ‚‚
s.sum (Î» (i : Î¹), f i) < âŠ¤ â†” âˆ€ (i : Î¹), i âˆˆ s â†’ f i < âŠ¤
(((âˆ« (x : â„) in z.re..w.re, f (â†‘x + â†‘(z.im) * complex.I)) - âˆ« (x : â„) in z.re..w.re, f (â†‘x + â†‘(w.im) * complex.I)) + complex.I â€¢ âˆ« (y : â„) in z.im..w.im, f (â†‘(w.re) + â†‘y * complex.I)) - complex.I â€¢ âˆ« (y : â„) in z.im..w.im, f (â†‘(z.re) + â†‘y * complex.I) = âˆ« (x : â„) in z.re..w.re, âˆ« (y : â„) in z.im..w.im, complex.I â€¢ â‡‘(f' (â†‘x + â†‘y * complex.I)) 1 - â‡‘(f' (â†‘x + â†‘y * complex.I)) complex.I
derangements.equiv.remove_none.fiber (option.some a) = {f : equiv.perm Î± | function.fixed_points â‡‘f âŠ† {a}}
âˆƒ (r' : Î¹ â†’ â„), (â‹ƒ (i : Î¹), metric.ball (c i) (r' i)) = set.univ âˆ§ âˆ€ (i : Î¹), r' i âˆˆ set.Ioo 0 (r i)
add_monoid.is_torsion_free â†¥H
b = âŠ¤
âˆƒ (i : set Î±), measurable_set i âˆ§ 0.restrict i â‰¤ measure_theory.vector_measure.restrict s i âˆ§ measure_theory.vector_measure.restrict s iá¶œ â‰¤ 0.restrict iá¶œ
â†‘(â‡‘(orthogonal_projection (submodule.span ğ•œ {v})) w) = (has_inner.inner v w / â†‘âˆ¥vâˆ¥ ^ 2) â€¢ v
g1 -áµ¥ g2 = g1 - g2
(nhds_within (â‡‘(ext_chart_at I c) c) (set.range â‡‘I)).has_basis (Î» (f : smooth_bump_function I c), true) (Î» (f : smooth_bump_function I c), euclidean.closed_ball (â‡‘(ext_chart_at I c) c) f.to_cont_diff_bump.to_cont_diff_bump_of_inner.R âˆ© set.range â‡‘I)
direct_sum.is_internal (Î» (i : â†¥S), submodule.torsion_by_set R M â†‘(p â†‘i))
â‡‘(direct_sum.coe_ring_hom A) (â‡‘(direct_sum.of (Î» (i : Î¹), â†¥(A i)) i) x) = â†‘x
(nhds c).has_basis (Î» (f : smooth_bump_function I c), true) (Î» (f : smooth_bump_function I c), tsupport â‡‘f)
â‡‘(euclidean_geometry.reflection s) p = â†‘(â‡‘(euclidean_geometry.orthogonal_projection s) p) -áµ¥ p +áµ¥ â†‘(â‡‘(euclidean_geometry.orthogonal_projection s) p)
â†‘(H âŠ” N) = â†‘H + â†‘N
summable f â†’ summable (Î» (x : Î±), |f x|)
f =O[l] g' â†” âˆ€á¶  (c : â„) in filter.at_top, asymptotics.is_O_with c l f g'
âˆƒ! (s : â†¥(F.val.obj (opposite.op V))), âˆ€ (i : Î¹), â‡‘(F.val.map (iUV i).op) s = sf i
measurable_embedding â‡‘e
has_inner.inner x (r â€¢ x) = r * (âˆ¥xâˆ¥ * âˆ¥xâˆ¥)
vector_span k (set.range p) = âŠ¤
(â¨† (i : Î¹), â†‘âˆ¥g iâˆ¥â‚Š) < âŠ¤
(Î» (t : Î¹), âˆ« (x : â„) in a..v t, f x âˆ‚Î¼ - âˆ« (x : â„) in a..u t, f x âˆ‚Î¼ - âˆ« (x : â„) in u t..v t, c âˆ‚Î¼) =o[lt] Î» (t : Î¹), âˆ« (x : â„) in u t..v t, 1 âˆ‚Î¼
group.nilpotency_class (Î  (i : Î·), Gs i) = finset.univ.sup (Î» (i : Î·), group.nilpotency_class (Gs i))
strict_concave_on ğ•œ ((Î» (z : E), c + z) â»Â¹' s) (f âˆ˜ Î» (z : E), c + z)
uniform_continuous â‡‘f â†” is_open â†‘(â†‘f.ker)
âˆ¥f zâˆ¥ â‰¤ C
v - â†‘(â‡‘(orthogonal_projection K) v) âˆˆ Ká—®
convex_on ğ•œ ((Î» (z : E), c + z) â»Â¹' s) (f âˆ˜ Î» (z : E), z + c)
(âˆ€ {Z : C} (g : Z âŸ¶ X), â‡‘S g â†’ J.covers R g) â†’ J.covers R f
convex â„ (f' '' s)
âˆ¥0âˆ¥ = 0
â…subgroup.pi set.univ H,subgroup.pi set.univ Kâ† â‰¤ subgroup.pi set.univ (Î» (i : Î·), â…H i,K iâ†)
is_open (â‡‘e '' (e.to_local_equiv.source âˆ© s))
strict_mono (Î» (n : â„•), f^[n] x)
f.limsup u = â¨… (s : set Î²) (H : s âˆˆ f), â¨† (a : Î²) (H : a âˆˆ s), u a
âˆƒ (x : Î±) (H : x âˆˆ s) (m : â„•) (H : m âˆˆ set.Ioo 0 n), f^[m] x âˆˆ s
(s âˆ© â‹‚ (i : Î¹), Z i).nonempty
v âˆˆ Ká—® â†” âˆ€ (u : E), u âˆˆ K â†’ has_inner.inner v u = 0
â‡‘Î¼ K < âŠ¤
âˆ€áµ (x : Î±) âˆ‚Î¼, âˆ€á¶  (n : â„•) in filter.at_top, x âˆ‰ s n
bornology.is_bounded sá¶œ â†’ bornology.is_cobounded s
fixing_submonoid M (s âˆª t) = fixing_submonoid M s âŠ“ fixing_submonoid M t
witt_vector.is_polyâ‚‚ p (Î» (R : Type u_1) (_Rcr : comm_ring R) (x y : witt_vector p R), g (f x) y)
âˆ€á¶  (r : â„) in nhds 0, metric.closed_ball x r âŠ† u
cont_mdiff_within_at I I' n f s x â†” continuous_within_at f s x âˆ§ cont_mdiff_within_at I (model_with_corners_self ğ•œ E') n (â‡‘(ext_chart_at I' (f x)) âˆ˜ f) (s âˆ© f â»Â¹' (ext_chart_at I' (f x)).source) x
âˆ€á¶  (x : E) in nhds a, has_strict_fderiv_at.implicit_function_of_complemented f f' hf hf' hker (f x) (â‡‘(has_strict_fderiv_at.implicit_to_local_homeomorph_of_complemented f f' hf hf' hker) x).snd = x
âˆ¯ (x : fin (n + 1) â†’ â„‚) in T(c, R), f x = âˆ® (x : â„‚) in C(c 0, R 0), âˆ¯ (y : fin n â†’ â„‚) in T(c âˆ˜ fin.succ, R âˆ˜ fin.succ), f (fin.cons x y)
g b - g a â‰¤ âˆ« (y : â„) in a..b, Ï† y
âˆ¥f zâˆ¥ â‰¤ C
âˆƒ (f : C(X, â„)), set.eq_on â‡‘f 0 s âˆ§ set.eq_on â‡‘f 1 t âˆ§ âˆ€ (x : X), â‡‘f x âˆˆ set.Icc 0 1
â‡‘Ïƒ '' s = s
aâº = a
(âˆ¥u - vâˆ¥ = â¨… (w : â†¥â†‘K), âˆ¥u - â†‘wâˆ¥) â†” âˆ€ (w : E), w âˆˆ K â†’ has_inner.inner (u - v) w = 0
â†‘(âŸ¨p1, hp1âŸ© -áµ¥ â‡‘(euclidean_geometry.orthogonal_projection s) p2) âˆˆ s.direction
is_open (â‡‘e '' s)
add_monoid.is_torsion â†¥(add_comm_monoid.add_torsion G)
â‡‘Î¼ (â‡‘f â»Â¹' s) = ennreal.of_real |â‡‘linear_map.det â†‘(f.symm)| * â‡‘Î¼ s
is_greatest (f '' t) (f a)
s.altitude i = affine_subspace.mk' (s.points i) ((affine_span â„ (s.points '' â†‘(finset.univ.erase i))).direction)á—® âŠ“ affine_span â„ (set.range s.points)
finset.univ.sum (Î» (x : KË£), â†‘x ^ i) = ite (fintype.card K - 1 âˆ£ i) (-1) 0
is_upper_set s â†’ is_lower_set (â‡‘order_dual.of_dual â»Â¹' s)
category_theory.presheaf.is_sheaf J (G.op â‹™ â„±.val)
âˆƒ (m : â„•) (H : m âˆˆ s) (n : â„•) (H : n âˆˆ s), m < n âˆ§ m â‰¡ n [MOD k]
â‡‘((category_theory.tensor_left_hom_equiv (X âŠ— X') Y Y' (Z âŠ— Z')).symm) ((f âŠ— g) â‰« (Î±_ Y Z Z').hom) = (Î±_ Y' X X').inv â‰« (â‡‘((category_theory.tensor_left_hom_equiv X Y Y' Z).symm) f âŠ— g)
category_theory.presieve.is_sheaf_for P â‡‘S â†” category_theory.presieve.yoneda_sheaf_condition P S
finset.univ.sum (Î» (a : Î±), fintype.card â†¥(add_action.fixed_by Î± Î² a)) = fintype.card (quotient (add_action.orbit_rel Î± Î²)) * fintype.card Î±
âˆ¥orthogonal_projection Kâˆ¥ â‰¤ 1
f âˆˆ algebra.adjoin R (add_monoid_algebra.of' R M '' â†‘(f.support))
has_dist.dist (r â€¢ v +áµ¥ pâ‚) pâ‚‚ * has_dist.dist (r â€¢ v +áµ¥ pâ‚) pâ‚‚ = has_inner.inner v v * r * r + 2 * has_inner.inner v (pâ‚ -áµ¥ pâ‚‚) * r + has_inner.inner (pâ‚ -áµ¥ pâ‚‚) (pâ‚ -áµ¥ pâ‚‚)
âˆƒá¶  (m : â„•) in filter.at_top, â‡‘Î¼ (s âˆ© f^[m] â»Â¹' s) â‰  0
âˆƒ (p : â„•), nat.prime p âˆ§ n â‰¤ p âˆ§ p â‰¡ 1 [MOD k]
â‡‘(s.orthogonal_projection_span) (r â€¢ (p2 -áµ¥ â†‘(â‡‘(s.orthogonal_projection_span) p2)) +áµ¥ p1) = âŸ¨p1, hpâŸ©
lie_module.is_weight âŠ¤ M 0
f (has_Sup.Sup s) = has_Sup.Sup (f '' s)
dense (â‹ƒ (s : set Î±) (H : s âˆˆ S), interior s)
s.sum (Î» (i : Î¹), |f i + g i| ^ p) ^ (1 / p) â‰¤ s.sum (Î» (i : Î¹), |f i| ^ p) ^ (1 / p) + s.sum (Î» (i : Î¹), |g i| ^ p) ^ (1 / p)
(x âˆˆ â¨† (i : Î¹), S i) â†” âˆƒ (i : Î¹), x âˆˆ S i
finite_dimensional.finrank K â†¥(s âŠ” t) + finite_dimensional.finrank K â†¥(s âŠ“ t) = finite_dimensional.finrank K â†¥s + finite_dimensional.finrank K â†¥t
âŠ¥.jacobson = âŠ¥
âˆƒ (t : finset G), K âŠ† â‹ƒ (g : G) (H : g âˆˆ t), (Î» (h : G), g + h) â»Â¹' V
concave_on ğ•œ ((Î» (z : E), c + z) â»Â¹' s) (f âˆ˜ Î» (z : E), c + z)
strict_convex ğ•œ (â‡‘f â»Â¹' s)
âˆƒ (Î¹ : Type u) [_inst_9 : fintype Î¹] [_inst_10 : decidable_eq Î¹] (p : Î¹ â†’ R) [_inst_11 : âˆ€ (i : Î¹), irreducible (p i)] (e : Î¹ â†’ â„•), direct_sum.is_internal (Î» (i : Î¹), submodule.torsion_by R M (p i ^ e i))
orthogonal_projection âŠ¥ = 0
âˆ«â» (x : G), f x âˆ‚Î¼ = 0 â†” f = 0
âˆ¥f'âˆ¥ â‰¤ â†‘C
(â…Ÿ A).mul A = 1
â†‘(lie_module.lower_central_series R â†¥I â†¥I k) â‰¤ â†‘(lie_module.lower_central_series R L â†¥I k)
âˆ« (y : â„) in a..b, Ï† y â‰¤ g b - g a
(exp_series ğ•‚ ğ”¸).radius = âŠ¤
set.eq_on â‡‘f â‡‘g â†‘(subfield.closure s)
affine_span k s = âŠ¤ â†” vector_span k s = âŠ¤
â†‘u âŠ† s +áµ¥ t â†’ (âˆƒ (s' : finset Î±) (t' : finset Î²), â†‘s' âŠ† s âˆ§ â†‘t' âŠ† t âˆ§ u âŠ† s' +áµ¥ t')
|has_inner.inner x y / (âˆ¥xâˆ¥ * âˆ¥yâˆ¥)| = 1 â†” x â‰  0 âˆ§ âˆƒ (r : â„), r â‰  0 âˆ§ y = r â€¢ x
âˆƒ (u : set E) (H : u âŠ‡ v) (b : basis â†¥u ğ•œ E), orthonormal ğ•œ â‡‘b âˆ§ â‡‘b = coe
âˆ€á¶  (Î´ : nnreal) in nhds_within 0 (set.Ioi 0), âˆ€ (s : set E) (f : E â†’ E), approximates_linear_on f A s Î´ â†’ â†‘m * â‡‘Î¼ s â‰¤ â‡‘Î¼ (f '' s)
Kâ‚ âŠ” Kâ‚á—® âŠ“ Kâ‚‚ = Kâ‚‚
function.injective â‡‘(polynomial.gal.gal_action_hom p E)
p2 -áµ¥ p âˆˆ s.direction â†” p2 âˆˆ s
(Î» (i : Î¹), âˆ« (x : Î±) in s i, f x âˆ‚Î¼ - m i â€¢ f a) =o[li] m
has_deriv_at f f' x â†’ has_fderiv_at f (1.smul_right f') x
á˜(f â‰« g) = á˜g â‰« á˜f
is_lub (s âˆª t) (a âŠ” b)
is_compact (coe_fn '' s)
âˆƒ (t : set Î±), measurable_set t âˆ§ â‡‘Î¼ t â‰¤ ennreal.of_real Îµ âˆ§ tendsto_uniformly_on f g filter.at_top tá¶œ
finsupp.map_domain â‡‘f (x * y) = finsupp.map_domain â‡‘f x * finsupp.map_domain â‡‘f y
âˆƒ (ns : â„• â†’ â„•), strict_mono ns âˆ§ âˆ€áµ (x : Î±) âˆ‚Î¼, filter.tendsto (Î» (i : â„•), f (ns i) x) filter.at_top (nhds (g x))
has_fpower_series_on_ball f p x âŠ¤
asymptotics.is_O_with c l (Î» (x : Î±), âˆ¥f' xâˆ¥) (Î» (x : Î±), âˆ¥g' xâˆ¥) â†’ asymptotics.is_O_with c l f' g'
is_topological_fiber_bundle F (Î» (x : â†¥{p : B' Ã— Z | f p.fst = proj p.snd}), â†‘x.fst)
A.det = finset.univ.sum (Î» (i : fin n.succ), (-1) ^ (â†‘i + â†‘j) * A i j * (A.minor â‡‘(i.succ_above) â‡‘(j.succ_above)).det)
function.bijective â‡‘f
âˆ€á¶  (y : E) in nhds c, âˆ¥f yâˆ¥ = âˆ¥f câˆ¥
asymptotics.is_O_with c l f g' â†’ asymptotics.is_O_with c l f (Î» (x : Î±), âˆ¥g' xâˆ¥)
â†‘1 = is_localization.coe_submodule P âŠ¤
cont_mdiff_on I I' n f s â†” continuous_on f s âˆ§ âˆ€ (y : M'), cont_mdiff_on I (model_with_corners_self ğ•œ E') n (â‡‘(ext_chart_at I' y) âˆ˜ f) (s âˆ© f â»Â¹' (ext_chart_at I' y).source)
a â‹– b â†’ â†‘a â‹– â†‘b
group.is_nilpotent G â†” âˆƒ (n : â„•), lower_central_series G n = âŠ¥
has_faithful_smul Î± (Î  (i : I), f i)
â‡‘f p = â‡‘g q â†’ (âˆƒ (s : â†¥(category_theory.limits.pullback f g)), â‡‘category_theory.limits.pullback.fst s = p âˆ§ â‡‘category_theory.limits.pullback.snd s = q)
nonempty (V â‰ƒâ‚—[K] Vâ‚)
âˆ€á¶  (t : R) in nhds 0, ring.inverse (â†‘x + t) = ring.inverse (1 + â†‘xâ»Â¹ * t) * â†‘xâ»Â¹
(((âˆ« (x : â„) in z.re..w.re, f (â†‘x + â†‘(z.im) * complex.I)) - âˆ« (x : â„) in z.re..w.re, f (â†‘x + â†‘(w.im) * complex.I)) + complex.I â€¢ âˆ« (y : â„) in z.im..w.im, f (â†‘(w.re) + â†‘y * complex.I)) - complex.I â€¢ âˆ« (y : â„) in z.im..w.im, f (â†‘(z.re) + â†‘y * complex.I) = 0
measure_theory.strongly_measurable (Î» (x : Î±), âˆ« (y : Î²), f x y âˆ‚Î½)
galois_connection (Î» (I : ideal A), projective_spectrum.zero_locus ğ’œ â†‘I) (Î» (t : (set (projective_spectrum ğ’œ))áµ’áµˆ), (projective_spectrum.vanishing_ideal t).to_ideal)
function.injective â‡‘f
âˆ¥x - yâˆ¥ * âˆ¥x - yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ - 2 * has_inner.inner x y + âˆ¥yâˆ¥ * âˆ¥yâˆ¥
summable (Î» (i : Î¹), (f i + g i) ^ p) âˆ§ (âˆ‘' (i : Î¹), (f i + g i) ^ p) ^ (1 / p) â‰¤ (âˆ‘' (i : Î¹), f i ^ p) ^ (1 / p) + (âˆ‘' (i : Î¹), g i ^ p) ^ (1 / p)
filter.tendsto (Î» (i : Î¹), âˆ« (x : Î±) in s i, f x âˆ‚Î¼) l (nhds 0)
(â¨… (i : Î¹), s i) = â¨… (t : finset Î¹) (i : Î¹) (H : i âˆˆ t), s i
t2_space (L â‰ƒâ‚[K] L)
âˆƒ (C : â„), 0 < C âˆ§ âˆ€ (x : E), âˆ¥â‡‘f xâˆ¥ â‰¤ C * âˆ¥xâˆ¥
open_embedding â‡‘e
âˆƒ (Î± Î² : Type) (IÎ± : topological_space Î±) (IÎ² : topological_space Î²), compact_space Î± âˆ§ t1_space Î² âˆ§ âˆƒ (f : Î± â‰ƒ Î²), continuous â‡‘f âˆ§ Â¬continuous â‡‘(f.symm)
(Î» (x : â„), x ^ s) =o[filter.at_top] Î» (x : â„), real.exp (b * x)
âŠ¥.fixing_subgroup = âŠ¤
â‡‘g âˆ˜ â‡‘f = â‡‘(f â‰« g)
measure_theory.mem_â„’p â‡‘(measure_theory.Lp.simple_func.to_simple_func f) p Î¼
âˆƒ (b : â†¥M), is_localization.is_integer R (â†‘b â€¢ a)
measure_theory.mem_â„’p.to_Lp â‡‘(c â€¢ f) _ = c â€¢ measure_theory.mem_â„’p.to_Lp â‡‘f _
âˆ«â» (a : Î±), (â¨… (n : â„•), f n a) âˆ‚Î¼ = â¨… (n : â„•), âˆ«â» (a : Î±), f n a âˆ‚Î¼
filter.tendsto (Î» (n : â„•), âˆ«â» (a : Î±), â†‘(â‡‘(thickened_indicator _ F) a) âˆ‚â†‘Î¼) filter.at_top (nhds (â‡‘â†‘Î¼ F))
âˆƒ (f : Î  (a : Î±), Î² a), âˆ€ (x : Î±), R x (f x)
(((âˆ« (x : â„) in z.re..w.re, f (â†‘x + â†‘(z.im) * complex.I)) - âˆ« (x : â„) in z.re..w.re, f (â†‘x + â†‘(w.im) * complex.I)) + complex.I â€¢ âˆ« (y : â„) in z.im..w.im, f (â†‘(w.re) + â†‘y * complex.I)) - complex.I â€¢ âˆ« (y : â„) in z.im..w.im, f (â†‘(z.re) + â†‘y * complex.I) = 0
â‡‘(f â‰« g) a = â‡‘g (â‡‘f a)
a âŠ” has_Inf.Inf s â‰¤ â¨… (b : Î±) (H : b âˆˆ s), a âŠ” b
âˆ® (z : â„‚) in C(c, R), (z - w)â»Â¹ â€¢ f z = (2 * â†‘real.pi * complex.I) â€¢ f w
âˆƒ! (s : â†¥(F.val.obj (opposite.op (supr U)))), F.val.is_gluing U sf s
(âˆ€á¶  (s : set Î±) in l.small_sets, âˆ€ (x : Î±), x âˆˆ s â†’ p x) â†’ (âˆ€á¶  (x : Î±) in l, p x)
metric.bounded s â†” emetric.diam s â‰  âŠ¤
A.topological_closure = âŠ¤
|has_inner.inner x (r â€¢ x)| / (âˆ¥xâˆ¥ * âˆ¥r â€¢ xâˆ¥) = 1
affine_span k set.univ = âŠ¤
(polynomial_functions (set.Icc a b)).topological_closure = âŠ¤
bdd_above s â†’ bdd_above (f '' s)
has_inner.inner x (r â€¢ x) / (âˆ¥xâˆ¥ * âˆ¥r â€¢ xâˆ¥) = -1
(â…Ÿ A).mul (A.mul B) = B
algebra.discr â„š â‡‘((is_primitive_root.sub_one_power_basis â„š hÎ¶).basis) = (-1) ^ ((â†‘p ^ (k + 1)).totient / 2) * â†‘p ^ (â†‘p ^ k * ((â†‘p - 1) * (k + 1) - 1))
âˆƒ (t : finset Î±), â†‘t âŠ† s âˆ§ â‡‘Î¼ (s  â‹ƒ (x : Î±) (H : x âˆˆ t), metric.closed_ball x (r x)) â‰¤ â†‘N / (â†‘N + 1) * â‡‘Î¼ s âˆ§ â†‘t.pairwise_disjoint (Î» (x : Î±), metric.closed_ball x (r x))
witt_vector.is_poly p (Î» (R : Type u_1) (_Rcr : comm_ring R), â‡‘witt_vector.verschiebung)
(category_theory.subobject.map g).obj (fâ‚ âŠ“ fâ‚‚) = (category_theory.subobject.map g).obj fâ‚ âŠ“ (category_theory.subobject.map g).obj fâ‚‚
â‡‘is_R_or_C.re (has_inner.inner x y) = (âˆ¥x + yâˆ¥ * âˆ¥x + yâˆ¥ - âˆ¥x - yâˆ¥ * âˆ¥x - yâˆ¥) / 4
âˆ€á¶  (t : Î¹) in lt, interval_integrable f Î¼ (u t) (v t)
tendsto_locally_uniformly F f p â†” âˆ€ (Îµ : ennreal), Îµ > 0 â†’ âˆ€ (x : Î²), âˆƒ (t : set Î²) (H : t âˆˆ nhds x), âˆ€á¶  (n : Î¹) in p, âˆ€ (y : Î²), y âˆˆ t â†’ has_edist.edist (f y) (F n y) < Îµ
â‡‘(ideal.quotient.mk I) â»Â¹' (â‡‘(ideal.quotient.mk I) '' s) = â‹ƒ (x : â†¥I), (Î» (y : R), x.val + y) '' s
â‡‘f (Î» (i : Î¹), (A i).sum (Î» (j : Î± i), g i j)) = (fintype.pi_finset A).sum (Î» (r : Î  (a : Î¹), Î± a), â‡‘f (Î» (i : Î¹), g i (r i)))
finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ g '' s), f i)) = finsum (Î» (j : Î²), finsum (Î» (H : j âˆˆ s), f (g j)))
convex_on ğ•œ (â‡‘g â»Â¹' s) (f âˆ˜ â‡‘g)
finsupp.map_domain â‡‘f 1 = 1
(category_theory.nat_trans.left_derived Î± n).app X = (F.left_derived_obj_iso n P).hom â‰« (homology_functor D (complex_shape.down â„•) n).map ((category_theory.nat_trans.map_homological_complex Î± (complex_shape.down â„•)).app P.complex) â‰« (G.left_derived_obj_iso n P).inv
pairwise (disjoint on Î» (n : Î±), set.Ioc (f n) (f (order.pred n)))
function.right_inverse coe â‡‘cardinal.to_nat
âˆ¥box_integral.integral I l f Î¼.to_box_additive.to_smulâˆ¥ â‰¤ box_integral.integral I l g Î¼.to_box_additive.to_smul
is_greatest (f '' s) (f a)
X.Î´ i.succ â‰« X.Ïƒ (â‡‘fin.cast_succ j) = X.Ïƒ j â‰« X.Î´ i
âˆƒ (t : set Î±) (r : Î± â†’ â„), t.countable âˆ§ t âŠ† s âˆ§ (âˆ€ (x : Î±), x âˆˆ t â†’ r x âˆˆ f x âˆ© set.Ioo 0 (R x)) âˆ§ â‡‘Î¼ (s  â‹ƒ (x : Î±) (H : x âˆˆ t), metric.closed_ball x (r x)) = 0 âˆ§ t.pairwise_disjoint (Î» (x : Î±), metric.closed_ball x (r x))
|real.log x * x| < 1
quotient.mk â»Â¹' (quotient.mk '' U) = â‹ƒ (a : Î±), has_scalar.smul a '' U
âˆ€á¶  (p : F Ã— â†¥(f'.ker)) in nhds (f a, 0), f (has_strict_fderiv_at.implicit_function_of_complemented f f' hf hf' hker p.fst p.snd) = p.fst
has_deriv_at_filter f f' x L â†” filter.tendsto (slope f x) (L âŠ“ filter.principal {x}á¶œ) (nhds f')
âˆ® (z : â„‚) in C(c, R), f' z = 0
âˆ«â» (a : Î²), f a âˆ‚measure_theory.measure.map â‡‘g Î¼ = âˆ«â» (a : Î±), f (â‡‘g a) âˆ‚Î¼
v âˆˆ s.direction â†” âˆƒ (p2 : P) (H : p2 âˆˆ s), v = p -áµ¥ p2
g (âˆ« (x : Î±), f x âˆ‚Î¼) â‰¤ âˆ« (x : Î±), g (f x) âˆ‚Î¼
is_integral_closure â†¥(algebra.adjoin â„¤ {Î¶}) â„¤ K
|y - x| â‰¤ |b - a|
âˆ¥fderiv ğ•œ f xâ‚€âˆ¥ â‰¤ â†‘C
âˆ€á¶  (x : Î±) in nhds xâ‚€, âˆ€ (y : Î²), y âˆˆ K â†’ P x y
cardinal.mk â†¥{t : set Î± | measurable_space.generate_measurable s t} â‰¤ cardinal.continuum
â…subgroup.pi set.univ H,subgroup.pi set.univ Kâ† = subgroup.pi set.univ (Î» (i : Î·), â…H i,K iâ†)
âˆƒ (t : Î¹ â†’ set Î±), (âˆ€ (i : Î¹), measurable_set (t i)) âˆ§ (âˆ€ (i : Î¹), â‡‘Î¼ (t i) = 0) âˆ§ pairwise (disjoint on Î» (i : Î¹), s i  t i)
s.sum (Î» (x : Î±), f x) = (finset.image quotient.mk s).sum (Î» (xbar : quotient R), (finset.filter (Î» (y : Î±), âŸ¦yâŸ§ = xbar) s).sum (Î» (y : Î±), f y))
f â‰« g = f â‹™ g
âˆƒ (M : â„), âˆ«â» (x : Î±), â†‘âˆ¥{x : Î± | M â‰¤ â†‘âˆ¥f xâˆ¥â‚Š}.indicator f xâˆ¥â‚Š âˆ‚Î¼ â‰¤ ennreal.of_real Îµ
n.factorization.prod (Î» (p k : â„•), f p) = n.factors.to_finset.prod (Î» (p : â„•), f p)
function.injective (Î» (b : Î²) (a : Î±), f a b)
âˆ¥x + yâˆ¥ < âˆ¥xâˆ¥ + âˆ¥yâˆ¥
interval_integrable F' Î¼ a b âˆ§ has_deriv_at (Î» (x : ğ•œ), âˆ« (t : â„) in a..b, F x t âˆ‚Î¼) (âˆ« (t : â„) in a..b, F' t âˆ‚Î¼) xâ‚€
(fintype.card â†¥Hâ‚).coprime (fintype.card â†¥Hâ‚‚)
measure_theory.ae_strongly_measurable' m â‡‘f Î¼ â†’ P f
(x â¨¿ y) = x âŠ” y
galois_connection (Î» (s : set R), prime_spectrum.zero_locus s) (Î» (t : (set (prime_spectrum R))áµ’áµˆ), â†‘(prime_spectrum.vanishing_ideal t))
category_theory.is_pushout hâ‚â‚ (vâ‚â‚ â‰« vâ‚‚â‚) (vâ‚â‚‚ â‰« vâ‚‚â‚‚) hâ‚ƒâ‚
âˆ¥f x - f aâˆ¥ â‰¤ C * (x - a)
Â¬linear_independent R (v âˆ˜ coe) â†” âˆƒ (f : Î¹ â†’â‚€ R), f âˆˆ finsupp.supported R R s âˆ§ f.support.sum (Î» (i : Î¹), â‡‘f i â€¢ v i) = 0 âˆ§ f â‰  0
âŠ¥.is_SRG_with (fintype.card V) 0 â„“ 0
filter.tendsto F p (nhds f) â†” tendsto_uniformly (Î» (i : Î¹) (a : Î±), â‡‘(F i) a) â‡‘f p
is_countably_spanning (set.univ.pi '' set.univ.pi C)
is_closed (coe_fn '' metric.closed_ball fâ‚€ r)
smooth I (model_with_corners_self â„ â„) â‡‘f
cardinal.mk â†¥(set.Icc a b) = cardinal.continuum
(â‡‘(bâ‚.repr) x).sum (Î» (i : Î¹â‚) (xi : R), (â‡‘(bâ‚‚.repr) y).sum (Î» (j : Î¹â‚‚) (yj : S), â‡‘Ïâ‚â‚‚ xi â€¢ â‡‘Ïƒâ‚â‚‚ yj â€¢ â‡‘(â‡‘B (â‡‘bâ‚ i)) (â‡‘bâ‚‚ j))) = â‡‘(â‡‘B x) y
âˆ€áµ (x : Î²) âˆ‚Î¼, filter.tendsto (Î» (r : â„), â‡‘Î¼ (s âˆ© metric.closed_ball x r) / â‡‘Î¼ (metric.closed_ball x r)) (nhds_within 0 (set.Ioi 0)) (nhds (s.indicator 1 x))
is_least s a â†’ is_greatest (f '' s) (f a)
[is_galois F E, intermediate_field.fixed_field âŠ¤ = âŠ¥, fintype.card (E â‰ƒâ‚[F] E) = finite_dimensional.finrank F E, âˆƒ (p : polynomial F), p.separable âˆ§ polynomial.is_splitting_field F E p].tfae
dense (â‹‚ (s : Î²), f s)
category_theory.limits.image.Î¹ f = (category_theory.limits.image.eq_to_iso h).hom â‰« category_theory.limits.image.Î¹ f'
âˆ€áµ (x : E) âˆ‚Î¼.restrict s, âˆ¥f' x - Aâˆ¥â‚Š â‰¤ Î´
star_convex ğ•œ (â‡‘f x) (â‡‘f '' s)
set.eq_on f 0 (complex.im â»Â¹' set.Icc a b)
category_theory.non_preadditive_abelian.Ïƒ â‰« f = category_theory.limits.prod.map f f â‰« category_theory.non_preadditive_abelian.Ïƒ
âˆƒ (y : O) (H : y âˆˆ M) (a : R) (hay : a â€¢ y âˆˆ N) (M' : submodule R O) (H : M' â‰¤ M) (N' : submodule R O) (H : N' â‰¤ N) (N'_le_M' : N' â‰¤ M') (y_ortho_M' : âˆ€ (c : R) (z : O), z âˆˆ M' â†’ c â€¢ y + z = 0 â†’ c = 0) (ay_ortho_N' : âˆ€ (c : R) (z : O), z âˆˆ N' â†’ c â€¢ a â€¢ y + z = 0 â†’ c = 0), âˆ€ (n' : â„•) (bN' : basis (fin n') R â†¥N'), âˆƒ (bN : basis (fin (n' + 1)) R â†¥N), âˆ€ (m' : â„•) (hn'm' : n' â‰¤ m') (bM' : basis (fin m') R â†¥M'), âˆƒ (hnm : n' + 1 â‰¤ m' + 1) (bM : basis (fin (m' + 1)) R â†¥M), âˆ€ (as : fin n' â†’ R), (âˆ€ (i : fin n'), â†‘(â‡‘bN' i) = as i â€¢ â†‘(â‡‘bM' (â‡‘(fin.cast_le hn'm') i))) â†’ (âˆƒ (as' : fin (n' + 1) â†’ R), âˆ€ (i : fin (n' + 1)), â†‘(â‡‘bN i) = as' i â€¢ â†‘(â‡‘bM (â‡‘(fin.cast_le hnm) i)))
âˆƒ (f : (Î  (n : â„•), E n) â†’ Î  (n : â„•), E n), (âˆ€ (x : Î  (n : â„•), E n), x âˆˆ s â†’ f x = x) âˆ§ set.range f = s âˆ§ lipschitz_with 1 f
filter.tendsto f (nhds_within c {c}á¶œ) (nhds (lim (nhds_within c {c}á¶œ) f))
monoid.is_torsion â†¥(comm_monoid.torsion G)
âˆ¥â‡‘f mâ‚ - â‡‘f mâ‚‚âˆ¥ â‰¤ âˆ¥fâˆ¥ * â†‘(fintype.card Î¹) * linear_order.max âˆ¥mâ‚âˆ¥ âˆ¥mâ‚‚âˆ¥ ^ (fintype.card Î¹ - 1) * âˆ¥mâ‚ - mâ‚‚âˆ¥
âˆƒ (F : circle_deg1_lift), function.semiconj â‡‘F â‡‘fâ‚ â‡‘fâ‚‚
is_pi_system (set.univ.pi '' set.univ.pi C)
âˆƒ (g : Î± â†’ nnreal), (âˆ€ (x : Î±), g x â‰¤ â‡‘f x) âˆ§ upper_semicontinuous g âˆ§ âˆ«â» (x : Î±), â†‘(â‡‘f x) âˆ‚Î¼ â‰¤ âˆ«â» (x : Î±), â†‘(g x) âˆ‚Î¼ + Îµ
âˆƒ (w : set E) (b : hilbert_basis â†¥w ğ•œ E), s âŠ† w âˆ§ â‡‘b = coe
âˆƒ (g : F â†’L[ğ•œ] ğ•œ), (âˆ€ (x : â†¥p), â‡‘g â†‘x = â‡‘f x) âˆ§ âˆ¥gâˆ¥ = âˆ¥fâˆ¥
category_theory.is_pushout (hâ‚â‚ â‰« hâ‚â‚‚) vâ‚â‚ vâ‚â‚ƒ (hâ‚‚â‚ â‰« hâ‚‚â‚‚)
fintype.card â†¥P = p ^ â‡‘((fintype.card G).factorization) p
witt_vector.is_polyâ‚‚ p (Î» (R : Type u_1) (_Rcr : comm_ring R) (x y : witt_vector p R), g x (f y))
metric.bounded (â‹ƒ (i : Î²) (H : i âˆˆ I), s i) â†” âˆ€ (i : Î²), i âˆˆ I â†’ metric.bounded (s i)
â‡‘Î¼ s < âŠ¤
âˆƒ (i : Î¹), nonempty (Î  (j : Î¹), Î² i â†ª Î² j)
(Î» (t : Î¹), ((âˆ« (x : â„) in a..v t, f x) - âˆ« (x : â„) in a..u t, f x) - (v t - u t) â€¢ c) =o[lt] (v - u)
is_pi_system (set.univ.pi '' set.univ.pi (Î» (i : Î¹), {s : set (Î± i) | measurable_set s}))
â‡‘(euclidean_geometry.reflection s) (v +áµ¥ p) = -v +áµ¥ p
analytic_on ğ•œ (deriv^[n] f) s
âˆ¥f.mk_normed_group_hom C hâˆ¥ â‰¤ C
âˆ€áµ (Ï‰ : Î©), filter.tendsto (Î» (n : â„•), (finset.range n).sum (Î» (i : â„•), X i Ï‰) / â†‘n) filter.at_top (nhds (âˆ« (a : Î©), X 0 a))
â†‘(â‡‘(euclidean_geometry.orthogonal_projection s) p) âˆˆ affine_subspace.mk' p (s.direction)á—®
measure_theory.simple_func.integral Î¼ f = s.sum (Î» (x : F), (â‡‘Î¼ (â‡‘f â»Â¹' {x})).to_real â€¢ x)
has_ftaylor_series_up_to_on n (f âˆ˜ â‡‘g) (Î» (x : G) (k : â„•), (p (â‡‘g x) k).comp_continuous_linear_map (Î» (_x : fin k), g)) (â‡‘g â»Â¹' s)
function.injective â‡‘(algebra_map Râ‚˜ Sâ‚˜)
measure_theory.vadd_invariant_measure G (G â§¸ Î“) (measure_theory.measure.map quotient_add_group.mk (Î¼.restrict ğ“•))
module.is_torsion' â†¥(submodule.torsion' R M S) S
s.prod (Î» (x : Î±), f x) = (finset.image quotient.mk s).prod (Î» (xbar : quotient R), (finset.filter (Î» (y : Î±), âŸ¦yâŸ§ = xbar) s).prod (Î» (y : Î±), f y))
f.srange = âŠ¤
âˆ« (x : E) in f '' s, g x âˆ‚Î¼ = âˆ« (x : E) in s, |(f' x).det| â€¢ g (f x) âˆ‚Î¼
â‡‘Î¼ {x : Î± | v.lim_ratio_meas hÏ x = âŠ¤} = 0
â‡‘f xâ‚ + â†‘-â‡‘(is_add_unit.lift_right (f.restrict S) h) yâ‚ = â‡‘f xâ‚‚ + â†‘-â‡‘(is_add_unit.lift_right (f.restrict S) h) yâ‚‚ â†” â‡‘f (xâ‚ + â†‘yâ‚‚) = â‡‘f (xâ‚‚ + â†‘yâ‚)
o.oangle x y = Î¸ â†” y = (âˆ¥yâˆ¥ / âˆ¥xâˆ¥) â€¢ â‡‘(o.rotation Î¸) x
(setoid.ker f).rel x y â†” x âˆˆ f â»Â¹' {f y}
âˆ€áµ (Ï‰ : Î©), filter.tendsto (Î» (n : â„•), (finset.range n).sum (Î» (i : â„•), X i Ï‰) / â†‘n) filter.at_top (nhds (âˆ« (a : Î©), X 0 a))
â‡‘(euclidean_geometry.orthogonal_projection s) (r â€¢ (p2 -áµ¥ â†‘(â‡‘(euclidean_geometry.orthogonal_projection s) p2)) +áµ¥ p1) = âŸ¨p1, hpâŸ©
(measure_theory.measure.map f Î¼).restrict s = measure_theory.measure.map f (Î¼.restrict (f â»Â¹' s))
finite_dimensional K â†¥(E1 âŠ” E2)
â‡‘((ext_chart_at I x).symm) â»Â¹' t âˆˆ nhds_within (â‡‘(ext_chart_at I x) x) (â‡‘((ext_chart_at I x).symm) â»Â¹' s âˆ© set.range â‡‘I)
closed_embedding â‡‘f
pairwise (disjoint on Î» (n : Î±), set.Ioc (f n) (f (order.succ n)))
function.injective â‡‘f â†” âˆ€ (a : G), â‡‘f a = 0 â†” a = 0
âˆ¥f zâˆ¥ â‰¤ C
âˆ¥a â€¢ x + b â€¢ yâˆ¥ < r
bornology.is_bounded s â†’ bounded_space â†¥s
f '' s âŠ† t â†” s âŠ† f â»Â¹' t
(Î» (t : R), ring.inverse (â†‘x + t) - â†‘xâ»Â¹) =O[nhds 0] Î» (t : R), âˆ¥tâˆ¥
âˆ€á¶  (t : set (Î± Ã— Î±)) in (uniformity Î±).small_sets, comp_rel t^[n] t âŠ† s
â‡‘Î¼ (r â€¢ s) = ennreal.of_real |r ^ finite_dimensional.finrank â„ E| * â‡‘Î¼ s
âŠ¥.direction = âŠ¥
âˆ¥x + yâˆ¥ ^ 2 = âˆ¥xâˆ¥ ^ 2 + 2 * â‡‘is_R_or_C.re (has_inner.inner x y) + âˆ¥yâˆ¥ ^ 2
has_deriv_at (Î» (u : â„), âˆ« (x : â„) in u..b, f x) (-f a) a
x âˆˆ set.Icc a b â†’ âˆ¥f xâˆ¥ â‰¤ B x
category_theory.preadditive_coyoneda â‹™ (category_theory.whiskering_right C AddCommGroup (Type v)).obj (category_theory.forget AddCommGroup) = category_theory.coyoneda
is_poly â‡‘f
dimH (f '' s) â‰¤ dimH s / â†‘r
is_compact (coe_fn '' metric.closed_ball fâ‚€ r)
â‡‘Î¼ U = â¨† (K : set Î±) (h : K âŠ† U) (h2 : is_compact K), â‡‘Î¼ K
(has_Inf.Inf s).rel = has_Inf.Inf (setoid.rel '' s)
category_theory.limits.biprod.fst â‰« category_theory.limits.biprod.inl + category_theory.limits.biprod.snd â‰« category_theory.limits.biprod.inr = ğŸ™ (X âŠ Y)
âŠ¥ = âŠ¤
f âˆˆ submodule.span k (add_monoid_algebra.of' k G '' â†‘(f.support))
âˆƒ (C : â„) (H : C > 0), âˆ€ {u : E â†’L[ğ•œ] F} {M : â„}, 0 â‰¤ M â†’ (âˆ€ (i : Î¹), âˆ¥â‡‘u (â‡‘v i)âˆ¥ â‰¤ M) â†’ âˆ¥uâˆ¥ â‰¤ C * M
â‡‘((ext_chart_at I x).symm) â»Â¹' (s âˆ© t) âˆ© set.range â‡‘I = â‡‘((ext_chart_at I x).symm) â»Â¹' s âˆ© set.range â‡‘I âˆ© â‡‘((ext_chart_at I x).symm) â»Â¹' t
subring.map f (subring.closure s) = subring.closure (â‡‘f '' s)
category_theory.is_iso (algebraic_geometry.PresheafedSpace.stalk_map (algebraic_geometry.Spec.to_PresheafedSpace.map (CommRing.of_hom (algebra_map â†¥R (localization M))).op) x)
filter.tendsto (Î» (n : â„•), âˆ«â» (a : Î±), â†‘(â‡‘(fs n) a) âˆ‚â†‘Î¼) filter.at_top (nhds (â‡‘â†‘Î¼ E))
âˆƒ (Î¹ : Type uâ‚) [_inst_3 : fintype Î¹] (C : Î¹ â†’ set Î±) (hC : âˆ€ (i : Î¹), is_compact (C i)) (U : Î¹ â†’ set Î²) (hU : âˆ€ (i : Î¹), is_open (U i)), (f âˆˆ â‹‚ (i : Î¹), continuous_map.compact_open.gen (C i) (U i)) âˆ§ (â‹‚ (i : Î¹), continuous_map.compact_open.gen (C i) (U i)) âŠ† continuous_map.compact_conv_nhd K V f
âŠ¤ - â†‘r = âŠ¤
(a âŠ” u)  v âˆˆ s
p1 -áµ¥ p2 âˆˆ s.direction
category_theory.limits.cokernel.map f f' p q hâ‚ â‰« category_theory.limits.cokernel.desc f' g' w' = category_theory.limits.cokernel.desc f g w â‰« r
â‡‘Î¼ s = â‡‘Î¼ (s âˆ© f â»Â¹' {0}) + â‡‘Î¼ (s âˆ© f â»Â¹' {âŠ¤}) + âˆ‘' (n : â„¤), â‡‘Î¼ (s âˆ© f â»Â¹' set.Ico (â†‘t ^ n) (â†‘t ^ (n + 1)))
vector_span k â†‘s = submodule.span k â†‘(finset.image (Î» (_x : P), _x -áµ¥ p) (s.erase p))
âˆ¯ (x : fin (n + 1) â†’ â„‚) in T(c, R), f x = âˆ® (x : â„‚) in C(c i, R i), âˆ¯ (y : fin n â†’ â„‚) in T(c âˆ˜ â‡‘(i.succ_above), R âˆ˜ â‡‘(i.succ_above)), f (i.insert_nth x y)
(â¨† (x : X) (H : x âˆˆ s), (nhds_within x s).small_sets.limsup dimH) = dimH s
coe '' mul_action.orbit R m = mul_action.orbit R â†‘m
is_least (f '' t) (f a)
strict_convex ğ•œ (x +áµ¥ s)
(2 * â†‘real.pi * complex.I)â»Â¹ â€¢ âˆ® (z : â„‚) in C(c, R), (z - w)â»Â¹ â€¢ f z = f w
is_connected (â‹ƒ (n : Î²) (H : n âˆˆ t), s n)
is_submonoid (f '' s)
finite_dimensional.finrank K (V â†’â‚—[K] W) = finite_dimensional.finrank K V * finite_dimensional.finrank K W
is_cyclotomic_extension S A â†¥(algebra.adjoin A {b : B | âˆƒ (a : â„•+), a âˆˆ S âˆ§ b ^ â†‘a = 1})
n â‰  0 â†’ â‡‘f n = n.factorization.prod (Î» (p k : â„•), â‡‘f (p ^ k))
orthonormal â„ â‡‘(e.adjust_to_orientation x)
(Î» (x : Î±), c) =O[l] f' â†” âˆƒ (b : â„), 0 < b âˆ§ âˆ€á¶  (x : Î±) in l, b â‰¤ âˆ¥f' xâˆ¥
âˆ€á¶  (r : â„) in nhds_within 0 (set.Ioi 0), (s âˆ© ({x} + r â€¢ t)).nonempty
âˆ¥f y - f xâˆ¥ â‰¤ C * âˆ¥y - xâˆ¥
f.range < âŠ¤
category_theory.limits.image.pre_comp f (g â‰« h) â‰« category_theory.limits.image.pre_comp g h = category_theory.limits.image.eq_to_hom _ â‰« category_theory.limits.image.pre_comp (f â‰« g) h
âˆ¥f - gâˆ¥ = (âˆ«â» (x : Î±), â†‘âˆ¥â‡‘f x - â‡‘g xâˆ¥â‚Š âˆ‚Î¼).to_real
âˆ¥a ^ nâˆ¥â‚Š â‰¤ âˆ¥aâˆ¥â‚Š ^ n
J = âŠ¤
âˆ« (x : fin (n + 1) â†’ â„) in â‡‘box_integral.box.Icc I, finset.univ.sum (Î» (i : fin (n + 1)), â‡‘(f' x) (pi.single i 1) i) = finset.univ.sum (Î» (i : fin (n + 1)), (âˆ« (x : fin n â†’ â„) in â‡‘box_integral.box.Icc (I.face i), f (i.insert_nth (I.upper i) x) i) - âˆ« (x : fin n â†’ â„) in â‡‘box_integral.box.Icc (I.face i), f (i.insert_nth (I.lower i) x) i)
|â†‘g 1 0| â‰¤ 1
continuous â‡‘f
(âˆ€ (i : Î¹), i âˆˆ I â†’ is_metric_separated s (t i)) â†’ is_metric_separated s (â‹ƒ (i : Î¹) (H : i âˆˆ I), t i)
cont_mdiff_within_at I I'' n (g âˆ˜ f) (s âˆ© f â»Â¹' t) x
(Î± â‰« Î²).c.app U = Î².c.app U â‰« Î±.c.app (opposite.op ((topological_space.opens.map Î².base).obj (opposite.unop U)))
cardinal.mk â†¥(set.Ioo a b) = cardinal.continuum
(has_Inf.Inf m).restrict t = has_Inf.Inf ((Î» (Î¼ : measure_theory.measure Î±), Î¼.restrict t) '' m)
orthonormal ğ•œ â‡‘(direct_sum.is_internal.subordinate_orthonormal_basis hn hV)
tendsto_locally_uniformly_on (Î» (n : â„•) (y : E), p.partial_sum n y) (Î» (y : E), f (x + y)) filter.at_top (emetric.ball 0 r)
âˆƒ (I : lie_ideal R â†¥K), â†‘I = lie_subalgebra.of_le hâ‚
âˆ¥(finset.range n).sum (Î» (x : â„•), f x) - aâˆ¥ â‰¤ C * r ^ n / (1 - r)
âˆ« (x : G), f x âˆ‚Î¼ = 0
f.srange = âŠ¤
measure_theory.strongly_measurable (Î» (y : Î²), âˆ« (x : Î±), f x y âˆ‚Î¼)
(measure_theory.measure.map â‡‘(quotient_add_group.mk' Î“) (Î¼.restrict ğ“•)).is_add_left_invariant
cont_diff_on ğ•œ âŠ¤ fâ‚‚ sâ‚‚ â†” differentiable_on ğ•œ fâ‚‚ sâ‚‚ âˆ§ cont_diff_on ğ•œ âŠ¤ (deriv fâ‚‚) sâ‚‚
vector.scanl f b vector.nil = b::áµ¥vector.nil
Â¬continuous â‡‘(cofinite_topology.of.symm)
âˆ€áµ (Ï‰ : Î©), (Î» (n : â„•), (finset.range n).sum (Î» (i : â„•), probability_theory.truncation (X i) â†‘i Ï‰) - (finset.range n).sum (Î» (i : â„•), X i Ï‰)) =o[filter.at_top] Î» (n : â„•), â†‘n
(Î» (i : Î¹), âˆ« (x : Î±) in s i, f x âˆ‚Î¼ - m i â€¢ f a) =o[li] m
metric.thickening Î´ E = (Î» (x : Î±), emetric.inf_edist x E) â»Â¹' set.Iio (ennreal.of_real Î´)
p i âˆ‰ affine_span k (p '' (s  {i}))
âˆ«â» (x : Î±), âˆ«â» (y : Î²), f x y âˆ‚Î½ âˆ‚Î¼ = âˆ«â» (z : Î² Ã— Î±), f z.snd z.fst âˆ‚Î½.prod Î¼
affine_independent k (Î» (p : â†¥s), â†‘p) â†” linear_independent k (Î» (v : â†¥((Î» (p : P), p -áµ¥ pâ‚) '' (s  {pâ‚}))), â†‘v)
â‡‘(algebra_map K E) (algebra.discr K â‡‘(pb.basis)) = finset.univ.prod (Î» (i : fin pb.dim), (finset.filter (Î» (j : fin pb.dim), i < j) finset.univ).prod (Î» (j : fin pb.dim), (â‡‘(â‡‘e j) pb.gen - â‡‘(â‡‘e i) pb.gen) ^ 2))
nonempty (Î± â†ªo Î²)
measure_theory.integrable (F' xâ‚€) Î¼ âˆ§ has_deriv_at (Î» (n : ğ•œ), âˆ« (a : Î±), F n a âˆ‚Î¼) (âˆ« (a : Î±), F' xâ‚€ a âˆ‚Î¼) xâ‚€
âˆ€á¶  (y : Î±) in l, f y â‰  x
f (â¨… (i : Î³), g i) = â¨… (i : Î³), f (g i)
deriv (Î» (u : â„), âˆ« (x : â„) in a..u, f x) b = f b
S.is_algebraic â†” algebra.is_algebraic R â†¥S
convolution f g (continuous_linear_map.lsmul ğ•œ ğ•œ) Î¼ x = âˆ« (t : G), f t â€¢ g (x - t) âˆ‚Î¼
(Î» (p : Î± Ã— Î±), (sum.inl p.fst, sum.inl p.snd)) '' a âˆª (Î» (p : Î² Ã— Î²), (sum.inr p.fst, sum.inr p.snd)) '' b âˆˆ uniform_space.core.sum.uniformity
number_field.class_number K = 1 â†” is_principal_ideal_ring â†¥(number_field.ring_of_integers K)
âˆ¥x - yâˆ¥ = âˆ¥xâˆ¥ + âˆ¥yâˆ¥ â†” inner_product_geometry.angle x y = real.pi
continuous â‡‘(Î¾.equiv_fun)
has_deriv_within_at (Î» (u : â„), âˆ« (x : â„) in u..b, f x) (-f a) s a
f '' monoid.closure s = monoid.closure (f '' s)
nonempty (V â‰ƒâ‚—[K] Vâ‚) â†” module.rank K V = module.rank K Vâ‚
is_closed (coe_fn '' s)
set.eq_on â‡‘e â‡‘e' e.to_local_equiv.source
âŒŠâ†‘m / â†‘nâŒ‹â‚Š = m / n
K â‰ƒ+* L
âˆƒ (f : cont_mdiff_map I (model_with_corners_self â„ â„) M â„ âŠ¤), set.eq_on â‡‘f 0 s âˆ§ set.eq_on â‡‘f 1 t âˆ§ âˆ€ (x : M), â‡‘f x âˆˆ set.Icc 0 1
function.semiconj g' â‡‘fb â‡‘fa
set.eq_on â‡‘(e.symm) â‡‘(e'.symm) e.target
module.is_torsion' M S â†” submodule.torsion' R M S = âŠ¤
o.oangle x y = Î¸ â†” x â‰  0 âˆ§ y â‰  0 âˆ§ y = (âˆ¥yâˆ¥ / âˆ¥xâˆ¥) â€¢ â‡‘(o.rotation Î¸) x âˆ¨ Î¸ = 0 âˆ§ (x = 0 âˆ¨ y = 0)
(â¨… (i : {i // f i â‰  âŠ¤}), f â†‘i) = â¨… (i : Î¹), f i
âˆ«â» (a : Î±), (â¨† (n : â„•), f n a) âˆ‚Î¼ = â¨† (n : â„•), âˆ«â» (a : Î±), f n a âˆ‚Î¼
finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ g '' s), f i)) = finsum (Î» (j : Î²), finsum (Î» (H : j âˆˆ s), f (g j)))
âˆ¥â†‘xâˆ¥ = âˆ¥xâˆ¥
category_theory.limits.biprod.map f g â‰« (category_theory.limits.biprod.braiding Y W).hom = (category_theory.limits.biprod.braiding X Z).hom â‰« category_theory.limits.biprod.map g f
X.Ïƒ i â‰« X.Î´ (â‡‘fin.cast_succ i) = ğŸ™ (X.obj (opposite.op (simplex_category.mk n)))
module.rank K â†¥s â‰¤ 1 â†” âˆƒ (vâ‚€ : V) (H : vâ‚€ âˆˆ s), s â‰¤ submodule.span K {vâ‚€}
category_theory.strong_epi (f â‰« g)
has_dist.dist (convolution f g L Î¼ xâ‚€) (âˆ« (t : G), â‡‘(â‡‘L (f t)) (g xâ‚€) âˆ‚Î¼) â‰¤ âˆ¥Lâˆ¥ * âˆ« (x : G), âˆ¥f xâˆ¥ âˆ‚Î¼ * Îµ
âˆ«â» (a : Î±), f a + g a âˆ‚Î¼ = âˆ«â» (a : Î±), f a âˆ‚Î¼ + âˆ«â» (a : Î±), g a âˆ‚Î¼
âˆƒ (U : set Î±) (H : U âŠ‡ s), is_open U âˆ§ â‡‘Î¼ U < âŠ¤
finite_dimensional.finrank ğ•œ â†¥(submodule.span ğ•œ {v})á—® = n
f.liminf (Î» (x : Î²), âŠ¤) = âŠ¤
algebra.discr A (matrix.vec_mul b (P.map â‡‘(algebra_map A B))) = P.det ^ 2 * algebra.discr A b
H = âŠ¤
convex ğ•œ ((Î» (x : E), z + x) â»Â¹' s)
e.is_image s t â†’ e.to_local_equiv.target âˆ© â‡‘(e.symm) â»Â¹' s = e.to_local_equiv.target âˆ© t
âˆƒ (g : â„• â†ªo â„•), (âˆ€ (m n : â„•), m < n â†’ r (f (â‡‘g m)) (f (â‡‘g n))) âˆ¨ âˆ€ (m n : â„•), m < n â†’ Â¬r (f (â‡‘g m)) (f (â‡‘g n))
âˆƒ (t : â†¥M), t â€¢ x âˆˆ algebra.adjoin R s
pairwise (disjoint on Î» (n : Î±), set.Ioc (f (order.succ n)) (f n))
âˆ¥vâˆ¥â‚Š â‰¤ âˆ¥uâˆ¥â‚Š + âˆ¥u - vâˆ¥â‚Š
convolution f g (continuous_linear_map.lsmul ğ•œ ğ•œ) Î¼ x = âˆ« (t : G), f (x - t) â€¢ g t âˆ‚Î¼
a â‰¡ b [MOD m]
â†‘(â‡‘(category_theory.limits.cofork.is_colimit.hom_iso ht Z') (k â‰« q)) = â†‘(â‡‘(category_theory.limits.cofork.is_colimit.hom_iso ht Z) k) â‰« q
module.End.eigenspace (T.restrict _) Î¼ = âŠ¥
â¨ (x : Î±) in t, f x âˆ‚Î¼ âˆˆ closure s
direct_sum.is_internal (Î» (i : â†¥S), submodule.torsion_by R M (q â†‘i))
vector_span k s = submodule.span k (s -áµ¥ s)
||a|| = |a|
âˆ® (z : â„‚) in C(c, R), f z = âˆ® (z : â„‚) in C(c, r), f z
p1 -áµ¥ p2 âˆˆ vector_span k s
group.nilpotency_class G = group.nilpotency_class (G â§¸ subgroup.center G) + 1
f + g = category_theory.limits.biprod.lift f g â‰« category_theory.limits.biprod.desc (ğŸ™ Y) (ğŸ™ Y)
filter.tendsto f (nhds_within x (set.Ioi x)) (nhds (has_Inf.Inf (f '' set.Ioi x)))
âˆ¥deriv f câˆ¥ â‰¤ Râ‚‚ / Râ‚
measure_theory.analytic_set (f '' s)
add_con_gen â‡‘c = c
star_convex ğ•œ x ((Î» (x : E), z + x) â»Â¹' s)
filter.tendsto Î¼s F (nhds Î¼) â†” âˆ€ (f : bounded_continuous_function Î± nnreal), filter.tendsto (Î» (i : Î³), âˆ«â» (x : Î±), â†‘(â‡‘f x) âˆ‚â†‘(Î¼s i)) F (nhds (âˆ«â» (x : Î±), â†‘(â‡‘f x) âˆ‚â†‘Î¼))
â‡‘(reflection (submodule.span ğ•œ {v})á—®) v = -v
has_inner.inner (measure_theory.indicator_const_Lp 2 hs hÎ¼s c) f = has_inner.inner c (âˆ« (x : Î±) in s, â‡‘f x âˆ‚Î¼)
âˆ€áµ (x : Î±) âˆ‚Î¼, âˆ€ (s : set Î±), s âˆˆ nhds x â†’ (âˆƒá¶  (n : â„•) in filter.at_top, f^[n] x âˆˆ s)
embedding (Î» (x : weak_bilin B) (y : F), â‡‘(â‡‘B x) y)
nonempty (Î± â†ª Î²) âˆ¨ nonempty (Î² â†ª Î±)
simplex_category.Î´ i â‰« simplex_category.Î´ j.succ = simplex_category.Î´ j â‰« simplex_category.Î´ (â‡‘fin.cast_succ i)
witt_vector.is_poly p (Î» (R : Type u_1) (_Rcr : comm_ring R), witt_vector.frobenius_fun)
âˆƒ (v : Î¹ â†’ set X), (âˆ€ (i : Î¹), is_open (v i)) âˆ§ (s âŠ† â‹ƒ (i : Î¹), v i) âˆ§ locally_finite v âˆ§ âˆ€ (i : Î¹), v i âŠ† u i
C.d i j' â‰« category_theory.eq_to_hom _ = C.d i j
â‡‘Î¼ {x : Î± | Îµ â‰¤ f x} â‰¤ âˆ«â» (a : Î±), f a âˆ‚Î¼ / Îµ
âˆƒ (d : â„•) (k : fin d â†’ â„•), nonempty (N â‰ƒâ‚—[R] direct_sum (fin d) (Î» (i : fin d), R â§¸ submodule.span R {p ^ k i}))
box_integral.has_integral I âŠ¥ (Î» (x : fin (n + 1) â†’ â„), â‡‘(f' x) (pi.single i 1)) box_integral.box_additive_map.volume (box_integral.integral (I.face i) âŠ¥ (Î» (x : fin n â†’ â„), f (i.insert_nth (I.upper i) x)) box_integral.box_additive_map.volume - box_integral.integral (I.face i) âŠ¥ (Î» (x : fin n â†’ â„), f (i.insert_nth (I.lower i) x)) box_integral.box_additive_map.volume)
(âˆ«â» (a : Î±), (f + g) a ^ p âˆ‚Î¼) ^ (1 / p) â‰¤ (âˆ«â» (a : Î±), f a ^ p âˆ‚Î¼) ^ (1 / p) + (âˆ«â» (a : Î±), g a ^ p âˆ‚Î¼) ^ (1 / p)
convolution f g (continuous_linear_map.lmul ğ•œ ğ•œ) Î¼ x = âˆ« (t : G), f t * g (x - t) âˆ‚Î¼
âˆƒ (s : fin N â†’ set Î²), (âˆ€ (i : fin N), (s i).pairwise_disjoint (Î» (j : Î²), metric.closed_ball (q.c j) (q.r j))) âˆ§ set.range q.c âŠ† â‹ƒ (i : fin N) (j : Î²) (H : j âˆˆ s i), metric.ball (q.c j) (q.r j)
âˆ¥â†‘xâˆ¥ = âˆ¥xâˆ¥
e.to_local_equiv.target âˆ© â‡‘(e.symm) â»Â¹' (e.to_local_equiv.source âˆ© s) = e.to_local_equiv.target âˆ© t â†’ e.is_image s t
totally_bounded (f '' s)
function.injective â‡‘(is_primitive_root.aut_to_pow K hÎ¼)
topological_space.is_topological_basis ((Î» (f : set (set Î±)), â‹‚â‚€ f) '' {f : set (set Î±) | f.finite âˆ§ f âŠ† s âˆ§ (â‹‚â‚€ f).nonempty})
cardinal.mk â†¥set.univ = cardinal.mk R ^ 4
e.to_local_equiv.target âˆ© â‡‘(e.symm) â»Â¹' s = e.to_local_equiv.target âˆ© t â†’ e.is_image s t
a â‰¡ b [MOD n] â†” n âˆ£ b - a
K â‰¤ Ká—®á—®
â†‘(N âŠ” H) = â†‘N + â†‘H
is_lower_set s â†’ is_upper_set (â‡‘order_dual.of_dual â»Â¹' s)
A.det = finset.univ.sum (Î» (j : fin n.succ), (-1) ^ (â†‘i + â†‘j) * A i j * (A.minor â‡‘(i.succ_above) â‡‘(j.succ_above)).det)
algebra.discr K â‡‘(pb.basis) = (-1) ^ (finite_dimensional.finrank K L * (finite_dimensional.finrank K L - 1) / 2) * â‡‘(algebra.norm K) (â‡‘(polynomial.aeval pb.gen) (â‡‘polynomial.derivative (minpoly K pb.gen)))
s.sum (Î» (a : Î±), f a) < âŠ¤
f '' s = g '' s
is_cyclotomic_extension T â†¥(algebra.adjoin A {b : B | âˆƒ (a : â„•+), a âˆˆ S âˆ§ b ^ â†‘a = 1}) B
function.injective â‡‘((ideal.map (polynomial.map_ring_hom (ideal.quotient.mk (ideal.comap polynomial.C P))) P).quotient_map (polynomial.map_ring_hom (ideal.quotient.mk (ideal.comap polynomial.C P))) ideal.le_comap_map)
âˆ® (z : â„‚) in C(c, R), (z - w)â»Â¹ = 2 * â†‘real.pi * complex.I
(â¨† (o : option Î²), option.elim a f o) = a âŠ” â¨† (b : Î²), f b
âˆ® (z : â„‚) in C(c, R), (z - c)â»Â¹ â€¢ f z = (2 * â†‘real.pi * complex.I) â€¢ f c
cardinal.mk â†¥(set.Ioc a b) = cardinal.continuum
has_strict_deriv_at (Î» (u : â„), âˆ« (x : â„) in a..u, f x) (f b) b
omega_limit f â‡‘Ï• (â‡‘Ï• t '' s) = omega_limit f â‡‘Ï• s
(â¨† (n : Î²), f n) âˆˆ â‹‚ (n : Î²), set.Icc (f n) (g n)
s.sum (Î» (i : Î¹), f i) = âŠ¤ â†” âˆƒ (i : Î¹) (H : i âˆˆ s), f i = âŠ¤
âˆ¥(â†‘r * (â†‘âˆ¥xâˆ¥)â»Â¹) â€¢ xâˆ¥ = r
continuous â‡‘(affine_map.line_map p v)
has_Sup.Sup S = eqv_gen.setoid (Î» (x y : Î±), âˆƒ (r : setoid Î±), r âˆˆ S âˆ§ r.rel x y)
set.unbounded has_lt.lt (â‹‚ (i : Î¹), function.fixed_points (f i))
module.rank K â†¥(f.range) + module.rank K â†¥(f.ker) = module.rank K V
âˆƒ (y : Î±) (H : y âˆˆ s), function.is_fixed_pt f y âˆ§ filter.tendsto (Î» (n : â„•), f^[n] x) filter.at_top (nhds y) âˆ§ âˆ€ (n : â„•), has_edist.edist (f^[n] x) y â‰¤ has_edist.edist x (f x) * â†‘K ^ n / (1 - â†‘K)
mul_action.fixed_points â†¥(P âŠ” Q) Î± = mul_action.fixed_points â†¥P Î± âˆ© mul_action.fixed_points â†¥Q Î±
has_dist.dist (f^[n] x) (contracting_with.fixed_point f hf) â‰¤ has_dist.dist (f^[n] x) (f^[n + 1] x) / (1 - â†‘K)
function.injective â‡‘(is_localization.map Q g _)
dimH s = â¨† (d : nnreal) (hd : â‡‘(measure_theory.measure.hausdorff_measure â†‘d) s = âŠ¤), â†‘d
(â‹‚ (x : Î±) (H : x âˆˆ s), t x) âŠ† t x
s =áµ[Î¼] t
âˆ« (x : â„) in t..t + n â€¢ T, f x = n â€¢ âˆ« (x : â„) in t..t + T, f x
â‡‘m (â‹ƒ (n : Î¹), s n) = â¨† (n : Î¹), â‡‘m (s n)
f =áµ[Î¼.restrict t] function.const Î± (â¨ (x : Î±) in t, f x âˆ‚Î¼) âˆ¨ âˆ¥âˆ« (x : Î±) in t, f x âˆ‚Î¼âˆ¥ < (â‡‘Î¼ t).to_real * C
s.sum (Î» (i : Î¹), f i * g i) â‰¤ s.sum (Î» (i : Î¹), |f i| ^ p) ^ (1 / p) * s.sum (Î» (i : Î¹), |g i| ^ q) ^ (1 / q)
finite_dimensional.finrank R (M â†’â‚—[R] N) = finite_dimensional.finrank R M * finite_dimensional.finrank R N
f.range = âŠ¤
nonempty â†¥((Top.limit_cone F).X)
dense (s Ã—Ë¢ t)
(measure_theory.measure.map â‡‘f Î¼).is_haar_measure
âˆƒ (t : set Î±) (H : t âŠ† s), t.finite âˆ§ s âŠ† â‹ƒ (x : Î±) (H : x âˆˆ t), metric.ball x e
function.surjective â‡‘(f.app (opposite.op U))
function.commute â‡‘clifford_algebra.reverse â‡‘clifford_algebra.involute
emetric.Hausdorff_edist (Î¦ '' s) (Î¦ '' t) = emetric.Hausdorff_edist s t
â‡‘(e.det) â‡‘(e.is_unit_smul hw) = finset.univ.prod (Î» (i : Î¹), w i)
âˆ« (x : G), f (g + x) âˆ‚Î¼ = âˆ« (x : G), f x âˆ‚Î¼
âˆƒ (C : â„) (H : C > 0), âˆ€ (n : â„•), âˆ¥p nâˆ¥ * â†‘r ^ n â‰¤ C
is_least (f '' s) (f a)
algebra.discr K â‡‘((is_primitive_root.power_basis K hÎ¶).basis) = (-1) ^ ((â†‘p ^ k).totient / 2) * â†‘p ^ (â†‘p ^ (k - 1) * ((â†‘p - 1) * k - 1))
X.Î´ i â‰« X.Î´ j.succ = X.Î´ j â‰« X.Î´ (â‡‘fin.cast_succ i)
âˆ« (z : Î± Ã— Î²), f z âˆ‚Î¼.prod Î½ = âˆ« (x : Î±), âˆ« (y : Î²), f (x, y) âˆ‚Î½ âˆ‚Î¼
cont_diff_within_at ğ•œ n (g âˆ˜ f) (s âˆ© f â»Â¹' t) x
vector_span k s = submodule.span k (has_vsub.vsub p '' s)
continuous (function.uncurry (Î» (x : Î±) (y : Î²), â‡‘(â‡‘f x) y))
(Î» (t : Î¹), âˆ« (x : â„) in v t..b, f x âˆ‚Î¼ - âˆ« (x : â„) in u t..b, f x âˆ‚Î¼ + âˆ« (x : â„) in u t..v t, c âˆ‚Î¼) =o[lt] Î» (t : Î¹), âˆ« (x : â„) in u t..v t, 1 âˆ‚Î¼
b â‹– a â†’ â‡‘order_dual.of_dual a â‹– â‡‘order_dual.of_dual b
a âŠ“ has_Sup.Sup s = â¨† (b : Î±) (H : b âˆˆ s), a âŠ“ b
continuous_on (Î» (b : â„), âˆ« (x : â„) in a..b, f x âˆ‚Î¼) (set.interval bâ‚ bâ‚‚)
connected_component x âŠ† â‹‚ (Z : {Z // is_clopen Z âˆ§ x âˆˆ Z}), â†‘Z
0 â‰¤ x â†” âˆ€ (j : x.right_moves), 0.lf (x.move_right j)
âˆ¥x - yâˆ¥ * âˆ¥x - yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + âˆ¥yâˆ¥ * âˆ¥yâˆ¥
discrete_valuation_ring R â†” is_principal_ideal_ring R âˆ§ âˆƒ! (P : ideal R), P â‰  âŠ¥ âˆ§ P.is_prime
is_glb (s âˆª t) (aâ‚ âŠ“ aâ‚‚)
(measure_theory.simple_func.map g f).lintegral Î¼ = f.range.sum (Î» (x : Î²), g x * â‡‘Î¼ (â‡‘f â»Â¹' {x}))
âˆ¥xâˆ¥ â‰¤ 1 â†’ âˆ¥â‡‘f xâˆ¥ â‰¤ âˆ¥fâˆ¥
k â‰« t.Ï€.app j = l â‰« t.Ï€.app j
J.Î¹ â‰« category_theory.InjectiveResolution.desc f I J = (cochain_complex.singleâ‚€ C).map f â‰« I.Î¹
âˆ«â» (a : Î±), (â¨… (n : â„•), f n a) âˆ‚Î¼ = â¨… (n : â„•), âˆ«â» (a : Î±), f n a âˆ‚Î¼
tendsto_uniformly_on F f p s â†” âˆ€ (Îµ : â„), Îµ > 0 â†’ (âˆ€á¶  (n : Î¹) in p, âˆ€ (x : Î²), x âˆˆ s â†’ has_dist.dist (f x) (F n x) < Îµ)
â‡‘(measure_theory.measure.hausdorff_measure d) (f '' s) â‰¤ â†‘K ^ d * â‡‘(measure_theory.measure.hausdorff_measure d) s
Îµ * â‡‘Î¼ {x : Î± | Îµ â‰¤ f x} â‰¤ âˆ«â» (a : Î±), f a âˆ‚Î¼
âˆƒ (m : â†¥M), m â€¢ x âˆˆ submodule.span R â†‘(is_localization.finset_integer_multiple (submonoid.map â†‘(algebra_map R S) M) s)
(fintype.card â†¥P).coprime â†‘P.index
has_Sup.Sup S = add_con_gen (has_Sup.Sup (coe_fn '' S))
âˆ€áµ (x : Î±) âˆ‚Î¼, âˆ€ (k : â„•), f^[k] x âˆˆ s â†’ (âˆƒá¶  (n : â„•) in filter.at_top, f^[n] x âˆˆ s)
reflexive (Î» (a b : M), âˆƒ (c : M), add_semiconj_by c a b)
X.Ïƒ j â‰« X.Ïƒ (â‡‘fin.cast_succ i) = X.Ïƒ i â‰« X.Ïƒ j.succ
âˆƒ (f : Î  (b : ordinal), b < a.cof.ord â†’ ordinal), a.is_fundamental_sequence a.cof.ord f
(Î» (x : â„), x ^ k) =o[filter.at_top] Î» (x : â„), real.exp (b * x)
c âŠ” d = add_con_gen (Î» (x y : M), â‡‘c x y âˆ¨ â‡‘d x y)
category_theory.limits.has_products_of_shape X Cáµ’áµ–
(âˆ‘' (n : â„•), f n) * âˆ‘' (n : â„•), g n = âˆ‘' (n : â„•), (finset.range (n + 1)).sum (Î» (k : â„•), f k * g (n - k))
cont_diff ğ•œ âŠ¤ fâ‚‚ â†” differentiable ğ•œ fâ‚‚ âˆ§ cont_diff ğ•œ âŠ¤ (deriv fâ‚‚)
group.fg â†¥H
ordinal.enum_ord S o = has_Inf.Inf (S âˆ© set.Ici (o.blsub (Î» (a : ordinal) (_x : a < o), ordinal.enum_ord S a)))
â‡‘(has_Inf.Inf m) s = â¨… (t : â„• â†’ set Î±) (h2 : s âŠ† set.Union t), âˆ‘' (n : â„•), â¨… (Î¼ : measure_theory.outer_measure Î±) (h3 : Î¼ âˆˆ m), â‡‘Î¼ (t n)
M â‰  âŠ¥
category_theory.limits.biproduct.Î¹ f j â‰« category_theory.limits.biproduct.Ï€ f j' = dite (j = j') (Î» (h : j = j'), category_theory.eq_to_hom _) (Î» (h : Â¬j = j'), 0)
â‡‘(has_Inf.Inf S) = has_Inf.Inf (coe_fn '' S)
âˆ¯ (x : fin 1 â†’ â„‚) in T(c, R), f x = âˆ® (z : â„‚) in C(c 0, R 0), f (Î» (_x : fin 1), z)
|has_inner.inner x y / (âˆ¥xâˆ¥ * âˆ¥yâˆ¥)| â‰¤ 1
measure_theory.measure.map (s.restrict f) (â‡‘(measure_theory.measure.comap coe) (Î¼.with_density (Î» (x : E), ennreal.of_real |(f' x).det|))) = Î¼.restrict (f '' s)
witt_vector.is_polyâ‚‚ p (Î» (R : Type u_1) (_Rcr : comm_ring R) (x y : witt_vector p R), h (f x) (g y))
âˆ« (y : â„) in a..b, f' y = f b - f a
u / v * v =á¶ [l] u
|real.log x * x ^ t| < 1 / t
âˆ€á¶  (x : E) in nhds a, has_strict_fderiv_at.implicit_function f f' hf hf' (f x) (â‡‘(has_strict_fderiv_at.implicit_to_local_homeomorph f f' hf hf') x).snd = x
Ká—®á—® = K
differentiable_on â„‚ (function.update f c (lim (nhds_within c {c}á¶œ) f)) (has_insert.insert c s)
âˆ® (z : â„‚) in C(c, R), (z - w)â»Â¹ â€¢ f z = (2 * â†‘real.pi * complex.I) â€¢ f w
(â‡‘â¨… (i : Î¹) (H : i âˆˆ I), m i) s = â¨… (t : â„• â†’ set Î±) (h2 : s âŠ† set.Union t), âˆ‘' (n : â„•), â¨… (i : Î¹) (H : i âˆˆ I), â‡‘(m i) (t n)
Jâ‚.close S = âŠ¤ â†” S âˆˆ â‡‘Jâ‚ X
(âˆ€á¶  (x : Î±) in l, âˆ€ (i : Î¹), i âˆˆ I â†’ p i x) â†” âˆ€ (i : Î¹), i âˆˆ I â†’ (âˆ€á¶  (x : Î±) in l, p i x)
is_closed â†‘Ká—®
â¨ (x : Î±) in t, f x âˆ‚Î¼ âˆˆ s
âˆ¥f 1 - f 0âˆ¥ â‰¤ C
is_compact (coe_fn '' s)
witt_vector.is_poly p (Î» (R : Type u_1) (_Rcr : comm_ring R), g âˆ˜ f)
Jâ‚ = Jâ‚‚ â†” âˆ€ (P : Cáµ’áµ– â¥¤ Type (max v u)), category_theory.presieve.is_sheaf Jâ‚ P â†” category_theory.presieve.is_sheaf Jâ‚‚ P
real.cos (inner_product_geometry.angle x y) * (âˆ¥xâˆ¥ * âˆ¥yâˆ¥) = has_inner.inner x y
metric.bounded s â†’ (âˆƒ (R : â„), âˆ€ (x : E), x âˆˆ s â†’ âˆ¥xâˆ¥ â‰¤ R)
âˆƒ (f : bounded_continuous_function X â„), set.eq_on â‡‘f 0 s âˆ§ set.eq_on â‡‘f 1 t âˆ§ âˆ€ (x : X), â‡‘f x âˆˆ set.Icc 0 1
âˆƒ (T : set Î¹), T.countable âˆ§ (â‹ƒ (i : Î¹) (H : i âˆˆ T), s i) = â‹ƒ (i : Î¹), s i
continuous (Î» (F : C(Î±, Î²)), continuous_map.restrict s F)
âˆ¥â‡‘f mâˆ¥ â‰¤ C * finset.univ.prod (Î» (i : Î¹), âˆ¥m iâˆ¥)
tangent_map I I â‡‘(charted_space.chart_at H p.fst) q = â‡‘((equiv.sigma_equiv_prod H E).symm) (â‡‘(charted_space.chart_at (model_prod H E) p) q)
âˆ¥fâˆ¥ = has_Inf.Inf {C : â„ | âˆ€ (x : Î±), âˆ¥â‡‘f xâˆ¥ â‰¤ C}
finite_dimensional.finrank K (V â§¸ s) â‰¤ finite_dimensional.finrank K V
filter.map prod.snd (nhds_within x (prod.fst â»Â¹' {x.fst})) = nhds x.snd
âˆ€áµ (x : Î±) âˆ‚Î¼, filter.tendsto (Î» (a : set Î±), â‡‘Ï a / â‡‘Î¼ a) (v.filter_at x) (nhds (Ï.rn_deriv Î¼ x))
set.range â‡‘(p.succ_above) = {p}á¶œ
polynomial.cyclotomic' n K = (polynomial.X ^ n - 1) /â‚˜ n.proper_divisors.prod (Î» (i : â„•), polynomial.cyclotomic' i K)
âˆ« (a : Î±), f a âˆ‚Î¼ = (âˆ«â» (a : Î±), ennreal.of_real (f a) âˆ‚Î¼).to_real - (âˆ«â» (a : Î±), ennreal.of_real (-f a) âˆ‚Î¼).to_real
measure_theory.submartingale f ğ’¢ Î¼ â†” âˆ€ (Ï„ Ï€ : Î± â†’ â„•), measure_theory.is_stopping_time ğ’¢ Ï„ â†’ measure_theory.is_stopping_time ğ’¢ Ï€ â†’ Ï„ â‰¤ Ï€ â†’ (âˆƒ (N : â„•), âˆ€ (x : Î±), Ï€ x â‰¤ N) â†’ âˆ« (x : Î±), measure_theory.stopped_value f Ï„ x âˆ‚Î¼ â‰¤ âˆ« (x : Î±), measure_theory.stopped_value f Ï€ x âˆ‚Î¼
function.injective (Î» (h : diffeomorph I I' M M' n) (x : M), â‡‘h x)
s âˆˆ finset.shadow^[k] ğ’œ â†” âˆƒ (t : finset Î±) (H : t âˆˆ ğ’œ), s âŠ† t âˆ§ t.card = s.card + k
filter.map prod.fst (nhds_within x (prod.snd â»Â¹' {x.snd})) = nhds x.fst
disjoint (set.range â‡‘(c.embedding iâ‚)) (set.range â‡‘(c.embedding iâ‚‚))
dimH (f '' s) â‰¤ dimH s / â†‘r
module.rank R (Î  (i : Î¹), M i) = cardinal.sum (Î» (i : Î¹), module.rank R (M i))
âˆ‘' (i : â„•), ite (n â‰¤ i) (2â»Â¹ ^ i) 0 = 2 * 2â»Â¹ ^ n
c.closed = set.range â‡‘c
a â‰¡ b [MOD m / m.gcd c]
â†‘(â‡‘(category_theory.limits.cotrident.is_colimit.hom_iso ht Z') (k â‰« q)) = â†‘(â‡‘(category_theory.limits.cotrident.is_colimit.hom_iso ht Z) k) â‰« q
continuous â‡‘f
âˆƒ (C r : â„) (hC : 0 < C) (hr : 0 < r), âˆ€ (n : â„•), âˆ¥p nâˆ¥ â‰¤ C * r ^ n
âˆ¥f + gâˆ¥ â‰¤ âˆ¥fâˆ¥ + âˆ¥gâˆ¥
â†‘(â‡‘(euclidean_geometry.orthogonal_projection s) p) -áµ¥ p âˆˆ (s.direction)á—®
is_top a â†’ a = âŠ¤
direct_sum.is_internal A â†” complete_lattice.independent A âˆ§ supr A = âŠ¤
â†‘s1 âŠ“ â†‘s2 = â†‘s1 âˆ© â†‘s2
âˆ¥â‡‘f mâˆ¥ â‰¤ âˆ¥fâˆ¥ * finset.univ.prod (Î» (i : Î¹), âˆ¥m iâˆ¥)
cardinal.mk â†¥set.univ = cardinal.continuum
m âˆˆ f' '' set.Icc a b
finsupp.map_domain â‡‘f 1 = 1
âˆƒ (S : C), âˆ€ {X : C}, X âˆˆ O â†’ nonempty (X âŸ¶ S)
(â†‘âŒŠaâŒ‹ * b + c) / int.fract a + b = (b * a + c) / int.fract a
â…x,yâ† âˆˆ H
function.surjective â‡‘(mv_polynomial.aeval (Î» (s : â†¥S), add_monoid_algebra.of' R M â†‘s))
âˆƒ (t : set Î±), measurable_set t âˆ§ t âŠ† s âˆ§ r < â‡‘Î¼ t âˆ§ â‡‘Î¼ t < âŠ¤
f =áµ[Î¼] function.const Î± (â¨ (x : Î±), f x âˆ‚Î¼) âˆ¨ â¨ (x : Î±), g (f x) âˆ‚Î¼ < g (â¨ (x : Î±), f x âˆ‚Î¼)
box_integral.has_integral I l â‡‘f Î¼.to_box_additive.to_smul (measure_theory.simple_func.integral (Î¼.restrict â†‘I) f)
1.is_diag
filter.tendsto F p (nhds f) â†” tendsto_locally_uniformly (Î» (i : Î¹) (a : Î±), â‡‘(F i) a) â‡‘f p
(âˆ‘' (x : Î¹), f x) * âˆ‘' (y : Î¹'), g y = âˆ‘' (z : Î¹ Ã— Î¹'), f z.fst * g z.snd
witt_vector.is_poly p (Î» (R : Type u_1) (_Rcr : comm_ring R) (x : witt_vector p R), x * â†‘n)
summable (Î» (i : Î¹), f i * g i) âˆ§ âˆ‘' (i : Î¹), f i * g i â‰¤ (âˆ‘' (i : Î¹), f i ^ p) ^ (1 / p) * (âˆ‘' (i : Î¹), g i ^ q) ^ (1 / q)
add_semiconj_by â†‘u x (â†‘u + x + â†‘-u)
has_dist.dist (â‡‘f x) (â‡‘f y) â‰¤ 2 * âˆ¥fâˆ¥
x = y â†” âˆ¥xâˆ¥ = âˆ¥yâˆ¥ âˆ§ hb.oangle x y = 0
âˆ«â» (a : Î±), filter.at_top.liminf (Î» (n : â„•), f n a) âˆ‚Î¼ â‰¤ filter.at_top.liminf (Î» (n : â„•), âˆ«â» (a : Î±), f n a âˆ‚Î¼)
â†‘(ideal.span {â‡‘(algebra_map S L) a}) âŠ† â†‘(submodule.span K (â‡‘(algebra_map S L) '' b))
measure_theory.analytic_set (â‹‚ (n : Î¹), s n)
measurable (Î» (y : Î²), âˆ«â» (x : Î±), f (x, y) âˆ‚Î¼)
p âˆˆ âŠ¤
0 = 1 â†” set.range â‡‘f = {0}
â†‘(s.direction) = (Î» (_x : P), _x -áµ¥ p) '' â†‘s
Â¬same_ray â„ x y â†” âˆ¥x + yâˆ¥ < âˆ¥xâˆ¥ + âˆ¥yâˆ¥
âˆ¥âˆ‘' (i : Î¹), f iâˆ¥ â‰¤ âˆ‘' (i : Î¹), âˆ¥f iâˆ¥
simplex_category.Î´ i â‰« simplex_category.Î´ (â‡‘fin.cast_succ i) = simplex_category.Î´ i â‰« simplex_category.Î´ i.succ
vector_span k âˆ… = âŠ¥
is_closed (coe_fn '' s)
p.bind_on_support (Î» (a : Î±) (_x : a âˆˆ p.support), f a) = p.bind f
monotone (Î» (x : Î±), f x Ã—Ë¢ g x)
nonempty â†¥(hall_matchings_on t Î¹')
has_inner.inner x y = (â†‘âˆ¥x + yâˆ¥ ^ 2 - â†‘âˆ¥x - yâˆ¥ ^ 2 + (â†‘âˆ¥x - is_R_or_C.I â€¢ yâˆ¥ ^ 2 - â†‘âˆ¥x + is_R_or_C.I â€¢ yâˆ¥ ^ 2) * is_R_or_C.I) / 4
[is_local_ring_hom f, â‡‘f '' (local_ring.maximal_ideal R).carrier âŠ† â†‘(local_ring.maximal_ideal S), ideal.map f (local_ring.maximal_ideal R) â‰¤ local_ring.maximal_ideal S, local_ring.maximal_ideal R â‰¤ ideal.comap f (local_ring.maximal_ideal S), ideal.comap f (local_ring.maximal_ideal S) = local_ring.maximal_ideal R].tfae
âˆ€á¶  (t : finset (Î¹ Ã— â„)) in filter.at_top, âˆ€ (I J : box_integral.box Î¹), J âˆˆ s â†’ âˆ€ (J' : box_integral.box Î¹), J' âˆˆ box_integral.prepartition.split_many I t â†’ Â¬disjoint â†‘J â†‘J' â†’ J' â‰¤ J
function.injective â‡‘f â†” function.surjective â‡‘f
(âˆ€ (a : â†¥P), â‡‘g (â‡‘f a) = 0) âˆ§ âˆ€ (b : â†¥Q), â‡‘g b = 0 â†’ (âˆƒ (a : â†¥P), â‡‘f a = b)
âˆ« (x : Î±), âˆ« (y : Î²), (f - g) (x, y) âˆ‚Î½ âˆ‚Î¼ = âˆ« (x : Î±), âˆ« (y : Î²), f (x, y) âˆ‚Î½ âˆ‚Î¼ - âˆ« (x : Î±), âˆ« (y : Î²), g (x, y) âˆ‚Î½ âˆ‚Î¼
â‡‘Î¼ (â‹ƒ (i : Î¹), s i) = â¨† (i : Î¹), â‡‘Î¼ (s i)
(matrix.from_blocks A B C D).det = A.det * (D - (C.mul (â…Ÿ A)).mul B).det
âˆ« (x : Î±), measure_theory.stopped_value f Ï„ x âˆ‚Î¼ â‰¤ âˆ« (x : Î±), measure_theory.stopped_value f Ï€ x âˆ‚Î¼
vector_span k (p '' s) = submodule.span k ((Î» (_x : P), _x -áµ¥ p i) '' (p '' (s  {i})))
affine_span k (set.range (Î» (q : â†¥s), â‡‘(affine_map.line_map p â†‘q) â†‘(w q))) = affine_span k s
âˆ¥x - yâˆ¥ * âˆ¥x - yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + âˆ¥yâˆ¥ * âˆ¥yâˆ¥ â†” has_inner.inner x y = 0
pairwise (disjoint on Î» (n : Î±), set.Ico (f n) (f (order.pred n)))
(âˆ€á¶  (x : Î±) in nhds a, p x) â†” âˆƒ (t : set Î±), (âˆ€ (x : Î±), x âˆˆ t â†’ p x) âˆ§ is_open t âˆ§ a âˆˆ t
â…â…Hâ‚,Hâ‚‚â†,Hâ‚ƒâ† = âŠ¥
âˆ€á¶  (y : Î±) in nhds a, âˆ€á¶  (x : Î±) in nhds y, p x
category_theory.is_idempotent_complete C â†” âˆ€ (X : C) (p : X âŸ¶ X), p â‰« p = p â†’ category_theory.limits.has_kernel p
âˆ« (x : G), f x âˆ‚Î¼ = 0
category_theory.is_pullback (hâ‚â‚ â‰« hâ‚â‚‚) vâ‚â‚ vâ‚â‚ƒ (hâ‚‚â‚ â‰« hâ‚‚â‚‚)
âˆ¥fâˆ¥ = 0 â†” f = 0
âˆ¥continuous_map.to_Lp p Î¼ ğ•œâˆ¥ â‰¤ â†‘(measure_theory.measure_univ_nnreal Î¼) ^ (p.to_real)â»Â¹
âˆ¥0âˆ¥ = 0
convex_on â„ set.univ â‡‘p
âˆƒ (s : set Î±), s.countable âˆ§ (â‹ƒ (x : Î±) (H : x âˆˆ s), f x) = set.univ
subgroup.normal_closure {âŸ¨fin_rotate 5, _âŸ©} = âŠ¤
function.injective â‡‘(dfinsupp.sum_add_hom (Î» (i : Î¹), (p i).subtype))
group.is_nilpotent (Î  (i : Î·), Gs i)
âˆ« (x : Î±), âˆ« (y : Î²), f x y âˆ‚Î½ âˆ‚Î¼ = âˆ« (z : Î± Ã— Î²), f z.fst z.snd âˆ‚Î¼.prod Î½
unique_diff_on ğ•œ (s Ã—Ë¢ t)
add_semiconj_by a (â†‘-x) (â†‘-y)
âˆ« (x : Î±) in s, âˆ¥g xâˆ¥ âˆ‚Î¼ â‰¤ âˆ« (x : Î±) in s, âˆ¥f xâˆ¥ âˆ‚Î¼
lie_algebra.is_nilpotent R â†¥((lie_algebra.ad R L).range) â†” lie_algebra.is_nilpotent R L
cont_diff ğ•œ âŠ¤ f â†” differentiable ğ•œ f âˆ§ cont_diff ğ•œ âŠ¤ (Î» (y : E), fderiv ğ•œ f y)
f â‰« category_theory.is_filtered.to_sup O H mY = category_theory.is_filtered.to_sup O H mX
function.surjective â‡‘(c.mk')
monotone (Î» (n : â„•), f^[n] x)
âˆ«â» (a : Î±), f a * T.indicator (Î» (_x : Î±), c) a âˆ‚Î¼ = âˆ«â» (a : Î±), f a âˆ‚Î¼ * âˆ«â» (a : Î±), T.indicator (Î» (_x : Î±), c) a âˆ‚Î¼
(g.to_continuous_map_on (set.Icc (-âˆ¥fâˆ¥) âˆ¥fâˆ¥)).comp â†‘f.attach_bound âˆˆ A
group.nilpotency_class (G â§¸ subgroup.center G) = group.nilpotency_class G - 1
â‡‘(hb.rotation (hb.oangle x y)) x = y â†” âˆ¥xâˆ¥ = âˆ¥yâˆ¥
discrete_topology â†¥t
finite_dimensional.finrank K â†¥(f.range) = finite_dimensional.finrank K V
continuous â‡‘f â†” continuous â‡‘(f.linear)
âˆƒ (C : nnreal) (H : C > 0), âˆ€ (n : â„•), âˆ¥p nâˆ¥â‚Š * r ^ n â‰¤ C
x âˆˆ set.Icc a b â†’ âˆ¥f xâˆ¥ â‰¤ B x
|v - (generalized_continued_fraction.of v).convergents n| â‰¤ 1 / (b * (generalized_continued_fraction.of v).denominators n * (generalized_continued_fraction.of v).denominators n)
cont_mdiff_within_at (I.prod J) (I'.prod J') n (prod.map f g) (s Ã—Ë¢ r) p
(âˆ f) = (fintype.elems Î¹).inf f
1.factor_multiset = 0
monoid.fg M â†” âˆƒ (S : set M), submonoid.closure S = âŠ¤ âˆ§ S.finite
has_deriv_within_at (Î» (u : â„), âˆ« (x : â„) in a..u, f x) (f b) s b
nonempty (V â‰ƒâ‚—[K] V')
âˆ« (x : â„) in a..b, real.sin x * real.cos x = (real.sin b ^ 2 - real.sin a ^ 2) / 2
function.injective â‡‘f â†” âˆ€ (a : G), â‡‘f a = 1 â†” a = 1
has_sum (Î» (n : â„•), âˆ® (z : â„‚) in C(c, R), (w / (z - c)) ^ n â€¢ (z - c)â»Â¹ â€¢ f z) (âˆ® (z : â„‚) in C(c, R), (z - (c + w))â»Â¹ â€¢ f z)
âˆ« (z : Î± Ã— Î²), f z âˆ‚Î¼.prod Î½ = âˆ« (y : Î²), âˆ« (x : Î±), f (x, y) âˆ‚Î¼ âˆ‚Î½
X.Ïƒ i â‰« X.Î´ i.succ = ğŸ™ (X.obj (opposite.op (simplex_category.mk n)))
function.injective (Î» (_x : G), _x +áµ¥ p)
f' =o[l] g â†’ (Î» (x : Î±), âˆ¥f' xâˆ¥) =o[l] g
âˆ¥f.mk_normed_group_hom C hâˆ¥ â‰¤ linear_order.max C 0
uniformity Î³ = â¨… (Îµ : ennreal) (H : Îµ > 0), filter.principal {p : Î³ Ã— Î³ | has_edist.edist p.fst p.snd < Îµ}
antitone (f âŠ“ g)
algebraic_geometry.structure_sheaf.to_stalk â†¥(opposite.unop (opposite.op (algebraic_geometry.LocallyRingedSpace.Î“.obj (opposite.op X)))) (â‡‘(X.to_Î“_Spec_SheafedSpace.base) x) â‰« algebraic_geometry.PresheafedSpace.stalk_map X.to_Î“_Spec_SheafedSpace x = X.Î“_to_stalk x
has_inner.inner (x + y) (x - y) = 0 â†” âˆ¥xâˆ¥ = âˆ¥yâˆ¥
â‡‘f '' S = â‡‘(f.symm) â»Â¹' S
Â¬a â‹– b â†” âˆƒ (c : Î±), a < c âˆ§ c < b
âˆ« (x : Î±), F (âˆ« (y : Î²), f (x, y) + g (x, y) âˆ‚Î½) âˆ‚Î¼ = âˆ« (x : Î±), F (âˆ« (y : Î²), f (x, y) âˆ‚Î½ + âˆ« (y : Î²), g (x, y) âˆ‚Î½) âˆ‚Î¼
w + â†‘-â‡‘(is_add_unit.lift_right (f.restrict S) h) y = z â†” w = â‡‘f â†‘y + z
finite_dimensional K â†¥(submodule.span K A)
(â¨† (i : Î¹), f i) = b
â‡‘(euclidean_geometry.orthogonal_projection s) (v +áµ¥ p) = âŸ¨p, hpâŸ©
âˆ¥Uâˆ¥ â‰¤ 1
âˆƒ (b' : set Î¹) (H : b' âŠ† b), b'.finite âˆ§ s âŠ† â‹ƒ (i : Î¹) (H : i âˆˆ b'), c i
filter.tendsto (Î» (n : â„•), âˆ«â» (a : Î±), F n a âˆ‚Î¼) filter.at_top (nhds (âˆ«â» (a : Î±), f a âˆ‚Î¼))
âˆ¥x + yâˆ¥ = âˆ¥xâˆ¥ + âˆ¥yâˆ¥
(Î» (y : E Ã— E), f y.fst - f y.snd - â‡‘(p 1) (Î» (_x : fin 1), y.fst - y.snd)) =O[nhds (x, x)] Î» (y : E Ã— E), âˆ¥y - (x, x)âˆ¥ * âˆ¥y.fst - y.sndâˆ¥
âˆ« (x : G), f (x + g) âˆ‚Î¼ = âˆ« (x : G), f x âˆ‚Î¼
âˆƒ (g : Î± â†’ ennreal), measurable g âˆ§ g â‰¤ f âˆ§ âˆ«â» (a : Î±), f a âˆ‚Î¼ = âˆ«â» (a : Î±), g a âˆ‚Î¼
âˆƒ (n : â„•), nonempty (basis (fin n) R â†¥N)
âˆƒ (n o : â„•) (hno : n â‰¤ o) (bO : basis (fin o) R â†¥O) (bN : basis (fin n) R â†¥N) (a : fin n â†’ R), âˆ€ (i : fin n), â†‘(â‡‘bN i) = a i â€¢ â†‘(â‡‘bO (â‡‘(fin.cast_le hno) i))
cont_diff_within_at ğ•œ n (prod.map f g) (s Ã—Ë¢ t) p
function.semiconj (Î» (x : Î±), â¨† (g' : G), â‡‘(â‡‘fâ‚ g')â»Â¹ (â‡‘(â‡‘fâ‚‚ g') x)) â‡‘(â‡‘fâ‚‚ g) â‡‘(â‡‘fâ‚ g)
âˆƒ (a : â„) (H : a âˆˆ set.Ioo 0 1) (C : â„) (H : C > 0), âˆ€ (y : E), y âˆˆ metric.ball 0 â†‘r' â†’ âˆ€ (n : â„•), âˆ¥f (x + y) - p.partial_sum n yâˆ¥ â‰¤ C * a ^ n
is_min a â†’ a = âŠ¥
category_theory.is_iso f â†” âˆ€ (x : â†¥X), category_theory.is_iso ((Top.presheaf.stalk_functor C x).map f)
â‡‘(o.rotation (o.oangle x y)) x = y â†” âˆ¥xâˆ¥ = âˆ¥yâˆ¥
summable (Î» (x : Î±), âˆ¥f xâˆ¥) â†” summable f
measure_theory.measure_preserving â‡‘(â‡‘matrix.to_lin' t.to_matrix) measure_theory.measure_space.volume measure_theory.measure_space.volume
function.injective â‡‘f
(Î» (y : E Ã— E), f y.fst - f y.snd - â‡‘(p 1) (Î» (_x : fin 1), y.fst - y.snd)) =O[filter.principal (emetric.ball (x, x) r')] Î» (y : E Ã— E), âˆ¥y - (x, x)âˆ¥ * âˆ¥y.fst - y.sndâˆ¥
âˆƒ (b : â†¥M), âˆ€ (i : Î¹), is_localization.is_integer R (â†‘b â€¢ f i)
(Î» (x : Î±), â‡‘Î½ (prod.mk x â»Â¹' s)) =áµ[Î¼] 0
â…I,Nâ† = ((lie_module.to_module_hom R L M).comp (tensor_product.lie_module.map_incl I N)).range
is_integral R (B.basis.to_matrix â‡‘(B'.basis) i j)
submodule.span R (â‡‘f â»Â¹' s) â‰¤ submodule.comap f (submodule.span Râ‚‚ s)
is_add_submonoid (f '' s)
âˆ® (z : â„‚) in C(c, R), f z = 0
strict_convex_on ğ•œ s (f âŠ” g)
algebra.discr â„š â‡‘b = algebra.discr â„š â‡‘b'
n.totient = n.factorization.prod (Î» (p k : â„•), p ^ (k - 1) * (p - 1))
X.Ïƒ (â‡‘fin.cast_succ i) â‰« X.Ïƒ j = X.Ïƒ j.succ â‰« X.Ïƒ i
strict_anti (Î» (n : â„•), f^[n] x)
unique_mdiff_on I' (e.to_local_equiv.target âˆ© â‡‘(e.symm) â»Â¹' s)
(âˆƒ (g : Gâ‚€) (hg : g â‰  0), p g hg) â†” âˆƒ (g : Gâ‚€Ë£), p â†‘g _
measurable (Î» (x : Î±), âˆ‘' (i : Î¹), f i x)
add_submonoid.closure {p : polynomial R | âˆƒ (n : â„•) (a : R), p = â‡‘(polynomial.monomial n) a} = âŠ¤
Î· â‰« Î¸ â‰« Î¹ = (Î· â‰« Î¸) â‰« Î¹
e.is_image s t â†’ e.to_local_equiv.source âˆ© â‡‘e â»Â¹' t = e.to_local_equiv.source âˆ© s
filter.tendsto (box_integral.integral_sum f vol) (l.to_filter_Union I âŠ¤) (nhds y)
(âˆ‘' (n : â„•), f n) * âˆ‘' (n : â„•), g n = âˆ‘' (n : â„•), (finset.nat.antidiagonal n).sum (Î» (kl : â„• Ã— â„•), f kl.fst * g kl.snd)
ennreal.of_real âˆ¥f - gâˆ¥ = âˆ«â» (x : Î±), â†‘âˆ¥â‡‘f x - â‡‘g xâˆ¥â‚Š âˆ‚Î¼
âˆƒ (Î¹ : Type u) (c : Î¹ â†’ Î±) (r r' : Î¹ â†’ â„), (âˆ€ (i : Î¹), c i âˆˆ s âˆ§ 0 < r i âˆ§ r i < r' i âˆ§ r' i < R (c i)) âˆ§ locally_finite (Î» (i : Î¹), metric.ball (c i) (r' i)) âˆ§ s âŠ† â‹ƒ (i : Î¹), metric.ball (c i) (r i)
f =o[nhds_within a {a}á¶œ] Î» (x : ğ•œ), (x - a)â»Â¹
âˆƒ (is : finset Î¹) {n : set X} (hnâ‚ : n âˆˆ nhds x) (hnâ‚‚ : n âŠ† â‹‚ (i : Î¹) (H : i âˆˆ is), U i), âˆ€ (z : X), z âˆˆ n â†’ function.mul_support (Î» (i : Î¹), f i z) âŠ† â†‘is
(â‹ƒ (i : Î¹) (H : i âˆˆ s), t i H).finite
f âˆˆ s.dfinsupp â‡‘t â†” âˆ€ (i : Î¹), â‡‘f i âˆˆ â‡‘t i
â‡‘(reflection Ká—®) v = -v
algebra.discr â„š â‡‘((is_primitive_root.power_basis â„š hÎ¶).basis) = algebra.discr â„š â‡‘((is_primitive_root.sub_one_power_basis â„š hÎ¶).basis)
has_dist.dist t.orthocenter (â‡‘(euclidean_geometry.reflection (affine_span â„ (t.points '' {iâ‚, iâ‚‚}))) (affine.simplex.circumcenter t)) = affine.simplex.circumradius t
âˆ€áµ (x : Î±) âˆ‚Î¼, âˆ€á¶  (a : set Î±) in v.filter_at x, 0 < â‡‘Î¼ a
is_preconnected (â‹ƒ (n : Î¹), s n)
set.eq_on f g (complex.re â»Â¹' set.Icc a b)
p -áµ¥ â†‘(â‡‘(euclidean_geometry.orthogonal_projection s) p) âˆˆ (s.direction)á—®
â‡‘(linear_map.to_matrix b b') linear_map.id = b'.to_matrix â‡‘b
measure_theory.analytic_set (f '' s)
âˆ« (x : E), f x * (measure_theory.pdf X Â«â„™Â» Î¼ x).to_real âˆ‚Î¼ = âˆ« (x : Î±), f (X x) âˆ‚Â«â„™Â»
measure_theory.integrable F' Î¼ âˆ§ has_deriv_at (Î» (x : ğ•œ), âˆ« (a : Î±), F x a âˆ‚Î¼) (âˆ« (a : Î±), F' a âˆ‚Î¼) xâ‚€
hb.oangle x y = Î¸ â†” y = (âˆ¥yâˆ¥ / âˆ¥xâˆ¥) â€¢ â‡‘(hb.rotation Î¸) x
nonempty (V â‰ƒâ‚—[K] V') â†” (module.rank K V).lift = (module.rank K V').lift
summable (Î» (i : Î¹), â‡‘(V i) (f i)) â†” summable (Î» (i : Î¹), âˆ¥f iâˆ¥ ^ 2)
âˆƒ (f : V â†’â‚—[K] K) (H : f â‰  0), p â‰¤ f.ker
cont_diff_within_at ğ•œ n (f âˆ˜ â‡‘g) (â‡‘g â»Â¹' s) x
(r âŠ“ s).rel = r.rel âŠ“ s.rel
is_connected (â‹ƒ (n : Î²), s n)
has_fpower_series_on_ball f (p.change_origin y) (x + y) (r - â†‘âˆ¥yâˆ¥â‚Š)
emetric.inf_edist (Î¦ x) (Î¦ '' t) = emetric.inf_edist x t
finite_dimensional.finrank ğ•œ â†¥(Kâ‚á—® âŠ“ Kâ‚‚) = n
âˆ¥bounded_continuous_function.const Î± bâˆ¥ â‰¤ âˆ¥bâˆ¥
âˆ¥normed_group_hom.id Vâˆ¥ = 1
(âˆ f) = (fintype.elems Î¹).sup f
function.injective â‡‘f
convex ğ•œ (â‡‘f â»Â¹' s)
â‡‘f (Î» (i : Î¹), finset.univ.sum (Î» (j : Î± i), g i j)) = finset.univ.sum (Î» (r : Î  (i : Î¹), Î± i), â‡‘f (Î» (i : Î¹), g i (r i)))
filter.tendsto (Î» (s : finset Î±), âˆ‘' (b : {x // x âˆ‰ s}), f â†‘b) filter.at_top (nhds 0)
polish_space â†¥s
function.surjective â‡‘f â†’ category_theory.epi f
(âˆ€ (x y : Î  (n : â„•), E n), has_dist.dist (f x) (f y) â‰¤ has_dist.dist x y) â†” âˆ€ (x y : Î  (n : â„•), E n) (n : â„•), y âˆˆ pi_nat.cylinder x n â†’ has_dist.dist (f x) (f y) â‰¤ (1 / 2) ^ n
âˆ¥âˆ‘' (i : Î¹), f iâˆ¥â‚Š â‰¤ a
âˆ¥x + yâˆ¥ * âˆ¥x + yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + âˆ¥yâˆ¥ * âˆ¥yâˆ¥
âˆ«â» (a : Î±), filter.at_top.liminf (Î» (n : â„•), f n a) âˆ‚Î¼ â‰¤ filter.at_top.liminf (Î» (n : â„•), âˆ«â» (a : Î±), f n a âˆ‚Î¼)
âˆƒ (g : E â†’â‚—[â„] â„), (âˆ€ (x : â†¥(f.domain)), â‡‘g â†‘x = â‡‘f x) âˆ§ âˆ€ (x : E), â‡‘g x â‰¤ N x
tendsto_locally_uniformly_on (Î» (n : â„•) (y : E), p.partial_sum n (y - x)) f filter.at_top (emetric.ball x r)
âˆ¥f.extend e h_dense _âˆ¥ â‰¤ â†‘N * âˆ¥fâˆ¥
differentiable_on â„ (Î» (u : â„), âˆ« (x : â„) in a..u, f x) s
âˆ¥fâˆ¥ â‰¤ C â†” âˆ€ (x : Î±), âˆ¥â‡‘f xâˆ¥ â‰¤ C
âˆƒ! (l : s.X âŸ¶ t.X), âˆ€ (j : J), l â‰« t.Ï€.app j = s.Ï€.app j
(â¨… (K : submodule ğ•œ E) (H : K âˆˆ s), Ká—®) = (has_Sup.Sup s)á—®
(âˆƒ (g : Gâ‚€Ë£), p g) â†” âˆƒ (g : Gâ‚€) (hg : g â‰  0), p (units.mk0 g hg)
âˆƒ (y : Î±), function.is_fixed_pt f y âˆ§ filter.tendsto (Î» (n : â„•), f^[n] x) filter.at_top (nhds y) âˆ§ âˆ€ (n : â„•), has_edist.edist (f^[n] x) y â‰¤ has_edist.edist x (f x) * â†‘K ^ n / (1 - â†‘K)
(âˆƒ (fs : finset Î¹) (hfs : â†‘fs âŠ† s) (w : Î¹ â†’ k) (hw : fs.sum (Î» (i : Î¹), w i) = x), v = â‡‘(fs.weighted_vsub_of_point p b) w) â†” âˆƒ (fs : finset â†¥s) (w : â†¥s â†’ k) (hw : fs.sum (Î» (i : â†¥s), w i) = x), v = â‡‘(fs.weighted_vsub_of_point (Î» (i : â†¥s), p â†‘i) b) w
is_path_connected (coe â»Â¹' W)
Ï†.order = âŠ¤ â†” Ï† = 0
polynomial.cyclotomic n R = (polynomial.X ^ n - 1) /â‚˜ n.proper_divisors.prod (Î» (i : â„•), polynomial.cyclotomic i R)
âˆ¥finset.univ.prod (Î» (j : fin (n + 1)), I.upper j - I.lower j) â€¢ â‡‘f' (pi.single i 1) - (box_integral.integral (I.face i) âŠ¥ (f âˆ˜ i.insert_nth (I.upper i)) box_integral.box_additive_map.volume - box_integral.integral (I.face i) âŠ¥ (f âˆ˜ i.insert_nth (I.lower i)) box_integral.box_additive_map.volume)âˆ¥ â‰¤ 2 * Îµ * â†‘c * finset.univ.prod (Î» (j : fin (n + 1)), I.upper j - I.lower j)
pairwise (disjoint on Î» (n : Î±), set.Ioo (f n) (f (order.succ n)))
s.sum (Î» (i : Î¹), w i â€¢ (pâ‚ i -áµ¥ pâ‚‚)) = â‡‘(s.weighted_vsub pâ‚) w
(nhds c).has_basis (Î» (f : smooth_bump_function I c), tsupport â‡‘f âŠ† s) (Î» (f : smooth_bump_function I c), function.support â‡‘f)
(f =o[l] Î» (x : Î±), -g' x) â†’ f =o[l] g'
âˆƒ (b : â†¥M), âˆ€ (a : S), a âˆˆ s â†’ is_localization.is_integer R (â†‘b â€¢ a)
unique_diff_within_at ğ•œ (f '' s) (f x)
filter.tendsto â‡‘complex.norm_sq (filter.cocompact â„‚) filter.at_top
measurable_space.pi = measurable_space.generate_from (set.univ.pi '' set.univ.pi C)
(Î» (y : E), f (x + y) - p.partial_sum n y) =O[nhds 0] Î» (y : E), âˆ¥yâˆ¥ ^ n
|x - a| â‰¤ |b - a|
t2_space Î± â†” âˆ€ {x y : Î±}, (nhds x âŠ“ nhds y).ne_bot â†’ x = y
â‡‘(polynomial.aeval M) p = â‡‘(polynomial.aeval M) (p %â‚˜ M.charpoly)
uniform_continuous â‡‘f
âŠ¥ â‹– a â†’ is_atom a
âˆƒ (Î± : E), FâŸ®Î±âŸ¯ = âŠ¤
finset.centroid k finset.univ p = 2â»Â¹ â€¢ (p 1 -áµ¥ p 0) +áµ¥ p 0
(Î» (t : Î¹), âˆ« (x : â„) in u t..v t, f x âˆ‚Î¼ + (â‡‘Î¼ (set.Ioc (v t) (u t))).to_real â€¢ c) =o[lt] Î» (t : Î¹), (â‡‘Î¼ (set.Ioc (v t) (u t))).to_real
((âˆ€ (a : â†¥P), â‡‘g (â‡‘f a) = 0) âˆ§ âˆ€ (b : â†¥Q), â‡‘g b = 0 â†’ (âˆƒ (a : â†¥P), â‡‘f a = b)) â†’ category_theory.exact f g
e.source âˆ© â‡‘e â»Â¹' s = e'.source âˆ© â‡‘e' â»Â¹' s
âˆƒ (T : C), âˆ€ (X : C), nonempty (T âŸ¶ X)
vector.scanl f b v = b::áµ¥f b v.head::áµ¥vector.nil
âˆƒ (t : set (Î± Ã— â„)), t.countable âˆ§ (âˆ€ (p : Î± Ã— â„), p âˆˆ t â†’ p.fst âˆˆ s) âˆ§ (âˆ€ (p : Î± Ã— â„), p âˆˆ t â†’ p.snd âˆˆ f p.fst) âˆ§ â‡‘Î¼ (s  â‹ƒ (p : Î± Ã— â„) (hp : p âˆˆ t), metric.closed_ball p.fst p.snd) = 0 âˆ§ t.pairwise_disjoint (Î» (p : Î± Ã— â„), metric.closed_ball p.fst p.snd)
tendsto_uniformly F f p â†” filter.tendsto (Î» (q : Î¹ Ã— Î±), (f q.snd, F q.fst q.snd)) (p.prod âŠ¤) (uniformity Î²)
function.injective â‡‘(â‡‘free_group.lift a)
âˆ¥a ^ nâˆ¥ â‰¤ âˆ¥aâˆ¥ ^ n
âˆ«â» (x : Î±), F (âˆ« (y : Î²), f (x, y) - g (x, y) âˆ‚Î½) âˆ‚Î¼ = âˆ«â» (x : Î±), F (âˆ« (y : Î²), f (x, y) âˆ‚Î½ - âˆ« (y : Î²), g (x, y) âˆ‚Î½) âˆ‚Î¼
âˆƒ (g : Î± â†’ nnreal), (âˆ€ (x : Î±), g x â‰¤ f x) âˆ§ upper_semicontinuous g âˆ§ measure_theory.integrable (Î» (x : Î±), â†‘(g x)) Î¼ âˆ§ âˆ« (x : Î±), â†‘(f x) âˆ‚Î¼ - Îµ â‰¤ âˆ« (x : Î±), â†‘(g x) âˆ‚Î¼
cont_mdiff I I' n f â†” continuous f âˆ§ âˆ€ (y : M'), cont_mdiff_on I (model_with_corners_self ğ•œ E') n (â‡‘(ext_chart_at I' y) âˆ˜ f) (f â»Â¹' (ext_chart_at I' y).source)
ps.pairwise (Î» (p1 p2 : P), has_dist.dist p1 p = has_dist.dist p2 p) â†” ps.pairwise (Î» (p1 p2 : P), has_dist.dist p1 â†‘(â‡‘(euclidean_geometry.orthogonal_projection s) p) = has_dist.dist p2 â†‘(â‡‘(euclidean_geometry.orthogonal_projection s) p))
B.nondegenerate â†” (â‡‘bilin_form.to_lin B).ker = âŠ¥
has_deriv_at (Î» (u : â„), âˆ« (x : â„) in a..u, f x) (f b) b
(m.gcd n).factor_multiset = m.factor_multiset âŠ“ n.factor_multiset
â†‘âŠ¤ = set.univ
0 < finite_dimensional.finrank K â†¥(â‡‘(f.generalized_eigenspace Î¼) k)
pairwise (disjoint on Î» (n : Î±), set.Ioo (f (order.pred n)) (f n))
convolution â‡‘Ï† g (continuous_linear_map.lsmul â„ â„) Î¼ xâ‚€ = measure_theory.integral Î¼ â‡‘Ï† â€¢ g xâ‚€
â†‘s âˆ© â†‘(affine_subspace.mk' p (s.direction)á—®) = {euclidean_geometry.orthogonal_projection_fn s p}
||a|| = |a|
metric.thickening Î´ E = â‹ƒ (x : X) (H : x âˆˆ E), metric.ball x Î´
has_fpower_series_on_ball (Î» (z : ğ•œ), ring.inverse (1 - z â€¢ a)) (Î» (n : â„•), continuous_multilinear_map.mk_pi_field ğ•œ (fin n) (a ^ n)) 0 (â†‘âˆ¥aâˆ¥â‚Š)â»Â¹
(finset.univ.pi t).prod (Î» (x : Î  (a : Î±), a âˆˆ finset.univ â†’ Î´ a), f x) = (fintype.pi_finset t).prod (Î» (x : Î  (a : Î±), Î´ a), f (Î» (a : Î±) (_x : a âˆˆ finset.univ), x a))
âˆƒ (j : set Î±), measurable_set j âˆ§ j âŠ† i âˆ§ measure_theory.vector_measure.restrict s j â‰¤ 0.restrict j âˆ§ â‡‘s j < 0
âˆ€á¶  (t : Î¹) in lt, interval_integrable f Î¼ (u t) (v t)
âˆƒ (y : E) (H : y âˆˆ frontier K), metric.inf_dist x Ká¶œ = has_dist.dist x y
(category_theory.cocone_of_representable P).Î¹.app j = (category_theory.yoneda_sections_small ((category_theory.category_of_elements.Ï€ P).left_op.obj j) (((category_theory.functor.const (P.elements)áµ’áµ–).obj (category_theory.cocone_of_representable P).X).obj j)).inv (opposite.unop j).snd
category_theory.exp_comparison F A â‰« category_theory.whisker_left F (category_theory.pre (F.map f)) = category_theory.whisker_right (category_theory.pre f) F â‰« category_theory.exp_comparison F A'
â‡‘(s.weighted_vsub_of_point p bâ‚) w +áµ¥ bâ‚ = â‡‘(s.weighted_vsub_of_point p bâ‚‚) w +áµ¥ bâ‚‚
F.map (category_theory.limits.prod.map f g) â‰« category_theory.limits.prod_comparison F A' B' = category_theory.limits.prod_comparison F A B â‰« category_theory.limits.prod.map (F.map f) (F.map g)
â‡‘(convex_hull ğ•œ) s = â‹ƒ (t : finset E) (hss : â†‘t âŠ† s) (hai : affine_independent ğ•œ coe), â‡‘(convex_hull ğ•œ) â†‘t
(âˆ€á¶  (x : Î±) in l, âˆ€ (i : Î¹), i âˆˆ I â†’ p i x) â†” âˆ€ (i : Î¹), i âˆˆ I â†’ (âˆ€á¶  (x : Î±) in l, p i x)
âˆƒ (U : set Î±) (H : U âŠ‡ s), is_open U âˆ§ â‡‘Î¼ U < âŠ¤
subgroup.closure â†‘(finset.image (Î» (g : G), âŸ¨g * (â†‘(subgroup.mem_right_transversals.to_fun hR g))â»Â¹, _âŸ©) (R * S)) = âŠ¤
is_open_map â‡‘f
is_noetherian Râ‚ â†¥I
category_theory.limits.image_subobject (h â‰« f) = category_theory.limits.image_subobject f
s.sum (Î» (i : Î¹), |f i|) ^ p â‰¤ â†‘(s.card) ^ (p - 1) * s.sum (Î» (i : Î¹), |f i| ^ p)
continuous â‡‘f
âˆ¥continuous_linear_map.lsmul ğ•œ ğ•œ'âˆ¥ â‰¤ 1
category_theory.limits.coprod_comparison F A B â‰« F.map (category_theory.limits.coprod.map f g) = category_theory.limits.coprod.map (F.map f) (F.map g) â‰« category_theory.limits.coprod_comparison F A' B'
has_Sup.Sup (has_insert.insert a s) = a âŠ” has_Sup.Sup s
|a + b| â‰¤ |a| + |b|
|v - (generalized_continued_fraction.of v).convergents n| â‰¤ 1 / ((generalized_continued_fraction.of v).denominators n * (generalized_continued_fraction.of v).denominators (n + 1))
âˆ«â» (z : Î± Ã— Î²), f z âˆ‚Î¼.prod Î½ = âˆ«â» (x : Î±), âˆ«â» (y : Î²), f (x, y) âˆ‚Î½ âˆ‚Î¼
complete_lattice.independent p â†” âˆ€ (i : Î¹) (x : â†¥(p i)) (v : Î â‚€ (i : Î¹), â†¥(p i)), â‡‘(â‡‘(dfinsupp.lsum â„•) (Î» (i : Î¹), (p i).subtype)) (dfinsupp.erase i v) = â†‘x â†’ x = 0
âˆ« (x : â„) in aâ‚..bâ‚, âˆ« (y : â„) in aâ‚‚..bâ‚‚, â‡‘(f' (x, y)) (1, 0) + â‡‘(g' (x, y)) (0, 1) = (((âˆ« (x : â„) in aâ‚..bâ‚, g (x, bâ‚‚)) - âˆ« (x : â„) in aâ‚..bâ‚, g (x, aâ‚‚)) + âˆ« (y : â„) in aâ‚‚..bâ‚‚, f (bâ‚, y)) - âˆ« (y : â„) in aâ‚‚..bâ‚‚, f (aâ‚, y)
âˆ¥f y - f xâˆ¥ â‰¤ C * âˆ¥y - xâˆ¥
(category_theory.category_of_elements.map Î±).op â‹™ category_theory.category_of_elements.to_costructured_arrow Fâ‚‚ = category_theory.category_of_elements.to_costructured_arrow Fâ‚ â‹™ category_theory.costructured_arrow.map Î±
emetric.diam (f '' s) = emetric.diam s
f' =O[l] g' â†’ ((Î» (x : Î±), âˆ¥f' xâˆ¥) =O[l] Î» (x : Î±), âˆ¥g' xâˆ¥)
a â©¿ b â†’ â‡‘order_dual.to_dual b â©¿ â‡‘order_dual.to_dual a
is_artinian R â†¥(submodule.span R A)
witt_vector.is_poly p (Î» (R : Type u_1) (_Rcr : comm_ring R), witt_vector.init n)
lie_module.weight_space M 0 = âŠ¤
âˆƒ (g : bounded_continuous_function Y â„), âˆ¥gâˆ¥ â‰¤ âˆ¥fâˆ¥ / 3 âˆ§ has_dist.dist (g.comp_continuous e) f â‰¤ 2 / 3 * âˆ¥fâˆ¥
(category_theory.limits.prod.braiding P Q).hom â‰« (category_theory.limits.prod.braiding Q P).hom = ğŸ™ (P â¨¯ Q)
âˆ€á¶  (x : â„) in residual â„, liouville x
v âˆˆ (submodule.span ğ•œ {u})á—®
a * b â‰¤ |a| ^ p / p + |b| ^ q / q
âˆƒ (S : set Î±), measurable_set S âˆ§ measure_theory.vector_measure.restrict j.to_signed_measure S â‰¤ 0.restrict S âˆ§ 0.restrict Sá¶œ â‰¤ measure_theory.vector_measure.restrict j.to_signed_measure Sá¶œ âˆ§ â‡‘(j.pos_part) S = 0 âˆ§ â‡‘(j.neg_part) Sá¶œ = 0
category_theory.epi f â†” function.surjective â‡‘(simplex_category.hom.to_order_hom f)
p1 -áµ¥ (g +áµ¥ p2) = p1 -áµ¥ p2 - g
monoid.is_torsion â†¥H
category_theory.ProjectiveResolution.lift_f_one f P Q â‰« Q.complex.d 1 0 = P.complex.d 1 0 â‰« category_theory.ProjectiveResolution.lift_f_zero f P Q
(upper_bounds s âˆ© t).nonempty â†’ bdd_above (f '' s)
(Î» (t : Î¹), ((âˆ« (x : â„) in v t..b, f x) - âˆ« (x : â„) in u t..b, f x) + (v t - u t) â€¢ c) =o[lt] (v - u)
â‡‘(orthogonal_projection (submodule.span ğ•œ {v})á—®) v = 0
convolution f g (continuous_linear_map.lmul ğ•œ ğ•œ) Î¼ x = âˆ« (t : G), f (x - t) * g t âˆ‚Î¼
âˆ¥f y - f x - â‡‘Ï† (y - x)âˆ¥ â‰¤ C * âˆ¥y - xâˆ¥
f =O[l] g â†” âˆƒ (c : â„), âˆ€á¶  (x : Î±) in l, âˆ¥f xâˆ¥ â‰¤ c * âˆ¥g xâˆ¥
â‡‘h (f.prod g) = f.prod (Î» (a : Î±) (b : M), â‡‘h (g a b))
s.prod (Î» (a : Î±), (t a).sum (Î» (b : Î´ a), f a b)) = (s.pi t).sum (Î» (p : Î  (a : Î±), a âˆˆ s â†’ Î´ a), s.attach.prod (Î» (x : {x // x âˆˆ s}), f x.val (p x.val _)))
category_theory.is_equivalence.of_iso e' (category_theory.is_equivalence.of_iso e hF) = category_theory.is_equivalence.of_iso (e â‰ªâ‰« e') hF
direct_sum.is_internal (add_monoid_algebra.grade_by R â‡‘f)
continuous â‡‘(add_monoid_hom.mul_right x)
bdd_above (â‹ƒ (i : Î²) (H : i âˆˆ I), S i) â†” âˆ€ (i : Î²), i âˆˆ I â†’ bdd_above (S i)
continuous_on â‡‘((hf.to_local_equiv hc).symm) (f '' s)
category_theory.is_pushout 0 (ğŸ™ X) 0 0
(Î» (h : â„), f (x + h â€¢ v + h â€¢ w) - f (x + h â€¢ v) - h â€¢ â‡‘(f' x) w - h ^ 2 â€¢ â‡‘(â‡‘f'' v) w - (h ^ 2 / 2) â€¢ â‡‘(â‡‘f'' w) w) =o[nhds_within 0 (set.Ioi 0)] Î» (h : â„), h ^ 2
â‡‘(convex_hull R) s = â‹ƒ (t : finset E) (w : â†‘t âŠ† s), â‡‘(convex_hull R) â†‘t
âˆ« (x : â„) in a..b, f' x â€¢ (g âˆ˜ f) x = âˆ« (x : â„) in f a..f b, g x
affine_span k (set.range p) = âŠ¤
âˆƒ (K : Î¹ â†’ set Î±), (âˆ€ (i : Î¹), is_compact (K i)) âˆ§ (âˆ€ (i : Î¹), K i âŠ† U i) âˆ§ s = â‹ƒ (i : Î¹) (H : i âˆˆ t), K i
âˆ® (z : â„‚) in C(c, R), (z - w)â»Â¹ â€¢ f z = (2 * â†‘real.pi * complex.I) â€¢ f w
function.injective â‡‘f â†’ âˆ€ (a : â†¥P), â‡‘f a = 0 â†’ a = 0
s.Î¹.app j â‰« k = s.Î¹.app j â‰« l
(fundamental_groupoid.fundamental_groupoid_functor.map g).map p = continuous_map.homotopy.hcast _ â‰« (fundamental_groupoid.fundamental_groupoid_functor.map H.ulift_map).map (continuous_map.homotopy.prod_to_prod_Top_I (ğŸ™ {down := 1}) p) â‰« continuous_map.homotopy.hcast _
hb.oangle x y = Î¸ â†” x â‰  0 âˆ§ y â‰  0 âˆ§ y = (âˆ¥yâˆ¥ / âˆ¥xâˆ¥) â€¢ â‡‘(hb.rotation Î¸) x âˆ¨ Î¸ = 0 âˆ§ (x = 0 âˆ¨ y = 0)
category_theory.limits.pushout f g = x âŠ” y
con_gen â‡‘c = c
has_inner.inner (â‡‘(finsupp.total Î¹ E ğ•œ v) lâ‚) (â‡‘(finsupp.total Î¹ E ğ•œ v) lâ‚‚) = lâ‚.sum (Î» (i : Î¹) (y : ğ•œ), â‡‘(star_ring_end ğ•œ) y * â‡‘lâ‚‚ i)
metric.inf_dist (Î¦ x) (Î¦ '' t) = metric.inf_dist x t
(âˆƒá¶  (x : Î±) in nhds a, x âˆˆ s) â†’ a âˆˆ closure s
f '' connected_component a = {f a}
âˆƒ (xâ‚€ : E), xâ‚€ âˆ‰ F âˆ§ âˆ€ (y : E), y âˆˆ F â†’ r * âˆ¥xâ‚€âˆ¥ â‰¤ âˆ¥xâ‚€ - yâˆ¥
âˆƒ (n : â„•), âˆ€ (m : â„•), n â‰¤ m â†’ f m = âŠ¤
J.covers S (g â‰« f)
submodule.span R {t : tensor_product R M N | âˆƒ (m : M) (n : N), m âŠ—â‚œ[R] n = t} = âŠ¤
set.eq_on â‡‘f â‡‘g â†‘(subsemiring.closure s)
I.radical = I.jacobson â†” âŠ¥.radical = âŠ¥.jacobson
summable (Î» (n : â„•), Î¾ ^ n) â†” âˆ¥Î¾âˆ¥ < 1
submodule.torsion R (M â§¸ submodule.torsion R M) = âŠ¥
âˆƒ (h : P â†’â‚—[R] M), f.comp h = g
c âŠ” d = con_gen (setoid.r âŠ” setoid.r)
tendsto_uniformly_on (Î» (n : â„•) (y : E), p.partial_sum n y) (Î» (y : E), f (x + y)) filter.at_top (metric.ball 0 â†‘r')
c âŠ” d = add_con_gen (setoid.r âŠ” setoid.r)
(âˆ€áµ (x : Î±) âˆ‚Î¼, x âˆˆ set.interval_oc a b â†’ P x) â†” (âˆ€áµ (x : Î±) âˆ‚Î¼, x âˆˆ set.Ioc a b â†’ P x) âˆ§ âˆ€áµ (x : Î±) âˆ‚Î¼, x âˆˆ set.Ioc b a â†’ P x
is_compl K Ká—®
âˆ« (y : â„) in a..b, g' y = g b - g a
lipschitz_with C.to_nnreal â‡‘f
âˆ€áµ (x : Î±) âˆ‚Î½, Î¼.rn_deriv Î½ x < âŠ¤
âˆ¥â‡‘(quotient_add_group.mk' S) mâˆ¥ = 0 â†” m âˆˆ closure â†‘S
category_theory.presieve.is_sheaf_for P â‡‘(category_theory.sieve.bind â‡‘U B)
(â¨ (x : Î±) in t, f x âˆ‚Î¼, â¨ (x : Î±) in t, g (f x) âˆ‚Î¼) âˆˆ {p : E Ã— â„ | p.fst âˆˆ s âˆ§ p.snd â‰¤ g p.fst}
f =O[l] g' â†’ (f =O[l] Î» (x : Î±), âˆ¥g' xâˆ¥)
âˆ« (x : G), f (g * x) âˆ‚Î¼ = âˆ« (x : G), f x âˆ‚Î¼
fintype.card {i // p i â‰  âŠ¥} â‰¤ finite_dimensional.finrank K V
âˆƒ (g : bounded_continuous_function Y â„), âˆ¥gâˆ¥ = âˆ¥fâˆ¥ âˆ§ g.restrict s = f
measure_theory.vadd_invariant_measure â†¥(Î“.opposite) G Î¼
continuous_map.compact_open = â¨… (s : set Î±) (hs : is_compact s), topological_space.induced (continuous_map.restrict s) continuous_map.compact_open
cardinal.mk Î¹ â‰¤ â†‘(fintype.card â†¥w)
disjoint a a â†’ a = âŠ¥
is_field â†¥A
is_add_monoid_hom â‡‘h
âˆ«â» (a : Î±), f a * g a âˆ‚Î¼ = âˆ«â» (a : Î±), f a âˆ‚Î¼ * âˆ«â» (a : Î±), g a âˆ‚Î¼
module.End.has_eigenvector â†‘T (â†‘â¨… (x : {x // x â‰  0}), (Î» (x : E), T.re_apply_inner_self x / âˆ¥xâˆ¥ ^ 2) â†‘x) xâ‚€
filter.tendsto (Î» (i : Î¹), âˆ«â» (a : Î±), â†‘(â‡‘(fs i) a) âˆ‚â†‘Î¼) L (nhds (âˆ«â» (a : Î±), â†‘(f a) âˆ‚â†‘Î¼))
a â‹– âŠ¤ â†’ is_coatom a
category_theory.is_pushout (ğŸ™ X) 0 0 0
cardinal.mk â†¥(set.Ico a b) = cardinal.continuum
set.eq_on â‡‘f â‡‘g â†‘(add_subsemigroup.closure s)
âˆ¥x - yâˆ¥ = |âˆ¥xâˆ¥ - âˆ¥yâˆ¥|
has_strict_fderiv_at (Î» (p : â„ Ã— â„), âˆ« (x : â„) in p.fst..p.snd, f x) ((continuous_linear_map.snd â„ â„ â„).smul_right cb - (continuous_linear_map.fst â„ â„ â„).smul_right ca) (a, b)
â‡‘Î¼ K < âŠ¤
e.to_local_equiv.source âˆ© â‡‘e â»Â¹' t = e.to_local_equiv.source âˆ© s â†’ e.is_image s t
âˆ¥f y - f xâˆ¥ â‰¤ C * âˆ¥y - xâˆ¥
finite_dimensional.finrank R â†¥(submodule.map â†‘f p) = finite_dimensional.finrank R â†¥p
D.diagram_over_open_Ï€ U i â‰« D.Î¹_inv_app_Ï€_eq_map U â‰« D.Î¹_inv_app U â‰« D.diagram_over_open_Ï€ U j = D.diagram_over_open_Ï€ U j
filter.tendsto (Î» (n : â„•), â†‘âˆ¥a ^ nâˆ¥â‚Š ^ (1 / â†‘n)) filter.at_top (nhds (spectral_radius â„‚ a))
filter.tendsto f (nhds_within x (set.Iio x)) (nhds (has_Sup.Sup (f '' set.Iio x)))
subsemigroup.map f (subsemigroup.closure s) = subsemigroup.closure (â‡‘f '' s)
A.det = finset.univ.sum (Î» (j : fin n.succ), (-1) ^ â†‘j * A 0 j * (A.minor fin.succ â‡‘(j.succ_above)).det)
Îµ ^ p.to_real * â‡‘Î¼ {x : Î± | Îµ â‰¤ â†‘âˆ¥f xâˆ¥â‚Š} â‰¤ measure_theory.snorm f p Î¼ ^ p.to_real
(A.mul (â…Ÿ B)).mul B = A
measure_theory.conservative f^[n] Î¼
topological_space.is_separable (f â»Â¹' s)
linear_independent k (Î» (v : â†¥s), â†‘v) â†” affine_independent k (Î» (p : â†¥({pâ‚} âˆª (Î» (v : V), v +áµ¥ pâ‚) '' s)), â†‘p)
(b.to_matrix â‡‘b').mul (b'.to_matrix â‡‘b) = 1
Î¼.inner_content âŸ¨â‹ƒ (i : â„•), U i, _âŸ© â‰¤ âˆ‘' (i : â„•), Î¼.inner_content âŸ¨U i, _âŸ©
(â‹ƒ (i : Î¹') (H : i âˆˆ s), g i).pairwise_disjoint f
âˆƒ (x : Î±) (H : x âˆˆ s) (m : â„•) (H : m â‰  0), f^[m] x âˆˆ s
âˆ« (x : â„) in a..b, c âˆ‚Î¼ = ((â‡‘Î¼ (set.Iic b)).to_real - (â‡‘Î¼ (set.Iic a)).to_real) â€¢ c
uniformity Î± = â¨… (Îµ : ennreal) (H : Îµ > 0), filter.principal {p : Î± Ã— Î± | has_edist.edist p.fst p.snd < Îµ}
dense (â‹‚ (s : Î²) (H : s âˆˆ S), f s)
has_inner.inner x y = âˆ¥xâˆ¥ * âˆ¥yâˆ¥ â†” âˆ¥yâˆ¥ â€¢ x = âˆ¥xâˆ¥ â€¢ y
âˆ¥f.mk_continuous C hâˆ¥ â‰¤ linear_order.max C 0
â‡‘(orthogonal_projection s.direction) (p -áµ¥ â†‘(â‡‘(euclidean_geometry.orthogonal_projection s) p)) = 0
category_theory.presheaf.is_sheaf (opens.grothendieck_topology â†¥X) F â†” F.is_sheaf_opens_le_cover
f =O[l] g' â†’ (f =O[l] Î» (x : Î±), -g' x)
âˆ« (x : Î±), âˆ« (y : Î²), f (x, y) - g (x, y) âˆ‚Î½ âˆ‚Î¼ = âˆ« (x : Î±), âˆ« (y : Î²), f (x, y) âˆ‚Î½ âˆ‚Î¼ - âˆ« (x : Î±), âˆ« (y : Î²), g (x, y) âˆ‚Î½ âˆ‚Î¼
âˆƒ (d : Î±), d â‰  0 âˆ§ âˆ¥d â€¢ xâˆ¥ < Îµ âˆ§ Îµ / âˆ¥câˆ¥ â‰¤ âˆ¥d â€¢ xâˆ¥ âˆ§ âˆ¥dâˆ¥â»Â¹ â‰¤ Îµâ»Â¹ * âˆ¥câˆ¥ * âˆ¥xâˆ¥
â‡‘Î¼ (â‡‘f '' s) = ennreal.of_real |â‡‘linear_map.det â†‘f| * â‡‘Î¼ s
(â¨† (i : Î¹), s i) = â¨† (t : finset Î¹) (i : Î¹) (H : i âˆˆ t), s i
â‡‘f l.sum = (list.map â‡‘f l).sum
âˆ¥f zâˆ¥ â‰¤ C
g '' set.image2 f s t = set.image2 f' s (g' '' t)
â‡‘(â‡‘(fourier_series.repr) f) i = âˆ« (t : â†¥circle), â†‘t ^ -i * â‡‘f t âˆ‚haar_circle
f (has_Inf.Inf s) = has_Inf.Inf (f '' s)
(fundamental_groupoid.fundamental_groupoid_functor.map f).map p = continuous_map.homotopy.hcast _ â‰« (fundamental_groupoid.fundamental_groupoid_functor.map H.ulift_map).map (continuous_map.homotopy.prod_to_prod_Top_I (ğŸ™ {down := 0}) p) â‰« continuous_map.homotopy.hcast _
convex_independent ğ•œ p â†” âˆ€ (i : Î¹) (s : set Î¹), p i âˆ‰ â‡‘(convex_hull ğ•œ) (p '' (s  {i}))
âˆƒ (S : C) (T : Î  {X : C}, X âˆˆ O â†’ (S âŸ¶ X)), âˆ€ {X Y : C} (mX : X âˆˆ O) (mY : Y âˆˆ O) {f : X âŸ¶ Y}, âŸ¨X, âŸ¨Y, âŸ¨mX, âŸ¨mY, fâŸ©âŸ©âŸ©âŸ© âˆˆ H â†’ T mX â‰« f = T mY
âˆƒ (P : finset (ideal R)) [_inst_7 : decidable_eq â†¥P] [_inst_8 : âˆ€ (p : ideal R), p âˆˆ P â†’ prime p] (e : â†¥P â†’ â„•), direct_sum.is_internal (Î» (p : â†¥P), submodule.torsion_by_set R M â†‘(â†‘p ^ e p))
circle_map c R '' set.Ioc 0 (2 * real.pi) = metric.sphere c |R|
add_monoid.is_torsion_free (G â§¸ add_torsion G)
nonempty (V â‰ƒâ‚—[K] Vâ‚‚) â†” finite_dimensional.finrank K V = finite_dimensional.finrank K Vâ‚‚
asymptotics.is_O_with c l f (Î» (x : Î±), âˆ¥g' xâˆ¥) â†’ asymptotics.is_O_with c l f g'
âˆƒ (t : fin n â†’ fin (fintype.card Fq ^ âŒˆ-real.log Îµ / real.log â†‘(fintype.card Fq)âŒ‰â‚Š)), âˆ€ (iâ‚€ iâ‚ : fin n), t iâ‚€ = t iâ‚ â†’ â†‘(â‡‘polynomial.card_pow_degree (A iâ‚ % b - A iâ‚€ % b)) < â‡‘polynomial.card_pow_degree b â€¢ Îµ
â‡‘f l.prod = (list.map â‡‘f l).prod
is_atom a â†’ âŠ¥ â‹– a
(generalized_continued_fraction.of v).h = â†‘âŒŠvâŒ‹
filter.tendsto (Î» (n : Î¹), âˆ«â» (a : Î±), â†‘(â‡‘(fs n) a) âˆ‚â†‘Î¼) L (nhds (â‡‘â†‘Î¼ E))
â‡‘Î¼ s = â¨… (t : {t // s âŠ† t âˆ§ measurable_set t}), â‡‘Î¼ â†‘t
(measure_theory.Lp.bounded_continuous_function E p Î¼).topological_closure = âŠ¤
category_theory.ProjectiveResolution.lift f P Q â‰« Q.Ï€ = P.Ï€ â‰« (chain_complex.singleâ‚€ C).map f
r âŠ” s = eqv_gen.setoid (r.rel âŠ” s.rel)
lipschitz_with C f â†’ âˆ€ (x y : E), âˆ¥f x - f yâˆ¥ â‰¤ â†‘C * âˆ¥x - yâˆ¥
âˆ¥x - yâˆ¥ ^ 2 = âˆ¥xâˆ¥ ^ 2 - 2 * has_inner.inner x y + âˆ¥yâˆ¥ ^ 2
category_theory.cover_preserving J L (F â‹™ G)
â‡‘(probability_theory.cond Î¼ s) t * â‡‘Î¼ s + â‡‘(probability_theory.cond Î¼ sá¶œ) t * â‡‘Î¼ sá¶œ = â‡‘Î¼ t
strict_convex_on ğ•œ ((Î» (z : E), c + z) â»Â¹' s) (f âˆ˜ Î» (z : E), c + z)
â‡‘clifford_algebra.involute (list.map â‡‘(clifford_algebra.Î¹ Q) l).prod = (-1) ^ l.length â€¢ (list.map â‡‘(clifford_algebra.Î¹ Q) l).prod
submodule.map p.subtype âŠ¤ = p
f.mrange = âŠ¤
differentiable_on â„‚ (function.update f c (lim (nhds_within c {c}á¶œ) f)) s
âˆ« (x : â„) in a..b, real.sin x ^ (n + 2) = (real.sin a ^ (n + 1) * real.cos a - real.sin b ^ (n + 1) * real.cos b) / (â†‘n + 2) + (â†‘n + 1) / (â†‘n + 2) * âˆ« (x : â„) in a..b, real.sin x ^ n
(s.altitude i).direction = (vector_span â„ (s.points '' â†‘(finset.univ.erase i)))á—® âŠ“ vector_span â„ (set.range s.points)
complete_lattice.independent p â†” function.injective â‡‘(â‡‘(dfinsupp.lsum â„•) (Î» (i : Î¹), (p i).subtype))
n â‰  0 â†’ f n = n.factorization.prod (Î» (p k : â„•), f (p ^ k))
âŠ¤ âˆˆ F
tendsto_uniformly_on F f p s â†” âˆ€ (Îµ : ennreal), Îµ > 0 â†’ (âˆ€á¶  (n : Î¹) in p, âˆ€ (x : Î²), x âˆˆ s â†’ has_edist.edist (f x) (F n x) < Îµ)
_.mpr q = category_theory.eq_to_hom p â‰« q
same_ray â„ x y â†” âˆ¥xâˆ¥â»Â¹ â€¢ x = âˆ¥yâˆ¥â»Â¹ â€¢ y
(â¨… (hâ‚ : p) (hâ‚‚ : q), s hâ‚ hâ‚‚) = â¨… (h : p âˆ§ q), s _ _
â‡‘f l.prod = (list.map â‡‘f l).prod
f =áµ[Î¼] function.const Î± (â¨ (x : Î±), f x âˆ‚Î¼) âˆ¨ âˆ¥âˆ« (x : Î±), f x âˆ‚Î¼âˆ¥ < (â‡‘Î¼ set.univ).to_real * C
âˆƒ (y : Î²), infinite â†¥(f â»Â¹' {y})
asymptotics.is_O_with c l f' g' â†’ asymptotics.is_O_with c l (Î» (x : Î±), âˆ¥f' xâˆ¥) (Î» (x : Î±), âˆ¥g' xâˆ¥)
unique_diff_on ğ•œ ((ext_chart_at I x).target âˆ© â‡‘((ext_chart_at I x).symm) â»Â¹' (s âˆ© f â»Â¹' (ext_chart_at I' y).source))
âˆ€áµ (x : Î±) âˆ‚Î¼, P x
complex.abs (complex.exp (â†‘a * (complex.exp z + complex.exp (-z)))) â‰¤ real.exp (a * real.cos b * real.exp |z.re|)
finset.univ.sum (Î» (a : Î±), fintype.card â†¥(mul_action.fixed_by Î± Î² a)) = fintype.card (quotient (mul_action.orbit_rel Î± Î²)) * fintype.card Î±
â‡‘((category_theory.unit_comp_partial_bijective_aux A B).symm) f = (category_theory.adjunction.of_right_adjoint i).unit.app A â‰« f
algebraic_geometry.structure_sheaf.to_open â†¥(algebraic_geometry.LocallyRingedSpace.Î“.obj (opposite.op X)) (prime_spectrum.basic_open r) â‰« f = X.to_to_Î“_Spec_map_basic_open r â†” f = X.to_Î“_Spec_c_app r
fderiv_within â„ (Î» (p : â„ Ã— â„), âˆ« (x : â„) in p.fst..p.snd, f x) (s Ã—Ë¢ t) (a, b) = (continuous_linear_map.snd â„ â„ â„).smul_right cb - (continuous_linear_map.fst â„ â„ â„).smul_right ca
âˆƒá¶  (z : â„) in nhds_within x (set.Ioi x), âˆ¥z - xâˆ¥â»Â¹ * âˆ¥f z - f xâˆ¥ < r
âˆ¥xâˆ¥ ^ 2 = âˆ¥â‡‘(orthogonal_projection S) xâˆ¥ ^ 2 + âˆ¥â‡‘(orthogonal_projection Sá—®) xâˆ¥ ^ 2
âˆƒ (f : bounded_continuous_function X â„), set.eq_on â‡‘f (function.const X a) s âˆ§ set.eq_on â‡‘f (function.const X b) t âˆ§ âˆ€ (x : X), â‡‘f x âˆˆ set.Icc a b
frontier sá¶œ = frontier s
âˆƒ (Î´ : ennreal) (H : Î´ > 0), âˆ€ (s : set Î±), â‡‘Î¼ s < Î´ â†’ âˆ«â» (x : Î±) in s, f x âˆ‚Î¼ < Îµ
(f =O[l] Î» (x : Î±), -g' x) â†’ f =O[l] g'
continuous (Î» (f : â†¥(measure_theory.Lp G 1 Î¼)), measure_theory.integrable.to_L1 â‡‘f _)
â†‘(intermediate_field.adjoin â†¥(intermediate_field.adjoin F S) T) = â†‘(intermediate_field.adjoin â†¥(intermediate_field.adjoin F T) S)
(â¨† (i : {i // f i â‰  âŠ¥}), f â†‘i) = â¨† (i : Î¹), f i
âˆ« (x : â„) in t..s + T, f x = (âˆ« (x : â„) in t..s, f x) + âˆ« (x : â„) in t..t + T, f x
e.is_image s t â†’ e.target âˆ© â‡‘(e.symm) â»Â¹' s = e.target âˆ© t
(â‡‘(power_series.monomial R n) a).order = ite (a = 0) âŠ¤ â†‘n
âˆƒ (n : â„•), n âˆˆ finset.card '' {t : finset G | K âŠ† â‹ƒ (g : G) (H : g âˆˆ t), (Î» (h : G), g * h) â»Â¹' V}
(Î½.restrict s).rn_deriv Î½ =áµ[Î½] s.indicator 1
âˆƒ (p : polynomial â„), âˆ€ (x : â„), x âˆˆ set.Icc a b â†’ |polynomial.eval x p - f x| < Îµ
g b - g a â‰¤ âˆ« (y : â„) in a..b, Ï† y
nonempty (category_theory.limits.is_limit (P.map_cone (category_theory.sieve.generate R).arrows.cocone.op)) â†” âˆ€ (E : Aáµ’áµ–), category_theory.presieve.is_sheaf_for (P â‹™ category_theory.coyoneda.obj E) R
real.sin (inner_product_geometry.angle x y) * (âˆ¥xâˆ¥ * âˆ¥yâˆ¥) = real.sqrt (has_inner.inner x x * has_inner.inner y y - has_inner.inner x y * has_inner.inner x y)
âˆ¥fâˆ¥ = 0 â†” f = 0
witt_vector.is_poly p (Î» (R : Type u_1) (_Rcr : comm_ring R) (x : witt_vector p R), f x x)
convex_independent ğ•œ (Î» (i : â†¥s), p â†‘i)
has_inner.inner x y = âˆ¥xâˆ¥ * âˆ¥yâˆ¥
â‡‘(measure_theory.outer_measure.restrict s) (has_Inf.Inf m) = has_Inf.Inf (â‡‘(measure_theory.outer_measure.restrict s) '' m)
subsingleton (Î± â‰ƒ+*o Î²)
vector_span k (set.range p) = submodule.span k (set.range (Î» (i : Î¹), p i0 -áµ¥ p i))
coe â»Â¹' (coe '' U) = â‹ƒ (x : Î±) (H : x âˆˆ U), connected_component x
continuous_on (tangent_map_within I I' f s) (tangent_bundle.proj I M â»Â¹' s)
finite_dimensional.finrank ğ•œ (X âŸ¶ X) = 1
âˆ¥S.normed_mkâˆ¥ = 0
f (has_Inf.Inf s) = has_Inf.Inf (f '' s)
transitive (Î» (a b : S), âˆƒ (c : S), semiconj_by c a b)
(â‡‘â¨… (i : Î¹), m i) s = â¨… (t : â„• â†’ set Î±) (h2 : s âŠ† set.Union t), âˆ‘' (n : â„•), â¨… (i : Î¹), â‡‘(m i) (t n)
finite_dimensional k â†¥((affine_span k s).direction)
has_Sup.Sup (s âˆª t) = has_Sup.Sup s âŠ” has_Sup.Sup t
euclidean_geometry.orthogonal_projection_fn s p -áµ¥ p âˆˆ (s.direction)á—®
topological_space.is_topological_basis (â‹ƒ (i : Î¹), (Î» (u : set (E i)), sigma.mk i '' u) '' s i)
galois_connection (Î» (I : ideal R), prime_spectrum.zero_locus â†‘I) (Î» (t : (set (prime_spectrum R))áµ’áµˆ), prime_spectrum.vanishing_ideal t)
has_fderiv_at (Î» (p : â„ Ã— â„), âˆ« (x : â„) in p.fst..p.snd, f x) ((continuous_linear_map.snd â„ â„ â„).smul_right (f b) - (continuous_linear_map.fst â„ â„ â„).smul_right (f a)) (a, b)
X.Î´ i â‰« X.Î´ (â‡‘fin.cast_succ i) = X.Î´ i â‰« X.Î´ i.succ
finite_dimensional.finrank ğ•œ (X âŸ¶ Y) = 0
e.to_matrix â‡‘(e.units_smul w) = matrix.diagonal (coe âˆ˜ w)
âˆƒ (t : finset Î¹), (s âˆ© â‹‚ (i : Î¹) (H : i âˆˆ t), Z i) = âˆ…
f.range = âŠ¤
âˆ¥measure_theory.Lp_meas_subgroup_to_Lp_trim F p Î¼ hm fâˆ¥ = âˆ¥fâˆ¥
âˆƒ (n : â„•), n â‰  0 âˆ§ (f ^ n).ker âŠ“ (f ^ n).range = âŠ¥
âˆ€á¶  (a : set Î±) in v.filter_at x, â‡‘Î¼ a < âŠ¤
(âˆ€ (x : Î±), âˆƒ (y : Î² x), P x y) â†” âˆƒ (f : Î  (a : Î±), Î² a), âˆ€ (x : Î±), P x (f x)
ennreal.of_real |(matrix.diagonal D).det| â€¢ measure_theory.measure.map â‡‘(â‡‘matrix.to_lin' (matrix.diagonal D)) measure_theory.measure_space.volume = measure_theory.measure_space.volume
a :: lâ‚ <+~ a :: lâ‚‚ â†’ lâ‚ <+~ lâ‚‚
measure_theory.measure.map f Î¼ = measure_theory.measure.sum (Î» (b : Î²), â‡‘Î¼ (f â»Â¹' {b}) â€¢ measure_theory.measure.dirac b)
image_to_kernel f g w â‰« category_theory.limits.kernel_subobject_map Î² = category_theory.limits.image_subobject_map Î± â‰« image_to_kernel f' g' w'
(â¨… (i : Î¹), f i) = b
set.image2 f s (g '' t) = g' '' set.image2 f' t s
â‡‘Î¼ K < âŠ¤
measure_theory.simple_func.integral Î¼ (measure_theory.simple_func.map (ennreal.to_real âˆ˜ g) f) = (âˆ«â» (a : Î±), g (â‡‘f a) âˆ‚Î¼).to_real
category_theory.is_pullback hâ‚â‚ (vâ‚â‚ â‰« vâ‚‚â‚) (vâ‚â‚‚ â‰« vâ‚‚â‚‚) hâ‚ƒâ‚
(Top.presheaf.covering_of_presieve.second_obj_iso_pi_inters F U R).hom â‰« category_theory.limits.pi.Ï€ (Î» (p : (Î£ (V : topological_space.opens â†¥X), {f // R f}) Ã— Î£ (V : topological_space.opens â†¥X), {f // R f}), F.obj (opposite.op (Top.presheaf.covering_of_presieve U R p.fst âŠ“ Top.presheaf.covering_of_presieve U R p.snd))) (f, g) = category_theory.limits.pi.Ï€ (Î» (fg : (Î£ (V : topological_space.opens â†¥X), {f // R f}) Ã— Î£ (W : topological_space.opens â†¥X), {g // R g}), F.obj (opposite.op (category_theory.limits.pullback fg.fst.snd.val fg.snd.snd.val))) (f, g) â‰« F.map (category_theory.eq_to_hom _).op
0.lf x â†” âˆƒ (i : x.left_moves), âˆ€ (j : (x.move_left i).right_moves), 0.lf ((x.move_left i).move_right j)
(polynomial_functions unit_interval).topological_closure = âŠ¤
(Î± â†ª Î²) â†’ (Î² â†ª Î±) â†’ nonempty (Î± â‰ƒ Î²)
continuous (Î» (p : continuous_multilinear_map ğ•œ E G Ã— Î  (i : Î¹), E i), â‡‘(p.fst) p.snd)
add_comm_monoid.add_torsion G = âŠ¤
matrix.det (Î» (i j : n), v i * A i j) = finset.univ.prod (Î» (i : n), v i) * A.det
cardinal.mk â†¥(S âˆª T) â‰¤ cardinal.mk â†¥S + cardinal.mk â†¥T
is_domain (polynomial R â§¸ ideal.map polynomial.C P)
linear_independent L (Î» (f : G â†’* L), â‡‘f)
â…Ÿ A = Aâ»Â¹
âˆƒ (C : â„) (H : C > 0), âˆ€ (n : â„•), âˆ¥p nâˆ¥ â‰¤ C / â†‘r ^ n
cont_diff_on ğ•œ n (f âˆ˜ â‡‘e) (â‡‘e â»Â¹' s) â†” cont_diff_on ğ•œ n f s
â†‘-1 = â†‘n - 1
is_compact s â†” âˆ€ {Î¹ : Type u} (Z : Î¹ â†’ set Î±), (âˆ€ (i : Î¹), is_closed (Z i)) â†’ (s âˆ© â‹‚ (i : Î¹), Z i) = âˆ… â†’ (âˆƒ (t : finset Î¹), (s âˆ© â‹‚ (i : Î¹) (H : i âˆˆ t), Z i) = âˆ…)
f =áµ[Î¼] function.const Î± (â¨ (x : Î±), f x âˆ‚Î¼) âˆ¨ âˆ¥â¨ (x : Î±), f x âˆ‚Î¼âˆ¥ < C
T.morâ‚ â‰« T.morâ‚‚ = 0
function.injective (Î» (_x : P), _x -áµ¥ p)
affine_independent k (Î» (x : â†¥(set.range p)), â†‘x)
spectrum ğ•œ (â‡‘(polynomial.aeval a) p) = (Î» (k : ğ•œ), polynomial.eval k p) '' spectrum ğ•œ a
âˆ« (x : â„) in 0..t, g x â‰¤ has_Sup.Sup ((Î» (t : â„), âˆ« (x : â„) in 0..t, g x) '' set.Icc 0 T) + âŒŠt / TâŒ‹ â€¢ âˆ« (x : â„) in 0..T, g x
âˆ«â» (x : G), f x âˆ‚Î¼ = 0 â†” f = 0
function.semiconj (Î» (x : Î±), â¨† (g' : G), â‡‘(â‡‘fâ‚ g')â»Â¹ (â‡‘(â‡‘fâ‚‚ g') x)) â‡‘(â‡‘fâ‚‚ g) â‡‘(â‡‘fâ‚ g)
category_theory.has_lifting_property i (category_theory.arrow.mk (ğŸ™ X))
s.direction = âŠ¤ â†” s = âŠ¤
âˆ¥â‡‘(add_monoid_hom.mul_right x) yâˆ¥ â‰¤ âˆ¥xâˆ¥ * âˆ¥yâˆ¥
(âˆ€áµ (x : Î±) âˆ‚Î¼.restrict (set.interval_oc a b), P x) â†” (âˆ€áµ (x : Î±) âˆ‚Î¼.restrict (set.Ioc a b), P x) âˆ§ âˆ€áµ (x : Î±) âˆ‚Î¼.restrict (set.Ioc b a), P x
â¨ (x : Î±), g (f x) âˆ‚Î¼ â‰¤ g (â¨ (x : Î±), f x âˆ‚Î¼)
âˆ«â» (x : G), f (x + g) âˆ‚Î¼ = âˆ«â» (x : G), f x âˆ‚Î¼
function.bijective â‡‘(algebra_map K Kâ‚˜)
function.injective â‡‘(I.quotient_map f le_rfl)
âŸ¦x.some_ray_vectorâŸ§ = x
algebraic_topology.alternating_face_map_complex.obj_d X (n + 1) â‰« algebraic_topology.alternating_face_map_complex.obj_d X n = 0
filter.tendsto f filter.at_top (nhds b) â†” âˆ€ (Îµ : â„), 0 < Îµ â†’ (âˆƒ (N : Î±), âˆ€ (n : Î±), N < n â†’ âˆ¥f n - bâˆ¥ < Îµ)
(f =O[l] Î» (x : Î±), âˆ¥g' xâˆ¥) â†’ f =O[l] g'
finsupp.map_domain â‡‘f (x * y) = finsupp.map_domain â‡‘f x * finsupp.map_domain â‡‘f y
function.bijective â‡‘(polynomial.gal.gal_action_hom p â„‚)
âˆƒ (m : M), â‡‘(quotient_add_group.mk' S) m = x âˆ§ âˆ¥mâˆ¥ < âˆ¥xâˆ¥ + Îµ
â‡‘((ext_chart_at I x).symm) â»Â¹' t âˆˆ nhds_within (â‡‘(ext_chart_at I x) x') (â‡‘((ext_chart_at I x).symm) â»Â¹' s âˆ© set.range â‡‘I)
â†‘(â‡‘(category_theory.limits.trident.is_limit.hom_iso ht Z') (q â‰« k)) = q â‰« â†‘(â‡‘(category_theory.limits.trident.is_limit.hom_iso ht Z) k)
pairwise (disjoint on Î» (n : Î±), set.Ico (f (order.pred n)) (f n))
â‡‘f s.prod = (multiset.map â‡‘f s).prod
0.order = âŠ¤
add_subgroup.map f (add_subgroup.closure s) = add_subgroup.closure (â‡‘f '' s)
âˆ¥x + yâˆ¥ ^ 2 = âˆ¥xâˆ¥ ^ 2 + 2 * has_inner.inner x y + âˆ¥yâˆ¥ ^ 2
âˆ«â» (x : G), f (g * x) âˆ‚Î¼ = âˆ«â» (x : G), f x âˆ‚Î¼
is_coprime (polynomial.X - â‡‘polynomial.C a) (f /â‚˜ (polynomial.X - â‡‘polynomial.C a))
topological_space.is_separable (f '' s)
simplex_category.Î´ i.succ â‰« simplex_category.Ïƒ i = ğŸ™ (simplex_category.mk n)
upper_central_series_step H = subgroup.comap (quotient_group.mk' H) (subgroup.center (G â§¸ H))
collinear k s â†” finite_dimensional.finrank k â†¥(vector_span k s) â‰¤ 1
function.bijective â‡‘f âˆ¨ f = 0
algebra.discr K â‡‘(B.basis) â€¢ z âˆˆ algebra.adjoin R {B.gen}
function.injective â‡‘f â†” âˆ€ (a : G), â‡‘f a = 1 â†’ a = 1
âˆƒ (i j : set Î±), measurable_set i âˆ§ 0.restrict i â‰¤ measure_theory.vector_measure.restrict s i âˆ§ measurable_set j âˆ§ measure_theory.vector_measure.restrict s j â‰¤ 0.restrict j âˆ§ is_compl i j
affine_independent k p â†” finite_dimensional.finrank k â†¥(vector_span k (set.range p)) = n
vector_span k s = submodule.span k ((Î» (_x : P), _x -áµ¥ p) '' s)
âˆ€áµ (x : Î±) âˆ‚Î¼, filter.tendsto (Î» (a : set Î±), â‡‘Ï a / â‡‘Î¼ a) (v.filter_at x) (nhds (Ï.rn_deriv Î¼ x))
matrix.det (Î» (i j : n), v j * A i j) = finset.univ.prod (Î» (i : n), v i) * A.det
âˆƒ (Î´ : â„), 0 < Î´ âˆ§ Î´ < 1 âˆ§ âˆ€ (s : finset E), (âˆ€ (c : E), c âˆˆ s â†’ âˆ¥câˆ¥ â‰¤ 2) â†’ (âˆ€ (c : E), c âˆˆ s â†’ âˆ€ (d : E), d âˆˆ s â†’ c â‰  d â†’ 1 - Î´ â‰¤ âˆ¥c - dâˆ¥) â†’ s.card â‰¤ besicovitch.multiplicity E
â‡‘((category_theory.tensor_right_hom_equiv (X' âŠ— X) Y Y' (Z' âŠ— Z)).symm) ((g âŠ— f) â‰« (Î±_ Z' Z Y').inv) = (Î±_ X' X Y).hom â‰« (g âŠ— â‡‘((category_theory.tensor_right_hom_equiv X Y Y' Z).symm) f)
measure_theory.condexp m Î¼ f =áµ[Î¼.restrict s] measure_theory.condexp mâ‚‚ Î¼ f
dense (â‹ƒ (s : Î²), interior (f s))
filter.tendsto (Î» (i : â„•), âˆ‘' (k : â„•), f (k + i)) filter.at_top (nhds 0)
uniform_continuous â‡‘f â†” is_open â†‘(â†‘f.ker)
f âˆˆ s.finsupp â‡‘t â†” âˆ€ (i : Î¹), â‡‘f i âˆˆ â‡‘t i
box_integral.has_integral I âŠ¥ (Î» (x : fin (n + 1) â†’ â„), finset.univ.sum (Î» (i : fin (n + 1)), â‡‘(f' x) (pi.single i 1) i)) box_integral.box_additive_map.volume (finset.univ.sum (Î» (i : fin (n + 1)), box_integral.integral (I.face i) âŠ¥ (Î» (x : fin n â†’ â„), f (i.insert_nth (I.upper i) x) i) box_integral.box_additive_map.volume - box_integral.integral (I.face i) âŠ¥ (Î» (x : fin n â†’ â„), f (i.insert_nth (I.lower i) x) i) box_integral.box_additive_map.volume))
I = âŠ¥ âˆ¨ I = âŠ¤
summable (Î» (i : Î±), âˆ¥â‡‘f iâˆ¥ * âˆ¥â‡‘g iâˆ¥) âˆ§ âˆ‘' (i : Î±), âˆ¥â‡‘f iâˆ¥ * âˆ¥â‡‘g iâˆ¥ â‰¤ âˆ¥fâˆ¥ * âˆ¥gâˆ¥
â‡‘Î¼ (â‡‘f â»Â¹' s) = ennreal.of_real |(â‡‘linear_map.det f)â»Â¹| * â‡‘Î¼ s
box_integral.has_integral I l f Î¼.to_box_additive.to_smul (âˆ« (x : Î¹ â†’ â„) in â†‘I, f x âˆ‚Î¼)
reflection âŠ¥ = linear_isometry_equiv.neg ğ•œ
â‡‘(measure_theory.measure.hausdorff_measure d) s = â¨† (r : ennreal) (hr : 0 < r), â¨… (t : â„• â†’ set X) (hts : s âŠ† â‹ƒ (n : â„•), t n) (ht : âˆ€ (n : â„•), emetric.diam (t n) â‰¤ r), âˆ‘' (n : â„•), â¨† (h : (t n).nonempty), emetric.diam (t n) ^ d
â‡‘f x = â‡‘f y â†’ (âˆƒ (z : â†¥P), â‡‘f z = 0 âˆ§ âˆ€ (R : C) (g : P âŸ¶ R), â‡‘g y = 0 â†’ â‡‘g z = â‡‘g x)
fourier_subalgebra.topological_closure = âŠ¤
filter.tendsto f (nhds_within c {c}á¶œ) (nhds (lim (nhds_within c {c}á¶œ) f))
âˆƒ (f : (Î  (n : â„•), E n) â†’ Î  (n : â„•), E n), (âˆ€ (x : Î  (n : â„•), E n), x âˆˆ s â†’ f x = x) âˆ§ set.range f = s âˆ§ continuous f
âˆƒ (v : F) (H : v âˆˆ K), âˆ¥u - vâˆ¥ = â¨… (w : â†¥K), âˆ¥u - â†‘wâˆ¥
has_inner.inner x y = (âˆ¥x + yâˆ¥ * âˆ¥x + yâˆ¥ - âˆ¥xâˆ¥ * âˆ¥xâˆ¥ - âˆ¥yâˆ¥ * âˆ¥yâˆ¥) / 2
âˆƒ (t : â„• â†’ set E) (A : â„• â†’ (E â†’L[â„] F)), pairwise (disjoint on t) âˆ§ (âˆ€ (n : â„•), measurable_set (t n)) âˆ§ (s âŠ† â‹ƒ (n : â„•), t n) âˆ§ (âˆ€ (n : â„•), approximates_linear_on f (A n) (s âˆ© t n) (r (A n))) âˆ§ (s.nonempty â†’ âˆ€ (n : â„•), âˆƒ (y : E) (H : y âˆˆ s), A n = f' y)
(â‹ƒ (a : Î±), â†‘(f a)).finite
measurable (Î» (x : Î±), âˆ«â» (y : Î²), f (x, y) âˆ‚Î½)
vector_span k (set.range p) = submodule.span k (set.range (Î» (i : {x // x â‰  iâ‚€}), p â†‘i -áµ¥ p iâ‚€))
is_closed (coe_fn '' normed_space.polar ğ•œ s)
(â‹ƒ (k : Îº), â†‘((â‡‘(b.repr) (v k)).support)) = set.univ
category_theory.pretopology.to_grothendieck C âŠ¥ = âŠ¥
f (â¨… (i : Î¹), g i) = â¨… (i : Î¹), f (g i)
affine_span k (â‹ƒ (i : Î¹), s i) = â¨† (i : Î¹), affine_span k (s i)
continuous_on f (s Ã—Ë¢ t)
continuous_at â‡‘f x
âˆ« (x : Î±) in s, f i x âˆ‚Î¼ â‰¤ âˆ« (x : Î±) in s, f j x âˆ‚Î¼
â‡‘is_R_or_C.re (has_inner.inner x y) = (âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + âˆ¥yâˆ¥ * âˆ¥yâˆ¥ - âˆ¥x - yâˆ¥ * âˆ¥x - yâˆ¥) / 2
âˆ«â» (x : Î±), f x âˆ‚Î¼ â‰¤ C
closure s âŠ† interior (â‡‘(affine_map.homothety x t) '' s)
continuous_on (Î» (p : E Ã— E), â‡‘(fderiv_within ğ•œ f s p.fst) p.snd) (s Ã—Ë¢ set.univ)
is_GÎ´ (â‹ƒ (i : Î¹) (H : i âˆˆ s), f i)
â‡‘(affine_homeomorph a b _) '' set.Icc 0 1 = set.Icc b (a + b)
(Ï† + Ïˆ).order = Ï†.order âŠ“ Ïˆ.order
measure_theory.mem_â„’p.to_Lp â‡‘(f + g) _ = measure_theory.mem_â„’p.to_Lp â‡‘f _ + measure_theory.mem_â„’p.to_Lp â‡‘g _
convex ğ•œ ((Î» (x : E), x + z) â»Â¹' s)
is_preconnected (â‹ƒ (n : Î²) (H : n âˆˆ t), s n)
(â¨… (x : L), (â‡‘(lie_algebra.ad R L) x).maximal_generalized_eigenspace 0) = âŠ¤
(âˆ€ (A : finset Î±), A.card â‰¤ fintype.card â†¥(rel.image r â†‘A)) â†” âˆƒ (f : Î± â†’ Î²), function.injective f âˆ§ âˆ€ (x : Î±), r x (f x)
convex_on ğ•œ s â‡‘f
âˆƒ (a : â„) (H : a âˆˆ set.Ioo 0 1), (Î» (n : â„•), âˆ¥p nâˆ¥ * â†‘r ^ n) =o[filter.at_top] has_pow.pow a
convolution f g L Î¼ xâ‚€ = âˆ« (t : G), â‡‘(â‡‘L (f t)) (g xâ‚€) âˆ‚Î¼
âˆ«â» (a : Î²), f a âˆ‚measure_theory.measure.map g Î¼ = âˆ«â» (a : Î±), f (g a) âˆ‚Î¼
f â‰« category_theory.is_filtered.coeq_hom f f' = f' â‰« category_theory.is_filtered.coeq_hom f f'
same_ray â„ x y â†” x = 0 âˆ¨ y = 0 âˆ¨ âˆ¥xâˆ¥â»Â¹ â€¢ x = âˆ¥yâˆ¥â»Â¹ â€¢ y
finite_dimensional.finrank ğ•œ â†¥Kâ‚ + finite_dimensional.finrank ğ•œ â†¥(Kâ‚á—® âŠ“ Kâ‚‚) = finite_dimensional.finrank ğ•œ â†¥Kâ‚‚
â‡‘h (f.sum g) = f.sum (Î» (a : Î±) (b : M), â‡‘h (g a b))
is_connected (â‹ƒ (n : Î¹) (H : n âˆˆ t), s n)
âˆ«â» (a : Î±), f a âˆ‚Î¼ = â¨† (Ï† : measure_theory.simple_func Î± nnreal) (hf : âˆ€ (x : Î±), â†‘(â‡‘Ï† x) â‰¤ f x), (measure_theory.simple_func.map coe Ï†).lintegral Î¼
monotone (f âŠ” g)
âˆƒ! (d : t.X âŸ¶ s.X), âˆ€ (j : J), t.Î¹.app j â‰« d = s.Î¹.app j
(r â€¢ m) âŠ—â‚œ[R] n = m âŠ—â‚œ[R] (r â€¢ n)
(x âˆˆ â¨† (i : Î¹), S i) â†” âˆƒ (i : Î¹), x âˆˆ S i
âˆƒ (r : nnreal) (H : r > 0), summable (Î» (i : Î£ (n : â„•), composition n), âˆ¥q.comp_along_composition p i.sndâˆ¥â‚Š * r ^ i.fst)
â†‘(s.direction) = has_vsub.vsub p '' â†‘s
is_compact (â‡‘weak_dual.to_normed_dual â»Â¹' metric.closed_ball x' r)
âˆƒ (g : Î± â†’ ereal), (âˆ€ (x : Î±), g x < â†‘(f x)) âˆ§ upper_semicontinuous g âˆ§ measure_theory.integrable (Î» (x : Î±), (g x).to_real) Î¼ âˆ§ (âˆ€áµ (x : Î±) âˆ‚Î¼, âŠ¥ < g x) âˆ§ âˆ« (x : Î±), f x âˆ‚Î¼ < âˆ« (x : Î±), (g x).to_real âˆ‚Î¼ + Îµ
emetric.Hausdorff_edist s âˆ… = âŠ¤
âˆ«â» (a : Î±), (f * g) a âˆ‚Î¼ â‰¤ (âˆ«â» (a : Î±), f a ^ p âˆ‚Î¼) ^ (1 / p) * (âˆ«â» (a : Î±), g a ^ q âˆ‚Î¼) ^ (1 / q)
finite_dimensional.finrank ğ•œ â†¥K + finite_dimensional.finrank ğ•œ â†¥Ká—® = finite_dimensional.finrank ğ•œ E
âˆƒ (t : set P), s âŠ† t âˆ§ t âŠ† u âˆ§ affine_independent â„ coe âˆ§ affine_span â„ t = âŠ¤
D.opens_image_preimage_map i j U â‰« (D.to_glue_data.f j k).c.app (opposite.op ((topological_space.opens.map (D.to_glue_data.Î¹ j).base).obj (_.functor.obj U))) = (category_theory.limits.pullback.fst â‰« D.to_glue_data.t j i â‰« D.to_glue_data.f i j).c.app (opposite.op U) â‰« _.inv_app (opposite.unop ((topological_space.opens.map (category_theory.limits.pullback.fst â‰« D.to_glue_data.t j i â‰« D.to_glue_data.f i j).base).op.obj (opposite.op U))) â‰« (D.to_glue_data.V (j, k)).presheaf.map (category_theory.eq_to_hom _)
e.prod e' âˆˆ cont_diff_groupoid âŠ¤ (I.prod I')
monoid.is_torsion_free (G â§¸ torsion G)
â‡‘(measure_theory.measure.hausdorff_measure d) (f '' s) â‰¤ â†‘C ^ d * â‡‘(measure_theory.measure.hausdorff_measure (â†‘r * d)) s
âˆ¥â‡‘f mâ‚ - â‡‘f mâ‚‚âˆ¥ â‰¤ âˆ¥fâˆ¥ * finset.univ.sum (Î» (i : Î¹), finset.univ.prod (Î» (j : Î¹), ite (j = i) âˆ¥mâ‚ i - mâ‚‚ iâˆ¥ (linear_order.max âˆ¥mâ‚ jâˆ¥ âˆ¥mâ‚‚ jâˆ¥)))
âŠ¤.fg
lie_module.is_nilpotent R L M â†” âˆƒ (k : â„•), lie_module.lower_central_series R L M k = âŠ¥
f ^ k = â‡‘(polynomial.aeval f) (polynomial.X ^ k %â‚˜ f.charpoly)
(A.mul B).mul (â…Ÿ B) = A
strict_concave_on ğ•œ ((Î» (z : E), c + z) â»Â¹' s) (f âˆ˜ Î» (z : E), z + c)
âˆ«â» (a : Î±), (â¨† (n : â„•), f n a) âˆ‚Î¼ = â¨† (n : â„•), âˆ«â» (a : Î±), f n a âˆ‚Î¼
(f =o[l] Î» (x : Î±), âˆ¥g' xâˆ¥) â†’ f =o[l] g'
(âˆ€áµ (x : Î±) âˆ‚Î¼.restrict s, p x) â†’ (âˆ€áµ (x : Î±) âˆ‚Î¼.restrict t, p x)
âˆƒ (Î¹ : Type u) (c : Î¹ â†’ Î±) (r r' : Î¹ â†’ â„), (âˆ€ (i : Î¹), 0 < r i âˆ§ r i < r' i âˆ§ r' i < R (c i)) âˆ§ locally_finite (Î» (i : Î¹), metric.ball (c i) (r' i)) âˆ§ (â‹ƒ (i : Î¹), metric.ball (c i) (r i)) = set.univ
fintype.card (â†¥(H.normalizer) â§¸ subgroup.comap H.normalizer.subtype H) â‰¡ fintype.card (G â§¸ H) [MOD p]
category_theory.abelian.factor_thru_image f â‰« category_theory.abelian.image.Î¹ f = f
nonempty (category_theory.limits.is_limit (P.map_cone S.arrows.cocone.op)) â†” âˆ€ (E : Aáµ’áµ–), category_theory.presieve.is_sheaf_for (P â‹™ category_theory.coyoneda.obj E) â‡‘S
unique_diff_on ğ•œ ((ext_chart_at I x).target âˆ© â‡‘((ext_chart_at I x).symm) â»Â¹' s)
â‡‘Î¼ (f â»Â¹' s) â‰¤ â‡‘(measure_theory.measure.map f Î¼) s
pairwise (Î» (a b : Î¹), has_inner.inner (gram_schmidt ğ•œ f a) (gram_schmidt ğ•œ f b) = 0)
â†‘u âŠ† s -áµ¥ t â†’ (âˆƒ (s' t' : finset Î²), â†‘s' âŠ† s âˆ§ â†‘t' âŠ† t âˆ§ u âŠ† s' -áµ¥ t')
dense (â‹‚ (s : Î²), f s)
function.is_fixed_pt f (contracting_with.fixed_point f^[n] hf)
open_embedding â‡‘(category_theory.limits.limit.Ï€ (category_theory.limits.cospan f g) category_theory.limits.walking_cospan.one)
s1.direction âŠ” s2.direction â‰¤ (s1 âŠ” s2).direction
is_preconnected (â‹ƒ (n : Î¹) (H : n âˆˆ t), s n)
fixing_submonoid M (â‹ƒ (i : Î¹), s i) = â¨… (i : Î¹), fixing_submonoid M (s i)
deriv (Î» (u : â„), âˆ« (x : â„) in u..b, f x) a = -c
strict_concave_on ğ•œ s (f âŠ“ g)
tendsto_uniformly_on (Î» (n : â„•) (y : E), p.partial_sum n (y - x)) f filter.at_top (metric.ball x â†‘r')
asymptotics.is_O_with c l (Î» (x : Î±), âˆ¥f' xâˆ¥) g â†’ asymptotics.is_O_with c l f' g
continuous (Î» (f : C(Î±, Î²)), â‡‘f a)
set.range (circle_map c R) = metric.sphere c |R|
âˆ« (y : â„) in a..b, f' y = f b - f a
âˆ‘' (i : â„•), m (â‹ƒ (b : Î³) (H : b âˆˆ encodable.decodeâ‚‚ Î³ i), s b) = âˆ‘' (b : Î³), m (s b)
finsum (Î» (a : Î±), finsum (Î» (H : a âˆˆ â‹ƒ (i : Î¹), t i), f a)) = finsum (Î» (i : Î¹), finsum (Î» (a : Î±), finsum (Î» (H : a âˆˆ t i), f a)))
continuous â‡‘f
âˆ« (x : â„) in a..b, f' x = f b - f a
nontrivial (Î  (i : I), f i)
âˆƒ (Î± : E), FâŸ®Î±âŸ¯ = âŠ¤
continuous â‡‘F
add_semiconj_by (â†‘-a) y x
algebra.discr K â‡‘((is_primitive_root.power_basis K hÎ¶).basis) = (-1) ^ (â†‘p ^ k * (â†‘p - 1) / 2) * â†‘p ^ (â†‘p ^ k * ((â†‘p - 1) * (k + 1) - 1))
x âˆˆ set.Icc a b â†’ âˆ¥f xâˆ¥ â‰¤ B x
(â‡‘(polynomial.taylor r) f).sum (Î» (i : â„•) (a : R), â‡‘polynomial.C a * (polynomial.X - â‡‘polynomial.C r) ^ i) = f
(âˆ€ (g : G) (A : set G), measurable_set A â†’ â‡‘Î¼ ((Î» (h : G), g + h) â»Â¹' A) = â‡‘Î¼ A) â†” Î¼.is_add_left_invariant
cont_mdiff_on I.tangent I'.tangent m (tangent_map_within I I' f s) (tangent_bundle.proj I H â»Â¹' s)
(â¨† (i : Î¹'), s i) = â¨† (t : finset (plift Î¹')) (i : plift Î¹') (H : i âˆˆ t), s i.down
set.Icc (f b) (f a) âŠ† f '' set.Icc a b
filter.tendsto u f (nhds a) â†” âˆ€ (Îµ : ennreal), Îµ > 0 â†’ (âˆ€á¶  (x : Î±) in f, u x âˆˆ set.Icc (a - Îµ) (a + Îµ))
dimH (f '' s) â‰¤ dimH s
let g : generalized_continued_fraction K := generalized_continued_fraction.of v, B : K := (g.continuants_aux (n + 1)).b, pB : K := (g.continuants_aux n).b in v - g.convergents n = ite (ifp.fr = 0) 0 ((-1) ^ n / (B * ((ifp.fr)â»Â¹ * B + pB)))
âˆƒ (K : subgroup G), fintype.card â†¥K = p ^ (n + 1) âˆ§ H â‰¤ K
subsingleton (Î± â‰ƒ+*o Î²)
concave_on ğ•œ s â‡‘f
âˆƒ (n : â„•) (Î¹ : Type u) [_inst_8 : fintype Î¹] (p : Î¹ â†’ R) [_inst_9 : âˆ€ (i : Î¹), irreducible (p i)] (e : Î¹ â†’ â„•), nonempty (N â‰ƒâ‚—[R] (fin n â†’â‚€ R) Ã— direct_sum Î¹ (Î» (i : Î¹), R â§¸ submodule.span R {p i ^ e i}))
âˆ¥âˆ¯ (x : fin n â†’ â„‚) in T(c, R), f xâˆ¥ â‰¤ (2 * real.pi) ^ n * finset.univ.prod (Î» (i : fin n), |R i|) * C
infi f * x = â¨… (i : Î¹), f i * x
âˆ«â» (a : Î±), (f * g) a âˆ‚Î¼ = âˆ«â» (a : Î±), f a âˆ‚Î¼ * âˆ«â» (a : Î±), g a âˆ‚Î¼
set.eq_on â‡‘(e.symm) â‡‘(e'.symm) e.to_local_equiv.target
âˆƒ (w : set E) (b : hilbert_basis â†¥w ğ•œ E), â‡‘b = coe
I.jacobson = I â†” âˆƒ (M : set (ideal R)), (âˆ€ (J : ideal R), J âˆˆ M â†’ J.is_maximal âˆ¨ J = âŠ¤) âˆ§ I = has_Inf.Inf M
(â¨… (x : L), (â‡‘(lie_module.to_endomorphism R L M) x).maximal_generalized_eigenspace 0) = âŠ¤
âˆ¥â‡‘f mâˆ¥â‚Š â‰¤ âˆ¥fâˆ¥â‚Š * finset.univ.prod (Î» (i : Î¹), âˆ¥m iâˆ¥â‚Š)
finite_dimensional.finrank K â†¥(f.range) + finite_dimensional.finrank K â†¥(f.ker) = finite_dimensional.finrank K V
dense (â‹‚ (n : â„•), f n)
(filter.map (Î» (_x : Î±), b) (filter.principal {a})).coprod (filter.map id (filter.principal {i})) = filter.principal ({b} Ã—Ë¢ set.univ âˆª set.univ Ã—Ë¢ {i})
algebra.finite_type R A â†” âˆƒ (s : finset A) (f : mv_polynomial {x // x âˆˆ s} R â†’â‚[R] A), function.surjective â‡‘f
category_theory.forget_enrichment.hom_to W (ğŸ™ X) = category_theory.e_id W (category_theory.forget_enrichment.to W X)
function.injective â‡‘(â‡‘free_product.lift f)
s.sum (Î» (i : Î¹), w i â€¢ (pâ‚ i -áµ¥ pâ‚‚)) = â‡‘(s.affine_combination pâ‚) w -áµ¥ pâ‚‚
continuous â‡‘(f.linear) â†” continuous â‡‘f
â‡‘f s.sum = (multiset.map â‡‘f s).sum
has_strict_deriv_at (Î» (u : â„), âˆ« (x : â„) in u..b, f x) (-c) a
has_dist.dist t.orthocenter (â‡‘(euclidean_geometry.reflection (affine_span â„ (t.points '' â†‘{iâ‚, iâ‚‚}))) (affine.simplex.circumcenter t)) = affine.simplex.circumradius t
âˆ¥continuous_linear_map.lsmul ğ•œ ğ•œ'âˆ¥ = 1
âˆƒ (C : â„) (H : C â‰¥ 0), âˆ€ (y : F), âˆƒ (x : E), has_dist.dist (â‡‘f x) y â‰¤ 1 / 2 * âˆ¥yâˆ¥ âˆ§ âˆ¥xâˆ¥ â‰¤ C * âˆ¥yâˆ¥
fintype.card (lucas_lehmer.X q)Ë£ < â†‘q ^ 2
has_edist.edist x y â‰  âŠ¤
â†‘u.product M âŠ¨ Ï† â†” âˆ€á¶  (a : Î±) in â†‘u, M a âŠ¨ Ï†
convex_on ğ•œ (â‡‘g â»Â¹' s) (f âˆ˜ â‡‘g)
witt_vector.is_polyâ‚‚ p (Î» (R : Type u_1) (_Rcr : comm_ring R) (x y : witt_vector p R), g (f x y))
witt_vector.is_poly p (Î» (R : Type u_1) (_x : comm_ring R), has_neg.neg)
â‡‘(linear_map.inr ğ•œ E F) '' tangent_cone_at ğ•œ t y âŠ† tangent_cone_at ğ•œ (s Ã—Ë¢ t) (x, y)
{c : cardinal | âˆƒ (S : set Î±), (âˆ€ (a : Î±), âˆƒ (b : Î±) (H : b âˆˆ S), r a b) âˆ§ cardinal.mk â†¥S = c}.nonempty
âˆƒ (b' : basis Î¹ R S) (a : Î¹ â†’ R) (ab' : basis Î¹ R â†¥I), âˆ€ (i : Î¹), â†‘(â‡‘ab' i) = a i â€¢ â‡‘b' i
deriv_within (Î» (u : â„), âˆ« (x : â„) in a..u, f x) s b = f b
f (â¨† (i : Î³), g i) = â¨† (i : Î³), f (g i)
y â‰« category_theory.limits.limit.Ï€ (category_theory.Ran.diagram G.op â„±.val (opposite.op V)) W = (category_theory.Ran_is_sheaf_of_cover_lifting.glued_limit_cone hu â„± hS hx).Ï€.app ((category_theory.structured_arrow.map f.op).obj W)
filter.tendsto (â‡‘Î¼ âˆ˜ s) filter.at_top (nhds (â‡‘Î¼ (â‹ƒ (n : Î¹), s n)))
continuous (Î» (p : C(Î±, Î²) Ã— Î±), â‡‘(p.fst) p.snd)
has_Inf.Inf (has_insert.insert a s) = a âŠ“ has_Inf.Inf s
is_monoid_hom â‡‘h
âŠ¤.is_SRG_with (fintype.card V) (fintype.card V - 1) (fintype.card V - 2) Î¼
sá¶œ âˆˆ f
âˆƒáµ (x : Î±) âˆ‚Î¼, x âˆˆ s âˆ§ âˆƒá¶  (n : â„•) in filter.at_top, f^[n] x âˆˆ s
â‡‘(has_Inf.Inf S) = has_Inf.Inf (coe_fn '' S)
(measure_theory.measure.map â‡‘f Î¼).is_add_haar_measure
âˆƒ (g : â†¥A), âˆ€ (x : X), âˆ¥â‡‘g x - f xâˆ¥ < Îµ
nonempty (C â‰Œ category_theory.discrete punit) â†” nonempty C âˆ§ âˆ€ (x y : C), nonempty (unique (x âŸ¶ y))
âˆ« (x : â„) in a..b, f x âˆ‚Î¼ < âˆ« (x : â„) in a..b, g x âˆ‚Î¼
k â‰« s.Ï€.app j = l â‰« s.Ï€.app j
(â‡‘(b.repr) x).sum (Î» (i : Î¹) (xi : Râ‚‚), (â‡‘(b.repr) y).sum (Î» (j : Î¹) (yj : Râ‚‚), xi â€¢ yj â€¢ â‡‘Bâ‚‚ (â‡‘b i) (â‡‘b j))) = â‡‘Bâ‚‚ x y
â‡‘Î¼ (â‡‘f '' s) = ennreal.of_real |â‡‘linear_map.det â†‘f| * â‡‘Î¼ s
has_fderiv_within_at (Î» (p : â„ Ã— â„), âˆ« (x : â„) in p.fst..p.snd, f x) ((continuous_linear_map.snd â„ â„ â„).smul_right (f b) - (continuous_linear_map.fst â„ â„ â„).smul_right (f a)) (s Ã—Ë¢ t) (a, b)
g +áµ¥ p -áµ¥ p = g
(cont_diff_groupoid âŠ¤ I).local_invariant_prop (cont_diff_groupoid âŠ¤ I') (cont_diff_within_at_prop I I' n)
function.bijective â‡‘(algebra_map R Râ‚˜)
(âˆ‘' (n : â„•), f n) * âˆ‘' (n : â„•), g n = âˆ‘' (n : â„•), (finset.nat.antidiagonal n).sum (Î» (kl : â„• Ã— â„•), f kl.fst * g kl.snd)
âˆ« (y : â„) in a..b, f' y = f b - f a
s âŠ† closure (f '' (f â»Â¹' s))
add_action.stabilizer Î± (g +áµ¥ x) = add_subgroup.map (add_equiv.to_add_monoid_hom (â‡‘add_aut.conj g)) (add_action.stabilizer Î± x)
category_theory.presieve.is_sheaf_for P R â†” category_theory.presieve.is_sheaf_for P â‡‘(category_theory.sieve.generate R)
â‡‘(convex_hull R) (set.range (Î» (i j : Î¹), ite (i = j) 1 0)) = std_simplex R Î¹
finprod (Î» (a : Î±), finprod (Î» (H : a âˆˆ â‹ƒ (x : Î¹) (H : x âˆˆ I), t x), f a)) = finprod (Î» (i : Î¹), finprod (Î» (H : i âˆˆ I), finprod (Î» (j : Î±), finprod (Î» (H : j âˆˆ t i), f j))))
âˆ«â» (x : G), f (g + x) âˆ‚Î¼ = âˆ«â» (x : G), f x âˆ‚Î¼
âˆ¥f zâˆ¥ â‰¤ C
âˆƒ (t : fin n â†’ fin (fintype.card Fq ^ âŒˆ-real.log Îµ / real.log â†‘(fintype.card Fq)âŒ‰â‚Š)), âˆ€ (iâ‚€ iâ‚ : fin n), t iâ‚€ = t iâ‚ â†” â†‘(â‡‘polynomial.card_pow_degree (A iâ‚ % b - A iâ‚€ % b)) < â‡‘polynomial.card_pow_degree b â€¢ Îµ
is_closed (coe_fn '' weak_dual.polar ğ•œ s)
f (â¨† (i : Î¹), g i) = â¨† (i : Î¹), f (g i)
add_monoid.fg M â†” âˆƒ (S : set M), add_submonoid.closure S = âŠ¤ âˆ§ S.finite
âˆƒ (t : finset Î¹), s âŠ† â‹ƒ (i : Î¹) (H : i âˆˆ t), U i
s âŠ† interior (â‡‘(affine_map.homothety x t) '' s)
âˆƒ (f : bump_covering Î¹ X s), (âˆ€ (i : Î¹), p â‡‘(â‡‘f i)) âˆ§ f.is_subordinate U
(â‹‚ (n : â„•), s n).nonempty
âˆ¥x + yâˆ¥ * âˆ¥x + yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + âˆ¥yâˆ¥ * âˆ¥yâˆ¥ â†” has_inner.inner x y = 0
âˆƒ (Z : multiset (prime_spectrum A)), (M ::â‚˜ multiset.map prime_spectrum.as_ideal Z).prod â‰¤ I âˆ§ Â¬(multiset.map prime_spectrum.as_ideal Z).prod â‰¤ I
witt_vector.is_poly p (Î» (R : Type u_1) (_Rcr : comm_ring R), â‡‘witt_vector.frobenius)
affine_independent k (Î» (i : â†¥s), p â†‘i)
âˆ« (x : â„) in a..b, f' x â€¢ (g âˆ˜ f) x = âˆ« (u : â„) in f a..f b, g u
category_theory.limits.has_limits_of_shape J Cáµ’áµ–
âˆ« (x : fin (n + 1) â†’ â„) in â‡‘box_integral.box.Icc I, finset.univ.sum (Î» (i : fin (n + 1)), â‡‘(f' x) (pi.single i 1) i) = finset.univ.sum (Î» (i : fin (n + 1)), (âˆ« (x : fin n â†’ â„) in â‡‘box_integral.box.Icc (I.face i), f (i.insert_nth (I.upper i) x) i) - âˆ« (x : fin n â†’ â„) in â‡‘box_integral.box.Icc (I.face i), f (i.insert_nth (I.lower i) x) i)
add_subsemigroup.map f (add_subsemigroup.closure s) = add_subsemigroup.closure (â‡‘f '' s)
measure_theory.measure.map â‡‘f measure_theory.measure_space.volume = ennreal.of_real |(â‡‘linear_map.det f)â»Â¹| â€¢ measure_theory.measure_space.volume
has_inner.inner (â‡‘(bounded_continuous_function.to_Lp 2 Î¼ ğ•œ) f) (â‡‘(bounded_continuous_function.to_Lp 2 Î¼ ğ•œ) g) = âˆ« (x : Î±), â‡‘(star_ring_end ğ•œ) (â‡‘f x) * â‡‘g x âˆ‚Î¼
p1 -áµ¥ p2 + (p2 -áµ¥ p3) = p1 -áµ¥ p3
-(p1 -áµ¥ p2) = p2 -áµ¥ p1
is_greatest s a â†’ is_least (f '' s) (f a)
measurable (Î» (y : Î²), â‡‘Î¼ ((Î» (x : Î±), (x, y)) â»Â¹' s))
â‡‘Î¼ (f '' s) â‰¤ â†‘Îµ * â‡‘Î¼ (metric.closed_ball 0 R)
is_least t a â†’ is_greatest (f '' t) (f a)
Î¼.finite_at_filter (f âŠ“ Î¼.ae) â†’ Î¼.finite_at_filter f
finite_dimensional.finrank ğ•œ â†¥Ká—® = n
X.Ïƒ j.succ â‰« X.Î´ (â‡‘fin.cast_succ i) = X.Î´ i â‰« X.Ïƒ j
âˆ« (x : â„) in a..b, real.sin x ^ m * real.cos x ^ (2 * n + 1) = âˆ« (u : â„) in real.sin a..real.sin b, u ^ m * (1 - u ^ 2) ^ n
âˆ¥x + yâˆ¥ * âˆ¥x + yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + âˆ¥yâˆ¥ * âˆ¥yâˆ¥ â†” inner_product_geometry.angle x y = real.pi / 2
cardinal.mk Î¹ â‰¤ â†‘(fintype.card â†¥w)
category_theory.preadditive_yoneda â‹™ (category_theory.whiskering_right Cáµ’áµ– AddCommGroup (Type v)).obj (category_theory.forget AddCommGroup) = category_theory.yoneda
âˆ¥âˆ‘' (i : Î¹), f iâˆ¥â‚Š â‰¤ âˆ‘' (i : Î¹), âˆ¥f iâˆ¥â‚Š
measure_theory.integrable F' Î¼ âˆ§ has_fderiv_at (Î» (x : H), âˆ« (a : Î±), F x a âˆ‚Î¼) (âˆ« (a : Î±), F' a âˆ‚Î¼) xâ‚€
v âˆˆ (submodule.span ğ•œ {u})á—®
normalizer_condition G â†” âˆ€ (H : subgroup G), H.normalizer = H â†’ H = âŠ¤
(category_theory.category_of_elements.to_costructured_arrow F).right_op â‹™ category_theory.category_of_elements.from_costructured_arrow F = ğŸ­ F.elements
âˆƒ (g : Î± â†’ nnreal), (âˆ€ (x : Î±), 0 < g x) âˆ§ measurable g âˆ§ âˆ«â» (x : Î±), â†‘(g x) âˆ‚Î¼ < Îµ
(âˆ€ (E : A), category_theory.presieve.is_separated J (P â‹™ category_theory.coyoneda.obj (opposite.op E))) â†” âˆ€ â¦ƒX : Câ¦„ (S : category_theory.sieve X), S âˆˆ â‡‘J X â†’ âˆ€ (c : category_theory.limits.cone (S.arrows.diagram.op â‹™ P)), subsingleton (c âŸ¶ P.map_cone S.arrows.cocone.op)
(double_quot.quot_quot_mk I J).ker = I âŠ” J
âˆƒ (xâ‚€ : E), âˆ¥xâ‚€âˆ¥ â‰¤ R âˆ§ âˆ€ (y : E), y âˆˆ F â†’ 1 â‰¤ âˆ¥xâ‚€ - yâˆ¥
â‡‘(â‡‘(measure_theory.condexp_L2 ğ•œ hm) (measure_theory.mem_â„’p.to_Lp (Î» (a : Î±), has_inner.inner c (â‡‘f a)) _)) =áµ[Î¼] Î» (a : Î±), has_inner.inner c (â‡‘(â‡‘(measure_theory.condexp_L2 ğ•œ hm) f) a)
âˆ¥â‡‘f mâ‚ - â‡‘f mâ‚‚âˆ¥ â‰¤ C * â†‘(fintype.card Î¹) * linear_order.max âˆ¥mâ‚âˆ¥ âˆ¥mâ‚‚âˆ¥ ^ (fintype.card Î¹ - 1) * âˆ¥mâ‚ - mâ‚‚âˆ¥
vector.scanl f b (x::áµ¥v) = b::áµ¥vector.scanl f (f b x) v
f =áµ[Î¼] function.const Î± (â¨ (x : Î±), f x âˆ‚Î¼) âˆ¨ âˆƒ (t : set Î±), measurable_set t âˆ§ â‡‘Î¼ t â‰  0 âˆ§ â‡‘Î¼ tá¶œ â‰  0 âˆ§ â¨ (x : Î±) in t, f x âˆ‚Î¼ â‰  â¨ (x : Î±) in tá¶œ, f x âˆ‚Î¼
(âˆ€ (g : G) (A : set G), measurable_set A â†’ â‡‘Î¼ ((Î» (h : G), h * g) â»Â¹' A) = â‡‘Î¼ A) â†” Î¼.is_mul_right_invariant
function.injective â‡‘f â†” âˆ€ (a : G), â‡‘f a = 0 â†’ a = 0
x +áµ¥ r â€¢ metric.ball 0 1 = metric.ball x r
filter.Coprod (Î» (d : Î´), filter.cocompact (Îº d)) = filter.cocompact (Î  (d : Î´), Îº d)
collinear k s â†” âˆƒ (pâ‚€ : P) (v : V), âˆ€ (p : P), p âˆˆ s â†’ (âˆƒ (r : k), p = r â€¢ v +áµ¥ pâ‚€)
add_con_gen â‡‘(add_con_gen r) = add_con_gen r
strict_convex ğ•œ (â‡‘f '' s)
âˆ¥g + hâˆ¥ â‰¤ âˆ¥gâˆ¥ + âˆ¥hâˆ¥
âˆ«â» (a : Î±), (â¨† (b : Î²), f b a) âˆ‚Î¼ = â¨† (b : Î²), âˆ«â» (a : Î±), f b a âˆ‚Î¼
monoid.is_torsion_free (Î  (i : Î·), Gs i)
âˆ¥q.comp_along_composition p câˆ¥ â‰¤ âˆ¥q c.lengthâˆ¥ * finset.univ.prod (Î» (i : fin c.length), âˆ¥p (c.blocks_fun i)âˆ¥)
has_dist.dist (r â€¢ v +áµ¥ pâ‚) pâ‚‚ = has_dist.dist pâ‚ pâ‚‚ â†” r = 0 âˆ¨ r = (-2) * has_inner.inner v (pâ‚ -áµ¥ pâ‚‚) / has_inner.inner v v
u =O[l] v â†’ (âˆƒ (Ï† : Î± â†’ ğ•œ) (hÏ† : filter.is_bounded_under has_le.le l (has_norm.norm âˆ˜ Ï†)), u =á¶ [l] Ï† * v)
âˆ«â» (x : Î±) in s, â†‘âˆ¥g xâˆ¥â‚Š âˆ‚Î¼ â‰¤ âˆ«â» (x : Î±) in s, â†‘âˆ¥f xâˆ¥â‚Š âˆ‚Î¼
â‡‘m (â‹ƒ (n : â„•), s n) = â¨† (n : â„•), â‡‘m (s n)
âˆ¥w - vâˆ¥ = âˆ¥w + vâˆ¥
(â¨† (hâ‚ : p) (hâ‚‚ : q), s hâ‚ hâ‚‚) = â¨† (h : p âˆ§ q), s _ _
âˆ« (y : â„) in a..b, deriv f y = f b - f a
âˆƒ (g : Î± â†’ ennreal), (âˆ€ (x : Î±), â†‘(f x) < g x) âˆ§ lower_semicontinuous g âˆ§ âˆ«â» (x : Î±), g x âˆ‚Î¼ â‰¤ âˆ«â» (x : Î±), â†‘(f x) âˆ‚Î¼ + Îµ
âˆ¥f y - f xâˆ¥ â‰¤ C * âˆ¥y - xâˆ¥
(Î» (t : Î¹), ((âˆ« (x : â„) in va t..vb t, f x) - âˆ« (x : â„) in ua t..ub t, f x) - ((vb t - ub t) â€¢ cb - (va t - ua t) â€¢ ca)) =o[lt] Î» (t : Î¹), âˆ¥va t - ua tâˆ¥ + âˆ¥vb t - ub tâˆ¥
filter.tendsto F p (nhds f) â†” âˆ€ (K : set Î±), is_compact K â†’ tendsto_uniformly_on (Î» (i : Î¹) (a : Î±), â‡‘(F i) a) â‡‘f p K
(((âˆ« (x : â„) in z.re..w.re, f (â†‘x + â†‘(z.im) * complex.I)) - âˆ« (x : â„) in z.re..w.re, f (â†‘x + â†‘(w.im) * complex.I)) + complex.I â€¢ âˆ« (y : â„) in z.im..w.im, f (â†‘(w.re) + â†‘y * complex.I)) - complex.I â€¢ âˆ« (y : â„) in z.im..w.im, f (â†‘(z.re) + â†‘y * complex.I) = 0
category_theory.presieve.is_sheaf âŠ¥ P
â‡‘(has_Inf.Inf m) s = â¨… (t : â„• â†’ set Î±) (h2 : s âŠ† set.Union t), âˆ‘' (n : â„•), â¨… (Î¼ : measure_theory.outer_measure Î±) (h3 : Î¼ âˆˆ m), â‡‘Î¼ (t n)
âˆƒ (S : C) (T : Î  {X : C}, X âˆˆ O â†’ (X âŸ¶ S)), âˆ€ {X Y : C} (mX : X âˆˆ O) (mY : Y âˆˆ O) {f : X âŸ¶ Y}, âŸ¨X, âŸ¨Y, âŸ¨mX, âŸ¨mY, fâŸ©âŸ©âŸ©âŸ© âˆˆ H â†’ f â‰« T mY = T mX
sá¶œ âˆˆ filter.hyperfilter Î±
f.ker = âŠ¥
âˆƒ (is : finset Î¹) {n : set X} (hnâ‚ : n âˆˆ nhds x) (hnâ‚‚ : n âŠ† â‹‚ (i : Î¹) (H : i âˆˆ is), U i), âˆ€ (z : X), z âˆˆ n â†’ function.support (Î» (i : Î¹), f i z) âŠ† â†‘is
is_bot a â†’ a = âŠ¥
nonempty â†¥(set.Ico x (x + dx)  set.Ico y (y + dy))
(finset.univ.pi t).sum (Î» (x : Î  (a : Î±), a âˆˆ finset.univ â†’ Î´ a), f x) = (fintype.pi_finset t).sum (Î» (x : Î  (a : Î±), Î´ a), f (Î» (a : Î±) (_x : a âˆˆ finset.univ), x a))
filter.map (prod.map (Î» (_x : Î±), b) id) ((filter.principal {a}).coprod (filter.principal {i})) = filter.principal ({b} Ã—Ë¢ set.univ)
(Î» (n : â„•), (âˆ« (a : Î©), (finset.range n).sum (Î» (i : â„•), probability_theory.truncation (X i) â†‘i) a) - â†‘n * âˆ« (a : Î©), X 0 a) =o[filter.at_top] coe
âˆ¥S.normed_mkâˆ¥ â‰¤ 1
âˆ«â» (a : Î±), (f * g) a âˆ‚Î¼ â‰¤ (âˆ«â» (a : Î±), f a ^ p âˆ‚Î¼) ^ (1 / p) * (âˆ«â» (a : Î±), g a ^ q âˆ‚Î¼) ^ (1 / q)
category_theory.limits.has_limits Cáµ’áµ–
s.monge_point -áµ¥ finset.centroid â„ {iâ‚, iâ‚‚}á¶œ s.points = â‡‘(finset.univ.weighted_vsub s.points_with_circumcenter) (affine.simplex.monge_point_vsub_face_centroid_weights_with_circumcenter iâ‚ iâ‚‚)
c âŠ” d = con_gen (Î» (x y : M), â‡‘c x y âˆ¨ â‡‘d x y)
nonempty (V â‰ƒâ‚—[K] Vâ‚‚)
spectrum ğ•œ (â‡‘(polynomial.aeval a) p) = (Î» (k : ğ•œ), polynomial.eval k p) '' spectrum ğ•œ a
is_greatest t a â†’ is_least (f '' t) (f a)
âˆ¥fâˆ¥â‚Š â‰¤ C â†” âˆ€ (x : Î±), âˆ¥â‡‘f xâˆ¥â‚Š â‰¤ C
(Î» (t : Î¹), âˆ« (x : â„) in u t..v t, f x âˆ‚Î¼ + (â‡‘Î¼ (set.Ioc (v t) (u t))).to_real â€¢ c) =o[lt] Î» (t : Î¹), (â‡‘Î¼ (set.Ioc (v t) (u t))).to_real
âˆ¥â‡‘(quotient_add_group.mk' S) mâˆ¥ = has_Inf.Inf ((Î» (x : M), âˆ¥m + xâˆ¥) '' â†‘S)
measure_theory.integrable_at_filter f (l âŠ“ Î¼.ae) Î¼ â†’ measure_theory.integrable_at_filter f l Î¼
â‡‘Î¼ K < âŠ¤
has_dist.dist (â‡‘f x) (â‡‘f y) â‰¤ 2 * âˆ¥fâˆ¥
measure_theory.strongly_measurable (Î» (x : Î±), âˆ« (y : Î²), f (x, y) âˆ‚Î½)
(sâ‚ âŠ“ sâ‚‚).direction = sâ‚.direction âŠ“ sâ‚‚.direction
â†‘(s.direction) = â†‘s -áµ¥ â†‘s
(â¨† (i : Î¹), Î¼ i).trim = â¨† (i : Î¹), (Î¼ i).trim
âˆƒ (V : open_subgroup G) (W : open_subgroup K), â†‘V Ã—Ë¢ â†‘W âŠ† U
filter.at_top.limsup (Î» (n : â„•), â†‘âˆ¥a ^ nâˆ¥â‚Š ^ (1 / â†‘n)) â‰¤ spectral_radius â„‚ a
âŠ¥.is_clique s â†’ s.subsingleton
algebra.finite_type R A â†” âˆƒ (n : â„•) (f : mv_polynomial (fin n) R â†’â‚[R] A), function.surjective â‡‘f
â‡‘Î¼ (f '' s) = 0
âˆ« (x : Î±), f x âˆ‚Î¼ âˆˆ s
(finsupp.map_domain f s).sum (Î» (b : Î²) (m : M), â‡‘(h b) m) = s.sum (Î» (a : Î±) (m : M), â‡‘(h (f a)) m)
metric.cthickening Î´ E = â‹ƒ (x : Î±) (H : x âˆˆ E), metric.closed_ball x Î´
category_theory.limits.kernel_subobject (f â‰« h) = category_theory.limits.kernel_subobject f
e.is_image s t â†’ e.source âˆ© â‡‘e â»Â¹' t = e.source âˆ© s
âˆƒ (C : â„), âˆ€ (z : E), âˆ¥â‡‘f zâˆ¥ â‰¤ C * âˆ¥zâˆ¥
H = âŠ¥ âˆ¨ nontrivial â†¥H
âˆƒ (l : list F), l.length â‰¤ n âˆ§ Ï† = (list.map (Î» (v : F), reflection (submodule.span â„ {v})á—®) l).prod
finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ g '' s), f i)) = finprod (Î» (j : Î²), finprod (Î» (H : j âˆˆ s), f (g j)))
dimH (f '' s) â‰¤ dimH s
module.rank Î± â†¥(E.sol_space) = â†‘(E.order)
vector_span k s = submodule.span k (has_vsub.vsub p '' (s  {p}))
has_strict_deriv_at (Î» (u : â„), âˆ« (x : â„) in u..b, f x) (-f a) a
âˆƒ (Î± : Type v) (c : Î± â†’ X) (r : Î  (a : Î±), Î¹ (c a)), (âˆ€ (a : Î±), p (c a) (r a)) âˆ§ (â‹ƒ (a : Î±), B (c a) (r a)) = set.univ âˆ§ locally_finite (Î» (a : Î±), B (c a) (r a))
measurable_set (f '' s)
(((âˆ« (x : â„) in z.re..w.re, f (â†‘x + â†‘(z.im) * complex.I)) - âˆ« (x : â„) in z.re..w.re, f (â†‘x + â†‘(w.im) * complex.I)) + complex.I â€¢ âˆ« (y : â„) in z.im..w.im, f (â†‘(w.re) + â†‘y * complex.I)) - complex.I â€¢ âˆ« (y : â„) in z.im..w.im, f (â†‘(z.re) + â†‘y * complex.I) = âˆ« (x : â„) in z.re..w.re, âˆ« (y : â„) in z.im..w.im, complex.I â€¢ â‡‘(f' (â†‘x + â†‘y * complex.I)) 1 - â‡‘(f' (â†‘x + â†‘y * complex.I)) complex.I
function.injective â‡‘(I.quotient_map f H)
âˆ¥fâˆ¥â‚Š â‰¤ M
(âˆ€ (a : â†¥P), â‡‘f a = 0) â†’ f = 0
uniformity Î± = â¨† (x : Î±), nhds (x, x)
direct_sum.is_internal V â†” (supr V)á—® = âŠ¥
âˆ« (x : â„) in a..b, real.cos x ^ (n + 2) = (real.cos b ^ (n + 1) * real.sin b - real.cos a ^ (n + 1) * real.sin a) / (â†‘n + 2) + (â†‘n + 1) / (â†‘n + 2) * âˆ« (x : â„) in a..b, real.cos x ^ n
(Î½.with_density f).rn_deriv Î½ =áµ[Î½] f
v +áµ¥ p âˆˆ s
âˆƒ (u : â„¤Ë£) (n : â„•), algebra.discr K â‡‘((is_primitive_root.power_basis K hÎ¶).basis) = â†‘u * â†‘p ^ n
finset.univ.prod (Î» (a : Î±), (t a).sum (Î» (b : Î´ a), f a b)) = (fintype.pi_finset t).sum (Î» (p : Î  (a : Î±), Î´ a), finset.univ.prod (Î» (x : Î±), f x (p x)))
function.surjective â‡‘f
measure_theory.integrable f (Î¼.prod Î½) â†” (âˆ€áµ (x : Î±) âˆ‚Î¼, measure_theory.integrable (Î» (y : Î²), f (x, y)) Î½) âˆ§ measure_theory.integrable (Î» (x : Î±), âˆ« (y : Î²), âˆ¥f (x, y)âˆ¥ âˆ‚Î½) Î¼
is_compact s â†” is_compact (f '' s)
(âˆ¥u - vâˆ¥ = â¨… (w : â†¥K), âˆ¥u - â†‘wâˆ¥) â†” âˆ€ (w : F), w âˆˆ K â†’ has_inner.inner (u - v) (w - v) â‰¤ 0
âˆ«â» (x : E) in s, ennreal.of_real |(f' x).det| âˆ‚Î¼ = â‡‘Î¼ (f '' s)
âˆƒ (g : Î± â†’ ennreal), (âˆ€ (x : Î±), f x â‰¤ g x) âˆ§ lower_semicontinuous g âˆ§ âˆ«â» (x : Î±), g x âˆ‚Î¼ â‰¤ âˆ«â» (x : Î±), f x âˆ‚Î¼ + Îµ
âŠ¥ = âŠ¤
filter.tendsto (Î» (n : Î¹), âˆ«â» (a : Î±), F n a âˆ‚Î¼) l (nhds (âˆ«â» (a : Î±), f a âˆ‚Î¼))
âˆƒ (y : E) (H : y âˆˆ frontier s), metric.inf_dist x sá¶œ = has_dist.dist x y
category_theory.presheaf.fork_map R F â‰« (Top.presheaf.covering_of_presieve.first_obj_iso_pi_opens F U R).hom = F.map (category_theory.eq_to_hom _).op â‰« Top.presheaf.sheaf_condition_equalizer_products.res F (Top.presheaf.covering_of_presieve U R)
euclidean_geometry.orthogonal_projection_fn s p âˆˆ affine_subspace.mk' p (s.direction)á—®
âˆ¥x - yâˆ¥ * âˆ¥x - yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + âˆ¥yâˆ¥ * âˆ¥yâˆ¥ - 2 * âˆ¥xâˆ¥ * âˆ¥yâˆ¥ * real.cos (inner_product_geometry.angle x y)
cardinal.mk â†¥(set.Ioi a) = cardinal.continuum
â‡‘(orthogonal_projection Ká—®) v = 0
âˆ«â» (a : Î±), f a + g a âˆ‚Î¼ = âˆ«â» (a : Î±), f a âˆ‚Î¼ + âˆ«â» (a : Î±), g a âˆ‚Î¼
is_mul_hom â‡‘h
Î¼.inner_regular is_compact (Î» (s : set Î±), measurable_set s âˆ§ â‡‘Î¼ s â‰  âŠ¤)
â‡‘((hV.linear_isometry_equiv hV').symm) w = âˆ‘' (i : Î¹), â‡‘(V i) (â‡‘w i)
âˆƒ (p : polynomial â„), âˆ¥p.to_continuous_map_on (set.Icc a b) - fâˆ¥ < Îµ
measurable (Î» (x : Î±), â‡‘Î½ (prod.mk x â»Â¹' s))
fintype.card â†¥(H.normalizer) â‰¡ fintype.card G [MOD p ^ (n + 1)]
âˆƒ (f : â„• â†’ E), (âˆ€ (n : â„•), âˆ¥f nâˆ¥ â‰¤ R) âˆ§ âˆ€ (m n : â„•), m â‰  n â†’ 1 â‰¤ âˆ¥f m - f nâˆ¥
bdd_below s â†’ bdd_below t â†’ (s âˆ© t).nonempty â†’ has_Inf.Inf s âŠ” has_Inf.Inf t â‰¤ has_Inf.Inf (s âˆ© t)
â‡‘((p.bind_on_support f).to_measure) s = âˆ‘' (a : Î±), â†‘(â‡‘p a) * dite (â‡‘p a = 0) (Î» (h : â‡‘p a = 0), 0) (Î» (h : Â¬â‡‘p a = 0), â‡‘((f a h).to_measure) s)
dense (â‹‚â‚€ S)
set.eq_on (has_norm.norm âˆ˜ f) (function.const E âˆ¥f zâˆ¥) (metric.closed_ball z r)
set.eq_on â‡‘f' â‡‘fâ‚' (tangent_cone_at ğ•œ s x)
fintype.card â†¥(add_action.orbit Î± b) * fintype.card â†¥(add_action.stabilizer Î± b) = fintype.card Î±
âˆ«â» (z : Î± Ã— Î²), f z âˆ‚Î¼.prod Î½ = âˆ«â» (x : Î±), âˆ«â» (y : Î²), f (x, y) âˆ‚Î½ âˆ‚Î¼
âˆ« (x : G), f x âˆ‚Î¼ = 0
|a * b| â‰¤ |a| * |b|
has_Sup.Sup S = add_con_gen (Î» (x y : M), âˆƒ (c : add_con M), c âˆˆ S âˆ§ â‡‘c x y)
âˆƒ (g : bounded_continuous_function Y â„), âˆ¥gâˆ¥ = âˆ¥fâˆ¥ âˆ§ â‡‘g âˆ˜ e = â‡‘f
p âˆˆ affine_span k (has_insert.insert p2 â†‘s) â†” âˆƒ (r : k) (p0 : P) (hp0 : p0 âˆˆ s), p = r â€¢ (p2 -áµ¥ p1) +áµ¥ p0
galois_connection (Î» (s : set A), projective_spectrum.zero_locus ğ’œ s) (Î» (t : (set (projective_spectrum ğ’œ))áµ’áµˆ), â†‘(projective_spectrum.vanishing_ideal t))
A.det = finset.univ.sum (Î» (i : fin n.succ), (-1) ^ â†‘i * A i 0 * (A.minor â‡‘(i.succ_above) fin.succ).det)
âˆ® (z : â„‚) in C(c, R), (z - w)â»Â¹ â€¢ f z = (2 * â†‘real.pi * complex.I) â€¢ f w
galois_connection (â‡‘order_dual.to_dual âˆ˜ fixing_submonoid M) ((Î» (P : submonoid M), mul_action.fixed_points â†¥P Î±) âˆ˜ â‡‘order_dual.of_dual)
is_preconnected (f '' s)
â‡‘(measure_theory.measure.map â‡‘f Î¼) s = â‡‘Î¼ (â‡‘f â»Â¹' s)
has_fderiv_at (Î» (x : H), âˆ« (t : â„) in a..b, F x t âˆ‚Î¼) (âˆ« (t : â„) in a..b, F' xâ‚€ t âˆ‚Î¼) xâ‚€
has_Sup.Sup (s âˆ© t) â‰¤ has_Sup.Sup s âŠ“ has_Sup.Sup t
(f'.prod Ï†').range â‰  âŠ¤
algebra.discr K â‡‘((is_primitive_root.power_basis K hÎ¶).basis) = (-1) ^ ((â†‘p ^ (k + 1)).totient / 2) * â†‘p ^ (â†‘p ^ k * ((â†‘p - 1) * (k + 1) - 1))
âˆ€á¶  (t : set (Î± Ã— Î±)) in (uniformity Î±).small_sets, comp_rel t t âŠ† s
âˆ€áµ (x : Î±) âˆ‚Î¼, P x
module.rank R (Î¹ â†’â‚€ R) = (cardinal.mk Î¹).lift
has_fpower_series_on_ball (Î» (w : â„‚), (2 * â†‘real.pi * complex.I)â»Â¹ â€¢ âˆ® (z : â„‚) in C(c, â†‘R), (z - w)â»Â¹ â€¢ f z) (cauchy_power_series f c â†‘R) c â†‘R
category_theory.limits.colimit.Î¹ F j â‰« category_theory.limits.colimit.desc F c = c.Î¹.app j
(measure_theory.measure.map â‡‘(quotient_group.mk' Î“) (Î¼.restrict ğ“•)).is_mul_left_invariant
âˆ« (x : Î±) in s, â‡‘(â‡‘(measure_theory.condexp_L1_clm hm Î¼) f) x âˆ‚Î¼ = âˆ« (x : Î±) in s, â‡‘f x âˆ‚Î¼
p.radius = filter.at_top.liminf (Î» (n : â„•), 1 / â†‘(âˆ¥p nâˆ¥â‚Š ^ (1 / â†‘n)))
â‡‘Î¼ E * âˆ«â» (y : G), f y âˆ‚Î½ = âˆ«â» (x : G), â‡‘Î½ ((Î» (z : G), z * x) â»Â¹' E) * f xâ»Â¹ âˆ‚Î¼
âˆ¥xâˆ¥ < r â†” âˆ€ (i : Î¹), âˆ¥x iâˆ¥ < r
supr A = âŠ¤
f.prod (Î» (x : Î±) (v : M), ite (x = a) (b x v) 1) = ite (a âˆˆ f.support) (b a (â‡‘f a)) 1
subgroup.normal_closure {âŸ¨equiv.swap 0 4 * equiv.swap 1 3, _âŸ©} = âŠ¤
âˆ« (x : F) in set.Icc a b, DF x = finset.univ.sum (Î» (i : fin (n + 1)), (âˆ« (x : fin n â†’ â„) in set.Icc (â‡‘eL a âˆ˜ â‡‘(i.succ_above)) (â‡‘eL b âˆ˜ â‡‘(i.succ_above)), f i (â‡‘(eL.symm) (i.insert_nth (â‡‘eL b i) x))) - âˆ« (x : fin n â†’ â„) in set.Icc (â‡‘eL a âˆ˜ â‡‘(i.succ_above)) (â‡‘eL b âˆ˜ â‡‘(i.succ_above)), f i (â‡‘(eL.symm) (i.insert_nth (â‡‘eL a i) x)))
âˆ« (x : â„) in a..b, real.sin x ^ (2 * m) * real.cos x ^ (2 * n) = âˆ« (x : â„) in a..b, ((1 - real.cos (2 * x)) / 2) ^ m * ((1 + real.cos (2 * x)) / 2) ^ n
lie_algebra.is_solvable R â†¥I â†” I â‰¤ lie_algebra.radical R L
â‡‘f (Î» (i : Î¹), finset.univ.sum (Î» (j : Î± i), g i j)) = finset.univ.sum (Î» (r : Î  (i : Î¹), Î± i), â‡‘f (Î» (i : Î¹), g i (r i)))
Ï† = Ïˆ â†” âˆ€ (n : Ïƒ â†’â‚€ â„•), â‡‘(mv_power_series.coeff R n) Ï† = â‡‘(mv_power_series.coeff R n) Ïˆ
âˆ‘' (i : Î¹), âˆ¥has_inner.inner (v i) xâˆ¥ ^ 2 â‰¤ âˆ¥xâˆ¥ ^ 2
(â‹‚ (l : E â†’L[â„] â„), {x : E | âˆƒ (y : E) (H : y âˆˆ s), â‡‘l x â‰¤ â‡‘l y}) = s
strict_convex_on ğ•œ ((Î» (z : E), c + z) â»Â¹' s) (f âˆ˜ Î» (z : E), z + c)
âˆƒ (j : J) (g : locally_constant â†¥(F.obj j) Î±), f = locally_constant.comap â‡‘(C.Ï€.app j) g
filter.tendsto (Î» (t : â„), âˆ« (x : â„) in 0..t, g x) filter.at_bot filter.at_bot
âˆ¥x + yâˆ¥ * âˆ¥x + yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + âˆ¥yâˆ¥ * âˆ¥yâˆ¥
lipschitz_with âˆ¥xâˆ¥â‚Š (Î» (f : E â†’SL[Ïƒâ‚â‚‚] F), â‡‘f x)
module.rank K â†¥s â‰¤ 1 â†” âˆƒ (vâ‚€ : V), s â‰¤ submodule.span K {vâ‚€}
â‡‘clifford_algebra.reverse (list.map â‡‘(clifford_algebra.Î¹ Q) l).prod = (list.map â‡‘(clifford_algebra.Î¹ Q) l).reverse.prod
â†‘(â‡‘(euclidean_geometry.orthogonal_projection s) p2 -áµ¥ âŸ¨p1, hp1âŸ©) âˆˆ s.direction
âˆ¥x - yâˆ¥ * âˆ¥x - yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + âˆ¥yâˆ¥ * âˆ¥yâˆ¥
continuous_at â‡‘(e.symm) x
category_theory.mono f â†” function.injective â‡‘(simplex_category.hom.to_order_hom f)
â‡‘s (i âˆ† j) = 0 âˆ§ â‡‘s (iá¶œ âˆ† já¶œ) = 0
cont_diff_on ğ•œ âŠ¤ fâ‚‚ sâ‚‚ â†” differentiable_on ğ•œ fâ‚‚ sâ‚‚ âˆ§ cont_diff_on ğ•œ âŠ¤ (deriv_within fâ‚‚ sâ‚‚) sâ‚‚
finite_dimensional.finrank ğ•œ (X âŸ¶ X) = 1
(Î» (N : â„•), â†‘(â‡‘roth_number_nat N)) =O[filter.at_top] Î» (N : â„•), â†‘N
has_deriv_within_at (Î» (u : â„), âˆ« (x : â„) in a..u, f x) c s b
module.rank R â†¥(submodule.map â†‘f p) = module.rank R â†¥p
âˆƒ (t : finset G), K âŠ† â‹ƒ (g : G) (H : g âˆˆ t), (Î» (h : G), g * h) â»Â¹' V
â‡‘(measure_theory.measure.mk_metric m) s â‰¤ l.liminf (Î» (n : Î²), âˆ‘' (i : Î¹ n), m (emetric.diam (t n i)))
module.End.has_eigenvector â†‘T (â†‘â¨† (x : {x // x â‰  0}), (Î» (x : E), T.re_apply_inner_self x / âˆ¥xâˆ¥ ^ 2) â†‘x) xâ‚€
bdd_above (f '' K)
X âˆˆ continuous_map.compact_convergence_uniformity â†” âˆƒ (K : set Î±) (V : set (Î² Ã— Î²)) (hK : is_compact K) (hV : V âˆˆ uniformity Î²), {fg : C(Î±, Î²) Ã— C(Î±, Î²) | âˆ€ (x : Î±), x âˆˆ K â†’ (â‡‘(fg.fst) x, â‡‘(fg.snd) x) âˆˆ V} âŠ† X
Kâ‚á—®á—® â‰¤ Kâ‚‚á—®á—®
fintype.card (sylow p G) â‰¡ 1 [MOD p]
(sâ‚ âŠ“ sâ‚‚).direction = sâ‚.direction âŠ“ sâ‚‚.direction
âˆƒ (s : C) (Î± : kâ‚ âŸ¶ s) (Î² : kâ‚‚ âŸ¶ s), fâ‚ â‰« Î± = gâ‚ â‰« Î² âˆ§ fâ‚‚ â‰« Î± = gâ‚‚ â‰« Î²
ğŸ­ â†¥C = ğŸ™ C
S = âŠ¥ âˆ¨ âˆƒ (x : M) (H : x âˆˆ S), x â‰  1
âˆ« (x : Î±) in s, â‡‘(measure_theory.condexp_L1 hm Î¼ f) x âˆ‚Î¼ = âˆ« (x : Î±) in s, f x âˆ‚Î¼
(Î» (x : â„), real.exp (-x) * x ^ s) =o[filter.at_top] Î» (x : â„), real.exp (-(1 / 2) * x)
Gá¶œ.is_SRG_with n (n - k - 1) (n - (2 * k - Î¼) - 2) (n - (2 * k - â„“))
âˆƒ (f_lim : Î± â†’ Î²) (hf_lim_meas : measure_theory.strongly_measurable f_lim), âˆ€áµ (x : Î±) âˆ‚Î¼, filter.tendsto (Î» (n : â„•), f n x) filter.at_top (nhds (f_lim x))
âˆ¥f y - f xâˆ¥ â‰¤ C * âˆ¥y - xâˆ¥
âˆƒ (v : Î¹ â†’ set X), (âˆ€ (a : Î¹), is_open (v a)) âˆ§ (â‹ƒ (i : Î¹), v i) = set.univ âˆ§ locally_finite v âˆ§ âˆ€ (a : Î¹), v a âŠ† u a
has_Inf.Inf s âŠ” a â‰¤ â¨… (b : Î±) (H : b âˆˆ s), b âŠ” a
âˆ¥continuous_linear_map.id ğ•œ Eâˆ¥ = 1
open_embedding â‡‘(category_theory.limits.pullback.map fâ‚ fâ‚‚ gâ‚ gâ‚‚ iâ‚ iâ‚‚ iâ‚ƒ eqâ‚ eqâ‚‚)
(âˆ€á¶  (x : Î±) in l, âˆ¥f xâˆ¥ â‰¤ c * âˆ¥g xâˆ¥) â†’ asymptotics.is_O_with c l f g
âˆ¥f zâˆ¥ â‰¤ C
filter.tendsto â†¿F (p.prod âŠ¤) (nhds c) â†” tendsto_uniformly F (Î» (_x : Î±), c) p
âˆƒ (V' : set (Î² Ã— Î²)) (H : V' âˆˆ uniformity Î²), V' âŠ† V âˆ§ âˆ€ (g : C(Î±, Î²)), g âˆˆ continuous_map.compact_conv_nhd K V' f â†’ continuous_map.compact_conv_nhd K V' g âŠ† continuous_map.compact_conv_nhd K V f
function.right_inverse â‡‘(mv_polynomial.map f) â‡‘(mv_polynomial.map g)
strict_convex ğ•œ ((Î» (x : E), z + x) â»Â¹' s)
algebra.finite_presentation R A â†” âˆƒ (Î¹ : Type u_2) (_x : fintype Î¹) (f : mv_polynomial Î¹ R â†’â‚[R] A), function.surjective â‡‘f âˆ§ f.to_ring_hom.ker.fg
x âˆˆ supr S â†” âˆƒ (f : Î â‚€ (i : Î¹), â†¥(S i)), f.sum (Î» (i : Î¹) (xi : â†¥(S i)), â†‘xi) = x
dense (set.range f)á¶œ
same_ray â„ x y â†’ âˆ¥xâˆ¥â»Â¹ â€¢ x = âˆ¥yâˆ¥â»Â¹ â€¢ y
p âˆ‰ âŠ¥
z = w + â†‘-â‡‘(is_add_unit.lift_right (f.restrict S) h) y â†” z + â‡‘f â†‘y = w
K âŠ“ Ká—® = âŠ¥
f =áµ[Î¼] s.rn_deriv Î¼
interval_integrable F' Î¼ a b âˆ§ has_fderiv_at (Î» (x : H), âˆ« (t : â„) in a..b, F x t âˆ‚Î¼) (âˆ« (t : â„) in a..b, F' t âˆ‚Î¼) xâ‚€
s.sum (Î» (a : Î±), f a) < âŠ¤ â†” âˆ€ (a : Î±), a âˆˆ s â†’ f a < âŠ¤
submodule.torsion R â†¥(submodule.torsion R M) = âŠ¤
has_deriv_at (Î» (u : â„), âˆ« (x : â„) in a..u, f x) c b
âˆƒ (eq_1 : opposite.op U = opposite.op ((topological_space.opens.map (category_theory.limits.colimit.Î¹ D.to_glue_data.diagram.multispan (opposite.unop (opposite.op (category_theory.limits.walking_multispan.right i)))).base).obj (_.functor.obj U))), D.Î¹_inv_app U â‰« D.diagram_over_open_Ï€ U i = (D.to_glue_data.U i).presheaf.map (category_theory.eq_to_hom eq_1)
finite_dimensional.finrank ğ•œ (X âŸ¶ Y) â‰¤ 1
â‡‘(measure_theory.measure.hausdorff_measure dâ‚‚) s = 0 âˆ¨ â‡‘(measure_theory.measure.hausdorff_measure dâ‚) s = âŠ¤
has_inner.inner x (r â€¢ x) / (âˆ¥xâˆ¥ * âˆ¥r â€¢ xâˆ¥) = 1
0 < âˆ« (x : â„) in a..b, f x âˆ‚Î¼ â†” a < b âˆ§ 0 < â‡‘Î¼ (function.support f âˆ© set.Ioc a b)
k â‰« s.Ï€.app j = l â‰« s.Ï€.app j
s.sum (Î» (i : Î¹), w i â€¢ (pâ‚ -áµ¥ pâ‚‚ i)) = pâ‚ -áµ¥ â‡‘(s.affine_combination pâ‚‚) w
fintype.card Î¹ â‰¤ fintype.card â†¥w
s.pairwise (Î» (x y : Î±), f x = f y) â†” âˆƒ (z : Î¹), âˆ€ (x : Î±), x âˆˆ s â†’ f x = z
S = âŠ¤
category_theory.presieve.is_sheaf_for P â‡‘âŠ¤
lâ‚ <+~ lâ‚‚ â†’ a :: lâ‚ <+~ a :: lâ‚‚
âˆƒ (g : E â†’L[ğ•œ] ğ•œ), âˆ¥gâˆ¥ = 1 âˆ§ â‡‘g x = â†‘âˆ¥xâˆ¥
category_theory.is_cofiltered.eq_hom f f' â‰« f = category_theory.is_cofiltered.eq_hom f f' â‰« f'
function.injective â‡‘(ideal.ker_lift_alg f)
first_order.language.Structure.fg L M â†” âˆƒ (S : set M), S.finite âˆ§ â‡‘(first_order.language.substructure.closure L) S = âŠ¤
has_inner.inner x y = â†‘âˆ¥xâˆ¥ * â†‘âˆ¥yâˆ¥ â†” â†‘âˆ¥yâˆ¥ â€¢ x = â†‘âˆ¥xâˆ¥ â€¢ y
âˆƒ (c : â†¥S), x + â†‘((f.sec (f.mk' x y)).snd) + â†‘c = (f.sec (f.mk' x y)).fst + â†‘y + â†‘c
inducing (Î» (x : X) (i : Î¹), f i x)
isometry â‡‘f â†” âˆ€ (x : E), âˆ¥â‡‘f xâˆ¥ = âˆ¥xâˆ¥
âˆ¥f zâˆ¥ â‰¤ C
algebra.finite_type R A â†” âˆƒ (Î¹ : Type u_2) (_x : fintype Î¹) (f : mv_polynomial Î¹ R â†’â‚[R] A), function.surjective â‡‘f
is_compact (f â»Â¹' K)
âˆƒá¶  (n : â„•) in filter.at_top, âˆ€ (k : â„•), k < n â†’ u n < u k
âˆƒ (g : bounded_continuous_function Y â„), âˆ¥gâˆ¥ = âˆ¥fâˆ¥ âˆ§ g.comp_continuous e = f
setoid.r = setoid.r âŠ“ setoid.r
is_noetherian R â†¥(submodule.span R A)
has_Inf.Inf (coe '' t) âˆˆ s
ennreal.of_real (â‡‘f b - â‡‘f a) â‰¤ âˆ‘' (i : â„•), ennreal.of_real (â‡‘f (d i) - â‡‘f (c i))
is_irreducible s â†” âˆ€ (U : finset (set Î±)), (âˆ€ (u : set Î±), u âˆˆ U â†’ is_open u) â†’ (âˆ€ (u : set Î±), u âˆˆ U â†’ (s âˆ© u).nonempty) â†’ (s âˆ© â‹‚â‚€ â†‘U).nonempty
âˆƒ (g : C(Y, â„)), continuous_map.restrict s g = f
âˆ« (x : â„) in a..b, real.sin x * real.cos x = (real.cos a ^ 2 - real.cos b ^ 2) / 2
has_strict_deriv_at â‡‘(f.symm) f'â»Â¹ a
continuous â‡‘(e.symm)
âˆ¥f 1 - f 0âˆ¥ â‰¤ C
âˆ¥f.to_continuous_linear_map.comp gâˆ¥ = âˆ¥gâˆ¥
â‡‘(measure_theory.measure.mk_metric m) s = â¨† (r : ennreal) (hr : 0 < r), â¨… (t : â„• â†’ set X) (h : s âŠ† set.Union t) (h' : âˆ€ (n : â„•), emetric.diam (t n) â‰¤ r), âˆ‘' (n : â„•), â¨† (h : (t n).nonempty), m (emetric.diam (t n))
comm_monoid.torsion G = âŠ¤
F.is_sheaf â†” Top.presheaf.is_sheaf (F â‹™ G)
f =o[l] g â†’ âˆ€ â¦ƒc : â„â¦„, 0 < c â†’ (âˆ€á¶  (x : Î±) in l, âˆ¥f xâˆ¥ â‰¤ c * âˆ¥g xâˆ¥)
g (â¨ (x : Î±), f x âˆ‚Î¼) â‰¤ â¨ (x : Î±), g (f x) âˆ‚Î¼
subsingleton (lie_ideal R â†¥âŠ¥)
add_monoid_algebra.of' R M m âˆˆ submodule.span R (add_monoid_algebra.of' R M '' S) â†” m âˆˆ S
q âˆˆ affine_span k (set.range p) â†” âˆƒ (s : finset Î¹) (w : Î¹ â†’ k), q = â‡‘(s.weighted_vsub_of_point p (p j)) w +áµ¥ p j
(â‹ƒ (x : Î±) (H : x âˆˆ Z), connected_component x) = Z
âˆƒ (s : M) (H : s âˆˆ S), âˆ¥m + sâˆ¥ < âˆ¥â‡‘(quotient_add_group.mk' S) mâˆ¥ + Îµ
âˆ¥deriv f câˆ¥ â‰¤ C / R
g +áµ¥ p1 -áµ¥ p2 = g + (p1 -áµ¥ p2)
A.mul ((â…Ÿ A).mul B) = B
tangent_map I I â‡‘((charted_space.chart_at H p.fst).symm) q = â‡‘((charted_space.chart_at (model_prod H E) p).symm) (â‡‘(equiv.sigma_equiv_prod H E) q)
aâº = a
âˆ€á¶  (n : â„•) in filter.at_top, v = (generalized_continued_fraction.of v).convergents n
(nhds 0).has_basis (Î» (_x : Î“â‚€Ë£), true) (Î» (Î³â‚€ : Î“â‚€Ë£), {Î³ : Î“â‚€ | Î³ < â†‘Î³â‚€})
x âŠ” y âˆˆ s
continuous (Î» (f : â†¥(measure_theory.Lp E 1 (Î¼.prod Î½))), âˆ« (x : Î±), âˆ« (y : Î²), â‡‘f (x, y) âˆ‚Î½ âˆ‚Î¼)
e.source âˆ© â‡‘e â»Â¹' t = e.source âˆ© s â†’ e.is_image s t
measure_theory.mem_â„’p.to_Lp â‡‘f _ âˆˆ measure_theory.Lp_meas_subgroup F m p Î¼
is_free_groupoid.spanning_tree.loop_of_hom T (is_free_groupoid.of e) = ğŸ™ (root' T)
âˆ‘' (i : â„¤), âˆ¥â‡‘(â‡‘(fourier_series.repr) f) iâˆ¥ ^ 2 = âˆ« (t : â†¥circle), âˆ¥â‡‘f tâˆ¥ ^ 2 âˆ‚haar_circle
(Î» (t : R), ring.inverse (â†‘x + t)) =O[nhds 0] Î» (t : R), 1
ğŸ™ (X, Y) = (ğŸ™ X, ğŸ™ Y)
has_inner.inner (l.sum (Î» (i : Î¹) (a : ğ•œ), a â€¢ v i)) x = l.sum (Î» (i : Î¹) (a : ğ•œ), â‡‘(star_ring_end ğ•œ) a â€¢ has_inner.inner (v i) x)
measure_theory.measure.map â‡‘(â‡‘matrix.to_lin' M) measure_theory.measure_space.volume = ennreal.of_real |(M.det)â»Â¹| â€¢ measure_theory.measure_space.volume
measure_theory.smul_invariant_measure G (G â§¸ Î“) (measure_theory.measure.map quotient_group.mk (Î¼.restrict ğ“•))
(âˆ€á¶  (x : Î±) in residual Î±, p x) â†” âˆƒ (t : set Î±), is_GÎ´ t âˆ§ dense t âˆ§ âˆ€ (x : Î±), x âˆˆ t â†’ p x
X.Î´ j.succ â‰« X.Î´ i = X.Î´ (â‡‘fin.cast_succ i) â‰« X.Î´ j
cont_mdiff_on I I'' n (g âˆ˜ f) (s âˆ© f â»Â¹' t)
â†‘(N âŠ” H) = â†‘N * â†‘H
âˆƒ (n : â„•), âˆ€ (m : â„•), n â‰¤ m â†’ f m = âŠ¥
â‡‘is_R_or_C.im (has_inner.inner x y) = (âˆ¥x - is_R_or_C.I â€¢ yâˆ¥ * âˆ¥x - is_R_or_C.I â€¢ yâˆ¥ - âˆ¥x + is_R_or_C.I â€¢ yâˆ¥ * âˆ¥x + is_R_or_C.I â€¢ yâˆ¥) / 4
is_connected (f â»Â¹' connected_component t)
â‡‘(Î¼.prod measure_theory.measure_space.volume) (region_between f g s) = ennreal.of_real (âˆ« (y : Î±) in s, (g - f) y âˆ‚Î¼)
âˆ« (x : â„) in a..b, f x < âˆ« (x : â„) in a..b, g x
â†‘s âˆ© â†‘(affine_subspace.mk' p (s.direction)á—®) = {â†‘(â‡‘(euclidean_geometry.orthogonal_projection s) p)}
âˆƒ (n : â„•), n â‰  0 âˆ§ (f ^ n).ker âŠ” (f ^ n).range = âŠ¤
has_sum (Î» (n : Î¹), âˆ« (t : â„) in a..b, F n t âˆ‚Î¼) (âˆ« (t : â„) in a..b, f t âˆ‚Î¼)
fintype.card (zmod n)Ë£ = n.totient
finite_dimensional K â†¥âŠ¥
âˆ¥x - yâˆ¥ ^ 2 = âˆ¥xâˆ¥ ^ 2 - 2 * â‡‘is_R_or_C.re (has_inner.inner x y) + âˆ¥yâˆ¥ ^ 2
set.inj_on (Î» (x : Î±), (x âŠ” u)  v) {x : Î± | disjoint u x âˆ§ v â‰¤ x}
âˆ¥f'âˆ¥ â‰¤ C
vector_span k (set.range p) = submodule.span k (set.range (Î» (i : {x // x â‰  iâ‚€}), p iâ‚€ -áµ¥ p â†‘i))
dimH (f '' s) â‰¤ dimH s / â†‘r
a â©¿ b
I.is_maximal â†” is_field (R â§¸ I)
cont_mdiff_on I.tangent I'.tangent m (tangent_map_within I I' f s) (tangent_bundle.proj I M â»Â¹' s)
cardinal.mk â†¥{t : set Î± | measurable_space.generate_measurable s t} â‰¤ linear_order.max (cardinal.mk â†¥s) 2 ^ cardinal.aleph_0
p1 -áµ¥ p3 - (p2 -áµ¥ p3) = p1 -áµ¥ p2
âˆƒ (s : set Î±), s.countable âˆ§ (â‹ƒ (x : Î±) (H : x âˆˆ s), f x) = set.univ
measurable (Î» (y : Î²), âˆ«â» (x : Î±), f x y âˆ‚Î¼)
finite_dimensional K â†¥Sâ‚
â‡‘v x = âŠ¤ â†” x = 0
unique_diff_within_at ğ•œ (s Ã—Ë¢ t) (x, y)
is_add_submonoid (f â»Â¹' s)
fintype.card Î² = finset.univ.sum (Î» (Ï‰ : quotient (add_action.orbit_rel Î± Î²)), fintype.card Î± / fintype.card â†¥(add_action.stabilizer Î± (Ï† Ï‰)))
affine_span k ({p} âˆª (Î» (v : V), v +áµ¥ p) '' s) = âŠ¤
Â¬0.nondegenerate
dimH (f '' t) â‰¤ dimH t
0 â‰¤áµ[Î¼] f
âˆ¥continuous_linear_map.id ğ•œ Eâˆ¥ â‰¤ 1
algebra.is_algebraic R A â†” âŠ¤.is_algebraic
closure E = â‹‚ (Î´ : â„) (H : Î´ âˆˆ s), metric.thickening Î´ E
â‡‘Î¼ E * âˆ«â» (y : G), f yâ»Â¹ / â‡‘Î½ ((Î» (x : G), x * yâ»Â¹) â»Â¹' E) âˆ‚Î½ = âˆ«â» (x : G), f x âˆ‚Î¼
âˆ« (x : G), f (x * g) âˆ‚Î¼ = âˆ« (x : G), f x âˆ‚Î¼
has_ftaylor_series_up_to_on n (â‡‘g âˆ˜ f) (Î» (x : E) (k : â„•), g.comp_continuous_multilinear_map (p x k)) s
continuous_on f s â†” continuous_on (f âˆ˜ â‡‘e) (e.to_local_equiv.source âˆ© â‡‘e â»Â¹' s)
disjoint K Ká—®
measurable â‡‘(measure_theory.Lp.simple_func.to_simple_func f)
category_theory.bicategory.whisker_right (category_theory.bicategory.left_unitor f).hom g = (category_theory.bicategory.associator (ğŸ™ a) f g).hom â‰« (category_theory.bicategory.left_unitor (f â‰« g)).hom
s.sum (Î» (i : Î¹), w i â€¢ (pâ‚ i -áµ¥ pâ‚‚ i)) = â‡‘(s.affine_combination pâ‚) w -áµ¥ â‡‘(s.affine_combination pâ‚‚) w
s.sum (Î» (b : Î²), â‡‘Î¼ (f â»Â¹' {b})) = â‡‘Î¼ (f â»Â¹' â†‘s)
f.c.app (opposite.op U) â‰« H.inv_app ((topological_space.opens.map f.base).obj U) = Y.presheaf.map (category_theory.eq_to_hom _).op
finite_dimensional.finrank k â†¥(vector_span k (set.range p)) â‰¤ n
â†¥((fin.find p).is_some) â†” âˆƒ (i : fin n), p i
â‡‘F f = finsupp.sum f (Î» (a : G) (b : k), b â€¢ â‡‘F (finsupp.single a 1))
âˆ¥fâˆ¥ â‰¤ M
âˆ€á¶  (y : E) in nhds x, has_fderiv_at f (â‡‘(continuous_multilinear_curry_fin1 ğ•œ E F) (p y 1)) y
set.eq_on â‡‘f â‡‘g (closure â†‘(submodule.span Râ‚ s))
âˆƒ (F : circle_deg1_lift), function.semiconj â‡‘F â‡‘fâ‚ â‡‘fâ‚‚
filter.tendsto F l (nhds f) â†” tendsto_uniformly (Î» (i : Î¹), â‡‘(F i)) â‡‘f l
â‡‘(measure_theory.measure.map f Î¼) s = â‡‘Î¼ (f â»Â¹' s)
â‡‘(linear_map.inl ğ•œ E F) '' tangent_cone_at ğ•œ s x âŠ† tangent_cone_at ğ•œ (s Ã—Ë¢ t) (x, y)
filter.tendsto (Î» (n : â„•), âˆ«â» (x : Î±), f n x âˆ‚Î¼) filter.at_top (nhds (âˆ«â» (x : Î±), F x âˆ‚Î¼))
âˆƒ (C : â„), âˆ€ (y : E), y âˆˆ emetric.ball x r' â†’ âˆ€ (z : E), z âˆˆ emetric.ball x r' â†’ âˆ¥f y - f z - â‡‘(p 1) (Î» (_x : fin 1), y - z)âˆ¥ â‰¤ C * linear_order.max âˆ¥y - xâˆ¥ âˆ¥z - xâˆ¥ * âˆ¥y - zâˆ¥
âˆƒ (C : â„) (hâ‚€ : 0 < C), âˆƒá¶  (n : â„•) in filter.at_top, 1 â‰¤ n âˆ§ âˆƒ (m : â„¤), x â‰  â†‘m / â†‘n âˆ§ |x - â†‘m / â†‘n| < C / â†‘n ^ p
finite_dimensional.finrank k â†¥(vector_span k (set.range p)) â‰¤ n â†” Â¬affine_independent k p
âˆ«â» (x : Î±), f x âˆ‚Î¼ â‰¤ C
X.Î´ (â‡‘fin.cast_succ i) â‰« X.Î´ i = X.Î´ i.succ â‰« X.Î´ i
infi f * x = â¨… (i : Î¹), f i * x
deriv_within (Î» (u : â„), âˆ« (x : â„) in u..b, f x) s a = -c
â‡‘F f = finsupp.sum f (Î» (a : G) (b : k), b â€¢ â‡‘F (finsupp.single a 1))
module.is_torsion R â†¥(submodule.torsion R M)
âˆƒ (u : set Î±) (v : set Î²), is_open u âˆ§ is_open v âˆ§ s âŠ† u âˆ§ t âŠ† v âˆ§ u Ã—Ë¢ v âŠ† n
is_empty (Î± â†ª Î²)
((Î» (x : Î±), âˆ¥f' xâˆ¥) =o[l] Î» (x : Î±), âˆ¥g' xâˆ¥) â†’ f' =o[l] g'
â‡‘Î¼ (f â»Â¹' s) = â‡‘Î½ (g â»Â¹' s)
has_deriv_within_at (Î» (u : â„), âˆ« (x : â„) in u..b, f x) (-c) s a
(F.right_derived n).map f = (F.right_derived_obj_iso n Q).hom â‰« (homology_functor D (complex_shape.up â„•) n).map ((F.map_homological_complex (complex_shape.up â„•)).map g) â‰« (F.right_derived_obj_iso n P).inv
filter.tendsto (Î» (i : â„•), âˆ‘' (k : â„•), f (k + i)) filter.at_top (nhds 0)
algebraic_independent R coe â†’ cardinal.mk â†¥s â‰¤ â†‘n
âˆ¥â‡‘(add_monoid_hom.mul_left x) yâˆ¥ â‰¤ âˆ¥xâˆ¥ * âˆ¥yâˆ¥
differentiable_on â„‚ (function.update f c (lim (nhds_within c {c}á¶œ) f)) s
x âˆˆ set.Icc a b â†’ âˆ¥f xâˆ¥ â‰¤ B x
i.inv â‰« sq.left â‰« p.hom = sq.right
ring.inverse x = â…Ÿ x
s.sum (Î» (i : Î¹), w i â€¢ (pâ‚ -áµ¥ pâ‚‚ i)) = -â‡‘(s.weighted_vsub pâ‚‚) w
fixing_subgroup M (s âˆª t) = fixing_subgroup M s âŠ“ fixing_subgroup M t
antitone (Î» (n : â„•), f^[n] x)
star_convex ğ•œ x (â‡‘f â»Â¹' s)
(â¨† (i : Î¹) (h : p i), S i) = ((dfinsupp.sum_add_hom (Î» (i : Î¹), (S i).subtype)).comp (dfinsupp.filter_add_monoid_hom (Î» (i : Î¹), â†¥(S i)) p)).mrange
measurable_space.generate_from (set.univ.pi '' set.univ.pi C) = measurable_space.pi
(submodule.span â„‚ (set.range (fourier_Lp p))).topological_closure = âŠ¤
is_lower_set s â†’ is_upper_set (â‡‘order_dual.to_dual â»Â¹' s)
â‡‘(monoid_algebra.of R M) m âˆˆ submodule.span R (â‡‘(monoid_algebra.of R M) '' S) â†” m âˆˆ S
category_theory.presheaf.second_map R F â‰« (Top.presheaf.covering_of_presieve.second_obj_iso_pi_inters F U R).hom = (Top.presheaf.covering_of_presieve.first_obj_iso_pi_opens F U R).hom â‰« Top.presheaf.sheaf_condition_equalizer_products.right_res F (Top.presheaf.covering_of_presieve U R)
e.is_image s t â†’ e.to_local_equiv.target âˆ© â‡‘(e.symm) â»Â¹' (e.to_local_equiv.source âˆ© s) = e.to_local_equiv.target âˆ© t
has_deriv_at f f' x â†” has_fderiv_at f (1.smul_right f') x
âˆ¥â‡‘f mâ‚ - â‡‘f mâ‚‚âˆ¥ â‰¤ C * finset.univ.sum (Î» (i : Î¹), finset.univ.prod (Î» (j : Î¹), ite (j = i) âˆ¥mâ‚ i - mâ‚‚ iâˆ¥ (linear_order.max âˆ¥mâ‚ jâˆ¥ âˆ¥mâ‚‚ jâˆ¥)))
e.target âˆ© â‡‘(e.symm) â»Â¹' s = e.target âˆ© t â†’ e.is_image s t
(â‡‘(topological_space.compacts.equiv f) K).carrier = â‡‘(f.symm) â»Â¹' K.carrier
fintype.card Î² = finset.univ.sum (Î» (Ï‰ : quotient (mul_action.orbit_rel Î± Î²)), fintype.card Î± / fintype.card â†¥(mul_action.stabilizer Î± (Ï† Ï‰)))
has_deriv_at (Î» (u : â„), âˆ« (x : â„) in u..b, f x) (-c) a
set.image2 f (g '' s) t = g' '' set.image2 f' t s
set.interval (f a) (f b) âŠ† f '' set.interval a b
âˆƒ (k : â„•+), n = k + 1
finite_dimensional.finrank K (V â§¸ s) + finite_dimensional.finrank K â†¥s = finite_dimensional.finrank K V
is_compact (â‡‘f â»Â¹' s)
continuous_within_at f s x â†” continuous_within_at (f âˆ˜ â‡‘e) (â‡‘e â»Â¹' s) (â‡‘(e.symm) x)
y âˆˆ â‹ƒ (x : Î±) (H : x âˆˆ s), t x
â‡‘Î¼ K < âŠ¤
â‡‘f (v +áµ¥ p) = â‡‘(f.linear) v +áµ¥ â‡‘f p
B.separating_right â†” B.flip.ker = âŠ¥
Ï€ â»Â¹' (Ï€ '' U) = U
has_inner.inner (sâ‚.sum (Î» (iâ‚ : Î¹â‚), wâ‚ iâ‚ â€¢ vâ‚ iâ‚)) (sâ‚‚.sum (Î» (iâ‚‚ : Î¹â‚‚), wâ‚‚ iâ‚‚ â€¢ vâ‚‚ iâ‚‚)) = -sâ‚.sum (Î» (iâ‚ : Î¹â‚), sâ‚‚.sum (Î» (iâ‚‚ : Î¹â‚‚), wâ‚ iâ‚ * wâ‚‚ iâ‚‚ * (âˆ¥vâ‚ iâ‚ - vâ‚‚ iâ‚‚âˆ¥ * âˆ¥vâ‚ iâ‚ - vâ‚‚ iâ‚‚âˆ¥))) / 2
a â‹– b â†’ â‡‘order_dual.to_dual b â‹– â‡‘order_dual.to_dual a
âˆƒ (m : â†¥M), m â€¢ x âˆˆ algebra.adjoin R â†‘(is_localization.finset_integer_multiple (submonoid.map â†‘(algebra_map R S) M) s)
âˆ¥f y - f x - â‡‘Ï† (y - x)âˆ¥ â‰¤ C * âˆ¥y - xâˆ¥
â‡‘Î¼ (â‹‚ (i : Î¹), s i) = â¨… (i : Î¹), â‡‘Î¼ (s i)
bornology.is_cobounded sá¶œ â†’ bornology.is_bounded s
â†‘(affine_span k (p '' s1)) âˆ© â†‘(affine_span k (p '' s2)) = âˆ…
Kâ‚‚á—® â‰¤ Kâ‚á—®
âˆƒ (c : â„) (H : c < a) (B : â„), (f - g) =O[filter.comap complex.abs filter.at_top âŠ“ l] Î» (z : â„‚), real.exp (B * complex.abs z ^ c)
(âˆ€á¶  (x : Î±) in l, x âˆˆ s â†” x âˆˆ t) â†’ s =á¶ [l] t
is_closed_map â‡‘f
âˆ« (y : â„) in a..b, f' y = f b - f a
âˆƒ (m : â„•) (H : m > N), â‡‘Î¼ (s âˆ© f^[m] â»Â¹' s) â‰  0
(category_theory.cocone_of_representable Pâ‚).Î¹.app j â‰« Î± = (category_theory.cocone_of_representable Pâ‚‚).Î¹.app ((category_theory.category_of_elements.map Î±).op.obj j)
(Î» (t : Î¹), âˆ« (x : â„) in va t..vb t, f x âˆ‚Î¼ - âˆ« (x : â„) in ua t..ub t, f x âˆ‚Î¼ - (âˆ« (x : â„) in ub t..vb t, cb âˆ‚Î¼ - âˆ« (x : â„) in ua t..va t, ca âˆ‚Î¼)) =o[lt] Î» (t : Î¹), âˆ¥âˆ« (x : â„) in ua t..va t, 1 âˆ‚Î¼âˆ¥ + âˆ¥âˆ« (x : â„) in ub t..vb t, 1 âˆ‚Î¼âˆ¥
measurable_space.generate_from (set.univ.pi '' set.univ.pi (Î» (i : Î¹), {s : set (Î± i) | measurable_set s})) = measurable_space.pi
âˆƒ (g : C(Y, â„)), â‡‘g âˆ˜ e = â‡‘f
group.is_nilpotent G â†” âˆƒ (n : â„•) (H : â„• â†’ subgroup G), is_ascending_central_series H âˆ§ H n = âŠ¤
âˆƒ (x : E), c < âˆ¥xâˆ¥
(â¨† (b : Î±) (H : b âˆˆ s), b âŠ“ a) â‰¤ has_Sup.Sup s âŠ“ a
uniform_continuous â‡‘f
âˆ¥measure_theory.mem_â„’p.to_Lp â‡‘f _âˆ¥ â‰¤ âˆ¥fâˆ¥
p âˆˆ s1 âŠ“ s2 â†” p âˆˆ s1 âˆ§ p âˆˆ s2
âˆ‘' (i : â„•), 1 / m ^ (i + (n + 1)).factorial < (1 - 1 / m)â»Â¹ * (1 / m ^ (n + 1).factorial)
Î¼.inner_regular p (Î» (s : set Î±), measurable_set s âˆ§ â‡‘Î¼ s â‰  âŠ¤)
â‡‘(measure_theory.measure.hausdorff_measure d) s â‰¤ l.liminf (Î» (n : Î²), âˆ‘' (i : Î¹ n), emetric.diam (t n i) ^ d)
âˆ¥â‡‘(quotient_add_group.mk' S) mâˆ¥ â‰¤ âˆ¥mâˆ¥
function.injective â‡‘f
âˆƒ (j : J) (V : set â†¥(F.obj j)) (hV : is_clopen V), U = â‡‘(C.Ï€.app j) â»Â¹' V
s -áµ¥ s âŠ† â†‘(vector_span k s)
emetric.inf_edist x (s âˆª t) = emetric.inf_edist x s âŠ“ emetric.inf_edist x t
âˆ€á¶  (z : â„) in nhds_within x s, âˆ¥z - xâˆ¥â»Â¹ * âˆ¥f z - f xâˆ¥ < r
hV.linear_isometry.to_linear_map.range = (â¨† (i : Î¹), (V i).to_linear_map.range).topological_closure
âˆ® (z : â„‚) in C(c, R), (z - w) ^ n = 0
cardinal.mk â†¥{t : set Î± | measurable_set t} â‰¤ linear_order.max (cardinal.mk â†¥s) 2 ^ cardinal.aleph_0
âˆ¥â‡‘f xâˆ¥ â‰¤ âˆ¥fâˆ¥ * âˆ¥xâˆ¥
ideal.is_jacobson R â†” âˆ€ {I : ideal R}, I.is_prime â†’ (âˆƒ (M : set (ideal R)), (âˆ€ (J : ideal R), J âˆˆ M â†’ J.is_maximal âˆ¨ J = âŠ¤) âˆ§ I = has_Inf.Inf M)
v +áµ¥ p âˆˆ affine_subspace.mk' p direction
has_Inf.Inf ((Î» (t : â„), âˆ« (x : â„) in 0..t, g x) '' set.Icc 0 T) + âŒŠt / TâŒ‹ â€¢ âˆ« (x : â„) in 0..T, g x â‰¤ âˆ« (x : â„) in 0..t, g x
âˆ¥f xâˆ¥ â‰¤ gronwall_bound Î´ K Îµ (x - a)
continuous_on (tangent_map_within I I' f s) (tangent_bundle.proj I H â»Â¹' s)
Î¼.inner_content (â¨† (i : â„•), U i) â‰¤ âˆ‘' (i : â„•), Î¼.inner_content (U i)
f.mrange = âŠ¤
âˆƒ (u : set (set Î±)) (H : u âŠ† t), u.countable âˆ§ u.pairwise_disjoint id âˆ§ â‡‘Î¼ (s  â‹ƒ (a : set Î±) (H : a âˆˆ u), a) = 0
continuous (show B â†’ Z.total_space, from Î» (x : B), âŸ¨x, vâŸ©)
module.End.has_eigenvalue T (â†‘â¨† (x : {x // x â‰  0}), â‡‘is_R_or_C.re (has_inner.inner (â‡‘T â†‘x) â†‘x) / âˆ¥â†‘xâˆ¥ ^ 2)
x âˆˆ set.Icc a b â†’ âˆ¥f xâˆ¥ â‰¤ B x
âˆ¥(â†‘âˆ¥xâˆ¥)â»Â¹ â€¢ xâˆ¥ = 1
continuous (Î» (f : C(Î±, Î²)), â‡‘f x)
has_inner.inner (r â€¢ x) x = r * (âˆ¥xâˆ¥ * âˆ¥xâˆ¥)
âˆ« (x : â„) in a..b, (g âˆ˜ f) x * f' x = âˆ« (x : â„) in f a..f b, g x
Â¬a â©¿ b â†” âˆƒ (c : Î±), a < c âˆ§ c < b
finite_dimensional.finrank K â†¥s â‰¤ finite_dimensional.finrank K V
âˆ« (x : Î±), âˆ« (y : Î²), f x y âˆ‚Î½ âˆ‚Î¼ = âˆ« (z : Î² Ã— Î±), f z.snd z.fst âˆ‚Î½.prod Î¼
dense {x}á¶œ â†” Â¬is_open {x}
â‡‘(c âŠ“ d) x y â†” â‡‘c x y âˆ§ â‡‘d x y
âˆ«â» (a : Î±), f a âˆ‚Î¼ + Îµ * â‡‘Î¼ {x : Î± | f x + Îµ â‰¤ g x} â‰¤ âˆ«â» (a : Î±), g a âˆ‚Î¼
s.monge_point = (â†‘(n + 1) / â†‘(n - 1)) â€¢ (finset.centroid â„ finset.univ s.points -áµ¥ s.circumcenter) +áµ¥ s.circumcenter
set.eq_on â‡‘e â‡‘e' e.source
âˆ¥â‡‘f zâˆ¥ â‰¤ c / r * âˆ¥zâˆ¥
âˆƒ (M : â„), 0 < M âˆ§ measure_theory.snorm ({x : Î± | M â‰¤ â†‘âˆ¥f xâˆ¥â‚Š}.indicator f) p Î¼ â‰¤ ennreal.of_real Îµ
â†‘(â‡‘(category_theory.limits.fork.is_limit.hom_iso ht Z') (q â‰« k)) = q â‰« â†‘(â‡‘(category_theory.limits.fork.is_limit.hom_iso ht Z) k)
has_deriv_at â‡‘(f.symm) f'â»Â¹ a
is_coatom a â†’ a â‹– âŠ¤
(âˆ€ (f : â„• â†’o (submodule R M)áµ’áµˆ), âˆƒ (n : â„•), âˆ€ (m : â„•), n â‰¤ m â†’ â‡‘f n = â‡‘f m) â†” is_artinian R M
âˆ¥f.mk_normed_group_hom C hâˆ¥ â‰¤ C
(lower_bounds s âˆ© t).nonempty â†’ bdd_above (f '' s)
y âˆˆ â‹‚ (x : Î±) (H : x âˆˆ s), t x
finite_dimensional.finrank k â†¥(vector_span k â†‘(finset.image p s)) â‰¤ n
âˆ¥f zâˆ¥ â‰¤ C
âˆƒ (G : finset M), algebra.adjoin R (add_monoid_algebra.of' R M '' â†‘G) = âŠ¤
â‡‘(f.lift hg) (f.mk' x y) = â‡‘g x + â†‘-â‡‘(is_add_unit.lift_right (g.restrict S) hg) y
âˆ¥f y - f xâˆ¥ â‰¤ C * âˆ¥y - xâˆ¥
tendsto_uniformly F f p â†” âˆ€ (Îµ : â„), Îµ > 0 â†’ (âˆ€á¶  (n : Î¹) in p, âˆ€ (x : Î²), has_dist.dist (f x) (F n x) < Îµ)
x = y â†” âˆ¥xâˆ¥ = âˆ¥yâˆ¥
âˆ¥â‡‘f xâˆ¥ = 0
âˆƒ (M : category_theory.bundled L.Structure), first_order.language.Structure.cg L â†¥M âˆ§ L.age â†¥M = K
âˆ« (x : â„) in a..b, (g âˆ˜ f) x * f' x = âˆ« (u : â„) in f a..f b, g u
|â‡‘f (bernstein.z k) - â‡‘f x| < Îµ / 2
â†‘-v = -â†‘v
âˆƒ (P : finset (ideal R)) [_inst_6 : decidable_eq â†¥P] [_inst_7 : âˆ€ (p : ideal R), p âˆˆ P â†’ prime p] (e : â†¥P â†’ â„•), direct_sum.is_internal (Î» (p : â†¥P), submodule.torsion_by_set R M â†‘(â†‘p ^ e p))
âˆƒ (a : Î±), infinite â†¥(f â»Â¹' {a})
set.range (â‡‘b âˆ˜ â‡‘(e.symm)) = set.range â‡‘b
âˆ¥â‡‘f mâˆ¥ â‰¤ âˆ¥fâˆ¥
subgroup.normal_closure {âŸ¨f, _âŸ©} = âŠ¤
add_submonoid.map f (add_submonoid.closure s) = add_submonoid.closure (â‡‘f '' s)
collinear k s â†” module.rank k â†¥(vector_span k s) â‰¤ 1
algebraic_geometry.to_Spec_Î“ (algebraic_geometry.LocallyRingedSpace.Î“.obj (opposite.op X)) â‰« X.to_Î“_Spec.val.c.app (opposite.op âŠ¤) = ğŸ™ (algebraic_geometry.LocallyRingedSpace.Î“.obj (opposite.op X))
coe =o[filter.at_top] Î» (n : â„•), r ^ n
measurable (Î» (x : Î±), â‡‘Î½ (prod.mk x â»Â¹' s))
filter.tendsto (Î» (i : Î¹), âˆ«â» (x : Î±) in s i, f x âˆ‚Î¼) l (nhds 0)
subfield.map f (subfield.closure s) = subfield.closure (â‡‘f '' s)
cardinal.mk â†¥s â‰¤ cardinal.continuum â†’ cardinal.mk â†¥{t : set Î± | measurable_set t} â‰¤ cardinal.continuum
function.injective â‡‘(ring.direct_limit.of G (Î» (i j : Î¹) (h : i â‰¤ j), â‡‘(f' i j h)) i)
âˆ¥h.comp fâˆ¥ â‰¤ âˆ¥hâˆ¥ * âˆ¥fâˆ¥
affine_independent k (Î» (x : â†¥s), â†‘x)
category_theory.sieve.generate (Top.presheaf.presieve_of_covering U) âˆˆ â‡‘(opens.grothendieck_topology â†¥X) (supr U)
âˆ¥f.mk_continuous C Hâˆ¥ â‰¤ linear_order.max C 0
g '' (f '' s) = (Î» (x : Î±), g (f x)) '' s
(âˆƒ (fs : finset Î¹) (hfs : â†‘fs âŠ† s) (w : Î¹ â†’ k) (hw : fs.sum (Î» (i : Î¹), w i) = 1), p0 = â‡‘(fs.affine_combination p) w) â†” âˆƒ (fs : finset â†¥s) (w : â†¥s â†’ k) (hw : fs.sum (Î» (i : â†¥s), w i) = 1), p0 = â‡‘(fs.affine_combination (Î» (i : â†¥s), p â†‘i)) w
add_le_cancellable a â†” a â‰  âŠ¤
has_fpower_series_on_ball f (cauchy_power_series f z â†‘R) z âŠ¤
âˆ€á¶  (y : Î±) in nhds a, f â‰¤á¶ [nhds y] g
function.surjective â‡‘(I.quotient_map (algebra_map R S) H)
category_theory.limits.has_colimits Cáµ’áµ–
âˆƒ (K : nnreal), antilipschitz_with K â‡‘f
cardinal.mk (â†¥ğ’«s) = 2 ^ cardinal.mk â†¥s
continuous_linear_map.id ğ•œ E = K.subtypeL.comp (orthogonal_projection K) + Ká—®.subtypeL.comp (orthogonal_projection Ká—®)
circle_integrable (Î» (z : â„‚), (z - w) ^ n) c R â†” R = 0 âˆ¨ 0 â‰¤ n âˆ¨ w âˆ‰ metric.sphere c |R|
a â‹– b â†’ â†‘a â‹– â†‘b
function.is_fixed_pt f^[n] x
âˆ‘' (b : â†¥s), â‡‘Î¼ (f â»Â¹' {â†‘b}) = â‡‘Î¼ (f â»Â¹' s)
cont_diff_on ğ•œ âŠ¤ f s â†” differentiable_on ğ•œ f s âˆ§ cont_diff_on ğ•œ âŠ¤ (Î» (y : E), fderiv ğ•œ f y) s
âˆƒ (S : L.elementary_substructure M), s âŠ† â†‘S âˆ§ (cardinal.mk â†¥S).lift = Îº.lift
measure_theory.integrable â‡‘(â‡‘(measure_theory.condexp_L2 ğ•œ hm) (measure_theory.indicator_const_Lp 2 hs hÎ¼s x)) Î¼
f.range = âŠ¤
finprod (Î» (a : Î±), finprod (Î» (H : a âˆˆ â‹ƒ (i : Î¹), t i), f a)) = finprod (Î» (i : Î¹), finprod (Î» (a : Î±), finprod (Î» (H : a âˆˆ t i), f a)))
â‡‘measure_theory.measure.count s = âŠ¤
S.functor_inclusion â‰« g = x â†” (â‡‘category_theory.presieve.nat_trans_equiv_compatible_family x).val.is_amalgamation (â‡‘category_theory.yoneda_equiv g)
box_integral.prepartition.split I i x = âŠ¤
cardinal.mk â†¥set.univ = cardinal.mk R ^ 4
f (has_Sup.Sup s) = has_Sup.Sup (f '' s)
(G.map_homological_complex c).map (homotopy.null_homotopic_map hom) = homotopy.null_homotopic_map (Î» (i j : Î¹), G.map (hom i j))
âˆ« (x : Î±) in s, â‡‘(â‡‘(measure_theory.condexp_L1_clm hm Î¼) f) x âˆ‚Î¼ = âˆ« (x : Î±) in s, â‡‘f x âˆ‚Î¼
x = y â†” âˆ¥xâˆ¥ = âˆ¥yâˆ¥ âˆ§ o.oangle x y = 0
has_inner.inner x y = âˆ¥xâˆ¥ * âˆ¥yâˆ¥ â†” inner_product_geometry.angle x y = 0
âˆ¥normed_group_hom.equalizer.lift Ï† hâˆ¥ â‰¤ C
âˆ¥0âˆ¥ = 0
âˆƒ (V : topological_space.opens â†¥X) (i : V âŸ¶ U) (hxV : x.val âˆˆ V), is_unit (â‡‘(X.to_PresheafedSpace.presheaf.map i.op) f)
emetric.Hausdorff_edist s t â‰  âŠ¤
filter.tendsto (Î» (n : Î¹), âˆ« (x : â„) in a..b, F n x âˆ‚Î¼) l (nhds (âˆ« (x : â„) in a..b, f x âˆ‚Î¼))
âˆƒ (g : Î± â†’ ennreal), (âˆ€ (x : Î±), â†‘(f x) < g x) âˆ§ lower_semicontinuous g âˆ§ (âˆ€áµ (x : Î±) âˆ‚Î¼, g x < âŠ¤) âˆ§ measure_theory.integrable (Î» (x : Î±), (g x).to_real) Î¼ âˆ§ âˆ« (x : Î±), (g x).to_real âˆ‚Î¼ < âˆ« (x : Î±), â†‘(f x) âˆ‚Î¼ + Îµ
algebra.discr A ((P.map â‡‘(algebra_map A B)).mul_vec b) = P.det ^ 2 * algebra.discr A b
(âˆ€á¶  (x : Î±) in l, p x) â†’ (âˆ€á¶  (s : set Î±) in l.small_sets, âˆ€ (x : Î±), x âˆˆ s â†’ p x)
function.surjective â‡‘(finsupp.total M M R id)
(Î» (i : Î¹), âˆ« (x : Î±) in s i, f x âˆ‚Î¼ - m i â€¢ b) =o[li] m
((category_theory.equalizer.first_obj_eq_family P â‡‘S).hom x).compatible â†” category_theory.equalizer.sieve.first_map P S x = category_theory.equalizer.sieve.second_map P S x
function_field.class_number Fq F = 1 â†” is_principal_ideal_ring â†¥(function_field.ring_of_integers Fq F)
continuous â‡‘(add_monoid_hom.mul_left x)
âˆƒ (a : â„) (H : a âˆˆ set.Ioo 0 1) (C : â„) (H : C > 0), âˆ€ (n : â„•), âˆ¥p nâˆ¥ * â†‘r ^ n â‰¤ C * a ^ n
â‡‘((p.bind f).to_measure) s = âˆ‘' (a : Î±), â†‘(â‡‘p a) * â‡‘((f a).to_measure) s
vector_span k s = submodule.span k ((Î» (_x : P), _x -áµ¥ p) '' (s  {p}))
a â‰¡ b [MOD m]
cont_diff_within_at ğ•œ n (f âˆ˜ â‡‘e) (â‡‘e â»Â¹' s) (â‡‘(e.symm) x) â†” cont_diff_within_at ğ•œ n f s x
category_theory.limits.kernel_subobject f â‰¤ category_theory.limits.kernel_subobject (f â‰« h)
algebraic_geometry.polynomial.image_of_Df f = â‡‘(prime_spectrum.comap polynomial.C) '' (prime_spectrum.zero_locus {f})á¶œ
filter.tendsto (â‡‘Î¼ âˆ˜ s) filter.at_top (nhds (â‡‘Î¼ (â‹‚ (n : Î¹), s n)))
(âˆ€ (i : Î¹), i âˆˆ I â†’ is_metric_separated (s i) t) â†’ is_metric_separated (â‹ƒ (i : Î¹) (H : i âˆˆ I), s i) t
p.radius - â†‘âˆ¥xâˆ¥â‚Š â‰¤ (p.change_origin x).radius
âˆ« (x : fin (n + 1) â†’ â„) in set.Icc a b, finset.univ.sum (Î» (i : fin (n + 1)), â‡‘(f' x) (pi.single i 1) i) = finset.univ.sum (Î» (i : fin (n + 1)), (âˆ« (x : fin n â†’ â„) in set.Icc (a âˆ˜ â‡‘(i.succ_above)) (b âˆ˜ â‡‘(i.succ_above)), f (i.insert_nth (b i) x) i) - âˆ« (x : fin n â†’ â„) in set.Icc (a âˆ˜ â‡‘(i.succ_above)) (b âˆ˜ â‡‘(i.succ_above)), f (i.insert_nth (a i) x) i)
f =o[l] g â†” âˆ€ â¦ƒc : â„â¦„, 0 < c â†’ (âˆ€á¶  (x : Î±) in l, âˆ¥f xâˆ¥ â‰¤ c * âˆ¥g xâˆ¥)
(â¨… (o : option Î²), option.elim a f o) = a âŠ“ â¨… (b : Î²), f b
measure_theory.tendsto_in_measure Î¼ (Î» (n : Î¹), â‡‘(f n)) l â‡‘g
p1 -áµ¥ p = p2 -áµ¥ p â†” p1 = p2
fintype.card Î± â‰¡ fintype.card â†¥(mul_action.fixed_points G Î±) [MOD p]
âˆƒ (l : list F), l.length â‰¤ finite_dimensional.finrank â„ F âˆ§ Ï† = (list.map (Î» (v : F), reflection (submodule.span â„ {v})á—®) l).prod
âˆƒ (b : â†¥M), âˆ€ (i : Î¹), i âˆˆ s â†’ is_localization.is_integer R (â†‘b â€¢ f i)
algebraic_geometry.PresheafedSpace.stalk_map Î± x â‰« category_theory.eq_to_hom _ = category_theory.eq_to_hom _ â‰« algebraic_geometry.PresheafedSpace.stalk_map Î² x'
â‡‘f â»Â¹' S = â‡‘(f.symm) '' S
gauge s (r â€¢ x) = |r| â€¢ gauge s x
âˆ¥fâˆ¥ â‰¤ C â†” âˆ€ (x : Î±), âˆ¥â‡‘f xâˆ¥ â‰¤ C
(has_Inf.Inf S).to_setoid = has_Inf.Inf (add_con.to_setoid '' S)
x * infi f = â¨… (i : Î¹), x * f i
is_add_hom â‡‘h
topological_space.separable_space â†¥s
linear_independent R coe â†’ cardinal.mk â†¥s â‰¤ â†‘n
tendsto_locally_uniformly_on F f p s â†” âˆ€ (Îµ : ennreal), Îµ > 0 â†’ âˆ€ (x : Î²), x âˆˆ s â†’ (âˆƒ (t : set Î²) (H : t âˆˆ nhds_within x s), âˆ€á¶  (n : Î¹) in p, âˆ€ (y : Î²), y âˆˆ t â†’ has_edist.edist (f y) (F n y) < Îµ)
g '' set.image2 f s t = set.image2 f' (g' '' s) t
module.is_torsion_by R M a â†” submodule.torsion_by R M a = âŠ¤
eâ‚.orientation = eâ‚‚.orientation â†” 0 < â‡‘(eâ‚.det) â‡‘eâ‚‚
âˆ«â» (a : Î±), (f * g) a âˆ‚Î¼ = âˆ«â» (a : Î±), f a âˆ‚Î¼ * âˆ«â» (a : Î±), g a âˆ‚Î¼
âˆ«â» (x : G), f (x * g) âˆ‚Î¼ = âˆ«â» (x : G), f x âˆ‚Î¼
âˆ¥x + yâˆ¥ = âˆ¥x - yâˆ¥ â†” inner_product_geometry.angle x y = real.pi / 2
bdd_above s â†’ bdd_below (f '' s)
is_lie_abelian â†¥(lie_algebra.radical R L) â†” âˆ€ (I : lie_ideal R L), lie_algebra.is_solvable R â†¥I â†’ is_lie_abelian â†¥I
âˆƒ (g : E â†’L[ğ•œ] ğ•œ), âˆ¥gâˆ¥ = 1 âˆ§ â‡‘g x = â†‘âˆ¥xâˆ¥
H = âŠ¤
filter.tendsto (Î» (n : â„•), âˆ«â» (a : Î±), F n a âˆ‚Î¼) filter.at_top (nhds (âˆ«â» (a : Î±), f a âˆ‚Î¼))
0 < âˆ« (x : â„) in a..b, f x
SemiNormedGroup.explicit_cokernel_desc condb â‰« g = SemiNormedGroup.explicit_cokernel.map h â‰« SemiNormedGroup.explicit_cokernel_desc condd
m âˆˆ submodule.span R s â†” âˆƒ (c : M â†’â‚€ R), â†‘(c.support) âŠ† s âˆ§ c.sum (Î» (mi : M) (r : R), r â€¢ mi) = m
topological_space.induced f âŠ¥ = âŠ¥
measure_theory.smul_invariant_measure â†¥(Î“.opposite) G Î¼
filter.tendsto (Î» (s : finset Î±), âˆ‘' (b : {x // x âˆ‰ s}), f â†‘b) filter.at_top (nhds 0)
f '' a âŠ† f '' b
â‡‘(c âŠ“ d) x y â†” â‡‘c x y âˆ§ â‡‘d x y
X.Î´ (â‡‘fin.cast_succ i) â‰« X.Ïƒ j.succ = X.Ïƒ j â‰« X.Î´ i
algebra.adjoin R (â‹ƒ (f : monoid_algebra R M) (H : f âˆˆ S), â‡‘(monoid_algebra.of R M) '' â†‘(f.support)) = âŠ¤
âˆƒ (Î¦ : X â†’ â†¥(lp (Î» (n : â„•), â„) âŠ¤)) (Î¨ : Y â†’ â†¥(lp (Î» (n : â„•), â„) âŠ¤)), isometry Î¦ âˆ§ isometry Î¨ âˆ§ Gromov_Hausdorff.GH_dist X Y = metric.Hausdorff_dist (set.range Î¦) (set.range Î¨)
r âŠ” s = eqv_gen.setoid (Î» (x y : Î±), r.rel x y âˆ¨ s.rel x y)
(â¨… (i : Î¹'), s i) = â¨… (t : finset (plift Î¹')) (i : plift Î¹') (H : i âˆˆ t), s i.down
(âˆ€ (i : Î¹), i âˆˆ I â†’ is_metric_separated (s i) t) â†’ is_metric_separated (â‹ƒ (i : Î¹) (H : i âˆˆ I), s i) t
set.eq_on â‡‘f â‡‘g â†‘(submodule.span R s)
measure_theory.simple_func.integral Î¼ (measure_theory.simple_func.map g f) = f.range.sum (Î» (x : E), (â‡‘Î¼ (â‡‘f â»Â¹' {x})).to_real â€¢ g x)
âˆƒ (g : Î± â†’ nnreal), (âˆ€ (x : Î±), â‡‘f x â‰¤ g x) âˆ§ lower_semicontinuous g âˆ§ âˆ«â» (x : Î±), â†‘(g x) âˆ‚Î¼ â‰¤ âˆ«â» (x : Î±), â†‘(â‡‘f x) âˆ‚Î¼ + Îµ
group.is_nilpotent G â†” âˆƒ (n : â„•) (H : â„• â†’ subgroup G), is_descending_central_series H âˆ§ H n = âŠ¥
measure_theory.strongly_measurable (Î» (y : Î²), âˆ« (x : Î±), f (x, y) âˆ‚Î¼)
filter.tendsto f (l âŠ“ filter.principal s) (nhds a) â†” filter.tendsto f l (nhds a)
âˆ¥normed_group_hom.id Vâˆ¥ = 1
(â¨† (x : Î±), nhds (x, x)) â‰¤ uniformity Î±
s.monge_plane iâ‚ iâ‚‚ = affine_subspace.mk' (finset.centroid â„ {iâ‚, iâ‚‚}á¶œ s.points) (submodule.span â„ {s.points iâ‚ -áµ¥ s.points iâ‚‚})á—® âŠ“ affine_span â„ (set.range s.points)
dense (f '' s)
cont_diff_at ğ•œ n â‡‘(f.symm) a
pairwise (Î» (x y : â†¥s), r â†‘x â†‘y) â†’ s.pairwise r
âˆ¥âˆ‘' (n : â„•), x ^ nâˆ¥ â‰¤ âˆ¥1âˆ¥ - 1 + (1 - âˆ¥xâˆ¥)â»Â¹
is_compact (f '' s) â†” is_compact s
function.bijective â‡‘f
affine_independent k p â†” Â¬finite_dimensional.finrank k â†¥(vector_span k (set.range p)) â‰¤ n
has_inner.inner (s.monge_point -áµ¥ finset.centroid â„ {iâ‚, iâ‚‚}á¶œ s.points) (s.points iâ‚ -áµ¥ s.points iâ‚‚) = 0
deriv (Î» (u : â„), âˆ« (x : â„) in u..b, f x) a = -f a
âˆ« (x : â„) in a..b, real.sin x ^ (2 * m + 1) * real.cos x ^ n = âˆ« (u : â„) in real.cos b..real.cos a, u ^ n * (1 - u ^ 2) ^ m
f â‰« homotopy.null_homotopic_map hom = homotopy.null_homotopic_map (Î» (i j : Î¹), f.f i â‰« hom i j)
cont_mdiff_within_at I I' n f s x â†” continuous_within_at f s x âˆ§ cont_diff_within_at ğ•œ n (written_in_ext_chart_at I I' x f) (â‡‘((ext_chart_at I x).symm) â»Â¹' s âˆ© set.range â‡‘I) (â‡‘(ext_chart_at I x) x)
âˆ¥f.comp g.to_linear_isometry.to_continuous_linear_mapâˆ¥ = âˆ¥fâˆ¥
âˆƒ (a : â†¥s â†’â‚€ R) (ha : âˆ€ (i : â†¥s), â‡‘a i âˆˆ I), a.sum (Î» (i : â†¥s) (c : R), c â€¢ f â†‘i) = x
â†‘âŠ¥ = âˆ…
(â¨† (Î¼ : ğ•œ), module.End.eigenspace T Î¼)á—® = âŠ¥
R (m (sâ‚ âŠ” sâ‚‚)) (m sâ‚ + m sâ‚‚)
category_theory.limits.image_subobject (h â‰« f) â‰¤ category_theory.limits.image_subobject f
âˆ¥dslope f c zâˆ¥ â‰¤ Râ‚‚ / Râ‚
â‡‘(convex_hull R) s = â‡‘(finset.univ.sum (Î» (x : â†¥s), (linear_map.proj x).smul_right x.val)) '' std_simplex R â†¥s
ring_subgroups_basis (Î» (Î³ : Î“â‚€Ë£), v.lt_add_subgroup Î³)
s.sum (Î» (i : Î¹), w i â€¢ (pâ‚ i -áµ¥ pâ‚‚ i)) = â‡‘(s.weighted_vsub pâ‚) w - â‡‘(s.weighted_vsub pâ‚‚) w
âŠ¥ = âŠ¤
deriv_within (Î» (u : â„), âˆ« (x : â„) in u..b, f x) s a = -f a
set.eq_on f 0 (complex.re â»Â¹' set.Icc a b)
bdd_above s â†” small â†¥s
function.surjective â‡‘(mv_polynomial.aeval (Î» (s : â†¥S), â‡‘(monoid_algebra.of R M) â†‘s))
algebra.discr K â‡‘((is_primitive_root.power_basis K hÎ¶).basis) = (-1) ^ ((â†‘p - 1) / 2) * â†‘p ^ (â†‘p - 2)
dense (f '' t)á¶œ
is_GÎ´ (â‹‚ (i : Î¹), s i)
âˆƒ (n : â„•) (e : M â†’ euclidean_space â„ (fin n)), smooth I (model_with_corners_self â„ (euclidean_space â„ (fin n))) e âˆ§ closed_embedding e âˆ§ âˆ€ (x : M), function.injective â‡‘(mfderiv I (model_with_corners_self â„ (euclidean_space â„ (fin n))) e x)
(Î» (h : â„), f (x + h â€¢ (2 â€¢ v + 2 â€¢ w)) + f (x + h â€¢ (v + w)) - f (x + h â€¢ (2 â€¢ v + w)) - f (x + h â€¢ (v + 2 â€¢ w)) - h ^ 2 â€¢ â‡‘(â‡‘f'' v) w) =o[nhds_within 0 (set.Ioi 0)] Î» (h : â„), h ^ 2
algebra.discr â„š â‡‘((is_primitive_root.sub_one_power_basis â„š hÎ¶).basis) = (-1) ^ ((â†‘p ^ k).totient / 2) * â†‘p ^ (â†‘p ^ (k - 1) * ((â†‘p - 1) * k - 1))
âˆ¥c.smul_right fâˆ¥â‚Š = âˆ¥câˆ¥â‚Š * âˆ¥fâˆ¥â‚Š
pairwise (Î» (i j : I), âˆ€ (x : f i) (y : f j), commute (pi.mul_single i x) (pi.mul_single j y))
âˆƒ (C' : â„), âˆ€ (i : Î¹), âˆ¥g iâˆ¥ â‰¤ C'
category_theory.bicategory.whisker_left ((category_theory.free_bicategory.preinclusion B).map {as := p}) Î· â‰« (category_theory.free_bicategory.normalize_iso p g).hom = (category_theory.free_bicategory.normalize_iso p f).hom â‰« (category_theory.free_bicategory.preinclusion B).mapâ‚‚ (category_theory.eq_to_hom _)
s.fg â†” finite_dimensional K â†¥s
embedding â‡‘(category_theory.limits.pullback.map fâ‚ fâ‚‚ gâ‚ gâ‚‚ iâ‚ iâ‚‚ iâ‚ƒ eqâ‚ eqâ‚‚)
âˆƒ (eq_1 : (topological_space.opens.map (D.to_glue_data.t k i).base).op.obj (opposite.op (_.open_functor.obj U)) = opposite.op (_.open_functor.obj (opposite.unop ((topological_space.opens.map (D.to_glue_data.t' k i j).base).op.obj (opposite.op U))))), _.inv_app U â‰« (D.to_glue_data.t k i).c.app (opposite.op (_.open_functor.obj U)) â‰« (D.to_glue_data.V (k, i)).presheaf.map (category_theory.eq_to_hom eq_1) = (D.to_glue_data.t' k i j).c.app (opposite.op U) â‰« _.inv_app (opposite.unop ((topological_space.opens.map (D.to_glue_data.t' k i j).base).op.obj (opposite.op U)))
_.inv_app U â‰« (D.to_glue_data.t k i).c.app (opposite.op (_.open_functor.obj U)) = (D.to_glue_data.t' k i j).c.app (opposite.op U) â‰« _.inv_app (opposite.unop ((topological_space.opens.map (D.to_glue_data.t' k i j).base).op.obj (opposite.op U))) â‰« (D.to_glue_data.V (k, i)).presheaf.map (category_theory.eq_to_hom _)
is_cyclotomic_extension S A B â†” (âˆ€ (a : â„•+), a âˆˆ S â†’ (âˆƒ (r : B), â‡‘(polynomial.aeval r) (polynomial.cyclotomic â†‘a A) = 0)) âˆ§ algebra.adjoin A {b : B | âˆƒ (a : â„•+), a âˆˆ S âˆ§ b ^ â†‘a = 1} = âŠ¤
finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ g '' s), f i)) = finprod (Î» (j : Î²), finprod (Î» (H : j âˆˆ s), f (g j)))
s.sum (Î» (i : Î¹), âˆ¥has_inner.inner (v i) xâˆ¥ ^ 2) â‰¤ âˆ¥xâˆ¥ ^ 2
subsingleton (Î± â†’+*o Î²)
x ^ n.totient â‰¡ 1 [MOD n]
âˆ« (x : â„) in t..t + T, f x = âˆ« (x : â„) in s..s + T, f x
f.limsup (Î» (x : Î²), âŠ¥) = âŠ¥
function.injective â‡‘(x.succ_above)
âˆ« (x : fin (n + 1) â†’ â„) in set.Icc a b, finset.univ.sum (Î» (i : fin (n + 1)), â‡‘(f' i x) (pi.single i 1)) = finset.univ.sum (Î» (i : fin (n + 1)), (âˆ« (x : fin n â†’ â„) in set.Icc (a âˆ˜ â‡‘(i.succ_above)) (b âˆ˜ â‡‘(i.succ_above)), f i (i.insert_nth (b i) x)) - âˆ« (x : fin n â†’ â„) in set.Icc (a âˆ˜ â‡‘(i.succ_above)) (b âˆ˜ â‡‘(i.succ_above)), f i (i.insert_nth (a i) x))
âˆƒ (v : basis (fin (finite_dimensional.finrank K V)) K V), B.is_Ortho â‡‘v
cont_diff_on ğ•œ n (g âˆ˜ f) (s âˆ© f â»Â¹' t)
â‡‘(0.succ_above) = fin.succ
f n = n.factorization.prod (Î» (p k : â„•), f (p ^ k))
p * q = p.support.sum (Î» (i : â„•), q.sum (Î» (j : â„•) (a : R), â‡‘(polynomial.monomial (i + j)) (p.coeff i * a)))
âˆ€áµ (x : Î±) âˆ‚Î¼, filter.tendsto (Î» (a : set Î±), â‡‘Ï a / â‡‘Î¼ a) (v.filter_at x) (nhds 0)
g '' set.image2 f s t = set.image2 f' t (g' '' s)
a = âŠ¥
category_theory.presheaf.is_sheaf J P â†” category_theory.presheaf.is_sheaf J (P â‹™ s)
0 < âˆ« (x : â„) in a..b, f x âˆ‚Î¼ â†” a < b âˆ§ 0 < â‡‘Î¼ (function.support f âˆ© set.Ioc a b)
pairwise (disjoint on Î» (n : Î±), set.Ico (f (order.succ n)) (f n))
(âˆ€ (g : G) (A : set G), measurable_set A â†’ â‡‘Î¼ ((Î» (h : G), g * h) â»Â¹' A) = â‡‘Î¼ A) â†” Î¼.is_mul_left_invariant
âˆ¥âˆ‘' (i : Î¹), f iâˆ¥ â‰¤ a
iterated_deriv_within n f s x = (Î» (g : ğ•œ â†’ F), deriv_within g s)^[n] f x
measure_theory.integrable_on g (f '' s) Î¼ â†” measure_theory.integrable_on (Î» (x : E), |(f' x).det| â€¢ g (f x)) s Î¼
âˆƒ (G : finset M), algebra.adjoin R (â‡‘(monoid_algebra.of R M) '' â†‘G) = âŠ¤
1.order = 0
ğŸ™ P = P.decomp_id_i â‰« P.decomp_id_p
âˆƒ (Î± : Type v) (c : Î± â†’ X) (r : Î  (a : Î±), Î¹ (c a)), (âˆ€ (a : Î±), c a âˆˆ s âˆ§ p (c a) (r a)) âˆ§ (s âŠ† â‹ƒ (a : Î±), B (c a) (r a)) âˆ§ locally_finite (Î» (a : Î±), B (c a) (r a))
cardinal.mk Î² â‰¤ cardinal.mk â†¥(set.range f)
âˆ€áµ (x : Î±) âˆ‚Î¼, x âˆˆ s â†’ (âˆƒá¶  (n : â„•) in filter.at_top, f^[n] x âˆˆ s)
âˆƒ (g : linear_pmap â„ E â„), f < g âˆ§ âˆ€ (x : â†¥(g.domain)), â†‘x âˆˆ s â†’ 0 â‰¤ â‡‘g x
âˆ¥fâˆ¥ = has_Inf.Inf {C : â„ | 0 â‰¤ C âˆ§ âˆ€ (x : Î±), âˆ¥â‡‘f xâˆ¥ â‰¤ C}
âˆ€áµ (x : Î±) âˆ‚Î¼.restrict s, filter.tendsto (Î» (a : set Î±), â‡‘Î¼ (s âˆ© a) / â‡‘Î¼ a) (v.filter_at x) (nhds 1)
f' =o[l] g' â†’ ((Î» (x : Î±), âˆ¥f' xâˆ¥) =o[l] Î» (x : Î±), âˆ¥g' xâˆ¥)
strong_rank_condition R â†” âˆ€ (n : â„•) (f : (fin (n + 1) â†’ R) â†’â‚—[R] fin n â†’ R), Â¬function.injective â‡‘f
A.mul (â…Ÿ A) = 1
p1 = g +áµ¥ p2 â†” p1 -áµ¥ p2 = g
(â‹ƒ (j : Î¹'), â‹‚ (i : Î¹), s i j) = â‹‚ (i : Î¹), â‹ƒ (j : Î¹'), s i j
function.left_inverse â‡‘(mv_polynomial.map f) â‡‘(mv_polynomial.map g)
[group.is_nilpotent G, normalizer_condition G, âˆ€ (H : subgroup G), is_coatom H â†’ H.normal, âˆ€ (p : â„•), fact (nat.prime p) â†’ âˆ€ (P : sylow p G), â†‘P.normal, nonempty ((Î  (p : â†¥((fintype.card G).factorization.support)) (P : sylow â†‘p G), â†¥â†‘P) â‰ƒ* G)].tfae
s.sum (Î» (i : Î¹), w i â€¢ (pâ‚ -áµ¥ pâ‚‚ i)) = s.sum (Î» (i : Î¹), w i) â€¢ (pâ‚ -áµ¥ b) - â‡‘(s.weighted_vsub_of_point pâ‚‚ b) w
â‡‘(euclidean_geometry.reflection (affine_span â„ (s.points '' {iâ‚, iâ‚‚}))) s.circumcenter = â‡‘(finset.univ.affine_combination s.points_with_circumcenter) (affine.simplex.reflection_circumcenter_weights_with_circumcenter iâ‚ iâ‚‚)
y âˆˆ omega_limit f Ï• s â†” âˆ€ (n : set Î²), n âˆˆ nhds y â†’ (âˆƒá¶  (t : Ï„) in f, (s âˆ© Ï• t â»Â¹' n).nonempty)
has_sum (Î» (n : â„•), â‡‘(cauchy_power_series f c R n) (Î» (_x : fin n), w)) ((2 * â†‘real.pi * complex.I)â»Â¹ â€¢ âˆ® (z : â„‚) in C(c, R), (z - (c + w))â»Â¹ â€¢ f z)
g (â¨ (x : Î±) in t, f x âˆ‚Î¼) â‰¤ â¨ (x : Î±) in t, g (f x) âˆ‚Î¼
is_R_or_C.abs (has_inner.inner x y / (â†‘âˆ¥xâˆ¥ * â†‘âˆ¥yâˆ¥)) = 1 â†” x â‰  0 âˆ§ âˆƒ (r : ğ•œ), r â‰  0 âˆ§ y = r â€¢ x
âˆƒ (J : â†¥(non_zero_divisors (ideal S))), â‡‘(class_group.mk0 L) I = â‡‘(class_group.mk0 L) J âˆ§ â‡‘(algebra_map R S) ((class_group.finset_approx bS adm).prod (Î» (m : R), m)) âˆˆ â†‘J
fixing_subgroup M (â‹ƒ (i : Î¹), s i) = â¨… (i : Î¹), fixing_subgroup M (s i)
âŠ¤ âˆˆ fixed_by_finite K L
âˆ«â» (a : Î±), â†‘((f * g) a) âˆ‚Î¼ â‰¤ (âˆ«â» (a : Î±), â†‘(f a) ^ p âˆ‚Î¼) ^ (1 / p) * (âˆ«â» (a : Î±), â†‘(g a) ^ q âˆ‚Î¼) ^ (1 / q)
closure E = â‹‚ (Î´ : â„) (H : Î´ âˆˆ s), metric.cthickening Î´ E
âˆ«â» (z : Î± Ã— Î²), f z âˆ‚Î¼.prod Î½ = âˆ«â» (y : Î²), âˆ«â» (x : Î±), f (x, y) âˆ‚Î¼ âˆ‚Î½
has_fderiv_at (Î» (p : â„ Ã— â„), âˆ« (x : â„) in p.fst..p.snd, f x) ((continuous_linear_map.snd â„ â„ â„).smul_right cb - (continuous_linear_map.fst â„ â„ â„).smul_right ca) (a, b)
cont_diff ğ•œ n â‡‘f
Ká—® = â¨… (v : â†¥K), (â‡‘innerSL â†‘v).ker
(category_theory.shift_functor C j).map ((category_theory.shift_functor C i).map f) = (category_theory.shift_comm X i j).hom â‰« (category_theory.shift_functor C i).map ((category_theory.shift_functor C j).map f) â‰« (category_theory.shift_comm Y j i).hom
lipschitz_with âˆ¥fâˆ¥â‚Š â‡‘f
â‡‘(has_star.star f) = has_star.star â‡‘f
topological_space.is_topological_basis {U : set â†¥(C.X) | âˆƒ (j : J) (V : set â†¥(F.obj j)), V âˆˆ T j âˆ§ U = â‡‘(C.Ï€.app j) â»Â¹' V}
(âˆ€ (u : set E), u âŠ‡ v â†’ orthonormal ğ•œ coe â†’ u = v) â†” âˆƒ (b : basis â†¥v ğ•œ E), â‡‘b = coe
âˆ® (z : â„‚) in C(c, R), f' z = 0
is_R_or_C.abs (has_inner.inner x y) = âˆ¥xâˆ¥ * âˆ¥yâˆ¥ â†” âˆƒ (r : ğ•œ), r â‰  0 âˆ§ y = r â€¢ x
â‡‘f (Î» (i : Î¹), (A i).sum (Î» (j : Î± i), g i j)) = (fintype.pi_finset A).sum (Î» (r : Î  (a : Î¹), Î± a), â‡‘f (Î» (i : Î¹), g i (r i)))
monotone (f âŠ“ g)
R (m (â¨† (b : Î³), s b)) (âˆ‘' (b : Î³), m (s b))
has_dist.dist a p * has_dist.dist b p = |has_dist.dist b q ^ 2 - has_dist.dist p q ^ 2|
l <+ l' â†” âˆƒ (f : fin l.length â†ªo fin l'.length), âˆ€ (ix : fin l.length), l.nth_le â†‘ix _ = l'.nth_le â†‘(â‡‘f ix) _
(algebraic_geometry.structure_sheaf.stalk_iso â†¥R (â‡‘(prime_spectrum.comap f) p)).hom â‰« localization.local_ring_hom (â‡‘(prime_spectrum.comap f) p).as_ideal p.as_ideal f rfl â‰« (algebraic_geometry.structure_sheaf.stalk_iso â†¥S p).inv = algebraic_geometry.PresheafedSpace.stalk_map (algebraic_geometry.Spec.SheafedSpace_map f) p
0.comp_linear_map f = 0
function.injective â‡‘(polynomial.expand R n)
same_ray â„ x y â†” âˆ¥x + yâˆ¥ = âˆ¥xâˆ¥ + âˆ¥yâˆ¥
â‡‘(ideal.quotient.mk I) x âˆˆ ideal.map (ideal.quotient.mk I) J â†” x âˆˆ J âŠ” I
has_Sup.Sup S = con_gen (has_Sup.Sup (coe_fn '' S))
âˆ¥x + yâˆ¥ = âˆ¥xâˆ¥ + âˆ¥yâˆ¥
cont_mdiff_on I I n â‡‘e e.to_local_equiv.source
is_open_map â‡‘(f.linear) â†” is_open_map â‡‘f
K â‰ƒ+* L
Kâ‚á—® âŠ“ Kâ‚‚á—® = (Kâ‚ âŠ” Kâ‚‚)á—®
(x::áµ¥vector.nil).nth ix = x
cardinal.mk â†¥(measurable_space.generate_measurable_rec s i) â‰¤ linear_order.max (cardinal.mk â†¥s) 2 ^ cardinal.aleph_0
has_inner.inner x y = (âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + âˆ¥yâˆ¥ * âˆ¥yâˆ¥ - âˆ¥x - yâˆ¥ * âˆ¥x - yâˆ¥) / 2
s.sum (Î» (x : Î±), f x) = âŠ¤ â†” âˆƒ (a : Î±) (H : a âˆˆ s), f a = âŠ¤
(â¨ (x : Î±) in t, f x âˆ‚Î¼, â¨ (x : Î±) in t, g (f x) âˆ‚Î¼) âˆˆ {p : E Ã— â„ | p.fst âˆˆ s âˆ§ g p.fst â‰¤ p.snd}
âˆ«â» (x : Î±), f x âˆ‚Î¼ â‰¤ C
Â¬a â‹– b
X.Î´ (â‡‘fin.cast_succ i) â‰« X.Ïƒ i = ğŸ™ (X.obj (simplex_category.mk n))
â…lie_ideal.comap I.incl Iâ‚,lie_ideal.comap I.incl Iâ‚‚â† = lie_ideal.comap I.incl â…Iâ‚,Iâ‚‚â†
setoid.r = setoid.r âŠ“ setoid.r
filter.tendsto (Î» (n : Î¹), âˆ« (a : Î±), F n a âˆ‚Î¼) l (nhds (âˆ« (a : Î±), f a âˆ‚Î¼))
metric.diam (f '' s) = metric.diam s
set.Icc (f a) (f b) âŠ† f '' set.Icc a b
set.image2 f s (g '' t) = g' '' set.image2 f' s t
is_submonoid (â‹ƒ (i : Î¹), s i)
âˆƒá¶  (z : â„) in nhds_within x (set.Ioi x), (z - x)â»Â¹ * (âˆ¥f zâˆ¥ - âˆ¥f xâˆ¥) < r
_.inv_app U â‰« (D.to_glue_data.f i k).c.app (opposite.op (_.open_functor.obj U)) = category_theory.limits.pullback.fst.c.app (opposite.op U) â‰« _.inv_app (opposite.unop ((topological_space.opens.map category_theory.limits.pullback.fst.base).op.obj (opposite.op U))) â‰« (D.to_glue_data.V (i, k)).presheaf.map (category_theory.eq_to_hom _)
(Î» (x : Î±), âˆ¥f' xâˆ¥) =O[l] g â†’ f' =O[l] g
s.sum (Î» (i : Î¹), f i) < âŠ¤
subgroup.closure ((Î» (g : G), g * (â†‘(subgroup.mem_right_transversals.to_fun hR g))â»Â¹) '' (R * S)) = H
has_fderiv_within_at (Î» (p : â„ Ã— â„), âˆ« (x : â„) in p.fst..p.snd, f x) ((continuous_linear_map.snd â„ â„ â„).smul_right cb - (continuous_linear_map.fst â„ â„ â„).smul_right ca) (s Ã—Ë¢ t) (a, b)
cont_diff_on ğ•œ âŠ¤ f s â†” differentiable_on ğ•œ f s âˆ§ cont_diff_on ğ•œ âŠ¤ (Î» (y : E), fderiv_within ğ•œ f s y) s
â¨ (x : Î±), f x âˆ‚Î¼ âˆˆ interior s
set.eq_on â‡‘f â‡‘g â†‘(subgroup.closure s)
(â¨… (i : Î¹), f i) = b
fintype.card â†¥(mul_action.orbit Î± b) * fintype.card â†¥(mul_action.stabilizer Î± b) = fintype.card Î±
x * infi f = â¨… (i : Î¹), x * f i
p3 -áµ¥ p2 - (p3 -áµ¥ p1) = p1 -áµ¥ p2
strict_convex ğ•œ s â†” s.pairwise (Î» (x y : E), âˆ€ â¦ƒa b : ğ•œâ¦„, 0 < a â†’ 0 < b â†’ (a / (a + b)) â€¢ x + (b / (a + b)) â€¢ y âˆˆ interior s)
vector_span k (p '' s) = submodule.span k (has_vsub.vsub (p i) '' (p '' (s  {i})))
spectrum â„‚ â†‘a = coe âˆ˜ complex.re '' spectrum â„‚ â†‘a
algebra.adjoin R (â‹ƒ (f : add_monoid_algebra R M) (H : f âˆˆ S), add_monoid_algebra.of' R M '' â†‘(f.support)) = âŠ¤
e.is_image s t â†’ e.to_local_equiv.source âˆ© â‡‘e â»Â¹' (e.to_local_equiv.target âˆ© t) = e.to_local_equiv.source âˆ© s
sá¶œ âˆˆ f
âˆƒ (U : topological_space.opens â†¥X) (m : x âˆˆ U) (s : â†¥(F.obj (opposite.op U))), â‡‘(F.germ âŸ¨x, mâŸ©) s = t
set.image2 f (g '' s) t = g' '' set.image2 f' s t
lie_submodule.ucs k âŠ¥ â‰¤ Nâ‚
finset.univ.sum (Î» (i : Î¹), âˆ¥x iâˆ¥â‚Š) â‰¤ fintype.card Î¹ â€¢ âˆ¥xâˆ¥â‚Š
finset.centroid k s p = finset.centroid k finset.univ (Î» (x : â†¥ps), â†‘x)
galois_connection (â‡‘order_dual.to_dual âˆ˜ fixing_subgroup M) ((Î» (P : subgroup M), mul_action.fixed_points â†¥P Î±) âˆ˜ â‡‘order_dual.of_dual)
(â¨… (i : Î¹), filter.principal (s i)).has_basis (Î» (t : set Î¹), t.finite) (Î» (t : set Î¹), â‹‚ (i : Î¹) (H : i âˆˆ t), s i)
âˆ® (z : â„‚) in C(c, R), (z - c)â»Â¹ â€¢ f z = (2 * â†‘real.pi * complex.I) â€¢ y
â‡‘Î¼ A = â¨† (K : set Î±) (H : K âŠ† A) (h : is_compact K), â‡‘Î¼ K
tendsto_locally_uniformly (Î» (i : Î¹) (a : Î±), â‡‘(F i) a) â‡‘f p
deriv f c = (2 * â†‘real.pi * complex.I)â»Â¹ â€¢ âˆ® (z : â„‚) in C(c, R), (z - c) ^ -2 â€¢ f z
function.injective â‡‘(â‡‘zsqrtd.lift r)
mv_polynomial.homogeneous_submodule Ïƒ R n = finsupp.supported R R {d : Ïƒ â†’â‚€ â„• | d.support.sum (Î» (i : Ïƒ), â‡‘d i) = n}
has_dist.dist x y = âˆ¥x -áµ¥ yâˆ¥
bdd_below s â†’ bdd_above (f '' s)
continuous_at â‡‘e x
s.sum (Î» (i : Î±), f i) + sá¶œ.sum (Î» (i : Î±), f i) = finset.univ.sum (Î» (i : Î±), f i)
N = âŠ¥
âˆ«â» (x : Î±), âˆ«â» (y : Î²), f x y âˆ‚Î½ âˆ‚Î¼ = âˆ«â» (z : Î± Ã— Î²), f z.fst z.snd âˆ‚Î¼.prod Î½
âˆƒ (Î¹ : Type) [_inst_3 : fintype Î¹], âˆ€ (C : (Î¹ â†’ Î±) â†’ Îº), âˆƒ (l : combinatorics.line Î± Î¹), combinatorics.line.is_mono C l
is_compact s â†” âˆ€ {Î¹ : Type u} (U : Î¹ â†’ set Î±), (âˆ€ (i : Î¹), is_open (U i)) â†’ (s âŠ† â‹ƒ (i : Î¹), U i) â†’ (âˆƒ (t : finset Î¹), s âŠ† â‹ƒ (i : Î¹) (H : i âˆˆ t), U i)
category_theory.forget_enrichment.hom_to W (f â‰« g) = ((Î»_ (ğŸ™_ W)).inv â‰« (category_theory.forget_enrichment.hom_to W f âŠ— category_theory.forget_enrichment.hom_to W g)) â‰« category_theory.e_comp W (category_theory.forget_enrichment.to W X) (category_theory.forget_enrichment.to W Y) (category_theory.forget_enrichment.to W Z)
s =á¶ [l] t â†’ (âˆ€á¶  (x : Î±) in l, x âˆˆ s â†” x âˆˆ t)
isometry â‡‘(algebra_map ğ•œ ğ•œ')
s âŠ† â‹ƒ (i : Î¹), t i
affine_span â„ {p, s.points i} = s.altitude i â†” p â‰  s.points i âˆ§ p âˆˆ affine_span â„ (set.range s.points) âˆ§ p -áµ¥ s.points i âˆˆ ((affine_span â„ (s.points '' â†‘(finset.univ.erase i))).direction)á—®
(finset.Ico 1 (n + 1)).sum (Î» (k : â„•), a ^ k * âˆ¥p.right_inv i kâˆ¥) â‰¤ âˆ¥â†‘(i.symm)âˆ¥ * a + âˆ¥â†‘(i.symm)âˆ¥ * C * (finset.Ico 2 (n + 1)).sum (Î» (k : â„•), (r * (finset.Ico 1 n).sum (Î» (j : â„•), a ^ j * âˆ¥p.right_inv i jâˆ¥)) ^ k)
has_ftaylor_series_up_to_on n (Î» (y : E), (f y, g y)) (Î» (y : E) (k : â„•), (p y k).prod (q y k)) s
âˆ« (z : Î± Ã— Î²) in s Ã—Ë¢ t, f z âˆ‚Î¼.prod Î½ = âˆ« (x : Î±) in s, âˆ« (y : Î²) in t, f (x, y) âˆ‚Î½ âˆ‚Î¼
âˆ« (x : â„), x * (measure_theory.pdf X Â«â„™Â» measure_theory.measure_space.volume x).to_real = âˆ« (x : Î±), X x âˆ‚Â«â„™Â»
âˆ«â» (x : Î±), âˆ«â» (y : Î²), f x y âˆ‚Î½ âˆ‚Î¼ = âˆ«â» (y : Î²), âˆ«â» (x : Î±), f x y âˆ‚Î¼ âˆ‚Î½
N âŠ” I â€¢ N' = N âŠ” J â€¢ N'
â‡‘(f.linear) (p1 -áµ¥ p2) = â‡‘f p1 -áµ¥ â‡‘f p2
[âˆƒ (a : â„) (H : a âˆˆ set.Ioo (-R) R), f =o[filter.at_top] has_pow.pow a, âˆƒ (a : â„) (H : a âˆˆ set.Ioo 0 R), f =o[filter.at_top] has_pow.pow a, âˆƒ (a : â„) (H : a âˆˆ set.Ioo (-R) R), f =O[filter.at_top] has_pow.pow a, âˆƒ (a : â„) (H : a âˆˆ set.Ioo 0 R), f =O[filter.at_top] has_pow.pow a, âˆƒ (a : â„) (H : a < R) (C : â„) (hâ‚€ : 0 < C âˆ¨ 0 < R), âˆ€ (n : â„•), |f n| â‰¤ C * a ^ n, âˆƒ (a : â„) (H : a âˆˆ set.Ioo 0 R) (C : â„) (H : C > 0), âˆ€ (n : â„•), |f n| â‰¤ C * a ^ n, âˆƒ (a : â„) (H : a < R), âˆ€á¶  (n : â„•) in filter.at_top, |f n| â‰¤ a ^ n, âˆƒ (a : â„) (H : a âˆˆ set.Ioo 0 R), âˆ€á¶  (n : â„•) in filter.at_top, |f n| â‰¤ a ^ n].tfae
continuous â‡‘l
âˆ¥x - yâˆ¥ * âˆ¥x - yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ - 2 * â‡‘is_R_or_C.re (has_inner.inner x y) + âˆ¥yâˆ¥ * âˆ¥yâˆ¥
has_strict_fderiv_at (Î» (p : â„ Ã— â„), âˆ« (x : â„) in p.fst..p.snd, f x) ((continuous_linear_map.snd â„ â„ â„).smul_right (f b) - (continuous_linear_map.fst â„ â„ â„).smul_right (f a)) (a, b)
âˆƒ (d : Î±), d â‰  0 âˆ§ âˆ¥d â€¢ xâˆ¥ < Îµ âˆ§ Îµ / âˆ¥câˆ¥ â‰¤ âˆ¥d â€¢ xâˆ¥ âˆ§ âˆ¥dâˆ¥â»Â¹ â‰¤ Îµâ»Â¹ * âˆ¥câˆ¥ * âˆ¥xâˆ¥
p i âˆˆ â‡‘(convex_hull ğ•œ) (p '' s) â†” i âˆˆ s
finsum (Î» (a : Î±), finsum (Î» (H : a âˆˆ â‹ƒ (x : Î¹) (H : x âˆˆ I), t x), f a)) = finsum (Î» (i : Î¹), finsum (Î» (H : i âˆˆ I), finsum (Î» (j : Î±), finsum (Î» (H : j âˆˆ t i), f j))))
(Î» (x : â„), x ^ k) =o[filter.at_top] Î» (x : â„), real.exp (b * x)
âˆƒ (Î± : E), FâŸ®Î±âŸ¯ = âŠ¤
âˆ« (x : â„) in a..b, f' x â€¢ (g âˆ˜ f) x = âˆ« (x : â„) in f a..f b, g x
â‡‘(add_con.ker f) x = â‡‘f â»Â¹' {â‡‘f x}
measure_theory.integrable f (Î¼.prod Î½) â†” (âˆ€áµ (y : Î²) âˆ‚Î½, measure_theory.integrable (Î» (x : Î±), f (x, y)) Î¼) âˆ§ measure_theory.integrable (Î» (y : Î²), âˆ« (x : Î±), âˆ¥f (x, y)âˆ¥ âˆ‚Î¼) Î½
convex_on ğ•œ ((Î» (z : E), c + z) â»Â¹' s) (f âˆ˜ Î» (z : E), c + z)
(quotient.mk '' L.age M).countable
{t : set Î± | measurable_space.generate_measurable s t} = â‹ƒ (i : (quotient.out (cardinal.aleph 1).ord).Î±), measurable_space.generate_measurable_rec s i
subsingleton (A â†’â‚[R] B)
â‡‘(Î¼.prod Î½) s = 0 â†” (Î» (x : Î±), â‡‘Î½ (prod.mk x â»Â¹' s)) =áµ[Î¼] 0
set.eq_on â‡‘f â‡‘g â†‘(â‡‘(first_order.language.substructure.closure L) s)
b â©¿ a â†’ â‡‘order_dual.of_dual a â©¿ â‡‘order_dual.of_dual b
Â¬is_field â†¥(number_field.ring_of_integers K)
(subgroup.map N.subtype â†‘P).normalizer âŠ” N = âŠ¤
dense (quotient.mk '' s)
(â‡‘(dfinsupp.lsum â„•) (Î» (i : Î¹), (p i).subtype)).comp ((dfinsupp.map_range.linear_map (Î» (i : Î¹), linear_map.to_span_singleton R â†¥(p i) âŸ¨v i, _âŸ©)).comp (finsupp_lequiv_dfinsupp R).to_linear_map) = finsupp.total Î¹ N R v
[measure_theory.vadd_invariant_measure G Î± Î¼, âˆ€ (c : G) (s : set Î±), measurable_set s â†’ â‡‘Î¼ (has_vadd.vadd c â»Â¹' s) = â‡‘Î¼ s, âˆ€ (c : G) (s : set Î±), measurable_set s â†’ â‡‘Î¼ (c +áµ¥ s) = â‡‘Î¼ s, âˆ€ (c : G) (s : set Î±), â‡‘Î¼ (has_vadd.vadd c â»Â¹' s) = â‡‘Î¼ s, âˆ€ (c : G) (s : set Î±), â‡‘Î¼ (c +áµ¥ s) = â‡‘Î¼ s, âˆ€ (c : G), measure_theory.measure.map (has_vadd.vadd c) Î¼ = Î¼, âˆ€ (c : G), measure_theory.measure_preserving (has_vadd.vadd c) Î¼ Î¼].tfae
â†‘(H âŠ” N) = â†‘H * â†‘N
â‡‘(s.affine_combination p) w = â‡‘(s.weighted_vsub_of_point p b) w +áµ¥ b
âˆƒá¶  (m : â„•) in filter.at_top, m â‰¡ d [MOD n]
f âˆˆ submodule.span k (â‡‘(monoid_algebra.of k G) '' â†‘(f.support))
add_monoid.is_torsion â†¥H
is_upper_set s â†’ is_lower_set (â‡‘order_dual.to_dual â»Â¹' s)
âˆƒ (t : set Î±) (H : t âŠ† s), t.finite âˆ§ s âŠ† â‹ƒ (x : Î±) (H : x âˆˆ t), metric.ball x e
set.Icc x y  set.univ.pi (Î» (i : Î¹), set.Ioo (x' i) (y' i)) âŠ† (â‹ƒ (i : Î¹), set.Icc x (function.update y i (x' i))) âˆª â‹ƒ (i : Î¹), set.Icc (function.update x i (y' i)) y
(matrix.from_blocks A B C D).det = D.det * (A - (B.mul (â…Ÿ D)).mul C).det
â‡‘(polynomial.aeval f) p = â‡‘(polynomial.aeval f) (p %â‚˜ f.charpoly)
has_inner.inner x (l.sum (Î» (i : Î¹) (a : ğ•œ), a â€¢ v i)) = l.sum (Î» (i : Î¹) (a : ğ•œ), a â€¢ has_inner.inner x (v i))
0 â‰¤ âˆ¥â‡‘(quotient_add_group.mk' S) mâˆ¥
âˆ¥x + yâˆ¥ * âˆ¥x + yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + 2 * â‡‘is_R_or_C.re (has_inner.inner x y) + âˆ¥yâˆ¥ * âˆ¥yâˆ¥
has_fderiv_at â‡‘(f.symm) â†‘(f'.symm) a
cardinal.mk â†¥(set.Ici a) = cardinal.continuum
âˆ€áµ (x : Î±) âˆ‚Î¼, filter.tendsto (Î» (a : set Î±), â‡‘Î¼ (s âˆ© a) / â‡‘Î¼ a) (v.filter_at x) (nhds (s.indicator 1 x))
function.bijective â‡‘(polynomial.gal.gal_action_hom p â„‚)
â‡‘Î¼ (f â»Â¹' s) = 0
âˆ¥â‡‘(continuous_multilinear_map.comp_along_composition p c f) vâˆ¥ â‰¤ âˆ¥fâˆ¥ * finset.univ.prod (Î» (i : fin c.length), âˆ¥p (c.blocks_fun i)âˆ¥) * finset.univ.prod (Î» (i : fin n), âˆ¥v iâˆ¥)
âˆ¥â‡‘innerSL xâˆ¥ = âˆ¥xâˆ¥
âˆƒ (t : â„• â†’ set E) (A : â„• â†’ (E â†’L[â„] F)), (âˆ€ (n : â„•), is_closed (t n)) âˆ§ (s âŠ† â‹ƒ (n : â„•), t n) âˆ§ (âˆ€ (n : â„•), approximates_linear_on f (A n) (s âˆ© t n) (r (A n))) âˆ§ (s.nonempty â†’ âˆ€ (n : â„•), âˆƒ (y : E) (H : y âˆˆ s), A n = f' y)
âˆ¥f x - f aâˆ¥ â‰¤ C * (x - a)
a â‰  âŠ¤
function.surjective â‡‘(c.lift f h)
summable (Î» (i : Î¹), f i * g i) âˆ§ âˆ‘' (i : Î¹), f i * g i â‰¤ (âˆ‘' (i : Î¹), f i ^ p) ^ (1 / p) * (âˆ‘' (i : Î¹), g i ^ q) ^ (1 / q)
s.pairwise âŠ¥ â†’ s.subsingleton
(Î» (n : â„•), â†‘n ^ k * râ‚ ^ n) =o[filter.at_top] Î» (n : â„•), râ‚‚ ^ n
linear_independent R v â†” (â‡‘(linear_map.lsum R (Î» (i : Î¹), R) â„•) (Î» (i : Î¹), linear_map.id.smul_right (v i))).ker = âŠ¥
R âŠ“ S âˆˆ â‡‘J X
L.age (first_order.language.direct_limit G f) = â‹ƒ (i : Î¹), L.age (G i)
witt_vector.is_polyâ‚‚ p (Î» (_x : Type u_1) (_x_1 : comm_ring _x), has_add.add)
submonoid.map f (submonoid.closure s) = submonoid.closure (â‡‘f '' s)
âˆƒ (c : â†¥S), x * â†‘((f.sec (f.mk' x y)).snd) * â†‘c = (f.sec (f.mk' x y)).fst * â†‘y * â†‘c
(âˆ€ (u : set E), u âŠ‡ v â†’ orthonormal ğ•œ coe â†’ u = v) â†” (submodule.span ğ•œ v)á—® = âŠ¥
âˆƒ (C : â„), 0 < C âˆ§ âˆ€ (m : Î  (i : Î¹), E i), âˆ¥â‡‘f mâˆ¥ â‰¤ C * finset.univ.prod (Î» (i : Î¹), âˆ¥m iâˆ¥)
â‡‘is_R_or_C.re (has_inner.inner x y) = (âˆ¥x + yâˆ¥ * âˆ¥x + yâˆ¥ - âˆ¥xâˆ¥ * âˆ¥xâˆ¥ - âˆ¥yâˆ¥ * âˆ¥yâˆ¥) / 2
(F.left_derived 0).map f â‰« category_theory.abelian.functor.left_derived_zero_to_self_app F Q = category_theory.abelian.functor.left_derived_zero_to_self_app F P â‰« F.map f
strict_convex ğ•œ ((Î» (x : E), x + z) â»Â¹' s)
p1 -áµ¥ p2 âˆˆ vector_span k s
f =áµ[Î¼] g
â‡‘(algebra_map K E) (â‡‘(algebra.norm K) x) = finset.univ.prod (Î» (Ïƒ : L â†’â‚[K] E), â‡‘Ïƒ x)
âˆƒ! (F : G â†’* H), âˆ€ (a : is_free_group.generators G), â‡‘F (is_free_group.of a) = f a
â‡‘measure_theory.measure_space.volume {Ï‰ : Î© | c â‰¤ |X Ï‰ - âˆ« (a : Î©), X a|} â‰¤ ennreal.of_real (probability_theory.variance X measure_theory.measure_space.volume / c ^ 2)
measurable_set (f '' s)
measure_theory.ae_strongly_measurable f Î¼ â†” ae_measurable f Î¼ âˆ§ âˆƒ (t : set Î²), topological_space.is_separable t âˆ§ âˆ€áµ (x : Î±) âˆ‚Î¼, f x âˆˆ t
â‡‘(s.affine_combination p) w = â‡‘(s.weighted_vsub_of_point p (classical.choice add_torsor.nonempty)) w +áµ¥ classical.choice add_torsor.nonempty
has_Sup.Sup (coe '' t) âˆˆ s
real.cos (inner_product_geometry.angle x y) = has_inner.inner x y / (âˆ¥xâˆ¥ * âˆ¥yâˆ¥)
has_inner.inner (â‡‘(finsupp.total Î¹ E ğ•œ v) lâ‚) (â‡‘(finsupp.total Î¹ E ğ•œ v) lâ‚‚) = lâ‚‚.sum (Î» (i : Î¹) (y : ğ•œ), â‡‘(star_ring_end ğ•œ) (â‡‘lâ‚ i) * y)
v âˆˆ s.direction â†” âˆƒ (p2 : P) (H : p2 âˆˆ s), v = p2 -áµ¥ p
disjoint (t x) (â¨† (i : Î¹) (H : i âˆˆ y), t i)
algebra.finite_presentation R (A â§¸ I)
âˆ€áµ (x : Î±) âˆ‚Î¼, âˆ€áµ (y : Î²) âˆ‚Î½, p (x, y)
has_compact_support f â†’ has_compact_support (Î» (x : Î±), âˆ¥f xâˆ¥)
(Î» (n : â„•), âˆ¥p nâˆ¥ * â†‘r ^ n) =o[filter.at_top] Î» (_x : â„•), 1
filter.tendsto (Î» (A : â„), âˆ« (x : Î±), probability_theory.truncation f A x âˆ‚Î¼) filter.at_top (nhds (âˆ« (x : Î±), f x âˆ‚Î¼))
âˆƒ (t : set P), s âŠ† t âˆ§ affine_independent k (Î» (p : â†¥t), â†‘p) âˆ§ affine_span k t = âŠ¤
concave_on ğ•œ (â‡‘g â»Â¹' s) (f âˆ˜ â‡‘g)
f â‰« h = g â‰« h
âˆ¥vâˆ¥ â‰¤ âˆ¥uâˆ¥ + âˆ¥u - vâˆ¥
âˆ« (x : Î±), âˆ« (y : Î²), (f + g) (x, y) âˆ‚Î½ âˆ‚Î¼ = âˆ« (x : Î±), âˆ« (y : Î²), f (x, y) âˆ‚Î½ âˆ‚Î¼ + âˆ« (x : Î±), âˆ« (y : Î²), g (x, y) âˆ‚Î½ âˆ‚Î¼
approximates_linear_on â‡‘((hf.to_local_equiv hc).symm) â†‘(f'.symm) (f '' s) (âˆ¥â†‘(f'.symm)âˆ¥â‚Š * (âˆ¥â†‘(f'.symm)âˆ¥â‚Šâ»Â¹ - c)â»Â¹ * c)
set.image2 f s t = â‹ƒ (i : Î±) (H : i âˆˆ s) (j : Î²) (H : j âˆˆ t), {f i j}
monoid.is_torsion_free â†¥H
transitive (Î» (a b : S), âˆƒ (c : S), add_semiconj_by c a b)
group.nilpotency_class â†¥H â‰¤ group.nilpotency_class G
algebraic_geometry.identity_to_Î“_Spec.app (algebraic_geometry.Spec.to_LocallyRingedSpace.obj (opposite.op R)) â‰« algebraic_geometry.Spec.to_LocallyRingedSpace.map (algebraic_geometry.Spec_Î“_identity.inv.app R).op = ğŸ™ ((ğŸ­ algebraic_geometry.LocallyRingedSpace).obj (algebraic_geometry.Spec.to_LocallyRingedSpace.obj (opposite.op R)))
category_theory.presieve.is_sheaf_for P (category_theory.presieve.singleton (ğŸ™ X))
convex ğ•œ (â‡‘f '' s)
coe â»Â¹' {â†‘x} = connected_component x
is_compact (closure (coe_fn '' s))
continuous â‡‘l â†” is_closed â†‘(l.ker)
3 âˆ£ n â†” 3 âˆ£ (10.digits n).sum
âˆ® (z : â„‚) in C(c, R), (z - w) ^ n = 0
s.Î¹.app j â‰« k = s.Î¹.app j â‰« l
category_theory.is_pullback 0 0 (ğŸ™ X) 0
p i âˆˆ affine_span k (p '' s) â†” i âˆˆ s
function.surjective â‡‘(c.lift f h)
orthonormal â„ â‡‘(orientation.fin_orthonormal_basis hn h x)
f â‰« g = f â‰« h
has_strict_deriv_at f f' x â†’ has_strict_fderiv_at f (1.smul_right f') x
X.to_Î“_Spec_fun â»Â¹' (prime_spectrum.basic_open r).val = (X.to_RingedSpace.basic_open r).val
algebra.discr K â‡‘b â‰  0
s.sum (Î» (i : Î¹), w i â€¢ (pâ‚ i -áµ¥ pâ‚‚ i)) = â‡‘(s.weighted_vsub_of_point pâ‚ b) w - â‡‘(s.weighted_vsub_of_point pâ‚‚ b) w
s.prod = âŠ¥ â†” âˆƒ (I : ideal R) (H : I âˆˆ s), I = âŠ¥
âˆƒ (Îµ : nnreal), 0 < Îµ âˆ§ âˆƒ (E : set Î±), measurable_set E âˆ§ 0 < â‡‘Î½ E âˆ§ 0.restrict E â‰¤ (Î¼.to_signed_measure - (Îµ â€¢ Î½).to_signed_measure).restrict E
(âˆ‘' (x : Î²), f x) * âˆ‘' (y : Î³), g y = âˆ‘' (z : Î² Ã— Î³), f z.fst * g z.snd
module.End.has_eigenvector â†‘T â†‘((Î» (x : E), T.re_apply_inner_self x / âˆ¥xâˆ¥ ^ 2) xâ‚€) xâ‚€
module.End.eigenspace (linear_map.restrict f hfp) Î¼ = âŠ¥
pairwise (disjoint on Î» (n : Î±), set.Ioo (f n) (f (order.pred n)))
b â‰  âŠ¥
f =á¶ [l] g â†’ â†‘f = â†‘g
function.surjective â‡‘(algebra_map R L)
hwf.fix F x = F x (Î» (y : Î±) (h : r y x), hwf.fix F y)
âˆ« (x : Î±), F (âˆ« (y : Î²), f (x, y) - g (x, y) âˆ‚Î½) âˆ‚Î¼ = âˆ« (x : Î±), F (âˆ« (y : Î²), f (x, y) âˆ‚Î½ - âˆ« (y : Î²), g (x, y) âˆ‚Î½) âˆ‚Î¼
s.prod (Î» (a : Î±), f a) < âŠ¤
is_greatest ((Î» (g : Î¹ â†’ nnreal), s.sum (Î» (i : Î¹), f i * g i)) '' {g : Î¹ â†’ nnreal | s.sum (Î» (i : Î¹), g i ^ q) â‰¤ 1}) (s.sum (Î» (i : Î¹), f i ^ p) ^ (1 / p))
â‡‘Î¼ A = â¨† (K : set Î±) (H : K âŠ† A) (h : is_closed K), â‡‘Î¼ K
function.injective â‡‘f
(Î» (k : ğ•œ), polynomial.eval k p) '' spectrum ğ•œ a âŠ† spectrum ğ•œ (â‡‘(polynomial.aeval a) p)
continuous_within_at (Î» (x : X), âˆ« (t : â„) in a..b, F x t âˆ‚Î¼) s xâ‚€
â‡‘((ext_chart_at I x).symm) â»Â¹' t âˆˆ nhds (â‡‘(ext_chart_at I x) x)
summable (Î» (i : Î¹), (f i + g i) ^ p) âˆ§ (âˆ‘' (i : Î¹), (f i + g i) ^ p) ^ (1 / p) â‰¤ (âˆ‘' (i : Î¹), f i ^ p) ^ (1 / p) + (âˆ‘' (i : Î¹), g i ^ p) ^ (1 / p)
group.nilpotency_class (G â§¸ H) â‰¤ group.nilpotency_class G
âˆ¥xâˆ¥ = âˆ¥â†‘xâˆ¥
âˆƒ (K : subgroup G), fintype.card â†¥K = p ^ m âˆ§ H â‰¤ K
is_fraction_ring â†¥(integral_closure A L) L
vector_span k (set.range p) = submodule.span k (set.range (Î» (i : Î¹), p i -áµ¥ p i0))
(Î» (t : Î¹), âˆ« (x : â„) in u t..v t, f x âˆ‚Î¼ - (â‡‘Î¼ (set.Ioc (u t) (v t))).to_real â€¢ c) =o[lt] Î» (t : Î¹), (â‡‘Î¼ (set.Ioc (u t) (v t))).to_real
âŠ¤.direction = âŠ¤
âˆƒ (C : â„) (H : C > 0), âˆ€ â¦ƒx : Î±â¦„, g'' x â‰  0 â†’ âˆ¥f xâˆ¥ â‰¤ C * âˆ¥g'' xâˆ¥
(Î» (t : R), ring.inverse (â†‘x + t) - â†‘xâ»Â¹ + â†‘xâ»Â¹ * t * â†‘xâ»Â¹) =O[nhds 0] Î» (t : R), âˆ¥tâˆ¥ ^ 2
star_convex ğ•œ x ((Î» (x : E), x + z) â»Â¹' s)
f âˆˆ algebra.adjoin R (â‡‘(monoid_algebra.of R M) '' â†‘(f.support))
filter.tendsto (Î» (Ï€ : box_integral.tagged_prepartition I Ã— box_integral.tagged_prepartition I), (box_integral.integral_sum f vol Ï€.fst, box_integral.integral_sum f vol Ï€.snd)) ((l.to_filter I).prod (l.to_filter I) âŠ“ filter.principal {Ï€ : box_integral.tagged_prepartition I Ã— box_integral.tagged_prepartition I | Ï€.fst.Union = Ï€.snd.Union}) (uniformity F)
u x âŠ† â‹ƒ (x : Î±) (H : x âˆˆ s), u x
v âˆˆ Ká—® â†” âˆ€ (u : E), u âˆˆ K â†’ has_inner.inner u v = 0
(â‹‚ (i : Î¹), s i) âŠ† t
subsingleton â†¥s â†” s.subsingleton
f (has_Sup.Sup s) = has_Sup.Sup (f '' s)
âˆ¥dslope f c zâˆ¥ â‰¤ Râ‚‚ / Râ‚
(mâ‚ âŠ” mâ‚‚).trim = mâ‚.trim âŠ” mâ‚‚.trim
U âˆˆ gal_basis K L â†” U âˆˆ subgroup.carrier '' fixed_by_finite K L
f = category_theory.eq_to_hom h â‰« g â‰« category_theory.eq_to_hom _ â†” f == g
finite_dimensional.finrank k â†¥(vector_span k â†‘(finset.image p s)) = n
u / v * v =á¶ [l] u
âˆƒ (U : set Î±) (H : U âˆˆ nhds_within x {x}á¶œ), disjoint U s
p1 -áµ¥ p2 = 0 â†” p1 = p2
âˆ«â» (a : Î±), g a âˆ‚Î¼.with_density f = âˆ«â» (a : Î±), (f * g) a âˆ‚Î¼
f âˆˆ submodule.span k (â‡‘(add_monoid_algebra.of k G) '' â†‘(f.support))
â‡‘h (f.sum g) = f.sum (Î» (a : Î±) (b : M), â‡‘h (g a b))
âˆ¥f + gâˆ¥ â‰¤ âˆ¥fâˆ¥ + âˆ¥gâˆ¥
measure_theory.ae_strongly_measurable (Î» (x : Î±), âˆ« (y : Î²), f (x, y) âˆ‚Î½) Î¼
âˆƒ (t : fin n â†’ fin âŒˆ1 / ÎµâŒ‰â‚Š), âˆ€ (iâ‚€ iâ‚ : fin n), t iâ‚€ = t iâ‚ â†’ â†‘|A iâ‚ % b - A iâ‚€ % b| < |b| â€¢ Îµ
â‡‘Î¼ (â‡‘f â»Â¹' s) = ennreal.of_real |(â‡‘linear_map.det â†‘f)â»Â¹| * â‡‘Î¼ s
e.to_local_equiv.source âˆ© â‡‘e â»Â¹' interior s = e.to_local_equiv.source âˆ© interior (â‡‘e â»Â¹' s)
char_p (R â§¸ I) p
measure_theory.condexp m Î¼ (s.indicator f) =áµ[Î¼] s.indicator (measure_theory.condexp m Î¼ f)
(â¨† (i : Î¹), f i) = b
concave_on ğ•œ s (f âŠ“ g)
category_theory.strong_mono (f â‰« g)
has_edist.edist (f n) a â‰¤ âˆ‘' (m : â„•), d (n + m)
â‡‘Î¼ (â‡‘f â»Â¹' s) = ennreal.of_real |â‡‘linear_map.det â†‘(f.symm)| * â‡‘Î¼ s
(category_theory.category_of_elements.from_costructured_arrow F).right_op â‹™ category_theory.category_of_elements.to_costructured_arrow F = ğŸ­ (category_theory.costructured_arrow category_theory.yoneda F)
âˆ¥fâˆ¥ â‰¤ M
(Î» (x : Î±), x) '' s = s
f =O[l] g' â†” âˆ€á¶  (c : â„) in filter.at_top, âˆ€á¶  (x : Î±) in l, âˆ¥f xâˆ¥ â‰¤ c * âˆ¥g' xâˆ¥
(â¨… (i : Î¹), (K i)á—®) = (supr K)á—®
M ^ k = â‡‘(polynomial.aeval M) (polynomial.X ^ k %â‚˜ M.charpoly)
affine_span k (set.range p) = âŠ¤ â†” fintype.card Î¹ = finite_dimensional.finrank k V + 1
mul_action.fixed_points â†¥(P âŠ” Q) Î± = mul_action.fixed_points â†¥P Î± âˆ© mul_action.fixed_points â†¥Q Î±
set.center MË£ = coe â»Â¹' set.center M
â‡‘Î¼ (â‹ƒ (i : Î¹) (H : i âˆˆ I), s i) = I.sum (Î» (i : Î¹), â‡‘Î¼ (s i))
âˆ¥x + yâˆ¥ ^ 2 = âˆ¥xâˆ¥ ^ 2 + 2 * â‡‘is_R_or_C.re (has_inner.inner x y) + âˆ¥yâˆ¥ ^ 2
has_inner.inner x y / (âˆ¥xâˆ¥ * âˆ¥yâˆ¥) = 1 â†” x â‰  0 âˆ§ âˆƒ (r : â„), 0 < r âˆ§ y = r â€¢ x
âˆƒ (f : bump_covering Î¹ X s), (âˆ€ (i : Î¹), p â‡‘(â‡‘f i)) âˆ§ f.is_subordinate U
âˆƒ (F : circle_deg1_lift), function.semiconj â‡‘F â‡‘fâ‚ â‡‘fâ‚‚
measure_theory.measure.map f ((Î¼.restrict s).with_density (Î» (x : E), ennreal.of_real |(f' x).det|)) = Î¼.restrict (f '' s)
(has_Inf.Inf S).to_setoid = has_Inf.Inf (con.to_setoid '' S)
(âˆ‘' (n : â„•), f n) * âˆ‘' (n : â„•), g n = âˆ‘' (n : â„•), (finset.range (n + 1)).sum (Î» (k : â„•), f k * g (n - k))
âˆƒ (s : C) (Î± : kâ‚ âŸ¶ s) (Î² : l âŸ¶ s) (Î³ : kâ‚‚ âŸ¶ s), fâ‚ â‰« Î± = gâ‚ â‰« Î² âˆ§ fâ‚‚ â‰« Î± = fâ‚ƒ â‰« Î³ âˆ§ fâ‚„ â‰« Î³ = gâ‚‚ â‰« Î²
has_dist.dist p1 p3 = |has_dist.dist p1 p2 - has_dist.dist p3 p2| â†” euclidean_geometry.angle p1 p2 p3 = 0
âˆƒ (f : E â†’ â„), f =á¶ [nhds x] 1 âˆ§ (âˆ€ (y : E), f y âˆˆ set.Icc 0 1) âˆ§ cont_diff â„ âŠ¤ f âˆ§ has_compact_support f âˆ§ tsupport f âŠ† s
s.prod (Î» (i : Î¹), f i) < âŠ¤
â‡‘(e.det) â‡‘(e.units_smul w) = finset.univ.prod (Î» (i : Î¹), â†‘(w i))
category_theory.limits.pullback.lift category_theory.limits.pullback.snd (category_theory.limits.pullback.fst â‰« algebraic_geometry.Scheme.pullback.p2 ğ’° f g) _ â‰« (algebraic_geometry.Scheme.pullback.gluing ğ’° f g).Î¹ i = category_theory.limits.pullback.fst
finite_dimensional k â†¥(vector_span k s)
f '' add_monoid.closure s = add_monoid.closure (f '' s)
fintype.card Î² = finset.univ.sum (Î» (Ï‰ : quotient (mul_action.orbit_rel Î± Î²)), fintype.card Î± / fintype.card â†¥(mul_action.stabilizer Î± Ï‰.out'))
function.surjective â‡‘f
s Ã—Ë¢ t âŠ† sâ‚ Ã—Ë¢ tâ‚ â†” s âŠ† sâ‚ âˆ§ t âŠ† tâ‚ âˆ¨ s = âˆ… âˆ¨ t = âˆ…
measure_theory.integrable_on (Î» (x : â„), âˆ¥real.exp (-x) * real.log x * x ^ (s - 1)âˆ¥) (set.Ioi 0) measure_theory.measure_space.volume
dense (â‹‚â‚€ S)
(Î» (t : Î¹), âˆ« (x : â„) in u t..v t, f x âˆ‚Î¼ - âˆ« (x : â„) in u t..v t, c âˆ‚Î¼) =o[lt] Î» (t : Î¹), âˆ« (x : â„) in u t..v t, 1 âˆ‚Î¼
(A.minor â‡‘e â‡‘e).det = A.det
âˆ‘' (n : â„•), â†‘n * r ^ n = r / (1 - r) ^ 2
X.Ïƒ (â‡‘fin.cast_succ j) â‰« X.Î´ i.succ = X.Î´ i â‰« X.Ïƒ j
has_Inf.Inf (s âˆª t) = has_Inf.Inf s âŠ“ has_Inf.Inf t
asymptotics.is_O_with c l f' g â†’ asymptotics.is_O_with c l (Î» (x : Î±), âˆ¥f' xâˆ¥) g
submodule.span ğ•œ (gram_schmidt ğ•œ f '' set.Iio c) = submodule.span ğ•œ (f '' set.Iio c)
(â¨† (i : Î¹) (h : p i), S i) = ((â‡‘(dfinsupp.lsum â„•) (Î» (i : Î¹), (S i).subtype)).comp (dfinsupp.filter_linear_map R (Î» (i : Î¹), â†¥(S i)) p)).range
complete_lattice.independent p â†” function.injective â‡‘(dfinsupp.sum_add_hom (Î» (i : Î¹), (p i).subtype))
(s1 âŠ” s2).direction = s1.direction âŠ” s2.direction âŠ” submodule.span k {p2 -áµ¥ p1}
cont_mdiff (model_with_corners_self â„ â„) (model_with_corners_self â„ (euclidean_space â„ (fin 1))) âŠ¤ â‡‘exp_map_circle
(âˆ€áµ (x : Î±) âˆ‚Î¼.restrict s, p x) â†” âˆ€áµ (x : Î±) âˆ‚Î¼.restrict t, p x
f.srange = âŠ¤
set.Icc x z  set.univ.pi (Î» (i : Î¹), set.Ioc (y i) (z i)) âŠ† â‹ƒ (i : Î¹), set.Icc x (function.update z i (y i))
âˆ¥x - yâˆ¥ = âˆ¥xâˆ¥ + âˆ¥yâˆ¥
polish_space â†¥s
is_closed_map â‡‘f
lipschitz_with âŸ¨âˆ¥fâˆ¥, _âŸ© â‡‘f
|b - x| â‰¤ |b - a|
bornology.is_bounded s â†’ bornology.is_cobounded sá¶œ
category_theory.limits.limit.pre F E = (category_theory.limits.limit.iso_limit_cone t).hom â‰« s.is_limit.lift (category_theory.limits.cone.whisker E t.cone) â‰« (category_theory.limits.limit.iso_limit_cone s).inv
continuous â‡‘f
(â‹ƒ (j : Î¹'), â‹‚ (i : Î¹), s i j) = â‹‚ (i : Î¹), â‹ƒ (j : Î¹'), s i j
finset.univ.sum (Î» (i : Î¹), âˆ¥x iâˆ¥) â‰¤ fintype.card Î¹ â€¢ âˆ¥xâˆ¥
âˆƒ (a : Î±), cardinal.mk â†¥(f â»Â¹' {a}) = cardinal.mk Î²
âˆ« (x : Î±), f x âˆ‚Î¼ = I
â‡‘h (f.prod g) = f.prod (Î» (a : Î±) (b : M), â‡‘h (g a b))
((Î» (x : Î±), 1) =O[l] Î» (x : Î±), real.exp (f x)) â†” filter.is_bounded_under ge l f
âˆƒ (N : T.Model), Îº.lift â‰¤ cardinal.mk â†¥N
âˆ¥xâˆ¥ = âˆ¥â†‘xâˆ¥
âˆƒ (g : E â†’L[â„] â„), (âˆ€ (x : â†¥p), â‡‘g â†‘x = â‡‘f x) âˆ§ âˆ¥gâˆ¥ = âˆ¥fâˆ¥
âˆ¥fâˆ¥ = 0 â†” f = 0
S = âŠ¥ âˆ¨ âˆƒ (x : M) (H : x âˆˆ S), x â‰  0
âˆ¥dGamma_integrand t xâˆ¥ â‰¤ dGamma_integrand_real s1 x + dGamma_integrand_real s2 x
finite_dimensional.finrank R (Î¹ â†’â‚€ R) = fintype.card Î¹
âˆƒ (V : open_subgroup G), â†‘V Ã—Ë¢ â†‘V âŠ† U
(m âˆˆ â¨† (i : Î¹), p i) â†” âˆƒ (s : finset Î¹), m âˆˆ â¨† (i : Î¹) (H : i âˆˆ s), p i
f = â‡‘f â‡‘e â€¢ e.det
x âŠ“ y âˆˆ F
cont_diff ğ•œ âŠ¤ â‡‘(equiv.prod_assoc E F G)
âˆƒ (C : â„) (H : C > 0), âˆ€ (y : F), âˆƒ (x : E), â‡‘f x = y âˆ§ âˆ¥xâˆ¥ â‰¤ C * âˆ¥yâˆ¥
measurable_set (f '' s)
â‡‘(s.weighted_vsub_of_point (Î» (_x : Î¹), p) b) w = s.sum (Î» (i : Î¹), w i) â€¢ (p -áµ¥ b)
(âˆ€ (g : G) (A : set G), measurable_set A â†’ â‡‘Î¼ ((Î» (h : G), h + g) â»Â¹' A) = â‡‘Î¼ A) â†” Î¼.is_add_right_invariant
(b.to_matrix â‡‘b').mul (b'.to_matrix b'') = b.to_matrix b''
category_theory.eq_to_hom _ â‰« C.d i' j = C.d i j
âˆ¥f zâˆ¥ â‰¤ C
v âˆˆ s.direction â†” âˆƒ (p1 : P) (H : p1 âˆˆ s) (p2 : P) (H : p2 âˆˆ s), v = p1 -áµ¥ p2
affine_span k s = âŠ¤ â†” vector_span k s = âŠ¤
first_order.language.Structure.cg L M â†” âˆƒ (S : set M), S.countable âˆ§ â‡‘(first_order.language.substructure.closure L) S = âŠ¤
measure_theory.integrable_on (Î» (x : â„), â†‘(real.exp (-x)) * â†‘(real.log x) * â†‘x ^ (s - 1)) (set.Ioi 0) measure_theory.measure_space.volume âˆ§ has_deriv_at complex.Gamma_integral (âˆ« (x : â„) in set.Ioi 0, â†‘(real.exp (-x)) * â†‘(real.log x) * â†‘x ^ (s - 1)) s
y âˆˆ omega_limit f Ï• s â†” âˆ€ (n : set Î²), n âˆˆ nhds y â†’ (âˆƒá¶  (t : Ï„) in f, (Ï• t '' s âˆ© n).nonempty)
(submodule.span â„‚ (set.range fourier)).topological_closure = âŠ¤
(lower_bounds s âˆ© t).nonempty â†’ bdd_below (f '' s)
âˆ€á¶  (Î´ : nnreal) in nhds_within 0 (set.Ioi 0), âˆ€ (s : set E) (f : E â†’ E), approximates_linear_on f A s Î´ â†’ â‡‘Î¼ (f '' s) â‰¤ â†‘m * â‡‘Î¼ s
finite_dimensional.finrank K â†¥(submodule.map f p) â‰¤ finite_dimensional.finrank K â†¥p
p -áµ¥ p1 = p -áµ¥ p2 â†” p1 = p2
âˆ¥x + yâˆ¥ â‰¤ âˆ¥xâˆ¥ + âˆ¥yâˆ¥
(x â¨¯ y) = x âŠ“ y
v +áµ¥ p âˆˆ s â†” v âˆˆ s.direction
A.topological_closure = âŠ¤
(fundamental_groupoid.fundamental_groupoid_functor.map f).map âŸ¦pâŸ§ == (fundamental_groupoid.fundamental_groupoid_functor.map g).map âŸ¦qâŸ§
(category_theory.subobject.pullback g).obj (fâ‚ âŠ“ fâ‚‚) = (category_theory.subobject.pullback g).obj fâ‚ âŠ“ (category_theory.subobject.pullback g).obj fâ‚‚
homotopy.null_homotopic_map hom â‰« g = homotopy.null_homotopic_map (Î» (i j : Î¹), hom i j â‰« g.f j)
(finset.filter (Î» (i : â„•), j < â†‘âŒŠc ^ iâŒ‹â‚Š) (finset.range N)).sum (Î» (i : â„•), 1 / â†‘âŒŠc ^ iâŒ‹â‚Š ^ 2) â‰¤ c ^ 5 * (c - 1)â»Â¹ ^ 3 / j ^ 2
cardinal.mk Î¹ â‰¤ â†‘(fintype.card â†¥w)
vector_span k {p} = âŠ¥
âˆ¥-xâˆ¥ = âˆ¥xâˆ¥
is_R_or_C.abs (has_inner.inner x y) â‰¤ âˆ¥xâˆ¥ * âˆ¥yâˆ¥
(â¨† (i : Î¹), A i) = (direct_sum.coe_alg_hom A).range.to_submodule
(â‡‘â¨… (i : Î¹) (H : i âˆˆ I), m i) s = â¨… (t : â„• â†’ set Î±) (h2 : s âŠ† set.Union t), âˆ‘' (n : â„•), â¨… (i : Î¹) (H : i âˆˆ I), â‡‘(m i) (t n)
âˆ¥x - yâˆ¥ ^ 2 = âˆ¥xâˆ¥ ^ 2 - 2 * â‡‘is_R_or_C.re (has_inner.inner x y) + âˆ¥yâˆ¥ ^ 2
âˆ« (x : G), f x âˆ‚Î¼ = 0
fderiv â„ (Î» (p : â„ Ã— â„), âˆ« (x : â„) in p.fst..p.snd, f x) (a, b) = (continuous_linear_map.snd â„ â„ â„).smul_right (f b) - (continuous_linear_map.fst â„ â„ â„).smul_right (f a)
category_theory.sieve.generate R = âŠ¤
(â‹‚ (i : Î¹'), s i) = â‹‚ (t : finset (plift Î¹')) (i : plift Î¹') (H : i âˆˆ t), s i.down
bdd_below s â†’ bdd_below (f '' s)
(Top.presheaf.covering_of_presieve.first_obj_iso_pi_opens F U R).hom â‰« category_theory.limits.pi.Ï€ (Î» (i : Î£ (V : topological_space.opens â†¥X), {f // R f}), F.obj (opposite.op (Top.presheaf.covering_of_presieve U R i))) f = category_theory.limits.pi.Ï€ (Î» (f : Î£ (V : topological_space.opens â†¥X), {f // R f}), F.obj (opposite.op f.fst)) f
âˆ¥x + yâˆ¥ * âˆ¥x + yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + 2 * has_inner.inner x y + âˆ¥yâˆ¥ * âˆ¥yâˆ¥
category_theory.idempotents.to_karoubi (J â¥¤ C) â‹™ category_theory.idempotents.karoubi_functor_category_embedding J C = (category_theory.whiskering_right J C (category_theory.idempotents.karoubi C)).obj (category_theory.idempotents.to_karoubi C)
â‡‘(s.weighted_vsub p) wâ‚ +áµ¥ â‡‘(s.affine_combination p) wâ‚‚ = â‡‘(s.affine_combination p) (wâ‚ + wâ‚‚)
(affine_span k (has_insert.insert p2 â†‘s)).direction = submodule.span k {p2 -áµ¥ p1} âŠ” s.direction
s.countable â†’ (complex.exp â»Â¹' s).countable
tendsto_locally_uniformly_on F f p s â†” âˆ€ (Îµ : â„), Îµ > 0 â†’ âˆ€ (x : Î²), x âˆˆ s â†’ (âˆƒ (t : set Î²) (H : t âˆˆ nhds_within x s), âˆ€á¶  (n : Î¹) in p, âˆ€ (y : Î²), y âˆˆ t â†’ has_dist.dist (f y) (F n y) < Îµ)
âˆ¥fâˆ¥ â‰¤ C
metric.Hausdorff_dist (Î¦ '' s) (Î¦ '' t) = metric.Hausdorff_dist s t
cont_mdiff (model_with_corners_self â„ (euclidean_space â„ (fin n))) (model_with_corners_self â„ (euclidean_space â„ (fin n))) âŠ¤ (Î» (x : â†¥(metric.sphere 0 1)), -x)
(â¨† (Î¼ : K) (k : â„•), â‡‘(f.generalized_eigenspace Î¼) k) = âŠ¤
filter.tendsto f filter.at_top (nhds b) â†” âˆ€ (Îµ : â„), 0 < Îµ â†’ (âˆƒ (N : Î±), âˆ€ (n : Î±), N â‰¤ n â†’ âˆ¥f n - bâˆ¥ < Îµ)
âˆ‘' (i : â„•), m (â¨† (b : Î³) (H : b âˆˆ encodable.decodeâ‚‚ Î³ i), s b) = âˆ‘' (b : Î³), m (s b)
l = âŠ¤
simplex_category.Î´ (â‡‘fin.cast_succ i) â‰« simplex_category.Ïƒ i = ğŸ™ (simplex_category.mk n)
measure_theory.measure.map â‡‘(quotient_group.mk' Î“) (Î¼.restrict ğ“•) = â‡‘Î¼ (ğ“• âˆ© â‡‘(quotient_group.mk' Î“) â»Â¹' â†‘K) â€¢ measure_theory.measure.haar_measure K
âˆ« (x : Î±), s.indicator f x âˆ‚Î¼ = âˆ« (x : Î±) in s, f x âˆ‚Î¼
i.hom â‰« sq.right â‰« p.inv = sq.left
âˆ€á¶  (y : Î±) in nhds a, f =á¶ [nhds y] g
|has_inner.inner x y| â‰¤ âˆ¥xâˆ¥ * âˆ¥yâˆ¥
âˆ¥f wâˆ¥ = âˆ¥f zâˆ¥
smooth I (I.prod (model_with_corners_self ğ•œ E')) (show M â†’ Z.to_topological_vector_bundle_core.total_space, from Î» (x : M), âŸ¨x, vâŸ©)
âˆ« (x : â„) in a..b, f' x = f b - f a
âˆ«â» (z : Î± Ã— Î²), f z âˆ‚Î¼.prod Î½ = âˆ«â» (y : Î²), âˆ«â» (x : Î±), f (x, y) âˆ‚Î¼ âˆ‚Î½
â†‘T.map (c.Î¹.app j) â‰« category_theory.monad.forget_creates_colimits.lambda c t = (D.obj j).a â‰« c.Î¹.app j
âˆƒ (b : â†¥M), is_localization.is_integer R (a * â‡‘(algebra_map R S) â†‘b)
function.surjective â‡‘(S.normed_mk)
1.update_row i (1 i + c â€¢ 1 j) = matrix.transvection i j c
{a : cardinal | âˆƒ {Î¹ : Type u} (f : Î¹ â†’ ordinal), ordinal.lsub f = o âˆ§ cardinal.mk Î¹ = a}.nonempty
S.to_submodule * T.to_submodule = (S âŠ” T).to_submodule
f =áµ[Î½] Î¼.rn_deriv Î½
cont_mdiff_within_at I I' n f s x â†” continuous_within_at f s x âˆ§ cont_diff_within_at ğ•œ n (â‡‘(ext_chart_at I' (f x)) âˆ˜ f âˆ˜ â‡‘((ext_chart_at I x).symm)) ((ext_chart_at I x).target âˆ© â‡‘((ext_chart_at I x).symm) â»Â¹' (s âˆ© f â»Â¹' (ext_chart_at I' (f x)).source)) (â‡‘(ext_chart_at I x) x)
â‡‘T v âˆˆ (module.End.eigenspace T Î¼)á—®
âˆ€á¶  (r : ğ•œ) in nhds 0, {x} + r â€¢ s âŠ† u
âˆ€á¶  (t : R) in nhds 0, ring.inverse (â†‘x + t) = (finset.range n).sum (Î» (i : â„•), (-â†‘xâ»Â¹ * t) ^ i) * â†‘xâ»Â¹ + (-â†‘xâ»Â¹ * t) ^ n * ring.inverse (â†‘x + t)
function.surjective â‡‘(c.mk')
F.map f â‰« category_theory.abelian.functor.right_derived_zero_to_self_app_inv F Q = category_theory.abelian.functor.right_derived_zero_to_self_app_inv F P â‰« (F.right_derived 0).map f
âˆ« (x : Î±) in s, â‡‘(â‡‘(measure_theory.condexp_L2 ğ•œ hm) f) x âˆ‚Î¼ = âˆ« (x : Î±) in s, â‡‘f x âˆ‚Î¼
âˆ« (x : â„) in a..b, (g âˆ˜ f) x * f' x = âˆ« (x : â„) in f a..f b, g x
iterated_deriv n f = deriv^[n] f
âˆ¥continuous_linear_map.id ğ•œ Eâˆ¥ = 1
â‡‘(s.affine_combination p) wâ‚ -áµ¥ â‡‘(s.affine_combination p) wâ‚‚ = â‡‘(s.weighted_vsub p) (wâ‚ - wâ‚‚)
âˆƒ (g : Î± â†’ F), measure_theory.fin_strongly_measurable g (Î¼.trim hm) âˆ§ â‡‘f =áµ[Î¼] g
âˆƒ (r' : Î¹ â†’ â„), (s âŠ† â‹ƒ (i : Î¹), metric.ball (c i) (r' i)) âˆ§ âˆ€ (i : Î¹), r' i âˆˆ set.Ioo 0 (r i)
âˆƒ (F : circle_deg1_lift), âˆ€ (g : G), function.semiconj â‡‘F â‡‘(â‡‘fâ‚ g) â‡‘(â‡‘fâ‚‚ g)
âˆ¥â‡‘(f.restr s hk z) vâˆ¥ â‰¤ C * âˆ¥zâˆ¥ ^ (n - k) * finset.univ.prod (Î» (i : fin k), âˆ¥v iâˆ¥)
set.maps_to â‡‘(linear_map.single i) (tangent_cone_at ğ•œ (s i) (x i)) (tangent_cone_at ğ•œ (set.univ.pi s) x)
(nhds_within x {x}á¶œ).ne_bot
(Î» (x : Î±), âˆ¥f' xâˆ¥) =o[l] g â†’ f' =o[l] g
âŸ¦H.eval_at xâŸ§ = continuous_map.homotopy.hcast _ â‰« (fundamental_groupoid.fundamental_groupoid_functor.map H.ulift_map).map (continuous_map.homotopy.prod_to_prod_Top_I unit_interval.uhpath01 (ğŸ™ x)) â‰« continuous_map.homotopy.hcast _
add_con.comap â‡‘f _ c = add_con.ker (c.mk'.comp f)
function.surjective â‡‘(ideal.quotient.mkâ‚ Râ‚ I)
cardinal.mk â†¥(set.Iic a) = cardinal.continuum
deriv (Î» (u : â„), âˆ« (x : â„) in a..u, f x) b = c
â‡‘h (f.sum g) = f.sum (Î» (a : Î±) (b : M), â‡‘h (g a b))
continuous_at (Î» (x : X), âˆ« (t : â„) in a..b, F x t âˆ‚Î¼) xâ‚€
âˆ€á¶  (p : F Ã— â†¥(f'.ker)) in nhds (f a, 0), f (has_strict_fderiv_at.implicit_function f f' hf hf' p.fst p.snd) = p.fst
function.surjective â‡‘f
cardinal.mk â†¥(set.Iio a) = cardinal.continuum
subgroup.map f (subgroup.closure s) = subgroup.closure (â‡‘f '' s)
â†‘(lie_module.lower_central_series R L (L â§¸ I) k) = â†‘(lie_module.lower_central_series R (L â§¸ I) (L â§¸ I) k)
n ^ (p - 1) â‰¡ 1 [ZMOD â†‘p]
affine_independent k p â†” n â‰¤ finite_dimensional.finrank k â†¥(vector_span k (set.range p))
cont_mdiff_within_at I I' n f s x' â†” continuous_within_at f s x' âˆ§ cont_diff_within_at ğ•œ n (â‡‘(ext_chart_at I' y) âˆ˜ f âˆ˜ â‡‘((ext_chart_at I x).symm)) ((ext_chart_at I x).target âˆ© â‡‘((ext_chart_at I x).symm) â»Â¹' (s âˆ© f â»Â¹' (ext_chart_at I' y).source)) (â‡‘(ext_chart_at I x) x')
has_strict_deriv_at (Î» (u : â„), âˆ« (x : â„) in a..u, f x) c b
âˆ¥fâˆ¥ â‰¤ M
category_theory.exact f g â†” âˆƒ (w : f â‰« g = 0), nonempty (homology f g w â‰… 0)
function.bijective (mul_semiring_action.to_alg_hom â†¥(fixed_points.subfield G F) F)
â‡‘(con.ker f) x = â‡‘f â»Â¹' {â‡‘f x}
finite_dimensional.finrank R (Î  (i : Î¹), M i) = finset.univ.sum (Î» (i : Î¹), finite_dimensional.finrank R (M i))
convex_independent ğ•œ (Î» (x : â†¥s), â†‘x) â†” âˆ€ (x : E), x âˆˆ s â†’ x âˆ‰ â‡‘(convex_hull ğ•œ) (s  {x})
antitone (f âŠ” g)
(â‹ƒ (x : Î±) (H : x âˆˆ s), uniform_space.ball x U) = set.univ
bdd_below (f '' K)
pairwise (Î» (i j : I), âˆ€ (x : f i) (y : f j), add_commute (pi.single i x) (pi.single j y))
f.range = âŠ¤
category_theory.limits.has_colimits_of_shape J Cáµ’áµ–
(G.map_homological_complex c).map (homotopy.null_homotopic_map' hom) = homotopy.null_homotopic_map' (Î» (i j : Î¹) (hij : c.rel j i), G.map (hom i j hij))
measure_theory.analytic_set (â‹ƒ (n : Î¹), s n)
set.unbounded has_lt.lt (â‹‚ (i : ordinal) (hi : i < o), function.fixed_points (f i hi))
(âˆƒá¶  (x : Î±) in â†‘f, p x) â†’ (âˆ€á¶  (x : Î±) in â†‘f, p x)
continuous (function.uncurry (Î» (x : E) (y : F), â‡‘(â‡‘f x) y))
Â¬a â‹– b â†’ (âˆƒ (c : Î±), a < c âˆ§ c < b)
(â¨† (i : Î¹) (H : i âˆˆ t), â¨… (j : Î¹) (hj : j âˆˆ t) (ij : j â‰  i), I j) = âŠ¤ â†” â†‘t.pairwise (Î» (i j : Î¹), I i âŠ” I j = âŠ¤)
(Î» (n : â„•), â†‘n ^ k) =o[filter.at_top] Î» (n : â„•), r ^ n
affine_span k (s âˆª t) = affine_span k s âŠ” affine_span k t
f â‰« g â‰« h = (f â‰« g) â‰« h
category_theory.abelian.coimage.Ï€ f â‰« category_theory.abelian.factor_thru_coimage f = f
âˆƒ (a : Î±), cardinal.mk Î± < cardinal.mk â†¥(f â»Â¹' {a})
âˆ€áµ (x : Î²) âˆ‚Î¼, filter.tendsto (Î» (r : â„), â‡‘Ï (metric.closed_ball x r) / â‡‘Î¼ (metric.closed_ball x r)) (nhds_within 0 (set.Ioi 0)) (nhds (Ï.rn_deriv Î¼ x))
âˆ€á¶  (z : â„) in nhds_within x s, âˆ¥z - xâˆ¥â»Â¹ * (âˆ¥f zâˆ¥ - âˆ¥f xâˆ¥) < r
âˆƒá¶  (n : â„•) in filter.at_top, âˆƒ (m : â„¤), x â‰  â†‘m / â†‘n âˆ§ |x - â†‘m / â†‘n| < â†‘n ^ -q
|(finset.range n).sum (Î» (i : â„•), x ^ (i + 1) / (â†‘i + 1)) + real.log (1 - x)| â‰¤ |x| ^ (n + 1) / (1 - |x|)
category_theory.inv (category_theory.limits.prod_comparison F A B) â‰« F.map (category_theory.limits.prod.map f g) = category_theory.limits.prod.map (F.map f) (F.map g) â‰« category_theory.inv (category_theory.limits.prod_comparison F A' B')
vector_span k s = âŠ¤
cont_diff_on ğ•œ n (prod.map f g) (s Ã—Ë¢ t)
concave_on ğ•œ ((Î» (z : E), c + z) â»Â¹' s) (f âˆ˜ Î» (z : E), z + c)
â†‘â…I,Nâ† = submodule.span R {m : M | âˆƒ (x : â†¥I) (n : â†¥N), â…â†‘x,â†‘nâ† = m}
closure s âŠ† â‡‘(affine_map.homothety x t) '' interior s
f =o[l] g' â†’ (f =o[l] Î» (x : Î±), -g' x)
â‡‘Î¼ (â‡‘f '' s) = ennreal.of_real |â‡‘linear_map.det f| * â‡‘Î¼ s
(â¨† (b : Î±) (H : b âˆˆ s), a âŠ“ b) â‰¤ a âŠ“ has_Sup.Sup s
0 â‰¤ âˆ¥xâˆ¥
unique_mdiff_on (I.prod (model_with_corners_self ğ•œ F)) (Z.to_topological_vector_bundle_core.proj â»Â¹' s)
is_complete (m '' s) â†” is_complete s
âˆ‘' (n : â„•), f n < âˆ‘' (n : â„•), g n
topological_space.is_topological_basis ((Î» (u : set Î±), sum.inl '' u) '' s âˆª (Î» (u : set Î²), sum.inr '' u) '' t)
subgroup.closure ((Î» (g : G), âŸ¨g * (â†‘(subgroup.mem_right_transversals.to_fun hR g))â»Â¹, _âŸ©) '' (R * S)) = âŠ¤
âˆ«â» (a : Î±), (â¨† (n : â„•), f n a) âˆ‚Î¼ = â¨† (n : â„•), âˆ«â» (a : Î±), f n a âˆ‚Î¼
âˆ¥f x - f aâˆ¥ â‰¤ C * (x - a)
affine.simplex.monge_point_vsub_face_centroid_weights_with_circumcenter iâ‚ iâ‚‚ = affine.simplex.monge_point_weights_with_circumcenter n - affine.simplex.centroid_weights_with_circumcenter {iâ‚, iâ‚‚}á¶œ
continuous (Î» (p : C(Î±, Î²) Ã— Î±), â‡‘(p.fst) p.snd)
âˆ¥f + gâˆ¥ â‰¤ âˆ¥fâˆ¥ + âˆ¥gâˆ¥
âˆ¥x - yâˆ¥ = |âˆ¥xâˆ¥ - âˆ¥yâˆ¥| â†” inner_product_geometry.angle x y = 0
no_zero_smul_divisors R M â†” submodule.torsion R M = âŠ¥
fintype.card Î² = finset.univ.sum (Î» (Ï‰ : quotient (add_action.orbit_rel Î± Î²)), fintype.card Î± / fintype.card â†¥(add_action.stabilizer Î± Ï‰.out'))
(â‡‘â¨… (i : Î¹), m i) s = â¨… (t : â„• â†’ set Î±) (h2 : s âŠ† set.Union t), âˆ‘' (n : â„•), â¨… (i : Î¹), â‡‘(m i) (t n)
f âˆˆ ideal.map mv_polynomial.C I â†” âˆ€ (m : Ïƒ â†’â‚€ â„•), mv_polynomial.coeff m f âˆˆ I
x = y â†” âˆ¥xâˆ¥ = âˆ¥yâˆ¥
linear_independent R v â†’ function.injective â‡‘(finsupp.total Î¹ M R v)
p -áµ¥ p = 0
continuous â‡‘g
category_theory.presieve.is_sheaf_for P â‡‘S
asymptotics.is_O_with c l f g â†” âˆ€á¶  (x : Î±) in l, âˆ¥f xâˆ¥ â‰¤ c * âˆ¥g xâˆ¥
â‡‘f (Î» (i : Î¹), (A i).sum (Î» (j : Î± i), g i j)) = (fintype.pi_finset A).sum (Î» (r : Î  (a : Î¹), Î± a), â‡‘f (Î» (i : Î¹), g i (r i)))
â‡‘f l.sum = (list.map â‡‘f l).sum
(âˆƒ (y : (zmod p)Ë£), y ^ 2 = x) â†” x ^ (p / 2) = 1
âˆƒ (g : E â†’â‚—[â„] â„), (âˆ€ (x : â†¥(f.domain)), â‡‘g â†‘x = â‡‘f x) âˆ§ âˆ€ (x : E), x âˆˆ s â†’ 0 â‰¤ â‡‘g x
is_R_or_C.abs (has_inner.inner x (r â€¢ x)) / (âˆ¥xâˆ¥ * âˆ¥r â€¢ xâˆ¥) = 1
filter.tendsto (Î» (i : Î¹), âˆ« (x : Î±), F i x âˆ‚Î¼) l (nhds (âˆ« (x : Î±), f x âˆ‚Î¼))
cont_mdiff_on I I n â‡‘(e.symm) e.to_local_equiv.target
f.sum (Î» (x : Î±) (v : M), ite (x = a) (b x v) 0) = ite (a âˆˆ f.support) (b a (â‡‘f a)) 0
âˆƒ (N : category_theory.bundled L.Structure), nonempty (L.elementary_embedding M â†¥N) âˆ§ cardinal.mk â†¥N = Îº.lift
(cardinal.mk Î±).lift â‰¤ (cardinal.mk Î²).lift â†” nonempty (Î± â†ª Î²)
(âˆ€ (c : category_theory.limits.cone (S.arrows.diagram.op â‹™ P)), subsingleton (c âŸ¶ P.map_cone S.arrows.cocone.op)) â†” âˆ€ (E : Aáµ’áµ–), category_theory.presieve.is_separated_for (P â‹™ category_theory.coyoneda.obj E) â‡‘S
âˆ¥â‡‘f xâˆ¥ â‰¤ âˆ¥fâˆ¥ * âˆ¥xâˆ¥
(F.left_derived n).map f = (F.left_derived_obj_iso n P).hom â‰« (homology_functor D (complex_shape.down â„•) n).map ((F.map_homological_complex (complex_shape.down â„•)).map g) â‰« (F.left_derived_obj_iso n Q).inv
category_theory.limits.colimit.pre F E = (category_theory.limits.colimit.iso_colimit_cocone s).hom â‰« s.is_colimit.desc (category_theory.limits.cocone.whisker E t.cocone) â‰« (category_theory.limits.colimit.iso_colimit_cocone t).inv
category_theory.limits.pullback f g = x âŠ“ y
dense (â‹‚ (s : Î²) (H : s âˆˆ S), f s H)
summable (Î» (i : Î¹), âˆ¥has_inner.inner (v i) xâˆ¥ ^ 2)
set.eq_on â‡‘f â‡‘g â†‘(subring.closure s)
filter.tendsto (Î» (t : â„), âˆ« (x : â„) in 0..t, g x) filter.at_top filter.at_top
has_inner.inner x y = -(âˆ¥xâˆ¥ * âˆ¥yâˆ¥) â†” inner_product_geometry.angle x y = real.pi
cont_diff_on ğ•œ m (Î» (p : E Ã— E), â‡‘(fderiv_within ğ•œ f s p.fst) p.snd) (s Ã—Ë¢ set.univ)
â‡‘(s.weighted_vsub p) w = s.sum (Î» (i : Î¹), w i â€¢ (p i -áµ¥ classical.choice add_torsor.nonempty))
convex_on ğ•œ s (f âŠ” g)
R (m (â¨† (d : Î´) (H : d âˆˆ t), s d)) (t.sum (Î» (d : Î´), m (s d)))
â†‘(intermediate_field.adjoin â†¥(intermediate_field.adjoin F S) T) = intermediate_field.adjoin F (S âˆª T)
â‡‘T v âˆˆ (â¨† (Î¼ : ğ•œ), module.End.eigenspace T Î¼)á—®
function.injective â‡‘(â‡‘(dfinsupp.lsum â„•) (Î» (i : Î¹), (p i).subtype))
âˆƒ (t : set (Î± Ã— â„)), t.countable âˆ§ (âˆ€ (p : Î± Ã— â„), p âˆˆ t â†’ p.fst âˆˆ s) âˆ§ (âˆ€ (p : Î± Ã— â„), p âˆˆ t â†’ p.snd âˆˆ f p.fst) âˆ§ â‡‘Î¼ (s  â‹ƒ (p : Î± Ã— â„) (hp : p âˆˆ t), metric.closed_ball p.fst p.snd) = 0 âˆ§ t.pairwise_disjoint (Î» (p : Î± Ã— â„), metric.closed_ball p.fst p.snd)
âˆ« (x : Î±), âˆ« (y : Î²), f x y âˆ‚Î½ âˆ‚Î¼ = âˆ« (y : Î²), âˆ« (x : Î±), f x y âˆ‚Î¼ âˆ‚Î½
f (has_Inf.Inf s) = has_Inf.Inf (f '' s)
âˆ¥f y - f x - â‡‘Ï† (y - x)âˆ¥ â‰¤ C * âˆ¥y - xâˆ¥
(â¨† (x : X), (nhds_within x s).small_sets.limsup dimH) = dimH s
âˆƒ (r' : Î¹ â†’ â„), (s âŠ† â‹ƒ (i : Î¹), metric.ball (c i) (r' i)) âˆ§ âˆ€ (i : Î¹), r' i < r i
(âˆ€ (a : â†¥P), â‡‘f a = 0 â†’ a = 0) â†’ category_theory.mono f
âˆ¥normed_group_hom.id Vâˆ¥ â‰¤ 1
â¨ (x : Î±) in t, g (f x) âˆ‚Î¼ â‰¤ g (â¨ (x : Î±) in t, f x âˆ‚Î¼)
is_GÎ´ (â‹‚â‚€ S)
category_theory.limits.kernel.lift g f w â‰« category_theory.limits.kernel.map g g' q r hâ‚‚ = p â‰« category_theory.limits.kernel.lift g' f' w'
âˆƒ (g : Î± â†’ ereal), (âˆ€ (x : Î±), â†‘(f x) < g x) âˆ§ lower_semicontinuous g âˆ§ measure_theory.integrable (Î» (x : Î±), (g x).to_real) Î¼ âˆ§ (âˆ€áµ (x : Î±) âˆ‚Î¼, g x < âŠ¤) âˆ§ âˆ« (x : Î±), (g x).to_real âˆ‚Î¼ < âˆ« (x : Î±), f x âˆ‚Î¼ + Îµ
âˆ€áµ (x : Î²) âˆ‚Î¼.restrict s, filter.tendsto (Î» (r : â„), â‡‘Î¼ (s âˆ© metric.closed_ball x r) / â‡‘Î¼ (metric.closed_ball x r)) (nhds_within 0 (set.Ioi 0)) (nhds 1)
continuous â‡‘f
âˆ« (x : Î±), X x âˆ‚Â«â„™Â» = (â‡‘measure_theory.measure_space.volume s)â»Â¹.to_real * âˆ« (x : â„) in s, x
closure {x}á¶œ = set.univ
concave_on ğ•œ (â‡‘g â»Â¹' s) (f âˆ˜ â‡‘g)
w = â†‘(â‡‘(orthogonal_projection K) w) + â†‘(â‡‘(orthogonal_projection Ká—®) w)
s1.direction âŠ” s2.direction < (s1 âŠ” s2).direction
e.unit.app (e.inverse.obj Y) â‰« e.inverse.map (e.counit.app Y) = ğŸ™ (e.inverse.obj Y)
âˆƒ (g : C(Y, â„)), (âˆ€ (y : Y), â‡‘g y âˆˆ t) âˆ§ continuous_map.restrict s g = f
tendsto_uniformly_on (Î» (n : Î¹), F n âˆ˜ g) (f âˆ˜ g) p (g â»Â¹' s)
dense {x}á¶œ
closure E = â‹‚ (Î´ : â„) (h : 0 < Î´), metric.cthickening Î´ E
finite_dimensional.finrank K â†¥s < finite_dimensional.finrank K V
has_inner.inner (â‡‘(continuous_map.to_Lp 2 Î¼ ğ•œ) f) (â‡‘(continuous_map.to_Lp 2 Î¼ ğ•œ) g) = âˆ« (x : Î±), â‡‘(star_ring_end ğ•œ) (â‡‘f x) * â‡‘g x âˆ‚Î¼
(((âˆ« (x : â„) in z.re..w.re, f (â†‘x + â†‘(z.im) * complex.I)) - âˆ« (x : â„) in z.re..w.re, f (â†‘x + â†‘(w.im) * complex.I)) + complex.I â€¢ âˆ« (y : â„) in z.im..w.im, f (â†‘(w.re) + â†‘y * complex.I)) - complex.I â€¢ âˆ« (y : â„) in z.im..w.im, f (â†‘(z.re) + â†‘y * complex.I) = âˆ« (x : â„) in z.re..w.re, âˆ« (y : â„) in z.im..w.im, complex.I â€¢ â‡‘(fderiv â„ f (â†‘x + â†‘y * complex.I)) 1 - â‡‘(fderiv â„ f (â†‘x + â†‘y * complex.I)) complex.I
U = â¨… (Îµ : Î²) (H : Îµ > z), filter.principal {p : Î± Ã— Î± | D p.fst p.snd < Îµ}
f â»Â¹' interior s âŠ† interior (f â»Â¹' s)
âˆ‘' (n : Î²), f n = f b + âˆ‘' (n : Î²), ite (n = b) 0 (f n)
f (â¨† (i : Î¹), g i) = â¨† (i : Î¹), f (g i)
category_theory.skeletal (D â¥¤ C)
category_theory.cover_lifting J L (F â‹™ G)
measurable â‡‘f
0.is_diag
(â‹ƒ (i : Î¹), s i) = â‹ƒ (t : finset Î¹) (i : Î¹) (H : i âˆˆ t), s i
âˆƒ (c : â„) (H : c < a) (B : â„), (f - g) =O[l] Î» (z : â„‚), real.exp (B * real.exp (c * |u z|))
âˆƒ (y : E) (H : y âˆˆ K) (z : E) (H : z âˆˆ Ká—®), v = y + z
set.eq_on â‡‘f â‡‘g â†‘(subsemigroup.closure s)
has_strict_fderiv_at â‡‘(f.symm) â†‘(f'.symm) a
convex_independent ğ•œ (Î» (x : â†¥s), â†‘x)
e.to_local_equiv.source âˆ© â‡‘e â»Â¹' (e.to_local_equiv.target âˆ© t) = e.to_local_equiv.source âˆ© s â†’ e.is_image s t
â‡‘(category_theory.colimit_adj.restrict_yoneda_hom_equiv A P Eâ‚‚ t) (k â‰« g) = â‡‘(category_theory.colimit_adj.restrict_yoneda_hom_equiv A P Eâ‚ t) k â‰« (category_theory.colimit_adj.restricted_yoneda A).map g
f â‰« homotopy.null_homotopic_map' hom = homotopy.null_homotopic_map' (Î» (i j : Î¹) (hij : c.rel j i), f.f i â‰« hom i j hij)
category_theory.limits.prod.map f g â‰« (category_theory.limits.prod.braiding Y W).hom = (category_theory.limits.prod.braiding X Z).hom â‰« category_theory.limits.prod.map g f
is_max a â†’ a = âŠ¤
has_edist.edist (f 0) a â‰¤ âˆ‘' (m : â„•), d m
âˆ« (x : â„) in t..t + T, f x = âˆ« (x : â„) in s..s + T, f x
âˆƒ (s : set Î±), measurable_set s âˆ§ (âˆ€ (t : set Î±), measurable_set t â†’ t âŠ† s â†’ â‡‘Î½ t â‰¤ â‡‘Î¼ t) âˆ§ âˆ€ (t : set Î±), measurable_set t â†’ t âŠ† sá¶œ â†’ â‡‘Î¼ t â‰¤ â‡‘Î½ t
filter.tendsto (Î» (t : â„), âˆ« (x : â„) in 0..t, g x) filter.at_top filter.at_top
submodule.span R s = (finsupp.total â†¥s M R coe).range
A.definable L ((Î» (g : Î² â†’ M), g âˆ˜ f) '' s)
group.fg G â†” âˆƒ (S : set G), subgroup.closure S = âŠ¤ âˆ§ S.finite
subgroup.closure (set.range (Î» (v : F), reflection (submodule.span â„ {v})á—®)) = âŠ¤
fderiv â„ (Î» (p : â„ Ã— â„), âˆ« (x : â„) in p.fst..p.snd, f x) (a, b) = (continuous_linear_map.snd â„ â„ â„).smul_right cb - (continuous_linear_map.fst â„ â„ â„).smul_right ca
âˆ¥S.normed_mkâˆ¥ = 1
continuous â‡‘f
(âˆƒ (f : C(Î±, Î²)), filter.tendsto F l (nhds f)) â†” âˆ€ (s : set Î±), is_compact s â†’ (âˆƒ (f : C(â†¥s, Î²)), filter.tendsto (Î» (i : Î¹), continuous_map.restrict s (F i)) l (nhds f))
âˆ¥f.mk_continuous C Hâˆ¥ â‰¤ C
finite_dimensional.finrank K V = 1 â†” submodule.span K {v} = âŠ¤
âˆ¥x - yâˆ¥ * âˆ¥x - yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + âˆ¥yâˆ¥ * âˆ¥yâˆ¥ â†” inner_product_geometry.angle x y = real.pi / 2
â‡‘(Î¼.prod measure_theory.measure_space.volume) (region_between f g s) = âˆ«â» (y : Î±) in s, ennreal.of_real ((g - f) y) âˆ‚Î¼
has_deriv_within_at f f' s x â†” has_fderiv_within_at f (1.smul_right f') s x
âˆƒ (n : â„•) (e : M â†’ euclidean_space â„ (fin n)), smooth I (model_with_corners_self â„ (euclidean_space â„ (fin n))) e âˆ§ function.injective e âˆ§ âˆ€ (x : M), function.injective â‡‘(mfderiv I (model_with_corners_self â„ (euclidean_space â„ (fin n))) e x)
finite_dimensional.finrank k â†¥(vector_span k (set.range p)) = n
âˆƒ (g : C(Y, â„)), (âˆ€ (y : Y), â‡‘g y âˆˆ t) âˆ§ â‡‘g âˆ˜ e = â‡‘f
â‡‘(probability_theory.cond_count (s âˆ© u)) t * â‡‘(probability_theory.cond_count s) u + â‡‘(probability_theory.cond_count (s âˆ© uá¶œ)) t * â‡‘(probability_theory.cond_count s) uá¶œ = â‡‘(probability_theory.cond_count s) t
measure_theory.uniform_integrable f p Î¼ â†” (âˆ€ (i : Î¹), measure_theory.strongly_measurable (f i)) âˆ§ âˆ€ (Îµ : â„), 0 < Îµ â†’ (âˆƒ (C : nnreal), âˆ€ (i : Î¹), measure_theory.snorm ({x : Î± | C â‰¤ âˆ¥f i xâˆ¥â‚Š}.indicator (f i)) p Î¼ â‰¤ ennreal.of_real Îµ)
x +áµ¥ r â€¢ metric.closed_ball 0 1 = metric.closed_ball x r
fintype.card â†¥(G.common_neighbors v w) < G.degree v
subsemiring.map f (subsemiring.closure s) = subsemiring.closure (â‡‘f '' s)
category_theory.is_idempotent_complete C â†” âˆ€ (X : C) (p : X âŸ¶ X), p â‰« p = p â†’ category_theory.limits.has_equalizer (ğŸ™ X) p
âˆƒ (g : E â†’L[ğ•œ] ğ•œ), âˆ¥gâˆ¥ â‰¤ 1 âˆ§ â‡‘g x = â†‘âˆ¥xâˆ¥
A.definable L ((Î» (g : Î² â†’ M), g âˆ˜ â‡‘f) '' s)
closure E = â‹‚ (Î´ : â„) (h : 0 < Î´), metric.thickening Î´ E
(â‹ƒ (i : Î±) (H : i âˆˆ set.Ico m n), set.Ioc (f i) (f (order.succ i))) = set.Ioc (f m) (f n)
âˆƒ (u : â„¤Ë£) (n : â„•), algebra.discr â„š â‡‘((is_primitive_root.sub_one_power_basis â„š hÎ¶).basis) = â†‘u * â†‘p ^ n
interval_integrable (F' xâ‚€) Î¼ a b âˆ§ has_deriv_at (Î» (x : ğ•œ), âˆ« (t : â„) in a..b, F x t âˆ‚Î¼) (âˆ« (t : â„) in a..b, F' xâ‚€ t âˆ‚Î¼) xâ‚€
has_fderiv_at (Î» (x : H), âˆ« (a : Î±), F x a âˆ‚Î¼) (âˆ« (a : Î±), F' xâ‚€ a âˆ‚Î¼) xâ‚€
(s1 âŠ“ s2).direction â‰¤ s1.direction âŠ“ s2.direction
S = âŠ¥ âˆ¨ nontrivial â†¥S
âˆ¥x + yâˆ¥ ^ 2 = âˆ¥xâˆ¥ ^ 2 + 2 * has_inner.inner x y + âˆ¥yâˆ¥ ^ 2
s.prod (Î» (i : Î±), f i) * sá¶œ.prod (Î» (i : Î±), f i) = finset.univ.prod (Î» (i : Î±), f i)
simplex_category.Î´ i.succ â‰« simplex_category.Ïƒ (â‡‘fin.cast_succ j) = simplex_category.Ïƒ j â‰« simplex_category.Î´ i
f =áµ[Î¼] function.const Î± (â¨ (x : Î±), f x âˆ‚Î¼) âˆ¨ g (â¨ (x : Î±), f x âˆ‚Î¼) < â¨ (x : Î±), g (f x) âˆ‚Î¼
filter.tendsto (Î» (n : â„•), âˆ«â» (a : Î±), â†‘(â‡‘(fs n) a) âˆ‚â†‘Î¼) filter.at_top (nhds (âˆ«â» (a : Î±), â†‘(f a) âˆ‚â†‘Î¼))
Îµ ^ p.to_real * â‡‘Î¼ {x : Î± | Îµ â‰¤ â†‘âˆ¥â‡‘f xâˆ¥â‚Š} â‰¤ ennreal.of_real âˆ¥fâˆ¥ ^ p.to_real
(upper_bounds s âˆ© t).nonempty â†’ bdd_below (f '' s)
pairwise (disjoint on Î» (n : Î±), set.Ico (f n) (f (order.succ n)))
âˆƒ (g : Î± â†’ nnreal), (âˆ€ (x : Î±), g x â‰¤ f x) âˆ§ upper_semicontinuous g âˆ§ âˆ«â» (x : Î±), â†‘(f x) âˆ‚Î¼ â‰¤ âˆ«â» (x : Î±), â†‘(g x) âˆ‚Î¼ + Îµ
e.to_matrix â‡‘(e.is_unit_smul hw) = matrix.diagonal w
bornology.is_cobounded s â†’ bornology.is_bounded sá¶œ
function.periodic_orbit f x = â†‘(list.map (Î» (n : â„•), f^[n] x) (list.range (function.minimal_period f x)))
âˆ« (x : Î±) in s, measure_theory.condexp m Î¼ f x âˆ‚Î¼ = âˆ« (x : Î±) in s, f x âˆ‚Î¼
Îµ * â‡‘Î¼ {x : Î± | Îµ â‰¤ f x} â‰¤ âˆ«â» (a : Î±), f a âˆ‚Î¼
âˆƒ (S : C), âˆ€ {X : C}, X âˆˆ O â†’ nonempty (S âŸ¶ X)
box_integral.integrable I l f vol â†” âˆ€ (Îµ : â„), Îµ > 0 â†’ (âˆƒ (r : nnreal â†’ (Î¹ â†’ â„) â†’ â†¥(set.Ioi 0)), (âˆ€ (c : nnreal), l.r_cond (r c)) âˆ§ âˆ€ (câ‚ câ‚‚ : nnreal) (Ï€â‚ Ï€â‚‚ : box_integral.tagged_prepartition I), l.mem_base_set I câ‚ (r câ‚) Ï€â‚ â†’ Ï€â‚.is_partition â†’ l.mem_base_set I câ‚‚ (r câ‚‚) Ï€â‚‚ â†’ Ï€â‚‚.is_partition â†’ has_dist.dist (box_integral.integral_sum f vol Ï€â‚) (box_integral.integral_sum f vol Ï€â‚‚) â‰¤ Îµ)
âˆ® (z : â„‚) in C(c, R), (z - c)â»Â¹ â€¢ f z = âˆ® (z : â„‚) in C(c, r), (z - c)â»Â¹ â€¢ f z
category_theory.limits.has_coproducts_of_shape X Cáµ’áµ–
has_edist.edist x.val y.val â‰  âŠ¤
is_open (s Ã—Ë¢ t) â†” is_open s âˆ§ is_open t âˆ¨ s = âˆ… âˆ¨ t = âˆ…
âˆƒ (g : matrix.special_linear_group (fin 2) â„¤), â†‘g 1 = cd âˆ§ âˆ€ (g' : matrix.special_linear_group (fin 2) â„¤), â†‘g 1 = â†‘g' 1 â†’ |(g â€¢ z).re| â‰¤ |(g' â€¢ z).re|
âˆƒ (t : Î¹ â†’ set Î±), (âˆ€ (i : Î¹), t i âŠ† s i) âˆ§ (âˆ€ (i : Î¹), s i =áµ[Î¼] t i) âˆ§ (âˆ€ (i : Î¹), measurable_set (t i)) âˆ§ pairwise (disjoint on t)
(â‹‚ (i : Î¹), s i) = â‹‚ (t : finset Î¹) (i : Î¹) (H : i âˆˆ t), s i
âˆƒ (g : E â‰ƒâ‚œ F), set.eq_on f â‡‘g s
function.periodic_orbit f x = cycle.map (Î» (n : â„•), f^[n] x) â†‘(list.range (function.minimal_period f x))
set.maps_to â‡‘f' (tangent_cone_at ğ•œ s x) (tangent_cone_at ğ•œ (f '' s) (f x))
A.definable L ((Î» (g : Î± âŠ• fin m â†’ M), g âˆ˜ sum.inl) '' s)
((Î» (x : Î±), âˆ¥f' xâˆ¥) =O[l] Î» (x : Î±), âˆ¥g' xâˆ¥) â†’ f' =O[l] g'
âˆ¥c.smul_right fâˆ¥ = âˆ¥câˆ¥ * âˆ¥fâˆ¥
Gromov_Hausdorff.to_GH_space X = Gromov_Hausdorff.to_GH_space Y â†” nonempty (X â‰ƒáµ¢ Y)
topological_space.induced has_pure.pure ultrafilter.topological_space = âŠ¥
(f â‰« g)á˜ = gá˜ â‰« fá˜
u =o[l] v â†’ (âˆƒ (Ï† : Î± â†’ ğ•œ) (hÏ† : filter.tendsto Ï† l (nhds 0)), u =á¶ [l] Ï† * v)
finite_dimensional K â†¥s
âˆƒ (r : â„) (hr : r âˆˆ set.Ioo 0 f.to_cont_diff_bump.to_cont_diff_bump_of_inner.R), s âŠ† (charted_space.chart_at H c).to_local_equiv.source âˆ© â‡‘(ext_chart_at I c) â»Â¹' euclidean.ball (â‡‘(ext_chart_at I c) c) r
0.prod = 1
âˆƒ (x : E), âˆ¥xâˆ¥ â‰¤ R âˆ§ âˆ€ (y : E), y âˆˆ s â†’ 1 â‰¤ âˆ¥y - xâˆ¥
homotopy.null_homotopic_map' hom â‰« g = homotopy.null_homotopic_map' (Î» (i j : Î¹) (hij : c.rel j i), hom i j hij â‰« g.f j)
(â‹ƒ (i : Î¹'), s i) = â‹ƒ (t : finset (plift Î¹')) (i : plift Î¹') (H : i âˆˆ t), s i.down
(category_theory.limits.biprod.braiding P Q).hom â‰« (category_theory.limits.biprod.braiding Q P).hom = ğŸ™ (P âŠ Q)
module.End.has_eigenvalue T (â†‘â¨… (x : {x // x â‰  0}), â‡‘is_R_or_C.re (has_inner.inner (â‡‘T â†‘x) â†‘x) / âˆ¥â†‘xâˆ¥ ^ 2)
(p /â‚˜ q).leading_coeff = p.leading_coeff
measure_theory.condexp m Î¼ (s.indicator f) =áµ[Î¼] s.indicator (measure_theory.condexp m Î¼ f)
â‡‘dfinsupp.lift_add_hom (dfinsupp.single_add_hom Î²) = add_monoid_hom.id (Î â‚€ (i : Î¹), Î² i)
measure_theory.integrable â‡‘(measure_theory.condexp_ind_smul hm hs hÎ¼s x) Î¼
(category_theory.limits.coprod.braiding P Q).hom â‰« (category_theory.limits.coprod.braiding Q P).hom = ğŸ™ (P â¨¿ Q)
(â‹‚ (j : Î¹'), â‹ƒ (i : Î¹), s i j) = â‹ƒ (i : Î¹), â‹‚ (j : Î¹'), s i j
â¨ (x : Î±), f x âˆ‚Î¼ âˆˆ s
add_monoid.is_torsion_free (Î  (i : Î·), Gs i)
p -áµ¥ p2 âˆˆ s.direction â†” p2 âˆˆ s
has_inner.inner (measure_theory.indicator_const_Lp 2 hs hÎ¼s c) f = âˆ« (x : Î±) in s, has_inner.inner c (â‡‘f x) âˆ‚Î¼
p1 -áµ¥ p2 +áµ¥ p2 = p1
has_dist.dist p1 p3 = |has_dist.dist p1 p2 - has_dist.dist p3 p2|
s.sum (Î» (i : Î¹), w i â€¢ (pâ‚ i -áµ¥ pâ‚‚)) = â‡‘(s.weighted_vsub_of_point pâ‚ b) w - s.sum (Î» (i : Î¹), w i) â€¢ (pâ‚‚ -áµ¥ b)
s.countable â†” âˆƒ (f : â„• â†’ â†¥s), function.surjective f
dense (â‹ƒ (s : Î²) (H : s âˆˆ S), interior (f s))
has_inner.inner x y / (âˆ¥xâˆ¥ * âˆ¥yâˆ¥) = -1 â†” x â‰  0 âˆ§ âˆƒ (r : â„), r < 0 âˆ§ y = r â€¢ x
convolution f g L Î¼ x = âˆ« (t : G), â‡‘(â‡‘L (f (x - t))) (g t) âˆ‚Î¼
continuous (Î» (x : â„ Ã— â„ Ã— â†¥unit_interval), â‡‘(Î³.truncate x.fst x.snd.fst) x.snd.snd)
(â‹‚ (n : â„•), s n).nonempty
(â†‘I âŠ† â‹ƒ (i : Î¹) (H : i âˆˆ â†‘s), â†‘(f i)) â†” âˆƒ (i : Î¹) (H : i âˆˆ s), I â‰¤ f i
set.Icc (f a) (f b) âŠ† f '' s
1 â‰¤ â†‘b ^ f.nat_degree * |polynomial.eval (â†‘a / â†‘b) (polynomial.map (algebra_map â„¤ K) f)|
pairwise (disjoint on Î» (n : Î±), set.Ioo (f (order.succ n)) (f n))
â†‘-u = -â†‘u
con_gen â‡‘(con_gen r) = con_gen r
â‡‘(algebra_map K E) (algebra.discr K â‡‘(pb.basis)) = finset.univ.prod (Î» (i : fin pb.dim), (finset.filter (Î» (j : fin pb.dim), i < j) finset.univ).prod (Î» (j : fin pb.dim), -((â‡‘(â‡‘e j) pb.gen - â‡‘(â‡‘e i) pb.gen) * (â‡‘(â‡‘e i) pb.gen - â‡‘(â‡‘e j) pb.gen))))
âˆƒ (y : â†¥â†‘t), x âˆˆ â‡‘(convex_hull ğ•œ) â†‘(t.erase â†‘y)
fintype.card â†¥s âˆ£ fintype.card Î±
x âˆˆ supr p â†” âˆƒ (f : Î â‚€ (i : Î¹), â†¥(p i)), f.sum (Î» (i : Î¹) (xi : â†¥(p i)), â†‘xi) = x
category_theory.presheaf.first_map R F â‰« (Top.presheaf.covering_of_presieve.second_obj_iso_pi_inters F U R).hom = (Top.presheaf.covering_of_presieve.first_obj_iso_pi_opens F U R).hom â‰« Top.presheaf.sheaf_condition_equalizer_products.left_res F (Top.presheaf.covering_of_presieve U R)
âˆƒ (r' : Î¹ â†’ â„), (â‹ƒ (i : Î¹), metric.ball (c i) (r' i)) = set.univ âˆ§ âˆ€ (i : Î¹), r' i < r i
{c : cardinal | âˆƒ (S : set Î±), set.unbounded r S âˆ§ cardinal.mk â†¥S = c}.nonempty
module.rank R (Î¹ â†’â‚€ R) = cardinal.mk Î¹
is_coatomic â†¥(set.Iic k)
affine_span k âˆ… = âŠ¥
(â‹‚ (j : Î¹'), â‹ƒ (i : Î¹), s i j) = â‹ƒ (i : Î¹), â‹‚ (j : Î¹'), s i j
X.Î´ i.succ â‰« X.Ïƒ i = ğŸ™ (X.obj (simplex_category.mk n))
category_theory.cover_preserving J J (ğŸ­ C)
(â¨† (g : ultrafilter Î±) (hg : â†‘g â‰¤ f), â†‘g) = f
âˆ¥xâˆ¥ = âˆ¥yâˆ¥
âˆƒ (t : â†¥M), t â€¢ x âˆˆ submodule.span R s
s.Î¹ â‰« Top.presheaf.presieve_of_covering.pi_opens_to_first_obj F U â‰« Top.presheaf.presieve_of_covering.first_obj_to_pi_opens F U = s.Î¹
set.range (s.face h).points = s.points '' â†‘fs
dimH (f '' s) â‰¤ dimH s
is_unit (algebra.discr K â‡‘b)
a - âŠ¤ = 0
âˆƒ (Î¹ : Type u) [_inst_8 : fintype Î¹] (p : Î¹ â†’ R) [_inst_9 : âˆ€ (i : Î¹), irreducible (p i)] (e : Î¹ â†’ â„•), nonempty (N â‰ƒâ‚—[R] direct_sum Î¹ (Î» (i : Î¹), R â§¸ submodule.span R {p i ^ e i}))
v +áµ¥ p âˆˆ span_points k s
set.range â‡‘(category_theory.limits.pullback.map fâ‚ fâ‚‚ gâ‚ gâ‚‚ iâ‚ iâ‚‚ iâ‚ƒ eqâ‚ eqâ‚‚) = â‡‘category_theory.limits.pullback.fst â»Â¹' set.range â‡‘iâ‚ âˆ© â‡‘category_theory.limits.pullback.snd â»Â¹' set.range â‡‘iâ‚‚
function.involutive â‡‘(euclidean_geometry.reflection s)
function.injective â‡‘f
f' =O[l] g â†’ (Î» (x : Î±), âˆ¥f' xâˆ¥) =O[l] g
âˆ¥f.mk_normed_group_hom C hâˆ¥ â‰¤ linear_order.max C 0
âˆ¥x - yâˆ¥ ^ 2 = âˆ¥xâˆ¥ ^ 2 - 2 * has_inner.inner x y + âˆ¥yâˆ¥ ^ 2
c = closure_operator.mkâ‚ƒ â‡‘c c.closed _ _ _
submodule.map f (submodule.span R s) = submodule.span Râ‚‚ (â‡‘f '' s)
â‡‘(euclidean_geometry.reflection s) (r â€¢ (pâ‚‚ -áµ¥ â†‘(â‡‘(euclidean_geometry.orthogonal_projection s) pâ‚‚)) +áµ¥ pâ‚) = -(r â€¢ (pâ‚‚ -áµ¥ â†‘(â‡‘(euclidean_geometry.orthogonal_projection s) pâ‚‚))) +áµ¥ pâ‚
(cauchy_power_series f c R).sum w = (2 * â†‘real.pi * complex.I)â»Â¹ â€¢ âˆ® (z : â„‚) in C(c, R), (z - (c + w))â»Â¹ â€¢ f z
is_R_or_C.abs (has_inner.inner x y) â‰¤ âˆ¥xâˆ¥ * âˆ¥yâˆ¥
is_submonoid (f â»Â¹' s)
measure_theory.null_measurable_set (f â»Â¹' t) Î¼
s.pairwise (Î» (x y : Î±), f x = f y) â†” âˆƒ (z : Î¹), âˆ€ (x : Î±), x âˆˆ s â†’ f x = z
âˆƒ (g : Î± â†’ ennreal), (âˆ€ (x : Î±), â†‘(f x) < g x) âˆ§ lower_semicontinuous g âˆ§ âˆ«â» (x : Î±), g x âˆ‚Î¼ â‰¤ âˆ«â» (x : Î±), â†‘(f x) âˆ‚Î¼ + Îµ
(âˆ€ â¦ƒc : â„â¦„, 0 < c â†’ (âˆ€á¶  (x : Î±) in l, âˆ¥f xâˆ¥ â‰¤ c * âˆ¥g xâˆ¥)) â†’ f =o[l] g
âˆ« (x : â„) in a..b, f x âˆ‚Î¼ = âˆ« (x : â„) in a..b, g x âˆ‚Î¼
âˆƒá¶  (b : â„•) in filter.at_top, âˆƒ (a : â„¤), x â‰  â†‘a / â†‘b âˆ§ |x - â†‘a / â†‘b| < 1 / â†‘b ^ n
module.is_torsion_by R â†¥(submodule.torsion_by R M a) a
summable (Î» (x : Î±), |f x|) â†’ summable f
cont_diff_at ğ•œ n â‡‘(f.symm) a
(Î» (t : R), ring.inverse (â†‘x + t) - (finset.range n).sum (Î» (i : â„•), (-â†‘xâ»Â¹ * t) ^ i) * â†‘xâ»Â¹) =O[nhds 0] Î» (t : R), âˆ¥tâˆ¥ ^ n
âˆƒ (v : E) (H : v âˆˆ K), âˆ¥u - vâˆ¥ = â¨… (w : â†¥â†‘K), âˆ¥u - â†‘wâˆ¥
âˆ« (x : Î±), âˆ« (y : Î²), f (x, y) + g (x, y) âˆ‚Î½ âˆ‚Î¼ = âˆ« (x : Î±), âˆ« (y : Î²), f (x, y) âˆ‚Î½ âˆ‚Î¼ + âˆ« (x : Î±), âˆ« (y : Î²), g (x, y) âˆ‚Î½ âˆ‚Î¼
measurable (Î» (x : Î±), âˆ«â» (y : Î²), f x y âˆ‚Î½)
â‡‘(algebra_map K E) (algebra.discr K â‡‘(pb.basis)) = (-1) ^ (finite_dimensional.finrank K L * (finite_dimensional.finrank K L - 1) / 2) * finset.univ.prod (Î» (i : fin pb.dim), (finset.filter (Î» (j : fin pb.dim), i < j) finset.univ).prod (Î» (j : fin pb.dim), (â‡‘(â‡‘e j) pb.gen - â‡‘(â‡‘e i) pb.gen) * (â‡‘(â‡‘e i) pb.gen - â‡‘(â‡‘e j) pb.gen)))
mul_action.fixed_points â†¥(supr P) Î± = â‹‚ (i : Î¹), mul_action.fixed_points â†¥(P i) Î±
â‡‘measure_theory.measure_space.volume (â‹ƒ (p : â„) (hp : 2 < p), {x : â„ | liouville_with p x}) = 0
has_inner.inner x y = -(âˆ¥xâˆ¥ * âˆ¥yâˆ¥)
convex_independent ğ•œ (Î» (x : â†¥(set.range p)), â†‘x)
â‡‘Î¼ ((Î» (h : G), g * h) â»Â¹' A) = â‡‘Î¼ A
â‡‘(linear_map.to_matrix bM bN) (â‡‘(dual_tensor_hom R M N) (bM.coord j âŠ—â‚œ[R] â‡‘bN i)) = matrix.std_basis_matrix i j 1
connected_component x = â‹‚ (Z : {Z // is_clopen Z âˆ§ x âˆˆ Z}), â†‘Z
finset.centroid k {iâ‚, iâ‚‚} p = 2â»Â¹ â€¢ (p iâ‚‚ -áµ¥ p iâ‚) +áµ¥ p iâ‚
has_dist.dist (r1 â€¢ v +áµ¥ p1) (r2 â€¢ v +áµ¥ p2) * has_dist.dist (r1 â€¢ v +áµ¥ p1) (r2 â€¢ v +áµ¥ p2) = has_dist.dist p1 p2 * has_dist.dist p1 p2 + (r1 - r2) * (r1 - r2) * (âˆ¥vâˆ¥ * âˆ¥vâˆ¥)
cardinal.mk â†¥set.univ = cardinal.continuum
pairwise (disjoint on Î» (n : Î±), set.Ioc (f (order.pred n)) (f n))
(s.monge_plane iâ‚ iâ‚‚).direction = (submodule.span â„ {s.points iâ‚ -áµ¥ s.points iâ‚‚})á—® âŠ“ vector_span â„ (set.range s.points)
function.injective â‡‘(add_con.ker_lift f)
measure_theory.simple_func.integral Î¼ f = (âˆ«â» (a : Î±), ennreal.of_real (â‡‘f a) âˆ‚Î¼).to_real
algebra.adjoin R (â‡‘(monoid_algebra.of R M) '' â‹ƒ (f : monoid_algebra R M) (H : f âˆˆ S), â†‘(f.support)) = âŠ¤
(â‹‚ (i : Î¹), Z i).nonempty
âˆ¥â†‘mâˆ¥ â‰¤ âˆ¥mâˆ¥
