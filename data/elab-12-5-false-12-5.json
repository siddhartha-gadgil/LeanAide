{"total-prompts": 33,
 "temperature": 0.5,
 "query-number": 12,
 "number-similar-sentences": 12,
 "number-keyword-sentences": 5,
 "include-fixed": false,
 "failures":
 ["Every set of Borel measure zero is Lebesgue measurable.",
  "For every subset of the Euclidean plane, there is a line segment of unit length whose endpoints are either both inside the subset or both outside it.",
  "Every set that is Lebesgue measurable but not Borel measurable has Lebesgue measure zero."],
 "elaborated-prompts":
 [{"theorem": "âˆ€ (p : â„•) [hp : Fact (Nat.Prime p)], p = 2 âˆ¨ p % 2 = 1",
   "prompt": "Every prime number is `2` or odd.",
   "all-elabs":
   [" (  p :  â„• ) ->  [ hp :  Fact   (   Nat.Prime  p  ) ] ->   p =  2 âˆ¨   p %  2 =  1",
    " (  p :  â„• ) ->  [  Fact   (   Nat.Prime  p  ) ] ->   p =  2 âˆ¨   p %  2 =  1",
    " (  p :  â„• ) ->   Nat.Prime  p â†’   p =  2 âˆ¨   p %  2 =  1",
    " {  p :  â„• } ->  [  Fact   (   Nat.Prime  p  ) ] ->   p =  2 âˆ¨   p %  2 =  1",
    " (  p :  â„• ) ->  [  Fact   (   Nat.Prime  p  ) ] ->   p =  2 âˆ¨  (     p %  2 =  1 âˆ§  p â‰   2  )"]},
  {"theorem": "âˆ€ (n : â„•), âˆƒ m, m % 2 = 1 âˆ§ n < m",
   "prompt": "There are infinitely many odd natural numbers.",
   "all-elabs":
   [" âˆ€   (  n  :  â„•  )  ,  âˆƒ    (   m :  â„• ) ,    m %  2 =  1 âˆ§  n < m",
    " âˆ€   (  n  :  â„•  )  ,  âˆƒ    (   m :  â„• ) ,   m > n âˆ§   m %  2 =  1",
    " âˆƒ    (   n :  â„• ) ,   n %  2 =  1",
    " âˆ€  n  ,  âˆƒ     m  ,   n < m âˆ§  Odd  m",
    " âˆ€   (  n  :  â„•  )  ,  âˆƒ    (   k :  â„• ) ,   k â‰¥ n âˆ§  Odd  k",
    " âˆƒ    (   n :  â„• ) ,  Odd  n",
    " âˆ€   (  n  :  â„•  )  ,  âˆƒ    (   k :  â„• ) ,  n <    2 * k +  1",
    " âˆƒ    (   n :  â„• ) ,  âˆ€   (  m  :  â„•  )  ,   m < n â†’  Odd  m",
    " âˆ€  p   :  â„• ,  âˆƒ     m  :  â„• ,   m > p âˆ§  Odd  m"]},
  {"theorem": "Nat.Prime 3",
   "prompt": "The smallest odd prime is `3`.",
   "all-elabs":
   [" Nat.Prime   3",
    " âˆ€  p   :  â„• ,   Nat.Prime  p â†’    p %  2 =  1 â†’  p =  3",
    " âˆ€   (  n  :  â„•  )  ,   Nat.Prime  n â†’   Nat.Prime   (   n +  2  ) â†’  n =  1",
    " âˆƒ    (   p :  â„• ) ,   Nat.Prime  p âˆ§    p %  2 =  1 âˆ§  âˆ€   (  p'  :  â„•  )  ,    p' %  2 =  1 â†’   Nat.Prime  p' â†’  p â‰¤ p'"]},
  {"theorem": "âˆ€ {n : â„•}, âˆƒ p, n < p âˆ§ Nat.Prime p âˆ§ Odd p",
   "prompt": "There are infinitely many odd prime numbers.",
   "all-elabs":
   [" âˆ€   {  n  :  â„• }  ,  âˆƒ    (   p :  â„• ) ,   n < p âˆ§   Nat.Prime  p âˆ§  Odd  p",
    " âˆƒ    (   p :  â„• ) ,   Nat.Prime  p âˆ§  Odd  p",
    " âˆ€   (  n  :  â„•  )  ,  âˆƒ    (   p :  â„• ) ,   n < p âˆ§   Nat.Prime  p âˆ§   p %  2 =  1",
    " âˆ€   (  n  :  â„•  )  ,  âˆƒ    (   p :  â„• ) ,   p â‰¥ n âˆ§   Nat.Prime  p âˆ§   p %  2 =  1",
    " âˆ€   (  n  :  â„•  )  ,  âˆƒ    (   p :  â„• ) ,   p > n âˆ§   Nat.Prime  p âˆ§  Odd  p",
    " âˆ€   (  n  :  â„•  )  ,  âˆƒ    (   p :  â„• ) ,   n < p âˆ§    p %  2 =  1 âˆ§  Nat.Prime  p",
    " âˆ€   (  a  :  â„•  )  ,  âˆƒ    (   b :  â„• ) ,   Nat.Prime  b âˆ§  a < b",
    " âˆ€   (  n  :  â„•  )  ,  âˆƒ    (   p :  â„• ) ,   Nat.Prime  p âˆ§  p > n",
    " âˆƒ    (   p :  â„• ) ,   p >  2 âˆ§  Nat.Prime  p"]},
  {"theorem": "âˆ€ {R : Type u} [inst : Ringâ‚“ R], IsField R",
   "prompt": "Every ring is a field.",
   "all-elabs": [" {  R :  Type  u } ->  [  Ringâ‚“  R ] ->  IsField  R"]},
  {"theorem": "(K : Type u) â†’ [inst : Field K] â†’ Ring K",
   "prompt": "Every field is a ring.",
   "all-elabs":
   [" (  K :  Type  u ) ->  [  Field  K ] ->  Ring  K",
    " (  K :  Type  u ) ->  [  Field  K ] ->  Ringâ‚“  K",
    " (  K :  Type  u ) ->  [  Field  K ] ->  Ring  K",
    " (  K :  Type  u ) ->  [  Field  K ] ->  Ringâ‚“  K",
    " {  K :  Type  u } ->  [  Field  K ] ->  Ring  K",
    " {  K :  Type  u } ->  [  Field  K ] ->  Ringâ‚“  K",
    " (  K :  Type  u ) ->  [  Field  K ] ->  CommRing  K",
    " (  K :  Type  u ) ->  [  Field  K ] ->  CommRingâ‚“  K"]},
  {"theorem": "{Î± : Type u_1} â†’ [inst : Ringâ‚“ Î±] â†’ Group (Units Î±)",
   "prompt": "The set of units in a ring forms a group.",
   "all-elabs":
   [" {  Î± :  Type  u_1 } ->  [  Ringâ‚“  Î± ] ->  Group   (   Units  Î±  )",
    " {  Î± :  Type  u_1 } ->  [  Ringâ‚“  Î± ] ->  Groupâ‚“   (   Units  Î±  )",
    " {  Î± :  Type  u } ->  [  Ringâ‚“  Î± ] ->  Group   (   Units  Î±  )",
    " {  Î± :  Type  u } ->  [  Ringâ‚“  Î± ] ->  Groupâ‚“   (   Units  Î±  )",
    " {  R :  Type  u_1 } ->  [  Ringâ‚“  R ] ->  Group   (   Units  R  )",
    " {  R :  Type  u_1 } ->  [  Ringâ‚“  R ] ->  Groupâ‚“   (   Units  R  )",
    " {  R :  Type  u_1 } ->  [  Ringâ‚“  R ] ->  Group   (    @ Units  R  _  )",
    " {  R :  Type  u_1 } ->  [  Ringâ‚“  R ] ->  Groupâ‚“   (    @ Units  R  _  )",
    " {  R :  Type  u } ->  [  Ringâ‚“  R ] ->  Group   (   Units  R  )",
    " {  R :  Type  u } ->  [  Ringâ‚“  R ] ->  Groupâ‚“   (   Units  R  )",
    " {  R :  Type  u_1 } ->  [  CommRingâ‚“  R ] ->  [  Fintype  R ] ->  Monoid   (   Units  R  )",
    " {  R :  Type  u_1 } ->  [  CommRingâ‚“  R ] ->  [  Fintype  R ] ->  Monoidâ‚“   (   Units  R  )",
    " {  R :  Type  u_1 } ->  [  Ringâ‚“  R ] ->  AddCommGroup   (   Units  R  )",
    " {  R :  Type  u_1 } ->  [  Ringâ‚“  R ] ->  AddCommGroupâ‚“   (   Units  R  )",
    " {  Î± :  Type  u_1 } ->  [  Ringâ‚“  Î± ] ->  [  One  Î± ] ->  Group   (   Units  Î±  )",
    " {  Î± :  Type  u_1 } ->  [  Ringâ‚“  Î± ] ->  [  One  Î± ] ->  Groupâ‚“   (   Units  Î±  )"]},
  {"theorem":
   "âˆ€ (k : Type u_1) {V : Type u_2} [inst : DivisionRing k] [inst_1 : AddCommGroupâ‚“ V] [inst_2 : Module k V],\n  FiniteDimensional k V",
   "prompt": "Every vector space is finite dimensional.",
   "all-elabs":
   [" (  k :  Type  u_1 ) ->  {  V :  Type  u_2 } ->  [  DivisionRing  k ] ->  [  AddCommGroupâ‚“  V ] ->  [  Module  k V ] ->  FiniteDimensional  k V",
    " {  K :  Type  u } ->  {  V :  Type  v } ->  [  DivisionRing  K ] ->  [  AddCommGroupâ‚“  V ] ->  [  Module  K V ] ->  [  DecidableEq  V ] ->  FiniteDimensional  K V",
    " {  Î± :  Type  u } ->  {  Î² :  Type  v } ->  [  DivisionRing  Î± ] ->  [  AddCommGroupâ‚“  Î² ] ->  [  Module  Î± Î² ] ->  FiniteDimensional  Î± Î²",
    " {  K :  Type  u } ->  {  V :  Type  v } ->  [  DivisionRing  K ] ->  [  AddCommGroupâ‚“  V ] ->  [  Module  K V ] ->  FiniteDimensional  K V",
    " (  K :  Type  u ) ->  (  V :  Type  v ) ->  [  DivisionRing  K ] ->  [  AddCommGroupâ‚“  V ] ->  [  Module  K V ] ->  FiniteDimensional  K V",
    " {  k :  Type  u } ->  {  V :  Type  v } ->  [  DivisionRing  k ] ->  [  AddCommGroupâ‚“  V ] ->  [  Module  k V ] ->  FiniteDimensional  k V"]},
  {"theorem":
   "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroupâ‚“ V] [inst_2 : Module K V],\n  Module.rank K V = 2 â†’ FiniteDimensional K V",
   "prompt":
   "If a vector space has dimension `2` then it is finite dimensional.",
   "all-elabs":
   [" {  K :  Type  u } ->  {  V :  Type  v } ->  [  DivisionRing  K ] ->  [  AddCommGroupâ‚“  V ] ->  [  Module  K V ] ->    Module.rank  K V =  2 â†’  FiniteDimensional  K V",
    " {  K :  Type  u } ->  {  V :  Type  v } ->  [  DivisionRing  K ] ->  [  AddCommGroupâ‚“  V ] ->  [  Module  K V ] ->  (  h :   Module.rank  K V =  2 ) ->  FiniteDimensional  K V",
    " {  K :  Type  u } ->  {  V :  Type  v } ->  [  DivisionRing  K ] ->  [  AddCommGroupâ‚“  V ] ->  [  Module  K V ] ->  {  n :  â„• } ->  (  h :   Module.rank  K V =  2 ) ->  FiniteDimensional  K V",
    " {  K :  Type  u } ->  {  V :  Type  v } ->  [  DivisionRing  K ] ->  [  AddCommGroupâ‚“  V ] ->  [  Module  K V ] ->  (  h :   Module.rank  K V â‰¤  2 ) ->  FiniteDimensional  K V"]},
  {"theorem": "(K : Type u) â†’ [inst : Field K] â†’ DivisionRing K",
   "prompt": "Every field is a division ring.",
   "all-elabs":
   [" (  K :  Type  u ) ->  [  Field  K ] ->  DivisionRing  K",
    " {  K :  Type  u } ->  [  Field  K ] ->  DivisionRing  K",
    " {  K :  Type* } ->  [  Field  K ] ->  DivisionRing  K",
    " {  F :  Type  u } ->  [  Field  F ] ->  DivisionRing  F",
    " (  F :  Type  u ) ->  [  Field  F ] ->  DivisionRing  F"]},
  {"theorem":
   "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroupâ‚“ V] [inst_2 : Module K V],\n  Module.rank K V = 2 â†’ FiniteDimensional K V",
   "prompt": "If a space has dimension `2` then it is finite dimensional.",
   "all-elabs":
   [" {  K :  Type  u } ->  {  V :  Type  v } ->  [  DivisionRing  K ] ->  [  AddCommGroupâ‚“  V ] ->  [  Module  K V ] ->    Module.rank  K V =  2 â†’  FiniteDimensional  K V",
    " {  K :  Type  u } ->  {  V :  Type  v } ->  [  DivisionRing  K ] ->  [  AddCommGroupâ‚“  V ] ->  [  Module  K V ] ->  (  h :   Module.rank  K V â‰¤  2 ) ->  FiniteDimensional  K V",
    " {  K :  Type  u } ->  {  V :  Type  v } ->  [  DivisionRing  K ] ->  [  AddCommGroupâ‚“  V ] ->  [  Module  K V ] ->  (  h :   Module.rank  K V =  2 ) ->  FiniteDimensional  K V"]},
  {"theorem": "âˆ€ {G : Type u_1} [inst : Groupâ‚“ G], Monoidâ‚“.IsTorsion G",
   "prompt": "Every group is a torsion monoid.",
   "all-elabs":
   [" {  G :  Type  u_1 } ->  [  Groupâ‚“  G ] ->  Monoidâ‚“.IsTorsion  G",
    " (  G :  Type  u_1 ) ->  [  Groupâ‚“  G ] ->  Monoidâ‚“.IsTorsion  G",
    " {  G :  Type  u_3 } ->  [  Groupâ‚“  G ] ->  Monoidâ‚“.IsTorsion  G"]},
  {"theorem": "âˆ€ {m : â„•}, âˆƒ n, m < n",
   "prompt": "Every natural number has a successor.",
   "all-elabs":
   [" {  m :  â„• } ->  âˆƒ    (   n :  â„• ) ,  m < n",
    " {  n :  â„• } ->  âˆƒ    (   m :  â„• ) ,  n < m",
    " âˆ€   (  n  :  â„•  )  ,  âˆƒ    (   m :  â„• ) ,  m = n.succ",
    " {  n :  â„• } ->  âˆƒ    (   m :  â„• ) ,  n = m.succ",
    " âˆ€   (  n  :  â„•  )  ,  âˆƒ    (   m :  â„• ) ,  n < m",
    " {  n :  â„• } ->  âˆƒ    (   a :  â„• ) ,  n < a"]},
  {"theorem": "âˆ€ (n : â„•), n < Nat.succ n",
   "prompt": "Every natural number is less than its successor.",
   "all-elabs": [" (  n :  â„• ) ->  n < n.succ", " {  n :  â„• } ->  n < n.succ"]},
  {"theorem":
   "âˆ€ {Î· G : Type u_1} {Gs : Î· â†’ Type u_2} [inst : Groupâ‚“ G] [inst_1 : (i : Î·) â†’ Groupâ‚“ (Gs i)],\n  Monoidâ‚“.IsTorsionFree (G Ã— ((i : Î·) â†’ Gs i)) â†’ âˆ€ (i : Î·), Monoidâ‚“.IsTorsionFree (Gs i)",
   "prompt":
   "If the direct product of two groups is torsion free then each of the groups is torsion free.",
   "all-elabs":
   [" {  Î· :  Type  u_1 } ->  {  G :  Type  u_1 } ->  {  Gs :  Î· â†’  Type  u_2 } ->  [  Groupâ‚“  G ] ->  [  Î  ( i : Î· ) ,  Groupâ‚“   (   Gs  i  ) ] ->  (  h :  Monoidâ‚“.IsTorsionFree   (   G Ã—  Î  ( i : Î· ) ,  Gs  i  ) ) ->  (  i : Î· ) ->  Monoidâ‚“.IsTorsionFree   (   Gs  i  )"]},
  {"theorem":
   "âˆ€ {G : Type u} [inst : Groupâ‚“ G] [inst_1 : Fintype G], IsSimpleGroup G â†’ âˆƒ p, Nat.Prime p âˆ§ Fintype.card G = p",
   "prompt": "Every finite simple group has prime order.",
   "all-elabs":
   [" {  G :  Type  u } ->  [  Groupâ‚“  G ] ->  [  Fintype  G ] ->  (  h :  IsSimpleGroup  G ) ->  âˆƒ    (   p :  â„• ) ,   Nat.Prime  p âˆ§   Fintype.card  G = p",
    " {  G :  Type  u } ->  [  Groupâ‚“  G ] ->  [  Fintype  G ] ->  (  h :  IsSimpleGroup  G ) ->  âˆƒ     p  ,   Fact   (   Nat.Prime  p  ) âˆ§   Fintype.card  G = p",
    " {  G :  Type  u } ->  [  Groupâ‚“  G ] ->  [  Fintype  G ] ->  (  h :  IsSimpleGroup  G ) ->  âˆƒ    (   p :  â„• ) ,   Fact   (   Nat.Prime  p  ) âˆ§   Fintype.card  G = p",
    " {  G :  Type  u } ->  [  Groupâ‚“  G ] ->  [  Fintype  G ] ->  (  h :  IsSimpleGroup  G ) ->  âˆƒ    (   p :  â„• ) ,    Fintype.card  G = p âˆ§  Fact   (   Nat.Prime  p  )",
    " {  Î± :  Type  u } ->  [  Groupâ‚“  Î± ] ->  [  Fintype  Î± ] ->  [  IsSimpleGroup  Î± ] ->  âˆƒ    (   p :  â„• ) ,   Fact   (   Nat.Prime  p  ) âˆ§   Fintype.card  Î± = p",
    " {  Î± :  Type  u_1 } ->  [  Groupâ‚“  Î± ] ->  [  Fintype  Î± ] ->  (  h :  IsSimpleGroup  Î± ) ->  âˆƒ     p  ,   Nat.Prime  p âˆ§   Fintype.card  Î± = p",
    " {  Î± :  Type  u } ->  [  Groupâ‚“  Î± ] ->  [  Fintype  Î± ] ->  (  h :  IsSimpleGroup  Î± ) ->  âˆƒ    (   p :  â„• ) ,   Fact   (   Nat.Prime  p  ) âˆ§   Fintype.card  Î± = p",
    " {  Î± :  Type  u } ->  [  Groupâ‚“  Î± ] ->  [  Fintype  Î± ] ->  (  h :  IsSimpleGroup  Î± ) ->  âˆƒ    (   p :  â„• ) ,   Nat.Prime  p âˆ§   Fintype.card  Î± = p"]},
  {"theorem":
   "âˆ€ {G : Type u} [inst : Groupâ‚“ G] [inst_1 : Fintype G], IsSimpleGroup G",
   "prompt": "Every finite group is simple.",
   "all-elabs":
   [" {  G :  Type  u } ->  [  Groupâ‚“  G ] ->  [  Fintype  G ] ->  IsSimpleGroup  G",
    " {  Î± :  Type  u } ->  [  Groupâ‚“  Î± ] ->  [  Fintype  Î± ] ->  IsSimpleGroup  Î±",
    " {  G :  Type  u_1 } ->  [  Groupâ‚“  G ] ->  [  Fintype  G ] ->  IsSimpleGroup  G",
    " (  G :  Type  u_1 ) ->  [  Groupâ‚“  G ] ->  [  Fintype  G ] ->  IsSimpleGroup  G"]},
  {"theorem":
   "âˆ€ {Î± : Type u} [inst : Group Î±] [inst : Fintype Î±], âˆƒ p, Fintype.card Î± = p âˆ§ Fact (Nat.Prime p)",
   "prompt": "Every finite group has prime order.",
   "all-elabs":
   [" {  Î± :  Type  u } ->  [  Group  Î± ] ->  [  Fintype  Î± ] ->  âˆƒ    (   p :  â„• ) ,    Fintype.card  Î± = p âˆ§  Fact   (   Nat.Prime  p  )",
    " {  Î± :  Type  u } ->  [  Groupâ‚“  Î± ] ->  [  Fintype  Î± ] ->  âˆƒ    (   p :  â„• ) ,    Fintype.card  Î± = p âˆ§  Fact   (   Nat.Prime  p  )",
    " {  Î± :  Type  u } ->  [  Group  Î± ] ->  [  Fintype  Î± ] ->  âˆƒ    (   p :  â„• ) ,   Fact   (   Nat.Prime  p  ) âˆ§   Fintype.card  Î± = p",
    " {  Î± :  Type  u } ->  [  Groupâ‚“  Î± ] ->  [  Fintype  Î± ] ->  âˆƒ    (   p :  â„• ) ,   Fact   (   Nat.Prime  p  ) âˆ§   Fintype.card  Î± = p",
    " {  Î± :  Type  u } ->  [  Group  Î± ] ->  [  Fintype  Î± ] ->  âˆƒ    (   p :  â„• ) ,   Nat.Prime  p âˆ§   Fintype.card  Î± = p",
    " {  Î± :  Type  u } ->  [  Groupâ‚“  Î± ] ->  [  Fintype  Î± ] ->  âˆƒ    (   p :  â„• ) ,   Nat.Prime  p âˆ§   Fintype.card  Î± = p",
    " {  Î± :  Type  u } ->  [  Group  Î± ] ->  [  Fintype  Î± ] ->  âˆƒ     p  :  â„• ,   Fact   (   Nat.Prime  p  ) âˆ§   Fintype.card  Î± = p",
    " {  Î± :  Type  u } ->  [  Groupâ‚“  Î± ] ->  [  Fintype  Î± ] ->  âˆƒ     p  :  â„• ,   Fact   (   Nat.Prime  p  ) âˆ§   Fintype.card  Î± = p",
    " {  G :  Type  u_1 } ->  [  Group  G ] ->  [  Fintype  G ] ->  âˆƒ    (   p :  â„• ) ,   Fact   (   Nat.Prime  p  ) âˆ§   Fintype.card  G = p",
    " {  G :  Type  u_1 } ->  [  Groupâ‚“  G ] ->  [  Fintype  G ] ->  âˆƒ    (   p :  â„• ) ,   Fact   (   Nat.Prime  p  ) âˆ§   Fintype.card  G = p",
    " {  G :  Type  u } ->  [  Group  G ] ->  [  Fintype  G ] ->  âˆƒ    (   p :  â„• ) ,   Nat.Prime  p âˆ§   Fintype.card  G = p",
    " {  G :  Type  u } ->  [  Groupâ‚“  G ] ->  [  Fintype  G ] ->  âˆƒ    (   p :  â„• ) ,   Nat.Prime  p âˆ§   Fintype.card  G = p",
    " {  G :  Type  u_1 } ->  [  Group  G ] ->  [  Fintype  G ] ->  âˆƒ    (   p :  â„• ) ,   Nat.Prime  p âˆ§   Fintype.card  G = p",
    " {  G :  Type  u_1 } ->  [  Groupâ‚“  G ] ->  [  Fintype  G ] ->  âˆƒ    (   p :  â„• ) ,   Nat.Prime  p âˆ§   Fintype.card  G = p"]},
  {"theorem":
   "âˆ€ (m n : â„•), âˆƒ a b c, a * a + b * b = c * c âˆ§ gcd a b = 1 âˆ§ a > 0 âˆ§ b > 0 âˆ§ c > 0 âˆ§ a â‰¥ m âˆ§ b â‰¥ n",
   "prompt": "There are infinitely many Pythagorean triples.",
   "all-elabs":
   [" âˆ€   (  m  :  â„•  )  (  n  :  â„•  )  ,  âˆƒ    (   a  b  c :  â„• ) ,  (      a * a +  b * b =  c * c âˆ§    gcd  a b =  1 âˆ§   a >  0 âˆ§   b >  0 âˆ§   c >  0 âˆ§   a â‰¥ m âˆ§  b â‰¥ n  )",
    " âˆ€  n   :  â„• ,  âˆƒ    (   x  y  z :  â„• ) ,   z > n âˆ§    x * x +  y * y =  z * z",
    " âˆ€   (  x y z  :  â„•  )  ,  âˆƒ    (   x'  y'  z' :  â„• ) ,   PythagoreanTriple  x' y' z' âˆ§   x' > x âˆ§   y' > y âˆ§  z' > z",
    " âˆ€   (  x y z  :  â„¤  )  ,  âˆƒ    (   a  b  c :  â„¤ ) ,   PythagoreanTriple  a b c âˆ§   a > x âˆ§   b > y âˆ§  c > z",
    " âˆ€   (  n  :  â„•  )  ,  âˆƒ    (   x  y  z :  â„• ) ,     x ^  2 +  y ^  2 =  z ^  2 âˆ§   x >  0 âˆ§   y >  0 âˆ§   z >  0 âˆ§    x + y + z = n",
    " âˆ€   (  n  :  â„•  )  ,  âˆƒ    (   x  y  z :  â„• ) ,     x * x +  y * y =  z * z âˆ§  z > n",
    " âˆ€   (  n  :  â„•  )  ,  âˆƒ    (   x  y  z :  â„• ) ,   PythagoreanTriple  x y z âˆ§  x â‰¤ n",
    " âˆ€   (  m n  :  â„•  )  ,  âˆƒ    (   x  y  z :  â„• ) ,     x * x +  y * y =  z * z âˆ§   x â‰   0 âˆ§   y â‰   0 âˆ§  z â‰   0",
    " âˆ€   (  n  :  â„•  )  ,  âˆƒ    (   x  y  z :  â„• ) ,     x ^  2 +  y ^  2 =  z ^  2 âˆ§  x â‰¥ n",
    " âˆ€   (  n  :  â„•  )  ,  âˆƒ    (   x  y  z :  â„• ) ,   PythagoreanTriple  x y z âˆ§  x > n",
    " âˆ€   (  z  :  â„•  )  ,  âˆƒ    (   x  y :  â„• ) ,  PythagoreanTriple  x y z"]},
  {"theorem":
   "âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} (s : Set Î±), MeasurableSet s",
   "prompt": "Every set is Lebesgue measurable.",
   "all-elabs":
   [" {  Î± :  Type  u_1 } ->  {  m :  MeasurableSpace  Î± } ->  (  s :  Set  Î± ) ->  MeasurableSet  s",
    " {  Î± :  Type  u_1 } ->  {  m :  MeasurableSpace  Î± } ->  âˆ€   (  s  :  Set  Î±  )  ,  MeasurableSet  s",
    " {  Î± :  Type* } ->  MeasurableSpace  Î±",
    " {  Î± :  Type  u_1 } ->  [  TopologicalSpace  Î± ] ->  [  TopologicalSpace.PseudoMetrizableSpace  Î± ] ->  [  MeasurableSpace  Î± ] ->  [  BorelSpace  Î± ] ->  (  s :  Set  Î± ) ->  MeasurableSet  s"]},
  {"theorem":
   "âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] (A : Set Î±), coeFn MeasureTheory.volume.toOuterMeasure A = 0",
   "prompt": "Every set has Lebesgue measure zero.",
   "all-elabs":
   [" {  Î± :  Type  u_1 } ->  [  MeasurableSpace  Î± ] ->  âˆ€   (  A  :  Set  Î±  )  ,   MeasureTheory.MeasureSpace.volume  A =  0",
    " âˆ€   {  Î±  :  Type  u_1 }  {  s  :  Set  Î± }  ,   MeasureTheory.MeasureSpace.volume  s =  0",
    " {  Î± :  Type  u } ->  [  MeasurableSpace  Î± ] ->  âˆ€   {  s  :  Set  Î± }  ,   MeasureTheory.MeasureSpace.volume  s =  0",
    " {  Î± :  Type  u_1 } ->  [  MeasurableSpace  Î± ] ->  (  s :  Set  Î± ) ->   MeasureTheory.MeasureSpace.volume  s =  0",
    " {  Î± :  Type  u_1 } ->  [  MeasurableSpace  Î± ] ->  {  s :  Set  Î± } ->   MeasureTheory.MeasureSpace.volume  s =  0",
    " {  Î± :  Type  u_1 } ->  âˆ€   (  s  :  Set  Î±  )  ,   MeasureTheory.MeasureSpace.volume  s =  0",
    " {  Î± :  Type  u_1 } ->  (  s :  Set  Î± ) ->   MeasureTheory.MeasureSpace.volume  s =  0",
    " {  Î± :  Type  u_1 } ->  {  s :  Set  Î± } ->   MeasureTheory.MeasureSpace.volume  s =  0"]},
  {"theorem":
   "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±}, (âˆ€ (t : Set Î±), IsClosed t â†’ s â‰  t â†’ IsCompact t) â†’ IsCompact s",
   "prompt":
   "If every proper closed set of a topological space is compact, then the space itself is compact.",
   "all-elabs":
   [" {  Î± :  Type  u } ->  [  TopologicalSpace  Î± ] ->  {  s :  Set  Î± } ->  (  h :  âˆ€   (  t  :  Set  Î±  )  (  ht  :  IsClosed  t  )  (  hne  :  s â‰  t  )  ,  IsCompact  t ) ->  IsCompact  s"]},
  {"theorem":
   "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±], CompactSpace Î± â†’ âˆ€ (s : Set Î±), IsCompact s",
   "prompt": "If a topological space is compact, then every subset is compact.",
   "all-elabs":
   [" {  Î± :  Type  u } ->  [  TopologicalSpace  Î± ] ->  (  h :  CompactSpace  Î± ) ->  (  s :  Set  Î± ) ->  IsCompact  s",
    " {  Î± :  Type  u } ->  [  TopologicalSpace  Î± ] ->  (  h :  IsCompact  Î± ) ->  (  s :  Set  Î± ) ->  IsCompact  s",
    " {  Î± :  Type  u } ->  [  TopologicalSpace  Î± ] ->  (  h :  IsCompact  Î± ) ->  {  s :  Set  Î± } ->  IsCompact  s",
    " {  Î± :  Type  u } ->  [  TopologicalSpace  Î± ] ->  (  hÎ± :  IsCompact  Î± ) ->  (  s :  Set  Î± ) ->  IsCompact  s",
    " {  Î± :  Type  u } ->  [  TopologicalSpace  Î± ] ->  [  CompactSpace  Î± ] ->  {  s :  Set  Î± } ->  IsCompact  s",
    " {  Î± :  Type  u } ->  [  TopologicalSpace  Î± ] ->  [  CompactSpace  Î± ] ->  (  s :  Set  Î± ) ->  IsCompact  s",
    " {  Î± :  Type* } ->  [  TopologicalSpace  Î± ] ->  [  CompactSpace  Î± ] ->  {  s :  Set  Î± } ->  IsCompact  s",
    " {  Î± :  Type  u } ->  [  TopologicalSpace  Î± ] ->  (  h :  CompactSpace  Î± ) ->  {  s :  Set  Î± } ->  IsCompact  s"]},
  {"theorem":
   "âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], p % 4 = 1 â†’ âˆƒ a b, a ^ 2 + b ^ 2 = p",
   "prompt":
   "Every prime that is one greater than a multiple of four can be expressed as the sum of two squares.",
   "all-elabs":
   [" (  p :  â„• ) ->  [  Fact   (   Nat.Prime  p  ) ] ->  (  hp4 :   p %  4 =  1 ) ->  âˆƒ    (   a  b :  â„• ) ,    a ^  2 +  b ^  2 = p",
    " {  p :  â„• } ->  [  Fact   (   Nat.Prime  p  ) ] ->  (  hp :   p %  4 =  1 ) ->  âˆƒ    (   a  b :  â„• ) ,    a ^  2 +  b ^  2 = p",
    " {  p :  â„• } ->  [  Fact   (   Nat.Prime  p  ) ] ->  (  h :   p %  4 =  1 ) ->  âˆƒ    (   a  b :  â„• ) ,    a ^  2 +  b ^  2 = p",
    " (  p :  â„• ) ->  [  Fact   (   Nat.Prime  p  ) ] ->  (  h :   p %  4 =  1 ) ->  âˆƒ    (   a  b :  â„• ) ,    a ^  2 +  b ^  2 = p",
    " {  p :  â„• } ->  (  hp :  Nat.Prime  p ) ->  (  h :   p %  4 =  1 ) ->  âˆƒ    (   a  b :  â„• ) ,    a ^  2 +  b ^  2 = p",
    " (  p :  â„• ) ->  [  Fact   (   Nat.Prime  p  ) ] ->  (  hp :   p %  4 =  1 ) ->  âˆƒ    (   a  b :  â„• ) ,    a ^  2 +  b ^  2 = p"]},
  {"theorem": "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], Â¬âˆƒ n, n * n = p",
   "prompt": "No prime number is a perfect square.",
   "all-elabs":
   [" {  p :  â„• } ->  [  Fact   (   Nat.Prime  p  ) ] ->  Â¬  âˆƒ    (   n :  â„• ) ,   n * n = p",
    " {  p :  â„• } ->  [  Fact   (   Nat.Prime  p  ) ] ->  Â¬  âˆƒ    (   n :  â„• ) ,   n ^  2 = p",
    " {  n :  â„• } ->  [  Fact   (   Nat.Prime  n  ) ] ->  âˆ€   (  m  :  â„•  )  ,   m * m â‰  n",
    " {  p :  â„• } ->  [  Fact   (   Nat.Prime  p  ) ] ->  Â¬  âˆƒ    (   m :  â„• ) ,   m * m = p",
    " {  p :  â„• } ->  [  Fact   (   Nat.Prime  p  ) ] ->  Â¬  âˆƒ    (   t :  â„• ) ,   t * t = p"]},
  {"theorem": "âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], p > 2",
   "prompt": "Every odd prime number is greater than `2`.",
   "all-elabs":
   [" (  p :  â„• ) ->  [  Fact   (   Nat.Prime  p  ) ] ->  p >  2",
    " (  p :  â„• ) ->  [  Fact   (   Nat.Prime  p  ) ] ->  (  h :  Odd  p ) ->  p >  2",
    " (  p :  â„• ) ->  [  Fact   (   Nat.Prime  p  ) ] ->  (  h :  Odd  p ) ->   2 < p",
    " (  p :  â„• ) ->  [  Fact   (   Nat.Prime  p  ) ] ->  (  h :   p %  2 =  1 ) ->   2 < p",
    " (  p :  â„• ) ->  [  Fact   (   Nat.Prime  p  ) ] ->  (  h_odd :   p %  2 =  1 ) ->   2 < p",
    " (  p :  â„• ) ->  [ hpri :  Fact   (   Nat.Prime  p  ) ] ->  (  h :   p %  2 =  1 ) ->   2 < p",
    " (  p :  â„• ) ->  [  Fact   (   Nat.Prime  p  ) ] ->  (  h :   p %  2 =  1 ) ->  p >  2",
    " {  p :  â„• } ->  (  h_p_odd :  Odd  p ) ->  (  h_p_prime :  Nat.Prime  p ) ->   2 < p"]},
  {"theorem":
   "âˆ€ {ð•œ : Type u_1} {E : Type u_2} [inst : LinearOrderedRing ð•œ] [inst_1 : AddCommGroupâ‚“ E] [inst_2 : Module ð•œ E]\n  [inst_3 : DenselyOrdered ð•œ] [inst_4 : NoZeroSmulDivisors ð•œ E] {A : Set E} {xâ‚ xâ‚‚ : E},\n  xâ‚ âˆˆ A â†’ xâ‚‚ âˆˆ A â†’ Segment ð•œ xâ‚ xâ‚‚ âŠ‚ A",
   "prompt":
   "Every line segments whose endpoints are in a convex set `C` is contained in `C`.",
   "all-elabs":
   [" {  ð•œ :  Type  u_1 } ->  {  E :  Type  u_2 } ->  [  LinearOrderedRing  ð•œ ] ->  [  AddCommGroupâ‚“  E ] ->  [  Module  ð•œ E ] ->  [  DenselyOrdered  ð•œ ] ->  [  NoZeroSmulDivisors  ð•œ E ] ->  {  A :  Set  E } ->  {  xâ‚ xâ‚‚ : E } ->   xâ‚ âˆˆ A â†’   xâ‚‚ âˆˆ A â†’   Segment  ð•œ xâ‚ xâ‚‚ âŠ† A",
    " {  ð•œ :  Type  u_1 } ->  {  E :  Type  u_2 } ->  [  LinearOrderedRing  ð•œ ] ->  [  AddCommGroupâ‚“  E ] ->  [  Module  ð•œ E ] ->  [  DenselyOrdered  ð•œ ] ->  [  NoZeroSmulDivisors  ð•œ E ] ->  {  A :  Set  E } ->  {  xâ‚ xâ‚‚ : E } ->   xâ‚ âˆˆ A â†’   xâ‚‚ âˆˆ A â†’   xâ‚ â‰  xâ‚‚ â†’   Segment  ð•œ xâ‚ xâ‚‚ âŠ† A",
    " {  ð•œ :  Type  u_1 } ->  {  E :  Type  u_2 } ->  [  LinearOrderedRing  ð•œ ] ->  [  AddCommGroupâ‚“  E ] ->  [  Module  ð•œ E ] ->  [  DenselyOrdered  ð•œ ] ->  [  NoZeroSmulDivisors  ð•œ E ] ->  {  A :  Set  E } ->  {  xâ‚ : E } ->  {  xâ‚‚ : E } ->   xâ‚ âˆˆ A â†’   xâ‚‚ âˆˆ A â†’   Segment  ð•œ xâ‚ xâ‚‚ âŠ† A",
    " {  ð•œ :  Type  u_1 } ->  {  E :  Type  u_2 } ->  [  LinearOrderedField  ð•œ ] ->  [  AddCommGroupâ‚“  E ] ->  [  Module  ð•œ E ] ->  [  DenselyOrdered  ð•œ ] ->  [  NoZeroSmulDivisors  ð•œ E ] ->  {  C :  Set  E } ->  (  x y : E ) ->  (  Hx :  x âˆˆ C ) ->  (  Hy :  y âˆˆ C ) ->   Segment  ð•œ x y âŠ† C",
    " {  ð•œ :  Type  u_1 } ->  {  E :  Type  u_2 } ->  [  LinearOrderedRing  ð•œ ] ->  [  AddCommGroupâ‚“  E ] ->  [  Module  ð•œ E ] ->  [  DenselyOrdered  ð•œ ] ->  [  NoZeroSmulDivisors  ð•œ E ] ->  {  C :  Set  E } ->  {  xâ‚ : E } ->  {  xâ‚‚ : E } ->   xâ‚ âˆˆ C â†’   xâ‚‚ âˆˆ C â†’   Segment  ð•œ xâ‚ xâ‚‚ âŠ† C",
    " {  ð•œ :  Type  u_1 } ->  {  E :  Type  u_2 } ->  [  LinearOrderedRing  ð•œ ] ->  [  AddCommGroupâ‚“  E ] ->  [  Module  ð•œ E ] ->  [  DenselyOrdered  ð•œ ] ->  [  NoZeroSmulDivisors  ð•œ E ] ->  {  A :  Set  E } ->  {  xâ‚ xâ‚‚ : E } ->  (  hxâ‚ :  xâ‚ âˆˆ A ) ->  (  hxâ‚‚ :  xâ‚‚ âˆˆ A ) ->   Segment  ð•œ xâ‚ xâ‚‚ âŠ† A",
    " {  ð•œ :  Type  u_1 } ->  {  E :  Type  u_2 } ->  [  LinearOrderedRing  ð•œ ] ->  [  AddCommGroupâ‚“  E ] ->  [  Module  ð•œ E ] ->  [  DenselyOrdered  ð•œ ] ->  [  NoZeroSmulDivisors  ð•œ E ] ->  {  C :  Set  E } ->  (  H :  Convex  ð•œ C ) ->  {  xâ‚ xâ‚‚ : E } ->  (  Hâ‚ :  xâ‚ âˆˆ C ) ->  (  Hâ‚‚ :  xâ‚‚ âˆˆ C ) ->   Segment  ð•œ xâ‚ xâ‚‚ âŠ† C"]},
  {"theorem":
   "âˆ€ {a b : â„•},\n  âˆƒ x y z w,\n    a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 âˆ§ b = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 â†”\n      âˆƒ x y z w, a * b = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2",
   "prompt":
   "The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares.",
   "all-elabs":
   [" {  a b :  â„• } ->  âˆƒ    (   x  y  z  w :  â„• ) ,    a =     x ^  2 +  y ^  2 +  z ^  2 +  w ^  2 âˆ§  b =     x ^  2 +  y ^  2 +  z ^  2 +  w ^  2 â†”  âˆƒ    (   x  y  z  w :  â„• ) ,   a * b =     x ^  2 +  y ^  2 +  z ^  2 +  w ^  2",
    " {  a b :  â„• } ->  (  ha :  âˆƒ    (   x  y  z  w :  â„• ) ,  a =     x ^  2 +  y ^  2 +  z ^  2 +  w ^  2 ) ->  (  hb :  âˆƒ    (   x  y  z  w :  â„• ) ,  b =     x ^  2 +  y ^  2 +  z ^  2 +  w ^  2 ) ->  âˆƒ    (   x  y  z  w :  â„• ) ,   a * b =     x ^  2 +  y ^  2 +  z ^  2 +  w ^  2",
    " {  a b :  â„• } ->  (  hâ‚ :  âˆƒ    (   x  y  z  w :  â„• ) ,  a =     x ^  2 +  y ^  2 +  z ^  2 +  w ^  2 ) ->  (  hâ‚‚ :  âˆƒ    (   x  y  z  w :  â„• ) ,  b =     x ^  2 +  y ^  2 +  z ^  2 +  w ^  2 ) ->  âˆƒ    (   x  y  z  w :  â„• ) ,   a * b =     x ^  2 +  y ^  2 +  z ^  2 +  w ^  2",
    " {  Î± :  Type  u } ->  [  CommRing  Î± ] ->  {  x y : Î± } ->  (  hx :  âˆƒ    (   a  b  c  d : Î± ) ,  x =     a ^  2 +  b ^  2 +  c ^  2 +  d ^  2 ) ->  (  hy :  âˆƒ    (   a  b  c  d : Î± ) ,  y =     a ^  2 +  b ^  2 +  c ^  2 +  d ^  2 ) ->  âˆƒ    (   a  b  c  d : Î± ) ,   x * y =     a ^  2 +  b ^  2 +  c ^  2 +  d ^  2",
    " {  Î± :  Type  u } ->  [  CommRingâ‚“  Î± ] ->  {  x y : Î± } ->  (  hx :  âˆƒ    (   a  b  c  d : Î± ) ,  x =     a ^  2 +  b ^  2 +  c ^  2 +  d ^  2 ) ->  (  hy :  âˆƒ    (   a  b  c  d : Î± ) ,  y =     a ^  2 +  b ^  2 +  c ^  2 +  d ^  2 ) ->  âˆƒ    (   a  b  c  d : Î± ) ,   x * y =     a ^  2 +  b ^  2 +  c ^  2 +  d ^  2",
    " {  Î± :  Type  u } ->  [  Ring  Î± ] ->  {  a b : Î± } ->  (  hab :  âˆƒ    (   x  y  z  w : Î± ) ,  a =     x ^  2 +  y ^  2 +  z ^  2 +  w ^  2 ) ->  (  hba :  âˆƒ    (   x  y  z  w : Î± ) ,  b =     x ^  2 +  y ^  2 +  z ^  2 +  w ^  2 ) ->  âˆƒ    (   x  y  z  w : Î± ) ,   a * b =     x ^  2 +  y ^  2 +  z ^  2 +  w ^  2",
    " {  Î± :  Type  u } ->  [  Ringâ‚“  Î± ] ->  {  a b : Î± } ->  (  hab :  âˆƒ    (   x  y  z  w : Î± ) ,  a =     x ^  2 +  y ^  2 +  z ^  2 +  w ^  2 ) ->  (  hba :  âˆƒ    (   x  y  z  w : Î± ) ,  b =     x ^  2 +  y ^  2 +  z ^  2 +  w ^  2 ) ->  âˆƒ    (   x  y  z  w : Î± ) ,   a * b =     x ^  2 +  y ^  2 +  z ^  2 +  w ^  2",
    " {  Î± :  Type  u } ->  [  Field  Î± ] ->  {  x y : Î± } ->  (  hx :  âˆƒ    (   a  b  c  d : Î± ) ,  x =     a * a +  b * b +  c * c +  d * d ) ->  (  hy :  âˆƒ    (   a  b  c  d : Î± ) ,  y =     a * a +  b * b +  c * c +  d * d ) ->  âˆƒ    (   a  b  c  d : Î± ) ,   x * y =     a * a +  b * b +  c * c +  d * d",
    " {  Î± :  Type  u } ->  [  LinearOrderedRing  Î± ] ->  {  x y : Î± } ->  (  hx :  âˆƒ     a  b  c  d  : Î± ,  x =     a ^  2 +  b ^  2 +  c ^  2 +  d ^  2 ) ->  (  hy :  âˆƒ     a  b  c  d  : Î± ,  y =     a ^  2 +  b ^  2 +  c ^  2 +  d ^  2 ) ->  âˆƒ     a  b  c  d  : Î± ,   x * y =     a ^  2 +  b ^  2 +  c ^  2 +  d ^  2"]},
  {"theorem":
   "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X",
   "prompt": "Every compact topological space is locally compact.",
   "all-elabs":
   [" {  X :  Type  u_1 } ->  [  TopologicalSpace  X ] ->  [  CompactSpace  X ] ->  LocallyCompactSpace  X",
    " {  Î± :  Type  u } ->  [  TopologicalSpace  Î± ] ->  [  CompactSpace  Î± ] ->  LocallyCompactSpace  Î±",
    " {  X :  Type  u } ->  [  TopologicalSpace  X ] ->  [  CompactSpace  X ] ->  LocallyCompactSpace  X",
    " {  X :  Type  u_1 } ->  [  TopologicalSpace  X ] ->  (  hX :  CompactSpace  X ) ->  LocallyCompactSpace  X"]},
  {"theorem":
   "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {f : Î± â†’ Î²},\n  Continuous f â†’ UniformContinuous f",
   "prompt": "Every continuous function is uniformly continuous.",
   "all-elabs":
   [" {  Î± :  Type  u_1 } ->  {  Î² :  Type  u_2 } ->  [  UniformSpace  Î± ] ->  [  UniformSpace  Î² ] ->  {  f :  Î± â†’ Î² } ->  (  hf :  Continuous  f ) ->  UniformContinuous  f",
    " {  Î± :  Type  u } ->  {  Î² :  Type  v } ->  [  UniformSpace  Î± ] ->  [  UniformSpace  Î² ] ->  {  f :  Î± â†’ Î² } ->  (  hf :  Continuous  f ) ->  UniformContinuous  f"]}],
 "elaborated": 30}