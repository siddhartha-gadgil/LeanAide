theorem cont_mdiff_iff {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {M : Type u_4} [topological_space M] [charted_space H M] [Is : smooth_manifold_with_corners I M] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners ğ•œ E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] [I's : smooth_manifold_with_corners I' M'] {f : M â†’ M'} {n : with_top â„•} : cont_mdiff I I' n f â†” continuous f âˆ§ âˆ€ (x : M) (y : M'), cont_diff_on ğ•œ n (â‡‘(ext_chart_at I' y) âˆ˜ f âˆ˜ â‡‘((ext_chart_at I x).symm)) ((ext_chart_at I x).target âˆ© â‡‘((ext_chart_at I x).symm) â»Â¹' (f â»Â¹' (ext_chart_at I' y).source))
theorem nndist_triangle {Î± : Type u} [pseudo_metric_space Î±] (x y z : Î±) : has_nndist.nndist x z â‰¤ has_nndist.nndist x y + has_nndist.nndist y z
theorem is_noetherian.iff_dim_lt_aleph_0 {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] : is_noetherian K V â†” module.rank K V < cardinal.aleph_0
theorem finset.sum_card_inter_le {Î± : Type u_2} [decidable_eq Î±] {s : finset Î±} {B : finset (finset Î±)} {n : â„•} (h : âˆ€ (a : Î±), a âˆˆ s â†’ (finset.filter (has_mem.mem a) B).card â‰¤ n) : B.sum (Î» (t : finset Î±), (s âˆ© t).card) â‰¤ s.card * n
theorem basis.ext_multilinear_fin {R : Type u_1} {n : â„•} {M : fin n â†’ Type u_3} {Mâ‚‚ : Type u_4} [comm_semiring R] [add_comm_monoid Mâ‚‚] [Î  (i : fin n), add_comm_monoid (M i)] [Î  (i : fin n), module R (M i)] [module R Mâ‚‚] {f g : multilinear_map R M Mâ‚‚} {Î¹â‚ : fin n â†’ Type u_2} (e : Î  (i : fin n), basis (Î¹â‚ i) R (M i)) (h : âˆ€ (v : Î  (i : fin n), Î¹â‚ i), â‡‘f (Î» (i : fin n), â‡‘(e i) (v i)) = â‡‘g (Î» (i : fin n), â‡‘(e i) (v i))) : f = g
theorem tangent_bundle_proj_open {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] (I : model_with_corners ğ•œ E H) (M : Type u_4) [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] : is_open_map (tangent_bundle.proj I M)
theorem Top.presheaf.section_ext {C : Type u} [category_theory.category C] [category_theory.limits.has_colimits C] {X : Top} [category_theory.concrete_category C] [category_theory.limits.preserves_filtered_colimits (category_theory.forget C)] [category_theory.limits.has_limits C] [category_theory.limits.preserves_limits (category_theory.forget C)] [category_theory.reflects_isomorphisms (category_theory.forget C)] (F : Top.sheaf C X) (U : topological_space.opens â†¥X) (s t : â†¥(F.val.obj (opposite.op U))) (h : âˆ€ (x : â†¥U), â‡‘(F.val.germ x) s = â‡‘(F.val.germ x) t) : s = t
theorem list.sum_drop_succ {G : Type u_7} [add_group G] (L : list G) (i : â„•) (p : i < L.length) : (list.drop (i + 1) L).sum = -L.nth_le i p + (list.drop i L).sum
theorem sub_lt_zero {Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b : Î±} : a - b < 0 â†” a < b
theorem balanced.smul_mono {ğ•œ : Type u_1} {ğ• : Type u_2} {E : Type u_3} [normed_field ğ•œ] [normed_ring ğ•] [normed_space ğ•œ ğ•] [add_comm_group E] [module ğ•œ E] [smul_with_zero ğ• E] [is_scalar_tower ğ•œ ğ• E] {s : set E} (hs : balanced ğ• s) {a : ğ•} {b : ğ•œ} (h : âˆ¥aâˆ¥ â‰¤ âˆ¥bâˆ¥) : a â€¢ s âŠ† b â€¢ s
theorem category_theory.right_lifting_property_initial_iff {C : Type u} [category_theory.category C] (i p : category_theory.arrow C) (h : category_theory.limits.is_initial i.left) : category_theory.has_lifting_property i p â†” âˆ€ {e : i.right âŸ¶ p.right}, âˆƒ (l : i.right âŸ¶ p.left), l â‰« p.hom = e
theorem zero_lt.preorder.left.mul_le_one_of_le_of_le' {Î± : Type u} {a b : Î±} [mul_one_class Î±] [has_zero Î±] [preorder Î±] [zero_lt.pos_mul_mono Î±] (ha : a â‰¤ 1) (hb : b â‰¤ 1) (a0 : 0 < a) : a * b â‰¤ 1
theorem polynomial.X_pow_sub_one_dvd_prod_cyclotomic (R : Type u_1) [comm_ring R] {n m : â„•} (hpos : 0 < n) (hm : m âˆ£ n) (hdiff : m â‰  n) : polynomial.X ^ m - 1 âˆ£ n.proper_divisors.prod (Î» (i : â„•), polynomial.cyclotomic i R)
theorem mul_equiv.apply_symm_apply {M : Type u_6} {N : Type u_7} [has_mul M] [has_mul N] (e : M â‰ƒ* N) (y : N) : â‡‘e (â‡‘(e.symm) y) = y
theorem witt_vector.verschiebung_fun_is_poly (p : â„•) : witt_vector.is_poly p (Î» (R : Type u_1) (_Rcr : comm_ring R), witt_vector.verschiebung_fun)
theorem cont_diff.continuous_linear_map_comp {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {G : Type u_4} [normed_group G] [normed_space ğ•œ G] {n : with_top â„•} {f : E â†’ F} (g : F â†’L[ğ•œ] G) (hf : cont_diff ğ•œ n f) : cont_diff ğ•œ n (Î» (x : E), â‡‘g (f x))
theorem add_units.is_add_regular {R : Type u_1} [add_monoid R] (a : add_units R) : is_add_regular â†‘a
theorem quasi_sober_of_open_cover {Î± : Type u_1} [topological_space Î±] (S : set (set Î±)) (hS : âˆ€ (s : â†¥S), is_open â†‘s) [hS' : âˆ€ (s : â†¥S), quasi_sober â†¥s] (hS'' : â‹ƒâ‚€S = âŠ¤) : quasi_sober Î±
theorem matrix.is_diag_of_subsingleton {Î± : Type u_1} {n : Type u_4} [has_zero Î±] [subsingleton n] (A : matrix n n Î±) : A.is_diag
theorem metric.tendsto_locally_uniformly_iff {Î± : Type u} {Î² : Type v} [pseudo_metric_space Î±] {Î¹ : Type u_1} [topological_space Î²] {F : Î¹ â†’ Î² â†’ Î±} {f : Î² â†’ Î±} {p : filter Î¹} : tendsto_locally_uniformly F f p â†” âˆ€ (Îµ : â„), Îµ > 0 â†’ âˆ€ (x : Î²), âˆƒ (t : set Î²) (H : t âˆˆ nhds x), âˆ€á¶  (n : Î¹) in p, âˆ€ (y : Î²), y âˆˆ t â†’ has_dist.dist (f y) (F n y) < Îµ
theorem interval_integral.deriv_within_integral_of_tendsto_ae_right {E : Type u_3} [normed_group E] [complete_space E] [normed_space â„ E] {f : â„ â†’ E} {c : E} {a b : â„} (hf : interval_integrable f measure_theory.measure_space.volume a b) {s t : set â„} [interval_integral.FTC_filter b (nhds_within b s) (nhds_within b t)] (hmeas : strongly_measurable_at_filter f (nhds_within b t) measure_theory.measure_space.volume) (hb : filter.tendsto f (nhds_within b t âŠ“ measure_theory.measure_space.volume.ae) (nhds c)) (hs : unique_diff_within_at â„ s b . "unique_diff_within_at_Ici_Iic_univ") : deriv_within (Î» (u : â„), âˆ« (x : â„) in a..u, f x) s b = c
theorem category_theory.sieve.id_mem_iff_eq_top {C : Type uâ‚} [category_theory.category C] {X : C} {S : category_theory.sieve X} : â‡‘S (ğŸ™ X) â†” S = âŠ¤
theorem euclidean_geometry.dist_sq_eq_dist_sq_add_dist_sq_iff_angle_eq_pi_div_two {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] (p1 p2 p3 : P) : has_dist.dist p1 p3 * has_dist.dist p1 p3 = has_dist.dist p1 p2 * has_dist.dist p1 p2 + has_dist.dist p3 p2 * has_dist.dist p3 p2 â†” euclidean_geometry.angle p1 p2 p3 = real.pi / 2
theorem linear_map.bot_lt_ker_of_det_eq_zero {M : Type u_2} [add_comm_group M] {ğ•œ : Type u_1} [field ğ•œ] [module ğ•œ M] {f : M â†’â‚—[ğ•œ] M} (hf : â‡‘linear_map.det f = 0) : âŠ¥ < f.ker
theorem matrix.dot_product_mul_vec {m : Type u_2} {n : Type u_3} {R : Type u_7} [fintype n] [fintype m] [non_unital_semiring R] (v : m â†’ R) (A : matrix m n R) (w : n â†’ R) : matrix.dot_product v (A.mul_vec w) = matrix.dot_product (matrix.vec_mul v A) w
theorem category_theory.abelian_of_adjunction.has_kernels {C : Type uâ‚} [category_theory.category C] [category_theory.preadditive C] {D : Type uâ‚‚} [category_theory.category D] [category_theory.abelian D] (F : C â¥¤ D) (G : D â¥¤ C) [G.preserves_zero_morphisms] (i : F â‹™ G â‰… ğŸ­ C) [category_theory.limits.preserves_finite_limits G] : category_theory.limits.has_kernels C
theorem measure_theory.Lp.ae_eq_of_forall_set_integral_eq' {Î± : Type u_1} {E' : Type u_5} {ğ•œ : Type u_11} {p : ennreal} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E'] [complete_space E'] [normed_space â„ E'] {m m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (hm : m â‰¤ m0) (f g : â†¥(measure_theory.Lp E' p Î¼)) (hp_ne_zero : p â‰  0) (hp_ne_top : p â‰  âŠ¤) (hf_int_finite : âˆ€ (s : set Î±), measurable_set s â†’ â‡‘Î¼ s < âŠ¤ â†’ measure_theory.integrable_on â‡‘f s Î¼) (hg_int_finite : âˆ€ (s : set Î±), measurable_set s â†’ â‡‘Î¼ s < âŠ¤ â†’ measure_theory.integrable_on â‡‘g s Î¼) (hfg : âˆ€ (s : set Î±), measurable_set s â†’ â‡‘Î¼ s < âŠ¤ â†’ âˆ« (x : Î±) in s, â‡‘f x âˆ‚Î¼ = âˆ« (x : Î±) in s, â‡‘g x âˆ‚Î¼) (hf_meas : measure_theory.ae_strongly_measurable' m â‡‘f Î¼) (hg_meas : measure_theory.ae_strongly_measurable' m â‡‘g Î¼) : â‡‘f =áµ[Î¼] â‡‘g
theorem simple_graph.adj_iff_exists_edge {V : Type u} (G : simple_graph V) {v w : V} : G.adj v w â†” v â‰  w âˆ§ âˆƒ (e : sym2 V) (H : e âˆˆ G.edge_set), v âˆˆ e âˆ§ w âˆˆ e
theorem set.nonempty.convex_hull {ğ•œ : Type u_1} {E : Type u_2} [ordered_semiring ğ•œ] [add_comm_monoid E] [module ğ•œ E] {s : set E} : s.nonempty â†’ (â‡‘(convex_hull ğ•œ) s).nonempty
theorem exists_prime_add_order_of_dvd_card {G : Type u_1} [add_group G] [fintype G] (p : â„•) [hp : fact (nat.prime p)] (hdvd : p âˆ£ fintype.card G) : âˆƒ (x : G), add_order_of x = p
theorem has_ssubset.ssubset.trans_subset {Î± : Type u} [has_subset Î±] [has_ssubset Î±] [is_nonstrict_strict_order Î± has_subset.subset has_ssubset.ssubset] {a b c : Î±} [is_trans Î± has_subset.subset] (hâ‚ : a âŠ‚ b) (hâ‚‚ : b âŠ† c) : a âŠ‚ c
theorem interval_integral.continuous_of_dominated_interval {E : Type u_3} [normed_group E] [complete_space E] [normed_space â„ E] {Î¼ : measure_theory.measure â„} {X : Type u_5} [topological_space X] [topological_space.first_countable_topology X] {F : X â†’ â„ â†’ E} {bound : â„ â†’ â„} {a b : â„} (hF_meas : âˆ€ (x : X), measure_theory.ae_strongly_measurable (F x) (Î¼.restrict (set.interval_oc a b))) (h_bound : âˆ€ (x : X), âˆ€áµ (t : â„) âˆ‚Î¼, t âˆˆ set.interval_oc a b â†’ âˆ¥F x tâˆ¥ â‰¤ bound t) (bound_integrable : interval_integrable bound Î¼ a b) (h_cont : âˆ€áµ (t : â„) âˆ‚Î¼, t âˆˆ set.interval_oc a b â†’ continuous (Î» (x : X), F x t)) : continuous (Î» (x : X), âˆ« (t : â„) in a..b, F x t âˆ‚Î¼)
theorem ring_hom.ker_lift_injective {R : Type u} {S : Type v} [comm_ring R] [comm_ring S] (f : R â†’+* S) : function.injective â‡‘(f.ker_lift)
theorem finset.sum_range_sub {G : Type u_1} [add_comm_group G] (f : â„• â†’ G) (n : â„•) : (finset.range n).sum (Î» (i : â„•), f (i + 1) - f i) = f n - f 0
theorem submodule.span_algebra_map_image {R : Type u} {S : Type v} [comm_semiring R] [semiring S] [algebra R S] (a : set R) : submodule.span R (â‡‘(algebra_map R S) '' a) = submodule.map (algebra.linear_map R S) (submodule.span R a)
theorem linear_map.det_aux_def {M : Type u_2} [add_comm_group M] {Î¹ : Type u_4} [decidable_eq Î¹] [fintype Î¹] {A : Type u_5} [comm_ring A] [module A M] (b : basis Î¹ A M) (f : M â†’â‚—[A] M) : â‡‘(linear_map.det_aux (trunc.mk b)) f = (â‡‘(linear_map.to_matrix b b) f).det
theorem list.sublist_iff_exists_order_embedding_nth_eq {Î± : Type u_1} {l l' : list Î±} : l <+ l' â†” âˆƒ (f : â„• â†ªo â„•), âˆ€ (ix : â„•), l.nth ix = l'.nth (â‡‘f ix)
theorem measure_theory.add_haar_image_eq_zero_of_det_fderiv_within_eq_zero {E : Type u_1} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] {s : set E} {f : E â†’ E} {f' : E â†’ (E â†’L[â„] E)} [measurable_space E] [borel_space E] (Î¼ : measure_theory.measure E) [Î¼.is_add_haar_measure] (hf' : âˆ€ (x : E), x âˆˆ s â†’ has_fderiv_within_at f (f' x) s x) (h'f' : âˆ€ (x : E), x âˆˆ s â†’ (f' x).det = 0) : â‡‘Î¼ (f '' s) = 0
theorem category_theory.has_right_lifting_property_comp {C : Type u} [category_theory.category C] {X Y Z : C} {i : category_theory.arrow C} {f : X âŸ¶ Y} {g : Y âŸ¶ Z} (hf : category_theory.has_lifting_property i (category_theory.arrow.mk f)) (hg : category_theory.has_lifting_property i (category_theory.arrow.mk g)) : category_theory.has_lifting_property i (category_theory.arrow.mk (f â‰« g))
theorem has_lt.lt.of_dual {Î± : Type u_1} [has_lt Î±] {a b : Î±áµ’áµˆ} : b < a â†’ â‡‘order_dual.of_dual a < â‡‘order_dual.of_dual b
theorem local_homeomorph.eq_on_source.target_eq {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] {e e' : local_homeomorph Î± Î²} (h : e â‰ˆ e') : e.to_local_equiv.target = e'.to_local_equiv.target
theorem inner_product_space.is_self_adjoint.conj_eigenvalue_eq_self {ğ•œ : Type u_1} [is_R_or_C ğ•œ] {E : Type u_2} [inner_product_space ğ•œ E] {T : E â†’â‚—[ğ•œ] E} (hT : inner_product_space.is_self_adjoint T) {Î¼ : ğ•œ} (hÎ¼ : module.End.has_eigenvalue T Î¼) : â‡‘(star_ring_end ğ•œ) Î¼ = Î¼
theorem countable_cover_nhds_within_of_sigma_compact {Î± : Type u} [topological_space Î±] [sigma_compact_space Î±] {f : Î± â†’ set Î±} {s : set Î±} (hs : is_closed s) (hf : âˆ€ (x : Î±), x âˆˆ s â†’ f x âˆˆ nhds_within x s) : âˆƒ (t : set Î±) (H : t âŠ† s), t.countable âˆ§ s âŠ† â‹ƒ (x : Î±) (H : x âˆˆ t), f x
theorem phragmen_lindelof.eq_on_horizontal_strip {E : Type u_1} [normed_group E] [normed_space â„‚ E] {a b : â„} {f g : â„‚ â†’ E} (hdf : diff_cont_on_cl â„‚ f (complex.im â»Â¹' set.Ioo a b)) (hBf : âˆƒ (c : â„) (H : c < real.pi / (b - a)) (B : â„), f =O[filter.comap (has_abs.abs âˆ˜ complex.re) filter.at_top âŠ“ filter.principal (complex.im â»Â¹' set.Ioo a b)] Î» (z : â„‚), real.exp (B * real.exp (c * |z.re|))) (hdg : diff_cont_on_cl â„‚ g (complex.im â»Â¹' set.Ioo a b)) (hBg : âˆƒ (c : â„) (H : c < real.pi / (b - a)) (B : â„), g =O[filter.comap (has_abs.abs âˆ˜ complex.re) filter.at_top âŠ“ filter.principal (complex.im â»Â¹' set.Ioo a b)] Î» (z : â„‚), real.exp (B * real.exp (c * |z.re|))) (ha : âˆ€ (z : â„‚), z.im = a â†’ f z = g z) (hb : âˆ€ (z : â„‚), z.im = b â†’ f z = g z) : set.eq_on f g (complex.im â»Â¹' set.Icc a b)
theorem sum_hom_units {R : Type u_1} {G : Type u_2} [comm_ring R] [is_domain R] [group G] [fintype G] (f : G â†’* R) [decidable (f = 1)] : finset.univ.sum (Î» (g : G), â‡‘f g) = ite (f = 1) â†‘(fintype.card G) 0
theorem category_theory.limits.Î¹_colimit_limit_to_limit_colimit_Ï€ {J K : Type v} [category_theory.small_category J] [category_theory.small_category K] {C : Type u} [category_theory.category C] (F : J Ã— K â¥¤ C) [category_theory.limits.has_limits_of_shape J C] [category_theory.limits.has_colimits_of_shape K C] (j : J) (k : K) : category_theory.limits.colimit.Î¹ (category_theory.curry.obj (category_theory.prod.swap K J â‹™ F) â‹™ category_theory.limits.lim) k â‰« category_theory.limits.colimit_limit_to_limit_colimit F â‰« category_theory.limits.limit.Ï€ (category_theory.curry.obj F â‹™ category_theory.limits.colim) j = category_theory.limits.limit.Ï€ ((category_theory.curry.obj (category_theory.prod.swap K J â‹™ F)).obj k) j â‰« category_theory.limits.colimit.Î¹ ((category_theory.curry.obj F).obj j) k
theorem integral_exp_neg_le {b : â„} (a X : â„) (h2 : 0 < b) : âˆ« (x : â„) in a..X, real.exp (-b * x) â‰¤ real.exp (-b * a) / b
theorem lift_of_splits {F : Type u_1} {K : Type u_2} {L : Type u_3} [field F] [field K] [field L] [algebra F K] [algebra F L] (s : finset K) : (âˆ€ (x : K), x âˆˆ s â†’ is_integral F x âˆ§ polynomial.splits (algebra_map F L) (minpoly F x)) â†’ nonempty (â†¥(algebra.adjoin F â†‘s) â†’â‚[F] L)
theorem set.pairwise.subtype {Î± : Type u_1} (s : set Î±) (r : Î± â†’ Î± â†’ Prop) : s.pairwise r â†’ pairwise (Î» (x y : â†¥s), r â†‘x â†‘y)
theorem lt_add_of_sub_right_lt {Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b c : Î±} : a - c < b â†’ a < b + c
theorem finprod_mem_mul_diff' {Î± : Type u_1} {M : Type u_5} [comm_monoid M] {f : Î± â†’ M} {s t : set Î±} (hst : s âŠ† t) (ht : (t âˆ© function.mul_support f).finite) : finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), f i)) * finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ t  s), f i)) = finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ t), f i))
theorem dual_number.snd_mul {R : Type u_1} [semiring R] (x y : dual_number R) : (x * y).snd = triv_sq_zero_ext.fst x * triv_sq_zero_ext.snd y + triv_sq_zero_ext.fst y * triv_sq_zero_ext.snd x
theorem mem_nhds_within_Ioi_iff_exists_Ioo_subset' {Î± : Type u} [topological_space Î±] [linear_order Î±] [order_topology Î±] {a u' : Î±} {s : set Î±} (hu' : a < u') : s âˆˆ nhds_within a (set.Ioi a) â†” âˆƒ (u : Î±) (H : u âˆˆ set.Ioi a), set.Ioo a u âŠ† s
theorem filter.frequently_high_scores {Î² : Type u_4} [linear_order Î²] [no_max_order Î²] {u : â„• â†’ Î²} (hu : filter.tendsto u filter.at_top filter.at_top) : âˆƒá¶  (n : â„•) in filter.at_top, âˆ€ (k : â„•), k < n â†’ u k < u n
theorem linear_ordered_comm_group_with_zero.nhds_zero_of_units {Î“â‚€ : Type u_1} [linear_ordered_comm_group_with_zero Î“â‚€] (Î³ : Î“â‚€Ë£) : {x : Î“â‚€ | x < â†‘Î³} âˆˆ nhds 0
theorem nnreal.exists_le_has_sum_of_le {Î² : Type u_2} {f g : Î² â†’ nnreal} {r : nnreal} (hgf : âˆ€ (b : Î²), g b â‰¤ f b) (hfr : has_sum f r) : âˆƒ (p : nnreal) (H : p â‰¤ r), has_sum g p
theorem turing.to_partrec.step_normal_then (c : turing.to_partrec.code) (k k' : turing.to_partrec.cont) (v : list â„•) : turing.to_partrec.step_normal c (k.then k') v = (turing.to_partrec.step_normal c k v).then k'
theorem category_theory.monad.forget_creates_colimits_of_monad_preserves {C : Type uâ‚} [category_theory.category C] {T : category_theory.monad C} {J : Type u} [category_theory.category J] [category_theory.limits.preserves_colimits_of_shape J â†‘T] (D : J â¥¤ T.algebra) [category_theory.limits.has_colimit (D â‹™ T.forget)] : category_theory.limits.has_colimit D
theorem mem_Icc_of_mem_std_simplex {R : Type u_1} {Î¹ : Type u_4} [linear_ordered_field R] [fintype Î¹] {f : Î¹ â†’ R} (hf : f âˆˆ std_simplex R Î¹) (x : Î¹) : f x âˆˆ set.Icc 0 1
theorem ring_hom_inv_pair.symm {Râ‚ : Type u_1} {Râ‚‚ : Type u_2} [semiring Râ‚] [semiring Râ‚‚] (Ïƒâ‚â‚‚ : Râ‚ â†’+* Râ‚‚) (Ïƒâ‚‚â‚ : Râ‚‚ â†’+* Râ‚) [ring_hom_inv_pair Ïƒâ‚â‚‚ Ïƒâ‚‚â‚] : ring_hom_inv_pair Ïƒâ‚‚â‚ Ïƒâ‚â‚‚
theorem category_theory.limits.eq_of_epi_equalizer {C : Type u} [category_theory.category C] {X Y : C} {f g : X âŸ¶ Y} [category_theory.limits.has_equalizer f g] [category_theory.epi (category_theory.limits.equalizer.Î¹ f g)] : f = g
theorem metric.eball_top_eq_univ {Î± : Type u} [pseudo_metric_space Î±] (x : Î±) : emetric.ball x âŠ¤ = set.univ
theorem antivary.sum_smul_eq_sum_comp_perm_smul_iff {Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [linear_ordered_ring Î±] [linear_ordered_add_comm_group Î²] [module Î± Î²] [ordered_smul Î± Î²] {Ïƒ : equiv.perm Î¹} {f : Î¹ â†’ Î±} {g : Î¹ â†’ Î²} [fintype Î¹] (hfg : antivary f g) : finset.univ.sum (Î» (i : Î¹), f (â‡‘Ïƒ i) â€¢ g i) = finset.univ.sum (Î» (i : Î¹), f i â€¢ g i) â†” antivary (f âˆ˜ â‡‘Ïƒ) g
theorem pmf.to_outer_measure_mono {Î± : Type u_1} (p : pmf Î±) {s t : set Î±} (h : s âˆ© p.support âŠ† t) : â‡‘(p.to_outer_measure) s â‰¤ â‡‘(p.to_outer_measure) t
theorem generalized_continued_fraction.zero_le_of_denom {K : Type u_1} {v : K} {n : â„•} [linear_ordered_field K] [floor_ring K] : 0 â‰¤ (generalized_continued_fraction.of v).denominators n
theorem cont_diff.has_strict_deriv_at {n : with_top â„•} {ğ•‚ : Type u_6} [is_R_or_C ğ•‚] {F' : Type u_8} [normed_group F'] [normed_space ğ•‚ F'] {f : ğ•‚ â†’ F'} {x : ğ•‚} (hf : cont_diff ğ•‚ n f) (hn : 1 â‰¤ n) : has_strict_deriv_at f (deriv f x) x
theorem liouville_with.mono {p q x : â„} (h : liouville_with p x) (hle : q â‰¤ p) : liouville_with q x
theorem mem_span_points (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (p : P) (s : set P) : p âˆˆ s â†’ p âˆˆ span_points k s
theorem ring.direct_limit.of.zero_exact {Î¹ : Type v} [preorder Î¹] {G : Î¹ â†’ Type w} [Î  (i : Î¹), comm_ring (G i)] {f' : Î  (i j : Î¹), i â‰¤ j â†’ G i â†’+* G j} [directed_system G (Î» (i j : Î¹) (h : i â‰¤ j), â‡‘(f' i j h))] [is_directed Î¹ has_le.le] {i : Î¹} {x : G i} (hix : â‡‘(ring.direct_limit.of G (Î» (i j : Î¹) (h : i â‰¤ j), â‡‘(f' i j h)) i) x = 0) : âˆƒ (j : Î¹) (hij : i â‰¤ j), â‡‘(f' i j hij) x = 0
theorem nat.partrec.code.rec_computable {Î± : Type u_1} {Ïƒ : Type u_2} [primcodable Î±] [primcodable Ïƒ] {c : Î± â†’ nat.partrec.code} (hc : computable c) {z : Î± â†’ Ïƒ} (hz : computable z) {s : Î± â†’ Ïƒ} (hs : computable s) {l : Î± â†’ Ïƒ} (hl : computable l) {r : Î± â†’ Ïƒ} (hr : computable r) {pr : Î± â†’ nat.partrec.code Ã— nat.partrec.code Ã— Ïƒ Ã— Ïƒ â†’ Ïƒ} (hpr : computableâ‚‚ pr) {co : Î± â†’ nat.partrec.code Ã— nat.partrec.code Ã— Ïƒ Ã— Ïƒ â†’ Ïƒ} (hco : computableâ‚‚ co) {pc : Î± â†’ nat.partrec.code Ã— nat.partrec.code Ã— Ïƒ Ã— Ïƒ â†’ Ïƒ} (hpc : computableâ‚‚ pc) {rf : Î± â†’ nat.partrec.code Ã— Ïƒ â†’ Ïƒ} (hrf : computableâ‚‚ rf) : let PR : Î± â†’ nat.partrec.code â†’ nat.partrec.code â†’ Ïƒ â†’ Ïƒ â†’ Ïƒ := Î» (a : Î±) (cf cg : nat.partrec.code) (hf hg : Ïƒ), pr a (cf, cg, hf, hg), CO : Î± â†’ nat.partrec.code â†’ nat.partrec.code â†’ Ïƒ â†’ Ïƒ â†’ Ïƒ := Î» (a : Î±) (cf cg : nat.partrec.code) (hf hg : Ïƒ), co a (cf, cg, hf, hg), PC : Î± â†’ nat.partrec.code â†’ nat.partrec.code â†’ Ïƒ â†’ Ïƒ â†’ Ïƒ := Î» (a : Î±) (cf cg : nat.partrec.code) (hf hg : Ïƒ), pc a (cf, cg, hf, hg), RF : Î± â†’ nat.partrec.code â†’ Ïƒ â†’ Ïƒ := Î» (a : Î±) (cf : nat.partrec.code) (hf : Ïƒ), rf a (cf, hf), F : Î± â†’ nat.partrec.code â†’ Ïƒ := Î» (a : Î±) (c : nat.partrec.code), c.rec_on (z a) (s a) (l a) (r a) (PR a) (CO a) (PC a) (RF a) in computable (Î» (a : Î±), F a (c a))
theorem inf_Sup_eq_supr_inf_sup_finset {Î± : Type u_1} [complete_lattice Î±] [is_compactly_generated Î±] {a : Î±} {s : set Î±} : a âŠ“ has_Sup.Sup s = â¨† (t : finset Î±) (H : â†‘t âŠ† s), a âŠ“ t.sup id
theorem category_theory.id_cover_lifting {C : Type u_1} [category_theory.category C] (J : category_theory.grothendieck_topology C) : category_theory.cover_lifting J J (ğŸ­ C)
theorem path.homotopic.proj_pi {Î¹ : Type u_1} {X : Î¹ â†’ Type u_2} [Î  (i : Î¹), topological_space (X i)] {as bs : Î  (i : Î¹), X i} (i : Î¹) (paths : Î  (i : Î¹), path.homotopic.quotient (as i) (bs i)) : path.homotopic.proj i (path.homotopic.pi paths) = paths i
theorem affine.triangle.orthocenter_eq_smul_vsub_vadd_circumcenter {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] (t : affine.triangle â„ P) : t.orthocenter = 3 â€¢ (finset.centroid â„ finset.univ t.points -áµ¥ affine.simplex.circumcenter t) +áµ¥ affine.simplex.circumcenter t
theorem exists_lt_lt_of_not_covby {Î± : Type u_1} [has_lt Î±] {a b : Î±} (h : a < b) : Â¬a â‹– b â†’ (âˆƒ (c : Î±), a < c âˆ§ c < b)
theorem continuous.fst' {Î± : Type u} {Î² : Type v} {Î³ : Type u_1} [topological_space Î±] [topological_space Î²] [topological_space Î³] {f : Î± â†’ Î³} (hf : continuous f) : continuous (Î» (x : Î± Ã— Î²), f x.fst)
theorem non_unital_ring_hom.comp_assoc {Î± : Type u_2} {Î² : Type u_3} {Î³ : Type u_4} [rÎ± : non_unital_non_assoc_semiring Î±] [rÎ² : non_unital_non_assoc_semiring Î²] {rÎ³ : non_unital_non_assoc_semiring Î³} {Î´ : Type u_1} {rÎ´ : non_unital_non_assoc_semiring Î´} (f : Î± â†’â‚™+* Î²) (g : Î² â†’â‚™+* Î³) (h : Î³ â†’â‚™+* Î´) : (h.comp g).comp f = h.comp (g.comp f)
theorem linear_ordered_comm_group_with_zero.directed_lt (Î“â‚€ : Type u_1) [linear_ordered_comm_group_with_zero Î“â‚€] : directed ge (Î» (Î³â‚€ : Î“â‚€Ë£), filter.principal {Î³ : Î“â‚€ | Î³ < â†‘Î³â‚€})
theorem real.pi_lower_bound_start (n : â„•) {a : â„} (h : real.sqrt_two_add_series (â†‘0 / â†‘1) n â‰¤ 2 - (a / 2 ^ (n + 1)) ^ 2) : a < real.pi
theorem category_theory.idempotents.idem_of_id_sub_idem {C : Type u_1} [category_theory.category C] [category_theory.preadditive C] {X : C} (p : X âŸ¶ X) (hp : p â‰« p = p) : (ğŸ™ X - p) â‰« (ğŸ™ X - p) = ğŸ™ X - p
theorem finsum_mem_add_diff {Î± : Type u_1} {M : Type u_5} [add_comm_monoid M] {f : Î± â†’ M} {s t : set Î±} (hst : s âŠ† t) (ht : t.finite) : finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), f i)) + finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ t  s), f i)) = finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ t), f i))
theorem lower_adjoint.closed_eq_range_close {Î± : Type u_1} {Î² : Type u_4} [partial_order Î±] [partial_order Î²] {u : Î² â†’ Î±} (l : lower_adjoint u) : l.closed = set.range (u âˆ˜ â‡‘l)
theorem measure_theory.finite_measure.tendsto_test_against_nn_of_le_const {Î± : Type u_1} [measurable_space Î±] [topological_space Î±] [opens_measurable_space Î±] {Î¼ : measure_theory.finite_measure Î±} {fs : â„• â†’ bounded_continuous_function Î± nnreal} {c : nnreal} (fs_le_const : âˆ€ (n : â„•) (a : Î±), â‡‘(fs n) a â‰¤ c) {f : bounded_continuous_function Î± nnreal} (fs_lim : âˆ€ (a : Î±), filter.tendsto (Î» (n : â„•), â‡‘(fs n) a) filter.at_top (nhds (â‡‘f a))) : filter.tendsto (Î» (n : â„•), Î¼.test_against_nn (fs n)) filter.at_top (nhds (Î¼.test_against_nn f))
theorem sylow.prime_pow_dvd_card_normalizer {G : Type u} [group G] [fintype G] {p n : â„•} [hp : fact (nat.prime p)] (hdvd : p ^ (n + 1) âˆ£ fintype.card G) {H : subgroup G} (hH : fintype.card â†¥H = p ^ n) : p ^ (n + 1) âˆ£ fintype.card â†¥(H.normalizer)
theorem is_max_on.of_is_local_max_on_of_concave_on {E : Type u_1} {Î² : Type u_2} [add_comm_group E] [topological_space E] [module â„ E] [topological_add_group E] [has_continuous_smul â„ E] [ordered_add_comm_group Î²] [module â„ Î²] [ordered_smul â„ Î²] {s : set E} {f : E â†’ Î²} {a : E} (a_in_s : a âˆˆ s) (h_localmax : is_local_max_on f s a) (h_conc : concave_on â„ s f) : is_max_on f s a
theorem iterated_fderiv_succ_eq_comp_right {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {f : E â†’ F} {x : E} {n : â„•} : iterated_fderiv ğ•œ (n + 1) f x = (â‡‘(continuous_multilinear_curry_right_equiv' ğ•œ n E F) âˆ˜ iterated_fderiv ğ•œ n (Î» (y : E), fderiv ğ•œ f y)) x
theorem finset.prod_sub_ordered {Î¹ : Type u_1} {R : Type u_2} [comm_ring R] [linear_order Î¹] (s : finset Î¹) (f g : Î¹ â†’ R) : s.prod (Î» (i : Î¹), f i - g i) = s.prod (Î» (i : Î¹), f i) - s.sum (Î» (i : Î¹), g i * (finset.filter (Î» (_x : Î¹), _x < i) s).prod (Î» (j : Î¹), f j - g j) * (finset.filter (Î» (j : Î¹), i < j) s).prod (Î» (j : Î¹), f j))
theorem interval_integral.measure_integral_sub_linear_is_o_of_tendsto_ae_of_le {Î¹ : Type u_1} {E : Type u_3} [normed_group E] [complete_space E] [normed_space â„ E] {f : â„ â†’ E} {a : â„} {c : E} {l l' : filter â„} {lt : filter Î¹} {Î¼ : measure_theory.measure â„} {u v : Î¹ â†’ â„} [measure_theory.is_locally_finite_measure Î¼] [interval_integral.FTC_filter a l l'] (hfm : strongly_measurable_at_filter f l' Î¼) (hf : filter.tendsto f (l' âŠ“ Î¼.ae) (nhds c)) (hu : filter.tendsto u lt l) (hv : filter.tendsto v lt l) (huv : u â‰¤á¶ [lt] v) : (Î» (t : Î¹), âˆ« (x : â„) in u t..v t, f x âˆ‚Î¼ - (â‡‘Î¼ (set.Ioc (u t) (v t))).to_real â€¢ c) =o[lt] Î» (t : Î¹), (â‡‘Î¼ (set.Ioc (u t) (v t))).to_real
theorem zmod.legendre_sym_eq_zero_iff (p : â„•) [fact (nat.prime p)] (a : â„¤) : zmod.legendre_sym p a = 0 â†” â†‘a = 0
theorem algebraic_topology.dold_kan.c_mk (i j : â„•) (h : j + 1 = i) : algebraic_topology.dold_kan.c.rel i j
theorem pgame.zero_lf_le {x : pgame} : 0.lf x â†” âˆƒ (i : x.left_moves), 0 â‰¤ x.move_left i
theorem contracting_with.fixed_point_is_fixed_pt {Î± : Type u_1} [metric_space Î±] {K : nnreal} {f : Î± â†’ Î±} (hf : contracting_with K f) [nonempty Î±] [complete_space Î±] : function.is_fixed_pt f (contracting_with.fixed_point f hf)
theorem left.mul_lt_mul {Î± : Type u_1} [has_mul Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] [covariant_class Î± Î± (function.swap has_mul.mul) has_le.le] {a b c d : Î±} (hâ‚ : a < b) (hâ‚‚ : c < d) : a * c < b * d
theorem finprod_mul_distrib {Î± : Type u_1} {M : Type u_5} [comm_monoid M] {f g : Î± â†’ M} (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) : finprod (Î» (i : Î±), f i * g i) = finprod (Î» (i : Î±), f i) * finprod (Î» (i : Î±), g i)
theorem metric.Hausdorff_dist_nonneg {Î± : Type u} [pseudo_metric_space Î±] {s t : set Î±} : 0 â‰¤ metric.Hausdorff_dist s t
theorem subfield.list_sum_mem {K : Type u} [field K] (s : subfield K) {l : list K} : (âˆ€ (x : K), x âˆˆ l â†’ x âˆˆ s) â†’ l.sum âˆˆ s
theorem inner_right_of_mem_orthogonal_singleton {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] (u : E) {v : E} (hv : v âˆˆ (submodule.span ğ•œ {u})á—®) : has_inner.inner u v = 0
theorem is_regular_iff_ne_zero {R : Type u_1} {a : R} [cancel_monoid_with_zero R] [nontrivial R] : is_regular a â†” a â‰  0
theorem finsum_mem_insert' {Î± : Type u_1} {M : Type u_5} [add_comm_monoid M] {a : Î±} {s : set Î±} (f : Î± â†’ M) (h : a âˆ‰ s) (hs : (s âˆ© function.support f).finite) : finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ has_insert.insert a s), f i)) = f a + finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), f i))
theorem matrix.is_diag.diagonal_diag {Î± : Type u_1} {n : Type u_4} [has_zero Î±] [decidable_eq n] {A : matrix n n Î±} (h : A.is_diag) : matrix.diagonal A.diag = A
theorem is_nilpotent_of_product_of_sylow_group {G : Type u_1} [hG : group G] [hf : fintype G] (e : (Î  (p : â†¥((fintype.card G).factorization.support)) (P : sylow â†‘p G), â†¥â†‘P) â‰ƒ* G) : group.is_nilpotent G
theorem polynomial.irreducible_of_eisenstein_criterion {R : Type u_1} [comm_ring R] [is_domain R] {f : polynomial R} {P : ideal R} (hP : P.is_prime) (hfl : f.leading_coeff âˆ‰ P) (hfP : âˆ€ (n : â„•), â†‘n < f.degree â†’ f.coeff n âˆˆ P) (hfd0 : 0 < f.degree) (h0 : f.coeff 0 âˆ‰ P ^ 2) (hu : f.is_primitive) : irreducible f
theorem witt_vector.iterate_verschiebung_mul_coeff {p : â„•} {R : Type u_1} [hp : fact (nat.prime p)] [comm_ring R] [char_p R p] (x y : witt_vector p R) (i j : â„•) : (â‡‘witt_vector.verschiebung^[i] x * â‡‘witt_vector.verschiebung^[j] y).coeff (i + j) = x.coeff 0 ^ p ^ j * y.coeff 0 ^ p ^ i
theorem metric.inf_edist_ne_top {Î± : Type u} [pseudo_metric_space Î±] {s : set Î±} {x : Î±} (h : s.nonempty) : emetric.inf_edist x s â‰  âŠ¤
theorem orientation.two_zsmul_oangle_sub_eq_two_zsmul_oangle_sub_of_norm_eq {V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) {xâ‚ xâ‚‚ y z : V} (hxâ‚yne : xâ‚ â‰  y) (hxâ‚zne : xâ‚ â‰  z) (hxâ‚‚yne : xâ‚‚ â‰  y) (hxâ‚‚zne : xâ‚‚ â‰  z) {r : â„} (hxâ‚ : âˆ¥xâ‚âˆ¥ = r) (hxâ‚‚ : âˆ¥xâ‚‚âˆ¥ = r) (hy : âˆ¥yâˆ¥ = r) (hz : âˆ¥zâˆ¥ = r) : 2 â€¢ o.oangle (y - xâ‚) (z - xâ‚) = 2 â€¢ o.oangle (y - xâ‚‚) (z - xâ‚‚)
theorem euclidean_geometry.right_dist_ne_zero_of_angle_eq_pi {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {p1 p2 p3 : P} (h : euclidean_geometry.angle p1 p2 p3 = real.pi) : has_dist.dist p3 p2 â‰  0
theorem linear_order.strict_concave_on_of_lt {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [ordered_semiring ğ•œ] [add_comm_monoid E] [ordered_add_comm_monoid Î²] [module ğ•œ E] [module ğ•œ Î²] [linear_order E] {s : set E} {f : E â†’ Î²} (hs : convex ğ•œ s) (hf : âˆ€ â¦ƒx y : Eâ¦„, x âˆˆ s â†’ y âˆˆ s â†’ x < y â†’ âˆ€ â¦ƒa b : ğ•œâ¦„, 0 < a â†’ 0 < b â†’ a + b = 1 â†’ a â€¢ f x + b â€¢ f y < f (a â€¢ x + b â€¢ y)) : strict_concave_on ğ•œ s f
theorem add_submonoid.dense_induction {M : Type u_1} [add_zero_class M] {p : M â†’ Prop} (x : M) {s : set M} (hs : add_submonoid.closure s = âŠ¤) (Hs : âˆ€ (x : M), x âˆˆ s â†’ p x) (H1 : p 0) (Hmul : âˆ€ (x y : M), p x â†’ p y â†’ p (x + y)) : p x
theorem inner_product_geometry.norm_add_eq_add_norm_iff_angle_eq_zero {V : Type u_1} [inner_product_space â„ V] {x y : V} (hx : x â‰  0) (hy : y â‰  0) : âˆ¥x + yâˆ¥ = âˆ¥xâˆ¥ + âˆ¥yâˆ¥ â†” inner_product_geometry.angle x y = 0
theorem has_fderiv_at_integral_of_dominated_loc_of_lip' {Î± : Type u_1} [measurable_space Î±] {Î¼ : measure_theory.measure Î±} {ğ•œ : Type u_2} [is_R_or_C ğ•œ] {E : Type u_3} [normed_group E] [normed_space â„ E] [normed_space ğ•œ E] [complete_space E] {H : Type u_4} [normed_group H] [normed_space ğ•œ H] {F : H â†’ Î± â†’ E} {F' : Î± â†’ (H â†’L[ğ•œ] E)} {xâ‚€ : H} {bound : Î± â†’ â„} {Îµ : â„} (Îµ_pos : 0 < Îµ) (hF_meas : âˆ€ (x : H), x âˆˆ metric.ball xâ‚€ Îµ â†’ measure_theory.ae_strongly_measurable (F x) Î¼) (hF_int : measure_theory.integrable (F xâ‚€) Î¼) (hF'_meas : measure_theory.ae_strongly_measurable F' Î¼) (h_lipsch : âˆ€áµ (a : Î±) âˆ‚Î¼, âˆ€ (x : H), x âˆˆ metric.ball xâ‚€ Îµ â†’ âˆ¥F x a - F xâ‚€ aâˆ¥ â‰¤ bound a * âˆ¥x - xâ‚€âˆ¥) (bound_integrable : measure_theory.integrable bound Î¼) (h_diff : âˆ€áµ (a : Î±) âˆ‚Î¼, has_fderiv_at (Î» (x : H), F x a) (F' a) xâ‚€) : measure_theory.integrable F' Î¼ âˆ§ has_fderiv_at (Î» (x : H), âˆ« (a : Î±), F x a âˆ‚Î¼) (âˆ« (a : Î±), F' a âˆ‚Î¼) xâ‚€
theorem strict_convex_on_open_of_deriv2_pos {D : set â„} (hD : convex â„ D) (hDâ‚‚ : is_open D) {f : â„ â†’ â„} (hf' : differentiable_on â„ f D) (hf'' : âˆ€ (x : â„), x âˆˆ D â†’ 0 < deriv^[2] f x) : strict_convex_on â„ D f
theorem ennreal.coe_sub {r p : nnreal} : â†‘(r - p) = â†‘r - â†‘p
theorem descending_central_series_ge_lower {G : Type u_1} [group G] (H : â„• â†’ subgroup G) (hH : is_descending_central_series H) (n : â„•) : lower_central_series G n â‰¤ H n
theorem measure_theory.ae_eq_condexp_of_forall_set_integral_eq {Î± : Type u_1} {F' : Type u_7} [normed_group F'] [normed_space â„ F'] [complete_space F'] {m m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (hm : m â‰¤ m0) [measure_theory.sigma_finite (Î¼.trim hm)] {f g : Î± â†’ F'} (hf : measure_theory.integrable f Î¼) (hg_int_finite : âˆ€ (s : set Î±), measurable_set s â†’ â‡‘Î¼ s < âŠ¤ â†’ measure_theory.integrable_on g s Î¼) (hg_eq : âˆ€ (s : set Î±), measurable_set s â†’ â‡‘Î¼ s < âŠ¤ â†’ âˆ« (x : Î±) in s, g x âˆ‚Î¼ = âˆ« (x : Î±) in s, f x âˆ‚Î¼) (hgm : measure_theory.ae_strongly_measurable' m g Î¼) : g =áµ[Î¼] measure_theory.condexp m Î¼ f
theorem measure_theory.Lp.simple_func.induction {Î± : Type u_1} {E : Type u_4} [measurable_space Î±] [normed_group E] {p : ennreal} {Î¼ : measure_theory.measure Î±} (hp_pos : p â‰  0) (hp_ne_top : p â‰  âŠ¤) {P : â†¥(measure_theory.Lp.simple_func E p Î¼) â†’ Prop} (h_ind : âˆ€ (c : E) {s : set Î±} (hs : measurable_set s) (hÎ¼s : â‡‘Î¼ s < âŠ¤), P (measure_theory.Lp.simple_func.indicator_const p hs _ c)) (h_add : âˆ€ â¦ƒf g : measure_theory.simple_func Î± Eâ¦„ (hf : measure_theory.mem_â„’p â‡‘f p Î¼) (hg : measure_theory.mem_â„’p â‡‘g p Î¼), disjoint (function.support â‡‘f) (function.support â‡‘g) â†’ P (measure_theory.Lp.simple_func.to_Lp f hf) â†’ P (measure_theory.Lp.simple_func.to_Lp g hg) â†’ P (measure_theory.Lp.simple_func.to_Lp f hf + measure_theory.Lp.simple_func.to_Lp g hg)) (f : â†¥(measure_theory.Lp.simple_func E p Î¼)) : P f
theorem padic_val_rat.inv (p : â„•) [p_prime : fact (nat.prime p)] (q : â„š) : padic_val_rat p qâ»Â¹ = -padic_val_rat p q
theorem finset.affine_combination_eq_linear_combination {k : Type u_1} {V : Type u_2} [ring k] [add_comm_group V] [module k V] {Î¹ : Type u_4} (s : finset Î¹) (p : Î¹ â†’ V) (w : Î¹ â†’ k) (hw : s.sum (Î» (i : Î¹), w i) = 1) : â‡‘(s.affine_combination p) w = s.sum (Î» (i : Î¹), w i â€¢ p i)
theorem bounded_continuous_function.Lp_norm_le {Î± : Type u_1} {E : Type u_2} {m0 : measurable_space Î±} {p : ennreal} {Î¼ : measure_theory.measure Î±} [normed_group E] [topological_space Î±] [borel_space Î±] [second_countable_topology_either Î± E] [measure_theory.is_finite_measure Î¼] (f : bounded_continuous_function Î± E) : âˆ¥âŸ¨continuous_map.to_ae_eq_fun Î¼ f.to_continuous_map, _âŸ©âˆ¥ â‰¤ â†‘(measure_theory.measure_univ_nnreal Î¼) ^ (p.to_real)â»Â¹ * âˆ¥fâˆ¥
theorem antitone.ne_of_lt_of_lt_int {Î± : Type u} [preorder Î±] {f : â„¤ â†’ Î±} (hf : antitone f) (n : â„¤) {x : Î±} (h1 : f (n + 1) < x) (h2 : x < f n) (a : â„¤) : f a â‰  x
theorem circle_integral.norm_integral_lt_of_norm_le_const_of_lt {E : Type u_1} [normed_group E] [normed_space â„‚ E] [complete_space E] {f : â„‚ â†’ E} {c : â„‚} {R C : â„} (hR : 0 < R) (hc : continuous_on f (metric.sphere c R)) (hf : âˆ€ (z : â„‚), z âˆˆ metric.sphere c R â†’ âˆ¥f zâˆ¥ â‰¤ C) (hlt : âˆƒ (z : â„‚) (H : z âˆˆ metric.sphere c R), âˆ¥f zâˆ¥ < C) : âˆ¥âˆ® (z : â„‚) in C(c, R), f zâˆ¥ < 2 * real.pi * R * C
theorem measurable_of_tendsto_ennreal {Î± : Type u_1} [measurable_space Î±] {f : â„• â†’ Î± â†’ ennreal} {g : Î± â†’ ennreal} (hf : âˆ€ (i : â„•), measurable (f i)) (lim : filter.tendsto f filter.at_top (nhds g)) : measurable g
theorem nnreal.inner_le_Lp_mul_Lq_has_sum {Î¹ : Type u} {f g : Î¹ â†’ nnreal} {A B : nnreal} {p q : â„} (hpq : p.is_conjugate_exponent q) (hf : has_sum (Î» (i : Î¹), f i ^ p) (A ^ p)) (hg : has_sum (Î» (i : Î¹), g i ^ q) (B ^ q)) : âˆƒ (C : nnreal), C â‰¤ A * B âˆ§ has_sum (Î» (i : Î¹), f i * g i) C
theorem filter.tendsto_small_sets_iff {Î± : Type u_1} {Î² : Type u_2} {la : filter Î±} {lb : filter Î²} {f : Î± â†’ set Î²} : filter.tendsto f la lb.small_sets â†” âˆ€ (t : set Î²), t âˆˆ lb â†’ (âˆ€á¶  (x : Î±) in la, f x âŠ† t)
theorem char_p_zero_or_prime_power (R : Type u_1) [comm_ring R] [local_ring R] (q : â„•) [char_R_q : char_p R q] : q = 0 âˆ¨ is_prime_pow q
theorem pgame.lt_or_equiv_or_gt_or_fuzzy (x y : pgame) : x < y âˆ¨ x.equiv y âˆ¨ y < x âˆ¨ x.fuzzy y
theorem submonoid.bot_or_nontrivial {M : Type u_1} [mul_one_class M] (S : submonoid M) : S = âŠ¥ âˆ¨ nontrivial â†¥S
theorem is_left_regular.pow {R : Type u_1} {a : R} [monoid R] (n : â„•) (rla : is_left_regular a) : is_left_regular (a ^ n)
theorem cont_mdiff_on_iff {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {M : Type u_4} [topological_space M] [charted_space H M] [Is : smooth_manifold_with_corners I M] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners ğ•œ E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] [I's : smooth_manifold_with_corners I' M'] {f : M â†’ M'} {s : set M} {n : with_top â„•} : cont_mdiff_on I I' n f s â†” continuous_on f s âˆ§ âˆ€ (x : M) (y : M'), cont_diff_on ğ•œ n (â‡‘(ext_chart_at I' y) âˆ˜ f âˆ˜ â‡‘((ext_chart_at I x).symm)) ((ext_chart_at I x).target âˆ© â‡‘((ext_chart_at I x).symm) â»Â¹' (s âˆ© f â»Â¹' (ext_chart_at I' y).source))
theorem subgroup.inv_mem {G : Type u_1} [group G] (H : subgroup G) {x : G} : x âˆˆ H â†’ xâ»Â¹ âˆˆ H
theorem convex_cone.salient_positive_cone (ğ•œ : Type u_1) (E : Type u_2) [ordered_semiring ğ•œ] [ordered_add_comm_group E] [module ğ•œ E] [ordered_smul ğ•œ E] : (convex_cone.positive_cone ğ•œ E).salient
theorem iterated_fderiv_within_inter' {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {s u : set E} {f : E â†’ F} {x : E} {n : â„•} (hu : u âˆˆ nhds_within x s) (hs : unique_diff_on ğ•œ s) (xs : x âˆˆ s) : iterated_fderiv_within ğ•œ n f (s âˆ© u) x = iterated_fderiv_within ğ•œ n f s x
theorem category_theory.equalizer.sieve.equalizer_sheaf_condition {C : Type uâ‚} [category_theory.category C] (P : Cáµ’áµ– â¥¤ Type (max vâ‚ uâ‚)) {X : C} (S : category_theory.sieve X) : category_theory.presieve.is_sheaf_for P â‡‘S â†” nonempty (category_theory.limits.is_limit (category_theory.limits.fork.of_Î¹ (category_theory.equalizer.fork_map P â‡‘S) _))
theorem category_theory.functor.monotone {X : Type u} {Y : Type v} [preorder X] [preorder Y] (f : X â¥¤ Y) : monotone f.obj
theorem affine.simplex.vector_span_le_altitude_direction_orthogonal {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {n : â„•} (s : affine.simplex â„ P (n + 1)) (i : fin (n + 2)) : vector_span â„ (s.points '' â†‘(finset.univ.erase i)) â‰¤ ((s.altitude i).direction)á—®
theorem dense_range.topological_closure_map_submodule {Râ‚ : Type u_1} {Râ‚‚ : Type u_2} [semiring Râ‚] [semiring Râ‚‚] {Ïƒâ‚â‚‚ : Râ‚ â†’+* Râ‚‚} {Mâ‚ : Type u_4} [topological_space Mâ‚] [add_comm_monoid Mâ‚] {Mâ‚‚ : Type u_6} [topological_space Mâ‚‚] [add_comm_monoid Mâ‚‚] [module Râ‚ Mâ‚] [module Râ‚‚ Mâ‚‚] [ring_hom_surjective Ïƒâ‚â‚‚] [topological_space Râ‚] [topological_space Râ‚‚] [has_continuous_smul Râ‚ Mâ‚] [has_continuous_add Mâ‚] [has_continuous_smul Râ‚‚ Mâ‚‚] [has_continuous_add Mâ‚‚] {f : Mâ‚ â†’SL[Ïƒâ‚â‚‚] Mâ‚‚} (hf' : dense_range â‡‘f) {s : submodule Râ‚ Mâ‚} (hs : s.topological_closure = âŠ¤) : (submodule.map â†‘f s).topological_closure = âŠ¤
theorem set.Union_Inter_subset {Î± : Type u_1} {Î¹ : Sort u_4} {Î¹' : Sort u_5} {s : Î¹ â†’ Î¹' â†’ set Î±} : (â‹ƒ (j : Î¹'), â‹‚ (i : Î¹), s i j) âŠ† â‹‚ (i : Î¹), â‹ƒ (j : Î¹'), s i j
theorem finprod_comp {Î± : Type u_1} {Î² : Type u_2} {M : Type u_5} [comm_monoid M] {g : Î² â†’ M} (e : Î± â†’ Î²) (heâ‚€ : function.bijective e) : finprod (Î» (i : Î±), g (e i)) = finprod (Î» (j : Î²), g j)
theorem ideal.map_pi {R : Type u} [comm_ring R] (I : ideal R) {Î¹ : Type u_1} [fintype Î¹] {Î¹' : Type w} (x : Î¹ â†’ R) (hi : âˆ€ (i : Î¹), x i âˆˆ I) (f : (Î¹ â†’ R) â†’â‚—[R] Î¹' â†’ R) (i : Î¹') : â‡‘f x i âˆˆ I
theorem real.sq_cos_pi_div_six  : real.cos (real.pi / 6) ^ 2 = 3 / 4
theorem continuous_at.snd'' {Î± : Type u} {Î² : Type v} {Î³ : Type u_1} [topological_space Î±] [topological_space Î²] [topological_space Î³] {f : Î² â†’ Î³} {x : Î± Ã— Î²} (hf : continuous_at f x.snd) : continuous_at (Î» (x : Î± Ã— Î²), f x.snd) x
theorem abs_cases {Î± : Type u} [linear_ordered_ring Î±] (a : Î±) : |a| = a âˆ§ 0 â‰¤ a âˆ¨ |a| = -a âˆ§ a < 0
theorem power_basis.repr_gen_pow_is_integral {S : Type u_2} [comm_ring S] {R : Type u_3} [comm_ring R] [algebra R S] {A : Type u_4} [comm_ring A] [algebra R A] [algebra S A] [is_scalar_tower R S A] {B : power_basis S A} (hB : is_integral R B.gen) [is_domain S] (hmin : minpoly S B.gen = polynomial.map (algebra_map R S) (minpoly R B.gen)) (n : â„•) (i : fin B.dim) : is_integral R (â‡‘(â‡‘(B.basis.repr) (B.gen ^ n)) i)
theorem continuous.exists_forall_ge_of_has_compact_mul_support {Î± : Type u_1} {Î² : Type u_2} [conditionally_complete_linear_order Î±] [topological_space Î±] [order_topology Î±] [topological_space Î²] [nonempty Î²] [has_one Î±] {f : Î² â†’ Î±} (hf : continuous f) (h : has_compact_mul_support f) : âˆƒ (x : Î²), âˆ€ (y : Î²), f y â‰¤ f x
theorem combinatorics.exists_mono_homothetic_copy {M : Type u_1} {Îº : Type u_2} [add_comm_monoid M] (S : finset M) [fintype Îº] (C : M â†’ Îº) : âˆƒ (a : â„•) (H : a > 0) (b : M) (c : Îº), âˆ€ (s : M), s âˆˆ S â†’ C (a â€¢ s + b) = c
theorem is_right_regular.pow_iff {R : Type u_1} {a : R} [monoid R] {n : â„•} (n0 : 0 < n) : is_right_regular (a ^ n) â†” is_right_regular a
theorem semiconj_by.reflexive {M : Type u} [mul_one_class M] : reflexive (Î» (a b : M), âˆƒ (c : M), semiconj_by c a b)
theorem local_homeomorph.is_O_congr {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] {E : Type u_3} [has_norm E] {F : Type u_4} [has_norm F] (e : local_homeomorph Î± Î²) {b : Î²} (hb : b âˆˆ e.to_local_equiv.target) {f : Î² â†’ E} {g : Î² â†’ F} : f =O[nhds b] g â†” (f âˆ˜ â‡‘e) =O[nhds (â‡‘(e.symm) b)] (g âˆ˜ â‡‘e)
theorem finite_dimensional.exists_is_basis_integral (A : Type u_2) (K : Type u_3) [comm_ring A] [field K] [is_domain A] [algebra A K] [is_fraction_ring A K] (L : Type u_4) [field L] [algebra K L] [finite_dimensional K L] [algebra A L] [is_scalar_tower A K L] : âˆƒ (s : finset L) (b : basis â†¥s K L), âˆ€ (x : â†¥s), is_integral A (â‡‘b x)
theorem con.ker_lift_mk {M : Type u_1} {P : Type u_3} [mul_one_class M] [mul_one_class P] {f : M â†’* P} (x : M) : â‡‘(con.ker_lift f) â†‘x = â‡‘f x
theorem measurable_space.dynkin_system.generate_from_eq {Î± : Type u_1} {s : set (set Î±)} (hs : is_pi_system s) : measurable_space.generate_from s = (measurable_space.dynkin_system.generate s).to_measurable_space _
theorem affine_equiv.affine_independent_iff {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {Î¹ : Type u_4} {Vâ‚‚ : Type u_5} {Pâ‚‚ : Type u_6} [add_comm_group Vâ‚‚] [module k Vâ‚‚] [add_torsor Vâ‚‚ Pâ‚‚] {p : Î¹ â†’ P} (e : P â‰ƒáµƒ[k] Pâ‚‚) : affine_independent k (â‡‘e âˆ˜ p) â†” affine_independent k p
theorem csupr_mem_Inter_Icc_of_antitone_Icc {Î± : Type u_1} {Î² : Type u_2} [conditionally_complete_lattice Î±] [semilattice_sup Î²] {f g : Î² â†’ Î±} (h : antitone (Î» (n : Î²), set.Icc (f n) (g n))) (h' : âˆ€ (n : Î²), f n â‰¤ g n) : (â¨† (n : Î²), f n) âˆˆ â‹‚ (n : Î²), set.Icc (f n) (g n)
theorem normed_group_hom.is_quotient_quotient {M : Type u_1} [semi_normed_group M] (S : add_subgroup M) : S.normed_mk.is_quotient
theorem category_theory.is_kernel_pair.is_reflexive_pair {C : Type u} [category_theory.category C] {A B R : C} {f g : R âŸ¶ A} {q : A âŸ¶ B} (h : category_theory.is_kernel_pair q f g) : category_theory.is_reflexive_pair f g
theorem self_adjoint.coe_re_map_spectrum {A : Type u_1} [normed_ring A] [normed_algebra â„‚ A] [complete_space A] [star_ring A] [cstar_ring A] [star_module â„‚ A] [nontrivial A] {a : A} (ha : a âˆˆ self_adjoint A) : spectrum â„‚ a = coe âˆ˜ complex.re '' spectrum â„‚ a
theorem edist_le_Ico_sum_edist {Î± : Type u} [pseudo_emetric_space Î±] (f : â„• â†’ Î±) {m n : â„•} (h : m â‰¤ n) : has_edist.edist (f m) (f n) â‰¤ (finset.Ico m n).sum (Î» (i : â„•), has_edist.edist (f i) (f (i + 1)))
theorem function.injective2.left {Î± : Sort u_1} {Î² : Sort u_2} {Î³ : Sort u_3} {f : Î± â†’ Î² â†’ Î³} (hf : function.injective2 f) (b : Î²) : function.injective (Î» (a : Î±), f a b)
theorem function.is_periodic_pt_zero {Î± : Type u_1} (f : Î± â†’ Î±) (x : Î±) : function.is_periodic_pt f 0 x
theorem con.Sup_eq_con_gen {M : Type u_1} [has_mul M] (S : set (con M)) : has_Sup.Sup S = con_gen (Î» (x y : M), âˆƒ (c : con M), c âˆˆ S âˆ§ â‡‘c x y)
theorem filter.tendsto.at_top_div_const {Î± : Type u_3} {Î² : Type u_4} [linear_ordered_field Î±] {l : filter Î²} {f : Î² â†’ Î±} {r : Î±} (hr : 0 < r) (hf : filter.tendsto f l filter.at_top) : filter.tendsto (Î» (x : Î²), f x / r) l filter.at_top
theorem box_integral.integrable.sum_integral_congr {Î¹ : Type u} {E : Type v} {F : Type w} [normed_group E] [normed_space â„ E] [normed_group F] [normed_space â„ F] {I : box_integral.box Î¹} [fintype Î¹] {l : box_integral.integration_params} {f : (Î¹ â†’ â„) â†’ E} {vol : box_integral.box_additive_map Î¹ (E â†’L[â„] F) âŠ¤} [complete_space F] (h : box_integral.integrable I l f vol) {Ï€â‚ Ï€â‚‚ : box_integral.prepartition I} (hU : Ï€â‚.Union = Ï€â‚‚.Union) : Ï€â‚.boxes.sum (Î» (J : box_integral.box Î¹), box_integral.integral J l f vol) = Ï€â‚‚.boxes.sum (Î» (J : box_integral.box Î¹), box_integral.integral J l f vol)
theorem antivary_on.sum_mul_lt_sum_comp_perm_mul_iff {Î¹ : Type u_1} {Î± : Type u_2} [linear_ordered_ring Î±] {s : finset Î¹} {Ïƒ : equiv.perm Î¹} {f g : Î¹ â†’ Î±} (hfg : antivary_on f g â†‘s) (hÏƒ : {x : Î¹ | â‡‘Ïƒ x â‰  x} âŠ† â†‘s) : s.sum (Î» (i : Î¹), f i * g i) < s.sum (Î» (i : Î¹), f (â‡‘Ïƒ i) * g i) â†” Â¬antivary_on (f âˆ˜ â‡‘Ïƒ) g â†‘s
theorem add_valuation.is_equiv.comap {R : Type u_2} {Î“â‚€ : Type u_3} {Î“'â‚€ : Type u_4} [linear_ordered_add_comm_monoid_with_top Î“â‚€] [linear_ordered_add_comm_monoid_with_top Î“'â‚€] [ring R] {vâ‚ : add_valuation R Î“â‚€} {vâ‚‚ : add_valuation R Î“'â‚€} {S : Type u_1} [ring S] (f : S â†’+* R) (h : vâ‚.is_equiv vâ‚‚) : (add_valuation.comap f vâ‚).is_equiv (add_valuation.comap f vâ‚‚)
theorem unique_diff_on_convex {G : Type u_4} [normed_group G] [normed_space â„ G] {s : set G} (conv : convex â„ s) (hs : (interior s).nonempty) : unique_diff_on â„ s
theorem category_theory.limits.biproduct.total {C : Type u} [category_theory.category C] [category_theory.preadditive C] {J : Type v} [fintype J] {f : J â†’ C} [category_theory.limits.has_biproduct f] : finset.univ.sum (Î» (j : J), category_theory.limits.biproduct.Ï€ f j â‰« category_theory.limits.biproduct.Î¹ f j) = ğŸ™ (â¨ f)
theorem is_coatom.dual {Î± : Type u_1} [preorder Î±] [order_top Î±] {a : Î±} : is_coatom a â†’ is_atom (â‡‘order_dual.to_dual a)
theorem isometry_emetric_iff_metric {Î± : Type u} {Î² : Type v} [pseudo_metric_space Î±] [pseudo_metric_space Î²] {f : Î± â†’ Î²} : isometry f â†” âˆ€ (x y : Î±), has_dist.dist (f x) (f y) = has_dist.dist x y
theorem orthonormal.map_linear_isometry_equiv {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {Î¹ : Type u_4} {E' : Type u_7} [inner_product_space ğ•œ E'] {v : basis Î¹ ğ•œ E} (hv : orthonormal ğ•œ â‡‘v) (f : E â‰ƒâ‚—áµ¢[ğ•œ] E') : orthonormal ğ•œ â‡‘(v.map f.to_linear_equiv)
theorem submonoid.localization_map.eq_of_eq {M : Type u_1} [comm_monoid M] {S : submonoid M} {N : Type u_2} [comm_monoid N] {P : Type u_3} [comm_monoid P] (f : S.localization_map N) {g : M â†’* P} (hg : âˆ€ (y : â†¥S), is_unit (â‡‘g â†‘y)) {x y : M} (h : â‡‘(f.to_map) x = â‡‘(f.to_map) y) : â‡‘g x = â‡‘g y
theorem function.injective.exists_ne {Î± : Type u_1} {Î² : Type u_2} [nontrivial Î±] {f : Î± â†’ Î²} (hf : function.injective f) (y : Î²) : âˆƒ (x : Î±), f x â‰  y
theorem norm_pow_le {Î± : Type u_1} [semi_normed_ring Î±] [norm_one_class Î±] (a : Î±) (n : â„•) : âˆ¥a ^ nâˆ¥ â‰¤ âˆ¥aâˆ¥ ^ n
theorem mem_nhds_within_Ici_iff_exists_Ico_subset {Î± : Type u} [topological_space Î±] [linear_order Î±] [order_topology Î±] [no_max_order Î±] {a : Î±} {s : set Î±} : s âˆˆ nhds_within a (set.Ici a) â†” âˆƒ (u : Î±) (H : u âˆˆ set.Ioi a), set.Ico a u âŠ† s
theorem domain_mvt {E : Type u_1} [normed_group E] [normed_space â„ E] {f : E â†’ â„} {s : set E} {x y : E} {f' : E â†’ (E â†’L[â„] â„)} (hf : âˆ€ (x : E), x âˆˆ s â†’ has_fderiv_within_at f (f' x) s x) (hs : convex â„ s) (xs : x âˆˆ s) (ys : y âˆˆ s) : âˆƒ (z : E) (H : z âˆˆ segment â„ x y), f y - f x = â‡‘(f' z) (y - x)
theorem padic_norm.nonarchimedean (p : â„•) [hp : fact (nat.prime p)] {q r : â„š} : padic_norm p (q + r) â‰¤ linear_order.max (padic_norm p q) (padic_norm p r)
theorem category_theory.triangulated.pretriangulated.comp_dist_triangle_mor_zeroâ‚‚â‚ƒ (C : Type u) [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.has_shift C â„¤] [category_theory.preadditive C] [âˆ€ (n : â„¤), (category_theory.shift_functor C n).additive] [category_theory.triangulated.pretriangulated C] (T : category_theory.triangulated.triangle C) (H : T âˆˆ dist_triang C) : T.morâ‚‚ â‰« T.morâ‚ƒ = 0
theorem algebraic_geometry.polynomial.is_open_map_comap_C {R : Type u_1} [comm_ring R] : is_open_map â‡‘(prime_spectrum.comap polynomial.C)
theorem free_group.ext_hom {Î± : Type u} {G : Type u_1} [group G] (f g : free_group Î± â†’* G) (h : âˆ€ (a : Î±), â‡‘f (free_group.of a) = â‡‘g (free_group.of a)) : f = g
theorem le_nhds_of_Limsup_eq_Liminf {Î± : Type u} [conditionally_complete_linear_order Î±] [topological_space Î±] [order_topology Î±] {f : filter Î±} {a : Î±} (hl : filter.is_bounded has_le.le f) (hg : filter.is_bounded ge f) (hs : f.Limsup = a) (hi : f.Liminf = a) : f â‰¤ nhds a
theorem cont_diff_on.comp_continuous_linear_map {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {G : Type u_4} [normed_group G] [normed_space ğ•œ G] {s : set E} {f : E â†’ F} {n : with_top â„•} (hf : cont_diff_on ğ•œ n f s) (g : G â†’L[ğ•œ] E) : cont_diff_on ğ•œ n (f âˆ˜ â‡‘g) (â‡‘g â»Â¹' s)
theorem multiples.is_add_submonoid {M : Type u_1} [add_monoid M] (x : M) : is_add_submonoid (multiples x)
theorem interval_integrable_sub_inv_iff {a b c : â„} : interval_integrable (Î» (x : â„), (x - c)â»Â¹) measure_theory.measure_space.volume a b â†” a = b âˆ¨ c âˆ‰ set.interval a b
theorem measure_theory.outer_measure.bounded_by_union_of_top_of_nonempty_inter {Î± : Type u_1} {m : set Î± â†’ ennreal} {s t : set Î±} (h : âˆ€ (u : set Î±), (s âˆ© u).nonempty â†’ (t âˆ© u).nonempty â†’ m u = âŠ¤) : â‡‘(measure_theory.outer_measure.bounded_by m) (s âˆª t) = â‡‘(measure_theory.outer_measure.bounded_by m) s + â‡‘(measure_theory.outer_measure.bounded_by m) t
theorem convex.strict_anti_on_of_deriv_neg {D : set â„} (hD : convex â„ D) {f : â„ â†’ â„} (hf : continuous_on f D) (hf' : âˆ€ (x : â„), x âˆˆ interior D â†’ deriv f x < 0) : strict_anti_on f D
theorem tendsto_nhds_lim {Î± : Type u} {Î² : Type v} [topological_space Î±] {f : filter Î²} {g : Î² â†’ Î±} (h : âˆƒ (a : Î±), filter.tendsto g f (nhds a)) : filter.tendsto g f (nhds (lim f g))
theorem complete_lattice.independent.linear_independent {Î¹ : Type u_1} {R : Type u_2} {N : Type u_5} [ring R] [add_comm_group N] [module R N] [no_zero_smul_divisors R N] (p : Î¹ â†’ submodule R N) (hp : complete_lattice.independent p) {v : Î¹ â†’ N} (hv : âˆ€ (i : Î¹), v i âˆˆ p i) (hv' : âˆ€ (i : Î¹), v i â‰  0) : linear_independent R v
theorem cont_diff_on.mul {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {n : with_top â„•} {s : set E} {f g : E â†’ ğ•œ} (hf : cont_diff_on ğ•œ n f s) (hg : cont_diff_on ğ•œ n g s) : cont_diff_on ğ•œ n (Î» (x : E), f x * g x) s
theorem is_open_map.to_quotient_map {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] {f : Î± â†’ Î²} (open_map : is_open_map f) (cont : continuous f) (surj : function.surjective f) : quotient_map f
theorem subsemigroup.mul_mem {M : Type u_1} [has_mul M] (S : subsemigroup M) {x y : M} : x âˆˆ S â†’ y âˆˆ S â†’ x * y âˆˆ S
theorem ideal.exists_ideal_over_prime_of_is_integral' {R : Type u_1} [comm_ring R] {S : Type u_2} [comm_ring S] [algebra R S] [is_domain S] (H : algebra.is_integral R S) (P : ideal R) [P.is_prime] (hP : (algebra_map R S).ker â‰¤ P) : âˆƒ (Q : ideal S), Q.is_prime âˆ§ ideal.comap (algebra_map R S) Q = P
theorem algebraic_geometry.PresheafedSpace.glue_data.Ï€_Î¹_inv_app_eq_id {C : Type u} [category_theory.category C] (D : algebraic_geometry.PresheafedSpace.glue_data C) [category_theory.limits.has_limits C] (i : D.to_glue_data.J) (U : topological_space.opens â†¥((D.to_glue_data.U i).carrier)) : D.diagram_over_open_Ï€ U i â‰« D.Î¹_inv_app_Ï€_eq_map U â‰« D.Î¹_inv_app U = ğŸ™ (category_theory.limits.limit (D.diagram_over_open U))
theorem normed_field.tendsto_zero_smul_of_tendsto_zero_of_bounded {Î¹ : Type u_1} {ğ•œ : Type u_2} {ğ”¸ : Type u_3} [normed_field ğ•œ] [normed_group ğ”¸] [normed_space ğ•œ ğ”¸] {l : filter Î¹} {Îµ : Î¹ â†’ ğ•œ} {f : Î¹ â†’ ğ”¸} (hÎµ : filter.tendsto Îµ l (nhds 0)) (hf : filter.is_bounded_under has_le.le l (has_norm.norm âˆ˜ f)) : filter.tendsto (Îµ â€¢ f) l (nhds 0)
theorem norm_bound {ğ•œ : Type u_1} [is_R_or_C ğ•œ] {F : Type u_2} [semi_normed_group F] [normed_space ğ•œ F] [normed_space â„ F] [is_scalar_tower â„ ğ•œ F] (fr : F â†’L[â„] â„) (x : F) : âˆ¥â‡‘(fr.to_linear_map.extend_to_ğ•œ') xâˆ¥ â‰¤ âˆ¥frâˆ¥ * âˆ¥xâˆ¥
theorem bump_covering.exists_is_subordinate_of_locally_finite {Î¹ : Type u} {X : Type v} [topological_space X] {s : set X} [normal_space X] (hs : is_closed s) (U : Î¹ â†’ set X) (ho : âˆ€ (i : Î¹), is_open (U i)) (hf : locally_finite U) (hU : s âŠ† â‹ƒ (i : Î¹), U i) : âˆƒ (f : bump_covering Î¹ X s), f.is_subordinate U
theorem matrix.is_diag_from_blocks_iff {Î± : Type u_1} {n : Type u_4} {m : Type u_5} [has_zero Î±] {A : matrix m m Î±} {B : matrix m n Î±} {C : matrix n m Î±} {D : matrix n n Î±} : (matrix.from_blocks A B C D).is_diag â†” A.is_diag âˆ§ B = 0 âˆ§ C = 0 âˆ§ D.is_diag
theorem cardinal.ord_card_unbounded'  : set.unbounded has_lt.lt {b : ordinal | b.card.ord = b âˆ§ ordinal.omega â‰¤ b}
theorem is_local_extr.fderiv_eq_zero {E : Type u} [normed_group E] [normed_space â„ E] {f : E â†’ â„} {a : E} (h : is_local_extr f a) : fderiv â„ f a = 0
theorem exists_has_deriv_within_at_eq_of_lt_of_gt {a b : â„} {f f' : â„ â†’ â„} (hab : a â‰¤ b) (hf : âˆ€ (x : â„), x âˆˆ set.Icc a b â†’ has_deriv_within_at f (f' x) (set.Icc a b) x) {m : â„} (hma : m < f' a) (hmb : f' b < m) : m âˆˆ f' '' set.Icc a b
theorem exists_nhds_square {Î± : Type u} [topological_space Î±] {s : set (Î± Ã— Î±)} {x : Î±} (hx : s âˆˆ nhds (x, x)) : âˆƒ (U : set Î±), is_open U âˆ§ x âˆˆ U âˆ§ U Ã—Ë¢ U âŠ† s
theorem direct_sum.alg_hom_ext' {Î¹ : Type uÎ¹} (R : Type uR) (A : Î¹ â†’ Type uA) {B : Type uB} [decidable_eq Î¹] [comm_semiring R] [Î  (i : Î¹), add_comm_monoid (A i)] [Î  (i : Î¹), module R (A i)] [add_monoid Î¹] [direct_sum.gsemiring A] [semiring B] [direct_sum.galgebra R A] [algebra R B] â¦ƒf g : direct_sum Î¹ (Î» (i : Î¹), A i) â†’â‚[R] Bâ¦„ (h : âˆ€ (i : Î¹), f.to_linear_map.comp (direct_sum.lof R Î¹ A i) = g.to_linear_map.comp (direct_sum.lof R Î¹ A i)) : f = g
theorem category_theory.nat_trans.right_derived_eq {C : Type u} [category_theory.category C] {D : Type u_1} [category_theory.category D] [category_theory.abelian C] [category_theory.has_injective_resolutions C] [category_theory.abelian D] {F G : C â¥¤ D} [F.additive] [G.additive] (Î± : F âŸ¶ G) (n : â„•) {X : C} (P : category_theory.InjectiveResolution X) : (category_theory.nat_trans.right_derived Î± n).app X = (F.right_derived_obj_iso n P).hom â‰« (homology_functor D (complex_shape.up â„•) n).map ((category_theory.nat_trans.map_homological_complex Î± (complex_shape.up â„•)).app P.cocomplex) â‰« (G.right_derived_obj_iso n P).inv
theorem algebraic_geometry.polynomial.comap_C_mem_image_of_Df {R : Type u_1} [comm_ring R] {f : polynomial R} {I : prime_spectrum (polynomial R)} (H : I âˆˆ (prime_spectrum.zero_locus {f})á¶œ) : â‡‘(prime_spectrum.comap polynomial.C) I âˆˆ algebraic_geometry.polynomial.image_of_Df f
theorem structure_groupoid.local_invariant_prop.lift_prop_within_at_indep_chart_aux {H : Type u_1} {M : Type u_2} [topological_space H] [topological_space M] [charted_space H M] {H' : Type u_3} {M' : Type u_4} [topological_space H'] [topological_space M'] [charted_space H' M'] {G : structure_groupoid H} {G' : structure_groupoid H'} {e e' : local_homeomorph M H} {f f' : local_homeomorph M' H'} {P : (H â†’ H') â†’ set H â†’ H â†’ Prop} {g : M â†’ M'} {s : set M} {x : M} (hG : G.local_invariant_prop G' P) (he : e âˆˆ structure_groupoid.maximal_atlas M G) (xe : x âˆˆ e.to_local_equiv.source) (he' : e' âˆˆ structure_groupoid.maximal_atlas M G) (xe' : x âˆˆ e'.to_local_equiv.source) (hf : f âˆˆ structure_groupoid.maximal_atlas M' G') (xf : g x âˆˆ f.to_local_equiv.source) (hf' : f' âˆˆ structure_groupoid.maximal_atlas M' G') (xf' : g x âˆˆ f'.to_local_equiv.source) (hgs : continuous_within_at g s x) (h : P (â‡‘f âˆ˜ g âˆ˜ â‡‘(e.symm)) (e.to_local_equiv.target âˆ© â‡‘(e.symm) â»Â¹' (s âˆ© g â»Â¹' f.to_local_equiv.source)) (â‡‘e x)) : P (â‡‘f' âˆ˜ g âˆ˜ â‡‘(e'.symm)) (e'.to_local_equiv.target âˆ© â‡‘(e'.symm) â»Â¹' (s âˆ© g â»Â¹' f'.to_local_equiv.source)) (â‡‘e' x)
theorem polynomial.cyclotomic_irreducible_of_irreducible_pow {p : â„•} (hp : nat.prime p) {R : Type u_1} [comm_ring R] [is_domain R] {n : â„•} (hn : n â‰  0) (h : irreducible (polynomial.cyclotomic (p ^ n) R)) : irreducible (polynomial.cyclotomic p R)
theorem finset.prod_subtype_of_mem {Î² : Type u} {Î± : Type v} {s : finset Î±} [comm_monoid Î²] (f : Î± â†’ Î²) {p : Î± â†’ Prop} [decidable_pred p] (h : âˆ€ (x : Î±), x âˆˆ s â†’ p x) : (finset.subtype p s).prod (Î» (x : subtype p), f â†‘x) = s.prod (Î» (x : Î±), f x)
theorem filter.tendsto.at_top_mul_neg_const {Î± : Type u_3} {Î² : Type u_4} [linear_ordered_field Î±] {l : filter Î²} {f : Î² â†’ Î±} {r : Î±} (hr : r < 0) (hf : filter.tendsto f l filter.at_top) : filter.tendsto (Î» (x : Î²), f x * r) l filter.at_bot
theorem zero_hom.congr_fun {M : Type u_3} {N : Type u_4} [has_zero M] [has_zero N] {f g : zero_hom M N} (h : f = g) (x : M) : â‡‘f x = â‡‘g x
theorem finset.prod_sigma {Î² : Type u} {Î± : Type v} [comm_monoid Î²] {Ïƒ : Î± â†’ Type u_1} (s : finset Î±) (t : Î  (a : Î±), finset (Ïƒ a)) (f : sigma Ïƒ â†’ Î²) : (s.sigma t).prod (Î» (x : Î£ (i : Î±), Ïƒ i), f x) = s.prod (Î» (a : Î±), (t a).prod (Î» (s : Ïƒ a), f âŸ¨a, sâŸ©))
theorem reflection_involutive {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] (K : submodule ğ•œ E) [complete_space â†¥K] : function.involutive â‡‘(reflection K)
theorem is_localization.localization_localization_is_localization {R : Type u_1} [comm_ring R] (M : submonoid R) {S : Type u_2} [comm_ring S] [algebra R S] (N : submonoid S) (T : Type u_4) [comm_ring T] [algebra R T] [algebra S T] [is_scalar_tower R S T] [is_localization M S] [is_localization N T] : is_localization (is_localization.localization_localization_submodule M N) T
theorem basis.orientation_ne_iff_eq_neg {R : Type u_1} [linear_ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {Î¹ : Type u_3} [decidable_eq Î¹] [fintype Î¹] (e : basis Î¹ R M) (x : orientation R M Î¹) : x â‰  e.orientation â†” x = -e.orientation
theorem measure_theory.null_of_locally_null {Î± : Type u_1} {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [topological_space Î±] [topological_space.second_countable_topology Î±] (s : set Î±) (hs : âˆ€ (x : Î±), x âˆˆ s â†’ (âˆƒ (u : set Î±) (H : u âˆˆ nhds_within x s), â‡‘Î¼ u = 0)) : â‡‘Î¼ s = 0
theorem measure_theory.indicator_const_Lp_disjoint_union {Î± : Type u_1} {E : Type u_2} {m0 : measurable_space Î±} {p : ennreal} {Î¼ : measure_theory.measure Î±} [normed_group E] {s t : set Î±} (hs : measurable_set s) (ht : measurable_set t) (hÎ¼s : â‡‘Î¼ s â‰  âŠ¤) (hÎ¼t : â‡‘Î¼ t â‰  âŠ¤) (hst : s âˆ© t = âˆ…) (c : E) : measure_theory.indicator_const_Lp p _ _ c = measure_theory.indicator_const_Lp p hs hÎ¼s c + measure_theory.indicator_const_Lp p ht hÎ¼t c
theorem nat.of_digits_lt_base_pow_length' {b : â„•} {l : list â„•} (hl : âˆ€ (x : â„•), x âˆˆ l â†’ x < b + 2) : nat.of_digits (b + 2) l < (b + 2) ^ l.length
theorem measure_theory.tendsto_measure_bInter_gt {Î± : Type u_1} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {Î¹ : Type u_2} [linear_order Î¹] [topological_space Î¹] [order_topology Î¹] [densely_ordered Î¹] [topological_space.first_countable_topology Î¹] {s : Î¹ â†’ set Î±} {a : Î¹} (hs : âˆ€ (r : Î¹), r > a â†’ measurable_set (s r)) (hm : âˆ€ (i j : Î¹), a < i â†’ i â‰¤ j â†’ s i âŠ† s j) (hf : âˆƒ (r : Î¹) (H : r > a), â‡‘Î¼ (s r) â‰  âŠ¤) : filter.tendsto (â‡‘Î¼ âˆ˜ s) (nhds_within a (set.Ioi a)) (nhds (â‡‘Î¼ (â‹‚ (r : Î¹) (H : r > a), s r)))
theorem category_theory.limits.is_terminal.mono_from {C : Type uâ‚} [category_theory.category C] {X Y : C} (t : category_theory.limits.is_terminal X) (f : X âŸ¶ Y) : category_theory.mono f
theorem sylow.exists_subgroup_card_pow_prime {G : Type u} [group G] [fintype G] (p : â„•) {n : â„•} [fact (nat.prime p)] (hdvd : p ^ n âˆ£ fintype.card G) : âˆƒ (K : subgroup G), fintype.card â†¥K = p ^ n
theorem submonoid.localization_map.map_mul_right {M : Type u_1} [comm_monoid M] {S : submonoid M} {N : Type u_2} [comm_monoid N] {P : Type u_3} [comm_monoid P] (f : S.localization_map N) {g : M â†’* P} {T : submonoid P} (hy : âˆ€ (y : â†¥S), â‡‘g â†‘y âˆˆ T) {Q : Type u_4} [comm_monoid Q] {k : T.localization_map Q} (z : N) : â‡‘(f.map hy k) z * â‡‘(k.to_map) (â‡‘g â†‘((f.sec z).snd)) = â‡‘(k.to_map) (â‡‘g (f.sec z).fst)
theorem associates.eq_pow_count_factors_of_dvd_pow {Î± : Type u_1} [cancel_comm_monoid_with_zero Î±] [dec_irr : Î  (p : associates Î±), decidable (irreducible p)] [unique_factorization_monoid Î±] [dec : decidable_eq Î±] [dec' : decidable_eq (associates Î±)] {p a : associates Î±} (hp : irreducible p) {n : â„•} (h : a âˆ£ p ^ n) : a = p ^ p.count a.factors
theorem fin.lt_succ_above_iff {n : â„•} (p : fin (n + 1)) (i : fin n) : p < â‡‘(p.succ_above) i â†” p â‰¤ â‡‘fin.cast_succ i
theorem formal_multilinear_series.comp_change_of_variables_sum {Î± : Type u_1} [add_comm_monoid Î±] (m M N : â„•) (f : (Î£ (n : â„•), fin n â†’ â„•) â†’ Î±) (g : (Î£ (n : â„•), composition n) â†’ Î±) (h : âˆ€ (e : Î£ (n : â„•), fin n â†’ â„•) (he : e âˆˆ formal_multilinear_series.comp_partial_sum_source m M N), f e = g (formal_multilinear_series.comp_change_of_variables m M N e he)) : (formal_multilinear_series.comp_partial_sum_source m M N).sum (Î» (e : Î£ (n : â„•), fin n â†’ â„•), f e) = (formal_multilinear_series.comp_partial_sum_target m M N).sum (Î» (e : Î£ (n : â„•), composition n), g e)
theorem interval_integral.measure_integral_sub_linear_is_o_of_tendsto_ae {Î¹ : Type u_1} {E : Type u_3} [normed_group E] [complete_space E] [normed_space â„ E] {f : â„ â†’ E} {a : â„} {c : E} {l l' : filter â„} {lt : filter Î¹} {Î¼ : measure_theory.measure â„} {u v : Î¹ â†’ â„} [measure_theory.is_locally_finite_measure Î¼] [interval_integral.FTC_filter a l l'] (hfm : strongly_measurable_at_filter f l' Î¼) (hf : filter.tendsto f (l' âŠ“ Î¼.ae) (nhds c)) (hu : filter.tendsto u lt l) (hv : filter.tendsto v lt l) : (Î» (t : Î¹), âˆ« (x : â„) in u t..v t, f x âˆ‚Î¼ - âˆ« (x : â„) in u t..v t, c âˆ‚Î¼) =o[lt] Î» (t : Î¹), âˆ« (x : â„) in u t..v t, 1 âˆ‚Î¼
theorem emetric.tendsto_uniformly_iff {Î± : Type u} {Î² : Type v} [pseudo_emetric_space Î±] {Î¹ : Type u_1} {F : Î¹ â†’ Î² â†’ Î±} {f : Î² â†’ Î±} {p : filter Î¹} : tendsto_uniformly F f p â†” âˆ€ (Îµ : ennreal), Îµ > 0 â†’ (âˆ€á¶  (n : Î¹) in p, âˆ€ (x : Î²), has_edist.edist (f x) (F n x) < Îµ)
theorem subfield.neg_mem {K : Type u} [field K] (s : subfield K) {x : K} : x âˆˆ s â†’ -x âˆˆ s
theorem add_submonoid.localization_map.map_map {M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {N : Type u_2} [add_comm_monoid N] {P : Type u_3} [add_comm_monoid P] (f : S.localization_map N) {g : M â†’+ P} {T : add_submonoid P} (hy : âˆ€ (y : â†¥S), â‡‘g â†‘y âˆˆ T) {Q : Type u_4} [add_comm_monoid Q] {k : T.localization_map Q} {A : Type u_5} [add_comm_monoid A] {U : add_submonoid A} {R : Type u_6} [add_comm_monoid R] (j : U.localization_map R) {l : P â†’+ A} (hl : âˆ€ (w : â†¥T), â‡‘l â†‘w âˆˆ U) (x : N) : â‡‘(k.map hl j) (â‡‘(f.map hy k) x) = â‡‘(f.map _ j) x
theorem measurable_liminf' {Î± : Type u_1} {Î´ : Type u_5} [topological_space Î±] [measurable_space Î±] [borel_space Î±] [measurable_space Î´] [complete_linear_order Î±] [order_topology Î±] [topological_space.second_countable_topology Î±] {Î¹ : Type u_2} {Î¹' : Type u_3} {f : Î¹ â†’ Î´ â†’ Î±} {u : filter Î¹} (hf : âˆ€ (i : Î¹), measurable (f i)) {p : Î¹' â†’ Prop} {s : Î¹' â†’ set Î¹} (hu : u.has_countable_basis p s) (hs : âˆ€ (i : Î¹'), (s i).countable) : measurable (Î» (x : Î´), u.liminf (Î» (i : Î¹), f i x))
theorem measure_theory.measure.finite_spanning_sets_in.outer_regular {Î± : Type u_1} [measurable_space Î±] [topological_space Î±] [opens_measurable_space Î±] {Î¼ : measure_theory.measure Î±} (s : Î¼.finite_spanning_sets_in {U : set Î± | is_open U âˆ§ (Î¼.restrict U).outer_regular}) : Î¼.outer_regular
theorem orthonormal.oangle_add_oangle_rev_neg_left {V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) (x y : V) : hb.oangle (-x) y + hb.oangle (-y) x = 0
theorem metric.closure_subset_cthickening {Î± : Type u} [pseudo_emetric_space Î±] (Î´ : â„) (E : set Î±) : closure E âŠ† metric.cthickening Î´ E
theorem algebra_map_int_eq (R : Type u_1) [ring R] : algebra_map â„¤ R = int.cast_ring_hom R
theorem partition_of_unity.exists_is_subordinate_of_locally_finite {Î¹ : Type u} {X : Type v} [topological_space X] {s : set X} [normal_space X] (hs : is_closed s) (U : Î¹ â†’ set X) (ho : âˆ€ (i : Î¹), is_open (U i)) (hf : locally_finite U) (hU : s âŠ† â‹ƒ (i : Î¹), U i) : âˆƒ (f : partition_of_unity Î¹ X s), f.is_subordinate U
theorem nat.odd_mod_four_iff {n : â„•} : n % 2 = 1 â†” n % 4 = 1 âˆ¨ n % 4 = 3
theorem mul_inv_mul_self {Gâ‚€ : Type u_2} [group_with_zero Gâ‚€] (a : Gâ‚€) : a * aâ»Â¹ * a = a
theorem submodule.orthogonal_gc (ğ•œ : Type u_1) (E : Type u_2) [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] : galois_connection submodule.orthogonal submodule.orthogonal
theorem add_subsemigroup.subset_closure {M : Type u_1} [has_add M] {s : set M} : s âŠ† â†‘(add_subsemigroup.closure s)
theorem dense_liouville  : dense {x : â„ | liouville x}
theorem finset.exists_card_fiber_le_of_card_le_nsmul {Î± : Type u} {Î² : Type v} {M : Type w} [decidable_eq Î²] {s : finset Î±} {t : finset Î²} {f : Î± â†’ Î²} {b : M} [linear_ordered_comm_ring M] (ht : t.nonempty) (hb : â†‘(s.card) â‰¤ t.card â€¢ b) : âˆƒ (y : Î²) (H : y âˆˆ t), â†‘((finset.filter (Î» (x : Î±), f x = y) s).card) â‰¤ b
theorem intermediate_field.bot_eq_top_of_dim_adjoin_eq_one {F : Type u_1} [field F] {E : Type u_2} [field E] [algebra F E] (h : âˆ€ (x : E), module.rank F â†¥FâŸ®xâŸ¯ = 1) : âŠ¥ = âŠ¤
theorem quotient.eq_rel {Î± : Type u_1} {r : setoid Î±} {x y : Î±} : quotient.mk' x = quotient.mk' y â†” r.rel x y
theorem asymptotics.is_o.norm_right {Î± : Type u_1} {E : Type u_3} {F' : Type u_7} [has_norm E] [semi_normed_group F'] {f : Î± â†’ E} {g' : Î± â†’ F'} {l : filter Î±} : f =o[l] g' â†’ (f =o[l] Î» (x : Î±), âˆ¥g' xâˆ¥)
theorem filter.tendsto.cesaro_smul {E : Type u_1} [normed_group E] [normed_space â„ E] {u : â„• â†’ E} {l : E} (h : filter.tendsto u filter.at_top (nhds l)) : filter.tendsto (Î» (n : â„•), (â†‘n)â»Â¹ â€¢ (finset.range n).sum (Î» (i : â„•), u i)) filter.at_top (nhds l)
theorem continuous.ae_measurable {Î± : Type u_1} {Î³ : Type u_3} [topological_space Î±] [measurable_space Î±] [opens_measurable_space Î±] [topological_space Î³] [measurable_space Î³] [borel_space Î³] {f : Î± â†’ Î³} (h : continuous f) {Î¼ : measure_theory.measure Î±} : ae_measurable f Î¼
theorem mem_nhds_within_Ici_iff_exists_Ico_subset' {Î± : Type u} [topological_space Î±] [linear_order Î±] [order_topology Î±] {a u' : Î±} {s : set Î±} (hu' : a < u') : s âˆˆ nhds_within a (set.Ici a) â†” âˆƒ (u : Î±) (H : u âˆˆ set.Ioi a), set.Ico a u âŠ† s
theorem orthonormal.oangle_add_cyc3 {V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) {x y z : V} (hx : x â‰  0) (hy : y â‰  0) (hz : z â‰  0) : hb.oangle x y + hb.oangle y z + hb.oangle z x = 0
theorem euclidean_geometry.angle_comm {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] (p1 p2 p3 : P) : euclidean_geometry.angle p1 p2 p3 = euclidean_geometry.angle p3 p2 p1
theorem ideal.is_jacobson_localization {R : Type u_1} {S : Type u_2} [comm_ring R] [comm_ring S] (y : R) [algebra R S] [is_localization.away y S] [H : ideal.is_jacobson R] : ideal.is_jacobson S
theorem centroid_mem_affine_span_of_nonempty (k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] {Î¹ : Type u_4} [char_zero k] {s : finset Î¹} (p : Î¹ â†’ P) (h : s.nonempty) : finset.centroid k s p âˆˆ affine_span k (set.range p)
theorem measure_theory.lintegral_with_density_eq_lintegral_mul {Î± : Type u_1} {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) {f : Î± â†’ ennreal} (h_mf : measurable f) {g : Î± â†’ ennreal} : measurable g â†’ âˆ«â» (a : Î±), g a âˆ‚Î¼.with_density f = âˆ«â» (a : Î±), (f * g) a âˆ‚Î¼
theorem finset.weighted_vsub_of_point_eq_of_sum_eq_zero {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {Î¹ : Type u_4} (s : finset Î¹) (w : Î¹ â†’ k) (p : Î¹ â†’ P) (h : s.sum (Î» (i : Î¹), w i) = 0) (bâ‚ bâ‚‚ : P) : â‡‘(s.weighted_vsub_of_point p bâ‚) w = â‡‘(s.weighted_vsub_of_point p bâ‚‚) w
theorem linear_map.trace_one (R : Type u_1) [comm_ring R] (M : Type u_2) [add_comm_group M] [module R M] [module.free R M] [module.finite R M] [nontrivial R] : â‡‘(linear_map.trace R M) 1 = â†‘(finite_dimensional.finrank R M)
theorem is_monoid_hom.inv {Î± : Type u_1} {Î² : Type u_2} [mul_one_class Î±] [comm_group Î²] {f : Î± â†’ Î²} (hf : is_monoid_hom f) : is_monoid_hom (Î» (a : Î±), (f a)â»Â¹)
theorem formal_multilinear_series.change_origin_eval {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field ğ•œ] [normed_group E] [normed_space ğ•œ E] [normed_group F] [normed_space ğ•œ F] [complete_space F] (p : formal_multilinear_series ğ•œ E F) {x y : E} (h : â†‘âˆ¥xâˆ¥â‚Š + â†‘âˆ¥yâˆ¥â‚Š < p.radius) : (p.change_origin x).sum y = p.sum (x + y)
theorem is_free_groupoid.path_nonempty_of_hom {G : Type u} [category_theory.groupoid G] [is_free_groupoid G] {a b : G} : nonempty (a âŸ¶ b) â†’ nonempty (quiver.path (symgen a) (symgen b))
theorem linear_map.exists_extend {K : Type u_4} {V : Type u} {V' : Type u_8} [field K] [add_comm_group V] [add_comm_group V'] [module K V] [module K V'] {p : submodule K V} (f : â†¥p â†’â‚—[K] V') : âˆƒ (g : V â†’â‚—[K] V'), g.comp p.subtype = f
theorem exp_char_one_of_char_zero (R : Type u) [semiring R] (q : â„•) [hp : char_p R 0] [hq : exp_char R q] : q = 1
theorem measure_theory.L2.inner_indicator_const_Lp_one {Î± : Type u_1} {ğ•œ : Type u_4} [is_R_or_C ğ•œ] [measurable_space Î±] {Î¼ : measure_theory.measure Î±} {s : set Î±} (hs : measurable_set s) (hÎ¼s : â‡‘Î¼ s â‰  âŠ¤) (f : â†¥(measure_theory.Lp ğ•œ 2 Î¼)) : has_inner.inner (measure_theory.indicator_const_Lp 2 hs hÎ¼s 1) f = âˆ« (x : Î±) in s, â‡‘f x âˆ‚Î¼
theorem filter.tendsto.neg_const_mul_at_bot {Î± : Type u_3} {Î² : Type u_4} [linear_ordered_field Î±] {l : filter Î²} {f : Î² â†’ Î±} {r : Î±} (hr : r < 0) (hf : filter.tendsto f l filter.at_bot) : filter.tendsto (Î» (x : Î²), r * f x) l filter.at_top
theorem tendsto_uniformly_on.comp' {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} {Î¹ : Type u_4} [uniform_space Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : set Î±} {p : filter Î¹} [uniform_space Î³] {g : Î² â†’ Î³} (h : tendsto_uniformly_on F f p s) (hg : uniform_continuous g) : tendsto_uniformly_on (Î» (i : Î¹), g âˆ˜ F i) (g âˆ˜ f) p s
theorem has_mfderiv_within_at.has_fderiv_within_at {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {E' : Type u_3} [normed_group E'] [normed_space ğ•œ E'] {f : E â†’ E'} {s : set E} {x : E} {f' : tangent_space (model_with_corners_self ğ•œ E) x â†’L[ğ•œ] tangent_space (model_with_corners_self ğ•œ E') (f x)} : has_mfderiv_within_at (model_with_corners_self ğ•œ E) (model_with_corners_self ğ•œ E') f s x f' â†’ has_fderiv_within_at f f' s x
theorem simplex_category.Ïƒ_comp_Ïƒ {n : â„•} {i j : fin (n + 1)} (H : i â‰¤ j) : simplex_category.Ïƒ (â‡‘fin.cast_succ i) â‰« simplex_category.Ïƒ j = simplex_category.Ïƒ j.succ â‰« simplex_category.Ïƒ i
theorem ring_hom.is_integral_elem_leading_coeff_mul {R : Type u_1} {S : Type u_4} [comm_ring R] [comm_ring S] (f : R â†’+* S) (p : polynomial R) (x : S) (h : polynomial.evalâ‚‚ f x p = 0) : f.is_integral_elem (â‡‘f p.leading_coeff * x)
theorem has_continuous_add_of_smooth {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {H : Type u_2} [topological_space H] {E : Type u_3} [normed_group E] [normed_space ğ•œ E] (I : model_with_corners ğ•œ E H) {G : Type u_4} [has_add G] [topological_space G] [charted_space H G] [has_smooth_add I G] : has_continuous_add G
theorem has_fderiv_at.of_local_left_inverse {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {f : E â†’ F} {f' : E â‰ƒL[ğ•œ] F} {g : F â†’ E} {a : F} (hg : continuous_at g a) (hf : has_fderiv_at f â†‘f' (g a)) (hfg : âˆ€á¶  (y : F) in nhds a, f (g y) = y) : has_fderiv_at g â†‘(f'.symm) a
theorem mul_sub_mul_div_mul_nonpos {Î± : Type u_1} [linear_ordered_field Î±] {a b c d : Î±} (hc : c â‰  0) (hd : d â‰  0) : a / c â‰¤ b / d â†’ (a * d - b * c) / (c * d) â‰¤ 0
theorem affine_subspace.not_le_iff_exists {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] (s1 s2 : affine_subspace k P) : Â¬s1 â‰¤ s2 â†” âˆƒ (p : P) (H : p âˆˆ s1), p âˆ‰ s2
theorem is_dedekind_domain.height_one_spectrum.int_valuation.map_one' {R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] (v : is_dedekind_domain.height_one_spectrum R) : v.int_valuation_def 1 = 1
theorem measure_theory.integrable.tendsto_set_integral_nhds_zero {Î± : Type u_1} {E : Type u_2} [normed_group E] [normed_space â„ E] [complete_space E] {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {Î¹ : Type u_3} {f : Î± â†’ E} (hf : measure_theory.integrable f Î¼) {l : filter Î¹} {s : Î¹ â†’ set Î±} (hs : filter.tendsto (â‡‘Î¼ âˆ˜ s) l (nhds 0)) : filter.tendsto (Î» (i : Î¹), âˆ« (x : Î±) in s i, f x âˆ‚Î¼) l (nhds 0)
theorem units.mul_left_dvd {Î± : Type u_1} [comm_monoid Î±] {a b : Î±} {u : Î±Ë£} : â†‘u * a âˆ£ b â†” a âˆ£ b
theorem mul_mem_class.mul_right_mem_add_closure {M : Type u_1} {R : Type u_4} [non_unital_non_assoc_semiring R] [set_like M R] [mul_mem_class M R] {S : M} {a b : R} (ha : a âˆˆ add_submonoid.closure â†‘S) (hb : b âˆˆ S) : a * b âˆˆ add_submonoid.closure â†‘S
theorem category_theory.limits.pushout_cocone.coequalizer_ext {C : Type u} [category_theory.category C] {X Y Z : C} {f : X âŸ¶ Y} {g : X âŸ¶ Z} (t : category_theory.limits.pushout_cocone f g) {W : C} {k l : t.X âŸ¶ W} (hâ‚€ : t.inl â‰« k = t.inl â‰« l) (hâ‚ : t.inr â‰« k = t.inr â‰« l) (j : category_theory.limits.walking_span) : t.Î¹.app j â‰« k = t.Î¹.app j â‰« l
theorem complex.re_eq_add_conj (z : â„‚) : â†‘(z.re) = (z + â‡‘(star_ring_end â„‚) z) / 2
theorem matrix.conj_transpose_smul {m : Type u_2} {n : Type u_3} {R : Type u_7} {Î± : Type v} [has_star R] [has_star Î±] [has_scalar R Î±] [star_module R Î±] (c : R) (M : matrix m n Î±) : (c â€¢ M).conj_transpose = has_star.star c â€¢ M.conj_transpose
theorem simplex_category.Î´_comp_Ïƒ_of_le {n : â„•} {i : fin (n + 2)} {j : fin (n + 1)} (H : i â‰¤ â‡‘fin.cast_succ j) : simplex_category.Î´ (â‡‘fin.cast_succ i) â‰« simplex_category.Ïƒ j.succ = simplex_category.Ïƒ j â‰« simplex_category.Î´ i
theorem category_theory.limits.has_biproduct.of_has_product {C : Type u} [category_theory.category C] [category_theory.preadditive C] {J : Type v} [fintype J] (f : J â†’ C) [category_theory.limits.has_product f] : category_theory.limits.has_biproduct f
theorem linear_map.continuous_of_is_closed_graph {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] [complete_space F] [complete_space E] (g : E â†’â‚—[ğ•œ] F) (hg : is_closed â†‘(g.graph)) : continuous â‡‘g
theorem bornology.is_vonN_bounded_covers {ğ•œ : Type u_1} {E : Type u_2} [normed_field ğ•œ] [add_comm_group E] [module ğ•œ E] [topological_space E] [has_continuous_smul ğ•œ E] : â‹ƒâ‚€set_of (bornology.is_vonN_bounded ğ•œ) = set.univ
theorem finprod_mem_singleton {Î± : Type u_1} {M : Type u_5} [comm_monoid M] {f : Î± â†’ M} {a : Î±} : finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ {a}), f i)) = f a
theorem units.is_open {R : Type u_1} [normed_ring R] [complete_space R] : is_open {x : R | is_unit x}
theorem monoid_hom.eq_on_mclosure {M : Type u_1} {N : Type u_2} [mul_one_class M] [mul_one_class N] {f g : M â†’* N} {s : set M} (h : set.eq_on â‡‘f â‡‘g s) : set.eq_on â‡‘f â‡‘g â†‘(submonoid.closure s)
theorem exp_add_of_commute {ğ•‚ : Type u_1} {ğ”¸ : Type u_2} [is_R_or_C ğ•‚] [normed_ring ğ”¸] [normed_algebra ğ•‚ ğ”¸] [complete_space ğ”¸] {x y : ğ”¸} (hxy : commute x y) : exp ğ•‚ (x + y) = exp ğ•‚ x * exp ğ•‚ y
theorem monoid_with_zero_hom.congr_fun {M : Type u_3} {N : Type u_4} [mul_zero_one_class M] [mul_zero_one_class N] {f g : M â†’*â‚€ N} (h : f = g) (x : M) : â‡‘f x = â‡‘g x
theorem prime_spectrum.exists_prime_spectrum_prod_le_and_ne_bot_of_domain {A : Type u} [comm_ring A] [is_domain A] [is_noetherian_ring A] (h_fA : Â¬is_field A) {I : ideal A} (h_nzI : I â‰  âŠ¥) : âˆƒ (Z : multiset (prime_spectrum A)), (multiset.map coe Z).prod â‰¤ I âˆ§ (multiset.map coe Z).prod â‰  âŠ¥
theorem card_class_group_eq_one_iff {R : Type u_1} {K : Type u_2} [comm_ring R] [field K] [algebra R K] [is_fraction_ring R K] [is_domain R] [is_dedekind_domain R] [fintype (class_group R K)] : fintype.card (class_group R K) = 1 â†” is_principal_ideal_ring R
theorem right.one_lt_inv_iff {Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± (function.swap has_mul.mul) has_lt.lt] {a : Î±} : 1 < aâ»Â¹ â†” a < 1
theorem dvd_add_self_left {Î± : Type u} [ring Î±] {a b : Î±} : a âˆ£ a + b â†” a âˆ£ b
theorem basis.le_span {Î¹ : Type w} {R : Type u} [ring R] [rank_condition R] {M : Type v} [add_comm_group M] [module R M] {J : set M} (v : basis Î¹ R M) (hJ : submodule.span R J = âŠ¤) : cardinal.mk â†¥(set.range â‡‘v) â‰¤ cardinal.mk â†¥J
theorem subring.closure_induction {R : Type u} [ring R] {s : set R} {p : R â†’ Prop} {x : R} (h : x âˆˆ subring.closure s) (Hs : âˆ€ (x : R), x âˆˆ s â†’ p x) (H0 : p 0) (H1 : p 1) (Hadd : âˆ€ (x y : R), p x â†’ p y â†’ p (x + y)) (Hneg : âˆ€ (x : R), p x â†’ p (-x)) (Hmul : âˆ€ (x y : R), p x â†’ p y â†’ p (x * y)) : p x
theorem erased.out_proof {p : Prop} (a : erased p) : p
theorem finset.induction_on_min_value {Î± : Type u_1} {Î¹ : Type u_4} [linear_order Î±] [decidable_eq Î¹] (f : Î¹ â†’ Î±) {p : finset Î¹ â†’ Prop} (s : finset Î¹) (h0 : p âˆ…) (step : âˆ€ (a : Î¹) (s : finset Î¹), a âˆ‰ s â†’ (âˆ€ (x : Î¹), x âˆˆ s â†’ f a â‰¤ f x) â†’ p s â†’ p (has_insert.insert a s)) : p s
theorem is_add_submonoid_Union_of_directed {M : Type u_1} [add_monoid M] {Î¹ : Type u_2} [hÎ¹ : nonempty Î¹] {s : Î¹ â†’ set M} (hs : âˆ€ (i : Î¹), is_add_submonoid (s i)) (directed : âˆ€ (i j : Î¹), âˆƒ (k : Î¹), s i âŠ† s k âˆ§ s j âŠ† s k) : is_add_submonoid (â‹ƒ (i : Î¹), s i)
theorem set.pairwise_disjoint.bUnion_finset {Î± : Type u_1} {Î¹ : Type u_2} {Î¹' : Type u_3} [lattice Î±] [order_bot Î±] {s : set Î¹'} {g : Î¹' â†’ finset Î¹} {f : Î¹ â†’ Î±} (hs : s.pairwise_disjoint (Î» (i' : Î¹'), (g i').sup f)) (hg : âˆ€ (i : Î¹'), i âˆˆ s â†’ â†‘(g i).pairwise_disjoint f) : (â‹ƒ (i : Î¹') (H : i âˆˆ s), â†‘(g i)).pairwise_disjoint f
theorem division_def {G : Type u_1} [div_inv_monoid G] (a b : G) : a / b = a * bâ»Â¹
theorem ball_pi {Î² : Type v} {Ï€ : Î² â†’ Type u_1} [fintype Î²] [Î  (b : Î²), pseudo_metric_space (Ï€ b)] (x : Î  (b : Î²), Ï€ b) {r : â„} (hr : 0 < r) : metric.ball x r = set.univ.pi (Î» (b : Î²), metric.ball (x b) r)
theorem int.nat_abs_pow_two (x : â„¤) : â†‘(x.nat_abs) ^ 2 = x ^ 2
theorem module.free.rank_tensor_product' (R : Type u) (M : Type v) [comm_ring R] [strong_rank_condition R] [add_comm_group M] [module R M] [module.free R M] (N : Type v) [add_comm_group N] [module R N] [module.free R N] : module.rank R (tensor_product R M N) = module.rank R M * module.rank R N
theorem norm_add_sq_eq_norm_sq_add_norm_sq_real {F : Type u_3} [inner_product_space â„ F] {x y : F} (h : has_inner.inner x y = 0) : âˆ¥x + yâˆ¥ * âˆ¥x + yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + âˆ¥yâˆ¥ * âˆ¥yâˆ¥
theorem same_ray.pos_smul_left {R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {x y : M} {r : R} (h : same_ray R x y) (hr : 0 < r) : same_ray R (r â€¢ x) y
theorem category_theory.limits.coprod_comparison_inv_natural {C : Type u} [category_theory.category C] {D : Type uâ‚‚} [category_theory.category D] (F : C â¥¤ D) {A A' B B' : C} [category_theory.limits.has_binary_coproduct A B] [category_theory.limits.has_binary_coproduct A' B'] [category_theory.limits.has_binary_coproduct (F.obj A) (F.obj B)] [category_theory.limits.has_binary_coproduct (F.obj A') (F.obj B')] (f : A âŸ¶ A') (g : B âŸ¶ B') [category_theory.is_iso (category_theory.limits.coprod_comparison F A B)] [category_theory.is_iso (category_theory.limits.coprod_comparison F A' B')] : category_theory.inv (category_theory.limits.coprod_comparison F A B) â‰« category_theory.limits.coprod.map (F.map f) (F.map g) = F.map (category_theory.limits.coprod.map f g) â‰« category_theory.inv (category_theory.limits.coprod_comparison F A' B')
theorem category_theory.normal_mono_category.pullback_of_mono {C : Type u_1} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_finite_products C] [category_theory.limits.has_kernels C] [category_theory.normal_mono_category C] {X Y Z : C} (a : X âŸ¶ Z) (b : Y âŸ¶ Z) [category_theory.mono a] [category_theory.mono b] : category_theory.limits.has_limit (category_theory.limits.cospan a b)
theorem tendsto_of_le_liminf_of_limsup_le {Î± : Type u} {Î² : Type v} [conditionally_complete_linear_order Î±] [topological_space Î±] [order_topology Î±] {f : filter Î²} {u : Î² â†’ Î±} {a : Î±} (hinf : a â‰¤ f.liminf u) (hsup : f.limsup u â‰¤ a) (h : filter.is_bounded_under has_le.le f u . "is_bounded_default") (h' : filter.is_bounded_under ge f u . "is_bounded_default") : filter.tendsto u f (nhds a)
theorem category_theory.limits.is_initial.hom_ext {C : Type uâ‚} [category_theory.category C] {X Y : C} (t : category_theory.limits.is_initial X) (f g : X âŸ¶ Y) : f = g
theorem nat_smul_eq_nsmul {M : Type u_5} [add_comm_monoid M] (h : module â„• M) (n : â„•) (x : M) : n â€¢ x = n â€¢ x
theorem star_convex.ord_connected {ğ•œ : Type u_1} [linear_ordered_field ğ•œ] {x : ğ•œ} {s : set ğ•œ} (hx : x âˆˆ s) : star_convex ğ•œ x s â†’ s.ord_connected
theorem bornology.is_vonN_bounded.of_topological_space_le {ğ•œ : Type u_1} {E : Type u_2} [semi_normed_ring ğ•œ] [add_comm_group E] [module ğ•œ E] {t t' : topological_space E} (h : t â‰¤ t') {s : set E} (hs : bornology.is_vonN_bounded ğ•œ s) : bornology.is_vonN_bounded ğ•œ s
theorem isometry.dist_eq {Î± : Type u} {Î² : Type v} [pseudo_metric_space Î±] [pseudo_metric_space Î²] {f : Î± â†’ Î²} (hf : isometry f) (x y : Î±) : has_dist.dist (f x) (f y) = has_dist.dist x y
theorem continuous_linear_map.is_open_map {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] (f : E â†’L[ğ•œ] F) [complete_space F] [complete_space E] (surj : function.surjective â‡‘f) : is_open_map â‡‘f
theorem add_monoid_algebra.support_gen_of_gen' {R : Type u_1} {M : Type u_2} [comm_semiring R] [add_monoid M] {S : set (add_monoid_algebra R M)} (hS : algebra.adjoin R S = âŠ¤) : algebra.adjoin R (add_monoid_algebra.of' R M '' â‹ƒ (f : add_monoid_algebra R M) (H : f âˆˆ S), â†‘(f.support)) = âŠ¤
theorem real.sin_pi_div_six  : real.sin (real.pi / 6) = 1 / 2
theorem category_theory.presieve.is_sheaf_for.functor_inclusion_comp_extend {C : Type uâ‚} [category_theory.category C] {X : C} {S : category_theory.sieve X} {P : Cáµ’áµ– â¥¤ Type vâ‚} (h : category_theory.presieve.is_sheaf_for P â‡‘S) (f : S.functor âŸ¶ P) : S.functor_inclusion â‰« h.extend f = f
theorem generalized_continued_fraction.terminates_of_rat (q : â„š) : (generalized_continued_fraction.of q).terminates
theorem matrix.det_eq_of_forall_row_eq_smul_add_pred {R : Type v} [comm_ring R] {n : â„•} {A B : matrix (fin (n + 1)) (fin (n + 1)) R} (c : fin n â†’ R) (A_zero : âˆ€ (j : fin (n + 1)), A 0 j = B 0 j) (A_succ : âˆ€ (i : fin n) (j : fin (n + 1)), A i.succ j = B i.succ j + c i * A (â‡‘fin.cast_succ i) j) : A.det = B.det
theorem ideal.ideal_prod_prime {R : Type u} {S : Type v} [ring R] [ring S] (I : ideal (R Ã— S)) : I.is_prime â†” (âˆƒ (p : ideal R), p.is_prime âˆ§ I = p.prod âŠ¤) âˆ¨ âˆƒ (p : ideal S), p.is_prime âˆ§ I = âŠ¤.prod p
theorem measure_theory.signed_measure.subset_positive_null_set {Î± : Type u_1} [measurable_space Î±] {s : measure_theory.signed_measure Î±} {u v w : set Î±} (hu : measurable_set u) (hv : measurable_set v) (hw : measurable_set w) (hsu : 0.restrict u â‰¤ measure_theory.vector_measure.restrict s u) (hwâ‚ : â‡‘s w = 0) (hwâ‚‚ : w âŠ† u) (hwt : v âŠ† w) : â‡‘s v = 0
theorem measure_theory.integral_divergence_prod_Icc_of_has_fderiv_within_at_off_countable_of_le {E : Type u} [normed_group E] [normed_space â„ E] [complete_space E] (f g : â„ Ã— â„ â†’ E) (f' g' : â„ Ã— â„ â†’ (â„ Ã— â„ â†’L[â„] E)) (a b : â„ Ã— â„) (hle : a â‰¤ b) (s : set (â„ Ã— â„)) (hs : s.countable) (Hcf : continuous_on f (set.Icc a b)) (Hcg : continuous_on g (set.Icc a b)) (Hdf : âˆ€ (x : â„ Ã— â„), x âˆˆ set.Ioo a.fst b.fst Ã—Ë¢ set.Ioo a.snd b.snd  s â†’ has_fderiv_at f (f' x) x) (Hdg : âˆ€ (x : â„ Ã— â„), x âˆˆ set.Ioo a.fst b.fst Ã—Ë¢ set.Ioo a.snd b.snd  s â†’ has_fderiv_at g (g' x) x) (Hi : measure_theory.integrable_on (Î» (x : â„ Ã— â„), â‡‘(f' x) (1, 0) + â‡‘(g' x) (0, 1)) (set.Icc a b) measure_theory.measure_space.volume) : âˆ« (x : â„ Ã— â„) in set.Icc a b, â‡‘(f' x) (1, 0) + â‡‘(g' x) (0, 1) = (((âˆ« (x : â„) in a.fst..b.fst, g (x, b.snd)) - âˆ« (x : â„) in a.fst..b.fst, g (x, a.snd)) + âˆ« (y : â„) in a.snd..b.snd, f (b.fst, y)) - âˆ« (y : â„) in a.snd..b.snd, f (a.fst, y)
theorem cont_diff_at.prod_map' {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {n : with_top â„•} {E' : Type u_6} [normed_group E'] [normed_space ğ•œ E'] {F' : Type u_7} [normed_group F'] [normed_space ğ•œ F'] {f : E â†’ F} {g : E' â†’ F'} {p : E Ã— E'} (hf : cont_diff_at ğ•œ n f p.fst) (hg : cont_diff_at ğ•œ n g p.snd) : cont_diff_at ğ•œ n (prod.map f g) p
theorem emetric.controlled_of_uniform_embedding {Î± : Type u} {Î² : Type v} [pseudo_emetric_space Î±] [pseudo_emetric_space Î²] {f : Î± â†’ Î²} : uniform_embedding f â†’ ((âˆ€ (Îµ : ennreal), Îµ > 0 â†’ (âˆƒ (Î´ : ennreal) (H : Î´ > 0), âˆ€ {a b : Î±}, has_edist.edist a b < Î´ â†’ has_edist.edist (f a) (f b) < Îµ)) âˆ§ âˆ€ (Î´ : ennreal), Î´ > 0 â†’ (âˆƒ (Îµ : ennreal) (H : Îµ > 0), âˆ€ {a b : Î±}, has_edist.edist (f a) (f b) < Îµ â†’ has_edist.edist a b < Î´))
theorem convex.add_smul_mem_interior' {E : Type u_2} {ğ•œ : Type u_3} [linear_ordered_field ğ•œ] [add_comm_group E] [module ğ•œ E] [topological_space E] [topological_add_group E] [has_continuous_const_smul ğ•œ E] {s : set E} (hs : convex ğ•œ s) {x y : E} (hx : x âˆˆ closure s) (hy : x + y âˆˆ interior s) {t : ğ•œ} (ht : t âˆˆ set.Ioc 0 1) : x + t â€¢ y âˆˆ interior s
theorem set.countable_iff_exists_inj_on {Î± : Type u} {s : set Î±} : s.countable â†” âˆƒ (f : Î± â†’ â„•), set.inj_on f s
theorem continuous.measurable {Î± : Type u_1} {Î³ : Type u_3} [topological_space Î±] [measurable_space Î±] [opens_measurable_space Î±] [topological_space Î³] [measurable_space Î³] [borel_space Î³] {f : Î± â†’ Î³} (hf : continuous f) : measurable f
theorem is_primitive_root.pow {M : Type u_1} [comm_monoid M] {Î¶ : M} {n a b : â„•} (hn : 0 < n) (h : is_primitive_root Î¶ n) (hprod : n = a * b) : is_primitive_root (Î¶ ^ a) b
theorem is_primitive_root.nth_roots_one_eq_bUnion_primitive_roots {R : Type u_5} [comm_ring R] [is_domain R] {Î¶ : R} {n : â„•} (h : is_primitive_root Î¶ n) : polynomial.nth_roots_finset n R = n.divisors.bUnion (Î» (i : â„•), primitive_roots i R)
theorem algebraic_topology.dold_kan.hÏƒ'_naturality {C : Type u_1} [category_theory.category C] [category_theory.preadditive C] (q n m : â„•) (hnm : algebraic_topology.dold_kan.c.rel m n) {X Y : category_theory.simplicial_object C} (f : X âŸ¶ Y) : f.app (opposite.op (simplex_category.mk n)) â‰« algebraic_topology.dold_kan.hÏƒ' q n m hnm = algebraic_topology.dold_kan.hÏƒ' q n m hnm â‰« f.app (opposite.op (simplex_category.mk m))
theorem algebra.is_algebraic.cardinal_mk_le_max (R L : Type u) [comm_ring R] [comm_ring L] [is_domain L] [algebra R L] [no_zero_smul_divisors R L] (halg : algebra.is_algebraic R L) : cardinal.mk L â‰¤ linear_order.max (cardinal.mk R) cardinal.aleph_0
theorem function.maps_to_fixed_pts_comp {Î± : Type u} {Î² : Type v} (f : Î± â†’ Î²) (g : Î² â†’ Î±) : set.maps_to f (function.fixed_points (g âˆ˜ f)) (function.fixed_points (f âˆ˜ g))
theorem category_theory.limits.has_binary_biproducts_of_finite_biproducts (C : Type u) [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_finite_biproducts C] : category_theory.limits.has_binary_biproducts C
theorem uniform_space.completion.uniformity_dist' {Î± : Type u} [pseudo_metric_space Î±] : uniformity (uniform_space.completion Î±) = â¨… (Îµ : {Îµ // 0 < Îµ}), filter.principal {p : uniform_space.completion Î± Ã— uniform_space.completion Î± | has_dist.dist p.fst p.snd < Îµ.val}
theorem strict_mono_on.continuous_at_of_image_mem_nhds {Î± : Type u_1} {Î² : Type u_2} [linear_order Î±] [topological_space Î±] [order_topology Î±] [linear_order Î²] [topological_space Î²] [order_topology Î²] [densely_ordered Î²] {f : Î± â†’ Î²} {s : set Î±} {a : Î±} (h_mono : strict_mono_on f s) (hs : s âˆˆ nhds a) (hfs : f '' s âˆˆ nhds (f a)) : continuous_at f a
theorem euclidean_geometry.reflection_mem_of_le_of_mem {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {sâ‚ sâ‚‚ : affine_subspace â„ P} [nonempty â†¥sâ‚] [complete_space â†¥(sâ‚.direction)] (hle : sâ‚ â‰¤ sâ‚‚) {p : P} (hp : p âˆˆ sâ‚‚) : â‡‘(euclidean_geometry.reflection sâ‚) p âˆˆ sâ‚‚
theorem vitali_family.ae_tendsto_div {Î± : Type u_1} [metric_space Î±] {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (v : vitali_family Î¼) [sigma_compact_space Î±] [borel_space Î±] [measure_theory.is_locally_finite_measure Î¼] {Ï : measure_theory.measure Î±} [measure_theory.is_locally_finite_measure Ï] (hÏ : Ï.absolutely_continuous Î¼) : âˆ€áµ (x : Î±) âˆ‚Î¼, âˆƒ (c : ennreal), filter.tendsto (Î» (a : set Î±), â‡‘Ï a / â‡‘Î¼ a) (v.filter_at x) (nhds c)
theorem add_lt_of_lt_neg_add {Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b c : Î±} : b < -a + c â†’ a + b < c
theorem cont_diff.continuous_fderiv_apply {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {f : E â†’ F} {n : with_top â„•} (h : cont_diff ğ•œ n f) (hn : 1 â‰¤ n) : continuous (Î» (p : E Ã— E), â‡‘(fderiv ğ•œ f p.fst) p.snd)
theorem continuous_uncurry_of_discrete_topology {Î± : Type u} {Î² : Type v} {Î³ : Type u_1} [topological_space Î±] [topological_space Î²] [topological_space Î³] [discrete_topology Î±] {f : Î± â†’ Î² â†’ Î³} (hf : âˆ€ (a : Î±), continuous (f a)) : continuous (function.uncurry f)
theorem fixed_points_submonoid_supr (M : Type u_1) (Î± : Type u_2) [monoid M] [mul_action M Î±] {Î¹ : Sort u_3} {P : Î¹ â†’ submonoid M} : mul_action.fixed_points â†¥(supr P) Î± = â‹‚ (i : Î¹), mul_action.fixed_points â†¥(P i) Î±
theorem generalized_continued_fraction.squash_seq_nth_of_lt {K : Type u_1} {n : â„•} {s : seq (generalized_continued_fraction.pair K)} [division_ring K] {m : â„•} (m_lt_n : m < n) : (generalized_continued_fraction.squash_seq s n).nth m = s.nth m
theorem continuous_at_right_of_monotone_on_of_image_mem_nhds_within {Î± : Type u_1} {Î² : Type u_2} [linear_order Î±] [topological_space Î±] [order_topology Î±] [linear_order Î²] [topological_space Î²] [order_topology Î²] [densely_ordered Î²] {f : Î± â†’ Î²} {s : set Î±} {a : Î±} (h_mono : monotone_on f s) (hs : s âˆˆ nhds_within a (set.Ici a)) (hfs : f '' s âˆˆ nhds_within (f a) (set.Ici (f a))) : continuous_within_at f (set.Ici a) a
theorem has_fpower_series_at.eq_formal_multilinear_series {ğ•œ : Type u_1} {E : Type u_2} [nondiscrete_normed_field ğ•œ] [normed_group E] [normed_space ğ•œ E] {pâ‚ pâ‚‚ : formal_multilinear_series ğ•œ ğ•œ E} {f : ğ•œ â†’ E} {x : ğ•œ} (hâ‚ : has_fpower_series_at f pâ‚ x) (hâ‚‚ : has_fpower_series_at f pâ‚‚ x) : pâ‚ = pâ‚‚
theorem antivary.sum_smul_lt_sum_comp_perm_smul_iff {Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [linear_ordered_ring Î±] [linear_ordered_add_comm_group Î²] [module Î± Î²] [ordered_smul Î± Î²] {Ïƒ : equiv.perm Î¹} {f : Î¹ â†’ Î±} {g : Î¹ â†’ Î²} [fintype Î¹] (hfg : antivary f g) : finset.univ.sum (Î» (i : Î¹), f i â€¢ g i) < finset.univ.sum (Î» (i : Î¹), f (â‡‘Ïƒ i) â€¢ g i) â†” Â¬antivary (f âˆ˜ â‡‘Ïƒ) g
theorem ADE_inequality.classification (p q r : â„•+) : 1 < ADE_inequality.sum_inv {p, q, r} â†” ADE_inequality.admissible {p, q, r}
theorem measure_theory.measure.prod_prod {Î± : Type u_1} {Î² : Type u_3} [measurable_space Î±] [measurable_space Î²] {Î¼ : measure_theory.measure Î±} {Î½ : measure_theory.measure Î²} [measure_theory.sigma_finite Î½] (s : set Î±) (t : set Î²) : â‡‘(Î¼.prod Î½) (s Ã—Ë¢ t) = â‡‘Î¼ s * â‡‘Î½ t
theorem monotone.tendsto_at_bot_at_bot {Î± : Type u_3} {Î² : Type u_4} [preorder Î±] [preorder Î²] {f : Î± â†’ Î²} (hf : monotone f) (h : âˆ€ (b : Î²), âˆƒ (a : Î±), f a â‰¤ b) : filter.tendsto f filter.at_bot filter.at_bot
theorem cont_diff_at.snd' {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {G : Type u_4} [normed_group G] [normed_space ğ•œ G] {n : with_top â„•} {f : F â†’ G} {x : E} {y : F} (hf : cont_diff_at ğ•œ n f y) : cont_diff_at ğ•œ n (Î» (x : E Ã— F), f x.snd) (x, y)
theorem orthonormal.oangle_rotation_right {V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) {x y : V} (hx : x â‰  0) (hy : y â‰  0) (Î¸ : real.angle) : hb.oangle x (â‡‘(hb.rotation Î¸) y) = hb.oangle x y + Î¸
theorem category_theory.limits.epi_of_is_colimit_parallel_family {J : Type v} {C : Type u} [category_theory.category C] {X Y : C} {f : J â†’ (X âŸ¶ Y)} [nonempty J] {c : category_theory.limits.cocone (category_theory.limits.parallel_family f)} (i : category_theory.limits.is_colimit c) : category_theory.epi (c.Î¹.app category_theory.limits.walking_parallel_family.one)
theorem affine.simplex.finrank_direction_altitude {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {n : â„•} (s : affine.simplex â„ P (n + 1)) (i : fin (n + 2)) : finite_dimensional.finrank â„ â†¥((s.altitude i).direction) = 1
theorem pgame.mul_comm_equiv (x y : pgame) : (x * y).equiv (y * x)
theorem continuous_on.surj_on_of_tendsto {Î± : Type u} [conditionally_complete_linear_order Î±] [topological_space Î±] [order_topology Î±] [densely_ordered Î±] {Î´ : Type u_1} [linear_order Î´] [topological_space Î´] [order_closed_topology Î´] {f : Î± â†’ Î´} {s : set Î±} [s.ord_connected] (hs : s.nonempty) (hf : continuous_on f s) (hbot : filter.tendsto (Î» (x : â†¥s), f â†‘x) filter.at_bot filter.at_bot) (htop : filter.tendsto (Î» (x : â†¥s), f â†‘x) filter.at_top filter.at_top) : set.surj_on f s set.univ
theorem cont_mdiff_coe_sphere {E : Type u_1} [inner_product_space â„ E] {n : â„•} [fact (finite_dimensional.finrank â„ E = n + 1)] : cont_mdiff (model_with_corners_self â„ (euclidean_space â„ (fin n))) (model_with_corners_self â„ E) âŠ¤ coe
theorem real.has_strict_fderiv_at_rpow_of_pos (p : â„ Ã— â„) (hp : 0 < p.fst) : has_strict_fderiv_at (Î» (x : â„ Ã— â„), x.fst ^ x.snd) ((p.snd * p.fst ^ (p.snd - 1)) â€¢ continuous_linear_map.fst â„ â„ â„ + (p.fst ^ p.snd * real.log p.fst) â€¢ continuous_linear_map.snd â„ â„ â„) p
theorem filter.tendsto_mul_left_cobounded {Î± : Type u_1} [normed_division_ring Î±] {a : Î±} (ha : a â‰  0) : filter.tendsto (has_mul.mul a) (filter.comap has_norm.norm filter.at_top) (filter.comap has_norm.norm filter.at_top)
theorem measure_theory.measure.pi_eq {Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_3} [fintype Î¹] [Î  (i : Î¹), measurable_space (Î± i)] {Î¼ : Î  (i : Î¹), measure_theory.measure (Î± i)} [âˆ€ (i : Î¹), measure_theory.sigma_finite (Î¼ i)] {Î¼' : measure_theory.measure (Î  (i : Î¹), Î± i)} (h : âˆ€ (s : Î  (i : Î¹), set (Î± i)), (âˆ€ (i : Î¹), measurable_set (s i)) â†’ â‡‘Î¼' (set.univ.pi s) = finset.univ.prod (Î» (i : Î¹), â‡‘(Î¼ i) (s i))) : measure_theory.measure.pi Î¼ = Î¼'
theorem mv_polynomial.exists_finset_renameâ‚‚ {Ïƒ : Type u_1} {R : Type u_4} [comm_semiring R] (pâ‚ pâ‚‚ : mv_polynomial Ïƒ R) : âˆƒ (s : finset Ïƒ) (qâ‚ qâ‚‚ : mv_polynomial â†¥s R), pâ‚ = â‡‘(mv_polynomial.rename coe) qâ‚ âˆ§ pâ‚‚ = â‡‘(mv_polynomial.rename coe) qâ‚‚
theorem ordered_comm_group.mul_lt_mul_left' {Î± : Type u_1} [has_mul Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {b c : Î±} (bc : b < c) (a : Î±) : a * b < a * c
theorem orthonormal.oangle_sub_right {V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) {x y z : V} (hx : x â‰  0) (hy : y â‰  0) (hz : z â‰  0) : hb.oangle x z - hb.oangle y z = hb.oangle x y
theorem is_integral_closure.is_fraction_ring_of_algebraic (A : Type u_4) [comm_ring A] [is_domain A] {L : Type u_6} [field L] [algebra A L] (C : Type u_7) [comm_ring C] [is_domain C] [algebra C L] [is_integral_closure C A L] [algebra A C] [is_scalar_tower A C L] (alg : algebra.is_algebraic A L) (inj : âˆ€ (x : A), â‡‘(algebra_map A L) x = 0 â†’ x = 0) : is_fraction_ring C L
theorem le_refl {Î± : Type u} [preorder Î±] (a : Î±) : a â‰¤ a
theorem real_inner_le_norm {F : Type u_3} [inner_product_space â„ F] (x y : F) : has_inner.inner x y â‰¤ âˆ¥xâˆ¥ * âˆ¥yâˆ¥
theorem isometric.map_midpoint {E : Type u_1} {PE : Type u_2} [normed_group E] [normed_space â„ E] [metric_space PE] [normed_add_torsor E PE] {F : Type u_3} {PF : Type u_4} [normed_group F] [normed_space â„ F] [metric_space PF] [normed_add_torsor F PF] (f : PE â‰ƒáµ¢ PF) (x y : PE) : â‡‘f (midpoint â„ x y) = midpoint â„ (â‡‘f x) (â‡‘f y)
theorem measure_theory.smul_invariant_measure_tfae (G : Type u_1) {Î± : Type u_3} {m : measurable_space Î±} [group G] [mul_action G Î±] [measurable_space G] [has_measurable_smul G Î±] (Î¼ : measure_theory.measure Î±) : [measure_theory.smul_invariant_measure G Î± Î¼, âˆ€ (c : G) (s : set Î±), measurable_set s â†’ â‡‘Î¼ (has_scalar.smul c â»Â¹' s) = â‡‘Î¼ s, âˆ€ (c : G) (s : set Î±), measurable_set s â†’ â‡‘Î¼ (c â€¢ s) = â‡‘Î¼ s, âˆ€ (c : G) (s : set Î±), â‡‘Î¼ (has_scalar.smul c â»Â¹' s) = â‡‘Î¼ s, âˆ€ (c : G) (s : set Î±), â‡‘Î¼ (c â€¢ s) = â‡‘Î¼ s, âˆ€ (c : G), measure_theory.measure.map (has_scalar.smul c) Î¼ = Î¼, âˆ€ (c : G), measure_theory.measure_preserving (has_scalar.smul c) Î¼ Î¼].tfae
theorem inv_nat_cast_smul_eq {E : Type u_1} (R : Type u_2) (S : Type u_3) [add_comm_group E] [division_ring R] [division_ring S] [module R E] [module S E] (n : â„•) (x : E) : (â†‘n)â»Â¹ â€¢ x = (â†‘n)â»Â¹ â€¢ x
theorem mul_lt_one {Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a b : Î±} (ha : a < 1) (hb : b < 1) : a * b < 1
theorem measure_theory.measure.ext_of_Ioc_finite {Î± : Type u_1} [topological_space Î±] {m : measurable_space Î±} [topological_space.second_countable_topology Î±] [linear_order Î±] [order_topology Î±] [borel_space Î±] (Î¼ Î½ : measure_theory.measure Î±) [measure_theory.is_finite_measure Î¼] (hÎ¼Î½ : â‡‘Î¼ set.univ = â‡‘Î½ set.univ) (h : âˆ€ â¦ƒa b : Î±â¦„, a < b â†’ â‡‘Î¼ (set.Ioc a b) = â‡‘Î½ (set.Ioc a b)) : Î¼ = Î½
theorem group_algebra.mul_average_left (k : Type u_1) (G : Type u_2) [comm_semiring k] [group G] [fintype G] [invertible â†‘(fintype.card G)] (g : G) : finsupp.single g 1 * group_algebra.average k G = group_algebra.average k G
theorem category_theory.simple_iff_subobject_is_simple_order {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] (X : C) : category_theory.simple X â†” is_simple_order (category_theory.subobject X)
theorem antivary.sum_smul_le_sum_smul_comp_perm {Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [linear_ordered_ring Î±] [linear_ordered_add_comm_group Î²] [module Î± Î²] [ordered_smul Î± Î²] {Ïƒ : equiv.perm Î¹} {f : Î¹ â†’ Î±} {g : Î¹ â†’ Î²} [fintype Î¹] (hfg : antivary f g) : finset.univ.sum (Î» (i : Î¹), f i â€¢ g i) â‰¤ finset.univ.sum (Î» (i : Î¹), f i â€¢ g (â‡‘Ïƒ i))
theorem measure_theory.le_lintegral_add {Î± : Type u_1} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (f g : Î± â†’ ennreal) : âˆ«â» (a : Î±), f a âˆ‚Î¼ + âˆ«â» (a : Î±), g a âˆ‚Î¼ â‰¤ âˆ«â» (a : Î±), f a + g a âˆ‚Î¼
theorem nnnorm_pow_le' {Î± : Type u_1} [semi_normed_ring Î±] (a : Î±) {n : â„•} : 0 < n â†’ âˆ¥a ^ nâˆ¥â‚Š â‰¤ âˆ¥aâˆ¥â‚Š ^ n
theorem category_theory.limits.biprod.add_eq_lift_id_desc {C : Type u} [category_theory.category C] [category_theory.preadditive C] {X Y : C} (f g : X âŸ¶ Y) [category_theory.limits.has_binary_biproduct X X] : f + g = category_theory.limits.biprod.lift (ğŸ™ X) (ğŸ™ X) â‰« category_theory.limits.biprod.desc f g
theorem setoid.injective_iff_ker_bot {Î± : Type u_1} {Î² : Type u_2} (f : Î± â†’ Î²) : function.injective f â†” setoid.ker f = âŠ¥
theorem finprod_mem_div_distrib {Î± : Type u_1} {G : Type u_4} {s : set Î±} [division_comm_monoid G] (f g : Î± â†’ G) (hs : s.finite) : finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), f i / g i)) = finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), f i)) / finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), g i))
theorem edist_lt_top {Î± : Type u_1} [pseudo_metric_space Î±] (x y : Î±) : has_edist.edist x y < âŠ¤
theorem polynomial.C_mem_lifts {R : Type u} [semiring R] {S : Type v} [semiring S] (f : R â†’+* S) (r : R) : â‡‘polynomial.C (â‡‘f r) âˆˆ polynomial.lifts f
theorem set.monotone_image {Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} : monotone (set.image f)
theorem is_alg_closed.splits_codomain {k : Type u_1} {K : Type u_2} [field k] [is_alg_closed k] [field K] {f : K â†’+* k} (p : polynomial K) : polynomial.splits f p
theorem finset.sup_indep.independent_of_univ {Î± : Type u_1} {Î¹ : Type u_3} [complete_lattice Î±] [fintype Î¹] {f : Î¹ â†’ Î±} : finset.univ.sup_indep f â†’ complete_lattice.independent f
theorem monovary_on.sum_smul_comp_perm_lt_sum_smul_iff {Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [linear_ordered_ring Î±] [linear_ordered_add_comm_group Î²] [module Î± Î²] [ordered_smul Î± Î²] {s : finset Î¹} {Ïƒ : equiv.perm Î¹} {f : Î¹ â†’ Î±} {g : Î¹ â†’ Î²} (hfg : monovary_on f g â†‘s) (hÏƒ : {x : Î¹ | â‡‘Ïƒ x â‰  x} âŠ† â†‘s) : s.sum (Î» (i : Î¹), f i â€¢ g (â‡‘Ïƒ i)) < s.sum (Î» (i : Î¹), f i â€¢ g i) â†” Â¬monovary_on f (g âˆ˜ â‡‘Ïƒ) â†‘s
theorem measure_theory.measure.div_mem_nhds_one_of_haar_pos {G : Type u_1} [group G] [topological_space G] [t2_space G] [topological_group G] [measurable_space G] [borel_space G] [topological_space.second_countable_topology G] (Î¼ : measure_theory.measure G) [Î¼.is_haar_measure] [locally_compact_space G] (E : set G) (hE : measurable_set E) (hEpos : 0 < â‡‘Î¼ E) : E / E âˆˆ nhds 1
theorem list.is_prefix.reverse {Î± : Type u_1} {lâ‚ lâ‚‚ : list Î±} : lâ‚ <+: lâ‚‚ â†’ lâ‚.reverse <:+ lâ‚‚.reverse
theorem real.tendsto_exp_neg_at_top_nhds_0  : filter.tendsto (Î» (x : â„), real.exp (-x)) filter.at_top (nhds 0)
theorem orthonormal.inner_left_finsupp {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {Î¹ : Type u_4} {v : Î¹ â†’ E} (hv : orthonormal ğ•œ v) (l : Î¹ â†’â‚€ ğ•œ) (i : Î¹) : has_inner.inner (â‡‘(finsupp.total Î¹ E ğ•œ v) l) (v i) = â‡‘(star_ring_end ğ•œ) (â‡‘l i)
theorem has_fpower_series_on_ball.uniform_geometric_approx' {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field ğ•œ] [normed_group E] [normed_space ğ•œ E] [normed_group F] [normed_space ğ•œ F] {f : E â†’ F} {p : formal_multilinear_series ğ•œ E F} {x : E} {r : ennreal} {r' : nnreal} (hf : has_fpower_series_on_ball f p x r) (h : â†‘r' < r) : âˆƒ (a : â„) (H : a âˆˆ set.Ioo 0 1) (C : â„) (H : C > 0), âˆ€ (y : E), y âˆˆ metric.ball 0 â†‘r' â†’ âˆ€ (n : â„•), âˆ¥f (x + y) - p.partial_sum n yâˆ¥ â‰¤ C * (a * (âˆ¥yâˆ¥ / â†‘r')) ^ n
theorem units.is_open_map_coe {R : Type u_1} [normed_ring R] [complete_space R] : is_open_map coe
theorem has_strict_deriv_at_exp {ğ•‚ : Type u_1} [is_R_or_C ğ•‚] {x : ğ•‚} : has_strict_deriv_at (exp ğ•‚) (exp ğ•‚ x) x
theorem nat.factors_unique {n : â„•} {l : list â„•} (hâ‚ : l.prod = n) (hâ‚‚ : âˆ€ (p : â„•), p âˆˆ l â†’ nat.prime p) : l ~ n.factors
theorem eq.ge {Î± : Type u} [preorder Î±] {x y : Î±} (h : x = y) : y â‰¤ x
theorem not_countable_complex  : Â¬set.univ.countable
theorem cont_diff.differentiable {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {f : E â†’ F} {n : with_top â„•} (h : cont_diff ğ•œ n f) (hn : 1 â‰¤ n) : differentiable ğ•œ f
theorem semiconj_by.mul_left {S : Type u} [semigroup S] {a b x y z : S} (ha : semiconj_by a y z) (hb : semiconj_by b x y) : semiconj_by (a * b) x z
theorem measure_theory.measure_set_of_frequently_eq_zero {Î± : Type u_1} {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {p : â„• â†’ Î± â†’ Prop} (hp : âˆ‘' (i : â„•), â‡‘Î¼ {x : Î± | p i x} â‰  âŠ¤) : â‡‘Î¼ {x : Î± | âˆƒá¶  (n : â„•) in filter.at_top, p n x} = 0
theorem bornology.is_vonN_bounded.union {ğ•œ : Type u_1} {E : Type u_2} [semi_normed_ring ğ•œ] [has_scalar ğ•œ E] [has_zero E] [topological_space E] {sâ‚ sâ‚‚ : set E} (hsâ‚ : bornology.is_vonN_bounded ğ•œ sâ‚) (hsâ‚‚ : bornology.is_vonN_bounded ğ•œ sâ‚‚) : bornology.is_vonN_bounded ğ•œ (sâ‚ âˆª sâ‚‚)
theorem complex.eq_on_closure_of_eq_on_frontier {E : Type u} [normed_group E] [normed_space â„‚ E] {F : Type v} [normed_group F] [normed_space â„‚ F] [nontrivial E] {f g : E â†’ F} {U : set E} (hU : metric.bounded U) (hf : diff_cont_on_cl â„‚ f U) (hg : diff_cont_on_cl â„‚ g U) (hfg : set.eq_on f g (frontier U)) : set.eq_on f g (closure U)
theorem polynomial.X_pow_mul_C {R : Type u} [semiring R] (r : R) (n : â„•) : polynomial.X ^ n * â‡‘polynomial.C r = â‡‘polynomial.C r * polynomial.X ^ n
theorem balanced.absorbs_self {ğ•œ : Type u_1} {E : Type u_3} [normed_field ğ•œ] [add_comm_group E] [module ğ•œ E] {A : set E} (hA : balanced ğ•œ A) : absorbs ğ•œ A A
theorem bilin_form.restrict_orthogonal_span_singleton_nondegenerate {V : Type u_9} {K : Type u_10} [field K] [add_comm_group V] [module K V] (B : bilin_form K V) (bâ‚ : B.nondegenerate) (bâ‚‚ : B.is_refl) {x : V} (hx : Â¬B.is_ortho x x) : (B.restrict (B.orthogonal (submodule.span K {x}))).nondegenerate
theorem function.bijective.exists_unique {Î± : Sort u_1} {Î² : Sort u_2} {f : Î± â†’ Î²} (hf : function.bijective f) (b : Î²) : âˆƒ! (a : Î±), f a = b
theorem eq.le {Î± : Type u} [preorder Î±] {a b : Î±} : a = b â†’ a â‰¤ b
theorem euclidean_geometry.angle_eq_angle_of_dist_eq {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {p1 p2 p3 : P} (h : has_dist.dist p1 p2 = has_dist.dist p1 p3) : euclidean_geometry.angle p1 p2 p3 = euclidean_geometry.angle p1 p3 p2
theorem pythagorean_triple.mul {x y z : â„¤} (h : pythagorean_triple x y z) (k : â„¤) : pythagorean_triple (k * x) (k * y) (k * z)
theorem le_csupr {Î± : Type u_1} {Î¹ : Sort u_3} [conditionally_complete_lattice Î±] {f : Î¹ â†’ Î±} (H : bdd_above (set.range f)) (c : Î¹) : f c â‰¤ supr f
theorem category_theory.locally_discrete.eq_of_hom {C : Type u} [category_theory.category_struct C] {X Y : category_theory.locally_discrete C} {f g : X âŸ¶ Y} (Î· : f âŸ¶ g) : f = g
theorem has_fderiv_at_boundary_of_tendsto_fderiv {E : Type u_1} [normed_group E] [normed_space â„ E] {F : Type u_2} [normed_group F] [normed_space â„ F] {f : E â†’ F} {s : set E} {x : E} {f' : E â†’L[â„] F} (f_diff : differentiable_on â„ f s) (s_conv : convex â„ s) (s_open : is_open s) (f_cont : âˆ€ (y : E), y âˆˆ closure s â†’ continuous_within_at f s y) (h : filter.tendsto (Î» (y : E), fderiv â„ f y) (nhds_within x s) (nhds f')) : has_fderiv_within_at f f' (closure s) x
theorem affine_independent.exists_unique_dist_eq {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {Î¹ : Type u_3} [hne : nonempty Î¹] [fintype Î¹] {p : Î¹ â†’ P} (ha : affine_independent â„ p) : âˆƒ! (cccr : P Ã— â„), cccr.fst âˆˆ affine_span â„ (set.range p) âˆ§ âˆ€ (i : Î¹), has_dist.dist (p i) cccr.fst = cccr.snd
theorem is_max.succ_eq {Î± : Type u_1} [partial_order Î±] [succ_order Î±] {a : Î±} : is_max a â†’ order.succ a = a
theorem affine_independent_iff_linear_independent_vsub (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {Î¹ : Type u_4} (p : Î¹ â†’ P) (i1 : Î¹) : affine_independent k p â†” linear_independent k (Î» (i : {x // x â‰  i1}), p â†‘i -áµ¥ p i1)
theorem has_sum_of_subseq_of_summable {Î¹ : Type u_1} {Î± : Type u_2} {E : Type u_3} [semi_normed_group E] {f : Î¹ â†’ E} (hf : summable (Î» (a : Î¹), âˆ¥f aâˆ¥)) {s : Î± â†’ finset Î¹} {p : filter Î±} [p.ne_bot] (hs : filter.tendsto s p filter.at_top) {a : E} (ha : filter.tendsto (Î» (b : Î±), (s b).sum (Î» (i : Î¹), f i)) p (nhds a)) : has_sum f a
theorem finsupp.congr_fun {Î± : Type u_1} {M : Type u_5} [has_zero M] {f g : Î± â†’â‚€ M} (h : f = g) (a : Î±) : â‡‘f a = â‡‘g a
theorem tendsto_uniformly.tendsto_comp {Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_4} [uniform_space Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {x : Î±} {p : filter Î¹} {g : Î¹ â†’ Î±} [topological_space Î±] (h : tendsto_uniformly F f p) (hf : continuous_at f x) (hg : filter.tendsto g p (nhds x)) : filter.tendsto (Î» (n : Î¹), F n (g n)) p (nhds (f x))
theorem category_theory.nat_trans_from_is_connected {J : Type uâ‚} [category_theory.category J] {C : Type uâ‚‚} [category_theory.category C] [category_theory.is_preconnected J] {X Y : C} (Î± : (category_theory.functor.const J).obj X âŸ¶ (category_theory.functor.const J).obj Y) (j j' : J) : Î±.app j = Î±.app j'
theorem ordinal.infinite_pigeonhole_card {Î² Î± : Type u} (f : Î² â†’ Î±) (Î¸ : cardinal) (hÎ¸ : Î¸ â‰¤ cardinal.mk Î²) (hâ‚ : cardinal.aleph_0 â‰¤ Î¸) (hâ‚‚ : cardinal.mk Î± < Î¸.ord.cof) : âˆƒ (a : Î±), Î¸ â‰¤ cardinal.mk â†¥(f â»Â¹' {a})
theorem polynomial.gal.restrict_prod_injective {F : Type u_1} [field F] (p q : polynomial F) : function.injective â‡‘(polynomial.gal.restrict_prod p q)
theorem orthogonal_family.is_internal_iff {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {Î¹ : Type u_4} [decidable_eq Î¹] [finite_dimensional ğ•œ E] {V : Î¹ â†’ submodule ğ•œ E} (hV : orthogonal_family ğ•œ (Î» (i : Î¹), (V i).subtypeâ‚—áµ¢)) : direct_sum.is_internal V â†” (supr V)á—® = âŠ¥
theorem basis.exists_op_nnnorm_le {ğ•œ : Type u} [nondiscrete_normed_field ğ•œ] {E : Type v} [normed_group E] [normed_space ğ•œ E] {F : Type w} [normed_group F] [normed_space ğ•œ F] [complete_space ğ•œ] {Î¹ : Type u_1} [fintype Î¹] (v : basis Î¹ ğ•œ E) : âˆƒ (C : nnreal) (H : C > 0), âˆ€ {u : E â†’L[ğ•œ] F} (M : nnreal), (âˆ€ (i : Î¹), âˆ¥â‡‘u (â‡‘v i)âˆ¥â‚Š â‰¤ M) â†’ âˆ¥uâˆ¥â‚Š â‰¤ C * M
theorem composition_series.exists_top_eq_snoc_equivalant {X : Type u} [lattice X] [jordan_holder_lattice X] (s : composition_series X) (x : X) (hm : jordan_holder_lattice.is_maximal x s.top) (hb : s.bot â‰¤ x) : âˆƒ (t : composition_series X), t.bot = s.bot âˆ§ t.length + 1 = s.length âˆ§ âˆƒ (htx : t.top = x), s.equivalent (t.snoc s.top _)
theorem finite_dimensional.finrank_mul_finrank (F : Type u) (K : Type v) (A : Type w) [field F] [field K] [add_comm_group A] [algebra F K] [module K A] [module F A] [is_scalar_tower F K A] [finite_dimensional F K] : finite_dimensional.finrank F K * finite_dimensional.finrank K A = finite_dimensional.finrank F A
theorem has_fderiv_at_exp_zero_of_radius_pos {ğ•‚ : Type u_1} {ğ”¸ : Type u_2} [nondiscrete_normed_field ğ•‚] [normed_ring ğ”¸] [normed_algebra ğ•‚ ğ”¸] [complete_space ğ”¸] (h : 0 < (exp_series ğ•‚ ğ”¸).radius) : has_fderiv_at (exp ğ•‚) 1 0
theorem generalized_continued_fraction.le_of_succ_nth_denom {K : Type u_1} {v : K} {n : â„•} [linear_ordered_field K] [floor_ring K] {b : K} (nth_part_denom_eq : (generalized_continued_fraction.of v).partial_denominators.nth n = option.some b) : b * (generalized_continued_fraction.of v).denominators n â‰¤ (generalized_continued_fraction.of v).denominators (n + 1)
theorem sylow.prime_dvd_card_quotient_normalizer {G : Type u} [group G] [fintype G] {p n : â„•} [hp : fact (nat.prime p)] (hdvd : p ^ (n + 1) âˆ£ fintype.card G) {H : subgroup G} (hH : fintype.card â†¥H = p ^ n) : p âˆ£ fintype.card (â†¥(H.normalizer) â§¸ subgroup.comap H.normalizer.subtype H)
theorem projectivization.map_injective {K : Type u_1} {V : Type u_2} [field K] [add_comm_group V] [module K V] {L : Type u_3} {W : Type u_4} [field L] [add_comm_group W] [module L W] {Ïƒ : K â†’+* L} {Ï„ : L â†’+* K} [ring_hom_inv_pair Ïƒ Ï„] (f : V â†’â‚›â‚—[Ïƒ] W) (hf : function.injective â‡‘f) : function.injective (projectivization.map f hf)
theorem finite_field.is_square_iff {F : Type u_3} [field F] [fintype F] (hF : ring_char F â‰  2) {a : F} (ha : a â‰  0) : is_square a â†” a ^ (fintype.card F / 2) = 1
theorem polynomial.exists_approx_polynomial {Fq : Type u_1} [fintype Fq] [field Fq] {b : polynomial Fq} (hb : b â‰  0) {Îµ : â„} (hÎµ : 0 < Îµ) (A : fin (fintype.card Fq ^ âŒˆ-real.log Îµ / real.log â†‘(fintype.card Fq)âŒ‰â‚Š).succ â†’ polynomial Fq) : âˆƒ (iâ‚€ iâ‚ : fin (fintype.card Fq ^ âŒˆ-real.log Îµ / real.log â†‘(fintype.card Fq)âŒ‰â‚Š).succ), iâ‚€ â‰  iâ‚ âˆ§ â†‘(â‡‘polynomial.card_pow_degree (A iâ‚ % b - A iâ‚€ % b)) < â‡‘polynomial.card_pow_degree b â€¢ Îµ
theorem measure_theory.measure.ext_of_generate_from_of_Union {Î± : Type u_1} {m0 : measurable_space Î±} {Î¼ Î½ : measure_theory.measure Î±} (C : set (set Î±)) (B : â„• â†’ set Î±) (hA : m0 = measurable_space.generate_from C) (hC : is_pi_system C) (h1B : (â‹ƒ (i : â„•), B i) = set.univ) (h2B : âˆ€ (i : â„•), B i âˆˆ C) (hÎ¼B : âˆ€ (i : â„•), â‡‘Î¼ (B i) â‰  âŠ¤) (h_eq : âˆ€ (s : set Î±), s âˆˆ C â†’ â‡‘Î¼ s = â‡‘Î½ s) : Î¼ = Î½
theorem finset.centroid_weights_eq_const (k : Type u_1) [division_ring k] {Î¹ : Type u_4} (s : finset Î¹) : finset.centroid_weights k s = function.const Î¹ (â†‘(s.card))â»Â¹
theorem simplex_category.len_le_of_mono {x y : simplex_category} {f : x âŸ¶ y} : category_theory.mono f â†’ x.len â‰¤ y.len
theorem ideal.comp_quotient_map_eq_of_comp_eq {R : Type u_1} {S : Type u_2} [comm_ring R] [comm_ring S] {R' : Type u_3} {S' : Type u_4} [comm_ring R'] [comm_ring S'] {f : R â†’+* S} {f' : R' â†’+* S'} {g : R â†’+* R'} {g' : S â†’+* S'} (hfg : f'.comp g = g'.comp f) (I : ideal S') : (I.quotient_map g' le_rfl).comp ((ideal.comap g' I).quotient_map f le_rfl) = (I.quotient_map f' le_rfl).comp ((ideal.comap f' I).quotient_map g _)
theorem nat.pred_one_add (n : â„•) : (1 + n).pred = n
theorem pi.is_pwo {Ïƒ : Type u_1} {Î± : Ïƒ â†’ Type u_2} [Î  (s : Ïƒ), linear_order (Î± s)] [âˆ€ (s : Ïƒ), is_well_order (Î± s) has_lt.lt] [fintype Ïƒ] (S : set (Î  (s : Ïƒ), Î± s)) : S.is_pwo
theorem is_preconnected.Union_of_chain {Î± : Type u} {Î² : Type v} [topological_space Î±] [linear_order Î²] [succ_order Î²] [is_succ_archimedean Î²] {s : Î² â†’ set Î±} (H : âˆ€ (n : Î²), is_preconnected (s n)) (K : âˆ€ (n : Î²), (s n âˆ© s (order.succ n)).nonempty) : is_preconnected (â‹ƒ (n : Î²), s n)
theorem witt_polynomial_zmod_self (p n : â„•) : witt_polynomial p (zmod (p ^ (n + 1))) (n + 1) = â‡‘(mv_polynomial.expand p) (witt_polynomial p (zmod (p ^ (n + 1))) n)
theorem cauchy_seq_iff_le_tendsto_0 {Î± : Type u} [pseudo_metric_space Î±] {s : â„• â†’ Î±} : cauchy_seq s â†” âˆƒ (b : â„• â†’ â„), (âˆ€ (n : â„•), 0 â‰¤ b n) âˆ§ (âˆ€ (n m N : â„•), N â‰¤ n â†’ N â‰¤ m â†’ has_dist.dist (s n) (s m) â‰¤ b N) âˆ§ filter.tendsto b filter.at_top (nhds 0)
theorem Mon.filtered_colimits.colimit_mul_aux_eq_of_rel_right {J : Type v} [category_theory.small_category J] (F : J â¥¤ Mon) [category_theory.is_filtered J] {x y y' : Î£ (j : J), â†¥(F.obj j)} (hyy' : category_theory.limits.types.filtered_colimit.rel (F â‹™ category_theory.forget Mon) y y') : Mon.filtered_colimits.colimit_mul_aux F x y = Mon.filtered_colimits.colimit_mul_aux F x y'
theorem metric.compact_iff_closed_bounded {Î± : Type u} [pseudo_metric_space Î±] {s : set Î±} [t2_space Î±] [proper_space Î±] : is_compact s â†” is_closed s âˆ§ metric.bounded s
theorem complex.has_deriv_at_sin (x : â„‚) : has_deriv_at complex.sin (complex.cos x) x
theorem metric.exists_closed_ball_inter_eq_singleton_of_discrete {Î± : Type u} [pseudo_metric_space Î±] {s : set Î±} [discrete_topology â†¥s] {x : Î±} (hx : x âˆˆ s) : âˆƒ (Îµ : â„) (H : Îµ > 0), metric.closed_ball x Îµ âˆ© s = {x}
theorem complex.continuous_at_cpow_of_re_pos {p : â„‚ Ã— â„‚} (hâ‚ : 0 â‰¤ p.fst.re âˆ¨ p.fst.im â‰  0) (hâ‚‚ : 0 < p.snd.re) : continuous_at (Î» (x : â„‚ Ã— â„‚), x.fst ^ x.snd) p
theorem char.quadratic_char_neg_one {F : Type u_1} [field F] [fintype F] [decidable_eq F] (hF : ring_char F â‰  2) : char.quadratic_char F (-1) = â‡‘zmod.Ï‡â‚„ â†‘(fintype.card F)
theorem fin.cons_update {n : â„•} {Î± : fin (n + 1) â†’ Type u} (x : Î± 0) (p : Î  (i : fin n), Î± i.succ) (i : fin n) (y : Î± i.succ) : fin.cons x (function.update p i y) = function.update (fin.cons x p) i.succ y
theorem setoid.Sup_def {Î± : Type u_1} {s : set (setoid Î±)} : has_Sup.Sup s = eqv_gen.setoid (has_Sup.Sup (setoid.rel '' s))
theorem category_theory.is_filtered.cocone_nonempty {C : Type u} [category_theory.category C] [category_theory.is_filtered C] {J : Type v} [category_theory.small_category J] [category_theory.fin_category J] (F : J â¥¤ C) : nonempty (category_theory.limits.cocone F)
theorem category_theory.abelian.pseudoelement.pseudo_zero_iff {C : Type u} [category_theory.category C] [category_theory.abelian C] {P : C} (a : category_theory.over P) : â†‘a = 0 â†” a.hom = 0
theorem ideal.is_prime_map_C_of_is_prime {R : Type u} [comm_ring R] {P : ideal R} (H : P.is_prime) : (ideal.map polynomial.C P).is_prime
theorem emetric.cauchy_iff {Î± : Type u} [pseudo_emetric_space Î±] {f : filter Î±} : cauchy f â†” f â‰  âŠ¥ âˆ§ âˆ€ (Îµ : ennreal), Îµ > 0 â†’ (âˆƒ (t : set Î±) (H : t âˆˆ f), âˆ€ (x : Î±), x âˆˆ t â†’ âˆ€ (y : Î±), y âˆˆ t â†’ has_edist.edist x y < Îµ)
theorem measure_theory.measure_preimage_add {G : Type u_1} [measurable_space G] [add_group G] [has_measurable_add G] (Î¼ : measure_theory.measure G) [Î¼.is_add_left_invariant] (g : G) (A : set G) : â‡‘Î¼ ((Î» (h : G), g + h) â»Â¹' A) = â‡‘Î¼ A
theorem set.seq_of_forall_finite_exists {Î³ : Type u_1} {P : Î³ â†’ set Î³ â†’ Prop} (h : âˆ€ (t : set Î³), t.finite â†’ (âˆƒ (c : Î³), P c t)) : âˆƒ (u : â„• â†’ Î³), âˆ€ (n : â„•), P (u n) (u '' set.Iio n)
theorem is_add_group_hom.sub {Î± : Type u_1} {Î² : Type u_2} [add_group Î±] [add_comm_group Î²] {f g : Î± â†’ Î²} (hf : is_add_group_hom f) (hg : is_add_group_hom g) : is_add_group_hom (Î» (a : Î±), f a - g a)
theorem and_or_distrib_left {a b c : Prop} : a âˆ§ (b âˆ¨ c) â†” a âˆ§ b âˆ¨ a âˆ§ c
theorem complex.circle_integral_div_sub_of_differentiable_on_off_countable {R : â„} {c w : â„‚} {s : set â„‚} (hs : s.countable) (hw : w âˆˆ metric.ball c R) {f : â„‚ â†’ â„‚} (hc : continuous_on f (metric.closed_ball c R)) (hd : âˆ€ (z : â„‚), z âˆˆ metric.ball c R  s â†’ differentiable_at â„‚ f z) : âˆ® (z : â„‚) in C(c, R), f z / (z - w) = 2 * â†‘real.pi * complex.I * f w
theorem set.antitone_bforall {Î± : Type u_1} {P : Î± â†’ Prop} : antitone (Î» (s : set Î±), âˆ€ (x : Î±), x âˆˆ s â†’ P x)
theorem has_lt.lt.trans' {Î± : Type u} [preorder Î±] {a b c : Î±} : b < c â†’ a < b â†’ a < c
theorem is_preconnected_sUnion {Î± : Type u} [topological_space Î±] (x : Î±) (c : set (set Î±)) (H1 : âˆ€ (s : set Î±), s âˆˆ c â†’ x âˆˆ s) (H2 : âˆ€ (s : set Î±), s âˆˆ c â†’ is_preconnected s) : is_preconnected (â‹ƒâ‚€c)
theorem emetric.uniform_continuous_on_iff {Î± : Type u} {Î² : Type v} [pseudo_emetric_space Î±] [pseudo_emetric_space Î²] {f : Î± â†’ Î²} {s : set Î±} : uniform_continuous_on f s â†” âˆ€ (Îµ : ennreal), Îµ > 0 â†’ (âˆƒ (Î´ : ennreal) (H : Î´ > 0), âˆ€ {a : Î±} {H : a âˆˆ s} {b : Î±} {H : b âˆˆ s}, has_edist.edist a b < Î´ â†’ has_edist.edist (f a) (f b) < Îµ)
theorem submonoid.closure_eq {M : Type u_1} [mul_one_class M] (S : submonoid M) : submonoid.closure â†‘S = S
theorem strict_convex.ae_eq_const_or_average_mem_interior {Î± : Type u_1} {E : Type u_2} {m0 : measurable_space Î±} [normed_group E] [normed_space â„ E] [complete_space E] {Î¼ : measure_theory.measure Î±} {s : set E} {f : Î± â†’ E} [measure_theory.is_finite_measure Î¼] (hs : strict_convex â„ s) (hsc : is_closed s) (hfs : âˆ€áµ (x : Î±) âˆ‚Î¼, f x âˆˆ s) (hfi : measure_theory.integrable f Î¼) : f =áµ[Î¼] function.const Î± (â¨ (x : Î±), f x âˆ‚Î¼) âˆ¨ â¨ (x : Î±), f x âˆ‚Î¼ âˆˆ interior s
theorem normed_space.norm_le_dual_bound (ğ•œ : Type v) [is_R_or_C ğ•œ] {E : Type u} [normed_group E] [normed_space ğ•œ E] (x : E) {M : â„} (hMp : 0 â‰¤ M) (hM : âˆ€ (f : normed_space.dual ğ•œ E), âˆ¥â‡‘f xâˆ¥ â‰¤ M * âˆ¥fâˆ¥) : âˆ¥xâˆ¥ â‰¤ M
theorem or_and_distrib_right {a b c : Prop} : (a âˆ¨ b) âˆ§ c â†” a âˆ§ c âˆ¨ b âˆ§ c
theorem filter.coprod_cocompact {Î± : Type u} {Î² : Type v} [topological_space Î±] [topological_space Î²] : (filter.cocompact Î±).coprod (filter.cocompact Î²) = filter.cocompact (Î± Ã— Î²)
theorem group.normal_closure.is_normal {G : Type u_1} {s : set G} [group G] : is_normal_subgroup (group.normal_closure s)
theorem cont_diff_id {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {n : with_top â„•} : cont_diff ğ•œ n id
theorem sub_right_lt_of_lt_add {Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b c : Î±} : a < b + c â†’ a - c < b
theorem dist_le_range_sum_dist {Î± : Type u} [pseudo_metric_space Î±] (f : â„• â†’ Î±) (n : â„•) : has_dist.dist (f 0) (f n) â‰¤ (finset.range n).sum (Î» (i : â„•), has_dist.dist (f i) (f (i + 1)))
theorem box_integral.has_integral_iff {Î¹ : Type u} {E : Type v} {F : Type w} [normed_group E] [normed_space â„ E] [normed_group F] [normed_space â„ F] {I : box_integral.box Î¹} [fintype Î¹] {l : box_integral.integration_params} {f : (Î¹ â†’ â„) â†’ E} {vol : box_integral.box_additive_map Î¹ (E â†’L[â„] F) âŠ¤} {y : F} : box_integral.has_integral I l f vol y â†” âˆ€ (Îµ : â„), Îµ > 0 â†’ (âˆƒ (r : nnreal â†’ (Î¹ â†’ â„) â†’ â†¥(set.Ioi 0)), (âˆ€ (c : nnreal), l.r_cond (r c)) âˆ§ âˆ€ (c : nnreal) (Ï€ : box_integral.tagged_prepartition I), l.mem_base_set I c (r c) Ï€ â†’ Ï€.is_partition â†’ has_dist.dist (box_integral.integral_sum f vol Ï€) y â‰¤ Îµ)
theorem le_trans {Î± : Type u} [preorder Î±] {a b c : Î±} : a â‰¤ b â†’ b â‰¤ c â†’ a â‰¤ c
theorem continuous_update {Î¹ : Type u_5} {Ï€ : Î¹ â†’ Type u_6} [Î  (i : Î¹), topological_space (Ï€ i)] [decidable_eq Î¹] (i : Î¹) : continuous (Î» (f : (Î  (j : Î¹), Ï€ j) Ã— Ï€ i), function.update f.fst i f.snd)
theorem category_theory.is_iso_of_mono_of_split_epi {C : Type uâ‚} [category_theory.category C] {X Y : C} (f : X âŸ¶ Y) [category_theory.mono f] [category_theory.split_epi f] : category_theory.is_iso f
theorem continuous_map.continuous_curry {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [topological_space Î±] [topological_space Î²] [topological_space Î³] [locally_compact_space (Î± Ã— Î²)] : continuous continuous_map.curry
theorem measure_theory.has_sum_integral_of_dominated_convergence {Î± : Type u_1} {E : Type u_2} [normed_group E] [normed_space â„ E] [complete_space E] {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {Î¹ : Type u_3} [encodable Î¹] {F : Î¹ â†’ Î± â†’ E} {f : Î± â†’ E} (bound : Î¹ â†’ Î± â†’ â„) (hF_meas : âˆ€ (n : Î¹), measure_theory.ae_strongly_measurable (F n) Î¼) (h_bound : âˆ€ (n : Î¹), âˆ€áµ (a : Î±) âˆ‚Î¼, âˆ¥F n aâˆ¥ â‰¤ bound n a) (bound_summable : âˆ€áµ (a : Î±) âˆ‚Î¼, summable (Î» (n : Î¹), bound n a)) (bound_integrable : measure_theory.integrable (Î» (a : Î±), âˆ‘' (n : Î¹), bound n a) Î¼) (h_lim : âˆ€áµ (a : Î±) âˆ‚Î¼, has_sum (Î» (n : Î¹), F n a) (f a)) : has_sum (Î» (n : Î¹), âˆ« (a : Î±), F n a âˆ‚Î¼) (âˆ« (a : Î±), f a âˆ‚Î¼)
theorem pythagorean_triple.coprime_classification' {x y z : â„¤} (h : pythagorean_triple x y z) (h_coprime : x.gcd y = 1) (h_parity : x % 2 = 1) (h_pos : 0 < z) : âˆƒ (m n : â„¤), x = m ^ 2 - n ^ 2 âˆ§ y = 2 * m * n âˆ§ z = m ^ 2 + n ^ 2 âˆ§ m.gcd n = 1 âˆ§ (m % 2 = 0 âˆ§ n % 2 = 1 âˆ¨ m % 2 = 1 âˆ§ n % 2 = 0) âˆ§ 0 â‰¤ m
theorem submodule.sup_orthogonal_of_complete_space {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {K : submodule ğ•œ E} [complete_space â†¥K] : K âŠ” Ká—® = âŠ¤
theorem is_localization.is_localization_of_is_exists_mul_mem {R : Type u_1} [comm_ring R] (S : Type u_2) [comm_ring S] [algebra R S] (M N : submonoid R) [is_localization M S] (h : M â‰¤ N) (h' : âˆ€ (x : â†¥N), âˆƒ (m : R), m * â†‘x âˆˆ M) : is_localization N S
theorem multilinear_map.snoc_add {R : Type u} {n : â„•} {M : fin n.succ â†’ Type v} {Mâ‚‚ : Type vâ‚‚} [semiring R] [Î  (i : fin n.succ), add_comm_monoid (M i)] [add_comm_monoid Mâ‚‚] [Î  (i : fin n.succ), module R (M i)] [module R Mâ‚‚] (f : multilinear_map R M Mâ‚‚) (m : Î  (i : fin n), M (â‡‘fin.cast_succ i)) (x y : M (fin.last n)) : â‡‘f (fin.snoc m (x + y)) = â‡‘f (fin.snoc m x) + â‡‘f (fin.snoc m y)
theorem zero_lt.right.mul_le_one_of_le_of_le {Î± : Type u} {a b : Î±} [mul_zero_one_class Î±] [partial_order Î±] [zero_lt.mul_pos_mono Î±] (ha : a â‰¤ 1) (hb : b â‰¤ 1) (b0 : 0 < b) : a * b â‰¤ 1
theorem minpoly.min (A : Type u_1) {B : Type u_2} [comm_ring A] [ring B] [algebra A B] (x : B) {p : polynomial A} (pmonic : p.monic) (hp : â‡‘(polynomial.aeval x) p = 0) : (minpoly A x).degree â‰¤ p.degree
theorem monovary_on.sum_smul_comp_perm_le_sum_smul {Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [linear_ordered_ring Î±] [linear_ordered_add_comm_group Î²] [module Î± Î²] [ordered_smul Î± Î²] {s : finset Î¹} {Ïƒ : equiv.perm Î¹} {f : Î¹ â†’ Î±} {g : Î¹ â†’ Î²} (hfg : monovary_on f g â†‘s) (hÏƒ : {x : Î¹ | â‡‘Ïƒ x â‰  x} âŠ† â†‘s) : s.sum (Î» (i : Î¹), f i â€¢ g (â‡‘Ïƒ i)) â‰¤ s.sum (Î» (i : Î¹), f i â€¢ g i)
theorem padic_seq.lift_index_left_left {p : â„•} [fact (nat.prime p)] {f : padic_seq p} (hf : Â¬f â‰ˆ 0) (v2 v3 : â„•) : padic_norm p (â‡‘f (padic_seq.stationary_point hf)) = padic_norm p (â‡‘f (linear_order.max (padic_seq.stationary_point hf) (linear_order.max v2 v3)))
theorem monoid_with_zero_hom.congr_arg {M : Type u_3} {N : Type u_4} [mul_zero_one_class M] [mul_zero_one_class N] (f : M â†’*â‚€ N) {x y : M} (h : x = y) : â‡‘f x = â‡‘f y
theorem affine.simplex.centroid_eq_of_range_eq {k : Type u_1} {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] {n : â„•} {sâ‚ sâ‚‚ : affine.simplex k P n} (h : set.range sâ‚.points = set.range sâ‚‚.points) : finset.centroid k finset.univ sâ‚.points = finset.centroid k finset.univ sâ‚‚.points
theorem regular_expression.matches_map {Î± : Type u_1} {Î² : Type u_2} (f : Î± â†’ Î²) (P : regular_expression Î±) : (regular_expression.map f P).matches = â‡‘(language.map f) P.matches
theorem real.Inf_nonneg (S : set â„) (hS : âˆ€ (x : â„), x âˆˆ S â†’ 0 â‰¤ x) : 0 â‰¤ has_Inf.Inf S
theorem Kuratowski_embedding.exists_isometric_embedding (Î± : Type u) [metric_space Î±] [topological_space.separable_space Î±] : âˆƒ (f : Î± â†’ â†¥(lp (Î» (n : â„•), â„) âŠ¤)), isometry f
theorem first_order.language.substructure.closure_induction' {L : first_order.language} {M : Type w} [L.Structure M] (s : set M) {p : Î  (x : M), x âˆˆ â‡‘(first_order.language.substructure.closure L) s â†’ Prop} (Hs : âˆ€ (x : M) (h : x âˆˆ s), p x _) (Hfun : âˆ€ {n : â„•} (f : L.functions n), first_order.language.closed_under f {x : M | âˆƒ (hx : x âˆˆ â‡‘(first_order.language.substructure.closure L) s), p x hx}) {x : M} (hx : x âˆˆ â‡‘(first_order.language.substructure.closure L) s) : p x hx
theorem filter.liminf_eq_supr_infi {Î± : Type u_1} {Î² : Type u_2} [complete_lattice Î±] {f : filter Î²} {u : Î² â†’ Î±} : f.liminf u = â¨† (s : set Î²) (H : s âˆˆ f), â¨… (a : Î²) (H : a âˆˆ s), u a
theorem vitali_family.null_of_frequently_le_of_frequently_ge {Î± : Type u_1} [metric_space Î±] {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (v : vitali_family Î¼) [sigma_compact_space Î±] [borel_space Î±] [measure_theory.is_locally_finite_measure Î¼] {Ï : measure_theory.measure Î±} [measure_theory.is_locally_finite_measure Ï] (hÏ : Ï.absolutely_continuous Î¼) {c d : nnreal} (hcd : c < d) (s : set Î±) (hc : âˆ€ (x : Î±), x âˆˆ s â†’ (âˆƒá¶  (a : set Î±) in v.filter_at x, â‡‘Ï a â‰¤ â†‘c * â‡‘Î¼ a)) (hd : âˆ€ (x : Î±), x âˆˆ s â†’ (âˆƒá¶  (a : set Î±) in v.filter_at x, â†‘d * â‡‘Î¼ a â‰¤ â‡‘Ï a)) : â‡‘Î¼ s = 0
theorem mul_equiv.map_finsupp_prod {Î± : Type u_1} {M : Type u_5} {N : Type u_7} {P : Type u_8} [has_zero M] [comm_monoid N] [comm_monoid P] (h : N â‰ƒ* P) (f : Î± â†’â‚€ M) (g : Î± â†’ M â†’ N) : â‡‘h (f.prod g) = f.prod (Î» (a : Î±) (b : M), â‡‘h (g a b))
theorem bdd_above.inter_of_right {Î± : Type u} [preorder Î±] {s t : set Î±} (h : bdd_above t) : bdd_above (s âˆ© t)
theorem subgroup.closure_induction'' {G : Type u_1} [group G] {k : set G} {p : G â†’ Prop} {x : G} (h : x âˆˆ subgroup.closure k) (Hk : âˆ€ (x : G), x âˆˆ k â†’ p x) (Hk_inv : âˆ€ (x : G), x âˆˆ k â†’ p xâ»Â¹) (H1 : p 1) (Hmul : âˆ€ (x y : G), p x â†’ p y â†’ p (x * y)) : p x
theorem antivary.sum_smul_lt_sum_smul_comp_perm_iff {Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [linear_ordered_ring Î±] [linear_ordered_add_comm_group Î²] [module Î± Î²] [ordered_smul Î± Î²] {Ïƒ : equiv.perm Î¹} {f : Î¹ â†’ Î±} {g : Î¹ â†’ Î²} [fintype Î¹] (hfg : antivary f g) : finset.univ.sum (Î» (i : Î¹), f i â€¢ g i) < finset.univ.sum (Î» (i : Î¹), f i â€¢ g (â‡‘Ïƒ i)) â†” Â¬antivary f (g âˆ˜ â‡‘Ïƒ)
theorem continuous_map.exists_mem_subalgebra_near_continuous_map_of_separates_points {X : Type u_1} [topological_space X] [compact_space X] (A : subalgebra â„ C(X, â„)) (w : A.separates_points) (f : C(X, â„)) (Îµ : â„) (pos : 0 < Îµ) : âˆƒ (g : â†¥A), âˆ¥â†‘g - fâˆ¥ < Îµ
theorem bounded_continuous_function.exists_forall_mem_restrict_eq_of_closed {Y : Type u_2} [topological_space Y] [normal_space Y] {s : set Y} (f : bounded_continuous_function â†¥s â„) (hs : is_closed s) {t : set â„} [t.ord_connected] (hf : âˆ€ (x : â†¥s), â‡‘f x âˆˆ t) (hne : t.nonempty) : âˆƒ (g : bounded_continuous_function Y â„), (âˆ€ (y : Y), â‡‘g y âˆˆ t) âˆ§ g.restrict s = f
theorem fin.order_embedding_eq {n : â„•} {Î± : Type u_1} [preorder Î±] {f g : fin n â†ªo Î±} (h : set.range â‡‘f = set.range â‡‘g) : f = g
theorem is_preconnected.closure {Î± : Type u} [topological_space Î±] {s : set Î±} (H : is_preconnected s) : is_preconnected (closure s)
theorem colex.sum_two_pow_lt_iff_lt (A B : finset â„•) : A.sum (Î» (i : â„•), 2 ^ i) < B.sum (Î» (i : â„•), 2 ^ i) â†” A.to_colex < B.to_colex
theorem is_artinian.induction {R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] [is_artinian R M] {P : submodule R M â†’ Prop} (hgt : âˆ€ (I : submodule R M), (âˆ€ (J : submodule R M), J < I â†’ P J) â†’ P I) (I : submodule R M) : P I
theorem linear_map.is_self_adjoint_adjoint_mul_self {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] [finite_dimensional ğ•œ E] (T : E â†’â‚—[ğ•œ] E) : inner_product_space.is_self_adjoint (â‡‘linear_map.adjoint T * T)
theorem strict_concave_on.lt_on_open_segment' {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [ordered_semiring ğ•œ] [add_comm_monoid E] [linear_ordered_add_comm_monoid Î²] [has_scalar ğ•œ E] [module ğ•œ Î²] [ordered_smul ğ•œ Î²] {s : set E} {f : E â†’ Î²} (hf : strict_concave_on ğ•œ s f) {x y : E} (hx : x âˆˆ s) (hy : y âˆˆ s) (hxy : x â‰  y) {a b : ğ•œ} (ha : 0 < a) (hb : 0 < b) (hab : a + b = 1) : linear_order.min (f x) (f y) < f (a â€¢ x + b â€¢ y)
theorem asymptotics.is_O_with.bound {Î± : Type u_1} {E : Type u_3} {F : Type u_4} [has_norm E] [has_norm F] {c : â„} {f : Î± â†’ E} {g : Î± â†’ F} {l : filter Î±} : asymptotics.is_O_with c l f g â†’ (âˆ€á¶  (x : Î±) in l, âˆ¥f xâˆ¥ â‰¤ c * âˆ¥g xâˆ¥)
theorem finset.untrop_sum {R : Type u_1} {S : Type u_2} [conditionally_complete_linear_order R] (s : finset S) (f : S â†’ tropical (with_top R)) : tropical.untrop (s.sum (Î» (i : S), f i)) = â¨… (i : â†¥s), tropical.untrop (f â†‘i)
theorem basis.map_isometry_euclidean_of_orthonormal {Î¹ : Type u_1} {ğ•œ : Type u_3} [is_R_or_C ğ•œ] {E : Type u_4} [inner_product_space ğ•œ E] {E' : Type u_5} [inner_product_space ğ•œ E'] [fintype Î¹] (v : basis Î¹ ğ•œ E) (hv : orthonormal ğ•œ â‡‘v) (f : E â‰ƒâ‚—áµ¢[ğ•œ] E') : ((v.map f.to_linear_equiv).to_orthonormal_basis _).repr = f.symm.trans (v.to_orthonormal_basis hv).repr
theorem finsupp.sum_smul_index_add_monoid_hom {Î± : Type u_1} {M : Type u_5} {N : Type u_7} {R : Type u_11} [monoid R] [add_monoid M] [add_comm_monoid N] [distrib_mul_action R M] {g : Î± â†’â‚€ M} {b : R} {h : Î± â†’ M â†’+ N} : (b â€¢ g).sum (Î» (a : Î±), â‡‘(h a)) = g.sum (Î» (i : Î±) (c : M), â‡‘(h i) (b â€¢ c))
theorem collinear_iff_of_mem (k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : set P} {pâ‚€ : P} (h : pâ‚€ âˆˆ s) : collinear k s â†” âˆƒ (v : V), âˆ€ (p : P), p âˆˆ s â†’ (âˆƒ (r : k), p = r â€¢ v +áµ¥ pâ‚€)
theorem measure_theory.mem_â„’p.integral_indicator_norm_ge_nonneg_le_of_meas {Î± : Type u_1} {Î² : Type u_2} {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) [normed_group Î²] {f : Î± â†’ Î²} (hf : measure_theory.mem_â„’p f 1 Î¼) (hmeas : measure_theory.strongly_measurable f) {Îµ : â„} (hÎµ : 0 < Îµ) : âˆƒ (M : â„), 0 â‰¤ M âˆ§ âˆ«â» (x : Î±), â†‘âˆ¥{x : Î± | M â‰¤ â†‘âˆ¥f xâˆ¥â‚Š}.indicator f xâˆ¥â‚Š âˆ‚Î¼ â‰¤ ennreal.of_real Îµ
theorem polynomial.prod_multiset_X_sub_C_dvd {R : Type u} [field R] (p : polynomial R) : (multiset.map (Î» (a : R), polynomial.X - â‡‘polynomial.C a) p.roots).prod âˆ£ p
theorem is_closed.Icc_subset_of_forall_mem_nhds_within {Î± : Type u} [conditionally_complete_linear_order Î±] [topological_space Î±] [order_topology Î±] [densely_ordered Î±] {a b : Î±} {s : set Î±} (hs : is_closed (s âˆ© set.Icc a b)) (ha : a âˆˆ s) (hgt : âˆ€ (x : Î±), x âˆˆ s âˆ© set.Ico a b â†’ s âˆˆ nhds_within x (set.Ioi x)) : set.Icc a b âŠ† s
theorem spectrum.pow_norm_pow_one_div_tendsto_nhds_spectral_radius {A : Type u_2} [normed_ring A] [normed_algebra â„‚ A] [complete_space A] [norm_one_class A] (a : A) : filter.tendsto (Î» (n : â„•), ennreal.of_real (âˆ¥a ^ nâˆ¥ ^ (1 / â†‘n))) filter.at_top (nhds (spectral_radius â„‚ a))
theorem is_cyclotomic_extension.prime_ne_two_pow_norm_zeta_sub_one {p : â„•+} {K : Type u} (L : Type v) [field K] [field L] [algebra K L] [ne_zero â†‘â†‘p] {k : â„•} [hpri : fact (nat.prime â†‘p)] [is_cyclotomic_extension {p ^ (k + 1)} K L] (hirr : irreducible (polynomial.cyclotomic â†‘(p ^ (k + 1)) K)) (h : p â‰  2) : â‡‘(algebra.norm K) (is_cyclotomic_extension.zeta (p ^ (k + 1)) K L - 1) = â†‘p
theorem polynomial.X_pow_sub_one_separable_iff {F : Type u} [field F] {n : â„•} : (polynomial.X ^ n - 1).separable â†” â†‘n â‰  0
theorem pgame.lt_iff_forall_le {x y : pgame} (ox : x.numeric) (oy : y.numeric) : x < y â†” (âˆƒ (i : y.left_moves), x â‰¤ y.move_left i) âˆ¨ âˆƒ (j : x.right_moves), x.move_right j â‰¤ y
theorem has_deriv_within_at.Ioo_of_Ioi {ğ•œ : Type u} [nondiscrete_normed_field ğ•œ] {F : Type v} [normed_group F] [normed_space ğ•œ F] {f : ğ•œ â†’ F} {f' : F} [linear_order ğ•œ] [order_closed_topology ğ•œ] {x y : ğ•œ} (h : x < y) : has_deriv_within_at f f' (set.Ioi x) x â†’ has_deriv_within_at f f' (set.Ioo x y) x
theorem has_le.le.antisymm {Î± : Type u} [partial_order Î±] {a b : Î±} : a â‰¤ b â†’ b â‰¤ a â†’ a = b
theorem exists_ratio_has_deriv_at_eq_ratio_slope' (f f' : â„ â†’ â„) {a b : â„} (hab : a < b) (g g' : â„ â†’ â„) {lfa lga lfb lgb : â„} (hff' : âˆ€ (x : â„), x âˆˆ set.Ioo a b â†’ has_deriv_at f (f' x) x) (hgg' : âˆ€ (x : â„), x âˆˆ set.Ioo a b â†’ has_deriv_at g (g' x) x) (hfa : filter.tendsto f (nhds_within a (set.Ioi a)) (nhds lfa)) (hga : filter.tendsto g (nhds_within a (set.Ioi a)) (nhds lga)) (hfb : filter.tendsto f (nhds_within b (set.Iio b)) (nhds lfb)) (hgb : filter.tendsto g (nhds_within b (set.Iio b)) (nhds lgb)) : âˆƒ (c : â„) (H : c âˆˆ set.Ioo a b), (lgb - lga) * f' c = (lfb - lfa) * g' c
theorem measure_theory.simple_func.box_integral_eq_integral {Î¹ : Type u} {E : Type v} [fintype Î¹] [normed_group E] [normed_space â„ E] (f : measure_theory.simple_func (Î¹ â†’ â„) E) (Î¼ : measure_theory.measure (Î¹ â†’ â„)) [measure_theory.is_locally_finite_measure Î¼] (I : box_integral.box Î¹) (l : box_integral.integration_params) (hl : l.bRiemann = bool.ff) : box_integral.integral I l â‡‘f Î¼.to_box_additive.to_smul = measure_theory.simple_func.integral (Î¼.restrict â†‘I) f
theorem dense.inter_open_nonempty {Î± : Type u} [topological_space Î±] {s : set Î±} : dense s â†’ âˆ€ (U : set Î±), is_open U â†’ U.nonempty â†’ (U âˆ© s).nonempty
theorem add_submonoid.localization_map.neg_unique {M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {N : Type u_2} [add_comm_monoid N] {f : M â†’+ N} (h : âˆ€ (y : â†¥S), is_add_unit (â‡‘f â†‘y)) {y : â†¥S} {z : N} (H : â‡‘f â†‘y + z = 0) : â†‘-â‡‘(is_add_unit.lift_right (f.restrict S) h) y = z
theorem homology.comp_right_eq_comp_left {V : Type u_1} [category_theory.category V] {Aâ‚ Bâ‚ Câ‚ Aâ‚‚ Bâ‚‚ Câ‚‚ Aâ‚ƒ Bâ‚ƒ Câ‚ƒ : V} {fâ‚ : Aâ‚ âŸ¶ Bâ‚} {gâ‚ : Bâ‚ âŸ¶ Câ‚} {fâ‚‚ : Aâ‚‚ âŸ¶ Bâ‚‚} {gâ‚‚ : Bâ‚‚ âŸ¶ Câ‚‚} {fâ‚ƒ : Aâ‚ƒ âŸ¶ Bâ‚ƒ} {gâ‚ƒ : Bâ‚ƒ âŸ¶ Câ‚ƒ} {Î±â‚ : category_theory.arrow.mk fâ‚ âŸ¶ category_theory.arrow.mk fâ‚‚} {Î²â‚ : category_theory.arrow.mk gâ‚ âŸ¶ category_theory.arrow.mk gâ‚‚} {Î±â‚‚ : category_theory.arrow.mk fâ‚‚ âŸ¶ category_theory.arrow.mk fâ‚ƒ} {Î²â‚‚ : category_theory.arrow.mk gâ‚‚ âŸ¶ category_theory.arrow.mk gâ‚ƒ} (pâ‚ : Î±â‚.right = Î²â‚.left) (pâ‚‚ : Î±â‚‚.right = Î²â‚‚.left) : (Î±â‚ â‰« Î±â‚‚).right = (Î²â‚ â‰« Î²â‚‚).left
theorem pgame.zero_le {x : pgame} : 0 â‰¤ x â†” âˆ€ (j : x.right_moves), âˆƒ (i : (x.move_right j).left_moves), 0 â‰¤ (x.move_right j).move_left i
theorem filter.map_at_top_finset_prod_le_of_prod_eq {Î± : Type u_3} {Î² : Type u_4} {Î³ : Type u_5} [comm_monoid Î±] {f : Î² â†’ Î±} {g : Î³ â†’ Î±} (h_eq : âˆ€ (u : finset Î³), âˆƒ (v : finset Î²), âˆ€ (v' : finset Î²), v âŠ† v' â†’ (âˆƒ (u' : finset Î³), u âŠ† u' âˆ§ u'.prod (Î» (x : Î³), g x) = v'.prod (Î» (b : Î²), f b))) : filter.map (Î» (s : finset Î²), s.prod (Î» (b : Î²), f b)) filter.at_top â‰¤ filter.map (Î» (s : finset Î³), s.prod (Î» (x : Î³), g x)) filter.at_top
theorem smul_pos {R : Type u_1} {M : Type u_2} [ordered_semiring R] [ordered_add_comm_monoid M] [smul_with_zero R M] [ordered_smul R M] {a : M} {c : R} (hc : 0 < c) : 0 < a â†’ 0 < c â€¢ a
theorem ordinal.enum_ord_def'_nonempty {S : set ordinal} (hS : set.unbounded has_lt.lt S) (a : ordinal) : (S âˆ© set.Ici a).nonempty
theorem orientation.ne_iff_eq_neg {R : Type u_1} [linear_ordered_field R] {M : Type u_2} [add_comm_group M] [module R M] {Î¹ : Type u_3} [decidable_eq Î¹] [fintype Î¹] [finite_dimensional R M] (xâ‚ xâ‚‚ : orientation R M Î¹) (h : fintype.card Î¹ = finite_dimensional.finrank R M) : xâ‚ â‰  xâ‚‚ â†” xâ‚ = -xâ‚‚
theorem add_semiconj_by.add_left {S : Type u} [add_semigroup S] {a b x y z : S} (ha : add_semiconj_by a y z) (hb : add_semiconj_by b x y) : add_semiconj_by (a + b) x z
theorem dense_embedding_pure {Î± : Type u} : dense_embedding has_pure.pure
theorem continuous_linear_map.is_bounded_linear_map {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] (f : E â†’L[ğ•œ] F) : is_bounded_linear_map ğ•œ â‡‘f
theorem finset.sum_centroid_weights_eq_one_of_cast_card_ne_zero {k : Type u_1} [division_ring k] {Î¹ : Type u_4} (s : finset Î¹) (h : â†‘(s.card) â‰  0) : s.sum (Î» (i : Î¹), finset.centroid_weights k s i) = 1
theorem nat.prime.factorization {p : â„•} (hp : nat.prime p) : p.factorization = finsupp.single p 1
theorem ideal.jacobson_eq_iff_jacobson_quotient_eq_bot {R : Type u} [comm_ring R] {I : ideal R} : I.jacobson = I â†” âŠ¥.jacobson = âŠ¥
theorem affine_subspace.ext_of_direction_eq {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s1 s2 : affine_subspace k P} (hd : s1.direction = s2.direction) (hn : (â†‘s1 âˆ© â†‘s2).nonempty) : s1 = s2
theorem list.sum_neg {G : Type u_7} [add_comm_group G] (L : list G) : -L.sum = (list.map (Î» (x : G), -x) L).sum
theorem orientation.oangle_neg_left_eq_neg_right {V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) (x y : V) : o.oangle (-x) y = o.oangle x (-y)
theorem matrix.det_smul_inv_mul_vec_eq_cramer {n : Type u'} {Î± : Type v} [fintype n] [decidable_eq n] [comm_ring Î±] (A : matrix n n Î±) (b : n â†’ Î±) (h : is_unit A.det) : A.det â€¢ Aâ»Â¹.mul_vec b = â‡‘(A.cramer) b
theorem filter.eventually_eq.measure_eq {Î± : Type u_1} [measurable_space Î±] {Î¼ : measure_theory.measure Î±} {s t : set Î±} (H : s =áµ[Î¼] t) : â‡‘Î¼ s = â‡‘Î¼ t
theorem interval_integral.integral_sub_linear_is_o_of_tendsto_ae {Î¹ : Type u_1} {E : Type u_3} [normed_group E] [complete_space E] [normed_space â„ E] {f : â„ â†’ E} {c : E} {l l' : filter â„} {lt : filter Î¹} {a : â„} [interval_integral.FTC_filter a l l'] (hfm : strongly_measurable_at_filter f l' measure_theory.measure_space.volume) (hf : filter.tendsto f (l' âŠ“ measure_theory.measure_space.volume.ae) (nhds c)) {u v : Î¹ â†’ â„} (hu : filter.tendsto u lt l) (hv : filter.tendsto v lt l) : (Î» (t : Î¹), (âˆ« (x : â„) in u t..v t, f x) - (v t - u t) â€¢ c) =o[lt] (v - u)
theorem set.finite.bdd_below_bUnion {Î± : Type u} {Î² : Type v} [semilattice_inf Î±] [nonempty Î±] {I : set Î²} {S : Î² â†’ set Î±} (H : I.finite) : bdd_below (â‹ƒ (i : Î²) (H : i âˆˆ I), S i) â†” âˆ€ (i : Î²), i âˆˆ I â†’ bdd_below (S i)
theorem pi_norm_le_iff {Î¹ : Type u_2} {Ï€ : Î¹ â†’ Type u_1} [fintype Î¹] [Î  (i : Î¹), semi_normed_group (Ï€ i)] {r : â„} (hr : 0 â‰¤ r) {x : Î  (i : Î¹), Ï€ i} : âˆ¥xâˆ¥ â‰¤ r â†” âˆ€ (i : Î¹), âˆ¥x iâˆ¥ â‰¤ r
theorem linear_map.mk_continuous_norm_le {ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_normed_group E] [semi_normed_group F] [nondiscrete_normed_field ğ•œ] [nondiscrete_normed_field ğ•œâ‚‚] [normed_space ğ•œ E] [normed_space ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} (f : E â†’â‚›â‚—[Ïƒâ‚â‚‚] F) {C : â„} (hC : 0 â‰¤ C) (h : âˆ€ (x : E), âˆ¥â‡‘f xâˆ¥ â‰¤ C * âˆ¥xâˆ¥) : âˆ¥f.mk_continuous C hâˆ¥ â‰¤ C
theorem add_subsemigroup.closure_eq {M : Type u_1} [has_add M] (S : add_subsemigroup M) : add_subsemigroup.closure â†‘S = S
theorem ideal.exists_ideal_over_prime_of_is_integral {R : Type u_1} [comm_ring R] {S : Type u_2} [comm_ring S] [algebra R S] (H : algebra.is_integral R S) (P : ideal R) [P.is_prime] (I : ideal S) [I.is_prime] (hIP : ideal.comap (algebra_map R S) I â‰¤ P) : âˆƒ (Q : ideal S) (H : Q â‰¥ I), Q.is_prime âˆ§ ideal.comap (algebra_map R S) Q = P
theorem function.injective.convex_independent_iff_set {ğ•œ : Type u_1} {E : Type u_2} {Î¹ : Type u_3} [ordered_semiring ğ•œ] [add_comm_group E] [module ğ•œ E] {p : Î¹ â†’ E} (hi : function.injective p) : convex_independent ğ•œ (Î» (x : â†¥(set.range p)), â†‘x) â†” convex_independent ğ•œ p
theorem set.image_image2_antidistrib_left {Î± : Type u_1} {Î² : Type u_3} {Î²' : Type u_4} {Î³ : Type u_5} {Î´ : Type u_7} {f : Î± â†’ Î² â†’ Î³} {s : set Î±} {t : set Î²} {g : Î³ â†’ Î´} {f' : Î²' â†’ Î± â†’ Î´} {g' : Î² â†’ Î²'} (h_antidistrib : âˆ€ (a : Î±) (b : Î²), g (f a b) = f' (g' b) a) : g '' set.image2 f s t = set.image2 f' (g' '' t) s
theorem is_compact.has_extreme_point {E : Type u_1} [normed_group E] [normed_space â„ E] {s : set E} (hscomp : is_compact s) (hsnemp : s.nonempty) : (set.extreme_points â„ s).nonempty
theorem euclidean_geometry.dist_sq_add_dist_sq_eq_two_mul_dist_midpoint_sq_add_half_dist_sq {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] (a b c : P) : has_dist.dist a b ^ 2 + has_dist.dist a c ^ 2 = 2 * (has_dist.dist a (midpoint â„ b c) ^ 2 + (has_dist.dist b c / 2) ^ 2)
theorem con.comap_eq {M : Type u_1} {N : Type u_2} [mul_one_class M] [mul_one_class N] {c : con M} {f : N â†’* M} : con.comap â‡‘f _ c = con.ker (c.mk'.comp f)
theorem is_artinian_of_tower (R : Type u_1) {S : Type u_2} {M : Type u_3} [comm_ring R] [ring S] [add_comm_group M] [algebra R S] [module S M] [module R M] [is_scalar_tower R S M] (h : is_artinian R M) : is_artinian S M
theorem cont_diff_prod_assoc_symm {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {G : Type u_4} [normed_group G] [normed_space ğ•œ G] : cont_diff ğ•œ âŠ¤ â‡‘((equiv.prod_assoc E F G).symm)
theorem tensor_algebra.Î¹_range_disjoint_one {R : Type u_1} [comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] : disjoint (tensor_algebra.Î¹ R).range 1
theorem real.cont_diff_at_rpow_of_ne (p : â„ Ã— â„) (hp : p.fst â‰  0) {n : with_top â„•} : cont_diff_at â„ n (Î» (p : â„ Ã— â„), p.fst ^ p.snd) p
theorem continuous_map.continuous {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] (f : C(Î±, Î²)) : continuous â‡‘f
theorem lipschitz_on_with.hausdorff_measure_image_le {X : Type u_2} {Y : Type u_3} [emetric_space X] [emetric_space Y] [measurable_space X] [borel_space X] [measurable_space Y] [borel_space Y] {K : nnreal} {f : X â†’ Y} {s : set X} (h : lipschitz_on_with K f s) {d : â„} (hd : 0 â‰¤ d) : â‡‘(measure_theory.measure.hausdorff_measure d) (f '' s) â‰¤ â†‘K ^ d * â‡‘(measure_theory.measure.hausdorff_measure d) s
theorem has_lt.lt.not_le {Î± : Type u} [preorder Î±] {a b : Î±} (h : a < b) : Â¬b â‰¤ a
theorem add_units.is_add_unit_add_units_add {M : Type u_1} [add_monoid M] (u : add_units M) (a : M) : is_add_unit (â†‘u + a) â†” is_add_unit a
theorem right.add_neg_of_neg_of_nonpos {Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b : Î±} (ha : a < 0) (hb : b â‰¤ 0) : a + b < 0
theorem metric.thickening_empty {Î± : Type u} [pseudo_emetric_space Î±] (Î´ : â„) : metric.thickening Î´ âˆ… = âˆ…
theorem nat.partrec.code.rec_prim {Î± : Type u_1} {Ïƒ : Type u_2} [primcodable Î±] [primcodable Ïƒ] {c : Î± â†’ nat.partrec.code} (hc : primrec c) {z : Î± â†’ Ïƒ} (hz : primrec z) {s : Î± â†’ Ïƒ} (hs : primrec s) {l : Î± â†’ Ïƒ} (hl : primrec l) {r : Î± â†’ Ïƒ} (hr : primrec r) {pr : Î± â†’ nat.partrec.code â†’ nat.partrec.code â†’ Ïƒ â†’ Ïƒ â†’ Ïƒ} (hpr : primrec (Î» (a : Î± Ã— nat.partrec.code Ã— nat.partrec.code Ã— Ïƒ Ã— Ïƒ), pr a.fst a.snd.fst a.snd.snd.fst a.snd.snd.snd.fst a.snd.snd.snd.snd)) {co : Î± â†’ nat.partrec.code â†’ nat.partrec.code â†’ Ïƒ â†’ Ïƒ â†’ Ïƒ} (hco : primrec (Î» (a : Î± Ã— nat.partrec.code Ã— nat.partrec.code Ã— Ïƒ Ã— Ïƒ), co a.fst a.snd.fst a.snd.snd.fst a.snd.snd.snd.fst a.snd.snd.snd.snd)) {pc : Î± â†’ nat.partrec.code â†’ nat.partrec.code â†’ Ïƒ â†’ Ïƒ â†’ Ïƒ} (hpc : primrec (Î» (a : Î± Ã— nat.partrec.code Ã— nat.partrec.code Ã— Ïƒ Ã— Ïƒ), pc a.fst a.snd.fst a.snd.snd.fst a.snd.snd.snd.fst a.snd.snd.snd.snd)) {rf : Î± â†’ nat.partrec.code â†’ Ïƒ â†’ Ïƒ} (hrf : primrec (Î» (a : Î± Ã— nat.partrec.code Ã— Ïƒ), rf a.fst a.snd.fst a.snd.snd)) : let F : Î± â†’ nat.partrec.code â†’ Ïƒ := Î» (a : Î±) (c : nat.partrec.code), c.rec_on (z a) (s a) (l a) (r a) (pr a) (co a) (pc a) (rf a) in primrec (Î» (a : Î±), F a (c a))
theorem measure_theory.is_add_fundamental_domain.map_restrict_quotient {G : Type u_1} [add_group G] [measurable_space G] [topological_space G] [topological_add_group G] [borel_space G] {Î¼ : measure_theory.measure G} {Î“ : add_subgroup G} {ğ“• : set G} (hğ“• : measure_theory.is_add_fundamental_domain â†¥(Î“.opposite) ğ“• Î¼) [encodable â†¥Î“] [measurable_space (G â§¸ Î“)] [borel_space (G â§¸ Î“)] [t2_space (G â§¸ Î“)] [topological_space.second_countable_topology (G â§¸ Î“)] (K : topological_space.positive_compacts (G â§¸ Î“)) [Î“.normal] [Î¼.is_add_haar_measure] [Î¼.is_add_right_invariant] (hğ“•_finite : â‡‘Î¼ ğ“• < âŠ¤) : measure_theory.measure.map â‡‘(quotient_add_group.mk' Î“) (Î¼.restrict ğ“•) = â‡‘Î¼ (ğ“• âˆ© â‡‘(quotient_add_group.mk' Î“) â»Â¹' â†‘K) â€¢ measure_theory.measure.add_haar_measure K
theorem finset.Inter_mem_sets {Î± : Type u} {f : filter Î±} {Î² : Type v} {s : Î² â†’ set Î±} (is : finset Î²) : (â‹‚ (i : Î²) (H : i âˆˆ is), s i) âˆˆ f â†” âˆ€ (i : Î²), i âˆˆ is â†’ s i âˆˆ f
theorem category_theory.congr_arg_mpr_hom_right {C : Type uâ‚} [category_theory.category C] {X Y Z : C} (p : X âŸ¶ Y) (q : Z = Y) : _.mpr p = p â‰« category_theory.eq_to_hom _
theorem orthonormal.oangle_rotation_oangle_left {V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) (x y : V) : hb.oangle (â‡‘(hb.rotation (hb.oangle x y)) x) y = 0
theorem add_monoid.subset_closure {M : Type u_1} [add_monoid M] {s : set M} : s âŠ† add_monoid.closure s
theorem monovary.sum_comp_perm_mul_lt_sum_mul_iff {Î¹ : Type u_1} {Î± : Type u_2} [linear_ordered_ring Î±] {Ïƒ : equiv.perm Î¹} {f g : Î¹ â†’ Î±} [fintype Î¹] (hfg : monovary f g) : finset.univ.sum (Î» (i : Î¹), f (â‡‘Ïƒ i) * g i) < finset.univ.sum (Î» (i : Î¹), f i * g i) â†” Â¬monovary (f âˆ˜ â‡‘Ïƒ) g
theorem order_iso.to_galois_connection {Î± : Type u} {Î² : Type v} [preorder Î±] [preorder Î²] (oi : Î± â‰ƒo Î²) : galois_connection â‡‘oi â‡‘(oi.symm)
theorem finset.mem_up_shadow_iff_exists_mem_card_add {Î± : Type u_1} [decidable_eq Î±] [fintype Î±] {ğ’œ : finset (finset Î±)} {s : finset Î±} {k : â„•} : s âˆˆ finset.up_shadow^[k] ğ’œ â†” âˆƒ (t : finset Î±) (H : t âˆˆ ğ’œ), t âŠ† s âˆ§ t.card + k = s.card
theorem integral_pow_abs_sub_interval_oc {a b : â„} (n : â„•) : âˆ« (x : â„) in set.interval_oc a b, |x - a| ^ n = |b - a| ^ (n + 1) / (â†‘n + 1)
theorem submodule.eq_top_of_nonempty_interior' {R : Type u_1} {M : Type u_2} [ring R] [topological_space R] [topological_space M] [add_comm_group M] [has_continuous_add M] [module R M] [has_continuous_smul R M] [(nhds_within 0 {x : R | is_unit x}).ne_bot] (s : submodule R M) (hs : (interior â†‘s).nonempty) : s = âŠ¤
theorem function.periodic.tendsto_at_bot_interval_integral_of_pos' {T : â„} {g : â„ â†’ â„} (hg : function.periodic g T) (h_int : âˆ€ (tâ‚ tâ‚‚ : â„), interval_integrable g measure_theory.measure_space.volume tâ‚ tâ‚‚) (hâ‚€ : âˆ€ (x : â„), 0 < g x) (hT : 0 < T) : filter.tendsto (Î» (t : â„), âˆ« (x : â„) in 0..t, g x) filter.at_bot filter.at_bot
theorem convex_on.neg {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [ordered_semiring ğ•œ] [add_comm_monoid E] [ordered_add_comm_group Î²] [has_scalar ğ•œ E] [module ğ•œ Î²] {s : set E} {f : E â†’ Î²} : convex_on ğ•œ s f â†’ concave_on ğ•œ s (-f)
theorem category_theory.triangulated.pretriangulated.comp_dist_triangle_mor_zeroâ‚ƒâ‚ (C : Type u) [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.has_shift C â„¤] [category_theory.preadditive C] [âˆ€ (n : â„¤), (category_theory.shift_functor C n).additive] [category_theory.triangulated.pretriangulated C] (T : category_theory.triangulated.triangle C) (H : T âˆˆ dist_triang C) : T.morâ‚ƒ â‰« (category_theory.shift_equiv C 1).functor.map T.morâ‚ = 0
theorem is_compact.nonempty_Inter_of_sequence_nonempty_compact_closed {Î± : Type u} [topological_space Î±] (Z : â„• â†’ set Î±) (hZd : âˆ€ (i : â„•), Z (i + 1) âŠ† Z i) (hZn : âˆ€ (i : â„•), (Z i).nonempty) (hZ0 : is_compact (Z 0)) (hZcl : âˆ€ (i : â„•), is_closed (Z i)) : (â‹‚ (i : â„•), Z i).nonempty
theorem is_localization.sec_spec' {R : Type u_1} [comm_semiring R] (M : submonoid R) {S : Type u_2} [comm_semiring S] [algebra R S] [is_localization M S] (z : S) : â‡‘(algebra_map R S) (is_localization.sec M z).fst = â‡‘(algebra_map R S) â†‘((is_localization.sec M z).snd) * z
theorem is_regular_mul_iff {R : Type u_1} {a b : R} [comm_semigroup R] : is_regular (a * b) â†” is_regular a âˆ§ is_regular b
theorem subgroup.pi_le_iff {Î· : Type u_5} {f : Î· â†’ Type u_6} [Î  (i : Î·), group (f i)] [decidable_eq Î·] [fintype Î·] {H : Î  (i : Î·), subgroup (f i)} {J : subgroup (Î  (i : Î·), f i)} : subgroup.pi set.univ H â‰¤ J â†” âˆ€ (i : Î·), subgroup.map (monoid_hom.single f i) (H i) â‰¤ J
theorem finprod_mem_of_eq_on_one {Î± : Type u_1} {M : Type u_5} [comm_monoid M] {f : Î± â†’ M} {s : set Î±} (hf : set.eq_on f 1 s) : finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), f i)) = 1
theorem continuous_on.strongly_measurable_at_filter {Î± : Type u_1} {Î² : Type u_2} [measurable_space Î±] [topological_space Î±] [opens_measurable_space Î±] [topological_space Î²] [topological_space.pseudo_metrizable_space Î²] [second_countable_topology_either Î± Î²] {f : Î± â†’ Î²} {s : set Î±} {Î¼ : measure_theory.measure Î±} (hs : is_open s) (hf : continuous_on f s) (x : Î±) (H : x âˆˆ s) : strongly_measurable_at_filter f (nhds x) Î¼
theorem affine_subspace.mem_coe (k : Type u_1) {V : Type u_2} (P : Type u_3) [ring k] [add_comm_group V] [module k V] [add_torsor V P] (p : P) (s : affine_subspace k P) : p âˆˆ â†‘s â†” p âˆˆ s
theorem linear_ordered_comm_group_with_zero.singleton_nhds_of_units {Î“â‚€ : Type u_1} [linear_ordered_comm_group_with_zero Î“â‚€] (Î³ : Î“â‚€Ë£) : {â†‘Î³} âˆˆ nhds â†‘Î³
theorem metric.Hausdorff_dist_le_of_inf_dist {Î± : Type u} [pseudo_metric_space Î±] {s t : set Î±} {r : â„} (hr : 0 â‰¤ r) (H1 : âˆ€ (x : Î±), x âˆˆ s â†’ metric.inf_dist x t â‰¤ r) (H2 : âˆ€ (x : Î±), x âˆˆ t â†’ metric.inf_dist x s â‰¤ r) : metric.Hausdorff_dist s t â‰¤ r
theorem first_order.language.substructure.is_elementary_of_exists {L : first_order.language} {M : Type u_3} [L.Structure M] (S : L.substructure M) (htv : âˆ€ (n : â„•) (Ï† : L.bounded_formula empty (n + 1)) (x : fin n â†’ â†¥S) (a : M), Ï†.realize inhabited.default (fin.snoc (coe âˆ˜ x) a) â†’ (âˆƒ (b : â†¥S), Ï†.realize inhabited.default (fin.snoc (coe âˆ˜ x) â†‘b))) : S.is_elementary
theorem linear_map.separating_left_iff_ker_eq_bot {R : Type u_1} {Râ‚ : Type u_2} {Râ‚‚ : Type u_3} {Mâ‚ : Type u_6} {Mâ‚‚ : Type u_7} [comm_semiring R] [comm_semiring Râ‚] [add_comm_monoid Mâ‚] [module Râ‚ Mâ‚] [comm_semiring Râ‚‚] [add_comm_monoid Mâ‚‚] [module Râ‚‚ Mâ‚‚] {Iâ‚ : Râ‚ â†’+* R} {Iâ‚‚ : Râ‚‚ â†’+* R} {B : Mâ‚ â†’â‚›â‚—[Iâ‚] Mâ‚‚ â†’â‚›â‚—[Iâ‚‚] R} : B.separating_left â†” B.ker = âŠ¥
theorem euclidean_geometry.circumcenter_eq_of_cospherical {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {ps : set P} {n : â„•} [finite_dimensional â„ V] (hd : finite_dimensional.finrank â„ V = n) (hc : euclidean_geometry.cospherical ps) {sxâ‚ sxâ‚‚ : affine.simplex â„ P n} (hsxâ‚ : set.range sxâ‚.points âŠ† ps) (hsxâ‚‚ : set.range sxâ‚‚.points âŠ† ps) : sxâ‚.circumcenter = sxâ‚‚.circumcenter
theorem is_open.measure_eq_supr_is_closed {Î± : Type u_1} [measurable_space Î±] [topological_space Î±] â¦ƒU : set Î±â¦„ (hU : is_open U) (Î¼ : measure_theory.measure Î±) [Î¼.weakly_regular] : â‡‘Î¼ U = â¨† (F : set Î±) (H : F âŠ† U) (h : is_closed F), â‡‘Î¼ F
theorem imp_forall_iff {Î± : Type u_1} {p : Prop} {q : Î± â†’ Prop} : p â†’ âˆ€ (x : Î±), q x â†” âˆ€ (x : Î±), p â†’ q x
theorem measure_theory.tendsto_in_measure_of_tendsto_ae {Î± : Type u_1} {E : Type u_3} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [metric_space E] {f : â„• â†’ Î± â†’ E} {g : Î± â†’ E} [measure_theory.is_finite_measure Î¼] (hf : âˆ€ (n : â„•), measure_theory.ae_strongly_measurable (f n) Î¼) (hfg : âˆ€áµ (x : Î±) âˆ‚Î¼, filter.tendsto (Î» (n : â„•), f n x) filter.at_top (nhds (g x))) : measure_theory.tendsto_in_measure Î¼ f filter.at_top g
theorem add_con.nsmul {M : Type u_1} [add_monoid M] (c : add_con M) (n : â„•) {w x : M} : â‡‘c w x â†’ â‡‘c (n â€¢ w) (n â€¢ x)
theorem module.free.of_equiv' {R : Type u} {N : Type z} [semiring R] [add_comm_monoid N] [module R N] {P : Type v} [add_comm_monoid P] [module R P] (h : module.free R P) (e : P â‰ƒâ‚—[R] N) : module.free R N
theorem closure_Ico {Î± : Type u} [topological_space Î±] [linear_order Î±] [order_topology Î±] [densely_ordered Î±] {a b : Î±} (hab : a â‰  b) : closure (set.Ico a b) = set.Icc a b
theorem category_theory.is_cofiltered.inf_to_commutes {C : Type u} [category_theory.category C] [category_theory.is_cofiltered C] (O : finset C) (H : finset (Î£' (X Y : C) (mX : X âˆˆ O) (mY : Y âˆˆ O), X âŸ¶ Y)) {X Y : C} (mX : X âˆˆ O) (mY : Y âˆˆ O) {f : X âŸ¶ Y} (mf : âŸ¨X, âŸ¨Y, âŸ¨mX, âŸ¨mY, fâŸ©âŸ©âŸ©âŸ© âˆˆ H) : category_theory.is_cofiltered.inf_to O H mX â‰« f = category_theory.is_cofiltered.inf_to O H mY
theorem tendsto_tsum_compl_at_top_zero {Î± : Type u_1} {Î² : Type u_2} [add_comm_group Î±] [uniform_space Î±] [uniform_add_group Î±] [t1_space Î±] (f : Î² â†’ Î±) : filter.tendsto (Î» (s : finset Î²), âˆ‘' (b : {x // x âˆ‰ s}), f â†‘b) filter.at_top (nhds 0)
theorem char_p_of_injective_algebra_map {R : Type u_1} {A : Type u_2} [comm_semiring R] [semiring A] [algebra R A] (h : function.injective â‡‘(algebra_map R A)) (p : â„•) [char_p R p] : char_p A p
theorem eq_of_vsub_eq_zero {G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] {p1 p2 : P} (h : p1 -áµ¥ p2 = 0) : p1 = p2
theorem add_monoid.is_torsion.not_torsion_free {G : Type u_1} [add_group G] [hN : nontrivial G] : add_monoid.is_torsion G â†’ Â¬add_monoid.is_torsion_free G
theorem bounded_continuous_function.uniform_continuous_comp {Î± : Type u} {Î² : Type v} {Î³ : Type w} [topological_space Î±] [pseudo_metric_space Î²] [pseudo_metric_space Î³] {G : Î² â†’ Î³} {C : nnreal} (H : lipschitz_with C G) : uniform_continuous (bounded_continuous_function.comp G H)
theorem clifford_algebra.Î¹_mul_Î¹_add_swap {R : Type u_1} [comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {Q : quadratic_form R M} (a b : M) : â‡‘(clifford_algebra.Î¹ Q) a * â‡‘(clifford_algebra.Î¹ Q) b + â‡‘(clifford_algebra.Î¹ Q) b * â‡‘(clifford_algebra.Î¹ Q) a = â‡‘(algebra_map R (clifford_algebra Q)) (quadratic_form.polar â‡‘Q a b)
theorem con.ker_lift_injective {M : Type u_1} {P : Type u_3} [mul_one_class M] [mul_one_class P] (f : M â†’* P) : function.injective â‡‘(con.ker_lift f)
theorem intermediate_field.ext {K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] {S T : intermediate_field K L} (h : âˆ€ (x : L), x âˆˆ S â†” x âˆˆ T) : S = T
theorem lie_ideal.map_bracket_le {R : Type u} {L : Type v} {L' : Type wâ‚‚} [comm_ring R] [lie_ring L] [lie_algebra R L] [lie_ring L'] [lie_algebra R L'] (f : L â†’â‚—â…Râ† L') {Iâ‚ Iâ‚‚ : lie_ideal R L} : lie_ideal.map f â…Iâ‚,Iâ‚‚â† â‰¤ â…lie_ideal.map f Iâ‚,lie_ideal.map f Iâ‚‚â†
theorem is_closed_frontier {Î± : Type u} [topological_space Î±] {s : set Î±} : is_closed (frontier s)
theorem subgroup.bot_or_exists_ne_one {G : Type u_1} [group G] (H : subgroup G) : H = âŠ¥ âˆ¨ âˆƒ (x : G) (H : x âˆˆ H), x â‰  1
theorem is_bounded_bilinear_map.continuous {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {G : Type u_4} [normed_group G] [normed_space ğ•œ G] {f : E Ã— F â†’ G} (h : is_bounded_bilinear_map ğ•œ f) : continuous f
theorem dist_le_Ico_sum_of_dist_le {Î± : Type u} [pseudo_metric_space Î±] {f : â„• â†’ Î±} {m n : â„•} (hmn : m â‰¤ n) {d : â„• â†’ â„} (hd : âˆ€ {k : â„•}, m â‰¤ k â†’ k < n â†’ has_dist.dist (f k) (f (k + 1)) â‰¤ d k) : has_dist.dist (f m) (f n) â‰¤ (finset.Ico m n).sum (Î» (i : â„•), d i)
theorem integral_closure.is_fraction_ring_of_algebraic {A : Type u_4} [comm_ring A] [is_domain A] {L : Type u_6} [field L] [algebra A L] (alg : algebra.is_algebraic A L) (inj : âˆ€ (x : A), â‡‘(algebra_map A L) x = 0 â†’ x = 0) : is_fraction_ring â†¥(integral_closure A L) L
theorem formal_multilinear_series.comp_partial_sum {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [nondiscrete_normed_field ğ•œ] [normed_group E] [normed_space ğ•œ E] [normed_group F] [normed_space ğ•œ F] [normed_group G] [normed_space ğ•œ G] (q : formal_multilinear_series ğ•œ F G) (p : formal_multilinear_series ğ•œ E F) (N : â„•) (z : E) : q.partial_sum N ((finset.Ico 1 N).sum (Î» (i : â„•), â‡‘(p i) (Î» (j : fin i), z))) = (formal_multilinear_series.comp_partial_sum_target 0 N N).sum (Î» (i : Î£ (n : â„•), composition n), â‡‘(q.comp_along_composition p i.snd) (Î» (j : fin i.fst), z))
theorem dite_eq_ite {Î± : Sort u_1} (P : Prop) [decidable P] (a b : Î±) : dite P (Î» (h : P), a) (Î» (h : Â¬P), b) = ite P a b
theorem is_compact_pi_infinite {Î¹ : Type u_1} {Ï€ : Î¹ â†’ Type u_2} [Î  (i : Î¹), topological_space (Ï€ i)] {s : Î  (i : Î¹), set (Ï€ i)} : (âˆ€ (i : Î¹), is_compact (s i)) â†’ is_compact {x : Î  (i : Î¹), Ï€ i | âˆ€ (i : Î¹), x i âˆˆ s i}
theorem tendsto_uniformly.comp {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} {Î¹ : Type u_4} [uniform_space Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : filter Î¹} (h : tendsto_uniformly F f p) (g : Î³ â†’ Î±) : tendsto_uniformly (Î» (n : Î¹), F n âˆ˜ g) (f âˆ˜ g) p
theorem category_theory.limits.mono_factorisation.ext {C : Type u} [category_theory.category C] {X Y : C} {f : X âŸ¶ Y} {F F' : category_theory.limits.mono_factorisation f} (hI : F.I = F'.I) (hm : F.m = category_theory.eq_to_hom hI â‰« F'.m) : F = F'
theorem measure_theory.uniform_integrable_of {Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_3} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [normed_group Î²] {p : ennreal} {f : Î¹ â†’ Î± â†’ Î²} [measure_theory.is_finite_measure Î¼] (hp : 1 â‰¤ p) (hp' : p â‰  âŠ¤) (hf : âˆ€ (i : Î¹), measure_theory.strongly_measurable (f i)) (h : âˆ€ (Îµ : â„), 0 < Îµ â†’ (âˆƒ (C : nnreal), âˆ€ (i : Î¹), measure_theory.snorm ({x : Î± | C â‰¤ âˆ¥f i xâˆ¥â‚Š}.indicator (f i)) p Î¼ â‰¤ ennreal.of_real Îµ)) : measure_theory.uniform_integrable f p Î¼
theorem affine.simplex.circumcenter_eq_point {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] (s : affine.simplex â„ P 0) (i : fin 1) : s.circumcenter = s.points i
theorem exists_idempotent_of_compact_t2_of_continuous_mul_left {M : Type u_1} [nonempty M] [semigroup M] [topological_space M] [compact_space M] [t2_space M] (continuous_mul_left : âˆ€ (r : M), continuous (Î» (_x : M), _x * r)) : âˆƒ (m : M), m * m = m
theorem units.is_smul_regular {R : Type u_1} (M : Type u_3) [monoid R] [mul_action R M] (a : RË£) : is_smul_regular M â†‘a
theorem parser.nat_of_done_bounded {cb : char_buffer} {n n' val : â„•} (h : parser.nat cb n = parse_result.done n' val) (hn : n' < buffer.size cb) : '0' â‰¤ buffer.read cb âŸ¨n', hnâŸ© â†’ '9' < buffer.read cb âŸ¨n', hnâŸ©
theorem function.commute.left_bij_on_fixed_pts_comp {Î± : Type u} {f g : Î± â†’ Î±} (h : function.commute f g) : set.bij_on f (function.fixed_points (f âˆ˜ g)) (function.fixed_points (f âˆ˜ g))
theorem norm_eq_infi_iff_real_inner_eq_zero {F : Type u_3} [inner_product_space â„ F] (K : submodule â„ F) {u v : F} (hv : v âˆˆ K) : (âˆ¥u - vâˆ¥ = â¨… (w : â†¥â†‘K), âˆ¥u - â†‘wâˆ¥) â†” âˆ€ (w : F), w âˆˆ K â†’ has_inner.inner (u - v) w = 0
theorem is_max_filter.undual {Î± : Type u} {Î² : Type v} [preorder Î²] {f : Î± â†’ Î²} {l : filter Î±} {a : Î±} : is_max_filter (â‡‘order_dual.to_dual âˆ˜ f) l a â†’ is_min_filter f l a
theorem matrix.finrank_matrix {m : Type u_1} {n : Type u_2} [fintype m] [fintype n] {R : Type v} [field R] : finite_dimensional.finrank R (matrix m n R) = fintype.card m * fintype.card n
theorem probability_theory.indep_fun.variance_add {Î© : Type u_1} [measure_theory.measure_space Î©] [measure_theory.is_probability_measure measure_theory.measure_space.volume] {X Y : Î© â†’ â„} (hX : measure_theory.mem_â„’p X 2 measure_theory.measure_space.volume) (hY : measure_theory.mem_â„’p Y 2 measure_theory.measure_space.volume) (h : probability_theory.indep_fun X Y measure_theory.measure_space.volume) : probability_theory.variance (X + Y) measure_theory.measure_space.volume = probability_theory.variance X measure_theory.measure_space.volume + probability_theory.variance Y measure_theory.measure_space.volume
theorem has_strict_fderiv_at.exists_lipschitz_on_with_of_nnnorm_lt {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {f : E â†’ F} {f' : E â†’L[ğ•œ] F} {x : E} (hf : has_strict_fderiv_at f f' x) (K : nnreal) (hK : âˆ¥f'âˆ¥â‚Š < K) : âˆƒ (s : set E) (H : s âˆˆ nhds x), lipschitz_on_with K f s
theorem pnat.prod_factor_multiset (n : â„•+) : n.factor_multiset.prod = n
theorem left.mul_lt_one {Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a b : Î±} (ha : a < 1) (hb : b < 1) : a * b < 1
theorem category_theory.is_pullback.zero_top {C : Type uâ‚} [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_zero_morphisms C] (X : C) : category_theory.is_pullback 0 0 0 (ğŸ™ X)
theorem con.pow {M : Type u_1} [monoid M] (c : con M) (n : â„•) {w x : M} : â‡‘c w x â†’ â‡‘c (w ^ n) (x ^ n)
theorem finsupp.single_left_injective {Î± : Type u_1} {M : Type u_5} [has_zero M] {b : M} (h : b â‰  0) : function.injective (Î» (a : Î±), finsupp.single a b)
theorem category_theory.is_iso.of_mono_retraction {C : Type uâ‚} [category_theory.category C] {X Y : C} {f : X âŸ¶ Y} [category_theory.split_mono f] [category_theory.mono (category_theory.retraction f)] : category_theory.is_iso f
theorem power_series.order_eq_nat {R : Type u_1} [semiring R] {Ï† : power_series R} {n : â„•} : Ï†.order = â†‘n â†” â‡‘(power_series.coeff R n) Ï† â‰  0 âˆ§ âˆ€ (i : â„•), i < n â†’ â‡‘(power_series.coeff R i) Ï† = 0
theorem dfinsupp.single_eq_of_sigma_eq {Î¹ : Type u} {Î² : Î¹ â†’ Type v} [dec : decidable_eq Î¹] [Î  (i : Î¹), has_zero (Î² i)] {i j : Î¹} {xi : Î² i} {xj : Î² j} (h : âŸ¨i, xiâŸ© = âŸ¨j, xjâŸ©) : dfinsupp.single i xi = dfinsupp.single j xj
theorem matrix.det_zero_of_row_eq {n : Type u_2} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] {M : matrix n n R} {i j : n} (i_ne_j : i â‰  j) (hij : M i = M j) : M.det = 0
theorem ennreal.tsum_geometric (r : ennreal) : âˆ‘' (n : â„•), r ^ n = (1 - r)â»Â¹
theorem witt_vector.mul_is_polyâ‚‚ {p : â„•} [fact (nat.prime p)] : witt_vector.is_polyâ‚‚ p (Î» (_x : Type u_1) (_x_1 : comm_ring _x), has_mul.mul)
theorem valuation.ext_iff {R : Type u_2} {Î“â‚€ : Type u_3} [ring R] [linear_ordered_comm_monoid_with_zero Î“â‚€] {vâ‚ vâ‚‚ : valuation R Î“â‚€} : vâ‚ = vâ‚‚ â†” âˆ€ (r : R), â‡‘vâ‚ r = â‡‘vâ‚‚ r
theorem lie_algebra.zero_root_subalgebra_is_cartan_of_eq (R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] (H : lie_subalgebra R L) [lie_algebra.is_nilpotent R â†¥H] (h : lie_algebra.zero_root_subalgebra R L H = H) : H.is_cartan_subalgebra
theorem finset.slice_subset {Î± : Type u_1} {ğ’œ : finset (finset Î±)} {r : â„•} : ğ’œ.slice r âŠ† ğ’œ
theorem add_nonpos {Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : a â‰¤ 0) (hb : b â‰¤ 0) : a + b â‰¤ 0
theorem orientation.oangle_rotation_self_left {V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) {x : V} (hx : x â‰  0) (Î¸ : real.angle) : o.oangle (â‡‘(o.rotation Î¸) x) x = -Î¸
theorem concave_on.le_map_integral {Î± : Type u_1} {E : Type u_2} {m0 : measurable_space Î±} [normed_group E] [normed_space â„ E] [complete_space E] {Î¼ : measure_theory.measure Î±} {s : set E} {f : Î± â†’ E} {g : E â†’ â„} [measure_theory.is_probability_measure Î¼] (hg : concave_on â„ s g) (hgc : continuous_on g s) (hsc : is_closed s) (hfs : âˆ€áµ (x : Î±) âˆ‚Î¼, f x âˆˆ s) (hfi : measure_theory.integrable f Î¼) (hgi : measure_theory.integrable (g âˆ˜ f) Î¼) : âˆ« (x : Î±), g (f x) âˆ‚Î¼ â‰¤ g (âˆ« (x : Î±), f x âˆ‚Î¼)
theorem add_group.fg_iff {G : Type u_3} [add_group G] : add_group.fg G â†” âˆƒ (S : set G), add_subgroup.closure S = âŠ¤ âˆ§ S.finite
theorem besicovitch.exists_closed_ball_covering_tsum_measure_le {Î± : Type u_1} [metric_space Î±] [topological_space.second_countable_topology Î±] [measurable_space Î±] [opens_measurable_space Î±] [has_besicovitch_covering Î±] (Î¼ : measure_theory.measure Î±) [measure_theory.sigma_finite Î¼] [Î¼.outer_regular] {Îµ : ennreal} (hÎµ : Îµ â‰  0) (f : Î± â†’ set â„) (s : set Î±) (hf : âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (Î´ : â„), Î´ > 0 â†’ (f x âˆ© set.Ioo 0 Î´).nonempty) : âˆƒ (t : set Î±) (r : Î± â†’ â„), t.countable âˆ§ t âŠ† s âˆ§ (âˆ€ (x : Î±), x âˆˆ t â†’ r x âˆˆ f x) âˆ§ (s âŠ† â‹ƒ (x : Î±) (H : x âˆˆ t), metric.closed_ball x (r x)) âˆ§ âˆ‘' (x : â†¥t), â‡‘Î¼ (metric.closed_ball â†‘x (r â†‘x)) â‰¤ â‡‘Î¼ s + Îµ
theorem tendsto_rpow_div_mul_add (a b c : â„) (hb : 0 â‰  b) : filter.tendsto (Î» (x : â„), x ^ (a / (b * x + c))) filter.at_top (nhds 1)
theorem same_ray.of_neg {R : Type u_1} [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {x y : M} : same_ray R (-x) (-y) â†’ same_ray R x y
theorem euclidean_geometry.inner_vsub_vsub_of_dist_eq_of_dist_eq {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {câ‚ câ‚‚ pâ‚ pâ‚‚ : P} (hcâ‚ : has_dist.dist pâ‚ câ‚ = has_dist.dist pâ‚‚ câ‚) (hcâ‚‚ : has_dist.dist pâ‚ câ‚‚ = has_dist.dist pâ‚‚ câ‚‚) : has_inner.inner (câ‚‚ -áµ¥ câ‚) (pâ‚‚ -áµ¥ pâ‚) = 0
theorem affine_independent.affine_span_image_finset_eq_of_le_of_card_eq_finrank_add_one {k : Type u_1} {V : Type u_2} {P : Type u_3} {Î¹ : Type u_4} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] {p : Î¹ â†’ P} (hi : affine_independent k p) {s : finset Î¹} {sp : affine_subspace k P} [finite_dimensional k â†¥(sp.direction)] (hle : affine_span k â†‘(finset.image p s) â‰¤ sp) (hc : s.card = finite_dimensional.finrank k â†¥(sp.direction) + 1) : affine_span k â†‘(finset.image p s) = sp
theorem summable_iff_cauchy_seq_finset {Î± : Type u_1} {Î² : Type u_2} [add_comm_group Î±] [uniform_space Î±] [complete_space Î±] {f : Î² â†’ Î±} : summable f â†” cauchy_seq (Î» (s : finset Î²), s.sum (Î» (b : Î²), f b))
theorem continuous_on.integral_sub_linear_is_o_ae {Î± : Type u_1} {E : Type u_3} [measurable_space Î±] {Î¹ : Type u_5} [normed_group E] [topological_space Î±] [opens_measurable_space Î±] [normed_space â„ E] [complete_space E] [second_countable_topology_either Î± E] {Î¼ : measure_theory.measure Î±} [measure_theory.is_locally_finite_measure Î¼] {a : Î±} {t : set Î±} {f : Î± â†’ E} (hft : continuous_on f t) (ha : a âˆˆ t) (ht : measurable_set t) {s : Î¹ â†’ set Î±} {li : filter Î¹} (hs : filter.tendsto s li (nhds_within a t).small_sets) (m : Î¹ â†’ â„ := Î» (i : Î¹), (â‡‘Î¼ (s i)).to_real) (hsÎ¼ : (Î» (i : Î¹), (â‡‘Î¼ (s i)).to_real) =á¶ [li] m . "refl") : (Î» (i : Î¹), âˆ« (x : Î±) in s i, f x âˆ‚Î¼ - m i â€¢ f a) =o[li] m
theorem finset.eq_weighted_vsub_subset_iff_eq_weighted_vsub_subtype (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {Î¹ : Type u_4} {v : V} {s : set Î¹} {p : Î¹ â†’ P} : (âˆƒ (fs : finset Î¹) (hfs : â†‘fs âŠ† s) (w : Î¹ â†’ k) (hw : fs.sum (Î» (i : Î¹), w i) = 0), v = â‡‘(fs.weighted_vsub p) w) â†” âˆƒ (fs : finset â†¥s) (w : â†¥s â†’ k) (hw : fs.sum (Î» (i : â†¥s), w i) = 0), v = â‡‘(fs.weighted_vsub (Î» (i : â†¥s), p â†‘i)) w
theorem set.subsingleton.preimage {Î± : Type u} {Î² : Type v} {s : set Î²} (hs : s.subsingleton) {f : Î± â†’ Î²} (hf : function.injective f) : (f â»Â¹' s).subsingleton
theorem measure_theory.Lp.induction_strongly_measurable {Î± : Type u_1} {F : Type u_6} {p : ennreal} [normed_group F] {m m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [fact (1 â‰¤ p)] [normed_space â„ F] (hm : m â‰¤ m0) (hp_ne_top : p â‰  âŠ¤) (P : â†¥(measure_theory.Lp F p Î¼) â†’ Prop) (h_ind : âˆ€ (c : F) {s : set Î±} (hs : measurable_set s) (hÎ¼s : â‡‘Î¼ s < âŠ¤), P â†‘(measure_theory.Lp.simple_func.indicator_const p _ _ c)) (h_add : âˆ€ â¦ƒf g : Î± â†’ Fâ¦„ (hf : measure_theory.mem_â„’p f p Î¼) (hg : measure_theory.mem_â„’p g p Î¼), measure_theory.strongly_measurable f â†’ measure_theory.strongly_measurable g â†’ disjoint (function.support f) (function.support g) â†’ P (measure_theory.mem_â„’p.to_Lp f hf) â†’ P (measure_theory.mem_â„’p.to_Lp g hg) â†’ P (measure_theory.mem_â„’p.to_Lp f hf + measure_theory.mem_â„’p.to_Lp g hg)) (h_closed : is_closed {f : â†¥(measure_theory.Lp_meas F â„ m p Î¼) | P â†‘f}) (f : â†¥(measure_theory.Lp F p Î¼)) : measure_theory.ae_strongly_measurable' m â‡‘f Î¼ â†’ P f
theorem is_noetherian_def {R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] : is_noetherian R M â†” âˆ€ (s : submodule R M), s.fg
theorem is_connected.Ioo_cInf_cSup_subset {Î± : Type u} [conditionally_complete_linear_order Î±] [topological_space Î±] [order_topology Î±] {s : set Î±} (hs : is_connected s) (hb : bdd_below s) (ha : bdd_above s) : set.Ioo (has_Inf.Inf s) (has_Sup.Sup s) âŠ† s
theorem algebraic_independent.restrict_scalars {Î¹ : Type u_1} {R : Type u_3} {A : Type u_5} {x : Î¹ â†’ A} [comm_ring R] [comm_ring A] [algebra R A] {K : Type u_2} [comm_ring K] [algebra R K] [algebra K A] [is_scalar_tower R K A] (hinj : function.injective â‡‘(algebra_map R K)) (ai : algebraic_independent K x) : algebraic_independent R x
theorem cont_diff_at.has_strict_fderiv_at {n : with_top â„•} {ğ•‚ : Type u_6} [is_R_or_C ğ•‚] {E' : Type u_7} [normed_group E'] [normed_space ğ•‚ E'] {F' : Type u_8} [normed_group F'] [normed_space ğ•‚ F'] {f : E' â†’ F'} {x : E'} (hf : cont_diff_at ğ•‚ n f x) (hn : 1 â‰¤ n) : has_strict_fderiv_at f (fderiv ğ•‚ f x) x
theorem or_and_distrib_left {a b c : Prop} : a âˆ¨ b âˆ§ c â†” (a âˆ¨ b) âˆ§ (a âˆ¨ c)
theorem cont_mdiff_on.cont_diff_on {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {n : with_top â„•} {f : E â†’ E'} {s : set E} : cont_mdiff_on (model_with_corners_self ğ•œ E) (model_with_corners_self ğ•œ E') n f s â†’ cont_diff_on ğ•œ n f s
theorem multilinear_map.dom_dom_congr_eq_iff {R : Type u} {Mâ‚‚ : Type vâ‚‚} {Mâ‚ƒ : Type vâ‚ƒ} [semiring R] [add_comm_monoid Mâ‚‚] [add_comm_monoid Mâ‚ƒ] [module R Mâ‚‚] [module R Mâ‚ƒ] {Î¹â‚ : Type u_1} {Î¹â‚‚ : Type u_2} [decidable_eq Î¹â‚] [decidable_eq Î¹â‚‚] (Ïƒ : Î¹â‚ â‰ƒ Î¹â‚‚) (f g : multilinear_map R (Î» (i : Î¹â‚), Mâ‚‚) Mâ‚ƒ) : multilinear_map.dom_dom_congr Ïƒ f = multilinear_map.dom_dom_congr Ïƒ g â†” f = g
theorem set.measure_eq_infi_is_open {Î± : Type u_1} [measurable_space Î±] [topological_space Î±] (A : set Î±) (Î¼ : measure_theory.measure Î±) [Î¼.outer_regular] : â‡‘Î¼ A = â¨… (U : set Î±) (h : A âŠ† U) (h2 : is_open U), â‡‘Î¼ U
theorem measure_theory.tendsto_integral_of_dominated_convergence {Î± : Type u_1} {E : Type u_2} [normed_group E] [normed_space â„ E] [complete_space E] {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {F : â„• â†’ Î± â†’ E} {f : Î± â†’ E} (bound : Î± â†’ â„) (F_measurable : âˆ€ (n : â„•), measure_theory.ae_strongly_measurable (F n) Î¼) (bound_integrable : measure_theory.integrable bound Î¼) (h_bound : âˆ€ (n : â„•), âˆ€áµ (a : Î±) âˆ‚Î¼, âˆ¥F n aâˆ¥ â‰¤ bound a) (h_lim : âˆ€áµ (a : Î±) âˆ‚Î¼, filter.tendsto (Î» (n : â„•), F n a) filter.at_top (nhds (f a))) : filter.tendsto (Î» (n : â„•), âˆ« (a : Î±), F n a âˆ‚Î¼) filter.at_top (nhds (âˆ« (a : Î±), f a âˆ‚Î¼))
theorem fintype.prod_equiv {Î± : Type u_1} {Î² : Type u_2} {M : Type u_3} [fintype Î±] [fintype Î²] [comm_monoid M] (e : Î± â‰ƒ Î²) (f : Î± â†’ M) (g : Î² â†’ M) (h : âˆ€ (x : Î±), f x = g (â‡‘e x)) : finset.univ.prod (Î» (x : Î±), f x) = finset.univ.prod (Î» (x : Î²), g x)
theorem mul_lt_one' {Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a b : Î±} (ha : a < 1) (hb : b < 1) : a * b < 1
theorem list.subperm_ext_iff {Î± : Type uu} [decidable_eq Î±] {lâ‚ lâ‚‚ : list Î±} : lâ‚ <+~ lâ‚‚ â†” âˆ€ (x : Î±), x âˆˆ lâ‚ â†’ list.count x lâ‚ â‰¤ list.count x lâ‚‚
theorem with_top.sum_lt_top_iff {Î¹ : Type u_1} {M : Type u_4} [ordered_add_comm_monoid M] {s : finset Î¹} {f : Î¹ â†’ with_top M} : s.sum (Î» (i : Î¹), f i) < âŠ¤ â†” âˆ€ (i : Î¹), i âˆˆ s â†’ f i < âŠ¤
theorem orthonormal.two_zsmul_oangle_sub_eq_two_zsmul_oangle_sub_of_norm_eq {V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) {xâ‚ xâ‚‚ y z : V} (hxâ‚yne : xâ‚ â‰  y) (hxâ‚zne : xâ‚ â‰  z) (hxâ‚‚yne : xâ‚‚ â‰  y) (hxâ‚‚zne : xâ‚‚ â‰  z) {r : â„} (hxâ‚ : âˆ¥xâ‚âˆ¥ = r) (hxâ‚‚ : âˆ¥xâ‚‚âˆ¥ = r) (hy : âˆ¥yâˆ¥ = r) (hz : âˆ¥zâˆ¥ = r) : 2 â€¢ hb.oangle (y - xâ‚) (z - xâ‚) = 2 â€¢ hb.oangle (y - xâ‚‚) (z - xâ‚‚)
theorem filter.tendsto.integrable_at_filter_ae {Î± : Type u_1} {E : Type u_3} [measurable_space Î±] [normed_group E] {f : Î± â†’ E} {Î¼ : measure_theory.measure Î±} {l : filter Î±} [l.is_measurably_generated] (hfm : strongly_measurable_at_filter f l Î¼) (hÎ¼ : Î¼.finite_at_filter l) {b : E} (hf : filter.tendsto f (l âŠ“ Î¼.ae) (nhds b)) : measure_theory.integrable_at_filter f l Î¼
theorem ring_equiv.is_domain {A : Type u_1} (B : Type u_2) [ring A] [ring B] [is_domain B] (e : A â‰ƒ+* B) : is_domain A
theorem cont_diff_on.smul {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {n : with_top â„•} {s : set E} {f : E â†’ ğ•œ} {g : E â†’ F} (hf : cont_diff_on ğ•œ n f s) (hg : cont_diff_on ğ•œ n g s) : cont_diff_on ğ•œ n (Î» (x : E), f x â€¢ g x) s
theorem affine_subspace.direction_eq_vector_span {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : affine_subspace k P) : s.direction = vector_span k â†‘s
theorem complex.integral_boundary_rect_of_continuous_on_of_has_fderiv_at_real {E : Type u} [normed_group E] [normed_space â„‚ E] [complete_space E] (f : â„‚ â†’ E) (f' : â„‚ â†’ (â„‚ â†’L[â„] E)) (z w : â„‚) (Hc : continuous_on f (set.interval z.re w.re Ã—â„‚ set.interval z.im w.im)) (Hd : âˆ€ (x : â„‚), x âˆˆ set.Ioo (linear_order.min z.re w.re) (linear_order.max z.re w.re) Ã—â„‚ set.Ioo (linear_order.min z.im w.im) (linear_order.max z.im w.im) â†’ has_fderiv_at f (f' x) x) (Hi : measure_theory.integrable_on (Î» (z : â„‚), complex.I â€¢ â‡‘(f' z) 1 - â‡‘(f' z) complex.I) (set.interval z.re w.re Ã—â„‚ set.interval z.im w.im) measure_theory.measure_space.volume) : (((âˆ« (x : â„) in z.re..w.re, f (â†‘x + â†‘(z.im) * complex.I)) - âˆ« (x : â„) in z.re..w.re, f (â†‘x + â†‘(w.im) * complex.I)) + complex.I â€¢ âˆ« (y : â„) in z.im..w.im, f (â†‘(w.re) + â†‘y * complex.I)) - complex.I â€¢ âˆ« (y : â„) in z.im..w.im, f (â†‘(z.re) + â†‘y * complex.I) = âˆ« (x : â„) in z.re..w.re, âˆ« (y : â„) in z.im..w.im, complex.I â€¢ â‡‘(f' (â†‘x + â†‘y * complex.I)) 1 - â‡‘(f' (â†‘x + â†‘y * complex.I)) complex.I
theorem generalized_continued_fraction.of_part_num_eq_one {K : Type u_1} {v : K} {n : â„•} [linear_ordered_field K] [floor_ring K] {a : K} (nth_part_num_eq : (generalized_continued_fraction.of v).partial_numerators.nth n = option.some a) : a = 1
theorem fintype.exists_card_fiber_lt_of_card_lt_nsmul {Î± : Type u} {Î² : Type v} {M : Type w} [decidable_eq Î²] [fintype Î±] [fintype Î²] (f : Î± â†’ Î²) {b : M} [linear_ordered_comm_ring M] (hb : â†‘(fintype.card Î±) < fintype.card Î² â€¢ b) : âˆƒ (y : Î²), â†‘((finset.filter (Î» (x : Î±), f x = y) finset.univ).card) < b
theorem has_lt.lt.asymm {Î± : Type u} [preorder Î±] {a b : Î±} (h : a < b) : Â¬b < a
theorem lp.has_sum_single {Î± : Type u_1} {E : Î± â†’ Type u_2} {p : ennreal} [Î  (i : Î±), normed_group (E i)] [decidable_eq Î±] [fact (1 â‰¤ p)] (hp : p â‰  âŠ¤) (f : â†¥(lp E p)) : has_sum (Î» (i : Î±), lp.single p i (â‡‘f i)) f
theorem add_commute.is_of_fin_order_add {G : Type u} {y : G} [add_monoid G] {x : G} (h : add_commute x y) (hx : is_of_fin_add_order x) (hy : is_of_fin_add_order y) : is_of_fin_add_order (x + y)
theorem polynomial.chebyshev.T_complex_cos (Î¸ : â„‚) (n : â„•) : polynomial.eval (complex.cos Î¸) (polynomial.chebyshev.T â„‚ n) = complex.cos (â†‘n * Î¸)
theorem basis.orientation_comp_linear_equiv_eq_iff_det_pos {R : Type u_1} [linear_ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {Î¹ : Type u_3} [decidable_eq Î¹] [fintype Î¹] (e : basis Î¹ R M) (f : M â‰ƒâ‚—[R] M) : (e.map f).orientation = e.orientation â†” 0 < â‡‘linear_map.det â†‘f
theorem polynomial.bernoulli_generating_function {A : Type u_1} [comm_ring A] [algebra â„š A] (t : A) : power_series.mk (Î» (n : â„•), â‡‘(polynomial.aeval t) ((1 / â†‘(n.factorial)) â€¢ polynomial.bernoulli n)) * (power_series.exp A - 1) = power_series.X * â‡‘(power_series.rescale t) (power_series.exp A)
theorem is_cyclotomic_extension.rat.cyclotomic_ring_is_integral_closure_of_prime_pow {p : â„•+} {k : â„•} [hp : fact (nat.prime â†‘p)] : is_integral_closure (cyclotomic_ring (p ^ k) â„¤ â„š) â„¤ (cyclotomic_field (p ^ k) â„š)
theorem derangements.equiv.remove_none.fiber_some {Î± : Type u_1} [decidable_eq Î±] (a : Î±) : derangements.equiv.remove_none.fiber (option.some a) = {f : equiv.perm Î± | function.fixed_points â‡‘f âŠ† {a}}
theorem ring.direct_limit.exists_of {Î¹ : Type v} [preorder Î¹] {G : Î¹ â†’ Type w} [Î  (i : Î¹), comm_ring (G i)] {f : Î  (i j : Î¹), i â‰¤ j â†’ G i â†’ G j} [nonempty Î¹] [is_directed Î¹ has_le.le] (z : ring.direct_limit G f) : âˆƒ (i : Î¹) (x : G i), â‡‘(ring.direct_limit.of G f i) x = z
theorem add_subsemigroup.ext {M : Type u_1} [has_add M] {S T : add_subsemigroup M} (h : âˆ€ (x : M), x âˆˆ S â†” x âˆˆ T) : S = T
theorem has_dvd.dvd.pow {M : Type u} [monoid M] {x y : M} (hxy : x âˆ£ y) {n : â„•} (hn : n â‰  0) : x âˆ£ y ^ n
theorem antilipschitz_with.le_mul_dist {Î± : Type u_1} {Î² : Type u_2} [pseudo_metric_space Î±] [pseudo_metric_space Î²] {K : nnreal} {f : Î± â†’ Î²} : antilipschitz_with K f â†’ âˆ€ (x y : Î±), has_dist.dist x y â‰¤ â†‘K * has_dist.dist (f x) (f y)
theorem exists_Union_ball_eq_radius_pos_lt {Î± : Type u} {Î¹ : Type v} [metric_space Î±] [proper_space Î±] {c : Î¹ â†’ Î±} {r : Î¹ â†’ â„} (hr : âˆ€ (i : Î¹), 0 < r i) (uf : âˆ€ (x : Î±), {i : Î¹ | x âˆˆ metric.ball (c i) (r i)}.finite) (uU : (â‹ƒ (i : Î¹), metric.ball (c i) (r i)) = set.univ) : âˆƒ (r' : Î¹ â†’ â„), (â‹ƒ (i : Î¹), metric.ball (c i) (r' i)) = set.univ âˆ§ âˆ€ (i : Î¹), r' i âˆˆ set.Ioo 0 (r i)
theorem has_mfderiv_at.has_fderiv_at {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {E' : Type u_3} [normed_group E'] [normed_space ğ•œ E'] {f : E â†’ E'} {x : E} {f' : tangent_space (model_with_corners_self ğ•œ E) x â†’L[ğ•œ] tangent_space (model_with_corners_self ğ•œ E') (f x)} : has_mfderiv_at (model_with_corners_self ğ•œ E) (model_with_corners_self ğ•œ E') f x f' â†’ has_fderiv_at f f' x
theorem is_torsion_free.add_subgroup {G : Type u_1} [add_group G] (tG : add_monoid.is_torsion_free G) (H : add_subgroup G) : add_monoid.is_torsion_free â†¥H
theorem metric.inf_dist_le_inf_dist_add_dist {Î± : Type u} [pseudo_metric_space Î±] {s : set Î±} {x y : Î±} : metric.inf_dist x s â‰¤ metric.inf_dist y s + has_dist.dist x y
theorem add_submonoid.localization_map.map_comp_map {M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {N : Type u_2} [add_comm_monoid N] {P : Type u_3} [add_comm_monoid P] (f : S.localization_map N) {g : M â†’+ P} {T : add_submonoid P} (hy : âˆ€ (y : â†¥S), â‡‘g â†‘y âˆˆ T) {Q : Type u_4} [add_comm_monoid Q] {k : T.localization_map Q} {A : Type u_5} [add_comm_monoid A] {U : add_submonoid A} {R : Type u_6} [add_comm_monoid R] (j : U.localization_map R) {l : P â†’+ A} (hl : âˆ€ (w : â†¥T), â‡‘l â†‘w âˆˆ U) : (k.map hl j).comp (f.map hy k) = f.map _ j
theorem has_lt.lt.eq_top {Î± : Type u_1} [preorder Î±] [bounded_order Î±] [is_simple_order Î±] {a b : Î±} (h : a < b) : b = âŠ¤
theorem map_lt_line_map_iff_slope_lt_slope {k : Type u_1} {E : Type u_2} [linear_ordered_field k] [ordered_add_comm_group E] [module k E] [ordered_smul k E] {f : k â†’ E} {a b r : k} (hab : a < b) (hâ‚€ : 0 < r) (hâ‚ : r < 1) : f (â‡‘(affine_map.line_map a b) r) < â‡‘(affine_map.line_map (f a) (f b)) r â†” slope f a (â‡‘(affine_map.line_map a b) r) < slope f (â‡‘(affine_map.line_map a b) r) b
theorem minpoly.gcd_domain_eq_field_fractions {A : Type u_1} {R : Type u_2} (K : Type u_3) [comm_ring A] [is_domain A] [normalized_gcd_monoid A] [field K] [comm_ring R] [is_domain R] [algebra A K] [is_fraction_ring A K] [algebra K R] [algebra A R] [is_scalar_tower A K R] {x : R} (hx : is_integral A x) : minpoly K x = polynomial.map (algebra_map A K) (minpoly A x)
theorem is_smul_regular.of_mul_eq_one {R : Type u_1} {M : Type u_3} {a b : R} [monoid R] [mul_action R M] (h : a * b = 1) : is_smul_regular M b
theorem cont_diff_at.fst' {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {G : Type u_4} [normed_group G] [normed_space ğ•œ G] {n : with_top â„•} {f : E â†’ G} {x : E} {y : F} (hf : cont_diff_at ğ•œ n f x) : cont_diff_at ğ•œ n (Î» (x : E Ã— F), f x.fst) (x, y)
theorem cont_diff.sub {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {n : with_top â„•} {f g : E â†’ F} (hf : cont_diff ğ•œ n f) (hg : cont_diff ğ•œ n g) : cont_diff ğ•œ n (Î» (x : E), f x - g x)
theorem measure_theory.signed_measure.exists_compl_positive_negative {Î± : Type u_1} [measurable_space Î±] (s : measure_theory.signed_measure Î±) : âˆƒ (i : set Î±), measurable_set i âˆ§ 0.restrict i â‰¤ measure_theory.vector_measure.restrict s i âˆ§ measure_theory.vector_measure.restrict s iá¶œ â‰¤ 0.restrict iá¶œ
theorem metric.diam_le_of_forall_dist_le {Î± : Type u} [pseudo_metric_space Î±] {s : set Î±} {C : â„} (hâ‚€ : 0 â‰¤ C) (h : âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (y : Î±), y âˆˆ s â†’ has_dist.dist x y â‰¤ C) : metric.diam s â‰¤ C
theorem cont_diff_at.prod {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {G : Type u_4} [normed_group G] [normed_space ğ•œ G] {x : E} {n : with_top â„•} {f : E â†’ F} {g : E â†’ G} (hf : cont_diff_at ğ•œ n f x) (hg : cont_diff_at ğ•œ n g x) : cont_diff_at ğ•œ n (Î» (x : E), (f x, g x)) x
theorem is_noetherian.iff_fg {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] : is_noetherian K V â†” module.finite K V
theorem module.free.rank_matrix'' (R : Type u) [ring R] [strong_rank_condition R] (m n : Type u) [fintype m] [fintype n] : module.rank R (matrix m n R) = cardinal.mk m * cardinal.mk n
theorem has_le.le.lt_of_ne {Î± : Type u} [partial_order Î±] {a b : Î±} : a â‰¤ b â†’ a â‰  b â†’ a < b
theorem mul_ne_zero_comm {Mâ‚€ : Type u_1} [mul_zero_class Mâ‚€] [no_zero_divisors Mâ‚€] {a b : Mâ‚€} : a * b â‰  0 â†” b * a â‰  0
theorem trans_gen_of_succ_of_lt {Î± : Type u_1} [partial_order Î±] [succ_order Î±] [is_succ_archimedean Î±] (r : Î± â†’ Î± â†’ Prop) {n m : Î±} (h : âˆ€ (i : Î±), i âˆˆ set.Ico n m â†’ r i (order.succ i)) (hnm : n < m) : relation.trans_gen r n m
theorem is_noetherian_ring_iff_ideal_fg (R : Type u_1) [semiring R] : is_noetherian_ring R â†” âˆ€ (I : ideal R), I.fg
theorem is_integer_of_is_root_of_monic {A : Type u_1} {K : Type u_2} [comm_ring A] [is_domain A] [unique_factorization_monoid A] [field K] [algebra A K] [is_fraction_ring A K] {p : polynomial A} (hp : p.monic) {r : K} (hr : â‡‘(polynomial.aeval r) p = 0) : is_localization.is_integer A r
theorem orthogonal_projection_singleton (ğ•œ : Type u_1) {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {v : E} (w : E) : â†‘(â‡‘(orthogonal_projection (submodule.span ğ•œ {v})) w) = (has_inner.inner v w / â†‘âˆ¥vâˆ¥ ^ 2) â€¢ v
theorem monotone.continuous_of_surjective {Î± : Type u_1} {Î² : Type u_2} [linear_order Î±] [topological_space Î±] [order_topology Î±] [linear_order Î²] [topological_space Î²] [order_topology Î²] [densely_ordered Î²] {f : Î± â†’ Î²} (h_mono : monotone f) (h_surj : function.surjective f) : continuous f
theorem set.finite_or_infinite {Î± : Type u} {s : set Î±} : s.finite âˆ¨ s.infinite
theorem submodule.complete_of_finite_dimensional {ğ•œ : Type u} [nondiscrete_normed_field ğ•œ] {E : Type v} [normed_group E] [normed_space ğ•œ E] [complete_space ğ•œ] (s : submodule ğ•œ E) [finite_dimensional ğ•œ â†¥s] : is_complete â†‘s
theorem right.add_pos_of_nonneg_of_pos {Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±} (ha : 0 â‰¤ a) (hb : 0 < b) : 0 < a + b
theorem measure_theory.exists_nonempty_inter_of_measure_univ_lt_tsum_measure {Î± : Type u_1} {Î¹ : Type u_5} {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) {s : Î¹ â†’ set Î±} (hs : âˆ€ (i : Î¹), measurable_set (s i)) (H : â‡‘Î¼ set.univ < âˆ‘' (i : Î¹), â‡‘Î¼ (s i)) : âˆƒ (i j : Î¹) (h : i â‰  j), (s i âˆ© s j).nonempty
theorem normed_space.sphere_nonempty {E : Type u_2} [normed_group E] [normed_space â„ E] [nontrivial E] {x : E} {r : â„} : (metric.sphere x r).nonempty â†” 0 â‰¤ r
theorem finset.sum_le_sum {Î¹ : Type u_1} {N : Type u_5} [ordered_add_comm_monoid N] {f g : Î¹ â†’ N} {s : finset Î¹} (h : âˆ€ (i : Î¹), i âˆˆ s â†’ f i â‰¤ g i) : s.sum (Î» (i : Î¹), f i) â‰¤ s.sum (Î» (i : Î¹), g i)
theorem orthonormal.inner_sum {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {Î¹ : Type u_4} {v : Î¹ â†’ E} (hv : orthonormal ğ•œ v) (lâ‚ lâ‚‚ : Î¹ â†’ ğ•œ) (s : finset Î¹) : has_inner.inner (s.sum (Î» (i : Î¹), lâ‚ i â€¢ v i)) (s.sum (Î» (i : Î¹), lâ‚‚ i â€¢ v i)) = s.sum (Î» (i : Î¹), â‡‘(star_ring_end ğ•œ) (lâ‚ i) * lâ‚‚ i)
theorem vsub_eq_sub {G : Type u_1} [add_group G] (g1 g2 : G) : g1 -áµ¥ g2 = g1 - g2
theorem euclidean_geometry.cospherical_def {P : Type u_2} [metric_space P] (ps : set P) : euclidean_geometry.cospherical ps â†” âˆƒ (center : P) (radius : â„), âˆ€ (p : P), p âˆˆ ps â†’ has_dist.dist p center = radius
theorem smooth_bump_function.nhds_within_range_basis {E : Type uE} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] {H : Type uH} [topological_space H] {I : model_with_corners â„ E H} {M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {c : M} : (nhds_within (â‡‘(ext_chart_at I c) c) (set.range â‡‘I)).has_basis (Î» (f : smooth_bump_function I c), true) (Î» (f : smooth_bump_function I c), euclidean.closed_ball (â‡‘(ext_chart_at I c) c) f.to_cont_diff_bump.to_cont_diff_bump_of_inner.R âˆ© set.range â‡‘I)
theorem lower_semicontinuous_on.add {Î± : Type u_1} [topological_space Î±] {s : set Î±} {Î³ : Type u_4} [linear_ordered_add_comm_monoid Î³] [topological_space Î³] [order_topology Î³] [has_continuous_add Î³] {f g : Î± â†’ Î³} (hf : lower_semicontinuous_on f s) (hg : lower_semicontinuous_on g s) : lower_semicontinuous_on (Î» (z : Î±), f z + g z) s
theorem minpoly.degree_le_of_ne_zero (A : Type u_1) {B : Type u_2} [field A] [ring B] [algebra A B] (x : B) {p : polynomial A} (pnz : p â‰  0) (hp : â‡‘(polynomial.aeval x) p = 0) : (minpoly A x).degree â‰¤ p.degree
theorem isometry.continuous {Î± : Type u} {Î² : Type v} [pseudo_emetric_space Î±] [pseudo_emetric_space Î²] {f : Î± â†’ Î²} (hf : isometry f) : continuous f
theorem linear_map.ext_ring {R : Type u_1} {S : Type u_6} {Mâ‚ƒ : Type u_12} [semiring R] [semiring S] [add_comm_monoid Mâ‚ƒ] [module S Mâ‚ƒ] {Ïƒ : R â†’+* S} {f g : R â†’â‚›â‚—[Ïƒ] Mâ‚ƒ} (h : â‡‘f 1 = â‡‘g 1) : f = g
theorem finite_of_fin_dim_affine_independent (k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] [finite_dimensional k V] {s : set P} (hi : affine_independent k coe) : s.finite
theorem zero_hom.coe_inj {M : Type u_3} {N : Type u_4} [has_zero M] [has_zero N] â¦ƒf g : zero_hom M Nâ¦„ (h : â‡‘f = â‡‘g) : f = g
theorem simple_graph.walk.edges_subset_edge_set {V : Type u} {G : simple_graph V} {u v : V} (p : G.walk u v) â¦ƒe : sym2 Vâ¦„ (h : e âˆˆ p.edges) : e âˆˆ G.edge_set
theorem measure_theory.measure.ext_of_Ico' {Î± : Type u_1} [topological_space Î±] {m : measurable_space Î±} [topological_space.second_countable_topology Î±] [linear_order Î±] [order_topology Î±] [borel_space Î±] [no_max_order Î±] (Î¼ Î½ : measure_theory.measure Î±) (hÎ¼ : âˆ€ â¦ƒa b : Î±â¦„, a < b â†’ â‡‘Î¼ (set.Ico a b) â‰  âŠ¤) (h : âˆ€ â¦ƒa b : Î±â¦„, a < b â†’ â‡‘Î¼ (set.Ico a b) = â‡‘Î½ (set.Ico a b)) : Î¼ = Î½
theorem is_primitive_root.nth_roots_nodup {R : Type u_5} [comm_ring R] [is_domain R] {Î¶ : R} {n : â„•} (h : is_primitive_root Î¶ n) : (polynomial.nth_roots n 1).nodup
theorem summable_of_norm_bounded_eventually {Î¹ : Type u_1} {E : Type u_3} [semi_normed_group E] [complete_space E] {f : Î¹ â†’ E} (g : Î¹ â†’ â„) (hg : summable g) (h : âˆ€á¶  (i : Î¹) in filter.cofinite, âˆ¥f iâˆ¥ â‰¤ g i) : summable f
theorem le_add_of_sub_left_le {Î± : Type u} [add_comm_group Î±] [has_le Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b c : Î±} : a - b â‰¤ c â†’ a â‰¤ b + c
theorem metric.Hausdorff_dist_self_zero {Î± : Type u} [pseudo_metric_space Î±] {s : set Î±} : metric.Hausdorff_dist s s = 0
theorem submodule.torsion_by_set_is_internal {R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] {Î¹ : Type u_3} [decidable_eq Î¹] {S : finset Î¹} {p : Î¹ â†’ ideal R} (hp : â†‘S.pairwise (Î» (i j : Î¹), p i âŠ” p j = âŠ¤)) (hM : module.is_torsion_by_set R M (â†‘â¨… (i : Î¹) (H : i âˆˆ S), p i)) : direct_sum.is_internal (Î» (i : â†¥S), submodule.torsion_by_set R M â†‘(p â†‘i))
theorem subfield.subset_closure {K : Type u} [field K] {s : set K} : s âŠ† â†‘(subfield.closure s)
theorem direct_sum.coe_ring_hom_of {Î¹ : Type u_1} {R : Type u_4} [decidable_eq Î¹] [add_monoid Î¹] [semiring R] (A : Î¹ â†’ add_submonoid R) [set_like.graded_monoid A] (i : Î¹) (x : â†¥(A i)) : â‡‘(direct_sum.coe_ring_hom A) (â‡‘(direct_sum.of (Î» (i : Î¹), â†¥(A i)) i) x) = â†‘x
theorem ordinal.unbounded_of_unbounded_Union {Î± Î² : Type u} (r : Î± â†’ Î± â†’ Prop) [wo : is_well_order Î± r] (s : Î² â†’ set Î±) (hâ‚ : set.unbounded r (â‹ƒ (x : Î²), s x)) (hâ‚‚ : cardinal.mk Î² < strict_order.cof r) : âˆƒ (x : Î²), set.unbounded r (s x)
theorem smooth_bump_function.nhds_basis_tsupport {E : Type uE} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] {H : Type uH} [topological_space H] (I : model_with_corners â„ E H) {M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] (c : M) [t2_space M] : (nhds c).has_basis (Î» (f : smooth_bump_function I c), true) (Î» (f : smooth_bump_function I c), tsupport â‡‘f)
theorem category_theory.limits.has_limit_of_iso {J : Type uâ‚} [category_theory.category J] {C : Type u} [category_theory.category C] {F G : J â¥¤ C} [category_theory.limits.has_limit F] (Î± : F â‰… G) : category_theory.limits.has_limit G
theorem euclidean_geometry.reflection_apply {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] (s : affine_subspace â„ P) [nonempty â†¥s] [complete_space â†¥(s.direction)] (p : P) : â‡‘(euclidean_geometry.reflection s) p = â†‘(â‡‘(euclidean_geometry.orthogonal_projection s) p) -áµ¥ p +áµ¥ â†‘(â‡‘(euclidean_geometry.orthogonal_projection s) p)
theorem fin.succ_above_below {n : â„•} (p : fin (n + 1)) (i : fin n) (h : â‡‘fin.cast_succ i < p) : â‡‘(p.succ_above) i = â‡‘fin.cast_succ i
theorem add_subgroup.add_normal {G : Type u_1} [add_group G] (H N : add_subgroup G) [N.normal] : â†‘(H âŠ” N) = â†‘H + â†‘N
theorem finsum_mem_sUnion {Î± : Type u_1} {M : Type u_5} [add_comm_monoid M] {f : Î± â†’ M} {t : set (set Î±)} (h : t.pairwise_disjoint id) (htâ‚€ : t.finite) (htâ‚ : âˆ€ (x : set Î±), x âˆˆ t â†’ x.finite) : finsum (Î» (a : Î±), finsum (Î» (H : a âˆˆ â‹ƒâ‚€t), f a)) = finsum (Î» (s : set Î±), finsum (Î» (H : s âˆˆ t), finsum (Î» (a : Î±), finsum (Î» (H : a âˆˆ s), f a))))
theorem summable.abs {Î± : Type u_1} {Î² : Type u_2} [linear_ordered_add_comm_group Î²] [uniform_space Î²] [uniform_add_group Î²] [complete_space Î²] {f : Î± â†’ Î²} : summable f â†’ summable (Î» (x : Î±), |f x|)
theorem orientation.rotation_trans {V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) (Î¸â‚ Î¸â‚‚ : real.angle) : (o.rotation Î¸â‚).trans (o.rotation Î¸â‚‚) = o.rotation (Î¸â‚‚ + Î¸â‚)
theorem asymptotics.is_O_iff_eventually_is_O_with {Î± : Type u_1} {E : Type u_3} {F' : Type u_7} [has_norm E] [semi_normed_group F'] {f : Î± â†’ E} {g' : Î± â†’ F'} {l : filter Î±} : f =O[l] g' â†” âˆ€á¶  (c : â„) in filter.at_top, asymptotics.is_O_with c l f g'
theorem not_bdd_above_iff {Î± : Type u_1} [linear_order Î±] {s : set Î±} : Â¬bdd_above s â†” âˆ€ (x : Î±), âˆƒ (y : Î±) (H : y âˆˆ s), x < y
theorem matrix.inv_eq_right_inv {n : Type u'} {Î± : Type v} [fintype n] [decidable_eq n] [comm_ring Î±] {A B : matrix n n Î±} (h : A.mul B = 1) : Aâ»Â¹ = B
theorem Top.sheaf.exists_unique_gluing' {C : Type u} [category_theory.category C] [category_theory.concrete_category C] [category_theory.limits.has_limits C] [category_theory.reflects_isomorphisms (category_theory.concrete_category.forget C)] [category_theory.limits.preserves_limits (category_theory.concrete_category.forget C)] {X : Top} (F : Top.sheaf C X) {Î¹ : Type v} (U : Î¹ â†’ topological_space.opens â†¥X) (V : topological_space.opens â†¥X) (iUV : Î  (i : Î¹), U i âŸ¶ V) (hcover : V â‰¤ supr U) (sf : Î  (i : Î¹), â†¥(F.val.obj (opposite.op (U i)))) (h : F.val.is_compatible U sf) : âˆƒ! (s : â†¥(F.val.obj (opposite.op V))), âˆ€ (i : Î¹), â‡‘(F.val.map (iUV i).op) s = sf i
theorem nat.factorial_mul_asc_factorial (n k : â„•) : n.factorial * n.asc_factorial k = (n + k).factorial
theorem measurable_equiv.measurable_embedding {Î± : Type u_1} {Î² : Type u_2} [measurable_space Î±] [measurable_space Î²] (e : Î± â‰ƒáµ Î²) : measurable_embedding â‡‘e
theorem real_inner_smul_self_right {F : Type u_3} [inner_product_space â„ F] (x : F) (r : â„) : has_inner.inner x (r â€¢ x) = r * (âˆ¥xâˆ¥ * âˆ¥xâˆ¥)
theorem orthonormal.oangle_rotation_left {V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) {x y : V} (hx : x â‰  0) (hy : y â‰  0) (Î¸ : real.angle) : hb.oangle (â‡‘(hb.rotation Î¸) x) y = hb.oangle x y - Î¸
theorem Compactum_to_CompHaus.ess_surj  : category_theory.ess_surj Compactum_to_CompHaus
theorem concave_on_open_of_deriv2_nonpos {D : set â„} (hD : convex â„ D) (hDâ‚‚ : is_open D) {f : â„ â†’ â„} (hf' : differentiable_on â„ f D) (hf'' : differentiable_on â„ (deriv f) D) (hf''_nonpos : âˆ€ (x : â„), x âˆˆ D â†’ deriv^[2] f x â‰¤ 0) : concave_on â„ D f
theorem is_alg_closed.splits_domain {k : Type u_1} {K : Type u_2} [field k] [is_alg_closed k] [field K] {f : k â†’+* K} (p : polynomial k) : polynomial.splits f p
theorem affine_independent.vector_span_eq_top_of_card_eq_finrank_add_one {k : Type u_1} {V : Type u_2} {P : Type u_3} {Î¹ : Type u_4} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] [finite_dimensional k V] [fintype Î¹] {p : Î¹ â†’ P} (hi : affine_independent k p) (hc : fintype.card Î¹ = finite_dimensional.finrank k V + 1) : vector_span k (set.range p) = âŠ¤
theorem category_theory.abelian.pseudoelement.zero_apply {C : Type u} [category_theory.category C] [category_theory.abelian C] {P : C} (Q : C) (a : â†¥P) : â‡‘0 a = 0
theorem banach_steinhaus_supr_nnnorm {E : Type u_1} {F : Type u_2} {ğ•œ : Type u_3} {ğ•œâ‚‚ : Type u_4} [semi_normed_group E] [semi_normed_group F] [nondiscrete_normed_field ğ•œ] [nondiscrete_normed_field ğ•œâ‚‚] [normed_space ğ•œ E] [normed_space ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} [ring_hom_isometric Ïƒâ‚â‚‚] {Î¹ : Type u_5} [complete_space E] {g : Î¹ â†’ (E â†’SL[Ïƒâ‚â‚‚] F)} (h : âˆ€ (x : E), (â¨† (i : Î¹), â†‘âˆ¥â‡‘(g i) xâˆ¥â‚Š) < âŠ¤) : (â¨† (i : Î¹), â†‘âˆ¥g iâˆ¥â‚Š) < âŠ¤
theorem add_subgroup.mem_closure_singleton {G : Type u_1} [add_group G] {x y : G} : y âˆˆ add_subgroup.closure {x} â†” âˆƒ (n : â„¤), n â€¢ x = y
theorem add_subgroup.add_mem {G : Type u_1} [add_group G] (H : add_subgroup G) {x y : G} : x âˆˆ H â†’ y âˆˆ H â†’ x + y âˆˆ H
theorem interval_integral.measure_integral_sub_integral_sub_linear_is_o_of_tendsto_ae_right {Î¹ : Type u_1} {E : Type u_3} [normed_group E] [complete_space E] [normed_space â„ E] {f : â„ â†’ E} {a b : â„} {c : E} {lb lb' : filter â„} {lt : filter Î¹} {Î¼ : measure_theory.measure â„} {u v : Î¹ â†’ â„} [interval_integral.FTC_filter b lb lb'] [measure_theory.is_locally_finite_measure Î¼] (hab : interval_integrable f Î¼ a b) (hmeas : strongly_measurable_at_filter f lb' Î¼) (hf : filter.tendsto f (lb' âŠ“ Î¼.ae) (nhds c)) (hu : filter.tendsto u lt lb) (hv : filter.tendsto v lt lb) : (Î» (t : Î¹), âˆ« (x : â„) in a..v t, f x âˆ‚Î¼ - âˆ« (x : â„) in a..u t, f x âˆ‚Î¼ - âˆ« (x : â„) in u t..v t, c âˆ‚Î¼) =o[lt] Î» (t : Î¹), âˆ« (x : â„) in u t..v t, 1 âˆ‚Î¼
theorem con.coe_one {M : Type u_1} [mul_one_class M] {c : con M} : â†‘1 = 1
theorem is_regular.subsingleton {R : Type u_1} [mul_zero_class R] (h : is_regular 0) : subsingleton R
theorem category_theory.limits.has_limit_of_equalizer_and_product {C : Type u} [category_theory.category C] {J : Type v} [category_theory.small_category J] (F : J â¥¤ C) [category_theory.limits.has_limit (category_theory.discrete.functor F.obj)] [category_theory.limits.has_limit (category_theory.discrete.functor (Î» (f : Î£ (p : J Ã— J), p.fst âŸ¶ p.snd), F.obj f.fst.snd))] [category_theory.limits.has_equalizers C] : category_theory.limits.has_limit F
theorem nilpotency_class_pi {Î· : Type u_2} [fintype Î·] {Gs : Î· â†’ Type u_3} [Î  (i : Î·), group (Gs i)] [âˆ€ (i : Î·), group.is_nilpotent (Gs i)] : group.nilpotency_class (Î  (i : Î·), Gs i) = finset.univ.sup (Î» (i : Î·), group.nilpotency_class (Gs i))
theorem inv_lt_one' {Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a : Î±} : aâ»Â¹ < 1 â†” 1 < a
theorem nat.totient_prime_pow_succ {p : â„•} (hp : nat.prime p) (n : â„•) : (p ^ (n + 1)).totient = p ^ n * (p - 1)
theorem edist_le_Ico_sum_of_edist_le {Î± : Type u} [pseudo_emetric_space Î±] {f : â„• â†’ Î±} {m n : â„•} (hmn : m â‰¤ n) {d : â„• â†’ ennreal} (hd : âˆ€ {k : â„•}, m â‰¤ k â†’ k < n â†’ has_edist.edist (f k) (f (k + 1)) â‰¤ d k) : has_edist.edist (f m) (f n) â‰¤ (finset.Ico m n).sum (Î» (i : â„•), d i)
theorem ring_equiv.map_one {R : Type u_4} {S : Type u_5} [non_assoc_semiring R] [non_assoc_semiring S] (f : R â‰ƒ+* S) : â‡‘f 1 = 1
theorem euclidean_geometry.circumradius_eq_of_cospherical {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {ps : set P} {n : â„•} [finite_dimensional â„ V] (hd : finite_dimensional.finrank â„ V = n) (hc : euclidean_geometry.cospherical ps) {sxâ‚ sxâ‚‚ : affine.simplex â„ P n} (hsxâ‚ : set.range sxâ‚.points âŠ† ps) (hsxâ‚‚ : set.range sxâ‚‚.points âŠ† ps) : sxâ‚.circumradius = sxâ‚‚.circumradius
theorem list.nat.antidiagonal_zero  : list.nat.antidiagonal 0 = [(0, 0)]
theorem mul_lt_one_of_lt_of_le {Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a b : Î±} (ha : a < 1) (hb : b â‰¤ 1) : a * b < 1
theorem ideal.map_comap_of_equiv {R : Type u} {S : Type v} [ring R] [ring S] (I : ideal R) (f : R â‰ƒ+* S) : ideal.map â†‘f I = ideal.comap â†‘(f.symm) I
theorem category_theory.unit_obj_eq_map_unit {C : Type uâ‚} {D : Type uâ‚‚} [category_theory.category C] [category_theory.category D] {i : D â¥¤ C} [category_theory.reflective i] (X : C) : (category_theory.adjunction.of_right_adjoint i).unit.app (i.obj ((category_theory.left_adjoint i).obj X)) = i.map ((category_theory.left_adjoint i).map ((category_theory.adjunction.of_right_adjoint i).unit.app X))
theorem multiset.nat.antidiagonal_zero  : multiset.nat.antidiagonal 0 = {(0, 0)}
theorem is_compact.binary_compact_cover {Î± : Type u} [topological_space Î±] [t2_space Î±] {K U V : set Î±} (hK : is_compact K) (hU : is_open U) (hV : is_open V) (h2K : K âŠ† U âˆª V) : âˆƒ (Kâ‚ Kâ‚‚ : set Î±), is_compact Kâ‚ âˆ§ is_compact Kâ‚‚ âˆ§ Kâ‚ âŠ† U âˆ§ Kâ‚‚ âŠ† V âˆ§ K = Kâ‚ âˆª Kâ‚‚
theorem is_integral_trans {R : Type u_1} {A : Type u_2} {B : Type u_3} [comm_ring R] [comm_ring A] [comm_ring B] [algebra A B] [algebra R B] [algebra R A] [is_scalar_tower R A B] (A_int : algebra.is_integral R A) (x : B) (hx : is_integral A x) : is_integral R x
theorem pgame.lt_def {x y : pgame} (ox : x.numeric) (oy : y.numeric) : x < y â†” (âˆƒ (i : y.left_moves), (âˆ€ (i' : x.left_moves), x.move_left i' < y.move_left i) âˆ§ âˆ€ (j : (y.move_left i).right_moves), x < (y.move_left i).move_right j) âˆ¨ âˆƒ (j : x.right_moves), (âˆ€ (i : (x.move_right j).left_moves), (x.move_right j).move_left i < y) âˆ§ âˆ€ (j' : y.right_moves), x.move_right j < y.move_right j'
theorem strict_concave_on.translate_right {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [ordered_semiring ğ•œ] [add_cancel_comm_monoid E] [ordered_add_comm_monoid Î²] [module ğ•œ E] [has_scalar ğ•œ Î²] {s : set E} {f : E â†’ Î²} (hf : strict_concave_on ğ•œ s f) (c : E) : strict_concave_on ğ•œ ((Î» (z : E), c + z) â»Â¹' s) (f âˆ˜ Î» (z : E), c + z)
theorem uniform_group.uniform_continuous_iff_open_ker {Î± : Type u_1} {Î² : Type u_2} [uniform_space Î±] [group Î±] [uniform_group Î±] {hom : Type u_3} [uniform_space Î²] [discrete_topology Î²] [group Î²] [uniform_group Î²] [monoid_hom_class hom Î± Î²] {f : hom} : uniform_continuous â‡‘f â†” is_open â†‘(â†‘f.ker)
theorem quotient.ind' {Î± : Sort u_1} {sâ‚ : setoid Î±} {p : quotient sâ‚ â†’ Prop} (h : âˆ€ (a : Î±), p (quotient.mk' a)) (q : quotient sâ‚) : p q
theorem complex.norm_le_of_forall_mem_frontier_norm_le {E : Type u} [normed_group E] [normed_space â„‚ E] {F : Type v} [normed_group F] [normed_space â„‚ F] [nontrivial E] {f : E â†’ F} {U : set E} (hU : metric.bounded U) (hd : diff_cont_on_cl â„‚ f U) {C : â„} (hC : âˆ€ (z : E), z âˆˆ frontier U â†’ âˆ¥f zâˆ¥ â‰¤ C) {z : E} (hz : z âˆˆ closure U) : âˆ¥f zâˆ¥ â‰¤ C
theorem category_theory.equivalence.ess_surj_of_equivalence {C : Type uâ‚} [category_theory.category C] {D : Type uâ‚‚} [category_theory.category D] (F : C â¥¤ D) [category_theory.is_equivalence F] : category_theory.ess_surj F
theorem sub_orthogonal_projection_mem_orthogonal {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {K : submodule ğ•œ E} [complete_space â†¥K] (v : E) : v - â†‘(â‡‘(orthogonal_projection K) v) âˆˆ Ká—®
theorem filter.has_basis.exists_antitone_subbasis {Î± : Type u_1} {Î¹' : Sort u_5} {f : filter Î±} [h : f.is_countably_generated] {p : Î¹' â†’ Prop} {s : Î¹' â†’ set Î±} (hs : f.has_basis p s) : âˆƒ (x : â„• â†’ Î¹'), (âˆ€ (i : â„•), p (x i)) âˆ§ f.has_antitone_basis (Î» (i : â„•), s (x i))
theorem convex_on.translate_left {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [ordered_semiring ğ•œ] [add_comm_monoid E] [ordered_add_comm_monoid Î²] [module ğ•œ E] [has_scalar ğ•œ Î²] {s : set E} {f : E â†’ Î²} (hf : convex_on ğ•œ s f) (c : E) : convex_on ğ•œ ((Î» (z : E), c + z) â»Â¹' s) (f âˆ˜ Î» (z : E), z + c)
theorem unique_diff_within_at.unique_mdiff_within_at {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {s : set E} {x : E} : unique_diff_within_at ğ•œ s x â†’ unique_mdiff_within_at (model_with_corners_self ğ•œ E) s x
theorem category_theory.grothendieck_topology.arrow_trans {C : Type u} [category_theory.category C] {X Y : C} (J : category_theory.grothendieck_topology C) (f : Y âŸ¶ X) (S R : category_theory.sieve X) (h : J.covers S f) : (âˆ€ {Z : C} (g : Z âŸ¶ X), â‡‘S g â†’ J.covers R g) â†’ J.covers R f
theorem continuous_on_clm_apply {ğ•œ : Type u} [nondiscrete_normed_field ğ•œ] {E : Type v} [normed_group E] [normed_space ğ•œ E] {F : Type w} [normed_group F] [normed_space ğ•œ F] [complete_space ğ•œ] {X : Type u_1} [topological_space X] [finite_dimensional ğ•œ E] {f : X â†’ (E â†’L[ğ•œ] F)} {s : set X} : continuous_on f s â†” âˆ€ (y : E), continuous_on (Î» (x : X), â‡‘(f x) y) s
theorem metric.bounded_closed_ball {Î± : Type u} [pseudo_metric_space Î±] {x : Î±} {r : â„} : metric.bounded (metric.closed_ball x r)
theorem pell.eq_pell {a : â„•} (a1 : 1 < a) {x y : â„•} (hp : x * x - d a1 * y * y = 1) : âˆƒ (n : â„•), x = pell.xn a1 n âˆ§ y = pell.yn a1 n
theorem well_founded.cut_expand {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} (hr : well_founded r) : well_founded (relation.cut_expand r)
theorem convex_image_has_deriv_at {f f' : â„ â†’ â„} {s : set â„} (hs : convex â„ s) (hf : âˆ€ (x : â„), x âˆˆ s â†’ has_deriv_at f (f' x) x) : convex â„ (f' '' s)
theorem normed_group_hom.op_norm_zero {Vâ‚ : Type u_2} {Vâ‚‚ : Type u_3} [semi_normed_group Vâ‚] [semi_normed_group Vâ‚‚] : âˆ¥0âˆ¥ = 0
theorem is_group_hom.injective_iff {Î± : Type u} {Î² : Type v} [group Î±] [group Î²] {f : Î± â†’ Î²} (hf : is_group_hom f) : function.injective f â†” âˆ€ (a : Î±), f a = 1 â†’ a = 1
theorem matrix.det_from_blocks_zeroâ‚‚â‚ {m : Type u_1} {n : Type u_2} [decidable_eq n] [fintype n] [decidable_eq m] [fintype m] {R : Type v} [comm_ring R] (A : matrix m m R) (B : matrix m n R) (D : matrix n n R) : (matrix.from_blocks A B 0 D).det = A.det * D.det
theorem subgroup.commutator_pi_pi_le {Î· : Type u_1} {Gs : Î· â†’ Type u_2} [Î  (i : Î·), group (Gs i)] (H K : Î  (i : Î·), subgroup (Gs i)) : â…subgroup.pi set.univ H,subgroup.pi set.univ Kâ† â‰¤ subgroup.pi set.univ (Î» (i : Î·), â…H i,K iâ†)
theorem setoid.classes_eqv_classes {Î± : Type u_1} {r : setoid Î±} (a : Î±) : âˆƒ! (b : set Î±) (H : b âˆˆ r.classes), a âˆˆ b
theorem local_homeomorph.image_open_of_open' {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] (e : local_homeomorph Î± Î²) {s : set Î±} (hs : is_open s) : is_open (â‡‘e '' (e.to_local_equiv.source âˆ© s))
theorem strict_mono.strict_mono_iterate_of_lt_map {Î± : Type u_1} [preorder Î±] {f : Î± â†’ Î±} {x : Î±} (hf : strict_mono f) (hx : x < f x) : strict_mono (Î» (n : â„•), f^[n] x)
theorem polynomial.root_multiplicity_X_sub_C_pow {R : Type u} [comm_ring R] [is_domain R] (a : R) (n : â„•) : polynomial.root_multiplicity a ((polynomial.X - â‡‘polynomial.C a) ^ n) = n
theorem is_const_of_deriv_eq_zero {ğ•œ : Type u_3} {G : Type u_4} [is_R_or_C ğ•œ] [normed_group G] [normed_space ğ•œ G] {f : ğ•œ â†’ G} (hf : differentiable ğ•œ f) (hf' : âˆ€ (x : ğ•œ), deriv f x = 0) (x y : ğ•œ) : f x = f y
theorem metric.Hausdorff_dist_empty {Î± : Type u} [pseudo_metric_space Î±] {s : set Î±} : metric.Hausdorff_dist s âˆ… = 0
theorem filter.limsup_eq_infi_supr {Î± : Type u_1} {Î² : Type u_2} [complete_lattice Î±] {f : filter Î²} {u : Î² â†’ Î±} : f.limsup u = â¨… (s : set Î²) (H : s âˆˆ f), â¨† (a : Î²) (H : a âˆˆ s), u a
theorem measure_theory.measure_preserving.exists_mem_image_mem_of_volume_lt_mul_volume {Î± : Type u_1} [measurable_space Î±] {Î¼ : measure_theory.measure Î±} {f : Î± â†’ Î±} {s : set Î±} (hf : measure_theory.measure_preserving f Î¼ Î¼) (hs : measurable_set s) {n : â„•} (hvol : â‡‘Î¼ set.univ < â†‘n * â‡‘Î¼ s) : âˆƒ (x : Î±) (H : x âˆˆ s) (m : â„•) (H : m âˆˆ set.Ioo 0 n), f^[m] x âˆˆ s
theorem parser.nat_of_done {cb : char_buffer} {n n' val : â„•} (h : parser.nat cb n = parse_result.done n' val) : val = nat.of_digits 10 (list.map (Î» (c : char), c.to_nat - '0'.to_nat) (list.take (n' - n) (list.drop n (buffer.to_list cb))).reverse)
theorem has_fderiv_within_at_iff_has_deriv_within_at {ğ•œ : Type u} [nondiscrete_normed_field ğ•œ] {F : Type v} [normed_group F] [normed_space ğ•œ F] {f : ğ•œ â†’ F} {x : ğ•œ} {s : set ğ•œ} {f' : ğ•œ â†’L[ğ•œ] F} : has_fderiv_within_at f f' s x â†” has_deriv_within_at f (â‡‘f' 1) s x
theorem is_compact.inter_Inter_nonempty {Î± : Type u} [topological_space Î±] {s : set Î±} {Î¹ : Type v} (hs : is_compact s) (Z : Î¹ â†’ set Î±) (hZc : âˆ€ (i : Î¹), is_closed (Z i)) (hsZ : âˆ€ (t : finset Î¹), (s âˆ© â‹‚ (i : Î¹) (H : i âˆˆ t), Z i).nonempty) : (s âˆ© â‹‚ (i : Î¹), Z i).nonempty
theorem submodule.mem_orthogonal' {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] (K : submodule ğ•œ E) (v : E) : v âˆˆ Ká—® â†” âˆ€ (u : E), u âˆˆ K â†’ has_inner.inner v u = 0
theorem ideal.polynomial.quotient_mk_comp_C_is_integral_of_jacobson {R : Type u_1} [comm_ring R] [ideal.is_jacobson R] (P : ideal (polynomial R)) [hP : P.is_maximal] : ((ideal.quotient.mk P).comp polynomial.C).is_integral
theorem interval_integral.integrable_on_deriv_right_of_nonneg {a b : â„} {g' g : â„ â†’ â„} (hab : a â‰¤ b) (hcont : continuous_on g (set.Icc a b)) (hderiv : âˆ€ (x : â„), x âˆˆ set.Ioo a b â†’ has_deriv_within_at g (g' x) (set.Ioi x) x) (g'pos : âˆ€ (x : â„), x âˆˆ set.Ioo a b â†’ 0 â‰¤ g' x) : measure_theory.integrable_on g' (set.Ioc a b) measure_theory.measure_space.volume
theorem affine_map.coe_comp {k : Type u_1} {V1 : Type u_2} {P1 : Type u_3} {V2 : Type u_4} {P2 : Type u_5} {V3 : Type u_6} {P3 : Type u_7} [ring k] [add_comm_group V1] [module k V1] [add_torsor V1 P1] [add_comm_group V2] [module k V2] [add_torsor V2 P2] [add_comm_group V3] [module k V3] [add_torsor V3 P3] (f : P2 â†’áµƒ[k] P3) (g : P1 â†’áµƒ[k] P2) : â‡‘(f.comp g) = â‡‘f âˆ˜ â‡‘g
theorem measure_theory.signed_measure.of_diff_eq_zero_of_symm_diff_eq_zero_negative {Î± : Type u_1} [measurable_space Î±] {s : measure_theory.signed_measure Î±} {u v : set Î±} (hu : measurable_set u) (hv : measurable_set v) (hsu : measure_theory.vector_measure.restrict s u â‰¤ 0.restrict u) (hsv : measure_theory.vector_measure.restrict s v â‰¤ 0.restrict v) (hs : â‡‘s (u âˆ† v) = 0) : â‡‘s (u  v) = 0 âˆ§ â‡‘s (v  u) = 0
theorem geometric_hahn_banach_closed_compact {E : Type u_2} [normed_group E] [normed_space â„ E] {s t : set E} (hsâ‚ : convex â„ s) (hsâ‚‚ : is_closed s) (htâ‚ : convex â„ t) (htâ‚‚ : is_compact t) (disj : disjoint s t) : âˆƒ (f : E â†’L[â„] â„) (u v : â„), (âˆ€ (a : E), a âˆˆ s â†’ â‡‘f a < u) âˆ§ u < v âˆ§ âˆ€ (b : E), b âˆˆ t â†’ v < â‡‘f b
theorem monotone.tendsto_at_top_finset {Î± : Type u_3} {Î² : Type u_4} [preorder Î²] {f : Î² â†’ finset Î±} (h : monotone f) (h' : âˆ€ (x : Î±), âˆƒ (n : Î²), x âˆˆ f n) : filter.tendsto f filter.at_top filter.at_top
theorem one_div_le_one_div {Î± : Type u_1} [linear_ordered_field Î±] {a b : Î±} (ha : 0 < a) (hb : 0 < b) : 1 / a â‰¤ 1 / b â†” b â‰¤ a
theorem list.drop_sum_join {Î± : Type u_1} (L : list (list Î±)) (i : â„•) : list.drop (list.take i (list.map list.length L)).sum L.join = (list.drop i L).join
theorem subsemiring.closure_inductionâ‚‚ {R : Type u} [non_assoc_semiring R] {s : set R} {p : R â†’ R â†’ Prop} {x y : R} (hx : x âˆˆ subsemiring.closure s) (hy : y âˆˆ subsemiring.closure s) (Hs : âˆ€ (x : R), x âˆˆ s â†’ âˆ€ (y : R), y âˆˆ s â†’ p x y) (H0_left : âˆ€ (x : R), p 0 x) (H0_right : âˆ€ (x : R), p x 0) (H1_left : âˆ€ (x : R), p 1 x) (H1_right : âˆ€ (x : R), p x 1) (Hadd_left : âˆ€ (xâ‚ xâ‚‚ y : R), p xâ‚ y â†’ p xâ‚‚ y â†’ p (xâ‚ + xâ‚‚) y) (Hadd_right : âˆ€ (x yâ‚ yâ‚‚ : R), p x yâ‚ â†’ p x yâ‚‚ â†’ p x (yâ‚ + yâ‚‚)) (Hmul_left : âˆ€ (xâ‚ xâ‚‚ y : R), p xâ‚ y â†’ p xâ‚‚ y â†’ p (xâ‚ * xâ‚‚) y) (Hmul_right : âˆ€ (x yâ‚ yâ‚‚ : R), p x yâ‚ â†’ p x yâ‚‚ â†’ p x (yâ‚ * yâ‚‚)) : p x y
theorem ultrafilter_is_closed_basic {Î± : Type u} (s : set Î±) : is_closed {u : ultrafilter Î± | s âˆˆ u}
theorem locally_finite.countable_univ {Î± : Type u} [topological_space Î±] [sigma_compact_space Î±] {Î¹ : Type u_1} {f : Î¹ â†’ set Î±} (hf : locally_finite f) (hne : âˆ€ (i : Î¹), (f i).nonempty) : set.univ.countable
theorem measure_theory.measure_lt_top_of_is_compact_of_is_mul_left_invariant' {G : Type u_1} [measurable_space G] [topological_space G] [borel_space G] {Î¼ : measure_theory.measure G} [group G] [topological_group G] [Î¼.is_mul_left_invariant] {U : set G} (hU : (interior U).nonempty) (h : â‡‘Î¼ U â‰  âŠ¤) {K : set G} (hK : is_compact K) : â‡‘Î¼ K < âŠ¤
theorem finite_field.is_square_of_char_two {F : Type u_3} [field F] [fintype F] (hF : ring_char F = 2) (a : F) : is_square a
theorem eq_affine_combination_of_mem_affine_span {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {Î¹ : Type u_4} {p1 : P} {p : Î¹ â†’ P} (h : p1 âˆˆ affine_span k (set.range p)) : âˆƒ (s : finset Î¹) (w : Î¹ â†’ k) (hw : s.sum (Î» (i : Î¹), w i) = 1), p1 = â‡‘(s.affine_combination p) w
theorem matrix.nondegenerate.det_ne_zero {n : Type u_3} [fintype n] {A : Type u_1} [decidable_eq n] [comm_ring A] [is_domain A] {M : matrix n n A} : M.nondegenerate â†’ M.det â‰  0
theorem volume_set_of_liouville  : â‡‘measure_theory.measure_space.volume {x : â„ | liouville x} = 0
theorem monoid_algebra.non_unital_alg_hom_ext (k : Type uâ‚) {G : Type uâ‚‚} [semiring k] [has_mul G] {A : Type uâ‚ƒ} [non_unital_non_assoc_semiring A] [distrib_mul_action k A] {Ï†â‚ Ï†â‚‚ : monoid_algebra k G â†’â‚™â‚[k] A} (h : âˆ€ (x : G), â‡‘Ï†â‚ (finsupp.single x 1) = â‡‘Ï†â‚‚ (finsupp.single x 1)) : Ï†â‚ = Ï†â‚‚
theorem submonoid.closure_induction {M : Type u_1} [mul_one_class M] {s : set M} {p : M â†’ Prop} {x : M} (h : x âˆˆ submonoid.closure s) (Hs : âˆ€ (x : M), x âˆˆ s â†’ p x) (H1 : p 1) (Hmul : âˆ€ (x y : M), p x â†’ p y â†’ p (x * y)) : p x
theorem matrix.pivot.exists_is_two_block_diagonal_of_ne_zero {ğ•œ : Type u_3} [field ğ•œ] {r : â„•} (M : matrix (fin r âŠ• unit) (fin r âŠ• unit) ğ•œ) (hM : M (sum.inr ()) (sum.inr ()) â‰  0) : âˆƒ (L L' : list (matrix.transvection_struct (fin r âŠ• unit) ğ•œ)), (((list.map matrix.transvection_struct.to_matrix L).prod.mul M).mul (list.map matrix.transvection_struct.to_matrix L').prod).is_two_block_diagonal
theorem monoid.closure_subset {M : Type u_1} [monoid M] {s t : set M} (ht : is_submonoid t) (h : s âŠ† t) : monoid.closure s âŠ† t
theorem int.abs_le_self_pow_two (a : â„¤) : â†‘(a.nat_abs) â‰¤ a ^ 2
theorem measure_theory.ae_eventually_not_mem {Î± : Type u_1} {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {s : â„• â†’ set Î±} (hs : âˆ‘' (i : â„•), â‡‘Î¼ (s i) â‰  âŠ¤) : âˆ€áµ (x : Î±) âˆ‚Î¼, âˆ€á¶  (n : â„•) in filter.at_top, x âˆ‰ s n
theorem cont_diff_on_fst {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {n : with_top â„•} {s : set (E Ã— F)} : cont_diff_on ğ•œ n prod.fst s
theorem refl_trans_gen_of_succ {Î± : Type u_1} [linear_order Î±] [succ_order Î±] [is_succ_archimedean Î±] (r : Î± â†’ Î± â†’ Prop) {n m : Î±} (h1 : âˆ€ (i : Î±), i âˆˆ set.Ico n m â†’ r i (order.succ i)) (h2 : âˆ€ (i : Î±), i âˆˆ set.Ico m n â†’ r (order.succ i) i) : relation.refl_trans_gen r n m
theorem linear_map.polar_gc {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [normed_comm_ring ğ•œ] [add_comm_monoid E] [add_comm_monoid F] [module ğ•œ E] [module ğ•œ F] (B : E â†’â‚—[ğ•œ] F â†’â‚—[ğ•œ] ğ•œ) : galois_connection (â‡‘order_dual.to_dual âˆ˜ B.polar) (B.flip.polar âˆ˜ â‡‘order_dual.of_dual)
theorem bornology.is_bounded.of_compl {Î± : Type u_2} [bornology Î±] {s : set Î±} : bornology.is_bounded sá¶œ â†’ bornology.is_cobounded s
theorem matrix.star_mul {n : Type u_3} {Î± : Type v} [fintype n] [non_unital_semiring Î±] [star_ring Î±] (M N : matrix n n Î±) : has_star.star (M.mul N) = (has_star.star N).mul (has_star.star M)
theorem category_theory.limits.has_wide_equalizers_of_has_limit_parallel_family (C : Type u) [category_theory.category C] [âˆ€ {J : Type v} {X Y : C} {f : J â†’ (X âŸ¶ Y)}, category_theory.limits.has_limit (category_theory.limits.parallel_family f)] : category_theory.limits.has_wide_equalizers C
theorem equiv.is_domain {Î± : Type u} {Î² : Type v} [ring Î±] [ring Î²] [is_domain Î²] (e : Î± â‰ƒ+* Î²) : is_domain Î±
theorem strict_convex_on_zpow {m : â„¤} (hmâ‚€ : m â‰  0) (hmâ‚ : m â‰  1) : strict_convex_on â„ (set.Ioi 0) (Î» (x : â„), x ^ m)
theorem deriv.lhopital_zero_at_top {l : filter â„} {f g : â„ â†’ â„} (hdf : âˆ€á¶  (x : â„) in filter.at_top, differentiable_at â„ f x) (hg' : âˆ€á¶  (x : â„) in filter.at_top, deriv g x â‰  0) (hftop : filter.tendsto f filter.at_top (nhds 0)) (hgtop : filter.tendsto g filter.at_top (nhds 0)) (hdiv : filter.tendsto (Î» (x : â„), deriv f x / deriv g x) filter.at_top l) : filter.tendsto (Î» (x : â„), f x / g x) filter.at_top l
theorem fixing_submonoid_union (M : Type u_1) (Î± : Type u_2) [monoid M] [mul_action M Î±] {s t : set Î±} : fixing_submonoid M (s âˆª t) = fixing_submonoid M s âŠ“ fixing_submonoid M t
theorem ordered_smul.mk'' {R : Type u_1} {M : Type u_2} [linear_ordered_semiring R] [ordered_add_comm_monoid M] [mul_action_with_zero R M] (hR : âˆ€ {c : R}, c â‰  0 â†’ is_unit c) (hlt : âˆ€ â¦ƒa b : Mâ¦„ â¦ƒc : Râ¦„, a < b â†’ 0 < c â†’ c â€¢ a â‰¤ c â€¢ b) : ordered_smul R M
theorem has_ssubset.ssubset.false {Î± : Type u} [has_ssubset Î±] [is_irrefl Î± has_ssubset.ssubset] {a : Î±} : Â¬a âŠ‚ a
theorem Gromov_Hausdorff.GH_dist_le_Hausdorff_dist {X : Type u} [metric_space X] [compact_space X] [nonempty X] {Y : Type v} [metric_space Y] [compact_space Y] [nonempty Y] {Î³ : Type w} [metric_space Î³] {Î¦ : X â†’ Î³} {Î¨ : Y â†’ Î³} (ha : isometry Î¦) (hb : isometry Î¨) : Gromov_Hausdorff.GH_dist X Y â‰¤ metric.Hausdorff_dist (set.range Î¦) (set.range Î¨)
theorem witt_vector.is_polyâ‚‚.comp_left {p : â„•} {g : Î  â¦ƒR : Type u_1â¦„ [_inst_3 : comm_ring R], witt_vector p R â†’ witt_vector p R â†’ witt_vector p R} {f : Î  â¦ƒR : Type u_1â¦„ [_inst_3 : comm_ring R], witt_vector p R â†’ witt_vector p R} (hg : witt_vector.is_polyâ‚‚ p g) (hf : witt_vector.is_poly p f) : witt_vector.is_polyâ‚‚ p (Î» (R : Type u_1) (_Rcr : comm_ring R) (x y : witt_vector p R), g (f x) y)
theorem eventually_closed_ball_subset {Î± : Type u} [pseudo_metric_space Î±] {x : Î±} {u : set Î±} (hu : u âˆˆ nhds x) : âˆ€á¶  (r : â„) in nhds 0, metric.closed_ball x r âŠ† u
theorem list.length_pos_of_one_lt_prod {M : Type u_3} [monoid M] [preorder M] (L : list M) (h : 1 < L.prod) : 0 < L.length
theorem list.prod_drop_succ {G : Type u_7} [group G] (L : list G) (i : â„•) (p : i < L.length) : (list.drop (i + 1) L).prod = (L.nth_le i p)â»Â¹ * (list.drop i L).prod
theorem strongly_measurable_iff_measurable {Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} {mÎ± : measurable_space Î±} [measurable_space Î²] [topological_space Î²] [topological_space.metrizable_space Î²] [borel_space Î²] [topological_space.second_countable_topology Î²] : measure_theory.strongly_measurable f â†” measurable f
theorem cont_mdiff_within_at_iff_target {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners ğ•œ E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] {f : M â†’ M'} {s : set M} {x : M} {n : with_top â„•} : cont_mdiff_within_at I I' n f s x â†” continuous_within_at f s x âˆ§ cont_mdiff_within_at I (model_with_corners_self ğ•œ E') n (â‡‘(ext_chart_at I' (f x)) âˆ˜ f) (s âˆ© f â»Â¹' (ext_chart_at I' (f x)).source) x
theorem line_map_le_map_iff_slope_le_slope_left {k : Type u_1} {E : Type u_2} [linear_ordered_field k] [ordered_add_comm_group E] [module k E] [ordered_smul k E] {f : k â†’ E} {a b r : k} (h : 0 < r * (b - a)) : â‡‘(affine_map.line_map (f a) (f b)) r â‰¤ f (â‡‘(affine_map.line_map a b) r) â†” slope f a b â‰¤ slope f a (â‡‘(affine_map.line_map a b) r)
theorem mul_lt_one_of_le_of_lt {Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a b : Î±} (ha : a â‰¤ 1) (hb : b < 1) : a * b < 1
theorem differentiable_within_at.mdifferentiable_within_at {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {E' : Type u_3} [normed_group E'] [normed_space ğ•œ E'] {f : E â†’ E'} {s : set E} {x : E} : differentiable_within_at ğ•œ f s x â†’ mdifferentiable_within_at (model_with_corners_self ğ•œ E) (model_with_corners_self ğ•œ E') f s x
theorem orientation.oangle_eq_iff_eq_pos_smul_rotation_or_eq_zero {V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) {x y : V} (Î¸ : real.angle) : o.oangle x y = Î¸ â†” (x â‰  0 âˆ§ y â‰  0 âˆ§ âˆƒ (r : â„), 0 < r âˆ§ y = r â€¢ â‡‘(o.rotation Î¸) x) âˆ¨ Î¸ = 0 âˆ§ (x = 0 âˆ¨ y = 0)
theorem continuous_linear_map.comp_has_fpower_series_on_ball {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [nondiscrete_normed_field ğ•œ] [normed_group E] [normed_space ğ•œ E] [normed_group F] [normed_space ğ•œ F] [normed_group G] [normed_space ğ•œ G] {f : E â†’ F} {p : formal_multilinear_series ğ•œ E F} {x : E} {r : ennreal} (g : F â†’L[ğ•œ] G) (h : has_fpower_series_on_ball f p x r) : has_fpower_series_on_ball (â‡‘g âˆ˜ f) (g.comp_formal_multilinear_series p) x r
theorem nhds_le_of_le {Î± : Type u} [topological_space Î±] {f : filter Î±} {a : Î±} {s : set Î±} (h : a âˆˆ s) (o : is_open s) (sf : filter.principal s â‰¤ f) : nhds a â‰¤ f
theorem has_strict_fderiv_at.eq_implicit_function_of_complemented {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] [complete_space E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] [complete_space F] {f : E â†’ F} {f' : E â†’L[ğ•œ] F} {a : E} (hf : has_strict_fderiv_at f f' a) (hf' : f'.range = âŠ¤) (hker : f'.ker.closed_complemented) : âˆ€á¶  (x : E) in nhds a, has_strict_fderiv_at.implicit_function_of_complemented f f' hf hf' hker (f x) (â‡‘(has_strict_fderiv_at.implicit_to_local_homeomorph_of_complemented f f' hf hf' hker) x).snd = x
theorem torus_integral_succ {n : â„•} {E : Type u_1} [normed_group E] [normed_space â„‚ E] [complete_space E] {f : (fin (n + 1) â†’ â„‚) â†’ E} {c : fin (n + 1) â†’ â„‚} {R : fin (n + 1) â†’ â„} (hf : torus_integrable f c R) : âˆ¯ (x : fin (n + 1) â†’ â„‚) in T(c, R), f x = âˆ® (x : â„‚) in C(c 0, R 0), âˆ¯ (y : fin n â†’ â„‚) in T(c âˆ˜ fin.succ, R âˆ˜ fin.succ), f (fin.cons x y)
theorem interval_integral.sub_le_integral_of_has_deriv_right_of_le {a b : â„} {g' g Ï† : â„ â†’ â„} (hab : a â‰¤ b) (hcont : continuous_on g (set.Icc a b)) (hderiv : âˆ€ (x : â„), x âˆˆ set.Ioo a b â†’ has_deriv_within_at g (g' x) (set.Ioi x) x) (Ï†int : measure_theory.integrable_on Ï† (set.Icc a b) measure_theory.measure_space.volume) (hÏ†g : âˆ€ (x : â„), x âˆˆ set.Ioo a b â†’ g' x â‰¤ Ï† x) : g b - g a â‰¤ âˆ« (y : â„) in a..b, Ï† y
theorem abelianization.hom_ext {G : Type u} [group G] {A : Type v} [monoid A] (Ï† Ïˆ : abelianization G â†’* A) (h : Ï†.comp abelianization.of = Ïˆ.comp abelianization.of) : Ï† = Ïˆ
theorem phragmen_lindelof.quadrant_III {E : Type u_1} [normed_group E] [normed_space â„‚ E] {C : â„} {f : â„‚ â†’ E} {z : â„‚} (hd : diff_cont_on_cl â„‚ f (set.Iio 0 Ã—â„‚ set.Iio 0)) (hB : âˆƒ (c : â„) (H : c < 2) (B : â„), f =O[filter.comap complex.abs filter.at_top âŠ“ filter.principal (set.Iio 0 Ã—â„‚ set.Iio 0)] Î» (z : â„‚), real.exp (B * complex.abs z ^ c)) (hre : âˆ€ (x : â„), x â‰¤ 0 â†’ âˆ¥f â†‘xâˆ¥ â‰¤ C) (him : âˆ€ (x : â„), x â‰¤ 0 â†’ âˆ¥f (â†‘x * complex.I)âˆ¥ â‰¤ C) (hz_re : z.re â‰¤ 0) (hz_im : z.im â‰¤ 0) : âˆ¥f zâˆ¥ â‰¤ C
theorem list.is_infix.reverse {Î± : Type u_1} {lâ‚ lâ‚‚ : list Î±} : lâ‚ <:+: lâ‚‚ â†’ lâ‚.reverse <:+: lâ‚‚.reverse
theorem dvd_add_right {Î± : Type u} [non_unital_ring Î±] {a b c : Î±} (h : a âˆ£ b) : a âˆ£ b + c â†” a âˆ£ c
theorem exists_continuous_zero_one_of_closed {X : Type u_1} [topological_space X] [normal_space X] {s t : set X} (hs : is_closed s) (ht : is_closed t) (hd : disjoint s t) : âˆƒ (f : C(X, â„)), set.eq_on â‡‘f 0 s âˆ§ set.eq_on â‡‘f 1 t âˆ§ âˆ€ (x : X), â‡‘f x âˆˆ set.Icc 0 1
theorem set.image_perm {Î± : Type u} {s : set Î±} {Ïƒ : equiv.perm Î±} (hs : {a : Î± | â‡‘Ïƒ a â‰  a} âŠ† s) : â‡‘Ïƒ '' s = s
theorem span_points_nonempty (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P) : (span_points k s).nonempty â†” s.nonempty
theorem list.nodup.of_sublists' {Î± : Type u} {l : list Î±} : l.sublists'.nodup â†’ l.nodup
theorem subring.multiset_sum_mem {R : Type u_1} [ring R] (s : subring R) (m : multiset R) : (âˆ€ (a : R), a âˆˆ m â†’ a âˆˆ s) â†’ m.sum âˆˆ s
theorem category_theory.concrete_category.epi_of_surjective {C : Type v} [category_theory.category C] [category_theory.concrete_category C] {X Y : C} (f : X âŸ¶ Y) (s : function.surjective â‡‘f) : category_theory.epi f
theorem balanced_zero_union_interior {ğ•œ : Type u_1} {E : Type u_3} [normed_field ğ•œ] [add_comm_group E] [module ğ•œ E] {A : set E} [topological_space E] [has_continuous_smul ğ•œ E] (hA : balanced ğ•œ A) : balanced ğ•œ (0 âˆª interior A)
theorem is_bounded_bilinear_map_inner {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] [normed_space â„ E] : is_bounded_bilinear_map â„ (Î» (p : E Ã— E), has_inner.inner p.fst p.snd)
theorem lattice_ordered_comm_group.pos_of_nonneg {Î± : Type u} [lattice Î±] [add_comm_group Î±] (a : Î±) (h : 0 â‰¤ a) : aâº = a
theorem emetric.inf_edist_singleton {Î± : Type u} [pseudo_emetric_space Î±] {x y : Î±} : emetric.inf_edist x {y} = has_edist.edist x y
theorem polynomial.map_cyclotomic (n : â„•) {R : Type u_1} {S : Type u_2} [ring R] [ring S] (f : R â†’+* S) : polynomial.map f (polynomial.cyclotomic n R) = polynomial.cyclotomic n S
theorem finset.prod_le_prod {Î¹ : Type u_1} {R : Type u_8} [ordered_comm_semiring R] {f g : Î¹ â†’ R} {s : finset Î¹} (h0 : âˆ€ (i : Î¹), i âˆˆ s â†’ 0 â‰¤ f i) (h1 : âˆ€ (i : Î¹), i âˆˆ s â†’ f i â‰¤ g i) : s.prod (Î» (i : Î¹), f i) â‰¤ s.prod (Î» (i : Î¹), g i)
theorem category_theory.preadditive.has_coequalizer_of_has_cokernel {C : Type u} [category_theory.category C] [category_theory.preadditive C] {X Y : C} (f g : X âŸ¶ Y) [category_theory.limits.has_cokernel (f - g)] : category_theory.limits.has_coequalizer f g
theorem norm_eq_infi_iff_inner_eq_zero {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] (K : submodule ğ•œ E) {u v : E} (hv : v âˆˆ K) : (âˆ¥u - vâˆ¥ = â¨… (w : â†¥â†‘K), âˆ¥u - â†‘wâˆ¥) â†” âˆ€ (w : E), w âˆˆ K â†’ has_inner.inner (u - v) w = 0
theorem measure_theory.ae_fin_strongly_measurable_iff_ae_measurable {Î± : Type u_1} {G : Type u_5} [normed_group G] [measurable_space G] [borel_space G] [topological_space.second_countable_topology G] {f : Î± â†’ G} {m0 : measurable_space Î±} (Î¼ : measure_theory.measure Î±) [measure_theory.sigma_finite Î¼] : measure_theory.ae_fin_strongly_measurable f Î¼ â†” ae_measurable f Î¼
theorem is_mul_hom.to_is_monoid_hom {Î± : Type u} {Î² : Type v} [mul_one_class Î±] [group Î²] {f : Î± â†’ Î²} (hf : is_mul_hom f) : is_monoid_hom f
theorem locally_finite.finite_nonempty_inter_compact {Î± : Type u} [topological_space Î±] {Î¹ : Type u_1} {f : Î¹ â†’ set Î±} (hf : locally_finite f) {s : set Î±} (hs : is_compact s) : {i : Î¹ | (f i âˆ© s).nonempty}.finite
theorem real.ediam_eq {s : set â„} (h : metric.bounded s) : emetric.diam s = ennreal.of_real (has_Sup.Sup s - has_Inf.Inf s)
theorem neg_add_lt_of_lt_add {Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b c : Î±} : a < b + c â†’ -b + a < c
theorem topological_space.dense_range_dense_seq (Î± : Type u) [t : topological_space Î±] [topological_space.separable_space Î±] [nonempty Î±] : dense_range (topological_space.dense_seq Î±)
theorem metric.lipschitz_inf_nndist_pt {Î± : Type u} [pseudo_metric_space Î±] (s : set Î±) : lipschitz_with 1 (Î» (x : Î±), metric.inf_nndist x s)
theorem category_theory.equalizer.presieve.compatible_iff {C : Type uâ‚} [category_theory.category C] (P : Cáµ’áµ– â¥¤ Type (max vâ‚ uâ‚)) {X : C} (R : category_theory.presieve X) [category_theory.limits.has_pullbacks C] (x : category_theory.equalizer.first_obj P R) : ((category_theory.equalizer.first_obj_eq_family P R).hom x).compatible â†” category_theory.equalizer.presieve.first_map P R x = category_theory.equalizer.presieve.second_map P R x
theorem euclidean_geometry.vsub_orthogonal_projection_mem_direction {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace â„ P} [nonempty â†¥s] [complete_space â†¥(s.direction)] {p1 : P} (p2 : P) (hp1 : p1 âˆˆ s) : â†‘(âŸ¨p1, hp1âŸ© -áµ¥ â‡‘(euclidean_geometry.orthogonal_projection s) p2) âˆˆ s.direction
theorem nat.arithmetic_function.sum_eq_iff_sum_mul_moebius_eq {R : Type u_1} [ring R] {f g : â„• â†’ R} : (âˆ€ (n : â„•), 0 < n â†’ n.divisors.sum (Î» (i : â„•), f i) = g n) â†” âˆ€ (n : â„•), 0 < n â†’ n.divisors_antidiagonal.sum (Î» (x : â„• Ã— â„•), â†‘(â‡‘nat.arithmetic_function.moebius x.fst) * g x.snd) = f n
theorem local_homeomorph.image_open_of_open {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] (e : local_homeomorph Î± Î²) {s : set Î±} (hs : is_open s) (h : s âŠ† e.to_local_equiv.source) : is_open (â‡‘e '' s)
theorem topological_vector_bundle_core.is_open_map_proj {R : Type u_1} {B : Type u_3} {F : Type u_4} [nondiscrete_normed_field R] [normed_group F] [normed_space R F] [topological_space B] {Î¹ : Type u_6} (Z : topological_vector_bundle_core R B F Î¹) : is_open_map Z.proj
theorem is_smul_regular.smul_iff {R : Type u_1} {S : Type u_2} {M : Type u_3} {a : R} [has_scalar R M] [has_scalar R S] [has_scalar S M] [is_scalar_tower R S M] (b : S) (ha : is_smul_regular M a) : is_smul_regular M (a â€¢ b) â†” is_smul_regular M b
theorem fin.prod_univ_succ {Î² : Type u_2} [comm_monoid Î²] {n : â„•} (f : fin (n + 1) â†’ Î²) : finset.univ.prod (Î» (i : fin (n + 1)), f i) = f 0 * finset.univ.prod (Î» (i : fin n), f i.succ)
theorem add_comm_monoid.add_torsion.is_torsion {G : Type u_1} [add_comm_monoid G] : add_monoid.is_torsion â†¥(add_comm_monoid.add_torsion G)
theorem measurable_set_of_differentiable_at (ğ•œ : Type u_1) [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] (f : E â†’ F) [measurable_space E] [opens_measurable_space E] [complete_space F] : measurable_set {x : E | differentiable_at ğ•œ f x}
theorem absorbent_ball {ğ•œ : Type u_3} {E : Type u_4} [normed_field ğ•œ] [semi_normed_group E] [normed_space ğ•œ E] {r : â„} {x : E} (hx : âˆ¥xâˆ¥ < r) : absorbent ğ•œ (metric.ball x r)
theorem totally_disconnected_space_iff_connected_component_subsingleton {Î± : Type u} [topological_space Î±] : totally_disconnected_space Î± â†” âˆ€ (x : Î±), (connected_component x).subsingleton
theorem measure_theory.absolutely_continuous_of_is_add_left_invariant {G : Type u_1} [measurable_space G] [add_group G] [has_measurable_addâ‚‚ G] (Î¼ Î½ : measure_theory.measure G) [measure_theory.sigma_finite Î½] [measure_theory.sigma_finite Î¼] [has_measurable_neg G] [Î¼.is_add_left_invariant] [Î½.is_add_left_invariant] (hÎ½ : Î½ â‰  0) : Î¼.absolutely_continuous Î½
theorem matrix.pivot.list_transvec_col_mul_last_row {ğ•œ : Type u_3} [field ğ•œ] {r : â„•} (M : matrix (fin r âŠ• unit) (fin r âŠ• unit) ğ•œ) (i : fin r âŠ• unit) : (matrix.pivot.list_transvec_col M).prod.mul M (sum.inr ()) i = M (sum.inr ()) i
theorem nonempty_of_finprod_mem_ne_one {Î± : Type u_1} {M : Type u_5} [comm_monoid M] {f : Î± â†’ M} {s : set Î±} (h : finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), f i)) â‰  1) : s.nonempty
theorem measure_theory.measure.add_haar_preimage_continuous_linear_equiv {E : Type u_1} [normed_group E] [normed_space â„ E] [measurable_space E] [borel_space E] [finite_dimensional â„ E] (Î¼ : measure_theory.measure E) [Î¼.is_add_haar_measure] (f : E â‰ƒL[â„] E) (s : set E) : â‡‘Î¼ (â‡‘f â»Â¹' s) = ennreal.of_real |â‡‘linear_map.det â†‘(f.symm)| * â‡‘Î¼ s
theorem nat.coprime_prod_left {Î¹ : Type u_1} {x : â„•} {s : Î¹ â†’ â„•} {t : finset Î¹} : (âˆ€ (i : Î¹), i âˆˆ t â†’ (s i).coprime x) â†’ (t.prod (Î» (i : Î¹), s i)).coprime x
theorem cardinal.not_countable_real  : Â¬set.univ.countable
theorem fintype.sum_equiv {Î± : Type u_1} {Î² : Type u_2} {M : Type u_3} [fintype Î±] [fintype Î²] [add_comm_monoid M] (e : Î± â‰ƒ Î²) (f : Î± â†’ M) (g : Î² â†’ M) (h : âˆ€ (x : Î±), f x = g (â‡‘e x)) : finset.univ.sum (Î» (x : Î±), f x) = finset.univ.sum (Î» (x : Î²), g x)
theorem category_theory.is_iso_right_of_is_iso_biprod_map {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_binary_biproducts C] {W X Y Z : C} (f : W âŸ¶ Y) (g : X âŸ¶ Z) [category_theory.is_iso (category_theory.limits.biprod.map f g)] : category_theory.is_iso g
theorem monotone_on.map_is_greatest {Î± : Type u} {Î² : Type v} [preorder Î±] [preorder Î²] {f : Î± â†’ Î²} {t : set Î±} (Hf : monotone_on f t) {a : Î±} (Ha : is_greatest t a) : is_greatest (f '' t) (f a)
theorem list.length_pos_of_prod_ne_one {M : Type u_3} [monoid M] (L : list M) (h : L.prod â‰  1) : 0 < L.length
theorem affine.simplex.altitude_def {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {n : â„•} (s : affine.simplex â„ P (n + 1)) (i : fin (n + 2)) : s.altitude i = affine_subspace.mk' (s.points i) ((affine_span â„ (s.points '' â†‘(finset.univ.erase i))).direction)á—® âŠ“ affine_span â„ (set.range s.points)
theorem inner_product_geometry.angle_smul_right_of_pos {V : Type u_1} [inner_product_space â„ V] (x y : V) {r : â„} (hr : 0 < r) : inner_product_geometry.angle x (r â€¢ y) = inner_product_geometry.angle x y
theorem finset.ne_of_mem_slice {Î± : Type u_1} {ğ’œ : finset (finset Î±)} {Aâ‚ Aâ‚‚ : finset Î±} {râ‚ râ‚‚ : â„•} (hâ‚ : Aâ‚ âˆˆ ğ’œ.slice râ‚) (hâ‚‚ : Aâ‚‚ âˆˆ ğ’œ.slice râ‚‚) : râ‚ â‰  râ‚‚ â†’ Aâ‚ â‰  Aâ‚‚
theorem is_exposed.eq_inter_halfspace {ğ•œ : Type u_1} {E : Type u_2} [normed_linear_ordered_field ğ•œ] [normed_group E] [normed_space ğ•œ E] {A B : set E} (hAB : is_exposed ğ•œ A B) : âˆƒ (l : E â†’L[ğ•œ] ğ•œ) (a : ğ•œ), B = {x âˆˆ A | a â‰¤ â‡‘l x}
theorem finite_field.sum_pow_units (K : Type u_1) [field K] [fintype K] [fintype KË£] (i : â„•) : finset.univ.sum (Î» (x : KË£), â†‘x ^ i) = ite (fintype.card K - 1 âˆ£ i) (-1) 0
theorem finset.sum_subtype_map_embedding {Î² : Type u} {Î± : Type v} [add_comm_monoid Î²] {p : Î± â†’ Prop} {s : finset {x // p x}} {f : {x // p x} â†’ Î²} {g : Î± â†’ Î²} (h : âˆ€ (x : {x // p x}), x âˆˆ s â†’ g â†‘x = f x) : (finset.map (function.embedding.subtype (Î» (x : Î±), p x)) s).sum (Î» (x : Î±), g x) = s.sum (Î» (x : {x // p x}), f x)
theorem subgroup.closure_eq {G : Type u_1} [group G] (K : subgroup G) : subgroup.closure â†‘K = K
theorem compact_t2_tot_disc_iff_tot_sep {Î± : Type u} [topological_space Î±] [t2_space Î±] [compact_space Î±] : totally_disconnected_space Î± â†” totally_separated_space Î±
theorem is_local_max.has_deriv_at_eq_zero {f : â„ â†’ â„} {f' a : â„} (h : is_local_max f a) (hf : has_deriv_at f f' a) : f' = 0
theorem measurable_set_of_differentiable_within_at_Ioi {F : Type u_1} [normed_group F] [normed_space â„ F] (f : â„ â†’ F) [complete_space F] : measurable_set {x : â„ | differentiable_within_at â„ f (set.Ioi x) x}
theorem nnreal.summable_of_le {Î² : Type u_2} {f g : Î² â†’ nnreal} (hgf : âˆ€ (b : Î²), g b â‰¤ f b) : summable f â†’ summable g
theorem convex.second_derivative_within_at_symmetric_of_mem_interior {E : Type u_1} {F : Type u_2} [normed_group E] [normed_space â„ E] [normed_group F] [normed_space â„ F] {s : set E} (s_conv : convex â„ s) {f : E â†’ F} {f' : E â†’ (E â†’L[â„] F)} {f'' : E â†’L[â„] E â†’L[â„] F} (hf : âˆ€ (x : E), x âˆˆ interior s â†’ has_fderiv_at f (f' x) x) {x : E} (xs : x âˆˆ s) (hx : has_fderiv_within_at f' f'' (interior s) x) {v w : E} (h4v : x + 4 â€¢ v âˆˆ interior s) (h4w : x + 4 â€¢ w âˆˆ interior s) : â‡‘(â‡‘f'' w) v = â‡‘(â‡‘f'' v) w
theorem polynomial.has_deriv_at {ğ•œ : Type u} [nondiscrete_normed_field ğ•œ] (p : polynomial ğ•œ) (x : ğ•œ) : has_deriv_at (Î» (x : ğ•œ), polynomial.eval x p) (polynomial.eval x (â‡‘polynomial.derivative p)) x
theorem closure_operator.le_closure {Î± : Type u_1} [partial_order Î±] (c : closure_operator Î±) (x : Î±) : x â‰¤ â‡‘c x
theorem valuation.is_equiv.comap {R : Type u_2} {Î“â‚€ : Type u_3} {Î“'â‚€ : Type u_4} [ring R] [linear_ordered_comm_monoid_with_zero Î“â‚€] [linear_ordered_comm_monoid_with_zero Î“'â‚€] {vâ‚ : valuation R Î“â‚€} {vâ‚‚ : valuation R Î“'â‚€} {S : Type u_1} [ring S] (f : S â†’+* R) (h : vâ‚.is_equiv vâ‚‚) : (valuation.comap f vâ‚).is_equiv (valuation.comap f vâ‚‚)
theorem emetric.uniform_continuous_iff {Î± : Type u} {Î² : Type v} [pseudo_emetric_space Î±] [pseudo_emetric_space Î²] {f : Î± â†’ Î²} : uniform_continuous f â†” âˆ€ (Îµ : ennreal), Îµ > 0 â†’ (âˆƒ (Î´ : ennreal) (H : Î´ > 0), âˆ€ {a b : Î±}, has_edist.edist a b < Î´ â†’ has_edist.edist (f a) (f b) < Îµ)
theorem is_cyclotomic_extension.splits_X_pow_sub_one (n : â„•+) (S : set â„•+) (K : Type w) (L : Type z) [field K] [field L] [algebra K L] [ne_zero â†‘â†‘n] [H : is_cyclotomic_extension S K L] (hS : n âˆˆ S) : polynomial.splits (algebra_map K L) (polynomial.X ^ â†‘n - 1)
theorem add_monoid_hom.functions_ext' {I : Type u_1} [decidable_eq I] {Z : I â†’ Type u_2} [Î  (i : I), add_comm_monoid (Z i)] [fintype I] (M : Type u_3) [add_comm_monoid M] (g h : (Î  (i : I), Z i) â†’+ M) (H : âˆ€ (i : I), g.comp (add_monoid_hom.single Z i) = h.comp (add_monoid_hom.single Z i)) : g = h
theorem finset.weighted_vsub_apply_const {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {Î¹ : Type u_4} (s : finset Î¹) (w : Î¹ â†’ k) (p : P) (h : s.sum (Î» (i : Î¹), w i) = 0) : â‡‘(s.weighted_vsub (Î» (_x : Î¹), p)) w = 0
theorem is_primitive_root.is_integral {n : â„•} {K : Type u_8} [comm_ring K] {Î¼ : K} (h : is_primitive_root Î¼ n) (hpos : 0 < n) : is_integral â„¤ Î¼
theorem continuous.bdd_below_range_of_has_compact_mul_support {Î± : Type u} {Î² : Type v} [topological_space Î±] [linear_order Î±] [order_closed_topology Î±] [nonempty Î±] [topological_space Î²] [has_one Î±] {f : Î² â†’ Î±} (hf : continuous f) (h : has_compact_mul_support f) : bdd_below (set.range f)
theorem function.injective.inj_on {Î± : Type u} {Î² : Type v} {f : Î± â†’ Î²} (h : function.injective f) (s : set Î±) : set.inj_on f s
theorem matrix.det_transpose {n : Type u_2} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] (M : matrix n n R) : M.transpose.det = M.det
theorem submonoid.localization_map.of_mul_equiv_of_dom_id {M : Type u_1} [comm_monoid M] {S : submonoid M} {N : Type u_2} [comm_monoid N] (f : S.localization_map N) : f.of_mul_equiv_of_dom _ = f
theorem monoid_algebra.ring_hom_ext' {k : Type uâ‚} {G : Type uâ‚‚} {R : Type u_1} [semiring k] [mul_one_class G] [semiring R] {f g : monoid_algebra k G â†’+* R} (hâ‚ : f.comp monoid_algebra.single_one_ring_hom = g.comp monoid_algebra.single_one_ring_hom) (h_of : â†‘f.comp (monoid_algebra.of k G) = â†‘g.comp (monoid_algebra.of k G)) : f = g
theorem uniform_space.second_countable_of_separable (Î± : Type u) [uniform_space Î±] [(uniformity Î±).is_countably_generated] [topological_space.separable_space Î±] : topological_space.second_countable_topology Î±
theorem linear_map.trace_id (R : Type u_1) [comm_ring R] (M : Type u_2) [add_comm_group M] [module R M] [module.free R M] [module.finite R M] [nontrivial R] : â‡‘(linear_map.trace R M) linear_map.id = â†‘(finite_dimensional.finrank R M)
theorem inv_lt_inv {Î± : Type u_1} [linear_ordered_field Î±] {a b : Î±} (ha : 0 < a) (hb : 0 < b) : aâ»Â¹ < bâ»Â¹ â†” b < a
theorem setoid.eqv_gen_mono {Î± : Type u_1} {r s : Î± â†’ Î± â†’ Prop} (h : âˆ€ (x y : Î±), r x y â†’ s x y) : eqv_gen.setoid r â‰¤ eqv_gen.setoid s
theorem padic_seq.lift_index_right {p : â„•} [fact (nat.prime p)] {f : padic_seq p} (hf : Â¬f â‰ˆ 0) (v1 v2 : â„•) : padic_norm p (â‡‘f (padic_seq.stationary_point hf)) = padic_norm p (â‡‘f (linear_order.max v1 (linear_order.max v2 (padic_seq.stationary_point hf))))
theorem right.mul_lt_one_of_lt_of_le {Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_mul.mul) has_lt.lt] {a b : Î±} (ha : a < 1) (hb : b â‰¤ 1) : a * b < 1
theorem is_upper_set.of_dual {Î± : Type u_1} [has_le Î±] {s : set Î±} : is_upper_set s â†’ is_lower_set (â‡‘order_dual.of_dual â»Â¹' s)
theorem finset.add_sum_erase {Î² : Type u} {Î± : Type v} [add_comm_monoid Î²] [decidable_eq Î±] (s : finset Î±) (f : Î± â†’ Î²) {a : Î±} (h : a âˆˆ s) : f a + (s.erase a).sum (Î» (x : Î±), f x) = s.sum (Î» (x : Î±), f x)
theorem category_theory.pullback_is_sheaf_of_cover_preserving {C : Type uâ‚} [category_theory.category C] {D : Type uâ‚‚} [category_theory.category D] {A : Type uâ‚ƒ} [category_theory.category A] {J : category_theory.grothendieck_topology C} {K : category_theory.grothendieck_topology D} {G : C â¥¤ D} (hGâ‚ : category_theory.compatible_preserving K G) (hGâ‚‚ : category_theory.cover_preserving J K G) (â„± : category_theory.Sheaf K A) : category_theory.presheaf.is_sheaf J (G.op â‹™ â„±.val)
theorem upper_semicontinuous.add' {Î± : Type u_1} [topological_space Î±] {Î³ : Type u_4} [linear_ordered_add_comm_monoid Î³] [topological_space Î³] [order_topology Î³] {f g : Î± â†’ Î³} (hf : upper_semicontinuous f) (hg : upper_semicontinuous g) (hcont : âˆ€ (x : Î±), continuous_at (Î» (p : Î³ Ã— Î³), p.fst + p.snd) (f x, g x)) : upper_semicontinuous (Î» (z : Î±), f z + g z)
theorem matrix.transpose_has_orthogonal_rows_iff_has_orthogonal_cols {Î± : Type u_1} {n : Type u_2} {m : Type u_3} [has_mul Î±] [add_comm_monoid Î±] (A : matrix m n Î±) [fintype m] : A.transpose.has_orthogonal_rows â†” A.has_orthogonal_cols
theorem category_theory.limits.eq_of_epi_fork_Î¹ {C : Type u} [category_theory.category C] {X Y : C} {f g : X âŸ¶ Y} (t : category_theory.limits.fork f g) [category_theory.epi t.Î¹] : f = g
theorem has_ftaylor_series_up_to_on.exists_lipschitz_on_with_of_nnnorm_lt {E : Type u_1} {F : Type u_2} [normed_group E] [normed_space â„ E] [normed_group F] [normed_space â„ F] {f : E â†’ F} {p : E â†’ formal_multilinear_series â„ E F} {s : set E} {x : E} (hf : has_ftaylor_series_up_to_on 1 f p (has_insert.insert x s)) (hs : convex â„ s) (K : nnreal) (hK : âˆ¥p x 1âˆ¥â‚Š < K) : âˆƒ (t : set E) (H : t âˆˆ nhds_within x s), lipschitz_on_with K f t
theorem nat.mul_div_mul_left (a b : â„•) {c : â„•} (hc : 0 < c) : c * a / (c * b) = a / b
theorem nat.exists_lt_modeq_of_infinite {s : set â„•} (hs : s.infinite) {k : â„•} (hk : 0 < k) : âˆƒ (m : â„•) (H : m âˆˆ s) (n : â„•) (H : n âˆˆ s), m < n âˆ§ m â‰¡ n [MOD k]
theorem category_theory.tensor_left_hom_equiv_tensor {C : Type uâ‚} [category_theory.category C] [category_theory.monoidal_category C] {X X' Y Y' Z Z' : C} [category_theory.exact_pairing Y Y'] (f : X âŸ¶ Y âŠ— Z) (g : X' âŸ¶ Z') : â‡‘((category_theory.tensor_left_hom_equiv (X âŠ— X') Y Y' (Z âŠ— Z')).symm) ((f âŠ— g) â‰« (Î±_ Y Z Z').hom) = (Î±_ Y' X X').inv â‰« (â‡‘((category_theory.tensor_left_hom_equiv X Y Y' Z).symm) f âŠ— g)
theorem category_theory.presieve.is_sheaf_for_iff_yoneda_sheaf_condition {C : Type uâ‚} [category_theory.category C] {X : C} {S : category_theory.sieve X} {P : Cáµ’áµ– â¥¤ Type vâ‚} : category_theory.presieve.is_sheaf_for P â‡‘S â†” category_theory.presieve.yoneda_sheaf_condition P S
theorem padic_norm.sub (p : â„•) [hp : fact (nat.prime p)] {q r : â„š} : padic_norm p (q - r) â‰¤ linear_order.max (padic_norm p q) (padic_norm p r)
theorem add_action.sum_card_fixed_by_eq_card_orbits_add_card_add_group (Î± : Type u) (Î² : Type v) [add_group Î±] [add_action Î± Î²] [fintype Î±] [Î  (a : Î±), fintype â†¥(add_action.fixed_by Î± Î² a)] [fintype (quotient (add_action.orbit_rel Î± Î²))] : finset.univ.sum (Î» (a : Î±), fintype.card â†¥(add_action.fixed_by Î± Î² a)) = fintype.card (quotient (add_action.orbit_rel Î± Î²)) * fintype.card Î±
theorem finsupp.lhom_ext {Î± : Type u_1} {M : Type u_2} {N : Type u_3} {R : Type u_5} [semiring R] [add_comm_monoid M] [module R M] [add_comm_monoid N] [module R N] â¦ƒÏ† Ïˆ : (Î± â†’â‚€ M) â†’â‚—[R] Nâ¦„ (h : âˆ€ (a : Î±) (b : M), â‡‘Ï† (finsupp.single a b) = â‡‘Ïˆ (finsupp.single a b)) : Ï† = Ïˆ
theorem affine_subspace.lt_def {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] (s1 s2 : affine_subspace k P) : s1 < s2 â†” â†‘s1 âŠ‚ â†‘s2
theorem measure_theory.tendsto_in_measure_of_tendsto_snorm_top {Î± : Type u_1} {Î¹ : Type u_2} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {E : Type u_3} [normed_group E] {f : Î¹ â†’ Î± â†’ E} {g : Î± â†’ E} {l : filter Î¹} (hfg : filter.tendsto (Î» (n : Î¹), measure_theory.snorm (f n - g) âŠ¤ Î¼) l (nhds 0)) : measure_theory.tendsto_in_measure Î¼ f l g
theorem orthogonal_projection_norm_le {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] (K : submodule ğ•œ E) [complete_space â†¥K] : âˆ¥orthogonal_projection Kâˆ¥ â‰¤ 1
theorem add_monoid_algebra.mem_adjoin_support {R : Type u_1} {M : Type u_2} [comm_semiring R] [add_monoid M] (f : add_monoid_algebra R M) : f âˆˆ algebra.adjoin R (add_monoid_algebra.of' R M '' â†‘(f.support))
theorem finset.prod_add_prod_le {Î¹ : Type u_1} {R : Type u_8} [ordered_comm_semiring R] {s : finset Î¹} {i : Î¹} {f g h : Î¹ â†’ R} (hi : i âˆˆ s) (h2i : g i + h i â‰¤ f i) (hgf : âˆ€ (j : Î¹), j âˆˆ s â†’ j â‰  i â†’ g j â‰¤ f j) (hhf : âˆ€ (j : Î¹), j âˆˆ s â†’ j â‰  i â†’ h j â‰¤ f j) (hg : âˆ€ (i : Î¹), i âˆˆ s â†’ 0 â‰¤ g i) (hh : âˆ€ (i : Î¹), i âˆˆ s â†’ 0 â‰¤ h i) : s.prod (Î» (i : Î¹), g i) + s.prod (Î» (i : Î¹), h i) â‰¤ s.prod (Î» (i : Î¹), f i)
theorem euclidean_geometry.dist_smul_vadd_sq {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] (r : â„) (v : V) (pâ‚ pâ‚‚ : P) : has_dist.dist (r â€¢ v +áµ¥ pâ‚) pâ‚‚ * has_dist.dist (r â€¢ v +áµ¥ pâ‚) pâ‚‚ = has_inner.inner v v * r * r + 2 * has_inner.inner v (pâ‚ -áµ¥ pâ‚‚) * r + has_inner.inner (pâ‚ -áµ¥ pâ‚‚) (pâ‚ -áµ¥ pâ‚‚)
theorem measure_theory.conservative.frequently_measure_inter_ne_zero {Î± : Type u_2} [measurable_space Î±] {f : Î± â†’ Î±} {s : set Î±} {Î¼ : measure_theory.measure Î±} (hf : measure_theory.conservative f Î¼) (hs : measurable_set s) (h0 : â‡‘Î¼ s â‰  0) : âˆƒá¶  (m : â„•) in filter.at_top, â‡‘Î¼ (s âˆ© f^[m] â»Â¹' s) â‰  0
theorem exists_idempotent_of_compact_t2_of_continuous_add_left {M : Type u_1} [nonempty M] [add_semigroup M] [topological_space M] [compact_space M] [t2_space M] (continuous_mul_left : âˆ€ (r : M), continuous (Î» (_x : M), _x + r)) : âˆƒ (m : M), m + m = m
theorem complex.is_trivial_topological_fiber_bundle_re  : is_trivial_topological_fiber_bundle â„ complex.re
theorem nat.exists_prime_ge_modeq_one {k : â„•} (n : â„•) (hpos : 0 < k) : âˆƒ (p : â„•), nat.prime p âˆ§ n â‰¤ p âˆ§ p â‰¡ 1 [MOD k]
theorem affine.simplex.orthogonal_projection_vadd_smul_vsub_orthogonal_projection {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {n : â„•} (s : affine.simplex â„ P n) {p1 : P} (p2 : P) (r : â„) (hp : p1 âˆˆ affine_span â„ (set.range s.points)) : â‡‘(s.orthogonal_projection_span) (r â€¢ (p2 -áµ¥ â†‘(â‡‘(s.orthogonal_projection_span) p2)) +áµ¥ p1) = âŸ¨p1, hpâŸ©
theorem complex.is_trivial_topological_fiber_bundle_im  : is_trivial_topological_fiber_bundle â„ complex.im
theorem monovary_on.sum_comp_perm_smul_lt_sum_smul_iff {Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [linear_ordered_ring Î±] [linear_ordered_add_comm_group Î²] [module Î± Î²] [ordered_smul Î± Î²] {s : finset Î¹} {Ïƒ : equiv.perm Î¹} {f : Î¹ â†’ Î±} {g : Î¹ â†’ Î²} (hfg : monovary_on f g â†‘s) (hÏƒ : {x : Î¹ | â‡‘Ïƒ x â‰  x} âŠ† â†‘s) : s.sum (Î» (i : Î¹), f (â‡‘Ïƒ i) â€¢ g i) < s.sum (Î» (i : Î¹), f i â€¢ g i) â†” Â¬monovary_on (f âˆ˜ â‡‘Ïƒ) g â†‘s
theorem con.to_setoid_inj {M : Type u_1} [has_mul M] {c d : con M} (H : c.to_setoid = d.to_setoid) : c = d
theorem lie_module.is_weight_zero_of_nilpotent {R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] (M : Type w) [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] [nontrivial M] [lie_algebra.is_nilpotent R L] [lie_module.is_nilpotent R L M] : lie_module.is_weight âŠ¤ M 0
theorem is_topological_fiber_bundle_fst {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] : is_topological_fiber_bundle F prod.fst
theorem map_Sup_of_continuous_at_of_monotone' {Î± : Type u} {Î² : Type v} [complete_linear_order Î±] [topological_space Î±] [order_topology Î±] [complete_linear_order Î²] [topological_space Î²] [order_topology Î²] {f : Î± â†’ Î²} {s : set Î±} (Cf : continuous_at f (has_Sup.Sup s)) (Mf : monotone f) (hs : s.nonempty) : f (has_Sup.Sup s) = has_Sup.Sup (f '' s)
theorem category_theory.adjunction.gc {X : Type u} {Y : Type v} [preorder X] [preorder Y] {L : X â¥¤ Y} {R : Y â¥¤ X} (adj : L âŠ£ R) : galois_connection L.obj R.obj
theorem power_series.eq_X_mul_shift_add_const {R : Type u_1} [semiring R] (Ï† : power_series R) : Ï† = power_series.X * power_series.mk (Î» (p : â„•), â‡‘(power_series.coeff R (p + 1)) Ï†) + â‡‘(power_series.C R) (â‡‘(power_series.constant_coeff R) Ï†)
theorem dense_sUnion_interior_of_closed {Î± : Type u_1} [topological_space Î±] [baire_space Î±] {S : set (set Î±)} (hc : âˆ€ (s : set Î±), s âˆˆ S â†’ is_closed s) (hS : S.countable) (hU : â‹ƒâ‚€S = set.univ) : dense (â‹ƒ (s : set Î±) (H : s âˆˆ S), interior s)
theorem semiconj_by.mul_right {S : Type u} [semigroup S] {a x y x' y' : S} (h : semiconj_by a x y) (h' : semiconj_by a x' y') : semiconj_by a (x * x') (y * y')
theorem power_series.eq_shift_mul_X_add_const {R : Type u_1} [semiring R] (Ï† : power_series R) : Ï† = power_series.mk (Î» (p : â„•), â‡‘(power_series.coeff R (p + 1)) Ï†) * power_series.X + â‡‘(power_series.C R) (â‡‘(power_series.constant_coeff R) Ï†)
theorem real.Lp_add_le {Î¹ : Type u} (s : finset Î¹) (f g : Î¹ â†’ â„) {p : â„} (hp : 1 â‰¤ p) : s.sum (Î» (i : Î¹), |f i + g i| ^ p) ^ (1 / p) â‰¤ s.sum (Î» (i : Î¹), |f i| ^ p) ^ (1 / p) + s.sum (Î» (i : Î¹), |g i| ^ p) ^ (1 / p)
theorem orientation.two_zsmul_oangle_neg_right {V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) (x y : V) : 2 â€¢ o.oangle x (-y) = 2 â€¢ o.oangle x y
theorem monovary_on.sum_mul_comp_perm_le_sum_mul {Î¹ : Type u_1} {Î± : Type u_2} [linear_ordered_ring Î±] {s : finset Î¹} {Ïƒ : equiv.perm Î¹} {f g : Î¹ â†’ Î±} (hfg : monovary_on f g â†‘s) (hÏƒ : {x : Î¹ | â‡‘Ïƒ x â‰  x} âŠ† â†‘s) : s.sum (Î» (i : Î¹), f i * g (â‡‘Ïƒ i)) â‰¤ s.sum (Î» (i : Î¹), f i * g i)
theorem orthogonal_family.has_sum_linear_isometry_equiv_symm {Î¹ : Type u_1} {ğ•œ : Type u_2} [is_R_or_C ğ•œ] {E : Type u_3} [inner_product_space ğ•œ E] [cplt : complete_space E] {G : Î¹ â†’ Type u_4} [Î  (i : Î¹), inner_product_space ğ•œ (G i)] {V : Î  (i : Î¹), G i â†’â‚—áµ¢[ğ•œ] E} (hV : orthogonal_family ğ•œ V) [âˆ€ (i : Î¹), complete_space (G i)] (hV' : (â¨† (i : Î¹), (V i).to_linear_map.range).topological_closure = âŠ¤) (w : â†¥(lp G 2)) : has_sum (Î» (i : Î¹), â‡‘(V i) (â‡‘w i)) (â‡‘((hV.linear_isometry_equiv hV').symm) w)
theorem antitone.covariant_of_const' {N : Type u_2} {Î± : Type u_3} [preorder Î±] [preorder N] {f : N â†’ Î±} {Î¼ : N â†’ N â†’ N} [covariant_class N N (function.swap Î¼) has_le.le] (hf : antitone f) (m : N) : antitone (Î» (n : N), f (Î¼ n m))
theorem laurent_polynomial.induction_on' {R : Type u_1} [semiring R] {M : laurent_polynomial R â†’ Prop} (p : laurent_polynomial R) (h_add : âˆ€ (p q : laurent_polynomial R), M p â†’ M q â†’ M (p + q)) (h_C_mul_T : âˆ€ (n : â„¤) (a : R), M (â‡‘laurent_polynomial.C a * laurent_polynomial.T n)) : M p
theorem orthonormal.inner_left_sum {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {Î¹ : Type u_4} {v : Î¹ â†’ E} (hv : orthonormal ğ•œ v) (l : Î¹ â†’ ğ•œ) {s : finset Î¹} {i : Î¹} (hi : i âˆˆ s) : has_inner.inner (s.sum (Î» (i : Î¹), l i â€¢ v i)) (v i) = â‡‘(star_ring_end ğ•œ) (l i)
theorem subring.mem_supr_of_directed {R : Type u} [ring R] {Î¹ : Sort u_1} [hÎ¹ : nonempty Î¹] {S : Î¹ â†’ subring R} (hS : directed has_le.le S) {x : R} : (x âˆˆ â¨† (i : Î¹), S i) â†” âˆƒ (i : Î¹), x âˆˆ S i
theorem euclidean_geometry.dist_eq_add_dist_iff_angle_eq_pi {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {p1 p2 p3 : P} (hp1p2 : p1 â‰  p2) (hp3p2 : p3 â‰  p2) : has_dist.dist p1 p3 = has_dist.dist p1 p2 + has_dist.dist p3 p2 â†” euclidean_geometry.angle p1 p2 p3 = real.pi
theorem module.nontrivial (R : Type u_1) (M : Type u_2) [semiring R] [nontrivial M] [add_comm_monoid M] [module R M] : nontrivial R
theorem antitone.max {Î± : Type u} {Î² : Type v} [preorder Î±] [linear_order Î²] {f g : Î± â†’ Î²} (hf : antitone f) (hg : antitone g) : antitone (Î» (x : Î±), linear_order.max (f x) (g x))
theorem formal_multilinear_series.left_inv_eq_right_inv {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] (p : formal_multilinear_series ğ•œ E F) (i : E â‰ƒL[ğ•œ] F) (h : p 1 = â‡‘((continuous_multilinear_curry_fin1 ğ•œ E F).symm) â†‘i) : p.left_inv i = p.right_inv i
theorem function.embedding.schroeder_bernstein {Î± : Type u} {Î² : Type v} {f : Î± â†’ Î²} {g : Î² â†’ Î±} (hf : function.injective f) (hg : function.injective g) : âˆƒ (h : Î± â†’ Î²), function.bijective h
theorem right.mul_le_one {Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_mul.mul) has_le.le] {a b : Î±} (ha : a â‰¤ 1) (hb : b â‰¤ 1) : a * b â‰¤ 1
theorem submodule.dim_sup_add_dim_inf_eq {K : Type u} {V : Type v} [field K] [add_comm_group V] [module K V] (s t : submodule K V) [finite_dimensional K â†¥s] [finite_dimensional K â†¥t] : finite_dimensional.finrank K â†¥(s âŠ” t) + finite_dimensional.finrank K â†¥(s âŠ“ t) = finite_dimensional.finrank K â†¥s + finite_dimensional.finrank K â†¥t
theorem ideal.polynomial.jacobson_bot_of_integral_localization {S : Type u_2} [comm_ring S] [is_domain S] {R : Type u_1} [comm_ring R] [is_domain R] [ideal.is_jacobson R] (Râ‚˜ : Type u_3) (Sâ‚˜ : Type u_4) [comm_ring Râ‚˜] [comm_ring Sâ‚˜] (Ï† : R â†’+* S) (hÏ† : function.injective â‡‘Ï†) (x : R) (hx : x â‰  0) [algebra R Râ‚˜] [is_localization.away x Râ‚˜] [algebra S Sâ‚˜] [is_localization (submonoid.map â†‘Ï† (submonoid.powers x)) Sâ‚˜] (hÏ†' : (is_localization.map Sâ‚˜ Ï† _).is_integral) : âŠ¥.jacobson = âŠ¥
theorem mul_eq_mul_prime_prod {R : Type u_1} [cancel_comm_monoid_with_zero R] {Î± : Type u_2} [decidable_eq Î±] {x y a : R} {s : finset Î±} {p : Î± â†’ R} (hp : âˆ€ (i : Î±), i âˆˆ s â†’ prime (p i)) (hx : x * y = a * s.prod (Î» (i : Î±), p i)) : âˆƒ (t u : finset Î±) (b c : R), t âˆª u = s âˆ§ disjoint t u âˆ§ a = b * c âˆ§ x = b * t.prod (Î» (i : Î±), p i) âˆ§ y = c * u.prod (Î» (i : Î±), p i)
theorem compact_covered_by_add_left_translates {G : Type w} [topological_space G] [add_group G] [topological_add_group G] {K V : set G} (hK : is_compact K) (hV : (interior V).nonempty) : âˆƒ (t : finset G), K âŠ† â‹ƒ (g : G) (H : g âˆˆ t), (Î» (h : G), g + h) â»Â¹' V
theorem nat.prime.multiplicity_choose {p n k b : â„•} (hp : nat.prime p) (hkn : k â‰¤ n) (hnb : nat.log p n < b) : multiplicity p (n.choose k) = â†‘((finset.filter (Î» (i : â„•), p ^ i â‰¤ k % p ^ i + (n - k) % p ^ i) (finset.Ico 1 b)).card)
theorem subsemigroup.closure_le {M : Type u_1} [has_mul M] {s : set M} {S : subsemigroup M} : subsemigroup.closure s â‰¤ S â†” s âŠ† â†‘S
theorem finset.prod_cancels_of_partition_cancels {Î² : Type u} {Î± : Type v} {s : finset Î±} {f : Î± â†’ Î²} [comm_monoid Î²] (R : setoid Î±) [decidable_rel setoid.r] (h : âˆ€ (x : Î±), x âˆˆ s â†’ (finset.filter (Î» (y : Î±), y â‰ˆ x) s).prod (Î» (a : Î±), f a) = 1) : s.prod (Î» (x : Î±), f x) = 1
theorem setoid.eq_of_mem_classes {Î± : Type u_1} {r : setoid Î±} {x : Î±} {b : set Î±} (hc : b âˆˆ r.classes) (hb : x âˆˆ b) {b' : set Î±} (hc' : b' âˆˆ r.classes) (hb' : x âˆˆ b') : b = b'
theorem eq_rec_constant {Î± : Sort u_1} {a a' : Î±} {Î² : Sort u_2} (y : Î²) (h : a = a') : eq.rec y h = y
theorem free_group.red.step.length {Î± : Type u} {Lâ‚ Lâ‚‚ : list (Î± Ã— bool)} : free_group.red.step Lâ‚ Lâ‚‚ â†’ Lâ‚‚.length + 2 = Lâ‚.length
theorem concave_on.translate_right {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [ordered_semiring ğ•œ] [add_comm_monoid E] [ordered_add_comm_monoid Î²] [module ğ•œ E] [has_scalar ğ•œ Î²] {s : set E} {f : E â†’ Î²} (hf : concave_on ğ•œ s f) (c : E) : concave_on ğ•œ ((Î» (z : E), c + z) â»Â¹' s) (f âˆ˜ Î» (z : E), c + z)
theorem strict_convex.affine_preimage {ğ•œ : Type u_1} {E : Type u_3} {F : Type u_4} [ordered_ring ğ•œ] [topological_space E] [topological_space F] [add_comm_group E] [add_comm_group F] [module ğ•œ E] [module ğ•œ F] {s : set F} (hs : strict_convex ğ•œ s) {f : E â†’áµƒ[ğ•œ] F} (hf : continuous â‡‘f) (hfinj : function.injective â‡‘f) : strict_convex ğ•œ (â‡‘f â»Â¹' s)
theorem submodule.is_internal_prime_power_torsion_of_pid {R : Type u} [comm_ring R] [is_domain R] [is_principal_ideal_ring R] {M : Type v} [add_comm_group M] [module R M] [module.finite R M] (hM : module.is_torsion R M) : âˆƒ (Î¹ : Type u) [_inst_9 : fintype Î¹] [_inst_10 : decidable_eq Î¹] (p : Î¹ â†’ R) [_inst_11 : âˆ€ (i : Î¹), irreducible (p i)] (e : Î¹ â†’ â„•), direct_sum.is_internal (Î» (i : Î¹), submodule.torsion_by R M (p i ^ e i))
theorem char.quadratic_char_dichotomy {F : Type u_1} [field F] [fintype F] [decidable_eq F] {a : F} (ha : a â‰  0) : char.quadratic_char F a = 1 âˆ¨ char.quadratic_char F a = -1
theorem orthogonal_projection_bot {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] : orthogonal_projection âŠ¥ = 0
theorem mul_is_left_regular_iff {R : Type u_1} {a : R} [semigroup R] (b : R) (ha : is_left_regular a) : is_left_regular (a * b) â†” is_left_regular b
theorem le_inv_mul_of_mul_le {Î± : Type u} [group Î±] [has_le Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a b c : Î±} : a * b â‰¤ c â†’ b â‰¤ aâ»Â¹ * c
theorem nat.gcd_eq_gcd_ab (x y : â„•) : â†‘(x.gcd y) = â†‘x * x.gcd_a y + â†‘y * x.gcd_b y
theorem gram_schmidt_orthogonal (ğ•œ : Type u_1) {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {Î¹ : Type u_3} [linear_order Î¹] [order_bot Î¹] [locally_finite_order Î¹] [is_well_order Î¹ has_lt.lt] (f : Î¹ â†’ E) {a b : Î¹} (hâ‚€ : a â‰  b) : has_inner.inner (gram_schmidt ğ•œ f a) (gram_schmidt ğ•œ f b) = 0
theorem measure_theory.lintegral_eq_zero_of_is_add_left_invariant {G : Type u_4} [measurable_space G] {Î¼ : measure_theory.measure G} [topological_space G] [add_group G] [topological_add_group G] [borel_space G] [Î¼.is_add_left_invariant] [Î¼.regular] (hÎ¼ : Î¼ â‰  0) {f : G â†’ ennreal} (hf : continuous f) : âˆ«â» (x : G), f x âˆ‚Î¼ = 0 â†” f = 0
theorem vector_span_mono (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {sâ‚ sâ‚‚ : set P} (h : sâ‚ âŠ† sâ‚‚) : vector_span k sâ‚ â‰¤ vector_span k sâ‚‚
theorem submonoid.localization_map.lift_mul_right {M : Type u_1} [comm_monoid M] {S : submonoid M} {N : Type u_2} [comm_monoid N] {P : Type u_3} [comm_monoid P] (f : S.localization_map N) {g : M â†’* P} (hg : âˆ€ (y : â†¥S), is_unit (â‡‘g â†‘y)) (z : N) : â‡‘(f.lift hg) z * â‡‘g â†‘((f.sec z).snd) = â‡‘g (f.sec z).fst
theorem ereal.neg_le_of_neg_le {a b : ereal} (h : -a â‰¤ b) : -b â‰¤ a
theorem is_seq_closed_iff_is_closed {X : Type u_1} [topological_space X] [sequential_space X] {s : set X} : is_seq_closed s â†” is_closed s
theorem has_fderiv_at.le_of_lip {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {f : E â†’ F} {f' : E â†’L[ğ•œ] F} {xâ‚€ : E} (hf : has_fderiv_at f f' xâ‚€) {s : set E} (hs : s âˆˆ nhds xâ‚€) {C : nnreal} (hlip : lipschitz_on_with C f s) : âˆ¥f'âˆ¥ â‰¤ â†‘C
theorem pow_four_add_four_mul_pow_four {R : Type u_1} [comm_ring R] {a b : R} : a ^ 4 + 4 * b ^ 4 = ((a - b) ^ 2 + b ^ 2) * ((a + b) ^ 2 + b ^ 2)
theorem matrix.inv_of_mul_self {n : Type u'} {Î± : Type v} [fintype n] [decidable_eq n] [comm_ring Î±] (A : matrix n n Î±) [invertible A] : (â…Ÿ A).mul A = 1
theorem subfield.prod_mem {K : Type u} [field K] (s : subfield K) {Î¹ : Type u_1} {t : finset Î¹} {f : Î¹ â†’ K} (h : âˆ€ (c : Î¹), c âˆˆ t â†’ f c âˆˆ s) : t.prod (Î» (i : Î¹), f i) âˆˆ s
theorem continuous_map.congr_arg {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] (f : C(Î±, Î²)) {x y : Î±} (h : x = y) : â‡‘f x = â‡‘f y
theorem zero_lt.left.one_lt_mul_of_le_of_lt {Î± : Type u} {a b : Î±} [mul_one_class Î±] [has_zero Î±] [preorder Î±] [zero_lt.pos_mul_strict_mono Î±] (ha : 1 â‰¤ a) (hb : 1 < b) (a0 : 0 < a) : 1 < a * b
theorem continuous_linear_map.adjoint_inner_left {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] [inner_product_space ğ•œ F] [complete_space E] [complete_space F] (A : E â†’L[ğ•œ] F) (x : E) (y : F) : has_inner.inner (â‡‘(â‡‘continuous_linear_map.adjoint A) y) x = has_inner.inner y (â‡‘A x)
theorem lie_module.coe_lower_central_series_ideal_le {R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] {I : lie_ideal R L} (k : â„•) : â†‘(lie_module.lower_central_series R â†¥I â†¥I k) â‰¤ â†‘(lie_module.lower_central_series R L â†¥I k)
theorem finite_dimensional.finrank_eq_card_finset_basis {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {Î¹ : Type w} {b : finset Î¹} (h : basis â†¥b K V) : finite_dimensional.finrank K V = b.card
theorem fin.nat_add_cast {n n' : â„•} (m : â„•) (i : fin n') (h : n' = n) : â‡‘(fin.nat_add m) (â‡‘(fin.cast h) i) = â‡‘(fin.cast _) (â‡‘(fin.nat_add m) i)
theorem monoid_hom.congr_arg {M : Type u_3} {N : Type u_4} [mul_one_class M] [mul_one_class N] (f : M â†’* N) {x y : M} (h : x = y) : â‡‘f x = â‡‘f y
theorem measurable_of_tendsto_nnreal {Î± : Type u_1} [measurable_space Î±] {f : â„• â†’ Î± â†’ nnreal} {g : Î± â†’ nnreal} (hf : âˆ€ (i : â„•), measurable (f i)) (lim : filter.tendsto f filter.at_top (nhds g)) : measurable g
theorem pgame.lf_zero_le {x : pgame} : x.lf 0 â†” âˆƒ (j : x.right_moves), x.move_right j â‰¤ 0
theorem asymptotics.is_O.neg_left {Î± : Type u_1} {F : Type u_4} {E' : Type u_6} [has_norm F] [semi_normed_group E'] {g : Î± â†’ F} {f' : Î± â†’ E'} {l : filter Î±} : f' =O[l] g â†’ (Î» (x : Î±), -f' x) =O[l] g
theorem category_theory.limits.pushout.hom_ext {C : Type u} [category_theory.category C] {X Y Z : C} {f : X âŸ¶ Y} {g : X âŸ¶ Z} [category_theory.limits.has_pushout f g] {W : C} {k l : category_theory.limits.pushout f g âŸ¶ W} (hâ‚€ : category_theory.limits.pushout.inl â‰« k = category_theory.limits.pushout.inl â‰« l) (hâ‚ : category_theory.limits.pushout.inr â‰« k = category_theory.limits.pushout.inr â‰« l) : k = l
theorem monotone.dual_left {Î± : Type u} {Î² : Type v} [preorder Î±] [preorder Î²] {f : Î± â†’ Î²} : monotone f â†’ antitone (f âˆ˜ â‡‘order_dual.of_dual)
theorem interval_integral.integral_le_sub_of_has_deriv_right_of_le {a b : â„} {g' g Ï† : â„ â†’ â„} (hab : a â‰¤ b) (hcont : continuous_on g (set.Icc a b)) (hderiv : âˆ€ (x : â„), x âˆˆ set.Ioo a b â†’ has_deriv_within_at g (g' x) (set.Ioi x) x) (Ï†int : measure_theory.integrable_on Ï† (set.Icc a b) measure_theory.measure_space.volume) (hÏ†g : âˆ€ (x : â„), x âˆˆ set.Ioo a b â†’ Ï† x â‰¤ g' x) : âˆ« (y : â„) in a..b, Ï† y â‰¤ g b - g a
theorem exp_series_radius_eq_top (ğ•‚ : Type u_1) (ğ”¸ : Type u_2) [is_R_or_C ğ•‚] [normed_ring ğ”¸] [normed_algebra ğ•‚ ğ”¸] : (exp_series ğ•‚ ğ”¸).radius = âŠ¤
theorem ring_hom.eq_on_field_closure {K : Type u} {L : Type v} [field K] [field L] {f g : K â†’+* L} {s : set K} (h : set.eq_on â‡‘f â‡‘g s) : set.eq_on â‡‘f â‡‘g â†‘(subfield.closure s)
theorem affine_subspace.eq_iff_direction_eq_of_mem {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {sâ‚ sâ‚‚ : affine_subspace k P} {p : P} (hâ‚ : p âˆˆ sâ‚) (hâ‚‚ : p âˆˆ sâ‚‚) : sâ‚ = sâ‚‚ â†” sâ‚.direction = sâ‚‚.direction
theorem category_theory.limits.has_strict_terminal_objects_of_terminal_is_strict {C : Type u} [category_theory.category C] (I : C) (h : âˆ€ (A : C) (f : I âŸ¶ A), category_theory.is_iso f) : category_theory.limits.has_strict_terminal_objects C
theorem unique_factorization_monoid.dvd_of_dvd_mul_right_of_no_prime_factors {R : Type u_2} [cancel_comm_monoid_with_zero R] [unique_factorization_monoid R] {a b c : R} (ha : a â‰  0) (no_factors : âˆ€ {d : R}, d âˆ£ a â†’ d âˆ£ b â†’ Â¬prime d) : a âˆ£ b * c â†’ a âˆ£ c
theorem affine_subspace.affine_span_eq_top_iff_vector_span_eq_top_of_nontrivial (k : Type u_1) (V : Type u_2) (P : Type u_3) [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {s : set P} [nontrivial P] : affine_span k s = âŠ¤ â†” vector_span k s = âŠ¤
theorem category_theory.sheaf.subcanonical.is_sheaf_of_representable {C : Type u} [category_theory.category C] {J : category_theory.grothendieck_topology C} (hJ : category_theory.sheaf.subcanonical J) (P : Cáµ’áµ– â¥¤ Type v) [P.representable] : category_theory.presieve.is_sheaf J P
theorem dense_iff_inter_open {Î± : Type u} [topological_space Î±] {s : set Î±} : dense s â†” âˆ€ (U : set Î±), is_open U â†’ U.nonempty â†’ (U âˆ© s).nonempty
theorem finset.subset_vadd {Î± : Type u_2} {Î² : Type u_3} [decidable_eq Î²] [has_vadd Î± Î²] {u : finset Î²} {s : set Î±} {t : set Î²} : â†‘u âŠ† s +áµ¥ t â†’ (âˆƒ (s' : finset Î±) (t' : finset Î²), â†‘s' âŠ† s âˆ§ â†‘t' âŠ† t âˆ§ u âŠ† s' +áµ¥ t')
theorem orthogonal_projection_unit_singleton (ğ•œ : Type u_1) {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {v : E} (hv : âˆ¥vâˆ¥ = 1) (w : E) : â†‘(â‡‘(orthogonal_projection (submodule.span ğ•œ {v})) w) = has_inner.inner v w â€¢ v
theorem zero_lt.left.one_lt_mul_of_lt_of_le {Î± : Type u} {a b : Î±} [mul_one_class Î±] [has_zero Î±] [preorder Î±] [zero_lt.pos_mul_mono Î±] (ha : 1 < a) (hb : 1 â‰¤ b) (a0 : 0 < a) : 1 < a * b
theorem finsum_mem_add_diff' {Î± : Type u_1} {M : Type u_5} [add_comm_monoid M] {f : Î± â†’ M} {s t : set Î±} (hst : s âŠ† t) (ht : (t âˆ© function.support f).finite) : finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), f i)) + finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ t  s), f i)) = finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ t), f i))
theorem abs_real_inner_div_norm_mul_norm_eq_one_iff {F : Type u_3} [inner_product_space â„ F] (x y : F) : |has_inner.inner x y / (âˆ¥xâˆ¥ * âˆ¥yâˆ¥)| = 1 â†” x â‰  0 âˆ§ âˆƒ (r : â„), r â‰  0 âˆ§ y = r â€¢ x
theorem exists_subset_is_orthonormal_basis {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {v : set E} [finite_dimensional ğ•œ E] (hv : orthonormal ğ•œ coe) : âˆƒ (u : set E) (H : u âŠ‡ v) (b : basis â†¥u ğ•œ E), orthonormal ğ•œ â‡‘b âˆ§ â‡‘b = coe
theorem real.Inf_nonpos (S : set â„) (hS : âˆ€ (x : â„), x âˆˆ S â†’ x â‰¤ 0) : has_Inf.Inf S â‰¤ 0
theorem measure_theory.mul_le_add_haar_image_of_lt_det {E : Type u_1} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] [measurable_space E] [borel_space E] (Î¼ : measure_theory.measure E) [Î¼.is_add_haar_measure] (A : E â†’L[â„] E) {m : nnreal} (hm : â†‘m < ennreal.of_real |A.det|) : âˆ€á¶  (Î´ : nnreal) in nhds_within 0 (set.Ioi 0), âˆ€ (s : set E) (f : E â†’ E), approximates_linear_on f A s Î´ â†’ â†‘m * â‡‘Î¼ s â‰¤ â‡‘Î¼ (f '' s)
theorem submodule.sup_orthogonal_inf_of_complete_space {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {Kâ‚ Kâ‚‚ : submodule ğ•œ E} (h : Kâ‚ â‰¤ Kâ‚‚) [complete_space â†¥Kâ‚] : Kâ‚ âŠ” Kâ‚á—® âŠ“ Kâ‚‚ = Kâ‚‚
theorem euclidean_geometry.circumradius_eq_of_cospherical_subset {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace â„ P} {ps : set P} (h : ps âŠ† â†‘s) [nonempty â†¥s] {n : â„•} [finite_dimensional â„ â†¥(s.direction)] (hd : finite_dimensional.finrank â„ â†¥(s.direction) = n) (hc : euclidean_geometry.cospherical ps) {sxâ‚ sxâ‚‚ : affine.simplex â„ P n} (hsxâ‚ : set.range sxâ‚.points âŠ† ps) (hsxâ‚‚ : set.range sxâ‚‚.points âŠ† ps) : sxâ‚.circumradius = sxâ‚‚.circumradius
theorem function.surjective.comp_left {Î± : Sort u} {Î² : Sort v} {Î³ : Sort w} {g : Î² â†’ Î³} (hg : function.surjective g) : function.surjective (function.comp g)
theorem has_deriv_within_at.Ioi_of_Ici {ğ•œ : Type u} [nondiscrete_normed_field ğ•œ] {F : Type v} [normed_group F] [normed_space ğ•œ F] {f : ğ•œ â†’ F} {f' : F} {x : ğ•œ} [partial_order ğ•œ] : has_deriv_within_at f f' (set.Ici x) x â†’ has_deriv_within_at f f' (set.Ioi x) x
theorem euclidean_geometry.cospherical_empty {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] : euclidean_geometry.cospherical âˆ…
theorem set.eq_of_Ico_disjoint {Î± : Type v} [linear_order Î±] {xâ‚ xâ‚‚ yâ‚ yâ‚‚ : Î±} (h : disjoint (set.Ico xâ‚ xâ‚‚) (set.Ico yâ‚ yâ‚‚)) (hx : xâ‚ < xâ‚‚) (h2 : xâ‚‚ âˆˆ set.Ico yâ‚ yâ‚‚) : yâ‚ = xâ‚‚
theorem power_series.span_X_is_prime {R : Type u_1} [comm_ring R] [is_domain R] : (ideal.span {power_series.X}).is_prime
theorem polynomial.gal.gal_action_hom_injective {F : Type u_1} [field F] (p : polynomial F) (E : Type u_2) [field E] [algebra F E] [fact (polynomial.splits (algebra_map F E) p)] : function.injective â‡‘(polynomial.gal.gal_action_hom p E)
theorem measure_theory.signed_measure.to_signed_measure_to_jordan_decomposition {Î± : Type u_1} [measurable_space Î±] (s : measure_theory.signed_measure Î±) : s.to_jordan_decomposition.to_signed_measure = s
theorem category_theory.limits.has_coequalizers_of_has_colimit_parallel_pair (C : Type u) [category_theory.category C] [âˆ€ {X Y : C} {f g : X âŸ¶ Y}, category_theory.limits.has_colimit (category_theory.limits.parallel_pair f g)] : category_theory.limits.has_coequalizers C
theorem affine_subspace.vsub_right_mem_direction_iff_mem {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : affine_subspace k P} {p : P} (hp : p âˆˆ s) (p2 : P) : p2 -áµ¥ p âˆˆ s.direction â†” p2 âˆˆ s
theorem continuous_within_at.integral_sub_linear_is_o_ae {Î± : Type u_1} {E : Type u_3} [measurable_space Î±] {Î¹ : Type u_5} [normed_group E] [topological_space Î±] [opens_measurable_space Î±] [normed_space â„ E] [complete_space E] {Î¼ : measure_theory.measure Î±} [measure_theory.is_locally_finite_measure Î¼] {a : Î±} {t : set Î±} {f : Î± â†’ E} (ha : continuous_within_at f t a) (ht : measurable_set t) (hfm : strongly_measurable_at_filter f (nhds_within a t) Î¼) {s : Î¹ â†’ set Î±} {li : filter Î¹} (hs : filter.tendsto s li (nhds_within a t).small_sets) (m : Î¹ â†’ â„ := Î» (i : Î¹), (â‡‘Î¼ (s i)).to_real) (hsÎ¼ : (Î» (i : Î¹), (â‡‘Î¼ (s i)).to_real) =á¶ [li] m . "refl") : (Î» (i : Î¹), âˆ« (x : Î±) in s i, f x âˆ‚Î¼ - m i â€¢ f a) =o[li] m
theorem matrix.pivot.list_transvec_col_mul_last_col {ğ•œ : Type u_3} [field ğ•œ] {r : â„•} (M : matrix (fin r âŠ• unit) (fin r âŠ• unit) ğ•œ) (hM : M (sum.inr ()) (sum.inr ()) â‰  0) (i : fin r) : (matrix.pivot.list_transvec_col M).prod.mul M (sum.inl i) (sum.inr ()) = 0
theorem has_deriv_at.has_fderiv_at {ğ•œ : Type u} [nondiscrete_normed_field ğ•œ] {F : Type v} [normed_group F] [normed_space ğ•œ F] {f : ğ•œ â†’ F} {x : ğ•œ} {f' : F} : has_deriv_at f f' x â†’ has_fderiv_at f (1.smul_right f') x
theorem nat.factorization_central_binom_eq_zero_of_two_mul_lt {p n : â„•} (h : 2 * n < p) : â‡‘(n.central_binom.factorization) p = 0
theorem semiconj_by.conj_mk {G : Type u} [group G] (a x : G) : semiconj_by a x (a * x * aâ»Â¹)
theorem has_deriv_at_interval_right_endpoint_of_tendsto_deriv {E : Type u_1} [normed_group E] [normed_space â„ E] {s : set â„} {e : E} {a : â„} {f : â„ â†’ E} (f_diff : differentiable_on â„ f s) (f_lim : continuous_within_at f s a) (hs : s âˆˆ nhds_within a (set.Iio a)) (f_lim' : filter.tendsto (Î» (x : â„), deriv f x) (nhds_within a (set.Iio a)) (nhds e)) : has_deriv_within_at f e (set.Iic a) a
theorem laurent_polynomial.reduce_to_polynomial_of_mul_T {R : Type u_1} [semiring R] (f : laurent_polynomial R) {Q : laurent_polynomial R â†’ Prop} (Qf : âˆ€ (f : polynomial R), Q (â‡‘polynomial.to_laurent f)) (QT : âˆ€ (f : laurent_polynomial R), Q (f * laurent_polynomial.T 1) â†’ Q f) : Q f
theorem representation.average_map_id {k : Type u_1} {G : Type u_2} {V : Type u_3} [comm_semiring k] [group G] [add_comm_monoid V] [module k V] (Ï : representation k G V) [fintype G] [invertible â†‘(fintype.card G)] (v : V) (hv : v âˆˆ Ï.invariants) : â‡‘(Ï.average_map) v = v
theorem subgroup.fg_iff_submonoid_fg {G : Type u_3} [group G] (P : subgroup G) : P.fg â†” P.to_submonoid.fg
theorem has_compact_support.has_fderiv_at_convolution_right {ğ•œ : Type u_1} {G : Type u_2} {E : Type u_3} {E' : Type u_4} {F : Type u_6} [normed_group E] [normed_group E'] [normed_group F] {f : G â†’ E} {g : G â†’ E'} [is_R_or_C ğ•œ] [normed_space ğ•œ E] [normed_space ğ•œ E'] [normed_space â„ F] [normed_space ğ•œ F] [complete_space F] [measurable_space G] {Î¼ : measure_theory.measure G} (L : E â†’L[ğ•œ] E' â†’L[ğ•œ] F) [normed_group G] [borel_space G] [topological_space.second_countable_topology G] [sigma_compact_space G] [measure_theory.sigma_finite Î¼] [Î¼.is_add_left_invariant] [normed_space ğ•œ G] [proper_space G] (hcg : has_compact_support g) (hf : measure_theory.locally_integrable f Î¼) (hg : cont_diff ğ•œ 1 g) (xâ‚€ : G) : has_fderiv_at (convolution f g L Î¼) (convolution f (fderiv ğ•œ g) (continuous_linear_map.precompR G L) Î¼ xâ‚€) xâ‚€
theorem geometry.simplicial_complex.face_subset_face_iff {ğ•œ : Type u_1} {E : Type u_2} [ordered_ring ğ•œ] [add_comm_group E] [module ğ•œ E] {K : geometry.simplicial_complex ğ•œ E} {s t : finset E} (hs : s âˆˆ K.faces) (ht : t âˆˆ K.faces) : â‡‘(convex_hull ğ•œ) â†‘s âŠ† â‡‘(convex_hull ğ•œ) â†‘t â†” s âŠ† t
theorem category_theory.any_functor_const_on_obj {J : Type uâ‚} [category_theory.category J] [category_theory.is_preconnected J] {Î± : Type uâ‚} (F : J â¥¤ category_theory.discrete Î±) (j j' : J) : F.obj j = F.obj j'
theorem box_integral.has_integral_zero_of_ae_eq_zero {Î¹ : Type u} {E : Type v} [fintype Î¹] [normed_group E] [normed_space â„ E] {l : box_integral.integration_params} {I : box_integral.box Î¹} {f : (Î¹ â†’ â„) â†’ E} {Î¼ : measure_theory.measure (Î¹ â†’ â„)} [measure_theory.is_locally_finite_measure Î¼] (hf : f =áµ[Î¼.restrict â†‘I] 0) (hl : l.bRiemann = bool.ff) : box_integral.has_integral I l f Î¼.to_box_additive.to_smul 0
theorem measure_theory.tendsto_in_measure_of_tendsto_snorm_of_strongly_measurable {Î± : Type u_1} {Î¹ : Type u_2} {E : Type u_3} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [normed_group E] {p : ennreal} {f : Î¹ â†’ Î± â†’ E} {g : Î± â†’ E} (hp_ne_zero : p â‰  0) (hp_ne_top : p â‰  âŠ¤) (hf : âˆ€ (n : Î¹), measure_theory.strongly_measurable (f n)) (hg : measure_theory.strongly_measurable g) {l : filter Î¹} (hfg : filter.tendsto (Î» (n : Î¹), measure_theory.snorm (f n - g) p Î¼) l (nhds 0)) : measure_theory.tendsto_in_measure Î¼ f l g
theorem continuous_on.surj_on_Icc {Î± : Type u} [conditionally_complete_linear_order Î±] [topological_space Î±] [order_topology Î±] [densely_ordered Î±] {Î´ : Type u_1} [linear_order Î´] [topological_space Î´] [order_closed_topology Î´] {s : set Î±} [hs : s.ord_connected] {f : Î± â†’ Î´} (hf : continuous_on f s) {a b : Î±} (ha : a âˆˆ s) (hb : b âˆˆ s) : set.surj_on f s (set.Icc (f a) (f b))
theorem sequentially_complete.le_nhds_of_seq_tendsto_nhds {Î± : Type u} [uniform_space Î±] {f : filter Î±} (hf : cauchy f) {U : â„• â†’ set (Î± Ã— Î±)} (U_mem : âˆ€ (n : â„•), U n âˆˆ uniformity Î±) (U_le : âˆ€ (s : set (Î± Ã— Î±)), s âˆˆ uniformity Î± â†’ (âˆƒ (n : â„•), U n âŠ† s)) â¦ƒa : Î±â¦„ (ha : filter.tendsto (sequentially_complete.seq hf U_mem) filter.at_top (nhds a)) : f â‰¤ nhds a
theorem category_theory.comp_left_adjoint_mate {C : Type uâ‚} [category_theory.category C] [category_theory.monoidal_category C] {X Y Z : C} [category_theory.has_left_dual X] [category_theory.has_left_dual Y] [category_theory.has_left_dual Z] {f : X âŸ¶ Y} {g : Y âŸ¶ Z} : á˜(f â‰« g) = á˜g â‰« á˜f
theorem is_lub.union {Î³ : Type w} [semilattice_sup Î³] {a b : Î³} {s t : set Î³} (hs : is_lub s a) (ht : is_lub t b) : is_lub (s âˆª t) (a âŠ” b)
theorem continuous_linear_map.is_compact_image_coe_of_bounded_of_closed_image {ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {F : Type u_6} [normed_group F] [nondiscrete_normed_field ğ•œ] [nondiscrete_normed_field ğ•œâ‚‚] [normed_space ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} {E' : Type u_10} [semi_normed_group E'] [normed_space ğ•œ E'] [ring_hom_isometric Ïƒâ‚â‚‚] [proper_space F] {s : set (E' â†’SL[Ïƒâ‚â‚‚] F)} (hb : metric.bounded s) (hc : is_closed (coe_fn '' s)) : is_compact (coe_fn '' s)
theorem ratfunc.num_div_dvd' {K : Type u} [hfield : field K] (p : polynomial K) {q : polynomial K} (hq : q â‰  0) : â‡‘polynomial.C ((q / gcd_monoid.gcd p q).leading_coeff)â»Â¹ * (p / gcd_monoid.gcd p q) âˆ£ p
theorem affine_independent_iff_indicator_eq_of_affine_combination_eq (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {Î¹ : Type u_4} (p : Î¹ â†’ P) : affine_independent k p â†” âˆ€ (s1 s2 : finset Î¹) (w1 w2 : Î¹ â†’ k), s1.sum (Î» (i : Î¹), w1 i) = 1 â†’ s2.sum (Î» (i : Î¹), w2 i) = 1 â†’ â‡‘(s1.affine_combination p) w1 = â‡‘(s2.affine_combination p) w2 â†’ â†‘s1.indicator w1 = â†‘s2.indicator w2
theorem submodule.fg_ker_comp {R : Type u_1} {M : Type u_2} {N : Type u_3} {P : Type u_4} [ring R] [add_comm_group M] [module R M] [add_comm_group N] [module R N] [add_comm_group P] [module R P] (f : M â†’â‚—[R] N) (g : N â†’â‚—[R] P) (hf1 : f.ker.fg) (hf2 : g.ker.fg) (hsur : function.surjective â‡‘f) : (g.comp f).ker.fg
theorem orientation.oangle_rotation_left {V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) {x y : V} (hx : x â‰  0) (hy : y â‰  0) (Î¸ : real.angle) : o.oangle (â‡‘(o.rotation Î¸) x) y = o.oangle x y - Î¸
theorem cont_diff_const {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {n : with_top â„•} {c : F} : cont_diff ğ•œ n (Î» (x : E), c)
theorem dense.exists_countable_dense_subset_no_bot_top {Î± : Type u} [topological_space Î±] [linear_order Î±] [order_topology Î±] [densely_ordered Î±] [nontrivial Î±] {s : set Î±} [topological_space.separable_space â†¥s] (hs : dense s) : âˆƒ (t : set Î±) (H : t âŠ† s), t.countable âˆ§ dense t âˆ§ (âˆ€ (x : Î±), is_bot x â†’ x âˆ‰ t) âˆ§ âˆ€ (x : Î±), is_top x â†’ x âˆ‰ t
theorem formal_multilinear_series.comp_coeff_zero'' {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [comm_ring ğ•œ] [add_comm_group E] [add_comm_group F] [module ğ•œ E] [module ğ•œ F] [topological_space E] [topological_space F] [topological_add_group E] [has_continuous_const_smul ğ•œ E] [topological_add_group F] [has_continuous_const_smul ğ•œ F] (q : formal_multilinear_series ğ•œ E F) (p : formal_multilinear_series ğ•œ E E) : q.comp p 0 = q 0
theorem mul_ne_zero_iff {Mâ‚€ : Type u_1} [mul_zero_class Mâ‚€] [no_zero_divisors Mâ‚€] {a b : Mâ‚€} : a * b â‰  0 â†” a â‰  0 âˆ§ b â‰  0
theorem orthonormal_subtype_iff_ite {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] [dec_E : decidable_eq E] {s : set E} : orthonormal ğ•œ coe â†” âˆ€ (v : E), v âˆˆ s â†’ âˆ€ (w : E), w âˆˆ s â†’ has_inner.inner v w = ite (v = w) 1 0
theorem add_subsemigroup.closure_induction {M : Type u_1} [has_add M] {s : set M} {p : M â†’ Prop} {x : M} (h : x âˆˆ add_subsemigroup.closure s) (Hs : âˆ€ (x : M), x âˆˆ s â†’ p x) (Hmul : âˆ€ (x y : M), p x â†’ p y â†’ p (x + y)) : p x
theorem add_monoid_hom.map_zsmul {Î± : Type u_1} {Î² : Type u_2} [add_group Î±] [subtraction_monoid Î²] (f : Î± â†’+ Î²) (g : Î±) (n : â„¤) : â‡‘f (n â€¢ g) = n â€¢ â‡‘f g
theorem left.mul_lt_one' {Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a b : Î±} (ha : a < 1) (hb : b < 1) : a * b < 1
theorem measure_theory.measure.finite_spanning_sets_in.sigma_finite {Î± : Type u_1} {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {C : set (set Î±)} (h : Î¼.finite_spanning_sets_in C) : measure_theory.sigma_finite Î¼
theorem measure_theory.tendsto_uniformly_on_of_ae_tendsto' {Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_3} {m : measurable_space Î±} [metric_space Î²] {Î¼ : measure_theory.measure Î±} [semilattice_sup Î¹] [nonempty Î¹] [encodable Î¹] {f : Î¹ â†’ Î± â†’ Î²} {g : Î± â†’ Î²} [measure_theory.is_finite_measure Î¼] (hf : âˆ€ (n : Î¹), measure_theory.strongly_measurable (f n)) (hg : measure_theory.strongly_measurable g) (hfg : âˆ€áµ (x : Î±) âˆ‚Î¼, filter.tendsto (Î» (n : Î¹), f n x) filter.at_top (nhds (g x))) {Îµ : â„} (hÎµ : 0 < Îµ) : âˆƒ (t : set Î±), measurable_set t âˆ§ â‡‘Î¼ t â‰¤ ennreal.of_real Îµ âˆ§ tendsto_uniformly_on f g filter.at_top tá¶œ
theorem add_monoid_algebra.map_domain_mul {Î± : Type u_1} {Î² : Type u_2} {Î±â‚‚ : Type u_3} [semiring Î²] [has_add Î±] [has_add Î±â‚‚] {F : Type u_4} [add_hom_class F Î± Î±â‚‚] (f : F) (x y : add_monoid_algebra Î² Î±) : finsupp.map_domain â‡‘f (x * y) = finsupp.map_domain â‡‘f x * finsupp.map_domain â‡‘f y
theorem finset.subset_mul {Î± : Type u_2} [decidable_eq Î±] [has_mul Î±] {u : finset Î±} {s t : set Î±} : â†‘u âŠ† s * t â†’ (âˆƒ (s' t' : finset Î±), â†‘s' âŠ† s âˆ§ â†‘t' âŠ† t âˆ§ u âŠ† s' * t')
theorem affine_independent_iff_eq_of_fintype_affine_combination_eq (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {Î¹ : Type u_4} [fintype Î¹] (p : Î¹ â†’ P) : affine_independent k p â†” âˆ€ (w1 w2 : Î¹ â†’ k), finset.univ.sum (Î» (i : Î¹), w1 i) = 1 â†’ finset.univ.sum (Î» (i : Î¹), w2 i) = 1 â†’ â‡‘(finset.univ.affine_combination p) w1 = â‡‘(finset.univ.affine_combination p) w2 â†’ w1 = w2
theorem dfinsupp.comp_lift_add_hom {Î¹ : Type u} {Î³ : Type w} {Î² : Î¹ â†’ Type v} [dec : decidable_eq Î¹] {Î´ : Type u_1} [Î  (i : Î¹), add_zero_class (Î² i)] [add_comm_monoid Î³] [add_comm_monoid Î´] (g : Î³ â†’+ Î´) (f : Î  (i : Î¹), Î² i â†’+ Î³) : g.comp (â‡‘dfinsupp.lift_add_hom f) = â‡‘dfinsupp.lift_add_hom (Î» (a : Î¹), g.comp (f a))
theorem measure_theory.tendsto_in_measure.exists_seq_tendsto_ae {Î± : Type u_1} {E : Type u_3} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [metric_space E] {f : â„• â†’ Î± â†’ E} {g : Î± â†’ E} (hfg : measure_theory.tendsto_in_measure Î¼ f filter.at_top g) : âˆƒ (ns : â„• â†’ â„•), strict_mono ns âˆ§ âˆ€áµ (x : Î±) âˆ‚Î¼, filter.tendsto (Î» (i : â„•), f (ns i) x) filter.at_top (nhds (g x))
theorem has_fpower_series_on_ball.r_eq_top_of_exists {ğ•œ : Type u_1} {E : Type u_2} [nondiscrete_normed_field ğ•œ] [normed_group E] [normed_space ğ•œ E] {f : ğ•œ â†’ E} {r : ennreal} {x : ğ•œ} {p : formal_multilinear_series ğ•œ ğ•œ E} (h : has_fpower_series_on_ball f p x r) (h' : âˆ€ (r' : nnreal), 0 < r' â†’ (âˆƒ (p' : formal_multilinear_series ğ•œ ğ•œ E), has_fpower_series_on_ball f p' x â†‘r')) : has_fpower_series_on_ball f p x âŠ¤
theorem free_algebra.induction (R : Type u_1) [comm_semiring R] (X : Type u_2) {C : free_algebra R X â†’ Prop} (h_grade0 : âˆ€ (r : R), C (â‡‘(algebra_map R (free_algebra R X)) r)) (h_grade1 : âˆ€ (x : X), C (free_algebra.Î¹ R x)) (h_mul : âˆ€ (a b : free_algebra R X), C a â†’ C b â†’ C (a * b)) (h_add : âˆ€ (a b : free_algebra R X), C a â†’ C b â†’ C (a + b)) (a : free_algebra R X) : C a
theorem asymptotics.is_O_with.of_norm_norm {Î± : Type u_1} {E' : Type u_6} {F' : Type u_7} [semi_normed_group E'] [semi_normed_group F'] {c : â„} {f' : Î± â†’ E'} {g' : Î± â†’ F'} {l : filter Î±} : asymptotics.is_O_with c l (Î» (x : Î±), âˆ¥f' xâˆ¥) (Î» (x : Î±), âˆ¥g' xâˆ¥) â†’ asymptotics.is_O_with c l f' g'
theorem measure_theory.tendsto_set_to_fun_of_dominated_convergence {Î± : Type u_1} {E : Type u_2} {F : Type u_3} [normed_group E] [normed_space â„ E] [normed_group F] [normed_space â„ F] {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [complete_space F] {T : set Î± â†’ (E â†’L[â„] F)} {C : â„} (hT : measure_theory.dominated_fin_meas_additive Î¼ T C) {fs : â„• â†’ Î± â†’ E} {f : Î± â†’ E} (bound : Î± â†’ â„) (fs_measurable : âˆ€ (n : â„•), measure_theory.ae_strongly_measurable (fs n) Î¼) (bound_integrable : measure_theory.integrable bound Î¼) (h_bound : âˆ€ (n : â„•), âˆ€áµ (a : Î±) âˆ‚Î¼, âˆ¥fs n aâˆ¥ â‰¤ bound a) (h_lim : âˆ€áµ (a : Î±) âˆ‚Î¼, filter.tendsto (Î» (n : â„•), fs n a) filter.at_top (nhds (f a))) : filter.tendsto (Î» (n : â„•), measure_theory.set_to_fun Î¼ T hT (fs n)) filter.at_top (nhds (measure_theory.set_to_fun Î¼ T hT f))
theorem is_topological_fiber_bundle.comap {B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z â†’ B} [topological_space Z] {B' : Type u_5} [topological_space B'] (h : is_topological_fiber_bundle F proj) {f : B' â†’ B} (hf : continuous f) : is_topological_fiber_bundle F (Î» (x : â†¥{p : B' Ã— Z | f p.fst = proj p.snd}), â†‘x.fst)
theorem dist_le_range_sum_of_dist_le {Î± : Type u} [pseudo_metric_space Î±] {f : â„• â†’ Î±} (n : â„•) {d : â„• â†’ â„} (hd : âˆ€ {k : â„•}, k < n â†’ has_dist.dist (f k) (f (k + 1)) â‰¤ d k) : has_dist.dist (f 0) (f n) â‰¤ (finset.range n).sum (Î» (i : â„•), d i)
theorem cont_diff_at.mul {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {x : E} {n : with_top â„•} {f g : E â†’ ğ•œ} (hf : cont_diff_at ğ•œ n f x) (hg : cont_diff_at ğ•œ n g x) : cont_diff_at ğ•œ n (Î» (x : E), f x * g x) x
theorem order.exists_between_finsets {Î± : Type u_1} [linear_order Î±] [densely_ordered Î±] [no_min_order Î±] [no_max_order Î±] [nonem : nonempty Î±] (lo hi : finset Î±) (lo_lt_hi : âˆ€ (x : Î±), x âˆˆ lo â†’ âˆ€ (y : Î±), y âˆˆ hi â†’ x < y) : âˆƒ (m : Î±), (âˆ€ (x : Î±), x âˆˆ lo â†’ x < m) âˆ§ âˆ€ (y : Î±), y âˆˆ hi â†’ m < y
theorem matrix.pivot.list_transvec_col_mul_mul_list_transvec_row_last_col {ğ•œ : Type u_3} [field ğ•œ] {r : â„•} (M : matrix (fin r âŠ• unit) (fin r âŠ• unit) ğ•œ) (hM : M (sum.inr ()) (sum.inr ()) â‰  0) (i : fin r) : ((matrix.pivot.list_transvec_col M).prod.mul M).mul (matrix.pivot.list_transvec_row M).prod (sum.inr ()) (sum.inl i) = 0
theorem exists_quadratic_eq_zero {K : Type u_1} [field K] [invertible 2] {a b c : K} (ha : a â‰  0) (h : âˆƒ (s : K), discrim a b c = s * s) : âˆƒ (x : K), a * x * x + b * x + c = 0
theorem matrix.det_succ_column {R : Type v} [comm_ring R] {n : â„•} (A : matrix (fin n.succ) (fin n.succ) R) (j : fin n.succ) : A.det = finset.univ.sum (Î» (i : fin n.succ), (-1) ^ (â†‘i + â†‘j) * A i j * (A.minor â‡‘(i.succ_above) â‡‘(j.succ_above)).det)
theorem finset.imageâ‚‚_distrib_subset_left {Î± : Type u_1} {Î² : Type u_3} {Î²' : Type u_4} {Î³' : Type u_6} {Î´ : Type u_7} {Îµ : Type u_9} [decidable_eq Î²'] [decidable_eq Î³'] [decidable_eq Î´] [decidable_eq Îµ] {s : finset Î±} {t : finset Î²} {Î³ : Type u_2} {u : finset Î³} {f : Î± â†’ Î´ â†’ Îµ} {g : Î² â†’ Î³ â†’ Î´} {fâ‚ : Î± â†’ Î² â†’ Î²'} {fâ‚‚ : Î± â†’ Î³ â†’ Î³'} {g' : Î²' â†’ Î³' â†’ Îµ} (h_distrib : âˆ€ (a : Î±) (b : Î²) (c : Î³), f a (g b c) = g' (fâ‚ a b) (fâ‚‚ a c)) : finset.imageâ‚‚ f s (finset.imageâ‚‚ g t u) âŠ† finset.imageâ‚‚ g' (finset.imageâ‚‚ fâ‚ s t) (finset.imageâ‚‚ fâ‚‚ s u)
theorem finprod_mem_pair {Î± : Type u_1} {M : Type u_5} [comm_monoid M] {f : Î± â†’ M} {a b : Î±} (h : a â‰  b) : finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ {a, b}), f i)) = f a * f b
theorem basis.maximal {Î¹ : Type u_1} {R : Type u_3} {M : Type u_5} [ring R] [add_comm_group M] [module R M] [nontrivial R] (b : basis Î¹ R M) : _.maximal
theorem is_left_regular.of_mul {R : Type u_1} {a b : R} [semigroup R] (ab : is_left_regular (a * b)) : is_left_regular b
theorem absorbent.gauge_set_nonempty {E : Type u_1} [add_comm_group E] [module â„ E] {s : set E} {x : E} (absorbs : absorbent â„ s) : {r : â„ | 0 < r âˆ§ x âˆˆ r â€¢ s}.nonempty
theorem zero_lt.right.mul_lt_one_of_lt_of_lt {Î± : Type u} {a b : Î±} [mul_one_class Î±] [has_zero Î±] [preorder Î±] [zero_lt.mul_pos_strict_mono Î±] (ha : a < 1) (hb : b < 1) (b0 : 0 < b) : a * b < 1
theorem is_noetherian.bijective_of_surjective_endomorphism {R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] [is_noetherian R M] (f : M â†’â‚—[R] M) (s : function.surjective â‡‘f) : function.bijective â‡‘f
theorem fin.succ_above_right_inj {n : â„•} {a b : fin n} {x : fin (n + 1)} : â‡‘(x.succ_above) a = â‡‘(x.succ_above) b â†” a = b
theorem has_strict_fderiv_at.comp {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {G : Type u_4} [normed_group G] [normed_space ğ•œ G] {f : E â†’ F} {f' : E â†’L[ğ•œ] F} (x : E) {g : F â†’ G} {g' : F â†’L[ğ•œ] G} (hg : has_strict_fderiv_at g g' (f x)) (hf : has_strict_fderiv_at f f' x) : has_strict_fderiv_at (Î» (x : E), g (f x)) (g'.comp f') x
theorem complex.norm_eventually_eq_of_is_local_max {E : Type u} [normed_group E] [normed_space â„‚ E] {F : Type v} [normed_group F] [normed_space â„‚ F] {f : E â†’ F} {c : E} (hd : âˆ€á¶  (z : E) in nhds c, differentiable_at â„‚ f z) (hc : is_local_max (has_norm.norm âˆ˜ f) c) : âˆ€á¶  (y : E) in nhds c, âˆ¥f yâˆ¥ = âˆ¥f câˆ¥
theorem formal_multilinear_series.le_radius_of_is_O {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field ğ•œ] [normed_group E] [normed_space ğ•œ E] [normed_group F] [normed_space ğ•œ F] (p : formal_multilinear_series ğ•œ E F) {r : nnreal} (h : (Î» (n : â„•), âˆ¥p nâˆ¥ * â†‘r ^ n) =O[filter.at_top] Î» (n : â„•), 1) : â†‘r â‰¤ p.radius
theorem subring.closure_inductionâ‚‚ {R : Type u} [ring R] {s : set R} {p : R â†’ R â†’ Prop} {a b : R} (ha : a âˆˆ subring.closure s) (hb : b âˆˆ subring.closure s) (Hs : âˆ€ (x : R), x âˆˆ s â†’ âˆ€ (y : R), y âˆˆ s â†’ p x y) (H0_left : âˆ€ (x : R), p 0 x) (H0_right : âˆ€ (x : R), p x 0) (H1_left : âˆ€ (x : R), p 1 x) (H1_right : âˆ€ (x : R), p x 1) (Hneg_left : âˆ€ (x y : R), p x y â†’ p (-x) y) (Hneg_right : âˆ€ (x y : R), p x y â†’ p x (-y)) (Hadd_left : âˆ€ (xâ‚ xâ‚‚ y : R), p xâ‚ y â†’ p xâ‚‚ y â†’ p (xâ‚ + xâ‚‚) y) (Hadd_right : âˆ€ (x yâ‚ yâ‚‚ : R), p x yâ‚ â†’ p x yâ‚‚ â†’ p x (yâ‚ + yâ‚‚)) (Hmul_left : âˆ€ (xâ‚ xâ‚‚ y : R), p xâ‚ y â†’ p xâ‚‚ y â†’ p (xâ‚ * xâ‚‚) y) (Hmul_right : âˆ€ (x yâ‚ yâ‚‚ : R), p x yâ‚ â†’ p x yâ‚‚ â†’ p x (yâ‚ * yâ‚‚)) : p a b
theorem has_deriv_within_at.Iic_of_Iio {ğ•œ : Type u} [nondiscrete_normed_field ğ•œ] {F : Type v} [normed_group F] [normed_space ğ•œ F] {f : ğ•œ â†’ F} {f' : F} {x : ğ•œ} [partial_order ğ•œ] : has_deriv_within_at f f' (set.Iio x) x â†’ has_deriv_within_at f f' (set.Iic x) x
theorem asymptotics.is_O_with.norm_right {Î± : Type u_1} {E : Type u_3} {F' : Type u_7} [has_norm E] [semi_normed_group F'] {c : â„} {f : Î± â†’ E} {g' : Î± â†’ F'} {l : filter Î±} : asymptotics.is_O_with c l f g' â†’ asymptotics.is_O_with c l f (Î» (x : Î±), âˆ¥g' xâˆ¥)
theorem infinite_basis_le_maximal_linear_independent' {R : Type u} [ring R] {M : Type v} [add_comm_group M] [module R M] [nontrivial R] {Î¹ : Type w} (b : basis Î¹ R M) [infinite Î¹] {Îº : Type w'} (v : Îº â†’ M) (i : linear_independent R v) (m : i.maximal) : (cardinal.mk Î¹).lift â‰¤ (cardinal.mk Îº).lift
theorem exists_idempotent_in_compact_add_subsemigroup {M : Type u_1} [add_semigroup M] [topological_space M] [t2_space M] (continuous_mul_left : âˆ€ (r : M), continuous (Î» (_x : M), _x + r)) (s : set M) (snemp : s.nonempty) (s_compact : is_compact s) (s_add : âˆ€ (x : M), x âˆˆ s â†’ âˆ€ (y : M), y âˆˆ s â†’ x + y âˆˆ s) : âˆƒ (m : M) (H : m âˆˆ s), m + m = m
theorem fractional_ideal.coe_one_eq_coe_submodule_top {R : Type u_1} [comm_ring R] {S : submonoid R} {P : Type u_2} [comm_ring P] [algebra R P] : â†‘1 = is_localization.coe_submodule P âŠ¤
theorem is_preconnected.eq_univ_of_unbounded {Î± : Type v} [linear_order Î±] [topological_space Î±] [order_closed_topology Î±] {s : set Î±} (hs : is_preconnected s) (hb : Â¬bdd_below s) (ha : Â¬bdd_above s) : s = set.univ
theorem metric.lipschitz_inf_dist_pt {Î± : Type u} [pseudo_metric_space Î±] (s : set Î±) : lipschitz_with 1 (Î» (x : Î±), metric.inf_dist x s)
theorem is_torsion_of_fintype {G : Type u_1} [group G] [fintype G] : monoid.is_torsion G
theorem exists_maximal_orthonormal {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {s : set E} (hs : orthonormal ğ•œ coe) : âˆƒ (w : set E) (H : w âŠ‡ s), orthonormal ğ•œ coe âˆ§ âˆ€ (u : set E), u âŠ‡ w â†’ orthonormal ğ•œ coe â†’ u = w
theorem has_ftaylor_series_up_to_on.has_fderiv_within_at {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {s : set E} {f : E â†’ F} {x : E} {n : with_top â„•} {p : E â†’ formal_multilinear_series ğ•œ E F} (h : has_ftaylor_series_up_to_on n f p s) (hn : 1 â‰¤ n) (hx : x âˆˆ s) : has_fderiv_within_at f (â‡‘(continuous_multilinear_curry_fin1 ğ•œ E F) (p x 1)) s x
theorem set.mem_finset_sum {Î± : Type u_2} {Î¹ : Type u_5} [add_comm_monoid Î±] (t : finset Î¹) (f : Î¹ â†’ set Î±) (a : Î±) : a âˆˆ t.sum (Î» (i : Î¹), f i) â†” âˆƒ (g : Î¹ â†’ Î±) (hg : âˆ€ {i : Î¹}, i âˆˆ t â†’ g i âˆˆ f i), t.sum (Î» (i : Î¹), g i) = a
theorem infinite.nonempty_field {Î± : Type u} [infinite Î±] : nonempty (field Î±)
theorem antivary_on.sum_mul_le_sum_mul_comp_perm {Î¹ : Type u_1} {Î± : Type u_2} [linear_ordered_ring Î±] {s : finset Î¹} {Ïƒ : equiv.perm Î¹} {f g : Î¹ â†’ Î±} (hfg : antivary_on f g â†‘s) (hÏƒ : {x : Î¹ | â‡‘Ïƒ x â‰  x} âŠ† â†‘s) : s.sum (Î» (i : Î¹), f i * g i) â‰¤ s.sum (Î» (i : Î¹), f i * g (â‡‘Ïƒ i))
theorem cont_mdiff_on_iff_target {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {M : Type u_4} [topological_space M] [charted_space H M] [Is : smooth_manifold_with_corners I M] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners ğ•œ E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] [I's : smooth_manifold_with_corners I' M'] {f : M â†’ M'} {s : set M} {n : with_top â„•} : cont_mdiff_on I I' n f s â†” continuous_on f s âˆ§ âˆ€ (y : M'), cont_mdiff_on I (model_with_corners_self ğ•œ E') n (â‡‘(ext_chart_at I' y) âˆ˜ f) (s âˆ© f â»Â¹' (ext_chart_at I' y).source)
theorem module.End.generalized_eigenspace_eq_generalized_eigenspace_finrank_of_le {K : Type v} {V : Type w} [field K] [add_comm_group V] [module K V] [finite_dimensional K V] (f : module.End K V) (Î¼ : K) {k : â„•} (hk : finite_dimensional.finrank K V â‰¤ k) : â‡‘(f.generalized_eigenspace Î¼) k = â‡‘(f.generalized_eigenspace Î¼) (finite_dimensional.finrank K V)
theorem nat.image_Ico_mod (n a : â„•) : finset.image (Î» (_x : â„•), _x % a) (finset.Ico n (n + a)) = finset.range a
theorem covby.coe_fin {n : â„•} {a b : fin n} : a â‹– b â†’ â†‘a â‹– â†‘b
theorem eckmann_hilton.mul {X : Type u} {mâ‚ mâ‚‚ : X â†’ X â†’ X} {eâ‚ eâ‚‚ : X} (hâ‚ : eckmann_hilton.is_unital mâ‚ eâ‚) (hâ‚‚ : eckmann_hilton.is_unital mâ‚‚ eâ‚‚) (distrib : âˆ€ (a b c d : X), mâ‚ (mâ‚‚ a b) (mâ‚‚ c d) = mâ‚‚ (mâ‚ a c) (mâ‚ b d)) : mâ‚ = mâ‚‚
theorem nilpotent_iff_lower_central_series {G : Type u_1} [group G] : group.is_nilpotent G â†” âˆƒ (n : â„•), lower_central_series G n = âŠ¥
theorem inv_lt_one_iff_one_lt {Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a : Î±} : aâ»Â¹ < 1 â†” 1 < a
theorem opens.pretopology_of_grothendieck (T : Type u) [topological_space T] : category_theory.pretopology.of_grothendieck (topological_space.opens T) (opens.grothendieck_topology T) = opens.pretopology T
theorem trans_gen_of_succ_of_reflexive {Î± : Type u_1} [linear_order Î±] [succ_order Î±] [is_succ_archimedean Î±] (r : Î± â†’ Î± â†’ Prop) {n m : Î±} (hr : reflexive r) (h1 : âˆ€ (i : Î±), i âˆˆ set.Ico n m â†’ r i (order.succ i)) (h2 : âˆ€ (i : Î±), i âˆˆ set.Ico m n â†’ r (order.succ i) i) : relation.trans_gen r n m
theorem matrix.mul_vec_cramer {n : Type u} [decidable_eq n] [fintype n] {Î± : Type v} [comm_ring Î±] (A : matrix n n Î±) (b : n â†’ Î±) : A.mul_vec (â‡‘(A.cramer) b) = A.det â€¢ b
theorem seminorm.balanced_ball_zero {ğ•œ : Type u_3} {E : Type u_4} [semi_normed_ring ğ•œ] [add_comm_group E] [module ğ•œ E] (p : seminorm ğ•œ E) (r : â„) : balanced ğ•œ (p.ball 0 r)
theorem metric.Hausdorff_dist_closure {Î± : Type u} [pseudo_metric_space Î±] {s t : set Î±} : metric.Hausdorff_dist (closure s) (closure t) = metric.Hausdorff_dist s t
theorem asymptotics.is_O_with.of_neg_left {Î± : Type u_1} {F : Type u_4} {E' : Type u_6} [has_norm F] [semi_normed_group E'] {c : â„} {g : Î± â†’ F} {f' : Î± â†’ E'} {l : filter Î±} : asymptotics.is_O_with c l (Î» (x : Î±), -f' x) g â†’ asymptotics.is_O_with c l f' g
theorem antivary_on.sum_smul_lt_sum_comp_perm_smul_iff {Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [linear_ordered_ring Î±] [linear_ordered_add_comm_group Î²] [module Î± Î²] [ordered_smul Î± Î²] {s : finset Î¹} {Ïƒ : equiv.perm Î¹} {f : Î¹ â†’ Î±} {g : Î¹ â†’ Î²} (hfg : antivary_on f g â†‘s) (hÏƒ : {x : Î¹ | â‡‘Ïƒ x â‰  x} âŠ† â†‘s) : s.sum (Î» (i : Î¹), f i â€¢ g i) < s.sum (Î» (i : Î¹), f (â‡‘Ïƒ i) â€¢ g i) â†” Â¬antivary_on (f âˆ˜ â‡‘Ïƒ) g â†‘s
theorem monotone_on.dual_left {Î± : Type u} {Î² : Type v} [preorder Î±] [preorder Î²] {f : Î± â†’ Î²} {s : set Î±} : monotone_on f s â†’ antitone_on (f âˆ˜ â‡‘order_dual.of_dual) s
theorem right.add_pos_of_pos_of_nonneg {Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b : Î±} (ha : 0 < a) (hb : 0 â‰¤ b) : 0 < a + b
theorem pi.has_faithful_smul_at {I : Type u} {f : I â†’ Type v} {Î± : Type u_1} [Î  (i : I), has_scalar Î± (f i)] [âˆ€ (i : I), nonempty (f i)] (i : I) [has_faithful_smul Î± (f i)] : has_faithful_smul Î± (Î  (i : I), f i)
theorem cont_diff_groupoid_zero_eq {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] (I : model_with_corners ğ•œ E H) : cont_diff_groupoid 0 I = continuous_groupoid H
theorem complex.im_eq_sub_conj (z : â„‚) : â†‘(z.im) = (z - â‡‘(star_ring_end â„‚) z) / (2 * complex.I)
theorem real.geom_mean_le_arith_mean_weighted {Î¹ : Type u} (s : finset Î¹) (w z : Î¹ â†’ â„) (hw : âˆ€ (i : Î¹), i âˆˆ s â†’ 0 â‰¤ w i) (hw' : s.sum (Î» (i : Î¹), w i) = 1) (hz : âˆ€ (i : Î¹), i âˆˆ s â†’ 0 â‰¤ z i) : s.prod (Î» (i : Î¹), z i ^ w i) â‰¤ s.sum (Î» (i : Î¹), w i * z i)
theorem antivary.sum_mul_eq_sum_comp_perm_mul_iff {Î¹ : Type u_1} {Î± : Type u_2} [linear_ordered_ring Î±] {Ïƒ : equiv.perm Î¹} {f g : Î¹ â†’ Î±} [fintype Î¹] (hfg : antivary f g) : finset.univ.sum (Î» (i : Î¹), f (â‡‘Ïƒ i) * g i) = finset.univ.sum (Î» (i : Î¹), f i * g i) â†” antivary (f âˆ˜ â‡‘Ïƒ) g
theorem finset.induction_on' {Î± : Type u_1} {p : finset Î± â†’ Prop} [decidable_eq Î±] (S : finset Î±) (hâ‚ : p âˆ…) (hâ‚‚ : âˆ€ {a : Î±} {s : finset Î±}, a âˆˆ S â†’ s âŠ† S â†’ a âˆ‰ s â†’ p s â†’ p (has_insert.insert a s)) : p S
theorem has_lt.lt.trans_eq' {Î± : Type u} [preorder Î±] {a b c : Î±} : b < c â†’ a = b â†’ a < c
theorem formal_multilinear_series.radius_right_inv_pos_of_radius_pos_aux1 (n : â„•) (p : â„• â†’ â„) (hp : âˆ€ (k : â„•), 0 â‰¤ p k) {r a : â„} (hr : 0 â‰¤ r) (ha : 0 â‰¤ a) : (finset.Ico 2 (n + 1)).sum (Î» (k : â„•), a ^ k * {c : composition k | 1 < c.length}.to_finset.sum (Î» (c : composition k), r ^ c.length * finset.univ.prod (Î» (j : fin c.length), p (c.blocks_fun j)))) â‰¤ (finset.Ico 2 (n + 1)).sum (Î» (j : â„•), r ^ j * (finset.Ico 1 n).sum (Î» (k : â„•), a ^ k * p k) ^ j)
theorem denumerable.raise'_sorted (l : list â„•) (n : â„•) : list.sorted has_lt.lt (denumerable.raise' l n)
theorem category_theory.limits.has_limit_of_equivalence_comp {J : Type uâ‚} [category_theory.category J] {K : Type uâ‚‚} [category_theory.category K] {C : Type u} [category_theory.category C] {F : J â¥¤ C} (e : K â‰Œ J) [category_theory.limits.has_limit (e.functor â‹™ F)] : category_theory.limits.has_limit F
theorem fintype.all_card_le_filter_rel_iff_exists_injective {Î± : Type u} {Î² : Type v} [fintype Î²] (r : Î± â†’ Î² â†’ Prop) [Î  (a : Î±), decidable_pred (r a)] : (âˆ€ (A : finset Î±), A.card â‰¤ (finset.filter (Î» (b : Î²), âˆƒ (a : Î±) (H : a âˆˆ A), r a b) finset.univ).card) â†” âˆƒ (f : Î± â†’ Î²), function.injective f âˆ§ âˆ€ (x : Î±), r x (f x)
theorem function.is_fixed_pt.eq {Î± : Type u} {f : Î± â†’ Î±} {x : Î±} (hf : function.is_fixed_pt f x) : f x = x
theorem category_theory.abelian.pseudoelement.pseudo_pullback {C : Type u} [category_theory.category C] [category_theory.abelian C] [category_theory.limits.has_pullbacks C] {P Q R : C} {f : P âŸ¶ R} {g : Q âŸ¶ R} {p : â†¥P} {q : â†¥Q} : â‡‘f p = â‡‘g q â†’ (âˆƒ (s : â†¥(category_theory.limits.pullback f g)), â‡‘category_theory.limits.pullback.fst s = p âˆ§ â‡‘category_theory.limits.pullback.snd s = q)
theorem matrix.general_linear_group.ext {n : Type u} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] â¦ƒA B : GL n Râ¦„ (h : âˆ€ (i j : n), â†‘A i j = â†‘B i j) : A = B
theorem list.nodup.of_sublists {Î± : Type u} {l : list Î±} : l.sublists.nodup â†’ l.nodup
theorem same_ray_nonneg_smul_left {R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] (v : M) {r : R} (h : 0 â‰¤ r) : same_ray R (r â€¢ v) v
theorem finprod_eq_of_bijective {Î± : Type u_1} {Î² : Type u_2} {M : Type u_5} [comm_monoid M] {f : Î± â†’ M} {g : Î² â†’ M} (e : Î± â†’ Î²) (heâ‚€ : function.bijective e) (heâ‚ : âˆ€ (x : Î±), f x = g (e x)) : finprod (Î» (i : Î±), f i) = finprod (Î» (j : Î²), g j)
theorem nonempty_linear_equiv_of_dim_eq {K : Type u} {V Vâ‚ : Type v} [division_ring K] [add_comm_group V] [module K V] [add_comm_group Vâ‚] [module K Vâ‚] (cond : module.rank K V = module.rank K Vâ‚) : nonempty (V â‰ƒâ‚—[K] Vâ‚)
theorem normed_ring.inverse_add {R : Type u_1} [normed_ring R] [complete_space R] (x : RË£) : âˆ€á¶  (t : R) in nhds 0, ring.inverse (â†‘x + t) = ring.inverse (1 + â†‘xâ»Â¹ * t) * â†‘xâ»Â¹
theorem convex_on_univ_norm {E : Type u_2} [semi_normed_group E] [normed_space â„ E] : convex_on â„ set.univ has_norm.norm
theorem inv_gold  : golden_ratioâ»Â¹ = -golden_conj
theorem filter.tendsto_at_top_finset_of_monotone {Î± : Type u_3} {Î² : Type u_4} [preorder Î²] {f : Î² â†’ finset Î±} (h : monotone f) (h' : âˆ€ (x : Î±), âˆƒ (n : Î²), x âˆˆ f n) : filter.tendsto f filter.at_top filter.at_top
theorem complex.integral_boundary_rect_eq_zero_of_continuous_on_of_differentiable_on {E : Type u} [normed_group E] [normed_space â„‚ E] [complete_space E] (f : â„‚ â†’ E) (z w : â„‚) (Hc : continuous_on f (set.interval z.re w.re Ã—â„‚ set.interval z.im w.im)) (Hd : differentiable_on â„‚ f (set.Ioo (linear_order.min z.re w.re) (linear_order.max z.re w.re) Ã—â„‚ set.Ioo (linear_order.min z.im w.im) (linear_order.max z.im w.im))) : (((âˆ« (x : â„) in z.re..w.re, f (â†‘x + â†‘(z.im) * complex.I)) - âˆ« (x : â„) in z.re..w.re, f (â†‘x + â†‘(w.im) * complex.I)) + complex.I â€¢ âˆ« (y : â„) in z.im..w.im, f (â†‘(w.re) + â†‘y * complex.I)) - complex.I â€¢ âˆ« (y : â„) in z.im..w.im, f (â†‘(z.re) + â†‘y * complex.I) = 0
theorem measure_theory.strongly_measurable.integral_prod_right {Î± : Type u_1} {Î² : Type u_3} {E : Type u_6} [measurable_space Î±] [measurable_space Î²] {Î½ : measure_theory.measure Î²} [normed_group E] [normed_space â„ E] [complete_space E] [measure_theory.sigma_finite Î½] â¦ƒf : Î± â†’ Î² â†’ Eâ¦„ (hf : measure_theory.strongly_measurable (function.uncurry f)) : measure_theory.strongly_measurable (Î» (x : Î±), âˆ« (y : Î²), f x y âˆ‚Î½)
theorem continuous.Icc_extend' {Î± : Type u_1} {Î² : Type u_2} [linear_order Î±] {a b : Î±} {h : a â‰¤ b} [topological_space Î±] [order_topology Î±] [topological_space Î²] {f : â†¥(set.Icc a b) â†’ Î²} (hf : continuous f) : continuous (set.Icc_extend h f)
theorem projective_spectrum.gc_ideal {R : Type u_1} {A : Type u_2} [comm_semiring R] [comm_ring A] [algebra R A] (ğ’œ : â„• â†’ submodule R A) [graded_algebra ğ’œ] : galois_connection (Î» (I : ideal A), projective_spectrum.zero_locus ğ’œ â†‘I) (Î» (t : (set (projective_spectrum ğ’œ))áµ’áµˆ), (projective_spectrum.vanishing_ideal t).to_ideal)
theorem is_least.cInf_eq {Î± : Type u_1} [conditionally_complete_lattice Î±] {s : set Î±} {a : Î±} (H : is_least s a) : has_Inf.Inf s = a
theorem is_noetherian.injective_of_surjective_endomorphism {R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] [is_noetherian R M] (f : M â†’â‚—[R] M) (s : function.surjective â‡‘f) : function.injective â‡‘f
theorem linear_map.charpoly_to_matrix {R : Type u} {M : Type v} [comm_ring R] [nontrivial R] [add_comm_group M] [module R M] [module.free R M] [module.finite R M] (f : M â†’â‚—[R] M) {Î¹ : Type w} [fintype Î¹] (b : basis Î¹ R M) : (â‡‘(linear_map.to_matrix b b) f).charpoly = f.charpoly
theorem polynomial.monomial_mem_lifts {R : Type u} [semiring R] {S : Type v} [semiring S] {f : R â†’+* S} {s : S} (n : â„•) (h : s âˆˆ set.range â‡‘f) : â‡‘(polynomial.monomial n) s âˆˆ polynomial.lifts f
theorem mul_self_div_self {Gâ‚€ : Type u_2} [group_with_zero Gâ‚€] (a : Gâ‚€) : a * a / a = a
theorem balanced.interior {ğ•œ : Type u_1} {E : Type u_3} [normed_field ğ•œ] [add_comm_group E] [module ğ•œ E] {A : set E} [topological_space E] [has_continuous_smul ğ•œ E] (hA : balanced ğ•œ A) (h : 0 âˆˆ interior A) : balanced ğ•œ (interior A)
theorem norm_sub_mul_self_real {F : Type u_3} [inner_product_space â„ F] {x y : F} : âˆ¥x - yâˆ¥ * âˆ¥x - yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ - 2 * has_inner.inner x y + âˆ¥yâˆ¥ * âˆ¥yâˆ¥
theorem list.head_add_tail_sum_of_ne_nil {M : Type u_3} [add_monoid M] [inhabited M] (l : list M) (h : l â‰  list.nil) : l.head + l.tail.sum = l.sum
theorem nat.prime.factorization_pow {p k : â„•} (hp : nat.prime p) : (p ^ k).factorization = finsupp.single p k
theorem affine.triangle.orthocenter_replace_orthocenter_eq_point {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {tâ‚ tâ‚‚ : affine.triangle â„ P} {iâ‚ iâ‚‚ iâ‚ƒ jâ‚ jâ‚‚ jâ‚ƒ : fin 3} (hiâ‚â‚‚ : iâ‚ â‰  iâ‚‚) (hiâ‚â‚ƒ : iâ‚ â‰  iâ‚ƒ) (hiâ‚‚â‚ƒ : iâ‚‚ â‰  iâ‚ƒ) (hjâ‚â‚‚ : jâ‚ â‰  jâ‚‚) (hjâ‚â‚ƒ : jâ‚ â‰  jâ‚ƒ) (hjâ‚‚â‚ƒ : jâ‚‚ â‰  jâ‚ƒ) (hâ‚ : tâ‚‚.points jâ‚ = tâ‚.orthocenter) (hâ‚‚ : tâ‚‚.points jâ‚‚ = tâ‚.points iâ‚‚) (hâ‚ƒ : tâ‚‚.points jâ‚ƒ = tâ‚.points iâ‚ƒ) : tâ‚‚.orthocenter = tâ‚.points iâ‚
theorem nnreal.Lp_add_le_tsum {Î¹ : Type u} {f g : Î¹ â†’ nnreal} {p : â„} (hp : 1 â‰¤ p) (hf : summable (Î» (i : Î¹), f i ^ p)) (hg : summable (Î» (i : Î¹), g i ^ p)) : summable (Î» (i : Î¹), (f i + g i) ^ p) âˆ§ (âˆ‘' (i : Î¹), (f i + g i) ^ p) ^ (1 / p) â‰¤ (âˆ‘' (i : Î¹), f i ^ p) ^ (1 / p) + (âˆ‘' (i : Î¹), g i ^ p) ^ (1 / p)
theorem tendsto_comp_of_locally_uniform_limit {Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_4} [uniform_space Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {x : Î±} {p : filter Î¹} {g : Î¹ â†’ Î±} [topological_space Î±] (h : continuous_at f x) (hg : filter.tendsto g p (nhds x)) (hunif : âˆ€ (u : set (Î² Ã— Î²)), u âˆˆ uniformity Î² â†’ (âˆƒ (t : set Î±) (H : t âˆˆ nhds x), âˆ€á¶  (n : Î¹) in p, âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F n y) âˆˆ u)) : filter.tendsto (Î» (n : Î¹), F n (g n)) p (nhds (f x))
theorem is_smul_regular.mul_iff {R : Type u_1} {M : Type u_3} {a b : R} [comm_semigroup R] [has_scalar R M] [is_scalar_tower R R M] : is_smul_regular M (a * b) â†” is_smul_regular M a âˆ§ is_smul_regular M b
theorem measure_theory.has_finite_integral.tendsto_set_integral_nhds_zero {Î± : Type u_1} {E : Type u_2} [normed_group E] [normed_space â„ E] [complete_space E] {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {Î¹ : Type u_3} {f : Î± â†’ E} (hf : measure_theory.has_finite_integral f Î¼) {l : filter Î¹} {s : Î¹ â†’ set Î±} (hs : filter.tendsto (â‡‘Î¼ âˆ˜ s) l (nhds 0)) : filter.tendsto (Î» (i : Î¹), âˆ« (x : Î±) in s i, f x âˆ‚Î¼) l (nhds 0)
theorem irreducible.dvd_symm {Î± : Type u_1} [monoid Î±] {p q : Î±} (hp : irreducible p) (hq : irreducible q) : p âˆ£ q â†’ q âˆ£ p
theorem is_field_of_is_integral_of_is_field {R : Type u_1} {S : Type u_2} [comm_ring R] [nontrivial R] [comm_ring S] [is_domain S] [algebra R S] (H : algebra.is_integral R S) (hRS : function.injective â‡‘(algebra_map R S)) (hS : is_field S) : is_field R
theorem infi_eq_infi_finset {Î± : Type u_1} {Î¹ : Type u_4} [complete_lattice Î±] (s : Î¹ â†’ Î±) : (â¨… (i : Î¹), s i) = â¨… (t : finset Î¹) (i : Î¹) (H : i âˆˆ t), s i
theorem subring.sub_mem {R : Type u} [ring R] (s : subring R) {x y : R} (hx : x âˆˆ s) (hy : y âˆˆ s) : x - y âˆˆ s
theorem convex_cone.ext {ğ•œ : Type u_1} {E : Type u_2} [ordered_semiring ğ•œ] [add_comm_monoid E] [has_scalar ğ•œ E] {S T : convex_cone ğ•œ E} (h : âˆ€ (x : E), x âˆˆ S â†” x âˆˆ T) : S = T
theorem nat.factorization_choose_le_one {p n k : â„•} (p_large : n < p ^ 2) : â‡‘((n.choose k).factorization) p â‰¤ 1
theorem Module.cokernel_Ï€_image_subobject_ext {R : Type u} [ring R] {L M N : Module R} (f : L âŸ¶ M) [category_theory.limits.has_image f] (g : â†‘(category_theory.limits.image_subobject f) âŸ¶ N) [category_theory.limits.has_cokernel g] {x y : â†¥N} (l : â†¥L) (w : x = y + â‡‘g (â‡‘(category_theory.limits.factor_thru_image_subobject f) l)) : â‡‘(category_theory.limits.cokernel.Ï€ g) x = â‡‘(category_theory.limits.cokernel.Ï€ g) y
theorem edist_le_range_sum_edist {Î± : Type u} [pseudo_emetric_space Î±] (f : â„• â†’ Î±) (n : â„•) : has_edist.edist (f 0) (f n) â‰¤ (finset.range n).sum (Î» (i : â„•), has_edist.edist (f i) (f (i + 1)))
theorem cont_diff_within_at.sub {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {x : E} {n : with_top â„•} {s : set E} {f g : E â†’ F} (hf : cont_diff_within_at ğ•œ n f s x) (hg : cont_diff_within_at ğ•œ n g s x) : cont_diff_within_at ğ•œ n (Î» (x : E), f x - g x) s x
theorem krull_topology_t2 {K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (h_int : algebra.is_integral K L) : t2_space (L â‰ƒâ‚[K] L)
theorem linear_map.bound_of_continuous {ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_normed_group E] [semi_normed_group F] [nondiscrete_normed_field ğ•œ] [nondiscrete_normed_field ğ•œâ‚‚] [normed_space ğ•œ E] [normed_space ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} [ring_hom_isometric Ïƒâ‚â‚‚] (f : E â†’â‚›â‚—[Ïƒâ‚â‚‚] F) (hf : continuous â‡‘f) : âˆƒ (C : â„), 0 < C âˆ§ âˆ€ (x : E), âˆ¥â‡‘f xâˆ¥ â‰¤ C * âˆ¥xâˆ¥
theorem local_homeomorph.to_open_embedding {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] (e : local_homeomorph Î± Î²) (h : e.to_local_equiv.source = set.univ) : open_embedding â‡‘e
theorem continuous.homeo_of_equiv_compact_to_t2.t1_counterexample  : âˆƒ (Î± Î² : Type) (IÎ± : topological_space Î±) (IÎ² : topological_space Î²), compact_space Î± âˆ§ t1_space Î² âˆ§ âˆƒ (f : Î± â‰ƒ Î²), continuous â‡‘f âˆ§ Â¬continuous â‡‘(f.symm)
theorem is_torsion.of_surjective {G : Type u_1} {H : Type u_2} [group G] [group H] {f : G â†’* H} (hf : function.surjective â‡‘f) (tG : monoid.is_torsion G) : monoid.is_torsion H
theorem add_is_torsion.of_surjective {G : Type u_1} {H : Type u_2} [add_group G] [add_group H] {f : G â†’+ H} (hf : function.surjective â‡‘f) (tG : add_monoid.is_torsion G) : add_monoid.is_torsion H
theorem is_cyclic_of_prime_card {Î± : Type u} [group Î±] [fintype Î±] {p : â„•} [hp : fact (nat.prime p)] (h : fintype.card Î± = p) : is_cyclic Î±
theorem add_submonoid.ext {M : Type u_1} [add_zero_class M] {S T : add_submonoid M} (h : âˆ€ (x : M), x âˆˆ S â†” x âˆˆ T) : S = T
theorem subset_closure_inter_of_is_preirreducible_of_is_open {Î± : Type u} [topological_space Î±] {S U : set Î±} (hS : is_preirreducible S) (hU : is_open U) (h : (S âˆ© U).nonempty) : S âŠ† closure (S âˆ© U)
theorem matrix.minor_diagonal {l : Type u_1} {m : Type u_2} {Î± : Type v} [has_zero Î±] [decidable_eq m] [decidable_eq l] (d : m â†’ Î±) (e : l â†’ m) (he : function.injective e) : (matrix.diagonal d).minor e e = matrix.diagonal (d âˆ˜ e)
theorem eq_zero_of_mul_eq_self_right {Mâ‚€ : Type u_1} [cancel_monoid_with_zero Mâ‚€] {a b : Mâ‚€} (hâ‚ : b â‰  1) (hâ‚‚ : a * b = a) : a = 0
theorem cardinal.mul_eq_max {a b : cardinal} (ha : cardinal.aleph_0 â‰¤ a) (hb : cardinal.aleph_0 â‰¤ b) : a * b = linear_order.max a b
theorem is_max_on.of_is_local_max_of_convex_univ {E : Type u_1} {Î² : Type u_2} [add_comm_group E] [topological_space E] [module â„ E] [topological_add_group E] [has_continuous_smul â„ E] [ordered_add_comm_group Î²] [module â„ Î²] [ordered_smul â„ Î²] {f : E â†’ Î²} {a : E} (h_local_max : is_local_max f a) (h_conc : concave_on â„ set.univ f) (x : E) : f x â‰¤ f a
theorem is_o_rpow_exp_pos_mul_at_top (s : â„) {b : â„} (hb : 0 < b) : (Î» (x : â„), x ^ s) =o[filter.at_top] Î» (x : â„), real.exp (b * x)
theorem category_theory.limits.as_factor_thru_image {C : Type u} [category_theory.category C] {X Y : C} (f : X âŸ¶ Y) [category_theory.limits.has_image f] : (category_theory.limits.image.mono_factorisation f).e = category_theory.limits.factor_thru_image f
theorem intermediate_field.fixing_subgroup.bot {K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] : âŠ¥.fixing_subgroup = âŠ¤
theorem category_theory.functor.hext {C : Type uâ‚} [category_theory.category C] {D : Type uâ‚‚} [category_theory.category D] {F G : C â¥¤ D} (h_obj : âˆ€ (X : C), F.obj X = G.obj X) (h_map : âˆ€ (X Y : C) (f : X âŸ¶ Y), F.map f == G.map f) : F = G
theorem bounded_continuous_function.exists_extension_forall_mem_of_closed_embedding {X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] [normal_space Y] (f : bounded_continuous_function X â„) {t : set â„} {e : X â†’ Y} [hs : t.ord_connected] (hf : âˆ€ (x : X), â‡‘f x âˆˆ t) (hne : t.nonempty) (he : closed_embedding e) : âˆƒ (g : bounded_continuous_function Y â„), (âˆ€ (y : Y), â‡‘g y âˆˆ t) âˆ§ â‡‘g âˆ˜ e = â‡‘f
theorem category_theory.abelian.pseudoelement.comp_comp {C : Type u} [category_theory.category C] [category_theory.abelian C] {P Q R : C} (f : P âŸ¶ Q) (g : Q âŸ¶ R) : â‡‘g âˆ˜ â‡‘f = â‡‘(f â‰« g)
theorem sub_pow_two {R : Type uâ‚} [comm_ring R] (a b : R) : (a - b) ^ 2 = a ^ 2 - 2 * a * b + b ^ 2
theorem path.homotopic.comp_pi_eq_pi_comp {Î¹ : Type u_1} {X : Î¹ â†’ Type u_2} [Î  (i : Î¹), topological_space (X i)] {as bs cs : Î  (i : Î¹), X i} (Î³â‚€ : Î  (i : Î¹), path.homotopic.quotient (as i) (bs i)) (Î³â‚ : Î  (i : Î¹), path.homotopic.quotient (bs i) (cs i)) : (path.homotopic.pi Î³â‚€).comp (path.homotopic.pi Î³â‚) = path.homotopic.pi (Î» (i : Î¹), (Î³â‚€ i).comp (Î³â‚ i))
theorem is_p_group.nonempty_fixed_point_of_prime_not_dvd_card {p : â„•} {G : Type u_1} [group G] (hG : is_p_group p G) [hp : fact (nat.prime p)] (Î± : Type u_2) [mul_action G Î±] [fintype Î±] [fintype â†¥(mul_action.fixed_points G Î±)] (hpÎ± : Â¬p âˆ£ fintype.card Î±) : (mul_action.fixed_points G Î±).nonempty
theorem affine_subspace.convex {ğ•œ : Type u_1} {E : Type u_2} [ordered_ring ğ•œ] [add_comm_group E] [module ğ•œ E] (Q : affine_subspace ğ•œ E) : convex ğ•œ â†‘Q
theorem measure_theory.Lp.simple_func.mem_â„’p {Î± : Type u_1} {E : Type u_4} [measurable_space Î±] [normed_group E] {p : ennreal} {Î¼ : measure_theory.measure Î±} (f : â†¥(measure_theory.Lp.simple_func E p Î¼)) : measure_theory.mem_â„’p â‡‘(measure_theory.Lp.simple_func.to_simple_func f) p Î¼
theorem is_localization.exists_integer_multiple {R : Type u_1} [comm_ring R] (M : submonoid R) {S : Type u_2} [comm_ring S] [algebra R S] [is_localization M S] (a : S) : âˆƒ (b : â†¥M), is_localization.is_integer R (â†‘b â€¢ a)
theorem nat.sub_mod_eq_zero_of_mod_eq {a b c : â„•} (h : a % c = b % c) : (a - b) % c = 0
theorem measure_theory.Lp_to_Lp_restrict_smul {Î± : Type u_1} {F : Type u_4} [measurable_space Î±] {ğ•œ : Type u_5} [normed_field ğ•œ] [normed_group F] [normed_space ğ•œ F] {p : ennreal} {Î¼ : measure_theory.measure Î±} (c : ğ•œ) (f : â†¥(measure_theory.Lp F p Î¼)) (s : set Î±) : measure_theory.mem_â„’p.to_Lp â‡‘(c â€¢ f) _ = c â€¢ measure_theory.mem_â„’p.to_Lp â‡‘f _
theorem complex.finrank_real_complex_fact  : fact (finite_dimensional.finrank â„ â„‚ = 2)
theorem intermediate_field.fixing_subgroup_is_open {K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (E : intermediate_field K L) [finite_dimensional K â†¥E] : is_open â†‘(E.fixing_subgroup)
theorem finset.nat.sum_antidiagonal_eq_sum_range_succ {M : Type u_1} [add_comm_monoid M] (f : â„• â†’ â„• â†’ M) (n : â„•) : (finset.nat.antidiagonal n).sum (Î» (ij : â„• Ã— â„•), f ij.fst ij.snd) = (finset.range n.succ).sum (Î» (k : â„•), f k (n - k))
theorem measure_theory.lintegral_infi {Î± : Type u_1} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {f : â„• â†’ Î± â†’ ennreal} (h_meas : âˆ€ (n : â„•), measurable (f n)) (h_anti : antitone f) (h_fin : âˆ«â» (a : Î±), f 0 a âˆ‚Î¼ â‰  âŠ¤) : âˆ«â» (a : Î±), (â¨… (n : â„•), f n a) âˆ‚Î¼ = â¨… (n : â„•), âˆ«â» (a : Î±), f n a âˆ‚Î¼
theorem simple_graph.le_min_degree_of_forall_le_degree {V : Type u} (G : simple_graph V) [fintype V] [decidable_rel G.adj] [nonempty V] (k : â„•) (h : âˆ€ (v : V), k â‰¤ G.degree v) : k â‰¤ G.min_degree
theorem measure_theory.tendsto_lintegral_thickened_indicator_of_is_closed {Î± : Type u_1} [measurable_space Î±] [pseudo_emetric_space Î±] [opens_measurable_space Î±] (Î¼ : measure_theory.finite_measure Î±) {F : set Î±} (F_closed : is_closed F) {Î´s : â„• â†’ â„} (Î´s_pos : âˆ€ (n : â„•), 0 < Î´s n) (Î´s_lim : filter.tendsto Î´s filter.at_top (nhds 0)) : filter.tendsto (Î» (n : â„•), âˆ«â» (a : Î±), â†‘(â‡‘(thickened_indicator _ F) a) âˆ‚â†‘Î¼) filter.at_top (nhds (â‡‘â†‘Î¼ F))
theorem AddMon.filtered_colimits.colimit_add_aux_eq_of_rel_right {J : Type v} [category_theory.small_category J] (F : J â¥¤ AddMon) [category_theory.is_filtered J] {x y y' : Î£ (j : J), â†¥(F.obj j)} (hyy' : category_theory.limits.types.filtered_colimit.rel (F â‹™ category_theory.forget AddMon) y y') : AddMon.filtered_colimits.colimit_add_aux F x y = AddMon.filtered_colimits.colimit_add_aux F x y'
theorem encodable.axiom_of_choice {Î± : Type u_1} {Î² : Î± â†’ Type u_2} {R : Î  (x : Î±), Î² x â†’ Prop} [Î  (a : Î±), encodable (Î² a)] [Î  (x : Î±) (y : Î² x), decidable (R x y)] (H : âˆ€ (x : Î±), âˆƒ (y : Î² x), R x y) : âˆƒ (f : Î  (a : Î±), Î² a), âˆ€ (x : Î±), R x (f x)
theorem complex.integral_boundary_rect_eq_zero_of_differentiable_on {E : Type u} [normed_group E] [normed_space â„‚ E] [complete_space E] (f : â„‚ â†’ E) (z w : â„‚) (H : differentiable_on â„‚ f (set.interval z.re w.re Ã—â„‚ set.interval z.im w.im)) : (((âˆ« (x : â„) in z.re..w.re, f (â†‘x + â†‘(z.im) * complex.I)) - âˆ« (x : â„) in z.re..w.re, f (â†‘x + â†‘(w.im) * complex.I)) + complex.I â€¢ âˆ« (y : â„) in z.im..w.im, f (â†‘(w.re) + â†‘y * complex.I)) - complex.I â€¢ âˆ« (y : â„) in z.im..w.im, f (â†‘(z.re) + â†‘y * complex.I) = 0
theorem category_theory.abelian.pseudoelement.comp_apply {C : Type u} [category_theory.category C] [category_theory.abelian C] {P Q R : C} (f : P âŸ¶ Q) (g : Q âŸ¶ R) (a : â†¥P) : â‡‘(f â‰« g) a = â‡‘g (â‡‘f a)
theorem vector.ext {n : â„•} {Î± : Type u_1} {v w : vector Î± n} (h : âˆ€ (m : fin n), v.nth m = w.nth m) : v = w
theorem star_div' {R : Type u} [field R] [star_ring R] (x y : R) : has_star.star (x / y) = has_star.star x / has_star.star y
theorem add_monoid_hom.is_of_fin_order {G : Type u} [add_monoid G] {H : Type v} [add_monoid H] (f : G â†’+ H) {x : G} (h : is_of_fin_add_order x) : is_of_fin_add_order (â‡‘f x)
theorem finset.centroid_weights_indicator_def (k : Type u_1) [division_ring k] {Î¹ : Type u_4} (s : finset Î¹) : finset.centroid_weights_indicator k s = â†‘s.indicator (finset.centroid_weights k s)
theorem sup_Inf_le_infi_sup {Î± : Type u_1} [complete_lattice Î±] {a : Î±} {s : set Î±} : a âŠ” has_Inf.Inf s â‰¤ â¨… (b : Î±) (H : b âˆˆ s), a âŠ” b
theorem differentiable_on.circle_integral_sub_inv_smul {E : Type u} [normed_group E] [normed_space â„‚ E] [complete_space E] {R : â„} {c w : â„‚} {f : â„‚ â†’ E} (hd : differentiable_on â„‚ f (metric.closed_ball c R)) (hw : w âˆˆ metric.ball c R) : âˆ® (z : â„‚) in C(c, R), (z - w)â»Â¹ â€¢ f z = (2 * â†‘real.pi * complex.I) â€¢ f w
theorem Top.sheaf.exists_unique_gluing {C : Type u} [category_theory.category C] [category_theory.concrete_category C] [category_theory.limits.has_limits C] [category_theory.reflects_isomorphisms (category_theory.concrete_category.forget C)] [category_theory.limits.preserves_limits (category_theory.concrete_category.forget C)] {X : Top} (F : Top.sheaf C X) {Î¹ : Type v} (U : Î¹ â†’ topological_space.opens â†¥X) (sf : Î  (i : Î¹), â†¥(F.val.obj (opposite.op (U i)))) (h : F.val.is_compatible U sf) : âˆƒ! (s : â†¥(F.val.obj (opposite.op (supr U)))), F.val.is_gluing U sf s
theorem continuous_at.snd' {Î± : Type u} {Î² : Type v} {Î³ : Type u_1} [topological_space Î±] [topological_space Î²] [topological_space Î³] {f : Î² â†’ Î³} {x : Î±} {y : Î²} (hf : continuous_at f y) : continuous_at (Î» (x : Î± Ã— Î²), f x.snd) (x, y)
theorem filter.eventually.of_small_sets {Î± : Type u_1} {l : filter Î±} {p : Î± â†’ Prop} : (âˆ€á¶  (s : set Î±) in l.small_sets, âˆ€ (x : Î±), x âˆˆ s â†’ p x) â†’ (âˆ€á¶  (x : Î±) in l, p x)
theorem affine_independent.vector_span_image_finset_eq_of_le_of_card_eq_finrank_add_one {k : Type u_1} {V : Type u_2} {P : Type u_3} {Î¹ : Type u_4} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] {p : Î¹ â†’ P} (hi : affine_independent k p) {s : finset Î¹} {sm : submodule k V} [finite_dimensional k â†¥sm] (hle : vector_span k â†‘(finset.image p s) â‰¤ sm) (hc : s.card = finite_dimensional.finrank k â†¥sm + 1) : vector_span k â†‘(finset.image p s) = sm
theorem metric.bounded_iff_ediam_ne_top {Î± : Type u} [pseudo_metric_space Î±] {s : set Î±} : metric.bounded s â†” emetric.diam s â‰  âŠ¤
theorem mdifferentiable_at_iff_differentiable_at {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {E' : Type u_3} [normed_group E'] [normed_space ğ•œ E'] {f : E â†’ E'} {x : E} : mdifferentiable_at (model_with_corners_self ğ•œ E) (model_with_corners_self ğ•œ E') f x â†” differentiable_at ğ•œ f x
theorem list.sublist_of_order_embedding_nth_eq {Î± : Type u_1} {l l' : list Î±} (f : â„• â†ªo â„•) (hf : âˆ€ (ix : â„•), l.nth ix = l'.nth (â‡‘f ix)) : l <+ l'
theorem continuous_map.subalgebra_topological_closure_eq_top_of_separates_points {X : Type u_1} [topological_space X] [compact_space X] (A : subalgebra â„ C(X, â„)) (w : A.separates_points) : A.topological_closure = âŠ¤
theorem abs_real_inner_div_norm_mul_norm_eq_one_of_ne_zero_of_ne_zero_mul {F : Type u_3} [inner_product_space â„ F] {x : F} {r : â„} (hx : x â‰  0) (hr : r â‰  0) : |has_inner.inner x (r â€¢ x)| / (âˆ¥xâˆ¥ * âˆ¥r â€¢ xâˆ¥) = 1
theorem orientation.oangle_sub_left {V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) {x y z : V} (hx : x â‰  0) (hy : y â‰  0) (hz : z â‰  0) : o.oangle x z - o.oangle x y = o.oangle y z
theorem measure_theory.measure.ext_of_Ioc' {Î± : Type u_1} [topological_space Î±] {m : measurable_space Î±} [topological_space.second_countable_topology Î±] [linear_order Î±] [order_topology Î±] [borel_space Î±] [no_min_order Î±] (Î¼ Î½ : measure_theory.measure Î±) (hÎ¼ : âˆ€ â¦ƒa b : Î±â¦„, a < b â†’ â‡‘Î¼ (set.Ioc a b) â‰  âŠ¤) (h : âˆ€ â¦ƒa b : Î±â¦„, a < b â†’ â‡‘Î¼ (set.Ioc a b) = â‡‘Î½ (set.Ioc a b)) : Î¼ = Î½
theorem affine_subspace.span_univ (k : Type u_1) (V : Type u_2) (P : Type u_3) [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] : affine_span k set.univ = âŠ¤
theorem convex_on.slope_mono_adjacent {ğ•œ : Type u_1} [linear_ordered_field ğ•œ] {s : set ğ•œ} {f : ğ•œ â†’ ğ•œ} (hf : convex_on ğ•œ s f) {x y z : ğ•œ} (hx : x âˆˆ s) (hz : z âˆˆ s) (hxy : x < y) (hyz : y < z) : (f y - f x) / (y - x) â‰¤ (f z - f y) / (z - y)
theorem polynomial_functions_closure_eq_top (a b : â„) : (polynomial_functions (set.Icc a b)).topological_closure = âŠ¤
theorem monotone.map_bdd_above {Î± : Type u} {Î² : Type v} [preorder Î±] [preorder Î²] {f : Î± â†’ Î²} (Hf : monotone f) {s : set Î±} : bdd_above s â†’ bdd_above (f '' s)
theorem continuous_map_mem_polynomial_functions_closure (a b : â„) (f : C(â†¥(set.Icc a b), â„)) : f âˆˆ (polynomial_functions (set.Icc a b)).topological_closure
theorem convex_hull_affine_basis_eq_nonneg_barycentric {R : Type u_1} {E : Type u_2} [linear_ordered_field R] [add_comm_group E] [module R E] {Î¹ : Type u_3} (b : affine_basis Î¹ R E) : â‡‘(convex_hull R) (set.range b.points) = {x : E | âˆ€ (i : Î¹), 0 â‰¤ â‡‘(b.coord i) x}
theorem has_mem.mem.out {Î± : Type u} {p : Î± â†’ Prop} {a : Î±} (h : a âˆˆ {x : Î± | p x}) : p a
theorem fin.tail_update_zero {n : â„•} {Î± : fin (n + 1) â†’ Type u} (q : Î  (i : fin (n + 1)), Î± i) (z : Î± 0) : fin.tail (function.update q 0 z) = fin.tail q
theorem finset.shadow_monotone {Î± : Type u_1} [decidable_eq Î±] : monotone finset.shadow
theorem pi.const_ring_hom_eq_algebra_map (R : Type u_1) (A : Type u_2) [comm_semiring R] : pi.const_ring_hom A R = algebra_map R (A â†’ R)
theorem category_theory.presieve.is_sheaf_for.is_separated_for {C : Type uâ‚} [category_theory.category C] {P : Cáµ’áµ– â¥¤ Type w} {X : C} {R : category_theory.presieve X} : category_theory.presieve.is_sheaf_for P R â†’ category_theory.presieve.is_separated_for P R
theorem succ.rec {Î± : Type u_1} [preorder Î±] [succ_order Î±] [is_succ_archimedean Î±] {P : Î± â†’ Prop} {m : Î±} (h0 : P m) (h1 : âˆ€ (n : Î±), m â‰¤ n â†’ P n â†’ P (order.succ n)) â¦ƒn : Î±â¦„ (hmn : m â‰¤ n) : P n
theorem map_zsmul {G : Type u_6} {H : Type u_7} {F : Type u_8} [add_group G] [subtraction_monoid H] [add_monoid_hom_class F G H] (f : F) (n : â„¤) (g : G) : â‡‘f (n â€¢ g) = n â€¢ â‡‘f g
theorem nat.totient_eq_mul_prod_factors (n : â„•) : â†‘(n.totient) = â†‘n * n.factors.to_finset.prod (Î» (p : â„•), 1 - (â†‘p)â»Â¹)
theorem Hausdorffification.lift_eq {R : Type u_1} [comm_ring R] (I : ideal R) {M : Type u_2} [add_comm_group M] [module R M] {N : Type u_3} [add_comm_group N] [module R N] [h : is_Hausdorff I N] (f : M â†’â‚—[R] N) (g : Hausdorffification I M â†’â‚—[R] N) (hg : g.comp (Hausdorffification.of I M) = f) : g = Hausdorffification.lift I f
theorem seminorm.gauge_ball {E : Type u_1} [add_comm_group E] [module â„ E] (p : seminorm â„ E) : gauge (p.ball 0 1) = â‡‘p
theorem real_inner_div_norm_mul_norm_eq_neg_one_of_ne_zero_of_neg_mul {F : Type u_3} [inner_product_space â„ F] {x : F} {r : â„} (hx : x â‰  0) (hr : r < 0) : has_inner.inner x (r â€¢ x) / (âˆ¥xâˆ¥ * âˆ¥r â€¢ xâˆ¥) = -1
theorem simple_graph.inc_matrix_apply' {R : Type u_1} {Î± : Type u_2} (G : simple_graph Î±) [has_zero R] [has_one R] [decidable_eq Î±] [decidable_rel G.adj] {a : Î±} {e : sym2 Î±} : simple_graph.inc_matrix R G a e = ite (e âˆˆ G.incidence_set a) 1 0
theorem cont_mdiff_within_at.comp {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners ğ•œ E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] {f : M â†’ M'} {s : set M} {n : with_top â„•} {E'' : Type u_14} [normed_group E''] [normed_space ğ•œ E''] {H'' : Type u_15} [topological_space H''] {I'' : model_with_corners ğ•œ E'' H''} {M'' : Type u_16} [topological_space M''] [charted_space H'' M''] {t : set M'} {g : M' â†’ M''} (x : M) (hg : cont_mdiff_within_at I' I'' n g t (f x)) (hf : cont_mdiff_within_at I I' n f s x) (st : set.maps_to f s t) : cont_mdiff_within_at I I'' n (g âˆ˜ f) s x
theorem matrix.inv_of_mul_self_assoc {m : Type u} {n : Type u'} {Î± : Type v} [fintype n] [decidable_eq n] [comm_ring Î±] (A : matrix n n Î±) (B : matrix n m Î±) [invertible A] : (â…Ÿ A).mul (A.mul B) = B
theorem metric.tendsto_at_top' {Î± : Type u} {Î² : Type v} [pseudo_metric_space Î±] [nonempty Î²] [semilattice_sup Î²] [no_max_order Î²] {u : Î² â†’ Î±} {a : Î±} : filter.tendsto u filter.at_top (nhds a) â†” âˆ€ (Îµ : â„), Îµ > 0 â†’ (âˆƒ (N : Î²), âˆ€ (n : Î²), n > N â†’ has_dist.dist (u n) a < Îµ)
theorem padic_norm.zero_of_padic_norm_eq_zero (p : â„•) [hp : fact (nat.prime p)] {q : â„š} (h : padic_norm p q = 0) : q = 0
theorem is_cyclotomic_extension.rat.discr_prime_pow_ne_two' {p : â„•+} {k : â„•} {K : Type u} [field K] [char_zero K] {Î¶ : K} [hp : fact (nat.prime â†‘p)] [is_cyclotomic_extension {p ^ (k + 1)} â„š K] (hÎ¶ : is_primitive_root Î¶ â†‘(p ^ (k + 1))) (hk : p ^ (k + 1) â‰  2) : algebra.discr â„š â‡‘((is_primitive_root.sub_one_power_basis â„š hÎ¶).basis) = (-1) ^ ((â†‘p ^ (k + 1)).totient / 2) * â†‘p ^ (â†‘p ^ k * ((â†‘p - 1) * (k + 1) - 1))
theorem orientation.oangle_neg_neg {V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) (x y : V) : o.oangle (-x) (-y) = o.oangle x y
theorem nat.exists_strict_mono' {Î± : Type u} [preorder Î±] [no_max_order Î±] (a : Î±) : âˆƒ (f : â„• â†’ Î±), strict_mono f âˆ§ f 0 = a
theorem besicovitch.exist_finset_disjoint_balls_large_measure {Î± : Type u_1} [metric_space Î±] [topological_space.second_countable_topology Î±] [measurable_space Î±] [opens_measurable_space Î±] (Î¼ : measure_theory.measure Î±) [measure_theory.is_finite_measure Î¼] {N : â„•} {Ï„ : â„} (hÏ„ : 1 < Ï„) (hN : is_empty (besicovitch.satellite_config Î± N Ï„)) (s : set Î±) (r : Î± â†’ â„) (rpos : âˆ€ (x : Î±), x âˆˆ s â†’ 0 < r x) (rle : âˆ€ (x : Î±), x âˆˆ s â†’ r x â‰¤ 1) : âˆƒ (t : finset Î±), â†‘t âŠ† s âˆ§ â‡‘Î¼ (s  â‹ƒ (x : Î±) (H : x âˆˆ t), metric.closed_ball x (r x)) â‰¤ â†‘N / (â†‘N + 1) * â‡‘Î¼ s âˆ§ â†‘t.pairwise_disjoint (Î» (x : Î±), metric.closed_ball x (r x))
theorem cSup_eq_of_forall_le_of_forall_lt_exists_gt {Î± : Type u_1} [conditionally_complete_lattice Î±] {s : set Î±} {b : Î±} (hs : s.nonempty) (H : âˆ€ (a : Î±), a âˆˆ s â†’ a â‰¤ b) (H' : âˆ€ (w : Î±), w < b â†’ (âˆƒ (a : Î±) (H : a âˆˆ s), w < a)) : has_Sup.Sup s = b
theorem polynomial.gal.card_complex_roots_eq_card_real_add_card_not_gal_inv (p : polynomial â„š) : (p.root_set â„‚).to_finset.card = (p.root_set â„).to_finset.card + (â‡‘(polynomial.gal.gal_action_hom p â„‚) (â‡‘(polynomial.gal.restrict p â„‚) (alg_equiv.restrict_scalars â„š complex.conj_ae))).support.card
theorem modular_group.tendsto_norm_sq_coprime_pair (z : upper_half_plane) : filter.tendsto (Î» (p : fin 2 â†’ â„¤), â‡‘complex.norm_sq (â†‘(p 0) * â†‘z + â†‘(p 1))) filter.cofinite filter.at_top
theorem measure_theory.measure_is_open_pos_of_vadd_invariant_of_compact_ne_zero (G : Type u_1) {Î± : Type u_3} {m : measurable_space Î±} [add_group G] [add_action G Î±] [measurable_space G] [has_measurable_vadd G Î±] {Î¼ : measure_theory.measure Î±} [measure_theory.vadd_invariant_measure G Î± Î¼] [topological_space Î±] [has_continuous_const_vadd G Î±] [add_action.is_minimal G Î±] {K U : set Î±} (hK : is_compact K) (hÎ¼K : â‡‘Î¼ K â‰  0) (hU : is_open U) (hne : U.nonempty) : 0 < â‡‘Î¼ U
theorem witt_vector.verschiebung_is_poly {p : â„•} [hp : fact (nat.prime p)] : witt_vector.is_poly p (Î» (R : Type u_1) (_Rcr : comm_ring R), â‡‘witt_vector.verschiebung)
theorem bump_covering.exists_is_subordinate {Î¹ : Type u} {X : Type v} [topological_space X] {s : set X} [normal_space X] [paracompact_space X] (hs : is_closed s) (U : Î¹ â†’ set X) (ho : âˆ€ (i : Î¹), is_open (U i)) (hU : s âŠ† â‹ƒ (i : Î¹), U i) : âˆƒ (f : bump_covering Î¹ X s), f.is_subordinate U
theorem category_theory.subobject.inf_map {C : Type uâ‚} [category_theory.category C] [category_theory.limits.has_pullbacks C] {X Y : C} (g : Y âŸ¶ X) [category_theory.mono g] (fâ‚ fâ‚‚ : category_theory.subobject Y) : (category_theory.subobject.map g).obj (fâ‚ âŠ“ fâ‚‚) = (category_theory.subobject.map g).obj fâ‚ âŠ“ (category_theory.subobject.map g).obj fâ‚‚
theorem AddMon.filtered_colimits.colimit_zero_eq {J : Type v} [category_theory.small_category J] (F : J â¥¤ AddMon) [category_theory.is_filtered J] (j : J) : 0 = AddMon.filtered_colimits.M.mk F âŸ¨j, 0âŸ©
theorem is_closed.mem_iff_inf_dist_zero {Î± : Type u} [pseudo_metric_space Î±] {s : set Î±} {x : Î±} (h : is_closed s) (hs : s.nonempty) : x âˆˆ s â†” metric.inf_dist x s = 0
theorem subalgebra.separates_points.is_R_or_C_to_real {ğ•œ : Type u_1} {X : Type u_2} [is_R_or_C ğ•œ] [topological_space X] {A : subalgebra ğ•œ C(X, ğ•œ)} (hA : A.separates_points) (hA' : continuous_map.conj_invariant_subalgebra (subalgebra.restrict_scalars â„ A)) : ((subalgebra.restrict_scalars â„ A).comap' (alg_hom.comp_left_continuous â„ is_R_or_C.of_real_am is_R_or_C.continuous_of_real)).separates_points
theorem metric.isometry_inl {X : Type u} {Y : Type v} [metric_space X] [metric_space Y] : isometry sum.inl
theorem tendsto_rpow_mul_exp_neg_mul_at_top_nhds_0 (s b : â„) (hb : 0 < b) : filter.tendsto (Î» (x : â„), x ^ s * real.exp (-b * x)) filter.at_top (nhds 0)
theorem metric.bounded.is_compact_closure {Î± : Type u} [pseudo_metric_space Î±] {s : set Î±} [proper_space Î±] (h : metric.bounded s) : is_compact (closure s)
theorem has_sum_coe_mul_geometric_of_norm_lt_1 {ğ•œ : Type u_1} [normed_field ğ•œ] [complete_space ğ•œ] {r : ğ•œ} (hr : âˆ¥râˆ¥ < 1) : has_sum (Î» (n : â„•), â†‘n * r ^ n) (r / (1 - r) ^ 2)
theorem is_local_extr_on.exists_linear_map_of_has_strict_fderiv_at {E : Type u_1} {F : Type u_2} [normed_group E] [normed_space â„ E] [complete_space E] [normed_group F] [normed_space â„ F] [complete_space F] {f : E â†’ F} {Ï† : E â†’ â„} {xâ‚€ : E} {f' : E â†’L[â„] F} {Ï†' : E â†’L[â„] â„} (hextr : is_local_extr_on Ï† {x : E | f x = f xâ‚€} xâ‚€) (hf' : has_strict_fderiv_at f f' xâ‚€) (hÏ†' : has_strict_fderiv_at Ï† Ï†' xâ‚€) : âˆƒ (Î› : module.dual â„ F) (Î›â‚€ : â„), (Î›, Î›â‚€) â‰  0 âˆ§ âˆ€ (x : E), â‡‘Î› (â‡‘f' x) + Î›â‚€ â€¢ â‡‘Ï†' x = 0
theorem re_inner_eq_norm_add_mul_self_sub_norm_sub_mul_self_div_four {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] (x y : E) : â‡‘is_R_or_C.re (has_inner.inner x y) = (âˆ¥x + yâˆ¥ * âˆ¥x + yâˆ¥ - âˆ¥x - yâˆ¥ * âˆ¥x - yâˆ¥) / 4
theorem has_le.le.eq_of_not_lt {Î± : Type u} [partial_order Î±] {a b : Î±} (hab : a â‰¤ b) (hba : Â¬a < b) : a = b
theorem set.inj_on.injective {Î± : Type u} {Î² : Type v} {s : set Î±} {f : Î± â†’ Î²} : set.inj_on f s â†’ function.injective (s.restrict f)
theorem monotone.max {Î± : Type u} {Î² : Type v} [preorder Î±] [linear_order Î²] {f g : Î± â†’ Î²} (hf : monotone f) (hg : monotone g) : monotone (Î» (x : Î±), linear_order.max (f x) (g x))
theorem strict_concave_on_univ_of_deriv2_neg {f : â„ â†’ â„} (hf' : differentiable â„ f) (hf'' : âˆ€ (x : â„), deriv^[2] f x < 0) : strict_concave_on â„ set.univ f
theorem set_like.ext {A : Type u_1} {B : Type u_2} [i : set_like A B] {p q : A} (h : âˆ€ (x : B), x âˆˆ p â†” x âˆˆ q) : p = q
theorem orientation.two_zsmul_oangle_neg_self_left {V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) (x : V) : 2 â€¢ o.oangle (-x) x = 0
theorem filter.tendsto.eventually_interval_integrable_ae {Î¹ : Type u_1} {E : Type u_3} [normed_group E] {f : â„ â†’ E} {Î¼ : measure_theory.measure â„} {l l' : filter â„} (hfm : strongly_measurable_at_filter f l' Î¼) [filter.tendsto_Ixx_class set.Ioc l l'] [l'.is_measurably_generated] (hÎ¼ : Î¼.finite_at_filter l') {c : E} (hf : filter.tendsto f (l' âŠ“ Î¼.ae) (nhds c)) {u v : Î¹ â†’ â„} {lt : filter Î¹} (hu : filter.tendsto u lt l) (hv : filter.tendsto v lt l) : âˆ€á¶  (t : Î¹) in lt, interval_integrable f Î¼ (u t) (v t)
theorem has_le.le.absolutely_continuous_of_ae {Î± : Type u_1} {m0 : measurable_space Î±} {Î¼ Î½ : measure_theory.measure Î±} : Î¼.ae â‰¤ Î½.ae â†’ Î¼.absolutely_continuous Î½
theorem emetric.tendsto_locally_uniformly_iff {Î± : Type u} {Î² : Type v} [pseudo_emetric_space Î±] {Î¹ : Type u_1} [topological_space Î²] {F : Î¹ â†’ Î² â†’ Î±} {f : Î² â†’ Î±} {p : filter Î¹} : tendsto_locally_uniformly F f p â†” âˆ€ (Îµ : ennreal), Îµ > 0 â†’ âˆ€ (x : Î²), âˆƒ (t : set Î²) (H : t âˆˆ nhds x), âˆ€á¶  (n : Î¹) in p, âˆ€ (y : Î²), y âˆˆ t â†’ has_edist.edist (f y) (F n y) < Îµ
theorem polynomial.X_mem_lifts {R : Type u} [semiring R] {S : Type v} [semiring S] (f : R â†’+* S) : polynomial.X âˆˆ polynomial.lifts f
theorem convex_on.exists_ge_of_mem_convex_hull {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [linear_ordered_field ğ•œ] [add_comm_group E] [linear_ordered_add_comm_group Î²] [module ğ•œ E] [module ğ•œ Î²] [ordered_smul ğ•œ Î²] {s : set E} {f : E â†’ Î²} (hf : convex_on ğ•œ (â‡‘(convex_hull ğ•œ) s) f) {x : E} (hx : x âˆˆ â‡‘(convex_hull ğ•œ) s) : âˆƒ (y : E) (H : y âˆˆ s), f x â‰¤ f y
theorem filter.tendsto.limsup_eq {Î± : Type u} {Î² : Type v} [conditionally_complete_linear_order Î±] [topological_space Î±] [order_topology Î±] {f : filter Î²} {u : Î² â†’ Î±} {a : Î±} [f.ne_bot] (h : filter.tendsto u f (nhds a)) : f.limsup u = a
theorem laurent_polynomial.induction_on_mul_T {R : Type u_1} [semiring R] {Q : laurent_polynomial R â†’ Prop} (f : laurent_polynomial R) (Qf : âˆ€ {f : polynomial R} {n : â„•}, Q (â‡‘polynomial.to_laurent f * laurent_polynomial.T (-â†‘n))) : Q f
theorem metric.diam_closed_ball {Î± : Type u} [pseudo_metric_space Î±] {x : Î±} {r : â„} (h : 0 â‰¤ r) : metric.diam (metric.closed_ball x r) â‰¤ 2 * r
theorem ideal.quotient.quotient_ring_saturate {R : Type u} [comm_ring R] (I : ideal R) (s : set R) : â‡‘(ideal.quotient.mk I) â»Â¹' (â‡‘(ideal.quotient.mk I) '' s) = â‹ƒ (x : â†¥I), (Î» (y : R), x.val + y) '' s
theorem order.iso_of_countable_dense (Î± : Type u_1) (Î² : Type u_2) [linear_order Î±] [linear_order Î²] [encodable Î±] [densely_ordered Î±] [no_min_order Î±] [no_max_order Î±] [nonempty Î±] [encodable Î²] [densely_ordered Î²] [no_min_order Î²] [no_max_order Î²] [nonempty Î²] : nonempty (Î± â‰ƒo Î²)
theorem ring_hom.map_bit1 {Î± : Type u_2} {Î² : Type u_3} {rÎ± : non_assoc_semiring Î±} {rÎ² : non_assoc_semiring Î²} (f : Î± â†’+* Î²) (a : Î±) : â‡‘f (bit1 a) = bit1 (â‡‘f a)
theorem poly.ext {Î± : Type u_1} {f g : poly Î±} : (âˆ€ (x : Î± â†’ â„•), â‡‘f x = â‡‘g x) â†’ f = g
theorem ring_hom.map_sub {Î± : Type u_2} {Î² : Type u_3} [non_assoc_ring Î±] [non_assoc_ring Î²] (f : Î± â†’+* Î²) (x y : Î±) : â‡‘f (x - y) = â‡‘f x - â‡‘f y
theorem continuous_multilinear_map.map_sum_finset {R : Type u} {Î¹ : Type v} {Mâ‚ : Î¹ â†’ Type wâ‚} {Mâ‚‚ : Type wâ‚‚} [decidable_eq Î¹] [semiring R] [Î  (i : Î¹), add_comm_monoid (Mâ‚ i)] [add_comm_monoid Mâ‚‚] [Î  (i : Î¹), module R (Mâ‚ i)] [module R Mâ‚‚] [Î  (i : Î¹), topological_space (Mâ‚ i)] [topological_space Mâ‚‚] (f : continuous_multilinear_map R Mâ‚ Mâ‚‚) {Î± : Î¹ â†’ Type u_1} [fintype Î¹] (g : Î  (i : Î¹), Î± i â†’ Mâ‚ i) (A : Î  (i : Î¹), finset (Î± i)) : â‡‘f (Î» (i : Î¹), (A i).sum (Î» (j : Î± i), g i j)) = (fintype.pi_finset A).sum (Î» (r : Î  (a : Î¹), Î± a), â‡‘f (Î» (i : Î¹), g i (r i)))
theorem comp_assoc_right {Î± : Type u_1} (f : Î± â†’ Î± â†’ Î±) [is_associative Î± f] (x y : Î±) : ((Î» (z : Î±), f z x) âˆ˜ Î» (z : Î±), f z y) = Î» (z : Î±), f z (f y x)
theorem category_theory.preadditive.has_equalizer_of_has_kernel {C : Type u} [category_theory.category C] [category_theory.preadditive C] {X Y : C} (f g : X âŸ¶ Y) [category_theory.limits.has_kernel (f - g)] : category_theory.limits.has_equalizer f g
theorem finsum_mem_image {Î± : Type u_1} {Î² : Type u_2} {M : Type u_5} [add_comm_monoid M] {f : Î± â†’ M} {s : set Î²} {g : Î² â†’ Î±} (hg : set.inj_on g s) : finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ g '' s), f i)) = finsum (Î» (j : Î²), finsum (Î» (H : j âˆˆ s), f (g j)))
theorem is_seq_closed_of_def {X : Type u_1} [topological_space X] {s : set X} (h : âˆ€ (x : â„• â†’ X) (a : X), (âˆ€ (n : â„•), x n âˆˆ s) â†’ filter.tendsto x filter.at_top (nhds a) â†’ a âˆˆ s) : is_seq_closed s
theorem nat.dvd_add_self_left {m n : â„•} : m âˆ£ m + n â†” m âˆ£ n
theorem convex_on.comp_affine_map {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} {Î² : Type u_4} [linear_ordered_field ğ•œ] [add_comm_group E] [add_comm_group F] [ordered_add_comm_monoid Î²] [module ğ•œ E] [module ğ•œ F] [has_scalar ğ•œ Î²] {f : F â†’ Î²} (g : E â†’áµƒ[ğ•œ] F) {s : set F} (hf : convex_on ğ•œ s f) : convex_on ğ•œ (â‡‘g â»Â¹' s) (f âˆ˜ â‡‘g)
theorem add_monoid_algebra.map_domain_one {Î± : Type u_1} {Î² : Type u_2} {Î±â‚‚ : Type u_3} [semiring Î²] [has_zero Î±] [has_zero Î±â‚‚] {F : Type u_4} [zero_hom_class F Î± Î±â‚‚] (f : F) : finsupp.map_domain â‡‘f 1 = 1
theorem category_theory.nat_trans.left_derived_eq {C : Type u} [category_theory.category C] {D : Type u_1} [category_theory.category D] [category_theory.preadditive C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_equalizers C] [category_theory.limits.has_images C] [category_theory.has_projective_resolutions C] [category_theory.preadditive D] [category_theory.limits.has_zero_object D] [category_theory.limits.has_equalizers D] [category_theory.limits.has_cokernels D] [category_theory.limits.has_images D] [category_theory.limits.has_image_maps D] {F G : C â¥¤ D} [F.additive] [G.additive] (Î± : F âŸ¶ G) (n : â„•) {X : C} (P : category_theory.ProjectiveResolution X) : (category_theory.nat_trans.left_derived Î± n).app X = (F.left_derived_obj_iso n P).hom â‰« (homology_functor D (complex_shape.down â„•) n).map ((category_theory.nat_trans.map_homological_complex Î± (complex_shape.down â„•)).app P.complex) â‰« (G.left_derived_obj_iso n P).inv
theorem inner_product_geometry.angle_le_pi {V : Type u_1} [inner_product_space â„ V] (x y : V) : inner_product_geometry.angle x y â‰¤ real.pi
theorem linear_map.nondegenerate_restrict_of_disjoint_orthogonal {R : Type u_1} {M : Type u_5} [comm_ring R] [add_comm_group M] [module R M] {B : M â†’â‚—[R] M â†’â‚—[R] R} (hB : B.is_refl) {W : submodule R M} (hW : disjoint W (W.orthogonal_bilin B)) : (B.dom_restrictâ‚â‚‚ W W).nondegenerate
theorem set.sized.up_shadow {Î± : Type u_1} [decidable_eq Î±] [fintype Î±] {ğ’œ : finset (finset Î±)} {r : â„•} (hğ’œ : set.sized r â†‘ğ’œ) : set.sized (r + 1) â†‘(ğ’œ.up_shadow)
theorem structure_groupoid.mem_maximal_atlas_of_mem_atlas {H : Type u} {M : Type u_2} [topological_space H] [topological_space M] [charted_space H M] (G : structure_groupoid H) [has_groupoid M G] {e : local_homeomorph M H} (he : e âˆˆ charted_space.atlas H M) : e âˆˆ structure_groupoid.maximal_atlas M G
theorem is_left_regular_of_mul_eq_one {R : Type u_1} {a b : R} [monoid R] (h : b * a = 1) : is_left_regular a
theorem polynomial.prod_roots_eq_coeff_zero_of_monic_of_split {K : Type v} [field K] {P : polynomial K} (hmo : P.monic) (hP : polynomial.splits (ring_hom.id K) P) : P.coeff 0 = (-1) ^ P.nat_degree * P.roots.prod
theorem lie_module.weight_vector_multiplication {R : Type u} (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] (Mâ‚ : Type wâ‚) (Mâ‚‚ : Type wâ‚‚) (Mâ‚ƒ : Type wâ‚ƒ) [add_comm_group Mâ‚] [module R Mâ‚] [lie_ring_module L Mâ‚] [lie_module R L Mâ‚] [add_comm_group Mâ‚‚] [module R Mâ‚‚] [lie_ring_module L Mâ‚‚] [lie_module R L Mâ‚‚] [add_comm_group Mâ‚ƒ] [module R Mâ‚ƒ] [lie_ring_module L Mâ‚ƒ] [lie_module R L Mâ‚ƒ] (g : tensor_product R Mâ‚ Mâ‚‚ â†’â‚—â…R,Lâ† Mâ‚ƒ) (Ï‡â‚ Ï‡â‚‚ : L â†’ R) : (â†‘g.comp (tensor_product.map_incl (lie_module.pre_weight_space Mâ‚ Ï‡â‚) (lie_module.pre_weight_space Mâ‚‚ Ï‡â‚‚))).range â‰¤ lie_module.pre_weight_space Mâ‚ƒ (Ï‡â‚ + Ï‡â‚‚)
theorem zmod.wilsons_lemma (p : â„•) [fact (nat.prime p)] : â†‘((p - 1).factorial) = -1
theorem is_min_on.undual {Î± : Type u} {Î² : Type v} [preorder Î²] {f : Î± â†’ Î²} {s : set Î±} {a : Î±} : is_min_on (â‡‘order_dual.to_dual âˆ˜ f) s a â†’ is_max_on f s a
theorem filter.tendsto_mul_right_cobounded {Î± : Type u_1} [normed_division_ring Î±] {a : Î±} (ha : a â‰  0) : filter.tendsto (Î» (x : Î±), x * a) (filter.comap has_norm.norm filter.at_top) (filter.comap has_norm.norm filter.at_top)
theorem is_unit.is_regular {R : Type u_1} {a : R} [monoid R] (ua : is_unit a) : is_regular a
theorem deriv.lhopital_zero_nhds' {a : â„} {l : filter â„} {f g : â„ â†’ â„} (hdf : âˆ€á¶  (x : â„) in nhds_within a (set.univ  {a}), differentiable_at â„ f x) (hg' : âˆ€á¶  (x : â„) in nhds_within a (set.univ  {a}), deriv g x â‰  0) (hfa : filter.tendsto f (nhds_within a (set.univ  {a})) (nhds 0)) (hga : filter.tendsto g (nhds_within a (set.univ  {a})) (nhds 0)) (hdiv : filter.tendsto (Î» (x : â„), deriv f x / deriv g x) (nhds_within a (set.univ  {a})) l) : filter.tendsto (Î» (x : â„), f x / g x) (nhds_within a (set.univ  {a})) l
theorem add_submonoid.localization_map.mk'_sec {M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {N : Type u_2} [add_comm_monoid N] (f : S.localization_map N) (z : N) : f.mk' (f.sec z).fst (f.sec z).snd = z
theorem antitone.pairwise_disjoint_on_Ioc_pred {Î± : Type u_1} {Î² : Type u_2} [linear_order Î±] [pred_order Î±] [preorder Î²] {f : Î± â†’ Î²} (hf : antitone f) : pairwise (disjoint on Î» (n : Î±), set.Ioc (f n) (f (order.pred n)))
theorem dfinsupp.single_eq_single_iff {Î¹ : Type u} {Î² : Î¹ â†’ Type v} [dec : decidable_eq Î¹] [Î  (i : Î¹), has_zero (Î² i)] (i j : Î¹) (xi : Î² i) (xj : Î² j) : dfinsupp.single i xi = dfinsupp.single j xj â†” i = j âˆ§ xi == xj âˆ¨ xi = 0 âˆ§ xj = 0
theorem is_mul_hom.mul {Î± : Type u_1} {Î² : Type u_2} [semigroup Î±] [comm_semigroup Î²] {f g : Î± â†’ Î²} (hf : is_mul_hom f) (hg : is_mul_hom g) : is_mul_hom (Î» (a : Î±), f a * g a)
theorem continuous_on_of_uniform_approx_of_continuous_on {Î± : Type u_1} {Î² : Type u_2} [uniform_space Î²] {f : Î± â†’ Î²} {s : set Î±} [topological_space Î±] (L : âˆ€ (u : set (Î² Ã— Î²)), u âˆˆ uniformity Î² â†’ (âˆƒ (F : Î± â†’ Î²), continuous_on F s âˆ§ âˆ€ (y : Î±), y âˆˆ s â†’ (f y, F y) âˆˆ u)) : continuous_on f s
theorem inducing.pseudo_metrizable_space {X : Type u_2} {Y : Type u_3} [topological_space X] [topological_space Y] [topological_space.pseudo_metrizable_space Y] {f : X â†’ Y} (hf : inducing f) : topological_space.pseudo_metrizable_space X
theorem cardinal.to_nat_right_inverse  : function.right_inverse coe â‡‘cardinal.to_nat
theorem commute.quaternion_conj {R : Type u_1} [comm_ring R] {a b : quaternion R} (h : commute a b) : commute (â‡‘quaternion.conj a) (â‡‘quaternion.conj b)
theorem measure_theory.uniform_integrable_fintype {Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_3} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [normed_group Î²] {p : ennreal} {f : Î¹ â†’ Î± â†’ Î²} [fintype Î¹] (hp_one : 1 â‰¤ p) (hp_top : p â‰  âŠ¤) (hf : âˆ€ (i : Î¹), measure_theory.strongly_measurable (f i)) (hf' : âˆ€ (i : Î¹), measure_theory.mem_â„’p (f i) p Î¼) : measure_theory.uniform_integrable f p Î¼
theorem category_theory.limits.biprod.cone_point_unique_up_to_iso_hom {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (X Y : C) [category_theory.limits.has_binary_biproduct X Y] {b : category_theory.limits.binary_bicone X Y} (hb : b.is_bilimit) : (hb.is_limit.cone_point_unique_up_to_iso (category_theory.limits.binary_biproduct.is_limit X Y)).hom = category_theory.limits.biprod.lift b.fst b.snd
theorem box_integral.norm_integral_le_of_norm_le {Î¹ : Type u} {E : Type v} [normed_group E] [normed_space â„ E] {I : box_integral.box Î¹} [fintype Î¹] {l : box_integral.integration_params} {f : (Î¹ â†’ â„) â†’ E} {g : (Î¹ â†’ â„) â†’ â„} (hle : âˆ€ (x : Î¹ â†’ â„), x âˆˆ â‡‘box_integral.box.Icc I â†’ âˆ¥f xâˆ¥ â‰¤ g x) (Î¼ : measure_theory.measure (Î¹ â†’ â„)) [measure_theory.is_locally_finite_measure Î¼] (hg : box_integral.integrable I l g Î¼.to_box_additive.to_smul) : âˆ¥box_integral.integral I l f Î¼.to_box_additive.to_smulâˆ¥ â‰¤ box_integral.integral I l g Î¼.to_box_additive.to_smul
theorem add_equiv.map_zero {M : Type u_1} {N : Type u_2} [add_zero_class M] [add_zero_class N] (h : M â‰ƒ+ N) : â‡‘h 0 = 0
theorem pi.mul_single_eq_of_ne' {I : Type u} {f : I â†’ Type vâ‚} [decidable_eq I] [Î  (i : I), has_one (f i)] {i i' : I} (h : i â‰  i') (x : f i) : pi.mul_single i x i' = 1
theorem linear_map.ext_on_range {R : Type u_1} {Râ‚‚ : Type u_2} {M : Type u_4} {Mâ‚‚ : Type u_5} [semiring R] [add_comm_monoid M] [module R M] [semiring Râ‚‚] [add_comm_monoid Mâ‚‚] [module Râ‚‚ Mâ‚‚] {Ïƒâ‚â‚‚ : R â†’+* Râ‚‚} {Î¹ : Type u_3} {v : Î¹ â†’ M} {f g : M â†’â‚›â‚—[Ïƒâ‚â‚‚] Mâ‚‚} (hv : submodule.span R (set.range v) = âŠ¤) (h : âˆ€ (i : Î¹), â‡‘f (v i) = â‡‘g (v i)) : f = g
theorem monotone.map_is_greatest {Î± : Type u} {Î² : Type v} [preorder Î±] [preorder Î²] {f : Î± â†’ Î²} (Hf : monotone f) {a : Î±} {s : set Î±} (Ha : is_greatest s a) : is_greatest (f '' s) (f a)
theorem is_torsion.not_torsion_free {G : Type u_1} [group G] [hN : nontrivial G] : monoid.is_torsion G â†’ Â¬monoid.is_torsion_free G
theorem ordering.compares.of_swap {Î± : Type u_1} [has_lt Î±] {a b : Î±} {o : ordering} : o.swap.compares a b â†’ o.compares b a
theorem sym2.map_id' {Î± : Type u_1} : sym2.map (Î» (x : Î±), x) = id
theorem geometric_hahn_banach_point_point {E : Type u_2} [normed_group E] [normed_space â„ E] {x y : E} (hxy : x â‰  y) : âˆƒ (f : E â†’L[â„] â„), â‡‘f x < â‡‘f y
theorem ennreal.cancel_of_lt {a : ennreal} (h : a < âŠ¤) : add_le_cancellable a
theorem simplex_category.len_le_of_epi {x y : simplex_category} {f : x âŸ¶ y} : category_theory.epi f â†’ y.len â‰¤ x.len
theorem is_left_regular_zero_iff_subsingleton {R : Type u_1} [mul_zero_class R] : is_left_regular 0 â†” subsingleton R
theorem colex.singleton_le_iff_le {Î± : Type u_1} [linear_order Î±] {r s : Î±} : {r}.to_colex â‰¤ {s}.to_colex â†” r â‰¤ s
theorem is_add_group_hom.map_neg {Î± : Type u} {Î² : Type v} [add_group Î±] [add_group Î²] {f : Î± â†’ Î²} (hf : is_add_group_hom f) (a : Î±) : f (-a) = -f a
theorem set.countable.exists_surjective {Î± : Type u} {s : set Î±} (hc : s.countable) (hs : s.nonempty) : âˆƒ (f : â„• â†’ Î±), s = set.range f
theorem part.eta {Î± : Type u_1} (o : part Î±) : {dom := o.dom, get := Î» (h : o.dom), o.get h} = o
theorem unique_diff_within_at.eq {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {f : E â†’ F} {f' fâ‚' : E â†’L[ğ•œ] F} {x : E} {s : set E} (H : unique_diff_within_at ğ•œ s x) (hf : has_fderiv_within_at f f' s x) (hg : has_fderiv_within_at f fâ‚' s x) : f' = fâ‚'
theorem category_theory.cosimplicial_object.Î´_comp_Ïƒ_of_gt {C : Type u} [category_theory.category C] (X : category_theory.cosimplicial_object C) {n : â„•} {i : fin (n + 2)} {j : fin (n + 1)} (H : â‡‘fin.cast_succ j < i) : X.Î´ i.succ â‰« X.Ïƒ (â‡‘fin.cast_succ j) = X.Ïƒ j â‰« X.Î´ i
theorem bilin_form.nondegenerate_restrict_of_disjoint_orthogonal {Râ‚ : Type u_3} {Mâ‚ : Type u_4} [ring Râ‚] [add_comm_group Mâ‚] [module Râ‚ Mâ‚] (B : bilin_form Râ‚ Mâ‚) (b : B.is_refl) {W : submodule Râ‚ Mâ‚} (hW : disjoint W (B.orthogonal W)) : (B.restrict W).nondegenerate
theorem besicovitch.exists_disjoint_closed_ball_covering_ae {Î± : Type u_1} [metric_space Î±] [topological_space.second_countable_topology Î±] [measurable_space Î±] [opens_measurable_space Î±] [has_besicovitch_covering Î±] (Î¼ : measure_theory.measure Î±) [measure_theory.sigma_finite Î¼] (f : Î± â†’ set â„) (s : set Î±) (hf : âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (Î´ : â„), Î´ > 0 â†’ (f x âˆ© set.Ioo 0 Î´).nonempty) (R : Î± â†’ â„) (hR : âˆ€ (x : Î±), x âˆˆ s â†’ 0 < R x) : âˆƒ (t : set Î±) (r : Î± â†’ â„), t.countable âˆ§ t âŠ† s âˆ§ (âˆ€ (x : Î±), x âˆˆ t â†’ r x âˆˆ f x âˆ© set.Ioo 0 (R x)) âˆ§ â‡‘Î¼ (s  â‹ƒ (x : Î±) (H : x âˆˆ t), metric.closed_ball x (r x)) = 0 âˆ§ t.pairwise_disjoint (Î» (x : Î±), metric.closed_ball x (r x))
theorem real.abs_log_mul_self_lt (x : â„) (h1 : 0 < x) (h2 : x â‰¤ 1) : |real.log x * x| < 1
theorem measure_theory.content.inner_content_mono {G : Type w} [topological_space G] (Î¼ : measure_theory.content G) â¦ƒU V : set Gâ¦„ (hU : is_open U) (hV : is_open V) (h2 : U âŠ† V) : Î¼.inner_content âŸ¨U, hUâŸ© â‰¤ Î¼.inner_content âŸ¨V, hVâŸ©
theorem eq_orthogonal_projection_fn_of_mem_of_inner_eq_zero {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {K : submodule ğ•œ E} [complete_space â†¥K] {u v : E} (hvm : v âˆˆ K) (hvo : âˆ€ (w : E), w âˆˆ K â†’ has_inner.inner (u - v) w = 0) : orthogonal_projection_fn K u = v
theorem mul_action.quotient_preimage_image_eq_union_mul {Î± : Type u} {Î² : Type v} [group Î±] [mul_action Î± Î²] (U : set Î²) : quotient.mk â»Â¹' (quotient.mk '' U) = â‹ƒ (a : Î±), has_scalar.smul a '' U
theorem has_strict_fderiv_at.map_implicit_function_of_complemented_eq {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] [complete_space E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] [complete_space F] {f : E â†’ F} {f' : E â†’L[ğ•œ] F} {a : E} (hf : has_strict_fderiv_at f f' a) (hf' : f'.range = âŠ¤) (hker : f'.ker.closed_complemented) : âˆ€á¶  (p : F Ã— â†¥(f'.ker)) in nhds (f a, 0), f (has_strict_fderiv_at.implicit_function_of_complemented f f' hf hf' hker p.fst p.snd) = p.fst
theorem affine.simplex.face_centroid_eq_centroid {k : Type u_1} {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] {n : â„•} (s : affine.simplex k P n) {fs : finset (fin (n + 1))} {m : â„•} (h : fs.card = m + 1) : finset.centroid k finset.univ (s.face h).points = finset.centroid k fs s.points
theorem finset.sup_indep_iff_disjoint_erase {Î± : Type u_1} {Î¹ : Type u_3} [lattice Î±] [order_bot Î±] {s : finset Î¹} {f : Î¹ â†’ Î±} [decidable_eq Î¹] : s.sup_indep f â†” âˆ€ (i : Î¹), i âˆˆ s â†’ disjoint (f i) ((s.erase i).sup f)
theorem complex.has_deriv_at_cos (x : â„‚) : has_deriv_at complex.cos (-complex.sin x) x
theorem has_deriv_at_filter_iff_tendsto_slope {ğ•œ : Type u} [nondiscrete_normed_field ğ•œ] {F : Type v} [normed_group F] [normed_space ğ•œ F] {f : ğ•œ â†’ F} {f' : F} {x : ğ•œ} {L : filter ğ•œ} : has_deriv_at_filter f f' x L â†” filter.tendsto (slope f x) (L âŠ“ filter.principal {x}á¶œ) (nhds f')
theorem circle_integral.integral_eq_zero_of_has_deriv_within_at' {E : Type u_1} [normed_group E] [normed_space â„‚ E] [complete_space E] {f f' : â„‚ â†’ E} {c : â„‚} {R : â„} (h : âˆ€ (z : â„‚), z âˆˆ metric.sphere c |R| â†’ has_deriv_within_at f (f' z) (metric.sphere c |R|) z) : âˆ® (z : â„‚) in C(c, R), f' z = 0
theorem first_order.language.hom.comp_assoc {L : first_order.language} {M : Type w} {N : Type w'} [L.Structure M] [L.Structure N] {P : Type u_1} [L.Structure P] {Q : Type u_2} [L.Structure Q] (f : L.hom M N) (g : L.hom N P) (h : L.hom P Q) : (h.comp g).comp f = h.comp (g.comp f)
theorem measure_theory.lintegral_map_equiv {Î± : Type u_1} {Î² : Type u_2} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [measurable_space Î²] (f : Î² â†’ ennreal) (g : Î± â‰ƒáµ Î²) : âˆ«â» (a : Î²), f a âˆ‚measure_theory.measure.map â‡‘g Î¼ = âˆ«â» (a : Î±), f (â‡‘g a) âˆ‚Î¼
theorem bounded_convex_hull {E : Type u_2} [semi_normed_group E] [normed_space â„ E] {s : set E} : metric.bounded (â‡‘(convex_hull â„) s) â†” metric.bounded s
theorem add_tsub_le_left {Î± : Type u_1} [preorder Î±] [add_comm_semigroup Î±] [has_sub Î±] [has_ordered_sub Î±] {a b : Î±} : a + b - a â‰¤ b
theorem left.one_lt_inv_iff {Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a : Î±} : 1 < aâ»Â¹ â†” a < 1
theorem absolute_value.abs_is_euclidean  : absolute_value.abs.is_euclidean
theorem image_sub_le_mul_sub_of_deriv_le {f : â„ â†’ â„} (hf : differentiable â„ f) {C : â„} (le_hf' : âˆ€ (x : â„), deriv f x â‰¤ C) â¦ƒx y : â„â¦„ (hxy : x â‰¤ y) : f y - f x â‰¤ C * (y - x)
theorem box_integral.has_integral_indicator_const {Î¹ : Type u} {E : Type v} [fintype Î¹] [normed_group E] [normed_space â„ E] (l : box_integral.integration_params) (hl : l.bRiemann = bool.ff) {s : set (Î¹ â†’ â„)} (hs : measurable_set s) (I : box_integral.box Î¹) (y : E) (Î¼ : measure_theory.measure (Î¹ â†’ â„)) [measure_theory.is_locally_finite_measure Î¼] : box_integral.has_integral I l (s.indicator (Î» (_x : Î¹ â†’ â„), y)) Î¼.to_box_additive.to_smul ((â‡‘Î¼ (s âˆ© â†‘I)).to_real â€¢ y)
theorem multilinear_map.cons_add {R : Type u} {n : â„•} {M : fin n.succ â†’ Type v} {Mâ‚‚ : Type vâ‚‚} [semiring R] [Î  (i : fin n.succ), add_comm_monoid (M i)] [add_comm_monoid Mâ‚‚] [Î  (i : fin n.succ), module R (M i)] [module R Mâ‚‚] (f : multilinear_map R M Mâ‚‚) (m : Î  (i : fin n), M i.succ) (x y : M 0) : â‡‘f (fin.cons (x + y) m) = â‡‘f (fin.cons x m) + â‡‘f (fin.cons y m)
theorem simple_graph.clique_free.clique_finset {Î± : Type u_1} (G : simple_graph Î±) [fintype Î±] [decidable_eq Î±] [decidable_rel G.adj] {n : â„•} : G.clique_free n â†’ G.clique_finset n = âˆ…
theorem localization_finite  : ring_hom.localization_preserves ring_hom.finite
theorem free_group.reduce.rev {Î± : Type u} {Lâ‚ Lâ‚‚ : list (Î± Ã— bool)} [decidable_eq Î±] (H : free_group.red Lâ‚ Lâ‚‚) : free_group.red Lâ‚‚ (free_group.reduce Lâ‚)
theorem affine_subspace.mem_direction_iff_eq_vsub_left {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : affine_subspace k P} {p : P} (hp : p âˆˆ s) (v : V) : v âˆˆ s.direction â†” âˆƒ (p2 : P) (H : p2 âˆˆ s), v = p -áµ¥ p2
theorem category_theory.grothendieck_topology.plus_map_to_plus {C : Type u} [category_theory.category C] (J : category_theory.grothendieck_topology C) {D : Type w} [category_theory.category D] [âˆ€ (P : Cáµ’áµ– â¥¤ D) (X : C) (S : J.cover X), category_theory.limits.has_multiequalizer (S.index P)] (P : Cáµ’áµ– â¥¤ D) [âˆ€ (X : C), category_theory.limits.has_colimits_of_shape (J.cover X)áµ’áµ– D] : J.plus_map (J.to_plus P) = J.to_plus (J.plus_obj P)
theorem finset.exists_lt_sum_fiber_of_maps_to_of_nsmul_lt_sum {Î± : Type u} {Î² : Type v} {M : Type w} [decidable_eq Î²] {s : finset Î±} {t : finset Î²} {f : Î± â†’ Î²} {w : Î± â†’ M} {b : M} [linear_ordered_cancel_add_comm_monoid M] (hf : âˆ€ (a : Î±), a âˆˆ s â†’ f a âˆˆ t) (hb : t.card â€¢ b < s.sum (Î» (x : Î±), w x)) : âˆƒ (y : Î²) (H : y âˆˆ t), b < (finset.filter (Î» (x : Î±), f x = y) s).sum (Î» (x : Î±), w x)
theorem filter.map_congr {Î± : Type u} {Î² : Type v} {mâ‚ mâ‚‚ : Î± â†’ Î²} {f : filter Î±} (h : mâ‚ =á¶ [f] mâ‚‚) : filter.map mâ‚ f = filter.map mâ‚‚ f
theorem iterated_fderiv_within_eq_equiv_comp {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {F : Type u_2} [normed_group F] [normed_space ğ•œ F] {n : â„•} {f : ğ•œ â†’ F} {s : set ğ•œ} : iterated_fderiv_within ğ•œ n f s = â‡‘(continuous_multilinear_map.pi_field_equiv ğ•œ (fin n) F) âˆ˜ iterated_deriv_within n f s
theorem is_free_groupoid.spanning_tree.tree_hom_eq {G : Type u} [category_theory.groupoid G] [is_free_groupoid G] (T : wide_subquiver (quiver.symmetrify (is_free_groupoid.generators G))) [quiver.arborescence â†¥T] {a : G} (p : quiver.path (quiver.root â†¥T) a) : is_free_groupoid.spanning_tree.tree_hom T a = is_free_groupoid.spanning_tree.hom_of_path T p
theorem colex.colex_lt_of_ssubset {Î± : Type u_1} [linear_order Î±] {A B : finset Î±} (h : A âŠ‚ B) : A.to_colex < B.to_colex
theorem ordered_add_comm_group.add_lt_add_left {Î± : Type u_1} [has_add Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {b c : Î±} (bc : b < c) (a : Î±) : a + b < a + c
theorem smooth_bump_covering.is_subordinate.to_bump_covering {Î¹ : Type uÎ¹} {E : Type uE} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] {H : Type uH} [topological_space H] {I : model_with_corners â„ E H} {M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {s : set M} [t2_space M] {f : smooth_bump_covering Î¹ I M s} {U : M â†’ set M} : f.is_subordinate U â†’ f.to_bump_covering.is_subordinate (Î» (i : Î¹), U (f.c i))
theorem lipschitz_with.dimH_range_le {X : Type u_2} {Y : Type u_3} [emetric_space X] [emetric_space Y] {K : nnreal} {f : X â†’ Y} (h : lipschitz_with K f) : dimH (set.range f) â‰¤ dimH set.univ
theorem convex_on.map_integral_le {Î± : Type u_1} {E : Type u_2} {m0 : measurable_space Î±} [normed_group E] [normed_space â„ E] [complete_space E] {Î¼ : measure_theory.measure Î±} {s : set E} {f : Î± â†’ E} {g : E â†’ â„} [measure_theory.is_probability_measure Î¼] (hg : convex_on â„ s g) (hgc : continuous_on g s) (hsc : is_closed s) (hfs : âˆ€áµ (x : Î±) âˆ‚Î¼, f x âˆˆ s) (hfi : measure_theory.integrable f Î¼) (hgi : measure_theory.integrable (g âˆ˜ f) Î¼) : g (âˆ« (x : Î±), f x âˆ‚Î¼) â‰¤ âˆ« (x : Î±), g (f x) âˆ‚Î¼
theorem measure_theory.integrable.interval_integrable {E : Type u_3} [normed_group E] {f : â„ â†’ E} {a b : â„} {Î¼ : measure_theory.measure â„} (hf : measure_theory.integrable f Î¼) : interval_integrable f Î¼ a b
theorem is_cyclotomic_extension.rat.is_integral_closure_adjoing_singleton_of_prime_pow {p : â„•+} {k : â„•} {K : Type u} [field K] [char_zero K] {Î¶ : K} [hp : fact (nat.prime â†‘p)] [hcycl : is_cyclotomic_extension {p ^ k} â„š K] (hÎ¶ : is_primitive_root Î¶ â†‘(p ^ k)) : is_integral_closure â†¥(algebra.adjoin â„¤ {Î¶}) â„¤ K
theorem convex.mul_sub_lt_image_sub_of_lt_deriv {D : set â„} (hD : convex â„ D) {f : â„ â†’ â„} (hf : continuous_on f D) (hf' : differentiable_on â„ f (interior D)) {C : â„} (hf'_gt : âˆ€ (x : â„), x âˆˆ interior D â†’ C < deriv f x) (x : â„) (H : x âˆˆ D) (y : â„) (H_1 : y âˆˆ D) : x < y â†’ C * (y - x) < f y - f x
theorem comp_add_right {Î± : Type u_1} [add_semigroup Î±] (x y : Î±) : ((Î» (_x : Î±), _x + x) âˆ˜ Î» (_x : Î±), _x + y) = Î» (_x : Î±), _x + (y + x)
theorem set.abs_sub_le_of_subinterval {Î± : Type u} [linear_ordered_add_comm_group Î±] {a b x y : Î±} (h : set.interval x y âŠ† set.interval a b) : |y - x| â‰¤ |b - a|
theorem is_primitive_root.minpoly_eq_pow {n : â„•} {K : Type u_8} [field K] {Î¼ : K} (h : is_primitive_root Î¼ n) [char_zero K] {p : â„•} [hprime : fact (nat.prime p)] (hdiv : Â¬p âˆ£ n) : minpoly â„¤ Î¼ = minpoly â„¤ (Î¼ ^ p)
theorem category_theory.limits.types.pi_lift_Ï€_apply {Î² : Type u} (f : Î² â†’ Type u) {P : Type u} (s : Î  (b : Î²), P âŸ¶ f b) (b : Î²) (x : P) : category_theory.limits.pi.Ï€ f b (category_theory.limits.pi.lift s x) = s b x
theorem has_strict_fderiv_at.to_local_inverse {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] [cs : complete_space E] {f : E â†’ F} {f' : E â‰ƒL[ğ•œ] F} {a : E} (hf : has_strict_fderiv_at f â†‘f' a) : has_strict_fderiv_at (has_strict_fderiv_at.local_inverse f f' a hf) â†‘(f'.symm) (f a)
theorem t2_separation_finset {Î± : Type u} [topological_space Î±] [t2_space Î±] (s : finset Î±) : âˆƒ (f : Î± â†’ set Î±), â†‘s.pairwise_disjoint f âˆ§ âˆ€ (x : Î±), x âˆˆ s â†’ x âˆˆ f x âˆ§ is_open (f x)
theorem fderiv_at.le_of_lip {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {f : E â†’ F} {xâ‚€ : E} (hf : differentiable_at ğ•œ f xâ‚€) {s : set E} (hs : s âˆˆ nhds xâ‚€) {C : nnreal} (hlip : lipschitz_on_with C f s) : âˆ¥fderiv ğ•œ f xâ‚€âˆ¥ â‰¤ â†‘C
theorem is_compact.eventually_forall_of_forall_eventually {Î± : Type u} {Î² : Type v} [topological_space Î±] [topological_space Î²] {xâ‚€ : Î±} {K : set Î²} (hK : is_compact K) {P : Î± â†’ Î² â†’ Prop} (hP : âˆ€ (y : Î²), y âˆˆ K â†’ (âˆ€á¶  (z : Î± Ã— Î²) in nhds (xâ‚€, y), P z.fst z.snd)) : âˆ€á¶  (x : Î±) in nhds xâ‚€, âˆ€ (y : Î²), y âˆˆ K â†’ P x y
theorem measurable_space.cardinal_generate_measurable_le_continuum {Î± : Type u} {s : set (set Î±)} (hs : cardinal.mk â†¥s â‰¤ cardinal.continuum) : cardinal.mk â†¥{t : set Î± | measurable_space.generate_measurable s t} â‰¤ cardinal.continuum
theorem cont_diff_on.continuous_linear_map_comp {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {G : Type u_4} [normed_group G] [normed_space ğ•œ G] {s : set E} {f : E â†’ F} {n : with_top â„•} (g : F â†’L[ğ•œ] G) (hf : cont_diff_on ğ•œ n f s) : cont_diff_on ğ•œ n (â‡‘g âˆ˜ f) s
theorem add_subgroup.is_normal_topological_closure {G : Type u_1} [topological_space G] [add_group G] [topological_add_group G] (N : add_subgroup G) [N.normal] : N.topological_closure.normal
theorem measure_theory.measure.ext_iff_of_sUnion_eq_univ {Î± : Type u_1} {m0 : measurable_space Î±} {Î¼ Î½ : measure_theory.measure Î±} {S : set (set Î±)} (hc : S.countable) (hs : â‹ƒâ‚€S = set.univ) : Î¼ = Î½ â†” âˆ€ (s : set Î±), s âˆˆ S â†’ Î¼.restrict s = Î½.restrict s
theorem finset.le_card_falling_div_choose {ğ•œ : Type u_1} {Î± : Type u_2} [linear_ordered_field ğ•œ] [decidable_eq Î±] {k : â„•} {ğ’œ : finset (finset Î±)} [fintype Î±] (hk : k â‰¤ fintype.card Î±) (hğ’œ : is_antichain has_subset.subset â†‘ğ’œ) : (finset.range (k + 1)).sum (Î» (r : â„•), â†‘((ğ’œ.slice (fintype.card Î± - r)).card) / â†‘((fintype.card Î±).choose (fintype.card Î± - r))) â‰¤ â†‘((finset.falling (fintype.card Î± - k) ğ’œ).card) / â†‘((fintype.card Î±).choose (fintype.card Î± - k))
theorem subgroup.commutator_pi_pi_of_fintype {Î· : Type u_1} [fintype Î·] {Gs : Î· â†’ Type u_2} [Î  (i : Î·), group (Gs i)] (H K : Î  (i : Î·), subgroup (Gs i)) : â…subgroup.pi set.univ H,subgroup.pi set.univ Kâ† = subgroup.pi set.univ (Î» (i : Î·), â…H i,K iâ†)
theorem cont_diff_at_map_inverse {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {n : with_top â„•} [complete_space E] (e : E â‰ƒL[ğ•œ] F) : cont_diff_at ğ•œ n continuous_linear_map.inverse â†‘e
theorem measure_theory.exists_null_pairwise_disjoint_diff {Î¹ : Type u_1} {Î± : Type u_2} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [encodable Î¹] {s : Î¹ â†’ set Î±} (hd : pairwise (measure_theory.ae_disjoint Î¼ on s)) : âˆƒ (t : Î¹ â†’ set Î±), (âˆ€ (i : Î¹), measurable_set (t i)) âˆ§ (âˆ€ (i : Î¹), â‡‘Î¼ (t i) = 0) âˆ§ pairwise (disjoint on Î» (i : Î¹), s i  t i)
theorem card_multiples (n p : â„•) : (finset.filter (Î» (e : â„•), p âˆ£ e + 1) (finset.range n)).card = n / p
theorem is_trivial_topological_fiber_bundle_fst {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] : is_trivial_topological_fiber_bundle F prod.fst
theorem polynomial.sum_over_range {R : Type u} {S : Type v} [semiring R] [add_comm_monoid S] (p : polynomial R) {f : â„• â†’ R â†’ S} (h : âˆ€ (n : â„•), f n 0 = 0) : p.sum f = (finset.range (p.nat_degree + 1)).sum (Î» (a : â„•), f a (p.coeff a))
theorem category_theory.limits.colimit_limit_to_limit_colimit_surjective {J K : Type v} [category_theory.small_category J] [category_theory.small_category K] (F : J Ã— K â¥¤ Type v) [category_theory.is_filtered K] [category_theory.fin_category J] : function.surjective (category_theory.limits.colimit_limit_to_limit_colimit F)
theorem emetric.Hausdorff_edist_closureâ‚ {Î± : Type u} [pseudo_emetric_space Î±] {s t : set Î±} : emetric.Hausdorff_edist (closure s) t = emetric.Hausdorff_edist s t
theorem orientation.eq_iff_oangle_eq_zero_of_norm_eq {V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) {x y : V} (h : âˆ¥xâˆ¥ = âˆ¥yâˆ¥) : x = y â†” o.oangle x y = 0
theorem upper_semicontinuous_at.add {Î± : Type u_1} [topological_space Î±] {x : Î±} {Î³ : Type u_4} [linear_ordered_add_comm_monoid Î³] [topological_space Î³] [order_topology Î³] [has_continuous_add Î³] {f g : Î± â†’ Î³} (hf : upper_semicontinuous_at f x) (hg : upper_semicontinuous_at g x) : upper_semicontinuous_at (Î» (z : Î±), f z + g z) x
theorem algebra.is_integral_of_finite (K : Type u_1) (L : Type u_2) [field K] [field L] [algebra K L] [finite_dimensional K L] : algebra.is_integral K L
theorem finset.sum_partition {Î² : Type u} {Î± : Type v} {s : finset Î±} {f : Î± â†’ Î²} [add_comm_monoid Î²] (R : setoid Î±) [decidable_rel setoid.r] : s.sum (Î» (x : Î±), f x) = (finset.image quotient.mk s).sum (Î» (xbar : quotient R), (finset.filter (Î» (y : Î±), âŸ¦yâŸ§ = xbar) s).sum (Î» (y : Î±), f y))
theorem category_theory.Groupoid.hom_to_functor {C D E : category_theory.Groupoid} (f : C âŸ¶ D) (g : D âŸ¶ E) : f â‰« g = f â‹™ g
theorem cont_diff_within_at.neg {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {x : E} {n : with_top â„•} {s : set E} {f : E â†’ F} (hf : cont_diff_within_at ğ•œ n f s x) : cont_diff_within_at ğ•œ n (Î» (x : E), -f x) s x
theorem continuous_map.congr_fun {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] {f g : C(Î±, Î²)} (H : f = g) (x : Î±) : â‡‘f x = â‡‘g x
theorem compact_open_separated_add_left {G : Type w} [topological_space G] [add_group G] [topological_add_group G] {K U : set G} (hK : is_compact K) (hU : is_open U) (hKU : K âŠ† U) : âˆƒ (V : set G) (H : V âˆˆ nhds 0), V + K âŠ† U
theorem module.ray.some_vector_ne_zero {R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] (x : module.ray R M) : x.some_vector â‰  0
theorem measure_theory.is_open_pos_measure_of_add_left_invariant_of_regular {G : Type u_1} [measurable_space G] [topological_space G] [borel_space G] {Î¼ : measure_theory.measure G} [add_group G] [topological_add_group G] [Î¼.is_add_left_invariant] [Î¼.regular] (hâ‚€ : Î¼ â‰  0) : Î¼.is_open_pos_measure
theorem affine_map.id_apply (k : Type u_1) {V1 : Type u_2} {P1 : Type u_3} [ring k] [add_comm_group V1] [module k V1] [add_torsor V1 P1] (p : P1) : â‡‘(affine_map.id k P1) p = p
theorem mvqpf.cofix.bisim {n : â„•} {F : typevec (n + 1) â†’ Type u} [mvfunctor F] [q : mvqpf F] {Î± : typevec n} (r : mvqpf.cofix F Î± â†’ mvqpf.cofix F Î± â†’ Prop) (h : âˆ€ (x y : mvqpf.cofix F Î±), r x y â†’ mvfunctor.liftr (Î±.rel_last r) x.dest y.dest) (x y : mvqpf.cofix F Î±) : r x y â†’ x = y
theorem measure_theory.mem_â„’p.integral_indicator_norm_ge_le {Î± : Type u_1} {Î² : Type u_2} {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) [normed_group Î²] {f : Î± â†’ Î²} (hf : measure_theory.mem_â„’p f 1 Î¼) (hmeas : measure_theory.strongly_measurable f) {Îµ : â„} (hÎµ : 0 < Îµ) : âˆƒ (M : â„), âˆ«â» (x : Î±), â†‘âˆ¥{x : Î± | M â‰¤ â†‘âˆ¥f xâˆ¥â‚Š}.indicator f xâˆ¥â‚Š âˆ‚Î¼ â‰¤ ennreal.of_real Îµ
theorem affine.simplex.mem_altitude {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {n : â„•} (s : affine.simplex â„ P (n + 1)) (i : fin (n + 2)) : s.points i âˆˆ s.altitude i
theorem set_of_is_preconnected_eq_of_ordered {Î± : Type u} [conditionally_complete_linear_order Î±] [topological_space Î±] [order_topology Î±] [densely_ordered Î±] : {s : set Î± | is_preconnected s} = set.range (function.uncurry set.Icc) âˆª set.range (function.uncurry set.Ico) âˆª set.range (function.uncurry set.Ioc) âˆª set.range (function.uncurry set.Ioo) âˆª (set.range set.Ici âˆª set.range set.Ioi âˆª set.range set.Iic âˆª set.range set.Iio âˆª {set.univ, âˆ…})
theorem proper_space_of_compact_closed_ball_of_le {Î± : Type u} [pseudo_metric_space Î±] (R : â„) (h : âˆ€ (x : Î±) (r : â„), R â‰¤ r â†’ is_compact (metric.closed_ball x r)) : proper_space Î±
theorem nat.prod_factorization_eq_prod_factors {n : â„•} {Î² : Type u_1} [comm_monoid Î²] (f : â„• â†’ Î²) : n.factorization.prod (Î» (p k : â„•), f p) = n.factors.to_finset.prod (Î» (p : â„•), f p)
theorem function.injective2.right' {Î± : Sort u_1} {Î² : Sort u_2} {Î³ : Sort u_3} {f : Î± â†’ Î² â†’ Î³} (hf : function.injective2 f) [nonempty Î±] : function.injective (Î» (b : Î²) (a : Î±), f a b)
theorem norm_add_lt_of_not_same_ray {E : Type u_2} [normed_group E] [normed_space â„ E] [strict_convex_space â„ E] {x y : E} (h : Â¬same_ray â„ x y) : âˆ¥x + yâˆ¥ < âˆ¥xâˆ¥ + âˆ¥yâˆ¥
theorem add_comm_group.direct_limit.of.zero_exact {Î¹ : Type v} [dec_Î¹ : decidable_eq Î¹] [preorder Î¹] {G : Î¹ â†’ Type w} [Î  (i : Î¹), add_comm_group (G i)] {f : Î  (i j : Î¹), i â‰¤ j â†’ G i â†’+ G j} [is_directed Î¹ has_le.le] [directed_system G (Î» (i j : Î¹) (h : i â‰¤ j), â‡‘(f i j h))] (i : Î¹) (x : G i) (h : â‡‘(add_comm_group.direct_limit.of G f i) x = 0) : âˆƒ (j : Î¹) (hij : i â‰¤ j), â‡‘(f i j hij) x = 0
theorem interval_integral.has_deriv_at_integral_of_dominated_loc_of_lip {ğ•œ : Type u_1} [is_R_or_C ğ•œ] {Î¼ : measure_theory.measure â„} {E : Type u_2} [normed_group E] [normed_space â„ E] [normed_space ğ•œ E] [complete_space E] {a b Îµ : â„} {bound : â„ â†’ â„} {F : ğ•œ â†’ â„ â†’ E} {F' : â„ â†’ E} {xâ‚€ : ğ•œ} (Îµ_pos : 0 < Îµ) (hF_meas : âˆ€á¶  (x : ğ•œ) in nhds xâ‚€, measure_theory.ae_strongly_measurable (F x) (Î¼.restrict (set.interval_oc a b))) (hF_int : interval_integrable (F xâ‚€) Î¼ a b) (hF'_meas : measure_theory.ae_strongly_measurable F' (Î¼.restrict (set.interval_oc a b))) (h_lipsch : âˆ€áµ (t : â„) âˆ‚Î¼, t âˆˆ set.interval_oc a b â†’ lipschitz_on_with (â‡‘real.nnabs (bound t)) (Î» (x : ğ•œ), F x t) (metric.ball xâ‚€ Îµ)) (bound_integrable : interval_integrable bound Î¼ a b) (h_diff : âˆ€áµ (t : â„) âˆ‚Î¼, t âˆˆ set.interval_oc a b â†’ has_deriv_at (Î» (x : ğ•œ), F x t) (F' t) xâ‚€) : interval_integrable F' Î¼ a b âˆ§ has_deriv_at (Î» (x : ğ•œ), âˆ« (t : â„) in a..b, F x t âˆ‚Î¼) (âˆ« (t : â„) in a..b, F' t âˆ‚Î¼) xâ‚€
theorem is_p_group.coprime_card_of_ne {G : Type u_1} [group G] {Gâ‚‚ : Type u_2} [group Gâ‚‚] (pâ‚ pâ‚‚ : â„•) [hpâ‚ : fact (nat.prime pâ‚)] [hpâ‚‚ : fact (nat.prime pâ‚‚)] (hne : pâ‚ â‰  pâ‚‚) (Hâ‚ : subgroup G) (Hâ‚‚ : subgroup Gâ‚‚) [fintype â†¥Hâ‚] [fintype â†¥Hâ‚‚] (hHâ‚ : is_p_group pâ‚ â†¥Hâ‚) (hHâ‚‚ : is_p_group pâ‚‚ â†¥Hâ‚‚) : (fintype.card â†¥Hâ‚).coprime (fintype.card â†¥Hâ‚‚)
theorem measure_theory.Lp.induction_strongly_measurable_aux {Î± : Type u_1} {F : Type u_6} {p : ennreal} [normed_group F] {m m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [fact (1 â‰¤ p)] [normed_space â„ F] (hm : m â‰¤ m0) (hp_ne_top : p â‰  âŠ¤) (P : â†¥(measure_theory.Lp F p Î¼) â†’ Prop) (h_ind : âˆ€ (c : F) {s : set Î±} (hs : measurable_set s) (hÎ¼s : â‡‘Î¼ s < âŠ¤), P â†‘(measure_theory.Lp.simple_func.indicator_const p _ _ c)) (h_add : âˆ€ â¦ƒf g : Î± â†’ Fâ¦„ (hf : measure_theory.mem_â„’p f p Î¼) (hg : measure_theory.mem_â„’p g p Î¼), measure_theory.ae_strongly_measurable' m f Î¼ â†’ measure_theory.ae_strongly_measurable' m g Î¼ â†’ disjoint (function.support f) (function.support g) â†’ P (measure_theory.mem_â„’p.to_Lp f hf) â†’ P (measure_theory.mem_â„’p.to_Lp g hg) â†’ P (measure_theory.mem_â„’p.to_Lp f hf + measure_theory.mem_â„’p.to_Lp g hg)) (h_closed : is_closed {f : â†¥(measure_theory.Lp_meas F â„ m p Î¼) | P â†‘f}) (f : â†¥(measure_theory.Lp F p Î¼)) : measure_theory.ae_strongly_measurable' m â‡‘f Î¼ â†’ P f
theorem continuous_linear_map.is_weak_closed_closed_ball {ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {F : Type u_6} [normed_group F] [nondiscrete_normed_field ğ•œ] [nondiscrete_normed_field ğ•œâ‚‚] [normed_space ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} {E' : Type u_10} [semi_normed_group E'] [normed_space ğ•œ E'] [ring_hom_isometric Ïƒâ‚â‚‚] (fâ‚€ : E' â†’SL[Ïƒâ‚â‚‚] F) (r : â„) â¦ƒf : E' â†’SL[Ïƒâ‚â‚‚] Fâ¦„ (hf : â‡‘f âˆˆ closure (coe_fn '' metric.closed_ball fâ‚€ r)) : f âˆˆ metric.closed_ball fâ‚€ r
theorem category_theory.limits.complete_lattice.coprod_eq_sup {Î± : Type u} [semilattice_sup Î±] [order_bot Î±] (x y : Î±) : (x â¨¿ y) = x âŠ” y
theorem prime_spectrum.gc_set (R : Type u) [comm_ring R] : galois_connection (Î» (s : set R), prime_spectrum.zero_locus s) (Î» (t : (set (prime_spectrum R))áµ’áµˆ), â†‘(prime_spectrum.vanishing_ideal t))
theorem category_theory.is_pushout.paste_vert {C : Type uâ‚} [category_theory.category C] {Xâ‚â‚ Xâ‚â‚‚ Xâ‚‚â‚ Xâ‚‚â‚‚ Xâ‚ƒâ‚ Xâ‚ƒâ‚‚ : C} {hâ‚â‚ : Xâ‚â‚ âŸ¶ Xâ‚â‚‚} {hâ‚‚â‚ : Xâ‚‚â‚ âŸ¶ Xâ‚‚â‚‚} {hâ‚ƒâ‚ : Xâ‚ƒâ‚ âŸ¶ Xâ‚ƒâ‚‚} {vâ‚â‚ : Xâ‚â‚ âŸ¶ Xâ‚‚â‚} {vâ‚â‚‚ : Xâ‚â‚‚ âŸ¶ Xâ‚‚â‚‚} {vâ‚‚â‚ : Xâ‚‚â‚ âŸ¶ Xâ‚ƒâ‚} {vâ‚‚â‚‚ : Xâ‚‚â‚‚ âŸ¶ Xâ‚ƒâ‚‚} (s : category_theory.is_pushout hâ‚â‚ vâ‚â‚ vâ‚â‚‚ hâ‚‚â‚) (t : category_theory.is_pushout hâ‚‚â‚ vâ‚‚â‚ vâ‚‚â‚‚ hâ‚ƒâ‚) : category_theory.is_pushout hâ‚â‚ (vâ‚â‚ â‰« vâ‚‚â‚) (vâ‚â‚‚ â‰« vâ‚‚â‚‚) hâ‚ƒâ‚
theorem subgroup.map_normalizer_eq_of_bijective {G : Type u_1} [group G] {N : Type u_3} [group N] (H : subgroup G) {f : G â†’* N} (hf : function.bijective â‡‘f) : subgroup.map f H.normalizer = (subgroup.map f H).normalizer
theorem norm_image_sub_le_of_norm_deriv_le_segment {E : Type u_1} [normed_group E] [normed_space â„ E] {f : â„ â†’ E} {a b C : â„} (hf : differentiable_on â„ f (set.Icc a b)) (bound : âˆ€ (x : â„), x âˆˆ set.Ico a b â†’ âˆ¥deriv_within f (set.Icc a b) xâˆ¥ â‰¤ C) (x : â„) (H : x âˆˆ set.Icc a b) : âˆ¥f x - f aâˆ¥ â‰¤ C * (x - a)
theorem category_theory.limits.has_limit.of_cones_iso {C : Type u} [category_theory.category C] {J K : Type uâ‚} [category_theory.category J] [category_theory.category K] (F : J â¥¤ C) (G : K â¥¤ C) (h : F.cones â‰… G.cones) [category_theory.limits.has_limit F] : category_theory.limits.has_limit G
theorem linear_dependent_comp_subtype {Î¹ : Type u_1} {R : Type u_3} {M : Type u_5} {v : Î¹ â†’ M} [semiring R] [add_comm_monoid M] [module R M] {s : set Î¹} : Â¬linear_independent R (v âˆ˜ coe) â†” âˆƒ (f : Î¹ â†’â‚€ R), f âˆˆ finsupp.supported R R s âˆ§ f.support.sum (Î» (i : Î¹), â‡‘f i â€¢ v i) = 0 âˆ§ f â‰  0
theorem category_theory.subobject.eq_of_comp_arrow_eq {C : Type uâ‚} [category_theory.category C] {X Y : C} {P : category_theory.subobject Y} {f g : X âŸ¶ â†‘P} (h : f â‰« P.arrow = g â‰« P.arrow) : f = g
theorem pi_eq_sum_univ {Î¹ : Type u_1} [fintype Î¹] [decidable_eq Î¹] {R : Type u_2} [semiring R] (x : Î¹ â†’ R) : x = finset.univ.sum (Î» (i : Î¹), x i â€¢ Î» (j : Î¹), ite (i = j) 1 0)
theorem simple_graph.bot_strongly_regular {V : Type u} [fintype V] [decidable_eq V] {â„“ : â„•} : âŠ¥.is_SRG_with (fintype.card V) 0 â„“ 0
theorem continuous_map.tendsto_iff_tendsto_uniformly {Î± : Type uâ‚} {Î² : Type uâ‚‚} [topological_space Î±] [uniform_space Î²] {f : C(Î±, Î²)} {Î¹ : Type uâ‚ƒ} {p : filter Î¹} {F : Î¹ â†’ C(Î±, Î²)} [compact_space Î±] : filter.tendsto F p (nhds f) â†” tendsto_uniformly (Î» (i : Î¹) (a : Î±), â‡‘(F i) a) â‡‘f p
theorem is_min_on.of_is_local_min_on_of_convex_on {E : Type u_1} {Î² : Type u_2} [add_comm_group E] [topological_space E] [module â„ E] [topological_add_group E] [has_continuous_smul â„ E] [ordered_add_comm_group Î²] [module â„ Î²] [ordered_smul â„ Î²] {s : set E} {f : E â†’ Î²} {a : E} (a_in_s : a âˆˆ s) (h_localmin : is_local_min_on f s a) (h_conv : convex_on â„ s f) : is_min_on f s a
theorem alternating_map.map_linear_dependent {Î¹ : Type u_6} [decidable_eq Î¹] {K : Type u_1} [ring K] {M : Type u_2} [add_comm_group M] [module K M] {N : Type u_3} [add_comm_group N] [module K N] [no_zero_smul_divisors K N] (f : alternating_map K M N Î¹) (v : Î¹ â†’ M) (h : Â¬linear_independent K v) : â‡‘f v = 0
theorem is_countably_spanning.pi {Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_3} [fintype Î¹] {C : Î  (i : Î¹), set (set (Î± i))} (hC : âˆ€ (i : Î¹), is_countably_spanning (C i)) : is_countably_spanning (set.univ.pi '' set.univ.pi C)
theorem continuous_linear_map.is_closed_image_coe_closed_ball {ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {E : Type u_4} {F : Type u_6} [normed_group E] [normed_group F] [nondiscrete_normed_field ğ•œ] [nondiscrete_normed_field ğ•œâ‚‚] [normed_space ğ•œ E] [normed_space ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} [ring_hom_isometric Ïƒâ‚â‚‚] (fâ‚€ : E â†’SL[Ïƒâ‚â‚‚] F) (r : â„) : is_closed (coe_fn '' metric.closed_ball fâ‚€ r)
theorem multiset.nodup.of_powerset {Î± : Type u_1} {s : multiset Î±} : s.powerset.nodup â†’ s.nodup
theorem linear_independent_unique {Î¹ : Type u_1} {R : Type u_3} {M : Type u_5} [ring R] [nontrivial R] [add_comm_group M] [module R M] [no_zero_smul_divisors R M] (v : Î¹ â†’ M) [unique Î¹] : v inhabited.default â‰  0 â†’ linear_independent R v
theorem smooth_bump_function.smooth {E : Type uE} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] {H : Type uH} [topological_space H] {I : model_with_corners â„ E H} {M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {c : M} (f : smooth_bump_function I c) [t2_space M] [smooth_manifold_with_corners I M] : smooth I (model_with_corners_self â„ â„) â‡‘f
theorem metric.uniformity_basis_dist_le {Î± : Type u} [pseudo_metric_space Î±] : (uniformity Î±).has_basis (Î» (Îµ : â„), 0 < Îµ) (Î» (Îµ : â„), {p : Î± Ã— Î± | has_dist.dist p.fst p.snd â‰¤ Îµ})
theorem convex.lipschitz_on_with_of_nnnorm_deriv_within_le {ğ•œ : Type u_3} {G : Type u_4} [is_R_or_C ğ•œ] [normed_group G] [normed_space ğ•œ G] {f : ğ•œ â†’ G} {s : set ğ•œ} {C : nnreal} (hs : convex â„ s) (hf : differentiable_on ğ•œ f s) (bound : âˆ€ (x : ğ•œ), x âˆˆ s â†’ âˆ¥deriv_within f s xâˆ¥â‚Š â‰¤ C) : lipschitz_on_with C f s
theorem algebraic_geometry.reduce_to_affine_global (P : Î  (X : algebraic_geometry.Scheme), topological_space.opens â†¥(X.to_LocallyRingedSpace.to_SheafedSpace.to_PresheafedSpace.carrier) â†’ Prop) (hâ‚ : âˆ€ (X : algebraic_geometry.Scheme) (U : topological_space.opens â†¥(X.to_LocallyRingedSpace.to_SheafedSpace.to_PresheafedSpace.carrier)), (âˆ€ (x : â†¥U), âˆƒ {V : topological_space.opens â†¥(X.to_LocallyRingedSpace.to_SheafedSpace.to_PresheafedSpace.carrier)} (h : x.val âˆˆ V) (i : V âŸ¶ U), P X V) â†’ P X U) (hâ‚‚ : âˆ€ {X Y : algebraic_geometry.Scheme} (f : X âŸ¶ Y) [hf : algebraic_geometry.is_open_immersion f], âˆƒ {U : set â†¥(X.to_LocallyRingedSpace.to_SheafedSpace.to_PresheafedSpace.carrier)} {V : set â†¥(Y.to_LocallyRingedSpace.to_SheafedSpace.to_PresheafedSpace.carrier)} (hU : U = âŠ¤) (hV : V = set.range â‡‘(f.val.base)), P X âŸ¨U, _âŸ© â†’ P Y âŸ¨V, _âŸ©) (hâ‚ƒ : âˆ€ (R : CommRing), P (algebraic_geometry.Scheme.Spec.obj (opposite.op R)) âŠ¤) (X : algebraic_geometry.Scheme) (U : topological_space.opens â†¥(X.to_LocallyRingedSpace.to_SheafedSpace.to_PresheafedSpace.carrier)) : P X U
theorem rack.to_envel_group.univ (R : Type u_1) [rack R] (G : Type u_2) [group G] (f : shelf_hom R (quandle.conj G)) : (quandle.conj.map (â‡‘rack.to_envel_group.map f)).comp (rack.to_envel_group R) = f
theorem polynomial.mono_map_nat_degree_eq {R : Type u_1} [semiring R] {S : Type u_2} {F : Type u_3} [semiring S] [add_monoid_hom_class F (polynomial R) (polynomial S)] {Ï† : F} {p : polynomial R} (k : â„•) (fu : â„• â†’ â„•) (fu0 : âˆ€ {n : â„•}, n â‰¤ k â†’ fu n = 0) (fc : âˆ€ {n m : â„•}, k â‰¤ n â†’ n < m â†’ fu n < fu m) (Ï†_k : âˆ€ {f : polynomial R}, f.nat_degree < k â†’ â‡‘Ï† f = 0) (Ï†_mon_nat : âˆ€ (n : â„•) (c : R), c â‰  0 â†’ (â‡‘Ï† (â‡‘(polynomial.monomial n) c)).nat_degree = fu n) : (â‡‘Ï† p).nat_degree = fu p.nat_degree
theorem list.drop_append {Î± : Type u} {lâ‚ lâ‚‚ : list Î±} (i : â„•) : list.drop (lâ‚.length + i) (lâ‚ ++ lâ‚‚) = list.drop i lâ‚‚
theorem antisymm_of' {Î± : Type u} (r : Î± â†’ Î± â†’ Prop) [is_antisymm Î± r] {a b : Î±} : r a b â†’ r b a â†’ b = a
theorem pi.mul_single_apply_commute {I : Type u} {f : I â†’ Type v} [decidable_eq I] [Î  (i : I), mul_one_class (f i)] (x : Î  (i : I), f i) (i j : I) : commute (pi.mul_single i (x i)) (pi.mul_single j (x j))
theorem nnreal.has_sum_iff_tendsto_nat {f : â„• â†’ nnreal} {r : nnreal} : has_sum f r â†” filter.tendsto (Î» (n : â„•), (finset.range n).sum (Î» (i : â„•), f i)) filter.at_top (nhds r)
theorem holder_with.uniform_continuous {X : Type u_1} {Y : Type u_2} [pseudo_emetric_space X] [pseudo_emetric_space Y] {C r : nnreal} {f : X â†’ Y} (hf : holder_with C r f) (h0 : 0 < r) : uniform_continuous f
theorem cardinal.mk_Icc_real {a b : â„} (h : a < b) : cardinal.mk â†¥(set.Icc a b) = cardinal.continuum
theorem linear_map.sum_repr_mul_repr_mul {Î¹â‚ : Type u_1} {Î¹â‚‚ : Type u_2} {R : Type u_3} {Râ‚‚ : Type u_4} {S : Type u_5} {Sâ‚‚ : Type u_6} {M : Type u_7} {N : Type u_8} {P : Type u_9} [comm_ring R] [comm_ring S] [comm_ring Râ‚‚] [comm_ring Sâ‚‚] [add_comm_group M] [add_comm_group N] [add_comm_group P] [module R M] [module S N] [module Râ‚‚ P] [module Sâ‚‚ P] [smul_comm_class Sâ‚‚ Râ‚‚ P] {Ïâ‚â‚‚ : R â†’+* Râ‚‚} {Ïƒâ‚â‚‚ : S â†’+* Sâ‚‚} (bâ‚ : basis Î¹â‚ R M) (bâ‚‚ : basis Î¹â‚‚ S N) {B : M â†’â‚›â‚—[Ïâ‚â‚‚] N â†’â‚›â‚—[Ïƒâ‚â‚‚] P} (x : M) (y : N) : (â‡‘(bâ‚.repr) x).sum (Î» (i : Î¹â‚) (xi : R), (â‡‘(bâ‚‚.repr) y).sum (Î» (j : Î¹â‚‚) (yj : S), â‡‘Ïâ‚â‚‚ xi â€¢ â‡‘Ïƒâ‚â‚‚ yj â€¢ â‡‘(â‡‘B (â‡‘bâ‚ i)) (â‡‘bâ‚‚ j))) = â‡‘(â‡‘B x) y
theorem besicovitch.ae_tendsto_measure_inter_div_of_measurable_set {Î² : Type u} [metric_space Î²] [measurable_space Î²] [borel_space Î²] [sigma_compact_space Î²] [has_besicovitch_covering Î²] (Î¼ : measure_theory.measure Î²) [measure_theory.is_locally_finite_measure Î¼] {s : set Î²} (hs : measurable_set s) : âˆ€áµ (x : Î²) âˆ‚Î¼, filter.tendsto (Î» (r : â„), â‡‘Î¼ (s âˆ© metric.closed_ball x r) / â‡‘Î¼ (metric.closed_ball x r)) (nhds_within 0 (set.Ioi 0)) (nhds (s.indicator 1 x))
theorem antitone.map_is_least {Î± : Type u} {Î² : Type v} [preorder Î±] [preorder Î²] {f : Î± â†’ Î²} (hf : antitone f) {a : Î±} {s : set Î±} : is_least s a â†’ is_greatest (f '' s) (f a)
theorem tendsto_subseq_of_bounded {X : Type u_1} [pseudo_metric_space X] [proper_space X] {s : set X} (hs : metric.bounded s) {x : â„• â†’ X} (hx : âˆ€ (n : â„•), x n âˆˆ s) : âˆƒ (a : X) (H : a âˆˆ closure s) (Ï† : â„• â†’ â„•), strict_mono Ï† âˆ§ filter.tendsto (x âˆ˜ Ï†) filter.at_top (nhds a)
theorem exists_irrational_btwn {x y : â„} (h : x < y) : âˆƒ (r : â„), irrational r âˆ§ x < r âˆ§ r < y
theorem tactic.ring_exp.exp_congr {Î± : Type u} [comm_semiring Î±] {p p' : Î±} {ps ps' : â„•} : p = p' â†’ ps = ps' â†’ p ^ ps = p' ^ ps'
theorem direct_sum.ring_hom_ext' {Î¹ : Type u_1} [decidable_eq Î¹] {A : Î¹ â†’ Type u_2} {R : Type u_3} [Î  (i : Î¹), add_comm_monoid (A i)] [add_monoid Î¹] [direct_sum.gsemiring A] [semiring R] â¦ƒF G : direct_sum Î¹ (Î» (i : Î¹), A i) â†’+* Râ¦„ (h : âˆ€ (i : Î¹), â†‘F.comp (direct_sum.of A i) = â†‘G.comp (direct_sum.of A i)) : F = G
theorem is_galois.tfae {F : Type u_1} [field F] {E : Type u_2} [field E] [algebra F E] [finite_dimensional F E] : [is_galois F E, intermediate_field.fixed_field âŠ¤ = âŠ¥, fintype.card (E â‰ƒâ‚[F] E) = finite_dimensional.finrank F E, âˆƒ (p : polynomial F), p.separable âˆ§ polynomial.is_splitting_field F E p].tfae
theorem cont_diff_within_at.exists_lipschitz_on_with {E : Type u_1} {F : Type u_2} [normed_group E] [normed_space â„ E] [normed_group F] [normed_space â„ F] {f : E â†’ F} {s : set E} {x : E} (hf : cont_diff_within_at â„ 1 f s x) (hs : convex â„ s) : âˆƒ (K : nnreal) (t : set E) (H : t âˆˆ nhds_within x s), lipschitz_on_with K f t
theorem dense_Inter_of_GÎ´ {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [baire_space Î±] [encodable Î²] {f : Î² â†’ set Î±} (ho : âˆ€ (s : Î²), is_GÎ´ (f s)) (hd : âˆ€ (s : Î²), dense (f s)) : dense (â‹‚ (s : Î²), f s)
theorem simple_graph.exists_maximal_degree_vertex {V : Type u} (G : simple_graph V) [fintype V] [decidable_rel G.adj] [nonempty V] : âˆƒ (v : V), G.max_degree = G.degree v
theorem category_theory.limits.image.eq_fac {C : Type u} [category_theory.category C] {X Y : C} {f f' : X âŸ¶ Y} [category_theory.limits.has_image f] [category_theory.limits.has_image f'] [category_theory.limits.has_equalizers C] (h : f = f') : category_theory.limits.image.Î¹ f = (category_theory.limits.image.eq_to_iso h).hom â‰« category_theory.limits.image.Î¹ f'
theorem cont_diff_on.differentiable_on {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {s : set E} {f : E â†’ F} {n : with_top â„•} (h : cont_diff_on ğ•œ n f s) (hn : 1 â‰¤ n) : differentiable_on ğ•œ f s
theorem zmod.legendre_sym_card_sqrts (p : â„•) [fact (nat.prime p)] (hp : p â‰  2) (a : â„¤) : â†‘({x : zmod p | x ^ 2 = â†‘a}.to_finset.card) = zmod.legendre_sym p a + 1
theorem category_theory.subobject.eq_of_comm {C : Type uâ‚} [category_theory.category C] {B : C} {X Y : category_theory.subobject B} (f : â†‘X â‰… â†‘Y) (w : f.hom â‰« Y.arrow = X.arrow) : X = Y
theorem factorization_mul {Î± : Type u_1} [cancel_comm_monoid_with_zero Î±] [unique_factorization_monoid Î±] [normalization_monoid Î±] [decidable_eq Î±] {a b : Î±} (ha : a â‰  0) (hb : b â‰  0) : factorization (a * b) = factorization a + factorization b
theorem le_rfl {Î± : Type u} [preorder Î±] {a : Î±} : a â‰¤ a
theorem dense_embedding.prod {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} {Î´ : Type u_4} [topological_space Î±] [topological_space Î²] [topological_space Î³] [topological_space Î´] {eâ‚ : Î± â†’ Î²} {eâ‚‚ : Î³ â†’ Î´} (deâ‚ : dense_embedding eâ‚) (deâ‚‚ : dense_embedding eâ‚‚) : dense_embedding (Î» (p : Î± Ã— Î³), (eâ‚ p.fst, eâ‚‚ p.snd))
theorem tfae_mem_nhds_within_Iic {Î± : Type u} [topological_space Î±] [linear_order Î±] [order_topology Î±] {a b : Î±} (h : a < b) (s : set Î±) : [s âˆˆ nhds_within b (set.Iic b), s âˆˆ nhds_within b (set.Icc a b), s âˆˆ nhds_within b (set.Ioc a b), âˆƒ (l : Î±) (H : l âˆˆ set.Ico a b), set.Ioc l b âŠ† s, âˆƒ (l : Î±) (H : l âˆˆ set.Iio b), set.Ioc l b âŠ† s].tfae
theorem approximates_linear_on.norm_fderiv_sub_le {E : Type u_1} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] {s : set E} {f : E â†’ E} [measurable_space E] [borel_space E] (Î¼ : measure_theory.measure E) [Î¼.is_add_haar_measure] {A : E â†’L[â„] E} {Î´ : nnreal} (hf : approximates_linear_on f A s Î´) (hs : measurable_set s) (f' : E â†’ (E â†’L[â„] E)) (hf' : âˆ€ (x : E), x âˆˆ s â†’ has_fderiv_within_at f (f' x) s x) : âˆ€áµ (x : E) âˆ‚Î¼.restrict s, âˆ¥f' x - Aâˆ¥â‚Š â‰¤ Î´
theorem star_convex.affine_image {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [ordered_ring ğ•œ] [add_comm_group E] [add_comm_group F] [module ğ•œ E] [module ğ•œ F] {x : E} (f : E â†’áµƒ[ğ•œ] F) {s : set E} (hs : star_convex ğ•œ x s) : star_convex ğ•œ (â‡‘f x) (â‡‘f '' s)
theorem ennreal.to_real_sum {Î± : Type u_1} {s : finset Î±} {f : Î± â†’ ennreal} (hf : âˆ€ (a : Î±), a âˆˆ s â†’ f a â‰  âŠ¤) : (s.sum (Î» (a : Î±), f a)).to_real = s.sum (Î» (a : Î±), (f a).to_real)
theorem bounded_continuous_function.dist_le {Î± : Type u} {Î² : Type v} [topological_space Î±] [pseudo_metric_space Î²] {f g : bounded_continuous_function Î± Î²} {C : â„} (C0 : 0 â‰¤ C) : has_dist.dist f g â‰¤ C â†” âˆ€ (x : Î±), has_dist.dist (â‡‘f x) (â‡‘g x) â‰¤ C
theorem affine_span_nonempty (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P) : â†‘(affine_span k s).nonempty â†” s.nonempty
theorem continuous_map.continuous_comp {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [topological_space Î±] [topological_space Î²] [topological_space Î³] (g : C(Î², Î³)) : continuous g.comp
theorem configuration.has_points.card_le (P L : Type u) [has_mem P L] [configuration.has_points P L] [fintype P] [fintype L] : fintype.card L â‰¤ fintype.card P
theorem phragmen_lindelof.eq_zero_on_horizontal_strip {E : Type u_1} [normed_group E] [normed_space â„‚ E] {a b : â„} {f : â„‚ â†’ E} (hd : diff_cont_on_cl â„‚ f (complex.im â»Â¹' set.Ioo a b)) (hB : âˆƒ (c : â„) (H : c < real.pi / (b - a)) (B : â„), f =O[filter.comap (has_abs.abs âˆ˜ complex.re) filter.at_top âŠ“ filter.principal (complex.im â»Â¹' set.Ioo a b)] Î» (z : â„‚), real.exp (B * real.exp (c * |z.re|))) (ha : âˆ€ (z : â„‚), z.im = a â†’ f z = 0) (hb : âˆ€ (z : â„‚), z.im = b â†’ f z = 0) : set.eq_on f 0 (complex.im â»Â¹' set.Icc a b)
theorem is_left_regular.pow_iff {R : Type u_1} {a : R} [monoid R] {n : â„•} (n0 : 0 < n) : is_left_regular (a ^ n) â†” is_left_regular a
theorem generalized_continued_fraction.squash_seq_succ_n_tail_eq_squash_seq_tail_n {K : Type u_1} {n : â„•} {s : seq (generalized_continued_fraction.pair K)} [division_ring K] : (generalized_continued_fraction.squash_seq s (n + 1)).tail = generalized_continued_fraction.squash_seq s.tail n
theorem category_theory.non_preadditive_abelian.Ïƒ_comp {C : Type u} [category_theory.category C] [category_theory.non_preadditive_abelian C] {X Y : C} (f : X âŸ¶ Y) : category_theory.non_preadditive_abelian.Ïƒ â‰« f = category_theory.limits.prod.map f f â‰« category_theory.non_preadditive_abelian.Ïƒ
theorem triv_sq_zero_ext.ind {R : Type u_1} {M : Type u_2} [add_zero_class R] [add_zero_class M] {P : triv_sq_zero_ext R M â†’ Prop} (h : âˆ€ (r : R) (m : M), P (triv_sq_zero_ext.inl r + triv_sq_zero_ext.inr m)) (x : triv_sq_zero_ext R M) : P x
theorem submodule.basis_of_pid_aux {Î¹ : Type u_1} {R : Type u_2} [comm_ring R] [is_domain R] [is_principal_ideal_ring R] [fintype Î¹] {O : Type u_3} [add_comm_group O] [module R O] (M N : submodule R O) (b'M : basis Î¹ R â†¥M) (N_bot : N â‰  âŠ¥) (N_le_M : N â‰¤ M) : âˆƒ (y : O) (H : y âˆˆ M) (a : R) (hay : a â€¢ y âˆˆ N) (M' : submodule R O) (H : M' â‰¤ M) (N' : submodule R O) (H : N' â‰¤ N) (N'_le_M' : N' â‰¤ M') (y_ortho_M' : âˆ€ (c : R) (z : O), z âˆˆ M' â†’ c â€¢ y + z = 0 â†’ c = 0) (ay_ortho_N' : âˆ€ (c : R) (z : O), z âˆˆ N' â†’ c â€¢ a â€¢ y + z = 0 â†’ c = 0), âˆ€ (n' : â„•) (bN' : basis (fin n') R â†¥N'), âˆƒ (bN : basis (fin (n' + 1)) R â†¥N), âˆ€ (m' : â„•) (hn'm' : n' â‰¤ m') (bM' : basis (fin m') R â†¥M'), âˆƒ (hnm : n' + 1 â‰¤ m' + 1) (bM : basis (fin (m' + 1)) R â†¥M), âˆ€ (as : fin n' â†’ R), (âˆ€ (i : fin n'), â†‘(â‡‘bN' i) = as i â€¢ â†‘(â‡‘bM' (â‡‘(fin.cast_le hn'm') i))) â†’ (âˆƒ (as' : fin (n' + 1) â†’ R), âˆ€ (i : fin (n' + 1)), â†‘(â‡‘bN i) = as' i â€¢ â†‘(â‡‘bM (â‡‘(fin.cast_le hnm) i)))
theorem add_subgroup.closure_eq {G : Type u_1} [add_group G] (K : add_subgroup G) : add_subgroup.closure â†‘K = K
theorem pi_nat.exists_lipschitz_retraction_of_is_closed {E : â„• â†’ Type u_1} [Î  (n : â„•), topological_space (E n)] [âˆ€ (n : â„•), discrete_topology (E n)] {s : set (Î  (n : â„•), E n)} (hs : is_closed s) (hne : s.nonempty) : âˆƒ (f : (Î  (n : â„•), E n) â†’ Î  (n : â„•), E n), (âˆ€ (x : Î  (n : â„•), E n), x âˆˆ s â†’ f x = x) âˆ§ set.range f = s âˆ§ lipschitz_with 1 f
theorem direct_sum.ring_hom_ext {Î¹ : Type u_1} [decidable_eq Î¹] {A : Î¹ â†’ Type u_2} {R : Type u_3} [Î  (i : Î¹), add_comm_monoid (A i)] [add_monoid Î¹] [direct_sum.gsemiring A] [semiring R] â¦ƒf g : direct_sum Î¹ (Î» (i : Î¹), A i) â†’+* Râ¦„ (h : âˆ€ (i : Î¹) (x : A i), â‡‘f (â‡‘(direct_sum.of A i) x) = â‡‘g (â‡‘(direct_sum.of A i) x)) : f = g
theorem equiv.nontrivial {Î± : Type u} {Î² : Type v} (e : Î± â‰ƒ Î²) [nontrivial Î²] : nontrivial Î±
theorem measure_theory.outer_measure.trim_binop {Î± : Type u_1} [measurable_space Î±] {mâ‚ mâ‚‚ mâ‚ƒ : measure_theory.outer_measure Î±} {op : ennreal â†’ ennreal â†’ ennreal} (h : âˆ€ (s : set Î±), â‡‘mâ‚ s = op (â‡‘mâ‚‚ s) (â‡‘mâ‚ƒ s)) (s : set Î±) : â‡‘(mâ‚.trim) s = op (â‡‘(mâ‚‚.trim) s) (â‡‘(mâ‚ƒ.trim) s)
theorem sub_left_le_of_le_add {Î± : Type u} [add_comm_group Î±] [has_le Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b c : Î±} : a â‰¤ b + c â†’ a - b â‰¤ c
theorem linear_map.eq_adjoint_iff_basis {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] [inner_product_space ğ•œ F] [finite_dimensional ğ•œ E] [finite_dimensional ğ•œ F] {Î¹â‚ : Type u_4} {Î¹â‚‚ : Type u_5} (bâ‚ : basis Î¹â‚ ğ•œ E) (bâ‚‚ : basis Î¹â‚‚ ğ•œ F) (A : E â†’â‚—[ğ•œ] F) (B : F â†’â‚—[ğ•œ] E) : A = â‡‘linear_map.adjoint B â†” âˆ€ (iâ‚ : Î¹â‚) (iâ‚‚ : Î¹â‚‚), has_inner.inner (â‡‘A (â‡‘bâ‚ iâ‚)) (â‡‘bâ‚‚ iâ‚‚) = has_inner.inner (â‡‘bâ‚ iâ‚) (â‡‘B (â‡‘bâ‚‚ iâ‚‚))
theorem intermediate_field.prod_mem {K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) {Î¹ : Type u_3} {t : finset Î¹} {f : Î¹ â†’ L} (h : âˆ€ (c : Î¹), c âˆˆ t â†’ f c âˆˆ S) : t.prod (Î» (i : Î¹), f i) âˆˆ S
theorem complex.tendsto_lim_of_differentiable_on_punctured_nhds_of_bounded_under {E : Type u} [normed_group E] [normed_space â„‚ E] [complete_space E] {f : â„‚ â†’ E} {c : â„‚} (hd : âˆ€á¶  (z : â„‚) in nhds_within c {c}á¶œ, differentiable_at â„‚ f z) (hb : filter.is_bounded_under has_le.le (nhds_within c {c}á¶œ) (Î» (z : â„‚), âˆ¥f z - f câˆ¥)) : filter.tendsto f (nhds_within c {c}á¶œ) (nhds (lim (nhds_within c {c}á¶œ) f))
theorem subalgebra.topological_closure_comap'_homeomorph {R : Type u_1} [comm_semiring R] {A : Type u} [topological_space A] [semiring A] [algebra R A] [topological_semiring A] (s : subalgebra R A) {B : Type u_2} [topological_space B] [ring B] [topological_ring B] [algebra R B] (f : B â†’â‚[R] A) (f' : B â‰ƒâ‚œ A) (w : â‡‘f = â‡‘f') : s.topological_closure.comap' f = (s.comap' f).topological_closure
theorem cycle.induction_on {Î± : Type u_1} {C : cycle Î± â†’ Prop} (s : cycle Î±) (H0 : C cycle.nil) (HI : âˆ€ (a : Î±) (l : list Î±), C â†‘l â†’ C â†‘(a :: l)) : C s
theorem orthonormal.rotation_eq_self_iff_angle_eq_zero {V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) {x : V} (hx : x â‰  0) (Î¸ : real.angle) : â‡‘(hb.rotation Î¸) x = x â†” Î¸ = 0
theorem irrational.add_cases {x y : â„} : irrational (x + y) â†’ irrational x âˆ¨ irrational y
theorem exists_mem_nhds_within_lt_dimH_of_lt_dimH {X : Type u_2} [emetric_space X] [topological_space.second_countable_topology X] {s : set X} {r : ennreal} (h : r < dimH s) : âˆƒ (x : X) (H : x âˆˆ s), âˆ€ (t : set X), t âˆˆ nhds_within x s â†’ r < dimH t
theorem power_series.exp_pow_sum {A : Type u_1} [comm_ring A] [algebra â„š A] (n : â„•) : (finset.range n).sum (Î» (k : â„•), power_series.exp A ^ k) = power_series.mk (Î» (p : â„•), (finset.range n).sum (Î» (k : â„•), â†‘k ^ p * â‡‘(algebra_map â„š A) (â†‘(p.factorial))â»Â¹))
theorem comm_monoid.torsion.is_torsion {G : Type u_1} [comm_monoid G] : monoid.is_torsion â†¥(comm_monoid.torsion G)
theorem emetric.inf_edist_lt_iff {Î± : Type u} [pseudo_emetric_space Î±] {x : Î±} {s : set Î±} {r : ennreal} : emetric.inf_edist x s < r â†” âˆƒ (y : Î±) (H : y âˆˆ s), has_edist.edist x y < r
theorem continuous_multilinear_map.norm_image_sub_le {ğ•œ : Type u} {Î¹ : Type v} {E : Î¹ â†’ Type wE} {G : Type wG} [decidable_eq Î¹] [fintype Î¹] [nondiscrete_normed_field ğ•œ] [Î  (i : Î¹), normed_group (E i)] [Î  (i : Î¹), normed_space ğ•œ (E i)] [normed_group G] [normed_space ğ•œ G] (f : continuous_multilinear_map ğ•œ E G) (mâ‚ mâ‚‚ : Î  (i : Î¹), E i) : âˆ¥â‡‘f mâ‚ - â‡‘f mâ‚‚âˆ¥ â‰¤ âˆ¥fâˆ¥ * â†‘(fintype.card Î¹) * linear_order.max âˆ¥mâ‚âˆ¥ âˆ¥mâ‚‚âˆ¥ ^ (fintype.card Î¹ - 1) * âˆ¥mâ‚ - mâ‚‚âˆ¥
theorem circle_deg1_lift.semiconj_of_bijective_of_translation_number_eq {fâ‚ fâ‚‚ : circle_deg1_lift} (hâ‚ : function.bijective â‡‘fâ‚) (hâ‚‚ : function.bijective â‡‘fâ‚‚) (h : fâ‚.translation_number = fâ‚‚.translation_number) : âˆƒ (F : circle_deg1_lift), function.semiconj â‡‘F â‡‘fâ‚ â‡‘fâ‚‚
theorem composition_series.jordan_holder {X : Type u} [lattice X] [jordan_holder_lattice X] (sâ‚ sâ‚‚ : composition_series X) (hb : sâ‚.bot = sâ‚‚.bot) (ht : sâ‚.top = sâ‚‚.top) : sâ‚.equivalent sâ‚‚
theorem Sup_eq_of_forall_le_of_forall_lt_exists_gt {Î± : Type u_1} [complete_lattice Î±] {s : set Î±} {b : Î±} (_x : âˆ€ (a : Î±), a âˆˆ s â†’ a â‰¤ b) (H : âˆ€ (w : Î±), w < b â†’ (âˆƒ (a : Î±) (H : a âˆˆ s), w < a)) : has_Sup.Sup s = b
theorem finite_field.sum_pow_lt_card_sub_one {K : Type u_1} [field K] [fintype K] (i : â„•) (h : i < fintype.card K - 1) : finset.univ.sum (Î» (x : K), x ^ i) = 0
theorem linear_equiv.finrank_eq {R : Type u_1} {M : Type u_2} {Mâ‚‚ : Type u_3} [ring R] [add_comm_group M] [add_comm_group Mâ‚‚] [module R M] [module R Mâ‚‚] (f : M â‰ƒâ‚—[R] Mâ‚‚) : finite_dimensional.finrank R M = finite_dimensional.finrank R Mâ‚‚
theorem is_pi_system.pi {Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_3} {C : Î  (i : Î¹), set (set (Î± i))} (hC : âˆ€ (i : Î¹), is_pi_system (C i)) : is_pi_system (set.univ.pi '' set.univ.pi C)
theorem measure_theory.tendsto_in_measure_of_tendsto_snorm {Î± : Type u_1} {Î¹ : Type u_2} {E : Type u_3} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [normed_group E] {p : ennreal} {f : Î¹ â†’ Î± â†’ E} {g : Î± â†’ E} {l : filter Î¹} (hp_ne_zero : p â‰  0) (hf : âˆ€ (n : Î¹), measure_theory.ae_strongly_measurable (f n) Î¼) (hg : measure_theory.ae_strongly_measurable g Î¼) (hfg : filter.tendsto (Î» (n : Î¹), measure_theory.snorm (f n - g) p Î¼) l (nhds 0)) : measure_theory.tendsto_in_measure Î¼ f l g
theorem polynomial.sum_over_range' {R : Type u} {S : Type v} [semiring R] [add_comm_monoid S] (p : polynomial R) {f : â„• â†’ R â†’ S} (h : âˆ€ (n : â„•), f n 0 = 0) (n : â„•) (w : p.nat_degree < n) : p.sum f = (finset.range n).sum (Î» (a : â„•), f a (p.coeff a))
theorem is_dedekind_domain.height_one_spectrum.valuation_of_mk' {R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] {K : Type u_2} [field K] [algebra R K] [is_fraction_ring R K] (v : is_dedekind_domain.height_one_spectrum R) {r : R} {s : â†¥(non_zero_divisors R)} : â‡‘(v.valuation) (is_localization.mk' K r s) = â‡‘(v.int_valuation) r / â‡‘(v.int_valuation) â†‘s
theorem formal_multilinear_series.le_radius_of_bound_nnreal {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field ğ•œ] [normed_group E] [normed_space ğ•œ E] [normed_group F] [normed_space ğ•œ F] (p : formal_multilinear_series ğ•œ E F) (C : nnreal) {r : nnreal} (h : âˆ€ (n : â„•), âˆ¥p nâˆ¥â‚Š * r ^ n â‰¤ C) : â†‘r â‰¤ p.radius
theorem covariant.monotone_of_const {M : Type u_1} {N : Type u_2} {Î¼ : M â†’ N â†’ N} [preorder N] [covariant_class M N Î¼ has_le.le] (m : M) : monotone (Î¼ m)
theorem exists_mem_Ioc_zpow {Î± : Type u_1} [linear_ordered_field Î±] [archimedean Î±] {x y : Î±} (hx : 0 < x) (hy : 1 < y) : âˆƒ (n : â„¤), x âˆˆ set.Ioc (y ^ n) (y ^ (n + 1))
theorem submonoid.localization_map.mul_inv_right {M : Type u_1} [comm_monoid M] {S : submonoid M} {N : Type u_2} [comm_monoid N] {f : M â†’* N} (h : âˆ€ (y : â†¥S), is_unit (â‡‘f â†‘y)) (y : â†¥S) (w z : N) : z = w * â†‘(â‡‘(is_unit.lift_right (f.restrict S) h) y)â»Â¹ â†” z * â‡‘f â†‘y = w
theorem is_add_monoid_hom.comp {Î± : Type u} {Î² : Type v} [add_zero_class Î±] [add_zero_class Î²] {f : Î± â†’ Î²} (hf : is_add_monoid_hom f) {Î³ : Type u_1} [add_zero_class Î³] {g : Î² â†’ Î³} (hg : is_add_monoid_hom g) : is_add_monoid_hom (g âˆ˜ f)
theorem is_Sup_finite_compact.well_founded (Î± : Type u_1) [complete_lattice Î±] : complete_lattice.is_Sup_finite_compact Î± â†’ well_founded gt
theorem not_is_right_regular_zero {R : Type u_1} [mul_zero_class R] [nR : nontrivial R] : Â¬is_right_regular 0
theorem is_compact.induction_on {Î± : Type u} [topological_space Î±] {s : set Î±} (hs : is_compact s) {p : set Î± â†’ Prop} (he : p âˆ…) (hmono : âˆ€ â¦ƒs t : set Î±â¦„, s âŠ† t â†’ p t â†’ p s) (hunion : âˆ€ â¦ƒs t : set Î±â¦„, p s â†’ p t â†’ p (s âˆª t)) (hnhds : âˆ€ (x : Î±), x âˆˆ s â†’ (âˆƒ (t : set Î±) (H : t âˆˆ nhds_within x s), p t)) : p s
theorem is_group_hom.map_inv {Î± : Type u} {Î² : Type v} [group Î±] [group Î²] {f : Î± â†’ Î²} (hf : is_group_hom f) (a : Î±) : f aâ»Â¹ = (f a)â»Â¹
theorem category_theory.abelian.pseudoelement.pseudo_apply_aux {C : Type u} [category_theory.category C] [category_theory.abelian C] {P Q : C} (f : P âŸ¶ Q) (a b : category_theory.over P) : a â‰ˆ b â†’ category_theory.abelian.app f a â‰ˆ category_theory.abelian.app f b
theorem cont_mdiff_within_at_iff_cont_mdiff_on_nhds {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {M : Type u_4} [topological_space M] [charted_space H M] [Is : smooth_manifold_with_corners I M] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners ğ•œ E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] [I's : smooth_manifold_with_corners I' M'] {f : M â†’ M'} {s : set M} {x : M} {n : â„•} : cont_mdiff_within_at I I' â†‘n f s x â†” âˆƒ (u : set M) (H_1 : u âˆˆ nhds_within x (has_insert.insert x s)), cont_mdiff_on I I' â†‘n f u
theorem generate_from_prod {Î± : Type u_1} {Î² : Type u_3} [measurable_space Î±] [measurable_space Î²] : measurable_space.generate_from (set.image2 has_set_prod.prod {s : set Î± | measurable_set s} {t : set Î² | measurable_set t}) = prod.measurable_space
theorem has_fpower_series_on_ball.exchange_radius {ğ•œ : Type u_1} {E : Type u_2} [nondiscrete_normed_field ğ•œ] [normed_group E] [normed_space ğ•œ E] {pâ‚ pâ‚‚ : formal_multilinear_series ğ•œ ğ•œ E} {f : ğ•œ â†’ E} {râ‚ râ‚‚ : ennreal} {x : ğ•œ} (hâ‚ : has_fpower_series_on_ball f pâ‚ x râ‚) (hâ‚‚ : has_fpower_series_on_ball f pâ‚‚ x râ‚‚) : has_fpower_series_on_ball f pâ‚ x râ‚‚
theorem measure_theory.simple_func.exists_upper_semicontinuous_le_lintegral_le {Î± : Type u_1} [topological_space Î±] [measurable_space Î±] [borel_space Î±] {Î¼ : measure_theory.measure Î±} [Î¼.weakly_regular] (f : measure_theory.simple_func Î± nnreal) (int_f : âˆ«â» (x : Î±), â†‘(â‡‘f x) âˆ‚Î¼ â‰  âŠ¤) {Îµ : ennreal} (Îµ0 : Îµ â‰  0) : âˆƒ (g : Î± â†’ nnreal), (âˆ€ (x : Î±), g x â‰¤ â‡‘f x) âˆ§ upper_semicontinuous g âˆ§ âˆ«â» (x : Î±), â†‘(â‡‘f x) âˆ‚Î¼ â‰¤ âˆ«â» (x : Î±), â†‘(g x) âˆ‚Î¼ + Îµ
theorem polynomial.degree_le_of_nat_degree_le {R : Type u} [semiring R] {p : polynomial R} {n : â„•} : p.nat_degree â‰¤ n â†’ p.degree â‰¤ â†‘n
theorem fintype.exists_card_fiber_le_of_card_le_mul {Î± : Type u} {Î² : Type v} [decidable_eq Î²] [fintype Î±] [fintype Î²] (f : Î± â†’ Î²) {n : â„•} [nonempty Î²] (hn : fintype.card Î± â‰¤ fintype.card Î² * n) : âˆƒ (y : Î²), (finset.filter (Î» (x : Î±), f x = y) finset.univ).card â‰¤ n
theorem Top.subpresheaf_to_Types.is_sheaf {X : Top} {T : â†¥X â†’ Type v} (P : Top.local_predicate T) : (Top.subpresheaf_to_Types P.to_prelocal_predicate).is_sheaf
theorem orthonormal.exists_hilbert_basis_extension {ğ•œ : Type u_2} [is_R_or_C ğ•œ] {E : Type u_3} [inner_product_space ğ•œ E] [cplt : complete_space E] {s : set E} (hs : orthonormal ğ•œ coe) : âˆƒ (w : set E) (b : hilbert_basis â†¥w ğ•œ E), s âŠ† w âˆ§ â‡‘b = coe
theorem exists_extension_norm_eq {ğ•œ : Type u_1} [is_R_or_C ğ•œ] {F : Type u_2} [semi_normed_group F] [normed_space ğ•œ F] (p : subspace ğ•œ F) (f : â†¥p â†’L[ğ•œ] ğ•œ) : âˆƒ (g : F â†’L[ğ•œ] ğ•œ), (âˆ€ (x : â†¥p), â‡‘g â†‘x = â‡‘f x) âˆ§ âˆ¥gâˆ¥ = âˆ¥fâˆ¥
theorem mv_polynomial.prod_X_add_C_eq_sum_esymm {R : Type u_1} [comm_semiring R] (Ïƒ : Type u_2) [fintype Ïƒ] : finset.univ.prod (Î» (i : Ïƒ), â‡‘polynomial.C (mv_polynomial.X i) + polynomial.X) = (finset.range (fintype.card Ïƒ + 1)).sum (Î» (j : â„•), â‡‘polynomial.C (mv_polynomial.esymm Ïƒ R j) * polynomial.X ^ (fintype.card Ïƒ - j))
theorem category_theory.is_pushout.paste_horiz {C : Type uâ‚} [category_theory.category C] {Xâ‚â‚ Xâ‚â‚‚ Xâ‚â‚ƒ Xâ‚‚â‚ Xâ‚‚â‚‚ Xâ‚‚â‚ƒ : C} {hâ‚â‚ : Xâ‚â‚ âŸ¶ Xâ‚â‚‚} {hâ‚â‚‚ : Xâ‚â‚‚ âŸ¶ Xâ‚â‚ƒ} {hâ‚‚â‚ : Xâ‚‚â‚ âŸ¶ Xâ‚‚â‚‚} {hâ‚‚â‚‚ : Xâ‚‚â‚‚ âŸ¶ Xâ‚‚â‚ƒ} {vâ‚â‚ : Xâ‚â‚ âŸ¶ Xâ‚‚â‚} {vâ‚â‚‚ : Xâ‚â‚‚ âŸ¶ Xâ‚‚â‚‚} {vâ‚â‚ƒ : Xâ‚â‚ƒ âŸ¶ Xâ‚‚â‚ƒ} (s : category_theory.is_pushout hâ‚â‚ vâ‚â‚ vâ‚â‚‚ hâ‚‚â‚) (t : category_theory.is_pushout hâ‚â‚‚ vâ‚â‚‚ vâ‚â‚ƒ hâ‚‚â‚‚) : category_theory.is_pushout (hâ‚â‚ â‰« hâ‚â‚‚) vâ‚â‚ vâ‚â‚ƒ (hâ‚‚â‚ â‰« hâ‚‚â‚‚)
theorem continuous_Inf_domâ‚‚ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} {f : Î± â†’ Î² â†’ Î³} {tas : set (topological_space Î±)} {tbs : set (topological_space Î²)} {ta : topological_space Î±} {tb : topological_space Î²} {tc : topological_space Î³} (ha : ta âˆˆ tas) (hb : tb âˆˆ tbs) (hf : continuous (Î» (p : Î± Ã— Î²), f p.fst p.snd)) : continuous (Î» (p : Î± Ã— Î²), f p.fst p.snd)
theorem submonoid.supr_induction {M : Type u_1} [mul_one_class M] {Î¹ : Sort u_2} (S : Î¹ â†’ submonoid M) {C : M â†’ Prop} {x : M} (hx : x âˆˆ â¨† (i : Î¹), S i) (hp : âˆ€ (i : Î¹) (x : M), x âˆˆ S i â†’ C x) (h1 : C 1) (hmul : âˆ€ (x y : M), C x â†’ C y â†’ C (x * y)) : C x
theorem sylow.card_eq_multiplicity {G : Type u} [group G] [fintype G] {p : â„•} [hp : fact (nat.prime p)] (P : sylow p G) : fintype.card â†¥P = p ^ â‡‘((fintype.card G).factorization) p
theorem exp_neg_inv_glue.f_aux_deriv_zero (n : â„•) : has_deriv_at (exp_neg_inv_glue.f_aux n) 0 0
theorem mul_add_eq_mul_add_iff_sub_mul_add_eq {Î± : Type u} [non_unital_non_assoc_ring Î±] {a b c d e : Î±} : a * e + c = b * e + d â†” (a - b) * e + c = d
theorem witt_vector.is_polyâ‚‚.comp_right {p : â„•} {g : Î  â¦ƒR : Type u_1â¦„ [_inst_3 : comm_ring R], witt_vector p R â†’ witt_vector p R â†’ witt_vector p R} {f : Î  â¦ƒR : Type u_1â¦„ [_inst_3 : comm_ring R], witt_vector p R â†’ witt_vector p R} (hg : witt_vector.is_polyâ‚‚ p g) (hf : witt_vector.is_poly p f) : witt_vector.is_polyâ‚‚ p (Î» (R : Type u_1) (_Rcr : comm_ring R) (x y : witt_vector p R), g x (f y))
theorem ordinal.fp_unbounded {f : ordinal â†’ ordinal} (H : ordinal.is_normal f) : set.unbounded has_lt.lt (function.fixed_points f)
theorem measurable_of_tendsto_nnreal' {Î± : Type u_1} [measurable_space Î±] {Î¹ : Type u_2} {f : Î¹ â†’ Î± â†’ nnreal} {g : Î± â†’ nnreal} (u : filter Î¹) [u.ne_bot] [u.is_countably_generated] (hf : âˆ€ (i : Î¹), measurable (f i)) (lim : filter.tendsto f u (nhds g)) : measurable g
theorem strict_mono_on.continuous_at_of_exists_between {Î± : Type u_1} {Î² : Type u_2} [linear_order Î±] [topological_space Î±] [order_topology Î±] [linear_order Î²] [topological_space Î²] [order_topology Î²] {f : Î± â†’ Î²} {s : set Î±} {a : Î±} (h_mono : strict_mono_on f s) (hs : s âˆˆ nhds a) (hfs_l : âˆ€ (b : Î²), b < f a â†’ (âˆƒ (c : Î±) (H : c âˆˆ s), f c âˆˆ set.Ico b (f a))) (hfs_r : âˆ€ (b : Î²), b > f a â†’ (âˆƒ (c : Î±) (H : c âˆˆ s), f c âˆˆ set.Ioc (f a) b)) : continuous_at f a
theorem metric.bounded_bUnion {Î± : Type u} {Î² : Type v} [pseudo_metric_space Î±] {I : set Î²} {s : Î² â†’ set Î±} (H : I.finite) : metric.bounded (â‹ƒ (i : Î²) (H : i âˆˆ I), s i) â†” âˆ€ (i : Î²), i âˆˆ I â†’ metric.bounded (s i)
theorem metric.bounded.measure_lt_top {Î± : Type u_1} {m0 : measurable_space Î±} [pseudo_metric_space Î±] [proper_space Î±] {Î¼ : measure_theory.measure Î±} [measure_theory.is_finite_measure_on_compacts Î¼] â¦ƒs : set Î±â¦„ (hs : metric.bounded s) : â‡‘Î¼ s < âŠ¤
theorem has_lt.lt.lf {x y : pgame} (h : x < y) : x.lf y
theorem exists_maximal_of_chains_bounded {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} (h : âˆ€ (c : set Î±), is_chain r c â†’ (âˆƒ (ub : Î±), âˆ€ (a : Î±), a âˆˆ c â†’ r a ub)) (trans : âˆ€ {a b c : Î±}, r a b â†’ r b c â†’ r a c) : âˆƒ (m : Î±), âˆ€ (a : Î±), r m a â†’ r a m
theorem set.eq_on.closure {Î± : Type u} {Î² : Type v} [topological_space Î±] [topological_space Î²] [t2_space Î±] {s : set Î²} {f g : Î² â†’ Î±} (h : set.eq_on f g s) (hf : continuous f) (hg : continuous g) : set.eq_on f g (closure s)
theorem emetric.inf_edist_le_inf_edist_add_edist {Î± : Type u} [pseudo_emetric_space Î±] {x y : Î±} {s : set Î±} : emetric.inf_edist x s â‰¤ emetric.inf_edist y s + has_edist.edist x y
theorem add_con.neg {M : Type u_1} [add_group M] (c : add_con M) {w x : M} : â‡‘c w x â†’ â‡‘c (-w) (-x)
theorem direct_sum.add_hom_ext' {Î¹ : Type v} [dec_Î¹ : decidable_eq Î¹] {Î² : Î¹ â†’ Type w} [Î  (i : Î¹), add_comm_monoid (Î² i)] {Î³ : Type u_1} [add_monoid Î³] â¦ƒf g : direct_sum Î¹ (Î» (i : Î¹), Î² i) â†’+ Î³â¦„ (H : âˆ€ (i : Î¹), f.comp (direct_sum.of (Î» (i : Î¹), Î² i) i) = g.comp (direct_sum.of Î² i)) : f = g
theorem is_right_regular.pow {R : Type u_1} {a : R} [monoid R] (n : â„•) (rra : is_right_regular a) : is_right_regular (a ^ n)
theorem convex.interior {E : Type u_2} {ğ•œ : Type u_3} [linear_ordered_field ğ•œ] [add_comm_group E] [module ğ•œ E] [topological_space E] [topological_add_group E] [has_continuous_const_smul ğ•œ E] {s : set E} (hs : convex ğ•œ s) : convex ğ•œ (interior s)
theorem function.embedding.min_injective {Î¹ : Type u} (Î² : Î¹ â†’ Type v) [I : nonempty Î¹] : âˆƒ (i : Î¹), nonempty (Î  (j : Î¹), Î² i â†ª Î² j)
theorem isometry.injective {Î² : Type v} [pseudo_emetric_space Î²] {Î± : Type u} [emetric_space Î±] {f : Î± â†’ Î²} (h : isometry f) : function.injective f
theorem is_local_extr_on.exists_multipliers_of_has_strict_fderiv_at {E : Type u_1} [normed_group E] [normed_space â„ E] [complete_space E] {Ï† : E â†’ â„} {xâ‚€ : E} {Ï†' : E â†’L[â„] â„} {Î¹ : Type u_2} [fintype Î¹] {f : Î¹ â†’ E â†’ â„} {f' : Î¹ â†’ (E â†’L[â„] â„)} (hextr : is_local_extr_on Ï† {x : E | âˆ€ (i : Î¹), f i x = f i xâ‚€} xâ‚€) (hf' : âˆ€ (i : Î¹), has_strict_fderiv_at (f i) (f' i) xâ‚€) (hÏ†' : has_strict_fderiv_at Ï† Ï†' xâ‚€) : âˆƒ (Î› : Î¹ â†’ â„) (Î›â‚€ : â„), (Î›, Î›â‚€) â‰  0 âˆ§ finset.univ.sum (Î» (i : Î¹), Î› i â€¢ f' i) + Î›â‚€ â€¢ Ï†' = 0
theorem measure_theory.measure.eq_with_density_rn_deriv {Î± : Type u_1} {m : measurable_space Î±} {Î¼ Î½ s : measure_theory.measure Î±} {f : Î± â†’ ennreal} (hf : measurable f) (hs : s.mutually_singular Î½) (hadd : Î¼ = s + Î½.with_density f) : Î½.with_density f = Î½.with_density (Î¼.rn_deriv Î½)
theorem orthonormal.oangle_neg_left_eq_neg_right {V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) (x y : V) : hb.oangle (-x) y = hb.oangle x (-y)
theorem cont_diff_on_snd {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {n : with_top â„•} {s : set (E Ã— F)} : cont_diff_on ğ•œ n prod.snd s
theorem mem_closure_iff_ultrafilter {Î± : Type u} [topological_space Î±] {s : set Î±} {x : Î±} : x âˆˆ closure s â†” âˆƒ (u : ultrafilter Î±), s âˆˆ u âˆ§ â†‘u â‰¤ nhds x
theorem real.tendsto_sum_pi_div_four  : filter.tendsto (Î» (k : â„•), (finset.range k).sum (Î» (i : â„•), (-1) ^ i / (2 * â†‘i + 1))) filter.at_top (nhds (real.pi / 4))
theorem monovary.sum_comp_perm_smul_lt_sum_smul_iff {Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [linear_ordered_ring Î±] [linear_ordered_add_comm_group Î²] [module Î± Î²] [ordered_smul Î± Î²] {Ïƒ : equiv.perm Î¹} {f : Î¹ â†’ Î±} {g : Î¹ â†’ Î²} [fintype Î¹] (hfg : monovary f g) : finset.univ.sum (Î» (i : Î¹), f (â‡‘Ïƒ i) â€¢ g i) < finset.univ.sum (Î» (i : Î¹), f i â€¢ g i) â†” Â¬monovary (f âˆ˜ â‡‘Ïƒ) g
theorem chart_at_self_eq {H : Type u_1} [topological_space H] {x : H} : charted_space.chart_at H x = local_homeomorph.refl H
theorem sum_four_sq_mul_sum_four_sq {R : Type u_1} [comm_ring R] {xâ‚ xâ‚‚ xâ‚ƒ xâ‚„ yâ‚ yâ‚‚ yâ‚ƒ yâ‚„ : R} : (xâ‚ ^ 2 + xâ‚‚ ^ 2 + xâ‚ƒ ^ 2 + xâ‚„ ^ 2) * (yâ‚ ^ 2 + yâ‚‚ ^ 2 + yâ‚ƒ ^ 2 + yâ‚„ ^ 2) = (xâ‚ * yâ‚ - xâ‚‚ * yâ‚‚ - xâ‚ƒ * yâ‚ƒ - xâ‚„ * yâ‚„) ^ 2 + (xâ‚ * yâ‚‚ + xâ‚‚ * yâ‚ + xâ‚ƒ * yâ‚„ - xâ‚„ * yâ‚ƒ) ^ 2 + (xâ‚ * yâ‚ƒ - xâ‚‚ * yâ‚„ + xâ‚ƒ * yâ‚ + xâ‚„ * yâ‚‚) ^ 2 + (xâ‚ * yâ‚„ + xâ‚‚ * yâ‚ƒ - xâ‚ƒ * yâ‚‚ + xâ‚„ * yâ‚) ^ 2
theorem is_add_left_regular_of_add_eq_zero {R : Type u_1} {a b : R} [add_monoid R] (h : b + a = 0) : is_add_left_regular a
theorem is_add_torsion.exponent_exists {G : Type u_1} [add_group G] (tG : add_monoid.is_torsion G) (bounded : (set.range (Î» (g : G), add_order_of g)).finite) : add_monoid.exponent_exists G
theorem is_least.bdd_below {Î± : Type u} [preorder Î±] {s : set Î±} {a : Î±} (h : is_least s a) : bdd_below s
theorem perfection_map.of (p : â„•) [fact (nat.prime p)] (R : Type uâ‚) [comm_semiring R] [char_p R p] : perfection_map p (perfection.coeff R p 0)
theorem category_theory.subobject_simple_iff_is_atom {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] {X : C} (Y : category_theory.subobject X) : category_theory.simple â†‘Y â†” is_atom Y
theorem interval_integral.integral_sub_integral_sub_linear_is_o_of_tendsto_ae_right {Î¹ : Type u_1} {E : Type u_3} [normed_group E] [complete_space E] [normed_space â„ E] {f : â„ â†’ E} {c : E} {lb lb' : filter â„} {lt : filter Î¹} {a b : â„} {u v : Î¹ â†’ â„} [interval_integral.FTC_filter b lb lb'] (hab : interval_integrable f measure_theory.measure_space.volume a b) (hmeas : strongly_measurable_at_filter f lb' measure_theory.measure_space.volume) (hf : filter.tendsto f (lb' âŠ“ measure_theory.measure_space.volume.ae) (nhds c)) (hu : filter.tendsto u lt lb) (hv : filter.tendsto v lt lb) : (Î» (t : Î¹), ((âˆ« (x : â„) in a..v t, f x) - âˆ« (x : â„) in a..u t, f x) - (v t - u t) â€¢ c) =o[lt] (v - u)
theorem canonically_ordered_comm_semiring.zero_lt_one {Î± : Type u} [canonically_ordered_comm_semiring Î±] [nontrivial Î±] : 0 < 1
theorem submodule.closed_of_finite_dimensional {ğ•œ : Type u} [nondiscrete_normed_field ğ•œ] {E : Type v} [normed_group E] [normed_space ğ•œ E] [complete_space ğ•œ] (s : submodule ğ•œ E) [finite_dimensional ğ•œ â†¥s] : is_closed â†‘s
theorem orthonormal.rotation_symm {V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) (Î¸ : real.angle) : (hb.rotation Î¸).symm = hb.rotation (-Î¸)
theorem euclidean_geometry.affine_span_of_orthocentric_system {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {s : set P} (ho : euclidean_geometry.orthocentric_system s) {p : fin 3 â†’ P} (hps : set.range p âŠ† s) (hpi : function.injective p) : affine_span â„ (set.range p) = affine_span â„ s
theorem sub_eq_zero_of_eq {G : Type u_2} [add_group G] {a b : G} : a = b â†’ a - b = 0
theorem orthonormal.orthonormal_of_forall_eq_or_eq_neg {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {Î¹ : Type u_4} {v w : Î¹ â†’ E} (hv : orthonormal ğ•œ v) (hw : âˆ€ (i : Î¹), w i = v i âˆ¨ w i = -v i) : orthonormal ğ•œ w
theorem real.sinh_bijective  : function.bijective real.sinh
theorem inner_product_space.is_self_adjoint.orthogonal_family_eigenspaces {ğ•œ : Type u_1} [is_R_or_C ğ•œ] {E : Type u_2} [inner_product_space ğ•œ E] {T : E â†’â‚—[ğ•œ] E} (hT : inner_product_space.is_self_adjoint T) : orthogonal_family ğ•œ (Î» (Î¼ : ğ•œ), (module.End.eigenspace T Î¼).subtypeâ‚—áµ¢)
theorem ne.ssubset_of_subset {Î± : Type u} [has_subset Î±] [has_ssubset Î±] [is_nonstrict_strict_order Î± has_subset.subset has_ssubset.ssubset] {a b : Î±} [is_antisymm Î± has_subset.subset] (hâ‚ : a â‰  b) (hâ‚‚ : a âŠ† b) : a âŠ‚ b
theorem zmod.euler_criterion (p : â„•) [fact (nat.prime p)] {a : zmod p} (ha : a â‰  0) : is_square a â†” a ^ (p / 2) = 1
theorem is_pi_system_pi {Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_3} [Î  (i : Î¹), measurable_space (Î± i)] : is_pi_system (set.univ.pi '' set.univ.pi (Î» (i : Î¹), {s : set (Î± i) | measurable_set s}))
theorem bdd_above_insert {Î³ : Type w} [semilattice_sup Î³] (a : Î³) {s : set Î³} : bdd_above (has_insert.insert a s) â†” bdd_above s
theorem finset.le_sum_card_inter {Î± : Type u_2} [decidable_eq Î±] {s : finset Î±} {B : finset (finset Î±)} {n : â„•} (h : âˆ€ (a : Î±), a âˆˆ s â†’ n â‰¤ (finset.filter (has_mem.mem a) B).card) : s.card * n â‰¤ B.sum (Î» (t : finset Î±), (s âˆ© t).card)
theorem strict_mono_on.continuous_at_right_of_image_mem_nhds_within {Î± : Type u_1} {Î² : Type u_2} [linear_order Î±] [topological_space Î±] [order_topology Î±] [linear_order Î²] [topological_space Î²] [order_topology Î²] [densely_ordered Î²] {f : Î± â†’ Î²} {s : set Î±} {a : Î±} (h_mono : strict_mono_on f s) (hs : s âˆˆ nhds_within a (set.Ici a)) (hfs : f '' s âˆˆ nhds_within (f a) (set.Ici (f a))) : continuous_within_at f (set.Ici a) a
theorem euclidean_geometry.reflection_orthogonal_vadd {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace â„ P} [nonempty â†¥s] [complete_space â†¥(s.direction)] {p : P} (hp : p âˆˆ s) {v : V} (hv : v âˆˆ (s.direction)á—®) : â‡‘(euclidean_geometry.reflection s) (v +áµ¥ p) = -v +áµ¥ p
theorem ring_hom.ker_is_maximal_of_surjective {R : Type u_1} {K : Type u_2} [ring R] [field K] (f : R â†’+* K) (hf : function.surjective â‡‘f) : f.ker.is_maximal
theorem linear_map.finite_dimensional_of_surjective {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {Vâ‚‚ : Type v'} [add_comm_group Vâ‚‚] [module K Vâ‚‚] [h : finite_dimensional K V] (f : V â†’â‚—[K] Vâ‚‚) (hf : f.range = âŠ¤) : finite_dimensional K Vâ‚‚
theorem analytic_on.iterated_deriv {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {f : ğ•œ â†’ F} {s : set ğ•œ} [complete_space F] (h : analytic_on ğ•œ f s) (n : â„•) : analytic_on ğ•œ (deriv^[n] f) s
theorem normed_group_hom.mk_normed_group_hom_norm_le {Vâ‚ : Type u_2} {Vâ‚‚ : Type u_3} [semi_normed_group Vâ‚] [semi_normed_group Vâ‚‚] (f : Vâ‚ â†’+ Vâ‚‚) {C : â„} (hC : 0 â‰¤ C) (h : âˆ€ (x : Vâ‚), âˆ¥â‡‘f xâˆ¥ â‰¤ C * âˆ¥xâˆ¥) : âˆ¥f.mk_normed_group_hom C hâˆ¥ â‰¤ C
theorem seminorm.absorbent_ball_zero {ğ•œ : Type u_3} {E : Type u_4} [normed_field ğ•œ] [add_comm_group E] [module ğ•œ E] (p : seminorm ğ•œ E) {r : â„} (hr : 0 < r) : absorbent ğ•œ (p.ball 0 r)
theorem neg_one_pow_two {R : Type uâ‚} [monoid R] [has_distrib_neg R] : (-1) ^ 2 = 1
theorem inner_eq_norm_mul_iff_of_norm_one {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {x y : E} (hx : âˆ¥xâˆ¥ = 1) (hy : âˆ¥yâˆ¥ = 1) : has_inner.inner x y = 1 â†” x = y
theorem edist_mem_uniformity {Î± : Type u} [pseudo_emetric_space Î±] {Îµ : ennreal} (Îµ0 : 0 < Îµ) : {p : Î± Ã— Î± | has_edist.edist p.fst p.snd < Îµ} âˆˆ uniformity Î±
theorem has_le.le.trans_lt' {Î± : Type u} [preorder Î±] {a b c : Î±} : b â‰¤ c â†’ a < b â†’ a < c
theorem orthonormal.oangle_smul_right_of_pos {V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) (x y : V) {r : â„} (hr : 0 < r) : hb.oangle x (r â€¢ y) = hb.oangle x y
theorem add_submonoid.localization_map.lift_left_inverse {M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {N : Type u_2} [add_comm_monoid N] {P : Type u_3} [add_comm_monoid P] (f : S.localization_map N) {k : S.localization_map P} (z : N) : â‡‘(k.lift _) (â‡‘(f.lift _) z) = z
theorem probability_theory.strong_law_aux7 {Î© : Type u_1} [measure_theory.measure_space Î©] [measure_theory.is_probability_measure measure_theory.measure_space.volume] (X : â„• â†’ Î© â†’ â„) (hint : measure_theory.integrable (X 0) measure_theory.measure_space.volume) (hindep : pairwise (Î» (i j : â„•), probability_theory.indep_fun (X i) (X j) measure_theory.measure_space.volume)) (hident : âˆ€ (i : â„•), probability_theory.ident_distrib (X i) (X 0) measure_theory.measure_space.volume measure_theory.measure_space.volume) (hnonneg : âˆ€ (i : â„•) (Ï‰ : Î©), 0 â‰¤ X i Ï‰) : âˆ€áµ (Ï‰ : Î©), filter.tendsto (Î» (n : â„•), (finset.range n).sum (Î» (i : â„•), X i Ï‰) / â†‘n) filter.at_top (nhds (âˆ« (a : Î©), X 0 a))
theorem measure_theory.adapted.prog_measurable_of_continuous {Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_3} {m : measurable_space Î±} [topological_space Î²] [preorder Î¹] {u : Î¹ â†’ Î± â†’ Î²} {f : measure_theory.filtration Î¹ m} [topological_space Î¹] [topological_space.metrizable_space Î¹] [measurable_space Î¹] [topological_space.second_countable_topology Î¹] [opens_measurable_space Î¹] [topological_space.metrizable_space Î²] (h : measure_theory.adapted f u) (hu_cont : âˆ€ (x : Î±), continuous (Î» (i : Î¹), u i x)) : measure_theory.prog_measurable f u
theorem euclidean_geometry.orthogonal_projection_mem_orthogonal {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] (s : affine_subspace â„ P) [nonempty â†¥s] [complete_space â†¥(s.direction)] (p : P) : â†‘(â‡‘(euclidean_geometry.orthogonal_projection s) p) âˆˆ affine_subspace.mk' p (s.direction)á—®
theorem local_homeomorph.is_O_with_congr {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] {E : Type u_3} [has_norm E] {F : Type u_4} [has_norm F] (e : local_homeomorph Î± Î²) {b : Î²} (hb : b âˆˆ e.to_local_equiv.target) {f : Î² â†’ E} {g : Î² â†’ F} {C : â„} : asymptotics.is_O_with C (nhds b) f g â†” asymptotics.is_O_with C (nhds (â‡‘(e.symm) b)) (f âˆ˜ â‡‘e) (g âˆ˜ â‡‘e)
theorem measure_theory.simple_func.integral_eq_sum_of_subset {Î± : Type u_1} {F : Type u_3} [normed_group F] [normed_space â„ F] {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [decidable_pred (Î» (x : F), x â‰  0)] {f : measure_theory.simple_func Î± F} {s : finset F} (hs : finset.filter (Î» (x : F), x â‰  0) f.range âŠ† s) : measure_theory.simple_func.integral Î¼ f = s.sum (Î» (x : F), (â‡‘Î¼ (â‡‘f â»Â¹' {x})).to_real â€¢ x)
theorem same_ray.nonneg_smul_right {R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {x y : M} {r : R} (h : same_ray R x y) (hr : 0 â‰¤ r) : same_ray R x (r â€¢ y)
theorem add_subgroup.closure_induction'' {G : Type u_1} [add_group G] {k : set G} {p : G â†’ Prop} {x : G} (h : x âˆˆ add_subgroup.closure k) (Hk : âˆ€ (x : G), x âˆˆ k â†’ p x) (Hk_inv : âˆ€ (x : G), x âˆˆ k â†’ p (-x)) (H1 : p 0) (Hmul : âˆ€ (x y : G), p x â†’ p y â†’ p (x + y)) : p x
theorem intermediate_field.multiset_sum_mem {K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) (m : multiset L) : (âˆ€ (a : L), a âˆˆ m â†’ a âˆˆ S) â†’ m.sum âˆˆ S
theorem convex_on_iff_slope_mono_adjacent {ğ•œ : Type u_1} [linear_ordered_field ğ•œ] {s : set ğ•œ} {f : ğ•œ â†’ ğ•œ} : convex_on ğ•œ s f â†” convex ğ•œ s âˆ§ âˆ€ â¦ƒx y z : ğ•œâ¦„, x âˆˆ s â†’ z âˆˆ s â†’ x < y â†’ y < z â†’ (f y - f x) / (y - x) â‰¤ (f z - f y) / (z - y)
theorem orthonormal.oangle_rotation_self_right {V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) {x : V} (hx : x â‰  0) (Î¸ : real.angle) : hb.oangle x (â‡‘(hb.rotation Î¸) x) = Î¸
theorem disjoint_or_subset_of_clopen {Î± : Type u} [topological_space Î±] {s t : set Î±} (hs : is_preconnected s) (ht : is_clopen t) : disjoint s t âˆ¨ s âŠ† t
theorem has_ftaylor_series_up_to_on.comp_continuous_linear_map {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {G : Type u_4} [normed_group G] [normed_space ğ•œ G] {s : set E} {f : E â†’ F} {n : with_top â„•} {p : E â†’ formal_multilinear_series ğ•œ E F} (hf : has_ftaylor_series_up_to_on n f p s) (g : G â†’L[ğ•œ] E) : has_ftaylor_series_up_to_on n (f âˆ˜ â‡‘g) (Î» (x : G) (k : â„•), (p (â‡‘g x) k).comp_continuous_linear_map (Î» (_x : fin k), g)) (â‡‘g â»Â¹' s)
theorem localization_algebra_injective {R : Type u_1} [comm_ring R] {M : submonoid R} {S : Type u_2} [comm_ring S] [algebra R S] (Râ‚˜ : Type u_4) (Sâ‚˜ : Type u_5) [comm_ring Râ‚˜] [comm_ring Sâ‚˜] [algebra R Râ‚˜] [is_localization M Râ‚˜] [algebra S Sâ‚˜] [is_localization (algebra.algebra_map_submonoid S M) Sâ‚˜] (hRS : function.injective â‡‘(algebra_map R S)) (hM : algebra.algebra_map_submonoid S M â‰¤ non_zero_divisors S) : function.injective â‡‘(algebra_map Râ‚˜ Sâ‚˜)
theorem measure_theory.is_add_fundamental_domain.vadd_invariant_measure_map {G : Type u_1} [add_group G] [measurable_space G] [topological_space G] [topological_add_group G] [borel_space G] {Î¼ : measure_theory.measure G} {Î“ : add_subgroup G} {ğ“• : set G} (hğ“• : measure_theory.is_add_fundamental_domain â†¥(Î“.opposite) ğ“• Î¼) [encodable â†¥Î“] [measurable_space (G â§¸ Î“)] [borel_space (G â§¸ Î“)] [Î¼.is_add_left_invariant] [Î¼.is_add_right_invariant] : measure_theory.vadd_invariant_measure G (G â§¸ Î“) (measure_theory.measure.map quotient_add_group.mk (Î¼.restrict ğ“•))
theorem submodule.torsion'_is_torsion' {R : Type u_1} {M : Type u_2} [comm_semiring R] [add_comm_monoid M] [module R M] (S : Type u_3) [comm_monoid S] [distrib_mul_action S M] [smul_comm_class S R M] : module.is_torsion' â†¥(submodule.torsion' R M S) S
theorem is_local_max_on.has_fderiv_within_at_eq_zero {E : Type u} [normed_group E] [normed_space â„ E] {f : E â†’ â„} {a : E} {f' : E â†’L[â„] â„} {s : set E} (h : is_local_max_on f s a) (hf : has_fderiv_within_at f f' s a) {y : E} (hy : y âˆˆ pos_tangent_cone_at s a) (hy' : -y âˆˆ pos_tangent_cone_at s a) : â‡‘f' y = 0
theorem finset.prod_partition {Î² : Type u} {Î± : Type v} {s : finset Î±} {f : Î± â†’ Î²} [comm_monoid Î²] (R : setoid Î±) [decidable_rel setoid.r] : s.prod (Î» (x : Î±), f x) = (finset.image quotient.mk s).prod (Î» (xbar : quotient R), (finset.filter (Î» (y : Î±), âŸ¦yâŸ§ = xbar) s).prod (Î» (y : Î±), f y))
theorem mul_hom.srange_top_of_surjective {M : Type u_1} [has_mul M] {N : Type u_2} [has_mul N] (f : M â†’â‚™* N) (hf : function.surjective â‡‘f) : f.srange = âŠ¤
theorem measure_theory.integral_image_eq_integral_abs_det_fderiv_smul {E : Type u_1} {F : Type u_2} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] [normed_group F] [normed_space â„ F] {s : set E} {f : E â†’ E} {f' : E â†’ (E â†’L[â„] E)} [measurable_space E] [borel_space E] (Î¼ : measure_theory.measure E) [Î¼.is_add_haar_measure] [complete_space F] (hs : measurable_set s) (hf' : âˆ€ (x : E), x âˆˆ s â†’ has_fderiv_within_at f (f' x) s x) (hf : set.inj_on f s) (g : E â†’ F) : âˆ« (x : E) in f '' s, g x âˆ‚Î¼ = âˆ« (x : E) in s, |(f' x).det| â€¢ g (f x) âˆ‚Î¼
theorem exists_deriv_eq_zero (f : â„ â†’ â„) {a b : â„} (hab : a < b) (hfc : continuous_on f (set.Icc a b)) (hfI : f a = f b) : âˆƒ (c : â„) (H : c âˆˆ set.Ioo a b), deriv f c = 0
theorem has_binary_products_of_terminal_and_pullbacks (C : Type u) [category_theory.category C] [category_theory.limits.has_terminal C] [category_theory.limits.has_pullbacks C] : category_theory.limits.has_binary_products C
theorem polynomial.cyclotomic'_ne_zero (n : â„•) (R : Type u_1) [comm_ring R] [is_domain R] : polynomial.cyclotomic' n R â‰  0
theorem bdd_above.inter_of_left {Î± : Type u} [preorder Î±] {s t : set Î±} (h : bdd_above s) : bdd_above (s âˆ© t)
theorem nhds_le_uniformity {Î± : Type u_1} [uniform_space Î±] (x : Î±) : nhds (x, x) â‰¤ uniformity Î±
theorem is_localization.map_map {R : Type u_1} [comm_semiring R] {M : submonoid R} {S : Type u_2} [comm_semiring S] [algebra R S] {P : Type u_3} [comm_semiring P] [is_localization M S] {g : R â†’+* P} {T : submonoid P} {Q : Type u_4} [comm_semiring Q] (hy : M â‰¤ submonoid.comap â†‘g T) [algebra P Q] [is_localization T Q] {A : Type u_5} [comm_semiring A] {U : submonoid A} {W : Type u_6} [comm_semiring W] [algebra A W] [is_localization U W] {l : P â†’+* A} (hl : T â‰¤ submonoid.comap â†‘l U) (x : S) : â‡‘(is_localization.map W l hl) (â‡‘(is_localization.map Q g hy) x) = â‡‘(is_localization.map W (l.comp g) _) x
theorem vitali_family.measure_lim_ratio_meas_top {Î± : Type u_1} [metric_space Î±] {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (v : vitali_family Î¼) [sigma_compact_space Î±] [borel_space Î±] [measure_theory.is_locally_finite_measure Î¼] {Ï : measure_theory.measure Î±} [measure_theory.is_locally_finite_measure Ï] (hÏ : Ï.absolutely_continuous Î¼) : â‡‘Î¼ {x : Î± | v.lim_ratio_meas hÏ x = âŠ¤} = 0
theorem set.mem_finset_prod {Î± : Type u_2} {Î¹ : Type u_5} [comm_monoid Î±] (t : finset Î¹) (f : Î¹ â†’ set Î±) (a : Î±) : a âˆˆ t.prod (Î» (i : Î¹), f i) â†” âˆƒ (g : Î¹ â†’ Î±) (hg : âˆ€ {i : Î¹}, i âˆˆ t â†’ g i âˆˆ f i), t.prod (Î» (i : Î¹), g i) = a
theorem spectrum.exp_mem_exp {ğ•œ : Type u_1} {A : Type u_2} [is_R_or_C ğ•œ] [normed_ring A] [normed_algebra ğ•œ A] [complete_space A] (a : A) {z : ğ•œ} (hz : z âˆˆ spectrum ğ•œ a) : exp ğ•œ z âˆˆ spectrum ğ•œ (exp ğ•œ a)
theorem polynomial.is_eisenstein_at.irreducible {R : Type u} [comm_ring R] [is_domain R] {ğ“Ÿ : ideal R} {f : polynomial R} (hf : f.is_eisenstein_at ğ“Ÿ) (hprime : ğ“Ÿ.is_prime) (hu : f.is_primitive) (hfd0 : 0 < f.nat_degree) : irreducible f
theorem pgame.numeric_nat (n : â„•) : â†‘n.numeric
theorem add_submonoid.localization_map.add_neg {M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {N : Type u_2} [add_comm_monoid N] {f : M â†’+ N} (h : âˆ€ (y : â†¥S), is_add_unit (â‡‘f â†‘y)) {xâ‚ xâ‚‚ : M} {yâ‚ yâ‚‚ : â†¥S} : â‡‘f xâ‚ + â†‘-â‡‘(is_add_unit.lift_right (f.restrict S) h) yâ‚ = â‡‘f xâ‚‚ + â†‘-â‡‘(is_add_unit.lift_right (f.restrict S) h) yâ‚‚ â†” â‡‘f (xâ‚ + â†‘yâ‚‚) = â‡‘f (xâ‚‚ + â†‘yâ‚)
theorem measure_theory.measure.add_haar_affine_subspace {E : Type u_1} [normed_group E] [normed_space â„ E] [measurable_space E] [borel_space E] [finite_dimensional â„ E] (Î¼ : measure_theory.measure E) [Î¼.is_add_haar_measure] (s : affine_subspace â„ E) (hs : s â‰  âŠ¤) : â‡‘Î¼ â†‘s = 0
theorem has_ftaylor_series_up_to_on_succ_iff_left {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {s : set E} {f : E â†’ F} {p : E â†’ formal_multilinear_series ğ•œ E F} {n : â„•} : has_ftaylor_series_up_to_on (â†‘n + 1) f p s â†” has_ftaylor_series_up_to_on â†‘n f p s âˆ§ (âˆ€ (x : E), x âˆˆ s â†’ has_fderiv_within_at (Î» (y : E), p y n) (p x n.succ).curry_left s x) âˆ§ continuous_on (Î» (x : E), p x (n + 1)) s
theorem exp_neg_inv_glue.cont_diff {n : with_top â„•} : cont_diff â„ n exp_neg_inv_glue
theorem ideal.eq_jacobson_iff_not_mem {R : Type u} [ring R] {I : ideal R} : I.jacobson = I â†” âˆ€ (x : R), x âˆ‰ I â†’ (âˆƒ (M : ideal R), (I â‰¤ M âˆ§ M.is_maximal) âˆ§ x âˆ‰ M)
theorem orientation.oangle_eq_iff_eq_norm_div_norm_smul_rotation_of_ne_zero {V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) {x y : V} (hx : x â‰  0) (hy : y â‰  0) (Î¸ : real.angle) : o.oangle x y = Î¸ â†” y = (âˆ¥yâˆ¥ / âˆ¥xâˆ¥) â€¢ â‡‘(o.rotation Î¸) x
theorem setoid.ker_iff_mem_preimage {Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} {x y : Î±} : (setoid.ker f).rel x y â†” x âˆˆ f â»Â¹' {f y}
theorem padic_val_int.one {p : â„•} : padic_val_int p 1 = 0
theorem algebra.power_basis.norm_gen_eq_prod_roots {S : Type u_2} [comm_ring S] {K : Type u_4} {F : Type u_6} [field K] [field F] [algebra K F] [algebra K S] (pb : power_basis K S) (hf : polynomial.splits (algebra_map K F) (minpoly K pb.gen)) : â‡‘(algebra_map K F) (â‡‘(algebra.norm K) pb.gen) = (polynomial.map (algebra_map K F) (minpoly K pb.gen)).roots.prod
theorem ordinal.sub_nonempty {a b : ordinal} : {o : ordinal | a â‰¤ b + o}.nonempty
theorem smul_closed_unit_ball_of_nonneg {E : Type u_2} [normed_group E] [normed_space â„ E] {r : â„} (hr : 0 â‰¤ r) : r â€¢ metric.closed_ball 0 1 = metric.closed_ball 0 r
theorem probability_theory.strong_law_ae {Î© : Type u_1} [measure_theory.measure_space Î©] [measure_theory.is_probability_measure measure_theory.measure_space.volume] (X : â„• â†’ Î© â†’ â„) (hint : measure_theory.integrable (X 0) measure_theory.measure_space.volume) (hindep : pairwise (Î» (i j : â„•), probability_theory.indep_fun (X i) (X j) measure_theory.measure_space.volume)) (hident : âˆ€ (i : â„•), probability_theory.ident_distrib (X i) (X 0) measure_theory.measure_space.volume measure_theory.measure_space.volume) : âˆ€áµ (Ï‰ : Î©), filter.tendsto (Î» (n : â„•), (finset.range n).sum (Î» (i : â„•), X i Ï‰) / â†‘n) filter.at_top (nhds (âˆ« (a : Î©), X 0 a))
theorem euclidean_geometry.orthogonal_projection_vadd_smul_vsub_orthogonal_projection {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace â„ P} [nonempty â†¥s] [complete_space â†¥(s.direction)] {p1 : P} (p2 : P) (r : â„) (hp : p1 âˆˆ s) : â‡‘(euclidean_geometry.orthogonal_projection s) (r â€¢ (p2 -áµ¥ â†‘(â‡‘(euclidean_geometry.orthogonal_projection s) p2)) +áµ¥ p1) = âŸ¨p1, hpâŸ©
theorem measure_theory.measure.restrict_map {Î± : Type u_1} {Î² : Type u_2} {m0 : measurable_space Î±} [measurable_space Î²] {Î¼ : measure_theory.measure Î±} {f : Î± â†’ Î²} (hf : measurable f) {s : set Î²} (hs : measurable_set s) : (measure_theory.measure.map f Î¼).restrict s = measure_theory.measure.map f (Î¼.restrict (f â»Â¹' s))
theorem affine_map.coe_id (k : Type u_1) {V1 : Type u_2} (P1 : Type u_3) [ring k] [add_comm_group V1] [module k V1] [add_torsor V1 P1] : â‡‘(affine_map.id k P1) = id
theorem simple_graph.max_degree_le_of_forall_degree_le {V : Type u} (G : simple_graph V) [fintype V] [decidable_rel G.adj] (k : â„•) (h : âˆ€ (v : V), G.degree v â‰¤ k) : G.max_degree â‰¤ k
theorem local_homeomorph.eq_on_source.symm' {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] {e e' : local_homeomorph Î± Î²} (h : e â‰ˆ e') : e.symm â‰ˆ e'.symm
theorem finite_dimensional_sup {K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (E1 E2 : intermediate_field K L) (h1 : finite_dimensional K â†¥E1) (h2 : finite_dimensional K â†¥E2) : finite_dimensional K â†¥(E1 âŠ” E2)
theorem inner_left_of_mem_orthogonal_singleton {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] (u : E) {v : E} (hv : v âˆˆ (submodule.span ğ•œ {u})á—®) : has_inner.inner v u = 0
theorem polynomial.cyclotomic_two (R : Type u_1) [ring R] : polynomial.cyclotomic 2 R = polynomial.X + 1
theorem power_series.order_mul {R : Type u_1} [comm_ring R] [is_domain R] (Ï† Ïˆ : power_series R) : (Ï† * Ïˆ).order = Ï†.order + Ïˆ.order
theorem left.mul_lt_one_of_lt_of_le {Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a b : Î±} (ha : a < 1) (hb : b â‰¤ 1) : a * b < 1
theorem neg_concave_on_iff {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [ordered_semiring ğ•œ] [add_comm_monoid E] [ordered_add_comm_group Î²] [has_scalar ğ•œ E] [module ğ•œ Î²] {s : set E} {f : E â†’ Î²} : concave_on ğ•œ s (-f) â†” convex_on ğ•œ s f
theorem add_torsion_eq_add_torsion_submonoid (G : Type u_1) [add_comm_group G] : add_comm_monoid.add_torsion G = (add_torsion G).to_add_submonoid
theorem uniform_space.completion.coe_isometry {Î± : Type u} [pseudo_metric_space Î±] : isometry coe
theorem continuous.measurable_embedding {Î³ : Type u_3} [tÎ³ : topological_space Î³] [polish_space Î³] [measurable_space Î³] [borel_space Î³] {Î² : Type u_4} [tÎ² : topological_space Î²] [t2_space Î²] [measurable_space Î²] [borel_space Î²] {f : Î³ â†’ Î²} (f_cont : continuous f) (f_inj : function.injective f) : measurable_embedding f
theorem is_localization.ext {R : Type u_1} [comm_semiring R] (M : submonoid R) {S : Type u_2} [comm_semiring S] [algebra R S] {P : Type u_3} [comm_semiring P] [is_localization M S] (j k : S â†’ P) (hj1 : j 1 = 1) (hk1 : k 1 = 1) (hjm : âˆ€ (a b : S), j (a * b) = j a * j b) (hkm : âˆ€ (a b : S), k (a * b) = k a * k b) (h : âˆ€ (a : R), j (â‡‘(algebra_map R S) a) = k (â‡‘(algebra_map R S) a)) : j = k
theorem is_preconnected.sUnion_directed {Î± : Type u} [topological_space Î±] {S : set (set Î±)} (K : directed_on has_subset.subset S) (H : âˆ€ (s : set Î±), s âˆˆ S â†’ is_preconnected s) : is_preconnected (â‹ƒâ‚€S)
theorem well_founded_lt_exact_sequence {Î± : Type u_1} [lattice Î±] [is_modular_lattice Î±] {Î² : Type u_2} {Î³ : Type u_3} [partial_order Î²] [preorder Î³] (hâ‚ : well_founded has_lt.lt) (hâ‚‚ : well_founded has_lt.lt) (K : Î±) (fâ‚ : Î² â†’ Î±) (fâ‚‚ : Î± â†’ Î²) (gâ‚ : Î³ â†’ Î±) (gâ‚‚ : Î± â†’ Î³) (gci : galois_coinsertion fâ‚ fâ‚‚) (gi : galois_insertion gâ‚‚ gâ‚) (hf : âˆ€ (a : Î±), fâ‚ (fâ‚‚ a) = a âŠ“ K) (hg : âˆ€ (a : Î±), gâ‚ (gâ‚‚ a) = a âŠ” K) : well_founded has_lt.lt
theorem is_min.pred_eq {Î± : Type u_1} [partial_order Î±] [pred_order Î±] {a : Î±} : is_min a â†’ order.pred a = a
theorem polynomial.degree_multiset_prod_le {R : Type u} [comm_semiring R] (t : multiset (polynomial R)) : t.prod.degree â‰¤ (multiset.map polynomial.degree t).sum
theorem add_con.ext_iff {M : Type u_1} [has_add M] {c d : add_con M} : (âˆ€ (x y : M), â‡‘c x y â†” â‡‘d x y) â†” c = d
theorem dim_mul_dim (F : Type u) (K A : Type v) [field F] [field K] [add_comm_group A] [algebra F K] [module K A] [module F A] [is_scalar_tower F K A] : module.rank F K * module.rank K A = module.rank F A
theorem finset.prod_range_induction {M : Type u_1} [comm_monoid M] (f s : â„• â†’ M) (h0 : s 0 = 1) (h : âˆ€ (n : â„•), s (n + 1) = s n * f n) (n : â„•) : (finset.range n).prod (Î» (k : â„•), f k) = s n
theorem ext_chart_preimage_mem_nhds_within {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] (I : model_with_corners ğ•œ E H) {M : Type u_4} [topological_space M] [charted_space H M] (x : M) {s t : set M} (ht : t âˆˆ nhds_within x s) : â‡‘((ext_chart_at I x).symm) â»Â¹' t âˆˆ nhds_within (â‡‘(ext_chart_at I x) x) (â‡‘((ext_chart_at I x).symm) â»Â¹' s âˆ© set.range â‡‘I)
theorem free_group.reduce.sound {Î± : Type u} {Lâ‚ Lâ‚‚ : list (Î± Ã— bool)} [decidable_eq Î±] (H : free_group.mk Lâ‚ = free_group.mk Lâ‚‚) : free_group.reduce Lâ‚ = free_group.reduce Lâ‚‚
theorem subtype.edist_eq {Î± : Type u} [pseudo_emetric_space Î±] {p : Î± â†’ Prop} (x y : subtype p) : has_edist.edist x y = has_edist.edist â†‘x â†‘y
theorem closure_Ioc {Î± : Type u} [topological_space Î±] [linear_order Î±] [order_topology Î±] [densely_ordered Î±] {a b : Î±} (hab : a â‰  b) : closure (set.Ioc a b) = set.Icc a b
theorem fin.find_eq_none_iff {n : â„•} {p : fin n â†’ Prop} [decidable_pred p] : fin.find p = option.none â†” âˆ€ (i : fin n), Â¬p i
theorem ideal.exist_integer_multiples_not_mem {A : Type u_2} {K : Type u_3} [comm_ring A] [field K] [is_domain A] [is_dedekind_domain A] [algebra A K] [is_fraction_ring A K] {J : ideal A} (hJ : J â‰  âŠ¤) {Î¹ : Type u_1} (s : finset Î¹) (f : Î¹ â†’ K) {j : Î¹} (hjs : j âˆˆ s) (hjf : f j â‰  0) : âˆƒ (a : K), (âˆ€ (i : Î¹), i âˆˆ s â†’ is_localization.is_integer A (a * f i)) âˆ§ âˆƒ (i : Î¹) (H : i âˆˆ s), a * f i âˆ‰ â†‘J
theorem zero_lt.right.one_lt_mul_of_le_of_lt {Î± : Type u} {a b : Î±} [mul_one_class Î±] [has_zero Î±] [preorder Î±] [zero_lt.mul_pos_mono Î±] (ha : 1 â‰¤ a) (hb : 1 < b) (b0 : 0 < b) : 1 < a * b
theorem orientation.oangle_neg_self_right {V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) {x : V} (hx : x â‰  0) : o.oangle x (-x) = â†‘real.pi
theorem cont_diff_at.cont_mdiff_at {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {n : with_top â„•} {f : E â†’ E'} {x : E} : cont_diff_at ğ•œ n f x â†’ cont_mdiff_at (model_with_corners_self ğ•œ E) (model_with_corners_self ğ•œ E') n f x
theorem generalized_continued_fraction.squash_gcf_eq_self_of_terminated {K : Type u_1} {n : â„•} {g : generalized_continued_fraction K} [division_ring K] (terminated_at_n : g.terminated_at n) : g.squash_gcf n = g
theorem convolution_tendsto_right {G : Type u_2} {E' : Type u_4} [normed_group E'] {g : G â†’ E'} [measurable_space G] {Î¼ : measure_theory.measure G} [semi_normed_group G] [borel_space G] [topological_space.second_countable_topology G] [Î¼.is_add_left_invariant] [measure_theory.sigma_finite Î¼] [normed_space â„ E'] [complete_space E'] {Î¹ : Type u_1} {l : filter Î¹} {Ï† : Î¹ â†’ G â†’ â„} (hnÏ† : âˆ€ (i : Î¹) (x : G), 0 â‰¤ Ï† i x) (hiÏ† : âˆ€ (i : Î¹), âˆ« (s : G), Ï† i s âˆ‚Î¼ = 1) (hÏ† : filter.tendsto (Î» (n : Î¹), function.support (Ï† n)) l (nhds 0).small_sets) (hmg : measure_theory.ae_strongly_measurable g Î¼) {xâ‚€ : G} (hcg : continuous_at g xâ‚€) : filter.tendsto (Î» (i : Î¹), convolution (Ï† i) g (continuous_linear_map.lsmul â„ â„) Î¼ xâ‚€) l (nhds (g xâ‚€))
theorem finset.centroid_singleton (k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] {Î¹ : Type u_4} (p : Î¹ â†’ P) (i : Î¹) : finset.centroid k {i} p = p i
theorem finset.le_prod_of_submultiplicative {Î¹ : Type u_1} {M : Type u_4} {N : Type u_5} [comm_monoid M] [ordered_comm_monoid N] (f : M â†’ N) (h_one : f 1 = 1) (h_mul : âˆ€ (x y : M), f (x * y) â‰¤ f x * f y) (s : finset Î¹) (g : Î¹ â†’ M) : f (s.prod (Î» (i : Î¹), g i)) â‰¤ s.prod (Î» (i : Î¹), f (g i))
theorem linear_equiv.closed_embedding_of_injective {ğ•œ : Type u} [nondiscrete_normed_field ğ•œ] {E : Type v} [normed_group E] [normed_space ğ•œ E] {F : Type w} [normed_group F] [normed_space ğ•œ F] [complete_space ğ•œ] {f : E â†’â‚—[ğ•œ] F} (hf : f.ker = âŠ¥) [finite_dimensional ğ•œ E] : closed_embedding â‡‘f
theorem monotone.pairwise_disjoint_on_Ioc_succ {Î± : Type u_1} {Î² : Type u_2} [linear_order Î±] [succ_order Î±] [preorder Î²] {f : Î± â†’ Î²} (hf : monotone f) : pairwise (disjoint on Î» (n : Î±), set.Ioc (f n) (f (order.succ n)))
theorem fin.pred_above_succ_above {n : â„•} (p i : fin n) : p.pred_above (â‡‘((â‡‘fin.cast_succ p).succ_above) i) = i
theorem injective_iff_map_eq_zero' {F : Type u_8} {G : Type u_1} {H : Type u_2} [add_group G] [add_zero_class H] [add_monoid_hom_class F G H] (f : F) : function.injective â‡‘f â†” âˆ€ (a : G), â‡‘f a = 0 â†” a = 0
theorem setoid.eqv_class_mem {Î± : Type u_1} {c : set (set Î±)} (H : âˆ€ (a : Î±), âˆƒ! (b : set Î±) (H : b âˆˆ c), a âˆˆ b) {y : Î±} : {x : Î± | (setoid.mk_classes c H).rel x y} âˆˆ c
theorem topological_fiber_bundle_core.local_triv_as_local_equiv_trans {Î¹ : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core Î¹ B F) (i j : Î¹) : (Z.local_triv_as_local_equiv i).symm.trans (Z.local_triv_as_local_equiv j) â‰ˆ (Z.triv_change i j).to_local_equiv
theorem phragmen_lindelof.right_half_plane_of_bounded_on_real {E : Type u_1} [normed_group E] [normed_space â„‚ E] {C : â„} {f : â„‚ â†’ E} {z : â„‚} (hd : diff_cont_on_cl â„‚ f {z : â„‚ | 0 < z.re}) (hexp : âˆƒ (c : â„) (H : c < 2) (B : â„), f =O[filter.comap complex.abs filter.at_top âŠ“ filter.principal {z : â„‚ | 0 < z.re}] Î» (z : â„‚), real.exp (B * complex.abs z ^ c)) (hre : filter.is_bounded_under has_le.le filter.at_top (Î» (x : â„), âˆ¥f â†‘xâˆ¥)) (him : âˆ€ (x : â„), âˆ¥f (â†‘x * complex.I)âˆ¥ â‰¤ C) (hz : 0 â‰¤ z.re) : âˆ¥f zâˆ¥ â‰¤ C
theorem norm_combo_lt_of_ne {E : Type u_2} [normed_group E] [normed_space â„ E] [strict_convex_space â„ E] {x y : E} {a b r : â„} (hx : âˆ¥xâˆ¥ â‰¤ r) (hy : âˆ¥yâˆ¥ â‰¤ r) (hne : x â‰  y) (ha : 0 < a) (hb : 0 < b) (hab : a + b = 1) : âˆ¥a â€¢ x + b â€¢ yâˆ¥ < r
theorem submonoid.mem_closure_singleton {M : Type u_1} [monoid M] {x y : M} : y âˆˆ submonoid.closure {x} â†” âˆƒ (n : â„•), x ^ n = y
theorem metric.diam_nonneg {Î± : Type u} [pseudo_metric_space Î±] {s : set Î±} : 0 â‰¤ metric.diam s
theorem matrix.det_permutation {n : Type u_2} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] (Ïƒ : equiv.perm n) : (equiv.to_pequiv Ïƒ).to_matrix.det = â†‘(â‡‘equiv.perm.sign Ïƒ)
theorem add_subgroup.is_open_of_zero_mem_interior {G : Type u_1} [add_group G] [topological_space G] [topological_add_group G] {H : add_subgroup G} (h_1_int : 0 âˆˆ interior â†‘H) : is_open â†‘H
theorem bornology.is_bounded.bounded_space_coe {Î± : Type u_1} [bornology Î±] {s : set Î±} : bornology.is_bounded s â†’ bounded_space â†¥s
theorem affine_span_insert_eq_affine_span (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {p : P} {ps : set P} (h : p âˆˆ affine_span k ps) : affine_span k (has_insert.insert p ps) = affine_span k ps
theorem star_div {R : Type u} [comm_group R] [star_semigroup R] (x y : R) : has_star.star (x / y) = has_star.star x / has_star.star y
theorem same_ray_smul_left_iff_of_ne {R : Type u_1} [linear_ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] [no_zero_smul_divisors R M] {v : M} (hv : v â‰  0) {r : R} (hr : r â‰  0) : same_ray R (r â€¢ v) v â†” 0 < r
theorem is_smul_regular.zero {R : Type u_1} {M : Type u_3} [monoid_with_zero R] [has_zero M] [mul_action_with_zero R M] [sM : subsingleton M] : is_smul_regular M 0
theorem polynomial.is_separable_contraction.dvd_degree' {F : Type} [comm_semiring F] {q : â„•} {f g : polynomial F} (hf : polynomial.is_separable_contraction q f g) : âˆƒ (m : â„•), g.nat_degree * q ^ m = f.nat_degree
theorem category_theory.grothendieck_topology.is_closed_iff_close_eq_self {C : Type u} [category_theory.category C] (Jâ‚ : category_theory.grothendieck_topology C) {X : C} (S : category_theory.sieve X) : Jâ‚.is_closed S â†” Jâ‚.close S = S
theorem set.image_subset_iff {Î± : Type u} {Î² : Type v} {s : set Î±} {t : set Î²} {f : Î± â†’ Î²} : f '' s âŠ† t â†” s âŠ† f â»Â¹' t
theorem category_theory.abelian.exact_iff_image_eq_kernel {C : Type uâ‚} [category_theory.category C] [category_theory.abelian C] {X Y Z : C} (f : X âŸ¶ Y) (g : Y âŸ¶ Z) : category_theory.exact f g â†” category_theory.limits.image_subobject f = category_theory.limits.kernel_subobject g
theorem add_monoid_algebra.grade.is_internal {Î¹ : Type u_2} {R : Type u_3} [decidable_eq Î¹] [add_monoid Î¹] [comm_semiring R] : direct_sum.is_internal (add_monoid_algebra.grade R)
theorem add_subgroup.map_normalizer_eq_of_bijective {G : Type u_1} [add_group G] {N : Type u_3} [add_group N] (H : add_subgroup G) {f : G â†’+ N} (hf : function.bijective â‡‘f) : add_subgroup.map f H.normalizer = (add_subgroup.map f H).normalizer
theorem finset.subset_add {Î± : Type u_2} [decidable_eq Î±] [has_add Î±] {u : finset Î±} {s t : set Î±} : â†‘u âŠ† s + t â†’ (âˆƒ (s' t' : finset Î±), â†‘s' âŠ† s âˆ§ â†‘t' âŠ† t âˆ§ u âŠ† s' + t')
theorem category_theory.normal_mono_category.epi_of_zero_cokernel {C : Type u_1} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_finite_products C] [category_theory.limits.has_kernels C] [category_theory.normal_mono_category C] {X Y : C} (f : X âŸ¶ Y) (Z : C) (l : category_theory.limits.is_colimit (category_theory.limits.cokernel_cofork.of_Ï€ 0 _)) : category_theory.epi f
theorem is_trivial_topological_fiber_bundle_snd {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] : is_trivial_topological_fiber_bundle F prod.snd
theorem finsum_mem_insert {Î± : Type u_1} {M : Type u_5} [add_comm_monoid M] {a : Î±} {s : set Î±} (f : Î± â†’ M) (h : a âˆ‰ s) (hs : s.finite) : finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ has_insert.insert a s), f i)) = f a + finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), f i))
theorem char_zero_of_exp_char_one (R : Type u) [semiring R] [nontrivial R] (p : â„•) [hp : char_p R p] [hq : exp_char R 1] : p = 0
theorem normed_ring.inverse_add_norm_diff_first_order {R : Type u_1} [normed_ring R] [complete_space R] (x : RË£) : (Î» (t : R), ring.inverse (â†‘x + t) - â†‘xâ»Â¹) =O[nhds 0] Î» (t : R), âˆ¥tâˆ¥
theorem powers.one_mem {M : Type u_1} [monoid M] {x : M} : 1 âˆˆ powers x
theorem function.injective.map_at_top_finset_sum_eq {Î± : Type u_3} {Î² : Type u_4} {Î³ : Type u_5} [add_comm_monoid Î±] {g : Î³ â†’ Î²} (hg : function.injective g) {f : Î² â†’ Î±} (hf : âˆ€ (x : Î²), x âˆ‰ set.range g â†’ f x = 0) : filter.map (Î» (s : finset Î³), s.sum (Î» (i : Î³), f (g i))) filter.at_top = filter.map (Î» (s : finset Î²), s.sum (Î» (i : Î²), f i)) filter.at_top
theorem eventually_uniformity_iterate_comp_subset {Î± : Type u_1} [uniform_space Î±] {s : set (Î± Ã— Î±)} (hs : s âˆˆ uniformity Î±) (n : â„•) : âˆ€á¶  (t : set (Î± Ã— Î±)) in (uniformity Î±).small_sets, comp_rel t^[n] t âŠ† s
theorem euclidean_geometry.angle_left_midpoint_eq_pi_div_two_of_dist_eq {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {p1 p2 p3 : P} (h : has_dist.dist p3 p1 = has_dist.dist p3 p2) : euclidean_geometry.angle p3 (midpoint â„ p1 p2) p1 = real.pi / 2
theorem measure_theory.measure.add_haar_smul {E : Type u_1} [normed_group E] [measurable_space E] [normed_space â„ E] [finite_dimensional â„ E] [borel_space E] (Î¼ : measure_theory.measure E) [Î¼.is_add_haar_measure] (r : â„) (s : set E) : â‡‘Î¼ (r â€¢ s) = ennreal.of_real |r ^ finite_dimensional.finrank â„ E| * â‡‘Î¼ s
theorem convex.center_mass_mem {R : Type u_1} {E : Type u_2} {Î¹ : Type u_4} [linear_ordered_field R] [add_comm_group E] [module R E] {s : set E} {t : finset Î¹} {w : Î¹ â†’ R} {z : Î¹ â†’ E} (hs : convex R s) : (âˆ€ (i : Î¹), i âˆˆ t â†’ 0 â‰¤ w i) â†’ 0 < t.sum (Î» (i : Î¹), w i) â†’ (âˆ€ (i : Î¹), i âˆˆ t â†’ z i âˆˆ s) â†’ t.center_mass w z âˆˆ s
theorem multilinear_map.comp_linear_map_injective {R : Type u} {Î¹ : Type u'} {Mâ‚ : Î¹ â†’ Type vâ‚} {Mâ‚‚ : Type vâ‚‚} [decidable_eq Î¹] [semiring R] [Î  (i : Î¹), add_comm_monoid (Mâ‚ i)] [add_comm_monoid Mâ‚‚] [Î  (i : Î¹), module R (Mâ‚ i)] [module R Mâ‚‚] {Mâ‚' : Î¹ â†’ Type u_1} [Î  (i : Î¹), add_comm_monoid (Mâ‚' i)] [Î  (i : Î¹), module R (Mâ‚' i)] (f : Î  (i : Î¹), Mâ‚ i â†’â‚—[R] Mâ‚' i) (hf : âˆ€ (i : Î¹), function.surjective â‡‘(f i)) : function.injective (Î» (g : multilinear_map R Mâ‚' Mâ‚‚), g.comp_linear_map f)
theorem affine_subspace.direction_bot (k : Type u_1) (V : Type u_2) (P : Type u_3) [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] : âŠ¥.direction = âŠ¥
theorem norm_add_sq {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {x y : E} : âˆ¥x + yâˆ¥ ^ 2 = âˆ¥xâˆ¥ ^ 2 + 2 * â‡‘is_R_or_C.re (has_inner.inner x y) + âˆ¥yâˆ¥ ^ 2
theorem emetric.second_countable_of_sigma_compact (Î± : Type u) [pseudo_emetric_space Î±] [sigma_compact_space Î±] : topological_space.second_countable_topology Î±
theorem has_deriv_at_exp {ğ•‚ : Type u_1} [is_R_or_C ğ•‚] {x : ğ•‚} : has_deriv_at (exp ğ•‚) (exp ğ•‚ x) x
theorem interval_integral.integral_has_deriv_at_left {E : Type u_3} [normed_group E] [complete_space E] [normed_space â„ E] {f : â„ â†’ E} {a b : â„} (hf : interval_integrable f measure_theory.measure_space.volume a b) (hmeas : strongly_measurable_at_filter f (nhds a) measure_theory.measure_space.volume) (ha : continuous_at f a) : has_deriv_at (Î» (u : â„), âˆ« (x : â„) in u..b, f x) (-f a) a
theorem lie_module.nilpotent_of_nilpotent_quotient (R : Type u) (L : Type v) (M : Type w) [comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] {N : lie_submodule R L M} (hâ‚ : N â‰¤ lie_module.max_triv_submodule R L M) (hâ‚‚ : lie_module.is_nilpotent R L (M â§¸ N)) : lie_module.is_nilpotent R L M
theorem orthonormal.eq_rotation_self_iff_angle_eq_zero {V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) {x : V} (hx : x â‰  0) (Î¸ : real.angle) : x = â‡‘(hb.rotation Î¸) x â†” Î¸ = 0
theorem antitone.covariant_of_const {M : Type u_1} {N : Type u_2} {Î¼ : M â†’ N â†’ N} {Î± : Type u_3} [preorder Î±] [preorder N] {f : N â†’ Î±} [covariant_class M N Î¼ has_le.le] (hf : antitone f) (m : M) : antitone (Î» (n : N), f (Î¼ m n))
theorem has_sum.prod_fiberwise {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [add_comm_monoid Î±] [topological_space Î±] [has_continuous_add Î±] [regular_space Î±] {f : Î² Ã— Î³ â†’ Î±} {g : Î² â†’ Î±} {a : Î±} (ha : has_sum f a) (hf : âˆ€ (b : Î²), has_sum (Î» (c : Î³), f (b, c)) (g b)) : has_sum g a
theorem image_norm_le_of_liminf_right_slope_norm_lt_deriv_boundary {a b : â„} {E : Type u_1} [normed_group E] {f : â„ â†’ E} {f' : â„ â†’ â„} (hf : continuous_on f (set.Icc a b)) (hf' : âˆ€ (x : â„), x âˆˆ set.Ico a b â†’ âˆ€ (r : â„), f' x < r â†’ (âˆƒá¶  (z : â„) in nhds_within x (set.Ioi x), slope (has_norm.norm âˆ˜ f) x z < r)) {B B' : â„ â†’ â„} (ha : âˆ¥f aâˆ¥ â‰¤ B a) (hB : continuous_on B (set.Icc a b)) (hB' : âˆ€ (x : â„), x âˆˆ set.Ico a b â†’ has_deriv_within_at B (B' x) (set.Ici x) x) (bound : âˆ€ (x : â„), x âˆˆ set.Ico a b â†’ âˆ¥f xâˆ¥ = B x â†’ f' x < B' x) â¦ƒx : â„â¦„ : x âˆˆ set.Icc a b â†’ âˆ¥f xâˆ¥ â‰¤ B x
theorem has_le.le.trans' {Î± : Type u} [preorder Î±] {a b c : Î±} : b â‰¤ c â†’ a â‰¤ b â†’ a â‰¤ c
theorem category_theory.whiskering_preadditive_coyoneda {C : Type u} [category_theory.category C] [category_theory.preadditive C] : category_theory.preadditive_coyoneda â‹™ (category_theory.whiskering_right C AddCommGroup (Type v)).obj (category_theory.forget AddCommGroup) = category_theory.coyoneda
theorem poly.is_poly {Î± : Type u_1} (f : poly Î±) : is_poly â‡‘f
theorem W_type.cardinal_mk_le_of_le {Î± : Type u} {Î² : Î± â†’ Type u} {Îº : cardinal} (hÎº : cardinal.sum (Î» (a : Î±), Îº ^ cardinal.mk (Î² a)) â‰¤ Îº) : cardinal.mk (W_type Î²) â‰¤ Îº
theorem category_theory.limits.has_zero_object_of_has_initial_object {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_initial C] : category_theory.limits.has_zero_object C
theorem cont_diff.add {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {n : with_top â„•} {f g : E â†’ F} (hf : cont_diff ğ•œ n f) (hg : cont_diff ğ•œ n g) : cont_diff ğ•œ n (Î» (x : E), f x + g x)
theorem legendre_symbol.Ico_map_val_min_abs_nat_abs_eq_Ico_map_id (p : â„•) [hp : fact (nat.prime p)] (a : zmod p) (hap : a â‰  0) : multiset.map (Î» (x : â„•), (a * â†‘x).val_min_abs.nat_abs) (finset.Ico 1 (p / 2).succ).val = multiset.map (Î» (a : â„•), a) (finset.Ico 1 (p / 2).succ).val
theorem dimH_image_le_of_locally_holder_on {X : Type u_2} {Y : Type u_3} [emetric_space X] [emetric_space Y] [topological_space.second_countable_topology X] {r : nnreal} {f : X â†’ Y} (hr : 0 < r) {s : set X} (hf : âˆ€ (x : X), x âˆˆ s â†’ (âˆƒ (C : nnreal) (t : set X) (H : t âˆˆ nhds_within x s), holder_on_with C r f t)) : dimH (f '' s) â‰¤ dimH s / â†‘r
theorem subalgebra.separates_points.strongly {Î± : Type u_1} [topological_space Î±] {ğ•œ : Type u_5} [topological_space ğ•œ] [field ğ•œ] [topological_ring ğ•œ] {s : subalgebra ğ•œ C(Î±, ğ•œ)} (h : s.separates_points) : â†‘s.separates_points_strongly
theorem mv_polynomial.induction_on'' {R : Type u} {Ïƒ : Type u_1} [comm_semiring R] {M : mv_polynomial Ïƒ R â†’ Prop} (p : mv_polynomial Ïƒ R) (h_C : âˆ€ (a : R), M (â‡‘mv_polynomial.C a)) (h_add_weak : âˆ€ (a : Ïƒ â†’â‚€ â„•) (b : R) (f : (Ïƒ â†’â‚€ â„•) â†’â‚€ R), a âˆ‰ f.support â†’ b â‰  0 â†’ M f â†’ M (â‡‘(mv_polynomial.monomial a) b) â†’ M (â‡‘(mv_polynomial.monomial a) b + f)) (h_X : âˆ€ (p : mv_polynomial Ïƒ R) (n : Ïƒ), M p â†’ M (p * mv_polynomial.X n)) : M p
theorem measure_theory.simple_func.lintegral_congr {Î± : Type u_1} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {f g : measure_theory.simple_func Î± ennreal} (h : â‡‘f =áµ[Î¼] â‡‘g) : f.lintegral Î¼ = g.lintegral Î¼
theorem is_localization.localization_localization_is_localization_of_has_all_units {R : Type u_1} [comm_ring R] (M : submonoid R) {S : Type u_2} [comm_ring S] [algebra R S] (N : submonoid S) (T : Type u_4) [comm_ring T] [algebra R T] [algebra S T] [is_scalar_tower R S T] [is_localization M S] [is_localization N T] (H : âˆ€ (x : S), is_unit x â†’ x âˆˆ N) : is_localization (submonoid.comap (algebra_map R S).to_monoid_hom N) T
theorem is_fw_invariant_iff_is_invariant {Ï„ : Type u_1} {Î± : Type u_2} [canonically_ordered_add_monoid Ï„] {Ï• : Ï„ â†’ Î± â†’ Î±} {s : set Î±} : is_fw_invariant Ï• s â†” is_invariant Ï• s
theorem emetric.Hausdorff_edist_self {Î± : Type u} [pseudo_emetric_space Î±] {s : set Î±} : emetric.Hausdorff_edist s s = 0
theorem continuous_linear_map.is_compact_image_coe_closed_ball {ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {E : Type u_4} {F : Type u_6} [normed_group E] [normed_group F] [nondiscrete_normed_field ğ•œ] [nondiscrete_normed_field ğ•œâ‚‚] [normed_space ğ•œ E] [normed_space ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} [ring_hom_isometric Ïƒâ‚â‚‚] [proper_space F] (fâ‚€ : E â†’SL[Ïƒâ‚â‚‚] F) (r : â„) : is_compact (coe_fn '' metric.closed_ball fâ‚€ r)
theorem linear_map.eq_adjoint_iff {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] [inner_product_space ğ•œ F] [finite_dimensional ğ•œ E] [finite_dimensional ğ•œ F] (A : E â†’â‚—[ğ•œ] F) (B : F â†’â‚—[ğ•œ] E) : A = â‡‘linear_map.adjoint B â†” âˆ€ (x : E) (y : F), has_inner.inner (â‡‘A x) y = has_inner.inner x (â‡‘B y)
theorem fintype.exists_sum_fiber_lt_of_sum_lt_nsmul {Î± : Type u} {Î² : Type v} {M : Type w} [decidable_eq Î²] [fintype Î±] [fintype Î²] (f : Î± â†’ Î²) {w : Î± â†’ M} {b : M} [linear_ordered_cancel_add_comm_monoid M] (hb : finset.univ.sum (Î» (x : Î±), w x) < fintype.card Î² â€¢ b) : âˆƒ (y : Î²), (finset.filter (Î» (x : Î±), f x = y) finset.univ).sum (Î» (x : Î±), w x) < b
theorem orientation.oangle_add_cyc3_neg_right {V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) {x y z : V} (hx : x â‰  0) (hy : y â‰  0) (hz : z â‰  0) : o.oangle x (-y) + o.oangle y (-z) + o.oangle z (-x) = â†‘real.pi
theorem is_open.measure_eq_supr_is_compact {Î± : Type u_1} [measurable_space Î±] [topological_space Î±] â¦ƒU : set Î±â¦„ (hU : is_open U) (Î¼ : measure_theory.measure Î±) [Î¼.regular] : â‡‘Î¼ U = â¨† (K : set Î±) (h : K âŠ† U) (h2 : is_compact K), â‡‘Î¼ K
theorem ring_equiv.map_add {R : Type u_4} {S : Type u_5} [has_mul R] [has_add R] [has_mul S] [has_add S] (e : R â‰ƒ+* S) (x y : R) : â‡‘e (x + y) = â‡‘e x + â‡‘e y
theorem direct_sum.to_module.unique (R : Type u) [semiring R] {Î¹ : Type v} [dec_Î¹ : decidable_eq Î¹] {M : Î¹ â†’ Type w} [Î  (i : Î¹), add_comm_monoid (M i)] [Î  (i : Î¹), module R (M i)] {N : Type uâ‚} [add_comm_monoid N] [module R N] (Ïˆ : direct_sum Î¹ (Î» (i : Î¹), M i) â†’â‚—[R] N) (f : direct_sum Î¹ (Î» (i : Î¹), M i)) : â‡‘Ïˆ f = â‡‘(direct_sum.to_module R Î¹ N (Î» (i : Î¹), Ïˆ.comp (direct_sum.lof R Î¹ M i))) f
theorem setoid.Inf_def {Î± : Type u_1} {s : set (setoid Î±)} : (has_Inf.Inf s).rel = has_Inf.Inf (setoid.rel '' s)
theorem image_le_of_liminf_slope_right_le_deriv_boundary {f : â„ â†’ â„} {a b : â„} (hf : continuous_on f (set.Icc a b)) {B B' : â„ â†’ â„} (ha : f a â‰¤ B a) (hB : continuous_on B (set.Icc a b)) (hB' : âˆ€ (x : â„), x âˆˆ set.Ico a b â†’ has_deriv_within_at B (B' x) (set.Ici x) x) (bound : âˆ€ (x : â„), x âˆˆ set.Ico a b â†’ âˆ€ (r : â„), B' x < r â†’ (âˆƒá¶  (z : â„) in nhds_within x (set.Ioi x), slope f x z < r)) â¦ƒx : â„â¦„ : x âˆˆ set.Icc a b â†’ f x â‰¤ B x
theorem add_monoid_hom.eq_on_neg {M : Type u_3} {F : Type u_8} {G : Type u_1} [add_group G] [add_monoid M] [add_monoid_hom_class F G M] {f g : F} {x : G} (h : â‡‘f x = â‡‘g x) : â‡‘f (-x) = â‡‘g (-x)
theorem filter.tendsto.uniformity_trans {Î± : Type u_1} {Î² : Type u_2} [uniform_space Î±] {l : filter Î²} {fâ‚ fâ‚‚ fâ‚ƒ : Î² â†’ Î±} (hâ‚â‚‚ : filter.tendsto (Î» (x : Î²), (fâ‚ x, fâ‚‚ x)) l (uniformity Î±)) (hâ‚‚â‚ƒ : filter.tendsto (Î» (x : Î²), (fâ‚‚ x, fâ‚ƒ x)) l (uniformity Î±)) : filter.tendsto (Î» (x : Î²), (fâ‚ x, fâ‚ƒ x)) l (uniformity Î±)
theorem category_theory.limits.biprod.total {C : Type u} [category_theory.category C] [category_theory.preadditive C] {X Y : C} [category_theory.limits.has_binary_biproduct X Y] : category_theory.limits.biprod.fst â‰« category_theory.limits.biprod.inl + category_theory.limits.biprod.snd â‰« category_theory.limits.biprod.inr = ğŸ™ (X âŠ Y)
theorem intermediate_field.bot_eq_top_of_finrank_adjoin_le_one {F : Type u_1} [field F] {E : Type u_2} [field E] [algebra F E] [finite_dimensional F E] (h : âˆ€ (x : E), finite_dimensional.finrank F â†¥FâŸ®xâŸ¯ â‰¤ 1) : âŠ¥ = âŠ¤
theorem nat.exists_infinite_primes (n : â„•) : âˆƒ (p : â„•), n â‰¤ p âˆ§ nat.prime p
theorem add_monoid_algebra.mem_span_support' {k : Type uâ‚} {G : Type uâ‚‚} [semiring k] (f : add_monoid_algebra k G) : f âˆˆ submodule.span k (add_monoid_algebra.of' k G '' â†‘(f.support))
theorem neg_zero' {Î± : Type u} [mul_zero_class Î±] [has_distrib_neg Î±] : -0 = 0
theorem algebra.commutes {R : Type u} {A : Type w} [comm_semiring R] [semiring A] [algebra R A] (r : R) (x : A) : â‡‘(algebra_map R A) r * x = x * â‡‘(algebra_map R A) r
theorem setoid.nonempty_of_mem_partition {Î± : Type u_1} {c : set (set Î±)} (hc : setoid.is_partition c) {s : set Î±} (h : s âˆˆ c) : s.nonempty
theorem basis.exists_op_norm_le {ğ•œ : Type u} [nondiscrete_normed_field ğ•œ] {E : Type v} [normed_group E] [normed_space ğ•œ E] {F : Type w} [normed_group F] [normed_space ğ•œ F] [complete_space ğ•œ] {Î¹ : Type u_1} [fintype Î¹] (v : basis Î¹ ğ•œ E) : âˆƒ (C : â„) (H : C > 0), âˆ€ {u : E â†’L[ğ•œ] F} {M : â„}, 0 â‰¤ M â†’ (âˆ€ (i : Î¹), âˆ¥â‡‘u (â‡‘v i)âˆ¥ â‰¤ M) â†’ âˆ¥uâˆ¥ â‰¤ C * M
theorem add_monoid_hom.coe_inj {M : Type u_3} {N : Type u_4} [add_zero_class M] [add_zero_class N] â¦ƒf g : M â†’+ Nâ¦„ (h : â‡‘f = â‡‘g) : f = g
theorem simple_graph.max_degree_lt_card_verts {V : Type u} (G : simple_graph V) [fintype V] [decidable_rel G.adj] [nonempty V] : G.max_degree < fintype.card V
theorem category_theory.limits.is_limit.of_nat_iso.cone_of_hom_fac {J : Type uâ‚} [category_theory.category J] {C : Type uâ‚ƒ} [category_theory.category C] {F : J â¥¤ C} {X : C} (h : category_theory.yoneda.obj X â‹™ category_theory.ulift_functor â‰… F.cones) {Y : C} (f : Y âŸ¶ X) : category_theory.limits.is_limit.of_nat_iso.cone_of_hom h f = (category_theory.limits.is_limit.of_nat_iso.limit_cone h).extend f
theorem is_compact.uniform_continuous_on_of_continuous {Î± : Type u_1} {Î² : Type u_2} [uniform_space Î±] [uniform_space Î²] [separated_space Î±] {s : set Î±} {f : Î± â†’ Î²} (hs : is_compact s) (hf : continuous_on f s) : uniform_continuous_on f s
theorem fermat_42.exists_minimal {a b c : â„¤} (h : fermat_42 a b c) : âˆƒ (a0 b0 c0 : â„¤), fermat_42.minimal a0 b0 c0
theorem add_submonoid.localization_map.map_add_left {M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {N : Type u_2} [add_comm_monoid N] {P : Type u_3} [add_comm_monoid P] (f : S.localization_map N) {g : M â†’+ P} {T : add_submonoid P} (hy : âˆ€ (y : â†¥S), â‡‘g â†‘y âˆˆ T) {Q : Type u_4} [add_comm_monoid Q] {k : T.localization_map Q} (z : N) : â‡‘(k.to_map) (â‡‘g â†‘((f.sec z).snd)) + â‡‘(f.map hy k) z = â‡‘(k.to_map) (â‡‘g (f.sec z).fst)
theorem fin.prod_univ_succ_above {Î² : Type u_2} [comm_monoid Î²] {n : â„•} (f : fin (n + 1) â†’ Î²) (x : fin (n + 1)) : finset.univ.prod (Î» (i : fin (n + 1)), f i) = f x * finset.univ.prod (Î» (i : fin n), f (â‡‘(x.succ_above) i))
theorem cardinal.nsmul_lt_aleph_0_iff {n : â„•} {a : cardinal} : n â€¢ a < cardinal.aleph_0 â†” n = 0 âˆ¨ a < cardinal.aleph_0
theorem filter.infi_ne_bot_of_directed {Î± : Type u} {Î¹ : Sort x} {f : Î¹ â†’ filter Î±} [hn : nonempty Î±] (hd : directed ge f) (hb : âˆ€ (i : Î¹), (f i).ne_bot) : (infi f).ne_bot
theorem filter.tendsto.const_mul_at_bot {Î± : Type u_3} {Î² : Type u_4} [linear_ordered_field Î±] {l : filter Î²} {f : Î² â†’ Î±} {r : Î±} (hr : 0 < r) (hf : filter.tendsto f l filter.at_bot) : filter.tendsto (Î» (x : Î²), r * f x) l filter.at_bot
theorem ext_chart_preimage_inter_eq {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] (I : model_with_corners ğ•œ E H) {M : Type u_4} [topological_space M] [charted_space H M] (x : M) {s t : set M} : â‡‘((ext_chart_at I x).symm) â»Â¹' (s âˆ© t) âˆ© set.range â‡‘I = â‡‘((ext_chart_at I x).symm) â»Â¹' s âˆ© set.range â‡‘I âˆ© â‡‘((ext_chart_at I x).symm) â»Â¹' t
theorem same_ray_pos_smul_right {R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] (v : M) {r : R} (h : 0 < r) : same_ray R v (r â€¢ v)
theorem is_primitive_root.card_primitive_roots {R : Type u_5} [comm_ring R] [is_domain R] {Î¶ : R} {k : â„•} (h : is_primitive_root Î¶ k) : (primitive_roots k R).card = k.totient
theorem filter.tendsto.not_tendsto {Î± : Type u} {Î² : Type v} {f : Î± â†’ Î²} {a : filter Î±} {bâ‚ bâ‚‚ : filter Î²} (hf : filter.tendsto f a bâ‚) [a.ne_bot] (hb : disjoint bâ‚ bâ‚‚) : Â¬filter.tendsto f a bâ‚‚
theorem ring_hom.map_closure {R : Type u} {S : Type v} [ring R] [ring S] (f : R â†’+* S) (s : set R) : subring.map f (subring.closure s) = subring.closure (â‡‘f '' s)
theorem add_commute.refl {S : Type u_1} [has_add S] (a : S) : add_commute a a
theorem ideal.prime_iff_is_prime {A : Type u_2} [comm_ring A] [is_domain A] [is_dedekind_domain A] {P : ideal A} (hP : P â‰  âŠ¥) : prime P â†” P.is_prime
theorem finset.exists_lt_card_fiber_of_nsmul_lt_card_of_maps_to {Î± : Type u} {Î² : Type v} {M : Type w} [decidable_eq Î²] {s : finset Î±} {t : finset Î²} {f : Î± â†’ Î²} {b : M} [linear_ordered_comm_ring M] (hf : âˆ€ (a : Î±), a âˆˆ s â†’ f a âˆˆ t) (ht : t.card â€¢ b < â†‘(s.card)) : âˆƒ (y : Î²) (H : y âˆˆ t), b < â†‘((finset.filter (Î» (x : Î±), f x = y) s).card)
theorem orthonormal.det_rotation {V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) (Î¸ : real.angle) : â‡‘linear_map.det â†‘((hb.rotation Î¸).to_linear_equiv) = 1
theorem zmod.units_pow_card_sub_one_eq_one (p : â„•) [fact (nat.prime p)] (a : (zmod p)Ë£) : a ^ (p - 1) = 1
theorem list.nodup.sublists {Î± : Type u} {l : list Î±} : l.nodup â†’ l.sublists.nodup
theorem algebraic_geometry.Spec_map_localization_is_iso (R : CommRing) (M : submonoid â†¥R) (x : prime_spectrum (localization M)) : category_theory.is_iso (algebraic_geometry.PresheafedSpace.stalk_map (algebraic_geometry.Spec.to_PresheafedSpace.map (CommRing.of_hom (algebra_map â†¥R (localization M))).op) x)
theorem real.tendsto_exp_nhds_0_nhds_1  : filter.tendsto real.exp (nhds 0) (nhds 1)
theorem measure_theory.measure_of_cont_bdd_of_tendsto_indicator {Î± : Type u_1} [measurable_space Î±] [topological_space Î±] [opens_measurable_space Î±] (Î¼ : measure_theory.finite_measure Î±) {c : nnreal} {E : set Î±} (E_mble : measurable_set E) (fs : â„• â†’ bounded_continuous_function Î± nnreal) (fs_bdd : âˆ€ (n : â„•) (a : Î±), â‡‘(fs n) a â‰¤ c) (fs_lim : filter.tendsto (Î» (n : â„•), â‡‘(fs n)) filter.at_top (nhds (E.indicator (Î» (x : Î±), 1)))) : filter.tendsto (Î» (n : â„•), âˆ«â» (a : Î±), â†‘(â‡‘(fs n) a) âˆ‚â†‘Î¼) filter.at_top (nhds (â‡‘â†‘Î¼ E))
theorem range.is_submonoid {M : Type u_1} [monoid M] {Î³ : Type u_2} [monoid Î³] {f : M â†’ Î³} (hf : is_monoid_hom f) : is_submonoid (set.range f)
theorem continuous_map.Inter_compact_open_gen_subset_compact_conv_nhd {Î± : Type uâ‚} {Î² : Type uâ‚‚} [topological_space Î±] [uniform_space Î²] {K : set Î±} {V : set (Î² Ã— Î²)} (f : C(Î±, Î²)) (hK : is_compact K) (hV : V âˆˆ uniformity Î²) : âˆƒ (Î¹ : Type uâ‚) [_inst_3 : fintype Î¹] (C : Î¹ â†’ set Î±) (hC : âˆ€ (i : Î¹), is_compact (C i)) (U : Î¹ â†’ set Î²) (hU : âˆ€ (i : Î¹), is_open (U i)), (f âˆˆ â‹‚ (i : Î¹), continuous_map.compact_open.gen (C i) (U i)) âˆ§ (â‹‚ (i : Î¹), continuous_map.compact_open.gen (C i) (U i)) âŠ† continuous_map.compact_conv_nhd K V f
theorem add_le_of_le_neg_add {Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b c : Î±} : b â‰¤ -a + c â†’ a + b â‰¤ c
theorem nat.partrec.code.fixed_point {f : nat.partrec.code â†’ nat.partrec.code} (hf : computable f) : âˆƒ (c : nat.partrec.code), (f c).eval = c.eval
theorem cont_diff.smul {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {n : with_top â„•} {f : E â†’ ğ•œ} {g : E â†’ F} (hf : cont_diff ğ•œ n f) (hg : cont_diff ğ•œ n g) : cont_diff ğ•œ n (Î» (x : E), f x â€¢ g x)
theorem smooth_bump_covering.exists_is_subordinate {E : Type uE} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] {H : Type uH} [topological_space H] (I : model_with_corners â„ E H) {M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {s : set M} {U : M â†’ set M} [t2_space M] [sigma_compact_space M] (hs : is_closed s) (hU : âˆ€ (x : M), x âˆˆ s â†’ U x âˆˆ nhds x) : âˆƒ (Î¹ : Type uM) (f : smooth_bump_covering Î¹ I M s), f.is_subordinate U
theorem exists_between_of_forall_le {Î± : Type u_1} [conditionally_complete_lattice Î±] {s t : set Î±} (sne : s.nonempty) (tne : t.nonempty) (hst : âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (y : Î±), y âˆˆ t â†’ x â‰¤ y) : (upper_bounds s âˆ© lower_bounds t).nonempty
theorem ennreal.top_sub_coe {r : nnreal} : âŠ¤ - â†‘r = âŠ¤
theorem is_smul_regular.not_zero {R : Type u_1} {M : Type u_3} [monoid_with_zero R] [has_zero M] [mul_action_with_zero R M] [nM : nontrivial M] : Â¬is_smul_regular M 0
theorem uv.sup_sdiff_mem_of_mem_compression {Î± : Type u_1} [generalized_boolean_algebra Î±] [decidable_rel disjoint] [decidable_rel has_le.le] {s : finset Î±} {u v a : Î±} (ha : a âˆˆ uv.compression u v s) (hva : v â‰¤ a) (hua : disjoint u a) : (a âŠ” u)  v âˆˆ s
theorem monoid_algebra.alg_hom_ext' {k : Type uâ‚} {G : Type uâ‚‚} [comm_semiring k] [monoid G] {A : Type uâ‚ƒ} [semiring A] [algebra k A] â¦ƒÏ†â‚ Ï†â‚‚ : monoid_algebra k G â†’â‚[k] Aâ¦„ (h : â†‘Ï†â‚.comp (monoid_algebra.of k G) = â†‘Ï†â‚‚.comp (monoid_algebra.of k G)) : Ï†â‚ = Ï†â‚‚
theorem has_subset.subset.antisymm {Î± : Type u} [has_subset Î±] {a b : Î±} [is_antisymm Î± has_subset.subset] (h : a âŠ† b) (h' : b âŠ† a) : a = b
theorem affine_subspace.vsub_mem_direction {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : affine_subspace k P} {p1 p2 : P} (hp1 : p1 âˆˆ s) (hp2 : p2 âˆˆ s) : p1 -áµ¥ p2 âˆˆ s.direction
theorem orientation.oangle_rev {V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) (x y : V) : o.oangle y x = -o.oangle x y
theorem char_dvd_card_solutions {K : Type u_1} {Ïƒ : Type u_2} [fintype K] [field K] [fintype Ïƒ] [decidable_eq K] [decidable_eq Ïƒ] (p : â„•) [char_p K p] {f : mv_polynomial Ïƒ K} (h : f.total_degree < fintype.card Ïƒ) : p âˆ£ fintype.card {x // â‡‘(mv_polynomial.eval x) f = 0}
theorem category_theory.zigzag_is_connected {J : Type uâ‚} [category_theory.category J] [nonempty J] (h : âˆ€ (jâ‚ jâ‚‚ : J), category_theory.zigzag jâ‚ jâ‚‚) : category_theory.is_connected J
theorem is_p_group.exists_fixed_point_of_prime_dvd_card_of_fixed_point {p : â„•} {G : Type u_1} [group G] (hG : is_p_group p G) [hp : fact (nat.prime p)] (Î± : Type u_2) [mul_action G Î±] [fintype Î±] [fintype â†¥(mul_action.fixed_points G Î±)] (hpÎ± : p âˆ£ fintype.card Î±) {a : Î±} (ha : a âˆˆ mul_action.fixed_points G Î±) : âˆƒ (b : Î±), b âˆˆ mul_action.fixed_points G Î± âˆ§ a â‰  b
theorem orientation.oangle_neg_left {V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) {x y : V} (hx : x â‰  0) (hy : y â‰  0) : o.oangle (-x) y = o.oangle x y + â†‘real.pi
theorem measure_theory.measure.finite_spanning_sets_in.ext {Î± : Type u_1} {m0 : measurable_space Î±} {Î¼ Î½ : measure_theory.measure Î±} {C : set (set Î±)} (hA : m0 = measurable_space.generate_from C) (hC : is_pi_system C) (h : Î¼.finite_spanning_sets_in C) (h_eq : âˆ€ (s : set Î±), s âˆˆ C â†’ â‡‘Î¼ s = â‡‘Î½ s) : Î¼ = Î½
theorem affine_independent.of_set_of_injective {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {Î¹ : Type u_4} {p : Î¹ â†’ P} (ha : affine_independent k (Î» (x : â†¥(set.range p)), â†‘x)) (hi : function.injective p) : affine_independent k p
theorem category_theory.limits.cokernel.map_desc {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y Z X' Y' Z' : C} (f : X âŸ¶ Y) [category_theory.limits.has_cokernel f] (g : Y âŸ¶ Z) (w : f â‰« g = 0) (f' : X' âŸ¶ Y') [category_theory.limits.has_cokernel f'] (g' : Y' âŸ¶ Z') (w' : f' â‰« g' = 0) (p : X âŸ¶ X') (q : Y âŸ¶ Y') (r : Z âŸ¶ Z') (hâ‚ : f â‰« q = p â‰« f') (hâ‚‚ : g â‰« r = q â‰« g') : category_theory.limits.cokernel.map f f' p q hâ‚ â‰« category_theory.limits.cokernel.desc f' g' w' = category_theory.limits.cokernel.desc f g w â‰« r
theorem even.exists_two_nsmul {Î± : Type u_2} [add_monoid Î±] (m : Î±) : even m â†’ (âˆƒ (c : Î±), m = 2 â€¢ c)
theorem char_p.char_ne_zero_of_fintype (R : Type u) [non_assoc_ring R] (p : â„•) [hc : char_p R p] [fintype R] : p â‰  0
theorem measure_eq_measure_preimage_add_measure_tsum_Ico_zpow {Î± : Type u_1} [measurable_space Î±] (Î¼ : measure_theory.measure Î±) {f : Î± â†’ ennreal} (hf : measurable f) {s : set Î±} (hs : measurable_set s) {t : nnreal} (ht : 1 < t) : â‡‘Î¼ s = â‡‘Î¼ (s âˆ© f â»Â¹' {0}) + â‡‘Î¼ (s âˆ© f â»Â¹' {âŠ¤}) + âˆ‘' (n : â„¤), â‡‘Î¼ (s âˆ© f â»Â¹' set.Ico (â†‘t ^ n) (â†‘t ^ (n + 1)))
theorem module.free.rank_direct_sum (R : Type u) [ring R] [strong_rank_condition R] {Î¹ : Type v} (M : Î¹ â†’ Type w) [Î  (i : Î¹), add_comm_group (M i)] [Î  (i : Î¹), module R (M i)] [âˆ€ (i : Î¹), module.free R (M i)] : module.rank R (direct_sum Î¹ (Î» (i : Î¹), M i)) = cardinal.sum (Î» (i : Î¹), module.rank R (M i))
theorem vector_span_eq_span_vsub_finset_right_ne (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : finset P} {p : P} (hp : p âˆˆ s) : vector_span k â†‘s = submodule.span k â†‘(finset.image (Î» (_x : P), _x -áµ¥ p) (s.erase p))
theorem module.free.rank_prod' (R : Type u) (M : Type v) [ring R] [strong_rank_condition R] [add_comm_group M] [module R M] [module.free R M] (N : Type v) [add_comm_group N] [module R N] [module.free R N] : module.rank R (M Ã— N) = module.rank R M + module.rank R N
theorem nat.arithmetic_function.is_multiplicative.iff_ne_zero {R : Type u_1} [monoid_with_zero R] {f : nat.arithmetic_function R} : f.is_multiplicative â†” â‡‘f 1 = 1 âˆ§ âˆ€ {m n : â„•}, m â‰  0 â†’ n â‰  0 â†’ m.coprime n â†’ â‡‘f (m * n) = â‡‘f m * â‡‘f n
theorem con.ker_eq_lift_of_injective {M : Type u_1} {P : Type u_3} [mul_one_class M] [mul_one_class P] (c : con M) (f : M â†’* P) (H : c â‰¤ con.ker f) (h : function.injective â‡‘(c.lift f H)) : con.ker f = c
theorem torus_integral_succ_above {n : â„•} {E : Type u_1} [normed_group E] [normed_space â„‚ E] [complete_space E] {f : (fin (n + 1) â†’ â„‚) â†’ E} {c : fin (n + 1) â†’ â„‚} {R : fin (n + 1) â†’ â„} (hf : torus_integrable f c R) (i : fin (n + 1)) : âˆ¯ (x : fin (n + 1) â†’ â„‚) in T(c, R), f x = âˆ® (x : â„‚) in C(c i, R i), âˆ¯ (y : fin n â†’ â„‚) in T(c âˆ˜ â‡‘(i.succ_above), R âˆ˜ â‡‘(i.succ_above)), f (i.insert_nth x y)
theorem int.le_induction_down {P : â„¤ â†’ Prop} {m : â„¤} (h0 : P m) (h1 : âˆ€ (n : â„¤), n â‰¤ m â†’ P n â†’ P (n - 1)) (n : â„¤) : n â‰¤ m â†’ P n
theorem has_ssubset.ssubset.not_subset {Î± : Type u} [has_subset Î±] [has_ssubset Î±] [is_nonstrict_strict_order Î± has_subset.subset has_ssubset.ssubset] {a b : Î±} (h : a âŠ‚ b) : Â¬b âŠ† a
theorem is_o_rpow_exp_at_top (s : â„) : (Î» (x : â„), x ^ s) =o[filter.at_top] real.exp
theorem tendsto_uniformly_on_iff_tendsto {Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_4} [uniform_space Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : filter Î¹} {s : set Î±} : tendsto_uniformly_on F f p s â†” filter.tendsto (Î» (q : Î¹ Ã— Î±), (f q.snd, F q.fst q.snd)) (p.prod (filter.principal s)) (uniformity Î²)
theorem is_localization.sec_spec {R : Type u_1} [comm_semiring R] (M : submonoid R) {S : Type u_2} [comm_semiring S] [algebra R S] [is_localization M S] (z : S) : z * â‡‘(algebra_map R S) â†‘((is_localization.sec M z).snd) = â‡‘(algebra_map R S) (is_localization.sec M z).fst
theorem bsupr_limsup_dimH {X : Type u_2} [emetric_space X] [topological_space.second_countable_topology X] (s : set X) : (â¨† (x : X) (H : x âˆˆ s), (nhds_within x s).small_sets.limsup dimH) = dimH s
theorem polynomial.nat_degree_C_mul_eq_of_mul_ne_zero {R : Type u} {a : R} [semiring R] {p : polynomial R} (h : a * p.leading_coeff â‰  0) : (â‡‘polynomial.C a * p).nat_degree = p.nat_degree
theorem equiv.perm.is_cycle_cycle_of_iff {Î± : Type u_1} [decidable_eq Î±] [fintype Î±] (f : equiv.perm Î±) {x : Î±} : (f.cycle_of x).is_cycle â†” â‡‘f x â‰  x
theorem filter.tendsto.at_bot_add {Î± : Type u} {Î² : Type v} [topological_space Î±] [linear_ordered_add_comm_group Î±] [order_topology Î±] {l : filter Î²} {f g : Î² â†’ Î±} {C : Î±} (hf : filter.tendsto f l filter.at_bot) (hg : filter.tendsto g l (nhds C)) : filter.tendsto (Î» (x : Î²), f x + g x) l filter.at_bot
theorem concave_on.ge_on_segment' {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [ordered_semiring ğ•œ] [add_comm_monoid E] [linear_ordered_add_comm_monoid Î²] [has_scalar ğ•œ E] [module ğ•œ Î²] [ordered_smul ğ•œ Î²] {s : set E} {f : E â†’ Î²} (hf : concave_on ğ•œ s f) {x y : E} (hx : x âˆˆ s) (hy : y âˆˆ s) {a b : ğ•œ} (ha : 0 â‰¤ a) (hb : 0 â‰¤ b) (hab : a + b = 1) : linear_order.min (f x) (f y) â‰¤ f (a â€¢ x + b â€¢ y)
theorem rack.to_envel_group.univ_uniq (R : Type u_1) [rack R] (G : Type u_2) [group G] (f : shelf_hom R (quandle.conj G)) (g : rack.envel_group R â†’* G) (h : f = (quandle.conj.map g).comp (rack.to_envel_group R)) : g = â‡‘rack.to_envel_group.map f
theorem is_cyclotomic_extension.two_pow_norm_zeta_sub_one {K : Type u} (L : Type v) [field K] [field L] [algebra K L] [ne_zero 2] {k : â„•} (hk : 2 â‰¤ k) [is_cyclotomic_extension {2 ^ k} K L] (hirr : irreducible (polynomial.cyclotomic (2 ^ k) K)) : â‡‘(algebra.norm K) (is_cyclotomic_extension.zeta (2 ^ k) K L - 1) = 2
theorem is_add_group_hom.mk' {Î± : Type u} {Î² : Type v} [add_group Î±] [add_group Î²] {f : Î± â†’ Î²} (hf : âˆ€ (x y : Î±), f (x + y) = f x + f y) : is_add_group_hom f
theorem cont_diff.comp {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {G : Type u_4} [normed_group G] [normed_space ğ•œ G] {n : with_top â„•} {g : F â†’ G} {f : E â†’ F} (hg : cont_diff ğ•œ n g) (hf : cont_diff ğ•œ n f) : cont_diff ğ•œ n (g âˆ˜ f)
theorem line_map_le_map_iff_slope_le_slope {k : Type u_1} {E : Type u_2} [linear_ordered_field k] [ordered_add_comm_group E] [module k E] [ordered_smul k E] {f : k â†’ E} {a b r : k} (hab : a < b) (hâ‚€ : 0 < r) (hâ‚ : r < 1) : â‡‘(affine_map.line_map (f a) (f b)) r â‰¤ f (â‡‘(affine_map.line_map a b) r) â†” slope f (â‡‘(affine_map.line_map a b) r) b â‰¤ slope f a (â‡‘(affine_map.line_map a b) r)
theorem Top.presheaf.is_sheaf_of_is_sheaf_unique_gluing_types {X : Top} (F : Top.presheaf (Type v) X) (Fsh : F.is_sheaf_unique_gluing) : F.is_sheaf
theorem inner_matrix_row_row {ğ•œ : Type u_3} [is_R_or_C ğ•œ] {n m : â„•} (A B : matrix (fin n) (fin m) ğ•œ) (i j : fin n) : has_inner.inner (A i) (B j) = B.mul A.conj_transpose j i
theorem sub_mul_action.coe_image_orbit {R : Type u} {M : Type v} [monoid R] [mul_action R M] {p : sub_mul_action R M} (m : â†¥p) : coe '' mul_action.orbit R m = mul_action.orbit R â†‘m
theorem add_submonoid.closure_inductionâ‚‚ {M : Type u_1} [add_zero_class M] {s : set M} {p : M â†’ M â†’ Prop} {x y : M} (hx : x âˆˆ add_submonoid.closure s) (hy : y âˆˆ add_submonoid.closure s) (Hs : âˆ€ (x : M), x âˆˆ s â†’ âˆ€ (y : M), y âˆˆ s â†’ p x y) (H1_left : âˆ€ (x : M), p 0 x) (H1_right : âˆ€ (x : M), p x 0) (Hmul_left : âˆ€ (x y z : M), p x z â†’ p y z â†’ p (x + y) z) (Hmul_right : âˆ€ (x y z : M), p z x â†’ p z y â†’ p z (x + y)) : p x y
theorem is_compact.elim_directed_cover {Î± : Type u} [topological_space Î±] {s : set Î±} {Î¹ : Type v} [hÎ¹ : nonempty Î¹] (hs : is_compact s) (U : Î¹ â†’ set Î±) (hUo : âˆ€ (i : Î¹), is_open (U i)) (hsU : s âŠ† â‹ƒ (i : Î¹), U i) (hdU : directed has_subset.subset U) : âˆƒ (i : Î¹), s âŠ† U i
theorem uniform_space.has_basis_symmetric {Î± : Type u_1} [uniform_space Î±] : (uniformity Î±).has_basis (Î» (s : set (Î± Ã— Î±)), s âˆˆ uniformity Î± âˆ§ symmetric_rel s) id
theorem monotone_on.map_is_least {Î± : Type u} {Î² : Type v} [preorder Î±] [preorder Î²] {f : Î± â†’ Î²} {t : set Î±} (Hf : monotone_on f t) {a : Î±} (Ha : is_least t a) : is_least (f '' t) (f a)
theorem strict_convex.vadd {ğ•œ : Type u_1} {E : Type u_3} [ordered_semiring ğ•œ] [topological_space E] [add_comm_group E] [module ğ•œ E] [has_continuous_add E] {s : set E} (hs : strict_convex ğ•œ s) (x : E) : strict_convex ğ•œ (x +áµ¥ s)
theorem measure_theory.integrable.induction {Î± : Type u_1} {E : Type u_4} [measurable_space Î±] [normed_group E] {Î¼ : measure_theory.measure Î±} (P : (Î± â†’ E) â†’ Prop) (h_ind : âˆ€ (c : E) â¦ƒs : set Î±â¦„, measurable_set s â†’ â‡‘Î¼ s < âŠ¤ â†’ P (s.indicator (Î» (_x : Î±), c))) (h_add : âˆ€ â¦ƒf g : Î± â†’ Eâ¦„, disjoint (function.support f) (function.support g) â†’ measure_theory.integrable f Î¼ â†’ measure_theory.integrable g Î¼ â†’ P f â†’ P g â†’ P (f + g)) (h_closed : is_closed {f : â†¥(measure_theory.Lp E 1 Î¼) | P â‡‘f}) (h_ae : âˆ€ â¦ƒf g : Î± â†’ Eâ¦„, f =áµ[Î¼] g â†’ measure_theory.integrable f Î¼ â†’ P f â†’ P g) â¦ƒf : Î± â†’ Eâ¦„ (hf : measure_theory.integrable f Î¼) : P f
theorem euclidean_geometry.mul_dist_add_mul_dist_eq_mul_dist_of_cospherical {V : Type u_1} [inner_product_space â„ V] {P : Type u_2} [metric_space P] [normed_add_torsor V P] {a b c d p : P} (h : euclidean_geometry.cospherical {a, b, c, d}) (hapc : euclidean_geometry.angle a p c = real.pi) (hbpd : euclidean_geometry.angle b p d = real.pi) : has_dist.dist a b * has_dist.dist c d + has_dist.dist b c * has_dist.dist d a = has_dist.dist a c * has_dist.dist b d
theorem int.lt_zpow_iff_log_lt {R : Type u_1} [linear_ordered_field R] [floor_ring R] {b : â„•} (hb : 1 < b) {x : â„¤} {r : R} (hr : 0 < r) : r < â†‘b ^ x â†” int.log b r < x
theorem measurable_set.is_clopenable {Î± : Type u_1} [topological_space Î±] [polish_space Î±] [measurable_space Î±] [borel_space Î±] {s : set Î±} (hs : measurable_set s) : polish_space.is_clopenable s
theorem basis.mk_coord_apply {Î¹ : Type u_1} {R : Type u_3} {M : Type u_5} {v : Î¹ â†’ M} [ring R] [add_comm_group M] [module R M] {hli : linear_independent R v} {hsp : submodule.span R (set.range v) = âŠ¤} {i j : Î¹} : â‡‘((basis.mk hli hsp).coord i) (v j) = ite (j = i) 1 0
theorem nat.le_two_mul_of_factorization_central_binom_pos {p n : â„•} (h_pos : 0 < â‡‘(n.central_binom.factorization) p) : p â‰¤ 2 * n
theorem complex.two_pi_I_inv_smul_circle_integral_sub_inv_smul_of_differentiable_on_off_countable {E : Type u} [normed_group E] [normed_space â„‚ E] [complete_space E] {R : â„} {c w : â„‚} {f : â„‚ â†’ E} {s : set â„‚} (hs : s.countable) (hw : w âˆˆ metric.ball c R) (hc : continuous_on f (metric.closed_ball c R)) (hd : âˆ€ (x : â„‚), x âˆˆ metric.ball c R  s â†’ differentiable_at â„‚ f x) : (2 * â†‘real.pi * complex.I)â»Â¹ â€¢ âˆ® (z : â„‚) in C(c, R), (z - w)â»Â¹ â€¢ f z = f w
theorem measure_theory.ae_strongly_measurable'.ae_strongly_measurable'_of_measurable_space_le_on {Î± : Type u_1} {E : Type u_2} {m mâ‚‚ m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [topological_space E] [has_zero E] (hm : m â‰¤ m0) {s : set Î±} {f : Î± â†’ E} (hs_m : measurable_set s) (hs : âˆ€ (t : set Î±), measurable_set (s âˆ© t) â†’ measurable_set (s âˆ© t)) (hf : measure_theory.ae_strongly_measurable' m f Î¼) (hf_zero : f =áµ[Î¼.restrict sá¶œ] 0) : measure_theory.ae_strongly_measurable' mâ‚‚ f Î¼
theorem is_connected.bUnion_of_chain {Î± : Type u} {Î² : Type v} [topological_space Î±] [linear_order Î²] [succ_order Î²] [is_succ_archimedean Î²] {s : Î² â†’ set Î±} {t : set Î²} (hnt : t.nonempty) (ht : t.ord_connected) (H : âˆ€ (n : Î²), n âˆˆ t â†’ is_connected (s n)) (K : âˆ€ (n : Î²), n âˆˆ t â†’ order.succ n âˆˆ t â†’ (s n âˆ© s (order.succ n)).nonempty) : is_connected (â‹ƒ (n : Î²) (H : n âˆˆ t), s n)
theorem matrix.det_fin_two {R : Type v} [comm_ring R] (A : matrix (fin 2) (fin 2) R) : A.det = A 0 0 * A 1 1 - A 0 1 * A 1 0
theorem ennreal.ae_measurable_of_exist_almost_disjoint_supersets {Î± : Type u_1} {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) (f : Î± â†’ ennreal) (h : âˆ€ (p q : nnreal), p < q â†’ (âˆƒ (u v : set Î±), measurable_set u âˆ§ measurable_set v âˆ§ {x : Î± | f x < â†‘p} âŠ† u âˆ§ {x : Î± | â†‘q < f x} âŠ† v âˆ§ â‡‘Î¼ (u âˆ© v) = 0)) : ae_measurable f Î¼
theorem unique_mdiff_within_at.eq {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners ğ•œ E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] {f : M â†’ M'} {x : M} {s : set M} [Is : smooth_manifold_with_corners I M] [I's : smooth_manifold_with_corners I' M'] {f' fâ‚' : tangent_space I x â†’L[ğ•œ] tangent_space I' (f x)} (U : unique_mdiff_within_at I s x) (h : has_mfderiv_within_at I I' f s x f') (hâ‚ : has_mfderiv_within_at I I' f s x fâ‚') : f' = fâ‚'
theorem add_monoid.is_torsion.module_of_torsion (R : Type u_3) (M : Type u_4) [add_comm_monoid M] [semiring R] [module R M] (tR : add_monoid.is_torsion R) : add_monoid.is_torsion M
theorem filter.eventually.self_of_nhds {Î± : Type u} [topological_space Î±] {p : Î± â†’ Prop} {a : Î±} (h : âˆ€á¶  (y : Î±) in nhds a, p y) : p a
theorem of_quotient_center_nilpotent {G : Type u_1} [group G] (h : group.is_nilpotent (G â§¸ subgroup.center G)) : group.is_nilpotent G
theorem monovary.sum_comp_perm_mul_le_sum_mul {Î¹ : Type u_1} {Î± : Type u_2} [linear_ordered_ring Î±] {Ïƒ : equiv.perm Î¹} {f g : Î¹ â†’ Î±} [fintype Î¹] (hfg : monovary f g) : finset.univ.sum (Î» (i : Î¹), f (â‡‘Ïƒ i) * g i) â‰¤ finset.univ.sum (Î» (i : Î¹), f i * g i)
theorem is_submonoid.image {M : Type u_1} [monoid M] {Î³ : Type u_2} [monoid Î³] {f : M â†’ Î³} (hf : is_monoid_hom f) {s : set M} (hs : is_submonoid s) : is_submonoid (f '' s)
theorem linear_map.finrank_linear_map {K : Type u_1} [field K] {V : Type u_2} [add_comm_group V] [module K V] [finite_dimensional K V] {W : Type u_3} [add_comm_group W] [module K W] [finite_dimensional K W] : finite_dimensional.finrank K (V â†’â‚—[K] W) = finite_dimensional.finrank K V * finite_dimensional.finrank K W
theorem is_p_group.is_nilpotent {G : Type u_1} [hG : group G] [hf : fintype G] {p : â„•} [hp : fact (nat.prime p)] (h : is_p_group p G) : group.is_nilpotent G
theorem euclidean_geometry.cospherical_singleton {P : Type u_2} [metric_space P] (p : P) : euclidean_geometry.cospherical {p}
theorem generalized_continued_fraction.terminates_iff_rat {K : Type u_1} [linear_ordered_field K] [floor_ring K] (v : K) : (generalized_continued_fraction.of v).terminates â†” âˆƒ (q : â„š), v = â†‘q
theorem isometric.midpoint_fixed {E : Type u_1} {PE : Type u_2} [normed_group E] [normed_space â„ E] [metric_space PE] [normed_add_torsor E PE] {x y : PE} (e : PE â‰ƒáµ¢ PE) : â‡‘e x = x â†’ â‡‘e y = y â†’ â‡‘e (midpoint â„ x y) = midpoint â„ x y
theorem is_cyclotomic_extension.union_left (S T : set â„•+) (A : Type u) (B : Type v) [comm_ring A] [comm_ring B] [algebra A B] [h : is_cyclotomic_extension T A B] (hS : S âŠ† T) : is_cyclotomic_extension S A â†¥(algebra.adjoin A {b : B | âˆƒ (a : â„•+), a âˆˆ S âˆ§ b ^ â†‘a = 1})
theorem is_unit.is_smul_regular {R : Type u_1} (M : Type u_3) {a : R} [monoid R] [mul_action R M] (ua : is_unit a) : is_smul_regular M a
theorem euclidean_geometry.exists_of_range_subset_orthocentric_system {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {t : affine.triangle â„ P} (ho : t.orthocenter âˆ‰ set.range t.points) {p : fin 3 â†’ P} (hps : set.range p âŠ† has_insert.insert t.orthocenter (set.range t.points)) (hpi : function.injective p) : (âˆƒ (iâ‚ iâ‚‚ iâ‚ƒ jâ‚‚ jâ‚ƒ : fin 3), iâ‚ â‰  iâ‚‚ âˆ§ iâ‚ â‰  iâ‚ƒ âˆ§ iâ‚‚ â‰  iâ‚ƒ âˆ§ (âˆ€ (i : fin 3), i = iâ‚ âˆ¨ i = iâ‚‚ âˆ¨ i = iâ‚ƒ) âˆ§ p iâ‚ = t.orthocenter âˆ§ jâ‚‚ â‰  jâ‚ƒ âˆ§ t.points jâ‚‚ = p iâ‚‚ âˆ§ t.points jâ‚ƒ = p iâ‚ƒ) âˆ¨ set.range p = set.range t.points
theorem submodule.finite_span_is_compact_element {R : Type u_1} {M : Type u_4} [semiring R] [add_comm_monoid M] [module R M] (S : set M) (h : S.finite) : complete_lattice.is_compact_element (submodule.span R S)
theorem nat.arithmetic_function.is_multiplicative.multiplicative_factorization {R : Type u_1} [comm_monoid_with_zero R] (f : nat.arithmetic_function R) (hf : f.is_multiplicative) {n : â„•} : n â‰  0 â†’ â‡‘f n = n.factorization.prod (Î» (p k : â„•), â‡‘f (p ^ k))
theorem metric.mk_uniformity_basis_le {Î± : Type u} [pseudo_metric_space Î±] {Î² : Type u_1} {p : Î² â†’ Prop} {f : Î² â†’ â„} (hfâ‚€ : âˆ€ (x : Î²), p x â†’ 0 < f x) (hf : âˆ€ (Îµ : â„), 0 < Îµ â†’ (âˆƒ (x : Î²) (hx : p x), f x â‰¤ Îµ)) : (uniformity Î±).has_basis p (Î» (x : Î²), {p : Î± Ã— Î± | has_dist.dist p.fst p.snd â‰¤ f x})
theorem well_founded.has_min {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} (H : well_founded r) (s : set Î±) : s.nonempty â†’ (âˆƒ (a : Î±) (H : a âˆˆ s), âˆ€ (x : Î±), x âˆˆ s â†’ Â¬r x a)
theorem orthonormal.orthonormal_adjust_to_orientation {E : Type u_1} [inner_product_space â„ E] {Î¹ : Type u_2} [fintype Î¹] [decidable_eq Î¹] [nonempty Î¹] {e : basis Î¹ â„ E} (h : orthonormal â„ â‡‘e) (x : orientation â„ E Î¹) : orthonormal â„ â‡‘(e.adjust_to_orientation x)
theorem asymptotics.is_O_const_left_iff_pos_le_norm {Î± : Type u_1} {E' : Type u_6} {E'' : Type u_9} [semi_normed_group E'] [normed_group E''] {f' : Î± â†’ E'} {l : filter Î±} {c : E''} (hc : c â‰  0) : (Î» (x : Î±), c) =O[l] f' â†” âˆƒ (b : â„), 0 < b âˆ§ âˆ€á¶  (x : Î±) in l, b â‰¤ âˆ¥f' xâˆ¥
theorem add_order_of_nsmul {G : Type u} {n : â„•} [fintype G] [add_left_cancel_monoid G] (x : G) : add_order_of (n â€¢ x) = add_order_of x / (add_order_of x).gcd n
theorem measure_theory.measure.ext_of_Ico {Î± : Type u_1} [topological_space Î±] {m : measurable_space Î±} [topological_space.second_countable_topology Î±] [conditionally_complete_linear_order Î±] [order_topology Î±] [borel_space Î±] [no_max_order Î±] (Î¼ Î½ : measure_theory.measure Î±) [measure_theory.is_locally_finite_measure Î¼] (h : âˆ€ â¦ƒa b : Î±â¦„, a < b â†’ â‡‘Î¼ (set.Ico a b) = â‡‘Î½ (set.Ico a b)) : Î¼ = Î½
theorem open_map_of_strict_deriv {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] [complete_space ğ•œ] {f f' : ğ•œ â†’ ğ•œ} (hf : âˆ€ (x : ğ•œ), has_strict_deriv_at f (f' x) x) (h0 : âˆ€ (x : ğ•œ), f' x â‰  0) : is_open_map f
theorem ideal.comap_eq_of_scalar_tower_quotient {R : Type u_1} [comm_ring R] {S : Type u_2} [comm_ring S] {p : ideal R} {P : ideal S} [algebra R S] [algebra (R â§¸ p) (S â§¸ P)] [is_scalar_tower R (R â§¸ p) (S â§¸ P)] (h : function.injective â‡‘(algebra_map (R â§¸ p) (S â§¸ P))) : ideal.comap (algebra_map R S) P = p
theorem submonoid.localization_map.lift_left_inverse {M : Type u_1} [comm_monoid M] {S : submonoid M} {N : Type u_2} [comm_monoid N] {P : Type u_3} [comm_monoid P] (f : S.localization_map N) {k : S.localization_map P} (z : N) : â‡‘(k.lift _) (â‡‘(f.lift _) z) = z
theorem box_integral.prepartition.card_filter_mem_Icc_le {Î¹ : Type u_1} {I : box_integral.box Î¹} (Ï€ : box_integral.prepartition I) [fintype Î¹] (x : Î¹ â†’ â„) : (finset.filter (Î» (J : box_integral.box Î¹), x âˆˆ â‡‘box_integral.box.Icc J) Ï€.boxes).card â‰¤ 2 ^ fintype.card Î¹
theorem continuous_at_of_locally_lipschitz {Î± : Type u} {Î² : Type v} [pseudo_metric_space Î±] [pseudo_metric_space Î²] {f : Î± â†’ Î²} {x : Î±} {r : â„} (hr : 0 < r) (K : â„) (h : âˆ€ (y : Î±), has_dist.dist y x < r â†’ has_dist.dist (f y) (f x) â‰¤ K * has_dist.dist y x) : continuous_at f x
theorem measure_theory.measure.eventually_nonempty_inter_smul_of_density_one {E : Type u_1} [normed_group E] [measurable_space E] [normed_space â„ E] [finite_dimensional â„ E] [borel_space E] (Î¼ : measure_theory.measure E) [Î¼.is_add_haar_measure] (s : set E) (x : E) (h : filter.tendsto (Î» (r : â„), â‡‘Î¼ (s âˆ© metric.closed_ball x r) / â‡‘Î¼ (metric.closed_ball x r)) (nhds_within 0 (set.Ioi 0)) (nhds 1)) (t : set E) (ht : measurable_set t) (h't : â‡‘Î¼ t â‰  0) : âˆ€á¶  (r : â„) in nhds_within 0 (set.Ioi 0), (s âˆ© ({x} + r â€¢ t)).nonempty
theorem setoid.ker_lift_injective {Î± : Type u_1} {Î² : Type u_2} (f : Î± â†’ Î²) : function.injective (quotient.lift f _)
theorem convex.norm_image_sub_le_of_norm_deriv_le {ğ•œ : Type u_3} {G : Type u_4} [is_R_or_C ğ•œ] [normed_group G] [normed_space ğ•œ G] {f : ğ•œ â†’ G} {s : set ğ•œ} {x y : ğ•œ} {C : â„} (hf : âˆ€ (x : ğ•œ), x âˆˆ s â†’ differentiable_at ğ•œ f x) (bound : âˆ€ (x : ğ•œ), x âˆˆ s â†’ âˆ¥deriv f xâˆ¥ â‰¤ C) (hs : convex â„ s) (xs : x âˆˆ s) (ys : y âˆˆ s) : âˆ¥f y - f xâˆ¥ â‰¤ C * âˆ¥y - xâˆ¥
theorem linear_map.range_lt_top_of_det_eq_zero {M : Type u_2} [add_comm_group M] {ğ•œ : Type u_1} [field ğ•œ] [module ğ•œ M] {f : M â†’â‚—[ğ•œ] M} (hf : â‡‘linear_map.det f = 0) : f.range < âŠ¤
theorem emetric.cauchy_seq_iff_le_tendsto_0 {Î± : Type u_1} {Î² : Type u_2} [pseudo_emetric_space Î±] [nonempty Î²] [semilattice_sup Î²] {s : Î² â†’ Î±} : cauchy_seq s â†” âˆƒ (b : Î² â†’ ennreal), (âˆ€ (n m N : Î²), N â‰¤ n â†’ N â‰¤ m â†’ has_edist.edist (s n) (s m) â‰¤ b N) âˆ§ filter.tendsto b filter.at_top (nhds 0)
theorem tendsto_diag_uniformity {Î± : Type u_1} {Î² : Type u_2} [uniform_space Î±] (f : Î² â†’ Î±) (l : filter Î²) : filter.tendsto (Î» (x : Î²), (f x, f x)) l (uniformity Î±)
theorem set.finite.pi {Î´ : Type u_1} [fintype Î´] {Îº : Î´ â†’ Type u_2} {t : Î  (d : Î´), set (Îº d)} (ht : âˆ€ (d : Î´), (t d).finite) : (set.univ.pi t).finite
theorem con.ker_rel {M : Type u_1} {P : Type u_3} [mul_one_class M] [mul_one_class P] (f : M â†’* P) {x y : M} : â‡‘(con.ker f) x y â†” â‡‘f x = â‡‘f y
theorem category_theory.le_topology_of_closed_sieves_is_sheaf {C : Type u} [category_theory.category C] {Jâ‚ Jâ‚‚ : category_theory.grothendieck_topology C} (h : category_theory.presieve.is_sheaf Jâ‚ (category_theory.functor.closed_sieves Jâ‚‚)) : Jâ‚ â‰¤ Jâ‚‚
theorem subsingleton_rat_module (E : Type u_1) [add_comm_group E] : subsingleton (module â„š E)
theorem orthonormal.eq_rotation_self_iff {V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) (x : V) (Î¸ : real.angle) : x = â‡‘(hb.rotation Î¸) x â†” x = 0 âˆ¨ Î¸ = 0
theorem measure_theory.measure.inner_regular.is_compact_is_closed {X : Type u_1} [topological_space X] [sigma_compact_space X] [measurable_space X] (Î¼ : measure_theory.measure X) : Î¼.inner_regular is_compact is_closed
theorem is_connected_iff_sUnion_disjoint_open {Î± : Type u} [topological_space Î±] {s : set Î±} : is_connected s â†” âˆ€ (U : finset (set Î±)), (âˆ€ (u v : set Î±), u âˆˆ U â†’ v âˆˆ U â†’ (s âˆ© (u âˆ© v)).nonempty â†’ u = v) â†’ (âˆ€ (u : set Î±), u âˆˆ U â†’ is_open u) â†’ s âŠ† â‹ƒâ‚€â†‘U â†’ (âˆƒ (u : set Î±) (H : u âˆˆ U), s âŠ† u)
theorem add_subgroup.sum_mem {G : Type u_1} [add_comm_group G] (K : add_subgroup G) {Î¹ : Type u_2} {t : finset Î¹} {f : Î¹ â†’ G} (h : âˆ€ (c : Î¹), c âˆˆ t â†’ f c âˆˆ K) : t.sum (Î» (c : Î¹), f c) âˆˆ K
theorem gram_schmidt_def (ğ•œ : Type u_1) {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {Î¹ : Type u_3} [linear_order Î¹] [order_bot Î¹] [locally_finite_order Î¹] [is_well_order Î¹ has_lt.lt] (f : Î¹ â†’ E) (n : Î¹) : gram_schmidt ğ•œ f n = f n - (finset.Iio n).sum (Î» (i : Î¹), â†‘(â‡‘(orthogonal_projection (submodule.span ğ•œ {gram_schmidt ğ•œ f i})) (f n)))
theorem category_theory.limits.image.pre_comp_comp {C : Type u} [category_theory.category C] {X Y : C} (f : X âŸ¶ Y) {Z : C} (g : Y âŸ¶ Z) {W : C} (h : Z âŸ¶ W) [category_theory.limits.has_image (g â‰« h)] [category_theory.limits.has_image (f â‰« g â‰« h)] [category_theory.limits.has_image h] [category_theory.limits.has_image ((f â‰« g) â‰« h)] : category_theory.limits.image.pre_comp f (g â‰« h) â‰« category_theory.limits.image.pre_comp g h = category_theory.limits.image.eq_to_hom _ â‰« category_theory.limits.image.pre_comp (f â‰« g) h
theorem list.nat.nodup_antidiagonal (n : â„•) : (list.nat.antidiagonal n).nodup
theorem formal_multilinear_series.continuous_on {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field ğ•œ] [normed_group E] [normed_space ğ•œ E] [normed_group F] [normed_space ğ•œ F] {p : formal_multilinear_series ğ•œ E F} [complete_space F] : continuous_on p.sum (emetric.ball 0 p.radius)
theorem category_theory.limits.complete_lattice.finite_limit_eq_finset_univ_inf {Î± J : Type u} [category_theory.small_category J] [category_theory.fin_category J] [semilattice_inf Î±] [order_top Î±] (F : J â¥¤ Î±) : category_theory.limits.limit F = finset.univ.inf F.obj
theorem measure_theory.L1.norm_sub_eq_lintegral {Î± : Type u_1} {Î² : Type u_2} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [normed_group Î²] (f g : â†¥(measure_theory.Lp Î² 1 Î¼)) : âˆ¥f - gâˆ¥ = (âˆ«â» (x : Î±), â†‘âˆ¥â‡‘f x - â‡‘g xâˆ¥â‚Š âˆ‚Î¼).to_real
theorem nnnorm_pow_le {Î± : Type u_1} [semi_normed_ring Î±] [norm_one_class Î±] (a : Î±) (n : â„•) : âˆ¥a ^ nâˆ¥â‚Š â‰¤ âˆ¥aâˆ¥â‚Š ^ n
theorem is_free_groupoid.ext_functor {G : Type u_1} [category_theory.groupoid G] [is_free_groupoid G] {X : Type v} [group X] (f g : G â¥¤ category_theory.single_obj X) (h : âˆ€ (a b : is_free_groupoid.generators G) (e : a âŸ¶ b), f.map (is_free_groupoid.of e) = g.map (is_free_groupoid.of e)) : f = g
theorem polynomial.cyclotomic_nonneg (n : â„•) {R : Type u_1} [linear_ordered_comm_ring R] {x : R} (hx : 1 â‰¤ x) : 0 â‰¤ polynomial.eval x (polynomial.cyclotomic n R)
theorem matrix.list_prod_inv_reverse {n : Type u'} {Î± : Type v} [fintype n] [decidable_eq n] [comm_ring Î±] (l : list (matrix n n Î±)) : (l.prod)â»Â¹ = (list.map has_inv.inv l.reverse).prod
theorem ideal.maximal_of_no_maximal {R : Type u} [semiring R] {P : ideal R} (hmax : âˆ€ (m : ideal R), P < m â†’ Â¬m.is_maximal) (J : ideal R) (hPJ : P < J) : J = âŠ¤
theorem category_theory.presheaf.is_sheaf_iff_is_limit_pretopology {C : Type uâ‚} [category_theory.category C] {A : Type uâ‚‚} [category_theory.category A] (P : Cáµ’áµ– â¥¤ A) [category_theory.limits.has_pullbacks C] (K : category_theory.pretopology C) : category_theory.presheaf.is_sheaf (category_theory.pretopology.to_grothendieck C K) P â†” âˆ€ â¦ƒX : Câ¦„ (R : category_theory.presieve X), R âˆˆ â‡‘K X â†’ nonempty (category_theory.limits.is_limit (P.map_cone (category_theory.sieve.generate R).arrows.cocone.op))
theorem measure_theory.integral_divergence_of_has_fderiv_within_at_off_countable_auxâ‚‚ {E : Type u} [normed_group E] [normed_space â„ E] [complete_space E] {n : â„•} (I : box_integral.box (fin (n + 1))) (f : (fin (n + 1) â†’ â„) â†’ fin (n + 1) â†’ E) (f' : (fin (n + 1) â†’ â„) â†’ ((fin (n + 1) â†’ â„) â†’L[â„] fin (n + 1) â†’ E)) (s : set (fin (n + 1) â†’ â„)) (hs : s.countable) (Hc : continuous_on f (â‡‘box_integral.box.Icc I)) (Hd : âˆ€ (x : fin (n + 1) â†’ â„), x âˆˆ â‡‘box_integral.box.Ioo I  s â†’ has_fderiv_at f (f' x) x) (Hi : measure_theory.integrable_on (Î» (x : fin (n + 1) â†’ â„), finset.univ.sum (Î» (i : fin (n + 1)), â‡‘(f' x) (pi.single i 1) i)) (â‡‘box_integral.box.Icc I) measure_theory.measure_space.volume) : âˆ« (x : fin (n + 1) â†’ â„) in â‡‘box_integral.box.Icc I, finset.univ.sum (Î» (i : fin (n + 1)), â‡‘(f' x) (pi.single i 1) i) = finset.univ.sum (Î» (i : fin (n + 1)), (âˆ« (x : fin n â†’ â„) in â‡‘box_integral.box.Icc (I.face i), f (i.insert_nth (I.upper i) x) i) - âˆ« (x : fin n â†’ â„) in â‡‘box_integral.box.Icc (I.face i), f (i.insert_nth (I.lower i) x) i)
theorem modular_group.abs_c_le_one {g : matrix.special_linear_group (fin 2) â„¤} {z : upper_half_plane} (hz : z âˆˆ modular_group.fdo) (hg : g â€¢ z âˆˆ modular_group.fdo) : |â†‘g 1 0| â‰¤ 1
theorem direct_sum.to_module_lof (R : Type u) [semiring R] {Î¹ : Type v} [dec_Î¹ : decidable_eq Î¹] {M : Î¹ â†’ Type w} [Î  (i : Î¹), add_comm_monoid (M i)] [Î  (i : Î¹), module R (M i)] {N : Type uâ‚} [add_comm_monoid N] [module R N] {Ï† : Î  (i : Î¹), M i â†’â‚—[R] N} (i : Î¹) (x : M i) : â‡‘(direct_sum.to_module R Î¹ N Ï†) (â‡‘(direct_sum.lof R Î¹ M i) x) = â‡‘(Ï† i) x
theorem submodule.smul_sup_le_of_le_smul_of_le_jacobson_bot {R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] {I : ideal R} {N N' : submodule R M} (hN' : N'.fg) (hIJ : I â‰¤ âŠ¥.jacobson) (hNN : N âŠ” N' â‰¤ N âŠ” I â€¢ N') : I â€¢ N' â‰¤ N
theorem finset.eq_zero_of_sum_eq_zero {Î² : Type u} {Î± : Type v} [add_comm_monoid Î²] {s : finset Î±} {f : Î± â†’ Î²} {a : Î±} (hp : s.sum (Î» (x : Î±), f x) = 0) (h1 : âˆ€ (x : Î±), x âˆˆ s â†’ x â‰  a â†’ f x = 0) (x : Î±) (H : x âˆˆ s) : f x = 0
theorem inv_int_cast_smul_eq {E : Type u_1} (R : Type u_2) (S : Type u_3) [add_comm_group E] [division_ring R] [division_ring S] [module R E] [module S E] (n : â„¤) (x : E) : (â†‘n)â»Â¹ â€¢ x = (â†‘n)â»Â¹ â€¢ x
theorem add_monoid_hom.continuous_of_bound {E : Type u_3} {F : Type u_4} [semi_normed_group E] [semi_normed_group F] (f : E â†’+ F) (C : â„) (h : âˆ€ (x : E), âˆ¥â‡‘f xâˆ¥ â‰¤ C * âˆ¥xâˆ¥) : continuous â‡‘f
theorem is_metric_separated.finset_Union_right {X : Type u_1} [emetric_space X] {Î¹ : Type u_2} {I : finset Î¹} {s : set X} {t : Î¹ â†’ set X} : (âˆ€ (i : Î¹), i âˆˆ I â†’ is_metric_separated s (t i)) â†’ is_metric_separated s (â‹ƒ (i : Î¹) (H : i âˆˆ I), t i)
theorem metric.cthickening_subset_thickening' {Î± : Type u} [pseudo_emetric_space Î±] {Î´â‚ Î´â‚‚ : â„} (Î´â‚‚_pos : 0 < Î´â‚‚) (hlt : Î´â‚ < Î´â‚‚) (E : set Î±) : metric.cthickening Î´â‚ E âŠ† metric.thickening Î´â‚‚ E
theorem continuous_map.continuous_of_continuous_uncurry {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [topological_space Î±] [topological_space Î²] [topological_space Î³] (f : Î± â†’ C(Î², Î³)) (h : continuous (function.uncurry (Î» (x : Î±) (y : Î²), â‡‘(f x) y))) : continuous f
theorem exists_compact_between {Î± : Type u} [topological_space Î±] [locally_compact_space Î±] [regular_space Î±] {K U : set Î±} (hK : is_compact K) (hU : is_open U) (hKU : K âŠ† U) : âˆƒ (K' : set Î±), is_compact K' âˆ§ K âŠ† interior K' âˆ§ K' âŠ† U
theorem complex.mem_roots_of_unity (n : â„•+) (x : â„‚Ë£) : x âˆˆ roots_of_unity n â„‚ â†” âˆƒ (i : â„•) (H : i < â†‘n), complex.exp (2 * â†‘real.pi * complex.I * (â†‘i / â†‘n)) = â†‘x
theorem collinear_iff_not_affine_independent (k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] (p : fin 3 â†’ P) : collinear k (set.range p) â†” Â¬affine_independent k p
theorem continuous_on.mono_dom {Î± : Type u_1} {Î² : Type u_2} {tâ‚ tâ‚‚ : topological_space Î±} {tâ‚ƒ : topological_space Î²} (hâ‚ : tâ‚‚ â‰¤ tâ‚) {s : set Î±} {f : Î± â†’ Î²} (hâ‚‚ : continuous_on f s) : continuous_on f s
theorem cont_mdiff_within_at.comp' {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners ğ•œ E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] {f : M â†’ M'} {s : set M} {n : with_top â„•} {E'' : Type u_14} [normed_group E''] [normed_space ğ•œ E''] {H'' : Type u_15} [topological_space H''] {I'' : model_with_corners ğ•œ E'' H''} {M'' : Type u_16} [topological_space M''] [charted_space H'' M''] {t : set M'} {g : M' â†’ M''} (x : M) (hg : cont_mdiff_within_at I' I'' n g t (f x)) (hf : cont_mdiff_within_at I I' n f s x) : cont_mdiff_within_at I I'' n (g âˆ˜ f) (s âˆ© f â»Â¹' t) x
theorem strict_mono_on.continuous_at_right_of_exists_between {Î± : Type u_1} {Î² : Type u_2} [linear_order Î±] [topological_space Î±] [order_topology Î±] [linear_order Î²] [topological_space Î²] [order_topology Î²] {f : Î± â†’ Î²} {s : set Î±} {a : Î±} (h_mono : strict_mono_on f s) (hs : s âˆˆ nhds_within a (set.Ici a)) (hfs : âˆ€ (b : Î²), b > f a â†’ (âˆƒ (c : Î±) (H : c âˆˆ s), f c âˆˆ set.Ioc (f a) b)) : continuous_within_at f (set.Ici a) a
theorem algebraic_geometry.PresheafedSpace.comp_c_app {C : Type u} [category_theory.category C] {X Y Z : algebraic_geometry.PresheafedSpace C} (Î± : X âŸ¶ Y) (Î² : Y âŸ¶ Z) (U : (topological_space.opens â†¥(Z.carrier))áµ’áµ–) : (Î± â‰« Î²).c.app U = Î².c.app U â‰« Î±.c.app (opposite.op ((topological_space.opens.map Î².base).obj (opposite.unop U)))
theorem nat.factorial_mul_desc_factorial {n k : â„•} : k â‰¤ n â†’ (n - k).factorial * n.desc_factorial k = n.factorial
theorem cardinal.mk_Ioo_real {a b : â„} (h : a < b) : cardinal.mk â†¥(set.Ioo a b) = cardinal.continuum
theorem continuous_at.fst' {Î± : Type u} {Î² : Type v} {Î³ : Type u_1} [topological_space Î±] [topological_space Î²] [topological_space Î³] {f : Î± â†’ Î³} {x : Î±} {y : Î²} (hf : continuous_at f x) : continuous_at (Î» (x : Î± Ã— Î²), f x.fst) (x, y)
theorem measure_theory.measure.restrict_Inf_eq_Inf_restrict {Î± : Type u_1} {t : set Î±} {m0 : measurable_space Î±} {m : set (measure_theory.measure Î±)} (hm : m.nonempty) (ht : measurable_set t) : (has_Inf.Inf m).restrict t = has_Inf.Inf ((Î» (Î¼ : measure_theory.measure Î±), Î¼.restrict t) '' m)
theorem iterated_deriv_within_succ {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {F : Type u_2} [normed_group F] [normed_space ğ•œ F] {n : â„•} {f : ğ•œ â†’ F} {s : set ğ•œ} {x : ğ•œ} (hxs : unique_diff_within_at ğ•œ s x) : iterated_deriv_within (n + 1) f s x = deriv_within (iterated_deriv_within n f s) s x
theorem direct_sum.is_internal.subordinate_orthonormal_basis_orthonormal {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] [finite_dimensional ğ•œ E] {n : â„•} (hn : finite_dimensional.finrank ğ•œ E = n) {Î¹ : Type u_4} [fintype Î¹] [decidable_eq Î¹] {V : Î¹ â†’ submodule ğ•œ E} (hV : direct_sum.is_internal V) (hV' : orthogonal_family ğ•œ (Î» (i : Î¹), (V i).subtypeâ‚—áµ¢)) : orthonormal ğ•œ â‡‘(direct_sum.is_internal.subordinate_orthonormal_basis hn hV)
theorem has_fpower_series_on_ball.tendsto_locally_uniformly_on {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field ğ•œ] [normed_group E] [normed_space ğ•œ E] [normed_group F] [normed_space ğ•œ F] {f : E â†’ F} {p : formal_multilinear_series ğ•œ E F} {x : E} {r : ennreal} (hf : has_fpower_series_on_ball f p x r) : tendsto_locally_uniformly_on (Î» (n : â„•) (y : E), p.partial_sum n y) (Î» (y : E), f (x + y)) filter.at_top (emetric.ball 0 r)
theorem emetric.continuous_inf_edist_Hausdorff_edist {Î± : Type u} [emetric_space Î±] : continuous (Î» (p : Î± Ã— topological_space.closeds Î±), emetric.inf_edist p.fst â†‘(p.snd))
theorem direct_sum.mk_smul (R : Type u) [semiring R] {Î¹ : Type v} [dec_Î¹ : decidable_eq Î¹] {M : Î¹ â†’ Type w} [Î  (i : Î¹), add_comm_monoid (M i)] [Î  (i : Î¹), module R (M i)] (s : finset Î¹) (c : R) (x : Î  (i : â†¥â†‘s), M i.val) : â‡‘(direct_sum.mk M s) (c â€¢ x) = c â€¢ â‡‘(direct_sum.mk M s) x
theorem edist_le_of_edist_le_geometric_of_tendsto {Î± : Type u_1} [pseudo_emetric_space Î±] (r C : ennreal) {f : â„• â†’ Î±} (hu : âˆ€ (n : â„•), has_edist.edist (f n) (f (n + 1)) â‰¤ C * r ^ n) {a : Î±} (ha : filter.tendsto f filter.at_top (nhds a)) (n : â„•) : has_edist.edist (f n) a â‰¤ C * r ^ n / (1 - r)
theorem collinear_pair (k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] (pâ‚ pâ‚‚ : P) : collinear k {pâ‚, pâ‚‚}
theorem finset.shadow_empty {Î± : Type u_1} [decidable_eq Î±] : âˆ….shadow = âˆ…
theorem lie_subalgebra.exists_nested_lie_ideal_of_le_normalizer {R : Type u_1} {L : Type u_2} [comm_ring R] [lie_ring L] [lie_algebra R L] {H K : lie_subalgebra R L} (hâ‚ : H â‰¤ K) (hâ‚‚ : K â‰¤ H.normalizer) : âˆƒ (I : lie_ideal R â†¥K), â†‘I = lie_subalgebra.of_le hâ‚
theorem is_smul_regular.of_smul {R : Type u_1} {S : Type u_2} {M : Type u_3} {s : S} [has_scalar R M] [has_scalar R S] [has_scalar S M] [is_scalar_tower R S M] (a : R) (ab : is_smul_regular M (a â€¢ s)) : is_smul_regular M s
theorem norm_sub_le_of_geometric_bound_of_has_sum {Î± : Type u_1} [semi_normed_group Î±] {r C : â„} {f : â„• â†’ Î±} (hr : r < 1) (hf : âˆ€ (n : â„•), âˆ¥f nâˆ¥ â‰¤ C * r ^ n) {a : Î±} (ha : has_sum f a) (n : â„•) : âˆ¥(finset.range n).sum (Î» (x : â„•), f x) - aâˆ¥ â‰¤ C * r ^ n / (1 - r)
theorem AddMon.filtered_colimits.colimit_add_aux_eq_of_rel_left {J : Type v} [category_theory.small_category J] (F : J â¥¤ AddMon) [category_theory.is_filtered J] {x x' y : Î£ (j : J), â†¥(F.obj j)} (hxx' : category_theory.limits.types.filtered_colimit.rel (F â‹™ category_theory.forget AddMon) x x') : AddMon.filtered_colimits.colimit_add_aux F x y = AddMon.filtered_colimits.colimit_add_aux F x' y
theorem list.length_pos_of_prod_lt_one {M : Type u_3} [monoid M] [preorder M] (L : list M) (h : L.prod < 1) : 0 < L.length
theorem is_GÎ´.union {Î± : Type u_1} [topological_space Î±] {s t : set Î±} (hs : is_GÎ´ s) (ht : is_GÎ´ t) : is_GÎ´ (s âˆª t)
theorem antivary_on.sum_mul_eq_sum_comp_perm_mul_iff {Î¹ : Type u_1} {Î± : Type u_2} [linear_ordered_ring Î±] {s : finset Î¹} {Ïƒ : equiv.perm Î¹} {f g : Î¹ â†’ Î±} (hfg : antivary_on f g â†‘s) (hÏƒ : {x : Î¹ | â‡‘Ïƒ x â‰  x} âŠ† â†‘s) : s.sum (Î» (i : Î¹), f (â‡‘Ïƒ i) * g i) = s.sum (Î» (i : Î¹), f i * g i) â†” antivary_on (f âˆ˜ â‡‘Ïƒ) g â†‘s
theorem first_order.language.direct_limit.cg {L : first_order.language} {Î¹ : Type u_3} [encodable Î¹] [preorder Î¹] [is_directed Î¹ has_le.le] [nonempty Î¹] {G : Î¹ â†’ Type w} [Î  (i : Î¹), L.Structure (G i)] (f : Î  (i j : Î¹), i â‰¤ j â†’ L.embedding (G i) (G j)) (h : âˆ€ (i : Î¹), first_order.language.Structure.cg L (G i)) [directed_system G (Î» (i j : Î¹) (h : i â‰¤ j), â‡‘(f i j h))] : first_order.language.Structure.cg L (first_order.language.direct_limit G f)
theorem orientation.oangle_zero_left {V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) (x : V) : o.oangle 0 x = 0
theorem nat.totient_eq_div_factors_mul (n : â„•) : n.totient = n / n.factors.to_finset.prod (Î» (p : â„•), p) * n.factors.to_finset.prod (Î» (p : â„•), p - 1)
theorem orientation.oangle_smul_right_self_of_nonneg {V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) (x : V) {r : â„} (hr : 0 â‰¤ r) : o.oangle x (r â€¢ x) = 0
theorem category_theory.is_coreflexive_pair.swap {C : Type u} [category_theory.category C] {A B : C} {f g : A âŸ¶ B} [category_theory.is_coreflexive_pair f g] : category_theory.is_coreflexive_pair g f
theorem is_integral_of_mem_closure' {R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] (G : set A) (hG : âˆ€ (x : A), x âˆˆ G â†’ is_integral R x) (x : A) (H : x âˆˆ subring.closure G) : is_integral R x
theorem antivary.sum_mul_eq_sum_mul_comp_perm_iff {Î¹ : Type u_1} {Î± : Type u_2} [linear_ordered_ring Î±] {Ïƒ : equiv.perm Î¹} {f g : Î¹ â†’ Î±} [fintype Î¹] (hfg : antivary f g) : finset.univ.sum (Î» (i : Î¹), f i * g (â‡‘Ïƒ i)) = finset.univ.sum (Î» (i : Î¹), f i * g i) â†” antivary f (g âˆ˜ â‡‘Ïƒ)
theorem category_theory.has_limits_of_has_limits_creates_limits {C : Type uâ‚} [category_theory.category C] {D : Type uâ‚‚} [category_theory.category D] (F : C â¥¤ D) [category_theory.limits.has_limits_of_size D] [category_theory.creates_limits_of_size F] : category_theory.limits.has_limits_of_size C
theorem real.not_summable_one_div_nat_cast  : Â¬summable (Î» (n : â„•), 1 / â†‘n)
theorem vitali_family.le_mul_with_density {Î± : Type u_1} [metric_space Î±] {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (v : vitali_family Î¼) [sigma_compact_space Î±] [borel_space Î±] [measure_theory.is_locally_finite_measure Î¼] {Ï : measure_theory.measure Î±} [measure_theory.is_locally_finite_measure Ï] (hÏ : Ï.absolutely_continuous Î¼) {s : set Î±} (hs : measurable_set s) {t : nnreal} (ht : 1 < t) : â‡‘Ï s â‰¤ â†‘t * â‡‘(Î¼.with_density (v.lim_ratio_meas hÏ)) s
theorem category_theory.normal_mono_category.epi_of_zero_cancel {C : Type u_1} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_finite_products C] [category_theory.limits.has_kernels C] [category_theory.normal_mono_category C] [category_theory.limits.has_zero_object C] {X Y : C} (f : X âŸ¶ Y) (hf : âˆ€ (Z : C) (g : Y âŸ¶ Z), f â‰« g = 0 â†’ g = 0) : category_theory.epi f
theorem power_series.ext {R : Type u_1} [semiring R] {Ï† Ïˆ : power_series R} (h : âˆ€ (n : â„•), â‡‘(power_series.coeff R n) Ï† = â‡‘(power_series.coeff R n) Ïˆ) : Ï† = Ïˆ
theorem submodule.topological_closure_map {Râ‚ : Type u_1} {Râ‚‚ : Type u_2} [semiring Râ‚] [semiring Râ‚‚] {Ïƒâ‚â‚‚ : Râ‚ â†’+* Râ‚‚} {Mâ‚ : Type u_4} [topological_space Mâ‚] [add_comm_monoid Mâ‚] {Mâ‚‚ : Type u_6} [topological_space Mâ‚‚] [add_comm_monoid Mâ‚‚] [module Râ‚ Mâ‚] [module Râ‚‚ Mâ‚‚] [ring_hom_surjective Ïƒâ‚â‚‚] [topological_space Râ‚] [topological_space Râ‚‚] [has_continuous_smul Râ‚ Mâ‚] [has_continuous_add Mâ‚] [has_continuous_smul Râ‚‚ Mâ‚‚] [has_continuous_add Mâ‚‚] (f : Mâ‚ â†’SL[Ïƒâ‚â‚‚] Mâ‚‚) (s : submodule Râ‚ Mâ‚) : submodule.map â†‘f s.topological_closure â‰¤ (submodule.map â†‘f s).topological_closure
theorem convex_iff_pointwise_add_subset {ğ•œ : Type u_1} {E : Type u_2} [ordered_semiring ğ•œ] [add_comm_monoid E] [has_scalar ğ•œ E] {s : set E} : convex ğ•œ s â†” âˆ€ â¦ƒa b : ğ•œâ¦„, 0 â‰¤ a â†’ 0 â‰¤ b â†’ a + b = 1 â†’ a â€¢ s + b â€¢ s âŠ† s
theorem measure_theory.integral_eq_zero_of_add_left_eq_neg {G : Type u_4} {E : Type u_5} [measurable_space G] [normed_group E] [normed_space â„ E] [complete_space E] {Î¼ : measure_theory.measure G} {f : G â†’ E} {g : G} [add_group G] [has_measurable_add G] [Î¼.is_add_left_invariant] (hf' : âˆ€ (x : G), f (g + x) = -f x) : âˆ« (x : G), f x âˆ‚Î¼ = 0
theorem add_hom.srange_top_of_surjective {M : Type u_1} [has_add M] {N : Type u_2} [has_add N] (f : add_hom M N) (hf : function.surjective â‡‘f) : f.srange = âŠ¤
theorem metric.sigma.isometry_mk {Î¹ : Type u_1} {E : Î¹ â†’ Type u_2} [Î  (i : Î¹), metric_space (E i)] (i : Î¹) : isometry (sigma.mk i)
theorem real.cosh_eq (x : â„) : real.cosh x = (real.exp x + real.exp (-x)) / 2
theorem continuous_on.ae_strongly_measurable_of_is_separable {Î± : Type u_1} {Î² : Type u_2} [measurable_space Î±] [topological_space Î±] [topological_space.pseudo_metrizable_space Î±] [opens_measurable_space Î±] [topological_space Î²] [topological_space.pseudo_metrizable_space Î²] {f : Î± â†’ Î²} {s : set Î±} {Î¼ : measure_theory.measure Î±} (hf : continuous_on f s) (hs : measurable_set s) (h's : topological_space.is_separable s) : measure_theory.ae_strongly_measurable f (Î¼.restrict s)
theorem le_neg_of_le_neg {Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± has_add.add has_le.le] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±} : a â‰¤ -b â†’ b â‰¤ -a
theorem has_le.le.eq_or_gt {Î± : Type u} [partial_order Î±] {a b : Î±} (h : a â‰¤ b) : b = a âˆ¨ a < b
theorem real.coe_fib_eq (n : â„•) : â†‘(nat.fib n) = (golden_ratio ^ n - golden_conj ^ n) / real.sqrt 5
theorem measure_theory.strongly_measurable.integral_prod_left {Î± : Type u_1} {Î² : Type u_3} {E : Type u_6} [measurable_space Î±] [measurable_space Î²] {Î¼ : measure_theory.measure Î±} [normed_group E] [normed_space â„ E] [complete_space E] [measure_theory.sigma_finite Î¼] â¦ƒf : Î± â†’ Î² â†’ Eâ¦„ (hf : measure_theory.strongly_measurable (function.uncurry f)) : measure_theory.strongly_measurable (Î» (y : Î²), âˆ« (x : Î±), f x y âˆ‚Î¼)
theorem nat.set_induction {S : set â„•} (hb : 0 âˆˆ S) (h_ind : âˆ€ (k : â„•), k âˆˆ S â†’ k + 1 âˆˆ S) (n : â„•) : n âˆˆ S
theorem cont_diff_bump_of_inner.nonneg' {E : Type u_1} [inner_product_space â„ E] {c : E} (f : cont_diff_bump_of_inner c) (x : E) : 0 â‰¤ â‡‘f x
theorem tendsto_extend_from {X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] {A : set X} {f : X â†’ Y} {x : X} (h : âˆƒ (y : Y), filter.tendsto f (nhds_within x A) (nhds y)) : filter.tendsto f (nhds_within x A) (nhds (extend_from A f x))
theorem module.free.finrank_eq_card_choose_basis_index (R : Type u) (M : Type v) [ring R] [strong_rank_condition R] [add_comm_group M] [module R M] [module.free R M] [module.finite R M] : finite_dimensional.finrank R M = fintype.card (module.free.choose_basis_index R M)
theorem first_order.language.substructure.closure_mono {L : first_order.language} {M : Type w} [L.Structure M] â¦ƒs t : set Mâ¦„ (h : s âŠ† t) : â‡‘(first_order.language.substructure.closure L) s â‰¤ â‡‘(first_order.language.substructure.closure L) t
theorem le_of_neg_le_neg {Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± has_add.add has_le.le] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±} : -a â‰¤ -b â†’ b â‰¤ a
theorem minpoly.unique (A : Type u_1) {B : Type u_2} [field A] [ring B] [algebra A B] (x : B) {p : polynomial A} (pmonic : p.monic) (hp : â‡‘(polynomial.aeval x) p = 0) (pmin : âˆ€ (q : polynomial A), q.monic â†’ â‡‘(polynomial.aeval x) q = 0 â†’ p.degree â‰¤ q.degree) : p = minpoly A x
theorem matrix.pivot.list_transvec_col_mul_last_row_drop {ğ•œ : Type u_3} [field ğ•œ] {r : â„•} (M : matrix (fin r âŠ• unit) (fin r âŠ• unit) ğ•œ) (i : fin r âŠ• unit) {k : â„•} (hk : k â‰¤ r) : (list.drop k (matrix.pivot.list_transvec_col M)).prod.mul M (sum.inr ()) i = M (sum.inr ()) i
theorem measure_theory.is_add_fundamental_domain.is_add_left_invariant_map {G : Type u_1} [add_group G] [measurable_space G] [topological_space G] [topological_add_group G] [borel_space G] {Î¼ : measure_theory.measure G} {Î“ : add_subgroup G} {ğ“• : set G} (hğ“• : measure_theory.is_add_fundamental_domain â†¥(Î“.opposite) ğ“• Î¼) [encodable â†¥Î“] [measurable_space (G â§¸ Î“)] [borel_space (G â§¸ Î“)] [Î“.normal] [Î¼.is_add_left_invariant] [Î¼.is_add_right_invariant] : (measure_theory.measure.map â‡‘(quotient_add_group.mk' Î“) (Î¼.restrict ğ“•)).is_add_left_invariant
theorem cont_diff_on_top_iff_deriv_of_open {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {fâ‚‚ : ğ•œ â†’ F} {sâ‚‚ : set ğ•œ} (hs : is_open sâ‚‚) : cont_diff_on ğ•œ âŠ¤ fâ‚‚ sâ‚‚ â†” differentiable_on ğ•œ fâ‚‚ sâ‚‚ âˆ§ cont_diff_on ğ•œ âŠ¤ (deriv fâ‚‚) sâ‚‚
theorem finset.prod_erase {Î² : Type u} {Î± : Type v} [comm_monoid Î²] [decidable_eq Î±] (s : finset Î±) {f : Î± â†’ Î²} {a : Î±} (h : f a = 1) : (s.erase a).prod (Î» (x : Î±), f x) = s.prod (Î» (x : Î±), f x)
theorem group.conj_mem_conjugates_of_set {G : Type u_1} [group G] {s : set G} {x c : G} : x âˆˆ group.conjugates_of_set s â†’ c * x * câ»Â¹ âˆˆ group.conjugates_of_set s
theorem inv_mul_le_of_le_mul {Î± : Type u} [group Î±] [has_le Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a b c : Î±} : a â‰¤ b * c â†’ bâ»Â¹ * a â‰¤ c
theorem ring.eq_self_iff_eq_zero_of_char_ne_two {R : Type u_1} [non_assoc_ring R] [nontrivial R] [no_zero_divisors R] (hR : ring_char R â‰  2) {a : R} : -a = a â†” a = 0
theorem add_subgroup.supr_induction {G : Type u_1} [add_group G] {Î¹ : Sort u_2} (S : Î¹ â†’ add_subgroup G) {C : G â†’ Prop} {x : G} (hx : x âˆˆ â¨† (i : Î¹), S i) (hp : âˆ€ (i : Î¹) (x : G), x âˆˆ S i â†’ C x) (h1 : C 0) (hmul : âˆ€ (x y : G), C x â†’ C y â†’ C (x + y)) : C x
theorem matrix.diagonal_transvection_induction_of_det_ne_zero {n : Type u_1} {ğ•œ : Type u_3} [field ğ•œ] [decidable_eq n] [fintype n] (P : matrix n n ğ•œ â†’ Prop) (M : matrix n n ğ•œ) (hMdet : M.det â‰  0) (hdiag : âˆ€ (D : n â†’ ğ•œ), (matrix.diagonal D).det â‰  0 â†’ P (matrix.diagonal D)) (htransvec : âˆ€ (t : matrix.transvection_struct n ğ•œ), P t.to_matrix) (hmul : âˆ€ (A B : matrix n n ğ•œ), A.det â‰  0 â†’ B.det â‰  0 â†’ P A â†’ P B â†’ P (A.mul B)) : P M
theorem ite_apply {Î± : Sort u_1} {Ïƒ : Î± â†’ Sort u_4} (P : Prop) [decidable P] (f g : Î  (a : Î±), Ïƒ a) (a : Î±) : ite P f g a = ite P (f a) (g a)
theorem power_basis.repr_pow_is_integral {S : Type u_2} [comm_ring S] {R : Type u_3} [comm_ring R] [algebra R S] {A : Type u_4} [comm_ring A] [algebra R A] [algebra S A] [is_scalar_tower R S A] {B : power_basis S A} (hB : is_integral R B.gen) [is_domain S] {x : A} (hx : âˆ€ (i : fin B.dim), is_integral R (â‡‘(â‡‘(B.basis.repr) x) i)) (hmin : minpoly S B.gen = polynomial.map (algebra_map R S) (minpoly R B.gen)) (n : â„•) (i : fin B.dim) : is_integral R (â‡‘(â‡‘(B.basis.repr) (x ^ n)) i)
theorem continuous_multilinear_map.map_smul_univ {R : Type u} {Î¹ : Type v} {Mâ‚ : Î¹ â†’ Type wâ‚} {Mâ‚‚ : Type wâ‚‚} [decidable_eq Î¹] [comm_semiring R] [Î  (i : Î¹), add_comm_monoid (Mâ‚ i)] [add_comm_monoid Mâ‚‚] [Î  (i : Î¹), module R (Mâ‚ i)] [module R Mâ‚‚] [Î  (i : Î¹), topological_space (Mâ‚ i)] [topological_space Mâ‚‚] (f : continuous_multilinear_map R Mâ‚ Mâ‚‚) [fintype Î¹] (c : Î¹ â†’ R) (m : Î  (i : Î¹), Mâ‚ i) : â‡‘f (Î» (i : Î¹), c i â€¢ m i) = finset.univ.prod (Î» (i : Î¹), c i) â€¢ â‡‘f m
theorem box_integral.integrable.tendsto_integral_sum_to_filter_Union_single {Î¹ : Type u} {E : Type v} {F : Type w} [normed_group E] [normed_space â„ E] [normed_group F] [normed_space â„ F] {I J : box_integral.box Î¹} [fintype Î¹] {l : box_integral.integration_params} {f : (Î¹ â†’ â„) â†’ E} {vol : box_integral.box_additive_map Î¹ (E â†’L[â„] F) âŠ¤} [complete_space F] (h : box_integral.integrable I l f vol) (hJ : J â‰¤ I) : filter.tendsto (box_integral.integral_sum f vol) (l.to_filter_Union I (box_integral.prepartition.single I J hJ)) (nhds (box_integral.integral J l f vol))
theorem char.quadratic_char_sq_one' {F : Type u_1} [field F] [fintype F] [decidable_eq F] {a : F} (ha : a â‰  0) : char.quadratic_char F (a ^ 2) = 1
theorem nhds_within_of_mem_discrete {Î± : Type u} [topological_space Î±] {s : set Î±} [discrete_topology â†¥s] {x : Î±} (hx : x âˆˆ s) : nhds_within x s = has_pure.pure x
theorem add_le_cancellable.tsub_lt_tsub_iff_left_of_le {Î± : Type u_1} [canonically_linear_ordered_add_monoid Î±] [has_sub Î±] [has_ordered_sub Î±] {a b c : Î±} (ha : add_le_cancellable a) (hb : add_le_cancellable b) (h : b â‰¤ a) : a - b < a - c â†” c < b
theorem is_fraction_ring.lift_algebra_map {A : Type u_4} [comm_ring A] [is_domain A] {K : Type u_5} [field K] {L : Type u_7} [field L] [algebra A K] [is_fraction_ring A K] {g : A â†’+* L} (hg : function.injective â‡‘g) (x : A) : â‡‘(is_fraction_ring.lift hg) (â‡‘(algebra_map A K) x) = â‡‘g x
theorem orientation.oangle_add_oangle_rev {V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) (x y : V) : o.oangle x y + o.oangle y x = 0
theorem affine_subspace.eq_of_direction_eq_of_nonempty_of_le {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {sâ‚ sâ‚‚ : affine_subspace k P} (hd : sâ‚.direction = sâ‚‚.direction) (hn : â†‘sâ‚.nonempty) (hle : sâ‚ â‰¤ sâ‚‚) : sâ‚ = sâ‚‚
theorem Top.sheaf.eq_of_locally_eq' {C : Type u} [category_theory.category C] [category_theory.concrete_category C] [category_theory.limits.has_limits C] [category_theory.reflects_isomorphisms (category_theory.concrete_category.forget C)] [category_theory.limits.preserves_limits (category_theory.concrete_category.forget C)] {X : Top} (F : Top.sheaf C X) {Î¹ : Type v} (U : Î¹ â†’ topological_space.opens â†¥X) (V : topological_space.opens â†¥X) (iUV : Î  (i : Î¹), U i âŸ¶ V) (hcover : V â‰¤ supr U) (s t : â†¥(F.val.obj (opposite.op V))) (h : âˆ€ (i : Î¹), â‡‘(F.val.map (iUV i).op) s = â‡‘(F.val.map (iUV i).op) t) : s = t
theorem part.ext' {Î± : Type u_1} {o p : part Î±} (H1 : o.dom â†” p.dom) (H2 : âˆ€ (hâ‚ : o.dom) (hâ‚‚ : p.dom), o.get hâ‚ = p.get hâ‚‚) : o = p
theorem vector.scanl_nil {Î± : Type u_1} {Î² : Type u_2} (f : Î² â†’ Î± â†’ Î²) (b : Î²) : vector.scanl f b vector.nil = b::áµ¥vector.nil
theorem colex.hom_le_iff {Î± : Type u_1} {Î² : Type u_2} [linear_order Î±] [linear_order Î²] {f : Î± â†’ Î²} (hâ‚ : strict_mono f) (A B : finset Î±) : (finset.image f A).to_colex â‰¤ (finset.image f B).to_colex â†” A.to_colex â‰¤ B.to_colex
theorem emetric.continuous_inf_edist {Î± : Type u} [pseudo_emetric_space Î±] {s : set Î±} : continuous (Î» (x : Î±), emetric.inf_edist x s)
theorem div_le_div_of_mul_sub_mul_div_nonpos {Î± : Type u_1} [linear_ordered_field Î±] {a b c d : Î±} (hc : c â‰  0) (hd : d â‰  0) : (a * d - b * c) / (c * d) â‰¤ 0 â†’ a / c â‰¤ b / d
theorem topological_space.opens.coe_mk {Î± : Type u_1} [topological_space Î±] {U : set Î±} {hU : is_open U} : â†‘âŸ¨U, hUâŸ© = U
theorem monovary.sum_mul_comp_perm_lt_sum_mul_iff {Î¹ : Type u_1} {Î± : Type u_2} [linear_ordered_ring Î±] {Ïƒ : equiv.perm Î¹} {f g : Î¹ â†’ Î±} [fintype Î¹] (hfg : monovary f g) : finset.univ.sum (Î» (i : Î¹), f i * g (â‡‘Ïƒ i)) < finset.univ.sum (Î» (i : Î¹), f i * g i) â†” Â¬monovary f (g âˆ˜ â‡‘Ïƒ)
theorem continuous_at_of_locally_uniform_approx_of_continuous_at {Î± : Type u_1} {Î² : Type u_2} [uniform_space Î²] {f : Î± â†’ Î²} {x : Î±} [topological_space Î±] (L : âˆ€ (u : set (Î² Ã— Î²)), u âˆˆ uniformity Î² â†’ (âˆƒ (t : set Î±) (H : t âˆˆ nhds x) (F : Î± â†’ Î²), continuous_at F x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u)) : continuous_at f x
theorem alexandroff.not_continuous_cofinite_topology_of_symm {X : Type u_1} [topological_space X] [infinite X] [discrete_topology X] : Â¬continuous â‡‘(cofinite_topology.of.symm)
theorem has_strict_deriv_at_of_has_deriv_at_of_continuous_at {ğ•œ : Type u_3} [is_R_or_C ğ•œ] {G : Type u_4} [normed_group G] [normed_space ğ•œ G] {f f' : ğ•œ â†’ G} {x : ğ•œ} (hder : âˆ€á¶  (y : ğ•œ) in nhds x, has_deriv_at f (f' y) y) (hcont : continuous_at f' x) : has_strict_deriv_at f (f' x) x
theorem fin.coe_val_eq_self {n : â„•} (a : fin (n + 1)) : â†‘(a.val) = a
theorem alternating_group.is_conj_swap_mul_swap_of_cycle_type_two {g : equiv.perm (fin 5)} (ha : g âˆˆ alternating_group (fin 5)) (h1 : g â‰  1) (h2 : âˆ€ (n : â„•), n âˆˆ g.cycle_type â†’ n = 2) : is_conj (equiv.swap 0 4 * equiv.swap 1 3) g
theorem topological_fiber_bundle_core.is_open_map_proj {Î¹ : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core Î¹ B F) : is_open_map Z.proj
theorem lipschitz_on_with.dist_le_mul {Î± : Type u} {Î² : Type v} [pseudo_metric_space Î±] [pseudo_metric_space Î²] {K : nnreal} {s : set Î±} {f : Î± â†’ Î²} : lipschitz_on_with K f s â†’ âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (y : Î±), y âˆˆ s â†’ has_dist.dist (f x) (f y) â‰¤ â†‘K * has_dist.dist x y
theorem con.lift_on_coe {M : Type u_1} [has_mul M] {Î² : Sort u_2} (c : con M) (f : M â†’ Î²) (h : âˆ€ (a b : M), â‡‘c a b â†’ f a = f b) (x : M) : con.lift_on â†‘x f h = f x
theorem probability_theory.strong_law_aux5 {Î© : Type u_1} [measure_theory.measure_space Î©] [measure_theory.is_probability_measure measure_theory.measure_space.volume] (X : â„• â†’ Î© â†’ â„) (hint : measure_theory.integrable (X 0) measure_theory.measure_space.volume) (hident : âˆ€ (i : â„•), probability_theory.ident_distrib (X i) (X 0) measure_theory.measure_space.volume measure_theory.measure_space.volume) (hnonneg : âˆ€ (i : â„•) (Ï‰ : Î©), 0 â‰¤ X i Ï‰) : âˆ€áµ (Ï‰ : Î©), (Î» (n : â„•), (finset.range n).sum (Î» (i : â„•), probability_theory.truncation (X i) â†‘i Ï‰) - (finset.range n).sum (Î» (i : â„•), X i Ï‰)) =o[filter.at_top] Î» (n : â„•), â†‘n
theorem clifford_algebra_quaternion.of_quaternion_conj {R : Type u_1} [comm_ring R] {câ‚ câ‚‚ : R} (q : quaternion_algebra R câ‚ câ‚‚) : â‡‘clifford_algebra_quaternion.of_quaternion (â‡‘quaternion_algebra.conj q) = â‡‘clifford_algebra.involute (â‡‘clifford_algebra.reverse (â‡‘clifford_algebra_quaternion.of_quaternion q))
theorem measurable_set.exists_lt_is_closed_of_ne_top {Î± : Type u_1} [measurable_space Î±] [topological_space Î±] {Î¼ : measure_theory.measure Î±} [Î¼.weakly_regular] â¦ƒA : set Î±â¦„ (hA : measurable_set A) (h'A : â‡‘Î¼ A â‰  âŠ¤) {r : ennreal} (hr : r < â‡‘Î¼ A) : âˆƒ (K : set Î±) (H : K âŠ† A), is_closed K âˆ§ r < â‡‘Î¼ K
theorem strict_concave_on_of_slope_strict_anti_adjacent {ğ•œ : Type u_1} [linear_ordered_field ğ•œ] {s : set ğ•œ} {f : ğ•œ â†’ ğ•œ} (hs : convex ğ•œ s) (hf : âˆ€ {x y z : ğ•œ}, x âˆˆ s â†’ z âˆˆ s â†’ x < y â†’ y < z â†’ (f z - f y) / (z - y) < (f y - f x) / (y - x)) : strict_concave_on ğ•œ s f
theorem filter.has_basis.mem_iff {Î± : Type u_1} {Î¹ : Sort u_4} {l : filter Î±} {p : Î¹ â†’ Prop} {s : Î¹ â†’ set Î±} {t : set Î±} (hl : l.has_basis p s) : t âˆˆ l â†” âˆƒ (i : Î¹) (hi : p i), s i âŠ† t
theorem finset.sum_fn {Î± : Type u_1} {Î² : Î± â†’ Type u_2} {Î³ : Type u_3} [Î  (a : Î±), add_comm_monoid (Î² a)] (s : finset Î³) (g : Î³ â†’ Î  (a : Î±), Î² a) : s.sum (Î» (c : Î³), g c) = Î» (a : Î±), s.sum (Î» (c : Î³), g c a)
theorem continuous_at.integral_sub_linear_is_o_ae {Î± : Type u_1} {E : Type u_3} [measurable_space Î±] {Î¹ : Type u_5} [normed_group E] [topological_space Î±] [opens_measurable_space Î±] [normed_space â„ E] [complete_space E] {Î¼ : measure_theory.measure Î±} [measure_theory.is_locally_finite_measure Î¼] {a : Î±} {f : Î± â†’ E} (ha : continuous_at f a) (hfm : strongly_measurable_at_filter f (nhds a) Î¼) {s : Î¹ â†’ set Î±} {li : filter Î¹} (hs : filter.tendsto s li (nhds a).small_sets) (m : Î¹ â†’ â„ := Î» (i : Î¹), (â‡‘Î¼ (s i)).to_real) (hsÎ¼ : (Î» (i : Î¹), (â‡‘Î¼ (s i)).to_real) =á¶ [li] m . "refl") : (Î» (i : Î¹), âˆ« (x : Î±) in s i, f x âˆ‚Î¼ - m i â€¢ f a) =o[li] m
theorem measure_theory.tendsto_in_measure_iff_tendsto_Lp {Î± : Type u_1} {Î² : Type u_2} {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) [normed_group Î²] {p : ennreal} {f : â„• â†’ Î± â†’ Î²} {g : Î± â†’ Î²} [measure_theory.is_finite_measure Î¼] (hp : 1 â‰¤ p) (hp' : p â‰  âŠ¤) (hf : âˆ€ (n : â„•), measure_theory.mem_â„’p (f n) p Î¼) (hg : measure_theory.mem_â„’p g p Î¼) : measure_theory.tendsto_in_measure Î¼ f filter.at_top g âˆ§ measure_theory.unif_integrable f p Î¼ â†” filter.tendsto (Î» (n : â„•), measure_theory.snorm (f n - g) p Î¼) filter.at_top (nhds 0)
theorem finset.imageâ‚‚_distrib_subset_right {Î± : Type u_1} {Î±' : Type u_2} {Î² : Type u_3} {Î²' : Type u_4} {Î´ : Type u_7} {Îµ : Type u_9} [decidable_eq Î±'] [decidable_eq Î²'] [decidable_eq Î´] [decidable_eq Îµ] {s : finset Î±} {t : finset Î²} {Î³ : Type u_5} {u : finset Î³} {f : Î´ â†’ Î³ â†’ Îµ} {g : Î± â†’ Î² â†’ Î´} {fâ‚ : Î± â†’ Î³ â†’ Î±'} {fâ‚‚ : Î² â†’ Î³ â†’ Î²'} {g' : Î±' â†’ Î²' â†’ Îµ} (h_distrib : âˆ€ (a : Î±) (b : Î²) (c : Î³), f (g a b) c = g' (fâ‚ a c) (fâ‚‚ b c)) : finset.imageâ‚‚ f (finset.imageâ‚‚ g s t) u âŠ† finset.imageâ‚‚ g' (finset.imageâ‚‚ fâ‚ s u) (finset.imageâ‚‚ fâ‚‚ t u)
theorem dual_pair.lc_coeffs {R : Type u_1} {M : Type u_2} {Î¹ : Type u_3} [comm_ring R] [add_comm_group M] [module R M] {e : Î¹ â†’ M} {Îµ : Î¹ â†’ module.dual R M} [decidable_eq Î¹] (h : dual_pair e Îµ) (m : M) : dual_pair.lc e (h.coeffs m) = m
theorem fin.snoc_update {n : â„•} {Î± : fin (n + 1) â†’ Type u} (x : Î± (fin.last n)) (p : Î  (i : fin n), Î± (â‡‘fin.cast_succ i)) (i : fin n) (y : Î± (â‡‘fin.cast_succ i)) : fin.snoc (function.update p i y) x = function.update (fin.snoc p x) (â‡‘fin.cast_succ i) y
theorem comm_sq.map {C : Type uâ‚} [category_theory.category C] {D : Type uâ‚‚} [category_theory.category D] (F : C â¥¤ D) {W X Y Z : C} {f : W âŸ¶ X} {g : W âŸ¶ Y} {h : X âŸ¶ Z} {i : Y âŸ¶ Z} (s : category_theory.comm_sq f g h i) : category_theory.comm_sq (F.map f) (F.map g) (F.map h) (F.map i)
theorem Gromov_Hausdorff.Hausdorff_dist_optimal {X : Type u} [metric_space X] [compact_space X] [nonempty X] {Y : Type v} [metric_space Y] [compact_space Y] [nonempty Y] : metric.Hausdorff_dist (set.range (Gromov_Hausdorff.optimal_GH_injl X Y)) (set.range (Gromov_Hausdorff.optimal_GH_injr X Y)) = Gromov_Hausdorff.GH_dist X Y
theorem mul_add_mul_le_mul_add_mul' {Î± : Type u} [ordered_semiring Î±] {a b c d : Î±} [has_exists_add_of_le Î±] (hba : b â‰¤ a) (hdc : d â‰¤ c) : a â€¢ d + b â€¢ c â‰¤ a â€¢ c + b â€¢ d
theorem orientation.oangle_zero_right {V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) (x : V) : o.oangle x 0 = 0
theorem metric.thickening_eq_preimage_inf_edist {Î± : Type u} [pseudo_emetric_space Î±] (Î´ : â„) (E : set Î±) : metric.thickening Î´ E = (Î» (x : Î±), emetric.inf_edist x E) â»Â¹' set.Iio (ennreal.of_real Î´)
theorem div_mem {M : Type u_3} {S : Type u_4} [div_inv_monoid M] [set_like S M] [hSM : subgroup_class S M] {H : S} {x y : M} (hx : x âˆˆ H) (hy : y âˆˆ H) : x / y âˆˆ H
theorem affine_independent.not_mem_affine_span_diff {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {Î¹ : Type u_4} [nontrivial k] {p : Î¹ â†’ P} (ha : affine_independent k p) (i : Î¹) (s : set Î¹) : p i âˆ‰ affine_span k (p '' (s  {i}))
theorem strict_convex_on.slope_strict_mono_adjacent {ğ•œ : Type u_1} [linear_ordered_field ğ•œ] {s : set ğ•œ} {f : ğ•œ â†’ ğ•œ} (hf : strict_convex_on ğ•œ s f) {x y z : ğ•œ} (hx : x âˆˆ s) (hz : z âˆˆ s) (hxy : x < y) (hyz : y < z) : (f y - f x) / (y - x) < (f z - f y) / (z - y)
theorem measure_theory.lintegral_lintegral_symm {Î± : Type u_1} {Î² : Type u_3} [measurable_space Î±] [measurable_space Î²] {Î¼ : measure_theory.measure Î±} {Î½ : measure_theory.measure Î²} [measure_theory.sigma_finite Î½] [measure_theory.sigma_finite Î¼] â¦ƒf : Î± â†’ Î² â†’ ennrealâ¦„ (hf : ae_measurable (function.uncurry f) (Î¼.prod Î½)) : âˆ«â» (x : Î±), âˆ«â» (y : Î²), f x y âˆ‚Î½ âˆ‚Î¼ = âˆ«â» (z : Î² Ã— Î±), f z.snd z.fst âˆ‚Î½.prod Î¼
theorem affine_independent_set_iff_linear_independent_vsub (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : set P} {pâ‚ : P} (hpâ‚ : pâ‚ âˆˆ s) : affine_independent k (Î» (p : â†¥s), â†‘p) â†” linear_independent k (Î» (v : â†¥((Î» (p : P), p -áµ¥ pâ‚) '' (s  {pâ‚}))), â†‘v)
theorem is_algebraic_algebra_map {R : Type u} {A : Type v} [comm_ring R] [ring A] [algebra R A] [nontrivial R] (x : R) : is_algebraic R (â‡‘(algebra_map R A) x)
theorem is_of_fin_order.inv {G : Type u} [group G] {x : G} (hx : is_of_fin_order x) : is_of_fin_order xâ»Â¹
theorem lt_or_lt_iff_ne {Î± : Type u} [linear_order Î±] {x y : Î±} : x < y âˆ¨ y < x â†” x â‰  y
theorem nat.sum_four_squares (n : â„•) : âˆƒ (a b c d : â„•), a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n
theorem reflection_mul_reflection {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] (K : submodule ğ•œ E) [complete_space â†¥K] : reflection K * reflection K = 1
theorem algebra.discr_power_basis_eq_prod (K : Type u) {L : Type v} (E : Type z) [field K] [field L] [field E] [algebra K L] [algebra K E] [module.finite K L] [is_alg_closed E] (pb : power_basis K L) (e : fin pb.dim â‰ƒ (L â†’â‚[K] E)) [is_separable K L] : â‡‘(algebra_map K E) (algebra.discr K â‡‘(pb.basis)) = finset.univ.prod (Î» (i : fin pb.dim), (finset.filter (Î» (j : fin pb.dim), i < j) finset.univ).prod (Î» (j : fin pb.dim), (â‡‘(â‡‘e j) pb.gen - â‡‘(â‡‘e i) pb.gen) ^ 2))
theorem cardinal.add_eq_max {a b : cardinal} (ha : cardinal.aleph_0 â‰¤ a) : a + b = linear_order.max a b
theorem power_basis.repr_mul_is_integral {S : Type u_2} [comm_ring S] {R : Type u_3} [comm_ring R] [algebra R S] {A : Type u_4} [comm_ring A] [algebra R A] [algebra S A] [is_scalar_tower R S A] {B : power_basis S A} (hB : is_integral R B.gen) [is_domain S] {x y : A} (hx : âˆ€ (i : fin B.dim), is_integral R (â‡‘(â‡‘(B.basis.repr) x) i)) (hy : âˆ€ (i : fin B.dim), is_integral R (â‡‘(â‡‘(B.basis.repr) y) i)) (hmin : minpoly S B.gen = polynomial.map (algebra_map R S) (minpoly R B.gen)) (i : fin B.dim) : is_integral R (â‡‘(â‡‘(B.basis.repr) (x * y)) i)
theorem multilinear_map.comp_linear_map_id {R : Type u} {Î¹ : Type u'} {Mâ‚‚ : Type vâ‚‚} [decidable_eq Î¹] [semiring R] [add_comm_monoid Mâ‚‚] [module R Mâ‚‚] {Mâ‚' : Î¹ â†’ Type u_1} [Î  (i : Î¹), add_comm_monoid (Mâ‚' i)] [Î  (i : Î¹), module R (Mâ‚' i)] (g : multilinear_map R Mâ‚' Mâ‚‚) : g.comp_linear_map (Î» (i : Î¹), linear_map.id) = g
theorem ennreal.cancel_of_ne {a : ennreal} (h : a â‰  âŠ¤) : add_le_cancellable a
theorem continuous.comp_ae_strongly_measurable {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [topological_space Î²] [topological_space Î³] {g : Î² â†’ Î³} {f : Î± â†’ Î²} (hg : continuous g) (hf : measure_theory.ae_strongly_measurable f Î¼) : measure_theory.ae_strongly_measurable (Î» (x : Î±), g (f x)) Î¼
theorem compact_space.uniform_continuous_of_continuous {Î± : Type u_1} {Î² : Type u_2} [uniform_space Î±] [uniform_space Î²] [compact_space Î±] [separated_space Î±] {f : Î± â†’ Î²} (h : continuous f) : uniform_continuous f
theorem order.embedding_from_countable_to_dense (Î± : Type u_1) (Î² : Type u_2) [linear_order Î±] [linear_order Î²] [encodable Î±] [densely_ordered Î²] [nontrivial Î²] : nonempty (Î± â†ªo Î²)
theorem box_integral.prepartition.not_disjoint_imp_le_of_subset_of_mem_split_many {Î¹ : Type u_1} {I J Js : box_integral.box Î¹} {s : finset (Î¹ Ã— â„)} (H : âˆ€ (i : Î¹), {(i, J.lower i), (i, J.upper i)} âŠ† s) (HJs : Js âˆˆ box_integral.prepartition.split_many I s) (Hn : Â¬disjoint â†‘J â†‘Js) : Js â‰¤ J
theorem dvd_add_left {Î± : Type u} [non_unital_ring Î±] {a b c : Î±} (h : a âˆ£ c) : a âˆ£ b + c â†” a âˆ£ b
theorem category_theory.presieve.restrict_inj {C : Type uâ‚} [category_theory.category C] {P : Cáµ’áµ– â¥¤ Type w} {X : C} {R : category_theory.presieve X} {xâ‚ xâ‚‚ : category_theory.presieve.family_of_elements P â‡‘(category_theory.sieve.generate R)} (tâ‚ : xâ‚.compatible) (tâ‚‚ : xâ‚‚.compatible) : category_theory.presieve.family_of_elements.restrict _ xâ‚ = category_theory.presieve.family_of_elements.restrict _ xâ‚‚ â†’ xâ‚ = xâ‚‚
theorem cont_diff_on.neg {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {n : with_top â„•} {s : set E} {f : E â†’ F} (hf : cont_diff_on ğ•œ n f s) : cont_diff_on ğ•œ n (Î» (x : E), -f x) s
theorem has_deriv_at_integral_of_dominated_loc_of_deriv_le {Î± : Type u_1} [measurable_space Î±] {Î¼ : measure_theory.measure Î±} {ğ•œ : Type u_2} [is_R_or_C ğ•œ] {E : Type u_3} [normed_group E] [normed_space â„ E] [normed_space ğ•œ E] [complete_space E] {F F' : ğ•œ â†’ Î± â†’ E} {xâ‚€ : ğ•œ} {Îµ : â„} (Îµ_pos : 0 < Îµ) (hF_meas : âˆ€á¶  (x : ğ•œ) in nhds xâ‚€, measure_theory.ae_strongly_measurable (F x) Î¼) (hF_int : measure_theory.integrable (F xâ‚€) Î¼) (hF'_meas : measure_theory.ae_strongly_measurable (F' xâ‚€) Î¼) {bound : Î± â†’ â„} (h_bound : âˆ€áµ (a : Î±) âˆ‚Î¼, âˆ€ (x : ğ•œ), x âˆˆ metric.ball xâ‚€ Îµ â†’ âˆ¥F' x aâˆ¥ â‰¤ bound a) (bound_integrable : measure_theory.integrable bound Î¼) (h_diff : âˆ€áµ (a : Î±) âˆ‚Î¼, âˆ€ (x : ğ•œ), x âˆˆ metric.ball xâ‚€ Îµ â†’ has_deriv_at (Î» (x : ğ•œ), F x a) (F' x a) x) : measure_theory.integrable (F' xâ‚€) Î¼ âˆ§ has_deriv_at (Î» (n : ğ•œ), âˆ« (a : Î±), F n a âˆ‚Î¼) (âˆ« (a : Î±), F' xâ‚€ a âˆ‚Î¼) xâ‚€
theorem tfae_mem_nhds_within_Iio {Î± : Type u} [topological_space Î±] [linear_order Î±] [order_topology Î±] {a b : Î±} (h : a < b) (s : set Î±) : [s âˆˆ nhds_within b (set.Iio b), s âˆˆ nhds_within b (set.Ico a b), s âˆˆ nhds_within b (set.Ioo a b), âˆƒ (l : Î±) (H : l âˆˆ set.Ico a b), set.Ioo l b âŠ† s, âˆƒ (l : Î±) (H : l âˆˆ set.Iio b), set.Ioo l b âŠ† s].tfae
theorem function.injective.tendsto_cofinite {Î± : Type u_2} {Î² : Type u_3} {f : Î± â†’ Î²} (hf : function.injective f) : filter.tendsto f filter.cofinite filter.cofinite
theorem bounded_continuous_function.continuous_eval_const {Î± : Type u} {Î² : Type v} [topological_space Î±] [pseudo_metric_space Î²] {x : Î±} : continuous (Î» (f : bounded_continuous_function Î± Î²), â‡‘f x)
theorem eq_of_nndist_eq_zero {Î³ : Type w} [metric_space Î³] {x y : Î³} : has_nndist.nndist x y = 0 â†’ x = y
theorem add_monoid_algebra.fg_of_finite_type {R : Type u_1} {M : Type u_2} [add_comm_monoid M] [comm_ring R] [nontrivial R] [h : algebra.finite_type R (add_monoid_algebra R M)] : add_monoid.fg M
theorem interior_singleton {Î± : Type u} [topological_space Î±] (x : Î±) [(nhds_within x {x}á¶œ).ne_bot] : interior {x} = âˆ…
theorem matrix.mv_polynomial_X_map_evalâ‚‚ {m : Type u_1} {n : Type u_2} {R : Type u_3} {S : Type u_4} [comm_semiring R] [comm_semiring S] (f : R â†’+* S) (A : matrix m n S) : (matrix.mv_polynomial_X m n R).map (mv_polynomial.evalâ‚‚ f (Î» (p : m Ã— n), A p.fst p.snd)) = A
theorem submonoid.localization_map.lift_mk' {M : Type u_1} [comm_monoid M] {S : submonoid M} {N : Type u_2} [comm_monoid N] {P : Type u_3} [comm_monoid P] (f : S.localization_map N) {g : M â†’* P} (hg : âˆ€ (y : â†¥S), is_unit (â‡‘g â†‘y)) (x : M) (y : â†¥S) : â‡‘(f.lift hg) (f.mk' x y) = â‡‘g x * â†‘(â‡‘(is_unit.lift_right (g.restrict S) hg) y)â»Â¹
theorem add_submonoid.closure_mono {M : Type u_1} [add_zero_class M] â¦ƒs t : set Mâ¦„ (h : s âŠ† t) : add_submonoid.closure s â‰¤ add_submonoid.closure t
theorem list.subperm_append_diff_self_of_count_le {Î± : Type uu} [decidable_eq Î±] {lâ‚ lâ‚‚ : list Î±} (h : âˆ€ (x : Î±), x âˆˆ lâ‚ â†’ list.count x lâ‚ â‰¤ list.count x lâ‚‚) : lâ‚ ++ lâ‚‚.diff lâ‚ ~ lâ‚‚
theorem function.commute.inv_on_fixed_pts_comp {Î± : Type u} {f g : Î± â†’ Î±} (h : function.commute f g) : set.inv_on f g (function.fixed_points (f âˆ˜ g)) (function.fixed_points (f âˆ˜ g))
theorem euclidean_geometry.angle_eq_right {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] (p1 p2 : P) : euclidean_geometry.angle p1 p2 p2 = real.pi / 2
theorem orthonormal.two_zsmul_oangle_neg_right {V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) (x y : V) : 2 â€¢ hb.oangle x (-y) = 2 â€¢ hb.oangle x y
theorem eventually_ne_of_tendsto_norm_at_top {Î± : Type u_1} {E : Type u_3} [semi_normed_group E] {l : filter Î±} {f : Î± â†’ E} (h : filter.tendsto (Î» (y : Î±), âˆ¥f yâˆ¥) l filter.at_top) (x : E) : âˆ€á¶  (y : Î±) in l, f y â‰  x
theorem set.Iio_subset_Iic {Î± : Type u_1} [preorder Î±] {a b : Î±} (h : a â‰¤ b) : set.Iio a âŠ† set.Iic b
theorem is_regular.pow {R : Type u_1} {a : R} [monoid R] (n : â„•) (ra : is_regular a) : is_regular (a ^ n)
theorem function.injective.is_domain {Î± : Type u_2} {Î² : Type u_3} [ring Î±] [is_domain Î±] [ring Î²] (f : Î² â†’+* Î±) (hf : function.injective â‡‘f) : is_domain Î²
theorem map_cinfi_of_continuous_at_of_monotone {Î± : Type u} {Î² : Type v} {Î³ : Type w} [conditionally_complete_linear_order Î±] [topological_space Î±] [order_topology Î±] [conditionally_complete_linear_order Î²] [topological_space Î²] [order_topology Î²] [nonempty Î³] {f : Î± â†’ Î²} {g : Î³ â†’ Î±} (Cf : continuous_at f (â¨… (i : Î³), g i)) (Mf : monotone f) (H : bdd_below (set.range g)) : f (â¨… (i : Î³), g i) = â¨… (i : Î³), f (g i)
theorem fintype.exists_ne_map_eq_of_card_lt {Î± : Type u_1} {Î² : Type u_2} [fintype Î±] [fintype Î²] (f : Î± â†’ Î²) (h : fintype.card Î² < fintype.card Î±) : âˆƒ (x y : Î±), x â‰  y âˆ§ f x = f y
theorem finite_dimensional.nontrivial_of_finrank_eq_succ {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {n : â„•} (hn : finite_dimensional.finrank K V = n.succ) : nontrivial V
theorem interval_integral.deriv_integral_right {E : Type u_3} [normed_group E] [complete_space E] [normed_space â„ E] {f : â„ â†’ E} {a b : â„} (hf : interval_integrable f measure_theory.measure_space.volume a b) (hmeas : strongly_measurable_at_filter f (nhds b) measure_theory.measure_space.volume) (hb : continuous_at f b) : deriv (Î» (u : â„), âˆ« (x : â„) in a..u, f x) b = f b
theorem polynomial.coeff_mul {R : Type u} [semiring R] (p q : polynomial R) (n : â„•) : (p * q).coeff n = (finset.nat.antidiagonal n).sum (Î» (x : â„• Ã— â„•), p.coeff x.fst * q.coeff x.snd)
theorem bounded_continuous_function.arzela_ascoliâ‚‚ {Î± : Type u} {Î² : Type v} [topological_space Î±] [compact_space Î±] [pseudo_metric_space Î²] (s : set Î²) (hs : is_compact s) (A : set (bounded_continuous_function Î± Î²)) (closed : is_closed A) (in_s : âˆ€ (f : bounded_continuous_function Î± Î²) (x : Î±), f âˆˆ A â†’ â‡‘f x âˆˆ s) (H : âˆ€ (x : Î±) (Îµ : â„), Îµ > 0 â†’ (âˆƒ (U : set Î±) (H : U âˆˆ nhds x), âˆ€ (y : Î±), y âˆˆ U â†’ âˆ€ (z : Î±), z âˆˆ U â†’ âˆ€ (f : bounded_continuous_function Î± Î²), f âˆˆ A â†’ has_dist.dist (â‡‘f y) (â‡‘f z) < Îµ)) : is_compact A
theorem is_localization.monoid_hom_ext {R : Type u_1} [comm_semiring R] (M : submonoid R) {S : Type u_2} [comm_semiring S] [algebra R S] {P : Type u_3} [comm_semiring P] [is_localization M S] â¦ƒj k : S â†’* Pâ¦„ (h : j.comp â†‘(algebra_map R S) = k.comp â†‘(algebra_map R S)) : j = k
theorem Top.sheaf.pushforward_sheaf_of_sheaf {C : Type uâ‚} [category_theory.category C] {X Y : Top} (f : X âŸ¶ Y) [category_theory.limits.has_products C] {F : Top.presheaf C X} (h : F.is_sheaf) : (f _* F).is_sheaf
theorem real.tendsto_pow_mul_exp_neg_at_top_nhds_0 (n : â„•) : filter.tendsto (Î» (x : â„), x ^ n * real.exp (-x)) filter.at_top (nhds 0)
theorem finset.affine_combination_apply_const {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {Î¹ : Type u_4} (s : finset Î¹) (w : Î¹ â†’ k) (p : P) (h : s.sum (Î» (i : Î¹), w i) = 1) : â‡‘(s.affine_combination (Î» (_x : Î¹), p)) w = p
theorem is_compact.bdd_below {Î± : Type u} [topological_space Î±] [linear_order Î±] [order_closed_topology Î±] [nonempty Î±] {s : set Î±} (hs : is_compact s) : bdd_below s
theorem measure_theory.is_open_pos_measure_of_add_left_invariant_of_compact {G : Type u_1} [measurable_space G] [topological_space G] [borel_space G] {Î¼ : measure_theory.measure G} [add_group G] [topological_add_group G] [Î¼.is_add_left_invariant] (K : set G) (hK : is_compact K) (h : â‡‘Î¼ K â‰  0) : Î¼.is_open_pos_measure
theorem is_topological_fiber_bundle.continuous_proj {B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z â†’ B} [topological_space Z] (h : is_topological_fiber_bundle F proj) : continuous proj
theorem topological_semiring.has_continuous_neg_of_mul {Î± : Type u_1} [topological_space Î±] [non_assoc_ring Î±] [has_continuous_mul Î±] : has_continuous_neg Î±
theorem metric.self_subset_cthickening {Î± : Type u} [pseudo_emetric_space Î±] {Î´ : â„} (E : set Î±) : E âŠ† metric.cthickening Î´ E
theorem mem_affine_span (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {p : P} {s : set P} (hp : p âˆˆ s) : p âˆˆ affine_span k s
theorem subalgebra.is_algebraic_iff {R : Type u} {A : Type v} [comm_ring R] [ring A] [algebra R A] (S : subalgebra R A) : S.is_algebraic â†” algebra.is_algebraic R â†¥S
theorem bdd_above.mono {Î± : Type u} [preorder Î±] â¦ƒs t : set Î±â¦„ (h : s âŠ† t) : bdd_above t â†’ bdd_above s
theorem has_binary_coproducts_of_initial_and_pushouts (C : Type u) [category_theory.category C] [category_theory.limits.has_initial C] [category_theory.limits.has_pushouts C] : category_theory.limits.has_binary_coproducts C
theorem convolution_lsmul {ğ•œ : Type u_1} {G : Type u_2} {F : Type u_6} [normed_group F] {x : G} [nondiscrete_normed_field ğ•œ] [normed_space ğ•œ F] [measurable_space G] {Î¼ : measure_theory.measure G} [normed_space â„ F] [complete_space F] [has_sub G] {f : G â†’ ğ•œ} {g : G â†’ F} : convolution f g (continuous_linear_map.lsmul ğ•œ ğ•œ) Î¼ x = âˆ« (t : G), f t â€¢ g (x - t) âˆ‚Î¼
theorem tensor_algebra.induction {R : Type u_1} [comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {C : tensor_algebra R M â†’ Prop} (h_grade0 : âˆ€ (r : R), C (â‡‘(algebra_map R (tensor_algebra R M)) r)) (h_grade1 : âˆ€ (x : M), C (â‡‘(tensor_algebra.Î¹ R) x)) (h_mul : âˆ€ (a b : tensor_algebra R M), C a â†’ C b â†’ C (a * b)) (h_add : âˆ€ (a b : tensor_algebra R M), C a â†’ C b â†’ C (a + b)) (a : tensor_algebra R M) : C a
theorem tendsto_le_of_eventually_le {Î± : Type u} {Î² : Type v} [topological_space Î±] [preorder Î±] [t : order_closed_topology Î±] {f g : Î² â†’ Î±} {b : filter Î²} {aâ‚ aâ‚‚ : Î±} [b.ne_bot] (hf : filter.tendsto f b (nhds aâ‚)) (hg : filter.tendsto g b (nhds aâ‚‚)) (h : f â‰¤á¶ [b] g) : aâ‚ â‰¤ aâ‚‚
theorem finset.induction_on_max {Î± : Type u_1} [linear_order Î±] [decidable_eq Î±] {p : finset Î± â†’ Prop} (s : finset Î±) (h0 : p âˆ…) (step : âˆ€ (a : Î±) (s : finset Î±), (âˆ€ (x : Î±), x âˆˆ s â†’ x < a) â†’ p s â†’ p (has_insert.insert a s)) : p s
theorem modular_group.bottom_row_coprime {R : Type u_1} [comm_ring R] (g : matrix.special_linear_group (fin 2) R) : is_coprime (â†‘g 1 0) (â†‘g 1 1)
theorem int.exists_strict_anti (Î± : Type u) [preorder Î±] [nonempty Î±] [no_min_order Î±] [no_max_order Î±] : âˆƒ (f : â„¤ â†’ Î±), strict_anti f
theorem continuous.tendsto_uniformly {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [uniform_space Î±] [uniform_space Î²] [separated_space Î±] [locally_compact_space Î±] [compact_space Î²] [separated_space Î²] [uniform_space Î³] (f : Î± â†’ Î² â†’ Î³) (h : continuous â†¿f) (x : Î±) : tendsto_uniformly f (f x) (nhds x)
theorem union_mem_uniformity_sum {Î± : Type u_1} {Î² : Type u_2} [uniform_space Î±] [uniform_space Î²] {a : set (Î± Ã— Î±)} (ha : a âˆˆ uniformity Î±) {b : set (Î² Ã— Î²)} (hb : b âˆˆ uniformity Î²) : (Î» (p : Î± Ã— Î±), (sum.inl p.fst, sum.inl p.snd)) '' a âˆª (Î» (p : Î² Ã— Î²), (sum.inr p.fst, sum.inr p.snd)) '' b âˆˆ uniform_space.core.sum.uniformity
theorem number_field.class_number_eq_one_iff {K : Type u_1} [field K] [number_field K] : number_field.class_number K = 1 â†” is_principal_ideal_ring â†¥(number_field.ring_of_integers K)
theorem inner_product_geometry.norm_sub_eq_add_norm_iff_angle_eq_pi {V : Type u_1} [inner_product_space â„ V] {x y : V} (hx : x â‰  0) (hy : y â‰  0) : âˆ¥x - yâˆ¥ = âˆ¥xâˆ¥ + âˆ¥yâˆ¥ â†” inner_product_geometry.angle x y = real.pi
theorem continuous_equiv_fun_basis {ğ•œ : Type u} [hnorm : nondiscrete_normed_field ğ•œ] {E : Type v} [add_comm_group E] [module ğ•œ E] [topological_space E] [topological_add_group E] [has_continuous_smul ğ•œ E] [complete_space ğ•œ] [t2_space E] {Î¹ : Type u_1} [fintype Î¹] (Î¾ : basis Î¹ ğ•œ E) : continuous â‡‘(Î¾.equiv_fun)
theorem continuous_linear_map.tendsto_of_tendsto_pointwise_of_cauchy_seq {ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {F : Type u_6} [normed_group F] [nondiscrete_normed_field ğ•œ] [nondiscrete_normed_field ğ•œâ‚‚] [normed_space ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} {E' : Type u_10} [semi_normed_group E'] [normed_space ğ•œ E'] [ring_hom_isometric Ïƒâ‚â‚‚] {f : â„• â†’ (E' â†’SL[Ïƒâ‚â‚‚] F)} {g : E' â†’SL[Ïƒâ‚â‚‚] F} (hg : filter.tendsto (Î» (n : â„•) (x : E'), â‡‘(f n) x) filter.at_top (nhds â‡‘g)) (hf : cauchy_seq f) : filter.tendsto f filter.at_top (nhds g)
theorem interval_integral.integral_has_deriv_within_at_left {E : Type u_3} [normed_group E] [complete_space E] [normed_space â„ E] {f : â„ â†’ E} {a b : â„} (hf : interval_integrable f measure_theory.measure_space.volume a b) {s t : set â„} [interval_integral.FTC_filter a (nhds_within a s) (nhds_within a t)] (hmeas : strongly_measurable_at_filter f (nhds_within a t) measure_theory.measure_space.volume) (ha : continuous_within_at f t a) : has_deriv_within_at (Î» (u : â„), âˆ« (x : â„) in u..b, f x) (-f a) s a
theorem orientation.rotation_eq_self_iff {V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) (x : V) (Î¸ : real.angle) : â‡‘(o.rotation Î¸) x = x â†” x = 0 âˆ¨ Î¸ = 0
theorem subsemiring.coe_closure_eq {R : Type u} [non_assoc_semiring R] (s : set R) : â†‘(subsemiring.closure s) = â†‘(add_submonoid.closure â†‘(submonoid.closure s))
theorem orthonormal.inner_left_right_finset {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {Î¹ : Type u_4} {s : finset Î¹} {v : Î¹ â†’ E} (hv : orthonormal ğ•œ v) {a : Î¹ â†’ Î¹ â†’ ğ•œ} : s.sum (Î» (i : Î¹), s.sum (Î» (j : Î¹), a i j â€¢ has_inner.inner (v j) (v i))) = s.sum (Î» (k : Î¹), a k k)
theorem monoid.image_closure {M : Type u_1} [monoid M] {A : Type u_2} [monoid A] {f : M â†’ A} (hf : is_monoid_hom f) (s : set M) : f '' monoid.closure s = monoid.closure (f '' s)
theorem linear_equiv.nonempty_equiv_iff_dim_eq {K : Type u} {V Vâ‚ : Type v} [division_ring K] [add_comm_group V] [module K V] [add_comm_group Vâ‚] [module K Vâ‚] : nonempty (V â‰ƒâ‚—[K] Vâ‚) â†” module.rank K V = module.rank K Vâ‚
theorem weak_dual.is_closed_image_coe_of_bounded_of_closed {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [semi_normed_group E] [normed_space ğ•œ E] {s : set (weak_dual ğ•œ E)} (hb : metric.bounded (â‡‘normed_space.dual.to_weak_dual â»Â¹' s)) (hc : is_closed s) : is_closed (coe_fn '' s)
theorem local_homeomorph.eq_on_source.eq_on {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] {e e' : local_homeomorph Î± Î²} (h : e â‰ˆ e') : set.eq_on â‡‘e â‡‘e' e.to_local_equiv.source
theorem nat.floor_div_eq_div {Î± : Type u_1} [linear_ordered_field Î±] [floor_semiring Î±] (m n : â„•) : âŒŠâ†‘m / â†‘nâŒ‹â‚Š = m / n
theorem is_alg_closed.ring_equiv_of_cardinal_eq_of_char_eq {K L : Type} [field K] [field L] [is_alg_closed K] [is_alg_closed L] (p : â„•) [char_p K p] [char_p L p] (hK : cardinal.aleph_0 < cardinal.mk K) (hKL : cardinal.mk K = cardinal.mk L) : K â‰ƒ+* L
theorem discrete_topology_of_discrete_uniformity {Î± : Type u_1} [hÎ± : uniform_space Î±] (h : uniformity Î± = filter.principal id_rel) : discrete_topology Î±
theorem nat.digits_lt_base {b m d : â„•} (hb : 2 â‰¤ b) (hd : d âˆˆ b.digits m) : d < b
theorem exists_smooth_zero_one_of_closed {E : Type uE} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] {H : Type uH} [topological_space H] (I : model_with_corners â„ E H) {M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] [t2_space M] [sigma_compact_space M] {s t : set M} (hs : is_closed s) (ht : is_closed t) (hd : disjoint s t) : âˆƒ (f : cont_mdiff_map I (model_with_corners_self â„ â„) M â„ âŠ¤), set.eq_on â‡‘f 0 s âˆ§ set.eq_on â‡‘f 1 t âˆ§ âˆ€ (x : M), â‡‘f x âˆˆ set.Icc 0 1
theorem orientation.oangle_rotation_right {V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) {x y : V} (hx : x â‰  0) (hy : y â‰  0) (Î¸ : real.angle) : o.oangle x (â‡‘(o.rotation Î¸) y) = o.oangle x y + Î¸
theorem homeomorph.is_O_congr {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] {E : Type u_3} [has_norm E] {F : Type u_4} [has_norm F] (e : Î± â‰ƒâ‚œ Î²) {b : Î²} {f : Î² â†’ E} {g : Î² â†’ F} : f =O[nhds b] g â†” (f âˆ˜ â‡‘e) =O[nhds (â‡‘(e.symm) b)] (g âˆ˜ â‡‘e)
theorem real.subgroup_dense_or_cyclic (G : add_subgroup â„) : dense â†‘G âˆ¨ âˆƒ (a : â„), G = add_subgroup.closure {a}
theorem fin.strict_mono_iff_lt_succ {n : â„•} {Î± : Type u_1} [preorder Î±] {f : fin (n + 1) â†’ Î±} : strict_mono f â†” âˆ€ (i : fin n), f (â‡‘fin.cast_succ i) < f i.succ
theorem is_integral_localization {R : Type u_1} [comm_ring R] {M : submonoid R} {S : Type u_2} [comm_ring S] [algebra R S] {Râ‚˜ : Type u_4} {Sâ‚˜ : Type u_5} [comm_ring Râ‚˜] [comm_ring Sâ‚˜] [algebra R Râ‚˜] [is_localization M Râ‚˜] [algebra S Sâ‚˜] [is_localization (algebra.algebra_map_submonoid S M) Sâ‚˜] (H : algebra.is_integral R S) : (is_localization.map Sâ‚˜ (algebra_map R S) _).is_integral
theorem category_theory.has_initial_of_weakly_initial_and_has_wide_equalizers {C : Type u} [category_theory.category C] [category_theory.limits.has_wide_equalizers C] {T : C} (hT : âˆ€ (X : C), nonempty (T âŸ¶ X)) : category_theory.limits.has_initial C
theorem pgame.lf_iff_forall_le {x y : pgame} : x.lf y â†” (âˆƒ (i : y.left_moves), x â‰¤ y.move_left i) âˆ¨ âˆƒ (j : x.right_moves), x.move_right j â‰¤ y
theorem orientation.oangle_rotation_self_right {V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) {x : V} (hx : x â‰  0) (Î¸ : real.angle) : o.oangle x (â‡‘(o.rotation Î¸) x) = Î¸
theorem is_torsion.extension_closed {G : Type u_1} {H : Type u_2} [group G] {N : subgroup G} [group H] {f : G â†’* H} (hN : N = f.ker) (tH : monoid.is_torsion H) (tN : monoid.is_torsion â†¥N) : monoid.is_torsion G
theorem local_equiv.trans_symm_self {Î± : Type u_1} {Î² : Type u_2} (e : local_equiv Î± Î²) : e.symm.trans e â‰ˆ local_equiv.of_set e.target
theorem fintype.induction_empty_option' {P : Î  (Î± : Type u) [_inst_1 : fintype Î±], Prop} (of_equiv : âˆ€ (Î± Î² : Type u) [_inst_2 : fintype Î²] (e : Î± â‰ƒ Î²), P Î± â†’ P Î²) (h_empty : P pempty) (h_option : âˆ€ (Î± : Type u) [_inst_3 : fintype Î±], P Î± â†’ P (option Î±)) (Î± : Type u) [fintype Î±] : P Î±
theorem function.semiconj.symm_adjoint {Î± : Type u_1} {Î² : Type u_2} [partial_order Î±] [preorder Î²] {fa : Î± â‰ƒo Î±} {fb : Î² â†ªo Î²} {g : Î± â†’ Î²} (h : function.semiconj g â‡‘fa â‡‘fb) {g' : Î² â†’ Î±} (hg' : is_order_right_adjoint g g') : function.semiconj g' â‡‘fb â‡‘fa
theorem simple_graph.to_graph_adj_matrix_eq {V : Type u_1} (Î± : Type u_2) (G : simple_graph V) [decidable_rel G.adj] [mul_zero_one_class Î±] [nontrivial Î±] : _.to_graph = G
theorem local_equiv.eq_on_source.symm_eq_on {Î± : Type u_1} {Î² : Type u_2} {e e' : local_equiv Î± Î²} (h : e â‰ˆ e') : set.eq_on â‡‘(e.symm) â‡‘(e'.symm) e.target
theorem measure_theory.mem_â„’p.induction {Î± : Type u_1} {E : Type u_4} [measurable_space Î±] [normed_group E] {p : ennreal} {Î¼ : measure_theory.measure Î±} [fact (1 â‰¤ p)] (hp_ne_top : p â‰  âŠ¤) (P : (Î± â†’ E) â†’ Prop) (h_ind : âˆ€ (c : E) â¦ƒs : set Î±â¦„, measurable_set s â†’ â‡‘Î¼ s < âŠ¤ â†’ P (s.indicator (Î» (_x : Î±), c))) (h_add : âˆ€ â¦ƒf g : Î± â†’ Eâ¦„, disjoint (function.support f) (function.support g) â†’ measure_theory.mem_â„’p f p Î¼ â†’ measure_theory.mem_â„’p g p Î¼ â†’ P f â†’ P g â†’ P (f + g)) (h_closed : is_closed {f : â†¥(measure_theory.Lp E p Î¼) | P â‡‘f}) (h_ae : âˆ€ â¦ƒf g : Î± â†’ Eâ¦„, f =áµ[Î¼] g â†’ measure_theory.mem_â„’p f p Î¼ â†’ P f â†’ P g) â¦ƒf : Î± â†’ Eâ¦„ (hf : measure_theory.mem_â„’p f p Î¼) : P f
theorem category_theory.limits.has_equalizers_of_pullbacks_and_binary_products {C : Type u} [category_theory.category C] [category_theory.limits.has_binary_products C] [category_theory.limits.has_pullbacks C] : category_theory.limits.has_equalizers C
theorem submodule.is_torsion'_iff_torsion'_eq_top {R : Type u_1} {M : Type u_2} [comm_semiring R] [add_comm_monoid M] [module R M] (S : Type u_3) [comm_monoid S] [distrib_mul_action S M] [smul_comm_class S R M] : module.is_torsion' M S â†” submodule.torsion' R M S = âŠ¤
theorem double_quot.ker_quot_left_to_quot_sup {R : Type u} [comm_ring R] (I J : ideal R) : (double_quot.quot_left_to_quot_sup I J).ker = ideal.map (ideal.quotient.mk I) J
theorem is_closed_std_simplex (Î¹ : Type u_1) [fintype Î¹] : is_closed (std_simplex â„ Î¹)
theorem order.succ_lt_succ {Î± : Type u_1} [preorder Î±] [succ_order Î±] {a b : Î±} [no_max_order Î±] : a < b â†’ order.succ a < order.succ b
theorem inner_product_geometry.angle_add_angle_eq_pi_of_angle_eq_pi {V : Type u_1} [inner_product_space â„ V] {x y : V} (z : V) (h : inner_product_geometry.angle x y = real.pi) : inner_product_geometry.angle x z + inner_product_geometry.angle y z = real.pi
theorem cont_mdiff.continuous_tangent_map {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {M : Type u_4} [topological_space M] [charted_space H M] [Is : smooth_manifold_with_corners I M] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners ğ•œ E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] [I's : smooth_manifold_with_corners I' M'] {f : M â†’ M'} {n : with_top â„•} (hf : cont_mdiff I I' n f) (hmn : 1 â‰¤ n) : continuous (tangent_map I I' f)
theorem orientation.oangle_eq_iff_eq_norm_div_norm_smul_rotation_or_eq_zero {V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) {x y : V} (Î¸ : real.angle) : o.oangle x y = Î¸ â†” x â‰  0 âˆ§ y â‰  0 âˆ§ y = (âˆ¥yâˆ¥ / âˆ¥xâˆ¥) â€¢ â‡‘(o.rotation Î¸) x âˆ¨ Î¸ = 0 âˆ§ (x = 0 âˆ¨ y = 0)
theorem finset.sum_insert_of_eq_zero_if_not_mem {Î² : Type u} {Î± : Type v} {s : finset Î±} {a : Î±} {f : Î± â†’ Î²} [add_comm_monoid Î²] [decidable_eq Î±] (h : a âˆ‰ s â†’ f a = 0) : (has_insert.insert a s).sum (Î» (x : Î±), f x) = s.sum (Î» (x : Î±), f x)
theorem infi_ne_top_subtype {Î± : Type u_1} {Î¹ : Sort u_4} [complete_lattice Î±] (f : Î¹ â†’ Î±) : (â¨… (i : {i // f i â‰  âŠ¤}), f â†‘i) = â¨… (i : Î¹), f i
theorem measure_theory.lintegral_supr_ae {Î± : Type u_1} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {f : â„• â†’ Î± â†’ ennreal} (hf : âˆ€ (n : â„•), measurable (f n)) (h_mono : âˆ€ (n : â„•), âˆ€áµ (a : Î±) âˆ‚Î¼, f n a â‰¤ f n.succ a) : âˆ«â» (a : Î±), (â¨† (n : â„•), f n a) âˆ‚Î¼ = â¨† (n : â„•), âˆ«â» (a : Î±), f n a âˆ‚Î¼
theorem finsum_mem_image' {Î± : Type u_1} {Î² : Type u_2} {M : Type u_5} [add_comm_monoid M] {f : Î± â†’ M} {s : set Î²} {g : Î² â†’ Î±} (hg : set.inj_on g (s âˆ© function.support (f âˆ˜ g))) : finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ g '' s), f i)) = finsum (Î» (j : Î²), finsum (Î» (H : j âˆˆ s), f (g j)))
theorem metric.Hausdorff_dist_self_closure {Î± : Type u} [pseudo_metric_space Î±] {s : set Î±} : metric.Hausdorff_dist s (closure s) = 0
theorem submodule.norm_coe {ğ•œ : Type u_1} {_x : ring ğ•œ} {E : Type u_2} [semi_normed_group E] {_x_1 : module ğ•œ E} {s : submodule ğ•œ E} (x : â†¥s) : âˆ¥â†‘xâˆ¥ = âˆ¥xâˆ¥
theorem mvqpf.cofix.bisimâ‚‚ {n : â„•} {F : typevec (n + 1) â†’ Type u} [mvfunctor F] [q : mvqpf F] {Î± : typevec n} (r : mvqpf.cofix F Î± â†’ mvqpf.cofix F Î± â†’ Prop) (h : âˆ€ (x y : mvqpf.cofix F Î±), r x y â†’ mvfunctor.liftr' (Î±.rel_last' r) x.dest y.dest) (x y : mvqpf.cofix F Î±) : r x y â†’ x = y
theorem category_theory.limits.biprod.braid_natural {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_binary_biproducts C] {W X Y Z : C} (f : X âŸ¶ Y) (g : Z âŸ¶ W) : category_theory.limits.biprod.map f g â‰« (category_theory.limits.biprod.braiding Y W).hom = (category_theory.limits.biprod.braiding X Z).hom â‰« category_theory.limits.biprod.map g f
theorem finset.exists_sum_fiber_lt_of_maps_to_of_sum_lt_nsmul {Î± : Type u} {Î² : Type v} {M : Type w} [decidable_eq Î²] {s : finset Î±} {t : finset Î²} {f : Î± â†’ Î²} {w : Î± â†’ M} {b : M} [linear_ordered_cancel_add_comm_monoid M] (hf : âˆ€ (a : Î±), a âˆˆ s â†’ f a âˆˆ t) (hb : s.sum (Î» (x : Î±), w x) < t.card â€¢ b) : âˆƒ (y : Î²) (H : y âˆˆ t), (finset.filter (Î» (x : Î±), f x = y) s).sum (Î» (x : Î±), w x) < b
theorem Limsup_eq_of_le_nhds {Î± : Type u} [conditionally_complete_linear_order Î±] [topological_space Î±] [order_topology Î±] {f : filter Î±} {a : Î±} [f.ne_bot] : f â‰¤ nhds a â†’ f.Limsup = a
theorem semiconj_by.eq {S : Type u} [has_mul S] {a x y : S} (h : semiconj_by a x y) : a * x = y * a
theorem continuous_map.compact_conv_nhd_subset_compact_open {Î± : Type uâ‚} {Î² : Type uâ‚‚} [topological_space Î±] [uniform_space Î²] {K : set Î±} (f : C(Î±, Î²)) (hK : is_compact K) {U : set Î²} (hU : is_open U) (hf : f âˆˆ continuous_map.compact_open.gen K U) : âˆƒ (V : set (Î² Ã— Î²)) (H : V âˆˆ uniformity Î²), is_open V âˆ§ continuous_map.compact_conv_nhd K V f âŠ† continuous_map.compact_open.gen K U
theorem category_theory.simplicial_object.Î´_comp_Ïƒ_self {C : Type u} [category_theory.category C] (X : category_theory.simplicial_object C) {n : â„•} {i : fin (n + 1)} : X.Ïƒ i â‰« X.Î´ (â‡‘fin.cast_succ i) = ğŸ™ (X.obj (opposite.op (simplex_category.mk n)))
theorem fin.cons_self_tail {n : â„•} {Î± : fin (n + 1) â†’ Type u} (q : Î  (i : fin (n + 1)), Î± i) : fin.cons (q 0) (fin.tail q) = q
theorem dim_submodule_le_one_iff {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] (s : submodule K V) : module.rank K â†¥s â‰¤ 1 â†” âˆƒ (vâ‚€ : V) (H : vâ‚€ âˆˆ s), s â‰¤ submodule.span K {vâ‚€}
theorem orthogonal_projection_fn_inner_eq_zero {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {K : submodule ğ•œ E} [complete_space â†¥K] (v w : E) (H : w âˆˆ K) : has_inner.inner (v - orthogonal_projection_fn K v) w = 0
theorem tfae_mem_nhds_within_Ici {Î± : Type u} [topological_space Î±] [linear_order Î±] [order_topology Î±] {a b : Î±} (hab : a < b) (s : set Î±) : [s âˆˆ nhds_within a (set.Ici a), s âˆˆ nhds_within a (set.Icc a b), s âˆˆ nhds_within a (set.Ico a b), âˆƒ (u : Î±) (H : u âˆˆ set.Ioc a b), set.Ico a u âŠ† s, âˆƒ (u : Î±) (H : u âˆˆ set.Ioi a), set.Ico a u âŠ† s].tfae
theorem category_theory.strong_epi_comp {C : Type u} [category_theory.category C] {P Q R : C} (f : P âŸ¶ Q) (g : Q âŸ¶ R) [category_theory.strong_epi f] [category_theory.strong_epi g] : category_theory.strong_epi (f â‰« g)
theorem alternating_map.comp_linear_map_assoc {R : Type u_1} [semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {N : Type u_3} [add_comm_monoid N] [module R N] {Î¹ : Type u_6} [decidable_eq Î¹] {Mâ‚‚ : Type u_7} [add_comm_monoid Mâ‚‚] [module R Mâ‚‚] {Mâ‚ƒ : Type u_8} [add_comm_monoid Mâ‚ƒ] [module R Mâ‚ƒ] (f : alternating_map R M N Î¹) (gâ‚ : Mâ‚‚ â†’â‚—[R] M) (gâ‚‚ : Mâ‚ƒ â†’â‚—[R] Mâ‚‚) : (f.comp_linear_map gâ‚).comp_linear_map gâ‚‚ = f.comp_linear_map (gâ‚.comp gâ‚‚)
theorem left.one_lt_mul {Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a b : Î±} (ha : 1 < a) (hb : 1 < b) : 1 < a * b
theorem subsemiring.multiset_prod_mem {R : Type u_1} [comm_semiring R] (s : subsemiring R) (m : multiset R) : (âˆ€ (a : R), a âˆˆ m â†’ a âˆˆ s) â†’ m.prod âˆˆ s
theorem first_order.language.directed_system.map_self {L : first_order.language} {Î¹ : Type v} [preorder Î¹] {G : Î¹ â†’ Type w} [Î  (i : Î¹), L.Structure (G i)] (f : Î  (i j : Î¹), i â‰¤ j â†’ L.embedding (G i) (G j)) [directed_system G (Î» (i j : Î¹) (h : i â‰¤ j), â‡‘(f i j h))] (i : Î¹) (x : G i) (h : i â‰¤ i) : â‡‘(f i i h) x = x
theorem dist_convolution_le' {ğ•œ : Type u_1} {G : Type u_2} {E : Type u_3} {E' : Type u_4} {F : Type u_6} [normed_group E] [normed_group E'] [normed_group F] {f : G â†’ E} {g : G â†’ E'} [nondiscrete_normed_field ğ•œ] [normed_space ğ•œ E] [normed_space ğ•œ E'] [normed_space ğ•œ F] (L : E â†’L[ğ•œ] E' â†’L[ğ•œ] F) [measurable_space G] {Î¼ : measure_theory.measure G} [normed_space â„ F] [complete_space F] [semi_normed_group G] [borel_space G] [topological_space.second_countable_topology G] [Î¼.is_add_left_invariant] [measure_theory.sigma_finite Î¼] {xâ‚€ : G} {R Îµ : â„} (hÎµ : 0 â‰¤ Îµ) (hif : measure_theory.integrable f Î¼) (hf : function.support f âŠ† metric.ball 0 R) (hmg : measure_theory.ae_strongly_measurable g Î¼) (hg : âˆ€ (x : G), x âˆˆ metric.ball xâ‚€ R â†’ has_dist.dist (g x) (g xâ‚€) â‰¤ Îµ) : has_dist.dist (convolution f g L Î¼ xâ‚€) (âˆ« (t : G), â‡‘(â‡‘L (f t)) (g xâ‚€) âˆ‚Î¼) â‰¤ âˆ¥Lâˆ¥ * âˆ« (x : G), âˆ¥f xâˆ¥ âˆ‚Î¼ * Îµ
theorem fin.cast_add_cast {n n' : â„•} (m : â„•) (i : fin n') (h : n' = n) : â‡‘(fin.cast_add m) (â‡‘(fin.cast h) i) = â‡‘(fin.cast _) (â‡‘(fin.cast_add m) i)
theorem polynomial.contraction_degree_eq_aux {F : Type} [field F] (q : â„•) [hq : fact (nat.prime q)] [hF : char_p F q] (g g' : polynomial F) (m m' : â„•) (h_expand : â‡‘(polynomial.expand F (q ^ m)) g = â‡‘(polynomial.expand F (q ^ m')) g') (h : m < m') (hg : g.separable) : g.nat_degree = g'.nat_degree
theorem matrix.circulant_mul_comm {Î± : Type u_1} {n : Type u_4} [comm_semigroup Î±] [add_comm_monoid Î±] [fintype n] [add_comm_group n] (v w : n â†’ Î±) : (matrix.circulant v).mul (matrix.circulant w) = (matrix.circulant w).mul (matrix.circulant v)
theorem measure_theory.lintegral_add_right {Î± : Type u_1} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (f : Î± â†’ ennreal) {g : Î± â†’ ennreal} (hg : measurable g) : âˆ«â» (a : Î±), f a + g a âˆ‚Î¼ = âˆ«â» (a : Î±), f a âˆ‚Î¼ + âˆ«â» (a : Î±), g a âˆ‚Î¼
theorem nndist_dist {Î± : Type u} [pseudo_metric_space Î±] (x y : Î±) : has_nndist.nndist x y = (has_dist.dist x y).to_nnreal
theorem well_founded.monotone_chain_condition (Î± : Type u_1) [partial_order Î±] : well_founded gt â†” âˆ€ (a : â„• â†’o Î±), âˆƒ (n : â„•), âˆ€ (m : â„•), n â‰¤ m â†’ â‡‘a n = â‡‘a m
theorem is_compact.exists_open_superset_measure_lt_top {Î± : Type u_1} [topological_space Î±] [measurable_space Î±] {s : set Î±} (h : is_compact s) (Î¼ : measure_theory.measure Î±) [measure_theory.is_locally_finite_measure Î¼] : âˆƒ (U : set Î±) (H : U âŠ‡ s), is_open U âˆ§ â‡‘Î¼ U < âŠ¤
theorem real_inner_add_add_self {F : Type u_3} [inner_product_space â„ F] {x y : F} : has_inner.inner (x + y) (x + y) = has_inner.inner x x + 2 * has_inner.inner x y + has_inner.inner y y
theorem finrank_orthogonal_span_singleton {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {n : â„•} [fact (finite_dimensional.finrank ğ•œ E = n + 1)] {v : E} (hv : v â‰  0) : finite_dimensional.finrank ğ•œ â†¥(submodule.span ğ•œ {v})á—® = n
theorem inner_map_polarization {V : Type u_4} [inner_product_space â„‚ V] (T : V â†’â‚—[â„‚] V) (x y : V) : has_inner.inner (â‡‘T y) x = (has_inner.inner (â‡‘T (x + y)) (x + y) - has_inner.inner (â‡‘T (x - y)) (x - y) + complex.I * has_inner.inner (â‡‘T (x + complex.I â€¢ y)) (x + complex.I â€¢ y) - complex.I * has_inner.inner (â‡‘T (x - complex.I â€¢ y)) (x - complex.I â€¢ y)) / 4
theorem linear_map.ext_basis {Î¹â‚ : Type u_1} {Î¹â‚‚ : Type u_2} {R : Type u_3} {Râ‚‚ : Type u_4} {S : Type u_5} {Sâ‚‚ : Type u_6} {M : Type u_7} {N : Type u_8} {P : Type u_9} [comm_ring R] [comm_ring S] [comm_ring Râ‚‚] [comm_ring Sâ‚‚] [add_comm_group M] [add_comm_group N] [add_comm_group P] [module R M] [module S N] [module Râ‚‚ P] [module Sâ‚‚ P] [smul_comm_class Sâ‚‚ Râ‚‚ P] {Ïâ‚â‚‚ : R â†’+* Râ‚‚} {Ïƒâ‚â‚‚ : S â†’+* Sâ‚‚} (bâ‚ : basis Î¹â‚ R M) (bâ‚‚ : basis Î¹â‚‚ S N) {B B' : M â†’â‚›â‚—[Ïâ‚â‚‚] N â†’â‚›â‚—[Ïƒâ‚â‚‚] P} (h : âˆ€ (i : Î¹â‚) (j : Î¹â‚‚), â‡‘(â‡‘B (â‡‘bâ‚ i)) (â‡‘bâ‚‚ j) = â‡‘(â‡‘B' (â‡‘bâ‚ i)) (â‡‘bâ‚‚ j)) : B = B'
theorem real.summable_nat_pow_inv {p : â„•} : summable (Î» (n : â„•), (â†‘n ^ p)â»Â¹) â†” 1 < p
theorem filter.liminf_const_top {Î± : Type u_1} {Î² : Type u_2} [complete_lattice Î±] {f : filter Î²} : f.liminf (Î» (x : Î²), âŠ¤) = âŠ¤
theorem Kuratowski_embedding.embedding_of_subset_dist_le {Î± : Type u} [metric_space Î±] (x : â„• â†’ Î±) (a b : Î±) : has_dist.dist (Kuratowski_embedding.embedding_of_subset x a) (Kuratowski_embedding.embedding_of_subset x b) â‰¤ has_dist.dist a b
theorem finset.sup_univ_eq_supr {Î± : Type u_1} {Î² : Type u_2} [fintype Î±] [complete_lattice Î²] (f : Î± â†’ Î²) : finset.univ.sup f = supr f
theorem uv.card_compression {Î± : Type u_1} [generalized_boolean_algebra Î±] [decidable_rel disjoint] [decidable_rel has_le.le] (u v : Î±) (s : finset Î±) : (uv.compression u v s).card = s.card
theorem polynomial.degree_prod {R : Type u} {Î¹ : Type w} (s : finset Î¹) [comm_semiring R] [no_zero_divisors R] (f : Î¹ â†’ polynomial R) [nontrivial R] : (s.prod (Î» (i : Î¹), f i)).degree = s.sum (Î» (i : Î¹), (f i).degree)
theorem box_integral.integrable.cauchy_map_integral_sum_to_filter_Union {Î¹ : Type u} {E : Type v} {F : Type w} [normed_group E] [normed_space â„ E] [normed_group F] [normed_space â„ F] {I : box_integral.box Î¹} [fintype Î¹] {l : box_integral.integration_params} {f : (Î¹ â†’ â„) â†’ E} {vol : box_integral.box_additive_map Î¹ (E â†’L[â„] F) âŠ¤} (h : box_integral.integrable I l f vol) (Ï€â‚€ : box_integral.prepartition I) : cauchy (filter.map (box_integral.integral_sum f vol) (l.to_filter_Union I Ï€â‚€))
theorem complex.det_conj_ae  : â‡‘linear_map.det complex.conj_ae.to_linear_map = -1
theorem same_ray.exists_eq_smul_add {R : Type u_1} [linear_ordered_field R] {M : Type u_2} [add_comm_group M] [module R M] {vâ‚ vâ‚‚ : M} (h : same_ray R vâ‚ vâ‚‚) : âˆƒ (a b : R), 0 â‰¤ a âˆ§ 0 â‰¤ b âˆ§ a + b = 1 âˆ§ vâ‚ = a â€¢ (vâ‚ + vâ‚‚) âˆ§ vâ‚‚ = b â€¢ (vâ‚ + vâ‚‚)
theorem emetric.subset_countable_closure_of_compact {Î± : Type u} [pseudo_emetric_space Î±] {s : set Î±} (hs : is_compact s) : âˆƒ (t : set Î±) (H : t âŠ† s), t.countable âˆ§ s âŠ† closure t
theorem mv_polynomial.evalâ‚‚_hom_X {S : Type v} [comm_ring S] {R : Type u} (c : â„¤ â†’+* S) (f : mv_polynomial R â„¤ â†’+* S) (x : mv_polynomial R â„¤) : mv_polynomial.evalâ‚‚ c (â‡‘f âˆ˜ mv_polynomial.X) x = â‡‘f x
theorem probability_theory.ident_distrib.ae_strongly_measurable_snd {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [measurable_space Î±] [measurable_space Î²] [measurable_space Î³] {Î¼ : measure_theory.measure Î±} {Î½ : measure_theory.measure Î²} {f : Î± â†’ Î³} {g : Î² â†’ Î³} [topological_space Î³] [topological_space.metrizable_space Î³] [borel_space Î³] (h : probability_theory.ident_distrib f g Î¼ Î½) (hf : measure_theory.ae_strongly_measurable f Î¼) : measure_theory.ae_strongly_measurable g Î½
theorem comp_add_left {Î± : Type u_1} [add_semigroup Î±] (x y : Î±) : has_add.add x âˆ˜ has_add.add y = has_add.add (x + y)
theorem algebra.discr_of_matrix_vec_mul {A : Type u} {B : Type v} {Î¹ : Type w} [comm_ring A] [comm_ring B] [algebra A B] [fintype Î¹] [decidable_eq Î¹] (b : Î¹ â†’ B) (P : matrix Î¹ Î¹ A) : algebra.discr A (matrix.vec_mul b (P.map â‡‘(algebra_map A B))) = P.det ^ 2 * algebra.discr A b
theorem nat.set_induction_bounded {b : â„•} {S : set â„•} (hb : b âˆˆ S) (h_ind : âˆ€ (k : â„•), k âˆˆ S â†’ k + 1 âˆˆ S) {n : â„•} (hbn : b â‰¤ n) : n âˆˆ S
theorem quotient_add_group.add_subgroup_eq_top_of_subsingleton {G : Type u} [add_group G] (H : add_subgroup G) (h : subsingleton (G â§¸ H)) : H = âŠ¤
theorem finsupp.coe_fn_inj {Î± : Type u_1} {M : Type u_5} [has_zero M] {f g : Î± â†’â‚€ M} : â‡‘f = â‡‘g â†” f = g
theorem measure_theory.submartingale_of_expected_stopped_value_mono {Î± : Type u_1} {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {ğ’¢ : measure_theory.filtration â„• m0} [measure_theory.is_finite_measure Î¼] {f : â„• â†’ Î± â†’ â„} (hadp : measure_theory.adapted ğ’¢ f) (hint : âˆ€ (i : â„•), measure_theory.integrable (f i) Î¼) (hf : âˆ€ (Ï„ Ï€ : Î± â†’ â„•), measure_theory.is_stopping_time ğ’¢ Ï„ â†’ measure_theory.is_stopping_time ğ’¢ Ï€ â†’ Ï„ â‰¤ Ï€ â†’ (âˆƒ (N : â„•), âˆ€ (x : Î±), Ï€ x â‰¤ N) â†’ âˆ« (x : Î±), measure_theory.stopped_value f Ï„ x âˆ‚Î¼ â‰¤ âˆ« (x : Î±), measure_theory.stopped_value f Ï€ x âˆ‚Î¼) : measure_theory.submartingale f ğ’¢ Î¼
theorem Module.has_cokernels_Module {R : Type u} [ring R] : category_theory.limits.has_cokernels (Module R)
theorem list.map_permutations_aux2 {Î± : Type u_1} {Î² : Type u_2} (t : Î±) (ts ys : list Î±) (f : list Î± â†’ Î²) : list.map f (list.permutations_aux2 t ts list.nil ys id).snd = (list.permutations_aux2 t ts list.nil ys f).snd
theorem strict_anti.strict_concave_on_univ_of_deriv {f : â„ â†’ â„} (hf : differentiable â„ f) (hf'_anti : strict_anti (deriv f)) : strict_concave_on â„ set.univ f
theorem metric.diam_singleton {Î± : Type u} [pseudo_metric_space Î±] {x : Î±} : metric.diam {x} = 0
theorem szemeredi_regularity.step_bound_pos {n : â„•} : 0 < n â†’ 0 < szemeredi_regularity.step_bound n
theorem convex.translate_preimage_right {ğ•œ : Type u_1} {E : Type u_2} [ordered_semiring ğ•œ] [add_comm_monoid E] [module ğ•œ E] {s : set E} (hs : convex ğ•œ s) (z : E) : convex ğ•œ ((Î» (x : E), z + x) â»Â¹' s)
theorem local_homeomorph.is_image.symm_preimage_eq {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] {e : local_homeomorph Î± Î²} {s : set Î±} {t : set Î²} : e.is_image s t â†’ e.to_local_equiv.target âˆ© â‡‘(e.symm) â»Â¹' s = e.to_local_equiv.target âˆ© t
theorem exists_increasing_or_nonincreasing_subseq {Î± : Type u_1} (r : Î± â†’ Î± â†’ Prop) [is_trans Î± r] (f : â„• â†’ Î±) : âˆƒ (g : â„• â†ªo â„•), (âˆ€ (m n : â„•), m < n â†’ r (f (â‡‘g m)) (f (â‡‘g n))) âˆ¨ âˆ€ (m n : â„•), m < n â†’ Â¬r (f (â‡‘g m)) (f (â‡‘g n))
theorem multiples.self_mem {M : Type u_1} [add_monoid M] {x : M} : x âˆˆ multiples x
theorem complex.tendsto_exp_comap_re_at_top  : filter.tendsto complex.exp (filter.comap complex.re filter.at_top) (filter.comap complex.abs filter.at_top)
theorem rel_embedding.coe_fn_injective {Î± : Type u_1} {Î² : Type u_2} {r : Î± â†’ Î± â†’ Prop} {s : Î² â†’ Î² â†’ Prop} : function.injective coe_fn
theorem multiple_mem_adjoin_of_mem_localization_adjoin {R S : Type u} [comm_ring R] [comm_ring S] (M : submonoid R) (R' : Type u) [comm_ring R'] [algebra R R'] [algebra R' S] [algebra R S] [is_scalar_tower R R' S] [is_localization M R'] (s : set S) (x : S) (hx : x âˆˆ algebra.adjoin R' s) : âˆƒ (t : â†¥M), t â€¢ x âˆˆ algebra.adjoin R s
theorem category_theory.limits.finite_colimits_from_coequalizers_and_finite_coproducts {C : Type u} [category_theory.category C] [category_theory.limits.has_finite_coproducts C] [category_theory.limits.has_coequalizers C] : category_theory.limits.has_finite_colimits C
theorem subgroup.closure_induction {G : Type u_1} [group G] {k : set G} {p : G â†’ Prop} {x : G} (h : x âˆˆ subgroup.closure k) (Hk : âˆ€ (x : G), x âˆˆ k â†’ p x) (H1 : p 1) (Hmul : âˆ€ (x y : G), p x â†’ p y â†’ p (x * y)) (Hinv : âˆ€ (x : G), p x â†’ p xâ»Â¹) : p x
theorem antitone.pairwise_disjoint_on_Ioc_succ {Î± : Type u_1} {Î² : Type u_2} [linear_order Î±] [succ_order Î±] [preorder Î²] {f : Î± â†’ Î²} (hf : antitone f) : pairwise (disjoint on Î» (n : Î±), set.Ioc (f (order.succ n)) (f n))
theorem add_order_of_pos_iff {G : Type u} {x : G} [add_monoid G] : 0 < add_order_of x â†” is_of_fin_add_order x
theorem bernstein_approximation.le_of_mem_S_compl {f : C(â†¥unit_interval, â„)} {Îµ : â„} {h : 0 < Îµ} {n : â„•} {x : â†¥unit_interval} {k : fin (n + 1)} (m : k âˆˆ (bernstein_approximation.S f Îµ h n x)á¶œ) : 1 â‰¤ bernstein_approximation.Î´ f Îµ h ^ -2 * (â†‘x - â†‘(bernstein.z k)) ^ 2
theorem star_ring_end_apply {R : Type u} [comm_semiring R] [star_ring R] {x : R} : â‡‘(star_ring_end R) x = has_star.star x
theorem finrank_eq_one_iff_of_nonzero' {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] (v : V) (nz : v â‰  0) : finite_dimensional.finrank K V = 1 â†” âˆ€ (w : V), âˆƒ (c : K), c â€¢ v = w
theorem topological_group.continuous_conj_prod {G : Type w} [topological_space G] [has_inv G] [has_mul G] [has_continuous_mul G] [has_continuous_inv G] : continuous (Î» (g : G Ã— G), g.fst * g.snd * (g.fst)â»Â¹)
theorem nnnorm_le_insert {E : Type u_3} [semi_normed_group E] (u v : E) : âˆ¥vâˆ¥â‚Š â‰¤ âˆ¥uâˆ¥â‚Š + âˆ¥u - vâˆ¥â‚Š
theorem has_sum_zero {Î± : Type u_1} {Î² : Type u_2} [add_comm_monoid Î±] [topological_space Î±] : has_sum (Î» (b : Î²), 0) 0
theorem monoid_hom.map_finprod_mem' {Î± : Type u_1} {M : Type u_5} {N : Type u_6} [comm_monoid M] [comm_monoid N] {s : set Î±} {f : Î± â†’ M} (g : M â†’* N) (hâ‚€ : (s âˆ© function.mul_support f).finite) : â‡‘g (finprod (Î» (j : Î±), finprod (Î» (H : j âˆˆ s), f j))) = finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), â‡‘g (f i)))
theorem is_integral_tower_top_of_is_integral {R : Type u_1} {A : Type u_2} {B : Type u_3} [comm_ring R] [comm_ring A] [comm_ring B] [algebra A B] [algebra R B] [algebra R A] [is_scalar_tower R A B] {x : B} (h : is_integral R x) : is_integral A x
theorem measure_theory.measurably_separable_range_of_disjoint {Î± : Type u_1} [topological_space Î±] [t2_space Î±] [measurable_space Î±] [borel_space Î±] {f g : (â„• â†’ â„•) â†’ Î±} (hf : continuous f) (hg : continuous g) (h : disjoint (set.range f) (set.range g)) : measure_theory.measurably_separable (set.range f) (set.range g)
theorem is_cyclotomic_extension.is_prime_pow_norm_zeta_sub_one {n : â„•+} {K : Type u} (L : Type v) [field K] [field L] [algebra K L] [ne_zero â†‘â†‘n] (hn : is_prime_pow â†‘n) [is_cyclotomic_extension {n} K L] (hirr : irreducible (polynomial.cyclotomic â†‘n K)) (h : n â‰  2) : â‡‘(algebra.norm K) (is_cyclotomic_extension.zeta n K L - 1) = â†‘(â†‘n.min_fac)
theorem is_group_hom.mul {Î± : Type u_1} {Î² : Type u_2} [group Î±] [comm_group Î²] {f g : Î± â†’ Î²} (hf : is_group_hom f) (hg : is_group_hom g) : is_group_hom (Î» (a : Î±), f a * g a)
theorem continuous_multilinear_map.cons_smul {R : Type u} {n : â„•} {M : fin n.succ â†’ Type w} {Mâ‚‚ : Type wâ‚‚} [semiring R] [Î  (i : fin n.succ), add_comm_monoid (M i)] [add_comm_monoid Mâ‚‚] [Î  (i : fin n.succ), module R (M i)] [module R Mâ‚‚] [Î  (i : fin n.succ), topological_space (M i)] [topological_space Mâ‚‚] (f : continuous_multilinear_map R M Mâ‚‚) (m : Î  (i : fin n), M i.succ) (c : R) (x : M 0) : â‡‘f (fin.cons (c â€¢ x) m) = c â€¢ â‡‘f (fin.cons x m)
theorem order_of_pow {G : Type u} {n : â„•} [fintype G] [left_cancel_monoid G] (x : G) : order_of (x ^ n) = order_of x / (order_of x).gcd n
theorem closed_embedding.polish_space {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] [polish_space Î²] {f : Î± â†’ Î²} (hf : closed_embedding f) : polish_space Î±
theorem turing.list_blank.exists_cons {Î“ : Type u_1} [inhabited Î“] (l : turing.list_blank Î“) : âˆƒ (a : Î“) (l' : turing.list_blank Î“), l = turing.list_blank.cons a l'
theorem separate_convex_open_set {E : Type u_2} [semi_normed_group E] [normed_space â„ E] {s : set E} (hsâ‚€ : 0 âˆˆ s) (hsâ‚ : convex â„ s) (hsâ‚‚ : is_open s) {xâ‚€ : E} (hxâ‚€ : xâ‚€ âˆ‰ s) : âˆƒ (f : E â†’L[â„] â„), â‡‘f xâ‚€ = 1 âˆ§ âˆ€ (x : E), x âˆˆ s â†’ â‡‘f x < 1
theorem nat.digits_lt_base' {b m d : â„•} : d âˆˆ (b + 2).digits m â†’ d < b + 2
theorem Exists.some_spec {Î± : Sort u_1} {p : Î± â†’ Prop} (P : âˆƒ (a : Î±), p a) : p P.some
theorem metric.inf_edist_le_inf_edist_cthickening_add {Î± : Type u} [pseudo_emetric_space Î±] {Î´ : â„} {s : set Î±} {x : Î±} : emetric.inf_edist x s â‰¤ emetric.inf_edist x (metric.cthickening Î´ s) + ennreal.of_real Î´
theorem convolution_lsmul_swap {ğ•œ : Type u_1} {G : Type u_2} {F : Type u_6} [normed_group F] {x : G} [nondiscrete_normed_field ğ•œ] [normed_space ğ•œ F] [measurable_space G] {Î¼ : measure_theory.measure G} [normed_space â„ F] [complete_space F] [add_comm_group G] [topological_space G] [topological_add_group G] [borel_space G] [Î¼.is_add_left_invariant] [Î¼.is_neg_invariant] {f : G â†’ ğ•œ} {g : G â†’ F} : convolution f g (continuous_linear_map.lsmul ğ•œ ğ•œ) Î¼ x = âˆ« (t : G), f (x - t) â€¢ g t âˆ‚Î¼
theorem antivary_on.sum_mul_lt_sum_mul_comp_perm_iff {Î¹ : Type u_1} {Î± : Type u_2} [linear_ordered_ring Î±] {s : finset Î¹} {Ïƒ : equiv.perm Î¹} {f g : Î¹ â†’ Î±} (hfg : antivary_on f g â†‘s) (hÏƒ : {x : Î¹ | â‡‘Ïƒ x â‰  x} âŠ† â†‘s) : s.sum (Î» (i : Î¹), f i * g i) < s.sum (Î» (i : Î¹), f i * g (â‡‘Ïƒ i)) â†” Â¬antivary_on f (g âˆ˜ â‡‘Ïƒ) â†‘s
theorem matrix.det_from_blocks_zeroâ‚â‚‚ {m : Type u_1} {n : Type u_2} [decidable_eq n] [fintype n] [decidable_eq m] [fintype m] {R : Type v} [comm_ring R] (A : matrix m m R) (C : matrix n m R) (D : matrix n n R) : (matrix.from_blocks A 0 C D).det = A.det * D.det
theorem lt_tsub_iff_right_of_le {Î± : Type u_1} [canonically_ordered_add_monoid Î±] [has_sub Î±] [has_ordered_sub Î±] {a b c : Î±} [contravariant_class Î± Î± has_add.add has_le.le] (h : c â‰¤ b) : a < b - c â†” a + c < b
theorem two_mul_le_add_sq {R : Type u_4} [linear_ordered_comm_ring R] (a b : R) : 2 * a * b â‰¤ a ^ 2 + b ^ 2
theorem is_dedekind_domain_iff (A : Type u_2) [comm_ring A] [is_domain A] (K : Type u_1) [field K] [algebra A K] [is_fraction_ring A K] : is_dedekind_domain A â†” is_noetherian_ring A âˆ§ ring.dimension_le_one A âˆ§ âˆ€ {x : K}, is_integral A x â†’ (âˆƒ (y : A), â‡‘(algebra_map A K) y = x)
theorem nat.modeq.modeq_cancel_left_of_coprime {a b c m : â„•} (hmc : m.gcd c = 1) (h : c * a â‰¡ c * b [MOD m]) : a â‰¡ b [MOD m]
theorem category_theory.limits.cofork.is_colimit.hom_iso_natural {C : Type u} [category_theory.category C] {X Y : C} {f g : X âŸ¶ Y} {t : category_theory.limits.cofork f g} {Z Z' : C} (q : Z âŸ¶ Z') (ht : category_theory.limits.is_colimit t) (k : t.X âŸ¶ Z) : â†‘(â‡‘(category_theory.limits.cofork.is_colimit.hom_iso ht Z') (k â‰« q)) = â†‘(â‡‘(category_theory.limits.cofork.is_colimit.hom_iso ht Z) k) â‰« q
theorem mem_nhds_within_Iio_iff_exists_Ico_subset {Î± : Type u} [topological_space Î±] [linear_order Î±] [order_topology Î±] [no_min_order Î±] [densely_ordered Î±] {a : Î±} {s : set Î±} : s âˆˆ nhds_within a (set.Iio a) â†” âˆƒ (l : Î±) (H : l âˆˆ set.Iio a), set.Ico l a âŠ† s
theorem inner_product_space.is_self_adjoint.orthogonal_supr_eigenspaces {ğ•œ : Type u_1} [is_R_or_C ğ•œ] {E : Type u_2} [inner_product_space ğ•œ E] {T : E â†’â‚—[ğ•œ] E} (hT : inner_product_space.is_self_adjoint T) (Î¼ : ğ•œ) : module.End.eigenspace (T.restrict _) Î¼ = âŠ¥
theorem nhds_basis_Ioo_pos_of_pos {Î± : Type u} [topological_space Î±] [linear_ordered_add_comm_group Î±] [order_topology Î±] [no_min_order Î±] [no_max_order Î±] {a : Î±} (ha : 0 < a) : (nhds a).has_basis (Î» (Îµ : Î±), 0 < Îµ âˆ§ Îµ â‰¤ a) (Î» (Îµ : Î±), set.Ioo (a - Îµ) (a + Îµ))
theorem convex.set_average_mem_closure {Î± : Type u_1} {E : Type u_2} {m0 : measurable_space Î±} [normed_group E] [normed_space â„ E] [complete_space E] {Î¼ : measure_theory.measure Î±} {s : set E} {t : set Î±} {f : Î± â†’ E} (hs : convex â„ s) (h0 : â‡‘Î¼ t â‰  0) (ht : â‡‘Î¼ t â‰  âŠ¤) (hfs : âˆ€áµ (x : Î±) âˆ‚Î¼.restrict t, f x âˆˆ s) (hfi : measure_theory.integrable_on f t Î¼) : â¨ (x : Î±) in t, f x âˆ‚Î¼ âˆˆ closure s
theorem metric.to_inductive_limit_isometry {X : â„• â†’ Type u} [Î  (n : â„•), metric_space (X n)] {f : Î  (n : â„•), X n â†’ X (n + 1)} (I : âˆ€ (n : â„•), isometry (f n)) (n : â„•) : isometry (metric.to_inductive_limit I n)
theorem submodule.torsion_by_is_internal {R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] {Î¹ : Type u_3} [decidable_eq Î¹] {S : finset Î¹} {q : Î¹ â†’ R} (hq : â†‘S.pairwise (is_coprime on q)) (hM : module.is_torsion_by R M (S.prod (Î» (i : Î¹), q i))) : direct_sum.is_internal (Î» (i : â†¥S), submodule.torsion_by R M (q â†‘i))
theorem vector_span_def (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P) : vector_span k s = submodule.span k (s -áµ¥ s)
theorem dim_mul_dim' (F : Type u) (K : Type v) (A : Type w) [field F] [field K] [add_comm_group A] [algebra F K] [module K A] [module F A] [is_scalar_tower F K A] : (module.rank F K).lift * (module.rank K A).lift = (module.rank F A).lift
theorem class_group.exists_min {R : Type u_1} {S : Type u_2} [euclidean_domain R] [comm_ring S] [is_domain S] [algebra R S] (abv : absolute_value R â„¤) (I : â†¥(non_zero_divisors (ideal S))) : âˆƒ (b : S) (H : b âˆˆ â†‘I), b â‰  0 âˆ§ âˆ€ (c : S), c âˆˆ â†‘I â†’ â‡‘abv (â‡‘(algebra.norm R) c) < â‡‘abv (â‡‘(algebra.norm R) b) â†’ c = 0
theorem uv.compress_idem {Î± : Type u_1} [generalized_boolean_algebra Î±] [decidable_rel disjoint] [decidable_rel has_le.le] (u v a : Î±) : uv.compress u v (uv.compress u v a) = uv.compress u v a
theorem lattice_ordered_comm_group.mabs_mabs {Î± : Type u} [lattice Î±] [comm_group Î±] [covariant_class Î± Î± has_mul.mul has_le.le] (a : Î±) : ||a|| = |a|
theorem reflexive.ne_imp_iff {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} (h : reflexive r) {x y : Î±} : x â‰  y â†’ r x y â†” r x y
theorem lipschitz_on_with.of_le_add_mul {Î± : Type u} [pseudo_metric_space Î±] {s : set Î±} {f : Î± â†’ â„} (K : nnreal) (h : âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (y : Î±), y âˆˆ s â†’ f x â‰¤ f y + â†‘K * has_dist.dist x y) : lipschitz_on_with K f s
theorem orthogonal_projection_map_apply {ğ•œ : Type u_1} [is_R_or_C ğ•œ] {E : Type u_2} {E' : Type u_3} [inner_product_space ğ•œ E] [inner_product_space ğ•œ E'] (f : E â‰ƒâ‚—áµ¢[ğ•œ] E') (p : submodule ğ•œ E) [complete_space â†¥p] (x : E') : â†‘(â‡‘(orthogonal_projection (submodule.map â†‘(f.to_linear_equiv) p)) x) = â‡‘f â†‘(â‡‘(orthogonal_projection p) (â‡‘(f.symm) x))
theorem filter.tendsto_iff_ultrafilter {Î± : Type u} {Î² : Type v} (f : Î± â†’ Î²) (lâ‚ : filter Î±) (lâ‚‚ : filter Î²) : filter.tendsto f lâ‚ lâ‚‚ â†” âˆ€ (g : ultrafilter Î±), â†‘g â‰¤ lâ‚ â†’ filter.tendsto f â†‘g lâ‚‚
theorem complex.circle_integral_eq_of_differentiable_on_annulus_off_countable {E : Type u} [normed_group E] [normed_space â„‚ E] [complete_space E] {c : â„‚} {r R : â„} (h0 : 0 < r) (hle : r â‰¤ R) {f : â„‚ â†’ E} {s : set â„‚} (hs : s.countable) (hc : continuous_on f (metric.closed_ball c R  metric.ball c r)) (hd : âˆ€ (z : â„‚), z âˆˆ metric.ball c R  metric.closed_ball c r  s â†’ differentiable_at â„‚ f z) : âˆ® (z : â„‚) in C(c, R), f z = âˆ® (z : â„‚) in C(c, r), f z
theorem is_fraction_ring.lift_mk' {A : Type u_4} [comm_ring A] [is_domain A] {K : Type u_5} [field K] {L : Type u_7} [field L] [algebra A K] [is_fraction_ring A K] {g : A â†’+* L} (hg : function.injective â‡‘g) (x : A) (y : â†¥(non_zero_divisors A)) : â‡‘(is_fraction_ring.lift hg) (is_localization.mk' K x y) = â‡‘g x / â‡‘g â†‘y
theorem tendsto_at_top_of_geom_le {v : â„• â†’ â„} {c : â„} (hâ‚€ : 0 < v 0) (hc : 1 < c) (hu : âˆ€ (n : â„•), c * v n â‰¤ v (n + 1)) : filter.tendsto v filter.at_top filter.at_top
theorem is_primitive_root.pow_sub_one_norm_prime_pow_of_one_le {p : â„•+} {K : Type u} {L : Type v} [field L] {Î¶ : L} [field K] [algebra K L] [hne : ne_zero â†‘â†‘p] {k s : â„•} (hÎ¶ : is_primitive_root Î¶ â†‘(p ^ (k + 1))) [hpri : fact (nat.prime â†‘p)] [hcycl : is_cyclotomic_extension {p ^ (k + 1)} K L] (hirr : irreducible (polynomial.cyclotomic â†‘(p ^ (k + 1)) K)) (hs : s â‰¤ k) (hk : 1 â‰¤ k) : â‡‘(algebra.norm K) (Î¶ ^ â†‘p ^ s - 1) = â†‘p ^ â†‘p ^ s
theorem vsub_mem_vector_span_of_mem_span_points_of_mem_span_points (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : set P} {p1 p2 : P} (hp1 : p1 âˆˆ span_points k s) (hp2 : p2 âˆˆ span_points k s) : p1 -áµ¥ p2 âˆˆ vector_span k s
theorem upper_central_series_is_ascending_central_series (G : Type u_1) [group G] : is_ascending_central_series (upper_central_series G)
theorem nilpotency_class_eq_quotient_center_plus_one {G : Type u_1} [group G] [hH : group.is_nilpotent G] [nontrivial G] : group.nilpotency_class G = group.nilpotency_class (G â§¸ subgroup.center G) + 1
theorem nnreal.young_inequality_real (a b : nnreal) {p q : â„} (hpq : p.is_conjugate_exponent q) : a * b â‰¤ a ^ p / p.to_nnreal + b ^ q / q.to_nnreal
theorem measure_theory.signed_measure.of_diff_eq_zero_of_symm_diff_eq_zero_positive {Î± : Type u_1} [measurable_space Î±] {s : measure_theory.signed_measure Î±} {u v : set Î±} (hu : measurable_set u) (hv : measurable_set v) (hsu : 0.restrict u â‰¤ measure_theory.vector_measure.restrict s u) (hsv : 0.restrict v â‰¤ measure_theory.vector_measure.restrict s v) (hs : â‡‘s (u âˆ† v) = 0) : â‡‘s (u  v) = 0 âˆ§ â‡‘s (v  u) = 0
theorem nat.prime.mod_two_eq_one_iff_ne_two {p : â„•} [fact (nat.prime p)] : p % 2 = 1 â†” p â‰  2
theorem absolute_value.is_admissible.exists_approx_aux {R : Type u_1} [euclidean_domain R] {abv : absolute_value R â„¤} (n : â„•) (h : abv.is_admissible) {Îµ : â„} (hÎµ : 0 < Îµ) {b : R} (hb : b â‰  0) (A : fin (h.card Îµ ^ n).succ â†’ fin n â†’ R) : âˆƒ (iâ‚€ iâ‚ : fin (h.card Îµ ^ n).succ), iâ‚€ â‰  iâ‚ âˆ§ âˆ€ (k : fin n), â†‘(â‡‘abv (A iâ‚ k % b - A iâ‚€ k % b)) < â‡‘abv b â€¢ Îµ
theorem coe_fourier_series  : â‡‘fourier_series = fourier_Lp 2
theorem list.map_comp_map {Î± : Type u} {Î² : Type v} {Î³ : Type w} (g : Î² â†’ Î³) (f : Î± â†’ Î²) : list.map g âˆ˜ list.map f = list.map (g âˆ˜ f)
theorem class_group.norm_le {R : Type u_1} {S : Type u_2} [euclidean_domain R] [comm_ring S] [is_domain S] [algebra R S] (abv : absolute_value R â„¤) {Î¹ : Type u_5} [decidable_eq Î¹] [fintype Î¹] (bS : basis Î¹ R S) (a : S) {y : â„¤} (hy : âˆ€ (k : Î¹), â‡‘abv (â‡‘(â‡‘(bS.repr) a) k) â‰¤ y) : â‡‘abv (â‡‘(algebra.norm R) a) â‰¤ class_group.norm_bound abv bS * y ^ fintype.card Î¹
theorem not_is_right_regular_zero_iff {R : Type u_1} [mul_zero_class R] : Â¬is_right_regular 0 â†” nontrivial R
theorem int.gcd_eq_gcd_ab (x y : â„¤) : â†‘(x.gcd y) = x * x.gcd_a y + y * x.gcd_b y
theorem has_strict_fderiv_at_exp {ğ•‚ : Type u_1} {ğ”¸ : Type u_2} [is_R_or_C ğ•‚] [normed_comm_ring ğ”¸] [normed_algebra ğ•‚ ğ”¸] [complete_space ğ”¸] {x : ğ”¸} : has_strict_fderiv_at (exp ğ•‚) (exp ğ•‚ x â€¢ 1) x
theorem affine_basis.to_matrix_vec_mul_coords {Î¹ : Type uâ‚} {k : Type uâ‚‚} {V : Type uâ‚ƒ} {P : Type uâ‚„} [add_comm_group V] [add_torsor V P] [ring k] [module k V] (b : affine_basis Î¹ k P) [fintype Î¹] (bâ‚‚ : affine_basis Î¹ k P) (x : P) : matrix.vec_mul (â‡‘(bâ‚‚.coords) x) (b.to_matrix bâ‚‚.points) = â‡‘(b.coords) x
theorem is_R_or_C.I_re {K : Type u_1} [is_R_or_C K] : â‡‘is_R_or_C.re is_R_or_C.I = 0
theorem affine.simplex.ext_iff {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {n : â„•} (s1 s2 : affine.simplex k P n) : s1 = s2 â†” âˆ€ (i : fin (n + 1)), s1.points i = s2.points i
theorem category_theory.limits.biprod.add_eq_lift_desc_id {C : Type u} [category_theory.category C] [category_theory.preadditive C] {X Y : C} (f g : X âŸ¶ Y) [category_theory.limits.has_binary_biproduct Y Y] : f + g = category_theory.limits.biprod.lift f g â‰« category_theory.limits.biprod.desc (ğŸ™ Y) (ğŸ™ Y)
theorem monotone.tendsto_nhds_within_Ioi {Î² : Type v} [conditionally_complete_linear_order Î²] [topological_space Î²] [order_topology Î²] {Î± : Type u_1} [linear_order Î±] [topological_space Î±] [order_topology Î±] {f : Î± â†’ Î²} (Mf : monotone f) (x : Î±) : filter.tendsto f (nhds_within x (set.Ioi x)) (nhds (has_Inf.Inf (f '' set.Ioi x)))
theorem complex.norm_deriv_le_div_of_maps_to_ball {E : Type u_1} [normed_group E] [normed_space â„‚ E] {Râ‚ Râ‚‚ : â„} {f : â„‚ â†’ E} {c : â„‚} (hd : differentiable_on â„‚ f (metric.ball c Râ‚)) (h_maps : set.maps_to f (metric.ball c Râ‚) (metric.ball (f c) Râ‚‚)) (hâ‚€ : 0 < Râ‚) : âˆ¥deriv f câˆ¥ â‰¤ Râ‚‚ / Râ‚
theorem metric.inf_dist_le_dist_of_mem {Î± : Type u} [pseudo_metric_space Î±] {s : set Î±} {x y : Î±} (h : y âˆˆ s) : metric.inf_dist x s â‰¤ has_dist.dist x y
theorem measure_theory.analytic_set.image_of_continuous_on {Î± : Type u_1} [topological_space Î±] {Î² : Type u_2} [topological_space Î²] {s : set Î±} (hs : measure_theory.analytic_set s) {f : Î± â†’ Î²} (hf : continuous_on f s) : measure_theory.analytic_set (f '' s)
theorem add_con.add_con_gen_of_add_con {M : Type u_1} [has_add M] (c : add_con M) : add_con_gen â‡‘c = c
theorem star_convex.preimage_add_right {ğ•œ : Type u_1} {E : Type u_2} [ordered_semiring ğ•œ] [add_comm_monoid E] [module ğ•œ E] {x z : E} {s : set E} (hs : star_convex ğ•œ (z + x) s) : star_convex ğ•œ x ((Î» (x : E), z + x) â»Â¹' s)
theorem finset.eq_empty_of_is_empty {Î± : Type u_1} [is_empty Î±] (s : finset Î±) : s = âˆ…
theorem measure_theory.probability_measure.tendsto_iff_forall_lintegral_tendsto {Î± : Type u_1} [measurable_space Î±] [topological_space Î±] [opens_measurable_space Î±] {Î³ : Type u_2} {F : filter Î³} {Î¼s : Î³ â†’ measure_theory.probability_measure Î±} {Î¼ : measure_theory.probability_measure Î±} : filter.tendsto Î¼s F (nhds Î¼) â†” âˆ€ (f : bounded_continuous_function Î± nnreal), filter.tendsto (Î» (i : Î³), âˆ«â» (x : Î±), â†‘(â‡‘f x) âˆ‚â†‘(Î¼s i)) F (nhds (âˆ«â» (x : Î±), â†‘(â‡‘f x) âˆ‚â†‘Î¼))
theorem reflection_orthogonal_complement_singleton_eq_neg {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] [complete_space E] (v : E) : â‡‘(reflection (submodule.span ğ•œ {v})á—®) v = -v
theorem measure_theory.L2.inner_indicator_const_Lp_eq_inner_set_integral {Î± : Type u_1} {E : Type u_2} (ğ•œ : Type u_4) [is_R_or_C ğ•œ] [measurable_space Î±] {Î¼ : measure_theory.measure Î±} [inner_product_space ğ•œ E] {s : set Î±} [complete_space E] [normed_space â„ E] (hs : measurable_set s) (hÎ¼s : â‡‘Î¼ s â‰  âŠ¤) (c : E) (f : â†¥(measure_theory.Lp E 2 Î¼)) : has_inner.inner (measure_theory.indicator_const_Lp 2 hs hÎ¼s c) f = has_inner.inner c (âˆ« (x : Î±) in s, â‡‘f x âˆ‚Î¼)
theorem finset.image_imageâ‚‚_right_anticomm {Î± : Type u_1} {Î² : Type u_3} {Î²' : Type u_4} {Î³ : Type u_5} {Î´ : Type u_7} [decidable_eq Î²'] [decidable_eq Î³] [decidable_eq Î´] {s : finset Î±} {t : finset Î²} {f : Î± â†’ Î²' â†’ Î³} {g : Î² â†’ Î²'} {f' : Î² â†’ Î± â†’ Î´} {g' : Î´ â†’ Î³} (h_right_anticomm : âˆ€ (a : Î±) (b : Î²), f a (g b) = g' (f' b a)) : finset.imageâ‚‚ f s (finset.image g t) = finset.image g' (finset.imageâ‚‚ f' t s)
theorem finset.prod_le_prod'' {Î¹ : Type u_1} {N : Type u_5} [ordered_comm_monoid N] {f g : Î¹ â†’ N} {s : finset Î¹} (h : âˆ€ (i : Î¹), i âˆˆ s â†’ f i â‰¤ g i) : s.prod (Î» (i : Î¹), f i) â‰¤ s.prod (Î» (i : Î¹), g i)
theorem measure_theory.map_prod_sum_eq {G : Type u_1} [measurable_space G] [add_group G] [has_measurable_addâ‚‚ G] (Î¼ Î½ : measure_theory.measure G) [measure_theory.sigma_finite Î½] [measure_theory.sigma_finite Î¼] [Î½.is_add_left_invariant] : measure_theory.measure.map (Î» (z : G Ã— G), (z.fst, z.fst + z.snd)) (Î¼.prod Î½) = Î¼.prod Î½
theorem set.zero_smul_set {Î± : Type u_2} {Î² : Type u_3} [has_zero Î±] [has_zero Î²] [smul_with_zero Î± Î²] {s : set Î²} (h : s.nonempty) : 0 â€¢ s = 0
theorem measure_theory.conservative.ae_frequently_mem_of_mem_nhds {Î± : Type u_2} [measurable_space Î±] [topological_space Î±] [topological_space.second_countable_topology Î±] [opens_measurable_space Î±] {f : Î± â†’ Î±} {Î¼ : measure_theory.measure Î±} (h : measure_theory.conservative f Î¼) : âˆ€áµ (x : Î±) âˆ‚Î¼, âˆ€ (s : set Î±), s âˆˆ nhds x â†’ (âˆƒá¶  (n : â„•) in filter.at_top, f^[n] x âˆˆ s)
theorem nonarchimedean_ring.mul_subset {R : Type u_1} [ring R] [topological_space R] [nonarchimedean_ring R] (U : open_add_subgroup R) : âˆƒ (V : open_add_subgroup R), â†‘V * â†‘V âŠ† â†‘U
theorem filter.tendsto.at_top_mul_neg {Î± : Type u} {Î² : Type v} [linear_ordered_field Î±] [topological_space Î±] [order_topology Î±] {l : filter Î²} {f g : Î² â†’ Î±} {C : Î±} (hC : C < 0) (hf : filter.tendsto f l filter.at_top) (hg : filter.tendsto g l (nhds C)) : filter.tendsto (Î» (x : Î²), f x * g x) l filter.at_bot
theorem is_bot.to_dual {Î± : Type u_1} [has_le Î±] {a : Î±} : is_bot a â†’ is_top (â‡‘order_dual.to_dual a)
theorem weak_bilin.embedding {ğ•œ : Type u_2} {E : Type u_5} {F : Type u_6} [topological_space ğ•œ] [comm_semiring ğ•œ] [add_comm_monoid E] [module ğ•œ E] [add_comm_monoid F] [module ğ•œ F] {B : E â†’â‚—[ğ•œ] F â†’â‚—[ğ•œ] ğ•œ} (hB : function.injective â‡‘B) : embedding (Î» (x : weak_bilin B) (y : F), â‡‘(â‡‘B x) y)
theorem nat.infinite_set_of_prime  : {p : â„• | nat.prime p}.infinite
theorem measure_theory.L1.simple_func.set_to_L1s_congr_measure {Î± : Type u_1} {E : Type u_2} {F : Type u_3} [normed_group E] [normed_space â„ E] [normed_group F] [normed_space â„ F] {m : measurable_space Î±} {Î¼ Î¼' : measure_theory.measure Î±} (T : set Î± â†’ (E â†’L[â„] F)) (h_zero : âˆ€ (s : set Î±), measurable_set s â†’ â‡‘Î¼ s = 0 â†’ T s = 0) (h_add : measure_theory.fin_meas_additive Î¼ T) (hÎ¼ : Î¼.absolutely_continuous Î¼') (f : â†¥(measure_theory.Lp.simple_func E 1 Î¼)) (f' : â†¥(measure_theory.Lp.simple_func E 1 Î¼')) (h : â‡‘f =áµ[Î¼] â‡‘f') : measure_theory.L1.simple_func.set_to_L1s T f = measure_theory.L1.simple_func.set_to_L1s T f'
theorem function.embedding.total (Î± : Type u) (Î² : Type v) : nonempty (Î± â†ª Î²) âˆ¨ nonempty (Î² â†ª Î±)
theorem simplex_category.Î´_comp_Î´ {n : â„•} {i j : fin (n + 2)} (H : i â‰¤ j) : simplex_category.Î´ i â‰« simplex_category.Î´ j.succ = simplex_category.Î´ j â‰« simplex_category.Î´ (â‡‘fin.cast_succ i)
theorem witt_vector.frobenius_fun_is_poly (p : â„•) [hp : fact (nat.prime p)] : witt_vector.is_poly p (Î» (R : Type u_1) (_Rcr : comm_ring R), witt_vector.frobenius_fun)
theorem add_equiv.map_add {M : Type u_6} {N : Type u_7} [has_add M] [has_add N] (f : M â‰ƒ+ N) (x y : M) : â‡‘f (x + y) = â‡‘f x + â‡‘f y
theorem precise_refinement_set {Î¹ : Type u} {X : Type v} [topological_space X] [paracompact_space X] {s : set X} (hs : is_closed s) (u : Î¹ â†’ set X) (uo : âˆ€ (i : Î¹), is_open (u i)) (us : s âŠ† â‹ƒ (i : Î¹), u i) : âˆƒ (v : Î¹ â†’ set X), (âˆ€ (i : Î¹), is_open (v i)) âˆ§ (s âŠ† â‹ƒ (i : Î¹), v i) âˆ§ locally_finite v âˆ§ âˆ€ (i : Î¹), v i âŠ† u i
theorem homological_complex.d_comp_eq_to_hom {Î¹ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {c : complex_shape Î¹} (C : homological_complex V c) {i j j' : Î¹} (rij : c.rel i j) (rij' : c.rel i j') : C.d i j' â‰« category_theory.eq_to_hom _ = C.d i j
theorem measure_theory.meas_ge_le_lintegral_div {Î± : Type u_1} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {f : Î± â†’ ennreal} (hf : ae_measurable f Î¼) {Îµ : ennreal} (hÎµ : Îµ â‰  0) (hÎµ' : Îµ â‰  âŠ¤) : â‡‘Î¼ {x : Î± | Îµ â‰¤ f x} â‰¤ âˆ«â» (a : Î±), f a âˆ‚Î¼ / Îµ
theorem is_lub.bdd_above {Î± : Type u} [preorder Î±] {s : set Î±} {a : Î±} (h : is_lub s a) : bdd_above s
theorem function.injective2.left' {Î± : Sort u_1} {Î² : Sort u_2} {Î³ : Sort u_3} {f : Î± â†’ Î² â†’ Î³} (hf : function.injective2 f) [nonempty Î²] : function.injective f
theorem module.torsion_by_prime_power_decomposition {R : Type u} [comm_ring R] [is_domain R] [is_principal_ideal_ring R] {N : Type (max u v)} [add_comm_group N] [module R N] {p : R} (hp : irreducible p) (hN : module.is_torsion' N â†¥(submonoid.powers p)) [h' : module.finite R N] : âˆƒ (d : â„•) (k : fin d â†’ â„•), nonempty (N â‰ƒâ‚—[R] direct_sum (fin d) (Î» (i : fin d), R â§¸ submodule.span R {p ^ k i}))
theorem box_integral.has_integral_bot_pderiv {E : Type u} [normed_group E] [normed_space â„ E] {n : â„•} [complete_space E] (I : box_integral.box (fin (n + 1))) (f : (fin (n + 1) â†’ â„) â†’ E) (f' : (fin (n + 1) â†’ â„) â†’ ((fin (n + 1) â†’ â„) â†’L[â„] E)) (s : set (fin (n + 1) â†’ â„)) (hs : s.countable) (Hs : âˆ€ (x : fin (n + 1) â†’ â„), x âˆˆ s â†’ continuous_within_at f (â‡‘box_integral.box.Icc I) x) (Hd : âˆ€ (x : fin (n + 1) â†’ â„), x âˆˆ â‡‘box_integral.box.Icc I  s â†’ has_fderiv_within_at f (f' x) (â‡‘box_integral.box.Icc I) x) (i : fin (n + 1)) : box_integral.has_integral I âŠ¥ (Î» (x : fin (n + 1) â†’ â„), â‡‘(f' x) (pi.single i 1)) box_integral.box_additive_map.volume (box_integral.integral (I.face i) âŠ¥ (Î» (x : fin n â†’ â„), f (i.insert_nth (I.upper i) x)) box_integral.box_additive_map.volume - box_integral.integral (I.face i) âŠ¥ (Î» (x : fin n â†’ â„), f (i.insert_nth (I.lower i) x)) box_integral.box_additive_map.volume)
theorem ennreal.lintegral_Lp_add_le {Î± : Type u_1} [measurable_space Î±] {Î¼ : measure_theory.measure Î±} {p : â„} {f g : Î± â†’ ennreal} (hf : ae_measurable f Î¼) (hg : ae_measurable g Î¼) (hp1 : 1 â‰¤ p) : (âˆ«â» (a : Î±), (f + g) a ^ p âˆ‚Î¼) ^ (1 / p) â‰¤ (âˆ«â» (a : Î±), f a ^ p âˆ‚Î¼) ^ (1 / p) + (âˆ«â» (a : Î±), g a ^ p âˆ‚Î¼) ^ (1 / p)
theorem is_cyclotomic_extension.integral (S : set â„•+) (A : Type u) (B : Type v) [comm_ring A] [comm_ring B] [algebra A B] [is_domain B] [is_noetherian_ring A] [fintype â†¥S] [is_cyclotomic_extension S A B] : algebra.is_integral A B
theorem solvable_by_rad.induction2 {F : Type u_1} [field F] {E : Type u_2} [field E] [algebra F E] {Î± Î² Î³ : â†¥(solvable_by_rad F E)} (hÎ³ : Î³ âˆˆ FâŸ®Î±, Î²âŸ¯) (hÎ± : solvable_by_rad.P Î±) (hÎ² : solvable_by_rad.P Î²) : solvable_by_rad.P Î³
theorem turing.to_partrec.step_ret_then {k k' : turing.to_partrec.cont} {v : list â„•} : turing.to_partrec.step_ret (k.then k') v = (turing.to_partrec.step_ret k v).then k'
theorem is_compact_interval {Î± : Type u_1} [linear_order Î±] [topological_space Î±] [compact_Icc_space Î±] {a b : Î±} : is_compact (set.interval a b)
theorem finset.sum_centroid_weights_indicator (k : Type u_1) [division_ring k] {Î¹ : Type u_4} (s : finset Î¹) [fintype Î¹] : finset.univ.sum (Î» (i : Î¹), finset.centroid_weights_indicator k s i) = s.sum (Î» (i : Î¹), finset.centroid_weights k s i)
theorem convolution_lmul {ğ•œ : Type u_1} {G : Type u_2} {x : G} [nondiscrete_normed_field ğ•œ] [measurable_space G] {Î¼ : measure_theory.measure G} [has_sub G] [normed_space â„ ğ•œ] [complete_space ğ•œ] {f g : G â†’ ğ•œ} : convolution f g (continuous_linear_map.lmul ğ•œ ğ•œ) Î¼ x = âˆ« (t : G), f t * g (x - t) âˆ‚Î¼
theorem nat.perm_factors_mul_of_coprime {a b : â„•} (hab : a.coprime b) : (a * b).factors ~ a.factors ++ b.factors
theorem con.le_def {M : Type u_1} [has_mul M] {c d : con M} : c â‰¤ d â†” âˆ€ {x y : M}, â‡‘c x y â†’ â‡‘d x y
theorem mem_nhds_within_Iio_iff_exists_Ioo_subset {Î± : Type u} [topological_space Î±] [linear_order Î±] [order_topology Î±] [no_min_order Î±] {a : Î±} {s : set Î±} : s âˆˆ nhds_within a (set.Iio a) â†” âˆƒ (l : Î±) (H : l âˆˆ set.Iio a), set.Ioo l a âŠ† s
theorem cont_diff_within_at.smul {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {x : E} {n : with_top â„•} {s : set E} {f : E â†’ ğ•œ} {g : E â†’ F} (hf : cont_diff_within_at ğ•œ n f s x) (hg : cont_diff_within_at ğ•œ n g s x) : cont_diff_within_at ğ•œ n (Î» (x : E), f x â€¢ g x) s x
theorem tsirelson_inequality {R : Type u} [ordered_ring R] [star_ordered_ring R] [algebra â„ R] [ordered_smul â„ R] [star_module â„ R] (Aâ‚€ Aâ‚ Bâ‚€ Bâ‚ : R) (T : is_CHSH_tuple Aâ‚€ Aâ‚ Bâ‚€ Bâ‚) : Aâ‚€ * Bâ‚€ + Aâ‚€ * Bâ‚ + Aâ‚ * Bâ‚€ - Aâ‚ * Bâ‚ â‰¤ real.sqrt 2 ^ 3 â€¢ 1
theorem apply_dite {Î± : Sort u_1} {Î² : Sort u_2} (f : Î± â†’ Î²) (P : Prop) [decidable P] (x : P â†’ Î±) (y : Â¬P â†’ Î±) : f (dite P x y) = dite P (Î» (h : P), f (x h)) (Î» (h : Â¬P), f (y h))
theorem tendsto_locally_uniformly.tendsto_comp {Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_4} [uniform_space Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {x : Î±} {p : filter Î¹} {g : Î¹ â†’ Î±} [topological_space Î±] (h : tendsto_locally_uniformly F f p) (hf : continuous_at f x) (hg : filter.tendsto g p (nhds x)) : filter.tendsto (Î» (n : Î¹), F n (g n)) p (nhds (f x))
theorem besicovitch.exist_disjoint_covering_families {Î± : Type u_1} [metric_space Î±] {Î² : Type u} {N : â„•} {Ï„ : â„} (hÏ„ : 1 < Ï„) (hN : is_empty (besicovitch.satellite_config Î± N Ï„)) (q : besicovitch.ball_package Î² Î±) : âˆƒ (s : fin N â†’ set Î²), (âˆ€ (i : fin N), (s i).pairwise_disjoint (Î» (j : Î²), metric.closed_ball (q.c j) (q.r j))) âˆ§ set.range q.c âŠ† â‹ƒ (i : fin N) (j : Î²) (H : j âˆˆ s i), metric.ball (q.c j) (q.r j)
theorem finsum_mem_singleton {Î± : Type u_1} {M : Type u_5} [add_comm_monoid M] {f : Î± â†’ M} {a : Î±} : finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ {a}), f i)) = f a
theorem set.prod_mul_indicator_subset_of_eq_one {Î± : Type u_1} {M : Type u_4} {N : Type u_5} [comm_monoid M] [has_one N] (f : Î± â†’ N) (g : Î± â†’ N â†’ M) {s t : finset Î±} (h : s âŠ† t) (hg : âˆ€ (a : Î±), g a 1 = 1) : s.prod (Î» (i : Î±), g i (f i)) = t.prod (Î» (i : Î±), g i (â†‘s.mul_indicator f i))
theorem is_primitive_root.pow_is_root_minpoly {n : â„•} {K : Type u_8} [field K] {Î¼ : K} (h : is_primitive_root Î¼ n) [char_zero K] {m : â„•} (hcop : m.coprime n) : (polynomial.map (int.cast_ring_hom K) (minpoly â„¤ Î¼)).is_root (Î¼ ^ m)
theorem category_theory.limits.equalizer.hom_ext {C : Type u} [category_theory.category C] {X Y : C} {f g : X âŸ¶ Y} [category_theory.limits.has_equalizer f g] {W : C} {k l : W âŸ¶ category_theory.limits.equalizer f g} (h : k â‰« category_theory.limits.equalizer.Î¹ f g = l â‰« category_theory.limits.equalizer.Î¹ f g) : k = l
theorem add_subgroup.norm_coe {E : Type u_1} [semi_normed_group E] {s : add_subgroup E} (x : â†¥s) : âˆ¥â†‘xâˆ¥ = âˆ¥xâˆ¥
theorem nnreal.rpow_arith_mean_le_arith_mean_rpow {Î¹ : Type u} (s : finset Î¹) (w z : Î¹ â†’ nnreal) (hw' : s.sum (Î» (i : Î¹), w i) = 1) {p : â„} (hp : 1 â‰¤ p) : s.sum (Î» (i : Î¹), w i * z i) ^ p â‰¤ s.sum (Î» (i : Î¹), w i * z i ^ p)
theorem tendsto_measure_cthickening_of_is_closed {Î± : Type u_1} [pseudo_metric_space Î±] [measurable_space Î±] [opens_measurable_space Î±] {Î¼ : measure_theory.measure Î±} {s : set Î±} (hs : âˆƒ (R : â„) (H : R > 0), â‡‘Î¼ (metric.cthickening R s) â‰  âŠ¤) (h's : is_closed s) : filter.tendsto (Î» (r : â„), â‡‘Î¼ (metric.cthickening r s)) (nhds 0) (nhds (â‡‘Î¼ s))
theorem local_homeomorph.is_image.of_symm_preimage_eq' {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] {e : local_homeomorph Î± Î²} {s : set Î±} {t : set Î²} : e.to_local_equiv.target âˆ© â‡‘(e.symm) â»Â¹' (e.to_local_equiv.source âˆ© s) = e.to_local_equiv.target âˆ© t â†’ e.is_image s t
theorem totally_bounded.image {Î± : Type u} {Î² : Type v} [uniform_space Î±] [uniform_space Î²] {f : Î± â†’ Î²} {s : set Î±} (hs : totally_bounded s) (hf : uniform_continuous f) : totally_bounded (f '' s)
theorem ordinal.principal_add_iff_zero_or_omega_opow {o : ordinal} : ordinal.principal has_add.add o â†” o = 0 âˆ¨ âˆƒ (a : ordinal), o = ordinal.omega ^ a
theorem galois_connection.le_u_l_trans {Î± : Type u} {Î² : Type v} [preorder Î±] [preorder Î²] {l : Î± â†’ Î²} {u : Î² â†’ Î±} (gc : galois_connection l u) {x y z : Î±} (hxy : x â‰¤ u (l y)) (hyz : y â‰¤ u (l z)) : x â‰¤ u (l z)
theorem is_primitive_root.aut_to_pow_injective {n : â„•+} (K : Type u_1) [field K] {L : Type u_2} [field L] {Î¼ : L} (hÎ¼ : is_primitive_root Î¼ â†‘n) [algebra K L] [is_cyclotomic_extension {n} K L] : function.injective â‡‘(is_primitive_root.aut_to_pow K hÎ¼)
theorem subgroup.le_normalizer_map {G : Type u_1} [group G] {H : subgroup G} {N : Type u_3} [group N] (f : G â†’* N) : subgroup.map f H.normalizer â‰¤ (subgroup.map f H).normalizer
theorem inv_lt_of_inv_lt' {Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] [covariant_class Î± Î± (function.swap has_mul.mul) has_lt.lt] {a b : Î±} : aâ»Â¹ < b â†’ bâ»Â¹ < a
theorem category_theory.limits.has_biproduct_of_total {C : Type u} [category_theory.category C] [category_theory.preadditive C] {J : Type v} [fintype J] {f : J â†’ C} (b : category_theory.limits.bicone f) (total : finset.univ.sum (Î» (j : J), b.Ï€ j â‰« b.Î¹ j) = ğŸ™ b.X) : category_theory.limits.has_biproduct f
theorem topological_space.is_topological_basis_of_subbasis {Î± : Type u} [t : topological_space Î±] {s : set (set Î±)} (hs : t = topological_space.generate_from s) : topological_space.is_topological_basis ((Î» (f : set (set Î±)), â‹‚â‚€ f) '' {f : set (set Î±) | f.finite âˆ§ f âŠ† s âˆ§ (â‹‚â‚€ f).nonempty})
theorem cardinal.mk_univ_quaternion_algebra {R : Type u_1} (câ‚ câ‚‚ : R) : cardinal.mk â†¥set.univ = cardinal.mk R ^ 4
theorem fin.succ_above_lt_gt {n : â„•} (p : fin (n + 1)) (i : fin n) : â‡‘fin.cast_succ i < p âˆ¨ p < i.succ
theorem dist_le_of_approx_trajectories_ODE {E : Type u_1} [normed_group E] [normed_space â„ E] {v : â„ â†’ E â†’ E} {K : nnreal} (hv : âˆ€ (t : â„), lipschitz_with K (v t)) {f g f' g' : â„ â†’ E} {a b Îµf Îµg Î´ : â„} (hf : continuous_on f (set.Icc a b)) (hf' : âˆ€ (t : â„), t âˆˆ set.Ico a b â†’ has_deriv_within_at f (f' t) (set.Ici t) t) (f_bound : âˆ€ (t : â„), t âˆˆ set.Ico a b â†’ has_dist.dist (f' t) (v t (f t)) â‰¤ Îµf) (hg : continuous_on g (set.Icc a b)) (hg' : âˆ€ (t : â„), t âˆˆ set.Ico a b â†’ has_deriv_within_at g (g' t) (set.Ici t) t) (g_bound : âˆ€ (t : â„), t âˆˆ set.Ico a b â†’ has_dist.dist (g' t) (v t (g t)) â‰¤ Îµg) (ha : has_dist.dist (f a) (g a) â‰¤ Î´) (t : â„) (H : t âˆˆ set.Icc a b) : has_dist.dist (f t) (g t) â‰¤ gronwall_bound Î´ â†‘K (Îµf + Îµg) (t - a)
theorem has_strict_fderiv_at.exists_lipschitz_on_with {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {f : E â†’ F} {f' : E â†’L[ğ•œ] F} {x : E} (hf : has_strict_fderiv_at f f' x) : âˆƒ (K : nnreal) (s : set E) (H : s âˆˆ nhds x), lipschitz_on_with K f s
theorem generate_from_prod_eq {Î± : Type u_1} {Î² : Type u_2} {C : set (set Î±)} {D : set (set Î²)} (hC : is_countably_spanning C) (hD : is_countably_spanning D) : prod.measurable_space = measurable_space.generate_from (set.image2 has_set_prod.prod C D)
theorem uv.compression_idem {Î± : Type u_1} [generalized_boolean_algebra Î±] [decidable_rel disjoint] [decidable_rel has_le.le] (u v : Î±) (s : finset Î±) : uv.compression u v (uv.compression u v s) = uv.compression u v s
theorem local_homeomorph.is_image.of_symm_preimage_eq {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] {e : local_homeomorph Î± Î²} {s : set Î±} {t : set Î²} : e.to_local_equiv.target âˆ© â‡‘(e.symm) â»Â¹' s = e.to_local_equiv.target âˆ© t â†’ e.is_image s t
theorem nat.modeq_iff_dvd' {n a b : â„•} (h : a â‰¤ b) : a â‰¡ b [MOD n] â†” n âˆ£ b - a
theorem generalized_continued_fraction.int_fract_pair.nth_stream_fr_lt_one {K : Type u_1} {v : K} {n : â„•} [linear_ordered_field K] [floor_ring K] {ifp_n : generalized_continued_fraction.int_fract_pair K} (nth_stream_eq : generalized_continued_fraction.int_fract_pair.stream v n = option.some ifp_n) : ifp_n.fr < 1
theorem minpoly.aeval_of_is_scalar_tower (R : Type u_1) {K : Type u_2} {T : Type u_3} {U : Type u_4} [comm_ring R] [field K] [comm_ring T] [algebra R K] [algebra K T] [algebra R T] [is_scalar_tower R K T] [comm_semiring U] [algebra K U] [algebra R U] [is_scalar_tower R K U] (x : T) (y : U) (hy : â‡‘(polynomial.aeval y) (minpoly K x) = 0) : â‡‘(polynomial.aeval y) (minpoly R x) = 0
theorem mvpfunctor.W_ind {n : â„•} (P : mvpfunctor (n + 1)) {Î± : typevec n} {C : P.W Î± â†’ Prop} (ih : âˆ€ (a : P.A) (f' : (P.drop.B a).arrow Î±) (f : P.last.B a â†’ P.W Î±), (âˆ€ (i : P.last.B a), C (f i)) â†’ C (P.W_mk a f' f)) (x : P.W Î±) : C x
theorem dfinsupp.lhom_ext {Î¹ : Type u_1} {R : Type u_2} {M : Î¹ â†’ Type u_4} {N : Type u_5} [dec_Î¹ : decidable_eq Î¹] [semiring R] [Î  (i : Î¹), add_comm_monoid (M i)] [Î  (i : Î¹), module R (M i)] [add_comm_monoid N] [module R N] â¦ƒÏ† Ïˆ : (Î â‚€ (i : Î¹), M i) â†’â‚—[R] Nâ¦„ (h : âˆ€ (i : Î¹) (x : M i), â‡‘Ï† (dfinsupp.single i x) = â‡‘Ïˆ (dfinsupp.single i x)) : Ï† = Ïˆ
theorem ideal.fg.map {R : Type u_1} {S : Type u_2} [semiring R] [semiring S] {I : ideal R} (h : I.fg) (f : R â†’+* S) : (ideal.map f I).fg
theorem finset.weighted_vsub_eq_weighted_vsub_of_point_of_sum_eq_zero {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {Î¹ : Type u_4} (s : finset Î¹) (w : Î¹ â†’ k) (p : Î¹ â†’ P) (h : s.sum (Î» (i : Î¹), w i) = 0) (b : P) : â‡‘(s.weighted_vsub p) w = â‡‘(s.weighted_vsub_of_point p b) w
theorem submodule.le_orthogonal_orthogonal {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] (K : submodule ğ•œ E) : K â‰¤ Ká—®á—®
theorem mdifferentiable_at.differentiable_at {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {E' : Type u_3} [normed_group E'] [normed_space ğ•œ E'] {f : E â†’ E'} {x : E} : mdifferentiable_at (model_with_corners_self ğ•œ E) (model_with_corners_self ğ•œ E') f x â†’ differentiable_at ğ•œ f x
theorem add_subgroup.normal_add {G : Type u_1} [add_group G] (N H : add_subgroup G) [N.normal] : â†‘(N âŠ” H) = â†‘N + â†‘H
theorem cont_diff_within_at.mul {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {x : E} {n : with_top â„•} {s : set E} {f g : E â†’ ğ•œ} (hf : cont_diff_within_at ğ•œ n f s x) (hg : cont_diff_within_at ğ•œ n g s x) : cont_diff_within_at ğ•œ n (Î» (x : E), f x * g x) s x
theorem list.nth_le_of_eq {Î± : Type u} {L L' : list Î±} (h : L = L') {i : â„•} (hi : i < L.length) : L.nth_le i hi = L'.nth_le i _
theorem is_lower_set.of_dual {Î± : Type u_1} [has_le Î±] {s : set Î±} : is_lower_set s â†’ is_upper_set (â‡‘order_dual.of_dual â»Â¹' s)
theorem pow_two {M : Type u} [monoid M] (a : M) : a ^ 2 = a * a
theorem orthonormal.oangle_neg_right {V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) {x y : V} (hx : x â‰  0) (hy : y â‰  0) : hb.oangle x (-y) = hb.oangle x y + â†‘real.pi
theorem subsemigroup.closure_eq {M : Type u_1} [has_mul M] (S : subsemigroup M) : subsemigroup.closure â†‘S = S
theorem monotone.le_iterate_of_le {Î± : Type u_1} [preorder Î±] {f g : Î± â†’ Î±} (hg : monotone g) (h : f â‰¤ g) (n : â„•) : f^[n] â‰¤ (g^[n])
theorem matrix.det_succ_row {R : Type v} [comm_ring R] {n : â„•} (A : matrix (fin n.succ) (fin n.succ) R) (i : fin n.succ) : A.det = finset.univ.sum (Î» (j : fin n.succ), (-1) ^ (â†‘i + â†‘j) * A i j * (A.minor â‡‘(i.succ_above) â‡‘(j.succ_above)).det)
theorem submonoid.localization_map.comp_eq_of_eq {M : Type u_1} [comm_monoid M] {S : submonoid M} {N : Type u_2} [comm_monoid N] {P : Type u_3} [comm_monoid P] (f : S.localization_map N) {g : M â†’* P} {T : submonoid P} {Q : Type u_4} [comm_monoid Q] (hg : âˆ€ (y : â†¥S), â‡‘g â†‘y âˆˆ T) (k : T.localization_map Q) {x y : M} (h : â‡‘(f.to_map) x = â‡‘(f.to_map) y) : â‡‘(k.to_map) (â‡‘g x) = â‡‘(k.to_map) (â‡‘g y)
theorem filter.exists_antitone_basis {Î± : Type u_1} (f : filter Î±) [f.is_countably_generated] : âˆƒ (x : â„• â†’ set Î±), f.has_antitone_basis x
theorem algebra.discr_power_basis_eq_norm (K : Type u) {L : Type v} [field K] [field L] [algebra K L] [module.finite K L] (pb : power_basis K L) [is_separable K L] : algebra.discr K â‡‘(pb.basis) = (-1) ^ (finite_dimensional.finrank K L * (finite_dimensional.finrank K L - 1) / 2) * â‡‘(algebra.norm K) (â‡‘(polynomial.aeval pb.gen) (â‡‘polynomial.derivative (minpoly K pb.gen)))
theorem add_con.lift_funext {M : Type u_1} {P : Type u_3} [add_zero_class M] [add_zero_class P] {c : add_con M} (f g : c.quotient â†’+ P) (h : âˆ€ (a : M), â‡‘f â†‘a = â‡‘g â†‘a) : f = g
theorem subsemiring.closure_mono {R : Type u} [non_assoc_semiring R] â¦ƒs t : set Râ¦„ (h : s âŠ† t) : subsemiring.closure s â‰¤ subsemiring.closure t
theorem finset.sum_centroid_weights_eq_one_of_card_ne_zero (k : Type u_1) [division_ring k] {Î¹ : Type u_4} (s : finset Î¹) [char_zero k] (h : s.card â‰  0) : s.sum (Î» (i : Î¹), finset.centroid_weights k s i) = 1
theorem image_le_of_liminf_slope_right_lt_deriv_boundary {f f' : â„ â†’ â„} {a b : â„} (hf : continuous_on f (set.Icc a b)) (hf' : âˆ€ (x : â„), x âˆˆ set.Ico a b â†’ âˆ€ (r : â„), f' x < r â†’ (âˆƒá¶  (z : â„) in nhds_within x (set.Ioi x), slope f x z < r)) {B B' : â„ â†’ â„} (ha : f a â‰¤ B a) (hB : âˆ€ (x : â„), has_deriv_at B (B' x) x) (bound : âˆ€ (x : â„), x âˆˆ set.Ico a b â†’ f x = B x â†’ f' x < B' x) â¦ƒx : â„â¦„ : x âˆˆ set.Icc a b â†’ f x â‰¤ B x
theorem ennreal.sum_lt_top {Î± : Type u_1} {s : finset Î±} {f : Î± â†’ ennreal} (h : âˆ€ (a : Î±), a âˆˆ s â†’ f a â‰  âŠ¤) : s.sum (Î» (a : Î±), f a) < âŠ¤
theorem inner_product_space.is_self_adjoint.diagonalization_apply_self_apply {ğ•œ : Type u_1} [is_R_or_C ğ•œ] [dec_ğ•œ : decidable_eq ğ•œ] {E : Type u_2} [inner_product_space ğ•œ E] {T : E â†’â‚—[ğ•œ] E} (hT : inner_product_space.is_self_adjoint T) [finite_dimensional ğ•œ E] (v : E) (Î¼ : module.End.eigenvalues T) : â‡‘(hT.diagonalization) (â‡‘T v) Î¼ = â†‘Î¼ â€¢ â‡‘(hT.diagonalization) v Î¼
theorem set.image_congr' {Î± : Type u} {Î² : Type v} {f g : Î± â†’ Î²} {s : set Î±} (h : âˆ€ (x : Î±), f x = g x) : f '' s = g '' s
theorem not_is_unit_prime_of_dvd_card {R : Type u_1} [comm_ring R] [fintype R] (p : â„•) [fact (nat.prime p)] (hp : p âˆ£ fintype.card R) : Â¬is_unit â†‘p
theorem matrix.det_conj' {m : Type u} {Î± : Type v} [comm_ring Î±] [fintype m] [decidable_eq m] {M : matrix m m Î±} (h : is_unit M) (N : matrix m m Î±) : ((Mâ»Â¹.mul N).mul M).det = N.det
theorem upper_semicontinuous_within_at.add {Î± : Type u_1} [topological_space Î±] {x : Î±} {s : set Î±} {Î³ : Type u_4} [linear_ordered_add_comm_monoid Î³] [topological_space Î³] [order_topology Î³] [has_continuous_add Î³] {f g : Î± â†’ Î³} (hf : upper_semicontinuous_within_at f s x) (hg : upper_semicontinuous_within_at g s x) : upper_semicontinuous_within_at (Î» (z : Î±), f z + g z) s x
theorem filter.tendsto.cesaro {u : â„• â†’ â„} {l : â„} (h : filter.tendsto u filter.at_top (nhds l)) : filter.tendsto (Î» (n : â„•), (â†‘n)â»Â¹ * (finset.range n).sum (Î» (i : â„•), u i)) filter.at_top (nhds l)
theorem affine_independent_iff {k : Type u_1} {V : Type u_2} [ring k] [add_comm_group V] [module k V] {Î¹ : Type u_3} {p : Î¹ â†’ V} : affine_independent k p â†” âˆ€ (s : finset Î¹) (w : Î¹ â†’ k), s.sum w = 0 â†’ s.sum (Î» (e : Î¹), w e â€¢ p e) = 0 â†’ âˆ€ (e : Î¹), e âˆˆ s â†’ w e = 0
theorem polynomial.gal.card_of_separable {F : Type u_1} [field F] {p : polynomial F} (hp : p.separable) : fintype.card p.gal = finite_dimensional.finrank F p.splitting_field
theorem is_cyclotomic_extension.union_right (S T : set â„•+) (A : Type u) (B : Type v) [comm_ring A] [comm_ring B] [algebra A B] [h : is_cyclotomic_extension (S âˆª T) A B] : is_cyclotomic_extension T â†¥(algebra.adjoin A {b : B | âˆƒ (a : â„•+), a âˆˆ S âˆ§ b ^ â†‘a = 1}) B
theorem neg_nonpos {Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± has_add.add has_le.le] {a : Î±} : -a â‰¤ 0 â†” 0 â‰¤ a
theorem ideal.injective_quotient_le_comap_map {R : Type u_1} [comm_ring R] (P : ideal (polynomial R)) : function.injective â‡‘((ideal.map (polynomial.map_ring_hom (ideal.quotient.mk (ideal.comap polynomial.C P))) P).quotient_map (polynomial.map_ring_hom (ideal.quotient.mk (ideal.comap polynomial.C P))) ideal.le_comap_map)
theorem lipschitz_on_with.approximates_linear_on {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {f : E â†’ F} {f' : E â†’L[ğ•œ] F} {s : set E} {c : nnreal} : lipschitz_on_with c (f - â‡‘f') s â†’ approximates_linear_on f f' s c
theorem nat.eq_pow_of_factorization_eq_single {n p k : â„•} (hn : n â‰  0) (h : n.factorization = finsupp.single p k) : n = p ^ k
theorem legendre_symbol.sum_mul_div_add_sum_mul_div_eq_mul (p q : â„•) [hp : fact (nat.prime p)] (hq0 : â†‘q â‰  0) : (finset.Ico 1 (p / 2).succ).sum (Î» (a : â„•), a * q / p) + (finset.Ico 1 (q / 2).succ).sum (Î» (a : â„•), a * p / q) = p / 2 * (q / 2)
theorem is_semiring_hom.to_is_add_monoid_hom {Î± : Type u} {Î² : Type v} [semiring Î±] [semiring Î²] {f : Î± â†’ Î²} (hf : is_semiring_hom f) : is_add_monoid_hom f
theorem circle_integral.integral_sub_inv_of_mem_ball {c w : â„‚} {R : â„} (hw : w âˆˆ metric.ball c R) : âˆ® (z : â„‚) in C(c, R), (z - w)â»Â¹ = 2 * â†‘real.pi * complex.I
theorem supr_option_elim {Î± : Type u_1} {Î² : Type u_2} [complete_lattice Î±] (a : Î±) (f : Î² â†’ Î±) : (â¨† (o : option Î²), option.elim a f o) = a âŠ” â¨† (b : Î²), f b
theorem emetric.inf_edist_anti {Î± : Type u} [pseudo_emetric_space Î±] {x : Î±} {s t : set Î±} (h : s âŠ† t) : emetric.inf_edist x t â‰¤ emetric.inf_edist x s
theorem antilipschitz_with.of_le_mul_dist {Î± : Type u_1} {Î² : Type u_2} [pseudo_metric_space Î±] [pseudo_metric_space Î²] {K : nnreal} {f : Î± â†’ Î²} : (âˆ€ (x y : Î±), has_dist.dist x y â‰¤ â†‘K * has_dist.dist (f x) (f y)) â†’ antilipschitz_with K f
theorem module.projective_of_lifting_property' {R : Type u} [semiring R] {P : Type (max u v)} [add_comm_monoid P] [module R P] (huniv : âˆ€ {M : Type (max v u)} {N : Type (max u v)} [_inst_8 : add_comm_monoid M] [_inst_9 : add_comm_monoid N] [_inst_10 : module R M] [_inst_11 : module R N] (f : M â†’â‚—[R] N) (g : P â†’â‚—[R] N), function.surjective â‡‘f â†’ (âˆƒ (h : P â†’â‚—[R] M), f.comp h = g)) : module.projective R P
theorem category_theory.well_powered_congr {C : Type uâ‚} [category_theory.category C] {D : Type uâ‚‚} [category_theory.category D] (e : C â‰Œ D) : category_theory.well_powered C â†” category_theory.well_powered D
theorem linear_recurrence.geom_sol_iff_root_char_poly {Î± : Type u_1} [comm_ring Î±] (E : linear_recurrence Î±) (q : Î±) : E.is_solution (Î» (n : â„•), q ^ n) â†” E.char_poly.is_root q
theorem complex.circle_integral_sub_center_inv_smul_of_differentiable_on_off_countable {E : Type u} [normed_group E] [normed_space â„‚ E] [complete_space E] {R : â„} (h0 : 0 < R) {f : â„‚ â†’ E} {c : â„‚} {s : set â„‚} (hs : s.countable) (hc : continuous_on f (metric.closed_ball c R)) (hd : âˆ€ (z : â„‚), z âˆˆ metric.ball c R  s â†’ differentiable_at â„‚ f z) : âˆ® (z : â„‚) in C(c, R), (z - c)â»Â¹ â€¢ f z = (2 * â†‘real.pi * complex.I) â€¢ f c
theorem set.prod_mul_indicator_subset {Î± : Type u_1} {M : Type u_4} [comm_monoid M] (f : Î± â†’ M) {s t : finset Î±} (h : s âŠ† t) : s.prod (Î» (i : Î±), f i) = t.prod (Î» (i : Î±), â†‘s.mul_indicator f i)
theorem cardinal.mk_Ioc_real {a b : â„} (h : a < b) : cardinal.mk â†¥(set.Ioc a b) = cardinal.continuum
theorem lucas_lehmer.X.X_card {q : â„•+} : fintype.card (lucas_lehmer.X q) = â†‘q ^ 2
theorem interval_integral.integral_has_strict_deriv_at_right {E : Type u_3} [normed_group E] [complete_space E] [normed_space â„ E] {f : â„ â†’ E} {a b : â„} (hf : interval_integrable f measure_theory.measure_space.volume a b) (hmeas : strongly_measurable_at_filter f (nhds b) measure_theory.measure_space.volume) (hb : continuous_at f b) : has_strict_deriv_at (Î» (u : â„), âˆ« (x : â„) in a..u, f x) (f b) b
theorem flow.omega_limit_image_eq {Ï„ : Type u_1} [topological_space Ï„] [add_comm_group Ï„] [topological_add_group Ï„] {Î± : Type u_2} [topological_space Î±] (f : filter Ï„) (Ï• : flow Ï„ Î±) (s : set Î±) (hf : âˆ€ (t : Ï„), filter.tendsto (Î» (_x : Ï„), _x + t) f f) (t : Ï„) : omega_limit f â‡‘Ï• (â‡‘Ï• t '' s) = omega_limit f â‡‘Ï• s
theorem finset.Icc_eq_empty {Î± : Type u_1} [preorder Î±] [locally_finite_order Î±] {a b : Î±} : Â¬a â‰¤ b â†’ finset.Icc a b = âˆ…
theorem nat.lt_wf  : well_founded nat.lt
theorem lipschitz_with.of_dist_le_mul {Î± : Type u} {Î² : Type v} [pseudo_metric_space Î±] [pseudo_metric_space Î²] {K : nnreal} {f : Î± â†’ Î²} : (âˆ€ (x y : Î±), has_dist.dist (f x) (f y) â‰¤ â†‘K * has_dist.dist x y) â†’ lipschitz_with K f
theorem minpoly.monic {A : Type u_1} {B : Type u_2} [comm_ring A] [ring B] [algebra A B] {x : B} (hx : is_integral A x) : (minpoly A x).monic
theorem monotone.csupr_mem_Inter_Icc_of_antitone {Î± : Type u_1} {Î² : Type u_2} [conditionally_complete_lattice Î±] [semilattice_sup Î²] {f g : Î² â†’ Î±} (hf : monotone f) (hg : antitone g) (h : f â‰¤ g) : (â¨† (n : Î²), f n) âˆˆ â‹‚ (n : Î²), set.Icc (f n) (g n)
theorem list.length_pos_of_sum_ne_zero {M : Type u_3} [add_monoid M] (L : list M) (h : L.sum â‰  0) : 0 < L.length
theorem with_top.sum_eq_top_iff {Î¹ : Type u_1} {M : Type u_4} [ordered_add_comm_monoid M] {s : finset Î¹} {f : Î¹ â†’ with_top M} : s.sum (Î» (i : Î¹), f i) = âŠ¤ â†” âˆƒ (i : Î¹) (H : i âˆˆ s), f i = âŠ¤
theorem one_lt_mul' {Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a b : Î±} (ha : 1 < a) (hb : 1 < b) : 1 < a * b
theorem polynomial.cyclotomic_prime_pow_eq_geom_sum {R : Type u_1} [comm_ring R] {p n : â„•} (hp : nat.prime p) : polynomial.cyclotomic (p ^ (n + 1)) R = (finset.range p).sum (Î» (i : â„•), (polynomial.X ^ p ^ n) ^ i)
theorem parser.nat_eq_done {cb : char_buffer} {n n' val : â„•} : parser.nat cb n = parse_result.done n' val â†” âˆƒ (hn : n < n'), val = nat.of_digits 10 (list.map (Î» (c : char), c.to_nat - '0'.to_nat) (list.take (n' - n) (list.drop n (buffer.to_list cb))).reverse) âˆ§ (âˆ€ (hn' : n' < buffer.size cb), '0' â‰¤ buffer.read cb âŸ¨n', hn'âŸ© â†’ '9' < buffer.read cb âŸ¨n', hn'âŸ©) âˆ§ âˆƒ (hn'' : n' â‰¤ buffer.size cb), âˆ€ (k : â„•) (hk : k < n'), n â‰¤ k â†’ '0' â‰¤ buffer.read cb âŸ¨k, _âŸ© âˆ§ buffer.read cb âŸ¨k, _âŸ© â‰¤ '9'
theorem simple_graph.min_degree_le_degree {V : Type u} (G : simple_graph V) [fintype V] [decidable_rel G.adj] (v : V) : G.min_degree â‰¤ G.degree v
theorem norm_smul_inv_norm' {ğ•œ : Type u_1} [is_R_or_C ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {r : â„} (r_nonneg : 0 â‰¤ r) {x : E} (hx : x â‰  0) : âˆ¥(â†‘r * (â†‘âˆ¥xâˆ¥)â»Â¹) â€¢ xâˆ¥ = r
theorem continuous_at.div {Î± : Type u_1} {Gâ‚€ : Type u_3} [group_with_zero Gâ‚€] [topological_space Gâ‚€] [has_continuous_invâ‚€ Gâ‚€] [has_continuous_mul Gâ‚€] {f g : Î± â†’ Gâ‚€} [topological_space Î±] {a : Î±} (hf : continuous_at f a) (hg : continuous_at g a) (hâ‚€ : g a â‰  0) : continuous_at (f / g) a
theorem add_valuation.supp_quot {R : Type u_2} {Î“â‚€ : Type u_3} [linear_ordered_add_comm_monoid_with_top Î“â‚€] [comm_ring R] (v : add_valuation R Î“â‚€) {J : ideal R} (hJ : J â‰¤ v.supp) : (v.on_quot hJ).supp = ideal.map (ideal.quotient.mk J) v.supp
theorem finite_dimensional.finrank_eq_card_basis {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {Î¹ : Type w} [fintype Î¹] (h : basis Î¹ K V) : finite_dimensional.finrank K V = fintype.card Î¹
theorem euclidean_geometry.dist_sq_eq_dist_orthogonal_projection_sq_add_dist_orthogonal_projection_sq {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace â„ P} [nonempty â†¥s] [complete_space â†¥(s.direction)] {p1 : P} (p2 : P) (hp1 : p1 âˆˆ s) : has_dist.dist p1 p2 * has_dist.dist p1 p2 = has_dist.dist p1 â†‘(â‡‘(euclidean_geometry.orthogonal_projection s) p2) * has_dist.dist p1 â†‘(â‡‘(euclidean_geometry.orthogonal_projection s) p2) + has_dist.dist p2 â†‘(â‡‘(euclidean_geometry.orthogonal_projection s) p2) * has_dist.dist p2 â†‘(â‡‘(euclidean_geometry.orthogonal_projection s) p2)
theorem emetric.Hausdorff_edist_self_closure {Î± : Type u} [pseudo_emetric_space Î±] {s : set Î±} : emetric.Hausdorff_edist s (closure s) = 0
theorem refl_trans_gen_of_succ_of_le {Î± : Type u_1} [partial_order Î±] [succ_order Î±] [is_succ_archimedean Î±] (r : Î± â†’ Î± â†’ Prop) {n m : Î±} (h : âˆ€ (i : Î±), i âˆˆ set.Ico n m â†’ r i (order.succ i)) (hnm : n â‰¤ m) : relation.refl_trans_gen r n m
theorem is_local_max.deriv_eq_zero {f : â„ â†’ â„} {a : â„} (h : is_local_max f a) : deriv f a = 0
theorem polynomial.nat_degree_prod' {R : Type u} {Î¹ : Type w} (s : finset Î¹) [comm_semiring R] (f : Î¹ â†’ polynomial R) (h : s.prod (Î» (i : Î¹), (f i).leading_coeff) â‰  0) : (s.prod (Î» (i : Î¹), f i)).nat_degree = s.sum (Î» (i : Î¹), (f i).nat_degree)
theorem affine.simplex.mk_of_point_points (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (p : P) (i : fin 1) : (affine.simplex.mk_of_point k p).points i = p
theorem set.inv_Ioo_0_left {k : Type u} [linear_ordered_field k] {a : k} (ha : 0 < a) : (set.Ioo 0 a)â»Â¹ = set.Ioi aâ»Â¹
theorem local_equiv.eq_of_eq_on_source_univ {Î± : Type u_1} {Î² : Type u_2} (e e' : local_equiv Î± Î²) (h : e â‰ˆ e') (s : e.source = set.univ) (t : e.target = set.univ) : e = e'
theorem lipschitz_with_of_nnnorm_deriv_le {ğ•œ : Type u_3} {G : Type u_4} [is_R_or_C ğ•œ] [normed_group G] [normed_space ğ•œ G] {f : ğ•œ â†’ G} {C : nnreal} (hf : differentiable ğ•œ f) (bound : âˆ€ (x : ğ•œ), âˆ¥deriv f xâˆ¥â‚Š â‰¤ C) : lipschitz_with C f
theorem strict_anti_on.Iic_union_Ici {Î± : Type u_1} {Î² : Type u_2} [linear_order Î±] [preorder Î²] {a : Î±} {f : Î± â†’ Î²} (hâ‚ : strict_anti_on f (set.Iic a)) (hâ‚‚ : strict_anti_on f (set.Ici a)) : strict_anti f
theorem affine_map.line_map_continuous {R : Type u_1} {F : Type u_3} [add_comm_group F] [topological_space F] [topological_add_group F] [ring R] [module R F] [topological_space R] [has_continuous_smul R F] {p v : F} : continuous â‡‘(affine_map.line_map p v)
theorem eq.subset {Î± : Type u_1} {s t : set Î±} : s = t â†’ s âŠ† t
theorem mul_hom.congr_arg {M : Type u_3} {N : Type u_4} [has_mul M] [has_mul N] (f : M â†’â‚™* N) {x y : M} (h : x = y) : â‡‘f x = â‡‘f y
theorem is_frobenius_number_pair {m n : â„•} (cop : m.coprime n) (hm : 1 < m) (hn : 1 < n) : is_frobenius_number (m * n - m - n) {m, n}
theorem edist_eq_zero {Î³ : Type w} [emetric_space Î³] {x y : Î³} : has_edist.edist x y = 0 â†” x = y
theorem measure_theory.is_fundamental_domain.measure_eq {G : Type u_1} {Î± : Type u_2} [group G] [mul_action G Î±] [measurable_space Î±] {s t : set Î±} {Î¼ : measure_theory.measure Î±} [measurable_space G] [has_measurable_smul G Î±] [measure_theory.smul_invariant_measure G Î± Î¼] [encodable G] (hs : measure_theory.is_fundamental_domain G s Î¼) (ht : measure_theory.is_fundamental_domain G t Î¼) : â‡‘Î¼ s = â‡‘Î¼ t
theorem padic_int.lift_unique {p : â„•} [hp_prime : fact (nat.prime p)] {R : Type u_1} [non_assoc_semiring R] {f : Î  (k : â„•), R â†’+* zmod (p ^ k)} (f_compat : âˆ€ (k1 k2 : â„•) (hk : k1 â‰¤ k2), (zmod.cast_hom _ (zmod (p ^ k1))).comp (f k2) = f k1) (g : R â†’+* â„¤_[p]) (hg : âˆ€ (n : â„•), (padic_int.to_zmod_pow n).comp g = f n) : padic_int.lift f_compat = g
theorem multiset.sub_zero {Î± : Type u_1} [decidable_eq Î±] (s : multiset Î±) : s - 0 = s
theorem setoid.Sup_eq_eqv_gen {Î± : Type u_1} (S : set (setoid Î±)) : has_Sup.Sup S = eqv_gen.setoid (Î» (x y : Î±), âˆƒ (r : setoid Î±), r âˆˆ S âˆ§ r.rel x y)
theorem polynomial.cyclotomic_expand_eq_cyclotomic_mul {p n : â„•} (hp : nat.prime p) (hdiv : Â¬p âˆ£ n) (R : Type u_1) [comm_ring R] : â‡‘(polynomial.expand R p) (polynomial.cyclotomic n R) = polynomial.cyclotomic (n * p) R * polynomial.cyclotomic n R
theorem convex.set_combo_subset {ğ•œ : Type u_1} {E : Type u_2} [ordered_semiring ğ•œ] [add_comm_monoid E] [has_scalar ğ•œ E] {s : set E} : convex ğ•œ s â†’ âˆ€ â¦ƒa b : ğ•œâ¦„, 0 â‰¤ a â†’ 0 â‰¤ b â†’ a + b = 1 â†’ a â€¢ s + b â€¢ s âŠ† s
theorem field.to_is_field (R : Type u) [field R] : is_field R
theorem finset.nat.prod_antidiagonal_eq_prod_range_succ {M : Type u_1} [comm_monoid M] (f : â„• â†’ â„• â†’ M) (n : â„•) : (finset.nat.antidiagonal n).prod (Î» (ij : â„• Ã— â„•), f ij.fst ij.snd) = (finset.range n.succ).prod (Î» (k : â„•), f k (n - k))
theorem add_con.symm {M : Type u_1} [has_add M] (c : add_con M) {x y : M} : â‡‘c x y â†’ â‡‘c y x
theorem affine_basis.linear_combination_coord_eq_self {Î¹ : Type uâ‚} {k : Type uâ‚‚} {V : Type uâ‚ƒ} [add_comm_group V] [ring k] [module k V] [fintype Î¹] (b : affine_basis Î¹ k V) (v : V) : finset.univ.sum (Î» (i : Î¹), â‡‘(b.coord i) v â€¢ b.points i) = v
theorem homology_map_eq_of_homotopy {Î¹ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape Î¹} {C D : homological_complex V c} {f g : C âŸ¶ D} [category_theory.limits.has_equalizers V] [category_theory.limits.has_cokernels V] [category_theory.limits.has_images V] [category_theory.limits.has_image_maps V] [category_theory.limits.has_zero_object V] (h : homotopy f g) (i : Î¹) : (homology_functor V c i).map f = (homology_functor V c i).map g
theorem ae_strongly_measurable_of_tendsto_ae {Î± : Type u_1} {Î² : Type u_2} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [topological_space Î²] {Î¹ : Type u_3} [topological_space.pseudo_metrizable_space Î²] (u : filter Î¹) [u.ne_bot] [u.is_countably_generated] {f : Î¹ â†’ Î± â†’ Î²} {g : Î± â†’ Î²} (hf : âˆ€ (i : Î¹), measure_theory.ae_strongly_measurable (f i) Î¼) (lim : âˆ€áµ (x : Î±) âˆ‚Î¼, filter.tendsto (Î» (n : Î¹), f n x) u (nhds (g x))) : measure_theory.ae_strongly_measurable g Î¼
theorem measure_theory.pdf.to_quasi_measure_preserving {Î± : Type u_1} {E : Type u_2} [measurable_space E] {m : measurable_space Î±} {â„™ : measure_theory.measure Î±} {Î¼ : measure_theory.measure E} {X : Î± â†’ E} [measure_theory.has_pdf X Â«â„™Â» Î¼] : measure_theory.measure.quasi_measure_preserving X Â«â„™Â» Î¼
theorem finset.le_sum_of_subadditive {Î¹ : Type u_1} {M : Type u_4} {N : Type u_5} [add_comm_monoid M] [ordered_add_comm_monoid N] (f : M â†’ N) (h_one : f 0 = 0) (h_mul : âˆ€ (x y : M), f (x + y) â‰¤ f x + f y) (s : finset Î¹) (g : Î¹ â†’ M) : f (s.sum (Î» (i : Î¹), g i)) â‰¤ s.sum (Î» (i : Î¹), f (g i))
theorem linear_isometry_equiv.inner_map_map {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {E' : Type u_7} [inner_product_space ğ•œ E'] (f : E â‰ƒâ‚—áµ¢[ğ•œ] E') (x y : E) : has_inner.inner (â‡‘f x) (â‡‘f y) = has_inner.inner x y
theorem finset.univ_filter_mem_range {Î± : Type u_1} {Î² : Type u_2} [fintype Î±] (f : Î± â†’ Î²) [fintype Î²] [decidable_pred (Î» (y : Î²), y âˆˆ set.range f)] [decidable_eq Î²] : finset.filter (Î» (y : Î²), y âˆˆ set.range f) finset.univ = finset.image f finset.univ
theorem power_series.le_order {R : Type u_1} [semiring R] (Ï† : power_series R) (n : enat) (h : âˆ€ (i : â„•), â†‘i < n â†’ â‡‘(power_series.coeff R i) Ï† = 0) : n â‰¤ Ï†.order
theorem bilin_form.restrict_nondegenerate_of_is_compl_orthogonal {V : Type u_9} {K : Type u_10} [field K] [add_comm_group V] [module K V] [finite_dimensional K V] {B : bilin_form K V} {W : subspace K V} (bâ‚ : B.is_refl) (bâ‚‚ : (B.restrict W).nondegenerate) : is_compl W (B.orthogonal W)
theorem ordinal.fp_family_unbounded {Î¹ : Type u} {f : Î¹ â†’ ordinal â†’ ordinal} (H : âˆ€ (i : Î¹), ordinal.is_normal (f i)) : set.unbounded has_lt.lt (â‹‚ (i : Î¹), function.fixed_points (f i))
theorem matrix.nonsing_inv_eq_ring_inverse {n : Type u'} {Î± : Type v} [fintype n] [decidable_eq n] [comm_ring Î±] (A : matrix n n Î±) : Aâ»Â¹ = ring.inverse A
theorem dim_range_add_dim_ker {K : Type u} {V Vâ‚ : Type v} [field K] [add_comm_group V] [module K V] [add_comm_group Vâ‚] [module K Vâ‚] (f : V â†’â‚—[K] Vâ‚) : module.rank K â†¥(f.range) + module.rank K â†¥(f.ker) = module.rank K V
theorem set.countable.dimH_zero {X : Type u_2} [emetric_space X] {s : set X} (hs : s.countable) : dimH s = 0
theorem lower_adjoint.le_closure {Î± : Type u_1} {Î² : Type u_4} [preorder Î±] [preorder Î²] {u : Î² â†’ Î±} (l : lower_adjoint u) (x : Î±) : x â‰¤ u (â‡‘l x)
theorem dite_apply {Î± : Sort u_1} {Ïƒ : Î± â†’ Sort u_4} (P : Prop) [decidable P] (f : P â†’ Î  (a : Î±), Ïƒ a) (g : Â¬P â†’ Î  (a : Î±), Ïƒ a) (a : Î±) : dite P f g a = dite P (Î» (h : P), f h a) (Î» (h : Â¬P), g h a)
theorem contracting_with.exists_fixed_point' {Î± : Type u_1} [emetric_space Î±] {K : nnreal} {f : Î± â†’ Î±} {s : set Î±} (hsc : is_complete s) (hsf : set.maps_to f s s) (hf : contracting_with K (set.maps_to.restrict f s s hsf)) {x : Î±} (hxs : x âˆˆ s) (hx : has_edist.edist x (f x) â‰  âŠ¤) : âˆƒ (y : Î±) (H : y âˆˆ s), function.is_fixed_pt f y âˆ§ filter.tendsto (Î» (n : â„•), f^[n] x) filter.at_top (nhds y) âˆ§ âˆ€ (n : â„•), has_edist.edist (f^[n] x) y â‰¤ has_edist.edist x (f x) * â†‘K ^ n / (1 - â†‘K)
theorem ring.inverse_non_unit {Mâ‚€ : Type u_1} [monoid_with_zero Mâ‚€] (x : Mâ‚€) (h : Â¬is_unit x) : ring.inverse x = 0
theorem finsupp.mul_prod_erase {Î± : Type u_1} {M : Type u_5} {N : Type u_7} [has_zero M] [comm_monoid N] (f : Î± â†’â‚€ M) (y : Î±) (g : Î± â†’ M â†’ N) (hyf : y âˆˆ f.support) : g y (â‡‘f y) * (finsupp.erase y f).prod g = f.prod g
theorem pgame.right_distrib_equiv (x y z : pgame) : ((x + y) * z).equiv (x * z + y * z)
theorem has_subset.subset.not_ssubset {Î± : Type u} [has_subset Î±] [has_ssubset Î±] [is_nonstrict_strict_order Î± has_subset.subset has_ssubset.ssubset] {a b : Î±} (h : a âŠ† b) : Â¬b âŠ‚ a
theorem subsingleton.convex_independent {ğ•œ : Type u_1} {E : Type u_2} {Î¹ : Type u_3} [ordered_semiring ğ•œ] [add_comm_group E] [module ğ•œ E] [subsingleton Î¹] (p : Î¹ â†’ E) : convex_independent ğ•œ p
theorem category_theory.reassoc_of {Î± : Sort u_1} (hh : Î±) {Î² : Prop} (x : tactic.calculated_Prop Î² hh . "derive_reassoc_proof") : Î²
theorem measurable_set_of_differentiable_within_at_Ici {F : Type u_1} [normed_group F] [normed_space â„ F] (f : â„ â†’ F) [complete_space F] : measurable_set {x : â„ | differentiable_within_at â„ f (set.Ici x) x}
theorem fixed_points_subgroup_sup (M : Type u_1) (Î± : Type u_2) [group M] [mul_action M Î±] {P Q : subgroup M} : mul_action.fixed_points â†¥(P âŠ” Q) Î± = mul_action.fixed_points â†¥P Î± âˆ© mul_action.fixed_points â†¥Q Î±
theorem submonoid.dense_induction {M : Type u_1} [mul_one_class M] {p : M â†’ Prop} (x : M) {s : set M} (hs : submonoid.closure s = âŠ¤) (Hs : âˆ€ (x : M), x âˆˆ s â†’ p x) (H1 : p 1) (Hmul : âˆ€ (x y : M), p x â†’ p y â†’ p (x * y)) : p x
theorem contracting_with.aposteriori_dist_iterate_fixed_point_le {Î± : Type u_1} [metric_space Î±] {K : nnreal} {f : Î± â†’ Î±} (hf : contracting_with K f) [nonempty Î±] [complete_space Î±] (x : Î±) (n : â„•) : has_dist.dist (f^[n] x) (contracting_with.fixed_point f hf) â‰¤ has_dist.dist (f^[n] x) (f^[n + 1] x) / (1 - â†‘K)
theorem is_square_of_exists_sq {Î± : Type u_2} [monoid Î±] (m : Î±) : (âˆƒ (c : Î±), m = c ^ 2) â†’ is_square m
theorem is_localization.map_injective_of_injective {R : Type u_1} [comm_ring R] (M : submonoid R) (S : Type u_2) [comm_ring S] [algebra R S] {P : Type u_3} [comm_ring P] [is_localization M S] (Q : Type u_5) [comm_ring Q] {g : R â†’+* P} [algebra P Q] (hg : function.injective â‡‘g) [is_localization (submonoid.map â†‘g M) Q] (hM : submonoid.map â†‘g M â‰¤ non_zero_divisors P) : function.injective â‡‘(is_localization.map Q g _)
theorem finsupp.map_domain_map_range {Î± : Type u_1} {Î² : Type u_2} {M : Type u_5} {N : Type u_7} [add_comm_monoid M] [add_comm_monoid N] (f : Î± â†’ Î²) (v : Î± â†’â‚€ M) (g : M â†’ N) (h0 : g 0 = 0) (hadd : âˆ€ (x y : M), g (x + y) = g x + g y) : finsupp.map_domain f (finsupp.map_range g h0 v) = finsupp.map_range g h0 (finsupp.map_domain f v)
theorem category_theory.limits.has_biproduct.of_has_coproduct {C : Type u} [category_theory.category C] [category_theory.preadditive C] {J : Type v} [fintype J] (f : J â†’ C) [category_theory.limits.has_coproduct f] : category_theory.limits.has_biproduct f
theorem fintype.exists_le_sum_fiber_of_nsmul_le_sum {Î± : Type u} {Î² : Type v} {M : Type w} [decidable_eq Î²] [fintype Î±] [fintype Î²] (f : Î± â†’ Î²) {w : Î± â†’ M} {b : M} [linear_ordered_cancel_add_comm_monoid M] [nonempty Î²] (hb : fintype.card Î² â€¢ b â‰¤ finset.univ.sum (Î» (x : Î±), w x)) : âˆƒ (y : Î²), b â‰¤ (finset.filter (Î» (x : Î±), f x = y) finset.univ).sum (Î» (x : Î±), w x)
theorem euclidean_geometry.cospherical_pair {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] (pâ‚ pâ‚‚ : P) : euclidean_geometry.cospherical {pâ‚, pâ‚‚}
theorem inv_gold_conj  : golden_conjâ»Â¹ = -golden_ratio
theorem nhds_basis_opens' {Î± : Type u} [topological_space Î±] (a : Î±) : (nhds a).has_basis (Î» (s : set Î±), s âˆˆ nhds a âˆ§ is_open s) (Î» (x : set Î±), x)
theorem dimH_def {X : Type u_2} [emetric_space X] [measurable_space X] [borel_space X] (s : set X) : dimH s = â¨† (d : nnreal) (hd : â‡‘(measure_theory.measure.hausdorff_measure â†‘d) s = âŠ¤), â†‘d
theorem add_monoid.closure_subset {M : Type u_1} [add_monoid M] {s t : set M} (ht : is_add_submonoid t) (h : s âŠ† t) : add_monoid.closure s âŠ† t
theorem category_theory.locally_cover_dense.induced_topology_cover_lifting {C : Type u_1} [category_theory.category C] {D : Type u_3} [category_theory.category D] {G : C â¥¤ D} {K : category_theory.grothendieck_topology D} [category_theory.full G] [category_theory.faithful G] (Hld : category_theory.locally_cover_dense K G) : category_theory.cover_lifting Hld.induced_topology K G
theorem orientation.eq_or_eq_neg {R : Type u_1} [linear_ordered_field R] {M : Type u_2} [add_comm_group M] [module R M] {Î¹ : Type u_3} [decidable_eq Î¹] [fintype Î¹] [finite_dimensional R M] (xâ‚ xâ‚‚ : orientation R M Î¹) (h : fintype.card Î¹ = finite_dimensional.finrank R M) : xâ‚ = xâ‚‚ âˆ¨ xâ‚ = -xâ‚‚
theorem set.bInter_subset_of_mem {Î± : Type u_1} {Î² : Type u_2} {s : set Î±} {t : Î± â†’ set Î²} {x : Î±} (xs : x âˆˆ s) : (â‹‚ (x : Î±) (H : x âˆˆ s), t x) âŠ† t x
theorem measure_theory.ae_eq_of_subset_of_measure_ge {Î± : Type u_1} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {s t : set Î±} (hâ‚ : s âŠ† t) (hâ‚‚ : â‡‘Î¼ t â‰¤ â‡‘Î¼ s) (hsm : measurable_set s) (ht : â‡‘Î¼ t â‰  âŠ¤) : s =áµ[Î¼] t
theorem set.nonempty.not_disjoint {Î± : Type u_1} {s t : set Î±} : (s âˆ© t).nonempty â†’ Â¬disjoint s t
theorem principal_ideal_ring.ring_hom_mem_submonoid_of_factors_subset_of_units_subset {R : Type u_1} {S : Type u_2} [comm_ring R] [is_domain R] [is_principal_ideal_ring R] [semiring S] (f : R â†’+* S) (s : submonoid S) (a : R) (ha : a â‰  0) (h : âˆ€ (b : R), b âˆˆ principal_ideal_ring.factors a â†’ â‡‘f b âˆˆ s) (hf : âˆ€ (c : RË£), â‡‘f â†‘c âˆˆ s) : â‡‘f a âˆˆ s
theorem convex.exists_nhds_within_lipschitz_on_with_of_has_fderiv_within_at_of_nnnorm_lt {E : Type u_1} [normed_group E] [normed_space â„ E] {ğ•œ : Type u_3} {G : Type u_4} [is_R_or_C ğ•œ] [normed_space ğ•œ E] [normed_group G] [normed_space ğ•œ G] {s : set E} {x : E} {f' : E â†’ (E â†’L[ğ•œ] G)} (hs : convex â„ s) {f : E â†’ G} (hder : âˆ€á¶  (y : E) in nhds_within x s, has_fderiv_within_at f (f' y) s y) (hcont : continuous_within_at f' s x) (K : nnreal) (hK : âˆ¥f' xâˆ¥â‚Š < K) : âˆƒ (t : set E) (H : t âˆˆ nhds_within x s), lipschitz_on_with K f t
theorem function.periodic.interval_integral_add_zsmul_eq {E : Type u_1} [normed_group E] [normed_space â„ E] [complete_space E] {f : â„ â†’ E} {T : â„} (hf : function.periodic f T) (n : â„¤) (t : â„) (h_int : âˆ€ (tâ‚ tâ‚‚ : â„), interval_integrable f measure_theory.measure_space.volume tâ‚ tâ‚‚) : âˆ« (x : â„) in t..t + n â€¢ T, f x = n â€¢ âˆ« (x : â„) in t..t + T, f x
theorem nat.exists_strict_anti' {Î± : Type u} [preorder Î±] [no_min_order Î±] (a : Î±) : âˆƒ (f : â„• â†’ Î±), strict_anti f âˆ§ f 0 = a
theorem neg_pos {Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a : Î±} : 0 < -a â†” a < 0
theorem orthonormal.exists_linear_isometry_equiv_eq_of_det_pos {V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) {f : V â‰ƒâ‚—áµ¢[â„] V} (hd : 0 < â‡‘linear_map.det â†‘(f.to_linear_equiv)) : âˆƒ (Î¸ : real.angle), f = hb.rotation Î¸
theorem category_theory.is_subterminal.mono_is_terminal_from {C : Type uâ‚} [category_theory.category C] {A : C} (hA : category_theory.is_subterminal A) {T : C} (hT : category_theory.limits.is_terminal T) : category_theory.mono (hT.from A)
theorem antivary_on.sum_mul_eq_sum_mul_comp_perm_iff {Î¹ : Type u_1} {Î± : Type u_2} [linear_ordered_ring Î±] {s : finset Î¹} {Ïƒ : equiv.perm Î¹} {f g : Î¹ â†’ Î±} (hfg : antivary_on f g â†‘s) (hÏƒ : {x : Î¹ | â‡‘Ïƒ x â‰  x} âŠ† â†‘s) : s.sum (Î» (i : Î¹), f i * g (â‡‘Ïƒ i)) = s.sum (Î» (i : Î¹), f i * g i) â†” antivary_on f (g âˆ˜ â‡‘Ïƒ) â†‘s
theorem measure_theory.outer_measure.Union_of_tendsto_zero {Î± : Type u_1} {Î¹ : Type u_2} (m : measure_theory.outer_measure Î±) {s : Î¹ â†’ set Î±} (l : filter Î¹) [l.ne_bot] (h0 : filter.tendsto (Î» (k : Î¹), â‡‘m ((â‹ƒ (n : Î¹), s n)  s k)) l (nhds 0)) : â‡‘m (â‹ƒ (n : Î¹), s n) = â¨† (n : Î¹), â‡‘m (s n)
theorem ae_eq_const_or_norm_set_integral_lt_of_norm_le_const {Î± : Type u_1} {E : Type u_2} {m0 : measurable_space Î±} [normed_group E] [normed_space â„ E] [complete_space E] {Î¼ : measure_theory.measure Î±} {t : set Î±} {f : Î± â†’ E} {C : â„} [strict_convex_space â„ E] (ht : â‡‘Î¼ t â‰  âŠ¤) (h_le : âˆ€áµ (x : Î±) âˆ‚Î¼.restrict t, âˆ¥f xâˆ¥ â‰¤ C) : f =áµ[Î¼.restrict t] function.const Î± (â¨ (x : Î±) in t, f x âˆ‚Î¼) âˆ¨ âˆ¥âˆ« (x : Î±) in t, f x âˆ‚Î¼âˆ¥ < (â‡‘Î¼ t).to_real * C
theorem submonoid.supr_induction' {M : Type u_1} [mul_one_class M] {Î¹ : Sort u_2} (S : Î¹ â†’ submonoid M) {C : Î  (x : M), (x âˆˆ â¨† (i : Î¹), S i) â†’ Prop} (hp : âˆ€ (i : Î¹) (x : M) (H : x âˆˆ S i), C x _) (h1 : C 1 _) (hmul : âˆ€ (x y : M) (hx : x âˆˆ â¨† (i : Î¹), S i) (hy : y âˆˆ â¨† (i : Î¹), S i), C x hx â†’ C y hy â†’ C (x * y) _) {x : M} (hx : x âˆˆ â¨† (i : Î¹), S i) : C x hx
theorem submonoid.list_prod_mem {M : Type u_1} [monoid M] (s : submonoid M) {l : list M} (hl : âˆ€ (x : M), x âˆˆ l â†’ x âˆˆ s) : l.prod âˆˆ s
theorem real.inner_le_Lp_mul_Lq {Î¹ : Type u} (s : finset Î¹) (f g : Î¹ â†’ â„) {p q : â„} (hpq : p.is_conjugate_exponent q) : s.sum (Î» (i : Î¹), f i * g i) â‰¤ s.sum (Î» (i : Î¹), |f i| ^ p) ^ (1 / p) * s.sum (Î» (i : Î¹), |g i| ^ q) ^ (1 / q)
theorem finset.nonempty.to_set {Î± : Type u_1} {s : finset Î±} : s.nonempty â†’ â†‘s.nonempty
theorem pgame.mul_assoc_equiv (x y z : pgame) : (x * y * z).equiv (x * (y * z))
theorem emetric.cauchy_seq_iff {Î± : Type u} {Î² : Type v} [pseudo_emetric_space Î±] [nonempty Î²] [semilattice_sup Î²] {u : Î² â†’ Î±} : cauchy_seq u â†” âˆ€ (Îµ : ennreal), Îµ > 0 â†’ (âˆƒ (N : Î²), âˆ€ (m : Î²), m â‰¥ N â†’ âˆ€ (n : Î²), n â‰¥ N â†’ has_edist.edist (u m) (u n) < Îµ)
theorem coe_fn_coe_trans' {Î± : Sort u_1} {Î² : Sort u_2} {Î³ : Sort u_3} {Î´ : out_param (Sort u_4)} [has_coe Î± Î²] [has_coe_t_aux Î² Î³] [has_coe_to_fun Î³ (Î» (_x : Î³), Î´)] (x : Î±) : â‡‘x = â‡‘â†‘x
theorem orthonormal.oangle_eq_pi_sub_two_zsmul_oangle_sub_of_norm_eq {V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) {x y : V} (hn : x â‰  y) (h : âˆ¥xâˆ¥ = âˆ¥yâˆ¥) : hb.oangle y x = â†‘real.pi - 2 â€¢ hb.oangle (y - x) y
theorem module.free.finrank_linear_hom (R : Type u) (M : Type v) (N : Type w) [comm_ring R] [strong_rank_condition R] [add_comm_group M] [module R M] [module.free R M] [module.finite R M] [add_comm_group N] [module R N] [module.free R N] [module.finite R N] : finite_dimensional.finrank R (M â†’â‚—[R] N) = finite_dimensional.finrank R M * finite_dimensional.finrank R N
theorem closed_under_restriction_iff_id_le {H : Type u} [topological_space H] (G : structure_groupoid H) : closed_under_restriction G â†” id_restr_groupoid â‰¤ G
theorem linear_map.range_eq_top_of_cancel {R : Type u_1} {M : Type u_2} {Râ‚‚ : Type u_3} {Mâ‚‚ : Type u_4} [ring R] [ring Râ‚‚] [add_comm_monoid M] [add_comm_group Mâ‚‚] [module R M] [module Râ‚‚ Mâ‚‚] {Ï„â‚â‚‚ : R â†’+* Râ‚‚} [ring_hom_surjective Ï„â‚â‚‚] {f : M â†’â‚›â‚—[Ï„â‚â‚‚] Mâ‚‚} (h : âˆ€ (u v : Mâ‚‚ â†’â‚—[Râ‚‚] Mâ‚‚ â§¸ f.range), u.comp f = v.comp f â†’ u = v) : f.range = âŠ¤
theorem quadratic_form.complex_equivalent {M : Type u_1} [add_comm_group M] [module â„‚ M] [finite_dimensional â„‚ M] (Qâ‚ Qâ‚‚ : quadratic_form â„‚ M) (hQâ‚ : (â‡‘quadratic_form.associated Qâ‚).nondegenerate) (hQâ‚‚ : (â‡‘quadratic_form.associated Qâ‚‚).nondegenerate) : Qâ‚.equivalent Qâ‚‚
theorem Top.nonempty_limit_cone_of_compact_t2_cofiltered_system {J : Type u} [category_theory.small_category J] (F : J â¥¤ Top) [category_theory.is_cofiltered J] [âˆ€ (j : J), nonempty â†¥(F.obj j)] [âˆ€ (j : J), compact_space â†¥(F.obj j)] [âˆ€ (j : J), t2_space â†¥(F.obj j)] : nonempty â†¥((Top.limit_cone F).X)
theorem is_add_right_regular.of_add {R : Type u_1} {a b : R} [add_semigroup R] (ab : is_add_right_regular (b + a)) : is_add_right_regular b
theorem dense.prod {Î± : Type u} {Î² : Type v} [topological_space Î±] [topological_space Î²] {s : set Î±} {t : set Î²} (hs : dense s) (ht : dense t) : dense (s Ã—Ë¢ t)
theorem set_has_minimal_iff_artinian {R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] : (âˆ€ (a : set (submodule R M)), a.nonempty â†’ (âˆƒ (M' : submodule R M) (H : M' âˆˆ a), âˆ€ (I : submodule R M), I âˆˆ a â†’ I â‰¤ M' â†’ I = M')) â†” is_artinian R M
theorem measure_theory.measure.is_haar_measure_map {G : Type u_1} [measurable_space G] [group G] [topological_space G] (Î¼ : measure_theory.measure G) [Î¼.is_haar_measure] [borel_space G] [topological_group G] {H : Type u_2} [group H] [topological_space H] [measurable_space H] [borel_space H] [t2_space H] [topological_group H] (f : G â‰ƒ* H) (hf : continuous â‡‘f) (hfsymm : continuous â‡‘(f.symm)) : (measure_theory.measure.map â‡‘f Î¼).is_haar_measure
theorem polynomial.is_primitive.irreducible_iff_irreducible_map_fraction_map {R : Type u_1} [comm_ring R] [is_domain R] [normalized_gcd_monoid R] {K : Type u_2} [field K] [algebra R K] [is_fraction_ring R K] {p : polynomial R} (hp : p.is_primitive) : irreducible p â†” irreducible (polynomial.map (algebra_map R K) p)
theorem topological_fiber_bundle_core.continuous_total_space_mk {Î¹ : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core Î¹ B F) (b : B) : continuous (bundle.total_space_mk b)
theorem is_compact.finite_cover_balls {Î± : Type u} [pseudo_metric_space Î±] {s : set Î±} (hs : is_compact s) {e : â„} (he : 0 < e) : âˆƒ (t : set Î±) (H : t âŠ† s), t.finite âˆ§ s âŠ† â‹ƒ (x : Î±) (H : x âˆˆ t), metric.ball x e
theorem submodule.pow_induction_on_right {R : Type u} [comm_semiring R] {A : Type v} [semiring A] [algebra R A] (M : submodule R A) {C : A â†’ Prop} (hr : âˆ€ (r : R), C (â‡‘(algebra_map R A) r)) (hadd : âˆ€ (x y : A), C x â†’ C y â†’ C (x + y)) (hmul : âˆ€ (x : A), C x â†’ âˆ€ (m : A), m âˆˆ M â†’ C (x * m)) {x : A} {n : â„•} (hx : x âˆˆ M ^ n) : C x
theorem smooth_bump_function.smooth_smul {E : Type uE} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] {H : Type uH} [topological_space H] {I : model_with_corners â„ E H} {M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {c : M} (f : smooth_bump_function I c) [t2_space M] [smooth_manifold_with_corners I M] {G : Type u_1} [normed_group G] [normed_space â„ G] {g : M â†’ G} (hg : smooth_on I (model_with_corners_self â„ G) g (charted_space.chart_at H c).to_local_equiv.source) : smooth I (model_with_corners_self â„ G) (Î» (x : M), â‡‘f x â€¢ g x)
theorem Top.presheaf.app_surjective_of_injective_of_locally_surjective {C : Type u} [category_theory.category C] [category_theory.limits.has_colimits C] {X : Top} [category_theory.concrete_category C] [category_theory.limits.preserves_filtered_colimits (category_theory.forget C)] [category_theory.limits.has_limits C] [category_theory.limits.preserves_limits (category_theory.forget C)] [category_theory.reflects_isomorphisms (category_theory.forget C)] {F G : Top.sheaf C X} (f : F âŸ¶ G) (U : topological_space.opens â†¥X) (hinj : âˆ€ (x : â†¥U), function.injective â‡‘((Top.presheaf.stalk_functor C x.val).map f)) (hsurj : âˆ€ (t : â†¥(G.val.obj (opposite.op U))) (x : â†¥U), âˆƒ (V : topological_space.opens â†¥X) (m : x.val âˆˆ V) (iVU : V âŸ¶ U) (s : â†¥(F.val.obj (opposite.op V))), â‡‘(f.app (opposite.op V)) s = â‡‘(G.val.map iVU.op) t) : function.surjective â‡‘(f.app (opposite.op U))
theorem free_algebra.hom_ext {R : Type u_1} [comm_semiring R] {X : Type u_2} {A : Type u_3} [semiring A] [algebra R A] {f g : free_algebra R X â†’â‚[R] A} (w : â‡‘f âˆ˜ free_algebra.Î¹ R = â‡‘g âˆ˜ free_algebra.Î¹ R) : f = g
theorem int.exists_strict_mono (Î± : Type u) [preorder Î±] [nonempty Î±] [no_min_order Î±] [no_max_order Î±] : âˆƒ (f : â„¤ â†’ Î±), strict_mono f
theorem clifford_algebra.reverse_involute_commute {R : Type u_1} [comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {Q : quadratic_form R M} : function.commute â‡‘clifford_algebra.reverse â‡‘clifford_algebra.involute
theorem emetric.Hausdorff_edist_image {Î± : Type u} {Î² : Type v} [pseudo_emetric_space Î±] [pseudo_emetric_space Î²] {s t : set Î±} {Î¦ : Î± â†’ Î²} (h : isometry Î¦) : emetric.Hausdorff_edist (Î¦ '' s) (Î¦ '' t) = emetric.Hausdorff_edist s t
theorem basis.det_is_unit_smul {R : Type u_1} [comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {Î¹ : Type u_4} [decidable_eq Î¹] [fintype Î¹] (e : basis Î¹ R M) {w : Î¹ â†’ R} (hw : âˆ€ (i : Î¹), is_unit (w i)) : â‡‘(e.det) â‡‘(e.is_unit_smul hw) = finset.univ.prod (Î» (i : Î¹), w i)
theorem measure_theory.integral_add_left_eq_self {G : Type u_4} {E : Type u_5} [measurable_space G] [normed_group E] [normed_space â„ E] [complete_space E] {Î¼ : measure_theory.measure G} [add_group G] [has_measurable_add G] [Î¼.is_add_left_invariant] (f : G â†’ E) (g : G) : âˆ« (x : G), f (g + x) âˆ‚Î¼ = âˆ« (x : G), f x âˆ‚Î¼
theorem formal_multilinear_series.norm_mul_pow_le_of_lt_radius {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field ğ•œ] [normed_group E] [normed_space ğ•œ E] [normed_group F] [normed_space ğ•œ F] (p : formal_multilinear_series ğ•œ E F) {r : nnreal} (h : â†‘r < p.radius) : âˆƒ (C : â„) (H : C > 0), âˆ€ (n : â„•), âˆ¥p nâˆ¥ * â†‘r ^ n â‰¤ C
theorem module.End.generalized_eigenspace_le_generalized_eigenspace_finrank {K : Type v} {V : Type w} [field K] [add_comm_group V] [module K V] [finite_dimensional K V] (f : module.End K V) (Î¼ : K) (k : â„•) : â‡‘(f.generalized_eigenspace Î¼) k â‰¤ â‡‘(f.generalized_eigenspace Î¼) (finite_dimensional.finrank K V)
theorem monoid_hom.map_div {Î± : Type u_1} {Î² : Type u_2} [group Î±] [division_monoid Î²] (f : Î± â†’* Î²) (g h : Î±) : â‡‘f (g / h) = â‡‘f g / â‡‘f h
theorem monotone.map_is_least {Î± : Type u} {Î² : Type v} [preorder Î±] [preorder Î²] {f : Î± â†’ Î²} (Hf : monotone f) {a : Î±} {s : set Î±} (Ha : is_least s a) : is_least (f '' s) (f a)
theorem nonempty.map {Î± : Sort u_1} {Î² : Sort u_2} (f : Î± â†’ Î²) : nonempty Î± â†’ nonempty Î²
theorem measure_theory.map_prod_inv_mul_eq_swap {G : Type u_1} [measurable_space G] [group G] [has_measurable_mulâ‚‚ G] (Î¼ Î½ : measure_theory.measure G) [measure_theory.sigma_finite Î½] [measure_theory.sigma_finite Î¼] [has_measurable_inv G] [Î¼.is_mul_left_invariant] : measure_theory.measure.map (Î» (z : G Ã— G), (z.snd, (z.snd)â»Â¹ * z.fst)) (Î¼.prod Î½) = Î½.prod Î¼
theorem category_theory.limits.has_colimits_of_shape_of_equivalence {J : Type uâ‚} [category_theory.category J] {C : Type u} [category_theory.category C] {J' : Type uâ‚‚} [category_theory.category J'] (e : J â‰Œ J') [category_theory.limits.has_colimits_of_shape J C] : category_theory.limits.has_colimits_of_shape J' C
theorem is_cyclotomic_extension.discr_prime_pow {p : â„•+} {k : â„•} {K : Type u} {L : Type v} {Î¶ : L} [field K] [field L] [algebra K L] [hcycl : is_cyclotomic_extension {p ^ k} K L] [hp : fact (nat.prime â†‘p)] [ne_zero â†‘â†‘p] (hÎ¶ : is_primitive_root Î¶ â†‘(p ^ k)) (hirr : irreducible (polynomial.cyclotomic â†‘(p ^ k) K)) : algebra.discr K â‡‘((is_primitive_root.power_basis K hÎ¶).basis) = (-1) ^ ((â†‘p ^ k).totient / 2) * â†‘p ^ (â†‘p ^ (k - 1) * ((â†‘p - 1) * k - 1))
theorem cardinal.increasing_cantor_function {c : â„} (h1 : 0 < c) (h2 : c < 1 / 2) {n : â„•} {f g : â„• â†’ bool} (hn : âˆ€ (k : â„•), k < n â†’ f k = g k) (fn : f n = bool.ff) (gn : g n = bool.tt) : cardinal.cantor_function c f < cardinal.cantor_function c g
theorem right_deriv_measurable_aux.D_subset_differentiable_set {F : Type u_1} [normed_group F] [normed_space â„ F] {f : â„ â†’ F} {K : set F} (hK : is_complete K) : right_deriv_measurable_aux.D f K âŠ† {x : â„ | differentiable_within_at â„ f (set.Ici x) x âˆ§ deriv_within f (set.Ici x) x âˆˆ K}
theorem nat.of_digits_lt_base_pow_length {b : â„•} {l : list â„•} (hb : 2 â‰¤ b) (hl : âˆ€ (x : â„•), x âˆˆ l â†’ x < b) : nat.of_digits b l < b ^ l.length
theorem second_derivative_symmetric_of_eventually {E : Type u_1} {F : Type u_2} [normed_group E] [normed_space â„ E] [normed_group F] [normed_space â„ F] {x : E} {f : E â†’ F} {f' : E â†’ (E â†’L[â„] F)} {f'' : E â†’L[â„] E â†’L[â„] F} (hf : âˆ€á¶  (y : E) in nhds x, has_fderiv_at f (f' y) y) (hx : has_fderiv_at f' f'' x) (v w : E) : â‡‘(â‡‘f'' v) w = â‡‘(â‡‘f'' w) v
theorem is_group_hom.mk' {Î± : Type u} {Î² : Type v} [group Î±] [group Î²] {f : Î± â†’ Î²} (hf : âˆ€ (x y : Î±), f (x * y) = f x * f y) : is_group_hom f
theorem category_theory.cosimplicial_object.Î´_comp_Î´ {C : Type u} [category_theory.category C] (X : category_theory.cosimplicial_object C) {n : â„•} {i j : fin (n + 2)} (H : i â‰¤ j) : X.Î´ i â‰« X.Î´ j.succ = X.Î´ j â‰« X.Î´ (â‡‘fin.cast_succ i)
theorem map_le_line_map_iff_slope_le_slope_left {k : Type u_1} {E : Type u_2} [linear_ordered_field k] [ordered_add_comm_group E] [module k E] [ordered_smul k E] {f : k â†’ E} {a b r : k} (h : 0 < r * (b - a)) : f (â‡‘(affine_map.line_map a b) r) â‰¤ â‡‘(affine_map.line_map (f a) (f b)) r â†” slope f a (â‡‘(affine_map.line_map a b) r) â‰¤ slope f a b
theorem strict_anti_of_deriv_neg {f : â„ â†’ â„} (hf' : âˆ€ (x : â„), deriv f x < 0) : strict_anti f
theorem measure_theory.integral_prod {Î± : Type u_1} {Î² : Type u_3} {E : Type u_6} [measurable_space Î±] [measurable_space Î²] {Î¼ : measure_theory.measure Î±} {Î½ : measure_theory.measure Î²} [normed_group E] [measure_theory.sigma_finite Î½] [normed_space â„ E] [complete_space E] [measure_theory.sigma_finite Î¼] (f : Î± Ã— Î² â†’ E) (hf : measure_theory.integrable f (Î¼.prod Î½)) : âˆ« (z : Î± Ã— Î²), f z âˆ‚Î¼.prod Î½ = âˆ« (x : Î±), âˆ« (y : Î²), f (x, y) âˆ‚Î½ âˆ‚Î¼
theorem measure_theory.strongly_measurable.strongly_measurable_of_measurable_space_le_on {Î± : Type u_1} {E : Type u_2} {m mâ‚‚ : measurable_space Î±} [topological_space E] [has_zero E] {s : set Î±} {f : Î± â†’ E} (hs_m : measurable_set s) (hs : âˆ€ (t : set Î±), measurable_set (s âˆ© t) â†’ measurable_set (s âˆ© t)) (hf : measure_theory.strongly_measurable f) (hf_zero : âˆ€ (x : Î±), x âˆ‰ s â†’ f x = 0) : measure_theory.strongly_measurable f
theorem strict_mono_of_deriv_pos {f : â„ â†’ â„} (hf' : âˆ€ (x : â„), 0 < deriv f x) : strict_mono f
theorem submodule.pow_induction_on_left {R : Type u} [comm_semiring R] {A : Type v} [semiring A] [algebra R A] (M : submodule R A) {C : A â†’ Prop} (hr : âˆ€ (r : R), C (â‡‘(algebra_map R A) r)) (hadd : âˆ€ (x y : A), C x â†’ C y â†’ C (x + y)) (hmul : âˆ€ (m : A), m âˆˆ M â†’ âˆ€ (x : A), C x â†’ C (m * x)) {x : A} {n : â„•} (hx : x âˆˆ M ^ n) : C x
theorem finsum_mem_eq_of_bij_on {Î± : Type u_1} {Î² : Type u_2} {M : Type u_5} [add_comm_monoid M] {s : set Î±} {t : set Î²} {f : Î± â†’ M} {g : Î² â†’ M} (e : Î± â†’ Î²) (heâ‚€ : set.bij_on e s t) (heâ‚ : âˆ€ (x : Î±), x âˆˆ s â†’ f x = g (e x)) : finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), f i)) = finsum (Î» (j : Î²), finsum (Î» (H : j âˆˆ t), g j))
theorem category_theory.functor.ess_image_eq_of_nat_iso {C : Type uâ‚} {D : Type uâ‚‚} [category_theory.category C] [category_theory.category D] {F F' : C â¥¤ D} (h : F â‰… F') : F.ess_image = F'.ess_image
theorem cont_diff_within_at.comp' {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {G : Type u_4} [normed_group G] [normed_space ğ•œ G] {n : with_top â„•} {s : set E} {t : set F} {g : F â†’ G} {f : E â†’ F} (x : E) (hg : cont_diff_within_at ğ•œ n g t (f x)) (hf : cont_diff_within_at ğ•œ n f s x) : cont_diff_within_at ğ•œ n (g âˆ˜ f) (s âˆ© f â»Â¹' t) x
theorem edist_le_of_edist_le_geometric_of_tendstoâ‚€ {Î± : Type u_1} [pseudo_emetric_space Î±] (r C : ennreal) {f : â„• â†’ Î±} (hu : âˆ€ (n : â„•), has_edist.edist (f n) (f (n + 1)) â‰¤ C * r ^ n) {a : Î±} (ha : filter.tendsto f filter.at_top (nhds a)) : has_edist.edist (f 0) a â‰¤ C / (1 - r)
theorem measure_theory.measure.ext_of_bUnion_eq_univ {Î± : Type u_1} {Î¹ : Type u_5} {m0 : measurable_space Î±} {Î¼ Î½ : measure_theory.measure Î±} {S : set Î¹} {s : Î¹ â†’ set Î±} (hc : S.countable) (hs : (â‹ƒ (i : Î¹) (H : i âˆˆ S), s i) = set.univ) : (âˆ€ (i : Î¹), i âˆˆ S â†’ Î¼.restrict (s i) = Î½.restrict (s i)) â†’ Î¼ = Î½
theorem summable.map_iff_of_equiv {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [add_comm_monoid Î±] [topological_space Î±] {f : Î² â†’ Î±} [add_comm_monoid Î³] [topological_space Î³] {G : Type u_4} [add_equiv_class G Î± Î³] (g : G) (hg : continuous â‡‘g) (hg' : continuous (add_equiv_class.inv g)) : summable (â‡‘g âˆ˜ f) â†” summable f
theorem add_semiconj_by.conj_mk {G : Type u} [add_group G] (a x : G) : add_semiconj_by a x (a + x + -a)
theorem fin.sum_univ_zero {Î² : Type u_2} [add_comm_monoid Î²] (f : fin 0 â†’ Î²) : finset.univ.sum (Î» (i : fin 0), f i) = 0
theorem vector_span_eq_span_vsub_set_left (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : set P} {p : P} (hp : p âˆˆ s) : vector_span k s = submodule.span k (has_vsub.vsub p '' s)
theorem continuous_map.continuous_uncurry_of_continuous {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [topological_space Î±] [topological_space Î²] [topological_space Î³] [locally_compact_space Î²] (f : C(Î±, C(Î², Î³))) : continuous (function.uncurry (Î» (x : Î±) (y : Î²), â‡‘(â‡‘f x) y))
theorem interval_integral.measure_integral_sub_integral_sub_linear_is_o_of_tendsto_ae_left {Î¹ : Type u_1} {E : Type u_3} [normed_group E] [complete_space E] [normed_space â„ E] {f : â„ â†’ E} {a b : â„} {c : E} {la la' : filter â„} {lt : filter Î¹} {Î¼ : measure_theory.measure â„} {u v : Î¹ â†’ â„} [interval_integral.FTC_filter a la la'] [measure_theory.is_locally_finite_measure Î¼] (hab : interval_integrable f Î¼ a b) (hmeas : strongly_measurable_at_filter f la' Î¼) (hf : filter.tendsto f (la' âŠ“ Î¼.ae) (nhds c)) (hu : filter.tendsto u lt la) (hv : filter.tendsto v lt la) : (Î» (t : Î¹), âˆ« (x : â„) in v t..b, f x âˆ‚Î¼ - âˆ« (x : â„) in u t..b, f x âˆ‚Î¼ + âˆ« (x : â„) in u t..v t, c âˆ‚Î¼) =o[lt] Î» (t : Î¹), âˆ« (x : â„) in u t..v t, 1 âˆ‚Î¼
theorem turing.partrec_to_TM2.tr_supports (c : turing.to_partrec.code) (k : turing.partrec_to_TM2.cont') : turing.TM2.supports turing.partrec_to_TM2.tr (turing.partrec_to_TM2.code_supp c k)
theorem clifford_algebra.even_induction {R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] (Q : quadratic_form R M) {P : Î  (x : clifford_algebra Q), x âˆˆ clifford_algebra.even_odd Q 0 â†’ Prop} (hr : âˆ€ (r : R), P (â‡‘(algebra_map R (clifford_algebra Q)) r) _) (hadd : âˆ€ {x y : clifford_algebra Q} {hx : x âˆˆ clifford_algebra.even_odd Q 0} {hy : y âˆˆ clifford_algebra.even_odd Q 0}, P x hx â†’ P y hy â†’ P (x + y) _) (hÎ¹Î¹_mul : âˆ€ (mâ‚ mâ‚‚ : M) {x : clifford_algebra Q} {hx : x âˆˆ clifford_algebra.even_odd Q 0}, P x hx â†’ P (â‡‘(clifford_algebra.Î¹ Q) mâ‚ * â‡‘(clifford_algebra.Î¹ Q) mâ‚‚ * x) _) (x : clifford_algebra Q) (hx : x âˆˆ clifford_algebra.even_odd Q 0) : P x hx
theorem apply_dite2 {Î± : Sort u_1} {Î² : Sort u_2} {Î³ : Sort u_3} (f : Î± â†’ Î² â†’ Î³) (P : Prop) [decidable P] (a : P â†’ Î±) (b : Â¬P â†’ Î±) (c : P â†’ Î²) (d : Â¬P â†’ Î²) : f (dite P a b) (dite P c d) = dite P (Î» (h : P), f (a h) (c h)) (Î» (h : Â¬P), f (b h) (d h))
theorem covby.of_dual {Î± : Type u_1} [has_lt Î±] {a b : Î±áµ’áµˆ} : b â‹– a â†’ â‡‘order_dual.of_dual a â‹– â‡‘order_dual.of_dual b
theorem mem_nhds_iff_exists_Ioo_subset' {Î± : Type u} [topological_space Î±] [linear_order Î±] [order_topology Î±] {a : Î±} {s : set Î±} (hl : âˆƒ (l : Î±), l < a) (hu : âˆƒ (u : Î±), a < u) : s âˆˆ nhds a â†” âˆƒ (l u : Î±), a âˆˆ set.Ioo l u âˆ§ set.Ioo l u âŠ† s
theorem add_semiconj_by.add_right {S : Type u} [add_semigroup S] {a x y x' y' : S} (h : add_semiconj_by a x y) (h' : add_semiconj_by a x' y') : add_semiconj_by a (x + x') (y + y')
theorem isometry.comp {Î± : Type u} {Î² : Type v} {Î³ : Type w} [pseudo_emetric_space Î±] [pseudo_emetric_space Î²] [pseudo_emetric_space Î³] {g : Î² â†’ Î³} {f : Î± â†’ Î²} (hg : isometry g) (hf : isometry f) : isometry (g âˆ˜ f)
theorem inf_Sup_eq_of_directed_on {Î± : Type u_1} [complete_lattice Î±] [is_compactly_generated Î±] {a : Î±} {s : set Î±} (h : directed_on has_le.le s) : a âŠ“ has_Sup.Sup s = â¨† (b : Î±) (H : b âˆˆ s), a âŠ“ b
theorem interval_integral.continuous_on_primitive_interval' {E : Type u_3} [normed_group E] [complete_space E] [normed_space â„ E] {a bâ‚ bâ‚‚ : â„} {Î¼ : measure_theory.measure â„} {f : â„ â†’ E} [measure_theory.has_no_atoms Î¼] (h_int : interval_integrable f Î¼ bâ‚ bâ‚‚) (ha : a âˆˆ set.interval bâ‚ bâ‚‚) : continuous_on (Î» (b : â„), âˆ« (x : â„) in a..b, f x âˆ‚Î¼) (set.interval bâ‚ bâ‚‚)
theorem connected_component_subset_Inter_clopen {Î± : Type u} [topological_space Î±] {x : Î±} : connected_component x âŠ† â‹‚ (Z : {Z // is_clopen Z âˆ§ x âˆˆ Z}), â†‘Z
theorem rel_iso.coe_fn_injective {Î± : Type u_1} {Î² : Type u_2} {r : Î± â†’ Î± â†’ Prop} {s : Î² â†’ Î² â†’ Prop} : function.injective coe_fn
theorem loc_compact_t2_tot_disc_iff_tot_sep {H : Type u_1} [topological_space H] [locally_compact_space H] [t2_space H] : totally_disconnected_space H â†” totally_separated_space H
theorem equiv.point_reflection_fixed_iff_of_injective_bit0 {G : Type u_1} {P : Type u_2} [add_group G] [add_torsor G P] {x y : P} (h : function.injective bit0) : â‡‘(equiv.point_reflection x) y = y â†” y = x
theorem orthonormal.comp_linear_isometry {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {Î¹ : Type u_4} {E' : Type u_7} [inner_product_space ğ•œ E'] {v : Î¹ â†’ E} (hv : orthonormal ğ•œ v) (f : E â†’â‚—áµ¢[ğ•œ] E') : orthonormal ğ•œ (â‡‘f âˆ˜ v)
theorem measure_theory.measure.restrict_apply {Î± : Type u_1} {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {s t : set Î±} (ht : measurable_set t) : â‡‘(Î¼.restrict s) t = â‡‘Î¼ (t âˆ© s)
theorem category_theory.grothendieck_topology.ext {C : Type u} [category_theory.category C] {Jâ‚ Jâ‚‚ : category_theory.grothendieck_topology C} (h : â‡‘Jâ‚ = â‡‘Jâ‚‚) : Jâ‚ = Jâ‚‚
theorem measure_theory.measure.ext_iff_of_Union_eq_univ {Î± : Type u_1} {Î¹ : Type u_5} {m0 : measurable_space Î±} {Î¼ Î½ : measure_theory.measure Î±} [encodable Î¹] {s : Î¹ â†’ set Î±} (hs : (â‹ƒ (i : Î¹), s i) = set.univ) : Î¼ = Î½ â†” âˆ€ (i : Î¹), Î¼.restrict (s i) = Î½.restrict (s i)
theorem is_ring_hom.to_is_semiring_hom {Î± : Type u} {Î² : Type v} [ring Î±] [ring Î²] {f : Î± â†’ Î²} (hf : is_ring_hom f) : is_semiring_hom f
theorem has_le.le.of_dual {Î± : Type u_1} [has_le Î±] {a b : Î±áµ’áµˆ} : b â‰¤ a â†’ â‡‘order_dual.of_dual a â‰¤ â‡‘order_dual.of_dual b
theorem orientation.exists_linear_isometry_equiv_eq_of_det_pos {V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) {f : V â‰ƒâ‚—áµ¢[â„] V} (hd : 0 < â‡‘linear_map.det â†‘(f.to_linear_equiv)) : âˆƒ (Î¸ : real.angle), f = o.rotation Î¸
theorem pgame.zero_le_lf {x : pgame} : 0 â‰¤ x â†” âˆ€ (j : x.right_moves), 0.lf (x.move_right j)
theorem inner_product_geometry.norm_sub_sq_eq_norm_sq_add_norm_sq' {V : Type u_1} [inner_product_space â„ V] (x y : V) (h : inner_product_geometry.angle x y = real.pi / 2) : âˆ¥x - yâˆ¥ * âˆ¥x - yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + âˆ¥yâˆ¥ * âˆ¥yâˆ¥
theorem discrete_valuation_ring.iff_pid_with_one_nonzero_prime (R : Type u) [comm_ring R] [is_domain R] : discrete_valuation_ring R â†” is_principal_ideal_ring R âˆ§ âˆƒ! (P : ideal R), P â‰  âŠ¥ âˆ§ P.is_prime
theorem is_glb.union {Î³ : Type w} [semilattice_inf Î³] {aâ‚ aâ‚‚ : Î³} {s t : set Î³} (hs : is_glb s aâ‚) (ht : is_glb t aâ‚‚) : is_glb (s âˆª t) (aâ‚ âŠ“ aâ‚‚)
theorem has_fderiv_at.comp {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {G : Type u_4} [normed_group G] [normed_space ğ•œ G] {f : E â†’ F} {f' : E â†’L[ğ•œ] F} (x : E) {g : F â†’ G} {g' : F â†’L[ğ•œ] G} (hg : has_fderiv_at g g' (f x)) (hf : has_fderiv_at f f' x) : has_fderiv_at (g âˆ˜ f) (g'.comp f') x
theorem one_hom.comp_assoc {M : Type u_3} {N : Type u_4} {P : Type u_5} {Q : Type u_1} [has_one M] [has_one N] [has_one P] [has_one Q] (f : one_hom M N) (g : one_hom N P) (h : one_hom P Q) : (h.comp g).comp f = h.comp (g.comp f)
theorem category_theory.limits.is_terminal.hom_ext {C : Type uâ‚} [category_theory.category C] {X Y : C} (t : category_theory.limits.is_terminal X) (f g : Y âŸ¶ X) : f = g
theorem exists_subset_Union_closed_subset {Î¹ : Type u_1} {X : Type u_2} [topological_space X] [normal_space X] {u : Î¹ â†’ set X} {s : set X} (hs : is_closed s) (uo : âˆ€ (i : Î¹), is_open (u i)) (uf : âˆ€ (x : X), x âˆˆ s â†’ {i : Î¹ | x âˆˆ u i}.finite) (us : s âŠ† â‹ƒ (i : Î¹), u i) : âˆƒ (v : Î¹ â†’ set X), s âŠ† set.Union v âˆ§ (âˆ€ (i : Î¹), is_closed (v i)) âˆ§ âˆ€ (i : Î¹), v i âŠ† u i
theorem measure_theory.measure.le_of_add_le_add_left {Î± : Type u_1} {m0 : measurable_space Î±} {Î¼ Î½â‚ Î½â‚‚ : measure_theory.measure Î±} [measure_theory.is_finite_measure Î¼] (A2 : Î¼ + Î½â‚ â‰¤ Î¼ + Î½â‚‚) : Î½â‚ â‰¤ Î½â‚‚
theorem rat.uniform_space_eq  : is_absolute_value.uniform_space has_abs.abs = pseudo_metric_space.to_uniform_space
theorem dense.exists_countable_dense_subset_bot_top {Î± : Type u_1} [topological_space Î±] [partial_order Î±] {s : set Î±} [topological_space.separable_space â†¥s] (hs : dense s) : âˆƒ (t : set Î±) (H : t âŠ† s), t.countable âˆ§ dense t âˆ§ (âˆ€ (x : Î±), is_bot x â†’ x âˆˆ s â†’ x âˆˆ t) âˆ§ âˆ€ (x : Î±), is_top x â†’ x âˆˆ s â†’ x âˆˆ t
theorem measure_theory.simple_func.map_lintegral {Î± : Type u_1} {Î² : Type u_2} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (g : Î² â†’ ennreal) (f : measure_theory.simple_func Î± Î²) : (measure_theory.simple_func.map g f).lintegral Î¼ = f.range.sum (Î» (x : Î²), g x * â‡‘Î¼ (â‡‘f â»Â¹' {x}))
theorem has_ssubset.ssubset.subset {Î± : Type u} [has_subset Î±] [has_ssubset Î±] [is_nonstrict_strict_order Î± has_subset.subset has_ssubset.ssubset] {a b : Î±} (h : a âŠ‚ b) : a âŠ† b
theorem category_theory.limits.is_limit.hom_is_iso {J : Type uâ‚} [category_theory.category J] {C : Type uâ‚ƒ} [category_theory.category C] {F : J â¥¤ C} {s t : category_theory.limits.cone F} (P : category_theory.limits.is_limit s) (Q : category_theory.limits.is_limit t) (f : s âŸ¶ t) : category_theory.is_iso f
theorem convex_on_pow (n : â„•) : convex_on â„ (set.Ici 0) (Î» (x : â„), x ^ n)
theorem continuous_linear_map.unit_le_op_norm {ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_normed_group E] [semi_normed_group F] [nondiscrete_normed_field ğ•œ] [nondiscrete_normed_field ğ•œâ‚‚] [normed_space ğ•œ E] [normed_space ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} [ring_hom_isometric Ïƒâ‚â‚‚] (f : E â†’SL[Ïƒâ‚â‚‚] F) (x : E) : âˆ¥xâˆ¥ â‰¤ 1 â†’ âˆ¥â‡‘f xâˆ¥ â‰¤ âˆ¥fâˆ¥
theorem open_map_of_strict_fderiv_equiv {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] [complete_space E] {f : E â†’ F} {f' : E â†’ (E â‰ƒL[ğ•œ] F)} (hf : âˆ€ (x : E), has_strict_fderiv_at f â†‘(f' x) x) : is_open_map f
theorem category_theory.limits.pullback_cone.equalizer_ext {C : Type u} [category_theory.category C] {X Y Z : C} {f : X âŸ¶ Z} {g : Y âŸ¶ Z} (t : category_theory.limits.pullback_cone f g) {W : C} {k l : W âŸ¶ t.X} (hâ‚€ : k â‰« t.fst = l â‰« t.fst) (hâ‚ : k â‰« t.snd = l â‰« t.snd) (j : category_theory.limits.walking_cospan) : k â‰« t.Ï€.app j = l â‰« t.Ï€.app j
theorem category_theory.InjectiveResolution.desc_commutes {C : Type u} [category_theory.category C] [category_theory.abelian C] {Y Z : C} (f : Z âŸ¶ Y) (I : category_theory.InjectiveResolution Y) (J : category_theory.InjectiveResolution Z) : J.Î¹ â‰« category_theory.InjectiveResolution.desc f I J = (cochain_complex.singleâ‚€ C).map f â‰« I.Î¹
theorem euclidean_geometry.exists_circumradius_eq_of_cospherical {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {ps : set P} {n : â„•} [finite_dimensional â„ V] (hd : finite_dimensional.finrank â„ V = n) (hc : euclidean_geometry.cospherical ps) : âˆƒ (r : â„), âˆ€ (sx : affine.simplex â„ P n), set.range sx.points âŠ† ps â†’ sx.circumradius = r
theorem minpoly.aeval_ne_zero_of_dvd_not_unit_minpoly {A : Type u_1} {B : Type u_2} [comm_ring A] [is_domain A] [ring B] [algebra A B] {x : B} {a : polynomial A} (hx : is_integral A x) (hamonic : a.monic) (hdvd : dvd_not_unit a (minpoly A x)) : â‡‘(polynomial.aeval x) a â‰  0
theorem clifford_algebra.induction {R : Type u_1} [comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {Q : quadratic_form R M} {C : clifford_algebra Q â†’ Prop} (h_grade0 : âˆ€ (r : R), C (â‡‘(algebra_map R (clifford_algebra Q)) r)) (h_grade1 : âˆ€ (x : M), C (â‡‘(clifford_algebra.Î¹ Q) x)) (h_mul : âˆ€ (a b : clifford_algebra Q), C a â†’ C b â†’ C (a * b)) (h_add : âˆ€ (a b : clifford_algebra Q), C a â†’ C b â†’ C (a + b)) (a : clifford_algebra Q) : C a
theorem nat_ordinal.induction {p : nat_ordinal â†’ Prop} (i : nat_ordinal) (h : âˆ€ (j : nat_ordinal), (âˆ€ (k : nat_ordinal), k < j â†’ p k) â†’ p j) : p i
theorem orientation.two_zsmul_oangle_smul_right_of_ne_zero {V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) (x y : V) {r : â„} (hr : r â‰  0) : 2 â€¢ o.oangle x (r â€¢ y) = 2 â€¢ o.oangle x y
theorem metric.bounded_singleton {Î± : Type u} [pseudo_metric_space Î±] {x : Î±} : metric.bounded {x}
theorem finprod_mem_union'' {Î± : Type u_1} {M : Type u_5} [comm_monoid M] {f : Î± â†’ M} {s t : set Î±} (hst : disjoint (s âˆ© function.mul_support f) (t âˆ© function.mul_support f)) (hs : (s âˆ© function.mul_support f).finite) (ht : (t âˆ© function.mul_support f).finite) : finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s âˆª t), f i)) = finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), f i)) * finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ t), f i))
theorem sq_add_sq_mul_sq_add_sq {R : Type u_1} [comm_ring R] {xâ‚ xâ‚‚ yâ‚ yâ‚‚ : R} : (xâ‚ ^ 2 + xâ‚‚ ^ 2) * (yâ‚ ^ 2 + yâ‚‚ ^ 2) = (xâ‚ * yâ‚ - xâ‚‚ * yâ‚‚) ^ 2 + (xâ‚ * yâ‚‚ + xâ‚‚ * yâ‚) ^ 2
theorem lipschitz_with.of_le_add_mul' {Î± : Type u} [pseudo_metric_space Î±] {f : Î± â†’ â„} (K : â„) (h : âˆ€ (x y : Î±), f x â‰¤ f y + K * has_dist.dist x y) : lipschitz_with K.to_nnreal f
theorem measure_theory.lintegral_infi_ae {Î± : Type u_1} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {f : â„• â†’ Î± â†’ ennreal} (h_meas : âˆ€ (n : â„•), measurable (f n)) (h_mono : âˆ€ (n : â„•), f n.succ â‰¤áµ[Î¼] f n) (h_fin : âˆ«â» (a : Î±), f 0 a âˆ‚Î¼ â‰  âŠ¤) : âˆ«â» (a : Î±), (â¨… (n : â„•), f n a) âˆ‚Î¼ = â¨… (n : â„•), âˆ«â» (a : Î±), f n a âˆ‚Î¼
theorem metric.tendsto_uniformly_on_iff {Î± : Type u} {Î² : Type v} [pseudo_metric_space Î±] {Î¹ : Type u_1} {F : Î¹ â†’ Î² â†’ Î±} {f : Î² â†’ Î±} {p : filter Î¹} {s : set Î²} : tendsto_uniformly_on F f p s â†” âˆ€ (Îµ : â„), Îµ > 0 â†’ (âˆ€á¶  (n : Î¹) in p, âˆ€ (x : Î²), x âˆˆ s â†’ has_dist.dist (f x) (F n x) < Îµ)
theorem lipschitz_with.hausdorff_measure_image_le {X : Type u_2} {Y : Type u_3} [emetric_space X] [emetric_space Y] [measurable_space X] [borel_space X] [measurable_space Y] [borel_space Y] {K : nnreal} {f : X â†’ Y} (h : lipschitz_with K f) {d : â„} (hd : 0 â‰¤ d) (s : set X) : â‡‘(measure_theory.measure.hausdorff_measure d) (f '' s) â‰¤ â†‘K ^ d * â‡‘(measure_theory.measure.hausdorff_measure d) s
theorem nat.filter_multiset_Ico_card_eq_of_periodic (n a : â„•) (p : â„• â†’ Prop) [decidable_pred p] (pp : function.periodic p a) : â‡‘multiset.card (multiset.filter p (multiset.Ico n (n + a))) = nat.count p a
theorem comp_mul_right {Î± : Type u_1} [semigroup Î±] (x y : Î±) : ((Î» (_x : Î±), _x * x) âˆ˜ Î» (_x : Î±), _x * y) = Î» (_x : Î±), _x * (y * x)
theorem category_theory.cover_dense.sheaf_hom_restrict_eq {C : Type u_1} [category_theory.category C] {D : Type u_3} [category_theory.category D] {K : category_theory.grothendieck_topology D} {A : Type u_7} [category_theory.category A] {G : C â¥¤ D} (H : category_theory.cover_dense K G) [category_theory.full G] {â„± : Dáµ’áµ– â¥¤ A} {â„±' : category_theory.Sheaf K A} (Î± : G.op â‹™ â„± âŸ¶ G.op â‹™ â„±'.val) : category_theory.whisker_left G.op (H.sheaf_hom Î±) = Î±
theorem nilpotent_of_surjective {G : Type u_1} [group G] {G' : Type u_2} [group G'] [h : group.is_nilpotent G] (f : G â†’* G') (hf : function.surjective â‡‘f) : group.is_nilpotent G'
theorem affine_isometry_equiv.vadd_vsub {ğ•œ : Type u_1} {V : Type u_2} {Vâ‚‚ : Type u_4} {P : Type u_8} {Pâ‚‚ : Type u_9} [normed_field ğ•œ] [semi_normed_group V] [semi_normed_group Vâ‚‚] [normed_space ğ•œ V] [normed_space ğ•œ Vâ‚‚] [pseudo_metric_space P] [pseudo_metric_space Pâ‚‚] [normed_add_torsor V P] [normed_add_torsor Vâ‚‚ Pâ‚‚] {f : P â†’ Pâ‚‚} (hf : isometry f) {p : P} {g : V â†’ Vâ‚‚} (hg : âˆ€ (v : V), g v = f (v +áµ¥ p) -áµ¥ f p) : isometry g
theorem finset.prod_le_one {Î¹ : Type u_1} {R : Type u_8} [ordered_comm_semiring R] {f : Î¹ â†’ R} {s : finset Î¹} (h0 : âˆ€ (i : Î¹), i âˆˆ s â†’ 0 â‰¤ f i) (h1 : âˆ€ (i : Î¹), i âˆˆ s â†’ f i â‰¤ 1) : s.prod (Î» (i : Î¹), f i) â‰¤ 1
theorem mem_extreme_points_iff_extreme_singleton {ğ•œ : Type u_1} {E : Type u_2} [ordered_semiring ğ•œ] [add_comm_monoid E] [has_scalar ğ•œ E] {A : set E} {x : E} : x âˆˆ set.extreme_points ğ•œ A â†” is_extreme ğ•œ A {x}
theorem orthonormal.oangle_rotation_oangle_right {V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) (x y : V) : hb.oangle y (â‡‘(hb.rotation (hb.oangle x y)) x) = 0
theorem measure_theory.mul_meas_ge_le_lintegral {Î± : Type u_1} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {f : Î± â†’ ennreal} (hf : measurable f) (Îµ : ennreal) : Îµ * â‡‘Î¼ {x : Î± | Îµ â‰¤ f x} â‰¤ âˆ«â» (a : Î±), f a âˆ‚Î¼
theorem bounded_continuous_function.exists_extension_forall_mem_Icc_of_closed_embedding {X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] [normal_space Y] (f : bounded_continuous_function X â„) {a b : â„} {e : X â†’ Y} (hf : âˆ€ (x : X), â‡‘f x âˆˆ set.Icc a b) (hle : a â‰¤ b) (he : closed_embedding e) : âˆƒ (g : bounded_continuous_function Y â„), (âˆ€ (y : Y), â‡‘g y âˆˆ set.Icc a b) âˆ§ â‡‘g âˆ˜ e = â‡‘f
theorem is_localization.smul_mem_finset_integer_multiple_span {R S : Type u} [comm_ring R] [comm_ring S] (M : submonoid R) (S' : Type u) [comm_ring S'] [algebra S S'] [algebra R S] [algebra R S'] [is_scalar_tower R S S'] [is_localization (submonoid.map â†‘(algebra_map R S) M) S'] (x : S) (s : finset S') (hx : â‡‘(algebra_map S S') x âˆˆ submodule.span R â†‘s) : âˆƒ (m : â†¥M), m â€¢ x âˆˆ submodule.span R â†‘(is_localization.finset_integer_multiple (submonoid.map â†‘(algebra_map R S) M) s)
theorem unique_diff_on.univ_pi {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] (Î¹ : Type u_2) [fintype Î¹] (E : Î¹ â†’ Type u_3) [Î  (i : Î¹), normed_group (E i)] [Î  (i : Î¹), normed_space ğ•œ (E i)] (s : Î  (i : Î¹), set (E i)) (h : âˆ€ (i : Î¹), unique_diff_on ğ•œ (s i)) : unique_diff_on ğ•œ (set.univ.pi s)
theorem complex.has_deriv_at_exp (x : â„‚) : has_deriv_at complex.exp (complex.exp x) x
theorem category_theory.functor.obj_mem_ess_image {C : Type uâ‚} {D : Type uâ‚‚} [category_theory.category C] [category_theory.category D] (F : D â¥¤ C) (Y : D) : F.obj Y âˆˆ F.ess_image
theorem orthonormal.oangle_zero_right {V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) (x : V) : hb.oangle x 0 = 0
theorem sylow.card_coprime_index {G : Type u} [group G] [fintype G] {p : â„•} [hp : fact (nat.prime p)] (P : sylow p G) : (fintype.card â†¥P).coprime â†‘P.index
theorem add_con.Sup_def {M : Type u_1} [has_add M] {S : set (add_con M)} : has_Sup.Sup S = add_con_gen (has_Sup.Sup (coe_fn '' S))
theorem finite_dimensional.finrank_zero_of_subsingleton {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [h : subsingleton V] : finite_dimensional.finrank K V = 0
theorem Top.presheaf.to_Types_is_sheaf (X : Top) (T : â†¥X â†’ Type u) : (X.presheaf_to_Types T).is_sheaf
theorem ring_hom.map_bit0 {Î± : Type u_2} {Î² : Type u_3} {rÎ± : non_assoc_semiring Î±} {rÎ² : non_assoc_semiring Î²} (f : Î± â†’+* Î²) (a : Î±) : â‡‘f (bit0 a) = bit0 (â‡‘f a)
theorem topological_space.second_countable_topology_of_countable_cover {Î± : Type u} [t : topological_space Î±] {Î¹ : Type u_1} [encodable Î¹] {U : Î¹ â†’ set Î±} [âˆ€ (i : Î¹), topological_space.second_countable_topology â†¥(U i)] (Uo : âˆ€ (i : Î¹), is_open (U i)) (hc : (â‹ƒ (i : Î¹), U i) = set.univ) : topological_space.second_countable_topology Î±
theorem is_cyclotomic_extension.finite (S : set â„•+) (A : Type u) (B : Type v) [comm_ring A] [comm_ring B] [algebra A B] [is_domain B] [hâ‚ : fintype â†¥S] [hâ‚‚ : is_cyclotomic_extension S A B] : module.finite A B
theorem nat.partrec.code.evaln_prim  : primrec (Î» (a : (â„• Ã— nat.partrec.code) Ã— â„•), nat.partrec.code.evaln a.fst.fst a.fst.snd a.snd)
theorem measure_theory.conservative.ae_forall_image_mem_imp_frequently_image_mem {Î± : Type u_2} [measurable_space Î±] {f : Î± â†’ Î±} {s : set Î±} {Î¼ : measure_theory.measure Î±} (hf : measure_theory.conservative f Î¼) (hs : measurable_set s) : âˆ€áµ (x : Î±) âˆ‚Î¼, âˆ€ (k : â„•), f^[k] x âˆˆ s â†’ (âˆƒá¶  (n : â„•) in filter.at_top, f^[n] x âˆˆ s)
theorem emetric.complete_of_convergent_controlled_sequences {Î± : Type u} [pseudo_emetric_space Î±] (B : â„• â†’ ennreal) (hB : âˆ€ (n : â„•), 0 < B n) (H : âˆ€ (u : â„• â†’ Î±), (âˆ€ (N n m : â„•), N â‰¤ n â†’ N â‰¤ m â†’ has_edist.edist (u n) (u m) < B N) â†’ (âˆƒ (x : Î±), filter.tendsto u filter.at_top (nhds x))) : complete_space Î±
theorem local_homeomorph.trans_self_symm {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] (e : local_homeomorph Î± Î²) : e.trans e.symm â‰ˆ local_homeomorph.of_set e.to_local_equiv.source _
theorem matrix.special_linear_group.coe_GL_pos_coe_GL_coe_matrix {n : Type u} [decidable_eq n] [fintype n] {R : Type v} [linear_ordered_comm_ring R] (g : matrix.special_linear_group n R) : â†‘â†‘â†‘g = â†‘g
theorem topological_vector_bundle.prod.inducing_diag {B : Type u_3} (Eâ‚ : B â†’ Type u_6) (Eâ‚‚ : B â†’ Type u_7) [topological_space (bundle.total_space Eâ‚)] [topological_space (bundle.total_space Eâ‚‚)] : inducing (Î» (p : bundle.total_space (Î» (x : B), Eâ‚ x Ã— Eâ‚‚ x)), (âŸ¨p.fst, p.snd.fstâŸ©, âŸ¨p.fst, p.snd.sndâŸ©))
theorem nat.totient_mul_prod_factors (n : â„•) : n.totient * n.factors.to_finset.prod (Î» (p : â„•), p) = n * n.factors.to_finset.prod (Î» (p : â„•), p - 1)
theorem is_closed.is_glb_mem {Î± : Type u} [topological_space Î±] [linear_order Î±] [order_topology Î±] {a : Î±} {s : set Î±} (ha : is_glb s a) (hs : s.nonempty) (sc : is_closed s) : a âˆˆ s
theorem algebraic_topology.dold_kan.map_hÏƒ' {C : Type u_1} [category_theory.category C] [category_theory.preadditive C] {D : Type u_3} [category_theory.category D] [category_theory.preadditive D] (G : C â¥¤ D) [G.additive] (X : category_theory.simplicial_object C) (q n m : â„•) (hnm : algebraic_topology.dold_kan.c.rel m n) : algebraic_topology.dold_kan.hÏƒ' q n m hnm = G.map (algebraic_topology.dold_kan.hÏƒ' q n m hnm)
theorem add_semiconj_by.reflexive {M : Type u} [add_zero_class M] : reflexive (Î» (a b : M), âˆƒ (c : M), add_semiconj_by c a b)
theorem right.add_pos' {Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±} (ha : 0 < a) (hb : 0 < b) : 0 < a + b
theorem category_theory.simplicial_object.Ïƒ_comp_Ïƒ {C : Type u} [category_theory.category C] (X : category_theory.simplicial_object C) {n : â„•} {i j : fin (n + 1)} (H : i â‰¤ j) : X.Ïƒ j â‰« X.Ïƒ (â‡‘fin.cast_succ i) = X.Ïƒ i â‰« X.Ïƒ j.succ
theorem ordinal.exists_fundamental_sequence (a : ordinal) : âˆƒ (f : Î  (b : ordinal), b < a.cof.ord â†’ ordinal), a.is_fundamental_sequence a.cof.ord f
theorem tendsto_locally_uniformly_on.tendsto_comp {Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_4} [uniform_space Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : set Î±} {x : Î±} {p : filter Î¹} {g : Î¹ â†’ Î±} [topological_space Î±] (h : tendsto_locally_uniformly_on F f p s) (hf : continuous_within_at f s x) (hx : x âˆˆ s) (hg : filter.tendsto g p (nhds_within x s)) : filter.tendsto (Î» (n : Î¹), F n (g n)) p (nhds (f x))
theorem finsum_add_distrib {Î± : Type u_1} {M : Type u_5} [add_comm_monoid M] {f g : Î± â†’ M} (hf : (function.support f).finite) (hg : (function.support g).finite) : finsum (Î» (i : Î±), f i + g i) = finsum (Î» (i : Î±), f i) + finsum (Î» (i : Î±), g i)
theorem is_o_zpow_exp_pos_mul_at_top (k : â„¤) {b : â„} (hb : 0 < b) : (Î» (x : â„), x ^ k) =o[filter.at_top] Î» (x : â„), real.exp (b * x)
theorem list.pairwise.pw_filter {Î± : Type u_1} {R : Î± â†’ Î± â†’ Prop} [decidable_rel R] {l : list Î±} : list.pairwise R l â†’ list.pw_filter R l = l
theorem list.comp_map {Î± : Type u} {Î² : Type v} {Î³ : Type w} (h : Î² â†’ Î³) (g : Î± â†’ Î²) (l : list Î±) : list.map (h âˆ˜ g) l = list.map h (list.map g l)
theorem add_con.sup_eq_add_con_gen {M : Type u_1} [has_add M] (c d : add_con M) : c âŠ” d = add_con_gen (Î» (x y : M), â‡‘c x y âˆ¨ â‡‘d x y)
theorem category_theory.sheaf.sheaf_for_finest_topology {C : Type u} [category_theory.category C] {P : Cáµ’áµ– â¥¤ Type v} (Ps : set (Cáµ’áµ– â¥¤ Type v)) (h : P âˆˆ Ps) : category_theory.presieve.is_sheaf (category_theory.sheaf.finest_topology Ps) P
theorem exp_neg_inv_glue.zero_of_nonpos {x : â„} (hx : x â‰¤ 0) : exp_neg_inv_glue x = 0
theorem category_theory.limits.has_products_opposite {C : Type uâ‚} [category_theory.category C] (X : Type vâ‚) [category_theory.limits.has_coproducts_of_shape X C] : category_theory.limits.has_products_of_shape X Cáµ’áµ–
theorem tsum_mul_tsum_eq_tsum_sum_range {Î± : Type u_1} {f g : â„• â†’ Î±} [topological_space Î±] [non_unital_non_assoc_semiring Î±] [regular_space Î±] [topological_semiring Î±] (hf : summable f) (hg : summable g) (hfg : summable (Î» (x : â„• Ã— â„•), f x.fst * g x.snd)) : (âˆ‘' (n : â„•), f n) * âˆ‘' (n : â„•), g n = âˆ‘' (n : â„•), (finset.range (n + 1)).sum (Î» (k : â„•), f k * g (n - k))
theorem cont_diff_top_iff_deriv {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {fâ‚‚ : ğ•œ â†’ F} : cont_diff ğ•œ âŠ¤ fâ‚‚ â†” differentiable ğ•œ fâ‚‚ âˆ§ cont_diff ğ•œ âŠ¤ (deriv fâ‚‚)
theorem subgroup.fg_of_index_ne_zero {G : Type u_1} [group G] {H : subgroup G} [hG : group.fg G] (hH : H.index â‰  0) : group.fg â†¥H
theorem closed_ball_pi {Î² : Type v} {Ï€ : Î² â†’ Type u_1} [fintype Î²] [Î  (b : Î²), pseudo_metric_space (Ï€ b)] (x : Î  (b : Î²), Ï€ b) {r : â„} (hr : 0 â‰¤ r) : metric.closed_ball x r = set.univ.pi (Î» (b : Î²), metric.closed_ball (x b) r)
theorem real.tendsto_prod_pi_div_two  : filter.tendsto (Î» (k : â„•), (finset.range k).prod (Î» (i : â„•), (2 * â†‘i + 2) / (2 * â†‘i + 1) * ((2 * â†‘i + 2) / (2 * â†‘i + 3)))) filter.at_top (nhds (real.pi / 2))
theorem cont_diff.comp_continuous_linear_map {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {G : Type u_4} [normed_group G] [normed_space ğ•œ G] {n : with_top â„•} {f : E â†’ F} {g : G â†’L[ğ•œ] E} (hf : cont_diff ğ•œ n f) : cont_diff ğ•œ n (f âˆ˜ â‡‘g)
theorem metric.cthickening_zero {Î± : Type u} [pseudo_emetric_space Î±] (E : set Î±) : metric.cthickening 0 E = closure E
theorem ordinal.enum_ord_def' {S : set ordinal} (o : ordinal) : ordinal.enum_ord S o = has_Inf.Inf (S âˆ© set.Ici (o.blsub (Î» (a : ordinal) (_x : a < o), ordinal.enum_ord S a)))
theorem quadratic_form.equivalent_one_zero_neg_one_weighted_sum_squared {M : Type u_1} [add_comm_group M] [module â„ M] [finite_dimensional â„ M] (Q : quadratic_form â„ M) : âˆƒ (w : fin (finite_dimensional.finrank â„ M) â†’ â„), (âˆ€ (i : fin (finite_dimensional.finrank â„ M)), w i = -1 âˆ¨ w i = 0 âˆ¨ w i = 1) âˆ§ Q.equivalent (quadratic_form.weighted_sum_squares â„ w)
theorem measure_theory.outer_measure.Inf_apply' {Î± : Type u_1} {m : set (measure_theory.outer_measure Î±)} {s : set Î±} (h : s.nonempty) : â‡‘(has_Inf.Inf m) s = â¨… (t : â„• â†’ set Î±) (h2 : s âŠ† set.Union t), âˆ‘' (n : â„•), â¨… (Î¼ : measure_theory.outer_measure Î±) (h3 : Î¼ âˆˆ m), â‡‘Î¼ (t n)
theorem real.subgroup_dense_of_no_min {G : add_subgroup â„} {gâ‚€ : â„} (gâ‚€_in : gâ‚€ âˆˆ G) (gâ‚€_ne : gâ‚€ â‰  0) (H' : Â¬âˆƒ (a : â„), is_least {g : â„ | g âˆˆ G âˆ§ 0 < g} a) : dense â†‘G
theorem ring.ne_bot_of_is_maximal_of_not_is_field {R : Type u_1} [comm_ring R] [nontrivial R] {M : ideal R} (max : M.is_maximal) (not_field : Â¬is_field R) : M â‰  âŠ¥
theorem multilinear_map.dom_coprod_alternization_eq {Î¹a : Type u_7} {Î¹b : Type u_8} [decidable_eq Î¹a] [decidable_eq Î¹b] [fintype Î¹a] [fintype Î¹b] {R' : Type u_9} {Máµ¢ : Type u_10} {Nâ‚ : Type u_11} {Nâ‚‚ : Type u_12} [comm_semiring R'] [add_comm_group Nâ‚] [module R' Nâ‚] [add_comm_group Nâ‚‚] [module R' Nâ‚‚] [add_comm_monoid Máµ¢] [module R' Máµ¢] (a : alternating_map R' Máµ¢ Nâ‚ Î¹a) (b : alternating_map R' Máµ¢ Nâ‚‚ Î¹b) : â‡‘multilinear_map.alternatization (â†‘a.dom_coprod â†‘b) = ((fintype.card Î¹a).factorial * (fintype.card Î¹b).factorial) â€¢ a.dom_coprod b
theorem category_theory.limits.biproduct.Î¹_Ï€ {J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [decidable_eq J] (f : J â†’ C) [category_theory.limits.has_biproduct f] (j j' : J) : category_theory.limits.biproduct.Î¹ f j â‰« category_theory.limits.biproduct.Ï€ f j' = dite (j = j') (Î» (h : j = j'), category_theory.eq_to_hom _) (Î» (h : Â¬j = j'), 0)
theorem polynomial.chebyshev.cos_nat_mul (n : â„•) (Î¸ : â„‚) : complex.cos (â†‘n * Î¸) = polynomial.eval (complex.cos Î¸) (polynomial.chebyshev.T â„‚ n)
theorem orientation.oangle_add_oangle_rev_neg_left {V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) (x y : V) : o.oangle (-x) y + o.oangle (-y) x = 0
theorem complex.abs_le_abs_of_maps_to_ball_self {f : â„‚ â†’ â„‚} {z : â„‚} {R : â„} (hd : differentiable_on â„‚ f (metric.ball 0 R)) (h_maps : set.maps_to f (metric.ball 0 R) (metric.ball 0 R)) (hâ‚€ : f 0 = 0) (hz : complex.abs z < R) : complex.abs (f z) â‰¤ complex.abs z
theorem monoid_hom.ext_int {M : Type u_1} [monoid M] {f g : â„¤ â†’* M} (h_neg_one : â‡‘f (-1) = â‡‘g (-1)) (h_nat : f.comp int.of_nat_hom.to_monoid_hom = g.comp int.of_nat_hom.to_monoid_hom) : f = g
theorem cardinal.lift_sup_le_lift_sup' {Î¹ : Type v} {Î¹' : Type v'} (f : Î¹ â†’ cardinal) (f' : Î¹' â†’ cardinal) (g : Î¹ â†’ Î¹') (h : âˆ€ (i : Î¹), (f i).lift â‰¤ (f' (g i)).lift) : (cardinal.sup f).lift â‰¤ (cardinal.sup f').lift
theorem units.mul_right_dvd {Î± : Type u_1} [monoid Î±] {a b : Î±} {u : Î±Ë£} : a * â†‘u âˆ£ b â†” a âˆ£ b
theorem finprod_mem_comm {Î± : Type u_1} {Î² : Type u_2} {M : Type u_5} [comm_monoid M] {s : set Î±} {t : set Î²} (f : Î± â†’ Î² â†’ M) (hs : s.finite) (ht : t.finite) : finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), finprod (Î» (j : Î²), finprod (Î» (H : j âˆˆ t), f i j)))) = finprod (Î» (j : Î²), finprod (Î» (H : j âˆˆ t), finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), f i j))))
theorem pgame.lf.trans_le {x y z : pgame} (hâ‚ : x.lf y) (hâ‚‚ : y â‰¤ z) : x.lf z
theorem add_con.Inf_def {M : Type u_1} [has_add M] (S : set (add_con M)) : â‡‘(has_Inf.Inf S) = has_Inf.Inf (coe_fn '' S)
theorem first_order.language.nonempty_of_nonempty_constants {L : first_order.language} {M : Type w} [L.Structure M] [h : nonempty L.constants] : nonempty M
theorem torus_integral_dim1 {E : Type u_1} [normed_group E] [normed_space â„‚ E] [complete_space E] (f : (fin 1 â†’ â„‚) â†’ E) (c : fin 1 â†’ â„‚) (R : fin 1 â†’ â„) : âˆ¯ (x : fin 1 â†’ â„‚) in T(c, R), f x = âˆ® (z : â„‚) in C(c 0, R 0), f (Î» (_x : fin 1), z)
theorem measure_theory.outer_measure.trim_smul {Î± : Type u_1} [measurable_space Î±] {R : Type u_2} [has_scalar R ennreal] [is_scalar_tower R ennreal ennreal] (c : R) (m : measure_theory.outer_measure Î±) : (c â€¢ m).trim = c â€¢ m.trim
theorem polynomial.exists_eq_polynomial {Fq : Type u_1} [fintype Fq] [semiring Fq] {d m : â„•} (hm : fintype.card Fq ^ d â‰¤ m) (b : polynomial Fq) (hb : b.nat_degree â‰¤ d) (A : fin m.succ â†’ polynomial Fq) (hA : âˆ€ (i : fin m.succ), (A i).degree < b.degree) : âˆƒ (iâ‚€ iâ‚ : fin m.succ), iâ‚€ â‰  iâ‚ âˆ§ A iâ‚ = A iâ‚€
theorem abs_real_inner_div_norm_mul_norm_le_one {F : Type u_3} [inner_product_space â„ F] (x y : F) : |has_inner.inner x y / (âˆ¥xâˆ¥ * âˆ¥yâˆ¥)| â‰¤ 1
theorem continuous.ext_on {Î± : Type u} {Î² : Type v} [topological_space Î±] [topological_space Î²] [t2_space Î±] {s : set Î²} (hs : dense s) {f g : Î² â†’ Î±} (hf : continuous f) (hg : continuous g) (h : set.eq_on f g s) : f = g
theorem cardinal.add_eq_self {c : cardinal} (h : cardinal.aleph_0 â‰¤ c) : c + c = c
theorem category_theory.exact_inl_snd {ğ’œ : Type u_1} [category_theory.category ğ’œ] [category_theory.preadditive ğ’œ] [category_theory.limits.has_kernels ğ’œ] [category_theory.limits.has_images ğ’œ] [category_theory.limits.has_binary_biproducts ğ’œ] (A B : ğ’œ) : category_theory.exact category_theory.limits.biprod.inl category_theory.limits.biprod.snd
theorem continuous.interval_integrable {E : Type u_3} [normed_group E] {Î¼ : measure_theory.measure â„} [measure_theory.is_locally_finite_measure Î¼] {u : â„ â†’ E} (hu : continuous u) (a b : â„) : interval_integrable u Î¼ a b
theorem finset.up_shadow_monotone {Î± : Type u_1} [decidable_eq Î±] [fintype Î±] : monotone finset.up_shadow
theorem neg_one_mul {Î± : Type u} [mul_one_class Î±] [has_distrib_neg Î±] (a : Î±) : (-1) * a = -a
theorem finset.map_affine_combination {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {Î¹ : Type u_4} (s : finset Î¹) {Vâ‚‚ : Type u_5} {Pâ‚‚ : Type u_6} [add_comm_group Vâ‚‚] [module k Vâ‚‚] [add_torsor Vâ‚‚ Pâ‚‚] (p : Î¹ â†’ P) (w : Î¹ â†’ k) (hw : s.sum w = 1) (f : P â†’áµƒ[k] Pâ‚‚) : â‡‘f (â‡‘(s.affine_combination p) w) = â‡‘(s.affine_combination (â‡‘f âˆ˜ p)) w
theorem bdd_above.convolution_exists_at' {ğ•œ : Type u_1} {G : Type u_2} {E : Type u_3} {E' : Type u_4} {F : Type u_6} [normed_group E] [normed_group E'] [normed_group F] {f : G â†’ E} {g : G â†’ E'} [nondiscrete_normed_field ğ•œ] [normed_space ğ•œ E] [normed_space ğ•œ E'] [normed_space ğ•œ F] (L : E â†’L[ğ•œ] E' â†’L[ğ•œ] F) [measurable_space G] {Î¼ : measure_theory.measure G} [add_group G] [has_measurable_addâ‚‚ G] [has_measurable_neg G] {xâ‚€ : G} {s : set G} (hbg : bdd_above ((Î» (i : G), âˆ¥g iâˆ¥) '' ((Î» (t : G), -t + xâ‚€) â»Â¹' s))) (hs : measurable_set s) (h2s : function.support (Î» (t : G), â‡‘(â‡‘L (f t)) (g (xâ‚€ - t))) âŠ† s) (hf : measure_theory.integrable_on f s Î¼) (hmf : measure_theory.ae_strongly_measurable f Î¼) (hmg : measure_theory.ae_strongly_measurable g (measure_theory.measure.map (Î» (t : G), xâ‚€ - t) Î¼)) : convolution_exists_at f g xâ‚€ L Î¼
theorem module.free.finrank_prod (R : Type u) (M : Type v) (N : Type w) [ring R] [strong_rank_condition R] [add_comm_group M] [module R M] [module.free R M] [module.finite R M] [add_comm_group N] [module R N] [module.free R N] [module.finite R N] : finite_dimensional.finrank R (M Ã— N) = finite_dimensional.finrank R M + finite_dimensional.finrank R N
theorem is_fraction_ring.is_algebraic_iff' (R : Type u_1) [comm_ring R] (S : Type u_2) [comm_ring S] [algebra R S] (K : Type u_5) [field K] [is_domain R] [is_domain S] [algebra R K] [algebra S K] [no_zero_smul_divisors R K] [is_fraction_ring S K] [is_scalar_tower R S K] : algebra.is_algebraic R S â†” algebra.is_algebraic R K
theorem measure_theory.restrict_map_with_density_abs_det_fderiv_eq_add_haar {E : Type u_1} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] {s : set E} {f : E â†’ E} {f' : E â†’ (E â†’L[â„] E)} [measurable_space E] [borel_space E] (Î¼ : measure_theory.measure E) [Î¼.is_add_haar_measure] (hs : measurable_set s) (hf' : âˆ€ (x : E), x âˆˆ s â†’ has_fderiv_within_at f (f' x) s x) (hf : set.inj_on f s) : measure_theory.measure.map (s.restrict f) (â‡‘(measure_theory.measure.comap coe) (Î¼.with_density (Î» (x : E), ennreal.of_real |(f' x).det|))) = Î¼.restrict (f '' s)
theorem zero_dvd_iff {Î± : Type u_1} [semigroup_with_zero Î±] {a : Î±} : 0 âˆ£ a â†” a = 0
theorem finset.card_Icc_finset {Î± : Type u_1} [decidable_eq Î±] {s t : finset Î±} (h : s âŠ† t) : (finset.Icc s t).card = 2 ^ (t.card - s.card)
theorem measure_theory.strongly_measurable.is_separable_range {Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} {m : measurable_space Î±} [topological_space Î²] (hf : measure_theory.strongly_measurable f) : topological_space.is_separable (set.range f)
theorem zmod.gauss_lemma (p : â„•) [fact (nat.prime p)] {a : â„¤} (hp : p â‰  2) (ha0 : â†‘a â‰  0) : zmod.legendre_sym p a = (-1) ^ (finset.filter (Î» (x : â„•), p / 2 < (â†‘a * â†‘x).val) (finset.Ico 1 (p / 2).succ)).card
theorem nat.prime.multiplicity_factorial_mul {n p : â„•} (hp : nat.prime p) : multiplicity p (p * n).factorial = multiplicity p n.factorial + â†‘n
theorem linear_map.det_cases {M : Type u_2} [add_comm_group M] {A : Type u_5} [comm_ring A] [module A M] [decidable_eq M] {P : A â†’ Prop} (f : M â†’â‚—[A] M) (hb : âˆ€ (s : finset M) (b : basis â†¥s A M), P (â‡‘(linear_map.to_matrix b b) f).det) (h1 : P 1) : P (â‡‘linear_map.det f)
theorem measure_theory.mem_â„’p.snorm_indicator_le_of_meas {Î± : Type u_1} {Î² : Type u_2} {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) [normed_group Î²] {p : ennreal} {f : Î± â†’ Î²} (hp_one : 1 â‰¤ p) (hp_top : p â‰  âŠ¤) (hf : measure_theory.mem_â„’p f p Î¼) (hmeas : measure_theory.strongly_measurable f) {Îµ : â„} (hÎµ : 0 < Îµ) : âˆƒ (Î´ : â„) (hÎ´ : 0 < Î´), âˆ€ (s : set Î±), measurable_set s â†’ â‡‘Î¼ s â‰¤ ennreal.of_real Î´ â†’ measure_theory.snorm (s.indicator f) p Î¼ â‰¤ ennreal.of_real Îµ
theorem equiv.perm.cycle_is_cycle_of {Î± : Type u_1} [decidable_eq Î±] [fintype Î±] {f c : equiv.perm Î±} {a : Î±} (ha : a âˆˆ c.support) (hc : c âˆˆ f.cycle_factors_finset) : c = f.cycle_of a
theorem measurable_set_of_mem_nhds_within_Ioi {Î± : Type u_1} [topological_space Î±] [measurable_space Î±] [borel_space Î±] [linear_order Î±] [order_topology Î±] [topological_space.second_countable_topology Î±] {s : set Î±} (h : âˆ€ (x : Î±), x âˆˆ s â†’ s âˆˆ nhds_within x (set.Ioi x)) : measurable_set s
theorem euclidean_geometry.mul_dist_eq_mul_dist_of_cospherical_of_angle_eq_pi {V : Type u_1} [inner_product_space â„ V] {P : Type u_2} [metric_space P] [normed_add_torsor V P] {a b c d p : P} (h : euclidean_geometry.cospherical {a, b, c, d}) (hapb : euclidean_geometry.angle a p b = real.pi) (hcpd : euclidean_geometry.angle c p d = real.pi) : has_dist.dist a p * has_dist.dist b p = has_dist.dist c p * has_dist.dist d p
theorem witt_vector.is_polyâ‚‚.comp {p : â„•} {h : Î  â¦ƒR : Type u_1â¦„ [_inst_3 : comm_ring R], witt_vector p R â†’ witt_vector p R â†’ witt_vector p R} {f g : Î  â¦ƒR : Type u_1â¦„ [_inst_3 : comm_ring R], witt_vector p R â†’ witt_vector p R} (hh : witt_vector.is_polyâ‚‚ p h) (hf : witt_vector.is_poly p f) (hg : witt_vector.is_poly p g) : witt_vector.is_polyâ‚‚ p (Î» (R : Type u_1) (_Rcr : comm_ring R) (x y : witt_vector p R), h (f x) (g y))
theorem strict_mono_on.dual_right {Î± : Type u} {Î² : Type v} [preorder Î±] [preorder Î²] {f : Î± â†’ Î²} {s : set Î±} : strict_mono_on f s â†’ strict_anti_on (â‡‘order_dual.to_dual âˆ˜ f) s
theorem lt_add_of_neg_add_lt_left {Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b c : Î±} : -b + a < c â†’ a < b + c
theorem not_interval_integrable_of_tendsto_norm_at_top_of_deriv_is_O_punctured {E : Type u_1} {F : Type u_2} [normed_group E] [normed_space â„ E] [topological_space.second_countable_topology E] [complete_space E] [normed_group F] {f : â„ â†’ E} {g : â„ â†’ F} {a b c : â„} (h_deriv : âˆ€á¶  (x : â„) in nhds_within c {c}á¶œ, differentiable_at â„ f x) (h_infty : filter.tendsto (Î» (x : â„), âˆ¥f xâˆ¥) (nhds_within c {c}á¶œ) filter.at_top) (hg : deriv f =O[nhds_within c {c}á¶œ] g) (hne : a â‰  b) (hc : c âˆˆ set.interval a b) : Â¬interval_integrable g measure_theory.measure_space.volume a b
theorem zero_lt.right.mul_nonneg {Î± : Type u} {a b : Î±} [mul_zero_class Î±] [partial_order Î±] [zero_lt.mul_pos_mono Î±] (ha : 0 â‰¤ a) (hb : 0 â‰¤ b) : 0 â‰¤ a * b
theorem finset.map_subtype_subset {Î± : Type u_1} {t : set Î±} (s : finset â†¥t) : â†‘(finset.map (function.embedding.subtype (Î» (x : Î±), x âˆˆ t)) s) âŠ† t
theorem add_con.lift_apply_mk' {M : Type u_1} {P : Type u_3} [add_zero_class M] [add_zero_class P] {c : add_con M} (f : c.quotient â†’+ P) : c.lift (f.comp c.mk') _ = f
theorem finset.exists_le_card_fiber_of_nsmul_le_card_of_maps_to {Î± : Type u} {Î² : Type v} {M : Type w} [decidable_eq Î²] {s : finset Î±} {t : finset Î²} {f : Î± â†’ Î²} {b : M} [linear_ordered_comm_ring M] (hf : âˆ€ (a : Î±), a âˆˆ s â†’ f a âˆˆ t) (ht : t.nonempty) (hb : t.card â€¢ b â‰¤ â†‘(s.card)) : âˆƒ (y : Î²) (H : y âˆˆ t), b â‰¤ â†‘((finset.filter (Î» (x : Î±), f x = y) s).card)
theorem measure_theory.tendsto_in_measure_of_tendsto_snorm_of_ne_top {Î± : Type u_1} {Î¹ : Type u_2} {E : Type u_3} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [normed_group E] {p : ennreal} {f : Î¹ â†’ Î± â†’ E} {g : Î± â†’ E} (hp_ne_zero : p â‰  0) (hp_ne_top : p â‰  âŠ¤) (hf : âˆ€ (n : Î¹), measure_theory.ae_strongly_measurable (f n) Î¼) (hg : measure_theory.ae_strongly_measurable g Î¼) {l : filter Î¹} (hfg : filter.tendsto (Î» (n : Î¹), measure_theory.snorm (f n - g) p Î¼) l (nhds 0)) : measure_theory.tendsto_in_measure Î¼ f l g
theorem measure_theory.signed_measure.absolutely_continuous_iff_with_densityáµ¥_rn_deriv_eq {Î± : Type u_1} {m : measurable_space Î±} (s : measure_theory.signed_measure Î±) (Î¼ : measure_theory.measure Î±) [measure_theory.sigma_finite Î¼] : measure_theory.vector_measure.absolutely_continuous s Î¼.to_ennreal_vector_measure â†” Î¼.with_densityáµ¥ (s.rn_deriv Î¼) = s
theorem orientation.fin_orthonormal_basis_orientation {E : Type u_1} [inner_product_space â„ E] {n : â„•} (hn : 0 < n) (h : finite_dimensional.finrank â„ E = n) (x : orientation â„ E (fin n)) : (orientation.fin_orthonormal_basis hn h x).orientation = x
theorem algebra.finite_presentation.trans {R : Type u_1} {A : Type u_2} {B : Type u_3} [comm_ring R] [comm_ring A] [algebra R A] [comm_ring B] [algebra R B] [algebra A B] [is_scalar_tower R A B] (hfpA : algebra.finite_presentation R A) (hfpB : algebra.finite_presentation A B) : algebra.finite_presentation R B
theorem has_scalar.comp.smul_comm_class {M : Type u_1} {N : Type u_2} {Î± : Type u_6} {Î² : Type u_7} [has_scalar M Î±] [has_scalar Î² Î±] [smul_comm_class M Î² Î±] (g : N â†’ M) : smul_comm_class N Î² Î±
theorem interval_integral.integral_eq_sub_of_has_deriv_right {E : Type u_3} [normed_group E] [complete_space E] [normed_space â„ E] {f : â„ â†’ E} {a b : â„} {f' : â„ â†’ E} (hcont : continuous_on f (set.interval a b)) (hderiv : âˆ€ (x : â„), x âˆˆ set.Ioo (linear_order.min a b) (linear_order.max a b) â†’ has_deriv_within_at f (f' x) (set.Ioi x) x) (hint : interval_integrable f' measure_theory.measure_space.volume a b) : âˆ« (y : â„) in a..b, f' y = f b - f a
theorem mvpfunctor.W_rec_eq {n : â„•} (P : mvpfunctor (n + 1)) {Î± : typevec n} {C : Type u_1} (g : Î  (a : P.A), (P.drop.B a).arrow Î± â†’ (P.last.B a â†’ P.W Î±) â†’ (P.last.B a â†’ C) â†’ C) (a : P.A) (f' : (P.drop.B a).arrow Î±) (f : P.last.B a â†’ P.W Î±) : P.W_rec g (P.W_mk a f' f) = g a f' f (Î» (i : P.last.B a), P.W_rec g (f i))
theorem measure_theory.exists_measurable_superset {Î± : Type u_1} [measurable_space Î±] (Î¼ : measure_theory.measure Î±) (s : set Î±) : âˆƒ (t : set Î±), s âŠ† t âˆ§ measurable_set t âˆ§ â‡‘Î¼ t = â‡‘Î¼ s
theorem tsub_lt_tsub_iff_right {Î± : Type u_1} [canonically_linear_ordered_add_monoid Î±] [has_sub Î±] [has_ordered_sub Î±] {a b c : Î±} [contravariant_class Î± Î± has_add.add has_le.le] (h : c â‰¤ a) : a - c < b - c â†” a < b
theorem analytic_on.deriv {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {f : ğ•œ â†’ F} {s : set ğ•œ} [complete_space F] (h : analytic_on ğ•œ f s) : analytic_on ğ•œ (deriv f) s
theorem asymptotics.is_o.eventually_mul_div_cancel {Î± : Type u_1} {ğ•œ : Type u_14} [normed_field ğ•œ] {l : filter Î±} {u v : Î± â†’ ğ•œ} (h : u =o[l] v) : u / v * v =á¶ [l] u
theorem has_sbtw.sbtw.not_btw {Î± : Type u_1} [circular_preorder Î±] {a b c : Î±} (h : has_sbtw.sbtw a b c) : Â¬has_btw.btw c b a
theorem minpoly.nat_degree_pos {A : Type u_1} {B : Type u_2} [comm_ring A] [ring B] [algebra A B] [nontrivial B] {x : B} (hx : is_integral A x) : 0 < (minpoly A x).nat_degree
theorem measure_theory.measure.hausdorff_measure_le_liminf_sum {X : Type u_2} [emetric_space X] [measurable_space X] [borel_space X] {Î² : Type u_1} {Î¹ : Î² â†’ Type u_3} [hÎ¹ : Î  (n : Î²), fintype (Î¹ n)] (d : â„) (s : set X) {l : filter Î²} (r : Î² â†’ ennreal) (hr : filter.tendsto r l (nhds 0)) (t : Î  (n : Î²), Î¹ n â†’ set X) (ht : âˆ€á¶  (n : Î²) in l, âˆ€ (i : Î¹ n), emetric.diam (t n i) â‰¤ r n) (hst : âˆ€á¶  (n : Î²) in l, s âŠ† â‹ƒ (i : Î¹ n), t n i) : â‡‘(measure_theory.measure.hausdorff_measure d) s â‰¤ l.liminf (Î» (n : Î²), finset.univ.sum (Î» (i : Î¹ n), emetric.diam (t n i) ^ d))
theorem real.abs_log_mul_self_rpow_lt (x t : â„) (h1 : 0 < x) (h2 : x â‰¤ 1) (ht : 0 < t) : |real.log x * x ^ t| < 1 / t
theorem unit_interval.le_one' {t : â†¥unit_interval} : t â‰¤ 1
theorem finset.card_erase_eq_ite {Î± : Type u_1} {s : finset Î±} {a : Î±} [decidable_eq Î±] : (s.erase a).card = ite (a âˆˆ s) (s.card - 1) s.card
theorem polynomial.monic.irreducible_of_irreducible_map {R : Type u} {S : Type v} [comm_ring R] [is_domain R] [comm_ring S] [is_domain S] (Ï† : R â†’+* S) (f : polynomial R) (h_mon : f.monic) (h_irr : irreducible (polynomial.map Ï† f)) : irreducible f
theorem category_theory.comonad.coalgebra_iso_of_iso {C : Type uâ‚} [category_theory.category C] (G : category_theory.comonad C) {A B : G.coalgebra} (f : A âŸ¶ B) [category_theory.is_iso f.f] : category_theory.is_iso f
theorem deriv.lhopital_zero_at_bot {l : filter â„} {f g : â„ â†’ â„} (hdf : âˆ€á¶  (x : â„) in filter.at_bot, differentiable_at â„ f x) (hg' : âˆ€á¶  (x : â„) in filter.at_bot, deriv g x â‰  0) (hfbot : filter.tendsto f filter.at_bot (nhds 0)) (hgbot : filter.tendsto g filter.at_bot (nhds 0)) (hdiv : filter.tendsto (Î» (x : â„), deriv f x / deriv g x) filter.at_bot l) : filter.tendsto (Î» (x : â„), f x / g x) filter.at_bot l
theorem quaternion_algebra.basis.ext {R : Type u_1} {A : Type u_2} [comm_ring R] [ring A] [algebra R A] {câ‚ câ‚‚ : R} â¦ƒqâ‚ qâ‚‚ : quaternion_algebra.basis A câ‚ câ‚‚â¦„ (hi : qâ‚.i = qâ‚‚.i) (hj : qâ‚.j = qâ‚‚.j) : qâ‚ = qâ‚‚
theorem euclidean_geometry.mul_dist_eq_mul_dist_of_cospherical {V : Type u_1} [inner_product_space â„ V] {P : Type u_2} [metric_space P] [normed_add_torsor V P] {a b c d p : P} (h : euclidean_geometry.cospherical {a, b, c, d}) (hapb : âˆƒ (kâ‚ : â„), kâ‚ â‰  1 âˆ§ b -áµ¥ p = kâ‚ â€¢ (a -áµ¥ p)) (hcpd : âˆƒ (kâ‚‚ : â„), kâ‚‚ â‰  1 âˆ§ d -áµ¥ p = kâ‚‚ â€¢ (c -áµ¥ p)) : has_dist.dist a p * has_dist.dist b p = has_dist.dist c p * has_dist.dist d p
theorem is_local_extr.has_deriv_at_eq_zero {f : â„ â†’ â„} {f' a : â„} (h : is_local_extr f a) : has_deriv_at f f' a â†’ f' = 0
theorem measure_theory.measure.tendsto_add_haar_inter_smul_one_of_density_one {E : Type u_1} [normed_group E] [measurable_space E] [normed_space â„ E] [finite_dimensional â„ E] [borel_space E] (Î¼ : measure_theory.measure E) [Î¼.is_add_haar_measure] (s : set E) (x : E) (h : filter.tendsto (Î» (r : â„), â‡‘Î¼ (s âˆ© metric.closed_ball x r) / â‡‘Î¼ (metric.closed_ball x r)) (nhds_within 0 (set.Ioi 0)) (nhds 1)) (t : set E) (ht : measurable_set t) (h't : â‡‘Î¼ t â‰  0) (h''t : â‡‘Î¼ t â‰  âŠ¤) : filter.tendsto (Î» (r : â„), â‡‘Î¼ (s âˆ© ({x} + r â€¢ t)) / â‡‘Î¼ ({x} + r â€¢ t)) (nhds_within 0 (set.Ioi 0)) (nhds 1)
theorem linear_map.linear_independent_iff {Î¹ : Type u_1} {R : Type u_3} {M : Type u_5} {M' : Type u_6} {v : Î¹ â†’ M} [semiring R] [add_comm_monoid M] [add_comm_monoid M'] [module R M] [module R M'] (f : M â†’â‚—[R] M') (hf_inj : f.ker = âŠ¥) : linear_independent R (â‡‘f âˆ˜ v) â†” linear_independent R v
theorem has_strict_fderiv_at.eq_implicit_function {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] [complete_space ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] [complete_space E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] [finite_dimensional ğ•œ F] {f : E â†’ F} {f' : E â†’L[ğ•œ] F} {a : E} (hf : has_strict_fderiv_at f f' a) (hf' : f'.range = âŠ¤) : âˆ€á¶  (x : E) in nhds a, has_strict_fderiv_at.implicit_function f f' hf hf' (f x) (â‡‘(has_strict_fderiv_at.implicit_to_local_homeomorph f f' hf hf') x).snd = x
theorem inner_product_space.is_self_adjoint_iff_bilin_form {F : Type u_3} [inner_product_space â„ F] (T : F â†’â‚—[â„] F) : inner_product_space.is_self_adjoint T â†” bilin_form_of_real_inner.is_self_adjoint T
theorem add_con.lift_range {M : Type u_1} {P : Type u_3} [add_zero_class M] [add_zero_class P] {c : add_con M} {f : M â†’+ P} (H : c â‰¤ add_con.ker f) : (c.lift f H).mrange = f.mrange
theorem submodule.orthogonal_orthogonal {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] (K : submodule ğ•œ E) [complete_space â†¥K] : Ká—®á—® = K
theorem nat.base_pow_length_digits_le' (b m : â„•) (hm : m â‰  0) : (b + 2) ^ ((b + 2).digits m).length â‰¤ (b + 2) * m
theorem orthonormal.oangle_eq_two_zsmul_oangle_sub_of_norm_eq {V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) {x y z : V} (hxyne : x â‰  y) (hxzne : x â‰  z) (hxy : âˆ¥xâˆ¥ = âˆ¥yâˆ¥) (hxz : âˆ¥xâˆ¥ = âˆ¥zâˆ¥) : hb.oangle y z = 2 â€¢ hb.oangle (y - x) (z - x)
theorem ordered_add_comm_group.le_of_add_le_add_left {Î± : Type u_1} [has_add Î±] [has_le Î±] [contravariant_class Î± Î± has_add.add has_le.le] {a b c : Î±} (bc : a + b â‰¤ a + c) : b â‰¤ c
theorem free_group.reduce.self {Î± : Type u} {L : list (Î± Ã— bool)} [decidable_eq Î±] : free_group.mk (free_group.reduce L) = free_group.mk L
theorem nat.factorization_mul_apply_of_coprime {p a b : â„•} (hab : a.coprime b) : â‡‘((a * b).factorization) p = â‡‘(a.factorization) p + â‡‘(b.factorization) p
theorem complex.differentiable_on_update_lim_insert_of_is_o {E : Type u} [normed_group E] [normed_space â„‚ E] [complete_space E] {f : â„‚ â†’ E} {s : set â„‚} {c : â„‚} (hc : s âˆˆ nhds_within c {c}á¶œ) (hd : differentiable_on â„‚ f s) (ho : (Î» (z : â„‚), f z - f c) =o[nhds_within c {c}á¶œ] Î» (z : â„‚), (z - c)â»Â¹) : differentiable_on â„‚ (function.update f c (lim (nhds_within c {c}á¶œ) f)) (has_insert.insert c s)
theorem category_theory.limits.has_terminal_of_unique {C : Type uâ‚} [category_theory.category C] (X : C) [h : Î  (Y : C), unique (Y âŸ¶ X)] : category_theory.limits.has_terminal C
theorem complex.circle_integral_sub_inv_smul_of_differentiable_on_off_countable_aux {E : Type u} [normed_group E] [normed_space â„‚ E] [complete_space E] {R : â„} {c w : â„‚} {f : â„‚ â†’ E} {s : set â„‚} (hs : s.countable) (hw : w âˆˆ metric.ball c R  s) (hc : continuous_on f (metric.closed_ball c R)) (hd : âˆ€ (x : â„‚), x âˆˆ metric.ball c R  s â†’ differentiable_at â„‚ f x) : âˆ® (z : â„‚) in C(c, R), (z - w)â»Â¹ â€¢ f z = (2 * â†‘real.pi * complex.I) â€¢ f w
theorem strict_mono.mul' {Î± : Type u_1} {Î² : Type u_2} [has_mul Î±] [preorder Î±] [preorder Î²] {f g : Î² â†’ Î±} [covariant_class Î± Î± has_mul.mul has_lt.lt] [covariant_class Î± Î± (function.swap has_mul.mul) has_lt.lt] (hf : strict_mono f) (hg : strict_mono g) : strict_mono (Î» (x : Î²), f x * g x)
theorem map_lt_line_map_iff_slope_lt_slope_left {k : Type u_1} {E : Type u_2} [linear_ordered_field k] [ordered_add_comm_group E] [module k E] [ordered_smul k E] {f : k â†’ E} {a b r : k} (h : 0 < r * (b - a)) : f (â‡‘(affine_map.line_map a b) r) < â‡‘(affine_map.line_map (f a) (f b)) r â†” slope f a (â‡‘(affine_map.line_map a b) r) < slope f a b
theorem map_mul_inv {G : Type u_6} {H : Type u_7} {F : Type u_8} [group G] [division_monoid H] [monoid_hom_class F G H] (f : F) (a b : G) : â‡‘f (a * bâ»Â¹) = â‡‘f a * (â‡‘f b)â»Â¹
theorem setoid.exists_of_mem_partition {Î± : Type u_1} {c : set (set Î±)} (hc : setoid.is_partition c) {s : set Î±} (hs : s âˆˆ c) : âˆƒ (y : Î±), s = {x : Î± | (setoid.mk_classes c _).rel x y}
theorem reflection_inv {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {K : submodule ğ•œ E} [complete_space â†¥K] : (reflection K)â»Â¹ = reflection K
theorem clifford_algebra.hom_ext {R : Type u_1} [comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {Q : quadratic_form R M} {A : Type u_3} [semiring A] [algebra R A] {f g : clifford_algebra Q â†’â‚[R] A} : f.to_linear_map.comp (clifford_algebra.Î¹ Q) = g.to_linear_map.comp (clifford_algebra.Î¹ Q) â†’ f = g
theorem absorbent_ball_zero {ğ•œ : Type u_3} {E : Type u_4} [normed_field ğ•œ] [semi_normed_group E] [normed_space ğ•œ E] {r : â„} (hr : 0 < r) : absorbent ğ•œ (metric.ball 0 r)
theorem measure_theory.outer_measure.binfi_apply {Î± : Type u_1} {Î¹ : Type u_2} {I : set Î¹} (hI : I.nonempty) (m : Î¹ â†’ measure_theory.outer_measure Î±) (s : set Î±) : (â‡‘â¨… (i : Î¹) (H : i âˆˆ I), m i) s = â¨… (t : â„• â†’ set Î±) (h2 : s âŠ† set.Union t), âˆ‘' (n : â„•), â¨… (i : Î¹) (H : i âˆˆ I), â‡‘(m i) (t n)
theorem polynomial.gal.splits_in_splitting_field_of_comp {F : Type u_1} [field F] (p q : polynomial F) (hq : q.nat_degree â‰  0) : polynomial.splits (algebra_map F (p.comp q).splitting_field) p
theorem monoid_hom.ext_iff {M : Type u_3} {N : Type u_4} [mul_one_class M] [mul_one_class N] {f g : M â†’* N} : f = g â†” âˆ€ (x : M), â‡‘f x = â‡‘g x
theorem mv_polynomial.induction_on' {R : Type u} {Ïƒ : Type u_1} [comm_semiring R] {P : mv_polynomial Ïƒ R â†’ Prop} (p : mv_polynomial Ïƒ R) (h1 : âˆ€ (u : Ïƒ â†’â‚€ â„•) (a : R), P (â‡‘(mv_polynomial.monomial u) a)) (h2 : âˆ€ (p q : mv_polynomial Ïƒ R), P p â†’ P q â†’ P (p + q)) : P p
theorem category_theory.grothendieck_topology.close_eq_top_iff_mem {C : Type u} [category_theory.category C] (Jâ‚ : category_theory.grothendieck_topology C) {X : C} (S : category_theory.sieve X) : Jâ‚.close S = âŠ¤ â†” S âˆˆ â‡‘Jâ‚ X
theorem affine.triangle.altitude_eq_monge_plane {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] (t : affine.triangle â„ P) {iâ‚ iâ‚‚ iâ‚ƒ : fin 3} (hâ‚â‚‚ : iâ‚ â‰  iâ‚‚) (hâ‚â‚ƒ : iâ‚ â‰  iâ‚ƒ) (hâ‚‚â‚ƒ : iâ‚‚ â‰  iâ‚ƒ) : affine.simplex.altitude t iâ‚ = affine.simplex.monge_plane t iâ‚‚ iâ‚ƒ
theorem filter.tendsto.invâ‚€ {Î± : Type u_1} {Gâ‚€ : Type u_3} [has_zero Gâ‚€] [has_inv Gâ‚€] [topological_space Gâ‚€] [has_continuous_invâ‚€ Gâ‚€] {l : filter Î±} {f : Î± â†’ Gâ‚€} {a : Gâ‚€} (hf : filter.tendsto f l (nhds a)) (ha : a â‰  0) : filter.tendsto (Î» (x : Î±), (f x)â»Â¹) l (nhds aâ»Â¹)
theorem is_closed.is_seq_closed {X : Type u_1} [topological_space X] {s : set X} (hs : is_closed s) : is_seq_closed s
theorem finset.eventually_all {Î± : Type u} {Î¹ : Type u_1} (I : finset Î¹) {l : filter Î±} {p : Î¹ â†’ Î± â†’ Prop} : (âˆ€á¶  (x : Î±) in l, âˆ€ (i : Î¹), i âˆˆ I â†’ p i x) â†” âˆ€ (i : Î¹), i âˆˆ I â†’ (âˆ€á¶  (x : Î±) in l, p i x)
theorem set.mem_fintype_prod {Î± : Type u_2} {Î¹ : Type u_5} [comm_monoid Î±] [fintype Î¹] (f : Î¹ â†’ set Î±) (a : Î±) : a âˆˆ finset.univ.prod (Î» (i : Î¹), f i) â†” âˆƒ (g : Î¹ â†’ Î±) (hg : âˆ€ (i : Î¹), g i âˆˆ f i), finset.univ.prod (Î» (i : Î¹), g i) = a
theorem unique_factorization_monoid.exists_reduced_factors {R : Type u_2} [cancel_comm_monoid_with_zero R] [unique_factorization_monoid R] (a : R) (H : a â‰  0) (b : R) : âˆƒ (a' b' c' : R), (âˆ€ {d : R}, d âˆ£ a' â†’ d âˆ£ b' â†’ is_unit d) âˆ§ c' * a' = a âˆ§ c' * b' = b
theorem solvable_by_rad.induction1 {F : Type u_1} [field F] {E : Type u_2} [field E] [algebra F E] {Î± Î² : â†¥(solvable_by_rad F E)} (hÎ² : Î² âˆˆ FâŸ®Î±âŸ¯) (hÎ± : solvable_by_rad.P Î±) : solvable_by_rad.P Î²
theorem composition.order_emb_of_fin_boundaries {n : â„•} (c : composition n) : c.boundaries.order_emb_of_fin _ = c.boundary
theorem measure_theory.hausdorff_measure_pi_real {Î¹ : Type u_1} [fintype Î¹] : measure_theory.measure.hausdorff_measure â†‘(fintype.card Î¹) = measure_theory.measure_space.volume
theorem submodule.is_closed_orthogonal {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] (K : submodule ğ•œ E) : is_closed â†‘Ká—®
theorem continuous_multilinear_map.cons_add {R : Type u} {n : â„•} {M : fin n.succ â†’ Type w} {Mâ‚‚ : Type wâ‚‚} [semiring R] [Î  (i : fin n.succ), add_comm_monoid (M i)] [add_comm_monoid Mâ‚‚] [Î  (i : fin n.succ), module R (M i)] [module R Mâ‚‚] [Î  (i : fin n.succ), topological_space (M i)] [topological_space Mâ‚‚] (f : continuous_multilinear_map R M Mâ‚‚) (m : Î  (i : fin n), M i.succ) (x y : M 0) : â‡‘f (fin.cons (x + y) m) = â‡‘f (fin.cons x m) + â‡‘f (fin.cons y m)
theorem convex.set_average_mem {Î± : Type u_1} {E : Type u_2} {m0 : measurable_space Î±} [normed_group E] [normed_space â„ E] [complete_space E] {Î¼ : measure_theory.measure Î±} {s : set E} {t : set Î±} {f : Î± â†’ E} (hs : convex â„ s) (hsc : is_closed s) (h0 : â‡‘Î¼ t â‰  0) (ht : â‡‘Î¼ t â‰  âŠ¤) (hfs : âˆ€áµ (x : Î±) âˆ‚Î¼.restrict t, f x âˆˆ s) (hfi : measure_theory.integrable_on f t Î¼) : â¨ (x : Î±) in t, f x âˆ‚Î¼ âˆˆ s
theorem norm_image_sub_le_of_norm_deriv_le_segment_01 {E : Type u_1} [normed_group E] [normed_space â„ E] {f : â„ â†’ E} {C : â„} (hf : differentiable_on â„ f (set.Icc 0 1)) (bound : âˆ€ (x : â„), x âˆˆ set.Ico 0 1 â†’ âˆ¥deriv_within f (set.Icc 0 1) xâˆ¥ â‰¤ C) : âˆ¥f 1 - f 0âˆ¥ â‰¤ C
theorem affine.simplex.eq_monge_point_of_forall_mem_monge_plane {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {n : â„•} {s : affine.simplex â„ P (n + 2)} {iâ‚ : fin (n + 3)} {p : P} (h : âˆ€ (iâ‚‚ : fin (n + 3)), iâ‚ â‰  iâ‚‚ â†’ p âˆˆ s.monge_plane iâ‚ iâ‚‚) : p = s.monge_point
theorem lt_of_tsub_lt_tsub_left {Î± : Type u_1} {a b c : Î±} [linear_order Î±] [add_comm_semigroup Î±] [has_sub Î±] [has_ordered_sub Î±] [covariant_class Î± Î± has_add.add has_le.le] (h : a - b < a - c) : c < b
theorem algebra.norm_eq_zero_iff' {K : Type u_4} {L : Type u_5} [field K] [field L] [algebra K L] [finite_dimensional K L] {x : L} : â‡‘linear_map.det (â‡‘(algebra.lmul K L) x) = 0 â†” x = 0
theorem continuous_linear_map.is_compact_image_coe_of_bounded_of_weak_closed {ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {F : Type u_6} [normed_group F] [nondiscrete_normed_field ğ•œ] [nondiscrete_normed_field ğ•œâ‚‚] [normed_space ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} {E' : Type u_10} [semi_normed_group E'] [normed_space ğ•œ E'] [ring_hom_isometric Ïƒâ‚â‚‚] [proper_space F] {s : set (E' â†’SL[Ïƒâ‚â‚‚] F)} (hb : metric.bounded s) (hc : âˆ€ (f : E' â†’SL[Ïƒâ‚â‚‚] F), â‡‘f âˆˆ closure (coe_fn '' s) â†’ f âˆˆ s) : is_compact (coe_fn '' s)
theorem witt_vector.is_poly.comp {p : â„•} {g f : Î  â¦ƒR : Type u_1â¦„ [_inst_3 : comm_ring R], witt_vector p R â†’ witt_vector p R} (hg : witt_vector.is_poly p g) (hf : witt_vector.is_poly p f) : witt_vector.is_poly p (Î» (R : Type u_1) (_Rcr : comm_ring R), g âˆ˜ f)
theorem category_theory.topology_eq_iff_same_sheaves {C : Type u} [category_theory.category C] {Jâ‚ Jâ‚‚ : category_theory.grothendieck_topology C} : Jâ‚ = Jâ‚‚ â†” âˆ€ (P : Cáµ’áµ– â¥¤ Type (max v u)), category_theory.presieve.is_sheaf Jâ‚ P â†” category_theory.presieve.is_sheaf Jâ‚‚ P
theorem padic_val_nat.one {p : â„•} : padic_val_nat p 1 = 0
theorem upper_semicontinuous_on.add' {Î± : Type u_1} [topological_space Î±] {s : set Î±} {Î³ : Type u_4} [linear_ordered_add_comm_monoid Î³] [topological_space Î³] [order_topology Î³] {f g : Î± â†’ Î³} (hf : upper_semicontinuous_on f s) (hg : upper_semicontinuous_on g s) (hcont : âˆ€ (x : Î±), x âˆˆ s â†’ continuous_at (Î» (p : Î³ Ã— Î³), p.fst + p.snd) (f x, g x)) : upper_semicontinuous_on (Î» (z : Î±), f z + g z) s
theorem inner_product_geometry.cos_angle_mul_norm_mul_norm {V : Type u_1} [inner_product_space â„ V] (x y : V) : real.cos (inner_product_geometry.angle x y) * (âˆ¥xâˆ¥ * âˆ¥yâˆ¥) = has_inner.inner x y
theorem subtype.prop {Î± : Sort u_1} {p : Î± â†’ Prop} (x : subtype p) : p â†‘x
theorem filter.tendsto.at_bot_mul_neg_const {Î± : Type u_3} {Î² : Type u_4} [linear_ordered_field Î±] {l : filter Î²} {f : Î² â†’ Î±} {r : Î±} (hr : r < 0) (hf : filter.tendsto f l filter.at_bot) : filter.tendsto (Î» (x : Î²), f x * r) l filter.at_top
theorem metric.bounded.exists_norm_le {E : Type u_1} [semi_normed_group E] {s : set E} : metric.bounded s â†’ (âˆƒ (R : â„), âˆ€ (x : E), x âˆˆ s â†’ âˆ¥xâˆ¥ â‰¤ R)
theorem exists_bounded_zero_one_of_closed {X : Type u_1} [topological_space X] [normal_space X] {s t : set X} (hs : is_closed s) (ht : is_closed t) (hd : disjoint s t) : âˆƒ (f : bounded_continuous_function X â„), set.eq_on â‡‘f 0 s âˆ§ set.eq_on â‡‘f 1 t âˆ§ âˆ€ (x : X), â‡‘f x âˆˆ set.Icc 0 1
theorem is_preconnected_of_forall {Î± : Type u} [topological_space Î±] {s : set Î±} (x : Î±) (H : âˆ€ (y : Î±), y âˆˆ s â†’ (âˆƒ (t : set Î±) (H : t âŠ† s), x âˆˆ t âˆ§ y âˆˆ t âˆ§ is_preconnected t)) : is_preconnected s
theorem pgame.le_zero {x : pgame} : x â‰¤ 0 â†” âˆ€ (i : x.left_moves), âˆƒ (j : (x.move_left i).right_moves), (x.move_left i).move_right j â‰¤ 0
theorem orientation.oangle_smul_right_of_pos {V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) (x y : V) {r : â„} (hr : 0 < r) : o.oangle x (r â€¢ y) = o.oangle x y
theorem lipschitz_with.of_le_add_mul {Î± : Type u} [pseudo_metric_space Î±] {f : Î± â†’ â„} (K : nnreal) (h : âˆ€ (x y : Î±), f x â‰¤ f y + â†‘K * has_dist.dist x y) : lipschitz_with K f
theorem affine.simplex.monge_point_mem_monge_plane {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {n : â„•} (s : affine.simplex â„ P (n + 2)) {iâ‚ iâ‚‚ : fin (n + 3)} : s.monge_point âˆˆ s.monge_plane iâ‚ iâ‚‚
theorem metric.uniform_embedding_bot_of_pairwise_le_dist {Î± : Type u} [pseudo_metric_space Î±] {Î² : Type u_1} {Îµ : â„} (hÎµ : 0 < Îµ) {f : Î² â†’ Î±} (hf : pairwise (Î» (x y : Î²), Îµ â‰¤ has_dist.dist (f x) (f y))) : uniform_embedding f
theorem module.ray.some_vector_ray {R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] (x : module.ray R M) : ray_of_ne_zero R x.some_vector _ = x
theorem topological_space.is_open_Union_countable {Î± : Type u} [t : topological_space Î±] [topological_space.second_countable_topology Î±] {Î¹ : Type u_1} (s : Î¹ â†’ set Î±) (H : âˆ€ (i : Î¹), is_open (s i)) : âˆƒ (T : set Î¹), T.countable âˆ§ (â‹ƒ (i : Î¹) (H : i âˆˆ T), s i) = â‹ƒ (i : Î¹), s i
theorem truncated_witt_vector.commutes (p : â„•) [hp : fact (nat.prime p)] (n : â„•) {m : â„•} (hm : n â‰¤ m) : (truncated_witt_vector.truncate hm).comp (truncated_witt_vector.zmod_equiv_trunc p m).to_ring_hom = (truncated_witt_vector.zmod_equiv_trunc p n).to_ring_hom.comp (zmod.cast_hom _ (zmod (p ^ n)))
theorem continuous_map.continuous_restrict {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] (s : set Î±) : continuous (Î» (F : C(Î±, Î²)), continuous_map.restrict s F)
theorem multilinear_map.bound_of_shell {ğ•œ : Type u} {Î¹ : Type v} {E : Î¹ â†’ Type wE} {G : Type wG} [decidable_eq Î¹] [fintype Î¹] [nondiscrete_normed_field ğ•œ] [Î  (i : Î¹), normed_group (E i)] [Î  (i : Î¹), normed_space ğ•œ (E i)] [normed_group G] [normed_space ğ•œ G] (f : multilinear_map ğ•œ E G) {Îµ : Î¹ â†’ â„} {C : â„} (hÎµ : âˆ€ (i : Î¹), 0 < Îµ i) {c : Î¹ â†’ ğ•œ} (hc : âˆ€ (i : Î¹), 1 < âˆ¥c iâˆ¥) (hf : âˆ€ (m : Î  (i : Î¹), E i), (âˆ€ (i : Î¹), Îµ i / âˆ¥c iâˆ¥ â‰¤ âˆ¥m iâˆ¥) â†’ (âˆ€ (i : Î¹), âˆ¥m iâˆ¥ < Îµ i) â†’ âˆ¥â‡‘f mâˆ¥ â‰¤ C * finset.univ.prod (Î» (i : Î¹), âˆ¥m iâˆ¥)) (m : Î  (i : Î¹), E i) : âˆ¥â‡‘f mâˆ¥ â‰¤ C * finset.univ.prod (Î» (i : Î¹), âˆ¥m iâˆ¥)
theorem tangent_map_chart {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] (I : model_with_corners ğ•œ E H) {M : Type u_4} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {p q : tangent_bundle I M} (h : q.fst âˆˆ (charted_space.chart_at H p.fst).to_local_equiv.source) : tangent_map I I â‡‘(charted_space.chart_at H p.fst) q = â‡‘((equiv.sigma_equiv_prod H E).symm) (â‡‘(charted_space.chart_at (model_prod H E) p) q)
theorem matrix.pivot.exists_list_transvec_mul_mul_list_transvec_eq_diagonal {n : Type u_1} {ğ•œ : Type u_3} [field ğ•œ] [decidable_eq n] [fintype n] (M : matrix n n ğ•œ) : âˆƒ (L L' : list (matrix.transvection_struct n ğ•œ)) (D : n â†’ ğ•œ), ((list.map matrix.transvection_struct.to_matrix L).prod.mul M).mul (list.map matrix.transvection_struct.to_matrix L').prod = matrix.diagonal D
theorem matrix.transpose_apply {m : Type u_2} {n : Type u_3} {Î± : Type v} (M : matrix m n Î±) (i : m) (j : n) : M.transpose j i = M i j
theorem topological_add_group.continuous_conj {G : Type w} [topological_space G] [has_neg G] [has_add G] [has_continuous_add G] (g : G) : continuous (Î» (h : G), g + h + -g)
theorem bounded_continuous_function.norm_eq_of_nonempty {Î± : Type u} {Î² : Type v} [topological_space Î±] [semi_normed_group Î²] (f : bounded_continuous_function Î± Î²) [h : nonempty Î±] : âˆ¥fâˆ¥ = has_Inf.Inf {C : â„ | âˆ€ (x : Î±), âˆ¥â‡‘f xâˆ¥ â‰¤ C}
theorem finset.sum_Ico_Ico_comm {M : Type u_1} [add_comm_monoid M] (a b : â„•) (f : â„• â†’ â„• â†’ M) : (finset.Ico a b).sum (Î» (i : â„•), (finset.Ico i b).sum (Î» (j : â„•), f i j)) = (finset.Ico a b).sum (Î» (j : â„•), (finset.Ico a (j + 1)).sum (Î» (i : â„•), f i j))
theorem euclidean_geometry.orthogonal_projection_orthogonal_projection {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] (s : affine_subspace â„ P) [nonempty â†¥s] [complete_space â†¥(s.direction)] (p : P) : â‡‘(euclidean_geometry.orthogonal_projection s) â†‘(â‡‘(euclidean_geometry.orthogonal_projection s) p) = â‡‘(euclidean_geometry.orthogonal_projection s) p
theorem submodule.finrank_quotient_le {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] (s : submodule K V) : finite_dimensional.finrank K (V â§¸ s) â‰¤ finite_dimensional.finrank K V
theorem map_snd_nhds_within {Î± : Type u} {Î² : Type v} [topological_space Î±] [topological_space Î²] (x : Î± Ã— Î²) : filter.map prod.snd (nhds_within x (prod.fst â»Â¹' {x.fst})) = nhds x.snd
theorem finsum_mem_union'' {Î± : Type u_1} {M : Type u_5} [add_comm_monoid M] {f : Î± â†’ M} {s t : set Î±} (hst : disjoint (s âˆ© function.support f) (t âˆ© function.support f)) (hs : (s âˆ© function.support f).finite) (ht : (t âˆ© function.support f).finite) : finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s âˆª t), f i)) = finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), f i)) + finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ t), f i))
theorem generalized_continued_fraction.denominators_recurrence {K : Type u_1} {g : generalized_continued_fraction K} {n : â„•} [division_ring K] {gp : generalized_continued_fraction.pair K} {ppredB predB : K} (succ_nth_s_eq : g.s.nth (n + 1) = option.some gp) (nth_denom_eq : g.denominators n = ppredB) (succ_nth_denom_eq : g.denominators (n + 1) = predB) : g.denominators (n + 2) = gp.b * predB + gp.a * ppredB
theorem finprod_mem_one {Î± : Type u_1} {M : Type u_5} [comm_monoid M] (s : set Î±) : finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), 1)) = 1
theorem multiples.zero_mem {M : Type u_1} [add_monoid M] {x : M} : 0 âˆˆ multiples x
theorem comp_mul_left {Î± : Type u_1} [semigroup Î±] (x y : Î±) : has_mul.mul x âˆ˜ has_mul.mul y = has_mul.mul (x * y)
theorem vitali_family.ae_tendsto_rn_deriv {Î± : Type u_1} [metric_space Î±] {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (v : vitali_family Î¼) [sigma_compact_space Î±] [borel_space Î±] [measure_theory.is_locally_finite_measure Î¼] (Ï : measure_theory.measure Î±) [measure_theory.is_locally_finite_measure Ï] : âˆ€áµ (x : Î±) âˆ‚Î¼, filter.tendsto (Î» (a : set Î±), â‡‘Ï a / â‡‘Î¼ a) (v.filter_at x) (nhds (Ï.rn_deriv Î¼ x))
theorem fin.range_succ_above {n : â„•} (p : fin (n + 1)) : set.range â‡‘(p.succ_above) = {p}á¶œ
theorem controlled_closure_range_of_complete {G : Type u_1} [normed_group G] [complete_space G] {H : Type u_2} [normed_group H] {f : normed_group_hom G H} {K : Type u_3} [semi_normed_group K] {j : normed_group_hom K H} (hj : âˆ€ (x : K), âˆ¥â‡‘j xâˆ¥ = âˆ¥xâˆ¥) {C Îµ : â„} (hC : 0 < C) (hÎµ : 0 < Îµ) (hyp : âˆ€ (k : K), âˆƒ (g : G), â‡‘f g = â‡‘j k âˆ§ âˆ¥gâˆ¥ â‰¤ C * âˆ¥kâˆ¥) : f.surjective_on_with j.range.topological_closure (C + Îµ)
theorem div_div_self {Gâ‚€ : Type u_2} [group_with_zero Gâ‚€] (a : Gâ‚€) : a / (a / a) = a
theorem polynomial.cyclotomic'_eq_X_pow_sub_one_div {K : Type u_1} [comm_ring K] [is_domain K] {Î¶ : K} {n : â„•} (hpos : 0 < n) (h : is_primitive_root Î¶ n) : polynomial.cyclotomic' n K = (polynomial.X ^ n - 1) /â‚˜ n.proper_divisors.prod (Î» (i : â„•), polynomial.cyclotomic' i K)
theorem measure_theory.integral_eq_lintegral_pos_part_sub_lintegral_neg_part {Î± : Type u_1} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {f : Î± â†’ â„} (hf : measure_theory.integrable f Î¼) : âˆ« (a : Î±), f a âˆ‚Î¼ = (âˆ«â» (a : Î±), ennreal.of_real (f a) âˆ‚Î¼).to_real - (âˆ«â» (a : Î±), ennreal.of_real (-f a) âˆ‚Î¼).to_real
theorem measure_theory.fin_strongly_measurable.measurable {Î± : Type u_1} {Î² : Type u_2} {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {f : Î± â†’ Î²} [has_zero Î²] [topological_space Î²] [topological_space.pseudo_metrizable_space Î²] [measurable_space Î²] [borel_space Î²] (hf : measure_theory.fin_strongly_measurable f Î¼) : measurable f
theorem measure_theory.submartingale_iff_expected_stopped_value_mono {Î± : Type u_1} {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {ğ’¢ : measure_theory.filtration â„• m0} [measure_theory.is_finite_measure Î¼] {f : â„• â†’ Î± â†’ â„} (hadp : measure_theory.adapted ğ’¢ f) (hint : âˆ€ (i : â„•), measure_theory.integrable (f i) Î¼) : measure_theory.submartingale f ğ’¢ Î¼ â†” âˆ€ (Ï„ Ï€ : Î± â†’ â„•), measure_theory.is_stopping_time ğ’¢ Ï„ â†’ measure_theory.is_stopping_time ğ’¢ Ï€ â†’ Ï„ â‰¤ Ï€ â†’ (âˆƒ (N : â„•), âˆ€ (x : Î±), Ï€ x â‰¤ N) â†’ âˆ« (x : Î±), measure_theory.stopped_value f Ï„ x âˆ‚Î¼ â‰¤ âˆ« (x : Î±), measure_theory.stopped_value f Ï€ x âˆ‚Î¼
theorem closed_embedding.tendsto_cocompact {Î± : Type u} {Î² : Type v} [topological_space Î±] [topological_space Î²] {f : Î± â†’ Î²} (hf : closed_embedding f) : filter.tendsto f (filter.cocompact Î±) (filter.cocompact Î²)
theorem diffeomorph.coe_fn_injective {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {E' : Type u_3} [normed_group E'] [normed_space ğ•œ E'] {H : Type u_5} [topological_space H] {H' : Type u_6} [topological_space H'] {I : model_with_corners ğ•œ E H} {I' : model_with_corners ğ•œ E' H'} {M : Type u_8} [topological_space M] [charted_space H M] {M' : Type u_9} [topological_space M'] [charted_space H' M'] {n : with_top â„•} : function.injective (Î» (h : diffeomorph I I' M M' n) (x : M), â‡‘h x)
theorem finset.mem_shadow_iff_exists_mem_card_add {Î± : Type u_1} [decidable_eq Î±] {ğ’œ : finset (finset Î±)} {s : finset Î±} {k : â„•} : s âˆˆ finset.shadow^[k] ğ’œ â†” âˆƒ (t : finset Î±) (H : t âˆˆ ğ’œ), s âŠ† t âˆ§ t.card = s.card + k
theorem concave_on_iff_slope_anti_adjacent {ğ•œ : Type u_1} [linear_ordered_field ğ•œ] {s : set ğ•œ} {f : ğ•œ â†’ ğ•œ} : concave_on ğ•œ s f â†” convex ğ•œ s âˆ§ âˆ€ â¦ƒx y z : ğ•œâ¦„, x âˆˆ s â†’ z âˆˆ s â†’ x < y â†’ y < z â†’ (f z - f y) / (z - y) â‰¤ (f y - f x) / (y - x)
theorem real.summable_one_div_nat_rpow {p : â„} : summable (Î» (n : â„•), 1 / â†‘n ^ p) â†” 1 < p
theorem finsupp.sum_add_index' {Î± : Type u_1} {M : Type u_5} {N : Type u_7} [add_zero_class M] [add_comm_monoid N] {f g : Î± â†’â‚€ M} {h : Î± â†’ M â†’ N} (h_zero : âˆ€ (a : Î±), h a 0 = 0) (h_add : âˆ€ (a : Î±) (bâ‚ bâ‚‚ : M), h a (bâ‚ + bâ‚‚) = h a bâ‚ + h a bâ‚‚) : (f + g).sum h = f.sum h + g.sum h
theorem map_fst_nhds_within {Î± : Type u} {Î² : Type v} [topological_space Î±] [topological_space Î²] (x : Î± Ã— Î²) : filter.map prod.fst (nhds_within x (prod.snd â»Â¹' {x.snd})) = nhds x.fst
theorem subgroup.le_normalizer_comap {G : Type u_1} [group G] {H : subgroup G} {N : Type u_3} [group N] (f : N â†’* G) : subgroup.comap f H.normalizer â‰¤ (subgroup.comap f H).normalizer
theorem composition.disjoint_range {n : â„•} (c : composition n) {iâ‚ iâ‚‚ : fin c.length} (h : iâ‚ â‰  iâ‚‚) : disjoint (set.range â‡‘(c.embedding iâ‚)) (set.range â‡‘(c.embedding iâ‚‚))
theorem strict_convex_on.lt_on_open_segment {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [ordered_semiring ğ•œ] [add_comm_monoid E] [linear_ordered_add_comm_monoid Î²] [has_scalar ğ•œ E] [module ğ•œ Î²] [ordered_smul ğ•œ Î²] {s : set E} {f : E â†’ Î²} (hf : strict_convex_on ğ•œ s f) {x y z : E} (hx : x âˆˆ s) (hy : y âˆˆ s) (hxy : x â‰  y) (hz : z âˆˆ open_segment ğ•œ x y) : f z < linear_order.max (f x) (f y)
theorem is_countably_spanning.prod {Î± : Type u_1} {Î² : Type u_3} {C : set (set Î±)} {D : set (set Î²)} (hC : is_countably_spanning C) (hD : is_countably_spanning D) : is_countably_spanning (set.image2 has_set_prod.prod C D)
theorem filter.coext {Î± : Type u} {f g : filter Î±} (h : âˆ€ (s : set Î±), sá¶œ âˆˆ f â†” sá¶œ âˆˆ g) : f = g
theorem holder_with.dimH_image_le {X : Type u_2} {Y : Type u_3} [emetric_space X] [emetric_space Y] {C r : nnreal} {f : X â†’ Y} (h : holder_with C r f) (hr : 0 < r) (s : set X) : dimH (f '' s) â‰¤ dimH s / â†‘r
theorem add_submonoid.localization_map.neg_inj {M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {N : Type u_2} [add_comm_monoid N] {f : M â†’+ N} (hf : âˆ€ (y : â†¥S), is_add_unit (â‡‘f â†‘y)) {y z : â†¥S} (h : -â‡‘(is_add_unit.lift_right (f.restrict S) hf) y = -â‡‘(is_add_unit.lift_right (f.restrict S) hf) z) : â‡‘f â†‘y = â‡‘f â†‘z
theorem module.free.rank_pi_fintype (R : Type u) [ring R] [strong_rank_condition R] {Î¹ : Type v} [fintype Î¹] {M : Î¹ â†’ Type w} [Î  (i : Î¹), add_comm_group (M i)] [Î  (i : Î¹), module R (M i)] [âˆ€ (i : Î¹), module.free R (M i)] : module.rank R (Î  (i : Î¹), M i) = cardinal.sum (Î» (i : Î¹), module.rank R (M i))
theorem tsum_geometric_inv_two_ge (n : â„•) : âˆ‘' (i : â„•), ite (n â‰¤ i) (2â»Â¹ ^ i) 0 = 2 * 2â»Â¹ ^ n
theorem probability_theory.cond_eq_inv_mul_cond_mul {Î± : Type u_1} {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) {s t : set Î±} [measure_theory.is_finite_measure Î¼] (hms : measurable_set s) (hmt : measurable_set t) : â‡‘(probability_theory.cond Î¼ s) t = (â‡‘Î¼ s)â»Â¹ * â‡‘(probability_theory.cond Î¼ t) s * â‡‘Î¼ t
theorem closure_operator.closed_eq_range_close {Î± : Type u_1} [partial_order Î±] (c : closure_operator Î±) : c.closed = set.range â‡‘c
theorem intermediate_field.div_mem {K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) {x y : L} : x âˆˆ S â†’ y âˆˆ S â†’ x / y âˆˆ S
theorem nat.modeq.modeq_cancel_left_div_gcd {a b c m : â„•} (hm : 0 < m) (h : c * a â‰¡ c * b [MOD m]) : a â‰¡ b [MOD m / m.gcd c]
theorem category_theory.is_pullback.of_bot {C : Type uâ‚} [category_theory.category C] {Xâ‚â‚ Xâ‚â‚‚ Xâ‚‚â‚ Xâ‚‚â‚‚ Xâ‚ƒâ‚ Xâ‚ƒâ‚‚ : C} {hâ‚â‚ : Xâ‚â‚ âŸ¶ Xâ‚â‚‚} {hâ‚‚â‚ : Xâ‚‚â‚ âŸ¶ Xâ‚‚â‚‚} {hâ‚ƒâ‚ : Xâ‚ƒâ‚ âŸ¶ Xâ‚ƒâ‚‚} {vâ‚â‚ : Xâ‚â‚ âŸ¶ Xâ‚‚â‚} {vâ‚â‚‚ : Xâ‚â‚‚ âŸ¶ Xâ‚‚â‚‚} {vâ‚‚â‚ : Xâ‚‚â‚ âŸ¶ Xâ‚ƒâ‚} {vâ‚‚â‚‚ : Xâ‚‚â‚‚ âŸ¶ Xâ‚ƒâ‚‚} (s : category_theory.is_pullback hâ‚â‚ (vâ‚â‚ â‰« vâ‚‚â‚) (vâ‚â‚‚ â‰« vâ‚‚â‚‚) hâ‚ƒâ‚) (p : hâ‚â‚ â‰« vâ‚â‚‚ = vâ‚â‚ â‰« hâ‚‚â‚) (t : category_theory.is_pullback hâ‚‚â‚ vâ‚‚â‚ vâ‚‚â‚‚ hâ‚ƒâ‚) : category_theory.is_pullback hâ‚â‚ vâ‚â‚ vâ‚â‚‚ hâ‚‚â‚
theorem category_theory.limits.cotrident.is_colimit.hom_iso_natural {J : Type v} {C : Type u} [category_theory.category C] {X Y : C} {f : J â†’ (X âŸ¶ Y)} [nonempty J] {t : category_theory.limits.cotrident f} {Z Z' : C} (q : Z âŸ¶ Z') (ht : category_theory.limits.is_colimit t) (k : t.X âŸ¶ Z) : â†‘(â‡‘(category_theory.limits.cotrident.is_colimit.hom_iso ht Z') (k â‰« q)) = â†‘(â‡‘(category_theory.limits.cotrident.is_colimit.hom_iso ht Z) k) â‰« q
theorem Compactum.continuous_of_hom {X Y : Compactum} (f : X âŸ¶ Y) : continuous â‡‘f
theorem submodule.mul_induction_on' {R : Type u} [comm_semiring R] {A : Type v} [semiring A] [algebra R A] {M N : submodule R A} {C : Î  (r : A), r âˆˆ M * N â†’ Prop} (hm : âˆ€ (m : A) (H : m âˆˆ M) (n : A) (H_1 : n âˆˆ N), C (m * n) _) (ha : âˆ€ (x : A) (hx : x âˆˆ M * N) (y : A) (hy : y âˆˆ M * N), C x hx â†’ C y hy â†’ C (x + y) _) {r : A} (hr : r âˆˆ M * N) : C r hr
theorem continuous_linear_map.inverse_equiv {R : Type u_1} {M : Type u_2} {Mâ‚‚ : Type u_3} [topological_space M] [topological_space Mâ‚‚] [semiring R] [add_comm_monoid Mâ‚‚] [module R Mâ‚‚] [add_comm_monoid M] [module R M] (e : M â‰ƒL[R] Mâ‚‚) : â†‘e.inverse = â†‘(e.symm)
theorem formal_multilinear_series.le_mul_pow_of_radius_pos {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field ğ•œ] [normed_group E] [normed_space ğ•œ E] [normed_group F] [normed_space ğ•œ F] (p : formal_multilinear_series ğ•œ E F) (h : 0 < p.radius) : âˆƒ (C r : â„) (hC : 0 < C) (hr : 0 < r), âˆ€ (n : â„•), âˆ¥p nâˆ¥ â‰¤ C * r ^ n
theorem affine.simplex.sum_point_weights_with_circumcenter {n : â„•} (i : fin (n + 1)) : finset.univ.sum (Î» (j : affine.simplex.points_with_circumcenter_index n), affine.simplex.point_weights_with_circumcenter i j) = 1
theorem module.End.has_generalized_eigenvalue_of_has_eigenvalue {R : Type v} {M : Type w} [comm_ring R] [add_comm_group M] [module R M] {f : module.End R M} {Î¼ : R} {k : â„•} (hk : 0 < k) (hÎ¼ : f.has_eigenvalue Î¼) : f.has_generalized_eigenvalue Î¼ k
theorem monoid_algebra.non_unital_alg_hom_ext' (k : Type uâ‚) {G : Type uâ‚‚} [semiring k] [has_mul G] {A : Type uâ‚ƒ} [non_unital_non_assoc_semiring A] [distrib_mul_action k A] {Ï†â‚ Ï†â‚‚ : monoid_algebra k G â†’â‚™â‚[k] A} (h : Ï†â‚.to_mul_hom.comp (monoid_algebra.of_magma k G) = Ï†â‚‚.to_mul_hom.comp (monoid_algebra.of_magma k G)) : Ï†â‚ = Ï†â‚‚
theorem finite_field.exists_nonsquare {F : Type u_3} [field F] [fintype F] (hF : ring_char F â‰  2) : âˆƒ (a : F), Â¬is_square a
theorem part.ext {Î± : Type u_1} {o p : part Î±} (H : âˆ€ (a : Î±), a âˆˆ o â†” a âˆˆ p) : o = p
theorem orthonormal.oangle_neg_self_right {V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) {x : V} (hx : x â‰  0) : hb.oangle x (-x) = â†‘real.pi
theorem conformal_at_iff {E : Type u_1} {F : Type u_2} [inner_product_space â„ E] [inner_product_space â„ F] {f : E â†’ F} {x : E} {f' : E â†’L[â„] F} (h : has_fderiv_at f f' x) : conformal_at f x â†” âˆƒ (c : â„), 0 < c âˆ§ âˆ€ (u v : E), has_inner.inner (â‡‘f' u) (â‡‘f' v) = c * has_inner.inner u v
theorem normed_group_hom.op_norm_add_le {Vâ‚ : Type u_2} {Vâ‚‚ : Type u_3} [semi_normed_group Vâ‚] [semi_normed_group Vâ‚‚] (f g : normed_group_hom Vâ‚ Vâ‚‚) : âˆ¥f + gâˆ¥ â‰¤ âˆ¥fâˆ¥ + âˆ¥gâˆ¥
theorem euclidean_geometry.orthogonal_projection_vsub_mem_direction_orthogonal {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] (s : affine_subspace â„ P) [nonempty â†¥s] [complete_space â†¥(s.direction)] (p : P) : â†‘(â‡‘(euclidean_geometry.orthogonal_projection s) p) -áµ¥ p âˆˆ (s.direction)á—®
theorem is_extr_on.dual {Î± : Type u} {Î² : Type v} [preorder Î²] {f : Î± â†’ Î²} {s : set Î±} {a : Î±} : is_extr_on f s a â†’ is_extr_on (â‡‘order_dual.to_dual âˆ˜ f) s a
theorem hall_marriage_theorem.hall_hard_inductive {Î¹ : Type u} {Î± : Type v} [fintype Î¹] {t : Î¹ â†’ finset Î±} [decidable_eq Î±] (ht : âˆ€ (s : finset Î¹), s.card â‰¤ (s.bUnion t).card) : âˆƒ (f : Î¹ â†’ Î±), function.injective f âˆ§ âˆ€ (x : Î¹), f x âˆˆ t x
theorem cont_diff_at.prod_map {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {n : with_top â„•} {E' : Type u_6} [normed_group E'] [normed_space ğ•œ E'] {F' : Type u_7} [normed_group F'] [normed_space ğ•œ F'] {f : E â†’ F} {g : E' â†’ F'} {x : E} {y : E'} (hf : cont_diff_at ğ•œ n f x) (hg : cont_diff_at ğ•œ n g y) : cont_diff_at ğ•œ n (prod.map f g) (x, y)
theorem measurable_div_const' {G : Type u_1} [div_inv_monoid G] [measurable_space G] [has_measurable_mul G] (g : G) : measurable (Î» (h : G), h / g)
theorem fin.heq_fun_iff {Î± : Sort u_1} {k l : â„•} (h : k = l) {f : fin k â†’ Î±} {g : fin l â†’ Î±} : f == g â†” âˆ€ (i : fin k), f i = g âŸ¨â†‘i, _âŸ©
theorem linear_map.to_matrix_id {R : Type u_1} [comm_semiring R] {n : Type u_4} [fintype n] [decidable_eq n] {Mâ‚ : Type u_5} [add_comm_monoid Mâ‚] [module R Mâ‚] (vâ‚ : basis n R Mâ‚) : â‡‘(linear_map.to_matrix vâ‚ vâ‚) linear_map.id = 1
theorem submodule.mem_of_span_eq_top_of_smul_pow_mem {R : Type u} {M : Type v} [comm_semiring R] [add_comm_monoid M] [module R M] (M' : submodule R M) (s : set R) (hs : ideal.span s = âŠ¤) (x : M) (H : âˆ€ (r : â†¥s), âˆƒ (n : â„•), â†‘r ^ n â€¢ x âˆˆ M') : x âˆˆ M'
theorem is_top.eq_top {Î± : Type u} [partial_order Î±] [order_top Î±] {a : Î±} : is_top a â†’ a = âŠ¤
theorem direct_sum.is_internal_submodule_iff_independent_and_supr_eq_top {R : Type u} [ring R] {Î¹ : Type v} [dec_Î¹ : decidable_eq Î¹] {M : Type u_1} [add_comm_group M] [module R M] (A : Î¹ â†’ submodule R M) : direct_sum.is_internal A â†” complete_lattice.independent A âˆ§ supr A = âŠ¤
theorem units.inv_eq_self_iff {R : Type x} [ring R] [no_zero_divisors R] (u : RË£) : uâ»Â¹ = u â†” u = 1 âˆ¨ u = -1
theorem algebraic_independent_finset_map_embedding_subtype {R : Type u_3} {A : Type u_5} [comm_ring R] [comm_ring A] [algebra R A] (s : set A) (li : algebraic_independent R coe) (t : finset â†¥s) : algebraic_independent R coe
theorem category_theory.limits.is_iso_limit_cone_parallel_pair_of_self {C : Type u} [category_theory.category C] {X Y : C} {f : X âŸ¶ Y} {c : category_theory.limits.fork f f} (h : category_theory.limits.is_limit c) : category_theory.is_iso c.Î¹
theorem dist_convolution_le {G : Type u_2} {E' : Type u_4} [normed_group E'] {g : G â†’ E'} [measurable_space G] {Î¼ : measure_theory.measure G} [semi_normed_group G] [borel_space G] [topological_space.second_countable_topology G] [Î¼.is_add_left_invariant] [measure_theory.sigma_finite Î¼] [normed_space â„ E'] [complete_space E'] {f : G â†’ â„} {xâ‚€ : G} {R Îµ : â„} (hÎµ : 0 â‰¤ Îµ) (hf : function.support f âŠ† metric.ball 0 R) (hnf : âˆ€ (x : G), 0 â‰¤ f x) (hintf : âˆ« (x : G), f x âˆ‚Î¼ = 1) (hmg : measure_theory.ae_strongly_measurable g Î¼) (hg : âˆ€ (x : G), x âˆˆ metric.ball xâ‚€ R â†’ has_dist.dist (g x) (g xâ‚€) â‰¤ Îµ) : has_dist.dist (convolution f g (continuous_linear_map.lsmul â„ â„) Î¼ xâ‚€) (g xâ‚€) â‰¤ Îµ
theorem finset.sum_bij {Î² : Type u} {Î± : Type v} {Î³ : Type w} [add_comm_monoid Î²] {s : finset Î±} {t : finset Î³} {f : Î± â†’ Î²} {g : Î³ â†’ Î²} (i : Î  (a : Î±), a âˆˆ s â†’ Î³) (hi : âˆ€ (a : Î±) (ha : a âˆˆ s), i a ha âˆˆ t) (h : âˆ€ (a : Î±) (ha : a âˆˆ s), f a = g (i a ha)) (i_inj : âˆ€ (aâ‚ aâ‚‚ : Î±) (haâ‚ : aâ‚ âˆˆ s) (haâ‚‚ : aâ‚‚ âˆˆ s), i aâ‚ haâ‚ = i aâ‚‚ haâ‚‚ â†’ aâ‚ = aâ‚‚) (i_surj : âˆ€ (b : Î³), b âˆˆ t â†’ (âˆƒ (a : Î±) (ha : a âˆˆ s), b = i a ha)) : s.sum (Î» (x : Î±), f x) = t.sum (Î» (x : Î³), g x)
theorem emetric.diam_empty {Î± : Type u} [pseudo_emetric_space Î±] : emetric.diam âˆ… = 0
theorem affine_subspace.inf_coe {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] (s1 s2 : affine_subspace k P) : â†‘s1 âŠ“ â†‘s2 = â†‘s1 âˆ© â†‘s2
theorem continuous_multilinear_map.le_op_norm {ğ•œ : Type u} {Î¹ : Type v} {E : Î¹ â†’ Type wE} {G : Type wG} [decidable_eq Î¹] [fintype Î¹] [nondiscrete_normed_field ğ•œ] [Î  (i : Î¹), normed_group (E i)] [Î  (i : Î¹), normed_space ğ•œ (E i)] [normed_group G] [normed_space ğ•œ G] (f : continuous_multilinear_map ğ•œ E G) (m : Î  (i : Î¹), E i) : âˆ¥â‡‘f mâˆ¥ â‰¤ âˆ¥fâˆ¥ * finset.univ.prod (Î» (i : Î¹), âˆ¥m iâˆ¥)
theorem mk_univ_complex  : cardinal.mk â†¥set.univ = cardinal.continuum
theorem exists_has_deriv_within_at_eq_of_gt_of_lt {a b : â„} {f f' : â„ â†’ â„} (hab : a â‰¤ b) (hf : âˆ€ (x : â„), x âˆˆ set.Icc a b â†’ has_deriv_within_at f (f' x) (set.Icc a b) x) {m : â„} (hma : f' a < m) (hmb : m < f' b) : m âˆˆ f' '' set.Icc a b
theorem measure_theory.adapted.prog_measurable_of_nat {Î± : Type u_1} {Î² : Type u_2} {m : measurable_space Î±} {f : measure_theory.filtration â„• m} {u : â„• â†’ Î± â†’ Î²} [add_comm_monoid Î²] [topological_space Î²] [has_continuous_add Î²] (h : measure_theory.adapted f u) : measure_theory.prog_measurable f u
theorem has_deriv_at.lhopital_zero_nhds' {a : â„} {l : filter â„} {f f' g g' : â„ â†’ â„} (hff' : âˆ€á¶  (x : â„) in nhds_within a (set.univ  {a}), has_deriv_at f (f' x) x) (hgg' : âˆ€á¶  (x : â„) in nhds_within a (set.univ  {a}), has_deriv_at g (g' x) x) (hg' : âˆ€á¶  (x : â„) in nhds_within a (set.univ  {a}), g' x â‰  0) (hfa : filter.tendsto f (nhds_within a (set.univ  {a})) (nhds 0)) (hga : filter.tendsto g (nhds_within a (set.univ  {a})) (nhds 0)) (hdiv : filter.tendsto (Î» (x : â„), f' x / g' x) (nhds_within a (set.univ  {a})) l) : filter.tendsto (Î» (x : â„), f x / g x) (nhds_within a (set.univ  {a})) l
theorem dvd_coeff_zero_of_aeval_eq_prime_smul_of_minpoly_is_eiseinstein_at {R : Type u} {K : Type v} {L : Type z} {p : R} [comm_ring R] [field K] [field L] [algebra K L] [algebra R L] [algebra R K] [is_scalar_tower R K L] [is_separable K L] [is_domain R] [normalized_gcd_monoid R] [is_fraction_ring R K] [is_integrally_closed R] {B : power_basis K L} (hp : prime p) (hBint : is_integral R B.gen) {z : L} {Q : polynomial R} (hQ : â‡‘(polynomial.aeval B.gen) Q = p â€¢ z) (hzint : is_integral R z) (hei : (minpoly R B.gen).is_eisenstein_at (submodule.span R {p})) : p âˆ£ Q.coeff 0
theorem filter.tendsto.neg_const_mul_at_top {Î± : Type u_3} {Î² : Type u_4} [linear_ordered_field Î±] {l : filter Î²} {f : Î² â†’ Î±} {r : Î±} (hr : r < 0) (hf : filter.tendsto f l filter.at_top) : filter.tendsto (Î» (x : Î²), r * f x) l filter.at_bot
theorem orthogonal_family.comp {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {Î¹ : Type u_4} {G : Î¹ â†’ Type u_5} [Î  (i : Î¹), inner_product_space ğ•œ (G i)] {V : Î  (i : Î¹), G i â†’â‚—áµ¢[ğ•œ] E} (hV : orthogonal_family ğ•œ V) {Î³ : Type u_3} {f : Î³ â†’ Î¹} (hf : function.injective f) : orthogonal_family ğ•œ (Î» (g : Î³), V (f g))
theorem monoid_algebra.map_domain_one {Î± : Type u_1} {Î² : Type u_2} {Î±â‚‚ : Type u_3} [semiring Î²] [has_one Î±] [has_one Î±â‚‚] {F : Type u_4} [one_hom_class F Î± Î±â‚‚] (f : F) : finsupp.map_domain â‡‘f 1 = 1
theorem category_theory.is_filtered.sup_objs_exists {C : Type u} [category_theory.category C] [category_theory.is_filtered C] (O : finset C) : âˆƒ (S : C), âˆ€ {X : C}, X âˆˆ O â†’ nonempty (X âŸ¶ S)
theorem rel_hom.coe_fn_injective {Î± : Type u_1} {Î² : Type u_2} {r : Î± â†’ Î± â†’ Prop} {s : Î² â†’ Î² â†’ Prop} : function.injective coe_fn
theorem padic_norm.eq_zpow_of_nonzero (p : â„•) {q : â„š} (hq : q â‰  0) : padic_norm p q = â†‘p ^ -padic_val_rat p q
theorem finset.nonempty.of_inv {Î± : Type u_2} [decidable_eq Î±] [has_inv Î±] {s : finset Î±} : s.nonempty â†’ sâ»Â¹.nonempty
theorem direct_sum.add_hom_ext {Î¹ : Type v} [dec_Î¹ : decidable_eq Î¹] {Î² : Î¹ â†’ Type w} [Î  (i : Î¹), add_comm_monoid (Î² i)] {Î³ : Type u_1} [add_monoid Î³] â¦ƒf g : direct_sum Î¹ (Î» (i : Î¹), Î² i) â†’+ Î³â¦„ (H : âˆ€ (i : Î¹) (y : Î² i), â‡‘f (â‡‘(direct_sum.of (Î» (i : Î¹), Î² i) i) y) = â‡‘g (â‡‘(direct_sum.of (Î» (i : Î¹), Î² i) i) y)) : f = g
theorem is_add_hom.id {Î± : Type u} [has_add Î±] : is_add_hom id
theorem subalgebra.mul_self {R : Type u_1} {A : Type u_2} [comm_semiring R] [semiring A] [algebra R A] (S : subalgebra R A) : S.to_submodule * S.to_submodule = S.to_submodule
theorem generalized_continued_fraction.comp_exact_value_correctness_of_stream_eq_some_aux_comp {K : Type u_1} [linear_ordered_field K] [floor_ring K] {a : K} (b c : K) (fract_a_ne_zero : int.fract a â‰  0) : (â†‘âŒŠaâŒ‹ * b + c) / int.fract a + b = (b * a + c) / int.fract a
theorem convex.mul_sub_le_image_sub_of_le_deriv {D : set â„} (hD : convex â„ D) {f : â„ â†’ â„} (hf : continuous_on f D) (hf' : differentiable_on â„ f (interior D)) {C : â„} (hf'_ge : âˆ€ (x : â„), x âˆˆ interior D â†’ C â‰¤ deriv f x) (x : â„) (H : x âˆˆ D) (y : â„) (H_1 : y âˆˆ D) : x â‰¤ y â†’ C * (y - x) â‰¤ f y - f x
theorem lie_subalgebra.ideal_in_normalizer {R : Type u_1} {L : Type u_2} [comm_ring R] [lie_ring L] [lie_algebra R L] {H : lie_subalgebra R L} {x y : L} (hx : x âˆˆ H.normalizer) (hy : y âˆˆ H) : â…x,yâ† âˆˆ H
theorem add_monoid_algebra.mv_polynomial_aeval_of_surjective_of_closure {R : Type u_1} {M : Type u_2} [add_comm_monoid M] [comm_semiring R] {S : set M} (hS : add_submonoid.closure S = âŠ¤) : function.surjective â‡‘(mv_polynomial.aeval (Î» (s : â†¥S), add_monoid_algebra.of' R M â†‘s))
theorem measure_theory.measure.exists_subset_measure_lt_top {Î± : Type u_1} {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {s : set Î±} [measure_theory.sigma_finite Î¼] {r : ennreal} (hs : measurable_set s) (h's : r < â‡‘Î¼ s) : âˆƒ (t : set Î±), measurable_set t âˆ§ t âŠ† s âˆ§ r < â‡‘Î¼ t âˆ§ â‡‘Î¼ t < âŠ¤
theorem nat.min_fac_sq_le_self {n : â„•} (w : 0 < n) (h : Â¬nat.prime n) : n.min_fac ^ 2 â‰¤ n
theorem squeeze_zero {Î± : Type u_1} {f g : Î± â†’ â„} {tâ‚€ : filter Î±} (hf : âˆ€ (t : Î±), 0 â‰¤ f t) (hft : âˆ€ (t : Î±), f t â‰¤ g t) (g0 : filter.tendsto g tâ‚€ (nhds 0)) : filter.tendsto f tâ‚€ (nhds 0)
theorem strict_concave_on.ae_eq_const_or_lt_map_average {Î± : Type u_1} {E : Type u_2} {m0 : measurable_space Î±} [normed_group E] [normed_space â„ E] [complete_space E] {Î¼ : measure_theory.measure Î±} {s : set E} {f : Î± â†’ E} {g : E â†’ â„} [measure_theory.is_finite_measure Î¼] (hg : strict_concave_on â„ s g) (hgc : continuous_on g s) (hsc : is_closed s) (hfs : âˆ€áµ (x : Î±) âˆ‚Î¼, f x âˆˆ s) (hfi : measure_theory.integrable f Î¼) (hgi : measure_theory.integrable (g âˆ˜ f) Î¼) : f =áµ[Î¼] function.const Î± (â¨ (x : Î±), f x âˆ‚Î¼) âˆ¨ â¨ (x : Î±), g (f x) âˆ‚Î¼ < g (â¨ (x : Î±), f x âˆ‚Î¼)
theorem measure_theory.simple_func.has_box_integral {Î¹ : Type u} {E : Type v} [fintype Î¹] [normed_group E] [normed_space â„ E] (f : measure_theory.simple_func (Î¹ â†’ â„) E) (Î¼ : measure_theory.measure (Î¹ â†’ â„)) [measure_theory.is_locally_finite_measure Î¼] (I : box_integral.box Î¹) (l : box_integral.integration_params) (hl : l.bRiemann = bool.ff) : box_integral.has_integral I l â‡‘f Î¼.to_box_additive.to_smul (measure_theory.simple_func.integral (Î¼.restrict â†‘I) f)
theorem category_theory.grothendieck_topology.arrow_max {C : Type u} [category_theory.category C] {X Y : C} (J : category_theory.grothendieck_topology C) (f : Y âŸ¶ X) (S : category_theory.sieve X) (hf : â‡‘S f) : J.covers S f
theorem strict_concave_on.slope_anti_adjacent {ğ•œ : Type u_1} [linear_ordered_field ğ•œ] {s : set ğ•œ} {f : ğ•œ â†’ ğ•œ} (hf : strict_concave_on ğ•œ s f) {x y z : ğ•œ} (hx : x âˆˆ s) (hz : z âˆˆ s) (hxy : x < y) (hyz : y < z) : (f z - f y) / (z - y) < (f y - f x) / (y - x)
theorem category_theory.has_colimits_of_reflective {C : Type uâ‚} [category_theory.category C] {D : Type uâ‚‚} [category_theory.category D] (R : D â¥¤ C) [category_theory.reflective R] [category_theory.limits.has_colimits_of_size C] : category_theory.limits.has_colimits_of_size D
theorem measure_theory.map_prod_mul_eq {G : Type u_1} [measurable_space G] [group G] [has_measurable_mulâ‚‚ G] (Î¼ Î½ : measure_theory.measure G) [measure_theory.sigma_finite Î½] [measure_theory.sigma_finite Î¼] [Î½.is_mul_left_invariant] : measure_theory.measure.map (Î» (z : G Ã— G), (z.fst, z.fst * z.snd)) (Î¼.prod Î½) = Î¼.prod Î½
theorem add_is_torsion.extension_closed {G : Type u_1} {H : Type u_2} [add_group G] {N : add_subgroup G} [add_group H] {f : G â†’+ H} (hN : N = f.ker) (tH : add_monoid.is_torsion H) (tN : add_monoid.is_torsion â†¥N) : add_monoid.is_torsion G
theorem finsum_mem_finset_product {Î± : Type u_1} {Î² : Type u_2} {M : Type u_5} [add_comm_monoid M] (s : finset (Î± Ã— Î²)) (f : Î± Ã— Î² â†’ M) : finsum (Î» (ab : Î± Ã— Î²), finsum (Î» (h : ab âˆˆ s), f ab)) = finsum (Î» (a : Î±), finsum (Î» (b : Î²), finsum (Î» (h : (a, b) âˆˆ s), f (a, b))))
theorem matrix.is_diag_one {Î± : Type u_1} {n : Type u_4} [decidable_eq n] [has_zero Î±] [has_one Î±] : 1.is_diag
theorem char_prime_of_ne_zero (R : Type u) [semiring R] [nontrivial R] [no_zero_divisors R] {p : â„•} [hp : char_p R p] (p_ne_zero : p â‰  0) : nat.prime p
theorem pgame.numeric_pow_half (n : â„•) : (pgame.pow_half n).numeric
theorem euclidean_geometry.dist_sq_eq_dist_sq_add_dist_sq_sub_two_mul_dist_mul_dist_mul_cos_angle {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] (p1 p2 p3 : P) : has_dist.dist p1 p3 * has_dist.dist p1 p3 = has_dist.dist p1 p2 * has_dist.dist p1 p2 + has_dist.dist p3 p2 * has_dist.dist p3 p2 - 2 * has_dist.dist p1 p2 * has_dist.dist p3 p2 * real.cos (euclidean_geometry.angle p1 p2 p3)
theorem multilinear_map.map_nonempty {R : Type u} {Î¹ : Type u'} {Mâ‚ : Î¹ â†’ Type vâ‚} {Mâ‚‚ : Type vâ‚‚} [decidable_eq Î¹] [ring R] [Î  (i : Î¹), add_comm_monoid (Mâ‚ i)] [add_comm_monoid Mâ‚‚] [Î  (i : Î¹), module R (Mâ‚ i)] [module R Mâ‚‚] [nonempty Î¹] (f : multilinear_map R Mâ‚ Mâ‚‚) (p : Î  (i : Î¹), submodule R (Mâ‚ i)) : â†‘(f.map p).nonempty
theorem subgroup.mul_mem {G : Type u_1} [group G] (H : subgroup G) {x y : G} : x âˆˆ H â†’ y âˆˆ H â†’ x * y âˆˆ H
theorem continuous_map.tendsto_iff_tendsto_locally_uniformly {Î± : Type uâ‚} {Î² : Type uâ‚‚} [topological_space Î±] [uniform_space Î²] {f : C(Î±, Î²)} {Î¹ : Type uâ‚ƒ} {p : filter Î¹} {F : Î¹ â†’ C(Î±, Î²)} [locally_compact_space Î±] : filter.tendsto F p (nhds f) â†” tendsto_locally_uniformly (Î» (i : Î¹) (a : Î±), â‡‘(F i) a) â‡‘f p
theorem tsum_mul_tsum_of_summable_norm {Î± : Type u_1} {Î¹ : Type u_4} {Î¹' : Type u_5} [normed_ring Î±] [complete_space Î±] {f : Î¹ â†’ Î±} {g : Î¹' â†’ Î±} (hf : summable (Î» (x : Î¹), âˆ¥f xâˆ¥)) (hg : summable (Î» (x : Î¹'), âˆ¥g xâˆ¥)) : (âˆ‘' (x : Î¹), f x) * âˆ‘' (y : Î¹'), g y = âˆ‘' (z : Î¹ Ã— Î¹'), f z.fst * g z.snd
theorem projectivization.ind {K : Type u_1} {V : Type u_2} [field K] [add_comm_group V] [module K V] {P : â„™ K V â†’ Prop} (h : âˆ€ (v : V) (h : v â‰  0), P (projectivization.mk K v h)) (p : â„™ K V) : P p
theorem measure_theory.ext_on_measurable_space_of_generate_finite {Î± : Type u_1} (mâ‚€ : measurable_space Î±) {Î¼ Î½ : measure_theory.measure Î±} [measure_theory.is_finite_measure Î¼] (C : set (set Î±)) (hÎ¼Î½ : âˆ€ (s : set Î±), s âˆˆ C â†’ â‡‘Î¼ s = â‡‘Î½ s) {m : measurable_space Î±} (h : m â‰¤ mâ‚€) (hA : m = measurable_space.generate_from C) (hC : is_pi_system C) (h_univ : â‡‘Î¼ set.univ = â‡‘Î½ set.univ) {s : set Î±} (hs : measurable_set s) : â‡‘Î¼ s = â‡‘Î½ s
theorem witt_vector.mul_n_is_poly (p : â„•) [hp : fact (nat.prime p)] (n : â„•) : witt_vector.is_poly p (Î» (R : Type u_1) (_Rcr : comm_ring R) (x : witt_vector p R), x * â†‘n)
theorem real.inner_le_Lp_mul_Lq_tsum_of_nonneg {Î¹ : Type u} {f g : Î¹ â†’ â„} {p q : â„} (hpq : p.is_conjugate_exponent q) (hf : âˆ€ (i : Î¹), 0 â‰¤ f i) (hg : âˆ€ (i : Î¹), 0 â‰¤ g i) (hf_sum : summable (Î» (i : Î¹), f i ^ p)) (hg_sum : summable (Î» (i : Î¹), g i ^ q)) : summable (Î» (i : Î¹), f i * g i) âˆ§ âˆ‘' (i : Î¹), f i * g i â‰¤ (âˆ‘' (i : Î¹), f i ^ p) ^ (1 / p) * (âˆ‘' (i : Î¹), g i ^ q) ^ (1 / q)
theorem category_theory.limits.has_limit_cospan_of_has_limit_pair_of_has_limit_parallel_pair {C : Type u} [ğ’ : category_theory.category C] {X Y Z : C} (f : X âŸ¶ Z) (g : Y âŸ¶ Z) [category_theory.limits.has_limit (category_theory.limits.pair X Y)] [category_theory.limits.has_limit (category_theory.limits.parallel_pair (category_theory.limits.prod.fst â‰« f) (category_theory.limits.prod.snd â‰« g))] : category_theory.limits.has_limit (category_theory.limits.cospan f g)
theorem is_greatest.union {Î³ : Type w} [linear_order Î³] {a b : Î³} {s t : set Î³} (ha : is_greatest s a) (hb : is_greatest t b) : is_greatest (s âˆª t) (linear_order.max a b)
theorem polynomial.chebyshev.U_complex_cos (Î¸ : â„‚) (n : â„•) : polynomial.eval (complex.cos Î¸) (polynomial.chebyshev.U â„‚ n) * complex.sin Î¸ = complex.sin ((â†‘n + 1) * Î¸)
theorem algebra.finite_presentation.of_surjective {R : Type u_1} {A : Type u_2} {B : Type u_3} [comm_ring R] [comm_ring A] [algebra R A] [comm_ring B] [algebra R B] {f : A â†’â‚[R] B} (hf : function.surjective â‡‘f) (hker : f.to_ring_hom.ker.fg) (hfp : algebra.finite_presentation R A) : algebra.finite_presentation R B
theorem strict_concave_on_iff_slope_strict_anti_adjacent {ğ•œ : Type u_1} [linear_ordered_field ğ•œ] {s : set ğ•œ} {f : ğ•œ â†’ ğ•œ} : strict_concave_on ğ•œ s f â†” convex ğ•œ s âˆ§ âˆ€ â¦ƒx y z : ğ•œâ¦„, x âˆˆ s â†’ z âˆˆ s â†’ x < y â†’ y < z â†’ (f z - f y) / (z - y) < (f y - f x) / (y - x)
theorem has_dvd.dvd.trans {Î± : Type u_1} [semigroup Î±] {a b c : Î±} : a âˆ£ b â†’ b âˆ£ c â†’ a âˆ£ c
theorem category_theory.limits.has_initial_of_unique {C : Type uâ‚} [category_theory.category C] (X : C) [h : Î  (Y : C), unique (X âŸ¶ Y)] : category_theory.limits.has_initial C
theorem add_units.mk_semiconj_by {M : Type u} [add_monoid M] (u : add_units M) (x : M) : add_semiconj_by â†‘u x (â†‘u + x + â†‘-u)
theorem bounded_continuous_function.dist_le_two_norm {Î± : Type u} {Î² : Type v} [topological_space Î±] [semi_normed_group Î²] (f : bounded_continuous_function Î± Î²) (x y : Î±) : has_dist.dist (â‡‘f x) (â‡‘f y) â‰¤ 2 * âˆ¥fâˆ¥
theorem orthonormal.eq_iff_norm_eq_and_oangle_eq_zero {V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) (x y : V) : x = y â†” âˆ¥xâˆ¥ = âˆ¥yâˆ¥ âˆ§ hb.oangle x y = 0
theorem measure_theory.lintegral_liminf_le' {Î± : Type u_1} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {f : â„• â†’ Î± â†’ ennreal} (h_meas : âˆ€ (n : â„•), ae_measurable (f n) Î¼) : âˆ«â» (a : Î±), filter.at_top.liminf (Î» (n : â„•), f n a) âˆ‚Î¼ â‰¤ filter.at_top.liminf (Î» (n : â„•), âˆ«â» (a : Î±), f n a âˆ‚Î¼)
theorem euclidean_geometry.exists_unique_dist_eq_of_insert {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace â„ P} [complete_space â†¥(s.direction)] {ps : set P} (hnps : ps.nonempty) {p : P} (hps : ps âŠ† â†‘s) (hp : p âˆ‰ s) (hu : âˆƒ! (cccr : P Ã— â„), cccr.fst âˆˆ s âˆ§ âˆ€ (p1 : P), p1 âˆˆ ps â†’ has_dist.dist p1 cccr.fst = cccr.snd) : âˆƒ! (cccrâ‚‚ : P Ã— â„), cccrâ‚‚.fst âˆˆ affine_span â„ (has_insert.insert p â†‘s) âˆ§ âˆ€ (p1 : P), p1 âˆˆ has_insert.insert p ps â†’ has_dist.dist p1 cccrâ‚‚.fst = cccrâ‚‚.snd
theorem module.End.generalized_eigenspace_restrict {R : Type v} {M : Type w} [comm_ring R] [add_comm_group M] [module R M] (f : module.End R M) (p : submodule R M) (k : â„•) (Î¼ : R) (hfp : âˆ€ (x : M), x âˆˆ p â†’ â‡‘f x âˆˆ p) : â‡‘(module.End.generalized_eigenspace (linear_map.restrict f hfp) Î¼) k = submodule.comap p.subtype (â‡‘(f.generalized_eigenspace Î¼) k)
theorem modular_group.exists_max_im (z : upper_half_plane) : âˆƒ (g : matrix.special_linear_group (fin 2) â„¤), âˆ€ (g' : matrix.special_linear_group (fin 2) â„¤), (g' â€¢ z).im â‰¤ (g â€¢ z).im
theorem formal_multilinear_series.comp_coeff_zero {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [comm_ring ğ•œ] [add_comm_group E] [add_comm_group F] [add_comm_group G] [module ğ•œ E] [module ğ•œ F] [module ğ•œ G] [topological_space E] [topological_space F] [topological_space G] [topological_add_group E] [has_continuous_const_smul ğ•œ E] [topological_add_group F] [has_continuous_const_smul ğ•œ F] [topological_add_group G] [has_continuous_const_smul ğ•œ G] (q : formal_multilinear_series ğ•œ F G) (p : formal_multilinear_series ğ•œ E F) (v : fin 0 â†’ E) (v' : fin 0 â†’ F) : â‡‘(q.comp p 0) v = â‡‘(q 0) v'
theorem box_integral.integrable.dist_integral_sum_le_of_mem_base_set {Î¹ : Type u} {E : Type v} {F : Type w} [normed_group E] [normed_space â„ E] [normed_group F] [normed_space â„ F] {I : box_integral.box Î¹} [fintype Î¹] {l : box_integral.integration_params} {f : (Î¹ â†’ â„) â†’ E} {vol : box_integral.box_additive_map Î¹ (E â†’L[â„] F) âŠ¤} {câ‚ câ‚‚ : nnreal} {Îµâ‚ Îµâ‚‚ : â„} {Ï€â‚ Ï€â‚‚ : box_integral.tagged_prepartition I} (h : box_integral.integrable I l f vol) (hposâ‚ : 0 < Îµâ‚) (hposâ‚‚ : 0 < Îµâ‚‚) (hâ‚ : l.mem_base_set I câ‚ (h.convergence_r Îµâ‚ câ‚) Ï€â‚) (hâ‚‚ : l.mem_base_set I câ‚‚ (h.convergence_r Îµâ‚‚ câ‚‚) Ï€â‚‚) (HU : Ï€â‚.Union = Ï€â‚‚.Union) : has_dist.dist (box_integral.integral_sum f vol Ï€â‚) (box_integral.integral_sum f vol Ï€â‚‚) â‰¤ Îµâ‚ + Îµâ‚‚
theorem ideal.polynomial_not_is_field {R : Type u} [ring R] : Â¬is_field (polynomial R)
theorem continuous.ae_strongly_measurable {Î± : Type u_1} {Î² : Type u_2} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [topological_space Î²] {f : Î± â†’ Î²} [topological_space Î±] [opens_measurable_space Î±] [topological_space.pseudo_metrizable_space Î²] [second_countable_topology_either Î± Î²] (hf : continuous f) : measure_theory.ae_strongly_measurable f Î¼
theorem is_fraction_ring.ideal_span_singleton_map_subset (R : Type u_1) [comm_ring R] {S : Type u_2} [comm_ring S] [algebra R S] {K : Type u_5} {L : Type u_3} [is_domain R] [is_domain S] [field K] [field L] [algebra R K] [algebra R L] [algebra S L] [is_integral_closure S R L] [is_fraction_ring S L] [algebra K L] [is_scalar_tower R S L] [is_scalar_tower R K L] {a : S} {b : set S} (alg : algebra.is_algebraic R L) (inj : function.injective â‡‘(algebra_map R L)) (h : â†‘(ideal.span {a}) âŠ† â†‘(submodule.span R b)) : â†‘(ideal.span {â‡‘(algebra_map S L) a}) âŠ† â†‘(submodule.span K (â‡‘(algebra_map S L) '' b))
theorem modular_group.tendsto_lc_row0 {cd : fin 2 â†’ â„¤} (hcd : is_coprime (cd 0) (cd 1)) : filter.tendsto (Î» (g : {g // â†‘g 1 = cd}), â‡‘(modular_group.lc_row0 cd) â†‘â†‘g) filter.cofinite (filter.cocompact â„)
theorem measure_theory.analytic_set.Inter {Î± : Type u_1} [topological_space Î±] {Î¹ : Type u_2} [hÎ¹ : nonempty Î¹] [encodable Î¹] [t2_space Î±] {s : Î¹ â†’ set Î±} (hs : âˆ€ (n : Î¹), measure_theory.analytic_set (s n)) : measure_theory.analytic_set (â‹‚ (n : Î¹), s n)
theorem measurable.lintegral_prod_left' {Î± : Type u_1} {Î² : Type u_3} [measurable_space Î±] [measurable_space Î²] {Î¼ : measure_theory.measure Î±} [measure_theory.sigma_finite Î¼] {f : Î± Ã— Î² â†’ ennreal} (hf : measurable f) : measurable (Î» (y : Î²), âˆ«â» (x : Î±), f (x, y) âˆ‚Î¼)
theorem equiv.perm.perm_congr_eq_mul {Î± : Type u} (e p : equiv.perm Î±) : â‡‘(equiv.perm_congr e) p = e * p * eâ»Â¹
theorem continuous_of_uniform_approx_of_continuous {Î± : Type u_1} {Î² : Type u_2} [uniform_space Î²] {f : Î± â†’ Î²} [topological_space Î±] (L : âˆ€ (u : set (Î² Ã— Î²)), u âˆˆ uniformity Î² â†’ (âˆƒ (F : Î± â†’ Î²), continuous F âˆ§ âˆ€ (y : Î±), (f y, F y) âˆˆ u)) : continuous f
theorem list.sorted_insertion_sort {Î± : Type uu} (r : Î± â†’ Î± â†’ Prop) [decidable_rel r] [is_total Î± r] [is_trans Î± r] (l : list Î±) : list.sorted r (list.insertion_sort r l)
theorem affine_subspace.mem_top (k : Type u_1) (V : Type u_2) {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] (p : P) : p âˆˆ âŠ¤
theorem midpoint_unique (R : Type u_1) {V : Type u_2} {P : Type u_4} [ring R] [invertible 2] [add_comm_group V] [module R V] [add_torsor V P] (R' : Type u_3) [ring R'] [invertible 2] [module R' V] (x y : P) : midpoint R x y = midpoint R' x y
theorem cont_diff_at.comp {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {G : Type u_4} [normed_group G] [normed_space ğ•œ G] {f : E â†’ F} {g : F â†’ G} {n : with_top â„•} (x : E) (hg : cont_diff_at ğ•œ n g (f x)) (hf : cont_diff_at ğ•œ n f x) : cont_diff_at ğ•œ n (g âˆ˜ f) x
theorem has_deriv_at.real_of_complex {e : â„‚ â†’ â„‚} {e' : â„‚} {z : â„} (h : has_deriv_at e e' â†‘z) : has_deriv_at (Î» (x : â„), (e â†‘x).re) e'.re z
theorem finprod_mem_union_inter' {Î± : Type u_1} {M : Type u_5} [comm_monoid M] {f : Î± â†’ M} {s t : set Î±} (hs : (s âˆ© function.mul_support f).finite) (ht : (t âˆ© function.mul_support f).finite) : finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s âˆª t), f i)) * finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s âˆ© t), f i)) = finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), f i)) * finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ t), f i))
theorem ring_hom.codomain_trivial_iff_range_eq_singleton_zero {Î± : Type u_2} {Î² : Type u_3} {rÎ± : non_assoc_semiring Î±} {rÎ² : non_assoc_semiring Î²} (f : Î± â†’+* Î²) : 0 = 1 â†” set.range â‡‘f = {0}
theorem affine_subspace.coe_direction_eq_vsub_set_right {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : affine_subspace k P} {p : P} (hp : p âˆˆ s) : â†‘(s.direction) = (Î» (_x : P), _x -áµ¥ p) '' â†‘s
theorem not_same_ray_iff_norm_add_lt {E : Type u_2} [normed_group E] [normed_space â„ E] [strict_convex_space â„ E] {x y : E} : Â¬same_ray â„ x y â†” âˆ¥x + yâˆ¥ < âˆ¥xâˆ¥ + âˆ¥yâˆ¥
theorem orientation.oangle_smul_right_of_neg {V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) (x y : V) {r : â„} (hr : r < 0) : o.oangle x (r â€¢ y) = o.oangle x (-y)
theorem norm_tsum_le_tsum_norm {Î¹ : Type u_1} {E : Type u_3} [semi_normed_group E] {f : Î¹ â†’ E} (hf : summable (Î» (i : Î¹), âˆ¥f iâˆ¥)) : âˆ¥âˆ‘' (i : Î¹), f iâˆ¥ â‰¤ âˆ‘' (i : Î¹), âˆ¥f iâˆ¥
theorem simplex_category.Î´_comp_Î´_self {n : â„•} {i : fin (n + 2)} : simplex_category.Î´ i â‰« simplex_category.Î´ (â‡‘fin.cast_succ i) = simplex_category.Î´ i â‰« simplex_category.Î´ i.succ
theorem uniform_space.completion.continuous_dist {Î± : Type u} {Î² : Type v} [pseudo_metric_space Î±] [topological_space Î²] {f g : Î² â†’ uniform_space.completion Î±} (hf : continuous f) (hg : continuous g) : continuous (Î» (x : Î²), has_dist.dist (f x) (g x))
theorem add_submonoid.closure_induction' {M : Type u_1} [add_zero_class M] (s : set M) {p : Î  (x : M), x âˆˆ add_submonoid.closure s â†’ Prop} (Hs : âˆ€ (x : M) (h : x âˆˆ s), p x _) (H1 : p 0 _) (Hmul : âˆ€ (x : M) (hx : x âˆˆ add_submonoid.closure s) (y : M) (hy : y âˆˆ add_submonoid.closure s), p x hx â†’ p y hy â†’ p (x + y) _) {x : M} (hx : x âˆˆ add_submonoid.closure s) : p x hx
theorem function.inv_on_fixed_pts_comp {Î± : Type u} {Î² : Type v} (f : Î± â†’ Î²) (g : Î² â†’ Î±) : set.inv_on f g (function.fixed_points (f âˆ˜ g)) (function.fixed_points (g âˆ˜ f))
theorem measure_theory.measure_eq_sub_vadd {G : Type u_1} [measurable_space G] [add_group G] [has_measurable_addâ‚‚ G] (Î¼ Î½ : measure_theory.measure G) [measure_theory.sigma_finite Î½] [measure_theory.sigma_finite Î¼] {E : set G} [has_measurable_neg G] [Î¼.is_add_left_invariant] [Î½.is_add_left_invariant] (hE : measurable_set E) (h2E : â‡‘Î½ E â‰  0) (h3E : â‡‘Î½ E â‰  âŠ¤) : Î¼ = (â‡‘Î¼ E / â‡‘Î½ E) â€¢ Î½
theorem polynomial.contraction_degree_eq_or_insep {F : Type} [field F] (q : â„•) [hq : fact (nat.prime q)] [char_p F q] (g g' : polynomial F) (m m' : â„•) (h_expand : â‡‘(polynomial.expand F (q ^ m)) g = â‡‘(polynomial.expand F (q ^ m')) g') (hg : g.separable) (hg' : g'.separable) : g.nat_degree = g'.nat_degree
theorem int.dvd_sub_of_mod_eq {a b c : â„¤} (h : a % b = c) : b âˆ£ a - c
theorem metric.inf_dist_le_Hausdorff_dist_of_mem {Î± : Type u} [pseudo_metric_space Î±] {s t : set Î±} {x : Î±} (hx : x âˆˆ s) (fin : emetric.Hausdorff_edist s t â‰  âŠ¤) : metric.inf_dist x t â‰¤ metric.Hausdorff_dist s t
theorem is_localization.card_le {R : Type u} [comm_ring R] (S : submonoid R) {L : Type u} [comm_ring L] [algebra R L] [is_localization S L] : cardinal.mk L â‰¤ cardinal.mk R
theorem tendsto_locally_uniformly_on_iff_tendsto_uniformly_on_of_compact {Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_4} [uniform_space Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : set Î±} {p : filter Î¹} [topological_space Î±] (hs : is_compact s) : tendsto_locally_uniformly_on F f p s â†” tendsto_uniformly_on F f p s
theorem Top.presheaf.compatible_iff_left_res_eq_right_res {X : Top} (F : Top.presheaf (Type v) X) {Î¹ : Type v} (U : Î¹ â†’ topological_space.opens â†¥X) (sf : Top.presheaf.sheaf_condition_equalizer_products.pi_opens F U) : F.is_compatible U ((F.pi_opens_iso_sections_family U).hom sf) â†” Top.presheaf.sheaf_condition_equalizer_products.left_res F U sf = Top.presheaf.sheaf_condition_equalizer_products.right_res F U sf
theorem fin.univ_cast_succ (n : â„•) : finset.univ = finset.cons (fin.last n) (finset.map fin.cast_succ.to_embedding finset.univ) _
theorem sub_div_sub_smul_slope_add_sub_div_sub_smul_slope {k : Type u_1} {E : Type u_2} {PE : Type u_3} [field k] [add_comm_group E] [module k E] [add_torsor E PE] (f : k â†’ PE) (a b c : k) : ((b - a) / (c - a)) â€¢ slope f a b + ((c - b) / (c - a)) â€¢ slope f b c = slope f a c
theorem vector_span_empty (k : Type u_1) {V : Type u_2} (P : Type u_3) [ring k] [add_comm_group V] [module k V] [add_torsor V P] : vector_span k âˆ… = âŠ¥
theorem continuous_linear_map.is_closed_image_coe_of_bounded_of_weak_closed {ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {F : Type u_6} [normed_group F] [nondiscrete_normed_field ğ•œ] [nondiscrete_normed_field ğ•œâ‚‚] [normed_space ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} {E' : Type u_10} [semi_normed_group E'] [normed_space ğ•œ E'] [ring_hom_isometric Ïƒâ‚â‚‚] {s : set (E' â†’SL[Ïƒâ‚â‚‚] F)} (hb : metric.bounded s) (hc : âˆ€ (f : E' â†’SL[Ïƒâ‚â‚‚] F), â‡‘f âˆˆ closure (coe_fn '' s) â†’ f âˆˆ s) : is_closed (coe_fn '' s)
theorem composition.sigma_eq_iff_blocks_eq {c c' : Î£ (n : â„•), composition n} : c = c' â†” c.snd.blocks = c'.snd.blocks
theorem has_dvd.dvd.nat_cast {Î± : Type u_1} [semiring Î±] {m n : â„•} (h : m âˆ£ n) : â†‘m âˆ£ â†‘n
theorem matrix.adjugate_mul_distrib {n : Type u} [decidable_eq n] [fintype n] {Î± : Type v} [comm_ring Î±] (A B : matrix n n Î±) : (A.mul B).adjugate = B.adjugate.mul A.adjugate
theorem monoid_with_zero_hom.ext_rat {M : Type u_4} [group_with_zero M] {f g : â„š â†’*â‚€ M} (same_on_int : f.comp (int.cast_ring_hom â„š).to_monoid_with_zero_hom = g.comp (int.cast_ring_hom â„š).to_monoid_with_zero_hom) : f = g
theorem fib_rec_char_poly_eq {Î² : Type u_1} [comm_ring Î²] : fib_rec.char_poly = polynomial.X ^ 2 - (polynomial.X + 1)
theorem category_theory.abelian.pseudoelement.pseudo_zero_aux {C : Type u} [category_theory.category C] [category_theory.abelian C] {P : C} (Q : C) (f : category_theory.over P) : f â‰ˆ â†‘0 â†” f.hom = 0
theorem pmf.bind_on_support_eq_bind {Î± : Type u_1} {Î² : Type u_2} (p : pmf Î±) (f : Î± â†’ pmf Î²) : p.bind_on_support (Î» (a : Î±) (_x : a âˆˆ p.support), f a) = p.bind f
theorem uv.is_compressed_self {Î± : Type u_1} [generalized_boolean_algebra Î±] [decidable_rel disjoint] [decidable_rel has_le.le] (u : Î±) (s : finset Î±) : uv.is_compressed u u s
theorem filter.tendsto.const_mul_at_top {Î± : Type u_3} {Î² : Type u_4} [linear_ordered_field Î±] {l : filter Î²} {f : Î² â†’ Î±} {r : Î±} (hr : 0 < r) (hf : filter.tendsto f l filter.at_top) : filter.tendsto (Î» (x : Î²), r * f x) l filter.at_top
theorem add_submonoid.add_mem {M : Type u_1} [add_zero_class M] (S : add_submonoid M) {x y : M} : x âˆˆ S â†’ y âˆˆ S â†’ x + y âˆˆ S
theorem minpoly.coeff_zero_ne_zero {A : Type u_1} {B : Type u_2} [field A] [ring B] [is_domain B] [algebra A B] {x : B} (hx : is_integral A x) (h : x â‰  0) : (minpoly A x).coeff 0 â‰  0
theorem monotone.set_prod {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [preorder Î±] {f : Î± â†’ set Î²} {g : Î± â†’ set Î³} (hf : monotone f) (hg : monotone g) : monotone (Î» (x : Î±), f x Ã—Ë¢ g x)
theorem emetric.mem_iff_inf_edist_zero_of_closed {Î± : Type u} [pseudo_emetric_space Î±] {x : Î±} {s : set Î±} (h : is_closed s) : x âˆˆ s â†” emetric.inf_edist x s = 0
theorem hall_matchings_on.nonempty {Î¹ : Type u} {Î± : Type v} [decidable_eq Î±] (t : Î¹ â†’ finset Î±) (h : âˆ€ (s : finset Î¹), s.card â‰¤ (s.bUnion t).card) (Î¹' : finset Î¹) : nonempty â†¥(hall_matchings_on t Î¹')
theorem affine.triangle.eq_orthocenter_of_forall_mem_altitude {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {t : affine.triangle â„ P} {iâ‚ iâ‚‚ : fin 3} {p : P} (hâ‚â‚‚ : iâ‚ â‰  iâ‚‚) (hâ‚ : p âˆˆ affine.simplex.altitude t iâ‚) (hâ‚‚ : p âˆˆ affine.simplex.altitude t iâ‚‚) : p = t.orthocenter
theorem inner_eq_sum_norm_sq_div_four {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] (x y : E) : has_inner.inner x y = (â†‘âˆ¥x + yâˆ¥ ^ 2 - â†‘âˆ¥x - yâˆ¥ ^ 2 + (â†‘âˆ¥x - is_R_or_C.I â€¢ yâˆ¥ ^ 2 - â†‘âˆ¥x + is_R_or_C.I â€¢ yâˆ¥ ^ 2) * is_R_or_C.I) / 4
theorem padic_norm.values_discrete (p : â„•) {q : â„š} (hq : q â‰  0) : âˆƒ (z : â„¤), padic_norm p q = â†‘p ^ -z
theorem inner_product_geometry.inner_eq_zero_iff_angle_eq_pi_div_two {V : Type u_1} [inner_product_space â„ V] (x y : V) : has_inner.inner x y = 0 â†” inner_product_geometry.angle x y = real.pi / 2
theorem convex_on_of_slope_mono_adjacent {ğ•œ : Type u_1} [linear_ordered_field ğ•œ] {s : set ğ•œ} {f : ğ•œ â†’ ğ•œ} (hs : convex ğ•œ s) (hf : âˆ€ {x y z : ğ•œ}, x âˆˆ s â†’ z âˆˆ s â†’ x < y â†’ y < z â†’ (f y - f x) / (y - x) â‰¤ (f z - f y) / (z - y)) : convex_on ğ•œ s f
theorem affine_independent.affine_span_eq_of_le_of_card_eq_finrank_add_one {k : Type u_1} {V : Type u_2} {P : Type u_3} {Î¹ : Type u_4} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] [fintype Î¹] {p : Î¹ â†’ P} (hi : affine_independent k p) {sp : affine_subspace k P} [finite_dimensional k â†¥(sp.direction)] (hle : affine_span k (set.range p) â‰¤ sp) (hc : fintype.card Î¹ = finite_dimensional.finrank k â†¥(sp.direction) + 1) : affine_span k (set.range p) = sp
theorem exists_unique_zsmul_near_of_pos {Î± : Type u_1} [linear_ordered_add_comm_group Î±] [archimedean Î±] {a : Î±} (ha : 0 < a) (g : Î±) : âˆƒ! (k : â„¤), k â€¢ a â‰¤ g âˆ§ g < (k + 1) â€¢ a
theorem local_ring.local_hom_tfae {R : Type u} {S : Type v} [comm_semiring R] [local_ring R] [comm_semiring S] [local_ring S] (f : R â†’+* S) : [is_local_ring_hom f, â‡‘f '' (local_ring.maximal_ideal R).carrier âŠ† â†‘(local_ring.maximal_ideal S), ideal.map f (local_ring.maximal_ideal R) â‰¤ local_ring.maximal_ideal S, local_ring.maximal_ideal R â‰¤ ideal.comap f (local_ring.maximal_ideal S), ideal.comap f (local_ring.maximal_ideal S) = local_ring.maximal_ideal R].tfae
theorem box_integral.prepartition.eventually_not_disjoint_imp_le_of_mem_split_many {Î¹ : Type u_1} [fintype Î¹] (s : finset (box_integral.box Î¹)) : âˆ€á¶  (t : finset (Î¹ Ã— â„)) in filter.at_top, âˆ€ (I J : box_integral.box Î¹), J âˆˆ s â†’ âˆ€ (J' : box_integral.box Î¹), J' âˆˆ box_integral.prepartition.split_many I t â†’ Â¬disjoint â†‘J â†‘J' â†’ J' â‰¤ J
theorem linear_map.injective_iff_surjective {K : Type u} {V : Type v} [field K] [add_comm_group V] [module K V] [finite_dimensional K V] {f : V â†’â‚—[K] V} : function.injective â‡‘f â†” function.surjective â‡‘f
theorem category_theory.abelian.pseudoelement.pseudo_exact_of_exact {C : Type u} [category_theory.category C] [category_theory.abelian C] {P Q R : C} {f : P âŸ¶ Q} {g : Q âŸ¶ R} (h : category_theory.exact f g) : (âˆ€ (a : â†¥P), â‡‘g (â‡‘f a) = 0) âˆ§ âˆ€ (b : â†¥Q), â‡‘g b = 0 â†’ (âˆƒ (a : â†¥P), â‡‘f a = b)
theorem metric.bounded.mono {Î± : Type u} [pseudo_metric_space Î±] {s t : set Î±} (incl : s âŠ† t) : metric.bounded t â†’ metric.bounded s
theorem measurable_set.exists_lt_is_compact_of_ne_top {Î± : Type u_1} [measurable_space Î±] [topological_space Î±] {Î¼ : measure_theory.measure Î±} [Î¼.regular] â¦ƒA : set Î±â¦„ (hA : measurable_set A) (h'A : â‡‘Î¼ A â‰  âŠ¤) {r : ennreal} (hr : r < â‡‘Î¼ A) : âˆƒ (K : set Î±) (H : K âŠ† A), is_compact K âˆ§ r < â‡‘Î¼ K
theorem finset.eq_of_card_le_one_of_sum_eq {Î² : Type u} {Î± : Type v} [add_comm_monoid Î²] {s : finset Î±} (hc : s.card â‰¤ 1) {f : Î± â†’ Î²} {b : Î²} (h : s.sum (Î» (x : Î±), f x) = b) (x : Î±) (H : x âˆˆ s) : f x = b
theorem fin.succ_above_ne {n : â„•} (p : fin (n + 1)) (i : fin n) : â‡‘(p.succ_above) i â‰  p
theorem exists_subset_Union_closure_subset {Î¹ : Type u_1} {X : Type u_2} [topological_space X] [normal_space X] {u : Î¹ â†’ set X} {s : set X} (hs : is_closed s) (uo : âˆ€ (i : Î¹), is_open (u i)) (uf : âˆ€ (x : X), x âˆˆ s â†’ {i : Î¹ | x âˆˆ u i}.finite) (us : s âŠ† â‹ƒ (i : Î¹), u i) : âˆƒ (v : Î¹ â†’ set X), s âŠ† set.Union v âˆ§ (âˆ€ (i : Î¹), is_open (v i)) âˆ§ âˆ€ (i : Î¹), closure (v i) âŠ† u i
theorem is_of_fin_add_order.neg {G : Type u} [add_group G] {x : G} (hx : is_of_fin_add_order x) : is_of_fin_add_order (-x)
theorem category_theory.grothendieck_topology.close_is_closed {C : Type u} [category_theory.category C] (Jâ‚ : category_theory.grothendieck_topology C) {X : C} (S : category_theory.sieve X) : Jâ‚.is_closed (Jâ‚.close S)
theorem linear_order.concave_on_of_lt {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [ordered_semiring ğ•œ] [add_comm_monoid E] [ordered_add_comm_monoid Î²] [module ğ•œ E] [module ğ•œ Î²] [linear_order E] {s : set E} {f : E â†’ Î²} (hs : convex ğ•œ s) (hf : âˆ€ â¦ƒx y : Eâ¦„, x âˆˆ s â†’ y âˆˆ s â†’ x < y â†’ âˆ€ â¦ƒa b : ğ•œâ¦„, 0 < a â†’ 0 < b â†’ a + b = 1 â†’ a â€¢ f x + b â€¢ f y â‰¤ f (a â€¢ x + b â€¢ y)) : concave_on ğ•œ s f
theorem measure_theory.induced_outer_measure_union_of_false_of_nonempty_inter {Î± : Type u_1} {P : set Î± â†’ Prop} {m : Î  (s : set Î±), P s â†’ ennreal} {P0 : P âˆ…} {m0 : m âˆ… P0 = 0} {s t : set Î±} (h : âˆ€ (u : set Î±), (s âˆ© u).nonempty â†’ (t âˆ© u).nonempty â†’ Â¬P u) : â‡‘(measure_theory.induced_outer_measure m P0 m0) (s âˆª t) = â‡‘(measure_theory.induced_outer_measure m P0 m0) s + â‡‘(measure_theory.induced_outer_measure m P0 m0) t
theorem colex.hom_fin_lt_iff {n : â„•} (A B : finset (fin n)) : (finset.image (Î» (i : fin n), â†‘i) A).to_colex < (finset.image (Î» (i : fin n), â†‘i) B).to_colex â†” A.to_colex < B.to_colex
theorem measure_theory.integral_integral_sub' {Î± : Type u_1} {Î² : Type u_3} {E : Type u_6} [measurable_space Î±] [measurable_space Î²] {Î¼ : measure_theory.measure Î±} {Î½ : measure_theory.measure Î²} [normed_group E] [measure_theory.sigma_finite Î½] [normed_space â„ E] [complete_space E] [measure_theory.sigma_finite Î¼] â¦ƒf g : Î± Ã— Î² â†’ Eâ¦„ (hf : measure_theory.integrable f (Î¼.prod Î½)) (hg : measure_theory.integrable g (Î¼.prod Î½)) : âˆ« (x : Î±), âˆ« (y : Î²), (f - g) (x, y) âˆ‚Î½ âˆ‚Î¼ = âˆ« (x : Î±), âˆ« (y : Î²), f (x, y) âˆ‚Î½ âˆ‚Î¼ - âˆ« (x : Î±), âˆ« (y : Î²), g (x, y) âˆ‚Î½ âˆ‚Î¼
theorem measure_theory.measure_Union_eq_supr {Î± : Type u_1} {Î¹ : Type u_5} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [encodable Î¹] {s : Î¹ â†’ set Î±} (hd : directed has_subset.subset s) : â‡‘Î¼ (â‹ƒ (i : Î¹), s i) = â¨† (i : Î¹), â‡‘Î¼ (s i)
theorem matrix.det_from_blocksâ‚â‚ {m : Type u} {n : Type u'} {Î± : Type v} [fintype n] [decidable_eq n] [comm_ring Î±] [fintype m] [decidable_eq m] (A : matrix m m Î±) (B : matrix m n Î±) (C : matrix n m Î±) (D : matrix n n Î±) [invertible A] : (matrix.from_blocks A B C D).det = A.det * (D - (C.mul (â…Ÿ A)).mul B).det
theorem measure_theory.submartingale.expected_stopped_value_mono {Î± : Type u_1} {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {ğ’¢ : measure_theory.filtration â„• m0} [measure_theory.sigma_finite_filtration Î¼ ğ’¢] {f : â„• â†’ Î± â†’ â„} (hf : measure_theory.submartingale f ğ’¢ Î¼) {Ï„ Ï€ : Î± â†’ â„•} (hÏ„ : measure_theory.is_stopping_time ğ’¢ Ï„) (hÏ€ : measure_theory.is_stopping_time ğ’¢ Ï€) (hle : Ï„ â‰¤ Ï€) {N : â„•} (hbdd : âˆ€ (x : Î±), Ï€ x â‰¤ N) : âˆ« (x : Î±), measure_theory.stopped_value f Ï„ x âˆ‚Î¼ â‰¤ âˆ« (x : Î±), measure_theory.stopped_value f Ï€ x âˆ‚Î¼
theorem submonoid.multiset_prod_mem {M : Type u_1} [comm_monoid M] (S : submonoid M) (m : multiset M) (hm : âˆ€ (a : M), a âˆˆ m â†’ a âˆˆ S) : m.prod âˆˆ S
theorem vector_span_image_eq_span_vsub_set_right_ne (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {Î¹ : Type u_4} (p : Î¹ â†’ P) {s : set Î¹} {i : Î¹} (hi : i âˆˆ s) : vector_span k (p '' s) = submodule.span k ((Î» (_x : P), _x -áµ¥ p i) '' (p '' (s  {i})))
theorem category_theory.triangulated.pretriangulated.triangulated_functor.map_distinguished {C : Type uâ‚} [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.has_shift C â„¤] [category_theory.preadditive C] [âˆ€ (n : â„¤), (category_theory.shift_functor C n).additive] {D : Type uâ‚‚} [category_theory.category D] [category_theory.limits.has_zero_object D] [category_theory.has_shift D â„¤] [category_theory.preadditive D] [âˆ€ (n : â„¤), (category_theory.shift_functor D n).additive] [category_theory.triangulated.pretriangulated C] [category_theory.triangulated.pretriangulated D] (F : category_theory.triangulated.pretriangulated.triangulated_functor C D) (T : category_theory.triangulated.triangle C) (h : T âˆˆ dist_triang C) : F.map_triangle.obj T âˆˆ dist_triang D
theorem nat.factorization_mul_support_of_coprime {a b : â„•} (hab : a.coprime b) : (a * b).factorization.support = a.factorization.support âˆª b.factorization.support
theorem module.End.has_generalized_eigenvalue_iff_has_eigenvalue {R : Type v} {M : Type w} [comm_ring R] [add_comm_group M] [module R M] {f : module.End R M} {Î¼ : R} {k : â„•} (hk : 0 < k) : f.has_generalized_eigenvalue Î¼ k â†” f.has_eigenvalue Î¼
theorem euclidean_geometry.angle_right_midpoint_eq_pi_div_two_of_dist_eq {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {p1 p2 p3 : P} (h : has_dist.dist p3 p1 = has_dist.dist p3 p2) : euclidean_geometry.angle p3 (midpoint â„ p1 p2) p2 = real.pi / 2
theorem affine_span_eq_affine_span_line_map_units {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] [nontrivial k] {s : set P} {p : P} (hp : p âˆˆ s) (w : â†¥s â†’ kË£) : affine_span k (set.range (Î» (q : â†¥s), â‡‘(affine_map.line_map p â†‘q) â†‘(w q))) = affine_span k s
theorem norm_sub_sq_eq_norm_sq_add_norm_sq_iff_real_inner_eq_zero {F : Type u_3} [inner_product_space â„ F] (x y : F) : âˆ¥x - yâˆ¥ * âˆ¥x - yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + âˆ¥yâˆ¥ * âˆ¥yâˆ¥ â†” has_inner.inner x y = 0
theorem antitone.pairwise_disjoint_on_Ico_pred {Î± : Type u_1} {Î² : Type u_2} [linear_order Î±] [pred_order Î±] [preorder Î²] {f : Î± â†’ Î²} (hf : antitone f) : pairwise (disjoint on Î» (n : Î±), set.Ico (f n) (f (order.pred n)))
theorem gaussian_int.prime_iff_mod_four_eq_three_of_nat_prime (p : â„•) [hp : fact (nat.prime p)] : prime â†‘p â†” p % 4 = 3
theorem inner_product_geometry.angle_smul_right_of_neg {V : Type u_1} [inner_product_space â„ V] (x y : V) {r : â„} (hr : r < 0) : inner_product_geometry.angle x (r â€¢ y) = inner_product_geometry.angle x (-y)
theorem eventually_nhds_iff {Î± : Type u} [topological_space Î±] {a : Î±} {p : Î± â†’ Prop} : (âˆ€á¶  (x : Î±) in nhds a, p x) â†” âˆƒ (t : set Î±), (âˆ€ (x : Î±), x âˆˆ t â†’ p x) âˆ§ is_open t âˆ§ a âˆˆ t
theorem subgroup.commutator_commutator_eq_bot_of_rotate {G : Type u_1} [group G] {Hâ‚ Hâ‚‚ Hâ‚ƒ : subgroup G} (h1 : â…â…Hâ‚‚,Hâ‚ƒâ†,Hâ‚â† = âŠ¥) (h2 : â…â…Hâ‚ƒ,Hâ‚â†,Hâ‚‚â† = âŠ¥) : â…â…Hâ‚,Hâ‚‚â†,Hâ‚ƒâ† = âŠ¥
theorem filter.eventually.eventually_nhds {Î± : Type u} [topological_space Î±] {p : Î± â†’ Prop} {a : Î±} (h : âˆ€á¶  (y : Î±) in nhds a, p y) : âˆ€á¶  (y : Î±) in nhds a, âˆ€á¶  (x : Î±) in nhds y, p x
theorem edist_le_of_edist_le_geometric_two_of_tendsto {Î± : Type u_1} [pseudo_emetric_space Î±] (C : ennreal) {f : â„• â†’ Î±} (hu : âˆ€ (n : â„•), has_edist.edist (f n) (f (n + 1)) â‰¤ C / 2 ^ n) {a : Î±} (ha : filter.tendsto f filter.at_top (nhds a)) (n : â„•) : has_edist.edist (f n) a â‰¤ 2 * C / 2 ^ n
theorem minpoly.one (A : Type u_1) (B : Type u_2) [field A] [ring B] [algebra A B] [nontrivial B] : minpoly A 1 = polynomial.X - 1
theorem cont_diff.fst {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {G : Type u_4} [normed_group G] [normed_space ğ•œ G] {n : with_top â„•} {f : E â†’ F Ã— G} (hf : cont_diff ğ•œ n f) : cont_diff ğ•œ n (Î» (x : E), (f x).fst)
theorem is_unit_iff_not_dvd_char (R : Type u_1) [comm_ring R] [fintype R] (p : â„•) [fact (nat.prime p)] : is_unit â†‘p â†” Â¬p âˆ£ ring_char R
theorem category_theory.idempotents.is_idempotent_complete_iff_idempotents_have_kernels (C : Type u_1) [category_theory.category C] [category_theory.preadditive C] : category_theory.is_idempotent_complete C â†” âˆ€ (X : C) (p : X âŸ¶ X), p â‰« p = p â†’ category_theory.limits.has_kernel p
theorem measure_theory.integral_eq_zero_of_add_right_eq_neg {G : Type u_4} {E : Type u_5} [measurable_space G] [normed_group E] [normed_space â„ E] [complete_space E] {Î¼ : measure_theory.measure G} {f : G â†’ E} {g : G} [add_group G] [has_measurable_add G] [Î¼.is_add_right_invariant] (hf' : âˆ€ (x : G), f (x + g) = -f x) : âˆ« (x : G), f x âˆ‚Î¼ = 0
theorem filter.map_coe_Iic_at_bot {Î± : Type u_3} [semilattice_inf Î±] (a : Î±) : filter.map coe filter.at_bot = filter.at_bot
theorem eckmann_hilton.mul_assoc {X : Type u} {mâ‚ mâ‚‚ : X â†’ X â†’ X} {eâ‚ eâ‚‚ : X} (hâ‚ : eckmann_hilton.is_unital mâ‚ eâ‚) (hâ‚‚ : eckmann_hilton.is_unital mâ‚‚ eâ‚‚) (distrib : âˆ€ (a b c d : X), mâ‚ (mâ‚‚ a b) (mâ‚‚ c d) = mâ‚‚ (mâ‚ a c) (mâ‚ b d)) : is_associative X mâ‚‚
theorem dense.of_closure {Î± : Type u} [topological_space Î±] {s : set Î±} : dense (closure s) â†’ dense s
theorem is_integrally_closed_iff {R : Type u_1} [comm_ring R] [is_domain R] (K : Type u_2) [field K] [algebra R K] [is_fraction_ring R K] : is_integrally_closed R â†” âˆ€ {x : K}, is_integral R x â†’ (âˆƒ (y : R), â‡‘(algebra_map R K) y = x)
theorem category_theory.is_pullback.paste_horiz {C : Type uâ‚} [category_theory.category C] {Xâ‚â‚ Xâ‚â‚‚ Xâ‚â‚ƒ Xâ‚‚â‚ Xâ‚‚â‚‚ Xâ‚‚â‚ƒ : C} {hâ‚â‚ : Xâ‚â‚ âŸ¶ Xâ‚â‚‚} {hâ‚â‚‚ : Xâ‚â‚‚ âŸ¶ Xâ‚â‚ƒ} {hâ‚‚â‚ : Xâ‚‚â‚ âŸ¶ Xâ‚‚â‚‚} {hâ‚‚â‚‚ : Xâ‚‚â‚‚ âŸ¶ Xâ‚‚â‚ƒ} {vâ‚â‚ : Xâ‚â‚ âŸ¶ Xâ‚‚â‚} {vâ‚â‚‚ : Xâ‚â‚‚ âŸ¶ Xâ‚‚â‚‚} {vâ‚â‚ƒ : Xâ‚â‚ƒ âŸ¶ Xâ‚‚â‚ƒ} (s : category_theory.is_pullback hâ‚â‚ vâ‚â‚ vâ‚â‚‚ hâ‚‚â‚) (t : category_theory.is_pullback hâ‚â‚‚ vâ‚â‚‚ vâ‚â‚ƒ hâ‚‚â‚‚) : category_theory.is_pullback (hâ‚â‚ â‰« hâ‚â‚‚) vâ‚â‚ vâ‚â‚ƒ (hâ‚‚â‚ â‰« hâ‚‚â‚‚)
theorem continuous_multilinear_map.op_norm_zero_iff {ğ•œ : Type u} {Î¹ : Type v} {E : Î¹ â†’ Type wE} {G : Type wG} [decidable_eq Î¹] [fintype Î¹] [nondiscrete_normed_field ğ•œ] [Î  (i : Î¹), normed_group (E i)] [Î  (i : Î¹), normed_space ğ•œ (E i)] [normed_group G] [normed_space ğ•œ G] (f : continuous_multilinear_map ğ•œ E G) : âˆ¥fâˆ¥ = 0 â†” f = 0
theorem linear_independent.comp {Î¹ : Type u_1} {Î¹' : Type u_2} {R : Type u_3} {M : Type u_5} {v : Î¹ â†’ M} [semiring R] [add_comm_monoid M] [module R M] (h : linear_independent R v) (f : Î¹' â†’ Î¹) (hf : function.injective f) : linear_independent R (v âˆ˜ f)
theorem is_locally_constant.desc {X : Type u_1} [topological_space X] {Î± : Type u_2} {Î² : Type u_3} (f : X â†’ Î±) (g : Î± â†’ Î²) (h : is_locally_constant (g âˆ˜ f)) (inj : function.injective g) : is_locally_constant f
theorem submodule.span_smul_eq_of_is_unit {R : Type u_1} {M : Type u_4} [semiring R] [add_comm_monoid M] [module R M] (s : set M) (r : R) (hr : is_unit r) : submodule.span R (r â€¢ s) = submodule.span R s
theorem csupr_le {Î± : Type u_1} {Î¹ : Sort u_3} [conditionally_complete_lattice Î±] [nonempty Î¹] {f : Î¹ â†’ Î±} {c : Î±} (H : âˆ€ (x : Î¹), f x â‰¤ c) : supr f â‰¤ c
theorem is_preconnected_iff_subset_of_disjoint {Î± : Type u} [topological_space Î±] {s : set Î±} : is_preconnected s â†” âˆ€ (u v : set Î±), is_open u â†’ is_open v â†’ s âŠ† u âˆª v â†’ s âˆ© (u âˆ© v) = âˆ… â†’ s âŠ† u âˆ¨ s âŠ† v
theorem continuous_map.to_Lp_norm_le {Î± : Type u_1} {E : Type u_2} {m0 : measurable_space Î±} {p : ennreal} (Î¼ : measure_theory.measure Î±) [normed_group E] [topological_space Î±] [borel_space Î±] [second_countable_topology_either Î± E] [compact_space Î±] [measure_theory.is_finite_measure Î¼] {ğ•œ : Type u_5} [fact (1 â‰¤ p)] [nondiscrete_normed_field ğ•œ] [normed_space ğ•œ E] : âˆ¥continuous_map.to_Lp p Î¼ ğ•œâˆ¥ â‰¤ â†‘(measure_theory.measure_univ_nnreal Î¼) ^ (p.to_real)â»Â¹
theorem is_local_min.fderiv_eq_zero {E : Type u} [normed_group E] [normed_space â„ E] {f : E â†’ â„} {a : E} (h : is_local_min f a) : fderiv â„ f a = 0
theorem norm_mk_zero {M : Type u_1} [semi_normed_group M] (S : add_subgroup M) : âˆ¥0âˆ¥ = 0
theorem seminorm.convex_on {ğ•œ : Type u_3} {E : Type u_4} [normed_field ğ•œ] [add_comm_group E] [normed_space â„ ğ•œ] [module ğ•œ E] [has_scalar â„ E] [is_scalar_tower â„ ğ•œ E] (p : seminorm ğ•œ E) : convex_on â„ set.univ â‡‘p
theorem nnreal.geom_mean_le_arith_mean2_weighted (wâ‚ wâ‚‚ pâ‚ pâ‚‚ : nnreal) : wâ‚ + wâ‚‚ = 1 â†’ pâ‚ ^ â†‘wâ‚ * pâ‚‚ ^ â†‘wâ‚‚ â‰¤ wâ‚ * pâ‚ + wâ‚‚ * pâ‚‚
theorem topological_space.countable_cover_nhds {Î± : Type u} [t : topological_space Î±] [topological_space.second_countable_topology Î±] {f : Î± â†’ set Î±} (hf : âˆ€ (x : Î±), f x âˆˆ nhds x) : âˆƒ (s : set Î±), s.countable âˆ§ (â‹ƒ (x : Î±) (H : x âˆˆ s), f x) = set.univ
theorem int.dvd_of_dvd_mul_right_of_gcd_one {a b c : â„¤} (habc : a âˆ£ b * c) (hab : a.gcd b = 1) : a âˆ£ c
theorem real.sq_sin_pi_div_three  : real.sin (real.pi / 3) ^ 2 = 3 / 4
theorem setoid.classes_inj {Î± : Type u_1} {râ‚ râ‚‚ : setoid Î±} : râ‚ = râ‚‚ â†” râ‚.classes = râ‚‚.classes
theorem alternating_group.normal_closure_fin_rotate_five  : subgroup.normal_closure {âŸ¨fin_rotate 5, _âŸ©} = âŠ¤
theorem linear_map.aeval_self_charpoly {R : Type u} {M : Type v} [comm_ring R] [nontrivial R] [add_comm_group M] [module R M] [module.free R M] [module.finite R M] (f : M â†’â‚—[R] M) : â‡‘(polynomial.aeval f) f.charpoly = 0
theorem linear_equiv.det_conj {R : Type u_1} [comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {M' : Type u_3} [add_comm_group M'] [module R M'] (f : M â‰ƒâ‚—[R] M) (e : M â‰ƒâ‚—[R] M') : â‡‘linear_equiv.det ((e.symm.trans f).trans e) = â‡‘linear_equiv.det f
theorem setoid.eq_of_mem_eqv_class {Î± : Type u_1} {c : set (set Î±)} (H : âˆ€ (a : Î±), âˆƒ! (b : set Î±) (H : b âˆˆ c), a âˆˆ b) {x : Î±} {b b' : set Î±} (hc : b âˆˆ c) (hb : x âˆˆ b) (hc' : b' âˆˆ c) (hb' : x âˆˆ b') : b = b'
theorem pgame.lf.lt {x y : pgame} (h : x.lf y) (ox : x.numeric) (oy : y.numeric) : x < y
theorem int.cast_inj_on_of_ring_char_ne_two {R : Type u_1} [non_assoc_ring R] [nontrivial R] (hR : ring_char R â‰  2) : set.inj_on coe {0, 1, -1}
theorem complete_lattice.independent.dfinsupp_sum_add_hom_injective {Î¹ : Type u_1} {N : Type u_5} [dec_Î¹ : decidable_eq Î¹] [add_comm_group N] {p : Î¹ â†’ add_subgroup N} (h : complete_lattice.independent p) : function.injective â‡‘(dfinsupp.sum_add_hom (Î» (i : Î¹), (p i).subtype))
theorem tendsto_inv_at_top_zero' {Î± : Type u} [linear_ordered_field Î±] [topological_space Î±] [order_topology Î±] : filter.tendsto (Î» (r : Î±), râ»Â¹) filter.at_top (nhds_within 0 (set.Ioi 0))
theorem quaternion_group.quaternion_group_one_is_cyclic  : is_cyclic (quaternion_group 1)
theorem matrix.map_smul' {n : Type u_3} {Î± : Type v} {Î² : Type w} [has_mul Î±] [has_mul Î²] (f : Î± â†’ Î²) (r : Î±) (A : matrix n n Î±) (hf : âˆ€ (aâ‚ aâ‚‚ : Î±), f (aâ‚ * aâ‚‚) = f aâ‚ * f aâ‚‚) : (r â€¢ A).map f = f r â€¢ A.map f
theorem is_nilpotent_pi_of_bounded_class {Î· : Type u_2} {Gs : Î· â†’ Type u_3} [Î  (i : Î·), group (Gs i)] [âˆ€ (i : Î·), group.is_nilpotent (Gs i)] (n : â„•) (h : âˆ€ (i : Î·), group.nilpotency_class (Gs i) â‰¤ n) : group.is_nilpotent (Î  (i : Î·), Gs i)
theorem ring.inverse_unit {Mâ‚€ : Type u_1} [monoid_with_zero Mâ‚€] (u : Mâ‚€Ë£) : ring.inverse â†‘u = â†‘uâ»Â¹
theorem formal_multilinear_series.le_radius_of_bound {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field ğ•œ] [normed_group E] [normed_space ğ•œ E] [normed_group F] [normed_space ğ•œ F] (p : formal_multilinear_series ğ•œ E F) (C : â„) {r : nnreal} (h : âˆ€ (n : â„•), âˆ¥p nâˆ¥ * â†‘r ^ n â‰¤ C) : â†‘r â‰¤ p.radius
theorem tangent_cone_congr {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {x : E} {s t : set E} (h : nhds_within x s = nhds_within x t) : tangent_cone_at ğ•œ s x = tangent_cone_at ğ•œ t x
theorem concave_on.slope_anti_adjacent {ğ•œ : Type u_1} [linear_ordered_field ğ•œ] {s : set ğ•œ} {f : ğ•œ â†’ ğ•œ} (hf : concave_on ğ•œ s f) {x y z : ğ•œ} (hx : x âˆˆ s) (hz : z âˆˆ s) (hxy : x < y) (hyz : y < z) : (f z - f y) / (z - y) â‰¤ (f y - f x) / (y - x)
theorem measure_theory.integral_integral {Î± : Type u_1} {Î² : Type u_3} {E : Type u_6} [measurable_space Î±] [measurable_space Î²] {Î¼ : measure_theory.measure Î±} {Î½ : measure_theory.measure Î²} [normed_group E] [measure_theory.sigma_finite Î½] [normed_space â„ E] [complete_space E] [measure_theory.sigma_finite Î¼] {f : Î± â†’ Î² â†’ E} (hf : measure_theory.integrable (function.uncurry f) (Î¼.prod Î½)) : âˆ« (x : Î±), âˆ« (y : Î²), f x y âˆ‚Î½ âˆ‚Î¼ = âˆ« (z : Î± Ã— Î²), f z.fst z.snd âˆ‚Î¼.prod Î½
theorem metric.frontier_thickening_subset {Î± : Type u} [pseudo_emetric_space Î±] (E : set Î±) {Î´ : â„} (Î´_pos : 0 < Î´) : frontier (metric.thickening Î´ E) âŠ† {x : Î± | emetric.inf_edist x E = ennreal.of_real Î´}
theorem unique_diff_on.prod {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {s : set E} {t : set F} (hs : unique_diff_on ğ•œ s) (ht : unique_diff_on ğ•œ t) : unique_diff_on ğ•œ (s Ã—Ë¢ t)
theorem monotone.mul_strict_mono' {Î± : Type u_1} {Î² : Type u_2} [has_mul Î±] [preorder Î±] [preorder Î²] [covariant_class Î± Î± has_mul.mul has_lt.lt] [covariant_class Î± Î± (function.swap has_mul.mul) has_le.le] {f g : Î² â†’ Î±} (hf : monotone f) (hg : strict_mono g) : strict_mono (Î» (x : Î²), f x * g x)
theorem filter.at_bot_Iio_eq {Î± : Type u_3} [semilattice_inf Î±] (a : Î±) : filter.at_bot = filter.comap coe filter.at_bot
theorem exp_char_is_prime_or_one (R : Type u) [semiring R] [nontrivial R] [no_zero_divisors R] (q : â„•) [hq : exp_char R q] : nat.prime q âˆ¨ q = 1
theorem commute.mul_left {S : Type u_1} [semigroup S] {a b c : S} (hac : commute a c) (hbc : commute b c) : commute (a * b) c
theorem emetric.Hausdorff_edist_closureâ‚‚ {Î± : Type u} [pseudo_emetric_space Î±] {s t : set Î±} : emetric.Hausdorff_edist s (closure t) = emetric.Hausdorff_edist s t
theorem add_semiconj_by.add_units_neg_right {M : Type u} [add_monoid M] {a : M} {x y : add_units M} (h : add_semiconj_by a â†‘x â†‘y) : add_semiconj_by a (â†‘-x) (â†‘-y)
theorem box_integral.prepartition.exists_tagged_le_is_Henstock_is_subordinate_Union_eq {Î¹ : Type u_1} [fintype Î¹] {I : box_integral.box Î¹} (r : (Î¹ â†’ â„) â†’ â†¥(set.Ioi 0)) (Ï€ : box_integral.prepartition I) : âˆƒ (Ï€' : box_integral.tagged_prepartition I), Ï€'.to_prepartition â‰¤ Ï€ âˆ§ Ï€'.is_Henstock âˆ§ Ï€'.is_subordinate r âˆ§ Ï€'.distortion = Ï€.distortion âˆ§ Ï€'.Union = Ï€.Union
theorem liouville_with_one (x : â„) : liouville_with 1 x
theorem measure_theory.integral_norm_le_of_forall_fin_meas_integral_eq {Î± : Type u_1} {m m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {s : set Î±} (hm : m â‰¤ m0) {f g : Î± â†’ â„} (hf : measure_theory.strongly_measurable f) (hfi : measure_theory.integrable_on f s Î¼) (hg : measure_theory.strongly_measurable g) (hgi : measure_theory.integrable_on g s Î¼) (hgf : âˆ€ (t : set Î±), measurable_set t â†’ â‡‘Î¼ t < âŠ¤ â†’ âˆ« (x : Î±) in t, g x âˆ‚Î¼ = âˆ« (x : Î±) in t, f x âˆ‚Î¼) (hs : measurable_set s) (hÎ¼s : â‡‘Î¼ s â‰  âŠ¤) : âˆ« (x : Î±) in s, âˆ¥g xâˆ¥ âˆ‚Î¼ â‰¤ âˆ« (x : Î±) in s, âˆ¥f xâˆ¥ âˆ‚Î¼
theorem nilpotency_class_le_of_surjective {G : Type u_1} [group G] {G' : Type u_2} [group G'] (f : G â†’* G') (hf : function.surjective â‡‘f) [h : group.is_nilpotent G] : group.nilpotency_class G' â‰¤ group.nilpotency_class G
theorem measurable_limsup {Î± : Type u_1} {Î´ : Type u_5} [topological_space Î±] [measurable_space Î±] [borel_space Î±] [measurable_space Î´] [complete_linear_order Î±] [order_topology Î±] [topological_space.second_countable_topology Î±] {f : â„• â†’ Î´ â†’ Î±} (hf : âˆ€ (i : â„•), measurable (f i)) : measurable (Î» (x : Î´), filter.at_top.limsup (Î» (i : â„•), f i x))
theorem uniform_space.completion.mem_uniformity_dist {Î± : Type u} [pseudo_metric_space Î±] (s : set (uniform_space.completion Î± Ã— uniform_space.completion Î±)) : s âˆˆ uniformity (uniform_space.completion Î±) â†” âˆƒ (Îµ : â„) (H : Îµ > 0), âˆ€ {a b : uniform_space.completion Î±}, has_dist.dist a b < Îµ â†’ (a, b) âˆˆ s
theorem orthonormal.two_zsmul_oangle_smul_right_self {V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) (x : V) {r : â„} : 2 â€¢ hb.oangle x (r â€¢ x) = 0
theorem convex.exists_nhds_within_lipschitz_on_with_of_has_fderiv_within_at {E : Type u_1} [normed_group E] [normed_space â„ E] {ğ•œ : Type u_3} {G : Type u_4} [is_R_or_C ğ•œ] [normed_space ğ•œ E] [normed_group G] [normed_space ğ•œ G] {s : set E} {x : E} {f' : E â†’ (E â†’L[ğ•œ] G)} (hs : convex â„ s) {f : E â†’ G} (hder : âˆ€á¶  (y : E) in nhds_within x s, has_fderiv_within_at f (f' y) s y) (hcont : continuous_within_at f' s x) : âˆƒ (K : nnreal) (t : set E) (H : t âˆˆ nhds_within x s), lipschitz_on_with K f t
theorem mul_equiv.symm_apply_apply {M : Type u_6} {N : Type u_7} [has_mul M] [has_mul N] (e : M â‰ƒ* N) (x : M) : â‡‘(e.symm) (â‡‘e x) = x
theorem normed_space.smul_mem_polar {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [semi_normed_group E] [normed_space ğ•œ E] {s : set E} {x' : normed_space.dual ğ•œ E} {c : ğ•œ} (hc : âˆ€ (z : E), z âˆˆ s â†’ âˆ¥â‡‘x' zâˆ¥ â‰¤ âˆ¥câˆ¥) : câ»Â¹ â€¢ x' âˆˆ normed_space.polar ğ•œ s
theorem left.add_pos_of_pos_of_nonneg {Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : 0 < a) (hb : 0 â‰¤ b) : 0 < a + b
theorem tsub_tsub_cancel_of_le {Î± : Type u_1} [canonically_ordered_add_monoid Î±] [has_sub Î±] [has_ordered_sub Î±] {a b : Î±} [contravariant_class Î± Î± has_add.add has_le.le] (h : a â‰¤ b) : b - (b - a) = a
theorem lie_algebra.is_nilpotent_range_ad_iff {R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] : lie_algebra.is_nilpotent R â†¥((lie_algebra.ad R L).range) â†” lie_algebra.is_nilpotent R L
theorem euclidean_geometry.cospherical_subset {P : Type u_2} [metric_space P] {psâ‚ psâ‚‚ : set P} (hs : psâ‚ âŠ† psâ‚‚) (hc : euclidean_geometry.cospherical psâ‚‚) : euclidean_geometry.cospherical psâ‚
theorem real.cos_pi_div_six  : real.cos (real.pi / 6) = real.sqrt 3 / 2
theorem convex.lipschitz_on_with_of_nnnorm_has_fderiv_within_le {E : Type u_1} [normed_group E] [normed_space â„ E] {ğ•œ : Type u_3} {G : Type u_4} [is_R_or_C ğ•œ] [normed_space ğ•œ E] [normed_group G] [normed_space ğ•œ G] {f : E â†’ G} {s : set E} {f' : E â†’ (E â†’L[ğ•œ] G)} {C : nnreal} (hf : âˆ€ (x : E), x âˆˆ s â†’ has_fderiv_within_at f (f' x) s x) (bound : âˆ€ (x : E), x âˆˆ s â†’ âˆ¥f' xâˆ¥â‚Š â‰¤ C) (hs : convex â„ s) : lipschitz_on_with C f s
theorem pgame.le_zero_lf {x : pgame} : x â‰¤ 0 â†” âˆ€ (i : x.left_moves), (x.move_left i).lf 0
theorem cont_diff_top_iff_fderiv {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {f : E â†’ F} : cont_diff ğ•œ âŠ¤ f â†” differentiable ğ•œ f âˆ§ cont_diff ğ•œ âŠ¤ (Î» (y : E), fderiv ğ•œ f y)
theorem monoid_algebra.mem_closure_of_mem_span_closure {R : Type u_1} {M : Type u_2} [comm_ring R] [comm_monoid M] [nontrivial R] {m : M} {S : set M} (h : â‡‘(monoid_algebra.of R M) m âˆˆ submodule.span R â†‘(submonoid.closure (â‡‘(monoid_algebra.of R M) '' S))) : m âˆˆ submonoid.closure S
theorem category_theory.is_filtered.to_sup_commutes {C : Type u} [category_theory.category C] [category_theory.is_filtered C] (O : finset C) (H : finset (Î£' (X Y : C) (mX : X âˆˆ O) (mY : Y âˆˆ O), X âŸ¶ Y)) {X Y : C} (mX : X âˆˆ O) (mY : Y âˆˆ O) {f : X âŸ¶ Y} (mf : âŸ¨X, âŸ¨Y, âŸ¨mX, âŸ¨mY, fâŸ©âŸ©âŸ©âŸ© âˆˆ H) : f â‰« category_theory.is_filtered.to_sup O H mY = category_theory.is_filtered.to_sup O H mX
theorem torus_integrable.neg {n : â„•} {E : Type u_1} [normed_group E] {f : (fin n â†’ â„‚) â†’ E} {c : fin n â†’ â„‚} {R : fin n â†’ â„} (hf : torus_integrable f c R) : torus_integrable (-f) c R
theorem is_cyclotomic_extension.norm_zeta_eq_one {n : â„•+} {K : Type u} (L : Type v) [field K] [field L] [algebra K L] [ne_zero â†‘â†‘n] [is_cyclotomic_extension {n} K L] (hn : n â‰  2) (hirr : irreducible (polynomial.cyclotomic â†‘n K)) : â‡‘(algebra.norm K) (is_cyclotomic_extension.zeta n K L) = 1
theorem polynomial.degree_cyclotomic' {R : Type u_1} [comm_ring R] [is_domain R] {Î¶ : R} {n : â„•} (h : is_primitive_root Î¶ n) : (polynomial.cyclotomic' n R).degree = â†‘(n.totient)
theorem con.mk'_surjective {M : Type u_1} [mul_one_class M] {c : con M} : function.surjective â‡‘(c.mk')
theorem is_dedekind_domain.height_one_spectrum.int_valuation_ne_zero' {R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] (v : is_dedekind_domain.height_one_spectrum R) (x : â†¥(non_zero_divisors R)) : v.int_valuation_def â†‘x â‰  0
theorem cont_diff_on.prod {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {G : Type u_4} [normed_group G] [normed_space ğ•œ G] {n : with_top â„•} {s : set E} {f : E â†’ F} {g : E â†’ G} (hf : cont_diff_on ğ•œ n f s) (hg : cont_diff_on ğ•œ n g s) : cont_diff_on ğ•œ n (Î» (x : E), (f x, g x)) s
theorem maximal_linear_independent_eq_infinite_basis {R : Type u} [ring R] [strong_rank_condition R] {M : Type v} [add_comm_group M] [module R M] {Î¹ : Type u_1} (b : basis Î¹ R M) [infinite Î¹] {Îº : Type u_1} (v : Îº â†’ M) (i : linear_independent R v) (m : i.maximal) : cardinal.mk Îº = cardinal.mk Î¹
theorem monotone.monotone_iterate_of_le_map {Î± : Type u_1} [preorder Î±] {f : Î± â†’ Î±} {x : Î±} (hf : monotone f) (hx : x â‰¤ f x) : monotone (Î» (n : â„•), f^[n] x)
theorem ennreal.cancel_of_lt' {a b : ennreal} (h : a < b) : add_le_cancellable a
theorem probability_theory.lintegral_mul_indicator_eq_lintegral_mul_lintegral_indicator {Î± : Type u_1} {f : Î± â†’ ennreal} {Mf mÎ± : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (hMf : Mf â‰¤ mÎ±) (c : ennreal) {T : set Î±} (h_meas_T : measurable_set T) (h_ind : probability_theory.indep_sets {s : set Î± | measurable_set s} {T} Î¼) (h_meas_f : measurable f) : âˆ«â» (a : Î±), f a * T.indicator (Î» (_x : Î±), c) a âˆ‚Î¼ = âˆ«â» (a : Î±), f a âˆ‚Î¼ * âˆ«â» (a : Î±), T.indicator (Î» (_x : Î±), c) a âˆ‚Î¼
theorem surjective_quot_mk {Î± : Sort u_1} (r : Î± â†’ Î± â†’ Prop) : function.surjective (quot.mk r)
theorem finset.exists_card_fiber_lt_of_card_lt_nsmul {Î± : Type u} {Î² : Type v} {M : Type w} [decidable_eq Î²] {s : finset Î±} {t : finset Î²} {f : Î± â†’ Î²} {b : M} [linear_ordered_comm_ring M] (ht : â†‘(s.card) < t.card â€¢ b) : âˆƒ (y : Î²) (H : y âˆˆ t), â†‘((finset.filter (Î» (x : Î±), f x = y) s).card) < b
theorem continuous_map.polynomial_comp_attach_bound_mem {X : Type u_1} [topological_space X] [compact_space X] (A : subalgebra â„ C(X, â„)) (f : â†¥A) (g : polynomial â„) : (g.to_continuous_map_on (set.Icc (-âˆ¥fâˆ¥) âˆ¥fâˆ¥)).comp â†‘f.attach_bound âˆˆ A
theorem convex_hull_diam {E : Type u_2} [semi_normed_group E] [normed_space â„ E] (s : set E) : metric.diam (â‡‘(convex_hull â„) s) = metric.diam s
theorem nilpotency_class_quotient_center {G : Type u_1} [group G] [hH : group.is_nilpotent G] : group.nilpotency_class (G â§¸ subgroup.center G) = group.nilpotency_class G - 1
theorem orientation.oangle_add_cyc3 {V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) {x y z : V} (hx : x â‰  0) (hy : y â‰  0) (hz : z â‰  0) : o.oangle x y + o.oangle y z + o.oangle z x = 0
theorem orthonormal.rotation_oangle_eq_iff_norm_eq {V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) (x y : V) : â‡‘(hb.rotation (hb.oangle x y)) x = y â†” âˆ¥xâˆ¥ = âˆ¥yâˆ¥
theorem zmod.Ï‡â‚„_int_eq_if_mod_four (n : â„¤) : â‡‘zmod.Ï‡â‚„ â†‘n = ite (n % 2 = 0) 0 (ite (n % 4 = 1) 1 (-1))
theorem has_mfderiv_at.comp {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners ğ•œ E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] {E'' : Type u_8} [normed_group E''] [normed_space ğ•œ E''] {H'' : Type u_9} [topological_space H''] {I'' : model_with_corners ğ•œ E'' H''} {M'' : Type u_10} [topological_space M''] [charted_space H'' M''] {f : M â†’ M'} (x : M) {g : M' â†’ M''} [Is : smooth_manifold_with_corners I M] [I's : smooth_manifold_with_corners I' M'] [I''s : smooth_manifold_with_corners I'' M''] {f' : tangent_space I x â†’L[ğ•œ] tangent_space I' (f x)} {g' : tangent_space I' (f x) â†’L[ğ•œ] tangent_space I'' (g (f x))} (hg : has_mfderiv_at I' I'' g (f x) g') (hf : has_mfderiv_at I I' f x f') : has_mfderiv_at I I'' (g âˆ˜ f) x (g'.comp f')
theorem discrete_topology.of_subset {X : Type u_1} [topological_space X] {s t : set X} (ds : discrete_topology â†¥s) (ts : t âŠ† s) : discrete_topology â†¥t
theorem pow_eq_pow_mod {M : Type u_1} [monoid M] {x : M} (m : â„•) {n : â„•} (h : x ^ n = 1) : x ^ m = x ^ (m % n)
theorem partition_of_unity.exists_is_subordinate {Î¹ : Type u} {X : Type v} [topological_space X] {s : set X} [normal_space X] [paracompact_space X] (hs : is_closed s) (U : Î¹ â†’ set X) (ho : âˆ€ (i : Î¹), is_open (U i)) (hU : s âŠ† â‹ƒ (i : Î¹), U i) : âˆƒ (f : partition_of_unity Î¹ X s), f.is_subordinate U
theorem polynomial.card_pow_degree_anti_archimedean {Fq : Type u_1} [fintype Fq] [field Fq] {x y z : polynomial Fq} {a : â„¤} (hxy : â‡‘polynomial.card_pow_degree (x - y) < a) (hyz : â‡‘polynomial.card_pow_degree (y - z) < a) : â‡‘polynomial.card_pow_degree (x - z) < a
theorem direct_sum.is_internal.submodule_independent {R : Type u} [semiring R] {Î¹ : Type v} [dec_Î¹ : decidable_eq Î¹] {M : Type u_1} [add_comm_monoid M] [module R M] {A : Î¹ â†’ submodule R M} (h : direct_sum.is_internal A) : complete_lattice.independent A
theorem pgame.relabelling.equiv {x y : pgame} (r : x.relabelling y) : x.equiv y
theorem linear_map.finrank_range_of_inj {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {Vâ‚‚ : Type v'} [add_comm_group Vâ‚‚] [module K Vâ‚‚] {f : V â†’â‚—[K] Vâ‚‚} (hf : function.injective â‡‘f) : finite_dimensional.finrank K â†¥(f.range) = finite_dimensional.finrank K V
theorem is_add_monoid_hom.is_add_monoid_hom_mul_left {Î³ : Type u_1} [non_unital_non_assoc_semiring Î³] (x : Î³) : is_add_monoid_hom (Î» (y : Î³), x * y)
theorem affine_map.continuous_iff {R : Type u_1} {E : Type u_2} {F : Type u_3} [add_comm_group E] [topological_space E] [add_comm_group F] [topological_space F] [topological_add_group F] [ring R] [module R E] [module R F] {f : E â†’áµƒ[R] F} : continuous â‡‘f â†” continuous â‡‘(f.linear)
theorem closure_Iio {Î± : Type u} [topological_space Î±] [linear_order Î±] [order_topology Î±] [densely_ordered Î±] (a : Î±) [no_min_order Î±] : closure (set.Iio a) = set.Iic a
theorem formal_multilinear_series.nnnorm_mul_pow_le_of_lt_radius {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field ğ•œ] [normed_group E] [normed_space ğ•œ E] [normed_group F] [normed_space ğ•œ F] (p : formal_multilinear_series ğ•œ E F) {r : nnreal} (h : â†‘r < p.radius) : âˆƒ (C : nnreal) (H : C > 0), âˆ€ (n : â„•), âˆ¥p nâˆ¥â‚Š * r ^ n â‰¤ C
theorem add_neg_of_nonpos_of_neg {Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b : Î±} (ha : a â‰¤ 0) (hb : b < 0) : a + b < 0
theorem topological_space.second_countable_topology_induced (Î± : Type u) (Î² : Type u_1) [t : topological_space Î²] [topological_space.second_countable_topology Î²] (f : Î± â†’ Î²) : topological_space.second_countable_topology Î±
theorem image_norm_le_of_norm_deriv_right_le_deriv_boundary {E : Type u_1} [normed_group E] [normed_space â„ E] {f : â„ â†’ E} {a b : â„} {f' : â„ â†’ E} (hf : continuous_on f (set.Icc a b)) (hf' : âˆ€ (x : â„), x âˆˆ set.Ico a b â†’ has_deriv_within_at f (f' x) (set.Ici x) x) {B B' : â„ â†’ â„} (ha : âˆ¥f aâˆ¥ â‰¤ B a) (hB : âˆ€ (x : â„), has_deriv_at B (B' x) x) (bound : âˆ€ (x : â„), x âˆˆ set.Ico a b â†’ âˆ¥f' xâˆ¥ â‰¤ B' x) â¦ƒx : â„â¦„ : x âˆˆ set.Icc a b â†’ âˆ¥f xâˆ¥ â‰¤ B x
theorem is_clopen.frontier_eq {Î± : Type u} [topological_space Î±] {s : set Î±} : is_clopen s â†’ frontier s = âˆ…
theorem cSup_eq_of_is_forall_le_of_forall_le_imp_ge {Î± : Type u_1} [conditionally_complete_lattice Î±] {s : set Î±} {b : Î±} (hs : s.nonempty) (h_is_ub : âˆ€ (a : Î±), a âˆˆ s â†’ a â‰¤ b) (h_b_le_ub : âˆ€ (ub : Î±), (âˆ€ (a : Î±), a âˆˆ s â†’ a â‰¤ ub) â†’ b â‰¤ ub) : has_Sup.Sup s = b
theorem measurable_of_tendsto_metrizable {Î± : Type u_1} {Î² : Type u_2} [measurable_space Î±] [topological_space Î²] [topological_space.pseudo_metrizable_space Î²] [measurable_space Î²] [borel_space Î²] {f : â„• â†’ Î± â†’ Î²} {g : Î± â†’ Î²} (hf : âˆ€ (i : â„•), measurable (f i)) (lim : filter.tendsto f filter.at_top (nhds g)) : measurable g
theorem locally_finite.finite_of_compact {Î± : Type u} [topological_space Î±] {Î¹ : Type u_1} [compact_space Î±] {f : Î¹ â†’ set Î±} (hf : locally_finite f) (hne : âˆ€ (i : Î¹), (f i).nonempty) : set.univ.finite
theorem is_integrally_closed_iff_is_integral_closure {R : Type u_1} [comm_ring R] [is_domain R] (K : Type u_2) [field K] [algebra R K] [is_fraction_ring R K] : is_integrally_closed R â†” is_integral_closure R R K
theorem fractional_ideal.exists_ne_zero_mem_is_integer {R : Type u_1} [comm_ring R] {K : Type u_3} [field K] [algebra R K] [is_fraction_ring R K] {I : fractional_ideal (non_zero_divisors R) K} [nontrivial R] (hI : I â‰  0) : âˆƒ (x : R) (H : x â‰  0), â‡‘(algebra_map R K) x âˆˆ I
theorem simple_graph.is_SRG_with.card_neighbor_finset_union_of_not_adj {V : Type u} [fintype V] [decidable_eq V] {G : simple_graph V} [decidable_rel G.adj] {n k â„“ Î¼ : â„•} {v w : V} (h : G.is_SRG_with n k â„“ Î¼) (hne : v â‰  w) (ha : Â¬G.adj v w) : (G.neighbor_finset v âˆª G.neighbor_finset w).card = 2 * k - Î¼
theorem has_compact_support.continuous_convolution_right {ğ•œ : Type u_1} {G : Type u_2} {E : Type u_3} {E' : Type u_4} {F : Type u_6} [normed_group E] [normed_group E'] [normed_group F] {f : G â†’ E} {g : G â†’ E'} [nondiscrete_normed_field ğ•œ] [normed_space ğ•œ E] [normed_space ğ•œ E'] [normed_space ğ•œ F] (L : E â†’L[ğ•œ] E' â†’L[ğ•œ] F) [measurable_space G] {Î¼ : measure_theory.measure G} [normed_space â„ F] [complete_space F] [add_group G] [topological_space G] [topological_add_group G] [borel_space G] [topological_space.second_countable_topology G] [locally_compact_space G] [t2_space G] (hcg : has_compact_support g) (hf : measure_theory.locally_integrable f Î¼) (hg : continuous g) : continuous (convolution f g L Î¼)
theorem cont_diff.snd {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {G : Type u_4} [normed_group G] [normed_space ğ•œ G] {n : with_top â„•} {f : E â†’ F Ã— G} (hf : cont_diff ğ•œ n f) : cont_diff ğ•œ n (Î» (x : E), (f x).snd)
theorem lie_algebra.is_engelian_of_is_noetherian {R : Type uâ‚} {L : Type uâ‚‚} [comm_ring R] [lie_ring L] [lie_algebra R L] [is_noetherian R L] : lie_algebra.is_engelian R L
theorem pi.single_apply {I : Type u} [decidable_eq I] {Î² : Type u_1} [has_zero Î²] (i : I) (x : Î²) (i' : I) : pi.single i x i' = ite (i' = i) x 0
theorem matrix.det_fin_one {R : Type v} [comm_ring R] (A : matrix (fin 1) (fin 1) R) : A.det = A 0 0
theorem list.drop_take_succ_join_eq_nth_le {Î± : Type u_1} (L : list (list Î±)) {i : â„•} (hi : i < L.length) : list.drop (list.take i (list.map list.length L)).sum (list.take (list.take (i + 1) (list.map list.length L)).sum L.join) = L.nth_le i hi
theorem exists_open_nhds_zero_add_subset {M : Type u_4} [topological_space M] [add_monoid M] [has_continuous_add M] {U : set M} (hU : U âˆˆ nhds 0) : âˆƒ (V : set M), is_open V âˆ§ 0 âˆˆ V âˆ§ V + V âŠ† U
theorem sum_Ico_pow (n p : â„•) : (finset.Ico 1 (n + 1)).sum (Î» (k : â„•), â†‘k ^ p) = (finset.range (p + 1)).sum (Î» (i : â„•), bernoulli' i * â†‘((p + 1).choose i) * â†‘n ^ (p + 1 - i) / (â†‘p + 1))
theorem algebra.finite_presentation.of_finite_type {R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] [is_noetherian_ring R] : algebra.finite_type R A â†” algebra.finite_presentation R A
theorem is_closed.is_clopenable {Î± : Type u_1} [topological_space Î±] [polish_space Î±] {s : set Î±} (hs : is_closed s) : polish_space.is_clopenable s
theorem generalized_continued_fraction.abs_sub_convergents_le' {K : Type u_1} {v : K} {n : â„•} [linear_ordered_field K] [floor_ring K] {b : K} (nth_part_denom_eq : (generalized_continued_fraction.of v).partial_denominators.nth n = option.some b) : |v - (generalized_continued_fraction.of v).convergents n| â‰¤ 1 / (b * (generalized_continued_fraction.of v).denominators n * (generalized_continued_fraction.of v).denominators n)
theorem cont_mdiff_within_at.prod_map' {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners ğ•œ E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] {F : Type u_8} [normed_group F] [normed_space ğ•œ F] {G : Type u_9} [topological_space G] {J : model_with_corners ğ•œ F G} {N : Type u_10} [topological_space N] [charted_space G N] {F' : Type u_11} [normed_group F'] [normed_space ğ•œ F'] {G' : Type u_12} [topological_space G'] {J' : model_with_corners ğ•œ F' G'} {N' : Type u_13} [topological_space N'] [charted_space G' N'] {f : M â†’ M'} {s : set M} {n : with_top â„•} {g : N â†’ N'} {r : set N} {p : M Ã— N} (hf : cont_mdiff_within_at I I' n f s p.fst) (hg : cont_mdiff_within_at J J' n g r p.snd) : cont_mdiff_within_at (I.prod J) (I'.prod J') n (prod.map f g) (s Ã—Ë¢ r) p
theorem category_theory.limits.complete_lattice.finite_product_eq_finset_inf {Î± : Type u} [semilattice_inf Î±] [order_top Î±] {Î¹ : Type u} [fintype Î¹] (f : Î¹ â†’ Î±) : (âˆ f) = (fintype.elems Î¹).inf f
theorem isometry.uniform_inducing {Î± : Type u} {Î² : Type v} [pseudo_emetric_space Î±] [pseudo_emetric_space Î²] {f : Î± â†’ Î²} (hf : isometry f) : uniform_inducing f
theorem pnat.factor_multiset_one  : 1.factor_multiset = 0
theorem is_atom.dual {Î± : Type u_1} [preorder Î±] [order_bot Î±] {a : Î±} : is_atom a â†’ is_coatom (â‡‘order_dual.to_dual a)
theorem has_ssubset.ssubset.asymm {Î± : Type u} [has_ssubset Î±] [is_asymm Î± has_ssubset.ssubset] {a b : Î±} (h : a âŠ‚ b) : Â¬b âŠ‚ a
theorem is_p_group.exists_le_sylow {p : â„•} {G : Type u_1} [group G] {P : subgroup G} (hP : is_p_group p â†¥P) : âˆƒ (Q : sylow p G), P â‰¤ â†‘Q
theorem monoid.fg_iff {M : Type u_1} [monoid M] : monoid.fg M â†” âˆƒ (S : set M), submonoid.closure S = âŠ¤ âˆ§ S.finite
theorem interval_integral.integral_has_deriv_within_at_right {E : Type u_3} [normed_group E] [complete_space E] [normed_space â„ E] {f : â„ â†’ E} {a b : â„} (hf : interval_integrable f measure_theory.measure_space.volume a b) {s t : set â„} [interval_integral.FTC_filter b (nhds_within b s) (nhds_within b t)] (hmeas : strongly_measurable_at_filter f (nhds_within b t) measure_theory.measure_space.volume) (hb : continuous_within_at f t b) : has_deriv_within_at (Î» (u : â„), âˆ« (x : â„) in a..u, f x) (f b) s b
theorem category_theory.iso_has_right_lifting_property {C : Type u} [category_theory.category C] {X Y : C} (i : category_theory.arrow C) (p : X â‰… Y) : category_theory.has_lifting_property i (category_theory.arrow.mk p.hom)
theorem nonempty_linear_equiv_of_lift_dim_eq {K : Type u} {V : Type v} {V' : Type v'} [division_ring K] [add_comm_group V] [module K V] [add_comm_group V'] [module K V'] (cond : (module.rank K V).lift = (module.rank K V').lift) : nonempty (V â‰ƒâ‚—[K] V')
theorem real.sinh_strict_mono  : strict_mono real.sinh
theorem tendsto_uniformly.comp' {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} {Î¹ : Type u_4} [uniform_space Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : filter Î¹} [uniform_space Î³] {g : Î² â†’ Î³} (h : tendsto_uniformly F f p) (hg : uniform_continuous g) : tendsto_uniformly (Î» (i : Î¹), g âˆ˜ F i) (g âˆ˜ f) p
theorem integral_sin_mul_cosâ‚ {a b : â„} : âˆ« (x : â„) in a..b, real.sin x * real.cos x = (real.sin b ^ 2 - real.sin a ^ 2) / 2
theorem shrinking_lemma.partial_refinement.exists_gt {Î¹ : Type u_1} {X : Type u_2} [topological_space X] [normal_space X] {u : Î¹ â†’ set X} {s : set X} (v : shrinking_lemma.partial_refinement u s) (hs : is_closed s) (i : Î¹) (hi : i âˆ‰ v.carrier) : âˆƒ (v' : shrinking_lemma.partial_refinement u s), v < v'
theorem linear_map.linear_independent_of_is_Ortho {K : Type u_8} {Kâ‚ : Type u_9} {Vâ‚ : Type u_12} {n : Type u_14} [field K] [field Kâ‚] [add_comm_group Vâ‚] [module Kâ‚ Vâ‚] {Iâ‚ Iâ‚' : Kâ‚ â†’+* K} {B : Vâ‚ â†’â‚›â‚—[Iâ‚] Vâ‚ â†’â‚›â‚—[Iâ‚'] K} {v : n â†’ Vâ‚} (hvâ‚ : B.is_Ortho v) (hvâ‚‚ : âˆ€ (i : n), Â¬B.is_ortho (v i) (v i)) : linear_independent Kâ‚ v
theorem injective_iff_map_eq_one' {F : Type u_8} {G : Type u_1} {H : Type u_2} [group G] [mul_one_class H] [monoid_hom_class F G H] (f : F) : function.injective â‡‘f â†” âˆ€ (a : G), â‡‘f a = 1 â†” a = 1
theorem composition.index_exists {n : â„•} (c : composition n) {j : â„•} (h : j < n) : âˆƒ (i : â„•), j < c.size_up_to i.succ âˆ§ i < c.length
theorem mathlib_dir_locator  : true
theorem finite_dimensional.of_finset_basis {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {Î¹ : Type w} {s : finset Î¹} (h : basis â†¥s K V) : finite_dimensional K V
theorem has_sum_two_pi_I_cauchy_power_series_integral {E : Type u_1} [normed_group E] [normed_space â„‚ E] [complete_space E] {f : â„‚ â†’ E} {c : â„‚} {R : â„} {w : â„‚} (hf : circle_integrable f c R) (hw : complex.abs w < R) : has_sum (Î» (n : â„•), âˆ® (z : â„‚) in C(c, R), (w / (z - c)) ^ n â€¢ (z - c)â»Â¹ â€¢ f z) (âˆ® (z : â„‚) in C(c, R), (z - (c + w))â»Â¹ â€¢ f z)
theorem measure_theory.integral_prod_symm {Î± : Type u_1} {Î² : Type u_3} {E : Type u_6} [measurable_space Î±] [measurable_space Î²] {Î¼ : measure_theory.measure Î±} {Î½ : measure_theory.measure Î²} [normed_group E] [measure_theory.sigma_finite Î½] [normed_space â„ E] [complete_space E] [measure_theory.sigma_finite Î¼] (f : Î± Ã— Î² â†’ E) (hf : measure_theory.integrable f (Î¼.prod Î½)) : âˆ« (z : Î± Ã— Î²), f z âˆ‚Î¼.prod Î½ = âˆ« (y : Î²), âˆ« (x : Î±), f (x, y) âˆ‚Î¼ âˆ‚Î½
theorem orthonormal.oangle_zero_left {V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) (x : V) : hb.oangle 0 x = 0
theorem category_theory.locally_cover_dense.induced_topology_cover_preserving {C : Type u_1} [category_theory.category C] {D : Type u_3} [category_theory.category D] {G : C â¥¤ D} {K : category_theory.grothendieck_topology D} [category_theory.full G] [category_theory.faithful G] (Hld : category_theory.locally_cover_dense K G) : category_theory.cover_preserving Hld.induced_topology K G
theorem dfinsupp.ext_iff {Î¹ : Type u} {Î² : Î¹ â†’ Type v} [Î  (i : Î¹), has_zero (Î² i)] {f g : Î â‚€ (i : Î¹), Î² i} : f = g â†” âˆ€ (i : Î¹), â‡‘f i = â‡‘g i
theorem complex.analytic_at_of_differentiable_on_punctured_nhds_of_continuous_at {E : Type u} [normed_group E] [normed_space â„‚ E] [complete_space E] {f : â„‚ â†’ E} {c : â„‚} (hd : âˆ€á¶  (z : â„‚) in nhds_within c {c}á¶œ, differentiable_at â„‚ f z) (hc : continuous_at f c) : analytic_at â„‚ f c
theorem category_theory.simplicial_object.Î´_comp_Ïƒ_succ {C : Type u} [category_theory.category C] (X : category_theory.simplicial_object C) {n : â„•} {i : fin (n + 1)} : X.Ïƒ i â‰« X.Î´ i.succ = ğŸ™ (X.obj (opposite.op (simplex_category.mk n)))
theorem vadd_right_injective {G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] (p : P) : function.injective (Î» (_x : G), _x +áµ¥ p)
theorem equiv.swap_mul_involutive {Î± : Type u} [decidable_eq Î±] (i j : Î±) : function.involutive (has_mul.mul (equiv.swap i j))
theorem tendsto_locally_uniformly_iff_tendsto_uniformly_of_compact_space {Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_4} [uniform_space Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : filter Î¹} [topological_space Î±] [compact_space Î±] : tendsto_locally_uniformly F f p â†” tendsto_uniformly F f p
theorem asymptotics.is_o.norm_left {Î± : Type u_1} {F : Type u_4} {E' : Type u_6} [has_norm F] [semi_normed_group E'] {g : Î± â†’ F} {f' : Î± â†’ E'} {l : filter Î±} : f' =o[l] g â†’ (Î» (x : Î±), âˆ¥f' xâˆ¥) =o[l] g
theorem affine_independent.exists_mem_inter_of_exists_mem_inter_affine_span {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {Î¹ : Type u_4} [nontrivial k] {p : Î¹ â†’ P} (ha : affine_independent k p) {s1 s2 : set Î¹} {p0 : P} (hp0s1 : p0 âˆˆ affine_span k (p '' s1)) (hp0s2 : p0 âˆˆ affine_span k (p '' s2)) : âˆƒ (i : Î¹), i âˆˆ s1 âˆ© s2
theorem mul_add_mul_lt_mul_add_mul {Î± : Type u} [ordered_semiring Î±] {a b c d : Î±} [has_exists_add_of_le Î±] (hab : a < b) (hcd : c < d) : a * d + b * c < a * c + b * d
theorem free_group.reduce.red {Î± : Type u} {L : list (Î± Ã— bool)} [decidable_eq Î±] : free_group.red L (free_group.reduce L)
theorem subring.closure_mono {R : Type u} [ring R] â¦ƒs t : set Râ¦„ (h : s âŠ† t) : subring.closure s â‰¤ subring.closure t
theorem add_monoid_hom.mk_normed_group_hom_norm_le' {Vâ‚ : Type u_2} {Vâ‚‚ : Type u_3} [semi_normed_group Vâ‚] [semi_normed_group Vâ‚‚] (f : Vâ‚ â†’+ Vâ‚‚) {C : â„} (h : âˆ€ (x : Vâ‚), âˆ¥â‡‘f xâˆ¥ â‰¤ C * âˆ¥xâˆ¥) : âˆ¥f.mk_normed_group_hom C hâˆ¥ â‰¤ linear_order.max C 0
theorem has_deriv_at.lhopital_zero_at_top {l : filter â„} {f f' g g' : â„ â†’ â„} (hff' : âˆ€á¶  (x : â„) in filter.at_top, has_deriv_at f (f' x) x) (hgg' : âˆ€á¶  (x : â„) in filter.at_top, has_deriv_at g (g' x) x) (hg' : âˆ€á¶  (x : â„) in filter.at_top, g' x â‰  0) (hftop : filter.tendsto f filter.at_top (nhds 0)) (hgtop : filter.tendsto g filter.at_top (nhds 0)) (hdiv : filter.tendsto (Î» (x : â„), f' x / g' x) filter.at_top l) : filter.tendsto (Î» (x : â„), f x / g x) filter.at_top l
theorem uniformity_edist {Î³ : Type w} [emetric_space Î³] : uniformity Î³ = â¨… (Îµ : ennreal) (H : Îµ > 0), filter.principal {p : Î³ Ã— Î³ | has_edist.edist p.fst p.snd < Îµ}
theorem witt_vector.verschiebung_mul_frobenius {p : â„•} {R : Type u_1} [hp : fact (nat.prime p)] [comm_ring R] (x y : witt_vector p R) : â‡‘witt_vector.verschiebung (x * â‡‘witt_vector.frobenius y) = â‡‘witt_vector.verschiebung x * y
theorem metric_space.ext {Î± : Type u_1} {m m' : metric_space Î±} (h : pseudo_metric_space.to_has_dist = pseudo_metric_space.to_has_dist) : m = m'
theorem cauchy_seq_of_le_tendsto_0' {Î± : Type u} {Î² : Type v} [pseudo_metric_space Î±] [nonempty Î²] [semilattice_sup Î²] {s : Î² â†’ Î±} (b : Î² â†’ â„) (h : âˆ€ (n m : Î²), n â‰¤ m â†’ has_dist.dist (s n) (s m) â‰¤ b n) (hâ‚€ : filter.tendsto b filter.at_top (nhds 0)) : cauchy_seq s
theorem padic_norm_e.add_eq_max_of_ne' {p : â„•} [fact (nat.prime p)] {q r : â„š_[p]} : padic_norm_e q â‰  padic_norm_e r â†’ padic_norm_e (q + r) = linear_order.max (padic_norm_e q) (padic_norm_e r)
theorem denom_dvd_of_is_root {A : Type u_1} {K : Type u_2} [comm_ring A] [is_domain A] [unique_factorization_monoid A] [field K] [algebra A K] [is_fraction_ring A K] {p : polynomial A} {r : K} (hr : â‡‘(polynomial.aeval r) p = 0) : â†‘(is_fraction_ring.denom A r) âˆ£ p.leading_coeff
theorem monoid_hom.map_mul {M : Type u_3} {N : Type u_4} [mul_one_class M] [mul_one_class N] (f : M â†’* N) (a b : M) : â‡‘f (a * b) = â‡‘f a * â‡‘f b
theorem is_preconnected_iff_subset_of_fully_disjoint_closed {Î± : Type u} [topological_space Î±] {s : set Î±} (hs : is_closed s) : is_preconnected s â†” âˆ€ (u v : set Î±), is_closed u â†’ is_closed v â†’ s âŠ† u âˆª v â†’ u âˆ© v = âˆ… â†’ s âŠ† u âˆ¨ s âŠ† v
theorem orthogonal_family.linear_isometry_equiv_apply_dfinsupp_sum_single {Î¹ : Type u_1} {ğ•œ : Type u_2} [is_R_or_C ğ•œ] {E : Type u_3} [inner_product_space ğ•œ E] [cplt : complete_space E] {G : Î¹ â†’ Type u_4} [Î  (i : Î¹), inner_product_space ğ•œ (G i)] {V : Î  (i : Î¹), G i â†’â‚—áµ¢[ğ•œ] E} (hV : orthogonal_family ğ•œ V) [âˆ€ (i : Î¹), complete_space (G i)] (hV' : (â¨† (i : Î¹), (V i).to_linear_map.range).topological_closure = âŠ¤) (Wâ‚€ : Î â‚€ (i : Î¹), G i) : â‡‘(â‡‘(hV.linear_isometry_equiv hV') (Wâ‚€.sum (Î» (i : Î¹), â‡‘(V i)))) = â‡‘Wâ‚€
theorem ennreal.young_inequality (a b : ennreal) {p q : â„} (hpq : p.is_conjugate_exponent q) : a * b â‰¤ a ^ p / ennreal.of_real p + b ^ q / ennreal.of_real q
theorem fin.coe_coe_eq_self {n : â„•} (a : fin (n + 1)) : â†‘â†‘a = a
theorem category_theory.limits.pushout_cocone.epi_of_is_colimit_mk_id_id {C : Type u} [category_theory.category C] {X Y : C} (f : X âŸ¶ Y) (t : category_theory.limits.is_colimit (category_theory.limits.pushout_cocone.mk (ğŸ™ Y) (ğŸ™ Y) rfl)) : category_theory.epi f
theorem reflexive.rel_of_ne_imp {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} (h : reflexive r) {x y : Î±} (hr : x â‰  y â†’ r x y) : r x y
theorem subring.mul_mem {R : Type u} [ring R] (s : subring R) {x y : R} : x âˆˆ s â†’ y âˆˆ s â†’ x * y âˆˆ s
theorem smul_zero' {R : Type u_1} (M : Type u_3) [has_zero R] [has_zero M] [smul_with_zero R M] (r : R) : r â€¢ 0 = 0
theorem tangent_bundle_proj_continuous {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] (I : model_with_corners ğ•œ E H) (M : Type u_4) [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] : continuous (tangent_bundle.proj I M)
theorem disjoint.map_order_iso {Î± : Type u_2} {Î² : Type u_3} [semilattice_inf Î±] [order_bot Î±] [semilattice_inf Î²] [order_bot Î²] {a b : Î±} (f : Î± â‰ƒo Î²) (ha : disjoint a b) : disjoint (â‡‘f a) (â‡‘f b)
theorem antitone.inf {Î± : Type u} {Î² : Type v} [preorder Î±] [semilattice_inf Î²] {f g : Î± â†’ Î²} (hf : antitone f) (hg : antitone g) : antitone (f âŠ“ g)
theorem is_localization.is_prime_of_is_prime_disjoint {R : Type u_1} [comm_semiring R] (M : submonoid R) (S : Type u_2) [comm_semiring S] [algebra R S] [is_localization M S] (I : ideal R) (hp : I.is_prime) (hd : disjoint â†‘M â†‘I) : (ideal.map (algebra_map R S) I).is_prime
theorem algebraic_geometry.LocallyRingedSpace.to_stalk_stalk_map_to_Î“_Spec (X : algebraic_geometry.LocallyRingedSpace) (x : â†¥X) : algebraic_geometry.structure_sheaf.to_stalk â†¥(opposite.unop (opposite.op (algebraic_geometry.LocallyRingedSpace.Î“.obj (opposite.op X)))) (â‡‘(X.to_Î“_Spec_SheafedSpace.base) x) â‰« algebraic_geometry.PresheafedSpace.stalk_map X.to_Î“_Spec_SheafedSpace x = X.Î“_to_stalk x
theorem complex.dist_le_div_mul_dist_of_maps_to_ball {E : Type u_1} [normed_group E] [normed_space â„‚ E] {Râ‚ Râ‚‚ : â„} {f : â„‚ â†’ E} {c z : â„‚} (hd : differentiable_on â„‚ f (metric.ball c Râ‚)) (h_maps : set.maps_to f (metric.ball c Râ‚) (metric.ball (f c) Râ‚‚)) (hz : z âˆˆ metric.ball c Râ‚) : has_dist.dist (f z) (f c) â‰¤ Râ‚‚ / Râ‚ * has_dist.dist z c
theorem category_theory.limits.is_colimit.of_nat_iso.cocone_fac {J : Type uâ‚} [category_theory.category J] {C : Type uâ‚ƒ} [category_theory.category C] {F : J â¥¤ C} {X : C} (h : category_theory.coyoneda.obj (opposite.op X) â‹™ category_theory.ulift_functor â‰… F.cocones) (s : category_theory.limits.cocone F) : (category_theory.limits.is_colimit.of_nat_iso.colimit_cocone h).extend (category_theory.limits.is_colimit.of_nat_iso.hom_of_cocone h s) = s
theorem measure_theory.measure.tendsto_add_haar_inter_smul_zero_of_density_zero {E : Type u_1} [normed_group E] [measurable_space E] [normed_space â„ E] [finite_dimensional â„ E] [borel_space E] (Î¼ : measure_theory.measure E) [Î¼.is_add_haar_measure] (s : set E) (x : E) (h : filter.tendsto (Î» (r : â„), â‡‘Î¼ (s âˆ© metric.closed_ball x r) / â‡‘Î¼ (metric.closed_ball x r)) (nhds_within 0 (set.Ioi 0)) (nhds 0)) (t : set E) (ht : measurable_set t) (h''t : â‡‘Î¼ t â‰  âŠ¤) : filter.tendsto (Î» (r : â„), â‡‘Î¼ (s âˆ© ({x} + r â€¢ t)) / â‡‘Î¼ ({x} + r â€¢ t)) (nhds_within 0 (set.Ioi 0)) (nhds 0)
theorem linear_map.trace_eq_contract_of_basis {R : Type u_1} [comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {Î¹ : Type u_4} [fintype Î¹] (b : basis Î¹ R M) : (linear_map.trace R M).comp (dual_tensor_hom R M M) = contract_left R M
theorem real_inner_add_sub_eq_zero_iff {F : Type u_3} [inner_product_space â„ F] (x y : F) : has_inner.inner (x + y) (x - y) = 0 â†” âˆ¥xâˆ¥ = âˆ¥yâˆ¥
theorem measure_theory.outer_measure.exists_mem_forall_mem_nhds_within_pos {Î± : Type u_1} [topological_space Î±] [topological_space.second_countable_topology Î±] (m : measure_theory.outer_measure Î±) {s : set Î±} (hs : â‡‘m s â‰  0) : âˆƒ (x : Î±) (H : x âˆˆ s), âˆ€ (t : set Î±), t âˆˆ nhds_within x s â†’ 0 < â‡‘m t
theorem subgroup.div_mem {G : Type u_1} [group G] (H : subgroup G) {x y : G} (hx : x âˆˆ H) (hy : y âˆˆ H) : x / y âˆˆ H
theorem finset.noncomm_sum_add_distrib {Î± : Type u_1} {Î² : Type u_2} [add_monoid Î²] {s : finset Î±} (f g : Î± â†’ Î²) (comm_ff : âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (y : Î±), y âˆˆ s â†’ add_commute (f x) (f y)) (comm_gg : âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (y : Î±), y âˆˆ s â†’ add_commute (g x) (g y)) (comm_gf : âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (y : Î±), y âˆˆ s â†’ x â‰  y â†’ add_commute (g x) (f y)) : s.noncomm_sum (f + g) _ = s.noncomm_sum f comm_ff + s.noncomm_sum g comm_gg
theorem group_algebra.mul_average_right (k : Type u_1) (G : Type u_2) [comm_semiring k] [group G] [fintype G] [invertible â†‘(fintype.card G)] (g : G) : group_algebra.average k G * finsupp.single g 1 = group_algebra.average k G
theorem orthonormal.det_conj_lie {V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) : â‡‘linear_map.det â†‘(hb.conj_lie.to_linear_equiv) = -1
theorem gold_irrational  : irrational golden_ratio
theorem even.nat_abs {n : â„¤} : even n â†’ even n.nat_abs
theorem set.image_equiv_eq_preimage_symm {Î± : Type u_1} {Î² : Type u_2} (S : set Î±) (f : Î± â‰ƒ Î²) : â‡‘f '' S = â‡‘(f.symm) â»Â¹' S
theorem powers.mul_mem {M : Type u_1} [monoid M] {x y z : M} : y âˆˆ powers x â†’ z âˆˆ powers x â†’ y * z âˆˆ powers x
theorem con.ext {M : Type u_1} [has_mul M] {c d : con M} (H : âˆ€ (x y : M), â‡‘c x y â†” â‡‘d x y) : c = d
theorem cont_diff_at.has_strict_fderiv_at' {n : with_top â„•} {ğ•‚ : Type u_6} [is_R_or_C ğ•‚] {E' : Type u_7} [normed_group E'] [normed_space ğ•‚ E'] {F' : Type u_8} [normed_group F'] [normed_space ğ•‚ F'] {f : E' â†’ F'} {f' : E' â†’L[ğ•‚] F'} {x : E'} (hf : cont_diff_at ğ•‚ n f x) (hf' : has_fderiv_at f f' x) (hn : 1 â‰¤ n) : has_strict_fderiv_at f f' x
theorem intermediate_field.list_prod_mem {K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) {l : list L} : (âˆ€ (x : L), x âˆˆ l â†’ x âˆˆ S) â†’ l.prod âˆˆ S
theorem spectrum.is_unit_resolvent {R : Type u} {A : Type v} [comm_semiring R] [ring A] [algebra R A] {r : R} {a : A} : r âˆˆ resolvent_set R a â†” is_unit (resolvent a r)
theorem not_covby_iff {Î± : Type u_1} [has_lt Î±] {a b : Î±} (h : a < b) : Â¬a â‹– b â†” âˆƒ (c : Î±), a < c âˆ§ c < b
theorem measure_theory.integral_fn_integral_add {Î± : Type u_1} {Î² : Type u_3} {E : Type u_6} [measurable_space Î±] [measurable_space Î²] {Î¼ : measure_theory.measure Î±} {Î½ : measure_theory.measure Î²} [normed_group E] [measure_theory.sigma_finite Î½] [normed_space â„ E] [complete_space E] [measure_theory.sigma_finite Î¼] {E' : Type u_7} [normed_group E'] [complete_space E'] [normed_space â„ E'] â¦ƒf g : Î± Ã— Î² â†’ Eâ¦„ (F : E â†’ E') (hf : measure_theory.integrable f (Î¼.prod Î½)) (hg : measure_theory.integrable g (Î¼.prod Î½)) : âˆ« (x : Î±), F (âˆ« (y : Î²), f (x, y) + g (x, y) âˆ‚Î½) âˆ‚Î¼ = âˆ« (x : Î±), F (âˆ« (y : Î²), f (x, y) âˆ‚Î½ + âˆ« (y : Î²), g (x, y) âˆ‚Î½) âˆ‚Î¼
theorem monoid_hom.coe_inj {M : Type u_3} {N : Type u_4} [mul_one_class M] [mul_one_class N] â¦ƒf g : M â†’* Nâ¦„ (h : â‡‘f = â‡‘g) : f = g
theorem eq.trans_lt {Î± : Type u} [preorder Î±] {a b c : Î±} (hab : a = b) (hbc : b < c) : a < c
theorem nnreal.young_inequality (a b : nnreal) {p q : nnreal} (hp : 1 < p) (hpq : 1 / p + 1 / q = 1) : a * b â‰¤ a ^ â†‘p / p + b ^ â†‘q / q
theorem cardinal.mk_real  : cardinal.mk â„ = cardinal.continuum
theorem add_submonoid.localization_map.add_neg_left {M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {N : Type u_2} [add_comm_monoid N] {f : M â†’+ N} (h : âˆ€ (y : â†¥S), is_add_unit (â‡‘f â†‘y)) (y : â†¥S) (w z : N) : w + â†‘-â‡‘(is_add_unit.lift_right (f.restrict S) h) y = z â†” w = â‡‘f â†‘y + z
theorem box_integral.has_integral_of_mul {Î¹ : Type u} {E : Type v} {F : Type w} [normed_group E] [normed_space â„ E] [normed_group F] [normed_space â„ F] {I : box_integral.box Î¹} [fintype Î¹] {l : box_integral.integration_params} {f : (Î¹ â†’ â„) â†’ E} {vol : box_integral.box_additive_map Î¹ (E â†’L[â„] F) âŠ¤} {y : F} (a : â„) (h : âˆ€ (Îµ : â„), 0 < Îµ â†’ (âˆƒ (r : nnreal â†’ (Î¹ â†’ â„) â†’ â†¥(set.Ioi 0)), (âˆ€ (c : nnreal), l.r_cond (r c)) âˆ§ âˆ€ (c : nnreal) (Ï€ : box_integral.tagged_prepartition I), l.mem_base_set I c (r c) Ï€ â†’ Ï€.is_partition â†’ has_dist.dist (box_integral.integral_sum f vol Ï€) y â‰¤ a * Îµ)) : box_integral.has_integral I l f vol y
theorem finite_dimensional.span_of_finite (K : Type u) {V : Type v} [division_ring K] [add_comm_group V] [module K V] {A : set V} (hA : A.finite) : finite_dimensional K â†¥(submodule.span K A)
theorem lipschitz_on_with.extend_finite_dimension {Î± : Type u_1} [pseudo_metric_space Î±] {E' : Type u_2} [normed_group E'] [normed_space â„ E'] [finite_dimensional â„ E'] {s : set Î±} {f : Î± â†’ E'} {K : nnreal} (hf : lipschitz_on_with K f s) : âˆƒ (g : Î± â†’ E'), lipschitz_with (lipschitz_extension_constant E' * K) g âˆ§ set.eq_on f g s
theorem local_homeomorph.eq_on_source.trans' {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [topological_space Î±] [topological_space Î²] [topological_space Î³] {e e' : local_homeomorph Î± Î²} {f f' : local_homeomorph Î² Î³} (he : e â‰ˆ e') (hf : f â‰ˆ f') : e.trans f â‰ˆ e'.trans f'
theorem supr_eq_of_forall_le_of_forall_lt_exists_gt {Î± : Type u_1} {Î¹ : Sort u_4} [complete_lattice Î±] {b : Î±} {f : Î¹ â†’ Î±} (hâ‚ : âˆ€ (i : Î¹), f i â‰¤ b) (hâ‚‚ : âˆ€ (w : Î±), w < b â†’ (âˆƒ (i : Î¹), w < f i)) : (â¨† (i : Î¹), f i) = b
theorem euclidean_geometry.orthogonal_projection_vadd_eq_self {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace â„ P} [nonempty â†¥s] [complete_space â†¥(s.direction)] {p : P} (hp : p âˆˆ s) {v : V} (hv : v âˆˆ (s.direction)á—®) : â‡‘(euclidean_geometry.orthogonal_projection s) (v +áµ¥ p) = âŸ¨p, hpâŸ©
theorem mv_polynomial.exists_fin_rename {Ïƒ : Type u_1} {R : Type u_4} [comm_semiring R] (p : mv_polynomial Ïƒ R) : âˆƒ (n : â„•) (f : fin n â†’ Ïƒ) (hf : function.injective f) (q : mv_polynomial (fin n) R), p = â‡‘(mv_polynomial.rename f) q
theorem entrywise_sup_norm_bound_of_unitary {ğ•œ : Type u_1} {n : Type u_3} [is_R_or_C ğ•œ] [fintype n] [decidable_eq n] {U : matrix n n ğ•œ} (hU : U âˆˆ matrix.unitary_group n ğ•œ) : âˆ¥Uâˆ¥ â‰¤ 1
theorem category_theory.limits.eq_of_mono_cofork_Ï€ {C : Type u} [category_theory.category C] {X Y : C} {f g : X âŸ¶ Y} (t : category_theory.limits.cofork f g) [category_theory.mono t.Ï€] : f = g
theorem measure_theory.measure.inner_regular.weakly_regular_of_finite {Î± : Type u_1} [measurable_space Î±] [topological_space Î±] [borel_space Î±] (Î¼ : measure_theory.measure Î±) [measure_theory.is_finite_measure Î¼] (H : Î¼.inner_regular is_closed is_open) : Î¼.weakly_regular
theorem exp_eq_exp (ğ•‚ : Type u_1) (ğ•‚' : Type u_2) (ğ”¸ : Type u_3) [field ğ•‚] [field ğ•‚'] [ring ğ”¸] [algebra ğ•‚ ğ”¸] [algebra ğ•‚' ğ”¸] [topological_space ğ”¸] [topological_ring ğ”¸] : exp ğ•‚ = exp ğ•‚'
theorem has_deriv_within_at.Ioi_of_Ioo {ğ•œ : Type u} [nondiscrete_normed_field ğ•œ] {F : Type v} [normed_group F] [normed_space ğ•œ F] {f : ğ•œ â†’ F} {f' : F} [linear_order ğ•œ] [order_closed_topology ğ•œ] {x y : ğ•œ} (h : x < y) : has_deriv_within_at f f' (set.Ioo x y) x â†’ has_deriv_within_at f f' (set.Ioi x) x
theorem is_compact.elim_finite_subcover_image {Î± : Type u} {Î¹ : Type u_1} [topological_space Î±] {s : set Î±} {b : set Î¹} {c : Î¹ â†’ set Î±} (hs : is_compact s) (hcâ‚ : âˆ€ (i : Î¹), i âˆˆ b â†’ is_open (c i)) (hcâ‚‚ : s âŠ† â‹ƒ (i : Î¹) (H : i âˆˆ b), c i) : âˆƒ (b' : set Î¹) (H : b' âŠ† b), b'.finite âˆ§ s âŠ† â‹ƒ (i : Î¹) (H : i âˆˆ b'), c i
theorem submonoid.localization_map.lift_spec_mul {M : Type u_1} [comm_monoid M] {S : submonoid M} {N : Type u_2} [comm_monoid N] {P : Type u_3} [comm_monoid P] (f : S.localization_map N) {g : M â†’* P} (hg : âˆ€ (y : â†¥S), is_unit (â‡‘g â†‘y)) (z : N) (w v : P) : â‡‘(f.lift hg) z * w = v â†” â‡‘g (f.sec z).fst * w = â‡‘g â†‘((f.sec z).snd) * v
theorem category_theory.presieve.extend_agrees {C : Type uâ‚} [category_theory.category C] {P : Cáµ’áµ– â¥¤ Type w} {X Y : C} {R : category_theory.presieve X} {x : category_theory.presieve.family_of_elements P R} (t : x.compatible) {f : Y âŸ¶ X} (hf : R f) : x.sieve_extend f _ = x f hf
theorem list.length_le_sum_of_one_le (L : list â„•) (h : âˆ€ (i : â„•), i âˆˆ L â†’ 1 â‰¤ i) : L.length â‰¤ L.sum
theorem measure_theory.tendsto_lintegral_of_dominated_convergence {Î± : Type u_1} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {F : â„• â†’ Î± â†’ ennreal} {f : Î± â†’ ennreal} (bound : Î± â†’ ennreal) (hF_meas : âˆ€ (n : â„•), measurable (F n)) (h_bound : âˆ€ (n : â„•), F n â‰¤áµ[Î¼] bound) (h_fin : âˆ«â» (a : Î±), bound a âˆ‚Î¼ â‰  âŠ¤) (h_lim : âˆ€áµ (a : Î±) âˆ‚Î¼, filter.tendsto (Î» (n : â„•), F n a) filter.at_top (nhds (f a))) : filter.tendsto (Î» (n : â„•), âˆ«â» (a : Î±), F n a âˆ‚Î¼) filter.at_top (nhds (âˆ«â» (a : Î±), f a âˆ‚Î¼))
theorem subring.list_sum_mem {R : Type u} [ring R] (s : subring R) {l : list R} : (âˆ€ (x : R), x âˆˆ l â†’ x âˆˆ s) â†’ l.sum âˆˆ s
theorem same_ray.norm_add {E : Type u_1} [semi_normed_group E] [normed_space â„ E] {x y : E} (h : same_ray â„ x y) : âˆ¥x + yâˆ¥ = âˆ¥xâˆ¥ + âˆ¥yâˆ¥
theorem linear_map.mul_eq_one_of_mul_eq_one {K : Type u} {V : Type v} [field K] [add_comm_group V] [module K V] [finite_dimensional K V] {f g : V â†’â‚—[K] V} (hfg : f * g = 1) : g * f = 1
theorem has_fpower_series_at.is_O_image_sub_norm_mul_norm_sub {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field ğ•œ] [normed_group E] [normed_space ğ•œ E] [normed_group F] [normed_space ğ•œ F] {f : E â†’ F} {p : formal_multilinear_series ğ•œ E F} {x : E} (hf : has_fpower_series_at f p x) : (Î» (y : E Ã— E), f y.fst - f y.snd - â‡‘(p 1) (Î» (_x : fin 1), y.fst - y.snd)) =O[nhds (x, x)] Î» (y : E Ã— E), âˆ¥y - (x, x)âˆ¥ * âˆ¥y.fst - y.sndâˆ¥
theorem linear_recurrence.eq_mk_of_is_sol_of_eq_init {Î± : Type u_1} [comm_semiring Î±] (E : linear_recurrence Î±) {u : â„• â†’ Î±} {init : fin E.order â†’ Î±} (h : E.is_solution u) (heq : âˆ€ (n : fin E.order), u â†‘n = init n) (n : â„•) : u n = E.mk_sol init n
theorem measure_theory.integral_add_right_eq_self {G : Type u_4} {E : Type u_5} [measurable_space G] [normed_group E] [normed_space â„ E] [complete_space E] {Î¼ : measure_theory.measure G} [add_group G] [has_measurable_add G] [Î¼.is_add_right_invariant] (f : G â†’ E) (g : G) : âˆ« (x : G), f (x + g) âˆ‚Î¼ = âˆ« (x : G), f x âˆ‚Î¼
theorem cont_diff_succ_iff_fderiv {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {f : E â†’ F} {n : â„•} : cont_diff ğ•œ â†‘(n + 1) f â†” differentiable ğ•œ f âˆ§ cont_diff ğ•œ â†‘n (Î» (y : E), fderiv ğ•œ f y)
theorem measure_theory.exists_measurable_le_lintegral_eq {Î± : Type u_1} {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) (f : Î± â†’ ennreal) : âˆƒ (g : Î± â†’ ennreal), measurable g âˆ§ g â‰¤ f âˆ§ âˆ«â» (a : Î±), f a âˆ‚Î¼ = âˆ«â» (a : Î±), g a âˆ‚Î¼
theorem submodule.nonempty_basis_of_pid {R : Type u_2} [comm_ring R] [is_domain R] [is_principal_ideal_ring R] {M : Type u_3} [add_comm_group M] [module R M] {Î¹ : Type u_1} [fintype Î¹] (b : basis Î¹ R M) (N : submodule R M) : âˆƒ (n : â„•), nonempty (basis (fin n) R â†¥N)
theorem finset.sum_cancels_of_partition_cancels {Î² : Type u} {Î± : Type v} {s : finset Î±} {f : Î± â†’ Î²} [add_comm_monoid Î²] (R : setoid Î±) [decidable_rel setoid.r] (h : âˆ€ (x : Î±), x âˆˆ s â†’ (finset.filter (Î» (y : Î±), y â‰ˆ x) s).sum (Î» (a : Î±), f a) = 0) : s.sum (Î» (x : Î±), f x) = 0
theorem clifford_algebra.odd_induction {R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] (Q : quadratic_form R M) {P : Î  (x : clifford_algebra Q), x âˆˆ clifford_algebra.even_odd Q 1 â†’ Prop} (hÎ¹ : âˆ€ (v : M), P (â‡‘(clifford_algebra.Î¹ Q) v) _) (hadd : âˆ€ {x y : clifford_algebra Q} {hx : x âˆˆ clifford_algebra.even_odd Q 1} {hy : y âˆˆ clifford_algebra.even_odd Q 1}, P x hx â†’ P y hy â†’ P (x + y) _) (hÎ¹Î¹_mul : âˆ€ (mâ‚ mâ‚‚ : M) {x : clifford_algebra Q} {hx : x âˆˆ clifford_algebra.even_odd Q 1}, P x hx â†’ P (â‡‘(clifford_algebra.Î¹ Q) mâ‚ * â‡‘(clifford_algebra.Î¹ Q) mâ‚‚ * x) _) (x : clifford_algebra Q) (hx : x âˆˆ clifford_algebra.even_odd Q 1) : P x hx
theorem has_scalar.comp.smul_comm_class' {M : Type u_1} {N : Type u_2} {Î± : Type u_6} {Î² : Type u_7} [has_scalar M Î±] [has_scalar Î² Î±] [smul_comm_class Î² M Î±] (g : N â†’ M) : smul_comm_class Î² N Î±
theorem matrix.nondegenerate_of_det_ne_zero {m : Type u_1} {A : Type u_3} [fintype m] [comm_ring A] [is_domain A] [decidable_eq m] {M : matrix m m A} (hM : M.det â‰  0) : M.nondegenerate
theorem local_equiv.eq_on_source.symm' {Î± : Type u_1} {Î² : Type u_2} {e e' : local_equiv Î± Î²} (h : e â‰ˆ e') : e.symm â‰ˆ e'.symm
theorem emetric.Hausdorff_edist_closure {Î± : Type u} [pseudo_emetric_space Î±] {s t : set Î±} : emetric.Hausdorff_edist (closure s) (closure t) = emetric.Hausdorff_edist s t
theorem sub_mul_action.stabilizer_of_sub_mul.submonoid {R : Type u} {M : Type v} [monoid R] [mul_action R M] {p : sub_mul_action R M} (m : â†¥p) : mul_action.stabilizer.submonoid R m = mul_action.stabilizer.submonoid R â†‘m
theorem finset.sum_card_le {Î± : Type u_2} [decidable_eq Î±] {B : finset (finset Î±)} {n : â„•} [fintype Î±] (h : âˆ€ (a : Î±), (finset.filter (has_mem.mem a) B).card â‰¤ n) : B.sum (Î» (s : finset Î±), s.card) â‰¤ fintype.card Î± * n
theorem is_nilpotent_of_ker_le_center {G : Type u_1} [group G] {H : Type u_2} [group H] (f : G â†’* H) (hf1 : f.ker â‰¤ subgroup.center G) (hH : group.is_nilpotent H) : group.is_nilpotent G
theorem le_inv_of_le_inv {Î± : Type u} [group Î±] [has_le Î±] [covariant_class Î± Î± has_mul.mul has_le.le] [covariant_class Î± Î± (function.swap has_mul.mul) has_le.le] {a b : Î±} : a â‰¤ bâ»Â¹ â†’ b â‰¤ aâ»Â¹
theorem antilipschitz_with.proper_space {Î² : Type u_2} [pseudo_metric_space Î²] {Î± : Type u_1} [metric_space Î±] {K : nnreal} {f : Î± â†’ Î²} [proper_space Î±] (hK : antilipschitz_with K f) (f_cont : continuous f) (hf : function.surjective f) : proper_space Î²
theorem emetric.closeds.edist_eq {Î± : Type u} [emetric_space Î±] {s t : topological_space.closeds Î±} : has_edist.edist s t = emetric.Hausdorff_edist â†‘s â†‘t
theorem subsemiring.zero_mem {R : Type u} [non_assoc_semiring R] (s : subsemiring R) : 0 âˆˆ s
theorem measure_theory.outer_measure.mk_metric'.trim_pre {X : Type u_2} [emetric_space X] [measurable_space X] [opens_measurable_space X] (m : set X â†’ ennreal) (hcl : âˆ€ (s : set X), m (closure s) = m s) (r : ennreal) : (measure_theory.outer_measure.mk_metric'.pre m r).trim = measure_theory.outer_measure.mk_metric'.pre m r
theorem submodule.exists_smith_normal_form_of_le {Î¹ : Type u_1} {R : Type u_2} [comm_ring R] [is_domain R] [is_principal_ideal_ring R] {M : Type u_3} [add_comm_group M] [module R M] [fintype Î¹] (b : basis Î¹ R M) (N O : submodule R M) (N_le_O : N â‰¤ O) : âˆƒ (n o : â„•) (hno : n â‰¤ o) (bO : basis (fin o) R â†¥O) (bN : basis (fin n) R â†¥N) (a : fin n â†’ R), âˆ€ (i : fin n), â†‘(â‡‘bN i) = a i â€¢ â†‘(â‡‘bO (â‡‘(fin.cast_le hno) i))
theorem compact_exists_clopen_in_open {Î± : Type u} [topological_space Î±] [t2_space Î±] [compact_space Î±] [totally_disconnected_space Î±] {x : Î±} {U : set Î±} (is_open : _root_.is_open U) (memU : x âˆˆ U) : âˆƒ (V : set Î±) (hV : is_clopen V), x âˆˆ V âˆ§ V âŠ† U
theorem matrix.transpose_has_orthogonal_cols_iff_has_orthogonal_rows {Î± : Type u_1} {n : Type u_2} {m : Type u_3} [has_mul Î±] [add_comm_monoid Î±] (A : matrix m n Î±) [fintype n] : A.transpose.has_orthogonal_cols â†” A.has_orthogonal_rows
theorem cont_diff_within_at.prod_map' {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {n : with_top â„•} {E' : Type u_6} [normed_group E'] [normed_space ğ•œ E'] {F' : Type u_7} [normed_group F'] [normed_space ğ•œ F'] {s : set E} {t : set E'} {f : E â†’ F} {g : E' â†’ F'} {p : E Ã— E'} (hf : cont_diff_within_at ğ•œ n f s p.fst) (hg : cont_diff_within_at ğ•œ n g t p.snd) : cont_diff_within_at ğ•œ n (prod.map f g) (s Ã—Ë¢ t) p
theorem reflection_map_apply {ğ•œ : Type u_1} [is_R_or_C ğ•œ] {E : Type u_2} {E' : Type u_3} [inner_product_space ğ•œ E] [inner_product_space ğ•œ E'] (f : E â‰ƒâ‚—áµ¢[ğ•œ] E') (K : submodule ğ•œ E) [complete_space â†¥K] (x : E') : â‡‘(reflection (submodule.map â†‘(f.to_linear_equiv) K)) x = â‡‘f (â‡‘(reflection K) (â‡‘(f.symm) x))
theorem inner_add_add_self {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {x y : E} : has_inner.inner (x + y) (x + y) = has_inner.inner x x + has_inner.inner x y + has_inner.inner y x + has_inner.inner y y
theorem is_add_group_hom.neg {Î± : Type u_1} {Î² : Type u_2} [add_group Î±] [add_comm_group Î²] {f : Î± â†’ Î²} (hf : is_add_group_hom f) : is_add_group_hom (Î» (a : Î±), -f a)
theorem affine.triangle.altitude_replace_orthocenter_eq_affine_span {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {tâ‚ tâ‚‚ : affine.triangle â„ P} {iâ‚ iâ‚‚ iâ‚ƒ jâ‚ jâ‚‚ jâ‚ƒ : fin 3} (hiâ‚â‚‚ : iâ‚ â‰  iâ‚‚) (hiâ‚â‚ƒ : iâ‚ â‰  iâ‚ƒ) (hiâ‚‚â‚ƒ : iâ‚‚ â‰  iâ‚ƒ) (hjâ‚â‚‚ : jâ‚ â‰  jâ‚‚) (hjâ‚â‚ƒ : jâ‚ â‰  jâ‚ƒ) (hjâ‚‚â‚ƒ : jâ‚‚ â‰  jâ‚ƒ) (hâ‚ : tâ‚‚.points jâ‚ = tâ‚.orthocenter) (hâ‚‚ : tâ‚‚.points jâ‚‚ = tâ‚.points iâ‚‚) (hâ‚ƒ : tâ‚‚.points jâ‚ƒ = tâ‚.points iâ‚ƒ) : affine.simplex.altitude tâ‚‚ jâ‚‚ = affine_span â„ {tâ‚.points iâ‚, tâ‚.points iâ‚‚}
theorem function.Sup_div_semiconj {Î± : Type u_1} {G : Type u_4} [complete_lattice Î±] [group G] (fâ‚ fâ‚‚ : G â†’* Î± â‰ƒo Î±) (g : G) : function.semiconj (Î» (x : Î±), â¨† (g' : G), â‡‘(â‡‘fâ‚ g')â»Â¹ (â‡‘(â‡‘fâ‚‚ g') x)) â‡‘(â‡‘fâ‚‚ g) â‡‘(â‡‘fâ‚ g)
theorem left.one_le_mul {Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a b : Î±} (ha : 1 â‰¤ a) (hb : 1 â‰¤ b) : 1 â‰¤ a * b
theorem has_fpower_series_on_ball.uniform_geometric_approx {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field ğ•œ] [normed_group E] [normed_space ğ•œ E] [normed_group F] [normed_space ğ•œ F] {f : E â†’ F} {p : formal_multilinear_series ğ•œ E F} {x : E} {r : ennreal} {r' : nnreal} (hf : has_fpower_series_on_ball f p x r) (h : â†‘r' < r) : âˆƒ (a : â„) (H : a âˆˆ set.Ioo 0 1) (C : â„) (H : C > 0), âˆ€ (y : E), y âˆˆ metric.ball 0 â†‘r' â†’ âˆ€ (n : â„•), âˆ¥f (x + y) - p.partial_sum n yâˆ¥ â‰¤ C * a ^ n
theorem zmod.legendre_sym_eq_neg_one_iff (p : â„•) [fact (nat.prime p)] {a : â„¤} : zmod.legendre_sym p a = -1 â†” Â¬is_square â†‘a
theorem dense_inducing.extend_eq' {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [topological_space Î±] [topological_space Î²] {i : Î± â†’ Î²} [topological_space Î³] [t2_space Î³] {f : Î± â†’ Î³} (di : dense_inducing i) (hf : âˆ€ (b : Î²), âˆƒ (c : Î³), filter.tendsto f (filter.comap i (nhds b)) (nhds c)) (a : Î±) : di.extend f (i a) = f a
theorem polynomial.eval_prod {R : Type u} [comm_semiring R] {Î¹ : Type u_1} (s : finset Î¹) (p : Î¹ â†’ polynomial R) (x : R) : polynomial.eval x (s.prod (Î» (j : Î¹), p j)) = s.prod (Î» (j : Î¹), polynomial.eval x (p j))
theorem is_min.eq_bot {Î± : Type u} [partial_order Î±] [order_bot Î±] {a : Î±} : is_min a â†’ a = âŠ¥
theorem Top.presheaf.is_iso_iff_stalk_functor_map_iso {C : Type u} [category_theory.category C] [category_theory.limits.has_colimits C] {X : Top} [category_theory.concrete_category C] [category_theory.limits.preserves_filtered_colimits (category_theory.forget C)] [category_theory.limits.has_limits C] [category_theory.limits.preserves_limits (category_theory.forget C)] [category_theory.reflects_isomorphisms (category_theory.forget C)] {F G : Top.sheaf C X} (f : F âŸ¶ G) : category_theory.is_iso f â†” âˆ€ (x : â†¥X), category_theory.is_iso ((Top.presheaf.stalk_functor C x).map f)
theorem metric.thickening_cthickening_subset {Î± : Type u} [pseudo_emetric_space Î±] {Î´ : â„} (Îµ : â„) (hÎ´ : 0 â‰¤ Î´) (s : set Î±) : metric.thickening Îµ (metric.cthickening Î´ s) âŠ† metric.thickening (Îµ + Î´) s
theorem category_theory.is_pushout.of_bot {C : Type uâ‚} [category_theory.category C] {Xâ‚â‚ Xâ‚â‚‚ Xâ‚‚â‚ Xâ‚‚â‚‚ Xâ‚ƒâ‚ Xâ‚ƒâ‚‚ : C} {hâ‚â‚ : Xâ‚â‚ âŸ¶ Xâ‚â‚‚} {hâ‚‚â‚ : Xâ‚‚â‚ âŸ¶ Xâ‚‚â‚‚} {hâ‚ƒâ‚ : Xâ‚ƒâ‚ âŸ¶ Xâ‚ƒâ‚‚} {vâ‚â‚ : Xâ‚â‚ âŸ¶ Xâ‚‚â‚} {vâ‚â‚‚ : Xâ‚â‚‚ âŸ¶ Xâ‚‚â‚‚} {vâ‚‚â‚ : Xâ‚‚â‚ âŸ¶ Xâ‚ƒâ‚} {vâ‚‚â‚‚ : Xâ‚‚â‚‚ âŸ¶ Xâ‚ƒâ‚‚} (s : category_theory.is_pushout hâ‚â‚ (vâ‚â‚ â‰« vâ‚‚â‚) (vâ‚â‚‚ â‰« vâ‚‚â‚‚) hâ‚ƒâ‚) (p : hâ‚‚â‚ â‰« vâ‚‚â‚‚ = vâ‚‚â‚ â‰« hâ‚ƒâ‚) (t : category_theory.is_pushout hâ‚â‚ vâ‚â‚ vâ‚â‚‚ hâ‚‚â‚) : category_theory.is_pushout hâ‚‚â‚ vâ‚‚â‚ vâ‚‚â‚‚ hâ‚ƒâ‚
theorem ring_hom.map_add {Î± : Type u_2} {Î² : Type u_3} {rÎ± : non_assoc_semiring Î±} {rÎ² : non_assoc_semiring Î²} (f : Î± â†’+* Î²) (a b : Î±) : â‡‘f (a + b) = â‡‘f a + â‡‘f b
theorem measure_theory.measure.ext_of_Ico_finite {Î± : Type u_1} [topological_space Î±] {m : measurable_space Î±} [topological_space.second_countable_topology Î±] [linear_order Î±] [order_topology Î±] [borel_space Î±] (Î¼ Î½ : measure_theory.measure Î±) [measure_theory.is_finite_measure Î¼] (hÎ¼Î½ : â‡‘Î¼ set.univ = â‡‘Î½ set.univ) (h : âˆ€ â¦ƒa b : Î±â¦„, a < b â†’ â‡‘Î¼ (set.Ico a b) = â‡‘Î½ (set.Ico a b)) : Î¼ = Î½
theorem matrix.sum_cramer_apply {n : Type u} [decidable_eq n] [fintype n] {Î± : Type v} [comm_ring Î±] (A : matrix n n Î±) {Î² : Type u_1} (s : finset Î²) (f : n â†’ Î² â†’ Î±) (i : n) : s.sum (Î» (x : Î²), â‡‘(A.cramer) (Î» (j : n), f j x) i) = â‡‘(A.cramer) (Î» (j : n), s.sum (Î» (x : Î²), f j x)) i
theorem list.nth_le_take' {Î± : Type u} (L : list Î±) {i j : â„•} (hi : i < (list.take j L).length) : (list.take j L).nth_le i hi = L.nth_le i _
theorem has_btw.btw.not_sbtw {Î± : Type u_1} [circular_preorder Î±] {a b c : Î±} (h : has_btw.btw a b c) : Â¬has_sbtw.sbtw c b a
theorem orientation.rotation_oangle_eq_iff_norm_eq {V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) (x y : V) : â‡‘(o.rotation (o.oangle x y)) x = y â†” âˆ¥xâˆ¥ = âˆ¥yâˆ¥
theorem summable_norm_iff {Î± : Type u_1} {E : Type u_2} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] {f : Î± â†’ E} : summable (Î» (x : Î±), âˆ¥f xâˆ¥) â†” summable f
theorem semiconj_by.units_inv_right {M : Type u} [monoid M] {a : M} {x y : MË£} (h : semiconj_by a â†‘x â†‘y) : semiconj_by a â†‘xâ»Â¹ â†‘yâ»Â¹
theorem linear_map.det_conj {M : Type u_2} [add_comm_group M] {A : Type u_5} [comm_ring A] [module A M] {N : Type u_1} [add_comm_group N] [module A N] (f : M â†’â‚—[A] M) (e : M â‰ƒâ‚—[A] N) : â‡‘linear_map.det (â†‘e.comp (f.comp â†‘(e.symm))) = â‡‘linear_map.det f
theorem is_primitive_root.minpoly_dvd_cyclotomic {n : â„•} {K : Type u_1} [field K] {Î¼ : K} (h : is_primitive_root Î¼ n) (hpos : 0 < n) [char_zero K] : minpoly â„¤ Î¼ âˆ£ polynomial.cyclotomic n â„¤
theorem star_isometry {E : Type u_2} [semi_normed_group E] [star_add_monoid E] [normed_star_group E] : isometry has_star.star
theorem real.volume_preserving_transvection_struct {Î¹ : Type u_1} [fintype Î¹] [decidable_eq Î¹] (t : matrix.transvection_struct Î¹ â„) : measure_theory.measure_preserving â‡‘(â‡‘matrix.to_lin' t.to_matrix) measure_theory.measure_space.volume measure_theory.measure_space.volume
theorem continuous_map.continuous_coe {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [compact_space Î±] [metric_space Î²] : continuous coe_fn
theorem category_theory.over.mono_of_mono_left {T : Type uâ‚} [category_theory.category T] {X : T} {f g : category_theory.over X} (k : f âŸ¶ g) [hk : category_theory.mono k.left] : category_theory.mono k
theorem pequiv.injective_of_forall_ne_is_some {Î± : Type u} {Î² : Type v} (f : Î± â‰ƒ. Î²) (aâ‚‚ : Î±) (h : âˆ€ (aâ‚ : Î±), aâ‚ â‰  aâ‚‚ â†’ â†¥((â‡‘f aâ‚).is_some)) : function.injective â‡‘f
theorem has_fpower_series_on_ball.is_O_image_sub_image_sub_deriv_principal {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field ğ•œ] [normed_group E] [normed_space ğ•œ E] [normed_group F] [normed_space ğ•œ F] {f : E â†’ F} {p : formal_multilinear_series ğ•œ E F} {x : E} {r r' : ennreal} (hf : has_fpower_series_on_ball f p x r) (hr : r' < r) : (Î» (y : E Ã— E), f y.fst - f y.snd - â‡‘(p 1) (Î» (_x : fin 1), y.fst - y.snd)) =O[filter.principal (emetric.ball (x, x) r')] Î» (y : E Ã— E), âˆ¥y - (x, x)âˆ¥ * âˆ¥y.fst - y.sndâˆ¥
theorem left.add_pos' {Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : 0 < a) (hb : 0 < b) : 0 < a + b
theorem same_ray_of_mem_orbit {R : Type u_1} [linear_ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {vâ‚ vâ‚‚ : M} (h : vâ‚ âˆˆ mul_action.orbit â†¥(units.pos_subgroup R) vâ‚‚) : same_ray R vâ‚ vâ‚‚
theorem category_theory.limits.has_finite_wide_pushouts_of_has_finite_limits (C : Type u) [category_theory.category C] [category_theory.limits.has_finite_colimits C] : category_theory.limits.has_finite_wide_pushouts C
theorem formal_multilinear_series.apply_composition_update {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [comm_ring ğ•œ] [add_comm_group E] [add_comm_group F] [module ğ•œ E] [module ğ•œ F] [topological_space E] [topological_space F] [topological_add_group E] [has_continuous_const_smul ğ•œ E] [topological_add_group F] [has_continuous_const_smul ğ•œ F] (p : formal_multilinear_series ğ•œ E F) {n : â„•} (c : composition n) (j : fin n) (v : fin n â†’ E) (z : E) : p.apply_composition c (function.update v j z) = function.update (p.apply_composition c v) (c.index j) (â‡‘(p (c.blocks_fun (c.index j))) (function.update (v âˆ˜ â‡‘(c.embedding (c.index j))) (c.inv_embedding j) z))
theorem set.nonempty.of_closure {Î± : Type u} [topological_space Î±] {s : set Î±} : (closure s).nonempty â†’ s.nonempty
theorem pgame.lf.le {x y : pgame} (h : x.lf y) (ox : x.numeric) (oy : y.numeric) : x â‰¤ y
theorem fin.find_spec {n : â„•} (p : fin n â†’ Prop) [decidable_pred p] {i : fin n} (hi : i âˆˆ fin.find p) : p i
theorem eq_of_tendsto_nhds {Î± : Type u} {Î² : Type v} [topological_space Î±] [topological_space Î²] [t1_space Î²] {f : Î± â†’ Î²} {a : Î±} {b : Î²} (h : filter.tendsto f (nhds a) (nhds b)) : f a = b
theorem is_localization.exist_integer_multiples_of_fintype {R : Type u_1} [comm_ring R] (M : submonoid R) {S : Type u_2} [comm_ring S] [algebra R S] [is_localization M S] {Î¹ : Type u_3} [fintype Î¹] (f : Î¹ â†’ S) : âˆƒ (b : â†¥M), âˆ€ (i : Î¹), is_localization.is_integer R (â†‘b â€¢ f i)
theorem measure_theory.measure.measure_ae_null_of_prod_null {Î± : Type u_1} {Î² : Type u_3} [measurable_space Î±] [measurable_space Î²] {Î¼ : measure_theory.measure Î±} {Î½ : measure_theory.measure Î²} [measure_theory.sigma_finite Î½] {s : set (Î± Ã— Î²)} (h : â‡‘(Î¼.prod Î½) s = 0) : (Î» (x : Î±), â‡‘Î½ (prod.mk x â»Â¹' s)) =áµ[Î¼] 0
theorem list.nodup.sublists' {Î± : Type u} {l : list Î±} : l.nodup â†’ l.sublists'.nodup
theorem measure_theory.measure.sub_mem_nhds_zero_of_add_haar_pos {G : Type u_1} [add_group G] [topological_space G] [t2_space G] [topological_add_group G] [measurable_space G] [borel_space G] [topological_space.second_countable_topology G] (Î¼ : measure_theory.measure G) [Î¼.is_add_haar_measure] [locally_compact_space G] (E : set G) (hE : measurable_set E) (hEpos : 0 < â‡‘Î¼ E) : E - E âˆˆ nhds 0
theorem lie_submodule.lie_ideal_oper_eq_tensor_map_range {R : Type u} [comm_ring R] {L : Type v} {M : Type w} [lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] (I : lie_ideal R L) (N : lie_submodule R L M) : â…I,Nâ† = ((lie_module.to_module_hom R L M).comp (tensor_product.lie_module.map_incl I N)).range
theorem power_basis.to_matrix_is_integral {K : Type u_1} {S : Type u_2} [field K] [comm_ring S] [algebra K S] {R : Type u_3} [comm_ring R] [algebra R S] [algebra R K] [is_scalar_tower R K S] {B B' : power_basis K S} {P : polynomial R} (h : â‡‘(polynomial.aeval B.gen) P = B'.gen) (hB : is_integral R B.gen) (hmin : minpoly K B.gen = polynomial.map (algebra_map R K) (minpoly R B.gen)) (i : fin B.dim) (j : fin B'.dim) : is_integral R (B.basis.to_matrix â‡‘(B'.basis) i j)
theorem measure_theory.unif_integrable_subsingleton {Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_3} {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) [normed_group Î²] {p : ennreal} [subsingleton Î¹] (hp_one : 1 â‰¤ p) (hp_top : p â‰  âŠ¤) {f : Î¹ â†’ Î± â†’ Î²} (hf : âˆ€ (i : Î¹), measure_theory.mem_â„’p (f i) p Î¼) : measure_theory.unif_integrable f p Î¼
theorem ring_hom.mem_ker {R : Type u} {S : Type v} [semiring R] [semiring S] (f : R â†’+* S) {r : R} : r âˆˆ f.ker â†” â‡‘f r = 0
theorem subfield.sum_mem {K : Type u} [field K] (s : subfield K) {Î¹ : Type u_1} {t : finset Î¹} {f : Î¹ â†’ K} (h : âˆ€ (c : Î¹), c âˆˆ t â†’ f c âˆˆ s) : t.sum (Î» (i : Î¹), f i) âˆˆ s
theorem quiver.hom.le {X : Type u} [preorder X] {x y : X} (h : x âŸ¶ y) : x â‰¤ y
theorem mv_power_series.ext {Ïƒ : Type u_1} {R : Type u_2} [semiring R] {Ï† Ïˆ : mv_power_series Ïƒ R} (h : âˆ€ (n : Ïƒ â†’â‚€ â„•), â‡‘(mv_power_series.coeff R n) Ï† = â‡‘(mv_power_series.coeff R n) Ïˆ) : Ï† = Ïˆ
theorem cont_diff.has_strict_fderiv_at {n : with_top â„•} {ğ•‚ : Type u_6} [is_R_or_C ğ•‚] {E' : Type u_7} [normed_group E'] [normed_space ğ•‚ E'] {F' : Type u_8} [normed_group F'] [normed_space ğ•‚ F'] {f : E' â†’ F'} {x : E'} (hf : cont_diff ğ•‚ n f) (hn : 1 â‰¤ n) : has_strict_fderiv_at f (fderiv ğ•‚ f x) x
theorem linear_map.span_preimage_le {R : Type u_1} {Râ‚‚ : Type u_2} {M : Type u_4} {Mâ‚‚ : Type u_5} [semiring R] [add_comm_monoid M] [module R M] [semiring Râ‚‚] {Ïƒâ‚â‚‚ : R â†’+* Râ‚‚} [add_comm_monoid Mâ‚‚] [module Râ‚‚ Mâ‚‚] (f : M â†’â‚›â‚—[Ïƒâ‚â‚‚] Mâ‚‚) (s : set Mâ‚‚) : submodule.span R (â‡‘f â»Â¹' s) â‰¤ submodule.comap f (submodule.span Râ‚‚ s)
theorem is_add_submonoid.image {M : Type u_1} [add_monoid M] {Î³ : Type u_2} [add_monoid Î³] {f : M â†’ Î³} (hf : is_add_monoid_hom f) {s : set M} (hs : is_add_submonoid s) : is_add_submonoid (f '' s)
theorem convex_on_of_deriv2_nonneg {D : set â„} (hD : convex â„ D) {f : â„ â†’ â„} (hf : continuous_on f D) (hf' : differentiable_on â„ f (interior D)) (hf'' : differentiable_on â„ (deriv f) (interior D)) (hf''_nonneg : âˆ€ (x : â„), x âˆˆ interior D â†’ 0 â‰¤ deriv^[2] f x) : convex_on â„ D f
theorem complex.circle_integral_eq_zero_of_differentiable_on_off_countable {E : Type u} [normed_group E] [normed_space â„‚ E] [complete_space E] {R : â„} (h0 : 0 â‰¤ R) {f : â„‚ â†’ E} {c : â„‚} {s : set â„‚} (hs : s.countable) (hc : continuous_on f (metric.closed_ball c R)) (hd : âˆ€ (z : â„‚), z âˆˆ metric.ball c R  s â†’ differentiable_at â„‚ f z) : âˆ® (z : â„‚) in C(c, R), f z = 0
theorem antivary_on.sum_mul_le_sum_comp_perm_mul {Î¹ : Type u_1} {Î± : Type u_2} [linear_ordered_ring Î±] {s : finset Î¹} {Ïƒ : equiv.perm Î¹} {f g : Î¹ â†’ Î±} (hfg : antivary_on f g â†‘s) (hÏƒ : {x : Î¹ | â‡‘Ïƒ x â‰  x} âŠ† â†‘s) : s.sum (Î» (i : Î¹), f i * g i) â‰¤ s.sum (Î» (i : Î¹), f (â‡‘Ïƒ i) * g i)
theorem is_ring_hom.id {Î± : Type u} [ring Î±] : is_ring_hom id
theorem strict_convex_on.sup {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [ordered_semiring ğ•œ] [add_comm_monoid E] [linear_ordered_add_comm_monoid Î²] [has_scalar ğ•œ E] [module ğ•œ Î²] [ordered_smul ğ•œ Î²] {s : set E} {f g : E â†’ Î²} (hf : strict_convex_on ğ•œ s f) (hg : strict_convex_on ğ•œ s g) : strict_convex_on ğ•œ s (f âŠ” g)
theorem intermediate_field.one_mem {K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) : 1 âˆˆ S
theorem mul_self_mul_inv {Gâ‚€ : Type u_2} [group_with_zero Gâ‚€] (a : Gâ‚€) : a * a * aâ»Â¹ = a
theorem algebra.discr_eq_discr_of_to_matrix_coeff_is_integral {Î¹ : Type w} {Î¹' : Type u_1} [fintype Î¹'] [fintype Î¹] (K : Type u) [field K] [number_field K] {b : basis Î¹ â„š K} {b' : basis Î¹' â„š K} (h : âˆ€ (i : Î¹) (j : Î¹'), is_integral â„¤ (b.to_matrix â‡‘b' i j)) (h' : âˆ€ (i : Î¹') (j : Î¹), is_integral â„¤ (b'.to_matrix â‡‘b i j)) : algebra.discr â„š â‡‘b = algebra.discr â„š â‡‘b'
theorem formal_multilinear_series.min_radius_le_radius_add {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field ğ•œ] [normed_group E] [normed_space ğ•œ E] [normed_group F] [normed_space ğ•œ F] (p q : formal_multilinear_series ğ•œ E F) : linear_order.min p.radius q.radius â‰¤ (p + q).radius
theorem setoid.ker_mk_eq {Î± : Type u_1} (r : setoid Î±) : setoid.ker quotient.mk = r
theorem measure_theory.measure.inner_regular.of_pseudo_emetric_space {X : Type u_1} [pseudo_emetric_space X] [measurable_space X] (Î¼ : measure_theory.measure X) : Î¼.inner_regular is_closed is_open
theorem clifford_algebra_complex.to_complex_involute (c : clifford_algebra clifford_algebra_complex.Q) : â‡‘clifford_algebra_complex.to_complex (â‡‘clifford_algebra.involute c) = â‡‘(star_ring_end â„‚) (â‡‘clifford_algebra_complex.to_complex c)
theorem formal_multilinear_series.right_inv_remove_zero {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] (p : formal_multilinear_series ğ•œ E F) (i : E â‰ƒL[ğ•œ] F) : p.remove_zero.right_inv i = p.right_inv i
theorem measure_theory.ae_measurable_fderiv_within {E : Type u_1} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] {s : set E} {f : E â†’ E} {f' : E â†’ (E â†’L[â„] E)} [measurable_space E] [borel_space E] (Î¼ : measure_theory.measure E) [Î¼.is_add_haar_measure] (hs : measurable_set s) (hf' : âˆ€ (x : E), x âˆˆ s â†’ has_fderiv_within_at f (f' x) s x) : ae_measurable f' (Î¼.restrict s)
theorem nat.totient_eq_prod_factorization {n : â„•} (hn : n â‰  0) : n.totient = n.factorization.prod (Î» (p k : â„•), p ^ (k - 1) * (p - 1))
theorem category_theory.cosimplicial_object.Ïƒ_comp_Ïƒ {C : Type u} [category_theory.category C] (X : category_theory.cosimplicial_object C) {n : â„•} {i j : fin (n + 1)} (H : i â‰¤ j) : X.Ïƒ (â‡‘fin.cast_succ i) â‰« X.Ïƒ j = X.Ïƒ j.succ â‰« X.Ïƒ i
theorem mul_add_mul_le_mul_add_mul {Î± : Type u} [ordered_semiring Î±] {a b c d : Î±} [has_exists_add_of_le Î±] (hab : a â‰¤ b) (hcd : c â‰¤ d) : a * d + b * c â‰¤ a * c + b * d
theorem strict_mono.strict_anti_iterate_of_map_lt {Î± : Type u_1} [preorder Î±] {f : Î± â†’ Î±} {x : Î±} (hf : strict_mono f) (hx : f x < x) : strict_anti (Î» (n : â„•), f^[n] x)
theorem unique_mdiff_on.unique_mdiff_on_preimage {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {M : Type u_4} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners ğ•œ E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] {s : set M} [smooth_manifold_with_corners I' M'] (hs : unique_mdiff_on I s) {e : local_homeomorph M M'} (he : local_homeomorph.mdifferentiable I I' e) : unique_mdiff_on I' (e.to_local_equiv.target âˆ© â‡‘(e.symm) â»Â¹' s)
theorem strict_anti_on.strict_concave_on_of_deriv {D : set â„} (hD : convex â„ D) {f : â„ â†’ â„} (hf : continuous_on f D) (hf' : differentiable_on â„ f (interior D)) (h_anti : strict_anti_on (deriv f) (interior D)) : strict_concave_on â„ D f
theorem measure_theory.map_prod_mul_inv_eq {G : Type u_1} [measurable_space G] [group G] [has_measurable_mulâ‚‚ G] (Î¼ Î½ : measure_theory.measure G) [measure_theory.sigma_finite Î½] [measure_theory.sigma_finite Î¼] [has_measurable_inv G] [Î¼.is_mul_left_invariant] [Î½.is_mul_left_invariant] : measure_theory.measure.map (Î» (z : G Ã— G), (z.snd * z.fst, (z.fst)â»Â¹)) (Î¼.prod Î½) = Î¼.prod Î½
theorem continuous_at_matrix_inv {n : Type u_5} {R : Type u_8} [topological_space R] [fintype n] [decidable_eq n] [comm_ring R] [topological_ring R] (A : matrix n n R) (h : continuous_at ring.inverse A.det) : continuous_at has_inv.inv A
theorem add_subsemigroup.add_mem {M : Type u_1} [has_add M] (S : add_subsemigroup M) {x y : M} : x âˆˆ S â†’ y âˆˆ S â†’ x + y âˆˆ S
theorem monotone.mul' {Î± : Type u_1} {Î² : Type u_2} [has_mul Î±] [preorder Î±] [preorder Î²] {f g : Î² â†’ Î±} [covariant_class Î± Î± has_mul.mul has_le.le] [covariant_class Î± Î± (function.swap has_mul.mul) has_le.le] (hf : monotone f) (hg : monotone g) : monotone (Î» (x : Î²), f x * g x)
theorem finset.sum_range_sub_of_monotone {Î± : Type v} [canonically_ordered_add_monoid Î±] [has_sub Î±] [has_ordered_sub Î±] [contravariant_class Î± Î± has_add.add has_le.le] {f : â„• â†’ Î±} (h : monotone f) (n : â„•) : (finset.range n).sum (Î» (i : â„•), f (i + 1) - f i) = f n - f 0
theorem quadratic_ne_zero_of_discrim_ne_sq {R : Type u_1} [comm_ring R] [is_domain R] {a b c : R} (h2 : 2 â‰  0) (ha : a â‰  0) (h : âˆ€ (s : R), discrim a b c â‰  s * s) (x : R) : a * x * x + b * x + c â‰  0
theorem euclidean_geometry.orthocentric_system.affine_independent {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {s : set P} (ho : euclidean_geometry.orthocentric_system s) {p : fin 3 â†’ P} (hps : set.range p âŠ† s) (hpi : function.injective p) : affine_independent â„ p
theorem vector.to_list_scanl {n : â„•} {Î± : Type u_1} {Î² : Type u_2} (f : Î² â†’ Î± â†’ Î²) (b : Î²) (v : vector Î± n) : (vector.scanl f b v).to_list = list.scanl f b v.to_list
theorem exists_nat_nat_continuous_surjective_of_complete_space (Î± : Type u_1) [metric_space Î±] [complete_space Î±] [topological_space.second_countable_topology Î±] [nonempty Î±] : âˆƒ (f : (â„• â†’ â„•) â†’ Î±), continuous f âˆ§ function.surjective f
theorem units.exists0' {Gâ‚€ : Type u_2} [group_with_zero Gâ‚€] {p : Î  (g : Gâ‚€), g â‰  0 â†’ Prop} : (âˆƒ (g : Gâ‚€) (hg : g â‰  0), p g hg) â†” âˆƒ (g : Gâ‚€Ë£), p â†‘g _
theorem orientation.eq_rotation_self_iff_angle_eq_zero {V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) {x : V} (hx : x â‰  0) (Î¸ : real.angle) : x = â‡‘(o.rotation Î¸) x â†” Î¸ = 0
theorem affine_equiv.point_reflection_fixed_iff_of_injective_bit0 (k : Type u_1) {Pâ‚ : Type u_2} {Vâ‚ : Type u_6} [ring k] [add_comm_group Vâ‚] [module k Vâ‚] [add_torsor Vâ‚ Pâ‚] {x y : Pâ‚} (h : function.injective bit0) : â‡‘(affine_equiv.point_reflection k x) y = y â†” y = x
theorem local_homeomorph.eq_on_source.restr {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] {e e' : local_homeomorph Î± Î²} (he : e â‰ˆ e') (s : set Î±) : e.restr s â‰ˆ e'.restr s
theorem function.bijective.comp_left {Î± : Sort u} {Î² : Sort v} {Î³ : Sort w} {g : Î² â†’ Î³} (hg : function.bijective g) : function.bijective (function.comp g)
theorem measurable.ennreal_tsum {Î± : Type u_1} [measurable_space Î±] {Î¹ : Type u_2} [encodable Î¹] {f : Î¹ â†’ Î± â†’ ennreal} (h : âˆ€ (i : Î¹), measurable (f i)) : measurable (Î» (x : Î±), âˆ‘' (i : Î¹), f i x)
theorem is_local_extr_on.linear_dependent_of_has_strict_fderiv_at {E : Type u_1} [normed_group E] [normed_space â„ E] [complete_space E] {Ï† : E â†’ â„} {xâ‚€ : E} {Ï†' : E â†’L[â„] â„} {Î¹ : Type u_2} [fintype Î¹] {f : Î¹ â†’ E â†’ â„} {f' : Î¹ â†’ (E â†’L[â„] â„)} (hextr : is_local_extr_on Ï† {x : E | âˆ€ (i : Î¹), f i x = f i xâ‚€} xâ‚€) (hf' : âˆ€ (i : Î¹), has_strict_fderiv_at (f i) (f' i) xâ‚€) (hÏ†' : has_strict_fderiv_at Ï† Ï†' xâ‚€) : Â¬linear_independent â„ (option.elim Ï†' f')
theorem module.ray.units_smul_of_neg {R : Type u_1} [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] (u : RË£) (hu : â†‘u < 0) (v : module.ray R M) : u â€¢ v = -v
theorem generalized_continued_fraction.coe_of_rat_eq {K : Type u_1} [linear_ordered_field K] [floor_ring K] {v : K} {q : â„š} (v_eq_q : v = â†‘q) : {h := â†‘((generalized_continued_fraction.of q).h), s := seq.map (generalized_continued_fraction.pair.map coe) (generalized_continued_fraction.of q).s} = generalized_continued_fraction.of v
theorem smul_mul_smul {M : Type u_1} {Î± : Type u_6} [monoid M] [mul_action M Î±] [has_mul Î±] (r s : M) (x y : Î±) [is_scalar_tower M Î± Î±] [smul_comm_class M Î± Î±] : r â€¢ x * s â€¢ y = (r * s) â€¢ (x * y)
theorem polynomial.add_submonoid_closure_set_of_eq_monomial {R : Type u} [semiring R] : add_submonoid.closure {p : polynomial R | âˆƒ (n : â„•) (a : R), p = â‡‘(polynomial.monomial n) a} = âŠ¤
theorem is_dedekind_domain.height_one_spectrum.int_valuation_le_pow_iff_dvd {R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] (v : is_dedekind_domain.height_one_spectrum R) (r : R) (n : â„•) : v.int_valuation_def r â‰¤ â†‘(â‡‘multiplicative.of_add (-â†‘n)) â†” v.as_ideal ^ n âˆ£ ideal.span {r}
theorem vector.scanl_val {n : â„•} {Î± : Type u_1} {Î² : Type u_2} (f : Î² â†’ Î± â†’ Î²) (b : Î²) {v : vector Î± n} : (vector.scanl f b v).val = list.scanl f b v.val
theorem category_theory.limits.has_limits_of_shape_of_equivalence {J : Type uâ‚} [category_theory.category J] {C : Type u} [category_theory.category C] {J' : Type uâ‚‚} [category_theory.category J'] (e : J â‰Œ J') [category_theory.limits.has_limits_of_shape J C] : category_theory.limits.has_limits_of_shape J' C
theorem tactic.bicategory.coherence.assoc_lift_homâ‚‚ {B : Type u} [category_theory.bicategory B] {a b : B} {f g h i : a âŸ¶ b} [category_theory.bicategory.lift_hom f] [category_theory.bicategory.lift_hom g] [category_theory.bicategory.lift_hom h] (Î· : f âŸ¶ g) (Î¸ : g âŸ¶ h) (Î¹ : h âŸ¶ i) [category_theory.bicategory.lift_homâ‚‚ Î·] [category_theory.bicategory.lift_homâ‚‚ Î¸] : Î· â‰« Î¸ â‰« Î¹ = (Î· â‰« Î¸) â‰« Î¹
theorem local_homeomorph.is_image.preimage_eq {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] {e : local_homeomorph Î± Î²} {s : set Î±} {t : set Î²} : e.is_image s t â†’ e.to_local_equiv.source âˆ© â‡‘e â»Â¹' t = e.to_local_equiv.source âˆ© s
theorem box_integral.has_integral.tendsto {Î¹ : Type u} {E : Type v} {F : Type w} [normed_group E] [normed_space â„ E] [normed_group F] [normed_space â„ F] {I : box_integral.box Î¹} [fintype Î¹] {l : box_integral.integration_params} {f : (Î¹ â†’ â„) â†’ E} {vol : box_integral.box_additive_map Î¹ (E â†’L[â„] F) âŠ¤} {y : F} (h : box_integral.has_integral I l f vol y) : filter.tendsto (box_integral.integral_sum f vol) (l.to_filter_Union I âŠ¤) (nhds y)
theorem has_fderiv_within_at_of_not_mem_closure {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {f : E â†’ F} {f' : E â†’L[ğ•œ] F} {x : E} {s : set E} (h : x âˆ‰ closure s) : has_fderiv_within_at f f' s x
theorem con.con_gen_le {M : Type u_1} [has_mul M] {r : M â†’ M â†’ Prop} {c : con M} (h : âˆ€ (x y : M), r x y â†’ setoid.r x y) : con_gen r â‰¤ c
theorem category_theory.Ran_is_sheaf_of_cover_lifting.glued_section_is_unique {C D : Type u} [category_theory.category C] [category_theory.category D] {A : Type w} [category_theory.category A] [category_theory.limits.has_limits A] {J : category_theory.grothendieck_topology C} {K : category_theory.grothendieck_topology D} {G : C â¥¤ D} (hu : category_theory.cover_lifting J K G) (â„± : category_theory.Sheaf J A) {X : A} {U : D} {S : category_theory.sieve U} (hS : S âˆˆ â‡‘K U) {x : category_theory.presieve.family_of_elements ((category_theory.Ran G.op).obj â„±.val â‹™ category_theory.coyoneda.obj (opposite.op X)) S.arrows} (hx : x.compatible) (y : ((category_theory.Ran G.op).obj â„±.val â‹™ category_theory.coyoneda.obj (opposite.op X)).obj (opposite.op U)) (hy : x.is_amalgamation y) : y = category_theory.Ran_is_sheaf_of_cover_lifting.glued_section hu â„± hS hx
theorem int.le_self_pow_two (b : â„¤) : b â‰¤ b ^ 2
theorem is_closed.is_lub_mem {Î± : Type u} [topological_space Î±] [linear_order Î±] [order_topology Î±] {a : Î±} {s : set Î±} (ha : is_lub s a) (hs : s.nonempty) (sc : is_closed s) : a âˆˆ s
theorem modular_group.one_lt_norm_sq_T_zpow_smul {z : upper_half_plane} (hz : z âˆˆ modular_group.fdo) (n : â„¤) : 1 < â‡‘complex.norm_sq â†‘(modular_group.T ^ n â€¢ z)
theorem tsum_mul_tsum_eq_tsum_sum_antidiagonal_of_summable_norm {Î± : Type u_1} [normed_ring Î±] [complete_space Î±] {f g : â„• â†’ Î±} (hf : summable (Î» (x : â„•), âˆ¥f xâˆ¥)) (hg : summable (Î» (x : â„•), âˆ¥g xâˆ¥)) : (âˆ‘' (n : â„•), f n) * âˆ‘' (n : â„•), g n = âˆ‘' (n : â„•), (finset.nat.antidiagonal n).sum (Î» (kl : â„• Ã— â„•), f kl.fst * g kl.snd)
theorem smul_cancel_of_non_zero_divisor {M : Type u_1} {R : Type u_2} [monoid M] [non_unital_non_assoc_ring R] [distrib_mul_action M R] (k : M) (h : âˆ€ (x : R), k â€¢ x = 0 â†’ x = 0) {a b : R} (h' : k â€¢ a = k â€¢ b) : a = b
theorem equiv.perm.is_three_cycle_sq_of_three_mem_cycle_type_five {g : equiv.perm (fin 5)} (h : 3 âˆˆ g.cycle_type) : (g * g).is_three_cycle
theorem category_theory.limits.initial_mono_class_of_disjoint_coproducts {C : Type u} [category_theory.category C] [category_theory.limits.coproducts_disjoint C] : category_theory.limits.initial_mono_class C
theorem is_localization.is_domain_of_le_non_zero_divisors {S : Type u_2} [comm_ring S] (A : Type u_6) [comm_ring A] [is_domain A] [algebra A S] {M : submonoid A} [is_localization M S] (hM : M â‰¤ non_zero_divisors A) : is_domain S
theorem orthonormal.exists_linear_isometry_equiv_map_eq_of_orientation_eq_neg {V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) {bâ‚‚ : basis (fin 2) â„ V} (hbâ‚‚ : orthonormal â„ â‡‘bâ‚‚) (ho : b.orientation = -bâ‚‚.orientation) : âˆƒ (Î¸ : real.angle), bâ‚‚ = b.map (hb.conj_lie.trans (hb.rotation Î¸)).to_linear_equiv
theorem measure_theory.L1.of_real_norm_sub_eq_lintegral {Î± : Type u_1} {Î² : Type u_2} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [normed_group Î²] (f g : â†¥(measure_theory.Lp Î² 1 Î¼)) : ennreal.of_real âˆ¥f - gâˆ¥ = âˆ«â» (x : Î±), â†‘âˆ¥â‡‘f x - â‡‘g xâˆ¥â‚Š âˆ‚Î¼
theorem polynomial.cyclotomic_pos' (n : â„•) {R : Type u_1} [linear_ordered_comm_ring R] {x : R} (hx : 1 < x) : 0 < polynomial.eval x (polynomial.cyclotomic n R)
theorem has_deriv_at_of_has_deriv_at_of_ne' {E : Type u_1} [normed_group E] [normed_space â„ E] {f g : â„ â†’ E} {x : â„} (f_diff : âˆ€ (y : â„), y â‰  x â†’ has_deriv_at f (g y) y) (hf : continuous_at f x) (hg : continuous_at g x) (y : â„) : has_deriv_at f (g y) y
theorem colex.forall_lt_of_colex_lt_of_forall_lt {Î± : Type u_1} [linear_order Î±] {A B : finset Î±} (t : Î±) (hâ‚ : A.to_colex < B.to_colex) (hâ‚‚ : âˆ€ (x : Î±), x âˆˆ B â†’ x < t) (x : Î±) (H : x âˆˆ A) : x < t
theorem polynomial.lifts_iff_lifts_ring {R : Type u} [ring R] {S : Type v} [ring S] (f : R â†’+* S) (p : polynomial S) : p âˆˆ polynomial.lifts f â†” p âˆˆ polynomial.lifts_ring f
theorem lt_tsub_of_add_lt_right {Î± : Type u_1} [canonically_ordered_add_monoid Î±] [has_sub Î±] [has_ordered_sub Î±] {a b c : Î±} [contravariant_class Î± Î± has_add.add has_le.le] (h : a + c < b) : a < b - c
theorem finset.prod_comp {Î² : Type u} {Î± : Type v} {Î³ : Type w} {s : finset Î±} [comm_monoid Î²] [decidable_eq Î³] (f : Î³ â†’ Î²) (g : Î± â†’ Î³) : s.prod (Î» (a : Î±), f (g a)) = (finset.image g s).prod (Î» (b : Î³), f b ^ (finset.filter (Î» (a : Î±), g a = b) s).card)
theorem subfield.closure_le {K : Type u} [field K] {s : set K} {t : subfield K} : subfield.closure s â‰¤ t â†” s âŠ† â†‘t
theorem filter.tendsto.at_bot_mul {Î± : Type u} {Î² : Type v} [linear_ordered_field Î±] [topological_space Î±] [order_topology Î±] {l : filter Î²} {f g : Î² â†’ Î±} {C : Î±} (hC : 0 < C) (hf : filter.tendsto f l filter.at_bot) (hg : filter.tendsto g l (nhds C)) : filter.tendsto (Î» (x : Î²), f x * g x) l filter.at_bot
theorem affine.simplex.circumcenter_eq_centroid {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] (s : affine.simplex â„ P 1) : s.circumcenter = finset.centroid â„ finset.univ s.points
theorem measure_theory.exists_nonempty_inter_of_measure_univ_lt_sum_measure {Î± : Type u_1} {Î¹ : Type u_5} {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) {s : finset Î¹} {t : Î¹ â†’ set Î±} (h : âˆ€ (i : Î¹), i âˆˆ s â†’ measurable_set (t i)) (H : â‡‘Î¼ set.univ < s.sum (Î» (i : Î¹), â‡‘Î¼ (t i))) : âˆƒ (i : Î¹) (H : i âˆˆ s) (j : Î¹) (H : j âˆˆ s) (h : i â‰  j), (t i âˆ© t j).nonempty
theorem summable_of_nonneg_of_le {Î² : Type u_2} {f g : Î² â†’ â„} (hg : âˆ€ (b : Î²), 0 â‰¤ g b) (hgf : âˆ€ (b : Î²), g b â‰¤ f b) (hf : summable f) : summable g
theorem monovary.sum_smul_comp_perm_lt_sum_smul_iff {Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [linear_ordered_ring Î±] [linear_ordered_add_comm_group Î²] [module Î± Î²] [ordered_smul Î± Î²] {Ïƒ : equiv.perm Î¹} {f : Î¹ â†’ Î±} {g : Î¹ â†’ Î²} [fintype Î¹] (hfg : monovary f g) : finset.univ.sum (Î» (i : Î¹), f i â€¢ g (â‡‘Ïƒ i)) < finset.univ.sum (Î» (i : Î¹), f i â€¢ g i) â†” Â¬monovary f (g âˆ˜ â‡‘Ïƒ)
theorem exists_locally_finite_subset_Union_ball_radius_lt {Î± : Type u} [metric_space Î±] [proper_space Î±] {s : set Î±} (hs : is_closed s) {R : Î± â†’ â„} (hR : âˆ€ (x : Î±), x âˆˆ s â†’ 0 < R x) : âˆƒ (Î¹ : Type u) (c : Î¹ â†’ Î±) (r r' : Î¹ â†’ â„), (âˆ€ (i : Î¹), c i âˆˆ s âˆ§ 0 < r i âˆ§ r i < r' i âˆ§ r' i < R (c i)) âˆ§ locally_finite (Î» (i : Î¹), metric.ball (c i) (r' i)) âˆ§ s âŠ† â‹ƒ (i : Î¹), metric.ball (c i) (r i)
theorem monoid.closure_mono {M : Type u_1} [monoid M] {s t : set M} (h : s âŠ† t) : monoid.closure s âŠ† monoid.closure t
theorem line_map_lt_map_iff_slope_lt_slope {k : Type u_1} {E : Type u_2} [linear_ordered_field k] [ordered_add_comm_group E] [module k E] [ordered_smul k E] {f : k â†’ E} {a b r : k} (hab : a < b) (hâ‚€ : 0 < r) (hâ‚ : r < 1) : â‡‘(affine_map.line_map (f a) (f b)) r < f (â‡‘(affine_map.line_map a b) r) â†” slope f (â‡‘(affine_map.line_map a b) r) b < slope f a (â‡‘(affine_map.line_map a b) r)
theorem filter.is_bounded_under.is_o_sub_self_inv {ğ•œ : Type u_1} {E : Type u_2} [normed_field ğ•œ] [has_norm E] {a : ğ•œ} {f : ğ•œ â†’ E} (h : filter.is_bounded_under has_le.le (nhds_within a {a}á¶œ) (has_norm.norm âˆ˜ f)) : f =o[nhds_within a {a}á¶œ] Î» (x : ğ•œ), (x - a)â»Â¹
theorem first_order.language.directed_system.map_map {L : first_order.language} {Î¹ : Type v} [preorder Î¹] {G : Î¹ â†’ Type w} [Î  (i : Î¹), L.Structure (G i)] (f : Î  (i j : Î¹), i â‰¤ j â†’ L.embedding (G i) (G j)) [directed_system G (Î» (i j : Î¹) (h : i â‰¤ j), â‡‘(f i j h))] {i j k : Î¹} (hij : i â‰¤ j) (hjk : j â‰¤ k) (x : G i) : â‡‘(f j k hjk) (â‡‘(f i j hij) x) = â‡‘(f i k _) x
theorem locally_finite.exists_finset_nhd_mul_support_subset {X : Type u_1} {R : Type u_9} {Î¹ : Type u_10} {U : Î¹ â†’ set X} [topological_space X] [has_one R] {f : Î¹ â†’ X â†’ R} (hlf : locally_finite (Î» (i : Î¹), function.mul_support (f i))) (hso : âˆ€ (i : Î¹), mul_tsupport (f i) âŠ† U i) (ho : âˆ€ (i : Î¹), is_open (U i)) (x : X) : âˆƒ (is : finset Î¹) {n : set X} (hnâ‚ : n âˆˆ nhds x) (hnâ‚‚ : n âŠ† â‹‚ (i : Î¹) (H : i âˆˆ is), U i), âˆ€ (z : X), z âˆˆ n â†’ function.mul_support (Î» (i : Î¹), f i z) âŠ† â†‘is
theorem nilpotent_center_quotient_ind {P : Î  (G : Type u_1) [_inst_3 : group G] [_inst_4 : group.is_nilpotent G], Prop} (G : Type u_1) [group G] [group.is_nilpotent G] (hbase : âˆ€ (G : Type u_1) [_inst_6 : group G] [_inst_7 : subsingleton G], P G) (hstep : âˆ€ (G : Type u_1) [_inst_8 : group G] [_inst_9 : group.is_nilpotent G], P (G â§¸ subgroup.center G) â†’ P G) : P G
theorem category_theory.preadditive.has_coequalizers_of_has_cokernels {C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_cokernels C] : category_theory.limits.has_coequalizers C
theorem add_monoid_hom.map_add {M : Type u_3} {N : Type u_4} [add_zero_class M] [add_zero_class N] (f : M â†’+ N) (a b : M) : â‡‘f (a + b) = â‡‘f a + â‡‘f b
theorem probability_theory.cond_apply {Î± : Type u_1} {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) {s : set Î±} (hms : measurable_set s) (t : set Î±) : â‡‘(probability_theory.cond Î¼ s) t = (â‡‘Î¼ s)â»Â¹ * â‡‘Î¼ (s âˆ© t)
theorem category_theory.limits.biproduct.cone_point_unique_up_to_iso_inv {J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (f : J â†’ C) [category_theory.limits.has_biproduct f] {b : category_theory.limits.bicone f} (hb : b.is_bilimit) : (hb.is_limit.cone_point_unique_up_to_iso (category_theory.limits.biproduct.is_limit f)).inv = category_theory.limits.biproduct.desc b.Î¹
theorem finite_field.card_image_polynomial_eval {R : Type u_2} [comm_ring R] [is_domain R] [decidable_eq R] [fintype R] {p : polynomial R} (hp : 0 < p.degree) : fintype.card R â‰¤ p.nat_degree * (finset.image (Î» (x : R), polynomial.eval x p) finset.univ).card
theorem discrim_lt_zero {K : Type u_1} [linear_ordered_field K] {a b c : K} (ha : a â‰  0) (h : âˆ€ (x : K), 0 < a * x * x + b * x + c) : discrim a b c < 0
theorem set.finite.bUnion' {Î± : Type u} {Î¹ : Type u_1} {s : set Î¹} (hs : s.finite) {t : Î  (i : Î¹), i âˆˆ s â†’ set Î±} (ht : âˆ€ (i : Î¹) (H : i âˆˆ s), (t i H).finite) : (â‹ƒ (i : Î¹) (H : i âˆˆ s), t i H).finite
theorem finite_dimensional.nonempty_continuous_linear_equiv_of_finrank_eq {ğ•œ : Type u} [nondiscrete_normed_field ğ•œ] {E : Type v} [normed_group E] [normed_space ğ•œ E] {F : Type w} [normed_group F] [normed_space ğ•œ F] [complete_space ğ•œ] [finite_dimensional ğ•œ E] [finite_dimensional ğ•œ F] (cond : finite_dimensional.finrank ğ•œ E = finite_dimensional.finrank ğ•œ F) : nonempty (E â‰ƒL[ğ•œ] F)
theorem is_monoid_hom.map_mul {Î± : Type u} {Î² : Type v} [mul_one_class Î±] [mul_one_class Î²] {f : Î± â†’ Î²} (hf : is_monoid_hom f) (x y : Î±) : f (x * y) = f x * f y
theorem nat.mem_factors_mul_right {p a b : â„•} (hpb : p âˆˆ b.factors) (ha : a â‰  0) : p âˆˆ (a * b).factors
theorem is_max.of_dual {Î± : Type u_1} [has_le Î±] {a : Î±áµ’áµˆ} : is_max a â†’ is_min (â‡‘order_dual.of_dual a)
theorem nonempty_sections_of_fintype_cofiltered_system {J : Type u} [category_theory.category J] [category_theory.is_cofiltered J] (F : J â¥¤ Type v) [Î  (j : J), fintype (F.obj j)] [âˆ€ (j : J), nonempty (F.obj j)] : F.sections.nonempty
theorem finset.image_imageâ‚‚_antidistrib_left {Î± : Type u_1} {Î² : Type u_3} {Î²' : Type u_4} {Î³ : Type u_5} {Î´ : Type u_7} [decidable_eq Î²'] [decidable_eq Î³] [decidable_eq Î´] {f : Î± â†’ Î² â†’ Î³} {s : finset Î±} {t : finset Î²} {g : Î³ â†’ Î´} {f' : Î²' â†’ Î± â†’ Î´} {g' : Î² â†’ Î²'} (h_antidistrib : âˆ€ (a : Î±) (b : Î²), g (f a b) = f' (g' b) a) : finset.image g (finset.imageâ‚‚ f s t) = finset.imageâ‚‚ f' (finset.image g' t) s
theorem ring_hom.map_one_ne_zero {Î± : Type u_2} {Î² : Type u_3} {rÎ± : non_assoc_semiring Î±} {rÎ² : non_assoc_semiring Î²} (f : Î± â†’+* Î²) [nontrivial Î²] : â‡‘f 1 â‰  0
theorem emetric.uniform_embedding_iff {Î± : Type u} {Î² : Type v} [pseudo_emetric_space Î±] [pseudo_emetric_space Î²] {f : Î± â†’ Î²} : uniform_embedding f â†” function.injective f âˆ§ uniform_continuous f âˆ§ âˆ€ (Î´ : ennreal), Î´ > 0 â†’ (âˆƒ (Îµ : ennreal) (H : Îµ > 0), âˆ€ {a b : Î±}, has_edist.edist (f a) (f b) < Îµ â†’ has_edist.edist a b < Î´)
theorem add_monoid_algebra.finite_type_iff_group_fg {R : Type u_1} {G : Type u_2} [add_comm_group G] [comm_ring R] [nontrivial R] : algebra.finite_type R (add_monoid_algebra R G) â†” add_group.fg G
theorem convex.add_smul_mem_interior {E : Type u_2} {ğ•œ : Type u_3} [linear_ordered_field ğ•œ] [add_comm_group E] [module ğ•œ E] [topological_space E] [topological_add_group E] [has_continuous_const_smul ğ•œ E] {s : set E} (hs : convex ğ•œ s) {x y : E} (hx : x âˆˆ s) (hy : x + y âˆˆ interior s) {t : ğ•œ} (ht : t âˆˆ set.Ioc 0 1) : x + t â€¢ y âˆˆ interior s
theorem complex.has_deriv_at_sinh (x : â„‚) : has_deriv_at complex.sinh (complex.cosh x) x
theorem affine_subspace.direction_of_nonempty_eq_direction {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : affine_subspace k P} (h : â†‘s.nonempty) : affine_subspace.direction_of_nonempty h = s.direction
theorem finset.mem_dfinsupp_iff_of_support_subset {Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_2} [decidable_eq Î¹] [Î  (i : Î¹), has_zero (Î± i)] {s : finset Î¹} {f : Î â‚€ (i : Î¹), Î± i} [Î  (i : Î¹), decidable_eq (Î± i)] {t : Î â‚€ (i : Î¹), finset (Î± i)} (ht : t.support âŠ† s) : f âˆˆ s.dfinsupp â‡‘t â†” âˆ€ (i : Î¹), â‡‘f i âˆˆ â‡‘t i
theorem padic_norm.mul (p : â„•) [hp : fact (nat.prime p)] (q r : â„š) : padic_norm p (q * r) = padic_norm p q * padic_norm p r
theorem fintype.nonempty_field_iff {Î± : Type u_1} [fintype Î±] : nonempty (field Î±) â†” is_prime_pow (fintype.card Î±)
theorem reflection_mem_subspace_orthogonal_precomplement_eq_neg {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {K : submodule ğ•œ E} [complete_space E] {v : E} (hv : v âˆˆ K) : â‡‘(reflection Ká—®) v = -v
theorem order_top.bdd_above {Î³ : Type w} [preorder Î³] [order_top Î³] (s : set Î³) : bdd_above s
theorem is_primitive_root.discr_zeta_eq_discr_zeta_sub_one {n : â„•+} {K : Type u} [field K] [char_zero K] {Î¶ : K} [is_cyclotomic_extension {n} â„š K] (hÎ¶ : is_primitive_root Î¶ â†‘n) : algebra.discr â„š â‡‘((is_primitive_root.power_basis â„š hÎ¶).basis) = algebra.discr â„š â‡‘((is_primitive_root.sub_one_power_basis â„š hÎ¶).basis)
theorem emetric.Hausdorff_edist_comm {Î± : Type u} [pseudo_emetric_space Î±] {s t : set Î±} : emetric.Hausdorff_edist s t = emetric.Hausdorff_edist t s
theorem orthogonal_projection_inner_eq_zero {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {K : submodule ğ•œ E} [complete_space â†¥K] (v w : E) (H : w âˆˆ K) : has_inner.inner (v - â†‘(â‡‘(orthogonal_projection K) v)) w = 0
theorem affine.triangle.dist_orthocenter_reflection_circumcenter {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] (t : affine.triangle â„ P) {iâ‚ iâ‚‚ : fin 3} (h : iâ‚ â‰  iâ‚‚) : has_dist.dist t.orthocenter (â‡‘(euclidean_geometry.reflection (affine_span â„ (t.points '' {iâ‚, iâ‚‚}))) (affine.simplex.circumcenter t)) = affine.simplex.circumradius t
theorem vitali_family.ae_eventually_measure_pos {Î± : Type u_1} [metric_space Î±] {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (v : vitali_family Î¼) [topological_space.second_countable_topology Î±] : âˆ€áµ (x : Î±) âˆ‚Î¼, âˆ€á¶  (a : set Î±) in v.filter_at x, 0 < â‡‘Î¼ a
theorem dense_inducing.tendsto_comap_nhds_nhds {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} {Î´ : Type u_4} [topological_space Î±] [topological_space Î²] {i : Î± â†’ Î²} [topological_space Î´] {f : Î³ â†’ Î±} {g : Î³ â†’ Î´} {h : Î´ â†’ Î²} {d : Î´} {a : Î±} (di : dense_inducing i) (H : filter.tendsto h (nhds d) (nhds (i a))) (comm : h âˆ˜ g = i âˆ˜ f) : filter.tendsto f (filter.comap g (nhds d)) (nhds a)
theorem has_subset.subset.ssubset_of_ne {Î± : Type u} [has_subset Î±] [has_ssubset Î±] [is_nonstrict_strict_order Î± has_subset.subset has_ssubset.ssubset] {a b : Î±} [is_antisymm Î± has_subset.subset] (hâ‚ : a âŠ† b) (hâ‚‚ : a â‰  b) : a âŠ‚ b
theorem is_preconnected.Union_of_refl_trans_gen {Î± : Type u} [topological_space Î±] {Î¹ : Type u_1} {s : Î¹ â†’ set Î±} (H : âˆ€ (i : Î¹), is_preconnected (s i)) (K : âˆ€ (i j : Î¹), relation.refl_trans_gen (Î» (i j : Î¹), (s i âˆ© s j).nonempty) i j) : is_preconnected (â‹ƒ (n : Î¹), s n)
theorem monovary_on.sum_mul_comp_perm_eq_sum_mul_iff {Î¹ : Type u_1} {Î± : Type u_2} [linear_ordered_ring Î±] {s : finset Î¹} {Ïƒ : equiv.perm Î¹} {f g : Î¹ â†’ Î±} (hfg : monovary_on f g â†‘s) (hÏƒ : {x : Î¹ | â‡‘Ïƒ x â‰  x} âŠ† â†‘s) : s.sum (Î» (i : Î¹), f i * g (â‡‘Ïƒ i)) = s.sum (Î» (i : Î¹), f i * g i) â†” monovary_on f (g âˆ˜ â‡‘Ïƒ) â†‘s
theorem shrinking_lemma.partial_refinement.le_chain_Sup {Î¹ : Type u_1} {X : Type u_2} [topological_space X] [normal_space X] {u : Î¹ â†’ set X} {s : set X} {c : set (shrinking_lemma.partial_refinement u s)} (hc : is_chain has_le.le c) (ne : c.nonempty) (hfin : âˆ€ (x : X), x âˆˆ s â†’ {i : Î¹ | x âˆˆ u i}.finite) (hU : s âŠ† â‹ƒ (i : Î¹), u i) {v : shrinking_lemma.partial_refinement u s} (hv : v âˆˆ c) : v â‰¤ shrinking_lemma.partial_refinement.chain_Sup c hc ne hfin hU
theorem matrix.nondegenerate.of_det_ne_zero {n : Type u_3} [fintype n] {A : Type u_1} [decidable_eq n] [comm_ring A] [is_domain A] {M : matrix n n A} : M.det â‰  0 â†’ M.nondegenerate
theorem deriv.lhopital_zero_nhds_left {a : â„} {l : filter â„} {f g : â„ â†’ â„} (hdf : âˆ€á¶  (x : â„) in nhds_within a (set.Iio a), differentiable_at â„ f x) (hg' : âˆ€á¶  (x : â„) in nhds_within a (set.Iio a), deriv g x â‰  0) (hfa : filter.tendsto f (nhds_within a (set.Iio a)) (nhds 0)) (hga : filter.tendsto g (nhds_within a (set.Iio a)) (nhds 0)) (hdiv : filter.tendsto (Î» (x : â„), deriv f x / deriv g x) (nhds_within a (set.Iio a)) l) : filter.tendsto (Î» (x : â„), f x / g x) (nhds_within a (set.Iio a)) l
theorem continuous.path_extend {X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] {x y : X} {Î³ : Y â†’ path x y} {f : Y â†’ â„} (hÎ³ : continuous â†¿Î³) (hf : continuous f) : continuous (Î» (t : Y), (Î³ t).extend (f t))
theorem one_le_mul {Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a b : Î±} (ha : 1 â‰¤ a) (hb : 1 â‰¤ b) : 1 â‰¤ a * b
theorem inner_product_space.is_self_adjoint.diagonalization_basis_apply_self_apply {ğ•œ : Type u_1} [is_R_or_C ğ•œ] [dec_ğ•œ : decidable_eq ğ•œ] {E : Type u_2} [inner_product_space ğ•œ E] {T : E â†’â‚—[ğ•œ] E} (hT : inner_product_space.is_self_adjoint T) [finite_dimensional ğ•œ E] {n : â„•} (hn : finite_dimensional.finrank ğ•œ E = n) (v : E) (i : fin n) : â‡‘(hT.diagonalization_basis hn) (â‡‘T v) i = â†‘(hT.eigenvalues hn i) * â‡‘(hT.diagonalization_basis hn) v i
theorem is_antichain.max_maximals {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} {s t : set Î±} (ht : is_antichain r t) (h : maximals r s âŠ† t) (hs : âˆ€ â¦ƒa : Î±â¦„, a âˆˆ t â†’ (âˆƒ (b : Î±) (H : b âˆˆ maximals r s), r b a)) : maximals r s = t
theorem phragmen_lindelof.eq_on_vertical_strip {E : Type u_1} [normed_group E] [normed_space â„‚ E] {a b : â„} {f g : â„‚ â†’ E} (hdf : diff_cont_on_cl â„‚ f (complex.re â»Â¹' set.Ioo a b)) (hBf : âˆƒ (c : â„) (H : c < real.pi / (b - a)) (B : â„), f =O[filter.comap (has_abs.abs âˆ˜ complex.im) filter.at_top âŠ“ filter.principal (complex.re â»Â¹' set.Ioo a b)] Î» (z : â„‚), real.exp (B * real.exp (c * |z.im|))) (hdg : diff_cont_on_cl â„‚ g (complex.re â»Â¹' set.Ioo a b)) (hBg : âˆƒ (c : â„) (H : c < real.pi / (b - a)) (B : â„), g =O[filter.comap (has_abs.abs âˆ˜ complex.im) filter.at_top âŠ“ filter.principal (complex.re â»Â¹' set.Ioo a b)] Î» (z : â„‚), real.exp (B * real.exp (c * |z.im|))) (ha : âˆ€ (z : â„‚), z.re = a â†’ f z = g z) (hb : âˆ€ (z : â„‚), z.re = b â†’ f z = g z) : set.eq_on f g (complex.re â»Â¹' set.Icc a b)
theorem is_closed.Hausdorff_dist_zero_iff_eq {Î± : Type u} [pseudo_metric_space Î±] {s t : set Î±} (hs : is_closed s) (ht : is_closed t) (fin : emetric.Hausdorff_edist s t â‰  âŠ¤) : metric.Hausdorff_dist s t = 0 â†” s = t
theorem fin.init_update_last {n : â„•} {Î± : fin (n + 1) â†’ Type u} (q : Î  (i : fin (n + 1)), Î± i) (z : Î± (fin.last n)) : fin.init (function.update q (fin.last n) z) = fin.init q
theorem topological_space.is_topological_basis.dense_iff {Î± : Type u} [t : topological_space Î±] {b : set (set Î±)} (hb : topological_space.is_topological_basis b) {s : set Î±} : dense s â†” âˆ€ (o : set Î±), o âˆˆ b â†’ o.nonempty â†’ (o âˆ© s).nonempty
theorem subgroup.ext {G : Type u_1} [group G] {H K : subgroup G} (h : âˆ€ (x : G), x âˆˆ H â†” x âˆˆ K) : H = K
theorem intermediate_field.fixing_subgroup.antimono {K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] {E1 E2 : intermediate_field K L} (h12 : E1 â‰¤ E2) : E2.fixing_subgroup â‰¤ E1.fixing_subgroup
theorem has_lt.lt.ne {Î± : Type u} [preorder Î±] {a b : Î±} (h : a < b) : a â‰  b
theorem right.mul_lt_one_of_le_of_lt {Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_mul.mul) has_le.le] {a b : Î±} (ha : a â‰¤ 1) (hb : b < 1) : a * b < 1
theorem euclidean_geometry.vsub_orthogonal_projection_mem_direction_orthogonal {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] (s : affine_subspace â„ P) [nonempty â†¥s] [complete_space â†¥(s.direction)] (p : P) : p -áµ¥ â†‘(â‡‘(euclidean_geometry.orthogonal_projection s) p) âˆˆ (s.direction)á—®
theorem orthonormal.oangle_add_cyc3_neg_right {V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) {x y z : V} (hx : x â‰  0) (hy : y â‰  0) (hz : z â‰  0) : hb.oangle x (-y) + hb.oangle y (-z) + hb.oangle z (-x) = â†‘real.pi
theorem false_of_nontrivial_of_product_domain (R : Type u_1) (S : Type u_2) [ring R] [ring S] [is_domain (R Ã— S)] [nontrivial R] [nontrivial S] : false
theorem category_theory.limits.epi_of_is_colimit_cofork {C : Type u} [category_theory.category C] {X Y : C} {f g : X âŸ¶ Y} {c : category_theory.limits.cofork f g} (i : category_theory.limits.is_colimit c) : category_theory.epi c.Ï€
theorem linear_map.to_matrix_id_eq_basis_to_matrix {Î¹ : Type u_1} {Î¹' : Type u_2} {R : Type u_5} {M : Type u_6} [comm_semiring R] [add_comm_monoid M] [module R M] (b : basis Î¹ R M) (b' : basis Î¹' R M) [fintype Î¹'] [fintype Î¹] [decidable_eq Î¹] : â‡‘(linear_map.to_matrix b b') linear_map.id = b'.to_matrix â‡‘b
theorem mem_nhds_within_Ici_iff_exists_Icc_subset' {Î± : Type u} [topological_space Î±] [linear_order Î±] [order_topology Î±] [no_max_order Î±] [densely_ordered Î±] {a : Î±} {s : set Î±} : s âˆˆ nhds_within a (set.Ici a) â†” âˆƒ (u : Î±) (H : u âˆˆ set.Ioi a), set.Icc a u âŠ† s
theorem is_open.analytic_set_image {Î± : Type u_1} [topological_space Î±] {Î² : Type u_2} [topological_space Î²] [polish_space Î²] {s : set Î²} (hs : is_open s) {f : Î² â†’ Î±} (f_cont : continuous f) : measure_theory.analytic_set (f '' s)
theorem units.smul_inv {G : Type u_1} {M : Type u_3} [group G] [monoid M] [mul_action G M] [smul_comm_class G M M] [is_scalar_tower G M M] (g : G) (m : MË£) : (g â€¢ m)â»Â¹ = gâ»Â¹ â€¢ mâ»Â¹
theorem measure_theory.pdf.integral_fun_mul_eq_integral {Î± : Type u_1} {E : Type u_2} [measurable_space E] {m : measurable_space Î±} {â„™ : measure_theory.measure Î±} {Î¼ : measure_theory.measure E} [measure_theory.is_finite_measure Â«â„™Â»] {X : Î± â†’ E} [measure_theory.has_pdf X Â«â„™Â» Î¼] {f : E â†’ â„} (hf : measurable f) : âˆ« (x : E), f x * (measure_theory.pdf X Â«â„™Â» Î¼ x).to_real âˆ‚Î¼ = âˆ« (x : Î±), f (X x) âˆ‚Â«â„™Â»
theorem has_deriv_at_integral_of_dominated_loc_of_lip {Î± : Type u_1} [measurable_space Î±] {Î¼ : measure_theory.measure Î±} {ğ•œ : Type u_2} [is_R_or_C ğ•œ] {E : Type u_3} [normed_group E] [normed_space â„ E] [normed_space ğ•œ E] [complete_space E] {F : ğ•œ â†’ Î± â†’ E} {F' : Î± â†’ E} {xâ‚€ : ğ•œ} {Îµ : â„} (Îµ_pos : 0 < Îµ) (hF_meas : âˆ€á¶  (x : ğ•œ) in nhds xâ‚€, measure_theory.ae_strongly_measurable (F x) Î¼) (hF_int : measure_theory.integrable (F xâ‚€) Î¼) (hF'_meas : measure_theory.ae_strongly_measurable F' Î¼) {bound : Î± â†’ â„} (h_lipsch : âˆ€áµ (a : Î±) âˆ‚Î¼, lipschitz_on_with (â‡‘real.nnabs (bound a)) (Î» (x : ğ•œ), F x a) (metric.ball xâ‚€ Îµ)) (bound_integrable : measure_theory.integrable bound Î¼) (h_diff : âˆ€áµ (a : Î±) âˆ‚Î¼, has_deriv_at (Î» (x : ğ•œ), F x a) (F' a) xâ‚€) : measure_theory.integrable F' Î¼ âˆ§ has_deriv_at (Î» (x : ğ•œ), âˆ« (a : Î±), F x a âˆ‚Î¼) (âˆ« (a : Î±), F' a âˆ‚Î¼) xâ‚€
theorem intermediate_field.map_id {K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (E : intermediate_field K L) : E.map (alg_hom.id K L) = E
theorem add_con.ker_lift_range_eq {M : Type u_1} {P : Type u_3} [add_zero_class M] [add_zero_class P] {f : M â†’+ P} : (add_con.ker_lift f).mrange = f.mrange
theorem cardinal.bdd_above_range {Î¹ : Type u} (f : Î¹ â†’ cardinal) : bdd_above (set.range f)
theorem orthonormal.oangle_eq_iff_eq_norm_div_norm_smul_rotation_of_ne_zero {V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) {x y : V} (hx : x â‰  0) (hy : y â‰  0) (Î¸ : real.angle) : hb.oangle x y = Î¸ â†” y = (âˆ¥yâˆ¥ / âˆ¥xâˆ¥) â€¢ â‡‘(hb.rotation Î¸) x
theorem orientation.oangle_self {V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) (x : V) : o.oangle x x = 0
theorem linear_equiv.nonempty_equiv_iff_lift_dim_eq {K : Type u} {V : Type v} {V' : Type v'} [division_ring K] [add_comm_group V] [module K V] [add_comm_group V'] [module K V'] : nonempty (V â‰ƒâ‚—[K] V') â†” (module.rank K V).lift = (module.rank K V').lift
theorem mem_nhds_iff_exists_Ioo_subset {Î± : Type u} [topological_space Î±] [linear_order Î±] [order_topology Î±] [no_max_order Î±] [no_min_order Î±] {a : Î±} {s : set Î±} : s âˆˆ nhds a â†” âˆƒ (l u : Î±), a âˆˆ set.Ioo l u âˆ§ set.Ioo l u âŠ† s
theorem quadratic_form.anisotropic_of_pi {Î¹ : Type u_1} {Máµ¢ : Î¹ â†’ Type u_7} [Î  (i : Î¹), add_comm_group (Máµ¢ i)] [fintype Î¹] {R : Type u_2} [ordered_ring R] [Î  (i : Î¹), module R (Máµ¢ i)] {Q : Î  (i : Î¹), quadratic_form R (Máµ¢ i)} (h : (quadratic_form.pi Q).anisotropic) (i : Î¹) : (Q i).anisotropic
theorem add_semiconj_by.eq {S : Type u} [has_add S] {a x y : S} (h : add_semiconj_by a x y) : a + x = y + a
theorem category_theory.limits.cokernel.Ï€_of_epi {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} (f : X âŸ¶ Y) [category_theory.limits.has_zero_object C] [category_theory.limits.has_cokernel f] [category_theory.epi f] : category_theory.limits.cokernel.Ï€ f = 0
theorem orthonormal.oangle_sub_left {V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) {x y z : V} (hx : x â‰  0) (hy : y â‰  0) (hz : z â‰  0) : hb.oangle x z - hb.oangle x y = hb.oangle y z
theorem orthogonal_family.summable_iff_norm_sq_summable {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {Î¹ : Type u_4} {G : Î¹ â†’ Type u_5} [Î  (i : Î¹), inner_product_space ğ•œ (G i)] {V : Î  (i : Î¹), G i â†’â‚—áµ¢[ğ•œ] E} (hV : orthogonal_family ğ•œ V) [complete_space E] (f : Î  (i : Î¹), G i) : summable (Î» (i : Î¹), â‡‘(V i) (f i)) â†” summable (Î» (i : Î¹), âˆ¥f iâˆ¥ ^ 2)
theorem real.real_sqrt_le_nat_sqrt_succ {a : â„•} : real.sqrt â†‘a â‰¤ â†‘(nat.sqrt a) + 1
theorem affine_subspace.direction_lt_of_nonempty {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {s1 s2 : affine_subspace k P} (h : s1 < s2) (hn : â†‘s1.nonempty) : s1.direction < s2.direction
theorem torus_integrable.function_integrable {n : â„•} {E : Type u_1} [normed_group E] {f : (fin n â†’ â„‚) â†’ E} {c : fin n â†’ â„‚} {R : fin n â†’ â„} [normed_space â„‚ E] (hf : torus_integrable f c R) : measure_theory.integrable_on (Î» (Î¸ : fin n â†’ â„), finset.univ.prod (Î» (i : fin n), â†‘(R i) * complex.exp (â†‘(Î¸ i) * complex.I) * complex.I) â€¢ f (torus_map c R Î¸)) (set.Icc 0 (Î» (_x : fin n), 2 * real.pi)) measure_theory.measure_space.volume
theorem submodule.exists_le_ker_of_lt_top {K : Type u_4} {V : Type u} [field K] [add_comm_group V] [module K V] (p : submodule K V) (hp : p < âŠ¤) : âˆƒ (f : V â†’â‚—[K] K) (H : f â‰  0), p â‰¤ f.ker
theorem cont_diff_within_at.comp_continuous_linear_map {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {G : Type u_4} [normed_group G] [normed_space ğ•œ G] {s : set E} {f : E â†’ F} {n : with_top â„•} {x : G} (g : G â†’L[ğ•œ] E) (hf : cont_diff_within_at ğ•œ n f s (â‡‘g x)) : cont_diff_within_at ğ•œ n (f âˆ˜ â‡‘g) (â‡‘g â»Â¹' s) x
theorem polynomial.induction_with_nat_degree_le {R : Type u_1} [semiring R] (P : polynomial R â†’ Prop) (N : â„•) (P_0 : P 0) (P_C_mul_pow : âˆ€ (n : â„•) (r : R), r â‰  0 â†’ n â‰¤ N â†’ P (â‡‘polynomial.C r * polynomial.X ^ n)) (P_C_add : âˆ€ (f g : polynomial R), f.nat_degree < g.nat_degree â†’ g.nat_degree â‰¤ N â†’ P f â†’ P g â†’ P (f + g)) (f : polynomial R) : f.nat_degree â‰¤ N â†’ P f
theorem setoid.inf_def {Î± : Type u_1} {r s : setoid Î±} : (r âŠ“ s).rel = r.rel âŠ“ s.rel
theorem is_connected.Union_of_chain {Î± : Type u} {Î² : Type v} [topological_space Î±] [linear_order Î²] [succ_order Î²] [is_succ_archimedean Î²] [nonempty Î²] {s : Î² â†’ set Î±} (H : âˆ€ (n : Î²), is_connected (s n)) (K : âˆ€ (n : Î²), (s n âˆ© s (order.succ n)).nonempty) : is_connected (â‹ƒ (n : Î²), s n)
theorem has_fpower_series_on_ball.change_origin {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field ğ•œ] [normed_group E] [normed_space ğ•œ E] [normed_group F] [normed_space ğ•œ F] [complete_space F] {f : E â†’ F} {p : formal_multilinear_series ğ•œ E F} {x y : E} {r : ennreal} (hf : has_fpower_series_on_ball f p x r) (h : â†‘âˆ¥yâˆ¥â‚Š < r) : has_fpower_series_on_ball f (p.change_origin y) (x + y) (r - â†‘âˆ¥yâˆ¥â‚Š)
theorem ultrafilter_converges_iff {Î± : Type u} {u : ultrafilter (ultrafilter Î±)} {x : ultrafilter Î±} : â†‘u â‰¤ nhds x â†” x = mjoin u
theorem is_open_map_quotient_mk_mul {Î“ : Type u_4} [group Î“] {T : Type u_5} [topological_space T] [mul_action Î“ T] [has_continuous_const_smul Î“ T] : is_open_map quotient.mk
theorem fin.init_update_cast_succ {n : â„•} {Î± : fin (n + 1) â†’ Type u} (q : Î  (i : fin (n + 1)), Î± i) (i : fin n) (y : Î± (â‡‘fin.cast_succ i)) : fin.init (function.update q (â‡‘fin.cast_succ i) y) = function.update (fin.init q) i y
theorem same_ray.exists_pos {R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {x y : M} (h : same_ray R x y) (hx : x â‰  0) (hy : y â‰  0) : âˆƒ (râ‚ râ‚‚ : R), 0 < râ‚ âˆ§ 0 < râ‚‚ âˆ§ râ‚ â€¢ x = râ‚‚ â€¢ y
theorem measure_theory.analytic_set.measurably_separable {Î± : Type u_1} [topological_space Î±] [t2_space Î±] [measurable_space Î±] [borel_space Î±] {s t : set Î±} (hs : measure_theory.analytic_set s) (ht : measure_theory.analytic_set t) (h : disjoint s t) : measure_theory.measurably_separable s t
theorem witt_vector.map_verschiebung {p : â„•} {R : Type u_1} {S : Type u_2} [hp : fact (nat.prime p)] [comm_ring R] [comm_ring S] (f : R â†’+* S) (x : witt_vector p R) : â‡‘(witt_vector.map f) (â‡‘witt_vector.verschiebung x) = â‡‘witt_vector.verschiebung (â‡‘(witt_vector.map f) x)
theorem pythagorean_triple.mul_iff {x y z : â„¤} (k : â„¤) (hk : k â‰  0) : pythagorean_triple (k * x) (k * y) (k * z) â†” pythagorean_triple x y z
theorem emetric.inf_edist_image {Î± : Type u} {Î² : Type v} [pseudo_emetric_space Î±] [pseudo_emetric_space Î²] {x : Î±} {t : set Î±} {Î¦ : Î± â†’ Î²} (hÎ¦ : isometry Î¦) : emetric.inf_edist (Î¦ x) (Î¦ '' t) = emetric.inf_edist x t
theorem set.finset_prod_mem_finset_prod {Î± : Type u_2} {Î¹ : Type u_5} [comm_monoid Î±] (t : finset Î¹) (f : Î¹ â†’ set Î±) (g : Î¹ â†’ Î±) (hg : âˆ€ (i : Î¹), i âˆˆ t â†’ g i âˆˆ f i) : t.prod (Î» (i : Î¹), g i) âˆˆ t.prod (Î» (i : Î¹), f i)
theorem monotone.min {Î± : Type u} {Î² : Type v} [preorder Î±] [linear_order Î²] {f g : Î± â†’ Î²} (hf : monotone f) (hg : monotone g) : monotone (Î» (x : Î±), linear_order.min (f x) (g x))
theorem submodule.finrank_add_inf_finrank_orthogonal' {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {Kâ‚ Kâ‚‚ : submodule ğ•œ E} [finite_dimensional ğ•œ â†¥Kâ‚‚] (h : Kâ‚ â‰¤ Kâ‚‚) {n : â„•} (h_dim : finite_dimensional.finrank ğ•œ â†¥Kâ‚ + n = finite_dimensional.finrank ğ•œ â†¥Kâ‚‚) : finite_dimensional.finrank ğ•œ â†¥(Kâ‚á—® âŠ“ Kâ‚‚) = n
theorem module.projective_of_lifting_property {R : Type u} [ring R] {P : Type (max u v)} [add_comm_group P] [module R P] (huniv : âˆ€ {M : Type (max v u)} {N : Type (max u v)} [_inst_4 : add_comm_group M] [_inst_5 : add_comm_group N] [_inst_6 : module R M] [_inst_7 : module R N] (f : M â†’â‚—[R] N) (g : P â†’â‚—[R] N), function.surjective â‡‘f â†’ (âˆƒ (h : P â†’â‚—[R] M), f.comp h = g)) : module.projective R P
theorem bounded_continuous_function.norm_const_le {Î± : Type u} {Î² : Type v} [topological_space Î±] [semi_normed_group Î²] (b : Î²) : âˆ¥bounded_continuous_function.const Î± bâˆ¥ â‰¤ âˆ¥bâˆ¥
theorem fin.coe_val_of_lt {n a : â„•} (h : a < n + 1) : â†‘a.val = a
theorem concave_on.le_map_sum {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} {Î¹ : Type u_5} [linear_ordered_field ğ•œ] [add_comm_group E] [ordered_add_comm_group Î²] [module ğ•œ E] [module ğ•œ Î²] [ordered_smul ğ•œ Î²] {s : set E} {f : E â†’ Î²} {t : finset Î¹} {w : Î¹ â†’ ğ•œ} {p : Î¹ â†’ E} (hf : concave_on ğ•œ s f) (hâ‚€ : âˆ€ (i : Î¹), i âˆˆ t â†’ 0 â‰¤ w i) (hâ‚ : t.sum (Î» (i : Î¹), w i) = 1) (hmem : âˆ€ (i : Î¹), i âˆˆ t â†’ p i âˆˆ s) : t.sum (Î» (i : Î¹), w i â€¢ f (p i)) â‰¤ f (t.sum (Î» (i : Î¹), w i â€¢ p i))
theorem emetric.Hausdorff_edist_le_ediam {Î± : Type u} [pseudo_emetric_space Î±] {s t : set Î±} (hs : s.nonempty) (ht : t.nonempty) : emetric.Hausdorff_edist s t â‰¤ emetric.diam (s âˆª t)
theorem normed_group_hom.norm_id_of_nontrivial_seminorm (V : Type u_1) [semi_normed_group V] (h : âˆƒ (x : V), âˆ¥xâˆ¥ â‰  0) : âˆ¥normed_group_hom.id Vâˆ¥ = 1
theorem emetric.inf_edist_le_Hausdorff_edist_of_mem {Î± : Type u} [pseudo_emetric_space Î±] {x : Î±} {s t : set Î±} (h : x âˆˆ s) : emetric.inf_edist x t â‰¤ emetric.Hausdorff_edist s t
theorem category_theory.limits.has_limit_of_has_colimit_left_op {C : Type uâ‚} [category_theory.category C] {J : Type uâ‚‚} [category_theory.category J] (F : J â¥¤ Cáµ’áµ–) [category_theory.limits.has_colimit F.left_op] : category_theory.limits.has_limit F
theorem nat.lt_base_pow_length_digits {b m : â„•} (hb : 2 â‰¤ b) : m < b ^ (b.digits m).length
theorem cardinal.ord_aleph_eq_enum_card  : cardinal.ord âˆ˜ cardinal.aleph = ordinal.enum_ord {b : ordinal | b.card.ord = b âˆ§ ordinal.omega â‰¤ b}
theorem polynomial.eval_mul_X_sub_C {R : Type u} [ring R] {p : polynomial R} (r : R) : polynomial.eval r (p * (polynomial.X - â‡‘polynomial.C r)) = 0
theorem category_theory.limits.complete_lattice.finite_coproduct_eq_finset_sup {Î± : Type u} [semilattice_sup Î±] [order_bot Î±] {Î¹ : Type u} [fintype Î¹] (f : Î¹ â†’ Î±) : (âˆ f) = (fintype.elems Î¹).sup f
theorem add_subsemigroup.closure_induction' {M : Type u_1} [has_add M] (s : set M) {p : Î  (x : M), x âˆˆ add_subsemigroup.closure s â†’ Prop} (Hs : âˆ€ (x : M) (h : x âˆˆ s), p x _) (Hmul : âˆ€ (x : M) (hx : x âˆˆ add_subsemigroup.closure s) (y : M) (hy : y âˆˆ add_subsemigroup.closure s), p x hx â†’ p y hy â†’ p (x + y) _) {x : M} (hx : x âˆˆ add_subsemigroup.closure s) : p x hx
theorem orientation.some_basis_orientation {R : Type u_1} [linear_ordered_field R] {M : Type u_2} [add_comm_group M] [module R M] {Î¹ : Type u_3} [decidable_eq Î¹] [fintype Î¹] [finite_dimensional R M] [nonempty Î¹] (x : orientation R M Î¹) (h : fintype.card Î¹ = finite_dimensional.finrank R M) : (x.some_basis h).orientation = x
theorem cont_mdiff_within_at.cont_diff_within_at {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {n : with_top â„•} {f : E â†’ E'} {s : set E} {x : E} : cont_mdiff_within_at (model_with_corners_self ğ•œ E) (model_with_corners_self ğ•œ E') n f s x â†’ cont_diff_within_at ğ•œ n f s x
theorem pequiv.injective_of_forall_is_some {Î± : Type u} {Î² : Type v} {f : Î± â‰ƒ. Î²} (h : âˆ€ (a : Î±), â†¥((â‡‘f a).is_some)) : function.injective â‡‘f
theorem real.sinh_eq (x : â„) : real.sinh x = (real.exp x - real.exp (-x)) / 2
theorem subsemiring.prod_mem {R : Type u_1} [comm_semiring R] (s : subsemiring R) {Î¹ : Type u_2} {t : finset Î¹} {f : Î¹ â†’ R} (h : âˆ€ (c : Î¹), c âˆˆ t â†’ f c âˆˆ s) : t.prod (Î» (i : Î¹), f i) âˆˆ s
theorem convex.affine_preimage {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [ordered_ring ğ•œ] [add_comm_group E] [add_comm_group F] [module ğ•œ E] [module ğ•œ F] (f : E â†’áµƒ[ğ•œ] F) {s : set F} (hs : convex ğ•œ s) : convex ğ•œ (â‡‘f â»Â¹' s)
theorem finsupp.on_finset_prod {Î± : Type u_1} {M : Type u_5} {N : Type u_7} [has_zero M] [comm_monoid N] {s : finset Î±} {f : Î± â†’ M} {g : Î± â†’ M â†’ N} (hf : âˆ€ (a : Î±), f a â‰  0 â†’ a âˆˆ s) (hg : âˆ€ (a : Î±), g a 0 = 1) : (finsupp.on_finset s f hf).prod g = s.prod (Î» (a : Î±), g a (f a))
theorem category_theory.limits.has_finite_biproducts.of_has_finite_coproducts {C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_finite_coproducts C] : category_theory.limits.has_finite_biproducts C
theorem function.update_comp_eq_of_forall_ne {Î±' : Sort w} [decidable_eq Î±'] {Î± : Sort u_1} {Î² : Sort u_2} (g : Î±' â†’ Î²) {f : Î± â†’ Î±'} {i : Î±'} (a : Î²) (h : âˆ€ (x : Î±), f x â‰  i) : function.update g i a âˆ˜ f = g âˆ˜ f
theorem cont_diff_at_fst {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {n : with_top â„•} {p : E Ã— F} : cont_diff_at ğ•œ n prod.fst p
theorem multilinear_map.map_sum {R : Type u} {Î¹ : Type u'} {Mâ‚ : Î¹ â†’ Type vâ‚} {Mâ‚‚ : Type vâ‚‚} [decidable_eq Î¹] [semiring R] [Î  (i : Î¹), add_comm_monoid (Mâ‚ i)] [add_comm_monoid Mâ‚‚] [Î  (i : Î¹), module R (Mâ‚ i)] [module R Mâ‚‚] (f : multilinear_map R Mâ‚ Mâ‚‚) {Î± : Î¹ â†’ Type u_1} (g : Î  (i : Î¹), Î± i â†’ Mâ‚ i) [fintype Î¹] [Î  (i : Î¹), fintype (Î± i)] : â‡‘f (Î» (i : Î¹), finset.univ.sum (Î» (j : Î± i), g i j)) = finset.univ.sum (Î» (r : Î  (i : Î¹), Î± i), â‡‘f (Î» (i : Î¹), g i (r i)))
theorem quotient.indâ‚‚' {Î± : Sort u_1} {Î² : Sort u_2} {sâ‚ : setoid Î±} {sâ‚‚ : setoid Î²} {p : quotient sâ‚ â†’ quotient sâ‚‚ â†’ Prop} (h : âˆ€ (aâ‚ : Î±) (aâ‚‚ : Î²), p (quotient.mk' aâ‚) (quotient.mk' aâ‚‚)) (qâ‚ : quotient sâ‚) (qâ‚‚ : quotient sâ‚‚) : p qâ‚ qâ‚‚
theorem nnreal.tendsto_tsum_compl_at_top_zero {Î± : Type u_1} (f : Î± â†’ nnreal) : filter.tendsto (Î» (s : finset Î±), âˆ‘' (b : {x // x âˆ‰ s}), f â†‘b) filter.at_top (nhds 0)
theorem continuous_within_at.insert_self {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] {f : Î± â†’ Î²} {x : Î±} {s : set Î±} : continuous_within_at f s x â†’ continuous_within_at f (has_insert.insert x s) x
theorem linear_equiv_det_rotation (a : â†¥circle) : â‡‘linear_equiv.det (â‡‘rotation a).to_linear_equiv = 1
theorem convex_cone.flat.pointed {ğ•œ : Type u_1} {E : Type u_2} [ordered_semiring ğ•œ] [add_comm_group E] [has_scalar ğ•œ E] {S : convex_cone ğ•œ E} (hS : S.flat) : S.pointed
theorem continuous.locally_integrable {X : Type u_1} {E : Type u_3} [measurable_space X] [topological_space X] [normed_group E] {f : X â†’ E} {Î¼ : measure_theory.measure X} [opens_measurable_space X] [topological_space.metrizable_space X] [measure_theory.is_locally_finite_measure Î¼] (hf : continuous f) : measure_theory.locally_integrable f Î¼
theorem algebra.is_algebraic_of_larger_base (K : Type u_1) (L : Type u_2) {A : Type u_5} [field K] [field L] [comm_ring A] [algebra K L] [algebra L A] [algebra K A] [is_scalar_tower K L A] (A_alg : algebra.is_algebraic K A) : algebra.is_algebraic L A
theorem is_closed.polish_space {Î± : Type u_1} [topological_space Î±] [polish_space Î±] {s : set Î±} (hs : is_closed s) : polish_space â†¥s
theorem category_theory.abelian.pseudoelement.epi_of_pseudo_surjective {C : Type u} [category_theory.category C] [category_theory.abelian C] {P Q : C} (f : P âŸ¶ Q) : function.surjective â‡‘f â†’ category_theory.epi f
theorem zmod.int_cast_zmod_cast {n : â„•} (a : zmod n) : â†‘â†‘a = a
theorem pi_nat.lipschitz_with_one_iff_forall_dist_image_le_of_mem_cylinder {E : â„• â†’ Type u_1} {Î± : Type u_2} [pseudo_metric_space Î±] {f : (Î  (n : â„•), E n) â†’ Î±} : (âˆ€ (x y : Î  (n : â„•), E n), has_dist.dist (f x) (f y) â‰¤ has_dist.dist x y) â†” âˆ€ (x y : Î  (n : â„•), E n) (n : â„•), y âˆˆ pi_nat.cylinder x n â†’ has_dist.dist (f x) (f y) â‰¤ (1 / 2) ^ n
theorem tsum_of_nnnorm_bounded {Î¹ : Type u_1} {E : Type u_3} [semi_normed_group E] {f : Î¹ â†’ E} {g : Î¹ â†’ nnreal} {a : nnreal} (hg : has_sum g a) (h : âˆ€ (i : Î¹), âˆ¥f iâˆ¥â‚Š â‰¤ g i) : âˆ¥âˆ‘' (i : Î¹), f iâˆ¥â‚Š â‰¤ a
theorem norm_add_sq_eq_norm_sq_add_norm_sq_of_inner_eq_zero {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] (x y : E) (h : has_inner.inner x y = 0) : âˆ¥x + yâˆ¥ * âˆ¥x + yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + âˆ¥yâˆ¥ * âˆ¥yâˆ¥
theorem measure_theory.lintegral_liminf_le {Î± : Type u_1} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {f : â„• â†’ Î± â†’ ennreal} (h_meas : âˆ€ (n : â„•), measurable (f n)) : âˆ«â» (a : Î±), filter.at_top.liminf (Î» (n : â„•), f n a) âˆ‚Î¼ â‰¤ filter.at_top.liminf (Î» (n : â„•), âˆ«â» (a : Î±), f n a âˆ‚Î¼)
theorem mul_sub_mul_div_mul_neg {Î± : Type u_1} [linear_ordered_field Î±] {a b c d : Î±} (hc : c â‰  0) (hd : d â‰  0) : a / c < b / d â†’ (a * d - b * c) / (c * d) < 0
theorem exists_extension_of_le_sublinear {E : Type u_2} [add_comm_group E] [module â„ E] (f : linear_pmap â„ E â„) (N : E â†’ â„) (N_hom : âˆ€ (c : â„), 0 < c â†’ âˆ€ (x : E), N (c â€¢ x) = c * N x) (N_add : âˆ€ (x y : E), N (x + y) â‰¤ N x + N y) (hf : âˆ€ (x : â†¥(f.domain)), â‡‘f x â‰¤ N â†‘x) : âˆƒ (g : E â†’â‚—[â„] â„), (âˆ€ (x : â†¥(f.domain)), â‡‘g â†‘x = â‡‘f x) âˆ§ âˆ€ (x : E), â‡‘g x â‰¤ N x
theorem has_fpower_series_on_ball.tendsto_locally_uniformly_on' {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field ğ•œ] [normed_group E] [normed_space ğ•œ E] [normed_group F] [normed_space ğ•œ F] {f : E â†’ F} {p : formal_multilinear_series ğ•œ E F} {x : E} {r : ennreal} (hf : has_fpower_series_on_ball f p x r) : tendsto_locally_uniformly_on (Î» (n : â„•) (y : E), p.partial_sum n (y - x)) f filter.at_top (emetric.ball x r)
theorem continuous_linear_map.op_norm_extend_le {ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {E : Type u_4} {F : Type u_6} {Fâ‚— : Type u_7} [normed_group E] [normed_group F] [normed_group Fâ‚—] [nondiscrete_normed_field ğ•œ] [nondiscrete_normed_field ğ•œâ‚‚] [normed_space ğ•œ E] [normed_space ğ•œâ‚‚ F] [normed_space ğ•œ Fâ‚—] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} (f : E â†’SL[Ïƒâ‚â‚‚] F) [complete_space F] (e : E â†’L[ğ•œ] Fâ‚—) (h_dense : dense_range â‡‘e) {N : nnreal} (h_e : âˆ€ (x : E), âˆ¥xâˆ¥ â‰¤ â†‘N * âˆ¥â‡‘e xâˆ¥) [ring_hom_isometric Ïƒâ‚â‚‚] : âˆ¥f.extend e h_dense _âˆ¥ â‰¤ â†‘N * âˆ¥fâˆ¥
theorem interval_integral.differentiable_on_integral_of_continuous {E : Type u_3} [normed_group E] [complete_space E] [normed_space â„ E] {f : â„ â†’ E} {a : â„} {s : set â„} (hintg : âˆ€ (x : â„), x âˆˆ s â†’ interval_integrable f measure_theory.measure_space.volume a x) (hcont : continuous f) : differentiable_on â„ (Î» (u : â„), âˆ« (x : â„) in a..u, f x) s
theorem is_regular.ne_zero {R : Type u_1} {a : R} [mul_zero_class R] [nontrivial R] (la : is_regular a) : a â‰  0
theorem is_dedekind_domain.height_one_spectrum.valuation_of_algebra_map {R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] {K : Type u_2} [field K] [algebra R K] [is_fraction_ring R K] (v : is_dedekind_domain.height_one_spectrum R) (r : R) : â‡‘(v.valuation) (â‡‘(algebra_map R K) r) = â‡‘(v.int_valuation) r
theorem bounded_continuous_function.norm_le {Î± : Type u} {Î² : Type v} [topological_space Î±] [semi_normed_group Î²] {f : bounded_continuous_function Î± Î²} {C : â„} (C0 : 0 â‰¤ C) : âˆ¥fâˆ¥ â‰¤ C â†” âˆ€ (x : Î±), âˆ¥â‡‘f xâˆ¥ â‰¤ C
theorem monoid.mem_closure_union_iff {M : Type u_1} [comm_monoid M] {s t : set M} {x : M} : x âˆˆ monoid.closure (s âˆª t) â†” âˆƒ (y : M) (H : y âˆˆ monoid.closure s) (z : M) (H : z âˆˆ monoid.closure t), y * z = x
theorem cau_seq_iff_cauchy_seq {Î± : Type u} [normed_field Î±] {u : â„• â†’ Î±} : is_cau_seq has_norm.norm u â†” cauchy_seq u
theorem category_theory.pi.has_colimit_of_has_colimit_comp_eval {I : Type vâ‚} {C : I â†’ Type uâ‚} [Î  (i : I), category_theory.category (C i)] {J : Type vâ‚} [category_theory.small_category J] {F : J â¥¤ Î  (i : I), C i} [âˆ€ (i : I), category_theory.limits.has_colimit (F â‹™ category_theory.pi.eval C i)] : category_theory.limits.has_colimit F
theorem matrix.mv_polynomial_X_map_matrix_eval {m : Type u_1} {R : Type u_3} [fintype m] [decidable_eq m] [comm_semiring R] (A : matrix m m R) : â‡‘((mv_polynomial.eval (Î» (p : m Ã— m), A p.fst p.snd)).map_matrix) (matrix.mv_polynomial_X m m R) = A
theorem uniq_inv_of_is_field (R : Type u) [ring R] (hf : is_field R) (x : R) : x â‰  0 â†’ (âˆƒ! (y : R), x * y = 1)
theorem category_theory.limits.is_limit.exists_unique {J : Type uâ‚} [category_theory.category J] {C : Type uâ‚ƒ} [category_theory.category C] {F : J â¥¤ C} {t : category_theory.limits.cone F} (h : category_theory.limits.is_limit t) (s : category_theory.limits.cone F) : âˆƒ! (l : s.X âŸ¶ t.X), âˆ€ (j : J), l â‰« t.Ï€.app j = s.Ï€.app j
theorem submodule.Inf_orthogonal {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] (s : set (submodule ğ•œ E)) : (â¨… (K : submodule ğ•œ E) (H : K âˆˆ s), Ká—®) = (has_Sup.Sup s)á—®
theorem topological_add_group.continuous_conj' {G : Type w} [topological_space G] [has_neg G] [has_add G] [has_continuous_add G] [has_continuous_neg G] (h : G) : continuous (Î» (g : G), g + h + -g)
theorem ring_hom_inv_pair.of_ring_equiv {Râ‚ : Type u_1} {Râ‚‚ : Type u_2} [semiring Râ‚] [semiring Râ‚‚] (e : Râ‚ â‰ƒ+* Râ‚‚) : ring_hom_inv_pair â†‘e â†‘(e.symm)
theorem measurable_const' {Î± : Type u_1} {Î² : Type u_2} [measurable_space Î±] [measurable_space Î²] {f : Î² â†’ Î±} (hf : âˆ€ (x y : Î²), f x = f y) : measurable f
theorem orthonormal.exists_linear_isometry_equiv_map_eq_of_orientation_eq {V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) {bâ‚‚ : basis (fin 2) â„ V} (hbâ‚‚ : orthonormal â„ â‡‘bâ‚‚) (ho : b.orientation = bâ‚‚.orientation) : âˆƒ (Î¸ : real.angle), bâ‚‚ = b.map (hb.rotation Î¸).to_linear_equiv
theorem units.exists0 {Gâ‚€ : Type u_2} [group_with_zero Gâ‚€] {p : Gâ‚€Ë£ â†’ Prop} : (âˆƒ (g : Gâ‚€Ë£), p g) â†” âˆƒ (g : Gâ‚€) (hg : g â‰  0), p (units.mk0 g hg)
theorem contracting_with.exists_fixed_point {Î± : Type u_1} [emetric_space Î±] [cs : complete_space Î±] {K : nnreal} {f : Î± â†’ Î±} (hf : contracting_with K f) (x : Î±) (hx : has_edist.edist x (f x) â‰  âŠ¤) : âˆƒ (y : Î±), function.is_fixed_pt f y âˆ§ filter.tendsto (Î» (n : â„•), f^[n] x) filter.at_top (nhds y) âˆ§ âˆ€ (n : â„•), has_edist.edist (f^[n] x) y â‰¤ has_edist.edist x (f x) * â†‘K ^ n / (1 - â†‘K)
theorem emetric.mk_uniformity_basis_le {Î± : Type u} [pseudo_emetric_space Î±] {Î² : Type u_1} {p : Î² â†’ Prop} {f : Î² â†’ ennreal} (hfâ‚€ : âˆ€ (x : Î²), p x â†’ 0 < f x) (hf : âˆ€ (Îµ : ennreal), 0 < Îµ â†’ (âˆƒ (x : Î²) (hx : p x), f x â‰¤ Îµ)) : (uniformity Î±).has_basis p (Î» (x : Î²), {p : Î± Ã— Î± | has_edist.edist p.fst p.snd â‰¤ f x})
theorem is_open_map_fst {Î± : Type u} {Î² : Type v} [topological_space Î±] [topological_space Î²] : is_open_map prod.fst
theorem finset.eq_weighted_vsub_of_point_subset_iff_eq_weighted_vsub_of_point_subtype {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {Î¹ : Type u_4} {v : V} {x : k} {s : set Î¹} {p : Î¹ â†’ P} {b : P} : (âˆƒ (fs : finset Î¹) (hfs : â†‘fs âŠ† s) (w : Î¹ â†’ k) (hw : fs.sum (Î» (i : Î¹), w i) = x), v = â‡‘(fs.weighted_vsub_of_point p b) w) â†” âˆƒ (fs : finset â†¥s) (w : â†¥s â†’ k) (hw : fs.sum (Î» (i : â†¥s), w i) = x), v = â‡‘(fs.weighted_vsub_of_point (Î» (i : â†¥s), p â†‘i) b) w
theorem is_seq_closed.is_closed {X : Type u_1} [topological_space X] [sequential_space X] {s : set X} : is_seq_closed s â†’ is_closed s
theorem is_path_connected.preimage_coe {X : Type u_1} [topological_space X] {U W : set X} (hW : is_path_connected W) (hWU : W âŠ† U) : is_path_connected (coe â»Â¹' W)
theorem is_algebraic_of_larger_base (K : Type u_1) (L : Type u_2) {A : Type u_5} [field K] [field L] [comm_ring A] [algebra K L] [algebra L A] [algebra K A] [is_scalar_tower K L A] {x : A} (A_alg : is_algebraic K x) : is_algebraic L x
theorem power_series.order_eq_top {R : Type u_1} [semiring R] {Ï† : power_series R} : Ï†.order = âŠ¤ â†” Ï† = 0
theorem finset.sum_centroid_weights_eq_one_of_card_eq_add_one (k : Type u_1) [division_ring k] {Î¹ : Type u_4} (s : finset Î¹) [char_zero k] {n : â„•} (h : s.card = n + 1) : s.sum (Î» (i : Î¹), finset.centroid_weights k s i) = 1
theorem set.sum_indicator_subset_of_eq_zero {Î± : Type u_1} {M : Type u_4} {N : Type u_5} [add_comm_monoid M] [has_zero N] (f : Î± â†’ N) (g : Î± â†’ N â†’ M) {s t : finset Î±} (h : s âŠ† t) (hg : âˆ€ (a : Î±), g a 0 = 0) : s.sum (Î» (i : Î±), g i (f i)) = t.sum (Î» (i : Î±), g i (â†‘s.indicator f i))
theorem filter.tendsto.integrable_at_filter {Î± : Type u_1} {E : Type u_3} [measurable_space Î±] [normed_group E] {f : Î± â†’ E} {Î¼ : measure_theory.measure Î±} {l : filter Î±} [l.is_measurably_generated] (hfm : strongly_measurable_at_filter f l Î¼) (hÎ¼ : Î¼.finite_at_filter l) {b : E} (hf : filter.tendsto f l (nhds b)) : measure_theory.integrable_at_filter f l Î¼
theorem filter.tendsto_abs_at_bot_at_top {Î± : Type u_3} [linear_ordered_add_comm_group Î±] : filter.tendsto has_abs.abs filter.at_bot filter.at_top
theorem filter.mapâ‚‚_map_left_comm {Î± : Type u_1} {Î±' : Type u_2} {Î² : Type u_3} {Î³ : Type u_5} {Î´ : Type u_7} {f : filter Î±} {g : filter Î²} {m : Î±' â†’ Î² â†’ Î³} {n : Î± â†’ Î±'} {m' : Î± â†’ Î² â†’ Î´} {n' : Î´ â†’ Î³} (h_left_comm : âˆ€ (a : Î±) (b : Î²), m (n a) b = n' (m' a b)) : filter.mapâ‚‚ m (filter.map n f) g = filter.map n' (filter.mapâ‚‚ m' f g)
theorem measure_theory.measure.add_haar_submodule {E : Type u_1} [normed_group E] [normed_space â„ E] [measurable_space E] [borel_space E] [finite_dimensional â„ E] (Î¼ : measure_theory.measure E) [Î¼.is_add_haar_measure] (s : submodule â„ E) (hs : s â‰  âŠ¤) : â‡‘Î¼ â†‘s = 0
theorem matrix.to_lin'_mul_apply {R : Type u_1} [comm_semiring R] {l : Type u_2} {m : Type u_3} {n : Type u_4} [fintype n] [decidable_eq n] [fintype m] [decidable_eq m] (M : matrix l m R) (N : matrix m n R) (x : n â†’ R) : â‡‘(â‡‘matrix.to_lin' (M.mul N)) x = â‡‘(â‡‘matrix.to_lin' M) (â‡‘(â‡‘matrix.to_lin' N) x)
theorem polynomial.cyclotomic_eq_X_pow_sub_one_div {R : Type u_1} [comm_ring R] {n : â„•} (hpos : 0 < n) : polynomial.cyclotomic n R = (polynomial.X ^ n - 1) /â‚˜ n.proper_divisors.prod (Î» (i : â„•), polynomial.cyclotomic i R)
theorem dimH_range_le_of_locally_holder_on {X : Type u_2} {Y : Type u_3} [emetric_space X] [emetric_space Y] [topological_space.second_countable_topology X] {r : nnreal} {f : X â†’ Y} (hr : 0 < r) (hf : âˆ€ (x : X), âˆƒ (C : nnreal) (s : set X) (H : s âˆˆ nhds x), holder_on_with C r f s) : dimH (set.range f) â‰¤ dimH set.univ / â†‘r
theorem measure_theory.measure_mono_ae {Î± : Type u_1} [measurable_space Î±] {Î¼ : measure_theory.measure Î±} {s t : set Î±} (H : s â‰¤áµ[Î¼] t) : â‡‘Î¼ s â‰¤ â‡‘Î¼ t
theorem finset.eq_one_of_prod_eq_one {Î² : Type u} {Î± : Type v} [comm_monoid Î²] {s : finset Î±} {f : Î± â†’ Î²} {a : Î±} (hp : s.prod (Î» (x : Î±), f x) = 1) (h1 : âˆ€ (x : Î±), x âˆˆ s â†’ x â‰  a â†’ f x = 1) (x : Î±) (H : x âˆˆ s) : f x = 1
theorem category_theory.preadditive.has_equalizers_of_has_kernels {C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_kernels C] : category_theory.limits.has_equalizers C
theorem antitone_on.dual_right {Î± : Type u} {Î² : Type v} [preorder Î±] [preorder Î²] {f : Î± â†’ Î²} {s : set Î±} : antitone_on f s â†’ monotone_on (â‡‘order_dual.to_dual âˆ˜ f) s
theorem box_integral.norm_volume_sub_integral_face_upper_sub_lower_smul_le {E : Type u} [normed_group E] [normed_space â„ E] {n : â„•} [complete_space E] (I : box_integral.box (fin (n + 1))) {i : fin (n + 1)} {f : (fin (n + 1) â†’ â„) â†’ E} {f' : (fin (n + 1) â†’ â„) â†’L[â„] E} (hfc : continuous_on f (â‡‘box_integral.box.Icc I)) {x : fin (n + 1) â†’ â„} (hxI : x âˆˆ â‡‘box_integral.box.Icc I) {a : E} {Îµ : â„} (h0 : 0 < Îµ) (hÎµ : âˆ€ (y : fin (n + 1) â†’ â„), y âˆˆ â‡‘box_integral.box.Icc I â†’ âˆ¥f y - a - â‡‘f' (y - x)âˆ¥ â‰¤ Îµ * âˆ¥y - xâˆ¥) {c : nnreal} (hc : I.distortion â‰¤ c) : âˆ¥finset.univ.prod (Î» (j : fin (n + 1)), I.upper j - I.lower j) â€¢ â‡‘f' (pi.single i 1) - (box_integral.integral (I.face i) âŠ¥ (f âˆ˜ i.insert_nth (I.upper i)) box_integral.box_additive_map.volume - box_integral.integral (I.face i) âŠ¥ (f âˆ˜ i.insert_nth (I.lower i)) box_integral.box_additive_map.volume)âˆ¥ â‰¤ 2 * Îµ * â†‘c * finset.univ.prod (Î» (j : fin (n + 1)), I.upper j - I.lower j)
theorem antivary.sum_mul_lt_sum_comp_perm_mul_iff {Î¹ : Type u_1} {Î± : Type u_2} [linear_ordered_ring Î±] {Ïƒ : equiv.perm Î¹} {f g : Î¹ â†’ Î±} [fintype Î¹] (hfg : antivary f g) : finset.univ.sum (Î» (i : Î¹), f i * g i) < finset.univ.sum (Î» (i : Î¹), f (â‡‘Ïƒ i) * g i) â†” Â¬antivary (f âˆ˜ â‡‘Ïƒ) g
theorem finset.sum_subtype_of_mem {Î² : Type u} {Î± : Type v} {s : finset Î±} [add_comm_monoid Î²] (f : Î± â†’ Î²) {p : Î± â†’ Prop} [decidable_pred p] (h : âˆ€ (x : Î±), x âˆˆ s â†’ p x) : (finset.subtype p s).sum (Î» (x : subtype p), f â†‘x) = s.sum (Î» (x : Î±), f x)
theorem is_regular_of_cancel_monoid {R : Type u_1} [cancel_monoid R] (g : R) : is_regular g
theorem filter.tendsto_iff_seq_tendsto {Î± : Type u_3} {Î² : Type u_4} {f : Î± â†’ Î²} {k : filter Î±} {l : filter Î²} [k.is_countably_generated] : filter.tendsto f k l â†” âˆ€ (x : â„• â†’ Î±), filter.tendsto x filter.at_top k â†’ filter.tendsto (f âˆ˜ x) filter.at_top l
theorem polynomial.has_separable_contraction.eq_degree {F : Type} [comm_semiring F] {f : polynomial F} (hf : polynomial.has_separable_contraction 1 f) : hf.degree = f.nat_degree
theorem is_add_monoid_hom.neg {Î± : Type u_1} {Î² : Type u_2} [add_zero_class Î±] [add_comm_group Î²] {f : Î± â†’ Î²} (hf : is_add_monoid_hom f) : is_add_monoid_hom (Î» (a : Î±), -f a)
theorem dense_inducing.separable_space {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] {i : Î± â†’ Î²} (di : dense_inducing i) [topological_space.separable_space Î±] : topological_space.separable_space Î²
theorem list.drop_take_succ_eq_cons_nth_le {Î± : Type u_1} (L : list Î±) {i : â„•} (hi : i < L.length) : list.drop i (list.take (i + 1) L) = [L.nth_le i hi]
theorem zero_hom.ext_iff {M : Type u_3} {N : Type u_4} [has_zero M] [has_zero N] {f g : zero_hom M N} : f = g â†” âˆ€ (x : M), â‡‘f x = â‡‘g x
theorem orientation.oangle_rotation_oangle_right {V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) (x y : V) : o.oangle y (â‡‘(o.rotation (o.oangle x y)) x) = 0
theorem box_integral.prepartition.restrict_boxes_of_le {Î¹ : Type u_1} {I J : box_integral.box Î¹} (Ï€ : box_integral.prepartition I) (h : I â‰¤ J) : (Ï€.restrict J).boxes = Ï€.boxes
theorem monotone.pairwise_disjoint_on_Ioo_succ {Î± : Type u_1} {Î² : Type u_2} [linear_order Î±] [succ_order Î±] [preorder Î²] {f : Î± â†’ Î²} (hf : monotone f) : pairwise (disjoint on Î» (n : Î±), set.Ioo (f n) (f (order.succ n)))
theorem real.disjoint_residual_ae  : disjoint (residual â„) measure_theory.measure_space.volume.ae
theorem finset.sum_smul_vsub_const_eq_weighted_vsub {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {Î¹ : Type u_4} (s : finset Î¹) (w : Î¹ â†’ k) (pâ‚ : Î¹ â†’ P) (pâ‚‚ : P) (h : s.sum (Î» (i : Î¹), w i) = 0) : s.sum (Î» (i : Î¹), w i â€¢ (pâ‚ i -áµ¥ pâ‚‚)) = â‡‘(s.weighted_vsub pâ‚) w
theorem nat.factorization_mul {a b : â„•} (ha : a â‰  0) (hb : b â‰  0) : (a * b).factorization = a.factorization + b.factorization
theorem smooth_bump_function.nhds_basis_support {E : Type uE} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] {H : Type uH} [topological_space H] (I : model_with_corners â„ E H) {M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {c : M} [t2_space M] {s : set M} (hs : s âˆˆ nhds c) : (nhds c).has_basis (Î» (f : smooth_bump_function I c), tsupport â‡‘f âŠ† s) (Î» (f : smooth_bump_function I c), function.support â‡‘f)
theorem asymptotics.is_o.of_neg_right {Î± : Type u_1} {E : Type u_3} {F' : Type u_7} [has_norm E] [semi_normed_group F'] {f : Î± â†’ E} {g' : Î± â†’ F'} {l : filter Î±} : (f =o[l] Î» (x : Î±), -g' x) â†’ f =o[l] g'
theorem category_theory.is_iso_iff_nonzero {C : Type u_1} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_kernels C] {X Y : C} [category_theory.simple X] [category_theory.simple Y] (f : X âŸ¶ Y) : category_theory.is_iso f â†” f â‰  0
theorem is_localization.exist_integer_multiples_of_finset {R : Type u_1} [comm_ring R] (M : submonoid R) {S : Type u_2} [comm_ring S] [algebra R S] [is_localization M S] (s : finset S) : âˆƒ (b : â†¥M), âˆ€ (a : S), a âˆˆ s â†’ is_localization.is_integer R (â†‘b â€¢ a)
theorem cont_diff_bump_of_inner.convolution_tendsto_right' {G : Type u_2} {E' : Type u_4} [normed_group E'] {g : G â†’ E'} [measurable_space G] {Î¼ : measure_theory.measure G} [normed_space â„ E'] [inner_product_space â„ G] [complete_space E'] [borel_space G] [measure_theory.is_locally_finite_measure Î¼] [Î¼.is_open_pos_measure] [finite_dimensional â„ G] [Î¼.is_add_left_invariant] {Î¹ : Type u_1} {Ï† : Î¹ â†’ cont_diff_bump_of_inner 0} {l : filter Î¹} (hÏ† : filter.tendsto (Î» (i : Î¹), (Ï† i).R) l (nhds 0)) (hmg : measure_theory.ae_strongly_measurable g Î¼) {xâ‚€ : G} (hcg : continuous_at g xâ‚€) : filter.tendsto (Î» (i : Î¹), convolution (Î» (x : G), (Ï† i).normed Î¼ x) g (continuous_linear_map.lsmul â„ â„) Î¼ xâ‚€) l (nhds (g xâ‚€))
theorem has_fderiv_within_at.unique_diff_within_at {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {f : E â†’ F} {s : set E} {f' : E â†’L[ğ•œ] F} {x : E} (h : has_fderiv_within_at f f' s x) (hs : unique_diff_within_at ğ•œ s x) (h' : dense_range â‡‘f') : unique_diff_within_at ğ•œ (f '' s) (f x)
theorem complete_lattice.independent.sup_indep {Î± : Type u_1} {Î¹ : Type u_3} [complete_lattice Î±] {s : finset Î¹} {f : Î¹ â†’ Î±} : complete_lattice.independent (f âˆ˜ coe) â†’ s.sup_indep f
theorem complex.tendsto_norm_sq_cocompact_at_top  : filter.tendsto â‡‘complex.norm_sq (filter.cocompact â„‚) filter.at_top
theorem filter.tendsto.liminf_eq {Î± : Type u} {Î² : Type v} [conditionally_complete_linear_order Î±] [topological_space Î±] [order_topology Î±] {f : filter Î²} {u : Î² â†’ Î±} {a : Î±} [f.ne_bot] (h : filter.tendsto u f (nhds a)) : f.liminf u = a
theorem funext {Î± : Sort u} {Î² : Î± â†’ Sort v} {fâ‚ fâ‚‚ : Î  (x : Î±), Î² x} (h : âˆ€ (x : Î±), fâ‚ x = fâ‚‚ x) : fâ‚ = fâ‚‚
theorem generate_from_pi_eq {Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_3} [fintype Î¹] {C : Î  (i : Î¹), set (set (Î± i))} (hC : âˆ€ (i : Î¹), is_countably_spanning (C i)) : measurable_space.pi = measurable_space.generate_from (set.univ.pi '' set.univ.pi C)
theorem has_fpower_series_at.is_O_sub_partial_sum_pow {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field ğ•œ] [normed_group E] [normed_space ğ•œ E] [normed_group F] [normed_space ğ•œ F] {f : E â†’ F} {p : formal_multilinear_series ğ•œ E F} {x : E} (hf : has_fpower_series_at f p x) (n : â„•) : (Î» (y : E), f (x + y) - p.partial_sum n y) =O[nhds 0] Î» (y : E), âˆ¥yâˆ¥ ^ n
theorem set.abs_sub_left_of_mem_interval {Î± : Type u} [linear_ordered_add_comm_group Î±] {a b x : Î±} (h : x âˆˆ set.interval a b) : |x - a| â‰¤ |b - a|
theorem basis.orientation_comp_linear_equiv_eq_neg_iff_det_neg {R : Type u_1} [linear_ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {Î¹ : Type u_3} [decidable_eq Î¹] [fintype Î¹] (e : basis Î¹ R M) (f : M â‰ƒâ‚—[R] M) : (e.map f).orientation = -e.orientation â†” â‡‘linear_map.det â†‘f < 0
theorem t2_iff_nhds {Î± : Type u} [topological_space Î±] : t2_space Î± â†” âˆ€ {x y : Î±}, (nhds x âŠ“ nhds y).ne_bot â†’ x = y
theorem submonoid.fg_iff {M : Type u_1} [monoid M] (P : submonoid M) : P.fg â†” âˆƒ (S : set M), submonoid.closure S = P âˆ§ S.finite
theorem generalized_continued_fraction.of_correctness_of_terminated_at {K : Type u_1} [linear_ordered_field K] {v : K} {n : â„•} [floor_ring K] (terminated_at_n : (generalized_continued_fraction.of v).terminated_at n) : v = (generalized_continued_fraction.of v).convergents n
theorem finsum_eq_of_bijective {Î± : Type u_1} {Î² : Type u_2} {M : Type u_5} [add_comm_monoid M] {f : Î± â†’ M} {g : Î² â†’ M} (e : Î± â†’ Î²) (heâ‚€ : function.bijective e) (heâ‚ : âˆ€ (x : Î±), f x = g (e x)) : finsum (Î» (i : Î±), f i) = finsum (Î» (j : Î²), g j)
theorem rack.pre_envel_group_rel'.rel {R : Type u} [rack R] {a b : rack.pre_envel_group R} : rack.pre_envel_group_rel' R a b â†’ rack.pre_envel_group_rel R a b
theorem zmod.legendre_sym_eq_pow (p : â„•) (a : â„¤) [hp : fact (nat.prime p)] : â†‘(zmod.legendre_sym p a) = â†‘a ^ (p / 2)
theorem matrix.aeval_eq_aeval_mod_charpoly {R : Type u} [comm_ring R] {n : Type v} [decidable_eq n] [fintype n] (M : matrix n n R) (p : polynomial R) : â‡‘(polynomial.aeval M) p = â‡‘(polynomial.aeval M) (p %â‚˜ M.charpoly)
theorem affine.simplex.sum_points_with_circumcenter {Î± : Type u_1} [add_comm_monoid Î±] {n : â„•} (f : affine.simplex.points_with_circumcenter_index n â†’ Î±) : finset.univ.sum (Î» (i : affine.simplex.points_with_circumcenter_index n), f i) = finset.univ.sum (Î» (i : fin (n + 1)), f (affine.simplex.points_with_circumcenter_index.point_index i)) + f affine.simplex.points_with_circumcenter_index.circumcenter_index
theorem uniform_continuous_of_continuous_at_one {Î± : Type u_1} {Î² : Type u_2} [uniform_space Î±] [group Î±] [uniform_group Î±] {hom : Type u_3} [uniform_space Î²] [group Î²] [uniform_group Î²] [monoid_hom_class hom Î± Î²] (f : hom) (hf : continuous_at â‡‘f 1) : uniform_continuous â‡‘f
theorem category_theory.essentially_small.mk' {C : Type u} [category_theory.category C] {S : Type w} [category_theory.small_category S] (e : C â‰Œ S) : category_theory.essentially_small C
theorem right.one_lt_mul_of_lt_of_le {Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_mul.mul) has_lt.lt] {a b : Î±} (ha : 1 < a) (hb : 1 â‰¤ b) : 1 < a * b
theorem neg_le_self {Î± : Type u} [add_group Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a : Î±} (h : 0 â‰¤ a) : -a â‰¤ a
theorem is_preconnected_of_forall_pair {Î± : Type u} [topological_space Î±] {s : set Î±} (H : âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (y : Î±), y âˆˆ s â†’ (âˆƒ (t : set Î±) (H : t âŠ† s), x âˆˆ t âˆ§ y âˆˆ t âˆ§ is_preconnected t)) : is_preconnected s
theorem conformal_at_iff_differentiable_at_or_differentiable_at_comp_conj {f : â„‚ â†’ â„‚} {z : â„‚} : conformal_at f z â†” (differentiable_at â„‚ f z âˆ¨ differentiable_at â„‚ (f âˆ˜ â‡‘(star_ring_end â„‚)) (â‡‘(star_ring_end â„‚) z)) âˆ§ fderiv â„ f z â‰  0
theorem is_noetherian.finite_basis_index {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {Î¹ : Type u_1} {s : set Î¹} [is_noetherian K V] (b : basis â†¥s K V) : s.finite
theorem approximates_linear_on.surj_on_closed_ball_of_nonlinear_right_inverse {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] [cs : complete_space E] {f : E â†’ F} {s : set E} {c : nnreal} {f' : E â†’L[ğ•œ] F} (hf : approximates_linear_on f f' s c) (f'symm : f'.nonlinear_right_inverse) {Îµ : â„} {b : E} (Îµ0 : 0 â‰¤ Îµ) (hÎµ : metric.closed_ball b Îµ âŠ† s) : set.surj_on f (metric.closed_ball b Îµ) (metric.closed_ball (f b) (((â†‘(f'symm.nnnorm))â»Â¹ - â†‘c) * Îµ))
theorem covby.is_atom {Î± : Type u_1} [partial_order Î±] [order_bot Î±] {a : Î±} : âŠ¥ â‹– a â†’ is_atom a
theorem padic_val_nat.zero {p : â„•} : padic_val_nat p 0 = 0
theorem power_series.order_X_pow {R : Type u_1} [semiring R] [nontrivial R] (n : â„•) : (power_series.X ^ n).order = â†‘n
theorem subgroup.subset_closure {G : Type u_1} [group G] {k : set G} : k âŠ† â†‘(subgroup.closure k)
theorem field.exists_primitive_element_of_fintype_top (F : Type u_1) [field F] (E : Type u_2) [field E] [algebra F E] [fintype E] : âˆƒ (Î± : E), FâŸ®Î±âŸ¯ = âŠ¤
theorem category_theory.exact_inr_fst {ğ’œ : Type u_1} [category_theory.category ğ’œ] [category_theory.preadditive ğ’œ] [category_theory.limits.has_kernels ğ’œ] [category_theory.limits.has_images ğ’œ] [category_theory.limits.has_binary_biproducts ğ’œ] (A B : ğ’œ) : category_theory.exact category_theory.limits.biprod.inr category_theory.limits.biprod.fst
theorem finset.centroid_pair_fin (k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] [invertible 2] (p : fin 2 â†’ P) : finset.centroid k finset.univ p = 2â»Â¹ â€¢ (p 1 -áµ¥ p 0) +áµ¥ p 0
theorem eq.subset' {Î± : Type u} [has_subset Î±] {a b : Î±} [is_refl Î± has_subset.subset] : a = b â†’ a âŠ† b
theorem interval_integral.measure_integral_sub_linear_is_o_of_tendsto_ae_of_ge {Î¹ : Type u_1} {E : Type u_3} [normed_group E] [complete_space E] [normed_space â„ E] {f : â„ â†’ E} {a : â„} {c : E} {l l' : filter â„} {lt : filter Î¹} {Î¼ : measure_theory.measure â„} {u v : Î¹ â†’ â„} [measure_theory.is_locally_finite_measure Î¼] [interval_integral.FTC_filter a l l'] (hfm : strongly_measurable_at_filter f l' Î¼) (hf : filter.tendsto f (l' âŠ“ Î¼.ae) (nhds c)) (hu : filter.tendsto u lt l) (hv : filter.tendsto v lt l) (huv : v â‰¤á¶ [lt] u) : (Î» (t : Î¹), âˆ« (x : â„) in u t..v t, f x âˆ‚Î¼ + (â‡‘Î¼ (set.Ioc (v t) (u t))).to_real â€¢ c) =o[lt] Î» (t : Î¹), (â‡‘Î¼ (set.Ioc (v t) (u t))).to_real
theorem module.subsingleton (R : Type u_1) (M : Type u_2) [semiring R] [subsingleton R] [add_comm_monoid M] [module R M] : subsingleton M
theorem power_series.order_monomial_of_ne_zero {R : Type u_1} [semiring R] (n : â„•) (a : R) (h : a â‰  0) : (â‡‘(power_series.monomial R n) a).order = â†‘n
theorem linear_equiv.det_mul_det_symm {M : Type u_2} [add_comm_group M] {A : Type u_1} [comm_ring A] [module A M] (f : M â‰ƒâ‚—[A] M) : â‡‘linear_map.det â†‘f * â‡‘linear_map.det â†‘(f.symm) = 1
theorem polynomial.sum_range_pow_eq_bernoulli_sub (n p : â„•) : (â†‘p + 1) * (finset.range n).sum (Î» (k : â„•), â†‘k ^ p) = polynomial.eval â†‘n (polynomial.bernoulli p.succ) - bernoulli p.succ
theorem category_theory.abelian.pseudoelement.exact_of_pseudo_exact {C : Type u} [category_theory.category C] [category_theory.abelian C] {P Q R : C} (f : P âŸ¶ Q) (g : Q âŸ¶ R) : ((âˆ€ (a : â†¥P), â‡‘g (â‡‘f a) = 0) âˆ§ âˆ€ (b : â†¥Q), â‡‘g b = 0 â†’ (âˆƒ (a : â†¥P), â‡‘f a = b)) â†’ category_theory.exact f g
theorem linear_ordered_comm_group_with_zero.nhds_zero_of_ne_zero {Î“â‚€ : Type u_1} [linear_ordered_comm_group_with_zero Î“â‚€] (Î³ : Î“â‚€) (h : Î³ â‰  0) : {x : Î“â‚€ | x < Î³} âˆˆ nhds 0
theorem cont_diff_on_clm_apply {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {G : Type u_4} [normed_group G] [normed_space ğ•œ G] [complete_space ğ•œ] {n : with_top â„•} {f : E â†’ (F â†’L[ğ•œ] G)} {s : set E} [finite_dimensional ğ•œ F] : cont_diff_on ğ•œ n f s â†” âˆ€ (y : F), cont_diff_on ğ•œ n (Î» (x : E), â‡‘(f x) y) s
theorem cont_diff.prod {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {G : Type u_4} [normed_group G] [normed_space ğ•œ G] {n : with_top â„•} {f : E â†’ F} {g : E â†’ G} (hf : cont_diff ğ•œ n f) (hg : cont_diff ğ•œ n g) : cont_diff ğ•œ n (Î» (x : E), (f x, g x))
theorem polynomial.leading_coeff_prod {R : Type u} {Î¹ : Type w} (s : finset Î¹) [comm_semiring R] [no_zero_divisors R] (f : Î¹ â†’ polynomial R) : (s.prod (Î» (i : Î¹), f i)).leading_coeff = s.prod (Î» (i : Î¹), (f i).leading_coeff)
theorem local_equiv.eq_on_source.source_inter_preimage_eq {Î± : Type u_1} {Î² : Type u_2} {e e' : local_equiv Î± Î²} (he : e â‰ˆ e') (s : set Î²) : e.source âˆ© â‡‘e â»Â¹' s = e'.source âˆ© â‡‘e' â»Â¹' s
theorem affine.simplex.monge_point_eq_affine_combination_of_points_with_circumcenter {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {n : â„•} (s : affine.simplex â„ P (n + 2)) : s.monge_point = â‡‘(finset.univ.affine_combination s.points_with_circumcenter) (affine.simplex.monge_point_weights_with_circumcenter n)
theorem category_theory.has_weakly_initial_of_weakly_initial_set_and_has_products {C : Type u} [category_theory.category C] [category_theory.limits.has_products C] {Î¹ : Type v} {B : Î¹ â†’ C} (hB : âˆ€ (A : C), âˆƒ (i : Î¹), nonempty (B i âŸ¶ A)) : âˆƒ (T : C), âˆ€ (X : C), nonempty (T âŸ¶ X)
theorem metric.emetric_ball {Î± : Type u} [pseudo_metric_space Î±] {x : Î±} {Îµ : â„} : emetric.ball x (ennreal.of_real Îµ) = metric.ball x Îµ
theorem vector.scanl_singleton {Î± : Type u_1} {Î² : Type u_2} (f : Î² â†’ Î± â†’ Î²) (b : Î²) (v : vector Î± 1) : vector.scanl f b v = b::áµ¥f b v.head::áµ¥vector.nil
theorem finsum_mem_insert_zero {Î± : Type u_1} {M : Type u_5} [add_comm_monoid M] {f : Î± â†’ M} {a : Î±} {s : set Î±} (h : f a = 0) : finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ has_insert.insert a s), f i)) = finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), f i))
theorem besicovitch.exists_disjoint_closed_ball_covering_ae_aux {Î± : Type u_1} [metric_space Î±] [topological_space.second_countable_topology Î±] [measurable_space Î±] [opens_measurable_space Î±] [has_besicovitch_covering Î±] (Î¼ : measure_theory.measure Î±) [measure_theory.sigma_finite Î¼] (f : Î± â†’ set â„) (s : set Î±) (hf : âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (Î´ : â„), Î´ > 0 â†’ (f x âˆ© set.Ioo 0 Î´).nonempty) : âˆƒ (t : set (Î± Ã— â„)), t.countable âˆ§ (âˆ€ (p : Î± Ã— â„), p âˆˆ t â†’ p.fst âˆˆ s) âˆ§ (âˆ€ (p : Î± Ã— â„), p âˆˆ t â†’ p.snd âˆˆ f p.fst) âˆ§ â‡‘Î¼ (s  â‹ƒ (p : Î± Ã— â„) (hp : p âˆˆ t), metric.closed_ball p.fst p.snd) = 0 âˆ§ t.pairwise_disjoint (Î» (p : Î± Ã— â„), metric.closed_ball p.fst p.snd)
theorem finite_dimensional.exists_nontrivial_relation_of_dim_lt_card {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] {t : finset V} (h : finite_dimensional.finrank K V < t.card) : âˆƒ (f : V â†’ K), t.sum (Î» (e : V), f e â€¢ e) = 0 âˆ§ âˆƒ (x : V) (H : x âˆˆ t), f x â‰  0
theorem matrix.nondegenerate.eq_zero_of_ortho {m : Type u_1} {R : Type u_2} [fintype m] [comm_ring R] {M : matrix m m R} (hM : M.nondegenerate) {v : m â†’ R} (hv : âˆ€ (w : m â†’ R), matrix.dot_product v (M.mul_vec w) = 0) : v = 0
theorem phragmen_lindelof.eq_on_right_half_plane_of_superexponential_decay {E : Type u_1} [normed_group E] [normed_space â„‚ E] {f g : â„‚ â†’ E} (hfd : diff_cont_on_cl â„‚ f {z : â„‚ | 0 < z.re}) (hgd : diff_cont_on_cl â„‚ g {z : â„‚ | 0 < z.re}) (hfexp : âˆƒ (c : â„) (H : c < 2) (B : â„), f =O[filter.comap complex.abs filter.at_top âŠ“ filter.principal {z : â„‚ | 0 < z.re}] Î» (z : â„‚), real.exp (B * complex.abs z ^ c)) (hgexp : âˆƒ (c : â„) (H : c < 2) (B : â„), g =O[filter.comap complex.abs filter.at_top âŠ“ filter.principal {z : â„‚ | 0 < z.re}] Î» (z : â„‚), real.exp (B * complex.abs z ^ c)) (hre : asymptotics.superpolynomial_decay filter.at_top real.exp (Î» (x : â„), âˆ¥f â†‘x - g â†‘xâˆ¥)) (hfim : âˆƒ (C : â„), âˆ€ (x : â„), âˆ¥f (â†‘x * complex.I)âˆ¥ â‰¤ C) (hgim : âˆƒ (C : â„), âˆ€ (x : â„), âˆ¥g (â†‘x * complex.I)âˆ¥ â‰¤ C) : set.eq_on f g {z : â„‚ | 0 â‰¤ z.re}
theorem topological_space.positive_compacts.locally_compact_space_of_group {G : Type w} [topological_space G] [group G] [topological_group G] [t2_space G] (K : topological_space.positive_compacts G) : locally_compact_space G
theorem has_lt.lt.not_lt {Î± : Type u} [preorder Î±] {a b : Î±} (h : a < b) : Â¬b < a
theorem list.permutations_aux2_snd_eq {Î± : Type u_1} {Î² : Type u_2} (t : Î±) (ts : list Î±) (r : list Î²) (ys : list Î±) (f : list Î± â†’ Î²) : (list.permutations_aux2 t ts r ys f).snd = list.map (Î» (x : list Î±), f (x ++ ts)) (list.permutations_aux2 t list.nil list.nil ys id).snd ++ r
theorem tendsto_uniformly_iff_tendsto {Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_4} [uniform_space Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : filter Î¹} : tendsto_uniformly F f p â†” filter.tendsto (Î» (q : Î¹ Ã— Î±), (f q.snd, F q.fst q.snd)) (p.prod âŠ¤) (uniformity Î²)
theorem has_scalar.comp.is_scalar_tower {M : Type u_1} {N : Type u_2} {Î± : Type u_6} {Î² : Type u_7} [has_scalar M Î±] [has_scalar M Î²] [has_scalar Î± Î²] [is_scalar_tower M Î± Î²] (g : N â†’ M) : is_scalar_tower N Î± Î²
theorem add_subsemigroup.closure_mono {M : Type u_1} [has_add M] â¦ƒs t : set Mâ¦„ (h : s âŠ† t) : add_subsemigroup.closure s â‰¤ add_subsemigroup.closure t
theorem measure_theory.unif_integrable_const {Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_3} {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) [normed_group Î²] {p : ennreal} {g : Î± â†’ Î²} (hp : 1 â‰¤ p) (hp_ne_top : p â‰  âŠ¤) (hg : measure_theory.mem_â„’p g p Î¼) : measure_theory.unif_integrable (Î» (n : Î¹), g) p Î¼
theorem fourier_subalgebra_separates_points  : fourier_subalgebra.separates_points
theorem polynomial.cyclotomic_ne_zero (n : â„•) (R : Type u_1) [ring R] [nontrivial R] : polynomial.cyclotomic n R â‰  0
theorem neg_neg_iff_pos {Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a : Î±} : -a < 0 â†” 0 < a
theorem finset.sup_indep.independent {Î± : Type u_1} {Î¹ : Type u_3} [complete_lattice Î±] {s : finset Î¹} {f : Î¹ â†’ Î±} : s.sup_indep f â†’ complete_lattice.independent (f âˆ˜ coe)
theorem iterated_deriv_within_succ' {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {F : Type u_2} [normed_group F] [normed_space ğ•œ F] {n : â„•} {f : ğ•œ â†’ F} {s : set ğ•œ} {x : ğ•œ} (hxs : unique_diff_on ğ•œ s) (hx : x âˆˆ s) : iterated_deriv_within (n + 1) f s x = iterated_deriv_within n (deriv_within f s) s x
theorem subsemiring.closure_induction {R : Type u} [non_assoc_semiring R] {s : set R} {p : R â†’ Prop} {x : R} (h : x âˆˆ subsemiring.closure s) (Hs : âˆ€ (x : R), x âˆˆ s â†’ p x) (H0 : p 0) (H1 : p 1) (Hadd : âˆ€ (x y : R), p x â†’ p y â†’ p (x + y)) (Hmul : âˆ€ (x y : R), p x â†’ p y â†’ p (x * y)) : p x
theorem emetric.cauchy_seq_iff' {Î± : Type u} {Î² : Type v} [pseudo_emetric_space Î±] [nonempty Î²] [semilattice_sup Î²] {u : Î² â†’ Î±} : cauchy_seq u â†” âˆ€ (Îµ : ennreal), Îµ > 0 â†’ (âˆƒ (N : Î²), âˆ€ (n : Î²), n â‰¥ N â†’ has_edist.edist (u n) (u N) < Îµ)
theorem is_add_left_regular.of_add {R : Type u_1} {a b : R} [add_semigroup R] (ab : is_add_left_regular (a + b)) : is_add_left_regular b
theorem finset.filter_eq' {Î² : Type u_2} [decidable_eq Î²] (s : finset Î²) (b : Î²) : finset.filter (Î» (a : Î²), a = b) s = ite (b âˆˆ s) {b} âˆ…
theorem smul_add_smul_le_smul_add_smul' {k : Type u_1} {M : Type u_2} [ordered_ring k] [ordered_add_comm_group M] [module k M] [ordered_smul k M] [contravariant_class M M has_add.add has_le.le] {a b : k} {c d : M} (hba : b â‰¤ a) (hdc : d â‰¤ c) : a â€¢ d + b â€¢ c â‰¤ a â€¢ c + b â€¢ d
theorem category_theory.exponential_ideal.mk_of_iso {C : Type uâ‚} {D : Type uâ‚‚} [category_theory.category C] [category_theory.category D] (i : D â¥¤ C) [category_theory.limits.has_finite_products C] [category_theory.cartesian_closed C] [category_theory.reflective i] (h : Î  (A : C), i â‹™ category_theory.exp A â‹™ category_theory.left_adjoint i â‹™ i â‰… i â‹™ category_theory.exp A) : category_theory.exponential_ideal i
theorem free_group.injective_lift_of_ping_pong {Î¹ : Type u_1} [nontrivial Î¹] {G : Type u_1} [group G] (a : Î¹ â†’ G) {Î± : Type u_4} [mul_action G Î±] (X Y : Î¹ â†’ set Î±) (hXnonempty : âˆ€ (i : Î¹), (X i).nonempty) (hXdisj : pairwise (Î» (i j : Î¹), disjoint (X i) (X j))) (hYdisj : pairwise (Î» (i j : Î¹), disjoint (Y i) (Y j))) (hXYdisj : âˆ€ (i j : Î¹), disjoint (X i) (Y j)) (hX : âˆ€ (i : Î¹), a i â€¢ (Y i)á¶œ âŠ† X i) (hY : âˆ€ (i : Î¹), aâ»Â¹ i â€¢ (X i)á¶œ âŠ† Y i) : function.injective â‡‘(â‡‘free_group.lift a)
theorem add_submonoid.localization_map.comp_eq_of_eq {M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {N : Type u_2} [add_comm_monoid N] {P : Type u_3} [add_comm_monoid P] (f : S.localization_map N) {g : M â†’+ P} {T : add_submonoid P} {Q : Type u_4} [add_comm_monoid Q] (hg : âˆ€ (y : â†¥S), â‡‘g â†‘y âˆˆ T) (k : T.localization_map Q) {x y : M} (h : â‡‘(f.to_map) x = â‡‘(f.to_map) y) : â‡‘(k.to_map) (â‡‘g x) = â‡‘(k.to_map) (â‡‘g y)
theorem subring.one_mem {R : Type u} [ring R] (s : subring R) : 1 âˆˆ s
theorem norm_pow_le' {Î± : Type u_1} [semi_normed_ring Î±] (a : Î±) {n : â„•} (h : 0 < n) : âˆ¥a ^ nâˆ¥ â‰¤ âˆ¥aâˆ¥ ^ n
theorem witt_vector.ghost_component_teichmuller (p : â„•) {R : Type u_1} [hp : fact (nat.prime p)] [comm_ring R] (r : R) (n : â„•) : â‡‘(witt_vector.ghost_component n) (â‡‘(witt_vector.teichmuller p) r) = r ^ p ^ n
theorem asymptotics.is_O_with.neg_right {Î± : Type u_1} {E : Type u_3} {F' : Type u_7} [has_norm E] [semi_normed_group F'] {c : â„} {f : Î± â†’ E} {g' : Î± â†’ F'} {l : filter Î±} : asymptotics.is_O_with c l f g' â†’ asymptotics.is_O_with c l f (Î» (x : Î±), -g' x)
theorem measure_theory.lintegral_fn_integral_sub {Î± : Type u_1} {Î² : Type u_3} {E : Type u_6} [measurable_space Î±] [measurable_space Î²] {Î¼ : measure_theory.measure Î±} {Î½ : measure_theory.measure Î²} [normed_group E] [measure_theory.sigma_finite Î½] [normed_space â„ E] [complete_space E] [measure_theory.sigma_finite Î¼] â¦ƒf g : Î± Ã— Î² â†’ Eâ¦„ (F : E â†’ ennreal) (hf : measure_theory.integrable f (Î¼.prod Î½)) (hg : measure_theory.integrable g (Î¼.prod Î½)) : âˆ«â» (x : Î±), F (âˆ« (y : Î²), f (x, y) - g (x, y) âˆ‚Î½) âˆ‚Î¼ = âˆ«â» (x : Î±), F (âˆ« (y : Î²), f (x, y) âˆ‚Î½ - âˆ« (y : Î²), g (x, y) âˆ‚Î½) âˆ‚Î¼
theorem filter.tendsto.const_mul_at_top' {Î± : Type u_1} {R : Type u_2} {l : filter Î±} {f : Î± â†’ R} {r : R} [linear_ordered_semiring R] [archimedean R] (hr : 0 < r) (hf : filter.tendsto f l filter.at_top) : filter.tendsto (Î» (x : Î±), r * f x) l filter.at_top
theorem ring_equiv.ext {R : Type u_4} {S : Type u_5} [has_mul R] [has_add R] [has_mul S] [has_add S] {f g : R â‰ƒ+* S} (h : âˆ€ (x : R), â‡‘f x = â‡‘g x) : f = g
theorem norm_zero_eq_zero {M : Type u_1} [semi_normed_group M] (S : add_subgroup M) (hS : is_closed â†‘S) (m : M) (h : âˆ¥â‡‘(quotient_add_group.mk' S) mâˆ¥ = 0) : m âˆˆ S
theorem measure_theory.exists_upper_semicontinuous_le_integral_le {Î± : Type u_1} [topological_space Î±] [measurable_space Î±] [borel_space Î±] {Î¼ : measure_theory.measure Î±} [Î¼.weakly_regular] (f : Î± â†’ nnreal) (fint : measure_theory.integrable (Î» (x : Î±), â†‘(f x)) Î¼) {Îµ : â„} (Îµpos : 0 < Îµ) : âˆƒ (g : Î± â†’ nnreal), (âˆ€ (x : Î±), g x â‰¤ f x) âˆ§ upper_semicontinuous g âˆ§ measure_theory.integrable (Î» (x : Î±), â†‘(g x)) Î¼ âˆ§ âˆ« (x : Î±), â†‘(f x) âˆ‚Î¼ - Îµ â‰¤ âˆ« (x : Î±), â†‘(g x) âˆ‚Î¼
theorem category_theory.is_connected.of_constant_of_preserves_morphisms {J : Type uâ‚} [category_theory.category J] [nonempty J] (h : âˆ€ {Î± : Type uâ‚} (F : J â†’ Î±), (âˆ€ {jâ‚ jâ‚‚ : J}, (jâ‚ âŸ¶ jâ‚‚) â†’ F jâ‚ = F jâ‚‚) â†’ âˆ€ (j j' : J), F j = F j') : category_theory.is_connected J
theorem cont_mdiff_iff_target {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {M : Type u_4} [topological_space M] [charted_space H M] [Is : smooth_manifold_with_corners I M] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners ğ•œ E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] [I's : smooth_manifold_with_corners I' M'] {f : M â†’ M'} {n : with_top â„•} : cont_mdiff I I' n f â†” continuous f âˆ§ âˆ€ (y : M'), cont_mdiff_on I (model_with_corners_self ğ•œ E') n (â‡‘(ext_chart_at I' y) âˆ˜ f) (f â»Â¹' (ext_chart_at I' y).source)
theorem euclidean_geometry.dist_set_eq_iff_dist_orthogonal_projection_eq {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace â„ P} [nonempty â†¥s] [complete_space â†¥(s.direction)] {ps : set P} (hps : ps âŠ† â†‘s) (p : P) : ps.pairwise (Î» (p1 p2 : P), has_dist.dist p1 p = has_dist.dist p2 p) â†” ps.pairwise (Î» (p1 p2 : P), has_dist.dist p1 â†‘(â‡‘(euclidean_geometry.orthogonal_projection s) p) = has_dist.dist p2 â†‘(â‡‘(euclidean_geometry.orthogonal_projection s) p))
theorem affine_independent_of_subsingleton (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {Î¹ : Type u_4} [subsingleton Î¹] (p : Î¹ â†’ P) : affine_independent k p
theorem bilin_form.nondegenerate_iff_ker_eq_bot {Râ‚‚ : Type u_5} {Mâ‚‚ : Type u_6} [comm_semiring Râ‚‚] [add_comm_monoid Mâ‚‚] [module Râ‚‚ Mâ‚‚] {B : bilin_form Râ‚‚ Mâ‚‚} : B.nondegenerate â†” (â‡‘bilin_form.to_lin B).ker = âŠ¥
theorem add_subgroup.closure_inductionâ‚‚ {G : Type u_1} [add_group G] {k : set G} {p : G â†’ G â†’ Prop} {x y : G} (hx : x âˆˆ add_subgroup.closure k) (hy : y âˆˆ add_subgroup.closure k) (Hk : âˆ€ (x : G), x âˆˆ k â†’ âˆ€ (y : G), y âˆˆ k â†’ p x y) (H1_left : âˆ€ (x : G), p 0 x) (H1_right : âˆ€ (x : G), p x 0) (Hmul_left : âˆ€ (xâ‚ xâ‚‚ y : G), p xâ‚ y â†’ p xâ‚‚ y â†’ p (xâ‚ + xâ‚‚) y) (Hmul_right : âˆ€ (x yâ‚ yâ‚‚ : G), p x yâ‚ â†’ p x yâ‚‚ â†’ p x (yâ‚ + yâ‚‚)) (Hinv_left : âˆ€ (x y : G), p x y â†’ p (-x) y) (Hinv_right : âˆ€ (x y : G), p x y â†’ p x (-y)) : p x y
theorem add_monoid_hom.map_mul_iff {R : Type u_1} {S : Type u_2} [non_unital_non_assoc_semiring R] [non_unital_non_assoc_semiring S] (f : R â†’+ S) : (âˆ€ (x y : R), â‡‘f (x * y) = â‡‘f x * â‡‘f y) â†” add_monoid_hom.mul.comprâ‚‚ f = (add_monoid_hom.mul.comp f).complâ‚‚ f
theorem add_con.add_con_gen_eq {M : Type u_1} [has_add M] (r : M â†’ M â†’ Prop) : add_con_gen r = has_Inf.Inf {s : add_con M | âˆ€ (x y : M), r x y â†’ â‡‘s x y}
theorem is_add_hom.add {Î± : Type u_1} {Î² : Type u_2} [add_semigroup Î±] [add_comm_semigroup Î²] {f g : Î± â†’ Î²} (hf : is_add_hom f) (hg : is_add_hom g) : is_add_hom (Î» (a : Î±), f a + g a)
theorem polynomial.lifts_and_degree_eq_and_monic {R : Type u} [semiring R] {S : Type v} [semiring S] {f : R â†’+* S} [nontrivial S] {p : polynomial S} (hlifts : p âˆˆ polynomial.lifts f) (hp : p.monic) : âˆƒ (q : polynomial R), polynomial.map f q = p âˆ§ q.degree = p.degree âˆ§ q.monic
theorem intermediate_value_univâ‚‚ {X : Type u} {Î± : Type v} [topological_space X] [linear_order Î±] [topological_space Î±] [order_closed_topology Î±] [preconnected_space X] {a b : X} {f g : X â†’ Î±} (hf : continuous f) (hg : continuous g) (ha : f a â‰¤ g a) (hb : g b â‰¤ f b) : âˆƒ (x : X), f x = g x
theorem cont_diff_groupoid_le {m n : with_top â„•} {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] (I : model_with_corners ğ•œ E H) (h : m â‰¤ n) : cont_diff_groupoid n I â‰¤ cont_diff_groupoid m I
theorem continuous_at_left_of_monotone_on_of_exists_between {Î± : Type u_1} {Î² : Type u_2} [linear_order Î±] [topological_space Î±] [order_topology Î±] [linear_order Î²] [topological_space Î²] [order_topology Î²] {f : Î± â†’ Î²} {s : set Î±} {a : Î±} (hf : monotone_on f s) (hs : s âˆˆ nhds_within a (set.Iic a)) (hfs : âˆ€ (b : Î²), b < f a â†’ (âˆƒ (c : Î±) (H : c âˆˆ s), f c âˆˆ set.Ioo b (f a))) : continuous_within_at f (set.Iic a) a
theorem formal_multilinear_series.congr {ğ•œ : Type u_1} {E : Type u_3} {F : Type u_4} [comm_ring ğ•œ] [add_comm_group E] [module ğ•œ E] [topological_space E] [topological_add_group E] [has_continuous_const_smul ğ•œ E] [add_comm_group F] [module ğ•œ F] [topological_space F] [topological_add_group F] [has_continuous_const_smul ğ•œ F] (p : formal_multilinear_series ğ•œ E F) {m n : â„•} {v : fin m â†’ E} {w : fin n â†’ E} (h1 : m = n) (h2 : âˆ€ (i : â„•) (him : i < m) (hin : i < n), v âŸ¨i, himâŸ© = w âŸ¨i, hinâŸ©) : â‡‘(p m) v = â‡‘(p n) w
theorem interval_integral.integral_has_deriv_at_right {E : Type u_3} [normed_group E] [complete_space E] [normed_space â„ E] {f : â„ â†’ E} {a b : â„} (hf : interval_integrable f measure_theory.measure_space.volume a b) (hmeas : strongly_measurable_at_filter f (nhds b) measure_theory.measure_space.volume) (hb : continuous_at f b) : has_deriv_at (Î» (u : â„), âˆ« (x : â„) in a..u, f x) (f b) b
theorem pnat.factor_multiset_gcd (m n : â„•+) : (m.gcd n).factor_multiset = m.factor_multiset âŠ“ n.factor_multiset
theorem formal_multilinear_series.partial_sum_continuous {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [ring ğ•œ] [add_comm_group E] [add_comm_group F] [module ğ•œ E] [module ğ•œ F] [topological_space E] [topological_space F] [topological_add_group E] [topological_add_group F] [has_continuous_const_smul ğ•œ E] [has_continuous_const_smul ğ•œ F] (p : formal_multilinear_series ğ•œ E F) (n : â„•) : continuous (p.partial_sum n)
theorem nat.exists_strict_anti (Î± : Type u) [preorder Î±] [nonempty Î±] [no_min_order Î±] : âˆƒ (f : â„• â†’ Î±), strict_anti f
theorem units.mk_semiconj_by {M : Type u} [monoid M] (u : MË£) (x : M) : semiconj_by â†‘u x (â†‘u * x * â†‘uâ»Â¹)
theorem nnreal.Lp_add_le_has_sum {Î¹ : Type u} {f g : Î¹ â†’ nnreal} {A B : nnreal} {p : â„} (hp : 1 â‰¤ p) (hf : has_sum (Î» (i : Î¹), f i ^ p) (A ^ p)) (hg : has_sum (Î» (i : Î¹), g i ^ p) (B ^ p)) : âˆƒ (C : nnreal), C â‰¤ A + B âˆ§ has_sum (Î» (i : Î¹), (f i + g i) ^ p) (C ^ p)
theorem probability_theory.cond_cond_eq_cond_inter {Î± : Type u_1} {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) {s t : set Î±} [measure_theory.is_finite_measure Î¼] (hms : measurable_set s) (hmt : measurable_set t) (hci : â‡‘Î¼ (s âˆ© t) â‰  0) : probability_theory.cond (probability_theory.cond Î¼ s) t = probability_theory.cond Î¼ (s âˆ© t)
theorem nat.bitwise_comm {f : bool â†’ bool â†’ bool} (hf : âˆ€ (b b' : bool), f b b' = f b' b) (hf' : f bool.ff bool.ff = bool.ff) (n m : â„•) : nat.bitwise f n m = nat.bitwise f m n
theorem polynomial.eval_monomial_one_add_sub {S : Type v} [comm_ring S] (d : â„•) (y : S) : polynomial.eval (1 + y) (â‡‘(polynomial.monomial d) (â†‘d + 1)) - polynomial.eval y (â‡‘(polynomial.monomial d) (â†‘d + 1)) = (finset.range (d + 1)).sum (Î» (x_1 : â„•), â†‘((d + 1).choose x_1) * (â†‘x_1 * y ^ (x_1 - 1)))
theorem mem_nhds_within_Iio_iff_exists_Ioo_subset' {Î± : Type u} [topological_space Î±] [linear_order Î±] [order_topology Î±] {a l' : Î±} {s : set Î±} (hl' : l' < a) : s âˆˆ nhds_within a (set.Iio a) â†” âˆƒ (l : Î±) (H : l âˆˆ set.Iio a), set.Ioo l a âŠ† s
theorem free_group.red.church_rosser {Î± : Type u} {Lâ‚ Lâ‚‚ Lâ‚ƒ : list (Î± Ã— bool)} : free_group.red Lâ‚ Lâ‚‚ â†’ free_group.red Lâ‚ Lâ‚ƒ â†’ relation.join free_group.red Lâ‚‚ Lâ‚ƒ
theorem measure_theory.add_haar_measure_eq_volume_pi (Î¹ : Type u_1) [fintype Î¹] : measure_theory.measure.add_haar_measure (topological_space.positive_compacts.pi_Icc01 Î¹) = measure_theory.measure_space.volume
theorem is_left_regular.mul {R : Type u_1} {a b : R} [semigroup R] (lra : is_left_regular a) (lrb : is_left_regular b) : is_left_regular (a * b)
theorem affine_subspace.top_coe (k : Type u_1) (V : Type u_2) (P : Type u_3) [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] : â†‘âŠ¤ = set.univ
theorem category_theory.equiv_relation {J : Type uâ‚} [category_theory.category J] [category_theory.is_connected J] (r : J â†’ J â†’ Prop) (hr : equivalence r) (h : âˆ€ {jâ‚ jâ‚‚ : J}, (jâ‚ âŸ¶ jâ‚‚) â†’ r jâ‚ jâ‚‚) (jâ‚ jâ‚‚ : J) : r jâ‚ jâ‚‚
theorem nat.desc_factorial_of_lt {n k : â„•} : n < k â†’ n.desc_factorial k = 0
theorem module.End.pos_finrank_generalized_eigenspace_of_has_eigenvalue {K : Type v} {V : Type w} [field K] [add_comm_group V] [module K V] [finite_dimensional K V] {f : module.End K V} {k : â„•} {Î¼ : K} (hx : f.has_eigenvalue Î¼) (hk : 0 < k) : 0 < finite_dimensional.finrank K â†¥(â‡‘(f.generalized_eigenspace Î¼) k)
theorem monotone.pairwise_disjoint_on_Ioo_pred {Î± : Type u_1} {Î² : Type u_2} [linear_order Î±] [pred_order Î±] [preorder Î²] {f : Î± â†’ Î²} (hf : monotone f) : pairwise (disjoint on Î» (n : Î±), set.Ioo (f (order.pred n)) (f n))
theorem cont_diff_bump_of_inner.convolution_eq_right {G : Type u_2} {E' : Type u_4} [normed_group E'] {g : G â†’ E'} [measurable_space G] {Î¼ : measure_theory.measure G} [normed_space â„ E'] [inner_product_space â„ G] [complete_space E'] {Ï† : cont_diff_bump_of_inner 0} {xâ‚€ : G} (hg : âˆ€ (x : G), x âˆˆ metric.ball xâ‚€ Ï†.R â†’ g x = g xâ‚€) : convolution â‡‘Ï† g (continuous_linear_map.lsmul â„ â„) Î¼ xâ‚€ = measure_theory.integral Î¼ â‡‘Ï† â€¢ g xâ‚€
theorem measure_theory.measure.pi_eq_generate_from {Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_3} [fintype Î¹] [Î  (i : Î¹), measurable_space (Î± i)] {Î¼ : Î  (i : Î¹), measure_theory.measure (Î± i)} {C : Î  (i : Î¹), set (set (Î± i))} (hC : âˆ€ (i : Î¹), measurable_space.generate_from (C i) = _inst_3 i) (h2C : âˆ€ (i : Î¹), is_pi_system (C i)) (h3C : Î  (i : Î¹), (Î¼ i).finite_spanning_sets_in (C i)) {Î¼Î½ : measure_theory.measure (Î  (i : Î¹), Î± i)} (hâ‚ : âˆ€ (s : Î  (i : Î¹), set (Î± i)), (âˆ€ (i : Î¹), s i âˆˆ C i) â†’ â‡‘Î¼Î½ (set.univ.pi s) = finset.univ.prod (Î» (i : Î¹), â‡‘(Î¼ i) (s i))) : measure_theory.measure.pi Î¼ = Î¼Î½
theorem unique_diff_on.unique_mdiff_on {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {s : set E} : unique_diff_on ğ•œ s â†’ unique_mdiff_on (model_with_corners_self ğ•œ E) s
theorem euclidean_geometry.inter_eq_singleton_orthogonal_projection_fn {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace â„ P} [nonempty â†¥s] [complete_space â†¥(s.direction)] (p : P) : â†‘s âˆ© â†‘(affine_subspace.mk' p (s.direction)á—®) = {euclidean_geometry.orthogonal_projection_fn s p}
theorem convex.monotone_on_of_deriv_nonneg {D : set â„} (hD : convex â„ D) {f : â„ â†’ â„} (hf : continuous_on f D) (hf' : differentiable_on â„ f (interior D)) (hf'_nonneg : âˆ€ (x : â„), x âˆˆ interior D â†’ 0 â‰¤ deriv f x) : monotone_on f D
theorem lattice_ordered_comm_group.abs_abs {Î± : Type u} [lattice Î±] [add_comm_group Î±] [covariant_class Î± Î± has_add.add has_le.le] (a : Î±) : ||a|| = |a|
theorem nat.arithmetic_function.prod_eq_iff_prod_pow_moebius_eq_of_nonzero {R : Type u_1} [comm_group_with_zero R] {f g : â„• â†’ R} (hf : âˆ€ (n : â„•), 0 < n â†’ f n â‰  0) (hg : âˆ€ (n : â„•), 0 < n â†’ g n â‰  0) : (âˆ€ (n : â„•), 0 < n â†’ n.divisors.prod (Î» (i : â„•), f i) = g n) â†” âˆ€ (n : â„•), 0 < n â†’ n.divisors_antidiagonal.prod (Î» (x : â„• Ã— â„•), g x.snd ^ â‡‘nat.arithmetic_function.moebius x.fst) = f n
theorem affine.simplex.sum_reflection_circumcenter_weights_with_circumcenter {n : â„•} {iâ‚ iâ‚‚ : fin (n + 1)} (h : iâ‚ â‰  iâ‚‚) : finset.univ.sum (Î» (i : affine.simplex.points_with_circumcenter_index n), affine.simplex.reflection_circumcenter_weights_with_circumcenter iâ‚ iâ‚‚ i) = 1
theorem metric.thickening_eq_bUnion_ball {X : Type u} [pseudo_metric_space X] {Î´ : â„} {E : set X} : metric.thickening Î´ E = â‹ƒ (x : X) (H : x âˆˆ E), metric.ball x Î´
theorem add_monoid.is_torsion.module_of_fintype (R : Type u_3) (M : Type u_4) [add_comm_monoid M] [ring R] [fintype R] [module R M] : add_monoid.is_torsion M
theorem spectrum.has_fpower_series_on_ball_inverse_one_sub_smul (ğ•œ : Type u_1) {A : Type u_2} [nondiscrete_normed_field ğ•œ] [normed_ring A] [normed_algebra ğ•œ A] [complete_space A] (a : A) : has_fpower_series_on_ball (Î» (z : ğ•œ), ring.inverse (1 - z â€¢ a)) (Î» (n : â„•), continuous_multilinear_map.mk_pi_field ğ•œ (fin n) (a ^ n)) 0 (â†‘âˆ¥aâˆ¥â‚Š)â»Â¹
theorem continuous.exists_forall_ge {Î± : Type u_1} {Î² : Type u_2} [conditionally_complete_linear_order Î±] [topological_space Î±] [order_topology Î±] [topological_space Î²] [nonempty Î²] {f : Î² â†’ Î±} (hf : continuous f) (hlim : filter.tendsto f (filter.cocompact Î²) filter.at_bot) : âˆƒ (x : Î²), âˆ€ (y : Î²), f y â‰¤ f x
theorem inner_product_geometry.angle_neg_right {V : Type u_1} [inner_product_space â„ V] (x y : V) : inner_product_geometry.angle x (-y) = real.pi - inner_product_geometry.angle x y
theorem is_left_regular_of_left_cancel_semigroup {R : Type u_1} [left_cancel_semigroup R] (g : R) : is_left_regular g
theorem is_cyclotomic_extension.trans (S T : set â„•+) (A : Type u) (B : Type v) [comm_ring A] [comm_ring B] [algebra A B] (C : Type w) [comm_ring C] [algebra A C] [algebra B C] [is_scalar_tower A B C] [hS : is_cyclotomic_extension S A B] [hT : is_cyclotomic_extension T B C] : is_cyclotomic_extension (S âˆª T) A C
theorem is_topological_fiber_bundle.is_open_map_proj {B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z â†’ B} [topological_space Z] (h : is_topological_fiber_bundle F proj) : is_open_map proj
theorem pythagorean_triple.classification {x y z : â„¤} : pythagorean_triple x y z â†” âˆƒ (k m n : â„¤), (x = k * (m ^ 2 - n ^ 2) âˆ§ y = k * (2 * m * n) âˆ¨ x = k * (2 * m * n) âˆ§ y = k * (m ^ 2 - n ^ 2)) âˆ§ (z = k * (m ^ 2 + n ^ 2) âˆ¨ z = -k * (m ^ 2 + n ^ 2))
theorem finset.prod_univ_pi {Î± : Type u_1} {Î² : Type u_2} [decidable_eq Î±] [fintype Î±] [comm_monoid Î²] {Î´ : Î± â†’ Type u_3} {t : Î  (a : Î±), finset (Î´ a)} (f : (Î  (a : Î±), a âˆˆ finset.univ â†’ Î´ a) â†’ Î²) : (finset.univ.pi t).prod (Î» (x : Î  (a : Î±), a âˆˆ finset.univ â†’ Î´ a), f x) = (fintype.pi_finset t).prod (Î» (x : Î  (a : Î±), Î´ a), f (Î» (a : Î±) (_x : a âˆˆ finset.univ), x a))
theorem tendsto_of_tendsto_of_tendsto_of_le_of_le {Î± : Type u} {Î² : Type v} [topological_space Î±] [partial_order Î±] [t : order_topology Î±] {f g h : Î² â†’ Î±} {b : filter Î²} {a : Î±} (hg : filter.tendsto g b (nhds a)) (hh : filter.tendsto h b (nhds a)) (hgf : g â‰¤ f) (hfh : f â‰¤ h) : filter.tendsto f b (nhds a)
theorem prime_spectrum.exists_prime_spectrum_prod_le (R : Type u) [comm_ring R] [is_noetherian_ring R] (I : ideal R) : âˆƒ (Z : multiset (prime_spectrum R)), (multiset.map coe Z).prod â‰¤ I
theorem category_theory.limits.has_binary_biproducts.of_has_binary_products {C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_binary_products C] : category_theory.limits.has_binary_biproducts C
theorem fin.prod_univ_zero {Î² : Type u_2} [comm_monoid Î²] (f : fin 0 â†’ Î²) : finset.univ.prod (Î» (i : fin 0), f i) = 1
theorem measure_theory.signed_measure.exists_subset_restrict_nonpos {Î± : Type u_1} [measurable_space Î±] {s : measure_theory.signed_measure Î±} {i : set Î±} (hi : â‡‘s i < 0) : âˆƒ (j : set Î±), measurable_set j âˆ§ j âŠ† i âˆ§ measure_theory.vector_measure.restrict s j â‰¤ 0.restrict j âˆ§ â‡‘s j < 0
theorem filter.tendsto.eventually_interval_integrable {Î¹ : Type u_1} {E : Type u_3} [normed_group E] {f : â„ â†’ E} {Î¼ : measure_theory.measure â„} {l l' : filter â„} (hfm : strongly_measurable_at_filter f l' Î¼) [filter.tendsto_Ixx_class set.Ioc l l'] [l'.is_measurably_generated] (hÎ¼ : Î¼.finite_at_filter l') {c : E} (hf : filter.tendsto f l' (nhds c)) {u v : Î¹ â†’ â„} {lt : filter Î¹} (hu : filter.tendsto u lt l) (hv : filter.tendsto v lt l) : âˆ€á¶  (t : Î¹) in lt, interval_integrable f Î¼ (u t) (v t)
theorem is_compact.exists_mem_frontier_inf_dist_compl_eq_dist {E : Type u_1} [normed_group E] [normed_space â„ E] [nontrivial E] {x : E} {K : set E} (hK : is_compact K) (hx : x âˆˆ K) : âˆƒ (y : E) (H : y âˆˆ frontier K), metric.inf_dist x Ká¶œ = has_dist.dist x y
theorem category_theory.cocone_of_representable_Î¹_app {C : Type uâ‚} [category_theory.small_category C] (P : Cáµ’áµ– â¥¤ Type uâ‚) (j : (P.elements)áµ’áµ–) : (category_theory.cocone_of_representable P).Î¹.app j = (category_theory.yoneda_sections_small ((category_theory.category_of_elements.Ï€ P).left_op.obj j) (((category_theory.functor.const (P.elements)áµ’áµ–).obj (category_theory.cocone_of_representable P).X).obj j)).inv (opposite.unop j).snd
theorem normed_space.bounded_polar_of_mem_nhds_zero (ğ•œ : Type u_1) [nondiscrete_normed_field ğ•œ] {E : Type u_2} [semi_normed_group E] [normed_space ğ•œ E] {s : set E} (s_nhd : s âˆˆ nhds 0) : metric.bounded (normed_space.polar ğ•œ s)
theorem has_fderiv_at_filter_iff_has_deriv_at_filter {ğ•œ : Type u} [nondiscrete_normed_field ğ•œ] {F : Type v} [normed_group F] [normed_space ğ•œ F] {f : ğ•œ â†’ F} {x : ğ•œ} {L : filter ğ•œ} {f' : ğ•œ â†’L[ğ•œ] F} : has_fderiv_at_filter f f' x L â†” has_deriv_at_filter f (â‡‘f' 1) x L
theorem category_theory.limits.is_iso_colimit_cocone_parallel_pair_of_self {C : Type u} [category_theory.category C] {X Y : C} {f : X âŸ¶ Y} {c : category_theory.limits.cofork f f} (h : category_theory.limits.is_colimit c) : category_theory.is_iso c.Ï€
theorem add_neg' {Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : a < 0) (hb : b < 0) : a + b < 0
theorem lower_semicontinuous_at.add {Î± : Type u_1} [topological_space Î±] {x : Î±} {Î³ : Type u_4} [linear_ordered_add_comm_monoid Î³] [topological_space Î³] [order_topology Î³] [has_continuous_add Î³] {f g : Î± â†’ Î³} (hf : lower_semicontinuous_at f x) (hg : lower_semicontinuous_at g x) : lower_semicontinuous_at (Î» (z : Î±), f z + g z) x
theorem category_theory.exp_comparison_whisker_left {C : Type u} [category_theory.category C] {D : Type u'} [category_theory.category D] [category_theory.limits.has_finite_products C] [category_theory.limits.has_finite_products D] (F : C â¥¤ D) [category_theory.cartesian_closed C] [category_theory.cartesian_closed D] [category_theory.limits.preserves_limits_of_shape (category_theory.discrete category_theory.limits.walking_pair) F] {A A' : C} (f : A' âŸ¶ A) : category_theory.exp_comparison F A â‰« category_theory.whisker_left F (category_theory.pre (F.map f)) = category_theory.whisker_right (category_theory.pre f) F â‰« category_theory.exp_comparison F A'
theorem list.nth_le_take {Î± : Type u} (L : list Î±) {i j : â„•} (hi : i < L.length) (hj : i < j) : L.nth_le i hi = (list.take j L).nth_le i _
theorem Top.presheaf.is_iso_of_stalk_functor_map_iso {C : Type u} [category_theory.category C] [category_theory.limits.has_colimits C] {X : Top} [category_theory.concrete_category C] [category_theory.limits.preserves_filtered_colimits (category_theory.forget C)] [category_theory.limits.has_limits C] [category_theory.limits.preserves_limits (category_theory.forget C)] [category_theory.reflects_isomorphisms (category_theory.forget C)] {F G : Top.sheaf C X} (f : F âŸ¶ G) [âˆ€ (x : â†¥X), category_theory.is_iso ((Top.presheaf.stalk_functor C x).map f)] : category_theory.is_iso f
theorem edist_nndist {Î± : Type u} [pseudo_metric_space Î±] (x y : Î±) : has_edist.edist x y = â†‘(has_nndist.nndist x y)
theorem has_fderiv_at_ring_inverse {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {R : Type u_6} [normed_ring R] [normed_algebra ğ•œ R] [complete_space R] (x : RË£) : has_fderiv_at ring.inverse (-â‡‘(â‡‘(continuous_linear_map.lmul_left_right ğ•œ R) â†‘xâ»Â¹) â†‘xâ»Â¹) â†‘x
theorem matrix.conj_transpose_apply {m : Type u_2} {n : Type u_3} {Î± : Type v} [has_star Î±] (M : matrix m n Î±) (i : m) (j : n) : M.conj_transpose j i = has_star.star (M i j)
theorem strict_convex_closed_ball (ğ•œ : Type u_1) {E : Type u_2} [normed_linear_ordered_field ğ•œ] [normed_group E] [normed_space ğ•œ E] [strict_convex_space ğ•œ E] (x : E) (r : â„) : strict_convex ğ•œ (metric.closed_ball x r)
theorem finset.weighted_vsub_of_point_vadd_eq_of_sum_eq_one {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {Î¹ : Type u_4} (s : finset Î¹) (w : Î¹ â†’ k) (p : Î¹ â†’ P) (h : s.sum (Î» (i : Î¹), w i) = 1) (bâ‚ bâ‚‚ : P) : â‡‘(s.weighted_vsub_of_point p bâ‚) w +áµ¥ bâ‚ = â‡‘(s.weighted_vsub_of_point p bâ‚‚) w +áµ¥ bâ‚‚
theorem complex.has_fpower_series_on_ball_of_differentiable_off_countable {E : Type u} [normed_group E] [normed_space â„‚ E] [complete_space E] {R : nnreal} {c : â„‚} {f : â„‚ â†’ E} {s : set â„‚} (hs : s.countable) (hc : continuous_on f (metric.closed_ball c â†‘R)) (hd : âˆ€ (z : â„‚), z âˆˆ metric.ball c â†‘R  s â†’ differentiable_at â„‚ f z) (hR : 0 < R) : has_fpower_series_on_ball f (cauchy_power_series f c â†‘R) c â†‘R
theorem lp.mem_â„“p_of_tendsto {Î± : Type u_1} {E : Î± â†’ Type u_2} {p : ennreal} [Î  (i : Î±), normed_group (E i)] {Î¹ : Type u_3} {l : filter Î¹} [l.ne_bot] [fact (1 â‰¤ p)] {F : Î¹ â†’ â†¥(lp E p)} (hF : metric.bounded (set.range F)) {f : Î  (a : Î±), E a} (hf : filter.tendsto (id (Î» (i : Î¹), â‡‘(F i))) l (nhds f)) : mem_â„“p f p
theorem category_theory.limits.prod_comparison_natural {C : Type u} [category_theory.category C] {D : Type uâ‚‚} [category_theory.category D] (F : C â¥¤ D) {A A' B B' : C} [category_theory.limits.has_binary_product A B] [category_theory.limits.has_binary_product A' B'] [category_theory.limits.has_binary_product (F.obj A) (F.obj B)] [category_theory.limits.has_binary_product (F.obj A') (F.obj B')] (f : A âŸ¶ A') (g : B âŸ¶ B') : F.map (category_theory.limits.prod.map f g) â‰« category_theory.limits.prod_comparison F A' B' = category_theory.limits.prod_comparison F A B â‰« category_theory.limits.prod.map (F.map f) (F.map g)
theorem convex_hull_eq_union {ğ•œ : Type u_1} {E : Type u} [linear_ordered_field ğ•œ] [add_comm_group E] [module ğ•œ E] {s : set E} : â‡‘(convex_hull ğ•œ) s = â‹ƒ (t : finset E) (hss : â†‘t âŠ† s) (hai : affine_independent ğ•œ coe), â‡‘(convex_hull ğ•œ) â†‘t
theorem set.finite.eventually_all {Î± : Type u} {Î¹ : Type u_1} {I : set Î¹} (hI : I.finite) {l : filter Î±} {p : Î¹ â†’ Î± â†’ Prop} : (âˆ€á¶  (x : Î±) in l, âˆ€ (i : Î¹), i âˆˆ I â†’ p i x) â†” âˆ€ (i : Î¹), i âˆˆ I â†’ (âˆ€á¶  (x : Î±) in l, p i x)
theorem is_compact.exists_open_superset_measure_lt_top' {Î± : Type u_1} [topological_space Î±] [measurable_space Î±] {Î¼ : measure_theory.measure Î±} {s : set Î±} (h : is_compact s) (hÎ¼ : âˆ€ (x : Î±), x âˆˆ s â†’ Î¼.finite_at_filter (nhds x)) : âˆƒ (U : set Î±) (H : U âŠ‡ s), is_open U âˆ§ â‡‘Î¼ U < âŠ¤
theorem subgroup.closure_mul_image_eq_top' {G : Type u_1} [group G] {H : subgroup G} [decidable_eq G] {R S : finset G} (hR : â†‘R âˆˆ subgroup.right_transversals â†‘H) (hR1 : 1 âˆˆ R) (hS : subgroup.closure â†‘S = âŠ¤) : subgroup.closure â†‘(finset.image (Î» (g : G), âŸ¨g * (â†‘(subgroup.mem_right_transversals.to_fun hR g))â»Â¹, _âŸ©) (R * S)) = âŠ¤
theorem exp_add_of_mem_ball {ğ•‚ : Type u_1} {ğ”¸ : Type u_2} [nondiscrete_normed_field ğ•‚] [normed_comm_ring ğ”¸] [normed_algebra ğ•‚ ğ”¸] [complete_space ğ”¸] [char_zero ğ•‚] {x y : ğ”¸} (hx : x âˆˆ emetric.ball 0 (exp_series ğ•‚ ğ”¸).radius) (hy : y âˆˆ emetric.ball 0 (exp_series ğ•‚ ğ”¸).radius) : exp ğ•‚ (x + y) = exp ğ•‚ x * exp ğ•‚ y
theorem add_submonoid.localization_map.lift_add_right {M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {N : Type u_2} [add_comm_monoid N] {P : Type u_3} [add_comm_monoid P] (f : S.localization_map N) {g : M â†’+ P} (hg : âˆ€ (y : â†¥S), is_add_unit (â‡‘g â†‘y)) (z : N) : â‡‘(f.lift hg) z + â‡‘g â†‘((f.sec z).snd) = â‡‘g (f.sec z).fst
theorem inner_product_geometry.angle_self_neg_of_nonzero {V : Type u_1} [inner_product_space â„ V] {x : V} (hx : x â‰  0) : inner_product_geometry.angle x (-x) = real.pi
theorem finprod_mem_insert_one {Î± : Type u_1} {M : Type u_5} [comm_monoid M] {f : Î± â†’ M} {a : Î±} {s : set Î±} (h : f a = 1) : finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ has_insert.insert a s), f i)) = finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), f i))
theorem continuous_linear_map.is_open_map_of_ne_zero {R : Type u_1} {M : Type u_2} [topological_space R] [division_ring R] [has_continuous_sub R] [add_comm_group M] [topological_space M] [has_continuous_add M] [module R M] [has_continuous_smul R M] (f : M â†’L[R] R) (hf : f â‰  0) : is_open_map â‡‘f
theorem is_cyclotomic_extension.splitting_field_cyclotomic (n : â„•+) (K : Type w) (L : Type z) [field K] [field L] [algebra K L] [ne_zero â†‘â†‘n] [is_cyclotomic_extension {n} K L] : polynomial.is_splitting_field K L (polynomial.cyclotomic â†‘n K)
theorem category_theory.inv_map_unit {C : Type uâ‚} [category_theory.category C] {D : Type uâ‚‚} [category_theory.category D] {L : C â¥¤ D} {R : D â¥¤ C} (h : L âŠ£ R) {X : C} [category_theory.is_iso (h.unit.app X)] : category_theory.inv (L.map (h.unit.app X)) = h.counit.app (L.obj X)
theorem filter.mapâ‚‚_distrib_le_left {Î± : Type u_1} {Î² : Type u_3} {Î²' : Type u_4} {Î³ : Type u_5} {Î³' : Type u_6} {Î´ : Type u_7} {Îµ : Type u_9} {f : filter Î±} {g : filter Î²} {h : filter Î³} {m : Î± â†’ Î´ â†’ Îµ} {n : Î² â†’ Î³ â†’ Î´} {mâ‚ : Î± â†’ Î² â†’ Î²'} {mâ‚‚ : Î± â†’ Î³ â†’ Î³'} {n' : Î²' â†’ Î³' â†’ Îµ} (h_distrib : âˆ€ (a : Î±) (b : Î²) (c : Î³), m a (n b c) = n' (mâ‚ a b) (mâ‚‚ a c)) : filter.mapâ‚‚ m f (filter.mapâ‚‚ n g h) â‰¤ filter.mapâ‚‚ n' (filter.mapâ‚‚ mâ‚ f g) (filter.mapâ‚‚ mâ‚‚ f h)
theorem matrix.det_mul_comm {m : Type u_1} [decidable_eq m] [fintype m] {R : Type v} [comm_ring R] (M N : matrix m m R) : (M.mul N).det = (N.mul M).det
theorem balanced.subset_core_of_subset {ğ•œ : Type u_1} {E : Type u_2} [semi_normed_ring ğ•œ] [has_scalar ğ•œ E] {s t : set E} (hs : balanced ğ•œ s) (h : s âŠ† t) : s âŠ† balanced_core ğ•œ t
theorem category_theory.limits.finite_limits_from_equalizers_and_finite_products {C : Type u} [category_theory.category C] [category_theory.limits.has_finite_products C] [category_theory.limits.has_equalizers C] : category_theory.limits.has_finite_limits C
theorem measure_theory.analytic_set_iff_exists_polish_space_range {Î± : Type u_1} [topological_space Î±] {s : set Î±} : measure_theory.analytic_set s â†” âˆƒ (Î² : Type) (h : topological_space Î²) (h' : polish_space Î²) (f : Î² â†’ Î±), continuous f âˆ§ set.range f = s
theorem fractional_ideal.is_noetherian {Râ‚ : Type u_3} [comm_ring Râ‚] {K : Type u_4} [field K] [algebra Râ‚ K] [frac : is_fraction_ring Râ‚ K] [is_domain Râ‚] [is_noetherian_ring Râ‚] (I : fractional_ideal (non_zero_divisors Râ‚) K) : is_noetherian Râ‚ â†¥I
theorem is_submonoid.power_subset {M : Type u_1} [monoid M] {s : set M} {a : M} (hs : is_submonoid s) (h : a âˆˆ s) : powers a âŠ† s
theorem category_theory.limits.image_subobject_iso_comp {C : Type u} [category_theory.category C] {X Y : C} [category_theory.limits.has_equalizers C] {X' : C} (h : X' âŸ¶ X) [category_theory.is_iso h] (f : X âŸ¶ Y) [category_theory.limits.has_image f] : category_theory.limits.image_subobject (h â‰« f) = category_theory.limits.image_subobject f
theorem has_lt.lt.trans {Î± : Type u} [preorder Î±] {a b c : Î±} : a < b â†’ b < c â†’ a < c
theorem real.rpow_sum_le_const_mul_sum_rpow {Î¹ : Type u} (s : finset Î¹) (f : Î¹ â†’ â„) {p : â„} (hp : 1 â‰¤ p) : s.sum (Î» (i : Î¹), |f i|) ^ p â‰¤ â†‘(s.card) ^ (p - 1) * s.sum (Î» (i : Î¹), |f i| ^ p)
theorem linear_map.continuous_of_finite_dimensional {ğ•œ : Type u} [hnorm : nondiscrete_normed_field ğ•œ] {E : Type v} [add_comm_group E] [module ğ•œ E] [topological_space E] [topological_add_group E] [has_continuous_smul ğ•œ E] {F' : Type x} [add_comm_group F'] [module ğ•œ F'] [topological_space F'] [topological_add_group F'] [has_continuous_smul ğ•œ F'] [complete_space ğ•œ] [t2_space E] [finite_dimensional ğ•œ E] (f : E â†’â‚—[ğ•œ] F') : continuous â‡‘f
theorem continuous_linear_map.op_norm_lsmul_le {ğ•œ : Type u_1} {E : Type u_4} [semi_normed_group E] [nondiscrete_normed_field ğ•œ] [normed_space ğ•œ E] {ğ•œ' : Type u_10} [normed_field ğ•œ'] [normed_algebra ğ•œ ğ•œ'] [normed_space ğ•œ' E] [is_scalar_tower ğ•œ ğ•œ' E] : âˆ¥continuous_linear_map.lsmul ğ•œ ğ•œ'âˆ¥ â‰¤ 1
theorem category_theory.limits.coprod_comparison_natural {C : Type u} [category_theory.category C] {D : Type uâ‚‚} [category_theory.category D] (F : C â¥¤ D) {A A' B B' : C} [category_theory.limits.has_binary_coproduct A B] [category_theory.limits.has_binary_coproduct A' B'] [category_theory.limits.has_binary_coproduct (F.obj A) (F.obj B)] [category_theory.limits.has_binary_coproduct (F.obj A') (F.obj B')] (f : A âŸ¶ A') (g : B âŸ¶ B') : category_theory.limits.coprod_comparison F A B â‰« F.map (category_theory.limits.coprod.map f g) = category_theory.limits.coprod.map (F.map f) (F.map g) â‰« category_theory.limits.coprod_comparison F A' B'
theorem cSup_insert {Î± : Type u_1} [conditionally_complete_lattice Î±] {s : set Î±} {a : Î±} (hs : bdd_above s) (sne : s.nonempty) : has_Sup.Sup (has_insert.insert a s) = a âŠ” has_Sup.Sup s
theorem abs_add {Î± : Type u} [linear_ordered_add_comm_group Î±] (a b : Î±) : |a + b| â‰¤ |a| + |b|
theorem generalized_continued_fraction.abs_sub_convergents_le {K : Type u_1} {v : K} {n : â„•} [linear_ordered_field K] [floor_ring K] (not_terminated_at_n : Â¬(generalized_continued_fraction.of v).terminated_at n) : |v - (generalized_continued_fraction.of v).convergents n| â‰¤ 1 / ((generalized_continued_fraction.of v).denominators n * (generalized_continued_fraction.of v).denominators (n + 1))
theorem list.is_suffix.reverse {Î± : Type u_1} {lâ‚ lâ‚‚ : list Î±} : lâ‚ <:+ lâ‚‚ â†’ lâ‚.reverse <+: lâ‚‚.reverse
theorem is_primitive_root.norm_eq_neg_one_pow {K : Type u} {L : Type v} [field L] {Î¶ : L} [field K] [algebra K L] (hÎ¶ : is_primitive_root Î¶ 2) : â‡‘(algebra.norm K) Î¶ = (-1) ^ finite_dimensional.finrank K L
theorem is_add_torsion_of_fintype {G : Type u_1} [add_group G] [fintype G] : add_monoid.is_torsion G
theorem metric.bounded.closure {Î± : Type u} [pseudo_metric_space Î±] {s : set Î±} (h : metric.bounded s) : metric.bounded (closure s)
theorem measure_theory.lintegral_prod_of_measurable {Î± : Type u_1} {Î² : Type u_3} [measurable_space Î±] [measurable_space Î²] {Î¼ : measure_theory.measure Î±} {Î½ : measure_theory.measure Î²} [measure_theory.sigma_finite Î½] (f : Î± Ã— Î² â†’ ennreal) (hf : measurable f) : âˆ«â» (z : Î± Ã— Î²), f z âˆ‚Î¼.prod Î½ = âˆ«â» (x : Î±), âˆ«â» (y : Î²), f (x, y) âˆ‚Î½ âˆ‚Î¼
theorem complete_lattice.independent_iff_forall_dfinsupp {Î¹ : Type u_1} {R : Type u_2} {N : Type u_5} [dec_Î¹ : decidable_eq Î¹] [semiring R] [add_comm_monoid N] [module R N] (p : Î¹ â†’ submodule R N) : complete_lattice.independent p â†” âˆ€ (i : Î¹) (x : â†¥(p i)) (v : Î â‚€ (i : Î¹), â†¥(p i)), â‡‘(â‡‘(dfinsupp.lsum â„•) (Î» (i : Î¹), (p i).subtype)) (dfinsupp.erase i v) = â†‘x â†’ x = 0
theorem continuous_on.exists_forall_ge' {Î± : Type u_1} {Î² : Type u_2} [conditionally_complete_linear_order Î±] [topological_space Î±] [order_topology Î±] [topological_space Î²] {s : set Î²} {f : Î² â†’ Î±} (hf : continuous_on f s) (hsc : is_closed s) {xâ‚€ : Î²} (hâ‚€ : xâ‚€ âˆˆ s) (hc : âˆ€á¶  (x : Î²) in filter.cocompact Î² âŠ“ filter.principal s, f x â‰¤ f xâ‚€) : âˆƒ (x : Î²) (H : x âˆˆ s), âˆ€ (y : Î²), y âˆˆ s â†’ f y â‰¤ f x
theorem list.length_of_fn {Î± : Type u} {n : â„•} (f : fin n â†’ Î±) : (list.of_fn f).length = n
theorem measure_theory.integral2_divergence_prod_of_has_fderiv_within_at_off_countable {E : Type u} [normed_group E] [normed_space â„ E] [complete_space E] (f g : â„ Ã— â„ â†’ E) (f' g' : â„ Ã— â„ â†’ (â„ Ã— â„ â†’L[â„] E)) (aâ‚ aâ‚‚ bâ‚ bâ‚‚ : â„) (s : set (â„ Ã— â„)) (hs : s.countable) (Hcf : continuous_on f (set.interval aâ‚ bâ‚ Ã—Ë¢ set.interval aâ‚‚ bâ‚‚)) (Hcg : continuous_on g (set.interval aâ‚ bâ‚ Ã—Ë¢ set.interval aâ‚‚ bâ‚‚)) (Hdf : âˆ€ (x : â„ Ã— â„), x âˆˆ set.Ioo (linear_order.min aâ‚ bâ‚) (linear_order.max aâ‚ bâ‚) Ã—Ë¢ set.Ioo (linear_order.min aâ‚‚ bâ‚‚) (linear_order.max aâ‚‚ bâ‚‚)  s â†’ has_fderiv_at f (f' x) x) (Hdg : âˆ€ (x : â„ Ã— â„), x âˆˆ set.Ioo (linear_order.min aâ‚ bâ‚) (linear_order.max aâ‚ bâ‚) Ã—Ë¢ set.Ioo (linear_order.min aâ‚‚ bâ‚‚) (linear_order.max aâ‚‚ bâ‚‚)  s â†’ has_fderiv_at g (g' x) x) (Hi : measure_theory.integrable_on (Î» (x : â„ Ã— â„), â‡‘(f' x) (1, 0) + â‡‘(g' x) (0, 1)) (set.interval aâ‚ bâ‚ Ã—Ë¢ set.interval aâ‚‚ bâ‚‚) measure_theory.measure_space.volume) : âˆ« (x : â„) in aâ‚..bâ‚, âˆ« (y : â„) in aâ‚‚..bâ‚‚, â‡‘(f' (x, y)) (1, 0) + â‡‘(g' (x, y)) (0, 1) = (((âˆ« (x : â„) in aâ‚..bâ‚, g (x, bâ‚‚)) - âˆ« (x : â„) in aâ‚..bâ‚, g (x, aâ‚‚)) + âˆ« (y : â„) in aâ‚‚..bâ‚‚, f (bâ‚, y)) - âˆ« (y : â„) in aâ‚‚..bâ‚‚, f (aâ‚, y)
theorem closure_operator.mem_mkâ‚ƒ_closed {Î± : Type u_1} [partial_order Î±] {f : Î± â†’ Î±} {p : Î± â†’ Prop} {hf : âˆ€ (x : Î±), x â‰¤ f x} {hfp : âˆ€ (x : Î±), p (f x)} {hmin : âˆ€ â¦ƒx y : Î±â¦„, x â‰¤ y â†’ p y â†’ f x â‰¤ y} {x : Î±} (hx : p x) : x âˆˆ (closure_operator.mkâ‚ƒ f p hf hfp hmin).closed
theorem category_theory.is_pushout.of_right {C : Type uâ‚} [category_theory.category C] {Xâ‚â‚ Xâ‚â‚‚ Xâ‚â‚ƒ Xâ‚‚â‚ Xâ‚‚â‚‚ Xâ‚‚â‚ƒ : C} {hâ‚â‚ : Xâ‚â‚ âŸ¶ Xâ‚â‚‚} {hâ‚â‚‚ : Xâ‚â‚‚ âŸ¶ Xâ‚â‚ƒ} {hâ‚‚â‚ : Xâ‚‚â‚ âŸ¶ Xâ‚‚â‚‚} {hâ‚‚â‚‚ : Xâ‚‚â‚‚ âŸ¶ Xâ‚‚â‚ƒ} {vâ‚â‚ : Xâ‚â‚ âŸ¶ Xâ‚‚â‚} {vâ‚â‚‚ : Xâ‚â‚‚ âŸ¶ Xâ‚‚â‚‚} {vâ‚â‚ƒ : Xâ‚â‚ƒ âŸ¶ Xâ‚‚â‚ƒ} (s : category_theory.is_pushout (hâ‚â‚ â‰« hâ‚â‚‚) vâ‚â‚ vâ‚â‚ƒ (hâ‚‚â‚ â‰« hâ‚‚â‚‚)) (p : hâ‚â‚‚ â‰« vâ‚â‚ƒ = vâ‚â‚‚ â‰« hâ‚‚â‚‚) (t : category_theory.is_pushout hâ‚â‚ vâ‚â‚ vâ‚â‚‚ hâ‚‚â‚) : category_theory.is_pushout hâ‚â‚‚ vâ‚â‚‚ vâ‚â‚ƒ hâ‚‚â‚‚
theorem continuous_linear_map.adjoint_comp {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] [inner_product_space ğ•œ F] [inner_product_space ğ•œ G] [complete_space E] [complete_space G] [complete_space F] (A : F â†’L[ğ•œ] G) (B : E â†’L[ğ•œ] F) : â‡‘continuous_linear_map.adjoint (A.comp B) = (â‡‘continuous_linear_map.adjoint B).comp (â‡‘continuous_linear_map.adjoint A)
theorem category_theory.is_cofiltered.cone_nonempty {C : Type u} [category_theory.category C] [category_theory.is_cofiltered C] {J : Type v} [category_theory.small_category J] [category_theory.fin_category J] (F : J â¥¤ C) : nonempty (category_theory.limits.cone F)
theorem finset.induction_on {Î± : Type u_1} {p : finset Î± â†’ Prop} [decidable_eq Î±] (s : finset Î±) (hâ‚ : p âˆ…) (hâ‚‚ : âˆ€ â¦ƒa : Î±â¦„ {s : finset Î±}, a âˆ‰ s â†’ p s â†’ p (has_insert.insert a s)) : p s
theorem real.Gamma_integral_convergent {s : â„} (h : 0 < s) : measure_theory.integrable_on (Î» (x : â„), real.exp (-x) * x ^ (s - 1)) (set.Ioi 0) measure_theory.measure_space.volume
theorem convex.norm_image_sub_le_of_norm_fderiv_within_le {E : Type u_1} [normed_group E] [normed_space â„ E] {ğ•œ : Type u_3} {G : Type u_4} [is_R_or_C ğ•œ] [normed_space ğ•œ E] [normed_group G] [normed_space ğ•œ G] {f : E â†’ G} {C : â„} {s : set E} {x y : E} (hf : differentiable_on ğ•œ f s) (bound : âˆ€ (x : E), x âˆˆ s â†’ âˆ¥fderiv_within ğ•œ f s xâˆ¥ â‰¤ C) (hs : convex â„ s) (xs : x âˆˆ s) (ys : y âˆˆ s) : âˆ¥f y - f xâˆ¥ â‰¤ C * âˆ¥y - xâˆ¥
theorem even.neg {Î± : Type u_2} [subtraction_monoid Î±] {a : Î±} : even a â†’ even (-a)
theorem algebra.mul_smul_comm {R : Type u} {A : Type w} [comm_semiring R] [semiring A] [algebra R A] (s : R) (x y : A) : x * s â€¢ y = s â€¢ (x * y)
theorem category_theory.category_of_elements.costructured_arrow_yoneda_equivalence_naturality {C : Type u} [category_theory.category C] {Fâ‚ Fâ‚‚ : Cáµ’áµ– â¥¤ Type v} (Î± : Fâ‚ âŸ¶ Fâ‚‚) : (category_theory.category_of_elements.map Î±).op â‹™ category_theory.category_of_elements.to_costructured_arrow Fâ‚‚ = category_theory.category_of_elements.to_costructured_arrow Fâ‚ â‹™ category_theory.costructured_arrow.map Î±
theorem free_group.reduce.idem {Î± : Type u} {L : list (Î± Ã— bool)} [decidable_eq Î±] : free_group.reduce (free_group.reduce L) = free_group.reduce L
theorem polynomial.nat_degree_mul_C_eq_of_mul_ne_zero {R : Type u} {a : R} [semiring R] {p : polynomial R} (h : p.leading_coeff * a â‰  0) : (p * â‡‘polynomial.C a).nat_degree = p.nat_degree
theorem isometry.ediam_image {Î± : Type u} {Î² : Type v} [pseudo_emetric_space Î±] [pseudo_emetric_space Î²] {f : Î± â†’ Î²} (hf : isometry f) (s : set Î±) : emetric.diam (f '' s) = emetric.diam s
theorem category_theory.has_limits_of_shape_of_reflective {C : Type uâ‚} [category_theory.category C] {D : Type uâ‚‚} [category_theory.category D] {J : Type u} [category_theory.category J] [category_theory.limits.has_limits_of_shape J C] (R : D â¥¤ C) [category_theory.reflective R] : category_theory.limits.has_limits_of_shape J D
theorem ideal.quotient_mk_maps_eq {R : Type u_1} [comm_ring R] (P : ideal (polynomial R)) : ((ideal.quotient.mk (ideal.map (polynomial.map_ring_hom (ideal.quotient.mk (ideal.comap polynomial.C P))) P)).comp polynomial.C).comp (ideal.quotient.mk (ideal.comap polynomial.C P)) = ((ideal.map (polynomial.map_ring_hom (ideal.quotient.mk (ideal.comap polynomial.C P))) P).quotient_map (polynomial.map_ring_hom (ideal.quotient.mk (ideal.comap polynomial.C P))) ideal.le_comap_map).comp ((ideal.quotient.mk P).comp polynomial.C)
theorem asymptotics.is_O.norm_norm {Î± : Type u_1} {E' : Type u_6} {F' : Type u_7} [semi_normed_group E'] [semi_normed_group F'] {f' : Î± â†’ E'} {g' : Î± â†’ F'} {l : filter Î±} : f' =O[l] g' â†’ ((Î» (x : Î±), âˆ¥f' xâˆ¥) =O[l] Î» (x : Î±), âˆ¥g' xâˆ¥)
theorem wcovby.to_dual {Î± : Type u_1} [preorder Î±] {a b : Î±} : a â©¿ b â†’ â‡‘order_dual.to_dual b â©¿ â‡‘order_dual.to_dual a
theorem continuous_on.tendsto_uniformly {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [uniform_space Î±] [uniform_space Î²] [locally_compact_space Î±] [compact_space Î²] [separated_space Î²] [uniform_space Î³] {f : Î± â†’ Î² â†’ Î³} {x : Î±} {U : set Î±} (hxU : U âˆˆ nhds x) (hU : is_separated U) (h : continuous_on â†¿f (U Ã—Ë¢ set.univ)) : tendsto_uniformly f (f x) (nhds x)
theorem has_deriv_at.lhopital_zero_nhds {a : â„} {l : filter â„} {f f' g g' : â„ â†’ â„} (hff' : âˆ€á¶  (x : â„) in nhds a, has_deriv_at f (f' x) x) (hgg' : âˆ€á¶  (x : â„) in nhds a, has_deriv_at g (g' x) x) (hg' : âˆ€á¶  (x : â„) in nhds a, g' x â‰  0) (hfa : filter.tendsto f (nhds a) (nhds 0)) (hga : filter.tendsto g (nhds a) (nhds 0)) (hdiv : filter.tendsto (Î» (x : â„), f' x / g' x) (nhds a) l) : filter.tendsto (Î» (x : â„), f x / g x) (nhds_within a (set.univ  {a})) l
theorem real.summable_nat_rpow_inv {p : â„} : summable (Î» (n : â„•), (â†‘n ^ p)â»Â¹) â†” 1 < p
theorem pgame.mul_one_equiv (x : pgame) : (x * 1).equiv x
theorem filter.map_mapâ‚‚_right_comm {Î± : Type u_1} {Î² : Type u_3} {Î²' : Type u_4} {Î³ : Type u_5} {Î´ : Type u_7} {f : filter Î±} {g : filter Î²} {m : Î± â†’ Î²' â†’ Î³} {n : Î² â†’ Î²'} {m' : Î± â†’ Î² â†’ Î´} {n' : Î´ â†’ Î³} (h_right_comm : âˆ€ (a : Î±) (b : Î²), m a (n b) = n' (m' a b)) : filter.mapâ‚‚ m f (filter.map n g) = filter.map n' (filter.mapâ‚‚ m' f g)
theorem emetric.diam_singleton {Î± : Type u} [pseudo_emetric_space Î±] {x : Î±} : emetric.diam {x} = 0
theorem is_artinian_span_of_finite (R : Type u_1) {M : Type u_2} [ring R] [add_comm_group M] [module R M] [is_artinian_ring R] {A : set M} (hA : A.finite) : is_artinian R â†¥(submodule.span R A)
theorem inner_product_geometry.angle_self {V : Type u_1} [inner_product_space â„ V] {x : V} (hx : x â‰  0) : inner_product_geometry.angle x x = 0
theorem witt_vector.init_is_poly (p n : â„•) : witt_vector.is_poly p (Î» (R : Type u_1) (_Rcr : comm_ring R), witt_vector.init n)
theorem lie_module.zero_weight_space_eq_top_of_nilpotent' {R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] (M : Type w) [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] [lie_algebra.is_nilpotent R L] [lie_module.is_nilpotent R L M] : lie_module.weight_space M 0 = âŠ¤
theorem bounded_continuous_function.tietze_extension_step {X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] [normal_space Y] (f : bounded_continuous_function X â„) (e : C(X, Y)) (he : closed_embedding â‡‘e) : âˆƒ (g : bounded_continuous_function Y â„), âˆ¥gâˆ¥ â‰¤ âˆ¥fâˆ¥ / 3 âˆ§ has_dist.dist (g.comp_continuous e) f â‰¤ 2 / 3 * âˆ¥fâˆ¥
theorem category_theory.limits.prod.symmetry {C : Type u} [category_theory.category C] (P Q : C) [category_theory.limits.has_binary_product P Q] [category_theory.limits.has_binary_product Q P] : (category_theory.limits.prod.braiding P Q).hom â‰« (category_theory.limits.prod.braiding Q P).hom = ğŸ™ (P â¨¯ Q)
theorem relation.rprod_le_trans_gen_game_add {Î± : Type u_1} {Î² : Type u_2} (rÎ± : Î± â†’ Î± â†’ Prop) (rÎ² : Î² â†’ Î² â†’ Prop) : prod.rprod rÎ± rÎ² â‰¤ relation.trans_gen (relation.game_add rÎ± rÎ²)
theorem filter.tendsto_neg_cobounded {E : Type u_3} [semi_normed_group E] : filter.tendsto has_neg.neg (filter.comap has_norm.norm filter.at_top) (filter.comap has_norm.norm filter.at_top)
theorem field.nonempty_iff {Î± : Type u} : nonempty (field Î±) â†” is_prime_pow (cardinal.mk Î±)
theorem pgame.mul_zero_equiv (x : pgame) : (x * 0).equiv 0
theorem finsupp.comap_smul_apply {Î± : Type u_1} {M : Type u_5} {G : Type u_9} [group G] [mul_action G Î±] [add_comm_monoid M] (g : G) (f : Î± â†’â‚€ M) (a : Î±) : â‡‘(g â€¢ f) a = â‡‘f (gâ»Â¹ â€¢ a)
theorem ae_strongly_measurable_iff_ae_measurable {Î± : Type u_1} {Î² : Type u_2} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [topological_space Î²] {f : Î± â†’ Î²} [measurable_space Î²] [topological_space.pseudo_metrizable_space Î²] [borel_space Î²] [topological_space.second_countable_topology Î²] : measure_theory.ae_strongly_measurable f Î¼ â†” ae_measurable f Î¼
theorem eventually_residual_liouville  : âˆ€á¶  (x : â„) in residual â„, liouville x
theorem add_commute.add_left {S : Type u_1} [add_semigroup S] {a b c : S} (hac : add_commute a c) (hbc : add_commute b c) : add_commute (a + b) c
theorem orthogonal_family.linear_isometry_equiv_symm_apply_dfinsupp_sum_single {Î¹ : Type u_1} {ğ•œ : Type u_2} [is_R_or_C ğ•œ] {E : Type u_3} [inner_product_space ğ•œ E] [cplt : complete_space E] {G : Î¹ â†’ Type u_4} [Î  (i : Î¹), inner_product_space ğ•œ (G i)] {V : Î  (i : Î¹), G i â†’â‚—áµ¢[ğ•œ] E} (hV : orthogonal_family ğ•œ V) [âˆ€ (i : Î¹), complete_space (G i)] (hV' : (â¨† (i : Î¹), (V i).to_linear_map.range).topological_closure = âŠ¤) (Wâ‚€ : Î â‚€ (i : Î¹), G i) : â‡‘((hV.linear_isometry_equiv hV').symm) (Wâ‚€.sum (lp.single 2)) = Wâ‚€.sum (Î» (i : Î¹), â‡‘(V i))
theorem quotient.induction_onâ‚‚' {Î± : Sort u_1} {Î² : Sort u_2} {sâ‚ : setoid Î±} {sâ‚‚ : setoid Î²} {p : quotient sâ‚ â†’ quotient sâ‚‚ â†’ Prop} (qâ‚ : quotient sâ‚) (qâ‚‚ : quotient sâ‚‚) (h : âˆ€ (aâ‚ : Î±) (aâ‚‚ : Î²), p (quotient.mk' aâ‚) (quotient.mk' aâ‚‚)) : p qâ‚ qâ‚‚
theorem normed_space.eq_iff_forall_dual_eq (ğ•œ : Type v) [is_R_or_C ğ•œ] {E : Type u} [normed_group E] [normed_space ğ•œ E] {x y : E} : x = y â†” âˆ€ (g : normed_space.dual ğ•œ E), â‡‘g x = â‡‘g y
theorem mem_orthogonal_singleton_of_inner_left {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] (u : E) {v : E} (hv : has_inner.inner v u = 0) : v âˆˆ (submodule.span ğ•œ {u})á—®
theorem complex.has_strict_deriv_at_cos (x : â„‚) : has_strict_deriv_at complex.cos (-complex.sin x) x
theorem tendsto_div_of_monotone_of_tendsto_div_floor_pow (u : â„• â†’ â„) (l : â„) (hmono : monotone u) (c : â„• â†’ â„) (cone : âˆ€ (k : â„•), 1 < c k) (clim : filter.tendsto c filter.at_top (nhds 1)) (hc : âˆ€ (k : â„•), filter.tendsto (Î» (n : â„•), u âŒŠc k ^ nâŒ‹â‚Š / â†‘âŒŠc k ^ nâŒ‹â‚Š) filter.at_top (nhds l)) : filter.tendsto (Î» (n : â„•), u n / â†‘n) filter.at_top (nhds l)
theorem normed_group.core.to_semi_normed_group.core {E : Type u_1} [add_comm_group E] [has_norm E] (C : normed_group.core E) : semi_normed_group.core E
theorem real.young_inequality (a b : â„) {p q : â„} (hpq : p.is_conjugate_exponent q) : a * b â‰¤ |a| ^ p / p + |b| ^ q / q
theorem ball_pi' {Î² : Type v} {Ï€ : Î² â†’ Type u_1} [fintype Î²] [Î  (b : Î²), pseudo_metric_space (Ï€ b)] [nonempty Î²] (x : Î  (b : Î²), Ï€ b) (r : â„) : metric.ball x r = set.univ.pi (Î» (b : Î²), metric.ball (x b) r)
theorem measure_theory.jordan_decomposition.exists_compl_positive_negative {Î± : Type u_1} [measurable_space Î±] (j : measure_theory.jordan_decomposition Î±) : âˆƒ (S : set Î±), measurable_set S âˆ§ measure_theory.vector_measure.restrict j.to_signed_measure S â‰¤ 0.restrict S âˆ§ 0.restrict Sá¶œ â‰¤ measure_theory.vector_measure.restrict j.to_signed_measure Sá¶œ âˆ§ â‡‘(j.pos_part) S = 0 âˆ§ â‡‘(j.neg_part) Sá¶œ = 0
theorem tendsto_uniformly_on.continuous_on {Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_4} [uniform_space Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : set Î±} {p : filter Î¹} [topological_space Î±] (h : tendsto_uniformly_on F f p s) (hc : âˆ€á¶  (n : Î¹) in p, continuous_on (F n) s) [p.ne_bot] : continuous_on f s
theorem ring_equiv.to_non_unital_ring_hom_commutes {R : Type u_4} {S : Type u_5} [non_assoc_semiring R] [non_assoc_semiring S] (f : R â‰ƒ+* S) : â†‘â†‘f = â†‘f
theorem simplex_category.epi_iff_surjective {n m : simplex_category} {f : n âŸ¶ m} : category_theory.epi f â†” function.surjective â‡‘(simplex_category.hom.to_order_hom f)
theorem even.exists_bit0 {Î± : Type u_2} [has_add Î±] {a : Î±} : even a â†’ (âˆƒ (b : Î±), a = bit0 b)
theorem vsub_vadd_eq_vsub_sub {G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] (p1 p2 : P) (g : G) : p1 -áµ¥ (g +áµ¥ p2) = p1 -áµ¥ p2 - g
theorem emetric.Hausdorff_edist_triangle {Î± : Type u} [pseudo_emetric_space Î±] {s t u : set Î±} : emetric.Hausdorff_edist s u â‰¤ emetric.Hausdorff_edist s t + emetric.Hausdorff_edist t u
theorem cauchy_seq_of_le_geometric {Î± : Type u_1} [pseudo_metric_space Î±] (r C : â„) (hr : r < 1) {f : â„• â†’ Î±} (hu : âˆ€ (n : â„•), has_dist.dist (f n) (f (n + 1)) â‰¤ C * r ^ n) : cauchy_seq f
theorem topological_fiber_bundle_core.continuous_proj {Î¹ : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core Î¹ B F) : continuous Z.proj
theorem convex.lipschitz_on_with_of_nnnorm_deriv_le {ğ•œ : Type u_3} {G : Type u_4} [is_R_or_C ğ•œ] [normed_group G] [normed_space ğ•œ G] {f : ğ•œ â†’ G} {s : set ğ•œ} {C : nnreal} (hf : âˆ€ (x : ğ•œ), x âˆˆ s â†’ differentiable_at ğ•œ f x) (bound : âˆ€ (x : ğ•œ), x âˆˆ s â†’ âˆ¥deriv f xâˆ¥â‚Š â‰¤ C) (hs : convex â„ s) : lipschitz_on_with C f s
theorem is_torsion.subgroup {G : Type u_1} [group G] (tG : monoid.is_torsion G) (H : subgroup G) : monoid.is_torsion â†¥H
theorem nat.pow_factorization_choose_le {p n k : â„•} (hn : 0 < n) : p ^ â‡‘((n.choose k).factorization) p â‰¤ n
theorem category_theory.ProjectiveResolution.lift_f_one_zero_comm {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_equalizers C] [category_theory.limits.has_images C] {Y Z : C} (f : Y âŸ¶ Z) (P : category_theory.ProjectiveResolution Y) (Q : category_theory.ProjectiveResolution Z) : category_theory.ProjectiveResolution.lift_f_one f P Q â‰« Q.complex.d 1 0 = P.complex.d 1 0 â‰« category_theory.ProjectiveResolution.lift_f_zero f P Q
theorem matrix.pivot.mul_list_transvec_row_last_col_take {ğ•œ : Type u_3} [field ğ•œ] {r : â„•} (M : matrix (fin r âŠ• unit) (fin r âŠ• unit) ğ•œ) (i : fin r âŠ• unit) {k : â„•} (hk : k â‰¤ r) : M.mul (list.take k (matrix.pivot.list_transvec_row M)).prod i (sum.inr ()) = M i (sum.inr ())
theorem monotone_on.map_bdd_above {Î± : Type u} {Î² : Type v} [preorder Î±] [preorder Î²] {f : Î± â†’ Î²} {s t : set Î±} (Hf : monotone_on f t) (Hst : s âŠ† t) : (upper_bounds s âˆ© t).nonempty â†’ bdd_above (f '' s)
theorem submodule.linear_map_qext {R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] (p : submodule R M) {Râ‚‚ : Type u_3} {Mâ‚‚ : Type u_4} [ring Râ‚‚] [add_comm_group Mâ‚‚] [module Râ‚‚ Mâ‚‚] {Ï„â‚â‚‚ : R â†’+* Râ‚‚} â¦ƒf g : M â§¸ p â†’â‚›â‚—[Ï„â‚â‚‚] Mâ‚‚â¦„ (h : f.comp p.mkq = g.comp p.mkq) : f = g
theorem measure_theory.measure.absolutely_continuous.ae_le {Î± : Type u_1} {m0 : measurable_space Î±} {Î¼ Î½ : measure_theory.measure Î±} : Î¼.absolutely_continuous Î½ â†’ Î¼.ae â‰¤ Î½.ae
theorem interval_integral.integral_sub_integral_sub_linear_is_o_of_tendsto_ae_left {Î¹ : Type u_1} {E : Type u_3} [normed_group E] [complete_space E] [normed_space â„ E] {f : â„ â†’ E} {c : E} {la la' : filter â„} {lt : filter Î¹} {a b : â„} {u v : Î¹ â†’ â„} [interval_integral.FTC_filter a la la'] (hab : interval_integrable f measure_theory.measure_space.volume a b) (hmeas : strongly_measurable_at_filter f la' measure_theory.measure_space.volume) (hf : filter.tendsto f (la' âŠ“ measure_theory.measure_space.volume.ae) (nhds c)) (hu : filter.tendsto u lt la) (hv : filter.tendsto v lt la) : (Î» (t : Î¹), ((âˆ« (x : â„) in v t..b, f x) - âˆ« (x : â„) in u t..b, f x) + (v t - u t) â€¢ c) =o[lt] (v - u)
theorem ennreal.cancel_coe {a : nnreal} : add_le_cancellable â†‘a
theorem has_ssubset.ssubset.ne' {Î± : Type u} [has_ssubset Î±] [is_irrefl Î± has_ssubset.ssubset] {a b : Î±} : a âŠ‚ b â†’ b â‰  a
theorem orthogonal_projection_orthogonal_complement_singleton_eq_zero {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] [complete_space E] (v : E) : â‡‘(orthogonal_projection (submodule.span ğ•œ {v})á—®) v = 0
theorem dioph.pow_dioph {Î± : Type} {f g : (Î± â†’ â„•) â†’ â„•} (df : dioph.dioph_fn f) (dg : dioph.dioph_fn g) : dioph.dioph_fn (Î» (v : Î± â†’ â„•), f v ^ g v)
theorem lie_algebra.subsingleton_of_semisimple_lie_abelian (R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] [lie_algebra.is_semisimple R L] [h : is_lie_abelian L] : subsingleton L
theorem add_subgroup.fg_iff_add_submonoid.fg {G : Type u_3} [add_group G] (P : add_subgroup G) : P.fg â†” P.to_add_submonoid.fg
theorem triple_product_permutation {R : Type u_1} [comm_ring R] (u v w : fin 3 â†’ R) : matrix.dot_product u (â‡‘(â‡‘cross_product v) w) = matrix.dot_product v (â‡‘(â‡‘cross_product w) u)
theorem category_theory.solution_set_condition_of_is_right_adjoint {C : Type u} [category_theory.category C] {D : Type u} [category_theory.category D] (G : D â¥¤ C) [category_theory.is_right_adjoint G] : category_theory.solution_set_condition G
theorem add_pow {R : Type u_1} [comm_semiring R] (x y : R) (n : â„•) : (x + y) ^ n = (finset.range (n + 1)).sum (Î» (m : â„•), x ^ m * y ^ (n - m) * â†‘(n.choose m))
theorem reflection_mem_subspace_orthogonal_complement_eq_neg {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {K : submodule ğ•œ E} [complete_space â†¥K] {v : E} (hv : v âˆˆ Ká—®) : â‡‘(reflection K) v = -v
theorem nat.lt_base_pow_length_digits' {b m : â„•} : m < (b + 2) ^ ((b + 2).digits m).length
theorem convolution_lmul_swap {ğ•œ : Type u_1} {G : Type u_2} {x : G} [nondiscrete_normed_field ğ•œ] [measurable_space G] {Î¼ : measure_theory.measure G} [add_comm_group G] [topological_space G] [topological_add_group G] [borel_space G] [Î¼.is_add_left_invariant] [Î¼.is_neg_invariant] [normed_space â„ ğ•œ] [complete_space ğ•œ] {f g : G â†’ ğ•œ} : convolution f g (continuous_linear_map.lmul ğ•œ ğ•œ) Î¼ x = âˆ« (t : G), f (x - t) * g t âˆ‚Î¼
theorem setoid.empty_not_mem_classes {Î± : Type u_1} {r : setoid Î±} : âˆ… âˆ‰ r.classes
theorem is_torsion.quotient_iff {G : Type u_1} {H : Type u_2} [group G] {N : subgroup G} [group H] {f : G â†’* H} (hf : function.surjective â‡‘f) (hN : N = f.ker) (tN : monoid.is_torsion â†¥N) : monoid.is_torsion H â†” monoid.is_torsion G
theorem convex.norm_image_sub_le_of_norm_fderiv_within_le' {E : Type u_1} [normed_group E] [normed_space â„ E] {ğ•œ : Type u_3} {G : Type u_4} [is_R_or_C ğ•œ] [normed_space ğ•œ E] [normed_group G] [normed_space ğ•œ G] {f : E â†’ G} {C : â„} {s : set E} {x y : E} {Ï† : E â†’L[ğ•œ] G} (hf : differentiable_on ğ•œ f s) (bound : âˆ€ (x : E), x âˆˆ s â†’ âˆ¥fderiv_within ğ•œ f s x - Ï†âˆ¥ â‰¤ C) (hs : convex â„ s) (xs : x âˆˆ s) (ys : y âˆˆ s) : âˆ¥f y - f x - â‡‘Ï† (y - x)âˆ¥ â‰¤ C * âˆ¥y - xâˆ¥
theorem padic_val_nat.self {p : â„•} (hp : 1 < p) : padic_val_nat p p = 1
theorem asymptotics.is_O_iff {Î± : Type u_1} {E : Type u_3} {F : Type u_4} [has_norm E] [has_norm F] {f : Î± â†’ E} {g : Î± â†’ F} {l : filter Î±} : f =O[l] g â†” âˆƒ (c : â„), âˆ€á¶  (x : Î±) in l, âˆ¥f xâˆ¥ â‰¤ c * âˆ¥g xâˆ¥
theorem nat.factorization_choose_le_log {p n k : â„•} : â‡‘((n.choose k).factorization) p â‰¤ nat.log p n
theorem is_right_regular.subsingleton {R : Type u_1} [mul_zero_class R] (h : is_right_regular 0) : subsingleton R
theorem multiset.nodup.powerset {Î± : Type u_1} {s : multiset Î±} : s.nodup â†’ s.powerset.nodup
theorem ring_hom.map_finsupp_prod {Î± : Type u_1} {M : Type u_5} {R : Type u_11} {S : Type u_12} [has_zero M] [comm_semiring R] [comm_semiring S] (h : R â†’+* S) (f : Î± â†’â‚€ M) (g : Î± â†’ M â†’ R) : â‡‘h (f.prod g) = f.prod (Î» (a : Î±) (b : M), â‡‘h (g a b))
theorem map_inv {G : Type u_6} {H : Type u_7} {F : Type u_8} [group G] [division_monoid H] [monoid_hom_class F G H] (f : F) (a : G) : â‡‘f aâ»Â¹ = (â‡‘f a)â»Â¹
theorem finset.prod_sum {Î± : Type u} {Î² : Type v} [comm_semiring Î²] {Î´ : Î± â†’ Type u_1} [decidable_eq Î±] [Î  (a : Î±), decidable_eq (Î´ a)] {s : finset Î±} {t : Î  (a : Î±), finset (Î´ a)} {f : Î  (a : Î±), Î´ a â†’ Î²} : s.prod (Î» (a : Î±), (t a).sum (Î» (b : Î´ a), f a b)) = (s.pi t).sum (Î» (p : Î  (a : Î±), a âˆˆ s â†’ Î´ a), s.attach.prod (Î» (x : {x // x âˆˆ s}), f x.val (p x.val _)))
theorem linear_map.trace_conj (R : Type u) [comm_semiring R] {M : Type v} [add_comm_monoid M] [module R M] (g : M â†’â‚—[R] M) (f : (M â†’â‚—[R] M)Ë£) : â‡‘(linear_map.trace R M) (â†‘f * g * â†‘fâ»Â¹) = â‡‘(linear_map.trace R M) g
theorem category_theory.is_equivalence.of_iso_trans {C : Type uâ‚} [category_theory.category C] {D : Type uâ‚‚} [category_theory.category D] {F G H : C â¥¤ D} (e : F â‰… G) (e' : G â‰… H) (hF : category_theory.is_equivalence F) : category_theory.is_equivalence.of_iso e' (category_theory.is_equivalence.of_iso e hF) = category_theory.is_equivalence.of_iso (e â‰ªâ‰« e') hF
theorem category_theory.limits.types.jointly_surjective' {J : Type v} [category_theory.small_category J] {F : J â¥¤ Type (max v u)} (x : category_theory.limits.colimit F) : âˆƒ (j : J) (y : F.obj j), category_theory.limits.colimit.Î¹ F j y = x
theorem Mon.filtered_colimits.colimit_mul_aux_eq_of_rel_left {J : Type v} [category_theory.small_category J] (F : J â¥¤ Mon) [category_theory.is_filtered J] {x x' y : Î£ (j : J), â†¥(F.obj j)} (hxx' : category_theory.limits.types.filtered_colimit.rel (F â‹™ category_theory.forget Mon) x x') : Mon.filtered_colimits.colimit_mul_aux F x y = Mon.filtered_colimits.colimit_mul_aux F x' y
theorem max_zero_sub_eq_self {Î± : Type u} [add_group Î±] [linear_order Î±] [covariant_class Î± Î± has_add.add has_le.le] (a : Î±) : linear_order.max a 0 - linear_order.max (-a) 0 = a
theorem nat.factorization_mul_of_coprime {a b : â„•} (hab : a.coprime b) : (a * b).factorization = a.factorization + b.factorization
theorem vitali_family.measure_lim_ratio_meas_zero {Î± : Type u_1} [metric_space Î±] {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (v : vitali_family Î¼) [sigma_compact_space Î±] [borel_space Î±] [measure_theory.is_locally_finite_measure Î¼] {Ï : measure_theory.measure Î±} [measure_theory.is_locally_finite_measure Ï] (hÏ : Ï.absolutely_continuous Î¼) : â‡‘Ï {x : Î± | v.lim_ratio_meas hÏ x = 0} = 0
theorem finset.centroid_def (k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] {Î¹ : Type u_4} (s : finset Î¹) (p : Î¹ â†’ P) : finset.centroid k s p = â‡‘(s.affine_combination p) (finset.centroid_weights k s)
theorem basis.orientation_units_smul {R : Type u_1} [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {Î¹ : Type u_4} [fintype Î¹] [decidable_eq Î¹] [nontrivial R] (e : basis Î¹ R M) (w : Î¹ â†’ RË£) : (e.units_smul w).orientation = (finset.univ.prod (Î» (i : Î¹), w i))â»Â¹ â€¢ e.orientation
theorem polynomial.roots_of_cyclotomic (n : â„•) (R : Type u_1) [comm_ring R] [is_domain R] : (polynomial.cyclotomic' n R).roots = (primitive_roots n R).val
theorem add_monoid_algebra.grade_by.is_internal {M : Type u_1} {Î¹ : Type u_2} {R : Type u_3} [decidable_eq M] [add_monoid M] [decidable_eq Î¹] [add_monoid Î¹] [comm_semiring R] (f : M â†’+ Î¹) : direct_sum.is_internal (add_monoid_algebra.grade_by R â‡‘f)
theorem Gromov_Hausdorff.GH_dist_le_of_approx_subsets {X : Type u} [metric_space X] [compact_space X] [nonempty X] {Y : Type v} [metric_space Y] [compact_space Y] [nonempty Y] {s : set X} (Î¦ : â†¥s â†’ Y) {Îµâ‚ Îµâ‚‚ Îµâ‚ƒ : â„} (hs : âˆ€ (x : X), âˆƒ (y : X) (H : y âˆˆ s), has_dist.dist x y â‰¤ Îµâ‚) (hs' : âˆ€ (x : Y), âˆƒ (y : â†¥s), has_dist.dist x (Î¦ y) â‰¤ Îµâ‚ƒ) (H : âˆ€ (x y : â†¥s), |has_dist.dist x y - has_dist.dist (Î¦ x) (Î¦ y)| â‰¤ Îµâ‚‚) : Gromov_Hausdorff.GH_dist X Y â‰¤ Îµâ‚ + Îµâ‚‚ / 2 + Îµâ‚ƒ
theorem antitone.dual_right {Î± : Type u} {Î² : Type v} [preorder Î±] [preorder Î²] {f : Î± â†’ Î²} : antitone f â†’ monotone (â‡‘order_dual.to_dual âˆ˜ f)
theorem mul_right_continuous {Î± : Type u_1} [topological_space Î±] [non_unital_non_assoc_ring Î±] [topological_ring Î±] (x : Î±) : continuous â‡‘(add_monoid_hom.mul_right x)
theorem set.finite.bdd_above_bUnion {Î± : Type u} {Î² : Type v} [semilattice_sup Î±] [nonempty Î±] {I : set Î²} {S : Î² â†’ set Î±} (H : I.finite) : bdd_above (â‹ƒ (i : Î²) (H : i âˆˆ I), S i) â†” âˆ€ (i : Î²), i âˆˆ I â†’ bdd_above (S i)
theorem approximates_linear_on.inverse_continuous_on {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {f : E â†’ F} {f' : E â‰ƒL[ğ•œ] F} {s : set E} {c : nnreal} (hf : approximates_linear_on f â†‘f' s c) (hc : subsingleton E âˆ¨ c < âˆ¥â†‘(f'.symm)âˆ¥â‚Šâ»Â¹) : continuous_on â‡‘((hf.to_local_equiv hc).symm) (f '' s)
theorem phragmen_lindelof.eq_zero_on_quadrant_I {E : Type u_1} [normed_group E] [normed_space â„‚ E] {f : â„‚ â†’ E} (hd : diff_cont_on_cl â„‚ f (set.Ioi 0 Ã—â„‚ set.Ioi 0)) (hB : âˆƒ (c : â„) (H : c < 2) (B : â„), f =O[filter.comap complex.abs filter.at_top âŠ“ filter.principal (set.Ioi 0 Ã—â„‚ set.Ioi 0)] Î» (z : â„‚), real.exp (B * complex.abs z ^ c)) (hre : âˆ€ (x : â„), 0 â‰¤ x â†’ f â†‘x = 0) (him : âˆ€ (x : â„), 0 â‰¤ x â†’ f (â†‘x * complex.I) = 0) : set.eq_on f 0 {z : â„‚ | 0 â‰¤ z.re âˆ§ 0 â‰¤ z.im}
theorem category_theory.is_pushout.zero_right {C : Type uâ‚} [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_zero_morphisms C] (X : C) : category_theory.is_pushout 0 (ğŸ™ X) 0 0
theorem convex.taylor_approx_two_segment {E : Type u_1} {F : Type u_2} [normed_group E] [normed_space â„ E] [normed_group F] [normed_space â„ F] {s : set E} (s_conv : convex â„ s) {f : E â†’ F} {f' : E â†’ (E â†’L[â„] F)} {f'' : E â†’L[â„] E â†’L[â„] F} (hf : âˆ€ (x : E), x âˆˆ interior s â†’ has_fderiv_at f (f' x) x) {x : E} (xs : x âˆˆ s) (hx : has_fderiv_within_at f' f'' (interior s) x) {v w : E} (hv : x + v âˆˆ interior s) (hw : x + v + w âˆˆ interior s) : (Î» (h : â„), f (x + h â€¢ v + h â€¢ w) - f (x + h â€¢ v) - h â€¢ â‡‘(f' x) w - h ^ 2 â€¢ â‡‘(â‡‘f'' v) w - (h ^ 2 / 2) â€¢ â‡‘(â‡‘f'' w) w) =o[nhds_within 0 (set.Ioi 0)] Î» (h : â„), h ^ 2
theorem charted_space_self_atlas {H : Type u_1} [topological_space H] {e : local_homeomorph H H} : e âˆˆ charted_space.atlas H H â†” e = local_homeomorph.refl H
theorem convex_hull_eq_union_convex_hull_finite_subsets {R : Type u_1} {E : Type u_2} [linear_ordered_field R] [add_comm_group E] [module R E] (s : set E) : â‡‘(convex_hull R) s = â‹ƒ (t : finset E) (w : â†‘t âŠ† s), â‡‘(convex_hull R) â†‘t
theorem category_theory.abelian.is_iso_of_is_iso_of_is_iso_of_is_iso_of_is_iso {V : Type u} [category_theory.category V] [category_theory.abelian V] {A B C D A' B' C' D' : V} {f : A âŸ¶ B} {g : B âŸ¶ C} {h : C âŸ¶ D} {f' : A' âŸ¶ B'} {g' : B' âŸ¶ C'} {h' : C' âŸ¶ D'} {Î± : A âŸ¶ A'} {Î² : B âŸ¶ B'} {Î³ : C âŸ¶ C'} {Î´ : D âŸ¶ D'} (commâ‚ : Î± â‰« f' = f â‰« Î²) (commâ‚‚ : Î² â‰« g' = g â‰« Î³) (commâ‚ƒ : Î³ â‰« h' = h â‰« Î´) {E E' : V} {i : D âŸ¶ E} {i' : D' âŸ¶ E'} {Îµ : E âŸ¶ E'} (commâ‚„ : Î´ â‰« i' = i â‰« Îµ) (hfg : category_theory.exact f g) (hgh : category_theory.exact g h) (hhi : category_theory.exact h i) (hf'g' : category_theory.exact f' g') (hg'h' : category_theory.exact g' h') (hh'i' : category_theory.exact h' i') [category_theory.is_iso Î±] [category_theory.is_iso Î²] [category_theory.is_iso Î´] [category_theory.is_iso Îµ] : category_theory.is_iso Î³
theorem category_theory.limits.has_finite_wide_pullbacks_of_has_finite_limits (C : Type u) [category_theory.category C] [category_theory.limits.has_finite_limits C] : category_theory.limits.has_finite_wide_pullbacks C
theorem measure_theory.tendsto_Lp_of_tendsto_ae {Î± : Type u_1} {Î² : Type u_2} {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) [normed_group Î²] {p : ennreal} [measure_theory.is_finite_measure Î¼] (hp : 1 â‰¤ p) (hp' : p â‰  âŠ¤) {f : â„• â†’ Î± â†’ Î²} {g : Î± â†’ Î²} (hf : âˆ€ (n : â„•), measure_theory.ae_strongly_measurable (f n) Î¼) (hg : measure_theory.mem_â„’p g p Î¼) (hui : measure_theory.unif_integrable f p Î¼) (hfg : âˆ€áµ (x : Î±) âˆ‚Î¼, filter.tendsto (Î» (n : â„•), f n x) filter.at_top (nhds (g x))) : filter.tendsto (Î» (n : â„•), measure_theory.snorm (f n - g) p Î¼) filter.at_top (nhds 0)
theorem finset.nat.mem_antidiagonal {n : â„•} {x : â„• Ã— â„•} : x âˆˆ finset.nat.antidiagonal n â†” x.fst + x.snd = n
theorem witt_vector.lift_unique {p : â„•} [hp : fact (nat.prime p)] {R : Type u_1} [comm_ring R] {S : Type u_2} [semiring S] {f : Î  (k : â„•), S â†’+* truncated_witt_vector p k R} (f_compat : âˆ€ (kâ‚ kâ‚‚ : â„•) (hk : kâ‚ â‰¤ kâ‚‚), (truncated_witt_vector.truncate hk).comp (f kâ‚‚) = f kâ‚) (g : S â†’+* witt_vector p R) (g_compat : âˆ€ (k : â„•), (witt_vector.truncate k).comp g = f k) : witt_vector.lift (Î» (kâ‚‚ : â„•), f kâ‚‚) f_compat = g
theorem interval_integral.integral_comp_smul_deriv {E : Type u_3} [normed_group E] [complete_space E] [normed_space â„ E] {a b : â„} {f f' : â„ â†’ â„} {g : â„ â†’ E} (h : âˆ€ (x : â„), x âˆˆ set.interval a b â†’ has_deriv_at f (f' x) x) (h' : continuous_on f' (set.interval a b)) (hg : continuous g) : âˆ« (x : â„) in a..b, f' x â€¢ (g âˆ˜ f) x = âˆ« (x : â„) in f a..f b, g x
theorem ordered_smul.mk' {k : Type u_1} {M : Type u_2} [linear_ordered_field k] [ordered_add_comm_monoid M] [mul_action_with_zero k M] (hlt : âˆ€ â¦ƒa b : Mâ¦„ â¦ƒc : kâ¦„, a < b â†’ 0 < c â†’ c â€¢ a â‰¤ c â€¢ b) : ordered_smul k M
theorem continuous_on.measurable_embedding {Î³ : Type u_3} [tÎ³ : topological_space Î³] [polish_space Î³] [measurable_space Î³] [borel_space Î³] {Î² : Type u_4} [tÎ² : topological_space Î²] [t2_space Î²] [measurable_space Î²] [borel_space Î²] {s : set Î³} {f : Î³ â†’ Î²} (hs : measurable_set s) (f_cont : continuous_on f s) (f_inj : set.inj_on f s) : measurable_embedding (s.restrict f)
theorem liouville.exists_one_le_pow_mul_dist {Z : Type u_1} {N : Type u_2} {R : Type u_3} [pseudo_metric_space R] {d : N â†’ â„} {j : Z â†’ N â†’ R} {f : R â†’ R} {Î± : R} {Îµ M : â„} (d0 : âˆ€ (a : N), 1 â‰¤ d a) (e0 : 0 < Îµ) (B : âˆ€ â¦ƒy : Râ¦„, y âˆˆ metric.closed_ball Î± Îµ â†’ has_dist.dist (f Î±) (f y) â‰¤ has_dist.dist Î± y * M) (L : âˆ€ â¦ƒz : Zâ¦„ â¦ƒa : Nâ¦„, j z a âˆˆ metric.closed_ball Î± Îµ â†’ 1 â‰¤ d a * has_dist.dist (f Î±) (f (j z a))) : âˆƒ (A : â„), 0 < A âˆ§ âˆ€ (z : Z) (a : N), 1 â‰¤ d a * (has_dist.dist Î± (j z a) * A)
theorem polynomial.nat_degree_multiset_prod' {R : Type u} [comm_semiring R] (t : multiset (polynomial R)) (h : (multiset.map (Î» (f : polynomial R), f.leading_coeff) t).prod â‰  0) : t.prod.nat_degree = (multiset.map (Î» (f : polynomial R), f.nat_degree) t).sum
theorem set.exists_is_open_lt_of_lt {Î± : Type u_1} [measurable_space Î±] [topological_space Î±] {Î¼ : measure_theory.measure Î±} [Î¼.outer_regular] (A : set Î±) (r : ennreal) (hr : â‡‘Î¼ A < r) : âˆƒ (U : set Î±) (H : U âŠ‡ A), is_open U âˆ§ â‡‘Î¼ U < r
theorem lie_algebra.nilpotent_of_nilpotent_quotient {R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] {I : lie_ideal R L} (hâ‚ : I â‰¤ lie_algebra.center R L) (hâ‚‚ : lie_algebra.is_nilpotent R (L â§¸ I)) : lie_algebra.is_nilpotent R L
theorem affine_basis.affine_span_eq_top_of_to_matrix_left_inv {Î¹ : Type uâ‚} {k : Type uâ‚‚} {V : Type uâ‚ƒ} {P : Type uâ‚„} [add_comm_group V] [add_torsor V P] [ring k] [module k V] (b : affine_basis Î¹ k P) {Î¹' : Type u_1} [fintype Î¹'] [fintype Î¹] [decidable_eq Î¹] [nontrivial k] (p : Î¹' â†’ P) {A : matrix Î¹ Î¹' k} (hA : A.mul (b.to_matrix p) = 1) : affine_span k (set.range p) = âŠ¤
theorem finite_dimensional.of_finite_basis {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {Î¹ : Type w} {s : set Î¹} (h : basis â†¥s K V) (hs : s.finite) : finite_dimensional K V
theorem cInf_singleton {Î± : Type u_1} [conditionally_complete_lattice Î±] (a : Î±) : has_Inf.Inf {a} = a
theorem witt_vector.peval_poly_of_interest' (p : â„•) [hp : fact (nat.prime p)] {k : Type u_1} [comm_ring k] [char_p k p] (n : â„•) (x y : witt_vector p k) : witt_vector.peval (witt_vector.poly_of_interest p n) ![Î» (i : â„•), x.coeff i, Î» (i : â„•), y.coeff i] = (x * y).coeff (n + 1) - y.coeff (n + 1) * x.coeff 0 ^ p ^ (n + 1) - x.coeff (n + 1) * y.coeff 0 ^ p ^ (n + 1)
theorem differentiable_on.analytic_at {E : Type u} [normed_group E] [normed_space â„‚ E] [complete_space E] {s : set â„‚} {f : â„‚ â†’ E} {z : â„‚} (hd : differentiable_on â„‚ f s) (hz : s âˆˆ nhds z) : analytic_at â„‚ f z
theorem is_compact.finite_compact_cover {Î± : Type u} [topological_space Î±] [t2_space Î±] {s : set Î±} (hs : is_compact s) {Î¹ : Type u_1} (t : finset Î¹) (U : Î¹ â†’ set Î±) (hU : âˆ€ (i : Î¹), i âˆˆ t â†’ is_open (U i)) (hsC : s âŠ† â‹ƒ (i : Î¹) (H : i âˆˆ t), U i) : âˆƒ (K : Î¹ â†’ set Î±), (âˆ€ (i : Î¹), is_compact (K i)) âˆ§ (âˆ€ (i : Î¹), K i âŠ† U i) âˆ§ s = â‹ƒ (i : Î¹) (H : i âˆˆ t), K i
theorem convex_on.le_on_segment {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [ordered_semiring ğ•œ] [add_comm_monoid E] [linear_ordered_add_comm_monoid Î²] [has_scalar ğ•œ E] [module ğ•œ Î²] [ordered_smul ğ•œ Î²] {s : set E} {f : E â†’ Î²} (hf : convex_on ğ•œ s f) {x y z : E} (hx : x âˆˆ s) (hy : y âˆˆ s) (hz : z âˆˆ segment ğ•œ x y) : f z â‰¤ linear_order.max (f x) (f y)
theorem diff_cont_on_cl.circle_integral_sub_inv_smul {E : Type u} [normed_group E] [normed_space â„‚ E] [complete_space E] {R : â„} {c w : â„‚} {f : â„‚ â†’ E} (h : diff_cont_on_cl â„‚ f (metric.ball c R)) (hw : w âˆˆ metric.ball c R) : âˆ® (z : â„‚) in C(c, R), (z - w)â»Â¹ â€¢ f z = (2 * â†‘real.pi * complex.I) â€¢ f w
theorem category_theory.abelian.pseudoelement.zero_of_map_zero {C : Type u} [category_theory.category C] [category_theory.abelian C] {P Q : C} (f : P âŸ¶ Q) : function.injective â‡‘f â†’ âˆ€ (a : â†¥P), â‡‘f a = 0 â†’ a = 0
theorem spectrum.zero_eq {ğ•œ : Type u} {A : Type v} [field ğ•œ] [ring A] [algebra ğ•œ A] [nontrivial A] : spectrum ğ•œ 0 = {0}
theorem neg_strict_convex_on_iff {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [ordered_semiring ğ•œ] [add_comm_monoid E] [ordered_add_comm_group Î²] [has_scalar ğ•œ E] [module ğ•œ Î²] {s : set E} {f : E â†’ Î²} : strict_convex_on ğ•œ s (-f) â†” strict_concave_on ğ•œ s f
theorem category_theory.limits.cofork.coequalizer_ext {C : Type u} [category_theory.category C] {X Y : C} {f g : X âŸ¶ Y} (s : category_theory.limits.cofork f g) {W : C} {k l : s.X âŸ¶ W} (h : s.Ï€ â‰« k = s.Ï€ â‰« l) (j : category_theory.limits.walking_parallel_pair) : s.Î¹.app j â‰« k = s.Î¹.app j â‰« l
theorem convex.combo_closure_interior_subset_interior {E : Type u_2} {ğ•œ : Type u_3} [linear_ordered_field ğ•œ] [add_comm_group E] [module ğ•œ E] [topological_space E] [topological_add_group E] [has_continuous_const_smul ğ•œ E] {s : set E} (hs : convex ğ•œ s) {a b : ğ•œ} (ha : 0 â‰¤ a) (hb : 0 < b) (hab : a + b = 1) : a â€¢ closure s + b â€¢ interior s âŠ† interior s
theorem euclidean_geometry.reflection_symm {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] (s : affine_subspace â„ P) [nonempty â†¥s] [complete_space â†¥(s.direction)] : (euclidean_geometry.reflection s).symm = euclidean_geometry.reflection s
theorem bornology.is_vonN_bounded.subset {ğ•œ : Type u_1} {E : Type u_2} [semi_normed_ring ğ•œ] [has_scalar ğ•œ E] [has_zero E] [topological_space E] {sâ‚ sâ‚‚ : set E} (h : sâ‚ âŠ† sâ‚‚) (hsâ‚‚ : bornology.is_vonN_bounded ğ•œ sâ‚‚) : bornology.is_vonN_bounded ğ•œ sâ‚
theorem is_regular_iff_subsingleton {R : Type u_1} [mul_zero_class R] : is_regular 0 â†” subsingleton R
theorem asymptotics.is_o_iff_forall_is_O_with {Î± : Type u_1} {E : Type u_3} {F : Type u_4} [has_norm E] [has_norm F] {f : Î± â†’ E} {g : Î± â†’ F} {l : filter Î±} : f =o[l] g â†” âˆ€ â¦ƒc : â„â¦„, 0 < c â†’ asymptotics.is_O_with c l f g
theorem strict_mono_on.continuous_at_left_of_surj_on {Î± : Type u_1} {Î² : Type u_2} [linear_order Î±] [topological_space Î±] [order_topology Î±] [linear_order Î²] [topological_space Î²] [order_topology Î²] {f : Î± â†’ Î²} {s : set Î±} {a : Î±} (h_mono : strict_mono_on f s) (hs : s âˆˆ nhds_within a (set.Iic a)) (hfs : set.surj_on f s (set.Iio (f a))) : continuous_within_at f (set.Iic a) a
theorem continuous_map.homotopy.apply_one_path {X Y : Top} {f g : C(â†¥X, â†¥Y)} (H : f.homotopy g) {xâ‚€ xâ‚ : â†¥X} (p : fundamental_groupoid.from_top xâ‚€ âŸ¶ fundamental_groupoid.from_top xâ‚) : (fundamental_groupoid.fundamental_groupoid_functor.map g).map p = continuous_map.homotopy.hcast _ â‰« (fundamental_groupoid.fundamental_groupoid_functor.map H.ulift_map).map (continuous_map.homotopy.prod_to_prod_Top_I (ğŸ™ {down := 1}) p) â‰« continuous_map.homotopy.hcast _
theorem orthonormal.oangle_eq_iff_eq_norm_div_norm_smul_rotation_or_eq_zero {V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) {x y : V} (Î¸ : real.angle) : hb.oangle x y = Î¸ â†” x â‰  0 âˆ§ y â‰  0 âˆ§ y = (âˆ¥yâˆ¥ / âˆ¥xâˆ¥) â€¢ â‡‘(hb.rotation Î¸) x âˆ¨ Î¸ = 0 âˆ§ (x = 0 âˆ¨ y = 0)
theorem basis.ext_linear_isometry {R : Type u_1} {Râ‚‚ : Type u_2} {E : Type u_5} {Eâ‚‚ : Type u_6} [semiring R] [semiring Râ‚‚] {Ïƒâ‚â‚‚ : R â†’+* Râ‚‚} [semi_normed_group E] [semi_normed_group Eâ‚‚] [module R E] [module Râ‚‚ Eâ‚‚] {Î¹ : Type u_3} (b : basis Î¹ R E) {fâ‚ fâ‚‚ : E â†’â‚›â‚—áµ¢[Ïƒâ‚â‚‚] Eâ‚‚} (h : âˆ€ (i : Î¹), â‡‘fâ‚ (â‡‘b i) = â‡‘fâ‚‚ (â‡‘b i)) : fâ‚ = fâ‚‚
theorem mem_tangent_cone_of_open_segment_subset {G : Type u_4} [normed_group G] [normed_space â„ G] {s : set G} {x y : G} (h : open_segment â„ x y âŠ† s) : y - x âˆˆ tangent_cone_at â„ s x
theorem convolution_assoc {ğ•œ : Type u_1} {G : Type u_2} {E : Type u_3} {E' : Type u_4} {E'' : Type u_5} {F : Type u_6} {F' : Type u_7} {F'' : Type u_8} [normed_group E] [normed_group E'] [normed_group E''] [normed_group F] {f : G â†’ E} {g : G â†’ E'} [is_R_or_C ğ•œ] [normed_space ğ•œ E] [normed_space ğ•œ E'] [normed_space ğ•œ E''] [normed_space â„ F] [normed_space ğ•œ F] [complete_space F] [measurable_space G] {Î¼ : measure_theory.measure G} (L : E â†’L[ğ•œ] E' â†’L[ğ•œ] F) [normed_group F'] [normed_space â„ F'] [normed_space ğ•œ F'] [complete_space F'] [normed_group F''] [normed_space â„ F''] [normed_space ğ•œ F''] [complete_space F''] {k : G â†’ E''} (Lâ‚‚ : F â†’L[ğ•œ] E'' â†’L[ğ•œ] F') (Lâ‚ƒ : E â†’L[ğ•œ] F'' â†’L[ğ•œ] F') (Lâ‚„ : E' â†’L[ğ•œ] E'' â†’L[ğ•œ] F'') [add_group G] [has_measurable_add G] [measure_theory.sigma_finite Î¼] {Î½ : measure_theory.measure G} [measure_theory.sigma_finite Î½] [Î½.is_add_right_invariant] (hL : âˆ€ (x : E) (y : E') (z : E''), â‡‘(â‡‘Lâ‚‚ (â‡‘(â‡‘L x) y)) z = â‡‘(â‡‘Lâ‚ƒ x) (â‡‘(â‡‘Lâ‚„ y) z)) {xâ‚€ : G} (hâ‚„ : convolution_exists g k Lâ‚„ Î½) (hâ‚ : convolution_exists f g L Î¼) (hi : measure_theory.integrable (function.uncurry (Î» (x y : G), â‡‘(â‡‘Lâ‚ƒ (f y)) (â‡‘(â‡‘Lâ‚„ (g (x - y))) (k (xâ‚€ - x))))) (Î½.prod Î¼)) : convolution (convolution f g L Î¼) k Lâ‚‚ Î½ xâ‚€ = convolution f (convolution g k Lâ‚„ Î½) Lâ‚ƒ Î¼ xâ‚€
theorem category_theory.limits.complete_lattice.pushout_eq_sup {Î± : Type u} [semilattice_sup Î±] [order_bot Î±] (x y z : Î±) (f : z âŸ¶ x) (g : z âŸ¶ y) : category_theory.limits.pushout f g = x âŠ” y
theorem con.con_gen_of_con {M : Type u_1} [has_mul M] (c : con M) : con_gen â‡‘c = c
theorem linear_independent.fin_cons {K : Type u_4} {V : Type u} [division_ring K] [add_comm_group V] [module K V] {x : V} {n : â„•} {v : fin n â†’ V} (hv : linear_independent K v) (hx : x âˆ‰ submodule.span K (set.range v)) : linear_independent K (fin.cons x v)
theorem orthonormal.inner_finsupp_eq_sum_left {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {Î¹ : Type u_4} {v : Î¹ â†’ E} (hv : orthonormal ğ•œ v) (lâ‚ lâ‚‚ : Î¹ â†’â‚€ ğ•œ) : has_inner.inner (â‡‘(finsupp.total Î¹ E ğ•œ v) lâ‚) (â‡‘(finsupp.total Î¹ E ğ•œ v) lâ‚‚) = lâ‚.sum (Î» (i : Î¹) (y : ğ•œ), â‡‘(star_ring_end ğ•œ) y * â‡‘lâ‚‚ i)
theorem add_lt_add {Î± : Type u_1} [has_add Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_lt.lt] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b c d : Î±} (hâ‚ : a < b) (hâ‚‚ : c < d) : a + c < b + d
theorem is_cyclotomic_extension.iff_singleton (n : â„•+) (A : Type u) (B : Type v) [comm_ring A] [comm_ring B] [algebra A B] : is_cyclotomic_extension {n} A B â†” (âˆƒ (r : B), â‡‘(polynomial.aeval r) (polynomial.cyclotomic â†‘n A) = 0) âˆ§ âˆ€ (x : B), x âˆˆ algebra.adjoin A {b : B | b ^ â†‘n = 1}
theorem metric.inf_dist_image {Î± : Type u} {Î² : Type v} [pseudo_metric_space Î±] [pseudo_metric_space Î²] {t : set Î±} {x : Î±} {Î¦ : Î± â†’ Î²} (hÎ¦ : isometry Î¦) : metric.inf_dist (Î¦ x) (Î¦ '' t) = metric.inf_dist x t
theorem filter.frequently.mem_closure {Î± : Type u} [topological_space Î±] {s : set Î±} {a : Î±} : (âˆƒá¶  (x : Î±) in nhds a, x âˆˆ s) â†’ a âˆˆ closure s
theorem category_theory.limits.has_finite_products_of_has_products (C : Type u) [category_theory.category C] [category_theory.limits.has_products C] : category_theory.limits.has_finite_products C
theorem continuous.image_connected_component_eq_singleton {Î± : Type u} [topological_space Î±] {Î² : Type u_1} [topological_space Î²] [totally_disconnected_space Î²] {f : Î± â†’ Î²} (h : continuous f) (a : Î±) : f '' connected_component a = {f a}
theorem holor.slice_eq {Î± : Type} {d : â„•} {ds : list â„•} (x y : holor Î± (d :: ds)) (h : x.slice = y.slice) : x = y
theorem euclidean_geometry.eq_of_dist_eq_of_dist_eq_of_finrank_eq_two {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] [finite_dimensional â„ V] (hd : finite_dimensional.finrank â„ V = 2) {câ‚ câ‚‚ pâ‚ pâ‚‚ p : P} {râ‚ râ‚‚ : â„} (hc : câ‚ â‰  câ‚‚) (hp : pâ‚ â‰  pâ‚‚) (hpâ‚câ‚ : has_dist.dist pâ‚ câ‚ = râ‚) (hpâ‚‚câ‚ : has_dist.dist pâ‚‚ câ‚ = râ‚) (hpcâ‚ : has_dist.dist p câ‚ = râ‚) (hpâ‚câ‚‚ : has_dist.dist pâ‚ câ‚‚ = râ‚‚) (hpâ‚‚câ‚‚ : has_dist.dist pâ‚‚ câ‚‚ = râ‚‚) (hpcâ‚‚ : has_dist.dist p câ‚‚ = râ‚‚) : p = pâ‚ âˆ¨ p = pâ‚‚
theorem riesz_lemma {ğ•œ : Type u_1} [normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : subspace ğ•œ E} (hFc : is_closed â†‘F) (hF : âˆƒ (x : E), x âˆ‰ F) {r : â„} (hr : r < 1) : âˆƒ (xâ‚€ : E), xâ‚€ âˆ‰ F âˆ§ âˆ€ (y : E), y âˆˆ F â†’ r * âˆ¥xâ‚€âˆ¥ â‰¤ âˆ¥xâ‚€ - yâˆ¥
theorem is_artinian.disjoint_partial_infs_eventually_top {R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] [I : is_artinian R M] (f : â„• â†’ submodule R M) (h : âˆ€ (n : â„•), disjoint (â‡‘(partial_sups (â‡‘order_dual.to_dual âˆ˜ f)) n) (â‡‘order_dual.to_dual (f (n + 1)))) : âˆƒ (n : â„•), âˆ€ (m : â„•), n â‰¤ m â†’ f m = âŠ¤
theorem euclidean_geometry.exists_circumradius_eq_of_cospherical_subset {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace â„ P} {ps : set P} (h : ps âŠ† â†‘s) [nonempty â†¥s] {n : â„•} [finite_dimensional â„ â†¥(s.direction)] (hd : finite_dimensional.finrank â„ â†¥(s.direction) = n) (hc : euclidean_geometry.cospherical ps) : âˆƒ (r : â„), âˆ€ (sx : affine.simplex â„ P n), set.range sx.points âŠ† ps â†’ sx.circumradius = r
theorem ordered_comm_group.le_of_mul_le_mul_left {Î± : Type u_1} [has_mul Î±] [has_le Î±] [contravariant_class Î± Î± has_mul.mul has_le.le] {a b c : Î±} (bc : a * b â‰¤ a * c) : b â‰¤ c
theorem category_theory.grothendieck_topology.arrow_stable {C : Type u} [category_theory.category C] {X Y : C} (J : category_theory.grothendieck_topology C) (f : Y âŸ¶ X) (S : category_theory.sieve X) (h : J.covers S f) {Z : C} (g : Z âŸ¶ Y) : J.covers S (g â‰« f)
theorem finset.sum_congr_set {Î± : Type u_1} [add_comm_monoid Î±] {Î² : Type u_2} [fintype Î²] (s : set Î²) [decidable_pred (Î» (_x : Î²), _x âˆˆ s)] (f : Î² â†’ Î±) (g : â†¥s â†’ Î±) (w : âˆ€ (x : Î²) (h : x âˆˆ s), f x = g âŸ¨x, hâŸ©) (w' : âˆ€ (x : Î²), x âˆ‰ s â†’ f x = 0) : finset.univ.sum f = finset.univ.sum g
theorem charpoly_left_mul_matrix {K : Type u_1} {S : Type u_2} [field K] [comm_ring S] [algebra K S] (h : power_basis K S) : (â‡‘(algebra.left_mul_matrix h.basis) h.gen).charpoly = minpoly K h.gen
theorem nat.prime_divisors_eq_to_filter_divisors_prime (n : â„•) : n.factors.to_finset = finset.filter nat.prime n.divisors
theorem tensor_product.span_tmul_eq_top (R : Type u_1) [comm_semiring R] (M : Type u_4) (N : Type u_5) [add_comm_monoid M] [add_comm_monoid N] [module R M] [module R N] : submodule.span R {t : tensor_product R M N | âˆƒ (m : M) (n : N), m âŠ—â‚œ[R] n = t} = âŠ¤
theorem metric.diam_empty {Î± : Type u} [pseudo_metric_space Î±] : metric.diam âˆ… = 0
theorem ring_hom.eq_on_sclosure {R : Type u} {S : Type v} [non_assoc_semiring R] [non_assoc_semiring S] {f g : R â†’+* S} {s : set R} (h : set.eq_on â‡‘f â‡‘g s) : set.eq_on â‡‘f â‡‘g â†‘(subsemiring.closure s)
theorem dense_range.separable_space {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space.separable_space Î±] [topological_space Î²] {f : Î± â†’ Î²} (h : dense_range f) (h' : continuous f) : topological_space.separable_space Î²
theorem zmod.pow_card_sub_one_eq_one {p : â„•} [fact (nat.prime p)] {a : zmod p} (ha : a â‰  0) : a ^ (p - 1) = 1
theorem ideal.radical_eq_jacobson_iff_radical_quotient_eq_jacobson_bot {R : Type u} [comm_ring R] {I : ideal R} : I.radical = I.jacobson â†” âŠ¥.radical = âŠ¥.jacobson
theorem category_theory.is_preconnected_of_equivalent {J : Type uâ‚} [category_theory.category J] {K : Type uâ‚} [category_theory.category K] [category_theory.is_preconnected J] (e : J â‰Œ K) : category_theory.is_preconnected K
theorem topological_add_group.continuous_conj_sum {G : Type w} [topological_space G] [has_neg G] [has_add G] [has_continuous_add G] [has_continuous_neg G] : continuous (Î» (g : G Ã— G), g.fst + g.snd + -g.fst)
theorem set.ord_connected_iff {Î± : Type u_1} [preorder Î±] {s : set Î±} : s.ord_connected â†” âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (y : Î±), y âˆˆ s â†’ x â‰¤ y â†’ set.Icc x y âŠ† s
theorem subgroup.closure_induction' {G : Type u_1} [group G] {k : set G} {p : Î  (x : G), x âˆˆ subgroup.closure k â†’ Prop} (Hs : âˆ€ (x : G) (h : x âˆˆ k), p x _) (H1 : p 1 _) (Hmul : âˆ€ (x : G) (hx : x âˆˆ subgroup.closure k) (y : G) (hy : y âˆˆ subgroup.closure k), p x hx â†’ p y hy â†’ p (x * y) _) (Hinv : âˆ€ (x : G) (hx : x âˆˆ subgroup.closure k), p x hx â†’ p xâ»Â¹ _) {x : G} (hx : x âˆˆ subgroup.closure k) : p x hx
theorem summable_geometric_iff_norm_lt_1 {K : Type u_4} [normed_field K] {Î¾ : K} : summable (Î» (n : â„•), Î¾ ^ n) â†” âˆ¥Î¾âˆ¥ < 1
theorem submodule.quotient_torsion.torsion_eq_bot {R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] : submodule.torsion R (M â§¸ submodule.torsion R M) = âŠ¥
theorem subfield.add_mem {K : Type u} [field K] (s : subfield K) {x y : K} : x âˆˆ s â†’ y âˆˆ s â†’ x + y âˆˆ s
theorem module.projective_lifting_property {R : Type u} [semiring R] {P : Type (max u v)} [add_comm_monoid P] [module R P] {M : Type (max u v)} [add_comm_group M] [module R M] {N : Type u_1} [add_comm_group N] [module R N] [h : module.projective R P] (f : M â†’â‚—[R] N) (g : P â†’â‚—[R] N) (hf : function.surjective â‡‘f) : âˆƒ (h : P â†’â‚—[R] M), f.comp h = g
theorem zpow_eq_zpow_iff' {Î± : Type u_1} [linear_ordered_comm_group Î±] {n : â„¤} {a b : Î±} (hn : n â‰  0) : a ^ n = b ^ n â†” a = b
theorem measure_theory.measure.sum_smul_dirac {Î± : Type u_1} {m0 : measurable_space Î±} [encodable Î±] [measurable_singleton_class Î±] (Î¼ : measure_theory.measure Î±) : measure_theory.measure.sum (Î» (a : Î±), â‡‘Î¼ {a} â€¢ measure_theory.measure.dirac a) = Î¼
theorem matrix.is_hermitian_from_blocks_iff {Î± : Type u_1} {m : Type u_3} {n : Type u_4} [non_unital_semiring Î±] [star_ring Î±] {A : matrix m m Î±} {B : matrix m n Î±} {C : matrix n m Î±} {D : matrix n n Î±} : (matrix.from_blocks A B C D).is_hermitian â†” A.is_hermitian âˆ§ B.conj_transpose = C âˆ§ C.conj_transpose = B âˆ§ D.is_hermitian
theorem finsupp.comap_domain_add_of_injective {Î± : Type u_1} {Î² : Type u_2} {M : Type u_5} [add_zero_class M] {f : Î± â†’ Î²} (hf : function.injective f) (vâ‚ vâ‚‚ : Î² â†’â‚€ M) : finsupp.comap_domain f (vâ‚ + vâ‚‚) _ = finsupp.comap_domain f vâ‚ _ + finsupp.comap_domain f vâ‚‚ _
theorem con.sup_def {M : Type u_1} [has_mul M] {c d : con M} : c âŠ” d = con_gen (setoid.r âŠ” setoid.r)
theorem has_deriv_within_at.Iio_of_Iic {ğ•œ : Type u} [nondiscrete_normed_field ğ•œ] {F : Type v} [normed_group F] [normed_space ğ•œ F] {f : ğ•œ â†’ F} {f' : F} {x : ğ•œ} [partial_order ğ•œ] : has_deriv_within_at f f' (set.Iic x) x â†’ has_deriv_within_at f f' (set.Iio x) x
theorem multiset.nat.card_antidiagonal (n : â„•) : â‡‘multiset.card (multiset.nat.antidiagonal n) = n + 1
theorem exists_measurable_piecewise_nat {Î± : Type u_1} {Î² : Type u_2} {mÎ² : measurable_space Î²} {m : measurable_space Î±} (t : â„• â†’ set Î²) (t_meas : âˆ€ (n : â„•), measurable_set (t n)) (t_disj : pairwise (disjoint on t)) (g : â„• â†’ Î² â†’ Î±) (hg : âˆ€ (n : â„•), measurable (g n)) : âˆƒ (f : Î² â†’ Î±), measurable f âˆ§ âˆ€ (n : â„•) (x : Î²), x âˆˆ t n â†’ f x = g n x
theorem has_fpower_series_on_ball.tendsto_uniformly_on {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field ğ•œ] [normed_group E] [normed_space ğ•œ E] [normed_group F] [normed_space ğ•œ F] {f : E â†’ F} {p : formal_multilinear_series ğ•œ E F} {x : E} {r : ennreal} {r' : nnreal} (hf : has_fpower_series_on_ball f p x r) (h : â†‘r' < r) : tendsto_uniformly_on (Î» (n : â„•) (y : E), p.partial_sum n y) (Î» (y : E), f (x + y)) filter.at_top (metric.ball 0 â†‘r')
theorem equiv.is_empty_congr {Î± : Sort u} {Î² : Sort v} (e : Î± â‰ƒ Î²) : is_empty Î± â†” is_empty Î²
theorem add_con.sup_def {M : Type u_1} [has_add M] {c d : add_con M} : c âŠ” d = add_con_gen (setoid.r âŠ” setoid.r)
theorem submonoid.subsemiring_closure_eq_closure {R : Type u} [non_assoc_semiring R] (M : submonoid R) : M.subsemiring_closure = subsemiring.closure â†‘M
theorem measure_theory.ae_interval_oc_iff {Î± : Type u_1} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [linear_order Î±] {a b : Î±} {P : Î± â†’ Prop} : (âˆ€áµ (x : Î±) âˆ‚Î¼, x âˆˆ set.interval_oc a b â†’ P x) â†” (âˆ€áµ (x : Î±) âˆ‚Î¼, x âˆˆ set.Ioc a b â†’ P x) âˆ§ âˆ€áµ (x : Î±) âˆ‚Î¼, x âˆˆ set.Ioc b a â†’ P x
theorem submodule.is_compl_orthogonal_of_complete_space {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {K : submodule ğ•œ E} [complete_space â†¥K] : is_compl K Ká—®
theorem finsupp.add_hom_ext {Î± : Type u_1} {M : Type u_5} {N : Type u_7} [add_zero_class M] [add_zero_class N] â¦ƒf g : (Î± â†’â‚€ M) â†’+ Nâ¦„ (H : âˆ€ (x : Î±) (y : M), â‡‘f (finsupp.single x y) = â‡‘g (finsupp.single x y)) : f = g
theorem apply_ite {Î± : Sort u_1} {Î² : Sort u_2} (f : Î± â†’ Î²) (P : Prop) [decidable P] (a b : Î±) : f (ite P a b) = ite P (f a) (f b)
theorem interval_integral.integral_eq_sub_of_has_deriv_right_of_le_real {a b : â„} {g' g : â„ â†’ â„} (hab : a â‰¤ b) (hcont : continuous_on g (set.Icc a b)) (hderiv : âˆ€ (x : â„), x âˆˆ set.Ioo a b â†’ has_deriv_within_at g (g' x) (set.Ioi x) x) (g'int : measure_theory.integrable_on g' (set.Icc a b) measure_theory.measure_space.volume) : âˆ« (y : â„) in a..b, g' y = g b - g a
theorem padic_norm.padic_norm_p {p : â„•} (hp : 1 < p) : padic_norm p â†‘p = 1 / â†‘p
theorem basis.ext_linear_isometry_equiv {R : Type u_1} {Râ‚‚ : Type u_2} {E : Type u_5} {Eâ‚‚ : Type u_6} [semiring R] [semiring Râ‚‚] {Ïƒâ‚â‚‚ : R â†’+* Râ‚‚} {Ïƒâ‚‚â‚ : Râ‚‚ â†’+* R} [ring_hom_inv_pair Ïƒâ‚â‚‚ Ïƒâ‚‚â‚] [ring_hom_inv_pair Ïƒâ‚‚â‚ Ïƒâ‚â‚‚] [semi_normed_group E] [semi_normed_group Eâ‚‚] [module R E] [module Râ‚‚ Eâ‚‚] {Î¹ : Type u_3} (b : basis Î¹ R E) {fâ‚ fâ‚‚ : E â‰ƒâ‚›â‚—áµ¢[Ïƒâ‚â‚‚] Eâ‚‚} (h : âˆ€ (i : Î¹), â‡‘fâ‚ (â‡‘b i) = â‡‘fâ‚‚ (â‡‘b i)) : fâ‚ = fâ‚‚
theorem linear_map.eq_on_span {R : Type u_1} {Râ‚‚ : Type u_2} {M : Type u_4} {Mâ‚‚ : Type u_5} [semiring R] [add_comm_monoid M] [module R M] [semiring Râ‚‚] [add_comm_monoid Mâ‚‚] [module Râ‚‚ Mâ‚‚] {Ïƒâ‚â‚‚ : R â†’+* Râ‚‚} {s : set M} {f g : M â†’â‚›â‚—[Ïƒâ‚â‚‚] Mâ‚‚} (H : set.eq_on â‡‘f â‡‘g s) â¦ƒx : Mâ¦„ (h : x âˆˆ submodule.span R s) : â‡‘f x = â‡‘g x
theorem zmod.nat_cast_comp_val {n : â„•} (R : Type u_1) [ring R] [fact (0 < n)] : coe âˆ˜ zmod.val = coe
theorem has_ftaylor_series_up_to_on.congr {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {s : set E} {f fâ‚ : E â†’ F} {n : with_top â„•} {p : E â†’ formal_multilinear_series ğ•œ E F} (h : has_ftaylor_series_up_to_on n f p s) (hâ‚ : âˆ€ (x : E), x âˆˆ s â†’ fâ‚ x = f x) : has_ftaylor_series_up_to_on n fâ‚ p s
theorem add_monoid_hom.lipschitz_of_bound {E : Type u_3} {F : Type u_4} [semi_normed_group E] [semi_normed_group F] (f : E â†’+ F) (C : â„) (h : âˆ€ (x : E), âˆ¥â‡‘f xâˆ¥ â‰¤ C * âˆ¥xâˆ¥) : lipschitz_with C.to_nnreal â‡‘f
theorem measure_theory.measure.rn_deriv_lt_top {Î± : Type u_1} {m : measurable_space Î±} (Î¼ Î½ : measure_theory.measure Î±) [measure_theory.sigma_finite Î¼] : âˆ€áµ (x : Î±) âˆ‚Î½, Î¼.rn_deriv Î½ x < âŠ¤
theorem ideal.map_le_comap_of_inverse {R : Type u} {S : Type v} [semiring R] [semiring S] (f : R â†’+* S) (g : S â†’+* R) (I : ideal R) (h : function.left_inverse â‡‘g â‡‘f) : ideal.map f I â‰¤ ideal.comap g I
theorem category_theory.presieve.is_sheaf_for.unique_extend {C : Type uâ‚} [category_theory.category C] {X : C} {S : category_theory.sieve X} {P : Cáµ’áµ– â¥¤ Type vâ‚} (h : category_theory.presieve.is_sheaf_for P â‡‘S) {f : S.functor âŸ¶ P} (t : category_theory.yoneda.obj X âŸ¶ P) (ht : S.functor_inclusion â‰« t = f) : t = h.extend f
theorem convex_hull_ediam {E : Type u_2} [semi_normed_group E] [normed_space â„ E] (s : set E) : emetric.diam (â‡‘(convex_hull â„) s) = emetric.diam s
theorem Class.iota_ex (p : Set â†’ Prop) : Class.iota p âˆˆ Class.univ
theorem quotient_norm_eq_zero_iff {M : Type u_1} [semi_normed_group M] (S : add_subgroup M) (m : M) : âˆ¥â‡‘(quotient_add_group.mk' S) mâˆ¥ = 0 â†” m âˆˆ closure â†‘S
theorem category_theory.sheaf.is_sheaf_for_bind {C : Type u} [category_theory.category C] {X : C} (P : Cáµ’áµ– â¥¤ Type v) (U : category_theory.sieve X) (B : Î  â¦ƒY : Câ¦„ â¦ƒf : Y âŸ¶ Xâ¦„, â‡‘U f â†’ category_theory.sieve Y) (hU : category_theory.presieve.is_sheaf_for P â‡‘U) (hB : âˆ€ â¦ƒY : Câ¦„ â¦ƒf : Y âŸ¶ Xâ¦„ (hf : â‡‘U f), category_theory.presieve.is_sheaf_for P â‡‘(B hf)) (hB' : âˆ€ â¦ƒY : Câ¦„ â¦ƒf : Y âŸ¶ Xâ¦„ (h : â‡‘U f) â¦ƒZ : Câ¦„ (g : Z âŸ¶ Y), category_theory.presieve.is_separated_for P â‡‘(category_theory.sieve.pullback g (B h))) : category_theory.presieve.is_sheaf_for P â‡‘(category_theory.sieve.bind â‡‘U B)
theorem concave_on.set_average_mem_hypograph {Î± : Type u_1} {E : Type u_2} {m0 : measurable_space Î±} [normed_group E] [normed_space â„ E] [complete_space E] {Î¼ : measure_theory.measure Î±} {s : set E} {t : set Î±} {f : Î± â†’ E} {g : E â†’ â„} (hg : concave_on â„ s g) (hgc : continuous_on g s) (hsc : is_closed s) (h0 : â‡‘Î¼ t â‰  0) (ht : â‡‘Î¼ t â‰  âŠ¤) (hfs : âˆ€áµ (x : Î±) âˆ‚Î¼.restrict t, f x âˆˆ s) (hfi : measure_theory.integrable_on f t Î¼) (hgi : measure_theory.integrable_on (g âˆ˜ f) t Î¼) : (â¨ (x : Î±) in t, f x âˆ‚Î¼, â¨ (x : Î±) in t, g (f x) âˆ‚Î¼) âˆˆ {p : E Ã— â„ | p.fst âˆˆ s âˆ§ p.snd â‰¤ g p.fst}
theorem category_theory.functor.ess_image.of_nat_iso {C : Type uâ‚} {D : Type uâ‚‚} [category_theory.category C] [category_theory.category D] {F F' : C â¥¤ D} (h : F â‰… F') {Y : D} (hY : Y âˆˆ F.ess_image) : Y âˆˆ F'.ess_image
theorem intermediate_field.map_mono {K : Type u_1} {L : Type u_2} {M : Type u_3} [field K] [field L] [field M] [algebra K L] [algebra K M] {E1 E2 : intermediate_field K L} (e : L â‰ƒâ‚[K] M) (h12 : E1 â‰¤ E2) : E1.map e.to_alg_hom â‰¤ E2.map e.to_alg_hom
theorem asymptotics.is_O.norm_right {Î± : Type u_1} {E : Type u_3} {F' : Type u_7} [has_norm E] [semi_normed_group F'] {f : Î± â†’ E} {g' : Î± â†’ F'} {l : filter Î±} : f =O[l] g' â†’ (f =O[l] Î» (x : Î±), âˆ¥g' xâˆ¥)
theorem orthonormal.inner_left_fintype {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {Î¹ : Type u_4} [fintype Î¹] {v : Î¹ â†’ E} (hv : orthonormal ğ•œ v) (l : Î¹ â†’ ğ•œ) (i : Î¹) : has_inner.inner (finset.univ.sum (Î» (i : Î¹), l i â€¢ v i)) (v i) = â‡‘(star_ring_end ğ•œ) (l i)
theorem strict_convex_on_pow {n : â„•} (hn : 2 â‰¤ n) : strict_convex_on â„ (set.Ici 0) (Î» (x : â„), x ^ n)
theorem submodule.fg_of_fg_map_of_fg_inf_ker {R : Type u_1} {M : Type u_2} {P : Type u_3} [ring R] [add_comm_group M] [module R M] [add_comm_group P] [module R P] (f : M â†’â‚—[R] P) {s : submodule R M} (hs1 : (submodule.map f s).fg) (hs2 : (s âŠ“ f.ker).fg) : s.fg
theorem measure_theory.integral_mul_left_eq_self {G : Type u_4} {E : Type u_5} [measurable_space G] [normed_group E] [normed_space â„ E] [complete_space E] {Î¼ : measure_theory.measure G} [group G] [has_measurable_mul G] [Î¼.is_mul_left_invariant] (f : G â†’ E) (g : G) : âˆ« (x : G), f (g * x) âˆ‚Î¼ = âˆ« (x : G), f x âˆ‚Î¼
theorem complete_lattice.independent.subtype_ne_bot_le_finrank {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] {Î¹ : Type w} {p : Î¹ â†’ submodule K V} (hp : complete_lattice.independent p) [fintype {i // p i â‰  âŠ¥}] : fintype.card {i // p i â‰  âŠ¥} â‰¤ finite_dimensional.finrank K V
theorem has_mem.mem.ne_of_not_mem' {Î± : Type u_1} {Î² : Type u_2} [has_mem Î± Î²] {s t : Î²} {a : Î±} : a âˆˆ s â†’ a âˆ‰ t â†’ s â‰  t
theorem add_commute.symm {S : Type u_1} [has_add S] {a b : S} (h : add_commute a b) : add_commute b a
theorem algebra.is_algebraic_trans {K : Type u_1} {L : Type u_2} {A : Type u_5} [field K] [field L] [comm_ring A] [algebra K L] [algebra L A] [algebra K A] [is_scalar_tower K L A] (L_alg : algebra.is_algebraic K L) (A_alg : algebra.is_algebraic L A) : algebra.is_algebraic K A
theorem dense_range_pure {Î± : Type u} : dense_range has_pure.pure
theorem commute.geom_sumâ‚‚_mul_add {Î± : Type u} [semiring Î±] {x y : Î±} (h : commute x y) (n : â„•) : (finset.range n).sum (Î» (i : â„•), (x + y) ^ i * y ^ (n - 1 - i)) * x + y ^ n = (x + y) ^ n
theorem linear_isometry.inner_map_map {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {E' : Type u_7} [inner_product_space ğ•œ E'] (f : E â†’â‚—áµ¢[ğ•œ] E') (x y : E) : has_inner.inner (â‡‘f x) (â‡‘f y) = has_inner.inner x y
theorem bounded_continuous_function.exists_norm_eq_restrict_eq_of_closed {Y : Type u_2} [topological_space Y] [normal_space Y] {s : set Y} (f : bounded_continuous_function â†¥s â„) (hs : is_closed s) : âˆƒ (g : bounded_continuous_function Y â„), âˆ¥gâˆ¥ = âˆ¥fâˆ¥ âˆ§ g.restrict s = f
theorem category_theory.is_iso_of_epi_of_nonzero {C : Type u} [category_theory.category C] [category_theory.abelian C] {X Y : C} [category_theory.simple X] {f : X âŸ¶ Y} [category_theory.epi f] (w : f â‰  0) : category_theory.is_iso f
theorem list.nth_zero_add_tail_sum {M : Type u_3} [add_monoid M] (l : list M) : (l.nth 0).get_or_else 0 + l.tail.sum = l.sum
theorem add_subgroup.vadd_invariant_measure {G : Type u_1} [add_group G] [measurable_space G] [topological_space G] [topological_add_group G] [borel_space G] {Î¼ : measure_theory.measure G} {Î“ : add_subgroup G} [Î¼.is_add_right_invariant] : measure_theory.vadd_invariant_measure â†¥(Î“.opposite) G Î¼
theorem continuous_map.compact_open_eq_Inf_induced {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] : continuous_map.compact_open = â¨… (s : set Î±) (hs : is_compact s), topological_space.induced (continuous_map.restrict s) continuous_map.compact_open
theorem self_adjoint.mem_spectrum_eq_re' {A : Type u_1} [normed_ring A] [normed_algebra â„‚ A] [complete_space A] [star_ring A] [cstar_ring A] [star_module â„‚ A] [nontrivial A] (a : â†¥(self_adjoint A)) {z : â„‚} (hz : z âˆˆ spectrum â„‚ â†‘a) : z = â†‘(z.re)
theorem basis_le_span' {R : Type u} [ring R] [rank_condition R] {M : Type v} [add_comm_group M] [module R M] {Î¹ : Type u_1} (b : basis Î¹ R M) {w : set M} [fintype â†¥w] (s : submodule.span R w = âŠ¤) : cardinal.mk Î¹ â‰¤ â†‘(fintype.card â†¥w)
theorem is_dedekind_domain.height_one_spectrum.valuation_lt_one_iff_dvd {R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] {K : Type u_2} [field K] [algebra R K] [is_fraction_ring R K] (v : is_dedekind_domain.height_one_spectrum R) (r : R) : â‡‘(v.valuation) (â‡‘(algebra_map R K) r) < 1 â†” v.as_ideal âˆ£ ideal.span {r}
theorem disjoint.eq_bot_of_self {Î± : Type u} [semilattice_inf Î±] [order_bot Î±] {a : Î±} : disjoint a a â†’ a = âŠ¥
theorem sq_add_mul_sq_mul_sq_add_mul_sq {R : Type u_1} [comm_ring R] {xâ‚ xâ‚‚ yâ‚ yâ‚‚ n : R} : (xâ‚ ^ 2 + n * xâ‚‚ ^ 2) * (yâ‚ ^ 2 + n * yâ‚‚ ^ 2) = (xâ‚ * yâ‚ - n * xâ‚‚ * yâ‚‚) ^ 2 + n * (xâ‚ * yâ‚‚ + xâ‚‚ * yâ‚) ^ 2
theorem subalgebra.is_field_of_algebraic {K : Type u_3} {L : Type u_4} [field K] [field L] [algebra K L] (A : subalgebra K L) (hKL : algebra.is_algebraic K L) : is_field â†¥A
theorem nnreal.Lp_add_le {Î¹ : Type u} (s : finset Î¹) (f g : Î¹ â†’ nnreal) {p : â„} (hp : 1 â‰¤ p) : s.sum (Î» (i : Î¹), (f i + g i) ^ p) ^ (1 / p) â‰¤ s.sum (Î» (i : Î¹), f i ^ p) ^ (1 / p) + s.sum (Î» (i : Î¹), g i ^ p) ^ (1 / p)
theorem is_add_submonoid.finset_sum_mem {M : Type u_1} {A : Type u_2} [add_comm_monoid M] {s : set M} (hs : is_add_submonoid s) (f : A â†’ M) (t : finset A) : (âˆ€ (b : A), b âˆˆ t â†’ f b âˆˆ s) â†’ t.sum (Î» (b : A), f b) âˆˆ s
theorem measure_theory.signed_measure.subset_negative_null_set {Î± : Type u_1} [measurable_space Î±] {s : measure_theory.signed_measure Î±} {u v w : set Î±} (hu : measurable_set u) (hv : measurable_set v) (hw : measurable_set w) (hsu : measure_theory.vector_measure.restrict s u â‰¤ 0.restrict u) (hwâ‚ : â‡‘s w = 0) (hwâ‚‚ : w âŠ† u) (hwt : v âŠ† w) : â‡‘s v = 0
theorem measure_theory.measure_congr {Î± : Type u_1} [measurable_space Î±] {Î¼ : measure_theory.measure Î±} {s t : set Î±} (H : s =áµ[Î¼] t) : â‡‘Î¼ s = â‡‘Î¼ t
theorem euclidean_geometry.orthogonal_projection_eq_self_iff {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace â„ P} [nonempty â†¥s] [complete_space â†¥(s.direction)] {p : P} : â†‘(â‡‘(euclidean_geometry.orthogonal_projection s) p) = p â†” p âˆˆ s
theorem local_homeomorph.continuous_on_iff_continuous_on_comp_left {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [topological_space Î±] [topological_space Î²] [topological_space Î³] (e : local_homeomorph Î± Î²) {f : Î³ â†’ Î±} {s : set Î³} (h : s âŠ† f â»Â¹' e.to_local_equiv.source) : continuous_on f s â†” continuous_on (â‡‘e âˆ˜ f) s
theorem affine_subspace.inter_nonempty_of_nonempty_of_sup_direction_eq_top {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {s1 s2 : affine_subspace k P} (h1 : â†‘s1.nonempty) (h2 : â†‘s2.nonempty) (hd : s1.direction âŠ” s2.direction = âŠ¤) : (â†‘s1 âˆ© â†‘s2).nonempty
theorem has_subset.subset.trans_ssubset {Î± : Type u} [has_subset Î±] [has_ssubset Î±] [is_nonstrict_strict_order Î± has_subset.subset has_ssubset.ssubset] {a b c : Î±} [is_trans Î± has_subset.subset] (hâ‚ : a âŠ† b) (hâ‚‚ : b âŠ‚ c) : a âŠ‚ c
theorem add_equiv.is_add_monoid_hom {M : Type u_1} {N : Type u_2} [add_zero_class M] [add_zero_class N] (h : M â‰ƒ+ N) : is_add_monoid_hom â‡‘h
theorem has_fderiv_at.comp_has_deriv_at {ğ•œ : Type u} [nondiscrete_normed_field ğ•œ] {F : Type v} [normed_group F] [normed_space ğ•œ F] {E : Type w} [normed_group E] [normed_space ğ•œ E] {f : ğ•œ â†’ F} {f' : F} (x : ğ•œ) {l : F â†’ E} {l' : F â†’L[ğ•œ] E} (hl : has_fderiv_at l l' (f x)) (hf : has_deriv_at f f' x) : has_deriv_at (l âˆ˜ f) (â‡‘l' f') x
theorem probability_theory.lintegral_mul_eq_lintegral_mul_lintegral_of_independent_measurable_space {Î± : Type u_1} {f g : Î± â†’ ennreal} {Mf Mg mÎ± : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (hMf : Mf â‰¤ mÎ±) (hMg : Mg â‰¤ mÎ±) (h_ind : probability_theory.indep Mf Mg Î¼) (h_meas_f : measurable f) (h_meas_g : measurable g) : âˆ«â» (a : Î±), f a * g a âˆ‚Î¼ = âˆ«â» (a : Î±), f a âˆ‚Î¼ * âˆ«â» (a : Î±), g a âˆ‚Î¼
theorem matrix.det_reindex_self {m : Type u_1} {n : Type u_2} [decidable_eq n] [fintype n] [decidable_eq m] [fintype m] {R : Type v} [comm_ring R] (e : m â‰ƒ n) (A : matrix m m R) : (â‡‘(matrix.reindex e e) A).det = A.det
theorem continuous_linear_map.adjoint_adjoint {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] [inner_product_space ğ•œ F] [complete_space E] [complete_space F] (A : E â†’L[ğ•œ] F) : â‡‘continuous_linear_map.adjoint (â‡‘continuous_linear_map.adjoint A) = A
theorem unique_mdiff_within_at.unique_diff_within_at {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {s : set E} {x : E} : unique_mdiff_within_at (model_with_corners_self ğ•œ E) s x â†’ unique_diff_within_at ğ•œ s x
theorem measure_theory.measure.pi_has_no_atoms {Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_3} [fintype Î¹] [Î  (i : Î¹), measurable_space (Î± i)] {Î¼ : Î  (i : Î¹), measure_theory.measure (Î± i)} [âˆ€ (i : Î¹), measure_theory.sigma_finite (Î¼ i)] (i : Î¹) [measure_theory.has_no_atoms (Î¼ i)] : measure_theory.has_no_atoms (measure_theory.measure.pi Î¼)
theorem filter.is_cobounded.mk {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} {f : filter Î±} [is_trans Î± r] (a : Î±) (h : âˆ€ (s : set Î±), s âˆˆ f â†’ (âˆƒ (x : Î±) (H : x âˆˆ s), r a x)) : filter.is_cobounded r f
theorem inner_product_space.is_self_adjoint.has_eigenvector_of_is_min_on {ğ•œ : Type u_1} [is_R_or_C ğ•œ] {E : Type u_2} [inner_product_space ğ•œ E] [complete_space E] {T : E â†’L[ğ•œ] E} (hT : inner_product_space.is_self_adjoint â†‘T) {xâ‚€ : E} (hxâ‚€ : xâ‚€ â‰  0) (hextr : is_min_on T.re_apply_inner_self (metric.sphere 0 âˆ¥xâ‚€âˆ¥) xâ‚€) : module.End.has_eigenvector â†‘T (â†‘â¨… (x : {x // x â‰  0}), (Î» (x : E), T.re_apply_inner_self x / âˆ¥xâˆ¥ ^ 2) â†‘x) xâ‚€
theorem measure_theory.finite_measure.tendsto_lintegral_nn_filter_of_le_const {Î± : Type u_1} [measurable_space Î±] [topological_space Î±] [opens_measurable_space Î±] {Î¹ : Type u_2} {L : filter Î¹} [L.is_countably_generated] (Î¼ : measure_theory.finite_measure Î±) {fs : Î¹ â†’ bounded_continuous_function Î± nnreal} {c : nnreal} (fs_le_const : âˆ€á¶  (i : Î¹) in L, âˆ€áµ (a : Î±) âˆ‚â†‘Î¼, â‡‘(fs i) a â‰¤ c) {f : Î± â†’ nnreal} (fs_lim : âˆ€áµ (a : Î±) âˆ‚â†‘Î¼, filter.tendsto (Î» (i : Î¹), â‡‘(fs i) a) L (nhds (f a))) : filter.tendsto (Î» (i : Î¹), âˆ«â» (a : Î±), â†‘(â‡‘(fs i) a) âˆ‚â†‘Î¼) L (nhds (âˆ«â» (a : Î±), â†‘(f a) âˆ‚â†‘Î¼))
theorem cont_diff_at.fst'' {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {G : Type u_4} [normed_group G] [normed_space ğ•œ G] {n : with_top â„•} {f : E â†’ G} {x : E Ã— F} (hf : cont_diff_at ğ•œ n f x.fst) : cont_diff_at ğ•œ n (Î» (x : E Ã— F), f x.fst) x
theorem polynomial.unique_int_coeff_of_cycl {K : Type u_1} [comm_ring K] [is_domain K] [char_zero K] {Î¶ : K} {n : â„•+} (h : is_primitive_root Î¶ â†‘n) : âˆƒ! (P : polynomial â„¤), polynomial.map (int.cast_ring_hom K) P = polynomial.cyclotomic' â†‘n K
theorem finset.sum_induction_nonempty {Î± : Type v} {s : finset Î±} {M : Type u_1} [add_comm_monoid M] (f : Î± â†’ M) (p : M â†’ Prop) (p_mul : âˆ€ (a b : M), p a â†’ p b â†’ p (a + b)) (hs_nonempty : s.nonempty) (p_s : âˆ€ (x : Î±), x âˆˆ s â†’ p (f x)) : p (s.sum (Î» (x : Î±), f x))
theorem covby.is_coatom {Î± : Type u_1} [partial_order Î±] [order_top Î±] {a : Î±} : a â‹– âŠ¤ â†’ is_coatom a
theorem model_with_corners_self_local_equiv (ğ•œ : Type u_1) [nondiscrete_normed_field ğ•œ] (E : Type u_2) [normed_group E] [normed_space ğ•œ E] : (model_with_corners_self ğ•œ E).to_local_equiv = local_equiv.refl E
theorem ideal.smul_eq_mul {R : Type u} [comm_semiring R] (I J : ideal R) : I â€¢ J = I * J
theorem finset.prod_induction_nonempty {Î± : Type v} {s : finset Î±} {M : Type u_1} [comm_monoid M] (f : Î± â†’ M) (p : M â†’ Prop) (p_mul : âˆ€ (a b : M), p a â†’ p b â†’ p (a * b)) (hs_nonempty : s.nonempty) (p_s : âˆ€ (x : Î±), x âˆˆ s â†’ p (f x)) : p (s.prod (Î» (x : Î±), f x))
theorem category_theory.is_pushout.zero_bot {C : Type uâ‚} [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_zero_morphisms C] (X : C) : category_theory.is_pushout (ğŸ™ X) 0 0 0
theorem direct_sum.mul_eq_sum_support_ghas_mul {Î¹ : Type u_1} [decidable_eq Î¹] (A : Î¹ â†’ Type u_2) [Î  (i : Î¹), add_comm_monoid (A i)] [add_monoid Î¹] [direct_sum.gsemiring A] [Î  (i : Î¹) (x : A i), decidable (x â‰  0)] (a a' : direct_sum Î¹ (Î» (i : Î¹), A i)) : a * a' = ((dfinsupp.support a).product (dfinsupp.support a')).sum (Î» (ij : Î¹ Ã— Î¹), â‡‘(direct_sum.of A (ij.fst + ij.snd)) (graded_monoid.ghas_mul.mul (â‡‘a ij.fst) (â‡‘a' ij.snd)))
theorem cardinal.mk_Ico_real {a b : â„} (h : a < b) : cardinal.mk â†¥(set.Ico a b) = cardinal.continuum
theorem isometry.nndist_eq {Î± : Type u} {Î² : Type v} [pseudo_metric_space Î±] [pseudo_metric_space Î²] {f : Î± â†’ Î²} (hf : isometry f) (x y : Î±) : has_nndist.nndist (f x) (f y) = has_nndist.nndist x y
theorem continuous_map.dist_apply_le_dist {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [compact_space Î±] [metric_space Î²] {f g : C(Î±, Î²)} (x : Î±) : has_dist.dist (â‡‘f x) (â‡‘g x) â‰¤ has_dist.dist f g
theorem finsupp.lhom_ext' {Î± : Type u_1} {M : Type u_2} {N : Type u_3} {R : Type u_5} [semiring R] [add_comm_monoid M] [module R M] [add_comm_monoid N] [module R N] â¦ƒÏ† Ïˆ : (Î± â†’â‚€ M) â†’â‚—[R] Nâ¦„ (h : âˆ€ (a : Î±), Ï†.comp (finsupp.lsingle a) = Ïˆ.comp (finsupp.lsingle a)) : Ï† = Ïˆ
theorem analytic_at.comp {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [nondiscrete_normed_field ğ•œ] [normed_group E] [normed_space ğ•œ E] [normed_group F] [normed_space ğ•œ F] [normed_group G] [normed_space ğ•œ G] {g : F â†’ G} {f : E â†’ F} {x : E} (hg : analytic_at ğ•œ g (f x)) (hf : analytic_at ğ•œ f x) : analytic_at ğ•œ (g âˆ˜ f) x
theorem add_hom.eq_on_mclosure {M : Type u_1} {N : Type u_2} [has_add M] [has_add N] {f g : add_hom M N} {s : set M} (h : set.eq_on â‡‘f â‡‘g s) : set.eq_on â‡‘f â‡‘g â†‘(add_subsemigroup.closure s)
theorem inner_product_geometry.norm_sub_eq_abs_sub_norm_of_angle_eq_zero {V : Type u_1} [inner_product_space â„ V] {x y : V} (h : inner_product_geometry.angle x y = 0) : âˆ¥x - yâˆ¥ = |âˆ¥xâˆ¥ - âˆ¥yâˆ¥|
theorem metric.continuous_inf_nndist_pt {Î± : Type u} [pseudo_metric_space Î±] (s : set Î±) : continuous (Î» (x : Î±), metric.inf_nndist x s)
theorem is_integral_closure.is_fraction_ring_of_finite_extension (A : Type u_4) (K : Type u_5) [comm_ring A] [is_domain A] (L : Type u_6) [field K] [field L] [algebra A K] [algebra A L] [is_fraction_ring A K] (C : Type u_7) [comm_ring C] [is_domain C] [algebra C L] [is_integral_closure C A L] [algebra A C] [is_scalar_tower A C L] [algebra K L] [is_scalar_tower A K L] [finite_dimensional K L] : is_fraction_ring C L
theorem interval_integral.integral_has_strict_fderiv_at_of_tendsto_ae {E : Type u_3} [normed_group E] [complete_space E] [normed_space â„ E] {f : â„ â†’ E} {ca cb : E} {a b : â„} (hf : interval_integrable f measure_theory.measure_space.volume a b) (hmeas_a : strongly_measurable_at_filter f (nhds a) measure_theory.measure_space.volume) (hmeas_b : strongly_measurable_at_filter f (nhds b) measure_theory.measure_space.volume) (ha : filter.tendsto f (nhds a âŠ“ measure_theory.measure_space.volume.ae) (nhds ca)) (hb : filter.tendsto f (nhds b âŠ“ measure_theory.measure_space.volume.ae) (nhds cb)) : has_strict_fderiv_at (Î» (p : â„ Ã— â„), âˆ« (x : â„) in p.fst..p.snd, f x) ((continuous_linear_map.snd â„ â„ â„).smul_right cb - (continuous_linear_map.fst â„ â„ â„).smul_right ca) (a, b)
theorem mem_extreme_points_iff_forall_segment {ğ•œ : Type u_1} {E : Type u_2} [linear_ordered_ring ğ•œ] [add_comm_group E] [module ğ•œ E] [densely_ordered ğ•œ] [no_zero_smul_divisors ğ•œ E] {A : set E} {x : E} : x âˆˆ set.extreme_points ğ•œ A â†” x âˆˆ A âˆ§ âˆ€ (xâ‚ : E), xâ‚ âˆˆ A â†’ âˆ€ (xâ‚‚ : E), xâ‚‚ âˆˆ A â†’ x âˆˆ segment ğ•œ xâ‚ xâ‚‚ â†’ xâ‚ = x âˆ¨ xâ‚‚ = x
theorem nat.sum_two_pow_lt {k : â„•} {A : finset â„•} (hâ‚ : âˆ€ {x : â„•}, x âˆˆ A â†’ x < k) : A.sum (has_pow.pow 2) < 2 ^ k
theorem has_sbtw.sbtw.not_sbtw {Î± : Type u_1} [circular_preorder Î±] {a b c : Î±} (h : has_sbtw.sbtw a b c) : Â¬has_sbtw.sbtw c b a
theorem fintype.exists_le_card_fiber_of_nsmul_le_card {Î± : Type u} {Î² : Type v} {M : Type w} [decidable_eq Î²] [fintype Î±] [fintype Î²] (f : Î± â†’ Î²) {b : M} [linear_ordered_comm_ring M] [nonempty Î²] (hb : fintype.card Î² â€¢ b â‰¤ â†‘(fintype.card Î±)) : âˆƒ (y : Î²), b â‰¤ â†‘((finset.filter (Î» (x : Î±), f x = y) finset.univ).card)
theorem fin.succ_succ_above_one {n : â„•} (i : fin (n + 2)) : â‡‘(i.succ.succ_above) 1 = (â‡‘(i.succ_above) 0).succ
theorem measure_theory.measure_lt_top_of_is_compact_of_is_add_left_invariant' {G : Type u_1} [measurable_space G] [topological_space G] [borel_space G] {Î¼ : measure_theory.measure G} [add_group G] [topological_add_group G] [Î¼.is_add_left_invariant] {U : set G} (hU : (interior U).nonempty) (h : â‡‘Î¼ U â‰  âŠ¤) {K : set G} (hK : is_compact K) : â‡‘Î¼ K < âŠ¤
theorem local_homeomorph.is_image.of_preimage_eq {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] {e : local_homeomorph Î± Î²} {s : set Î±} {t : set Î²} : e.to_local_equiv.source âˆ© â‡‘e â»Â¹' t = e.to_local_equiv.source âˆ© s â†’ e.is_image s t
theorem dist_le_of_trajectories_ODE_of_mem_set {E : Type u_1} [normed_group E] [normed_space â„ E] {v : â„ â†’ E â†’ E} {s : â„ â†’ set E} {K : â„} (hv : âˆ€ (t : â„) (x : E), x âˆˆ s t â†’ âˆ€ (y : E), y âˆˆ s t â†’ has_dist.dist (v t x) (v t y) â‰¤ K * has_dist.dist x y) {f g : â„ â†’ E} {a b Î´ : â„} (hf : continuous_on f (set.Icc a b)) (hf' : âˆ€ (t : â„), t âˆˆ set.Ico a b â†’ has_deriv_within_at f (v t (f t)) (set.Ici t) t) (hfs : âˆ€ (t : â„), t âˆˆ set.Ico a b â†’ f t âˆˆ s t) (hg : continuous_on g (set.Icc a b)) (hg' : âˆ€ (t : â„), t âˆˆ set.Ico a b â†’ has_deriv_within_at g (v t (g t)) (set.Ici t) t) (hgs : âˆ€ (t : â„), t âˆˆ set.Ico a b â†’ g t âˆˆ s t) (ha : has_dist.dist (f a) (g a) â‰¤ Î´) (t : â„) (H : t âˆˆ set.Icc a b) : has_dist.dist (f t) (g t) â‰¤ Î´ * real.exp (K * (t - a))
theorem exp_neg_inv_glue.f_aux_limit (n : â„•) : filter.tendsto (Î» (x : â„), polynomial.eval x (exp_neg_inv_glue.P_aux n) * real.exp (-xâ»Â¹) / x ^ (2 * n)) (nhds_within 0 (set.Ioi 0)) (nhds 0)
theorem polynomial.span_le_of_coeff_mem_C_inverse {R : Type u} [semiring R] {f : polynomial R} {I : submodule (polynomial R) (polynomial R)} (cf : âˆ€ (i : â„•), f.coeff i âˆˆ â‡‘polynomial.C â»Â¹' I.carrier) : submodule.span (polynomial R) {g : polynomial R | âˆƒ (i : â„•), g = â‡‘polynomial.C (f.coeff i)} â‰¤ I
theorem order.partial_iso.exists_across {Î± : Type u_1} {Î² : Type u_2} [linear_order Î±] [linear_order Î²] [densely_ordered Î²] [no_min_order Î²] [no_max_order Î²] [nonempty Î²] (f : order.partial_iso Î± Î²) (a : Î±) : âˆƒ (b : Î²), âˆ€ (p : Î± Ã— Î²), p âˆˆ f.val â†’ cmp p.fst a = cmp p.snd b
theorem padic_val_rat.sum_pos_of_pos (p : â„•) [p_prime : fact (nat.prime p)] {n : â„•} {F : â„• â†’ â„š} (hF : âˆ€ (i : â„•), i < n â†’ 0 < padic_val_rat p (F i)) (hn0 : (finset.range n).sum (Î» (i : â„•), F i) â‰  0) : 0 < padic_val_rat p ((finset.range n).sum (Î» (i : â„•), F i))
theorem monoid.closure_singleton {M : Type u_1} [monoid M] {x : M} : monoid.closure {x} = powers x
theorem bdd_above.image2 {Î± : Type u} {Î² : Type v} {Î³ : Type w} [preorder Î±] [preorder Î²] [preorder Î³] {f : Î± â†’ Î² â†’ Î³} {s : set Î±} {t : set Î²} (hâ‚€ : âˆ€ (b : Î²), monotone (function.swap f b)) (hâ‚ : âˆ€ (a : Î±), monotone (f a)) : bdd_above s â†’ bdd_above t â†’ bdd_above (set.image2 f s t)
theorem sym2.card {Î± : Type u_1} [decidable_eq Î±] [fintype Î±] : fintype.card (sym2 Î±) = fintype.card Î± * (fintype.card Î± + 1) / 2
theorem convex.norm_image_sub_le_of_norm_has_fderiv_within_le {E : Type u_1} [normed_group E] [normed_space â„ E] {ğ•œ : Type u_3} {G : Type u_4} [is_R_or_C ğ•œ] [normed_space ğ•œ E] [normed_group G] [normed_space ğ•œ G] {f : E â†’ G} {C : â„} {s : set E} {x y : E} {f' : E â†’ (E â†’L[ğ•œ] G)} (hf : âˆ€ (x : E), x âˆˆ s â†’ has_fderiv_within_at f (f' x) s x) (bound : âˆ€ (x : E), x âˆˆ s â†’ âˆ¥f' xâˆ¥ â‰¤ C) (hs : convex â„ s) (xs : x âˆˆ s) (ys : y âˆˆ s) : âˆ¥f y - f xâˆ¥ â‰¤ C * âˆ¥y - xâˆ¥
theorem category_theory.eq_to_iso_map {C : Type uâ‚} [category_theory.category C] {D : Type uâ‚‚} [category_theory.category D] (F : C â¥¤ D) {X Y : C} (p : X = Y) : F.map_iso (category_theory.eq_to_iso p) = category_theory.eq_to_iso _
theorem measure_theory.strongly_measurable.fin_strongly_measurable {Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} [topological_space Î²] [has_zero Î²] {m0 : measurable_space Î±} (hf : measure_theory.strongly_measurable f) (Î¼ : measure_theory.measure Î±) [measure_theory.sigma_finite Î¼] : measure_theory.fin_strongly_measurable f Î¼
theorem locally_finite.finite_nonempty_of_compact {Î± : Type u} [topological_space Î±] {Î¹ : Type u_1} [compact_space Î±] {f : Î¹ â†’ set Î±} (hf : locally_finite f) : {i : Î¹ | (f i).nonempty}.finite
theorem nat.factorization_eq_zero_iff (n : â„•) : n.factorization = 0 â†” n = 0 âˆ¨ n = 1
theorem lucas_lehmer.order_Ï‰ (p' : â„•) (h : lucas_lehmer.lucas_lehmer_residue (p' + 2) = 0) : order_of (lucas_lehmer.Ï‰_unit (p' + 2)) = 2 ^ (p' + 2)
theorem linear_equiv.finrank_map_eq {R : Type u_1} {M : Type u_2} {Mâ‚‚ : Type u_3} [ring R] [add_comm_group M] [add_comm_group Mâ‚‚] [module R M] [module R Mâ‚‚] (f : M â‰ƒâ‚—[R] Mâ‚‚) (p : submodule R M) : finite_dimensional.finrank R â†¥(submodule.map â†‘f p) = finite_dimensional.finrank R â†¥p
theorem algebraic_geometry.PresheafedSpace.glue_data.Ï€_Î¹_inv_app_Ï€ {C : Type u} [category_theory.category C] (D : algebraic_geometry.PresheafedSpace.glue_data C) [category_theory.limits.has_limits C] (i j : D.to_glue_data.J) (U : topological_space.opens â†¥((D.to_glue_data.U i).carrier)) : D.diagram_over_open_Ï€ U i â‰« D.Î¹_inv_app_Ï€_eq_map U â‰« D.Î¹_inv_app U â‰« D.diagram_over_open_Ï€ U j = D.diagram_over_open_Ï€ U j
theorem finset.mem_up_shadow_iff_exists_mem_card_add_one {Î± : Type u_1} [decidable_eq Î±] [fintype Î±] {ğ’œ : finset (finset Î±)} {s : finset Î±} : s âˆˆ ğ’œ.up_shadow â†” âˆƒ (t : finset Î±) (H : t âˆˆ ğ’œ), t âŠ† s âˆ§ t.card + 1 = s.card
theorem spectrum.pow_nnnorm_pow_one_div_tendsto_nhds_spectral_radius {A : Type u_2} [normed_ring A] [normed_algebra â„‚ A] [complete_space A] [norm_one_class A] (a : A) : filter.tendsto (Î» (n : â„•), â†‘âˆ¥a ^ nâˆ¥â‚Š ^ (1 / â†‘n)) filter.at_top (nhds (spectral_radius â„‚ a))
theorem order.succ_ne_succ {Î± : Type u_1} [partial_order Î±] [succ_order Î±] {a b : Î±} [no_max_order Î±] : a â‰  b â†’ order.succ a â‰  order.succ b
theorem monotone.tendsto_nhds_within_Iio {Î² : Type v} [conditionally_complete_linear_order Î²] [topological_space Î²] [order_topology Î²] {Î± : Type u_1} [linear_order Î±] [topological_space Î±] [order_topology Î±] {f : Î± â†’ Î²} (Mf : monotone f) (x : Î±) : filter.tendsto f (nhds_within x (set.Iio x)) (nhds (has_Sup.Sup (f '' set.Iio x)))
theorem generalized_continued_fraction.succ_succ_nth_convergent'_aux_eq_succ_nth_convergent'_aux_squash_seq {K : Type u_1} {n : â„•} {s : seq (generalized_continued_fraction.pair K)} [division_ring K] : generalized_continued_fraction.convergents'_aux s (n + 2) = generalized_continued_fraction.convergents'_aux (generalized_continued_fraction.squash_seq s n) (n + 1)
theorem mul_hom.map_mclosure {M : Type u_1} {N : Type u_2} [has_mul M] [has_mul N] (f : M â†’â‚™* N) (s : set M) : subsemigroup.map f (subsemigroup.closure s) = subsemigroup.closure (â‡‘f '' s)
theorem category_theory.limits.colimit_limit_to_limit_colimit_injective {J K : Type v} [category_theory.small_category J] [category_theory.small_category K] (F : J Ã— K â¥¤ Type v) [category_theory.is_filtered K] [fintype J] : function.injective (category_theory.limits.colimit_limit_to_limit_colimit F)
theorem matrix.det_succ_row_zero {R : Type v} [comm_ring R] {n : â„•} (A : matrix (fin n.succ) (fin n.succ) R) : A.det = finset.univ.sum (Î» (j : fin n.succ), (-1) ^ â†‘j * A 0 j * (A.minor fin.succ â‡‘(j.succ_above)).det)
theorem tsub_tsub_le {Î± : Type u_1} [preorder Î±] [add_comm_semigroup Î±] [has_sub Î±] [has_ordered_sub Î±] {a b : Î±} : b - (b - a) â‰¤ a
theorem has_strict_fderiv_at.approximates_deriv_on_nhds {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {f : E â†’ F} {f' : E â†’L[ğ•œ] F} {a : E} (hf : has_strict_fderiv_at f f' a) {c : nnreal} (hc : subsingleton E âˆ¨ 0 < c) : âˆƒ (s : set E) (H : s âˆˆ nhds a), approximates_linear_on f f' s c
theorem linear_independent.map {Î¹ : Type u_1} {R : Type u_3} {M : Type u_5} {M' : Type u_6} {v : Î¹ â†’ M} [semiring R] [add_comm_monoid M] [add_comm_monoid M'] [module R M] [module R M'] (hv : linear_independent R v) {f : M â†’â‚—[R] M'} (hf_inj : disjoint (submodule.span R (set.range v)) f.ker) : linear_independent R (â‡‘f âˆ˜ v)
theorem measure_theory.mul_meas_ge_le_pow_snorm' {Î± : Type u_1} {E : Type u_2} {m0 : measurable_space Î±} {p : ennreal} (Î¼ : measure_theory.measure Î±) [normed_group E] {f : Î± â†’ E} (hp_ne_zero : p â‰  0) (hp_ne_top : p â‰  âŠ¤) (hf : measure_theory.ae_strongly_measurable f Î¼) (Îµ : ennreal) : Îµ ^ p.to_real * â‡‘Î¼ {x : Î± | Îµ â‰¤ â†‘âˆ¥f xâˆ¥â‚Š} â‰¤ measure_theory.snorm f p Î¼ ^ p.to_real
theorem finset.prod_product_right' {Î² : Type u} {Î± : Type v} {Î³ : Type w} [comm_monoid Î²] {s : finset Î³} {t : finset Î±} {f : Î³ â†’ Î± â†’ Î²} : (s.product t).prod (Î» (x : Î³ Ã— Î±), f x.fst x.snd) = t.prod (Î» (y : Î±), s.prod (Î» (x : Î³), f x y))
theorem intermediate_value_univ {X : Type u} {Î± : Type v} [topological_space X] [linear_order Î±] [topological_space Î±] [order_closed_topology Î±] [preconnected_space X] (a b : X) {f : X â†’ Î±} (hf : continuous f) : set.Icc (f a) (f b) âŠ† set.range f
theorem quadratic_eq_zero_iff {K : Type u_1} [field K] [invertible 2] {a b c : K} (ha : a â‰  0) {s : K} (h : discrim a b c = s * s) (x : K) : a * x * x + b * x + c = 0 â†” x = (-b + s) / (2 * a) âˆ¨ x = (-b - s) / (2 * a)
theorem sigma.subtype_ext {Î± : Type u_1} {Î² : Type u_2} {p : Î± â†’ Î² â†’ Prop} {xâ‚€ xâ‚ : Î£ (a : Î±), subtype (p a)} : xâ‚€.fst = xâ‚.fst â†’ â†‘(xâ‚€.snd) = â†‘(xâ‚.snd) â†’ xâ‚€ = xâ‚
theorem matrix.mul_inv_of_mul_self_cancel {m : Type u} {n : Type u'} {Î± : Type v} [fintype n] [decidable_eq n] [comm_ring Î±] (A : matrix m n Î±) (B : matrix n n Î±) [invertible B] : (A.mul (â…Ÿ B)).mul B = A
theorem is_bounded_linear_map_prod_multilinear {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {G : Type u_4} [normed_group G] [normed_space ğ•œ G] {Î¹ : Type u_5} [decidable_eq Î¹] [fintype Î¹] {E : Î¹ â†’ Type u_2} [Î  (i : Î¹), normed_group (E i)] [Î  (i : Î¹), normed_space ğ•œ (E i)] : is_bounded_linear_map ğ•œ (Î» (p : continuous_multilinear_map ğ•œ E F Ã— continuous_multilinear_map ğ•œ E G), p.fst.prod p.snd)
theorem measure_theory.conservative.iterate {Î± : Type u_2} [measurable_space Î±] {f : Î± â†’ Î±} {Î¼ : measure_theory.measure Î±} (hf : measure_theory.conservative f Î¼) (n : â„•) : measure_theory.conservative f^[n] Î¼
theorem category_theory.discrete.eq_of_hom {Î± : Type uâ‚} {X Y : category_theory.discrete Î±} (i : X âŸ¶ Y) : X.as = Y.as
theorem ring_hom.ker_is_prime {R : Type u} {S : Type v} [ring R] [ring S] [is_domain S] (f : R â†’+* S) : f.ker.is_prime
theorem category_theory.presieve.restrict_extend {C : Type uâ‚} [category_theory.category C] {P : Cáµ’áµ– â¥¤ Type w} {X : C} {R : category_theory.presieve X} {x : category_theory.presieve.family_of_elements P R} (t : x.compatible) : category_theory.presieve.family_of_elements.restrict _ x.sieve_extend = x
theorem inducing.is_separable_preimage {Î± : Type u} {Î² : Type v} [pseudo_metric_space Î±] {f : Î² â†’ Î±} [topological_space Î²] (hf : inducing f) {s : set Î±} (hs : topological_space.is_separable s) : topological_space.is_separable (f â»Â¹' s)
theorem measurable.ennreal_induction {Î± : Type u_1} [measurable_space Î±] {P : (Î± â†’ ennreal) â†’ Prop} (h_ind : âˆ€ (c : ennreal) â¦ƒs : set Î±â¦„, measurable_set s â†’ P (s.indicator (Î» (_x : Î±), c))) (h_add : âˆ€ â¦ƒf g : Î± â†’ ennrealâ¦„, disjoint (function.support f) (function.support g) â†’ measurable f â†’ measurable g â†’ P f â†’ P g â†’ P (f + g)) (h_supr : âˆ€ â¦ƒf : â„• â†’ Î± â†’ ennrealâ¦„, (âˆ€ (n : â„•), measurable (f n)) â†’ monotone f â†’ (âˆ€ (n : â„•), P (f n)) â†’ P (Î» (x : Î±), â¨† (n : â„•), f n x)) â¦ƒf : Î± â†’ ennrealâ¦„ (hf : measurable f) : P f
theorem linear_independent_set_iff_affine_independent_vadd_union_singleton (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : set V} (hs : âˆ€ (v : V), v âˆˆ s â†’ v â‰  0) (pâ‚ : P) : linear_independent k (Î» (v : â†¥s), â†‘v) â†” affine_independent k (Î» (p : â†¥({pâ‚} âˆª (Î» (v : V), v +áµ¥ pâ‚) '' s)), â†‘p)
theorem absolute_value.is_admissible.exists_approx {R : Type u_1} [euclidean_domain R] {abv : absolute_value R â„¤} {Î¹ : Type u_2} [fintype Î¹] {Îµ : â„} (hÎµ : 0 < Îµ) {b : R} (hb : b â‰  0) (h : abv.is_admissible) (A : fin (h.card Îµ ^ fintype.card Î¹).succ â†’ Î¹ â†’ R) : âˆƒ (iâ‚€ iâ‚ : fin (h.card Îµ ^ fintype.card Î¹).succ), iâ‚€ â‰  iâ‚ âˆ§ âˆ€ (k : Î¹), â†‘(â‡‘abv (A iâ‚ k % b - A iâ‚€ k % b)) < â‡‘abv b â€¢ Îµ
theorem basis.to_matrix_mul_to_matrix_flip {Î¹ : Type u_1} {Î¹' : Type u_2} {R : Type u_5} {M : Type u_6} [comm_semiring R] [add_comm_monoid M] [module R M] (b : basis Î¹ R M) (b' : basis Î¹' R M) [decidable_eq Î¹] [fintype Î¹'] : (b.to_matrix â‡‘b').mul (b'.to_matrix â‡‘b) = 1
theorem monoid_hom.map_exists_right_inv {M : Type u_3} {N : Type u_4} {F : Type u_8} {mM : mul_one_class M} {mN : mul_one_class N} [monoid_hom_class F M N] (f : F) {x : M} (hx : âˆƒ (y : M), x * y = 1) : âˆƒ (y : N), â‡‘f x * y = 1
theorem measure_theory.content.inner_content_Union_nat {G : Type w} [topological_space G] (Î¼ : measure_theory.content G) [t2_space G] â¦ƒU : â„• â†’ set Gâ¦„ (hU : âˆ€ (i : â„•), is_open (U i)) : Î¼.inner_content âŸ¨â‹ƒ (i : â„•), U i, _âŸ© â‰¤ âˆ‘' (i : â„•), Î¼.inner_content âŸ¨U i, _âŸ©
theorem measure_theory.unif_integrable_fin {Î± : Type u_1} {Î² : Type u_2} {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) [normed_group Î²] {p : ennreal} (hp_one : 1 â‰¤ p) (hp_top : p â‰  âŠ¤) {n : â„•} {f : fin n â†’ Î± â†’ Î²} (hf : âˆ€ (i : fin n), measure_theory.mem_â„’p (f i) p Î¼) : measure_theory.unif_integrable f p Î¼
theorem filter.map_coe_Ici_at_top {Î± : Type u_3} [semilattice_sup Î±] (a : Î±) : filter.map coe filter.at_top = filter.at_top
theorem category_theory.grothendieck_topology.le_close_of_is_closed {C : Type u} [category_theory.category C] (Jâ‚ : category_theory.grothendieck_topology C) {X : C} {S T : category_theory.sieve X} (h : S â‰¤ T) (hT : Jâ‚.is_closed T) : Jâ‚.close S â‰¤ T
theorem set.pairwise_disjoint.bUnion {Î± : Type u_1} {Î¹ : Type u_2} {Î¹' : Type u_3} [complete_lattice Î±] {s : set Î¹'} {g : Î¹' â†’ set Î¹} {f : Î¹ â†’ Î±} (hs : s.pairwise_disjoint (Î» (i' : Î¹'), â¨† (i : Î¹) (H : i âˆˆ g i'), f i)) (hg : âˆ€ (i : Î¹'), i âˆˆ s â†’ (g i).pairwise_disjoint f) : (â‹ƒ (i : Î¹') (H : i âˆˆ s), g i).pairwise_disjoint f
theorem has_lt.lt.trans_lf {x y z : pgame} (hâ‚ : x < y) (hâ‚‚ : y.lf z) : x.lf z
theorem ideal.dvd_iff_le {A : Type u_2} [comm_ring A] [is_domain A] [is_dedekind_domain A] {I J : ideal A} : I âˆ£ J â†” J â‰¤ I
theorem mem_adjoin_of_smul_prime_smul_of_minpoly_is_eiseinstein_at {R : Type u} {K : Type v} {L : Type z} {p : R} [comm_ring R] [field K] [field L] [algebra K L] [algebra R L] [algebra R K] [is_scalar_tower R K L] [is_separable K L] [is_domain R] [normalized_gcd_monoid R] [is_fraction_ring R K] [is_integrally_closed R] {B : power_basis K L} (hp : prime p) (hBint : is_integral R B.gen) {z : L} (hzint : is_integral R z) (hz : p â€¢ z âˆˆ algebra.adjoin R {B.gen}) (hei : (minpoly R B.gen).is_eisenstein_at (submodule.span R {p})) : z âˆˆ algebra.adjoin R {B.gen}
theorem measure_theory.measure_preserving.exists_mem_image_mem {Î± : Type u_1} [measurable_space Î±] {Î¼ : measure_theory.measure Î±} {f : Î± â†’ Î±} {s : set Î±} [measure_theory.is_finite_measure Î¼] (hf : measure_theory.measure_preserving f Î¼ Î¼) (hs : measurable_set s) (hs' : â‡‘Î¼ s â‰  0) : âˆƒ (x : Î±) (H : x âˆˆ s) (m : â„•) (H : m â‰  0), f^[m] x âˆˆ s
theorem bornology.is_bounded.bounded_space_subtype {Î± : Type u_1} [bornology Î±] {p : Î± â†’ Prop} : bornology.is_bounded {x : Î± | p x} â†’ bounded_space (subtype p)
theorem interval_integral.integral_const_of_cdf {E : Type u_3} [normed_group E] [complete_space E] [normed_space â„ E] {a b : â„} {Î¼ : measure_theory.measure â„} [measure_theory.is_finite_measure Î¼] (c : E) : âˆ« (x : â„) in a..b, c âˆ‚Î¼ = ((â‡‘Î¼ (set.Iic b)).to_real - (â‡‘Î¼ (set.Iic a)).to_real) â€¢ c
theorem uniformity_pseudoedist {Î± : Type u} [pseudo_emetric_space Î±] : uniformity Î± = â¨… (Îµ : ennreal) (H : Îµ > 0), filter.principal {p : Î± Ã— Î± | has_edist.edist p.fst p.snd < Îµ}
theorem zero_ne_one_or_forall_eq_0 {Mâ‚€ : Type u_1} [mul_zero_one_class Mâ‚€] : 0 â‰  1 âˆ¨ âˆ€ (a : Mâ‚€), a = 0
theorem affine.simplex.monge_point_mem_affine_span {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {n : â„•} (s : affine.simplex â„ P n) : s.monge_point âˆˆ affine_span â„ (set.range s.points)
theorem dense_embedding.separable_space {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] {e : Î± â†’ Î²} (de : dense_embedding e) [topological_space.separable_space Î±] : topological_space.separable_space Î²
theorem finset.center_mass_id_mem_convex_hull {R : Type u_1} {E : Type u_2} [linear_ordered_field R] [add_comm_group E] [module R E] (t : finset E) {w : E â†’ R} (hwâ‚€ : âˆ€ (i : E), i âˆˆ t â†’ 0 â‰¤ w i) (hws : 0 < t.sum (Î» (i : E), w i)) : t.center_mass w id âˆˆ â‡‘(convex_hull R) â†‘t
theorem submodule.coe_inner {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] (W : submodule ğ•œ E) (x y : â†¥W) : has_inner.inner x y = has_inner.inner â†‘x â†‘y
theorem dense_bInter_of_open {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [baire_space Î±] {S : set Î²} {f : Î² â†’ set Î±} (ho : âˆ€ (s : Î²), s âˆˆ S â†’ is_open (f s)) (hS : S.countable) (hd : âˆ€ (s : Î²), s âˆˆ S â†’ dense (f s)) : dense (â‹‚ (s : Î²) (H : s âˆˆ S), f s)
theorem is_compact.is_closed {Î± : Type u} [topological_space Î±] [t2_space Î±] {s : set Î±} (hs : is_compact s) : is_closed s
theorem nat.cast_desc_factorial_two (S : Type u_1) [ring S] (a : â„•) : â†‘(a.desc_factorial 2) = â†‘a * (â†‘a - 1)
theorem vitali_family.measure_le_mul_of_subset_lim_ratio_meas_lt {Î± : Type u_1} [metric_space Î±] {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (v : vitali_family Î¼) [sigma_compact_space Î±] [borel_space Î±] [measure_theory.is_locally_finite_measure Î¼] {Ï : measure_theory.measure Î±} [measure_theory.is_locally_finite_measure Ï] (hÏ : Ï.absolutely_continuous Î¼) {p : nnreal} {s : set Î±} (h : s âŠ† {x : Î± | v.lim_ratio_meas hÏ x < â†‘p}) : â‡‘Ï s â‰¤ â†‘p * â‡‘Î¼ s
theorem ideal.is_jacobson_iff_prime_eq {R : Type u_1} [comm_ring R] : ideal.is_jacobson R â†” âˆ€ (P : ideal R), P.is_prime â†’ P.jacobson = P
theorem matrix.right_inv_eq_left_inv {n : Type u'} {Î± : Type v} [fintype n] [decidable_eq n] [comm_ring Î±] {A B C : matrix n n Î±} (h : A.mul B = 1) (g : C.mul A = 1) : B = C
theorem inner_eq_norm_mul_iff_real {F : Type u_3} [inner_product_space â„ F] {x y : F} : has_inner.inner x y = âˆ¥xâˆ¥ * âˆ¥yâˆ¥ â†” âˆ¥yâˆ¥ â€¢ x = âˆ¥xâˆ¥ â€¢ y
theorem linear_map.mk_continuous_norm_le' {ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_normed_group E] [semi_normed_group F] [nondiscrete_normed_field ğ•œ] [nondiscrete_normed_field ğ•œâ‚‚] [normed_space ğ•œ E] [normed_space ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} (f : E â†’â‚›â‚—[Ïƒâ‚â‚‚] F) {C : â„} (h : âˆ€ (x : E), âˆ¥â‡‘f xâˆ¥ â‰¤ C * âˆ¥xâˆ¥) : âˆ¥f.mk_continuous C hâˆ¥ â‰¤ linear_order.max C 0
theorem polynomial_functions.comap'_comp_right_alg_hom_Icc_homeo_I (a b : â„) (h : a < b) : (polynomial_functions unit_interval).comap' (continuous_map.comp_right_alg_hom â„ (Icc_homeo_I a b h).symm.to_continuous_map) = polynomial_functions (set.Icc a b)
theorem is_add_group_hom.comp {Î± : Type u} {Î² : Type v} [add_group Î±] [add_group Î²] {f : Î± â†’ Î²} (hf : is_add_group_hom f) {Î³ : Type u_1} [add_group Î³] {g : Î² â†’ Î³} (hg : is_add_group_hom g) : is_add_group_hom (g âˆ˜ f)
theorem euclidean_geometry.orthogonal_projection_vsub_orthogonal_projection {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] (s : affine_subspace â„ P) [nonempty â†¥s] [complete_space â†¥(s.direction)] (p : P) : â‡‘(orthogonal_projection s.direction) (p -áµ¥ â†‘(â‡‘(euclidean_geometry.orthogonal_projection s) p)) = 0
theorem tendsto_uniformly_on.uniform_cauchy_seq_on {Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_4} [uniform_space Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : set Î±} {p : filter Î¹} (hF : tendsto_uniformly_on F f p s) : uniform_cauchy_seq_on F p s
theorem generalized_continued_fraction.continuants_recurrence {K : Type u_1} {g : generalized_continued_fraction K} {n : â„•} [division_ring K] {gp ppred pred : generalized_continued_fraction.pair K} (succ_nth_s_eq : g.s.nth (n + 1) = option.some gp) (nth_conts_eq : g.continuants n = ppred) (succ_nth_conts_eq : g.continuants (n + 1) = pred) : g.continuants (n + 2) = {a := gp.b * pred.a + gp.a * ppred.a, b := gp.b * pred.b + gp.a * ppred.b}
theorem list.ordered_insert_eq_take_drop {Î± : Type uu} (r : Î± â†’ Î± â†’ Prop) [decidable_rel r] (a : Î±) (l : list Î±) : list.ordered_insert r a l = list.take_while (Î» (b : Î±), Â¬r a b) l ++ a :: list.drop_while (Î» (b : Î±), Â¬r a b) l
theorem has_sbtw.sbtw.trans_right {Î± : Type u_1} [circular_preorder Î±] {a b c d : Î±} (hbc : has_sbtw.sbtw a b c) (hcd : has_sbtw.sbtw a c d) : has_sbtw.sbtw a b d
theorem Top.presheaf.is_sheaf_sites_iff_is_sheaf_opens_le_cover {C : Type u} [category_theory.category C] {X : Top} (F : Top.presheaf C X) : category_theory.presheaf.is_sheaf (opens.grothendieck_topology â†¥X) F â†” F.is_sheaf_opens_le_cover
theorem asymptotics.is_O.neg_right {Î± : Type u_1} {E : Type u_3} {F' : Type u_7} [has_norm E] [semi_normed_group F'] {f : Î± â†’ E} {g' : Î± â†’ F'} {l : filter Î±} : f =O[l] g' â†’ (f =O[l] Î» (x : Î±), -g' x)
theorem one_hom.congr_arg {M : Type u_3} {N : Type u_4} [has_one M] [has_one N] (f : one_hom M N) {x y : M} (h : x = y) : â‡‘f x = â‡‘f y
theorem uniform_embedding_of_spaced_out {Î² : Type u_2} [uniform_space Î²] {Î± : Type u_1} {f : Î± â†’ Î²} {s : set (Î² Ã— Î²)} (hs : s âˆˆ uniformity Î²) (hf : pairwise (Î» (x y : Î±), (f x, f y) âˆ‰ s)) : uniform_embedding f
theorem char.quadratic_char_card_sqrts {F : Type u_1} [field F] [fintype F] [decidable_eq F] (hF : ring_char F â‰  2) (a : F) : â†‘({x : F | x ^ 2 = a}.to_finset.card) = char.quadratic_char F a + 1
theorem has_fderiv_at_exp_zero {ğ•‚ : Type u_1} {ğ”¸ : Type u_2} [is_R_or_C ğ•‚] [normed_ring ğ”¸] [normed_algebra ğ•‚ ğ”¸] [complete_space ğ”¸] : has_fderiv_at (exp ğ•‚) 1 0
theorem algebra.discr_zero_of_not_linear_independent (A : Type u) {B : Type v} {Î¹ : Type w} [comm_ring A] [comm_ring B] [algebra A B] [fintype Î¹] [is_domain A] {b : Î¹ â†’ B} (hli : Â¬linear_independent A b) : algebra.discr A b = 0
theorem measure_theory.integral_integral_sub {Î± : Type u_1} {Î² : Type u_3} {E : Type u_6} [measurable_space Î±] [measurable_space Î²] {Î¼ : measure_theory.measure Î±} {Î½ : measure_theory.measure Î²} [normed_group E] [measure_theory.sigma_finite Î½] [normed_space â„ E] [complete_space E] [measure_theory.sigma_finite Î¼] â¦ƒf g : Î± Ã— Î² â†’ Eâ¦„ (hf : measure_theory.integrable f (Î¼.prod Î½)) (hg : measure_theory.integrable g (Î¼.prod Î½)) : âˆ« (x : Î±), âˆ« (y : Î²), f (x, y) - g (x, y) âˆ‚Î½ âˆ‚Î¼ = âˆ« (x : Î±), âˆ« (y : Î²), f (x, y) âˆ‚Î½ âˆ‚Î¼ - âˆ« (x : Î±), âˆ« (y : Î²), g (x, y) âˆ‚Î½ âˆ‚Î¼
theorem equiv.apply_swap_eq_self {Î± : Sort u} {Î² : Sort v} [decidable_eq Î±] {v : Î± â†’ Î²} {i j : Î±} (hv : v i = v j) (k : Î±) : v (â‡‘(equiv.swap i j) k) = v k
theorem contracting_with.efixed_point_eq_of_edist_lt_top' {Î± : Type u_1} [emetric_space Î±] {K : nnreal} {f : Î± â†’ Î±} (hf : contracting_with K f) {s : set Î±} (hsc : is_complete s) (hsf : set.maps_to f s s) (hfs : contracting_with K (set.maps_to.restrict f s s hsf)) {x : Î±} (hxs : x âˆˆ s) (hx : has_edist.edist x (f x) â‰  âŠ¤) {t : set Î±} (htc : is_complete t) (htf : set.maps_to f t t) (hft : contracting_with K (set.maps_to.restrict f t t htf)) {y : Î±} (hyt : y âˆˆ t) (hy : has_edist.edist y (f y) â‰  âŠ¤) (hxy : has_edist.edist x y â‰  âŠ¤) : contracting_with.efixed_point' f hsc hsf hfs x hxs hx = contracting_with.efixed_point' f htc htf hft y hyt hy
theorem rescale_to_shell_semi_normed {Î± : Type u_1} [normed_field Î±] {E : Type u_5} [semi_normed_group E] [normed_space Î± E] {c : Î±} (hc : 1 < âˆ¥câˆ¥) {Îµ : â„} (Îµpos : 0 < Îµ) {x : E} (hx : âˆ¥xâˆ¥ â‰  0) : âˆƒ (d : Î±), d â‰  0 âˆ§ âˆ¥d â€¢ xâˆ¥ < Îµ âˆ§ Îµ / âˆ¥câˆ¥ â‰¤ âˆ¥d â€¢ xâˆ¥ âˆ§ âˆ¥dâˆ¥â»Â¹ â‰¤ Îµâ»Â¹ * âˆ¥câˆ¥ * âˆ¥xâˆ¥
theorem convex_cone.pointed_positive_cone (ğ•œ : Type u_1) (E : Type u_2) [ordered_semiring ğ•œ] [ordered_add_comm_group E] [module ğ•œ E] [ordered_smul ğ•œ E] : (convex_cone.positive_cone ğ•œ E).pointed
theorem polynomial.rev_at_fun_eq (N i : â„•) : polynomial.rev_at_fun N i = â‡‘(polynomial.rev_at N) i
theorem measure_theory.nonempty_inter_of_measure_lt_add {Î± : Type u_1} {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) {s t u : set Î±} (ht : measurable_set t) (h's : s âŠ† u) (h't : t âŠ† u) (h : â‡‘Î¼ u < â‡‘Î¼ s + â‡‘Î¼ t) : (s âˆ© t).nonempty
theorem finset.pimage_eq_image_filter {Î± : Type u_1} {Î² : Type u_2} [decidable_eq Î²] {f : Î± â†’. Î²} [Î  (x : Î±), decidable (f x).dom] {s : finset Î±} : finset.pimage f s = finset.image (Î» (x : {x // x âˆˆ finset.filter (Î» (x : Î±), (f x).dom) s}), (f â†‘x).get _) (finset.filter (Î» (x : Î±), (f x).dom) s).attach
theorem list.length_split_wrt_composition {n : â„•} {Î± : Type u_1} (l : list Î±) (c : composition n) : (l.split_wrt_composition c).length = c.length
theorem measure_theory.measure.add_haar_image_continuous_linear_equiv {E : Type u_1} [normed_group E] [normed_space â„ E] [measurable_space E] [borel_space E] [finite_dimensional â„ E] (Î¼ : measure_theory.measure E) [Î¼.is_add_haar_measure] (f : E â‰ƒL[â„] E) (s : set E) : â‡‘Î¼ (â‡‘f '' s) = ennreal.of_real |â‡‘linear_map.det â†‘f| * â‡‘Î¼ s
theorem supr_eq_supr_finset {Î± : Type u_1} {Î¹ : Type u_4} [complete_lattice Î±] (s : Î¹ â†’ Î±) : (â¨† (i : Î¹), s i) = â¨† (t : finset Î¹) (i : Î¹) (H : i âˆˆ t), s i
theorem ring_hom.map_list_sum {Î² : Type u} {Î³ : Type w} [non_assoc_semiring Î²] [non_assoc_semiring Î³] (f : Î² â†’+* Î³) (l : list Î²) : â‡‘f l.sum = (list.map â‡‘f l).sum
theorem affine_independent_iff_of_fintype (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {Î¹ : Type u_4} [fintype Î¹] (p : Î¹ â†’ P) : affine_independent k p â†” âˆ€ (w : Î¹ â†’ k), finset.univ.sum (Î» (i : Î¹), w i) = 0 â†’ â‡‘(finset.univ.weighted_vsub p) w = 0 â†’ âˆ€ (i : Î¹), w i = 0
theorem first_order.language.embedding.comp_assoc {L : first_order.language} {M : Type w} {N : Type w'} [L.Structure M] [L.Structure N] {P : Type u_1} [L.Structure P] {Q : Type u_2} [L.Structure Q] (f : L.embedding M N) (g : L.embedding N P) (h : L.embedding P Q) : (h.comp g).comp f = h.comp (g.comp f)
theorem mv_polynomial.esymm_eq_sum_subtype (Ïƒ : Type u_1) (R : Type u_2) [comm_semiring R] [fintype Ïƒ] (n : â„•) : mv_polynomial.esymm Ïƒ R n = finset.univ.sum (Î» (t : {s // s.card = n}), â†‘t.prod (Î» (i : Ïƒ), mv_polynomial.X i))
theorem finsupp.comap_domain_smul_of_injective {Î± : Type u_1} {Î² : Type u_2} {M : Type u_5} {R : Type u_11} [add_monoid M] [monoid R] [distrib_mul_action R M] {f : Î± â†’ Î²} (hf : function.injective f) (r : R) (v : Î² â†’â‚€ M) : finsupp.comap_domain f (r â€¢ v) _ = r â€¢ finsupp.comap_domain f v _
theorem phragmen_lindelof.vertical_strip {E : Type u_1} [normed_group E] [normed_space â„‚ E] {a b C : â„} {f : â„‚ â†’ E} {z : â„‚} (hfd : diff_cont_on_cl â„‚ f (complex.re â»Â¹' set.Ioo a b)) (hB : âˆƒ (c : â„) (H : c < real.pi / (b - a)) (B : â„), f =O[filter.comap (has_abs.abs âˆ˜ complex.im) filter.at_top âŠ“ filter.principal (complex.re â»Â¹' set.Ioo a b)] Î» (z : â„‚), real.exp (B * real.exp (c * |z.im|))) (hle_a : âˆ€ (z : â„‚), z.re = a â†’ âˆ¥f zâˆ¥ â‰¤ C) (hle_b : âˆ€ (z : â„‚), z.re = b â†’ âˆ¥f zâˆ¥ â‰¤ C) (hza : a â‰¤ z.re) (hzb : z.re â‰¤ b) : âˆ¥f zâˆ¥ â‰¤ C
theorem lt_inv_mul_of_mul_lt {Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a b c : Î±} : a * b < c â†’ b < aâ»Â¹ * c
theorem has_ftaylor_series_up_to_on.has_fderiv_at {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {s : set E} {f : E â†’ F} {x : E} {n : with_top â„•} {p : E â†’ formal_multilinear_series ğ•œ E F} (h : has_ftaylor_series_up_to_on n f p s) (hn : 1 â‰¤ n) (hx : s âˆˆ nhds x) : has_fderiv_at f (â‡‘(continuous_multilinear_curry_fin1 ğ•œ E F) (p x 1)) x
theorem category_theory.presieve.is_separated_for.is_sheaf_for {C : Type uâ‚} [category_theory.category C] {P : Cáµ’áµ– â¥¤ Type w} {X : C} {R : category_theory.presieve X} (t : category_theory.presieve.is_separated_for P R) : (âˆ€ (x : category_theory.presieve.family_of_elements P R), x.compatible â†’ (âˆƒ (t : P.obj (opposite.op X)), x.is_amalgamation t)) â†’ category_theory.presieve.is_sheaf_for P R
theorem first_order.language.is_fraisse_limit.is_fraisse {L : first_order.language} (K : set (category_theory.bundled L.Structure)) {M : Type w} [L.Structure M] [L.countable_functions] (h : first_order.language.is_fraisse_limit K M) : first_order.language.is_fraisse K
theorem image_le_of_liminf_slope_right_lt_deriv_boundary' {f f' : â„ â†’ â„} {a b : â„} (hf : continuous_on f (set.Icc a b)) (hf' : âˆ€ (x : â„), x âˆˆ set.Ico a b â†’ âˆ€ (r : â„), f' x < r â†’ (âˆƒá¶  (z : â„) in nhds_within x (set.Ioi x), slope f x z < r)) {B B' : â„ â†’ â„} (ha : f a â‰¤ B a) (hB : continuous_on B (set.Icc a b)) (hB' : âˆ€ (x : â„), x âˆˆ set.Ico a b â†’ has_deriv_within_at B (B' x) (set.Ici x) x) (bound : âˆ€ (x : â„), x âˆˆ set.Ico a b â†’ f x = B x â†’ f' x < B' x) â¦ƒx : â„â¦„ : x âˆˆ set.Icc a b â†’ f x â‰¤ B x
theorem set.image_image2_distrib_right {Î± : Type u_1} {Î² : Type u_3} {Î²' : Type u_4} {Î³ : Type u_5} {Î´ : Type u_7} {f : Î± â†’ Î² â†’ Î³} {s : set Î±} {t : set Î²} {g : Î³ â†’ Î´} {f' : Î± â†’ Î²' â†’ Î´} {g' : Î² â†’ Î²'} (h_distrib : âˆ€ (a : Î±) (b : Î²), g (f a b) = f' a (g' b)) : g '' set.image2 f s t = set.image2 f' s (g' '' t)
theorem function.is_periodic_id {Î± : Type u_1} (n : â„•) (x : Î±) : function.is_periodic_pt id n x
theorem right.add_neg {Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b : Î±} (ha : a < 0) (hb : b < 0) : a + b < 0
theorem balanced.hull_subset_of_subset {ğ•œ : Type u_1} {E : Type u_2} [semi_normed_ring ğ•œ] [has_scalar ğ•œ E] {s t : set E} (ht : balanced ğ•œ t) (h : s âŠ† t) : balanced_hull ğ•œ s âŠ† t
theorem direct_sum.is_internal_submodule_of_independent_of_supr_eq_top {R : Type u} [ring R] {Î¹ : Type v} [dec_Î¹ : decidable_eq Î¹] {M : Type u_1} [add_comm_group M] [module R M] {A : Î¹ â†’ submodule R M} (hi : complete_lattice.independent A) (hs : supr A = âŠ¤) : direct_sum.is_internal A
theorem tendsto_locally_uniformly_on.continuous_on {Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_4} [uniform_space Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : set Î±} {p : filter Î¹} [topological_space Î±] (h : tendsto_locally_uniformly_on F f p s) (hc : âˆ€á¶  (n : Î¹) in p, continuous_on (F n) s) [p.ne_bot] : continuous_on f s
theorem fourier_series_repr (f : â†¥(measure_theory.Lp â„‚ 2 haar_circle)) (i : â„¤) : â‡‘(â‡‘(fourier_series.repr) f) i = âˆ« (t : â†¥circle), â†‘t ^ -i * â‡‘f t âˆ‚haar_circle
theorem map_cInf_of_continuous_at_of_monotone {Î± : Type u} {Î² : Type v} [conditionally_complete_linear_order Î±] [topological_space Î±] [order_topology Î±] [conditionally_complete_linear_order Î²] [topological_space Î²] [order_topology Î²] {f : Î± â†’ Î²} {s : set Î±} (Cf : continuous_at f (has_Inf.Inf s)) (Mf : monotone f) (ne : s.nonempty) (H : bdd_below s) : f (has_Inf.Inf s) = has_Inf.Inf (f '' s)
theorem basis.orientation_eq_or_eq_neg {R : Type u_1} [linear_ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {Î¹ : Type u_3} [decidable_eq Î¹] [fintype Î¹] (e : basis Î¹ R M) (x : orientation R M Î¹) : x = e.orientation âˆ¨ x = -e.orientation
theorem uniform_space.completion.uniform_continuous_dist {Î± : Type u} [pseudo_metric_space Î±] : uniform_continuous (Î» (p : uniform_space.completion Î± Ã— uniform_space.completion Î±), has_dist.dist p.fst p.snd)
theorem continuous_map.homotopy.apply_zero_path {X Y : Top} {f g : C(â†¥X, â†¥Y)} (H : f.homotopy g) {xâ‚€ xâ‚ : â†¥X} (p : fundamental_groupoid.from_top xâ‚€ âŸ¶ fundamental_groupoid.from_top xâ‚) : (fundamental_groupoid.fundamental_groupoid_functor.map f).map p = continuous_map.homotopy.hcast _ â‰« (fundamental_groupoid.fundamental_groupoid_functor.map H.ulift_map).map (continuous_map.homotopy.prod_to_prod_Top_I (ğŸ™ {down := 0}) p) â‰« continuous_map.homotopy.hcast _
theorem convex_independent_iff_not_mem_convex_hull_diff {ğ•œ : Type u_1} {E : Type u_2} {Î¹ : Type u_3} [ordered_semiring ğ•œ] [add_comm_group E] [module ğ•œ E] {p : Î¹ â†’ E} : convex_independent ğ•œ p â†” âˆ€ (i : Î¹) (s : set Î¹), p i âˆ‰ â‡‘(convex_hull ğ•œ) (p '' (s  {i}))
theorem matrix.det_mul_left_comm {m : Type u_1} [decidable_eq m] [fintype m] {R : Type v} [comm_ring R] (M N P : matrix m m R) : (M.mul (N.mul P)).det = (N.mul (M.mul P)).det
theorem add_submonoid.multiset_sum_mem {M : Type u_1} [add_comm_monoid M] (S : add_submonoid M) (m : multiset M) (hm : âˆ€ (a : M), a âˆˆ m â†’ a âˆˆ S) : m.sum âˆˆ S
theorem orthogonal_projection_fn_mem {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {K : submodule ğ•œ E} [complete_space â†¥K] (v : E) : orthogonal_projection_fn K v âˆˆ K
theorem gold_conj_irrational  : irrational golden_conj
theorem exterior_algebra.induction {R : Type u1} [comm_semiring R] {M : Type u2} [add_comm_monoid M] [module R M] {C : exterior_algebra R M â†’ Prop} (h_grade0 : âˆ€ (r : R), C (â‡‘(algebra_map R (exterior_algebra R M)) r)) (h_grade1 : âˆ€ (x : M), C (â‡‘(exterior_algebra.Î¹ R) x)) (h_mul : âˆ€ (a b : exterior_algebra R M), C a â†’ C b â†’ C (a * b)) (h_add : âˆ€ (a b : exterior_algebra R M), C a â†’ C b â†’ C (a + b)) (a : exterior_algebra R M) : C a
theorem finset.le_sum_nonempty_of_subadditive_on_pred {Î¹ : Type u_1} {M : Type u_4} {N : Type u_5} [add_comm_monoid M] [ordered_add_comm_monoid N] (f : M â†’ N) (p : M â†’ Prop) (h_mul : âˆ€ (x y : M), p x â†’ p y â†’ f (x + y) â‰¤ f x + f y) (hp_mul : âˆ€ (x y : M), p x â†’ p y â†’ p (x + y)) (g : Î¹ â†’ M) (s : finset Î¹) (hs_nonempty : s.nonempty) (hs : âˆ€ (i : Î¹), i âˆˆ s â†’ p (g i)) : f (s.sum (Î» (i : Î¹), g i)) â‰¤ s.sum (Î» (i : Î¹), f (g i))
theorem category_theory.is_cofiltered.inf_exists {C : Type u} [category_theory.category C] [category_theory.is_cofiltered C] (O : finset C) (H : finset (Î£' (X Y : C) (mX : X âˆˆ O) (mY : Y âˆˆ O), X âŸ¶ Y)) : âˆƒ (S : C) (T : Î  {X : C}, X âˆˆ O â†’ (S âŸ¶ X)), âˆ€ {X Y : C} (mX : X âˆˆ O) (mY : Y âˆˆ O) {f : X âŸ¶ Y}, âŸ¨X, âŸ¨Y, âŸ¨mX, âŸ¨mY, fâŸ©âŸ©âŸ©âŸ© âˆˆ H â†’ T mX â‰« f = T mY
theorem submodule.is_internal_prime_power_torsion {R : Type u} [comm_ring R] [is_domain R] {M : Type v} [add_comm_group M] [module R M] [is_dedekind_domain R] [module.finite R M] (hM : module.is_torsion R M) : âˆƒ (P : finset (ideal R)) [_inst_7 : decidable_eq â†¥P] [_inst_8 : âˆ€ (p : ideal R), p âˆˆ P â†’ prime p] (e : â†¥P â†’ â„•), direct_sum.is_internal (Î» (p : â†¥P), submodule.torsion_by_set R M â†‘(â†‘p ^ e p))
theorem image_circle_map_Ioc (c : â„‚) (R : â„) : circle_map c R '' set.Ioc 0 (2 * real.pi) = metric.sphere c |R|
theorem real.has_sum_pow_div_log_of_abs_lt_1 {x : â„} (h : |x| < 1) : has_sum (Î» (n : â„•), x ^ (n + 1) / (â†‘n + 1)) (-real.log (1 - x))
theorem nat.coprime_factors_disjoint {a b : â„•} (hab : a.coprime b) : a.factors.disjoint b.factors
theorem add_is_torsion_free.quotient_torsion (G : Type u_1) [add_comm_group G] : add_monoid.is_torsion_free (G â§¸ add_torsion G)
theorem finsupp.lt_wf (Î¹ : Type u_3) : well_founded has_lt.lt
theorem dense_inducing.extend_Z_bilin {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} {Î´ : Type u_4} {G : Type u_5} [topological_space Î±] [add_comm_group Î±] [topological_add_group Î±] [topological_space Î²] [add_comm_group Î²] [topological_add_group Î²] [topological_space Î³] [add_comm_group Î³] [topological_add_group Î³] [topological_space Î´] [add_comm_group Î´] [topological_add_group Î´] [uniform_space G] [add_comm_group G] [uniform_add_group G] [separated_space G] [complete_space G] {e : Î² â†’+ Î±} (de : dense_inducing â‡‘e) {f : Î´ â†’+ Î³} (df : dense_inducing â‡‘f) {Ï† : Î² â†’+ Î´ â†’+ G} (hÏ† : continuous (Î» (p : Î² Ã— Î´), â‡‘(â‡‘Ï† p.fst) p.snd)) : continuous (_.extend (Î» (p : Î² Ã— Î´), â‡‘(â‡‘Ï† p.fst) p.snd))
theorem dim_add_dim_split {K : Type u} {V Vâ‚ Vâ‚‚ Vâ‚ƒ : Type v} [field K] [add_comm_group V] [module K V] [add_comm_group Vâ‚] [module K Vâ‚] [add_comm_group Vâ‚‚] [module K Vâ‚‚] [add_comm_group Vâ‚ƒ] [module K Vâ‚ƒ] (db : Vâ‚‚ â†’â‚—[K] V) (eb : Vâ‚ƒ â†’â‚—[K] V) (cd : Vâ‚ â†’â‚—[K] Vâ‚‚) (ce : Vâ‚ â†’â‚—[K] Vâ‚ƒ) (hde : âŠ¤ â‰¤ db.range âŠ” eb.range) (hgd : cd.ker = âŠ¥) (eq : db.comp cd = eb.comp ce) (eqâ‚‚ : âˆ€ (d : Vâ‚‚) (e : Vâ‚ƒ), â‡‘db d = â‡‘eb e â†’ (âˆƒ (c : Vâ‚), â‡‘cd c = d âˆ§ â‡‘ce c = e)) : module.rank K V + module.rank K Vâ‚ = module.rank K Vâ‚‚ + module.rank K Vâ‚ƒ
theorem is_local_min_on.fderiv_within_nonneg {E : Type u} [normed_group E] [normed_space â„ E] {f : E â†’ â„} {a : E} {s : set E} (h : is_local_min_on f s a) {y : E} (hy : y âˆˆ pos_tangent_cone_at s a) : 0 â‰¤ â‡‘(fderiv_within â„ f s a) y
theorem category_theory.congr_hom {C : Type v} [category_theory.category C] [category_theory.concrete_category C] {X Y : C} {f g : X âŸ¶ Y} (h : f = g) (x : â†¥X) : â‡‘f x = â‡‘g x
theorem ennreal.rpow_arith_mean_le_arith_mean_rpow {Î¹ : Type u} (s : finset Î¹) (w z : Î¹ â†’ ennreal) (hw' : s.sum (Î» (i : Î¹), w i) = 1) {p : â„} (hp : 1 â‰¤ p) : s.sum (Î» (i : Î¹), w i * z i) ^ p â‰¤ s.sum (Î» (i : Î¹), w i * z i ^ p)
theorem finite_dimensional.nonempty_linear_equiv_iff_finrank_eq {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {Vâ‚‚ : Type v'} [add_comm_group Vâ‚‚] [module K Vâ‚‚] [finite_dimensional K V] [finite_dimensional K Vâ‚‚] : nonempty (V â‰ƒâ‚—[K] Vâ‚‚) â†” finite_dimensional.finrank K V = finite_dimensional.finrank K Vâ‚‚
theorem int.gcd_least_linear {a b : â„¤} (ha : a â‰  0) : is_least {n : â„• | 0 < n âˆ§ âˆƒ (x y : â„¤), â†‘n = a * x + b * y} (a.gcd b)
theorem zero_lt.right.one_lt_mul_of_lt_of_le {Î± : Type u} {a b : Î±} [mul_one_class Î±] [has_zero Î±] [preorder Î±] [zero_lt.mul_pos_strict_mono Î±] (ha : 1 < a) (hb : 1 â‰¤ b) (b0 : 0 < b) : 1 < a * b
theorem Gromov_Hausdorff.Hausdorff_dist_optimal_le_HD (X : Type u) (Y : Type v) [metric_space X] [compact_space X] [nonempty X] [metric_space Y] [compact_space Y] [nonempty Y] {f : Cb X Y} (h : f âˆˆ candidates_b X Y) : metric.Hausdorff_dist (set.range (Gromov_Hausdorff.optimal_GH_injl X Y)) (set.range (Gromov_Hausdorff.optimal_GH_injr X Y)) â‰¤ Gromov_Hausdorff.HD f
theorem antisymm_rel.eq {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} [is_refl Î± r] [is_antisymm Î± r] {a b : Î±} : antisymm_rel r a b â†’ a = b
theorem continuous_linear_map.eq_adjoint_iff {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] [inner_product_space ğ•œ F] [complete_space E] [complete_space F] (A : E â†’L[ğ•œ] F) (B : F â†’L[ğ•œ] E) : A = â‡‘continuous_linear_map.adjoint B â†” âˆ€ (x : E) (y : F), has_inner.inner (â‡‘A x) y = has_inner.inner x (â‡‘B y)
theorem asymptotics.is_O_with.of_norm_right {Î± : Type u_1} {E : Type u_3} {F' : Type u_7} [has_norm E] [semi_normed_group F'] {c : â„} {f : Î± â†’ E} {g' : Î± â†’ F'} {l : filter Î±} : asymptotics.is_O_with c l f (Î» (x : Î±), âˆ¥g' xâˆ¥) â†’ asymptotics.is_O_with c l f g'
theorem polynomial.exists_partition_polynomial {Fq : Type u_1} [fintype Fq] [field Fq] (n : â„•) {Îµ : â„} (hÎµ : 0 < Îµ) {b : polynomial Fq} (hb : b â‰  0) (A : fin n â†’ polynomial Fq) : âˆƒ (t : fin n â†’ fin (fintype.card Fq ^ âŒˆ-real.log Îµ / real.log â†‘(fintype.card Fq)âŒ‰â‚Š)), âˆ€ (iâ‚€ iâ‚ : fin n), t iâ‚€ = t iâ‚ â†’ â†‘(â‡‘polynomial.card_pow_degree (A iâ‚ % b - A iâ‚€ % b)) < â‡‘polynomial.card_pow_degree b â€¢ Îµ
theorem monoid_hom.map_list_prod {M : Type u_3} {N : Type u_4} [monoid M] [monoid N] (f : M â†’* N) (l : list M) : â‡‘f l.prod = (list.map â‡‘f l).prod
theorem fin.coe_fin_le {n : â„•} {a b : fin n} : â†‘a â‰¤ â†‘b â†” a â‰¤ b
theorem is_atom.bot_covby {Î± : Type u_1} [partial_order Î±] [order_bot Î±] {a : Î±} : is_atom a â†’ âŠ¥ â‹– a
theorem pred_lt_pred {Î± : Type u_1} [preorder Î±] [pred_order Î±] {a b : Î±} [no_min_order Î±] : a < b â†’ order.pred a < order.pred b
theorem generalized_continued_fraction.of_h_eq_floor {K : Type u_1} [linear_ordered_field K] [floor_ring K] {v : K} : (generalized_continued_fraction.of v).h = â†‘âŒŠvâŒ‹
theorem category_theory.limits.has_zero_morphisms.ext {C : Type u} [category_theory.category C] (I J : category_theory.limits.has_zero_morphisms C) : I = J
theorem padic_seq.stationary {p : â„•} [fact (nat.prime p)] {f : cau_seq â„š (padic_norm p)} (hf : Â¬f â‰ˆ 0) : âˆƒ (N : â„•), âˆ€ (m n : â„•), N â‰¤ m â†’ N â‰¤ n â†’ padic_norm p (â‡‘f n) = padic_norm p (â‡‘f m)
theorem power_series.nat_le_order {R : Type u_1} [semiring R] (Ï† : power_series R) (n : â„•) (h : âˆ€ (i : â„•), i < n â†’ â‡‘(power_series.coeff R i) Ï† = 0) : â†‘n â‰¤ Ï†.order
theorem measure_theory.measure_of_cont_bdd_of_tendsto_filter_indicator {Î± : Type u_1} [measurable_space Î±] {Î¹ : Type u_2} {L : filter Î¹} [L.is_countably_generated] [topological_space Î±] [opens_measurable_space Î±] (Î¼ : measure_theory.finite_measure Î±) {c : nnreal} {E : set Î±} (E_mble : measurable_set E) (fs : Î¹ â†’ bounded_continuous_function Î± nnreal) (fs_bdd : âˆ€á¶  (i : Î¹) in L, âˆ€áµ (a : Î±) âˆ‚â†‘Î¼, â‡‘(fs i) a â‰¤ c) (fs_lim : âˆ€áµ (a : Î±) âˆ‚â†‘Î¼, filter.tendsto (Î» (i : Î¹), â‡‘(fs i) a) L (nhds (E.indicator (Î» (x : Î±), 1) a))) : filter.tendsto (Î» (n : Î¹), âˆ«â» (a : Î±), â†‘(â‡‘(fs n) a) âˆ‚â†‘Î¼) L (nhds (â‡‘â†‘Î¼ E))
theorem krull_topology_totally_disconnected {K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (h_int : algebra.is_integral K L) : is_totally_disconnected set.univ
theorem category_theory.limits.cocones.cocone_iso_of_hom_iso {J : Type uâ‚} [category_theory.category J] {C : Type uâ‚ƒ} [category_theory.category C] {K : J â¥¤ C} {c d : category_theory.limits.cocone K} (f : c âŸ¶ d) [i : category_theory.is_iso f.hom] : category_theory.is_iso f
theorem is_of_fin_order_zero {G : Type u} [add_monoid G] : is_of_fin_add_order 0
theorem set_has_maximal_iff_noetherian {R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] : (âˆ€ (a : set (submodule R M)), a.nonempty â†’ (âˆƒ (M' : submodule R M) (H : M' âˆˆ a), âˆ€ (I : submodule R M), I âˆˆ a â†’ M' â‰¤ I â†’ I = M')) â†” is_noetherian R M
theorem is_add_left_regular.add {R : Type u_1} {a b : R} [add_semigroup R] (lra : is_add_left_regular a) (lrb : is_add_left_regular b) : is_add_left_regular (a + b)
theorem orthonormal.two_zsmul_oangle_smul_left_of_ne_zero {V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) (x y : V) {r : â„} (hr : r â‰  0) : 2 â€¢ hb.oangle (r â€¢ x) y = 2 â€¢ hb.oangle x y
theorem measure_theory.measure_eq_infi' {Î± : Type u_1} [measurable_space Î±] (Î¼ : measure_theory.measure Î±) (s : set Î±) : â‡‘Î¼ s = â¨… (t : {t // s âŠ† t âˆ§ measurable_set t}), â‡‘Î¼ â†‘t
theorem euclidean_geometry.orthocentric_system.eq_insert_orthocenter {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {s : set P} (ho : euclidean_geometry.orthocentric_system s) {t : affine.triangle â„ P} (ht : set.range t.points âŠ† s) : s = has_insert.insert t.orthocenter (set.range t.points)
theorem add_equiv.map_sub {G : Type u_10} {H : Type u_11} [add_group G] [subtraction_monoid H] (h : G â‰ƒ+ H) (x y : G) : â‡‘h (x - y) = â‡‘h x - â‡‘h y
theorem matrix.adjugate_adjugate' {n : Type u} [decidable_eq n] [fintype n] {Î± : Type v} [comm_ring Î±] (A : matrix n n Î±) [nontrivial n] : A.adjugate.adjugate = A.det ^ (fintype.card n - 2) â€¢ A
theorem ordered_comm_group.lt_of_mul_lt_mul_left {Î± : Type u_1} [has_mul Î±] [has_lt Î±] [contravariant_class Î± Î± has_mul.mul has_lt.lt] {a b c : Î±} (bc : a * b < a * c) : b < c
theorem cont_diff_iff_iterated_deriv {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {F : Type u_2} [normed_group F] [normed_space ğ•œ F] {f : ğ•œ â†’ F} {n : with_top â„•} : cont_diff ğ•œ n f â†” (âˆ€ (m : â„•), â†‘m â‰¤ n â†’ continuous (iterated_deriv m f)) âˆ§ âˆ€ (m : â„•), â†‘m < n â†’ differentiable ğ•œ (iterated_deriv m f)
theorem measure_theory.Lp.bounded_continuous_function_dense {Î± : Type u_1} [measurable_space Î±] [topological_space Î±] [normal_space Î±] [borel_space Î±] (E : Type u_2) [normed_group E] [second_countable_topology_either Î± E] {p : ennreal} [fact (1 â‰¤ p)] (hp : p â‰  âŠ¤) (Î¼ : measure_theory.measure Î±) [normed_space â„ E] [Î¼.weakly_regular] : (measure_theory.Lp.bounded_continuous_function E p Î¼).topological_closure = âŠ¤
theorem polynomial.X_mul_C {R : Type u} [semiring R] (r : R) : polynomial.X * â‡‘polynomial.C r = â‡‘polynomial.C r * polynomial.X
theorem category_theory.ProjectiveResolution.lift_commutes {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_equalizers C] [category_theory.limits.has_images C] {Y Z : C} (f : Y âŸ¶ Z) (P : category_theory.ProjectiveResolution Y) (Q : category_theory.ProjectiveResolution Z) : category_theory.ProjectiveResolution.lift f P Q â‰« Q.Ï€ = P.Ï€ â‰« (chain_complex.singleâ‚€ C).map f
theorem setoid.sup_def {Î± : Type u_1} {r s : setoid Î±} : r âŠ” s = eqv_gen.setoid (r.rel âŠ” s.rel)
theorem lipschitz_with.norm_sub_le {E : Type u_3} {F : Type u_4} [semi_normed_group E] [semi_normed_group F] {f : E â†’ F} {C : nnreal} : lipschitz_with C f â†’ âˆ€ (x y : E), âˆ¥f x - f yâˆ¥ â‰¤ â†‘C * âˆ¥x - yâˆ¥
theorem smooth_smul {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {V : Type u_14} [normed_group V] [normed_space ğ•œ V] : smooth ((model_with_corners_self ğ•œ ğ•œ).prod (model_with_corners_self ğ•œ V)) (model_with_corners_self ğ•œ V) (Î» (p : ğ•œ Ã— V), p.fst â€¢ p.snd)
theorem ordinal.induction {p : ordinal â†’ Prop} (i : ordinal) (h : âˆ€ (j : ordinal), (âˆ€ (k : ordinal), k < j â†’ p k) â†’ p j) : p i
theorem norm_sub_sq_real {F : Type u_3} [inner_product_space â„ F] {x y : F} : âˆ¥x - yâˆ¥ ^ 2 = âˆ¥xâˆ¥ ^ 2 - 2 * has_inner.inner x y + âˆ¥yâˆ¥ ^ 2
theorem real.sinh_injective  : function.injective real.sinh
theorem category_theory.cover_preserving.comp {C : Type uâ‚} [category_theory.category C] {D : Type uâ‚‚} [category_theory.category D] {A : Type uâ‚ƒ} [category_theory.category A] (J : category_theory.grothendieck_topology C) (K : category_theory.grothendieck_topology D) {L : category_theory.grothendieck_topology A} {F : C â¥¤ D} (hF : category_theory.cover_preserving J K F) {G : D â¥¤ A} (hG : category_theory.cover_preserving K L G) : category_theory.cover_preserving J L (F â‹™ G)
theorem probability_theory.cond_add_cond_compl_eq {Î± : Type u_1} {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) {s t : set Î±} [measure_theory.is_finite_measure Î¼] (hms : measurable_set s) (hcs : â‡‘Î¼ s â‰  0) (hcs' : â‡‘Î¼ sá¶œ â‰  0) : â‡‘(probability_theory.cond Î¼ s) t * â‡‘Î¼ s + â‡‘(probability_theory.cond Î¼ sá¶œ) t * â‡‘Î¼ sá¶œ = â‡‘Î¼ t
theorem strict_convex_on.translate_right {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [ordered_semiring ğ•œ] [add_cancel_comm_monoid E] [ordered_add_comm_monoid Î²] [module ğ•œ E] [has_scalar ğ•œ Î²] {s : set E} {f : E â†’ Î²} (hf : strict_convex_on ğ•œ s f) (c : E) : strict_convex_on ğ•œ ((Î» (z : E), c + z) â»Â¹' s) (f âˆ˜ Î» (z : E), c + z)
theorem right.neg_pos_iff {Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a : Î±} : 0 < -a â†” a < 0
theorem mem_uniformity_edist {Î± : Type u} [pseudo_emetric_space Î±] {s : set (Î± Ã— Î±)} : s âˆˆ uniformity Î± â†” âˆƒ (Îµ : ennreal) (H : Îµ > 0), âˆ€ {a b : Î±}, has_edist.edist a b < Îµ â†’ (a, b) âˆˆ s
theorem con.inv {M : Type u_1} [group M] (c : con M) {w x : M} : â‡‘c w x â†’ â‡‘c wâ»Â¹ xâ»Â¹
theorem clifford_algebra.involute_prod_map_Î¹ {R : Type u_1} [comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {Q : quadratic_form R M} (l : list M) : â‡‘clifford_algebra.involute (list.map â‡‘(clifford_algebra.Î¹ Q) l).prod = (-1) ^ l.length â€¢ (list.map â‡‘(clifford_algebra.Î¹ Q) l).prod
theorem is_preirreducible_iff_closed_union_closed {Î± : Type u} [topological_space Î±] {s : set Î±} : is_preirreducible s â†” âˆ€ (zâ‚ zâ‚‚ : set Î±), is_closed zâ‚ â†’ is_closed zâ‚‚ â†’ s âŠ† zâ‚ âˆª zâ‚‚ â†’ s âŠ† zâ‚ âˆ¨ s âŠ† zâ‚‚
theorem submodule.map_subtype_top {R : Type u_1} {M : Type u_9} [semiring R] [add_comm_monoid M] [module R M] (p : submodule R M) : submodule.map p.subtype âŠ¤ = p
theorem surjective_quotient_mk (Î± : Sort u_1) [s : setoid Î±] : function.surjective quotient.mk
theorem add_monoid_hom.mrange_top_of_surjective {M : Type u_1} [add_zero_class M] {N : Type u_2} [add_zero_class N] (f : M â†’+ N) (hf : function.surjective â‡‘f) : f.mrange = âŠ¤
theorem complex.differentiable_on_update_lim_of_is_o {E : Type u} [normed_group E] [normed_space â„‚ E] [complete_space E] {f : â„‚ â†’ E} {s : set â„‚} {c : â„‚} (hc : s âˆˆ nhds c) (hd : differentiable_on â„‚ f (s  {c})) (ho : (Î» (z : â„‚), f z - f c) =o[nhds_within c {c}á¶œ] Î» (z : â„‚), (z - c)â»Â¹) : differentiable_on â„‚ (function.update f c (lim (nhds_within c {c}á¶œ) f)) s
theorem matrix.adjugate_adjugate {n : Type u} [decidable_eq n] [fintype n] {Î± : Type v} [comm_ring Î±] (A : matrix n n Î±) (h : fintype.card n â‰  1) : A.adjugate.adjugate = A.det ^ (fintype.card n - 2) â€¢ A
theorem integral_sin_pow {a b : â„} (n : â„•) : âˆ« (x : â„) in a..b, real.sin x ^ (n + 2) = (real.sin a ^ (n + 1) * real.cos a - real.sin b ^ (n + 1) * real.cos b) / (â†‘n + 2) + (â†‘n + 1) / (â†‘n + 2) * âˆ« (x : â„) in a..b, real.sin x ^ n
theorem affine.simplex.direction_altitude {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {n : â„•} (s : affine.simplex â„ P (n + 1)) (i : fin (n + 2)) : (s.altitude i).direction = (vector_span â„ (s.points '' â†‘(finset.univ.erase i)))á—® âŠ“ vector_span â„ (set.range s.points)
theorem complete_lattice.independent_iff_dfinsupp_lsum_injective {Î¹ : Type u_1} {R : Type u_2} {N : Type u_5} [dec_Î¹ : decidable_eq Î¹] [ring R] [add_comm_group N] [module R N] (p : Î¹ â†’ submodule R N) : complete_lattice.independent p â†” function.injective â‡‘(â‡‘(dfinsupp.lsum â„•) (Î» (i : Î¹), (p i).subtype))
theorem nat.multiplicative_factorization {Î² : Type u_1} [comm_monoid Î²] (f : â„• â†’ Î²) (h_mult : âˆ€ (x y : â„•), x.coprime y â†’ f (x * y) = f x * f y) (hf : f 1 = 1) {n : â„•} : n â‰  0 â†’ f n = n.factorization.prod (Î» (p k : â„•), f (p ^ k))
theorem order.pfilter.top_mem {P : Type u_1} [preorder P] [order_top P] {F : order.pfilter P} : âŠ¤ âˆˆ F
theorem group.normal_closure_subset {G : Type u_1} [group G] {s t : set G} (ht : is_normal_subgroup t) (h : s âŠ† t) : group.normal_closure s âŠ† t
theorem has_ftaylor_series_up_to_succ_iff_right {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {f : E â†’ F} {p : E â†’ formal_multilinear_series ğ•œ E F} {n : â„•} : has_ftaylor_series_up_to â†‘(n + 1) f p â†” (âˆ€ (x : E), (p x 0).uncurry0 = f x) âˆ§ (âˆ€ (x : E), has_fderiv_at (Î» (y : E), p y 0) (p x 1).curry_left x) âˆ§ has_ftaylor_series_up_to â†‘n (Î» (x : E), â‡‘(continuous_multilinear_curry_fin1 ğ•œ E F) (p x 1)) (Î» (x : E), (p x).shift)
theorem subsingleton_floor_semiring {Î± : Type u_1} [linear_ordered_semiring Î±] : subsingleton (floor_semiring Î±)
theorem add_con.lift_unique {M : Type u_1} {P : Type u_3} [add_zero_class M] [add_zero_class P] {c : add_con M} {f : M â†’+ P} (H : c â‰¤ add_con.ker f) (g : c.quotient â†’+ P) (Hg : g.comp c.mk' = f) : g = c.lift f H
theorem nnreal.has_sum_geometric {r : nnreal} (hr : r < 1) : has_sum (Î» (n : â„•), r ^ n) (1 - r)â»Â¹
theorem smooth_partition_of_unity.is_subordinate.to_partition_of_unity {Î¹ : Type uÎ¹} {E : Type uE} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] {H : Type uH} [topological_space H] {I : model_with_corners â„ E H} {M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {s : set M} {f : smooth_partition_of_unity Î¹ I M s} {U : Î¹ â†’ set M} : f.is_subordinate U â†’ f.to_partition_of_unity.is_subordinate U
theorem finset.prod_add_ordered {Î¹ : Type u_1} {R : Type u_2} [comm_semiring R] [linear_order Î¹] (s : finset Î¹) (f g : Î¹ â†’ R) : s.prod (Î» (i : Î¹), f i + g i) = s.prod (Î» (i : Î¹), f i) + s.sum (Î» (i : Î¹), g i * (finset.filter (Î» (_x : Î¹), _x < i) s).prod (Î» (j : Î¹), f j + g j) * (finset.filter (Î» (j : Î¹), i < j) s).prod (Î» (j : Î¹), f j))
theorem emetric.complete_of_cauchy_seq_tendsto {Î± : Type u} [pseudo_emetric_space Î±] : (âˆ€ (u : â„• â†’ Î±), cauchy_seq u â†’ (âˆƒ (a : Î±), filter.tendsto u filter.at_top (nhds a))) â†’ complete_space Î±
theorem metric.thickening_mono {Î± : Type u} [pseudo_emetric_space Î±] {Î´â‚ Î´â‚‚ : â„} (hle : Î´â‚ â‰¤ Î´â‚‚) (E : set Î±) : metric.thickening Î´â‚ E âŠ† metric.thickening Î´â‚‚ E
theorem polynomial.coprime_of_root_cyclotomic {n : â„•} (hpos : 0 < n) {p : â„•} [hprime : fact (nat.prime p)] {a : â„•} (hroot : (polynomial.cyclotomic n (zmod p)).is_root (â‡‘(nat.cast_ring_hom (zmod p)) a)) : a.coprime p
theorem matrix.is_symm.ext {Î± : Type u_1} {n : Type u_3} {A : matrix n n Î±} : (âˆ€ (i j : n), A j i = A i j) â†’ A.is_symm
theorem emetric.tendsto_uniformly_on_iff {Î± : Type u} {Î² : Type v} [pseudo_emetric_space Î±] {Î¹ : Type u_1} {F : Î¹ â†’ Î² â†’ Î±} {f : Î² â†’ Î±} {p : filter Î¹} {s : set Î²} : tendsto_uniformly_on F f p s â†” âˆ€ (Îµ : ennreal), Îµ > 0 â†’ (âˆ€á¶  (n : Î¹) in p, âˆ€ (x : Î²), x âˆˆ s â†’ has_edist.edist (f x) (F n x) < Îµ)
theorem ODE_solution_unique_of_mem_set {E : Type u_1} [normed_group E] [normed_space â„ E] {v : â„ â†’ E â†’ E} {s : â„ â†’ set E} {K : â„} (hv : âˆ€ (t : â„) (x : E), x âˆˆ s t â†’ âˆ€ (y : E), y âˆˆ s t â†’ has_dist.dist (v t x) (v t y) â‰¤ K * has_dist.dist x y) {f g : â„ â†’ E} {a b : â„} (hf : continuous_on f (set.Icc a b)) (hf' : âˆ€ (t : â„), t âˆˆ set.Ico a b â†’ has_deriv_within_at f (v t (f t)) (set.Ici t) t) (hfs : âˆ€ (t : â„), t âˆˆ set.Ico a b â†’ f t âˆˆ s t) (hg : continuous_on g (set.Icc a b)) (hg' : âˆ€ (t : â„), t âˆˆ set.Ico a b â†’ has_deriv_within_at g (v t (g t)) (set.Ici t) t) (hgs : âˆ€ (t : â„), t âˆˆ set.Ico a b â†’ g t âˆˆ s t) (ha : f a = g a) (t : â„) (H : t âˆˆ set.Icc a b) : f t = g t
theorem category_theory.hom_orthogonal.equiv_of_iso {C : Type u} [category_theory.category C] {Î¹ : Type u_1} {s : Î¹ â†’ C} [category_theory.preadditive C] [category_theory.limits.has_finite_biproducts C] [âˆ€ (i : Î¹), invariant_basis_number (category_theory.End (s i))] (o : category_theory.hom_orthogonal s) {Î± Î² : Type v} [fintype Î±] [fintype Î²] {f : Î± â†’ Î¹} {g : Î² â†’ Î¹} (i : (â¨ Î» (a : Î±), s (f a)) â‰… â¨ Î» (b : Î²), s (g b)) : âˆƒ (e : Î± â‰ƒ Î²), âˆ€ (a : Î±), g (â‡‘e a) = f a
theorem category_theory.presieve.family_of_elements.compatible.restrict {C : Type uâ‚} [category_theory.category C] {P : Cáµ’áµ– â¥¤ Type w} {X : C} {Râ‚ Râ‚‚ : category_theory.presieve X} (h : Râ‚ â‰¤ Râ‚‚) {x : category_theory.presieve.family_of_elements P Râ‚‚} : x.compatible â†’ (category_theory.presieve.family_of_elements.restrict h x).compatible
theorem filter.map_mapâ‚‚_distrib_left {Î± : Type u_1} {Î±' : Type u_2} {Î² : Type u_3} {Î³ : Type u_5} {Î´ : Type u_7} {m : Î± â†’ Î² â†’ Î³} {f : filter Î±} {g : filter Î²} {n : Î³ â†’ Î´} {m' : Î±' â†’ Î² â†’ Î´} {n' : Î± â†’ Î±'} (h_distrib : âˆ€ (a : Î±) (b : Î²), n (m a b) = m' (n' a) b) : filter.map n (filter.mapâ‚‚ m f g) = filter.mapâ‚‚ m' (filter.map n' f) g
theorem finset.sum_range_id_mul_two (n : â„•) : (finset.range n).sum (Î» (i : â„•), i) * 2 = n * (n - 1)
theorem finset.le_prod_nonempty_of_submultiplicative {Î¹ : Type u_1} {M : Type u_4} {N : Type u_5} [comm_monoid M] [ordered_comm_monoid N] (f : M â†’ N) (h_mul : âˆ€ (x y : M), f (x * y) â‰¤ f x * f y) {s : finset Î¹} (hs : s.nonempty) (g : Î¹ â†’ M) : f (s.prod (Î» (i : Î¹), g i)) â‰¤ s.prod (Î» (i : Î¹), f (g i))
theorem has_ssubset.ssubset.trans {Î± : Type u} [has_ssubset Î±] [is_trans Î± has_ssubset.ssubset] {a b c : Î±} : a âŠ‚ b â†’ b âŠ‚ c â†’ a âŠ‚ c
theorem real.has_strict_fderiv_at_rpow_of_neg (p : â„ Ã— â„) (hp : p.fst < 0) : has_strict_fderiv_at (Î» (x : â„ Ã— â„), x.fst ^ x.snd) ((p.snd * p.fst ^ (p.snd - 1)) â€¢ continuous_linear_map.fst â„ â„ â„ + (p.fst ^ p.snd * real.log p.fst - real.exp (real.log p.fst * p.snd) * real.sin (p.snd * real.pi) * real.pi) â€¢ continuous_linear_map.snd â„ â„ â„) p
theorem monotone_stabilizes_iff_noetherian {R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] : (âˆ€ (f : â„• â†’o submodule R M), âˆƒ (n : â„•), âˆ€ (m : â„•), n â‰¤ m â†’ â‡‘f n = â‡‘f m) â†” is_noetherian R M
theorem commute.refl {S : Type u_1} [has_mul S] (a : S) : commute a a
theorem category_theory.congr_arg_mpr_hom_left {C : Type uâ‚} [category_theory.category C] {X Y Z : C} (p : X = Y) (q : Y âŸ¶ Z) : _.mpr q = category_theory.eq_to_hom p â‰« q
theorem right.neg_neg_iff {Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a : Î±} : -a < 0 â†” 0 < a
theorem alexandroff.dense_range_coe {X : Type u_1} [topological_space X] [noncompact_space X] : dense_range coe
theorem convex_on.map_center_mass_le {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} {Î¹ : Type u_5} [linear_ordered_field ğ•œ] [add_comm_group E] [ordered_add_comm_group Î²] [module ğ•œ E] [module ğ•œ Î²] [ordered_smul ğ•œ Î²] {s : set E} {f : E â†’ Î²} {t : finset Î¹} {w : Î¹ â†’ ğ•œ} {p : Î¹ â†’ E} (hf : convex_on ğ•œ s f) (hâ‚€ : âˆ€ (i : Î¹), i âˆˆ t â†’ 0 â‰¤ w i) (hâ‚ : 0 < t.sum (Î» (i : Î¹), w i)) (hmem : âˆ€ (i : Î¹), i âˆˆ t â†’ p i âˆˆ s) : f (t.center_mass w p) â‰¤ t.center_mass w (f âˆ˜ p)
theorem orthonormal.oangle_conj_lie {V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) (x y : V) : hb.oangle (â‡‘(hb.conj_lie) x) (â‡‘(hb.conj_lie) y) = -hb.oangle x y
theorem generalized_continued_fraction.nth_of_eq_some_of_nth_int_fract_pair_stream_fr_ne_zero {K : Type u_1} [linear_ordered_field K] [floor_ring K] {v : K} {n : â„•} {ifp_n : generalized_continued_fraction.int_fract_pair K} (stream_nth_eq : generalized_continued_fraction.int_fract_pair.stream v n = option.some ifp_n) (nth_fr_ne_zero : ifp_n.fr â‰  0) : (generalized_continued_fraction.of v).s.nth n = option.some {a := 1, b := â†‘((generalized_continued_fraction.int_fract_pair.of (ifp_n.fr)â»Â¹).b)}
theorem affine.triangle.orthocenter_mem_altitude {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] (t : affine.triangle â„ P) {iâ‚ : fin 3} : t.orthocenter âˆˆ affine.simplex.altitude t iâ‚
theorem dvd_neg {Î± : Type u} [semigroup Î±] [has_distrib_neg Î±] (a b : Î±) : a âˆ£ -b â†” a âˆ£ b
theorem euclidean_geometry.angle_eq_zero_of_angle_eq_pi_left {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {p1 p2 p3 : P} (h : euclidean_geometry.angle p1 p2 p3 = real.pi) : euclidean_geometry.angle p2 p1 p3 = 0
theorem topological_add_group.path_connected {E : Type u_2} [add_comm_group E] [module â„ E] [topological_space E] [topological_add_group E] [has_continuous_smul â„ E] : path_connected_space E
theorem add_neg_of_neg_of_nonpos {Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : a < 0) (hb : b â‰¤ 0) : a + b < 0
theorem same_ray_iff_inv_norm_smul_eq_of_ne {F : Type u_2} [normed_group F] [normed_space â„ F] {x y : F} (hx : x â‰  0) (hy : y â‰  0) : same_ray â„ x y â†” âˆ¥xâˆ¥â»Â¹ â€¢ x = âˆ¥yâˆ¥â»Â¹ â€¢ y
theorem same_ray.trans {R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {x y z : M} (hxy : same_ray R x y) (hyz : same_ray R y z) (hy : y = 0 â†’ x = 0 âˆ¨ z = 0) : same_ray R x z
theorem unique_topology_of_t2 {ğ•œ : Type u} [hnorm : nondiscrete_normed_field ğ•œ] {t : topological_space ğ•œ} (hâ‚ : topological_add_group ğ•œ) (hâ‚‚ : has_continuous_smul ğ•œ ğ•œ) (hâ‚ƒ : t2_space ğ•œ) : t = uniform_space.to_topological_space
theorem infi_and' {Î± : Type u_1} [complete_lattice Î±] {p q : Prop} {s : p â†’ q â†’ Î±} : (â¨… (hâ‚ : p) (hâ‚‚ : q), s hâ‚ hâ‚‚) = â¨… (h : p âˆ§ q), s _ _
theorem ring_hom.map_list_prod {Î² : Type u} {Î³ : Type w} [semiring Î²] [semiring Î³] (f : Î² â†’+* Î³) (l : list Î²) : â‡‘f l.prod = (list.map â‡‘f l).prod
theorem add_con.sub {M : Type u_1} [add_group M] (c : add_con M) {w x y z : M} : â‡‘c w x â†’ â‡‘c y z â†’ â‡‘c (w - y) (x - z)
theorem polynomial.degree_pos_induction_on {R : Type u} [semiring R] {P : polynomial R â†’ Prop} (p : polynomial R) (h0 : 0 < p.degree) (hC : âˆ€ {a : R}, a â‰  0 â†’ P (â‡‘polynomial.C a * polynomial.X)) (hX : âˆ€ {p : polynomial R}, 0 < p.degree â†’ P p â†’ P (p * polynomial.X)) (hadd : âˆ€ {p : polynomial R} {a : R}, 0 < p.degree â†’ P p â†’ P (p + â‡‘polynomial.C a)) : P p
theorem ae_eq_const_or_norm_integral_lt_of_norm_le_const {Î± : Type u_1} {E : Type u_2} {m0 : measurable_space Î±} [normed_group E] [normed_space â„ E] [complete_space E] {Î¼ : measure_theory.measure Î±} {f : Î± â†’ E} {C : â„} [strict_convex_space â„ E] [measure_theory.is_finite_measure Î¼] (h_le : âˆ€áµ (x : Î±) âˆ‚Î¼, âˆ¥f xâˆ¥ â‰¤ C) : f =áµ[Î¼] function.const Î± (â¨ (x : Î±), f x âˆ‚Î¼) âˆ¨ âˆ¥âˆ« (x : Î±), f x âˆ‚Î¼âˆ¥ < (â‡‘Î¼ set.univ).to_real * C
theorem seq.terminated_stable {Î± : Type u} (s : seq Î±) {m n : â„•} (m_le_n : m â‰¤ n) (terminated_at_m : s.terminated_at m) : s.terminated_at n
theorem add_salem_spencer.le_roth_number_nat {k n : â„•} (s : finset â„•) (hs : add_salem_spencer â†‘s) (hsn : âˆ€ (x : â„•), x âˆˆ s â†’ x < n) (hsk : s.card = k) : k â‰¤ â‡‘roth_number_nat n
theorem strict_anti_on.dual_left {Î± : Type u} {Î² : Type v} [preorder Î±] [preorder Î²] {f : Î± â†’ Î²} {s : set Î±} : strict_anti_on f s â†’ strict_mono_on (f âˆ˜ â‡‘order_dual.of_dual) s
theorem fintype.exists_infinite_fiber {Î± : Type u_1} {Î² : Type u_2} [infinite Î±] [fintype Î²] (f : Î± â†’ Î²) : âˆƒ (y : Î²), infinite â†¥(f â»Â¹' {y})
theorem filter.exists_seq_tendsto {Î± : Type u_3} (f : filter Î±) [f.is_countably_generated] [f.ne_bot] : âˆƒ (x : â„• â†’ Î±), filter.tendsto x filter.at_top f
theorem set.eq_on.of_subset_closure {Î± : Type u} {Î² : Type v} [topological_space Î±] [topological_space Î²] [t2_space Î±] {s t : set Î²} {f g : Î² â†’ Î±} (h : set.eq_on f g s) (hf : continuous_on f t) (hg : continuous_on g t) (hst : s âŠ† t) (hts : t âŠ† closure s) : set.eq_on f g t
theorem ideal.polynomial_mem_ideal_of_coeff_mem_ideal {R : Type u} [comm_semiring R] (I : ideal (polynomial R)) (p : polynomial R) (hp : âˆ€ (n : â„•), p.coeff n âˆˆ ideal.comap polynomial.C I) : p âˆˆ I
theorem is_min.of_dual {Î± : Type u_1} [has_le Î±] {a : Î±áµ’áµˆ} : is_min a â†’ is_max (â‡‘order_dual.of_dual a)
theorem local_homeomorph.is_o_congr {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] {E : Type u_3} [has_norm E] {F : Type u_4} [has_norm F] (e : local_homeomorph Î± Î²) {b : Î²} (hb : b âˆˆ e.to_local_equiv.target) {f : Î² â†’ E} {g : Î² â†’ F} : f =o[nhds b] g â†” (f âˆ˜ â‡‘e) =o[nhds (â‡‘(e.symm) b)] (g âˆ˜ â‡‘e)
theorem asymptotics.is_O_with.norm_norm {Î± : Type u_1} {E' : Type u_6} {F' : Type u_7} [semi_normed_group E'] [semi_normed_group F'] {c : â„} {f' : Î± â†’ E'} {g' : Î± â†’ F'} {l : filter Î±} : asymptotics.is_O_with c l f' g' â†’ asymptotics.is_O_with c l (Î» (x : Î±), âˆ¥f' xâˆ¥) (Î» (x : Î±), âˆ¥g' xâˆ¥)
theorem small.mk' {Î± : Type v} {S : Type w} (e : Î± â‰ƒ S) : small Î±
theorem topological_group.continuous_conj' {G : Type w} [topological_space G] [has_inv G] [has_mul G] [has_continuous_mul G] [has_continuous_inv G] (h : G) : continuous (Î» (g : G), g * h * gâ»Â¹)
theorem lt_of_inv_lt_inv {Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] [covariant_class Î± Î± (function.swap has_mul.mul) has_lt.lt] {a b : Î±} : aâ»Â¹ < bâ»Â¹ â†’ b < a
theorem finset.sum_product' {Î² : Type u} {Î± : Type v} {Î³ : Type w} [add_comm_monoid Î²] {s : finset Î³} {t : finset Î±} {f : Î³ â†’ Î± â†’ Î²} : (s.product t).sum (Î» (x : Î³ Ã— Î±), f x.fst x.snd) = s.sum (Î» (x : Î³), t.sum (Î» (y : Î±), f x y))
theorem torus_integrable.add {n : â„•} {E : Type u_1} [normed_group E] {f g : (fin n â†’ â„‚) â†’ E} {c : fin n â†’ â„‚} {R : fin n â†’ â„} (hf : torus_integrable f c R) (hg : torus_integrable g c R) : torus_integrable (f + g) c R
theorem pseudo_metric.uniformity_basis_edist {Î± : Type u} [pseudo_metric_space Î±] : (uniformity Î±).has_basis (Î» (Îµ : ennreal), 0 < Îµ) (Î» (Îµ : ennreal), {p : Î± Ã— Î± | has_edist.edist p.fst p.snd < Îµ})
theorem unique_mdiff_on.unique_diff_on_inter_preimage {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {M : Type u_4} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners ğ•œ E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] {s : set M} (hs : unique_mdiff_on I s) (x : M) (y : M') {f : M â†’ M'} (hf : continuous_on f s) : unique_diff_on ğ•œ ((ext_chart_at I x).target âˆ© â‡‘((ext_chart_at I x).symm) â»Â¹' (s âˆ© f â»Â¹' (ext_chart_at I' y).source))
theorem ideal.has_basis_nhds_zero_adic {R : Type u_1} [comm_ring R] (I : ideal R) : (nhds 0).has_basis (Î» (n : â„•), true) (Î» (n : â„•), â†‘(I ^ n))
theorem measure_theory.ae_of_forall_measure_lt_top_ae_restrict {Î± : Type u_1} {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [measure_theory.sigma_finite Î¼] (P : Î± â†’ Prop) (h : âˆ€ (s : set Î±), measurable_set s â†’ â‡‘Î¼ s < âŠ¤ â†’ (âˆ€áµ (x : Î±) âˆ‚Î¼.restrict s, P x)) : âˆ€áµ (x : Î±) âˆ‚Î¼, P x
theorem differentiable.exists_eq_const_of_bounded {E : Type u} [normed_group E] [normed_space â„‚ E] {F : Type v} [normed_group F] [normed_space â„‚ F] {f : E â†’ F} (hf : differentiable â„‚ f) (hb : metric.bounded (set.range f)) : âˆƒ (c : F), f = function.const E c
theorem complex.abs_exp_mul_exp_add_exp_neg_le_of_abs_im_le {a b : â„} (ha : a â‰¤ 0) {z : â„‚} (hz : |z.im| â‰¤ b) (hb : b â‰¤ real.pi / 2) : complex.abs (complex.exp (â†‘a * (complex.exp z + complex.exp (-z)))) â‰¤ real.exp (a * real.cos b * real.exp |z.re|)
theorem polynomial.has_separable_contraction.dvd_degree {F : Type} [comm_semiring F] {q : â„•} {f : polynomial F} (hf : polynomial.has_separable_contraction q f) : hf.degree âˆ£ f.nat_degree
theorem measure_theory.mem_â„’p.mono {Î± : Type u_1} {E : Type u_2} {F : Type u_3} {m0 : measurable_space Î±} {p : ennreal} {Î¼ : measure_theory.measure Î±} [normed_group E] [normed_group F] {f : Î± â†’ E} {g : Î± â†’ F} (hg : measure_theory.mem_â„’p g p Î¼) (hf : measure_theory.ae_strongly_measurable f Î¼) (hfg : âˆ€áµ (x : Î±) âˆ‚Î¼, âˆ¥f xâˆ¥ â‰¤ âˆ¥g xâˆ¥) : measure_theory.mem_â„’p f p Î¼
theorem mul_action.sum_card_fixed_by_eq_card_orbits_mul_card_group (Î± : Type u) (Î² : Type v) [group Î±] [mul_action Î± Î²] [fintype Î±] [Î  (a : Î±), fintype â†¥(mul_action.fixed_by Î± Î² a)] [fintype (quotient (mul_action.orbit_rel Î± Î²))] : finset.univ.sum (Î» (a : Î±), fintype.card â†¥(mul_action.fixed_by Î± Î² a)) = fintype.card (quotient (mul_action.orbit_rel Î± Î²)) * fintype.card Î±
theorem matrix.det_one_add_mul_comm {m : Type u} {n : Type u'} {Î± : Type v} [fintype n] [decidable_eq n] [comm_ring Î±] [fintype m] [decidable_eq m] (A : matrix m n Î±) (B : matrix n m Î±) : (1 + A.mul B).det = (1 + B.mul A).det
theorem category_theory.unit_comp_partial_bijective_aux_symm_apply {C : Type uâ‚} {D : Type uâ‚‚} [category_theory.category C] [category_theory.category D] {i : D â¥¤ C} [category_theory.reflective i] {A : C} {B : D} (f : i.obj ((category_theory.left_adjoint i).obj A) âŸ¶ i.obj B) : â‡‘((category_theory.unit_comp_partial_bijective_aux A B).symm) f = (category_theory.adjunction.of_right_adjoint i).unit.app A â‰« f
theorem bounded_continuous_function.dist_zero_of_empty {Î± : Type u} {Î² : Type v} [topological_space Î±] [pseudo_metric_space Î²] {f g : bounded_continuous_function Î± Î²} [is_empty Î±] : has_dist.dist f g = 0
theorem algebraic_geometry.LocallyRingedSpace.to_Î“_Spec_c_app_iff (X : algebraic_geometry.LocallyRingedSpace) (r : â†¥(algebraic_geometry.LocallyRingedSpace.Î“.obj (opposite.op X))) (f : (algebraic_geometry.Spec.structure_sheaf â†¥(algebraic_geometry.LocallyRingedSpace.Î“.obj (opposite.op X))).val.obj (opposite.op (prime_spectrum.basic_open r)) âŸ¶ X.to_SheafedSpace.to_PresheafedSpace.presheaf.obj (opposite.op (X.to_Î“_Spec_map_basic_open r))) : algebraic_geometry.structure_sheaf.to_open â†¥(algebraic_geometry.LocallyRingedSpace.Î“.obj (opposite.op X)) (prime_spectrum.basic_open r) â‰« f = X.to_to_Î“_Spec_map_basic_open r â†” f = X.to_Î“_Spec_c_app r
theorem le_nhds_of_cauchy_adhp_aux {Î± : Type u} [uniform_space Î±] {f : filter Î±} {x : Î±} (adhs : âˆ€ (s : set (Î± Ã— Î±)), s âˆˆ uniformity Î± â†’ (âˆƒ (t : set Î±) (H : t âˆˆ f), t Ã—Ë¢ t âŠ† s âˆ§ âˆƒ (y : Î±), (x, y) âˆˆ s âˆ§ y âˆˆ t)) : f â‰¤ nhds x
theorem power_series.sub_const_eq_shift_mul_X {R : Type u_1} [ring R] (Ï† : power_series R) : Ï† - â‡‘(power_series.C R) (â‡‘(power_series.constant_coeff R) Ï†) = power_series.mk (Î» (p : â„•), â‡‘(power_series.coeff R (p + 1)) Ï†) * power_series.X
theorem isometry.right_inv {Î± : Type u} {Î² : Type v} [pseudo_emetric_space Î±] [pseudo_emetric_space Î²] {f : Î± â†’ Î²} {g : Î² â†’ Î±} (h : isometry f) (hg : function.right_inverse g f) : isometry g
theorem witt_vector.isocrystal_classification (p : â„•) [fact (nat.prime p)] (k : Type u_1) [field k] [is_alg_closed k] [char_p k p] (V : Type u_2) [add_comm_group V] [witt_vector.isocrystal p k V] (h_dim : finite_dimensional.finrank (fraction_ring (witt_vector p k)) V = 1) : âˆƒ (m : â„¤), nonempty (witt_vector.isocrystal_equiv p k (witt_vector.standard_one_dim_isocrystal p k m) V)
theorem add_le_of_le_sub_left {Î± : Type u} [add_comm_group Î±] [has_le Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b c : Î±} : b â‰¤ c - a â†’ a + b â‰¤ c
theorem affine.simplex.sum_monge_point_weights_with_circumcenter (n : â„•) : finset.univ.sum (Î» (i : affine.simplex.points_with_circumcenter_index (n + 2)), affine.simplex.monge_point_weights_with_circumcenter n i) = 1
theorem finset.noncomm_prod_mul_distrib {Î± : Type u_1} {Î² : Type u_2} [monoid Î²] {s : finset Î±} (f g : Î± â†’ Î²) (comm_ff : âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (y : Î±), y âˆˆ s â†’ commute (f x) (f y)) (comm_gg : âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (y : Î±), y âˆˆ s â†’ commute (g x) (g y)) (comm_gf : âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (y : Î±), y âˆˆ s â†’ x â‰  y â†’ commute (g x) (f y)) : s.noncomm_prod (f * g) _ = s.noncomm_prod f comm_ff * s.noncomm_prod g comm_gg
theorem monoid_algebra.finite_type_iff_fg {R : Type u_1} {M : Type u_2} [comm_monoid M] [comm_ring R] [nontrivial R] : algebra.finite_type R (monoid_algebra R M) â†” monoid.fg M
theorem interval_integral.fderiv_within_integral_of_tendsto_ae {E : Type u_3} [normed_group E] [complete_space E] [normed_space â„ E] {f : â„ â†’ E} {ca cb : E} {la lb : filter â„} {a b : â„} (hf : interval_integrable f measure_theory.measure_space.volume a b) (hmeas_a : strongly_measurable_at_filter f la measure_theory.measure_space.volume) (hmeas_b : strongly_measurable_at_filter f lb measure_theory.measure_space.volume) {s t : set â„} [interval_integral.FTC_filter a (nhds_within a s) la] [interval_integral.FTC_filter b (nhds_within b t) lb] (ha : filter.tendsto f (la âŠ“ measure_theory.measure_space.volume.ae) (nhds ca)) (hb : filter.tendsto f (lb âŠ“ measure_theory.measure_space.volume.ae) (nhds cb)) (hs : unique_diff_within_at â„ s a . "unique_diff_within_at_Ici_Iic_univ") (ht : unique_diff_within_at â„ t b . "unique_diff_within_at_Ici_Iic_univ") : fderiv_within â„ (Î» (p : â„ Ã— â„), âˆ« (x : â„) in p.fst..p.snd, f x) (s Ã—Ë¢ t) (a, b) = (continuous_linear_map.snd â„ â„ â„).smul_right cb - (continuous_linear_map.fst â„ â„ â„).smul_right ca
theorem line_map_lt_map_iff_slope_lt_slope_left {k : Type u_1} {E : Type u_2} [linear_ordered_field k] [ordered_add_comm_group E] [module k E] [ordered_smul k E] {f : k â†’ E} {a b r : k} (h : 0 < r * (b - a)) : â‡‘(affine_map.line_map (f a) (f b)) r < f (â‡‘(affine_map.line_map a b) r) â†” slope f a b < slope f a (â‡‘(affine_map.line_map a b) r)
theorem finset.eq_of_mem_of_not_mem_erase {Î± : Type u_1} [decidable_eq Î±] {s : finset Î±} {a b : Î±} (hs : b âˆˆ s) (hsa : b âˆ‰ s.erase a) : b = a
theorem linear_map.trace_eq_contract_of_basis' {R : Type u_1} [comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {Î¹ : Type u_4} [fintype Î¹] [decidable_eq Î¹] (b : basis Î¹ R M) : linear_map.trace R M = (contract_left R M).comp (dual_tensor_hom_equiv_of_basis b).symm.to_linear_map
theorem mfderiv_within_eq_fderiv_within {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {E' : Type u_3} [normed_group E'] [normed_space ğ•œ E'] {f : E â†’ E'} {s : set E} {x : E} : mfderiv_within (model_with_corners_self ğ•œ E) (model_with_corners_self ğ•œ E') f s x = fderiv_within ğ•œ f s x
theorem finset.nonempty.card_pos {Î± : Type u_1} {s : finset Î±} : s.nonempty â†’ 0 < s.card
theorem filter.map_mapâ‚‚_antidistrib_left {Î± : Type u_1} {Î² : Type u_3} {Î²' : Type u_4} {Î³ : Type u_5} {Î´ : Type u_7} {m : Î± â†’ Î² â†’ Î³} {f : filter Î±} {g : filter Î²} {n : Î³ â†’ Î´} {m' : Î²' â†’ Î± â†’ Î´} {n' : Î² â†’ Î²'} (h_antidistrib : âˆ€ (a : Î±) (b : Î²), n (m a b) = m' (n' b) a) : filter.map n (filter.mapâ‚‚ m f g) = filter.mapâ‚‚ m' (filter.map n' g) f
theorem has_deriv_within_at.liminf_right_norm_slope_le {E : Type u} [normed_group E] [normed_space â„ E] {f : â„ â†’ E} {f' : E} {x r : â„} (hf : has_deriv_within_at f f' (set.Ici x) x) (hr : âˆ¥f'âˆ¥ < r) : âˆƒá¶  (z : â„) in nhds_within x (set.Ioi x), âˆ¥z - xâˆ¥â»Â¹ * âˆ¥f z - f xâˆ¥ < r
theorem is_integral.is_algebraic (R : Type u) {A : Type v} [comm_ring R] [ring A] [algebra R A] [nontrivial R] {x : A} : is_integral R x â†’ is_algebraic R x
theorem Profinite.is_iso_of_bijective {X Y : Profinite} (f : X âŸ¶ Y) (bij : function.bijective â‡‘f) : category_theory.is_iso f
theorem norm_sq_eq_add_norm_sq_projection {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] (x : E) (S : submodule ğ•œ E) [complete_space E] [complete_space â†¥S] : âˆ¥xâˆ¥ ^ 2 = âˆ¥â‡‘(orthogonal_projection S) xâˆ¥ ^ 2 + âˆ¥â‡‘(orthogonal_projection Sá—®) xâˆ¥ ^ 2
theorem add_le_of_le_sub_right {Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b c : Î±} : a â‰¤ c - b â†’ a + b â‰¤ c
theorem padic_val_int.self {p : â„•} (hp : 1 < p) : padic_val_int p â†‘p = 1
theorem zmod.Ï‡â‚ˆ'_int_eq_if_mod_eight (n : â„¤) : â‡‘zmod.Ï‡â‚ˆ' â†‘n = ite (n % 2 = 0) 0 (ite (n % 8 = 1 âˆ¨ n % 8 = 3) 1 (-1))
theorem exists_bounded_mem_Icc_of_closed_of_le {X : Type u_1} [topological_space X] [normal_space X] {s t : set X} (hs : is_closed s) (ht : is_closed t) (hd : disjoint s t) {a b : â„} (hle : a â‰¤ b) : âˆƒ (f : bounded_continuous_function X â„), set.eq_on â‡‘f (function.const X a) s âˆ§ set.eq_on â‡‘f (function.const X b) t âˆ§ âˆ€ (x : X), â‡‘f x âˆˆ set.Icc a b
theorem finsum_mem_pair {Î± : Type u_1} {M : Type u_5} [add_comm_monoid M] {f : Î± â†’ M} {a b : Î±} (h : a â‰  b) : finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ {a, b}), f i)) = f a + f b
theorem set.Union_lift_binary {Î± : Type u_1} {Î¹ : Type u_2} {Î² : Type u_3} {S : Î¹ â†’ set Î±} {f : Î  (i : Î¹), â†¥(S i) â†’ Î²} {hf : âˆ€ (i j : Î¹) (x : Î±) (hxi : x âˆˆ S i) (hxj : x âˆˆ S j), f i âŸ¨x, hxiâŸ© = f j âŸ¨x, hxjâŸ©} {T : set Î±} (hT' : T = set.Union S) (dir : directed has_le.le S) (op : â†¥T â†’ â†¥T â†’ â†¥T) (opi : Î  (i : Î¹), â†¥(S i) â†’ â†¥(S i) â†’ â†¥(S i)) (hopi : âˆ€ (i : Î¹) (x y : â†¥(S i)), set.inclusion _ (opi i x y) = op (set.inclusion _ x) (set.inclusion _ y)) (opÎ² : Î² â†’ Î² â†’ Î²) (h : âˆ€ (i : Î¹) (x y : â†¥(S i)), f i (opi i x y) = opÎ² (f i x) (f i y)) (x y : â†¥T) : set.Union_lift S f hf T _ (op x y) = opÎ² (set.Union_lift S f hf T _ x) (set.Union_lift S f hf T _ y)
theorem monoid.not_is_torsion_free_iff (G : Type u_1) [monoid G] : Â¬monoid.is_torsion_free G â†” âˆƒ (g : G), g â‰  1 âˆ§ is_of_fin_order g
theorem frontier_compl {Î± : Type u} [topological_space Î±] (s : set Î±) : frontier sá¶œ = frontier s
theorem nat.four_pow_lt_mul_central_binom (n : â„•) (n_big : 4 â‰¤ n) : 4 ^ n < n * n.central_binom
theorem pfun.ext' {Î± : Type u_1} {Î² : Type u_2} {f g : Î± â†’. Î²} (H1 : âˆ€ (a : Î±), a âˆˆ f.dom â†” a âˆˆ g.dom) (H2 : âˆ€ (a : Î±) (p : f.dom a) (q : g.dom a), f.fn a p = g.fn a q) : f = g
theorem inner_sum {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {Î¹ : Type u_3} (s : finset Î¹) (f : Î¹ â†’ E) (x : E) : has_inner.inner x (s.sum (Î» (i : Î¹), f i)) = s.sum (Î» (i : Î¹), has_inner.inner x (f i))
theorem fintype.induction_empty_option {P : Type u â†’ Prop} (of_equiv : âˆ€ {Î± Î² : Type u}, Î± â‰ƒ Î² â†’ P Î± â†’ P Î²) (h_empty : P pempty) (h_option : âˆ€ {Î± : Type u} [_inst_1 : fintype Î±], P Î± â†’ P (option Î±)) (Î± : Type u) [fintype Î±] : P Î±
theorem formal_multilinear_series.has_fpower_series_on_ball {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field ğ•œ] [normed_group E] [normed_space ğ•œ E] [normed_group F] [normed_space ğ•œ F] [complete_space F] (p : formal_multilinear_series ğ•œ E F) (h : 0 < p.radius) : has_fpower_series_on_ball p.sum p 0 p.radius
theorem category_theory.normal_epi_category.mono_of_cancel_zero {C : Type u_1} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_finite_coproducts C] [category_theory.limits.has_cokernels C] [category_theory.normal_epi_category C] [category_theory.limits.has_zero_object C] {X Y : C} (f : X âŸ¶ Y) (hf : âˆ€ (Z : C) (g : Z âŸ¶ X), g â‰« f = 0 â†’ g = 0) : category_theory.mono f
theorem linear_recurrence.is_sol_mk_sol {Î± : Type u_1} [comm_semiring Î±] (E : linear_recurrence Î±) (init : fin E.order â†’ Î±) : E.is_solution (E.mk_sol init)
theorem hall_marriage_theorem.hall_hard_inductive_step_A {Î¹ : Type u} {Î± : Type v} [fintype Î¹] {t : Î¹ â†’ finset Î±} [decidable_eq Î±] {n : â„•} (hn : fintype.card Î¹ = n + 1) (ht : âˆ€ (s : finset Î¹), s.card â‰¤ (s.bUnion t).card) (ih : âˆ€ {Î¹' : Type u} [_inst_3 : fintype Î¹'] (t' : Î¹' â†’ finset Î±), fintype.card Î¹' â‰¤ n â†’ (âˆ€ (s' : finset Î¹'), s'.card â‰¤ (s'.bUnion t').card) â†’ (âˆƒ (f : Î¹' â†’ Î±), function.injective f âˆ§ âˆ€ (x : Î¹'), f x âˆˆ t' x)) (ha : âˆ€ (s : finset Î¹), s.nonempty â†’ s â‰  finset.univ â†’ s.card < (s.bUnion t).card) : âˆƒ (f : Î¹ â†’ Î±), function.injective f âˆ§ âˆ€ (x : Î¹), f x âˆˆ t x
theorem measure_theory.exists_pos_set_lintegral_lt_of_measure_lt {Î± : Type u_1} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {f : Î± â†’ ennreal} (h : âˆ«â» (x : Î±), f x âˆ‚Î¼ â‰  âŠ¤) {Îµ : ennreal} (hÎµ : Îµ â‰  0) : âˆƒ (Î´ : ennreal) (H : Î´ > 0), âˆ€ (s : set Î±), â‡‘Î¼ s < Î´ â†’ âˆ«â» (x : Î±) in s, f x âˆ‚Î¼ < Îµ
theorem cont_diff_within_at_succ_iff_has_fderiv_within_at {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {s : set E} {f : E â†’ F} {x : E} {n : â„•} : cont_diff_within_at ğ•œ â†‘(n + 1) f s x â†” âˆƒ (u : set E) (H : u âˆˆ nhds_within x (has_insert.insert x s)) (f' : E â†’ (E â†’L[ğ•œ] F)), (âˆ€ (x : E), x âˆˆ u â†’ has_fderiv_within_at f (f' x) u x) âˆ§ cont_diff_within_at ğ•œ â†‘n f' u x
theorem category_theory.limits.is_initial.epi_to {C : Type uâ‚} [category_theory.category C] {X Y : C} (t : category_theory.limits.is_initial X) (f : Y âŸ¶ X) : category_theory.epi f
theorem linear_independent.maximal_iff {Î¹ : Type w} {R : Type u} [ring R] [nontrivial R] {M : Type v} [add_comm_group M] [module R M] {v : Î¹ â†’ M} (i : linear_independent R v) : i.maximal â†” âˆ€ (Îº : Type v) (w : Îº â†’ M), linear_independent R w â†’ âˆ€ (j : Î¹ â†’ Îº), w âˆ˜ j = v â†’ function.surjective j
theorem asymptotics.is_O.of_neg_right {Î± : Type u_1} {E : Type u_3} {F' : Type u_7} [has_norm E] [semi_normed_group F'] {f : Î± â†’ E} {g' : Î± â†’ F'} {l : filter Î±} : (f =O[l] Î» (x : Î±), -g' x) â†’ f =O[l] g'
theorem no_max_order.infinite {Î± : Type u_1} [preorder Î±] [nonempty Î±] [no_max_order Î±] : infinite Î±
theorem continuous_matrix {Î± : Type u_2} {m : Type u_4} {n : Type u_5} {R : Type u_8} [topological_space R] [topological_space Î±] {f : Î± â†’ matrix m n R} (h : âˆ€ (i : m) (j : n), continuous (Î» (a : Î±), f a i j)) : continuous f
theorem mul_sub {Î± : Type u} [non_unital_non_assoc_ring Î±] (a b c : Î±) : a * (b - c) = a * b - a * c
theorem multiset.Ioc_eq_zero {Î± : Type u_1} [preorder Î±] [locally_finite_order Î±] {a b : Î±} : Â¬a < b â†’ multiset.Ioc a b = 0
theorem nnreal.rpow_sum_le_const_mul_sum_rpow {Î¹ : Type u} (s : finset Î¹) (f : Î¹ â†’ nnreal) {p : â„} (hp : 1 â‰¤ p) : s.sum (Î» (i : Î¹), f i) ^ p â‰¤ â†‘(s.card) ^ (p - 1) * s.sum (Î» (i : Î¹), f i ^ p)
theorem dist_le_of_le_geometric_two_of_tendsto {Î± : Type u_1} [pseudo_metric_space Î±] (C : â„) {f : â„• â†’ Î±} (huâ‚‚ : âˆ€ (n : â„•), has_dist.dist (f n) (f (n + 1)) â‰¤ C / 2 / 2 ^ n) {a : Î±} (ha : filter.tendsto f filter.at_top (nhds a)) (n : â„•) : has_dist.dist (f n) a â‰¤ C / 2 ^ n
theorem with_top.is_lub_Sup' {Î² : Type u_1} [conditionally_complete_lattice Î²] {s : set (with_top Î²)} (hs : s.nonempty) : is_lub s (has_Sup.Sup s)
theorem measure_theory.continuous_L1_to_L1 {Î± : Type u_1} {G : Type u_5} [normed_group G] {m : measurable_space Î±} {Î¼ Î¼' : measure_theory.measure Î±} (c' : ennreal) (hc' : c' â‰  âŠ¤) (hÎ¼'_le : Î¼' â‰¤ c' â€¢ Î¼) : continuous (Î» (f : â†¥(measure_theory.Lp G 1 Î¼)), measure_theory.integrable.to_L1 â‡‘f _)
theorem finsum_mem_range {Î± : Type u_1} {Î² : Type u_2} {M : Type u_5} [add_comm_monoid M] {f : Î± â†’ M} {g : Î² â†’ Î±} (hg : function.injective g) : finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ set.range g), f i)) = finsum (Î» (j : Î²), f (g j))
theorem univ.is_submonoid {M : Type u_1} [monoid M] : is_submonoid set.univ
theorem has_fderiv_within_at.lim {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {f : E â†’ F} {f' : E â†’L[ğ•œ] F} {x : E} {s : set E} (h : has_fderiv_within_at f f' s x) {Î± : Type u_4} (l : filter Î±) {c : Î± â†’ ğ•œ} {d : Î± â†’ E} {v : E} (dtop : âˆ€á¶  (n : Î±) in l, x + d n âˆˆ s) (clim : filter.tendsto (Î» (n : Î±), âˆ¥c nâˆ¥) l filter.at_top) (cdlim : filter.tendsto (Î» (n : Î±), c n â€¢ d n) l (nhds v)) : filter.tendsto (Î» (n : Î±), c n â€¢ (f (x + d n) - f x)) l (nhds (â‡‘f' v))
theorem is_cyclotomic_extension.prime_ne_two_pow_norm_zeta_pow_sub_one {p : â„•+} {K : Type u} (L : Type v) [field K] [field L] [algebra K L] [ne_zero â†‘â†‘p] {k : â„•} [hpri : fact (nat.prime â†‘p)] [is_cyclotomic_extension {p ^ (k + 1)} K L] (hirr : irreducible (polynomial.cyclotomic â†‘(p ^ (k + 1)) K)) {s : â„•} (hs : s â‰¤ k) (htwo : p ^ (k - s + 1) â‰  2) : â‡‘(algebra.norm K) (is_cyclotomic_extension.zeta (p ^ (k + 1)) K L ^ â†‘p ^ s - 1) = â†‘p ^ â†‘p ^ s
theorem generalized_continued_fraction.int_fract_pair.stream_succ_nth_fr_num_lt_nth_fr_num_rat {q : â„š} {n : â„•} {ifp_n ifp_succ_n : generalized_continued_fraction.int_fract_pair â„š} (stream_nth_eq : generalized_continued_fraction.int_fract_pair.stream q n = option.some ifp_n) (stream_succ_nth_eq : generalized_continued_fraction.int_fract_pair.stream q (n + 1) = option.some ifp_succ_n) : ifp_succ_n.fr.num < ifp_n.fr.num
theorem add_subgroup.comap_normalizer_eq_of_surjective {G : Type u_1} [add_group G] {N : Type u_3} [add_group N] (H : add_subgroup G) {f : N â†’+ G} (hf : function.surjective â‡‘f) : add_subgroup.comap f H.normalizer = (add_subgroup.comap f H).normalizer
theorem lt_tsub_iff_left {Î± : Type u_1} {a b c : Î±} [linear_order Î±] [add_comm_semigroup Î±] [has_sub Î±] [has_ordered_sub Î±] : a < b - c â†” c + a < b
theorem is_local_max_on.fderiv_within_nonpos {E : Type u} [normed_group E] [normed_space â„ E] {f : E â†’ â„} {a : E} {s : set E} (h : is_local_max_on f s a) {y : E} (hy : y âˆˆ pos_tangent_cone_at s a) : â‡‘(fderiv_within â„ f s a) y â‰¤ 0
theorem intermediate_field.adjoin_adjoin_comm (F : Type u_1) [field F] {E : Type u_2} [field E] [algebra F E] (S T : set E) : â†‘(intermediate_field.adjoin â†¥(intermediate_field.adjoin F S) T) = â†‘(intermediate_field.adjoin â†¥(intermediate_field.adjoin F T) S)
theorem supr_ne_bot_subtype {Î± : Type u_1} {Î¹ : Sort u_4} [complete_lattice Î±] (f : Î¹ â†’ Î±) : (â¨† (i : {i // f i â‰  âŠ¥}), f â†‘i) = â¨† (i : Î¹), f i
theorem function.periodic.interval_integral_add_eq_add {E : Type u_1} [normed_group E] [normed_space â„ E] [complete_space E] {f : â„ â†’ E} {T : â„} (hf : function.periodic f T) (t s : â„) (h_int : âˆ€ (tâ‚ tâ‚‚ : â„), interval_integrable f measure_theory.measure_space.volume tâ‚ tâ‚‚) : âˆ« (x : â„) in t..s + T, f x = (âˆ« (x : â„) in t..s, f x) + âˆ« (x : â„) in t..t + T, f x
theorem add_monoid_algebra.mem_closure_of_mem_span_closure {R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_monoid M] [nontrivial R] {m : M} {S : set M} (h : add_monoid_algebra.of' R M m âˆˆ submodule.span R â†‘(submonoid.closure (add_monoid_algebra.of' R M '' S))) : m âˆˆ add_submonoid.closure S
theorem polynomial.base_mul_mem_lifts {R : Type u} [semiring R] {S : Type v} [semiring S] {f : R â†’+* S} {p : polynomial S} (r : R) (hp : p âˆˆ polynomial.lifts f) : â‡‘polynomial.C (â‡‘f r) * p âˆˆ polynomial.lifts f
theorem subtype.range_val {Î± : Type u_1} {s : set Î±} : set.range subtype.val = s
theorem spectrum.nonempty {A : Type u_1} [normed_ring A] [normed_algebra â„‚ A] [complete_space A] [nontrivial A] (a : A) : (spectrum â„‚ a).nonempty
theorem local_equiv.is_image.symm_preimage_eq {Î± : Type u_1} {Î² : Type u_2} {e : local_equiv Î± Î²} {s : set Î±} {t : set Î²} : e.is_image s t â†’ e.target âˆ© â‡‘(e.symm) â»Â¹' s = e.target âˆ© t
theorem power_series.order_monomial {R : Type u_1} [semiring R] (n : â„•) (a : R) [decidable (a = 0)] : (â‡‘(power_series.monomial R n) a).order = ite (a = 0) âŠ¤ â†‘n
theorem finset.exists_card_fiber_le_of_card_le_mul {Î± : Type u} {Î² : Type v} [decidable_eq Î²] {s : finset Î±} {t : finset Î²} {f : Î± â†’ Î²} {n : â„•} (ht : t.nonempty) (hn : s.card â‰¤ t.card * n) : âˆƒ (y : Î²) (H : y âˆˆ t), (finset.filter (Î» (x : Î±), f x = y) s).card â‰¤ n
theorem has_lt.lt.trans_le {Î± : Type u} [preorder Î±] {a b c : Î±} : a < b â†’ b â‰¤ c â†’ a < c
theorem measure_theory.measure.haar.index_defined {G : Type u_1} [group G] [topological_space G] [topological_group G] {K V : set G} (hK : is_compact K) (hV : (interior V).nonempty) : âˆƒ (n : â„•), n âˆˆ finset.card '' {t : finset G | K âŠ† â‹ƒ (g : G) (H : g âˆˆ t), (Î» (h : G), g * h) â»Â¹' V}
theorem Gromov_Hausdorff.totally_bounded {t : set Gromov_Hausdorff.GH_space} {C : â„} {u : â„• â†’ â„} {K : â„• â†’ â„•} (ulim : filter.tendsto u filter.at_top (nhds 0)) (hdiam : âˆ€ (p : Gromov_Hausdorff.GH_space), p âˆˆ t â†’ metric.diam set.univ â‰¤ C) (hcov : âˆ€ (p : Gromov_Hausdorff.GH_space), p âˆˆ t â†’ âˆ€ (n : â„•), âˆƒ (s : set p.rep), cardinal.mk â†¥s â‰¤ â†‘(K n) âˆ§ set.univ âŠ† â‹ƒ (x : p.rep) (H : x âˆˆ s), metric.ball x (u n)) : totally_bounded t
theorem measure_theory.measure.rn_deriv_restrict {Î± : Type u_1} {m : measurable_space Î±} (Î½ : measure_theory.measure Î±) [measure_theory.sigma_finite Î½] {s : set Î±} (hs : measurable_set s) : (Î½.restrict s).rn_deriv Î½ =áµ[Î½] s.indicator 1
theorem category_theory.has_colimits_of_has_colimits_creates_colimits {C : Type uâ‚} [category_theory.category C] {D : Type uâ‚‚} [category_theory.category D] (F : C â¥¤ D) [category_theory.limits.has_colimits_of_size D] [category_theory.creates_colimits_of_size F] : category_theory.limits.has_colimits_of_size C
theorem convex_hull_exists_dist_ge2 {E : Type u_2} [semi_normed_group E] [normed_space â„ E] {s t : set E} {x y : E} (hx : x âˆˆ â‡‘(convex_hull â„) s) (hy : y âˆˆ â‡‘(convex_hull â„) t) : âˆƒ (x' : E) (H : x' âˆˆ s) (y' : E) (H : y' âˆˆ t), has_dist.dist x y â‰¤ has_dist.dist x' y'
theorem exists_pow_lt_of_lt_one {Î± : Type u_1} [linear_ordered_field Î±] [archimedean Î±] {x y : Î±} (hx : 0 < x) (hy : y < 1) : âˆƒ (n : â„•), y ^ n < x
theorem exists_polynomial_near_of_continuous_on (a b : â„) (f : â„ â†’ â„) (c : continuous_on f (set.Icc a b)) (Îµ : â„) (pos : 0 < Îµ) : âˆƒ (p : polynomial â„), âˆ€ (x : â„), x âˆˆ set.Icc a b â†’ |polynomial.eval x p - f x| < Îµ
theorem bdd_below.inter_of_left {Î± : Type u} [preorder Î±] {s t : set Î±} (h : bdd_below s) : bdd_below (s âˆ© t)
theorem submodule.inner_right_of_mem_orthogonal {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {K : submodule ğ•œ E} {u v : E} (hu : u âˆˆ K) (hv : v âˆˆ Ká—®) : has_inner.inner u v = 0
theorem orientation.two_zsmul_oangle_smul_right_self {V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) (x : V) {r : â„} : 2 â€¢ o.oangle x (r â€¢ x) = 0
theorem lucas_lehmer.two_lt_q (p' : â„•) : 2 < lucas_lehmer.q (p' + 2)
theorem continuous_linear_equiv.has_sum {Î¹ : Type u_10} {R : Type u_11} {Râ‚‚ : Type u_12} {M : Type u_13} {Mâ‚‚ : Type u_14} [semiring R] [semiring Râ‚‚] [add_comm_monoid M] [module R M] [add_comm_monoid Mâ‚‚] [module Râ‚‚ Mâ‚‚] [topological_space M] [topological_space Mâ‚‚] {Ïƒ : R â†’+* Râ‚‚} {Ïƒ' : Râ‚‚ â†’+* R} [ring_hom_inv_pair Ïƒ Ïƒ'] [ring_hom_inv_pair Ïƒ' Ïƒ] {f : Î¹ â†’ M} (e : M â‰ƒSL[Ïƒ] Mâ‚‚) {y : Mâ‚‚} : has_sum (Î» (b : Î¹), â‡‘e (f b)) y â†” has_sum f (â‡‘(e.symm) y)
theorem category_theory.is_filtered.of_right_adjoint {C : Type u} [category_theory.category C] [category_theory.is_filtered C] {D : Type uâ‚} [category_theory.category D] {L : D â¥¤ C} {R : C â¥¤ D} (h : L âŠ£ R) : category_theory.is_filtered D
theorem interval_integral.sub_le_integral_of_has_deriv_right_of_le_Ico {a b : â„} {g' g Ï† : â„ â†’ â„} (hab : a â‰¤ b) (hcont : continuous_on g (set.Icc a b)) (hderiv : âˆ€ (x : â„), x âˆˆ set.Ico a b â†’ has_deriv_within_at g (g' x) (set.Ioi x) x) (Ï†int : measure_theory.integrable_on Ï† (set.Icc a b) measure_theory.measure_space.volume) (hÏ†g : âˆ€ (x : â„), x âˆˆ set.Ico a b â†’ g' x â‰¤ Ï† x) : g b - g a â‰¤ âˆ« (y : â„) in a..b, Ï† y
theorem isometry_subsingleton {Î± : Type u} {Î² : Type v} [pseudo_emetric_space Î±] [pseudo_emetric_space Î²] {f : Î± â†’ Î²} [subsingleton Î±] : isometry f
theorem bilin_form.restrict_symm {R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] (B : bilin_form R M) (b : B.is_symm) (W : submodule R M) : (B.restrict W).is_symm
theorem closure_Ioi {Î± : Type u} [topological_space Î±] [linear_order Î±] [order_topology Î±] [densely_ordered Î±] (a : Î±) [no_max_order Î±] : closure (set.Ioi a) = set.Ici a
theorem category_theory.presheaf.is_limit_iff_is_sheaf_for_presieve {C : Type uâ‚} [category_theory.category C] {A : Type uâ‚‚} [category_theory.category A] (P : Cáµ’áµ– â¥¤ A) {X : C} (R : category_theory.presieve X) : nonempty (category_theory.limits.is_limit (P.map_cone (category_theory.sieve.generate R).arrows.cocone.op)) â†” âˆ€ (E : Aáµ’áµ–), category_theory.presieve.is_sheaf_for (P â‹™ category_theory.coyoneda.obj E) R
theorem inner_product_geometry.sin_angle_mul_norm_mul_norm {V : Type u_1} [inner_product_space â„ V] (x y : V) : real.sin (inner_product_geometry.angle x y) * (âˆ¥xâˆ¥ * âˆ¥yâˆ¥) = real.sqrt (has_inner.inner x x * has_inner.inner y y - has_inner.inner x y * has_inner.inner x y)
theorem polynomial.cyclotomic.irreducible {n : â„•} (hpos : 0 < n) : irreducible (polynomial.cyclotomic n â„¤)
theorem continuous_linear_map.op_norm_zero_iff {ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {E : Type u_4} {F : Type u_6} [normed_group E] [normed_group F] [nondiscrete_normed_field ğ•œ] [nondiscrete_normed_field ğ•œâ‚‚] [normed_space ğ•œ E] [normed_space ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} (f : E â†’SL[Ïƒâ‚â‚‚] F) [ring_hom_isometric Ïƒâ‚â‚‚] : âˆ¥fâˆ¥ = 0 â†” f = 0
theorem mdifferentiable_iff_differentiable {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {E' : Type u_3} [normed_group E'] [normed_space ğ•œ E'] {f : E â†’ E'} : mdifferentiable (model_with_corners_self ğ•œ E) (model_with_corners_self ğ•œ E') f â†” differentiable ğ•œ f
theorem power_series.ext_iff {R : Type u_1} [semiring R] {Ï† Ïˆ : power_series R} : Ï† = Ïˆ â†” âˆ€ (n : â„•), â‡‘(power_series.coeff R n) Ï† = â‡‘(power_series.coeff R n) Ïˆ
theorem formal_multilinear_series.le_comp_radius_of_summable {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [nondiscrete_normed_field ğ•œ] [normed_group E] [normed_space ğ•œ E] [normed_group F] [normed_space ğ•œ F] [normed_group G] [normed_space ğ•œ G] (q : formal_multilinear_series ğ•œ F G) (p : formal_multilinear_series ğ•œ E F) (r : nnreal) (hr : summable (Î» (i : Î£ (n : â„•), composition n), âˆ¥q.comp_along_composition p i.sndâˆ¥â‚Š * r ^ i.fst)) : â†‘r â‰¤ (q.comp p).radius
theorem witt_vector.is_polyâ‚‚.diag {p : â„•} {f : Î  â¦ƒR : Type u_1â¦„ [_inst_3 : comm_ring R], witt_vector p R â†’ witt_vector p R â†’ witt_vector p R} (hf : witt_vector.is_polyâ‚‚ p f) : witt_vector.is_poly p (Î» (R : Type u_1) (_Rcr : comm_ring R) (x : witt_vector p R), f x x)
theorem finset.induction_on_max_value {Î± : Type u_1} {Î¹ : Type u_4} [linear_order Î±] [decidable_eq Î¹] (f : Î¹ â†’ Î±) {p : finset Î¹ â†’ Prop} (s : finset Î¹) (h0 : p âˆ…) (step : âˆ€ (a : Î¹) (s : finset Î¹), a âˆ‰ s â†’ (âˆ€ (x : Î¹), x âˆˆ s â†’ f x â‰¤ f a) â†’ p s â†’ p (has_insert.insert a s)) : p s
theorem finprod_mem_union' {Î± : Type u_1} {M : Type u_5} [comm_monoid M] {f : Î± â†’ M} {s t : set Î±} (hst : disjoint s t) (hs : (s âˆ© function.mul_support f).finite) (ht : (t âˆ© function.mul_support f).finite) : finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s âˆª t), f i)) = finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), f i)) * finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ t), f i))
theorem function.periodic.exists_mem_Icoâ‚€ {Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} {c : Î±} [linear_ordered_add_comm_group Î±] [archimedean Î±] (h : function.periodic f c) (hc : 0 < c) (x : Î±) : âˆƒ (y : Î±) (H : y âˆˆ set.Ico 0 c), f x = f y
theorem convex_independent.subtype {ğ•œ : Type u_1} {E : Type u_2} {Î¹ : Type u_3} [ordered_semiring ğ•œ] [add_comm_group E] [module ğ•œ E] {p : Î¹ â†’ E} (hc : convex_independent ğ•œ p) (s : set Î¹) : convex_independent ğ•œ (Î» (i : â†¥s), p â†‘i)
theorem inner_product_geometry.inner_eq_mul_norm_of_angle_eq_zero {V : Type u_1} [inner_product_space â„ V] {x y : V} (h : inner_product_geometry.angle x y = 0) : has_inner.inner x y = âˆ¥xâˆ¥ * âˆ¥yâˆ¥
theorem left_invariant_derivation.left_invariant' {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {G : Type u_4} [topological_space G] [charted_space H G] [monoid G] [has_smooth_mul I G] (g : G) (X : left_invariant_derivation I G) : â‡‘(hfdifferential _) (â‡‘(derivation.eval_at 1) â†‘X) = â‡‘(derivation.eval_at g) â†‘X
theorem rat.dense_range_cast {ğ•œ : Type u_1} [linear_ordered_field ğ•œ] [topological_space ğ•œ] [order_topology ğ•œ] [archimedean ğ•œ] : dense_range coe
theorem same_ray.exists_nonneg_right {R : Type u_1} [linear_ordered_field R] {M : Type u_2} [add_comm_group M] [module R M] {x y : M} (h : same_ray R x y) (hy : y â‰  0) : âˆƒ (r : R), 0 â‰¤ r âˆ§ x = r â€¢ y
theorem metric.Hausdorff_dist_closureâ‚ {Î± : Type u} [pseudo_metric_space Î±] {s t : set Î±} : metric.Hausdorff_dist (closure s) t = metric.Hausdorff_dist s t
theorem euclidean_geometry.dist_left_midpoint_eq_dist_right_midpoint {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] (p1 p2 : P) : has_dist.dist p1 (midpoint â„ p1 p2) = has_dist.dist p2 (midpoint â„ p1 p2)
theorem valuation.zero_iff {Î“â‚€ : Type u_3} [linear_ordered_comm_monoid_with_zero Î“â‚€] [nontrivial Î“â‚€] {K : Type u_1} [division_ring K] (v : valuation K Î“â‚€) {x : K} : â‡‘v x = 0 â†” x = 0
theorem module.ray.ne_neg_self {R : Type u_1} [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] [no_zero_smul_divisors R M] (x : module.ray R M) : x â‰  -x
theorem measure_theory.outer_measure.restrict_Inf_eq_Inf_restrict {Î± : Type u_1} (m : set (measure_theory.outer_measure Î±)) {s : set Î±} (hm : m.nonempty) : â‡‘(measure_theory.outer_measure.restrict s) (has_Inf.Inf m) = has_Inf.Inf (â‡‘(measure_theory.outer_measure.restrict s) '' m)
theorem zmod.Ï‡â‚ˆ'_trichotomy (a : zmod 8) : â‡‘zmod.Ï‡â‚ˆ' a = 0 âˆ¨ â‡‘zmod.Ï‡â‚ˆ' a = 1 âˆ¨ â‡‘zmod.Ï‡â‚ˆ' a = -1
theorem order_ring_iso.subsingleton_right {Î± : Type u_2} {Î² : Type u_3} [linear_ordered_field Î±] [linear_ordered_field Î²] [archimedean Î²] : subsingleton (Î± â‰ƒ+*o Î²)
theorem list.nth_le_drop' {Î± : Type u} (L : list Î±) {i j : â„•} (h : j < (list.drop i L).length) : (list.drop i L).nth_le j h = L.nth_le (i + j) _
theorem finset.min'_singleton {Î± : Type u_1} [linear_order Î±] (a : Î±) : {a}.min' _ = a
theorem irrational_nrt_of_notint_nrt {x : â„} (n : â„•) (m : â„¤) (hxr : x ^ n = â†‘m) (hv : Â¬âˆƒ (y : â„¤), x = â†‘y) (hnpos : 0 < n) : irrational x
theorem vector_span_range_eq_span_range_vsub_left (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {Î¹ : Type u_4} (p : Î¹ â†’ P) (i0 : Î¹) : vector_span k (set.range p) = submodule.span k (set.range (Î» (i : Î¹), p i0 -áµ¥ p i))
theorem category_theory.is_iso_iff_bijective {X Y : Type u} (f : X âŸ¶ Y) : category_theory.is_iso f â†” function.bijective f
theorem connected_components_preimage_image {Î± : Type u} [topological_space Î±] (U : set Î±) : coe â»Â¹' (coe '' U) = â‹ƒ (x : Î±) (H : x âˆˆ U), connected_component x
theorem conformal_at_iff_is_conformal_map_fderiv {X : Type u_1} {Y : Type u_2} [normed_group X] [normed_group Y] [normed_space â„ X] [normed_space â„ Y] {f : X â†’ Y} {x : X} : conformal_at f x â†” is_conformal_map (fderiv â„ f x)
theorem exists_ratio_deriv_eq_ratio_slope' (f : â„ â†’ â„) {a b : â„} (hab : a < b) (g : â„ â†’ â„) {lfa lga lfb lgb : â„} (hdf : differentiable_on â„ f (set.Ioo a b)) (hdg : differentiable_on â„ g (set.Ioo a b)) (hfa : filter.tendsto f (nhds_within a (set.Ioi a)) (nhds lfa)) (hga : filter.tendsto g (nhds_within a (set.Ioi a)) (nhds lga)) (hfb : filter.tendsto f (nhds_within b (set.Iio b)) (nhds lfb)) (hgb : filter.tendsto g (nhds_within b (set.Iio b)) (nhds lgb)) : âˆƒ (c : â„) (H : c âˆˆ set.Ioo a b), (lgb - lga) * deriv f c = (lfb - lfa) * deriv g c
theorem convex_independent_iff_finset {ğ•œ : Type u_1} {E : Type u_2} {Î¹ : Type u_3} [linear_ordered_field ğ•œ] [add_comm_group E] [module ğ•œ E] {p : Î¹ â†’ E} : convex_independent ğ•œ p â†” âˆ€ (s : finset Î¹) (x : Î¹), p x âˆˆ â‡‘(convex_hull ğ•œ) â†‘(finset.image p s) â†’ x âˆˆ s
theorem cont_mdiff_on.continuous_on_tangent_map_within {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {M : Type u_4} [topological_space M] [charted_space H M] [Is : smooth_manifold_with_corners I M] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners ğ•œ E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] [I's : smooth_manifold_with_corners I' M'] {f : M â†’ M'} {s : set M} {n : with_top â„•} (hf : cont_mdiff_on I I' n f s) (hmn : 1 â‰¤ n) (hs : unique_mdiff_on I s) : continuous_on (tangent_map_within I I' f s) (tangent_bundle.proj I M â»Â¹' s)
theorem int.tendsto_coe_cofinite  : filter.tendsto coe filter.cofinite (filter.cocompact â„)
theorem add_subgroup.pi_le_iff {Î· : Type u_5} {f : Î· â†’ Type u_6} [Î  (i : Î·), add_group (f i)] [decidable_eq Î·] [fintype Î·] {H : Î  (i : Î·), add_subgroup (f i)} {J : add_subgroup (Î  (i : Î·), f i)} : add_subgroup.pi set.univ H â‰¤ J â†” âˆ€ (i : Î·), add_subgroup.map (add_monoid_hom.single f i) (H i) â‰¤ J
theorem cont_diff.cont_mdiff {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {n : with_top â„•} {f : E â†’ E'} : cont_diff ğ•œ n f â†’ cont_mdiff (model_with_corners_self ğ•œ E) (model_with_corners_self ğ•œ E') n f
theorem cont_diff_on.continuous_on_iterated_deriv_within {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {F : Type u_2} [normed_group F] [normed_space ğ•œ F] {f : ğ•œ â†’ F} {s : set ğ•œ} {n : with_top â„•} {m : â„•} (h : cont_diff_on ğ•œ n f s) (hmn : â†‘m â‰¤ n) (hs : unique_diff_on ğ•œ s) : continuous_on (iterated_deriv_within m f s) s
theorem emetric.countable_closure_of_compact {Î³ : Type w} [emetric_space Î³] {s : set Î³} (hs : is_compact s) : âˆƒ (t : set Î³) (H : t âŠ† s), t.countable âˆ§ s = closure t
theorem submonoid.ext {M : Type u_1} [mul_one_class M] {S T : submonoid M} (h : âˆ€ (x : M), x âˆˆ S â†” x âˆˆ T) : S = T
theorem category_theory.finrank_endomorphism_simple_eq_one {C : Type u_1} [category_theory.category C] [category_theory.preadditive C] (ğ•œ : Type u_3) [field ğ•œ] [is_alg_closed ğ•œ] [category_theory.linear ğ•œ C] [category_theory.limits.has_kernels C] (X : C) [category_theory.simple X] [I : finite_dimensional ğ•œ (X âŸ¶ X)] : finite_dimensional.finrank ğ•œ (X âŸ¶ X) = 1
theorem basis.adjust_to_orientation_apply_eq_or_eq_neg {R : Type u_1} [linear_ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {Î¹ : Type u_3} [decidable_eq Î¹] [fintype Î¹] [nontrivial R] [nonempty Î¹] (e : basis Î¹ R M) (x : orientation R M Î¹) (i : Î¹) : â‡‘(e.adjust_to_orientation x) i = â‡‘e i âˆ¨ â‡‘(e.adjust_to_orientation x) i = -â‡‘e i
theorem list.length_pos_of_sum_neg {M : Type u_3} [add_monoid M] [preorder M] (L : list M) (h : L.sum < 0) : 0 < L.length
theorem add_subgroup.norm_trivial_quotient_mk {M : Type u_1} [semi_normed_group M] (S : add_subgroup M) (h : â†‘(S.topological_closure) = set.univ) : âˆ¥S.normed_mkâˆ¥ = 0
theorem map_Inf_of_continuous_at_of_monotone' {Î± : Type u} {Î² : Type v} [complete_linear_order Î±] [topological_space Î±] [order_topology Î±] [complete_linear_order Î²] [topological_space Î²] [order_topology Î²] {f : Î± â†’ Î²} {s : set Î±} (Cf : continuous_at f (has_Inf.Inf s)) (Mf : monotone f) (hs : s.nonempty) : f (has_Inf.Inf s) = has_Inf.Inf (f '' s)
theorem category_theory.limits.pullback_cone.mono_of_is_limit_mk_id_id {C : Type u} [category_theory.category C] {X Y : C} (f : X âŸ¶ Y) (t : category_theory.limits.is_limit (category_theory.limits.pullback_cone.mk (ğŸ™ X) (ğŸ™ X) rfl)) : category_theory.mono f
theorem cauchy_seq_of_le_tendsto_0 {Î± : Type u} {Î² : Type v} [pseudo_metric_space Î±] [nonempty Î²] [semilattice_sup Î²] {s : Î² â†’ Î±} (b : Î² â†’ â„) (h : âˆ€ (n m N : Î²), N â‰¤ n â†’ N â‰¤ m â†’ has_dist.dist (s n) (s m) â‰¤ b N) (hâ‚€ : filter.tendsto b filter.at_top (nhds 0)) : cauchy_seq s
theorem real.le_rpow_add {x : â„} (hx : 0 â‰¤ x) (y z : â„) : x ^ y * x ^ z â‰¤ x ^ (y + z)
theorem finset.le_sum_nonempty_of_subadditive {Î¹ : Type u_1} {M : Type u_4} {N : Type u_5} [add_comm_monoid M] [ordered_add_comm_monoid N] (f : M â†’ N) (h_mul : âˆ€ (x y : M), f (x + y) â‰¤ f x + f y) {s : finset Î¹} (hs : s.nonempty) (g : Î¹ â†’ M) : f (s.sum (Î» (i : Î¹), g i)) â‰¤ s.sum (Î» (i : Î¹), f (g i))
theorem nat.factors_add_two (n : â„•) : (n + 2).factors = (n + 2).min_fac :: ((n + 2) / (n + 2).min_fac).factors
theorem is_greatest.bdd_above {Î± : Type u} [preorder Î±] {s : set Î±} {a : Î±} (h : is_greatest s a) : bdd_above s
theorem semiconj_by.transitive {S : Type u} [semigroup S] : transitive (Î» (a b : S), âˆƒ (c : S), semiconj_by c a b)
theorem fintype.exists_lt_card_fiber_of_mul_lt_card {Î± : Type u} {Î² : Type v} [decidable_eq Î²] [fintype Î±] [fintype Î²] (f : Î± â†’ Î²) {n : â„•} (hn : fintype.card Î² * n < fintype.card Î±) : âˆƒ (y : Î²), n < (finset.filter (Î» (x : Î±), f x = y) finset.univ).card
theorem fin.coe_order_iso_apply {n m : â„•} (e : fin n â‰ƒo fin m) (i : fin n) : â†‘(â‡‘e i) = â†‘i
theorem left.add_pos {Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b : Î±} (ha : 0 < a) (hb : 0 < b) : 0 < a + b
theorem measure_theory.outer_measure.infi_apply' {Î± : Type u_1} {Î¹ : Sort u_2} (m : Î¹ â†’ measure_theory.outer_measure Î±) {s : set Î±} (hs : s.nonempty) : (â‡‘â¨… (i : Î¹), m i) s = â¨… (t : â„• â†’ set Î±) (h2 : s âŠ† set.Union t), âˆ‘' (n : â„•), â¨… (i : Î¹), â‡‘(m i) (t n)
theorem univ.is_add_submonoid {M : Type u_1} [add_monoid M] : is_add_submonoid set.univ
theorem is_compact.integrable_on_of_nhds_within {X : Type u_1} {E : Type u_3} [measurable_space X] [topological_space X] [normed_group E] {f : X â†’ E} {Î¼ : measure_theory.measure X} {K : set X} (hK : is_compact K) (hf : âˆ€ (x : X), x âˆˆ K â†’ measure_theory.integrable_at_filter f (nhds_within x K) Î¼) : measure_theory.integrable_on f K Î¼
theorem finite_dimensional_direction_affine_span_of_finite (k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : set P} (h : s.finite) : finite_dimensional k â†¥((affine_span k s).direction)
theorem option.map_injective {Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} (Hf : function.injective f) : function.injective (option.map f)
theorem tendsto_exp_div_rpow_at_top (s : â„) : filter.tendsto (Î» (x : â„), real.exp x / x ^ s) filter.at_top filter.at_top
theorem conj_act.fixed_points_eq_center {G : Type u_2} [group G] : mul_action.fixed_points (conj_act G) G = â†‘(subgroup.center G)
theorem cSup_union {Î± : Type u_1} [conditionally_complete_lattice Î±] {s t : set Î±} (hs : bdd_above s) (sne : s.nonempty) (ht : bdd_above t) (tne : t.nonempty) : has_Sup.Sup (s âˆª t) = has_Sup.Sup s âŠ” has_Sup.Sup t
theorem euclidean_geometry.orthogonal_projection_fn_vsub_mem_direction_orthogonal {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace â„ P} [nonempty â†¥s] [complete_space â†¥(s.direction)] (p : P) : euclidean_geometry.orthogonal_projection_fn s p -áµ¥ p âˆˆ (s.direction)á—®
theorem finset.op_sum {Î² : Type u} {Î± : Type v} [add_comm_monoid Î²] {s : finset Î±} (f : Î± â†’ Î²) : mul_opposite.op (s.sum (Î» (x : Î±), f x)) = s.sum (Î» (x : Î±), mul_opposite.op (f x))
theorem continuous_within_at.tendsto {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] {f : Î± â†’ Î²} {s : set Î±} {x : Î±} (h : continuous_within_at f s x) : filter.tendsto f (nhds_within x s) (nhds (f x))
theorem finset.product_bUnion {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [decidable_eq Î³] (s : finset Î±) (t : finset Î²) (f : Î± Ã— Î² â†’ finset Î³) : (s.product t).bUnion f = s.bUnion (Î» (a : Î±), t.bUnion (Î» (b : Î²), f (a, b)))
theorem topological_space.is_topological_basis.sigma {Î¹ : Type u_1} {E : Î¹ â†’ Type u_2} [Î  (i : Î¹), topological_space (E i)] {s : Î  (i : Î¹), set (set (E i))} (hs : âˆ€ (i : Î¹), topological_space.is_topological_basis (s i)) : topological_space.is_topological_basis (â‹ƒ (i : Î¹), (Î» (u : set (E i)), sigma.mk i '' u) '' s i)
theorem strict_mono.dual_right {Î± : Type u} {Î² : Type v} [preorder Î±] [preorder Î²] {f : Î± â†’ Î²} : strict_mono f â†’ strict_anti (â‡‘order_dual.to_dual âˆ˜ f)
theorem has_le.le.trans_eq' {Î± : Type u} [preorder Î±] {a b c : Î±} : b â‰¤ c â†’ a = b â†’ a â‰¤ c
theorem finset.sum_powerset {Î± : Type u} {Î² : Type v} [add_comm_monoid Î²] (s : finset Î±) (f : finset Î± â†’ Î²) : s.powerset.sum (Î» (t : finset Î±), f t) = (finset.range (s.card + 1)).sum (Î» (j : â„•), (finset.powerset_len j s).sum (Î» (t : finset Î±), f t))
theorem filter.tendsto.implicit_function {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] [complete_space ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] [complete_space E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] [finite_dimensional ğ•œ F] {f : E â†’ F} {f' : E â†’L[ğ•œ] F} {a : E} (hf : has_strict_fderiv_at f f' a) (hf' : f'.range = âŠ¤) {Î± : Type u_4} {l : filter Î±} {gâ‚ : Î± â†’ F} {gâ‚‚ : Î± â†’ â†¥(f'.ker)} (hâ‚ : filter.tendsto gâ‚ l (nhds (f a))) (hâ‚‚ : filter.tendsto gâ‚‚ l (nhds 0)) : filter.tendsto (Î» (t : Î±), has_strict_fderiv_at.implicit_function f f' hf hf' (gâ‚ t) (gâ‚‚ t)) l (nhds a)
theorem monotone.tendsto_at_top_at_top_iff {Î± : Type u_3} {Î² : Type u_4} [nonempty Î±] [semilattice_sup Î±] [preorder Î²] {f : Î± â†’ Î²} (hf : monotone f) : filter.tendsto f filter.at_top filter.at_top â†” âˆ€ (b : Î²), âˆƒ (a : Î±), b â‰¤ f a
theorem one_add_mul_le_pow {R : Type uâ‚} [linear_ordered_ring R] {a : R} (H : -2 â‰¤ a) (n : â„•) : 1 + â†‘n * a â‰¤ (1 + a) ^ n
theorem le_one_of_one_le_inv {Î± : Type u} [group Î±] [has_le Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a : Î±} : 1 â‰¤ aâ»Â¹ â†’ a â‰¤ 1
theorem set.mem_of_indicator_ne_zero {Î± : Type u_1} {M : Type u_4} [has_zero M] {s : set Î±} {f : Î± â†’ M} {a : Î±} (h : s.indicator f a â‰  0) : a âˆˆ s
theorem nat.arithmetic_function.is_multiplicative.eq_iff_eq_on_prime_powers {R : Type u_1} [comm_monoid_with_zero R] (f : nat.arithmetic_function R) (hf : f.is_multiplicative) (g : nat.arithmetic_function R) (hg : g.is_multiplicative) : f = g â†” âˆ€ (p i : â„•), nat.prime p â†’ â‡‘f (p ^ i) = â‡‘g (p ^ i)
theorem dfinsupp.lift_add_hom_comp_single {Î¹ : Type u} {Î³ : Type w} {Î² : Î¹ â†’ Type v} [dec : decidable_eq Î¹] [Î  (i : Î¹), add_zero_class (Î² i)] [add_comm_monoid Î³] (f : Î  (i : Î¹), Î² i â†’+ Î³) (i : Î¹) : (â‡‘dfinsupp.lift_add_hom f).comp (dfinsupp.single_add_hom Î² i) = f i
theorem filter.tendsto.at_bot_mul_neg_const' {Î± : Type u_1} {R : Type u_2} {l : filter Î±} {f : Î± â†’ R} {r : R} [linear_ordered_ring R] [archimedean R] (hr : r < 0) (hf : filter.tendsto f l filter.at_bot) : filter.tendsto (Î» (x : Î±), f x * r) l filter.at_top
theorem generalized_continued_fraction.succ_nth_convergent_eq_squash_gcf_nth_convergent {K : Type u_1} {n : â„•} {g : generalized_continued_fraction K} [field K] (nth_part_denom_ne_zero : âˆ€ {b : K}, g.partial_denominators.nth n = option.some b â†’ b â‰  0) : g.convergents (n + 1) = (g.squash_gcf n).convergents n
theorem quadratic_eq_zero_iff_discrim_eq_sq {R : Type u_1} [comm_ring R] [is_domain R] {a b c : R} (h2 : 2 â‰  0) (ha : a â‰  0) (x : R) : a * x * x + b * x + c = 0 â†” discrim a b c = (2 * a * x + b) ^ 2
theorem generalized_continued_fraction.int_fract_pair.succ_nth_stream_eq_none_iff {K : Type u_1} [linear_ordered_field K] [floor_ring K] {v : K} {n : â„•} : generalized_continued_fraction.int_fract_pair.stream v (n + 1) = option.none â†” generalized_continued_fraction.int_fract_pair.stream v n = option.none âˆ¨ âˆƒ (ifp : generalized_continued_fraction.int_fract_pair K), generalized_continued_fraction.int_fract_pair.stream v n = option.some ifp âˆ§ ifp.fr = 0
theorem comp_assoc_left {Î± : Type u_1} (f : Î± â†’ Î± â†’ Î±) [is_associative Î± f] (x y : Î±) : f x âˆ˜ f y = f (f x y)
theorem mul_zero_eq_const {Mâ‚€ : Type u_1} [mul_zero_class Mâ‚€] : (Î» (_x : Mâ‚€), _x * 0) = function.const Mâ‚€ 0
theorem phragmen_lindelof.eq_zero_on_right_half_plane_of_superexponential_decay {E : Type u_1} [normed_group E] [normed_space â„‚ E] {f : â„‚ â†’ E} (hd : diff_cont_on_cl â„‚ f {z : â„‚ | 0 < z.re}) (hexp : âˆƒ (c : â„) (H : c < 2) (B : â„), f =O[filter.comap complex.abs filter.at_top âŠ“ filter.principal {z : â„‚ | 0 < z.re}] Î» (z : â„‚), real.exp (B * complex.abs z ^ c)) (hre : asymptotics.superpolynomial_decay filter.at_top real.exp (Î» (x : â„), âˆ¥f â†‘xâˆ¥)) (him : âˆƒ (C : â„), âˆ€ (x : â„), âˆ¥f (â†‘x * complex.I)âˆ¥ â‰¤ C) : set.eq_on f 0 {z : â„‚ | 0 â‰¤ z.re}
theorem add_monoid_hom.map_real_smul {E : Type u_1} [add_comm_group E] [module â„ E] [topological_space E] [has_continuous_smul â„ E] {F : Type u_2} [add_comm_group F] [module â„ F] [topological_space F] [has_continuous_smul â„ F] [t2_space F] (f : E â†’+ F) (hf : continuous â‡‘f) (c : â„) (x : E) : â‡‘f (c â€¢ x) = c â€¢ â‡‘f x
theorem category_theory.has_limit_of_created {C : Type uâ‚} [category_theory.category C] {D : Type uâ‚‚} [category_theory.category D] {J : Type w} [category_theory.category J] (K : J â¥¤ C) (F : C â¥¤ D) [category_theory.limits.has_limit (K â‹™ F)] [category_theory.creates_limit K F] : category_theory.limits.has_limit K
theorem polynomial.cyclotomic.monic (n : â„•) (R : Type u_1) [ring R] : (polynomial.cyclotomic n R).monic
theorem not_and_distrib {a b : Prop} : Â¬(a âˆ§ b) â†” Â¬a âˆ¨ Â¬b
theorem finsum_mem_insert_of_eq_zero_if_not_mem {Î± : Type u_1} {M : Type u_5} [add_comm_monoid M] {f : Î± â†’ M} {a : Î±} {s : set Î±} (h : a âˆ‰ s â†’ f a = 0) : finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ has_insert.insert a s), f i)) = finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), f i))
theorem prime_spectrum.gc (R : Type u) [comm_ring R] : galois_connection (Î» (I : ideal R), prime_spectrum.zero_locus â†‘I) (Î» (t : (set (prime_spectrum R))áµ’áµˆ), prime_spectrum.vanishing_ideal t)
theorem antilipschitz_with.le_mul_nndist {Î± : Type u_1} {Î² : Type u_2} [pseudo_metric_space Î±] [pseudo_metric_space Î²] {K : nnreal} {f : Î± â†’ Î²} : antilipschitz_with K f â†’ âˆ€ (x y : Î±), has_nndist.nndist x y â‰¤ K * has_nndist.nndist (f x) (f y)
theorem complex.has_strict_deriv_at_cosh (x : â„‚) : has_strict_deriv_at complex.cosh (complex.sinh x) x
theorem units.is_unit_units_mul {M : Type u_1} [monoid M] (u : MË£) (a : M) : is_unit (â†‘u * a) â†” is_unit a
theorem measure_theory.measure.restrict_mono {Î± : Type u_1} {m0 : measurable_space Î±} â¦ƒs s' : set Î±â¦„ (hs : s âŠ† s') â¦ƒÎ¼ Î½ : measure_theory.measure Î±â¦„ (hÎ¼Î½ : Î¼ â‰¤ Î½) : Î¼.restrict s â‰¤ Î½.restrict s'
theorem modular_group.bottom_row_surj {R : Type u_1} [comm_ring R] : set.surj_on (Î» (g : matrix.special_linear_group (fin 2) R), â†‘g 1) set.univ {cd : fin 2 â†’ R | is_coprime (cd 0) (cd 1)}
theorem one_lt_mul'' {Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a b : Î±} (ha : 1 < a) (hb : 1 < b) : 1 < a * b
theorem measure_theory.is_stopping_time.measurable_set_lt_of_is_lub {Î± : Type u_1} {Î¹ : Type u_3} {m : measurable_space Î±} [linear_order Î¹] {f : measure_theory.filtration Î¹ m} {Ï„ : Î± â†’ Î¹} [topological_space Î¹] [order_topology Î¹] [topological_space.first_countable_topology Î¹] (hÏ„ : measure_theory.is_stopping_time f Ï„) (i : Î¹) (h_lub : is_lub (set.Iio i) i) : measurable_set {x : Î± | Ï„ x < i}
theorem is_semiring_hom.comp {Î± : Type u} {Î² : Type v} [semiring Î±] [semiring Î²] {f : Î± â†’ Î²} (hf : is_semiring_hom f) {Î³ : Type u_1} [semiring Î³] {g : Î² â†’ Î³} (hg : is_semiring_hom g) : is_semiring_hom (g âˆ˜ f)
theorem complete_lattice.independent.sup_indep_univ {Î± : Type u_1} {Î¹ : Type u_3} [complete_lattice Î±] [fintype Î¹] {f : Î¹ â†’ Î±} : complete_lattice.independent f â†’ finset.univ.sup_indep f
theorem interval_integral.integral_has_fderiv_at {E : Type u_3} [normed_group E] [complete_space E] [normed_space â„ E] {f : â„ â†’ E} {a b : â„} (hf : interval_integrable f measure_theory.measure_space.volume a b) (hmeas_a : strongly_measurable_at_filter f (nhds a) measure_theory.measure_space.volume) (hmeas_b : strongly_measurable_at_filter f (nhds b) measure_theory.measure_space.volume) (ha : continuous_at f a) (hb : continuous_at f b) : has_fderiv_at (Î» (p : â„ Ã— â„), âˆ« (x : â„) in p.fst..p.snd, f x) ((continuous_linear_map.snd â„ â„ â„).smul_right (f b) - (continuous_linear_map.fst â„ â„ â„).smul_right (f a)) (a, b)
theorem category_theory.cosimplicial_object.Î´_comp_Î´_self {C : Type u} [category_theory.category C] (X : category_theory.cosimplicial_object C) {n : â„•} {i : fin (n + 2)} : X.Î´ i â‰« X.Î´ (â‡‘fin.cast_succ i) = X.Î´ i â‰« X.Î´ i.succ
theorem add_con.add_con_gen_mono {M : Type u_1} [has_add M] {r s : M â†’ M â†’ Prop} (h : âˆ€ (x y : M), r x y â†’ s x y) : add_con_gen r â‰¤ add_con_gen s
theorem category_theory.finrank_hom_simple_simple_eq_zero_of_not_iso {C : Type u_1} [category_theory.category C] [category_theory.preadditive C] (ğ•œ : Type u_3) [division_ring ğ•œ] [category_theory.limits.has_kernels C] [category_theory.linear ğ•œ C] {X Y : C} [category_theory.simple X] [category_theory.simple Y] (h : (X â‰… Y) â†’ false) : finite_dimensional.finrank ğ•œ (X âŸ¶ Y) = 0
theorem matrix.det_smul_inv_vec_mul_eq_cramer_transpose {n : Type u'} {Î± : Type v} [fintype n] [decidable_eq n] [comm_ring Î±] (A : matrix n n Î±) (b : n â†’ Î±) (h : is_unit A.det) : A.det â€¢ matrix.vec_mul b Aâ»Â¹ = â‡‘(A.transpose.cramer) b
theorem not_bdd_below_iff {Î± : Type u_1} [linear_order Î±] {s : set Î±} : Â¬bdd_below s â†” âˆ€ (x : Î±), âˆƒ (y : Î±) (H : y âˆˆ s), y < x
theorem fintype.card_fin_even {k : â„•} : fact (even (fintype.card (fin (bit0 k))))
theorem zmod.Ï‡â‚„_eq_neg_one_pow {n : â„•} (hn : n % 2 = 1) : â‡‘zmod.Ï‡â‚„ â†‘n = (-1) ^ (n / 2)
theorem basis.to_matrix_units_smul {Î¹ : Type u_1} {Râ‚‚ : Type u_7} {Mâ‚‚ : Type u_8} [comm_ring Râ‚‚] [add_comm_group Mâ‚‚] [module Râ‚‚ Mâ‚‚] [decidable_eq Î¹] (e : basis Î¹ Râ‚‚ Mâ‚‚) (w : Î¹ â†’ Râ‚‚Ë£) : e.to_matrix â‡‘(e.units_smul w) = matrix.diagonal (coe âˆ˜ w)
theorem is_compact.elim_finite_subfamily_closed {Î± : Type u} [topological_space Î±] {s : set Î±} {Î¹ : Type v} (hs : is_compact s) (Z : Î¹ â†’ set Î±) (hZc : âˆ€ (i : Î¹), is_closed (Z i)) (hsZ : (s âˆ© â‹‚ (i : Î¹), Z i) = âˆ…) : âˆƒ (t : finset Î¹), (s âˆ© â‹‚ (i : Î¹) (H : i âˆˆ t), Z i) = âˆ…
theorem denumerable.raise_sorted (l : list â„•) (n : â„•) : list.sorted has_le.le (denumerable.raise l n)
theorem Mon.filtered_colimits.colimit_one_eq {J : Type v} [category_theory.small_category J] (F : J â¥¤ Mon) [category_theory.is_filtered J] (j : J) : 1 = Mon.filtered_colimits.M.mk F âŸ¨j, 1âŸ©
theorem generalized_continued_fraction.nth_of_eq_some_of_succ_nth_int_fract_pair_stream {K : Type u_1} [linear_ordered_field K] [floor_ring K] {v : K} {n : â„•} {ifp_succ_n : generalized_continued_fraction.int_fract_pair K} (stream_succ_nth_eq : generalized_continued_fraction.int_fract_pair.stream v (n + 1) = option.some ifp_succ_n) : (generalized_continued_fraction.of v).s.nth n = option.some {a := 1, b := â†‘(ifp_succ_n.b)}
theorem gram_schmidt_orthonormal (ğ•œ : Type u_1) {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {Î¹ : Type u_3} [linear_order Î¹] [order_bot Î¹] [locally_finite_order Î¹] [is_well_order Î¹ has_lt.lt] [succ_order Î¹] [is_succ_archimedean Î¹] (f : Î¹ â†’ E) (hâ‚€ : linear_independent ğ•œ f) : orthonormal ğ•œ (gram_schmidt_normed ğ•œ f)
theorem monoid_hom.range_top_of_surjective {G : Type u_1} [group G] {N : Type u_2} [group N] (f : G â†’* N) (hf : function.surjective â‡‘f) : f.range = âŠ¤
theorem is_right_regular.ne_zero {R : Type u_1} {a : R} [mul_zero_class R] [nontrivial R] (ra : is_right_regular a) : a â‰  0
theorem cont_diff_at.neg {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {x : E} {n : with_top â„•} {f : E â†’ F} (hf : cont_diff_at ğ•œ n f x) : cont_diff_at ğ•œ n (Î» (x : E), -f x) x
theorem measure_theory.uniform_integrable_const {Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_3} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [normed_group Î²] {p : ennreal} {g : Î± â†’ Î²} (hp : 1 â‰¤ p) (hp_ne_top : p â‰  âŠ¤) (hgm : measure_theory.strongly_measurable g) (hg : measure_theory.mem_â„’p g p Î¼) : measure_theory.uniform_integrable (Î» (n : Î¹), g) p Î¼
theorem measure_theory.Lp_meas_subgroup_to_Lp_trim_norm_map {Î± : Type u_1} {F : Type u_6} {p : ennreal} [normed_group F] {m m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [hp : fact (1 â‰¤ p)] (hm : m â‰¤ m0) (f : â†¥(measure_theory.Lp_meas_subgroup F m p Î¼)) : âˆ¥measure_theory.Lp_meas_subgroup_to_Lp_trim F p Î¼ hm fâˆ¥ = âˆ¥fâˆ¥
theorem is_noetherian.exists_endomorphism_iterate_ker_inf_range_eq_bot {R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] [I : is_noetherian R M] (f : M â†’â‚—[R] M) : âˆƒ (n : â„•), n â‰  0 âˆ§ (f ^ n).ker âŠ“ (f ^ n).range = âŠ¥
theorem dite_comp_equiv_update {Î± : Type u_1} {Î² : Sort u_2} {Î³ : Sort u_3} {s : set Î±} (e : Î² â‰ƒ â†¥s) (v : Î² â†’ Î³) (w : Î± â†’ Î³) (j : Î²) (x : Î³) [decidable_eq Î²] [decidable_eq Î±] [Î  (j : Î±), decidable (j âˆˆ s)] : (Î» (i : Î±), dite (i âˆˆ s) (Î» (h : i âˆˆ s), function.update v j x (â‡‘(e.symm) âŸ¨i, hâŸ©)) (Î» (h : i âˆ‰ s), w i)) = function.update (Î» (i : Î±), dite (i âˆˆ s) (Î» (h : i âˆˆ s), v (â‡‘(e.symm) âŸ¨i, hâŸ©)) (Î» (h : i âˆ‰ s), w i)) â†‘(â‡‘e j) x
theorem vitali_family.eventually_measure_lt_top {Î± : Type u_1} [metric_space Î±] {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (v : vitali_family Î¼) [measure_theory.is_locally_finite_measure Î¼] (x : Î±) : âˆ€á¶  (a : set Î±) in v.filter_at x, â‡‘Î¼ a < âŠ¤
theorem con.lift_coe {M : Type u_1} {P : Type u_3} [mul_one_class M] [mul_one_class P] {c : con M} {f : M â†’* P} (H : c â‰¤ con.ker f) (x : M) : â‡‘(c.lift f H) â†‘x = â‡‘f x
theorem encodable.skolem {Î± : Type u_1} {Î² : Î± â†’ Type u_2} {P : Î  (x : Î±), Î² x â†’ Prop} [c : Î  (a : Î±), encodable (Î² a)] [d : Î  (x : Î±) (y : Î² x), decidable (P x y)] : (âˆ€ (x : Î±), âˆƒ (y : Î² x), P x y) â†” âˆƒ (f : Î  (a : Î±), Î² a), âˆ€ (x : Î±), P x (f x)
theorem orientation.two_zsmul_oangle_smul_left_self {V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) (x : V) {r : â„} : 2 â€¢ o.oangle (r â€¢ x) x = 0
theorem real.smul_map_diagonal_volume_pi {Î¹ : Type u_1} [fintype Î¹] [decidable_eq Î¹] {D : Î¹ â†’ â„} (h : (matrix.diagonal D).det â‰  0) : ennreal.of_real |(matrix.diagonal D).det| â€¢ measure_theory.measure.map â‡‘(â‡‘matrix.to_lin' (matrix.diagonal D)) measure_theory.measure_space.volume = measure_theory.measure_space.volume
theorem map_add_neg {G : Type u_6} {H : Type u_7} {F : Type u_8} [add_group G] [subtraction_monoid H] [add_monoid_hom_class F G H] (f : F) (a b : G) : â‡‘f (a + -b) = â‡‘f a + -â‡‘f b
theorem tot_sep_of_zero_dim {Î± : Type u} [topological_space Î±] [t2_space Î±] (h : topological_space.is_topological_basis {s : set Î± | is_clopen s}) : totally_separated_space Î±
theorem list.subperm.of_cons {Î± : Type uu} (a : Î±) {lâ‚ lâ‚‚ : list Î±} : a :: lâ‚ <+~ a :: lâ‚‚ â†’ lâ‚ <+~ lâ‚‚
theorem monoid_hom.eq_on_inv {M : Type u_3} {F : Type u_8} {G : Type u_1} [group G] [monoid M] [monoid_hom_class F G M] {f g : F} {x : G} (h : â‡‘f x = â‡‘g x) : â‡‘f xâ»Â¹ = â‡‘g xâ»Â¹
theorem ideal_eq_zero_of_localization {R : Type u} [comm_ring R] (I : ideal R) (h : âˆ€ (J : ideal R) (hJ : J.is_maximal), is_localization.coe_submodule (localization.at_prime J) I = 0) : I = 0
theorem metric.bounded_of_compact_space {Î± : Type u} [pseudo_metric_space Î±] {s : set Î±} [compact_space Î±] : metric.bounded s
theorem power_series.coeff_mul_of_lt_order {R : Type u_1} [semiring R] {Ï† Ïˆ : power_series R} {n : â„•} (h : â†‘n < Ïˆ.order) : â‡‘(power_series.coeff R n) (Ï† * Ïˆ) = 0
theorem measure_theory.outer_measure.mk_metric_mono {X : Type u_2} [emetric_space X] {mâ‚ mâ‚‚ : ennreal â†’ ennreal} (hle : mâ‚ â‰¤á¶ [nhds_within 0 (set.Ici 0)] mâ‚‚) : measure_theory.outer_measure.mk_metric mâ‚ â‰¤ measure_theory.outer_measure.mk_metric mâ‚‚
theorem measure_theory.measure.map_eq_sum {Î± : Type u_1} {Î² : Type u_2} {m0 : measurable_space Î±} [measurable_space Î²] [encodable Î²] [measurable_singleton_class Î²] (Î¼ : measure_theory.measure Î±) (f : Î± â†’ Î²) (hf : measurable f) : measure_theory.measure.map f Î¼ = measure_theory.measure.sum (Î» (b : Î²), â‡‘Î¼ (f â»Â¹' {b}) â€¢ measure_theory.measure.dirac b)
theorem image_subobject_map_comp_image_to_kernel {V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {A B C : V} {f : A âŸ¶ B} [category_theory.limits.has_image f] {g : B âŸ¶ C} [category_theory.limits.has_kernel g] (w : f â‰« g = 0) {A' B' C' : V} {f' : A' âŸ¶ B'} [category_theory.limits.has_image f'] {g' : B' âŸ¶ C'} [category_theory.limits.has_kernel g'] (w' : f' â‰« g' = 0) (Î± : category_theory.arrow.mk f âŸ¶ category_theory.arrow.mk f') [category_theory.limits.has_image_map Î±] (Î² : category_theory.arrow.mk g âŸ¶ category_theory.arrow.mk g') (p : Î±.right = Î².left) : image_to_kernel f g w â‰« category_theory.limits.kernel_subobject_map Î² = category_theory.limits.image_subobject_map Î± â‰« image_to_kernel f' g' w'
theorem affine_map.ext {k : Type u_1} {V1 : Type u_2} {P1 : Type u_3} {V2 : Type u_4} {P2 : Type u_5} [ring k] [add_comm_group V1] [module k V1] [add_torsor V1 P1] [add_comm_group V2] [module k V2] [add_torsor V2 P2] {f g : P1 â†’áµƒ[k] P2} (h : âˆ€ (p : P1), â‡‘f p = â‡‘g p) : f = g
theorem tendsto_measure_cthickening {Î± : Type u_1} [pseudo_metric_space Î±] [measurable_space Î±] [opens_measurable_space Î±] {Î¼ : measure_theory.measure Î±} {s : set Î±} (hs : âˆƒ (R : â„) (H : R > 0), â‡‘Î¼ (metric.cthickening R s) â‰  âŠ¤) : filter.tendsto (Î» (r : â„), â‡‘Î¼ (metric.cthickening r s)) (nhds 0) (nhds (â‡‘Î¼ (closure s)))
theorem finset.Ioc_eq_empty {Î± : Type u_1} [preorder Î±] [locally_finite_order Î±] {a b : Î±} : Â¬a < b â†’ finset.Ioc a b = âˆ…
theorem circle_integrable.out {E : Type u_1} [normed_group E] {f : â„‚ â†’ E} {c : â„‚} {R : â„} [normed_space â„‚ E] (hf : circle_integrable f c R) : interval_integrable (Î» (Î¸ : â„), deriv (circle_map c R) Î¸ â€¢ f (circle_map c R Î¸)) measure_theory.measure_space.volume 0 (2 * real.pi)
theorem setoid.classes_mk_classes {Î± : Type u_1} (c : set (set Î±)) (hc : setoid.is_partition c) : (setoid.mk_classes c _).classes = c
theorem mul_lt_of_lt_inv_mul {Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a b c : Î±} : b < aâ»Â¹ * c â†’ a * b < c
theorem disjoint.filter_principal {Î± : Type u_1} {s t : set Î±} : disjoint s t â†’ disjoint (filter.principal s) (filter.principal t)
theorem list.eq_nil_of_prefix_nil {Î± : Type u_1} {l : list Î±} : l <+: list.nil â†’ l = list.nil
theorem finsupp.sum_add_index {Î± : Type u_1} {M : Type u_5} {N : Type u_7} [add_zero_class M] [add_comm_monoid N] {f g : Î± â†’â‚€ M} {h : Î± â†’ M â†’ N} (h_zero : âˆ€ (a : Î±), a âˆˆ f.support âˆª g.support â†’ h a 0 = 0) (h_add : âˆ€ (a : Î±), a âˆˆ f.support âˆª g.support â†’ âˆ€ (bâ‚ bâ‚‚ : M), h a (bâ‚ + bâ‚‚) = h a bâ‚ + h a bâ‚‚) : (f + g).sum h = f.sum h + g.sum h
theorem category_theory.pi.has_limit_of_has_limit_comp_eval {I : Type vâ‚} {C : I â†’ Type uâ‚} [Î  (i : I), category_theory.category (C i)] {J : Type vâ‚} [category_theory.small_category J] {F : J â¥¤ Î  (i : I), C i} [âˆ€ (i : I), category_theory.limits.has_limit (F â‹™ category_theory.pi.eval C i)] : category_theory.limits.has_limit F
theorem ideal.exists_maximal (Î± : Type u) [semiring Î±] [nontrivial Î±] : âˆƒ (M : ideal Î±), M.is_maximal
theorem infi_eq_of_forall_ge_of_forall_gt_exists_lt {Î± : Type u_1} {Î¹ : Sort u_4} [complete_lattice Î±] {b : Î±} {f : Î¹ â†’ Î±} (hâ‚ : âˆ€ (i : Î¹), b â‰¤ f i) (hâ‚‚ : âˆ€ (w : Î±), b < w â†’ (âˆƒ (i : Î¹), f i < w)) : (â¨… (i : Î¹), f i) = b
theorem set.image_image2_right_anticomm {Î± : Type u_1} {Î² : Type u_3} {Î²' : Type u_4} {Î³ : Type u_5} {Î´ : Type u_7} {s : set Î±} {t : set Î²} {f : Î± â†’ Î²' â†’ Î³} {g : Î² â†’ Î²'} {f' : Î² â†’ Î± â†’ Î´} {g' : Î´ â†’ Î³} (h_right_anticomm : âˆ€ (a : Î±) (b : Î²), f a (g b) = g' (f' b a)) : set.image2 f s (g '' t) = g' '' set.image2 f' t s
theorem real.cosh_pos (x : â„) : 0 < real.cosh x
theorem nat.prime.multiplicity_factorial_mul_succ {n p : â„•} (hp : nat.prime p) : multiplicity p (p * (n + 1)).factorial = multiplicity p (p * n).factorial + multiplicity p (n + 1) + 1
theorem alternating_map.dom_coprod.summand_add_swap_smul_eq_zero {Î¹a : Type u_7} {Î¹b : Type u_8} [decidable_eq Î¹a] [decidable_eq Î¹b] [fintype Î¹a] [fintype Î¹b] {R' : Type u_9} {Máµ¢ : Type u_10} {Nâ‚ : Type u_11} {Nâ‚‚ : Type u_12} [comm_semiring R'] [add_comm_group Nâ‚] [module R' Nâ‚] [add_comm_group Nâ‚‚] [module R' Nâ‚‚] [add_comm_monoid Máµ¢] [module R' Máµ¢] (a : alternating_map R' Máµ¢ Nâ‚ Î¹a) (b : alternating_map R' Máµ¢ Nâ‚‚ Î¹b) (Ïƒ : equiv.perm.mod_sum_congr Î¹a Î¹b) {v : Î¹a âŠ• Î¹b â†’ Máµ¢} {i j : Î¹a âŠ• Î¹b} (hv : v i = v j) (hij : i â‰  j) : â‡‘(alternating_map.dom_coprod.summand a b Ïƒ) v + â‡‘(alternating_map.dom_coprod.summand a b (equiv.swap i j â€¢ Ïƒ)) v = 0
theorem has_deriv_at_exp_of_mem_ball {ğ•‚ : Type u_1} [nondiscrete_normed_field ğ•‚] [complete_space ğ•‚] [char_zero ğ•‚] {x : ğ•‚} (hx : x âˆˆ emetric.ball 0 (exp_series ğ•‚ ğ•‚).radius) : has_deriv_at (exp ğ•‚) (exp ğ•‚ x) x
theorem is_regular_one {R : Type u_1} [mul_one_class R] : is_regular 1
theorem measure_theory.measure_lt_top_of_is_compact_of_is_mul_left_invariant {G : Type u_1} [measurable_space G] [topological_space G] [borel_space G] {Î¼ : measure_theory.measure G} [group G] [topological_group G] [Î¼.is_mul_left_invariant] (U : set G) (hU : is_open U) (h'U : U.nonempty) (h : â‡‘Î¼ U â‰  âŠ¤) {K : set G} (hK : is_compact K) : â‡‘Î¼ K < âŠ¤
theorem affine_independent.injective {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {Î¹ : Type u_4} [nontrivial k] {p : Î¹ â†’ P} (ha : affine_independent k p) : function.injective p
theorem fermat_42.exists_pos_odd_minimal {a b c : â„¤} (h : fermat_42 a b c) : âˆƒ (a0 b0 c0 : â„¤), fermat_42.minimal a0 b0 c0 âˆ§ a0 % 2 = 1 âˆ§ 0 < c0
theorem monotone.add_strict_mono {Î± : Type u_1} {Î² : Type u_2} [has_add Î±] [preorder Î±] [preorder Î²] [covariant_class Î± Î± has_add.add has_lt.lt] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {f g : Î² â†’ Î±} (hf : monotone f) (hg : strict_mono g) : strict_mono (Î» (x : Î²), f x + g x)
theorem witt_vector.map_frobenius_poly.keyâ‚‚ (p : â„•) [hp : fact (nat.prime p)] {n i j : â„•} (hi : i < n) (hj : j < p ^ (n - i)) : j - pnat_multiplicity p âŸ¨j + 1, _âŸ© + n = i + j + (n - i - pnat_multiplicity p âŸ¨j + 1, _âŸ©)
theorem affine.simplex.face_points {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {n : â„•} (s : affine.simplex k P n) {fs : finset (fin (n + 1))} {m : â„•} (h : fs.card = m + 1) (i : fin (m + 1)) : (s.face h).points i = s.points (â‡‘(fs.order_emb_of_fin h) i)
theorem finset.affine_combination_linear {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {Î¹ : Type u_4} (s : finset Î¹) (p : Î¹ â†’ P) : (s.affine_combination p).linear = s.weighted_vsub p
theorem measure_theory.simple_func.integral_eq_lintegral' {Î± : Type u_1} {E : Type u_2} [normed_group E] {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {f : measure_theory.simple_func Î± E} {g : E â†’ ennreal} (hf : measure_theory.integrable â‡‘f Î¼) (hg0 : g 0 = 0) (ht : âˆ€ (b : E), g b â‰  âŠ¤) : measure_theory.simple_func.integral Î¼ (measure_theory.simple_func.map (ennreal.to_real âˆ˜ g) f) = (âˆ«â» (a : Î±), g (â‡‘f a) âˆ‚Î¼).to_real
theorem box_integral.box_additive_map.sum_boxes_congr {Î¹ : Type u_1} {M : Type u_2} [add_comm_monoid M] {Iâ‚€ : with_top (box_integral.box Î¹)} {I : box_integral.box Î¹} [fintype Î¹] (f : box_integral.box_additive_map Î¹ M Iâ‚€) (hI : â†‘I â‰¤ Iâ‚€) {Ï€â‚ Ï€â‚‚ : box_integral.prepartition I} (h : Ï€â‚.Union = Ï€â‚‚.Union) : Ï€â‚.boxes.sum (Î» (J : box_integral.box Î¹), â‡‘f J) = Ï€â‚‚.boxes.sum (Î» (J : box_integral.box Î¹), â‡‘f J)
theorem list.split_on_intercalate {Î± : Type u} (ls : list (list Î±)) [decidable_eq Î±] (x : Î±) (hx : âˆ€ (l : list Î±), l âˆˆ ls â†’ x âˆ‰ l) (hls : ls â‰  list.nil) : list.split_on x ([x].intercalate ls) = ls
theorem add_monoid_hom.map_sum {Î² : Type u} {Î± : Type v} {Î³ : Type w} [add_comm_monoid Î²] [add_comm_monoid Î³] (g : Î² â†’+ Î³) (f : Î± â†’ Î²) (s : finset Î±) : â‡‘g (s.sum (Î» (x : Î±), f x)) = s.sum (Î» (x : Î±), â‡‘g (f x))
theorem category_theory.is_pullback.paste_vert {C : Type uâ‚} [category_theory.category C] {Xâ‚â‚ Xâ‚â‚‚ Xâ‚‚â‚ Xâ‚‚â‚‚ Xâ‚ƒâ‚ Xâ‚ƒâ‚‚ : C} {hâ‚â‚ : Xâ‚â‚ âŸ¶ Xâ‚â‚‚} {hâ‚‚â‚ : Xâ‚‚â‚ âŸ¶ Xâ‚‚â‚‚} {hâ‚ƒâ‚ : Xâ‚ƒâ‚ âŸ¶ Xâ‚ƒâ‚‚} {vâ‚â‚ : Xâ‚â‚ âŸ¶ Xâ‚‚â‚} {vâ‚â‚‚ : Xâ‚â‚‚ âŸ¶ Xâ‚‚â‚‚} {vâ‚‚â‚ : Xâ‚‚â‚ âŸ¶ Xâ‚ƒâ‚} {vâ‚‚â‚‚ : Xâ‚‚â‚‚ âŸ¶ Xâ‚ƒâ‚‚} (s : category_theory.is_pullback hâ‚â‚ vâ‚â‚ vâ‚â‚‚ hâ‚‚â‚) (t : category_theory.is_pullback hâ‚‚â‚ vâ‚‚â‚ vâ‚‚â‚‚ hâ‚ƒâ‚) : category_theory.is_pullback hâ‚â‚ (vâ‚â‚ â‰« vâ‚‚â‚) (vâ‚â‚‚ â‰« vâ‚‚â‚‚) hâ‚ƒâ‚
theorem units.ne_zero {Mâ‚€ : Type u_1} [monoid_with_zero Mâ‚€] [nontrivial Mâ‚€] (u : Mâ‚€Ë£) : â†‘u â‰  0
theorem Top.presheaf.covering_of_presieve.second_obj_iso_pi_inters_Ï€ {C : Type u} [category_theory.category C] [category_theory.limits.has_products C] {X : Top} (F : Top.presheaf C X) (U : topological_space.opens â†¥X) (R : category_theory.presieve U) (f g : Î£ (V : topological_space.opens â†¥X), {f // R f}) : (Top.presheaf.covering_of_presieve.second_obj_iso_pi_inters F U R).hom â‰« category_theory.limits.pi.Ï€ (Î» (p : (Î£ (V : topological_space.opens â†¥X), {f // R f}) Ã— Î£ (V : topological_space.opens â†¥X), {f // R f}), F.obj (opposite.op (Top.presheaf.covering_of_presieve U R p.fst âŠ“ Top.presheaf.covering_of_presieve U R p.snd))) (f, g) = category_theory.limits.pi.Ï€ (Î» (fg : (Î£ (V : topological_space.opens â†¥X), {f // R f}) Ã— Î£ (W : topological_space.opens â†¥X), {g // R g}), F.obj (opposite.op (category_theory.limits.pullback fg.fst.snd.val fg.snd.snd.val))) (f, g) â‰« F.map (category_theory.eq_to_hom _).op
theorem category_theory.limits.has_binary_product.swap {C : Type u} [category_theory.category C] (P Q : C) [category_theory.limits.has_binary_product P Q] : category_theory.limits.has_binary_product Q P
theorem pgame.zero_lf {x : pgame} : 0.lf x â†” âˆƒ (i : x.left_moves), âˆ€ (j : (x.move_left i).right_moves), 0.lf ((x.move_left i).move_right j)
theorem polynomial_functions_closure_eq_top'  : (polynomial_functions unit_interval).topological_closure = âŠ¤
theorem category_theory.abelian.functor.preserves_exact_of_preserves_finite_colimits_of_epi {C : Type u} [category_theory.category C] {D : Type u} [category_theory.category D] (F : C â¥¤ D) {X Y Z : C} {f : X âŸ¶ Y} {g : Y âŸ¶ Z} [category_theory.abelian C] [category_theory.abelian D] [F.additive] [category_theory.limits.preserves_finite_colimits F] [category_theory.epi g] (ex : category_theory.exact f g) : category_theory.exact (F.map f) (F.map g)
theorem affine.simplex.orthogonal_projection_eq_circumcenter_of_exists_dist_eq {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {n : â„•} (s : affine.simplex â„ P n) {p : P} (hr : âˆƒ (r : â„), âˆ€ (i : fin (n + 1)), has_dist.dist (s.points i) p = r) : â†‘(â‡‘(s.orthogonal_projection_span) p) = s.circumcenter
theorem map_lt_line_map_iff_slope_lt_slope_right {k : Type u_1} {E : Type u_2} [linear_ordered_field k] [ordered_add_comm_group E] [module k E] [ordered_smul k E] {f : k â†’ E} {a b r : k} (h : 0 < (1 - r) * (b - a)) : f (â‡‘(affine_map.line_map a b) r) < â‡‘(affine_map.line_map (f a) (f b)) r â†” slope f a b < slope f (â‡‘(affine_map.line_map a b) r) b
theorem function.embedding.antisymm {Î± : Type u} {Î² : Type v} : (Î± â†ª Î²) â†’ (Î² â†ª Î±) â†’ nonempty (Î± â‰ƒ Î²)
theorem euclidean_geometry.angle_add_angle_add_angle_eq_pi {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {p1 p2 p3 : P} (h2 : p2 â‰  p1) (h3 : p3 â‰  p1) : euclidean_geometry.angle p1 p2 p3 + euclidean_geometry.angle p2 p3 p1 + euclidean_geometry.angle p3 p1 p2 = real.pi
theorem map_zpow {G : Type u_6} {H : Type u_7} {F : Type u_8} [group G] [division_monoid H] [monoid_hom_class F G H] (f : F) (g : G) (n : â„¤) : â‡‘f (g ^ n) = â‡‘f g ^ n
theorem bilin_form.is_Ortho.nondegenerate_iff_not_is_ortho_basis_self {R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] {n : Type w} [nontrivial R] [no_zero_divisors R] (B : bilin_form R M) (v : basis n R M) (hO : B.is_Ortho â‡‘v) : B.nondegenerate â†” âˆ€ (i : n), Â¬B.is_ortho (â‡‘v i) (â‡‘v i)
theorem is_closed_proj_of_is_compact {X : Type u_1} [topological_space X] [compact_space X] {Y : Type u_2} [topological_space Y] : is_closed_map prod.snd
theorem is_prime_pow_iff_unique_prime_dvd {n : â„•} : is_prime_pow n â†” âˆƒ! (p : â„•), nat.prime p âˆ§ p âˆ£ n
theorem function.is_fixed_pt_id {Î± : Type u} (x : Î±) : function.is_fixed_pt id x
theorem cont_diff_on_iff_ftaylor_series {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {f : E â†’ F} {n : with_top â„•} : cont_diff ğ•œ n f â†” has_ftaylor_series_up_to n f (ftaylor_series ğ•œ f)
theorem clifford_algebra.Î¹_sq_scalar {R : Type u_1} [comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] (Q : quadratic_form R M) (m : M) : â‡‘(clifford_algebra.Î¹ Q) m * â‡‘(clifford_algebra.Î¹ Q) m = â‡‘(algebra_map R (clifford_algebra Q)) (â‡‘Q m)
theorem normed_space.noncompact_space (ğ•œ : Type u_5) (E : Type u_6) [nondiscrete_normed_field ğ•œ] [normed_group E] [normed_space ğ•œ E] [nontrivial E] : noncompact_space E
theorem continuous_multilinear_map.continuous_eval {ğ•œ : Type u} {Î¹ : Type v} {E : Î¹ â†’ Type wE} {G : Type wG} [decidable_eq Î¹] [fintype Î¹] [nondiscrete_normed_field ğ•œ] [Î  (i : Î¹), normed_group (E i)] [Î  (i : Î¹), normed_space ğ•œ (E i)] [normed_group G] [normed_space ğ•œ G] : continuous (Î» (p : continuous_multilinear_map ğ•œ E G Ã— Î  (i : Î¹), E i), â‡‘(p.fst) p.snd)
theorem measure_theory.exists_absolutely_continuous_is_finite_measure {Î± : Type u_1} {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) [measure_theory.sigma_finite Î¼] : âˆƒ (Î½ : measure_theory.measure Î±), measure_theory.is_finite_measure Î½ âˆ§ Î¼.absolutely_continuous Î½
theorem add_monoid.is_torsion.torsion_eq_top {G : Type u_1} [add_comm_monoid G] (tG : add_monoid.is_torsion G) : add_comm_monoid.add_torsion G = âŠ¤
theorem add_con.ext {M : Type u_1} [has_add M] {c d : add_con M} (H : âˆ€ (x y : M), â‡‘c x y â†” â‡‘d x y) : c = d
theorem algebra.norm_eq_zero_iff {K : Type u_4} {L : Type u_5} [field K] [field L] [algebra K L] [finite_dimensional K L] {x : L} : â‡‘(algebra.norm K) x = 0 â†” x = 0
theorem real.sin_gt_sub_cube {x : â„} (h : 0 < x) (h' : x â‰¤ 1) : x - x ^ 3 / 4 < real.sin x
theorem nndist_eq_zero {Î³ : Type w} [metric_space Î³] {x y : Î³} : has_nndist.nndist x y = 0 â†” x = y
theorem subfield.multiset_prod_mem {K : Type u} [field K] (s : subfield K) (m : multiset K) : (âˆ€ (a : K), a âˆˆ m â†’ a âˆˆ s) â†’ m.prod âˆˆ s
theorem category_theory.limits.has_terminal_of_has_terminal_of_preserves_limit {C : Type uâ‚} [category_theory.category C] {D : Type uâ‚‚} [category_theory.category D] (G : C â¥¤ D) [category_theory.limits.has_terminal C] [category_theory.limits.preserves_limit (category_theory.functor.empty C) G] : category_theory.limits.has_terminal D
theorem matrix.det_mul_column {n : Type u_2} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] (v : n â†’ R) (A : matrix n n R) : matrix.det (Î» (i j : n), v i * A i j) = finset.univ.prod (Î» (i : n), v i) * A.det
theorem lt_of_sub_pos {Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b : Î±} : 0 < a - b â†’ b < a
theorem zmod.legendre_sym_sq_one' (p : â„•) [fact (nat.prime p)] (a : â„¤) (ha : â†‘a â‰  0) : zmod.legendre_sym p (a ^ 2) = 1
theorem measure_theory.unif_integrable_fintype {Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_3} {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) [normed_group Î²] {p : ennreal} [fintype Î¹] (hp_one : 1 â‰¤ p) (hp_top : p â‰  âŠ¤) {f : Î¹ â†’ Î± â†’ Î²} (hf : âˆ€ (i : Î¹), measure_theory.mem_â„’p (f i) p Î¼) : measure_theory.unif_integrable f p Î¼
theorem cardinal.mk_union_le {Î± : Type u} (S T : set Î±) : cardinal.mk â†¥(S âˆª T) â‰¤ cardinal.mk â†¥S + cardinal.mk â†¥T
theorem nnreal.inner_le_Lp_mul_Lq {Î¹ : Type u} (s : finset Î¹) (f g : Î¹ â†’ nnreal) {p q : â„} (hpq : p.is_conjugate_exponent q) : s.sum (Î» (i : Î¹), f i * g i) â‰¤ s.sum (Î» (i : Î¹), f i ^ p) ^ (1 / p) * s.sum (Î» (i : Î¹), g i ^ q) ^ (1 / q)
theorem ideal.is_domain_map_C_quotient {R : Type u} [comm_ring R] {P : ideal R} (H : P.is_prime) : is_domain (polynomial R â§¸ ideal.map polynomial.C P)
theorem linear_independent_monoid_hom (G : Type u_1) [monoid G] (L : Type u_2) [comm_ring L] [no_zero_divisors L] : linear_independent L (Î» (f : G â†’* L), â‡‘f)
theorem order.cofinal_meets_ideal_of_cofinals {P : Type u_1} [preorder P] (p : P) {Î¹ : Type u_2} [encodable Î¹] (ğ’Ÿ : Î¹ â†’ order.cofinal P) (i : Î¹) : âˆƒ (x : P), x âˆˆ ğ’Ÿ i âˆ§ x âˆˆ order.ideal_of_cofinals p ğ’Ÿ
theorem linear_equiv.to_add_monoid_hom_commutes {R : Type u_1} {S : Type u_6} {M : Type u_7} {Mâ‚‚ : Type u_9} [semiring R] [semiring S] [add_comm_monoid M] [add_comm_monoid Mâ‚‚] {module_M : module R M} {module_S_Mâ‚‚ : module S Mâ‚‚} {Ïƒ : R â†’+* S} {Ïƒ' : S â†’+* R} {reâ‚ : ring_hom_inv_pair Ïƒ Ïƒ'} {reâ‚‚ : ring_hom_inv_pair Ïƒ' Ïƒ} (e : M â‰ƒâ‚›â‚—[Ïƒ] Mâ‚‚) : e.to_linear_map.to_add_monoid_hom = e.to_add_equiv.to_add_monoid_hom
theorem set.countable_set_of_finite_subset {Î± : Type u} {s : set Î±} : s.countable â†’ {t : set Î± | t.finite âˆ§ t âŠ† s}.countable
theorem linear_independent_le_basis {R : Type u} [ring R] [strong_rank_condition R] {M : Type v} [add_comm_group M] [module R M] {Î¹ : Type u_1} (b : basis Î¹ R M) {Îº : Type u_1} (v : Îº â†’ M) (i : linear_independent R v) : cardinal.mk Îº â‰¤ cardinal.mk Î¹
theorem matrix.inv_of_eq_nonsing_inv {n : Type u'} {Î± : Type v} [fintype n] [decidable_eq n] [comm_ring Î±] (A : matrix n n Î±) [invertible A] : â…Ÿ A = Aâ»Â¹
theorem subfield.closure_mono {K : Type u} [field K] â¦ƒs t : set Kâ¦„ (h : s âŠ† t) : subfield.closure s â‰¤ subfield.closure t
theorem category_theory.Ran_is_sheaf_of_cover_lifting.glued_section_is_amalgamation {C D : Type u} [category_theory.category C] [category_theory.category D] {A : Type w} [category_theory.category A] [category_theory.limits.has_limits A] {J : category_theory.grothendieck_topology C} {K : category_theory.grothendieck_topology D} {G : C â¥¤ D} (hu : category_theory.cover_lifting J K G) (â„± : category_theory.Sheaf J A) {X : A} {U : D} {S : category_theory.sieve U} (hS : S âˆˆ â‡‘K U) {x : category_theory.presieve.family_of_elements ((category_theory.Ran G.op).obj â„±.val â‹™ category_theory.coyoneda.obj (opposite.op X)) S.arrows} (hx : x.compatible) : x.is_amalgamation (category_theory.Ran_is_sheaf_of_cover_lifting.glued_section hu â„± hS hx)
theorem linear_map.trace_eq_contract' (R : Type u_1) [comm_ring R] (M : Type u_2) [add_comm_group M] [module R M] [module.free R M] [module.finite R M] [nontrivial R] : linear_map.trace R M = (contract_left R M).comp (dual_tensor_hom_equiv R M M).symm.to_linear_map
theorem formal_multilinear_series.norm_le_div_pow_of_pos_of_lt_radius {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field ğ•œ] [normed_group E] [normed_space ğ•œ E] [normed_group F] [normed_space ğ•œ F] (p : formal_multilinear_series ğ•œ E F) {r : nnreal} (h0 : 0 < r) (h : â†‘r < p.radius) : âˆƒ (C : â„) (H : C > 0), âˆ€ (n : â„•), âˆ¥p nâˆ¥ â‰¤ C / â†‘r ^ n
theorem valuation_ring.of_integers {ğ’ª : Type u} {K : Type v} {Î“ : Type w} [comm_ring ğ’ª] [is_domain ğ’ª] [field K] [algebra ğ’ª K] [linear_ordered_comm_group_with_zero Î“] (v : valuation K Î“) (hh : v.integers ğ’ª) : valuation_ring ğ’ª
theorem eq.absolutely_continuous {Î± : Type u_1} {m0 : measurable_space Î±} {Î¼ Î½ : measure_theory.measure Î±} (h : Î¼ = Î½) : Î¼.absolutely_continuous Î½
theorem finset.sum_erase_add {Î² : Type u} {Î± : Type v} [add_comm_monoid Î²] [decidable_eq Î±] (s : finset Î±) (f : Î± â†’ Î²) {a : Î±} (h : a âˆˆ s) : (s.erase a).sum (Î» (x : Î±), f x) + f a = s.sum (Î» (x : Î±), f x)
theorem finprod_mem_empty {Î± : Type u_1} {M : Type u_5} [comm_monoid M] {f : Î± â†’ M} : finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ âˆ…), f i)) = 1
theorem matrix.is_symm_diagonal {Î± : Type u_1} {n : Type u_3} [decidable_eq n] [has_zero Î±] (v : n â†’ Î±) : (matrix.diagonal v).is_symm
theorem continuous_linear_equiv.cont_diff_on_comp_iff {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {G : Type u_4} [normed_group G] [normed_space ğ•œ G] {s : set E} {f : E â†’ F} {n : with_top â„•} (e : G â‰ƒL[ğ•œ] E) : cont_diff_on ğ•œ n (f âˆ˜ â‡‘e) (â‡‘e â»Â¹' s) â†” cont_diff_on ğ•œ n f s
theorem zmod.cast_neg_one {R : Type u_1} [ring R] (n : â„•) : â†‘-1 = â†‘n - 1
theorem filter.has_basis.restrict_subset {Î± : Type u_1} {Î¹ : Sort u_4} {l : filter Î±} {p : Î¹ â†’ Prop} {s : Î¹ â†’ set Î±} (h : l.has_basis p s) {V : set Î±} (hV : V âˆˆ l) : l.has_basis (Î» (i : Î¹), p i âˆ§ s i âŠ† V) s
theorem is_compact_iff_finite_subfamily_closed {Î± : Type u} [topological_space Î±] {s : set Î±} : is_compact s â†” âˆ€ {Î¹ : Type u} (Z : Î¹ â†’ set Î±), (âˆ€ (i : Î¹), is_closed (Z i)) â†’ (s âˆ© â‹‚ (i : Î¹), Z i) = âˆ… â†’ (âˆƒ (t : finset Î¹), (s âˆ© â‹‚ (i : Î¹) (H : i âˆˆ t), Z i) = âˆ…)
theorem tendsto_inv_zero_at_top {Î± : Type u} [linear_ordered_field Î±] [topological_space Î±] [order_topology Î±] : filter.tendsto (Î» (x : Î±), xâ»Â¹) (nhds_within 0 (set.Ioi 0)) filter.at_top
theorem affine.triangle.orthocenter_eq_monge_point {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] (t : affine.triangle â„ P) : t.orthocenter = affine.simplex.monge_point t
theorem function.injective.comp_left {Î± : Sort u_1} {Î² : Sort u_2} {Î³ : Sort u_3} {g : Î² â†’ Î³} (hg : function.injective g) : function.injective (function.comp g)
theorem ae_eq_const_or_norm_average_lt_of_norm_le_const {Î± : Type u_1} {E : Type u_2} {m0 : measurable_space Î±} [normed_group E] [normed_space â„ E] [complete_space E] {Î¼ : measure_theory.measure Î±} {f : Î± â†’ E} {C : â„} [strict_convex_space â„ E] (h_le : âˆ€áµ (x : Î±) âˆ‚Î¼, âˆ¥f xâˆ¥ â‰¤ C) : f =áµ[Î¼] function.const Î± (â¨ (x : Î±), f x âˆ‚Î¼) âˆ¨ âˆ¥â¨ (x : Î±), f x âˆ‚Î¼âˆ¥ < C
theorem pgame.numeric_to_pgame (o : ordinal) : o.to_pgame.numeric
theorem tendsto_uniformly_on.tendsto_comp {Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_4} [uniform_space Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : set Î±} {x : Î±} {p : filter Î¹} {g : Î¹ â†’ Î±} [topological_space Î±] (h : tendsto_uniformly_on F f p s) (hf : continuous_within_at f s x) (hg : filter.tendsto g p (nhds_within x s)) : filter.tendsto (Î» (n : Î¹), F n (g n)) p (nhds (f x))
theorem interval_integral.integrable_on_deriv_of_nonneg {a b : â„} {g' g : â„ â†’ â„} (hab : a â‰¤ b) (hcont : continuous_on g (set.Icc a b)) (hderiv : âˆ€ (x : â„), x âˆˆ set.Ioo a b â†’ has_deriv_at g (g' x) x) (g'pos : âˆ€ (x : â„), x âˆˆ set.Ioo a b â†’ 0 â‰¤ g' x) : measure_theory.integrable_on g' (set.Ioc a b) measure_theory.measure_space.volume
theorem affine.simplex.circumcenter_circumradius_unique_dist_eq {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {n : â„•} (s : affine.simplex â„ P n) : (s.circumcenter_circumradius.fst âˆˆ affine_span â„ (set.range s.points) âˆ§ âˆ€ (i : fin (n + 1)), has_dist.dist (s.points i) s.circumcenter_circumradius.fst = s.circumcenter_circumradius.snd) âˆ§ âˆ€ (cccr : P Ã— â„), (cccr.fst âˆˆ affine_span â„ (set.range s.points) âˆ§ âˆ€ (i : fin (n + 1)), has_dist.dist (s.points i) cccr.fst = cccr.snd) â†’ cccr = s.circumcenter_circumradius
theorem strict_mono_on.continuous_at_left_of_exists_between {Î± : Type u_1} {Î² : Type u_2} [linear_order Î±] [topological_space Î±] [order_topology Î±] [linear_order Î²] [topological_space Î²] [order_topology Î²] {f : Î± â†’ Î²} {s : set Î±} {a : Î±} (h_mono : strict_mono_on f s) (hs : s âˆˆ nhds_within a (set.Iic a)) (hfs : âˆ€ (b : Î²), b < f a â†’ (âˆƒ (c : Î±) (H : c âˆˆ s), f c âˆˆ set.Ico b (f a))) : continuous_within_at f (set.Iic a) a
theorem minpoly.zero (A : Type u_1) (B : Type u_2) [field A] [ring B] [algebra A B] [nontrivial B] : minpoly A 0 = polynomial.X
theorem category_theory.triangulated.pretriangulated.comp_dist_triangle_mor_zeroâ‚â‚‚ (C : Type u) [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.has_shift C â„¤] [category_theory.preadditive C] [âˆ€ (n : â„¤), (category_theory.shift_functor C n).additive] [category_theory.triangulated.pretriangulated C] (T : category_theory.triangulated.triangle C) (H : T âˆˆ dist_triang C) : T.morâ‚ â‰« T.morâ‚‚ = 0
theorem subgroup.supr_induction' {G : Type u_1} [group G] {Î¹ : Sort u_2} (S : Î¹ â†’ subgroup G) {C : Î  (x : G), (x âˆˆ â¨† (i : Î¹), S i) â†’ Prop} (hp : âˆ€ (i : Î¹) (x : G) (H : x âˆˆ S i), C x _) (h1 : C 1 _) (hmul : âˆ€ (x y : G) (hx : x âˆˆ â¨† (i : Î¹), S i) (hy : y âˆˆ â¨† (i : Î¹), S i), C x hx â†’ C y hy â†’ C (x * y) _) {x : G} (hx : x âˆˆ â¨† (i : Î¹), S i) : C x hx
theorem real.arsinh_sinh (x : â„) : real.arsinh (real.sinh x) = x
theorem real.pi_upper_bound_start (n : â„•) {a : â„} (h : 2 - ((a - 1 / 4 ^ n) / 2 ^ (n + 1)) ^ 2 â‰¤ real.sqrt_two_add_series (â†‘0 / â†‘1) n) (hâ‚‚ : 1 / 4 ^ n â‰¤ a) : real.pi < a
theorem function.injective.subsingleton {Î± : Sort u} {Î² : Sort v} {f : Î± â†’ Î²} (hf : function.injective f) [subsingleton Î²] : subsingleton Î±
theorem euclidean_geometry.dist_orthogonal_projection_ne_zero_of_not_mem {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace â„ P} [nonempty â†¥s] [complete_space â†¥(s.direction)] {p : P} (hp : p âˆ‰ s) : has_dist.dist p â†‘(â‡‘(euclidean_geometry.orthogonal_projection s) p) â‰  0
theorem nat.diag_induction (P : â„• â†’ â„• â†’ Prop) (ha : âˆ€ (a : â„•), P (a + 1) (a + 1)) (hb : âˆ€ (b : â„•), P 0 (b + 1)) (hd : âˆ€ (a b : â„•), a < b â†’ P (a + 1) b â†’ P a (b + 1) â†’ P (a + 1) (b + 1)) (a b : â„•) : a < b â†’ P a b
theorem vsub_left_injective {G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] (p : P) : function.injective (Î» (_x : P), _x -áµ¥ p)
theorem least_descending_central_series_length_eq_nilpotency_class {G : Type u_1} [group G] [hG : group.is_nilpotent G] : nat.find _ = group.nilpotency_class G
theorem monovary.sum_smul_comp_perm_eq_sum_smul_iff {Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [linear_ordered_ring Î±] [linear_ordered_add_comm_group Î²] [module Î± Î²] [ordered_smul Î± Î²] {Ïƒ : equiv.perm Î¹} {f : Î¹ â†’ Î±} {g : Î¹ â†’ Î²} [fintype Î¹] (hfg : monovary f g) : finset.univ.sum (Î» (i : Î¹), f i â€¢ g (â‡‘Ïƒ i)) = finset.univ.sum (Î» (i : Î¹), f i â€¢ g i) â†” monovary f (g âˆ˜ â‡‘Ïƒ)
theorem affine_independent.range {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {Î¹ : Type u_4} {p : Î¹ â†’ P} (ha : affine_independent k p) : affine_independent k (Î» (x : â†¥(set.range p)), â†‘x)
theorem has_lt.lt.not_is_max {Î± : Type u_1} [preorder Î±] {a b : Î±} (h : a < b) : Â¬is_max a
theorem box_integral.prepartition.inj_on_set_of_mem_Icc_set_of_lower_eq {Î¹ : Type u_1} {I : box_integral.box Î¹} (Ï€ : box_integral.prepartition I) (x : Î¹ â†’ â„) : set.inj_on (Î» (J : box_integral.box Î¹), {i : Î¹ | J.lower i = x i}) {J : box_integral.box Î¹ | J âˆˆ Ï€ âˆ§ x âˆˆ â‡‘box_integral.box.Icc J}
theorem eq_of_deriv_within_eq {E : Type u_1} [normed_group E] [normed_space â„ E] {f : â„ â†’ E} {a b : â„} {g : â„ â†’ E} (fdiff : differentiable_on â„ f (set.Icc a b)) (gdiff : differentiable_on â„ g (set.Icc a b)) (hderiv : set.eq_on (deriv_within f (set.Icc a b)) (deriv_within g (set.Icc a b)) (set.Ico a b)) (hi : f a = g a) (y : â„) (H : y âˆˆ set.Icc a b) : f y = g y
theorem spectrum.map_polynomial_aeval_of_nonempty {ğ•œ : Type u} {A : Type v} [field ğ•œ] [ring A] [algebra ğ•œ A] [is_alg_closed ğ•œ] [nontrivial A] (a : A) (p : polynomial ğ•œ) (hnon : (spectrum ğ•œ a).nonempty) : spectrum ğ•œ (â‡‘(polynomial.aeval a) p) = (Î» (k : ğ•œ), polynomial.eval k p) '' spectrum ğ•œ a
theorem list.prod_inv_reverse {G : Type u_7} [group G] (L : list G) : (L.prod)â»Â¹ = (list.map (Î» (x : G), xâ»Â¹) L).reverse.prod
theorem strongly_measurable_iff_measurable_separable {Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} {m : measurable_space Î±} [topological_space Î²] [topological_space.pseudo_metrizable_space Î²] [measurable_space Î²] [borel_space Î²] : measure_theory.strongly_measurable f â†” measurable f âˆ§ topological_space.is_separable (set.range f)
theorem quaternion_group.order_of_a_one {n : â„•} : order_of (quaternion_group.a 1) = 2 * n
theorem function.periodic.integral_le_Sup_add_zsmul_of_pos {T : â„} {g : â„ â†’ â„} (hg : function.periodic g T) (h_int : âˆ€ (tâ‚ tâ‚‚ : â„), interval_integrable g measure_theory.measure_space.volume tâ‚ tâ‚‚) (hT : 0 < T) (t : â„) : âˆ« (x : â„) in 0..t, g x â‰¤ has_Sup.Sup ((Î» (t : â„), âˆ« (x : â„) in 0..t, g x) '' set.Icc 0 T) + âŒŠt / TâŒ‹ â€¢ âˆ« (x : â„) in 0..T, g x
theorem upper_semicontinuous_at.add' {Î± : Type u_1} [topological_space Î±] {x : Î±} {Î³ : Type u_4} [linear_ordered_add_comm_monoid Î³] [topological_space Î³] [order_topology Î³] {f g : Î± â†’ Î³} (hf : upper_semicontinuous_at f x) (hg : upper_semicontinuous_at g x) (hcont : continuous_at (Î» (p : Î³ Ã— Î³), p.fst + p.snd) (f x, g x)) : upper_semicontinuous_at (Î» (z : Î±), f z + g z) x
theorem is_localization.lift_mk' {R : Type u_1} [comm_semiring R] {M : submonoid R} {S : Type u_2} [comm_semiring S] [algebra R S] {P : Type u_3} [comm_semiring P] [is_localization M S] {g : R â†’+* P} (hg : âˆ€ (y : â†¥M), is_unit (â‡‘g â†‘y)) (x : R) (y : â†¥M) : â‡‘(is_localization.lift hg) (is_localization.mk' S x y) = â‡‘g x * â†‘(â‡‘(is_unit.lift_right (g.to_monoid_hom.restrict M) hg) y)â»Â¹
theorem phragmen_lindelof.eq_zero_on_quadrant_III {E : Type u_1} [normed_group E] [normed_space â„‚ E] {f : â„‚ â†’ E} (hd : diff_cont_on_cl â„‚ f (set.Iio 0 Ã—â„‚ set.Iio 0)) (hB : âˆƒ (c : â„) (H : c < 2) (B : â„), f =O[filter.comap complex.abs filter.at_top âŠ“ filter.principal (set.Iio 0 Ã—â„‚ set.Iio 0)] Î» (z : â„‚), real.exp (B * complex.abs z ^ c)) (hre : âˆ€ (x : â„), x â‰¤ 0 â†’ f â†‘x = 0) (him : âˆ€ (x : â„), x â‰¤ 0 â†’ f (â†‘x * complex.I) = 0) : set.eq_on f 0 {z : â„‚ | z.re â‰¤ 0 âˆ§ z.im â‰¤ 0}
theorem measure_theory.lintegral_eq_zero_of_is_mul_left_invariant {G : Type u_4} [measurable_space G] {Î¼ : measure_theory.measure G} [topological_space G] [group G] [topological_group G] [borel_space G] [Î¼.is_mul_left_invariant] [Î¼.regular] (hÎ¼ : Î¼ â‰  0) {f : G â†’ ennreal} (hf : continuous f) : âˆ«â» (x : G), f x âˆ‚Î¼ = 0 â†” f = 0
theorem function.cSup_div_semiconj {Î± : Type u_1} {G : Type u_4} [conditionally_complete_lattice Î±] [group G] (fâ‚ fâ‚‚ : G â†’* Î± â‰ƒo Î±) (hbdd : âˆ€ (x : Î±), bdd_above (set.range (Î» (g : G), â‡‘(â‡‘fâ‚ g)â»Â¹ (â‡‘(â‡‘fâ‚‚ g) x)))) (g : G) : function.semiconj (Î» (x : Î±), â¨† (g' : G), â‡‘(â‡‘fâ‚ g')â»Â¹ (â‡‘(â‡‘fâ‚‚ g') x)) â‡‘(â‡‘fâ‚‚ g) â‡‘(â‡‘fâ‚ g)
theorem tensor_product.algebra_tensor_module.curry_injective {R : Type u_1} {A : Type u_2} {M : Type u_3} {N : Type u_4} {P : Type u_5} [comm_semiring R] [semiring A] [algebra R A] [add_comm_monoid M] [module R M] [module A M] [is_scalar_tower R A M] [add_comm_monoid N] [module R N] [add_comm_monoid P] [module R P] [module A P] [is_scalar_tower R A P] : function.injective tensor_product.algebra_tensor_module.curry
theorem category_theory.id_has_right_lifting_property {C : Type u} [category_theory.category C] {X : C} (i : category_theory.arrow C) : category_theory.has_lifting_property i (category_theory.arrow.mk (ğŸ™ X))
theorem finset.bdd_above {Î± : Type u} [semilattice_sup Î±] [nonempty Î±] (s : finset Î±) : bdd_above â†‘s
theorem matrix.coe_units_inv {n : Type u'} {Î± : Type v} [fintype n] [decidable_eq n] [comm_ring Î±] (A : (matrix n n Î±)Ë£) : â†‘Aâ»Â¹ = (â†‘A)â»Â¹
theorem neg_convex_on_iff {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [ordered_semiring ğ•œ] [add_comm_monoid E] [ordered_add_comm_group Î²] [has_scalar ğ•œ E] [module ğ•œ Î²] {s : set E} {f : E â†’ Î²} : convex_on ğ•œ s (-f) â†” concave_on ğ•œ s f
theorem measure_theory.measure.mk_metric_mono {X : Type u_2} [emetric_space X] [measurable_space X] [borel_space X] {mâ‚ mâ‚‚ : ennreal â†’ ennreal} (hle : mâ‚ â‰¤á¶ [nhds_within 0 (set.Ici 0)] mâ‚‚) : measure_theory.measure.mk_metric mâ‚ â‰¤ measure_theory.measure.mk_metric mâ‚‚
theorem affine_subspace.direction_eq_top_iff_of_nonempty {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {s : affine_subspace k P} (h : â†‘s.nonempty) : s.direction = âŠ¤ â†” s = âŠ¤
theorem add_subgroup.subset_closure {G : Type u_1} [add_group G] {k : set G} : k âŠ† â†‘(add_subgroup.closure k)
theorem category_theory.is_reflexive_pair.swap {C : Type u} [category_theory.category C] {A B : C} {f g : A âŸ¶ B} [category_theory.is_reflexive_pair f g] : category_theory.is_reflexive_pair g f
theorem con.lift_comp_mk' {M : Type u_1} {P : Type u_3} [mul_one_class M] [mul_one_class P] {c : con M} {f : M â†’* P} (H : c â‰¤ con.ker f) : (c.lift f H).comp c.mk' = f
theorem equiv.swap_mul_self_mul {Î± : Type u} [decidable_eq Î±] (i j : Î±) (Ïƒ : equiv.perm Î±) : equiv.swap i j * (equiv.swap i j * Ïƒ) = Ïƒ
theorem add_subgroup.ker_normed_mk {M : Type u_1} [semi_normed_group M] (S : add_subgroup M) : S.normed_mk.ker = S
theorem mul_right_bound {Î± : Type u_1} [non_unital_semi_normed_ring Î±] (x y : Î±) : âˆ¥â‡‘(add_monoid_hom.mul_right x) yâˆ¥ â‰¤ âˆ¥xâˆ¥ * âˆ¥yâˆ¥
theorem polynomial.separable_X_pow_sub_C_unit {R : Type u} [comm_ring R] {n : â„•} (u : RË£) (hn : is_unit â†‘n) : (polynomial.X ^ n - â‡‘polynomial.C â†‘u).separable
theorem subsingleton_of_forall_eq {Î± : Sort u_1} (x : Î±) (h : âˆ€ (y : Î±), y = x) : subsingleton Î±
theorem measure_theory.ae_restrict_interval_oc_iff {Î± : Type u_1} {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [linear_order Î±] {a b : Î±} {P : Î± â†’ Prop} : (âˆ€áµ (x : Î±) âˆ‚Î¼.restrict (set.interval_oc a b), P x) â†” (âˆ€áµ (x : Î±) âˆ‚Î¼.restrict (set.Ioc a b), P x) âˆ§ âˆ€áµ (x : Î±) âˆ‚Î¼.restrict (set.Ioc b a), P x
theorem concave_on.le_map_average {Î± : Type u_1} {E : Type u_2} {m0 : measurable_space Î±} [normed_group E] [normed_space â„ E] [complete_space E] {Î¼ : measure_theory.measure Î±} {s : set E} {f : Î± â†’ E} {g : E â†’ â„} [measure_theory.is_finite_measure Î¼] (hg : concave_on â„ s g) (hgc : continuous_on g s) (hsc : is_closed s) (hÎ¼ : Î¼ â‰  0) (hfs : âˆ€áµ (x : Î±) âˆ‚Î¼, f x âˆˆ s) (hfi : measure_theory.integrable f Î¼) (hgi : measure_theory.integrable (g âˆ˜ f) Î¼) : â¨ (x : Î±), g (f x) âˆ‚Î¼ â‰¤ g (â¨ (x : Î±), f x âˆ‚Î¼)
theorem list.take_sum_join {Î± : Type u_1} (L : list (list Î±)) (i : â„•) : list.take (list.take i (list.map list.length L)).sum L.join = (list.take i L).join
theorem measure_theory.lintegral_add_right_eq_self {G : Type u_4} [measurable_space G] {Î¼ : measure_theory.measure G} [add_group G] [has_measurable_add G] [Î¼.is_add_right_invariant] (f : G â†’ ennreal) (g : G) : âˆ«â» (x : G), f (x + g) âˆ‚Î¼ = âˆ«â» (x : G), f x âˆ‚Î¼
theorem field.localization_map_bijective {K : Type u_1} {Kâ‚˜ : Type u_2} [field K] [comm_ring Kâ‚˜] {M : submonoid K} (hM : 0 âˆ‰ M) [algebra K Kâ‚˜] [is_localization M Kâ‚˜] : function.bijective â‡‘(algebra_map K Kâ‚˜)
theorem continuous_linear_map.ext_on {Râ‚ : Type u_1} {Râ‚‚ : Type u_2} [semiring Râ‚] [semiring Râ‚‚] {Ïƒâ‚â‚‚ : Râ‚ â†’+* Râ‚‚} {Mâ‚ : Type u_4} [topological_space Mâ‚] [add_comm_monoid Mâ‚] {Mâ‚‚ : Type u_6} [topological_space Mâ‚‚] [add_comm_monoid Mâ‚‚] [module Râ‚ Mâ‚] [module Râ‚‚ Mâ‚‚] [t2_space Mâ‚‚] {s : set Mâ‚} (hs : dense â†‘(submodule.span Râ‚ s)) {f g : Mâ‚ â†’SL[Ïƒâ‚â‚‚] Mâ‚‚} (h : set.eq_on â‡‘f â‡‘g s) : f = g
theorem is_add_submonoid.smul_mem {M : Type u_1} [add_monoid M] {s : set M} {a : M} (hs : is_add_submonoid s) (h : a âˆˆ s) {n : â„•} : n â€¢ a âˆˆ s
theorem ideal.quotient_map_injective {R : Type u_1} {S : Type u_2} [comm_ring R] [comm_ring S] {I : ideal S} {f : R â†’+* S} : function.injective â‡‘(I.quotient_map f le_rfl)
theorem intermediate_field.inv_mem {K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) {x : L} : x âˆˆ S â†’ xâ»Â¹ âˆˆ S
theorem uniform_space.compact_iff_seq_compact {X : Type u_1} [uniform_space X] {s : set X} [(uniformity X).is_countably_generated] : is_compact s â†” is_seq_compact s
theorem module.ray.some_ray_vector_ray {R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] (x : module.ray R M) : âŸ¦x.some_ray_vectorâŸ§ = x
theorem lower_semicontinuous.add {Î± : Type u_1} [topological_space Î±] {Î³ : Type u_4} [linear_ordered_add_comm_monoid Î³] [topological_space Î³] [order_topology Î³] [has_continuous_add Î³] {f g : Î± â†’ Î³} (hf : lower_semicontinuous f) (hg : lower_semicontinuous g) : lower_semicontinuous (Î» (z : Î±), f z + g z)
theorem one_lt_mul_of_lt_of_le' {Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a b : Î±} (ha : 1 < a) (hb : 1 â‰¤ b) : 1 < a * b
theorem measurable.ite {Î± : Type u_1} {Î² : Type u_2} {f g : Î± â†’ Î²} {m : measurable_space Î±} {mÎ² : measurable_space Î²} {p : Î± â†’ Prop} {_x : decidable_pred p} (hp : measurable_set {a : Î± | p a}) (hf : measurable f) (hg : measurable g) : measurable (Î» (x : Î±), ite (p x) (f x) (g x))
theorem nhds_basis_opens {Î± : Type u} [topological_space Î±] (a : Î±) : (nhds a).has_basis (Î» (s : set Î±), a âˆˆ s âˆ§ is_open s) (Î» (s : set Î±), s)
theorem function.periodic.exists_mem_Ico {Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} {c : Î±} [linear_ordered_add_comm_group Î±] [archimedean Î±] (h : function.periodic f c) (hc : 0 < c) (x a : Î±) : âˆƒ (y : Î±) (H : y âˆˆ set.Ico a (a + c)), f x = f y
theorem affine_equiv.affine_independent_set_of_eq_iff {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {Vâ‚‚ : Type u_5} {Pâ‚‚ : Type u_6} [add_comm_group Vâ‚‚] [module k Vâ‚‚] [add_torsor Vâ‚‚ Pâ‚‚] {s : set P} (e : P â‰ƒáµƒ[k] Pâ‚‚) : affine_independent k coe â†” affine_independent k coe
theorem algebraic_topology.alternating_face_map_complex.d_squared {C : Type u_1} [category_theory.category C] [category_theory.preadditive C] (X : category_theory.simplicial_object C) (n : â„•) : algebraic_topology.alternating_face_map_complex.obj_d X (n + 1) â‰« algebraic_topology.alternating_face_map_complex.obj_d X n = 0
theorem orthogonal_projection_eq_self_iff {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {K : submodule ğ•œ E} [complete_space â†¥K] {v : E} : â†‘(â‡‘(orthogonal_projection K) v) = v â†” v âˆˆ K
theorem measure_theory.mem_â„’p.snorm_indicator_le' {Î± : Type u_1} {Î² : Type u_2} {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) [normed_group Î²] {p : ennreal} {f : Î± â†’ Î²} (hp_one : 1 â‰¤ p) (hp_top : p â‰  âŠ¤) (hf : measure_theory.mem_â„’p f p Î¼) (hmeas : measure_theory.strongly_measurable f) {Îµ : â„} (hÎµ : 0 < Îµ) : âˆƒ (Î´ : â„) (hÎ´ : 0 < Î´), âˆ€ (s : set Î±), measurable_set s â†’ â‡‘Î¼ s â‰¤ ennreal.of_real Î´ â†’ measure_theory.snorm (s.indicator f) p Î¼ â‰¤ 2 * ennreal.of_real Îµ
theorem normed_group.tendsto_at_top' {Î± : Type u_1} [nonempty Î±] [semilattice_sup Î±] [no_max_order Î±] {Î² : Type u_2} [semi_normed_group Î²] {f : Î± â†’ Î²} {b : Î²} : filter.tendsto f filter.at_top (nhds b) â†” âˆ€ (Îµ : â„), 0 < Îµ â†’ (âˆƒ (N : Î±), âˆ€ (n : Î±), N < n â†’ âˆ¥f n - bâˆ¥ < Îµ)
theorem asymptotics.is_O.of_norm_right {Î± : Type u_1} {E : Type u_3} {F' : Type u_7} [has_norm E] [semi_normed_group F'] {f : Î± â†’ E} {g' : Î± â†’ F'} {l : filter Î±} : (f =O[l] Î» (x : Î±), âˆ¥g' xâˆ¥) â†’ f =O[l] g'
theorem category_theory.simple_of_cosimple {C : Type u} [category_theory.category C] [category_theory.abelian C] (X : C) (h : âˆ€ {Z : C} (f : X âŸ¶ Z) [_inst_3 : category_theory.epi f], category_theory.is_iso f â†” f â‰  0) : category_theory.simple X
theorem class_group.norm_lt {R : Type u_1} {S : Type u_2} [euclidean_domain R] [comm_ring S] [is_domain S] [algebra R S] (abv : absolute_value R â„¤) {Î¹ : Type u_5} [decidable_eq Î¹] [fintype Î¹] (bS : basis Î¹ R S) {T : Type u_3} [linear_ordered_ring T] (a : S) {y : T} (hy : âˆ€ (k : Î¹), â†‘(â‡‘abv (â‡‘(â‡‘(bS.repr) a) k)) < y) : â†‘(â‡‘abv (â‡‘(algebra.norm R) a)) < â†‘(class_group.norm_bound abv bS) * y ^ fintype.card Î¹
theorem finset.sum_centroid_weights_indicator_eq_one_of_card_eq_add_one (k : Type u_1) [division_ring k] {Î¹ : Type u_4} (s : finset Î¹) [char_zero k] [fintype Î¹] {n : â„•} (h : s.card = n + 1) : finset.univ.sum (Î» (i : Î¹), finset.centroid_weights_indicator k s i) = 1
theorem is_add_submonoid.inter {M : Type u_1} [add_monoid M] {sâ‚ sâ‚‚ : set M} (isâ‚ : is_add_submonoid sâ‚) (isâ‚‚ : is_add_submonoid sâ‚‚) : is_add_submonoid (sâ‚ âˆ© sâ‚‚)
theorem con.ext'_iff {M : Type u_1} [has_mul M] {c d : con M} : setoid.r = setoid.r â†” c = d
theorem monoid_algebra.map_domain_mul {Î± : Type u_1} {Î² : Type u_2} {Î±â‚‚ : Type u_3} [semiring Î²] [has_mul Î±] [has_mul Î±â‚‚] {F : Type u_4} [mul_hom_class F Î± Î±â‚‚] (f : F) (x y : monoid_algebra Î² Î±) : finsupp.map_domain â‡‘f (x * y) = finsupp.map_domain â‡‘f x * finsupp.map_domain â‡‘f y
theorem dual_number.alg_hom_ext {R : Type u_1} {A : Type u_2} [comm_semiring R] [semiring A] [algebra R A] â¦ƒf g : dual_number R â†’â‚[R] Aâ¦„ (h : â‡‘f dual_number.eps = â‡‘g dual_number.eps) : f = g
theorem same_ray_neg_iff {R : Type u_1} [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {x y : M} : same_ray R (-x) (-y) â†” same_ray R x y
theorem category_theory.is_filtered.of_equivalence {C : Type u} [category_theory.category C] [category_theory.is_filtered C] {D : Type uâ‚} [category_theory.category D] (h : C â‰Œ D) : category_theory.is_filtered D
theorem polynomial.gal.gal_action_hom_bijective_of_prime_degree' {p : polynomial â„š} (p_irr : irreducible p) (p_deg : nat.prime p.nat_degree) (p_roots1 : fintype.card â†¥(p.root_set â„) + 1 â‰¤ fintype.card â†¥(p.root_set â„‚)) (p_roots2 : fintype.card â†¥(p.root_set â„‚) â‰¤ fintype.card â†¥(p.root_set â„) + 3) : function.bijective â‡‘(polynomial.gal.gal_action_hom p â„‚)
theorem measure_theory.measure.weakly_regular.restrict_of_measurable_set {Î± : Type u_1} [measurable_space Î±] [topological_space Î±] {Î¼ : measure_theory.measure Î±} [borel_space Î±] [Î¼.weakly_regular] (A : set Î±) (hA : measurable_set A) (h'A : â‡‘Î¼ A â‰  âŠ¤) : (Î¼.restrict A).weakly_regular
theorem add_subgroup.cyclic_of_min {G : Type u_1} [linear_ordered_add_comm_group G] [archimedean G] {H : add_subgroup G} {a : G} (ha : is_least {g : G | g âˆˆ H âˆ§ 0 < g} a) : H = add_subgroup.closure {a}
theorem left.add_neg {Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b : Î±} (ha : a < 0) (hb : b < 0) : a + b < 0
theorem norm_mk_lt {M : Type u_1} [semi_normed_group M] {S : add_subgroup M} (x : M â§¸ S) {Îµ : â„} (hÎµ : 0 < Îµ) : âˆƒ (m : M), â‡‘(quotient_add_group.mk' S) m = x âˆ§ âˆ¥mâˆ¥ < âˆ¥xâˆ¥ + Îµ
theorem liouville.liouville_number_rat_initial_terms {m : â„•} (hm : 0 < m) (k : â„•) : âˆƒ (p : â„•), liouville.liouville_number_initial_terms â†‘m k = â†‘p / â†‘m ^ k.factorial
theorem continuous_on.integrable_on_compact {X : Type u_1} {E : Type u_3} [measurable_space X] [topological_space X] [normed_group E] {f : X â†’ E} {Î¼ : measure_theory.measure X} [opens_measurable_space X] [topological_space.metrizable_space X] [measure_theory.is_locally_finite_measure Î¼] {K : set X} (hK : is_compact K) (hf : continuous_on f K) : measure_theory.integrable_on f K Î¼
theorem is_bot.of_dual {Î± : Type u_1} [has_le Î±] {a : Î±áµ’áµˆ} : is_bot a â†’ is_top (â‡‘order_dual.of_dual a)
theorem ext_chart_preimage_mem_nhds_within' {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] (I : model_with_corners ğ•œ E H) {M : Type u_4} [topological_space M] [charted_space H M] (x : M) {s t : set M} {x' : M} (h : x' âˆˆ (ext_chart_at I x).source) (ht : t âˆˆ nhds_within x' s) : â‡‘((ext_chart_at I x).symm) â»Â¹' t âˆˆ nhds_within (â‡‘(ext_chart_at I x) x') (â‡‘((ext_chart_at I x).symm) â»Â¹' s âˆ© set.range â‡‘I)
theorem category_theory.limits.trident.is_limit.hom_iso_natural {J : Type v} {C : Type u} [category_theory.category C] {X Y : C} {f : J â†’ (X âŸ¶ Y)} [nonempty J] {t : category_theory.limits.trident f} (ht : category_theory.limits.is_limit t) {Z Z' : C} (q : Z' âŸ¶ Z) (k : Z âŸ¶ t.X) : â†‘(â‡‘(category_theory.limits.trident.is_limit.hom_iso ht Z') (q â‰« k)) = q â‰« â†‘(â‡‘(category_theory.limits.trident.is_limit.hom_iso ht Z) k)
theorem monotone.pairwise_disjoint_on_Ico_pred {Î± : Type u_1} {Î² : Type u_2} [linear_order Î±] [pred_order Î±] [preorder Î²] {f : Î± â†’ Î²} (hf : monotone f) : pairwise (disjoint on Î» (n : Î±), set.Ico (f (order.pred n)) (f n))
theorem ring_hom.map_multiset_prod {Î² : Type u} {Î³ : Type w} [comm_semiring Î²] [comm_semiring Î³] (f : Î² â†’+* Î³) (s : multiset Î²) : â‡‘f s.prod = (multiset.map â‡‘f s).prod
theorem power_series.order_zero {R : Type u_1} [semiring R] : 0.order = âŠ¤
theorem tangent_bundle.tangent_map_tangent_bundle_pure {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {M : Type u_4} [topological_space M] [charted_space H M] [Is : smooth_manifold_with_corners I M] (p : tangent_bundle I M) : tangent_map I I.tangent (tangent_bundle.zero_section I M) p = âŸ¨âŸ¨p.fst, 0âŸ©, (p.snd, 0)âŸ©
theorem is_of_fin_order.apply {Î· : Type u_1} {Gs : Î· â†’ Type u_2} [Î  (i : Î·), monoid (Gs i)] {x : Î  (i : Î·), Gs i} (h : is_of_fin_order x) (i : Î·) : is_of_fin_order (x i)
theorem filter.tendsto.at_bot_div_const {Î± : Type u_3} {Î² : Type u_4} [linear_ordered_field Î±] {l : filter Î²} {f : Î² â†’ Î±} {r : Î±} (hr : 0 < r) (hf : filter.tendsto f l filter.at_bot) : filter.tendsto (Î» (x : Î²), f x / r) l filter.at_bot
theorem is_add_monoid_hom.map_add {Î± : Type u} {Î² : Type v} [add_zero_class Î±] [add_zero_class Î²] {f : Î± â†’ Î²} (hf : is_add_monoid_hom f) (x y : Î±) : f (x + y) = f x + f y
theorem add_monoid_hom.map_closure {G : Type u_1} [add_group G] {N : Type u_3} [add_group N] (f : G â†’+ N) (s : set G) : add_subgroup.map f (add_subgroup.closure s) = add_subgroup.closure (â‡‘f '' s)
theorem norm_add_sq_real {F : Type u_3} [inner_product_space â„ F] {x y : F} : âˆ¥x + yâˆ¥ ^ 2 = âˆ¥xâˆ¥ ^ 2 + 2 * has_inner.inner x y + âˆ¥yâˆ¥ ^ 2
theorem convex.add_smul_sub_mem_interior {E : Type u_2} {ğ•œ : Type u_3} [linear_ordered_field ğ•œ] [add_comm_group E] [module ğ•œ E] [topological_space E] [topological_add_group E] [has_continuous_const_smul ğ•œ E] {s : set E} (hs : convex ğ•œ s) {x y : E} (hx : x âˆˆ s) (hy : y âˆˆ interior s) {t : ğ•œ} (ht : t âˆˆ set.Ioc 0 1) : x + t â€¢ (y - x) âˆˆ interior s
theorem cont_diff_at_ring_inverse (ğ•œ : Type u_1) [nondiscrete_normed_field ğ•œ] {n : with_top â„•} {R : Type u_6} [normed_ring R] [normed_algebra ğ•œ R] [complete_space R] (x : RË£) : cont_diff_at ğ•œ n ring.inverse â†‘x
theorem localization.at_prime.map_eq_maximal_ideal {R : Type u_1} [comm_semiring R] {I : ideal R} [hI : I.is_prime] : ideal.map (algebra_map R (localization.at_prime I)) I = local_ring.maximal_ideal (localization I.prime_compl)
theorem subfield.inv_mem {K : Type u} [field K] (s : subfield K) {x : K} : x âˆˆ s â†’ xâ»Â¹ âˆˆ s
theorem measure_theory.lintegral_mul_left_eq_self {G : Type u_4} [measurable_space G] {Î¼ : measure_theory.measure G} [group G] [has_measurable_mul G] [Î¼.is_mul_left_invariant] (f : G â†’ ennreal) (g : G) : âˆ«â» (x : G), f (g * x) âˆ‚Î¼ = âˆ«â» (x : G), f x âˆ‚Î¼
theorem polynomial.is_coprime_of_is_root_of_eval_derivative_ne_zero {K : Type u_1} [field K] (f : polynomial K) (a : K) (hf' : polynomial.eval a (â‡‘polynomial.derivative f) â‰  0) : is_coprime (polynomial.X - â‡‘polynomial.C a) (f /â‚˜ (polynomial.X - â‡‘polynomial.C a))
theorem Top.presheaf.is_sheaf_iff_is_sheaf_unique_gluing {C : Type u} [category_theory.category C] [category_theory.concrete_category C] [category_theory.limits.has_limits C] [category_theory.reflects_isomorphisms (category_theory.forget C)] [category_theory.limits.preserves_limits (category_theory.forget C)] {X : Top} (F : Top.presheaf C X) : F.is_sheaf â†” F.is_sheaf_unique_gluing
theorem same_ray.pos_smul_right {R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {x y : M} {r : R} (h : same_ray R x y) (hr : 0 < r) : same_ray R x (r â€¢ y)
theorem continuous_on.is_separable_image {Î± : Type u} {Î² : Type v} [pseudo_metric_space Î±] [topological_space Î²] {f : Î± â†’ Î²} {s : set Î±} (hf : continuous_on f s) (hs : topological_space.is_separable s) : topological_space.is_separable (f '' s)
theorem inner_product_space.is_self_adjoint.restrict_invariant {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {T : E â†’â‚—[ğ•œ] E} (hT : inner_product_space.is_self_adjoint T) {V : submodule ğ•œ E} (hV : âˆ€ (v : E), v âˆˆ V â†’ â‡‘T v âˆˆ V) : inner_product_space.is_self_adjoint (T.restrict hV)
theorem topological_space.is_topological_basis.mem_nhds_iff {Î± : Type u} [t : topological_space Î±] {a : Î±} {s : set Î±} {b : set (set Î±)} (hb : topological_space.is_topological_basis b) : s âˆˆ nhds a â†” âˆƒ (t : set Î±) (H : t âˆˆ b), a âˆˆ t âˆ§ t âŠ† s
theorem simplex_category.Î´_comp_Ïƒ_succ {n : â„•} {i : fin (n + 1)} : simplex_category.Î´ i.succ â‰« simplex_category.Ïƒ i = ğŸ™ (simplex_category.mk n)
theorem upper_central_series_step_eq_comap_center {G : Type u_1} [group G] (H : subgroup G) [H.normal] : upper_central_series_step H = subgroup.comap (quotient_group.mk' H) (subgroup.center (G â§¸ H))
theorem collinear_iff_finrank_le_one (k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P) [finite_dimensional k â†¥(vector_span k s)] : collinear k s â†” finite_dimensional.finrank k â†¥(vector_span k s) â‰¤ 1
theorem pow_two_pos_of_ne_zero {R : Type u_4} [linear_ordered_ring R] (a : R) (h : a â‰  0) : 0 < a ^ 2
theorem vector.to_list_reverse {n : â„•} {Î± : Type u_1} {v : vector Î± n} : v.reverse.to_list = v.to_list.reverse
theorem linear_map.bijective_or_eq_zero {R : Type u_1} [ring R] {M : Type u_2} [add_comm_group M] [module R M] {N : Type u_3} [add_comm_group N] [module R N] [is_simple_module R M] [is_simple_module R N] (f : M â†’â‚—[R] N) : function.bijective â‡‘f âˆ¨ f = 0
theorem tendsto_self_mul_const_pow_of_lt_one {r : â„} (hr : 0 â‰¤ r) (h'r : r < 1) : filter.tendsto (Î» (n : â„•), â†‘n * r ^ n) filter.at_top (nhds 0)
theorem algebra.discr_mul_is_integral_mem_adjoin (K : Type u) {L : Type v} [field K] [field L] [algebra K L] [module.finite K L] {R : Type z} [comm_ring R] [algebra R K] [algebra R L] [is_scalar_tower R K L] [is_domain R] [is_separable K L] [is_integrally_closed R] [is_fraction_ring R K] {B : power_basis K L} (hint : is_integral R B.gen) {z : L} (hz : is_integral R z) : algebra.discr K â‡‘(B.basis) â€¢ z âˆˆ algebra.adjoin R {B.gen}
theorem metric.sigma.complete_space {Î¹ : Type u_1} {E : Î¹ â†’ Type u_2} [Î  (i : Î¹), metric_space (E i)] [âˆ€ (i : Î¹), complete_space (E i)] : complete_space (Î£ (i : Î¹), E i)
theorem injective_iff_map_eq_one {F : Type u_8} {G : Type u_1} {H : Type u_2} [group G] [mul_one_class H] [monoid_hom_class F G H] (f : F) : function.injective â‡‘f â†” âˆ€ (a : G), â‡‘f a = 1 â†’ a = 1
theorem asymptotics.is_o_of_tendsto {Î± : Type u_1} {ğ•œ : Type u_14} [normed_field ğ•œ] {l : filter Î±} {f g : Î± â†’ ğ•œ} (hgf : âˆ€ (x : Î±), g x = 0 â†’ f x = 0) : filter.tendsto (Î» (x : Î±), f x / g x) l (nhds 0) â†’ f =o[l] g
theorem phragmen_lindelof.eq_zero_on_quadrant_IV {E : Type u_1} [normed_group E] [normed_space â„‚ E] {f : â„‚ â†’ E} (hd : diff_cont_on_cl â„‚ f (set.Ioi 0 Ã—â„‚ set.Iio 0)) (hB : âˆƒ (c : â„) (H : c < 2) (B : â„), f =O[filter.comap complex.abs filter.at_top âŠ“ filter.principal (set.Ioi 0 Ã—â„‚ set.Iio 0)] Î» (z : â„‚), real.exp (B * complex.abs z ^ c)) (hre : âˆ€ (x : â„), 0 â‰¤ x â†’ f â†‘x = 0) (him : âˆ€ (x : â„), x â‰¤ 0 â†’ f (â†‘x * complex.I) = 0) : set.eq_on f 0 {z : â„‚ | 0 â‰¤ z.re âˆ§ z.im â‰¤ 0}
theorem joined_in.joined_subtype {X : Type u_1} [topological_space X] {x y : X} {F : set X} (h : joined_in F x y) : joined âŸ¨x, _âŸ© âŸ¨y, _âŸ©
theorem measure_theory.signed_measure.exists_is_compl_positive_negative {Î± : Type u_1} [measurable_space Î±] (s : measure_theory.signed_measure Î±) : âˆƒ (i j : set Î±), measurable_set i âˆ§ 0.restrict i â‰¤ measure_theory.vector_measure.restrict s i âˆ§ measurable_set j âˆ§ measure_theory.vector_measure.restrict s j â‰¤ 0.restrict j âˆ§ is_compl i j
theorem measurable.comap_le {Î± : Type u_1} {Î² : Type u_2} {mâ‚ : measurable_space Î±} {mâ‚‚ : measurable_space Î²} {f : Î± â†’ Î²} : measurable f â†’ measurable_space.comap f mâ‚‚ â‰¤ mâ‚
theorem emetric.cauchy_seq_iff_nnreal {Î± : Type u} {Î² : Type v} [pseudo_emetric_space Î±] [nonempty Î²] [semilattice_sup Î²] {u : Î² â†’ Î±} : cauchy_seq u â†” âˆ€ (Îµ : nnreal), 0 < Îµ â†’ (âˆƒ (N : Î²), âˆ€ (n : Î²), N â‰¤ n â†’ has_edist.edist (u n) (u N) < â†‘Îµ)
theorem ideal.quotient.mkâ‚_ker (Râ‚ : Type u_3) {A : Type u_5} [comm_semiring Râ‚] [comm_ring A] [algebra Râ‚ A] (I : ideal A) : â†‘(ideal.quotient.mkâ‚ Râ‚ I).ker = I
theorem analytic_on.fderiv {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {f : E â†’ F} {s : set E} [complete_space F] (h : analytic_on ğ•œ f s) : analytic_on ğ•œ (fderiv ğ•œ f) s
theorem affine_independent_iff_finrank_vector_span_eq (k : Type u_1) {V : Type u_2} {P : Type u_3} {Î¹ : Type u_4} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] [fintype Î¹] (p : Î¹ â†’ P) {n : â„•} (hc : fintype.card Î¹ = n + 1) : affine_independent k p â†” finite_dimensional.finrank k â†¥(vector_span k (set.range p)) = n
theorem le_sub_left_of_add_le {Î± : Type u} [add_comm_group Î±] [has_le Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b c : Î±} : a + b â‰¤ c â†’ b â‰¤ c - a
theorem subring.subset_closure {R : Type u} [ring R] {s : set R} : s âŠ† â†‘(subring.closure s)
theorem phragmen_lindelof.eq_on_quadrant_I {E : Type u_1} [normed_group E] [normed_space â„‚ E] {f g : â„‚ â†’ E} (hdf : diff_cont_on_cl â„‚ f (set.Ioi 0 Ã—â„‚ set.Ioi 0)) (hBf : âˆƒ (c : â„) (H : c < 2) (B : â„), f =O[filter.comap complex.abs filter.at_top âŠ“ filter.principal (set.Ioi 0 Ã—â„‚ set.Ioi 0)] Î» (z : â„‚), real.exp (B * complex.abs z ^ c)) (hdg : diff_cont_on_cl â„‚ g (set.Ioi 0 Ã—â„‚ set.Ioi 0)) (hBg : âˆƒ (c : â„) (H : c < 2) (B : â„), g =O[filter.comap complex.abs filter.at_top âŠ“ filter.principal (set.Ioi 0 Ã—â„‚ set.Ioi 0)] Î» (z : â„‚), real.exp (B * complex.abs z ^ c)) (hre : âˆ€ (x : â„), 0 â‰¤ x â†’ f â†‘x = g â†‘x) (him : âˆ€ (x : â„), 0 â‰¤ x â†’ f (â†‘x * complex.I) = g (â†‘x * complex.I)) : set.eq_on f g {z : â„‚ | 0 â‰¤ z.re âˆ§ 0 â‰¤ z.im}
theorem vector_span_eq_span_vsub_set_right (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : set P} {p : P} (hp : p âˆˆ s) : vector_span k s = submodule.span k ((Î» (_x : P), _x -áµ¥ p) '' s)
theorem generalized_continued_fraction.exists_int_eq_of_part_denom {K : Type u_1} {v : K} {n : â„•} [linear_ordered_field K] [floor_ring K] {b : K} (nth_part_denom_eq : (generalized_continued_fraction.of v).partial_denominators.nth n = option.some b) : âˆƒ (z : â„¤), b = â†‘z
theorem vitali_family.ae_tendsto_rn_deriv_of_absolutely_continuous {Î± : Type u_1} [metric_space Î±] {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (v : vitali_family Î¼) [sigma_compact_space Î±] [borel_space Î±] [measure_theory.is_locally_finite_measure Î¼] {Ï : measure_theory.measure Î±} [measure_theory.is_locally_finite_measure Ï] (hÏ : Ï.absolutely_continuous Î¼) : âˆ€áµ (x : Î±) âˆ‚Î¼, filter.tendsto (Î» (a : set Î±), â‡‘Ï a / â‡‘Î¼ a) (v.filter_at x) (nhds (Ï.rn_deriv Î¼ x))
theorem polynomial.chebyshev.mul_T (R : Type u_1) [comm_ring R] (m k : â„•) : 2 * polynomial.chebyshev.T R m * polynomial.chebyshev.T R (m + k) = polynomial.chebyshev.T R (2 * m + k) + polynomial.chebyshev.T R k
theorem vitali_family.measure_le_of_frequently_le {Î± : Type u_1} [metric_space Î±] {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (v : vitali_family Î¼) [sigma_compact_space Î±] [borel_space Î±] {Ï : measure_theory.measure Î±} (Î½ : measure_theory.measure Î±) [measure_theory.is_locally_finite_measure Î½] (hÏ : Ï.absolutely_continuous Î¼) (s : set Î±) (hs : âˆ€ (x : Î±), x âˆˆ s â†’ (âˆƒá¶  (a : set Î±) in v.filter_at x, â‡‘Ï a â‰¤ â‡‘Î½ a)) : â‡‘Ï s â‰¤ â‡‘Î½ s
theorem algebraic_topology.dold_kan.map_HÏƒ {C : Type u_1} [category_theory.category C] [category_theory.preadditive C] {D : Type u_3} [category_theory.category D] [category_theory.preadditive D] (G : C â¥¤ D) [G.additive] (X : category_theory.simplicial_object C) (q n : â„•) : (algebraic_topology.dold_kan.HÏƒ q).f n = G.map ((algebraic_topology.dold_kan.HÏƒ q).f n)
theorem category_theory.limits.pullback.hom_ext {C : Type u} [category_theory.category C] {X Y Z : C} {f : X âŸ¶ Z} {g : Y âŸ¶ Z} [category_theory.limits.has_pullback f g] {W : C} {k l : W âŸ¶ category_theory.limits.pullback f g} (hâ‚€ : k â‰« category_theory.limits.pullback.fst = l â‰« category_theory.limits.pullback.fst) (hâ‚ : k â‰« category_theory.limits.pullback.snd = l â‰« category_theory.limits.pullback.snd) : k = l
theorem category_theory.is_cofiltered.of_left_adjoint {C : Type u} [category_theory.category C] [category_theory.is_cofiltered C] {D : Type uâ‚} [category_theory.category D] {L : C â¥¤ D} {R : D â¥¤ C} (h : L âŠ£ R) : category_theory.is_cofiltered D
theorem con.lift_unique {M : Type u_1} {P : Type u_3} [mul_one_class M] [mul_one_class P] {c : con M} {f : M â†’* P} (H : c â‰¤ con.ker f) (g : c.quotient â†’* P) (Hg : g.comp c.mk' = f) : g = c.lift f H
theorem mem_upper_central_series_succ_iff (G : Type u_1) [group G] (n : â„•) (x : G) : x âˆˆ upper_central_series G (n + 1) â†” âˆ€ (y : G), x * y * xâ»Â¹ * yâ»Â¹ âˆˆ upper_central_series G n
theorem zmod.legendre_sym_mul (p : â„•) [fact (nat.prime p)] (a b : â„¤) : zmod.legendre_sym p (a * b) = zmod.legendre_sym p a * zmod.legendre_sym p b
theorem bilin_form.is_compl_span_singleton_orthogonal {V : Type u_9} {K : Type u_10} [field K] [add_comm_group V] [module K V] {B : bilin_form K V} {x : V} (hx : Â¬B.is_ortho x x) : is_compl (submodule.span K {x}) (B.orthogonal (submodule.span K {x}))
theorem is_right_regular.mul {R : Type u_1} {a b : R} [semigroup R] (rra : is_right_regular a) (rrb : is_right_regular b) : is_right_regular (a * b)
theorem exists_countable_dense_no_bot_top (Î± : Type u) [topological_space Î±] [linear_order Î±] [order_topology Î±] [densely_ordered Î±] [topological_space.separable_space Î±] [nontrivial Î±] : âˆƒ (s : set Î±), s.countable âˆ§ dense s âˆ§ (âˆ€ (x : Î±), is_bot x â†’ x âˆ‰ s) âˆ§ âˆ€ (x : Î±), is_top x â†’ x âˆ‰ s
theorem module.End.exp_ne_zero_of_has_generalized_eigenvalue {R : Type v} {M : Type w} [comm_ring R] [add_comm_group M] [module R M] {f : module.End R M} {Î¼ : R} {k : â„•} (h : f.has_generalized_eigenvalue Î¼ k) : k â‰  0
theorem mul_sub_le_image_sub_of_le_deriv {f : â„ â†’ â„} (hf : differentiable â„ f) {C : â„} (hf'_ge : âˆ€ (x : â„), C â‰¤ deriv f x) â¦ƒx y : â„â¦„ (hxy : x â‰¤ y) : C * (y - x) â‰¤ f y - f x
theorem category_theory.subobject.eq_mk_of_comm {C : Type uâ‚} [category_theory.category C] {B A : C} {X : category_theory.subobject B} (f : A âŸ¶ B) [category_theory.mono f] (i : â†‘X â‰… A) (w : i.hom â‰« f = X.arrow) : X = category_theory.subobject.mk f
theorem category_theory.limits.has_colimit_of_has_limit_left_op {C : Type uâ‚} [category_theory.category C] {J : Type uâ‚‚} [category_theory.category J] (F : J â¥¤ Cáµ’áµ–) [category_theory.limits.has_limit F.left_op] : category_theory.limits.has_colimit F
theorem matrix.det_mul_row {n : Type u_2} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] (v : n â†’ R) (A : matrix n n R) : matrix.det (Î» (i j : n), v j * A i j) = finset.univ.prod (Î» (i : n), v i) * A.det
theorem besicovitch.exists_good_Î´ (E : Type u_1) [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] : âˆƒ (Î´ : â„), 0 < Î´ âˆ§ Î´ < 1 âˆ§ âˆ€ (s : finset E), (âˆ€ (c : E), c âˆˆ s â†’ âˆ¥câˆ¥ â‰¤ 2) â†’ (âˆ€ (c : E), c âˆˆ s â†’ âˆ€ (d : E), d âˆˆ s â†’ c â‰  d â†’ 1 - Î´ â‰¤ âˆ¥c - dâˆ¥) â†’ s.card â‰¤ besicovitch.multiplicity E
theorem nat.prime_pow_prime_divisor {p k : â„•} (hk : k â‰  0) (hp : nat.prime p) : (p ^ k).factors.to_finset = {p}
theorem emetric.edist_le_diam_of_mem {Î± : Type u} [pseudo_emetric_space Î±] {x y : Î±} {s : set Î±} (hx : x âˆˆ s) (hy : y âˆˆ s) : has_edist.edist x y â‰¤ emetric.diam s
theorem category_theory.is_pullback.of_right {C : Type uâ‚} [category_theory.category C] {Xâ‚â‚ Xâ‚â‚‚ Xâ‚â‚ƒ Xâ‚‚â‚ Xâ‚‚â‚‚ Xâ‚‚â‚ƒ : C} {hâ‚â‚ : Xâ‚â‚ âŸ¶ Xâ‚â‚‚} {hâ‚â‚‚ : Xâ‚â‚‚ âŸ¶ Xâ‚â‚ƒ} {hâ‚‚â‚ : Xâ‚‚â‚ âŸ¶ Xâ‚‚â‚‚} {hâ‚‚â‚‚ : Xâ‚‚â‚‚ âŸ¶ Xâ‚‚â‚ƒ} {vâ‚â‚ : Xâ‚â‚ âŸ¶ Xâ‚‚â‚} {vâ‚â‚‚ : Xâ‚â‚‚ âŸ¶ Xâ‚‚â‚‚} {vâ‚â‚ƒ : Xâ‚â‚ƒ âŸ¶ Xâ‚‚â‚ƒ} (s : category_theory.is_pullback (hâ‚â‚ â‰« hâ‚â‚‚) vâ‚â‚ vâ‚â‚ƒ (hâ‚‚â‚ â‰« hâ‚‚â‚‚)) (p : hâ‚â‚ â‰« vâ‚â‚‚ = vâ‚â‚ â‰« hâ‚‚â‚) (t : category_theory.is_pullback hâ‚â‚‚ vâ‚â‚‚ vâ‚â‚ƒ hâ‚‚â‚‚) : category_theory.is_pullback hâ‚â‚ vâ‚â‚ vâ‚â‚‚ hâ‚‚â‚
theorem setoid.eqv_classes_disjoint {Î± : Type u_1} {c : set (set Î±)} (H : âˆ€ (a : Î±), âˆƒ! (b : set Î±) (H : b âˆˆ c), a âˆˆ b) : c.pairwise_disjoint id
theorem exp_neg_inv_glue.pos_of_pos {x : â„} (hx : 0 < x) : 0 < exp_neg_inv_glue x
theorem witt_vector.discrete_valuation_ring {p : â„•} [hp : fact (nat.prime p)] {k : Type u_1} [field k] [char_p k p] [perfect_ring k p] : discrete_valuation_ring (witt_vector p k)
theorem add_monoid_algebra.non_unital_alg_hom_ext' (k : Type uâ‚) {G : Type uâ‚‚} [semiring k] [has_add G] {A : Type uâ‚ƒ} [non_unital_non_assoc_semiring A] [distrib_mul_action k A] {Ï†â‚ Ï†â‚‚ : add_monoid_algebra k G â†’â‚™â‚[k] A} (h : Ï†â‚.to_mul_hom.comp (add_monoid_algebra.of_magma k G) = Ï†â‚‚.to_mul_hom.comp (add_monoid_algebra.of_magma k G)) : Ï†â‚ = Ï†â‚‚
theorem finset.filter_true_of_mem {Î± : Type u_1} {p : Î± â†’ Prop} [decidable_pred p] {s : finset Î±} (h : âˆ€ (x : Î±), x âˆˆ s â†’ p x) : finset.filter p s = s
theorem cardinal.aleph_0_le_mul_iff {a b : cardinal} : cardinal.aleph_0 â‰¤ a * b â†” a â‰  0 âˆ§ b â‰  0 âˆ§ (cardinal.aleph_0 â‰¤ a âˆ¨ cardinal.aleph_0 â‰¤ b)
theorem category_theory.tensor_right_hom_equiv_tensor {C : Type uâ‚} [category_theory.category C] [category_theory.monoidal_category C] {X X' Y Y' Z Z' : C} [category_theory.exact_pairing Y Y'] (f : X âŸ¶ Z âŠ— Y') (g : X' âŸ¶ Z') : â‡‘((category_theory.tensor_right_hom_equiv (X' âŠ— X) Y Y' (Z' âŠ— Z)).symm) ((g âŠ— f) â‰« (Î±_ Z' Z Y').inv) = (Î±_ X' X Y).hom â‰« (g âŠ— â‡‘((category_theory.tensor_right_hom_equiv X Y Y' Z).symm) f)
theorem measure_theory.condexp_ae_eq_restrict_of_measurable_space_eq_on {Î± : Type u_1} {F' : Type u_7} [normed_group F'] [normed_space â„ F'] [complete_space F'] {f : Î± â†’ F'} {s : set Î±} {m mâ‚‚ m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (hm : m â‰¤ m0) (hmâ‚‚ : mâ‚‚ â‰¤ m0) [measure_theory.sigma_finite (Î¼.trim hm)] [measure_theory.sigma_finite (Î¼.trim hmâ‚‚)] (hs_m : measurable_set s) (hs : âˆ€ (t : set Î±), measurable_set (s âˆ© t) â†” measurable_set (s âˆ© t)) : measure_theory.condexp m Î¼ f =áµ[Î¼.restrict s] measure_theory.condexp mâ‚‚ Î¼ f
theorem dense_Union_interior_of_closed {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [baire_space Î±] [encodable Î²] {f : Î² â†’ set Î±} (hc : âˆ€ (s : Î²), is_closed (f s)) (hU : (â‹ƒ (s : Î²), f s) = set.univ) : dense (â‹ƒ (s : Î²), interior (f s))
theorem squeeze_zero_norm {Î± : Type u_1} {E : Type u_3} [semi_normed_group E] {f : Î± â†’ E} {g : Î± â†’ â„} {tâ‚€ : filter Î±} (h : âˆ€ (n : Î±), âˆ¥f nâˆ¥ â‰¤ g n) (h' : filter.tendsto g tâ‚€ (nhds 0)) : filter.tendsto f tâ‚€ (nhds 0)
theorem nnreal.tendsto_sum_nat_add (f : â„• â†’ nnreal) : filter.tendsto (Î» (i : â„•), âˆ‘' (k : â„•), f (k + i)) filter.at_top (nhds 0)
theorem category_theory.limits.has_binary_biproduct_of_total {C : Type u} [category_theory.category C] [category_theory.preadditive C] {X Y : C} (b : category_theory.limits.binary_bicone X Y) (total : b.fst â‰« b.inl + b.snd â‰« b.inr = ğŸ™ b.X) : category_theory.limits.has_binary_biproduct X Y
theorem nhds_inter_eq_singleton_of_mem_discrete {Î± : Type u} [topological_space Î±] {s : set Î±} [discrete_topology â†¥s] {x : Î±} (hx : x âˆˆ s) : âˆƒ (U : set Î±) (H : U âˆˆ nhds x), U âˆ© s = {x}
theorem map_infi_of_continuous_at_of_monotone {Î± : Type u} {Î² : Type v} [complete_linear_order Î±] [topological_space Î±] [order_topology Î±] [complete_linear_order Î²] [topological_space Î²] [order_topology Î²] {Î¹ : Sort u_1} {f : Î± â†’ Î²} {g : Î¹ â†’ Î±} (Cf : continuous_at f (infi g)) (Mf : monotone f) (ftop : f âŠ¤ = âŠ¤) : f (infi g) = infi (f âˆ˜ g)
theorem uniform_add_group.uniform_continuous_iff_open_ker {Î± : Type u_1} {Î² : Type u_2} [uniform_space Î±] [add_group Î±] [uniform_add_group Î±] {hom : Type u_3} [uniform_space Î²] [discrete_topology Î²] [add_group Î²] [uniform_add_group Î²] [add_monoid_hom_class hom Î± Î²] {f : hom} : uniform_continuous â‡‘f â†” is_open â†‘(â†‘f.ker)
theorem is_clopen_inter_of_disjoint_cover_clopen {Î± : Type u} [topological_space Î±] {Z a b : set Î±} (h : is_clopen Z) (cover : Z âŠ† a âˆª b) (ha : is_open a) (hb : is_open b) (hab : a âˆ© b = âˆ…) : is_clopen (Z âˆ© a)
theorem finset.mem_finsupp_iff_of_support_subset {Î¹ : Type u_1} {Î± : Type u_2} [has_zero Î±] {s : finset Î¹} {f : Î¹ â†’â‚€ Î±} {t : Î¹ â†’â‚€ finset Î±} (ht : t.support âŠ† s) : f âˆˆ s.finsupp â‡‘t â†” âˆ€ (i : Î¹), â‡‘f i âˆˆ â‡‘t i
theorem Gromov_Hausdorff.isometry_optimal_GH_injr (X : Type u) (Y : Type v) [metric_space X] [compact_space X] [nonempty X] [metric_space Y] [compact_space Y] [nonempty Y] : isometry (Gromov_Hausdorff.optimal_GH_injr X Y)
theorem box_integral.has_integral_bot_divergence_of_forall_has_deriv_within_at {E : Type u} [normed_group E] [normed_space â„ E] {n : â„•} [complete_space E] (I : box_integral.box (fin (n + 1))) (f : (fin (n + 1) â†’ â„) â†’ fin (n + 1) â†’ E) (f' : (fin (n + 1) â†’ â„) â†’ ((fin (n + 1) â†’ â„) â†’L[â„] fin (n + 1) â†’ E)) (s : set (fin (n + 1) â†’ â„)) (hs : s.countable) (Hs : âˆ€ (x : fin (n + 1) â†’ â„), x âˆˆ s â†’ continuous_within_at f (â‡‘box_integral.box.Icc I) x) (Hd : âˆ€ (x : fin (n + 1) â†’ â„), x âˆˆ â‡‘box_integral.box.Icc I  s â†’ has_fderiv_within_at f (f' x) (â‡‘box_integral.box.Icc I) x) : box_integral.has_integral I âŠ¥ (Î» (x : fin (n + 1) â†’ â„), finset.univ.sum (Î» (i : fin (n + 1)), â‡‘(f' x) (pi.single i 1) i)) box_integral.box_additive_map.volume (finset.univ.sum (Î» (i : fin (n + 1)), box_integral.integral (I.face i) âŠ¥ (Î» (x : fin n â†’ â„), f (i.insert_nth (I.upper i) x) i) box_integral.box_additive_map.volume - box_integral.integral (I.face i) âŠ¥ (Î» (x : fin n â†’ â„), f (i.insert_nth (I.lower i) x) i) box_integral.box_additive_map.volume))
theorem ideal.eq_bot_or_top {K : Type u} [division_ring K] (I : ideal K) : I = âŠ¥ âˆ¨ I = âŠ¤
theorem lp.tsum_mul_le_mul_norm {Î± : Type u_1} {E : Î± â†’ Type u_2} [Î  (i : Î±), normed_group (E i)] {p q : ennreal} (hpq : p.to_real.is_conjugate_exponent q.to_real) (f : â†¥(lp E p)) (g : â†¥(lp E q)) : summable (Î» (i : Î±), âˆ¥â‡‘f iâˆ¥ * âˆ¥â‡‘g iâˆ¥) âˆ§ âˆ‘' (i : Î±), âˆ¥â‡‘f iâˆ¥ * âˆ¥â‡‘g iâˆ¥ â‰¤ âˆ¥fâˆ¥ * âˆ¥gâˆ¥
theorem is_add_left_regular_of_left_cancel_add_semigroup {R : Type u_1} [add_left_cancel_semigroup R] (g : R) : is_add_left_regular g
theorem strict_convex_space.of_norm_add {E : Type u_2} [normed_group E] [normed_space â„ E] (h : âˆ€ (x y : E), âˆ¥x + yâˆ¥ = âˆ¥xâˆ¥ + âˆ¥yâˆ¥ â†’ same_ray â„ x y) : strict_convex_space â„ E
theorem measure_theory.measure.add_haar_preimage_linear_map {E : Type u_1} [normed_group E] [normed_space â„ E] [measurable_space E] [borel_space E] [finite_dimensional â„ E] (Î¼ : measure_theory.measure E) [Î¼.is_add_haar_measure] {f : E â†’â‚—[â„] E} (hf : â‡‘linear_map.det f â‰  0) (s : set E) : â‡‘Î¼ (â‡‘f â»Â¹' s) = ennreal.of_real |(â‡‘linear_map.det f)â»Â¹| * â‡‘Î¼ s
theorem complex.partial_Gamma_add_one {s : â„‚} (hs : 0 < s.re) {X : â„} (hX : 0 â‰¤ X) : (s + 1).partial_Gamma X = s * s.partial_Gamma X - â†‘(real.exp (-X)) * â†‘X ^ s
theorem has_fpower_series_on_ball.comp_sub {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field ğ•œ] [normed_group E] [normed_space ğ•œ E] [normed_group F] [normed_space ğ•œ F] {f : E â†’ F} {p : formal_multilinear_series ğ•œ E F} {x : E} {r : ennreal} (hf : has_fpower_series_on_ball f p x r) (y : E) : has_fpower_series_on_ball (Î» (z : E), f (z - y)) p (x + y) r
theorem add_tsub_assoc_of_le {Î± : Type u_1} [canonically_ordered_add_monoid Î±] [has_sub Î±] [has_ordered_sub Î±] {b c : Î±} [contravariant_class Î± Î± has_add.add has_le.le] (h : c â‰¤ b) (a : Î±) : a + b - c = a + (b - c)
theorem exp_neg_inv_glue.f_aux_deriv_pos (n : â„•) (x : â„) (hx : 0 < x) : has_deriv_at (exp_neg_inv_glue.f_aux n) (polynomial.eval x (exp_neg_inv_glue.P_aux (n + 1)) * real.exp (-xâ»Â¹) / x ^ (2 * (n + 1))) x
theorem category_theory.functor.empty_ext' {C : Type u} [category_theory.category C] (F G : category_theory.discrete pempty â¥¤ C) : F = G
theorem measure_theory.integrable_on.has_box_integral {Î¹ : Type u} {E : Type v} [fintype Î¹] [normed_group E] [normed_space â„ E] [complete_space E] {f : (Î¹ â†’ â„) â†’ E} {Î¼ : measure_theory.measure (Î¹ â†’ â„)} [measure_theory.is_locally_finite_measure Î¼] {I : box_integral.box Î¹} (hf : measure_theory.integrable_on f â†‘I Î¼) (l : box_integral.integration_params) (hl : l.bRiemann = bool.ff) : box_integral.has_integral I l f Î¼.to_box_additive.to_smul (âˆ« (x : Î¹ â†’ â„) in â†‘I, f x âˆ‚Î¼)
theorem measure_theory.pdf.quasi_measure_preserving_has_pdf {Î± : Type u_1} {E : Type u_2} [measurable_space E] {m : measurable_space Î±} {â„™ : measure_theory.measure Î±} {Î¼ : measure_theory.measure E} {F : Type u_3} [measurable_space F] {Î½ : measure_theory.measure F} {X : Î± â†’ E} [measure_theory.has_pdf X Â«â„™Â» Î¼] {g : E â†’ F} (hg : measure_theory.measure.quasi_measure_preserving g Î¼ Î½) (hmap : (measure_theory.measure.map g (measure_theory.measure.map X Â«â„™Â»)).have_lebesgue_decomposition Î½) : measure_theory.has_pdf (g âˆ˜ X) Â«â„™Â» Î½
theorem clifford_algebra.submodule_map_mul_reverse {R : Type u_1} [comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] (Q : quadratic_form R M) (p q : submodule R (clifford_algebra Q)) : submodule.map clifford_algebra.reverse (p * q) = submodule.map clifford_algebra.reverse q * submodule.map clifford_algebra.reverse p
theorem std_simplex_subset_closed_ball {Î¹ : Type u_1} [fintype Î¹] : std_simplex â„ Î¹ âŠ† metric.closed_ball 0 1
theorem reflection_bot {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] : reflection âŠ¥ = linear_isometry_equiv.neg ğ•œ
theorem gauge_def' {E : Type u_1} [add_comm_group E] [module â„ E] {s : set E} {x : E} : gauge s x = has_Inf.Inf {r âˆˆ set.Ioi 0 | râ»Â¹ â€¢ x âˆˆ s}
theorem derivation.ext_of_adjoin_eq_top {R : Type u_1} [comm_semiring R] {A : Type u_2} [comm_semiring A] [algebra R A] {M : Type u_3} [add_comm_monoid M] [module A M] [module R M] {D1 D2 : derivation R A M} (s : set A) (hs : algebra.adjoin R s = âŠ¤) (h : set.eq_on â‡‘D1 â‡‘D2 s) : D1 = D2
theorem measure_theory.measure.hausdorff_measure_apply {X : Type u_2} [emetric_space X] [measurable_space X] [borel_space X] (d : â„) (s : set X) : â‡‘(measure_theory.measure.hausdorff_measure d) s = â¨† (r : ennreal) (hr : 0 < r), â¨… (t : â„• â†’ set X) (hts : s âŠ† â‹ƒ (n : â„•), t n) (ht : âˆ€ (n : â„•), emetric.diam (t n) â‰¤ r), âˆ‘' (n : â„•), â¨† (h : (t n).nonempty), emetric.diam (t n) ^ d
theorem has_le.le.trans_lf {x y z : pgame} (hâ‚ : x â‰¤ y) (hâ‚‚ : y.lf z) : x.lf z
theorem ideal.mem_quotient_iff_mem {R : Type u_1} [comm_ring R] {I J : ideal R} (hIJ : I â‰¤ J) {x : R} : â‡‘(ideal.quotient.mk I) x âˆˆ ideal.map (ideal.quotient.mk I) J â†” x âˆˆ J
theorem set.interval_subset_interval_union_interval {Î± : Type u} [linear_order Î±] {a b c : Î±} : set.interval a c âŠ† set.interval a b âˆª set.interval b c
theorem orientation.map_eq_det_inv_smul {R : Type u_1} [linear_ordered_field R] {M : Type u_2} [add_comm_group M] [module R M] {Î¹ : Type u_3} [decidable_eq Î¹] [fintype Î¹] [finite_dimensional R M] (x : orientation R M Î¹) (f : M â‰ƒâ‚—[R] M) (h : fintype.card Î¹ = finite_dimensional.finrank R M) : â‡‘(orientation.map Î¹ f) x = (â‡‘linear_equiv.det f)â»Â¹ â€¢ x
theorem structure_groupoid.compatible {H : Type u_1} [topological_space H] (G : structure_groupoid H) {M : Type u_2} [topological_space M] [charted_space H M] [has_groupoid M G] {e e' : local_homeomorph M H} (he : e âˆˆ charted_space.atlas H M) (he' : e' âˆˆ charted_space.atlas H M) : e.symm.trans e' âˆˆ G
theorem add_neg {Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b : Î±} (ha : a < 0) (hb : b < 0) : a + b < 0
theorem fintype.is_prime_pow_card_of_field {Î± : Type u_1} [fintype Î±] [field Î±] : is_prime_pow (fintype.card Î±)
theorem convex.lipschitz_on_with_of_nnnorm_has_deriv_within_le {ğ•œ : Type u_3} {G : Type u_4} [is_R_or_C ğ•œ] [normed_group G] [normed_space ğ•œ G] {f f' : ğ•œ â†’ G} {s : set ğ•œ} {C : nnreal} (hs : convex â„ s) (hf : âˆ€ (x : ğ•œ), x âˆˆ s â†’ has_deriv_within_at f (f' x) s x) (bound : âˆ€ (x : ğ•œ), x âˆˆ s â†’ âˆ¥f' xâˆ¥â‚Š â‰¤ C) : lipschitz_on_with C f s
theorem localization.at_prime.comap_maximal_ideal {R : Type u_1} [comm_semiring R] {I : ideal R} [hI : I.is_prime] : ideal.comap (algebra_map R (localization.at_prime I)) (local_ring.maximal_ideal (localization I.prime_compl)) = I
theorem orientation.oangle_neg_orientation_eq_neg {V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) (x y : V) : (-o).oangle x y = -o.oangle x y
theorem filter.map_at_top_finset_sum_le_of_sum_eq {Î± : Type u_3} {Î² : Type u_4} {Î³ : Type u_5} [add_comm_monoid Î±] {f : Î² â†’ Î±} {g : Î³ â†’ Î±} (h_eq : âˆ€ (u : finset Î³), âˆƒ (v : finset Î²), âˆ€ (v' : finset Î²), v âŠ† v' â†’ (âˆƒ (u' : finset Î³), u âŠ† u' âˆ§ u'.sum (Î» (x : Î³), g x) = v'.sum (Î» (b : Î²), f b))) : filter.map (Î» (s : finset Î²), s.sum (Î» (b : Î²), f b)) filter.at_top â‰¤ filter.map (Î» (s : finset Î³), s.sum (Î» (x : Î³), g x)) filter.at_top
theorem group.fg_iff_monoid.fg {G : Type u_3} [group G] : group.fg G â†” monoid.fg G
theorem category_theory.abelian.pseudoelement.sub_of_eq_image {C : Type u} [category_theory.category C] [category_theory.abelian C] {P Q : C} (f : P âŸ¶ Q) (x y : â†¥P) : â‡‘f x = â‡‘f y â†’ (âˆƒ (z : â†¥P), â‡‘f z = 0 âˆ§ âˆ€ (R : C) (g : P âŸ¶ R), â‡‘g y = 0 â†’ â‡‘g z = â‡‘g x)
theorem padic_val_rat.pow (p : â„•) [p_prime : fact (nat.prime p)] {q : â„š} (hq : q â‰  0) {k : â„•} : padic_val_rat p (q ^ k) = â†‘k * padic_val_rat p q
theorem fourier_subalgebra_closure_eq_top  : fourier_subalgebra.topological_closure = âŠ¤
theorem has_deriv_at.scomp {ğ•œ : Type u} [nondiscrete_normed_field ğ•œ] {F : Type v} [normed_group F] [normed_space ğ•œ F] (x : ğ•œ) {ğ•œ' : Type u_1} [nondiscrete_normed_field ğ•œ'] [normed_algebra ğ•œ ğ•œ'] [normed_space ğ•œ' F] [is_scalar_tower ğ•œ ğ•œ' F] {h : ğ•œ â†’ ğ•œ'} {h' : ğ•œ'} {gâ‚ : ğ•œ' â†’ F} {gâ‚' : F} (hg : has_deriv_at gâ‚ gâ‚' (h x)) (hh : has_deriv_at h h' x) : has_deriv_at (gâ‚ âˆ˜ h) (h' â€¢ gâ‚') x
theorem strict_mono.strict_convex_on_univ_of_deriv {f : â„ â†’ â„} (hf : differentiable â„ f) (hf'_mono : strict_mono (deriv f)) : strict_convex_on â„ set.univ f
theorem measure_theory.measure.restrict_mono' {Î± : Type u_1} {m0 : measurable_space Î±} â¦ƒs s' : set Î±â¦„ â¦ƒÎ¼ Î½ : measure_theory.measure Î±â¦„ (hs : s â‰¤áµ[Î¼] s') (hÎ¼Î½ : Î¼ â‰¤ Î½) : Î¼.restrict s â‰¤ Î½.restrict s'
theorem complex.tendsto_lim_of_differentiable_on_punctured_nhds_of_is_o {E : Type u} [normed_group E] [normed_space â„‚ E] [complete_space E] {f : â„‚ â†’ E} {c : â„‚} (hd : âˆ€á¶  (z : â„‚) in nhds_within c {c}á¶œ, differentiable_at â„‚ f z) (ho : (Î» (z : â„‚), f z - f c) =o[nhds_within c {c}á¶œ] Î» (z : â„‚), (z - c)â»Â¹) : filter.tendsto f (nhds_within c {c}á¶œ) (nhds (lim (nhds_within c {c}á¶œ) f))
theorem neg_of_neg_pos {Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a : Î±} : 0 < -a â†’ a < 0
theorem pi_nat.exists_retraction_of_is_closed {E : â„• â†’ Type u_1} [Î  (n : â„•), topological_space (E n)] [âˆ€ (n : â„•), discrete_topology (E n)] {s : set (Î  (n : â„•), E n)} (hs : is_closed s) (hne : s.nonempty) : âˆƒ (f : (Î  (n : â„•), E n) â†’ Î  (n : â„•), E n), (âˆ€ (x : Î  (n : â„•), E n), x âˆˆ s â†’ f x = x) âˆ§ set.range f = s âˆ§ continuous f
theorem algebra.power_basis.norm_gen_eq_coeff_zero_minpoly {S : Type u_2} [comm_ring S] {K : Type u_4} [field K] [algebra K S] (pb : power_basis K S) : â‡‘(algebra.norm K) pb.gen = (-1) ^ pb.dim * (minpoly K pb.gen).coeff 0
theorem finprod_induction {M : Type u_2} {Î± : Sort u_4} [comm_monoid M] {f : Î± â†’ M} (p : M â†’ Prop) (hpâ‚€ : p 1) (hpâ‚ : âˆ€ (x y : M), p x â†’ p y â†’ p (x * y)) (hpâ‚‚ : âˆ€ (i : Î±), p (f i)) : p (finprod (Î» (i : Î±), f i))
theorem exists_norm_eq_infi_of_complete_convex {F : Type u_3} [inner_product_space â„ F] {K : set F} (ne : K.nonempty) (hâ‚ : is_complete K) (hâ‚‚ : convex â„ K) (u : F) : âˆƒ (v : F) (H : v âˆˆ K), âˆ¥u - vâˆ¥ = â¨… (w : â†¥K), âˆ¥u - â†‘wâˆ¥
theorem real_inner_eq_norm_add_mul_self_sub_norm_mul_self_sub_norm_mul_self_div_two {F : Type u_3} [inner_product_space â„ F] (x y : F) : has_inner.inner x y = (âˆ¥x + yâˆ¥ * âˆ¥x + yâˆ¥ - âˆ¥xâˆ¥ * âˆ¥xâˆ¥ - âˆ¥yâˆ¥ * âˆ¥yâˆ¥) / 2
theorem exists_partition_approximates_linear_on_of_has_fderiv_within_at {E : Type u_1} {F : Type u_2} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] [normed_group F] [normed_space â„ F] [measurable_space E] [borel_space E] [topological_space.second_countable_topology F] (f : E â†’ F) (s : set E) (f' : E â†’ (E â†’L[â„] F)) (hf' : âˆ€ (x : E), x âˆˆ s â†’ has_fderiv_within_at f (f' x) s x) (r : (E â†’L[â„] F) â†’ nnreal) (rpos : âˆ€ (A : E â†’L[â„] F), r A â‰  0) : âˆƒ (t : â„• â†’ set E) (A : â„• â†’ (E â†’L[â„] F)), pairwise (disjoint on t) âˆ§ (âˆ€ (n : â„•), measurable_set (t n)) âˆ§ (s âŠ† â‹ƒ (n : â„•), t n) âˆ§ (âˆ€ (n : â„•), approximates_linear_on f (A n) (s âˆ© t n) (r (A n))) âˆ§ (s.nonempty â†’ âˆ€ (n : â„•), âˆƒ (y : E) (H : y âˆˆ s), A n = f' y)
theorem is_topological_fiber_bundle_snd {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] : is_topological_fiber_bundle F prod.snd
theorem nat.totient_prime_pow {p : â„•} (hp : nat.prime p) {n : â„•} (hn : 0 < n) : (p ^ n).totient = p ^ (n - 1) * (p - 1)
theorem Top.presheaf.to_Type_is_sheaf (X : Top) (T : Type u) : (X.presheaf_to_Type T).is_sheaf
theorem tendsto_rpow_div  : filter.tendsto (Î» (x : â„), x ^ (1 / x)) filter.at_top (nhds 1)
theorem contract_left_assoc_coevaluation (K : Type u) [field K] (V : Type v) [add_comm_group V] [module K V] [finite_dimensional K V] : (linear_map.rtensor (module.dual K V) (contract_left K V)).comp ((tensor_product.assoc K (module.dual K V) V (module.dual K V)).symm.to_linear_map.comp (linear_map.ltensor (module.dual K V) (coevaluation K V))) = (tensor_product.lid K (module.dual K V)).symm.to_linear_map.comp (tensor_product.rid K (module.dual K V)).to_linear_map
theorem set.union_finset_finite_of_range_finite {Î± : Type u} {Î² : Type v} (f : Î± â†’ finset Î²) (h : (set.range f).finite) : (â‹ƒ (a : Î±), â†‘(f a)).finite
theorem measurable.lintegral_prod_right' {Î± : Type u_1} {Î² : Type u_3} [measurable_space Î±] [measurable_space Î²] {Î½ : measure_theory.measure Î²} [measure_theory.sigma_finite Î½] {f : Î± Ã— Î² â†’ ennreal} (hf : measurable f) : measurable (Î» (x : Î±), âˆ«â» (y : Î²), f (x, y) âˆ‚Î½)
theorem finset.card_Ico_finset {Î± : Type u_1} [decidable_eq Î±] {s t : finset Î±} (h : s âŠ† t) : (finset.Ico s t).card = 2 ^ (t.card - s.card) - 1
theorem minpoly.coeff_zero_eq_zero {A : Type u_1} {B : Type u_2} [field A] [ring B] [is_domain B] [algebra A B] {x : B} (hx : is_integral A x) : (minpoly A x).coeff 0 = 0 â†” x = 0
theorem real.Lp_add_le_has_sum_of_nonneg {Î¹ : Type u} {f g : Î¹ â†’ â„} {p : â„} (hp : 1 â‰¤ p) (hf : âˆ€ (i : Î¹), 0 â‰¤ f i) (hg : âˆ€ (i : Î¹), 0 â‰¤ g i) {A B : â„} (hA : 0 â‰¤ A) (hB : 0 â‰¤ B) (hfA : has_sum (Î» (i : Î¹), f i ^ p) (A ^ p)) (hgB : has_sum (Î» (i : Î¹), g i ^ p) (B ^ p)) : âˆƒ (C : â„), 0 â‰¤ C âˆ§ C â‰¤ A + B âˆ§ has_sum (Î» (i : Î¹), (f i + g i) ^ p) (C ^ p)
theorem convex.is_const_of_fderiv_within_eq_zero {E : Type u_1} [normed_group E] [normed_space â„ E] {ğ•œ : Type u_3} {G : Type u_4} [is_R_or_C ğ•œ] [normed_space ğ•œ E] [normed_group G] [normed_space ğ•œ G] {f : E â†’ G} {s : set E} {x y : E} (hs : convex â„ s) (hf : differentiable_on ğ•œ f s) (hf' : âˆ€ (x : E), x âˆˆ s â†’ fderiv_within ğ•œ f s x = 0) (hx : x âˆˆ s) (hy : y âˆˆ s) : f x = f y
theorem vector_span_range_eq_span_range_vsub_right_ne (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {Î¹ : Type u_4} (p : Î¹ â†’ P) (iâ‚€ : Î¹) : vector_span k (set.range p) = submodule.span k (set.range (Î» (i : {x // x â‰  iâ‚€}), p â†‘i -áµ¥ p iâ‚€))
theorem normed_space.dual.is_closed_image_polar_of_mem_nhds (ğ•œ : Type u_1) [nondiscrete_normed_field ğ•œ] {E : Type u_2} [semi_normed_group E] [normed_space ğ•œ E] {s : set E} (s_nhd : s âˆˆ nhds 0) : is_closed (coe_fn '' normed_space.polar ğ•œ s)
theorem category_theory.is_pushout.of_is_coproduct {C : Type uâ‚} [category_theory.category C] {Z X Y : C} {c : category_theory.limits.binary_cofan X Y} (h : category_theory.limits.is_colimit c) (t : category_theory.limits.is_initial Z) : category_theory.is_pushout (t.to ((category_theory.limits.pair X Y).obj {as := category_theory.limits.walking_pair.left})) (t.to ((category_theory.limits.pair X Y).obj {as := category_theory.limits.walking_pair.right})) c.inl c.inr
theorem union_support_maximal_linear_independent_eq_range_basis {R : Type u} [ring R] {M : Type v} [add_comm_group M] [module R M] [nontrivial R] {Î¹ : Type w} (b : basis Î¹ R M) {Îº : Type w'} (v : Îº â†’ M) (i : linear_independent R v) (m : i.maximal) : (â‹ƒ (k : Îº), â†‘((â‡‘(b.repr) (v k)).support)) = set.univ
theorem category_theory.reflects_isomorphisms_forgetâ‚‚ (C : Type (u+1)) [category_theory.category C] [category_theory.concrete_category C] (D : Type (u+1)) [category_theory.category D] [category_theory.concrete_category D] [category_theory.has_forgetâ‚‚ C D] [category_theory.reflects_isomorphisms (category_theory.forget C)] : category_theory.reflects_isomorphisms (category_theory.forgetâ‚‚ C D)
theorem continuous_linear_map.comp_analytic_on {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [nondiscrete_normed_field ğ•œ] [normed_group E] [normed_space ğ•œ E] [normed_group F] [normed_space ğ•œ F] [normed_group G] [normed_space ğ•œ G] {f : E â†’ F} {s : set E} (g : F â†’L[ğ•œ] G) (h : analytic_on ğ•œ f s) : analytic_on ğ•œ (â‡‘g âˆ˜ f) s
theorem dfinsupp.add_hom_ext' {Î¹ : Type u} {Î² : Î¹ â†’ Type v} [dec : decidable_eq Î¹] [Î  (i : Î¹), add_zero_class (Î² i)] {Î³ : Type w} [add_zero_class Î³] â¦ƒf g : (Î â‚€ (i : Î¹), Î² i) â†’+ Î³â¦„ (H : âˆ€ (x : Î¹), f.comp (dfinsupp.single_add_hom Î² x) = g.comp (dfinsupp.single_add_hom Î² x)) : f = g
theorem strict_convex_iff_convex {ğ•œ : Type u_1} [linear_ordered_field ğ•œ] [topological_space ğ•œ] [order_topology ğ•œ] {s : set ğ•œ} : strict_convex ğ•œ s â†” convex ğ•œ s
theorem monoid_with_zero_hom.ext_int' {M : Type u_1} [monoid_with_zero M] {Ï†â‚ Ï†â‚‚ : â„¤ â†’*â‚€ M} (h_neg_one : â‡‘Ï†â‚ (-1) = â‡‘Ï†â‚‚ (-1)) (h_pos : âˆ€ (n : â„•), 0 < n â†’ â‡‘Ï†â‚ â†‘n = â‡‘Ï†â‚‚ â†‘n) : Ï†â‚ = Ï†â‚‚
theorem category_theory.has_finite_products_of_has_binary_and_terminal {C : Type u} [category_theory.category C] [category_theory.limits.has_binary_products C] [category_theory.limits.has_terminal C] : category_theory.limits.has_finite_products C
theorem category_theory.pretopology.to_grothendieck_bot (C : Type u) [category_theory.category C] [category_theory.limits.has_pullbacks C] : category_theory.pretopology.to_grothendieck C âŠ¥ = âŠ¥
theorem real.Lp_add_le_of_nonneg {Î¹ : Type u} (s : finset Î¹) {f g : Î¹ â†’ â„} {p : â„} (hp : 1 â‰¤ p) (hf : âˆ€ (i : Î¹), i âˆˆ s â†’ 0 â‰¤ f i) (hg : âˆ€ (i : Î¹), i âˆˆ s â†’ 0 â‰¤ g i) : s.sum (Î» (i : Î¹), (f i + g i) ^ p) ^ (1 / p) â‰¤ s.sum (Î» (i : Î¹), f i ^ p) ^ (1 / p) + s.sum (Î» (i : Î¹), g i ^ p) ^ (1 / p)
theorem affine_subspace.lt_iff_le_and_exists {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] (s1 s2 : affine_subspace k P) : s1 < s2 â†” s1 â‰¤ s2 âˆ§ âˆƒ (p : P) (H : p âˆˆ s2), p âˆ‰ s1
theorem continuous_at_of_monotone_on_of_image_mem_nhds {Î± : Type u_1} {Î² : Type u_2} [linear_order Î±] [topological_space Î±] [order_topology Î±] [linear_order Î²] [topological_space Î²] [order_topology Î²] [densely_ordered Î²] {f : Î± â†’ Î²} {s : set Î±} {a : Î±} (h_mono : monotone_on f s) (hs : s âˆˆ nhds a) (hfs : f '' s âˆˆ nhds (f a)) : continuous_at f a
theorem measure_theory.strongly_measurable.ite {Î± : Type u_1} {Î² : Type u_2} {f g : Î± â†’ Î²} {m : measurable_space Î±} [topological_space Î²] {p : Î± â†’ Prop} {_x : decidable_pred p} (hp : measurable_set {a : Î± | p a}) (hf : measure_theory.strongly_measurable f) (hg : measure_theory.strongly_measurable g) : measure_theory.strongly_measurable (Î» (x : Î±), ite (p x) (f x) (g x))
theorem affine_subspace.affine_span_coe {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] (s : affine_subspace k P) : affine_span k â†‘s = s
theorem matrix.is_diag.from_blocks {Î± : Type u_1} {n : Type u_4} {m : Type u_5} [has_zero Î±] {A : matrix m m Î±} {D : matrix n n Î±} (ha : A.is_diag) (hd : D.is_diag) : (matrix.from_blocks A 0 0 D).is_diag
theorem fintype.exists_lt_card_fiber_of_nsmul_lt_card {Î± : Type u} {Î² : Type v} {M : Type w} [decidable_eq Î²] [fintype Î±] [fintype Î²] (f : Î± â†’ Î²) {b : M} [linear_ordered_comm_ring M] (hb : fintype.card Î² â€¢ b < â†‘(fintype.card Î±)) : âˆƒ (y : Î²), b < â†‘((finset.filter (Î» (x : Î±), f x = y) finset.univ).card)
theorem equiv.add_right_symm_apply {G : Type u_10} [add_group G] (a : G) : â‡‘(equiv.symm (equiv.add_right a)) = Î» (x : G), x + -a
theorem finset.affine_combination_map {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {Î¹ : Type u_4} {Î¹â‚‚ : Type u_5} (sâ‚‚ : finset Î¹â‚‚) (e : Î¹â‚‚ â†ª Î¹) (w : Î¹ â†’ k) (p : Î¹ â†’ P) : â‡‘((finset.map e sâ‚‚).affine_combination p) w = â‡‘(sâ‚‚.affine_combination (p âˆ˜ â‡‘e)) (w âˆ˜ â‡‘e)
theorem map_infi_of_continuous_at_of_monotone' {Î± : Type u} {Î² : Type v} [complete_linear_order Î±] [topological_space Î±] [order_topology Î±] [complete_linear_order Î²] [topological_space Î²] [order_topology Î²] {Î¹ : Sort u_1} [nonempty Î¹] {f : Î± â†’ Î²} {g : Î¹ â†’ Î±} (Cf : continuous_at f (infi g)) (Mf : monotone f) : f (â¨… (i : Î¹), g i) = â¨… (i : Î¹), f (g i)
theorem continuous.fst {Î± : Type u} {Î² : Type v} {Î³ : Type u_1} [topological_space Î±] [topological_space Î²] [topological_space Î³] {f : Î± â†’ Î² Ã— Î³} (hf : continuous f) : continuous (Î» (a : Î±), (f a).fst)
theorem has_le.le.lt_of_not_le {Î± : Type u} [preorder Î±] {a b : Î±} : a â‰¤ b â†’ Â¬b â‰¤ a â†’ a < b
theorem category_theory.abelian.mono_of_epi_of_mono_of_mono {V : Type u} [category_theory.category V] [category_theory.abelian V] {A B C D A' B' C' D' : V} {f : A âŸ¶ B} {g : B âŸ¶ C} {h : C âŸ¶ D} {f' : A' âŸ¶ B'} {g' : B' âŸ¶ C'} {h' : C' âŸ¶ D'} {Î± : A âŸ¶ A'} {Î² : B âŸ¶ B'} {Î³ : C âŸ¶ C'} {Î´ : D âŸ¶ D'} (commâ‚ : Î± â‰« f' = f â‰« Î²) (commâ‚‚ : Î² â‰« g' = g â‰« Î³) (commâ‚ƒ : Î³ â‰« h' = h â‰« Î´) (hfg : category_theory.exact f g) (hgh : category_theory.exact g h) (hf'g' : category_theory.exact f' g') (hÎ± : category_theory.epi Î±) (hÎ² : category_theory.mono Î²) (hÎ´ : category_theory.mono Î´) : category_theory.mono Î³
theorem orientation.map_eq_iff_det_pos {R : Type u_1} [linear_ordered_field R] {M : Type u_2} [add_comm_group M] [module R M] {Î¹ : Type u_3} [decidable_eq Î¹] [fintype Î¹] [finite_dimensional R M] (x : orientation R M Î¹) (f : M â‰ƒâ‚—[R] M) (h : fintype.card Î¹ = finite_dimensional.finrank R M) : â‡‘(orientation.map Î¹ f) x = x â†” 0 < â‡‘linear_map.det â†‘f
theorem affine_subspace.span_Union (k : Type u_1) (V : Type u_2) {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {Î¹ : Type u_4} (s : Î¹ â†’ set P) : affine_span k (â‹ƒ (i : Î¹), s i) = â¨† (i : Î¹), affine_span k (s i)
theorem module.ray.units_smul_of_pos {R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] (u : RË£) (hu : 0 < â†‘u) (v : module.ray R M) : u â€¢ v = v
theorem metric.inf_dist_le_inf_dist_add_Hausdorff_dist {Î± : Type u} [pseudo_metric_space Î±] {s t : set Î±} {x : Î±} (fin : emetric.Hausdorff_edist s t â‰  âŠ¤) : metric.inf_dist x t â‰¤ metric.inf_dist x s + metric.Hausdorff_dist s t
theorem affine.simplex.face_eq_mk_of_point {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {n : â„•} (s : affine.simplex k P n) (i : fin (n + 1)) : s.face _ = affine.simplex.mk_of_point k (s.points i)
theorem continuous_on_prod_of_continuous_on_lipschitz_on {Î± : Type u} {Î² : Type v} {Î³ : Type w} [pseudo_emetric_space Î±] [topological_space Î²] [pseudo_emetric_space Î³] (f : Î± Ã— Î² â†’ Î³) {s : set Î±} {t : set Î²} (K : nnreal) (ha : âˆ€ (a : Î±), a âˆˆ s â†’ continuous_on (Î» (y : Î²), f (a, y)) t) (hb : âˆ€ (b : Î²), b âˆˆ t â†’ lipschitz_on_with K (Î» (x : Î±), f (x, b)) s) : continuous_on f (s Ã—Ë¢ t)
theorem equiv.mul_swap_involutive {Î± : Type u} [decidable_eq Î±] (i j : Î±) : function.involutive (Î» (_x : equiv.perm Î±), _x * equiv.swap i j)
theorem continuous_map.continuous_at {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] (f : C(Î±, Î²)) (x : Î±) : continuous_at â‡‘f x
theorem nonempty_of_finsum_mem_ne_zero {Î± : Type u_1} {M : Type u_5} [add_comm_monoid M] {f : Î± â†’ M} {s : set Î±} (h : finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), f i)) â‰  0) : s.nonempty
theorem measure_theory.submartingale.set_integral_le {Î± : Type u_1} {Î¹ : Type u_3} [preorder Î¹] {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {â„± : measure_theory.filtration Î¹ m0} [measure_theory.sigma_finite_filtration Î¼ â„±] {f : Î¹ â†’ Î± â†’ â„} (hf : measure_theory.submartingale f â„± Î¼) {i j : Î¹} (hij : i â‰¤ j) {s : set Î±} (hs : measurable_set s) : âˆ« (x : Î±) in s, f i x âˆ‚Î¼ â‰¤ âˆ« (x : Î±) in s, f j x âˆ‚Î¼
theorem re_inner_eq_norm_mul_self_add_norm_mul_self_sub_norm_sub_mul_self_div_two {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] (x y : E) : â‡‘is_R_or_C.re (has_inner.inner x y) = (âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + âˆ¥yâˆ¥ * âˆ¥yâˆ¥ - âˆ¥x - yâˆ¥ * âˆ¥x - yâˆ¥) / 2
theorem filter.tendsto_at_bot_at_bot_of_monotone' {Î¹ : Type u_1} {Î± : Type u_3} [preorder Î¹] [linear_order Î±] {u : Î¹ â†’ Î±} (h : monotone u) (H : Â¬bdd_below (set.range u)) : filter.tendsto u filter.at_bot filter.at_bot
theorem measure_theory.lintegral_le_of_forall_fin_meas_le' {Î± : Type u_1} {m m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (hm : m â‰¤ m0) [measure_theory.sigma_finite (Î¼.trim hm)] (C : ennreal) {f : Î± â†’ ennreal} (hf_meas : ae_measurable f Î¼) (hf : âˆ€ (s : set Î±), measurable_set s â†’ â‡‘Î¼ s â‰  âŠ¤ â†’ âˆ«â» (x : Î±) in s, f x âˆ‚Î¼ â‰¤ C) : âˆ«â» (x : Î±), f x âˆ‚Î¼ â‰¤ C
theorem convex.closure_subset_interior_image_homothety_of_one_lt {E : Type u_2} [add_comm_group E] [module â„ E] [topological_space E] [topological_add_group E] [has_continuous_smul â„ E] {s : set E} (hs : convex â„ s) {x : E} (hx : x âˆˆ interior s) (t : â„) (ht : 1 < t) : closure s âŠ† interior (â‡‘(affine_map.homothety x t) '' s)
theorem category_theory.coyoneda.is_iso {C : Type uâ‚} [category_theory.category C] {X Y : Cáµ’áµ–} (f : X âŸ¶ Y) [category_theory.is_iso (category_theory.coyoneda.map f)] : category_theory.is_iso f
theorem list.sublist.sum_le_sum {M : Type u_3} [add_monoid M] [preorder M] [covariant_class M M (function.swap has_add.add) has_le.le] [covariant_class M M has_add.add has_le.le] {lâ‚ lâ‚‚ : list M} (h : lâ‚ <+ lâ‚‚) (hâ‚ : âˆ€ (a : M), a âˆˆ lâ‚‚ â†’ 0 â‰¤ a) : lâ‚.sum â‰¤ lâ‚‚.sum
theorem add_submonoid.localization_map.map_spec {M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {N : Type u_2} [add_comm_monoid N] {P : Type u_3} [add_comm_monoid P] (f : S.localization_map N) {g : M â†’+ P} {T : add_submonoid P} (hy : âˆ€ (y : â†¥S), â‡‘g â†‘y âˆˆ T) {Q : Type u_4} [add_comm_monoid Q] {k : T.localization_map Q} (z : N) (u : Q) : â‡‘(f.map hy k) z = u â†” â‡‘(k.to_map) (â‡‘g (f.sec z).fst) = â‡‘(k.to_map) (â‡‘g â†‘((f.sec z).snd)) + u
theorem cont_diff_on.continuous_on_fderiv_within_apply {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {s : set E} {f : E â†’ F} {n : with_top â„•} (h : cont_diff_on ğ•œ n f s) (hs : unique_diff_on ğ•œ s) (hn : 1 â‰¤ n) : continuous_on (Î» (p : E Ã— E), â‡‘(fderiv_within ğ•œ f s p.fst) p.snd) (s Ã—Ë¢ set.univ)
theorem mv_polynomial.cardinal_mk_le_max {Ïƒ R : Type u} [comm_semiring R] : cardinal.mk (mv_polynomial Ïƒ R) â‰¤ linear_order.max (linear_order.max (cardinal.mk R) (cardinal.mk Ïƒ)) cardinal.aleph_0
theorem is_GÎ´_bUnion {Î± : Type u_1} {Î¹ : Type u_4} [topological_space Î±] {s : set Î¹} (hs : s.finite) {f : Î¹ â†’ set Î±} (h : âˆ€ (i : Î¹), i âˆˆ s â†’ is_GÎ´ (f i)) : is_GÎ´ (â‹ƒ (i : Î¹) (H : i âˆˆ s), f i)
theorem is_right_regular_of_non_zero_divisor {Î± : Type u} [non_unital_non_assoc_ring Î±] (k : Î±) (h : âˆ€ (x : Î±), x * k = 0 â†’ x = 0) : is_right_regular k
theorem affine_homeomorph_image_I {ğ•œ : Type u_1} [linear_ordered_field ğ•œ] [topological_space ğ•œ] [topological_ring ğ•œ] (a b : ğ•œ) (h : 0 < a) : â‡‘(affine_homeomorph a b _) '' set.Icc 0 1 = set.Icc b (a + b)
theorem category_theory.equalizer.presieve.sheaf_condition {C : Type uâ‚} [category_theory.category C] (P : Cáµ’áµ– â¥¤ Type (max vâ‚ uâ‚)) {X : C} (R : category_theory.presieve X) [category_theory.limits.has_pullbacks C] : category_theory.presieve.is_sheaf_for P R â†” nonempty (category_theory.limits.is_limit (category_theory.limits.fork.of_Î¹ (category_theory.equalizer.fork_map P R) _))
theorem has_btw.btw.cyclic_right {Î± : Type u_1} [circular_preorder Î±] {a b c : Î±} (h : has_btw.btw a b c) : has_btw.btw c a b
theorem orientation.two_zsmul_oangle_smul_smul_self {V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) (x : V) {râ‚ râ‚‚ : â„} : 2 â€¢ o.oangle (râ‚ â€¢ x) (râ‚‚ â€¢ x) = 0
theorem lt_of_tsub_lt_tsub_right {Î± : Type u_1} {a b c : Î±} [linear_order Î±] [add_comm_semigroup Î±] [has_sub Î±] [has_ordered_sub Î±] (h : a - c < b - c) : a < b
theorem power_series.order_add_of_order_eq {R : Type u_1} [semiring R] (Ï† Ïˆ : power_series R) (h : Ï†.order â‰  Ïˆ.order) : (Ï† + Ïˆ).order = Ï†.order âŠ“ Ïˆ.order
theorem min_cases {Î± : Type u} [linear_order Î±] (a b : Î±) : linear_order.min a b = a âˆ§ a â‰¤ b âˆ¨ linear_order.min a b = b âˆ§ b < a
theorem pgame.le_def {x y : pgame} : x â‰¤ y â†” (âˆ€ (i : x.left_moves), (âˆƒ (i' : y.left_moves), x.move_left i â‰¤ y.move_left i') âˆ¨ âˆƒ (j : (x.move_left i).right_moves), (x.move_left i).move_right j â‰¤ y) âˆ§ âˆ€ (j : y.right_moves), (âˆƒ (i : (y.move_right j).left_moves), x â‰¤ (y.move_right j).move_left i) âˆ¨ âˆƒ (j' : x.right_moves), x.move_right j' â‰¤ y.move_right j
theorem measure_theory.Lp_to_Lp_restrict_add {Î± : Type u_1} {E : Type u_3} [measurable_space Î±] [normed_group E] {p : ennreal} {Î¼ : measure_theory.measure Î±} (f g : â†¥(measure_theory.Lp E p Î¼)) (s : set Î±) : measure_theory.mem_â„’p.to_Lp â‡‘(f + g) _ = measure_theory.mem_â„’p.to_Lp â‡‘f _ + measure_theory.mem_â„’p.to_Lp â‡‘g _
theorem continuous_at_right_of_monotone_on_of_closure_image_mem_nhds_within {Î± : Type u_1} {Î² : Type u_2} [linear_order Î±] [topological_space Î±] [order_topology Î±] [linear_order Î²] [topological_space Î²] [order_topology Î²] [densely_ordered Î²] {f : Î± â†’ Î²} {s : set Î±} {a : Î±} (h_mono : monotone_on f s) (hs : s âˆˆ nhds_within a (set.Ici a)) (hfs : closure (f '' s) âˆˆ nhds_within (f a) (set.Ici (f a))) : continuous_within_at f (set.Ici a) a
theorem finset.center_mass_segment {R : Type u_1} {E : Type u_2} {Î¹ : Type u_4} [linear_ordered_field R] [add_comm_group E] [module R E] (s : finset Î¹) (wâ‚ wâ‚‚ : Î¹ â†’ R) (z : Î¹ â†’ E) (hwâ‚ : s.sum (Î» (i : Î¹), wâ‚ i) = 1) (hwâ‚‚ : s.sum (Î» (i : Î¹), wâ‚‚ i) = 1) (a b : R) (hab : a + b = 1) : a â€¢ s.center_mass wâ‚ z + b â€¢ s.center_mass wâ‚‚ z = s.center_mass (Î» (i : Î¹), a * wâ‚ i + b * wâ‚‚ i) z
theorem strict_convex_on_iff_slope_strict_mono_adjacent {ğ•œ : Type u_1} [linear_ordered_field ğ•œ] {s : set ğ•œ} {f : ğ•œ â†’ ğ•œ} : strict_convex_on ğ•œ s f â†” convex ğ•œ s âˆ§ âˆ€ â¦ƒx y z : ğ•œâ¦„, x âˆˆ s â†’ z âˆˆ s â†’ x < y â†’ y < z â†’ (f y - f x) / (y - x) < (f z - f y) / (z - y)
theorem emetric.Hausdorff_edist_zero_iff_closure_eq_closure {Î± : Type u} [pseudo_emetric_space Î±] {s t : set Î±} : emetric.Hausdorff_edist s t = 0 â†” closure s = closure t
theorem exists_open_with_compact_closure {Î± : Type u} [topological_space Î±] [locally_compact_space Î±] [t2_space Î±] (x : Î±) : âˆƒ (U : set Î±), is_open U âˆ§ x âˆˆ U âˆ§ is_compact (closure U)
theorem measure_theory.Lp_meas_subgroup_to_Lp_trim_right_inv {Î± : Type u_1} {F : Type u_6} {p : ennreal} [normed_group F] {m m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (hm : m â‰¤ m0) : function.right_inverse (measure_theory.Lp_trim_to_Lp_meas_subgroup F p Î¼ hm) (measure_theory.Lp_meas_subgroup_to_Lp_trim F p Î¼ hm)
theorem closure_operator.closure_le_mkâ‚ƒ_iff {Î± : Type u_1} [partial_order Î±] {f : Î± â†’ Î±} {p : Î± â†’ Prop} {hf : âˆ€ (x : Î±), x â‰¤ f x} {hfp : âˆ€ (x : Î±), p (f x)} {hmin : âˆ€ â¦ƒx y : Î±â¦„, x â‰¤ y â†’ p y â†’ f x â‰¤ y} {x y : Î±} (hxy : x â‰¤ y) (hy : p y) : â‡‘(closure_operator.mkâ‚ƒ f p hf hfp hmin) x â‰¤ y
theorem submonoid.localization_map.inv_inj {M : Type u_1} [comm_monoid M] {S : submonoid M} {N : Type u_2} [comm_monoid N] {f : M â†’* N} (hf : âˆ€ (y : â†¥S), is_unit (â‡‘f â†‘y)) {y z : â†¥S} (h : (â‡‘(is_unit.lift_right (f.restrict S) hf) y)â»Â¹ = (â‡‘(is_unit.lift_right (f.restrict S) hf) z)â»Â¹) : â‡‘f â†‘y = â‡‘f â†‘z
theorem monoid_hom.map_zpow {Î± : Type u_1} {Î² : Type u_2} [group Î±] [division_monoid Î²] (f : Î± â†’* Î²) (g : Î±) (n : â„¤) : â‡‘f (g ^ n) = â‡‘f g ^ n
theorem le_nhds_Lim {Î± : Type u} [topological_space Î±] {f : filter Î±} (h : âˆƒ (a : Î±), f â‰¤ nhds a) : f â‰¤ nhds (Lim f)
theorem convex.translate_preimage_left {ğ•œ : Type u_1} {E : Type u_2} [ordered_semiring ğ•œ] [add_comm_monoid E] [module ğ•œ E] {s : set E} (hs : convex ğ•œ s) (z : E) : convex ğ•œ ((Î» (x : E), x + z) â»Â¹' s)
theorem is_preconnected.bUnion_of_chain {Î± : Type u} {Î² : Type v} [topological_space Î±] [linear_order Î²] [succ_order Î²] [is_succ_archimedean Î²] {s : Î² â†’ set Î±} {t : set Î²} (ht : t.ord_connected) (H : âˆ€ (n : Î²), n âˆˆ t â†’ is_preconnected (s n)) (K : âˆ€ (n : Î²), n âˆˆ t â†’ order.succ n âˆˆ t â†’ (s n âˆ© s (order.succ n)).nonempty) : is_preconnected (â‹ƒ (n : Î²) (H : n âˆˆ t), s n)
theorem lie_algebra.infi_max_gen_zero_eigenspace_eq_top_of_nilpotent (R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] [lie_algebra.is_nilpotent R L] : (â¨… (x : L), (â‡‘(lie_algebra.ad R L) x).maximal_generalized_eigenspace 0) = âŠ¤
theorem list.array_eq_of_fn {Î± : Type u} {n : â„•} (a : array n Î±) : a.to_list = list.of_fn a.read
theorem real.tendsto_log_at_top  : filter.tendsto real.log filter.at_top filter.at_top
theorem cauchy_seq_bdd {Î± : Type u} [pseudo_metric_space Î±] {u : â„• â†’ Î±} (hu : cauchy_seq u) : âˆƒ (R : â„) (H : R > 0), âˆ€ (m n : â„•), has_dist.dist (u m) (u n) < R
theorem discrete_valuation_ring.has_unit_mul_pow_irreducible_factorization.to_unique_factorization_monoid {R : Type u_1} [comm_ring R] (hR : discrete_valuation_ring.has_unit_mul_pow_irreducible_factorization R) [is_domain R] : unique_factorization_monoid R
theorem fintype.all_card_le_rel_image_card_iff_exists_injective {Î± : Type u} {Î² : Type v} [decidable_eq Î²] (r : Î± â†’ Î² â†’ Prop) [Î  (a : Î±), fintype â†¥(rel.image r {a})] : (âˆ€ (A : finset Î±), A.card â‰¤ fintype.card â†¥(rel.image r â†‘A)) â†” âˆƒ (f : Î± â†’ Î²), function.injective f âˆ§ âˆ€ (x : Î±), r x (f x)
theorem generalized_continued_fraction.int_fract_pair.stream_is_seq {K : Type u_1} [linear_ordered_field K] [floor_ring K] (v : K) : (generalized_continued_fraction.int_fract_pair.stream v).is_seq
theorem not_interval_integrable_of_tendsto_norm_at_top_of_deriv_is_O_within_diff_singleton {E : Type u_1} {F : Type u_2} [normed_group E] [normed_space â„ E] [topological_space.second_countable_topology E] [complete_space E] [normed_group F] {f : â„ â†’ E} {g : â„ â†’ F} {a b c : â„} (hne : a â‰  b) (hc : c âˆˆ set.interval a b) (h_deriv : âˆ€á¶  (x : â„) in nhds_within c (set.interval a b  {c}), differentiable_at â„ f x) (h_infty : filter.tendsto (Î» (x : â„), âˆ¥f xâˆ¥) (nhds_within c (set.interval a b  {c})) filter.at_top) (hg : deriv f =O[nhds_within c (set.interval a b  {c})] g) : Â¬interval_integrable g measure_theory.measure_space.volume a b
theorem linear_map.convex_on {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [ordered_semiring ğ•œ] [add_comm_monoid E] [ordered_add_comm_monoid Î²] [module ğ•œ E] [module ğ•œ Î²] (f : E â†’â‚—[ğ•œ] Î²) {s : set E} (hs : convex ğ•œ s) : convex_on ğ•œ s â‡‘f
theorem formal_multilinear_series.is_o_of_lt_radius {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field ğ•œ] [normed_group E] [normed_space ğ•œ E] [normed_group F] [normed_space ğ•œ F] (p : formal_multilinear_series ğ•œ E F) {r : nnreal} (h : â†‘r < p.radius) : âˆƒ (a : â„) (H : a âˆˆ set.Ioo 0 1), (Î» (n : â„•), âˆ¥p nâˆ¥ * â†‘r ^ n) =o[filter.at_top] has_pow.pow a
theorem convolution_eq_right' {ğ•œ : Type u_1} {G : Type u_2} {E : Type u_3} {E' : Type u_4} {F : Type u_6} [normed_group E] [normed_group E'] [normed_group F] {f : G â†’ E} {g : G â†’ E'} [nondiscrete_normed_field ğ•œ] [normed_space ğ•œ E] [normed_space ğ•œ E'] [normed_space ğ•œ F] (L : E â†’L[ğ•œ] E' â†’L[ğ•œ] F) [measurable_space G] {Î¼ : measure_theory.measure G} [normed_space â„ F] [complete_space F] [semi_normed_group G] {xâ‚€ : G} {R : â„} (hf : function.support f âŠ† metric.ball 0 R) (hg : âˆ€ (x : G), x âˆˆ metric.ball xâ‚€ R â†’ g x = g xâ‚€) : convolution f g L Î¼ xâ‚€ = âˆ« (t : G), â‡‘(â‡‘L (f t)) (g xâ‚€) âˆ‚Î¼
theorem filter.mapâ‚‚_distrib_le_right {Î± : Type u_1} {Î±' : Type u_2} {Î² : Type u_3} {Î²' : Type u_4} {Î³ : Type u_5} {Î´ : Type u_7} {Îµ : Type u_9} {f : filter Î±} {g : filter Î²} {h : filter Î³} {m : Î´ â†’ Î³ â†’ Îµ} {n : Î± â†’ Î² â†’ Î´} {mâ‚ : Î± â†’ Î³ â†’ Î±'} {mâ‚‚ : Î² â†’ Î³ â†’ Î²'} {n' : Î±' â†’ Î²' â†’ Îµ} (h_distrib : âˆ€ (a : Î±) (b : Î²) (c : Î³), m (n a b) c = n' (mâ‚ a c) (mâ‚‚ b c)) : filter.mapâ‚‚ m (filter.mapâ‚‚ n f g) h â‰¤ filter.mapâ‚‚ n' (filter.mapâ‚‚ mâ‚ f h) (filter.mapâ‚‚ mâ‚‚ g h)
theorem measurable_embedding.lintegral_map {Î± : Type u_1} {Î² : Type u_2} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [measurable_space Î²] {g : Î± â†’ Î²} (hg : measurable_embedding g) (f : Î² â†’ ennreal) : âˆ«â» (a : Î²), f a âˆ‚measure_theory.measure.map g Î¼ = âˆ«â» (a : Î±), f (g a) âˆ‚Î¼
theorem finset.not_mem_map_subtype_of_not_property {Î± : Type u_1} {p : Î± â†’ Prop} (s : finset {x // p x}) {a : Î±} (h : Â¬p a) : a âˆ‰ finset.map (function.embedding.subtype (Î» (x : Î±), p x)) s
theorem category_theory.is_filtered.coeq_condition {C : Type u} [category_theory.category C] [category_theory.is_filtered C] {j j' : C} (f f' : j âŸ¶ j') : f â‰« category_theory.is_filtered.coeq_hom f f' = f' â‰« category_theory.is_filtered.coeq_hom f f'
theorem padic_val_nat.div {p : â„•} [p_prime : fact (nat.prime p)] {b : â„•} (dvd : p âˆ£ b) : padic_val_nat p (b / p) = padic_val_nat p b - 1
theorem same_ray_iff_inv_norm_smul_eq {F : Type u_2} [normed_group F] [normed_space â„ F] {x y : F} : same_ray â„ x y â†” x = 0 âˆ¨ y = 0 âˆ¨ âˆ¥xâˆ¥â»Â¹ â€¢ x = âˆ¥yâˆ¥â»Â¹ â€¢ y
theorem function.antiperiodic.periodic {Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} {c : Î±} [semiring Î±] [add_group Î²] (h : function.antiperiodic f c) : function.periodic f (2 * c)
theorem bilin_form.nondegenerate_of_anisotropic {R : Type u_2} {M : Type u_3} [add_comm_group M] [ring R] [module R M] {B : bilin_form R M} (hB : B.to_quadratic_form.anisotropic) : B.nondegenerate
theorem affine.simplex.eq_circumradius_of_dist_eq {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {n : â„•} (s : affine.simplex â„ P n) {p : P} (hp : p âˆˆ affine_span â„ (set.range s.points)) {r : â„} (hr : âˆ€ (i : fin (n + 1)), has_dist.dist (s.points i) p = r) : r = s.circumradius
theorem submodule.finrank_add_inf_finrank_orthogonal {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {Kâ‚ Kâ‚‚ : submodule ğ•œ E} [finite_dimensional ğ•œ â†¥Kâ‚‚] (h : Kâ‚ â‰¤ Kâ‚‚) : finite_dimensional.finrank ğ•œ â†¥Kâ‚ + finite_dimensional.finrank ğ•œ â†¥(Kâ‚á—® âŠ“ Kâ‚‚) = finite_dimensional.finrank ğ•œ â†¥Kâ‚‚
theorem is_submonoid.Inter {M : Type u_1} [monoid M] {Î¹ : Sort u_2} {s : Î¹ â†’ set M} (h : âˆ€ (y : Î¹), is_submonoid (s y)) : is_submonoid (set.Inter s)
theorem add_submonoid.localization_map.eq_of_eq {M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {N : Type u_2} [add_comm_monoid N] {P : Type u_3} [add_comm_monoid P] (f : S.localization_map N) {g : M â†’+ P} (hg : âˆ€ (y : â†¥S), is_add_unit (â‡‘g â†‘y)) {x y : M} (h : â‡‘(f.to_map) x = â‡‘(f.to_map) y) : â‡‘g x = â‡‘g y
theorem subsemiring.closure_eq {R : Type u} [non_assoc_semiring R] (s : subsemiring R) : subsemiring.closure â†‘s = s
theorem same_ray.refl {R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] (x : M) : same_ray R x x
theorem ring_hom.map_finsupp_sum {Î± : Type u_1} {M : Type u_5} {R : Type u_11} {S : Type u_12} [has_zero M] [semiring R] [semiring S] (h : R â†’+* S) (f : Î± â†’â‚€ M) (g : Î± â†’ M â†’ R) : â‡‘h (f.sum g) = f.sum (Î» (a : Î±) (b : M), â‡‘h (g a b))
theorem is_connected.bUnion_of_refl_trans_gen {Î± : Type u} [topological_space Î±] {Î¹ : Type u_1} {t : set Î¹} {s : Î¹ â†’ set Î±} (ht : t.nonempty) (H : âˆ€ (i : Î¹), i âˆˆ t â†’ is_connected (s i)) (K : âˆ€ (i : Î¹), i âˆˆ t â†’ âˆ€ (j : Î¹), j âˆˆ t â†’ relation.refl_trans_gen (Î» (i j : Î¹), (s i âˆ© s j).nonempty âˆ§ i âˆˆ t) i j) : is_connected (â‹ƒ (n : Î¹) (H : n âˆˆ t), s n)
theorem measure_theory.lintegral_eq_nnreal {Î± : Type u_1} {m : measurable_space Î±} (f : Î± â†’ ennreal) (Î¼ : measure_theory.measure Î±) : âˆ«â» (a : Î±), f a âˆ‚Î¼ = â¨† (Ï† : measure_theory.simple_func Î± nnreal) (hf : âˆ€ (x : Î±), â†‘(â‡‘Ï† x) â‰¤ f x), (measure_theory.simple_func.map coe Ï†).lintegral Î¼
theorem indexed_partition.out_proj {Î¹ : Type u_1} {Î± : Type u_2} {s : Î¹ â†’ set Î±} (hs : indexed_partition s) (x : Î±) : â‡‘(hs.out) (hs.proj x) = hs.some (hs.index x)
theorem monotone.sup {Î± : Type u} {Î² : Type v} [preorder Î±] [semilattice_sup Î²] {f g : Î± â†’ Î²} (hf : monotone f) (hg : monotone g) : monotone (f âŠ” g)
theorem option.subsingleton_iff_is_empty {Î± : Type u_1} : subsingleton (option Î±) â†” is_empty Î±
theorem cardinal.sum_lt_prod {Î¹ : Type u_1} (f g : Î¹ â†’ cardinal) (H : âˆ€ (i : Î¹), f i < g i) : cardinal.sum f < cardinal.prod g
theorem orientation.two_zsmul_oangle_neg_left {V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) (x y : V) : 2 â€¢ o.oangle (-x) y = 2 â€¢ o.oangle x y
theorem category_theory.limits.is_colimit.exists_unique {J : Type uâ‚} [category_theory.category J] {C : Type uâ‚ƒ} [category_theory.category C] {F : J â¥¤ C} {t : category_theory.limits.cocone F} (h : category_theory.limits.is_colimit t) (s : category_theory.limits.cocone F) : âˆƒ! (d : t.X âŸ¶ s.X), âˆ€ (j : J), t.Î¹.app j â‰« d = s.Î¹.app j
theorem function.periodic.exists_mem_Ioc {Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} {c : Î±} [linear_ordered_add_comm_group Î±] [archimedean Î±] (h : function.periodic f c) (hc : 0 < c) (x a : Î±) : âˆƒ (y : Î±) (H : y âˆˆ set.Ioc a (a + c)), f x = f y
theorem tensor_product.smul_tmul {R : Type u_1} [comm_semiring R] {R' : Type u_2} [monoid R'] {M : Type u_4} {N : Type u_5} [add_comm_monoid M] [add_comm_monoid N] [module R M] [module R N] [distrib_mul_action R' M] [distrib_mul_action R' N] [tensor_product.compatible_smul R R' M N] (r : R') (m : M) (n : N) : (r â€¢ m) âŠ—â‚œ[R] n = m âŠ—â‚œ[R] (r â€¢ n)
theorem fderiv_measurable_aux.D_subset_differentiable_set {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {f : E â†’ F} {K : set (E â†’L[ğ•œ] F)} (hK : is_complete K) : fderiv_measurable_aux.D f K âŠ† {x : E | differentiable_at ğ•œ f x âˆ§ fderiv ğ•œ f x âˆˆ K}
theorem emetric.diam_subsingleton {Î± : Type u} [pseudo_emetric_space Î±] {s : set Î±} (hs : s.subsingleton) : emetric.diam s = 0
theorem subfield.mem_supr_of_directed {K : Type u} [field K] {Î¹ : Sort u_1} [hÎ¹ : nonempty Î¹] {S : Î¹ â†’ subfield K} (hS : directed has_le.le S) {x : K} : (x âˆˆ â¨† (i : Î¹), S i) â†” âˆƒ (i : Î¹), x âˆˆ S i
theorem measure_theory.adapted.stopped_process_of_nat {Î± : Type u_1} {Î² : Type u_2} {m : measurable_space Î±} {f : measure_theory.filtration â„• m} {u : â„• â†’ Î± â†’ Î²} {Ï„ : Î± â†’ â„•} [add_comm_monoid Î²] [topological_space Î²] [has_continuous_add Î²] (hu : measure_theory.adapted f u) (hÏ„ : measure_theory.is_stopping_time f Ï„) : measure_theory.adapted f (measure_theory.stopped_process u Ï„)
theorem add_pos' {Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : 0 < a) (hb : 0 < b) : 0 < a + b
theorem inner_map_self_eq_zero {V : Type u_4} [inner_product_space â„‚ V] (T : V â†’â‚—[â„‚] V) : (âˆ€ (x : V), has_inner.inner (â‡‘T x) x = 0) â†” T = 0
theorem submodule.not_mem_span_of_apply_not_mem_span_image {R : Type u_1} {Râ‚‚ : Type u_2} {M : Type u_4} {Mâ‚‚ : Type u_5} [semiring R] [add_comm_monoid M] [module R M] [semiring Râ‚‚] {Ïƒâ‚â‚‚ : R â†’+* Râ‚‚} [add_comm_monoid Mâ‚‚] [module Râ‚‚ Mâ‚‚] [ring_hom_surjective Ïƒâ‚â‚‚] (f : M â†’â‚›â‚—[Ïƒâ‚â‚‚] Mâ‚‚) {x : M} {s : set M} (h : â‡‘f x âˆ‰ submodule.span Râ‚‚ (â‡‘f '' s)) : x âˆ‰ submodule.span R s
theorem measurable.exists_continuous {Î± : Type u_1} {Î² : Type u_2} [t : topological_space Î±] [polish_space Î±] [measurable_space Î±] [borel_space Î±] [tÎ² : topological_space Î²] [topological_space.second_countable_topology Î²] [measurable_space Î²] [borel_space Î²] {f : Î± â†’ Î²} (hf : measurable f) : âˆƒ (t' : topological_space Î±), t' â‰¤ t âˆ§ continuous f âˆ§ polish_space Î±
theorem tendsto_uniformly.continuous {Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_4} [uniform_space Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : filter Î¹} [topological_space Î±] (h : tendsto_uniformly F f p) (hc : âˆ€á¶  (n : Î¹) in p, continuous (F n)) [p.ne_bot] : continuous f
theorem formal_multilinear_series.comp_summable_nnreal {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [nondiscrete_normed_field ğ•œ] [normed_group E] [normed_space ğ•œ E] [normed_group F] [normed_space ğ•œ F] [normed_group G] [normed_space ğ•œ G] (q : formal_multilinear_series ğ•œ F G) (p : formal_multilinear_series ğ•œ E F) (hq : 0 < q.radius) (hp : 0 < p.radius) : âˆƒ (r : nnreal) (H : r > 0), summable (Î» (i : Î£ (n : â„•), composition n), âˆ¥q.comp_along_composition p i.sndâˆ¥â‚Š * r ^ i.fst)
theorem rack.assoc_iff_id {R : Type u_1} [rack R] {x y z : R} : shelf.act x (shelf.act y z) = shelf.act (shelf.act x y) z â†” shelf.act x z = z
theorem ring_hom.map_zero {Î± : Type u_2} {Î² : Type u_3} {rÎ± : non_assoc_semiring Î±} {rÎ² : non_assoc_semiring Î²} (f : Î± â†’+* Î²) : â‡‘f 0 = 0
theorem ring_hom.codomain_trivial_iff_map_one_eq_zero {Î± : Type u_2} {Î² : Type u_3} {rÎ± : non_assoc_semiring Î±} {rÎ² : non_assoc_semiring Î²} (f : Î± â†’+* Î²) : 0 = 1 â†” â‡‘f 1 = 0
theorem orientation.two_zsmul_oangle_smul_left_of_ne_zero {V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) (x y : V) {r : â„} (hr : r â‰  0) : 2 â€¢ o.oangle (r â€¢ x) y = 2 â€¢ o.oangle x y
theorem complex.abs_add (z w : â„‚) : complex.abs (z + w) â‰¤ complex.abs z + complex.abs w
theorem sub_lt_self {Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] (a : Î±) {b : Î±} : 0 < b â†’ a - b < a
theorem has_deriv_at.lhopital_zero_nhds_left {a : â„} {l : filter â„} {f f' g g' : â„ â†’ â„} (hff' : âˆ€á¶  (x : â„) in nhds_within a (set.Iio a), has_deriv_at f (f' x) x) (hgg' : âˆ€á¶  (x : â„) in nhds_within a (set.Iio a), has_deriv_at g (g' x) x) (hg' : âˆ€á¶  (x : â„) in nhds_within a (set.Iio a), g' x â‰  0) (hfa : filter.tendsto f (nhds_within a (set.Iio a)) (nhds 0)) (hga : filter.tendsto g (nhds_within a (set.Iio a)) (nhds 0)) (hdiv : filter.tendsto (Î» (x : â„), f' x / g' x) (nhds_within a (set.Iio a)) l) : filter.tendsto (Î» (x : â„), f x / g x) (nhds_within a (set.Iio a)) l
theorem affine_subspace.coe_direction_eq_vsub_set_left {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : affine_subspace k P} {p : P} (hp : p âˆˆ s) : â†‘(s.direction) = has_vsub.vsub p '' â†‘s
theorem is_torsion.exponent_exists {G : Type u_1} [group G] (tG : monoid.is_torsion G) (bounded : (set.range (Î» (g : G), order_of g)).finite) : monoid.exponent_exists G
theorem weak_dual.is_compact_closed_ball (ğ•œ : Type u_1) [nondiscrete_normed_field ğ•œ] {E : Type u_2} [semi_normed_group E] [normed_space ğ•œ E] [proper_space ğ•œ] (x' : normed_space.dual ğ•œ E) (r : â„) : is_compact (â‡‘weak_dual.to_normed_dual â»Â¹' metric.closed_ball x' r)
theorem basis.equiv_fun_symm_apply {Î¹ : Type u_1} {R : Type u_3} {M : Type u_5} [semiring R] [add_comm_monoid M] [module R M] [fintype Î¹] (b : basis Î¹ R M) (x : Î¹ â†’ R) : â‡‘(b.equiv_fun.symm) x = finset.univ.sum (Î» (i : Î¹), x i â€¢ â‡‘b i)
theorem measure_theory.exists_upper_semicontinuous_lt_integral_gt {Î± : Type u_1} [topological_space Î±] [measurable_space Î±] [borel_space Î±] {Î¼ : measure_theory.measure Î±} [Î¼.weakly_regular] [measure_theory.sigma_finite Î¼] (f : Î± â†’ â„) (hf : measure_theory.integrable f Î¼) {Îµ : â„} (Îµpos : 0 < Îµ) : âˆƒ (g : Î± â†’ ereal), (âˆ€ (x : Î±), g x < â†‘(f x)) âˆ§ upper_semicontinuous g âˆ§ measure_theory.integrable (Î» (x : Î±), (g x).to_real) Î¼ âˆ§ (âˆ€áµ (x : Î±) âˆ‚Î¼, âŠ¥ < g x) âˆ§ âˆ« (x : Î±), f x âˆ‚Î¼ < âˆ« (x : Î±), (g x).to_real âˆ‚Î¼ + Îµ
theorem emetric.Hausdorff_edist_empty {Î± : Type u} [pseudo_emetric_space Î±] {s : set Î±} (ne : s.nonempty) : emetric.Hausdorff_edist s âˆ… = âŠ¤
theorem not_not {a : Prop} : Â¬Â¬a â†” a
theorem orthonormal.two_zsmul_oangle_smul_left_self {V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) (x : V) {r : â„} : 2 â€¢ hb.oangle (r â€¢ x) x = 0
theorem ennreal.lintegral_mul_le_Lp_mul_Lq {Î± : Type u_1} [measurable_space Î±] (Î¼ : measure_theory.measure Î±) {p q : â„} (hpq : p.is_conjugate_exponent q) {f g : Î± â†’ ennreal} (hf : ae_measurable f Î¼) (hg : ae_measurable g Î¼) : âˆ«â» (a : Î±), (f * g) a âˆ‚Î¼ â‰¤ (âˆ«â» (a : Î±), f a ^ p âˆ‚Î¼) ^ (1 / p) * (âˆ«â» (a : Î±), g a ^ q âˆ‚Î¼) ^ (1 / q)
theorem strict_anti.dual_left {Î± : Type u} {Î² : Type v} [preorder Î±] [preorder Î²] {f : Î± â†’ Î²} : strict_anti f â†’ strict_mono (f âˆ˜ â‡‘order_dual.of_dual)
theorem of_set_mem_cont_diff_groupoid (n : with_top â„•) {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] (I : model_with_corners ğ•œ E H) {s : set H} (hs : is_open s) : local_homeomorph.of_set s hs âˆˆ cont_diff_groupoid n I
theorem local_homeomorph.eq_on_source.source_eq {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] {e e' : local_homeomorph Î± Î²} (h : e â‰ˆ e') : e.to_local_equiv.source = e'.to_local_equiv.source
theorem category_theory.limits.has_colimit_of_iso {J : Type uâ‚} [category_theory.category J] {C : Type u} [category_theory.category C] {F G : J â¥¤ C} [category_theory.limits.has_colimit F] (Î± : G â‰… F) : category_theory.limits.has_colimit G
theorem topological_space.exists_dense_seq (Î± : Type u) [t : topological_space Î±] [topological_space.separable_space Î±] [nonempty Î±] : âˆƒ (u : â„• â†’ Î±), dense_range u
theorem submodule.finrank_add_finrank_orthogonal {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] [finite_dimensional ğ•œ E] (K : submodule ğ•œ E) : finite_dimensional.finrank ğ•œ â†¥K + finite_dimensional.finrank ğ•œ â†¥Ká—® = finite_dimensional.finrank ğ•œ E
theorem measure_theory.is_stopping_time.piecewise_of_le {Î± : Type u_1} {Î¹ : Type u_3} {m : measurable_space Î±} [preorder Î¹] {ğ’¢ : measure_theory.filtration Î¹ m} {Ï„ Î· : Î± â†’ Î¹} {i : Î¹} {s : set Î±} [decidable_pred (Î» (_x : Î±), _x âˆˆ s)] (hÏ„_st : measure_theory.is_stopping_time ğ’¢ Ï„) (hÎ·_st : measure_theory.is_stopping_time ğ’¢ Î·) (hÏ„ : âˆ€ (x : Î±), i â‰¤ Ï„ x) (hÎ· : âˆ€ (x : Î±), i â‰¤ Î· x) (hs : measurable_set s) : measure_theory.is_stopping_time ğ’¢ (s.piecewise Ï„ Î·)
theorem exists_subset_affine_independent_span_eq_top_of_open {V : Type u_1} {P : Type u_2} [normed_group V] [normed_space â„ V] [metric_space P] [normed_add_torsor V P] {s u : set P} (hu : is_open u) (hsu : s âŠ† u) (hne : s.nonempty) (h : affine_independent â„ coe) : âˆƒ (t : set P), s âŠ† t âˆ§ t âŠ† u âˆ§ affine_independent â„ coe âˆ§ affine_span â„ t = âŠ¤
theorem measure_theory.outer_measure.is_metric.borel_le_caratheodory {X : Type u_2} [emetric_space X] {Î¼ : measure_theory.outer_measure X} (hm : Î¼.is_metric) : borel X â‰¤ Î¼.caratheodory
theorem same_ray_nonneg_smul_right {R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] (v : M) {r : R} (h : 0 â‰¤ r) : same_ray R v (r â€¢ v)
theorem algebraic_geometry.PresheafedSpace.glue_data.opens_image_preimage_map_app {C : Type u} [category_theory.category C] (D : algebraic_geometry.PresheafedSpace.glue_data C) [category_theory.limits.has_limits C] (i j k : D.to_glue_data.J) (U : topological_space.opens â†¥((D.to_glue_data.U i).carrier)) : D.opens_image_preimage_map i j U â‰« (D.to_glue_data.f j k).c.app (opposite.op ((topological_space.opens.map (D.to_glue_data.Î¹ j).base).obj (_.functor.obj U))) = (category_theory.limits.pullback.fst â‰« D.to_glue_data.t j i â‰« D.to_glue_data.f i j).c.app (opposite.op U) â‰« _.inv_app (opposite.unop ((topological_space.opens.map (category_theory.limits.pullback.fst â‰« D.to_glue_data.t j i â‰« D.to_glue_data.f i j).base).op.obj (opposite.op U))) â‰« (D.to_glue_data.V (j, k)).presheaf.map (category_theory.eq_to_hom _)
theorem squeeze_zero_norm' {Î± : Type u_1} {E : Type u_3} [semi_normed_group E] {f : Î± â†’ E} {g : Î± â†’ â„} {tâ‚€ : filter Î±} (h : âˆ€á¶  (n : Î±) in tâ‚€, âˆ¥f nâˆ¥ â‰¤ g n) (h' : filter.tendsto g tâ‚€ (nhds 0)) : filter.tendsto f tâ‚€ (nhds 0)
theorem cont_diff_groupoid_prod {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] {I : model_with_corners ğ•œ E H} {I' : model_with_corners ğ•œ E' H'} {e : local_homeomorph H H} {e' : local_homeomorph H' H'} (he : e âˆˆ cont_diff_groupoid âŠ¤ I) (he' : e' âˆˆ cont_diff_groupoid âŠ¤ I') : e.prod e' âˆˆ cont_diff_groupoid âŠ¤ (I.prod I')
theorem strict_mono.dual_left {Î± : Type u} {Î² : Type v} [preorder Î±] [preorder Î²] {f : Î± â†’ Î²} : strict_mono f â†’ strict_anti (f âˆ˜ â‡‘order_dual.of_dual)
theorem is_torsion_free.quotient_torsion (G : Type u_1) [comm_group G] : monoid.is_torsion_free (G â§¸ torsion G)
theorem add_equiv.map_sum {Î² : Type u} {Î± : Type v} {Î³ : Type w} [add_comm_monoid Î²] [add_comm_monoid Î³] (g : Î² â‰ƒ+ Î³) (f : Î± â†’ Î²) (s : finset Î±) : â‡‘g (s.sum (Î» (x : Î±), f x)) = s.sum (Î» (x : Î±), â‡‘g (f x))
theorem holder_on_with.hausdorff_measure_image_le {X : Type u_2} {Y : Type u_3} [emetric_space X] [emetric_space Y] [measurable_space X] [borel_space X] [measurable_space Y] [borel_space Y] {C r : nnreal} {f : X â†’ Y} {s : set X} (h : holder_on_with C r f s) (hr : 0 < r) {d : â„} (hd : 0 â‰¤ d) : â‡‘(measure_theory.measure.hausdorff_measure d) (f '' s) â‰¤ â†‘C ^ d * â‡‘(measure_theory.measure.hausdorff_measure (â†‘r * d)) s
theorem euclidean_geometry.left_dist_ne_zero_of_angle_eq_pi {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {p1 p2 p3 : P} (h : euclidean_geometry.angle p1 p2 p3 = real.pi) : has_dist.dist p1 p2 â‰  0
theorem is_of_fin_order_inv_iff {G : Type u} [group G] {x : G} : is_of_fin_order xâ»Â¹ â†” is_of_fin_order x
theorem continuous_multilinear_map.norm_image_sub_le' {ğ•œ : Type u} {Î¹ : Type v} {E : Î¹ â†’ Type wE} {G : Type wG} [decidable_eq Î¹] [fintype Î¹] [nondiscrete_normed_field ğ•œ] [Î  (i : Î¹), normed_group (E i)] [Î  (i : Î¹), normed_space ğ•œ (E i)] [normed_group G] [normed_space ğ•œ G] (f : continuous_multilinear_map ğ•œ E G) (mâ‚ mâ‚‚ : Î  (i : Î¹), E i) : âˆ¥â‡‘f mâ‚ - â‡‘f mâ‚‚âˆ¥ â‰¤ âˆ¥fâˆ¥ * finset.univ.sum (Î» (i : Î¹), finset.univ.prod (Î» (j : Î¹), ite (j = i) âˆ¥mâ‚ i - mâ‚‚ iâˆ¥ (linear_order.max âˆ¥mâ‚ jâˆ¥ âˆ¥mâ‚‚ jâˆ¥)))
theorem complex.dist_le_dist_of_maps_to_ball_self {f : â„‚ â†’ â„‚} {c z : â„‚} {R : â„} (hd : differentiable_on â„‚ f (metric.ball c R)) (h_maps : set.maps_to f (metric.ball c R) (metric.ball c R)) (hc : f c = c) (hz : z âˆˆ metric.ball c R) : has_dist.dist (f z) c â‰¤ has_dist.dist z c
theorem fg_of_fg_of_fg (A : Type w) (B : Type uâ‚) (C : Type u_1) [comm_ring A] [comm_ring B] [comm_ring C] [algebra A B] [algebra B C] [algebra A C] [is_scalar_tower A B C] [is_noetherian_ring A] (hAC : âŠ¤.fg) (hBC : âŠ¤.fg) (hBCi : function.injective â‡‘(algebra_map B C)) : âŠ¤.fg
theorem monovary_on.sum_comp_perm_mul_lt_sum_mul_iff {Î¹ : Type u_1} {Î± : Type u_2} [linear_ordered_ring Î±] {s : finset Î¹} {Ïƒ : equiv.perm Î¹} {f g : Î¹ â†’ Î±} (hfg : monovary_on f g â†‘s) (hÏƒ : {x : Î¹ | â‡‘Ïƒ x â‰  x} âŠ† â†‘s) : s.sum (Î» (i : Î¹), f (â‡‘Ïƒ i) * g i) < s.sum (Î» (i : Î¹), f i * g i) â†” Â¬monovary_on (f âˆ˜ â‡‘Ïƒ) g â†‘s
theorem finsupp.single_injective {Î± : Type u_1} {M : Type u_5} [has_zero M] (a : Î±) : function.injective (finsupp.single a)
theorem image_sub_lt_mul_sub_of_deriv_lt {f : â„ â†’ â„} (hf : differentiable â„ f) {C : â„} (lt_hf' : âˆ€ (x : â„), deriv f x < C) â¦ƒx y : â„â¦„ (hxy : x < y) : f y - f x < C * (y - x)
theorem add_monoid_hom.map_neg {Î± : Type u_1} {Î² : Type u_2} [add_group Î±] [subtraction_monoid Î²] (f : Î± â†’+ Î²) (a : Î±) : â‡‘f (-a) = -â‡‘f a
theorem lie_module.is_nilpotent_iff (R : Type u) (L : Type v) (M : Type w) [comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] : lie_module.is_nilpotent R L M â†” âˆƒ (k : â„•), lie_module.lower_central_series R L M k = âŠ¥
theorem disjoint.exists_open_convexes {E : Type u_2} [semi_normed_group E] [normed_space â„ E] {s t : set E} (disj : disjoint s t) (hsâ‚ : convex â„ s) (hsâ‚‚ : is_compact s) (htâ‚ : convex â„ t) (htâ‚‚ : is_closed t) : âˆƒ (u v : set E), is_open u âˆ§ is_open v âˆ§ convex â„ u âˆ§ convex â„ v âˆ§ s âŠ† u âˆ§ t âŠ† v âˆ§ disjoint u v
theorem linear_map.pow_eq_aeval_mod_charpoly {R : Type u} {M : Type v} [comm_ring R] [nontrivial R] [add_comm_group M] [module R M] [module.free R M] [module.finite R M] (f : M â†’â‚—[R] M) (k : â„•) : f ^ k = â‡‘(polynomial.aeval f) (polynomial.X ^ k %â‚˜ f.charpoly)
theorem matrix.mul_mul_inv_of_self_cancel {m : Type u} {n : Type u'} {Î± : Type v} [fintype n] [decidable_eq n] [comm_ring Î±] (A : matrix m n Î±) (B : matrix n n Î±) [invertible B] : (A.mul B).mul (â…Ÿ B) = A
theorem emetric.mem_closure_iff_inf_edist_zero {Î± : Type u} [pseudo_emetric_space Î±] {x : Î±} {s : set Î±} : x âˆˆ closure s â†” emetric.inf_edist x s = 0
theorem continuous.surjective' {Î± : Type u} [conditionally_complete_linear_order Î±] [topological_space Î±] [order_topology Î±] [densely_ordered Î±] {Î´ : Type u_1} [linear_order Î´] [topological_space Î´] [order_closed_topology Î´] {f : Î± â†’ Î´} (hf : continuous f) (h_top : filter.tendsto f filter.at_bot filter.at_top) (h_bot : filter.tendsto f filter.at_top filter.at_bot) : function.surjective f
theorem measure_theory.signed_measure.singular_part_add_with_density_rn_deriv_eq {Î± : Type u_1} {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) (s : measure_theory.signed_measure Î±) [s.have_lebesgue_decomposition Î¼] : s.singular_part Î¼ + Î¼.with_densityáµ¥ (s.rn_deriv Î¼) = s
theorem exists_open_set_nhds' {Î± : Type u} [topological_space Î±] {s U : set Î±} (h : U âˆˆ â¨† (x : Î±) (H : x âˆˆ s), nhds x) : âˆƒ (V : set Î±), s âŠ† V âˆ§ is_open V âˆ§ V âŠ† U
theorem strict_concave_on.translate_left {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [ordered_semiring ğ•œ] [add_cancel_comm_monoid E] [ordered_add_comm_monoid Î²] [module ğ•œ E] [has_scalar ğ•œ Î²] {s : set E} {f : E â†’ Î²} (hf : strict_concave_on ğ•œ s f) (c : E) : strict_concave_on ğ•œ ((Î» (z : E), c + z) â»Â¹' s) (f âˆ˜ Î» (z : E), z + c)
theorem algebra.trace_algebra_map {K : Type u_4} {L : Type u_5} [field K] [field L] [algebra K L] (x : K) : â‡‘(algebra.trace K L) (â‡‘(algebra_map K L) x) = finite_dimensional.finrank K L â€¢ x
theorem measure_theory.lintegral_supr' {Î± : Type u_1} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {f : â„• â†’ Î± â†’ ennreal} (hf : âˆ€ (n : â„•), ae_measurable (f n) Î¼) (h_mono : âˆ€áµ (x : Î±) âˆ‚Î¼, monotone (Î» (n : â„•), f n x)) : âˆ«â» (a : Î±), (â¨† (n : â„•), f n a) âˆ‚Î¼ = â¨† (n : â„•), âˆ«â» (a : Î±), f n a âˆ‚Î¼
theorem polynomial.cyclotomic.irreducible_rat {n : â„•} (hpos : 0 < n) : irreducible (polynomial.cyclotomic n â„š)
theorem orthonormal.oangle_sub_eq_oangle_sub_rev_of_norm_eq {V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) {x y : V} (h : âˆ¥xâˆ¥ = âˆ¥yâˆ¥) : hb.oangle x (x - y) = hb.oangle (y - x) y
theorem is_pi_system.prod {Î± : Type u_1} {Î² : Type u_3} {C : set (set Î±)} {D : set (set Î²)} (hC : is_pi_system C) (hD : is_pi_system D) : is_pi_system (set.image2 has_set_prod.prod C D)
theorem has_strict_deriv_at_exp_zero_of_radius_pos {ğ•‚ : Type u_1} [nondiscrete_normed_field ğ•‚] [complete_space ğ•‚] (h : 0 < (exp_series ğ•‚ ğ•‚).radius) : has_strict_deriv_at (exp ğ•‚) 1 0
theorem spectrum.differentiable_on_inverse_one_sub_smul {ğ•œ : Type u_1} {A : Type u_2} [nondiscrete_normed_field ğ•œ] [normed_ring A] [normed_algebra ğ•œ A] [complete_space A] {a : A} {r : nnreal} (hr : â†‘r < (spectral_radius ğ•œ a)â»Â¹) : differentiable_on ğ•œ (Î» (z : ğ•œ), ring.inverse (1 - z â€¢ a)) (metric.closed_ball 0 â†‘r)
theorem list.permutations_aux2_comp_append {Î± : Type u_1} {Î² : Type u_2} {t : Î±} {ts ys : list Î±} {r : list Î²} (f : list Î± â†’ Î²) : (list.permutations_aux2 t list.nil r ys (Î» (x : list Î±), f (x ++ ts))).snd = (list.permutations_aux2 t ts r ys f).snd
theorem relation.cut_expand_fibration {Î± : Type u_1} (r : Î± â†’ Î± â†’ Prop) : relation.fibration (relation.game_add (relation.cut_expand r) (relation.cut_expand r)) (relation.cut_expand r) (Î» (s : multiset Î± Ã— multiset Î±), s.fst + s.snd)
theorem nat.factors_count_eq {n p : â„•} : list.count p n.factors = â‡‘(n.factorization) p
theorem intermediate_field.mul_mem {K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) {x y : L} : x âˆˆ S â†’ y âˆˆ S â†’ x * y âˆˆ S
theorem antitone.min {Î± : Type u} {Î² : Type v} [preorder Î±] [linear_order Î²] {f g : Î± â†’ Î²} (hf : antitone f) (hg : antitone g) : antitone (Î» (x : Î±), linear_order.min (f x) (g x))
theorem asymptotics.is_o.of_norm_right {Î± : Type u_1} {E : Type u_3} {F' : Type u_7} [has_norm E] [semi_normed_group F'] {f : Î± â†’ E} {g' : Î± â†’ F'} {l : filter Î±} : (f =o[l] Î» (x : Î±), âˆ¥g' xâˆ¥) â†’ f =o[l] g'
theorem cont_diff_on_of_continuous_on_differentiable_on_deriv {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {F : Type u_2} [normed_group F] [normed_space ğ•œ F] {f : ğ•œ â†’ F} {s : set ğ•œ} {n : with_top â„•} (Hcont : âˆ€ (m : â„•), â†‘m â‰¤ n â†’ continuous_on (Î» (x : ğ•œ), iterated_deriv_within m f s x) s) (Hdiff : âˆ€ (m : â„•), â†‘m < n â†’ differentiable_on ğ•œ (Î» (x : ğ•œ), iterated_deriv_within m f s x) s) : cont_diff_on ğ•œ n f s
theorem measure_theory.fin_strongly_measurable_iff_measurable {Î± : Type u_1} {G : Type u_5} [normed_group G] [measurable_space G] [borel_space G] [topological_space.second_countable_topology G] {f : Î± â†’ G} {m0 : measurable_space Î±} (Î¼ : measure_theory.measure Î±) [measure_theory.sigma_finite Î¼] : measure_theory.fin_strongly_measurable f Î¼ â†” measurable f
theorem euclidean_geometry.angle_eq_angle_of_angle_eq_pi {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] (p1 : P) {p2 p3 p4 : P} (h : euclidean_geometry.angle p2 p3 p4 = real.pi) : euclidean_geometry.angle p1 p2 p3 = euclidean_geometry.angle p1 p2 p4
theorem measure_theory.outer_measure.ext_nonempty {Î± : Type u_1} {Î¼â‚ Î¼â‚‚ : measure_theory.outer_measure Î±} (h : âˆ€ (s : set Î±), s.nonempty â†’ â‡‘Î¼â‚ s = â‡‘Î¼â‚‚ s) : Î¼â‚ = Î¼â‚‚
theorem finset.prod_product' {Î² : Type u} {Î± : Type v} {Î³ : Type w} [comm_monoid Î²] {s : finset Î³} {t : finset Î±} {f : Î³ â†’ Î± â†’ Î²} : (s.product t).prod (Î» (x : Î³ Ã— Î±), f x.fst x.snd) = s.prod (Î» (x : Î³), t.prod (Î» (y : Î±), f x y))
theorem continuous_at_left_of_monotone_on_of_closure_image_mem_nhds_within {Î± : Type u_1} {Î² : Type u_2} [linear_order Î±] [topological_space Î±] [order_topology Î±] [linear_order Î²] [topological_space Î²] [order_topology Î²] [densely_ordered Î²] {f : Î± â†’ Î²} {s : set Î±} {a : Î±} (hf : monotone_on f s) (hs : s âˆˆ nhds_within a (set.Iic a)) (hfs : closure (f '' s) âˆˆ nhds_within (f a) (set.Iic (f a))) : continuous_within_at f (set.Iic a) a
theorem Top.presheaf.is_sheaf_iff_is_sheaf_preserves_limit_pairwise_intersections {X : Top} {C : Type u} [category_theory.category C] [category_theory.limits.has_products C] (F : Top.presheaf C X) : F.is_sheaf â†” F.is_sheaf_preserves_limit_pairwise_intersections
theorem inner_product_geometry.angle_smul_left_of_neg {V : Type u_1} [inner_product_space â„ V] (x y : V) {r : â„} (hr : r < 0) : inner_product_geometry.angle (r â€¢ x) y = inner_product_geometry.angle (-x) y
theorem category_theory.adjunction.has_limits_of_shape_of_equivalence {C : Type uâ‚} [category_theory.category C] {D : Type uâ‚‚} [category_theory.category D] {J : Type u} [category_theory.category J] (E : D â¥¤ C) [category_theory.is_equivalence E] [category_theory.limits.has_limits_of_shape J C] : category_theory.limits.has_limits_of_shape J D
theorem antitone.dual_left {Î± : Type u} {Î² : Type v} [preorder Î±] [preorder Î²] {f : Î± â†’ Î²} : antitone f â†’ monotone (f âˆ˜ â‡‘order_dual.of_dual)
theorem measure_theory.ae_restrict_of_ae_eq_of_ae_restrict {Î± : Type u_1} {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {s t : Î± â†’ Prop} (hst : s =áµ[Î¼] t) {p : Î± â†’ Prop} : (âˆ€áµ (x : Î±) âˆ‚Î¼.restrict s, p x) â†’ (âˆ€áµ (x : Î±) âˆ‚Î¼.restrict t, p x)
theorem exists_locally_finite_Union_eq_ball_radius_lt {Î± : Type u} [metric_space Î±] [proper_space Î±] {R : Î± â†’ â„} (hR : âˆ€ (x : Î±), 0 < R x) : âˆƒ (Î¹ : Type u) (c : Î¹ â†’ Î±) (r r' : Î¹ â†’ â„), (âˆ€ (i : Î¹), 0 < r i âˆ§ r i < r' i âˆ§ r' i < R (c i)) âˆ§ locally_finite (Î» (i : Î¹), metric.ball (c i) (r' i)) âˆ§ (â‹ƒ (i : Î¹), metric.ball (c i) (r i)) = set.univ
theorem sylow.card_quotient_normalizer_modeq_card_quotient {G : Type u} [group G] [fintype G] {p n : â„•} [hp : fact (nat.prime p)] {H : subgroup G} (hH : fintype.card â†¥H = p ^ n) : fintype.card (â†¥(H.normalizer) â§¸ subgroup.comap H.normalizer.subtype H) â‰¡ fintype.card (G â§¸ H) [MOD p]
theorem power_series.order_le {R : Type u_1} [semiring R] {Ï† : power_series R} (n : â„•) (h : â‡‘(power_series.coeff R n) Ï† â‰  0) : Ï†.order â‰¤ â†‘n
theorem mdifferentiable_within_at.differentiable_within_at {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {E' : Type u_3} [normed_group E'] [normed_space ğ•œ E'] {f : E â†’ E'} {s : set E} {x : E} : mdifferentiable_within_at (model_with_corners_self ğ•œ E) (model_with_corners_self ğ•œ E') f s x â†’ differentiable_within_at ğ•œ f s x
theorem complex.continuous_at_cpow_zero_of_re_pos {z : â„‚} (hz : 0 < z.re) : continuous_at (Î» (x : â„‚ Ã— â„‚), x.fst ^ x.snd) (0, z)
theorem add_submonoid.localization_map.lift_add_left {M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {N : Type u_2} [add_comm_monoid N] {P : Type u_3} [add_comm_monoid P] (f : S.localization_map N) {g : M â†’+ P} (hg : âˆ€ (y : â†¥S), is_add_unit (â‡‘g â†‘y)) (z : N) : â‡‘g â†‘((f.sec z).snd) + â‡‘(f.lift hg) z = â‡‘g (f.sec z).fst
theorem nat.prod_pow_factorization_eq_self {f : â„• â†’â‚€ â„•} (hf : âˆ€ (p : â„•), p âˆˆ f.support â†’ nat.prime p) : (f.prod has_pow.pow).factorization = f
theorem compact_std_simplex (Î¹ : Type u_1) [fintype Î¹] : is_compact (std_simplex â„ Î¹)
theorem Gromov_Hausdorff.HD_candidates_b_dist_le {X : Type u} {Y : Type v} [metric_space X] [compact_space X] [nonempty X] [metric_space Y] [compact_space Y] [nonempty Y] : Gromov_Hausdorff.HD (Gromov_Hausdorff.candidates_b_dist X Y) â‰¤ metric.diam set.univ + 1 + metric.diam set.univ
theorem category_theory.abelian.image.fac {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_kernels C] [category_theory.limits.has_cokernels C] {P Q : C} (f : P âŸ¶ Q) : category_theory.abelian.factor_thru_image f â‰« category_theory.abelian.image.Î¹ f = f
theorem not_bdd_above_iff' {Î± : Type u} [preorder Î±] {s : set Î±} : Â¬bdd_above s â†” âˆ€ (x : Î±), âˆƒ (y : Î±) (H : y âˆˆ s), Â¬y â‰¤ x
theorem pythagorean_triple_comm {x y z : â„¤} : pythagorean_triple x y z â†” pythagorean_triple y x z
theorem set.finite.dimH_zero {X : Type u_2} [emetric_space X] {s : set X} (hs : s.finite) : dimH s = 0
theorem is_dedekind_domain.inf_prime_pow_eq_prod {R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] {Î¹ : Type u_2} (s : finset Î¹) (f : Î¹ â†’ ideal R) (e : Î¹ â†’ â„•) (prime : âˆ€ (i : Î¹), i âˆˆ s â†’ _root_.prime (f i)) (coprime : âˆ€ (i : Î¹), i âˆˆ s â†’ âˆ€ (j : Î¹), j âˆˆ s â†’ i â‰  j â†’ f i â‰  f j) : s.inf (Î» (i : Î¹), f i ^ e i) = s.prod (Î» (i : Î¹), f i ^ e i)
theorem int.le_zpow_iff_clog_le {R : Type u_1} [linear_ordered_field R] [floor_ring R] {b : â„•} (hb : 1 < b) {x : â„¤} {r : R} (hr : 0 < r) : r â‰¤ â†‘b ^ x â†” int.clog b r â‰¤ x
theorem linear_map.is_Ortho.not_is_ortho_basis_self_of_separating_right {R : Type u_1} {M : Type u_5} {n : Type u_14} [comm_ring R] [add_comm_group M] [module R M] {I I' : R â†’+* R} [nontrivial R] {B : M â†’â‚›â‚—[I] M â†’â‚›â‚—[I'] R} {v : basis n R M} (h : B.is_Ortho â‡‘v) (hB : B.separating_right) (i : n) : Â¬B.is_ortho (â‡‘v i) (â‡‘v i)
theorem category_theory.presheaf.is_limit_iff_is_sheaf_for {C : Type uâ‚} [category_theory.category C] {A : Type uâ‚‚} [category_theory.category A] (P : Cáµ’áµ– â¥¤ A) {X : C} (S : category_theory.sieve X) : nonempty (category_theory.limits.is_limit (P.map_cone S.arrows.cocone.op)) â†” âˆ€ (E : Aáµ’áµ–), category_theory.presieve.is_sheaf_for (P â‹™ category_theory.coyoneda.obj E) â‡‘S
theorem unique_mdiff_on.unique_diff_on_target_inter {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {M : Type u_4} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {s : set M} (hs : unique_mdiff_on I s) (x : M) : unique_diff_on ğ•œ ((ext_chart_at I x).target âˆ© â‡‘((ext_chart_at I x).symm) â»Â¹' s)
theorem measure_theory.measure.le_map_apply {Î± : Type u_1} {Î² : Type u_2} {m0 : measurable_space Î±} [measurable_space Î²] {Î¼ : measure_theory.measure Î±} {f : Î± â†’ Î²} (hf : ae_measurable f Î¼) (s : set Î²) : â‡‘Î¼ (f â»Â¹' s) â‰¤ â‡‘(measure_theory.measure.map f Î¼) s
theorem gram_schmidt_pairwise_orthogonal (ğ•œ : Type u_1) {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {Î¹ : Type u_3} [linear_order Î¹] [order_bot Î¹] [locally_finite_order Î¹] [is_well_order Î¹ has_lt.lt] (f : Î¹ â†’ E) : pairwise (Î» (a b : Î¹), has_inner.inner (gram_schmidt ğ•œ f a) (gram_schmidt ğ•œ f b) = 0)
theorem convex.mem_Icc {ğ•œ : Type u_1} [linear_ordered_field ğ•œ] {x y : ğ•œ} (h : x â‰¤ y) {z : ğ•œ} : z âˆˆ set.Icc x y â†” âˆƒ (a b : ğ•œ), 0 â‰¤ a âˆ§ 0 â‰¤ b âˆ§ a + b = 1 âˆ§ a * x + b * y = z
theorem homology.ext {V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {A B C : V} (f : A âŸ¶ B) [category_theory.limits.has_image f] (g : B âŸ¶ C) [category_theory.limits.has_kernel g] (w : f â‰« g = 0) [category_theory.limits.has_cokernel (image_to_kernel f g w)] {D : V} {k k' : homology f g w âŸ¶ D} (p : homology.Ï€ f g w â‰« k = homology.Ï€ f g w â‰« k') : k = k'
theorem add_is_torsion.quotient_iff {G : Type u_1} {H : Type u_2} [add_group G] {N : add_subgroup G} [add_group H] {f : G â†’+ H} (hf : function.surjective â‡‘f) (hN : N = f.ker) (tN : add_monoid.is_torsion â†¥N) : add_monoid.is_torsion H â†” add_monoid.is_torsion G
theorem nat.le_induction {P : â„• â†’ Prop} {m : â„•} (h0 : P m) (h1 : âˆ€ (n : â„•), m â‰¤ n â†’ P n â†’ P (n + 1)) (n : â„•) : m â‰¤ n â†’ P n
theorem monovary.sum_comp_perm_smul_eq_sum_smul_iff {Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [linear_ordered_ring Î±] [linear_ordered_add_comm_group Î²] [module Î± Î²] [ordered_smul Î± Î²] {Ïƒ : equiv.perm Î¹} {f : Î¹ â†’ Î±} {g : Î¹ â†’ Î²} [fintype Î¹] (hfg : monovary f g) : finset.univ.sum (Î» (i : Î¹), f (â‡‘Ïƒ i) â€¢ g i) = finset.univ.sum (Î» (i : Î¹), f i â€¢ g i) â†” monovary (f âˆ˜ â‡‘Ïƒ) g
theorem euclidean_geometry.dist_orthogonal_projection_eq_zero_iff {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace â„ P} [nonempty â†¥s] [complete_space â†¥(s.direction)] {p : P} : has_dist.dist p â†‘(â‡‘(euclidean_geometry.orthogonal_projection s) p) = 0 â†” p âˆˆ s
theorem finset.subset_vsub {Î± : Type u_2} {Î² : Type u_3} [decidable_eq Î±] [has_vsub Î± Î²] {u : finset Î±} {s t : set Î²} : â†‘u âŠ† s -áµ¥ t â†’ (âˆƒ (s' t' : finset Î²), â†‘s' âŠ† s âˆ§ â†‘t' âŠ† t âˆ§ u âŠ† s' -áµ¥ t')
theorem monovary.sum_smul_comp_perm_le_sum_smul {Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [linear_ordered_ring Î±] [linear_ordered_add_comm_group Î²] [module Î± Î²] [ordered_smul Î± Î²] {Ïƒ : equiv.perm Î¹} {f : Î¹ â†’ Î±} {g : Î¹ â†’ Î²} [fintype Î¹] (hfg : monovary f g) : finset.univ.sum (Î» (i : Î¹), f i â€¢ g (â‡‘Ïƒ i)) â‰¤ finset.univ.sum (Î» (i : Î¹), f i â€¢ g i)
theorem exists_seq_of_forall_finset_exists {Î± : Type u_1} (P : Î± â†’ Prop) (r : Î± â†’ Î± â†’ Prop) (h : âˆ€ (s : finset Î±), (âˆ€ (x : Î±), x âˆˆ s â†’ P x) â†’ (âˆƒ (y : Î±), P y âˆ§ âˆ€ (x : Î±), x âˆˆ s â†’ r x y)) : âˆƒ (f : â„• â†’ Î±), (âˆ€ (n : â„•), P (f n)) âˆ§ âˆ€ (m n : â„•), m < n â†’ r (f m) (f n)
theorem measure_theory.measure.have_lebesgue_decomposition_of_finite_measure {Î± : Type u_1} {m : measurable_space Î±} {Î¼ Î½ : measure_theory.measure Î±} [measure_theory.is_finite_measure Î¼] [measure_theory.is_finite_measure Î½] : Î¼.have_lebesgue_decomposition Î½
theorem dense_Inter_of_open {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [baire_space Î±] [encodable Î²] {f : Î² â†’ set Î±} (ho : âˆ€ (s : Î²), is_open (f s)) (hd : âˆ€ (s : Î²), dense (f s)) : dense (â‹‚ (s : Î²), f s)
theorem orthonormal.rotation_eq_of_orientation_eq {V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) {bâ‚‚ : basis (fin 2) â„ V} (hbâ‚‚ : orthonormal â„ â‡‘bâ‚‚) (ho : b.orientation = bâ‚‚.orientation) (Î¸ : real.angle) : hb.rotation Î¸ = hbâ‚‚.rotation Î¸
theorem is_of_fin_order_neg_iff {G : Type u} [add_group G] {x : G} : is_of_fin_add_order (-x) â†” is_of_fin_add_order x
theorem generalized_continued_fraction.of_one_le_nth_part_denom {K : Type u_1} {v : K} {n : â„•} [linear_ordered_field K] [floor_ring K] {b : K} (nth_part_denom_eq : (generalized_continued_fraction.of v).partial_denominators.nth n = option.some b) : 1 â‰¤ b
theorem metric.continuous_inf_dist_pt {Î± : Type u} [pseudo_metric_space Î±] (s : set Î±) : continuous (Î» (x : Î±), metric.inf_dist x s)
theorem contracting_with.is_fixed_pt_fixed_point_iterate {Î± : Type u_1} [metric_space Î±] {K : nnreal} {f : Î± â†’ Î±} [nonempty Î±] [complete_space Î±] {n : â„•} (hf : contracting_with K f^[n]) : function.is_fixed_pt f (contracting_with.fixed_point f^[n] hf)
theorem orientation.oangle_eq_two_zsmul_oangle_sub_of_norm_eq_real {V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) {x y z : V} (hxyne : x â‰  y) (hxzne : x â‰  z) {r : â„} (hx : âˆ¥xâˆ¥ = r) (hy : âˆ¥yâˆ¥ = r) (hz : âˆ¥zâˆ¥ = r) : o.oangle y z = 2 â€¢ o.oangle (y - x) (z - x)
theorem orthonormal.two_zsmul_oangle_neg_self_left {V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) (x : V) : 2 â€¢ hb.oangle (-x) x = 0
theorem measurable.of_comap_le {Î± : Type u_1} {Î² : Type u_2} {mâ‚ : measurable_space Î±} {mâ‚‚ : measurable_space Î²} {f : Î± â†’ Î²} : measurable_space.comap f mâ‚‚ â‰¤ mâ‚ â†’ measurable f
theorem besicovitch.tau_package.mem_Union_up_to_last_step {Î± : Type u_1} [metric_space Î±] {Î² : Type u} [nonempty Î²] (p : besicovitch.tau_package Î² Î±) (x : Î²) : p.to_ball_package.c x âˆˆ p.Union_up_to p.last_step
theorem ring_hom.not_one_mem_ker {R : Type u} {S : Type v} [semiring R] [semiring S] [nontrivial S] (f : R â†’+* S) : 1 âˆ‰ f.ker
theorem finset.prod_subtype_eq_prod_filter {Î² : Type u} {Î± : Type v} {s : finset Î±} [comm_monoid Î²] (f : Î± â†’ Î²) {p : Î± â†’ Prop} [decidable_pred p] : (finset.subtype p s).prod (Î» (x : subtype p), f â†‘x) = (finset.filter p s).prod (Î» (x : Î±), f x)
theorem zero_lt.left.mul_nonneg {Î± : Type u} {a b : Î±} [mul_zero_class Î±] [partial_order Î±] [zero_lt.pos_mul_mono Î±] (ha : 0 â‰¤ a) (hb : 0 â‰¤ b) : 0 â‰¤ a * b
theorem Top.open_embedding_of_pullback_open_embeddings {X Y S : Top} {f : X âŸ¶ S} {g : Y âŸ¶ S} (Hâ‚ : open_embedding â‡‘f) (Hâ‚‚ : open_embedding â‡‘g) : open_embedding â‡‘(category_theory.limits.limit.Ï€ (category_theory.limits.cospan f g) category_theory.limits.walking_cospan.one)
theorem affine_subspace.sup_direction_le {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] (s1 s2 : affine_subspace k P) : s1.direction âŠ” s2.direction â‰¤ (s1 âŠ” s2).direction
theorem ideal.quotient.maximal_of_is_field {R : Type u} [comm_ring R] (I : ideal R) (hqf : is_field (R â§¸ I)) : I.is_maximal
theorem differentiable.analytic_at {E : Type u} [normed_group E] [normed_space â„‚ E] [complete_space E] {f : â„‚ â†’ E} (hf : differentiable â„‚ f) (z : â„‚) : analytic_at â„‚ f z
theorem is_preconnected.bUnion_of_refl_trans_gen {Î± : Type u} [topological_space Î±] {Î¹ : Type u_1} {t : set Î¹} {s : Î¹ â†’ set Î±} (H : âˆ€ (i : Î¹), i âˆˆ t â†’ is_preconnected (s i)) (K : âˆ€ (i : Î¹), i âˆˆ t â†’ âˆ€ (j : Î¹), j âˆˆ t â†’ relation.refl_trans_gen (Î» (i j : Î¹), (s i âˆ© s j).nonempty âˆ§ i âˆˆ t) i j) : is_preconnected (â‹ƒ (n : Î¹) (H : n âˆˆ t), s n)
theorem smul_comm_class.symm (M : Type u_1) (N : Type u_2) (Î± : Type u_3) [has_scalar M Î±] [has_scalar N Î±] [smul_comm_class M N Î±] : smul_comm_class N M Î±
theorem bdd_above.continuous_convolution_right_of_integrable {ğ•œ : Type u_1} {G : Type u_2} {E : Type u_3} {E' : Type u_4} {F : Type u_6} [normed_group E] [normed_group E'] [normed_group F] {f : G â†’ E} {g : G â†’ E'} [nondiscrete_normed_field ğ•œ] [normed_space ğ•œ E] [normed_space ğ•œ E'] [normed_space ğ•œ F] (L : E â†’L[ğ•œ] E' â†’L[ğ•œ] F) [measurable_space G] {Î¼ : measure_theory.measure G} [normed_space â„ F] [complete_space F] [add_group G] [topological_space G] [topological_add_group G] [borel_space G] [topological_space.second_countable_topology G] (hbg : bdd_above (set.range (Î» (x : G), âˆ¥g xâˆ¥))) (hf : measure_theory.integrable f Î¼) (hg : continuous g) : continuous (convolution f g L Î¼)
theorem fixing_submonoid_Union (M : Type u_1) (Î± : Type u_2) [monoid M] [mul_action M Î±] {Î¹ : Sort u_3} {s : Î¹ â†’ set Î±} : fixing_submonoid M (â‹ƒ (i : Î¹), s i) = â¨… (i : Î¹), fixing_submonoid M (s i)
theorem besicovitch.is_empty_satellite_config_multiplicity (E : Type u_1) [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] : is_empty (besicovitch.satellite_config E (besicovitch.multiplicity E) (besicovitch.good_Ï„ E))
theorem formal_multilinear_series.comp_partial_sum_target_tendsto_at_top  : filter.tendsto (Î» (N : â„•), formal_multilinear_series.comp_partial_sum_target 0 N N) filter.at_top filter.at_top
theorem cont_diff_at_succ_iff_has_fderiv_at {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {f : E â†’ F} {x : E} {n : â„•} : cont_diff_at ğ•œ â†‘(n + 1) f x â†” âˆƒ (f' : E â†’ (E â†’L[ğ•œ] F)), (âˆƒ (u : set E) (H : u âˆˆ nhds x), âˆ€ (x : E), x âˆˆ u â†’ has_fderiv_at f (f' x) x) âˆ§ cont_diff_at ğ•œ â†‘n f' x
theorem algebra.finite_type.of_finite_presentation {R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] : algebra.finite_presentation R A â†’ algebra.finite_type R A
theorem finset.weighted_vsub_of_point_eq_of_weights_eq {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {Î¹ : Type u_4} (s : finset Î¹) (p : Î¹ â†’ P) (j : Î¹) (wâ‚ wâ‚‚ : Î¹ â†’ k) (hw : âˆ€ (i : Î¹), i â‰  j â†’ wâ‚ i = wâ‚‚ i) : â‡‘(s.weighted_vsub_of_point p (p j)) wâ‚ = â‡‘(s.weighted_vsub_of_point p (p j)) wâ‚‚
theorem fin.coe_fin_lt {n : â„•} {a b : fin n} : â†‘a < â†‘b â†” a < b
theorem subgroup.closure_le {G : Type u_1} [group G] (K : subgroup G) {k : set G} : subgroup.closure k â‰¤ K â†” k âŠ† â†‘K
theorem zsmul_eq_zsmul_iff' {Î± : Type u_1} [linear_ordered_add_comm_group Î±] {n : â„¤} {a b : Î±} (hn : n â‰  0) : n â€¢ a = n â€¢ b â†” a = b
theorem padic_norm.div (p : â„•) [hp : fact (nat.prime p)] (q r : â„š) : padic_norm p (q / r) = padic_norm p q / padic_norm p r
theorem interval_integral.deriv_integral_of_tendsto_ae_left {E : Type u_3} [normed_group E] [complete_space E] [normed_space â„ E] {f : â„ â†’ E} {c : E} {a b : â„} (hf : interval_integrable f measure_theory.measure_space.volume a b) (hmeas : strongly_measurable_at_filter f (nhds a) measure_theory.measure_space.volume) (hb : filter.tendsto f (nhds a âŠ“ measure_theory.measure_space.volume.ae) (nhds c)) : deriv (Î» (u : â„), âˆ« (x : â„) in u..b, f x) a = -c
theorem is_add_monoid_hom.is_add_monoid_hom_mul_right {Î³ : Type u_1} [non_unital_non_assoc_semiring Î³] (x : Î³) : is_add_monoid_hom (Î» (y : Î³), y * x)
theorem is_localization.map_comp_map {R : Type u_1} [comm_semiring R] {M : submonoid R} {S : Type u_2} [comm_semiring S] [algebra R S] {P : Type u_3} [comm_semiring P] [is_localization M S] {g : R â†’+* P} {T : submonoid P} {Q : Type u_4} [comm_semiring Q] (hy : M â‰¤ submonoid.comap â†‘g T) [algebra P Q] [is_localization T Q] {A : Type u_5} [comm_semiring A] {U : submonoid A} {W : Type u_6} [comm_semiring W] [algebra A W] [is_localization U W] {l : P â†’+* A} (hl : T â‰¤ submonoid.comap â†‘l U) : (is_localization.map W l hl).comp (is_localization.map Q g hy) = is_localization.map W (l.comp g) _
theorem continuous_on.ae_strongly_measurable {Î± : Type u_1} {Î² : Type u_2} [measurable_space Î±] [topological_space Î±] [topological_space Î²] [h : second_countable_topology_either Î± Î²] [opens_measurable_space Î±] [topological_space.pseudo_metrizable_space Î²] {f : Î± â†’ Î²} {s : set Î±} {Î¼ : measure_theory.measure Î±} (hf : continuous_on f s) (hs : measurable_set s) : measure_theory.ae_strongly_measurable f (Î¼.restrict s)
theorem category_theory.grothendieck_topology.is_closed_pullback {C : Type u} [category_theory.category C] (Jâ‚ : category_theory.grothendieck_topology C) {X Y : C} (f : Y âŸ¶ X) (S : category_theory.sieve X) : Jâ‚.is_closed S â†’ Jâ‚.is_closed (category_theory.sieve.pullback f S)
theorem linear_map.map_span_le {R : Type u_1} {Râ‚‚ : Type u_2} {M : Type u_4} {Mâ‚‚ : Type u_5} [semiring R] [add_comm_monoid M] [module R M] [semiring Râ‚‚] {Ïƒâ‚â‚‚ : R â†’+* Râ‚‚} [add_comm_monoid Mâ‚‚] [module Râ‚‚ Mâ‚‚] [ring_hom_surjective Ïƒâ‚â‚‚] (f : M â†’â‚›â‚—[Ïƒâ‚â‚‚] Mâ‚‚) (s : set M) (N : submodule Râ‚‚ Mâ‚‚) : submodule.map f (submodule.span R s) â‰¤ N â†” âˆ€ (m : M), m âˆˆ s â†’ â‡‘f m âˆˆ N
theorem submonoid.closure_inductionâ‚‚ {M : Type u_1} [mul_one_class M] {s : set M} {p : M â†’ M â†’ Prop} {x y : M} (hx : x âˆˆ submonoid.closure s) (hy : y âˆˆ submonoid.closure s) (Hs : âˆ€ (x : M), x âˆˆ s â†’ âˆ€ (y : M), y âˆˆ s â†’ p x y) (H1_left : âˆ€ (x : M), p 1 x) (H1_right : âˆ€ (x : M), p x 1) (Hmul_left : âˆ€ (x y z : M), p x z â†’ p y z â†’ p (x * y) z) (Hmul_right : âˆ€ (x y z : M), p z x â†’ p z y â†’ p z (x * y)) : p x y
theorem comp_smul_left (M : Type u_1) {Î± : Type u_6} [monoid M] [mul_action M Î±] (aâ‚ aâ‚‚ : M) : has_scalar.smul aâ‚ âˆ˜ has_scalar.smul aâ‚‚ = has_scalar.smul (aâ‚ * aâ‚‚)
theorem subring.neg_mem {R : Type u} [ring R] (s : subring R) {x : R} : x âˆˆ s â†’ -x âˆˆ s
theorem has_le.le.lt_or_eq {Î± : Type u} [partial_order Î±] {a b : Î±} : a â‰¤ b â†’ a < b âˆ¨ a = b
theorem unique_diff_on_Icc_zero_one  : unique_diff_on â„ (set.Icc 0 1)
theorem strict_concave_on.inf {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [ordered_semiring ğ•œ] [add_comm_monoid E] [linear_ordered_add_comm_monoid Î²] [has_scalar ğ•œ E] [module ğ•œ Î²] [ordered_smul ğ•œ Î²] {s : set E} {f g : E â†’ Î²} (hf : strict_concave_on ğ•œ s f) (hg : strict_concave_on ğ•œ s g) : strict_concave_on ğ•œ s (f âŠ“ g)
theorem has_fpower_series_on_ball.tendsto_uniformly_on' {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field ğ•œ] [normed_group E] [normed_space ğ•œ E] [normed_group F] [normed_space ğ•œ F] {f : E â†’ F} {p : formal_multilinear_series ğ•œ E F} {x : E} {r : ennreal} {r' : nnreal} (hf : has_fpower_series_on_ball f p x r) (h : â†‘r' < r) : tendsto_uniformly_on (Î» (n : â„•) (y : E), p.partial_sum n (y - x)) f filter.at_top (metric.ball x â†‘r')
theorem linear_independent_le_infinite_basis {R : Type u} [ring R] [strong_rank_condition R] {M : Type v} [add_comm_group M] [module R M] {Î¹ : Type u_1} (b : basis Î¹ R M) [infinite Î¹] {Îº : Type u_1} (v : Îº â†’ M) (i : linear_independent R v) : cardinal.mk Îº â‰¤ cardinal.mk Î¹
theorem exists_Ioo_extr_on_Icc (f : â„ â†’ â„) {a b : â„} (hab : a < b) (hfc : continuous_on f (set.Icc a b)) (hfI : f a = f b) : âˆƒ (c : â„) (H : c âˆˆ set.Ioo a b), is_extr_on f (set.Icc a b) c
theorem has_fderiv_at_exp_of_mem_ball {ğ•‚ : Type u_1} {ğ”¸ : Type u_2} [nondiscrete_normed_field ğ•‚] [normed_comm_ring ğ”¸] [normed_algebra ğ•‚ ğ”¸] [complete_space ğ”¸] [char_zero ğ•‚] {x : ğ”¸} (hx : x âˆˆ emetric.ball 0 (exp_series ğ•‚ ğ”¸).radius) : has_fderiv_at (exp ğ•‚) (exp ğ•‚ x â€¢ 1) x
theorem smul_add_smul_lt_smul_add_smul' {k : Type u_1} {M : Type u_2} [ordered_ring k] [ordered_add_comm_group M] [module k M] [ordered_smul k M] [covariant_class M M has_add.add has_lt.lt] [contravariant_class M M has_add.add has_lt.lt] {a b : k} {c d : M} (hba : b < a) (hdc : d < c) : a â€¢ d + b â€¢ c < a â€¢ c + b â€¢ d
theorem eckmann_hilton.mul_comm {X : Type u} {mâ‚ mâ‚‚ : X â†’ X â†’ X} {eâ‚ eâ‚‚ : X} (hâ‚ : eckmann_hilton.is_unital mâ‚ eâ‚) (hâ‚‚ : eckmann_hilton.is_unital mâ‚‚ eâ‚‚) (distrib : âˆ€ (a b c d : X), mâ‚ (mâ‚‚ a b) (mâ‚‚ c d) = mâ‚‚ (mâ‚ a c) (mâ‚ b d)) : is_commutative X mâ‚‚
theorem asymptotics.is_O_with.of_norm_left {Î± : Type u_1} {F : Type u_4} {E' : Type u_6} [has_norm F] [semi_normed_group E'] {c : â„} {g : Î± â†’ F} {f' : Î± â†’ E'} {l : filter Î±} : asymptotics.is_O_with c l (Î» (x : Î±), âˆ¥f' xâˆ¥) g â†’ asymptotics.is_O_with c l f' g
theorem polynomial.induction_on' {R : Type u} [semiring R] {M : polynomial R â†’ Prop} (p : polynomial R) (h_add : âˆ€ (p q : polynomial R), M p â†’ M q â†’ M (p + q)) (h_monomial : âˆ€ (n : â„•) (a : R), M (â‡‘(polynomial.monomial n) a)) : M p
theorem real.has_strict_deriv_at_const_rpow_of_neg {a x : â„} (ha : a < 0) : has_strict_deriv_at (Î» (x : â„), a ^ x) (a ^ x * real.log a - real.exp (real.log a * x) * real.sin (x * real.pi) * real.pi) x
theorem continuous_map.continuous_eval_const' {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] [locally_compact_space Î±] (a : Î±) : continuous (Î» (f : C(Î±, Î²)), â‡‘f a)
theorem countable_of_isolated_left {Î± : Type u} [topological_space Î±] [linear_order Î±] [order_topology Î±] [topological_space.second_countable_topology Î±] : {x : Î± | âˆƒ (y : Î±), y < x âˆ§ set.Ioo y x = âˆ…}.countable
theorem range_circle_map (c : â„‚) (R : â„) : set.range (circle_map c R) = metric.sphere c |R|
theorem multilinear_map.map_add_univ {R : Type u} {Î¹ : Type u'} {Mâ‚ : Î¹ â†’ Type vâ‚} {Mâ‚‚ : Type vâ‚‚} [decidable_eq Î¹] [semiring R] [Î  (i : Î¹), add_comm_monoid (Mâ‚ i)] [add_comm_monoid Mâ‚‚] [Î  (i : Î¹), module R (Mâ‚ i)] [module R Mâ‚‚] (f : multilinear_map R Mâ‚ Mâ‚‚) [fintype Î¹] (m m' : Î  (i : Î¹), Mâ‚ i) : â‡‘f (m + m') = finset.univ.sum (Î» (s : finset Î¹), â‡‘f (s.piecewise m m'))
theorem interval_integral.integral_eq_sub_of_has_deriv_right_of_le {E : Type u_3} [normed_group E] [complete_space E] [normed_space â„ E] {f : â„ â†’ E} {a b : â„} {f' : â„ â†’ E} (hab : a â‰¤ b) (hcont : continuous_on f (set.Icc a b)) (hderiv : âˆ€ (x : â„), x âˆˆ set.Ioo a b â†’ has_deriv_within_at f (f' x) (set.Ioi x) x) (f'int : interval_integrable f' measure_theory.measure_space.volume a b) : âˆ« (y : â„) in a..b, f' y = f b - f a
theorem measure_theory.measure.is_haar_measure_of_is_compact_nonempty_interior {G : Type u_1} [measurable_space G] [group G] [topological_space G] [topological_group G] [borel_space G] (Î¼ : measure_theory.measure G) [Î¼.is_mul_left_invariant] (K : set G) (hK : is_compact K) (h'K : (interior K).nonempty) (h : â‡‘Î¼ K â‰  0) (h' : â‡‘Î¼ K â‰  âŠ¤) : Î¼.is_haar_measure
theorem tsum_Union_decodeâ‚‚ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [add_comm_monoid Î±] [topological_space Î±] [t2_space Î±] [encodable Î³] (m : set Î² â†’ Î±) (m0 : m âˆ… = 0) (s : Î³ â†’ set Î²) : âˆ‘' (i : â„•), m (â‹ƒ (b : Î³) (H : b âˆˆ encodable.decodeâ‚‚ Î³ i), s b) = âˆ‘' (b : Î³), m (s b)
theorem finite_dimensional.of_injective {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {Vâ‚‚ : Type v'} [add_comm_group Vâ‚‚] [module K Vâ‚‚] (f : V â†’â‚—[K] Vâ‚‚) (w : function.injective â‡‘f) [finite_dimensional K Vâ‚‚] : finite_dimensional K V
theorem finsum_mem_Union {Î± : Type u_1} {Î¹ : Type u_3} {M : Type u_5} [add_comm_monoid M] {f : Î± â†’ M} [fintype Î¹] {t : Î¹ â†’ set Î±} (h : pairwise (disjoint on t)) (ht : âˆ€ (i : Î¹), (t i).finite) : finsum (Î» (a : Î±), finsum (Î» (H : a âˆˆ â‹ƒ (i : Î¹), t i), f a)) = finsum (Î» (i : Î¹), finsum (Î» (a : Î±), finsum (Î» (H : a âˆˆ t i), f a)))
theorem concave_on_of_slope_anti_adjacent {ğ•œ : Type u_1} [linear_ordered_field ğ•œ] {s : set ğ•œ} {f : ğ•œ â†’ ğ•œ} (hs : convex ğ•œ s) (hf : âˆ€ {x y z : ğ•œ}, x âˆˆ s â†’ z âˆˆ s â†’ x < y â†’ y < z â†’ (f z - f y) / (z - y) â‰¤ (f y - f x) / (y - x)) : concave_on ğ•œ s f
theorem measurable_set.nhds_within_is_measurably_generated {Î± : Type u_1} [topological_space Î±] [measurable_space Î±] [opens_measurable_space Î±] {s : set Î±} (hs : measurable_set s) (a : Î±) : (nhds_within a s).is_measurably_generated
theorem equiv.add_left_symm_apply {G : Type u_10} [add_group G] (a : G) : â‡‘(equiv.symm (equiv.add_left a)) = has_add.add (-a)
theorem category_theory.limits.mono_of_is_limit_parallel_family {J : Type v} {C : Type u} [category_theory.category C] {X Y : C} {f : J â†’ (X âŸ¶ Y)} [nonempty J] {c : category_theory.limits.cone (category_theory.limits.parallel_family f)} (i : category_theory.limits.is_limit c) : category_theory.mono (category_theory.limits.trident.Î¹ c)
theorem direct_sum.of_smul (R : Type u) [semiring R] {Î¹ : Type v} [dec_Î¹ : decidable_eq Î¹] {M : Î¹ â†’ Type w} [Î  (i : Î¹), add_comm_monoid (M i)] [Î  (i : Î¹), module R (M i)] (i : Î¹) (c : R) (x : M i) : â‡‘(direct_sum.of M i) (c â€¢ x) = c â€¢ â‡‘(direct_sum.of M i) x
theorem multilinear_map.continuous_of_bound {ğ•œ : Type u} {Î¹ : Type v} {E : Î¹ â†’ Type wE} {G : Type wG} [decidable_eq Î¹] [fintype Î¹] [nondiscrete_normed_field ğ•œ] [Î  (i : Î¹), normed_group (E i)] [Î  (i : Î¹), normed_space ğ•œ (E i)] [normed_group G] [normed_space ğ•œ G] (f : multilinear_map ğ•œ E G) (C : â„) (H : âˆ€ (m : Î  (i : Î¹), E i), âˆ¥â‡‘f mâˆ¥ â‰¤ C * finset.univ.prod (Î» (i : Î¹), âˆ¥m iâˆ¥)) : continuous â‡‘f
theorem category_theory.is_iso_of_fully_faithful {C : Type uâ‚} [category_theory.category C] {D : Type uâ‚‚} [category_theory.category D] (F : C â¥¤ D) [category_theory.full F] [category_theory.faithful F] {X Y : C} (f : X âŸ¶ Y) [category_theory.is_iso (F.map f)] : category_theory.is_iso f
theorem measure_theory.integral_eq_of_has_deriv_within_at_off_countable {E : Type u} [normed_group E] [normed_space â„ E] [complete_space E] (f f' : â„ â†’ E) {a b : â„} {s : set â„} (hs : s.countable) (Hc : continuous_on f (set.interval a b)) (Hd : âˆ€ (x : â„), x âˆˆ set.Ioo (linear_order.min a b) (linear_order.max a b)  s â†’ has_deriv_at f (f' x) x) (Hi : interval_integrable f' measure_theory.measure_space.volume a b) : âˆ« (x : â„) in a..b, f' x = f b - f a
theorem list.join_split_wrt_composition {Î± : Type u_1} (l : list Î±) (c : composition l.length) : (l.split_wrt_composition c).join = l
theorem convex_on_univ_of_deriv2_nonneg {f : â„ â†’ â„} (hf' : differentiable â„ f) (hf'' : differentiable â„ (deriv f)) (hf''_nonneg : âˆ€ (x : â„), 0 â‰¤ deriv^[2] f x) : convex_on â„ set.univ f
theorem continuous_on.comp_fract'' {Î± : Type u_1} {Î² : Type u_2} [linear_ordered_ring Î±] [floor_ring Î±] [topological_space Î±] [order_topology Î±] [topological_add_group Î±] [topological_space Î²] {f : Î± â†’ Î²} (h : continuous_on f (set.Icc 0 1)) (hf : f 0 = f 1) : continuous (f âˆ˜ int.fract)
theorem strict_convex_on_of_deriv2_pos {D : set â„} (hD : convex â„ D) {f : â„ â†’ â„} (hf : continuous_on f D) (hf' : differentiable_on â„ f (interior D)) (hf'' : âˆ€ (x : â„), x âˆˆ interior D â†’ 0 < deriv^[2] f x) : strict_convex_on â„ D f
theorem order.lt_of_pred_lt_pred {Î± : Type u_1} [preorder Î±] [pred_order Î±] {a b : Î±} [no_min_order Î±] : order.pred a < order.pred b â†’ a < b
theorem mul_dvd_mul_iff_left {Î± : Type u_1} [cancel_monoid_with_zero Î±] {a b c : Î±} (ha : a â‰  0) : a * b âˆ£ a * c â†” b âˆ£ c
theorem minpoly.eq_of_algebra_map_eq {K : Type u_1} {S : Type u_2} {T : Type u_3} [field K] [comm_ring S] [comm_ring T] [algebra K S] [algebra K T] [algebra S T] [is_scalar_tower K S T] (hST : function.injective â‡‘(algebra_map S T)) {x : S} {y : T} (hx : is_integral K x) (h : y = â‡‘(algebra_map S T) x) : minpoly K x = minpoly K y
theorem vadd_comm_class.symm (M : Type u_1) (N : Type u_2) (Î± : Type u_3) [has_vadd M Î±] [has_vadd N Î±] [vadd_comm_class M N Î±] : vadd_comm_class N M Î±
theorem pi.nontrivial_at {I : Type u_3} {f : I â†’ Type u_4} (i' : I) [inst : âˆ€ (i : I), nonempty (f i)] [nontrivial (f i')] : nontrivial (Î  (i : I), f i)
theorem direct_sum.coe_to_module_eq_coe_to_add_monoid (R : Type u) [semiring R] (Î¹ : Type v) [dec_Î¹ : decidable_eq Î¹] {M : Î¹ â†’ Type w} [Î  (i : Î¹), add_comm_monoid (M i)] [Î  (i : Î¹), module R (M i)] (N : Type uâ‚) [add_comm_monoid N] [module R N] (Ï† : Î  (i : Î¹), M i â†’â‚—[R] N) : â‡‘(direct_sum.to_module R Î¹ N Ï†) = â‡‘(direct_sum.to_add_monoid (Î» (i : Î¹), (Ï† i).to_add_monoid_hom))
theorem homeomorph.is_O_with_congr {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] {E : Type u_3} [has_norm E] {F : Type u_4} [has_norm F] (e : Î± â‰ƒâ‚œ Î²) {b : Î²} {f : Î² â†’ E} {g : Î² â†’ F} {C : â„} : asymptotics.is_O_with C (nhds b) f g â†” asymptotics.is_O_with C (nhds (â‡‘(e.symm) b)) (f âˆ˜ â‡‘e) (g âˆ˜ â‡‘e)
theorem field.exists_primitive_element (F : Type u_1) (E : Type u_2) [field F] [field E] [algebra F E] [finite_dimensional F E] [is_separable F E] : âˆƒ (Î± : E), FâŸ®Î±âŸ¯ = âŠ¤
theorem linear_ordered_comm_group_with_zero.nhds_coe_units {Î“â‚€ : Type u_1} [linear_ordered_comm_group_with_zero Î“â‚€] (Î³ : Î“â‚€Ë£) : nhds â†‘Î³ = has_pure.pure â†‘Î³
theorem finset.property_of_mem_map_subtype {Î± : Type u_1} {p : Î± â†’ Prop} (s : finset {x // p x}) {a : Î±} (h : a âˆˆ finset.map (function.embedding.subtype (Î» (x : Î±), p x)) s) : p a
theorem category_theory.functor.ext {C : Type uâ‚} [category_theory.category C] {D : Type uâ‚‚} [category_theory.category D] {F G : C â¥¤ D} (h_obj : âˆ€ (X : C), F.obj X = G.obj X) (h_map : âˆ€ (X Y : C) (f : X âŸ¶ Y), F.map f = category_theory.eq_to_hom _ â‰« G.map f â‰« category_theory.eq_to_hom _) : F = G
theorem set.maps_to.closure {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] {s : set Î±} {t : set Î²} {f : Î± â†’ Î²} (h : set.maps_to f s t) (hc : continuous f) : set.maps_to f (closure s) (closure t)
theorem normed_space.to_locally_convex_space' (ğ•œ : Type u_1) {E : Type u_2} [normed_field ğ•œ] [normed_space â„ ğ•œ] [semi_normed_group E] [normed_space ğ•œ E] [module â„ E] [is_scalar_tower â„ ğ•œ E] : locally_convex_space â„ E
theorem exists_lt_subset_ball {Î± : Type u} [pseudo_metric_space Î±] [proper_space Î±] {x : Î±} {r : â„} {s : set Î±} (hs : is_closed s) (h : s âŠ† metric.ball x r) : âˆƒ (r' : â„) (H : r' < r), s âŠ† metric.ball x r'
theorem continuous_map.homotopy.continuous {X : Type u} {Y : Type v} [topological_space X] [topological_space Y] {fâ‚€ fâ‚ : C(X, Y)} (F : fâ‚€.homotopy fâ‚) : continuous â‡‘F
theorem exists_subset_nhd_of_compact' {Î± : Type u} [topological_space Î±] {Î¹ : Type u_1} [nonempty Î¹] {V : Î¹ â†’ set Î±} (hV : directed superset V) (hV_cpct : âˆ€ (i : Î¹), is_compact (V i)) (hV_closed : âˆ€ (i : Î¹), is_closed (V i)) {U : set Î±} (hU : âˆ€ (x : Î±), (x âˆˆ â‹‚ (i : Î¹), V i) â†’ U âˆˆ nhds x) : âˆƒ (i : Î¹), V i âŠ† U
theorem topological_space.metrizable_space_of_regular_second_countable (X : Type u_2) [topological_space X] [regular_space X] [topological_space.second_countable_topology X] : topological_space.metrizable_space X
theorem is_dedekind_domain.height_one_spectrum.int_valuation.map_add_le_max' {R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] (v : is_dedekind_domain.height_one_spectrum R) (x y : R) : v.int_valuation_def (x + y) â‰¤ linear_order.max (v.int_valuation_def x) (v.int_valuation_def y)
theorem subsemigroup.ext {M : Type u_1} [has_mul M] {S T : subsemigroup M} (h : âˆ€ (x : M), x âˆˆ S â†” x âˆˆ T) : S = T
theorem set.pairwise_disjoint.countable_of_is_open {Î± : Type u} [t : topological_space Î±] [topological_space.separable_space Î±] {Î¹ : Type u_1} {s : Î¹ â†’ set Î±} {a : set Î¹} (h : a.pairwise_disjoint s) (ha : âˆ€ (i : Î¹), i âˆˆ a â†’ is_open (s i)) (h'a : âˆ€ (i : Î¹), i âˆˆ a â†’ (s i).nonempty) : a.countable
theorem category_theory.is_pullback.of_has_pullback {C : Type uâ‚} [category_theory.category C] {X Y Z : C} (f : X âŸ¶ Z) (g : Y âŸ¶ Z) [category_theory.limits.has_pullback f g] : category_theory.is_pullback category_theory.limits.pullback.fst category_theory.limits.pullback.snd f g
theorem function.is_periodic_pt.eq_of_apply_eq {Î± : Type u_1} {f : Î± â†’ Î±} {x y : Î±} {m n : â„•} (hx : function.is_periodic_pt f m x) (hy : function.is_periodic_pt f n y) (hm : 0 < m) (hn : 0 < n) (h : f x = f y) : x = y
theorem is_unit.dvd_mul_left {Î± : Type u_1} [comm_monoid Î±] (a b u : Î±) (hu : is_unit u) : a âˆ£ u * b â†” a âˆ£ b
theorem add_semiconj_by.add_units_neg_symm_left {M : Type u} [add_monoid M] {a : add_units M} {x y : M} (h : add_semiconj_by â†‘a x y) : add_semiconj_by (â†‘-a) y x
theorem zero_lt.preorder.left.one_le_mul_of_le_of_le {Î± : Type u} {a b : Î±} [mul_one_class Î±] [has_zero Î±] [preorder Î±] [zero_lt.pos_mul_mono Î±] (ha : 1 â‰¤ a) (hb : 1 â‰¤ b) (a0 : 0 < a) : 1 â‰¤ a * b
theorem is_cyclotomic_extension.discr_prime_pow_ne_two' {p : â„•+} {k : â„•} {K : Type u} {L : Type v} {Î¶ : L} [field K] [field L] [algebra K L] [is_cyclotomic_extension {p ^ (k + 1)} K L] [hp : fact (nat.prime â†‘p)] [ne_zero â†‘â†‘p] (hÎ¶ : is_primitive_root Î¶ â†‘(p ^ (k + 1))) (hirr : irreducible (polynomial.cyclotomic â†‘(p ^ (k + 1)) K)) (hk : p ^ (k + 1) â‰  2) : algebra.discr K â‡‘((is_primitive_root.power_basis K hÎ¶).basis) = (-1) ^ (â†‘p ^ k * (â†‘p - 1) / 2) * â†‘p ^ (â†‘p ^ k * ((â†‘p - 1) * (k + 1) - 1))
theorem generalized_continued_fraction.int_fract_pair.succ_nth_stream_b_le_nth_stream_fr_inv {K : Type u_1} {v : K} {n : â„•} [linear_ordered_field K] [floor_ring K] {ifp_n ifp_succ_n : generalized_continued_fraction.int_fract_pair K} (nth_stream_eq : generalized_continued_fraction.int_fract_pair.stream v n = option.some ifp_n) (succ_nth_stream_eq : generalized_continued_fraction.int_fract_pair.stream v (n + 1) = option.some ifp_succ_n) : â†‘(ifp_succ_n.b) â‰¤ (ifp_n.fr)â»Â¹
theorem padic_val_rat.of_int_multiplicity {p : â„•} (z : â„¤) (hp : p â‰  1) (hz : z â‰  0) : padic_val_rat p â†‘z = â†‘((multiplicity â†‘p z).get _)
theorem relation.game_add_le_lex {Î± : Type u_1} {Î² : Type u_2} (rÎ± : Î± â†’ Î± â†’ Prop) (rÎ² : Î² â†’ Î² â†’ Prop) : relation.game_add rÎ± rÎ² â‰¤ prod.lex rÎ± rÎ²
theorem dense.inter_of_open_left {Î± : Type u} [topological_space Î±] {s t : set Î±} (hs : dense s) (ht : dense t) (hso : is_open s) : dense (s âˆ© t)
theorem image_norm_le_of_norm_deriv_right_le_deriv_boundary' {E : Type u_1} [normed_group E] [normed_space â„ E] {f : â„ â†’ E} {a b : â„} {f' : â„ â†’ E} (hf : continuous_on f (set.Icc a b)) (hf' : âˆ€ (x : â„), x âˆˆ set.Ico a b â†’ has_deriv_within_at f (f' x) (set.Ici x) x) {B B' : â„ â†’ â„} (ha : âˆ¥f aâˆ¥ â‰¤ B a) (hB : continuous_on B (set.Icc a b)) (hB' : âˆ€ (x : â„), x âˆˆ set.Ico a b â†’ has_deriv_within_at B (B' x) (set.Ici x) x) (bound : âˆ€ (x : â„), x âˆˆ set.Ico a b â†’ âˆ¥f' xâˆ¥ â‰¤ B' x) â¦ƒx : â„â¦„ : x âˆˆ set.Icc a b â†’ âˆ¥f xâˆ¥ â‰¤ B x
theorem affine.triangle.orthocenter_eq_of_range_eq {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {tâ‚ tâ‚‚ : affine.triangle â„ P} (h : set.range tâ‚.points = set.range tâ‚‚.points) : tâ‚.orthocenter = tâ‚‚.orthocenter
theorem orthonormal.oangle_eq_of_orientation_eq {V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) {bâ‚‚ : basis (fin 2) â„ V} (hbâ‚‚ : orthonormal â„ â‡‘bâ‚‚) (ho : b.orientation = bâ‚‚.orientation) (x y : V) : hb.oangle x y = hbâ‚‚.oangle x y
theorem is_smul_regular.pow_iff {R : Type u_1} {M : Type u_3} {a : R} [monoid R] [mul_action R M] {n : â„•} (n0 : 0 < n) : is_smul_regular M (a ^ n) â†” is_smul_regular M a
theorem dist_le_of_le_geometric_of_tendsto {Î± : Type u_1} [pseudo_metric_space Î±] (r C : â„) (hr : r < 1) {f : â„• â†’ Î±} (hu : âˆ€ (n : â„•), has_dist.dist (f n) (f (n + 1)) â‰¤ C * r ^ n) {a : Î±} (ha : filter.tendsto f filter.at_top (nhds a)) (n : â„•) : has_dist.dist (f n) a â‰¤ C * r ^ n / (1 - r)
theorem polynomial.sum_taylor_eq {R : Type u_1} [comm_ring R] (f : polynomial R) (r : R) : (â‡‘(polynomial.taylor r) f).sum (Î» (i : â„•) (a : R), â‡‘polynomial.C a * (polynomial.X - â‡‘polynomial.C r) ^ i) = f
theorem measure_theory.forall_measure_preimage_add_iff {G : Type u_1} [measurable_space G] [has_add G] [has_measurable_add G] (Î¼ : measure_theory.measure G) : (âˆ€ (g : G) (A : set G), measurable_set A â†’ â‡‘Î¼ ((Î» (h : G), g + h) â»Â¹' A) = â‡‘Î¼ A) â†” Î¼.is_add_left_invariant
theorem cont_mdiff_on.cont_mdiff_on_tangent_map_within_aux {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners ğ•œ E' H'} {m n : with_top â„•} {f : H â†’ H'} {s : set H} (hf : cont_mdiff_on I I' n f s) (hmn : m + 1 â‰¤ n) (hs : unique_mdiff_on I s) : cont_mdiff_on I.tangent I'.tangent m (tangent_map_within I I' f s) (tangent_bundle.proj I H â»Â¹' s)
theorem supr_eq_supr_finset' {Î± : Type u_1} {Î¹' : Sort u_5} [complete_lattice Î±] (s : Î¹' â†’ Î±) : (â¨† (i : Î¹'), s i) = â¨† (t : finset (plift Î¹')) (i : plift Î¹') (H : i âˆˆ t), s i.down
theorem set.pairwise_disjoint.countable_of_Ioo {Î± : Type u} [topological_space Î±] [linear_order Î±] [order_topology Î±] [topological_space.second_countable_topology Î±] {y : Î± â†’ Î±} {s : set Î±} (h : s.pairwise_disjoint (Î» (x : Î±), set.Ioo x (y x))) (h' : âˆ€ (x : Î±), x âˆˆ s â†’ x < y x) : s.countable
theorem intermediate_value_Icc' {Î± : Type u} [conditionally_complete_linear_order Î±] [topological_space Î±] [order_topology Î±] [densely_ordered Î±] {Î´ : Type u_1} [linear_order Î´] [topological_space Î´] [order_closed_topology Î´] {a b : Î±} (hab : a â‰¤ b) {f : Î± â†’ Î´} (hf : continuous_on f (set.Icc a b)) : set.Icc (f b) (f a) âŠ† f '' set.Icc a b
theorem ennreal.tendsto_nhds {Î± : Type u_1} {f : filter Î±} {u : Î± â†’ ennreal} {a : ennreal} (ha : a â‰  âŠ¤) : filter.tendsto u f (nhds a) â†” âˆ€ (Îµ : ennreal), Îµ > 0 â†’ (âˆ€á¶  (x : Î±) in f, u x âˆˆ set.Icc (a - Îµ) (a + Îµ))
theorem strict_concave_on.neg {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [ordered_semiring ğ•œ] [add_comm_monoid E] [ordered_add_comm_group Î²] [has_scalar ğ•œ E] [module ğ•œ Î²] {s : set E} {f : E â†’ Î²} : strict_concave_on ğ•œ s f â†’ strict_convex_on ğ•œ s (-f)
theorem dimH_image_le_of_locally_lipschitz_on {X : Type u_2} {Y : Type u_3} [emetric_space X] [emetric_space Y] [topological_space.second_countable_topology X] {f : X â†’ Y} {s : set X} (hf : âˆ€ (x : X), x âˆˆ s â†’ (âˆƒ (C : nnreal) (t : set X) (H : t âˆˆ nhds_within x s), lipschitz_on_with C f t)) : dimH (f '' s) â‰¤ dimH s
theorem metric.isometry_inr {X : Type u} {Y : Type v} [metric_space X] [metric_space Y] : isometry sum.inr
theorem measurable_update {Î´ : Type u_4} {Ï€ : Î´ â†’ Type u_7} [Î  (a : Î´), measurable_space (Ï€ a)] (f : Î  (a : Î´), Ï€ a) {a : Î´} [decidable_eq Î´] : measurable (function.update f a)
theorem add_semiconj_by.zero_right {M : Type u} [add_zero_class M] (a : M) : add_semiconj_by a 0 0
theorem composition_series.ext_fun {X : Type u} [lattice X] [jordan_holder_lattice X] {sâ‚ sâ‚‚ : composition_series X} (hl : sâ‚.length = sâ‚‚.length) (h : âˆ€ (i : fin (sâ‚.length + 1)), â‡‘sâ‚ i = â‡‘sâ‚‚ (â‡‘(fin.cast _) i)) : sâ‚ = sâ‚‚
theorem category_theory.iso.faithful_of_comp {C : Type uâ‚} [category_theory.category C] {D : Type uâ‚‚} [category_theory.category D] {E : Type uâ‚ƒ} [category_theory.category E] {F : C â¥¤ D} {G : D â¥¤ E} {H : C â¥¤ E} [â„‹ : category_theory.faithful H] (h : F â‹™ G â‰… H) : category_theory.faithful F
theorem measure_theory.measure.finite_at_filter.integrable_at_filter {Î± : Type u_1} {E : Type u_3} [measurable_space Î±] [normed_group E] {f : Î± â†’ E} {Î¼ : measure_theory.measure Î±} {l : filter Î±} [l.is_measurably_generated] (hfm : strongly_measurable_at_filter f l Î¼) (hÎ¼ : Î¼.finite_at_filter l) (hf : filter.is_bounded_under has_le.le l (has_norm.norm âˆ˜ f)) : measure_theory.integrable_at_filter f l Î¼
theorem eq_orthogonal_projection_of_mem_of_inner_eq_zero {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {K : submodule ğ•œ E} [complete_space â†¥K] {u v : E} (hvm : v âˆˆ K) (hvo : âˆ€ (w : E), w âˆˆ K â†’ has_inner.inner (u - v) w = 0) : â†‘(â‡‘(orthogonal_projection K) u) = v
theorem local_homeomorph.ext {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] (e e' : local_homeomorph Î± Î²) (h : âˆ€ (x : Î±), â‡‘e x = â‡‘e' x) (hinv : âˆ€ (x : Î²), â‡‘(e.symm) x = â‡‘(e'.symm) x) (hs : e.to_local_equiv.source = e'.to_local_equiv.source) : e = e'
theorem generalized_continued_fraction.sub_convergents_eq {K : Type u_1} {v : K} {n : â„•} [linear_ordered_field K] [floor_ring K] {ifp : generalized_continued_fraction.int_fract_pair K} (stream_nth_eq : generalized_continued_fraction.int_fract_pair.stream v n = option.some ifp) : let g : generalized_continued_fraction K := generalized_continued_fraction.of v, B : K := (g.continuants_aux (n + 1)).b, pB : K := (g.continuants_aux n).b in v - g.convergents n = ite (ifp.fr = 0) 0 ((-1) ^ n / (B * ((ifp.fr)â»Â¹ * B + pB)))
theorem box_integral.has_integral.congr_ae {Î¹ : Type u} {E : Type v} [fintype Î¹] [normed_group E] [normed_space â„ E] {l : box_integral.integration_params} {I : box_integral.box Î¹} {y : E} {f g : (Î¹ â†’ â„) â†’ E} {Î¼ : measure_theory.measure (Î¹ â†’ â„)} [measure_theory.is_locally_finite_measure Î¼] (hf : box_integral.has_integral I l f Î¼.to_box_additive.to_smul y) (hfg : f =áµ[Î¼.restrict â†‘I] g) (hl : l.bRiemann = bool.ff) : box_integral.has_integral I l g Î¼.to_box_additive.to_smul y
theorem module.projective_of_basis {R : Type u} [ring R] {P : Type (max u v)} [add_comm_group P] [module R P] {Î¹ : Type u_1} (b : basis Î¹ R P) : module.projective R P
theorem iterated_deriv_succ' {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {F : Type u_2} [normed_group F] [normed_space ğ•œ F] {n : â„•} {f : ğ•œ â†’ F} : iterated_deriv (n + 1) f = iterated_deriv n (deriv f)
theorem colex.sum_two_pow_le_iff_lt (A B : finset â„•) : A.sum (Î» (i : â„•), 2 ^ i) â‰¤ B.sum (Î» (i : â„•), 2 ^ i) â†” A.to_colex â‰¤ B.to_colex
theorem zero_lt.left.one_le_mul_of_le_of_le {Î± : Type u} {a b : Î±} [mul_zero_one_class Î±] [partial_order Î±] [zero_lt.pos_mul_mono Î±] (ha : 1 â‰¤ a) (hb : 1 â‰¤ b) (a0 : 0 â‰¤ a) : 1 â‰¤ a * b
theorem real.lt_tan (x : â„) (h1 : 0 < x) (h2 : x < real.pi / 2) : x < real.tan x
theorem right.add_nonneg {Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±} (ha : 0 â‰¤ a) (hb : 0 â‰¤ b) : 0 â‰¤ a + b
theorem sylow.exists_subgroup_card_pow_succ {G : Type u} [group G] [fintype G] {p n : â„•} [hp : fact (nat.prime p)] (hdvd : p ^ (n + 1) âˆ£ fintype.card G) {H : subgroup G} (hH : fintype.card â†¥H = p ^ n) : âˆƒ (K : subgroup G), fintype.card â†¥K = p ^ (n + 1) âˆ§ H â‰¤ K
theorem box_integral.integrable.tendsto_integral_sum_sum_integral {Î¹ : Type u} {E : Type v} {F : Type w} [normed_group E] [normed_space â„ E] [normed_group F] [normed_space â„ F] {I : box_integral.box Î¹} [fintype Î¹] {l : box_integral.integration_params} {f : (Î¹ â†’ â„) â†’ E} {vol : box_integral.box_additive_map Î¹ (E â†’L[â„] F) âŠ¤} [complete_space F] (h : box_integral.integrable I l f vol) (Ï€â‚€ : box_integral.prepartition I) : filter.tendsto (box_integral.integral_sum f vol) (l.to_filter_Union I Ï€â‚€) (nhds (Ï€â‚€.boxes.sum (Î» (J : box_integral.box Î¹), box_integral.integral J l f vol)))
theorem tensor_algebra.hom_ext {R : Type u_1} [comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {A : Type u_3} [semiring A] [algebra R A] {f g : tensor_algebra R M â†’â‚[R] A} (w : f.to_linear_map.comp (tensor_algebra.Î¹ R) = g.to_linear_map.comp (tensor_algebra.Î¹ R)) : f = g
theorem order_ring_iso.subsingleton_left {Î± : Type u_2} {Î² : Type u_3} [linear_ordered_field Î±] [archimedean Î±] [linear_ordered_field Î²] : subsingleton (Î± â‰ƒ+*o Î²)
theorem is_localization.is_localization_of_submonoid_le {R : Type u_1} [comm_ring R] (S : Type u_2) [comm_ring S] [algebra R S] (T : Type u_4) [comm_ring T] [algebra R T] (M N : submonoid R) (h : M â‰¤ N) [is_localization M S] [is_localization N T] [algebra S T] [is_scalar_tower R S T] : is_localization (submonoid.map (algebra_map R S).to_monoid_hom N) T
theorem polish_space.exists_polish_space_forall_le {Î± : Type u_1} {Î¹ : Type u_2} [encodable Î¹] [t : topological_space Î±] [p : polish_space Î±] (m : Î¹ â†’ topological_space Î±) (hm : âˆ€ (n : Î¹), m n â‰¤ t) (h'm : âˆ€ (n : Î¹), polish_space Î±) : âˆƒ (t' : topological_space Î±), (âˆ€ (n : Î¹), t' â‰¤ m n) âˆ§ t' â‰¤ t âˆ§ polish_space Î±
theorem submonoid.localization_map.lift_mul_left {M : Type u_1} [comm_monoid M] {S : submonoid M} {N : Type u_2} [comm_monoid N] {P : Type u_3} [comm_monoid P] (f : S.localization_map N) {g : M â†’* P} (hg : âˆ€ (y : â†¥S), is_unit (â‡‘g â†‘y)) (z : N) : â‡‘g â†‘((f.sec z).snd) * â‡‘(f.lift hg) z = â‡‘g (f.sec z).fst
theorem con.con_gen_eq {M : Type u_1} [has_mul M] (r : M â†’ M â†’ Prop) : con_gen r = has_Inf.Inf {s : con M | âˆ€ (x y : M), r x y â†’ â‡‘s x y}
theorem linear_map.concave_on {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [ordered_semiring ğ•œ] [add_comm_monoid E] [ordered_add_comm_monoid Î²] [module ğ•œ E] [module ğ•œ Î²] (f : E â†’â‚—[ğ•œ] Î²) {s : set E} (hs : convex ğ•œ s) : concave_on ğ•œ s â‡‘f
theorem continuous_linear_equiv.extâ‚ {Râ‚ : Type u_1} [semiring Râ‚] {Mâ‚ : Type u_4} [topological_space Mâ‚] [add_comm_monoid Mâ‚] [module Râ‚ Mâ‚] [topological_space Râ‚] {f g : Râ‚ â‰ƒL[Râ‚] Mâ‚} (h : â‡‘f 1 = â‡‘g 1) : f = g
theorem module.equiv_free_prod_direct_sum {R : Type u} [comm_ring R] [is_domain R] [is_principal_ideal_ring R] {N : Type (max u v)} [add_comm_group N] [module R N] [h' : module.finite R N] : âˆƒ (n : â„•) (Î¹ : Type u) [_inst_8 : fintype Î¹] (p : Î¹ â†’ R) [_inst_9 : âˆ€ (i : Î¹), irreducible (p i)] (e : Î¹ â†’ â„•), nonempty (N â‰ƒâ‚—[R] (fin n â†’â‚€ R) Ã— direct_sum Î¹ (Î» (i : Î¹), R â§¸ submodule.span R {p i ^ e i}))
theorem is_local_extr.has_fderiv_at_eq_zero {E : Type u} [normed_group E] [normed_space â„ E] {f : E â†’ â„} {a : E} {f' : E â†’L[â„] â„} (h : is_local_extr f a) : has_fderiv_at f f' a â†’ f' = 0
theorem mul_hom.congr_fun {M : Type u_3} {N : Type u_4} [has_mul M] [has_mul N] {f g : M â†’â‚™* N} (h : f = g) (x : M) : â‡‘f x = â‡‘g x
theorem algebraic_geometry.RingedSpace.is_unit_res_basic_open (X : algebraic_geometry.RingedSpace) {U : topological_space.opens â†¥X} (f : â†¥(X.to_PresheafedSpace.presheaf.obj (opposite.op U))) : is_unit (â‡‘(X.to_PresheafedSpace.presheaf.map (category_theory.hom_of_le _).op) f)
theorem norm_torus_integral_le_of_norm_le_const {n : â„•} {E : Type u_1} [normed_group E] [normed_space â„‚ E] [complete_space E] {f : (fin n â†’ â„‚) â†’ E} {c : fin n â†’ â„‚} {R : fin n â†’ â„} {C : â„} (hf : âˆ€ (Î¸ : fin n â†’ â„), âˆ¥f (torus_map c R Î¸)âˆ¥ â‰¤ C) : âˆ¥âˆ¯ (x : fin n â†’ â„‚) in T(c, R), f xâˆ¥ â‰¤ (2 * real.pi) ^ n * finset.univ.prod (Î» (i : fin n), |R i|) * C
theorem ennreal.infi_mul {Î¹ : Sort u_1} [nonempty Î¹] {f : Î¹ â†’ ennreal} {x : ennreal} (h : x â‰  âŠ¤) : infi f * x = â¨… (i : Î¹), f i * x
theorem orthonormal.comp_linear_isometry_equiv {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {Î¹ : Type u_4} {E' : Type u_7} [inner_product_space ğ•œ E'] {v : Î¹ â†’ E} (hv : orthonormal ğ•œ v) (f : E â‰ƒâ‚—áµ¢[ğ•œ] E') : orthonormal ğ•œ (â‡‘f âˆ˜ v)
theorem cardinal.aleph_0_le_mul_iff' {a b : cardinal} : cardinal.aleph_0 â‰¤ a * b â†” a â‰  0 âˆ§ cardinal.aleph_0 â‰¤ b âˆ¨ cardinal.aleph_0 â‰¤ a âˆ§ b â‰  0
theorem submonoid.one_mem {M : Type u_1} [mul_one_class M] (S : submonoid M) : 1 âˆˆ S
theorem dim_eq_card_basis {R : Type u} [ring R] [strong_rank_condition R] {M : Type v} [add_comm_group M] [module R M] {Î¹ : Type w} [fintype Î¹] (h : basis Î¹ R M) : module.rank R M = â†‘(fintype.card Î¹)
theorem tactic.ring2.correctness {Î± : Type u_1} [comm_semiring Î±] (t : tree Î±) (râ‚ râ‚‚ : tactic.ring2.csring_expr) (H : tactic.ring2.horner_expr.of_csexpr râ‚ = tactic.ring2.horner_expr.of_csexpr râ‚‚) : tactic.ring2.csring_expr.eval t râ‚ = tactic.ring2.csring_expr.eval t râ‚‚
theorem smul_neg_of_neg_of_pos {k : Type u_1} {M : Type u_2} [ordered_ring k] [ordered_add_comm_group M] [module k M] [ordered_smul k M] {a : M} {c : k} (hc : c < 0) : 0 < a â†’ c â€¢ a < 0
theorem probability_theory.lintegral_mul_eq_lintegral_mul_lintegral_of_indep_fun {Î± : Type u_1} {mÎ± : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {f g : Î± â†’ ennreal} (h_meas_f : measurable f) (h_meas_g : measurable g) (h_indep_fun : probability_theory.indep_fun f g Î¼) : âˆ«â» (a : Î±), (f * g) a âˆ‚Î¼ = âˆ«â» (a : Î±), f a âˆ‚Î¼ * âˆ«â» (a : Î±), g a âˆ‚Î¼
theorem orthonormal.oangle_add_oangle_rev {V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) (x y : V) : hb.oangle x y + hb.oangle y x = 0
theorem exists_integral_multiples (A : Type u_2) (K : Type u_3) [comm_ring A] [field K] [is_domain A] [algebra A K] [is_fraction_ring A K] {L : Type u_4} [field L] [algebra K L] [finite_dimensional K L] [algebra A L] [is_scalar_tower A K L] (s : finset L) : âˆƒ (y : A) (H : y â‰  0), âˆ€ (x : L), x âˆˆ s â†’ is_integral A (y â€¢ x)
theorem local_homeomorph.eq_on_source.symm_eq_on_target {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] {e e' : local_homeomorph Î± Î²} (h : e â‰ˆ e') : set.eq_on â‡‘(e.symm) â‡‘(e'.symm) e.to_local_equiv.target
theorem metric.forall_of_forall_mem_closed_ball {Î± : Type u} [pseudo_metric_space Î±] (p : Î± â†’ Prop) (x : Î±) (H : âˆƒá¶  (R : â„) in filter.at_top, âˆ€ (y : Î±), y âˆˆ metric.closed_ball x R â†’ p y) (y : Î±) : p y
theorem category_theory.preadditive.has_cokernel_of_has_coequalizer {C : Type u} [category_theory.category C] [category_theory.preadditive C] {X Y : C} (f g : X âŸ¶ Y) [category_theory.limits.has_coequalizer f g] : category_theory.limits.has_cokernel (f - g)
theorem irrational_nrt_of_n_not_dvd_multiplicity {x : â„} (n : â„•) {m : â„¤} (hm : m â‰  0) (p : â„•) [hp : fact (nat.prime p)] (hxr : x ^ n = â†‘m) (hv : (multiplicity â†‘p m).get _ % n â‰  0) : irrational x
theorem smul_add_smul_le_smul_add_smul {k : Type u_1} {M : Type u_2} [ordered_ring k] [ordered_add_comm_group M] [module k M] [ordered_smul k M] [contravariant_class M M has_add.add has_le.le] {a b : k} {c d : M} (hab : a â‰¤ b) (hcd : c â‰¤ d) : a â€¢ d + b â€¢ c â‰¤ a â€¢ c + b â€¢ d
theorem discrete_valuation_ring.of_has_unit_mul_pow_irreducible_factorization {R : Type u} [comm_ring R] [is_domain R] (hR : discrete_valuation_ring.has_unit_mul_pow_irreducible_factorization R) : discrete_valuation_ring R
theorem exists_hilbert_basis (ğ•œ : Type u_2) [is_R_or_C ğ•œ] (E : Type u_3) [inner_product_space ğ•œ E] [cplt : complete_space E] : âˆƒ (w : set E) (b : hilbert_basis â†¥w ğ•œ E), â‡‘b = coe
theorem cont_diff_within_at_snd {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {n : with_top â„•} {s : set (E Ã— F)} {p : E Ã— F} : cont_diff_within_at ğ•œ n prod.snd s p
theorem orthonormal.comp {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {Î¹ : Type u_4} {Î¹' : Type u_3} {v : Î¹ â†’ E} (hv : orthonormal ğ•œ v) (f : Î¹' â†’ Î¹) (hf : function.injective f) : orthonormal ğ•œ (v âˆ˜ f)
theorem ideal.eq_jacobson_iff_Inf_maximal {R : Type u} [ring R] {I : ideal R} : I.jacobson = I â†” âˆƒ (M : set (ideal R)), (âˆ€ (J : ideal R), J âˆˆ M â†’ J.is_maximal âˆ¨ J = âŠ¤) âˆ§ I = has_Inf.Inf M
theorem lie_module.infi_max_gen_zero_eigenspace_eq_top_of_nilpotent (R : Type u) (L : Type v) (M : Type w) [comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] [lie_module.is_nilpotent R L M] : (â¨… (x : L), (â‡‘(lie_module.to_endomorphism R L M) x).maximal_generalized_eigenspace 0) = âŠ¤
theorem ring.two_ne_zero {R : Type u_1} [non_assoc_semiring R] [nontrivial R] (hR : ring_char R â‰  2) : 2 â‰  0
theorem is_primitive_root.sub_one_norm_prime_ne_two {p : â„•+} {K : Type u} {L : Type v} [field L] {Î¶ : L} [field K] [algebra K L] [ne_zero â†‘â†‘p] {k : â„•} (hÎ¶ : is_primitive_root Î¶ â†‘(p ^ (k + 1))) [hpri : fact (nat.prime â†‘p)] [is_cyclotomic_extension {p ^ (k + 1)} K L] (hirr : irreducible (polynomial.cyclotomic â†‘(p ^ (k + 1)) K)) (h : p â‰  2) : â‡‘(algebra.norm K) (Î¶ - 1) = â†‘p
theorem continuous_multilinear_map.le_op_nnnorm {ğ•œ : Type u} {Î¹ : Type v} {E : Î¹ â†’ Type wE} {G : Type wG} [decidable_eq Î¹] [fintype Î¹] [nondiscrete_normed_field ğ•œ] [Î  (i : Î¹), normed_group (E i)] [Î  (i : Î¹), normed_space ğ•œ (E i)] [normed_group G] [normed_space ğ•œ G] (f : continuous_multilinear_map ğ•œ E G) (m : Î  (i : Î¹), E i) : âˆ¥â‡‘f mâˆ¥â‚Š â‰¤ âˆ¥fâˆ¥â‚Š * finset.univ.prod (Î» (i : Î¹), âˆ¥m iâˆ¥â‚Š)
theorem linear_map.finrank_range_add_finrank_ker {K : Type u} {V : Type v} [field K] [add_comm_group V] [module K V] {Vâ‚‚ : Type v'} [add_comm_group Vâ‚‚] [module K Vâ‚‚] [finite_dimensional K V] (f : V â†’â‚—[K] Vâ‚‚) : finite_dimensional.finrank K â†¥(f.range) + finite_dimensional.finrank K â†¥(f.ker) = finite_dimensional.finrank K V
theorem finsum_induction {M : Type u_2} {Î± : Sort u_4} [add_comm_monoid M] {f : Î± â†’ M} (p : M â†’ Prop) (hpâ‚€ : p 0) (hpâ‚ : âˆ€ (x y : M), p x â†’ p y â†’ p (x + y)) (hpâ‚‚ : âˆ€ (i : Î±), p (f i)) : p (finsum (Î» (i : Î±), f i))
theorem dense_Inter_of_open_nat {Î± : Type u_1} [topological_space Î±] [baire_space Î±] {f : â„• â†’ set Î±} (ho : âˆ€ (n : â„•), is_open (f n)) (hd : âˆ€ (n : â„•), dense (f n)) : dense (â‹‚ (n : â„•), f n)
theorem measure_theory.measure.ext_of_Union_eq_univ {Î± : Type u_1} {Î¹ : Type u_5} {m0 : measurable_space Î±} {Î¼ Î½ : measure_theory.measure Î±} [encodable Î¹] {s : Î¹ â†’ set Î±} (hs : (â‹ƒ (i : Î¹), s i) = set.univ) : (âˆ€ (i : Î¹), Î¼.restrict (s i) = Î½.restrict (s i)) â†’ Î¼ = Î½
theorem filter.map_const_principal_coprod_map_id_principal {Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_3} (a : Î±) (b : Î²) (i : Î¹) : (filter.map (Î» (_x : Î±), b) (filter.principal {a})).coprod (filter.map id (filter.principal {i})) = filter.principal ({b} Ã—Ë¢ set.univ âˆª set.univ Ã—Ë¢ {i})
theorem fractional_ideal.coe_ideal_mul_inv {A : Type u_2} {K : Type u_3} [comm_ring A] [field K] [is_domain A] [algebra A K] [is_fraction_ring A K] [h : is_dedekind_domain A] (I : ideal A) (hI0 : I â‰  âŠ¥) : â†‘I * (â†‘I)â»Â¹ = 1
theorem orthonormal.rotation_trans {V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) (Î¸â‚ Î¸â‚‚ : real.angle) : (hb.rotation Î¸â‚).trans (hb.rotation Î¸â‚‚) = hb.rotation (Î¸â‚‚ + Î¸â‚)
theorem unitization.linear_map_ext {S : Type u_2} {R : Type u_3} {A : Type u_4} {N : Type u_1} [semiring S] [add_comm_monoid R] [add_comm_monoid A] [add_comm_monoid N] [module S R] [module S A] [module S N] â¦ƒf g : unitization R A â†’â‚—[S] Nâ¦„ (hl : âˆ€ (r : R), â‡‘f (unitization.inl r) = â‡‘g (unitization.inl r)) (hr : âˆ€ (a : A), â‡‘f â†‘a = â‡‘g â†‘a) : f = g
theorem category_theory.is_pushout.of_has_pushout {C : Type uâ‚} [category_theory.category C] {Z X Y : C} (f : Z âŸ¶ X) (g : Z âŸ¶ Y) [category_theory.limits.has_pushout f g] : category_theory.is_pushout f g category_theory.limits.pushout.inl category_theory.limits.pushout.inr
theorem algebra.finite_type.iff_quotient_mv_polynomial {R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] : algebra.finite_type R A â†” âˆƒ (s : finset A) (f : mv_polynomial {x // x âˆˆ s} R â†’â‚[R] A), function.surjective â‡‘f
theorem CompHaus.is_iso_of_bijective {X Y : CompHaus} (f : X âŸ¶ Y) (bij : function.bijective â‡‘f) : category_theory.is_iso f
theorem category_theory.forget_enrichment_id {C : Type uâ‚} (W : Type (v+1)) [category_theory.category W] [category_theory.monoidal_category W] [category_theory.enriched_category W C] (X : category_theory.forget_enrichment W C) : category_theory.forget_enrichment.hom_to W (ğŸ™ X) = category_theory.e_id W (category_theory.forget_enrichment.to W X)
theorem metric.bounded_of_finite {Î± : Type u} [pseudo_metric_space Î±] {s : set Î±} (h : s.finite) : metric.bounded s
theorem filter.tendsto.at_top_mul_const {Î± : Type u_3} {Î² : Type u_4} [linear_ordered_field Î±] {l : filter Î²} {f : Î² â†’ Î±} {r : Î±} (hr : 0 < r) (hf : filter.tendsto f l filter.at_top) : filter.tendsto (Î» (x : Î²), f x * r) l filter.at_top
theorem free_product.lift_injective_of_ping_pong {Î¹ : Type u_1} [hnontriv : nontrivial Î¹] {G : Type u_4} [group G] {H : Î¹ â†’ Type u_5} [Î  (i : Î¹), group (H i)] (f : Î  (i : Î¹), H i â†’* G) (hcard : 3 â‰¤ cardinal.mk Î¹ âˆ¨ âˆƒ (i : Î¹), 3 â‰¤ cardinal.mk (H i)) {Î± : Type u_6} [mul_action G Î±] (X : Î¹ â†’ set Î±) (hXnonempty : âˆ€ (i : Î¹), (X i).nonempty) (hXdisj : pairwise (Î» (i j : Î¹), disjoint (X i) (X j))) (hpp : pairwise (Î» (i j : Î¹), âˆ€ (h : H i), h â‰  1 â†’ â‡‘(f i) h â€¢ X j âŠ† X i)) : function.injective â‡‘(â‡‘free_product.lift f)
theorem finset.sum_smul_vsub_const_eq_affine_combination_vsub {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {Î¹ : Type u_4} (s : finset Î¹) (w : Î¹ â†’ k) (pâ‚ : Î¹ â†’ P) (pâ‚‚ : P) (h : s.sum (Î» (i : Î¹), w i) = 1) : s.sum (Î» (i : Î¹), w i â€¢ (pâ‚ i -áµ¥ pâ‚‚)) = â‡‘(s.affine_combination pâ‚) w -áµ¥ pâ‚‚
theorem orthonormal.linear_equiv_det_conj_lie {V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) : â‡‘linear_equiv.det hb.conj_lie.to_linear_equiv = -1
theorem affine_map.continuous_linear_iff {ğ•œ : Type u_1} {V : Type u_2} {Vâ‚‚ : Type u_4} {P : Type u_8} {Pâ‚‚ : Type u_9} [normed_field ğ•œ] [semi_normed_group V] [semi_normed_group Vâ‚‚] [normed_space ğ•œ V] [normed_space ğ•œ Vâ‚‚] [pseudo_metric_space P] [pseudo_metric_space Pâ‚‚] [normed_add_torsor V P] [normed_add_torsor Vâ‚‚ Pâ‚‚] {f : P â†’áµƒ[ğ•œ] Pâ‚‚} : continuous â‡‘(f.linear) â†” continuous â‡‘f
theorem polynomial.cyclotomic_eq_minpoly {n : â„•} {K : Type u_1} [field K] {Î¼ : K} (h : is_primitive_root Î¼ n) (hpos : 0 < n) [char_zero K] : polynomial.cyclotomic n â„¤ = minpoly â„¤ Î¼
theorem tendsto_pow_const_mul_const_pow_of_lt_one (k : â„•) {r : â„} (hr : 0 â‰¤ r) (h'r : r < 1) : filter.tendsto (Î» (n : â„•), â†‘n ^ k * r ^ n) filter.at_top (nhds 0)
theorem mv_polynomial.induction_on''' {R : Type u} {Ïƒ : Type u_1} [comm_semiring R] {M : mv_polynomial Ïƒ R â†’ Prop} (p : mv_polynomial Ïƒ R) (h_C : âˆ€ (a : R), M (â‡‘mv_polynomial.C a)) (h_add_weak : âˆ€ (a : Ïƒ â†’â‚€ â„•) (b : R) (f : (Ïƒ â†’â‚€ â„•) â†’â‚€ R), a âˆ‰ f.support â†’ b â‰  0 â†’ M f â†’ M (â‡‘(mv_polynomial.monomial a) b + f)) : M p
theorem ring_hom.map_multiset_sum {Î² : Type u} {Î³ : Type w} [non_assoc_semiring Î²] [non_assoc_semiring Î³] (f : Î² â†’+* Î³) (s : multiset Î²) : â‡‘f s.sum = (multiset.map â‡‘f s).sum
theorem is_closed.is_closed_le {Î± : Type u} {Î² : Type v} [topological_space Î±] [preorder Î±] [t : order_closed_topology Î±] [topological_space Î²] {f g : Î² â†’ Î±} {s : set Î²} (hs : is_closed s) (hf : continuous_on f s) (hg : continuous_on g s) : is_closed {x âˆˆ s | f x â‰¤ g x}
theorem interval_integral.integral_has_strict_deriv_at_of_tendsto_ae_left {E : Type u_3} [normed_group E] [complete_space E] [normed_space â„ E] {f : â„ â†’ E} {c : E} {a b : â„} (hf : interval_integrable f measure_theory.measure_space.volume a b) (hmeas : strongly_measurable_at_filter f (nhds a) measure_theory.measure_space.volume) (ha : filter.tendsto f (nhds a âŠ“ measure_theory.measure_space.volume.ae) (nhds c)) : has_strict_deriv_at (Î» (u : â„), âˆ« (x : â„) in u..b, f x) (-c) a
theorem list.of_fn_zero {Î± : Type u} (f : fin 0 â†’ Î±) : list.of_fn f = list.nil
theorem affine.triangle.dist_orthocenter_reflection_circumcenter_finset {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] (t : affine.triangle â„ P) {iâ‚ iâ‚‚ : fin 3} (h : iâ‚ â‰  iâ‚‚) : has_dist.dist t.orthocenter (â‡‘(euclidean_geometry.reflection (affine_span â„ (t.points '' â†‘{iâ‚, iâ‚‚}))) (affine.simplex.circumcenter t)) = affine.simplex.circumradius t
theorem generalized_continued_fraction.of_correctness_of_terminates {K : Type u_1} [linear_ordered_field K] {v : K} [floor_ring K] (terminates : (generalized_continued_fraction.of v).terminates) : âˆƒ (n : â„•), v = (generalized_continued_fraction.of v).convergents n
theorem equiv.option_congr_eq_equiv_function_map_equiv {Î± Î² : Type u_1} (e : Î± â‰ƒ Î²) : e.option_congr = equiv_functor.map_equiv option e
theorem is_unit.mul_left_dvd {Î± : Type u_1} [comm_monoid Î±] (a b u : Î±) (hu : is_unit u) : u * a âˆ£ b â†” a âˆ£ b
theorem continuous_linear_map.op_norm_lsmul (ğ•œ : Type u_1) {E : Type u_4} [normed_group E] [nondiscrete_normed_field ğ•œ] [normed_space ğ•œ E] (ğ•œ' : Type u_12) [normed_field ğ•œ'] [normed_algebra ğ•œ ğ•œ'] [normed_space ğ•œ' E] [is_scalar_tower ğ•œ ğ•œ' E] [nontrivial E] : âˆ¥continuous_linear_map.lsmul ğ•œ ğ•œ'âˆ¥ = 1
theorem continuous_linear_map.exists_approx_preimage_norm_le {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] (f : E â†’L[ğ•œ] F) [complete_space F] (surj : function.surjective â‡‘f) : âˆƒ (C : â„) (H : C â‰¥ 0), âˆ€ (y : F), âˆƒ (x : E), has_dist.dist (â‡‘f x) y â‰¤ 1 / 2 * âˆ¥yâˆ¥ âˆ§ âˆ¥xâˆ¥ â‰¤ C * âˆ¥yâˆ¥
theorem lucas_lehmer.X.units_card {q : â„•+} (w : 1 < q) : fintype.card (lucas_lehmer.X q)Ë£ < â†‘q ^ 2
theorem finset.image_imageâ‚‚_distrib_left {Î± : Type u_1} {Î±' : Type u_2} {Î² : Type u_3} {Î³ : Type u_5} {Î´ : Type u_7} [decidable_eq Î±'] [decidable_eq Î³] [decidable_eq Î´] {f : Î± â†’ Î² â†’ Î³} {s : finset Î±} {t : finset Î²} {g : Î³ â†’ Î´} {f' : Î±' â†’ Î² â†’ Î´} {g' : Î± â†’ Î±'} (h_distrib : âˆ€ (a : Î±) (b : Î²), g (f a b) = f' (g' a) b) : finset.image g (finset.imageâ‚‚ f s t) = finset.imageâ‚‚ f' (finset.image g' s) t
theorem vitali_family.exists_measurable_supersets_lim_ratio {Î± : Type u_1} [metric_space Î±] {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (v : vitali_family Î¼) [sigma_compact_space Î±] [borel_space Î±] [measure_theory.is_locally_finite_measure Î¼] {Ï : measure_theory.measure Î±} [measure_theory.is_locally_finite_measure Ï] (hÏ : Ï.absolutely_continuous Î¼) {p q : nnreal} (hpq : p < q) : âˆƒ (a b : set Î±), measurable_set a âˆ§ measurable_set b âˆ§ {x : Î± | v.lim_ratio Ï x < â†‘p} âŠ† a âˆ§ {x : Î± | â†‘q < v.lim_ratio Ï x} âŠ† b âˆ§ â‡‘Î¼ (a âˆ© b) = 0
theorem cont_diff_on_succ_iff_deriv_within {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {fâ‚‚ : ğ•œ â†’ F} {sâ‚‚ : set ğ•œ} {n : â„•} (hs : unique_diff_on ğ•œ sâ‚‚) : cont_diff_on ğ•œ â†‘(n + 1) fâ‚‚ sâ‚‚ â†” differentiable_on ğ•œ fâ‚‚ sâ‚‚ âˆ§ cont_diff_on ğ•œ â†‘n (deriv_within fâ‚‚ sâ‚‚) sâ‚‚
theorem add_subgroup.ext {G : Type u_1} [add_group G] {H K : add_subgroup G} (h : âˆ€ (x : G), x âˆˆ H â†” x âˆˆ K) : H = K
theorem category_theory.limits.strong_epi_of_strong_epi_mono_factorisation {C : Type u} [category_theory.category C] {X Y : C} {f : X âŸ¶ Y} (F : category_theory.limits.strong_epi_mono_factorisation f) {F' : category_theory.limits.mono_factorisation f} (hF' : category_theory.limits.is_image F') : category_theory.strong_epi F'.e
theorem edist_ne_top {Î± : Type u} [pseudo_metric_space Î±] (x y : Î±) : has_edist.edist x y â‰  âŠ¤
theorem linear_independent.of_comp {Î¹ : Type u_1} {R : Type u_3} {M : Type u_5} {M' : Type u_6} {v : Î¹ â†’ M} [semiring R] [add_comm_monoid M] [add_comm_monoid M'] [module R M] [module R M'] (f : M â†’â‚—[R] M') (hfv : linear_independent R (â‡‘f âˆ˜ v)) : linear_independent R v
theorem real.not_summable_nat_cast_inv  : Â¬summable (Î» (n : â„•), (â†‘n)â»Â¹)
theorem first_order.language.ultraproduct.sentence_realize {Î± : Type u_1} {M : Î± â†’ Type u_2} {u : ultrafilter Î±} {L : first_order.language} [Î  (a : Î±), L.Structure (M a)] [âˆ€ (a : Î±), nonempty (M a)] (Ï† : L.sentence) : â†‘u.product M âŠ¨ Ï† â†” âˆ€á¶  (a : Î±) in â†‘u, M a âŠ¨ Ï†
theorem char_eq_exp_char_iff (R : Type u) [semiring R] (p q : â„•) [hp : char_p R p] [hq : exp_char R q] : p = q â†” nat.prime p
theorem category_theory.simple_of_is_simple_order_subobject {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] (X : C) [is_simple_order (category_theory.subobject X)] : category_theory.simple X
theorem subgroup.commute_of_normal_of_disjoint {G : Type u_1} [group G] (Hâ‚ Hâ‚‚ : subgroup G) (hHâ‚ : Hâ‚.normal) (hHâ‚‚ : Hâ‚‚.normal) (hdis : disjoint Hâ‚ Hâ‚‚) (x y : G) (hx : x âˆˆ Hâ‚) (hy : y âˆˆ Hâ‚‚) : commute x y
theorem mv_polynomial.fin_succ_equiv_coeff_coeff {R : Type u} [comm_semiring R] {n : â„•} (m : fin n â†’â‚€ â„•) (f : mv_polynomial (fin (n + 1)) R) (i : â„•) : mv_polynomial.coeff m ((â‡‘(mv_polynomial.fin_succ_equiv R n) f).coeff i) = mv_polynomial.coeff (finsupp.cons i m) f
theorem tendsto_one_plus_div_pow_exp (t : â„) : filter.tendsto (Î» (x : â„•), (1 + t / â†‘x) ^ x) filter.at_top (nhds (real.exp t))
theorem convex_on.comp_linear_map {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} {Î² : Type u_4} [ordered_semiring ğ•œ] [add_comm_monoid E] [add_comm_monoid F] [ordered_add_comm_monoid Î²] [module ğ•œ E] [module ğ•œ F] [has_scalar ğ•œ Î²] {f : F â†’ Î²} {s : set F} (hf : convex_on ğ•œ s f) (g : E â†’â‚—[ğ•œ] F) : convex_on ğ•œ (â‡‘g â»Â¹' s) (f âˆ˜ â‡‘g)
theorem finprod_mem_dvd {Î± : Type u_1} {N : Type u_6} [comm_monoid N] {f : Î± â†’ N} (a : Î±) (hf : (function.mul_support f).finite) : f a âˆ£ finprod f
theorem category_theory.functor.punit_ext' {C : Type u} [category_theory.category C] (F G : C â¥¤ category_theory.discrete punit) : F = G
theorem box_integral.integral_nonneg {Î¹ : Type u} {I : box_integral.box Î¹} [fintype Î¹] {l : box_integral.integration_params} {g : (Î¹ â†’ â„) â†’ â„} (hg : âˆ€ (x : Î¹ â†’ â„), x âˆˆ â‡‘box_integral.box.Icc I â†’ 0 â‰¤ g x) (Î¼ : measure_theory.measure (Î¹ â†’ â„)) [measure_theory.is_locally_finite_measure Î¼] : 0 â‰¤ box_integral.integral I l g Î¼.to_box_additive.to_smul
theorem witt_vector.is_poly.compâ‚‚ {p : â„•} {g : Î  â¦ƒR : Type u_1â¦„ [_inst_3 : comm_ring R], witt_vector p R â†’ witt_vector p R} {f : Î  â¦ƒR : Type u_1â¦„ [_inst_3 : comm_ring R], witt_vector p R â†’ witt_vector p R â†’ witt_vector p R} (hg : witt_vector.is_poly p g) (hf : witt_vector.is_polyâ‚‚ p f) : witt_vector.is_polyâ‚‚ p (Î» (R : Type u_1) (_Rcr : comm_ring R) (x y : witt_vector p R), g (f x y))
theorem witt_vector.neg_is_poly {p : â„•} [hp : fact (nat.prime p)] : witt_vector.is_poly p (Î» (R : Type u_1) (_x : comm_ring R), has_neg.neg)
theorem equiv.polish_space_induced {Î± : Type u_1} {Î² : Type u_2} [t : topological_space Î²] [polish_space Î²] (f : Î± â‰ƒ Î²) : polish_space Î±
theorem tendsto_measure_cthickening_of_is_compact {Î± : Type u_1} [metric_space Î±] [measurable_space Î±] [opens_measurable_space Î±] [proper_space Î±] {Î¼ : measure_theory.measure Î±} [measure_theory.is_finite_measure_on_compacts Î¼] {s : set Î±} (hs : is_compact s) : filter.tendsto (Î» (r : â„), â‡‘Î¼ (metric.cthickening r s)) (nhds 0) (nhds (â‡‘Î¼ s))
theorem multilinear_map.snoc_smul {R : Type u} {n : â„•} {M : fin n.succ â†’ Type v} {Mâ‚‚ : Type vâ‚‚} [semiring R] [Î  (i : fin n.succ), add_comm_monoid (M i)] [add_comm_monoid Mâ‚‚] [Î  (i : fin n.succ), module R (M i)] [module R Mâ‚‚] (f : multilinear_map R M Mâ‚‚) (m : Î  (i : fin n), M (â‡‘fin.cast_succ i)) (c : R) (x : M (fin.last n)) : â‡‘f (fin.snoc m (c â€¢ x)) = c â€¢ â‡‘f (fin.snoc m x)
theorem linear_equiv.finite_dimensional {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {Vâ‚‚ : Type v'} [add_comm_group Vâ‚‚] [module K Vâ‚‚] (f : V â‰ƒâ‚—[K] Vâ‚‚) [finite_dimensional K V] : finite_dimensional K Vâ‚‚
theorem category_theory.limits.has_pushouts_of_has_binary_coproducts_of_has_coequalizers (C : Type u) [ğ’ : category_theory.category C] [category_theory.limits.has_binary_coproducts C] [category_theory.limits.has_coequalizers C] : category_theory.limits.has_pushouts C
theorem is_group_hom.inv {Î± : Type u_1} {Î² : Type u_2} [group Î±] [comm_group Î²] {f : Î± â†’ Î²} (hf : is_group_hom f) : is_group_hom (Î» (a : Î±), (f a)â»Â¹)
theorem polynomial.cyclotomic'_two (R : Type u_1) [comm_ring R] [is_domain R] (p : â„•) [char_p R p] (hp : p â‰  2) : polynomial.cyclotomic' 2 R = polynomial.X + 1
theorem list.prod_pos {R : Type u_8} [ordered_semiring R] [nontrivial R] (l : list R) (h : âˆ€ (a : R), a âˆˆ l â†’ 0 < a) : 0 < l.prod
theorem affine.simplex.eq_circumcenter_of_dist_eq {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {n : â„•} (s : affine.simplex â„ P n) {p : P} (hp : p âˆˆ affine_span â„ (set.range s.points)) {r : â„} (hr : âˆ€ (i : fin (n + 1)), has_dist.dist (s.points i) p = r) : p = s.circumcenter
theorem subset_tangent_cone_prod_right {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {x : E} {s : set E} {t : set F} {y : F} (hs : x âˆˆ closure s) : â‡‘(linear_map.inr ğ•œ E F) '' tangent_cone_at ğ•œ t y âŠ† tangent_cone_at ğ•œ (s Ã—Ë¢ t) (x, y)
theorem category_theory.presieve.is_sheaf_pretopology {C : Type uâ‚} [category_theory.category C] {P : Cáµ’áµ– â¥¤ Type w} [category_theory.limits.has_pullbacks C] (K : category_theory.pretopology C) : category_theory.presieve.is_sheaf (category_theory.pretopology.to_grothendieck C K) P â†” âˆ€ {X : C} (R : category_theory.presieve X), R âˆˆ â‡‘K X â†’ category_theory.presieve.is_sheaf_for P R
theorem filter.map_coe_Ioi_at_top {Î± : Type u_3} [semilattice_sup Î±] [no_max_order Î±] (a : Î±) : filter.map coe filter.at_top = filter.at_top
theorem order.cof_nonempty {Î± : Type u_1} (r : Î± â†’ Î± â†’ Prop) [is_refl Î± r] : {c : cardinal | âˆƒ (S : set Î±), (âˆ€ (a : Î±), âˆƒ (b : Î±) (H : b âˆˆ S), r a b) âˆ§ cardinal.mk â†¥S = c}.nonempty
theorem game.not_le {x y : game} : Â¬x â‰¤ y â†” y.lf x
theorem category_theory.is_pushout.of_is_colimit {C : Type uâ‚} [category_theory.category C] {Z X Y : C} {f : Z âŸ¶ X} {g : Z âŸ¶ Y} {c : category_theory.limits.pushout_cocone f g} (h : category_theory.limits.is_colimit c) : category_theory.is_pushout f g c.inl c.inr
theorem ideal.exists_smith_normal_form {Î¹ : Type u_1} {R : Type u_2} [comm_ring R] [is_domain R] [is_principal_ideal_ring R] [fintype Î¹] {S : Type u_3} [comm_ring S] [is_domain S] [algebra R S] (b : basis Î¹ R S) (I : ideal S) (hI : I â‰  âŠ¥) : âˆƒ (b' : basis Î¹ R S) (a : Î¹ â†’ R) (ab' : basis Î¹ R â†¥I), âˆ€ (i : Î¹), â†‘(â‡‘ab' i) = a i â€¢ â‡‘b' i
theorem localization.r_eq_r' {M : Type u_1} [comm_monoid M] (S : submonoid M) : localization.r S = localization.r' S
theorem subgroup.is_open_of_one_mem_interior {G : Type u_1} [group G] [topological_space G] [topological_group G] {H : subgroup G} (h_1_int : 1 âˆˆ interior â†‘H) : is_open â†‘H
theorem orientation.oangle_smul_left_of_pos {V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) (x y : V) {r : â„} (hr : 0 < r) : o.oangle (r â€¢ x) y = o.oangle x y
theorem dot_self_cross {R : Type u_1} [comm_ring R] (v w : fin 3 â†’ R) : matrix.dot_product v (â‡‘(â‡‘cross_product v) w) = 0
theorem subgroup.exists_left_complement'_of_coprime {G : Type u} [group G] {N : subgroup G} [N.normal] (hN : (nat.card â†¥N).coprime N.index) : âˆƒ (H : subgroup G), H.is_complement' N
theorem affine.simplex.circumradius_pos {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {n : â„•} (s : affine.simplex â„ P (n + 1)) : 0 < s.circumradius
theorem interval_integral.deriv_within_integral_right {E : Type u_3} [normed_group E] [complete_space E] [normed_space â„ E] {f : â„ â†’ E} {a b : â„} (hf : interval_integrable f measure_theory.measure_space.volume a b) {s t : set â„} [interval_integral.FTC_filter b (nhds_within b s) (nhds_within b t)] (hmeas : strongly_measurable_at_filter f (nhds_within b t) measure_theory.measure_space.volume) (hb : continuous_within_at f t b) (hs : unique_diff_within_at â„ s b . "unique_diff_within_at_Ici_Iic_univ") : deriv_within (Î» (u : â„), âˆ« (x : â„) in a..u, f x) s b = f b
theorem vector.to_list_singleton {Î± : Type u_1} (v : vector Î± 1) : v.to_list = [v.head]
theorem map_csupr_of_continuous_at_of_monotone {Î± : Type u} {Î² : Type v} {Î³ : Type w} [conditionally_complete_linear_order Î±] [topological_space Î±] [order_topology Î±] [conditionally_complete_linear_order Î²] [topological_space Î²] [order_topology Î²] [nonempty Î³] {f : Î± â†’ Î²} {g : Î³ â†’ Î±} (Cf : continuous_at f (â¨† (i : Î³), g i)) (Mf : monotone f) (H : bdd_above (set.range g)) : f (â¨† (i : Î³), g i) = â¨† (i : Î³), f (g i)
theorem add_monoid_algebra.ring_hom_ext {k : Type uâ‚} {G : Type uâ‚‚} {R : Type u_1} [semiring k] [add_monoid G] [semiring R] {f g : add_monoid_algebra k G â†’+* R} (hâ‚€ : âˆ€ (b : k), â‡‘f (finsupp.single 0 b) = â‡‘g (finsupp.single 0 b)) (h_of : âˆ€ (a : G), â‡‘f (finsupp.single a 1) = â‡‘g (finsupp.single a 1)) : f = g
theorem zmod.Ï‡â‚ˆ_trichotomy (a : zmod 8) : â‡‘zmod.Ï‡â‚ˆ a = 0 âˆ¨ â‡‘zmod.Ï‡â‚ˆ a = 1 âˆ¨ â‡‘zmod.Ï‡â‚ˆ a = -1
theorem category_theory.Ran_is_sheaf_of_cover_lifting.helper {C D : Type u} [category_theory.category C] [category_theory.category D] {A : Type w} [category_theory.category A] [category_theory.limits.has_limits A] {J : category_theory.grothendieck_topology C} {K : category_theory.grothendieck_topology D} {G : C â¥¤ D} (hu : category_theory.cover_lifting J K G) (â„± : category_theory.Sheaf J A) {X : A} {U : D} {S : category_theory.sieve U} (hS : S âˆˆ â‡‘K U) {x : category_theory.presieve.family_of_elements ((category_theory.Ran G.op).obj â„±.val â‹™ category_theory.coyoneda.obj (opposite.op X)) S.arrows} (hx : x.compatible) {V : D} (f : V âŸ¶ U) (y : X âŸ¶ ((category_theory.Ran G.op).obj â„±.val).obj (opposite.op V)) (W : category_theory.structured_arrow (opposite.op V) G.op) (H : âˆ€ {V' : C} {fV : G.obj V' âŸ¶ V} (hV : S.arrows (fV â‰« f)), y â‰« ((category_theory.Ran G.op).obj â„±.val).map fV.op = x (fV â‰« f) hV) : y â‰« category_theory.limits.limit.Ï€ (category_theory.Ran.diagram G.op â„±.val (opposite.op V)) W = (category_theory.Ran_is_sheaf_of_cover_lifting.glued_limit_cone hu â„± hS hx).Ï€.app ((category_theory.structured_arrow.map f.op).obj W)
theorem finrank_eq_one_iff' {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] : finite_dimensional.finrank K V = 1 â†” âˆƒ (v : V) (n : v â‰  0), âˆ€ (w : V), âˆƒ (c : K), c â€¢ v = w
theorem ennreal.of_real_of_nonpos {p : â„} : p â‰¤ 0 â†’ ennreal.of_real p = 0
theorem measure_theory.tendsto_measure_Union {Î± : Type u_1} {Î¹ : Type u_5} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [semilattice_sup Î¹] [encodable Î¹] {s : Î¹ â†’ set Î±} (hm : monotone s) : filter.tendsto (â‡‘Î¼ âˆ˜ s) filter.at_top (nhds (â‡‘Î¼ (â‹ƒ (n : Î¹), s n)))
theorem submodule.pow_induction_on_right' {R : Type u} [comm_semiring R] {A : Type v} [semiring A] [algebra R A] (M : submodule R A) {C : Î  (n : â„•) (x : A), x âˆˆ M ^ n â†’ Prop} (hr : âˆ€ (r : R), C 0 (â‡‘(algebra_map R A) r) _) (hadd : âˆ€ (x y : A) (i : â„•) (hx : x âˆˆ M ^ i) (hy : y âˆˆ M ^ i), C i x hx â†’ C i y hy â†’ C i (x + y) _) (hmul : âˆ€ (i : â„•) (x : A) (hx : x âˆˆ M ^ i), C i x hx â†’ âˆ€ (m : A) (H : m âˆˆ M), C i.succ (x * m) _) {x : A} {n : â„•} (hx : x âˆˆ M ^ n) : C n x hx
theorem nat.nth_eq_order_iso_of_nat (p : â„• â†’ Prop) [decidable_pred p] (i : infinite â†¥(set_of p)) (n : â„•) : nat.nth p n = â†‘(â‡‘(nat.subtype.order_iso_of_nat (set_of p)) n)
theorem pgame.left_response_spec {x : pgame} (h : 0 â‰¤ x) (j : x.right_moves) : 0 â‰¤ (x.move_right j).move_left (pgame.left_response h j)
theorem is_compact.ultrafilter_le_nhds {Î± : Type u} [topological_space Î±] {s : set Î±} : is_compact s â†’ âˆ€ (f : ultrafilter Î±), â†‘f â‰¤ filter.principal s â†’ (âˆƒ (a : Î±) (H : a âˆˆ s), â†‘f â‰¤ nhds a)
theorem function.not_surjective_Type {Î± : Type u} (f : Î± â†’ Type (max u v)) : Â¬function.surjective f
theorem has_deriv_at_interval_left_endpoint_of_tendsto_deriv {E : Type u_1} [normed_group E] [normed_space â„ E] {s : set â„} {e : E} {a : â„} {f : â„ â†’ E} (f_diff : differentiable_on â„ f s) (f_lim : continuous_within_at f s a) (hs : s âˆˆ nhds_within a (set.Ioi a)) (f_lim' : filter.tendsto (Î» (x : â„), deriv f x) (nhds_within a (set.Ioi a)) (nhds e)) : has_deriv_within_at f e (set.Ici a) a
theorem continuous_map.continuous_eval {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [compact_space Î±] [metric_space Î²] : continuous (Î» (p : C(Î±, Î²) Ã— Î±), â‡‘(p.fst) p.snd)
theorem set.Union_lift_unary {Î± : Type u_1} {Î¹ : Type u_2} {Î² : Type u_3} {S : Î¹ â†’ set Î±} {f : Î  (i : Î¹), â†¥(S i) â†’ Î²} {hf : âˆ€ (i j : Î¹) (x : Î±) (hxi : x âˆˆ S i) (hxj : x âˆˆ S j), f i âŸ¨x, hxiâŸ© = f j âŸ¨x, hxjâŸ©} {T : set Î±} (hT' : T = set.Union S) (u : â†¥T â†’ â†¥T) (ui : Î  (i : Î¹), â†¥(S i) â†’ â†¥(S i)) (hui : âˆ€ (i : Î¹) (x : â†¥(S i)), u (set.inclusion _ x) = set.inclusion _ (ui i x)) (uÎ² : Î² â†’ Î²) (h : âˆ€ (i : Î¹) (x : â†¥(S i)), f i (ui i x) = uÎ² (f i x)) (x : â†¥T) : set.Union_lift S f hf T _ (u x) = uÎ² (set.Union_lift S f hf T _ x)
theorem is_primitive_root.pow_sub_one_norm_prime_pow_ne_two {p : â„•+} {K : Type u} {L : Type v} [field L] {Î¶ : L} [field K] [algebra K L] [ne_zero â†‘â†‘p] {k s : â„•} (hÎ¶ : is_primitive_root Î¶ â†‘(p ^ (k + 1))) [hpri : fact (nat.prime â†‘p)] [is_cyclotomic_extension {p ^ (k + 1)} K L] (hirr : irreducible (polynomial.cyclotomic â†‘(p ^ (k + 1)) K)) (hs : s â‰¤ k) (htwo : p ^ (k - s + 1) â‰  2) : â‡‘(algebra.norm K) (Î¶ ^ â†‘p ^ s - 1) = â†‘p ^ â†‘p ^ s
theorem real.young_inequality_of_nonneg {a b p q : â„} (ha : 0 â‰¤ a) (hb : 0 â‰¤ b) (hpq : p.is_conjugate_exponent q) : a * b â‰¤ a ^ p / p + b ^ q / q
theorem cInf_insert {Î± : Type u_1} [conditionally_complete_lattice Î±] {s : set Î±} {a : Î±} (hs : bdd_below s) (sne : s.nonempty) : has_Inf.Inf (has_insert.insert a s) = a âŠ“ has_Inf.Inf s
theorem mul_equiv.is_monoid_hom {M : Type u_1} {N : Type u_2} [mul_one_class M] [mul_one_class N] (h : M â‰ƒ* N) : is_monoid_hom â‡‘h
theorem symm_trans_mem_cont_diff_groupoid (n : with_top â„•) {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] (I : model_with_corners ğ•œ E H) {M : Type u_4} [topological_space M] (e : local_homeomorph M H) : e.symm.trans e âˆˆ cont_diff_groupoid n I
theorem simple_graph.is_SRG_with.top {V : Type u} [fintype V] [decidable_eq V] {Î¼ : â„•} : âŠ¤.is_SRG_with (fintype.card V) (fintype.card V - 1) (fintype.card V - 2) Î¼
theorem is_compact.compl_mem_sets_of_nhds_within {Î± : Type u} [topological_space Î±] {s : set Î±} (hs : is_compact s) {f : filter Î±} (hf : âˆ€ (a : Î±), a âˆˆ s â†’ (âˆƒ (t : set Î±) (H : t âˆˆ nhds_within a s), tá¶œ âˆˆ f)) : sá¶œ âˆˆ f
theorem witt_vector.map_frobenius_poly.keyâ‚ (p : â„•) [hp : fact (nat.prime p)] (n j : â„•) (hj : j < p ^ n) : p ^ (n - pnat_multiplicity p âŸ¨j + 1, _âŸ©) âˆ£ (p ^ n).choose (j + 1)
theorem real.tendsto_mul_exp_add_div_pow_at_top (b c : â„) (n : â„•) (hb : 0 < b) : filter.tendsto (Î» (x : â„), (b * real.exp x + c) / x ^ n) filter.at_top filter.at_top
theorem is_mul_hom.inv {Î± : Type u_1} {Î² : Type u_2} [has_mul Î±] [comm_group Î²] {f : Î± â†’ Î²} (hf : is_mul_hom f) : is_mul_hom (Î» (a : Î±), (f a)â»Â¹)
theorem formal_multilinear_series.left_inv_comp {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] (p : formal_multilinear_series ğ•œ E F) (i : E â‰ƒL[ğ•œ] F) (h : p 1 = â‡‘((continuous_multilinear_curry_fin1 ğ•œ E F).symm) â†‘i) : (p.left_inv i).comp p = formal_multilinear_series.id ğ•œ E
theorem pgame.le_iff_forall_lf {x y : pgame} : x â‰¤ y â†” (âˆ€ (i : x.left_moves), (x.move_left i).lf y) âˆ§ âˆ€ (j : y.right_moves), x.lf (y.move_right j)
theorem measure_theory.conservative.frequently_ae_mem_and_frequently_image_mem {Î± : Type u_2} [measurable_space Î±] {f : Î± â†’ Î±} {s : set Î±} {Î¼ : measure_theory.measure Î±} (hf : measure_theory.conservative f Î¼) (hs : measurable_set s) (h0 : â‡‘Î¼ s â‰  0) : âˆƒáµ (x : Î±) âˆ‚Î¼, x âˆˆ s âˆ§ âˆƒá¶  (n : â„•) in filter.at_top, f^[n] x âˆˆ s
theorem powers.is_submonoid {M : Type u_1} [monoid M] (x : M) : is_submonoid (powers x)
theorem add_semiconj_by.zero_left {M : Type u} [add_zero_class M] (x : M) : add_semiconj_by 0 x x
theorem con.Inf_def {M : Type u_1} [has_mul M] (S : set (con M)) : â‡‘(has_Inf.Inf S) = has_Inf.Inf (coe_fn '' S)
theorem measure_theory.measure.is_add_haar_measure_map {G : Type u_1} [measurable_space G] [add_group G] [topological_space G] (Î¼ : measure_theory.measure G) [Î¼.is_add_haar_measure] [borel_space G] [topological_add_group G] {H : Type u_2} [add_group H] [topological_space H] [measurable_space H] [borel_space H] [t2_space H] [topological_add_group H] (f : G â‰ƒ+ H) (hf : continuous â‡‘f) (hfsymm : continuous â‡‘(f.symm)) : (measure_theory.measure.map â‡‘f Î¼).is_add_haar_measure
theorem ideal.rank_eq {R : Type u_1} {S : Type u_2} [comm_ring R] [strong_rank_condition R] [ring S] [is_domain S] [algebra R S] {n : Type u_3} {m : Type u_4} [fintype n] [fintype m] (b : basis n R S) {I : ideal S} (hI : I â‰  âŠ¥) (c : basis m R â†¥I) : fintype.card m = fintype.card n
theorem continuous_map.exists_mem_subalgebra_near_continuous_of_separates_points {X : Type u_1} [topological_space X] [compact_space X] (A : subalgebra â„ C(X, â„)) (w : A.separates_points) (f : X â†’ â„) (c : continuous f) (Îµ : â„) (pos : 0 < Îµ) : âˆƒ (g : â†¥A), âˆ€ (x : X), âˆ¥â‡‘g x - f xâˆ¥ < Îµ
theorem int.zpow_lt_iff_lt_clog {R : Type u_1} [linear_ordered_field R] [floor_ring R] {b : â„•} (hb : 1 < b) {x : â„¤} {r : R} (hr : 0 < r) : â†‘b ^ x < r â†” x < int.clog b r
theorem is_ring_hom.comp {Î± : Type u} {Î² : Type v} [ring Î±] [ring Î²] {f : Î± â†’ Î²} (hf : is_ring_hom f) {Î³ : Type u_1} [ring Î³] {g : Î² â†’ Î³} (hg : is_ring_hom g) : is_ring_hom (g âˆ˜ f)
theorem contract_left_assoc_coevaluation' (K : Type u) [field K] (V : Type v) [add_comm_group V] [module K V] [finite_dimensional K V] : (linear_map.ltensor V (contract_left K V)).comp ((tensor_product.assoc K V (module.dual K V) V).to_linear_map.comp (linear_map.rtensor V (coevaluation K V))) = (tensor_product.rid K V).symm.to_linear_map.comp (tensor_product.lid K V).to_linear_map
theorem affine_combination_mem_affine_span {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {Î¹ : Type u_4} [nontrivial k] {s : finset Î¹} {w : Î¹ â†’ k} (h : s.sum (Î» (i : Î¹), w i) = 1) (p : Î¹ â†’ P) : â‡‘(s.affine_combination p) w âˆˆ affine_span k (set.range p)
theorem equiv.perm.is_cycle.support_congr {Î± : Type u_1} [decidable_eq Î±] [fintype Î±] {f g : equiv.perm Î±} (hf : f.is_cycle) (hg : g.is_cycle) (h : f.support âŠ† g.support) (h' : âˆ€ (x : Î±), x âˆˆ f.support â†’ â‡‘f x = â‡‘g x) : f = g
theorem bdd_below.inter_of_right {Î± : Type u} [preorder Î±] {s t : set Î±} (h : bdd_below t) : bdd_below (s âˆ© t)
theorem finset.card_Ioc_finset {Î± : Type u_1} [decidable_eq Î±] {s t : finset Î±} (h : s âŠ† t) : (finset.Ioc s t).card = 2 ^ (t.card - s.card) - 1
theorem category_theory.equiv_punit_iff_unique (C : Type u) [category_theory.category C] : nonempty (C â‰Œ category_theory.discrete punit) â†” nonempty C âˆ§ âˆ€ (x y : C), nonempty (unique (x âŸ¶ y))
theorem inner_product_geometry.angle_eq_zero_iff {V : Type u_1} [inner_product_space â„ V] {x y : V} : inner_product_geometry.angle x y = 0 â†” x â‰  0 âˆ§ âˆƒ (r : â„), 0 < r âˆ§ y = r â€¢ x
theorem category_theory.is_subterminal.mono_terminal_from {C : Type uâ‚} [category_theory.category C] {A : C} [category_theory.limits.has_terminal C] (hA : category_theory.is_subterminal A) : category_theory.mono (category_theory.limits.terminal.from A)
theorem is_unit.nat_abs_eq {n : â„¤} : is_unit n â†’ n.nat_abs = 1
theorem category_theory.is_cofiltered.of_is_left_adjoint {C : Type u} [category_theory.category C] [category_theory.is_cofiltered C] {D : Type uâ‚} [category_theory.category D] (L : C â¥¤ D) [category_theory.is_left_adjoint L] : category_theory.is_cofiltered D
theorem map_exp (ğ•‚ : Type u_1) {ğ”¸ : Type u_2} {ğ”¹ : Type u_3} [is_R_or_C ğ•‚] [normed_ring ğ”¸] [normed_algebra ğ•‚ ğ”¸] [normed_ring ğ”¹] [normed_algebra ğ•‚ ğ”¹] [complete_space ğ”¸] {F : Type u_4} [ring_hom_class F ğ”¸ ğ”¹] (f : F) (hf : continuous â‡‘f) (x : ğ”¸) : â‡‘f (exp ğ•‚ x) = exp ğ•‚ (â‡‘f x)
theorem same_ray.add_left {R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {x y z : M} (hx : same_ray R x z) (hy : same_ray R y z) : same_ray R (x + y) z
theorem embedding.to_isometry {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [metric_space Î²] {f : Î± â†’ Î²} (h : embedding f) : isometry f
theorem isometry.edist_eq {Î± : Type u} {Î² : Type v} [pseudo_emetric_space Î±] [pseudo_emetric_space Î²] {f : Î± â†’ Î²} (hf : isometry f) (x y : Î±) : has_edist.edist (f x) (f y) = has_edist.edist x y
theorem polynomial.X_pow_mul_assoc_C {R : Type u} [semiring R] {p : polynomial R} {n : â„•} (r : R) : p * polynomial.X ^ n * â‡‘polynomial.C r = p * â‡‘polynomial.C r * polynomial.X ^ n
theorem nat.count_eq_card_fintype (p : â„• â†’ Prop) [decidable_pred p] (n : â„•) : nat.count p n = fintype.card {k // k < n âˆ§ p k}
theorem interval_integral.integral_lt_integral_of_ae_le_of_measure_set_of_lt_ne_zero {f g : â„ â†’ â„} {a b : â„} {Î¼ : measure_theory.measure â„} (hab : a â‰¤ b) (hfi : interval_integrable f Î¼ a b) (hgi : interval_integrable g Î¼ a b) (hle : f â‰¤áµ[Î¼.restrict (set.Ioc a b)] g) (hlt : â‡‘(Î¼.restrict (set.Ioc a b)) {x : â„ | f x < g x} â‰  0) : âˆ« (x : â„) in a..b, f x âˆ‚Î¼ < âˆ« (x : â„) in a..b, g x âˆ‚Î¼
theorem category_theory.limits.trident.equalizer_ext {J : Type v} {C : Type u} [category_theory.category C] {X Y : C} {f : J â†’ (X âŸ¶ Y)} [nonempty J] (s : category_theory.limits.trident f) {W : C} {k l : W âŸ¶ s.X} (h : k â‰« s.Î¹ = l â‰« s.Î¹) (j : category_theory.limits.walking_parallel_family J) : k â‰« s.Ï€.app j = l â‰« s.Ï€.app j
theorem basis.ext_elem {Î¹ : Type u_1} {R : Type u_3} {M : Type u_5} [semiring R] [add_comm_monoid M] [module R M] (b : basis Î¹ R M) {x y : M} (h : âˆ€ (i : Î¹), â‡‘(â‡‘(b.repr) x) i = â‡‘(â‡‘(b.repr) y) i) : x = y
theorem convex_cone.to_ordered_smul {ğ•œ : Type u_1} {E : Type u_2} [linear_ordered_field ğ•œ] [ordered_add_comm_group E] [module ğ•œ E] (S : convex_cone ğ•œ E) (h : âˆ€ (x y : E), x â‰¤ y â†” y - x âˆˆ S) : ordered_smul ğ•œ E
theorem mem_tangent_cone_of_segment_subset {G : Type u_4} [normed_group G] [normed_space â„ G] {s : set G} {x y : G} (h : segment â„ x y âŠ† s) : y - x âˆˆ tangent_cone_at â„ s x
theorem emetric.nonempty_of_Hausdorff_edist_ne_top {Î± : Type u} [pseudo_emetric_space Î±] {s t : set Î±} (hs : s.nonempty) (fin : emetric.Hausdorff_edist s t â‰  âŠ¤) : t.nonempty
theorem category_theory.R_faithful_of_counit_is_iso {C : Type uâ‚} [category_theory.category C] {D : Type uâ‚‚} [category_theory.category D] {L : C â¥¤ D} {R : D â¥¤ C} (h : L âŠ£ R) [category_theory.is_iso h.counit] : category_theory.faithful R
theorem add_localization.r_eq_r' {M : Type u_1} [add_comm_monoid M] (S : add_submonoid M) : add_localization.r S = add_localization.r' S
theorem finprod_mem_sUnion {Î± : Type u_1} {M : Type u_5} [comm_monoid M] {f : Î± â†’ M} {t : set (set Î±)} (h : t.pairwise_disjoint id) (htâ‚€ : t.finite) (htâ‚ : âˆ€ (x : set Î±), x âˆˆ t â†’ x.finite) : finprod (Î» (a : Î±), finprod (Î» (H : a âˆˆ â‹ƒâ‚€t), f a)) = finprod (Î» (s : set Î±), finprod (Î» (H : s âˆˆ t), finprod (Î» (a : Î±), finprod (Î» (H : a âˆˆ s), f a))))
theorem bilin_form.sum_repr_mul_repr_mul {Râ‚‚ : Type u_5} {Mâ‚‚ : Type u_6} [comm_semiring Râ‚‚] [add_comm_monoid Mâ‚‚] [module Râ‚‚ Mâ‚‚] {Bâ‚‚ : bilin_form Râ‚‚ Mâ‚‚} {Î¹ : Type u_13} (b : basis Î¹ Râ‚‚ Mâ‚‚) (x y : Mâ‚‚) : (â‡‘(b.repr) x).sum (Î» (i : Î¹) (xi : Râ‚‚), (â‡‘(b.repr) y).sum (Î» (j : Î¹) (yj : Râ‚‚), xi â€¢ yj â€¢ â‡‘Bâ‚‚ (â‡‘b i) (â‡‘b j))) = â‡‘Bâ‚‚ x y
theorem module.direct_limit.of.zero_exact {R : Type u} [ring R] {Î¹ : Type v} [dec_Î¹ : decidable_eq Î¹] [preorder Î¹] {G : Î¹ â†’ Type w} [Î  (i : Î¹), add_comm_group (G i)] [Î  (i : Î¹), module R (G i)] {f : Î  (i j : Î¹), i â‰¤ j â†’ (G i â†’â‚—[R] G j)} [directed_system G (Î» (i j : Î¹) (h : i â‰¤ j), â‡‘(f i j h))] [is_directed Î¹ has_le.le] {i : Î¹} {x : G i} (H : â‡‘(module.direct_limit.of R Î¹ G f i) x = 0) : âˆƒ (j : Î¹) (hij : i â‰¤ j), â‡‘(f i j hij) x = 0
theorem algebraic_geometry.PresheafedSpace.is_open_immersion.to_iso {C : Type u} [category_theory.category C] {X Y : algebraic_geometry.PresheafedSpace C} (f : X âŸ¶ Y) [h : algebraic_geometry.PresheafedSpace.is_open_immersion f] [h' : category_theory.epi f.base] : category_theory.is_iso f
theorem measure_theory.measure.add_haar_image_continuous_linear_map {E : Type u_1} [normed_group E] [normed_space â„ E] [measurable_space E] [borel_space E] [finite_dimensional â„ E] (Î¼ : measure_theory.measure E) [Î¼.is_add_haar_measure] (f : E â†’L[â„] E) (s : set E) : â‡‘Î¼ (â‡‘f '' s) = ennreal.of_real |â‡‘linear_map.det â†‘f| * â‡‘Î¼ s
theorem convex_on.map_sum_le {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} {Î¹ : Type u_5} [linear_ordered_field ğ•œ] [add_comm_group E] [ordered_add_comm_group Î²] [module ğ•œ E] [module ğ•œ Î²] [ordered_smul ğ•œ Î²] {s : set E} {f : E â†’ Î²} {t : finset Î¹} {w : Î¹ â†’ ğ•œ} {p : Î¹ â†’ E} (hf : convex_on ğ•œ s f) (hâ‚€ : âˆ€ (i : Î¹), i âˆˆ t â†’ 0 â‰¤ w i) (hâ‚ : t.sum (Î» (i : Î¹), w i) = 1) (hmem : âˆ€ (i : Î¹), i âˆˆ t â†’ p i âˆˆ s) : f (t.sum (Î» (i : Î¹), w i â€¢ p i)) â‰¤ t.sum (Î» (i : Î¹), w i â€¢ f (p i))
theorem fin.prod_univ_cast_succ {Î² : Type u_2} [comm_monoid Î²] {n : â„•} (f : fin (n + 1) â†’ Î²) : finset.univ.prod (Î» (i : fin (n + 1)), f i) = finset.univ.prod (Î» (i : fin n), f (â‡‘fin.cast_succ i)) * f (fin.last n)
theorem interval_integral.integral_has_fderiv_within_at {E : Type u_3} [normed_group E] [complete_space E] [normed_space â„ E] {f : â„ â†’ E} {la lb : filter â„} {a b : â„} (hf : interval_integrable f measure_theory.measure_space.volume a b) (hmeas_a : strongly_measurable_at_filter f la measure_theory.measure_space.volume) (hmeas_b : strongly_measurable_at_filter f lb measure_theory.measure_space.volume) {s t : set â„} [interval_integral.FTC_filter a (nhds_within a s) la] [interval_integral.FTC_filter b (nhds_within b t) lb] (ha : filter.tendsto f la (nhds (f a))) (hb : filter.tendsto f lb (nhds (f b))) : has_fderiv_within_at (Î» (p : â„ Ã— â„), âˆ« (x : â„) in p.fst..p.snd, f x) ((continuous_linear_map.snd â„ â„ â„).smul_right (f b) - (continuous_linear_map.fst â„ â„ â„).smul_right (f a)) (s Ã—Ë¢ t) (a, b)
theorem vadd_vsub {G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] (g : G) (p : P) : g +áµ¥ p -áµ¥ p = g
theorem cont_diff_within_at_local_invariant_prop {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] (I : model_with_corners ğ•œ E H) {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] (I' : model_with_corners ğ•œ E' H') (n : with_top â„•) : (cont_diff_groupoid âŠ¤ I).local_invariant_prop (cont_diff_groupoid âŠ¤ I') (cont_diff_within_at_prop I I' n)
theorem cont_diff_at.has_strict_deriv_at {n : with_top â„•} {ğ•‚ : Type u_6} [is_R_or_C ğ•‚] {F' : Type u_8} [normed_group F'] [normed_space ğ•‚ F'] {f : ğ•‚ â†’ F'} {x : ğ•‚} (hf : cont_diff_at ğ•‚ n f x) (hn : 1 â‰¤ n) : has_strict_deriv_at f (deriv f x) x
theorem normed_space.polar_closed_ball {ğ•œ : Type u_1} [is_R_or_C ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {r : â„} (hr : 0 < r) : normed_space.polar ğ•œ (metric.closed_ball 0 r) = metric.closed_ball 0 râ»Â¹
theorem is_field.localization_map_bijective {R : Type u_1} {Râ‚˜ : Type u_2} [comm_ring R] [comm_ring Râ‚˜] {M : submonoid R} (hM : 0 âˆ‰ M) (hR : is_field R) [algebra R Râ‚˜] [is_localization M Râ‚˜] : function.bijective â‡‘(algebra_map R Râ‚˜)
theorem has_sum.mapL {Î¹ : Type u_10} {R : Type u_11} {Râ‚‚ : Type u_12} {M : Type u_13} {Mâ‚‚ : Type u_14} [semiring R] [semiring Râ‚‚] [add_comm_monoid M] [module R M] [add_comm_monoid Mâ‚‚] [module Râ‚‚ Mâ‚‚] [topological_space M] [topological_space Mâ‚‚] {Ïƒ : R â†’+* Râ‚‚} {f : Î¹ â†’ M} (Ï† : M â†’SL[Ïƒ] Mâ‚‚) {x : M} (hf : has_sum f x) : has_sum (Î» (b : Î¹), â‡‘Ï† (f b)) (â‡‘Ï† x)
theorem padic_norm.nonneg (p : â„•) (q : â„š) : 0 â‰¤ padic_norm p q
theorem finset.inf_coe {Î± : Type u_1} {Î² : Type u_2} [semilattice_inf Î±] [order_top Î±] {P : Î± â†’ Prop} {Ptop : P âŠ¤} {Pinf : âˆ€ â¦ƒx y : Î±â¦„, P x â†’ P y â†’ P (x âŠ“ y)} (t : finset Î²) (f : Î² â†’ {x // P x}) : â†‘(t.inf f) = t.inf (Î» (x : Î²), â†‘(f x))
theorem tsum_mul_tsum_eq_tsum_sum_antidiagonal {Î± : Type u_1} {f g : â„• â†’ Î±} [topological_space Î±] [non_unital_non_assoc_semiring Î±] [regular_space Î±] [topological_semiring Î±] (hf : summable f) (hg : summable g) (hfg : summable (Î» (x : â„• Ã— â„•), f x.fst * g x.snd)) : (âˆ‘' (n : â„•), f n) * âˆ‘' (n : â„•), g n = âˆ‘' (n : â„•), (finset.nat.antidiagonal n).sum (Î» (kl : â„• Ã— â„•), f kl.fst * g kl.snd)
theorem range.is_add_submonoid {M : Type u_1} [add_monoid M] {Î³ : Type u_2} [add_monoid Î³] {f : M â†’ Î³} (hf : is_add_monoid_hom f) : is_add_submonoid (set.range f)
theorem interval_integral.integral_eq_sub_of_has_deriv_at {E : Type u_3} [normed_group E] [complete_space E] [normed_space â„ E] {f : â„ â†’ E} {a b : â„} {f' : â„ â†’ E} (hderiv : âˆ€ (x : â„), x âˆˆ set.interval a b â†’ has_deriv_at f (f' x) x) (hint : interval_integrable f' measure_theory.measure_space.volume a b) : âˆ« (y : â„) in a..b, f' y = f b - f a
theorem measurable_set.exists_is_compact_diff_lt {Î± : Type u_1} [measurable_space Î±] [topological_space Î±] {Î¼ : measure_theory.measure Î±} [opens_measurable_space Î±] [t2_space Î±] [Î¼.regular] â¦ƒA : set Î±â¦„ (hA : measurable_set A) (h'A : â‡‘Î¼ A â‰  âŠ¤) {Îµ : ennreal} (hÎµ : Îµ â‰  0) : âˆƒ (K : set Î±) (H : K âŠ† A), is_compact K âˆ§ â‡‘Î¼ (A  K) < Îµ
theorem dense_range.subset_closure_image_preimage_of_is_open {Î² : Type u_2} [topological_space Î²] {Îº : Type u_5} {f : Îº â†’ Î²} (hf : dense_range f) {s : set Î²} (hs : is_open s) : s âŠ† closure (f '' (f â»Â¹' s))
theorem add_action.stabilizer_vadd_eq_stabilizer_map_conj {Î± : Type u} {Î² : Type v} [add_group Î±] [add_action Î± Î²] (g : Î±) (x : Î²) : add_action.stabilizer Î± (g +áµ¥ x) = add_subgroup.map (add_equiv.to_add_monoid_hom (â‡‘add_aut.conj g)) (add_action.stabilizer Î± x)
theorem filter.map_mapâ‚‚_distrib_right {Î± : Type u_1} {Î² : Type u_3} {Î²' : Type u_4} {Î³ : Type u_5} {Î´ : Type u_7} {m : Î± â†’ Î² â†’ Î³} {f : filter Î±} {g : filter Î²} {n : Î³ â†’ Î´} {m' : Î± â†’ Î²' â†’ Î´} {n' : Î² â†’ Î²'} (h_distrib : âˆ€ (a : Î±) (b : Î²), n (m a b) = m' a (n' b)) : filter.map n (filter.mapâ‚‚ m f g) = filter.mapâ‚‚ m' f (filter.map n' g)
theorem category_theory.presieve.is_sheaf_for_iff_generate {C : Type uâ‚} [category_theory.category C] {P : Cáµ’áµ– â¥¤ Type w} {X : C} (R : category_theory.presieve X) : category_theory.presieve.is_sheaf_for P R â†” category_theory.presieve.is_sheaf_for P â‡‘(category_theory.sieve.generate R)
theorem acc.of_fibration {Î± : Type u_1} {Î² : Type u_2} {rÎ± : Î± â†’ Î± â†’ Prop} {rÎ² : Î² â†’ Î² â†’ Prop} (f : Î± â†’ Î²) (fib : relation.fibration rÎ± rÎ² f) {a : Î±} (ha : acc rÎ± a) : acc rÎ² (f a)
theorem affine.simplex.orthogonal_projection_circumcenter {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {n : â„•} (s : affine.simplex â„ P n) {fs : finset (fin (n + 1))} {m : â„•} (h : fs.card = m + 1) : â†‘(â‡‘((s.face h).orthogonal_projection_span) s.circumcenter) = (s.face h).circumcenter
theorem map_le_line_map_iff_slope_le_slope {k : Type u_1} {E : Type u_2} [linear_ordered_field k] [ordered_add_comm_group E] [module k E] [ordered_smul k E] {f : k â†’ E} {a b r : k} (hab : a < b) (hâ‚€ : 0 < r) (hâ‚ : r < 1) : f (â‡‘(affine_map.line_map a b) r) â‰¤ â‡‘(affine_map.line_map (f a) (f b)) r â†” slope f a (â‡‘(affine_map.line_map a b) r) â‰¤ slope f (â‡‘(affine_map.line_map a b) r) b
theorem convex_hull_basis_eq_std_simplex {R : Type u_1} (Î¹ : Type u_4) [linear_ordered_field R] [fintype Î¹] : â‡‘(convex_hull R) (set.range (Î» (i j : Î¹), ite (i = j) 1 0)) = std_simplex R Î¹
theorem commute.eq {S : Type u_1} [has_mul S] {a b : S} (h : commute a b) : a * b = b * a
theorem nnreal.rpow_arith_mean_le_arith_mean2_rpow (wâ‚ wâ‚‚ zâ‚ zâ‚‚ : nnreal) (hw' : wâ‚ + wâ‚‚ = 1) {p : â„} (hp : 1 â‰¤ p) : (wâ‚ * zâ‚ + wâ‚‚ * zâ‚‚) ^ p â‰¤ wâ‚ * zâ‚ ^ p + wâ‚‚ * zâ‚‚ ^ p
theorem euclidean_geometry.inner_weighted_vsub {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {Î¹â‚ : Type u_3} {sâ‚ : finset Î¹â‚} {wâ‚ : Î¹â‚ â†’ â„} (pâ‚ : Î¹â‚ â†’ P) (hâ‚ : sâ‚.sum (Î» (i : Î¹â‚), wâ‚ i) = 0) {Î¹â‚‚ : Type u_4} {sâ‚‚ : finset Î¹â‚‚} {wâ‚‚ : Î¹â‚‚ â†’ â„} (pâ‚‚ : Î¹â‚‚ â†’ P) (hâ‚‚ : sâ‚‚.sum (Î» (i : Î¹â‚‚), wâ‚‚ i) = 0) : has_inner.inner (â‡‘(sâ‚.weighted_vsub pâ‚) wâ‚) (â‡‘(sâ‚‚.weighted_vsub pâ‚‚) wâ‚‚) = -sâ‚.sum (Î» (iâ‚ : Î¹â‚), sâ‚‚.sum (Î» (iâ‚‚ : Î¹â‚‚), wâ‚ iâ‚ * wâ‚‚ iâ‚‚ * (has_dist.dist (pâ‚ iâ‚) (pâ‚‚ iâ‚‚) * has_dist.dist (pâ‚ iâ‚) (pâ‚‚ iâ‚‚)))) / 2
theorem finprod_mem_bUnion {Î± : Type u_1} {Î¹ : Type u_3} {M : Type u_5} [comm_monoid M] {f : Î± â†’ M} {I : set Î¹} {t : Î¹ â†’ set Î±} (h : I.pairwise_disjoint t) (hI : I.finite) (ht : âˆ€ (i : Î¹), i âˆˆ I â†’ (t i).finite) : finprod (Î» (a : Î±), finprod (Î» (H : a âˆˆ â‹ƒ (x : Î¹) (H : x âˆˆ I), t x), f a)) = finprod (Î» (i : Î¹), finprod (Î» (H : i âˆˆ I), finprod (Î» (j : Î±), finprod (Î» (H : j âˆˆ t i), f j))))
theorem padic_norm_e.nonarchimedean' {p : â„•} [fact (nat.prime p)] (q r : â„š_[p]) : padic_norm_e (q + r) â‰¤ linear_order.max (padic_norm_e q) (padic_norm_e r)
theorem complex.det_conj_lie  : â‡‘linear_map.det â†‘(complex.conj_lie.to_linear_equiv) = -1
theorem add_hom.coe_inj {M : Type u_3} {N : Type u_4} [has_add M] [has_add N] â¦ƒf g : add_hom M Nâ¦„ (h : â‡‘f = â‡‘g) : f = g
theorem measure_theory.lintegral_add_left_eq_self {G : Type u_4} [measurable_space G] {Î¼ : measure_theory.measure G} [add_group G] [has_measurable_add G] [Î¼.is_add_left_invariant] (f : G â†’ ennreal) (g : G) : âˆ«â» (x : G), f (g + x) âˆ‚Î¼ = âˆ«â» (x : G), f x âˆ‚Î¼
theorem euclidean_geometry.dist_reflection_eq_of_mem {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] (s : affine_subspace â„ P) [nonempty â†¥s] [complete_space â†¥(s.direction)] {pâ‚ : P} (hpâ‚ : pâ‚ âˆˆ s) (pâ‚‚ : P) : has_dist.dist pâ‚ (â‡‘(euclidean_geometry.reflection s) pâ‚‚) = has_dist.dist pâ‚ pâ‚‚
theorem phragmen_lindelof.quadrant_I {E : Type u_1} [normed_group E] [normed_space â„‚ E] {C : â„} {f : â„‚ â†’ E} {z : â„‚} (hd : diff_cont_on_cl â„‚ f (set.Ioi 0 Ã—â„‚ set.Ioi 0)) (hB : âˆƒ (c : â„) (H : c < 2) (B : â„), f =O[filter.comap complex.abs filter.at_top âŠ“ filter.principal (set.Ioi 0 Ã—â„‚ set.Ioi 0)] Î» (z : â„‚), real.exp (B * complex.abs z ^ c)) (hre : âˆ€ (x : â„), 0 â‰¤ x â†’ âˆ¥f â†‘xâˆ¥ â‰¤ C) (him : âˆ€ (x : â„), 0 â‰¤ x â†’ âˆ¥f (â†‘x * complex.I)âˆ¥ â‰¤ C) (hz_re : 0 â‰¤ z.re) (hz_im : 0 â‰¤ z.im) : âˆ¥f zâˆ¥ â‰¤ C
theorem add_con.map_of_surjective_eq_map_gen {M : Type u_1} {N : Type u_2} [has_add M] [has_add N] {c : add_con M} {f : M â†’ N} (H : âˆ€ (x y : M), f (x + y) = f x + f y) (h : add_con.add_ker f H â‰¤ c) (hf : function.surjective f) : c.map_gen f = c.map_of_surjective f H h hf
theorem polynomial.exists_partition_polynomial_aux {Fq : Type u_1} [fintype Fq] [field Fq] (n : â„•) {Îµ : â„} (hÎµ : 0 < Îµ) {b : polynomial Fq} (hb : b â‰  0) (A : fin n â†’ polynomial Fq) : âˆƒ (t : fin n â†’ fin (fintype.card Fq ^ âŒˆ-real.log Îµ / real.log â†‘(fintype.card Fq)âŒ‰â‚Š)), âˆ€ (iâ‚€ iâ‚ : fin n), t iâ‚€ = t iâ‚ â†” â†‘(â‡‘polynomial.card_pow_degree (A iâ‚ % b - A iâ‚€ % b)) < â‡‘polynomial.card_pow_degree b â€¢ Îµ
theorem polynomial.mem_lifts_and_degree_eq {R : Type u} [semiring R] {S : Type v} [semiring S] {f : R â†’+* S} {p : polynomial S} (hlifts : p âˆˆ polynomial.lifts f) : âˆƒ (q : polynomial R), polynomial.map f q = p âˆ§ q.degree = p.degree
theorem nat.dvd_left_injective  : function.injective has_dvd.dvd
theorem weak_dual.is_closed_image_polar_of_mem_nhds (ğ•œ : Type u_1) [nondiscrete_normed_field ğ•œ] {E : Type u_2} [semi_normed_group E] [normed_space ğ•œ E] {s : set E} (s_nhd : s âˆˆ nhds 0) : is_closed (coe_fn '' weak_dual.polar ğ•œ s)
theorem multiset.map_count_true_eq_filter_card {Î± : Type u_1} (s : multiset Î±) (p : Î± â†’ Prop) [decidable_pred p] : multiset.count true (multiset.map p s) = â‡‘multiset.card (multiset.filter p s)
theorem strict_convex.ord_connected {ğ•œ : Type u_1} [linear_ordered_field ğ•œ] [topological_space ğ•œ] [order_topology ğ•œ] {s : set ğ•œ} : strict_convex ğ•œ s â†’ s.ord_connected
theorem rack.ad_conj {R : Type u_1} [rack R] (x y : R) : rack.act (shelf.act x y) = rack.act x * rack.act y * (rack.act x)â»Â¹
theorem map_supr_of_continuous_at_of_monotone' {Î± : Type u} {Î² : Type v} [complete_linear_order Î±] [topological_space Î±] [order_topology Î±] [complete_linear_order Î²] [topological_space Î²] [order_topology Î²] {Î¹ : Sort u_1} [nonempty Î¹] {f : Î± â†’ Î²} {g : Î¹ â†’ Î±} (Cf : continuous_at f (supr g)) (Mf : monotone f) : f (â¨† (i : Î¹), g i) = â¨† (i : Î¹), f (g i)
theorem list.eq_nil_of_suffix_nil {Î± : Type u_1} {l : list Î±} : l <:+ list.nil â†’ l = list.nil
theorem module.ray.linear_equiv_smul_eq_map {R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] (e : M â‰ƒâ‚—[R] M) (v : module.ray R M) : e â€¢ v = â‡‘(module.ray.map e) v
theorem seq_closure_subset_closure {X : Type u_1} [topological_space X] (s : set X) : seq_closure s âŠ† closure s
theorem add_monoid.fg_iff {M : Type u_1} [add_monoid M] : add_monoid.fg M â†” âˆƒ (S : set M), add_submonoid.closure S = âŠ¤ âˆ§ S.finite
theorem category_theory.is_filtered.of_is_right_adjoint {C : Type u} [category_theory.category C] [category_theory.is_filtered C] {D : Type uâ‚} [category_theory.category D] (R : C â¥¤ D) [category_theory.is_right_adjoint R] : category_theory.is_filtered D
theorem dense_range.quotient {Î± : Type u} {Î² : Type v} [setoid Î±] [topological_space Î±] {f : Î² â†’ Î±} (hf : dense_range f) : dense_range (quotient.mk âˆ˜ f)
theorem Kuratowski_embedding.embedding_of_subset_isometry {Î± : Type u} [metric_space Î±] (x : â„• â†’ Î±) (H : dense_range x) : isometry (Kuratowski_embedding.embedding_of_subset x)
theorem add_pos_of_nonneg_of_pos {Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b : Î±} (ha : 0 â‰¤ a) (hb : 0 < b) : 0 < a + b
theorem mul_add_mul_lt_mul_add_mul' {Î± : Type u} [ordered_semiring Î±] {a b c d : Î±} [has_exists_add_of_le Î±] (hba : b < a) (hdc : d < c) : a â€¢ d + b â€¢ c < a â€¢ c + b â€¢ d
theorem set.finite.bdd_below {Î± : Type u} [semilattice_inf Î±] [nonempty Î±] {s : set Î±} (hs : s.finite) : bdd_below s
theorem max_chain_spec {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} : is_max_chain r (max_chain r)
theorem polynomial.is_primitive.int.irreducible_iff_irreducible_map_cast {p : polynomial â„¤} (hp : p.is_primitive) : irreducible p â†” irreducible (polynomial.map (int.cast_ring_hom â„š) p)
theorem list.chain.induction_head {Î± : Type u} {r : Î± â†’ Î± â†’ Prop} {a b : Î±} (p : Î± â†’ Prop) (l : list Î±) (h : list.chain r a l) (hb : (a :: l).last _ = b) (carries : âˆ€ â¦ƒx y : Î±â¦„, r x y â†’ p y â†’ p x) (final : p b) : p a
theorem strict_concave_on_open_of_deriv2_neg {D : set â„} (hD : convex â„ D) (hDâ‚‚ : is_open D) {f : â„ â†’ â„} (hf' : differentiable_on â„ f D) (hf'' : âˆ€ (x : â„), x âˆˆ D â†’ deriv^[2] f x < 0) : strict_concave_on â„ D f
theorem is_compact.elim_finite_subcover {Î± : Type u} [topological_space Î±] {s : set Î±} {Î¹ : Type v} (hs : is_compact s) (U : Î¹ â†’ set Î±) (hUo : âˆ€ (i : Î¹), is_open (U i)) (hsU : s âŠ† â‹ƒ (i : Î¹), U i) : âˆƒ (t : finset Î¹), s âŠ† â‹ƒ (i : Î¹) (H : i âˆˆ t), U i
theorem relation.church_rosser {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} {a b c : Î±} (h : âˆ€ (a b c : Î±), r a b â†’ r a c â†’ (âˆƒ (d : Î±), relation.refl_gen r b d âˆ§ relation.refl_trans_gen r c d)) (hab : relation.refl_trans_gen r a b) (hac : relation.refl_trans_gen r a c) : relation.join (relation.refl_trans_gen r) b c
theorem metric.dist_le_diam_of_mem {Î± : Type u} [pseudo_metric_space Î±] {s : set Î±} {x y : Î±} (h : metric.bounded s) (hx : x âˆˆ s) (hy : y âˆˆ s) : has_dist.dist x y â‰¤ metric.diam s
theorem convex.subset_interior_image_homothety_of_one_lt {E : Type u_2} [add_comm_group E] [module â„ E] [topological_space E] [topological_add_group E] [has_continuous_smul â„ E] {s : set E} (hs : convex â„ s) {x : E} (hx : x âˆˆ interior s) (t : â„) (ht : 1 < t) : s âŠ† interior (â‡‘(affine_map.homothety x t) '' s)
theorem multilinear_map.comp_linear_equiv_eq_zero_iff {R : Type u} {Î¹ : Type u'} {Mâ‚ : Î¹ â†’ Type vâ‚} {Mâ‚‚ : Type vâ‚‚} [decidable_eq Î¹] [semiring R] [Î  (i : Î¹), add_comm_monoid (Mâ‚ i)] [add_comm_monoid Mâ‚‚] [Î  (i : Î¹), module R (Mâ‚ i)] [module R Mâ‚‚] {Mâ‚' : Î¹ â†’ Type u_1} [Î  (i : Î¹), add_comm_monoid (Mâ‚' i)] [Î  (i : Î¹), module R (Mâ‚' i)] (g : multilinear_map R Mâ‚' Mâ‚‚) (f : Î  (i : Î¹), Mâ‚ i â‰ƒâ‚—[R] Mâ‚' i) : g.comp_linear_map (Î» (i : Î¹), â†‘(f i)) = 0 â†” g = 0
theorem Top.presheaf.is_sheaf_opens_le_cover_iff_is_sheaf_pairwise_intersections {C : Type u} [category_theory.category C] {X : Top} (F : Top.presheaf C X) : F.is_sheaf_opens_le_cover â†” F.is_sheaf_pairwise_intersections
theorem finsupp.add_hom_ext' {Î± : Type u_1} {M : Type u_5} {N : Type u_7} [add_zero_class M] [add_zero_class N] â¦ƒf g : (Î± â†’â‚€ M) â†’+ Nâ¦„ (H : âˆ€ (x : Î±), f.comp (finsupp.single_add_hom x) = g.comp (finsupp.single_add_hom x)) : f = g
theorem bump_covering.exists_is_subordinate_of_locally_finite_of_prop {Î¹ : Type u} {X : Type v} [topological_space X] {s : set X} [normal_space X] (p : (X â†’ â„) â†’ Prop) (h01 : âˆ€ (s t : set X), is_closed s â†’ is_closed t â†’ disjoint s t â†’ (âˆƒ (f : C(X, â„)), p â‡‘f âˆ§ set.eq_on â‡‘f 0 s âˆ§ set.eq_on â‡‘f 1 t âˆ§ âˆ€ (x : X), â‡‘f x âˆˆ set.Icc 0 1)) (hs : is_closed s) (U : Î¹ â†’ set X) (ho : âˆ€ (i : Î¹), is_open (U i)) (hf : locally_finite U) (hU : s âŠ† â‹ƒ (i : Î¹), U i) : âˆƒ (f : bump_covering Î¹ X s), (âˆ€ (i : Î¹), p â‡‘(â‡‘f i)) âˆ§ f.is_subordinate U
theorem metric.nonempty_Inter_of_nonempty_bInter {Î± : Type u} [pseudo_metric_space Î±] [complete_space Î±] {s : â„• â†’ set Î±} (hs : âˆ€ (n : â„•), is_closed (s n)) (h's : âˆ€ (n : â„•), metric.bounded (s n)) (h : âˆ€ (N : â„•), (â‹‚ (n : â„•) (H : n â‰¤ N), s n).nonempty) (h' : filter.tendsto (Î» (n : â„•), metric.diam (s n)) filter.at_top (nhds 0)) : (â‹‚ (n : â„•), s n).nonempty
theorem add_mul {R : Type x} [has_mul R] [has_add R] [right_distrib_class R] (a b c : R) : (a + b) * c = a * c + b * c
theorem equiv.perm.cycle_factors_finset_noncomm_prod {Î± : Type u_1} [decidable_eq Î±] [fintype Î±] (f : equiv.perm Î±) (comm : (âˆ€ (g : equiv.perm Î±), g âˆˆ f.cycle_factors_finset â†’ âˆ€ (h : equiv.perm Î±), h âˆˆ f.cycle_factors_finset â†’ commute (id g) (id h)) := _) : f.cycle_factors_finset.noncomm_prod id comm = f
theorem lie_ideal.comap_map_le {R : Type u} {L : Type v} {L' : Type wâ‚‚} [comm_ring R] [lie_ring L] [lie_algebra R L] [lie_ring L'] [lie_algebra R L'] {f : L â†’â‚—â…Râ† L'} {I : lie_ideal R L} : I â‰¤ lie_ideal.comap f (lie_ideal.map f I)
theorem norm_add_sq_eq_norm_sq_add_norm_sq_iff_real_inner_eq_zero {F : Type u_3} [inner_product_space â„ F] (x y : F) : âˆ¥x + yâˆ¥ * âˆ¥x + yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + âˆ¥yâˆ¥ * âˆ¥yâˆ¥ â†” has_inner.inner x y = 0
theorem zero_lt.left.mul_lt_one_of_lt_of_le {Î± : Type u} {a b : Î±} [mul_one_class Î±] [has_zero Î±] [preorder Î±] [zero_lt.pos_mul_mono Î±] (ha : a < 1) (hb : b â‰¤ 1) (a0 : 0 < a) : a * b < 1
theorem has_subset.subset.ssubset_of_not_subset {Î± : Type u} [has_subset Î±] [has_ssubset Î±] [is_nonstrict_strict_order Î± has_subset.subset has_ssubset.ssubset] {a b : Î±} (hâ‚ : a âŠ† b) (hâ‚‚ : Â¬b âŠ† a) : a âŠ‚ b
theorem exists_multiset_prod_cons_le_and_prod_not_le {A : Type u_2} [comm_ring A] [is_domain A] [is_dedekind_domain A] (hNF : Â¬is_field A) {I M : ideal A} (hI0 : I â‰  âŠ¥) (hIM : I â‰¤ M) [hM : M.is_maximal] : âˆƒ (Z : multiset (prime_spectrum A)), (M ::â‚˜ multiset.map prime_spectrum.as_ideal Z).prod â‰¤ I âˆ§ Â¬(multiset.map prime_spectrum.as_ideal Z).prod â‰¤ I
theorem finprod_mem_eq_of_bij_on {Î± : Type u_1} {Î² : Type u_2} {M : Type u_5} [comm_monoid M] {s : set Î±} {t : set Î²} {f : Î± â†’ M} {g : Î² â†’ M} (e : Î± â†’ Î²) (heâ‚€ : set.bij_on e s t) (heâ‚ : âˆ€ (x : Î±), x âˆˆ s â†’ f x = g (e x)) : finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), f i)) = finprod (Î» (j : Î²), finprod (Î» (H : j âˆˆ t), g j))
theorem witt_vector.frobenius_is_poly (p : â„•) [hp : fact (nat.prime p)] : witt_vector.is_poly p (Î» (R : Type u_1) (_Rcr : comm_ring R), â‡‘witt_vector.frobenius)
theorem padic_val_rat.le_padic_val_rat_add_of_le (p : â„•) [p_prime : fact (nat.prime p)] {q r : â„š} (hqr : q + r â‰  0) (h : padic_val_rat p q â‰¤ padic_val_rat p r) : padic_val_rat p q â‰¤ padic_val_rat p (q + r)
theorem is_top.of_dual {Î± : Type u_1} [has_le Î±] {a : Î±áµ’áµˆ} : is_top a â†’ is_bot (â‡‘order_dual.of_dual a)
theorem fintype.eq_of_subsingleton_of_prod_eq {M : Type u_4} [comm_monoid M] {Î¹ : Type u_1} [subsingleton Î¹] {s : finset Î¹} {f : Î¹ â†’ M} {b : M} (h : s.prod (Î» (i : Î¹), f i) = b) (i : Î¹) (H : i âˆˆ s) : f i = b
theorem real.mul_le_sin {x : â„} (hx : 0 â‰¤ x) (hx' : x â‰¤ real.pi / 2) : 2 / real.pi * x â‰¤ real.sin x
theorem orthogonal_projection_mem_subspace_eq_self {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {K : submodule ğ•œ E} [complete_space â†¥K] (v : â†¥K) : â‡‘(orthogonal_projection K) â†‘v = v
theorem affine_independent.subtype {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {Î¹ : Type u_4} {p : Î¹ â†’ P} (ha : affine_independent k p) (s : set Î¹) : affine_independent k (Î» (i : â†¥s), p â†‘i)
theorem quotient_add_group.add_monoid_hom_ext {G : Type u} [add_group G] (N : add_subgroup G) [nN : N.normal] {H : Type v} [add_group H] â¦ƒf g : G â§¸ N â†’+ Hâ¦„ (h : f.comp (quotient_add_group.mk' N) = g.comp (quotient_add_group.mk' N)) : f = g
theorem metric.mem_thickening_iff {Î´ : â„} {X : Type u} [pseudo_metric_space X] {E : set X} {x : X} : x âˆˆ metric.thickening Î´ E â†” âˆƒ (z : X) (H : z âˆˆ E), has_dist.dist x z < Î´
theorem interval_integral.integral_comp_smul_deriv'' {E : Type u_3} [normed_group E] [complete_space E] [normed_space â„ E] {a b : â„} {f f' : â„ â†’ â„} {g : â„ â†’ E} (hf : continuous_on f (set.interval a b)) (hff' : âˆ€ (x : â„), x âˆˆ set.Ioo (linear_order.min a b) (linear_order.max a b) â†’ has_deriv_within_at f (f' x) (set.Ioi x) x) (hf' : continuous_on f' (set.interval a b)) (hg : continuous_on g (f '' set.interval a b)) : âˆ« (x : â„) in a..b, f' x â€¢ (g âˆ˜ f) x = âˆ« (u : â„) in f a..f b, g u
theorem Module.homology_ext {R : Type v} [ring R] {L M N K : Module R} {f : L âŸ¶ M} {g : M âŸ¶ N} (w : f â‰« g = 0) {h k : homology f g w âŸ¶ K} (w_1 : âˆ€ (x : â†¥(linear_map.ker g)), â‡‘h (â‡‘(category_theory.limits.cokernel.Ï€ (image_to_kernel f g w)) (â‡‘Module.to_kernel_subobject x)) = â‡‘k (â‡‘(category_theory.limits.cokernel.Ï€ (image_to_kernel f g w)) (â‡‘Module.to_kernel_subobject x))) : h = k
theorem padic_val_rat.of_nat {p n : â„•} : padic_val_rat p â†‘n = â†‘(padic_val_nat p n)
theorem orthonormal.rotation_pi {V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) : hb.rotation â†‘real.pi = linear_isometry_equiv.neg â„
theorem category_theory.limits.has_limits_of_shape_op_of_has_colimits_of_shape {C : Type uâ‚} [category_theory.category C] {J : Type uâ‚‚} [category_theory.category J] [category_theory.limits.has_colimits_of_shape Jáµ’áµ– C] : category_theory.limits.has_limits_of_shape J Cáµ’áµ–
theorem minpoly.root {A : Type u_1} {B : Type u_2} [field A] [ring B] [is_domain B] [algebra A B] {x : B} (hx : is_integral A x) {y : A} (h : (minpoly A x).is_root y) : â‡‘(algebra_map A B) y = x
theorem structure_groupoid.compatible_of_mem_maximal_atlas {H : Type u} {M : Type u_2} [topological_space H] [topological_space M] [charted_space H M] {G : structure_groupoid H} {e e' : local_homeomorph M H} (he : e âˆˆ structure_groupoid.maximal_atlas M G) (he' : e' âˆˆ structure_groupoid.maximal_atlas M G) : e.symm.trans e' âˆˆ G
theorem is_max.to_dual {Î± : Type u_1} [has_le Î±] {a : Î±} : is_max a â†’ is_min (â‡‘order_dual.to_dual a)
theorem category_theory.functor.initial.has_limit_of_comp {C : Type v} [category_theory.small_category C] {D : Type v} [category_theory.small_category D] (F : C â¥¤ D) [F.initial] {E : Type u} [category_theory.category E] {G : D â¥¤ E} [category_theory.limits.has_limit (F â‹™ G)] : category_theory.limits.has_limit G
theorem measure_theory.outer_measure.null_of_locally_null {Î± : Type u_1} [topological_space Î±] [topological_space.second_countable_topology Î±] (m : measure_theory.outer_measure Î±) (s : set Î±) (hs : âˆ€ (x : Î±), x âˆˆ s â†’ (âˆƒ (u : set Î±) (H : u âˆˆ nhds_within x s), â‡‘m u = 0)) : â‡‘m s = 0
theorem asymptotics.is_o.of_is_O_with {Î± : Type u_1} {E : Type u_3} {F : Type u_4} [has_norm E] [has_norm F] {f : Î± â†’ E} {g : Î± â†’ F} {l : filter Î±} : (âˆ€ â¦ƒc : â„â¦„, 0 < c â†’ asymptotics.is_O_with c l f g) â†’ f =o[l] g
theorem exists_lt_of_lt_csupr {Î± : Type u_1} {Î¹ : Sort u_3} [conditionally_complete_linear_order Î±] {b : Î±} [nonempty Î¹] {f : Î¹ â†’ Î±} (h : b < supr f) : âˆƒ (i : Î¹), b < f i
theorem is_open_analytic_at (ğ•œ : Type u_1) {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field ğ•œ] [normed_group E] [normed_space ğ•œ E] [normed_group F] [normed_space ğ•œ F] [complete_space F] (f : E â†’ F) : is_open {x : E | analytic_at ğ•œ f x}
theorem equiv.perm.swap_induction_on {Î± : Type u} [decidable_eq Î±] [fintype Î±] {P : equiv.perm Î± â†’ Prop} (f : equiv.perm Î±) : P 1 â†’ (âˆ€ (f : equiv.perm Î±) (x y : Î±), x â‰  y â†’ P f â†’ P (equiv.swap x y * f)) â†’ P f
theorem mul_hom.coe_inj {M : Type u_3} {N : Type u_4} [has_mul M] [has_mul N] â¦ƒf g : M â†’â‚™* Nâ¦„ (h : â‡‘f = â‡‘g) : f = g
theorem is_preconnected_Icc {Î± : Type u} [conditionally_complete_linear_order Î±] [topological_space Î±] [order_topology Î±] [densely_ordered Î±] {a b : Î±} : is_preconnected (set.Icc a b)
theorem exists_local_extr_Ioo (f : â„ â†’ â„) {a b : â„} (hab : a < b) (hfc : continuous_on f (set.Icc a b)) (hfI : f a = f b) : âˆƒ (c : â„) (H : c âˆˆ set.Ioo a b), is_local_extr f c
theorem subgroup.normalizer_condition.normal_of_coatom {G : Type u_1} [group G] (H : subgroup G) (hnc : normalizer_condition G) (hmax : is_coatom H) : H.normal
theorem submonoid.localization_map.map_map {M : Type u_1} [comm_monoid M] {S : submonoid M} {N : Type u_2} [comm_monoid N] {P : Type u_3} [comm_monoid P] (f : S.localization_map N) {g : M â†’* P} {T : submonoid P} (hy : âˆ€ (y : â†¥S), â‡‘g â†‘y âˆˆ T) {Q : Type u_4} [comm_monoid Q] {k : T.localization_map Q} {A : Type u_5} [comm_monoid A] {U : submonoid A} {R : Type u_6} [comm_monoid R] (j : U.localization_map R) {l : P â†’* A} (hl : âˆ€ (w : â†¥T), â‡‘l â†‘w âˆˆ U) (x : N) : â‡‘(k.map hl j) (â‡‘(f.map hy k) x) = â‡‘(f.map _ j) x
theorem order.pfilter.ext {P : Type u_1} [preorder P] (s t : order.pfilter P) (h : â†‘s = â†‘t) : s = t
theorem inv_le {Î± : Type u_1} [linear_ordered_field Î±] {a b : Î±} (ha : 0 < a) (hb : 0 < b) : aâ»Â¹ â‰¤ b â†” bâ»Â¹ â‰¤ a
theorem submodule.coe_sum {R : Type u} {M : Type v} {Î¹ : Type w} [semiring R] [add_comm_monoid M] {module_M : module R M} (p : submodule R M) (x : Î¹ â†’ â†¥p) (s : finset Î¹) : â†‘(s.sum (Î» (i : Î¹), x i)) = s.sum (Î» (i : Î¹), â†‘(x i))
theorem measure_theory.integral_divergence_of_has_fderiv_within_at_off_countable_auxâ‚ {E : Type u} [normed_group E] [normed_space â„ E] [complete_space E] {n : â„•} (I : box_integral.box (fin (n + 1))) (f : (fin (n + 1) â†’ â„) â†’ fin (n + 1) â†’ E) (f' : (fin (n + 1) â†’ â„) â†’ ((fin (n + 1) â†’ â„) â†’L[â„] fin (n + 1) â†’ E)) (s : set (fin (n + 1) â†’ â„)) (hs : s.countable) (Hc : continuous_on f (â‡‘box_integral.box.Icc I)) (Hd : âˆ€ (x : fin (n + 1) â†’ â„), x âˆˆ â‡‘box_integral.box.Icc I  s â†’ has_fderiv_within_at f (f' x) (â‡‘box_integral.box.Icc I) x) (Hi : measure_theory.integrable_on (Î» (x : fin (n + 1) â†’ â„), finset.univ.sum (Î» (i : fin (n + 1)), â‡‘(f' x) (pi.single i 1) i)) (â‡‘box_integral.box.Icc I) measure_theory.measure_space.volume) : âˆ« (x : fin (n + 1) â†’ â„) in â‡‘box_integral.box.Icc I, finset.univ.sum (Î» (i : fin (n + 1)), â‡‘(f' x) (pi.single i 1) i) = finset.univ.sum (Î» (i : fin (n + 1)), (âˆ« (x : fin n â†’ â„) in â‡‘box_integral.box.Icc (I.face i), f (i.insert_nth (I.upper i) x) i) - âˆ« (x : fin n â†’ â„) in â‡‘box_integral.box.Icc (I.face i), f (i.insert_nth (I.lower i) x) i)
theorem reflection_symm {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {K : submodule ğ•œ E} [complete_space â†¥K] : (reflection K).symm = reflection K
theorem mul_mem_class.mul_left_mem_add_closure {M : Type u_1} {R : Type u_4} [non_unital_non_assoc_semiring R] [set_like M R] [mul_mem_class M R] {S : M} {a b : R} (ha : a âˆˆ S) (hb : b âˆˆ add_submonoid.closure â†‘S) : a * b âˆˆ add_submonoid.closure â†‘S
theorem galois_connection.exists_eq_u {Î± : Type u} {Î² : Type v} [partial_order Î±] [preorder Î²] {l : Î± â†’ Î²} {u : Î² â†’ Î±} (gc : galois_connection l u) (a : Î±) : (âˆƒ (b : Î²), a = u b) â†” a = u (l a)
theorem submodule.supr_induction' {R : Type u_1} {M : Type u_4} [semiring R] [add_comm_monoid M] [module R M] {Î¹ : Sort u_2} (p : Î¹ â†’ submodule R M) {C : Î  (x : M), (x âˆˆ â¨† (i : Î¹), p i) â†’ Prop} (hp : âˆ€ (i : Î¹) (x : M) (H : x âˆˆ p i), C x _) (h0 : C 0 _) (hadd : âˆ€ (x y : M) (hx : x âˆˆ â¨† (i : Î¹), p i) (hy : y âˆˆ â¨† (i : Î¹), p i), C x hx â†’ C y hy â†’ C (x + y) _) {x : M} (hx : x âˆˆ â¨† (i : Î¹), p i) : C x hx
theorem box_integral.prepartition.exists_Union_eq_diff {Î¹ : Type u_1} {I : box_integral.box Î¹} [fintype Î¹] (Ï€ : box_integral.prepartition I) : âˆƒ (Ï€' : box_integral.prepartition I), Ï€'.Union = â†‘I  Ï€.Union
theorem apply_ite2 {Î± : Sort u_1} {Î² : Sort u_2} {Î³ : Sort u_3} (f : Î± â†’ Î² â†’ Î³) (P : Prop) [decidable P] (a b : Î±) (c d : Î²) : f (ite P a b) (ite P c d) = ite P (f a c) (f b d)
theorem path.continuous_extend {X : Type u_1} [topological_space X] {x y : X} (Î³ : path x y) : continuous Î³.extend
theorem strict_concave_on.lt_on_open_segment {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [ordered_semiring ğ•œ] [add_comm_monoid E] [linear_ordered_add_comm_monoid Î²] [has_scalar ğ•œ E] [module ğ•œ Î²] [ordered_smul ğ•œ Î²] {s : set E} {f : E â†’ Î²} (hf : strict_concave_on ğ•œ s f) {x y z : E} (hx : x âˆˆ s) (hy : y âˆˆ s) (hxy : x â‰  y) (hz : z âˆˆ open_segment ğ•œ x y) : linear_order.min (f x) (f y) < f z
theorem category_theory.exponential_ideal.mk' {C : Type uâ‚} {D : Type uâ‚‚} [category_theory.category C] [category_theory.category D] (i : D â¥¤ C) [category_theory.limits.has_finite_products C] [category_theory.cartesian_closed C] (h : âˆ€ (B : D) (A : C), (category_theory.exp A).obj (i.obj B) âˆˆ i.ess_image) : category_theory.exponential_ideal i
theorem left.add_nonneg {Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : 0 â‰¤ a) (hb : 0 â‰¤ b) : 0 â‰¤ a + b
theorem measure_theory.outer_measure.restrict_trim {Î± : Type u_1} [measurable_space Î±] {Î¼ : measure_theory.outer_measure Î±} {s : set Î±} (hs : measurable_set s) : (â‡‘(measure_theory.outer_measure.restrict s) Î¼).trim = â‡‘(measure_theory.outer_measure.restrict s) Î¼.trim
theorem set.range_unique {Î± : Type u} {Î¹ : Sort x} {f : Î¹ â†’ Î±} [h : unique Î¹] : set.range f = {f inhabited.default}
theorem finite_dimensional.finrank_pos_iff {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] : 0 < finite_dimensional.finrank K V â†” nontrivial V
theorem add_hom.map_mclosure {M : Type u_1} {N : Type u_2} [has_add M] [has_add N] (f : add_hom M N) (s : set M) : add_subsemigroup.map f (add_subsemigroup.closure s) = add_subsemigroup.closure (â‡‘f '' s)
theorem real.map_linear_map_volume_pi_eq_smul_volume_pi {Î¹ : Type u_1} [fintype Î¹] {f : (Î¹ â†’ â„) â†’â‚—[â„] Î¹ â†’ â„} (hf : â‡‘linear_map.det f â‰  0) : measure_theory.measure.map â‡‘f measure_theory.measure_space.volume = ennreal.of_real |(â‡‘linear_map.det f)â»Â¹| â€¢ measure_theory.measure_space.volume
theorem multiset.nat.mem_antidiagonal {n : â„•} {x : â„• Ã— â„•} : x âˆˆ multiset.nat.antidiagonal n â†” x.fst + x.snd = n
theorem monoid_hom.map_finprod_mem {Î± : Type u_1} {M : Type u_5} {N : Type u_6} [comm_monoid M] [comm_monoid N] {s : set Î±} (f : Î± â†’ M) (g : M â†’* N) (hs : s.finite) : â‡‘g (finprod (Î» (j : Î±), finprod (Î» (H : j âˆˆ s), f j))) = finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), â‡‘g (f i)))
theorem orthonormal.eq_iff_oangle_eq_zero_of_norm_eq {V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) {x y : V} (h : âˆ¥xâˆ¥ = âˆ¥yâˆ¥) : x = y â†” hb.oangle x y = 0
theorem measure_theory.measure.restrict_union_congr {Î± : Type u_1} {m0 : measurable_space Î±} {Î¼ Î½ : measure_theory.measure Î±} {s t : set Î±} : Î¼.restrict (s âˆª t) = Î½.restrict (s âˆª t) â†” Î¼.restrict s = Î½.restrict s âˆ§ Î¼.restrict t = Î½.restrict t
theorem orthonormal.linear_equiv_det_rotation {V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) (Î¸ : real.angle) : â‡‘linear_equiv.det (hb.rotation Î¸).to_linear_equiv = 1
theorem measure_theory.bounded_continuous_function.inner_to_Lp {Î± : Type u_1} [topological_space Î±] [measure_theory.measure_space Î±] [borel_space Î±] {ğ•œ : Type u_2} [is_R_or_C ğ•œ] (Î¼ : measure_theory.measure Î±) [measure_theory.is_finite_measure Î¼] (f g : bounded_continuous_function Î± ğ•œ) : has_inner.inner (â‡‘(bounded_continuous_function.to_Lp 2 Î¼ ğ•œ) f) (â‡‘(bounded_continuous_function.to_Lp 2 Î¼ ğ•œ) g) = âˆ« (x : Î±), â‡‘(star_ring_end ğ•œ) (â‡‘f x) * â‡‘g x âˆ‚Î¼
theorem vsub_add_vsub_cancel {G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] (p1 p2 p3 : P) : p1 -áµ¥ p2 + (p2 -áµ¥ p3) = p1 -áµ¥ p3
theorem finsupp.prod_add_index {Î± : Type u_1} {M : Type u_5} {N : Type u_7} [add_zero_class M] [comm_monoid N] {f g : Î± â†’â‚€ M} {h : Î± â†’ M â†’ N} (h_zero : âˆ€ (a : Î±), a âˆˆ f.support âˆª g.support â†’ h a 0 = 1) (h_add : âˆ€ (a : Î±), a âˆˆ f.support âˆª g.support â†’ âˆ€ (bâ‚ bâ‚‚ : M), h a (bâ‚ + bâ‚‚) = h a bâ‚ * h a bâ‚‚) : (f + g).prod h = f.prod h * g.prod h
theorem is_primitive_root.sub_one_norm_is_prime_pow {n : â„•+} {K : Type u} {L : Type v} [field L] {Î¶ : L} (hÎ¶ : is_primitive_root Î¶ â†‘n) [field K] [algebra K L] [ne_zero â†‘â†‘n] (hn : is_prime_pow â†‘n) [is_cyclotomic_extension {n} K L] (hirr : irreducible (polynomial.cyclotomic â†‘n K)) (h : n â‰  2) : â‡‘(algebra.norm K) (Î¶ - 1) = â†‘(â†‘n.min_fac)
theorem ordinal.bdd_above_range {Î¹ : Type u} (f : Î¹ â†’ ordinal) : bdd_above (set.range f)
theorem neg_vsub_eq_vsub_rev {G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] (p1 p2 : P) : -(p1 -áµ¥ p2) = p2 -áµ¥ p1
theorem set.mem_of_mul_indicator_ne_one {Î± : Type u_1} {M : Type u_4} [has_one M] {s : set Î±} {f : Î± â†’ M} {a : Î±} (h : s.mul_indicator f a â‰  1) : a âˆˆ s
theorem antitone.map_is_greatest {Î± : Type u} {Î² : Type v} [preorder Î±] [preorder Î²] {f : Î± â†’ Î²} (hf : antitone f) {a : Î±} {s : set Î±} : is_greatest s a â†’ is_least (f '' s) (f a)
theorem cardinal.ord_aleph'_eq_enum_card  : cardinal.ord âˆ˜ cardinal.aleph' = ordinal.enum_ord {b : ordinal | b.card.ord = b}
theorem mv_polynomial.exists_finset_rename {Ïƒ : Type u_1} {R : Type u_4} [comm_semiring R] (p : mv_polynomial Ïƒ R) : âˆƒ (s : finset Ïƒ) (q : mv_polynomial {x // x âˆˆ s} R), p = â‡‘(mv_polynomial.rename coe) q
theorem is_extr_filter.undual {Î± : Type u} {Î² : Type v} [preorder Î²] {f : Î± â†’ Î²} {l : filter Î±} {a : Î±} : is_extr_filter (â‡‘order_dual.to_dual âˆ˜ f) l a â†’ is_extr_filter f l a
theorem nat.totient_div_of_dvd {n d : â„•} (hnd : d âˆ£ n) : (n / d).totient = (finset.filter (Î» (k : â„•), n.gcd k = d) (finset.range n)).card
theorem mul_dvd_mul_iff_right {Î± : Type u_1} [cancel_comm_monoid_with_zero Î±] {a b c : Î±} (hc : c â‰  0) : a * c âˆ£ b * c â†” a âˆ£ b
theorem finset.image_imageâ‚‚_distrib_right {Î± : Type u_1} {Î² : Type u_3} {Î²' : Type u_4} {Î³ : Type u_5} {Î´ : Type u_7} [decidable_eq Î²'] [decidable_eq Î³] [decidable_eq Î´] {f : Î± â†’ Î² â†’ Î³} {s : finset Î±} {t : finset Î²} {g : Î³ â†’ Î´} {f' : Î± â†’ Î²' â†’ Î´} {g' : Î² â†’ Î²'} (h_distrib : âˆ€ (a : Î±) (b : Î²), g (f a b) = f' a (g' b)) : finset.image g (finset.imageâ‚‚ f s t) = finset.imageâ‚‚ f' s (finset.image g' t)
theorem measurable_measure_prod_mk_right {Î± : Type u_1} {Î² : Type u_3} [measurable_space Î±] [measurable_space Î²] {Î¼ : measure_theory.measure Î±} [measure_theory.sigma_finite Î¼] {s : set (Î± Ã— Î²)} (hs : measurable_set s) : measurable (Î» (y : Î²), â‡‘Î¼ ((Î» (x : Î±), (x, y)) â»Â¹' s))
theorem measure_theory.add_haar_image_eq_zero_of_det_fderiv_within_eq_zero_aux {E : Type u_1} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] {s : set E} {f : E â†’ E} {f' : E â†’ (E â†’L[â„] E)} [measurable_space E] [borel_space E] (Î¼ : measure_theory.measure E) [Î¼.is_add_haar_measure] (hf' : âˆ€ (x : E), x âˆˆ s â†’ has_fderiv_within_at f (f' x) s x) (R : â„) (hs : s âŠ† metric.closed_ball 0 R) (Îµ : nnreal) (Îµpos : 0 < Îµ) (h'f' : âˆ€ (x : E), x âˆˆ s â†’ (f' x).det = 0) : â‡‘Î¼ (f '' s) â‰¤ â†‘Îµ * â‡‘Î¼ (metric.closed_ball 0 R)
theorem extend_partial_order {Î± : Type u} (r : Î± â†’ Î± â†’ Prop) [is_partial_order Î± r] : âˆƒ (s : Î± â†’ Î± â†’ Prop) (_x : is_linear_order Î± s), r â‰¤ s
theorem antitone_on.map_is_least {Î± : Type u} {Î² : Type v} [preorder Î±] [preorder Î²] {f : Î± â†’ Î²} {t : set Î±} (Hf : antitone_on f t) {a : Î±} : is_least t a â†’ is_greatest (f '' t) (f a)
theorem commute.mul_right {S : Type u_1} [semigroup S] {a b c : S} (hab : commute a b) (hac : commute a c) : commute a (b * c)
theorem circle_deg1_lift.exists_eq_add_translation_number (f : circle_deg1_lift) (hf : continuous â‡‘f) : âˆƒ (x : â„), â‡‘f x = x + f.translation_number
theorem is_greatest.cSup_eq {Î± : Type u_1} [conditionally_complete_lattice Î±] {s : set Î±} {a : Î±} (H : is_greatest s a) : has_Sup.Sup s = a
theorem collinear_singleton (k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] (p : P) : collinear k {p}
theorem mk_complex  : cardinal.mk â„‚ = cardinal.continuum
theorem measure_theory.measure.finite_at_filter.of_inf_ae {Î± : Type u_1} {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {f : filter Î±} : Î¼.finite_at_filter (f âŠ“ Î¼.ae) â†’ Î¼.finite_at_filter f
theorem subfield.closure_induction {K : Type u} [field K] {s : set K} {p : K â†’ Prop} {x : K} (h : x âˆˆ subfield.closure s) (Hs : âˆ€ (x : K), x âˆˆ s â†’ p x) (H1 : p 1) (Hadd : âˆ€ (x y : K), p x â†’ p y â†’ p (x + y)) (Hneg : âˆ€ (x : K), p x â†’ p (-x)) (Hinv : âˆ€ (x : K), p x â†’ p xâ»Â¹) (Hmul : âˆ€ (x y : K), p x â†’ p y â†’ p (x * y)) : p x
theorem finset.order_emb_of_fin_unique {Î± : Type u_1} [linear_order Î±] {s : finset Î±} {k : â„•} (h : s.card = k) {f : fin k â†’ Î±} (hfs : âˆ€ (x : fin k), f x âˆˆ s) (hmono : strict_mono f) : f = â‡‘(s.order_emb_of_fin h)
theorem finsum_mem_empty {Î± : Type u_1} {M : Type u_5} [add_comm_monoid M] {f : Î± â†’ M} : finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ âˆ…), f i)) = 0
theorem matrix.is_adj_matrix.adj_matrix_to_graph_eq {V : Type u_1} {Î± : Type u_2} [mul_zero_one_class Î±] [nontrivial Î±] {A : matrix V V Î±} (h : A.is_adj_matrix) [decidable_eq Î±] : simple_graph.adj_matrix Î± h.to_graph = A
theorem submodule.finrank_add_finrank_orthogonal' {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] [finite_dimensional ğ•œ E] {K : submodule ğ•œ E} {n : â„•} (h_dim : finite_dimensional.finrank ğ•œ â†¥K + n = finite_dimensional.finrank ğ•œ E) : finite_dimensional.finrank ğ•œ â†¥Ká—® = n
theorem pythagorean_triple.zero  : pythagorean_triple 0 0 0
theorem strict_mono_on.strict_convex_on_of_deriv {D : set â„} (hD : convex â„ D) {f : â„ â†’ â„} (hf : continuous_on f D) (hf' : differentiable_on â„ f (interior D)) (hf'_mono : strict_mono_on (deriv f) (interior D)) : strict_convex_on â„ D f
theorem category_theory.simplicial_object.Î´_comp_Ïƒ_of_le {C : Type u} [category_theory.category C] (X : category_theory.simplicial_object C) {n : â„•} {i : fin (n + 2)} {j : fin (n + 1)} (H : i â‰¤ â‡‘fin.cast_succ j) : X.Ïƒ j.succ â‰« X.Î´ (â‡‘fin.cast_succ i) = X.Î´ i â‰« X.Ïƒ j
theorem comap_coe_Ioo_nhds_within_Iio {Î± : Type u} [topological_space Î±] [linear_order Î±] [order_topology Î±] [densely_ordered Î±] (a b : Î±) : filter.comap coe (nhds_within b (set.Iio b)) = filter.at_top
theorem is_coprime.ne_zero {R : Type u} [comm_semiring R] [nontrivial R] {p : fin 2 â†’ R} (h : is_coprime (p 0) (p 1)) : p â‰  0
theorem integral_sin_pow_mul_cos_pow_odd {a b : â„} (m n : â„•) : âˆ« (x : â„) in a..b, real.sin x ^ m * real.cos x ^ (2 * n + 1) = âˆ« (u : â„) in real.sin a..real.sin b, u ^ m * (1 - u ^ 2) ^ n
theorem matrix.cramer_eq_adjugate_mul_vec {n : Type u} [decidable_eq n] [fintype n] {Î± : Type v} [comm_ring Î±] (A : matrix n n Î±) (b : n â†’ Î±) : â‡‘(A.cramer) b = A.adjugate.mul_vec b
theorem nat.succ_mul_central_binom_succ (n : â„•) : (n + 1) * (n + 1).central_binom = 2 * (2 * n + 1) * n.central_binom
theorem set_like.coe_list_dprod {Î¹ : Type u_1} {R : Type u_2} {Î± : Type u_3} {S : Type u_4} [set_like S R] [monoid R] [add_monoid Î¹] (A : Î¹ â†’ S) [set_like.graded_monoid A] (fÎ¹ : Î± â†’ Î¹) (fA : Î  (a : Î±), â†¥(A (fÎ¹ a))) (l : list Î±) : â†‘(l.dprod fÎ¹ fA) = (list.map (Î» (a : Î±), â†‘(fA a)) l).prod
theorem category_theory.limits.has_colimit_span_of_has_colimit_pair_of_has_colimit_parallel_pair {C : Type u} [ğ’ : category_theory.category C] {X Y Z : C} (f : X âŸ¶ Y) (g : X âŸ¶ Z) [category_theory.limits.has_colimit (category_theory.limits.pair Y Z)] [category_theory.limits.has_colimit (category_theory.limits.parallel_pair (f â‰« category_theory.limits.coprod.inl) (g â‰« category_theory.limits.coprod.inr))] : category_theory.limits.has_colimit (category_theory.limits.span f g)
theorem ideal.comap_le_map_of_inverse {R : Type u} {S : Type v} [semiring R] [semiring S] (f : R â†’+* S) (g : S â†’+* R) (I : ideal S) (h : function.left_inverse â‡‘g â‡‘f) : ideal.comap f I â‰¤ ideal.map g I
theorem orthonormal.oangle_rotation_self_left {V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) {x : V} (hx : x â‰  0) (Î¸ : real.angle) : hb.oangle (â‡‘(hb.rotation Î¸) x) x = -Î¸
theorem dense_range.prod_map {Î² : Type v} {Î³ : Type u_1} [topological_space Î²] [topological_space Î³] {Î¹ : Type u_2} {Îº : Type u_3} {f : Î¹ â†’ Î²} {g : Îº â†’ Î³} (hf : dense_range f) (hg : dense_range g) : dense_range (prod.map f g)
theorem bdd_below_insert {Î³ : Type w} [semilattice_inf Î³] (a : Î³) {s : set Î³} : bdd_below (has_insert.insert a s) â†” bdd_below s
theorem inner_product_geometry.norm_add_sq_eq_norm_sq_add_norm_sq_iff_angle_eq_pi_div_two {V : Type u_1} [inner_product_space â„ V] (x y : V) : âˆ¥x + yâˆ¥ * âˆ¥x + yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + âˆ¥yâˆ¥ * âˆ¥yâˆ¥ â†” inner_product_geometry.angle x y = real.pi / 2
theorem linear_independent_le_span' {R : Type u} [ring R] [strong_rank_condition R] {M : Type v} [add_comm_group M] [module R M] {Î¹ : Type u_1} (v : Î¹ â†’ M) (i : linear_independent R v) (w : set M) [fintype â†¥w] (s : set.range v â‰¤ â†‘(submodule.span R w)) : cardinal.mk Î¹ â‰¤ â†‘(fintype.card â†¥w)
theorem category_theory.whiskering_preadditive_yoneda {C : Type u} [category_theory.category C] [category_theory.preadditive C] : category_theory.preadditive_yoneda â‹™ (category_theory.whiskering_right Cáµ’áµ– AddCommGroup (Type v)).obj (category_theory.forget AddCommGroup) = category_theory.yoneda
theorem metric.inf_edist_le_inf_edist_thickening_add {Î± : Type u} [pseudo_emetric_space Î±] {Î´ : â„} {s : set Î±} {x : Î±} : emetric.inf_edist x s â‰¤ emetric.inf_edist x (metric.thickening Î´ s) + ennreal.of_real Î´
theorem intermediate_field.sum_mem {K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) {Î¹ : Type u_3} {t : finset Î¹} {f : Î¹ â†’ L} (h : âˆ€ (c : Î¹), c âˆˆ t â†’ f c âˆˆ S) : t.sum (Î» (i : Î¹), f i) âˆˆ S
theorem nnnorm_tsum_le {Î¹ : Type u_1} {E : Type u_3} [semi_normed_group E] {f : Î¹ â†’ E} (hf : summable (Î» (i : Î¹), âˆ¥f iâˆ¥â‚Š)) : âˆ¥âˆ‘' (i : Î¹), f iâˆ¥â‚Š â‰¤ âˆ‘' (i : Î¹), âˆ¥f iâˆ¥â‚Š
theorem has_fderiv_at_integral_of_dominated_loc_of_lip {Î± : Type u_1} [measurable_space Î±] {Î¼ : measure_theory.measure Î±} {ğ•œ : Type u_2} [is_R_or_C ğ•œ] {E : Type u_3} [normed_group E] [normed_space â„ E] [normed_space ğ•œ E] [complete_space E] {H : Type u_4} [normed_group H] [normed_space ğ•œ H] {F : H â†’ Î± â†’ E} {F' : Î± â†’ (H â†’L[ğ•œ] E)} {xâ‚€ : H} {bound : Î± â†’ â„} {Îµ : â„} (Îµ_pos : 0 < Îµ) (hF_meas : âˆ€á¶  (x : H) in nhds xâ‚€, measure_theory.ae_strongly_measurable (F x) Î¼) (hF_int : measure_theory.integrable (F xâ‚€) Î¼) (hF'_meas : measure_theory.ae_strongly_measurable F' Î¼) (h_lip : âˆ€áµ (a : Î±) âˆ‚Î¼, lipschitz_on_with (â‡‘real.nnabs (bound a)) (Î» (x : H), F x a) (metric.ball xâ‚€ Îµ)) (bound_integrable : measure_theory.integrable bound Î¼) (h_diff : âˆ€áµ (a : Î±) âˆ‚Î¼, has_fderiv_at (Î» (x : H), F x a) (F' a) xâ‚€) : measure_theory.integrable F' Î¼ âˆ§ has_fderiv_at (Î» (x : H), âˆ« (a : Î±), F x a âˆ‚Î¼) (âˆ« (a : Î±), F' a âˆ‚Î¼) xâ‚€
theorem ordinal.div_nonempty {a b : ordinal} (h : b â‰  0) : {o : ordinal | a < b * order.succ o}.nonempty
theorem finset.induction_on_union {Î± : Type u_1} [decidable_eq Î±] (P : finset Î± â†’ finset Î± â†’ Prop) (symm : âˆ€ {a b : finset Î±}, P a b â†’ P b a) (empty_right : âˆ€ {a : finset Î±}, P a âˆ…) (singletons : âˆ€ {a b : Î±}, P {a} {b}) (union_of : âˆ€ {a b c : finset Î±}, P a c â†’ P b c â†’ P (a âˆª b) c) (a b : finset Î±) : P a b
theorem finset.nonempty.map {Î± : Type u_1} {Î² : Type u_2} {f : Î± â†ª Î²} {s : finset Î±} : s.nonempty â†’ (finset.map f s).nonempty
theorem category_theory.sheaf.le_finest_topology {C : Type u} [category_theory.category C] (Ps : set (Cáµ’áµ– â¥¤ Type v)) (J : category_theory.grothendieck_topology C) (hJ : âˆ€ (P : Cáµ’áµ– â¥¤ Type v), P âˆˆ Ps â†’ category_theory.presieve.is_sheaf J P) : J â‰¤ category_theory.sheaf.finest_topology Ps
theorem algebraic_independent.of_subtype_range {R : Type u_3} {A : Type u_5} [comm_ring R] [comm_ring A] [algebra R A] {Î¹ : Type u_1} {f : Î¹ â†’ A} (hf : function.injective f) : algebraic_independent R coe â†’ algebraic_independent R f
theorem mem_orthogonal_singleton_of_inner_right {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] (u : E) {v : E} (hv : has_inner.inner u v = 0) : v âˆˆ (submodule.span ğ•œ {u})á—®
theorem nat.fib_coprime_fib_succ (n : â„•) : (nat.fib n).coprime (nat.fib (n + 1))
theorem finset.sum_centroid_weights_eq_one_of_nonempty (k : Type u_1) [division_ring k] {Î¹ : Type u_4} (s : finset Î¹) [char_zero k] (h : s.nonempty) : s.sum (Î» (i : Î¹), finset.centroid_weights k s i) = 1
theorem list.sublist.prod_le_prod' {M : Type u_3} [monoid M] [preorder M] [covariant_class M M (function.swap has_mul.mul) has_le.le] [covariant_class M M has_mul.mul has_le.le] {lâ‚ lâ‚‚ : list M} (h : lâ‚ <+ lâ‚‚) (hâ‚ : âˆ€ (a : M), a âˆˆ lâ‚‚ â†’ 1 â‰¤ a) : lâ‚.prod â‰¤ lâ‚‚.prod
theorem is_simple_group_of_prime_card {Î± : Type u} [group Î±] [fintype Î±] {p : â„•} [hp : fact (nat.prime p)] (h : fintype.card Î± = p) : is_simple_group Î±
theorem bool.apply_apply_apply (f : bool â†’ bool) (x : bool) : f (f (f x)) = f x
theorem has_le.le.antisymm' {Î± : Type u} [partial_order Î±] {a b : Î±} : a â‰¤ b â†’ b â‰¤ a â†’ b = a
theorem pi.single_comm {I : Type u} [decidable_eq I] {Î² : Type u_1} [has_zero Î²] (i : I) (x : Î²) (i' : I) : pi.single i x i' = pi.single i' x i
theorem has_continuous_mul_of_smooth {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {H : Type u_2} [topological_space H] {E : Type u_3} [normed_group E] [normed_space ğ•œ E] (I : model_with_corners ğ•œ E H) {G : Type u_4} [has_mul G] [topological_space G] [charted_space H G] [has_smooth_mul I G] : has_continuous_mul G
theorem normalizer_condition_iff_only_full_group_self_normalizing {G : Type u_1} [group G] : normalizer_condition G â†” âˆ€ (H : subgroup G), H.normalizer = H â†’ H = âŠ¤
theorem category_theory.category_of_elements.from_to_costructured_arrow_eq {C : Type u} [category_theory.category C] (F : Cáµ’áµ– â¥¤ Type v) : (category_theory.category_of_elements.to_costructured_arrow F).right_op â‹™ category_theory.category_of_elements.from_costructured_arrow F = ğŸ­ F.elements
theorem metric.bounded_iff_subset_ball {Î± : Type u} [pseudo_metric_space Î±] {s : set Î±} (c : Î±) : metric.bounded s â†” âˆƒ (r : â„), s âŠ† metric.closed_ball c r
theorem filter.has_antitone_basis.subbasis_with_rel {Î± : Type u_3} {f : filter Î±} {s : â„• â†’ set Î±} (hs : f.has_antitone_basis s) {r : â„• â†’ â„• â†’ Prop} (hr : âˆ€ (m : â„•), âˆ€á¶  (n : â„•) in filter.at_top, r m n) : âˆƒ (Ï† : â„• â†’ â„•), strict_mono Ï† âˆ§ (âˆ€ â¦ƒm n : â„•â¦„, m < n â†’ r (Ï† m) (Ï† n)) âˆ§ f.has_antitone_basis (s âˆ˜ Ï†)
theorem measure_theory.exists_pos_lintegral_lt_of_sigma_finite {Î± : Type u_1} {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) [measure_theory.sigma_finite Î¼] {Îµ : ennreal} (Îµ0 : Îµ â‰  0) : âˆƒ (g : Î± â†’ nnreal), (âˆ€ (x : Î±), 0 < g x) âˆ§ measurable g âˆ§ âˆ«â» (x : Î±), â†‘(g x) âˆ‚Î¼ < Îµ
theorem linear_map.polar_weak_closed {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [normed_comm_ring ğ•œ] [add_comm_monoid E] [add_comm_monoid F] [module ğ•œ E] [module ğ•œ F] (B : E â†’â‚—[ğ•œ] F â†’â‚—[ğ•œ] ğ•œ) (s : set E) : is_closed (B.polar s)
theorem metric.self_subset_thickening {Î± : Type u} [pseudo_emetric_space Î±] {Î´ : â„} (Î´_pos : 0 < Î´) (E : set Î±) : E âŠ† metric.thickening Î´ E
theorem inner_product_geometry.angle_smul_left_of_pos {V : Type u_1} [inner_product_space â„ V] (x y : V) {r : â„} (hr : 0 < r) : inner_product_geometry.angle (r â€¢ x) y = inner_product_geometry.angle x y
theorem category_theory.mono_iff_injective {X Y : Type u} (f : X âŸ¶ Y) : category_theory.mono f â†” function.injective f
theorem strict_mono.add {Î± : Type u_1} {Î² : Type u_2} [has_add Î±] [preorder Î±] [preorder Î²] {f g : Î² â†’ Î±} [covariant_class Î± Î± has_add.add has_lt.lt] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] (hf : strict_mono f) (hg : strict_mono g) : strict_mono (Î» (x : Î²), f x + g x)
theorem pow_gcd_card_eq_one_iff {G : Type u} {x : G} {n : â„•} [fintype G] [group G] : x ^ n = 1 â†” x ^ n.gcd (fintype.card G) = 1
theorem category_theory.presheaf.is_separated_iff_subsingleton {C : Type uâ‚} [category_theory.category C] {A : Type uâ‚‚} [category_theory.category A] (J : category_theory.grothendieck_topology C) (P : Cáµ’áµ– â¥¤ A) : (âˆ€ (E : A), category_theory.presieve.is_separated J (P â‹™ category_theory.coyoneda.obj (opposite.op E))) â†” âˆ€ â¦ƒX : Câ¦„ (S : category_theory.sieve X), S âˆˆ â‡‘J X â†’ âˆ€ (c : category_theory.limits.cone (S.arrows.diagram.op â‹™ P)), subsingleton (c âŸ¶ P.map_cone S.arrows.cocone.op)
theorem double_quot.ker_quot_quot_mk {R : Type u} [comm_ring R] (I J : ideal R) : (double_quot.quot_quot_mk I J).ker = I âŠ” J
theorem star_id_of_comm {R : Type u_1} [comm_semiring R] {x : R} : has_star.star x = x
theorem cauchy_seq_of_edist_le_geometric_two {Î± : Type u_1} [pseudo_emetric_space Î±] (C : ennreal) (hC : C â‰  âŠ¤) {f : â„• â†’ Î±} (hu : âˆ€ (n : â„•), has_edist.edist (f n) (f (n + 1)) â‰¤ C / 2 ^ n) : cauchy_seq f
theorem nonarchimedean_ring.left_mul_subset {R : Type u_1} [ring R] [topological_space R] [nonarchimedean_ring R] (U : open_add_subgroup R) (r : R) : âˆƒ (V : open_add_subgroup R), r â€¢ â†‘V âŠ† â†‘U
theorem antitone_of_deriv_nonpos {f : â„ â†’ â„} (hf : differentiable â„ f) (hf' : âˆ€ (x : â„), deriv f x â‰¤ 0) : antitone f
theorem commutative_of_add_cyclic_center_quotient {G : Type u_1} {H : Type u_2} [add_group G] [add_group H] [is_add_cyclic H] (f : G â†’+ H) (hf : f.ker â‰¤ add_subgroup.center G) (a b : G) : a + b = b + a
theorem add_con.add_con_gen_le {M : Type u_1} [has_add M] {r : M â†’ M â†’ Prop} {c : add_con M} (h : âˆ€ (x y : M), r x y â†’ setoid.r x y) : add_con_gen r â‰¤ c
theorem finset.weighted_vsub_indicator_subset {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {Î¹ : Type u_4} (w : Î¹ â†’ k) (p : Î¹ â†’ P) {sâ‚ sâ‚‚ : finset Î¹} (h : sâ‚ âŠ† sâ‚‚) : â‡‘(sâ‚.weighted_vsub p) w = â‡‘(sâ‚‚.weighted_vsub p) (â†‘sâ‚.indicator w)
theorem lipschitz_on_with.extend_real {Î± : Type u} [pseudo_metric_space Î±] {f : Î± â†’ â„} {s : set Î±} {K : nnreal} (hf : lipschitz_on_with K f s) : âˆƒ (g : Î± â†’ â„), lipschitz_with K g âˆ§ set.eq_on f g s
theorem riesz_lemma_of_norm_lt {ğ•œ : Type u_1} [normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {c : ğ•œ} (hc : 1 < âˆ¥câˆ¥) {R : â„} (hR : âˆ¥câˆ¥ < R) {F : subspace ğ•œ E} (hFc : is_closed â†‘F) (hF : âˆƒ (x : E), x âˆ‰ F) : âˆƒ (xâ‚€ : E), âˆ¥xâ‚€âˆ¥ â‰¤ R âˆ§ âˆ€ (y : E), y âˆˆ F â†’ 1 â‰¤ âˆ¥xâ‚€ - yâˆ¥
theorem polynomial.cyclotomic_expand_eq_cyclotomic {p n : â„•} (hp : nat.prime p) (hdiv : p âˆ£ n) (R : Type u_1) [comm_ring R] : â‡‘(polynomial.expand R p) (polynomial.cyclotomic n R) = polynomial.cyclotomic (n * p) R
theorem same_ray.add_right {R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {x y z : M} (hy : same_ray R x y) (hz : same_ray R x z) : same_ray R x (y + z)
theorem generalized_continued_fraction.squash_gcf_nth_of_lt {K : Type u_1} {n : â„•} {g : generalized_continued_fraction K} [division_ring K] {m : â„•} (m_lt_n : m < n) : (g.squash_gcf (n + 1)).s.nth m = g.s.nth m
theorem padic_val_nat_def {p : â„•} [hp : fact (nat.prime p)] {n : â„•} (hn : 0 < n) : padic_val_nat p n = (multiplicity p n).get _
theorem quotient.surjective_quotient_mk' {Î± : Sort u_1} {sâ‚ : setoid Î±} : function.surjective quotient.mk'
theorem is_smul_regular.subsingleton {R : Type u_1} {M : Type u_3} [monoid_with_zero R] [has_zero M] [mul_action_with_zero R M] (h : is_smul_regular M 0) : subsingleton M
theorem hindman.FP_partition_regular {M : Type u_1} [semigroup M] (a : stream M) (s : set (set M)) (sfin : s.finite) (scov : hindman.FP a âŠ† â‹ƒâ‚€s) : âˆƒ (c : set M) (H : c âˆˆ s) (b : stream M), hindman.FP b âŠ† c
theorem complete_lattice.is_compact_element_iff_le_of_directed_Sup_le (Î± : Type u_1) [complete_lattice Î±] (k : Î±) : complete_lattice.is_compact_element k â†” âˆ€ (s : set Î±), s.nonempty â†’ directed_on has_le.le s â†’ k â‰¤ has_Sup.Sup s â†’ (âˆƒ (x : Î±), x âˆˆ s âˆ§ k â‰¤ x)
theorem category_theory.normal_epi_category.mono_of_zero_kernel {C : Type u_1} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_finite_coproducts C] [category_theory.limits.has_cokernels C] [category_theory.normal_epi_category C] {X Y : C} (f : X âŸ¶ Y) (Z : C) (l : category_theory.limits.is_limit (category_theory.limits.kernel_fork.of_Î¹ 0 _)) : category_theory.mono f
theorem trans_gen_of_pred_of_ne {Î± : Type u_1} [linear_order Î±] [pred_order Î±] [is_pred_archimedean Î±] (r : Î± â†’ Î± â†’ Prop) {n m : Î±} (h1 : âˆ€ (i : Î±), i âˆˆ set.Ioc m n â†’ r i (order.pred i)) (h2 : âˆ€ (i : Î±), i âˆˆ set.Ioc n m â†’ r (order.pred i) i) (hnm : n â‰  m) : relation.trans_gen r n m
theorem has_fpower_series_at.comp {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [nondiscrete_normed_field ğ•œ] [normed_group E] [normed_space ğ•œ E] [normed_group F] [normed_space ğ•œ F] [normed_group G] [normed_space ğ•œ G] {g : F â†’ G} {f : E â†’ F} {q : formal_multilinear_series ğ•œ F G} {p : formal_multilinear_series ğ•œ E F} {x : E} (hg : has_fpower_series_at g q (f x)) (hf : has_fpower_series_at f p x) : has_fpower_series_at (g âˆ˜ f) (q.comp p) x
theorem euclidean_geometry.dist_eq_of_angle_eq_angle_of_angle_ne_pi {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {p1 p2 p3 : P} (h : euclidean_geometry.angle p1 p2 p3 = euclidean_geometry.angle p1 p3 p2) (hpi : euclidean_geometry.angle p2 p1 p3 â‰  real.pi) : has_dist.dist p1 p2 = has_dist.dist p1 p3
theorem perfection_map.mk' {p : â„•} [fact (nat.prime p)] {R : Type uâ‚} [comm_semiring R] [char_p R p] {P : Type uâ‚ƒ} [comm_semiring P] [char_p P p] [perfect_ring P p] {f : P â†’+* R} (g : P â‰ƒ+* ring.perfection R p) (hfg : â‡‘(perfection.lift p P R) f = â†‘g) : perfection_map p f
theorem continuous_of_locally_uniform_approx_of_continuous_at {Î± : Type u_1} {Î² : Type u_2} [uniform_space Î²] {f : Î± â†’ Î²} [topological_space Î±] (L : âˆ€ (x : Î±) (u : set (Î² Ã— Î²)), u âˆˆ uniformity Î² â†’ (âˆƒ (t : set Î±) (H : t âˆˆ nhds x) (F : Î± â†’ Î²), continuous_at F x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u)) : continuous f
theorem lucas_lehmer.X.closed_form {q : â„•+} (i : â„•) : â†‘(lucas_lehmer.s i) = lucas_lehmer.X.Ï‰ ^ 2 ^ i + lucas_lehmer.X.Ï‰b ^ 2 ^ i
theorem dist_le_Ico_sum_dist {Î± : Type u} [pseudo_metric_space Î±] (f : â„• â†’ Î±) {m n : â„•} (h : m â‰¤ n) : has_dist.dist (f m) (f n) â‰¤ (finset.Ico m n).sum (Î» (i : â„•), has_dist.dist (f i) (f (i + 1)))
theorem cont_diff_within_at.add {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {x : E} {n : with_top â„•} {s : set E} {f g : E â†’ F} (hf : cont_diff_within_at ğ•œ n f s x) (hg : cont_diff_within_at ğ•œ n g s x) : cont_diff_within_at ğ•œ n (Î» (x : E), f x + g x) s x
theorem finset.imageâ‚‚_image_left_comm {Î± : Type u_1} {Î±' : Type u_2} {Î² : Type u_3} {Î³ : Type u_5} {Î´ : Type u_7} [decidable_eq Î±'] [decidable_eq Î³] [decidable_eq Î´] {s : finset Î±} {t : finset Î²} {f : Î±' â†’ Î² â†’ Î³} {g : Î± â†’ Î±'} {f' : Î± â†’ Î² â†’ Î´} {g' : Î´ â†’ Î³} (h_left_comm : âˆ€ (a : Î±) (b : Î²), f (g a) b = g' (f' a b)) : finset.imageâ‚‚ f (finset.image g s) t = finset.image g' (finset.imageâ‚‚ f' s t)
theorem measure_theory.Lp_meas_subgroup_to_Lp_trim_left_inv {Î± : Type u_1} {F : Type u_6} {p : ennreal} [normed_group F] {m m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (hm : m â‰¤ m0) : function.left_inverse (measure_theory.Lp_trim_to_Lp_meas_subgroup F p Î¼ hm) (measure_theory.Lp_meas_subgroup_to_Lp_trim F p Î¼ hm)
theorem finite_dimensional.nonempty_continuous_linear_equiv_iff_finrank_eq {ğ•œ : Type u} [nondiscrete_normed_field ğ•œ] {E : Type v} [normed_group E] [normed_space ğ•œ E] {F : Type w} [normed_group F] [normed_space ğ•œ F] [complete_space ğ•œ] [finite_dimensional ğ•œ E] [finite_dimensional ğ•œ F] : nonempty (E â‰ƒL[ğ•œ] F) â†” finite_dimensional.finrank ğ•œ E = finite_dimensional.finrank ğ•œ F
theorem eq_pos_convex_span_of_mem_convex_hull {ğ•œ : Type u_1} {E : Type u} [linear_ordered_field ğ•œ] [add_comm_group E] [module ğ•œ E] {s : set E} {x : E} (hx : x âˆˆ â‡‘(convex_hull ğ•œ) s) : âˆƒ (Î¹ : Type u) (_x : fintype Î¹) (z : Î¹ â†’ E) (w : Î¹ â†’ ğ•œ) (hss : set.range z âŠ† s) (hai : affine_independent ğ•œ z) (hw : âˆ€ (i : Î¹), 0 < w i), finset.univ.sum (Î» (i : Î¹), w i) = 1 âˆ§ finset.univ.sum (Î» (i : Î¹), w i â€¢ z i) = x
theorem category_theory.is_iso_of_mono_of_nonzero {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} [category_theory.simple Y] {f : X âŸ¶ Y} [category_theory.mono f] (w : f â‰  0) : category_theory.is_iso f
theorem finrank_eq_one_iff {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] (Î¹ : Type u_1) [unique Î¹] : finite_dimensional.finrank K V = 1 â†” nonempty (basis Î¹ K V)
theorem measure_theory.condexp_L2_const_inner {Î± : Type u_1} {E : Type u_4} {ğ•œ : Type u_11} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] [complete_space E] {m m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (hm : m â‰¤ m0) (f : â†¥(measure_theory.Lp E 2 Î¼)) (c : E) : â‡‘(â‡‘(measure_theory.condexp_L2 ğ•œ hm) (measure_theory.mem_â„’p.to_Lp (Î» (a : Î±), has_inner.inner c (â‡‘f a)) _)) =áµ[Î¼] Î» (a : Î±), has_inner.inner c (â‡‘(â‡‘(measure_theory.condexp_L2 ğ•œ hm) f) a)
theorem pgame.zero_add_equiv (x : pgame) : (0 + x).equiv x
theorem metric.cthickening_subset_of_subset {Î± : Type u} [pseudo_emetric_space Î±] (Î´ : â„) {Eâ‚ Eâ‚‚ : set Î±} (h : Eâ‚ âŠ† Eâ‚‚) : metric.cthickening Î´ Eâ‚ âŠ† metric.cthickening Î´ Eâ‚‚
theorem finset.induction_on_pi_max {Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_2} [fintype Î¹] [decidable_eq Î¹] [Î  (i : Î¹), decidable_eq (Î± i)] [Î  (i : Î¹), linear_order (Î± i)] {p : (Î  (i : Î¹), finset (Î± i)) â†’ Prop} (f : Î  (i : Î¹), finset (Î± i)) (h0 : p (Î» (_x : Î¹), âˆ…)) (step : âˆ€ (g : Î  (i : Î¹), finset (Î± i)) (i : Î¹) (x : Î± i), (âˆ€ (y : Î± i), y âˆˆ g i â†’ y < x) â†’ p g â†’ p (function.update g i (has_insert.insert x (g i)))) : p f
theorem multilinear_map.norm_image_sub_le_of_bound {ğ•œ : Type u} {Î¹ : Type v} {E : Î¹ â†’ Type wE} {G : Type wG} [decidable_eq Î¹] [fintype Î¹] [nondiscrete_normed_field ğ•œ] [Î  (i : Î¹), normed_group (E i)] [Î  (i : Î¹), normed_space ğ•œ (E i)] [normed_group G] [normed_space ğ•œ G] (f : multilinear_map ğ•œ E G) {C : â„} (hC : 0 â‰¤ C) (H : âˆ€ (m : Î  (i : Î¹), E i), âˆ¥â‡‘f mâˆ¥ â‰¤ C * finset.univ.prod (Î» (i : Î¹), âˆ¥m iâˆ¥)) (mâ‚ mâ‚‚ : Î  (i : Î¹), E i) : âˆ¥â‡‘f mâ‚ - â‡‘f mâ‚‚âˆ¥ â‰¤ C * â†‘(fintype.card Î¹) * linear_order.max âˆ¥mâ‚âˆ¥ âˆ¥mâ‚‚âˆ¥ ^ (fintype.card Î¹ - 1) * âˆ¥mâ‚ - mâ‚‚âˆ¥
theorem is_of_fin_order.mul {G : Type u} {x y : G} [comm_monoid G] (hx : is_of_fin_order x) (hy : is_of_fin_order y) : is_of_fin_order (x * y)
theorem monotone.covariant_of_const' {N : Type u_2} {Î± : Type u_3} [preorder Î±] [preorder N] {f : N â†’ Î±} {Î¼ : N â†’ N â†’ N} [covariant_class N N (function.swap Î¼) has_le.le] (hf : monotone f) (m : N) : monotone (Î» (n : N), f (Î¼ n m))
theorem finset.exists_subset_of_mem_shadow {Î± : Type u_1} [decidable_eq Î±] {ğ’œ : finset (finset Î±)} {s : finset Î±} (hs : s âˆˆ ğ’œ.shadow) : âˆƒ (t : finset Î±) (H : t âˆˆ ğ’œ), s âŠ† t
theorem vector.scanl_cons {n : â„•} {Î± : Type u_1} {Î² : Type u_2} (f : Î² â†’ Î± â†’ Î²) (b : Î²) (v : vector Î± n) (x : Î±) : vector.scanl f b (x::áµ¥v) = b::áµ¥vector.scanl f (f b x) v
theorem linear_map.det_smul {ğ•œ : Type u_1} [field ğ•œ] {M : Type u_2} [add_comm_group M] [module ğ•œ M] (c : ğ•œ) (f : M â†’â‚—[ğ•œ] M) : â‡‘linear_map.det (c â€¢ f) = c ^ finite_dimensional.finrank ğ•œ M * â‡‘linear_map.det f
theorem inner_lt_one_iff_real_of_norm_one {F : Type u_3} [inner_product_space â„ F] {x y : F} (hx : âˆ¥xâˆ¥ = 1) (hy : âˆ¥yâˆ¥ = 1) : has_inner.inner x y < 1 â†” x â‰  y
theorem padic_norm.of_int (p : â„•) [hp : fact (nat.prime p)] (z : â„¤) : padic_norm p â†‘z â‰¤ 1
theorem is_localization.is_domain_localization {A : Type u_6} [comm_ring A] [is_domain A] {M : submonoid A} (hM : M â‰¤ non_zero_divisors A) : is_domain (localization M)
theorem ae_eq_const_or_exists_average_ne_compl {Î± : Type u_1} {E : Type u_2} {m0 : measurable_space Î±} [normed_group E] [normed_space â„ E] [complete_space E] {Î¼ : measure_theory.measure Î±} {f : Î± â†’ E} [measure_theory.is_finite_measure Î¼] (hfi : measure_theory.integrable f Î¼) : f =áµ[Î¼] function.const Î± (â¨ (x : Î±), f x âˆ‚Î¼) âˆ¨ âˆƒ (t : set Î±), measurable_set t âˆ§ â‡‘Î¼ t â‰  0 âˆ§ â‡‘Î¼ tá¶œ â‰  0 âˆ§ â¨ (x : Î±) in t, f x âˆ‚Î¼ â‰  â¨ (x : Î±) in tá¶œ, f x âˆ‚Î¼
theorem sub_mul {Î± : Type u} [non_unital_non_assoc_ring Î±] (a b c : Î±) : (a - b) * c = a * c - b * c
theorem filter.map_mapâ‚‚_right_anticomm {Î± : Type u_1} {Î² : Type u_3} {Î²' : Type u_4} {Î³ : Type u_5} {Î´ : Type u_7} {f : filter Î±} {g : filter Î²} {m : Î± â†’ Î²' â†’ Î³} {n : Î² â†’ Î²'} {m' : Î² â†’ Î± â†’ Î´} {n' : Î´ â†’ Î³} (h_right_anticomm : âˆ€ (a : Î±) (b : Î²), m a (n b) = n' (m' b a)) : filter.mapâ‚‚ m f (filter.map n g) = filter.map n' (filter.mapâ‚‚ m' g f)
theorem is_ring_hom.of_semiring {Î± : Type u} {Î² : Type v} [ring Î±] [ring Î²] {f : Î± â†’ Î²} (H : is_semiring_hom f) : is_ring_hom f
theorem basis.det_ne_zero {R : Type u_1} [comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {Î¹ : Type u_4} [decidable_eq Î¹] [fintype Î¹] (e : basis Î¹ R M) [nontrivial R] : e.det â‰  0
theorem tsub_nonpos_of_le {Î± : Type u_1} [preorder Î±] [add_comm_monoid Î±] [has_sub Î±] [has_ordered_sub Î±] {a b : Î±} : a â‰¤ b â†’ a - b â‰¤ 0
theorem category_theory.limits.has_binary_biproduct.of_has_binary_product {C : Type u} [category_theory.category C] [category_theory.preadditive C] (X Y : C) [category_theory.limits.has_binary_product X Y] : category_theory.limits.has_binary_biproduct X Y
theorem filter.tendsto_at_top_of_monotone_of_filter {Î¹ : Type u_1} {Î± : Type u_3} [preorder Î¹] [preorder Î±] {l : filter Î¹} {u : Î¹ â†’ Î±} (h : monotone u) [l.ne_bot] (hu : filter.tendsto u l filter.at_top) : filter.tendsto u filter.at_top filter.at_top
theorem measure_theory.forall_measure_preimage_mul_right_iff {G : Type u_1} [measurable_space G] [has_mul G] [has_measurable_mul G] (Î¼ : measure_theory.measure G) : (âˆ€ (g : G) (A : set G), measurable_set A â†’ â‡‘Î¼ ((Î» (h : G), h * g) â»Â¹' A) = â‡‘Î¼ A) â†” Î¼.is_mul_right_invariant
theorem measure_theory.L1.tendsto_set_to_L1 {Î± : Type u_1} {E : Type u_2} {F : Type u_3} [normed_group E] [normed_space â„ E] [normed_group F] [normed_space â„ F] {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [complete_space F] {T : set Î± â†’ (E â†’L[â„] F)} {C : â„} (hT : measure_theory.dominated_fin_meas_additive Î¼ T C) (f : â†¥(measure_theory.Lp E 1 Î¼)) {Î¹ : Type u_4} (fs : Î¹ â†’ â†¥(measure_theory.Lp E 1 Î¼)) {l : filter Î¹} (hfs : filter.tendsto fs l (nhds f)) : filter.tendsto (Î» (i : Î¹), â‡‘(measure_theory.L1.set_to_L1 hT) (fs i)) l (nhds (â‡‘(measure_theory.L1.set_to_L1 hT) f))
theorem is_dedekind_domain.height_one_spectrum.int_valuation_ne_zero {R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] (v : is_dedekind_domain.height_one_spectrum R) (x : R) (hx : x â‰  0) : v.int_valuation_def x â‰  0
theorem finite_dimensional.finrank_pos {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] [h : nontrivial V] : 0 < finite_dimensional.finrank K V
theorem inner_matrix_col_col {ğ•œ : Type u_3} [is_R_or_C ğ•œ] {n m : â„•} (A B : matrix (fin n) (fin m) ğ•œ) (i j : fin m) : has_inner.inner (A.transpose i) (B.transpose j) = A.conj_transpose.mul B i j
theorem injective_iff_map_eq_zero {F : Type u_8} {G : Type u_1} {H : Type u_2} [add_group G] [add_zero_class H] [add_monoid_hom_class F G H] (f : F) : function.injective â‡‘f â†” âˆ€ (a : G), â‡‘f a = 0 â†’ a = 0
theorem map_div {G : Type u_6} {H : Type u_7} {F : Type u_8} [group G] [division_monoid H] [monoid_hom_class F G H] (f : F) (a b : G) : â‡‘f (a / b) = â‡‘f a / â‡‘f b
theorem submonoid.localization_map.map_comp_map {M : Type u_1} [comm_monoid M] {S : submonoid M} {N : Type u_2} [comm_monoid N] {P : Type u_3} [comm_monoid P] (f : S.localization_map N) {g : M â†’* P} {T : submonoid P} (hy : âˆ€ (y : â†¥S), â‡‘g â†‘y âˆˆ T) {Q : Type u_4} [comm_monoid Q] {k : T.localization_map Q} {A : Type u_5} [comm_monoid A] {U : submonoid A} {R : Type u_6} [comm_monoid R] (j : U.localization_map R) {l : P â†’* A} (hl : âˆ€ (w : â†¥T), â‡‘l â†‘w âˆˆ U) : (k.map hl j).comp (f.map hy k) = f.map _ j
theorem affinity_unit_ball {E : Type u_2} [normed_group E] [normed_space â„ E] {r : â„} (hr : 0 < r) (x : E) : x +áµ¥ r â€¢ metric.ball 0 1 = metric.ball x r
theorem finsum_mem_sub_distrib {Î± : Type u_1} {G : Type u_4} {s : set Î±} [subtraction_comm_monoid G] (f g : Î± â†’ G) (hs : s.finite) : finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), f i - g i)) = finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), f i)) - finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), g i))
theorem filter.Coprod_cocompact {Î´ : Type u_1} {Îº : Î´ â†’ Type u_2} [Î  (d : Î´), topological_space (Îº d)] : filter.Coprod (Î» (d : Î´), filter.cocompact (Îº d)) = filter.cocompact (Î  (d : Î´), Îº d)
theorem units.open_embedding_coe {R : Type u_1} [normed_ring R] [complete_space R] : open_embedding coe
theorem prime_multiset.factor_multiset_prod (v : prime_multiset) : v.prod.factor_multiset = v
theorem is_open_map_snd {Î± : Type u} {Î² : Type v} [topological_space Î±] [topological_space Î²] : is_open_map prod.snd
theorem filter.has_basis.lift {Î± : Type u_1} {Î³ : Type u_3} {Î¹ : Type u_2} {p : Î¹ â†’ Prop} {s : Î¹ â†’ set Î±} {f : filter Î±} (hf : f.has_basis p s) {Î² : Î¹ â†’ Type u_4} {pg : Î  (i : Î¹), Î² i â†’ Prop} {sg : Î  (i : Î¹), Î² i â†’ set Î³} {g : set Î± â†’ filter Î³} (hg : âˆ€ (i : Î¹), (g (s i)).has_basis (pg i) (sg i)) (gm : monotone g) : (f.lift g).has_basis (Î» (i : Î£ (i : Î¹), Î² i), p i.fst âˆ§ pg i.fst i.snd) (Î» (i : Î£ (i : Î¹), Î² i), sg i.fst i.snd)
theorem orthonormal.oangle_smul_left_self_of_nonneg {V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) (x : V) {r : â„} (hr : 0 â‰¤ r) : hb.oangle (r â€¢ x) x = 0
theorem collinear_iff_exists_forall_eq_smul_vadd (k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P) : collinear k s â†” âˆƒ (pâ‚€ : P) (v : V), âˆ€ (p : P), p âˆˆ s â†’ (âˆƒ (r : k), p = r â€¢ v +áµ¥ pâ‚€)
theorem nat.factorization_prod {Î± : Type u_1} {S : finset Î±} {g : Î± â†’ â„•} (hS : âˆ€ (x : Î±), x âˆˆ S â†’ g x â‰  0) : (S.prod g).factorization = S.sum (Î» (x : Î±), (g x).factorization)
theorem add_con.add_con_gen_idem {M : Type u_1} [has_add M] (r : M â†’ M â†’ Prop) : add_con_gen â‡‘(add_con_gen r) = add_con_gen r
theorem strict_convex.affine_image {ğ•œ : Type u_1} {E : Type u_3} {F : Type u_4} [ordered_ring ğ•œ] [topological_space E] [topological_space F] [add_comm_group E] [add_comm_group F] [module ğ•œ E] [module ğ•œ F] {s : set E} (hs : strict_convex ğ•œ s) {f : E â†’áµƒ[ğ•œ] F} (hf : is_open_map â‡‘f) : strict_convex ğ•œ (â‡‘f '' s)
theorem norm_add_le {E : Type u_3} [semi_normed_group E] (g h : E) : âˆ¥g + hâˆ¥ â‰¤ âˆ¥gâˆ¥ + âˆ¥hâˆ¥
theorem exterior_algebra.Î¹_sq_zero {R : Type u1} [comm_semiring R] {M : Type u2} [add_comm_monoid M] [module R M] (m : M) : â‡‘(exterior_algebra.Î¹ R) m * â‡‘(exterior_algebra.Î¹ R) m = 0
theorem right_deriv_measurable_aux.differentiable_set_subset_D {F : Type u_1} [normed_group F] [normed_space â„ F] {f : â„ â†’ F} (K : set F) : {x : â„ | differentiable_within_at â„ f (set.Ici x) x âˆ§ deriv_within f (set.Ici x) x âˆˆ K} âŠ† right_deriv_measurable_aux.D f K
theorem nat.add_choose_eq (m n k : â„•) : (m + n).choose k = (finset.nat.antidiagonal k).sum (Î» (ij : â„• Ã— â„•), m.choose ij.fst * n.choose ij.snd)
theorem measure_theory.lintegral_supr_directed {Î± : Type u_1} {Î² : Type u_2} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [encodable Î²] {f : Î² â†’ Î± â†’ ennreal} (hf : âˆ€ (b : Î²), measurable (f b)) (h_directed : directed has_le.le f) : âˆ«â» (a : Î±), (â¨† (b : Î²), f b a) âˆ‚Î¼ = â¨† (b : Î²), âˆ«â» (a : Î±), f b a âˆ‚Î¼
theorem is_torsion_free.prod {Î· : Type u_1} {Gs : Î· â†’ Type u_2} [Î  (i : Î·), group (Gs i)] (tfGs : âˆ€ (i : Î·), monoid.is_torsion_free (Gs i)) : monoid.is_torsion_free (Î  (i : Î·), Gs i)
theorem reflection_trans_reflection {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] (K : submodule ğ•œ E) [complete_space â†¥K] : (reflection K).trans (reflection K) = linear_isometry_equiv.refl ğ•œ E
theorem formal_multilinear_series.comp_along_composition_norm {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [nondiscrete_normed_field ğ•œ] [normed_group E] [normed_space ğ•œ E] [normed_group F] [normed_space ğ•œ F] [normed_group G] [normed_space ğ•œ G] {n : â„•} (q : formal_multilinear_series ğ•œ F G) (p : formal_multilinear_series ğ•œ E F) (c : composition n) : âˆ¥q.comp_along_composition p câˆ¥ â‰¤ âˆ¥q c.lengthâˆ¥ * finset.univ.prod (Î» (i : fin c.length), âˆ¥p (c.blocks_fun i)âˆ¥)
theorem basis.repr_apply_eq {Î¹ : Type u_1} {R : Type u_3} {M : Type u_5} [semiring R] [add_comm_monoid M] [module R M] (b : basis Î¹ R M) (f : M â†’ Î¹ â†’ R) (hadd : âˆ€ (x y : M), f (x + y) = f x + f y) (hsmul : âˆ€ (c : R) (x : M), f (c â€¢ x) = c â€¢ f x) (f_eq : âˆ€ (i : Î¹), f (â‡‘b i) = â‡‘(finsupp.single i 1)) (x : M) (i : Î¹) : â‡‘(â‡‘(b.repr) x) i = f x i
theorem continued_fraction.convergents_eq_convergents' {K : Type u_1} [linear_ordered_field K] {c : continued_fraction K} : â†‘c.convergents = â†‘c.convergents'
theorem alternating_map.comp_linear_equiv_eq_zero_iff {R : Type u_1} [semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {N : Type u_3} [add_comm_monoid N] [module R N] {Î¹ : Type u_6} [decidable_eq Î¹] {Mâ‚‚ : Type u_7} [add_comm_monoid Mâ‚‚] [module R Mâ‚‚] (f : alternating_map R M N Î¹) (g : Mâ‚‚ â‰ƒâ‚—[R] M) : f.comp_linear_map â†‘g = 0 â†” f = 0
theorem euclidean_geometry.dist_smul_vadd_eq_dist {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {v : V} (pâ‚ pâ‚‚ : P) (hv : v â‰  0) (r : â„) : has_dist.dist (r â€¢ v +áµ¥ pâ‚) pâ‚‚ = has_dist.dist pâ‚ pâ‚‚ â†” r = 0 âˆ¨ r = (-2) * has_inner.inner v (pâ‚ -áµ¥ pâ‚‚) / has_inner.inner v v
theorem one_lt_inv_of_inv {Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a : Î±} : a < 1 â†’ 1 < aâ»Â¹
theorem asymptotics.is_O.exists_eq_mul {Î± : Type u_1} {ğ•œ : Type u_14} [normed_field ğ•œ] {l : filter Î±} {u v : Î± â†’ ğ•œ} : u =O[l] v â†’ (âˆƒ (Ï† : Î± â†’ ğ•œ) (hÏ† : filter.is_bounded_under has_le.le l (has_norm.norm âˆ˜ Ï†)), u =á¶ [l] Ï† * v)
theorem polynomial.cyclotomic_coeff_zero (R : Type u_1) [comm_ring R] {n : â„•} (hn : 2 â‰¤ n) : (polynomial.cyclotomic n R).coeff 0 = 1
theorem measure_theory.lintegral_nnnorm_le_of_forall_fin_meas_integral_eq {Î± : Type u_1} {m m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {s : set Î±} (hm : m â‰¤ m0) {f g : Î± â†’ â„} (hf : measure_theory.strongly_measurable f) (hfi : measure_theory.integrable_on f s Î¼) (hg : measure_theory.strongly_measurable g) (hgi : measure_theory.integrable_on g s Î¼) (hgf : âˆ€ (t : set Î±), measurable_set t â†’ â‡‘Î¼ t < âŠ¤ â†’ âˆ« (x : Î±) in t, g x âˆ‚Î¼ = âˆ« (x : Î±) in t, f x âˆ‚Î¼) (hs : measurable_set s) (hÎ¼s : â‡‘Î¼ s â‰  âŠ¤) : âˆ«â» (x : Î±) in s, â†‘âˆ¥g xâˆ¥â‚Š âˆ‚Î¼ â‰¤ âˆ«â» (x : Î±) in s, â†‘âˆ¥f xâˆ¥â‚Š âˆ‚Î¼
theorem emetric.nonempty_compacts.to_closeds.uniform_embedding {Î± : Type u} [emetric_space Î±] : uniform_embedding topological_space.nonempty_compacts.to_closeds
theorem is_dedekind_domain.height_one_spectrum.valuation_le_one {R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] {K : Type u_2} [field K] [algebra R K] [is_fraction_ring R K] (v : is_dedekind_domain.height_one_spectrum R) (r : R) : â‡‘(v.valuation) (â‡‘(algebra_map R K) r) â‰¤ 1
theorem Top.presheaf.is_sheaf_iff_is_sheaf_pairwise_intersections {X : Top} {C : Type u} [category_theory.category C] [category_theory.limits.has_products C] (F : Top.presheaf C X) : F.is_sheaf â†” F.is_sheaf_pairwise_intersections
theorem measure_theory.outer_measure.Union_nat_of_monotone_of_tsum_ne_top {Î± : Type u_1} (m : measure_theory.outer_measure Î±) {s : â„• â†’ set Î±} (h_mono : âˆ€ (n : â„•), s n âŠ† s (n + 1)) (h0 : âˆ‘' (k : â„•), â‡‘m (s (k + 1)  s k) â‰  âŠ¤) : â‡‘m (â‹ƒ (n : â„•), s n) = â¨† (n : â„•), â‡‘m (s n)
theorem norm_sub_eq_norm_add {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {v w : E} (h : has_inner.inner v w = 0) : âˆ¥w - vâˆ¥ = âˆ¥w + vâˆ¥
theorem set.image2_distrib_subset_right {Î± : Type u_1} {Î±' : Type u_2} {Î² : Type u_3} {Î²' : Type u_4} {Î³ : Type u_5} {Î´ : Type u_7} {Îµ : Type u_9} {s : set Î±} {t : set Î²} {u : set Î³} {f : Î´ â†’ Î³ â†’ Îµ} {g : Î± â†’ Î² â†’ Î´} {fâ‚ : Î± â†’ Î³ â†’ Î±'} {fâ‚‚ : Î² â†’ Î³ â†’ Î²'} {g' : Î±' â†’ Î²' â†’ Îµ} (h_distrib : âˆ€ (a : Î±) (b : Î²) (c : Î³), f (g a b) c = g' (fâ‚ a c) (fâ‚‚ b c)) : set.image2 f (set.image2 g s t) u âŠ† set.image2 g' (set.image2 fâ‚ s u) (set.image2 fâ‚‚ t u)
theorem supr_and' {Î± : Type u_1} [complete_lattice Î±] {p q : Prop} {s : p â†’ q â†’ Î±} : (â¨† (hâ‚ : p) (hâ‚‚ : q), s hâ‚ hâ‚‚) = â¨† (h : p âˆ§ q), s _ _
theorem orthonormal.oangle_add_swap {V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) {x y z : V} (hx : x â‰  0) (hy : y â‰  0) (hz : z â‰  0) : hb.oangle y z + hb.oangle x y = hb.oangle x z
theorem add_monoid_hom.map_sub {Î± : Type u_1} {Î² : Type u_2} [add_group Î±] [subtraction_monoid Î²] (f : Î± â†’+ Î²) (g h : Î±) : â‡‘f (g - h) = â‡‘f g - â‡‘f h
theorem finset.center_mass_segment' {R : Type u_1} {E : Type u_2} {Î¹ : Type u_4} {Î¹' : Type u_5} [linear_ordered_field R] [add_comm_group E] [module R E] (s : finset Î¹) (t : finset Î¹') (ws : Î¹ â†’ R) (zs : Î¹ â†’ E) (wt : Î¹' â†’ R) (zt : Î¹' â†’ E) (hws : s.sum (Î» (i : Î¹), ws i) = 1) (hwt : t.sum (Î» (i : Î¹'), wt i) = 1) (a b : R) (hab : a + b = 1) : a â€¢ s.center_mass ws zs + b â€¢ t.center_mass wt zt = (finset.map function.embedding.inl s âˆª finset.map function.embedding.inr t).center_mass (sum.elim (Î» (i : Î¹), a * ws i) (Î» (j : Î¹'), b * wt j)) (sum.elim zs zt)
theorem ring_hom.eq_nat_cast' {R : Type u_1} [non_assoc_semiring R] (f : â„• â†’+* R) : f = nat.cast_ring_hom R
theorem orthonormal.oangle_smul_left_of_neg {V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) (x y : V) {r : â„} (hr : r < 0) : hb.oangle (r â€¢ x) y = hb.oangle (-x) y
theorem interval_integral.integral_deriv_eq_sub {E : Type u_3} [normed_group E] [complete_space E] [normed_space â„ E] {f : â„ â†’ E} {a b : â„} (hderiv : âˆ€ (x : â„), x âˆˆ set.interval a b â†’ differentiable_at â„ f x) (hint : interval_integrable (deriv f) measure_theory.measure_space.volume a b) : âˆ« (y : â„) in a..b, deriv f y = f b - f a
theorem module.directed_system.map_map {R : Type u} [ring R] {Î¹ : Type v} [preorder Î¹] {G : Î¹ â†’ Type w} [Î  (i : Î¹), add_comm_group (G i)] [Î  (i : Î¹), module R (G i)] (f : Î  (i j : Î¹), i â‰¤ j â†’ (G i â†’â‚—[R] G j)) [directed_system G (Î» (i j : Î¹) (h : i â‰¤ j), â‡‘(f i j h))] {i j k : Î¹} (hij : i â‰¤ j) (hjk : j â‰¤ k) (x : G i) : â‡‘(f j k hjk) (â‡‘(f i j hij) x) = â‡‘(f i k _) x
theorem exists_maximal_of_nonempty_chains_bounded {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} [nonempty Î±] (h : âˆ€ (c : set Î±), is_chain r c â†’ c.nonempty â†’ (âˆƒ (ub : Î±), âˆ€ (a : Î±), a âˆˆ c â†’ r a ub)) (trans : âˆ€ {a b c : Î±}, r a b â†’ r b c â†’ r a c) : âˆƒ (m : Î±), âˆ€ (a : Î±), r m a â†’ r a m
theorem pmf.to_measure_pure_apply {Î± : Type u_1} (a : Î±) (s : set Î±) [measurable_space Î±] (hs : measurable_set s) : â‡‘((pmf.pure a).to_measure) s = ite (a âˆˆ s) 1 0
theorem finite_dimensional.eq_of_le_of_finrank_eq {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {Sâ‚ Sâ‚‚ : submodule K V} [finite_dimensional K â†¥Sâ‚‚] (hle : Sâ‚ â‰¤ Sâ‚‚) (hd : finite_dimensional.finrank K â†¥Sâ‚ = finite_dimensional.finrank K â†¥Sâ‚‚) : Sâ‚ = Sâ‚‚
theorem concave_on.ge_on_segment {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [ordered_semiring ğ•œ] [add_comm_monoid E] [linear_ordered_add_comm_monoid Î²] [has_scalar ğ•œ E] [module ğ•œ Î²] [ordered_smul ğ•œ Î²] {s : set E} {f : E â†’ Î²} (hf : concave_on ğ•œ s f) {x y z : E} (hx : x âˆˆ s) (hy : y âˆˆ s) (hz : z âˆˆ segment ğ•œ x y) : linear_order.min (f x) (f y) â‰¤ f z
theorem metric.bounded.union {Î± : Type u} [pseudo_metric_space Î±] {s t : set Î±} (hs : metric.bounded s) (ht : metric.bounded t) : metric.bounded (s âˆª t)
theorem map_bit0 {Î± : Type u} {Î² : Type v} {F : Type u_1} [non_assoc_semiring Î±] [non_assoc_semiring Î²] [add_hom_class F Î± Î²] (f : F) (a : Î±) : â‡‘f (bit0 a) = bit0 (â‡‘f a)
theorem has_deriv_within_at.congr_set {ğ•œ : Type u} [nondiscrete_normed_field ğ•œ] {F : Type v} [normed_group F] [normed_space ğ•œ F] {f : ğ•œ â†’ F} {f' : F} {x : ğ•œ} {s t u : set ğ•œ} (hu : u âˆˆ nhds x) (h : s âˆ© u = t âˆ© u) : has_deriv_within_at f f' s x â†’ has_deriv_within_at f f' t x
theorem cauchy_seq_of_dist_le_of_summable {Î± : Type u_1} [pseudo_metric_space Î±] {f : â„• â†’ Î±} (d : â„• â†’ â„) (hf : âˆ€ (n : â„•), has_dist.dist (f n) (f n.succ) â‰¤ d n) (hd : summable d) : cauchy_seq f
theorem measure_theory.exists_lt_lower_semicontinuous_lintegral_ge_of_ae_measurable {Î± : Type u_1} [topological_space Î±] [measurable_space Î±] [borel_space Î±] (Î¼ : measure_theory.measure Î±) [Î¼.weakly_regular] [measure_theory.sigma_finite Î¼] (f : Î± â†’ nnreal) (fmeas : ae_measurable f Î¼) {Îµ : ennreal} (Îµ0 : Îµ â‰  0) : âˆƒ (g : Î± â†’ ennreal), (âˆ€ (x : Î±), â†‘(f x) < g x) âˆ§ lower_semicontinuous g âˆ§ âˆ«â» (x : Î±), g x âˆ‚Î¼ â‰¤ âˆ«â» (x : Î±), â†‘(f x) âˆ‚Î¼ + Îµ
theorem nat.not_bdd_above_set_of_prime  : Â¬bdd_above {p : â„• | nat.prime p}
theorem category_theory.Sheaf.is_sheaf_of_is_limit {C : Type (max v u)} [category_theory.category C] {J : category_theory.grothendieck_topology C} {D : Type w} [category_theory.category D] {K : Type (max v u)} [category_theory.small_category K] [category_theory.limits.has_limits_of_shape K D] (F : K â¥¤ category_theory.Sheaf J D) (E : category_theory.limits.cone (F â‹™ category_theory.Sheaf_to_presheaf J D)) (hE : category_theory.limits.is_limit E) : category_theory.presheaf.is_sheaf J E.X
theorem finset.sum_range_by_parts {R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] (f : â„• â†’ R) (g : â„• â†’ M) (n : â„•) : (finset.range n).sum (Î» (i : â„•), f i â€¢ g i) = f (n - 1) â€¢ (finset.range n).sum (Î» (i : â„•), g i) - (finset.range (n - 1)).sum (Î» (i : â„•), (f (i + 1) - f i) â€¢ (finset.range (i + 1)).sum (Î» (i : â„•), g i))
theorem multiset_sum_mem {B : Type u_3} {S : B} {M : Type u_1} [add_comm_monoid M] [set_like B M] [add_submonoid_class B M] (m : multiset M) (hm : âˆ€ (a : M), a âˆˆ m â†’ a âˆˆ S) : m.sum âˆˆ S
theorem convex.norm_image_sub_le_of_norm_deriv_within_le {ğ•œ : Type u_3} {G : Type u_4} [is_R_or_C ğ•œ] [normed_group G] [normed_space ğ•œ G] {f : ğ•œ â†’ G} {s : set ğ•œ} {x y : ğ•œ} {C : â„} (hf : differentiable_on ğ•œ f s) (bound : âˆ€ (x : ğ•œ), x âˆˆ s â†’ âˆ¥deriv_within f s xâˆ¥ â‰¤ C) (hs : convex â„ s) (xs : x âˆˆ s) (ys : y âˆˆ s) : âˆ¥f y - f xâˆ¥ â‰¤ C * âˆ¥y - xâˆ¥
theorem interval_integral.integral_sub_integral_sub_linear_is_o_of_tendsto_ae {Î¹ : Type u_1} {E : Type u_3} [normed_group E] [complete_space E] [normed_space â„ E] {f : â„ â†’ E} {ca cb : E} {la la' lb lb' : filter â„} {lt : filter Î¹} {a b : â„} {ua ub va vb : Î¹ â†’ â„} [interval_integral.FTC_filter a la la'] [interval_integral.FTC_filter b lb lb'] (hab : interval_integrable f measure_theory.measure_space.volume a b) (hmeas_a : strongly_measurable_at_filter f la' measure_theory.measure_space.volume) (hmeas_b : strongly_measurable_at_filter f lb' measure_theory.measure_space.volume) (ha_lim : filter.tendsto f (la' âŠ“ measure_theory.measure_space.volume.ae) (nhds ca)) (hb_lim : filter.tendsto f (lb' âŠ“ measure_theory.measure_space.volume.ae) (nhds cb)) (hua : filter.tendsto ua lt la) (hva : filter.tendsto va lt la) (hub : filter.tendsto ub lt lb) (hvb : filter.tendsto vb lt lb) : (Î» (t : Î¹), ((âˆ« (x : â„) in va t..vb t, f x) - âˆ« (x : â„) in ua t..ub t, f x) - ((vb t - ub t) â€¢ cb - (va t - ua t) â€¢ ca)) =o[lt] Î» (t : Î¹), âˆ¥va t - ua tâˆ¥ + âˆ¥vb t - ub tâˆ¥
theorem continuous_map.tendsto_iff_forall_compact_tendsto_uniformly_on' {Î± : Type uâ‚} {Î² : Type uâ‚‚} [topological_space Î±] [uniform_space Î²] (f : C(Î±, Î²)) {Î¹ : Type uâ‚ƒ} {p : filter Î¹} {F : Î¹ â†’ C(Î±, Î²)} : filter.tendsto F p (nhds f) â†” âˆ€ (K : set Î±), is_compact K â†’ tendsto_uniformly_on (Î» (i : Î¹) (a : Î±), â‡‘(F i) a) â‡‘f p K
theorem category_theory.subobject.lower_iso {C : Type uâ‚} [category_theory.category C] {X Y : C} (Fâ‚ Fâ‚‚ : category_theory.mono_over X â¥¤ category_theory.mono_over Y) (h : Fâ‚ â‰… Fâ‚‚) : category_theory.subobject.lower Fâ‚ = category_theory.subobject.lower Fâ‚‚
theorem has_strict_fderiv_at_exp_zero {ğ•‚ : Type u_1} {ğ”¸ : Type u_2} [is_R_or_C ğ•‚] [normed_ring ğ”¸] [normed_algebra ğ•‚ ğ”¸] [complete_space ğ”¸] : has_strict_fderiv_at (exp ğ•‚) 1 0
theorem infinite_of_mem_nhds {Î± : Type u_1} [topological_space Î±] [t1_space Î±] (x : Î±) [hx : (nhds_within x {x}á¶œ).ne_bot] {s : set Î±} (hs : s âˆˆ nhds x) : s.infinite
theorem basis.eq_of_apply_eq {Î¹ : Type u_1} {R : Type u_3} {M : Type u_5} [semiring R] [add_comm_monoid M] [module R M] {bâ‚ bâ‚‚ : basis Î¹ R M} (h : âˆ€ (i : Î¹), â‡‘bâ‚ i = â‡‘bâ‚‚ i) : bâ‚ = bâ‚‚
theorem category_theory.is_connected_of_equivalent {J : Type uâ‚} [category_theory.category J] {K : Type uâ‚} [category_theory.category K] (e : J â‰Œ K) [category_theory.is_connected J] : category_theory.is_connected K
theorem convex.combo_self_interior_subset_interior {E : Type u_2} {ğ•œ : Type u_3} [linear_ordered_field ğ•œ] [add_comm_group E] [module ğ•œ E] [topological_space E] [topological_add_group E] [has_continuous_const_smul ğ•œ E] {s : set E} (hs : convex ğ•œ s) {a b : ğ•œ} (ha : 0 â‰¤ a) (hb : 0 < b) (hab : a + b = 1) : a â€¢ s + b â€¢ interior s âŠ† interior s
theorem one_lt_of_inv_lt_one {Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a : Î±} : aâ»Â¹ < 1 â†’ 1 < a
theorem complex.integral_boundary_rect_eq_zero_of_differentiable_on_off_countable {E : Type u} [normed_group E] [normed_space â„‚ E] [complete_space E] (f : â„‚ â†’ E) (z w : â„‚) (s : set â„‚) (hs : s.countable) (Hc : continuous_on f (set.interval z.re w.re Ã—â„‚ set.interval z.im w.im)) (Hd : âˆ€ (x : â„‚), x âˆˆ set.Ioo (linear_order.min z.re w.re) (linear_order.max z.re w.re) Ã—â„‚ set.Ioo (linear_order.min z.im w.im) (linear_order.max z.im w.im)  s â†’ differentiable_at â„‚ f x) : (((âˆ« (x : â„) in z.re..w.re, f (â†‘x + â†‘(z.im) * complex.I)) - âˆ« (x : â„) in z.re..w.re, f (â†‘x + â†‘(w.im) * complex.I)) + complex.I â€¢ âˆ« (y : â„) in z.im..w.im, f (â†‘(w.re) + â†‘y * complex.I)) - complex.I â€¢ âˆ« (y : â„) in z.im..w.im, f (â†‘(z.re) + â†‘y * complex.I) = 0
theorem category_theory.presieve.is_sheaf_bot {C : Type uâ‚} [category_theory.category C] {P : Cáµ’áµ– â¥¤ Type w} : category_theory.presieve.is_sheaf âŠ¥ P
theorem category_theory.functor.eq_of_iso {C : Type uâ‚} [category_theory.category C] {D : Type uâ‚‚} [category_theory.category D] {Fâ‚ Fâ‚‚ : D â¥¤ C} [âˆ€ (X Y : C), subsingleton (X âŸ¶ Y)] (hC : category_theory.skeletal C) (hF : Fâ‚ â‰… Fâ‚‚) : Fâ‚ = Fâ‚‚
theorem is_extr_on.undual {Î± : Type u} {Î² : Type v} [preorder Î²] {f : Î± â†’ Î²} {s : set Î±} {a : Î±} : is_extr_on (â‡‘order_dual.to_dual âˆ˜ f) s a â†’ is_extr_on f s a
theorem measure_theory.outer_measure.Inf_apply {Î± : Type u_1} {m : set (measure_theory.outer_measure Î±)} {s : set Î±} (h : m.nonempty) : â‡‘(has_Inf.Inf m) s = â¨… (t : â„• â†’ set Î±) (h2 : s âŠ† set.Union t), âˆ‘' (n : â„•), â¨… (Î¼ : measure_theory.outer_measure Î±) (h3 : Î¼ âˆˆ m), â‡‘Î¼ (t n)
theorem padic_norm_e.one' {p : â„•} [fact (nat.prime p)] : padic_norm_e 1 = 1
theorem nnreal.arith_mean_le_rpow_mean {Î¹ : Type u} (s : finset Î¹) (w z : Î¹ â†’ nnreal) (hw' : s.sum (Î» (i : Î¹), w i) = 1) {p : â„} (hp : 1 â‰¤ p) : s.sum (Î» (i : Î¹), w i * z i) â‰¤ s.sum (Î» (i : Î¹), w i * z i ^ p) ^ (1 / p)
theorem strict_mono_on.dual_left {Î± : Type u} {Î² : Type v} [preorder Î±] [preorder Î²] {f : Î± â†’ Î²} {s : set Î±} : strict_mono_on f s â†’ strict_anti_on (f âˆ˜ â‡‘order_dual.of_dual) s
theorem measure_theory.measure.is_add_haar_measure_of_is_compact_nonempty_interior {G : Type u_1} [measurable_space G] [add_group G] [topological_space G] [topological_add_group G] [borel_space G] (Î¼ : measure_theory.measure G) [Î¼.is_add_left_invariant] (K : set G) (hK : is_compact K) (h'K : (interior K).nonempty) (h : â‡‘Î¼ K â‰  0) (h' : â‡‘Î¼ K â‰  âŠ¤) : Î¼.is_add_haar_measure
theorem category_theory.is_filtered.sup_exists {C : Type u} [category_theory.category C] [category_theory.is_filtered C] (O : finset C) (H : finset (Î£' (X Y : C) (mX : X âˆˆ O) (mY : Y âˆˆ O), X âŸ¶ Y)) : âˆƒ (S : C) (T : Î  {X : C}, X âˆˆ O â†’ (X âŸ¶ S)), âˆ€ {X Y : C} (mX : X âˆˆ O) (mY : Y âˆˆ O) {f : X âŸ¶ Y}, âŸ¨X, âŸ¨Y, âŸ¨mX, âŸ¨mY, fâŸ©âŸ©âŸ©âŸ© âˆˆ H â†’ f â‰« T mY = T mX
theorem eventually_closure_subset_of_is_compact_absorbing_of_is_open_of_omega_limit_subset' {Ï„ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [topological_space Î²] (f : filter Ï„) (Ï• : Ï„ â†’ Î± â†’ Î²) (s : set Î±) {c : set Î²} (hcâ‚ : is_compact c) (hcâ‚‚ : âˆƒ (v : set Ï„) (H : v âˆˆ f), closure (set.image2 Ï• v s) âŠ† c) {n : set Î²} (hnâ‚ : is_open n) (hnâ‚‚ : omega_limit f Ï• s âŠ† n) : âˆƒ (u : set Ï„) (H : u âˆˆ f), closure (set.image2 Ï• u s) âŠ† n
theorem least_ascending_central_series_length_eq_nilpotency_class {G : Type u_1} [group G] [hG : group.is_nilpotent G] : nat.find _ = group.nilpotency_class G
theorem emetric.exists_edist_lt_of_Hausdorff_edist_lt {Î± : Type u} [pseudo_emetric_space Î±] {x : Î±} {s t : set Î±} {r : ennreal} (h : x âˆˆ s) (H : emetric.Hausdorff_edist s t < r) : âˆƒ (y : Î±) (H : y âˆˆ t), has_edist.edist x y < r
theorem comm_of {Î± : Type u} (r : Î± â†’ Î± â†’ Prop) [is_symm Î± r] {a b : Î±} : r a b â†” r b a
theorem exists_subset_nhd_of_compact {Î± : Type u} [topological_space Î±] [t2_space Î±] {Î¹ : Type u_1} [nonempty Î¹] {V : Î¹ â†’ set Î±} (hV : directed superset V) (hV_cpct : âˆ€ (i : Î¹), is_compact (V i)) {U : set Î±} (hU : âˆ€ (x : Î±), (x âˆˆ â‹‚ (i : Î¹), V i) â†’ U âˆˆ nhds x) : âˆƒ (i : Î¹), V i âŠ† U
theorem set.finite.compl_mem_hyperfilter {Î± : Type u} [infinite Î±] {s : set Î±} (hf : s.finite) : sá¶œ âˆˆ filter.hyperfilter Î±
theorem antivary_on.sum_smul_le_sum_smul_comp_perm {Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [linear_ordered_ring Î±] [linear_ordered_add_comm_group Î²] [module Î± Î²] [ordered_smul Î± Î²] {s : finset Î¹} {Ïƒ : equiv.perm Î¹} {f : Î¹ â†’ Î±} {g : Î¹ â†’ Î²} (hfg : antivary_on f g â†‘s) (hÏƒ : {x : Î¹ | â‡‘Ïƒ x â‰  x} âŠ† â†‘s) : s.sum (Î» (i : Î¹), f i â€¢ g i) â‰¤ s.sum (Î» (i : Î¹), f i â€¢ g (â‡‘Ïƒ i))
theorem linear_map.ker_eq_bot_of_cancel {R : Type u_1} {Râ‚‚ : Type u_3} {M : Type u_9} {Mâ‚‚ : Type u_12} [semiring R] [semiring Râ‚‚] [add_comm_monoid M] [add_comm_monoid Mâ‚‚] [module R M] [module Râ‚‚ Mâ‚‚] {Ï„â‚â‚‚ : R â†’+* Râ‚‚} {f : M â†’â‚›â‚—[Ï„â‚â‚‚] Mâ‚‚} (h : âˆ€ (u v : â†¥(f.ker) â†’â‚—[R] M), f.comp u = f.comp v â†’ u = v) : f.ker = âŠ¥
theorem is_smul_regular.of_smul_eq_one {R : Type u_1} {S : Type u_2} {M : Type u_3} {a : R} {s : S} [monoid S] [has_scalar R M] [has_scalar R S] [mul_action S M] [is_scalar_tower R S M] (h : a â€¢ s = 1) : is_smul_regular M s
theorem finset.exists_le_sum_fiber_of_maps_to_of_nsmul_le_sum {Î± : Type u} {Î² : Type v} {M : Type w} [decidable_eq Î²] {s : finset Î±} {t : finset Î²} {f : Î± â†’ Î²} {w : Î± â†’ M} {b : M} [linear_ordered_cancel_add_comm_monoid M] (hf : âˆ€ (a : Î±), a âˆˆ s â†’ f a âˆˆ t) (ht : t.nonempty) (hb : t.card â€¢ b â‰¤ s.sum (Î» (x : Î±), w x)) : âˆƒ (y : Î²) (H : y âˆˆ t), b â‰¤ (finset.filter (Î» (x : Î±), f x = y) s).sum (Î» (x : Î±), w x)
theorem locally_finite.exists_finset_nhd_support_subset {X : Type u_1} {R : Type u_9} {Î¹ : Type u_10} {U : Î¹ â†’ set X} [topological_space X] [has_zero R] {f : Î¹ â†’ X â†’ R} (hlf : locally_finite (Î» (i : Î¹), function.support (f i))) (hso : âˆ€ (i : Î¹), tsupport (f i) âŠ† U i) (ho : âˆ€ (i : Î¹), is_open (U i)) (x : X) : âˆƒ (is : finset Î¹) {n : set X} (hnâ‚ : n âˆˆ nhds x) (hnâ‚‚ : n âŠ† â‹‚ (i : Î¹) (H : i âˆˆ is), U i), âˆ€ (z : X), z âˆˆ n â†’ function.support (Î» (i : Î¹), f i z) âŠ† â†‘is
theorem is_bot.eq_bot {Î± : Type u} [partial_order Î±] [order_bot Î±] {a : Î±} : is_bot a â†’ a = âŠ¥
theorem nat.cofinite_eq_at_top  : filter.cofinite = filter.at_top
theorem set.nonempty_Ico_sdiff {Î± : Type u_1} [linear_ordered_add_comm_group Î±] {x dx y dy : Î±} (h : dy < dx) (hx : 0 < dx) : nonempty â†¥(set.Ico x (x + dx)  set.Ico y (y + dy))
theorem char.quadratic_char_eq_neg_one_iff_not_one {F : Type u_1} [field F] [fintype F] [decidable_eq F] {a : F} (ha : a â‰  0) : char.quadratic_char F a = -1 â†” Â¬char.quadratic_char F a = 1
theorem finset.sum_univ_pi {Î± : Type u_1} {Î² : Type u_2} [decidable_eq Î±] [fintype Î±] [add_comm_monoid Î²] {Î´ : Î± â†’ Type u_3} {t : Î  (a : Î±), finset (Î´ a)} (f : (Î  (a : Î±), a âˆˆ finset.univ â†’ Î´ a) â†’ Î²) : (finset.univ.pi t).sum (Î» (x : Î  (a : Î±), a âˆˆ finset.univ â†’ Î´ a), f x) = (fintype.pi_finset t).sum (Î» (x : Î  (a : Î±), Î´ a), f (Î» (a : Î±) (_x : a âˆˆ finset.univ), x a))
theorem filter.map_prod_map_const_id_principal_coprod_principal {Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_3} (a : Î±) (b : Î²) (i : Î¹) : filter.map (prod.map (Î» (_x : Î±), b) id) ((filter.principal {a}).coprod (filter.principal {i})) = filter.principal ({b} Ã—Ë¢ set.univ)
theorem probability_theory.strong_law_aux3 {Î© : Type u_1} [measure_theory.measure_space Î©] [measure_theory.is_probability_measure measure_theory.measure_space.volume] (X : â„• â†’ Î© â†’ â„) (hint : measure_theory.integrable (X 0) measure_theory.measure_space.volume) (hident : âˆ€ (i : â„•), probability_theory.ident_distrib (X i) (X 0) measure_theory.measure_space.volume measure_theory.measure_space.volume) : (Î» (n : â„•), (âˆ« (a : Î©), (finset.range n).sum (Î» (i : â„•), probability_theory.truncation (X i) â†‘i) a) - â†‘n * âˆ« (a : Î©), X 0 a) =o[filter.at_top] coe
theorem liouville.liouville_number_eq_initial_terms_add_tail {m : â„} (hm : 1 < m) (k : â„•) : liouville.liouville_number m = liouville.liouville_number_initial_terms m k + liouville.liouville_number_tail m k
theorem add_subgroup.norm_normed_mk_le {M : Type u_1} [semi_normed_group M] (S : add_subgroup M) : âˆ¥S.normed_mkâˆ¥ â‰¤ 1
theorem smul_neg_of_pos_of_neg {k : Type u_1} {M : Type u_2} [ordered_semiring k] [ordered_add_comm_group M] [module k M] [ordered_smul k M] {a : M} {c : k} (hc : 0 < c) : a < 0 â†’ c â€¢ a < 0
theorem ennreal.lintegral_mul_le_Lp_mul_Lq_of_ne_zero_of_ne_top {Î± : Type u_1} [measurable_space Î±] {Î¼ : measure_theory.measure Î±} {p q : â„} (hpq : p.is_conjugate_exponent q) {f g : Î± â†’ ennreal} (hf : ae_measurable f Î¼) (hf_nontop : âˆ«â» (a : Î±), f a ^ p âˆ‚Î¼ â‰  âŠ¤) (hg_nontop : âˆ«â» (a : Î±), g a ^ q âˆ‚Î¼ â‰  âŠ¤) (hf_nonzero : âˆ«â» (a : Î±), f a ^ p âˆ‚Î¼ â‰  0) (hg_nonzero : âˆ«â» (a : Î±), g a ^ q âˆ‚Î¼ â‰  0) : âˆ«â» (a : Î±), (f * g) a âˆ‚Î¼ â‰¤ (âˆ«â» (a : Î±), f a ^ p âˆ‚Î¼) ^ (1 / p) * (âˆ«â» (a : Î±), g a ^ q âˆ‚Î¼) ^ (1 / q)
theorem is_square.exists_sq {Î± : Type u_2} [monoid Î±] (m : Î±) : is_square m â†’ (âˆƒ (c : Î±), m = c ^ 2)
theorem one_lt_mul_of_le_of_lt' {Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a b : Î±} (ha : 1 â‰¤ a) (hb : 1 < b) : 1 < a * b
theorem is_dedekind_domain.height_one_spectrum.int_valuation_le_one {R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] (v : is_dedekind_domain.height_one_spectrum R) (x : R) : v.int_valuation_def x â‰¤ 1
theorem category_theory.limits.has_limits_op_of_has_colimits {C : Type uâ‚} [category_theory.category C] [category_theory.limits.has_colimits C] : category_theory.limits.has_limits Cáµ’áµ–
theorem finset.weighted_vsub_of_point_map {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {Î¹ : Type u_4} {Î¹â‚‚ : Type u_5} (sâ‚‚ : finset Î¹â‚‚) (e : Î¹â‚‚ â†ª Î¹) (w : Î¹ â†’ k) (p : Î¹ â†’ P) (b : P) : â‡‘((finset.map e sâ‚‚).weighted_vsub_of_point p b) w = â‡‘(sâ‚‚.weighted_vsub_of_point (p âˆ˜ â‡‘e) b) (w âˆ˜ â‡‘e)
theorem finset.induction_on_pi_min {Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_2} [fintype Î¹] [decidable_eq Î¹] [Î  (i : Î¹), decidable_eq (Î± i)] [Î  (i : Î¹), linear_order (Î± i)] {p : (Î  (i : Î¹), finset (Î± i)) â†’ Prop} (f : Î  (i : Î¹), finset (Î± i)) (h0 : p (Î» (_x : Î¹), âˆ…)) (step : âˆ€ (g : Î  (i : Î¹), finset (Î± i)) (i : Î¹) (x : Î± i), (âˆ€ (y : Î± i), y âˆˆ g i â†’ x < y) â†’ p g â†’ p (function.update g i (has_insert.insert x (g i)))) : p f
theorem affine.simplex.monge_point_vsub_face_centroid_eq_weighted_vsub_of_points_with_circumcenter {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {n : â„•} (s : affine.simplex â„ P (n + 2)) {iâ‚ iâ‚‚ : fin (n + 3)} (h : iâ‚ â‰  iâ‚‚) : s.monge_point -áµ¥ finset.centroid â„ {iâ‚, iâ‚‚}á¶œ s.points = â‡‘(finset.univ.weighted_vsub s.points_with_circumcenter) (affine.simplex.monge_point_vsub_face_centroid_weights_with_circumcenter iâ‚ iâ‚‚)
theorem finset.prod_fn {Î± : Type u_1} {Î² : Î± â†’ Type u_2} {Î³ : Type u_3} [Î  (a : Î±), comm_monoid (Î² a)] (s : finset Î³) (g : Î³ â†’ Î  (a : Î±), Î² a) : s.prod (Î» (c : Î³), g c) = Î» (a : Î±), s.prod (Î» (c : Î³), g c a)
theorem ray_eq_iff {R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {vâ‚ vâ‚‚ : M} (hvâ‚ : vâ‚ â‰  0) (hvâ‚‚ : vâ‚‚ â‰  0) : ray_of_ne_zero R vâ‚ hvâ‚ = ray_of_ne_zero R vâ‚‚ hvâ‚‚ â†” same_ray R vâ‚ vâ‚‚
theorem finset.sum_ite_eq' {Î² : Type u} {Î± : Type v} [add_comm_monoid Î²] [decidable_eq Î±] (s : finset Î±) (a : Î±) (b : Î± â†’ Î²) : s.sum (Î» (x : Î±), ite (x = a) (b x) 0) = ite (a âˆˆ s) (b a) 0
theorem basis.total_coord {R : Type u_1} {M : Type u_2} {Î¹ : Type u_5} [comm_ring R] [add_comm_group M] [module R M] [fintype Î¹] (b : basis Î¹ R M) (f : Î¹ â†’â‚€ R) (i : Î¹) : â‡‘(â‡‘(finsupp.total Î¹ (module.dual R M) R b.coord) f) (â‡‘b i) = â‡‘f i
theorem cardinal.mk_quaternion_algebra {R : Type u_1} (câ‚ câ‚‚ : R) : cardinal.mk (quaternion_algebra R câ‚ câ‚‚) = cardinal.mk R ^ 4
theorem cont_diff_on.sub {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {n : with_top â„•} {s : set E} {f g : E â†’ F} (hf : cont_diff_on ğ•œ n f s) (hg : cont_diff_on ğ•œ n g s) : cont_diff_on ğ•œ n (Î» (x : E), f x - g x) s
theorem continuous_at_of_monotone_on_of_exists_between {Î± : Type u_1} {Î² : Type u_2} [linear_order Î±] [topological_space Î±] [order_topology Î±] [linear_order Î²] [topological_space Î²] [order_topology Î²] {f : Î± â†’ Î²} {s : set Î±} {a : Î±} (h_mono : monotone_on f s) (hs : s âˆˆ nhds a) (hfs_l : âˆ€ (b : Î²), b < f a â†’ (âˆƒ (c : Î±) (H : c âˆˆ s), f c âˆˆ set.Ioo b (f a))) (hfs_r : âˆ€ (b : Î²), b > f a â†’ (âˆƒ (c : Î±) (H : c âˆˆ s), f c âˆˆ set.Ioo (f a) b)) : continuous_at f a
theorem con.sup_eq_con_gen {M : Type u_1} [has_mul M] (c d : con M) : c âŠ” d = con_gen (Î» (x y : M), â‡‘c x y âˆ¨ â‡‘d x y)
theorem basis.det_smul_mk_coord_eq_det_update {R : Type u_1} [comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {Î¹ : Type u_4} [decidable_eq Î¹] [fintype Î¹] (e : basis Î¹ R M) {v : Î¹ â†’ M} (hli : linear_independent R v) (hsp : submodule.span R (set.range v) = âŠ¤) (i : Î¹) : â‡‘(e.det) v â€¢ (basis.mk hli hsp).coord i = e.det.to_multilinear_map.to_linear_map v i
theorem finset.exists_subset_of_mem_up_shadow {Î± : Type u_1} [decidable_eq Î±] [fintype Î±] {ğ’œ : finset (finset Î±)} {s : finset Î±} (hs : s âˆˆ ğ’œ.up_shadow) : âˆƒ (t : finset Î±) (H : t âˆˆ ğ’œ), t âŠ† s
theorem category_theory.limits.types.pi_map_Ï€_apply {Î² : Type u} {f g : Î² â†’ Type u} (Î± : Î  (j : Î²), f j âŸ¶ g j) (b : Î²) (x : âˆ Î» (j : Î²), f j) : category_theory.limits.pi.Ï€ g b (category_theory.limits.pi.map Î± x) = Î± b (category_theory.limits.pi.Ï€ f b x)
theorem measure_theory.strongly_measurable.measurable {Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} {m : measurable_space Î±} [topological_space Î²] [topological_space.pseudo_metrizable_space Î²] [measurable_space Î²] [borel_space Î²] (hf : measure_theory.strongly_measurable f) : measurable f
theorem mv_polynomial.is_domain_fintype (R : Type u) (Ïƒ : Type v) [comm_ring R] [fintype Ïƒ] [is_domain R] : is_domain (mv_polynomial Ïƒ R)
theorem multiset.mem_antidiagonal {Î± : Type u_1} {s : multiset Î±} {x : multiset Î± Ã— multiset Î±} : x âˆˆ s.antidiagonal â†” x.fst + x.snd = s
theorem polynomial.nat_degree_ne_zero_induction_on {R : Type u} [semiring R] {M : polynomial R â†’ Prop} {f : polynomial R} (f0 : f.nat_degree â‰  0) (h_C_add : âˆ€ {a : R} {p : polynomial R}, M p â†’ M (â‡‘polynomial.C a + p)) (h_add : âˆ€ {p q : polynomial R}, M p â†’ M q â†’ M (p + q)) (h_monomial : âˆ€ {n : â„•} {a : R}, a â‰  0 â†’ n â‰  0 â†’ M (â‡‘(polynomial.monomial n) a)) : M f
theorem add_monoid_algebra.finite_type_iff_fg {R : Type u_1} {M : Type u_2} [add_comm_monoid M] [comm_ring R] [nontrivial R] : algebra.finite_type R (add_monoid_algebra R M) â†” add_monoid.fg M
theorem finset.sup_coe {Î± : Type u_1} {Î² : Type u_2} [semilattice_sup Î±] [order_bot Î±] {P : Î± â†’ Prop} {Pbot : P âŠ¥} {Psup : âˆ€ â¦ƒx y : Î±â¦„, P x â†’ P y â†’ P (x âŠ” y)} (t : finset Î²) (f : Î² â†’ {x // P x}) : â†‘(t.sup f) = t.sup (Î» (x : Î²), â†‘(f x))
theorem finite_dimensional.nonempty_linear_equiv_of_finrank_eq {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {Vâ‚‚ : Type v'} [add_comm_group Vâ‚‚] [module K Vâ‚‚] [finite_dimensional K V] [finite_dimensional K Vâ‚‚] (cond : finite_dimensional.finrank K V = finite_dimensional.finrank K Vâ‚‚) : nonempty (V â‰ƒâ‚—[K] Vâ‚‚)
theorem spectrum.map_polynomial_aeval_of_degree_pos {ğ•œ : Type u} {A : Type v} [field ğ•œ] [ring A] [algebra ğ•œ A] [is_alg_closed ğ•œ] (a : A) (p : polynomial ğ•œ) (hdeg : 0 < p.degree) : spectrum ğ•œ (â‡‘(polynomial.aeval a) p) = (Î» (k : ğ•œ), polynomial.eval k p) '' spectrum ğ•œ a
theorem nnreal.summable_condensed_iff {f : â„• â†’ nnreal} (hf : âˆ€ â¦ƒm n : â„•â¦„, 0 < m â†’ m â‰¤ n â†’ f n â‰¤ f m) : summable (Î» (k : â„•), 2 ^ k * f (2 ^ k)) â†” summable f
theorem antitone_on.map_is_greatest {Î± : Type u} {Î² : Type v} [preorder Î±] [preorder Î²] {f : Î± â†’ Î²} {t : set Î±} (Hf : antitone_on f t) {a : Î±} : is_greatest t a â†’ is_least (f '' t) (f a)
theorem polynomial.separable_X_pow_sub_C {F : Type u} [field F] {n : â„•} (a : F) (hn : â†‘n â‰  0) (ha : a â‰  0) : (polynomial.X ^ n - â‡‘polynomial.C a).separable
theorem set.Iio_subset_Iio {Î± : Type u_1} [preorder Î±] {a b : Î±} (h : a â‰¤ b) : set.Iio a âŠ† set.Iio b
theorem has_compact_support.continuous_convolution_right_of_integrable {ğ•œ : Type u_1} {G : Type u_2} {E : Type u_3} {E' : Type u_4} {F : Type u_6} [normed_group E] [normed_group E'] [normed_group F] {f : G â†’ E} {g : G â†’ E'} [nondiscrete_normed_field ğ•œ] [normed_space ğ•œ E] [normed_space ğ•œ E'] [normed_space ğ•œ F] (L : E â†’L[ğ•œ] E' â†’L[ğ•œ] F) [measurable_space G] {Î¼ : measure_theory.measure G} [normed_space â„ F] [complete_space F] [add_group G] [topological_space G] [topological_add_group G] [borel_space G] [topological_space.second_countable_topology G] (hcg : has_compact_support g) (hf : measure_theory.integrable f Î¼) (hg : continuous g) : continuous (convolution f g L Î¼)
theorem nat.prime.multiplicity_le_multiplicity_choose_add {p : â„•} (hp : nat.prime p) (n k : â„•) : multiplicity p n â‰¤ multiplicity p (n.choose k) + multiplicity p k
theorem add_con.induction_on {M : Type u_1} [has_add M] {c : add_con M} {C : c.quotient â†’ Prop} (q : c.quotient) (H : âˆ€ (x : M), C â†‘x) : C q
theorem bounded_continuous_function.nnnorm_le {Î± : Type u} {Î² : Type v} [topological_space Î±] [semi_normed_group Î²] (f : bounded_continuous_function Î± Î²) (C : nnreal) : âˆ¥fâˆ¥â‚Š â‰¤ C â†” âˆ€ (x : Î±), âˆ¥â‡‘f xâˆ¥â‚Š â‰¤ C
theorem image_le_of_deriv_right_lt_deriv_boundary' {f f' : â„ â†’ â„} {a b : â„} (hf : continuous_on f (set.Icc a b)) (hf' : âˆ€ (x : â„), x âˆˆ set.Ico a b â†’ has_deriv_within_at f (f' x) (set.Ici x) x) {B B' : â„ â†’ â„} (ha : f a â‰¤ B a) (hB : continuous_on B (set.Icc a b)) (hB' : âˆ€ (x : â„), x âˆˆ set.Ico a b â†’ has_deriv_within_at B (B' x) (set.Ici x) x) (bound : âˆ€ (x : â„), x âˆˆ set.Ico a b â†’ f x = B x â†’ f' x < B' x) â¦ƒx : â„â¦„ : x âˆˆ set.Icc a b â†’ f x â‰¤ B x
theorem polynomial.prod_cyclotomic'_eq_X_pow_sub_one {K : Type u_1} [comm_ring K] [is_domain K] {Î¶ : K} {n : â„•} (hpos : 0 < n) (h : is_primitive_root Î¶ n) : n.divisors.prod (Î» (i : â„•), polynomial.cyclotomic' i K) = polynomial.X ^ n - 1
theorem interval_integral.measure_integral_sub_linear_is_o_of_tendsto_ae_of_ge' {Î¹ : Type u_1} {E : Type u_3} [normed_group E] [complete_space E] [normed_space â„ E] {f : â„ â†’ E} {c : E} {l l' : filter â„} {lt : filter Î¹} {Î¼ : measure_theory.measure â„} {u v : Î¹ â†’ â„} [l'.is_measurably_generated] [filter.tendsto_Ixx_class set.Ioc l l'] (hfm : strongly_measurable_at_filter f l' Î¼) (hf : filter.tendsto f (l' âŠ“ Î¼.ae) (nhds c)) (hl : Î¼.finite_at_filter l') (hu : filter.tendsto u lt l) (hv : filter.tendsto v lt l) (huv : v â‰¤á¶ [lt] u) : (Î» (t : Î¹), âˆ« (x : â„) in u t..v t, f x âˆ‚Î¼ + (â‡‘Î¼ (set.Ioc (v t) (u t))).to_real â€¢ c) =o[lt] Î» (t : Î¹), (â‡‘Î¼ (set.Ioc (v t) (u t))).to_real
theorem quotient_norm_mk_eq {M : Type u_1} [semi_normed_group M] (S : add_subgroup M) (m : M) : âˆ¥â‡‘(quotient_add_group.mk' S) mâˆ¥ = has_Inf.Inf ((Î» (x : M), âˆ¥m + xâˆ¥) '' â†‘S)
theorem neg_lt_self {Î± : Type u} [add_group Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a : Î±} (h : 0 < a) : -a < a
theorem measure_theory.integrable_at_filter.of_inf_ae {Î± : Type u_1} {E : Type u_3} [measurable_space Î±] [normed_group E] {f : Î± â†’ E} {Î¼ : measure_theory.measure Î±} {l : filter Î±} : measure_theory.integrable_at_filter f (l âŠ“ Î¼.ae) Î¼ â†’ measure_theory.integrable_at_filter f l Î¼
theorem submonoid.mul_mem {M : Type u_1} [mul_one_class M] (S : submonoid M) {x y : M} : x âˆˆ S â†’ y âˆˆ S â†’ x * y âˆˆ S
theorem quadratic_form.basis_repr_eq_of_is_Ortho {M : Type u_3} [add_comm_group M] {Râ‚ : Type u_4} [comm_ring Râ‚] [module Râ‚ M] {Î¹ : Type u_6} [fintype Î¹] [invertible 2] (Q : quadratic_form Râ‚ M) (v : basis Î¹ Râ‚ M) (hvâ‚‚ : (â‡‘quadratic_form.associated Q).is_Ortho â‡‘v) : Q.basis_repr v = quadratic_form.weighted_sum_squares Râ‚ (Î» (i : Î¹), â‡‘Q (â‡‘v i))
theorem asymptotics.is_o.forall_is_O_with {Î± : Type u_1} {E : Type u_3} {F : Type u_4} [has_norm E] [has_norm F] {f : Î± â†’ E} {g : Î± â†’ F} {l : filter Î±} : f =o[l] g â†’ âˆ€ â¦ƒc : â„â¦„, 0 < c â†’ asymptotics.is_O_with c l f g
theorem is_compact.measure_lt_top {Î± : Type u_1} {m0 : measurable_space Î±} [topological_space Î±] {Î¼ : measure_theory.measure Î±} [measure_theory.is_finite_measure_on_compacts Î¼] â¦ƒK : set Î±â¦„ (hK : is_compact K) : â‡‘Î¼ K < âŠ¤
theorem add_subsemigroup.closure_inductionâ‚‚ {M : Type u_1} [has_add M] {s : set M} {p : M â†’ M â†’ Prop} {x y : M} (hx : x âˆˆ add_subsemigroup.closure s) (hy : y âˆˆ add_subsemigroup.closure s) (Hs : âˆ€ (x : M), x âˆˆ s â†’ âˆ€ (y : M), y âˆˆ s â†’ p x y) (Hmul_left : âˆ€ (x y z : M), p x z â†’ p y z â†’ p (x + y) z) (Hmul_right : âˆ€ (x y z : M), p z x â†’ p z y â†’ p z (x + y)) : p x y
theorem pgame.le_iff_forall_lt {x y : pgame} (ox : x.numeric) (oy : y.numeric) : x â‰¤ y â†” (âˆ€ (i : x.left_moves), x.move_left i < y) âˆ§ âˆ€ (j : y.right_moves), x < y.move_right j
theorem vsub_right_injective {G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] (p : P) : function.injective (has_vsub.vsub p)
theorem function.injective.no_zero_smul_divisors {R : Type u_1} {M : Type u_2} {N : Type u_3} [has_zero R] [has_zero M] [has_zero N] [has_scalar R M] [has_scalar R N] [no_zero_smul_divisors R N] (f : M â†’ N) (hf : function.injective f) (h0 : f 0 = 0) (hs : âˆ€ (c : R) (x : M), f (c â€¢ x) = c â€¢ f x) : no_zero_smul_divisors R M
theorem exists_has_deriv_at_eq_slope (f f' : â„ â†’ â„) {a b : â„} (hab : a < b) (hfc : continuous_on f (set.Icc a b)) (hff' : âˆ€ (x : â„), x âˆˆ set.Ioo a b â†’ has_deriv_at f (f' x) x) : âˆƒ (c : â„) (H : c âˆˆ set.Ioo a b), f' c = (f b - f a) / (b - a)
theorem affine_subspace.mk'_nonempty {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (p : P) (direction : submodule k V) : â†‘(affine_subspace.mk' p direction).nonempty
theorem trans_gen_of_pred_of_lt {Î± : Type u_1} [partial_order Î±] [pred_order Î±] [is_pred_archimedean Î±] (r : Î± â†’ Î± â†’ Prop) {n m : Î±} (h : âˆ€ (i : Î±), i âˆˆ set.Ioc n m â†’ r (order.pred i) i) (hmn : n < m) : relation.trans_gen r n m
theorem truncated_witt_vector.commutes_symm (p : â„•) [hp : fact (nat.prime p)] (n : â„•) {m : â„•} (hm : n â‰¤ m) : (truncated_witt_vector.zmod_equiv_trunc p n).symm.to_ring_hom.comp (truncated_witt_vector.truncate hm) = (zmod.cast_hom _ (zmod (p ^ n))).comp (truncated_witt_vector.zmod_equiv_trunc p m).symm.to_ring_hom
theorem local_homeomorph.continuous_iff_continuous_comp_left {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [topological_space Î±] [topological_space Î²] [topological_space Î³] (e : local_homeomorph Î± Î²) {f : Î³ â†’ Î±} (h : f â»Â¹' e.to_local_equiv.source = set.univ) : continuous f â†” continuous (â‡‘e âˆ˜ f)
theorem nat.fib_add_two {n : â„•} : nat.fib (n + 2) = nat.fib n + nat.fib (n + 1)
theorem continuous_map.dist_le_two_norm {Î± : Type u_1} {E : Type u_3} [topological_space Î±] [compact_space Î±] [normed_group E] (f : C(Î±, E)) (x y : Î±) : has_dist.dist (â‡‘f x) (â‡‘f y) â‰¤ 2 * âˆ¥fâˆ¥
theorem is_semiring_hom.to_is_monoid_hom {Î± : Type u} {Î² : Type v} [semiring Î±] [semiring Î²] {f : Î± â†’ Î²} (hf : is_semiring_hom f) : is_monoid_hom f
theorem measure_theory.strongly_measurable.integral_prod_right' {Î± : Type u_1} {Î² : Type u_3} {E : Type u_6} [measurable_space Î±] [measurable_space Î²] {Î½ : measure_theory.measure Î²} [normed_group E] [normed_space â„ E] [complete_space E] [measure_theory.sigma_finite Î½] â¦ƒf : Î± Ã— Î² â†’ Eâ¦„ (hf : measure_theory.strongly_measurable f) : measure_theory.strongly_measurable (Î» (x : Î±), âˆ« (y : Î²), f (x, y) âˆ‚Î½)
theorem inner_product_space.is_self_adjoint_iff_inner_map_self_real {V : Type u_4} [inner_product_space â„‚ V] (T : V â†’â‚—[â„‚] V) : inner_product_space.is_self_adjoint T â†” âˆ€ (v : V), â‡‘(star_ring_end â„‚) (has_inner.inner (â‡‘T v) v) = has_inner.inner (â‡‘T v) v
theorem first_order.language.direct_limit.exists_of {L : first_order.language} {Î¹ : Type v} [preorder Î¹] {G : Î¹ â†’ Type w} [Î  (i : Î¹), L.Structure (G i)] {f : Î  (i j : Î¹), i â‰¤ j â†’ L.embedding (G i) (G j)} [is_directed Î¹ has_le.le] [directed_system G (Î» (i j : Î¹) (h : i â‰¤ j), â‡‘(f i j h))] [nonempty Î¹] (z : first_order.language.direct_limit G f) : âˆƒ (i : Î¹) (x : G i), â‡‘(first_order.language.direct_limit.of L Î¹ G f i) x = z
theorem affine_subspace.direction_inf_of_mem_inf {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {sâ‚ sâ‚‚ : affine_subspace k P} {p : P} (h : p âˆˆ sâ‚ âŠ“ sâ‚‚) : (sâ‚ âŠ“ sâ‚‚).direction = sâ‚.direction âŠ“ sâ‚‚.direction
theorem affine_subspace.coe_direction_eq_vsub_set {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : affine_subspace k P} (h : â†‘s.nonempty) : â†‘(s.direction) = â†‘s -áµ¥ â†‘s
theorem subtype.is_empty_of_false {Î± : Sort u_1} {p : Î± â†’ Prop} (hp : âˆ€ (a : Î±), Â¬p a) : is_empty (subtype p)
theorem polynomial.irreducible_has_separable_contraction {F : Type} [field F] (q : â„•) [hF : exp_char F q] (f : polynomial F) [irred : irreducible f] : polynomial.has_separable_contraction q f
theorem cont_diff_within_at.comp {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {G : Type u_4} [normed_group G] [normed_space ğ•œ G] {n : with_top â„•} {s : set E} {t : set F} {g : F â†’ G} {f : E â†’ F} (x : E) (hg : cont_diff_within_at ğ•œ n g t (f x)) (hf : cont_diff_within_at ğ•œ n f s x) (st : s âŠ† f â»Â¹' t) : cont_diff_within_at ğ•œ n (g âˆ˜ f) s x
theorem convex.ord_connected {ğ•œ : Type u_1} [linear_ordered_field ğ•œ] {s : set ğ•œ} : convex ğ•œ s â†’ s.ord_connected
theorem measure_theory.outer_measure.trim_supr {Î± : Type u_1} [measurable_space Î±] {Î¹ : Type u_2} [encodable Î¹] (Î¼ : Î¹ â†’ measure_theory.outer_measure Î±) : (â¨† (i : Î¹), Î¼ i).trim = â¨† (i : Î¹), (Î¼ i).trim
theorem module.free.rank_prod (R : Type u) (M : Type v) (N : Type w) [ring R] [strong_rank_condition R] [add_comm_group M] [module R M] [module.free R M] [add_comm_group N] [module R N] [module.free R N] : module.rank R (M Ã— N) = (module.rank R M).lift + (module.rank R N).lift
theorem orthonormal.rotation_eq_self_iff {V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) (x : V) (Î¸ : real.angle) : â‡‘(hb.rotation Î¸) x = x â†” x = 0 âˆ¨ Î¸ = 0
theorem nonarchimedean_group.prod_subset {G : Type u_1} [group G] [topological_space G] [nonarchimedean_group G] {K : Type u_3} [group K] [topological_space K] [nonarchimedean_group K] {U : set (G Ã— K)} (hU : U âˆˆ nhds 1) : âˆƒ (V : open_subgroup G) (W : open_subgroup K), â†‘V Ã—Ë¢ â†‘W âŠ† U
theorem spectrum.limsup_pow_nnnorm_pow_one_div_le_spectral_radius {A : Type u_2} [normed_ring A] [normed_algebra â„‚ A] [complete_space A] (a : A) : filter.at_top.limsup (Î» (n : â„•), â†‘âˆ¥a ^ nâˆ¥â‚Š ^ (1 / â†‘n)) â‰¤ spectral_radius â„‚ a
theorem measure_theory.simple_func.lintegral_eq_of_measure_preimage {Î± : Type u_1} {Î² : Type u_2} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [measurable_space Î²] {f : measure_theory.simple_func Î± ennreal} {g : measure_theory.simple_func Î² ennreal} {Î½ : measure_theory.measure Î²} (H : âˆ€ (y : ennreal), â‡‘Î¼ (â‡‘f â»Â¹' {y}) = â‡‘Î½ (â‡‘g â»Â¹' {y})) : f.lintegral Î¼ = g.lintegral Î½
theorem algebra.algebra_ext {R : Type u_1} [comm_semiring R] {A : Type u_2} [semiring A] (P Q : algebra R A) (w : âˆ€ (r : R), â‡‘(algebra_map R A) r = â‡‘(algebra_map R A) r) : P = Q
theorem besicovitch.tendsto_filter_at {Î± : Type u_1} [metric_space Î±] [topological_space.second_countable_topology Î±] [measurable_space Î±] [opens_measurable_space Î±] [has_besicovitch_covering Î±] (Î¼ : measure_theory.measure Î±) [measure_theory.sigma_finite Î¼] (x : Î±) : filter.tendsto (Î» (r : â„), metric.closed_ball x r) (nhds_within 0 (set.Ioi 0)) ((besicovitch.vitali_family Î¼).filter_at x)
theorem exponent_exists.is_torsion {G : Type u_1} [group G] (h : monoid.exponent_exists G) : monoid.is_torsion G
theorem asymptotics.is_O_with.neg_left {Î± : Type u_1} {F : Type u_4} {E' : Type u_6} [has_norm F] [semi_normed_group E'] {c : â„} {g : Î± â†’ F} {f' : Î± â†’ E'} {l : filter Î±} : asymptotics.is_O_with c l f' g â†’ asymptotics.is_O_with c l (Î» (x : Î±), -f' x) g
theorem topological_semiring_of_smooth {ğ•œ : Type u_1} {R : Type u_2} {E : Type u_3} {H : Type u_4} [topological_space R] [topological_space H] [nondiscrete_normed_field ğ•œ] [normed_group E] [normed_space ğ•œ E] [charted_space H R] (I : model_with_corners ğ•œ E H) [semiring R] [smooth_ring I R] : topological_semiring R
theorem add_submonoid.zero_mem {M : Type u_1} [add_zero_class M] (S : add_submonoid M) : 0 âˆˆ S
theorem continuous.bdd_above_range_of_has_compact_support {Î± : Type u} {Î² : Type v} [topological_space Î±] [linear_order Î±] [order_closed_topology Î±] [nonempty Î±] [topological_space Î²] [has_zero Î±] {f : Î² â†’ Î±} (hf : continuous f) (h : has_compact_support f) : bdd_above (set.range f)
theorem simple_graph.is_clique.subsingleton {Î± : Type u_1} {s : set Î±} : âŠ¥.is_clique s â†’ s.subsingleton
theorem has_fderiv_at.lim {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {f : E â†’ F} {f' : E â†’L[ğ•œ] F} {x : E} (hf : has_fderiv_at f f' x) (v : E) {Î± : Type u_4} {c : Î± â†’ ğ•œ} {l : filter Î±} (hc : filter.tendsto (Î» (n : Î±), âˆ¥c nâˆ¥) l filter.at_top) : filter.tendsto (Î» (n : Î±), c n â€¢ (f (x + (c n)â»Â¹ â€¢ v) - f x)) l (nhds (â‡‘f' v))
theorem measure_theory.outer_measure.trim_op {Î± : Type u_1} [measurable_space Î±] {mâ‚ mâ‚‚ : measure_theory.outer_measure Î±} {op : ennreal â†’ ennreal} (h : âˆ€ (s : set Î±), â‡‘mâ‚ s = op (â‡‘mâ‚‚ s)) (s : set Î±) : â‡‘(mâ‚.trim) s = op (â‡‘(mâ‚‚.trim) s)
theorem quadratic_form.nondegenerate_of_anisotropic {R : Type u_2} {M : Type u_3} [add_comm_group M] [ring R] [module R M] [invertible 2] (Q : quadratic_form R M) (hB : Q.anisotropic) : (â‡‘quadratic_form.associated' Q).nondegenerate
theorem linear_equiv.det_coe_symm {M : Type u_2} [add_comm_group M] {ğ•œ : Type u_1} [field ğ•œ] [module ğ•œ M] (f : M â‰ƒâ‚—[ğ•œ] M) : â‡‘linear_map.det â†‘(f.symm) = (â‡‘linear_map.det â†‘f)â»Â¹
theorem thickened_indicator_aux_tendsto_indicator_closure {Î± : Type u_1} [pseudo_emetric_space Î±] {Î´seq : â„• â†’ â„} (Î´seq_lim : filter.tendsto Î´seq filter.at_top (nhds 0)) (E : set Î±) : filter.tendsto (Î» (n : â„•), thickened_indicator_aux (Î´seq n) E) filter.at_top (nhds ((closure E).indicator (Î» (x : Î±), 1)))
theorem t2_separation {Î± : Type u} [topological_space Î±] [t2_space Î±] {x y : Î±} (h : x â‰  y) : âˆƒ (u v : set Î±), is_open u âˆ§ is_open v âˆ§ x âˆˆ u âˆ§ y âˆˆ v âˆ§ u âˆ© v = âˆ…
theorem algebra.finite_type.iff_quotient_mv_polynomial'' {R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] : algebra.finite_type R A â†” âˆƒ (n : â„•) (f : mv_polynomial (fin n) R â†’â‚[R] A), function.surjective â‡‘f
theorem vsub_right_cancel {G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] {p1 p2 p : P} (h : p -áµ¥ p1 = p -áµ¥ p2) : p1 = p2
theorem measure_theory.add_haar_image_eq_zero_of_differentiable_on_of_add_haar_eq_zero {E : Type u_1} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] {s : set E} {f : E â†’ E} [measurable_space E] [borel_space E] (Î¼ : measure_theory.measure E) [Î¼.is_add_haar_measure] (hf : differentiable_on â„ f s) (hs : â‡‘Î¼ s = 0) : â‡‘Î¼ (f '' s) = 0
theorem convex.integral_mem {Î± : Type u_1} {E : Type u_2} {m0 : measurable_space Î±} [normed_group E] [normed_space â„ E] [complete_space E] {Î¼ : measure_theory.measure Î±} {s : set E} {f : Î± â†’ E} [measure_theory.is_probability_measure Î¼] (hs : convex â„ s) (hsc : is_closed s) (hf : âˆ€áµ (x : Î±) âˆ‚Î¼, f x âˆˆ s) (hfi : measure_theory.integrable f Î¼) : âˆ« (x : Î±), f x âˆ‚Î¼ âˆˆ s
theorem tactic.ring_exp.sum_congr {Î± : Type u} [comm_semiring Î±] {p p' ps ps' : Î±} : p = p' â†’ ps = ps' â†’ p + ps = p' + ps'
theorem finsupp.sum_map_domain_index_add_monoid_hom {Î± : Type u_1} {Î² : Type u_2} {M : Type u_5} {N : Type u_7} [add_comm_monoid M] [add_comm_monoid N] {f : Î± â†’ Î²} {s : Î± â†’â‚€ M} (h : Î² â†’ M â†’+ N) : (finsupp.map_domain f s).sum (Î» (b : Î²) (m : M), â‡‘(h b) m) = s.sum (Î» (a : Î±) (m : M), â‡‘(h (f a)) m)
theorem mul_sub_lt_image_sub_of_lt_deriv {f : â„ â†’ â„} (hf : differentiable â„ f) {C : â„} (hf'_gt : âˆ€ (x : â„), C < deriv f x) â¦ƒx y : â„â¦„ (hxy : x < y) : C * (y - x) < f y - f x
theorem nat.eq_one_of_dvd_coprimes {a b k : â„•} (h_ab_coprime : a.coprime b) (hka : k âˆ£ a) (hkb : k âˆ£ b) : k = 1
theorem is_compact.cthickening_eq_bUnion_closed_ball {Î± : Type u_1} [pseudo_metric_space Î±] {Î´ : â„} {E : set Î±} (hE : is_compact E) (hÎ´ : 0 â‰¤ Î´) : metric.cthickening Î´ E = â‹ƒ (x : Î±) (H : x âˆˆ E), metric.closed_ball x Î´
theorem finset.mem_slice {Î± : Type u_1} {ğ’œ : finset (finset Î±)} {A : finset Î±} {r : â„•} : A âˆˆ ğ’œ.slice r â†” A âˆˆ ğ’œ âˆ§ A.card = r
theorem affine_independent.vector_span_eq_of_le_of_card_eq_finrank_add_one {k : Type u_1} {V : Type u_2} {P : Type u_3} {Î¹ : Type u_4} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] [fintype Î¹] {p : Î¹ â†’ P} (hi : affine_independent k p) {sm : submodule k V} [finite_dimensional k â†¥sm] (hle : vector_span k (set.range p) â‰¤ sm) (hc : fintype.card Î¹ = finite_dimensional.finrank k â†¥sm + 1) : vector_span k (set.range p) = sm
theorem generalized_continued_fraction.comp_exact_value_correctness_of_stream_eq_some {K : Type u_1} [linear_ordered_field K] {v : K} {n : â„•} [floor_ring K] {ifp_n : generalized_continued_fraction.int_fract_pair K} : generalized_continued_fraction.int_fract_pair.stream v n = option.some ifp_n â†’ v = generalized_continued_fraction.comp_exact_value ((generalized_continued_fraction.of v).continuants_aux n) ((generalized_continued_fraction.of v).continuants_aux (n + 1)) ifp_n.fr
theorem category_theory.limits.kernel_subobject_comp_mono {C : Type u} [category_theory.category C] {X Y : C} [category_theory.limits.has_zero_morphisms C] (f : X âŸ¶ Y) [category_theory.limits.has_kernel f] {Z : C} (h : Y âŸ¶ Z) [category_theory.mono h] : category_theory.limits.kernel_subobject (f â‰« h) = category_theory.limits.kernel_subobject f
theorem add_con.map_apply {M : Type u_1} [add_zero_class M] {c d : add_con M} (h : c â‰¤ d) (x : c.quotient) : â‡‘(c.map d h) x = â‡‘(c.lift d.mk' _) x
theorem subgroup.fg_iff {G : Type u_3} [group G] (P : subgroup G) : P.fg â†” âˆƒ (S : set G), subgroup.closure S = P âˆ§ S.finite
theorem finset.imageâ‚‚_congr' {Î± : Type u_1} {Î² : Type u_3} {Î³ : Type u_5} [decidable_eq Î³] {f f' : Î± â†’ Î² â†’ Î³} {s : finset Î±} {t : finset Î²} (h : âˆ€ (a : Î±) (b : Î²), f a b = f' a b) : finset.imageâ‚‚ f s t = finset.imageâ‚‚ f' s t
theorem local_equiv.is_image.preimage_eq {Î± : Type u_1} {Î² : Type u_2} {e : local_equiv Î± Î²} {s : set Î±} {t : set Î²} : e.is_image s t â†’ e.source âˆ© â‡‘e â»Â¹' t = e.source âˆ© s
theorem linear_map.bound_of_ball_bound {ğ•œ : Type u_1} {E : Type u_4} {Fâ‚— : Type u_7} [normed_group E] [normed_group Fâ‚—] [nondiscrete_normed_field ğ•œ] [normed_space ğ•œ E] [normed_space ğ•œ Fâ‚—] {r : â„} (r_pos : 0 < r) (c : â„) (f : E â†’â‚—[ğ•œ] Fâ‚—) (h : âˆ€ (z : E), z âˆˆ metric.ball 0 r â†’ âˆ¥â‡‘f zâˆ¥ â‰¤ c) : âˆƒ (C : â„), âˆ€ (z : E), âˆ¥â‡‘f zâˆ¥ â‰¤ C * âˆ¥zâˆ¥
theorem continuous.Icc_extend {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [linear_order Î±] [topological_space Î³] {a b : Î±} {h : a â‰¤ b} [topological_space Î±] [order_topology Î±] [topological_space Î²] {f : Î³ â†’ â†¥(set.Icc a b) â†’ Î²} {g : Î³ â†’ Î±} (hf : continuous â†¿f) (hg : continuous g) : continuous (Î» (a_1 : Î³), set.Icc_extend h (f a_1) (g a_1))
theorem subgroup.bot_or_nontrivial {G : Type u_1} [group G] (H : subgroup G) : H = âŠ¥ âˆ¨ nontrivial â†¥H
theorem is_smul_regular_of_group {R : Type u_1} {G : Type u_4} [group G] [mul_action G R] (g : G) : is_smul_regular R g
theorem linear_isometry_equiv.reflections_generate_dim_aux {F : Type u_3} [inner_product_space â„ F] [finite_dimensional â„ F] {n : â„•} (Ï† : F â‰ƒâ‚—áµ¢[â„] F) (hn : finite_dimensional.finrank â„ â†¥((continuous_linear_map.id â„ F - â†‘(Ï†.to_continuous_linear_equiv)).ker)á—® â‰¤ n) : âˆƒ (l : list F), l.length â‰¤ n âˆ§ Ï† = (list.map (Î» (v : F), reflection (submodule.span â„ {v})á—®) l).prod
theorem is_add_hom.comp {Î± : Type u} {Î² : Type v} [has_add Î±] [has_add Î²] {Î³ : Type u_1} [has_add Î³] {f : Î± â†’ Î²} {g : Î² â†’ Î³} (hf : is_add_hom f) (hg : is_add_hom g) : is_add_hom (g âˆ˜ f)
theorem finprod_mem_image {Î± : Type u_1} {Î² : Type u_2} {M : Type u_5} [comm_monoid M] {f : Î± â†’ M} {s : set Î²} {g : Î² â†’ Î±} (hg : set.inj_on g s) : finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ g '' s), f i)) = finprod (Î» (j : Î²), finprod (Î» (H : j âˆˆ s), f (g j)))
theorem lipschitz_with.holder_with {X : Type u_1} {Y : Type u_2} [pseudo_emetric_space X] [pseudo_emetric_space Y] {C : nnreal} {f : X â†’ Y} : lipschitz_with C f â†’ holder_with C 1 f
theorem matrix.pivot.list_transvec_col_mul_mul_list_transvec_row_last_row {ğ•œ : Type u_3} [field ğ•œ] {r : â„•} (M : matrix (fin r âŠ• unit) (fin r âŠ• unit) ğ•œ) (hM : M (sum.inr ()) (sum.inr ()) â‰  0) (i : fin r) : ((matrix.pivot.list_transvec_col M).prod.mul M).mul (matrix.pivot.list_transvec_row M).prod (sum.inl i) (sum.inr ()) = 0
theorem lipschitz_with.dimH_image_le {X : Type u_2} {Y : Type u_3} [emetric_space X] [emetric_space Y] {K : nnreal} {f : X â†’ Y} (h : lipschitz_with K f) (s : set X) : dimH (f '' s) â‰¤ dimH s
theorem refl_trans_gen_of_pred_of_le {Î± : Type u_1} [partial_order Î±] [pred_order Î±] [is_pred_archimedean Î±] (r : Î± â†’ Î± â†’ Prop) {n m : Î±} (h : âˆ€ (i : Î±), i âˆˆ set.Ioc n m â†’ r (order.pred i) i) (hmn : n â‰¤ m) : relation.refl_trans_gen r n m
theorem finset.sum_comm' {Î² : Type u} {Î± : Type v} {Î³ : Type w} [add_comm_monoid Î²] {s : finset Î³} {t : Î³ â†’ finset Î±} {t' : finset Î±} {s' : Î± â†’ finset Î³} (h : âˆ€ (x : Î³) (y : Î±), x âˆˆ s âˆ§ y âˆˆ t x â†” x âˆˆ s' y âˆ§ y âˆˆ t') {f : Î³ â†’ Î± â†’ Î²} : s.sum (Î» (x : Î³), (t x).sum (Î» (y : Î±), f x y)) = t'.sum (Î» (y : Î±), (s' y).sum (Î» (x : Î³), f x y))
theorem category_theory.limits.has_wide_coequalizers_of_has_colimit_parallel_family (C : Type u) [category_theory.category C] [âˆ€ {J : Type v} {X Y : C} {f : J â†’ (X âŸ¶ Y)}, category_theory.limits.has_colimit (category_theory.limits.parallel_family f)] : category_theory.limits.has_wide_coequalizers C
theorem antivary.sum_mul_le_sum_mul_comp_perm {Î¹ : Type u_1} {Î± : Type u_2} [linear_ordered_ring Î±] {Ïƒ : equiv.perm Î¹} {f g : Î¹ â†’ Î±} [fintype Î¹] (hfg : antivary f g) : finset.univ.sum (Î» (i : Î¹), f i * g i) â‰¤ finset.univ.sum (Î» (i : Î¹), f i * g (â‡‘Ïƒ i))
theorem filter.is_bounded_under_of {Î± : Type u_1} {Î² : Type u_2} {r : Î± â†’ Î± â†’ Prop} {f : filter Î²} {u : Î² â†’ Î±} : (âˆƒ (b : Î±), âˆ€ (x : Î²), r (u x) b) â†’ filter.is_bounded_under r f u
theorem linear_recurrence.sol_space_dim {Î± : Type u_1} [field Î±] (E : linear_recurrence Î±) : module.rank Î± â†¥(E.sol_space) = â†‘(E.order)
theorem mul_le_one' {Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a b : Î±} (ha : a â‰¤ 1) (hb : b â‰¤ 1) : a * b â‰¤ 1
theorem multilinear_map.comp_linear_map_assoc {R : Type u} {Î¹ : Type u'} {Mâ‚ : Î¹ â†’ Type vâ‚} {Mâ‚‚ : Type vâ‚‚} [decidable_eq Î¹] [semiring R] [Î  (i : Î¹), add_comm_monoid (Mâ‚ i)] [add_comm_monoid Mâ‚‚] [Î  (i : Î¹), module R (Mâ‚ i)] [module R Mâ‚‚] {Mâ‚' : Î¹ â†’ Type u_1} [Î  (i : Î¹), add_comm_monoid (Mâ‚' i)] [Î  (i : Î¹), module R (Mâ‚' i)] {Mâ‚'' : Î¹ â†’ Type u_2} [Î  (i : Î¹), add_comm_monoid (Mâ‚'' i)] [Î  (i : Î¹), module R (Mâ‚'' i)] (g : multilinear_map R Mâ‚'' Mâ‚‚) (fâ‚ : Î  (i : Î¹), Mâ‚' i â†’â‚—[R] Mâ‚'' i) (fâ‚‚ : Î  (i : Î¹), Mâ‚ i â†’â‚—[R] Mâ‚' i) : (g.comp_linear_map fâ‚).comp_linear_map fâ‚‚ = g.comp_linear_map (Î» (i : Î¹), (fâ‚ i).comp (fâ‚‚ i))
theorem is_fraction_ring.char_p_of_is_fraction_ring (R : Type u_1) {K : Type u_2} [comm_ring R] [field K] [algebra R K] [is_fraction_ring R K] (p : â„•) [char_p R p] : char_p K p
theorem vector_span_eq_span_vsub_set_left_ne (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : set P} {p : P} (hp : p âˆˆ s) : vector_span k s = submodule.span k (has_vsub.vsub p '' (s  {p}))
theorem exp_neg_inv_glue.f_aux_iterated_deriv (n : â„•) : iterated_deriv n (exp_neg_inv_glue.f_aux 0) = exp_neg_inv_glue.f_aux n
theorem interval_integral.integral_has_strict_deriv_at_left {E : Type u_3} [normed_group E] [complete_space E] [normed_space â„ E] {f : â„ â†’ E} {a b : â„} (hf : interval_integrable f measure_theory.measure_space.volume a b) (hmeas : strongly_measurable_at_filter f (nhds a) measure_theory.measure_space.volume) (ha : continuous_at f a) : has_strict_deriv_at (Î» (u : â„), âˆ« (x : â„) in u..b, f x) (-f a) a
theorem category_theory.limits.is_limit.hom_ext {J : Type uâ‚} [category_theory.category J] {C : Type uâ‚ƒ} [category_theory.category C] {F : J â¥¤ C} {t : category_theory.limits.cone F} (h : category_theory.limits.is_limit t) {W : C} {f f' : W âŸ¶ t.X} (w : âˆ€ (j : J), f â‰« t.Ï€.app j = f' â‰« t.Ï€.app j) : f = f'
theorem list.split_on_p_eq_single {Î± : Type u} (p : Î± â†’ Prop) [decidable_pred p] (xs : list Î±) (h : âˆ€ (x : Î±), x âˆˆ xs â†’ Â¬p x) : list.split_on_p p xs = [xs]
theorem inner_orthogonal_projection_left_eq_right {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] (K : submodule ğ•œ E) [complete_space E] [complete_space â†¥K] (u v : E) : has_inner.inner â†‘(â‡‘(orthogonal_projection K) u) v = has_inner.inner u â†‘(â‡‘(orthogonal_projection K) v)
theorem refinement_of_locally_compact_sigma_compact_of_nhds_basis {X : Type v} [topological_space X] [locally_compact_space X] [sigma_compact_space X] [t2_space X] {Î¹ : X â†’ Type u} {p : Î  (x : X), Î¹ x â†’ Prop} {B : Î  (x : X), Î¹ x â†’ set X} (hB : âˆ€ (x : X), (nhds x).has_basis (p x) (B x)) : âˆƒ (Î± : Type v) (c : Î± â†’ X) (r : Î  (a : Î±), Î¹ (c a)), (âˆ€ (a : Î±), p (c a) (r a)) âˆ§ (â‹ƒ (a : Î±), B (c a) (r a)) = set.univ âˆ§ locally_finite (Î» (a : Î±), B (c a) (r a))
theorem subgroup.supr_induction {G : Type u_1} [group G] {Î¹ : Sort u_2} (S : Î¹ â†’ subgroup G) {C : G â†’ Prop} {x : G} (hx : x âˆˆ â¨† (i : Î¹), S i) (hp : âˆ€ (i : Î¹) (x : G), x âˆˆ S i â†’ C x) (h1 : C 1) (hmul : âˆ€ (x y : G), C x â†’ C y â†’ C (x * y)) : C x
theorem real_inner_mul_inner_self_le {F : Type u_3} [inner_product_space â„ F] (x y : F) : has_inner.inner x y * has_inner.inner x y â‰¤ has_inner.inner x x * has_inner.inner y y
theorem monovary_on.sum_mul_comp_perm_lt_sum_mul_iff {Î¹ : Type u_1} {Î± : Type u_2} [linear_ordered_ring Î±] {s : finset Î¹} {Ïƒ : equiv.perm Î¹} {f g : Î¹ â†’ Î±} (hfg : monovary_on f g â†‘s) (hÏƒ : {x : Î¹ | â‡‘Ïƒ x â‰  x} âŠ† â†‘s) : s.sum (Î» (i : Î¹), f i â€¢ g (â‡‘Ïƒ i)) < s.sum (Î» (i : Î¹), f i â€¢ g i) â†” Â¬monovary_on f (g âˆ˜ â‡‘Ïƒ) â†‘s
theorem measurable_set.image_of_continuous_on_inj_on {Î³ : Type u_3} [tÎ³ : topological_space Î³] [polish_space Î³] [measurable_space Î³] [borel_space Î³] {Î² : Type u_4} [tÎ² : topological_space Î²] [t2_space Î²] [measurable_space Î²] [borel_space Î²] {s : set Î³} {f : Î³ â†’ Î²} (hs : measurable_set s) (f_cont : continuous_on f s) (f_inj : set.inj_on f s) : measurable_set (f '' s)
theorem finsum_mem_union_inter' {Î± : Type u_1} {M : Type u_5} [add_comm_monoid M] {f : Î± â†’ M} {s t : set Î±} (hs : (s âˆ© function.support f).finite) (ht : (t âˆ© function.support f).finite) : finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s âˆª t), f i)) + finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s âˆ© t), f i)) = finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), f i)) + finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ t), f i))
theorem complex.integral_boundary_rect_of_has_fderiv_at_real_off_countable {E : Type u} [normed_group E] [normed_space â„‚ E] [complete_space E] (f : â„‚ â†’ E) (f' : â„‚ â†’ (â„‚ â†’L[â„] E)) (z w : â„‚) (s : set â„‚) (hs : s.countable) (Hc : continuous_on f (set.interval z.re w.re Ã—â„‚ set.interval z.im w.im)) (Hd : âˆ€ (x : â„‚), x âˆˆ set.Ioo (linear_order.min z.re w.re) (linear_order.max z.re w.re) Ã—â„‚ set.Ioo (linear_order.min z.im w.im) (linear_order.max z.im w.im)  s â†’ has_fderiv_at f (f' x) x) (Hi : measure_theory.integrable_on (Î» (z : â„‚), complex.I â€¢ â‡‘(f' z) 1 - â‡‘(f' z) complex.I) (set.interval z.re w.re Ã—â„‚ set.interval z.im w.im) measure_theory.measure_space.volume) : (((âˆ« (x : â„) in z.re..w.re, f (â†‘x + â†‘(z.im) * complex.I)) - âˆ« (x : â„) in z.re..w.re, f (â†‘x + â†‘(w.im) * complex.I)) + complex.I â€¢ âˆ« (y : â„) in z.im..w.im, f (â†‘(w.re) + â†‘y * complex.I)) - complex.I â€¢ âˆ« (y : â„) in z.im..w.im, f (â†‘(z.re) + â†‘y * complex.I) = âˆ« (x : â„) in z.re..w.re, âˆ« (y : â„) in z.im..w.im, complex.I â€¢ â‡‘(f' (â†‘x + â†‘y * complex.I)) 1 - â‡‘(f' (â†‘x + â†‘y * complex.I)) complex.I
theorem inv_le_one' {Î± : Type u} [group Î±] [has_le Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a : Î±} : aâ»Â¹ â‰¤ 1 â†” 1 â‰¤ a
theorem quadratic_form.exists_quadratic_form_ne_zero {R : Type u_2} {M : Type u_3} [add_comm_group M] [ring R] [module R M] [invertible 2] {Q : quadratic_form R M} (hBâ‚ : â‡‘quadratic_form.associated' Q â‰  0) : âˆƒ (x : M), â‡‘Q x â‰  0
theorem emetric.diam_union {Î± : Type u} [pseudo_emetric_space Î±] {x y : Î±} {s t : set Î±} (xs : x âˆˆ s) (yt : y âˆˆ t) : emetric.diam (s âˆª t) â‰¤ emetric.diam s + has_edist.edist x y + emetric.diam t
theorem ideal.quotient_map_injective' {R : Type u_1} {S : Type u_2} [comm_ring R] [comm_ring S] {J : ideal R} {I : ideal S} {f : R â†’+* S} {H : J â‰¤ ideal.comap f I} (h : ideal.comap f I â‰¤ J) : function.injective â‡‘(I.quotient_map f H)
theorem continuous_linear_map.op_nnnorm_le_bound {ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_normed_group E] [semi_normed_group F] [nondiscrete_normed_field ğ•œ] [nondiscrete_normed_field ğ•œâ‚‚] [normed_space ğ•œ E] [normed_space ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} [ring_hom_isometric Ïƒâ‚â‚‚] (f : E â†’SL[Ïƒâ‚â‚‚] F) (M : nnreal) (hM : âˆ€ (x : E), âˆ¥â‡‘f xâˆ¥â‚Š â‰¤ M * âˆ¥xâˆ¥â‚Š) : âˆ¥fâˆ¥â‚Š â‰¤ M
theorem phragmen_lindelof.eq_on_quadrant_IV {E : Type u_1} [normed_group E] [normed_space â„‚ E] {f g : â„‚ â†’ E} (hdf : diff_cont_on_cl â„‚ f (set.Ioi 0 Ã—â„‚ set.Iio 0)) (hBf : âˆƒ (c : â„) (H : c < 2) (B : â„), f =O[filter.comap complex.abs filter.at_top âŠ“ filter.principal (set.Ioi 0 Ã—â„‚ set.Iio 0)] Î» (z : â„‚), real.exp (B * complex.abs z ^ c)) (hdg : diff_cont_on_cl â„‚ g (set.Ioi 0 Ã—â„‚ set.Iio 0)) (hBg : âˆƒ (c : â„) (H : c < 2) (B : â„), g =O[filter.comap complex.abs filter.at_top âŠ“ filter.principal (set.Ioi 0 Ã—â„‚ set.Iio 0)] Î» (z : â„‚), real.exp (B * complex.abs z ^ c)) (hre : âˆ€ (x : â„), 0 â‰¤ x â†’ f â†‘x = g â†‘x) (him : âˆ€ (x : â„), x â‰¤ 0 â†’ f (â†‘x * complex.I) = g (â†‘x * complex.I)) : set.eq_on f g {z : â„‚ | 0 â‰¤ z.re âˆ§ z.im â‰¤ 0}
theorem monoid_with_zero_hom.ext_rat_on_pnat {M : Type u_4} [group_with_zero M] {f g : â„š â†’*â‚€ M} (same_on_neg_one : â‡‘f (-1) = â‡‘g (-1)) (same_on_pnat : âˆ€ (n : â„•), 0 < n â†’ â‡‘f â†‘n = â‡‘g â†‘n) : f = g
theorem local_equiv.trans_self_symm {Î± : Type u_1} {Î² : Type u_2} (e : local_equiv Î± Î²) : e.trans e.symm â‰ˆ local_equiv.of_set e.source
theorem is_fraction_ring.is_domain (A : Type u_4) [comm_ring A] [is_domain A] {K : Type u_5} [comm_ring K] [algebra A K] [is_fraction_ring A K] : is_domain K
theorem cross_dot_cross {R : Type u_1} [comm_ring R] (u v w x : fin 3 â†’ R) : matrix.dot_product (â‡‘(â‡‘cross_product u) v) (â‡‘(â‡‘cross_product w) x) = matrix.dot_product u w * matrix.dot_product v x - matrix.dot_product u x * matrix.dot_product v w
theorem ennreal.rpow_sum_le_const_mul_sum_rpow {Î¹ : Type u} (s : finset Î¹) (f : Î¹ â†’ ennreal) {p : â„} (hp : 1 â‰¤ p) : s.sum (Î» (i : Î¹), f i) ^ p â‰¤ â†‘(s.card) ^ (p - 1) * s.sum (Î» (i : Î¹), f i ^ p)
theorem sub_mul_action.stabilizer_of_sub_mul {R : Type u} {M : Type v} [group R] [mul_action R M] {p : sub_mul_action R M} (m : â†¥p) : mul_action.stabilizer R m = mul_action.stabilizer R â†‘m
theorem module.finite.of_basis {R : Type u_1} {M : Type u_2} {Î¹ : Type u_3} [comm_ring R] [add_comm_group M] [module R M] [fintype Î¹] (b : basis Î¹ R M) : module.finite R M
theorem category_theory.abelian.pseudoelement.zero_morphism_ext {C : Type u} [category_theory.category C] [category_theory.abelian C] {P Q : C} (f : P âŸ¶ Q) : (âˆ€ (a : â†¥P), â‡‘f a = 0) â†’ f = 0
theorem category_theory.abelian.epi_of_epi_of_epi_of_mono {V : Type u} [category_theory.category V] [category_theory.abelian V] {A B C D A' B' C' D' : V} {f : A âŸ¶ B} {g : B âŸ¶ C} {h : C âŸ¶ D} {f' : A' âŸ¶ B'} {g' : B' âŸ¶ C'} {h' : C' âŸ¶ D'} {Î± : A âŸ¶ A'} {Î² : B âŸ¶ B'} {Î³ : C âŸ¶ C'} {Î´ : D âŸ¶ D'} (commâ‚ : Î± â‰« f' = f â‰« Î²) (commâ‚‚ : Î² â‰« g' = g â‰« Î³) (commâ‚ƒ : Î³ â‰« h' = h â‰« Î´) (hgh : category_theory.exact g h) (hf'g' : category_theory.exact f' g') (hg'h' : category_theory.exact g' h') (hÎ± : category_theory.epi Î±) (hÎ³ : category_theory.epi Î³) (hÎ´ : category_theory.mono Î´) : category_theory.epi Î²
theorem is_right_regular.of_mul {R : Type u_1} {a b : R} [semigroup R] (ab : is_right_regular (b * a)) : is_right_regular b
theorem add_equiv.ext {M : Type u_6} {N : Type u_7} [has_add M] [has_add N] {f g : M â‰ƒ+ N} (h : âˆ€ (x : M), â‡‘f x = â‡‘g x) : f = g
theorem nat.pow_le_iff_le_log {b : â„•} (hb : 1 < b) {x y : â„•} (hy : 0 < y) : b ^ x â‰¤ y â†” x â‰¤ nat.log b y
theorem compact_space_uniformity {Î± : Type u_1} [uniform_space Î±] [compact_space Î±] [separated_space Î±] : uniformity Î± = â¨† (x : Î±), nhds (x, x)
theorem image_le_of_deriv_right_le_deriv_boundary {f f' : â„ â†’ â„} {a b : â„} (hf : continuous_on f (set.Icc a b)) (hf' : âˆ€ (x : â„), x âˆˆ set.Ico a b â†’ has_deriv_within_at f (f' x) (set.Ici x) x) {B B' : â„ â†’ â„} (ha : f a â‰¤ B a) (hB : continuous_on B (set.Icc a b)) (hB' : âˆ€ (x : â„), x âˆˆ set.Ico a b â†’ has_deriv_within_at B (B' x) (set.Ici x) x) (bound : âˆ€ (x : â„), x âˆˆ set.Ico a b â†’ f' x â‰¤ B' x) â¦ƒx : â„â¦„ : x âˆˆ set.Icc a b â†’ f x â‰¤ B x
theorem is_p_group.disjoint_of_ne {G : Type u_1} [group G] (pâ‚ pâ‚‚ : â„•) [hpâ‚ : fact (nat.prime pâ‚)] [hpâ‚‚ : fact (nat.prime pâ‚‚)] (hne : pâ‚ â‰  pâ‚‚) (Hâ‚ Hâ‚‚ : subgroup G) (hHâ‚ : is_p_group pâ‚ â†¥Hâ‚) (hHâ‚‚ : is_p_group pâ‚‚ â†¥Hâ‚‚) : disjoint Hâ‚ Hâ‚‚
theorem finset.subset_sub {Î± : Type u_2} [decidable_eq Î±] [has_sub Î±] {u : finset Î±} {s t : set Î±} : â†‘u âŠ† s - t â†’ (âˆƒ (s' t' : finset Î±), â†‘s' âŠ† s âˆ§ â†‘t' âŠ† t âˆ§ u âŠ† s' - t')
theorem antivary.sum_mul_lt_sum_mul_comp_perm_iff {Î¹ : Type u_1} {Î± : Type u_2} [linear_ordered_ring Î±] {Ïƒ : equiv.perm Î¹} {f g : Î¹ â†’ Î±} [fintype Î¹] (hfg : antivary f g) : finset.univ.sum (Î» (i : Î¹), f i â€¢ g i) < finset.univ.sum (Î» (i : Î¹), f i â€¢ g (â‡‘Ïƒ i)) â†” Â¬antivary f (g âˆ˜ â‡‘Ïƒ)
theorem denoms_clearable_nat_degree {R : Type u_1} {K : Type u_2} [semiring R] [comm_semiring K] {b : R} {bi : K} (i : R â†’+* K) (f : polynomial R) (a : R) (bu : bi * â‡‘i b = 1) : denoms_clearable a b f.nat_degree f i
theorem int.subgroup_cyclic (H : add_subgroup â„¤) : âˆƒ (a : â„¤), H = add_subgroup.closure {a}
theorem polynomial.X_mul {R : Type u} [semiring R] {p : polynomial R} : polynomial.X * p = p * polynomial.X
theorem matrix.is_diag.from_blocks_of_is_symm {Î± : Type u_1} {n : Type u_4} {m : Type u_5} [has_zero Î±] {A : matrix m m Î±} {C : matrix n m Î±} {D : matrix n n Î±} (h : (matrix.from_blocks A 0 C D).is_symm) (ha : A.is_diag) (hd : D.is_diag) : (matrix.from_blocks A 0 C D).is_diag
theorem jacobi_cross {R : Type u_1} [comm_ring R] (u v w : fin 3 â†’ R) : â‡‘(â‡‘cross_product u) (â‡‘(â‡‘cross_product v) w) + â‡‘(â‡‘cross_product v) (â‡‘(â‡‘cross_product w) u) + â‡‘(â‡‘cross_product w) (â‡‘(â‡‘cross_product u) v) = 0
theorem antivary.sum_smul_eq_sum_smul_comp_perm_iff {Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [linear_ordered_ring Î±] [linear_ordered_add_comm_group Î²] [module Î± Î²] [ordered_smul Î± Î²] {Ïƒ : equiv.perm Î¹} {f : Î¹ â†’ Î±} {g : Î¹ â†’ Î²} [fintype Î¹] (hfg : antivary f g) : finset.univ.sum (Î» (i : Î¹), f i â€¢ g (â‡‘Ïƒ i)) = finset.univ.sum (Î» (i : Î¹), f i â€¢ g i) â†” antivary f (g âˆ˜ â‡‘Ïƒ)
theorem shrinking_lemma.partial_refinement.apply_eq_of_chain {Î¹ : Type u_1} {X : Type u_2} [topological_space X] [normal_space X] {u : Î¹ â†’ set X} {s : set X} {c : set (shrinking_lemma.partial_refinement u s)} (hc : is_chain has_le.le c) {vâ‚ vâ‚‚ : shrinking_lemma.partial_refinement u s} (hâ‚ : vâ‚ âˆˆ c) (hâ‚‚ : vâ‚‚ âˆˆ c) {i : Î¹} (hiâ‚ : i âˆˆ vâ‚.carrier) (hiâ‚‚ : i âˆˆ vâ‚‚.carrier) : â‡‘vâ‚ i = â‡‘vâ‚‚ i
theorem euclidean_geometry.exists_circumcenter_eq_of_cospherical_subset {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace â„ P} {ps : set P} (h : ps âŠ† â†‘s) [nonempty â†¥s] {n : â„•} [finite_dimensional â„ â†¥(s.direction)] (hd : finite_dimensional.finrank â„ â†¥(s.direction) = n) (hc : euclidean_geometry.cospherical ps) : âˆƒ (c : P), âˆ€ (sx : affine.simplex â„ P n), set.range sx.points âŠ† ps â†’ sx.circumcenter = c
theorem iterated_fderiv_eq_equiv_comp {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {F : Type u_2} [normed_group F] [normed_space ğ•œ F] {n : â„•} {f : ğ•œ â†’ F} : iterated_fderiv ğ•œ n f = â‡‘(continuous_multilinear_map.pi_field_equiv ğ•œ (fin n) F) âˆ˜ iterated_deriv n f
theorem cont_diff_at.exists_lipschitz_on_with_of_nnnorm_lt {ğ•‚ : Type u_6} [is_R_or_C ğ•‚] {E' : Type u_7} [normed_group E'] [normed_space ğ•‚ E'] {F' : Type u_8} [normed_group F'] [normed_space ğ•‚ F'] {f : E' â†’ F'} {x : E'} (hf : cont_diff_at ğ•‚ 1 f x) (K : nnreal) (hK : âˆ¥fderiv ğ•‚ f xâˆ¥â‚Š < K) : âˆƒ (t : set E') (H : t âˆˆ nhds x), lipschitz_on_with K f t
theorem power_series.order_eq {R : Type u_1} [semiring R] {Ï† : power_series R} {n : enat} : Ï†.order = n â†” (âˆ€ (i : â„•), â†‘i = n â†’ â‡‘(power_series.coeff R i) Ï† â‰  0) âˆ§ âˆ€ (i : â„•), â†‘i < n â†’ â‡‘(power_series.coeff R i) Ï† = 0
theorem le_implies_le_of_le_of_le {Î± : Type u} {a b c d : Î±} [preorder Î±] (hca : c â‰¤ a) (hbd : b â‰¤ d) : a â‰¤ b â†’ c â‰¤ d
theorem orthogonal_family.is_internal_iff_of_is_complete {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {Î¹ : Type u_4} [decidable_eq Î¹] {V : Î¹ â†’ submodule ğ•œ E} (hV : orthogonal_family ğ•œ (Î» (i : Î¹), (V i).subtypeâ‚—áµ¢)) (hc : is_complete â†‘(supr V)) : direct_sum.is_internal V â†” (supr V)á—® = âŠ¥
theorem integral_cos_pow {a b : â„} (n : â„•) : âˆ« (x : â„) in a..b, real.cos x ^ (n + 2) = (real.cos b ^ (n + 1) * real.sin b - real.cos a ^ (n + 1) * real.sin a) / (â†‘n + 2) + (â†‘n + 1) / (â†‘n + 2) * âˆ« (x : â„) in a..b, real.cos x ^ n
theorem list.duplicate_iff_sublist {Î± : Type u_1} {l : list Î±} {x : Î±} : list.duplicate x l â†” [x, x] <+ l
theorem finset.eq_of_card_le_one_of_prod_eq {Î² : Type u} {Î± : Type v} [comm_monoid Î²] {s : finset Î±} (hc : s.card â‰¤ 1) {f : Î± â†’ Î²} {b : Î²} (h : s.prod (Î» (x : Î±), f x) = b) (x : Î±) (H : x âˆˆ s) : f x = b
theorem measure_theory.measure.rn_deriv_with_density {Î± : Type u_1} {m : measurable_space Î±} (Î½ : measure_theory.measure Î±) [measure_theory.sigma_finite Î½] {f : Î± â†’ ennreal} (hf : measurable f) : (Î½.with_density f).rn_deriv Î½ =áµ[Î½] f
theorem unit_interval.nonneg' {t : â†¥unit_interval} : 0 â‰¤ t
theorem affine_subspace.vadd_mem_of_mem_direction {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : affine_subspace k P} {v : V} (hv : v âˆˆ s.direction) {p : P} (hp : p âˆˆ s) : v +áµ¥ p âˆˆ s
theorem lie_submodule.quotient.lie_module_hom_ext {R : Type u} {L : Type v} {M : Type w} [comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] (N : lie_submodule R L M) â¦ƒf g : M â§¸ N â†’â‚—â…R,Lâ† Mâ¦„ (h : f.comp (lie_submodule.quotient.mk' N) = g.comp (lie_submodule.quotient.mk' N)) : f = g
theorem det_rotation (a : â†¥circle) : â‡‘linear_map.det â†‘((â‡‘rotation a).to_linear_equiv) = 1
theorem polynomial.cyclotomic_eq_minpoly_rat {n : â„•} {K : Type u_1} [field K] {Î¼ : K} (h : is_primitive_root Î¼ n) (hpos : 0 < n) [char_zero K] : polynomial.cyclotomic n â„š = minpoly â„š Î¼
theorem is_cyclotomic_extension.discr_prime_pow_eq_unit_mul_pow {p : â„•+} {k : â„•} {K : Type u} {L : Type v} {Î¶ : L} [field K] [field L] [algebra K L] [is_cyclotomic_extension {p ^ k} K L] [hp : fact (nat.prime â†‘p)] [ne_zero â†‘â†‘p] (hÎ¶ : is_primitive_root Î¶ â†‘(p ^ k)) (hirr : irreducible (polynomial.cyclotomic â†‘(p ^ k) K)) : âˆƒ (u : â„¤Ë£) (n : â„•), algebra.discr K â‡‘((is_primitive_root.power_basis K hÎ¶).basis) = â†‘u * â†‘p ^ n
theorem filter.comap_cocompact_le {Î± : Type u} {Î² : Type v} [topological_space Î±] [topological_space Î²] {f : Î± â†’ Î²} (hf : continuous f) : filter.comap f (filter.cocompact Î²) â‰¤ filter.cocompact Î±
theorem function_field_iff (Fq F : Type) [field Fq] [field F] (Fqt : Type u_1) [field Fqt] [algebra (polynomial Fq) Fqt] [is_fraction_ring (polynomial Fq) Fqt] [algebra (ratfunc Fq) F] [algebra Fqt F] [algebra (polynomial Fq) F] [is_scalar_tower (polynomial Fq) Fqt F] [is_scalar_tower (polynomial Fq) (ratfunc Fq) F] : function_field Fq F â†” finite_dimensional Fqt F
theorem is_max_on.undual {Î± : Type u} {Î² : Type v} [preorder Î²] {f : Î± â†’ Î²} {s : set Î±} {a : Î±} : is_max_on (â‡‘order_dual.to_dual âˆ˜ f) s a â†’ is_min_on f s a
theorem list.relation_refl_trans_gen_of_exists_chain {Î± : Type u} {r : Î± â†’ Î± â†’ Prop} {a b : Î±} (l : list Î±) (hlâ‚ : list.chain r a l) (hlâ‚‚ : (a :: l).last _ = b) : relation.refl_trans_gen r a b
theorem has_btw.btw.sbtw_of_not_btw {Î± : Type u_1} [circular_preorder Î±] {a b c : Î±} (habc : has_btw.btw a b c) (hcba : Â¬has_btw.btw c b a) : has_sbtw.sbtw a b c
theorem measure_theory.finite_measure.limsup_measure_closed_le_of_tendsto {Î± : Type u_1} {Î¹ : Type u_2} {L : filter Î¹} [measurable_space Î±] [pseudo_emetric_space Î±] [opens_measurable_space Î±] {Î¼ : measure_theory.finite_measure Î±} {Î¼s : Î¹ â†’ measure_theory.finite_measure Î±} (Î¼s_lim : filter.tendsto Î¼s L (nhds Î¼)) {F : set Î±} (F_closed : is_closed F) : L.limsup (Î» (i : Î¹), â‡‘â†‘(Î¼s i) F) â‰¤ â‡‘â†‘Î¼ F
theorem has_ftaylor_series_up_to_on.has_strict_fderiv_at {n : with_top â„•} {ğ•‚ : Type u_6} [is_R_or_C ğ•‚] {E' : Type u_7} [normed_group E'] [normed_space ğ•‚ E'] {F' : Type u_8} [normed_group F'] [normed_space ğ•‚ F'] {s : set E'} {f : E' â†’ F'} {x : E'} {p : E' â†’ formal_multilinear_series ğ•‚ E' F'} (hf : has_ftaylor_series_up_to_on n f p s) (hn : 1 â‰¤ n) (hs : s âˆˆ nhds x) : has_strict_fderiv_at f (â‡‘(continuous_multilinear_curry_fin1 ğ•‚ E' F') (p x 1)) x
theorem tactic.interval_cases.mem_set_elems {Î± : Type u_1} [decidable_eq Î±] (s : set Î±) [fintype â†¥s] {a : Î±} (h : a âˆˆ s) : a âˆˆ tactic.interval_cases.set_elems s
theorem finset.prod_univ_sum {Î± : Type u_1} {Î² : Type u_2} [decidable_eq Î±] [fintype Î±] [comm_semiring Î²] {Î´ : Î± â†’ Type u_1} [Î  (a : Î±), decidable_eq (Î´ a)] {t : Î  (a : Î±), finset (Î´ a)} {f : Î  (a : Î±), Î´ a â†’ Î²} : finset.univ.prod (Î» (a : Î±), (t a).sum (Î» (b : Î´ a), f a b)) = (fintype.pi_finset t).sum (Î» (p : Î  (a : Î±), Î´ a), finset.univ.prod (Î» (x : Î±), f x (p x)))
theorem cont_diff_fst {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {n : with_top â„•} : cont_diff ğ•œ n prod.fst
theorem polynomial.cyclotomic_mul_prime_pow_eq (R : Type u_1) {p m : â„•} [fact (nat.prime p)] [ring R] [char_p R p] (hm : Â¬p âˆ£ m) {k : â„•} : 0 < k â†’ polynomial.cyclotomic (p ^ k * m) R = polynomial.cyclotomic m R ^ (p ^ k - p ^ (k - 1))
theorem category_theory.nat_trans.epi_app_of_epi {C : Type uâ‚} [category_theory.category C] {D : Type uâ‚‚} [category_theory.category D] {F G : C â¥¤ D} (Î± : F âŸ¶ G) [âˆ€ (X : C), category_theory.epi (Î±.app X)] : category_theory.epi Î±
theorem linear_map.pi_ext' {R : Type u} {M : Type v} {Î¹ : Type x} [semiring R] {Ï† : Î¹ â†’ Type i} [Î  (i : Î¹), add_comm_monoid (Ï† i)] [Î  (i : Î¹), module R (Ï† i)] [fintype Î¹] [decidable_eq Î¹] [add_comm_monoid M] [module R M] {f g : (Î  (i : Î¹), Ï† i) â†’â‚—[R] M} (h : âˆ€ (i : Î¹), f.comp (linear_map.single i) = g.comp (linear_map.single i)) : f = g
theorem linear_map.surjective_of_injective {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] {f : V â†’â‚—[K] V} (hinj : function.injective â‡‘f) : function.surjective â‡‘f
theorem zero_lt.preorder.right.one_le_mul_of_le_of_le {Î± : Type u} {a b : Î±} [mul_one_class Î±] [has_zero Î±] [preorder Î±] [zero_lt.mul_pos_mono Î±] (ha : 1 â‰¤ a) (hb : 1 â‰¤ b) (b0 : 0 < b) : 1 â‰¤ a * b
theorem measure_theory.integrable_prod_iff {Î± : Type u_1} {Î² : Type u_3} {E : Type u_6} [measurable_space Î±] [measurable_space Î²] {Î¼ : measure_theory.measure Î±} {Î½ : measure_theory.measure Î²} [normed_group E] [measure_theory.sigma_finite Î½] â¦ƒf : Î± Ã— Î² â†’ Eâ¦„ (h1f : measure_theory.ae_strongly_measurable f (Î¼.prod Î½)) : measure_theory.integrable f (Î¼.prod Î½) â†” (âˆ€áµ (x : Î±) âˆ‚Î¼, measure_theory.integrable (Î» (y : Î²), f (x, y)) Î½) âˆ§ measure_theory.integrable (Î» (x : Î±), âˆ« (y : Î²), âˆ¥f (x, y)âˆ¥ âˆ‚Î½) Î¼
theorem is_preconnected.Icc_subset {Î± : Type v} [linear_order Î±] [topological_space Î±] [order_closed_topology Î±] {s : set Î±} (hs : is_preconnected s) {a b : Î±} (ha : a âˆˆ s) (hb : b âˆˆ s) : set.Icc a b âŠ† s
theorem is_localization.localization_is_scalar_tower_of_submonoid_le {R : Type u_1} [comm_ring R] (S : Type u_2) [comm_ring S] [algebra R S] (T : Type u_4) [comm_ring T] [algebra R T] (M N : submonoid R) (h : M â‰¤ N) [is_localization M S] [is_localization N T] : is_scalar_tower R S T
theorem finset.subtype_map_of_mem {Î± : Type u_1} {s : finset Î±} {p : Î± â†’ Prop} [decidable_pred p] (h : âˆ€ (x : Î±), x âˆˆ s â†’ p x) : finset.map (function.embedding.subtype p) (finset.subtype p s) = s
theorem orthonormal.oangle_neg_neg {V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) (x y : V) : hb.oangle (-x) (-y) = hb.oangle x y
theorem set_like.list_dprod_eq {Î¹ : Type u_1} {R : Type u_2} {Î± : Type u_3} {S : Type u_4} [set_like S R] [monoid R] [add_monoid Î¹] (A : Î¹ â†’ S) [set_like.graded_monoid A] (fÎ¹ : Î± â†’ Î¹) (fA : Î  (a : Î±), â†¥(A (fÎ¹ a))) (l : list Î±) : l.dprod fÎ¹ fA = âŸ¨(list.map (Î» (a : Î±), â†‘(fA a)) l).prod, _âŸ©
theorem has_sum.tendsto_sum_nat {Î± : Type u_1} [add_comm_monoid Î±] [topological_space Î±] {a : Î±} {f : â„• â†’ Î±} (h : has_sum f a) : filter.tendsto (Î» (n : â„•), (finset.range n).sum (Î» (i : â„•), f i)) filter.at_top (nhds a)
theorem measurable_set.principal_is_measurably_generated {Î± : Type u_1} [measurable_space Î±] {s : set Î±} : measurable_set s â†’ (filter.principal s).is_measurably_generated
theorem zmod.legendre_sym_eq_one_or_neg_one (p : â„•) [fact (nat.prime p)] (a : â„¤) (ha : â†‘a â‰  0) : zmod.legendre_sym p a = 1 âˆ¨ zmod.legendre_sym p a = -1
theorem dense_range.comp {Î² : Type u_2} {Î³ : Type u_3} [topological_space Î²] [topological_space Î³] {Îº : Type u_5} {g : Î² â†’ Î³} {f : Îº â†’ Î²} (hg : dense_range g) (hf : dense_range f) (cg : continuous g) : dense_range (g âˆ˜ f)
theorem category_theory.preadditive.has_kernel_of_has_equalizer {C : Type u} [category_theory.category C] [category_theory.preadditive C] {X Y : C} (f g : X âŸ¶ Y) [category_theory.limits.has_equalizer f g] : category_theory.limits.has_kernel (f - g)
theorem convex.mem_Ioc {ğ•œ : Type u_1} [linear_ordered_field ğ•œ] {x y : ğ•œ} (h : x < y) {z : ğ•œ} : z âˆˆ set.Ioc x y â†” âˆƒ (a b : ğ•œ), 0 â‰¤ a âˆ§ 0 < b âˆ§ a + b = 1 âˆ§ a * x + b * y = z
theorem embedding.is_compact_iff_is_compact_image {Î± : Type u} {Î² : Type v} [topological_space Î±] [topological_space Î²] {s : set Î±} {f : Î± â†’ Î²} (hf : embedding f) : is_compact s â†” is_compact (f '' s)
theorem add_monoid_hom.map_exists_right_neg {M : Type u_3} {N : Type u_4} {F : Type u_8} {mM : add_zero_class M} {mN : add_zero_class N} [add_monoid_hom_class F M N] (f : F) {x : M} (hx : âˆƒ (y : M), x + y = 0) : âˆƒ (y : N), â‡‘f x + y = 0
theorem exterior_algebra.Î¹_range_disjoint_one {R : Type u1} [comm_semiring R] {M : Type u2} [add_comm_monoid M] [module R M] : disjoint (exterior_algebra.Î¹ R).range 1
theorem norm_eq_infi_iff_real_inner_le_zero {F : Type u_3} [inner_product_space â„ F] {K : set F} (h : convex â„ K) {u v : F} (hv : v âˆˆ K) : (âˆ¥u - vâˆ¥ = â¨… (w : â†¥K), âˆ¥u - â†‘wâˆ¥) â†” âˆ€ (w : F), w âˆˆ K â†’ has_inner.inner (u - v) (w - v) â‰¤ 0
theorem mul_eq_mul_prime_pow {R : Type u_1} [cancel_comm_monoid_with_zero R] {x y a p : R} {n : â„•} (hp : prime p) (hx : x * y = a * p ^ n) : âˆƒ (i j : â„•) (b c : R), i + j = n âˆ§ a = b * c âˆ§ x = b * p ^ i âˆ§ y = c * p ^ j
theorem measure_theory.lintegral_abs_det_fderiv_eq_add_haar_image {E : Type u_1} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] {s : set E} {f : E â†’ E} {f' : E â†’ (E â†’L[â„] E)} [measurable_space E] [borel_space E] (Î¼ : measure_theory.measure E) [Î¼.is_add_haar_measure] (hs : measurable_set s) (hf' : âˆ€ (x : E), x âˆˆ s â†’ has_fderiv_within_at f (f' x) s x) (hf : set.inj_on f s) : âˆ«â» (x : E) in s, ennreal.of_real |(f' x).det| âˆ‚Î¼ = â‡‘Î¼ (f '' s)
theorem measure_theory.exists_le_lower_semicontinuous_lintegral_ge {Î± : Type u_1} [topological_space Î±] [measurable_space Î±] [borel_space Î±] (Î¼ : measure_theory.measure Î±) [Î¼.weakly_regular] (f : Î± â†’ ennreal) (hf : measurable f) {Îµ : ennreal} (Îµpos : Îµ â‰  0) : âˆƒ (g : Î± â†’ ennreal), (âˆ€ (x : Î±), f x â‰¤ g x) âˆ§ lower_semicontinuous g âˆ§ âˆ«â» (x : Î±), g x âˆ‚Î¼ â‰¤ âˆ«â» (x : Î±), f x âˆ‚Î¼ + Îµ
theorem is_cyclotomic_extension.empty (A : Type u) (B : Type v) [comm_ring A] [comm_ring B] [algebra A B] [h : is_cyclotomic_extension âˆ… A B] : âŠ¥ = âŠ¤
theorem is_top.to_dual {Î± : Type u_1} [has_le Î±] {a : Î±} : is_top a â†’ is_bot (â‡‘order_dual.to_dual a)
theorem measure_theory.tendsto_lintegral_filter_of_dominated_convergence {Î± : Type u_1} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {Î¹ : Type u_2} {l : filter Î¹} [l.is_countably_generated] {F : Î¹ â†’ Î± â†’ ennreal} {f : Î± â†’ ennreal} (bound : Î± â†’ ennreal) (hF_meas : âˆ€á¶  (n : Î¹) in l, measurable (F n)) (h_bound : âˆ€á¶  (n : Î¹) in l, âˆ€áµ (a : Î±) âˆ‚Î¼, F n a â‰¤ bound a) (h_fin : âˆ«â» (a : Î±), bound a âˆ‚Î¼ â‰  âŠ¤) (h_lim : âˆ€áµ (a : Î±) âˆ‚Î¼, filter.tendsto (Î» (n : Î¹), F n a) l (nhds (f a))) : filter.tendsto (Î» (n : Î¹), âˆ«â» (a : Î±), F n a âˆ‚Î¼) l (nhds (âˆ«â» (a : Î±), f a âˆ‚Î¼))
theorem exists_mem_frontier_inf_dist_compl_eq_dist {E : Type u_1} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] {x : E} {s : set E} (hx : x âˆˆ s) (hs : s â‰  set.univ) : âˆƒ (y : E) (H : y âˆˆ frontier s), metric.inf_dist x sá¶œ = has_dist.dist x y
theorem edist_le_of_edist_le_geometric_two_of_tendstoâ‚€ {Î± : Type u_1} [pseudo_emetric_space Î±] (C : ennreal) {f : â„• â†’ Î±} (hu : âˆ€ (n : â„•), has_edist.edist (f n) (f (n + 1)) â‰¤ C / 2 ^ n) {a : Î±} (ha : filter.tendsto f filter.at_top (nhds a)) : has_edist.edist (f 0) a â‰¤ 2 * C
theorem Top.presheaf.covering_of_presieve.fork_map_comp_first_obj_iso_pi_opens_eq {C : Type u} [category_theory.category C] [category_theory.limits.has_products C] {X : Top} (F : Top.presheaf C X) (U : topological_space.opens â†¥X) (R : category_theory.presieve U) (hR : category_theory.sieve.generate R âˆˆ â‡‘(opens.grothendieck_topology â†¥X) U) : category_theory.presheaf.fork_map R F â‰« (Top.presheaf.covering_of_presieve.first_obj_iso_pi_opens F U R).hom = F.map (category_theory.eq_to_hom _).op â‰« Top.presheaf.sheaf_condition_equalizer_products.res F (Top.presheaf.covering_of_presieve U R)
theorem euclidean_geometry.orthogonal_projection_fn_mem_orthogonal {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace â„ P} [nonempty â†¥s] [complete_space â†¥(s.direction)] (p : P) : euclidean_geometry.orthogonal_projection_fn s p âˆˆ affine_subspace.mk' p (s.direction)á—®
theorem finsum_sub_distrib {Î± : Type u_1} {G : Type u_4} [subtraction_comm_monoid G] {f g : Î± â†’ G} (hf : (function.support f).finite) (hg : (function.support g).finite) : finsum (Î» (i : Î±), f i - g i) = finsum (Î» (i : Î±), f i) - finsum (Î» (i : Î±), g i)
theorem odd.exists_bit1 {Î± : Type u_2} [semiring Î±] {a : Î±} : odd a â†’ (âˆƒ (b : Î±), a = bit1 b)
theorem padic_val_nat.mul (p : â„•) [p_prime : fact (nat.prime p)] {q r : â„•} (hq : q â‰  0) (hr : r â‰  0) : padic_val_nat p (q * r) = padic_val_nat p q + padic_val_nat p r
theorem category_theory.abelian.mono_inl_of_factor_thru_epi_mono_factorization {C : Type u} [category_theory.category C] [category_theory.abelian C] [category_theory.limits.has_pushouts C] {W X Y Z : C} (f : X âŸ¶ Y) (g : X âŸ¶ Z) (gâ‚ : X âŸ¶ W) [category_theory.epi gâ‚] (gâ‚‚ : W âŸ¶ Z) [category_theory.mono gâ‚‚] (hg : gâ‚ â‰« gâ‚‚ = g) (f' : W âŸ¶ Y) (hf : gâ‚ â‰« f' = f) (t : category_theory.limits.pushout_cocone f g) (ht : category_theory.limits.is_colimit t) : category_theory.mono t.inl
theorem circle_deg1_lift.translation_number_of_map_pow_eq_add_int (f : circle_deg1_lift) {x : â„} {n : â„•} {m : â„¤} (h : â‡‘(f ^ n) x = x + â†‘m) (hn : 0 < n) : f.translation_number = â†‘m / â†‘n
theorem add_subgroup.eq_zero_of_noncomm_sum_eq_zero_of_independent {G : Type u_1} [add_group G] {Î¹ : Type u_2} (s : finset Î¹) (f : Î¹ â†’ G) (comm : âˆ€ (x : Î¹), x âˆˆ s â†’ âˆ€ (y : Î¹), y âˆˆ s â†’ add_commute (f x) (f y)) (K : Î¹ â†’ add_subgroup G) (hind : complete_lattice.independent K) (hmem : âˆ€ (x : Î¹), x âˆˆ s â†’ f x âˆˆ K x) (heq1 : s.noncomm_sum f comm = 0) (i : Î¹) (H : i âˆˆ s) : f i = 0
theorem finprod_mem_insert {Î± : Type u_1} {M : Type u_5} [comm_monoid M] {a : Î±} {s : set Î±} (f : Î± â†’ M) (h : a âˆ‰ s) (hs : s.finite) : finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ has_insert.insert a s), f i)) = f a * finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), f i))
theorem inner_product_geometry.norm_sub_sq_eq_norm_sq_add_norm_sq_sub_two_mul_norm_mul_norm_mul_cos_angle {V : Type u_1} [inner_product_space â„ V] (x y : V) : âˆ¥x - yâˆ¥ * âˆ¥x - yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + âˆ¥yâˆ¥ * âˆ¥yâˆ¥ - 2 * âˆ¥xâˆ¥ * âˆ¥yâˆ¥ * real.cos (inner_product_geometry.angle x y)
theorem category_theory.limits.is_iso_Ï€_of_is_initial {C : Type uâ‚} [category_theory.category C] {J : Type u} [category_theory.category J] {j : J} (I : category_theory.limits.is_initial j) (F : J â¥¤ C) [category_theory.limits.has_limit F] : category_theory.is_iso (category_theory.limits.limit.Ï€ F j)
theorem div_self_mul_self {Gâ‚€ : Type u_2} [group_with_zero Gâ‚€] (a : Gâ‚€) : a / a * a = a
theorem add_hom.congr_fun {M : Type u_3} {N : Type u_4} [has_add M] [has_add N] {f g : add_hom M N} (h : f = g) (x : M) : â‡‘f x = â‡‘g x
theorem continuous_on.mono_rng {Î± : Type u_1} {Î² : Type u_2} {tâ‚ : topological_space Î±} {tâ‚‚ tâ‚ƒ : topological_space Î²} (hâ‚ : tâ‚‚ â‰¤ tâ‚ƒ) {s : set Î±} {f : Î± â†’ Î²} (hâ‚‚ : continuous_on f s) : continuous_on f s
theorem cardinal.mk_Ioi_real (a : â„) : cardinal.mk â†¥(set.Ioi a) = cardinal.continuum
theorem add_subgroup.neg_mem {G : Type u_1} [add_group G] (H : add_subgroup G) {x : G} : x âˆˆ H â†’ -x âˆˆ H
theorem category_theory.limits.initial_mono_class.of_initial {C : Type uâ‚} [category_theory.category C] [category_theory.limits.has_initial C] (h : âˆ€ (X : C), category_theory.mono (category_theory.limits.initial.to X)) : category_theory.limits.initial_mono_class C
theorem set.finset_prod_subset_finset_prod {Î± : Type u_2} {Î¹ : Type u_5} [comm_monoid Î±] (t : finset Î¹) (fâ‚ fâ‚‚ : Î¹ â†’ set Î±) (hf : âˆ€ {i : Î¹}, i âˆˆ t â†’ fâ‚ i âŠ† fâ‚‚ i) : t.prod (Î» (i : Î¹), fâ‚ i) âŠ† t.prod (Î» (i : Î¹), fâ‚‚ i)
theorem is_dedekind_domain.height_one_spectrum.valuation_uniformizer_ne_zero {R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] (K : Type u_2) [field K] [algebra R K] [is_fraction_ring R K] (v : is_dedekind_domain.height_one_spectrum R) : classical.some _ â‰  0
theorem measure_theory.measure.mk_metric_mono_smul {X : Type u_2} [emetric_space X] [measurable_space X] [borel_space X] {mâ‚ mâ‚‚ : ennreal â†’ ennreal} {c : ennreal} (hc : c â‰  âŠ¤) (h0 : c â‰  0) (hle : mâ‚ â‰¤á¶ [nhds_within 0 (set.Ici 0)] c â€¢ mâ‚‚) : measure_theory.measure.mk_metric mâ‚ â‰¤ c â€¢ measure_theory.measure.mk_metric mâ‚‚
theorem orthogonal_projection_mem_subspace_orthogonal_precomplement_eq_zero {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {K : submodule ğ•œ E} [complete_space E] {v : E} (hv : v âˆˆ K) : â‡‘(orthogonal_projection Ká—®) v = 0
theorem structure_groupoid.id_mem_maximal_atlas {H : Type u} [topological_space H] (G : structure_groupoid H) : local_homeomorph.refl H âˆˆ structure_groupoid.maximal_atlas H G
theorem measure_theory.lintegral_add_left {Î± : Type u_1} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {f : Î± â†’ ennreal} (hf : measurable f) (g : Î± â†’ ennreal) : âˆ«â» (a : Î±), f a + g a âˆ‚Î¼ = âˆ«â» (a : Î±), f a âˆ‚Î¼ + âˆ«â» (a : Î±), g a âˆ‚Î¼
theorem mul_equiv.is_mul_hom {M : Type u_1} {N : Type u_2} [mul_one_class M] [mul_one_class N] (h : M â‰ƒ* N) : is_mul_hom â‡‘h
theorem measure_theory.measure.regular.inner_regular_measurable {Î± : Type u_1} [measurable_space Î±] [topological_space Î±] {Î¼ : measure_theory.measure Î±} [Î¼.regular] : Î¼.inner_regular is_compact (Î» (s : set Î±), measurable_set s âˆ§ â‡‘Î¼ s â‰  âŠ¤)
theorem asymptotics.is_O_with_of_eq_mul {Î± : Type u_1} {ğ•œ : Type u_14} [normed_field ğ•œ] {c : â„} {l : filter Î±} {u v : Î± â†’ ğ•œ} (Ï† : Î± â†’ ğ•œ) (hÏ† : âˆ€á¶  (x : Î±) in l, âˆ¥Ï† xâˆ¥ â‰¤ c) (h : u =á¶ [l] Ï† * v) : asymptotics.is_O_with c l u v
theorem ennreal.rpow_arith_mean_le_arith_mean2_rpow (wâ‚ wâ‚‚ zâ‚ zâ‚‚ : ennreal) (hw' : wâ‚ + wâ‚‚ = 1) {p : â„} (hp : 1 â‰¤ p) : (wâ‚ * zâ‚ + wâ‚‚ * zâ‚‚) ^ p â‰¤ wâ‚ * zâ‚ ^ p + wâ‚‚ * zâ‚‚ ^ p
theorem con.ker_lift_range_eq {M : Type u_1} {P : Type u_3} [mul_one_class M] [mul_one_class P] {f : M â†’* P} : (con.ker_lift f).mrange = f.mrange
theorem category_theory.prod_comparison_iso {C : Type uâ‚} {D : Type uâ‚‚} [category_theory.category C] [category_theory.category D] (i : D â¥¤ C) [category_theory.limits.has_finite_products C] [category_theory.reflective i] [category_theory.cartesian_closed C] [category_theory.exponential_ideal i] (A B : C) : category_theory.is_iso (category_theory.limits.prod_comparison (category_theory.left_adjoint i) A B)
theorem category_theory.presieve.is_sheaf_for_subsieve {C : Type uâ‚} [category_theory.category C] {X : C} (P : Cáµ’áµ– â¥¤ Type w) {S : category_theory.sieve X} {R : category_theory.presieve X} (h : â‡‘S â‰¤ R) (trans : âˆ€ â¦ƒY : Câ¦„ (f : Y âŸ¶ X), category_theory.presieve.is_sheaf_for P â‡‘(category_theory.sieve.pullback f S)) : category_theory.presieve.is_sheaf_for P R
theorem con.eq {M : Type u_1} [has_mul M] (c : con M) {a b : M} : â†‘a = â†‘b â†” â‡‘c a b
theorem subsemiring.list_sum_mem {R : Type u} [non_assoc_semiring R] (s : subsemiring R) {l : list R} : (âˆ€ (x : R), x âˆˆ l â†’ x âˆˆ s) â†’ l.sum âˆˆ s
theorem category_theory.limits.has_pushouts_of_has_colimit_span (C : Type u) [category_theory.category C] [âˆ€ {X Y Z : C} {f : X âŸ¶ Y} {g : X âŸ¶ Z}, category_theory.limits.has_colimit (category_theory.limits.span f g)] : category_theory.limits.has_pushouts C
theorem nonempty_interior_of_Union_of_closed {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [baire_space Î±] [nonempty Î±] [encodable Î²] {f : Î² â†’ set Î±} (hc : âˆ€ (s : Î²), is_closed (f s)) (hU : (â‹ƒ (s : Î²), f s) = set.univ) : âˆƒ (s : Î²), (interior (f s)).nonempty
theorem orthogonal_family.linear_isometry_equiv_symm_apply {Î¹ : Type u_1} {ğ•œ : Type u_2} [is_R_or_C ğ•œ] {E : Type u_3} [inner_product_space ğ•œ E] [cplt : complete_space E] {G : Î¹ â†’ Type u_4} [Î  (i : Î¹), inner_product_space ğ•œ (G i)] {V : Î  (i : Î¹), G i â†’â‚—áµ¢[ğ•œ] E} (hV : orthogonal_family ğ•œ V) [âˆ€ (i : Î¹), complete_space (G i)] (hV' : (â¨† (i : Î¹), (V i).to_linear_map.range).topological_closure = âŠ¤) (w : â†¥(lp G 2)) : â‡‘((hV.linear_isometry_equiv hV').symm) w = âˆ‘' (i : Î¹), â‡‘(V i) (â‡‘w i)
theorem function.is_fixed_pt.is_periodic_pt {Î± : Type u_1} {f : Î± â†’ Î±} {x : Î±} (hf : function.is_fixed_pt f x) (n : â„•) : function.is_periodic_pt f n x
theorem nat.sum_range_choose (n : â„•) : (finset.range (n + 1)).sum (Î» (m : â„•), n.choose m) = 2 ^ n
theorem exists_polynomial_near_continuous_map (a b : â„) (f : C(â†¥(set.Icc a b), â„)) (Îµ : â„) (pos : 0 < Îµ) : âˆƒ (p : polynomial â„), âˆ¥p.to_continuous_map_on (set.Icc a b) - fâˆ¥ < Îµ
theorem measurable_measure_prod_mk_left_finite {Î± : Type u_1} {Î² : Type u_3} [measurable_space Î±] [measurable_space Î²] {Î½ : measure_theory.measure Î²} [measure_theory.is_finite_measure Î½] {s : set (Î± Ã— Î²)} (hs : measurable_set s) : measurable (Î» (x : Î±), â‡‘Î½ (prod.mk x â»Â¹' s))
theorem sylow.card_normalizer_modeq_card {G : Type u} [group G] [fintype G] {p n : â„•} [hp : fact (nat.prime p)] {H : subgroup G} (hH : fintype.card â†¥H = p ^ n) : fintype.card â†¥(H.normalizer) â‰¡ fintype.card G [MOD p ^ (n + 1)]
theorem is_closed.Icc_subset_of_forall_exists_gt {Î± : Type u} [conditionally_complete_linear_order Î±] [topological_space Î±] [order_topology Î±] {a b : Î±} {s : set Î±} (hs : is_closed (s âˆ© set.Icc a b)) (ha : a âˆˆ s) (hgt : âˆ€ (x : Î±), x âˆˆ s âˆ© set.Ico a b â†’ âˆ€ (y : Î±), y âˆˆ set.Ioi x â†’ (s âˆ© set.Ioc x y).nonempty) : set.Icc a b âŠ† s
theorem exists_seq_norm_le_one_le_norm_sub' {ğ•œ : Type u} [nondiscrete_normed_field ğ•œ] {E : Type v} [normed_group E] [normed_space ğ•œ E] [complete_space ğ•œ] {c : ğ•œ} (hc : 1 < âˆ¥câˆ¥) {R : â„} (hR : âˆ¥câˆ¥ < R) (h : Â¬finite_dimensional ğ•œ E) : âˆƒ (f : â„• â†’ E), (âˆ€ (n : â„•), âˆ¥f nâˆ¥ â‰¤ R) âˆ§ âˆ€ (m n : â„•), m â‰  n â†’ 1 â‰¤ âˆ¥f m - f nâˆ¥
theorem le_cInf_inter {Î± : Type u_1} [conditionally_complete_lattice Î±] {s t : set Î±} : bdd_below s â†’ bdd_below t â†’ (s âˆ© t).nonempty â†’ has_Inf.Inf s âŠ” has_Inf.Inf t â‰¤ has_Inf.Inf (s âˆ© t)
theorem left.inv_lt_one_iff {Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a : Î±} : aâ»Â¹ < 1 â†” 1 < a
theorem zmod.int_cast_comp_cast {n : â„•} (R : Type u_1) [ring R] : coe âˆ˜ coe = coe
theorem nat.choose_le_central_binom (r n : â„•) : (2 * n).choose r â‰¤ n.central_binom
theorem pmf.to_measure_bind_on_support_apply {Î± : Type u_1} {Î² : Type u_2} {p : pmf Î±} (f : Î  (a : Î±), a âˆˆ p.support â†’ pmf Î²) (s : set Î²) [measurable_space Î²] (hs : measurable_set s) : â‡‘((p.bind_on_support f).to_measure) s = âˆ‘' (a : Î±), â†‘(â‡‘p a) * dite (â‡‘p a = 0) (Î» (h : â‡‘p a = 0), 0) (Î» (h : Â¬â‡‘p a = 0), â‡‘((f a h).to_measure) s)
theorem dense_sInter_of_open {Î± : Type u_1} [topological_space Î±] [baire_space Î±] {S : set (set Î±)} (ho : âˆ€ (s : set Î±), s âˆˆ S â†’ is_open s) (hS : S.countable) (hd : âˆ€ (s : set Î±), s âˆˆ S â†’ dense s) : dense (â‹‚â‚€ S)
theorem pi.single_smul' {I : Type u} {Î± : Type u_1} {Î² : Type u_2} [monoid Î±] [add_monoid Î²] [distrib_mul_action Î± Î²] [decidable_eq I] (i : I) (r : Î±) (x : Î²) : pi.single i (r â€¢ x) = r â€¢ pi.single i x
theorem complex.norm_eq_on_closed_ball_of_is_max_on {E : Type u} [normed_group E] [normed_space â„‚ E] {F : Type v} [normed_group F] [normed_space â„‚ F] {f : E â†’ F} {z : E} {r : â„} (hd : diff_cont_on_cl â„‚ f (metric.ball z r)) (hz : is_max_on (has_norm.norm âˆ˜ f) (metric.ball z r) z) : set.eq_on (has_norm.norm âˆ˜ f) (function.const E âˆ¥f zâˆ¥) (metric.closed_ball z r)
theorem has_fderiv_within_at.unique_on {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {f : E â†’ F} {f' fâ‚' : E â†’L[ğ•œ] F} {x : E} {s : set E} (hf : has_fderiv_within_at f f' s x) (hg : has_fderiv_within_at f fâ‚' s x) : set.eq_on â‡‘f' â‡‘fâ‚' (tangent_cone_at ğ•œ s x)
theorem subtype.range_coe_subtype {Î± : Type u_1} {p : Î± â†’ Prop} : set.range coe = {x : Î± | p x}
theorem is_add_regular_add_and_add_iff {R : Type u_1} {a b : R} [add_semigroup R] : is_add_regular (a + b) âˆ§ is_add_regular (b + a) â†” is_add_regular a âˆ§ is_add_regular b
theorem lt_add_of_neg_add_lt {Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b c : Î±} : -b + a < c â†’ a < b + c
theorem pow_two_sub_pow_two {R : Type uâ‚} [comm_ring R] (a b : R) : a ^ 2 - b ^ 2 = (a + b) * (a - b)
theorem finset.card_sym2 {Î± : Type u_1} [decidable_eq Î±] (s : finset Î±) : s.sym2.card = s.card * (s.card + 1) / 2
theorem function.injective.map_at_top_finset_prod_eq {Î± : Type u_3} {Î² : Type u_4} {Î³ : Type u_5} [comm_monoid Î±] {g : Î³ â†’ Î²} (hg : function.injective g) {f : Î² â†’ Î±} (hf : âˆ€ (x : Î²), x âˆ‰ set.range g â†’ f x = 1) : filter.map (Î» (s : finset Î³), s.prod (Î» (i : Î³), f (g i))) filter.at_top = filter.map (Î» (s : finset Î²), s.prod (Î» (i : Î²), f i)) filter.at_top
theorem topological_space.is_topological_basis.mem_closure_iff {Î± : Type u} [t : topological_space Î±] {b : set (set Î±)} (hb : topological_space.is_topological_basis b) {s : set Î±} {a : Î±} : a âˆˆ closure s â†” âˆ€ (o : set Î±), o âˆˆ b â†’ a âˆˆ o â†’ (o âˆ© s).nonempty
theorem multiset.nat.nodup_antidiagonal (n : â„•) : (multiset.nat.antidiagonal n).nodup
theorem add_action.card_orbit_add_card_stabilizer_eq_card_add_group (Î± : Type u) {Î² : Type v} [add_group Î±] [add_action Î± Î²] (b : Î²) [fintype Î±] [fintype â†¥(add_action.orbit Î± b)] [fintype â†¥(add_action.stabilizer Î± b)] : fintype.card â†¥(add_action.orbit Î± b) * fintype.card â†¥(add_action.stabilizer Î± b) = fintype.card Î±
theorem measure_theory.lintegral_prod {Î± : Type u_1} {Î² : Type u_3} [measurable_space Î±] [measurable_space Î²] {Î¼ : measure_theory.measure Î±} {Î½ : measure_theory.measure Î²} [measure_theory.sigma_finite Î½] (f : Î± Ã— Î² â†’ ennreal) (hf : ae_measurable f (Î¼.prod Î½)) : âˆ«â» (z : Î± Ã— Î²), f z âˆ‚Î¼.prod Î½ = âˆ«â» (x : Î±), âˆ«â» (y : Î²), f (x, y) âˆ‚Î½ âˆ‚Î¼
theorem ray_vector.equiv_neg_iff {R : Type u_1} [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {vâ‚ vâ‚‚ : ray_vector R M} : -vâ‚ â‰ˆ -vâ‚‚ â†” vâ‚ â‰ˆ vâ‚‚
theorem is_compact.bdd_above {Î± : Type u} [topological_space Î±] [linear_order Î±] [order_closed_topology Î±] [nonempty Î±] {s : set Î±} (hs : is_compact s) : bdd_above s
theorem asymptotics.is_O_iff_is_O_with {Î± : Type u_1} {E : Type u_3} {F : Type u_4} [has_norm E] [has_norm F] {f : Î± â†’ E} {g : Î± â†’ F} {l : filter Î±} : f =O[l] g â†” âˆƒ (c : â„), asymptotics.is_O_with c l f g
theorem measure_theory.integral_eq_zero_of_mul_right_eq_neg {G : Type u_4} {E : Type u_5} [measurable_space G] [normed_group E] [normed_space â„ E] [complete_space E] {Î¼ : measure_theory.measure G} {f : G â†’ E} {g : G} [group G] [has_measurable_mul G] [Î¼.is_mul_right_invariant] (hf' : âˆ€ (x : G), f (x * g) = -f x) : âˆ« (x : G), f x âˆ‚Î¼ = 0
theorem qpf.recF_eq_of_Wequiv {F : Type u â†’ Type u} [functor F] [q : qpf F] {Î± : Type u} (u : F Î± â†’ Î±) (x y : (qpf.P F).W) : qpf.Wequiv x y â†’ qpf.recF u x = qpf.recF u y
theorem measure_theory.is_fundamental_domain.mk' {G : Type u_1} {Î± : Type u_2} [group G] [mul_action G Î±] [measurable_space Î±] {s : set Î±} {Î¼ : measure_theory.measure Î±} (h_meas : measure_theory.null_measurable_set s Î¼) (h_exists : âˆ€ (x : Î±), âˆƒ! (g : G), g â€¢ x âˆˆ s) : measure_theory.is_fundamental_domain G s Î¼
theorem affine.simplex.dist_circumcenter_eq_circumradius {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {n : â„•} (s : affine.simplex â„ P n) (i : fin (n + 1)) : has_dist.dist (s.points i) s.circumcenter = s.circumradius
theorem affine.simplex.circumcenter_mem_affine_span {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {n : â„•} (s : affine.simplex â„ P n) : s.circumcenter âˆˆ affine_span â„ (set.range s.points)
theorem continuous.exists_forall_le {Î± : Type u_1} {Î² : Type u_2} [conditionally_complete_linear_order Î±] [topological_space Î±] [order_topology Î±] [topological_space Î²] [nonempty Î²] {f : Î² â†’ Î±} (hf : continuous f) (hlim : filter.tendsto f (filter.cocompact Î²) filter.at_top) : âˆƒ (x : Î²), âˆ€ (y : Î²), f x â‰¤ f y
theorem is_integral.linear_independent_pow {S : Type u_2} [comm_ring S] {K : Type u_6} [field K] [algebra K S] {x : S} (hx : is_integral K x) : linear_independent K (Î» (i : fin (minpoly K x).nat_degree), x ^ â†‘i)
theorem finprod_mem_union {Î± : Type u_1} {M : Type u_5} [comm_monoid M] {f : Î± â†’ M} {s t : set Î±} (hst : disjoint s t) (hs : s.finite) (ht : t.finite) : finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s âˆª t), f i)) = finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), f i)) * finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ t), f i))
theorem nat.factorization_disjoint_of_coprime {a b : â„•} (hab : a.coprime b) : disjoint a.factorization.support b.factorization.support
theorem image_le_of_deriv_right_lt_deriv_boundary {f f' : â„ â†’ â„} {a b : â„} (hf : continuous_on f (set.Icc a b)) (hf' : âˆ€ (x : â„), x âˆˆ set.Ico a b â†’ has_deriv_within_at f (f' x) (set.Ici x) x) {B B' : â„ â†’ â„} (ha : f a â‰¤ B a) (hB : âˆ€ (x : â„), has_deriv_at B (B' x) x) (bound : âˆ€ (x : â„), x âˆˆ set.Ico a b â†’ f x = B x â†’ f' x < B' x) â¦ƒx : â„â¦„ : x âˆˆ set.Icc a b â†’ f x â‰¤ B x
theorem subfield.closure_eq {K : Type u} [field K] (s : subfield K) : subfield.closure â†‘s = s
theorem lattice_ordered_comm_group.mabs_mul_le {Î± : Type u} [lattice Î±] [comm_group Î±] [covariant_class Î± Î± has_mul.mul has_le.le] (a b : Î±) : |a * b| â‰¤ |a| * |b|
theorem add_con.Sup_eq_add_con_gen {M : Type u_1} [has_add M] (S : set (add_con M)) : has_Sup.Sup S = add_con_gen (Î» (x y : M), âˆƒ (c : add_con M), c âˆˆ S âˆ§ â‡‘c x y)
theorem is_min_filter.undual {Î± : Type u} {Î² : Type v} [preorder Î²] {f : Î± â†’ Î²} {l : filter Î±} {a : Î±} : is_min_filter (â‡‘order_dual.to_dual âˆ˜ f) l a â†’ is_max_filter f l a
theorem discrete_valuation_ring.irreducible_iff_uniformizer {R : Type u} [comm_ring R] [is_domain R] [discrete_valuation_ring R] (Ï– : R) : irreducible Ï– â†” local_ring.maximal_ideal R = ideal.span {Ï–}
theorem has_le.le.eq_of_not_gt {Î± : Type u} [partial_order Î±] {a b : Î±} (hab : a â‰¤ b) (hba : Â¬a < b) : b = a
theorem bounded_continuous_function.exists_extension_norm_eq_of_closed_embedding {X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] [normal_space Y] (f : bounded_continuous_function X â„) {e : X â†’ Y} (he : closed_embedding e) : âˆƒ (g : bounded_continuous_function Y â„), âˆ¥gâˆ¥ = âˆ¥fâˆ¥ âˆ§ â‡‘g âˆ˜ e = â‡‘f
theorem measure_theory.Lp.mem_bounded_continuous_function_iff {Î± : Type u_1} {E : Type u_2} {m0 : measurable_space Î±} {p : ennreal} {Î¼ : measure_theory.measure Î±} [normed_group E] [topological_space Î±] [borel_space Î±] [second_countable_topology_either Î± E] {f : â†¥(measure_theory.Lp E p Î¼)} : f âˆˆ measure_theory.Lp.bounded_continuous_function E p Î¼ â†” âˆƒ (fâ‚€ : bounded_continuous_function Î± E), continuous_map.to_ae_eq_fun Î¼ fâ‚€.to_continuous_map = â†‘f
theorem add_subgroup.multiset_sum_mem {G : Type u_1} [add_comm_group G] (K : add_subgroup G) (g : multiset G) : (âˆ€ (a : G), a âˆˆ g â†’ a âˆˆ K) â†’ g.sum âˆˆ K
theorem finset.centroid_eq_affine_combination_fintype (k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] {Î¹ : Type u_4} (s : finset Î¹) [fintype Î¹] (p : Î¹ â†’ P) : finset.centroid k s p = â‡‘(finset.univ.affine_combination p) (finset.centroid_weights_indicator k s)
theorem real.tendsto_exp_div_pow_at_top (n : â„•) : filter.tendsto (Î» (x : â„), real.exp x / x ^ n) filter.at_top filter.at_top
theorem nat.fib_add (m n : â„•) : nat.fib (m + n + 1) = nat.fib m * nat.fib n + nat.fib (m + 1) * nat.fib (n + 1)
theorem affine_subspace.mem_affine_span_insert_iff {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : affine_subspace k P} {p1 : P} (hp1 : p1 âˆˆ s) (p2 p : P) : p âˆˆ affine_span k (has_insert.insert p2 â†‘s) â†” âˆƒ (r : k) (p0 : P) (hp0 : p0 âˆˆ s), p = r â€¢ (p2 -áµ¥ p1) +áµ¥ p0
theorem finset.nonempty.cons_induction {Î± : Type u_1} {p : Î  (s : finset Î±), s.nonempty â†’ Prop} (hâ‚€ : âˆ€ (a : Î±), p {a} _) (hâ‚ : âˆ€ â¦ƒa : Î±â¦„ (s : finset Î±) (h : a âˆ‰ s) (hs : s.nonempty), p s hs â†’ p (finset.cons a s h) _) {s : finset Î±} (hs : s.nonempty) : p s hs
theorem fractional_ideal.mul_inv_cancel {A : Type u_2} {K : Type u_3} [comm_ring A] [field K] [is_domain A] [algebra A K] [is_fraction_ring A K] [is_dedekind_domain A] {I : fractional_ideal (non_zero_divisors A) K} (hne : I â‰  0) : I * Iâ»Â¹ = 1
theorem measurable_sub_const' {G : Type u_1} [sub_neg_monoid G] [measurable_space G] [has_measurable_add G] (g : G) : measurable (Î» (h : G), h - g)
theorem con.ext' {M : Type u_1} [has_mul M] {c d : con M} (H : setoid.r = setoid.r) : c = d
theorem projective_spectrum.gc_set {R : Type u_1} {A : Type u_2} [comm_semiring R] [comm_ring A] [algebra R A] (ğ’œ : â„• â†’ submodule R A) [graded_algebra ğ’œ] : galois_connection (Î» (s : set A), projective_spectrum.zero_locus ğ’œ s) (Î» (t : (set (projective_spectrum ğ’œ))áµ’áµˆ), â†‘(projective_spectrum.vanishing_ideal t))
theorem measure_theory.measure.ext_of_generate_from_of_cover_subset {Î± : Type u_1} {m0 : measurable_space Î±} {Î¼ Î½ : measure_theory.measure Î±} {S T : set (set Î±)} (h_gen : m0 = measurable_space.generate_from S) (h_inter : is_pi_system S) (h_sub : T âŠ† S) (hc : T.countable) (hU : â‹ƒâ‚€T = set.univ) (htop : âˆ€ (s : set Î±), s âˆˆ T â†’ â‡‘Î¼ s â‰  âŠ¤) (h_eq : âˆ€ (s : set Î±), s âˆˆ S â†’ â‡‘Î¼ s = â‡‘Î½ s) : Î¼ = Î½
theorem monotone.tendsto_at_bot_at_bot_iff {Î± : Type u_3} {Î² : Type u_4} [nonempty Î±] [semilattice_inf Î±] [preorder Î²] {f : Î± â†’ Î²} (hf : monotone f) : filter.tendsto f filter.at_bot filter.at_bot â†” âˆ€ (b : Î²), âˆƒ (a : Î±), f a â‰¤ b
theorem matrix.det_succ_column_zero {R : Type v} [comm_ring R] {n : â„•} (A : matrix (fin n.succ) (fin n.succ) R) : A.det = finset.univ.sum (Î» (i : fin n.succ), (-1) ^ â†‘i * A i 0 * (A.minor â‡‘(i.succ_above) fin.succ).det)
theorem category_theory.has_colimits_of_shape_of_has_colimits_of_shape_creates_colimits_of_shape {C : Type uâ‚} [category_theory.category C] {D : Type uâ‚‚} [category_theory.category D] {J : Type w} [category_theory.category J] (F : C â¥¤ D) [category_theory.limits.has_colimits_of_shape J D] [category_theory.creates_colimits_of_shape J F] : category_theory.limits.has_colimits_of_shape J C
theorem complex.circle_integral_sub_inv_smul_of_differentiable_on_off_countable {E : Type u} [normed_group E] [normed_space â„‚ E] [complete_space E] {R : â„} {c w : â„‚} {f : â„‚ â†’ E} {s : set â„‚} (hs : s.countable) (hw : w âˆˆ metric.ball c R) (hc : continuous_on f (metric.closed_ball c R)) (hd : âˆ€ (x : â„‚), x âˆˆ metric.ball c R  s â†’ differentiable_at â„‚ f x) : âˆ® (z : â„‚) in C(c, R), (z - w)â»Â¹ â€¢ f z = (2 * â†‘real.pi * complex.I) â€¢ f w
theorem is_closed.mem_of_ge_of_forall_exists_gt {Î± : Type u} [conditionally_complete_linear_order Î±] [topological_space Î±] [order_topology Î±] {a b : Î±} {s : set Î±} (hs : is_closed (s âˆ© set.Icc a b)) (ha : a âˆˆ s) (hab : a â‰¤ b) (hgt : âˆ€ (x : Î±), x âˆˆ s âˆ© set.Ico a b â†’ (s âˆ© set.Ioc x b).nonempty) : b âˆˆ s
theorem pow_two_nonneg {R : Type u_4} [linear_ordered_ring R] (a : R) : 0 â‰¤ a ^ 2
theorem convex.add_haar_frontier {E : Type u_1} [normed_group E] [normed_space â„ E] [measurable_space E] [borel_space E] [finite_dimensional â„ E] (Î¼ : measure_theory.measure E) [Î¼.is_add_haar_measure] {s : set E} (hs : convex â„ s) : â‡‘Î¼ (frontier s) = 0
theorem generalized_continued_fraction.int_fract_pair.one_le_succ_nth_stream_b {K : Type u_1} {v : K} {n : â„•} [linear_ordered_field K] [floor_ring K] {ifp_succ_n : generalized_continued_fraction.int_fract_pair K} (succ_nth_stream_eq : generalized_continued_fraction.int_fract_pair.stream v (n + 1) = option.some ifp_succ_n) : 1 â‰¤ ifp_succ_n.b
theorem linear_map.trace_eq_matrix_trace_of_finset (R : Type u) [comm_semiring R] {M : Type v} [add_comm_monoid M] [module R M] {s : finset M} (b : basis â†¥s R M) (f : M â†’â‚—[R] M) : â‡‘(linear_map.trace R M) f = (â‡‘(linear_map.to_matrix b b) f).trace
theorem mv_polynomial.derivation_eq_on_supported {Ïƒ : Type u_1} {R : Type u_2} {A : Type u_3} [comm_semiring R] [add_comm_monoid A] [module R A] [module (mv_polynomial Ïƒ R) A] {Dâ‚ Dâ‚‚ : derivation R (mv_polynomial Ïƒ R) A} {s : set Ïƒ} (h : set.eq_on (â‡‘Dâ‚ âˆ˜ mv_polynomial.X) (â‡‘Dâ‚‚ âˆ˜ mv_polynomial.X) s) {f : mv_polynomial Ïƒ R} (hf : f âˆˆ mv_polynomial.supported R s) : â‡‘Dâ‚ f = â‡‘Dâ‚‚ f
theorem ideal.exists_ideal_over_maximal_of_is_integral {R : Type u_1} [comm_ring R] {S : Type u_2} [comm_ring S] [algebra R S] [is_domain S] (H : algebra.is_integral R S) (P : ideal R) [P_max : P.is_maximal] (hP : (algebra_map R S).ker â‰¤ P) : âˆƒ (Q : ideal S), Q.is_maximal âˆ§ ideal.comap (algebra_map R S) Q = P
theorem fixing_submonoid_fixed_points_gc (M : Type u_1) (Î± : Type u_2) [monoid M] [mul_action M Î±] : galois_connection (â‡‘order_dual.to_dual âˆ˜ fixing_submonoid M) ((Î» (P : submonoid M), mul_action.fixed_points â†¥P Î±) âˆ˜ â‡‘order_dual.of_dual)
theorem is_preconnected.image {Î± : Type u} {Î² : Type v} [topological_space Î±] [topological_space Î²] {s : set Î±} (H : is_preconnected s) (f : Î± â†’ Î²) (hf : continuous_on f s) : is_preconnected (f '' s)
theorem measure_theory.measure_preserving.prod {Î± : Type u_1} {Î² : Type u_3} {Î³ : Type u_5} [measurable_space Î±] [measurable_space Î²] [measurable_space Î³] {Î´ : Type u_7} [measurable_space Î´] {Î¼a : measure_theory.measure Î±} {Î¼b : measure_theory.measure Î²} {Î¼c : measure_theory.measure Î³} {Î¼d : measure_theory.measure Î´} [measure_theory.sigma_finite Î¼b] [measure_theory.sigma_finite Î¼d] {f : Î± â†’ Î²} {g : Î³ â†’ Î´} (hf : measure_theory.measure_preserving f Î¼a Î¼b) (hg : measure_theory.measure_preserving g Î¼c Î¼d) : measure_theory.measure_preserving (prod.map f g) (Î¼a.prod Î¼c) (Î¼b.prod Î¼d)
theorem complex.tendsto_abs_cocompact_at_top  : filter.tendsto complex.abs (filter.cocompact â„‚) filter.at_top
theorem measurable_equiv.map_apply {Î± : Type u_1} {Î² : Type u_2} [measurable_space Î±] [measurable_space Î²] {Î¼ : measure_theory.measure Î±} (f : Î± â‰ƒáµ Î²) (s : set Î²) : â‡‘(measure_theory.measure.map â‡‘f Î¼) s = â‡‘Î¼ (â‡‘f â»Â¹' s)
theorem add_con.lift_coe {M : Type u_1} {P : Type u_3} [add_zero_class M] [add_zero_class P] {c : add_con M} {f : M â†’+ P} (H : c â‰¤ add_con.ker f) (x : M) : â‡‘(c.lift f H) â†‘x = â‡‘f x
theorem composition.sigma_composition_eq_iff {n : â„•} (i j : Î£ (a : composition n), composition a.length) : i = j â†” i.fst.blocks = j.fst.blocks âˆ§ i.snd.blocks = j.snd.blocks
theorem discrim_le_zero {K : Type u_1} [linear_ordered_field K] {a b c : K} (h : âˆ€ (x : K), 0 â‰¤ a * x * x + b * x + c) : discrim a b c â‰¤ 0
theorem affine_subspace.self_mem_mk' {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (p : P) (direction : submodule k V) : p âˆˆ affine_subspace.mk' p direction
theorem con.induction_on {M : Type u_1} [has_mul M] {c : con M} {C : c.quotient â†’ Prop} (q : c.quotient) (H : âˆ€ (x : M), C â†‘x) : C q
theorem add_submonoid.supr_eq_mrange_dfinsupp_sum_add_hom {Î¹ : Type u} {Î³ : Type w} [dec : decidable_eq Î¹] [add_comm_monoid Î³] (S : Î¹ â†’ add_submonoid Î³) : supr S = (dfinsupp.sum_add_hom (Î» (i : Î¹), (S i).subtype)).mrange
theorem padic_norm.nonzero (p : â„•) [hp : fact (nat.prime p)] {q : â„š} (hq : q â‰  0) : padic_norm p q â‰  0
theorem is_projective.iff_projective {R : Type u} [ring R] {P : Type (max u v)} [add_comm_group P] [module R P] : module.projective R P â†” category_theory.projective (Module.of R P)
theorem Module.has_kernels_Module {R : Type u} [ring R] : category_theory.limits.has_kernels (Module R)
theorem normed_ring.inverse_continuous_at {R : Type u_1} [normed_ring R] [complete_space R] (x : RË£) : continuous_at ring.inverse â†‘x
theorem subsemiring.add_mem {R : Type u} [non_assoc_semiring R] (s : subsemiring R) {x y : R} : x âˆˆ s â†’ y âˆˆ s â†’ x + y âˆˆ s
theorem holder_with.dimH_range_le {X : Type u_2} {Y : Type u_3} [emetric_space X] [emetric_space Y] {C r : nnreal} {f : X â†’ Y} (h : holder_with C r f) (hr : 0 < r) : dimH (set.range f) â‰¤ dimH set.univ / â†‘r
theorem interval_integral.has_fderiv_at_integral_of_dominated_of_fderiv_le {ğ•œ : Type u_1} [is_R_or_C ğ•œ] {Î¼ : measure_theory.measure â„} {E : Type u_2} [normed_group E] [normed_space â„ E] [normed_space ğ•œ E] [complete_space E] {H : Type u_3} [normed_group H] [normed_space ğ•œ H] {a b Îµ : â„} {bound : â„ â†’ â„} {F : H â†’ â„ â†’ E} {F' : H â†’ â„ â†’ (H â†’L[ğ•œ] E)} {xâ‚€ : H} (Îµ_pos : 0 < Îµ) (hF_meas : âˆ€á¶  (x : H) in nhds xâ‚€, measure_theory.ae_strongly_measurable (F x) (Î¼.restrict (set.interval_oc a b))) (hF_int : interval_integrable (F xâ‚€) Î¼ a b) (hF'_meas : measure_theory.ae_strongly_measurable (F' xâ‚€) (Î¼.restrict (set.interval_oc a b))) (h_bound : âˆ€áµ (t : â„) âˆ‚Î¼, t âˆˆ set.interval_oc a b â†’ âˆ€ (x : H), x âˆˆ metric.ball xâ‚€ Îµ â†’ âˆ¥F' x tâˆ¥ â‰¤ bound t) (bound_integrable : interval_integrable bound Î¼ a b) (h_diff : âˆ€áµ (t : â„) âˆ‚Î¼, t âˆˆ set.interval_oc a b â†’ âˆ€ (x : H), x âˆˆ metric.ball xâ‚€ Îµ â†’ has_fderiv_at (Î» (x : H), F x t) (F' x t) x) : has_fderiv_at (Î» (x : H), âˆ« (t : â„) in a..b, F x t âˆ‚Î¼) (âˆ« (t : â„) in a..b, F' xâ‚€ t âˆ‚Î¼) xâ‚€
theorem cSup_inter_le {Î± : Type u_1} [conditionally_complete_lattice Î±] {s t : set Î±} (hs : bdd_above s) (ht : bdd_above t) (hst : (s âˆ© t).nonempty) : has_Sup.Sup (s âˆ© t) â‰¤ has_Sup.Sup s âŠ“ has_Sup.Sup t
theorem configuration.nondegenerate.exists_injective_of_card_le {P L : Type u} [has_mem P L] [configuration.nondegenerate P L] [fintype P] [fintype L] (h : fintype.card L â‰¤ fintype.card P) : âˆƒ (f : L â†’ P), function.injective f âˆ§ âˆ€ (l : L), f l âˆ‰ l
theorem is_local_extr_on.exists_multipliers_of_has_strict_fderiv_at_1d {E : Type u_1} [normed_group E] [normed_space â„ E] [complete_space E] {Ï† : E â†’ â„} {xâ‚€ : E} {Ï†' : E â†’L[â„] â„} {f : E â†’ â„} {f' : E â†’L[â„] â„} (hextr : is_local_extr_on Ï† {x : E | f x = f xâ‚€} xâ‚€) (hf' : has_strict_fderiv_at f f' xâ‚€) (hÏ†' : has_strict_fderiv_at Ï† Ï†' xâ‚€) : âˆƒ (a b : â„), (a, b) â‰  0 âˆ§ a â€¢ f' + b â€¢ Ï†' = 0
theorem matrix.det_zero_of_column_eq {n : Type u_2} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] {M : matrix n n R} {i j : n} (i_ne_j : i â‰  j) (hij : âˆ€ (k : n), M k i = M k j) : M.det = 0
theorem order_of_eq_of_pow_and_pow_div_prime {G : Type u} {x : G} {n : â„•} [monoid G] (hn : 0 < n) (hx : x ^ n = 1) (hd : âˆ€ (p : â„•), nat.prime p â†’ p âˆ£ n â†’ x ^ (n / p) â‰  1) : order_of x = n
theorem add_monoid.closure_singleton {M : Type u_1} [add_monoid M] {x : M} : add_monoid.closure {x} = multiples x
theorem is_local_extr_on.range_ne_top_of_has_strict_fderiv_at {E : Type u_1} {F : Type u_2} [normed_group E] [normed_space â„ E] [complete_space E] [normed_group F] [normed_space â„ F] [complete_space F] {f : E â†’ F} {Ï† : E â†’ â„} {xâ‚€ : E} {f' : E â†’L[â„] F} {Ï†' : E â†’L[â„] â„} (hextr : is_local_extr_on Ï† {x : E | f x = f xâ‚€} xâ‚€) (hf' : has_strict_fderiv_at f f' xâ‚€) (hÏ†' : has_strict_fderiv_at Ï† Ï†' xâ‚€) : (f'.prod Ï†').range â‰  âŠ¤
theorem metric.bounded_sphere {Î± : Type u} [pseudo_metric_space Î±] {x : Î±} {r : â„} : metric.bounded (metric.sphere x r)
theorem is_cyclotomic_extension.discr_prime_pow_ne_two {p : â„•+} {k : â„•} {K : Type u} {L : Type v} {Î¶ : L} [field K] [field L] [algebra K L] [is_cyclotomic_extension {p ^ (k + 1)} K L] [hp : fact (nat.prime â†‘p)] [ne_zero â†‘â†‘p] (hÎ¶ : is_primitive_root Î¶ â†‘(p ^ (k + 1))) (hirr : irreducible (polynomial.cyclotomic â†‘(p ^ (k + 1)) K)) (hk : p ^ (k + 1) â‰  2) : algebra.discr K â‡‘((is_primitive_root.power_basis K hÎ¶).basis) = (-1) ^ ((â†‘p ^ (k + 1)).totient / 2) * â†‘p ^ (â†‘p ^ k * ((â†‘p - 1) * (k + 1) - 1))
theorem orthonormal.two_zsmul_oangle_neg_left {V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) (x y : V) : 2 â€¢ hb.oangle (-x) y = 2 â€¢ hb.oangle x y
theorem eventually_uniformity_comp_subset {Î± : Type u_1} [uniform_space Î±] {s : set (Î± Ã— Î±)} (hs : s âˆˆ uniformity Î±) : âˆ€á¶  (t : set (Î± Ã— Î±)) in (uniformity Î±).small_sets, comp_rel t t âŠ† s
theorem orthonormal.rotation_zero {V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) : hb.rotation 0 = linear_isometry_equiv.refl â„ V
theorem category_theory.limits.limit_Ï€_is_iso_of_is_strict_terminal {C : Type u} [category_theory.category C] [category_theory.limits.has_strict_terminal_objects C] {J : Type v} [category_theory.small_category J] (F : J â¥¤ C) [category_theory.limits.has_limit F] (i : J) (H : Î  (j : J), j â‰  i â†’ category_theory.limits.is_terminal (F.obj j)) [subsingleton (i âŸ¶ i)] : category_theory.is_iso (category_theory.limits.limit.Ï€ F i)
theorem measure_theory.ae_of_forall_measure_lt_top_ae_restrict' {Î± : Type u_1} {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (Î½ : measure_theory.measure Î±) [measure_theory.sigma_finite Î¼] [measure_theory.sigma_finite Î½] (P : Î± â†’ Prop) (h : âˆ€ (s : set Î±), measurable_set s â†’ â‡‘Î¼ s < âŠ¤ â†’ â‡‘Î½ s < âŠ¤ â†’ (âˆ€áµ (x : Î±) âˆ‚Î¼.restrict s, P x)) : âˆ€áµ (x : Î±) âˆ‚Î¼, P x
theorem lower_central_series_is_descending_central_series {G : Type u_1} [group G] : is_descending_central_series (lower_central_series G)
theorem pgame.right_response_spec {x : pgame} (h : x â‰¤ 0) (i : x.left_moves) : (x.move_left i).move_right (pgame.right_response h i) â‰¤ 0
theorem subgroup.schur_zassenhaus_induction.step7 {G : Type u} [group G] [fintype G] {N : subgroup G} [N.normal] (h1 : (fintype.card â†¥N).coprime N.index) (h2 : âˆ€ (G' : Type u) [_inst_4 : group G'] [_inst_5 : fintype G'], fintype.card G' < fintype.card G â†’ âˆ€ {N' : subgroup G'} [_inst_6 : N'.normal], (fintype.card â†¥N').coprime N'.index â†’ (âˆƒ (H' : subgroup G'), N'.is_complement' H')) (h3 : âˆ€ (H : subgroup G), Â¬N.is_complement' H) : N.is_commutative
theorem weak_dual.is_closed_polar (ğ•œ : Type u_1) [nondiscrete_normed_field ğ•œ] {E : Type u_2} [semi_normed_group E] [normed_space ğ•œ E] (s : set E) : is_closed (weak_dual.polar ğ•œ s)
theorem ODE_solution_unique {E : Type u_1} [normed_group E] [normed_space â„ E] {v : â„ â†’ E â†’ E} {K : nnreal} (hv : âˆ€ (t : â„), lipschitz_with K (v t)) {f g : â„ â†’ E} {a b : â„} (hf : continuous_on f (set.Icc a b)) (hf' : âˆ€ (t : â„), t âˆˆ set.Ico a b â†’ has_deriv_within_at f (v t (f t)) (set.Ici t) t) (hg : continuous_on g (set.Icc a b)) (hg' : âˆ€ (t : â„), t âˆˆ set.Ico a b â†’ has_deriv_within_at g (v t (g t)) (set.Ici t) t) (ha : f a = g a) (t : â„) (H : t âˆˆ set.Icc a b) : f t = g t
theorem module.free.rank_finsupp (R : Type u) [ring R] [strong_rank_condition R] {Î¹ : Type v} : module.rank R (Î¹ â†’â‚€ R) = (cardinal.mk Î¹).lift
theorem cont_diff_succ_iff_deriv {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {fâ‚‚ : ğ•œ â†’ F} {n : â„•} : cont_diff ğ•œ â†‘(n + 1) fâ‚‚ â†” differentiable ğ•œ fâ‚‚ âˆ§ cont_diff ğ•œ â†‘n (deriv fâ‚‚)
theorem polynomial.cyclotomic.is_primitive (n : â„•) (R : Type u_1) [comm_ring R] : (polynomial.cyclotomic n R).is_primitive
theorem is_compact.diff {Î± : Type u} [topological_space Î±] {s t : set Î±} (hs : is_compact s) (ht : is_open t) : is_compact (s  t)
theorem zmod.Ï‡â‚ˆ_int_eq_if_mod_eight (n : â„¤) : â‡‘zmod.Ï‡â‚ˆ â†‘n = ite (n % 2 = 0) 0 (ite (n % 8 = 1 âˆ¨ n % 8 = 7) 1 (-1))
theorem has_fpower_series_on_cauchy_integral {E : Type u_1} [normed_group E] [normed_space â„‚ E] [complete_space E] {f : â„‚ â†’ E} {c : â„‚} {R : nnreal} (hf : circle_integrable f c â†‘R) (hR : 0 < R) : has_fpower_series_on_ball (Î» (w : â„‚), (2 * â†‘real.pi * complex.I)â»Â¹ â€¢ âˆ® (z : â„‚) in C(c, â†‘R), (z - w)â»Â¹ â€¢ f z) (cauchy_power_series f c â†‘R) c â†‘R
theorem subtype.mem {Î± : Type u_1} {s : set Î±} (p : â†¥s) : â†‘p âˆˆ s
theorem first_order.language.substructure.ext {L : first_order.language} {M : Type w} [L.Structure M] {S T : L.substructure M} (h : âˆ€ (x : M), x âˆˆ S â†” x âˆˆ T) : S = T
theorem sbtw_cyclic {Î± : Type u_1} [circular_preorder Î±] {a b c : Î±} : has_sbtw.sbtw a b c â†” has_sbtw.sbtw c a b
theorem affine.simplex.sum_monge_point_vsub_face_centroid_weights_with_circumcenter {n : â„•} {iâ‚ iâ‚‚ : fin (n + 3)} (h : iâ‚ â‰  iâ‚‚) : finset.univ.sum (Î» (i : affine.simplex.points_with_circumcenter_index (n + 2)), affine.simplex.monge_point_vsub_face_centroid_weights_with_circumcenter iâ‚ iâ‚‚ i) = 0
theorem category_theory.topology_of_closure_operator_self {C : Type u} [category_theory.category C] (Jâ‚ : category_theory.grothendieck_topology C) : category_theory.topology_of_closure_operator Jâ‚.closure_operator _ = Jâ‚
theorem polynomial.cyclotomic'_one (R : Type u_1) [comm_ring R] [is_domain R] : polynomial.cyclotomic' 1 R = polynomial.X - 1
theorem category_theory.limits.colimit.Î¹_desc {J : Type uâ‚} [category_theory.category J] {C : Type u} [category_theory.category C] {F : J â¥¤ C} [category_theory.limits.has_colimit F] (c : category_theory.limits.cocone F) (j : J) : category_theory.limits.colimit.Î¹ F j â‰« category_theory.limits.colimit.desc F c = c.Î¹.app j
theorem measure_theory.is_fundamental_domain.is_mul_left_invariant_map {G : Type u_1} [group G] [measurable_space G] [topological_space G] [topological_group G] [borel_space G] {Î¼ : measure_theory.measure G} {Î“ : subgroup G} {ğ“• : set G} (hğ“• : measure_theory.is_fundamental_domain â†¥(Î“.opposite) ğ“• Î¼) [encodable â†¥Î“] [measurable_space (G â§¸ Î“)] [borel_space (G â§¸ Î“)] [Î“.normal] [Î¼.is_mul_left_invariant] [Î¼.is_mul_right_invariant] : (measure_theory.measure.map â‡‘(quotient_group.mk' Î“) (Î¼.restrict ğ“•)).is_mul_left_invariant
theorem monovary_on.sum_smul_comp_perm_eq_sum_smul_iff {Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [linear_ordered_ring Î±] [linear_ordered_add_comm_group Î²] [module Î± Î²] [ordered_smul Î± Î²] {s : finset Î¹} {Ïƒ : equiv.perm Î¹} {f : Î¹ â†’ Î±} {g : Î¹ â†’ Î²} (hfg : monovary_on f g â†‘s) (hÏƒ : {x : Î¹ | â‡‘Ïƒ x â‰  x} âŠ† â†‘s) : s.sum (Î» (i : Î¹), f i â€¢ g (â‡‘Ïƒ i)) = s.sum (Î» (i : Î¹), f i â€¢ g i) â†” monovary_on f (g âˆ˜ â‡‘Ïƒ) â†‘s
theorem measure_theory.set_integral_condexp_L1_clm {Î± : Type u_1} {F' : Type u_7} [normed_group F'] [normed_space â„ F'] [complete_space F'] {m m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {hm : m â‰¤ m0} [measure_theory.sigma_finite (Î¼.trim hm)] {s : set Î±} (f : â†¥(measure_theory.Lp F' 1 Î¼)) (hs : measurable_set s) : âˆ« (x : Î±) in s, â‡‘(â‡‘(measure_theory.condexp_L1_clm hm Î¼) f) x âˆ‚Î¼ = âˆ« (x : Î±) in s, â‡‘f x âˆ‚Î¼
theorem formal_multilinear_series.radius_eq_liminf {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] (p : formal_multilinear_series ğ•œ E F) : p.radius = filter.at_top.liminf (Î» (n : â„•), 1 / â†‘(âˆ¥p nâˆ¥â‚Š ^ (1 / â†‘n)))
theorem subring.prod_mem {R : Type u_1} [comm_ring R] (s : subring R) {Î¹ : Type u_2} {t : finset Î¹} {f : Î¹ â†’ R} (h : âˆ€ (c : Î¹), c âˆˆ t â†’ f c âˆˆ s) : t.prod (Î» (i : Î¹), f i) âˆˆ s
theorem matrix.exists_mul_vec_eq_zero_iff_aux {n : Type u_3} [fintype n] {K : Type u_1} [decidable_eq n] [field K] {M : matrix n n K} : (âˆƒ (v : n â†’ K) (H : v â‰  0), M.mul_vec v = 0) â†” M.det = 0
theorem finsum_mem_union_inter {Î± : Type u_1} {M : Type u_5} [add_comm_monoid M] {f : Î± â†’ M} {s t : set Î±} (hs : s.finite) (ht : t.finite) : finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s âˆª t), f i)) + finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s âˆ© t), f i)) = finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), f i)) + finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ t), f i))
theorem measure_theory.measure_mul_lintegral_eq {G : Type u_1} [measurable_space G] [group G] [has_measurable_mulâ‚‚ G] (Î¼ Î½ : measure_theory.measure G) [measure_theory.sigma_finite Î½] [measure_theory.sigma_finite Î¼] {E : set G} [has_measurable_inv G] [Î¼.is_mul_left_invariant] [Î½.is_mul_left_invariant] (Em : measurable_set E) (f : G â†’ ennreal) (hf : measurable f) : â‡‘Î¼ E * âˆ«â» (y : G), f y âˆ‚Î½ = âˆ«â» (x : G), â‡‘Î½ ((Î» (z : G), z * x) â»Â¹' E) * f xâ»Â¹ âˆ‚Î¼
theorem metric.dist_le_diam_of_mem' {Î± : Type u} [pseudo_metric_space Î±] {s : set Î±} {x y : Î±} (h : emetric.diam s â‰  âŠ¤) (hx : x âˆˆ s) (hy : y âˆˆ s) : has_dist.dist x y â‰¤ metric.diam s
theorem pi_norm_lt_iff {Î¹ : Type u_2} {Ï€ : Î¹ â†’ Type u_1} [fintype Î¹] [Î  (i : Î¹), semi_normed_group (Ï€ i)] {r : â„} (hr : 0 < r) {x : Î  (i : Î¹), Ï€ i} : âˆ¥xâˆ¥ < r â†” âˆ€ (i : Î¹), âˆ¥x iâˆ¥ < r
theorem polynomial.cyclotomic_injective {R : Type u_1} [comm_ring R] [char_zero R] : function.injective (Î» (n : â„•), polynomial.cyclotomic n R)
theorem metric.controlled_of_uniform_embedding {Î± : Type u} {Î² : Type v} [pseudo_metric_space Î±] [pseudo_metric_space Î²] {f : Î± â†’ Î²} : uniform_embedding f â†’ ((âˆ€ (Îµ : â„), Îµ > 0 â†’ (âˆƒ (Î´ : â„) (H : Î´ > 0), âˆ€ {a b : Î±}, has_dist.dist a b < Î´ â†’ has_dist.dist (f a) (f b) < Îµ)) âˆ§ âˆ€ (Î´ : â„), Î´ > 0 â†’ (âˆƒ (Îµ : â„) (H : Îµ > 0), âˆ€ {a b : Î±}, has_dist.dist (f a) (f b) < Îµ â†’ has_dist.dist a b < Î´))
theorem direct_sum.is_internal.submodule_supr_eq_top {R : Type u} [semiring R] {Î¹ : Type v} [dec_Î¹ : decidable_eq Î¹] {M : Type u_1} [add_comm_monoid M] [module R M] {A : Î¹ â†’ submodule R M} (h : direct_sum.is_internal A) : supr A = âŠ¤
theorem finsupp.prod_ite_eq' {Î± : Type u_1} {M : Type u_5} {N : Type u_7} [has_zero M] [comm_monoid N] [decidable_eq Î±] (f : Î± â†’â‚€ M) (a : Î±) (b : Î± â†’ M â†’ N) : f.prod (Î» (x : Î±) (v : M), ite (x = a) (b x v) 1) = ite (a âˆˆ f.support) (b a (â‡‘f a)) 1
theorem alternating_group.normal_closure_swap_mul_swap_five  : subgroup.normal_closure {âŸ¨equiv.swap 0 4 * equiv.swap 1 3, _âŸ©} = âŠ¤
theorem cInf_eq_of_forall_ge_of_forall_gt_exists_lt {Î± : Type u_1} [conditionally_complete_lattice Î±] {s : set Î±} {b : Î±} : s.nonempty â†’ (âˆ€ (a : Î±), a âˆˆ s â†’ b â‰¤ a) â†’ (âˆ€ (w : Î±), b < w â†’ (âˆƒ (a : Î±) (H : a âˆˆ s), a < w)) â†’ has_Inf.Inf s = b
theorem finset.up_shadow_empty {Î± : Type u_1} [decidable_eq Î±] [fintype Î±] : âˆ….up_shadow = âˆ…
theorem is_compact.inter_right {Î± : Type u} [topological_space Î±] {s t : set Î±} (hs : is_compact s) (ht : is_closed t) : is_compact (s âˆ© t)
theorem measure_theory.integral_divergence_of_has_fderiv_within_at_off_countable_of_equiv {E : Type u} [normed_group E] [normed_space â„ E] [complete_space E] {n : â„•} {F : Type u_1} [normed_group F] [normed_space â„ F] [partial_order F] [measure_theory.measure_space F] [borel_space F] (eL : F â‰ƒL[â„] fin (n + 1) â†’ â„) (he_ord : âˆ€ (x y : F), â‡‘eL x â‰¤ â‡‘eL y â†” x â‰¤ y) (he_vol : measure_theory.measure_preserving â‡‘eL measure_theory.measure_space.volume measure_theory.measure_space.volume) (f : fin (n + 1) â†’ F â†’ E) (f' : fin (n + 1) â†’ F â†’ (F â†’L[â„] E)) (s : set F) (hs : s.countable) (a b : F) (hle : a â‰¤ b) (Hc : âˆ€ (i : fin (n + 1)), continuous_on (f i) (set.Icc a b)) (Hd : âˆ€ (x : F), x âˆˆ interior (set.Icc a b)  s â†’ âˆ€ (i : fin (n + 1)), has_fderiv_at (f i) (f' i x) x) (DF : F â†’ E) (hDF : âˆ€ (x : F), DF x = finset.univ.sum (Î» (i : fin (n + 1)), â‡‘(f' i x) (â‡‘(eL.symm) (pi.single i 1)))) (Hi : measure_theory.integrable_on DF (set.Icc a b) measure_theory.measure_space.volume) : âˆ« (x : F) in set.Icc a b, DF x = finset.univ.sum (Î» (i : fin (n + 1)), (âˆ« (x : fin n â†’ â„) in set.Icc (â‡‘eL a âˆ˜ â‡‘(i.succ_above)) (â‡‘eL b âˆ˜ â‡‘(i.succ_above)), f i (â‡‘(eL.symm) (i.insert_nth (â‡‘eL b i) x))) - âˆ« (x : fin n â†’ â„) in set.Icc (â‡‘eL a âˆ˜ â‡‘(i.succ_above)) (â‡‘eL b âˆ˜ â‡‘(i.succ_above)), f i (â‡‘(eL.symm) (i.insert_nth (â‡‘eL a i) x)))
theorem dense.inter_of_GÎ´ {Î± : Type u_1} [topological_space Î±] [baire_space Î±] {s t : set Î±} (hs : is_GÎ´ s) (ht : is_GÎ´ t) (hsc : dense s) (htc : dense t) : dense (s âˆ© t)
theorem integral_sin_pow_even_mul_cos_pow_even {a b : â„} (m n : â„•) : âˆ« (x : â„) in a..b, real.sin x ^ (2 * m) * real.cos x ^ (2 * n) = âˆ« (x : â„) in a..b, ((1 - real.cos (2 * x)) / 2) ^ m * ((1 + real.cos (2 * x)) / 2) ^ n
theorem alternating_map.coe_alternatization {R : Type u_1} [semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {N' : Type u_5} [add_comm_group N'] [module R N'] {Î¹ : Type u_6} [decidable_eq Î¹] [fintype Î¹] (a : alternating_map R M N' Î¹) : â‡‘multilinear_map.alternatization â†‘a = (fintype.card Î¹).factorial â€¢ a
theorem padic_val_int.zero {p : â„•} : padic_val_int p 0 = 0
theorem lie_algebra.lie_ideal.solvable_iff_le_radical (R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] [is_noetherian R L] (I : lie_ideal R L) : lie_algebra.is_solvable R â†¥I â†” I â‰¤ lie_algebra.radical R L
theorem add_con.coe_zero {M : Type u_1} [add_zero_class M] {c : add_con M} : â†‘0 = 0
theorem metric.diam_union {Î± : Type u} [pseudo_metric_space Î±] {s : set Î±} {x y : Î±} {t : set Î±} (xs : x âˆˆ s) (yt : y âˆˆ t) : metric.diam (s âˆª t) â‰¤ metric.diam s + has_dist.dist x y + metric.diam t
theorem directed_of_sup {Î± : Type u} {Î² : Type v} [semilattice_sup Î±] {f : Î± â†’ Î²} {r : Î² â†’ Î² â†’ Prop} (H : âˆ€ â¦ƒi j : Î±â¦„, i â‰¤ j â†’ r (f i) (f j)) : directed r f
theorem continuous_multilinear_map.map_sum {R : Type u} {Î¹ : Type v} {Mâ‚ : Î¹ â†’ Type wâ‚} {Mâ‚‚ : Type wâ‚‚} [decidable_eq Î¹] [semiring R] [Î  (i : Î¹), add_comm_monoid (Mâ‚ i)] [add_comm_monoid Mâ‚‚] [Î  (i : Î¹), module R (Mâ‚ i)] [module R Mâ‚‚] [Î  (i : Î¹), topological_space (Mâ‚ i)] [topological_space Mâ‚‚] (f : continuous_multilinear_map R Mâ‚ Mâ‚‚) {Î± : Î¹ â†’ Type u_1} [fintype Î¹] (g : Î  (i : Î¹), Î± i â†’ Mâ‚ i) [Î  (i : Î¹), fintype (Î± i)] : â‡‘f (Î» (i : Î¹), finset.univ.sum (Î» (j : Î± i), g i j)) = finset.univ.sum (Î» (r : Î  (i : Î¹), Î± i), â‡‘f (Î» (i : Î¹), g i (r i)))
theorem continuous.exists_forall_le_of_has_compact_mul_support {Î± : Type u_1} {Î² : Type u_2} [conditionally_complete_linear_order Î±] [topological_space Î±] [order_topology Î±] [topological_space Î²] [nonempty Î²] [has_one Î±] {f : Î² â†’ Î±} (hf : continuous f) (h : has_compact_mul_support f) : âˆƒ (x : Î²), âˆ€ (y : Î²), f x â‰¤ f y
theorem int.dvd_of_dvd_mul_left_of_gcd_one {a b c : â„¤} (habc : a âˆ£ b * c) (hab : a.gcd c = 1) : a âˆ£ b
theorem nndist_self {Î± : Type u} [pseudo_metric_space Î±] (a : Î±) : has_nndist.nndist a a = 0
theorem set.image2_subset {Î± : Type u_1} {Î² : Type u_3} {Î³ : Type u_5} {f : Î± â†’ Î² â†’ Î³} {s s' : set Î±} {t t' : set Î²} (hs : s âŠ† s') (ht : t âŠ† t') : set.image2 f s t âŠ† set.image2 f s' t'
theorem finset.prod_erase_mul {Î² : Type u} {Î± : Type v} [comm_monoid Î²] [decidable_eq Î±] (s : finset Î±) (f : Î± â†’ Î²) {a : Î±} (h : a âˆˆ s) : (s.erase a).prod (Î» (x : Î±), f x) * f a = s.prod (Î» (x : Î±), f x)
theorem mv_power_series.ext_iff {Ïƒ : Type u_1} {R : Type u_2} [semiring R] {Ï† Ïˆ : mv_power_series Ïƒ R} : Ï† = Ïˆ â†” âˆ€ (n : Ïƒ â†’â‚€ â„•), â‡‘(mv_power_series.coeff R n) Ï† = â‡‘(mv_power_series.coeff R n) Ïˆ
theorem orthonormal.tsum_inner_products_le {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {Î¹ : Type u_4} (x : E) {v : Î¹ â†’ E} (hv : orthonormal ğ•œ v) : âˆ‘' (i : Î¹), âˆ¥has_inner.inner (v i) xâˆ¥ ^ 2 â‰¤ âˆ¥xâˆ¥ ^ 2
theorem Inter_halfspaces_eq {E : Type u_2} [normed_group E] [normed_space â„ E] {s : set E} (hsâ‚ : convex â„ s) (hsâ‚‚ : is_closed s) : (â‹‚ (l : E â†’L[â„] â„), {x : E | âˆƒ (y : E) (H : y âˆˆ s), â‡‘l x â‰¤ â‡‘l y}) = s
theorem add_monoid_hom.congr_arg {M : Type u_3} {N : Type u_4} [add_zero_class M] [add_zero_class N] (f : M â†’+ N) {x y : M} (h : x = y) : â‡‘f x = â‡‘f y
theorem convex_on_open_of_deriv2_nonneg {D : set â„} (hD : convex â„ D) (hDâ‚‚ : is_open D) {f : â„ â†’ â„} (hf' : differentiable_on â„ f D) (hf'' : differentiable_on â„ (deriv f) D) (hf''_nonneg : âˆ€ (x : â„), x âˆˆ D â†’ 0 â‰¤ deriv^[2] f x) : convex_on â„ D f
theorem exists_countable_dense_bot_top (Î± : Type u_1) [topological_space Î±] [topological_space.separable_space Î±] [partial_order Î±] : âˆƒ (s : set Î±), s.countable âˆ§ dense s âˆ§ (âˆ€ (x : Î±), is_bot x â†’ x âˆˆ s) âˆ§ âˆ€ (x : Î±), is_top x â†’ x âˆˆ s
theorem module.End.maximal_generalized_eigenspace_eq {R : Type v} {M : Type w} [comm_ring R] [add_comm_group M] [module R M] [h : is_noetherian R M] (f : module.End R M) (Î¼ : R) : f.maximal_generalized_eigenspace Î¼ = â‡‘(f.generalized_eigenspace Î¼) (f.maximal_generalized_eigenspace_index Î¼)
theorem strict_convex_on.translate_left {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [ordered_semiring ğ•œ] [add_cancel_comm_monoid E] [ordered_add_comm_monoid Î²] [module ğ•œ E] [has_scalar ğ•œ Î²] {s : set E} {f : E â†’ Î²} (hf : strict_convex_on ğ•œ s f) (c : E) : strict_convex_on ğ•œ ((Î» (z : E), c + z) â»Â¹' s) (f âˆ˜ Î» (z : E), z + c)
theorem orthonormal.oangle_map {V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) (x y : V) (f : V â‰ƒâ‚—áµ¢[â„] V) : _.oangle x y = hb.oangle (â‡‘(f.symm) x) (â‡‘(f.symm) y)
theorem Profinite.exists_locally_constant {J : Type u} [category_theory.small_category J] [category_theory.is_cofiltered J] {F : J â¥¤ Profinite} (C : category_theory.limits.cone F) (hC : category_theory.limits.is_limit C) {Î± : Type u_1} (f : locally_constant â†¥(C.X) Î±) : âˆƒ (j : J) (g : locally_constant â†¥(F.obj j) Î±), f = locally_constant.comap â‡‘(C.Ï€.app j) g
theorem triple_product_eq_det {R : Type u_1} [comm_ring R] (u v w : fin 3 â†’ R) : matrix.dot_product u (â‡‘(â‡‘cross_product v) w) = matrix.det ![u, v, w]
theorem function.periodic.tendsto_at_bot_interval_integral_of_pos {T : â„} {g : â„ â†’ â„} (hg : function.periodic g T) (h_int : âˆ€ (tâ‚ tâ‚‚ : â„), interval_integrable g measure_theory.measure_space.volume tâ‚ tâ‚‚) (hâ‚€ : 0 < âˆ« (x : â„) in 0..T, g x) (hT : 0 < T) : filter.tendsto (Î» (t : â„), âˆ« (x : â„) in 0..t, g x) filter.at_bot filter.at_bot
theorem inner_product_geometry.norm_add_sq_eq_norm_sq_add_norm_sq' {V : Type u_1} [inner_product_space â„ V] (x y : V) (h : inner_product_geometry.angle x y = real.pi / 2) : âˆ¥x + yâˆ¥ * âˆ¥x + yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + âˆ¥yâˆ¥ * âˆ¥yâˆ¥
theorem polynomial.X_pow_sub_one_eq_prod {R : Type u_1} [comm_ring R] [is_domain R] {Î¶ : R} {n : â„•} (hpos : 0 < n) (h : is_primitive_root Î¶ n) : polynomial.X ^ n - 1 = (polynomial.nth_roots_finset n R).prod (Î» (Î¶ : R), polynomial.X - â‡‘polynomial.C Î¶)
theorem continuous_linear_map.lipschitz_apply {ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_normed_group E] [semi_normed_group F] [nondiscrete_normed_field ğ•œ] [nondiscrete_normed_field ğ•œâ‚‚] [normed_space ğ•œ E] [normed_space ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} [ring_hom_isometric Ïƒâ‚â‚‚] (x : E) : lipschitz_with âˆ¥xâˆ¥â‚Š (Î» (f : E â†’SL[Ïƒâ‚â‚‚] F), â‡‘f x)
theorem dim_submodule_le_one_iff' {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] (s : submodule K V) : module.rank K â†¥s â‰¤ 1 â†” âˆƒ (vâ‚€ : V), s â‰¤ submodule.span K {vâ‚€}
theorem clifford_algebra.reverse_prod_map_Î¹ {R : Type u_1} [comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {Q : quadratic_form R M} (l : list M) : â‡‘clifford_algebra.reverse (list.map â‡‘(clifford_algebra.Î¹ Q) l).prod = (list.map â‡‘(clifford_algebra.Î¹ Q) l).reverse.prod
theorem euclidean_geometry.orthogonal_projection_vsub_mem_direction {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace â„ P} [nonempty â†¥s] [complete_space â†¥(s.direction)] {p1 : P} (p2 : P) (hp1 : p1 âˆˆ s) : â†‘(â‡‘(euclidean_geometry.orthogonal_projection s) p2 -áµ¥ âŸ¨p1, hp1âŸ©) âˆˆ s.direction
theorem eq_zero_of_zero_eq_one {Mâ‚€ : Type u_1} [mul_zero_one_class Mâ‚€] (h : 0 = 1) (a : Mâ‚€) : a = 0
theorem cont_diff_at.exists_lipschitz_on_with {ğ•‚ : Type u_6} [is_R_or_C ğ•‚] {E' : Type u_7} [normed_group E'] [normed_space ğ•‚ E'] {F' : Type u_8} [normed_group F'] [normed_space ğ•‚ F'] {f : E' â†’ F'} {x : E'} (hf : cont_diff_at ğ•‚ 1 f x) : âˆƒ (K : nnreal) (t : set E') (H : t âˆˆ nhds x), lipschitz_on_with K f t
theorem local_homeomorph.singleton_has_groupoid {H : Type u} [topological_space H] {Î± : Type u_5} [topological_space Î±] (e : local_homeomorph Î± H) (h : e.to_local_equiv.source = set.univ) (G : structure_groupoid H) [closed_under_restriction G] : has_groupoid Î± G
theorem mem_nhds_within_Iic_iff_exists_Ioc_subset' {Î± : Type u} [topological_space Î±] [linear_order Î±] [order_topology Î±] {a l' : Î±} {s : set Î±} (hl' : l' < a) : s âˆˆ nhds_within a (set.Iic a) â†” âˆƒ (l : Î±) (H : l âˆˆ set.Iio a), set.Ioc l a âŠ† s
theorem complex.tendsto_exp_comap_re_at_bot  : filter.tendsto complex.exp (filter.comap complex.re filter.at_bot) (nhds 0)
theorem exp_neg_inv_glue.f_aux_deriv (n : â„•) (x : â„) (hx : x â‰  0) : has_deriv_at (Î» (x : â„), polynomial.eval x (exp_neg_inv_glue.P_aux n) * real.exp (-xâ»Â¹) / x ^ (2 * n)) (polynomial.eval x (exp_neg_inv_glue.P_aux (n + 1)) * real.exp (-xâ»Â¹) / x ^ (2 * (n + 1))) x
theorem metric.closure_subset_thickening {Î± : Type u} [pseudo_emetric_space Î±] {Î´ : â„} (Î´_pos : 0 < Î´) (E : set Î±) : closure E âŠ† metric.thickening Î´ E
theorem norm_sub_sq_eq_norm_sq_add_norm_sq_real {F : Type u_3} [inner_product_space â„ F] {x y : F} (h : has_inner.inner x y = 0) : âˆ¥x - yâˆ¥ * âˆ¥x - yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + âˆ¥yâˆ¥ * âˆ¥yâˆ¥
theorem list.tail_sum (L : list â„•) : L.tail.sum = L.sum - L.head
theorem measure_theory.simple_func.induction {Î± : Type u_1} {Î³ : Type u_2} [measurable_space Î±] [add_monoid Î³] {P : measure_theory.simple_func Î± Î³ â†’ Prop} (h_ind : âˆ€ (c : Î³) {s : set Î±} (hs : measurable_set s), P (measure_theory.simple_func.piecewise s hs (measure_theory.simple_func.const Î± c) (measure_theory.simple_func.const Î± 0))) (h_add : âˆ€ â¦ƒf g : measure_theory.simple_func Î± Î³â¦„, disjoint (function.support â‡‘f) (function.support â‡‘g) â†’ P f â†’ P g â†’ P (f + g)) (f : measure_theory.simple_func Î± Î³) : P f
theorem finset.prod_congr_set {Î± : Type u_1} [comm_monoid Î±] {Î² : Type u_2} [fintype Î²] (s : set Î²) [decidable_pred (Î» (_x : Î²), _x âˆˆ s)] (f : Î² â†’ Î±) (g : â†¥s â†’ Î±) (w : âˆ€ (x : Î²) (h : x âˆˆ s), f x = g âŸ¨x, hâŸ©) (w' : âˆ€ (x : Î²), x âˆ‰ s â†’ f x = 1) : finset.univ.prod f = finset.univ.prod g
theorem cont_mdiff_at_iff_cont_mdiff_on_nhds {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {M : Type u_4} [topological_space M] [charted_space H M] [Is : smooth_manifold_with_corners I M] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners ğ•œ E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] [I's : smooth_manifold_with_corners I' M'] {f : M â†’ M'} {x : M} {n : â„•} : cont_mdiff_at I I' â†‘n f x â†” âˆƒ (u : set M) (H_1 : u âˆˆ nhds x), cont_mdiff_on I I' â†‘n f u
theorem set.image3_congr' {Î± : Type u_1} {Î² : Type u_3} {Î³ : Type u_5} {Î´ : Type u_7} {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s : set Î±} {t : set Î²} {u : set Î³} (h : âˆ€ (a : Î±) (b : Î²) (c : Î³), g a b c = g' a b c) : set.image3 g s t u = set.image3 g' s t u
theorem free_group.red.cons_nil_iff_singleton {Î± : Type u} {L : list (Î± Ã— bool)} {x : Î±} {b : bool} : free_group.red ((x, b) :: L) list.nil â†” free_group.red L [(x, !b)]
theorem local_homeomorph.continuous_at_symm {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] (e : local_homeomorph Î± Î²) {x : Î²} (h : x âˆˆ e.to_local_equiv.target) : continuous_at â‡‘(e.symm) x
theorem monotone.add {Î± : Type u_1} {Î² : Type u_2} [has_add Î±] [preorder Î±] [preorder Î²] {f g : Î² â†’ Î±} [covariant_class Î± Î± has_add.add has_le.le] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] (hf : monotone f) (hg : monotone g) : monotone (Î» (x : Î²), f x + g x)
theorem orthonormal.two_zsmul_oangle_smul_right_of_ne_zero {V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) (x y : V) {r : â„} (hr : r â‰  0) : 2 â€¢ hb.oangle x (r â€¢ y) = 2 â€¢ hb.oangle x y
theorem continuous.snd' {Î± : Type u} {Î² : Type v} {Î³ : Type u_1} [topological_space Î±] [topological_space Î²] [topological_space Î³] {f : Î² â†’ Î³} (hf : continuous f) : continuous (Î» (x : Î± Ã— Î²), f x.snd)
theorem is_compact.uniform_continuous_on_of_continuous' {Î± : Type u_1} {Î² : Type u_2} [uniform_space Î±] [uniform_space Î²] {s : set Î±} {f : Î± â†’ Î²} (hs : is_compact s) (hs' : is_separated s) (hf : continuous_on f s) : uniform_continuous_on f s
theorem Compactum_to_CompHaus.faithful  : category_theory.faithful Compactum_to_CompHaus
theorem open_segment_subset_ball_of_ne {E : Type u_2} [normed_group E] [normed_space â„ E] [strict_convex_space â„ E] {x y z : E} {r : â„} (hx : x âˆˆ metric.closed_ball z r) (hy : y âˆˆ metric.closed_ball z r) (hne : x â‰  y) : open_segment â„ x y âŠ† metric.ball z r
theorem simplex_category.mono_iff_injective {n m : simplex_category} {f : n âŸ¶ m} : category_theory.mono f â†” function.injective â‡‘(simplex_category.hom.to_order_hom f)
theorem probability_theory.indep_fun.integrable_mul {Î± : Type u_1} {mÎ± : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {Î² : Type u_2} [measurable_space Î²] {X Y : Î± â†’ Î²} [normed_division_ring Î²] [borel_space Î²] (hXY : probability_theory.indep_fun X Y Î¼) (hX : measure_theory.integrable X Î¼) (hY : measure_theory.integrable Y Î¼) : measure_theory.integrable (X * Y) Î¼
theorem measure_theory.signed_measure.of_symm_diff_compl_positive_negative {Î± : Type u_1} [measurable_space Î±] {s : measure_theory.signed_measure Î±} {i j : set Î±} (hi : measurable_set i) (hj : measurable_set j) (hi' : 0.restrict i â‰¤ measure_theory.vector_measure.restrict s i âˆ§ measure_theory.vector_measure.restrict s iá¶œ â‰¤ 0.restrict iá¶œ) (hj' : 0.restrict j â‰¤ measure_theory.vector_measure.restrict s j âˆ§ measure_theory.vector_measure.restrict s já¶œ â‰¤ 0.restrict já¶œ) : â‡‘s (i âˆ† j) = 0 âˆ§ â‡‘s (iá¶œ âˆ† já¶œ) = 0
theorem polynomial.erase_mem_lifts {R : Type u} [semiring R] {S : Type v} [semiring S] {f : R â†’+* S} {p : polynomial S} (n : â„•) (h : p âˆˆ polynomial.lifts f) : polynomial.erase n p âˆˆ polynomial.lifts f
theorem and_or_distrib_right {a b c : Prop} : a âˆ§ b âˆ¨ c â†” (a âˆ¨ c) âˆ§ (b âˆ¨ c)
theorem ring_hom.codomain_trivial_iff_range_trivial {Î± : Type u_2} {Î² : Type u_3} {rÎ± : non_assoc_semiring Î±} {rÎ² : non_assoc_semiring Î²} (f : Î± â†’+* Î²) : 0 = 1 â†” âˆ€ (x : Î±), â‡‘f x = 0
theorem cont_diff_on_top_iff_deriv_within {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {fâ‚‚ : ğ•œ â†’ F} {sâ‚‚ : set ğ•œ} (hs : unique_diff_on ğ•œ sâ‚‚) : cont_diff_on ğ•œ âŠ¤ fâ‚‚ sâ‚‚ â†” differentiable_on ğ•œ fâ‚‚ sâ‚‚ âˆ§ cont_diff_on ğ•œ âŠ¤ (deriv_within fâ‚‚ sâ‚‚) sâ‚‚
theorem finset.sum_erase {Î² : Type u} {Î± : Type v} [add_comm_monoid Î²] [decidable_eq Î±] (s : finset Î±) {f : Î± â†’ Î²} {a : Î±} (h : f a = 0) : (s.erase a).sum (Î» (x : Î±), f x) = s.sum (Î» (x : Î±), f x)
theorem torus_integrable.sub {n : â„•} {E : Type u_1} [normed_group E] {f g : (fin n â†’ â„‚) â†’ E} {c : fin n â†’ â„‚} {R : fin n â†’ â„} (hf : torus_integrable f c R) (hg : torus_integrable g c R) : torus_integrable (f - g) c R
theorem unitization.ind {R : Type u_1} {A : Type u_2} [add_zero_class R] [add_zero_class A] {P : unitization R A â†’ Prop} (h : âˆ€ (r : R) (a : A), P (unitization.inl r + â†‘a)) (x : unitization R A) : P x
theorem algebra.is_algebraic_of_larger_base_of_injective {R : Type u_3} {S : Type u_4} {A : Type u_5} [comm_ring R] [comm_ring S] [comm_ring A] [algebra R S] [algebra S A] [algebra R A] [is_scalar_tower R S A] (hinj : function.injective â‡‘(algebra_map R S)) (A_alg : algebra.is_algebraic R A) : algebra.is_algebraic S A
theorem is_localization.card {R : Type u} [comm_ring R] (S : submonoid R) (L : Type u) [comm_ring L] [algebra R L] [is_localization S L] (hS : S â‰¤ non_zero_divisors R) : cardinal.mk R = cardinal.mk L
theorem lebesgue_number_lemma_sUnion {Î± : Type u} [uniform_space Î±] {s : set Î±} {c : set (set Î±)} (hs : is_compact s) (hcâ‚ : âˆ€ (t : set Î±), t âˆˆ c â†’ is_open t) (hcâ‚‚ : s âŠ† â‹ƒâ‚€c) : âˆƒ (n : set (Î± Ã— Î±)) (H : n âˆˆ uniformity Î±), âˆ€ (x : Î±), x âˆˆ s â†’ (âˆƒ (t : set Î±) (H : t âˆˆ c), âˆ€ (y : Î±), (x, y) âˆˆ n â†’ y âˆˆ t)
theorem mul_le_of_le_inv_mul {Î± : Type u} [group Î±] [has_le Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a b c : Î±} : b â‰¤ aâ»Â¹ * c â†’ a * b â‰¤ c
theorem ideal.exists_nonzero_mem_of_ne_bot {R : Type u_1} [comm_ring R] {P : ideal (polynomial R)} (Pb : P â‰  âŠ¥) (hP : âˆ€ (x : R), â‡‘polynomial.C x âˆˆ P â†’ x = 0) : âˆƒ (p : polynomial R), p âˆˆ P âˆ§ polynomial.map (ideal.quotient.mk (ideal.comap polynomial.C P)) p â‰  0
theorem powers.self_mem {M : Type u_1} [monoid M] {x : M} : x âˆˆ powers x
theorem quadratic_form.equivalent_one_neg_one_weighted_sum_squared {M : Type u_1} [add_comm_group M] [module â„ M] [finite_dimensional â„ M] (Q : quadratic_form â„ M) (hQ : (â‡‘quadratic_form.associated Q).nondegenerate) : âˆƒ (w : fin (finite_dimensional.finrank â„ M) â†’ â„), (âˆ€ (i : fin (finite_dimensional.finrank â„ M)), w i = -1 âˆ¨ w i = 1) âˆ§ Q.equivalent (quadratic_form.weighted_sum_squares â„ w)
theorem matrix.det_fin_zero {R : Type v} [comm_ring R] {A : matrix (fin 0) (fin 0) R} : A.det = 1
theorem category_theory.finrank_endomorphism_eq_one {C : Type u_1} [category_theory.category C] [category_theory.preadditive C] (ğ•œ : Type u_3) [field ğ•œ] [is_alg_closed ğ•œ] [category_theory.linear ğ•œ C] {X : C} (is_iso_iff_nonzero : âˆ€ (f : X âŸ¶ X), category_theory.is_iso f â†” f â‰  0) [I : finite_dimensional ğ•œ (X âŸ¶ X)] : finite_dimensional.finrank ğ•œ (X âŸ¶ X) = 1
theorem category_theory.Ran_is_sheaf_of_cover_lifting {C D : Type u} [category_theory.category C] [category_theory.category D] {A : Type w} [category_theory.category A] [category_theory.limits.has_limits A] {J : category_theory.grothendieck_topology C} {K : category_theory.grothendieck_topology D} {G : C â¥¤ D} (hG : category_theory.cover_lifting J K G) (â„± : category_theory.Sheaf J A) : category_theory.presheaf.is_sheaf K ((category_theory.Ran G.op).obj â„±.val)
theorem roth_number_nat_is_O_id  : (Î» (N : â„•), â†‘(â‡‘roth_number_nat N)) =O[filter.at_top] Î» (N : â„•), â†‘N
theorem modular_group.exists_smul_mem_fd (z : upper_half_plane) : âˆƒ (g : matrix.special_linear_group (fin 2) â„¤), g â€¢ z âˆˆ modular_group.fd
theorem interval_integral.integral_has_deriv_within_at_of_tendsto_ae_right {E : Type u_3} [normed_group E] [complete_space E] [normed_space â„ E] {f : â„ â†’ E} {c : E} {a b : â„} (hf : interval_integrable f measure_theory.measure_space.volume a b) {s t : set â„} [interval_integral.FTC_filter b (nhds_within b s) (nhds_within b t)] (hmeas : strongly_measurable_at_filter f (nhds_within b t) measure_theory.measure_space.volume) (hb : filter.tendsto f (nhds_within b t âŠ“ measure_theory.measure_space.volume.ae) (nhds c)) : has_deriv_within_at (Î» (u : â„), âˆ« (x : â„) in a..u, f x) c s b
theorem sum_hom_units_eq_zero {R : Type u_1} {G : Type u_2} [comm_ring R] [is_domain R] [group G] [fintype G] (f : G â†’* R) (hf : f â‰  1) : finset.univ.sum (Î» (g : G), â‡‘f g) = 0
theorem continuous.strongly_measurable {Î± : Type u_1} [measurable_space Î±] [topological_space Î±] [opens_measurable_space Î±] {Î² : Type u_2} [topological_space Î²] [topological_space.pseudo_metrizable_space Î²] [h : second_countable_topology_either Î± Î²] {f : Î± â†’ Î²} (hf : continuous f) : measure_theory.strongly_measurable f
theorem left.mul_lt_one_of_le_of_lt {Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a b : Î±} (ha : a â‰¤ 1) (hb : b < 1) : a * b < 1
theorem factorization_pow {Î± : Type u_1} [cancel_comm_monoid_with_zero Î±] [unique_factorization_monoid Î±] [normalization_monoid Î±] [decidable_eq Î±] {x : Î±} {n : â„•} : factorization (x ^ n) = n â€¢ factorization x
theorem ereal.neg_le {a b : ereal} : -a â‰¤ b â†” -b â‰¤ a
theorem list.perm.prod_eq' {Î± : Type uu} [monoid Î±] {lâ‚ lâ‚‚ : list Î±} (h : lâ‚ ~ lâ‚‚) (hc : list.pairwise (Î» (x y : Î±), x * y = y * x) lâ‚) : lâ‚.prod = lâ‚‚.prod
theorem linear_equiv.dim_map_eq {R : Type u} [ring R] {M : Type v} [add_comm_group M] [module R M] {Mâ‚ : Type v} [add_comm_group Mâ‚] [module R Mâ‚] (f : M â‰ƒâ‚—[R] Mâ‚) (p : submodule R M) : module.rank R â†¥(submodule.map â†‘f p) = module.rank R â†¥p
theorem box_integral.has_integral_of_bRiemann_eq_ff_of_forall_is_o {Î¹ : Type u} {E : Type v} {F : Type w} [normed_group E] [normed_space â„ E] [normed_group F] [normed_space â„ F] {I : box_integral.box Î¹} [fintype Î¹] {l : box_integral.integration_params} {f : (Î¹ â†’ â„) â†’ E} {vol : box_integral.box_additive_map Î¹ (E â†’L[â„] F) âŠ¤} (hl : l.bRiemann = bool.ff) (B : box_integral.box_additive_map Î¹ â„ â†‘I) (hB0 : âˆ€ (J : box_integral.box Î¹), 0 â‰¤ â‡‘B J) (g : box_integral.box_additive_map Î¹ F â†‘I) (s : set (Î¹ â†’ â„)) (hs : s.countable) (hlH : s.nonempty â†’ l.bHenstock = bool.tt) (Hâ‚ : âˆ€ (c : nnreal) (x : Î¹ â†’ â„), x âˆˆ â‡‘box_integral.box.Icc I âˆ© s â†’ âˆ€ (Îµ : â„), Îµ > 0 â†’ (âˆƒ (Î´ : â„) (H : Î´ > 0), âˆ€ (J : box_integral.box Î¹), J â‰¤ I â†’ â‡‘box_integral.box.Icc J âŠ† metric.closed_ball x Î´ â†’ x âˆˆ â‡‘box_integral.box.Icc J â†’ (â†¥(l.bDistortion) â†’ J.distortion â‰¤ c) â†’ has_dist.dist (â‡‘(â‡‘vol J) (f x)) (â‡‘g J) â‰¤ Îµ)) (Hâ‚‚ : âˆ€ (c : nnreal) (x : Î¹ â†’ â„), x âˆˆ â‡‘box_integral.box.Icc I  s â†’ âˆ€ (Îµ : â„), Îµ > 0 â†’ (âˆƒ (Î´ : â„) (H : Î´ > 0), âˆ€ (J : box_integral.box Î¹), J â‰¤ I â†’ â‡‘box_integral.box.Icc J âŠ† metric.closed_ball x Î´ â†’ (â†¥(l.bHenstock) â†’ x âˆˆ â‡‘box_integral.box.Icc J) â†’ (â†¥(l.bDistortion) â†’ J.distortion â‰¤ c) â†’ has_dist.dist (â‡‘(â‡‘vol J) (f x)) (â‡‘g J) â‰¤ Îµ * â‡‘B J)) : box_integral.has_integral I l f vol (â‡‘g I)
theorem ratfunc.induction_on {K : Type u} [hring : comm_ring K] [hdomain : is_domain K] {P : ratfunc K â†’ Prop} (x : ratfunc K) (f : âˆ€ (p q : polynomial K), q â‰  0 â†’ P (â‡‘(algebra_map (polynomial K) (ratfunc K)) p / â‡‘(algebra_map (polynomial K) (ratfunc K)) q)) : P x
theorem compact_covered_by_mul_left_translates {G : Type w} [topological_space G] [group G] [topological_group G] {K V : set G} (hK : is_compact K) (hV : (interior V).nonempty) : âˆƒ (t : finset G), K âŠ† â‹ƒ (g : G) (H : g âˆˆ t), (Î» (h : G), g * h) â»Â¹' V
theorem nonempty_omega_limit_of_is_compact_absorbing {Ï„ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [topological_space Î²] (f : filter Ï„) (Ï• : Ï„ â†’ Î± â†’ Î²) (s : set Î±) [f.ne_bot] {c : set Î²} (hcâ‚ : is_compact c) (hcâ‚‚ : âˆƒ (v : set Ï„) (H : v âˆˆ f), closure (set.image2 Ï• v s) âŠ† c) (hs : s.nonempty) : (omega_limit f Ï• s).nonempty
theorem lipschitz_with.list_prod {Î± : Type u} {Î¹ : Type x} [pseudo_emetric_space Î±] (f : Î¹ â†’ function.End Î±) (K : Î¹ â†’ nnreal) (h : âˆ€ (i : Î¹), lipschitz_with (K i) (f i)) (l : list Î¹) : lipschitz_with (list.map K l).prod (list.map f l).prod
theorem finsupp.is_pwo {Î± : Type u_1} {Ïƒ : Type u_2} [has_zero Î±] [linear_order Î±] [is_well_order Î± has_lt.lt] [fintype Ïƒ] (S : set (Ïƒ â†’â‚€ Î±)) : S.is_pwo
theorem add_units.is_add_unit_add_add_units {M : Type u_1} [add_monoid M] (a : M) (u : add_units M) : is_add_unit (a + â†‘u) â†” is_add_unit a
theorem complete_lattice.is_compact_element.directed_Sup_lt_of_lt {Î± : Type u_1} [complete_lattice Î±] {k : Î±} (hk : complete_lattice.is_compact_element k) {s : set Î±} (hemp : s.nonempty) (hdir : directed_on has_le.le s) (hbelow : âˆ€ (x : Î±), x âˆˆ s â†’ x < k) : has_Sup.Sup s < k
theorem category_theory.concrete_category.hom_ext {C : Type v} [category_theory.category C] [category_theory.concrete_category C] {X Y : C} (f g : X âŸ¶ Y) (w : âˆ€ (x : â†¥X), â‡‘f x = â‡‘g x) : f = g
theorem set.sum_indicator_subset {Î± : Type u_1} {M : Type u_4} [add_comm_monoid M] (f : Î± â†’ M) {s t : finset Î±} (h : s âŠ† t) : s.sum (Î» (i : Î±), f i) = t.sum (Î» (i : Î±), â†‘s.indicator f i)
theorem finset.weighted_vsub_of_point_erase {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {Î¹ : Type u_4} (s : finset Î¹) (w : Î¹ â†’ k) (p : Î¹ â†’ P) (i : Î¹) : â‡‘((s.erase i).weighted_vsub_of_point p (p i)) w = â‡‘(s.weighted_vsub_of_point p (p i)) w
theorem inner_product_geometry.angle_comm {V : Type u_1} [inner_product_space â„ V] (x y : V) : inner_product_geometry.angle x y = inner_product_geometry.angle y x
theorem setoid.map_of_surjective_eq_map {Î± : Type u_1} {Î² : Type u_2} {r : setoid Î±} {f : Î± â†’ Î²} (h : setoid.ker f â‰¤ r) (hf : function.surjective f) : r.map f = r.map_of_surjective f h hf
theorem is_primitive_root.sub_one_norm_prime {p : â„•+} {K : Type u} {L : Type v} [field L] {Î¶ : L} [field K] [algebra K L] [ne_zero â†‘â†‘p] [hpri : fact (nat.prime â†‘p)] [hcyc : is_cyclotomic_extension {p} K L] (hÎ¶ : is_primitive_root Î¶ â†‘p) (hirr : irreducible (polynomial.cyclotomic â†‘p K)) (h : p â‰  2) : â‡‘(algebra.norm K) (Î¶ - 1) = â†‘p
theorem cardinal.cantor (a : cardinal) : a < 2 ^ a
theorem measure_theory.measure.mk_metric_le_liminf_tsum {X : Type u_2} [emetric_space X] [measurable_space X] [borel_space X] {Î² : Type u_1} {Î¹ : Î² â†’ Type u_3} [Î  (n : Î²), encodable (Î¹ n)] (s : set X) {l : filter Î²} (r : Î² â†’ ennreal) (hr : filter.tendsto r l (nhds 0)) (t : Î  (n : Î²), Î¹ n â†’ set X) (ht : âˆ€á¶  (n : Î²) in l, âˆ€ (i : Î¹ n), emetric.diam (t n i) â‰¤ r n) (hst : âˆ€á¶  (n : Î²) in l, s âŠ† â‹ƒ (i : Î¹ n), t n i) (m : ennreal â†’ ennreal) : â‡‘(measure_theory.measure.mk_metric m) s â‰¤ l.liminf (Î» (n : Î²), âˆ‘' (i : Î¹ n), m (emetric.diam (t n i)))
theorem modular_group.c_eq_zero {g : matrix.special_linear_group (fin 2) â„¤} {z : upper_half_plane} (hz : z âˆˆ modular_group.fdo) (hg : g â€¢ z âˆˆ modular_group.fdo) : â†‘g 1 0 = 0
theorem inner_product_space.is_self_adjoint.has_eigenvector_of_is_max_on {ğ•œ : Type u_1} [is_R_or_C ğ•œ] {E : Type u_2} [inner_product_space ğ•œ E] [complete_space E] {T : E â†’L[ğ•œ] E} (hT : inner_product_space.is_self_adjoint â†‘T) {xâ‚€ : E} (hxâ‚€ : xâ‚€ â‰  0) (hextr : is_max_on T.re_apply_inner_self (metric.sphere 0 âˆ¥xâ‚€âˆ¥) xâ‚€) : module.End.has_eigenvector â†‘T (â†‘â¨† (x : {x // x â‰  0}), (Î» (x : E), T.re_apply_inner_self x / âˆ¥xâˆ¥ ^ 2) â†‘x) xâ‚€
theorem is_of_fin_add_order.apply {Î· : Type u_1} {Gs : Î· â†’ Type u_2} [Î  (i : Î·), add_monoid (Gs i)] {x : Î  (i : Î·), Gs i} (h : is_of_fin_add_order x) (i : Î·) : is_of_fin_add_order (x i)
theorem affine_independent.map' {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {Î¹ : Type u_4} {Vâ‚‚ : Type u_5} {Pâ‚‚ : Type u_6} [add_comm_group Vâ‚‚] [module k Vâ‚‚] [add_torsor Vâ‚‚ Pâ‚‚] {p : Î¹ â†’ P} (hai : affine_independent k p) (f : P â†’áµƒ[k] Pâ‚‚) (hf : function.injective â‡‘f) : affine_independent k (â‡‘f âˆ˜ p)
theorem dot_cross_self {R : Type u_1} [comm_ring R] (v w : fin 3 â†’ R) : matrix.dot_product w (â‡‘(â‡‘cross_product v) w) = 0
theorem add_con.lift_on_coe {M : Type u_1} [has_add M] {Î² : Sort u_2} (c : add_con M) (f : M â†’ Î²) (h : âˆ€ (a b : M), â‡‘c a b â†’ f a = f b) (x : M) : add_con.lift_on â†‘x f h = f x
theorem is_compact.bdd_above_image {Î± : Type u} {Î² : Type v} [topological_space Î±] [linear_order Î±] [order_closed_topology Î±] [nonempty Î±] [topological_space Î²] {f : Î² â†’ Î±} {K : set Î²} (hK : is_compact K) (hf : continuous_on f K) : bdd_above (f '' K)
theorem strict_convex_on_exp  : strict_convex_on â„ set.univ real.exp
theorem continuous_map.mem_compact_convergence_uniformity {Î± : Type uâ‚} {Î² : Type uâ‚‚} [topological_space Î±] [uniform_space Î²] (X : set (C(Î±, Î²) Ã— C(Î±, Î²))) : X âˆˆ continuous_map.compact_convergence_uniformity â†” âˆƒ (K : set Î±) (V : set (Î² Ã— Î²)) (hK : is_compact K) (hV : V âˆˆ uniformity Î²), {fg : C(Î±, Î²) Ã— C(Î±, Î²) | âˆ€ (x : Î±), x âˆˆ K â†’ (â‡‘(fg.fst) x, â‡‘(fg.snd) x) âˆˆ V} âŠ† X
theorem submodule.orthogonal_orthogonal_monotone {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {Kâ‚ Kâ‚‚ : submodule ğ•œ E} (h : Kâ‚ â‰¤ Kâ‚‚) : Kâ‚á—®á—® â‰¤ Kâ‚‚á—®á—®
theorem filter.tendsto_at_top_at_top_of_monotone' {Î¹ : Type u_1} {Î± : Type u_3} [preorder Î¹] [linear_order Î±] {u : Î¹ â†’ Î±} (h : monotone u) (H : Â¬bdd_above (set.range u)) : filter.tendsto u filter.at_top filter.at_top
theorem card_sylow_modeq_one (p : â„•) (G : Type u_1) [group G] [fact (nat.prime p)] [fintype (sylow p G)] : fintype.card (sylow p G) â‰¡ 1 [MOD p]
theorem con.mul {M : Type u_1} [has_mul M] (c : con M) {w x y z : M} : â‡‘c w x â†’ â‡‘c y z â†’ â‡‘c (w * y) (x * z)
theorem affine_subspace.direction_inf_of_mem {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {sâ‚ sâ‚‚ : affine_subspace k P} {p : P} (hâ‚ : p âˆˆ sâ‚) (hâ‚‚ : p âˆˆ sâ‚‚) : (sâ‚ âŠ“ sâ‚‚).direction = sâ‚.direction âŠ“ sâ‚‚.direction
theorem sub_left_lt_of_lt_add {Î± : Type u} [add_comm_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b c : Î±} : a < b + c â†’ a - b < c
theorem multiset.count_map_eq_count {Î± : Type u_1} {Î² : Type u_2} [decidable_eq Î±] [decidable_eq Î²] (f : Î± â†’ Î²) (s : multiset Î±) (hf : set.inj_on f {x : Î± | x âˆˆ s}) (x : Î±) (H : x âˆˆ s) : multiset.count (f x) (multiset.map f s) = multiset.count x s
theorem category_theory.triangulated.pretriangulated.inv_rot_of_dist_triangle (C : Type u) [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.has_shift C â„¤] [category_theory.preadditive C] [âˆ€ (n : â„¤), (category_theory.shift_functor C n).additive] [category_theory.triangulated.pretriangulated C] (T : category_theory.triangulated.triangle C) (H : T âˆˆ dist_triang C) : T.inv_rotate âˆˆ dist_triang C
theorem cont_mdiff.comp {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners ğ•œ E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] {f : M â†’ M'} {n : with_top â„•} {E'' : Type u_14} [normed_group E''] [normed_space ğ•œ E''] {H'' : Type u_15} [topological_space H''] {I'' : model_with_corners ğ•œ E'' H''} {M'' : Type u_16} [topological_space M''] [charted_space H'' M''] {g : M' â†’ M''} (hg : cont_mdiff I' I'' n g) (hf : cont_mdiff I I' n f) : cont_mdiff I I'' n (g âˆ˜ f)
theorem complex.linear_equiv_det_conj_lie  : â‡‘linear_equiv.det complex.conj_lie.to_linear_equiv = -1
theorem category_theory.limits.has_pullback_symmetry {C : Type u} [category_theory.category C] {X Y Z : C} (f : X âŸ¶ Z) (g : Y âŸ¶ Z) [category_theory.limits.has_pullback f g] : category_theory.limits.has_pullback g f
theorem orientation.rotation_eq_self_iff_angle_eq_zero {V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) {x : V} (hx : x â‰  0) (Î¸ : real.angle) : â‡‘(o.rotation Î¸) x = x â†” Î¸ = 0
theorem padic_val_int.of_nat {p n : â„•} : padic_val_int p â†‘n = padic_val_nat p n
theorem linear_equiv.lift_dim_eq {R : Type u} [ring R] {M : Type v} [add_comm_group M] [module R M] {M' : Type v'} [add_comm_group M'] [module R M'] (f : M â‰ƒâ‚—[R] M') : (module.rank R M).lift = (module.rank R M').lift
theorem category_theory.is_filtered.bowtie {C : Type u} [category_theory.category C] [category_theory.is_filtered C] {jâ‚ jâ‚‚ kâ‚ kâ‚‚ : C} (fâ‚ : jâ‚ âŸ¶ kâ‚) (gâ‚ : jâ‚ âŸ¶ kâ‚‚) (fâ‚‚ : jâ‚‚ âŸ¶ kâ‚) (gâ‚‚ : jâ‚‚ âŸ¶ kâ‚‚) : âˆƒ (s : C) (Î± : kâ‚ âŸ¶ s) (Î² : kâ‚‚ âŸ¶ s), fâ‚ â‰« Î± = gâ‚ â‰« Î² âˆ§ fâ‚‚ â‰« Î± = gâ‚‚ â‰« Î²
theorem inv_le_inv {Î± : Type u_1} [linear_ordered_field Î±] {a b : Î±} (ha : 0 < a) (hb : 0 < b) : aâ»Â¹ â‰¤ bâ»Â¹ â†” b â‰¤ a
theorem category_theory.Groupoid.id_to_functor {C : category_theory.Groupoid} : ğŸ­ â†¥C = ğŸ™ C
theorem power_series.order_mul_ge {R : Type u_1} [semiring R] (Ï† Ïˆ : power_series R) : Ï†.order + Ïˆ.order â‰¤ (Ï† * Ïˆ).order
theorem is_dedekind_domain.height_one_spectrum.int_valuation_zero_le {R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] (v : is_dedekind_domain.height_one_spectrum R) (x : â†¥(non_zero_divisors R)) : 0 < v.int_valuation_def â†‘x
theorem submonoid.bot_or_exists_ne_one {M : Type u_1} [mul_one_class M] (S : submonoid M) : S = âŠ¥ âˆ¨ âˆƒ (x : M) (H : x âˆˆ S), x â‰  1
theorem exists_ne_one_of_finprod_mem_ne_one {Î± : Type u_1} {M : Type u_5} [comm_monoid M] {f : Î± â†’ M} {s : set Î±} (h : finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), f i)) â‰  1) : âˆƒ (x : Î±) (H : x âˆˆ s), f x â‰  1
theorem indexed_partition.proj_out {Î¹ : Type u_1} {Î± : Type u_2} {s : Î¹ â†’ set Î±} (hs : indexed_partition s) (x : hs.quotient) : hs.proj (â‡‘(hs.out) x) = x
theorem inv.is_group_hom {Î± : Type u} [comm_group Î±] : is_group_hom has_inv.inv
theorem totally_bounded.closure {Î± : Type u} [uniform_space Î±] {s : set Î±} (h : totally_bounded s) : totally_bounded (closure s)
theorem tendsto_rpow_neg_div  : filter.tendsto (Î» (x : â„), x ^ ((-1) / x)) filter.at_top (nhds 1)
theorem measure_theory.set_integral_condexp_L1 {Î± : Type u_1} {F' : Type u_7} [normed_group F'] [normed_space â„ F'] [complete_space F'] {m m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {hm : m â‰¤ m0} [measure_theory.sigma_finite (Î¼.trim hm)] {f : Î± â†’ F'} {s : set Î±} (hf : measure_theory.integrable f Î¼) (hs : measurable_set s) : âˆ« (x : Î±) in s, â‡‘(measure_theory.condexp_L1 hm Î¼ f) x âˆ‚Î¼ = âˆ« (x : Î±) in s, f x âˆ‚Î¼
theorem bounded_continuous_function.exists_extension_forall_exists_le_ge_of_closed_embedding {X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] [normal_space Y] [nonempty X] (f : bounded_continuous_function X â„) {e : X â†’ Y} (he : closed_embedding e) : âˆƒ (g : bounded_continuous_function Y â„), (âˆ€ (y : Y), âˆƒ (xâ‚ xâ‚‚ : X), â‡‘g y âˆˆ set.Icc (â‡‘f xâ‚) (â‡‘f xâ‚‚)) âˆ§ â‡‘g âˆ˜ e = â‡‘f
theorem real.Gamma_integrand_is_o (s : â„) : (Î» (x : â„), real.exp (-x) * x ^ s) =o[filter.at_top] Î» (x : â„), real.exp (-(1 / 2) * x)
theorem simple_graph.is_SRG_with.compl {V : Type u} [fintype V] [decidable_eq V] {G : simple_graph V} [decidable_rel G.adj] {n k â„“ Î¼ : â„•} (h : G.is_SRG_with n k â„“ Î¼) : Gá¶œ.is_SRG_with n (n - k - 1) (n - (2 * k - Î¼) - 2) (n - (2 * k - â„“))
theorem is_closed_set_of_cluster_pt {Î± : Type u} [topological_space Î±] {f : filter Î±} : is_closed {x : Î± | cluster_pt x f}
theorem has_le.le.not_lt {Î± : Type u} [preorder Î±] {a b : Î±} (h : a â‰¤ b) : Â¬b < a
theorem monotone.tendsto_alternating_series_of_tendsto_zero {f : â„• â†’ â„} (hfa : monotone f) (hf0 : filter.tendsto f filter.at_top (nhds 0)) : âˆƒ (l : â„), filter.tendsto (Î» (n : â„•), (finset.range (n + 1)).sum (Î» (i : â„•), (-1) ^ i * f i)) filter.at_top (nhds l)
theorem finset.sum_insert_zero {Î² : Type u} {Î± : Type v} {s : finset Î±} {a : Î±} {f : Î± â†’ Î²} [add_comm_monoid Î²] [decidable_eq Î±] (h : f a = 0) : (has_insert.insert a s).sum (Î» (x : Î±), f x) = s.sum (Î» (x : Î±), f x)
theorem is_glb.of_subset_of_superset {Î± : Type u} [preorder Î±] {a : Î±} {s t p : set Î±} (hs : is_glb s a) (hp : is_glb p a) (hst : s âŠ† t) (htp : t âŠ† p) : is_glb t a
theorem measurable_liminf {Î± : Type u_1} {Î´ : Type u_5} [topological_space Î±] [measurable_space Î±] [borel_space Î±] [measurable_space Î´] [complete_linear_order Î±] [order_topology Î±] [topological_space.second_countable_topology Î±] {f : â„• â†’ Î´ â†’ Î±} (hf : âˆ€ (i : â„•), measurable (f i)) : measurable (Î» (x : Î´), filter.at_top.liminf (Î» (i : â„•), f i x))
theorem exists_strongly_measurable_limit_of_tendsto_ae {Î± : Type u_1} {Î² : Type u_2} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [topological_space Î²] [topological_space.pseudo_metrizable_space Î²] {f : â„• â†’ Î± â†’ Î²} (hf : âˆ€ (n : â„•), measure_theory.ae_strongly_measurable (f n) Î¼) (h_ae_tendsto : âˆ€áµ (x : Î±) âˆ‚Î¼, âˆƒ (l : Î²), filter.tendsto (Î» (n : â„•), f n x) filter.at_top (nhds l)) : âˆƒ (f_lim : Î± â†’ Î²) (hf_lim_meas : measure_theory.strongly_measurable f_lim), âˆ€áµ (x : Î±) âˆ‚Î¼, filter.tendsto (Î» (n : â„•), f n x) filter.at_top (nhds (f_lim x))
theorem function.is_fixed_pt.comp {Î± : Type u} {f g : Î± â†’ Î±} {x : Î±} (hf : function.is_fixed_pt f x) (hg : function.is_fixed_pt g x) : function.is_fixed_pt (f âˆ˜ g) x
theorem nat.base_pow_length_digits_le (b m : â„•) (hb : 2 â‰¤ b) : m â‰  0 â†’ b ^ (b.digits m).length â‰¤ b * m
theorem convex.norm_image_sub_le_of_norm_fderiv_le {E : Type u_1} [normed_group E] [normed_space â„ E] {ğ•œ : Type u_3} {G : Type u_4} [is_R_or_C ğ•œ] [normed_space ğ•œ E] [normed_group G] [normed_space ğ•œ G] {f : E â†’ G} {C : â„} {s : set E} {x y : E} (hf : âˆ€ (x : E), x âˆˆ s â†’ differentiable_at ğ•œ f x) (bound : âˆ€ (x : E), x âˆˆ s â†’ âˆ¥fderiv ğ•œ f xâˆ¥ â‰¤ C) (hs : convex â„ s) (xs : x âˆˆ s) (ys : y âˆˆ s) : âˆ¥f y - f xâˆ¥ â‰¤ C * âˆ¥y - xâˆ¥
theorem is_local_extr.deriv_eq_zero {f : â„ â†’ â„} {a : â„} (h : is_local_extr f a) : deriv f a = 0
theorem commutative_of_cyclic_center_quotient {G : Type u_1} {H : Type u_2} [group G] [group H] [is_cyclic H] (f : G â†’* H) (hf : f.ker â‰¤ subgroup.center G) (a b : G) : a * b = b * a
theorem measure_theory.measure.measure_inter_eq_of_measure_eq {Î± : Type u_1} {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {s t u : set Î±} (hs : measurable_set s) (h : â‡‘Î¼ t = â‡‘Î¼ u) (htu : t âŠ† u) (ht_ne_top : â‡‘Î¼ t â‰  âŠ¤) : â‡‘Î¼ (t âˆ© s) = â‡‘Î¼ (u âˆ© s)
theorem metric.thickening_subset_of_subset {Î± : Type u} [pseudo_emetric_space Î±] (Î´ : â„) {Eâ‚ Eâ‚‚ : set Î±} (h : Eâ‚ âŠ† Eâ‚‚) : metric.thickening Î´ Eâ‚ âŠ† metric.thickening Î´ Eâ‚‚
theorem lie_module.is_nilpotent_iff_forall {R : Type uâ‚} {L : Type uâ‚‚} {M : Type uâ‚„} [comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] [is_noetherian R L] : lie_module.is_nilpotent R L M â†” âˆ€ (x : L), is_nilpotent (â‡‘(lie_module.to_endomorphism R L M) x)
theorem precise_refinement {Î¹ : Type u} {X : Type v} [topological_space X] [paracompact_space X] (u : Î¹ â†’ set X) (uo : âˆ€ (a : Î¹), is_open (u a)) (uc : (â‹ƒ (i : Î¹), u i) = set.univ) : âˆƒ (v : Î¹ â†’ set X), (âˆ€ (a : Î¹), is_open (v a)) âˆ§ (â‹ƒ (i : Î¹), v i) = set.univ âˆ§ locally_finite v âˆ§ âˆ€ (a : Î¹), v a âŠ† u a
theorem measure_theory.finite_measure.tendsto_test_against_nn_filter_of_le_const {Î± : Type u_1} [measurable_space Î±] [topological_space Î±] [opens_measurable_space Î±] {Î¹ : Type u_2} {L : filter Î¹} [L.is_countably_generated] {Î¼ : measure_theory.finite_measure Î±} {fs : Î¹ â†’ bounded_continuous_function Î± nnreal} {c : nnreal} (fs_le_const : âˆ€á¶  (i : Î¹) in L, âˆ€áµ (a : Î±) âˆ‚â†‘Î¼, â‡‘(fs i) a â‰¤ c) {f : bounded_continuous_function Î± nnreal} (fs_lim : âˆ€áµ (a : Î±) âˆ‚â†‘Î¼, filter.tendsto (Î» (i : Î¹), â‡‘(fs i) a) L (nhds (â‡‘f a))) : filter.tendsto (Î» (i : Î¹), Î¼.test_against_nn (fs i)) L (nhds (Î¼.test_against_nn f))
theorem bernstein_polynomial.linear_independent (n : â„•) : linear_independent â„š (Î» (Î½ : fin (n + 1)), bernstein_polynomial â„š n â†‘Î½)
theorem is_add_submonoid.Inter {M : Type u_1} [add_monoid M] {Î¹ : Sort u_2} {s : Î¹ â†’ set M} (h : âˆ€ (y : Î¹), is_add_submonoid (s y)) : is_add_submonoid (set.Inter s)
theorem measure_theory.measure.ext_of_Ici {Î± : Type u_1} [topological_space Î±] {m : measurable_space Î±} [topological_space.second_countable_topology Î±] [linear_order Î±] [order_topology Î±] [borel_space Î±] (Î¼ Î½ : measure_theory.measure Î±) [measure_theory.is_finite_measure Î¼] (h : âˆ€ (a : Î±), â‡‘Î¼ (set.Ici a) = â‡‘Î½ (set.Ici a)) : Î¼ = Î½
theorem Inf_sup_le_infi_sup {Î± : Type u_1} [complete_lattice Î±] {a : Î±} {s : set Î±} : has_Inf.Inf s âŠ” a â‰¤ â¨… (b : Î±) (H : b âˆˆ s), b âŠ” a
theorem one_hom.ext_iff {M : Type u_3} {N : Type u_4} [has_one M] [has_one N] {f g : one_hom M N} : f = g â†” âˆ€ (x : M), â‡‘f x = â‡‘g x
theorem euclidean_geometry.dist_reflection {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] (s : affine_subspace â„ P) [nonempty â†¥s] [complete_space â†¥(s.direction)] (pâ‚ pâ‚‚ : P) : has_dist.dist pâ‚ (â‡‘(euclidean_geometry.reflection s) pâ‚‚) = has_dist.dist (â‡‘(euclidean_geometry.reflection s) pâ‚) pâ‚‚
theorem complete_lattice.independent.comp {Î¹ : Sort u_1} {Î¹' : Sort u_2} {Î± : Type u_3} [complete_lattice Î±] {s : Î¹ â†’ Î±} (hs : complete_lattice.independent s) (f : Î¹' â†’ Î¹) (hf : function.injective f) : complete_lattice.independent (s âˆ˜ f)
theorem concave_on.exists_le_of_mem_convex_hull {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [linear_ordered_field ğ•œ] [add_comm_group E] [linear_ordered_add_comm_group Î²] [module ğ•œ E] [module ğ•œ Î²] [ordered_smul ğ•œ Î²] {s : set E} {f : E â†’ Î²} (hf : concave_on ğ•œ (â‡‘(convex_hull ğ•œ) s) f) {x : E} (hx : x âˆˆ â‡‘(convex_hull ğ•œ) s) : âˆƒ (y : E) (H : y âˆˆ s), f y â‰¤ f x
theorem cardinal.ord_card_unbounded  : set.unbounded has_lt.lt {b : ordinal | b.card.ord = b}
theorem filter.tendsto.at_top_mul_neg_const' {Î± : Type u_1} {R : Type u_2} {l : filter Î±} {f : Î± â†’ R} {r : R} [linear_ordered_ring R] [archimedean R] (hr : r < 0) (hf : filter.tendsto f l filter.at_top) : filter.tendsto (Î» (x : Î±), f x * r) l filter.at_bot
theorem monoid_with_zero_hom.coe_inj {M : Type u_3} {N : Type u_4} [mul_zero_one_class M] [mul_zero_one_class N] â¦ƒf g : M â†’*â‚€ Nâ¦„ (h : â‡‘f = â‡‘g) : f = g
theorem modular_group.im_lt_im_S_smul {z : upper_half_plane} (h : â‡‘complex.norm_sq â†‘z < 1) : z.im < (modular_group.S â€¢ z).im
theorem convex_independent.comp_embedding {ğ•œ : Type u_1} {E : Type u_2} {Î¹ : Type u_3} [ordered_semiring ğ•œ] [add_comm_group E] [module ğ•œ E] {Î¹' : Type u_4} (f : Î¹' â†ª Î¹) {p : Î¹ â†’ E} (hc : convex_independent ğ•œ p) : convex_independent ğ•œ (p âˆ˜ â‡‘f)
theorem finset.sum_Ico_by_parts {R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] (f : â„• â†’ R) (g : â„• â†’ M) {m n : â„•} (hmn : m < n) : (finset.Ico m n).sum (Î» (i : â„•), f i â€¢ g i) = f (n - 1) â€¢ (finset.range n).sum (Î» (i : â„•), g i) - f m â€¢ (finset.range m).sum (Î» (i : â„•), g i) - (finset.Ico m (n - 1)).sum (Î» (i : â„•), (f (i + 1) - f i) â€¢ (finset.range (i + 1)).sum (Î» (i : â„•), g i))
theorem geometric_hahn_banach_compact_closed {E : Type u_2} [normed_group E] [normed_space â„ E] {s t : set E} (hsâ‚ : convex â„ s) (hsâ‚‚ : is_compact s) (htâ‚ : convex â„ t) (htâ‚‚ : is_closed t) (disj : disjoint s t) : âˆƒ (f : E â†’L[â„] â„) (u v : â„), (âˆ€ (a : E), a âˆˆ s â†’ â‡‘f a < u) âˆ§ u < v âˆ§ âˆ€ (b : E), b âˆˆ t â†’ v < â‡‘f b
theorem right.inv_lt_one_iff {Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± (function.swap has_mul.mul) has_lt.lt] {a : Î±} : aâ»Â¹ < 1 â†” 1 < a
theorem dense_closure {Î± : Type u} [topological_space Î±] {s : set Î±} : dense (closure s) â†” dense s
theorem hom_coe_pow {M : Type u_1} {F : Type u_2} [monoid F] (c : F â†’ M â†’ M) (h1 : c 1 = id) (hmul : âˆ€ (f g : F), c (f * g) = c f âˆ˜ c g) (f : F) (n : â„•) : c (f ^ n) = (c f^[n])
theorem local_equiv.ext {Î± : Type u_1} {Î² : Type u_2} {e e' : local_equiv Î± Î²} (h : âˆ€ (x : Î±), â‡‘e x = â‡‘e' x) (hsymm : âˆ€ (x : Î²), â‡‘(e.symm) x = â‡‘(e'.symm) x) (hs : e.source = e'.source) : e = e'
theorem continuous_linear_map.norm_id {ğ•œ : Type u_1} {E : Type u_4} [normed_group E] [nondiscrete_normed_field ğ•œ] [normed_space ğ•œ E] [nontrivial E] : âˆ¥continuous_linear_map.id ğ•œ Eâˆ¥ = 1
theorem Top.pullback_map_open_embedding_of_open_embeddings {W X Y Z S T : Top} (fâ‚ : W âŸ¶ S) (fâ‚‚ : X âŸ¶ S) (gâ‚ : Y âŸ¶ T) (gâ‚‚ : Z âŸ¶ T) {iâ‚ : W âŸ¶ Y} {iâ‚‚ : X âŸ¶ Z} (Hâ‚ : open_embedding â‡‘iâ‚) (Hâ‚‚ : open_embedding â‡‘iâ‚‚) (iâ‚ƒ : S âŸ¶ T) [Hâ‚ƒ : category_theory.mono iâ‚ƒ] (eqâ‚ : fâ‚ â‰« iâ‚ƒ = iâ‚ â‰« gâ‚) (eqâ‚‚ : fâ‚‚ â‰« iâ‚ƒ = iâ‚‚ â‰« gâ‚‚) : open_embedding â‡‘(category_theory.limits.pullback.map fâ‚ fâ‚‚ gâ‚ gâ‚‚ iâ‚ iâ‚‚ iâ‚ƒ eqâ‚ eqâ‚‚)
theorem monotone.convex_on_univ_of_deriv {f : â„ â†’ â„} (hf : differentiable â„ f) (hf'_mono : monotone (deriv f)) : convex_on â„ set.univ f
theorem continuous.comp_div_cases {Î± : Type u_1} {Î² : Type u_2} {Gâ‚€ : Type u_3} [group_with_zero Gâ‚€] [topological_space Gâ‚€] [has_continuous_invâ‚€ Gâ‚€] [has_continuous_mul Gâ‚€] [topological_space Î±] [topological_space Î²] {f g : Î± â†’ Gâ‚€} (h : Î± â†’ Gâ‚€ â†’ Î²) (hf : continuous f) (hg : continuous g) (hh : âˆ€ (a : Î±), g a â‰  0 â†’ continuous_at â†¿h (a, f a / g a)) (h2h : âˆ€ (a : Î±), g a = 0 â†’ filter.tendsto â†¿h ((nhds a).prod âŠ¤) (nhds (h a 0))) : continuous (Î» (x : Î±), h x (f x / g x))
theorem neg_pos_of_neg {Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a : Î±} : a < 0 â†’ 0 < -a
theorem asymptotics.is_O_with.of_bound {Î± : Type u_1} {E : Type u_3} {F : Type u_4} [has_norm E] [has_norm F] {c : â„} {f : Î± â†’ E} {g : Î± â†’ F} {l : filter Î±} : (âˆ€á¶  (x : Î±) in l, âˆ¥f xâˆ¥ â‰¤ c * âˆ¥g xâˆ¥) â†’ asymptotics.is_O_with c l f g
theorem zmod.legendre_sym_eq_one_iff (p : â„•) [fact (nat.prime p)] {a : â„¤} (ha0 : â†‘a â‰  0) : zmod.legendre_sym p a = 1 â†” is_square â†‘a
theorem weak_dual.is_compact_polar (ğ•œ : Type u_1) [nondiscrete_normed_field ğ•œ] {E : Type u_2} [semi_normed_group E] [normed_space ğ•œ E] [proper_space ğ•œ] {s : set E} (s_nhd : s âˆˆ nhds 0) : is_compact (weak_dual.polar ğ•œ s)
theorem continuous_iff_seq_continuous {X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] {f : X â†’ Y} [sequential_space X] : continuous f â†” seq_continuous f
theorem eq.trans_le {Î± : Type u} [preorder Î±] {a b c : Î±} (hab : a = b) (hbc : b â‰¤ c) : a â‰¤ c
theorem phragmen_lindelof.quadrant_IV {E : Type u_1} [normed_group E] [normed_space â„‚ E] {C : â„} {f : â„‚ â†’ E} {z : â„‚} (hd : diff_cont_on_cl â„‚ f (set.Ioi 0 Ã—â„‚ set.Iio 0)) (hB : âˆƒ (c : â„) (H : c < 2) (B : â„), f =O[filter.comap complex.abs filter.at_top âŠ“ filter.principal (set.Ioi 0 Ã—â„‚ set.Iio 0)] Î» (z : â„‚), real.exp (B * complex.abs z ^ c)) (hre : âˆ€ (x : â„), 0 â‰¤ x â†’ âˆ¥f â†‘xâˆ¥ â‰¤ C) (him : âˆ€ (x : â„), x â‰¤ 0 â†’ âˆ¥f (â†‘x * complex.I)âˆ¥ â‰¤ C) (hz_re : 0 â‰¤ z.re) (hz_im : z.im â‰¤ 0) : âˆ¥f zâˆ¥ â‰¤ C
theorem orientation.rotation_neg_orientation_eq_neg {V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) (Î¸ : real.angle) : (-o).rotation Î¸ = o.rotation (-Î¸)
theorem submodule.coe_scott_continuous {R : Type u_1} {M : Type u_4} [semiring R] [add_comm_monoid M] [module R M] : omega_complete_partial_order.continuous' coe
theorem tendsto_prod_top_iff {Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_4} [uniform_space Î²] {F : Î¹ â†’ Î± â†’ Î²} {p : filter Î¹} {c : Î²} : filter.tendsto â†¿F (p.prod âŠ¤) (nhds c) â†” tendsto_uniformly F (Î» (_x : Î±), c) p
theorem relation.acc_of_singleton {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} (hi : irreflexive r) {s : multiset Î±} : (âˆ€ (a : Î±), a âˆˆ s â†’ acc (relation.cut_expand r) {a}) â†’ acc (relation.cut_expand r) s
theorem ordinal.enum_ord_def {S : set ordinal} (o : ordinal) : ordinal.enum_ord S o = has_Inf.Inf (S âˆ© {b : ordinal | âˆ€ (c : ordinal), c < o â†’ ordinal.enum_ord S c < b})
theorem affine.simplex.sum_circumcenter_weights_with_circumcenter (n : â„•) : finset.univ.sum (Î» (i : affine.simplex.points_with_circumcenter_index n), affine.simplex.circumcenter_weights_with_circumcenter n i) = 1
theorem metric.frontier_cthickening_subset {Î± : Type u} [pseudo_emetric_space Î±] (E : set Î±) {Î´ : â„} : frontier (metric.cthickening Î´ E) âŠ† {x : Î± | emetric.inf_edist x E = ennreal.of_real Î´}
theorem exists_has_deriv_at_eq_zero (f f' : â„ â†’ â„) {a b : â„} (hab : a < b) (hfc : continuous_on f (set.Icc a b)) (hfI : f a = f b) (hff' : âˆ€ (x : â„), x âˆˆ set.Ioo a b â†’ has_deriv_at f (f' x) x) : âˆƒ (c : â„) (H : c âˆˆ set.Ioo a b), f' c = 0
theorem is_local_max.has_fderiv_at_eq_zero {E : Type u} [normed_group E] [normed_space â„ E] {f : E â†’ â„} {a : E} {f' : E â†’L[â„] â„} (h : is_local_max f a) (hf : has_fderiv_at f f' a) : f' = 0
theorem continuous_map.compact_conv_nhd_nhd_basis {Î± : Type uâ‚} {Î² : Type uâ‚‚} [topological_space Î±] [uniform_space Î²] {K : set Î±} {V : set (Î² Ã— Î²)} (f : C(Î±, Î²)) (hV : V âˆˆ uniformity Î²) : âˆƒ (V' : set (Î² Ã— Î²)) (H : V' âˆˆ uniformity Î²), V' âŠ† V âˆ§ âˆ€ (g : C(Î±, Î²)), g âˆˆ continuous_map.compact_conv_nhd K V' f â†’ continuous_map.compact_conv_nhd K V' g âŠ† continuous_map.compact_conv_nhd K V f
theorem category_theory.grothendieck_topology.covers_iff_mem_of_closed {C : Type u} [category_theory.category C] (Jâ‚ : category_theory.grothendieck_topology C) {X : C} {S : category_theory.sieve X} (h : Jâ‚.is_closed S) {Y : C} (f : Y âŸ¶ X) : Jâ‚.covers S f â†” â‡‘S f
theorem polynomial.is_root_cyclotomic_iff_char_zero {n : â„•} {R : Type u_1} [comm_ring R] [is_domain R] [char_zero R] {Î¼ : R} (hn : 0 < n) : (polynomial.cyclotomic n R).is_root Î¼ â†” is_primitive_root Î¼ n
theorem mv_polynomial.map_right_inverse {R : Type u} {Sâ‚ : Type v} {Ïƒ : Type u_1} [comm_semiring R] [comm_semiring Sâ‚] {f : R â†’+* Sâ‚} {g : Sâ‚ â†’+* R} (hf : function.right_inverse â‡‘f â‡‘g) : function.right_inverse â‡‘(mv_polynomial.map f) â‡‘(mv_polynomial.map g)
theorem real.sin_pi_div_three  : real.sin (real.pi / 3) = real.sqrt 3 / 2
theorem Compactum.Lim_eq_str {X : Compactum} (F : ultrafilter â†¥X) : F.Lim = X.str F
theorem padic_norm.neg (p : â„•) (q : â„š) : padic_norm p (-q) = padic_norm p q
theorem strict_convex.preimage_add_right {ğ•œ : Type u_1} {E : Type u_3} [ordered_semiring ğ•œ] [topological_space E] [add_cancel_comm_monoid E] [has_continuous_add E] [module ğ•œ E] {s : set E} (hs : strict_convex ğ•œ s) (z : E) : strict_convex ğ•œ ((Î» (x : E), z + x) â»Â¹' s)
theorem measure_theory.outer_measure.exists_measurable_superset_forall_eq_trim {Î± : Type u_1} [measurable_space Î±] {Î¹ : Type u_2} [encodable Î¹] (Î¼ : Î¹ â†’ measure_theory.outer_measure Î±) (s : set Î±) : âˆƒ (t : set Î±), s âŠ† t âˆ§ measurable_set t âˆ§ âˆ€ (i : Î¹), â‡‘(Î¼ i) t = â‡‘((Î¼ i).trim) s
theorem int.le_induction {P : â„¤ â†’ Prop} {m : â„¤} (h0 : P m) (h1 : âˆ€ (n : â„¤), m â‰¤ n â†’ P n â†’ P (n + 1)) (n : â„¤) : m â‰¤ n â†’ P n
theorem algebra.finite_presentation.iff_quotient_mv_polynomial' {R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] : algebra.finite_presentation R A â†” âˆƒ (Î¹ : Type u_2) (_x : fintype Î¹) (f : mv_polynomial Î¹ R â†’â‚[R] A), function.surjective â‡‘f âˆ§ f.to_ring_hom.ker.fg
theorem zmod.pow_totient {n : â„•} [fact (0 < n)] (x : (zmod n)Ë£) : x ^ n.totient = 1
theorem add_submonoid.mem_supr_iff_exists_dfinsupp' {Î¹ : Type u} {Î³ : Type w} [dec : decidable_eq Î¹] [add_comm_monoid Î³] (S : Î¹ â†’ add_submonoid Î³) [Î  (i : Î¹) (x : â†¥(S i)), decidable (x â‰  0)] (x : Î³) : x âˆˆ supr S â†” âˆƒ (f : Î â‚€ (i : Î¹), â†¥(S i)), f.sum (Î» (i : Î¹) (xi : â†¥(S i)), â†‘xi) = x
theorem polynomial.nat_degree_cyclotomic' {R : Type u_1} [comm_ring R] [is_domain R] {Î¶ : R} {n : â„•} (h : is_primitive_root Î¶ n) : (polynomial.cyclotomic' n R).nat_degree = n.totient
theorem is_least.union {Î³ : Type w} [linear_order Î³] {a b : Î³} {s t : set Î³} (ha : is_least s a) (hb : is_least t b) : is_least (s âˆª t) (linear_order.min a b)
theorem set.image2_distrib_subset_left {Î± : Type u_1} {Î² : Type u_3} {Î²' : Type u_4} {Î³ : Type u_5} {Î³' : Type u_6} {Î´ : Type u_7} {Îµ : Type u_9} {s : set Î±} {t : set Î²} {u : set Î³} {f : Î± â†’ Î´ â†’ Îµ} {g : Î² â†’ Î³ â†’ Î´} {fâ‚ : Î± â†’ Î² â†’ Î²'} {fâ‚‚ : Î± â†’ Î³ â†’ Î³'} {g' : Î²' â†’ Î³' â†’ Îµ} (h_distrib : âˆ€ (a : Î±) (b : Î²) (c : Î³), f a (g b c) = g' (fâ‚ a b) (fâ‚‚ a c)) : set.image2 f s (set.image2 g t u) âŠ† set.image2 g' (set.image2 fâ‚ s t) (set.image2 fâ‚‚ s u)
theorem measure_theory.measure.add_haar_closed_ball' {E : Type u_1} [normed_group E] [measurable_space E] [normed_space â„ E] [finite_dimensional â„ E] [borel_space E] (Î¼ : measure_theory.measure E) [Î¼.is_add_haar_measure] (x : E) {r : â„} (hr : 0 â‰¤ r) : â‡‘Î¼ (metric.closed_ball x r) = ennreal.of_real (r ^ finite_dimensional.finrank â„ E) * â‡‘Î¼ (metric.closed_ball 0 1)
theorem is_smul_regular.not_zero_iff {R : Type u_1} {M : Type u_3} [monoid_with_zero R] [has_zero M] [mul_action_with_zero R M] : Â¬is_smul_regular M 0 â†” nontrivial M
theorem two_mul_le_add_pow_two {R : Type u_4} [linear_ordered_comm_ring R] (a b : R) : 2 * a * b â‰¤ a ^ 2 + b ^ 2
theorem finset.sum_sigma {Î² : Type u} {Î± : Type v} [add_comm_monoid Î²] {Ïƒ : Î± â†’ Type u_1} (s : finset Î±) (t : Î  (a : Î±), finset (Ïƒ a)) (f : sigma Ïƒ â†’ Î²) : (s.sigma t).sum (Î» (x : Î£ (i : Î±), Ïƒ i), f x) = s.sum (Î» (a : Î±), (t a).sum (Î» (s : Ïƒ a), f âŸ¨a, sâŸ©))
theorem totally_disconnected_space_iff_connected_component_singleton {Î± : Type u} [topological_space Î±] : totally_disconnected_space Î± â†” âˆ€ (x : Î±), connected_component x = {x}
theorem cont_diff.dense_compl_range_of_finrank_lt_finrank {E : Type u_4} {F : Type u_5} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] [normed_group F] [normed_space â„ F] [finite_dimensional â„ F] {f : E â†’ F} (h : cont_diff â„ 1 f) (hEF : finite_dimensional.finrank â„ E < finite_dimensional.finrank â„ F) : dense (set.range f)á¶œ
theorem same_ray.inv_norm_smul_eq {F : Type u_2} [normed_group F] [normed_space â„ F] {x y : F} (hx : x â‰  0) (hy : y â‰  0) : same_ray â„ x y â†’ âˆ¥xâˆ¥â»Â¹ â€¢ x = âˆ¥yâˆ¥â»Â¹ â€¢ y
theorem affine_subspace.not_mem_bot (k : Type u_1) (V : Type u_2) {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] (p : P) : p âˆ‰ âŠ¥
theorem matrix.det_mul_add_one_comm {m : Type u} {n : Type u'} {Î± : Type v} [fintype n] [decidable_eq n] [comm_ring Î±] [fintype m] [decidable_eq m] (A : matrix m n Î±) (B : matrix n m Î±) : (A.mul B + 1).det = (B.mul A + 1).det
theorem add_submonoid.localization_map.add_neg_right {M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {N : Type u_2} [add_comm_monoid N] {f : M â†’+ N} (h : âˆ€ (y : â†¥S), is_add_unit (â‡‘f â†‘y)) (y : â†¥S) (w z : N) : z = w + â†‘-â‡‘(is_add_unit.lift_right (f.restrict S) h) y â†” z + â‡‘f â†‘y = w
theorem submodule.inf_orthogonal_eq_bot {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] (K : submodule ğ•œ E) : K âŠ“ Ká—® = âŠ¥
theorem measure_theory.signed_measure.eq_rn_deriv {Î± : Type u_1} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {s : measure_theory.signed_measure Î±} (t : measure_theory.signed_measure Î±) (f : Î± â†’ â„) (hfi : measure_theory.integrable f Î¼) (htÎ¼ : measure_theory.vector_measure.mutually_singular t Î¼.to_ennreal_vector_measure) (hadd : s = t + Î¼.with_densityáµ¥ f) : f =áµ[Î¼] s.rn_deriv Î¼
theorem is_add_group_hom.map_zero {Î± : Type u} {Î² : Type v} [add_group Î±] [add_group Î²] {f : Î± â†’ Î²} (hf : is_add_group_hom f) : f 0 = 0
theorem dense_range.dense_of_maps_to {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] {f : Î± â†’ Î²} (hf' : dense_range f) (hf : continuous f) {s : set Î±} (hs : dense s) {t : set Î²} (ht : set.maps_to f s t) : dense t
theorem roth_number_nat_add_le (M N : â„•) : â‡‘roth_number_nat (M + N) â‰¤ â‡‘roth_number_nat M + â‡‘roth_number_nat N
theorem antitone.cauchy_seq_series_mul_of_tendsto_zero_of_bounded {E : Type u_4} [normed_group E] [normed_space â„ E] {b : â„} {f : â„• â†’ â„} {z : â„• â†’ E} (hfa : antitone f) (hf0 : filter.tendsto f filter.at_top (nhds 0)) (hzb : âˆ€ (n : â„•), âˆ¥(finset.range n).sum (Î» (i : â„•), z i)âˆ¥ â‰¤ b) : cauchy_seq (Î» (n : â„•), (finset.range (n + 1)).sum (Î» (i : â„•), f i â€¢ z i))
theorem emetric.diam_mono {Î± : Type u} [pseudo_emetric_space Î±] {s t : set Î±} (h : s âŠ† t) : emetric.diam s â‰¤ emetric.diam t
theorem convex_on_zpow (m : â„¤) : convex_on â„ (set.Ioi 0) (Î» (x : â„), x ^ m)
theorem add_eq_add_iff_eq_and_eq {Î± : Type u_1} [add_semigroup Î±] [partial_order Î±] [covariant_class Î± Î± has_add.add has_lt.lt] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] [contravariant_class Î± Î± has_add.add has_le.le] [contravariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b c d : Î±} (hac : a â‰¤ c) (hbd : b â‰¤ d) : a + b = c + d â†” a = c âˆ§ b = d
theorem metric.diam_union' {Î± : Type u} [pseudo_metric_space Î±] {s t : set Î±} (h : (s âˆ© t).nonempty) : metric.diam (s âˆª t) â‰¤ metric.diam s + metric.diam t
theorem fin.prod_univ_eq_prod_range {Î± : Type u_1} [comm_monoid Î±] (f : â„• â†’ Î±) (n : â„•) : finset.univ.prod (Î» (i : fin n), f â†‘i) = (finset.range n).prod (Î» (i : â„•), f i)
theorem algebra.is_algebraic_of_finite (K : Type u_1) (L : Type u_2) [field K] [field L] [algebra K L] [finite : finite_dimensional K L] : algebra.is_algebraic K L
theorem fintype.sum_pow_mul_eq_add_pow (Î± : Type u_1) [fintype Î±] {R : Type u_2} [comm_semiring R] (a b : R) : finset.univ.sum (Î» (s : finset Î±), a ^ s.card * b ^ (fintype.card Î± - s.card)) = (a + b) ^ fintype.card Î±
theorem nat.factorization_pow (n k : â„•) : (n ^ k).factorization = k â€¢ n.factorization
theorem free_group.reduce.exact {Î± : Type u} {Lâ‚ Lâ‚‚ : list (Î± Ã— bool)} [decidable_eq Î±] (H : free_group.reduce Lâ‚ = free_group.reduce Lâ‚‚) : free_group.mk Lâ‚ = free_group.mk Lâ‚‚
theorem list.head_mul_tail_prod_of_ne_nil {M : Type u_3} [monoid M] [inhabited M] (l : list M) (h : l â‰  list.nil) : l.head * l.tail.prod = l.prod
theorem monotone.ne_of_lt_of_lt_nat {Î± : Type u} [preorder Î±] {f : â„• â†’ Î±} (hf : monotone f) (n : â„•) {x : Î±} (h1 : f n < x) (h2 : x < f (n + 1)) (a : â„•) : f a â‰  x
theorem mul_equiv.map_one {M : Type u_1} {N : Type u_2} [mul_one_class M] [mul_one_class N] (h : M â‰ƒ* N) : â‡‘h 1 = 1
theorem polynomial.cyclotomic'_zero (R : Type u_1) [comm_ring R] [is_domain R] : polynomial.cyclotomic' 0 R = 1
theorem list.nodup.cyclic_permutations {Î± : Type u} {l : list Î±} (hn : l.nodup) : l.cyclic_permutations.nodup
theorem is_primitive_root.separable_minpoly_mod {n : â„•} {K : Type u_8} [field K] {Î¼ : K} (h : is_primitive_root Î¼ n) [char_zero K] {p : â„•} [fact (nat.prime p)] (hdiv : Â¬p âˆ£ n) : (polynomial.map (int.cast_ring_hom (zmod p)) (minpoly â„¤ Î¼)).separable
theorem has_strict_deriv_at_exp_zero {ğ•‚ : Type u_1} [is_R_or_C ğ•‚] : has_strict_deriv_at (exp ğ•‚) 1 0
theorem interval_integral.has_fderiv_at_integral_of_dominated_loc_of_lip {ğ•œ : Type u_1} [is_R_or_C ğ•œ] {Î¼ : measure_theory.measure â„} {E : Type u_2} [normed_group E] [normed_space â„ E] [normed_space ğ•œ E] [complete_space E] {H : Type u_3} [normed_group H] [normed_space ğ•œ H] {a b Îµ : â„} {bound : â„ â†’ â„} {F : H â†’ â„ â†’ E} {F' : â„ â†’ (H â†’L[ğ•œ] E)} {xâ‚€ : H} (Îµ_pos : 0 < Îµ) (hF_meas : âˆ€á¶  (x : H) in nhds xâ‚€, measure_theory.ae_strongly_measurable (F x) (Î¼.restrict (set.interval_oc a b))) (hF_int : interval_integrable (F xâ‚€) Î¼ a b) (hF'_meas : measure_theory.ae_strongly_measurable F' (Î¼.restrict (set.interval_oc a b))) (h_lip : âˆ€áµ (t : â„) âˆ‚Î¼, t âˆˆ set.interval_oc a b â†’ lipschitz_on_with (â‡‘real.nnabs (bound t)) (Î» (x : H), F x t) (metric.ball xâ‚€ Îµ)) (bound_integrable : interval_integrable bound Î¼ a b) (h_diff : âˆ€áµ (t : â„) âˆ‚Î¼, t âˆˆ set.interval_oc a b â†’ has_fderiv_at (Î» (x : H), F x t) (F' t) xâ‚€) : interval_integrable F' Î¼ a b âˆ§ has_fderiv_at (Î» (x : H), âˆ« (t : â„) in a..b, F x t âˆ‚Î¼) (âˆ« (t : â„) in a..b, F' t âˆ‚Î¼) xâ‚€
theorem ennreal.sum_lt_top_iff {Î± : Type u_1} {s : finset Î±} {f : Î± â†’ ennreal} : s.sum (Î» (a : Î±), f a) < âŠ¤ â†” âˆ€ (a : Î±), a âˆˆ s â†’ f a < âŠ¤
theorem affine_map.affine_independent_iff {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {Î¹ : Type u_4} {Vâ‚‚ : Type u_5} {Pâ‚‚ : Type u_6} [add_comm_group Vâ‚‚] [module k Vâ‚‚] [add_torsor Vâ‚‚ Pâ‚‚] {p : Î¹ â†’ P} (f : P â†’áµƒ[k] Pâ‚‚) (hf : function.injective â‡‘f) : affine_independent k (â‡‘f âˆ˜ p) â†” affine_independent k p
theorem liouville.liouville_with {x : â„} (hx : liouville x) (p : â„) : liouville_with p x
theorem matrix.pivot.exists_list_transvec_mul_diagonal_mul_list_transvec {n : Type u_1} {ğ•œ : Type u_3} [field ğ•œ] [decidable_eq n] [fintype n] (M : matrix n n ğ•œ) : âˆƒ (L L' : list (matrix.transvection_struct n ğ•œ)) (D : n â†’ ğ•œ), M = ((list.map matrix.transvection_struct.to_matrix L).prod.mul (matrix.diagonal D)).mul (list.map matrix.transvection_struct.to_matrix L').prod
theorem finite_dimensional.finrank_eq_dim (K : Type u) (V : Type v) [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] : â†‘(finite_dimensional.finrank K V) = module.rank K V
theorem add_pos {Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b : Î±} (ha : 0 < a) (hb : 0 < b) : 0 < a + b
theorem setoid.comap_eq {Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} {r : setoid Î²} : setoid.comap f r = setoid.ker (quotient.mk âˆ˜ f)
theorem real.summable_pow_div_factorial (x : â„) : summable (Î» (n : â„•), x ^ n / â†‘(n.factorial))
theorem metric.uniform_continuous_inf_nndist_pt {Î± : Type u} [pseudo_metric_space Î±] (s : set Î±) : uniform_continuous (Î» (x : Î±), metric.inf_nndist x s)
theorem submodule.torsion_torsion_eq_top {R : Type u_1} {M : Type u_2} [comm_semiring R] [add_comm_monoid M] [module R M] : submodule.torsion R â†¥(submodule.torsion R M) = âŠ¤
theorem finset.all_card_le_bUnion_card_iff_exists_injective {Î¹ : Type u} {Î± : Type v} [decidable_eq Î±] (t : Î¹ â†’ finset Î±) : (âˆ€ (s : finset Î¹), s.card â‰¤ (s.bUnion t).card) â†” âˆƒ (f : Î¹ â†’ Î±), function.injective f âˆ§ âˆ€ (x : Î¹), f x âˆˆ t x
theorem colex.hom_fin_le_iff {n : â„•} (A B : finset (fin n)) : (finset.image (Î» (i : fin n), â†‘i) A).to_colex â‰¤ (finset.image (Î» (i : fin n), â†‘i) B).to_colex â†” A.to_colex â‰¤ B.to_colex
theorem finite_field.unit_is_square_iff {F : Type u_3} [field F] [fintype F] (hF : ring_char F â‰  2) (a : FË£) : is_square a â†” a ^ (fintype.card F / 2) = 1
theorem commute.is_of_fin_order_mul {G : Type u} {y : G} [monoid G] {x : G} (h : commute x y) (hx : is_of_fin_order x) (hy : is_of_fin_order y) : is_of_fin_order (x * y)
theorem interval_integral.integral_has_deriv_at_of_tendsto_ae_right {E : Type u_3} [normed_group E] [complete_space E] [normed_space â„ E] {f : â„ â†’ E} {c : E} {a b : â„} (hf : interval_integrable f measure_theory.measure_space.volume a b) (hmeas : strongly_measurable_at_filter f (nhds b) measure_theory.measure_space.volume) (hb : filter.tendsto f (nhds b âŠ“ measure_theory.measure_space.volume.ae) (nhds c)) : has_deriv_at (Î» (u : â„), âˆ« (x : â„) in a..u, f x) c b
theorem mul_opposite.op_zpow {M : Type u} [div_inv_monoid M] (x : M) (z : â„¤) : mul_opposite.op (x ^ z) = mul_opposite.op x ^ z
theorem category_theory.epi_iff_surjective {X Y : Type u} (f : X âŸ¶ Y) : category_theory.epi f â†” function.surjective f
theorem iterated_fderiv_within_of_is_open {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {s : set E} {f : E â†’ F} (n : â„•) (hs : is_open s) : set.eq_on (iterated_fderiv_within ğ•œ n f s) (iterated_fderiv ğ•œ n f) s
theorem algebraic_geometry.PresheafedSpace.glue_data.Î¹_inv_app_Ï€ {C : Type u} [category_theory.category C] (D : algebraic_geometry.PresheafedSpace.glue_data C) [category_theory.limits.has_limits C] {i : D.to_glue_data.J} (U : topological_space.opens â†¥((D.to_glue_data.U i).carrier)) : âˆƒ (eq_1 : opposite.op U = opposite.op ((topological_space.opens.map (category_theory.limits.colimit.Î¹ D.to_glue_data.diagram.multispan (opposite.unop (opposite.op (category_theory.limits.walking_multispan.right i)))).base).obj (_.functor.obj U))), D.Î¹_inv_app U â‰« D.diagram_over_open_Ï€ U i = (D.to_glue_data.U i).presheaf.map (category_theory.eq_to_hom eq_1)
theorem is_min_on.dual {Î± : Type u} {Î² : Type v} [preorder Î²] {f : Î± â†’ Î²} {s : set Î±} {a : Î±} : is_min_on f s a â†’ is_max_on (â‡‘order_dual.to_dual âˆ˜ f) s a
theorem first_order.language.equiv.comp_assoc {L : first_order.language} {M : Type w} {N : Type w'} [L.Structure M] [L.Structure N] {P : Type u_1} [L.Structure P] {Q : Type u_2} [L.Structure Q] (f : L.equiv M N) (g : L.equiv N P) (h : L.equiv P Q) : (h.comp g).comp f = h.comp (g.comp f)
theorem complex.abs_deriv_le_div_of_maps_to_ball {f : â„‚ â†’ â„‚} {c : â„‚} {Râ‚ Râ‚‚ : â„} (hd : differentiable_on â„‚ f (metric.ball c Râ‚)) (h_maps : set.maps_to f (metric.ball c Râ‚) (metric.ball (f c) Râ‚‚)) (hâ‚€ : 0 < Râ‚) : complex.abs (deriv f c) â‰¤ Râ‚‚ / Râ‚
theorem is_cyclotomic_extension.splitting_field_X_pow_sub_one (n : â„•+) (K : Type w) (L : Type z) [field K] [field L] [algebra K L] [ne_zero â†‘â†‘n] [is_cyclotomic_extension {n} K L] : polynomial.is_splitting_field K L (polynomial.X ^ â†‘n - 1)
theorem has_ftaylor_series_up_to.has_fderiv_at {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {f : E â†’ F} {n : with_top â„•} {p : E â†’ formal_multilinear_series ğ•œ E F} (h : has_ftaylor_series_up_to n f p) (hn : 1 â‰¤ n) (x : E) : has_fderiv_at f (â‡‘(continuous_multilinear_curry_fin1 ğ•œ E F) (p x 1)) x
theorem nat.support_factorization {n : â„•} : n.factorization.support = n.factors.to_finset
theorem category_theory.finrank_hom_simple_simple_le_one {C : Type u_1} [category_theory.category C] [category_theory.preadditive C] (ğ•œ : Type u_3) [field ğ•œ] [is_alg_closed ğ•œ] [category_theory.linear ğ•œ C] [category_theory.limits.has_kernels C] (X Y : C) [finite_dimensional ğ•œ (X âŸ¶ X)] [category_theory.simple X] [category_theory.simple Y] : finite_dimensional.finrank ğ•œ (X âŸ¶ Y) â‰¤ 1
theorem zmod.Ï‡â‚„_trichotomy (a : zmod 4) : â‡‘zmod.Ï‡â‚„ a = 0 âˆ¨ â‡‘zmod.Ï‡â‚„ a = 1 âˆ¨ â‡‘zmod.Ï‡â‚„ a = -1
theorem antisymm_of {Î± : Type u} (r : Î± â†’ Î± â†’ Prop) [is_antisymm Î± r] {a b : Î±} : r a b â†’ r b a â†’ a = b
theorem add_pow_two {R : Type uâ‚} [comm_semiring R] (a b : R) : (a + b) ^ 2 = a ^ 2 + 2 * a * b + b ^ 2
theorem polynomial.cyclotomic'.monic (n : â„•) (R : Type u_1) [comm_ring R] [is_domain R] : (polynomial.cyclotomic' n R).monic
theorem submodule.span_span_of_tower (R : Type u_1) {M : Type u_4} (S : Type u_7) [semiring R] [add_comm_monoid M] [module R M] (s : set M) [semiring S] [has_scalar R S] [module S M] [is_scalar_tower R S M] : submodule.span S â†‘(submodule.span R s) = submodule.span S s
theorem linear_map.is_compl_span_singleton_orthogonal {K : Type u_8} {V : Type u_11} [field K] [add_comm_group V] [module K V] {B : V â†’â‚—[K] V â†’â‚—[K] K} {x : V} (hx : Â¬B.is_ortho x x) : is_compl (submodule.span K {x}) ((submodule.span K {x}).orthogonal_bilin B)
theorem continuous_linear_map.inverse_non_equiv {R : Type u_1} {M : Type u_2} {Mâ‚‚ : Type u_3} [topological_space M] [topological_space Mâ‚‚] [semiring R] [add_comm_monoid Mâ‚‚] [module R Mâ‚‚] [add_comm_monoid M] [module R M] (f : M â†’L[R] Mâ‚‚) (h : Â¬âˆƒ (e' : M â‰ƒL[R] Mâ‚‚), â†‘e' = f) : f.inverse = 0
theorem zmod.legendre_sym_mod (p : â„•) [fact (nat.prime p)] (a : â„¤) : zmod.legendre_sym p a = zmod.legendre_sym p (a % â†‘p)
theorem universal_enveloping_algebra.hom_ext (R : Type uâ‚) {L : Type uâ‚‚} [comm_ring R] [lie_ring L] [lie_algebra R L] {A : Type uâ‚ƒ} [ring A] [algebra R A] {gâ‚ gâ‚‚ : universal_enveloping_algebra R L â†’â‚[R] A} (h : â†‘gâ‚.comp (universal_enveloping_algebra.Î¹ R) = â†‘gâ‚‚.comp (universal_enveloping_algebra.Î¹ R)) : gâ‚ = gâ‚‚
theorem has_strict_deriv_at.of_local_left_inverse {ğ•œ : Type u} [nondiscrete_normed_field ğ•œ] {f g : ğ•œ â†’ ğ•œ} {f' a : ğ•œ} (hg : continuous_at g a) (hf : has_strict_deriv_at f f' (g a)) (hf' : f' â‰  0) (hfg : âˆ€á¶  (y : ğ•œ) in nhds a, f (g y) = y) : has_strict_deriv_at g f'â»Â¹ a
theorem finite_dimensional.finrank_self (K : Type u) [division_ring K] : finite_dimensional.finrank K K = 1
theorem measure_theory.measure.hausdorff_measure_zero_or_top {X : Type u_2} [emetric_space X] [measurable_space X] [borel_space X] {dâ‚ dâ‚‚ : â„} (h : dâ‚ < dâ‚‚) (s : set X) : â‡‘(measure_theory.measure.hausdorff_measure dâ‚‚) s = 0 âˆ¨ â‡‘(measure_theory.measure.hausdorff_measure dâ‚) s = âŠ¤
theorem real_inner_div_norm_mul_norm_eq_one_of_ne_zero_of_pos_mul {F : Type u_3} [inner_product_space â„ F] {x : F} {r : â„} (hx : x â‰  0) (hr : 0 < r) : has_inner.inner x (r â€¢ x) / (âˆ¥xâˆ¥ * âˆ¥r â€¢ xâˆ¥) = 1
theorem interval_integral.integral_pos_iff_support_of_nonneg_ae' {f : â„ â†’ â„} {a b : â„} {Î¼ : measure_theory.measure â„} (hf : 0 â‰¤áµ[Î¼.restrict (set.interval_oc a b)] f) (hfi : interval_integrable f Î¼ a b) : 0 < âˆ« (x : â„) in a..b, f x âˆ‚Î¼ â†” a < b âˆ§ 0 < â‡‘Î¼ (function.support f âˆ© set.Ioc a b)
theorem one_add_mul_sub_le_pow {R : Type uâ‚} [linear_ordered_ring R] {a : R} (H : -1 â‰¤ a) (n : â„•) : 1 + â†‘n * (a - 1) â‰¤ a ^ n
theorem is_add_hom.to_is_add_monoid_hom {Î± : Type u} {Î² : Type v} [add_zero_class Î±] [add_group Î²] {f : Î± â†’ Î²} (hf : is_add_hom f) : is_add_monoid_hom f
theorem has_mem.mem.ne_of_not_mem {Î± : Type u_1} {Î² : Type u_2} [has_mem Î± Î²] {s : Î²} {a b : Î±} : a âˆˆ s â†’ b âˆ‰ s â†’ a â‰  b
theorem antitone.ne_of_lt_of_lt_nat {Î± : Type u} [preorder Î±] {f : â„• â†’ Î±} (hf : antitone f) (n : â„•) {x : Î±} (h1 : f (n + 1) < x) (h2 : x < f n) (a : â„•) : f a â‰  x
theorem category_theory.classifier_is_sheaf {C : Type u} [category_theory.category C] (Jâ‚ : category_theory.grothendieck_topology C) : category_theory.presieve.is_sheaf Jâ‚ (category_theory.functor.closed_sieves Jâ‚)
theorem witt_vector.map_teichmuller (p : â„•) {R : Type u_1} {S : Type u_2} [hp : fact (nat.prime p)] [comm_ring R] [comm_ring S] (f : R â†’+* S) (r : R) : â‡‘(witt_vector.map f) (â‡‘(witt_vector.teichmuller p) r) = â‡‘(witt_vector.teichmuller p) (â‡‘f r)
theorem category_theory.limits.fork.equalizer_ext {C : Type u} [category_theory.category C] {X Y : C} {f g : X âŸ¶ Y} (s : category_theory.limits.fork f g) {W : C} {k l : W âŸ¶ s.X} (h : k â‰« s.Î¹ = l â‰« s.Î¹) (j : category_theory.limits.walking_parallel_pair) : k â‰« s.Ï€.app j = l â‰« s.Ï€.app j
theorem finset.sum_smul_const_vsub_eq_vsub_affine_combination {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {Î¹ : Type u_4} (s : finset Î¹) (w : Î¹ â†’ k) (pâ‚‚ : Î¹ â†’ P) (pâ‚ : P) (h : s.sum (Î» (i : Î¹), w i) = 1) : s.sum (Î» (i : Î¹), w i â€¢ (pâ‚ -áµ¥ pâ‚‚ i)) = pâ‚ -áµ¥ â‡‘(s.affine_combination pâ‚‚) w
theorem nat.choose_le_succ_of_lt_half_left {r n : â„•} (h : r < n / 2) : n.choose r â‰¤ n.choose (r + 1)
theorem mem_affine_span_iff_eq_affine_combination (k : Type u_1) (V : Type u_2) {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {Î¹ : Type u_4} [nontrivial k] {p1 : P} {p : Î¹ â†’ P} : p1 âˆˆ affine_span k (set.range p) â†” âˆƒ (s : finset Î¹) (w : Î¹ â†’ k) (hw : s.sum (Î» (i : Î¹), w i) = 1), p1 = â‡‘(s.affine_combination p) w
theorem cont_diff_at.continuous_linear_map_comp {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {G : Type u_4} [normed_group G] [normed_space ğ•œ G] {f : E â†’ F} {x : E} {n : with_top â„•} (g : F â†’L[ğ•œ] G) (hf : cont_diff_at ğ•œ n f x) : cont_diff_at ğ•œ n (â‡‘g âˆ˜ f) x
theorem finset.card_Ioo_finset {Î± : Type u_1} [decidable_eq Î±] {s t : finset Î±} (h : s âŠ† t) : (finset.Ioo s t).card = 2 ^ (t.card - s.card) - 2
theorem basis.le_span'' {R : Type u} [ring R] [rank_condition R] {M : Type v} [add_comm_group M] [module R M] {Î¹ : Type u_1} [fintype Î¹] (b : basis Î¹ R M) {w : set M} [fintype â†¥w] (s : submodule.span R w = âŠ¤) : fintype.card Î¹ â‰¤ fintype.card â†¥w
theorem cont_diff.fst' {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {G : Type u_4} [normed_group G] [normed_space ğ•œ G] {n : with_top â„•} {f : E â†’ G} (hf : cont_diff ğ•œ n f) : cont_diff ğ•œ n (Î» (x : E Ã— F), f x.fst)
theorem generalized_continued_fraction.int_fract_pair.seq1_fst_eq_of {K : Type u_1} [linear_ordered_field K] [floor_ring K] {v : K} : (generalized_continued_fraction.int_fract_pair.seq1 v).fst = generalized_continued_fraction.int_fract_pair.of v
theorem set.pairwise_eq_iff_exists_eq {Î± : Type u_1} {Î¹ : Type u_2} [nonempty Î¹] (s : set Î±) (f : Î± â†’ Î¹) : s.pairwise (Î» (x y : Î±), f x = f y) â†” âˆƒ (z : Î¹), âˆ€ (x : Î±), x âˆˆ s â†’ f x = z
theorem sym2.card_image_diag {Î± : Type u_1} [decidable_eq Î±] (s : finset Î±) : (finset.image quotient.mk s.diag).card = s.card
theorem iterated_fderiv_within_succ_eq_comp_left {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {s : set E} {f : E â†’ F} {n : â„•} : iterated_fderiv_within ğ•œ (n + 1) f s = â‡‘(continuous_multilinear_curry_left_equiv ğ•œ (Î» (i : fin (n + 1)), E) F) âˆ˜ fderiv_within ğ•œ (iterated_fderiv_within ğ•œ n f s) s
theorem add_lt_of_lt_sub_right {Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b c : Î±} : a < c - b â†’ a + b < c
theorem finite_dimensional.eq_top_of_finrank_eq {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] {S : submodule K V} (h : finite_dimensional.finrank K â†¥S = finite_dimensional.finrank K V) : S = âŠ¤
theorem category_theory.presieve.is_sheaf_for_top_sieve {C : Type uâ‚} [category_theory.category C] {X : C} (P : Cáµ’áµ– â¥¤ Type w) : category_theory.presieve.is_sheaf_for P â‡‘âŠ¤
theorem list.subperm.cons {Î± : Type uu} (a : Î±) {lâ‚ lâ‚‚ : list Î±} : lâ‚ <+~ lâ‚‚ â†’ a :: lâ‚ <+~ a :: lâ‚‚
theorem le_cinfi {Î± : Type u_1} {Î¹ : Sort u_3} [conditionally_complete_lattice Î±] [nonempty Î¹] {f : Î¹ â†’ Î±} {c : Î±} (H : âˆ€ (x : Î¹), c â‰¤ f x) : c â‰¤ infi f
theorem category_theory.is_equivalence.of_iso_refl {C : Type uâ‚} [category_theory.category C] {D : Type uâ‚‚} [category_theory.category D] (F : C â¥¤ D) (hF : category_theory.is_equivalence F) : category_theory.is_equivalence.of_iso (category_theory.iso.refl F) hF = hF
theorem measure_theory.measure.ext_of_Iic {Î± : Type u_1} [topological_space Î±] {m : measurable_space Î±} [topological_space.second_countable_topology Î±] [linear_order Î±] [order_topology Î±] [borel_space Î±] (Î¼ Î½ : measure_theory.measure Î±) [measure_theory.is_finite_measure Î¼] (h : âˆ€ (a : Î±), â‡‘Î¼ (set.Iic a) = â‡‘Î½ (set.Iic a)) : Î¼ = Î½
theorem fintype.induction_subsingleton_or_nontrivial {P : Î  (Î± : Type u_1) [_inst_1 : fintype Î±], Prop} (Î± : Type u_1) [fintype Î±] (hbase : âˆ€ (Î± : Type u_1) [_inst_3 : fintype Î±] [_inst_4 : subsingleton Î±], P Î±) (hstep : âˆ€ (Î± : Type u_1) [_inst_5 : fintype Î±] [_inst_6 : nontrivial Î±], (âˆ€ (Î² : Type u_1) [_inst_7 : fintype Î²], fintype.card Î² < fintype.card Î± â†’ P Î²) â†’ P Î±) : P Î±
theorem measure_theory.exists_measurable_superset_forall_eq {Î± : Type u_1} [measurable_space Î±] {Î¹ : Type u_2} [encodable Î¹] (Î¼ : Î¹ â†’ measure_theory.measure Î±) (s : set Î±) : âˆƒ (t : set Î±), s âŠ† t âˆ§ measurable_set t âˆ§ âˆ€ (i : Î¹), â‡‘(Î¼ i) t = â‡‘(Î¼ i) s
theorem free_monoid.star_one {Î± : Type u_1} : has_star.star 1 = 1
theorem exists_dual_vector (ğ•œ : Type v) [is_R_or_C ğ•œ] {E : Type u} [normed_group E] [normed_space ğ•œ E] (x : E) (h : x â‰  0) : âˆƒ (g : E â†’L[ğ•œ] ğ•œ), âˆ¥gâˆ¥ = 1 âˆ§ â‡‘g x = â†‘âˆ¥xâˆ¥
theorem category_theory.is_cofiltered.eq_condition {C : Type u} [category_theory.category C] [category_theory.is_cofiltered C] {j j' : C} (f f' : j âŸ¶ j') : category_theory.is_cofiltered.eq_hom f f' â‰« f = category_theory.is_cofiltered.eq_hom f f' â‰« f'
theorem liouville_with.mul_rat_iff {p x : â„} {r : â„š} (hr : r â‰  0) : liouville_with p (x * â†‘r) â†” liouville_with p x
theorem finset.affine_combination_indicator_subset {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {Î¹ : Type u_4} (w : Î¹ â†’ k) (p : Î¹ â†’ P) {sâ‚ sâ‚‚ : finset Î¹} (h : sâ‚ âŠ† sâ‚‚) : â‡‘(sâ‚.affine_combination p) w = â‡‘(sâ‚‚.affine_combination p) (â†‘sâ‚.indicator w)
theorem ideal.ker_lift_alg_injective {Râ‚ : Type u_3} {A : Type u_5} {B : Type u_6} [comm_semiring Râ‚] [comm_ring A] [comm_ring B] [algebra Râ‚ A] [algebra Râ‚ B] (f : A â†’â‚[Râ‚] B) : function.injective â‡‘(ideal.ker_lift_alg f)
theorem first_order.language.Structure.fg_iff {L : first_order.language} {M : Type u_3} [L.Structure M] : first_order.language.Structure.fg L M â†” âˆƒ (S : set M), S.finite âˆ§ â‡‘(first_order.language.substructure.closure L) S = âŠ¤
theorem linear_recurrence.sol_eq_of_eq_init {Î± : Type u_1} [comm_semiring Î±] (E : linear_recurrence Î±) (u v : â„• â†’ Î±) (hu : E.is_solution u) (hv : E.is_solution v) : u = v â†” set.eq_on u v â†‘(finset.range E.order)
theorem real.tendsto_exp_at_top  : filter.tendsto real.exp filter.at_top filter.at_top
theorem iterated_fderiv_within_congr {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {s : set E} {f fâ‚ : E â†’ F} {x : E} {n : â„•} (hs : unique_diff_on ğ•œ s) (hL : âˆ€ (y : E), y âˆˆ s â†’ fâ‚ y = f y) (hx : x âˆˆ s) : iterated_fderiv_within ğ•œ n fâ‚ s x = iterated_fderiv_within ğ•œ n f s x
theorem upper_semicontinuous_on.add {Î± : Type u_1} [topological_space Î±] {s : set Î±} {Î³ : Type u_4} [linear_ordered_add_comm_monoid Î³] [topological_space Î³] [order_topology Î³] [has_continuous_add Î³] {f g : Î± â†’ Î³} (hf : upper_semicontinuous_on f s) (hg : upper_semicontinuous_on g s) : upper_semicontinuous_on (Î» (z : Î±), f z + g z) s
theorem acc.cut_expand {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} (hi : irreflexive r) {a : Î±} (hacc : acc r a) : acc (relation.cut_expand r) {a}
theorem affine_subspace.mk'_eq {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : affine_subspace k P} {p : P} (hp : p âˆˆ s) : affine_subspace.mk' p s.direction = s
theorem pequiv.equiv_to_pequiv_to_matrix {n : Type u_4} {Î± : Type v} [decidable_eq n] [has_zero Î±] [has_one Î±] (Ïƒ : n â‰ƒ n) (i j : n) : Ïƒ.to_pequiv.to_matrix i j = 1 (â‡‘Ïƒ i) j
theorem homological_complex.image_to_kernel_as_boundaries_to_cycles {Î¹ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {c : complex_shape Î¹} [category_theory.limits.has_zero_object V] [category_theory.limits.has_kernels V] [category_theory.limits.has_images V] (C : homological_complex V c) (i : Î¹) (h : C.boundaries i â‰¤ C.cycles i) : (C.boundaries i).of_le (C.cycles i) h = C.boundaries_to_cycles i
theorem pi.mul_single_comm {I : Type u} [decidable_eq I] {Î² : Type u_1} [has_one Î²] (i : I) (x : Î²) (i' : I) : pi.mul_single i x i' = pi.mul_single i' x i
theorem inner_eq_norm_mul_iff {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {x y : E} : has_inner.inner x y = â†‘âˆ¥xâˆ¥ * â†‘âˆ¥yâˆ¥ â†” â†‘âˆ¥yâˆ¥ â€¢ x = â†‘âˆ¥xâˆ¥ â€¢ y
theorem list.chain'.append_overlap {Î± : Type u} {R : Î± â†’ Î± â†’ Prop} {lâ‚ lâ‚‚ lâ‚ƒ : list Î±} (hâ‚ : list.chain' R (lâ‚ ++ lâ‚‚)) (hâ‚‚ : list.chain' R (lâ‚‚ ++ lâ‚ƒ)) (hn : lâ‚‚ â‰  list.nil) : list.chain' R (lâ‚ ++ lâ‚‚ ++ lâ‚ƒ)
theorem quadratic_form.equivalent_sum_squares {M : Type u_1} [add_comm_group M] [module â„‚ M] [finite_dimensional â„‚ M] (Q : quadratic_form â„‚ M) (hQ : (â‡‘quadratic_form.associated Q).nondegenerate) : Q.equivalent (quadratic_form.weighted_sum_squares â„‚ 1)
theorem add_submonoid.localization_map.exists_of_sec_mk' {M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {N : Type u_2} [add_comm_monoid N] (f : S.localization_map N) (x : M) (y : â†¥S) : âˆƒ (c : â†¥S), x + â†‘((f.sec (f.mk' x y)).snd) + â†‘c = (f.sec (f.mk' x y)).fst + â†‘y + â†‘c
theorem affine.simplex.point_eq_affine_combination_of_points_with_circumcenter {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {n : â„•} (s : affine.simplex â„ P n) (i : fin (n + 1)) : s.points i = â‡‘(finset.univ.affine_combination s.points_with_circumcenter) (affine.simplex.point_weights_with_circumcenter i)
theorem finrank_le_one {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] (v : V) (h : âˆ€ (w : V), âˆƒ (c : K), c â€¢ v = w) : finite_dimensional.finrank K V â‰¤ 1
theorem inducing_infi_to_pi {Î¹ : Type u_5} {Ï€ : Î¹ â†’ Type u_6} {X : Type u_1} [Î  (i : Î¹), topological_space (Ï€ i)] (f : Î  (i : Î¹), X â†’ Ï€ i) : inducing (Î» (x : X) (i : Î¹), f i x)
theorem finset.prod_insert_of_eq_one_if_not_mem {Î² : Type u} {Î± : Type v} {s : finset Î±} {a : Î±} {f : Î± â†’ Î²} [comm_monoid Î²] [decidable_eq Î±] (h : a âˆ‰ s â†’ f a = 1) : (has_insert.insert a s).prod (Î» (x : Î±), f x) = s.prod (Î» (x : Î±), f x)
theorem continuous_linear_map.isometry_iff_norm {ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_normed_group E] [semi_normed_group F] [nondiscrete_normed_field ğ•œ] [nondiscrete_normed_field ğ•œâ‚‚] [normed_space ğ•œ E] [normed_space ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} (f : E â†’SL[Ïƒâ‚â‚‚] F) : isometry â‡‘f â†” âˆ€ (x : E), âˆ¥â‡‘f xâˆ¥ = âˆ¥xâˆ¥
theorem phragmen_lindelof.horizontal_strip {E : Type u_1} [normed_group E] [normed_space â„‚ E] {a b C : â„} {f : â„‚ â†’ E} {z : â„‚} (hfd : diff_cont_on_cl â„‚ f (complex.im â»Â¹' set.Ioo a b)) (hB : âˆƒ (c : â„) (H : c < real.pi / (b - a)) (B : â„), f =O[filter.comap (has_abs.abs âˆ˜ complex.re) filter.at_top âŠ“ filter.principal (complex.im â»Â¹' set.Ioo a b)] Î» (z : â„‚), real.exp (B * real.exp (c * |z.re|))) (hle_a : âˆ€ (z : â„‚), z.im = a â†’ âˆ¥f zâˆ¥ â‰¤ C) (hle_b : âˆ€ (z : â„‚), z.im = b â†’ âˆ¥f zâˆ¥ â‰¤ C) (hza : a â‰¤ z.im) (hzb : z.im â‰¤ b) : âˆ¥f zâˆ¥ â‰¤ C
theorem list.dprod_monoid (Î¹ : Type u_1) {R : Type u_2} {Î± : Type u_3} [add_monoid Î¹] [monoid R] (l : list Î±) (fÎ¹ : Î± â†’ Î¹) (fA : Î± â†’ R) : l.dprod fÎ¹ fA = (list.map fA l).prod
theorem algebra.finite_type.iff_quotient_mv_polynomial' {R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] : algebra.finite_type R A â†” âˆƒ (Î¹ : Type u_2) (_x : fintype Î¹) (f : mv_polynomial Î¹ R â†’â‚[R] A), function.surjective â‡‘f
theorem closed_embedding.is_compact_preimage {Î± : Type u} {Î² : Type v} [topological_space Î±] [topological_space Î²] {f : Î± â†’ Î²} (hf : closed_embedding f) {K : set Î²} (hK : is_compact K) : is_compact (f â»Â¹' K)
theorem pullback_nonzero {Mâ‚€ : Type u_1} {Mâ‚€' : Type u_3} [mul_zero_one_class Mâ‚€] [nontrivial Mâ‚€] [has_zero Mâ‚€'] [has_one Mâ‚€'] (f : Mâ‚€' â†’ Mâ‚€) (zero : f 0 = 0) (one : f 1 = 1) : nontrivial Mâ‚€'
theorem is_closed_map_smul_of_ne_zero {Î± : Type u_2} {Gâ‚€ : Type u_4} [topological_space Î±] [group_with_zero Gâ‚€] [mul_action Gâ‚€ Î±] [has_continuous_const_smul Gâ‚€ Î±] {c : Gâ‚€} (hc : c â‰  0) : is_closed_map (Î» (x : Î±), c â€¢ x)
theorem euclidean_geometry.eq_or_eq_reflection_of_dist_eq {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {n : â„•} {s : affine.simplex â„ P n} {p pâ‚ pâ‚‚ : P} {r : â„} (hpâ‚ : pâ‚ âˆˆ affine_span â„ (has_insert.insert p (set.range s.points))) (hpâ‚‚ : pâ‚‚ âˆˆ affine_span â„ (has_insert.insert p (set.range s.points))) (hâ‚ : âˆ€ (i : fin (n + 1)), has_dist.dist (s.points i) pâ‚ = r) (hâ‚‚ : âˆ€ (i : fin (n + 1)), has_dist.dist (s.points i) pâ‚‚ = r) : pâ‚ = pâ‚‚ âˆ¨ pâ‚ = â‡‘(euclidean_geometry.reflection (affine_span â„ (set.range s.points))) pâ‚‚
theorem is_bounded_bilinear_map_comp_multilinear {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {G : Type u_4} [normed_group G] [normed_space ğ•œ G] {Î¹ : Type u_2} {E : Î¹ â†’ Type u_5} [decidable_eq Î¹] [fintype Î¹] [Î  (i : Î¹), normed_group (E i)] [Î  (i : Î¹), normed_space ğ•œ (E i)] : is_bounded_bilinear_map ğ•œ (Î» (p : (F â†’L[ğ•œ] G) Ã— continuous_multilinear_map ğ•œ E F), p.fst.comp_continuous_multilinear_map p.snd)
theorem euclidean_geometry.cospherical_iff_exists_mem_of_finite_dimensional {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace â„ P} {ps : set P} (h : ps âŠ† â†‘s) [nonempty â†¥s] [finite_dimensional â„ â†¥(s.direction)] : euclidean_geometry.cospherical ps â†” âˆƒ (center : P) (H : center âˆˆ s) (radius : â„), âˆ€ (p : P), p âˆˆ ps â†’ has_dist.dist p center = radius
theorem has_fderiv_at_exp {ğ•‚ : Type u_1} {ğ”¸ : Type u_2} [is_R_or_C ğ•‚] [normed_comm_ring ğ”¸] [normed_algebra ğ•‚ ğ”¸] [complete_space ğ”¸] {x : ğ”¸} : has_fderiv_at (exp ğ•‚) (exp ğ•‚ x â€¢ 1) x
theorem mv_polynomial.funext {R : Type u_1} [comm_ring R] [is_domain R] [infinite R] {Ïƒ : Type u_2} {p q : mv_polynomial Ïƒ R} (h : âˆ€ (x : Ïƒ â†’ R), â‡‘(mv_polynomial.eval x) p = â‡‘(mv_polynomial.eval x) q) : p = q
theorem filter.frequently_low_scores {Î² : Type u_4} [linear_order Î²] [no_min_order Î²] {u : â„• â†’ Î²} (hu : filter.tendsto u filter.at_top filter.at_bot) : âˆƒá¶  (n : â„•) in filter.at_top, âˆ€ (k : â„•), k < n â†’ u n < u k
theorem matrix.det_conj {m : Type u} {Î± : Type v} [comm_ring Î±] [fintype m] [decidable_eq m] {M : matrix m m Î±} (h : is_unit M) (N : matrix m m Î±) : ((M.mul N).mul Mâ»Â¹).det = N.det
theorem bounded_continuous_function.exists_extension_norm_eq_of_closed_embedding' {X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] [normal_space Y] (f : bounded_continuous_function X â„) (e : C(X, Y)) (he : closed_embedding â‡‘e) : âˆƒ (g : bounded_continuous_function Y â„), âˆ¥gâˆ¥ = âˆ¥fâˆ¥ âˆ§ g.comp_continuous e = f
theorem mul_eq_mul_iff_eq_and_eq {Î± : Type u_1} [semigroup Î±] [partial_order Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] [covariant_class Î± Î± (function.swap has_mul.mul) has_le.le] [contravariant_class Î± Î± has_mul.mul has_le.le] [contravariant_class Î± Î± (function.swap has_mul.mul) has_le.le] {a b c d : Î±} (hac : a â‰¤ c) (hbd : b â‰¤ d) : a * b = c * d â†” a = c âˆ§ b = d
theorem con.inf_def {M : Type u_1} [has_mul M] {c d : con M} : setoid.r = setoid.r âŠ“ setoid.r
theorem cont_diff_on_succ_iff_has_fderiv_within_at {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {s : set E} {f : E â†’ F} {n : â„•} : cont_diff_on ğ•œ â†‘(n + 1) f s â†” âˆ€ (x : E), x âˆˆ s â†’ (âˆƒ (u : set E) (H : u âˆˆ nhds_within x (has_insert.insert x s)) (f' : E â†’ (E â†’L[ğ•œ] F)), (âˆ€ (x : E), x âˆˆ u â†’ has_fderiv_within_at f (f' x) u x) âˆ§ cont_diff_on ğ•œ â†‘n f' u)
theorem category_theory.strict_initial {C : Type u} [category_theory.category C] {A : C} [category_theory.limits.has_finite_products C] [category_theory.exponentiable A] {I : C} (t : category_theory.limits.is_initial I) (f : A âŸ¶ I) : category_theory.is_iso f
theorem mdifferentiable_on.differentiable_on {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {E' : Type u_3} [normed_group E'] [normed_space ğ•œ E'] {f : E â†’ E'} {s : set E} : mdifferentiable_on (model_with_corners_self ğ•œ E) (model_with_corners_self ğ•œ E') f s â†’ differentiable_on ğ•œ f s
theorem list.split_on_p_first {Î± : Type u} (p : Î± â†’ Prop) [decidable_pred p] (xs : list Î±) (h : âˆ€ (x : Î±), x âˆˆ xs â†’ Â¬p x) (sep : Î±) (hsep : p sep) (as : list Î±) : list.split_on_p p (xs ++ sep :: as) = xs :: list.split_on_p p as
theorem units.dvd_mul_left {Î± : Type u_1} [comm_monoid Î±] {a b : Î±} {u : Î±Ë£} : a âˆ£ â†‘u * b â†” a âˆ£ b
theorem has_sbtw.sbtw.btw {Î± : Type u_1} [circular_preorder Î±] {a b c : Î±} (h : has_sbtw.sbtw a b c) : has_btw.btw a b c
theorem affine.simplex.circumcenter_eq_affine_combination_of_points_with_circumcenter {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {n : â„•} (s : affine.simplex â„ P n) : s.circumcenter = â‡‘(finset.univ.affine_combination s.points_with_circumcenter) (affine.simplex.circumcenter_weights_with_circumcenter n)
theorem is_noetherian_span_of_finite (R : Type u_1) {M : Type u_2} [ring R] [add_comm_group M] [module R M] [is_noetherian_ring R] {A : set M} (hA : A.finite) : is_noetherian R â†¥(submodule.span R A)
theorem set.Ioi_subset_Ici {Î± : Type u_1} [preorder Î±] {a b : Î±} (h : a â‰¤ b) : set.Ioi b âŠ† set.Ici a
theorem finsum_mem_zero {Î± : Type u_1} {M : Type u_5} [add_comm_monoid M] (s : set Î±) : finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), 0)) = 0
theorem has_strict_fderiv_at_exp_zero_of_radius_pos {ğ•‚ : Type u_1} {ğ”¸ : Type u_2} [nondiscrete_normed_field ğ•‚] [normed_ring ğ”¸] [normed_algebra ğ•‚ ğ”¸] [complete_space ğ”¸] (h : 0 < (exp_series ğ•‚ ğ”¸).radius) : has_strict_fderiv_at (exp ğ•‚) 1 0
theorem finset.prod_bij {Î² : Type u} {Î± : Type v} {Î³ : Type w} [comm_monoid Î²] {s : finset Î±} {t : finset Î³} {f : Î± â†’ Î²} {g : Î³ â†’ Î²} (i : Î  (a : Î±), a âˆˆ s â†’ Î³) (hi : âˆ€ (a : Î±) (ha : a âˆˆ s), i a ha âˆˆ t) (h : âˆ€ (a : Î±) (ha : a âˆˆ s), f a = g (i a ha)) (i_inj : âˆ€ (aâ‚ aâ‚‚ : Î±) (haâ‚ : aâ‚ âˆˆ s) (haâ‚‚ : aâ‚‚ âˆˆ s), i aâ‚ haâ‚ = i aâ‚‚ haâ‚‚ â†’ aâ‚ = aâ‚‚) (i_surj : âˆ€ (b : Î³), b âˆˆ t â†’ (âˆƒ (a : Î±) (ha : a âˆˆ s), b = i a ha)) : s.prod (Î» (x : Î±), f x) = t.prod (Î» (x : Î³), g x)
theorem Inf_within_of_ord_connected {Î± : Type u_1} [conditionally_complete_linear_order Î±] {s : set Î±} [hs : s.ord_connected] â¦ƒt : set â†¥sâ¦„ (ht : t.nonempty) (h_bdd : bdd_below t) : has_Inf.Inf (coe '' t) âˆˆ s
theorem algebraic_geometry.LocallyRingedSpace.is_unit_res_to_Î“_Spec_map_basic_open (X : algebraic_geometry.LocallyRingedSpace) (r : â†¥(algebraic_geometry.LocallyRingedSpace.Î“.obj (opposite.op X))) : is_unit (â‡‘(X.to_to_Î“_Spec_map_basic_open r) r)
theorem add_con.ker_lift_mk {M : Type u_1} {P : Type u_3} [add_zero_class M] [add_zero_class P] {f : M â†’+ P} (x : M) : â‡‘(add_con.ker_lift f) â†‘x = â‡‘f x
theorem matrix.pivot.reindex_exists_list_transvec_mul_mul_list_transvec_eq_diagonal {n : Type u_1} {p : Type u_2} {ğ•œ : Type u_3} [field ğ•œ] [decidable_eq n] [decidable_eq p] [fintype n] [fintype p] (M : matrix p p ğ•œ) (e : p â‰ƒ n) (H : âˆƒ (L L' : list (matrix.transvection_struct n ğ•œ)) (D : n â†’ ğ•œ), ((list.map matrix.transvection_struct.to_matrix L).prod.mul (â‡‘(matrix.reindex_alg_equiv ğ•œ e) M)).mul (list.map matrix.transvection_struct.to_matrix L').prod = matrix.diagonal D) : âˆƒ (L L' : list (matrix.transvection_struct p ğ•œ)) (D : p â†’ ğ•œ), ((list.map matrix.transvection_struct.to_matrix L).prod.mul M).mul (list.map matrix.transvection_struct.to_matrix L').prod = matrix.diagonal D
theorem algebraic_geometry.PresheafedSpace.is_iso_of_components {C : Type u} [category_theory.category C] {X Y : algebraic_geometry.PresheafedSpace C} (f : X âŸ¶ Y) [category_theory.is_iso f.base] [category_theory.is_iso f.c] : category_theory.is_iso f
theorem stieltjes_function.length_subadditive_Icc_Ioo (f : stieltjes_function) {a b : â„} {c d : â„• â†’ â„} (ss : set.Icc a b âŠ† â‹ƒ (i : â„•), set.Ioo (c i) (d i)) : ennreal.of_real (â‡‘f b - â‡‘f a) â‰¤ âˆ‘' (i : â„•), ennreal.of_real (â‡‘f (d i) - â‡‘f (c i))
theorem finite_field.trace_to_zmod_nondegenerate (F : Type u_1) [field F] [fintype F] {a : F} (ha : a â‰  0) : âˆƒ (b : F), â‡‘(algebra.trace (zmod (ring_char F)) F) (a * b) â‰  0
theorem CHSH_inequality_of_comm {R : Type u} [ordered_comm_ring R] [star_ordered_ring R] [algebra â„ R] [ordered_smul â„ R] (Aâ‚€ Aâ‚ Bâ‚€ Bâ‚ : R) (T : is_CHSH_tuple Aâ‚€ Aâ‚ Bâ‚€ Bâ‚) : Aâ‚€ * Bâ‚€ + Aâ‚€ * Bâ‚ + Aâ‚ * Bâ‚€ - Aâ‚ * Bâ‚ â‰¤ 2
theorem is_irreducible_iff_sInter {Î± : Type u} [topological_space Î±] {s : set Î±} : is_irreducible s â†” âˆ€ (U : finset (set Î±)), (âˆ€ (u : set Î±), u âˆˆ U â†’ is_open u) â†’ (âˆ€ (u : set Î±), u âˆˆ U â†’ (s âˆ© u).nonempty) â†’ (s âˆ© â‹‚â‚€ â†‘U).nonempty
theorem image_range_order_of {G : Type u} {x : G} [fintype G] [group G] [decidable_eq G] : finset.image (Î» (i : â„•), x ^ i) (finset.range (order_of x)) = â†‘(subgroup.zpowers x).to_finset
theorem add_submonoid.closure_induction {M : Type u_1} [add_zero_class M] {s : set M} {p : M â†’ Prop} {x : M} (h : x âˆˆ add_submonoid.closure s) (Hs : âˆ€ (x : M), x âˆˆ s â†’ p x) (H1 : p 0) (Hmul : âˆ€ (x y : M), p x â†’ p y â†’ p (x + y)) : p x
theorem function.is_periodic_pt.eq_of_apply_eq_same {Î± : Type u_1} {f : Î± â†’ Î±} {x y : Î±} {n : â„•} (hx : function.is_periodic_pt f n x) (hy : function.is_periodic_pt f n y) (hn : 0 < n) (h : f x = f y) : x = y
theorem torsion_eq_torsion_submonoid (G : Type u_1) [comm_group G] : comm_monoid.torsion G = (torsion G).to_submonoid
theorem is_sup_closed_compact.is_Sup_finite_compact (Î± : Type u_1) [complete_lattice Î±] : complete_lattice.is_sup_closed_compact Î± â†’ complete_lattice.is_Sup_finite_compact Î±
theorem finset.prod_powerset {Î± : Type u} {Î² : Type v} [comm_monoid Î²] (s : finset Î±) (f : finset Î± â†’ Î²) : s.powerset.prod (Î» (t : finset Î±), f t) = (finset.range (s.card + 1)).prod (Î» (j : â„•), (finset.powerset_len j s).prod (Î» (t : finset Î±), f t))
theorem free_group.reduce.min {Î± : Type u} {Lâ‚ Lâ‚‚ : list (Î± Ã— bool)} [decidable_eq Î±] (H : free_group.red (free_group.reduce Lâ‚) Lâ‚‚) : free_group.reduce Lâ‚ = Lâ‚‚
theorem measure_theory.is_add_fundamental_domain.mk' {G : Type u_1} {Î± : Type u_2} [add_group G] [add_action G Î±] [measurable_space Î±] {s : set Î±} {Î¼ : measure_theory.measure Î±} (h_meas : measure_theory.null_measurable_set s Î¼) (h_exists : âˆ€ (x : Î±), âˆƒ! (g : G), g +áµ¥ x âˆˆ s) : measure_theory.is_add_fundamental_domain G s Î¼
theorem continuous_map.exists_restrict_eq_of_closed {Y : Type u_2} [topological_space Y] [normal_space Y] {s : set Y} (f : C(â†¥s, â„)) (hs : is_closed s) : âˆƒ (g : C(Y, â„)), continuous_map.restrict s g = f
theorem finsupp.add_sum_erase {Î± : Type u_1} {M : Type u_5} {N : Type u_7} [has_zero M] [add_comm_monoid N] (f : Î± â†’â‚€ M) (y : Î±) (g : Î± â†’ M â†’ N) (hyf : y âˆˆ f.support) : g y (â‡‘f y) + (finsupp.erase y f).sum g = f.sum g
theorem nat.partrec.code.eval_prec_zero (cf cg : nat.partrec.code) (a : â„•) : (cf.prec cg).eval (nat.mkpair a 0) = cf.eval a
theorem ring_hom.map_neg {Î± : Type u_2} {Î² : Type u_3} [non_assoc_ring Î±] [non_assoc_ring Î²] (f : Î± â†’+* Î²) (x : Î±) : â‡‘f (-x) = -â‡‘f x
theorem measure_theory.pdf.real.has_pdf_iff_of_measurable {Î± : Type u_1} {m : measurable_space Î±} {â„™ : measure_theory.measure Î±} [measure_theory.is_finite_measure Â«â„™Â»] {X : Î± â†’ â„} (hX : measurable X) : measure_theory.has_pdf X Â«â„™Â» measure_theory.measure_space.volume â†” (measure_theory.measure.map X Â«â„™Â»).absolutely_continuous measure_theory.measure_space.volume
theorem category_theory.has_colimit_of_created {C : Type uâ‚} [category_theory.category C] {D : Type uâ‚‚} [category_theory.category D] {J : Type w} [category_theory.category J] (K : J â¥¤ C) (F : C â¥¤ D) [category_theory.limits.has_colimit (K â‹™ F)] [category_theory.creates_colimit K F] : category_theory.limits.has_colimit K
theorem integral_sin_mul_cosâ‚‚ {a b : â„} : âˆ« (x : â„) in a..b, real.sin x * real.cos x = (real.cos a ^ 2 - real.cos b ^ 2) / 2
theorem local_homeomorph.has_strict_deriv_at_symm {ğ•œ : Type u} [nondiscrete_normed_field ğ•œ] (f : local_homeomorph ğ•œ ğ•œ) {a f' : ğ•œ} (ha : a âˆˆ f.to_local_equiv.target) (hf' : f' â‰  0) (htff' : has_strict_deriv_at â‡‘f f' (â‡‘(f.symm) a)) : has_strict_deriv_at â‡‘(f.symm) f'â»Â¹ a
theorem linear_equiv.continuous_symm {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] [complete_space F] [complete_space E] (e : E â‰ƒâ‚—[ğ•œ] F) (h : continuous â‡‘e) : continuous â‡‘(e.symm)
theorem norm_image_sub_le_of_norm_deriv_le_segment_01' {E : Type u_1} [normed_group E] [normed_space â„ E] {f f' : â„ â†’ E} {C : â„} (hf : âˆ€ (x : â„), x âˆˆ set.Icc 0 1 â†’ has_deriv_within_at f (f' x) (set.Icc 0 1) x) (bound : âˆ€ (x : â„), x âˆˆ set.Ico 0 1 â†’ âˆ¥f' xâˆ¥ â‰¤ C) : âˆ¥f 1 - f 0âˆ¥ â‰¤ C
theorem quaternion_group.card {n : â„•} [fact (0 < n)] : fintype.card (quaternion_group n) = 4 * n
theorem subset_affine_span (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P) : s âŠ† â†‘(affine_span k s)
theorem cont_diff_at.has_strict_deriv_at' {n : with_top â„•} {ğ•‚ : Type u_6} [is_R_or_C ğ•‚] {F' : Type u_8} [normed_group F'] [normed_space ğ•‚ F'] {f : ğ•‚ â†’ F'} {f' : F'} {x : ğ•‚} (hf : cont_diff_at ğ•‚ n f x) (hf' : has_deriv_at f f' x) (hn : 1 â‰¤ n) : has_strict_deriv_at f f' x
theorem orientation.oangle_add {V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) {x y z : V} (hx : x â‰  0) (hy : y â‰  0) (hz : z â‰  0) : o.oangle x y + o.oangle y z = o.oangle x z
theorem affine_map.coe_mk {k : Type u_1} {V1 : Type u_2} {P1 : Type u_3} {V2 : Type u_4} {P2 : Type u_5} [ring k] [add_comm_group V1] [module k V1] [add_torsor V1 P1] [add_comm_group V2] [module k V2] [add_torsor V2 P2] (f : P1 â†’ P2) (linear : V1 â†’â‚—[k] V2) (add : âˆ€ (p : P1) (v : V1), f (v +áµ¥ p) = â‡‘linear v +áµ¥ f p) : â‡‘{to_fun := f, linear := linear, map_vadd' := add} = f
theorem emetric.inf_edist_le_edist_of_mem {Î± : Type u} [pseudo_emetric_space Î±] {x y : Î±} {s : set Î±} (h : y âˆˆ s) : emetric.inf_edist x s â‰¤ has_edist.edist x y
theorem linear_isometry.norm_to_continuous_linear_map_comp {ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {ğ•œâ‚ƒ : Type u_3} {E : Type u_4} {F : Type u_6} {G : Type u_8} [normed_group E] [normed_group F] [normed_group G] [nondiscrete_normed_field ğ•œ] [nondiscrete_normed_field ğ•œâ‚‚] [nondiscrete_normed_field ğ•œâ‚ƒ] [normed_space ğ•œ E] [normed_space ğ•œâ‚‚ F] [normed_space ğ•œâ‚ƒ G] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} {Ïƒâ‚‚â‚ƒ : ğ•œâ‚‚ â†’+* ğ•œâ‚ƒ} {Ïƒâ‚â‚ƒ : ğ•œ â†’+* ğ•œâ‚ƒ} [ring_hom_comp_triple Ïƒâ‚â‚‚ Ïƒâ‚‚â‚ƒ Ïƒâ‚â‚ƒ] [ring_hom_isometric Ïƒâ‚â‚‚] (f : F â†’â‚›â‚—áµ¢[Ïƒâ‚‚â‚ƒ] G) {g : E â†’SL[Ïƒâ‚â‚‚] F} : âˆ¥f.to_continuous_linear_map.comp gâˆ¥ = âˆ¥gâˆ¥
theorem padic_int.to_zmod_spec {p : â„•} [hp_prime : fact (nat.prime p)] (z : â„¤_[p]) : z - â†‘(â‡‘padic_int.to_zmod z) âˆˆ local_ring.maximal_ideal â„¤_[p]
theorem bilin_form.exists_bilin_form_self_ne_zero {R : Type u_2} {M : Type u_3} [add_comm_group M] [ring R] [module R M] [htwo : invertible 2] {B : bilin_form R M} (hBâ‚ : B â‰  0) (hBâ‚‚ : B.is_symm) : âˆƒ (x : M), Â¬B.is_ortho x x
theorem direct_sum.is_internal.subordinate_orthonormal_basis_subordinate {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] [finite_dimensional ğ•œ E] {n : â„•} (hn : finite_dimensional.finrank ğ•œ E = n) {Î¹ : Type u_4} [fintype Î¹] [decidable_eq Î¹] {V : Î¹ â†’ submodule ğ•œ E} (hV : direct_sum.is_internal V) (a : fin n) : â‡‘(direct_sum.is_internal.subordinate_orthonormal_basis hn hV) a âˆˆ V (direct_sum.is_internal.subordinate_orthonormal_basis_index hn hV a)
theorem is_complemented_of_is_atomistic {Î± : Type u_1} [complete_lattice Î±] [is_modular_lattice Î±] [is_compactly_generated Î±] [is_atomistic Î±] : is_complemented Î±
theorem isometry.closed_embedding {Î± : Type u} {Î² : Type v} [emetric_space Î±] [complete_space Î±] [emetric_space Î²] {f : Î± â†’ Î²} (hf : isometry f) : closed_embedding f
theorem category_theory.over.over_has_terminal {C : Type u} [category_theory.category C] (B : C) : category_theory.limits.has_terminal (category_theory.over B)
theorem pfun.fix_stop {Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’. Î² âŠ• Î±} (a : Î±) {b : Î²} (hb : sum.inl b âˆˆ f a) : b âˆˆ f.fix a
theorem one_smul_eq_id (M : Type u_1) {Î± : Type u_6} [monoid M] [mul_action M Î±] : has_scalar.smul 1 = id
theorem category_theory.subobject.nontrivial_of_not_is_zero {C : Type uâ‚} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] {X : C} (h : Â¬category_theory.limits.is_zero X) : nontrivial (category_theory.subobject X)
theorem filter.tendsto.mul_at_top {Î± : Type u} {Î² : Type v} [linear_ordered_field Î±] [topological_space Î±] [order_topology Î±] {l : filter Î²} {f g : Î² â†’ Î±} {C : Î±} (hC : 0 < C) (hf : filter.tendsto f l (nhds C)) (hg : filter.tendsto g l filter.at_top) : filter.tendsto (Î» (x : Î²), f x * g x) l filter.at_top
theorem is_locally_homeomorph.mk {X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] (f : X â†’ Y) (h : âˆ€ (x : X), âˆƒ (e : local_homeomorph X Y), x âˆˆ e.to_local_equiv.source âˆ§ âˆ€ (x : X), x âˆˆ e.to_local_equiv.source â†’ f x = â‡‘e x) : is_locally_homeomorph f
theorem measure_theory.measure.mk_metric_apply {X : Type u_2} [emetric_space X] [measurable_space X] [borel_space X] (m : ennreal â†’ ennreal) (s : set X) : â‡‘(measure_theory.measure.mk_metric m) s = â¨† (r : ennreal) (hr : 0 < r), â¨… (t : â„• â†’ set X) (h : s âŠ† set.Union t) (h' : âˆ€ (n : â„•), emetric.diam (t n) â‰¤ r), âˆ‘' (n : â„•), â¨† (h : (t n).nonempty), m (emetric.diam (t n))
theorem monoid.is_torsion.torsion_eq_top {G : Type u_1} [comm_monoid G] (tG : monoid.is_torsion G) : comm_monoid.torsion G = âŠ¤
theorem topological_space.exists_embedding_l_infty (X : Type u_2) [topological_space X] [regular_space X] [topological_space.second_countable_topology X] : âˆƒ (f : X â†’ bounded_continuous_function â„• â„), embedding f
theorem category_theory.over.epi_of_epi_left {T : Type uâ‚} [category_theory.category T] {X : T} {f g : category_theory.over X} (k : f âŸ¶ g) [hk : category_theory.epi k.left] : category_theory.epi k
theorem orthonormal.oangle_smul_left_of_pos {V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) (x y : V) {r : â„} (hr : 0 < r) : hb.oangle (r â€¢ x) y = hb.oangle x y
theorem int.exists_greatest_of_bdd {P : â„¤ â†’ Prop} (Hbdd : âˆƒ (b : â„¤), âˆ€ (z : â„¤), P z â†’ z â‰¤ b) (Hinh : âˆƒ (z : â„¤), P z) : âˆƒ (ub : â„¤), P ub âˆ§ âˆ€ (z : â„¤), P z â†’ z â‰¤ ub
theorem polynomial.cyclotomic_zero (R : Type u_1) [ring R] : polynomial.cyclotomic 0 R = 1
theorem setoid.eqv_gen_idem {Î± : Type u_1} (r : Î± â†’ Î± â†’ Prop) : eqv_gen.setoid (eqv_gen.setoid r).rel = eqv_gen.setoid r
theorem subfield.div_mem {K : Type u} [field K] (s : subfield K) {x y : K} : x âˆˆ s â†’ y âˆˆ s â†’ x / y âˆˆ s
theorem law_cos {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] (p1 p2 p3 : P) : has_dist.dist p1 p3 * has_dist.dist p1 p3 = has_dist.dist p1 p2 * has_dist.dist p1 p2 + has_dist.dist p3 p2 * has_dist.dist p3 p2 - 2 * has_dist.dist p1 p2 * has_dist.dist p3 p2 * real.cos (euclidean_geometry.angle p1 p2 p3)
theorem finset.subset_smul {Î± : Type u_2} {Î² : Type u_3} [decidable_eq Î²] [has_scalar Î± Î²] {u : finset Î²} {s : set Î±} {t : set Î²} : â†‘u âŠ† s â€¢ t â†’ (âˆƒ (s' : finset Î±) (t' : finset Î²), â†‘s' âŠ† s âˆ§ â†‘t' âŠ† t âˆ§ u âŠ† s' â€¢ t')
theorem is_irreducible_iff_sUnion_closed {Î± : Type u} [topological_space Î±] {s : set Î±} : is_irreducible s â†” âˆ€ (Z : finset (set Î±)), (âˆ€ (z : set Î±), z âˆˆ Z â†’ is_closed z) â†’ s âŠ† â‹ƒâ‚€â†‘Z â†’ (âˆƒ (z : set Î±) (H : z âˆˆ Z), s âŠ† z)
theorem div_eq_mul_inv {G : Type u_1} [div_inv_monoid G] (a b : G) : a / b = a * bâ»Â¹
theorem multiset.le.subset {Î± : Type u_1} {s t : multiset Î±} : s â‰¤ t â†’ s âŠ† t
theorem Liminf_eq_of_le_nhds {Î± : Type u} [conditionally_complete_linear_order Î±] [topological_space Î±] [order_topology Î±] {f : filter Î±} {a : Î±} [f.ne_bot] (h : f â‰¤ nhds a) : f.Liminf = a
theorem function.periodic.compact_of_continuous {Î± : Type u} [topological_space Î±] {f : â„ â†’ Î±} {c : â„} (hp : function.periodic f c) (hc : c â‰  0) (hf : continuous f) : is_compact (set.range f)
theorem polynomial.chebyshev.T_mul (R : Type u_1) [comm_ring R] (m n : â„•) : polynomial.chebyshev.T R (m * n) = (polynomial.chebyshev.T R m).comp (polynomial.chebyshev.T R n)
theorem category_theory.limits.has_zero_object_of_has_terminal_object {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_terminal C] : category_theory.limits.has_zero_object C
theorem tendsto_pow_neg_at_top {Î± : Type u} [linear_ordered_field Î±] [topological_space Î±] [order_topology Î±] {n : â„•} (hn : 1 â‰¤ n) : filter.tendsto (Î» (x : Î±), x ^ -â†‘n) filter.at_top (nhds 0)
theorem matrix.is_symm_from_blocks_iff {Î± : Type u_1} {n : Type u_3} {m : Type u_4} {A : matrix m m Î±} {B : matrix m n Î±} {C : matrix n m Î±} {D : matrix n n Î±} : (matrix.from_blocks A B C D).is_symm â†” A.is_symm âˆ§ B.transpose = C âˆ§ C.transpose = B âˆ§ D.is_symm
theorem mv_polynomial.ring_hom_ext' {R : Type u} {Ïƒ : Type u_1} [comm_semiring R] {A : Type u_2} [semiring A] {f g : mv_polynomial Ïƒ R â†’+* A} (hC : f.comp mv_polynomial.C = g.comp mv_polynomial.C) (hX : âˆ€ (i : Ïƒ), â‡‘f (mv_polynomial.X i) = â‡‘g (mv_polynomial.X i)) : f = g
theorem finite_field.pow_dichotomy {F : Type u_3} [field F] [fintype F] (hF : ring_char F â‰  2) {a : F} (ha : a â‰  0) : a ^ (fintype.card F / 2) = 1 âˆ¨ a ^ (fintype.card F / 2) = -1
theorem linear_independent_of_ne_zero_of_inner_eq_zero {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {Î¹ : Type u_3} {v : Î¹ â†’ E} (hz : âˆ€ (i : Î¹), v i â‰  0) (ho : âˆ€ (i j : Î¹), i â‰  j â†’ has_inner.inner (v i) (v j) = 0) : linear_independent ğ•œ v
theorem not_is_left_regular_zero {R : Type u_1} [mul_zero_class R] [nR : nontrivial R] : Â¬is_left_regular 0
theorem Top.presheaf.is_sheaf_iff_is_sheaf_comp {C : Type uâ‚} [category_theory.category C] {D : Type uâ‚‚} [category_theory.category D] (G : C â¥¤ D) [category_theory.reflects_isomorphisms G] [category_theory.limits.has_limits C] [category_theory.limits.has_limits D] [category_theory.limits.preserves_limits G] {X : Top} (F : Top.presheaf C X) : F.is_sheaf â†” Top.presheaf.is_sheaf (F â‹™ G)
theorem asymptotics.is_o.bound {Î± : Type u_1} {E : Type u_3} {F : Type u_4} [has_norm E] [has_norm F] {f : Î± â†’ E} {g : Î± â†’ F} {l : filter Î±} : f =o[l] g â†’ âˆ€ â¦ƒc : â„â¦„, 0 < c â†’ (âˆ€á¶  (x : Î±) in l, âˆ¥f xâˆ¥ â‰¤ c * âˆ¥g xâˆ¥)
theorem is_principal_ideal_ring.of_surjective {R : Type u} {S : Type u_1} [ring R] [ring S] [is_principal_ideal_ring R] (f : R â†’+* S) (hf : function.surjective â‡‘f) : is_principal_ideal_ring S
theorem category_theory.is_iso_of_epi_of_split_mono {C : Type uâ‚} [category_theory.category C] {X Y : C} (f : X âŸ¶ Y) [category_theory.split_mono f] [category_theory.epi f] : category_theory.is_iso f
theorem convex_on.map_average_le {Î± : Type u_1} {E : Type u_2} {m0 : measurable_space Î±} [normed_group E] [normed_space â„ E] [complete_space E] {Î¼ : measure_theory.measure Î±} {s : set E} {f : Î± â†’ E} {g : E â†’ â„} [measure_theory.is_finite_measure Î¼] (hg : convex_on â„ s g) (hgc : continuous_on g s) (hsc : is_closed s) (hÎ¼ : Î¼ â‰  0) (hfs : âˆ€áµ (x : Î±) âˆ‚Î¼, f x âˆˆ s) (hfi : measure_theory.integrable f Î¼) (hgi : measure_theory.integrable (g âˆ˜ f) Î¼) : g (â¨ (x : Î±), f x âˆ‚Î¼) â‰¤ â¨ (x : Î±), g (f x) âˆ‚Î¼
theorem equiv.mul_right_symm_apply {G : Type u_10} [group G] (a : G) : â‡‘(equiv.symm (equiv.mul_right a)) = Î» (x : G), x * aâ»Â¹
theorem normal_space_of_regular_second_countable (Î± : Type u) [topological_space Î±] [topological_space.second_countable_topology Î±] [regular_space Î±] : normal_space Î±
theorem metric.Hausdorff_dist_le_of_mem_dist {Î± : Type u} [pseudo_metric_space Î±] {s t : set Î±} {r : â„} (hr : 0 â‰¤ r) (H1 : âˆ€ (x : Î±), x âˆˆ s â†’ (âˆƒ (y : Î±) (H : y âˆˆ t), has_dist.dist x y â‰¤ r)) (H2 : âˆ€ (x : Î±), x âˆˆ t â†’ (âˆƒ (y : Î±) (H : y âˆˆ s), has_dist.dist x y â‰¤ r)) : metric.Hausdorff_dist s t â‰¤ r
theorem euclidean_geometry.orthocentric_system.exists_circumradius_eq {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {s : set P} (ho : euclidean_geometry.orthocentric_system s) : âˆƒ (r : â„), âˆ€ (t : affine.triangle â„ P), set.range t.points âŠ† s â†’ affine.simplex.circumradius t = r
theorem mem_nhds_within_Iic_iff_exists_Ioc_subset {Î± : Type u} [topological_space Î±] [linear_order Î±] [order_topology Î±] [no_min_order Î±] {a : Î±} {s : set Î±} : s âˆˆ nhds_within a (set.Iic a) â†” âˆƒ (l : Î±) (H : l âˆˆ set.Iio a), set.Ioc l a âŠ† s
theorem lie_ideal.subsingleton_of_bot {R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] : subsingleton (lie_ideal R â†¥âŠ¥)
theorem first_order.language.substructure.closure_le {L : first_order.language} {M : Type w} [L.Structure M] {S : L.substructure M} {s : set M} : â‡‘(first_order.language.substructure.closure L) s â‰¤ S â†” s âŠ† â†‘S
theorem subgroup.multiset_prod_mem {G : Type u_1} [comm_group G] (K : subgroup G) (g : multiset G) : (âˆ€ (a : G), a âˆˆ g â†’ a âˆˆ K) â†’ g.prod âˆˆ K
theorem add_monoid.not_is_torsion_iff (G : Type u_1) [add_monoid G] : Â¬add_monoid.is_torsion G â†” âˆƒ (g : G), Â¬is_of_fin_add_order g
theorem fin.monotone_iff_le_succ {n : â„•} {Î± : Type u_1} [preorder Î±] {f : fin (n + 1) â†’ Î±} : monotone f â†” âˆ€ (i : fin n), f (â‡‘fin.cast_succ i) â‰¤ f i.succ
theorem add_monoid_algebra.of'_mem_span {R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_monoid M] [nontrivial R] {m : M} {S : set M} : add_monoid_algebra.of' R M m âˆˆ submodule.span R (add_monoid_algebra.of' R M '' S) â†” m âˆˆ S
theorem finset.weighted_vsub_eq_linear_combination {k : Type u_1} {V : Type u_2} [ring k] [add_comm_group V] [module k V] {Î¹ : Type u_3} (s : finset Î¹) {w : Î¹ â†’ k} {p : Î¹ â†’ V} (hw : s.sum w = 0) : â‡‘(s.weighted_vsub p) w = s.sum (Î» (i : Î¹), w i â€¢ p i)
theorem mem_affine_span_iff_eq_weighted_vsub_of_point_vadd (k : Type u_1) (V : Type u_2) {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {Î¹ : Type u_4} [nontrivial k] (p : Î¹ â†’ P) (j : Î¹) (q : P) : q âˆˆ affine_span k (set.range p) â†” âˆƒ (s : finset Î¹) (w : Î¹ â†’ k), q = â‡‘(s.weighted_vsub_of_point p (p j)) w +áµ¥ p j
theorem is_clopen.bUnion_connected_component_eq {Î± : Type u} [topological_space Î±] {Z : set Î±} (h : is_clopen Z) : (â‹ƒ (x : Î±) (H : x âˆˆ Z), connected_component x) = Z
theorem quadratic_eq_zero_iff_of_discrim_eq_zero {K : Type u_1} [field K] [invertible 2] {a b c : K} (ha : a â‰  0) (h : discrim a b c = 0) (x : K) : a * x * x + b * x + c = 0 â†” x = -b / (2 * a)
theorem norm_mk_lt' {M : Type u_1} [semi_normed_group M] (S : add_subgroup M) (m : M) {Îµ : â„} (hÎµ : 0 < Îµ) : âˆƒ (s : M) (H : s âˆˆ S), âˆ¥m + sâˆ¥ < âˆ¥â‡‘(quotient_add_group.mk' S) mâˆ¥ + Îµ
theorem complex.norm_deriv_le_of_forall_mem_sphere_norm_le {F : Type v} [normed_group F] [normed_space â„‚ F] {c : â„‚} {R C : â„} {f : â„‚ â†’ F} (hR : 0 < R) (hd : diff_cont_on_cl â„‚ f (metric.ball c R)) (hC : âˆ€ (z : â„‚), z âˆˆ metric.sphere c R â†’ âˆ¥f zâˆ¥ â‰¤ C) : âˆ¥deriv f câˆ¥ â‰¤ C / R
theorem affine.simplex.dist_circumcenter_eq_circumradius' {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {n : â„•} (s : affine.simplex â„ P n) (i : fin (n + 1)) : has_dist.dist s.circumcenter (s.points i) = s.circumradius
theorem vadd_vsub_assoc {G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] (g : G) (p1 p2 : P) : g +áµ¥ p1 -áµ¥ p2 = g + (p1 -áµ¥ p2)
theorem formal_multilinear_series.comp_right_inv {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] (p : formal_multilinear_series ğ•œ E F) (i : E â‰ƒL[ğ•œ] F) (h : p 1 = â‡‘((continuous_multilinear_curry_fin1 ğ•œ E F).symm) â†‘i) (h0 : p 0 = 0) : p.comp (p.right_inv i) = formal_multilinear_series.id ğ•œ F
theorem complex.linear_equiv_det_conj_ae  : â‡‘linear_equiv.det complex.conj_ae.to_linear_equiv = -1
theorem padic_val_nat.pow (p q n : â„•) [fact (nat.prime p)] (hq : q â‰  0) : padic_val_nat p (q ^ n) = n * padic_val_nat p q
theorem is_primitive_root.sub_one_norm_two {K : Type u} {L : Type v} [field L] {Î¶ : L} [field K] [algebra K L] [ne_zero 2] {k : â„•} (hÎ¶ : is_primitive_root Î¶ (2 ^ k)) (hk : 2 â‰¤ k) [H : is_cyclotomic_extension {2 ^ k} K L] (hirr : irreducible (polynomial.cyclotomic (2 ^ k) K)) : â‡‘(algebra.norm K) (Î¶ - 1) = 2
theorem module.End.has_generalized_eigenvalue_of_has_generalized_eigenvalue_of_le {R : Type v} {M : Type w} [comm_ring R] [add_comm_group M] [module R M] {f : module.End R M} {Î¼ : R} {k m : â„•} (hm : k â‰¤ m) (hk : f.has_generalized_eigenvalue Î¼ k) : f.has_generalized_eigenvalue Î¼ m
theorem matrix.mul_inv_of_self_assoc {m : Type u} {n : Type u'} {Î± : Type v} [fintype n] [decidable_eq n] [comm_ring Î±] (A : matrix n n Î±) (B : matrix n m Î±) [invertible A] : A.mul ((â…Ÿ A).mul B) = B
theorem tangent_map_chart_symm {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] (I : model_with_corners ğ•œ E H) {M : Type u_4} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {p : tangent_bundle I M} {q : tangent_bundle I H} (h : q.fst âˆˆ (charted_space.chart_at H p.fst).to_local_equiv.target) : tangent_map I I â‡‘((charted_space.chart_at H p.fst).symm) q = â‡‘((charted_space.chart_at (model_prod H E) p).symm) (â‡‘(equiv.sigma_equiv_prod H E) q)
theorem lattice_ordered_comm_group.pos_of_one_le {Î± : Type u} [lattice Î±] [comm_group Î±] (a : Î±) (h : 1 â‰¤ a) : aâº = a
theorem generalized_continued_fraction.of_correctness_at_top_of_terminates {K : Type u_1} [linear_ordered_field K] {v : K} [floor_ring K] (terminates : (generalized_continued_fraction.of v).terminates) : âˆ€á¶  (n : â„•) in filter.at_top, v = (generalized_continued_fraction.of v).convergents n
theorem equiv.mul_left_symm_apply {G : Type u_10} [group G] (a : G) : â‡‘(equiv.symm (equiv.mul_left a)) = has_mul.mul aâ»Â¹
theorem multiset_prod_mem {B : Type u_3} {S : B} {M : Type u_1} [comm_monoid M] [set_like B M] [submonoid_class B M] (m : multiset M) (hm : âˆ€ (a : M), a âˆˆ m â†’ a âˆˆ S) : m.prod âˆˆ S
theorem linear_ordered_comm_group_with_zero.has_basis_nhds_zero {Î“â‚€ : Type u_1} [linear_ordered_comm_group_with_zero Î“â‚€] : (nhds 0).has_basis (Î» (_x : Î“â‚€Ë£), true) (Î» (Î³â‚€ : Î“â‚€Ë£), {Î³ : Î“â‚€ | Î³ < â†‘Î³â‚€})
theorem complex.has_strict_deriv_at_sinh (x : â„‚) : has_strict_deriv_at complex.sinh (complex.cosh x) x
theorem linear_map.comp_eq_id_comm {K : Type u} {V : Type v} [field K] [add_comm_group V] [module K V] [finite_dimensional K V] {f g : V â†’â‚—[K] V} : f.comp g = linear_map.id â†” g.comp f = linear_map.id
theorem polynomial.cyclotomic_eq_prod_X_pow_sub_one_pow_moebius {n : â„•} (R : Type u_1) [comm_ring R] [is_domain R] : â‡‘(algebra_map (polynomial R) (ratfunc R)) (polynomial.cyclotomic n R) = n.divisors_antidiagonal.prod (Î» (i : â„• Ã— â„•), â‡‘(algebra_map (polynomial R) (ratfunc R)) (polynomial.X ^ i.snd - 1) ^ â‡‘nat.arithmetic_function.moebius i.fst)
theorem category_theory.is_iso_of_epi_of_strong_mono {C : Type u} [category_theory.category C] {P Q : C} (f : P âŸ¶ Q) [category_theory.epi f] [category_theory.strong_mono f] : category_theory.is_iso f
theorem order.ideal.sup_mem {P : Type u_1} [semilattice_sup P] {x y : P} {s : order.ideal P} (hx : x âˆˆ s) (hy : y âˆˆ s) : x âŠ” y âˆˆ s
theorem colex.lt_singleton_iff_mem_lt {Î± : Type u_1} [linear_order Î±] {r : Î±} {s : finset Î±} : s.to_colex < {r}.to_colex â†” âˆ€ (x : Î±), x âˆˆ s â†’ x < r
theorem measure_theory.continuous_integral_integral {Î± : Type u_1} {Î² : Type u_3} {E : Type u_6} [measurable_space Î±] [measurable_space Î²] {Î¼ : measure_theory.measure Î±} {Î½ : measure_theory.measure Î²} [normed_group E] [measure_theory.sigma_finite Î½] [normed_space â„ E] [complete_space E] [measure_theory.sigma_finite Î¼] : continuous (Î» (f : â†¥(measure_theory.Lp E 1 (Î¼.prod Î½))), âˆ« (x : Î±), âˆ« (y : Î²), â‡‘f (x, y) âˆ‚Î½ âˆ‚Î¼)
theorem local_equiv.is_image.of_preimage_eq {Î± : Type u_1} {Î² : Type u_2} {e : local_equiv Î± Î²} {s : set Î±} {t : set Î²} : e.source âˆ© â‡‘e â»Â¹' t = e.source âˆ© s â†’ e.is_image s t
theorem metric.Hausdorff_dist_comm {Î± : Type u} [pseudo_metric_space Î±] {s t : set Î±} : metric.Hausdorff_dist s t = metric.Hausdorff_dist t s
theorem category_theory.sheaf.is_sheaf_yoneda_obj {C : Type u} [category_theory.category C] (X : C) : category_theory.presieve.is_sheaf (category_theory.sheaf.canonical_topology C) (category_theory.yoneda.obj X)
theorem add_monoid_hom.map_add_neg {Î± : Type u_1} {Î² : Type u_2} [add_group Î±] [subtraction_monoid Î²] (f : Î± â†’+ Î²) (g h : Î±) : â‡‘f (g + -h) = â‡‘f g + -â‡‘f h
theorem measure_theory.mem_Lp_meas_subgroup_to_Lp_of_trim {Î± : Type u_1} {F : Type u_6} {p : ennreal} [normed_group F] {m m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (hm : m â‰¤ m0) (f : â†¥(measure_theory.Lp F p (Î¼.trim hm))) : measure_theory.mem_â„’p.to_Lp â‡‘f _ âˆˆ measure_theory.Lp_meas_subgroup F m p Î¼
theorem is_free_groupoid.spanning_tree.loop_of_hom_eq_id {G : Type u} [category_theory.groupoid G] [is_free_groupoid G] (T : wide_subquiver (quiver.symmetrify (is_free_groupoid.generators G))) [quiver.arborescence â†¥T] {a b : is_free_groupoid.generators G} (e : a âŸ¶ b) (H : e âˆˆ quiver.wide_subquiver_symmetrify T a b) : is_free_groupoid.spanning_tree.loop_of_hom T (is_free_groupoid.of e) = ğŸ™ (root' T)
theorem lipschitz_on_with.extend_pi {Î± : Type u} {Î¹ : Type x} [pseudo_metric_space Î±] [fintype Î¹] {f : Î± â†’ Î¹ â†’ â„} {s : set Î±} {K : nnreal} (hf : lipschitz_on_with K f s) : âˆƒ (g : Î± â†’ Î¹ â†’ â„), lipschitz_with K g âˆ§ set.eq_on f g s
theorem tsum_sq_fourier_series_repr (f : â†¥(measure_theory.Lp â„‚ 2 haar_circle)) : âˆ‘' (i : â„¤), âˆ¥â‡‘(â‡‘(fourier_series.repr) f) iâˆ¥ ^ 2 = âˆ« (t : â†¥circle), âˆ¥â‡‘f tâˆ¥ ^ 2 âˆ‚haar_circle
theorem con.mul_ker_mk_eq {M : Type u_1} [has_mul M] (c : con M) : con.mul_ker coe _ = c
theorem continuous_map.tendsto_of_tendsto_locally_uniformly {Î± : Type uâ‚} {Î² : Type uâ‚‚} [topological_space Î±] [uniform_space Î²] {f : C(Î±, Î²)} {Î¹ : Type uâ‚ƒ} {p : filter Î¹} {F : Î¹ â†’ C(Î±, Î²)} (h : tendsto_locally_uniformly (Î» (i : Î¹) (a : Î±), â‡‘(F i) a) â‡‘f p) : filter.tendsto F p (nhds f)
theorem normed_ring.inverse_add_norm {R : Type u_1} [normed_ring R] [complete_space R] (x : RË£) : (Î» (t : R), ring.inverse (â†‘x + t)) =O[nhds 0] Î» (t : R), 1
theorem same_ray_pos_smul_left {R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] (v : M) {r : R} (h : 0 < r) : same_ray R (r â€¢ v) v
theorem category_theory.prod_id (C : Type uâ‚) [category_theory.category C] (D : Type uâ‚‚) [category_theory.category D] (X : C) (Y : D) : ğŸ™ (X, Y) = (ğŸ™ X, ğŸ™ Y)
theorem finsupp.sum_inner {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {Î¹ : Type u_3} (l : Î¹ â†’â‚€ ğ•œ) (v : Î¹ â†’ E) (x : E) : has_inner.inner (l.sum (Î» (i : Î¹) (a : ğ•œ), a â€¢ v i)) x = l.sum (Î» (i : Î¹) (a : ğ•œ), â‡‘(star_ring_end ğ•œ) a â€¢ has_inner.inner (v i) x)
theorem zmod.ring_char_zmod_n (n : â„•) : ring_char (zmod n) = n
theorem real.map_matrix_volume_pi_eq_smul_volume_pi {Î¹ : Type u_1} [fintype Î¹] [decidable_eq Î¹] {M : matrix Î¹ Î¹ â„} (hM : M.det â‰  0) : measure_theory.measure.map â‡‘(â‡‘matrix.to_lin' M) measure_theory.measure_space.volume = ennreal.of_real |(M.det)â»Â¹| â€¢ measure_theory.measure_space.volume
theorem measure_theory.is_fundamental_domain.smul_invariant_measure_map {G : Type u_1} [group G] [measurable_space G] [topological_space G] [topological_group G] [borel_space G] {Î¼ : measure_theory.measure G} {Î“ : subgroup G} {ğ“• : set G} (hğ“• : measure_theory.is_fundamental_domain â†¥(Î“.opposite) ğ“• Î¼) [encodable â†¥Î“] [measurable_space (G â§¸ Î“)] [borel_space (G â§¸ Î“)] [Î¼.is_mul_left_invariant] [Î¼.is_mul_right_invariant] : measure_theory.smul_invariant_measure G (G â§¸ Î“) (measure_theory.measure.map quotient_group.mk (Î¼.restrict ğ“•))
theorem is_preconnected.mem_intervals {Î± : Type u} [conditionally_complete_linear_order Î±] [topological_space Î±] [order_topology Î±] {s : set Î±} (hs : is_preconnected s) : s âˆˆ {set.Icc (has_Inf.Inf s) (has_Sup.Sup s), set.Ico (has_Inf.Inf s) (has_Sup.Sup s), set.Ioc (has_Inf.Inf s) (has_Sup.Sup s), set.Ioo (has_Inf.Inf s) (has_Sup.Sup s), set.Ici (has_Inf.Inf s), set.Ioi (has_Inf.Inf s), set.Iic (has_Sup.Sup s), set.Iio (has_Sup.Sup s), set.univ, âˆ…}
theorem ennreal.to_nnreal_sum {Î± : Type u_1} {s : finset Î±} {f : Î± â†’ ennreal} (hf : âˆ€ (a : Î±), a âˆˆ s â†’ f a â‰  âŠ¤) : (s.sum (Î» (a : Î±), f a)).to_nnreal = s.sum (Î» (a : Î±), (f a).to_nnreal)
theorem eventually_residual {Î± : Type u_1} [topological_space Î±] [baire_space Î±] {p : Î± â†’ Prop} : (âˆ€á¶  (x : Î±) in residual Î±, p x) â†” âˆƒ (t : set Î±), is_GÎ´ t âˆ§ dense t âˆ§ âˆ€ (x : Î±), x âˆˆ t â†’ p x
theorem category_theory.simplicial_object.Î´_comp_Î´ {C : Type u} [category_theory.category C] (X : category_theory.simplicial_object C) {n : â„•} {i j : fin (n + 2)} (H : i â‰¤ j) : X.Î´ j.succ â‰« X.Î´ i = X.Î´ (â‡‘fin.cast_succ i) â‰« X.Î´ j
theorem finset.centroid_eq_of_inj_on_of_image_eq (k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] {Î¹ : Type u_4} (s : finset Î¹) {Î¹â‚‚ : Type u_5} (sâ‚‚ : finset Î¹â‚‚) {p : Î¹ â†’ P} (hi : âˆ€ (i : Î¹), i âˆˆ s â†’ âˆ€ (j : Î¹), j âˆˆ s â†’ p i = p j â†’ i = j) {pâ‚‚ : Î¹â‚‚ â†’ P} (hiâ‚‚ : âˆ€ (i : Î¹â‚‚), i âˆˆ sâ‚‚ â†’ âˆ€ (j : Î¹â‚‚), j âˆˆ sâ‚‚ â†’ pâ‚‚ i = pâ‚‚ j â†’ i = j) (he : p '' â†‘s = pâ‚‚ '' â†‘sâ‚‚) : finset.centroid k s p = finset.centroid k sâ‚‚ pâ‚‚
theorem cont_mdiff_on.comp' {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners ğ•œ E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] {f : M â†’ M'} {s : set M} {n : with_top â„•} {E'' : Type u_14} [normed_group E''] [normed_space ğ•œ E''] {H'' : Type u_15} [topological_space H''] {I'' : model_with_corners ğ•œ E'' H''} {M'' : Type u_16} [topological_space M''] [charted_space H'' M''] {t : set M'} {g : M' â†’ M''} (hg : cont_mdiff_on I' I'' n g t) (hf : cont_mdiff_on I I' n f s) : cont_mdiff_on I I'' n (g âˆ˜ f) (s âˆ© f â»Â¹' t)
theorem subgroup.normal_mul {G : Type u_1} [group G] (N H : subgroup G) [N.normal] : â†‘(N âŠ” H) = â†‘N * â†‘H
theorem pi.mul_single_apply {I : Type u} [decidable_eq I] {Î² : Type u_1} [has_one Î²] (i : I) (x : Î²) (i' : I) : pi.mul_single i x i' = ite (i' = i) x 1
theorem tendsto_of_no_upcrossings {Î± : Type u} {Î² : Type v} [conditionally_complete_linear_order Î±] [topological_space Î±] [order_topology Î±] [densely_ordered Î±] {f : filter Î²} {u : Î² â†’ Î±} {s : set Î±} (hs : dense s) (H : âˆ€ (a : Î±), a âˆˆ s â†’ âˆ€ (b : Î±), b âˆˆ s â†’ a < b â†’ Â¬((âˆƒá¶  (n : Î²) in f, u n < a) âˆ§ âˆƒá¶  (n : Î²) in f, b < u n)) (h : filter.is_bounded_under has_le.le f u . "is_bounded_default") (h' : filter.is_bounded_under ge f u . "is_bounded_default") : âˆƒ (c : Î±), filter.tendsto u f (nhds c)
theorem is_noetherian.disjoint_partial_sups_eventually_bot {R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] [I : is_noetherian R M] (f : â„• â†’ submodule R M) (h : âˆ€ (n : â„•), disjoint (â‡‘(partial_sups f) n) (f (n + 1))) : âˆƒ (n : â„•), âˆ€ (m : â„•), n â‰¤ m â†’ f m = âŠ¥
theorem strict_anti_on.dual_right {Î± : Type u} {Î² : Type v} [preorder Î±] [preorder Î²] {f : Î± â†’ Î²} {s : set Î±} : strict_anti_on f s â†’ strict_mono_on (â‡‘order_dual.to_dual âˆ˜ f) s
theorem subring.sum_mem {R : Type u_1} [ring R] (s : subring R) {Î¹ : Type u_2} {t : finset Î¹} {f : Î¹ â†’ R} (h : âˆ€ (c : Î¹), c âˆˆ t â†’ f c âˆˆ s) : t.sum (Î» (i : Î¹), f i) âˆˆ s
theorem embedding.comp_strongly_measurable_iff {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} {m : measurable_space Î±} [topological_space Î²] [topological_space.pseudo_metrizable_space Î²] [topological_space Î³] [topological_space.pseudo_metrizable_space Î³] {g : Î² â†’ Î³} {f : Î± â†’ Î²} (hg : embedding g) : measure_theory.strongly_measurable (Î» (x : Î±), g (f x)) â†” measure_theory.strongly_measurable f
theorem algebra.norm_algebra_map {K : Type u_4} {L : Type u_5} [field K] [field L] [algebra K L] (x : K) : â‡‘(algebra.norm K) (â‡‘(algebra_map K L) x) = x ^ finite_dimensional.finrank K L
theorem fin.cast_eq_cast' {n m : â„•} (h : fin n = fin m) : cast h = â‡‘(fin.cast _)
theorem im_inner_eq_norm_sub_I_smul_mul_self_sub_norm_add_I_smul_mul_self_div_four {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] (x y : E) : â‡‘is_R_or_C.im (has_inner.inner x y) = (âˆ¥x - is_R_or_C.I â€¢ yâˆ¥ * âˆ¥x - is_R_or_C.I â€¢ yâˆ¥ - âˆ¥x + is_R_or_C.I â€¢ yâˆ¥ * âˆ¥x + is_R_or_C.I â€¢ yâˆ¥) / 4
theorem nat.div_lt_self' (n b : â„•) : (n + 1) / (b + 2) < n + 1
theorem preimage_connected_component_connected {Î± : Type u} {Î² : Type v} [topological_space Î±] [topological_space Î²] {f : Î± â†’ Î²} (connected_fibers : âˆ€ (t : Î²), is_connected (f â»Â¹' {t})) (hcl : âˆ€ (T : set Î²), is_closed T â†” is_closed (f â»Â¹' T)) (t : Î²) : is_connected (f â»Â¹' connected_component t)
theorem centroid_mem_affine_span_of_card_ne_zero (k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] {Î¹ : Type u_4} [char_zero k] {s : finset Î¹} (p : Î¹ â†’ P) (h : s.card â‰  0) : finset.centroid k s p âˆˆ affine_span k (set.range p)
theorem submodule.span_coe_eq_restrict_scalars {R : Type u_1} {M : Type u_4} {S : Type u_7} [semiring R] [add_comm_monoid M] [module R M] (p : submodule R M) [semiring S] [has_scalar S R] [module S M] [is_scalar_tower S R M] : submodule.span S â†‘p = submodule.restrict_scalars S p
theorem module.End.has_eigenvalue_of_has_generalized_eigenvalue {R : Type v} {M : Type w} [comm_ring R] [add_comm_group M] [module R M] {f : module.End R M} {Î¼ : R} {k : â„•} (hÎ¼ : f.has_generalized_eigenvalue Î¼ k) : f.has_eigenvalue Î¼
theorem volume_region_between_eq_integral {Î± : Type u_1} [measurable_space Î±] {Î¼ : measure_theory.measure Î±} {f g : Î± â†’ â„} {s : set Î±} [measure_theory.sigma_finite Î¼] (f_int : measure_theory.integrable_on f s Î¼) (g_int : measure_theory.integrable_on g s Î¼) (hs : measurable_set s) (hfg : âˆ€ (x : Î±), x âˆˆ s â†’ f x â‰¤ g x) : â‡‘(Î¼.prod measure_theory.measure_space.volume) (region_between f g s) = ennreal.of_real (âˆ« (y : Î±) in s, (g - f) y âˆ‚Î¼)
theorem intermediate_field.list_sum_mem {K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) {l : list L} : (âˆ€ (x : L), x âˆˆ l â†’ x âˆˆ S) â†’ l.sum âˆˆ S
theorem inner_product_geometry.angle_neg_neg {V : Type u_1} [inner_product_space â„ V] (x y : V) : inner_product_geometry.angle (-x) (-y) = inner_product_geometry.angle x y
theorem category_theory.presieve.is_separated_for_and_exists_is_amalgamation_iff_sheaf_for {C : Type uâ‚} [category_theory.category C] {P : Cáµ’áµ– â¥¤ Type w} {X : C} {R : category_theory.presieve X} : (category_theory.presieve.is_separated_for P R âˆ§ âˆ€ (x : category_theory.presieve.family_of_elements P R), x.compatible â†’ (âˆƒ (t : P.obj (opposite.op X)), x.is_amalgamation t)) â†” category_theory.presieve.is_sheaf_for P R
theorem finset.filter_eq {Î² : Type u_2} [decidable_eq Î²] (s : finset Î²) (b : Î²) : finset.filter (eq b) s = ite (b âˆˆ s) {b} âˆ…
theorem add_group_filter_basis.uniform_add_group {G : Type u_1} [add_comm_group G] (B : add_group_filter_basis G) : uniform_add_group G
theorem interval_integral.integral_lt_integral_of_continuous_on_of_le_of_exists_lt {f g : â„ â†’ â„} {a b : â„} (hab : a < b) (hfc : continuous_on f (set.Icc a b)) (hgc : continuous_on g (set.Icc a b)) (hle : âˆ€ (x : â„), x âˆˆ set.Ioc a b â†’ f x â‰¤ g x) (hlt : âˆƒ (c : â„) (H : c âˆˆ set.Icc a b), f c < g c) : âˆ« (x : â„) in a..b, f x < âˆ« (x : â„) in a..b, g x
theorem con.lift_funext {M : Type u_1} {P : Type u_3} [mul_one_class M] [mul_one_class P] {c : con M} (f g : c.quotient â†’* P) (h : âˆ€ (a : M), â‡‘f â†‘a = â‡‘g â†‘a) : f = g
theorem box_integral.box.subbox_induction_on {Î¹ : Type u_1} [fintype Î¹] {p : box_integral.box Î¹ â†’ Prop} (I : box_integral.box Î¹) (H_ind : âˆ€ (J : box_integral.box Î¹), J â‰¤ I â†’ (âˆ€ (J' : box_integral.box Î¹), J' âˆˆ box_integral.prepartition.split_center J â†’ p J') â†’ p J) (H_nhds : âˆ€ (z : Î¹ â†’ â„), z âˆˆ â‡‘box_integral.box.Icc I â†’ (âˆƒ (U : set (Î¹ â†’ â„)) (H : U âˆˆ nhds_within z (â‡‘box_integral.box.Icc I)), âˆ€ (J : box_integral.box Î¹), J â‰¤ I â†’ âˆ€ (m : â„•), z âˆˆ â‡‘box_integral.box.Icc J â†’ â‡‘box_integral.box.Icc J âŠ† U â†’ (âˆ€ (i : Î¹), J.upper i - J.lower i = (I.upper i - I.lower i) / 2 ^ m) â†’ p J)) : p I
theorem euclidean_geometry.inter_eq_singleton_orthogonal_projection {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace â„ P} [nonempty â†¥s] [complete_space â†¥(s.direction)] (p : P) : â†‘s âˆ© â†‘(affine_subspace.mk' p (s.direction)á—®) = {â†‘(â‡‘(euclidean_geometry.orthogonal_projection s) p)}
theorem antilipschitz_with.subsingleton {Î± : Type u_1} {Î² : Type u_2} [emetric_space Î±] [pseudo_emetric_space Î²] {f : Î± â†’ Î²} (h : antilipschitz_with 0 f) : subsingleton Î±
theorem is_artinian.exists_endomorphism_iterate_ker_sup_range_eq_top {R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] [I : is_artinian R M] (f : M â†’â‚—[R] M) : âˆƒ (n : â„•), n â‰  0 âˆ§ (f ^ n).ker âŠ” (f ^ n).range = âŠ¤
theorem mul_is_right_regular_iff {R : Type u_1} {a : R} [semigroup R] (b : R) (ha : is_right_regular a) : is_right_regular (b * a) â†” is_right_regular b
theorem lebesgue_number_lemma {Î± : Type u} [uniform_space Î±] {s : set Î±} {Î¹ : Sort u_1} {c : Î¹ â†’ set Î±} (hs : is_compact s) (hcâ‚ : âˆ€ (i : Î¹), is_open (c i)) (hcâ‚‚ : s âŠ† â‹ƒ (i : Î¹), c i) : âˆƒ (n : set (Î± Ã— Î±)) (H : n âˆˆ uniformity Î±), âˆ€ (x : Î±), x âˆˆ s â†’ (âˆƒ (i : Î¹), {y : Î± | (x, y) âˆˆ n} âŠ† c i)
theorem orthonormal.oangle_eq_iff_eq_pos_smul_rotation_or_eq_zero {V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) {x y : V} (Î¸ : real.angle) : hb.oangle x y = Î¸ â†” (x â‰  0 âˆ§ y â‰  0 âˆ§ âˆƒ (r : â„), 0 < r âˆ§ y = r â€¢ â‡‘(hb.rotation Î¸) x) âˆ¨ Î¸ = 0 âˆ§ (x = 0 âˆ¨ y = 0)
theorem interval_integral.has_sum_integral_of_dominated_convergence {E : Type u_3} [normed_group E] [complete_space E] [normed_space â„ E] {a b : â„} {f : â„ â†’ E} {Î¼ : measure_theory.measure â„} {Î¹ : Type u_1} [encodable Î¹] {F : Î¹ â†’ â„ â†’ E} (bound : Î¹ â†’ â„ â†’ â„) (hF_meas : âˆ€ (n : Î¹), measure_theory.ae_strongly_measurable (F n) (Î¼.restrict (set.interval_oc a b))) (h_bound : âˆ€ (n : Î¹), âˆ€áµ (t : â„) âˆ‚Î¼, t âˆˆ set.interval_oc a b â†’ âˆ¥F n tâˆ¥ â‰¤ bound n t) (bound_summable : âˆ€áµ (t : â„) âˆ‚Î¼, t âˆˆ set.interval_oc a b â†’ summable (Î» (n : Î¹), bound n t)) (bound_integrable : interval_integrable (Î» (t : â„), âˆ‘' (n : Î¹), bound n t) Î¼ a b) (h_lim : âˆ€áµ (t : â„) âˆ‚Î¼, t âˆˆ set.interval_oc a b â†’ has_sum (Î» (n : Î¹), F n t) (f t)) : has_sum (Î» (n : Î¹), âˆ« (t : â„) in a..b, F n t âˆ‚Î¼) (âˆ« (t : â„) in a..b, f t âˆ‚Î¼)
theorem zmod.card_units_eq_totient (n : â„•) [fact (0 < n)] [fintype (zmod n)Ë£] : fintype.card (zmod n)Ë£ = n.totient
theorem intermediate_field.finite_dimensional_bot (K : Type u_1) (L : Type u_2) [field K] [field L] [algebra K L] : finite_dimensional K â†¥âŠ¥
theorem norm_sub_sq {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {x y : E} : âˆ¥x - yâˆ¥ ^ 2 = âˆ¥xâˆ¥ ^ 2 - 2 * â‡‘is_R_or_C.re (has_inner.inner x y) + âˆ¥yâˆ¥ ^ 2
theorem sup_sdiff_inj_on {Î± : Type u_1} [generalized_boolean_algebra Î±] (u v : Î±) : set.inj_on (Î» (x : Î±), (x âŠ” u)  v) {x : Î± | disjoint u x âˆ§ v â‰¤ x}
theorem filter.high_scores {Î² : Type u_4} [linear_order Î²] [no_max_order Î²] {u : â„• â†’ Î²} (hu : filter.tendsto u filter.at_top filter.at_top) (N : â„•) : âˆƒ (n : â„•) (H : n â‰¥ N), âˆ€ (k : â„•), k < n â†’ u k < u n
theorem is_adic_iff {R : Type u_1} [comm_ring R] [top : topological_space R] [topological_ring R] {J : ideal R} : is_adic J â†” (âˆ€ (n : â„•), is_open â†‘(J ^ n)) âˆ§ âˆ€ (s : set R), s âˆˆ nhds 0 â†’ (âˆƒ (n : â„•), â†‘(J ^ n) âŠ† s)
theorem measure_theory.measure.hausdorff_measure_mono {X : Type u_2} [emetric_space X] [measurable_space X] [borel_space X] {dâ‚ dâ‚‚ : â„} (h : dâ‚ â‰¤ dâ‚‚) (s : set X) : â‡‘(measure_theory.measure.hausdorff_measure dâ‚‚) s â‰¤ â‡‘(measure_theory.measure.hausdorff_measure dâ‚) s
theorem commute.mul_self_sub_mul_self_eq {R : Type x} [non_unital_non_assoc_ring R] {a b : R} (h : commute a b) : a * a - b * b = (a + b) * (a - b)
theorem has_fderiv_at.le_of_lip' {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {f : E â†’ F} {f' : E â†’L[ğ•œ] F} {xâ‚€ : E} (hf : has_fderiv_at f f' xâ‚€) {C : â„} (hCâ‚€ : 0 â‰¤ C) (hlip : âˆ€á¶  (x : E) in nhds xâ‚€, âˆ¥f x - f xâ‚€âˆ¥ â‰¤ C * âˆ¥x - xâ‚€âˆ¥) : âˆ¥f'âˆ¥ â‰¤ C
theorem vector_span_range_eq_span_range_vsub_left_ne (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {Î¹ : Type u_4} (p : Î¹ â†’ P) (iâ‚€ : Î¹) : vector_span k (set.range p) = submodule.span k (set.range (Î» (i : {x // x â‰  iâ‚€}), p iâ‚€ -áµ¥ p â†‘i))
theorem orientation.oangle_neg_self_left {V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) {x : V} (hx : x â‰  0) : o.oangle (-x) x = â†‘real.pi
theorem subgroup.exists_right_complement'_of_coprime {G : Type u} [group G] {N : subgroup G} [N.normal] (hN : (nat.card â†¥N).coprime N.index) : âˆƒ (H : subgroup G), N.is_complement' H
theorem bdd_below.mono {Î± : Type u} [preorder Î±] â¦ƒs t : set Î±â¦„ (h : s âŠ† t) : bdd_below t â†’ bdd_below s
theorem fourier_subalgebra_coe  : fourier_subalgebra.to_submodule = submodule.span â„‚ (set.range fourier)
theorem box_integral.has_integral_McShane_of_forall_is_o {Î¹ : Type u} {E : Type v} {F : Type w} [normed_group E] [normed_space â„ E] [normed_group F] [normed_space â„ F] {I : box_integral.box Î¹} [fintype Î¹] {f : (Î¹ â†’ â„) â†’ E} {vol : box_integral.box_additive_map Î¹ (E â†’L[â„] F) âŠ¤} (B : box_integral.box_additive_map Î¹ â„ â†‘I) (hB0 : âˆ€ (J : box_integral.box Î¹), 0 â‰¤ â‡‘B J) (g : box_integral.box_additive_map Î¹ F â†‘I) (H : nnreal â†’ âˆ€ (x : Î¹ â†’ â„), x âˆˆ â‡‘box_integral.box.Icc I â†’ âˆ€ (Îµ : â„), Îµ > 0 â†’ (âˆƒ (Î´ : â„) (H : Î´ > 0), âˆ€ (J : box_integral.box Î¹), J â‰¤ I â†’ â‡‘box_integral.box.Icc J âŠ† metric.closed_ball x Î´ â†’ has_dist.dist (â‡‘(â‡‘vol J) (f x)) (â‡‘g J) â‰¤ Îµ * â‡‘B J)) : box_integral.has_integral I box_integral.integration_params.McShane f vol (â‡‘g I)
theorem affine.simplex.monge_plane_comm {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {n : â„•} (s : affine.simplex â„ P (n + 2)) (iâ‚ iâ‚‚ : fin (n + 3)) : s.monge_plane iâ‚ iâ‚‚ = s.monge_plane iâ‚‚ iâ‚
theorem holder_on_with.dimH_image_le {X : Type u_2} {Y : Type u_3} [emetric_space X] [emetric_space Y] {C r : nnreal} {f : X â†’ Y} {s : set X} (h : holder_on_with C r f s) (hr : 0 < r) : dimH (f '' s) â‰¤ dimH s / â†‘r
theorem order.pred_lt_of_not_is_min {Î± : Type u_1} [preorder Î±] [pred_order Î±] {a : Î±} : Â¬is_min a â†’ order.pred a < a
theorem subgroup.map_equiv_normalizer_eq {G : Type u_1} [group G] {N : Type u_3} [group N] (H : subgroup G) (f : G â‰ƒ* N) : subgroup.map f.to_monoid_hom H.normalizer = (subgroup.map f.to_monoid_hom H).normalizer
theorem measure_theory.measure.ext_of_sUnion_eq_univ {Î± : Type u_1} {m0 : measurable_space Î±} {Î¼ Î½ : measure_theory.measure Î±} {S : set (set Î±)} (hc : S.countable) (hs : â‹ƒâ‚€S = set.univ) : (âˆ€ (s : set Î±), s âˆˆ S â†’ Î¼.restrict s = Î½.restrict s) â†’ Î¼ = Î½
theorem pow_four_add_four_mul_pow_four' {R : Type u_1} [comm_ring R] {a b : R} : a ^ 4 + 4 * b ^ 4 = (a ^ 2 - 2 * a * b + 2 * b ^ 2) * (a ^ 2 + 2 * a * b + 2 * b ^ 2)
theorem has_le.le.wcovby_of_le {Î± : Type u_1} [preorder Î±] {a b : Î±} (h1 : a â‰¤ b) (h2 : b â‰¤ a) : a â©¿ b
theorem matrix.diagonal_transvection_induction {n : Type u_1} {ğ•œ : Type u_3} [field ğ•œ] [decidable_eq n] [fintype n] (P : matrix n n ğ•œ â†’ Prop) (M : matrix n n ğ•œ) (hdiag : âˆ€ (D : n â†’ ğ•œ), (matrix.diagonal D).det = M.det â†’ P (matrix.diagonal D)) (htransvec : âˆ€ (t : matrix.transvection_struct n ğ•œ), P t.to_matrix) (hmul : âˆ€ (A B : matrix n n ğ•œ), P A â†’ P B â†’ P (A.mul B)) : P M
theorem measurable_of_tendsto_metrizable' {Î± : Type u_1} {Î² : Type u_2} [measurable_space Î±] [topological_space Î²] [topological_space.pseudo_metrizable_space Î²] [measurable_space Î²] [borel_space Î²] {Î¹ : Type u_3} {f : Î¹ â†’ Î± â†’ Î²} {g : Î± â†’ Î²} (u : filter Î¹) [u.ne_bot] [u.is_countably_generated] (hf : âˆ€ (i : Î¹), measurable (f i)) (lim : filter.tendsto f u (nhds g)) : measurable g
theorem emetric.inf_edist_zero_of_mem {Î± : Type u} [pseudo_emetric_space Î±] {x : Î±} {s : set Î±} (h : x âˆˆ s) : emetric.inf_edist x s = 0
theorem is_primitive_root.pow_sub_one_norm_prime_ne_two {p : â„•+} {K : Type u} {L : Type v} [field L] {Î¶ : L} [field K] [algebra K L] [ne_zero â†‘â†‘p] {k : â„•} (hÎ¶ : is_primitive_root Î¶ â†‘(p ^ (k + 1))) [hpri : fact (nat.prime â†‘p)] [is_cyclotomic_extension {p ^ (k + 1)} K L] (hirr : irreducible (polynomial.cyclotomic â†‘(p ^ (k + 1)) K)) {s : â„•} (hs : s â‰¤ k) (hodd : p â‰  2) : â‡‘(algebra.norm K) (Î¶ ^ â†‘p ^ s - 1) = â†‘p ^ â†‘p ^ s
theorem finrank_le_one_iff {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] : finite_dimensional.finrank K V â‰¤ 1 â†” âˆƒ (v : V), âˆ€ (w : V), âˆƒ (c : K), c â€¢ v = w
theorem deriv.lhopital_zero_nhds {a : â„} {l : filter â„} {f g : â„ â†’ â„} (hdf : âˆ€á¶  (x : â„) in nhds a, differentiable_at â„ f x) (hg' : âˆ€á¶  (x : â„) in nhds a, deriv g x â‰  0) (hfa : filter.tendsto f (nhds a) (nhds 0)) (hga : filter.tendsto g (nhds a) (nhds 0)) (hdiv : filter.tendsto (Î» (x : â„), deriv f x / deriv g x) (nhds a) l) : filter.tendsto (Î» (x : â„), f x / g x) (nhds_within a (set.univ  {a})) l
theorem is_smul_regular.zero_iff_subsingleton {R : Type u_1} {M : Type u_3} [monoid_with_zero R] [has_zero M] [mul_action_with_zero R M] : is_smul_regular M 0 â†” subsingleton M
theorem ideal.quotient.maximal_ideal_iff_is_field_quotient {R : Type u} [comm_ring R] (I : ideal R) : I.is_maximal â†” is_field (R â§¸ I)
theorem cont_mdiff_on.cont_mdiff_on_tangent_map_within {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {M : Type u_4} [topological_space M] [charted_space H M] [Is : smooth_manifold_with_corners I M] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners ğ•œ E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] [I's : smooth_manifold_with_corners I' M'] {f : M â†’ M'} {s : set M} {m n : with_top â„•} (hf : cont_mdiff_on I I' n f s) (hmn : m + 1 â‰¤ n) (hs : unique_mdiff_on I s) : cont_mdiff_on I.tangent I'.tangent m (tangent_map_within I I' f s) (tangent_bundle.proj I M â»Â¹' s)
theorem affine_basis.affine_independent_of_to_matrix_right_inv {Î¹ : Type uâ‚} {k : Type uâ‚‚} {V : Type uâ‚ƒ} {P : Type uâ‚„} [add_comm_group V] [add_torsor V P] [ring k] [module k V] (b : affine_basis Î¹ k P) {Î¹' : Type u_1} [fintype Î¹'] [fintype Î¹] [decidable_eq Î¹'] (p : Î¹' â†’ P) {A : matrix Î¹ Î¹' k} (hA : (b.to_matrix p).mul A = 1) : affine_independent k p
theorem mem_range_of_exists_le_of_exists_ge {X : Type u} {Î± : Type v} [topological_space X] [linear_order Î±] [topological_space Î±] [order_closed_topology Î±] [preconnected_space X] {c : Î±} {f : X â†’ Î±} (hf : continuous f) (hâ‚ : âˆƒ (a : X), f a â‰¤ c) (hâ‚‚ : âˆƒ (b : X), c â‰¤ f b) : c âˆˆ set.range f
theorem cauchy_seq_of_le_geometric_two {Î± : Type u_1} [pseudo_metric_space Î±] (C : â„) {f : â„• â†’ Î±} (huâ‚‚ : âˆ€ (n : â„•), has_dist.dist (f n) (f (n + 1)) â‰¤ C / 2 / 2 ^ n) : cauchy_seq f
theorem pgame.mk_lf_mk {xl xr : Type u_1} {xL : xl â†’ pgame} {xR : xr â†’ pgame} {yl yr : Type u_1} {yL : yl â†’ pgame} {yR : yr â†’ pgame} : (pgame.mk xl xr xL xR).lf (pgame.mk yl yr yL yR) â†” (âˆƒ (i : yl), pgame.mk xl xr xL xR â‰¤ yL i) âˆ¨ âˆƒ (j : xr), xR j â‰¤ pgame.mk yl yr yL yR
theorem order_of_pos_iff {G : Type u} {x : G} [monoid G] : 0 < order_of x â†” is_of_fin_order x
theorem probability_theory.ident_distrib.ae_strongly_measurable_fst {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [measurable_space Î±] [measurable_space Î²] [measurable_space Î³] {Î¼ : measure_theory.measure Î±} {Î½ : measure_theory.measure Î²} {f : Î± â†’ Î³} {g : Î² â†’ Î³} [topological_space Î³] [topological_space.metrizable_space Î³] [opens_measurable_space Î³] [topological_space.second_countable_topology Î³] (h : probability_theory.ident_distrib f g Î¼ Î½) : measure_theory.ae_strongly_measurable f Î¼
theorem convex_cone.ext' {ğ•œ : Type u_1} {E : Type u_2} [ordered_semiring ğ•œ] [add_comm_monoid E] [has_scalar ğ•œ E] {S T : convex_cone ğ•œ E} (h : â†‘S = â†‘T) : S = T
theorem measurable_space.cardinal_generate_measurable_le {Î± : Type u} (s : set (set Î±)) : cardinal.mk â†¥{t : set Î± | measurable_space.generate_measurable s t} â‰¤ linear_order.max (cardinal.mk â†¥s) 2 ^ cardinal.aleph_0
theorem vsub_sub_vsub_cancel_right {G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] (p1 p2 p3 : P) : p1 -áµ¥ p3 - (p2 -áµ¥ p3) = p1 -áµ¥ p2
theorem zmod.legendre_sym_sq_one (p : â„•) [fact (nat.prime p)] (a : â„¤) (ha : â†‘a â‰  0) : zmod.legendre_sym p a ^ 2 = 1
theorem ring_equiv.to_equiv_commutes {R : Type u_4} {S : Type u_5} [non_assoc_semiring R] [non_assoc_semiring S] (f : R â‰ƒ+* S) : â†‘f.to_equiv = â†‘f.to_equiv
theorem is_cyclotomic_extension.finite_dimensional (S : set â„•+) (K : Type w) [field K] (C : Type z) [fintype â†¥S] [comm_ring C] [algebra K C] [is_domain C] [is_cyclotomic_extension S K C] : finite_dimensional K C
theorem bilin_form.linear_independent_of_is_Ortho {V : Type u_9} {K : Type u_10} [field K] [add_comm_group V] [module K V] {n : Type w} {B : bilin_form K V} {v : n â†’ V} (hvâ‚ : B.is_Ortho v) (hvâ‚‚ : âˆ€ (i : n), Â¬B.is_ortho (v i) (v i)) : linear_independent K v
theorem has_lt.lt.trans_le' {Î± : Type u} [preorder Î±] {a b c : Î±} : b < c â†’ a â‰¤ b â†’ a < c
theorem is_left_regular.subsingleton {R : Type u_1} [mul_zero_class R] (h : is_left_regular 0) : subsingleton R
theorem monoid_algebra.finite_type_iff_group_fg {R : Type u_1} {G : Type u_2} [comm_group G] [comm_ring R] [nontrivial R] : algebra.finite_type R (monoid_algebra R G) â†” group.fg G
theorem countable_cover_nhds_of_sigma_compact {Î± : Type u} [topological_space Î±] [sigma_compact_space Î±] {f : Î± â†’ set Î±} (hf : âˆ€ (x : Î±), f x âˆˆ nhds x) : âˆƒ (s : set Î±), s.countable âˆ§ (â‹ƒ (x : Î±) (H : x âˆˆ s), f x) = set.univ
theorem add_submonoid.mem_closure_pair {A : Type u_1} [add_comm_monoid A] (a b c : A) : c âˆˆ add_submonoid.closure {a, b} â†” âˆƒ (m n : â„•), m â€¢ a + n â€¢ b = c
theorem infinite_basis_le_maximal_linear_independent {R : Type u} [ring R] {M : Type v} [add_comm_group M] [module R M] [nontrivial R] {Î¹ : Type w} (b : basis Î¹ R M) [infinite Î¹] {Îº : Type w} (v : Îº â†’ M) (i : linear_independent R v) (m : i.maximal) : cardinal.mk Î¹ â‰¤ cardinal.mk Îº
theorem measurable.lintegral_prod_left {Î± : Type u_1} {Î² : Type u_3} [measurable_space Î±] [measurable_space Î²] {Î¼ : measure_theory.measure Î±} [measure_theory.sigma_finite Î¼] {f : Î± â†’ Î² â†’ ennreal} (hf : measurable (function.uncurry f)) : measurable (Î» (y : Î²), âˆ«â» (x : Î±), f x y âˆ‚Î¼)
theorem tsub_eq_zero_of_le {Î± : Type u_1} [canonically_ordered_add_monoid Î±] [has_sub Î±] [has_ordered_sub Î±] {a b : Î±} (h : a â‰¤ b) : a - b = 0
theorem padic_norm.padic_norm_p_lt_one_of_prime (p : â„•) [fact (nat.prime p)] : padic_norm p â†‘p < 1
theorem submodule.finite_dimensional_of_le {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {Sâ‚ Sâ‚‚ : submodule K V} [finite_dimensional K â†¥Sâ‚‚] (h : Sâ‚ â‰¤ Sâ‚‚) : finite_dimensional K â†¥Sâ‚
theorem add_valuation.top_iff {Î“â‚€ : Type u_3} [linear_ordered_add_comm_monoid_with_top Î“â‚€] [nontrivial Î“â‚€] {K : Type u_1} [division_ring K] (v : add_valuation K Î“â‚€) {x : K} : â‡‘v x = âŠ¤ â†” x = 0
theorem measure_theory.measure.haar_measure_unique {G : Type u_1} [group G] [topological_space G] [t2_space G] [topological_group G] [measurable_space G] [borel_space G] [topological_space.second_countable_topology G] (Î¼ : measure_theory.measure G) [measure_theory.sigma_finite Î¼] [Î¼.is_mul_left_invariant] (Kâ‚€ : topological_space.positive_compacts G) : Î¼ = â‡‘Î¼ â†‘Kâ‚€ â€¢ measure_theory.measure.haar_measure Kâ‚€
theorem filter.tendsto_at_bot_embedding {Î± : Type u_3} {Î² : Type u_4} {Î³ : Type u_5} [preorder Î²] [preorder Î³] {f : Î± â†’ Î²} {e : Î² â†’ Î³} {l : filter Î±} (hm : âˆ€ (bâ‚ bâ‚‚ : Î²), e bâ‚ â‰¤ e bâ‚‚ â†” bâ‚ â‰¤ bâ‚‚) (hu : âˆ€ (c : Î³), âˆƒ (b : Î²), e b â‰¤ c) : filter.tendsto (e âˆ˜ f) l filter.at_bot â†” filter.tendsto f l filter.at_bot
theorem finset.mem_up_shadow_iff_erase_mem {Î± : Type u_1} [decidable_eq Î±] [fintype Î±] {ğ’œ : finset (finset Î±)} {s : finset Î±} : s âˆˆ ğ’œ.up_shadow â†” âˆƒ (a : Î±) (H : a âˆˆ s), s.erase a âˆˆ ğ’œ
theorem prime_factors_irreducible {Î± : Type u_1} [cancel_comm_monoid_with_zero Î±] {a : Î±} {f : multiset Î±} (ha : irreducible a) (pfa : (âˆ€ (b : Î±), b âˆˆ f â†’ prime b) âˆ§ associated f.prod a) : âˆƒ (p : Î±), associated a p âˆ§ f = {p}
theorem metric.cthickening_mono {Î± : Type u} [pseudo_emetric_space Î±] {Î´â‚ Î´â‚‚ : â„} (hle : Î´â‚ â‰¤ Î´â‚‚) (E : set Î±) : metric.cthickening Î´â‚ E âŠ† metric.cthickening Î´â‚‚ E
theorem polynomial.splits_iff_card_roots {K : Type v} [field K] {p : polynomial K} : polynomial.splits (ring_hom.id K) p â†” â‡‘multiset.card p.roots = p.nat_degree
theorem linear_map.to_matrix_eq_to_matrix' {R : Type u_1} [comm_semiring R] {n : Type u_4} [fintype n] [decidable_eq n] : linear_map.to_matrix (pi.basis_fun R n) (pi.basis_fun R n) = linear_map.to_matrix'
theorem mdifferentiable.differentiable {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {E' : Type u_3} [normed_group E'] [normed_space ğ•œ E'] {f : E â†’ E'} : mdifferentiable (model_with_corners_self ğ•œ E) (model_with_corners_self ğ•œ E') f â†’ differentiable ğ•œ f
theorem unique_diff_within_at.prod {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {x : E} {s : set E} {t : set F} {y : F} (hs : unique_diff_within_at ğ•œ s x) (ht : unique_diff_within_at ğ•œ t y) : unique_diff_within_at ğ•œ (s Ã—Ë¢ t) (x, y)
theorem category_theory.has_colimits_of_shape_of_reflective {C : Type uâ‚} [category_theory.category C] {D : Type uâ‚‚} [category_theory.category D] {J : Type u} [category_theory.category J] (R : D â¥¤ C) [category_theory.reflective R] [category_theory.limits.has_colimits_of_shape J C] : category_theory.limits.has_colimits_of_shape J D
theorem is_add_submonoid.preimage {M : Type u_1} [add_monoid M] {N : Type u_2} [add_monoid N] {f : M â†’ N} (hf : is_add_monoid_hom f) {s : set N} (hs : is_add_submonoid s) : is_add_submonoid (f â»Â¹' s)
theorem add_action.card_eq_sum_card_add_group_sub_card_stabilizer' (Î± : Type u) (Î² : Type v) [add_group Î±] [add_action Î± Î²] [fintype Î±] [fintype Î²] [fintype (quotient (add_action.orbit_rel Î± Î²))] [Î  (b : Î²), fintype â†¥(add_action.stabilizer Î± b)] {Ï† : quotient (add_action.orbit_rel Î± Î²) â†’ Î²} (hÏ† : function.left_inverse quotient.mk' Ï†) : fintype.card Î² = finset.univ.sum (Î» (Ï‰ : quotient (add_action.orbit_rel Î± Î²)), fintype.card Î± / fintype.card â†¥(add_action.stabilizer Î± (Ï† Ï‰)))
theorem lt_of_tsub_lt_tsub_left_of_le {Î± : Type u_1} [canonically_ordered_add_monoid Î±] [has_sub Î±] [has_ordered_sub Î±] {a b c : Î±} [contravariant_class Î± Î± has_add.add has_le.le] [contravariant_class Î± Î± has_add.add has_lt.lt] (hca : c â‰¤ a) (h : a - b < a - c) : c < b
theorem affine_span_singleton_union_vadd_eq_top_of_span_eq_top {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : set V} (p : P) (h : submodule.span k (set.range coe) = âŠ¤) : affine_span k ({p} âˆª (Î» (v : V), v +áµ¥ p) '' s) = âŠ¤
theorem list.sum_neg_reverse {G : Type u_7} [add_group G] (L : list G) : -L.sum = (list.map (Î» (x : G), -x) L).reverse.sum
theorem complete_lattice.set_independent.pairwise_disjoint {Î± : Type u_1} [complete_lattice Î±] {s : set Î±} (hs : complete_lattice.set_independent s) : s.pairwise_disjoint id
theorem direct_sum.is_internal_submodule_iff_is_compl {R : Type u} [ring R] {Î¹ : Type v} [dec_Î¹ : decidable_eq Î¹] {M : Type u_1} [add_comm_group M] [module R M] (A : Î¹ â†’ submodule R M) {i j : Î¹} (hij : i â‰  j) (h : set.univ = {i, j}) : direct_sum.is_internal A â†” is_compl (A i) (A j)
theorem contracting_with.dist_fixed_point_fixed_point_of_dist_le' {Î± : Type u_1} [metric_space Î±] {K : nnreal} {f : Î± â†’ Î±} (hf : contracting_with K f) (g : Î± â†’ Î±) {x y : Î±} (hx : function.is_fixed_pt f x) (hy : function.is_fixed_pt g y) {C : â„} (hfg : âˆ€ (z : Î±), has_dist.dist (f z) (g z) â‰¤ C) : has_dist.dist x y â‰¤ C / (1 - â†‘K)
theorem algebraic_geometry.LocallyRingedSpace.to_Î“_Spec_continuous (X : algebraic_geometry.LocallyRingedSpace) : continuous X.to_Î“_Spec_fun
theorem add_equiv.map_neg {G : Type u_10} {H : Type u_11} [add_group G] [subtraction_monoid H] (h : G â‰ƒ+ H) (x : G) : â‡‘h (-x) = -â‡‘h x
theorem list_prod_mem {M : Type u_1} {B : Type u_3} [monoid M] [set_like B M] [submonoid_class B M] {S : B} {l : list M} (hl : âˆ€ (x : M), x âˆˆ l â†’ x âˆˆ S) : l.prod âˆˆ S
theorem bilin_form.not_nondegenerate_zero (R : Type u_1) (M : Type u_2) [semiring R] [add_comm_monoid M] [module R M] [nontrivial M] : Â¬0.nondegenerate
theorem monoid.not_is_torsion_iff (G : Type u_1) [monoid G] : Â¬monoid.is_torsion G â†” âˆƒ (g : G), Â¬is_of_fin_order g
theorem line_map_le_map_iff_slope_le_slope_right {k : Type u_1} {E : Type u_2} [linear_ordered_field k] [ordered_add_comm_group E] [module k E] [ordered_smul k E] {f : k â†’ E} {a b r : k} (h : 0 < (1 - r) * (b - a)) : â‡‘(affine_map.line_map (f a) (f b)) r â‰¤ f (â‡‘(affine_map.line_map a b) r) â†” slope f (â‡‘(affine_map.line_map a b) r) b â‰¤ slope f a b
theorem con.map_apply {M : Type u_1} [mul_one_class M] {c d : con M} (h : c â‰¤ d) (x : c.quotient) : â‡‘(c.map d h) x = â‡‘(c.lift d.mk' _) x
theorem cont_diff_on.dimH_image_le {E : Type u_4} {F : Type u_5} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] [normed_group F] [normed_space â„ F] {f : E â†’ F} {s t : set E} (hf : cont_diff_on â„ 1 f s) (hc : convex â„ s) (ht : t âŠ† s) : dimH (f '' t) â‰¤ dimH t
theorem uniform_space.complete_of_convergent_controlled_sequences {Î± : Type u} [uniform_space Î±] [(uniformity Î±).is_countably_generated] (U : â„• â†’ set (Î± Ã— Î±)) (U_mem : âˆ€ (n : â„•), U n âˆˆ uniformity Î±) (HU : âˆ€ (u : â„• â†’ Î±), (âˆ€ (N m n : â„•), N â‰¤ m â†’ N â‰¤ n â†’ (u m, u n) âˆˆ U N) â†’ (âˆƒ (a : Î±), filter.tendsto u filter.at_top (nhds a))) : complete_space Î±
theorem category_theory.has_finite_coproducts_of_has_binary_and_terminal {C : Type u} [category_theory.category C] [category_theory.limits.has_binary_coproducts C] [category_theory.limits.has_initial C] : category_theory.limits.has_finite_coproducts C
theorem has_le.le.lt_of_ne' {Î± : Type u} [partial_order Î±] {a b : Î±} : a â‰¤ b â†’ b â‰  a â†’ a < b
theorem concave_on.neg {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [ordered_semiring ğ•œ] [add_comm_monoid E] [ordered_add_comm_group Î²] [has_scalar ğ•œ E] [module ğ•œ Î²] {s : set E} {f : E â†’ Î²} : concave_on ğ•œ s f â†’ convex_on ğ•œ s (-f)
theorem measure_theory.ae_nonneg_of_forall_set_integral_nonneg_of_finite_measure_of_strongly_measurable {Î± : Type u_1} {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [measure_theory.is_finite_measure Î¼] {f : Î± â†’ â„} (hfm : measure_theory.strongly_measurable f) (hf : measure_theory.integrable f Î¼) (hf_zero : âˆ€ (s : set Î±), measurable_set s â†’ 0 â‰¤ âˆ« (x : Î±) in s, f x âˆ‚Î¼) : 0 â‰¤áµ[Î¼] f
theorem module.free.rank_tensor_product (R : Type u) (M : Type v) (N : Type w) [comm_ring R] [strong_rank_condition R] [add_comm_group M] [module R M] [module.free R M] [add_comm_group N] [module R N] [module.free R N] : module.rank R (tensor_product R M N) = (module.rank R M).lift * (module.rank R N).lift
theorem is_connected.Icc_subset {Î± : Type v} [linear_order Î±] [topological_space Î±] [order_closed_topology Î±] {s : set Î±} (hs : is_connected s) {a b : Î±} (ha : a âˆˆ s) (hb : b âˆˆ s) : set.Icc a b âŠ† s
theorem continuous_linear_map.norm_id_le {ğ•œ : Type u_1} {E : Type u_4} [semi_normed_group E] [nondiscrete_normed_field ğ•œ] [normed_space ğ•œ E] : âˆ¥continuous_linear_map.id ğ•œ Eâˆ¥ â‰¤ 1
theorem map_le_line_map_iff_slope_le_slope_right {k : Type u_1} {E : Type u_2} [linear_ordered_field k] [ordered_add_comm_group E] [module k E] [ordered_smul k E] {f : k â†’ E} {a b r : k} (h : 0 < (1 - r) * (b - a)) : f (â‡‘(affine_map.line_map a b) r) â‰¤ â‡‘(affine_map.line_map (f a) (f b)) r â†” slope f a b â‰¤ slope f (â‡‘(affine_map.line_map a b) r) b
theorem smul_pos_of_neg_of_neg {k : Type u_1} {M : Type u_2} [ordered_ring k] [ordered_add_comm_group M] [module k M] [ordered_smul k M] {a : M} {c : k} (hc : c < 0) : a < 0 â†’ 0 < c â€¢ a
theorem fin.coe_coe_of_lt {n a : â„•} (h : a < n + 1) : â†‘â†‘a = a
theorem algebra.right_comm {R : Type u} {A : Type w} [comm_semiring R] [semiring A] [algebra R A] (x : A) (r : R) (y : A) : x * â‡‘(algebra_map R A) r * y = x * y * â‡‘(algebra_map R A) r
theorem category_theory.subobject.exists_iso_map {C : Type uâ‚} [category_theory.category C] {X Y : C} [category_theory.limits.has_images C] (f : X âŸ¶ Y) [category_theory.mono f] : category_theory.subobject.exists f = category_theory.subobject.map f
theorem ereal.le_neg_of_le_neg {a b : ereal} (h : a â‰¤ -b) : b â‰¤ -a
theorem add_subgroup.fg_iff {G : Type u_3} [add_group G] (P : add_subgroup G) : P.fg â†” âˆƒ (S : set G), add_subgroup.closure S = P âˆ§ S.finite
theorem algebra.is_algebraic_iff {R : Type u} {A : Type v} [comm_ring R] [ring A] [algebra R A] : algebra.is_algebraic R A â†” âŠ¤.is_algebraic
theorem multiset.nodup.dedup {Î± : Type u_1} [decidable_eq Î±] {s : multiset Î±} : s.nodup â†’ s.dedup = s
theorem structure_groupoid.is_local_structomorph_within_at_local_invariant_prop {H : Type u_1} [topological_space H] (G : structure_groupoid H) [closed_under_restriction G] : G.local_invariant_prop G G.is_local_structomorph_within_at
theorem eckmann_hilton.one {X : Type u} {mâ‚ mâ‚‚ : X â†’ X â†’ X} {eâ‚ eâ‚‚ : X} (hâ‚ : eckmann_hilton.is_unital mâ‚ eâ‚) (hâ‚‚ : eckmann_hilton.is_unital mâ‚‚ eâ‚‚) (distrib : âˆ€ (a b c d : X), mâ‚ (mâ‚‚ a b) (mâ‚‚ c d) = mâ‚‚ (mâ‚ a c) (mâ‚ b d)) : eâ‚ = eâ‚‚
theorem metric.closure_eq_Inter_thickening' {Î± : Type u} [pseudo_emetric_space Î±] (E : set Î±) (s : set â„) (hsâ‚€ : s âŠ† set.Ioi 0) (hs : âˆ€ (Îµ : â„), 0 < Îµ â†’ (s âˆ© set.Ioc 0 Îµ).nonempty) : closure E = â‹‚ (Î´ : â„) (H : Î´ âˆˆ s), metric.thickening Î´ E
theorem measure_theory.measure_lintegral_div_measure {G : Type u_1} [measurable_space G] [group G] [has_measurable_mulâ‚‚ G] (Î¼ Î½ : measure_theory.measure G) [measure_theory.sigma_finite Î½] [measure_theory.sigma_finite Î¼] {E : set G} [has_measurable_inv G] [Î¼.is_mul_left_invariant] [Î½.is_mul_left_invariant] (Em : measurable_set E) (h2E : â‡‘Î½ E â‰  0) (h3E : â‡‘Î½ E â‰  âŠ¤) (f : G â†’ ennreal) (hf : measurable f) : â‡‘Î¼ E * âˆ«â» (y : G), f yâ»Â¹ / â‡‘Î½ ((Î» (x : G), x * yâ»Â¹) â»Â¹' E) âˆ‚Î½ = âˆ«â» (x : G), f x âˆ‚Î¼
theorem real.Sup_nonneg (S : set â„) (hS : âˆ€ (x : â„), x âˆˆ S â†’ 0 â‰¤ x) : 0 â‰¤ has_Sup.Sup S
theorem measure_theory.integral_mul_right_eq_self {G : Type u_4} {E : Type u_5} [measurable_space G] [normed_group E] [normed_space â„ E] [complete_space E] {Î¼ : measure_theory.measure G} [group G] [has_measurable_mul G] [Î¼.is_mul_right_invariant] (f : G â†’ E) (g : G) : âˆ« (x : G), f (x * g) âˆ‚Î¼ = âˆ« (x : G), f x âˆ‚Î¼
theorem has_ftaylor_series_up_to_on.continuous_linear_map_comp {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {G : Type u_4} [normed_group G] [normed_space ğ•œ G] {s : set E} {f : E â†’ F} {n : with_top â„•} {p : E â†’ formal_multilinear_series ğ•œ E F} (g : F â†’L[ğ•œ] G) (hf : has_ftaylor_series_up_to_on n f p s) : has_ftaylor_series_up_to_on n (â‡‘g âˆ˜ f) (Î» (x : E) (k : â„•), g.comp_continuous_multilinear_map (p x k)) s
theorem summable.mapL {Î¹ : Type u_10} {R : Type u_11} {Râ‚‚ : Type u_12} {M : Type u_13} {Mâ‚‚ : Type u_14} [semiring R] [semiring Râ‚‚] [add_comm_monoid M] [module R M] [add_comm_monoid Mâ‚‚] [module Râ‚‚ Mâ‚‚] [topological_space M] [topological_space Mâ‚‚] {Ïƒ : R â†’+* Râ‚‚} {f : Î¹ â†’ M} (Ï† : M â†’SL[Ïƒ] Mâ‚‚) (hf : summable f) : summable (Î» (b : Î¹), â‡‘Ï† (f b))
theorem exists_mem_Ico_zpow {Î± : Type u_1} [linear_ordered_field Î±] [archimedean Î±] {x y : Î±} (hx : 0 < x) (hy : 1 < y) : âˆƒ (n : â„¤), x âˆˆ set.Ico (y ^ n) (y ^ (n + 1))
theorem solvable_by_rad.is_solvable' {F : Type u_1} [field F] {E : Type u_2} [field E] [algebra F E] {Î± : E} {q : polynomial F} (q_irred : irreducible q) (q_aeval : â‡‘(polynomial.aeval Î±) q = 0) (hÎ± : is_solvable_by_rad F Î±) : is_solvable q.gal
theorem local_homeomorph.continuous_on_iff_continuous_on_comp_right {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [topological_space Î±] [topological_space Î²] [topological_space Î³] (e : local_homeomorph Î± Î²) {f : Î² â†’ Î³} {s : set Î²} (h : s âŠ† e.to_local_equiv.target) : continuous_on f s â†” continuous_on (f âˆ˜ â‡‘e) (e.to_local_equiv.source âˆ© â‡‘e â»Â¹' s)
theorem submodule.orthogonal_disjoint {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] (K : submodule ğ•œ E) : disjoint K Ká—®
theorem metric.exists_ball_inter_eq_singleton_of_mem_discrete {Î± : Type u} [pseudo_metric_space Î±] {s : set Î±} [discrete_topology â†¥s] {x : Î±} (hx : x âˆˆ s) : âˆƒ (Îµ : â„) (H : Îµ > 0), metric.ball x Îµ âˆ© s = {x}
theorem measure_theory.Lp.simple_func.measurable {Î± : Type u_1} {E : Type u_4} [measurable_space Î±] [normed_group E] {p : ennreal} {Î¼ : measure_theory.measure Î±} [measurable_space E] (f : â†¥(measure_theory.Lp.simple_func E p Î¼)) : measurable â‡‘(measure_theory.Lp.simple_func.to_simple_func f)
theorem has_fderiv_at_iff_has_deriv_at {ğ•œ : Type u} [nondiscrete_normed_field ğ•œ] {F : Type v} [normed_group F] [normed_space ğ•œ F] {f : ğ•œ â†’ F} {x : ğ•œ} {f' : ğ•œ â†’L[ğ•œ] F} : has_fderiv_at f f' x â†” has_deriv_at f (â‡‘f' 1) x
theorem first_order.language.substructure.closure_induction {L : first_order.language} {M : Type w} [L.Structure M] {s : set M} {p : M â†’ Prop} {x : M} (h : x âˆˆ â‡‘(first_order.language.substructure.closure L) s) (Hs : âˆ€ (x : M), x âˆˆ s â†’ p x) (Hfun : âˆ€ {n : â„•} (f : L.functions n), first_order.language.closed_under f (set_of p)) : p x
theorem category_theory.bicategory.left_unitor_whisker_right {B : Type u} [category_theory.bicategory B] {a b c : B} (f : a âŸ¶ b) (g : b âŸ¶ c) : category_theory.bicategory.whisker_right (category_theory.bicategory.left_unitor f).hom g = (category_theory.bicategory.associator (ğŸ™ a) f g).hom â‰« (category_theory.bicategory.left_unitor (f â‰« g)).hom
theorem finset.sum_smul_vsub_eq_affine_combination_vsub {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {Î¹ : Type u_4} (s : finset Î¹) (w : Î¹ â†’ k) (pâ‚ pâ‚‚ : Î¹ â†’ P) : s.sum (Î» (i : Î¹), w i â€¢ (pâ‚ i -áµ¥ pâ‚‚ i)) = â‡‘(s.affine_combination pâ‚) w -áµ¥ â‡‘(s.affine_combination pâ‚‚) w
theorem measure_theory.sum_measure_preimage_singleton {Î± : Type u_1} {Î² : Type u_2} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (s : finset Î²) {f : Î± â†’ Î²} (hf : âˆ€ (y : Î²), y âˆˆ s â†’ measurable_set (f â»Â¹' {y})) : s.sum (Î» (b : Î²), â‡‘Î¼ (f â»Â¹' {b})) = â‡‘Î¼ (f â»Â¹' â†‘s)
theorem measure_theory.measure_inter_add_diffâ‚€ {Î± : Type u_2} {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {t : set Î±} (s : set Î±) (ht : measure_theory.null_measurable_set t Î¼) : â‡‘Î¼ (s âˆ© t) + â‡‘Î¼ (s  t) = â‡‘Î¼ s
theorem bilin_form.is_adjoint_pair_iff_eq_of_nondegenerate {V : Type u_9} {K : Type u_10} [field K] [add_comm_group V] [module K V] [finite_dimensional K V] (B : bilin_form K V) (b : B.nondegenerate) (Ïˆ Ï† : V â†’â‚—[K] V) : B.is_adjoint_pair B Ïˆ Ï† â†” Ïˆ = B.left_adjoint_of_nondegenerate b Ï†
theorem finset.map_perm {Î± : Type u_1} {s : finset Î±} {Ïƒ : equiv.perm Î±} (hs : {a : Î± | â‡‘Ïƒ a â‰  a} âŠ† â†‘s) : finset.map â†‘Ïƒ s = s
theorem order.le_of_pred_le_pred {Î± : Type u_1} [preorder Î±] [pred_order Î±] {a b : Î±} [no_min_order Î±] : order.pred a â‰¤ order.pred b â†’ a â‰¤ b
theorem is_preconnected_iff_subset_of_disjoint_closed {Î± : Type u} [topological_space Î±] {s : set Î±} : is_preconnected s â†” âˆ€ (u v : set Î±), is_closed u â†’ is_closed v â†’ s âŠ† u âˆª v â†’ s âˆ© (u âˆ© v) = âˆ… â†’ s âŠ† u âˆ¨ s âŠ† v
theorem fin.tail_update_succ {n : â„•} {Î± : fin (n + 1) â†’ Type u} (q : Î  (i : fin (n + 1)), Î± i) (i : fin n) (y : Î± i.succ) : fin.tail (function.update q i.succ y) = function.update (fin.tail q) i y
theorem algebraic_geometry.PresheafedSpace.is_open_immersion.app_inv_app' {C : Type u} [category_theory.category C] {X Y : algebraic_geometry.PresheafedSpace C} {f : X âŸ¶ Y} (H : algebraic_geometry.PresheafedSpace.is_open_immersion f) (U : topological_space.opens â†¥Y) (hU : â†‘U âŠ† set.range â‡‘(f.base)) : f.c.app (opposite.op U) â‰« H.inv_app ((topological_space.opens.map f.base).obj U) = Y.presheaf.map (category_theory.eq_to_hom _).op
theorem fin.succ_above_lt_iff {n : â„•} (p : fin (n + 1)) (i : fin n) : â‡‘(p.succ_above) i < p â†” â‡‘fin.cast_succ i < p
theorem orthonormal.oangle_add_oangle_rev_neg_right {V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) (x y : V) : hb.oangle x (-y) + hb.oangle y (-x) = 0
theorem filter.at_top_Ici_eq {Î± : Type u_3} [semilattice_sup Î±] (a : Î±) : filter.at_top = filter.comap coe filter.at_top
theorem asymptotics.is_O_with.of_neg_right {Î± : Type u_1} {E : Type u_3} {F' : Type u_7} [has_norm E] [semi_normed_group F'] {c : â„} {f : Î± â†’ E} {g' : Î± â†’ F'} {l : filter Î±} : asymptotics.is_O_with c l f (Î» (x : Î±), -g' x) â†’ asymptotics.is_O_with c l f g'
theorem finrank_vector_span_range_le (k : Type u_1) {V : Type u_2} {P : Type u_3} {Î¹ : Type u_4} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] [fintype Î¹] (p : Î¹ â†’ P) {n : â„•} (hc : fintype.card Î¹ = n + 1) : finite_dimensional.finrank k â†¥(vector_span k (set.range p)) â‰¤ n
theorem fin.is_some_find_iff {n : â„•} {p : fin n â†’ Prop} [decidable_pred p] : â†¥((fin.find p).is_some) â†” âˆƒ (i : fin n), p i
theorem coe_affine_span (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P) : â†‘(affine_span k s) = span_points k s
theorem add_monoid_algebra.lift_unique {k : Type uâ‚} {G : Type uâ‚‚} [comm_semiring k] [add_monoid G] {A : Type uâ‚ƒ} [semiring A] [algebra k A] (F : add_monoid_algebra k G â†’â‚[k] A) (f : monoid_algebra k G) : â‡‘F f = finsupp.sum f (Î» (a : G) (b : k), b â€¢ â‡‘F (finsupp.single a 1))
theorem cont_diff.mul {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {n : with_top â„•} {f g : E â†’ ğ•œ} (hf : cont_diff ğ•œ n f) (hg : cont_diff ğ•œ n g) : cont_diff ğ•œ n (Î» (x : E), f x * g x)
theorem category_theory.grothendieck_topology.le_close {C : Type u} [category_theory.category C] (Jâ‚ : category_theory.grothendieck_topology C) {X : C} (S : category_theory.sieve X) : S â‰¤ Jâ‚.close S
theorem finset.sum_range_id (n : â„•) : (finset.range n).sum (Î» (i : â„•), i) = n * (n - 1) / 2
theorem continuous_linear_map.op_norm_le_bound {ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_normed_group E] [semi_normed_group F] [nondiscrete_normed_field ğ•œ] [nondiscrete_normed_field ğ•œâ‚‚] [normed_space ğ•œ E] [normed_space ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} (f : E â†’SL[Ïƒâ‚â‚‚] F) {M : â„} (hMp : 0 â‰¤ M) (hM : âˆ€ (x : E), âˆ¥â‡‘f xâˆ¥ â‰¤ M * âˆ¥xâˆ¥) : âˆ¥fâˆ¥ â‰¤ M
theorem has_ftaylor_series_up_to_on.eventually_has_fderiv_at {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {s : set E} {f : E â†’ F} {x : E} {n : with_top â„•} {p : E â†’ formal_multilinear_series ğ•œ E F} (h : has_ftaylor_series_up_to_on n f p s) (hn : 1 â‰¤ n) (hx : s âˆˆ nhds x) : âˆ€á¶  (y : E) in nhds x, has_fderiv_at f (â‡‘(continuous_multilinear_curry_fin1 ğ•œ E F) (p y 1)) y
theorem lt_neg_of_lt_neg {Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b : Î±} : a < -b â†’ b < -a
theorem formal_multilinear_series.comp_coeff_one {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [comm_ring ğ•œ] [add_comm_group E] [add_comm_group F] [add_comm_group G] [module ğ•œ E] [module ğ•œ F] [module ğ•œ G] [topological_space E] [topological_space F] [topological_space G] [topological_add_group E] [has_continuous_const_smul ğ•œ E] [topological_add_group F] [has_continuous_const_smul ğ•œ F] [topological_add_group G] [has_continuous_const_smul ğ•œ G] (q : formal_multilinear_series ğ•œ F G) (p : formal_multilinear_series ğ•œ E F) (v : fin 1 â†’ E) : â‡‘(q.comp p 1) v = â‡‘(q 1) (Î» (i : fin 1), â‡‘(p 1) v)
theorem topological_semiring.to_topological_ring {Î± : Type u_1} [topological_space Î±] [non_assoc_ring Î±] (h : topological_semiring Î±) : topological_ring Î±
theorem has_le.le.eq_or_lt {Î± : Type u} [partial_order Î±] {a b : Î±} (h : a â‰¤ b) : a = b âˆ¨ a < b
theorem continuous_linear_map.eq_on_closure_span {Râ‚ : Type u_1} {Râ‚‚ : Type u_2} [semiring Râ‚] [semiring Râ‚‚] {Ïƒâ‚â‚‚ : Râ‚ â†’+* Râ‚‚} {Mâ‚ : Type u_4} [topological_space Mâ‚] [add_comm_monoid Mâ‚] {Mâ‚‚ : Type u_6} [topological_space Mâ‚‚] [add_comm_monoid Mâ‚‚] [module Râ‚ Mâ‚] [module Râ‚‚ Mâ‚‚] [t2_space Mâ‚‚] {s : set Mâ‚} {f g : Mâ‚ â†’SL[Ïƒâ‚â‚‚] Mâ‚‚} (h : set.eq_on â‡‘f â‡‘g s) : set.eq_on â‡‘f â‡‘g (closure â†‘(submodule.span Râ‚ s))
theorem circle_deg1_lift.semiconj_of_is_unit_of_translation_number_eq {fâ‚ fâ‚‚ : circle_deg1_lift} (hâ‚ : is_unit fâ‚) (hâ‚‚ : is_unit fâ‚‚) (h : fâ‚.translation_number = fâ‚‚.translation_number) : âˆƒ (F : circle_deg1_lift), function.semiconj â‡‘F â‡‘fâ‚ â‡‘fâ‚‚
theorem Kuratowski_embedding.isometry (Î± : Type u) [metric_space Î±] [topological_space.separable_space Î±] : isometry (Kuratowski_embedding Î±)
theorem inner_product_space.of_core.inner_add_add_self {ğ•œ : Type u_1} {F : Type u_3} [is_R_or_C ğ•œ] [add_comm_group F] [module ğ•œ F] [c : inner_product_space.core ğ•œ F] {x y : F} : has_inner.inner (x + y) (x + y) = has_inner.inner x x + has_inner.inner x y + has_inner.inner y x + has_inner.inner y y
theorem zero_at_infty_continuous_map.tendsto_iff_tendsto_uniformly {Î± : Type u} {Î² : Type v} [topological_space Î±] [metric_space Î²] [has_zero Î²] {Î¹ : Type u_1} {F : Î¹ â†’ zero_at_infty_continuous_map Î± Î²} {f : zero_at_infty_continuous_map Î± Î²} {l : filter Î¹} : filter.tendsto F l (nhds f) â†” tendsto_uniformly (Î» (i : Î¹), â‡‘(F i)) â‡‘f l
theorem measure_theory.jordan_decomposition.to_signed_measure_injective {Î± : Type u_1} [measurable_space Î±] : function.injective measure_theory.jordan_decomposition.to_signed_measure
theorem continuous_linear_equiv.comp_cont_diff_on_iff {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {G : Type u_4} [normed_group G] [normed_space ğ•œ G] {s : set E} {f : E â†’ F} {n : with_top â„•} (e : F â‰ƒL[ğ•œ] G) : cont_diff_on ğ•œ n (â‡‘e âˆ˜ f) s â†” cont_diff_on ğ•œ n f s
theorem is_add_submonoid.multiples_subset {M : Type u_1} [add_monoid M] {s : set M} {a : M} (hs : is_add_submonoid s) (h : a âˆˆ s) : multiples a âŠ† s
theorem metric.is_compact_of_is_closed_bounded {Î± : Type u} [pseudo_metric_space Î±] {s : set Î±} [proper_space Î±] (hc : is_closed s) (hb : metric.bounded s) : is_compact s
theorem list.nth_le_split_wrt_composition {n : â„•} {Î± : Type u_1} (l : list Î±) (c : composition n) {i : â„•} (hi : i < (l.split_wrt_composition c).length) : (l.split_wrt_composition c).nth_le i hi = list.drop (c.size_up_to i) (list.take (c.size_up_to (i + 1)) l)
theorem measure_theory.measure.map_apply_of_ae_measurable {Î± : Type u_1} {Î² : Type u_2} {m0 : measurable_space Î±} [measurable_space Î²] {Î¼ : measure_theory.measure Î±} {f : Î± â†’ Î²} (hf : ae_measurable f Î¼) {s : set Î²} (hs : measurable_set s) : â‡‘(measure_theory.measure.map f Î¼) s = â‡‘Î¼ (f â»Â¹' s)
theorem complex.Gamma_integral_convergent {s : â„‚} (hs : 0 < s.re) : measure_theory.integrable_on (Î» (x : â„), â†‘(real.exp (-x)) * â†‘x ^ (s - 1)) (set.Ioi 0) measure_theory.measure_space.volume
theorem convex.combo_affine_apply {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [ordered_ring ğ•œ] [add_comm_group E] [add_comm_group F] [module ğ•œ E] [module ğ•œ F] {a b : ğ•œ} {x y : E} {f : E â†’áµƒ[ğ•œ] F} (h : a + b = 1) : â‡‘f (a â€¢ x + b â€¢ y) = a â€¢ â‡‘f x + b â€¢ â‡‘f y
theorem linear_map.infi_invariant {R : Type u_1} {M : Type u_9} [semiring R] [add_comm_monoid M] [module R M] {Ïƒ : R â†’+* R} [ring_hom_surjective Ïƒ] {Î¹ : Sort u_2} (f : M â†’â‚›â‚—[Ïƒ] M) {p : Î¹ â†’ submodule R M} (hf : âˆ€ (i : Î¹) (v : M), v âˆˆ p i â†’ â‡‘f v âˆˆ p i) (v : M) (H : v âˆˆ infi p) : â‡‘f v âˆˆ infi p
theorem monoid.exists_list_of_mem_closure {M : Type u_1} [monoid M] {s : set M} {a : M} (h : a âˆˆ monoid.closure s) : âˆƒ (l : list M), (âˆ€ (x : M), x âˆˆ l â†’ x âˆˆ s) âˆ§ l.prod = a
theorem subset_tangent_cone_prod_left {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {x : E} {s : set E} {t : set F} {y : F} (ht : y âˆˆ closure t) : â‡‘(linear_map.inl ğ•œ E F) '' tangent_cone_at ğ•œ s x âŠ† tangent_cone_at ğ•œ (s Ã—Ë¢ t) (x, y)
theorem has_lt.lt.trans_eq {Î± : Type u} [preorder Î±] {a b c : Î±} (hab : a < b) (hbc : b = c) : a < c
theorem measure_theory.lintegral_tendsto_of_tendsto_of_monotone {Î± : Type u_1} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {f : â„• â†’ Î± â†’ ennreal} {F : Î± â†’ ennreal} (hf : âˆ€ (n : â„•), ae_measurable (f n) Î¼) (h_mono : âˆ€áµ (x : Î±) âˆ‚Î¼, monotone (Î» (n : â„•), f n x)) (h_tendsto : âˆ€áµ (x : Î±) âˆ‚Î¼, filter.tendsto (Î» (n : â„•), f n x) filter.at_top (nhds (F x))) : filter.tendsto (Î» (n : â„•), âˆ«â» (x : Î±), f n x âˆ‚Î¼) filter.at_top (nhds (âˆ«â» (x : Î±), F x âˆ‚Î¼))
theorem orthonormal.inner_right_fintype {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {Î¹ : Type u_4} [fintype Î¹] {v : Î¹ â†’ E} (hv : orthonormal ğ•œ v) (l : Î¹ â†’ ğ•œ) (i : Î¹) : has_inner.inner (v i) (finset.univ.sum (Î» (i : Î¹), l i â€¢ v i)) = l i
theorem has_dvd.dvd.multiplicity_pos {Î± : Type u_1} [comm_monoid Î±] [decidable_rel has_dvd.dvd] {a b : Î±} : a âˆ£ b â†’ 0 < multiplicity a b
theorem has_fpower_series_on_ball.image_sub_sub_deriv_le {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field ğ•œ] [normed_group E] [normed_space ğ•œ E] [normed_group F] [normed_space ğ•œ F] {f : E â†’ F} {p : formal_multilinear_series ğ•œ E F} {x : E} {r r' : ennreal} (hf : has_fpower_series_on_ball f p x r) (hr : r' < r) : âˆƒ (C : â„), âˆ€ (y : E), y âˆˆ emetric.ball x r' â†’ âˆ€ (z : E), z âˆˆ emetric.ball x r' â†’ âˆ¥f y - f z - â‡‘(p 1) (Î» (_x : fin 1), y - z)âˆ¥ â‰¤ C * linear_order.max âˆ¥y - xâˆ¥ âˆ¥z - xâˆ¥ * âˆ¥y - zâˆ¥
theorem upper_semicontinuous.add {Î± : Type u_1} [topological_space Î±] {Î³ : Type u_4} [linear_ordered_add_comm_monoid Î³] [topological_space Î³] [order_topology Î³] [has_continuous_add Î³] {f g : Î± â†’ Î³} (hf : upper_semicontinuous f) (hg : upper_semicontinuous g) : upper_semicontinuous (Î» (z : Î±), f z + g z)
theorem finprod_mem_range {Î± : Type u_1} {Î² : Type u_2} {M : Type u_5} [comm_monoid M] {f : Î± â†’ M} {g : Î² â†’ Î±} (hg : function.injective g) : finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ set.range g), f i)) = finprod (Î» (j : Î²), f (g j))
theorem basis.finite_index_of_dim_lt_aleph_0 {R : Type u} [ring R] [strong_rank_condition R] {M : Type v} [add_comm_group M] [module R M] {Î¹ : Type u_1} {s : set Î¹} (b : basis â†¥s R M) (h : module.rank R M < cardinal.aleph_0) : s.finite
theorem real.angle.induction_on {p : real.angle â†’ Prop} (Î¸ : real.angle) (h : âˆ€ (x : â„), p â†‘x) : p Î¸
theorem liouville_with.exists_pos {p x : â„} (h : liouville_with p x) : âˆƒ (C : â„) (hâ‚€ : 0 < C), âˆƒá¶  (n : â„•) in filter.at_top, 1 â‰¤ n âˆ§ âˆƒ (m : â„¤), x â‰  â†‘m / â†‘n âˆ§ |x - â†‘m / â†‘n| < C / â†‘n ^ p
theorem cinfi_le {Î± : Type u_1} {Î¹ : Sort u_3} [conditionally_complete_lattice Î±] {f : Î¹ â†’ Î±} (H : bdd_below (set.range f)) (c : Î¹) : infi f â‰¤ f c
theorem power_series.exp_mul_exp_neg_eq_one {A : Type u_1} [comm_ring A] [algebra â„š A] : power_series.exp A * â‡‘power_series.eval_neg_hom (power_series.exp A) = 1
theorem category_theory.is_iso_left_of_is_iso_biprod_map {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_binary_biproducts C] {W X Y Z : C} (f : W âŸ¶ Y) (g : X âŸ¶ Z) [category_theory.is_iso (category_theory.limits.biprod.map f g)] : category_theory.is_iso f
theorem generalized_continued_fraction.continuants_aux_eq_continuants_aux_squash_gcf_of_le {K : Type u_1} {n : â„•} {g : generalized_continued_fraction K} [division_ring K] {m : â„•} : m â‰¤ n â†’ g.continuants_aux m = (g.squash_gcf n).continuants_aux m
theorem fin.find_min {n : â„•} {p : fin n â†’ Prop} [decidable_pred p] {i : fin n} (hi : i âˆˆ fin.find p) {j : fin n} (hj : j < i) : Â¬p j
theorem multilinear_map.dom_coprod_alternization_coe {Î¹a : Type u_7} {Î¹b : Type u_8} [decidable_eq Î¹a] [decidable_eq Î¹b] [fintype Î¹a] [fintype Î¹b] {R' : Type u_9} {Máµ¢ : Type u_10} {Nâ‚ : Type u_11} {Nâ‚‚ : Type u_12} [comm_semiring R'] [add_comm_group Nâ‚] [module R' Nâ‚] [add_comm_group Nâ‚‚] [module R' Nâ‚‚] [add_comm_monoid Máµ¢] [module R' Máµ¢] (a : multilinear_map R' (Î» (_x : Î¹a), Máµ¢) Nâ‚) (b : multilinear_map R' (Î» (_x : Î¹b), Máµ¢) Nâ‚‚) : â†‘(â‡‘multilinear_map.alternatization a).dom_coprod â†‘(â‡‘multilinear_map.alternatization b) = finset.univ.sum (Î» (Ïƒa : equiv.perm Î¹a), finset.univ.sum (Î» (Ïƒb : equiv.perm Î¹b), â‡‘equiv.perm.sign Ïƒa â€¢ â‡‘equiv.perm.sign Ïƒb â€¢ (multilinear_map.dom_dom_congr Ïƒa a).dom_coprod (multilinear_map.dom_dom_congr Ïƒb b)))
theorem polynomial.X_pow_sub_one_splits {K : Type u_1} [field K] {Î¶ : K} {n : â„•} (h : is_primitive_root Î¶ n) : polynomial.splits (ring_hom.id K) (polynomial.X ^ n - â‡‘polynomial.C 1)
theorem list.take_append {Î± : Type u} {lâ‚ lâ‚‚ : list Î±} (i : â„•) : list.take (lâ‚.length + i) (lâ‚ ++ lâ‚‚) = lâ‚ ++ list.take i lâ‚‚
theorem category_theory.limits.eq_of_mono_coequalizer {C : Type u} [category_theory.category C] {X Y : C} {f g : X âŸ¶ Y} [category_theory.limits.has_coequalizer f g] [category_theory.mono (category_theory.limits.coequalizer.Ï€ f g)] : f = g
theorem category_theory.exact_d_f {C : Type u} [category_theory.category C] [category_theory.enough_projectives C] [category_theory.abelian C] {X Y : C} (f : X âŸ¶ Y) : category_theory.exact (category_theory.projective.d f) f
theorem le_sub_right_of_add_le {Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b c : Î±} : a + b â‰¤ c â†’ a â‰¤ c - b
theorem cont_diff_at_snd {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {n : with_top â„•} {p : E Ã— F} : cont_diff_at ğ•œ n prod.snd p
theorem right.mul_lt_one {Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_mul.mul) has_lt.lt] {a b : Î±} (ha : a < 1) (hb : b < 1) : a * b < 1
theorem geom_sumâ‚‚_mul_add {Î± : Type u} [comm_semiring Î±] (x y : Î±) (n : â„•) : (finset.range n).sum (Î» (i : â„•), (x + y) ^ i * y ^ (n - 1 - i)) * x + y ^ n = (x + y) ^ n
theorem is_antichain.disjoint_slice_shadow_falling {Î± : Type u_2} [decidable_eq Î±] {ğ’œ : finset (finset Î±)} {m n : â„•} (hğ’œ : is_antichain has_subset.subset â†‘ğ’œ) : disjoint (ğ’œ.slice m) (finset.falling n ğ’œ).shadow
theorem euclidean_geometry.exists_dist_eq_circumradius_of_subset_insert_orthocenter {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {t : affine.triangle â„ P} (ho : t.orthocenter âˆ‰ set.range t.points) {p : fin 3 â†’ P} (hps : set.range p âŠ† has_insert.insert t.orthocenter (set.range t.points)) (hpi : function.injective p) : âˆƒ (c : P) (H : c âˆˆ affine_span â„ (set.range t.points)), âˆ€ (pâ‚ : P), pâ‚ âˆˆ set.range p â†’ has_dist.dist pâ‚ c = affine.simplex.circumradius t
theorem subsemiring.one_mem {R : Type u} [non_assoc_semiring R] (s : subsemiring R) : 1 âˆˆ s
theorem polynomial.bernoulli_succ_eval (n p : â„•) : polynomial.eval â†‘n (polynomial.bernoulli p.succ) = bernoulli p.succ + (â†‘p + 1) * (finset.range n).sum (Î» (k : â„•), â†‘k ^ p)
theorem orthogonal_projection_mem_subspace_orthogonal_complement_eq_zero {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {K : submodule ğ•œ E} [complete_space â†¥K] {v : E} (hv : v âˆˆ Ká—®) : â‡‘(orthogonal_projection K) v = 0
theorem bernstein_polynomial.variance (R : Type u_1) [comm_ring R] (n : â„•) : (finset.range (n + 1)).sum (Î» (Î½ : â„•), (n â€¢ polynomial.X - â†‘Î½) ^ 2 * bernstein_polynomial R n Î½) = n â€¢ polynomial.X * (1 - polynomial.X)
theorem euclidean_domain.gcd_eq_gcd_ab {R : Type u} [euclidean_domain R] [decidable_eq R] (a b : R) : euclidean_domain.gcd a b = a * euclidean_domain.gcd_a a b + b * euclidean_domain.gcd_b a b
theorem is_mul_hom.id {Î± : Type u} [has_mul Î±] : is_mul_hom id
theorem liouville_with.mul_rat {p x : â„} {r : â„š} (h : liouville_with p x) (hr : r â‰  0) : liouville_with p (x * â†‘r)
theorem category_theory.adjunction.has_limits_of_equivalence {C : Type uâ‚} [category_theory.category C] {D : Type uâ‚‚} [category_theory.category D] (E : D â¥¤ C) [category_theory.is_equivalence E] [category_theory.limits.has_limits_of_size C] : category_theory.limits.has_limits_of_size D
theorem finrank_vector_span_le_iff_not_affine_independent (k : Type u_1) {V : Type u_2} {P : Type u_3} {Î¹ : Type u_4} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] [fintype Î¹] (p : Î¹ â†’ P) {n : â„•} (hc : fintype.card Î¹ = n + 2) : finite_dimensional.finrank k â†¥(vector_span k (set.range p)) â‰¤ n â†” Â¬affine_independent k p
theorem measure_theory.lintegral_le_of_forall_fin_meas_le_of_measurable {Î± : Type u_1} {m m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (hm : m â‰¤ m0) [measure_theory.sigma_finite (Î¼.trim hm)] (C : ennreal) {f : Î± â†’ ennreal} (hf_meas : measurable f) (hf : âˆ€ (s : set Î±), measurable_set s â†’ â‡‘Î¼ s â‰  âŠ¤ â†’ âˆ«â» (x : Î±) in s, f x âˆ‚Î¼ â‰¤ C) : âˆ«â» (x : Î±), f x âˆ‚Î¼ â‰¤ C
theorem cauchy_seq_of_edist_le_of_summable {Î± : Type u_1} [pseudo_emetric_space Î±] {f : â„• â†’ Î±} (d : â„• â†’ nnreal) (hf : âˆ€ (n : â„•), has_edist.edist (f n) (f n.succ) â‰¤ â†‘(d n)) (hd : summable d) : cauchy_seq f
theorem category_theory.simplicial_object.Î´_comp_Î´_self {C : Type u} [category_theory.category C] (X : category_theory.simplicial_object C) {n : â„•} {i : fin (n + 2)} : X.Î´ (â‡‘fin.cast_succ i) â‰« X.Î´ i = X.Î´ i.succ â‰« X.Î´ i
theorem is_semiring_hom.id {Î± : Type u} [semiring Î±] : is_semiring_hom id
theorem ennreal.infi_mul_of_ne {Î¹ : Sort u_1} {f : Î¹ â†’ ennreal} {x : ennreal} (h0 : x â‰  0) (h : x â‰  âŠ¤) : infi f * x = â¨… (i : Î¹), f i * x
theorem interval_integral.deriv_within_integral_of_tendsto_ae_left {E : Type u_3} [normed_group E] [complete_space E] [normed_space â„ E] {f : â„ â†’ E} {c : E} {a b : â„} (hf : interval_integrable f measure_theory.measure_space.volume a b) {s t : set â„} [interval_integral.FTC_filter a (nhds_within a s) (nhds_within a t)] (hmeas : strongly_measurable_at_filter f (nhds_within a t) measure_theory.measure_space.volume) (ha : filter.tendsto f (nhds_within a t âŠ“ measure_theory.measure_space.volume.ae) (nhds c)) (hs : unique_diff_within_at â„ s a . "unique_diff_within_at_Ici_Iic_univ") : deriv_within (Î» (u : â„), âˆ« (x : â„) in u..b, f x) s a = -c
theorem monoid_algebra.lift_unique {k : Type uâ‚} {G : Type uâ‚‚} [comm_semiring k] [monoid G] {A : Type uâ‚ƒ} [semiring A] [algebra k A] (F : monoid_algebra k G â†’â‚[k] A) (f : monoid_algebra k G) : â‡‘F f = finsupp.sum f (Î» (a : G) (b : k), b â€¢ â‡‘F (finsupp.single a 1))
theorem fib_is_sol_fib_rec {Î± : Type u_1} [comm_semiring Î±] : fib_rec.is_solution (Î» (x : â„•), â†‘(nat.fib x))
theorem category_theory.preadditive.exact_of_iso_of_exact' {V : Type u} [category_theory.category V] [category_theory.limits.has_images V] [category_theory.limits.has_zero_object V] [category_theory.preadditive V] [category_theory.limits.has_kernels V] [category_theory.limits.has_cokernels V] {Aâ‚ Bâ‚ Câ‚ Aâ‚‚ Bâ‚‚ Câ‚‚ : V} (fâ‚ : Aâ‚ âŸ¶ Bâ‚) (gâ‚ : Bâ‚ âŸ¶ Câ‚) (fâ‚‚ : Aâ‚‚ âŸ¶ Bâ‚‚) (gâ‚‚ : Bâ‚‚ âŸ¶ Câ‚‚) (Î± : Aâ‚ â‰… Aâ‚‚) (Î² : Bâ‚ â‰… Bâ‚‚) (Î³ : Câ‚ â‰… Câ‚‚) (hsqâ‚ : Î±.hom â‰« fâ‚‚ = fâ‚ â‰« Î².hom) (hsqâ‚‚ : Î².hom â‰« gâ‚‚ = gâ‚ â‰« Î³.hom) (h : category_theory.exact fâ‚ gâ‚) : category_theory.exact fâ‚‚ gâ‚‚
theorem submodule.torsion_is_torsion {R : Type u_1} {M : Type u_2} [comm_semiring R] [add_comm_monoid M] [module R M] : module.is_torsion R â†¥(submodule.torsion R M)
theorem generalized_tube_lemma {Î± : Type u} {Î² : Type v} [topological_space Î±] [topological_space Î²] {s : set Î±} (hs : is_compact s) {t : set Î²} (ht : is_compact t) {n : set (Î± Ã— Î²)} (hn : is_open n) (hp : s Ã—Ë¢ t âŠ† n) : âˆƒ (u : set Î±) (v : set Î²), is_open u âˆ§ is_open v âˆ§ s âŠ† u âˆ§ t âŠ† v âˆ§ u Ã—Ë¢ v âŠ† n
theorem trans_gen_of_succ_of_ne {Î± : Type u_1} [linear_order Î±] [succ_order Î±] [is_succ_archimedean Î±] (r : Î± â†’ Î± â†’ Prop) {n m : Î±} (h1 : âˆ€ (i : Î±), i âˆˆ set.Ico n m â†’ r i (order.succ i)) (h2 : âˆ€ (i : Î±), i âˆˆ set.Ico m n â†’ r (order.succ i) i) (hnm : n â‰  m) : relation.trans_gen r n m
theorem real.tendsto_div_pow_mul_exp_add_at_top (b c : â„) (n : â„•) (hb : 0 â‰  b) : filter.tendsto (Î» (x : â„), x ^ n / (b * real.exp x + c)) filter.at_top (nhds 0)
theorem metric.cthickening_thickening_subset {Î± : Type u} [pseudo_emetric_space Î±] {Îµ : â„} (hÎµ : 0 â‰¤ Îµ) (Î´ : â„) (s : set Î±) : metric.cthickening Îµ (metric.thickening Î´ s) âŠ† metric.cthickening (Îµ + Î´) s
theorem function.embedding.is_empty_of_card_lt {Î± : Type u_1} {Î² : Type u_2} [fintype Î±] [fintype Î²] (h : fintype.card Î² < fintype.card Î±) : is_empty (Î± â†ª Î²)
theorem minpoly.ne_one (A : Type u_1) {B : Type u_2} [comm_ring A] [ring B] [algebra A B] (x : B) [nontrivial B] : minpoly A x â‰  1
theorem asymptotics.is_o.of_norm_norm {Î± : Type u_1} {E' : Type u_6} {F' : Type u_7} [semi_normed_group E'] [semi_normed_group F'] {f' : Î± â†’ E'} {g' : Î± â†’ F'} {l : filter Î±} : ((Î» (x : Î±), âˆ¥f' xâˆ¥) =o[l] Î» (x : Î±), âˆ¥g' xâˆ¥) â†’ f' =o[l] g'
theorem linear_map.range_prod_eq {R : Type u} {M : Type v} {Mâ‚‚ : Type w} {Mâ‚ƒ : Type y} [ring R] [add_comm_group M] [add_comm_group Mâ‚‚] [add_comm_group Mâ‚ƒ] [module R M] [module R Mâ‚‚] [module R Mâ‚ƒ] {f : M â†’â‚—[R] Mâ‚‚} {g : M â†’â‚—[R] Mâ‚ƒ} (h : f.ker âŠ” g.ker = âŠ¤) : (f.prod g).range = f.range.prod g.range
theorem probability_theory.ident_distrib.measure_preimage_eq {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [measurable_space Î±] [measurable_space Î²] [measurable_space Î³] {Î¼ : measure_theory.measure Î±} {Î½ : measure_theory.measure Î²} {f : Î± â†’ Î³} {g : Î² â†’ Î³} (h : probability_theory.ident_distrib f g Î¼ Î½) {s : set Î³} (hs : measurable_set s) : â‡‘Î¼ (f â»Â¹' s) = â‡‘Î½ (g â»Â¹' s)
theorem interval_integral.integral_has_deriv_within_at_of_tendsto_ae_left {E : Type u_3} [normed_group E] [complete_space E] [normed_space â„ E] {f : â„ â†’ E} {c : E} {a b : â„} (hf : interval_integrable f measure_theory.measure_space.volume a b) {s t : set â„} [interval_integral.FTC_filter a (nhds_within a s) (nhds_within a t)] (hmeas : strongly_measurable_at_filter f (nhds_within a t) measure_theory.measure_space.volume) (ha : filter.tendsto f (nhds_within a t âŠ“ measure_theory.measure_space.volume.ae) (nhds c)) : has_deriv_within_at (Î» (u : â„), âˆ« (x : â„) in u..b, f x) (-c) s a
theorem is_pushout.map {C : Type uâ‚} [category_theory.category C] {D : Type uâ‚‚} [category_theory.category D] (F : C â¥¤ D) {W X Y Z : C} {f : W âŸ¶ X} {g : W âŸ¶ Y} {h : X âŸ¶ Z} {i : Y âŸ¶ Z} [category_theory.limits.preserves_colimit (category_theory.limits.span f g) F] (s : category_theory.is_pushout f g h i) : category_theory.is_pushout (F.map f) (F.map g) (F.map h) (F.map i)
theorem cont_diff_at.to_local_inverse {ğ•‚ : Type u_6} [is_R_or_C ğ•‚] {E' : Type u_7} [normed_group E'] [normed_space ğ•‚ E'] {F' : Type u_8} [normed_group F'] [normed_space ğ•‚ F'] [complete_space E'] {f : E' â†’ F'} {f' : E' â‰ƒL[ğ•‚] F'} {a : E'} {n : with_top â„•} (hf : cont_diff_at ğ•‚ n f a) (hf' : has_fderiv_at f â†‘f' a) (hn : 1 â‰¤ n) : cont_diff_at ğ•‚ n (hf.local_inverse hf' hn) (f a)
theorem function.surjective.dense_range {Î² : Type u_2} [topological_space Î²] {Îº : Type u_5} {f : Îº â†’ Î²} (hf : function.surjective f) : dense_range f
theorem category_theory.functor.right_derived_map_eq {C : Type u} [category_theory.category C] {D : Type u_1} [category_theory.category D] [category_theory.abelian C] [category_theory.has_injective_resolutions C] [category_theory.abelian D] (F : C â¥¤ D) [F.additive] (n : â„•) {X Y : C} (f : Y âŸ¶ X) {P : category_theory.InjectiveResolution X} {Q : category_theory.InjectiveResolution Y} (g : Q.cocomplex âŸ¶ P.cocomplex) (w : Q.Î¹ â‰« g = (cochain_complex.singleâ‚€ C).map f â‰« P.Î¹) : (F.right_derived n).map f = (F.right_derived_obj_iso n Q).hom â‰« (homology_functor D (complex_shape.up â„•) n).map ((F.map_homological_complex (complex_shape.up â„•)).map g) â‰« (F.right_derived_obj_iso n P).inv
theorem basis.card_le_card_of_linear_independent_aux {R : Type u_1} [ring R] [strong_rank_condition R] (n : â„•) {m : â„•} (v : fin m â†’ fin n â†’ R) : linear_independent R v â†’ m â‰¤ n
theorem tendsto_sum_nat_add {Î± : Type u_1} [add_comm_group Î±] [topological_space Î±] [topological_add_group Î±] [t2_space Î±] (f : â„• â†’ Î±) : filter.tendsto (Î» (i : â„•), âˆ‘' (k : â„•), f (k + i)) filter.at_top (nhds 0)
theorem upper_semicontinuous_within_at.add' {Î± : Type u_1} [topological_space Î±] {x : Î±} {s : set Î±} {Î³ : Type u_4} [linear_ordered_add_comm_monoid Î³] [topological_space Î³] [order_topology Î³] {f g : Î± â†’ Î³} (hf : upper_semicontinuous_within_at f s x) (hg : upper_semicontinuous_within_at g s x) (hcont : continuous_at (Î» (p : Î³ Ã— Î³), p.fst + p.snd) (f x, g x)) : upper_semicontinuous_within_at (Î» (z : Î±), f z + g z) s x
theorem algebraic_independent_bounded_of_finset_algebraic_independent_bounded {R : Type u_3} {A : Type u_5} [comm_ring R] [comm_ring A] [algebra R A] {n : â„•} (H : âˆ€ (s : finset A), algebraic_independent R (Î» (i : â†¥s), â†‘i) â†’ s.card â‰¤ n) (s : set A) : algebraic_independent R coe â†’ cardinal.mk â†¥s â‰¤ â†‘n
theorem finset.noncomm_sum_union_of_disjoint {Î± : Type u_1} {Î² : Type u_2} [add_monoid Î²] [decidable_eq Î±] {s t : finset Î±} (h : disjoint s t) (f : Î± â†’ Î²) (comm : âˆ€ (x : Î±), x âˆˆ s âˆª t â†’ âˆ€ (y : Î±), y âˆˆ s âˆª t â†’ add_commute (f x) (f y)) (scomm : (âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (y : Î±), y âˆˆ s â†’ add_commute (f x) (f y)) := _) (tcomm : (âˆ€ (x : Î±), x âˆˆ t â†’ âˆ€ (y : Î±), y âˆˆ t â†’ add_commute (f x) (f y)) := _) : (s âˆª t).noncomm_sum f comm = s.noncomm_sum f scomm + t.noncomm_sum f tcomm
theorem uniform_space.complete_of_cauchy_seq_tendsto {Î± : Type u} [uniform_space Î±] [(uniformity Î±).is_countably_generated] (H' : âˆ€ (u : â„• â†’ Î±), cauchy_seq u â†’ (âˆƒ (a : Î±), filter.tendsto u filter.at_top (nhds a))) : complete_space Î±
theorem euclidean_geometry.reflection_reflection {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] (s : affine_subspace â„ P) [nonempty â†¥s] [complete_space â†¥(s.direction)] (p : P) : â‡‘(euclidean_geometry.reflection s) (â‡‘(euclidean_geometry.reflection s) p) = p
theorem polynomial.bernoulli_eq_sub_sum (n : â„•) : â†‘(n.succ) â€¢ polynomial.bernoulli n = â‡‘(polynomial.monomial n) â†‘(n.succ) - (finset.range n).sum (Î» (k : â„•), â†‘((n + 1).choose k) â€¢ polynomial.bernoulli k)
theorem linear_map.is_Ortho.separating_left_of_not_is_ortho_basis_self {R : Type u_1} {M : Type u_5} {n : Type u_14} [comm_ring R] [add_comm_group M] [module R M] [no_zero_divisors R] {B : M â†’â‚—[R] M â†’â‚—[R] R} (v : basis n R M) (hO : B.is_Ortho â‡‘v) (h : âˆ€ (i : n), Â¬B.is_ortho (â‡‘v i) (â‡‘v i)) : B.separating_left
theorem module.free.rank_matrix' (R : Type u) [ring R] [strong_rank_condition R] (m n : Type v) [fintype m] [fintype n] : module.rank R (matrix m n R) = (cardinal.mk m * cardinal.mk n).lift
theorem add_nonneg {Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : 0 â‰¤ a) (hb : 0 â‰¤ b) : 0 â‰¤ a + b
theorem exists_idempotent_in_compact_subsemigroup {M : Type u_1} [semigroup M] [topological_space M] [t2_space M] (continuous_mul_left : âˆ€ (r : M), continuous (Î» (_x : M), _x * r)) (s : set M) (snemp : s.nonempty) (s_compact : is_compact s) (s_add : âˆ€ (x : M), x âˆˆ s â†’ âˆ€ (y : M), y âˆˆ s â†’ x * y âˆˆ s) : âˆƒ (m : M) (H : m âˆˆ s), m * m = m
theorem orientation.map_eq_neg_iff_det_neg {R : Type u_1} [linear_ordered_field R] {M : Type u_2} [add_comm_group M] [module R M] {Î¹ : Type u_3} [decidable_eq Î¹] [fintype Î¹] [finite_dimensional R M] (x : orientation R M Î¹) (f : M â‰ƒâ‚—[R] M) (h : fintype.card Î¹ = finite_dimensional.finrank R M) : â‡‘(orientation.map Î¹ f) x = -x â†” â‡‘linear_map.det â†‘f < 0
theorem continuous_at_left_of_monotone_on_of_image_mem_nhds_within {Î± : Type u_1} {Î² : Type u_2} [linear_order Î±] [topological_space Î±] [order_topology Î±] [linear_order Î²] [topological_space Î²] [order_topology Î²] [densely_ordered Î²] {f : Î± â†’ Î²} {s : set Î±} {a : Î±} (h_mono : monotone_on f s) (hs : s âˆˆ nhds_within a (set.Iic a)) (hfs : f '' s âˆˆ nhds_within (f a) (set.Iic (f a))) : continuous_within_at f (set.Iic a) a
theorem mul_left_bound {Î± : Type u_1} [non_unital_semi_normed_ring Î±] (x y : Î±) : âˆ¥â‡‘(add_monoid_hom.mul_left x) yâˆ¥ â‰¤ âˆ¥xâˆ¥ * âˆ¥yâˆ¥
theorem colex.singleton_lt_iff_lt {Î± : Type u_1} [linear_order Î±] {r s : Î±} : {r}.to_colex < {s}.to_colex â†” r < s
theorem Top.presheaf.is_sheaf_punit {X : Top} (F : Top.presheaf (category_theory.discrete punit) X) : F.is_sheaf
theorem complex.differentiable_on_update_lim_of_bdd_above {E : Type u} [normed_group E] [normed_space â„‚ E] [complete_space E] {f : â„‚ â†’ E} {s : set â„‚} {c : â„‚} (hc : s âˆˆ nhds c) (hd : differentiable_on â„‚ f (s  {c})) (hb : bdd_above (has_norm.norm âˆ˜ f '' (s  {c}))) : differentiable_on â„‚ (function.update f c (lim (nhds_within c {c}á¶œ) f)) s
theorem is_compact.inter_left {Î± : Type u} [topological_space Î±] {s t : set Î±} (ht : is_compact t) (hs : is_closed s) : is_compact (s âˆ© t)
theorem dihedral_group.card {n : â„•} [fact (0 < n)] : fintype.card (dihedral_group n) = 2 * n
theorem exists_compact_superset {Î± : Type u} [topological_space Î±] [locally_compact_space Î±] {K : set Î±} (hK : is_compact K) : âˆƒ (K' : set Î±), is_compact K' âˆ§ K âŠ† interior K'
theorem finprod_div_distrib {Î± : Type u_1} {G : Type u_4} [division_comm_monoid G] {f g : Î± â†’ G} (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) : finprod (Î» (i : Î±), f i / g i) = finprod (Î» (i : Î±), f i) / finprod (Î» (i : Î±), g i)
theorem finset.sum_subtype_eq_sum_filter {Î² : Type u} {Î± : Type v} {s : finset Î±} [add_comm_monoid Î²] (f : Î± â†’ Î²) {p : Î± â†’ Prop} [decidable_pred p] : (finset.subtype p s).sum (Î» (x : subtype p), f â†‘x) = (finset.filter p s).sum (Î» (x : Î±), f x)
theorem filter.map_at_top_eq_of_gc {Î± : Type u_3} {Î² : Type u_4} [semilattice_sup Î±] [semilattice_sup Î²] {f : Î± â†’ Î²} (g : Î² â†’ Î±) (b' : Î²) (hf : monotone f) (gc : âˆ€ (a : Î±) (b : Î²), b â‰¥ b' â†’ (f a â‰¤ b â†” a â‰¤ g b)) (hgi : âˆ€ (b : Î²), b â‰¥ b' â†’ b â‰¤ f (g b)) : filter.map f filter.at_top = filter.at_top
theorem mul_nonneg_of_three {Î± : Type u} [linear_ordered_ring Î±] (a b c : Î±) : 0 â‰¤ a * b âˆ¨ 0 â‰¤ b * c âˆ¨ 0 â‰¤ c * a
theorem monovary_on.sum_comp_perm_mul_le_sum_mul {Î¹ : Type u_1} {Î± : Type u_2} [linear_ordered_ring Î±] {s : finset Î¹} {Ïƒ : equiv.perm Î¹} {f g : Î¹ â†’ Î±} (hfg : monovary_on f g â†‘s) (hÏƒ : {x : Î¹ | â‡‘Ïƒ x â‰  x} âŠ† â†‘s) : s.sum (Î» (i : Î¹), f (â‡‘Ïƒ i) * g i) â‰¤ s.sum (Î» (i : Î¹), f i * g i)
theorem class_group.exists_mem_finset_approx' {R : Type u_1} {S : Type u_2} (L : Type u_4) [euclidean_domain R] [comm_ring S] [is_domain S] [field L] [algRL : algebra R L] [algebra R S] [algebra S L] [ist : is_scalar_tower R S L] [iic : is_integral_closure S R L] {abv : absolute_value R â„¤} {Î¹ : Type u_5} [decidable_eq Î¹] [fintype Î¹] (bS : basis Î¹ R S) (adm : abv.is_admissible) [infinite R] [decidable_eq R] (h : algebra.is_algebraic R L) (a : S) {b : S} (hb : b â‰  0) : âˆƒ (q : S) (r : R) (H : r âˆˆ class_group.finset_approx bS adm), â‡‘abv (â‡‘(algebra.norm R) (r â€¢ a - q * b)) < â‡‘abv (â‡‘(algebra.norm R) b)
theorem bdd_above.union {Î³ : Type w} [semilattice_sup Î³] {s t : set Î³} : bdd_above s â†’ bdd_above t â†’ bdd_above (s âˆª t)
theorem image_norm_le_of_norm_deriv_right_lt_deriv_boundary {E : Type u_1} [normed_group E] [normed_space â„ E] {f : â„ â†’ E} {a b : â„} {f' : â„ â†’ E} (hf : continuous_on f (set.Icc a b)) (hf' : âˆ€ (x : â„), x âˆˆ set.Ico a b â†’ has_deriv_within_at f (f' x) (set.Ici x) x) {B B' : â„ â†’ â„} (ha : âˆ¥f aâˆ¥ â‰¤ B a) (hB : âˆ€ (x : â„), has_deriv_at B (B' x) x) (bound : âˆ€ (x : â„), x âˆˆ set.Ico a b â†’ âˆ¥f xâˆ¥ = B x â†’ âˆ¥f' xâˆ¥ < B' x) â¦ƒx : â„â¦„ : x âˆˆ set.Icc a b â†’ âˆ¥f xâˆ¥ â‰¤ B x
theorem bdd_below_union {Î³ : Type w} [semilattice_inf Î³] {s t : set Î³} : bdd_below (s âˆª t) â†” bdd_below s âˆ§ bdd_below t
theorem category_theory.arrow.square_from_iso_invert {T : Type u} [category_theory.category T] {X Y : T} (i : X â‰… Y) (p : category_theory.arrow T) (sq : category_theory.arrow.mk i.hom âŸ¶ p) : i.inv â‰« sq.left â‰« p.hom = sq.right
theorem ring.inverse_invertible {Î± : Type u} [monoid_with_zero Î±] (x : Î±) [invertible x] : ring.inverse x = â…Ÿ x
theorem is_cyclotomic_extension.zeta_primitive_root (n : â„•+) (A : Type w) (B : Type z) [comm_ring A] [comm_ring B] [algebra A B] [is_cyclotomic_extension {n} A B] [is_domain B] [ne_zero â†‘â†‘n] : is_primitive_root (is_cyclotomic_extension.zeta n A B) â†‘n
theorem has_compact_support.continuous_convolution_left_of_integrable {ğ•œ : Type u_1} {G : Type u_2} {E : Type u_3} {E' : Type u_4} {F : Type u_6} [normed_group E] [normed_group E'] [normed_group F] {f : G â†’ E} {g : G â†’ E'} [nondiscrete_normed_field ğ•œ] [normed_space ğ•œ E] [normed_space ğ•œ E'] [normed_space ğ•œ F] (L : E â†’L[ğ•œ] E' â†’L[ğ•œ] F) [measurable_space G] {Î¼ : measure_theory.measure G} [normed_space â„ F] [complete_space F] [add_comm_group G] [topological_space G] [topological_add_group G] [borel_space G] [Î¼.is_add_left_invariant] [Î¼.is_neg_invariant] [topological_space.second_countable_topology G] (hcf : has_compact_support f) (hf : continuous f) (hg : measure_theory.integrable g Î¼) : continuous (convolution f g L Î¼)
theorem lower_semicontinuous_at.add' {Î± : Type u_1} [topological_space Î±] {x : Î±} {Î³ : Type u_4} [linear_ordered_add_comm_monoid Î³] [topological_space Î³] [order_topology Î³] {f g : Î± â†’ Î³} (hf : lower_semicontinuous_at f x) (hg : lower_semicontinuous_at g x) (hcont : continuous_at (Î» (p : Î³ Ã— Î³), p.fst + p.snd) (f x, g x)) : lower_semicontinuous_at (Î» (z : Î±), f z + g z) x
theorem module.free.finrank_pi (R : Type u) [ring R] [strong_rank_condition R] {Î¹ : Type v} [fintype Î¹] : finite_dimensional.finrank R (Î¹ â†’ R) = fintype.card Î¹
theorem finset.exists_card_fiber_lt_of_card_lt_mul {Î± : Type u} {Î² : Type v} [decidable_eq Î²] {s : finset Î±} {t : finset Î²} {f : Î± â†’ Î²} {n : â„•} (hn : s.card < t.card * n) : âˆƒ (y : Î²) (H : y âˆˆ t), (finset.filter (Î» (x : Î±), f x = y) s).card < n
theorem category_theory.limits.limits_from_equalizers_and_products {C : Type u} [category_theory.category C] [category_theory.limits.has_products C] [category_theory.limits.has_equalizers C] : category_theory.limits.has_limits C
theorem finset.sum_smul_const_vsub_eq_neg_weighted_vsub {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {Î¹ : Type u_4} (s : finset Î¹) (w : Î¹ â†’ k) (pâ‚‚ : Î¹ â†’ P) (pâ‚ : P) (h : s.sum (Î» (i : Î¹), w i) = 0) : s.sum (Î» (i : Î¹), w i â€¢ (pâ‚ -áµ¥ pâ‚‚ i)) = -â‡‘(s.weighted_vsub pâ‚‚) w
theorem fixing_subgroup_union (M : Type u_1) (Î± : Type u_2) [group M] [mul_action M Î±] {s t : set Î±} : fixing_subgroup M (s âˆª t) = fixing_subgroup M s âŠ“ fixing_subgroup M t
theorem monotone.antitone_iterate_of_map_le {Î± : Type u_1} [preorder Î±] {f : Î± â†’ Î±} {x : Î±} (hf : monotone f) (hx : f x â‰¤ x) : antitone (Î» (n : â„•), f^[n] x)
theorem category_theory.limits.has_binary_products_of_has_limit_pair (C : Type u) [category_theory.category C] [âˆ€ {X Y : C}, category_theory.limits.has_limit (category_theory.limits.pair X Y)] : category_theory.limits.has_binary_products C
theorem topological_space.subset_trans {X : Type u_1} [tX : topological_space X] {s t : set X} (ts : t âŠ† s) : subtype.topological_space = topological_space.induced (set.inclusion ts) subtype.topological_space
theorem padic_val_rat.neg {p : â„•} (q : â„š) : padic_val_rat p (-q) = padic_val_rat p q
theorem affine_subspace.inter_eq_singleton_of_nonempty_of_is_compl {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {s1 s2 : affine_subspace k P} (h1 : â†‘s1.nonempty) (h2 : â†‘s2.nonempty) (hd : is_compl s1.direction s2.direction) : âˆƒ (p : P), â†‘s1 âˆ© â†‘s2 = {p}
theorem cont_mdiff_at.comp {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners ğ•œ E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] {f : M â†’ M'} {n : with_top â„•} {E'' : Type u_14} [normed_group E''] [normed_space ğ•œ E''] {H'' : Type u_15} [topological_space H''] {I'' : model_with_corners ğ•œ E'' H''} {M'' : Type u_16} [topological_space M''] [charted_space H'' M''] {g : M' â†’ M''} (x : M) (hg : cont_mdiff_at I' I'' n g (f x)) (hf : cont_mdiff_at I I' n f x) : cont_mdiff_at I I'' n (g âˆ˜ f) x
theorem star_convex.affine_preimage {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [ordered_ring ğ•œ] [add_comm_group E] [add_comm_group F] [module ğ•œ E] [module ğ•œ F] {x : E} (f : E â†’áµƒ[ğ•œ] F) {s : set F} (hs : star_convex ğ•œ (â‡‘f x) s) : star_convex ğ•œ x (â‡‘f â»Â¹' s)
theorem antitone.tendsto_alternating_series_of_tendsto_zero {f : â„• â†’ â„} (hfa : antitone f) (hf0 : filter.tendsto f filter.at_top (nhds 0)) : âˆƒ (l : â„), filter.tendsto (Î» (n : â„•), (finset.range (n + 1)).sum (Î» (i : â„•), (-1) ^ i * f i)) filter.at_top (nhds l)
theorem add_submonoid.bsupr_eq_mrange_dfinsupp_sum_add_hom {Î¹ : Type u} {Î³ : Type w} [dec : decidable_eq Î¹] (p : Î¹ â†’ Prop) [decidable_pred p] [add_comm_monoid Î³] (S : Î¹ â†’ add_submonoid Î³) : (â¨† (i : Î¹) (h : p i), S i) = ((dfinsupp.sum_add_hom (Î» (i : Î¹), (S i).subtype)).comp (dfinsupp.filter_add_monoid_hom (Î» (i : Î¹), â†¥(S i)) p)).mrange
theorem finset.filter_false_of_mem {Î± : Type u_1} {p : Î± â†’ Prop} [decidable_pred p] {s : finset Î±} (h : âˆ€ (x : Î±), x âˆˆ s â†’ Â¬p x) : finset.filter p s = âˆ…
theorem nat.eq_zero_of_dvd_of_lt {a b : â„•} (w : a âˆ£ b) (h : b < a) : b = 0
theorem generalized_continued_fraction.of_denom_mono {K : Type u_1} {v : K} {n : â„•} [linear_ordered_field K] [floor_ring K] : (generalized_continued_fraction.of v).denominators n â‰¤ (generalized_continued_fraction.of v).denominators (n + 1)
theorem one_hom.coe_inj {M : Type u_3} {N : Type u_4} [has_one M] [has_one N] â¦ƒf g : one_hom M Nâ¦„ (h : â‡‘f = â‡‘g) : f = g
theorem add_commute.eq {S : Type u_1} [has_add S] {a b : S} (h : add_commute a b) : a + b = b + a
theorem generate_from_eq_pi {Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_3} [fintype Î¹] [h : Î  (i : Î¹), measurable_space (Î± i)] {C : Î  (i : Î¹), set (set (Î± i))} (hC : âˆ€ (i : Î¹), measurable_space.generate_from (C i) = h i) (h2C : âˆ€ (i : Î¹), is_countably_spanning (C i)) : measurable_space.generate_from (set.univ.pi '' set.univ.pi C) = measurable_space.pi
theorem span_fourier_Lp_closure_eq_top {p : ennreal} [fact (1 â‰¤ p)] (hp : p â‰  âŠ¤) : (submodule.span â„‚ (set.range (fourier_Lp p))).topological_closure = âŠ¤
theorem is_lower_set.to_dual {Î± : Type u_1} [has_le Î±] {s : set Î±áµ’áµˆ} : is_lower_set s â†’ is_upper_set (â‡‘order_dual.to_dual â»Â¹' s)
theorem ultrafilter_extend_eq_iff {Î± : Type u} {Î³ : Type u_1} [topological_space Î³] [t2_space Î³] [compact_space Î³] {f : Î± â†’ Î³} {b : ultrafilter Î±} {c : Î³} : ultrafilter.extend f b = c â†” â†‘(ultrafilter.map f b) â‰¤ nhds c
theorem polynomial.order_of_root_cyclotomic_dvd {n : â„•} (hpos : 0 < n) {p : â„•} [fact (nat.prime p)] {a : â„•} (hroot : (polynomial.cyclotomic n (zmod p)).is_root (â‡‘(nat.cast_ring_hom (zmod p)) a)) : order_of (zmod.unit_of_coprime a _) âˆ£ n
theorem continuous_at_of_monotone_on_of_closure_image_mem_nhds {Î± : Type u_1} {Î² : Type u_2} [linear_order Î±] [topological_space Î±] [order_topology Î±] [linear_order Î²] [topological_space Î²] [order_topology Î²] [densely_ordered Î²] {f : Î± â†’ Î²} {s : set Î±} {a : Î±} (h_mono : monotone_on f s) (hs : s âˆˆ nhds a) (hfs : closure (f '' s) âˆˆ nhds (f a)) : continuous_at f a
theorem monoid_algebra.of_mem_span_of_iff {R : Type u_1} {M : Type u_2} [comm_ring R] [comm_monoid M] [nontrivial R] {m : M} {S : set M} : â‡‘(monoid_algebra.of R M) m âˆˆ submodule.span R (â‡‘(monoid_algebra.of R M) '' S) â†” m âˆˆ S
theorem geom_gold_is_sol_fib_rec  : fib_rec.is_solution (has_pow.pow golden_ratio)
theorem ideal.ideal_prod_eq {R : Type u} {S : Type v} [ring R] [ring S] (I : ideal (R Ã— S)) : I = (ideal.map (ring_hom.fst R S) I).prod (ideal.map (ring_hom.snd R S) I)
theorem tangent_cone_at.lim_zero {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {y : E} {Î± : Type u_3} (l : filter Î±) {c : Î± â†’ ğ•œ} {d : Î± â†’ E} (hc : filter.tendsto (Î» (n : Î±), âˆ¥c nâˆ¥) l filter.at_top) (hd : filter.tendsto (Î» (n : Î±), c n â€¢ d n) l (nhds y)) : filter.tendsto d l (nhds 0)
theorem Top.presheaf.covering_of_presieve.first_obj_iso_comp_right_res_eq {C : Type u} [category_theory.category C] [category_theory.limits.has_products C] {X : Top} (F : Top.presheaf C X) (U : topological_space.opens â†¥X) (R : category_theory.presieve U) : category_theory.presheaf.second_map R F â‰« (Top.presheaf.covering_of_presieve.second_obj_iso_pi_inters F U R).hom = (Top.presheaf.covering_of_presieve.first_obj_iso_pi_opens F U R).hom â‰« Top.presheaf.sheaf_condition_equalizer_products.right_res F (Top.presheaf.covering_of_presieve U R)
theorem metric.diam_le_of_forall_dist_le_of_nonempty {Î± : Type u} [pseudo_metric_space Î±] {s : set Î±} (hs : s.nonempty) {C : â„} (h : âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (y : Î±), y âˆˆ s â†’ has_dist.dist x y â‰¤ C) : metric.diam s â‰¤ C
theorem box_integral.prepartition.bUnion_index_of_mem {Î¹ : Type u_1} {I J : box_integral.box Î¹} (Ï€ : box_integral.prepartition I) {Ï€i : Î  (J : box_integral.box Î¹), box_integral.prepartition J} (hJ : J âˆˆ Ï€) {J' : box_integral.box Î¹} (hJ' : J' âˆˆ Ï€i J) : Ï€.bUnion_index Ï€i J' = J
theorem summable_one_div_pow_of_le {m : â„} {f : â„• â†’ â„•} (hm : 1 < m) (fi : âˆ€ (i : â„•), i â‰¤ f i) : summable (Î» (i : â„•), 1 / m ^ f i)
theorem set.inv_on.bij_on {Î± : Type u} {Î² : Type v} {s : set Î±} {t : set Î²} {f : Î± â†’ Î²} {f' : Î² â†’ Î±} (h : set.inv_on f' f s t) (hf : set.maps_to f s t) (hf' : set.maps_to f' t s) : set.bij_on f s t
theorem finset.sup_indep.sup {Î± : Type u_1} {Î¹ : Type u_3} {Î¹' : Type u_4} [distrib_lattice Î±] [order_bot Î±] [decidable_eq Î¹] {s : finset Î¹'} {g : Î¹' â†’ finset Î¹} {f : Î¹ â†’ Î±} (hs : s.sup_indep (Î» (i : Î¹'), (g i).sup f)) (hg : âˆ€ (i' : Î¹'), i' âˆˆ s â†’ (g i').sup_indep f) : (s.sup g).sup_indep f
theorem exp_add_of_commute_of_mem_ball {ğ•‚ : Type u_1} {ğ”¸ : Type u_2} [nondiscrete_normed_field ğ•‚] [normed_ring ğ”¸] [normed_algebra ğ•‚ ğ”¸] [complete_space ğ”¸] [char_zero ğ•‚] {x y : ğ”¸} (hxy : commute x y) (hx : x âˆˆ emetric.ball 0 (exp_series ğ•‚ ğ”¸).radius) (hy : y âˆˆ emetric.ball 0 (exp_series ğ•‚ ğ”¸).radius) : exp ğ•‚ (x + y) = exp ğ•‚ x * exp ğ•‚ y
theorem probability_theory.indep_fun_iff_integral_comp_mul {Î± : Type u_1} {mÎ± : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [measure_theory.is_finite_measure Î¼] {Î² : Type u_2} {Î²' : Type u_3} {mÎ² : measurable_space Î²} {mÎ²' : measurable_space Î²'} {f : Î± â†’ Î²} {g : Î± â†’ Î²'} {hfm : measurable f} {hgm : measurable g} : probability_theory.indep_fun f g Î¼ â†” âˆ€ {Ï† : Î² â†’ â„} {Ïˆ : Î²' â†’ â„}, measurable Ï† â†’ measurable Ïˆ â†’ measure_theory.integrable (Ï† âˆ˜ f) Î¼ â†’ measure_theory.integrable (Ïˆ âˆ˜ g) Î¼ â†’ measure_theory.integral Î¼ (Ï† âˆ˜ f * Ïˆ âˆ˜ g) = measure_theory.integral Î¼ (Ï† âˆ˜ f) * measure_theory.integral Î¼ (Ïˆ âˆ˜ g)
theorem nat.filter_Ico_card_eq_of_periodic (n a : â„•) (p : â„• â†’ Prop) [decidable_pred p] (pp : function.periodic p a) : (finset.filter p (finset.Ico n (n + a))).card = nat.count p a
theorem local_homeomorph.is_image.symm_preimage_eq' {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] {e : local_homeomorph Î± Î²} {s : set Î±} {t : set Î²} : e.is_image s t â†’ e.to_local_equiv.target âˆ© â‡‘(e.symm) â»Â¹' (e.to_local_equiv.source âˆ© s) = e.to_local_equiv.target âˆ© t
theorem polynomial.sum_roots_eq_next_coeff_of_monic_of_split {K : Type v} [field K] {P : polynomial K} (hmo : P.monic) (hP : polynomial.splits (ring_hom.id K) P) : P.next_coeff = -P.roots.sum
theorem metric.bounded_ball {Î± : Type u} [pseudo_metric_space Î±] {x : Î±} {r : â„} : metric.bounded (metric.ball x r)
theorem has_deriv_at_iff_has_fderiv_at {ğ•œ : Type u} [nondiscrete_normed_field ğ•œ] {F : Type v} [normed_group F] [normed_space ğ•œ F] {f : ğ•œ â†’ F} {x : ğ•œ} {f' : F} : has_deriv_at f f' x â†” has_fderiv_at f (1.smul_right f') x
theorem multilinear_map.norm_image_sub_le_of_bound' {ğ•œ : Type u} {Î¹ : Type v} {E : Î¹ â†’ Type wE} {G : Type wG} [decidable_eq Î¹] [fintype Î¹] [nondiscrete_normed_field ğ•œ] [Î  (i : Î¹), normed_group (E i)] [Î  (i : Î¹), normed_space ğ•œ (E i)] [normed_group G] [normed_space ğ•œ G] (f : multilinear_map ğ•œ E G) {C : â„} (hC : 0 â‰¤ C) (H : âˆ€ (m : Î  (i : Î¹), E i), âˆ¥â‡‘f mâˆ¥ â‰¤ C * finset.univ.prod (Î» (i : Î¹), âˆ¥m iâˆ¥)) (mâ‚ mâ‚‚ : Î  (i : Î¹), E i) : âˆ¥â‡‘f mâ‚ - â‡‘f mâ‚‚âˆ¥ â‰¤ C * finset.univ.sum (Î» (i : Î¹), finset.univ.prod (Î» (j : Î¹), ite (j = i) âˆ¥mâ‚ i - mâ‚‚ iâˆ¥ (linear_order.max âˆ¥mâ‚ jâˆ¥ âˆ¥mâ‚‚ jâˆ¥)))
theorem local_equiv.is_image.of_symm_preimage_eq {Î± : Type u_1} {Î² : Type u_2} {e : local_equiv Î± Î²} {s : set Î±} {t : set Î²} : e.target âˆ© â‡‘(e.symm) â»Â¹' s = e.target âˆ© t â†’ e.is_image s t
theorem linear_map.trace_eq_contract (R : Type u_1) [comm_ring R] (M : Type u_2) [add_comm_group M] [module R M] [module.free R M] [module.finite R M] [nontrivial R] : (linear_map.trace R M).comp (dual_tensor_hom R M M) = contract_left R M
theorem finset.mem_up_shadow_iff {Î± : Type u_1} [decidable_eq Î±] [fintype Î±] {ğ’œ : finset (finset Î±)} {s : finset Î±} : s âˆˆ ğ’œ.up_shadow â†” âˆƒ (t : finset Î±) (H : t âˆˆ ğ’œ) (a : Î±) (H : a âˆ‰ t), has_insert.insert a t = s
theorem topological_space.compacts.equiv_to_fun_val {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] (f : Î± â‰ƒâ‚œ Î²) (K : topological_space.compacts Î±) : (â‡‘(topological_space.compacts.equiv f) K).carrier = â‡‘(f.symm) â»Â¹' K.carrier
theorem coe_fn_coe_base' {Î± : Sort u_1} {Î² : Sort u_2} {Î³ : out_param (Sort u_3)} [has_coe Î± Î²] [has_coe_to_fun Î² (Î» (_x : Î²), Î³)] (x : Î±) : â‡‘x = â‡‘â†‘x
theorem nat.factors_mul_to_finset {a b : â„•} (ha : a â‰  0) (hb : b â‰  0) : (a * b).factors.to_finset = a.factors.to_finset âˆª b.factors.to_finset
theorem set.Ioi_subset_Ioi {Î± : Type u_1} [preorder Î±] {a b : Î±} (h : a â‰¤ b) : set.Ioi b âŠ† set.Ioi a
theorem linear_order.strict_convex_on_of_lt {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [ordered_semiring ğ•œ] [add_comm_monoid E] [ordered_add_comm_monoid Î²] [module ğ•œ E] [module ğ•œ Î²] [linear_order E] {s : set E} {f : E â†’ Î²} (hs : convex ğ•œ s) (hf : âˆ€ â¦ƒx y : Eâ¦„, x âˆˆ s â†’ y âˆˆ s â†’ x < y â†’ âˆ€ â¦ƒa b : ğ•œâ¦„, 0 < a â†’ 0 < b â†’ a + b = 1 â†’ f (a â€¢ x + b â€¢ y) < a â€¢ f x + b â€¢ f y) : strict_convex_on ğ•œ s f
theorem mul_action.card_eq_sum_card_group_div_card_stabilizer' (Î± : Type u) (Î² : Type v) [group Î±] [mul_action Î± Î²] [fintype Î±] [fintype Î²] [fintype (quotient (mul_action.orbit_rel Î± Î²))] [Î  (b : Î²), fintype â†¥(mul_action.stabilizer Î± b)] {Ï† : quotient (mul_action.orbit_rel Î± Î²) â†’ Î²} (hÏ† : function.left_inverse quotient.mk' Ï†) : fintype.card Î² = finset.univ.sum (Î» (Ï‰ : quotient (mul_action.orbit_rel Î± Î²)), fintype.card Î± / fintype.card â†¥(mul_action.stabilizer Î± (Ï† Ï‰)))
theorem antitone_on.dual_left {Î± : Type u} {Î² : Type v} [preorder Î±] [preorder Î²] {f : Î± â†’ Î²} {s : set Î±} : antitone_on f s â†’ monotone_on (f âˆ˜ â‡‘order_dual.of_dual) s
theorem has_sbtw.sbtw.cyclic_left {Î± : Type u_1} [circular_preorder Î±] {a b c : Î±} (h : has_sbtw.sbtw a b c) : has_sbtw.sbtw b c a
theorem interval_integral.integral_has_deriv_at_of_tendsto_ae_left {E : Type u_3} [normed_group E] [complete_space E] [normed_space â„ E] {f : â„ â†’ E} {c : E} {a b : â„} (hf : interval_integrable f measure_theory.measure_space.volume a b) (hmeas : strongly_measurable_at_filter f (nhds a) measure_theory.measure_space.volume) (ha : filter.tendsto f (nhds a âŠ“ measure_theory.measure_space.volume.ae) (nhds c)) : has_deriv_at (Î» (u : â„), âˆ« (x : â„) in u..b, f x) (-c) a
theorem filter.tendsto.at_bot_mul_const' {Î± : Type u_1} {R : Type u_2} {l : filter Î±} {f : Î± â†’ R} {r : R} [linear_ordered_ring R] [archimedean R] (hr : 0 < r) (hf : filter.tendsto f l filter.at_bot) : filter.tendsto (Î» (x : Î±), f x * r) l filter.at_bot
theorem set.image2_image_left_anticomm {Î± : Type u_1} {Î±' : Type u_2} {Î² : Type u_3} {Î³ : Type u_5} {Î´ : Type u_7} {s : set Î±} {t : set Î²} {f : Î±' â†’ Î² â†’ Î³} {g : Î± â†’ Î±'} {f' : Î² â†’ Î± â†’ Î´} {g' : Î´ â†’ Î³} (h_left_anticomm : âˆ€ (a : Î±) (b : Î²), f (g a) b = g' (f' b a)) : set.image2 f (g '' s) t = g' '' set.image2 f' t s
theorem intermediate_value_interval {Î± : Type u} [conditionally_complete_linear_order Î±] [topological_space Î±] [order_topology Î±] [densely_ordered Î±] {Î´ : Type u_1} [linear_order Î´] [topological_space Î´] [order_closed_topology Î´] {a b : Î±} {f : Î± â†’ Î´} (hf : continuous_on f (set.interval a b)) : set.interval (f a) (f b) âŠ† f '' set.interval a b
theorem pnat.exists_eq_succ_of_ne_one {n : â„•+} (h1 : n â‰  1) : âˆƒ (k : â„•+), n = k + 1
theorem differentiable_on.mdifferentiable_on {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {E' : Type u_3} [normed_group E'] [normed_space ğ•œ E'] {f : E â†’ E'} {s : set E} : differentiable_on ğ•œ f s â†’ mdifferentiable_on (model_with_corners_self ğ•œ E) (model_with_corners_self ğ•œ E') f s
theorem submodule.finrank_quotient_add_finrank {K : Type u} {V : Type v} [field K] [add_comm_group V] [module K V] [finite_dimensional K V] (s : submodule K V) : finite_dimensional.finrank K (V â§¸ s) + finite_dimensional.finrank K â†¥s = finite_dimensional.finrank K V
theorem cocompact_map.compact_preimage {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] [t2_space Î²] (f : cocompact_map Î± Î²) â¦ƒs : set Î²â¦„ (hs : is_compact s) : is_compact (â‡‘f â»Â¹' s)
theorem local_homeomorph.continuous_within_at_iff_continuous_within_at_comp_right {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [topological_space Î±] [topological_space Î²] [topological_space Î³] (e : local_homeomorph Î± Î²) {f : Î² â†’ Î³} {s : set Î²} {x : Î²} (h : x âˆˆ e.to_local_equiv.target) : continuous_within_at f s x â†” continuous_within_at (f âˆ˜ â‡‘e) (â‡‘e â»Â¹' s) (â‡‘(e.symm) x)
theorem minpoly.ne_zero {A : Type u_1} {B : Type u_2} [comm_ring A] [ring B] [algebra A B] {x : B} [nontrivial A] (hx : is_integral A x) : minpoly A x â‰  0
theorem set.mem_bUnion {Î± : Type u_1} {Î² : Type u_2} {s : set Î±} {t : Î± â†’ set Î²} {x : Î±} {y : Î²} (xs : x âˆˆ s) (ytx : y âˆˆ t x) : y âˆˆ â‹ƒ (x : Î±) (H : x âˆˆ s), t x
theorem witt_structure_rat_rec (p : â„•) {idx : Type u_2} [hp : fact (nat.prime p)] (Î¦ : mv_polynomial idx â„š) (n : â„•) : witt_structure_rat p Î¦ n = â‡‘mv_polynomial.C (1 / â†‘p ^ n) * (â‡‘(mv_polynomial.bindâ‚ (Î» (b : idx), â‡‘(mv_polynomial.rename (Î» (i : â„•), (b, i))) (witt_polynomial p â„š n))) Î¦ - (finset.range n).sum (Î» (i : â„•), â‡‘mv_polynomial.C (â†‘p ^ i) * witt_structure_rat p Î¦ i ^ p ^ (n - i)))
theorem measure_theory.measure_lt_top_of_is_compact_of_is_add_left_invariant {G : Type u_1} [measurable_space G] [topological_space G] [borel_space G] {Î¼ : measure_theory.measure G} [add_group G] [topological_add_group G] [Î¼.is_add_left_invariant] (U : set G) (hU : is_open U) (h'U : U.nonempty) (h : â‡‘Î¼ U â‰  âŠ¤) {K : set G} (hK : is_compact K) : â‡‘Î¼ K < âŠ¤
theorem combo_mem_ball_of_ne {E : Type u_2} [normed_group E] [normed_space â„ E] [strict_convex_space â„ E] {x y z : E} {a b r : â„} (hx : x âˆˆ metric.closed_ball z r) (hy : y âˆˆ metric.closed_ball z r) (hne : x â‰  y) (ha : 0 < a) (hb : 0 < b) (hab : a + b = 1) : a â€¢ x + b â€¢ y âˆˆ metric.ball z r
theorem continuous_at.snd {Î± : Type u} {Î² : Type v} {Î³ : Type u_1} [topological_space Î±] [topological_space Î²] [topological_space Î³] {f : Î± â†’ Î² Ã— Î³} {x : Î±} (hf : continuous_at f x) : continuous_at (Î» (a : Î±), (f a).snd) x
theorem affine_map.map_vadd {k : Type u_1} {V1 : Type u_2} {P1 : Type u_3} {V2 : Type u_4} {P2 : Type u_5} [ring k] [add_comm_group V1] [module k V1] [add_torsor V1 P1] [add_comm_group V2] [module k V2] [add_torsor V2 P2] (f : P1 â†’áµƒ[k] P2) (p : P1) (v : V1) : â‡‘f (v +áµ¥ p) = â‡‘(f.linear) v +áµ¥ â‡‘f p
theorem linear_map.separating_right_iff_flip_ker_eq_bot {R : Type u_1} {Râ‚ : Type u_2} {Râ‚‚ : Type u_3} {Mâ‚ : Type u_6} {Mâ‚‚ : Type u_7} [comm_semiring R] [comm_semiring Râ‚] [add_comm_monoid Mâ‚] [module Râ‚ Mâ‚] [comm_semiring Râ‚‚] [add_comm_monoid Mâ‚‚] [module Râ‚‚ Mâ‚‚] {Iâ‚ : Râ‚ â†’+* R} {Iâ‚‚ : Râ‚‚ â†’+* R} {B : Mâ‚ â†’â‚›â‚—[Iâ‚] Mâ‚‚ â†’â‚›â‚—[Iâ‚‚] R} : B.separating_right â†” B.flip.ker = âŠ¥
theorem category_theory.is_iso_of_regular_mono_of_epi {C : Type uâ‚} [category_theory.category C] {X Y : C} (f : X âŸ¶ Y) [category_theory.regular_mono f] [e : category_theory.epi f] : category_theory.is_iso f
theorem linear_map.adjoint_comp {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] [inner_product_space ğ•œ F] [inner_product_space ğ•œ G] [finite_dimensional ğ•œ E] [finite_dimensional ğ•œ F] [finite_dimensional ğ•œ G] (A : F â†’â‚—[ğ•œ] G) (B : E â†’â‚—[ğ•œ] F) : â‡‘linear_map.adjoint (A.comp B) = (â‡‘linear_map.adjoint B).comp (â‡‘linear_map.adjoint A)
theorem comm_group.nilpotency_class_le_one {G : Type u_1} [comm_group G] : group.nilpotency_class G â‰¤ 1
theorem category_theory.limits.types.coequalizer_preimage_image_eq_of_preimage_eq {X Y Z : Type u} (f g : X âŸ¶ Y) (Ï€ : Y âŸ¶ Z) (e : f â‰« Ï€ = g â‰« Ï€) (h : category_theory.limits.is_colimit (category_theory.limits.cofork.of_Ï€ Ï€ e)) (U : set Y) (H : f â»Â¹' U = g â»Â¹' U) : Ï€ â»Â¹' (Ï€ '' U) = U
theorem neg_lt_of_neg_lt {Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b : Î±} : -a < b â†’ -b < a
theorem inner_sum_smul_sum_smul_of_sum_eq_zero {F : Type u_3} [inner_product_space â„ F] {Î¹â‚ : Type u_1} {sâ‚ : finset Î¹â‚} {wâ‚ : Î¹â‚ â†’ â„} (vâ‚ : Î¹â‚ â†’ F) (hâ‚ : sâ‚.sum (Î» (i : Î¹â‚), wâ‚ i) = 0) {Î¹â‚‚ : Type u_2} {sâ‚‚ : finset Î¹â‚‚} {wâ‚‚ : Î¹â‚‚ â†’ â„} (vâ‚‚ : Î¹â‚‚ â†’ F) (hâ‚‚ : sâ‚‚.sum (Î» (i : Î¹â‚‚), wâ‚‚ i) = 0) : has_inner.inner (sâ‚.sum (Î» (iâ‚ : Î¹â‚), wâ‚ iâ‚ â€¢ vâ‚ iâ‚)) (sâ‚‚.sum (Î» (iâ‚‚ : Î¹â‚‚), wâ‚‚ iâ‚‚ â€¢ vâ‚‚ iâ‚‚)) = -sâ‚.sum (Î» (iâ‚ : Î¹â‚), sâ‚‚.sum (Î» (iâ‚‚ : Î¹â‚‚), wâ‚ iâ‚ * wâ‚‚ iâ‚‚ * (âˆ¥vâ‚ iâ‚ - vâ‚‚ iâ‚‚âˆ¥ * âˆ¥vâ‚ iâ‚ - vâ‚‚ iâ‚‚âˆ¥))) / 2
theorem convex_on_norm {E : Type u_2} [semi_normed_group E] [normed_space â„ E] {s : set E} (hs : convex â„ s) : convex_on â„ s has_norm.norm
theorem covby.to_dual {Î± : Type u_1} [has_lt Î±] {a b : Î±} : a â‹– b â†’ â‡‘order_dual.to_dual b â‹– â‡‘order_dual.to_dual a
theorem is_localization.lift_mem_adjoin_finset_integer_multiple {R S : Type u} [comm_ring R] [comm_ring S] (M : submonoid R) (S' : Type u) [comm_ring S'] [algebra S S'] [algebra R S] [algebra R S'] [is_scalar_tower R S S'] [is_localization (submonoid.map â†‘(algebra_map R S) M) S'] (x : S) (s : finset S') (hx : â‡‘(algebra_map S S') x âˆˆ algebra.adjoin R â†‘s) : âˆƒ (m : â†¥M), m â€¢ x âˆˆ algebra.adjoin R â†‘(is_localization.finset_integer_multiple (submonoid.map â†‘(algebra_map R S) M) s)
theorem finset.le_sum_of_subadditive_on_pred {Î¹ : Type u_1} {M : Type u_4} {N : Type u_5} [add_comm_monoid M] [ordered_add_comm_monoid N] (f : M â†’ N) (p : M â†’ Prop) (h_one : f 0 = 0) (h_mul : âˆ€ (x y : M), p x â†’ p y â†’ f (x + y) â‰¤ f x + f y) (hp_mul : âˆ€ (x y : M), p x â†’ p y â†’ p (x + y)) (g : Î¹ â†’ M) {s : finset Î¹} (hs : âˆ€ (i : Î¹), i âˆˆ s â†’ p (g i)) : f (s.sum (Î» (i : Î¹), g i)) â‰¤ s.sum (Î» (i : Î¹), f (g i))
theorem add_submonoid.localization_map.of_add_equiv_of_dom_id {M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {N : Type u_2} [add_comm_monoid N] (f : S.localization_map N) : f.of_add_equiv_of_dom _ = f
theorem polynomial.degree_cyclotomic_pos (n : â„•) (R : Type u_1) (hpos : 0 < n) [ring R] [nontrivial R] : 0 < (polynomial.cyclotomic n R).degree
theorem finsum_mem_union' {Î± : Type u_1} {M : Type u_5} [add_comm_monoid M] {f : Î± â†’ M} {s t : set Î±} (hst : disjoint s t) (hs : (s âˆ© function.support f).finite) (ht : (t âˆ© function.support f).finite) : finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s âˆª t), f i)) = finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), f i)) + finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ t), f i))
theorem convex.norm_image_sub_le_of_norm_fderiv_le' {E : Type u_1} [normed_group E] [normed_space â„ E] {ğ•œ : Type u_3} {G : Type u_4} [is_R_or_C ğ•œ] [normed_space ğ•œ E] [normed_group G] [normed_space ğ•œ G] {f : E â†’ G} {C : â„} {s : set E} {x y : E} {Ï† : E â†’L[ğ•œ] G} (hf : âˆ€ (x : E), x âˆˆ s â†’ differentiable_at ğ•œ f x) (bound : âˆ€ (x : E), x âˆˆ s â†’ âˆ¥fderiv ğ•œ f x - Ï†âˆ¥ â‰¤ C) (hs : convex â„ s) (xs : x âˆˆ s) (ys : y âˆˆ s) : âˆ¥f y - f x - â‡‘Ï† (y - x)âˆ¥ â‰¤ C * âˆ¥y - xâˆ¥
theorem seminorm.convex_ball {ğ•œ : Type u_3} {E : Type u_4} [normed_field ğ•œ] [add_comm_group E] [normed_space â„ ğ•œ] [module ğ•œ E] [module â„ E] [is_scalar_tower â„ ğ•œ E] (p : seminorm ğ•œ E) (x : E) (r : â„) : convex â„ (p.ball x r)
theorem measure_theory.measure_Inter_eq_infi {Î± : Type u_1} {Î¹ : Type u_5} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [encodable Î¹] {s : Î¹ â†’ set Î±} (h : âˆ€ (i : Î¹), measurable_set (s i)) (hd : directed superset s) (hfin : âˆƒ (i : Î¹), â‡‘Î¼ (s i) â‰  âŠ¤) : â‡‘Î¼ (â‹‚ (i : Î¹), s i) = â¨… (i : Î¹), â‡‘Î¼ (s i)
theorem parallelogram_law {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {x y : E} : has_inner.inner (x + y) (x + y) + has_inner.inner (x - y) (x - y) = 2 * (has_inner.inner x x + has_inner.inner y y)
theorem category_theory.grothendieck_topology.pullback_close {C : Type u} [category_theory.category C] (Jâ‚ : category_theory.grothendieck_topology C) {X Y : C} (f : Y âŸ¶ X) (S : category_theory.sieve X) : Jâ‚.close (category_theory.sieve.pullback f S) = category_theory.sieve.pullback f (Jâ‚.close S)
theorem bornology.is_cobounded.of_compl {Î± : Type u_2} [bornology Î±] {s : set Î±} : bornology.is_cobounded sá¶œ â†’ bornology.is_bounded s
theorem witt_vector.verschiebung_zmod {p : â„•} [hp : fact (nat.prime p)] (x : witt_vector p (zmod p)) : â‡‘witt_vector.verschiebung x = x * â†‘p
theorem affine.simplex.circumcenter_eq_of_range_eq {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {n : â„•} {sâ‚ sâ‚‚ : affine.simplex â„ P n} (h : set.range sâ‚.points = set.range sâ‚‚.points) : sâ‚.circumcenter = sâ‚‚.circumcenter
theorem affine_independent.affine_span_disjoint_of_disjoint {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {Î¹ : Type u_4} [nontrivial k] {p : Î¹ â†’ P} (ha : affine_independent k p) {s1 s2 : set Î¹} (hd : s1 âˆ© s2 = âˆ…) : â†‘(affine_span k (p '' s1)) âˆ© â†‘(affine_span k (p '' s2)) = âˆ…
theorem exp_add {ğ•‚ : Type u_1} {ğ”¸ : Type u_2} [is_R_or_C ğ•‚] [normed_comm_ring ğ”¸] [normed_algebra ğ•‚ ğ”¸] [complete_space ğ”¸] {x y : ğ”¸} : exp ğ•‚ (x + y) = exp ğ•‚ x * exp ğ•‚ y
theorem measure_theory.is_locally_finite_measure_of_is_finite_measure_on_compacts {Î± : Type u_1} {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [topological_space Î±] [locally_compact_space Î±] [measure_theory.is_finite_measure_on_compacts Î¼] : measure_theory.is_locally_finite_measure Î¼
theorem fin.update_cons_zero {n : â„•} {Î± : fin (n + 1) â†’ Type u} (x : Î± 0) (p : Î  (i : fin n), Î± i.succ) (z : Î± 0) : function.update (fin.cons x p) 0 z = fin.cons z p
theorem finset.induction_on_pi {Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_2} [fintype Î¹] [decidable_eq Î¹] [Î  (i : Î¹), decidable_eq (Î± i)] {p : (Î  (i : Î¹), finset (Î± i)) â†’ Prop} (f : Î  (i : Î¹), finset (Î± i)) (h0 : p (Î» (_x : Î¹), âˆ…)) (step : âˆ€ (g : Î  (i : Î¹), finset (Î± i)) (i : Î¹) (x : Î± i), x âˆ‰ g i â†’ p g â†’ p (function.update g i (has_insert.insert x (g i)))) : p f
theorem multiset.count_map_eq_count' {Î± : Type u_1} {Î² : Type u_2} [decidable_eq Î±] [decidable_eq Î²] (f : Î± â†’ Î²) (s : multiset Î±) (hf : function.injective f) (x : Î±) : multiset.count (f x) (multiset.map f s) = multiset.count x s
theorem submodule.orthogonal_le {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {Kâ‚ Kâ‚‚ : submodule ğ•œ E} (h : Kâ‚ â‰¤ Kâ‚‚) : Kâ‚‚á—® â‰¤ Kâ‚á—®
theorem list.prod_update_nth' {G : Type u_7} [comm_group G] (L : list G) (n : â„•) (a : G) : (L.update_nth n a).prod = L.prod * dite (n < L.length) (Î» (hn : n < L.length), (L.nth_le n hn)â»Â¹ * a) (Î» (hn : Â¬n < L.length), 1)
theorem affine_independent.units_line_map {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {Î¹ : Type u_4} {p : Î¹ â†’ P} (hp : affine_independent k p) (j : Î¹) (w : Î¹ â†’ kË£) : affine_independent k (Î» (i : Î¹), â‡‘(affine_map.line_map (p j) (p i)) â†‘(w i))
theorem finset.nonempty.inv {Î± : Type u_2} [decidable_eq Î±] [has_inv Î±] {s : finset Î±} : sâ»Â¹.nonempty â†’ s.nonempty
theorem has_fderiv_within_at.comp_has_deriv_within_at {ğ•œ : Type u} [nondiscrete_normed_field ğ•œ] {F : Type v} [normed_group F] [normed_space ğ•œ F] {E : Type w} [normed_group E] [normed_space ğ•œ E] {f : ğ•œ â†’ F} {f' : F} (x : ğ•œ) {s : set ğ•œ} {l : F â†’ E} {l' : F â†’L[ğ•œ] E} {t : set F} (hl : has_fderiv_within_at l l' t (f x)) (hf : has_deriv_within_at f f' s x) (hst : set.maps_to f s t) : has_deriv_within_at (l âˆ˜ f) (â‡‘l' f') s x
theorem nndist_edist {Î± : Type u} [pseudo_metric_space Î±] (x y : Î±) : has_nndist.nndist x y = (has_edist.edist x y).to_nnreal
theorem matrix.mv_polynomial_X_map_matrix_aeval {m : Type u_1} (R : Type u_3) {S : Type u_4} [fintype m] [decidable_eq m] [comm_semiring R] [comm_semiring S] [algebra R S] (A : matrix m m S) : â‡‘((mv_polynomial.aeval (Î» (p : m Ã— m), A p.fst p.snd)).map_matrix) (matrix.mv_polynomial_X m m R) = A
theorem subsingleton_iff_zero_eq_one {Mâ‚€ : Type u_1} [mul_zero_one_class Mâ‚€] : 0 = 1 â†” subsingleton Mâ‚€
theorem cardinal.mul_eq_self {c : cardinal} (h : cardinal.aleph_0 â‰¤ c) : c * c = c
theorem phragmen_lindelof.is_O_sub_exp_rpow {E : Type u_1} [normed_group E] {a : â„} {f g : â„‚ â†’ E} {l : filter â„‚} (hBf : âˆƒ (c : â„) (H : c < a) (B : â„), f =O[filter.comap complex.abs filter.at_top âŠ“ l] Î» (z : â„‚), real.exp (B * complex.abs z ^ c)) (hBg : âˆƒ (c : â„) (H : c < a) (B : â„), g =O[filter.comap complex.abs filter.at_top âŠ“ l] Î» (z : â„‚), real.exp (B * complex.abs z ^ c)) : âˆƒ (c : â„) (H : c < a) (B : â„), (f - g) =O[filter.comap complex.abs filter.at_top âŠ“ l] Î» (z : â„‚), real.exp (B * complex.abs z ^ c)
theorem filter.eventually.set_eq {Î± : Type u} {s t : set Î±} {l : filter Î±} : (âˆ€á¶  (x : Î±) in l, x âˆˆ s â†” x âˆˆ t) â†’ s =á¶ [l] t
theorem strict_mono_on.continuous_at_left_of_closure_image_mem_nhds_within {Î± : Type u_1} {Î² : Type u_2} [linear_order Î±] [topological_space Î±] [order_topology Î±] [linear_order Î²] [topological_space Î²] [order_topology Î²] [densely_ordered Î²] {f : Î± â†’ Î²} {s : set Î±} {a : Î±} (h_mono : strict_mono_on f s) (hs : s âˆˆ nhds_within a (set.Iic a)) (hfs : closure (f '' s) âˆˆ nhds_within (f a) (set.Iic (f a))) : continuous_within_at f (set.Iic a) a
theorem cont_diff_bump_of_inner.normed_convolution_eq_right {G : Type u_2} {E' : Type u_4} [normed_group E'] {g : G â†’ E'} [measurable_space G] {Î¼ : measure_theory.measure G} [normed_space â„ E'] [inner_product_space â„ G] [complete_space E'] {Ï† : cont_diff_bump_of_inner 0} [borel_space G] [measure_theory.is_locally_finite_measure Î¼] [Î¼.is_open_pos_measure] [finite_dimensional â„ G] {xâ‚€ : G} (hg : âˆ€ (x : G), x âˆˆ metric.ball xâ‚€ Ï†.R â†’ g x = g xâ‚€) : convolution (Ï†.normed Î¼) g (continuous_linear_map.lsmul â„ â„) Î¼ xâ‚€ = g xâ‚€
theorem CompHaus.is_closed_map {X Y : CompHaus} (f : X âŸ¶ Y) : is_closed_map â‡‘f
theorem mul_equiv.map_div {G : Type u_10} {H : Type u_11} [group G] [division_monoid H] (h : G â‰ƒ* H) (x y : G) : â‡‘h (x / y) = â‡‘h x / â‡‘h y
theorem local_equiv.eq_on_source.source_eq {Î± : Type u_1} {Î² : Type u_2} {e e' : local_equiv Î± Î²} (h : e â‰ˆ e') : e.source = e'.source
theorem is_preconnected.intermediate_valueâ‚‚ {X : Type u} {Î± : Type v} [topological_space X] [linear_order Î±] [topological_space Î±] [order_closed_topology Î±] {s : set X} (hs : is_preconnected s) {a b : X} (ha : a âˆˆ s) (hb : b âˆˆ s) {f g : X â†’ Î±} (hf : continuous_on f s) (hg : continuous_on g s) (ha' : f a â‰¤ g a) (hb' : g b â‰¤ f b) : âˆƒ (x : X) (H : x âˆˆ s), f x = g x
theorem complex.continuous_at_cpow_const_of_re_pos {z w : â„‚} (hz : 0 â‰¤ z.re âˆ¨ z.im â‰  0) (hw : 0 < w.re) : continuous_at (Î» (x : â„‚), x ^ w) z
theorem interval_integral.integral_eq_sub_of_has_deriv_at_of_le {E : Type u_3} [normed_group E] [complete_space E] [normed_space â„ E] {f : â„ â†’ E} {a b : â„} {f' : â„ â†’ E} (hab : a â‰¤ b) (hcont : continuous_on f (set.Icc a b)) (hderiv : âˆ€ (x : â„), x âˆˆ set.Ioo a b â†’ has_deriv_at f (f' x) x) (hint : interval_integrable f' measure_theory.measure_space.volume a b) : âˆ« (y : â„) in a..b, f' y = f b - f a
theorem measure_theory.measure.ext_of_Ioc {Î± : Type u_1} [topological_space Î±] {m : measurable_space Î±} [topological_space.second_countable_topology Î±] [conditionally_complete_linear_order Î±] [order_topology Î±] [borel_space Î±] [no_min_order Î±] (Î¼ Î½ : measure_theory.measure Î±) [measure_theory.is_locally_finite_measure Î¼] (h : âˆ€ â¦ƒa b : Î±â¦„, a < b â†’ â‡‘Î¼ (set.Ioc a b) = â‡‘Î½ (set.Ioc a b)) : Î¼ = Î½
theorem measure_theory.conservative.exists_gt_measure_inter_ne_zero {Î± : Type u_2} [measurable_space Î±] {f : Î± â†’ Î±} {s : set Î±} {Î¼ : measure_theory.measure Î±} (hf : measure_theory.conservative f Î¼) (hs : measurable_set s) (h0 : â‡‘Î¼ s â‰  0) (N : â„•) : âˆƒ (m : â„•) (H : m > N), â‡‘Î¼ (s âˆ© f^[m] â»Â¹' s) â‰  0
theorem continuous_inf_dom_leftâ‚‚ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} {f : Î± â†’ Î² â†’ Î³} {ta1 ta2 : topological_space Î±} {tb1 tb2 : topological_space Î²} {tc1 : topological_space Î³} (h : continuous (Î» (p : Î± Ã— Î²), f p.fst p.snd)) : continuous (Î» (p : Î± Ã— Î²), f p.fst p.snd)
theorem box_integral.prepartition.is_partition.exists_split_many_le {Î¹ : Type u_1} [fintype Î¹] {I : box_integral.box Î¹} {Ï€ : box_integral.prepartition I} (h : Ï€.is_partition) : âˆƒ (s : finset (Î¹ Ã— â„)), box_integral.prepartition.split_many I s â‰¤ Ï€
theorem category_theory.cocone_of_representable_naturality {C : Type uâ‚} [category_theory.small_category C] {Pâ‚ Pâ‚‚ : Cáµ’áµ– â¥¤ Type uâ‚} (Î± : Pâ‚ âŸ¶ Pâ‚‚) (j : (Pâ‚.elements)áµ’áµ–) : (category_theory.cocone_of_representable Pâ‚).Î¹.app j â‰« Î± = (category_theory.cocone_of_representable Pâ‚‚).Î¹.app ((category_theory.category_of_elements.map Î±).op.obj j)
theorem interval_integral.measure_integral_sub_integral_sub_linear_is_o_of_tendsto_ae {Î¹ : Type u_1} {E : Type u_3} [normed_group E] [complete_space E] [normed_space â„ E] {f : â„ â†’ E} {a b : â„} {ca cb : E} {la la' lb lb' : filter â„} {lt : filter Î¹} {Î¼ : measure_theory.measure â„} {ua va ub vb : Î¹ â†’ â„} [interval_integral.FTC_filter a la la'] [interval_integral.FTC_filter b lb lb'] [measure_theory.is_locally_finite_measure Î¼] (hab : interval_integrable f Î¼ a b) (hmeas_a : strongly_measurable_at_filter f la' Î¼) (hmeas_b : strongly_measurable_at_filter f lb' Î¼) (ha_lim : filter.tendsto f (la' âŠ“ Î¼.ae) (nhds ca)) (hb_lim : filter.tendsto f (lb' âŠ“ Î¼.ae) (nhds cb)) (hua : filter.tendsto ua lt la) (hva : filter.tendsto va lt la) (hub : filter.tendsto ub lt lb) (hvb : filter.tendsto vb lt lb) : (Î» (t : Î¹), âˆ« (x : â„) in va t..vb t, f x âˆ‚Î¼ - âˆ« (x : â„) in ua t..ub t, f x âˆ‚Î¼ - (âˆ« (x : â„) in ub t..vb t, cb âˆ‚Î¼ - âˆ« (x : â„) in ua t..va t, ca âˆ‚Î¼)) =o[lt] Î» (t : Î¹), âˆ¥âˆ« (x : â„) in ua t..va t, 1 âˆ‚Î¼âˆ¥ + âˆ¥âˆ« (x : â„) in ub t..vb t, 1 âˆ‚Î¼âˆ¥
theorem generate_from_pi {Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_3} [fintype Î¹] [Î  (i : Î¹), measurable_space (Î± i)] : measurable_space.generate_from (set.univ.pi '' set.univ.pi (Î» (i : Î¹), {s : set (Î± i) | measurable_set s})) = measurable_space.pi
theorem continuous_map.exists_extension_of_closed_embedding {X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] [normal_space Y] (f : C(X, â„)) (e : X â†’ Y) (he : closed_embedding e) : âˆƒ (g : C(Y, â„)), â‡‘g âˆ˜ e = â‡‘f
theorem nat.prime.multiplicity_factorial {p : â„•} (hp : nat.prime p) {n b : â„•} : nat.log p n < b â†’ multiplicity p n.factorial = â†‘((finset.Ico 1 b).sum (Î» (i : â„•), n / p ^ i))
theorem nilpotent_iff_finite_ascending_central_series (G : Type u_1) [group G] : group.is_nilpotent G â†” âˆƒ (n : â„•) (H : â„• â†’ subgroup G), is_ascending_central_series H âˆ§ H n = âŠ¤
theorem finprod_mem_mul_distrib {Î± : Type u_1} {M : Type u_5} [comm_monoid M] {f g : Î± â†’ M} {s : set Î±} (hs : s.finite) : finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), f i * g i)) = finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), f i)) * finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), g i))
theorem linear_map.re_inner_adjoint_mul_self_nonneg {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] [finite_dimensional ğ•œ E] (T : E â†’â‚—[ğ•œ] E) (x : E) : 0 â‰¤ â‡‘is_R_or_C.re (has_inner.inner x (â‡‘(â‡‘linear_map.adjoint T * T) x))
theorem normed_space.exists_lt_norm (ğ•œ : Type u_5) (E : Type u_6) [nondiscrete_normed_field ğ•œ] [normed_group E] [normed_space ğ•œ E] [nontrivial E] (c : â„) : âˆƒ (x : E), c < âˆ¥xâˆ¥
theorem cont_diff_on_iff_continuous_on_differentiable_on_deriv {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {F : Type u_2} [normed_group F] [normed_space ğ•œ F] {f : ğ•œ â†’ F} {s : set ğ•œ} {n : with_top â„•} (hs : unique_diff_on ğ•œ s) : cont_diff_on ğ•œ n f s â†” (âˆ€ (m : â„•), â†‘m â‰¤ n â†’ continuous_on (iterated_deriv_within m f s) s) âˆ§ âˆ€ (m : â„•), â†‘m < n â†’ differentiable_on ğ•œ (iterated_deriv_within m f s) s
theorem is_min_filter.dual {Î± : Type u} {Î² : Type v} [preorder Î²] {f : Î± â†’ Î²} {l : filter Î±} {a : Î±} : is_min_filter f l a â†’ is_max_filter (â‡‘order_dual.to_dual âˆ˜ f) l a
theorem measure_theory.absolutely_continuous_of_is_mul_left_invariant {G : Type u_1} [measurable_space G] [group G] [has_measurable_mulâ‚‚ G] (Î¼ Î½ : measure_theory.measure G) [measure_theory.sigma_finite Î½] [measure_theory.sigma_finite Î¼] [has_measurable_inv G] [Î¼.is_mul_left_invariant] [Î½.is_mul_left_invariant] (hÎ½ : Î½ â‰  0) : Î¼.absolutely_continuous Î½
theorem sum_mem {B : Type u_3} {S : B} {M : Type u_1} [add_comm_monoid M] [set_like B M] [add_submonoid_class B M] {Î¹ : Type u_2} {t : finset Î¹} {f : Î¹ â†’ M} (h : âˆ€ (c : Î¹), c âˆˆ t â†’ f c âˆˆ S) : t.sum (Î» (c : Î¹), f c) âˆˆ S
theorem complex.exists_mem_frontier_is_max_on_norm {E : Type u} [normed_group E] [normed_space â„‚ E] {F : Type v} [normed_group F] [normed_space â„‚ F] [nontrivial E] [finite_dimensional â„‚ E] {f : E â†’ F} {U : set E} (hb : metric.bounded U) (hne : U.nonempty) (hd : diff_cont_on_cl â„‚ f U) : âˆƒ (z : E) (H : z âˆˆ frontier U), is_max_on (has_norm.norm âˆ˜ f) (closure U) z
theorem supr_inf_le_Sup_inf {Î± : Type u_1} [complete_lattice Î±] {a : Î±} {s : set Î±} : (â¨† (b : Î±) (H : b âˆˆ s), b âŠ“ a) â‰¤ has_Sup.Sup s âŠ“ a
theorem filter.tendsto_abs_at_top_at_top {Î± : Type u_3} [linear_ordered_add_comm_group Î±] : filter.tendsto has_abs.abs filter.at_top filter.at_top
theorem uniform_continuous_of_continuous_at_zero {Î± : Type u_1} {Î² : Type u_2} [uniform_space Î±] [add_group Î±] [uniform_add_group Î±] {hom : Type u_3} [uniform_space Î²] [add_group Î²] [uniform_add_group Î²] [add_monoid_hom_class hom Î± Î²] (f : hom) (hf : continuous_at â‡‘f 0) : uniform_continuous â‡‘f
theorem unitization.alg_hom_ext' {R : Type u_2} {A : Type u_3} [comm_semiring R] [non_unital_semiring A] [module R A] [smul_comm_class R A A] [is_scalar_tower R A A] {C : Type u_5} [ring C] [algebra R C] {Ï† Ïˆ : unitization R A â†’â‚[R] C} (h : Ï†.to_non_unital_alg_hom.comp (unitization.coe_non_unital_alg_hom R A) = Ïˆ.to_non_unital_alg_hom.comp (unitization.coe_non_unital_alg_hom R A)) : Ï† = Ïˆ
theorem measure_theory.norm_Lp_to_Lp_restrict_le {Î± : Type u_1} {E : Type u_3} [measurable_space Î±] [normed_group E] {p : ennreal} {Î¼ : measure_theory.measure Î±} (s : set Î±) (f : â†¥(measure_theory.Lp E p Î¼)) : âˆ¥measure_theory.mem_â„’p.to_Lp â‡‘f _âˆ¥ â‰¤ âˆ¥fâˆ¥
theorem affine_subspace.mem_inf_iff {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] (p : P) (s1 s2 : affine_subspace k P) : p âˆˆ s1 âŠ“ s2 â†” p âˆˆ s1 âˆ§ p âˆˆ s2
theorem liouville.tsum_one_div_pow_factorial_lt (n : â„•) {m : â„} (m1 : 1 < m) : âˆ‘' (i : â„•), 1 / m ^ (i + (n + 1)).factorial < (1 - 1 / m)â»Â¹ * (1 / m ^ (n + 1).factorial)
theorem is_noetherian.induction {R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] [is_noetherian R M] {P : submodule R M â†’ Prop} (hgt : âˆ€ (I : submodule R M), (âˆ€ (J : submodule R M), J > I â†’ P J) â†’ P I) (I : submodule R M) : P I
theorem dist_le_of_trajectories_ODE {E : Type u_1} [normed_group E] [normed_space â„ E] {v : â„ â†’ E â†’ E} {K : nnreal} (hv : âˆ€ (t : â„), lipschitz_with K (v t)) {f g : â„ â†’ E} {a b Î´ : â„} (hf : continuous_on f (set.Icc a b)) (hf' : âˆ€ (t : â„), t âˆˆ set.Ico a b â†’ has_deriv_within_at f (v t (f t)) (set.Ici t) t) (hg : continuous_on g (set.Icc a b)) (hg' : âˆ€ (t : â„), t âˆˆ set.Ico a b â†’ has_deriv_within_at g (v t (g t)) (set.Ici t) t) (ha : has_dist.dist (f a) (g a) â‰¤ Î´) (t : â„) (H : t âˆˆ set.Icc a b) : has_dist.dist (f t) (g t) â‰¤ Î´ * real.exp (â†‘K * (t - a))
theorem measure_theory.measure.inner_regular.measurable_set_of_open {Î± : Type u_1} [measurable_space Î±] [topological_space Î±] {Î¼ : measure_theory.measure Î±} {p : set Î± â†’ Prop} [Î¼.outer_regular] (H : Î¼.inner_regular p is_open) (h0 : p âˆ…) (hd : âˆ€ â¦ƒs U : set Î±â¦„, p s â†’ is_open U â†’ p (s  U)) : Î¼.inner_regular p (Î» (s : set Î±), measurable_set s âˆ§ â‡‘Î¼ s â‰  âŠ¤)
theorem finset.weighted_vsub_of_point_indicator_subset {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {Î¹ : Type u_4} (w : Î¹ â†’ k) (p : Î¹ â†’ P) (b : P) {sâ‚ sâ‚‚ : finset Î¹} (h : sâ‚ âŠ† sâ‚‚) : â‡‘(sâ‚.weighted_vsub_of_point p b) w = â‡‘(sâ‚‚.weighted_vsub_of_point p b) (â†‘sâ‚.indicator w)
theorem reflection_map {ğ•œ : Type u_1} [is_R_or_C ğ•œ] {E : Type u_2} {E' : Type u_3} [inner_product_space ğ•œ E] [inner_product_space ğ•œ E'] (f : E â‰ƒâ‚—áµ¢[ğ•œ] E') (K : submodule ğ•œ E) [complete_space â†¥K] : reflection (submodule.map â†‘(f.to_linear_equiv) K) = f.symm.trans ((reflection K).trans f)
theorem measure_theory.measure.hausdorff_measure_le_liminf_tsum {X : Type u_2} [emetric_space X] [measurable_space X] [borel_space X] {Î² : Type u_1} {Î¹ : Î² â†’ Type u_3} [hÎ¹ : Î  (n : Î²), encodable (Î¹ n)] (d : â„) (s : set X) {l : filter Î²} (r : Î² â†’ ennreal) (hr : filter.tendsto r l (nhds 0)) (t : Î  (n : Î²), Î¹ n â†’ set X) (ht : âˆ€á¶  (n : Î²) in l, âˆ€ (i : Î¹ n), emetric.diam (t n i) â‰¤ r n) (hst : âˆ€á¶  (n : Î²) in l, s âŠ† â‹ƒ (i : Î¹ n), t n i) : â‡‘(measure_theory.measure.hausdorff_measure d) s â‰¤ l.liminf (Î» (n : Î²), âˆ‘' (i : Î¹ n), emetric.diam (t n i) ^ d)
theorem discrete_valuation_ring.exists_prime (R : Type u) [comm_ring R] [is_domain R] [discrete_valuation_ring R] : âˆƒ (Ï– : R), prime Ï–
theorem quotient_norm_mk_le {M : Type u_1} [semi_normed_group M] (S : add_subgroup M) (m : M) : âˆ¥â‡‘(quotient_add_group.mk' S) mâˆ¥ â‰¤ âˆ¥mâˆ¥
theorem category_theory.abelian.pseudoelement.pseudo_injective_of_mono {C : Type u} [category_theory.category C] [category_theory.abelian C] {P Q : C} (f : P âŸ¶ Q) [category_theory.mono f] : function.injective â‡‘f
theorem first_order.language.substructure.closure_eq {L : first_order.language} {M : Type w} [L.Structure M] (S : L.substructure M) : â‡‘(first_order.language.substructure.closure L) â†‘S = S
theorem Profinite.exists_clopen_of_cofiltered {J : Type u} [category_theory.small_category J] [category_theory.is_cofiltered J] {F : J â¥¤ Profinite} (C : category_theory.limits.cone F) (hC : category_theory.limits.is_limit C) {U : set â†¥(C.X)} (hU : is_clopen U) : âˆƒ (j : J) (V : set â†¥(F.obj j)) (hV : is_clopen V), U = â‡‘(C.Ï€.app j) â»Â¹' V
theorem linear_equiv.is_unit_det' {M : Type u_2} [add_comm_group M] {A : Type u_1} [comm_ring A] [module A M] (f : M â‰ƒâ‚—[A] M) : is_unit (â‡‘linear_map.det â†‘f)
theorem vsub_set_subset_vector_span (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P) : s -áµ¥ s âŠ† â†‘(vector_span k s)
theorem mul_mem_class.mul_mem_add_closure {M : Type u_1} {R : Type u_4} [non_unital_non_assoc_semiring R] [set_like M R] [mul_mem_class M R] {S : M} {a b : R} (ha : a âˆˆ add_submonoid.closure â†‘S) (hb : b âˆˆ add_submonoid.closure â†‘S) : a * b âˆˆ add_submonoid.closure â†‘S
theorem finset.mem_shadow_iff_exists_mem_card_add_one {Î± : Type u_1} [decidable_eq Î±] {ğ’œ : finset (finset Î±)} {s : finset Î±} : s âˆˆ ğ’œ.shadow â†” âˆƒ (t : finset Î±) (H : t âˆˆ ğ’œ), s âŠ† t âˆ§ t.card = s.card + 1
theorem unique_factorization_monoid.multiplicity_eq_count_normalized_factors {R : Type u_2} [cancel_comm_monoid_with_zero R] [unique_factorization_monoid R] [nontrivial R] [normalization_monoid R] [decidable_eq R] [dec_dvd : decidable_rel has_dvd.dvd] {a b : R} (ha : irreducible a) (hb : b â‰  0) : multiplicity a b = â†‘(multiset.count (â‡‘normalize a) (unique_factorization_monoid.normalized_factors b))
theorem euclidean_geometry.exists_dist_eq_iff_exists_dist_orthogonal_projection_eq {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace â„ P} [nonempty â†¥s] [complete_space â†¥(s.direction)] {ps : set P} (hps : ps âŠ† â†‘s) (p : P) : (âˆƒ (r : â„), âˆ€ (p1 : P), p1 âˆˆ ps â†’ has_dist.dist p1 p = r) â†” âˆƒ (r : â„), âˆ€ (p1 : P), p1 âˆˆ ps â†’ has_dist.dist p1 â†‘(â‡‘(euclidean_geometry.orthogonal_projection s) p) = r
theorem exp_sum {ğ•‚ : Type u_1} {ğ”¸ : Type u_2} [is_R_or_C ğ•‚] [normed_comm_ring ğ”¸] [normed_algebra ğ•‚ ğ”¸] [complete_space ğ”¸] {Î¹ : Type u_3} (s : finset Î¹) (f : Î¹ â†’ ğ”¸) : exp ğ•‚ (s.sum (Î» (i : Î¹), f i)) = s.prod (Î» (i : Î¹), exp ğ•‚ (f i))
theorem emetric.inf_edist_union {Î± : Type u} [pseudo_emetric_space Î±] {x : Î±} {s t : set Î±} : emetric.inf_edist x (s âˆª t) = emetric.inf_edist x s âŠ“ emetric.inf_edist x t
theorem real.deriv_tan_sub_id (x : â„) (h : real.cos x â‰  0) : deriv (Î» (y : â„), real.tan y - y) x = 1 / real.cos x ^ 2 - 1
theorem cont_diff_on.comp {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {G : Type u_4} [normed_group G] [normed_space ğ•œ G] {n : with_top â„•} {s : set E} {t : set F} {g : F â†’ G} {f : E â†’ F} (hg : cont_diff_on ğ•œ n g t) (hf : cont_diff_on ğ•œ n f s) (st : s âŠ† f â»Â¹' t) : cont_diff_on ğ•œ n (g âˆ˜ f) s
theorem basis.to_matrix_reindex' {Î¹ : Type u_1} {Î¹' : Type u_2} {R : Type u_5} {M : Type u_6} [comm_semiring R] [add_comm_monoid M] [module R M] [fintype Î¹'] [fintype Î¹] [decidable_eq Î¹] [decidable_eq Î¹'] (b : basis Î¹ R M) (v : Î¹' â†’ M) (e : Î¹ â‰ƒ Î¹') : (b.reindex e).to_matrix v = â‡‘(matrix.reindex_alg_equiv R e) (b.to_matrix (v âˆ˜ â‡‘e))
theorem finset.dimH_zero {X : Type u_2} [emetric_space X] (s : finset X) : dimH â†‘s = 0
theorem function.is_fixed_pt.to_left_inverse {Î± : Type u} {f g : Î± â†’ Î±} {x : Î±} (hf : function.is_fixed_pt f x) (h : function.left_inverse g f) : function.is_fixed_pt g x
theorem exists_gcd_eq_mul_add_mul {R : Type u} [comm_ring R] [is_domain R] [is_principal_ideal_ring R] [gcd_monoid R] (a b : R) : âˆƒ (x y : R), gcd_monoid.gcd a b = a * x + b * y
theorem algebra.finite_presentation.mv_polynomial (R : Type u_1) [comm_ring R] (Î¹ : Type u_2) [fintype Î¹] : algebra.finite_presentation R (mv_polynomial Î¹ R)
theorem fin.strict_anti_iff_succ_lt {n : â„•} {Î± : Type u_1} [preorder Î±] {f : fin (n + 1) â†’ Î±} : strict_anti f â†” âˆ€ (i : fin n), f i.succ < f (â‡‘fin.cast_succ i)
theorem orthonormal.oangle_eq_neg_of_orientation_eq_neg {V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) {bâ‚‚ : basis (fin 2) â„ V} (hbâ‚‚ : orthonormal â„ â‡‘bâ‚‚) (ho : b.orientation = -bâ‚‚.orientation) (x y : V) : hb.oangle x y = -hbâ‚‚.oangle x y
theorem strict_mono_on.continuous_at_right_of_closure_image_mem_nhds_within {Î± : Type u_1} {Î² : Type u_2} [linear_order Î±] [topological_space Î±] [order_topology Î±] [linear_order Î²] [topological_space Î²] [order_topology Î²] [densely_ordered Î²] {f : Î± â†’ Î²} {s : set Î±} {a : Î±} (h_mono : strict_mono_on f s) (hs : s âˆˆ nhds_within a (set.Ici a)) (hfs : closure (f '' s) âˆˆ nhds_within (f a) (set.Ici (f a))) : continuous_within_at f (set.Ici a) a
theorem has_deriv_within_at.limsup_norm_slope_le {E : Type u} [normed_group E] [normed_space â„ E] {f : â„ â†’ E} {f' : E} {s : set â„} {x r : â„} (hf : has_deriv_within_at f f' s x) (hr : âˆ¥f'âˆ¥ < r) : âˆ€á¶  (z : â„) in nhds_within x s, âˆ¥z - xâˆ¥â»Â¹ * âˆ¥f z - f xâˆ¥ < r
theorem category_theory.grothendieck_topology.plus.sep {C : Type u} [category_theory.category C] {J : category_theory.grothendieck_topology C} {D : Type w} [category_theory.category D] [category_theory.concrete_category D] [category_theory.limits.preserves_limits (category_theory.forget D)] [âˆ€ (X : C), category_theory.limits.has_colimits_of_shape (J.cover X)áµ’áµ– D] [âˆ€ (P : Cáµ’áµ– â¥¤ D) (X : C) (S : J.cover X), category_theory.limits.has_multiequalizer (S.index P)] [Î  (X : C), category_theory.limits.preserves_colimits_of_shape (J.cover X)áµ’áµ– (category_theory.forget D)] {X : C} (P : Cáµ’áµ– â¥¤ D) (S : J.cover X) (x y : â†¥((J.plus_obj P).obj (opposite.op X))) (h : âˆ€ (I : S.arrow), â‡‘((J.plus_obj P).map I.f.op) x = â‡‘((J.plus_obj P).map I.f.op) y) : x = y
theorem setoid.eqv_gen_le {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} {s : setoid Î±} (h : âˆ€ (x y : Î±), r x y â†’ s.rel x y) : eqv_gen.setoid r â‰¤ s
theorem is_open.exists_lt_is_closed {Î± : Type u_1} [measurable_space Î±] [topological_space Î±] {Î¼ : measure_theory.measure Î±} [Î¼.weakly_regular] â¦ƒU : set Î±â¦„ (hU : is_open U) {r : ennreal} (hr : r < â‡‘Î¼ U) : âˆƒ (F : set Î±) (H : F âŠ† U), is_closed F âˆ§ r < â‡‘Î¼ F
theorem has_fpower_series_on_ball.analytic_at_of_mem {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field ğ•œ] [normed_group E] [normed_space ğ•œ E] [normed_group F] [normed_space ğ•œ F] [complete_space F] {f : E â†’ F} {p : formal_multilinear_series ğ•œ E F} {x y : E} {r : ennreal} (hf : has_fpower_series_on_ball f p x r) (h : y âˆˆ emetric.ball x r) : analytic_at ğ•œ f y
theorem pgame.lf_zero {x : pgame} : x.lf 0 â†” âˆƒ (j : x.right_moves), âˆ€ (i : (x.move_right j).left_moves), ((x.move_right j).move_left i).lf 0
theorem orientation.oangle_smul_left_of_neg {V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) (x y : V) {r : â„} (hr : r < 0) : o.oangle (r â€¢ x) y = o.oangle (-x) y
theorem orthogonal_family.range_linear_isometry {Î¹ : Type u_1} {ğ•œ : Type u_2} [is_R_or_C ğ•œ] {E : Type u_3} [inner_product_space ğ•œ E] [cplt : complete_space E] {G : Î¹ â†’ Type u_4} [Î  (i : Î¹), inner_product_space ğ•œ (G i)] {V : Î  (i : Î¹), G i â†’â‚—áµ¢[ğ•œ] E} (hV : orthogonal_family ğ•œ V) [âˆ€ (i : Î¹), complete_space (G i)] : hV.linear_isometry.to_linear_map.range = (â¨† (i : Î¹), (V i).to_linear_map.range).topological_closure
theorem submodule.exists_sub_one_mem_and_smul_eq_zero_of_fg_of_le_smul {R : Type u_1} [comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] (I : ideal R) (N : submodule R M) (hn : N.fg) (hin : N â‰¤ I â€¢ N) : âˆƒ (r : R), r - 1 âˆˆ I âˆ§ âˆ€ (n : M), n âˆˆ N â†’ r â€¢ n = 0
theorem orientation.linear_equiv_det_rotation {V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) (Î¸ : real.angle) : â‡‘linear_equiv.det (o.rotation Î¸).to_linear_equiv = 1
theorem subtype.forall' {Î± : Sort u_1} {p : Î± â†’ Prop} {q : Î  (x : Î±), p x â†’ Prop} : (âˆ€ (x : Î±) (h : p x), q x h) â†” âˆ€ (x : {a // p a}), q â†‘x _
theorem is_of_fin_order_one {G : Type u} [monoid G] : is_of_fin_order 1
theorem circle_integral.integral_sub_zpow_of_ne {n : â„¤} (hn : n â‰  -1) (c w : â„‚) (R : â„) : âˆ® (z : â„‚) in C(c, R), (z - w) ^ n = 0
theorem mul_hom.ext_iff {M : Type u_3} {N : Type u_4} [has_mul M] [has_mul N] {f g : M â†’â‚™* N} : f = g â†” âˆ€ (x : M), â‡‘f x = â‡‘g x
theorem measurable_space.cardinal_measurable_set_le {Î± : Type u} (s : set (set Î±)) : cardinal.mk â†¥{t : set Î± | measurable_set t} â‰¤ linear_order.max (cardinal.mk â†¥s) 2 ^ cardinal.aleph_0
theorem normed_group_hom.le_op_norm {Vâ‚ : Type u_2} {Vâ‚‚ : Type u_3} [semi_normed_group Vâ‚] [semi_normed_group Vâ‚‚] (f : normed_group_hom Vâ‚ Vâ‚‚) (x : Vâ‚) : âˆ¥â‡‘f xâˆ¥ â‰¤ âˆ¥fâˆ¥ * âˆ¥xâˆ¥
theorem monovary.sum_mul_comp_perm_le_sum_mul {Î¹ : Type u_1} {Î± : Type u_2} [linear_ordered_ring Î±] {Ïƒ : equiv.perm Î¹} {f g : Î¹ â†’ Î±} [fintype Î¹] (hfg : monovary f g) : finset.univ.sum (Î» (i : Î¹), f i * g (â‡‘Ïƒ i)) â‰¤ finset.univ.sum (Î» (i : Î¹), f i * g i)
theorem units.dvd_mul_right {Î± : Type u_1} [monoid Î±] {a b : Î±} {u : Î±Ë£} : a âˆ£ b * â†‘u â†” a âˆ£ b
theorem orthonormal_fourier  : orthonormal â„‚ (fourier_Lp 2)
theorem matrix.inv_eq_left_inv {n : Type u'} {Î± : Type v} [fintype n] [decidable_eq n] [comm_ring Î±] {A B : matrix n n Î±} (h : B.mul A = 1) : Aâ»Â¹ = B
theorem zero_mul_eq_const {Mâ‚€ : Type u_1} [mul_zero_class Mâ‚€] : has_mul.mul 0 = function.const Mâ‚€ 0
theorem polynomial.is_root_cyclotomic_prime_pow_mul_iff_of_char_p {m k p : â„•} {R : Type u_1} [comm_ring R] [is_domain R] [hp : fact (nat.prime p)] [hchar : char_p R p] {Î¼ : R} [ne_zero â†‘m] : (polynomial.cyclotomic (p ^ k * m) R).is_root Î¼ â†” is_primitive_root Î¼ m
theorem same_ray_smul_right_iff_of_ne {R : Type u_1} [linear_ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] [no_zero_smul_divisors R M] {v : M} (hv : v â‰  0) {r : R} (hr : r â‰  0) : same_ray R v (r â€¢ v) â†” 0 < r
theorem is_bounded_bilinear_map.is_bounded_linear_map_deriv {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {G : Type u_4} [normed_group G] [normed_space ğ•œ G] {f : E Ã— F â†’ G} (h : is_bounded_bilinear_map ğ•œ f) : is_bounded_linear_map ğ•œ (Î» (p : E Ã— F), h.deriv p)
theorem linear_map.is_Ortho.separating_right_iff_not_is_ortho_basis_self {R : Type u_1} {M : Type u_5} {n : Type u_14} [comm_ring R] [add_comm_group M] [module R M] [no_zero_divisors R] {B : M â†’â‚—[R] M â†’â‚—[R] R} (v : basis n R M) (hO : B.is_Ortho â‡‘v) (h : âˆ€ (i : n), Â¬B.is_ortho (â‡‘v i) (â‡‘v i)) : B.separating_right
theorem ideal.eq_zero_of_polynomial_mem_map_range {R : Type u} [comm_ring R] (I : ideal (polynomial R)) (x : â†¥(((ideal.quotient.mk I).comp polynomial.C).range)) (hx : â‡‘polynomial.C x âˆˆ ideal.map (polynomial.map_ring_hom ((ideal.quotient.mk I).comp polynomial.C).range_restrict) I) : x = 0
theorem liouville_with.rat_mul_iff {p x : â„} {r : â„š} (hr : r â‰  0) : liouville_with p (â†‘r * x) â†” liouville_with p x
theorem semilattice_sup_mk'_partial_order_eq_semilattice_inf_mk'_partial_order {Î± : Type u_1} [has_sup Î±] [has_inf Î±] (sup_comm : âˆ€ (a b : Î±), a âŠ” b = b âŠ” a) (sup_assoc : âˆ€ (a b c : Î±), a âŠ” b âŠ” c = a âŠ” (b âŠ” c)) (sup_idem : âˆ€ (a : Î±), a âŠ” a = a) (inf_comm : âˆ€ (a b : Î±), a âŠ“ b = b âŠ“ a) (inf_assoc : âˆ€ (a b c : Î±), a âŠ“ b âŠ“ c = a âŠ“ (b âŠ“ c)) (inf_idem : âˆ€ (a : Î±), a âŠ“ a = a) (sup_inf_self : âˆ€ (a b : Î±), a âŠ” a âŠ“ b = a) (inf_sup_self : âˆ€ (a b : Î±), a âŠ“ (a âŠ” b) = a) : semilattice_sup.to_partial_order Î± = semilattice_inf.to_partial_order Î±
theorem ultrafilter_is_open_basic {Î± : Type u} (s : set Î±) : is_open {u : ultrafilter Î± | s âˆˆ u}
theorem ideal.is_jacobson_iff_Inf_maximal {R : Type u_1} [comm_ring R] : ideal.is_jacobson R â†” âˆ€ {I : ideal R}, I.is_prime â†’ (âˆƒ (M : set (ideal R)), (âˆ€ (J : ideal R), J âˆˆ M â†’ J.is_maximal âˆ¨ J = âŠ¤) âˆ§ I = has_Inf.Inf M)
theorem affine_subspace.vadd_mem_mk' {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {v : V} (p : P) {direction : submodule k V} (hv : v âˆˆ direction) : v +áµ¥ p âˆˆ affine_subspace.mk' p direction
theorem function.periodic.Inf_add_zsmul_le_integral_of_pos {T : â„} {g : â„ â†’ â„} (hg : function.periodic g T) (h_int : âˆ€ (tâ‚ tâ‚‚ : â„), interval_integrable g measure_theory.measure_space.volume tâ‚ tâ‚‚) (hT : 0 < T) (t : â„) : has_Inf.Inf ((Î» (t : â„), âˆ« (x : â„) in 0..t, g x) '' set.Icc 0 T) + âŒŠt / TâŒ‹ â€¢ âˆ« (x : â„) in 0..T, g x â‰¤ âˆ« (x : â„) in 0..t, g x
theorem asymptotics.is_o.neg_left {Î± : Type u_1} {F : Type u_4} {E' : Type u_6} [has_norm F] [semi_normed_group E'] {g : Î± â†’ F} {f' : Î± â†’ E'} {l : filter Î±} : f' =o[l] g â†’ (Î» (x : Î±), -f' x) =o[l] g
theorem one_pos {Î± : Type u} [ordered_semiring Î±] [nontrivial Î±] : 0 < 1
theorem monoid_hom.map_mul_inv {Î± : Type u_1} {Î² : Type u_2} [group Î±] [division_monoid Î²] (f : Î± â†’* Î²) (g h : Î±) : â‡‘f (g * hâ»Â¹) = â‡‘f g * (â‡‘f h)â»Â¹
theorem norm_le_gronwall_bound_of_norm_deriv_right_le {E : Type u_1} [normed_group E] [normed_space â„ E] {f f' : â„ â†’ E} {Î´ K Îµ a b : â„} (hf : continuous_on f (set.Icc a b)) (hf' : âˆ€ (x : â„), x âˆˆ set.Ico a b â†’ has_deriv_within_at f (f' x) (set.Ici x) x) (ha : âˆ¥f aâˆ¥ â‰¤ Î´) (bound : âˆ€ (x : â„), x âˆˆ set.Ico a b â†’ âˆ¥f' xâˆ¥ â‰¤ K * âˆ¥f xâˆ¥ + Îµ) (x : â„) (H : x âˆˆ set.Icc a b) : âˆ¥f xâˆ¥ â‰¤ gronwall_bound Î´ K Îµ (x - a)
theorem submonoid.subset_closure {M : Type u_1} [mul_one_class M] {s : set M} : s âŠ† â†‘(submonoid.closure s)
theorem cont_diff_on_of_differentiable_on_deriv {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {F : Type u_2} [normed_group F] [normed_space ğ•œ F] {f : ğ•œ â†’ F} {s : set ğ•œ} {n : with_top â„•} (h : âˆ€ (m : â„•), â†‘m â‰¤ n â†’ differentiable_on ğ•œ (iterated_deriv_within m f s) s) : cont_diff_on ğ•œ n f s
theorem measurable.measurable_of_countable_ne {Î± : Type u_1} {Î² : Type u_2} {f g : Î± â†’ Î²} {m : measurable_space Î±} {mÎ² : measurable_space Î²} [measurable_singleton_class Î±] (hf : measurable f) (h : {x : Î± | f x â‰  g x}.countable) : measurable g
theorem is_mul_hom.comp {Î± : Type u} {Î² : Type v} [has_mul Î±] [has_mul Î²] {Î³ : Type u_1} [has_mul Î³] {f : Î± â†’ Î²} {g : Î² â†’ Î³} (hf : is_mul_hom f) (hg : is_mul_hom g) : is_mul_hom (g âˆ˜ f)
theorem cont_mdiff_on.continuous_on_tangent_map_within_aux {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners ğ•œ E' H'} {n : with_top â„•} {f : H â†’ H'} {s : set H} (hf : cont_mdiff_on I I' n f s) (hn : 1 â‰¤ n) (hs : unique_mdiff_on I s) : continuous_on (tangent_map_within I I' f s) (tangent_bundle.proj I H â»Â¹' s)
theorem is_monoid_hom.comp {Î± : Type u} {Î² : Type v} [mul_one_class Î±] [mul_one_class Î²] {f : Î± â†’ Î²} (hf : is_monoid_hom f) {Î³ : Type u_1} [mul_one_class Î³] {g : Î² â†’ Î³} (hg : is_monoid_hom g) : is_monoid_hom (g âˆ˜ f)
theorem measure_theory.content.inner_content_Sup_nat {G : Type w} [topological_space G] (Î¼ : measure_theory.content G) [t2_space G] (U : â„• â†’ topological_space.opens G) : Î¼.inner_content (â¨† (i : â„•), U i) â‰¤ âˆ‘' (i : â„•), Î¼.inner_content (U i)
theorem module.End.eigenspace_le_generalized_eigenspace {R : Type v} {M : Type w} [comm_ring R] [add_comm_group M] [module R M] {f : module.End R M} {Î¼ : R} {k : â„•} (hk : 0 < k) : f.eigenspace Î¼ â‰¤ â‡‘(f.generalized_eigenspace Î¼) k
theorem add_subsemigroup.closure_le {M : Type u_1} [has_add M] {s : set M} {S : add_subsemigroup M} : add_subsemigroup.closure s â‰¤ S â†” s âŠ† â†‘S
theorem monoid_hom.mrange_top_of_surjective {M : Type u_1} [mul_one_class M] {N : Type u_2} [mul_one_class N] (f : M â†’* N) (hf : function.surjective â‡‘f) : f.mrange = âŠ¤
theorem solvable_by_rad.induction3 {F : Type u_1} [field F] {E : Type u_2} [field E] [algebra F E] {Î± : â†¥(solvable_by_rad F E)} {n : â„•} (hn : n â‰  0) (hÎ± : solvable_by_rad.P (Î± ^ n)) : solvable_by_rad.P Î±
theorem vitali.exists_disjoint_covering_ae {Î± : Type u_1} [metric_space Î±] [measurable_space Î±] [opens_measurable_space Î±] [topological_space.second_countable_topology Î±] (Î¼ : measure_theory.measure Î±) [measure_theory.is_locally_finite_measure Î¼] (s : set Î±) (t : set (set Î±)) (hf : âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (Îµ : â„), Îµ > 0 â†’ (âˆƒ (a : set Î±) (H : a âˆˆ t), x âˆˆ a âˆ§ a âŠ† metric.closed_ball x Îµ)) (ht : âˆ€ (a : set Î±), a âˆˆ t â†’ (interior a).nonempty) (h't : âˆ€ (a : set Î±), a âˆˆ t â†’ is_closed a) (C : nnreal) (h : âˆ€ (a : set Î±), a âˆˆ t â†’ (âˆƒ (x : Î±) (H : x âˆˆ a), â‡‘Î¼ (metric.closed_ball x (3 * metric.diam a)) â‰¤ â†‘C * â‡‘Î¼ a)) : âˆƒ (u : set (set Î±)) (H : u âŠ† t), u.countable âˆ§ u.pairwise_disjoint id âˆ§ â‡‘Î¼ (s  â‹ƒ (a : set Î±) (H : a âˆˆ u), a) = 0
theorem disjointed_unique {Î± : Type u_1} [generalized_boolean_algebra Î±] {f d : â„• â†’ Î±} (hdisj : pairwise (disjoint on d)) (hsups : partial_sups d = partial_sups f) : d = disjointed f
theorem measurable.ae_strongly_measurable {Î± : Type u_1} {Î² : Type u_2} [topological_space Î²] {f : Î± â†’ Î²} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [measurable_space Î²] [topological_space.pseudo_metrizable_space Î²] [topological_space.second_countable_topology Î²] [opens_measurable_space Î²] (hf : measurable f) : measure_theory.ae_strongly_measurable f Î¼
theorem continuous.matrix_mul {X : Type u_1} {m : Type u_4} {n : Type u_5} {p : Type u_6} {R : Type u_8} [topological_space X] [topological_space R] [fintype n] [has_mul R] [add_comm_monoid R] [has_continuous_add R] [has_continuous_mul R] {A : X â†’ matrix m n R} {B : X â†’ matrix n p R} (hA : continuous A) (hB : continuous B) : continuous (Î» (x : X), (A x).mul (B x))
theorem finset.nat.antidiagonal_zero  : finset.nat.antidiagonal 0 = {(0, 0)}
theorem ring_hom.map_sum {Î² : Type u} {Î± : Type v} {Î³ : Type w} [non_assoc_semiring Î²] [non_assoc_semiring Î³] (g : Î² â†’+* Î³) (f : Î± â†’ Î²) (s : finset Î±) : â‡‘g (s.sum (Î» (x : Î±), f x)) = s.sum (Î» (x : Î±), â‡‘g (f x))
theorem orientation.rotation_zero {V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) : o.rotation 0 = linear_isometry_equiv.refl â„ V
theorem filter.at_bot_Iic_eq {Î± : Type u_3} [semilattice_inf Î±] (a : Î±) : filter.at_bot = filter.comap coe filter.at_bot
theorem free_group.red.nil_iff {Î± : Type u} {L : list (Î± Ã— bool)} : free_group.red list.nil L â†” L = list.nil
theorem intermediate_field.zero_mem {K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) : 0 âˆˆ S
theorem category_theory.limits.complete_lattice.limit_eq_infi {Î± : Type u} [complete_lattice Î±] {J : Type u} [category_theory.small_category J] (F : J â¥¤ Î±) : category_theory.limits.limit F = infi F.obj
theorem topological_fiber_bundle_core.continuous_const_section {Î¹ : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core Î¹ B F) (v : F) (h : âˆ€ (i j : Î¹) (x : B), x âˆˆ Z.base_set i âˆ© Z.base_set j â†’ Z.coord_change i j x v = v) : continuous (show B â†’ Z.total_space, from Î» (x : B), âŸ¨x, vâŸ©)
theorem zero_hom.congr_arg {M : Type u_3} {N : Type u_4} [has_zero M] [has_zero N] (f : zero_hom M N) {x y : M} (h : x = y) : â‡‘f x = â‡‘f y
theorem one_le_inv' {Î± : Type u} [group Î±] [has_le Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a : Î±} : 1 â‰¤ aâ»Â¹ â†” a â‰¤ 1
theorem inner_product_space.is_self_adjoint.has_eigenvalue_supr_of_finite_dimensional {ğ•œ : Type u_1} [is_R_or_C ğ•œ] {E : Type u_2} [inner_product_space ğ•œ E] [finite_dimensional ğ•œ E] [nontrivial E] {T : E â†’â‚—[ğ•œ] E} (hT : inner_product_space.is_self_adjoint T) : module.End.has_eigenvalue T (â†‘â¨† (x : {x // x â‰  0}), â‡‘is_R_or_C.re (has_inner.inner (â‡‘T â†‘x) â†‘x) / âˆ¥â†‘xâˆ¥ ^ 2)
theorem sub_mem {M : Type u_3} {S : Type u_4} [sub_neg_monoid M] [set_like S M] [hSM : add_subgroup_class S M] {H : S} {x y : M} (hx : x âˆˆ H) (hy : y âˆˆ H) : x - y âˆˆ H
theorem measurable_set_region_between {Î± : Type u_1} [measurable_space Î±] {f g : Î± â†’ â„} {s : set Î±} (hf : measurable f) (hg : measurable g) (hs : measurable_set s) : measurable_set (region_between f g s)
theorem image_norm_le_of_norm_deriv_right_lt_deriv_boundary' {E : Type u_1} [normed_group E] [normed_space â„ E] {f : â„ â†’ E} {a b : â„} {f' : â„ â†’ E} (hf : continuous_on f (set.Icc a b)) (hf' : âˆ€ (x : â„), x âˆˆ set.Ico a b â†’ has_deriv_within_at f (f' x) (set.Ici x) x) {B B' : â„ â†’ â„} (ha : âˆ¥f aâˆ¥ â‰¤ B a) (hB : continuous_on B (set.Icc a b)) (hB' : âˆ€ (x : â„), x âˆˆ set.Ico a b â†’ has_deriv_within_at B (B' x) (set.Ici x) x) (bound : âˆ€ (x : â„), x âˆˆ set.Ico a b â†’ âˆ¥f xâˆ¥ = B x â†’ âˆ¥f' xâˆ¥ < B' x) â¦ƒx : â„â¦„ : x âˆˆ set.Icc a b â†’ âˆ¥f xâˆ¥ â‰¤ B x
theorem norm_smul_inv_norm {ğ•œ : Type u_1} [is_R_or_C ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {x : E} (hx : x â‰  0) : âˆ¥(â†‘âˆ¥xâˆ¥)â»Â¹ â€¢ xâˆ¥ = 1
theorem neg_lt_zero {Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a : Î±} : -a < 0 â†” 0 < a
theorem fin.cast_eq_cast {n m : â„•} (h : n = m) : â‡‘(fin.cast h) = cast _
theorem matrix.det_reindex_alg_equiv {m : Type u_2} {n : Type u_3} (R : Type u_11) [comm_ring R] [fintype m] [decidable_eq m] [fintype n] [decidable_eq n] (e : m â‰ƒ n) (A : matrix m m R) : (â‡‘(matrix.reindex_alg_equiv R e) A).det = A.det
theorem continuous_map.continuous_eval_const {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [compact_space Î±] [metric_space Î²] (x : Î±) : continuous (Î» (f : C(Î±, Î²)), â‡‘f x)
theorem quot.lift_mk {Î± : Sort u_1} {Î³ : Sort u_4} {r : Î± â†’ Î± â†’ Prop} (f : Î± â†’ Î³) (h : âˆ€ (aâ‚ aâ‚‚ : Î±), r aâ‚ aâ‚‚ â†’ f aâ‚ = f aâ‚‚) (a : Î±) : quot.lift f h (quot.mk r a) = f a
theorem is_left_regular_of_non_zero_divisor {Î± : Type u} [non_unital_non_assoc_ring Î±] (k : Î±) (h : âˆ€ (x : Î±), k * x = 0 â†’ x = 0) : is_left_regular k
theorem mul_action.to_perm_injective {Î± : Type u} {Î² : Type v} [group Î±] [mul_action Î± Î²] [has_faithful_smul Î± Î²] : function.injective mul_action.to_perm
theorem submodule.span_subset_span (R : Type u_1) {M : Type u_4} (S : Type u_7) [semiring R] [add_comm_monoid M] [module R M] (s : set M) [semiring S] [has_scalar R S] [module S M] [is_scalar_tower R S M] : â†‘(submodule.span R s) âŠ† â†‘(submodule.span S s)
theorem real_inner_smul_self_left {F : Type u_3} [inner_product_space â„ F] (x : F) (r : â„) : has_inner.inner (r â€¢ x) x = r * (âˆ¥xâˆ¥ * âˆ¥xâˆ¥)
theorem filter.tendsto.le_comap {Î± : Type u} {Î² : Type v} {f : Î± â†’ Î²} {lâ‚ : filter Î±} {lâ‚‚ : filter Î²} : filter.tendsto f lâ‚ lâ‚‚ â†’ lâ‚ â‰¤ filter.comap f lâ‚‚
theorem interval_integral.integral_comp_mul_deriv {a b : â„} {f f' g : â„ â†’ â„} (h : âˆ€ (x : â„), x âˆˆ set.interval a b â†’ has_deriv_at f (f' x) x) (h' : continuous_on f' (set.interval a b)) (hg : continuous g) : âˆ« (x : â„) in a..b, (g âˆ˜ f) x * f' x = âˆ« (x : â„) in f a..f b, g x
theorem continuous_sigma {Î² : Type v} {Î¹ : Type u_5} {Ïƒ : Î¹ â†’ Type u_6} [Î  (i : Î¹), topological_space (Ïƒ i)] [topological_space Î²] {f : sigma Ïƒ â†’ Î²} (h : âˆ€ (i : Î¹), continuous (Î» (a : Ïƒ i), f âŸ¨i, aâŸ©)) : continuous f
theorem finset.sum_centroid_weights_indicator_eq_one_of_nonempty (k : Type u_1) [division_ring k] {Î¹ : Type u_4} (s : finset Î¹) [char_zero k] [fintype Î¹] (h : s.nonempty) : finset.univ.sum (Î» (i : Î¹), finset.centroid_weights_indicator k s i) = 1
theorem add_monoid_hom.map_exists_left_neg {M : Type u_3} {N : Type u_4} {F : Type u_8} {mM : add_zero_class M} {mN : add_zero_class N} [add_monoid_hom_class F M N] (f : F) {x : M} (hx : âˆƒ (y : M), y + x = 0) : âˆƒ (y : N), y + â‡‘f x = 0
theorem convex.combo_interior_self_subset_interior {E : Type u_2} {ğ•œ : Type u_3} [linear_ordered_field ğ•œ] [add_comm_group E] [module ğ•œ E] [topological_space E] [topological_add_group E] [has_continuous_const_smul ğ•œ E] {s : set E} (hs : convex ğ•œ s) {a b : ğ•œ} (ha : 0 < a) (hb : 0 â‰¤ b) (hab : a + b = 1) : a â€¢ interior s + b â€¢ s âŠ† interior s
theorem not_wcovby_iff {Î± : Type u_1} [preorder Î±] {a b : Î±} (h : a â‰¤ b) : Â¬a â©¿ b â†” âˆƒ (c : Î±), a < c âˆ§ c < b
theorem subgroup.map_injective_of_ker_le {G : Type u_1} [group G] {N : Type u_3} [group N] (f : G â†’* N) {H K : subgroup G} (hH : f.ker â‰¤ H) (hK : f.ker â‰¤ K) (hf : subgroup.map f H = subgroup.map f K) : H = K
theorem inv_mul_lt_of_lt_mul {Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a b c : Î±} : a < b * c â†’ bâ»Â¹ * a < c
theorem finite_dimensional.finrank_fintype_fun_eq_card (K : Type u) [division_ring K] {Î¹ : Type v} [fintype Î¹] : finite_dimensional.finrank K (Î¹ â†’ K) = fintype.card Î¹
theorem submodule.finrank_le {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] (s : submodule K V) : finite_dimensional.finrank K â†¥s â‰¤ finite_dimensional.finrank K V
theorem measure_theory.integral_integral_symm {Î± : Type u_1} {Î² : Type u_3} {E : Type u_6} [measurable_space Î±] [measurable_space Î²] {Î¼ : measure_theory.measure Î±} {Î½ : measure_theory.measure Î²} [normed_group E] [measure_theory.sigma_finite Î½] [normed_space â„ E] [complete_space E] [measure_theory.sigma_finite Î¼] {f : Î± â†’ Î² â†’ E} (hf : measure_theory.integrable (function.uncurry f) (Î¼.prod Î½)) : âˆ« (x : Î±), âˆ« (y : Î²), f x y âˆ‚Î½ âˆ‚Î¼ = âˆ« (z : Î² Ã— Î±), f z.snd z.fst âˆ‚Î½.prod Î¼
theorem emetric.inf_edist_le_inf_edist_add_Hausdorff_edist {Î± : Type u} [pseudo_emetric_space Î±] {x : Î±} {s t : set Î±} : emetric.inf_edist x t â‰¤ emetric.inf_edist x s + emetric.Hausdorff_edist s t
theorem witt_vector.frobenius_verschiebung {p : â„•} {R : Type u_1} [hp : fact (nat.prime p)] [comm_ring R] (x : witt_vector p R) : â‡‘witt_vector.frobenius (â‡‘witt_vector.verschiebung x) = x * â†‘p
theorem cont_diff_within_at.cont_mdiff_within_at {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {n : with_top â„•} {f : E â†’ E'} {s : set E} {x : E} : cont_diff_within_at ğ•œ n f s x â†’ cont_mdiff_within_at (model_with_corners_self ğ•œ E) (model_with_corners_self ğ•œ E') n f s x
theorem generalized_continued_fraction.int_fract_pair.nth_stream_fr_nonneg {K : Type u_1} {v : K} {n : â„•} [linear_ordered_field K] [floor_ring K] {ifp_n : generalized_continued_fraction.int_fract_pair K} (nth_stream_eq : generalized_continued_fraction.int_fract_pair.stream v n = option.some ifp_n) : 0 â‰¤ ifp_n.fr
theorem measurable_set.exists_is_closed_lt_add {Î± : Type u_1} [measurable_space Î±] [topological_space Î±] {Î¼ : measure_theory.measure Î±} [Î¼.weakly_regular] {s : set Î±} (hs : measurable_set s) (hÎ¼s : â‡‘Î¼ s â‰  âŠ¤) {Îµ : ennreal} (hÎµ : Îµ â‰  0) : âˆƒ (K : set Î±) (H : K âŠ† s), is_closed K âˆ§ â‡‘Î¼ s < â‡‘Î¼ K + Îµ
theorem subgroup.list_prod_mem {G : Type u_1} [group G] (K : subgroup G) {l : list G} : (âˆ€ (x : G), x âˆˆ l â†’ x âˆˆ K) â†’ l.prod âˆˆ K
theorem continuous_on.surj_on_of_tendsto' {Î± : Type u} [conditionally_complete_linear_order Î±] [topological_space Î±] [order_topology Î±] [densely_ordered Î±] {Î´ : Type u_1} [linear_order Î´] [topological_space Î´] [order_closed_topology Î´] {f : Î± â†’ Î´} {s : set Î±} [s.ord_connected] (hs : s.nonempty) (hf : continuous_on f s) (hbot : filter.tendsto (Î» (x : â†¥s), f â†‘x) filter.at_bot filter.at_top) (htop : filter.tendsto (Î» (x : â†¥s), f â†‘x) filter.at_top filter.at_bot) : set.surj_on f s set.univ
theorem real.nat_sqrt_le_real_sqrt {a : â„•} : â†‘(nat.sqrt a) â‰¤ real.sqrt â†‘a
theorem category_theory.presieve.is_sheaf_for.hom_ext {C : Type uâ‚} [category_theory.category C] {X : C} {S : category_theory.sieve X} {P : Cáµ’áµ– â¥¤ Type vâ‚} (h : category_theory.presieve.is_sheaf_for P â‡‘S) (tâ‚ tâ‚‚ : category_theory.yoneda.obj X âŸ¶ P) (ht : S.functor_inclusion â‰« tâ‚ = S.functor_inclusion â‰« tâ‚‚) : tâ‚ = tâ‚‚
theorem dense_compl_singleton_iff_not_open {Î± : Type u} [topological_space Î±] {x : Î±} : dense {x}á¶œ â†” Â¬is_open {x}
theorem list.prod_reverse_noncomm {G : Type u_7} [group G] (L : list G) : L.reverse.prod = ((list.map (Î» (x : G), xâ»Â¹) L).prod)â»Â¹
theorem con.inf_iff_and {M : Type u_1} [has_mul M] {c d : con M} {x y : M} : â‡‘(c âŠ“ d) x y â†” â‡‘c x y âˆ§ â‡‘d x y
theorem spectrum.smul_eq_smul {ğ•œ : Type u} {A : Type v} [field ğ•œ] [ring A] [algebra ğ•œ A] [nontrivial A] (k : ğ•œ) (a : A) (ha : (spectrum ğ•œ a).nonempty) : spectrum ğ•œ (k â€¢ a) = k â€¢ spectrum ğ•œ a
theorem monotone.cauchy_seq_alternating_series_of_tendsto_zero {f : â„• â†’ â„} (hfa : monotone f) (hf0 : filter.tendsto f filter.at_top (nhds 0)) : cauchy_seq (Î» (n : â„•), (finset.range (n + 1)).sum (Î» (i : â„•), (-1) ^ i * f i))
theorem convex_cone.blunt.salient {ğ•œ : Type u_1} {E : Type u_2} [ordered_semiring ğ•œ] [add_comm_group E] [has_scalar ğ•œ E] {S : convex_cone ğ•œ E} : S.blunt â†’ S.salient
theorem measure_theory.lintegral_add_mul_meas_add_le_le_lintegral {Î± : Type u_1} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {f g : Î± â†’ ennreal} (hle : f â‰¤áµ[Î¼] g) (hg : ae_measurable g Î¼) (Îµ : ennreal) : âˆ«â» (a : Î±), f a âˆ‚Î¼ + Îµ * â‡‘Î¼ {x : Î± | f x + Îµ â‰¤ g x} â‰¤ âˆ«â» (a : Î±), g a âˆ‚Î¼
theorem finsum_mem_range' {Î± : Type u_1} {Î² : Type u_2} {M : Type u_5} [add_comm_monoid M] {f : Î± â†’ M} {g : Î² â†’ Î±} (hg : set.inj_on g (function.support (f âˆ˜ g))) : finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ set.range g), f i)) = finsum (Î» (j : Î²), f (g j))
theorem cont_diff_of_differentiable_iterated_deriv {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {F : Type u_2} [normed_group F] [normed_space ğ•œ F] {f : ğ•œ â†’ F} {n : with_top â„•} (h : âˆ€ (m : â„•), â†‘m â‰¤ n â†’ differentiable ğ•œ (iterated_deriv m f)) : cont_diff ğ•œ n f
theorem affine.simplex.monge_point_eq_smul_vsub_vadd_circumcenter {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {n : â„•} (s : affine.simplex â„ P n) : s.monge_point = (â†‘(n + 1) / â†‘(n - 1)) â€¢ (finset.centroid â„ finset.univ s.points -áµ¥ s.circumcenter) +áµ¥ s.circumcenter
theorem module.free.finrank_tensor_product (R : Type u) [comm_ring R] [strong_rank_condition R] (M : Type v) (N : Type w) [add_comm_group M] [module R M] [module.free R M] [add_comm_group N] [module R N] [module.free R N] : finite_dimensional.finrank R (tensor_product R M N) = finite_dimensional.finrank R M * finite_dimensional.finrank R N
theorem polynomial.root_multiplicity_of_dvd {R : Type u} [comm_ring R] [is_domain R] {p : polynomial R} {a : R} {n : â„•} (hzero : p â‰  0) (h : (polynomial.X - â‡‘polynomial.C a) ^ n âˆ£ p) : n â‰¤ polynomial.root_multiplicity a p
theorem finset.all_card_le_bUnion_card_iff_exists_injective' {Î¹ : Type u_1} {Î± : Type u_2} [fintype Î¹] [decidable_eq Î±] (t : Î¹ â†’ finset Î±) : (âˆ€ (s : finset Î¹), s.card â‰¤ (s.bUnion t).card) â†” âˆƒ (f : Î¹ â†’ Î±), function.injective f âˆ§ âˆ€ (x : Î¹), f x âˆˆ t x
theorem local_equiv.eq_on_source.eq_on {Î± : Type u_1} {Î² : Type u_2} {e e' : local_equiv Î± Î²} (h : e â‰ˆ e') : set.eq_on â‡‘e â‡‘e' e.source
theorem linear_map.bound_of_ball_bound' {ğ•œ : Type u_1} [is_R_or_C ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {r : â„} (r_pos : 0 < r) (c : â„) (f : E â†’â‚—[ğ•œ] ğ•œ) (h : âˆ€ (z : E), z âˆˆ metric.closed_ball 0 r â†’ âˆ¥â‡‘f zâˆ¥ â‰¤ c) (z : E) : âˆ¥â‡‘f zâˆ¥ â‰¤ c / r * âˆ¥zâˆ¥
theorem emetric.is_closed_subsets_of_is_closed {Î± : Type u} [emetric_space Î±] {s : set Î±} (hs : is_closed s) : is_closed {t : topological_space.closeds Î± | â†‘t âŠ† s}
theorem continuous.tendsto' {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] {f : Î± â†’ Î²} (hf : continuous f) (x : Î±) (y : Î²) (h : f x = y) : filter.tendsto f (nhds x) (nhds y)
theorem measure_theory.mem_â„’p.snorm_indicator_norm_ge_pos_le {Î± : Type u_1} {Î² : Type u_2} {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) [normed_group Î²] {p : ennreal} {f : Î± â†’ Î²} (hf : measure_theory.mem_â„’p f p Î¼) (hmeas : measure_theory.strongly_measurable f) {Îµ : â„} (hÎµ : 0 < Îµ) : âˆƒ (M : â„), 0 < M âˆ§ measure_theory.snorm ({x : Î± | M â‰¤ â†‘âˆ¥f xâˆ¥â‚Š}.indicator f) p Î¼ â‰¤ ennreal.of_real Îµ
theorem cont_diff_on_of_locally_cont_diff_on {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {s : set E} {f : E â†’ F} {n : with_top â„•} (h : âˆ€ (x : E), x âˆˆ s â†’ (âˆƒ (u : set E), is_open u âˆ§ x âˆˆ u âˆ§ cont_diff_on ğ•œ n f (s âˆ© u))) : cont_diff_on ğ•œ n f s
theorem category_theory.limits.fork.is_limit.hom_iso_natural {C : Type u} [category_theory.category C] {X Y : C} {f g : X âŸ¶ Y} {t : category_theory.limits.fork f g} (ht : category_theory.limits.is_limit t) {Z Z' : C} (q : Z' âŸ¶ Z) (k : Z âŸ¶ t.X) : â†‘(â‡‘(category_theory.limits.fork.is_limit.hom_iso ht Z') (q â‰« k)) = q â‰« â†‘(â‡‘(category_theory.limits.fork.is_limit.hom_iso ht Z) k)
theorem local_homeomorph.has_deriv_at_symm {ğ•œ : Type u} [nondiscrete_normed_field ğ•œ] (f : local_homeomorph ğ•œ ğ•œ) {a f' : ğ•œ} (ha : a âˆˆ f.to_local_equiv.target) (hf' : f' â‰  0) (htff' : has_deriv_at â‡‘f f' (â‡‘(f.symm) a)) : has_deriv_at â‡‘(f.symm) f'â»Â¹ a
theorem dense.diff_singleton {Î± : Type u} [topological_space Î±] [t1_space Î±] {s : set Î±} (hs : dense s) (x : Î±) [(nhds_within x {x}á¶œ).ne_bot] : dense (s  {x})
theorem measure_theory.tendsto_Lp_of_tendsto_ae_of_meas {Î± : Type u_1} {Î² : Type u_2} {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) [normed_group Î²] {p : ennreal} [measure_theory.is_finite_measure Î¼] (hp : 1 â‰¤ p) (hp' : p â‰  âŠ¤) {f : â„• â†’ Î± â†’ Î²} {g : Î± â†’ Î²} (hf : âˆ€ (n : â„•), measure_theory.strongly_measurable (f n)) (hg : measure_theory.strongly_measurable g) (hg' : measure_theory.mem_â„’p g p Î¼) (hui : measure_theory.unif_integrable f p Î¼) (hfg : âˆ€áµ (x : Î±) âˆ‚Î¼, filter.tendsto (Î» (n : â„•), f n x) filter.at_top (nhds (g x))) : filter.tendsto (Î» (n : â„•), measure_theory.snorm (f n - g) p Î¼) filter.at_top (nhds 0)
theorem is_coatom.covby_top {Î± : Type u_1} [partial_order Î±] [order_top Î±] {a : Î±} : is_coatom a â†’ a â‹– âŠ¤
theorem tendsto_of_tendsto_of_tendsto_of_le_of_le' {Î± : Type u} {Î² : Type v} [topological_space Î±] [partial_order Î±] [t : order_topology Î±] {f g h : Î² â†’ Î±} {b : filter Î²} {a : Î±} (hg : filter.tendsto g b (nhds a)) (hh : filter.tendsto h b (nhds a)) (hgf : âˆ€á¶  (b : Î²) in b, g b â‰¤ f b) (hfh : âˆ€á¶  (b : Î²) in b, f b â‰¤ h b) : filter.tendsto f b (nhds a)
theorem monotone_stabilizes_iff_artinian {R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] : (âˆ€ (f : â„• â†’o (submodule R M)áµ’áµˆ), âˆƒ (n : â„•), âˆ€ (m : â„•), n â‰¤ m â†’ â‡‘f n = â‡‘f m) â†” is_artinian R M
theorem is_localization.eq_of_eq {R : Type u_1} [comm_semiring R] {M : submonoid R} {S : Type u_2} [comm_semiring S] [algebra R S] {P : Type u_3} [comm_semiring P] [is_localization M S] {g : R â†’+* P} (hg : âˆ€ (y : â†¥M), is_unit (â‡‘g â†‘y)) {x y : R} (h : â‡‘(algebra_map R S) x = â‡‘(algebra_map R S) y) : â‡‘g x = â‡‘g y
theorem is_regular_of_ne_zero {R : Type u_1} {a : R} [cancel_monoid_with_zero R] (a0 : a â‰  0) : is_regular a
theorem nat.dvd_right_iff_eq {m n : â„•} : (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n
theorem minpoly.irreducible {A : Type u_1} {B : Type u_2} [comm_ring A] [is_domain A] [ring B] [algebra A B] {x : B} [is_domain B] (hx : is_integral A x) : irreducible (minpoly A x)
theorem add_monoid_hom.mk_normed_group_hom_norm_le {Vâ‚ : Type u_2} {Vâ‚‚ : Type u_3} [semi_normed_group Vâ‚] [semi_normed_group Vâ‚‚] (f : Vâ‚ â†’+ Vâ‚‚) {C : â„} (hC : 0 â‰¤ C) (h : âˆ€ (x : Vâ‚), âˆ¥â‡‘f xâˆ¥ â‰¤ C * âˆ¥xâˆ¥) : âˆ¥f.mk_normed_group_hom C hâˆ¥ â‰¤ C
theorem antitone_on.map_bdd_below {Î± : Type u} {Î² : Type v} [preorder Î±] [preorder Î²] {f : Î± â†’ Î²} {s t : set Î±} (Hf : antitone_on f t) (Hst : s âŠ† t) : (lower_bounds s âˆ© t).nonempty â†’ bdd_above (f '' s)
theorem graded_monoid.list_prod_map_eq_dprod {Î¹ : Type u_1} {Î± : Type u_2} {A : Î¹ â†’ Type u_3} [add_monoid Î¹] [graded_monoid.gmonoid A] (l : list Î±) (f : Î± â†’ graded_monoid A) : (list.map f l).prod = graded_monoid.mk (l.dprod_index (Î» (i : Î±), (f i).fst)) (l.dprod (Î» (i : Î±), (f i).fst) (Î» (i : Î±), (f i).snd))
theorem filter.tendsto.at_top_mul_const' {Î± : Type u_1} {R : Type u_2} {l : filter Î±} {f : Î± â†’ R} {r : R} [linear_ordered_semiring R] [archimedean R] (hr : 0 < r) (hf : filter.tendsto f l filter.at_top) : filter.tendsto (Î» (x : Î±), f x * r) l filter.at_top
theorem measure_theory.measure_preserving.conservative {Î± : Type u_2} [measurable_space Î±] {f : Î± â†’ Î±} {Î¼ : measure_theory.measure Î±} [measure_theory.is_finite_measure Î¼] (h : measure_theory.measure_preserving f Î¼ Î¼) : measure_theory.conservative f Î¼
theorem eq.superset {Î± : Type u} [has_subset Î±] {a b : Î±} [is_refl Î± has_subset.subset] : a = b â†’ b âŠ† a
theorem mem_nhds_within_Iic_iff_exists_Icc_subset' {Î± : Type u} [topological_space Î±] [linear_order Î±] [order_topology Î±] [no_min_order Î±] [densely_ordered Î±] {a : Î±} {s : set Î±} : s âˆˆ nhds_within a (set.Iic a) â†” âˆƒ (l : Î±) (H : l âˆˆ set.Iio a), set.Icc l a âŠ† s
theorem minpoly.dvd (A : Type u_1) {B : Type u_2} [field A] [ring B] [algebra A B] (x : B) {p : polynomial A} (hp : â‡‘(polynomial.aeval x) p = 0) : minpoly A x âˆ£ p
theorem finset.image_imageâ‚‚_antidistrib_right {Î± : Type u_1} {Î±' : Type u_2} {Î² : Type u_3} {Î³ : Type u_5} {Î´ : Type u_7} [decidable_eq Î±'] [decidable_eq Î³] [decidable_eq Î´] {f : Î± â†’ Î² â†’ Î³} {s : finset Î±} {t : finset Î²} {g : Î³ â†’ Î´} {f' : Î² â†’ Î±' â†’ Î´} {g' : Î± â†’ Î±'} (h_antidistrib : âˆ€ (a : Î±) (b : Î²), g (f a b) = f' b (g' a)) : finset.image g (finset.imageâ‚‚ f s t) = finset.imageâ‚‚ f' t (finset.image g' s)
theorem is_group_hom.id {Î± : Type u} [group Î±] : is_group_hom id
theorem continuous.exists_forall_ge' {Î± : Type u_1} {Î² : Type u_2} [conditionally_complete_linear_order Î±] [topological_space Î±] [order_topology Î±] [topological_space Î²] {f : Î² â†’ Î±} (hf : continuous f) (xâ‚€ : Î²) (h : âˆ€á¶  (x : Î²) in filter.cocompact Î², f x â‰¤ f xâ‚€) : âˆƒ (x : Î²), âˆ€ (y : Î²), f y â‰¤ f x
theorem set.mem_bInter {Î± : Type u_1} {Î² : Type u_2} {s : set Î±} {t : Î± â†’ set Î²} {y : Î²} (h : âˆ€ (x : Î±), x âˆˆ s â†’ y âˆˆ t x) : y âˆˆ â‹‚ (x : Î±) (H : x âˆˆ s), t x
theorem circle_deg1_lift.forall_map_sub_of_Icc (f : circle_deg1_lift) (P : â„ â†’ Prop) (h : âˆ€ (x : â„), x âˆˆ set.Icc 0 1 â†’ P (â‡‘f x - x)) (x : â„) : P (â‡‘f x - x)
theorem finrank_vector_span_image_finset_le (k : Type u_1) {V : Type u_2} {P : Type u_3} {Î¹ : Type u_4} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] (p : Î¹ â†’ P) (s : finset Î¹) {n : â„•} (hc : s.card = n + 1) : finite_dimensional.finrank k â†¥(vector_span k â†‘(finset.image p s)) â‰¤ n
theorem local_homeomorph.continuous_within_at_iff_continuous_within_at_comp_left {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [topological_space Î±] [topological_space Î²] [topological_space Î³] (e : local_homeomorph Î± Î²) {f : Î³ â†’ Î±} {s : set Î³} {x : Î³} (hx : f x âˆˆ e.to_local_equiv.source) (h : f â»Â¹' e.to_local_equiv.source âˆˆ nhds_within x s) : continuous_within_at f s x â†” continuous_within_at (â‡‘e âˆ˜ f) s x
theorem function.injective.pairwise_ne {Î± : Type u_1} {Î¹ : Type u_2} {f : Î¹ â†’ Î±} : function.injective f â†’ pairwise (ne on f)
theorem sym.map_id' {Î± : Type u_1} {n : â„•} (s : sym Î± n) : sym.map (Î» (x : Î±), x) s = s
theorem representation.char_one {k : Type u_1} {G : Type u_2} {V : Type u_3} [comm_ring k] [group G] [add_comm_group V] [module k V] (Ï : representation k G V) [nontrivial k] [module.free k V] [module.finite k V] : Ï.character 1 = â†‘(finite_dimensional.finrank k V)
theorem affine_map.decomp {k : Type u_1} {V1 : Type u_2} {V2 : Type u_4} [ring k] [add_comm_group V1] [module k V1] [add_comm_group V2] [module k V2] (f : V1 â†’áµƒ[k] V2) : â‡‘f = â‡‘(f.linear) + Î» (z : V1), â‡‘f 0
theorem phragmen_lindelof.quadrant_II {E : Type u_1} [normed_group E] [normed_space â„‚ E] {C : â„} {f : â„‚ â†’ E} {z : â„‚} (hd : diff_cont_on_cl â„‚ f (set.Iio 0 Ã—â„‚ set.Ioi 0)) (hB : âˆƒ (c : â„) (H : c < 2) (B : â„), f =O[filter.comap complex.abs filter.at_top âŠ“ filter.principal (set.Iio 0 Ã—â„‚ set.Ioi 0)] Î» (z : â„‚), real.exp (B * complex.abs z ^ c)) (hre : âˆ€ (x : â„), x â‰¤ 0 â†’ âˆ¥f â†‘xâˆ¥ â‰¤ C) (him : âˆ€ (x : â„), 0 â‰¤ x â†’ âˆ¥f (â†‘x * complex.I)âˆ¥ â‰¤ C) (hz_re : z.re â‰¤ 0) (hz_im : 0 â‰¤ z.im) : âˆ¥f zâˆ¥ â‰¤ C
theorem add_monoid_algebra.exists_finset_adjoin_eq_top {R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_monoid M] [h : algebra.finite_type R (add_monoid_algebra R M)] : âˆƒ (G : finset M), algebra.adjoin R (add_monoid_algebra.of' R M '' â†‘G) = âŠ¤
theorem first_order.language.substructure.dense_induction {L : first_order.language} {M : Type w} [L.Structure M] {p : M â†’ Prop} (x : M) {s : set M} (hs : â‡‘(first_order.language.substructure.closure L) s = âŠ¤) (Hs : âˆ€ (x : M), x âˆˆ s â†’ p x) (Hfun : âˆ€ {n : â„•} (f : L.functions n), first_order.language.closed_under f (set_of p)) : p x
theorem box_integral.box.subbox_induction_on' {Î¹ : Type u_1} {p : box_integral.box Î¹ â†’ Prop} (I : box_integral.box Î¹) (H_ind : âˆ€ (J : box_integral.box Î¹), J â‰¤ I â†’ (âˆ€ (s : set Î¹), p (J.split_center_box s)) â†’ p J) (H_nhds : âˆ€ (z : Î¹ â†’ â„), z âˆˆ â‡‘box_integral.box.Icc I â†’ (âˆƒ (U : set (Î¹ â†’ â„)) (H : U âˆˆ nhds_within z (â‡‘box_integral.box.Icc I)), âˆ€ (J : box_integral.box Î¹), J â‰¤ I â†’ âˆ€ (m : â„•), z âˆˆ â‡‘box_integral.box.Icc J â†’ â‡‘box_integral.box.Icc J âŠ† U â†’ (âˆ€ (i : Î¹), J.upper i - J.lower i = (I.upper i - I.lower i) / 2 ^ m) â†’ p J)) : p I
theorem analytic_on.iterated_fderiv {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {f : E â†’ F} {s : set E} [complete_space F] (h : analytic_on ğ•œ f s) (n : â„•) : analytic_on ğ•œ (iterated_fderiv ğ•œ n f) s
theorem add_submonoid.localization_map.lift_mk' {M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {N : Type u_2} [add_comm_monoid N] {P : Type u_3} [add_comm_monoid P] (f : S.localization_map N) {g : M â†’+ P} (hg : âˆ€ (y : â†¥S), is_add_unit (â‡‘g â†‘y)) (x : M) (y : â†¥S) : â‡‘(f.lift hg) (f.mk' x y) = â‡‘g x + â†‘-â‡‘(is_add_unit.lift_right (g.restrict S) hg) y
theorem fintype.card_compl_eq_card_compl {Î± : Type u_1} [fintype Î±] (p q : Î± â†’ Prop) [fintype {x // p x}] [fintype {x // Â¬p x}] [fintype {x // q x}] [fintype {x // Â¬q x}] (h : fintype.card {x // p x} = fintype.card {x // q x}) : fintype.card {x // Â¬p x} = fintype.card {x // Â¬q x}
theorem category_theory.presieve.is_sheaf_for_iso {C : Type uâ‚} [category_theory.category C] {P : Cáµ’áµ– â¥¤ Type w} {X : C} {R : category_theory.presieve X} {P' : Cáµ’áµ– â¥¤ Type w} (i : P â‰… P') : category_theory.presieve.is_sheaf_for P R â†’ category_theory.presieve.is_sheaf_for P' R
theorem convex.norm_image_sub_le_of_norm_has_deriv_within_le {ğ•œ : Type u_3} {G : Type u_4} [is_R_or_C ğ•œ] [normed_group G] [normed_space ğ•œ G] {f f' : ğ•œ â†’ G} {s : set ğ•œ} {x y : ğ•œ} {C : â„} (hf : âˆ€ (x : ğ•œ), x âˆˆ s â†’ has_deriv_within_at f (f' x) s x) (bound : âˆ€ (x : ğ•œ), x âˆˆ s â†’ âˆ¥f' xâˆ¥ â‰¤ C) (hs : convex â„ s) (xs : x âˆˆ s) (ys : y âˆˆ s) : âˆ¥f y - f xâˆ¥ â‰¤ C * âˆ¥y - xâˆ¥
theorem finprod_mem_insert' {Î± : Type u_1} {M : Type u_5} [comm_monoid M] {a : Î±} {s : set Î±} (f : Î± â†’ M) (h : a âˆ‰ s) (hs : (s âˆ© function.mul_support f).finite) : finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ has_insert.insert a s), f i)) = f a * finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), f i))
theorem is_local_min_on.has_fderiv_within_at_nonneg {E : Type u} [normed_group E] [normed_space â„ E] {f : E â†’ â„} {a : E} {f' : E â†’L[â„] â„} {s : set E} (h : is_local_min_on f s a) (hf : has_fderiv_within_at f f' s a) {y : E} (hy : y âˆˆ pos_tangent_cone_at s a) : 0 â‰¤ â‡‘f' y
theorem nonempty_sections_of_fintype_inverse_system {J : Type u} [preorder J] [is_directed J has_le.le] (F : Jáµ’áµ– â¥¤ Type v) [Î  (j : Jáµ’áµ–), fintype (F.obj j)] [âˆ€ (j : Jáµ’áµ–), nonempty (F.obj j)] : F.sections.nonempty
theorem hindman.exists_FP_of_finite_cover {M : Type u_1} [semigroup M] [nonempty M] (s : set (set M)) (sfin : s.finite) (scov : âŠ¤ âŠ† â‹ƒâ‚€s) : âˆƒ (c : set M) (H : c âˆˆ s) (a : stream M), hindman.FP a âŠ† c
theorem monotone.cauchy_seq_series_mul_of_tendsto_zero_of_bounded {E : Type u_4} [normed_group E] [normed_space â„ E] {b : â„} {f : â„• â†’ â„} {z : â„• â†’ E} (hfa : monotone f) (hf0 : filter.tendsto f filter.at_top (nhds 0)) (hgb : âˆ€ (n : â„•), âˆ¥(finset.range n).sum (Î» (i : â„•), z i)âˆ¥ â‰¤ b) : cauchy_seq (Î» (n : â„•), (finset.range (n + 1)).sum (Î» (i : â„•), f i â€¢ z i))
theorem neg_dvd {Î± : Type u} [semigroup Î±] [has_distrib_neg Î±] (a b : Î±) : -a âˆ£ b â†” a âˆ£ b
theorem metric.tendsto_uniformly_iff {Î± : Type u} {Î² : Type v} [pseudo_metric_space Î±] {Î¹ : Type u_1} {F : Î¹ â†’ Î² â†’ Î±} {f : Î² â†’ Î±} {p : filter Î¹} : tendsto_uniformly F f p â†” âˆ€ (Îµ : â„), Îµ > 0 â†’ (âˆ€á¶  (n : Î¹) in p, âˆ€ (x : Î²), has_dist.dist (f x) (F n x) < Îµ)
theorem basis.map_orientation_eq_det_inv_smul {R : Type u_1} [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {Î¹ : Type u_4} [fintype Î¹] [decidable_eq Î¹] (e : basis Î¹ R M) (x : orientation R M Î¹) (f : M â‰ƒâ‚—[R] M) : â‡‘(orientation.map Î¹ f) x = (â‡‘linear_equiv.det f)â»Â¹ â€¢ x
theorem finset.univ_perm_option {Î± : Type u_1} [decidable_eq Î±] [fintype Î±] : finset.univ = finset.map equiv.perm.decompose_option.symm.to_embedding finset.univ
theorem cauchy_seq_range_of_norm_bounded {E : Type u_3} [semi_normed_group E] {f : â„• â†’ E} (g : â„• â†’ â„) (hg : cauchy_seq (Î» (n : â„•), (finset.range n).sum (Î» (i : â„•), g i))) (hf : âˆ€ (i : â„•), âˆ¥f iâˆ¥ â‰¤ g i) : cauchy_seq (Î» (n : â„•), (finset.range n).sum (Î» (i : â„•), f i))
theorem set.finite.is_closed_convex_hull {E : Type u_2} [add_comm_group E] [module â„ E] [topological_space E] [topological_add_group E] [has_continuous_smul â„ E] [t2_space E] {s : set E} (hs : s.finite) : is_closed (â‡‘(convex_hull â„) s)
theorem matrix.pivot.is_two_block_diagonal_list_transvec_col_mul_mul_list_transvec_row {ğ•œ : Type u_3} [field ğ•œ] {r : â„•} (M : matrix (fin r âŠ• unit) (fin r âŠ• unit) ğ•œ) (hM : M (sum.inr ()) (sum.inr ()) â‰  0) : (((matrix.pivot.list_transvec_col M).prod.mul M).mul (matrix.pivot.list_transvec_row M).prod).is_two_block_diagonal
theorem affine_subspace.direction_mk' {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (p : P) (direction : submodule k V) : (affine_subspace.mk' p direction).direction = direction
theorem eq.trans_ge {Î± : Type u} [preorder Î±] {a b c : Î±} : b = c â†’ a â‰¤ b â†’ a â‰¤ c
theorem orientation.eq_iff_norm_eq_of_oangle_eq_zero {V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) {x y : V} (h : o.oangle x y = 0) : x = y â†” âˆ¥xâˆ¥ = âˆ¥yâˆ¥
theorem list.intercalate_split_on {Î± : Type u} (xs : list Î±) (x : Î±) [decidable_eq Î±] : [x].intercalate (list.split_on x xs) = xs
theorem norm_image_of_norm_zero {ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_normed_group E] [semi_normed_group F] [nondiscrete_normed_field ğ•œ] [nondiscrete_normed_field ğ•œâ‚‚] [normed_space ğ•œ E] [normed_space ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} {f : E â†’â‚›â‚—[Ïƒâ‚â‚‚] F} (hf : continuous â‡‘f) {x : E} (hx : âˆ¥xâˆ¥ = 0) : âˆ¥â‡‘f xâˆ¥ = 0
theorem list.exists_chain_of_relation_refl_trans_gen {Î± : Type u} {r : Î± â†’ Î± â†’ Prop} {a b : Î±} (h : relation.refl_trans_gen r a b) : âˆƒ (l : list Î±), list.chain r a l âˆ§ (a :: l).last _ = b
theorem subfield.zero_mem {K : Type u} [field K] (s : subfield K) : 0 âˆˆ s
theorem submonoid.mem_closure_pair {A : Type u_1} [comm_monoid A] (a b c : A) : c âˆˆ submonoid.closure {a, b} â†” âˆƒ (m n : â„•), a ^ m * b ^ n = c
theorem mv_polynomial.mem_ideal_of_coeff_mem_ideal {R : Type u} {Ïƒ : Type v} [comm_ring R] (I : ideal (mv_polynomial Ïƒ R)) (p : mv_polynomial Ïƒ R) (hcoe : âˆ€ (m : Ïƒ â†’â‚€ â„•), mv_polynomial.coeff m p âˆˆ ideal.comap mv_polynomial.C I) : p âˆˆ I
theorem first_order.language.exists_cg_is_age_of {L : first_order.language} {K : set (category_theory.bundled L.Structure)} (hn : K.nonempty) (h : âˆ€ (M N : category_theory.bundled L.Structure), nonempty (L.equiv â†¥M â†¥N) â†’ (M âˆˆ K â†” N âˆˆ K)) (hc : (quotient.mk '' K).countable) (fg : âˆ€ (M : category_theory.bundled L.Structure), M âˆˆ K â†’ first_order.language.Structure.fg L â†¥M) (hp : first_order.language.hereditary K) (jep : first_order.language.joint_embedding K) : âˆƒ (M : category_theory.bundled L.Structure), first_order.language.Structure.cg L â†¥M âˆ§ L.age â†¥M = K
theorem set.finset_sum_subset_finset_sum {Î± : Type u_2} {Î¹ : Type u_5} [add_comm_monoid Î±] (t : finset Î¹) (fâ‚ fâ‚‚ : Î¹ â†’ set Î±) (hf : âˆ€ {i : Î¹}, i âˆˆ t â†’ fâ‚ i âŠ† fâ‚‚ i) : t.sum (Î» (i : Î¹), fâ‚ i) âŠ† t.sum (Î» (i : Î¹), fâ‚‚ i)
theorem topological_fiber_bundle.trivialization.continuous_at_proj {B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z â†’ B} [topological_space Z] (e : topological_fiber_bundle.trivialization F proj) {x : Z} (ex : x âˆˆ e.to_local_homeomorph.to_local_equiv.source) : continuous_at proj x
theorem matrix.is_unit_diagonal {n : Type u'} {Î± : Type v} [fintype n] [decidable_eq n] [comm_ring Î±] {v : n â†’ Î±} : is_unit (matrix.diagonal v) â†” is_unit v
theorem real.sign_apply_eq_of_ne_zero (r : â„) (h : r â‰  0) : r.sign = -1 âˆ¨ r.sign = 1
theorem fermat_42.coprime_of_minimal {a b c : â„¤} (h : fermat_42.minimal a b c) : is_coprime a b
theorem ordered_add_comm_group.lt_of_add_lt_add_left {Î± : Type u_1} [has_add Î±] [has_lt Î±] [contravariant_class Î± Î± has_add.add has_lt.lt] {a b c : Î±} (bc : a + b < a + c) : b < c
theorem has_subset.subset.eq_or_ssubset {Î± : Type u} [has_subset Î±] [has_ssubset Î±] [is_nonstrict_strict_order Î± has_subset.subset has_ssubset.ssubset] {a b : Î±} [is_antisymm Î± has_subset.subset] (h : a âŠ† b) : a = b âˆ¨ a âŠ‚ b
theorem interval_integral.integral_comp_mul_deriv'' {a b : â„} {f f' g : â„ â†’ â„} (hf : continuous_on f (set.interval a b)) (hff' : âˆ€ (x : â„), x âˆˆ set.Ioo (linear_order.min a b) (linear_order.max a b) â†’ has_deriv_within_at f (f' x) (set.Ioi x) x) (hf' : continuous_on f' (set.interval a b)) (hg : continuous_on g (f '' set.interval a b)) : âˆ« (x : â„) in a..b, (g âˆ˜ f) x * f' x = âˆ« (u : â„) in f a..f b, g u
theorem pgame.lf_def {x y : pgame} : x.lf y â†” (âˆƒ (i : y.left_moves), (âˆ€ (i' : x.left_moves), (x.move_left i').lf (y.move_left i)) âˆ§ âˆ€ (j : (y.move_left i).right_moves), x.lf ((y.move_left i).move_right j)) âˆ¨ âˆƒ (j : x.right_moves), (âˆ€ (i : (x.move_right j).left_moves), ((x.move_right j).move_left i).lf y) âˆ§ âˆ€ (j' : y.right_moves), (x.move_right j).lf (y.move_right j')
theorem subsemigroup.closure_mono {M : Type u_1} [has_mul M] â¦ƒs t : set Mâ¦„ (h : s âŠ† t) : subsemigroup.closure s â‰¤ subsemigroup.closure t
theorem submodule.span_le_restrict_scalars (R : Type u_1) {M : Type u_4} (S : Type u_7) [semiring R] [add_comm_monoid M] [module R M] (s : set M) [semiring S] [has_scalar R S] [module S M] [is_scalar_tower R S M] : submodule.span R s â‰¤ submodule.restrict_scalars R (submodule.span S s)
theorem free_group.red.singleton_iff {Î± : Type u} {Lâ‚ : list (Î± Ã— bool)} {x : Î± Ã— bool} : free_group.red [x] Lâ‚ â†” Lâ‚ = [x]
theorem well_founded_gt_exact_sequence {Î± : Type u_1} [lattice Î±] [is_modular_lattice Î±] {Î² : Type u_2} {Î³ : Type u_3} [preorder Î²] [partial_order Î³] (hâ‚ : well_founded gt) (hâ‚‚ : well_founded gt) (K : Î±) (fâ‚ : Î² â†’ Î±) (fâ‚‚ : Î± â†’ Î²) (gâ‚ : Î³ â†’ Î±) (gâ‚‚ : Î± â†’ Î³) (gci : galois_coinsertion fâ‚ fâ‚‚) (gi : galois_insertion gâ‚‚ gâ‚) (hf : âˆ€ (a : Î±), fâ‚ (fâ‚‚ a) = a âŠ“ K) (hg : âˆ€ (a : Î±), gâ‚ (gâ‚‚ a) = a âŠ” K) : well_founded gt
theorem bernstein_approximation.lt_of_mem_S {f : C(â†¥unit_interval, â„)} {Îµ : â„} {h : 0 < Îµ} {n : â„•} {x : â†¥unit_interval} {k : fin (n + 1)} (m : k âˆˆ bernstein_approximation.S f Îµ h n x) : |â‡‘f (bernstein.z k) - â‡‘f x| < Îµ / 2
theorem complex.has_strict_deriv_at_sin (x : â„‚) : has_strict_deriv_at complex.sin (complex.cos x) x
theorem complete_lattice.independent.pairwise_disjoint {Î± : Type u_1} {Î¹ : Type u_3} [complete_lattice Î±] {t : Î¹ â†’ Î±} (ht : complete_lattice.independent t) : pairwise (disjoint on t)
theorem ray_vector.coe_neg {M : Type u_2} [add_comm_group M] {R : Type u_1} (v : ray_vector R M) : â†‘-v = -â†‘v
theorem multilinear_map.map_smul_univ {R : Type u} {Î¹ : Type u'} {Mâ‚ : Î¹ â†’ Type vâ‚} {Mâ‚‚ : Type vâ‚‚} [decidable_eq Î¹] [comm_semiring R] [Î  (i : Î¹), add_comm_monoid (Mâ‚ i)] [add_comm_monoid Mâ‚‚] [Î  (i : Î¹), module R (Mâ‚ i)] [module R Mâ‚‚] (f : multilinear_map R Mâ‚ Mâ‚‚) [fintype Î¹] (c : Î¹ â†’ R) (m : Î  (i : Î¹), Mâ‚ i) : â‡‘f (Î» (i : Î¹), c i â€¢ m i) = finset.univ.prod (Î» (i : Î¹), c i) â€¢ â‡‘f m
theorem nat.multiplicity_eq_card_pow_dvd {m n b : â„•} (hm : m â‰  1) (hn : 0 < n) (hb : nat.log m n < b) : multiplicity m n = â†‘((finset.filter (Î» (i : â„•), m ^ i âˆ£ n) (finset.Ico 1 b)).card)
theorem submodule.is_internal_prime_power_torsion_of_is_torsion_by_ideal {R : Type u} [comm_ring R] [is_domain R] {M : Type v} [add_comm_group M] [module R M] [is_dedekind_domain R] {I : ideal R} (hI : I â‰  âŠ¥) (hM : module.is_torsion_by_set R M â†‘I) : âˆƒ (P : finset (ideal R)) [_inst_6 : decidable_eq â†¥P] [_inst_7 : âˆ€ (p : ideal R), p âˆˆ P â†’ prime p] (e : â†¥P â†’ â„•), direct_sum.is_internal (Î» (p : â†¥P), submodule.torsion_by_set R M â†‘(â†‘p ^ e p))
theorem continuous.integrable_of_has_compact_support {X : Type u_1} {E : Type u_3} [measurable_space X] [topological_space X] [normed_group E] {f : X â†’ E} {Î¼ : measure_theory.measure X} [opens_measurable_space X] [topological_space.metrizable_space X] [measure_theory.is_locally_finite_measure Î¼] (hf : continuous f) (hcf : has_compact_support f) : measure_theory.integrable f Î¼
theorem cardinal.exists_infinite_fiber {Î² Î± : Type u_1} (f : Î² â†’ Î±) (w : cardinal.mk Î± < cardinal.mk Î²) (w' : infinite Î±) : âˆƒ (a : Î±), infinite â†¥(f â»Â¹' {a})
theorem free_abelian_group.lift.ext {Î± : Type u} {Î² : Type v} [add_comm_group Î²] (g h : free_abelian_group Î± â†’+ Î²) (H : âˆ€ (x : Î±), â‡‘g (free_abelian_group.of x) = â‡‘h (free_abelian_group.of x)) : g = h
theorem basis.range_reindex' {Î¹ : Type u_1} {Î¹' : Type u_2} {R : Type u_3} {M : Type u_5} [semiring R] [add_comm_monoid M] [module R M] (b : basis Î¹ R M) (e : Î¹ â‰ƒ Î¹') : set.range (â‡‘b âˆ˜ â‡‘(e.symm)) = set.range â‡‘b
theorem generalized_continued_fraction.of_correctness_of_nth_stream_eq_none {K : Type u_1} [linear_ordered_field K] {v : K} {n : â„•} [floor_ring K] (nth_stream_eq_none : generalized_continued_fraction.int_fract_pair.stream v n = option.none) : v = (generalized_continued_fraction.of v).convergents (n - 1)
theorem continuous_multilinear_map.unit_le_op_norm {ğ•œ : Type u} {Î¹ : Type v} {E : Î¹ â†’ Type wE} {G : Type wG} [decidable_eq Î¹] [fintype Î¹] [nondiscrete_normed_field ğ•œ] [Î  (i : Î¹), normed_group (E i)] [Î  (i : Î¹), normed_space ğ•œ (E i)] [normed_group G] [normed_space ğ•œ G] (f : continuous_multilinear_map ğ•œ E G) (m : Î  (i : Î¹), E i) (h : âˆ¥mâˆ¥ â‰¤ 1) : âˆ¥â‡‘f mâˆ¥ â‰¤ âˆ¥fâˆ¥
theorem nonempty_measurable_superset {Î± : Type u_1} {m : measurable_space Î±} (s : set Î±) : nonempty {t // s âŠ† t âˆ§ measurable_set t}
theorem filter.coprod_cofinite {Î± : Type u_2} {Î² : Type u_3} : filter.cofinite.coprod filter.cofinite = filter.cofinite
theorem uniformity_has_basis_open_symmetric {Î± : Type u_1} [uniform_space Î±] : (uniformity Î±).has_basis (Î» (V : set (Î± Ã— Î±)), V âˆˆ uniformity Î± âˆ§ is_open V âˆ§ symmetric_rel V) id
theorem dvd_add_self_right {Î± : Type u} [ring Î±] {a b : Î±} : a âˆ£ b + a â†” a âˆ£ b
theorem strict_mono_on.Iic_union_Ici {Î± : Type u_1} {Î² : Type u_2} [linear_order Î±] [preorder Î²] {a : Î±} {f : Î± â†’ Î²} (hâ‚ : strict_mono_on f (set.Iic a)) (hâ‚‚ : strict_mono_on f (set.Ici a)) : strict_mono f
theorem equiv.perm.is_three_cycle.alternating_normal_closure {Î± : Type u_1} [fintype Î±] [decidable_eq Î±] (h5 : 5 â‰¤ fintype.card Î±) {f : equiv.perm Î±} (hf : f.is_three_cycle) : subgroup.normal_closure {âŸ¨f, _âŸ©} = âŠ¤
theorem add_monoid_hom.map_mclosure {M : Type u_1} {N : Type u_2} [add_zero_class M] [add_zero_class N] (f : M â†’+ N) (s : set M) : add_submonoid.map f (add_submonoid.closure s) = add_submonoid.closure (â‡‘f '' s)
theorem fractional_ideal.div_eq_mul_inv {A : Type u_2} {K : Type u_3} [comm_ring A] [field K] [is_domain A] [algebra A K] [is_fraction_ring A K] [is_dedekind_domain A] (I J : fractional_ideal (non_zero_divisors A) K) : I / J = I * Jâ»Â¹
theorem filter.tendsto.add_at_top {Î± : Type u} {Î² : Type v} [topological_space Î±] [linear_ordered_add_comm_group Î±] [order_topology Î±] {l : filter Î²} {f g : Î² â†’ Î±} {C : Î±} (hf : filter.tendsto f l (nhds C)) (hg : filter.tendsto g l filter.at_top) : filter.tendsto (Î» (x : Î²), f x + g x) l filter.at_top
theorem char.quadratic_char_sum_zero {F : Type u_1} [field F] [fintype F] [decidable_eq F] (hF : ring_char F â‰  2) : finset.univ.sum (Î» (a : F), char.quadratic_char F a) = 0
theorem ring_hom.map_one {Î± : Type u_2} {Î² : Type u_3} {rÎ± : non_assoc_semiring Î±} {rÎ² : non_assoc_semiring Î²} (f : Î± â†’+* Î²) : â‡‘f 1 = 1
theorem collinear_iff_dim_le_one (k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P) : collinear k s â†” module.rank k â†¥(vector_span k s) â‰¤ 1
theorem dense.inter_of_open_right {Î± : Type u} [topological_space Î±] {s t : set Î±} (hs : dense s) (ht : dense t) (hto : is_open t) : dense (s âˆ© t)
theorem multilinear_map.dom_coprod_dom_dom_congr_sum_congr {R : Type u_1} {Î¹â‚ : Type u_2} {Î¹â‚‚ : Type u_3} {Î¹â‚ƒ : Type u_4} {Î¹â‚„ : Type u_5} [comm_semiring R] [decidable_eq Î¹â‚] [decidable_eq Î¹â‚‚] [decidable_eq Î¹â‚ƒ] [decidable_eq Î¹â‚„] {Nâ‚ : Type u_6} [add_comm_monoid Nâ‚] [module R Nâ‚] {Nâ‚‚ : Type u_7} [add_comm_monoid Nâ‚‚] [module R Nâ‚‚] {N : Type u_8} [add_comm_monoid N] [module R N] (a : multilinear_map R (Î» (_x : Î¹â‚), N) Nâ‚) (b : multilinear_map R (Î» (_x : Î¹â‚‚), N) Nâ‚‚) (Ïƒa : Î¹â‚ â‰ƒ Î¹â‚ƒ) (Ïƒb : Î¹â‚‚ â‰ƒ Î¹â‚„) : multilinear_map.dom_dom_congr (Ïƒa.sum_congr Ïƒb) (a.dom_coprod b) = (multilinear_map.dom_dom_congr Ïƒa a).dom_coprod (multilinear_map.dom_dom_congr Ïƒb b)
theorem metric.mem_closure_iff_inf_dist_zero {Î± : Type u} [pseudo_metric_space Î±] {s : set Î±} {x : Î±} (h : s.nonempty) : x âˆˆ closure s â†” metric.inf_dist x s = 0
theorem left.add_nonpos {Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : a â‰¤ 0) (hb : b â‰¤ 0) : a + b â‰¤ 0
theorem is_fw_invariant.is_invariant {Ï„ : Type u_1} {Î± : Type u_2} [canonically_ordered_add_monoid Ï„] {Ï• : Ï„ â†’ Î± â†’ Î±} {s : set Î±} (h : is_fw_invariant Ï• s) : is_invariant Ï• s
theorem submonoid.closure_le {M : Type u_1} [mul_one_class M] {s : set M} {S : submonoid M} : submonoid.closure s â‰¤ S â†” s âŠ† â†‘S
theorem submonoid.localization_map.inv_unique {M : Type u_1} [comm_monoid M] {S : submonoid M} {N : Type u_2} [comm_monoid N] {f : M â†’* N} (h : âˆ€ (y : â†¥S), is_unit (â‡‘f â†‘y)) {y : â†¥S} {z : N} (H : â‡‘f â†‘y * z = 1) : â†‘(â‡‘(is_unit.lift_right (f.restrict S) h) y)â»Â¹ = z
theorem finset.order_emb_of_fin_last {Î± : Type u_1} [linear_order Î±] {s : finset Î±} {k : â„•} (h : s.card = k) (hz : 0 < k) : â‡‘(s.order_emb_of_fin h) âŸ¨k - 1, _âŸ© = s.max' _
theorem semiconj_by.units_inv_symm_left {M : Type u} [monoid M] {a : MË£} {x y : M} (h : semiconj_by â†‘a x y) : semiconj_by â†‘aâ»Â¹ y x
theorem algebraic_geometry.LocallyRingedSpace.Î“_Spec_left_triangle (X : algebraic_geometry.LocallyRingedSpace) : algebraic_geometry.to_Spec_Î“ (algebraic_geometry.LocallyRingedSpace.Î“.obj (opposite.op X)) â‰« X.to_Î“_Spec.val.c.app (opposite.op âŠ¤) = ğŸ™ (algebraic_geometry.LocallyRingedSpace.Î“.obj (opposite.op X))
theorem is_o_coe_const_pow_of_one_lt {R : Type u_1} [normed_ring R] {r : â„} (hr : 1 < r) : coe =o[filter.at_top] Î» (n : â„•), r ^ n
theorem measurable_measure_prod_mk_left {Î± : Type u_1} {Î² : Type u_3} [measurable_space Î±] [measurable_space Î²] {Î½ : measure_theory.measure Î²} [measure_theory.sigma_finite Î½] {s : set (Î± Ã— Î²)} (hs : measurable_set s) : measurable (Î» (x : Î±), â‡‘Î½ (prod.mk x â»Â¹' s))
theorem tendsto_of_tendsto_of_dist {Î± : Type u} [pseudo_metric_space Î±] {Î¹ : Type u_1} {fâ‚ fâ‚‚ : Î¹ â†’ Î±} {p : filter Î¹} {a : Î±} (hâ‚ : filter.tendsto fâ‚ p (nhds a)) (h : filter.tendsto (Î» (x : Î¹), has_dist.dist (fâ‚ x) (fâ‚‚ x)) p (nhds 0)) : filter.tendsto fâ‚‚ p (nhds a)
theorem function.cantor_surjective {Î± : Type u_1} (f : Î± â†’ set Î±) : Â¬function.surjective f
theorem cont_diff_at.cont_diff_bump {E : Type u_1} {X : Type u_2} [inner_product_space â„ E] [normed_group X] [normed_space â„ X] {n : with_top â„•} {c g : X â†’ E} {f : Î  (x : X), cont_diff_bump_of_inner (c x)} {x : X} (hc : cont_diff_at â„ n c x) (hr : cont_diff_at â„ n (Î» (x : X), (f x).r) x) (hR : cont_diff_at â„ n (Î» (x : X), (f x).R) x) (hg : cont_diff_at â„ n g x) : cont_diff_at â„ n (Î» (x : X), â‡‘(f x) (g x)) x
theorem exists_nat_pow_near_of_lt_one {Î± : Type u_1} [linear_ordered_field Î±] [archimedean Î±] {x y : Î±} (xpos : 0 < x) (hx : x â‰¤ 1) (ypos : 0 < y) (hy : y < 1) : âˆƒ (n : â„•), y ^ (n + 1) < x âˆ§ x â‰¤ y ^ n
theorem subring.list_prod_mem {R : Type u} [ring R] (s : subring R) {l : list R} : (âˆ€ (x : R), x âˆˆ l â†’ x âˆˆ s) â†’ l.prod âˆˆ s
theorem category_theory.grothendieck_topology.plus.is_sheaf_of_sep {C : Type u} [category_theory.category C] {J : category_theory.grothendieck_topology C} {D : Type w} [category_theory.category D] [category_theory.concrete_category D] [category_theory.limits.preserves_limits (category_theory.forget D)] [âˆ€ (X : C), category_theory.limits.has_colimits_of_shape (J.cover X)áµ’áµ– D] [âˆ€ (P : Cáµ’áµ– â¥¤ D) (X : C) (S : J.cover X), category_theory.limits.has_multiequalizer (S.index P)] [Î  (X : C), category_theory.limits.preserves_colimits_of_shape (J.cover X)áµ’áµ– (category_theory.forget D)] [category_theory.reflects_isomorphisms (category_theory.forget D)] (P : Cáµ’áµ– â¥¤ D) (hsep : âˆ€ (X : C) (S : J.cover X) (x y : â†¥(P.obj (opposite.op X))), (âˆ€ (I : S.arrow), â‡‘(P.map I.f.op) x = â‡‘(P.map I.f.op) y) â†’ x = y) : category_theory.presheaf.is_sheaf J (J.plus_obj P)
theorem finite_dimensional.proper_is_R_or_C (K : Type u_1) [is_R_or_C K] (E : Type u_2) [normed_group E] [normed_space K E] [finite_dimensional K E] : proper_space E
theorem measure_theory.tendsto_set_lintegral_zero {Î± : Type u_1} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {Î¹ : Type u_2} {f : Î± â†’ ennreal} (h : âˆ«â» (x : Î±), f x âˆ‚Î¼ â‰  âŠ¤) {l : filter Î¹} {s : Î¹ â†’ set Î±} (hl : filter.tendsto (â‡‘Î¼ âˆ˜ s) l (nhds 0)) : filter.tendsto (Î» (i : Î¹), âˆ«â» (x : Î±) in s i, f x âˆ‚Î¼) l (nhds 0)
theorem exists_Union_eq_closure_subset {Î¹ : Type u_1} {X : Type u_2} [topological_space X] [normal_space X] {u : Î¹ â†’ set X} (uo : âˆ€ (i : Î¹), is_open (u i)) (uf : âˆ€ (x : X), {i : Î¹ | x âˆˆ u i}.finite) (uU : (â‹ƒ (i : Î¹), u i) = set.univ) : âˆƒ (v : Î¹ â†’ set X), set.Union v = set.univ âˆ§ (âˆ€ (i : Î¹), is_open (v i)) âˆ§ âˆ€ (i : Î¹), closure (v i) âŠ† u i
theorem ring_hom.map_field_closure {K : Type u} {L : Type v} [field K] [field L] (f : K â†’+* L) (s : set K) : subfield.map f (subfield.closure s) = subfield.closure (â‡‘f '' s)
theorem emetric.diam_le {Î± : Type u} [pseudo_emetric_space Î±] {s : set Î±} {d : ennreal} (h : âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (y : Î±), y âˆˆ s â†’ has_edist.edist x y â‰¤ d) : emetric.diam s â‰¤ d
theorem orientation.oangle_map {V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) (x y : V) (f : V â‰ƒâ‚—áµ¢[â„] V) : (â‡‘(orientation.map (fin 2) f.to_linear_equiv) o).oangle x y = o.oangle (â‡‘(f.symm) x) (â‡‘(f.symm) y)
theorem measurable_space.cardinal_measurable_set_le_continuum {Î± : Type u} {s : set (set Î±)} : cardinal.mk â†¥s â‰¤ cardinal.continuum â†’ cardinal.mk â†¥{t : set Î± | measurable_set t} â‰¤ cardinal.continuum
theorem is_open.is_GÎ´ {Î± : Type u_1} [topological_space Î±] {s : set Î±} (h : is_open s) : is_GÎ´ s
theorem ring.direct_limit.of_injective {Î¹ : Type v} [preorder Î¹] {G : Î¹ â†’ Type w} [Î  (i : Î¹), comm_ring (G i)] (f' : Î  (i j : Î¹), i â‰¤ j â†’ G i â†’+* G j) [is_directed Î¹ has_le.le] [directed_system G (Î» (i j : Î¹) (h : i â‰¤ j), â‡‘(f' i j h))] (hf : âˆ€ (i j : Î¹) (hij : i â‰¤ j), function.injective â‡‘(f' i j hij)) (i : Î¹) : function.injective â‡‘(ring.direct_limit.of G (Î» (i j : Î¹) (h : i â‰¤ j), â‡‘(f' i j h)) i)
theorem is_primitive_root.norm_eq_one {n : â„•+} {K : Type u} {L : Type v} [field L] {Î¶ : L} (hÎ¶ : is_primitive_root Î¶ â†‘n) [field K] [algebra K L] [ne_zero â†‘â†‘n] [is_cyclotomic_extension {n} K L] (hn : n â‰  2) (hirr : irreducible (polynomial.cyclotomic â†‘n K)) : â‡‘(algebra.norm K) Î¶ = 1
theorem continuous_linear_map.op_norm_comp_le {ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {ğ•œâ‚ƒ : Type u_3} {E : Type u_4} {F : Type u_6} {G : Type u_8} [semi_normed_group E] [semi_normed_group F] [semi_normed_group G] [nondiscrete_normed_field ğ•œ] [nondiscrete_normed_field ğ•œâ‚‚] [nondiscrete_normed_field ğ•œâ‚ƒ] [normed_space ğ•œ E] [normed_space ğ•œâ‚‚ F] [normed_space ğ•œâ‚ƒ G] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} {Ïƒâ‚‚â‚ƒ : ğ•œâ‚‚ â†’+* ğ•œâ‚ƒ} {Ïƒâ‚â‚ƒ : ğ•œ â†’+* ğ•œâ‚ƒ} [ring_hom_comp_triple Ïƒâ‚â‚‚ Ïƒâ‚‚â‚ƒ Ïƒâ‚â‚ƒ] [ring_hom_isometric Ïƒâ‚â‚‚] [ring_hom_isometric Ïƒâ‚‚â‚ƒ] (h : F â†’SL[Ïƒâ‚‚â‚ƒ] G) (f : E â†’SL[Ïƒâ‚â‚‚] F) : âˆ¥h.comp fâˆ¥ â‰¤ âˆ¥hâˆ¥ * âˆ¥fâˆ¥
theorem measure_theory.measure_eq_div_smul {G : Type u_1} [measurable_space G] [group G] [has_measurable_mulâ‚‚ G] (Î¼ Î½ : measure_theory.measure G) [measure_theory.sigma_finite Î½] [measure_theory.sigma_finite Î¼] {E : set G} [has_measurable_inv G] [Î¼.is_mul_left_invariant] [Î½.is_mul_left_invariant] (hE : measurable_set E) (h2E : â‡‘Î½ E â‰  0) (h3E : â‡‘Î½ E â‰  âŠ¤) : Î¼ = (â‡‘Î¼ E / â‡‘Î½ E) â€¢ Î½
theorem summable_of_norm_bounded {Î¹ : Type u_1} {E : Type u_3} [semi_normed_group E] [complete_space E] {f : Î¹ â†’ E} (g : Î¹ â†’ â„) (hg : summable g) (h : âˆ€ (i : Î¹), âˆ¥f iâˆ¥ â‰¤ g i) : summable f
theorem affine_independent.mono {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s t : set P} (ha : affine_independent k (Î» (x : â†¥t), â†‘x)) (hs : s âŠ† t) : affine_independent k (Î» (x : â†¥s), â†‘x)
theorem Top.presheaf.presieve_of_covering.mem_grothendieck_topology {X : Top} {Î¹ : Type v} (U : Î¹ â†’ topological_space.opens â†¥X) : category_theory.sieve.generate (Top.presheaf.presieve_of_covering U) âˆˆ â‡‘(opens.grothendieck_topology â†¥X) (supr U)
theorem multilinear_map.mk_continuous_norm_le' {ğ•œ : Type u} {Î¹ : Type v} {E : Î¹ â†’ Type wE} {G : Type wG} [decidable_eq Î¹] [fintype Î¹] [nondiscrete_normed_field ğ•œ] [Î  (i : Î¹), normed_group (E i)] [Î  (i : Î¹), normed_space ğ•œ (E i)] [normed_group G] [normed_space ğ•œ G] (f : multilinear_map ğ•œ E G) {C : â„} (H : âˆ€ (m : Î  (i : Î¹), E i), âˆ¥â‡‘f mâˆ¥ â‰¤ C * finset.univ.prod (Î» (i : Î¹), âˆ¥m iâˆ¥)) : âˆ¥f.mk_continuous C Hâˆ¥ â‰¤ linear_order.max C 0
theorem list.exists_of_mem_map {Î± : Type u} {Î² : Type v} {f : Î± â†’ Î²} {b : Î²} {l : list Î±} : b âˆˆ list.map f l â†’ (âˆƒ (a : Î±), a âˆˆ l âˆ§ f a = b)
theorem complete_lattice.independent_iff_sup_indep_univ {Î± : Type u_1} {Î¹ : Type u_3} [complete_lattice Î±] [fintype Î¹] {f : Î¹ â†’ Î±} : complete_lattice.independent f â†” finset.univ.sup_indep f
theorem is_add_right_regular.add {R : Type u_1} {a b : R} [add_semigroup R] (rra : is_add_right_regular a) (rrb : is_add_right_regular b) : is_add_right_regular (a + b)
theorem set.image_image {Î± : Type u} {Î² : Type v} {Î³ : Type w} (g : Î² â†’ Î³) (f : Î± â†’ Î²) (s : set Î±) : g '' (f '' s) = (Î» (x : Î±), g (f x)) '' s
theorem lebesgue_number_of_compact_open {Î± : Type u_1} [uniform_space Î±] {K U : set Î±} (hK : is_compact K) (hU : is_open U) (hKU : K âŠ† U) : âˆƒ (V : set (Î± Ã— Î±)) (H : V âˆˆ uniformity Î±), is_open V âˆ§ âˆ€ (x : Î±), x âˆˆ K â†’ uniform_space.ball x V âŠ† U
theorem box_integral.box.exists_tagged_partition_is_Henstock_is_subordinate_homothetic {Î¹ : Type u_1} [fintype Î¹] (I : box_integral.box Î¹) (r : (Î¹ â†’ â„) â†’ â†¥(set.Ioi 0)) : âˆƒ (Ï€ : box_integral.tagged_prepartition I), Ï€.is_partition âˆ§ Ï€.is_Henstock âˆ§ Ï€.is_subordinate r âˆ§ (âˆ€ (J : box_integral.box Î¹), J âˆˆ Ï€ â†’ (âˆƒ (m : â„•), âˆ€ (i : Î¹), J.upper i - J.lower i = (I.upper i - I.lower i) / 2 ^ m)) âˆ§ Ï€.distortion = I.distortion
theorem disjoint.one_not_mem_div_set {Î± : Type u_2} [group Î±] {s t : set Î±} : disjoint s t â†’ 1 âˆ‰ s / t
theorem power_series.is_unit_constant_coeff {R : Type u_1} [semiring R] (Ï† : power_series R) (h : is_unit Ï†) : is_unit (â‡‘(power_series.constant_coeff R) Ï†)
theorem has_fpower_series_on_ball.continuous_on {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field ğ•œ] [normed_group E] [normed_space ğ•œ E] [normed_group F] [normed_space ğ•œ F] {f : E â†’ F} {p : formal_multilinear_series ğ•œ E F} {x : E} {r : ennreal} (hf : has_fpower_series_on_ball f p x r) : continuous_on f (emetric.ball x r)
theorem fin.succ_above_above {n : â„•} (p : fin (n + 1)) (i : fin n) (h : p â‰¤ â‡‘fin.cast_succ i) : â‡‘(p.succ_above) i = i.succ
theorem is_GÎ´_set_of_continuous_at {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [uniform_space Î²] [(uniformity Î²).is_countably_generated] (f : Î± â†’ Î²) : is_GÎ´ {x : Î± | continuous_at f x}
theorem mem_vector_span_iff_eq_weighted_vsub (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {Î¹ : Type u_4} {v : V} {p : Î¹ â†’ P} : v âˆˆ vector_span k (set.range p) â†” âˆƒ (s : finset Î¹) (w : Î¹ â†’ k) (h : s.sum (Î» (i : Î¹), w i) = 0), v = â‡‘(s.weighted_vsub p) w
theorem filter.tendsto.germ_tendsto {Î± : Type u_1} {Î² : Type u_2} {l : filter Î±} {f : Î± â†’ Î²} {lb : filter Î²} : filter.tendsto f l lb â†’ â†‘f.tendsto lb
theorem finset.eq_affine_combination_subset_iff_eq_affine_combination_subtype (k : Type u_1) (V : Type u_2) {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {Î¹ : Type u_4} {p0 : P} {s : set Î¹} {p : Î¹ â†’ P} : (âˆƒ (fs : finset Î¹) (hfs : â†‘fs âŠ† s) (w : Î¹ â†’ k) (hw : fs.sum (Î» (i : Î¹), w i) = 1), p0 = â‡‘(fs.affine_combination p) w) â†” âˆƒ (fs : finset â†¥s) (w : â†¥s â†’ k) (hw : fs.sum (Î» (i : â†¥s), w i) = 1), p0 = â‡‘(fs.affine_combination (Î» (i : â†¥s), p â†‘i)) w
theorem ennreal.add_le_cancellable_iff_ne {a : ennreal} : add_le_cancellable a â†” a â‰  âŠ¤
theorem polynomial.root_multiplicity_add {R : Type u} [comm_ring R] [is_domain R] {p q : polynomial R} (a : R) (hzero : p + q â‰  0) : linear_order.min (polynomial.root_multiplicity a p) (polynomial.root_multiplicity a q) â‰¤ polynomial.root_multiplicity a (p + q)
theorem dist_add_dist_eq_iff {E : Type u_2} [normed_group E] [normed_space â„ E] [strict_convex_space â„ E] {x y z : E} : has_dist.dist x y + has_dist.dist y z = has_dist.dist x z â†” y âˆˆ segment â„ x z
theorem mem_exposed_points_iff_exposed_singleton {ğ•œ : Type u_1} {E : Type u_2} [normed_linear_ordered_field ğ•œ] [normed_group E] [normed_space ğ•œ E] {A : set E} {x : E} : x âˆˆ set.exposed_points ğ•œ A â†” is_exposed ğ•œ A {x}
theorem matrix.pivot.exists_list_transvec_mul_mul_list_transvec_eq_diagonal_induction {ğ•œ : Type u_3} [field ğ•œ] {r : â„•} (IH : âˆ€ (M : matrix (fin r) (fin r) ğ•œ), âˆƒ (Lâ‚€ Lâ‚€' : list (matrix.transvection_struct (fin r) ğ•œ)) (Dâ‚€ : fin r â†’ ğ•œ), ((list.map matrix.transvection_struct.to_matrix Lâ‚€).prod.mul M).mul (list.map matrix.transvection_struct.to_matrix Lâ‚€').prod = matrix.diagonal Dâ‚€) (M : matrix (fin r âŠ• unit) (fin r âŠ• unit) ğ•œ) : âˆƒ (L L' : list (matrix.transvection_struct (fin r âŠ• unit) ğ•œ)) (D : fin r âŠ• unit â†’ ğ•œ), ((list.map matrix.transvection_struct.to_matrix L).prod.mul M).mul (list.map matrix.transvection_struct.to_matrix L').prod = matrix.diagonal D
theorem add_tsub_le_right {Î± : Type u_1} [preorder Î±] [has_add Î±] [has_sub Î±] [has_ordered_sub Î±] {a b : Î±} : a + b - b â‰¤ a
theorem differentiable.has_fpower_series_on_ball {E : Type u} [normed_group E] [normed_space â„‚ E] [complete_space E] {f : â„‚ â†’ E} (h : differentiable â„‚ f) (z : â„‚) {R : nnreal} (hR : 0 < R) : has_fpower_series_on_ball f (cauchy_power_series f z â†‘R) z âŠ¤
theorem filter.eventually_le.eventually_le_nhds {Î± : Type u} {Î² : Type v} [topological_space Î±] [has_le Î²] {f g : Î± â†’ Î²} {a : Î±} (h : f â‰¤á¶ [nhds a] g) : âˆ€á¶  (y : Î±) in nhds a, f â‰¤á¶ [nhds y] g
theorem metric.nonempty_compacts.dist_eq {Î± : Type u} [metric_space Î±] {x y : topological_space.nonempty_compacts Î±} : has_dist.dist x y = metric.Hausdorff_dist â†‘x â†‘y
theorem function.involutive.ite_not {Î± : Sort u} {f : Î± â†’ Î±} (h : function.involutive f) (P : Prop) [decidable P] (x : Î±) : f (ite P x (f x)) = ite (Â¬P) x (f x)
theorem measurable.strongly_measurable {Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} {mÎ± : measurable_space Î±} [measurable_space Î²] [topological_space Î²] [topological_space.pseudo_metrizable_space Î²] [topological_space.second_countable_topology Î²] [opens_measurable_space Î²] (hf : measurable f) : measure_theory.strongly_measurable f
theorem power_series.X_prime {R : Type u_1} [comm_ring R] [is_domain R] : prime power_series.X
theorem category_theory.has_limits_of_shape_of_has_limits_of_shape_creates_limits_of_shape {C : Type uâ‚} [category_theory.category C] {D : Type uâ‚‚} [category_theory.category D] {J : Type w} [category_theory.category J] (F : C â¥¤ D) [category_theory.limits.has_limits_of_shape J D] [category_theory.creates_limits_of_shape J F] : category_theory.limits.has_limits_of_shape J C
theorem cont_diff_snd {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {n : with_top â„•} : cont_diff ğ•œ n prod.snd
theorem reflection_eq_self_iff {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {K : submodule ğ•œ E} [complete_space â†¥K] (x : E) : â‡‘(reflection K) x = x â†” x âˆˆ K
theorem fin.add_nat_cast {n n' m : â„•} (i : fin n') (h : n' = n) : â‡‘(fin.add_nat m) (â‡‘(fin.cast h) i) = â‡‘(fin.cast _) (â‡‘(fin.add_nat m) i)
theorem exp_neg_inv_glue.nonneg (x : â„) : 0 â‰¤ exp_neg_inv_glue x
theorem tsub_lt_tsub_iff_left_of_le {Î± : Type u_1} [canonically_linear_ordered_add_monoid Î±] [has_sub Î±] [has_ordered_sub Î±] {a b c : Î±} [contravariant_class Î± Î± has_add.add has_le.le] (h : b â‰¤ a) : a - b < a - c â†” c < b
theorem is_localization.surjective_quotient_map_of_maximal_of_localization {R : Type u_1} [comm_ring R] (M : submonoid R) (S : Type u_2) [comm_ring S] [algebra R S] [is_localization M S] {I : ideal S} [I.is_prime] {J : ideal R} {H : J â‰¤ ideal.comap (algebra_map R S) I} (hI : (ideal.comap (algebra_map R S) I).is_maximal) : function.surjective â‡‘(I.quotient_map (algebra_map R S) H)
theorem category_theory.limits.has_colimits_op_of_has_limits {C : Type uâ‚} [category_theory.category C] [category_theory.limits.has_limits C] : category_theory.limits.has_colimits Cáµ’áµ–
theorem subsemigroup.dense_induction {M : Type u_1} [has_mul M] {p : M â†’ Prop} (x : M) {s : set M} (hs : subsemigroup.closure s = âŠ¤) (Hs : âˆ€ (x : M), x âˆˆ s â†’ p x) (Hmul : âˆ€ (x y : M), p x â†’ p y â†’ p (x * y)) : p x
theorem finsupp.prod_add_index_of_disjoint {Î± : Type u_1} {M : Type u_5} [add_comm_monoid M] {f1 f2 : Î± â†’â‚€ M} (hd : disjoint f1.support f2.support) {Î² : Type u_2} [comm_monoid Î²] (g : Î± â†’ M â†’ Î²) : (f1 + f2).prod g = f1.prod g * f2.prod g
theorem mvqpf.cofix.bisim_rel {n : â„•} {F : typevec (n + 1) â†’ Type u} [mvfunctor F] [q : mvqpf F] {Î± : typevec n} (r : mvqpf.cofix F Î± â†’ mvqpf.cofix F Î± â†’ Prop) (h : âˆ€ (x y : mvqpf.cofix F Î±), r x y â†’ mvfunctor.map (typevec.id ::: quot.mk r) x.dest = mvfunctor.map (typevec.id ::: quot.mk r) y.dest) (x y : mvqpf.cofix F Î±) : r x y â†’ x = y
theorem ideal.map_of_equiv {R : Type u} {S : Type v} [ring R] [ring S] (I : ideal R) (f : R â‰ƒ+* S) : ideal.map â†‘(f.symm) (ideal.map â†‘f I) = I
theorem prime_spectrum.punit (x : prime_spectrum punit) : false
theorem exists_prime_order_of_dvd_card {G : Type u_1} [group G] [fintype G] (p : â„•) [hp : fact (nat.prime p)] (hdvd : p âˆ£ fintype.card G) : âˆƒ (x : G), order_of x = p
theorem continuous_linear_map.antilipschitz_of_uniform_embedding {ğ•œ : Type u_1} {E : Type u_4} {Fâ‚— : Type u_7} [normed_group E] [normed_group Fâ‚—] [nondiscrete_normed_field ğ•œ] [normed_space ğ•œ E] [normed_space ğ•œ Fâ‚—] (f : E â†’L[ğ•œ] Fâ‚—) (hf : uniform_embedding â‡‘f) : âˆƒ (K : nnreal), antilipschitz_with K â‡‘f
theorem cardinal.mk_powerset {Î± : Type u} (s : set Î±) : cardinal.mk (â†¥ğ’«s) = 2 ^ cardinal.mk â†¥s
theorem linear_order.convex_on_of_lt {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [ordered_semiring ğ•œ] [add_comm_monoid E] [ordered_add_comm_monoid Î²] [module ğ•œ E] [module ğ•œ Î²] [linear_order E] {s : set E} {f : E â†’ Î²} (hs : convex ğ•œ s) (hf : âˆ€ â¦ƒx y : Eâ¦„, x âˆˆ s â†’ y âˆˆ s â†’ x < y â†’ âˆ€ â¦ƒa b : ğ•œâ¦„, 0 < a â†’ 0 < b â†’ a + b = 1 â†’ f (a â€¢ x + b â€¢ y) â‰¤ a â€¢ f x + b â€¢ f y) : convex_on ğ•œ s f
theorem simple_graph.even_card_odd_degree_vertices {V : Type u} (G : simple_graph V) [fintype V] [decidable_rel G.adj] : even (finset.filter (Î» (v : V), odd (G.degree v)) finset.univ).card
theorem local_homeomorph.continuous_at_iff_continuous_at_comp_right {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [topological_space Î±] [topological_space Î²] [topological_space Î³] (e : local_homeomorph Î± Î²) {f : Î² â†’ Î³} {x : Î²} (h : x âˆˆ e.to_local_equiv.target) : continuous_at f x â†” continuous_at (f âˆ˜ â‡‘e) (â‡‘(e.symm) x)
theorem id_eq_sum_orthogonal_projection_self_orthogonal_complement {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] (K : submodule ğ•œ E) [complete_space E] [complete_space â†¥K] : continuous_linear_map.id ğ•œ E = K.subtypeL.comp (orthogonal_projection K) + Ká—®.subtypeL.comp (orthogonal_projection Ká—®)
theorem finset.sum_range_induction {M : Type u_1} [add_comm_monoid M] (f s : â„• â†’ M) (h0 : s 0 = 0) (h : âˆ€ (n : â„•), s (n + 1) = s n + f n) (n : â„•) : (finset.range n).sum (Î» (k : â„•), f k) = s n
theorem finset.weighted_vsub_map {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {Î¹ : Type u_4} {Î¹â‚‚ : Type u_5} (sâ‚‚ : finset Î¹â‚‚) (e : Î¹â‚‚ â†ª Î¹) (w : Î¹ â†’ k) (p : Î¹ â†’ P) : â‡‘((finset.map e sâ‚‚).weighted_vsub p) w = â‡‘(sâ‚‚.weighted_vsub (p âˆ˜ â‡‘e)) (w âˆ˜ â‡‘e)
theorem circle_integrable_sub_zpow_iff {c w : â„‚} {R : â„} {n : â„¤} : circle_integrable (Î» (z : â„‚), (z - w) ^ n) c R â†” R = 0 âˆ¨ 0 â‰¤ n âˆ¨ w âˆ‰ metric.sphere c |R|
theorem covby.cast_int {a b : â„•} : a â‹– b â†’ â†‘a â‹– â†‘b
theorem Module.projective_of_free {R : Type u} [ring R] {M : Module R} {Î¹ : Type u_1} (b : basis Î¹ R â†¥M) : category_theory.projective M
theorem lt_sub_right_of_add_lt {Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b c : Î±} : a + b < c â†’ a < c - b
theorem function.is_fixed_pt.iterate {Î± : Type u} {f : Î± â†’ Î±} {x : Î±} (hf : function.is_fixed_pt f x) (n : â„•) : function.is_fixed_pt f^[n] x
theorem measure_theory.tsum_measure_preimage_singleton {Î± : Type u_1} {Î² : Type u_2} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {s : set Î²} (hs : s.countable) {f : Î± â†’ Î²} (hf : âˆ€ (y : Î²), y âˆˆ s â†’ measurable_set (f â»Â¹' {y})) : âˆ‘' (b : â†¥s), â‡‘Î¼ (f â»Â¹' {â†‘b}) = â‡‘Î¼ (f â»Â¹' s)
theorem cont_diff_on_succ_iff_deriv_of_open {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {fâ‚‚ : ğ•œ â†’ F} {sâ‚‚ : set ğ•œ} {n : â„•} (hs : is_open sâ‚‚) : cont_diff_on ğ•œ â†‘(n + 1) fâ‚‚ sâ‚‚ â†” differentiable_on ğ•œ fâ‚‚ sâ‚‚ âˆ§ cont_diff_on ğ•œ â†‘n (deriv fâ‚‚) sâ‚‚
theorem category_theory.reflects_epi {C : Type uâ‚} {D : Type uâ‚‚} [category_theory.category C] [category_theory.category D] (F : C â¥¤ D) {X Y : C} (f : X âŸ¶ Y) [category_theory.limits.reflects_colimit (category_theory.limits.span f f) F] [category_theory.epi (F.map f)] : category_theory.epi f
theorem cont_diff_on_top_iff_fderiv_of_open {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {s : set E} {f : E â†’ F} (hs : is_open s) : cont_diff_on ğ•œ âŠ¤ f s â†” differentiable_on ğ•œ f s âˆ§ cont_diff_on ğ•œ âŠ¤ (Î» (y : E), fderiv ğ•œ f y) s
theorem is_open.exists_lt_is_compact {Î± : Type u_1} [measurable_space Î±] [topological_space Î±] {Î¼ : measure_theory.measure Î±} [Î¼.regular] â¦ƒU : set Î±â¦„ (hU : is_open U) {r : ennreal} (hr : r < â‡‘Î¼ U) : âˆƒ (K : set Î±) (H : K âŠ† U), is_compact K âˆ§ r < â‡‘Î¼ K
theorem omega.nat.preterm.val_constant (v w : â„• â†’ â„•) (t : omega.nat.preterm) : (âˆ€ (x : â„•), x < t.fresh_index â†’ v x = w x) â†’ omega.nat.preterm.val v t = omega.nat.preterm.val w t
theorem dist_edist {Î± : Type u} [pseudo_metric_space Î±] (x y : Î±) : has_dist.dist x y = (has_edist.edist x y).to_real
theorem first_order.language.exists_elementary_substructure_card_eq (L : first_order.language) {M : Type w} [nonempty M] [L.Structure M] (s : set M) (Îº : cardinal) (h1 : cardinal.aleph_0 â‰¤ Îº) (h2 : (cardinal.mk â†¥s).lift â‰¤ Îº.lift) (h3 : L.card.lift â‰¤ Îº.lift) (h4 : Îº.lift â‰¤ (cardinal.mk M).lift) : âˆƒ (S : L.elementary_substructure M), s âŠ† â†‘S âˆ§ (cardinal.mk â†¥S).lift = Îº.lift
theorem ordinal.eq_enum_ord {S : set ordinal} (f : ordinal â†’ ordinal) (hS : set.unbounded has_lt.lt S) : strict_mono f âˆ§ set.range f = S â†” f = ordinal.enum_ord S
theorem omega.unsat_of_unsat_eq_elim (ee : list omega.ee) (c : omega.clause) : (omega.eq_elim ee c).unsat â†’ c.unsat
theorem measure_theory.integrable_condexp_L2_indicator {Î± : Type u_1} {E' : Type u_5} {ğ•œ : Type u_11} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E'] [complete_space E'] [normed_space â„ E'] {m m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {s : set Î±} (hm : m â‰¤ m0) [measure_theory.sigma_finite (Î¼.trim hm)] (hs : measurable_set s) (hÎ¼s : â‡‘Î¼ s â‰  âŠ¤) (x : E') : measure_theory.integrable â‡‘(â‡‘(measure_theory.condexp_L2 ğ•œ hm) (measure_theory.indicator_const_Lp 2 hs hÎ¼s x)) Î¼
theorem add_monoid_hom.range_top_of_surjective {G : Type u_1} [add_group G] {N : Type u_2} [add_group N] (f : G â†’+ N) (hf : function.surjective â‡‘f) : f.range = âŠ¤
theorem affine_subspace.coe_affine_span_singleton (k : Type u_1) (V : Type u_2) {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] (p : P) : â†‘(affine_span k {p}) = {p}
theorem composition.size_up_to_size_up_to_add {n : â„•} (a : composition n) (b : composition a.length) {i j : â„•} (hi : i < b.length) (hj : j < b.blocks_fun âŸ¨i, hiâŸ©) : a.size_up_to (b.size_up_to i + j) = (a.gather b).size_up_to i + (a.sigma_composition_aux b âŸ¨i, _âŸ©).size_up_to j
theorem path.trans_prod_eq_prod_trans {X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] {aâ‚ aâ‚‚ aâ‚ƒ : X} {bâ‚ bâ‚‚ bâ‚ƒ : Y} (Î³â‚ : path aâ‚ aâ‚‚) (Î´â‚ : path aâ‚‚ aâ‚ƒ) (Î³â‚‚ : path bâ‚ bâ‚‚) (Î´â‚‚ : path bâ‚‚ bâ‚ƒ) : (Î³â‚.prod Î³â‚‚).trans (Î´â‚.prod Î´â‚‚) = (Î³â‚.trans Î´â‚).prod (Î³â‚‚.trans Î´â‚‚)
theorem algebraic_geometry.RingedSpace.is_unit_of_is_unit_germ (X : algebraic_geometry.RingedSpace) (U : topological_space.opens â†¥X) (f : â†¥(X.to_PresheafedSpace.presheaf.obj (opposite.op U))) (h : âˆ€ (x : â†¥U), is_unit (â‡‘(X.to_PresheafedSpace.presheaf.germ x) f)) : is_unit f
theorem cont_mdiff_at.comp_cont_mdiff_within_at {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners ğ•œ E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] {f : M â†’ M'} {s : set M} {n : with_top â„•} {E'' : Type u_14} [normed_group E''] [normed_space ğ•œ E''] {H'' : Type u_15} [topological_space H''] {I'' : model_with_corners ğ•œ E'' H''} {M'' : Type u_16} [topological_space M''] [charted_space H'' M''] {g : M' â†’ M''} (x : M) (hg : cont_mdiff_at I' I'' n g (f x)) (hf : cont_mdiff_within_at I I' n f s x) : cont_mdiff_within_at I I'' n (g âˆ˜ f) s x
theorem is_regular_mul_and_mul_iff {R : Type u_1} {a b : R} [semigroup R] : is_regular (a * b) âˆ§ is_regular (b * a) â†” is_regular a âˆ§ is_regular b
theorem cauchy_seq_tendsto_of_is_complete {Î± : Type u} {Î² : Type v} [uniform_space Î±] [semilattice_sup Î²] {K : set Î±} (hâ‚ : is_complete K) {u : Î² â†’ Î±} (hâ‚‚ : âˆ€ (n : Î²), u n âˆˆ K) (hâ‚ƒ : cauchy_seq u) : âˆƒ (v : Î±) (H : v âˆˆ K), filter.tendsto u filter.at_top (nhds v)
theorem topological_space.is_topological_basis_of_open_of_nhds {Î± : Type u} [t : topological_space Î±] {s : set (set Î±)} (h_open : âˆ€ (u : set Î±), u âˆˆ s â†’ is_open u) (h_nhds : âˆ€ (a : Î±) (u : set Î±), a âˆˆ u â†’ is_open u â†’ (âˆƒ (v : set Î±) (H : v âˆˆ s), a âˆˆ v âˆ§ v âŠ† u)) : topological_space.is_topological_basis s
theorem is_primitive_root.minpoly_eq_pow_coprime {n : â„•} {K : Type u_8} [field K] {Î¼ : K} (h : is_primitive_root Î¼ n) [char_zero K] {m : â„•} (hcop : m.coprime n) : minpoly â„¤ Î¼ = minpoly â„¤ (Î¼ ^ m)
theorem padic_norm.padic_norm_of_prime_of_ne {p q : â„•} [p_prime : fact (nat.prime p)] [q_prime : fact (nat.prime q)] (neq : p â‰  q) : padic_norm p â†‘q = 1
theorem lt_mul_of_inv_mul_lt_left {Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a b c : Î±} : bâ»Â¹ * a < c â†’ a < b * c
theorem add_con.add_ker_mk_eq {M : Type u_1} [has_add M] (c : add_con M) : add_con.add_ker coe _ = c
theorem finprod_mem_Union {Î± : Type u_1} {Î¹ : Type u_3} {M : Type u_5} [comm_monoid M] {f : Î± â†’ M} [fintype Î¹] {t : Î¹ â†’ set Î±} (h : pairwise (disjoint on t)) (ht : âˆ€ (i : Î¹), (t i).finite) : finprod (Î» (a : Î±), finprod (Î» (H : a âˆˆ â‹ƒ (i : Î¹), t i), f a)) = finprod (Î» (i : Î¹), finprod (Î» (a : Î±), finprod (Î» (H : a âˆˆ t i), f a)))
theorem cont_diff.prod_map {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {n : with_top â„•} {E' : Type u_6} [normed_group E'] [normed_space ğ•œ E'] {F' : Type u_7} [normed_group F'] [normed_space ğ•œ F'] {f : E â†’ F} {g : E' â†’ F'} (hf : cont_diff ğ•œ n f) (hg : cont_diff ğ•œ n g) : cont_diff ğ•œ n (prod.map f g)
theorem category_theory.mem_ess_image_of_unit_split_mono {C : Type uâ‚} {D : Type uâ‚‚} [category_theory.category C] [category_theory.category D] {i : D â¥¤ C} [category_theory.reflective i] {A : C} [category_theory.split_mono ((category_theory.adjunction.of_right_adjoint i).unit.app A)] : A âˆˆ i.ess_image
theorem tendsto_comp_of_locally_uniform_limit_within {Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_4} [uniform_space Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : set Î±} {x : Î±} {p : filter Î¹} {g : Î¹ â†’ Î±} [topological_space Î±] (h : continuous_within_at f s x) (hg : filter.tendsto g p (nhds_within x s)) (hunif : âˆ€ (u : set (Î² Ã— Î²)), u âˆˆ uniformity Î² â†’ (âˆƒ (t : set Î±) (H : t âˆˆ nhds_within x s), âˆ€á¶  (n : Î¹) in p, âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F n y) âˆˆ u)) : filter.tendsto (Î» (n : Î¹), F n (g n)) p (nhds (f x))
theorem measure_theory.measure.count_apply_infinite {Î± : Type u_1} {s : set Î±} [measurable_space Î±] (hs : s.infinite) : â‡‘measure_theory.measure.count s = âŠ¤
theorem category_theory.presieve.extension_iff_amalgamation {C : Type uâ‚} [category_theory.category C] {X : C} {S : category_theory.sieve X} {P : Cáµ’áµ– â¥¤ Type vâ‚} (x : S.functor âŸ¶ P) (g : category_theory.yoneda.obj X âŸ¶ P) : S.functor_inclusion â‰« g = x â†” (â‡‘category_theory.presieve.nat_trans_equiv_compatible_family x).val.is_amalgamation (â‡‘category_theory.yoneda_equiv g)
theorem box_integral.prepartition.split_of_not_mem_Ioo {Î¹ : Type u_1} {I : box_integral.box Î¹} {i : Î¹} {x : â„} (h : x âˆ‰ set.Ioo (I.lower i) (I.upper i)) : box_integral.prepartition.split I i x = âŠ¤
theorem finprod_mem_mul_distrib' {Î± : Type u_1} {M : Type u_5} [comm_monoid M] {f g : Î± â†’ M} {s : set Î±} (hf : (s âˆ© function.mul_support f).finite) (hg : (s âˆ© function.mul_support g).finite) : finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), f i * g i)) = finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), f i)) * finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), g i))
theorem inv_int_cast_smul_comm {Î± : Type u_1} {E : Type u_2} (R : Type u_3) [add_comm_group E] [division_ring R] [monoid Î±] [module R E] [distrib_mul_action Î± E] (n : â„¤) (s : Î±) (x : E) : (â†‘n)â»Â¹ â€¢ s â€¢ x = s â€¢ (â†‘n)â»Â¹ â€¢ x
theorem cardinal.mk_univ_quaternion (R : Type u_1) [has_one R] [has_neg R] : cardinal.mk â†¥set.univ = cardinal.mk R ^ 4
theorem map_cSup_of_continuous_at_of_monotone {Î± : Type u} {Î² : Type v} [conditionally_complete_linear_order Î±] [topological_space Î±] [order_topology Î±] [conditionally_complete_linear_order Î²] [topological_space Î²] [order_topology Î²] {f : Î± â†’ Î²} {s : set Î±} (Cf : continuous_at f (has_Sup.Sup s)) (Mf : monotone f) (ne : s.nonempty) (H : bdd_above s) : f (has_Sup.Sup s) = has_Sup.Sup (f '' s)
theorem finset.min'_lt_max'_of_card {Î± : Type u_1} [linear_order Î±] (s : finset Î±) (hâ‚‚ : 1 < s.card) : s.min' _ < s.max' _
theorem is_totally_disconnected_of_clopen_set {X : Type u_1} [topological_space X] (hX : âˆ€ {x y : X}, x â‰  y â†’ (âˆƒ (U : set X) (h_clopen : is_clopen U), x âˆˆ U âˆ§ y âˆ‰ U)) : is_totally_disconnected set.univ
theorem homotopy.map_null_homotopic_map {Î¹ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape Î¹} {C D : homological_complex V c} {W : Type u_2} [category_theory.category W] [category_theory.preadditive W] (G : V â¥¤ W) [G.additive] (hom : Î  (i j : Î¹), C.X i âŸ¶ D.X j) : (G.map_homological_complex c).map (homotopy.null_homotopic_map hom) = homotopy.null_homotopic_map (Î» (i j : Î¹), G.map (hom i j))
theorem ext_nat'' {A : Type u_1} {F : Type u_2} [mul_zero_one_class A] [monoid_with_zero_hom_class F â„• A] (f g : F) (h_pos : âˆ€ {n : â„•}, 0 < n â†’ â‡‘f n = â‡‘g n) : f = g
theorem measure_theory.set_integral_condexp_L1_clm_of_measure_ne_top {Î± : Type u_1} {F' : Type u_7} [normed_group F'] [normed_space â„ F'] [complete_space F'] {m m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {hm : m â‰¤ m0} [measure_theory.sigma_finite (Î¼.trim hm)] {s : set Î±} (f : â†¥(measure_theory.Lp F' 1 Î¼)) (hs : measurable_set s) (hÎ¼s : â‡‘Î¼ s â‰  âŠ¤) : âˆ« (x : Î±) in s, â‡‘(â‡‘(measure_theory.condexp_L1_clm hm Î¼) f) x âˆ‚Î¼ = âˆ« (x : Î±) in s, â‡‘f x âˆ‚Î¼
theorem orientation.eq_iff_norm_eq_and_oangle_eq_zero {V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) (x y : V) : x = y â†” âˆ¥xâˆ¥ = âˆ¥yâˆ¥ âˆ§ o.oangle x y = 0
theorem fin.succ_above_lt_ge {n : â„•} (p : fin (n + 1)) (i : fin n) : â‡‘fin.cast_succ i < p âˆ¨ p â‰¤ â‡‘fin.cast_succ i
theorem fin.cast_succ_pos {n : â„•} {i : fin (n + 1)} (h : 0 < i) : 0 < â‡‘fin.cast_succ i
theorem inner_product_geometry.inner_eq_mul_norm_iff_angle_eq_zero {V : Type u_1} [inner_product_space â„ V] {x y : V} (hx : x â‰  0) (hy : y â‰  0) : has_inner.inner x y = âˆ¥xâˆ¥ * âˆ¥yâˆ¥ â†” inner_product_geometry.angle x y = 0
theorem normed_group_hom.equalizer.norm_lift_le {V : Type u_1} {W : Type u_2} {Vâ‚ : Type u_3} [semi_normed_group V] [semi_normed_group W] [semi_normed_group Vâ‚] {f g : normed_group_hom V W} (Ï† : normed_group_hom Vâ‚ V) (h : f.comp Ï† = g.comp Ï†) (C : â„) (hÏ† : âˆ¥Ï†âˆ¥ â‰¤ C) : âˆ¥normed_group_hom.equalizer.lift Ï† hâˆ¥ â‰¤ C
theorem prime.dvd_prod_iff {M : Type u_1} [comm_monoid_with_zero M] {p : M} {L : list M} (pp : prime p) : p âˆ£ L.prod â†” âˆƒ (a : M) (H : a âˆˆ L), p âˆ£ a
theorem continuous_linear_map.op_norm_zero {ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_normed_group E] [semi_normed_group F] [nondiscrete_normed_field ğ•œ] [nondiscrete_normed_field ğ•œâ‚‚] [normed_space ğ•œ E] [normed_space ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} [ring_hom_isometric Ïƒâ‚â‚‚] : âˆ¥0âˆ¥ = 0
theorem right.one_lt_mul_of_le_of_lt {Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_mul.mul) has_le.le] {a b : Î±} (ha : 1 â‰¤ a) (hb : 1 < b) : 1 < a * b
theorem algebraic_geometry.RingedSpace.is_unit_res_of_is_unit_germ (X : algebraic_geometry.RingedSpace) (U : topological_space.opens â†¥X) (f : â†¥(X.to_PresheafedSpace.presheaf.obj (opposite.op U))) (x : â†¥U) (h : is_unit (â‡‘(X.to_PresheafedSpace.presheaf.germ x) f)) : âˆƒ (V : topological_space.opens â†¥X) (i : V âŸ¶ U) (hxV : x.val âˆˆ V), is_unit (â‡‘(X.to_PresheafedSpace.presheaf.map i.op) f)
theorem category_theory.limits.has_colimit_of_equivalence_comp {J : Type uâ‚} [category_theory.category J] {K : Type uâ‚‚} [category_theory.category K] {C : Type u} [category_theory.category C] {F : J â¥¤ C} (e : K â‰Œ J) [category_theory.limits.has_colimit (e.functor â‹™ F)] : category_theory.limits.has_colimit F
theorem metric.Hausdorff_edist_ne_top_of_nonempty_of_bounded {Î± : Type u} [pseudo_metric_space Î±] {s t : set Î±} (hs : s.nonempty) (ht : t.nonempty) (bs : metric.bounded s) (bt : metric.bounded t) : emetric.Hausdorff_edist s t â‰  âŠ¤
theorem convex.image_sub_lt_mul_sub_of_deriv_lt {D : set â„} (hD : convex â„ D) {f : â„ â†’ â„} (hf : continuous_on f D) (hf' : differentiable_on â„ f (interior D)) {C : â„} (lt_hf' : âˆ€ (x : â„), x âˆˆ interior D â†’ deriv f x < C) (x : â„) (H : x âˆˆ D) (y : â„) (H_1 : y âˆˆ D) : x < y â†’ f y - f x < C * (y - x)
theorem is_seq_closed.mem_of_tendsto {X : Type u_1} [topological_space X] {s : set X} (hs : is_seq_closed s) {x : â„• â†’ X} (hmem : âˆ€ (n : â„•), x n âˆˆ s) {a : X} (ha : filter.tendsto x filter.at_top (nhds a)) : a âˆˆ s
theorem category_theory.functor.ess_image.of_iso {C : Type uâ‚} {D : Type uâ‚‚} [category_theory.category C] [category_theory.category D] {F : C â¥¤ D} {Y Y' : D} (h : Y â‰… Y') (hY : Y âˆˆ F.ess_image) : Y' âˆˆ F.ess_image
theorem interval_integral.tendsto_integral_filter_of_dominated_convergence {E : Type u_3} [normed_group E] [complete_space E] [normed_space â„ E] {a b : â„} {f : â„ â†’ E} {Î¼ : measure_theory.measure â„} {Î¹ : Type u_1} {l : filter Î¹} [l.is_countably_generated] {F : Î¹ â†’ â„ â†’ E} (bound : â„ â†’ â„) (hF_meas : âˆ€á¶  (n : Î¹) in l, measure_theory.ae_strongly_measurable (F n) (Î¼.restrict (set.interval_oc a b))) (h_bound : âˆ€á¶  (n : Î¹) in l, âˆ€áµ (x : â„) âˆ‚Î¼, x âˆˆ set.interval_oc a b â†’ âˆ¥F n xâˆ¥ â‰¤ bound x) (bound_integrable : interval_integrable bound Î¼ a b) (h_lim : âˆ€áµ (x : â„) âˆ‚Î¼, x âˆˆ set.interval_oc a b â†’ filter.tendsto (Î» (n : Î¹), F n x) l (nhds (f x))) : filter.tendsto (Î» (n : Î¹), âˆ« (x : â„) in a..b, F n x âˆ‚Î¼) l (nhds (âˆ« (x : â„) in a..b, f x âˆ‚Î¼))
theorem add_subsemigroup.dense_induction {M : Type u_1} [has_add M] {p : M â†’ Prop} (x : M) {s : set M} (hs : add_subsemigroup.closure s = âŠ¤) (Hs : âˆ€ (x : M), x âˆˆ s â†’ p x) (Hmul : âˆ€ (x y : M), p x â†’ p y â†’ p (x + y)) : p x
theorem measure_theory.exists_lt_lower_semicontinuous_integral_gt_nnreal {Î± : Type u_1} [topological_space Î±] [measurable_space Î±] [borel_space Î±] {Î¼ : measure_theory.measure Î±} [Î¼.weakly_regular] [measure_theory.sigma_finite Î¼] (f : Î± â†’ nnreal) (fint : measure_theory.integrable (Î» (x : Î±), â†‘(f x)) Î¼) {Îµ : â„} (Îµpos : 0 < Îµ) : âˆƒ (g : Î± â†’ ennreal), (âˆ€ (x : Î±), â†‘(f x) < g x) âˆ§ lower_semicontinuous g âˆ§ (âˆ€áµ (x : Î±) âˆ‚Î¼, g x < âŠ¤) âˆ§ measure_theory.integrable (Î» (x : Î±), (g x).to_real) Î¼ âˆ§ âˆ« (x : Î±), (g x).to_real âˆ‚Î¼ < âˆ« (x : Î±), â†‘(f x) âˆ‚Î¼ + Îµ
theorem monoid_hom.congr_fun {M : Type u_3} {N : Type u_4} [mul_one_class M] [mul_one_class N] {f g : M â†’* N} (h : f = g) (x : M) : â‡‘f x = â‡‘g x
theorem module.End.generalized_eigenvec_disjoint_range_ker {K : Type v} {V : Type w} [field K] [add_comm_group V] [module K V] [finite_dimensional K V] (f : module.End K V) (Î¼ : K) : disjoint (f.generalized_eigenrange Î¼ (finite_dimensional.finrank K V)) (â‡‘(f.generalized_eigenspace Î¼) (finite_dimensional.finrank K V))
theorem algebra.discr_of_matrix_mul_vec {A : Type u} {B : Type v} {Î¹ : Type w} [comm_ring A] [comm_ring B] [algebra A B] [fintype Î¹] [decidable_eq Î¹] (b : Î¹ â†’ B) (P : matrix Î¹ Î¹ A) : algebra.discr A ((P.map â‡‘(algebra_map A B)).mul_vec b) = P.det ^ 2 * algebra.discr A b
theorem function.update_apply {Î± : Sort u} [decidable_eq Î±] {Î² : Sort u_1} (f : Î± â†’ Î²) (a' : Î±) (b : Î²) (a : Î±) : function.update f a' b a = ite (a = a') b (f a)
theorem filter.eventually.small_sets {Î± : Type u_1} {l : filter Î±} {p : Î± â†’ Prop} : (âˆ€á¶  (x : Î±) in l, p x) â†’ (âˆ€á¶  (s : set Î±) in l.small_sets, âˆ€ (x : Î±), x âˆˆ s â†’ p x)
theorem fin.cast_succ_eq {n n' : â„•} (i : fin n) (h : n.succ = n'.succ) : â‡‘(fin.cast h) i.succ = (â‡‘(fin.cast _) i).succ
theorem cardinal.lift_sup_le_lift_sup {Î¹ : Type v} {Î¹' : Type v'} (f : Î¹ â†’ cardinal) (f' : Î¹' â†’ cardinal) (g : Î¹ â†’ Î¹') (h : âˆ€ (i : Î¹), (f i).lift â‰¤ (f' (g i)).lift) : (cardinal.sup f).lift â‰¤ (cardinal.sup f').lift
theorem finsupp.total_id_surjective (R : Type u_5) [semiring R] (M : Type u_1) [add_comm_monoid M] [module R M] : function.surjective â‡‘(finsupp.total M M R id)
theorem continuous_map.continuous_map_mem_subalgebra_closure_of_separates_points {X : Type u_1} [topological_space X] [compact_space X] (A : subalgebra â„ C(X, â„)) (w : A.separates_points) (f : C(X, â„)) : f âˆˆ A.topological_closure
theorem filter.tendsto.integral_sub_linear_is_o_ae {Î± : Type u_1} {E : Type u_3} [measurable_space Î±] {Î¹ : Type u_5} [normed_group E] [normed_space â„ E] [complete_space E] {Î¼ : measure_theory.measure Î±} {l : filter Î±} [l.is_measurably_generated] {f : Î± â†’ E} {b : E} (h : filter.tendsto f (l âŠ“ Î¼.ae) (nhds b)) (hfm : strongly_measurable_at_filter f l Î¼) (hÎ¼ : Î¼.finite_at_filter l) {s : Î¹ â†’ set Î±} {li : filter Î¹} (hs : filter.tendsto s li l.small_sets) (m : Î¹ â†’ â„ := Î» (i : Î¹), (â‡‘Î¼ (s i)).to_real) (hsÎ¼ : (Î» (i : Î¹), (â‡‘Î¼ (s i)).to_real) =á¶ [li] m . "refl") : (Î» (i : Î¹), âˆ« (x : Î±) in s i, f x âˆ‚Î¼ - m i â€¢ b) =o[li] m
theorem measure_theory.measure.measure_to_measurable_inter_of_sigma_finite {Î± : Type u_1} {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [measure_theory.sigma_finite Î¼] {s : set Î±} (hs : measurable_set s) (t : set Î±) : â‡‘Î¼ (measure_theory.to_measurable Î¼ t âˆ© s) = â‡‘Î¼ (t âˆ© s)
theorem simple_graph.sum_degrees_eq_twice_card_edges {V : Type u} (G : simple_graph V) [fintype V] [decidable_rel G.adj] [decidable_eq V] : finset.univ.sum (Î» (v : V), G.degree v) = 2 * G.edge_finset.card
theorem category_theory.equalizer.sieve.compatible_iff {C : Type uâ‚} [category_theory.category C] (P : Cáµ’áµ– â¥¤ Type (max vâ‚ uâ‚)) {X : C} (S : category_theory.sieve X) (x : category_theory.equalizer.first_obj P â‡‘S) : ((category_theory.equalizer.first_obj_eq_family P â‡‘S).hom x).compatible â†” category_theory.equalizer.sieve.first_map P S x = category_theory.equalizer.sieve.second_map P S x
theorem function_field.class_number_eq_one_iff (Fq F : Type) [field Fq] [fintype Fq] [field F] [algebra (polynomial Fq) F] [algebra (ratfunc Fq) F] [is_scalar_tower (polynomial Fq) (ratfunc Fq) F] [function_field Fq F] [is_separable (ratfunc Fq) F] : function_field.class_number Fq F = 1 â†” is_principal_ideal_ring â†¥(function_field.ring_of_integers Fq F)
theorem closure_Iio' {Î± : Type u} [topological_space Î±] [linear_order Î±] [order_topology Î±] [densely_ordered Î±] {a : Î±} (h : (set.Iio a).nonempty) : closure (set.Iio a) = set.Iic a
theorem affine_independent_iff_not_collinear (k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] (p : fin 3 â†’ P) : affine_independent k p â†” Â¬collinear k (set.range p)
theorem finite_field.even_card_iff_char_two {F : Type u_3} [field F] [fintype F] : ring_char F = 2 â†” fintype.card F % 2 = 0
theorem differentiable.apply_eq_apply_of_bounded {E : Type u} [normed_group E] [normed_space â„‚ E] {F : Type v} [normed_group F] [normed_space â„‚ F] {f : E â†’ F} (hf : differentiable â„‚ f) (hb : metric.bounded (set.range f)) (z w : E) : f z = f w
theorem category_theory.limits.equalizer.Î¹_of_eq {C : Type u} [category_theory.category C] {X Y : C} {f g : X âŸ¶ Y} [category_theory.limits.has_equalizer f g] (h : f = g) : category_theory.is_iso (category_theory.limits.equalizer.Î¹ f g)
theorem continuous_on.surj_on_interval {Î± : Type u} [conditionally_complete_linear_order Î±] [topological_space Î±] [order_topology Î±] [densely_ordered Î±] {Î´ : Type u_1} [linear_order Î´] [topological_space Î´] [order_closed_topology Î´] {s : set Î±} [hs : s.ord_connected] {f : Î± â†’ Î´} (hf : continuous_on f s) {a b : Î±} (ha : a âˆˆ s) (hb : b âˆˆ s) : set.surj_on f s (set.interval (f a) (f b))
theorem char.quadratic_char_neg_one_iff_not_is_square {F : Type u_1} [field F] [fintype F] [decidable_eq F] {a : F} : char.quadratic_char F a = -1 â†” Â¬is_square a
theorem mul_left_continuous {Î± : Type u_1} [topological_space Î±] [non_unital_non_assoc_ring Î±] [topological_ring Î±] (x : Î±) : continuous â‡‘(add_monoid_hom.mul_left x)
theorem decidable.em (p : Prop) [decidable p] : p âˆ¨ Â¬p
theorem formal_multilinear_series.norm_mul_pow_le_mul_pow_of_lt_radius {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field ğ•œ] [normed_group E] [normed_space ğ•œ E] [normed_group F] [normed_space ğ•œ F] (p : formal_multilinear_series ğ•œ E F) {r : nnreal} (h : â†‘r < p.radius) : âˆƒ (a : â„) (H : a âˆˆ set.Ioo 0 1) (C : â„) (H : C > 0), âˆ€ (n : â„•), âˆ¥p nâˆ¥ * â†‘r ^ n â‰¤ C * a ^ n
theorem category_theory.is_connected.of_induct {J : Type uâ‚} [category_theory.category J] [nonempty J] {jâ‚€ : J} (h : âˆ€ (p : set J), jâ‚€ âˆˆ p â†’ (âˆ€ {jâ‚ jâ‚‚ : J}, (jâ‚ âŸ¶ jâ‚‚) â†’ (jâ‚ âˆˆ p â†” jâ‚‚ âˆˆ p)) â†’ âˆ€ (j : J), j âˆˆ p) : category_theory.is_connected J
theorem add_submonoid.list_sum_mem {M : Type u_1} [add_monoid M] (s : add_submonoid M) {l : list M} (hl : âˆ€ (x : M), x âˆˆ l â†’ x âˆˆ s) : l.sum âˆˆ s
theorem pmf.to_measure_bind_apply {Î± : Type u_1} {Î² : Type u_2} (p : pmf Î±) (f : Î± â†’ pmf Î²) (s : set Î²) [measurable_space Î²] (hs : measurable_set s) : â‡‘((p.bind f).to_measure) s = âˆ‘' (a : Î±), â†‘(â‡‘p a) * â‡‘((f a).to_measure) s
theorem subgroup.one_mem {G : Type u_1} [group G] (H : subgroup G) : 1 âˆˆ H
theorem category_theory.is_cofiltered.of_equivalence {C : Type u} [category_theory.category C] [category_theory.is_cofiltered C] {D : Type uâ‚} [category_theory.category D] (h : C â‰Œ D) : category_theory.is_cofiltered D
theorem vector_span_eq_span_vsub_set_right_ne (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : set P} {p : P} (hp : p âˆˆ s) : vector_span k s = submodule.span k ((Î» (_x : P), _x -áµ¥ p) '' (s  {p}))
theorem inner_mul_inner_self_le {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] (x y : E) : is_R_or_C.abs (has_inner.inner x y) * is_R_or_C.abs (has_inner.inner y x) â‰¤ â‡‘is_R_or_C.re (has_inner.inner x x) * â‡‘is_R_or_C.re (has_inner.inner y y)
theorem nat.modeq.modeq_cancel_right_of_coprime {a b c m : â„•} (hmc : m.gcd c = 1) (h : a * c â‰¡ b * c [MOD m]) : a â‰¡ b [MOD m]
theorem submodule.span_induction {R : Type u_1} {M : Type u_4} [semiring R] [add_comm_monoid M] [module R M] {x : M} {s : set M} {p : M â†’ Prop} (h : x âˆˆ submodule.span R s) (Hs : âˆ€ (x : M), x âˆˆ s â†’ p x) (H0 : p 0) (H1 : âˆ€ (x y : M), p x â†’ p y â†’ p (x + y)) (H2 : âˆ€ (a : R) (x : M), p x â†’ p (a â€¢ x)) : p x
theorem exists_lt_of_cinfi_lt {Î± : Type u_1} {Î¹ : Sort u_3} [conditionally_complete_linear_order Î±] {a : Î±} [nonempty Î¹] {f : Î¹ â†’ Î±} (h : infi f < a) : âˆƒ (i : Î¹), f i < a
theorem continuous_linear_equiv.cont_diff_within_at_comp_iff {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {G : Type u_4} [normed_group G] [normed_space ğ•œ G] {s : set E} {f : E â†’ F} {x : E} {n : with_top â„•} (e : G â‰ƒL[ğ•œ] E) : cont_diff_within_at ğ•œ n (f âˆ˜ â‡‘e) (â‡‘e â»Â¹' s) (â‡‘(e.symm) x) â†” cont_diff_within_at ğ•œ n f s x
theorem mul_equiv.ext {M : Type u_6} {N : Type u_7} [has_mul M] [has_mul N] {f g : M â‰ƒ* N} (h : âˆ€ (x : M), â‡‘f x = â‡‘g x) : f = g
theorem category_theory.functor.final_of_adjunction {C : Type v} [category_theory.small_category C] {D : Type v} [category_theory.small_category D] {L : C â¥¤ D} {R : D â¥¤ C} (adj : L âŠ£ R) : R.final
theorem tendsto_exp_mul_div_rpow_at_top (s b : â„) (hb : 0 < b) : filter.tendsto (Î» (x : â„), real.exp (b * x) / x ^ s) filter.at_top filter.at_top
theorem polynomial.leading_coeff_prod' {R : Type u} {Î¹ : Type w} (s : finset Î¹) [comm_semiring R] (f : Î¹ â†’ polynomial R) (h : s.prod (Î» (i : Î¹), (f i).leading_coeff) â‰  0) : (s.prod (Î» (i : Î¹), f i)).leading_coeff = s.prod (Î» (i : Î¹), (f i).leading_coeff)
theorem Top.presheaf.covering_presieve_eq_self {X : Top} {Y : topological_space.opens â†¥X} (R : category_theory.presieve Y) : Top.presheaf.presieve_of_covering_aux (Top.presheaf.covering_of_presieve Y R) Y = R
theorem fintype.sum_bijective {Î± : Type u_1} {Î² : Type u_2} {M : Type u_3} [fintype Î±] [fintype Î²] [add_comm_monoid M] (e : Î± â†’ Î²) (he : function.bijective e) (f : Î± â†’ M) (g : Î² â†’ M) (h : âˆ€ (x : Î±), f x = g (e x)) : finset.univ.sum (Î» (x : Î±), f x) = finset.univ.sum (Î» (x : Î²), g x)
theorem cont_diff_within_at.continuous_linear_map_comp {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {G : Type u_4} [normed_group G] [normed_space ğ•œ G] {s : set E} {f : E â†’ F} {x : E} {n : with_top â„•} (g : F â†’L[ğ•œ] G) (hf : cont_diff_within_at ğ•œ n f s x) : cont_diff_within_at ğ•œ n (â‡‘g âˆ˜ f) s x
theorem intermediate_field.mem_fixing_subgroup_iff {K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (E : intermediate_field K L) (Ïƒ : L â‰ƒâ‚[K] L) : Ïƒ âˆˆ E.fixing_subgroup â†” âˆ€ (x : L), x âˆˆ E â†’ â‡‘Ïƒ x = x
theorem vadd_right_cancel {G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] {g1 g2 : G} (p : P) (h : g1 +áµ¥ p = g2 +áµ¥ p) : g1 = g2
theorem injective_of_increasing {Î± : Type u_1} {Î² : Type u_2} (r : Î± â†’ Î± â†’ Prop) (s : Î² â†’ Î² â†’ Prop) [is_trichotomous Î± r] [is_irrefl Î² s] (f : Î± â†’ Î²) (hf : âˆ€ {x y : Î±}, r x y â†’ s (f x) (f y)) : function.injective f
theorem measure_theory.measure.sub_apply {Î± : Type u_1} {m : measurable_space Î±} {Î¼ Î½ : measure_theory.measure Î±} {s : set Î±} [measure_theory.is_finite_measure Î½] (hâ‚ : measurable_set s) (hâ‚‚ : Î½ â‰¤ Î¼) : â‡‘(Î¼ - Î½) s = â‡‘Î¼ s - â‡‘Î½ s
theorem set.image2_congr' {Î± : Type u_1} {Î² : Type u_3} {Î³ : Type u_5} {f f' : Î± â†’ Î² â†’ Î³} {s : set Î±} {t : set Î²} (h : âˆ€ (a : Î±) (b : Î²), f a b = f' a b) : set.image2 f s t = set.image2 f' s t
theorem add_con.to_setoid_inj {M : Type u_1} [has_add M] {c d : add_con M} (H : c.to_setoid = d.to_setoid) : c = d
theorem category_theory.limits.kernel_subobject_comp_le {C : Type u} [category_theory.category C] {X Y : C} [category_theory.limits.has_zero_morphisms C] (f : X âŸ¶ Y) [category_theory.limits.has_kernel f] {Z : C} (h : Y âŸ¶ Z) [category_theory.limits.has_kernel (f â‰« h)] : category_theory.limits.kernel_subobject f â‰¤ category_theory.limits.kernel_subobject (f â‰« h)
theorem algebraic_geometry.polynomial.image_of_Df_eq_comap_C_compl_zero_locus {R : Type u_1} [comm_ring R] {f : polynomial R} : algebraic_geometry.polynomial.image_of_Df f = â‡‘(prime_spectrum.comap polynomial.C) '' (prime_spectrum.zero_locus {f})á¶œ
theorem measure_theory.tendsto_measure_Inter {Î± : Type u_1} {Î¹ : Type u_5} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [encodable Î¹] [semilattice_sup Î¹] {s : Î¹ â†’ set Î±} (hs : âˆ€ (n : Î¹), measurable_set (s n)) (hm : antitone s) (hf : âˆƒ (i : Î¹), â‡‘Î¼ (s i) â‰  âŠ¤) : filter.tendsto (â‡‘Î¼ âˆ˜ s) filter.at_top (nhds (â‡‘Î¼ (â‹‚ (n : Î¹), s n)))
theorem is_metric_separated.finite_Union_left {X : Type u_1} [emetric_space X] {Î¹ : Type u_2} {I : set Î¹} (hI : I.finite) {s : Î¹ â†’ set X} {t : set X} : (âˆ€ (i : Î¹), i âˆˆ I â†’ is_metric_separated (s i) t) â†’ is_metric_separated (â‹ƒ (i : Î¹) (H : i âˆˆ I), s i) t
theorem linear_map.mul_eq_one_comm {K : Type u} {V : Type v} [field K] [add_comm_group V] [module K V] [finite_dimensional K V] {f g : V â†’â‚—[K] V} : f * g = 1 â†” g * f = 1
theorem inner_product_geometry.angle_neg_self_of_nonzero {V : Type u_1} [inner_product_space â„ V] {x : V} (hx : x â‰  0) : inner_product_geometry.angle (-x) x = real.pi
theorem euclidean_geometry.dist_eq_iff_dist_orthogonal_projection_eq {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace â„ P} [nonempty â†¥s] [complete_space â†¥(s.direction)] {p1 p2 : P} (p3 : P) (hp1 : p1 âˆˆ s) (hp2 : p2 âˆˆ s) : has_dist.dist p1 p3 = has_dist.dist p2 p3 â†” has_dist.dist p1 â†‘(â‡‘(euclidean_geometry.orthogonal_projection s) p3) = has_dist.dist p2 â†‘(â‡‘(euclidean_geometry.orthogonal_projection s) p3)
theorem add_submonoid.sum_mem {M : Type u_1} [add_comm_monoid M] (S : add_submonoid M) {Î¹ : Type u_2} {t : finset Î¹} {f : Î¹ â†’ M} (h : âˆ€ (c : Î¹), c âˆˆ t â†’ f c âˆˆ S) : t.sum (Î» (c : Î¹), f c) âˆˆ S
theorem category_theory.constant_of_preserves_morphisms {J : Type uâ‚} [category_theory.category J] [category_theory.is_preconnected J] {Î± : Type uâ‚} (F : J â†’ Î±) (h : âˆ€ (jâ‚ jâ‚‚ : J), (jâ‚ âŸ¶ jâ‚‚) â†’ F jâ‚ = F jâ‚‚) (j j' : J) : F j = F j'
theorem formal_multilinear_series.change_origin_radius {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field ğ•œ] [normed_group E] [normed_space ğ•œ E] [normed_group F] [normed_space ğ•œ F] (p : formal_multilinear_series ğ•œ E F) {x : E} : p.radius - â†‘âˆ¥xâˆ¥â‚Š â‰¤ (p.change_origin x).radius
theorem is_prime_pow_iff_pow_succ {R : Type u_1} [comm_monoid_with_zero R] (n : R) : is_prime_pow n â†” âˆƒ (p : R) (k : â„•), prime p âˆ§ p ^ (k + 1) = n
theorem periodic_circle_map (c : â„‚) (R : â„) : function.periodic (circle_map c R) (2 * real.pi)
theorem edist_triangle_left {Î± : Type u} [pseudo_emetric_space Î±] (x y z : Î±) : has_edist.edist x y â‰¤ has_edist.edist z x + has_edist.edist z y
theorem euclidean_geometry.reflection_eq_iff_orthogonal_projection_eq {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] (sâ‚ sâ‚‚ : affine_subspace â„ P) [nonempty â†¥sâ‚] [nonempty â†¥sâ‚‚] [complete_space â†¥(sâ‚.direction)] [complete_space â†¥(sâ‚‚.direction)] (p : P) : â‡‘(euclidean_geometry.reflection sâ‚) p = â‡‘(euclidean_geometry.reflection sâ‚‚) p â†” â†‘(â‡‘(euclidean_geometry.orthogonal_projection sâ‚) p) = â†‘(â‡‘(euclidean_geometry.orthogonal_projection sâ‚‚) p)
theorem equiv.perm.prod_prod_extend_right {Î² : Type v} {Î± : Type u_1} [decidable_eq Î±] (Ïƒ : Î± â†’ equiv.perm Î²) {l : list Î±} (hl : l.nodup) (mem_l : âˆ€ (a : Î±), a âˆˆ l) : (list.map (Î» (a : Î±), equiv.perm.prod_extend_right a (Ïƒ a)) l).prod = equiv.prod_congr_right Ïƒ
theorem is_primitive_root.pow_sub_one_norm_two {K : Type u} {L : Type v} [field L] {Î¶ : L} [field K] [algebra K L] [ne_zero 2] {k : â„•} (hÎ¶ : is_primitive_root Î¶ (2 ^ (k + 1))) [is_cyclotomic_extension {2 ^ (k + 1)} K L] (hirr : irreducible (polynomial.cyclotomic (2 ^ (k + 1)) K)) : â‡‘(algebra.norm K) (Î¶ ^ 2 ^ k - 1) = (-2) ^ 2 ^ k
theorem measure_theory.integral_divergence_of_has_fderiv_within_at_off_countable {E : Type u} [normed_group E] [normed_space â„ E] [complete_space E] {n : â„•} (a b : fin (n + 1) â†’ â„) (hle : a â‰¤ b) (f : (fin (n + 1) â†’ â„) â†’ fin (n + 1) â†’ E) (f' : (fin (n + 1) â†’ â„) â†’ ((fin (n + 1) â†’ â„) â†’L[â„] fin (n + 1) â†’ E)) (s : set (fin (n + 1) â†’ â„)) (hs : s.countable) (Hc : continuous_on f (set.Icc a b)) (Hd : âˆ€ (x : fin (n + 1) â†’ â„), x âˆˆ set.univ.pi (Î» (i : fin (n + 1)), set.Ioo (a i) (b i))  s â†’ has_fderiv_at f (f' x) x) (Hi : measure_theory.integrable_on (Î» (x : fin (n + 1) â†’ â„), finset.univ.sum (Î» (i : fin (n + 1)), â‡‘(f' x) (pi.single i 1) i)) (set.Icc a b) measure_theory.measure_space.volume) : âˆ« (x : fin (n + 1) â†’ â„) in set.Icc a b, finset.univ.sum (Î» (i : fin (n + 1)), â‡‘(f' x) (pi.single i 1) i) = finset.univ.sum (Î» (i : fin (n + 1)), (âˆ« (x : fin n â†’ â„) in set.Icc (a âˆ˜ â‡‘(i.succ_above)) (b âˆ˜ â‡‘(i.succ_above)), f (i.insert_nth (b i) x) i) - âˆ« (x : fin n â†’ â„) in set.Icc (a âˆ˜ â‡‘(i.succ_above)) (b âˆ˜ â‡‘(i.succ_above)), f (i.insert_nth (a i) x) i)
theorem asymptotics.is_o_iff {Î± : Type u_1} {E : Type u_3} {F : Type u_4} [has_norm E] [has_norm F] {f : Î± â†’ E} {g : Î± â†’ F} {l : filter Î±} : f =o[l] g â†” âˆ€ â¦ƒc : â„â¦„, 0 < c â†’ (âˆ€á¶  (x : Î±) in l, âˆ¥f xâˆ¥ â‰¤ c * âˆ¥g xâˆ¥)
theorem left.add_lt_add {Î± : Type u_1} [has_add Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_lt.lt] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b c d : Î±} (hâ‚ : a < b) (hâ‚‚ : c < d) : a + c < b + d
theorem linear_recurrence.mk_sol_eq_init {Î± : Type u_1} [comm_semiring Î±] (E : linear_recurrence Î±) (init : fin E.order â†’ Î±) (n : fin E.order) : E.mk_sol init â†‘n = init n
theorem category_theory.presheaf.is_sheaf_iff_is_sheaf' {C : Type uâ‚} [category_theory.category C] {A : Type uâ‚‚} [category_theory.category A] (J : category_theory.grothendieck_topology C) (P : Cáµ’áµ– â¥¤ A) [category_theory.limits.has_products A] [category_theory.limits.has_pullbacks C] : category_theory.presheaf.is_sheaf J P â†” category_theory.presheaf.is_sheaf' J P
theorem euclidean_geometry.circumcenter_eq_of_cospherical_subset {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace â„ P} {ps : set P} (h : ps âŠ† â†‘s) [nonempty â†¥s] {n : â„•} [finite_dimensional â„ â†¥(s.direction)] (hd : finite_dimensional.finrank â„ â†¥(s.direction) = n) (hc : euclidean_geometry.cospherical ps) {sxâ‚ sxâ‚‚ : affine.simplex â„ P n} (hsxâ‚ : set.range sxâ‚.points âŠ† ps) (hsxâ‚‚ : set.range sxâ‚‚.points âŠ† ps) : sxâ‚.circumcenter = sxâ‚‚.circumcenter
theorem infi_option_elim {Î± : Type u_1} {Î² : Type u_2} [complete_lattice Î±] (a : Î±) (f : Î² â†’ Î±) : (â¨… (o : option Î²), option.elim a f o) = a âŠ“ â¨… (b : Î²), f b
theorem measure_theory.tendsto_in_measure_of_tendsto_Lp {Î± : Type u_1} {Î¹ : Type u_2} {E : Type u_3} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [normed_group E] {p : ennreal} [hp : fact (1 â‰¤ p)] {f : Î¹ â†’ â†¥(measure_theory.Lp E p Î¼)} {g : â†¥(measure_theory.Lp E p Î¼)} {l : filter Î¹} (hfg : filter.tendsto f l (nhds g)) : measure_theory.tendsto_in_measure Î¼ (Î» (n : Î¹), â‡‘(f n)) l â‡‘g
theorem add_equiv.apply_symm_apply {M : Type u_6} {N : Type u_7} [has_add M] [has_add N] (e : M â‰ƒ+ N) (y : N) : â‡‘e (â‡‘(e.symm) y) = y
theorem filter.low_scores {Î² : Type u_4} [linear_order Î²] [no_min_order Î²] {u : â„• â†’ Î²} (hu : filter.tendsto u filter.at_top filter.at_bot) (N : â„•) : âˆƒ (n : â„•) (H : n â‰¥ N), âˆ€ (k : â„•), k < n â†’ u n < u k
theorem finsupp.mul_prod_erase' {Î± : Type u_1} {M : Type u_5} {N : Type u_7} [has_zero M] [comm_monoid N] (f : Î± â†’â‚€ M) (y : Î±) (g : Î± â†’ M â†’ N) (hg : âˆ€ (i : Î±), g i 0 = 1) : g y (â‡‘f y) * (finsupp.erase y f).prod g = f.prod g
theorem vsub_left_cancel_iff {G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] {p1 p2 p : P} : p1 -áµ¥ p = p2 -áµ¥ p â†” p1 = p2
theorem mul_self_add_mul_self_eq_zero {Î± : Type u} [linear_ordered_ring Î±] {x y : Î±} : x * x + y * y = 0 â†” x = 0 âˆ§ y = 0
theorem right.add_neg' {Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±} (ha : a < 0) (hb : b < 0) : a + b < 0
theorem finset.card_le_one_of_subsingleton {Î± : Type u_1} [subsingleton Î±] (s : finset Î±) : s.card â‰¤ 1
theorem comap_uniformity_of_spaced_out {Î² : Type u_2} [uniform_space Î²] {Î± : Type u_1} {f : Î± â†’ Î²} {s : set (Î² Ã— Î²)} (hs : s âˆˆ uniformity Î²) (hf : pairwise (Î» (x y : Î±), (f x, f y) âˆ‰ s)) : filter.comap (prod.map f f) (uniformity Î²) = filter.principal id_rel
theorem category_theory.is_iso_of_hom_simple {C : Type u_1} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_kernels C] {X Y : C} [category_theory.simple X] [category_theory.simple Y] {f : X âŸ¶ Y} (w : f â‰  0) : category_theory.is_iso f
theorem is_p_group.card_modeq_card_fixed_points {p : â„•} {G : Type u_1} [group G] (hG : is_p_group p G) [hp : fact (nat.prime p)] (Î± : Type u_2) [mul_action G Î±] [fintype Î±] [fintype â†¥(mul_action.fixed_points G Î±)] : fintype.card Î± â‰¡ fintype.card â†¥(mul_action.fixed_points G Î±) [MOD p]
theorem category_theory.zero_not_simple (C : Type u) [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] [category_theory.simple 0] : false
theorem is_add_right_regular_of_add_eq_zero {R : Type u_1} {a b : R} [add_monoid R] (h : a + b = 0) : is_add_right_regular a
theorem is_add_group_hom.add {Î± : Type u_1} {Î² : Type u_2} [add_group Î±] [add_comm_group Î²] {f g : Î± â†’ Î²} (hf : is_add_group_hom f) (hg : is_add_group_hom g) : is_add_group_hom (Î» (a : Î±), f a + g a)
theorem is_torsion_free.not_torsion {G : Type u_1} [group G] [hN : nontrivial G] : monoid.is_torsion_free G â†’ Â¬monoid.is_torsion G
theorem dfinsupp.lsum_single {Î¹ : Type u_1} {R : Type u_2} (S : Type u_3) {M : Î¹ â†’ Type u_4} {N : Type u_5} [dec_Î¹ : decidable_eq Î¹] [semiring R] [Î  (i : Î¹), add_comm_monoid (M i)] [Î  (i : Î¹), module R (M i)] [add_comm_monoid N] [module R N] [semiring S] [module S N] [smul_comm_class R S N] (F : Î  (i : Î¹), M i â†’â‚—[R] N) (i : Î¹) (x : M i) : â‡‘(â‡‘(dfinsupp.lsum S) F) (dfinsupp.single i x) = â‡‘(F i) x
theorem generalized_continued_fraction.ext_iff {Î± : Type u_1} {g g' : generalized_continued_fraction Î±} : g = g' â†” g.h = g'.h âˆ§ g.s = g'.s
theorem has_deriv_at.lhopital_zero_nhds_right {a : â„} {l : filter â„} {f f' g g' : â„ â†’ â„} (hff' : âˆ€á¶  (x : â„) in nhds_within a (set.Ioi a), has_deriv_at f (f' x) x) (hgg' : âˆ€á¶  (x : â„) in nhds_within a (set.Ioi a), has_deriv_at g (g' x) x) (hg' : âˆ€á¶  (x : â„) in nhds_within a (set.Ioi a), g' x â‰  0) (hfa : filter.tendsto f (nhds_within a (set.Ioi a)) (nhds 0)) (hga : filter.tendsto g (nhds_within a (set.Ioi a)) (nhds 0)) (hdiv : filter.tendsto (Î» (x : â„), f' x / g' x) (nhds_within a (set.Ioi a)) l) : filter.tendsto (Î» (x : â„), f x / g x) (nhds_within a (set.Ioi a)) l
theorem tendsto_locally_uniformly.continuous {Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_4} [uniform_space Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : filter Î¹} [topological_space Î±] (h : tendsto_locally_uniformly F f p) (hc : âˆ€á¶  (n : Î¹) in p, continuous (F n)) [p.ne_bot] : continuous f
theorem linear_isometry_equiv.reflections_generate_dim {F : Type u_3} [inner_product_space â„ F] [finite_dimensional â„ F] (Ï† : F â‰ƒâ‚—áµ¢[â„] F) : âˆƒ (l : list F), l.length â‰¤ finite_dimensional.finrank â„ F âˆ§ Ï† = (list.map (Î» (v : F), reflection (submodule.span â„ {v})á—®) l).prod
theorem is_localization.exist_integer_multiples {R : Type u_1} [comm_ring R] (M : submonoid R) {S : Type u_2} [comm_ring S] [algebra R S] [is_localization M S] {Î¹ : Type u_3} (s : finset Î¹) (f : Î¹ â†’ S) : âˆƒ (b : â†¥M), âˆ€ (i : Î¹), i âˆˆ s â†’ is_localization.is_integer R (â†‘b â€¢ f i)
theorem formal_multilinear_series.id_apply_one (ğ•œ : Type u_1) (E : Type u_2) [nondiscrete_normed_field ğ•œ] [normed_group E] [normed_space ğ•œ E] (v : fin 1 â†’ E) : â‡‘(formal_multilinear_series.id ğ•œ E 1) v = v 0
theorem algebraic_geometry.PresheafedSpace.stalk_map.congr {C : Type u} [category_theory.category C] [category_theory.limits.has_colimits C] {X Y : algebraic_geometry.PresheafedSpace C} (Î± Î² : X âŸ¶ Y) (hâ‚ : Î± = Î²) (x x' : â†¥X) (hâ‚‚ : x = x') : algebraic_geometry.PresheafedSpace.stalk_map Î± x â‰« category_theory.eq_to_hom _ = category_theory.eq_to_hom _ â‰« algebraic_geometry.PresheafedSpace.stalk_map Î² x'
theorem strict_mono.add_monotone {Î± : Type u_1} {Î² : Type u_2} [has_add Î±] [preorder Î±] [preorder Î²] {f g : Î² â†’ Î±} [covariant_class Î± Î± has_add.add has_le.le] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] (hf : strict_mono f) (hg : monotone g) : strict_mono (Î» (x : Î²), f x + g x)
theorem Inf_eq_of_forall_ge_of_forall_gt_exists_lt {Î± : Type u_1} [complete_lattice Î±] {s : set Î±} {b : Î±} : (âˆ€ (a : Î±), a âˆˆ s â†’ b â‰¤ a) â†’ (âˆ€ (w : Î±), b < w â†’ (âˆƒ (a : Î±) (H : a âˆˆ s), a < w)) â†’ has_Inf.Inf s = b
theorem set.preimage_equiv_eq_image_symm {Î± : Type u_1} {Î² : Type u_2} (S : set Î±) (f : Î² â‰ƒ Î±) : â‡‘f â»Â¹' S = â‡‘(f.symm) '' S
theorem gauge_smul {E : Type u_1} [add_comm_group E] [module â„ E] {Î± : Type u_2} [linear_ordered_field Î±] [mul_action_with_zero Î± â„] [ordered_smul Î± â„] [module Î± E] [is_scalar_tower Î± â„ (set E)] {s : set E} (symmetric : âˆ€ (x : E), x âˆˆ s â†’ -x âˆˆ s) (r : Î±) (x : E) : gauge s (r â€¢ x) = |r| â€¢ gauge s x
theorem continuous_map.norm_le {Î± : Type u_1} {E : Type u_3} [topological_space Î±] [compact_space Î±] [normed_group E] (f : C(Î±, E)) {C : â„} (C0 : 0 â‰¤ C) : âˆ¥fâˆ¥ â‰¤ C â†” âˆ€ (x : Î±), âˆ¥â‡‘f xâˆ¥ â‰¤ C
theorem monotone.continuous_of_dense_range {Î± : Type u_1} {Î² : Type u_2} [linear_order Î±] [topological_space Î±] [order_topology Î±] [linear_order Î²] [topological_space Î²] [order_topology Î²] [densely_ordered Î²] {f : Î± â†’ Î²} (h_mono : monotone f) (h_dense : dense_range f) : continuous f
theorem metric.diam_mono {Î± : Type u} [pseudo_metric_space Î±] {s t : set Î±} (h : s âŠ† t) (ht : metric.bounded t) : metric.diam s â‰¤ metric.diam t
theorem add_con.Inf_to_setoid {M : Type u_1} [has_add M] (S : set (add_con M)) : (has_Inf.Inf S).to_setoid = has_Inf.Inf (add_con.to_setoid '' S)
theorem ennreal.mul_infi_of_ne {Î¹ : Sort u_1} {f : Î¹ â†’ ennreal} {x : ennreal} (h0 : x â‰  0) (h : x â‰  âŠ¤) : x * infi f = â¨… (i : Î¹), x * f i
theorem add_equiv.is_add_hom {M : Type u_1} {N : Type u_2} [add_zero_class M] [add_zero_class N] (h : M â‰ƒ+ N) : is_add_hom â‡‘h
theorem add_con.add {M : Type u_1} [has_add M] (c : add_con M) {w x y z : M} : â‡‘c w x â†’ â‡‘c y z â†’ â‡‘c (w + y) (x + z)
theorem topological_space.is_separable.separable_space {Î± : Type u} [pseudo_metric_space Î±] {s : set Î±} (hs : topological_space.is_separable s) : topological_space.separable_space â†¥s
theorem linear_independent_bounded_of_finset_linear_independent_bounded {R : Type u_3} {M : Type u_5} [semiring R] [add_comm_monoid M] [module R M] {n : â„•} (H : âˆ€ (s : finset M), linear_independent R (Î» (i : â†¥s), â†‘i) â†’ s.card â‰¤ n) (s : set M) : linear_independent R coe â†’ cardinal.mk â†¥s â‰¤ â†‘n
theorem subring.ext {R : Type u} [ring R] {S T : subring R} (h : âˆ€ (x : R), x âˆˆ S â†” x âˆˆ T) : S = T
theorem intermediate_field.add_mem {K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) {x y : L} : x âˆˆ S â†’ y âˆˆ S â†’ x + y âˆˆ S
theorem emetric.tendsto_locally_uniformly_on_iff {Î± : Type u} {Î² : Type v} [pseudo_emetric_space Î±] {Î¹ : Type u_1} [topological_space Î²] {F : Î¹ â†’ Î² â†’ Î±} {f : Î² â†’ Î±} {p : filter Î¹} {s : set Î²} : tendsto_locally_uniformly_on F f p s â†” âˆ€ (Îµ : ennreal), Îµ > 0 â†’ âˆ€ (x : Î²), x âˆˆ s â†’ (âˆƒ (t : set Î²) (H : t âˆˆ nhds_within x s), âˆ€á¶  (n : Î¹) in p, âˆ€ (y : Î²), y âˆˆ t â†’ has_edist.edist (f y) (F n y) < Îµ)
theorem category_theory.limits.initial_mono_class.of_is_initial {C : Type uâ‚} [category_theory.category C] {I : C} (hI : category_theory.limits.is_initial I) (h : âˆ€ (X : C), category_theory.mono (hI.to X)) : category_theory.limits.initial_mono_class C
theorem empty_wf {Î± : Sort u} : well_founded empty_relation
theorem filter.tendsto.inv {Î± : Type u} {G : Type w} [topological_space G] [has_inv G] [has_continuous_inv G] {f : Î± â†’ G} {l : filter Î±} {y : G} (h : filter.tendsto f l (nhds y)) : filter.tendsto (Î» (x : Î±), (f x)â»Â¹) l (nhds yâ»Â¹)
theorem filter.tendsto_of_subseq_tendsto {Î± : Type u_1} {Î¹ : Type u_2} {x : Î¹ â†’ Î±} {f : filter Î±} {l : filter Î¹} [l.is_countably_generated] (hxy : âˆ€ (ns : â„• â†’ Î¹), filter.tendsto ns filter.at_top l â†’ (âˆƒ (ms : â„• â†’ â„•), filter.tendsto (Î» (n : â„•), x (ns (ms n))) filter.at_top f)) : filter.tendsto x l f
theorem set.image_image2_distrib_left {Î± : Type u_1} {Î±' : Type u_2} {Î² : Type u_3} {Î³ : Type u_5} {Î´ : Type u_7} {f : Î± â†’ Î² â†’ Î³} {s : set Î±} {t : set Î²} {g : Î³ â†’ Î´} {f' : Î±' â†’ Î² â†’ Î´} {g' : Î± â†’ Î±'} (h_distrib : âˆ€ (a : Î±) (b : Î²), g (f a b) = f' (g' a) b) : g '' set.image2 f s t = set.image2 f' (g' '' s) t
theorem finsum_mem_add_distrib' {Î± : Type u_1} {M : Type u_5} [add_comm_monoid M] {f g : Î± â†’ M} {s : set Î±} (hf : (s âˆ© function.support f).finite) (hg : (s âˆ© function.support g).finite) : finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), f i + g i)) = finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), f i)) + finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), g i))
theorem matrix.pivot.mul_list_transvec_row_last_col {ğ•œ : Type u_3} [field ğ•œ] {r : â„•} (M : matrix (fin r âŠ• unit) (fin r âŠ• unit) ğ•œ) (i : fin r âŠ• unit) : M.mul (matrix.pivot.list_transvec_row M).prod i (sum.inr ()) = M i (sum.inr ())
theorem differentiable_at.conformal_at {E : Type u_1} [normed_group E] [normed_space â„‚ E] {z : â„‚} {f : â„‚ â†’ E} (h : differentiable_at â„‚ f z) (hf' : deriv f z â‰  0) : conformal_at f z
theorem module.is_torsion_by_iff_torsion_by_eq_top {R : Type u_1} {M : Type u_2} [comm_semiring R] [add_comm_monoid M] [module R M] (a : R) : module.is_torsion_by R M a â†” submodule.torsion_by R M a = âŠ¤
theorem basis.orientation_eq_iff_det_pos {R : Type u_1} [linear_ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {Î¹ : Type u_3} [decidable_eq Î¹] [fintype Î¹] (eâ‚ eâ‚‚ : basis Î¹ R M) : eâ‚.orientation = eâ‚‚.orientation â†” 0 < â‡‘(eâ‚.det) â‡‘eâ‚‚
theorem is_dedekind_domain.height_one_spectrum.valuation_exists_uniformizer {R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] (K : Type u_2) [field K] [algebra R K] [is_fraction_ring R K] (v : is_dedekind_domain.height_one_spectrum R) : âˆƒ (Ï€ : K), â‡‘(v.valuation) Ï€ = â†‘(â‡‘multiplicative.of_add (-1))
theorem list.nodup.of_attach {Î± : Type u} {l : list Î±} : l.attach.nodup â†’ l.nodup
theorem is_local_max_on.fderiv_within_eq_zero {E : Type u} [normed_group E] [normed_space â„ E] {f : E â†’ â„} {a : E} {s : set E} (h : is_local_max_on f s a) {y : E} (hy : y âˆˆ pos_tangent_cone_at s a) (hy' : -y âˆˆ pos_tangent_cone_at s a) : â‡‘(fderiv_within â„ f s a) y = 0
theorem mv_power_series.is_unit_constant_coeff {Ïƒ : Type u_1} {R : Type u_2} [semiring R] (Ï† : mv_power_series Ïƒ R) (h : is_unit Ï†) : is_unit (â‡‘(mv_power_series.constant_coeff Ïƒ R) Ï†)
theorem num_dvd_of_is_root {A : Type u_1} {K : Type u_2} [comm_ring A] [is_domain A] [unique_factorization_monoid A] [field K] [algebra A K] [is_fraction_ring A K] {p : polynomial A} {r : K} (hr : â‡‘(polynomial.aeval r) p = 0) : is_fraction_ring.num A r âˆ£ p.coeff 0
theorem probability_theory.lintegral_mul_eq_lintegral_mul_lintegral_of_indep_fun' {Î± : Type u_1} {mÎ± : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {f g : Î± â†’ ennreal} (h_meas_f : ae_measurable f Î¼) (h_meas_g : ae_measurable g Î¼) (h_indep_fun : probability_theory.indep_fun f g Î¼) : âˆ«â» (a : Î±), (f * g) a âˆ‚Î¼ = âˆ«â» (a : Î±), f a âˆ‚Î¼ * âˆ«â» (a : Î±), g a âˆ‚Î¼
theorem measure_theory.lintegral_mul_right_eq_self {G : Type u_4} [measurable_space G] {Î¼ : measure_theory.measure G} [group G] [has_measurable_mul G] [Î¼.is_mul_right_invariant] (f : G â†’ ennreal) (g : G) : âˆ«â» (x : G), f (x * g) âˆ‚Î¼ = âˆ«â» (x : G), f x âˆ‚Î¼
theorem is_integral_of_mem_of_fg {R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] (S : subalgebra R A) (HS : S.to_submodule.fg) (x : A) (hx : x âˆˆ S) : is_integral R x
theorem algebraic_geometry.structure_sheaf.comap_id_eq_map {R : Type u} [comm_ring R] (U V : topological_space.opens â†¥(algebraic_geometry.prime_spectrum.Top R)) (iVU : V âŸ¶ U) : algebraic_geometry.structure_sheaf.comap (ring_hom.id R) U V _ = (algebraic_geometry.Spec.structure_sheaf R).val.map iVU.op
theorem add_monoid.mem_closure_union_iff {M : Type u_1} [add_comm_monoid M] {s t : set M} {x : M} : x âˆˆ add_monoid.closure (s âˆª t) â†” âˆƒ (y : M) (H : y âˆˆ add_monoid.closure s) (z : M) (H : z âˆˆ add_monoid.closure t), y + z = x
theorem inner_product_geometry.norm_add_eq_norm_sub_iff_angle_eq_pi_div_two {V : Type u_1} [inner_product_space â„ V] (x y : V) : âˆ¥x + yâˆ¥ = âˆ¥x - yâˆ¥ â†” inner_product_geometry.angle x y = real.pi / 2
theorem metric.is_open_thickening {Î± : Type u} [pseudo_emetric_space Î±] {Î´ : â„} {E : set Î±} : is_open (metric.thickening Î´ E)
theorem antitone.map_bdd_above {Î± : Type u} {Î² : Type v} [preorder Î±] [preorder Î²] {f : Î± â†’ Î²} (hf : antitone f) {s : set Î±} : bdd_above s â†’ bdd_below (f '' s)
theorem pnat.xgcd_type.step_v (u : pnat.xgcd_type) (hr : u.r â‰  0) : u.step.v = u.v.swap
theorem subset_span_points (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P) : s âŠ† span_points k s
theorem order.lt_of_succ_lt_succ {Î± : Type u_1} [preorder Î±] [succ_order Î±] {a b : Î±} [no_max_order Î±] : order.succ a < order.succ b â†’ a < b
theorem uv.mem_of_mem_compression {Î± : Type u_1} [generalized_boolean_algebra Î±] [decidable_rel disjoint] [decidable_rel has_le.le] {s : finset Î±} {u v a : Î±} (ha : a âˆˆ uv.compression u v s) (hva : v â‰¤ a) (hvu : v = âŠ¥ â†’ u = âŠ¥) : a âˆˆ s
theorem phragmen_lindelof.eq_zero_on_quadrant_II {E : Type u_1} [normed_group E] [normed_space â„‚ E] {f : â„‚ â†’ E} (hd : diff_cont_on_cl â„‚ f (set.Iio 0 Ã—â„‚ set.Ioi 0)) (hB : âˆƒ (c : â„) (H : c < 2) (B : â„), f =O[filter.comap complex.abs filter.at_top âŠ“ filter.principal (set.Iio 0 Ã—â„‚ set.Ioi 0)] Î» (z : â„‚), real.exp (B * complex.abs z ^ c)) (hre : âˆ€ (x : â„), x â‰¤ 0 â†’ f â†‘x = 0) (him : âˆ€ (x : â„), 0 â‰¤ x â†’ f (â†‘x * complex.I) = 0) : set.eq_on f 0 {z : â„‚ | z.re â‰¤ 0 âˆ§ 0 â‰¤ z.im}
theorem monotone.tendsto_at_top_at_top {Î± : Type u_3} {Î² : Type u_4} [preorder Î±] [preorder Î²] {f : Î± â†’ Î²} (hf : monotone f) (h : âˆ€ (b : Î²), âˆƒ (a : Î±), b â‰¤ f a) : filter.tendsto f filter.at_top filter.at_top
theorem differentiable.mdifferentiable {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {E' : Type u_3} [normed_group E'] [normed_space ğ•œ E'] {f : E â†’ E'} : differentiable ğ•œ f â†’ mdifferentiable (model_with_corners_self ğ•œ E) (model_with_corners_self ğ•œ E') f
theorem sub_one_div_inv_le_two {Î± : Type u_1} [linear_ordered_field Î±] {a : Î±} (a2 : 2 â‰¤ a) : (1 - 1 / a)â»Â¹ â‰¤ 2
theorem lie_algebra.abelian_radical_iff_solvable_is_abelian (R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] [is_noetherian R L] : is_lie_abelian â†¥(lie_algebra.radical R L) â†” âˆ€ (I : lie_ideal R L), lie_algebra.is_solvable R â†¥I â†’ is_lie_abelian â†¥I
theorem category_theory.has_limits_of_reflective {C : Type uâ‚} [category_theory.category C] {D : Type uâ‚‚} [category_theory.category D] (R : D â¥¤ C) [category_theory.limits.has_limits_of_size C] [category_theory.reflective R] : category_theory.limits.has_limits_of_size D
theorem exists_dual_vector' (ğ•œ : Type v) [is_R_or_C ğ•œ] {E : Type u} [normed_group E] [normed_space ğ•œ E] [nontrivial E] (x : E) : âˆƒ (g : E â†’L[ğ•œ] ğ•œ), âˆ¥gâˆ¥ = 1 âˆ§ â‡‘g x = â†‘âˆ¥xâˆ¥
theorem is_smul_regular.smul {R : Type u_1} {S : Type u_2} {M : Type u_3} {a : R} {s : S} [has_scalar R M] [has_scalar R S] [has_scalar S M] [is_scalar_tower R S M] (ra : is_smul_regular M a) (rs : is_smul_regular M s) : is_smul_regular M (a â€¢ s)
theorem quotient_group.subgroup_eq_top_of_subsingleton {G : Type u} [group G] (H : subgroup G) (h : subsingleton (G â§¸ H)) : H = âŠ¤
theorem matrix.is_symm.from_blocks {Î± : Type u_1} {n : Type u_3} {m : Type u_4} {A : matrix m m Î±} {B : matrix m n Î±} {C : matrix n m Î±} {D : matrix n n Î±} (hA : A.is_symm) (hBC : B.transpose = C) (hD : D.is_symm) : (matrix.from_blocks A B C D).is_symm
theorem hindman.FP.mul {M : Type u_1} [semigroup M] {a : stream M} {m : M} (hm : m âˆˆ hindman.FP a) : âˆƒ (n : â„•), âˆ€ (m' : M), m' âˆˆ hindman.FP (stream.drop n a) â†’ m * m' âˆˆ hindman.FP a
theorem orthonormal.oangle_eq_iff_eq_pos_smul_rotation_of_ne_zero {V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) {x y : V} (hx : x â‰  0) (hy : y â‰  0) (Î¸ : real.angle) : hb.oangle x y = Î¸ â†” âˆƒ (r : â„), 0 < r âˆ§ y = r â€¢ â‡‘(hb.rotation Î¸) x
theorem convex.to_cone_is_least {ğ•œ : Type u_1} {E : Type u_2} [linear_ordered_field ğ•œ] [ordered_add_comm_group E] [module ğ•œ E] {s : set E} (hs : convex ğ•œ s) : is_least {t : convex_cone ğ•œ E | s âŠ† â†‘t} (convex.to_cone s hs)
theorem iterated_fderiv_within_apply_eq_iterated_deriv_within_mul_prod {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {F : Type u_2} [normed_group F] [normed_space ğ•œ F] {n : â„•} {f : ğ•œ â†’ F} {s : set ğ•œ} {x : ğ•œ} {m : fin n â†’ ğ•œ} : â‡‘(iterated_fderiv_within ğ•œ n f s x) m = finset.univ.prod (Î» (i : fin n), m i) â€¢ iterated_deriv_within n f s x
theorem clifford_algebra_complex.of_complex_conj (c : â„‚) : â‡‘clifford_algebra_complex.of_complex (â‡‘(star_ring_end â„‚) c) = â‡‘clifford_algebra.involute (â‡‘clifford_algebra_complex.of_complex c)
theorem orthonormal.exists_linear_isometry_equiv_eq {V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) (f : V â‰ƒâ‚—áµ¢[â„] V) : âˆƒ (Î¸ : real.angle), f = hb.rotation Î¸ âˆ¨ f = hb.conj_lie.trans (hb.rotation Î¸)
theorem measure_theory.tendsto_lintegral_of_dominated_convergence' {Î± : Type u_1} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {F : â„• â†’ Î± â†’ ennreal} {f : Î± â†’ ennreal} (bound : Î± â†’ ennreal) (hF_meas : âˆ€ (n : â„•), ae_measurable (F n) Î¼) (h_bound : âˆ€ (n : â„•), F n â‰¤áµ[Î¼] bound) (h_fin : âˆ«â» (a : Î±), bound a âˆ‚Î¼ â‰  âŠ¤) (h_lim : âˆ€áµ (a : Î±) âˆ‚Î¼, filter.tendsto (Î» (n : â„•), F n a) filter.at_top (nhds (f a))) : filter.tendsto (Î» (n : â„•), âˆ«â» (a : Î±), F n a âˆ‚Î¼) filter.at_top (nhds (âˆ«â» (a : Î±), f a âˆ‚Î¼))
theorem nnreal.geom_mean_le_arith_mean_weighted {Î¹ : Type u} (s : finset Î¹) (w z : Î¹ â†’ nnreal) (hw' : s.sum (Î» (i : Î¹), w i) = 1) : s.prod (Î» (i : Î¹), z i ^ â†‘(w i)) â‰¤ s.sum (Î» (i : Î¹), w i * z i)
theorem liouville.transcendental {x : â„} (lx : liouville x) : transcendental â„¤ x
theorem interval_integral.interval_integral_pos_of_pos {f : â„ â†’ â„} {a b : â„} (hfi : interval_integrable f measure_theory.measure_space.volume a b) (h : âˆ€ (x : â„), 0 < f x) (hab : a < b) : 0 < âˆ« (x : â„) in a..b, f x
theorem SemiNormedGroup.explicit_coker.map_desc {A B C D B' D' : SemiNormedGroup} {fab : A âŸ¶ B} {fbd : B âŸ¶ D} {fac : A âŸ¶ C} {fcd : C âŸ¶ D} {h : fab â‰« fbd = fac â‰« fcd} {fbb' : B âŸ¶ B'} {fdd' : D âŸ¶ D'} {condb : fab â‰« fbb' = 0} {condd : fcd â‰« fdd' = 0} {g : B' âŸ¶ D'} (h' : fbb' â‰« g = fbd â‰« fdd') : SemiNormedGroup.explicit_cokernel_desc condb â‰« g = SemiNormedGroup.explicit_cokernel.map h â‰« SemiNormedGroup.explicit_cokernel_desc condd
theorem polynomial.to_laurent_apply {R : Type u_1} [semiring R] (p : polynomial R) : â‡‘polynomial.to_laurent p = finsupp.map_domain coe p.to_finsupp
theorem has_ftaylor_series_up_to_on.exists_lipschitz_on_with {E : Type u_1} {F : Type u_2} [normed_group E] [normed_space â„ E] [normed_group F] [normed_space â„ F] {f : E â†’ F} {p : E â†’ formal_multilinear_series â„ E F} {s : set E} {x : E} (hf : has_ftaylor_series_up_to_on 1 f p (has_insert.insert x s)) (hs : convex â„ s) : âˆƒ (K : nnreal) (t : set E) (H : t âˆˆ nhds_within x s), lipschitz_on_with K f t
theorem mem_span_set {R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] {m : M} {s : set M} : m âˆˆ submodule.span R s â†” âˆƒ (c : M â†’â‚€ R), â†‘(c.support) âŠ† s âˆ§ c.sum (Î» (mi : M) (r : R), r â€¢ mi) = m
theorem induced_bot {X : Type u_1} {Y : Type u_2} {f : X â†’ Y} (hf : function.injective f) : topological_space.induced f âŠ¥ = âŠ¥
theorem subgroup.smul_invariant_measure {G : Type u_1} [group G] [measurable_space G] [topological_space G] [topological_group G] [borel_space G] {Î¼ : measure_theory.measure G} {Î“ : subgroup G} [Î¼.is_mul_right_invariant] : measure_theory.smul_invariant_measure â†¥(Î“.opposite) G Î¼
theorem ennreal.tendsto_tsum_compl_at_top_zero {Î± : Type u_1} {f : Î± â†’ ennreal} (hf : âˆ‘' (x : Î±), f x â‰  âŠ¤) : filter.tendsto (Î» (s : finset Î±), âˆ‘' (b : {x // x âˆ‰ s}), f â†‘b) filter.at_top (nhds 0)
theorem formal_multilinear_series.id_apply_ne_one (ğ•œ : Type u_1) (E : Type u_2) [nondiscrete_normed_field ğ•œ] [normed_group E] [normed_space ğ•œ E] {n : â„•} (h : n â‰  1) : formal_multilinear_series.id ğ•œ E n = 0
theorem bounded_continuous_function.lipschitz_comp {Î± : Type u} {Î² : Type v} {Î³ : Type w} [topological_space Î±] [pseudo_metric_space Î²] [pseudo_metric_space Î³] {G : Î² â†’ Î³} {C : nnreal} (H : lipschitz_with C G) : lipschitz_with C (bounded_continuous_function.comp G H)
theorem turing.list_blank.cons_head_tail {Î“ : Type u_1} [inhabited Î“] (l : turing.list_blank Î“) : turing.list_blank.cons l.head l.tail = l
theorem set.image_subset {Î± : Type u} {Î² : Type v} {a b : set Î±} (f : Î± â†’ Î²) (h : a âŠ† b) : f '' a âŠ† f '' b
theorem add_subgroup.le_normalizer_comap {G : Type u_1} [add_group G] {H : add_subgroup G} {N : Type u_3} [add_group N] (f : N â†’+ G) : add_subgroup.comap f H.normalizer â‰¤ (add_subgroup.comap f H).normalizer
theorem category_theory.limits.is_iso_Î¹_of_is_terminal {C : Type uâ‚} [category_theory.category C] {J : Type u} [category_theory.category J] {j : J} (I : category_theory.limits.is_terminal j) (F : J â¥¤ C) [category_theory.limits.has_colimit F] : category_theory.is_iso (category_theory.limits.colimit.Î¹ F j)
theorem dist_le_of_approx_trajectories_ODE_of_mem_set {E : Type u_1} [normed_group E] [normed_space â„ E] {v : â„ â†’ E â†’ E} {s : â„ â†’ set E} {K : â„} (hv : âˆ€ (t : â„) (x : E), x âˆˆ s t â†’ âˆ€ (y : E), y âˆˆ s t â†’ has_dist.dist (v t x) (v t y) â‰¤ K * has_dist.dist x y) {f g f' g' : â„ â†’ E} {a b Îµf Îµg Î´ : â„} (hf : continuous_on f (set.Icc a b)) (hf' : âˆ€ (t : â„), t âˆˆ set.Ico a b â†’ has_deriv_within_at f (f' t) (set.Ici t) t) (f_bound : âˆ€ (t : â„), t âˆˆ set.Ico a b â†’ has_dist.dist (f' t) (v t (f t)) â‰¤ Îµf) (hfs : âˆ€ (t : â„), t âˆˆ set.Ico a b â†’ f t âˆˆ s t) (hg : continuous_on g (set.Icc a b)) (hg' : âˆ€ (t : â„), t âˆˆ set.Ico a b â†’ has_deriv_within_at g (g' t) (set.Ici t) t) (g_bound : âˆ€ (t : â„), t âˆˆ set.Ico a b â†’ has_dist.dist (g' t) (v t (g t)) â‰¤ Îµg) (hgs : âˆ€ (t : â„), t âˆˆ set.Ico a b â†’ g t âˆˆ s t) (ha : has_dist.dist (f a) (g a) â‰¤ Î´) (t : â„) (H : t âˆˆ set.Icc a b) : has_dist.dist (f t) (g t) â‰¤ gronwall_bound Î´ K (Îµf + Îµg) (t - a)
theorem add_con.inf_iff_and {M : Type u_1} [has_add M] {c d : add_con M} {x y : M} : â‡‘(c âŠ“ d) x y â†” â‡‘c x y âˆ§ â‡‘d x y
theorem algebra.finite_presentation.equiv {R : Type u_1} {A : Type u_2} {B : Type u_3} [comm_ring R] [comm_ring A] [algebra R A] [comm_ring B] [algebra R B] (hfp : algebra.finite_presentation R A) (e : A â‰ƒâ‚[R] B) : algebra.finite_presentation R B
theorem free_product.neword.of_word {Î¹ : Type u_1} {M : Î¹ â†’ Type u_2} [Î  (i : Î¹), monoid (M i)] (w : free_product.word M) (h : w â‰  free_product.word.empty) : âˆƒ (i j : Î¹) (w' : free_product.neword M i j), w'.to_word = w
theorem category_theory.cosimplicial_object.Î´_comp_Ïƒ_of_le {C : Type u} [category_theory.category C] (X : category_theory.cosimplicial_object C) {n : â„•} {i : fin (n + 2)} {j : fin (n + 1)} (H : i â‰¤ â‡‘fin.cast_succ j) : X.Î´ (â‡‘fin.cast_succ i) â‰« X.Ïƒ j.succ = X.Ïƒ j â‰« X.Î´ i
theorem is_bounded_linear_map.cont_diff {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {f : E â†’ F} {n : with_top â„•} (hf : is_bounded_linear_map ğ•œ f) : cont_diff ğ•œ n f
theorem finset.exists_sum_fiber_lt_of_sum_fiber_nonneg_of_sum_lt_nsmul {Î± : Type u} {Î² : Type v} {M : Type w} [decidable_eq Î²] {s : finset Î±} {t : finset Î²} {f : Î± â†’ Î²} {w : Î± â†’ M} {b : M} [linear_ordered_cancel_add_comm_monoid M] (ht : âˆ€ (y : Î²), y âˆ‰ t â†’ 0 â‰¤ (finset.filter (Î» (x : Î±), f x = y) s).sum (Î» (x : Î±), w x)) (hb : s.sum (Î» (x : Î±), w x) < t.card â€¢ b) : âˆƒ (y : Î²) (H : y âˆˆ t), (finset.filter (Î» (x : Î±), f x = y) s).sum (Î» (x : Î±), w x) < b
theorem power_series.exp_pow_eq_rescale_exp {A : Type u_1} [comm_ring A] [algebra â„š A] (k : â„•) : power_series.exp A ^ k = â‡‘(power_series.rescale â†‘k) (power_series.exp A)
theorem has_strict_fderiv_at.of_local_left_inverse {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {f : E â†’ F} {f' : E â‰ƒL[ğ•œ] F} {g : F â†’ E} {a : F} (hg : continuous_at g a) (hf : has_strict_fderiv_at f â†‘f' (g a)) (hfg : âˆ€á¶  (y : F) in nhds a, f (g y) = y) : has_strict_fderiv_at g â†‘(f'.symm) a
theorem monoid_algebra.support_gen_of_gen {R : Type u_1} {M : Type u_2} [comm_semiring R] [monoid M] {S : set (monoid_algebra R M)} (hS : algebra.adjoin R S = âŠ¤) : algebra.adjoin R (â‹ƒ (f : monoid_algebra R M) (H : f âˆˆ S), â‡‘(monoid_algebra.of R M) '' â†‘(f.support)) = âŠ¤
theorem Gromov_Hausdorff.GH_dist_eq_Hausdorff_dist (X : Type u) [metric_space X] [compact_space X] [nonempty X] (Y : Type v) [metric_space Y] [compact_space Y] [nonempty Y] : âˆƒ (Î¦ : X â†’ â†¥(lp (Î» (n : â„•), â„) âŠ¤)) (Î¨ : Y â†’ â†¥(lp (Î» (n : â„•), â„) âŠ¤)), isometry Î¦ âˆ§ isometry Î¨ âˆ§ Gromov_Hausdorff.GH_dist X Y = metric.Hausdorff_dist (set.range Î¦) (set.range Î¨)
theorem finite_dimensional.of_surjective {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {Vâ‚‚ : Type v'} [add_comm_group Vâ‚‚] [module K Vâ‚‚] (f : V â†’â‚—[K] Vâ‚‚) (w : function.surjective â‡‘f) [finite_dimensional K V] : finite_dimensional K Vâ‚‚
theorem second_derivative_symmetric {E : Type u_1} {F : Type u_2} [normed_group E] [normed_space â„ E] [normed_group F] [normed_space â„ F] {x : E} {f : E â†’ F} {f' : E â†’ (E â†’L[â„] F)} {f'' : E â†’L[â„] E â†’L[â„] F} (hf : âˆ€ (y : E), has_fderiv_at f (f' y) y) (hx : has_fderiv_at f' f'' x) (v w : E) : â‡‘(â‡‘f'' v) w = â‡‘(â‡‘f'' w) v
theorem setoid.sup_eq_eqv_gen {Î± : Type u_1} (r s : setoid Î±) : r âŠ” s = eqv_gen.setoid (Î» (x y : Î±), r.rel x y âˆ¨ s.rel x y)
theorem infi_eq_infi_finset' {Î± : Type u_1} {Î¹' : Sort u_5} [complete_lattice Î±] (s : Î¹' â†’ Î±) : (â¨… (i : Î¹'), s i) = â¨… (t : finset (plift Î¹')) (i : plift Î¹') (H : i âˆˆ t), s i.down
theorem orthonormal.exists_linear_isometry_equiv_eq_of_det_neg {V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) {f : V â‰ƒâ‚—áµ¢[â„] V} (hd : â‡‘linear_map.det â†‘(f.to_linear_equiv) < 0) : âˆƒ (Î¸ : real.angle), f = hb.conj_lie.trans (hb.rotation Î¸)
theorem category_theory.normal_mono_category.has_limit_parallel_pair {C : Type u_1} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_finite_products C] [category_theory.limits.has_kernels C] [category_theory.normal_mono_category C] {X Y : C} (f g : X âŸ¶ Y) : category_theory.limits.has_limit (category_theory.limits.parallel_pair f g)
theorem finsupp.prod_add_index' {Î± : Type u_1} {M : Type u_5} {N : Type u_7} [add_zero_class M] [comm_monoid N] {f g : Î± â†’â‚€ M} {h : Î± â†’ M â†’ N} (h_zero : âˆ€ (a : Î±), h a 0 = 1) (h_add : âˆ€ (a : Î±) (bâ‚ bâ‚‚ : M), h a (bâ‚ + bâ‚‚) = h a bâ‚ * h a bâ‚‚) : (f + g).prod h = f.prod h * g.prod h
theorem is_metric_separated.finset_Union_left {X : Type u_1} [emetric_space X] {Î¹ : Type u_2} {I : finset Î¹} {s : Î¹ â†’ set X} {t : set X} : (âˆ€ (i : Î¹), i âˆˆ I â†’ is_metric_separated (s i) t) â†’ is_metric_separated (â‹ƒ (i : Î¹) (H : i âˆˆ I), s i) t
theorem linear_map.eq_on_span' {R : Type u_1} {Râ‚‚ : Type u_2} {M : Type u_4} {Mâ‚‚ : Type u_5} [semiring R] [add_comm_monoid M] [module R M] [semiring Râ‚‚] [add_comm_monoid Mâ‚‚] [module Râ‚‚ Mâ‚‚] {Ïƒâ‚â‚‚ : R â†’+* Râ‚‚} {s : set M} {f g : M â†’â‚›â‚—[Ïƒâ‚â‚‚] Mâ‚‚} (H : set.eq_on â‡‘f â‡‘g s) : set.eq_on â‡‘f â‡‘g â†‘(submodule.span R s)
theorem vsub_left_cancel {G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] {p1 p2 p : P} (h : p1 -áµ¥ p = p2 -áµ¥ p) : p1 = p2
theorem linear_recurrence.eq_mk_of_is_sol_of_eq_init' {Î± : Type u_1} [comm_semiring Î±] (E : linear_recurrence Î±) {u : â„• â†’ Î±} {init : fin E.order â†’ Î±} (h : E.is_solution u) (heq : âˆ€ (n : fin E.order), u â†‘n = init n) : u = E.mk_sol init
theorem euclidean_geometry.dist_eq_add_dist_of_angle_eq_pi {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {p1 p2 p3 : P} (h : euclidean_geometry.angle p1 p2 p3 = real.pi) : has_dist.dist p1 p3 = has_dist.dist p1 p2 + has_dist.dist p3 p2
theorem mdifferentiable_within_at_iff_differentiable_within_at {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {E' : Type u_3} [normed_group E'] [normed_space ğ•œ E'] {f : E â†’ E'} {s : set E} {x : E} : mdifferentiable_within_at (model_with_corners_self ğ•œ E) (model_with_corners_self ğ•œ E') f s x â†” differentiable_within_at ğ•œ f s x
theorem measure_theory.simple_func.map_integral {Î± : Type u_1} {E : Type u_2} {F : Type u_3} [normed_group E] [normed_group F] [normed_space â„ F] {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (f : measure_theory.simple_func Î± E) (g : E â†’ F) (hf : measure_theory.integrable â‡‘f Î¼) (hg : g 0 = 0) : measure_theory.simple_func.integral Î¼ (measure_theory.simple_func.map g f) = f.range.sum (Î» (x : E), (â‡‘Î¼ (â‡‘f â»Â¹' {x})).to_real â€¢ g x)
theorem mul_opposite.op_pow {M : Type u} [monoid M] (x : M) (n : â„•) : mul_opposite.op (x ^ n) = mul_opposite.op x ^ n
theorem exists_ne_zero_of_finsum_mem_ne_zero {Î± : Type u_1} {M : Type u_5} [add_comm_monoid M] {f : Î± â†’ M} {s : set Î±} (h : finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), f i)) â‰  0) : âˆƒ (x : Î±) (H : x âˆˆ s), f x â‰  0
theorem measure_theory.simple_func.exists_le_lower_semicontinuous_lintegral_ge {Î± : Type u_1} [topological_space Î±] [measurable_space Î±] [borel_space Î±] (Î¼ : measure_theory.measure Î±) [Î¼.weakly_regular] (f : measure_theory.simple_func Î± nnreal) {Îµ : ennreal} (Îµ0 : Îµ â‰  0) : âˆƒ (g : Î± â†’ nnreal), (âˆ€ (x : Î±), â‡‘f x â‰¤ g x) âˆ§ lower_semicontinuous g âˆ§ âˆ«â» (x : Î±), â†‘(g x) âˆ‚Î¼ â‰¤ âˆ«â» (x : Î±), â†‘(â‡‘f x) âˆ‚Î¼ + Îµ
theorem ordinal.opow_le_iff_le_log {b x c : ordinal} (b1 : 1 < b) (x0 : 0 < x) : b ^ c â‰¤ x â†” c â‰¤ ordinal.log b x
theorem nilpotent_iff_finite_descending_central_series (G : Type u_1) [group G] : group.is_nilpotent G â†” âˆƒ (n : â„•) (H : â„• â†’ subgroup G), is_descending_central_series H âˆ§ H n = âŠ¥
theorem measure_theory.strongly_measurable.integral_prod_left' {Î± : Type u_1} {Î² : Type u_3} {E : Type u_6} [measurable_space Î±] [measurable_space Î²] {Î¼ : measure_theory.measure Î±} [normed_group E] [normed_space â„ E] [complete_space E] [measure_theory.sigma_finite Î¼] â¦ƒf : Î± Ã— Î² â†’ Eâ¦„ (hf : measure_theory.strongly_measurable f) : measure_theory.strongly_measurable (Î» (y : Î²), âˆ« (x : Î±), f (x, y) âˆ‚Î¼)
theorem finset.prod_insert_one {Î² : Type u} {Î± : Type v} {s : finset Î±} {a : Î±} {f : Î± â†’ Î²} [comm_monoid Î²] [decidable_eq Î±] (h : f a = 1) : (has_insert.insert a s).prod (Î» (x : Î±), f x) = s.prod (Î» (x : Î±), f x)
theorem fin_injective  : function.injective fin
theorem measure_theory.ae_measurable_of_exist_almost_disjoint_supersets {Î± : Type u_1} {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) {Î² : Type u_2} [complete_linear_order Î²] [densely_ordered Î²] [topological_space Î²] [order_topology Î²] [topological_space.second_countable_topology Î²] [measurable_space Î²] [borel_space Î²] (s : set Î²) (s_count : s.countable) (s_dense : dense s) (f : Î± â†’ Î²) (h : âˆ€ (p : Î²), p âˆˆ s â†’ âˆ€ (q : Î²), q âˆˆ s â†’ p < q â†’ (âˆƒ (u v : set Î±), measurable_set u âˆ§ measurable_set v âˆ§ {x : Î± | f x < p} âŠ† u âˆ§ {x : Î± | q < f x} âŠ† v âˆ§ â‡‘Î¼ (u âˆ© v) = 0)) : ae_measurable f Î¼
theorem star_mul' {R : Type u} [comm_semigroup R] [star_semigroup R] (x y : R) : has_star.star (x * y) = has_star.star x * has_star.star y
theorem tendsto_inf_principal_nhds_iff_of_forall_eq {Î± : Type u} {Î² : Type v} [topological_space Î±] {f : Î² â†’ Î±} {l : filter Î²} {s : set Î²} {a : Î±} (h : âˆ€ (x : Î²), x âˆ‰ s â†’ f x = a) : filter.tendsto f (l âŠ“ filter.principal s) (nhds a) â†” filter.tendsto f l (nhds a)
theorem submodule.torsion_by_set_eq_torsion_by_span {R : Type u_1} {M : Type u_2} [comm_semiring R] [add_comm_monoid M] [module R M] (s : set R) : submodule.torsion_by_set R M s = submodule.torsion_by_set R M â†‘(ideal.span s)
theorem normed_group_hom.norm_id {V : Type u_1} [normed_group V] [nontrivial V] : âˆ¥normed_group_hom.id Vâˆ¥ = 1
theorem is_alg_closed.cardinal_eq_cardinal_transcendence_basis_of_aleph_0_lt {R K : Type u} [comm_ring R] [field K] [algebra R K] [is_alg_closed K] {Î¹ : Type u} (v : Î¹ â†’ K) [nontrivial R] (hv : is_transcendence_basis R v) (hR : cardinal.mk R â‰¤ cardinal.aleph_0) (hK : cardinal.aleph_0 < cardinal.mk K) : cardinal.mk K = cardinal.mk Î¹
theorem con.mk'_ker {M : Type u_1} [mul_one_class M] (c : con M) : con.ker c.mk' = c
theorem smul_add_smul_lt_smul_add_smul {k : Type u_1} {M : Type u_2} [ordered_ring k] [ordered_add_comm_group M] [module k M] [ordered_smul k M] [covariant_class M M has_add.add has_lt.lt] [contravariant_class M M has_add.add has_lt.lt] {a b : k} {c d : M} (hab : a < b) (hcd : c < d) : a â€¢ d + b â€¢ c < a â€¢ c + b â€¢ d
theorem supr_nhds_le_uniformity {Î± : Type u_1} [uniform_space Î±] : (â¨† (x : Î±), nhds (x, x)) â‰¤ uniformity Î±
theorem measure_theory.outer_measure.mk_metric'_is_metric {X : Type u_2} [emetric_space X] (m : set X â†’ ennreal) : (measure_theory.outer_measure.mk_metric' m).is_metric
theorem submonoid.localization_map.mul_inv {M : Type u_1} [comm_monoid M] {S : submonoid M} {N : Type u_2} [comm_monoid N] {f : M â†’* N} (h : âˆ€ (y : â†¥S), is_unit (â‡‘f â†‘y)) {xâ‚ xâ‚‚ : M} {yâ‚ yâ‚‚ : â†¥S} : â‡‘f xâ‚ * â†‘(â‡‘(is_unit.lift_right (f.restrict S) h) yâ‚)â»Â¹ = â‡‘f xâ‚‚ * â†‘(â‡‘(is_unit.lift_right (f.restrict S) h) yâ‚‚)â»Â¹ â†” â‡‘f (xâ‚ * â†‘yâ‚‚) = â‡‘f (xâ‚‚ * â†‘yâ‚)
theorem cont_diff.neg {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {n : with_top â„•} {f : E â†’ F} (hf : cont_diff ğ•œ n f) : cont_diff ğ•œ n (Î» (x : E), -f x)
theorem minpoly.gcd_domain_dvd {A : Type u_1} {R : Type u_2} (K : Type u_3) [comm_ring A] [is_domain A] [normalized_gcd_monoid A] [field K] [comm_ring R] [is_domain R] [algebra A K] [is_fraction_ring A K] [algebra K R] [algebra A R] [is_scalar_tower A K R] {x : R} (hx : is_integral A x) {P : polynomial A} (hprim : P.is_primitive) (hroot : â‡‘(polynomial.aeval x) P = 0) : minpoly A x âˆ£ P
theorem euclidean_geometry.eq_of_dist_eq_of_dist_eq_of_mem_of_finrank_eq_two {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace â„ P} [finite_dimensional â„ â†¥(s.direction)] (hd : finite_dimensional.finrank â„ â†¥(s.direction) = 2) {câ‚ câ‚‚ pâ‚ pâ‚‚ p : P} (hcâ‚s : câ‚ âˆˆ s) (hcâ‚‚s : câ‚‚ âˆˆ s) (hpâ‚s : pâ‚ âˆˆ s) (hpâ‚‚s : pâ‚‚ âˆˆ s) (hps : p âˆˆ s) {râ‚ râ‚‚ : â„} (hc : câ‚ â‰  câ‚‚) (hp : pâ‚ â‰  pâ‚‚) (hpâ‚câ‚ : has_dist.dist pâ‚ câ‚ = râ‚) (hpâ‚‚câ‚ : has_dist.dist pâ‚‚ câ‚ = râ‚) (hpcâ‚ : has_dist.dist p câ‚ = râ‚) (hpâ‚câ‚‚ : has_dist.dist pâ‚ câ‚‚ = râ‚‚) (hpâ‚‚câ‚‚ : has_dist.dist pâ‚‚ câ‚‚ = râ‚‚) (hpcâ‚‚ : has_dist.dist p câ‚‚ = râ‚‚) : p = pâ‚ âˆ¨ p = pâ‚‚
theorem affine.simplex.monge_plane_def {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {n : â„•} (s : affine.simplex â„ P (n + 2)) (iâ‚ iâ‚‚ : fin (n + 3)) : s.monge_plane iâ‚ iâ‚‚ = affine_subspace.mk' (finset.centroid â„ {iâ‚, iâ‚‚}á¶œ s.points) (submodule.span â„ {s.points iâ‚ -áµ¥ s.points iâ‚‚})á—® âŠ“ affine_span â„ (set.range s.points)
theorem alternating_map.comp_linear_map_id {R : Type u_1} [semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {N : Type u_3} [add_comm_monoid N] [module R N] {Î¹ : Type u_6} [decidable_eq Î¹] (f : alternating_map R M N Î¹) : f.comp_linear_map linear_map.id = f
theorem cont_diff.comp_cont_diff_on {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {G : Type u_4} [normed_group G] [normed_space ğ•œ G] {n : with_top â„•} {s : set E} {g : F â†’ G} {f : E â†’ F} (hg : cont_diff ğ•œ n g) (hf : cont_diff_on ğ•œ n f s) : cont_diff_on ğ•œ n (g âˆ˜ f) s
theorem composition.sigma_pi_composition_eq_iff {n : â„•} (u v : Î£ (c : composition n), Î  (i : fin c.length), composition (c.blocks_fun i)) : u = v â†” list.of_fn (Î» (i : fin u.fst.length), (u.snd i).blocks) = list.of_fn (Î» (i : fin v.fst.length), (v.snd i).blocks)
theorem list.nat.mem_antidiagonal {n : â„•} {x : â„• Ã— â„•} : x âˆˆ list.nat.antidiagonal n â†” x.fst + x.snd = n
theorem interval_integrable_inv_iff {a b : â„} : interval_integrable (Î» (x : â„), xâ»Â¹) measure_theory.measure_space.volume a b â†” a = b âˆ¨ 0 âˆ‰ set.interval a b
theorem dense_range.dense_image {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] {f : Î± â†’ Î²} (hf' : dense_range f) (hf : continuous f) {s : set Î±} (hs : dense s) : dense (f '' s)
theorem ext_chart_model_space_eq_id (ğ•œ : Type u_1) [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] (x : E) : ext_chart_at (model_with_corners_self ğ•œ E) x = local_equiv.refl E
theorem not_interval_integrable_of_tendsto_norm_at_top_of_deriv_is_O_filter {E : Type u_1} {F : Type u_2} [normed_group E] [normed_space â„ E] [topological_space.second_countable_topology E] [complete_space E] [normed_group F] {f : â„ â†’ E} {g : â„ â†’ F} {a b : â„} (l : filter â„) [l.ne_bot] [filter.tendsto_Ixx_class set.Icc l l] (hl : set.interval a b âˆˆ l) (hd : âˆ€á¶  (x : â„) in l, differentiable_at â„ f x) (hf : filter.tendsto (Î» (x : â„), âˆ¥f xâˆ¥) l filter.at_top) (hfg : deriv f =O[l] g) : Â¬interval_integrable g measure_theory.measure_space.volume a b
theorem local_homeomorph.cont_diff_at_symm {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {n : with_top â„•} [complete_space E] (f : local_homeomorph E F) {fâ‚€' : E â‰ƒL[ğ•œ] F} {a : F} (ha : a âˆˆ f.to_local_equiv.target) (hfâ‚€' : has_fderiv_at â‡‘f â†‘fâ‚€' (â‡‘(f.symm) a)) (hf : cont_diff_at ğ•œ n â‡‘f (â‡‘(f.symm) a)) : cont_diff_at ğ•œ n â‡‘(f.symm) a
theorem pairwise.set_of_subtype {Î± : Type u_1} (s : set Î±) (r : Î± â†’ Î± â†’ Prop) : pairwise (Î» (x y : â†¥s), r â†‘x â†‘y) â†’ s.pairwise r
theorem matrix.fin.circulant_ite (Î± : Type u_1) [has_zero Î±] [has_one Î±] (n : â„•) : matrix.circulant (Î» (i : fin n), ite (â†‘i = 0) 1 0) = 1
theorem matrix.nondegenerate.exists_not_ortho_of_ne_zero {m : Type u_1} {R : Type u_2} [fintype m] [comm_ring R] {M : matrix m m R} (hM : M.nondegenerate) {v : m â†’ R} (hv : v â‰  0) : âˆƒ (w : m â†’ R), matrix.dot_product v (M.mul_vec w) â‰  0
theorem normed_ring.tsum_geometric_of_norm_lt_1 {R : Type u_4} [normed_ring R] [complete_space R] (x : R) (h : âˆ¥xâˆ¥ < 1) : âˆ¥âˆ‘' (n : â„•), x ^ nâˆ¥ â‰¤ âˆ¥1âˆ¥ - 1 + (1 - âˆ¥xâˆ¥)â»Â¹
theorem ring_hom.comp_assoc {Î± : Type u_2} {Î² : Type u_3} {Î³ : Type u_4} [rÎ± : non_assoc_semiring Î±] [rÎ² : non_assoc_semiring Î²] {rÎ³ : non_assoc_semiring Î³} {Î´ : Type u_1} {rÎ´ : non_assoc_semiring Î´} (f : Î± â†’+* Î²) (g : Î² â†’+* Î³) (h : Î³ â†’+* Î´) : (h.comp g).comp f = h.comp (g.comp f)
theorem inducing.is_compact_iff {Î± : Type u} {Î² : Type v} [topological_space Î±] [topological_space Î²] {f : Î± â†’ Î²} (hf : inducing f) {s : set Î±} : is_compact (f '' s) â†” is_compact s
theorem affine_span_mono (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {sâ‚ sâ‚‚ : set P} (h : sâ‚ âŠ† sâ‚‚) : affine_span k sâ‚ â‰¤ affine_span k sâ‚‚
theorem is_artinian.bijective_of_injective_endomorphism {R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] [is_artinian R M] (f : M â†’â‚—[R] M) (s : function.injective â‡‘f) : function.bijective â‡‘f
theorem dfinsupp.sum_add_hom_apply {Î¹ : Type u} {Î³ : Type w} {Î² : Î¹ â†’ Type v} [dec : decidable_eq Î¹] [Î  (i : Î¹), add_zero_class (Î² i)] [Î  (i : Î¹) (x : Î² i), decidable (x â‰  0)] [add_comm_monoid Î³] (Ï† : Î  (i : Î¹), Î² i â†’+ Î³) (f : Î â‚€ (i : Î¹), Î² i) : â‡‘(dfinsupp.sum_add_hom Ï†) f = f.sum (Î» (x : Î¹), â‡‘(Ï† x))
theorem sq {M : Type u} [monoid M] (a : M) : a ^ 2 = a * a
theorem inv_nat_cast_smul_comm {Î± : Type u_1} {E : Type u_2} (R : Type u_3) [add_comm_group E] [division_ring R] [monoid Î±] [module R E] [distrib_mul_action Î± E] (n : â„•) (s : Î±) (x : E) : (â†‘n)â»Â¹ â€¢ s â€¢ x = s â€¢ (â†‘n)â»Â¹ â€¢ x
theorem linear_independent.of_subtype_range {R : Type u_3} {M : Type u_5} [semiring R] [add_comm_monoid M] [module R M] {Î¹ : Type u_1} {f : Î¹ â†’ M} (hf : function.injective f) : linear_independent R coe â†’ linear_independent R f
theorem affine_independent_iff_not_finrank_vector_span_le (k : Type u_1) {V : Type u_2} {P : Type u_3} {Î¹ : Type u_4} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] [fintype Î¹] (p : Î¹ â†’ P) {n : â„•} (hc : fintype.card Î¹ = n + 2) : affine_independent k p â†” Â¬finite_dimensional.finrank k â†¥(vector_span k (set.range p)) â‰¤ n
theorem continuous_on_extend_from {X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] [regular_space Y] {f : X â†’ Y} {A B : set X} (hB : B âŠ† closure A) (hf : âˆ€ (x : X), x âˆˆ B â†’ (âˆƒ (y : Y), filter.tendsto f (nhds_within x A) (nhds y))) : continuous_on (extend_from A f) B
theorem submodule.span_induction' {R : Type u_1} {M : Type u_4} [semiring R] [add_comm_monoid M] [module R M] {s : set M} {p : Î  (x : M), x âˆˆ submodule.span R s â†’ Prop} (Hs : âˆ€ (x : M) (h : x âˆˆ s), p x _) (H0 : p 0 _) (H1 : âˆ€ (x : M) (hx : x âˆˆ submodule.span R s) (y : M) (hy : y âˆˆ submodule.span R s), p x hx â†’ p y hy â†’ p (x + y) _) (H2 : âˆ€ (a : R) (x : M) (hx : x âˆˆ submodule.span R s), p x hx â†’ p (a â€¢ x) _) {x : M} (hx : x âˆˆ submodule.span R s) : p x hx
theorem affine.simplex.inner_monge_point_vsub_face_centroid_vsub {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {n : â„•} (s : affine.simplex â„ P (n + 2)) {iâ‚ iâ‚‚ : fin (n + 3)} : has_inner.inner (s.monge_point -áµ¥ finset.centroid â„ {iâ‚, iâ‚‚}á¶œ s.points) (s.points iâ‚ -áµ¥ s.points iâ‚‚) = 0
theorem absorbent_nhds_zero {ğ•œ : Type u_1} {E : Type u_3} [normed_field ğ•œ] [add_comm_group E] [module ğ•œ E] {A : set E} [topological_space E] [has_continuous_smul ğ•œ E] (hA : A âˆˆ nhds 0) : absorbent ğ•œ A
theorem measure_theory.signed_measure.eq_singular_part {Î± : Type u_1} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {s : measure_theory.signed_measure Î±} (t : measure_theory.signed_measure Î±) (f : Î± â†’ â„) (htÎ¼ : measure_theory.vector_measure.mutually_singular t Î¼.to_ennreal_vector_measure) (hadd : s = t + Î¼.with_densityáµ¥ f) : t = s.singular_part Î¼
theorem is_bounded_bilinear_map.cont_diff {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {G : Type u_4} [normed_group G] [normed_space ğ•œ G] {b : E Ã— F â†’ G} {n : with_top â„•} (hb : is_bounded_bilinear_map ğ•œ b) : cont_diff ğ•œ n b
theorem add_con.ext' {M : Type u_1} [has_add M] {c d : add_con M} (H : setoid.r = setoid.r) : c = d
theorem category_theory.limits.has_colimits_of_size_shrink (C : Type u) [category_theory.category C] [category_theory.limits.has_colimits_of_size C] : category_theory.limits.has_colimits_of_size C
theorem exp_neg_inv_glue.f_aux_has_deriv_at (n : â„•) (x : â„) : has_deriv_at (exp_neg_inv_glue.f_aux n) (exp_neg_inv_glue.f_aux (n + 1) x) x
theorem polynomial.cyclotomic_mul_prime_eq_pow_of_not_dvd (R : Type u_1) {p n : â„•} [hp : fact (nat.prime p)] [ring R] [char_p R p] (hn : Â¬p âˆ£ n) : polynomial.cyclotomic (n * p) R = polynomial.cyclotomic n R ^ (p - 1)
theorem interval_integral.deriv_integral_left {E : Type u_3} [normed_group E] [complete_space E] [normed_space â„ E] {f : â„ â†’ E} {a b : â„} (hf : interval_integrable f measure_theory.measure_space.volume a b) (hmeas : strongly_measurable_at_filter f (nhds a) measure_theory.measure_space.volume) (hb : continuous_at f a) : deriv (Î» (u : â„), âˆ« (x : â„) in u..b, f x) a = -f a
theorem box_integral.integrable.to_subbox {Î¹ : Type u} {E : Type v} {F : Type w} [normed_group E] [normed_space â„ E] [normed_group F] [normed_space â„ F] {I J : box_integral.box Î¹} [fintype Î¹] {l : box_integral.integration_params} {f : (Î¹ â†’ â„) â†’ E} {vol : box_integral.box_additive_map Î¹ (E â†’L[â„] F) âŠ¤} [complete_space F] (h : box_integral.integrable I l f vol) (hJ : J â‰¤ I) : box_integral.integrable J l f vol
theorem cont_diff_at.sub {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {x : E} {n : with_top â„•} {f g : E â†’ F} (hf : cont_diff_at ğ•œ n f x) (hg : cont_diff_at ğ•œ n g x) : cont_diff_at ğ•œ n (Î» (x : E), f x - g x) x
theorem integral_sin_pow_odd_mul_cos_pow {a b : â„} (m n : â„•) : âˆ« (x : â„) in a..b, real.sin x ^ (2 * m + 1) * real.cos x ^ n = âˆ« (u : â„) in real.cos b..real.cos a, u ^ n * (1 - u ^ 2) ^ m
theorem hall_marriage_theorem.hall_hard_inductive_step_B {Î¹ : Type u} {Î± : Type v} [fintype Î¹] {t : Î¹ â†’ finset Î±} [decidable_eq Î±] {n : â„•} (hn : fintype.card Î¹ = n + 1) (ht : âˆ€ (s : finset Î¹), s.card â‰¤ (s.bUnion t).card) (ih : âˆ€ {Î¹' : Type u} [_inst_3 : fintype Î¹'] (t' : Î¹' â†’ finset Î±), fintype.card Î¹' â‰¤ n â†’ (âˆ€ (s' : finset Î¹'), s'.card â‰¤ (s'.bUnion t').card) â†’ (âˆƒ (f : Î¹' â†’ Î±), function.injective f âˆ§ âˆ€ (x : Î¹'), f x âˆˆ t' x)) (s : finset Î¹) (hs : s.nonempty) (hns : s â‰  finset.univ) (hus : s.card = (s.bUnion t).card) : âˆƒ (f : Î¹ â†’ Î±), function.injective f âˆ§ âˆ€ (x : Î¹), f x âˆˆ t x
theorem homotopy.comp_null_homotopic_map {Î¹ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape Î¹} {C D E : homological_complex V c} (f : C âŸ¶ D) (hom : Î  (i j : Î¹), D.X i âŸ¶ E.X j) : f â‰« homotopy.null_homotopic_map hom = homotopy.null_homotopic_map (Î» (i j : Î¹), f.f i â‰« hom i j)
theorem cont_mdiff_within_at_iff'' {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners ğ•œ E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] {f : M â†’ M'} {s : set M} {x : M} {n : with_top â„•} : cont_mdiff_within_at I I' n f s x â†” continuous_within_at f s x âˆ§ cont_diff_within_at ğ•œ n (written_in_ext_chart_at I I' x f) (â‡‘((ext_chart_at I x).symm) â»Â¹' s âˆ© set.range â‡‘I) (â‡‘(ext_chart_at I x) x)
theorem nonpos_of_neg_nonneg {Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± has_add.add has_le.le] {a : Î±} : 0 â‰¤ -a â†’ a â‰¤ 0
theorem measure_theory.nonempty_inter_of_measure_lt_add' {Î± : Type u_1} {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) {s t u : set Î±} (hs : measurable_set s) (h's : s âŠ† u) (h't : t âŠ† u) (h : â‡‘Î¼ u < â‡‘Î¼ s + â‡‘Î¼ t) : (s âˆ© t).nonempty
theorem continuous_linear_map.op_norm_comp_linear_isometry_equiv {ğ•œâ‚‚ : Type u_2} {ğ•œâ‚ƒ : Type u_3} {F : Type u_6} {G : Type u_8} [normed_group F] [normed_group G] [nondiscrete_normed_field ğ•œâ‚‚] [nondiscrete_normed_field ğ•œâ‚ƒ] [normed_space ğ•œâ‚‚ F] [normed_space ğ•œâ‚ƒ G] {Ïƒâ‚‚â‚ƒ : ğ•œâ‚‚ â†’+* ğ•œâ‚ƒ} {ğ•œâ‚‚' : Type u_10} [nondiscrete_normed_field ğ•œâ‚‚'] {F' : Type u_11} [normed_group F'] [normed_space ğ•œâ‚‚' F'] {Ïƒâ‚‚' : ğ•œâ‚‚' â†’+* ğ•œâ‚‚} {Ïƒâ‚‚'' : ğ•œâ‚‚ â†’+* ğ•œâ‚‚'} {Ïƒâ‚‚â‚ƒ' : ğ•œâ‚‚' â†’+* ğ•œâ‚ƒ} [ring_hom_inv_pair Ïƒâ‚‚' Ïƒâ‚‚''] [ring_hom_inv_pair Ïƒâ‚‚'' Ïƒâ‚‚'] [ring_hom_comp_triple Ïƒâ‚‚' Ïƒâ‚‚â‚ƒ Ïƒâ‚‚â‚ƒ'] [ring_hom_comp_triple Ïƒâ‚‚'' Ïƒâ‚‚â‚ƒ' Ïƒâ‚‚â‚ƒ] [ring_hom_isometric Ïƒâ‚‚â‚ƒ] [ring_hom_isometric Ïƒâ‚‚'] [ring_hom_isometric Ïƒâ‚‚''] [ring_hom_isometric Ïƒâ‚‚â‚ƒ'] (f : F â†’SL[Ïƒâ‚‚â‚ƒ] G) (g : F' â‰ƒâ‚›â‚—áµ¢[Ïƒâ‚‚'] F) : âˆ¥f.comp g.to_linear_isometry.to_continuous_linear_mapâˆ¥ = âˆ¥fâˆ¥
theorem fin.coe_cast {n m : â„•} (h : n = m) (i : fin n) : â†‘(â‡‘(fin.cast h) i) = â†‘i
theorem dfinsupp.lift_add_hom_apply_single {Î¹ : Type u} {Î³ : Type w} {Î² : Î¹ â†’ Type v} [dec : decidable_eq Î¹] [Î  (i : Î¹), add_zero_class (Î² i)] [add_comm_monoid Î³] (f : Î  (i : Î¹), Î² i â†’+ Î³) (i : Î¹) (x : Î² i) : â‡‘(â‡‘dfinsupp.lift_add_hom f) (dfinsupp.single i x) = â‡‘(f i) x
theorem submodule.exists_sum_of_mem_ideal_smul_span {R : Type u} {M : Type v} [comm_semiring R] [add_comm_monoid M] [module R M] (I : ideal R) {Î¹ : Type u_1} (s : set Î¹) (f : Î¹ â†’ M) (x : M) (hx : x âˆˆ I â€¢ submodule.span R (f '' s)) : âˆƒ (a : â†¥s â†’â‚€ R) (ha : âˆ€ (i : â†¥s), â‡‘a i âˆˆ I), a.sum (Î» (i : â†¥s) (c : R), c â€¢ f â†‘i) = x
theorem strict_mono_on.continuous_at_right_of_surj_on {Î± : Type u_1} {Î² : Type u_2} [linear_order Î±] [topological_space Î±] [order_topology Î±] [linear_order Î²] [topological_space Î²] [order_topology Î²] {f : Î± â†’ Î²} {s : set Î±} {a : Î±} (h_mono : strict_mono_on f s) (hs : s âˆˆ nhds_within a (set.Ici a)) (hfs : set.surj_on f s (set.Ioi (f a))) : continuous_within_at f (set.Ici a) a
theorem subring.zero_mem {R : Type u} [ring R] (s : subring R) : 0 âˆˆ s
theorem orthonormal.oangle_eq_two_zsmul_oangle_sub_of_norm_eq_real {V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) {x y z : V} (hxyne : x â‰  y) (hxzne : x â‰  z) {r : â„} (hx : âˆ¥xâˆ¥ = r) (hy : âˆ¥yâˆ¥ = r) (hz : âˆ¥zâˆ¥ = r) : hb.oangle y z = 2 â€¢ hb.oangle (y - x) (z - x)
theorem affine_subspace.bot_coe (k : Type u_1) (V : Type u_2) (P : Type u_3) [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] : â†‘âŠ¥ = âˆ…
theorem dvd_of_mul_left_eq {Î± : Type u_1} [comm_semigroup Î±] {a b : Î±} (c : Î±) (h : c * a = b) : a âˆ£ b
theorem is_integral_tower_bot_of_is_integral {R : Type u_1} {A : Type u_2} {B : Type u_3} [comm_ring R] [comm_ring A] [comm_ring B] [algebra A B] [algebra R B] [algebra R A] [is_scalar_tower R A B] (H : function.injective â‡‘(algebra_map A B)) {x : A} (h : is_integral R (â‡‘(algebra_map A B) x)) : is_integral R x
theorem semiconj_by.one_left {M : Type u} [mul_one_class M] (x : M) : semiconj_by 1 x x
theorem char_zero_of_injective_algebra_map {R : Type u_1} {A : Type u_2} [comm_semiring R] [semiring A] [algebra R A] (h : function.injective â‡‘(algebra_map R A)) [char_zero R] : char_zero A
theorem category_theory.limits.wide_coequalizer.hom_ext {J : Type v} {C : Type u} [category_theory.category C] {X Y : C} {f : J â†’ (X âŸ¶ Y)} [category_theory.limits.has_wide_coequalizer f] [nonempty J] {W : C} {k l : category_theory.limits.wide_coequalizer f âŸ¶ W} (h : category_theory.limits.wide_coequalizer.Ï€ f â‰« k = category_theory.limits.wide_coequalizer.Ï€ f â‰« l) : k = l
theorem inner_product_space.is_self_adjoint.orthogonal_supr_eigenspaces_eq_bot {ğ•œ : Type u_1} [is_R_or_C ğ•œ] {E : Type u_2} [inner_product_space ğ•œ E] {T : E â†’â‚—[ğ•œ] E} (hT : inner_product_space.is_self_adjoint T) [finite_dimensional ğ•œ E] : (â¨† (Î¼ : ğ•œ), module.End.eigenspace T Î¼)á—® = âŠ¥
theorem rel_sup_add {Î± : Type u_1} {Î² : Type u_2} [add_comm_monoid Î±] [topological_space Î±] [t2_space Î±] [complete_lattice Î²] (m : Î² â†’ Î±) (m0 : m âŠ¥ = 0) (R : Î± â†’ Î± â†’ Prop) (m_supr : âˆ€ (s : â„• â†’ Î²), R (m (â¨† (i : â„•), s i)) (âˆ‘' (i : â„•), m (s i))) (sâ‚ sâ‚‚ : Î²) : R (m (sâ‚ âŠ” sâ‚‚)) (m sâ‚ + m sâ‚‚)
theorem category_theory.limits.image_subobject_comp_le {C : Type u} [category_theory.category C] {X Y X' : C} (h : X' âŸ¶ X) (f : X âŸ¶ Y) [category_theory.limits.has_image f] [category_theory.limits.has_image (h â‰« f)] : category_theory.limits.image_subobject (h â‰« f) â‰¤ category_theory.limits.image_subobject f
theorem complex.schwarz_aux {Râ‚ Râ‚‚ : â„} {c z : â„‚} {f : â„‚ â†’ â„‚} (hd : differentiable_on â„‚ f (metric.ball c Râ‚)) (h_maps : set.maps_to f (metric.ball c Râ‚) (metric.ball (f c) Râ‚‚)) (hz : z âˆˆ metric.ball c Râ‚) : âˆ¥dslope f c zâˆ¥ â‰¤ Râ‚‚ / Râ‚
theorem zero_lt.right.mul_lt_one_of_le_of_lt {Î± : Type u} {a b : Î±} [mul_one_class Î±] [has_zero Î±] [preorder Î±] [zero_lt.mul_pos_mono Î±] (ha : a â‰¤ 1) (hb : b < 1) (b0 : 0 < b) : a * b < 1
theorem set.finite.convex_hull_eq_image {R : Type u_1} {E : Type u_2} [linear_ordered_field R] [add_comm_group E] [module R E] {s : set E} (hs : s.finite) : â‡‘(convex_hull R) s = â‡‘(finset.univ.sum (Î» (x : â†¥s), (linear_map.proj x).smul_right x.val)) '' std_simplex R â†¥s
theorem polynomial.derivative_evalâ‚‚_C {R : Type u} [comm_semiring R] (p q : polynomial R) : â‡‘polynomial.derivative (polynomial.evalâ‚‚ polynomial.C q p) = polynomial.evalâ‚‚ polynomial.C q (â‡‘polynomial.derivative p) * â‡‘polynomial.derivative q
theorem valuation.subgroups_basis {R : Type u} [ring R] {Î“â‚€ : Type v} [linear_ordered_comm_group_with_zero Î“â‚€] (v : valuation R Î“â‚€) : ring_subgroups_basis (Î» (Î³ : Î“â‚€Ë£), v.lt_add_subgroup Î³)
theorem inseparable.nhds_eq {X : Type u_1} [topological_space X] {x y : X} : inseparable x y â†’ nhds x = nhds y
theorem matrix.to_lin_mul_apply {R : Type u_1} [comm_semiring R] {l : Type u_2} {m : Type u_3} {n : Type u_4} [fintype n] [fintype m] [decidable_eq n] {Mâ‚ : Type u_5} {Mâ‚‚ : Type u_6} [add_comm_monoid Mâ‚] [add_comm_monoid Mâ‚‚] [module R Mâ‚] [module R Mâ‚‚] (vâ‚ : basis n R Mâ‚) (vâ‚‚ : basis m R Mâ‚‚) {Mâ‚ƒ : Type u_7} [add_comm_monoid Mâ‚ƒ] [module R Mâ‚ƒ] (vâ‚ƒ : basis l R Mâ‚ƒ) [fintype l] [decidable_eq m] (A : matrix l m R) (B : matrix m n R) (x : Mâ‚) : â‡‘(â‡‘(matrix.to_lin vâ‚ vâ‚ƒ) (A.mul B)) x = â‡‘(â‡‘(matrix.to_lin vâ‚‚ vâ‚ƒ) A) (â‡‘(â‡‘(matrix.to_lin vâ‚ vâ‚‚) B) x)
theorem finset.sum_smul_vsub_eq_weighted_vsub_sub {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {Î¹ : Type u_4} (s : finset Î¹) (w : Î¹ â†’ k) (pâ‚ pâ‚‚ : Î¹ â†’ P) : s.sum (Î» (i : Î¹), w i â€¢ (pâ‚ i -áµ¥ pâ‚‚ i)) = â‡‘(s.weighted_vsub pâ‚) w - â‡‘(s.weighted_vsub pâ‚‚) w
theorem is_cyclotomic_extension.singleton_one (A : Type u) (B : Type v) [comm_ring A] [comm_ring B] [algebra A B] [h : is_cyclotomic_extension {1} A B] : âŠ¥ = âŠ¤
theorem finprod_mem_induction {Î± : Type u_1} {M : Type u_5} [comm_monoid M] {f : Î± â†’ M} {s : set Î±} (p : M â†’ Prop) (hpâ‚€ : p 1) (hpâ‚ : âˆ€ (x y : M), p x â†’ p y â†’ p (x * y)) (hpâ‚‚ : âˆ€ (x : Î±), x âˆˆ s â†’ p (f x)) : p (finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), f i)))
theorem interval_integral.deriv_within_integral_left {E : Type u_3} [normed_group E] [complete_space E] [normed_space â„ E] {f : â„ â†’ E} {a b : â„} (hf : interval_integrable f measure_theory.measure_space.volume a b) {s t : set â„} [interval_integral.FTC_filter a (nhds_within a s) (nhds_within a t)] (hmeas : strongly_measurable_at_filter f (nhds_within a t) measure_theory.measure_space.volume) (ha : continuous_within_at f t a) (hs : unique_diff_within_at â„ s a . "unique_diff_within_at_Ici_Iic_univ") : deriv_within (Î» (u : â„), âˆ« (x : â„) in u..b, f x) s a = -f a
theorem lower_semicontinuous_within_at.add' {Î± : Type u_1} [topological_space Î±] {x : Î±} {s : set Î±} {Î³ : Type u_4} [linear_ordered_add_comm_monoid Î³] [topological_space Î³] [order_topology Î³] {f g : Î± â†’ Î³} (hf : lower_semicontinuous_within_at f s x) (hg : lower_semicontinuous_within_at g s x) (hcont : continuous_at (Î» (p : Î³ Ã— Î³), p.fst + p.snd) (f x, g x)) : lower_semicontinuous_within_at (Î» (z : Î±), f z + g z) s x
theorem phragmen_lindelof.eq_zero_on_vertical_strip {E : Type u_1} [normed_group E] [normed_space â„‚ E] {a b : â„} {f : â„‚ â†’ E} (hd : diff_cont_on_cl â„‚ f (complex.re â»Â¹' set.Ioo a b)) (hB : âˆƒ (c : â„) (H : c < real.pi / (b - a)) (B : â„), f =O[filter.comap (has_abs.abs âˆ˜ complex.im) filter.at_top âŠ“ filter.principal (complex.re â»Â¹' set.Ioo a b)] Î» (z : â„‚), real.exp (B * real.exp (c * |z.im|))) (ha : âˆ€ (z : â„‚), z.re = a â†’ f z = 0) (hb : âˆ€ (z : â„‚), z.re = b â†’ f z = 0) : set.eq_on f 0 (complex.re â»Â¹' set.Icc a b)
theorem cardinal.bdd_above_iff_small (s : set cardinal) : bdd_above s â†” small â†¥s
theorem module.ext' {R : Type u_1} [semiring R] {M : Type u_2} [add_comm_monoid M] (P Q : module R M) (w : âˆ€ (r : R) (m : M), r â€¢ m = r â€¢ m) : P = Q
theorem has_le.le.eq_or_lt_dec {Î± : Type u} [partial_order Î±] [decidable_rel has_le.le] {a b : Î±} (hab : a â‰¤ b) : a = b âˆ¨ a < b
theorem add_submonoid.mem_closure_singleton {A : Type u_2} [add_monoid A] {x y : A} : y âˆˆ add_submonoid.closure {x} â†” âˆƒ (n : â„•), n â€¢ x = y
theorem zero_lt.left.mul_pos {Î± : Type u} {a b : Î±} [mul_zero_class Î±] [preorder Î±] [zero_lt.pos_mul_strict_mono Î±] (ha : 0 < a) (hb : 0 < b) : 0 < a * b
theorem orthonormal.linear_independent {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {Î¹ : Type u_4} {v : Î¹ â†’ E} (hv : orthonormal ğ•œ v) : linear_independent ğ•œ v
theorem continuous_at.comp_div_cases {Î± : Type u_1} {Î² : Type u_2} {Gâ‚€ : Type u_3} [group_with_zero Gâ‚€] [topological_space Gâ‚€] [has_continuous_invâ‚€ Gâ‚€] [has_continuous_mul Gâ‚€] [topological_space Î±] [topological_space Î²] {a : Î±} {f g : Î± â†’ Gâ‚€} (h : Î± â†’ Gâ‚€ â†’ Î²) (hf : continuous_at f a) (hg : continuous_at g a) (hh : g a â‰  0 â†’ continuous_at â†¿h (a, f a / g a)) (h2h : g a = 0 â†’ filter.tendsto â†¿h ((nhds a).prod âŠ¤) (nhds (h a 0))) : continuous_at (Î» (x : Î±), h x (f x / g x)) a
theorem complete_lattice.independent.map_order_iso {Î¹ : Sort u_1} {Î± : Type u_2} {Î² : Type u_3} [complete_lattice Î±] [complete_lattice Î²] (f : Î± â‰ƒo Î²) {a : Î¹ â†’ Î±} (ha : complete_lattice.independent a) : complete_lattice.independent (â‡‘f âˆ˜ a)
theorem category_theory.endofunctor.algebra.initial.str_is_iso {C : Type u} [category_theory.category C] {F : C â¥¤ C} {A : category_theory.endofunctor.algebra F} (h : category_theory.limits.is_initial A) : category_theory.is_iso A.str
theorem algebra.trace_algebra_map_of_basis {R : Type u_1} {S : Type u_2} [comm_ring R] [comm_ring S] [algebra R S] {Î¹ : Type w} [fintype Î¹] (b : basis Î¹ R S) (x : R) : â‡‘(algebra.trace R S) (â‡‘(algebra_map R S) x) = fintype.card Î¹ â€¢ x
theorem monoid_algebra.mv_polynomial_aeval_of_surjective_of_closure {R : Type u_1} {M : Type u_2} [comm_monoid M] [comm_semiring R] {S : set M} (hS : submonoid.closure S = âŠ¤) : function.surjective â‡‘(mv_polynomial.aeval (Î» (s : â†¥S), â‡‘(monoid_algebra.of R M) â†‘s))
theorem is_cyclotomic_extension.discr_odd_prime {p : â„•+} {K : Type u} {L : Type v} {Î¶ : L} [field K] [field L] [algebra K L] [is_cyclotomic_extension {p} K L] [hp : fact (nat.prime â†‘p)] [ne_zero â†‘â†‘p] (hÎ¶ : is_primitive_root Î¶ â†‘p) (hirr : irreducible (polynomial.cyclotomic â†‘p K)) (hodd : p â‰  2) : algebra.discr K â‡‘((is_primitive_root.power_basis K hÎ¶).basis) = (-1) ^ ((â†‘p - 1) / 2) * â†‘p ^ (â†‘p - 2)
theorem linear_map.adjoint_inner_left {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] [inner_product_space ğ•œ F] [finite_dimensional ğ•œ E] [finite_dimensional ğ•œ F] (A : E â†’â‚—[ğ•œ] F) (x : E) (y : F) : has_inner.inner (â‡‘(â‡‘linear_map.adjoint A) y) x = has_inner.inner y (â‡‘A x)
theorem cont_diff_on.dense_compl_image_of_dimH_lt_finrank {E : Type u_4} {F : Type u_5} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] [normed_group F] [normed_space â„ F] [finite_dimensional â„ F] {f : E â†’ F} {s t : set E} (h : cont_diff_on â„ 1 f s) (hc : convex â„ s) (ht : t âŠ† s) (htF : dimH t < â†‘(finite_dimensional.finrank â„ F)) : dense (f '' t)á¶œ
theorem nilpotency_class_prod {Gâ‚ : Type u_2} {Gâ‚‚ : Type u_3} [group Gâ‚] [group Gâ‚‚] [group.is_nilpotent Gâ‚] [group.is_nilpotent Gâ‚‚] : group.nilpotency_class (Gâ‚ Ã— Gâ‚‚) = linear_order.max (group.nilpotency_class Gâ‚) (group.nilpotency_class Gâ‚‚)
theorem antivary_on.sum_smul_lt_sum_smul_comp_perm_iff {Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [linear_ordered_ring Î±] [linear_ordered_add_comm_group Î²] [module Î± Î²] [ordered_smul Î± Î²] {s : finset Î¹} {Ïƒ : equiv.perm Î¹} {f : Î¹ â†’ Î±} {g : Î¹ â†’ Î²} (hfg : antivary_on f g â†‘s) (hÏƒ : {x : Î¹ | â‡‘Ïƒ x â‰  x} âŠ† â†‘s) : s.sum (Î» (i : Î¹), f i â€¢ g i) < s.sum (Î» (i : Î¹), f i â€¢ g (â‡‘Ïƒ i)) â†” Â¬antivary_on f (g âˆ˜ â‡‘Ïƒ) â†‘s
theorem ennreal.Lp_add_le {Î¹ : Type u} (s : finset Î¹) (f g : Î¹ â†’ ennreal) {p : â„} (hp : 1 â‰¤ p) : s.sum (Î» (i : Î¹), (f i + g i) ^ p) ^ (1 / p) â‰¤ s.sum (Î» (i : Î¹), f i ^ p) ^ (1 / p) + s.sum (Î» (i : Î¹), g i ^ p) ^ (1 / p)
theorem dist_nndist {Î± : Type u} [pseudo_metric_space Î±] (x y : Î±) : has_dist.dist x y = â†‘(has_nndist.nndist x y)
theorem countable_of_isolated_right {Î± : Type u} [topological_space Î±] [linear_order Î±] [order_topology Î±] [topological_space.second_countable_topology Î±] : {x : Î± | âˆƒ (y : Î±), x < y âˆ§ set.Ioo x y = âˆ…}.countable
theorem linear_independent.fin_cons' {R : Type u_3} {M : Type u_5} [semiring R] [add_comm_monoid M] [module R M] {m : â„•} (x : M) (v : fin m â†’ M) (hli : linear_independent R v) (x_ortho : âˆ€ (c : R) (y : â†¥(submodule.span R (set.range v))), c â€¢ x + â†‘y = 0 â†’ c = 0) : linear_independent R (fin.cons x v)
theorem add_submonoid.subset_closure {M : Type u_1} [add_zero_class M] {s : set M} : s âŠ† â†‘(add_submonoid.closure s)
theorem list.prod_range_succ' {Î± : Type u} [monoid Î±] (f : â„• â†’ Î±) (n : â„•) : (list.map f (list.range n.succ)).prod = f 0 * (list.map (Î» (i : â„•), f i.succ) (list.range n)).prod
theorem continuous_linear_map.lmul_left_right_is_bounded_bilinear (ğ•œ : Type u_1) [nondiscrete_normed_field ğ•œ] (ğ•œ' : Type u_2) [normed_ring ğ•œ'] [normed_algebra ğ•œ ğ•œ'] : is_bounded_bilinear_map ğ•œ (Î» (p : ğ•œ' Ã— ğ•œ'), â‡‘(â‡‘(continuous_linear_map.lmul_left_right ğ•œ ğ•œ') p.fst) p.snd)
theorem convex.combo_interior_closure_subset_interior {E : Type u_2} {ğ•œ : Type u_3} [linear_ordered_field ğ•œ] [add_comm_group E] [module ğ•œ E] [topological_space E] [topological_add_group E] [has_continuous_const_smul ğ•œ E] {s : set E} (hs : convex ğ•œ s) {a b : ğ•œ} (ha : 0 < a) (hb : 0 â‰¤ b) (hab : a + b = 1) : a â€¢ interior s + b â€¢ closure s âŠ† interior s
theorem complex.Gamma_integral_add_one {s : â„‚} (hs : 0 < s.re) : (s + 1).Gamma_integral = s * s.Gamma_integral
theorem ideal.mem_map_C_iff {R : Type u} [comm_semiring R] {I : ideal R} {f : polynomial R} : f âˆˆ ideal.map polynomial.C I â†” âˆ€ (n : â„•), f.coeff n âˆˆ I
theorem category_theory.idempotents.is_idempotent_complete_iff_of_equivalence {C : Type u_1} [category_theory.category C] {D : Type u_3} [category_theory.category D] (Îµ : C â‰Œ D) : category_theory.is_idempotent_complete C â†” category_theory.is_idempotent_complete D
theorem two_pos {Î± : Type u} [ordered_semiring Î±] [nontrivial Î±] : 0 < 2
theorem list.nodup.attach {Î± : Type u} {l : list Î±} : l.nodup â†’ l.attach.nodup
theorem category_theory.limits.types.unique_of_type_equalizer {X Y Z : Type u} (f : X âŸ¶ Y) {g h : Y âŸ¶ Z} (w : f â‰« g = f â‰« h) (t : category_theory.limits.is_limit (category_theory.limits.fork.of_Î¹ f w)) (y : Y) (hy : g y = h y) : âˆƒ! (x : X), f x = y
theorem iterated_fderiv_succ_eq_comp_left {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {f : E â†’ F} {n : â„•} : iterated_fderiv ğ•œ (n + 1) f = â‡‘(continuous_multilinear_curry_left_equiv ğ•œ (Î» (i : fin (n + 1)), E) F) âˆ˜ fderiv ğ•œ (iterated_fderiv ğ•œ n f)
theorem is_GÎ´_Inter {Î± : Type u_1} {Î¹ : Type u_4} [topological_space Î±] [encodable Î¹] {s : Î¹ â†’ set Î±} (hs : âˆ€ (i : Î¹), is_GÎ´ (s i)) : is_GÎ´ (â‹‚ (i : Î¹), s i)
theorem matrix.det_mv_polynomial_X_ne_zero (m : Type u_1) (R : Type u_3) [decidable_eq m] [fintype m] [comm_ring R] [nontrivial R] : (matrix.mv_polynomial_X m m R).det â‰  0
theorem exists_embedding_euclidean_of_compact {E : Type uE} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] {H : Type uH} [topological_space H] {I : model_with_corners â„ E H} {M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] [t2_space M] [compact_space M] : âˆƒ (n : â„•) (e : M â†’ euclidean_space â„ (fin n)), smooth I (model_with_corners_self â„ (euclidean_space â„ (fin n))) e âˆ§ closed_embedding e âˆ§ âˆ€ (x : M), function.injective â‡‘(mfderiv I (model_with_corners_self â„ (euclidean_space â„ (fin n))) e x)
theorem sym2.card_image_off_diag {Î± : Type u_1} [decidable_eq Î±] (s : finset Î±) : (finset.image quotient.mk s.off_diag).card = s.card.choose 2
theorem category_theory.limits.has_colimit_of_coequalizer_and_coproduct {C : Type u} [category_theory.category C] {J : Type v} [category_theory.small_category J] (F : J â¥¤ C) [category_theory.limits.has_colimit (category_theory.discrete.functor F.obj)] [category_theory.limits.has_colimit (category_theory.discrete.functor (Î» (f : Î£ (p : J Ã— J), p.fst âŸ¶ p.snd), F.obj f.fst.fst))] [category_theory.limits.has_coequalizers C] : category_theory.limits.has_colimit F
theorem has_fpower_series_at.eq_zero {ğ•œ : Type u_1} {E : Type u_2} [nondiscrete_normed_field ğ•œ] [normed_group E] [normed_space ğ•œ E] {p : formal_multilinear_series ğ•œ ğ•œ E} {x : ğ•œ} (h : has_fpower_series_at 0 p x) : p = 0
theorem is_submonoid.inter {M : Type u_1} [monoid M] {sâ‚ sâ‚‚ : set M} (isâ‚ : is_submonoid sâ‚) (isâ‚‚ : is_submonoid sâ‚‚) : is_submonoid (sâ‚ âˆ© sâ‚‚)
theorem minpoly.aeval (A : Type u_1) {B : Type u_2} [comm_ring A] [ring B] [algebra A B] (x : B) : â‡‘(polynomial.aeval x) (minpoly A x) = 0
theorem finprod_mem_mul_diff {Î± : Type u_1} {M : Type u_5} [comm_monoid M] {f : Î± â†’ M} {s t : set Î±} (hst : s âŠ† t) (ht : t.finite) : finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), f i)) * finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ t  s), f i)) = finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ t), f i))
theorem eq_zero_of_mul_eq_self_left {Mâ‚€ : Type u_1} [cancel_monoid_with_zero Mâ‚€] {a b : Mâ‚€} (hâ‚ : b â‰  1) (hâ‚‚ : b * a = a) : a = 0
theorem right.inv_le_one_iff {Î± : Type u} [group Î±] [has_le Î±] [covariant_class Î± Î± (function.swap has_mul.mul) has_le.le] {a : Î±} : aâ»Â¹ â‰¤ 1 â†” 1 â‰¤ a
theorem finite_dimensional.finrank_zero_iff {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] : finite_dimensional.finrank K V = 0 â†” subsingleton V
theorem monoid_algebra.fg_of_finite_type {R : Type u_1} {M : Type u_2} [comm_monoid M] [comm_ring R] [nontrivial R] [h : algebra.finite_type R (monoid_algebra R M)] : monoid.fg M
theorem con.induction_onâ‚‚ {M : Type u_1} {N : Type u_2} [has_mul M] [has_mul N] {c : con M} {d : con N} {C : c.quotient â†’ d.quotient â†’ Prop} (p : c.quotient) (q : d.quotient) (H : âˆ€ (x : M) (y : N), C â†‘x â†‘y) : C p q
theorem metric.closed_ball_subset_cthickening {Î± : Type u_1} [pseudo_metric_space Î±] {x : Î±} {E : set Î±} (hx : x âˆˆ E) (Î´ : â„) : metric.closed_ball x Î´ âŠ† metric.cthickening Î´ E
theorem category_theory.paths.ext_functor {V : Type uâ‚} [quiver V] {C : Type u_1} [category_theory.category C] {F G : category_theory.paths V â¥¤ C} (h_obj : F.obj = G.obj) (h : âˆ€ (a b : V) (e : a âŸ¶ b), F.map e.to_path = category_theory.eq_to_hom _ â‰« G.map e.to_path â‰« category_theory.eq_to_hom _) : F = G
theorem convex.is_o_alternate_sum_square {E : Type u_1} {F : Type u_2} [normed_group E] [normed_space â„ E] [normed_group F] [normed_space â„ F] {s : set E} (s_conv : convex â„ s) {f : E â†’ F} {f' : E â†’ (E â†’L[â„] F)} {f'' : E â†’L[â„] E â†’L[â„] F} (hf : âˆ€ (x : E), x âˆˆ interior s â†’ has_fderiv_at f (f' x) x) {x : E} (xs : x âˆˆ s) (hx : has_fderiv_within_at f' f'' (interior s) x) {v w : E} (h4v : x + 4 â€¢ v âˆˆ interior s) (h4w : x + 4 â€¢ w âˆˆ interior s) : (Î» (h : â„), f (x + h â€¢ (2 â€¢ v + 2 â€¢ w)) + f (x + h â€¢ (v + w)) - f (x + h â€¢ (2 â€¢ v + w)) - f (x + h â€¢ (v + 2 â€¢ w)) - h ^ 2 â€¢ â‡‘(â‡‘f'' v) w) =o[nhds_within 0 (set.Ioi 0)] Î» (h : â„), h ^ 2
theorem is_cyclotomic_extension.rat.discr_prime_pow' {p : â„•+} {k : â„•} {K : Type u} [field K] [char_zero K] {Î¶ : K} [hp : fact (nat.prime â†‘p)] [is_cyclotomic_extension {p ^ k} â„š K] (hÎ¶ : is_primitive_root Î¶ â†‘(p ^ k)) : algebra.discr â„š â‡‘((is_primitive_root.sub_one_power_basis â„š hÎ¶).basis) = (-1) ^ ((â†‘p ^ k).totient / 2) * â†‘p ^ (â†‘p ^ (k - 1) * ((â†‘p - 1) * k - 1))
theorem continuous_linear_map.nnnorm_smul_right_apply {ğ•œ : Type u_1} {E : Type u_4} {Fâ‚— : Type u_7} [normed_group E] [normed_group Fâ‚—] [nondiscrete_normed_field ğ•œ] [normed_space ğ•œ E] [normed_space ğ•œ Fâ‚—] (c : E â†’L[ğ•œ] ğ•œ) (f : Fâ‚—) : âˆ¥c.smul_right fâˆ¥â‚Š = âˆ¥câˆ¥â‚Š * âˆ¥fâˆ¥â‚Š
theorem smul_mul_assoc {Î± : Type u_6} {Î² : Type u_7} [has_mul Î²] [has_scalar Î± Î²] [is_scalar_tower Î± Î² Î²] (r : Î±) (x y : Î²) : r â€¢ x * y = r â€¢ (x * y)
theorem category_theory.is_pullback.of_is_limit {C : Type uâ‚} [category_theory.category C] {X Y Z : C} {f : X âŸ¶ Z} {g : Y âŸ¶ Z} {c : category_theory.limits.pullback_cone f g} (h : category_theory.limits.is_limit c) : category_theory.is_pullback c.fst c.snd f g
theorem finsum_mem_comm {Î± : Type u_1} {Î² : Type u_2} {M : Type u_5} [add_comm_monoid M] {s : set Î±} {t : set Î²} (f : Î± â†’ Î² â†’ M) (hs : s.finite) (ht : t.finite) : finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), finsum (Î» (j : Î²), finsum (Î» (H : j âˆˆ t), f i j)))) = finsum (Î» (j : Î²), finsum (Î» (H : j âˆˆ t), finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), f i j))))
theorem pi.mul_single_commute {I : Type u} {f : I â†’ Type v} [decidable_eq I] [Î  (i : I), mul_one_class (f i)] : pairwise (Î» (i j : I), âˆ€ (x : f i) (y : f j), commute (pi.mul_single i x) (pi.mul_single j y))
theorem banach_steinhaus {E : Type u_1} {F : Type u_2} {ğ•œ : Type u_3} {ğ•œâ‚‚ : Type u_4} [semi_normed_group E] [semi_normed_group F] [nondiscrete_normed_field ğ•œ] [nondiscrete_normed_field ğ•œâ‚‚] [normed_space ğ•œ E] [normed_space ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} [ring_hom_isometric Ïƒâ‚â‚‚] {Î¹ : Type u_5} [complete_space E] {g : Î¹ â†’ (E â†’SL[Ïƒâ‚â‚‚] F)} (h : âˆ€ (x : E), âˆƒ (C : â„), âˆ€ (i : Î¹), âˆ¥â‡‘(g i) xâˆ¥ â‰¤ C) : âˆƒ (C' : â„), âˆ€ (i : Î¹), âˆ¥g iâˆ¥ â‰¤ C'
theorem category_theory.free_bicategory.normalize_naturality {B : Type u} [quiver B] {a b c : B} (p : quiver.path a b) {f g : category_theory.free_bicategory.hom b c} (Î· : f âŸ¶ g) : category_theory.bicategory.whisker_left ((category_theory.free_bicategory.preinclusion B).map {as := p}) Î· â‰« (category_theory.free_bicategory.normalize_iso p g).hom = (category_theory.free_bicategory.normalize_iso p f).hom â‰« (category_theory.free_bicategory.preinclusion B).mapâ‚‚ (category_theory.eq_to_hom _)
theorem algebraic_geometry.structure_sheaf.comap_id {R : Type u} [comm_ring R] (U V : topological_space.opens â†¥(algebraic_geometry.prime_spectrum.Top R)) (hUV : U = V) : algebraic_geometry.structure_sheaf.comap (ring_hom.id R) U V _ = category_theory.eq_to_hom _
theorem right.add_pos {Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b : Î±} (ha : 0 < a) (hb : 0 < b) : 0 < a + b
theorem submodule.fg_iff_finite_dimensional {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] (s : submodule K V) : s.fg â†” finite_dimensional K â†¥s
theorem finset.mem_shadow_iff {Î± : Type u_1} [decidable_eq Î±] {ğ’œ : finset (finset Î±)} {s : finset Î±} : s âˆˆ ğ’œ.shadow â†” âˆƒ (t : finset Î±) (H : t âˆˆ ğ’œ) (a : Î±) (H : a âˆˆ t), t.erase a = s
theorem metric.inf_dist_zero_of_mem {Î± : Type u} [pseudo_metric_space Î±] {s : set Î±} {x : Î±} (h : x âˆˆ s) : metric.inf_dist x s = 0
theorem category_theory.endofunctor.algebra.iso_of_iso {C : Type u} [category_theory.category C] {F : C â¥¤ C} {Aâ‚€ Aâ‚ : category_theory.endofunctor.algebra F} (f : Aâ‚€ âŸ¶ Aâ‚) [category_theory.is_iso f.f] : category_theory.is_iso f
theorem subgroup.closure_inductionâ‚‚ {G : Type u_1} [group G] {k : set G} {p : G â†’ G â†’ Prop} {x y : G} (hx : x âˆˆ subgroup.closure k) (hy : y âˆˆ subgroup.closure k) (Hk : âˆ€ (x : G), x âˆˆ k â†’ âˆ€ (y : G), y âˆˆ k â†’ p x y) (H1_left : âˆ€ (x : G), p 1 x) (H1_right : âˆ€ (x : G), p x 1) (Hmul_left : âˆ€ (xâ‚ xâ‚‚ y : G), p xâ‚ y â†’ p xâ‚‚ y â†’ p (xâ‚ * xâ‚‚) y) (Hmul_right : âˆ€ (x yâ‚ yâ‚‚ : G), p x yâ‚ â†’ p x yâ‚‚ â†’ p x (yâ‚ * yâ‚‚)) (Hinv_left : âˆ€ (x y : G), p x y â†’ p xâ»Â¹ y) (Hinv_right : âˆ€ (x y : G), p x y â†’ p x yâ»Â¹) : p x y
theorem Top.pullback_map_embedding_of_embeddings {W X Y Z S T : Top} (fâ‚ : W âŸ¶ S) (fâ‚‚ : X âŸ¶ S) (gâ‚ : Y âŸ¶ T) (gâ‚‚ : Z âŸ¶ T) {iâ‚ : W âŸ¶ Y} {iâ‚‚ : X âŸ¶ Z} (Hâ‚ : embedding â‡‘iâ‚) (Hâ‚‚ : embedding â‡‘iâ‚‚) (iâ‚ƒ : S âŸ¶ T) (eqâ‚ : fâ‚ â‰« iâ‚ƒ = iâ‚ â‰« gâ‚) (eqâ‚‚ : fâ‚‚ â‰« iâ‚ƒ = iâ‚‚ â‰« gâ‚‚) : embedding â‡‘(category_theory.limits.pullback.map fâ‚ fâ‚‚ gâ‚ gâ‚‚ iâ‚ iâ‚‚ iâ‚ƒ eqâ‚ eqâ‚‚)
theorem algebraic_geometry.PresheafedSpace.glue_data.snd_inv_app_t_app' {C : Type u} [category_theory.category C] (D : algebraic_geometry.PresheafedSpace.glue_data C) (i j k : D.to_glue_data.J) (U : topological_space.opens â†¥((category_theory.limits.pullback (D.to_glue_data.f i j) (D.to_glue_data.f i k)).carrier)) : âˆƒ (eq_1 : (topological_space.opens.map (D.to_glue_data.t k i).base).op.obj (opposite.op (_.open_functor.obj U)) = opposite.op (_.open_functor.obj (opposite.unop ((topological_space.opens.map (D.to_glue_data.t' k i j).base).op.obj (opposite.op U))))), _.inv_app U â‰« (D.to_glue_data.t k i).c.app (opposite.op (_.open_functor.obj U)) â‰« (D.to_glue_data.V (k, i)).presheaf.map (category_theory.eq_to_hom eq_1) = (D.to_glue_data.t' k i j).c.app (opposite.op U) â‰« _.inv_app (opposite.unop ((topological_space.opens.map (D.to_glue_data.t' k i j).base).op.obj (opposite.op U)))
theorem continuous_extend_from {X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] [regular_space Y] {f : X â†’ Y} {A : set X} (hA : dense A) (hf : âˆ€ (x : X), âˆƒ (y : Y), filter.tendsto f (nhds_within x A) (nhds y)) : continuous (extend_from A f)
theorem algebraic_geometry.PresheafedSpace.glue_data.snd_inv_app_t_app {C : Type u} [category_theory.category C] (D : algebraic_geometry.PresheafedSpace.glue_data C) (i j k : D.to_glue_data.J) (U : topological_space.opens â†¥((category_theory.limits.pullback (D.to_glue_data.f i j) (D.to_glue_data.f i k)).carrier)) : _.inv_app U â‰« (D.to_glue_data.t k i).c.app (opposite.op (_.open_functor.obj U)) = (D.to_glue_data.t' k i j).c.app (opposite.op U) â‰« _.inv_app (opposite.unop ((topological_space.opens.map (D.to_glue_data.t' k i j).base).op.obj (opposite.op U))) â‰« (D.to_glue_data.V (k, i)).presheaf.map (category_theory.eq_to_hom _)
theorem category_theory.presieve.is_sheaf_for_subsieve_aux {C : Type uâ‚} [category_theory.category C] {X : C} (P : Cáµ’áµ– â¥¤ Type w) {S : category_theory.sieve X} {R : category_theory.presieve X} (h : â‡‘S â‰¤ R) (hS : category_theory.presieve.is_sheaf_for P â‡‘S) (trans : âˆ€ â¦ƒY : Câ¦„ â¦ƒf : Y âŸ¶ Xâ¦„, R f â†’ category_theory.presieve.is_separated_for P â‡‘(category_theory.sieve.pullback f S)) : category_theory.presieve.is_sheaf_for P R
theorem is_add_regular.and_of_add_of_add {R : Type u_1} {a b : R} [add_semigroup R] (ab : is_add_regular (a + b)) (ba : is_add_regular (b + a)) : is_add_regular a âˆ§ is_add_regular b
theorem is_cyclotomic_extension.iff_adjoin_eq_top (S : set â„•+) (A : Type u) (B : Type v) [comm_ring A] [comm_ring B] [algebra A B] : is_cyclotomic_extension S A B â†” (âˆ€ (a : â„•+), a âˆˆ S â†’ (âˆƒ (r : B), â‡‘(polynomial.aeval r) (polynomial.cyclotomic â†‘a A) = 0)) âˆ§ algebra.adjoin A {b : B | âˆƒ (a : â„•+), a âˆˆ S âˆ§ b ^ â†‘a = 1} = âŠ¤
theorem holder_on_with.uniform_continuous_on {X : Type u_1} {Y : Type u_2} [pseudo_emetric_space X] [pseudo_emetric_space Y] {C r : nnreal} {f : X â†’ Y} {s : set X} (hf : holder_on_with C r f s) (h0 : 0 < r) : uniform_continuous_on f s
theorem lt_of_neg_lt_neg {Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b : Î±} : -a < -b â†’ b < a
theorem multiset.well_founded_lt {Î± : Type u_1} : well_founded has_lt.lt
theorem finprod_mem_image' {Î± : Type u_1} {Î² : Type u_2} {M : Type u_5} [comm_monoid M] {f : Î± â†’ M} {s : set Î²} {g : Î² â†’ Î±} (hg : set.inj_on g (s âˆ© function.mul_support (f âˆ˜ g))) : finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ g '' s), f i)) = finprod (Î» (j : Î²), finprod (Î» (H : j âˆˆ s), f (g j)))
theorem add_con.trans {M : Type u_1} [has_add M] (c : add_con M) {x y z : M} : â‡‘c x y â†’ â‡‘c y z â†’ â‡‘c x z
theorem orthonormal.sum_inner_products_le {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {Î¹ : Type u_4} (x : E) {v : Î¹ â†’ E} {s : finset Î¹} (hv : orthonormal ğ•œ v) : s.sum (Î» (i : Î¹), âˆ¥has_inner.inner (v i) xâˆ¥ ^ 2) â‰¤ âˆ¥xâˆ¥ ^ 2
theorem polynomial.C_eq_algebra_map {R : Type u} [comm_semiring R] (r : R) : â‡‘polynomial.C r = â‡‘(algebra_map R (polynomial R)) r
theorem order_ring_hom.subsingleton {Î± : Type u_2} {Î² : Type u_3} [linear_ordered_field Î±] [linear_ordered_field Î²] [archimedean Î²] : subsingleton (Î± â†’+*o Î²)
theorem nat.modeq.pow_totient {x n : â„•} (h : x.coprime n) : x ^ n.totient â‰¡ 1 [MOD n]
theorem function.periodic.interval_integral_add_eq {E : Type u_1} [normed_group E] [normed_space â„ E] [complete_space E] {f : â„ â†’ E} {T : â„} (hf : function.periodic f T) (t s : â„) : âˆ« (x : â„) in t..t + T, f x = âˆ« (x : â„) in s..s + T, f x
theorem not_bdd_below_iff' {Î± : Type u} [preorder Î±] {s : set Î±} : Â¬bdd_below s â†” âˆ€ (x : Î±), âˆƒ (y : Î±) (H : y âˆˆ s), Â¬x â‰¤ y
theorem euclidean_geometry.dist_sq_mul_dist_add_dist_sq_mul_dist {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] (a b c p : P) (h : euclidean_geometry.angle b p c = real.pi) : has_dist.dist a b ^ 2 * has_dist.dist c p + has_dist.dist a c ^ 2 * has_dist.dist b p = has_dist.dist b c * (has_dist.dist a p ^ 2 + has_dist.dist b p * has_dist.dist c p)
theorem filter.limsup_const_bot {Î± : Type u_1} {Î² : Type u_2} [complete_lattice Î±] {f : filter Î²} : f.limsup (Î» (x : Î²), âŠ¥) = âŠ¥
theorem con.coe_mul {M : Type u_1} [has_mul M] {c : con M} (x y : M) : â†‘(x * y) = â†‘x * â†‘y
theorem finset.prod_add {Î± : Type u} {Î² : Type v} [comm_semiring Î²] (f g : Î± â†’ Î²) (s : finset Î±) : s.prod (Î» (a : Î±), f a + g a) = s.powerset.sum (Î» (t : finset Î±), t.prod (Î» (a : Î±), f a) * (s  t).prod (Î» (a : Î±), g a))
theorem bernoulli'_odd_eq_zero {n : â„•} (h_odd : odd n) (hlt : 1 < n) : bernoulli' n = 0
theorem fin.succ_above_right_injective {n : â„•} {x : fin (n + 1)} : function.injective â‡‘(x.succ_above)
theorem first_order.language.Theory.is_satisfiable_iff_is_finitely_satisfiable {L : first_order.language} {T : L.Theory} : T.is_satisfiable â†” T.is_finitely_satisfiable
theorem measure_theory.integral_divergence_of_has_fderiv_within_at_off_countable' {E : Type u} [normed_group E] [normed_space â„ E] [complete_space E] {n : â„•} (a b : fin (n + 1) â†’ â„) (hle : a â‰¤ b) (f : fin (n + 1) â†’ (fin (n + 1) â†’ â„) â†’ E) (f' : fin (n + 1) â†’ (fin (n + 1) â†’ â„) â†’ ((fin (n + 1) â†’ â„) â†’L[â„] E)) (s : set (fin (n + 1) â†’ â„)) (hs : s.countable) (Hc : âˆ€ (i : fin (n + 1)), continuous_on (f i) (set.Icc a b)) (Hd : âˆ€ (x : fin (n + 1) â†’ â„), x âˆˆ set.univ.pi (Î» (i : fin (n + 1)), set.Ioo (a i) (b i))  s â†’ âˆ€ (i : fin (n + 1)), has_fderiv_at (f i) (f' i x) x) (Hi : measure_theory.integrable_on (Î» (x : fin (n + 1) â†’ â„), finset.univ.sum (Î» (i : fin (n + 1)), â‡‘(f' i x) (pi.single i 1))) (set.Icc a b) measure_theory.measure_space.volume) : âˆ« (x : fin (n + 1) â†’ â„) in set.Icc a b, finset.univ.sum (Î» (i : fin (n + 1)), â‡‘(f' i x) (pi.single i 1)) = finset.univ.sum (Î» (i : fin (n + 1)), (âˆ« (x : fin n â†’ â„) in set.Icc (a âˆ˜ â‡‘(i.succ_above)) (b âˆ˜ â‡‘(i.succ_above)), f i (i.insert_nth (b i) x)) - âˆ« (x : fin n â†’ â„) in set.Icc (a âˆ˜ â‡‘(i.succ_above)) (b âˆ˜ â‡‘(i.succ_above)), f i (i.insert_nth (a i) x))
theorem bilin_form.exists_orthogonal_basis {V : Type u} {K : Type v} [field K] [add_comm_group V] [module K V] [finite_dimensional K V] [hK : invertible 2] {B : bilin_form K V} (hBâ‚‚ : B.is_symm) : âˆƒ (v : basis (fin (finite_dimensional.finrank K V)) K V), B.is_Ortho â‡‘v
theorem euclidean_geometry.angle_le_pi {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] (p1 p2 p3 : P) : euclidean_geometry.angle p1 p2 p3 â‰¤ real.pi
theorem add_tsub_le_assoc {Î± : Type u_1} [preorder Î±] [add_comm_semigroup Î±] [has_sub Î±] [has_ordered_sub Î±] {a b c : Î±} [covariant_class Î± Î± has_add.add has_le.le] : a + b - c â‰¤ a + (b - c)
theorem orthonormal.oangle_neg_left {V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) {x y : V} (hx : x â‰  0) (hy : y â‰  0) : hb.oangle (-x) y = hb.oangle x y + â†‘real.pi
theorem sub_pos_of_lt {Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b : Î±} : b < a â†’ 0 < a - b
theorem cont_diff_on.comp' {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {G : Type u_4} [normed_group G] [normed_space ğ•œ G] {n : with_top â„•} {s : set E} {t : set F} {g : F â†’ G} {f : E â†’ F} (hg : cont_diff_on ğ•œ n g t) (hf : cont_diff_on ğ•œ n f s) : cont_diff_on ğ•œ n (g âˆ˜ f) (s âˆ© f â»Â¹' t)
theorem metric.inf_dist_nonneg {Î± : Type u} [pseudo_metric_space Î±] {s : set Î±} {x : Î±} : 0 â‰¤ metric.inf_dist x s
theorem is_topological_fiber_bundle.exists_trivialization_Icc_subset {B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z â†’ B} [topological_space Z] [conditionally_complete_linear_order B] [order_topology B] (h : is_topological_fiber_bundle F proj) (a b : B) : âˆƒ (e : topological_fiber_bundle.trivialization F proj), set.Icc a b âŠ† e.base_set
theorem divisor_chain.second_of_chain_is_irreducible {M : Type u_1} [cancel_comm_monoid_with_zero M] {q : associates M} {n : â„•} (hn : n â‰  0) {c : fin (n + 1) â†’ associates M} (hâ‚ : strict_mono c) (hâ‚‚ : âˆ€ {r : associates M}, r â‰¤ q â†” âˆƒ (i : fin (n + 1)), r = c i) (hq : q â‰  0) : irreducible (c 1)
theorem strict_mono.mul_monotone' {Î± : Type u_1} {Î² : Type u_2} [has_mul Î±] [preorder Î±] [preorder Î²] {f g : Î² â†’ Î±} [covariant_class Î± Î± has_mul.mul has_le.le] [covariant_class Î± Î± (function.swap has_mul.mul) has_lt.lt] (hf : strict_mono f) (hg : monotone g) : strict_mono (Î» (x : Î²), f x * g x)
theorem fin.succ_above_zero {n : â„•} : â‡‘(0.succ_above) = fin.succ
theorem polish_space.exists_nat_nat_continuous_surjective (Î± : Type u_1) [topological_space Î±] [polish_space Î±] [nonempty Î±] : âˆƒ (f : (â„• â†’ â„•) â†’ Î±), continuous f âˆ§ function.surjective f
theorem nat.multiplicative_factorization' {Î² : Type u_1} [comm_monoid Î²] (f : â„• â†’ Î²) (h_mult : âˆ€ (x y : â„•), x.coprime y â†’ f (x * y) = f x * f y) (hf0 : f 0 = 1) (hf1 : f 1 = 1) {n : â„•} : f n = n.factorization.prod (Î» (p k : â„•), f (p ^ k))
theorem polynomial.mul_eq_sum_sum {R : Type u} [semiring R] {p q : polynomial R} : p * q = p.support.sum (Î» (i : â„•), q.sum (Î» (j : â„•) (a : R), â‡‘(polynomial.monomial (i + j)) (p.coeff i * a)))
theorem tensor_product.ext {R : Type u_1} [comm_semiring R] {M : Type u_4} {N : Type u_5} {P : Type u_6} [add_comm_monoid M] [add_comm_monoid N] [add_comm_monoid P] [module R M] [module R N] [module R P] {g h : tensor_product R M N â†’â‚—[R] P} (H : (tensor_product.mk R M N).comprâ‚‚ g = (tensor_product.mk R M N).comprâ‚‚ h) : g = h
theorem iterated_fderiv_within_inter_open {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {s u : set E} {f : E â†’ F} {x : E} {n : â„•} (hu : is_open u) (hs : unique_diff_on ğ•œ (s âˆ© u)) (hx : x âˆˆ s âˆ© u) : iterated_fderiv_within ğ•œ n f (s âˆ© u) x = iterated_fderiv_within ğ•œ n f s x
theorem vitali_family.ae_eventually_measure_zero_of_singular {Î± : Type u_1} [metric_space Î±] {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (v : vitali_family Î¼) [sigma_compact_space Î±] [borel_space Î±] [measure_theory.is_locally_finite_measure Î¼] {Ï : measure_theory.measure Î±} [measure_theory.is_locally_finite_measure Ï] (hÏ : Ï.mutually_singular Î¼) : âˆ€áµ (x : Î±) âˆ‚Î¼, filter.tendsto (Î» (a : set Î±), â‡‘Ï a / â‡‘Î¼ a) (v.filter_at x) (nhds 0)
theorem set.image_image2_antidistrib_right {Î± : Type u_1} {Î±' : Type u_2} {Î² : Type u_3} {Î³ : Type u_5} {Î´ : Type u_7} {f : Î± â†’ Î² â†’ Î³} {s : set Î±} {t : set Î²} {g : Î³ â†’ Î´} {f' : Î² â†’ Î±' â†’ Î´} {g' : Î± â†’ Î±'} (h_antidistrib : âˆ€ (a : Î±) (b : Î²), g (f a b) = f' b (g' a)) : g '' set.image2 f s t = set.image2 f' t (g' '' s)
theorem lipschitz_on_with.of_dist_le_mul {Î± : Type u} {Î² : Type v} [pseudo_metric_space Î±] [pseudo_metric_space Î²] {K : nnreal} {s : set Î±} {f : Î± â†’ Î²} : (âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (y : Î±), y âˆˆ s â†’ has_dist.dist (f x) (f y) â‰¤ â†‘K * has_dist.dist x y) â†’ lipschitz_on_with K f s
theorem int.not_is_field  : Â¬is_field â„¤
theorem finset.le_prod_of_submultiplicative_on_pred {Î¹ : Type u_1} {M : Type u_4} {N : Type u_5} [comm_monoid M] [ordered_comm_monoid N] (f : M â†’ N) (p : M â†’ Prop) (h_one : f 1 = 1) (h_mul : âˆ€ (x y : M), p x â†’ p y â†’ f (x * y) â‰¤ f x * f y) (hp_mul : âˆ€ (x y : M), p x â†’ p y â†’ p (x * y)) (g : Î¹ â†’ M) {s : finset Î¹} (hs : âˆ€ (i : Î¹), i âˆˆ s â†’ p (g i)) : f (s.prod (Î» (i : Î¹), g i)) â‰¤ s.prod (Î» (i : Î¹), f (g i))
theorem is_local_max.fderiv_eq_zero {E : Type u} [normed_group E] [normed_space â„ E] {f : E â†’ â„} {a : E} (h : is_local_max f a) : fderiv â„ f a = 0
theorem has_lt.lt.eq_bot {Î± : Type u_1} [preorder Î±] [bounded_order Î±] [is_simple_order Î±] {a b : Î±} (h : a < b) : a = âŠ¥
theorem free_group.red.inv_of_red_of_ne {Î± : Type u} {Lâ‚ Lâ‚‚ : list (Î± Ã— bool)} {x1 : Î±} {b1 : bool} {x2 : Î±} {b2 : bool} (H1 : (x1, b1) â‰  (x2, b2)) (H2 : free_group.red ((x1, b1) :: Lâ‚) ((x2, b2) :: Lâ‚‚)) : free_group.red Lâ‚ ((x1, !b1) :: (x2, b2) :: Lâ‚‚)
theorem filter.has_basis.restrict {Î± : Type u_1} {Î¹ : Sort u_4} {l : filter Î±} {p : Î¹ â†’ Prop} {s : Î¹ â†’ set Î±} (h : l.has_basis p s) {q : Î¹ â†’ Prop} (hq : âˆ€ (i : Î¹), p i â†’ (âˆƒ (j : Î¹), p j âˆ§ q j âˆ§ s j âŠ† s i)) : l.has_basis (Î» (i : Î¹), p i âˆ§ q i) s
theorem category_theory.presheaf.is_sheaf_iff_is_sheaf_forget {C : Type uâ‚} [category_theory.category C] {A : Type uâ‚‚} [category_theory.category A] (J : category_theory.grothendieck_topology C) (P : Cáµ’áµ– â¥¤ A) [category_theory.limits.has_pullbacks C] (s : A â¥¤ Type (max vâ‚ uâ‚)) [category_theory.limits.has_limits A] [category_theory.limits.preserves_limits s] [category_theory.reflects_isomorphisms s] : category_theory.presheaf.is_sheaf J P â†” category_theory.presheaf.is_sheaf J (P â‹™ s)
theorem interval_integral.integral_pos_iff_support_of_nonneg_ae {f : â„ â†’ â„} {a b : â„} {Î¼ : measure_theory.measure â„} (hf : 0 â‰¤áµ[Î¼] f) (hfi : interval_integrable f Î¼ a b) : 0 < âˆ« (x : â„) in a..b, f x âˆ‚Î¼ â†” a < b âˆ§ 0 < â‡‘Î¼ (function.support f âˆ© set.Ioc a b)
theorem strict_mono_on.continuous_at_of_closure_image_mem_nhds {Î± : Type u_1} {Î² : Type u_2} [linear_order Î±] [topological_space Î±] [order_topology Î±] [linear_order Î²] [topological_space Î²] [order_topology Î²] [densely_ordered Î²] {f : Î± â†’ Î²} {s : set Î±} {a : Î±} (h_mono : strict_mono_on f s) (hs : s âˆˆ nhds a) (hfs : closure (f '' s) âˆˆ nhds (f a)) : continuous_at f a
theorem antitone.pairwise_disjoint_on_Ico_succ {Î± : Type u_1} {Î² : Type u_2} [linear_order Î±] [succ_order Î±] [preorder Î²] {f : Î± â†’ Î²} (hf : antitone f) : pairwise (disjoint on Î» (n : Î±), set.Ico (f (order.succ n)) (f n))
theorem category_theory.is_subterminal_of_mono_is_terminal_from {C : Type uâ‚} [category_theory.category C] {A T : C} (hT : category_theory.limits.is_terminal T) [category_theory.mono (hT.from A)] : category_theory.is_subterminal A
theorem measure_theory.forall_measure_preimage_mul_iff {G : Type u_1} [measurable_space G] [has_mul G] [has_measurable_mul G] (Î¼ : measure_theory.measure G) : (âˆ€ (g : G) (A : set G), measurable_set A â†’ â‡‘Î¼ ((Î» (h : G), g * h) â»Â¹' A) = â‡‘Î¼ A) â†” Î¼.is_mul_left_invariant
theorem dim_le_one_iff {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] : module.rank K V â‰¤ 1 â†” âˆƒ (vâ‚€ : V), âˆ€ (v : V), âˆƒ (r : K), r â€¢ vâ‚€ = v
theorem tsum_of_norm_bounded {Î¹ : Type u_1} {E : Type u_3} [semi_normed_group E] {f : Î¹ â†’ E} {g : Î¹ â†’ â„} {a : â„} (hg : has_sum g a) (h : âˆ€ (i : Î¹), âˆ¥f iâˆ¥ â‰¤ g i) : âˆ¥âˆ‘' (i : Î¹), f iâˆ¥ â‰¤ a
theorem exists_compact_mem_nhds {Î± : Type u} [topological_space Î±] [locally_compact_space Î±] (x : Î±) : âˆƒ (K : set Î±), is_compact K âˆ§ K âˆˆ nhds x
theorem convex.lipschitz_on_with_of_nnnorm_fderiv_le {E : Type u_1} [normed_group E] [normed_space â„ E] {ğ•œ : Type u_3} {G : Type u_4} [is_R_or_C ğ•œ] [normed_space ğ•œ E] [normed_group G] [normed_space ğ•œ G] {f : E â†’ G} {s : set E} {C : nnreal} (hf : âˆ€ (x : E), x âˆˆ s â†’ differentiable_at ğ•œ f x) (bound : âˆ€ (x : E), x âˆˆ s â†’ âˆ¥fderiv ğ•œ f xâˆ¥â‚Š â‰¤ C) (hs : convex â„ s) : lipschitz_on_with C f s
theorem iterated_deriv_within_eq_iterate {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {F : Type u_2} [normed_group F] [normed_space ğ•œ F] {n : â„•} {f : ğ•œ â†’ F} {s : set ğ•œ} {x : ğ•œ} (hs : unique_diff_on ğ•œ s) (hx : x âˆˆ s) : iterated_deriv_within n f s x = (Î» (g : ğ•œ â†’ F), deriv_within g s)^[n] f x
theorem cont_diff_at.add {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {x : E} {n : with_top â„•} {f g : E â†’ F} (hf : cont_diff_at ğ•œ n f x) (hg : cont_diff_at ğ•œ n g x) : cont_diff_at ğ•œ n (Î» (x : E), f x + g x) x
theorem exists_deriv_eq_zero' {f : â„ â†’ â„} {a b l : â„} (hab : a < b) (hfa : filter.tendsto f (nhds_within a (set.Ioi a)) (nhds l)) (hfb : filter.tendsto f (nhds_within b (set.Iio b)) (nhds l)) : âˆƒ (c : â„) (H : c âˆˆ set.Ioo a b), deriv f c = 0
theorem finset.sum_centroid_weights_indicator_eq_one_of_card_ne_zero (k : Type u_1) [division_ring k] {Î¹ : Type u_4} (s : finset Î¹) [char_zero k] [fintype Î¹] (h : s.card â‰  0) : finset.univ.sum (Î» (i : Î¹), finset.centroid_weights_indicator k s i) = 1
theorem composition_series.ext {X : Type u} [lattice X] [jordan_holder_lattice X] {sâ‚ sâ‚‚ : composition_series X} (h : âˆ€ (x : X), x âˆˆ sâ‚ â†” x âˆˆ sâ‚‚) : sâ‚ = sâ‚‚
theorem measure_theory.integrable_on_image_iff_integrable_on_abs_det_fderiv_smul {E : Type u_1} {F : Type u_2} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] [normed_group F] [normed_space â„ F] {s : set E} {f : E â†’ E} {f' : E â†’ (E â†’L[â„] E)} [measurable_space E] [borel_space E] (Î¼ : measure_theory.measure E) [Î¼.is_add_haar_measure] (hs : measurable_set s) (hf' : âˆ€ (x : E), x âˆˆ s â†’ has_fderiv_within_at f (f' x) s x) (hf : set.inj_on f s) (g : E â†’ F) : measure_theory.integrable_on g (f '' s) Î¼ â†” measure_theory.integrable_on (Î» (x : E), |(f' x).det| â€¢ g (f x)) s Î¼
theorem bounded_continuous_function.mem_Lp {Î± : Type u_1} {E : Type u_2} {m0 : measurable_space Î±} {p : ennreal} {Î¼ : measure_theory.measure Î±} [normed_group E] [topological_space Î±] [borel_space Î±] [second_countable_topology_either Î± E] [measure_theory.is_finite_measure Î¼] (f : bounded_continuous_function Î± E) : continuous_map.to_ae_eq_fun Î¼ f.to_continuous_map âˆˆ measure_theory.Lp E p Î¼
theorem orthonormal.inner_finsupp_eq_zero {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {Î¹ : Type u_4} {v : Î¹ â†’ E} (hv : orthonormal ğ•œ v) {s : set Î¹} {i : Î¹} (hi : i âˆ‰ s) {l : Î¹ â†’â‚€ ğ•œ} (hl : l âˆˆ finsupp.supported ğ•œ ğ•œ s) : has_inner.inner (â‡‘(finsupp.total Î¹ E ğ•œ v) l) (v i) = 0
theorem monoid_algebra.exists_finset_adjoin_eq_top {R : Type u_1} {M : Type u_2} [comm_ring R] [comm_monoid M] [h : algebra.finite_type R (monoid_algebra R M)] : âˆƒ (G : finset M), algebra.adjoin R (â‡‘(monoid_algebra.of R M) '' â†‘G) = âŠ¤
theorem list.nth_zero_mul_tail_prod {M : Type u_3} [monoid M] (l : list M) : (l.nth 0).get_or_else 1 * l.tail.prod = l.prod
theorem isometry.uniform_embedding {Î± : Type u} {Î² : Type v} [emetric_space Î±] [pseudo_emetric_space Î²] {f : Î± â†’ Î²} (hf : isometry f) : uniform_embedding f
theorem ratfunc.eval_mul {K : Type u} [hfield : field K] {L : Type u_1} [field L] (f : K â†’+* L) (a : L) {x y : ratfunc K} (hx : polynomial.evalâ‚‚ f a x.denom â‰  0) (hy : polynomial.evalâ‚‚ f a y.denom â‰  0) : ratfunc.eval f a (x * y) = ratfunc.eval f a x * ratfunc.eval f a y
theorem Top.stalk_to_fiber_injective {X : Top} {T : â†¥X â†’ Type v} (P : Top.local_predicate T) (x : â†¥X) (w : âˆ€ (U V : topological_space.open_nhds x) (fU : Î  (y : â†¥(U.val)), T â†‘y), P.to_prelocal_predicate.pred fU â†’ âˆ€ (fV : Î  (y : â†¥(V.val)), T â†‘y), P.to_prelocal_predicate.pred fV â†’ fU âŸ¨x, _âŸ© = fV âŸ¨x, _âŸ© â†’ (âˆƒ (W : topological_space.open_nhds x) (iU : W âŸ¶ U) (iV : W âŸ¶ V), âˆ€ (w : â†¥(W.val)), fU (â‡‘iU w) = fV (â‡‘iV w))) : function.injective (Top.stalk_to_fiber P x)
theorem left.one_lt_mul_of_lt_of_le {Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a b : Î±} (ha : 1 < a) (hb : 1 â‰¤ b) : 1 < a * b
theorem power_series.order_one {R : Type u_1} [semiring R] [nontrivial R] : 1.order = 0
theorem category_theory.idempotents.karoubi.decomp_id {C : Type u_1} [category_theory.category C] (P : category_theory.idempotents.karoubi C) : ğŸ™ P = P.decomp_id_i â‰« P.decomp_id_p
theorem vector.last_def {n : â„•} {Î± : Type u_1} {v : vector Î± (n + 1)} : v.last = v.nth (fin.last n)
theorem dense_inducing.prod {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} {Î´ : Type u_4} [topological_space Î±] [topological_space Î²] [topological_space Î³] [topological_space Î´] {eâ‚ : Î± â†’ Î²} {eâ‚‚ : Î³ â†’ Î´} (deâ‚ : dense_inducing eâ‚) (deâ‚‚ : dense_inducing eâ‚‚) : dense_inducing (Î» (p : Î± Ã— Î³), (eâ‚ p.fst, eâ‚‚ p.snd))
theorem is_bounded_bilinear_map_smul_right {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] : is_bounded_bilinear_map ğ•œ (Î» (p : (E â†’L[ğ•œ] ğ•œ) Ã— F), p.fst.smul_right p.snd)
theorem refinement_of_locally_compact_sigma_compact_of_nhds_basis_set {X : Type v} [topological_space X] [locally_compact_space X] [sigma_compact_space X] [t2_space X] {Î¹ : X â†’ Type u} {p : Î  (x : X), Î¹ x â†’ Prop} {B : Î  (x : X), Î¹ x â†’ set X} {s : set X} (hs : is_closed s) (hB : âˆ€ (x : X), x âˆˆ s â†’ (nhds x).has_basis (p x) (B x)) : âˆƒ (Î± : Type v) (c : Î± â†’ X) (r : Î  (a : Î±), Î¹ (c a)), (âˆ€ (a : Î±), c a âˆˆ s âˆ§ p (c a) (r a)) âˆ§ (s âŠ† â‹ƒ (a : Î±), B (c a) (r a)) âˆ§ locally_finite (Î» (a : Î±), B (c a) (r a))
theorem cardinal.le_range_of_union_finset_eq_top {Î± : Type u_1} {Î² : Type u_2} [infinite Î²] (f : Î± â†’ finset Î²) (w : (â‹ƒ (a : Î±), â†‘(f a)) = âŠ¤) : cardinal.mk Î² â‰¤ cardinal.mk â†¥(set.range f)
theorem measure_theory.conservative.ae_mem_imp_frequently_image_mem {Î± : Type u_2} [measurable_space Î±] {f : Î± â†’ Î±} {s : set Î±} {Î¼ : measure_theory.measure Î±} (hf : measure_theory.conservative f Î¼) (hs : measurable_set s) : âˆ€áµ (x : Î±) âˆ‚Î¼, x âˆˆ s â†’ (âˆƒá¶  (n : â„•) in filter.at_top, f^[n] x âˆˆ s)
theorem linear_map.adjoint_adjoint {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] [inner_product_space ğ•œ F] [finite_dimensional ğ•œ E] [finite_dimensional ğ•œ F] (A : E â†’â‚—[ğ•œ] F) : â‡‘linear_map.adjoint (â‡‘linear_map.adjoint A) = A
theorem mdifferentiable_on_iff_differentiable_on {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {E' : Type u_3} [normed_group E'] [normed_space ğ•œ E'] {f : E â†’ E'} {s : set E} : mdifferentiable_on (model_with_corners_self ğ•œ E) (model_with_corners_self ğ•œ E') f s â†” differentiable_on ğ•œ f s
theorem list.Ico.trichotomy (n a b : â„•) : n < a âˆ¨ b â‰¤ n âˆ¨ n âˆˆ list.Ico a b
theorem monotone.covariant_of_const {M : Type u_1} {N : Type u_2} {Î¼ : M â†’ N â†’ N} {Î± : Type u_3} [preorder Î±] [preorder N] {f : N â†’ Î±} [covariant_class M N Î¼ has_le.le] (hf : monotone f) (m : M) : monotone (Î» (n : N), f (Î¼ m n))
theorem pseudo_metric_space.ext {Î± : Type u_1} {m m' : pseudo_metric_space Î±} (h : pseudo_metric_space.to_has_dist = pseudo_metric_space.to_has_dist) : m = m'
theorem vitali_family.with_density_le_mul {Î± : Type u_1} [metric_space Î±] {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (v : vitali_family Î¼) [sigma_compact_space Î±] [borel_space Î±] [measure_theory.is_locally_finite_measure Î¼] {Ï : measure_theory.measure Î±} [measure_theory.is_locally_finite_measure Ï] (hÏ : Ï.absolutely_continuous Î¼) {s : set Î±} (hs : measurable_set s) {t : nnreal} (ht : 1 < t) : â‡‘(Î¼.with_density (v.lim_ratio_meas hÏ)) s â‰¤ â†‘t ^ 2 * â‡‘Ï s
theorem cont_diff_at.snd {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {G : Type u_4} [normed_group G] [normed_space ğ•œ G] {n : with_top â„•} {f : E â†’ F Ã— G} {x : E} (hf : cont_diff_at ğ•œ n f x) : cont_diff_at ğ•œ n (Î» (x : E), (f x).snd) x
theorem summable_condensed_iff_of_nonneg {f : â„• â†’ â„} (h_nonneg : âˆ€ (n : â„•), 0 â‰¤ f n) (h_mono : âˆ€ â¦ƒm n : â„•â¦„, 0 < m â†’ m â‰¤ n â†’ f n â‰¤ f m) : summable (Î» (k : â„•), 2 ^ k * f (2 ^ k)) â†” summable f
theorem euclidean_geometry.angle_eq_angle_of_angle_eq_pi_of_angle_eq_pi {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {p1 p2 p3 p4 p5 : P} (hapc : euclidean_geometry.angle p1 p5 p3 = real.pi) (hbpd : euclidean_geometry.angle p2 p5 p4 = real.pi) : euclidean_geometry.angle p1 p5 p2 = euclidean_geometry.angle p3 p5 p4
theorem riesz_extension.step {E : Type u_2} [add_comm_group E] [module â„ E] (s : convex_cone â„ E) (f : linear_pmap â„ E â„) (nonneg : âˆ€ (x : â†¥(f.domain)), â†‘x âˆˆ s â†’ 0 â‰¤ â‡‘f x) (dense : âˆ€ (y : E), âˆƒ (x : â†¥(f.domain)), â†‘x + y âˆˆ s) (hdom : f.domain â‰  âŠ¤) : âˆƒ (g : linear_pmap â„ E â„), f < g âˆ§ âˆ€ (x : â†¥(g.domain)), â†‘x âˆˆ s â†’ 0 â‰¤ â‡‘g x
theorem ring_equiv.to_monoid_hom_commutes {R : Type u_4} {S : Type u_5} [non_assoc_semiring R] [non_assoc_semiring S] (f : R â‰ƒ+* S) : â†‘f.to_monoid_hom = â†‘f.to_monoid_hom
theorem category_theory.over.construct_products.over_finite_products_of_finite_wide_pullbacks {C : Type u} [category_theory.category C] [category_theory.limits.has_finite_wide_pullbacks C] {B : C} : category_theory.limits.has_finite_products (category_theory.over B)
theorem bounded_continuous_function.norm_eq {Î± : Type u} {Î² : Type v} [topological_space Î±] [semi_normed_group Î²] (f : bounded_continuous_function Î± Î²) : âˆ¥fâˆ¥ = has_Inf.Inf {C : â„ | 0 â‰¤ C âˆ§ âˆ€ (x : Î±), âˆ¥â‡‘f xâˆ¥ â‰¤ C}
theorem vitali_family.ae_tendsto_measure_inter_div {Î± : Type u_1} [metric_space Î±] {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (v : vitali_family Î¼) [sigma_compact_space Î±] [borel_space Î±] [measure_theory.is_locally_finite_measure Î¼] (s : set Î±) : âˆ€áµ (x : Î±) âˆ‚Î¼.restrict s, filter.tendsto (Î» (a : set Î±), â‡‘Î¼ (s âˆ© a) / â‡‘Î¼ a) (v.filter_at x) (nhds 1)
theorem dist_le_of_le_geometric_two_of_tendstoâ‚€ {Î± : Type u_1} [pseudo_metric_space Î±] (C : â„) {f : â„• â†’ Î±} (huâ‚‚ : âˆ€ (n : â„•), has_dist.dist (f n) (f (n + 1)) â‰¤ C / 2 / 2 ^ n) {a : Î±} (ha : filter.tendsto f filter.at_top (nhds a)) : has_dist.dist (f 0) a â‰¤ C
theorem tangent_cone_inter_nhds {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {x : E} {s t : set E} (ht : t âˆˆ nhds x) : tangent_cone_at ğ•œ (s âˆ© t) x = tangent_cone_at ğ•œ s x
theorem metric.exists_dist_lt_of_Hausdorff_dist_lt' {Î± : Type u} [pseudo_metric_space Î±] {s t : set Î±} {y : Î±} {r : â„} (h : y âˆˆ t) (H : metric.Hausdorff_dist s t < r) (fin : emetric.Hausdorff_edist s t â‰  âŠ¤) : âˆƒ (x : Î±) (H : x âˆˆ s), has_dist.dist x y < r
theorem category_theory.epi_of_nonzero_to_simple {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_equalizers C] {X Y : C} [category_theory.simple Y] {f : X âŸ¶ Y} [category_theory.limits.has_image f] (w : f â‰  0) : category_theory.epi f
theorem asymptotics.is_o.norm_norm {Î± : Type u_1} {E' : Type u_6} {F' : Type u_7} [semi_normed_group E'] [semi_normed_group F'] {f' : Î± â†’ E'} {g' : Î± â†’ F'} {l : filter Î±} : f' =o[l] g' â†’ ((Î» (x : Î±), âˆ¥f' xâˆ¥) =o[l] Î» (x : Î±), âˆ¥g' xâˆ¥)
theorem dfinsupp.lhom_ext' {Î¹ : Type u_1} {R : Type u_2} {M : Î¹ â†’ Type u_4} {N : Type u_5} [dec_Î¹ : decidable_eq Î¹] [semiring R] [Î  (i : Î¹), add_comm_monoid (M i)] [Î  (i : Î¹), module R (M i)] [add_comm_monoid N] [module R N] â¦ƒÏ† Ïˆ : (Î â‚€ (i : Î¹), M i) â†’â‚—[R] Nâ¦„ (h : âˆ€ (i : Î¹), Ï†.comp (dfinsupp.lsingle i) = Ïˆ.comp (dfinsupp.lsingle i)) : Ï† = Ïˆ
theorem cont_mdiff.cont_mdiff_tangent_map {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {M : Type u_4} [topological_space M] [charted_space H M] [Is : smooth_manifold_with_corners I M] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners ğ•œ E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] [I's : smooth_manifold_with_corners I' M'] {f : M â†’ M'} {m n : with_top â„•} (hf : cont_mdiff I I' n f) (hmn : m + 1 â‰¤ n) : cont_mdiff I.tangent I'.tangent m (tangent_map I I' f)
theorem quaternion_group.order_of_a {n : â„•} [fact (0 < n)] (i : zmod (2 * n)) : order_of (quaternion_group.a i) = 2 * n / (2 * n).gcd i.val
theorem affine.simplex.sum_centroid_weights_with_circumcenter {n : â„•} {fs : finset (fin (n + 1))} (h : fs.nonempty) : finset.univ.sum (Î» (i : affine.simplex.points_with_circumcenter_index n), affine.simplex.centroid_weights_with_circumcenter fs i) = 1
theorem add_con.le_def {M : Type u_1} [has_add M] {c d : add_con M} : c â‰¤ d â†” âˆ€ {x y : M}, â‡‘c x y â†’ â‡‘d x y
theorem is_monoid_hom.id {Î± : Type u} [mul_one_class Î±] : is_monoid_hom id
theorem finite_dimensional_of_is_compact_closed_ballâ‚€ (ğ•œ : Type u) [nondiscrete_normed_field ğ•œ] {E : Type v} [normed_group E] [normed_space ğ•œ E] [complete_space ğ•œ] {r : â„} (rpos : 0 < r) (h : is_compact (metric.closed_ball 0 r)) : finite_dimensional ğ•œ E
theorem lt_cSup_of_lt {Î± : Type u_1} [conditionally_complete_lattice Î±] {s : set Î±} {a b : Î±} (hs : bdd_above s) (ha : a âˆˆ s) (h : b < a) : b < has_Sup.Sup s
theorem multilinear_map.dom_coprod_alternization {Î¹a : Type u_7} {Î¹b : Type u_8} [decidable_eq Î¹a] [decidable_eq Î¹b] [fintype Î¹a] [fintype Î¹b] {R' : Type u_9} {Máµ¢ : Type u_10} {Nâ‚ : Type u_11} {Nâ‚‚ : Type u_12} [comm_semiring R'] [add_comm_group Nâ‚] [module R' Nâ‚] [add_comm_group Nâ‚‚] [module R' Nâ‚‚] [add_comm_monoid Máµ¢] [module R' Máµ¢] (a : multilinear_map R' (Î» (_x : Î¹a), Máµ¢) Nâ‚) (b : multilinear_map R' (Î» (_x : Î¹b), Máµ¢) Nâ‚‚) : â‡‘multilinear_map.alternatization (a.dom_coprod b) = (â‡‘multilinear_map.alternatization a).dom_coprod (â‡‘multilinear_map.alternatization b)
theorem pgame.add_zero_equiv (x : pgame) : (x + 0).equiv x
theorem strong_rank_condition_iff_succ (R : Type u) [semiring R] : strong_rank_condition R â†” âˆ€ (n : â„•) (f : (fin (n + 1) â†’ R) â†’â‚—[R] fin n â†’ R), Â¬function.injective â‡‘f
theorem padic_norm.padic_norm_p_of_prime (p : â„•) [fact (nat.prime p)] : padic_norm p â†‘p = 1 / â†‘p
theorem matrix.mul_inv_of_self {n : Type u'} {Î± : Type v} [fintype n] [decidable_eq n] [comm_ring Î±] (A : matrix n n Î±) [invertible A] : A.mul (â…Ÿ A) = 1
theorem uv.card_compress {Î± : Type u_1} [decidable_eq Î±] {U V : finset Î±} (hUV : U.card = V.card) (A : finset Î±) : (uv.compress U V A).card = A.card
theorem laurent_polynomial.C_eq_algebra_map {R : Type u_1} [comm_semiring R] (r : R) : â‡‘laurent_polynomial.C r = â‡‘(algebra_map R (laurent_polynomial R)) r
theorem eq_vadd_iff_vsub_eq {G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] (p1 : P) (g : G) (p2 : P) : p1 = g +áµ¥ p2 â†” p1 -áµ¥ p2 = g
theorem algebra.is_integral_trans {R : Type u_1} {A : Type u_2} {B : Type u_3} [comm_ring R] [comm_ring A] [comm_ring B] [algebra A B] [algebra R B] [algebra R A] [is_scalar_tower R A B] (hA : algebra.is_integral R A) (hB : algebra.is_integral A B) : algebra.is_integral R B
theorem set.Union_Inter_of_monotone {Î¹ : Type u_1} {Î¹' : Type u_2} {Î± : Type u_3} [fintype Î¹] [preorder Î¹'] [is_directed Î¹' has_le.le] [nonempty Î¹'] {s : Î¹ â†’ Î¹' â†’ set Î±} (hs : âˆ€ (i : Î¹), monotone (s i)) : (â‹ƒ (j : Î¹'), â‹‚ (i : Î¹), s i j) = â‹‚ (i : Î¹), â‹ƒ (j : Î¹'), s i j
theorem mv_polynomial.map_left_inverse {R : Type u} {Sâ‚ : Type v} {Ïƒ : Type u_1} [comm_semiring R] [comm_semiring Sâ‚] {f : R â†’+* Sâ‚} {g : Sâ‚ â†’+* R} (hf : function.left_inverse â‡‘f â‡‘g) : function.left_inverse â‡‘(mv_polynomial.map f) â‡‘(mv_polynomial.map g)
theorem category_theory.limits.has_colimit.of_cocones_iso {J : Type uâ‚} [category_theory.category J] {C : Type u} [category_theory.category C] {K : Type uâ‚} [category_theory.category K] (F : J â¥¤ C) (G : K â¥¤ C) (h : F.cocones â‰… G.cocones) [category_theory.limits.has_colimit F] : category_theory.limits.has_colimit G
theorem set.finite.nmem_hyperfilter {Î± : Type u} [infinite Î±] {s : set Î±} (hf : s.finite) : s âˆ‰ filter.hyperfilter Î±
theorem left.mul_le_one {Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a b : Î±} (ha : a â‰¤ 1) (hb : b â‰¤ 1) : a * b â‰¤ 1
theorem monoid_hom.is_of_fin_order {G : Type u} [monoid G] {H : Type v} [monoid H] (f : G â†’* H) {x : G} (h : is_of_fin_order x) : is_of_fin_order (â‡‘f x)
theorem filter.tendsto.uniformity_symm {Î± : Type u_1} {Î² : Type u_2} [uniform_space Î±] {l : filter Î²} {f : Î² â†’ Î± Ã— Î±} (h : filter.tendsto f l (uniformity Î±)) : filter.tendsto (Î» (x : Î²), ((f x).snd, (f x).fst)) l (uniformity Î±)
theorem filter.mapâ‚‚_map_left_anticomm {Î± : Type u_1} {Î±' : Type u_2} {Î² : Type u_3} {Î³ : Type u_5} {Î´ : Type u_7} {f : filter Î±} {g : filter Î²} {m : Î±' â†’ Î² â†’ Î³} {n : Î± â†’ Î±'} {m' : Î² â†’ Î± â†’ Î´} {n' : Î´ â†’ Î³} (h_left_anticomm : âˆ€ (a : Î±) (b : Î²), m (n a) b = n' (m' b a)) : filter.mapâ‚‚ m (filter.map n f) g = filter.map n' (filter.mapâ‚‚ m' g f)
theorem int.units_pow_two (u : â„¤Ë£) : u ^ 2 = 1
theorem compact_open_separated_add_right {G : Type w} [topological_space G] [add_group G] [topological_add_group G] {K U : set G} (hK : is_compact K) (hU : is_open U) (hKU : K âŠ† U) : âˆƒ (V : set G) (H : V âˆˆ nhds 0), K + V âŠ† U
theorem is_nilpotent_of_finite_tfae {G : Type u_1} [hG : group G] [hf : fintype G] : [group.is_nilpotent G, normalizer_condition G, âˆ€ (H : subgroup G), is_coatom H â†’ H.normal, âˆ€ (p : â„•), fact (nat.prime p) â†’ âˆ€ (P : sylow p G), â†‘P.normal, nonempty ((Î  (p : â†¥((fintype.card G).factorization.support)) (P : sylow â†‘p G), â†¥â†‘P) â‰ƒ* G)].tfae
theorem measure_theory.tendsto_set_to_fun_filter_of_dominated_convergence {Î± : Type u_1} {E : Type u_2} {F : Type u_3} [normed_group E] [normed_space â„ E] [normed_group F] [normed_space â„ F] {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [complete_space F] {T : set Î± â†’ (E â†’L[â„] F)} {C : â„} (hT : measure_theory.dominated_fin_meas_additive Î¼ T C) {Î¹ : Type u_4} {l : filter Î¹} [l.is_countably_generated] {fs : Î¹ â†’ Î± â†’ E} {f : Î± â†’ E} (bound : Î± â†’ â„) (hfs_meas : âˆ€á¶  (n : Î¹) in l, measure_theory.ae_strongly_measurable (fs n) Î¼) (h_bound : âˆ€á¶  (n : Î¹) in l, âˆ€áµ (a : Î±) âˆ‚Î¼, âˆ¥fs n aâˆ¥ â‰¤ bound a) (bound_integrable : measure_theory.integrable bound Î¼) (h_lim : âˆ€áµ (a : Î±) âˆ‚Î¼, filter.tendsto (Î» (n : Î¹), fs n a) l (nhds (f a))) : filter.tendsto (Î» (n : Î¹), measure_theory.set_to_fun Î¼ T hT (fs n)) l (nhds (measure_theory.set_to_fun Î¼ T hT f))
theorem ordinal.log_nonempty {b x : ordinal} (h : 1 < b) : {o : ordinal | x < b ^ o}.nonempty
theorem nat.prime.sq_add_sq {p : â„•} [fact (nat.prime p)] (hp : p % 4 = 1) : âˆƒ (a b : â„•), a ^ 2 + b ^ 2 = p
theorem continuous.surjective {Î± : Type u} [conditionally_complete_linear_order Î±] [topological_space Î±] [order_topology Î±] [densely_ordered Î±] {Î´ : Type u_1} [linear_order Î´] [topological_space Î´] [order_closed_topology Î´] {f : Î± â†’ Î´} (hf : continuous f) (h_top : filter.tendsto f filter.at_top filter.at_top) (h_bot : filter.tendsto f filter.at_bot filter.at_bot) : function.surjective f
theorem phragmen_lindelof.eq_on_quadrant_II {E : Type u_1} [normed_group E] [normed_space â„‚ E] {f g : â„‚ â†’ E} (hdf : diff_cont_on_cl â„‚ f (set.Iio 0 Ã—â„‚ set.Ioi 0)) (hBf : âˆƒ (c : â„) (H : c < 2) (B : â„), f =O[filter.comap complex.abs filter.at_top âŠ“ filter.principal (set.Iio 0 Ã—â„‚ set.Ioi 0)] Î» (z : â„‚), real.exp (B * complex.abs z ^ c)) (hdg : diff_cont_on_cl â„‚ g (set.Iio 0 Ã—â„‚ set.Ioi 0)) (hBg : âˆƒ (c : â„) (H : c < 2) (B : â„), g =O[filter.comap complex.abs filter.at_top âŠ“ filter.principal (set.Iio 0 Ã—â„‚ set.Ioi 0)] Î» (z : â„‚), real.exp (B * complex.abs z ^ c)) (hre : âˆ€ (x : â„), x â‰¤ 0 â†’ f â†‘x = g â†‘x) (him : âˆ€ (x : â„), 0 â‰¤ x â†’ f (â†‘x * complex.I) = g (â†‘x * complex.I)) : set.eq_on f g {z : â„‚ | z.re â‰¤ 0 âˆ§ 0 â‰¤ z.im}
theorem polynomial.map_alg_eq_map {R : Type u} [comm_semiring R] {S : Type v} [semiring S] [algebra R S] (p : polynomial R) : â‡‘(polynomial.map_alg R S) p = polynomial.map (algebra_map R S) p
theorem finset.sum_smul_const_vsub_eq_sub_weighted_vsub_of_point {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {Î¹ : Type u_4} (s : finset Î¹) (w : Î¹ â†’ k) (pâ‚‚ : Î¹ â†’ P) (pâ‚ b : P) : s.sum (Î» (i : Î¹), w i â€¢ (pâ‚ -áµ¥ pâ‚‚ i)) = s.sum (Î» (i : Î¹), w i) â€¢ (pâ‚ -áµ¥ b) - â‡‘(s.weighted_vsub_of_point pâ‚‚ b) w
theorem commute.symm {S : Type u_1} [has_mul S] {a b : S} (h : commute a b) : commute b a
theorem emetric.mk_uniformity_basis {Î± : Type u} [pseudo_emetric_space Î±] {Î² : Type u_1} {p : Î² â†’ Prop} {f : Î² â†’ ennreal} (hfâ‚€ : âˆ€ (x : Î²), p x â†’ 0 < f x) (hf : âˆ€ (Îµ : ennreal), 0 < Îµ â†’ (âˆƒ (x : Î²) (hx : p x), f x â‰¤ Îµ)) : (uniformity Î±).has_basis p (Î» (x : Î²), {p : Î± Ã— Î± | has_edist.edist p.fst p.snd < f x})
theorem polynomial.leading_coeff_multiset_prod' {R : Type u} [comm_semiring R] (t : multiset (polynomial R)) (h : (multiset.map polynomial.leading_coeff t).prod â‰  0) : t.prod.leading_coeff = (multiset.map polynomial.leading_coeff t).prod
theorem convex_cone.ext'_iff {ğ•œ : Type u_1} {E : Type u_2} [ordered_semiring ğ•œ] [add_comm_monoid E] [has_scalar ğ•œ E] {S T : convex_cone ğ•œ E} : â†‘S = â†‘T â†” S = T
theorem pgame.lf.trans_lt {x y z : pgame} (hâ‚ : x.lf y) (hâ‚‚ : y < z) : x.lf z
theorem affine.simplex.reflection_circumcenter_eq_affine_combination_of_points_with_circumcenter {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {n : â„•} (s : affine.simplex â„ P n) {iâ‚ iâ‚‚ : fin (n + 1)} (h : iâ‚ â‰  iâ‚‚) : â‡‘(euclidean_geometry.reflection (affine_span â„ (s.points '' {iâ‚, iâ‚‚}))) s.circumcenter = â‡‘(finset.univ.affine_combination s.points_with_circumcenter) (affine.simplex.reflection_circumcenter_weights_with_circumcenter iâ‚ iâ‚‚)
theorem category_theory.is_iso_of_regular_epi_of_mono {C : Type uâ‚} [category_theory.category C] {X Y : C} (f : X âŸ¶ Y) [category_theory.regular_epi f] [m : category_theory.mono f] : category_theory.is_iso f
theorem measure_theory.is_clopenable_iff_measurable_set {Î³ : Type u_3} [tÎ³ : topological_space Î³] [polish_space Î³] [measurable_space Î³] [borel_space Î³] {s : set Î³} : polish_space.is_clopenable s â†” measurable_set s
theorem comap_coe_Ioo_nhds_within_Ioi {Î± : Type u} [topological_space Î±] [linear_order Î±] [order_topology Î±] [densely_ordered Î±] (a b : Î±) : filter.comap coe (nhds_within a (set.Ioi a)) = filter.at_bot
theorem is_cyclotomic_extension.splits_cyclotomic (n : â„•+) (S : set â„•+) (K : Type w) (L : Type z) [field K] [field L] [algebra K L] [ne_zero â†‘â†‘n] [is_cyclotomic_extension S K L] (hS : n âˆˆ S) : polynomial.splits (algebra_map K L) (polynomial.cyclotomic â†‘n K)
theorem is_dedekind_domain.height_one_spectrum.int_valuation.map_mul' {R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] (v : is_dedekind_domain.height_one_spectrum R) (x y : R) : v.int_valuation_def (x * y) = v.int_valuation_def x * v.int_valuation_def y
theorem mem_omega_limit_iff_frequently {Ï„ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [topological_space Î²] (f : filter Ï„) (Ï• : Ï„ â†’ Î± â†’ Î²) (s : set Î±) (y : Î²) : y âˆˆ omega_limit f Ï• s â†” âˆ€ (n : set Î²), n âˆˆ nhds y â†’ (âˆƒá¶  (t : Ï„) in f, (s âˆ© Ï• t â»Â¹' n).nonempty)
theorem lower_semicontinuous_within_at.add {Î± : Type u_1} [topological_space Î±] {x : Î±} {s : set Î±} {Î³ : Type u_4} [linear_ordered_add_comm_monoid Î³] [topological_space Î³] [order_topology Î³] [has_continuous_add Î³] {f g : Î± â†’ Î³} (hf : lower_semicontinuous_within_at f s x) (hg : lower_semicontinuous_within_at g s x) : lower_semicontinuous_within_at (Î» (z : Î±), f z + g z) s x
theorem has_sum_cauchy_power_series_integral {E : Type u_1} [normed_group E] [normed_space â„‚ E] [complete_space E] {f : â„‚ â†’ E} {c : â„‚} {R : â„} {w : â„‚} (hf : circle_integrable f c R) (hw : complex.abs w < R) : has_sum (Î» (n : â„•), â‡‘(cauchy_power_series f c R n) (Î» (_x : fin n), w)) ((2 * â†‘real.pi * complex.I)â»Â¹ â€¢ âˆ® (z : â„‚) in C(c, R), (z - (c + w))â»Â¹ â€¢ f z)
theorem set.pairwise.of_refl {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} {s : set Î±} [is_refl Î± r] : s.pairwise r â†’ âˆ€ â¦ƒa : Î±â¦„, a âˆˆ s â†’ âˆ€ â¦ƒb : Î±â¦„, b âˆˆ s â†’ r a b
theorem convex_on.map_set_average_le {Î± : Type u_1} {E : Type u_2} {m0 : measurable_space Î±} [normed_group E] [normed_space â„ E] [complete_space E] {Î¼ : measure_theory.measure Î±} {s : set E} {t : set Î±} {f : Î± â†’ E} {g : E â†’ â„} (hg : convex_on â„ s g) (hgc : continuous_on g s) (hsc : is_closed s) (h0 : â‡‘Î¼ t â‰  0) (ht : â‡‘Î¼ t â‰  âŠ¤) (hfs : âˆ€áµ (x : Î±) âˆ‚Î¼.restrict t, f x âˆˆ s) (hfi : measure_theory.integrable_on f t Î¼) (hgi : measure_theory.integrable_on (g âˆ˜ f) t Î¼) : g (â¨ (x : Î±) in t, f x âˆ‚Î¼) â‰¤ â¨ (x : Î±) in t, g (f x) âˆ‚Î¼
theorem abs_inner_div_norm_mul_norm_eq_one_iff {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] (x y : E) : is_R_or_C.abs (has_inner.inner x y / (â†‘âˆ¥xâˆ¥ * â†‘âˆ¥yâˆ¥)) = 1 â†” x â‰  0 âˆ§ âˆƒ (r : ğ•œ), r â‰  0 âˆ§ y = r â€¢ x
theorem class_group.exists_mk0_eq_mk0 {R : Type u_1} {S : Type u_2} (L : Type u_4) [euclidean_domain R] [comm_ring S] [is_domain S] [field L] [algRL : algebra R L] [algebra R S] [algebra S L] [ist : is_scalar_tower R S L] [iic : is_integral_closure S R L] {abv : absolute_value R â„¤} {Î¹ : Type u_5} [decidable_eq Î¹] [fintype Î¹] (bS : basis Î¹ R S) (adm : abv.is_admissible) [infinite R] [decidable_eq R] [is_dedekind_domain S] [is_fraction_ring S L] (h : algebra.is_algebraic R L) (I : â†¥(non_zero_divisors (ideal S))) : âˆƒ (J : â†¥(non_zero_divisors (ideal S))), â‡‘(class_group.mk0 L) I = â‡‘(class_group.mk0 L) J âˆ§ â‡‘(algebra_map R S) ((class_group.finset_approx bS adm).prod (Î» (m : R), m)) âˆˆ â†‘J
theorem measure_theory.measure_is_open_pos_of_smul_invariant_of_compact_ne_zero (G : Type u_1) {Î± : Type u_3} {m : measurable_space Î±} [group G] [mul_action G Î±] [measurable_space G] [has_measurable_smul G Î±] {Î¼ : measure_theory.measure Î±} [measure_theory.smul_invariant_measure G Î± Î¼] [topological_space Î±] [has_continuous_const_smul G Î±] [mul_action.is_minimal G Î±] {K U : set Î±} (hK : is_compact K) (hÎ¼K : â‡‘Î¼ K â‰  0) (hU : is_open U) (hne : U.nonempty) : 0 < â‡‘Î¼ U
theorem pos_of_neg_neg {Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a : Î±} : -a < 0 â†’ 0 < a
theorem monoid.subset_closure {M : Type u_1} [monoid M] {s : set M} : s âŠ† monoid.closure s
theorem category_theory.limits.colimits_from_coequalizers_and_coproducts {C : Type u} [category_theory.category C] [category_theory.limits.has_coproducts C] [category_theory.limits.has_coequalizers C] : category_theory.limits.has_colimits C
theorem list.sum_update_nth' {G : Type u_7} [add_comm_group G] (L : list G) (n : â„•) (a : G) : (L.update_nth n a).sum = L.sum + dite (n < L.length) (Î» (hn : n < L.length), -L.nth_le n hn + a) (Î» (hn : Â¬n < L.length), 0)
theorem strict_convex_on_of_slope_strict_mono_adjacent {ğ•œ : Type u_1} [linear_ordered_field ğ•œ] {s : set ğ•œ} {f : ğ•œ â†’ ğ•œ} (hs : convex ğ•œ s) (hf : âˆ€ {x y z : ğ•œ}, x âˆˆ s â†’ z âˆˆ s â†’ x < y â†’ y < z â†’ (f y - f x) / (y - x) < (f z - f y) / (z - y)) : strict_convex_on ğ•œ s f
theorem con.map_of_surjective_eq_map_gen {M : Type u_1} {N : Type u_2} [has_mul M] [has_mul N] {c : con M} {f : M â†’ N} (H : âˆ€ (x y : M), f (x * y) = f x * f y) (h : con.mul_ker f H â‰¤ c) (hf : function.surjective f) : c.map_gen f = c.map_of_surjective f H h hf
theorem fixing_subgroup_Union (M : Type u_1) (Î± : Type u_2) [group M] [mul_action M Î±] {Î¹ : Sort u_3} {s : Î¹ â†’ set Î±} : fixing_subgroup M (â‹ƒ (i : Î¹), s i) = â¨… (i : Î¹), fixing_subgroup M (s i)
theorem measure_theory.measure.haar.haar_content_self {G : Type u_1} [group G] [topological_space G] [topological_group G] [t2_space G] {Kâ‚€ : topological_space.positive_compacts G} : â‡‘(measure_theory.measure.haar.haar_content Kâ‚€) Kâ‚€.to_compacts = 1
theorem bdd_above_union {Î³ : Type w} [semilattice_sup Î³] {s t : set Î³} : bdd_above (s âˆª t) â†” bdd_above s âˆ§ bdd_above t
theorem one_le_of_inv_le_one {Î± : Type u} [group Î±] [has_le Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a : Î±} : aâ»Â¹ â‰¤ 1 â†’ 1 â‰¤ a
theorem sum_range_pow (n p : â„•) : (finset.range n).sum (Î» (k : â„•), â†‘k ^ p) = (finset.range (p + 1)).sum (Î» (i : â„•), bernoulli i * â†‘((p + 1).choose i) * â†‘n ^ (p + 1 - i) / (â†‘p + 1))
theorem alg_hom.map_coe_real_complex {A : Type u_3} [semiring A] [algebra â„ A] (f : â„‚ â†’â‚[â„] A) (x : â„) : â‡‘f â†‘x = â‡‘(algebra_map â„ A) x
theorem top_fixed_by_finite {K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] : âŠ¤ âˆˆ fixed_by_finite K L
theorem subsemiring.sum_mem {R : Type u} [non_assoc_semiring R] (s : subsemiring R) {Î¹ : Type u_1} {t : finset Î¹} {f : Î¹ â†’ R} (h : âˆ€ (c : Î¹), c âˆˆ t â†’ f c âˆˆ s) : t.sum (Î» (i : Î¹), f i) âˆˆ s
theorem submodule.pow_induction_on_left' {R : Type u} [comm_semiring R] {A : Type v} [semiring A] [algebra R A] (M : submodule R A) {C : Î  (n : â„•) (x : A), x âˆˆ M ^ n â†’ Prop} (hr : âˆ€ (r : R), C 0 (â‡‘(algebra_map R A) r) _) (hadd : âˆ€ (x y : A) (i : â„•) (hx : x âˆˆ M ^ i) (hy : y âˆˆ M ^ i), C i x hx â†’ C i y hy â†’ C i (x + y) _) (hmul : âˆ€ (m : A) (H : m âˆˆ M) (i : â„•) (x : A) (hx : x âˆˆ M ^ i), C i x hx â†’ C i.succ (m * x) _) {x : A} {n : â„•} (hx : x âˆˆ M ^ n) : C n x hx
theorem finsupp.ext_iff {Î± : Type u_1} {M : Type u_5} [has_zero M] {f g : Î± â†’â‚€ M} : f = g â†” âˆ€ (a : Î±), â‡‘f a = â‡‘g a
theorem dense_inducing.interior_compact_eq_empty {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] {i : Î± â†’ Î²} [t2_space Î²] (di : dense_inducing i) (hd : dense (set.range i)á¶œ) {s : set Î±} (hs : is_compact s) : interior s = âˆ…
theorem Top.presheaf.is_sheaf_iff_is_sheaf_opens_le_cover {C : Type u} [category_theory.category C] {X : Top} [category_theory.limits.has_products C] (F : Top.presheaf C X) : F.is_sheaf â†” F.is_sheaf_opens_le_cover
theorem list.eq_iff_join_eq {Î± : Type u_1} (L L' : list (list Î±)) : L = L' â†” L.join = L'.join âˆ§ list.map list.length L = list.map list.length L'
theorem cont_diff_at.differentiable_at {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {f : E â†’ F} {x : E} {n : with_top â„•} (h : cont_diff_at ğ•œ n f x) (hn : 1 â‰¤ n) : differentiable_at ğ•œ f x
theorem nnreal.lintegral_mul_le_Lp_mul_Lq {Î± : Type u_1} [measurable_space Î±] {Î¼ : measure_theory.measure Î±} {p q : â„} (hpq : p.is_conjugate_exponent q) {f g : Î± â†’ nnreal} (hf : ae_measurable f Î¼) (hg : ae_measurable g Î¼) : âˆ«â» (a : Î±), â†‘((f * g) a) âˆ‚Î¼ â‰¤ (âˆ«â» (a : Î±), â†‘(f a) ^ p âˆ‚Î¼) ^ (1 / p) * (âˆ«â» (a : Î±), â†‘(g a) ^ q âˆ‚Î¼) ^ (1 / q)
theorem metric.cthickening_empty {Î± : Type u} [pseudo_emetric_space Î±] (Î´ : â„) : metric.cthickening Î´ âˆ… = âˆ…
theorem metric.closure_eq_Inter_cthickening' {Î± : Type u} [pseudo_emetric_space Î±] (E : set Î±) (s : set â„) (hs : âˆ€ (Îµ : â„), 0 < Îµ â†’ (s âˆ© set.Ioc 0 Îµ).nonempty) : closure E = â‹‚ (Î´ : â„) (H : Î´ âˆˆ s), metric.cthickening Î´ E
theorem category_theory.functor.final.has_colimit_of_comp {C : Type v} [category_theory.small_category C] {D : Type v} [category_theory.small_category D] (F : C â¥¤ D) [F.final] {E : Type u} [category_theory.category E] {G : D â¥¤ E} [category_theory.limits.has_colimit (F â‹™ G)] : category_theory.limits.has_colimit G
theorem measure_theory.lintegral_prod_symm' {Î± : Type u_1} {Î² : Type u_3} [measurable_space Î±] [measurable_space Î²] {Î¼ : measure_theory.measure Î±} {Î½ : measure_theory.measure Î²} [measure_theory.sigma_finite Î½] [measure_theory.sigma_finite Î¼] (f : Î± Ã— Î² â†’ ennreal) (hf : measurable f) : âˆ«â» (z : Î± Ã— Î²), f z âˆ‚Î¼.prod Î½ = âˆ«â» (y : Î²), âˆ«â» (x : Î±), f (x, y) âˆ‚Î¼ âˆ‚Î½
theorem reflection_apply {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {K : submodule ğ•œ E} [complete_space â†¥K] (p : E) : â‡‘(reflection K) p = bit0 â†‘(â‡‘(orthogonal_projection K) p) - p
theorem topological_space.first_countable_topology.tendsto_subseq {Î± : Type u} [t : topological_space Î±] [topological_space.first_countable_topology Î±] {u : â„• â†’ Î±} {x : Î±} (hx : map_cluster_pt x filter.at_top u) : âˆƒ (Ïˆ : â„• â†’ â„•), strict_mono Ïˆ âˆ§ filter.tendsto (u âˆ˜ Ïˆ) filter.at_top (nhds x)
theorem monovary.sum_comp_perm_mul_eq_sum_mul_iff {Î¹ : Type u_1} {Î± : Type u_2} [linear_ordered_ring Î±] {Ïƒ : equiv.perm Î¹} {f g : Î¹ â†’ Î±} [fintype Î¹] (hfg : monovary f g) : finset.univ.sum (Î» (i : Î¹), f (â‡‘Ïƒ i) * g i) = finset.univ.sum (Î» (i : Î¹), f i * g i) â†” monovary (f âˆ˜ â‡‘Ïƒ) g
theorem interval_integral.integral_has_fderiv_at_of_tendsto_ae {E : Type u_3} [normed_group E] [complete_space E] [normed_space â„ E] {f : â„ â†’ E} {ca cb : E} {a b : â„} (hf : interval_integrable f measure_theory.measure_space.volume a b) (hmeas_a : strongly_measurable_at_filter f (nhds a) measure_theory.measure_space.volume) (hmeas_b : strongly_measurable_at_filter f (nhds b) measure_theory.measure_space.volume) (ha : filter.tendsto f (nhds a âŠ“ measure_theory.measure_space.volume.ae) (nhds ca)) (hb : filter.tendsto f (nhds b âŠ“ measure_theory.measure_space.volume.ae) (nhds cb)) : has_fderiv_at (Î» (p : â„ Ã— â„), âˆ« (x : â„) in p.fst..p.snd, f x) ((continuous_linear_map.snd â„ â„ â„).smul_right cb - (continuous_linear_map.fst â„ â„ â„).smul_right ca) (a, b)
theorem is_local_min.has_fderiv_at_eq_zero {E : Type u} [normed_group E] [normed_space â„ E] {f : E â†’ â„} {a : E} {f' : E â†’L[â„] â„} (h : is_local_min f a) (hf : has_fderiv_at f f' a) : f' = 0
theorem is_max_on.dual {Î± : Type u} {Î² : Type v} [preorder Î²] {f : Î± â†’ Î²} {s : set Î±} {a : Î±} : is_max_on f s a â†’ is_min_on (â‡‘order_dual.to_dual âˆ˜ f) s a
theorem continuous_affine_map.cont_diff {ğ•œ : Type u_1} {V : Type u_2} {W : Type u_3} [nondiscrete_normed_field ğ•œ] [normed_group V] [normed_space ğ•œ V] [normed_group W] [normed_space ğ•œ W] {n : with_top â„•} (f : V â†’A[ğ•œ] W) : cont_diff ğ•œ n â‡‘f
theorem orthogonal_eq_inter {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] (K : submodule ğ•œ E) : Ká—® = â¨… (v : â†¥K), (â‡‘innerSL â†‘v).ker
theorem category_theory.shift_comm' {C : Type u} {A : Type u_1} [category_theory.category C] [add_comm_monoid A] [category_theory.has_shift C A] {X Y : C} (f : X âŸ¶ Y) (i j : A) : (category_theory.shift_functor C j).map ((category_theory.shift_functor C i).map f) = (category_theory.shift_comm X i j).hom â‰« (category_theory.shift_functor C i).map ((category_theory.shift_functor C j).map f) â‰« (category_theory.shift_comm Y j i).hom
theorem refl_trans_gen_of_pred {Î± : Type u_1} [linear_order Î±] [pred_order Î±] [is_pred_archimedean Î±] (r : Î± â†’ Î± â†’ Prop) {n m : Î±} (h1 : âˆ€ (i : Î±), i âˆˆ set.Ioc m n â†’ r i (order.pred i)) (h2 : âˆ€ (i : Î±), i âˆˆ set.Ioc n m â†’ r (order.pred i) i) : relation.refl_trans_gen r n m
theorem continuous_linear_map.lipschitz {ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_normed_group E] [semi_normed_group F] [nondiscrete_normed_field ğ•œ] [nondiscrete_normed_field ğ•œâ‚‚] [normed_space ğ•œ E] [normed_space ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} [ring_hom_isometric Ïƒâ‚â‚‚] (f : E â†’SL[Ïƒâ‚â‚‚] F) : lipschitz_with âˆ¥fâˆ¥â‚Š â‡‘f
theorem setoid.eqv_gen_of_setoid {Î± : Type u_1} (r : setoid Î±) : eqv_gen.setoid setoid.r = r
theorem metric.thickening_subset_cthickening {Î± : Type u} [pseudo_emetric_space Î±] (Î´ : â„) (E : set Î±) : metric.thickening Î´ E âŠ† metric.cthickening Î´ E
theorem bounded_continuous_function.coe_star {Î± : Type u} {Î² : Type v} [topological_space Î±] [semi_normed_group Î²] [star_add_monoid Î²] [normed_star_group Î²] (f : bounded_continuous_function Î± Î²) : â‡‘(has_star.star f) = has_star.star â‡‘f
theorem clifford_algebra_complex.reverse_apply (x : clifford_algebra clifford_algebra_complex.Q) : â‡‘clifford_algebra.reverse x = x
theorem convex.strict_mono_on_of_deriv_pos {D : set â„} (hD : convex â„ D) {f : â„ â†’ â„} (hf : continuous_on f D) (hf' : âˆ€ (x : â„), x âˆˆ interior D â†’ 0 < deriv f x) : strict_mono_on f D
theorem Top.is_topological_basis_cofiltered_limit {J : Type v} [category_theory.small_category J] [category_theory.is_cofiltered J] (F : J â¥¤ Top) (C : category_theory.limits.cone F) (hC : category_theory.limits.is_limit C) (T : Î  (j : J), set (set â†¥(F.obj j))) (hT : âˆ€ (j : J), topological_space.is_topological_basis (T j)) (univ : âˆ€ (i : J), set.univ âˆˆ T i) (inter : âˆ€ (i : J) (U1 U2 : set â†¥(F.obj i)), U1 âˆˆ T i â†’ U2 âˆˆ T i â†’ U1 âˆ© U2 âˆˆ T i) (compat : âˆ€ (i j : J) (f : i âŸ¶ j) (V : set â†¥(F.obj j)), V âˆˆ T j â†’ â‡‘(F.map f) â»Â¹' V âˆˆ T i) : topological_space.is_topological_basis {U : set â†¥(C.X) | âˆƒ (j : J) (V : set â†¥(F.obj j)), V âˆˆ T j âˆ§ U = â‡‘(C.Ï€.app j) â»Â¹' V}
theorem maximal_orthonormal_iff_basis_of_finite_dimensional {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {v : set E} [finite_dimensional ğ•œ E] (hv : orthonormal ğ•œ coe) : (âˆ€ (u : set E), u âŠ‡ v â†’ orthonormal ğ•œ coe â†’ u = v) â†” âˆƒ (b : basis â†¥v ğ•œ E), â‡‘b = coe
theorem linear_ordered_comm_group_with_zero.nhds_of_ne_zero {Î“â‚€ : Type u_1} [linear_ordered_comm_group_with_zero Î“â‚€] (Î³ : Î“â‚€) (h : Î³ â‰  0) : nhds Î³ = has_pure.pure Î³
theorem finset.prod_one_sub_ordered {Î¹ : Type u_1} {R : Type u_2} [comm_ring R] [linear_order Î¹] (s : finset Î¹) (f : Î¹ â†’ R) : s.prod (Î» (i : Î¹), 1 - f i) = 1 - s.sum (Î» (i : Î¹), f i * (finset.filter (Î» (_x : Î¹), _x < i) s).prod (Î» (j : Î¹), 1 - f j))
theorem category_theory.inv_counit_map {C : Type uâ‚} [category_theory.category C] {D : Type uâ‚‚} [category_theory.category D] {L : C â¥¤ D} {R : D â¥¤ C} (h : L âŠ£ R) {X : D} [category_theory.is_iso (h.counit.app X)] : category_theory.inv (R.map (h.counit.app X)) = h.unit.app (R.obj X)
theorem circle_integral.integral_eq_zero_of_has_deriv_within_at {E : Type u_1} [normed_group E] [normed_space â„‚ E] [complete_space E] {f f' : â„‚ â†’ E} {c : â„‚} {R : â„} (hR : 0 â‰¤ R) (h : âˆ€ (z : â„‚), z âˆˆ metric.sphere c R â†’ has_deriv_within_at f (f' z) (metric.sphere c R) z) : âˆ® (z : â„‚) in C(c, R), f' z = 0
theorem category_theory.limits.has_pullbacks_of_has_limit_cospan (C : Type u) [category_theory.category C] [âˆ€ {X Y Z : C} {f : X âŸ¶ Z} {g : Y âŸ¶ Z}, category_theory.limits.has_limit (category_theory.limits.cospan f g)] : category_theory.limits.has_pullbacks C
theorem nat.desc_factorial_eq_div {n k : â„•} (h : k â‰¤ n) : n.desc_factorial k = n.factorial / (n - k).factorial
theorem finset.sum_powerset_insert {Î± : Type u} {Î² : Type v} [decidable_eq Î±] [add_comm_monoid Î²] {s : finset Î±} {x : Î±} (h : x âˆ‰ s) (f : finset Î± â†’ Î²) : (has_insert.insert x s).powerset.sum (Î» (a : finset Î±), f a) = s.powerset.sum (Î» (a : finset Î±), f a) + s.powerset.sum (Î» (t : finset Î±), f (has_insert.insert x t))
theorem metric.inductive_limit_dist_eq_dist {X : â„• â†’ Type u} [Î  (n : â„•), metric_space (X n)] {f : Î  (n : â„•), X n â†’ X (n + 1)} (I : âˆ€ (n : â„•), isometry (f n)) (x y : Î£ (n : â„•), X n) (m : â„•) (hx : x.fst â‰¤ m) (hy : y.fst â‰¤ m) : metric.inductive_limit_dist f x y = has_dist.dist (nat.le_rec_on hx f x.snd) (nat.le_rec_on hy f y.snd)
theorem abs_inner_eq_norm_iff {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] (x y : E) (hx0 : x â‰  0) (hy0 : y â‰  0) : is_R_or_C.abs (has_inner.inner x y) = âˆ¥xâˆ¥ * âˆ¥yâˆ¥ â†” âˆƒ (r : ğ•œ), r â‰  0 âˆ§ y = r â€¢ x
theorem finset.mem_shadow_iff_insert_mem {Î± : Type u_1} [decidable_eq Î±] {ğ’œ : finset (finset Î±)} {s : finset Î±} : s âˆˆ ğ’œ.shadow â†” âˆƒ (a : Î±) (H : a âˆ‰ s), has_insert.insert a s âˆˆ ğ’œ
theorem category_theory.abelian.pseudoelement.apply_zero {C : Type u} [category_theory.category C] [category_theory.abelian C] {P Q : C} (f : P âŸ¶ Q) : â‡‘f 0 = 0
theorem is_group_hom.comp {Î± : Type u} {Î² : Type v} [group Î±] [group Î²] {f : Î± â†’ Î²} (hf : is_group_hom f) {Î³ : Type u_1} [group Î³] {g : Î² â†’ Î³} (hg : is_group_hom g) : is_group_hom (g âˆ˜ f)
theorem multilinear_map.map_sum_finset {R : Type u} {Î¹ : Type u'} {Mâ‚ : Î¹ â†’ Type vâ‚} {Mâ‚‚ : Type vâ‚‚} [decidable_eq Î¹] [semiring R] [Î  (i : Î¹), add_comm_monoid (Mâ‚ i)] [add_comm_monoid Mâ‚‚] [Î  (i : Î¹), module R (Mâ‚ i)] [module R Mâ‚‚] (f : multilinear_map R Mâ‚ Mâ‚‚) {Î± : Î¹ â†’ Type u_1} (g : Î  (i : Î¹), Î± i â†’ Mâ‚ i) (A : Î  (i : Î¹), finset (Î± i)) [fintype Î¹] : â‡‘f (Î» (i : Î¹), (A i).sum (Î» (j : Î± i), g i j)) = (fintype.pi_finset A).sum (Î» (r : Î  (a : Î¹), Î± a), â‡‘f (Î» (i : Î¹), g i (r i)))
theorem linear_ordered_comm_group_with_zero.nhds_fun_ok (Î“â‚€ : Type u_1) [linear_ordered_comm_group_with_zero Î“â‚€] (x : Î“â‚€) {s : set Î“â‚€} (s_in : s âˆˆ linear_ordered_comm_group_with_zero.nhds_fun Î“â‚€ x) : âˆƒ (t : set Î“â‚€) (H : t âˆˆ linear_ordered_comm_group_with_zero.nhds_fun Î“â‚€ x), t âŠ† s âˆ§ âˆ€ (y : Î“â‚€), y âˆˆ t â†’ s âˆˆ linear_ordered_comm_group_with_zero.nhds_fun Î“â‚€ y
theorem convex.add_smul_sub_mem_interior' {E : Type u_2} {ğ•œ : Type u_3} [linear_ordered_field ğ•œ] [add_comm_group E] [module ğ•œ E] [topological_space E] [topological_add_group E] [has_continuous_const_smul ğ•œ E] {s : set E} (hs : convex ğ•œ s) {x y : E} (hx : x âˆˆ closure s) (hy : y âˆˆ interior s) {t : ğ•œ} (ht : t âˆˆ set.Ioc 0 1) : x + t â€¢ (y - x) âˆˆ interior s
theorem is_fraction_ring.comap_is_algebraic_iff {A : Type u_4} {K : Type u_5} {C : Type u_6} [comm_ring A] [is_domain A] [field K] [algebra A K] [is_fraction_ring A K] [comm_ring C] [algebra A C] [algebra K C] [is_scalar_tower A K C] : algebra.is_algebraic A C â†” algebra.is_algebraic K C
theorem measure_theory.is_fundamental_domain.ess_sup_measure_restrict {G : Type u_1} {Î± : Type u_2} [group G] [mul_action G Î±] [measurable_space Î±] {s : set Î±} {Î¼ : measure_theory.measure Î±} [measurable_space G] [has_measurable_smul G Î±] [measure_theory.smul_invariant_measure G Î± Î¼] [encodable G] (hs : measure_theory.is_fundamental_domain G s Î¼) {f : Î± â†’ ennreal} (hf : âˆ€ (Î³ : G) (x : Î±), f (Î³ â€¢ x) = f x) : ess_sup f (Î¼.restrict s) = ess_sup f Î¼
theorem polynomial.C_leading_coeff_mul_prod_multiset_X_sub_C {K : Type u_1} [comm_ring K] [is_domain K] {p : polynomial K} (hroots : â‡‘multiset.card p.roots = p.nat_degree) : â‡‘polynomial.C p.leading_coeff * (multiset.map (Î» (a : K), polynomial.X - â‡‘polynomial.C a) p.roots).prod = p
theorem monotone.inf {Î± : Type u} {Î² : Type v} [preorder Î±] [semilattice_inf Î²] {f g : Î± â†’ Î²} (hf : monotone f) (hg : monotone g) : monotone (f âŠ“ g)
theorem rel_supr_tsum {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [add_comm_monoid Î±] [topological_space Î±] [t2_space Î±] [encodable Î³] [complete_lattice Î²] (m : Î² â†’ Î±) (m0 : m âŠ¥ = 0) (R : Î± â†’ Î± â†’ Prop) (m_supr : âˆ€ (s : â„• â†’ Î²), R (m (â¨† (i : â„•), s i)) (âˆ‘' (i : â„•), m (s i))) (s : Î³ â†’ Î²) : R (m (â¨† (b : Î³), s b)) (âˆ‘' (b : Î³), m (s b))
theorem category_theory.limits.is_colimit.hom_is_iso {J : Type uâ‚} [category_theory.category J] {C : Type uâ‚ƒ} [category_theory.category C] {F : J â¥¤ C} {s t : category_theory.limits.cocone F} (P : category_theory.limits.is_colimit s) (Q : category_theory.limits.is_colimit t) (f : s âŸ¶ t) : category_theory.is_iso f
theorem metric.emetric_closed_ball_nnreal {Î± : Type u} [pseudo_metric_space Î±] {x : Î±} {Îµ : nnreal} : emetric.closed_ball x â†‘Îµ = metric.closed_ball x â†‘Îµ
theorem affine_subspace.affine_span_eq_Inf (k : Type u_1) (V : Type u_2) {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] (s : set P) : affine_span k s = has_Inf.Inf {s' : affine_subspace k P | s âŠ† â†‘s'}
theorem matrix.is_hermitian_iff_is_self_adjoint {Î± : Type u_1} {n : Type u_4} [is_R_or_C Î±] [fintype n] [decidable_eq n] {A : matrix n n Î±} : A.is_hermitian â†” inner_product_space.is_self_adjoint (â‡‘((pi_Lp.linear_equiv Î± (Î» (_x : n), Î±)).symm.conj) (â‡‘matrix.to_lin' A))
theorem uniform_space.completion.dist_eq {Î± : Type u} [pseudo_metric_space Î±] (x y : Î±) : has_dist.dist â†‘x â†‘y = has_dist.dist x y
theorem well_founded.game_add {Î± : Type u_1} {Î² : Type u_2} {rÎ± : Î± â†’ Î± â†’ Prop} {rÎ² : Î² â†’ Î² â†’ Prop} (hÎ± : well_founded rÎ±) (hÎ² : well_founded rÎ²) : well_founded (relation.game_add rÎ± rÎ²)
theorem probability_theory.indep_fun.variance_sum {Î© : Type u_1} [measure_theory.measure_space Î©] [measure_theory.is_probability_measure measure_theory.measure_space.volume] {Î¹ : Type u_2} {X : Î¹ â†’ Î© â†’ â„} {s : finset Î¹} (hs : âˆ€ (i : Î¹), i âˆˆ s â†’ measure_theory.mem_â„’p (X i) 2 measure_theory.measure_space.volume) (h : â†‘s.pairwise (Î» (i j : Î¹), probability_theory.indep_fun (X i) (X j) measure_theory.measure_space.volume)) : probability_theory.variance (s.sum (Î» (i : Î¹), X i)) measure_theory.measure_space.volume = s.sum (Î» (i : Î¹), probability_theory.variance (X i) measure_theory.measure_space.volume)
theorem is_integral_leading_coeff_smul {R : Type u_1} {S : Type u_4} [comm_ring R] [comm_ring S] (p : polynomial R) (x : S) [algebra R S] (h : â‡‘(polynomial.aeval x) p = 0) : is_integral R (p.leading_coeff â€¢ x)
theorem polynomial.prod_cyclotomic_eq_X_pow_sub_one {n : â„•} (hpos : 0 < n) (R : Type u_1) [comm_ring R] : n.divisors.prod (Î» (i : â„•), polynomial.cyclotomic i R) = polynomial.X ^ n - 1
theorem matrix.pivot.exists_is_two_block_diagonal_list_transvec_mul_mul_list_transvec {ğ•œ : Type u_3} [field ğ•œ] {r : â„•} (M : matrix (fin r âŠ• unit) (fin r âŠ• unit) ğ•œ) : âˆƒ (L L' : list (matrix.transvection_struct (fin r âŠ• unit) ğ•œ)), (((list.map matrix.transvection_struct.to_matrix L).prod.mul M).mul (list.map matrix.transvection_struct.to_matrix L').prod).is_two_block_diagonal
theorem centroid_mem_affine_span_of_cast_card_ne_zero {k : Type u_1} {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] {Î¹ : Type u_4} {s : finset Î¹} (p : Î¹ â†’ P) (h : â†‘(s.card) â‰  0) : finset.centroid k s p âˆˆ affine_span k (set.range p)
theorem finpartition.is_partition_parts {Î± : Type u_1} (f : finpartition set.univ) : setoid.is_partition â†‘(f.parts)
theorem is_primitive_root.is_roots_of_minpoly {n : â„•} {K : Type u_8} [field K] {Î¼ : K} (h : is_primitive_root Î¼ n) [char_zero K] : primitive_roots n K âŠ† (polynomial.map (int.cast_ring_hom K) (minpoly â„¤ Î¼)).roots.to_finset
theorem fin.tail_init_eq_init_tail {n : â„•} {Î² : Type u_1} (q : fin (n + 2) â†’ Î²) : fin.tail (fin.init q) = fin.init (fin.tail q)
theorem circle_deg1_lift.translation_number_of_eq_add_int (f : circle_deg1_lift) {x : â„} {m : â„¤} (h : â‡‘f x = x + â†‘m) : f.translation_number = â†‘m
theorem measure_theory.map_prod_inv_mul_eq {G : Type u_1} [measurable_space G] [group G] [has_measurable_mulâ‚‚ G] (Î¼ Î½ : measure_theory.measure G) [measure_theory.sigma_finite Î½] [measure_theory.sigma_finite Î¼] [has_measurable_inv G] [Î½.is_mul_left_invariant] : measure_theory.measure.map (Î» (z : G Ã— G), (z.fst, (z.fst)â»Â¹ * z.snd)) (Î¼.prod Î½) = Î¼.prod Î½
theorem has_deriv_at_exp_zero {ğ•‚ : Type u_1} [is_R_or_C ğ•‚] : has_deriv_at (exp ğ•‚) 1 0
theorem cauchy_seq_tendsto_of_complete {Î± : Type u} {Î² : Type v} [uniform_space Î±] [semilattice_sup Î²] [complete_space Î±] {u : Î² â†’ Î±} (H : cauchy_seq u) : âˆƒ (x : Î±), filter.tendsto u filter.at_top (nhds x)
theorem euclidean_geometry.mul_dist_eq_abs_sub_sq_dist {V : Type u_1} [inner_product_space â„ V] {P : Type u_2} [metric_space P] [normed_add_torsor V P] {a b p q : P} (hp : âˆƒ (k : â„), k â‰  1 âˆ§ b -áµ¥ p = k â€¢ (a -áµ¥ p)) (hq : has_dist.dist a q = has_dist.dist b q) : has_dist.dist a p * has_dist.dist b p = |has_dist.dist b q ^ 2 - has_dist.dist p q ^ 2|
theorem interval_integral.interval_integrable_rpow' {a b r : â„} (h : -1 < r) : interval_integrable (Î» (x : â„), x ^ r) measure_theory.measure_space.volume a b
theorem matrix.is_hermitian.spectral_theorem {ğ•œ : Type u_1} [is_R_or_C ğ•œ] [decidable_eq ğ•œ] {n : Type u_2} [fintype n] [decidable_eq n] {A : matrix n n ğ•œ} (hA : A.is_hermitian) : hA.eigenvector_matrix_inv.mul A = (matrix.diagonal (coe âˆ˜ hA.eigenvalues)).mul hA.eigenvector_matrix_inv
theorem simple_graph.exists_minimal_degree_vertex {V : Type u} (G : simple_graph V) [fintype V] [decidable_rel G.adj] [nonempty V] : âˆƒ (v : V), G.min_degree = G.degree v
theorem add_commute.add_right {S : Type u_1} [add_semigroup S] {a b c : S} (hab : add_commute a b) (hac : add_commute a c) : add_commute a (b + c)
theorem list.sublist_iff_exists_fin_order_embedding_nth_le_eq {Î± : Type u_1} {l l' : list Î±} : l <+ l' â†” âˆƒ (f : fin l.length â†ªo fin l'.length), âˆ€ (ix : fin l.length), l.nth_le â†‘ix _ = l'.nth_le â†‘(â‡‘f ix) _
theorem algebraic_geometry.local_ring_hom_comp_stalk_iso {R S : CommRing} (f : R âŸ¶ S) (p : prime_spectrum â†¥S) : (algebraic_geometry.structure_sheaf.stalk_iso â†¥R (â‡‘(prime_spectrum.comap f) p)).hom â‰« localization.local_ring_hom (â‡‘(prime_spectrum.comap f) p).as_ideal p.as_ideal f rfl â‰« (algebraic_geometry.structure_sheaf.stalk_iso â†¥S p).inv = algebraic_geometry.PresheafedSpace.stalk_map (algebraic_geometry.Spec.SheafedSpace_map f) p
theorem polynomial.smul_mem_lifts {R : Type u} [comm_semiring R] {S : Type v} [semiring S] [algebra R S] {p : polynomial S} (r : R) (hp : p âˆˆ polynomial.lifts (algebra_map R S)) : r â€¢ p âˆˆ polynomial.lifts (algebra_map R S)
theorem list_sum_mem {M : Type u_1} {B : Type u_3} [add_monoid M] [set_like B M] [add_submonoid_class B M] {S : B} {l : list M} (hl : âˆ€ (x : M), x âˆˆ l â†’ x âˆˆ S) : l.sum âˆˆ S
theorem box_integral.integrable.dist_integral_sum_sum_integral_le_of_mem_base_set_of_Union_eq {Î¹ : Type u} {E : Type v} {F : Type w} [normed_group E] [normed_space â„ E] [normed_group F] [normed_space â„ F] {I : box_integral.box Î¹} {Ï€ : box_integral.tagged_prepartition I} [fintype Î¹] {l : box_integral.integration_params} {f : (Î¹ â†’ â„) â†’ E} {vol : box_integral.box_additive_map Î¹ (E â†’L[â„] F) âŠ¤} {c : nnreal} {Îµ : â„} [complete_space F] (h : box_integral.integrable I l f vol) (h0 : 0 < Îµ) (hÏ€ : l.mem_base_set I c (h.convergence_r Îµ c) Ï€) {Ï€â‚€ : box_integral.prepartition I} (hU : Ï€.Union = Ï€â‚€.Union) : has_dist.dist (box_integral.integral_sum f vol Ï€) (Ï€â‚€.boxes.sum (Î» (J : box_integral.box Î¹), box_integral.integral J l f vol)) â‰¤ Îµ
theorem topological_vector_bundle.trivialization.coord_change_apply' {R : Type u_1} {B : Type u_3} {F : Type u_4} {E : B â†’ Type u_5} [semiring R] [Î  (x : B), add_comm_monoid (E x)] [Î  (x : B), module R (E x)] [topological_space F] [add_comm_monoid F] [module R F] [topological_space B] [topological_space (bundle.total_space E)] (e e' : topological_vector_bundle.trivialization R F E) {b : B} (hb : b âˆˆ e.to_fiber_bundle_trivialization.base_set âˆ© e'.to_fiber_bundle_trivialization.base_set) (y : F) : â‡‘(e.coord_change e' b) y = (â‡‘e' (â‡‘(e.to_fiber_bundle_trivialization.to_local_homeomorph.symm) (b, y))).snd
theorem real.sinh_surjective  : function.surjective real.sinh
theorem mem_residual {Î± : Type u_1} [topological_space Î±] [baire_space Î±] {s : set Î±} : s âˆˆ residual Î± â†” âˆƒ (t : set Î±) (H : t âŠ† s), is_GÎ´ t âˆ§ dense t
theorem multilinear_map.zero_comp_linear_map {R : Type u} {Î¹ : Type u'} {Mâ‚ : Î¹ â†’ Type vâ‚} {Mâ‚‚ : Type vâ‚‚} [decidable_eq Î¹] [semiring R] [Î  (i : Î¹), add_comm_monoid (Mâ‚ i)] [add_comm_monoid Mâ‚‚] [Î  (i : Î¹), module R (Mâ‚ i)] [module R Mâ‚‚] {Mâ‚' : Î¹ â†’ Type u_1} [Î  (i : Î¹), add_comm_monoid (Mâ‚' i)] [Î  (i : Î¹), module R (Mâ‚' i)] (f : Î  (i : Î¹), Mâ‚ i â†’â‚—[R] Mâ‚' i) : 0.comp_linear_map f = 0
theorem le_nhds_iff {Î± : Type u} [topological_space Î±] {f : filter Î±} {a : Î±} : f â‰¤ nhds a â†” âˆ€ (s : set Î±), a âˆˆ s â†’ is_open s â†’ s âˆˆ f
theorem polynomial.expand_injective {R : Type u} [comm_semiring R] {n : â„•} (hn : 0 < n) : function.injective â‡‘(polynomial.expand R n)
theorem tactic.ring_exp.prod_congr {Î± : Type u} [comm_semiring Î±] {p p' ps ps' : Î±} : p = p' â†’ ps = ps' â†’ p * ps = p' * ps'
theorem matrix.circulant_is_symm_iff {Î± : Type u_1} {n : Type u_4} [add_group n] {v : n â†’ Î±} : (matrix.circulant v).is_symm â†” âˆ€ (i : n), v (-i) = v i
theorem iterated_fderiv_apply_eq_iterated_deriv_mul_prod {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {F : Type u_2} [normed_group F] [normed_space ğ•œ F] {n : â„•} {f : ğ•œ â†’ F} {x : ğ•œ} {m : fin n â†’ ğ•œ} : â‡‘(iterated_fderiv ğ•œ n f x) m = finset.univ.prod (Î» (i : fin n), m i) â€¢ iterated_deriv n f x
theorem same_ray_iff_norm_add {E : Type u_2} [normed_group E] [normed_space â„ E] [strict_convex_space â„ E] {x y : E} : same_ray â„ x y â†” âˆ¥x + yâˆ¥ = âˆ¥xâˆ¥ + âˆ¥yâˆ¥
theorem ideal.mem_quotient_iff_mem_sup {R : Type u_1} [comm_ring R] {I J : ideal R} {x : R} : â‡‘(ideal.quotient.mk I) x âˆˆ ideal.map (ideal.quotient.mk I) J â†” x âˆˆ J âŠ” I
theorem category_theory.limits.biprod.cone_point_unique_up_to_iso_inv {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (X Y : C) [category_theory.limits.has_binary_biproduct X Y] {b : category_theory.limits.binary_bicone X Y} (hb : b.is_bilimit) : (hb.is_limit.cone_point_unique_up_to_iso (category_theory.limits.binary_biproduct.is_limit X Y)).inv = category_theory.limits.biprod.desc b.inl b.inr
theorem add_con.ext'_iff {M : Type u_1} [has_add M] {c d : add_con M} : setoid.r = setoid.r â†” c = d
theorem con.Sup_def {M : Type u_1} [has_mul M] {S : set (con M)} : has_Sup.Sup S = con_gen (has_Sup.Sup (coe_fn '' S))
theorem multilinear_map.cons_smul {R : Type u} {n : â„•} {M : fin n.succ â†’ Type v} {Mâ‚‚ : Type vâ‚‚} [semiring R] [Î  (i : fin n.succ), add_comm_monoid (M i)] [add_comm_monoid Mâ‚‚] [Î  (i : fin n.succ), module R (M i)] [module R Mâ‚‚] (f : multilinear_map R M Mâ‚‚) (m : Î  (i : fin n), M i.succ) (c : R) (x : M 0) : â‡‘f (fin.cons (c â€¢ x) m) = c â€¢ â‡‘f (fin.cons x m)
theorem category_theory.limits.is_colimit.hom_ext {J : Type uâ‚} [category_theory.category J] {C : Type uâ‚ƒ} [category_theory.category C] {F : J â¥¤ C} {t : category_theory.limits.cocone F} (h : category_theory.limits.is_colimit t) {W : C} {f f' : t.X âŸ¶ W} (w : âˆ€ (j : J), t.Î¹.app j â‰« f = t.Î¹.app j â‰« f') : f = f'
theorem inner_product_geometry.norm_add_eq_add_norm_of_angle_eq_zero {V : Type u_1} [inner_product_space â„ V] {x y : V} (h : inner_product_geometry.angle x y = 0) : âˆ¥x + yâˆ¥ = âˆ¥xâˆ¥ + âˆ¥yâˆ¥
theorem nat.coprime_prod_right {Î¹ : Type u_1} {x : â„•} {s : Î¹ â†’ â„•} {t : finset Î¹} : (âˆ€ (i : Î¹), i âˆˆ t â†’ x.coprime (s i)) â†’ x.coprime (t.prod (Î» (i : Î¹), s i))
theorem nat.cast_le_pow_sub_div_sub {K : Type u_1} [linear_ordered_field K] {a : K} (H : 1 < a) (n : â„•) : â†‘n â‰¤ (a ^ n - 1) / (a - 1)
theorem omega_complete_partial_order.continuous_hom.forall_forall_merge {Î± : Type u} {Î² : Type v} [omega_complete_partial_order Î±] [omega_complete_partial_order Î²] (câ‚€ : omega_complete_partial_order.chain (Î± â†’ğ’„ Î²)) (câ‚ : omega_complete_partial_order.chain Î±) (z : Î²) : (âˆ€ (i j : â„•), â‡‘(â‡‘câ‚€ i) (â‡‘câ‚ j) â‰¤ z) â†” âˆ€ (i : â„•), â‡‘(â‡‘câ‚€ i) (â‡‘câ‚ i) â‰¤ z
theorem function.id_le_iterate_of_id_le {Î± : Type u_1} [preorder Î±] {f : Î± â†’ Î±} (h : id â‰¤ f) (n : â„•) : id â‰¤ (f^[n])
theorem concave_on.exists_le_of_center_mass {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} {Î¹ : Type u_5} [linear_ordered_field ğ•œ] [add_comm_group E] [linear_ordered_add_comm_group Î²] [module ğ•œ E] [module ğ•œ Î²] [ordered_smul ğ•œ Î²] {s : set E} {f : E â†’ Î²} {t : finset Î¹} {w : Î¹ â†’ ğ•œ} {p : Î¹ â†’ E} (h : concave_on ğ•œ s f) (hwâ‚€ : âˆ€ (i : Î¹), i âˆˆ t â†’ 0 â‰¤ w i) (hwâ‚ : 0 < t.sum (Î» (i : Î¹), w i)) (hp : âˆ€ (i : Î¹), i âˆˆ t â†’ p i âˆˆ s) : âˆƒ (i : Î¹) (H : i âˆˆ t), f (p i) â‰¤ f (t.center_mass w p)
theorem cont_mdiff_on_of_mem_maximal_atlas {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {M : Type u_4} [topological_space M] [charted_space H M] [Is : smooth_manifold_with_corners I M] {n : with_top â„•} {e : local_homeomorph M H} (h : e âˆˆ smooth_manifold_with_corners.maximal_atlas I M) : cont_mdiff_on I I n â‡‘e e.to_local_equiv.source
theorem measure_theory.strongly_measurable.ae_measurable {Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} {m : measurable_space Î±} [topological_space Î²] [topological_space.pseudo_metrizable_space Î²] [measurable_space Î²] [borel_space Î²] {Î¼ : measure_theory.measure Î±} (hf : measure_theory.strongly_measurable f) : ae_measurable f Î¼
theorem sub_nonpos_of_le {Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±} : a â‰¤ b â†’ a - b â‰¤ 0
theorem affine_map.is_open_map_linear_iff {ğ•œ : Type u_1} {V : Type u_2} {Vâ‚‚ : Type u_4} {P : Type u_8} {Pâ‚‚ : Type u_9} [normed_field ğ•œ] [semi_normed_group V] [semi_normed_group Vâ‚‚] [normed_space ğ•œ V] [normed_space ğ•œ Vâ‚‚] [pseudo_metric_space P] [pseudo_metric_space Pâ‚‚] [normed_add_torsor V P] [normed_add_torsor Vâ‚‚ Pâ‚‚] {f : P â†’áµƒ[ğ•œ] Pâ‚‚} : is_open_map â‡‘(f.linear) â†” is_open_map â‡‘f
theorem is_alg_closed.ring_equiv_of_cardinal_eq_of_char_zero {K L : Type} [field K] [field L] [is_alg_closed K] [is_alg_closed L] [char_zero K] [char_zero L] (hK : cardinal.aleph_0 < cardinal.mk K) (hKL : cardinal.mk K = cardinal.mk L) : K â‰ƒ+* L
theorem is_integral_localization_at_leading_coeff {R : Type u_1} [comm_ring R] {M : submonoid R} {S : Type u_2} [comm_ring S] [algebra R S] {Râ‚˜ : Type u_4} {Sâ‚˜ : Type u_5} [comm_ring Râ‚˜] [comm_ring Sâ‚˜] [algebra R Râ‚˜] [is_localization M Râ‚˜] [algebra S Sâ‚˜] [is_localization (algebra.algebra_map_submonoid S M) Sâ‚˜] {x : S} (p : polynomial R) (hp : â‡‘(polynomial.aeval x) p = 0) (hM : p.leading_coeff âˆˆ M) : (is_localization.map Sâ‚˜ (algebra_map R S) _).is_integral_elem (â‡‘(algebra_map S Sâ‚˜) x)
theorem has_subset.subset.ssubset_or_eq {Î± : Type u} [has_subset Î±] [has_ssubset Î±] [is_nonstrict_strict_order Î± has_subset.subset has_ssubset.ssubset] {a b : Î±} [is_antisymm Î± has_subset.subset] (h : a âŠ† b) : a âŠ‚ b âˆ¨ a = b
theorem algebraic_geometry.SheafedSpace.is_open_immersion.of_stalk_iso {C : Type u} [category_theory.category C] [category_theory.limits.has_products C] [category_theory.limits.has_limits C] [category_theory.limits.has_colimits C] [category_theory.concrete_category C] [category_theory.reflects_isomorphisms (category_theory.forget C)] [category_theory.limits.preserves_limits (category_theory.forget C)] [category_theory.limits.preserves_filtered_colimits (category_theory.forget C)] {X Y : algebraic_geometry.SheafedSpace C} (f : X âŸ¶ Y) (hf : open_embedding â‡‘(f.base)) [H : âˆ€ (x : â†¥X), category_theory.is_iso (algebraic_geometry.PresheafedSpace.stalk_map f x)] : algebraic_geometry.SheafedSpace.is_open_immersion f
theorem cont_diff_on.add {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {n : with_top â„•} {s : set E} {f g : E â†’ F} (hf : cont_diff_on ğ•œ n f s) (hg : cont_diff_on ğ•œ n g s) : cont_diff_on ğ•œ n (Î» (x : E), f x + g x) s
theorem polynomial.int_coeff_of_cyclotomic' {K : Type u_1} [comm_ring K] [is_domain K] {Î¶ : K} {n : â„•} (h : is_primitive_root Î¶ n) : âˆƒ (P : polynomial â„¤), polynomial.map (int.cast_ring_hom K) P = polynomial.cyclotomic' n K âˆ§ P.degree = (polynomial.cyclotomic' n K).degree âˆ§ P.monic
theorem prod.map_map {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} {Î´ : Type u_4} {Îµ : Type u_5} {Î¶ : Type u_6} (f : Î± â†’ Î²) (f' : Î³ â†’ Î´) (g : Î² â†’ Îµ) (g' : Î´ â†’ Î¶) (x : Î± Ã— Î³) : prod.map g g' (prod.map f f' x) = prod.map (g âˆ˜ f) (g' âˆ˜ f') x
theorem fin.succ_above_left_inj {n : â„•} {x y : fin (n + 1)} : x.succ_above = y.succ_above â†” x = y
theorem is_closed_map_smulâ‚€ {ğ•œ : Type u_1} {M : Type u_2} [division_ring ğ•œ] [add_comm_monoid M] [topological_space M] [t1_space M] [module ğ•œ M] [has_continuous_const_smul ğ•œ M] (c : ğ•œ) : is_closed_map (Î» (x : M), c â€¢ x)
theorem tendsto_of_liminf_eq_limsup {Î± : Type u} {Î² : Type v} [conditionally_complete_linear_order Î±] [topological_space Î±] [order_topology Î±] {f : filter Î²} {u : Î² â†’ Î±} {a : Î±} (hinf : f.liminf u = a) (hsup : f.limsup u = a) (h : filter.is_bounded_under has_le.le f u . "is_bounded_default") (h' : filter.is_bounded_under ge f u . "is_bounded_default") : filter.tendsto u f (nhds a)
theorem submodule.inf_orthogonal {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] (Kâ‚ Kâ‚‚ : submodule ğ•œ E) : Kâ‚á—® âŠ“ Kâ‚‚á—® = (Kâ‚ âŠ” Kâ‚‚)á—®
theorem vector.nth_cons_nil {Î± : Type u_1} {ix : fin 1} (x : Î±) : (x::áµ¥vector.nil).nth ix = x
theorem measurable_space.cardinal_generate_measurable_rec_le {Î± : Type u} (s : set (set Î±)) (i : (quotient.out (cardinal.aleph 1).ord).Î±) : cardinal.mk â†¥(measurable_space.generate_measurable_rec s i) â‰¤ linear_order.max (cardinal.mk â†¥s) 2 ^ cardinal.aleph_0
theorem algebra.adjoin_induction' {R : Type u} {A : Type v} [comm_semiring R] [semiring A] [algebra R A] {s : set A} {p : â†¥(algebra.adjoin R s) â†’ Prop} (Hs : âˆ€ (x : A) (h : x âˆˆ s), p âŸ¨x, _âŸ©) (Halg : âˆ€ (r : R), p (â‡‘(algebra_map R â†¥(algebra.adjoin R s)) r)) (Hadd : âˆ€ (x y : â†¥(algebra.adjoin R s)), p x â†’ p y â†’ p (x + y)) (Hmul : âˆ€ (x y : â†¥(algebra.adjoin R s)), p x â†’ p y â†’ p (x * y)) (x : â†¥(algebra.adjoin R s)) : p x
theorem category_theory.adjunction.has_colimits_of_equivalence {C : Type uâ‚} [category_theory.category C] {D : Type uâ‚‚} [category_theory.category D] (E : C â¥¤ D) [category_theory.is_equivalence E] [category_theory.limits.has_colimits_of_size D] : category_theory.limits.has_colimits_of_size C
theorem orientation.oangle_eq_iff_eq_pos_smul_rotation_of_ne_zero {V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) {x y : V} (hx : x â‰  0) (hy : y â‰  0) (Î¸ : real.angle) : o.oangle x y = Î¸ â†” âˆƒ (r : â„), 0 < r âˆ§ y = r â€¢ â‡‘(o.rotation Î¸) x
theorem exists_has_deriv_at_eq_zero' {f f' : â„ â†’ â„} {a b l : â„} (hab : a < b) (hfa : filter.tendsto f (nhds_within a (set.Ioi a)) (nhds l)) (hfb : filter.tendsto f (nhds_within b (set.Iio b)) (nhds l)) (hff' : âˆ€ (x : â„), x âˆˆ set.Ioo a b â†’ has_deriv_at f (f' x) x) : âˆƒ (c : â„) (H : c âˆˆ set.Ioo a b), f' c = 0
theorem fermat_42.exists_odd_minimal {a b c : â„¤} (h : fermat_42 a b c) : âˆƒ (a0 b0 c0 : â„¤), fermat_42.minimal a0 b0 c0 âˆ§ a0 % 2 = 1
theorem rack.to_envel_group.map_aux.well_def {R : Type u_1} [rack R] {G : Type u_2} [group G] (f : shelf_hom R (quandle.conj G)) {a b : rack.pre_envel_group R} : rack.pre_envel_group_rel' R a b â†’ rack.to_envel_group.map_aux f a = rack.to_envel_group.map_aux f b
theorem fintype.card_of_is_empty {Î± : Type u_1} [is_empty Î±] : fintype.card Î± = 0
theorem finset.weighted_vsub_of_point_insert {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {Î¹ : Type u_4} (s : finset Î¹) [decidable_eq Î¹] (w : Î¹ â†’ k) (p : Î¹ â†’ P) (i : Î¹) : â‡‘((has_insert.insert i s).weighted_vsub_of_point p (p i)) w = â‡‘(s.weighted_vsub_of_point p (p i)) w
theorem real_inner_eq_norm_mul_self_add_norm_mul_self_sub_norm_sub_mul_self_div_two {F : Type u_3} [inner_product_space â„ F] (x y : F) : has_inner.inner x y = (âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + âˆ¥yâˆ¥ * âˆ¥yâˆ¥ - âˆ¥x - yâˆ¥ * âˆ¥x - yâˆ¥) / 2
theorem matrix.to_lin_eq_to_lin' {R : Type u_1} [comm_semiring R] {m : Type u_3} {n : Type u_4} [fintype n] [fintype m] [decidable_eq n] : matrix.to_lin (pi.basis_fun R n) (pi.basis_fun R m) = matrix.to_lin'
theorem odd.nat_abs {n : â„¤} : odd n â†’ odd n.nat_abs
theorem power_basis.trace_gen_eq_next_coeff_minpoly {S : Type u_2} [comm_ring S] {K : Type u_4} [field K] [algebra K S] [nontrivial S] (pb : power_basis K S) : â‡‘(algebra.trace K S) pb.gen = -(minpoly K pb.gen).next_coeff
theorem card_class_group_eq_one {R : Type u_1} {K : Type u_2} [comm_ring R] [field K] [algebra R K] [is_fraction_ring R K] [is_domain R] [is_principal_ideal_ring R] : fintype.card (class_group R K) = 1
theorem pSet.equiv.eq {x y : pSet} : x.equiv y â†” x.to_set = y.to_set
theorem ennreal.sum_eq_top_iff {Î± : Type u_1} {s : finset Î±} {f : Î± â†’ ennreal} : s.sum (Î» (x : Î±), f x) = âŠ¤ â†” âˆƒ (a : Î±) (H : a âˆˆ s), f a = âŠ¤
theorem probability_theory.indep_fun.integral_mul_of_nonneg {Î± : Type u_1} {mÎ± : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {X Y : Î± â†’ â„} (hXY : probability_theory.indep_fun X Y Î¼) (hXp : 0 â‰¤ X) (hYp : 0 â‰¤ Y) (hXm : ae_measurable X Î¼) (hYm : ae_measurable Y Î¼) : measure_theory.integral Î¼ (X * Y) = measure_theory.integral Î¼ X * measure_theory.integral Î¼ Y
theorem convex_on.set_average_mem_epigraph {Î± : Type u_1} {E : Type u_2} {m0 : measurable_space Î±} [normed_group E] [normed_space â„ E] [complete_space E] {Î¼ : measure_theory.measure Î±} {s : set E} {t : set Î±} {f : Î± â†’ E} {g : E â†’ â„} (hg : convex_on â„ s g) (hgc : continuous_on g s) (hsc : is_closed s) (h0 : â‡‘Î¼ t â‰  0) (ht : â‡‘Î¼ t â‰  âŠ¤) (hfs : âˆ€áµ (x : Î±) âˆ‚Î¼.restrict t, f x âˆˆ s) (hfi : measure_theory.integrable_on f t Î¼) (hgi : measure_theory.integrable_on (g âˆ˜ f) t Î¼) : (â¨ (x : Î±) in t, f x âˆ‚Î¼, â¨ (x : Î±) in t, g (f x) âˆ‚Î¼) âˆˆ {p : E Ã— â„ | p.fst âˆˆ s âˆ§ g p.fst â‰¤ p.snd}
theorem filter.tendsto.neg_mul_at_top {Î± : Type u} {Î² : Type v} [linear_ordered_field Î±] [topological_space Î±] [order_topology Î±] {l : filter Î²} {f g : Î² â†’ Î±} {C : Î±} (hC : C < 0) (hf : filter.tendsto f l (nhds C)) (hg : filter.tendsto g l filter.at_top) : filter.tendsto (Î» (x : Î²), f x * g x) l filter.at_bot
theorem measure_theory.lintegral_le_of_forall_fin_meas_le {Î± : Type u_1} [measurable_space Î±] {Î¼ : measure_theory.measure Î±} [measure_theory.sigma_finite Î¼] (C : ennreal) {f : Î± â†’ ennreal} (hf_meas : ae_measurable f Î¼) (hf : âˆ€ (s : set Î±), measurable_set s â†’ â‡‘Î¼ s â‰  âŠ¤ â†’ âˆ«â» (x : Î±) in s, f x âˆ‚Î¼ â‰¤ C) : âˆ«â» (x : Î±), f x âˆ‚Î¼ â‰¤ C
theorem units.is_regular {R : Type u_1} [monoid R] (a : RË£) : is_regular â†‘a
theorem not_covby {Î± : Type u_1} [has_lt Î±] {a b : Î±} [densely_ordered Î±] : Â¬a â‹– b
theorem category_theory.cosimplicial_object.Î´_comp_Ïƒ_self {C : Type u} [category_theory.category C] (X : category_theory.cosimplicial_object C) {n : â„•} {i : fin (n + 1)} : X.Î´ (â‡‘fin.cast_succ i) â‰« X.Ïƒ i = ğŸ™ (X.obj (simplex_category.mk n))
theorem lie_ideal.comap_bracket_incl_of_le {R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] (I : lie_ideal R L) {Iâ‚ Iâ‚‚ : lie_ideal R L} (hâ‚ : Iâ‚ â‰¤ I) (hâ‚‚ : Iâ‚‚ â‰¤ I) : â…lie_ideal.comap I.incl Iâ‚,lie_ideal.comap I.incl Iâ‚‚â† = lie_ideal.comap I.incl â…Iâ‚,Iâ‚‚â†
theorem euclidean_geometry.orthogonal_projection_linear {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace â„ P} [nonempty â†¥s] [complete_space â†¥(s.direction)] : (euclidean_geometry.orthogonal_projection s).linear = â†‘(orthogonal_projection s.direction)
theorem is_compact_sphere {Î± : Type u_1} [pseudo_metric_space Î±] [proper_space Î±] (x : Î±) (r : â„) : is_compact (metric.sphere x r)
theorem add_con.inf_def {M : Type u_1} [has_add M] {c d : add_con M} : setoid.r = setoid.r âŠ“ setoid.r
theorem con.zpow {M : Type u_1} [group M] (c : con M) (n : â„¤) {w x : M} : â‡‘c w x â†’ â‡‘c (w ^ n) (x ^ n)
theorem measure_theory.tendsto_integral_filter_of_dominated_convergence {Î± : Type u_1} {E : Type u_2} [normed_group E] [normed_space â„ E] [complete_space E] {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {Î¹ : Type u_3} {l : filter Î¹} [l.is_countably_generated] {F : Î¹ â†’ Î± â†’ E} {f : Î± â†’ E} (bound : Î± â†’ â„) (hF_meas : âˆ€á¶  (n : Î¹) in l, measure_theory.ae_strongly_measurable (F n) Î¼) (h_bound : âˆ€á¶  (n : Î¹) in l, âˆ€áµ (a : Î±) âˆ‚Î¼, âˆ¥F n aâˆ¥ â‰¤ bound a) (bound_integrable : measure_theory.integrable bound Î¼) (h_lim : âˆ€áµ (a : Î±) âˆ‚Î¼, filter.tendsto (Î» (n : Î¹), F n a) l (nhds (f a))) : filter.tendsto (Î» (n : Î¹), âˆ« (a : Î±), F n a âˆ‚Î¼) l (nhds (âˆ« (a : Î±), f a âˆ‚Î¼))
theorem mem_nhds_within_Ioi_iff_exists_Ioc_subset {Î± : Type u} [topological_space Î±] [linear_order Î±] [order_topology Î±] [no_max_order Î±] [densely_ordered Î±] {a : Î±} {s : set Î±} : s âˆˆ nhds_within a (set.Ioi a) â†” âˆƒ (u : Î±) (H : u âˆˆ set.Ioi a), set.Ioc a u âŠ† s
theorem finset.card_insert_eq_ite {Î± : Type u_1} {s : finset Î±} {a : Î±} [decidable_eq Î±] : (has_insert.insert a s).card = ite (a âˆˆ s) s.card (s.card + 1)
theorem neg_ray_of_ne_zero (R : Type u_1) [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] (v : M) (h : v â‰  0) : -ray_of_ne_zero R v h = ray_of_ne_zero R (-v) _
theorem isometry.diam_image {Î± : Type u} {Î² : Type v} [pseudo_metric_space Î±] [pseudo_metric_space Î²] {f : Î± â†’ Î²} (hf : isometry f) (s : set Î±) : metric.diam (f '' s) = metric.diam s
theorem subfield.sub_mem {K : Type u} [field K] (s : subfield K) {x y : K} : x âˆˆ s â†’ y âˆˆ s â†’ x - y âˆˆ s
theorem mv_polynomial.C_dvd_iff_zmod {Ïƒ : Type u_1} (n : â„•) (Ï† : mv_polynomial Ïƒ â„¤) : â‡‘mv_polynomial.C â†‘n âˆ£ Ï† â†” â‡‘(mv_polynomial.map (int.cast_ring_hom (zmod n))) Ï† = 0
theorem char.quadratic_char_one_iff_is_square {F : Type u_1} [field F] [fintype F] [decidable_eq F] {a : F} (ha : a â‰  0) : char.quadratic_char F a = 1 â†” is_square a
theorem is_add_unit.is_add_regular {R : Type u_1} {a : R} [add_monoid R] (ua : is_add_unit a) : is_add_regular a
theorem intermediate_value_Icc {Î± : Type u} [conditionally_complete_linear_order Î±] [topological_space Î±] [order_topology Î±] [densely_ordered Î±] {Î´ : Type u_1} [linear_order Î´] [topological_space Î´] [order_closed_topology Î´] {a b : Î±} (hab : a â‰¤ b) {f : Î± â†’ Î´} (hf : continuous_on f (set.Icc a b)) : set.Icc (f a) (f b) âŠ† f '' set.Icc a b
theorem list.head_le_sum (L : list â„•) : L.head â‰¤ L.sum
theorem set.image_image2_right_comm {Î± : Type u_1} {Î² : Type u_3} {Î²' : Type u_4} {Î³ : Type u_5} {Î´ : Type u_7} {s : set Î±} {t : set Î²} {f : Î± â†’ Î²' â†’ Î³} {g : Î² â†’ Î²'} {f' : Î± â†’ Î² â†’ Î´} {g' : Î´ â†’ Î³} (h_right_comm : âˆ€ (a : Î±) (b : Î²), f a (g b) = g' (f' a b)) : set.image2 f s (g '' t) = g' '' set.image2 f' s t
theorem module.End.eigenspace_restrict_le_eigenspace {R : Type v} {M : Type w} [comm_ring R] [add_comm_group M] [module R M] (f : module.End R M) {p : submodule R M} (hfp : âˆ€ (x : M), x âˆˆ p â†’ â‡‘f x âˆˆ p) (Î¼ : R) : submodule.map p.subtype (module.End.eigenspace (linear_map.restrict f hfp) Î¼) â‰¤ f.eigenspace Î¼
theorem is_submonoid_Union_of_directed {M : Type u_1} [monoid M] {Î¹ : Type u_2} [hÎ¹ : nonempty Î¹] {s : Î¹ â†’ set M} (hs : âˆ€ (i : Î¹), is_submonoid (s i)) (directed : âˆ€ (i j : Î¹), âˆƒ (k : Î¹), s i âŠ† s k âˆ§ s j âŠ† s k) : is_submonoid (â‹ƒ (i : Î¹), s i)
theorem filter.tendsto.op_zero_is_bounded_under_le {Î± : Type u_1} {E : Type u_3} {F : Type u_4} {G : Type u_5} [semi_normed_group E] [semi_normed_group F] [semi_normed_group G] {f : Î± â†’ E} {g : Î± â†’ F} {l : filter Î±} (hf : filter.tendsto f l (nhds 0)) (hg : filter.is_bounded_under has_le.le l (has_norm.norm âˆ˜ g)) (op : E â†’ F â†’ G) (h_op : âˆ€ (x : E) (y : F), âˆ¥op x yâˆ¥ â‰¤ âˆ¥xâˆ¥ * âˆ¥yâˆ¥) : filter.tendsto (Î» (x : Î±), op (f x) (g x)) l (nhds 0)
theorem has_deriv_within_at.liminf_right_slope_norm_le {E : Type u} [normed_group E] [normed_space â„ E] {f : â„ â†’ E} {f' : E} {x r : â„} (hf : has_deriv_within_at f f' (set.Ici x) x) (hr : âˆ¥f'âˆ¥ < r) : âˆƒá¶  (z : â„) in nhds_within x (set.Ioi x), (z - x)â»Â¹ * (âˆ¥f zâˆ¥ - âˆ¥f xâˆ¥) < r
theorem algebraic_geometry.PresheafedSpace.glue_data.f_inv_app_f_app {C : Type u} [category_theory.category C] (D : algebraic_geometry.PresheafedSpace.glue_data C) (i j k : D.to_glue_data.J) (U : topological_space.opens â†¥((D.to_glue_data.V (i, j)).carrier)) : _.inv_app U â‰« (D.to_glue_data.f i k).c.app (opposite.op (_.open_functor.obj U)) = category_theory.limits.pullback.fst.c.app (opposite.op U) â‰« _.inv_app (opposite.unop ((topological_space.opens.map category_theory.limits.pullback.fst.base).op.obj (opposite.op U))) â‰« (D.to_glue_data.V (i, k)).presheaf.map (category_theory.eq_to_hom _)
theorem add_submonoid.closure_le {M : Type u_1} [add_zero_class M] {s : set M} {S : add_submonoid M} : add_submonoid.closure s â‰¤ S â†” s âŠ† â†‘S
theorem asymptotics.is_O.of_norm_left {Î± : Type u_1} {F : Type u_4} {E' : Type u_6} [has_norm F] [semi_normed_group E'] {g : Î± â†’ F} {f' : Î± â†’ E'} {l : filter Î±} : (Î» (x : Î±), âˆ¥f' xâˆ¥) =O[l] g â†’ f' =O[l] g
theorem same_ray_map_iff {R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {N : Type u_3} [add_comm_monoid N] [module R N] {x y : M} (e : M â‰ƒâ‚—[R] N) : same_ray R (â‡‘e x) (â‡‘e y) â†” same_ray R x y
theorem with_top.sum_lt_top {Î¹ : Type u_1} {M : Type u_4} [ordered_add_comm_monoid M] {s : finset Î¹} {f : Î¹ â†’ with_top M} (h : âˆ€ (i : Î¹), i âˆˆ s â†’ f i â‰  âŠ¤) : s.sum (Î» (i : Î¹), f i) < âŠ¤
theorem exists_lt_of_cInf_lt {Î± : Type u_1} [conditionally_complete_linear_order Î±] {s : set Î±} {b : Î±} (hs : s.nonempty) (hb : has_Inf.Inf s < b) : âˆƒ (a : Î±) (H : a âˆˆ s), a < b
theorem contracting_with.restrict {Î± : Type u_1} [emetric_space Î±] {K : nnreal} {f : Î± â†’ Î±} (hf : contracting_with K f) {s : set Î±} (hs : set.maps_to f s s) : contracting_with K (set.maps_to.restrict f s s hs)
theorem set.finite.compact_convex_hull {E : Type u_2} [add_comm_group E] [module â„ E] [topological_space E] [topological_add_group E] [has_continuous_smul â„ E] {s : set E} (hs : s.finite) : is_compact (â‡‘(convex_hull â„) s)
theorem subgroup.closure_mul_image_eq {G : Type u_1} [group G] {H : subgroup G} {R S : set G} (hR : R âˆˆ subgroup.right_transversals â†‘H) (hR1 : 1 âˆˆ R) (hS : subgroup.closure S = âŠ¤) : subgroup.closure ((Î» (g : G), g * (â†‘(subgroup.mem_right_transversals.to_fun hR g))â»Â¹) '' (R * S)) = H
theorem metric.second_countable_of_almost_dense_set {Î± : Type u} [pseudo_metric_space Î±] (H : âˆ€ (Îµ : â„), Îµ > 0 â†’ (âˆƒ (s : set Î±), s.countable âˆ§ âˆ€ (x : Î±), âˆƒ (y : Î±) (H : y âˆˆ s), has_dist.dist x y â‰¤ Îµ)) : topological_space.second_countable_topology Î±
theorem interval_integral.integral_has_fderiv_within_at_of_tendsto_ae {E : Type u_3} [normed_group E] [complete_space E] [normed_space â„ E] {f : â„ â†’ E} {ca cb : E} {la lb : filter â„} {a b : â„} (hf : interval_integrable f measure_theory.measure_space.volume a b) {s t : set â„} [interval_integral.FTC_filter a (nhds_within a s) la] [interval_integral.FTC_filter b (nhds_within b t) lb] (hmeas_a : strongly_measurable_at_filter f la measure_theory.measure_space.volume) (hmeas_b : strongly_measurable_at_filter f lb measure_theory.measure_space.volume) (ha : filter.tendsto f (la âŠ“ measure_theory.measure_space.volume.ae) (nhds ca)) (hb : filter.tendsto f (lb âŠ“ measure_theory.measure_space.volume.ae) (nhds cb)) : has_fderiv_within_at (Î» (p : â„ Ã— â„), âˆ« (x : â„) in p.fst..p.snd, f x) ((continuous_linear_map.snd â„ â„ â„).smul_right cb - (continuous_linear_map.fst â„ â„ â„).smul_right ca) (s Ã—Ë¢ t) (a, b)
theorem vector.scanl_nth {n : â„•} {Î± : Type u_1} {Î² : Type u_2} (f : Î² â†’ Î± â†’ Î²) (b : Î²) (v : vector Î± n) (i : fin n) : (vector.scanl f b v).nth i.succ = f ((vector.scanl f b v).nth (â‡‘fin.cast_succ i)) (v.nth i)
theorem normed_space.dual.dual_norm_topology_le_weak_dual_topology {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [semi_normed_group E] [normed_space ğ•œ E] : uniform_space.to_topological_space â‰¤ weak_dual.topological_space ğ•œ E
theorem cont_diff_on_top_iff_fderiv_within {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {s : set E} {f : E â†’ F} (hs : unique_diff_on ğ•œ s) : cont_diff_on ğ•œ âŠ¤ f s â†” differentiable_on ğ•œ f s âˆ§ cont_diff_on ğ•œ âŠ¤ (Î» (y : E), fderiv_within ğ•œ f s y) s
theorem is_ring_hom.map_zero {Î± : Type u} {Î² : Type v} [ring Î±] [ring Î²] {f : Î± â†’ Î²} (hf : is_ring_hom f) : f 0 = 0
theorem convex.average_mem_interior_of_set {Î± : Type u_1} {E : Type u_2} {m0 : measurable_space Î±} [normed_group E] [normed_space â„ E] [complete_space E] {Î¼ : measure_theory.measure Î±} {s : set E} {t : set Î±} {f : Î± â†’ E} [measure_theory.is_finite_measure Î¼] (hs : convex â„ s) (h0 : â‡‘Î¼ t â‰  0) (hfs : âˆ€áµ (x : Î±) âˆ‚Î¼, f x âˆˆ s) (hfi : measure_theory.integrable f Î¼) (ht : â¨ (x : Î±) in t, f x âˆ‚Î¼ âˆˆ interior s) : â¨ (x : Î±), f x âˆ‚Î¼ âˆˆ interior s
theorem monoid_hom.eq_on_closure {G : Type u_1} [group G] {N : Type u_3} [group N] {f g : G â†’* N} {s : set G} (h : set.eq_on â‡‘f â‡‘g s) : set.eq_on â‡‘f â‡‘g â†‘(subgroup.closure s)
theorem alternating_map.dom_coprod.summand_eq_zero_of_smul_invariant {Î¹a : Type u_7} {Î¹b : Type u_8} [decidable_eq Î¹a] [decidable_eq Î¹b] [fintype Î¹a] [fintype Î¹b] {R' : Type u_9} {Máµ¢ : Type u_10} {Nâ‚ : Type u_11} {Nâ‚‚ : Type u_12} [comm_semiring R'] [add_comm_group Nâ‚] [module R' Nâ‚] [add_comm_group Nâ‚‚] [module R' Nâ‚‚] [add_comm_monoid Máµ¢] [module R' Máµ¢] (a : alternating_map R' Máµ¢ Nâ‚ Î¹a) (b : alternating_map R' Máµ¢ Nâ‚‚ Î¹b) (Ïƒ : equiv.perm.mod_sum_congr Î¹a Î¹b) {v : Î¹a âŠ• Î¹b â†’ Máµ¢} {i j : Î¹a âŠ• Î¹b} (hv : v i = v j) (hij : i â‰  j) : equiv.swap i j â€¢ Ïƒ = Ïƒ â†’ â‡‘(alternating_map.dom_coprod.summand a b Ïƒ) v = 0
theorem cinfi_eq_of_forall_ge_of_forall_gt_exists_lt {Î± : Type u_1} {Î¹ : Sort u_3} [conditionally_complete_lattice Î±] {b : Î±} [nonempty Î¹] {f : Î¹ â†’ Î±} (hâ‚ : âˆ€ (i : Î¹), b â‰¤ f i) (hâ‚‚ : âˆ€ (w : Î±), b < w â†’ (âˆƒ (i : Î¹), f i < w)) : (â¨… (i : Î¹), f i) = b
theorem mul_action.card_orbit_mul_card_stabilizer_eq_card_group (Î± : Type u) {Î² : Type v} [group Î±] [mul_action Î± Î²] (b : Î²) [fintype Î±] [fintype â†¥(mul_action.orbit Î± b)] [fintype â†¥(mul_action.stabilizer Î± b)] : fintype.card â†¥(mul_action.orbit Î± b) * fintype.card â†¥(mul_action.stabilizer Î± b) = fintype.card Î±
theorem ennreal.mul_infi {Î¹ : Sort u_1} [nonempty Î¹] {f : Î¹ â†’ ennreal} {x : ennreal} (h : x â‰  âŠ¤) : x * infi f = â¨… (i : Î¹), x * f i
theorem matrix.cons_val_one {Î± : Type u} {m : â„•} (x : Î±) (u : fin m.succ â†’ Î±) : matrix.vec_cons x u 1 = matrix.vec_head u
theorem set.pairwise_disjoint.sup_indep {Î± : Type u_1} {Î¹ : Type u_3} [distrib_lattice Î±] [order_bot Î±] {s : finset Î¹} {f : Î¹ â†’ Î±} : â†‘s.pairwise_disjoint f â†’ s.sup_indep f
theorem function.injective.nontrivial {Î± : Type u_1} {Î² : Type u_2} [nontrivial Î±] {f : Î± â†’ Î²} (hf : function.injective f) : nontrivial Î²
theorem tendsto_rpow_neg_at_top {y : â„} (hy : 0 < y) : filter.tendsto (Î» (x : â„), x ^ -y) filter.at_top (nhds 0)
theorem vsub_sub_vsub_cancel_left {G : Type u_1} {P : Type u_2} [add_comm_group G] [add_torsor G P] (p1 p2 p3 : P) : p3 -áµ¥ p2 - (p3 -áµ¥ p1) = p1 -áµ¥ p2
theorem subgroup.exists_left_complement'_of_coprime_of_fintype {G : Type u} [group G] [fintype G] {N : subgroup G} [N.normal] (hN : (fintype.card â†¥N).coprime N.index) : âˆƒ (H : subgroup G), H.is_complement' N
theorem monotone_of_deriv_nonneg {f : â„ â†’ â„} (hf : differentiable â„ f) (hf' : âˆ€ (x : â„), 0 â‰¤ deriv f x) : monotone f
theorem colex.sdiff_lt_sdiff_iff_lt {Î± : Type u_1} [has_lt Î±] [decidable_eq Î±] (A B : finset Î±) : (A  B).to_colex < (B  A).to_colex â†” A.to_colex < B.to_colex
theorem nat.choose_le_middle (r n : â„•) : n.choose r â‰¤ n.choose (n / 2)
theorem local_ring.of_nonunits_add {R : Type u} [comm_semiring R] [nontrivial R] (h : âˆ€ (a b : R), a âˆˆ nonunits R â†’ b âˆˆ nonunits R â†’ a + b âˆˆ nonunits R) : local_ring R
theorem strict_convex_iff_div {ğ•œ : Type u_1} {E : Type u_3} [linear_ordered_field ğ•œ] [topological_space E] [add_comm_group E] [module ğ•œ E] {s : set E} : strict_convex ğ•œ s â†” s.pairwise (Î» (x y : E), âˆ€ â¦ƒa b : ğ•œâ¦„, 0 < a â†’ 0 < b â†’ (a / (a + b)) â€¢ x + (b / (a + b)) â€¢ y âˆˆ interior s)
theorem polynomial.cyclotomic_eq_prod_X_sub_primitive_roots {K : Type u_1} [comm_ring K] [is_domain K] {Î¶ : K} {n : â„•} (hz : is_primitive_root Î¶ n) : polynomial.cyclotomic n K = (primitive_roots n K).prod (Î» (Î¼ : K), polynomial.X - â‡‘polynomial.C Î¼)
theorem affine.simplex.orthogonal_projection_eq_circumcenter_of_dist_eq {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {n : â„•} (s : affine.simplex â„ P n) {p : P} {r : â„} (hr : âˆ€ (i : fin (n + 1)), has_dist.dist (s.points i) p = r) : â†‘(â‡‘(s.orthogonal_projection_span) p) = s.circumcenter
theorem is_add_monoid_hom.id {Î± : Type u} [add_zero_class Î±] : is_add_monoid_hom id
theorem finset.prod_range_div {M : Type u_1} [comm_group M] (f : â„• â†’ M) (n : â„•) : (finset.range n).prod (Î» (i : â„•), f (i + 1) * (f i)â»Â¹) = f n * (f 0)â»Â¹
theorem vector_span_image_eq_span_vsub_set_left_ne (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {Î¹ : Type u_4} (p : Î¹ â†’ P) {s : set Î¹} {i : Î¹} (hi : i âˆˆ s) : vector_span k (p '' s) = submodule.span k (has_vsub.vsub (p i) '' (p '' (s  {i})))
theorem function.injective.nat_tendsto_at_top {f : â„• â†’ â„•} (hf : function.injective f) : filter.tendsto f filter.at_top filter.at_top
theorem self_adjoint.coe_re_map_spectrum' {A : Type u_1} [normed_ring A] [normed_algebra â„‚ A] [complete_space A] [star_ring A] [cstar_ring A] [star_module â„‚ A] [nontrivial A] (a : â†¥(self_adjoint A)) : spectrum â„‚ â†‘a = coe âˆ˜ complex.re '' spectrum â„‚ â†‘a
theorem category_theory.sheaf.is_sheaf_of_representable {C : Type u} [category_theory.category C] (P : Cáµ’áµ– â¥¤ Type v) [P.representable] : category_theory.presieve.is_sheaf (category_theory.sheaf.canonical_topology C) P
theorem finset.card_powerset_len {Î± : Type u_1} (n : â„•) (s : finset Î±) : (finset.powerset_len n s).card = s.card.choose n
theorem add_monoid_algebra.support_gen_of_gen {R : Type u_1} {M : Type u_2} [comm_semiring R] [add_monoid M] {S : set (add_monoid_algebra R M)} (hS : algebra.adjoin R S = âŠ¤) : algebra.adjoin R (â‹ƒ (f : add_monoid_algebra R M) (H : f âˆˆ S), add_monoid_algebra.of' R M '' â†‘(f.support)) = âŠ¤
theorem module.free.rank_eq_card_choose_basis_index (R : Type u) (M : Type v) [ring R] [strong_rank_condition R] [add_comm_group M] [module R M] [module.free R M] : module.rank R M = cardinal.mk (module.free.choose_basis_index R M)
theorem cont_diff_on.differentiable_on_iterated_deriv_within {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {F : Type u_2} [normed_group F] [normed_space ğ•œ F] {f : ğ•œ â†’ F} {s : set ğ•œ} {n : with_top â„•} {m : â„•} (h : cont_diff_on ğ•œ n f s) (hmn : â†‘m < n) (hs : unique_diff_on ğ•œ s) : differentiable_on ğ•œ (iterated_deriv_within m f s) s
theorem affine_map.decomp' {k : Type u_1} {V1 : Type u_2} {V2 : Type u_4} [ring k] [add_comm_group V1] [module k V1] [add_comm_group V2] [module k V2] (f : V1 â†’áµƒ[k] V2) : â‡‘(f.linear) = â‡‘f - Î» (z : V1), â‡‘f 0
theorem vector.singleton_tail {Î± : Type u_1} (v : vector Î± 1) : v.tail = vector.nil
theorem differentiable.exists_const_forall_eq_of_bounded {E : Type u} [normed_group E] [normed_space â„‚ E] {F : Type v} [normed_group F] [normed_space â„‚ F] {f : E â†’ F} (hf : differentiable â„‚ f) (hb : metric.bounded (set.range f)) : âˆƒ (c : F), âˆ€ (z : E), f z = c
theorem orthonormal.inner_right_sum {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {Î¹ : Type u_4} {v : Î¹ â†’ E} (hv : orthonormal ğ•œ v) (l : Î¹ â†’ ğ•œ) {s : finset Î¹} {i : Î¹} (hi : i âˆˆ s) : has_inner.inner (v i) (s.sum (Î» (i : Î¹), l i â€¢ v i)) = l i
theorem is_localization.ring_hom_ext {R : Type u_1} [comm_semiring R] (M : submonoid R) {S : Type u_2} [comm_semiring S] [algebra R S] {P : Type u_3} [comm_semiring P] [is_localization M S] â¦ƒj k : S â†’+* Pâ¦„ (h : j.comp (algebra_map R S) = k.comp (algebra_map R S)) : j = k
theorem is_primitive_root.is_root_cyclotomic {R : Type u_1} {n : â„•} [comm_ring R] [is_domain R] (hpos : 0 < n) {Î¼ : R} (h : is_primitive_root Î¼ n) : (polynomial.cyclotomic n R).is_root Î¼
theorem metric.Hausdorff_dist_closureâ‚‚ {Î± : Type u} [pseudo_metric_space Î±] {s t : set Î±} : metric.Hausdorff_dist s (closure t) = metric.Hausdorff_dist s t
theorem measure_theory.measure.eq_singular_part {Î± : Type u_1} {m : measurable_space Î±} {Î¼ Î½ s : measure_theory.measure Î±} {f : Î± â†’ ennreal} (hf : measurable f) (hs : s.mutually_singular Î½) (hadd : Î¼ = s + Î½.with_density f) : s = Î¼.singular_part Î½
theorem is_localization.is_prime_iff_is_prime_disjoint {R : Type u_1} [comm_semiring R] (M : submonoid R) (S : Type u_2) [comm_semiring S] [algebra R S] [is_localization M S] (J : ideal S) : J.is_prime â†” (ideal.comap (algebra_map R S) J).is_prime âˆ§ disjoint â†‘M â†‘(ideal.comap (algebra_map R S) J)
theorem Top.presheaf.is_sheaf_unique_gluing_of_is_sheaf_types {X : Top} (F : Top.presheaf (Type v) X) (Fsh : F.is_sheaf) : F.is_sheaf_unique_gluing
theorem finset.exists_lt_sum_fiber_of_sum_fiber_nonpos_of_nsmul_lt_sum {Î± : Type u} {Î² : Type v} {M : Type w} [decidable_eq Î²] {s : finset Î±} {t : finset Î²} {f : Î± â†’ Î²} {w : Î± â†’ M} {b : M} [linear_ordered_cancel_add_comm_monoid M] (ht : âˆ€ (y : Î²), y âˆ‰ t â†’ (finset.filter (Î» (x : Î±), f x = y) s).sum (Î» (x : Î±), w x) â‰¤ 0) (hb : t.card â€¢ b < s.sum (Î» (x : Î±), w x)) : âˆƒ (y : Î²) (H : y âˆˆ t), b < (finset.filter (Î» (x : Î±), f x = y) s).sum (Î» (x : Î±), w x)
theorem convex.closure {E : Type u_2} {ğ•œ : Type u_3} [linear_ordered_field ğ•œ] [add_comm_group E] [module ğ•œ E] [topological_space E] [topological_add_group E] [has_continuous_const_smul ğ•œ E] {s : set E} (hs : convex ğ•œ s) : convex ğ•œ (closure s)
theorem tendsto_self_mul_const_pow_of_abs_lt_one {r : â„} (hr : |r| < 1) : filter.tendsto (Î» (n : â„•), â†‘n * r ^ n) filter.at_top (nhds 0)
theorem submodule.supr_induction {R : Type u_1} {M : Type u_4} [semiring R] [add_comm_monoid M] [module R M] {Î¹ : Sort u_2} (p : Î¹ â†’ submodule R M) {C : M â†’ Prop} {x : M} (hx : x âˆˆ â¨† (i : Î¹), p i) (hp : âˆ€ (i : Î¹) (x : M), x âˆˆ p i â†’ C x) (h0 : C 0) (hadd : âˆ€ (x y : M), C x â†’ C y â†’ C (x + y)) : C x
theorem colex.sdiff_le_sdiff_iff_le {Î± : Type u_1} [linear_order Î±] (A B : finset Î±) : (A  B).to_colex â‰¤ (B  A).to_colex â†” A.to_colex â‰¤ B.to_colex
theorem local_homeomorph.is_image.preimage_eq' {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] {e : local_homeomorph Î± Î²} {s : set Î±} {t : set Î²} : e.is_image s t â†’ e.to_local_equiv.source âˆ© â‡‘e â»Â¹' (e.to_local_equiv.target âˆ© t) = e.to_local_equiv.source âˆ© s
theorem basis.ext_multilinear {R : Type u_1} {Î¹ : Type u_2} {Mâ‚‚ : Type u_4} {Mâ‚ƒ : Type u_5} [comm_semiring R] [add_comm_monoid Mâ‚‚] [add_comm_monoid Mâ‚ƒ] [module R Mâ‚‚] [module R Mâ‚ƒ] [decidable_eq Î¹] [fintype Î¹] {f g : multilinear_map R (Î» (i : Î¹), Mâ‚‚) Mâ‚ƒ} {Î¹â‚ : Type u_3} (e : basis Î¹â‚ R Mâ‚‚) (h : âˆ€ (v : Î¹ â†’ Î¹â‚), â‡‘f (Î» (i : Î¹), â‡‘e (v i)) = â‡‘g (Î» (i : Î¹), â‡‘e (v i))) : f = g
theorem ratfunc.eval_add {K : Type u} [hfield : field K] {L : Type u_1} [field L] (f : K â†’+* L) (a : L) {x y : ratfunc K} (hx : polynomial.evalâ‚‚ f a x.denom â‰  0) (hy : polynomial.evalâ‚‚ f a y.denom â‰  0) : ratfunc.eval f a (x + y) = ratfunc.eval f a x + ratfunc.eval f a y
theorem is_compact.compl_mem_sets {Î± : Type u} [topological_space Î±] {s : set Î±} (hs : is_compact s) {f : filter Î±} (hf : âˆ€ (a : Î±), a âˆˆ s â†’ sá¶œ âˆˆ nhds a âŠ“ f) : sá¶œ âˆˆ f
theorem Top.presheaf.germ_exist {C : Type u} [category_theory.category C] [category_theory.limits.has_colimits C] {X : Top} [category_theory.concrete_category C] [category_theory.limits.preserves_filtered_colimits (category_theory.forget C)] (F : Top.presheaf C X) (x : â†¥X) (t : â†¥(F.stalk x)) : âˆƒ (U : topological_space.opens â†¥X) (m : x âˆˆ U) (s : â†¥(F.obj (opposite.op U))), â‡‘(F.germ âŸ¨x, mâŸ©) s = t
theorem finset.exists_intermediate_set {Î± : Type u_1} {A B : finset Î±} (i : â„•) (hâ‚ : i + B.card â‰¤ A.card) (hâ‚‚ : B âŠ† A) : âˆƒ (C : finset Î±), B âŠ† C âˆ§ C âŠ† A âˆ§ C.card = i + B.card
theorem finite_dimensional.proper (ğ•œ : Type u) [nondiscrete_normed_field ğ•œ] (E : Type v) [normed_group E] [normed_space ğ•œ E] [proper_space ğ•œ] [finite_dimensional ğ•œ E] : proper_space E
theorem even_of_exists_two_nsmul {Î± : Type u_2} [add_monoid Î±] (m : Î±) : (âˆƒ (c : Î±), m = 2 â€¢ c) â†’ even m
theorem convex_on.le_on_segment' {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [ordered_semiring ğ•œ] [add_comm_monoid E] [linear_ordered_add_comm_monoid Î²] [has_scalar ğ•œ E] [module ğ•œ Î²] [ordered_smul ğ•œ Î²] {s : set E} {f : E â†’ Î²} (hf : convex_on ğ•œ s f) {x y : E} (hx : x âˆˆ s) (hy : y âˆˆ s) {a b : ğ•œ} (ha : 0 â‰¤ a) (hb : 0 â‰¤ b) (hab : a + b = 1) : f (a â€¢ x + b â€¢ y) â‰¤ linear_order.max (f x) (f y)
theorem submodule.inner_left_of_mem_orthogonal {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {K : submodule ğ•œ E} {u v : E} (hu : u âˆˆ K) (hv : v âˆˆ Ká—®) : has_inner.inner v u = 0
theorem cInf_le_cSup {Î± : Type u_1} [conditionally_complete_lattice Î±] {s : set Î±} (hb : bdd_below s) (ha : bdd_above s) (ne : s.nonempty) : has_Inf.Inf s â‰¤ has_Sup.Sup s
theorem set.image2_image_left_comm {Î± : Type u_1} {Î±' : Type u_2} {Î² : Type u_3} {Î³ : Type u_5} {Î´ : Type u_7} {s : set Î±} {t : set Î²} {f : Î±' â†’ Î² â†’ Î³} {g : Î± â†’ Î±'} {f' : Î± â†’ Î² â†’ Î´} {g' : Î´ â†’ Î³} (h_left_comm : âˆ€ (a : Î±) (b : Î²), f (g a) b = g' (f' a b)) : set.image2 f (g '' s) t = g' '' set.image2 f' s t
theorem category_theory.is_pullback.of_is_limit' {C : Type uâ‚} [category_theory.category C] {P X Y Z : C} {fst : P âŸ¶ X} {snd : P âŸ¶ Y} {f : X âŸ¶ Z} {g : Y âŸ¶ Z} (w : category_theory.comm_sq fst snd f g) (h : category_theory.limits.is_limit w.cone) : category_theory.is_pullback fst snd f g
theorem sub_le_self {Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± has_add.add has_le.le] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] (a : Î±) {b : Î±} : 0 â‰¤ b â†’ a - b â‰¤ a
theorem is_cyclotomic_extension.finrank {n : â„•+} {K : Type u} (L : Type v) [field K] [field L] [algebra K L] [is_cyclotomic_extension {n} K L] (hirr : irreducible (polynomial.cyclotomic â†‘n K)) [ne_zero â†‘â†‘n] : finite_dimensional.finrank K L = â†‘n.totient
theorem lie_submodule.ucs_le_of_centralizer_eq_self {R : Type u} {L : Type v} {M : Type w} [comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] {Nâ‚ : lie_submodule R L M} (h : Nâ‚.centralizer = Nâ‚) (k : â„•) : lie_submodule.ucs k âŠ¥ â‰¤ Nâ‚
theorem complex.to_matrix_conj_ae  : â‡‘(linear_map.to_matrix complex.basis_one_I complex.basis_one_I) complex.conj_ae.to_linear_map = ![![1, 0], ![0, -1]]
theorem is_primitive_root.norm_eq_one_of_linearly_ordered {n : â„•+} {L : Type v} [field L] {Î¶ : L} (hÎ¶ : is_primitive_root Î¶ â†‘n) {K : Type u_1} [linear_ordered_field K] [algebra K L] (hodd : odd â†‘n) : â‡‘(algebra.norm K) Î¶ = 1
theorem subgroup.comap_normalizer_eq_of_surjective {G : Type u_1} [group G] {N : Type u_3} [group N] (H : subgroup G) {f : N â†’* G} (hf : function.surjective â‡‘f) : subgroup.comap f H.normalizer = (subgroup.comap f H).normalizer
theorem add_con.lift_mk' {M : Type u_1} {P : Type u_3} [add_zero_class M] [add_zero_class P] {c : add_con M} {f : M â†’+ P} (H : c â‰¤ add_con.ker f) (x : M) : â‡‘(c.lift f H) (â‡‘(c.mk') x) = â‡‘f x
theorem inner_product_geometry.angle_zero_right {V : Type u_1} [inner_product_space â„ V] (x : V) : inner_product_geometry.angle x 0 = real.pi / 2
theorem category_theory.zigzag_obj_of_zigzag {J : Type uâ‚} [category_theory.category J] {K : Type uâ‚‚} [category_theory.category K] (F : J â¥¤ K) {jâ‚ jâ‚‚ : J} (h : category_theory.zigzag jâ‚ jâ‚‚) : category_theory.zigzag (F.obj jâ‚) (F.obj jâ‚‚)
theorem pi.sum_nnnorm_apply_le_nnnorm {Î¹ : Type u_2} {Ï€ : Î¹ â†’ Type u_1} [fintype Î¹] [Î  (i : Î¹), semi_normed_group (Ï€ i)] (x : Î  (i : Î¹), Ï€ i) : finset.univ.sum (Î» (i : Î¹), âˆ¥x iâˆ¥â‚Š) â‰¤ fintype.card Î¹ â€¢ âˆ¥xâˆ¥â‚Š
theorem module.ray.ind (R : Type u_1) [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {C : module.ray R M â†’ Prop} (h : âˆ€ (v : M) (hv : v â‰  0), C (ray_of_ne_zero R v hv)) (x : module.ray R M) : C x
theorem finset.centroid_eq_centroid_image_of_inj_on (k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] {Î¹ : Type u_4} (s : finset Î¹) {p : Î¹ â†’ P} (hi : âˆ€ (i : Î¹), i âˆˆ s â†’ âˆ€ (j : Î¹), j âˆˆ s â†’ p i = p j â†’ i = j) {ps : set P} [fintype â†¥ps] (hps : ps = p '' â†‘s) : finset.centroid k s p = finset.centroid k finset.univ (Î» (x : â†¥ps), â†‘x)
theorem liouville_with.irrational {p x : â„} (h : liouville_with p x) (hp : 1 < p) : irrational x
theorem is_add_regular_zero {R : Type u_1} [add_zero_class R] : is_add_regular 0
theorem fixing_subgroup_fixed_points_gc (M : Type u_1) (Î± : Type u_2) [group M] [mul_action M Î±] : galois_connection (â‡‘order_dual.to_dual âˆ˜ fixing_subgroup M) ((Î» (P : subgroup M), mul_action.fixed_points â†¥P Î±) âˆ˜ â‡‘order_dual.of_dual)
theorem affine_independent_def (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {Î¹ : Type u_4} (p : Î¹ â†’ P) : affine_independent k p â†” âˆ€ (s : finset Î¹) (w : Î¹ â†’ k), s.sum (Î» (i : Î¹), w i) = 0 â†’ â‡‘(s.weighted_vsub p) w = 0 â†’ âˆ€ (i : Î¹), i âˆˆ s â†’ w i = 0
theorem topological_add_group_of_lie_add_group {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {H : Type u_2} [topological_space H] {E : Type u_3} [normed_group E] [normed_space ğ•œ E] (I : model_with_corners ğ•œ E H) {G : Type u_5} [topological_space G] [charted_space H G] [add_group G] [lie_add_group I G] : topological_add_group G
theorem not_is_regular_zero {R : Type u_1} [mul_zero_class R] [nontrivial R] : Â¬is_regular 0
theorem cont_diff_within_at.differentiable_within_at' {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {s : set E} {f : E â†’ F} {x : E} {n : with_top â„•} (h : cont_diff_within_at ğ•œ n f s x) (hn : 1 â‰¤ n) : differentiable_within_at ğ•œ f (has_insert.insert x s) x
theorem exists_open_superset_and_is_compact_closure {Î± : Type u} [topological_space Î±] [locally_compact_space Î±] [t2_space Î±] {K : set Î±} (hK : is_compact K) : âˆƒ (V : set Î±), is_open V âˆ§ K âŠ† V âˆ§ is_compact (closure V)
theorem uniform_cauchy_seq_on.tendsto_uniformly_on_of_tendsto {Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_4} [uniform_space Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : set Î±} {p : filter Î¹} [p.ne_bot] (hF : uniform_cauchy_seq_on F p s) (hF' : âˆ€ (x : Î±), x âˆˆ s â†’ filter.tendsto (Î» (n : Î¹), F n x) p (nhds (f x))) : tendsto_uniformly_on F f p s
theorem emetric.inf_edist_closure {Î± : Type u} [pseudo_emetric_space Î±] {x : Î±} {s : set Î±} : emetric.inf_edist x (closure s) = emetric.inf_edist x s
theorem filter.has_basis_infi_principal_finite {Î± : Type u_1} {Î¹ : Type u_2} (s : Î¹ â†’ set Î±) : (â¨… (i : Î¹), filter.principal (s i)).has_basis (Î» (t : set Î¹), t.finite) (Î» (t : set Î¹), â‹‚ (i : Î¹) (H : i âˆˆ t), s i)
theorem complex.circle_integral_sub_center_inv_smul_of_differentiable_on_off_countable_of_tendsto {E : Type u} [normed_group E] [normed_space â„‚ E] [complete_space E] {c : â„‚} {R : â„} (h0 : 0 < R) {f : â„‚ â†’ E} {y : E} {s : set â„‚} (hs : s.countable) (hc : continuous_on f (metric.closed_ball c R  {c})) (hd : âˆ€ (z : â„‚), z âˆˆ metric.ball c R  {c}  s â†’ differentiable_at â„‚ f z) (hy : filter.tendsto f (nhds_within c {c}á¶œ) (nhds y)) : âˆ® (z : â„‚) in C(c, R), (z - c)â»Â¹ â€¢ f z = (2 * â†‘real.pi * complex.I) â€¢ y
theorem measurable_set.measure_eq_supr_is_compact_of_ne_top {Î± : Type u_1} [measurable_space Î±] [topological_space Î±] {Î¼ : measure_theory.measure Î±} [Î¼.regular] â¦ƒA : set Î±â¦„ (hA : measurable_set A) (h'A : â‡‘Î¼ A â‰  âŠ¤) : â‡‘Î¼ A = â¨† (K : set Î±) (H : K âŠ† A) (h : is_compact K), â‡‘Î¼ K
theorem left.add_pos_of_nonneg_of_pos {Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b : Î±} (ha : 0 â‰¤ a) (hb : 0 < b) : 0 < a + b
theorem implies.trans {p q r : Prop} (hâ‚ : implies p q) (hâ‚‚ : implies q r) : implies p r
theorem integral_closure_map_alg_equiv {R : Type u_1} {A : Type u_2} {B : Type u_3} [comm_ring R] [comm_ring A] [comm_ring B] [algebra R A] [algebra R B] (f : A â‰ƒâ‚[R] B) : (integral_closure R A).map â†‘f = integral_closure R B
theorem has_le.le.lt_or_eq_dec {Î± : Type u} [partial_order Î±] [decidable_rel has_le.le] {a b : Î±} (hab : a â‰¤ b) : a < b âˆ¨ a = b
theorem continuous_map.tendsto_locally_uniformly_of_tendsto {Î± : Type uâ‚} {Î² : Type uâ‚‚} [topological_space Î±] [uniform_space Î²] {f : C(Î±, Î²)} {Î¹ : Type uâ‚ƒ} {p : filter Î¹} {F : Î¹ â†’ C(Î±, Î²)} (hÎ± : âˆ€ (x : Î±), âˆƒ (n : set Î±), is_compact n âˆ§ n âˆˆ nhds x) (h : filter.tendsto F p (nhds f)) : tendsto_locally_uniformly (Î» (i : Î¹) (a : Î±), â‡‘(F i) a) â‡‘f p
theorem lt_of_sub_neg {Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b : Î±} : a - b < 0 â†’ a < b
theorem finset.centroid_weights_apply (k : Type u_1) [division_ring k] {Î¹ : Type u_4} (s : finset Î¹) (i : Î¹) : finset.centroid_weights k s i = (â†‘(s.card))â»Â¹
theorem cont_mdiff_at.cont_diff_at {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {n : with_top â„•} {f : E â†’ E'} {x : E} : cont_mdiff_at (model_with_corners_self ğ•œ E) (model_with_corners_self ğ•œ E') n f x â†’ cont_diff_at ğ•œ n f x
theorem has_le.le.trans_eq {Î± : Type u} [preorder Î±] {a b c : Î±} (hab : a â‰¤ b) (hbc : b = c) : a â‰¤ c
theorem int.exists_lt_and_lt_iff_not_dvd (m : â„¤) {n : â„¤} (hn : 0 < n) : (âˆƒ (k : â„¤), n * k < m âˆ§ m < n * (k + 1)) â†” Â¬n âˆ£ m
theorem complex.deriv_eq_smul_circle_integral {F : Type v} [normed_group F] [normed_space â„‚ F] [complete_space F] {R : â„} {c : â„‚} {f : â„‚ â†’ F} (hR : 0 < R) (hf : diff_cont_on_cl â„‚ f (metric.ball c R)) : deriv f c = (2 * â†‘real.pi * complex.I)â»Â¹ â€¢ âˆ® (z : â„‚) in C(c, R), (z - c) ^ -2 â€¢ f z
theorem alternating_map.comp_linear_map_injective {R : Type u_1} [semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {N : Type u_3} [add_comm_monoid N] [module R N] {Î¹ : Type u_6} [decidable_eq Î¹] {Mâ‚‚ : Type u_7} [add_comm_monoid Mâ‚‚] [module R Mâ‚‚] (f : Mâ‚‚ â†’â‚—[R] M) (hf : function.surjective â‡‘f) : function.injective (Î» (g : alternating_map R M N Î¹), g.comp_linear_map f)
theorem category_theory.L_faithful_of_unit_is_iso {C : Type uâ‚} [category_theory.category C] {D : Type uâ‚‚} [category_theory.category D] {L : C â¥¤ D} {R : D â¥¤ C} (h : L âŠ£ R) [category_theory.is_iso h.unit] : category_theory.faithful L
theorem quadratic_form.anisotropic_of_prod {Mâ‚ : Type u_3} {Mâ‚‚ : Type u_4} [add_comm_group Mâ‚] [add_comm_group Mâ‚‚] {R : Type u_1} [ordered_ring R] [module R Mâ‚] [module R Mâ‚‚] {Qâ‚ : quadratic_form R Mâ‚} {Qâ‚‚ : quadratic_form R Mâ‚‚} (h : (Qâ‚.prod Qâ‚‚).anisotropic) : Qâ‚.anisotropic âˆ§ Qâ‚‚.anisotropic
theorem pnat.count_factor_multiset (m : â„•+) (p : nat.primes) (k : â„•) : â†‘p ^ k âˆ£ m â†” k â‰¤ multiset.count p m.factor_multiset
theorem zsqrtd.lift_injective {R : Type} [comm_ring R] [char_zero R] {d : â„¤} (r : {r // r * r = â†‘d}) (hd : âˆ€ (n : â„¤), d â‰  n * n) : function.injective â‡‘(â‡‘zsqrtd.lift r)
theorem mv_polynomial.homogeneous_submodule_eq_finsupp_supported (Ïƒ : Type u_1) (R : Type u_3) [comm_semiring R] (n : â„•) : mv_polynomial.homogeneous_submodule Ïƒ R n = finsupp.supported R R {d : Ïƒ â†’â‚€ â„• | d.support.sum (Î» (i : Ïƒ), â‡‘d i) = n}
theorem dist_eq_norm_vsub (V : Type u_2) {P : Type u_3} [semi_normed_group V] [pseudo_metric_space P] [normed_add_torsor V P] (x y : P) : has_dist.dist x y = âˆ¥x -áµ¥ yâˆ¥
theorem polynomial.has_strict_deriv_at {ğ•œ : Type u} [nondiscrete_normed_field ğ•œ] (p : polynomial ğ•œ) (x : ğ•œ) : has_strict_deriv_at (Î» (x : ğ•œ), polynomial.eval x p) (polynomial.eval x (â‡‘polynomial.derivative p)) x
theorem antitone.map_bdd_below {Î± : Type u} {Î² : Type v} [preorder Î±] [preorder Î²] {f : Î± â†’ Î²} (hf : antitone f) {s : set Î±} : bdd_below s â†’ bdd_above (f '' s)
theorem picard_lindelof.exists_solution {E : Type u_1} [normed_group E] [normed_space â„ E] (v : picard_lindelof E) [complete_space E] : âˆƒ (f : â„ â†’ E), f â†‘(v.tâ‚€) = v.xâ‚€ âˆ§ âˆ€ (t : â„), t âˆˆ set.Icc v.t_min v.t_max â†’ has_deriv_within_at f (â‡‘v t (f t)) (set.Icc v.t_min v.t_max) t
theorem ideal.eq_zero_of_constant_mem_of_maximal {R : Type u} [ring R] (hR : is_field R) (I : ideal (polynomial R)) [hI : I.is_maximal] (x : R) (hx : â‡‘polynomial.C x âˆˆ I) : x = 0
theorem category_theory.limits.has_binary_biproduct.of_has_binary_coproduct {C : Type u} [category_theory.category C] [category_theory.preadditive C] (X Y : C) [category_theory.limits.has_binary_coproduct X Y] : category_theory.limits.has_binary_biproduct X Y
theorem local_homeomorph.continuous_at {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] (e : local_homeomorph Î± Î²) {x : Î±} (h : x âˆˆ e.to_local_equiv.source) : continuous_at â‡‘e x
theorem ultrafilter.exists_le {Î± : Type u} (f : filter Î±) [h : f.ne_bot] : âˆƒ (u : ultrafilter Î±), â†‘u â‰¤ f
theorem linear_map.prod_ext {R : Type u} {M : Type v} {Mâ‚‚ : Type w} {Mâ‚ƒ : Type y} [semiring R] [add_comm_monoid M] [add_comm_monoid Mâ‚‚] [add_comm_monoid Mâ‚ƒ] [module R M] [module R Mâ‚‚] [module R Mâ‚ƒ] {f g : M Ã— Mâ‚‚ â†’â‚—[R] Mâ‚ƒ} (hl : f.comp (linear_map.inl R M Mâ‚‚) = g.comp (linear_map.inl R M Mâ‚‚)) (hr : f.comp (linear_map.inr R M Mâ‚‚) = g.comp (linear_map.inr R M Mâ‚‚)) : f = g
theorem category_theory.limits.has_binary_coproducts_of_has_colimit_pair (C : Type u) [category_theory.category C] [âˆ€ {X Y : C}, category_theory.limits.has_colimit (category_theory.limits.pair X Y)] : category_theory.limits.has_binary_coproducts C
theorem matrix.det_eq_of_forall_row_eq_smul_add_const {n : Type u_2} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] {A B : matrix n n R} (c : n â†’ R) (k : n) (hk : c k = 0) (A_eq : âˆ€ (i j : n), A i j = B i j + c i * B k j) : A.det = B.det
theorem finset.nat.antidiagonal_congr {n : â„•} {p q : â„• Ã— â„•} (hp : p âˆˆ finset.nat.antidiagonal n) (hq : q âˆˆ finset.nat.antidiagonal n) : p = q â†” p.fst = q.fst
theorem quaternion_group.order_of_xa {n : â„•} [hpos : fact (0 < n)] (i : zmod (2 * n)) : order_of (quaternion_group.xa i) = 4
theorem finset.sum_add_sum_compl {Î² : Type u} {Î± : Type v} [add_comm_monoid Î²] [fintype Î±] [decidable_eq Î±] (s : finset Î±) (f : Î± â†’ Î²) : s.sum (Î» (i : Î±), f i) + sá¶œ.sum (Î» (i : Î±), f i) = finset.univ.sum (Î» (i : Î±), f i)
theorem submodule.eq_bot_of_le_smul_of_le_jacobson_bot {R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] (I : ideal R) (N : submodule R M) (hN : N.fg) (hIN : N â‰¤ I â€¢ N) (hIjac : I â‰¤ âŠ¥.jacobson) : N = âŠ¥
theorem is_add_regular_add_iff {R : Type u_1} {a b : R} [add_comm_semigroup R] : is_add_regular (a + b) â†” is_add_regular a âˆ§ is_add_regular b
theorem measure_theory.lintegral_lintegral {Î± : Type u_1} {Î² : Type u_3} [measurable_space Î±] [measurable_space Î²] {Î¼ : measure_theory.measure Î±} {Î½ : measure_theory.measure Î²} [measure_theory.sigma_finite Î½] â¦ƒf : Î± â†’ Î² â†’ ennrealâ¦„ (hf : ae_measurable (function.uncurry f) (Î¼.prod Î½)) : âˆ«â» (x : Î±), âˆ«â» (y : Î²), f x y âˆ‚Î½ âˆ‚Î¼ = âˆ«â» (z : Î± Ã— Î²), f z.fst z.snd âˆ‚Î¼.prod Î½
theorem exists_open_set_nhds {Î± : Type u} [topological_space Î±] {s U : set Î±} (h : âˆ€ (x : Î±), x âˆˆ s â†’ U âˆˆ nhds x) : âˆƒ (V : set Î±), s âŠ† V âˆ§ is_open V âˆ§ V âŠ† U
theorem combinatorics.line.exists_mono_in_high_dimension (Î± : Type u) [fintype Î±] (Îº : Type v) [fintype Îº] : âˆƒ (Î¹ : Type) [_inst_3 : fintype Î¹], âˆ€ (C : (Î¹ â†’ Î±) â†’ Îº), âˆƒ (l : combinatorics.line Î± Î¹), combinatorics.line.is_mono C l
theorem is_compact_iff_finite_subcover {Î± : Type u} [topological_space Î±] {s : set Î±} : is_compact s â†” âˆ€ {Î¹ : Type u} (U : Î¹ â†’ set Î±), (âˆ€ (i : Î¹), is_open (U i)) â†’ (s âŠ† â‹ƒ (i : Î¹), U i) â†’ (âˆƒ (t : finset Î¹), s âŠ† â‹ƒ (i : Î¹) (H : i âˆˆ t), U i)
theorem category_theory.forget_enrichment_comp {C : Type uâ‚} (W : Type (v+1)) [category_theory.category W] [category_theory.monoidal_category W] [category_theory.enriched_category W C] {X Y Z : category_theory.forget_enrichment W C} (f : X âŸ¶ Y) (g : Y âŸ¶ Z) : category_theory.forget_enrichment.hom_to W (f â‰« g) = ((Î»_ (ğŸ™_ W)).inv â‰« (category_theory.forget_enrichment.hom_to W f âŠ— category_theory.forget_enrichment.hom_to W g)) â‰« category_theory.e_comp W (category_theory.forget_enrichment.to W X) (category_theory.forget_enrichment.to W Y) (category_theory.forget_enrichment.to W Z)
theorem metric.dist_mem_uniformity {Î± : Type u} [pseudo_metric_space Î±] {Îµ : â„} (Îµ0 : 0 < Îµ) : {p : Î± Ã— Î± | has_dist.dist p.fst p.snd < Îµ} âˆˆ uniformity Î±
theorem left.one_lt_mul_of_le_of_lt {Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a b : Î±} (ha : 1 â‰¤ a) (hb : 1 < b) : 1 < a * b
theorem filter.eventually_eq.mem_iff {Î± : Type u} {s t : set Î±} {l : filter Î±} : s =á¶ [l] t â†’ (âˆ€á¶  (x : Î±) in l, x âˆˆ s â†” x âˆˆ t)
theorem function.is_fixed_pt.left_of_comp {Î± : Type u} {f g : Î± â†’ Î±} {x : Î±} (hfg : function.is_fixed_pt (f âˆ˜ g) x) (hg : function.is_fixed_pt g x) : function.is_fixed_pt f x
theorem orientation.oangle_rotation {V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) (x y : V) (Î¸ : real.angle) : o.oangle (â‡‘(o.rotation Î¸) x) (â‡‘(o.rotation Î¸) y) = o.oangle x y
theorem ordinal.enum_ord_def_nonempty {S : set ordinal} (hS : set.unbounded has_lt.lt S) {o : ordinal} : {x : ordinal | x âˆˆ S âˆ§ âˆ€ (c : ordinal), c < o â†’ ordinal.enum_ord S c < x}.nonempty
theorem is_noetherian_of_range_eq_ker {R : Type u_1} {M : Type u_2} {P : Type u_3} {N : Type w} [ring R] [add_comm_group M] [module R M] [add_comm_group N] [module R N] [add_comm_group P] [module R P] [is_noetherian R M] [is_noetherian R P] (f : M â†’â‚—[R] N) (g : N â†’â‚—[R] P) (hf : function.injective â‡‘f) (hg : function.surjective â‡‘g) (h : f.range = g.ker) : is_noetherian R N
theorem category_theory.abelian.pseudoelement.Module.eq_range_of_pseudoequal {R : Type u_1} [comm_ring R] {G : Module R} {x y : category_theory.over G} (h : category_theory.abelian.pseudo_equal G x y) : linear_map.range x.hom = linear_map.range y.hom
theorem linear_map.finite_dimensional_of_det_ne_one {M : Type u_2} [add_comm_group M] {ğ•œ : Type u_1} [field ğ•œ] [module ğ•œ M] (f : M â†’â‚—[ğ•œ] M) (hf : â‡‘linear_map.det f â‰  1) : finite_dimensional ğ•œ M
theorem list.nth_le_map_rev {Î± : Type u} {Î² : Type v} (f : Î± â†’ Î²) {l : list Î±} {n : â„•} (H : n < l.length) : f (l.nth_le n H) = (list.map f l).nth_le n _
theorem algebra_map_isometry (ğ•œ : Type u_5) (ğ•œ' : Type u_6) [normed_field ğ•œ] [semi_normed_ring ğ•œ'] [normed_algebra ğ•œ ğ•œ'] [norm_one_class ğ•œ'] : isometry â‡‘(algebra_map ğ•œ ğ•œ')
theorem pgame.left_distrib_equiv (x y z : pgame) : (x * (y + z)).equiv (x * y + x * z)
theorem set.subset_Union_of_subset {Î± : Type u_1} {Î¹ : Sort u_4} {s : set Î±} {t : Î¹ â†’ set Î±} (i : Î¹) (h : s âŠ† t i) : s âŠ† â‹ƒ (i : Î¹), t i
theorem mv_polynomial.vars_prod {R : Type u} {Ïƒ : Type u_1} [comm_semiring R] {Î¹ : Type u_2} {s : finset Î¹} (f : Î¹ â†’ mv_polynomial Ïƒ R) : (s.prod (Î» (i : Î¹), f i)).vars âŠ† s.bUnion (Î» (i : Î¹), (f i).vars)
theorem eq.faithful_of_comp {C : Type uâ‚} [category_theory.category C] {D : Type uâ‚‚} [category_theory.category D] {E : Type uâ‚ƒ} [category_theory.category E] {F : C â¥¤ D} {G : D â¥¤ E} {H : C â¥¤ E} [â„‹ : category_theory.faithful H] (h : F â‹™ G = H) : category_theory.faithful F
theorem tendsto_rpow_at_top {y : â„} (hy : 0 < y) : filter.tendsto (Î» (x : â„), x ^ y) filter.at_top filter.at_top
theorem pi.single_apply_commute {I : Type u} {f : I â†’ Type v} [decidable_eq I] [Î  (i : I), add_zero_class (f i)] (x : Î  (i : I), f i) (i j : I) : add_commute (pi.single i (x i)) (pi.single j (x j))
theorem int.eq_zero_of_dvd_of_nat_abs_lt_nat_abs {a b : â„¤} (w : a âˆ£ b) (h : b.nat_abs < a.nat_abs) : b = 0
theorem affine.simplex.affine_span_pair_eq_altitude_iff {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {n : â„•} (s : affine.simplex â„ P (n + 1)) (i : fin (n + 2)) (p : P) : affine_span â„ {p, s.points i} = s.altitude i â†” p â‰  s.points i âˆ§ p âˆˆ affine_span â„ (set.range s.points) âˆ§ p -áµ¥ s.points i âˆˆ ((affine_span â„ (s.points '' â†‘(finset.univ.erase i))).direction)á—®
theorem formal_multilinear_series.radius_right_inv_pos_of_radius_pos_aux2 {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {n : â„•} (hn : 2 â‰¤ n + 1) (p : formal_multilinear_series ğ•œ E F) (i : E â‰ƒL[ğ•œ] F) {r a C : â„} (hr : 0 â‰¤ r) (ha : 0 â‰¤ a) (hC : 0 â‰¤ C) (hp : âˆ€ (n : â„•), âˆ¥p nâˆ¥ â‰¤ C * r ^ n) : (finset.Ico 1 (n + 1)).sum (Î» (k : â„•), a ^ k * âˆ¥p.right_inv i kâˆ¥) â‰¤ âˆ¥â†‘(i.symm)âˆ¥ * a + âˆ¥â†‘(i.symm)âˆ¥ * C * (finset.Ico 2 (n + 1)).sum (Î» (k : â„•), (r * (finset.Ico 1 n).sum (Î» (j : â„•), a ^ j * âˆ¥p.right_inv i jâˆ¥)) ^ k)
theorem bernstein_approximation_uniform (f : C(â†¥unit_interval, â„)) : filter.tendsto (Î» (n : â„•), bernstein_approximation n f) filter.at_top (nhds f)
theorem has_ftaylor_series_up_to_on.prod {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {G : Type u_4} [normed_group G] [normed_space ğ•œ G] {s : set E} {f : E â†’ F} {n : with_top â„•} {p : E â†’ formal_multilinear_series ğ•œ E F} (hf : has_ftaylor_series_up_to_on n f p s) {g : E â†’ G} {q : E â†’ formal_multilinear_series ğ•œ E G} (hg : has_ftaylor_series_up_to_on n g q s) : has_ftaylor_series_up_to_on n (Î» (y : E), (f y, g y)) (Î» (y : E) (k : â„•), (p y k).prod (q y k)) s
theorem metric.inf_dist_eq_closure {Î± : Type u} [pseudo_metric_space Î±] {s : set Î±} {x : Î±} : metric.inf_dist x (closure s) = metric.inf_dist x s
theorem free_group.reduce.eq_of_red {Î± : Type u} {Lâ‚ Lâ‚‚ : list (Î± Ã— bool)} [decidable_eq Î±] (H : free_group.red Lâ‚ Lâ‚‚) : free_group.reduce Lâ‚ = free_group.reduce Lâ‚‚
theorem lt_inv_of_lt_inv {Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] [covariant_class Î± Î± (function.swap has_mul.mul) has_lt.lt] {a b : Î±} : a < bâ»Â¹ â†’ b < aâ»Â¹
theorem measure_theory.set_integral_prod {Î± : Type u_1} {Î² : Type u_3} {E : Type u_6} [measurable_space Î±] [measurable_space Î²] {Î¼ : measure_theory.measure Î±} {Î½ : measure_theory.measure Î²} [normed_group E] [measure_theory.sigma_finite Î½] [normed_space â„ E] [complete_space E] [measure_theory.sigma_finite Î¼] (f : Î± Ã— Î² â†’ E) {s : set Î±} {t : set Î²} (hf : measure_theory.integrable_on f (s Ã—Ë¢ t) (Î¼.prod Î½)) : âˆ« (z : Î± Ã— Î²) in s Ã—Ë¢ t, f z âˆ‚Î¼.prod Î½ = âˆ« (x : Î±) in s, âˆ« (y : Î²) in t, f (x, y) âˆ‚Î½ âˆ‚Î¼
theorem nat.dvd_left_iff_eq {m n : â„•} : (âˆ€ (a : â„•), a âˆ£ m â†” a âˆ£ n) â†” m = n
theorem fin.succ_above_last {n : â„•} : (fin.last n).succ_above = fin.cast_succ
theorem convex_on_exp  : convex_on â„ set.univ real.exp
theorem embedding.metrizable_space {X : Type u_2} {Y : Type u_3} [topological_space X] [topological_space Y] [topological_space.metrizable_space Y] {f : X â†’ Y} (hf : embedding f) : topological_space.metrizable_space X
theorem generalized_continued_fraction.int_fract_pair.succ_nth_stream_eq_some_iff {K : Type u_1} [linear_ordered_field K] [floor_ring K] {v : K} {n : â„•} {ifp_succ_n : generalized_continued_fraction.int_fract_pair K} : generalized_continued_fraction.int_fract_pair.stream v (n + 1) = option.some ifp_succ_n â†” âˆƒ (ifp_n : generalized_continued_fraction.int_fract_pair K), generalized_continued_fraction.int_fract_pair.stream v n = option.some ifp_n âˆ§ ifp_n.fr â‰  0 âˆ§ generalized_continued_fraction.int_fract_pair.of (ifp_n.fr)â»Â¹ = ifp_succ_n
theorem measure_theory.pdf.integral_mul_eq_integral {Î± : Type u_1} {m : measurable_space Î±} {â„™ : measure_theory.measure Î±} [measure_theory.is_finite_measure Â«â„™Â»] {X : Î± â†’ â„} [measure_theory.has_pdf X Â«â„™Â» measure_theory.measure_space.volume] : âˆ« (x : â„), x * (measure_theory.pdf X Â«â„™Â» measure_theory.measure_space.volume x).to_real = âˆ« (x : Î±), X x âˆ‚Â«â„™Â»
theorem measure_theory.lintegral_lintegral_swap {Î± : Type u_1} {Î² : Type u_3} [measurable_space Î±] [measurable_space Î²] {Î¼ : measure_theory.measure Î±} {Î½ : measure_theory.measure Î²} [measure_theory.sigma_finite Î½] [measure_theory.sigma_finite Î¼] â¦ƒf : Î± â†’ Î² â†’ ennrealâ¦„ (hf : ae_measurable (function.uncurry f) (Î¼.prod Î½)) : âˆ«â» (x : Î±), âˆ«â» (y : Î²), f x y âˆ‚Î½ âˆ‚Î¼ = âˆ«â» (y : Î²), âˆ«â» (x : Î±), f x y âˆ‚Î¼ âˆ‚Î½
theorem linear_map.congr_fun {R : Type u_1} {S : Type u_6} {M : Type u_9} {Mâ‚ƒ : Type u_12} [semiring R] [semiring S] [add_comm_monoid M] [add_comm_monoid Mâ‚ƒ] [module R M] [module S Mâ‚ƒ] {Ïƒ : R â†’+* S} {f g : M â†’â‚›â‚—[Ïƒ] Mâ‚ƒ} (h : f = g) (x : M) : â‡‘f x = â‡‘g x
theorem polynomial.is_separable_contraction.degree_eq {F : Type} [field F] (q : â„•) {f : polynomial F} (hf : polynomial.has_separable_contraction q f) [hF : exp_char F q] (g : polynomial F) (hg : polynomial.is_separable_contraction q f g) : g.nat_degree = hf.degree
theorem vector.reverse_nth_zero {n : â„•} {Î± : Type u_1} {v : vector Î± (n + 1)} : v.reverse.head = v.last
theorem measure_theory.mem_â„’p_trim_of_mem_Lp_meas_subgroup {Î± : Type u_1} {F : Type u_6} {p : ennreal} [normed_group F] {m m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (hm : m â‰¤ m0) (f : â†¥(measure_theory.Lp F p Î¼)) (hf_meas : f âˆˆ measure_theory.Lp_meas_subgroup F m p Î¼) : measure_theory.mem_â„’p (Exists.some _) p (Î¼.trim hm)
theorem orientation.oangle_smul_smul_self_of_nonneg {V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) (x : V) {râ‚ râ‚‚ : â„} (hrâ‚ : 0 â‰¤ râ‚) (hrâ‚‚ : 0 â‰¤ râ‚‚) : o.oangle (râ‚ â€¢ x) (râ‚‚ â€¢ x) = 0
theorem pgame.equiv_nim_grundy_value (G : pgame) [G.impartial] : G.equiv (nim G.grundy_value)
theorem add_subgroup.map_equiv_normalizer_eq {G : Type u_1} [add_group G] {N : Type u_3} [add_group N] (H : add_subgroup G) (f : G â‰ƒ+ N) : add_subgroup.map f.to_add_monoid_hom H.normalizer = (add_subgroup.map f.to_add_monoid_hom H).normalizer
theorem submodule.smul_sup_eq_smul_sup_of_le_smul_of_le_jacobson {R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] {I J : ideal R} {N N' : submodule R M} (hN' : N'.fg) (hIJ : I â‰¤ J.jacobson) (hNN : N âŠ” N' â‰¤ N âŠ” I â€¢ N') : N âŠ” I â€¢ N' = N âŠ” J â€¢ N'
theorem category_theory.is_pushout.of_is_colimit' {C : Type uâ‚} [category_theory.category C] {Z X Y P : C} {f : Z âŸ¶ X} {g : Z âŸ¶ Y} {inl : X âŸ¶ P} {inr : Y âŸ¶ P} (w : category_theory.comm_sq f g inl inr) (h : category_theory.limits.is_colimit w.cocone) : category_theory.is_pushout f g inl inr
theorem has_le.le.trans {Î± : Type u} [preorder Î±] {a b c : Î±} : a â‰¤ b â†’ b â‰¤ c â†’ a â‰¤ c
theorem generalized_continued_fraction.determinant {K : Type u_1} {v : K} {n : â„•} [linear_ordered_field K] [floor_ring K] (not_terminated_at_n : Â¬(generalized_continued_fraction.of v).terminated_at n) : (generalized_continued_fraction.of v).numerators n * (generalized_continued_fraction.of v).denominators (n + 1) - (generalized_continued_fraction.of v).denominators n * (generalized_continued_fraction.of v).numerators (n + 1) = (-1) ^ (n + 1)
theorem is_add_group_hom.id {Î± : Type u} [add_group Î±] : is_add_group_hom id
theorem affine_map.linear_map_vsub {k : Type u_1} {V1 : Type u_2} {P1 : Type u_3} {V2 : Type u_4} {P2 : Type u_5} [ring k] [add_comm_group V1] [module k V1] [add_torsor V1 P1] [add_comm_group V2] [module k V2] [add_torsor V2 P2] (f : P1 â†’áµƒ[k] P2) (p1 p2 : P1) : â‡‘(f.linear) (p1 -áµ¥ p2) = â‡‘f p1 -áµ¥ â‡‘f p2
theorem is_submonoid.multiset_prod_mem {M : Type u_1} [comm_monoid M] {s : set M} (hs : is_submonoid s) (m : multiset M) : (âˆ€ (a : M), a âˆˆ m â†’ a âˆˆ s) â†’ m.prod âˆˆ s
theorem tfae_exists_lt_is_o_pow (f : â„• â†’ â„) (R : â„) : [âˆƒ (a : â„) (H : a âˆˆ set.Ioo (-R) R), f =o[filter.at_top] has_pow.pow a, âˆƒ (a : â„) (H : a âˆˆ set.Ioo 0 R), f =o[filter.at_top] has_pow.pow a, âˆƒ (a : â„) (H : a âˆˆ set.Ioo (-R) R), f =O[filter.at_top] has_pow.pow a, âˆƒ (a : â„) (H : a âˆˆ set.Ioo 0 R), f =O[filter.at_top] has_pow.pow a, âˆƒ (a : â„) (H : a < R) (C : â„) (hâ‚€ : 0 < C âˆ¨ 0 < R), âˆ€ (n : â„•), |f n| â‰¤ C * a ^ n, âˆƒ (a : â„) (H : a âˆˆ set.Ioo 0 R) (C : â„) (H : C > 0), âˆ€ (n : â„•), |f n| â‰¤ C * a ^ n, âˆƒ (a : â„) (H : a < R), âˆ€á¶  (n : â„•) in filter.at_top, |f n| â‰¤ a ^ n, âˆƒ (a : â„) (H : a âˆˆ set.Ioo 0 R), âˆ€á¶  (n : â„•) in filter.at_top, |f n| â‰¤ a ^ n].tfae
theorem linear_map.continuous_of_is_closed_ker {ğ•œ : Type u} [hnorm : nondiscrete_normed_field ğ•œ] {E : Type v} [add_comm_group E] [module ğ•œ E] [topological_space E] [topological_add_group E] [has_continuous_smul ğ•œ E] (l : E â†’â‚—[ğ•œ] ğ•œ) (hl : is_closed â†‘(l.ker)) : continuous â‡‘l
theorem deriv.lhopital_zero_nhds_right {a : â„} {l : filter â„} {f g : â„ â†’ â„} (hdf : âˆ€á¶  (x : â„) in nhds_within a (set.Ioi a), differentiable_at â„ f x) (hg' : âˆ€á¶  (x : â„) in nhds_within a (set.Ioi a), deriv g x â‰  0) (hfa : filter.tendsto f (nhds_within a (set.Ioi a)) (nhds 0)) (hga : filter.tendsto g (nhds_within a (set.Ioi a)) (nhds 0)) (hdiv : filter.tendsto (Î» (x : â„), deriv f x / deriv g x) (nhds_within a (set.Ioi a)) l) : filter.tendsto (Î» (x : â„), f x / g x) (nhds_within a (set.Ioi a)) l
theorem category_theory.abelian_of_adjunction.has_cokernels {C : Type uâ‚} [category_theory.category C] [category_theory.preadditive C] {D : Type uâ‚‚} [category_theory.category D] [category_theory.abelian D] (F : C â¥¤ D) (G : D â¥¤ C) [G.preserves_zero_morphisms] (i : F â‹™ G â‰… ğŸ­ C) (adj : G âŠ£ F) : category_theory.limits.has_cokernels C
theorem norm_sub_mul_self {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {x y : E} : âˆ¥x - yâˆ¥ * âˆ¥x - yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ - 2 * â‡‘is_R_or_C.re (has_inner.inner x y) + âˆ¥yâˆ¥ * âˆ¥yâˆ¥
theorem nonempty_sections_of_fintype_cofiltered_system.init {J : Type u} [category_theory.small_category J] [category_theory.is_cofiltered J] (F : J â¥¤ Type u) [hf : Î  (j : J), fintype (F.obj j)] [hne : âˆ€ (j : J), nonempty (F.obj j)] : F.sections.nonempty
theorem measure_theory.tendsto_Lp_of_tendsto_in_measure {Î± : Type u_1} {Î² : Type u_2} {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) [normed_group Î²] {p : ennreal} {f : â„• â†’ Î± â†’ Î²} {g : Î± â†’ Î²} [measure_theory.is_finite_measure Î¼] (hp : 1 â‰¤ p) (hp' : p â‰  âŠ¤) (hf : âˆ€ (n : â„•), measure_theory.ae_strongly_measurable (f n) Î¼) (hg : measure_theory.mem_â„’p g p Î¼) (hui : measure_theory.unif_integrable f p Î¼) (hfg : measure_theory.tendsto_in_measure Î¼ f filter.at_top g) : filter.tendsto (Î» (n : â„•), measure_theory.snorm (f n - g) p Î¼) filter.at_top (nhds 0)
theorem euclidean_geometry.orthogonal_projection_fn_mem {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace â„ P} [nonempty â†¥s] [complete_space â†¥(s.direction)] (p : P) : euclidean_geometry.orthogonal_projection_fn s p âˆˆ s
theorem filter.tendsto.add_at_bot {Î± : Type u} {Î² : Type v} [topological_space Î±] [linear_ordered_add_comm_group Î±] [order_topology Î±] {l : filter Î²} {f g : Î² â†’ Î±} {C : Î±} (hf : filter.tendsto f l (nhds C)) (hg : filter.tendsto g l filter.at_bot) : filter.tendsto (Î» (x : Î²), f x + g x) l filter.at_bot
theorem euclidean_geometry.angle_eq_zero_of_angle_eq_pi_right {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {p1 p2 p3 : P} (h : euclidean_geometry.angle p1 p2 p3 = real.pi) : euclidean_geometry.angle p2 p3 p1 = 0
theorem ordered_semiring.to_char_zero {R : Type u_1} [ordered_semiring R] [nontrivial R] : char_zero R
theorem interval_integral.integral_has_strict_fderiv_at {E : Type u_3} [normed_group E] [complete_space E] [normed_space â„ E] {f : â„ â†’ E} {a b : â„} (hf : interval_integrable f measure_theory.measure_space.volume a b) (hmeas_a : strongly_measurable_at_filter f (nhds a) measure_theory.measure_space.volume) (hmeas_b : strongly_measurable_at_filter f (nhds b) measure_theory.measure_space.volume) (ha : continuous_at f a) (hb : continuous_at f b) : has_strict_fderiv_at (Î» (p : â„ Ã— â„), âˆ« (x : â„) in p.fst..p.snd, f x) ((continuous_linear_map.snd â„ â„ â„).smul_right (f b) - (continuous_linear_map.fst â„ â„ â„).smul_right (f a)) (a, b)
theorem is_algebraic_of_larger_base_of_injective {R : Type u_3} {S : Type u_4} {A : Type u_5} [comm_ring R] [comm_ring S] [comm_ring A] [algebra R S] [algebra S A] [algebra R A] [is_scalar_tower R S A] (hinj : function.injective â‡‘(algebra_map R S)) {x : A} (A_alg : is_algebraic R x) : is_algebraic S x
theorem rescale_to_shell {Î± : Type u_1} [normed_field Î±] {E : Type u_5} [normed_group E] [normed_space Î± E] {c : Î±} (hc : 1 < âˆ¥câˆ¥) {Îµ : â„} (Îµpos : 0 < Îµ) {x : E} (hx : x â‰  0) : âˆƒ (d : Î±), d â‰  0 âˆ§ âˆ¥d â€¢ xâˆ¥ < Îµ âˆ§ Îµ / âˆ¥câˆ¥ â‰¤ âˆ¥d â€¢ xâˆ¥ âˆ§ âˆ¥dâˆ¥â»Â¹ â‰¤ Îµâ»Â¹ * âˆ¥câˆ¥ * âˆ¥xâˆ¥
theorem generalized_continued_fraction.of_part_num_eq_one_and_exists_int_part_denom_eq {K : Type u_1} {v : K} {n : â„•} [linear_ordered_field K] [floor_ring K] {gp : generalized_continued_fraction.pair K} (nth_s_eq : (generalized_continued_fraction.of v).s.nth n = option.some gp) : gp.a = 1 âˆ§ âˆƒ (z : â„¤), gp.b = â†‘z
theorem convex_independent.mem_convex_hull_iff {ğ•œ : Type u_1} {E : Type u_2} {Î¹ : Type u_3} [ordered_semiring ğ•œ] [add_comm_group E] [module ğ•œ E] {p : Î¹ â†’ E} (hc : convex_independent ğ•œ p) (s : set Î¹) (i : Î¹) : p i âˆˆ â‡‘(convex_hull ğ•œ) (p '' s) â†” i âˆˆ s
theorem finset.weighted_vsub_empty {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {Î¹ : Type u_4} (w : Î¹ â†’ k) (p : Î¹ â†’ P) : â‡‘(âˆ….weighted_vsub p) w = 0
theorem matrix.det_comm' {A : Type u_5} [comm_ring A] {m : Type u_6} {n : Type u_7} [fintype m] [fintype n] [decidable_eq m] [decidable_eq n] {M : matrix n m A} {N M' : matrix m n A} (hMM' : M.mul M' = 1) (hM'M : M'.mul M = 1) : (M.mul N).det = (N.mul M).det
theorem basis.orientation_neg_single {R : Type u_1} [linear_ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {Î¹ : Type u_3} [decidable_eq Î¹] [fintype Î¹] [nontrivial R] (e : basis Î¹ R M) (i : Î¹) : (e.units_smul (function.update 1 i (-1))).orientation = -e.orientation
theorem finsum_mem_bUnion {Î± : Type u_1} {Î¹ : Type u_3} {M : Type u_5} [add_comm_monoid M] {f : Î± â†’ M} {I : set Î¹} {t : Î¹ â†’ set Î±} (h : I.pairwise_disjoint t) (hI : I.finite) (ht : âˆ€ (i : Î¹), i âˆˆ I â†’ (t i).finite) : finsum (Î» (a : Î±), finsum (Î» (H : a âˆˆ â‹ƒ (x : Î¹) (H : x âˆˆ I), t x), f a)) = finsum (Î» (i : Î¹), finsum (Î» (H : i âˆˆ I), finsum (Î» (j : Î±), finsum (Î» (H : j âˆˆ t i), f j))))
theorem category_theory.functor.ess_image.unit_is_iso {C : Type uâ‚} {D : Type uâ‚‚} [category_theory.category C] [category_theory.category D] {i : D â¥¤ C} [category_theory.reflective i] {A : C} (h : A âˆˆ i.ess_image) : category_theory.is_iso ((category_theory.adjunction.of_right_adjoint i).unit.app A)
theorem zero_eq_mul {Mâ‚€ : Type u_1} [mul_zero_class Mâ‚€] [no_zero_divisors Mâ‚€] {a b : Mâ‚€} : 0 = a * b â†” a = 0 âˆ¨ b = 0
theorem vector.tail_nil {Î± : Type u_1} : vector.nil.tail = vector.nil
theorem finset.card_div_choose_le_card_shadow_div_choose {ğ•œ : Type u_1} {Î± : Type u_2} [linear_ordered_field ğ•œ] [decidable_eq Î±] [fintype Î±] {ğ’œ : finset (finset Î±)} {r : â„•} (hr : r â‰  0) (hğ’œ : set.sized r â†‘ğ’œ) : â†‘(ğ’œ.card) / â†‘((fintype.card Î±).choose r) â‰¤ â†‘(ğ’œ.shadow.card) / â†‘((fintype.card Î±).choose (r - 1))
theorem dense_inducing_pure {Î± : Type u} : dense_inducing has_pure.pure
theorem power_series.coeff_of_lt_order {R : Type u_1} [semiring R] {Ï† : power_series R} (n : â„•) (h : â†‘n < Ï†.order) : â‡‘(power_series.coeff R n) Ï† = 0
theorem monoid_hom.map_inv {Î± : Type u_1} {Î² : Type u_2} [group Î±] [division_monoid Î²] (f : Î± â†’* Î²) (a : Î±) : â‡‘f aâ»Â¹ = (â‡‘f a)â»Â¹
theorem refl_trans_gen_of_pred_of_ge {Î± : Type u_1} [partial_order Î±] [pred_order Î±] [is_pred_archimedean Î±] (r : Î± â†’ Î± â†’ Prop) {n m : Î±} (h : âˆ€ (i : Î±), i âˆˆ set.Ioc m n â†’ r i (order.pred i)) (hnm : m â‰¤ n) : relation.refl_trans_gen r n m
theorem exp_neg_inv_glue.f_aux_zero_eq  : exp_neg_inv_glue.f_aux 0 = exp_neg_inv_glue
theorem is_o_pow_exp_pos_mul_at_top (k : â„•) {b : â„} (hb : 0 < b) : (Î» (x : â„), x ^ k) =o[filter.at_top] Î» (x : â„), real.exp (b * x)
theorem nat.arithmetic_function.prod_eq_iff_prod_pow_moebius_eq {R : Type u_1} [comm_group R] {f g : â„• â†’ R} : (âˆ€ (n : â„•), 0 < n â†’ n.divisors.prod (Î» (i : â„•), f i) = g n) â†” âˆ€ (n : â„•), 0 < n â†’ n.divisors_antidiagonal.prod (Î» (x : â„• Ã— â„•), g x.snd ^ â‡‘nat.arithmetic_function.moebius x.fst) = f n
theorem bilin_form.ext_basis {Râ‚‚ : Type u_5} {Mâ‚‚ : Type u_6} [comm_semiring Râ‚‚] [add_comm_monoid Mâ‚‚] [module Râ‚‚ Mâ‚‚] {Bâ‚‚ Fâ‚‚ : bilin_form Râ‚‚ Mâ‚‚} {Î¹ : Type u_13} (b : basis Î¹ Râ‚‚ Mâ‚‚) (h : âˆ€ (i j : Î¹), â‡‘Bâ‚‚ (â‡‘b i) (â‡‘b j) = â‡‘Fâ‚‚ (â‡‘b i) (â‡‘b j)) : Bâ‚‚ = Fâ‚‚
theorem inner_product_geometry.angle_neg_left {V : Type u_1} [inner_product_space â„ V] (x y : V) : inner_product_geometry.angle (-x) y = real.pi - inner_product_geometry.angle x y
theorem finrank_eq_one {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] (v : V) (n : v â‰  0) (h : âˆ€ (w : V), âˆƒ (c : K), c â€¢ v = w) : finite_dimensional.finrank K V = 1
theorem equiv.perm.is_cycle.eq_on_support_inter_nonempty_congr {Î± : Type u_1} [decidable_eq Î±] [fintype Î±] {f g : equiv.perm Î±} (hf : f.is_cycle) (hg : g.is_cycle) (h : âˆ€ (x : Î±), x âˆˆ f.support âˆ© g.support â†’ â‡‘f x = â‡‘g x) {x : Î±} (hx : â‡‘f x = â‡‘g x) (hx' : x âˆˆ f.support) : f = g
theorem is_ring_hom.map_neg {Î± : Type u} {Î² : Type v} [ring Î±] [ring Î²] {f : Î± â†’ Î²} {x : Î±} (hf : is_ring_hom f) : f (-x) = -f x
theorem field.exists_primitive_element_of_fintype_bot (F : Type u_1) [field F] (E : Type u_2) [field E] [algebra F E] [fintype F] [finite_dimensional F E] : âˆƒ (Î± : E), FâŸ®Î±âŸ¯ = âŠ¤
theorem euclidean_geometry.angle_eq_left {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] (p1 p2 : P) : euclidean_geometry.angle p1 p1 p2 = real.pi / 2
theorem set.sized.union {Î± : Type u_1} {A B : set (finset Î±)} {r : â„•} : set.sized r A âˆ§ set.sized r B â†’ set.sized r (A âˆª B)
theorem interval_integral.integral_comp_smul_deriv' {E : Type u_3} [normed_group E] [complete_space E] [normed_space â„ E] {a b : â„} {f f' : â„ â†’ â„} {g : â„ â†’ E} (h : âˆ€ (x : â„), x âˆˆ set.interval a b â†’ has_deriv_at f (f' x) x) (h' : continuous_on f' (set.interval a b)) (hg : continuous_on g (f '' set.interval a b)) : âˆ« (x : â„) in a..b, f' x â€¢ (g âˆ˜ f) x = âˆ« (x : â„) in f a..f b, g x
theorem add_con.ker_apply_eq_preimage {M : Type u_1} {P : Type u_3} [add_zero_class M] [add_zero_class P] {f : M â†’+ P} (x : M) : â‡‘(add_con.ker f) x = â‡‘f â»Â¹' {â‡‘f x}
theorem dihedral_group.order_of_sr {n : â„•} (i : zmod n) : order_of (dihedral_group.sr i) = 2
theorem measure_theory.integrable_prod_iff' {Î± : Type u_1} {Î² : Type u_3} {E : Type u_6} [measurable_space Î±] [measurable_space Î²] {Î¼ : measure_theory.measure Î±} {Î½ : measure_theory.measure Î²} [normed_group E] [measure_theory.sigma_finite Î½] [measure_theory.sigma_finite Î¼] â¦ƒf : Î± Ã— Î² â†’ Eâ¦„ (h1f : measure_theory.ae_strongly_measurable f (Î¼.prod Î½)) : measure_theory.integrable f (Î¼.prod Î½) â†” (âˆ€áµ (y : Î²) âˆ‚Î½, measure_theory.integrable (Î» (x : Î±), f (x, y)) Î¼) âˆ§ measure_theory.integrable (Î» (y : Î²), âˆ« (x : Î±), âˆ¥f (x, y)âˆ¥ âˆ‚Î¼) Î½
theorem convex_on.translate_right {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [ordered_semiring ğ•œ] [add_comm_monoid E] [ordered_add_comm_monoid Î²] [module ğ•œ E] [has_scalar ğ•œ Î²] {s : set E} {f : E â†’ Î²} (hf : convex_on ğ•œ s f) (c : E) : convex_on ğ•œ ((Î» (z : E), c + z) â»Â¹' s) (f âˆ˜ Î» (z : E), c + z)
theorem first_order.language.age.countable_quotient {L : first_order.language} (M : Type w) [L.Structure M] (h : set.univ.countable) : (quotient.mk '' L.age M).countable
theorem measurable_space.generate_measurable_eq_rec {Î± : Type u} (s : set (set Î±)) : {t : set Î± | measurable_space.generate_measurable s t} = â‹ƒ (i : (quotient.out (cardinal.aleph 1).ord).Î±), measurable_space.generate_measurable_rec s i
theorem forall_liouville_with_iff {x : â„} : (âˆ€ (p : â„), liouville_with p x) â†” liouville x
theorem is_submonoid.finset_prod_mem {M : Type u_1} {A : Type u_2} [comm_monoid M] {s : set M} (hs : is_submonoid s) (f : A â†’ M) (t : finset A) : (âˆ€ (b : A), b âˆˆ t â†’ f b âˆˆ s) â†’ t.prod (Î» (b : A), f b) âˆˆ s
theorem equiv.coe_fn_injective {Î± : Sort u} {Î² : Sort v} : function.injective coe_fn
theorem orientation.oangle_sub_right {V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) {x y z : V} (hx : x â‰  0) (hy : y â‰  0) (hz : z â‰  0) : o.oangle x z - o.oangle y z = o.oangle x y
theorem topological_space.is_topological_basis.open_eq_sUnion' {Î± : Type u} [t : topological_space Î±] {B : set (set Î±)} (hB : topological_space.is_topological_basis B) {u : set Î±} (ou : is_open u) : u = â‹ƒâ‚€{s âˆˆ B | s âŠ† u}
theorem order.le_of_succ_le_succ {Î± : Type u_1} [preorder Î±] [succ_order Î±] {a b : Î±} [no_max_order Î±] : order.succ a â‰¤ order.succ b â†’ a â‰¤ b
theorem box_integral.tagged_prepartition.is_Henstock.card_filter_tag_eq_le {Î¹ : Type u_1} {I : box_integral.box Î¹} {Ï€ : box_integral.tagged_prepartition I} [fintype Î¹] (h : Ï€.is_Henstock) (x : Î¹ â†’ â„) : (finset.filter (Î» (J : box_integral.box Î¹), Ï€.tag J = x) Ï€.to_prepartition.boxes).card â‰¤ 2 ^ fintype.card Î¹
theorem alg_hom.subsingleton {R : Type u} {A : Type v} {B : Type w} [comm_semiring R] [semiring A] [algebra R A] [semiring B] [algebra R B] [subsingleton (subalgebra R A)] : subsingleton (A â†’â‚[R] B)
theorem nat.dvd_add_self_right {m n : â„•} : m âˆ£ n + m â†” m âˆ£ n
theorem finite_dimensional.exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) : âˆƒ (f : V â†’ K), t.sum (Î» (e : V), f e â€¢ e) = 0 âˆ§ t.sum (Î» (e : V), f e) = 0 âˆ§ âˆƒ (x : V) (H : x âˆˆ t), f x â‰  0
theorem mk_eq_mk_of_basis {Î¹ : Type w} {Î¹' : Type w'} {R : Type u} [ring R] [invariant_basis_number R] {M : Type v} [add_comm_group M] [module R M] (v : basis Î¹ R M) (v' : basis Î¹' R M) : (cardinal.mk Î¹).lift = (cardinal.mk Î¹').lift
theorem measure_theory.measure.measure_prod_null {Î± : Type u_1} {Î² : Type u_3} [measurable_space Î±] [measurable_space Î²] {Î¼ : measure_theory.measure Î±} {Î½ : measure_theory.measure Î²} [measure_theory.sigma_finite Î½] {s : set (Î± Ã— Î²)} (hs : measurable_set s) : â‡‘(Î¼.prod Î½) s = 0 â†” (Î» (x : Î±), â‡‘Î½ (prod.mk x â»Â¹' s)) =áµ[Î¼] 0
theorem tendsto_pow_at_top_nhds_0_of_norm_lt_1 {R : Type u_1} [normed_ring R] {x : R} (h : âˆ¥xâˆ¥ < 1) : filter.tendsto (Î» (n : â„•), x ^ n) filter.at_top (nhds 0)
theorem minpoly.prime {A : Type u_1} {B : Type u_2} [field A] [ring B] [is_domain B] [algebra A B] {x : B} (hx : is_integral A x) : prime (minpoly A x)
theorem first_order.language.hom.eq_on_closure {L : first_order.language} {M : Type w} {N : Type u_1} [L.Structure M] [L.Structure N] {f g : L.hom M N} {s : set M} (h : set.eq_on â‡‘f â‡‘g s) : set.eq_on â‡‘f â‡‘g â†‘(â‡‘(first_order.language.substructure.closure L) s)
theorem uniformity_has_basis_open {Î± : Type u_1} [uniform_space Î±] : (uniformity Î±).has_basis (Î» (V : set (Î± Ã— Î±)), V âˆˆ uniformity Î± âˆ§ is_open V) id
theorem le_of_sub_nonneg {Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±} : 0 â‰¤ a - b â†’ b â‰¤ a
theorem submonoid.localization_map.map_spec {M : Type u_1} [comm_monoid M] {S : submonoid M} {N : Type u_2} [comm_monoid N] {P : Type u_3} [comm_monoid P] (f : S.localization_map N) {g : M â†’* P} {T : submonoid P} (hy : âˆ€ (y : â†¥S), â‡‘g â†‘y âˆˆ T) {Q : Type u_4} [comm_monoid Q] {k : T.localization_map Q} (z : N) (u : Q) : â‡‘(f.map hy k) z = u â†” â‡‘(k.to_map) (â‡‘g (f.sec z).fst) = â‡‘(k.to_map) (â‡‘g â†‘((f.sec z).snd)) * u
theorem count_succ_eq_succ_count {p : â„• â†’ Prop} [decidable_pred p] {n : â„•} : p n â†’ nat.count p (n + 1) = nat.count p n + 1
theorem wcovby.of_dual {Î± : Type u_1} [preorder Î±] {a b : Î±áµ’áµˆ} : b â©¿ a â†’ â‡‘order_dual.of_dual a â©¿ â‡‘order_dual.of_dual b
theorem add_monoid.closure_mono {M : Type u_1} [add_monoid M] {s t : set M} (h : s âŠ† t) : add_monoid.closure s âŠ† add_monoid.closure t
theorem dense_range.equalizer {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [topological_space Î²] [topological_space Î³] [t2_space Î³] {f : Î± â†’ Î²} (hfd : dense_range f) {g h : Î² â†’ Î³} (hg : continuous g) (hh : continuous h) (H : g âˆ˜ f = h âˆ˜ f) : g = h
theorem number_field.ring_of_integers.not_is_field (K : Type u_1) [field K] [number_field K] : Â¬is_field â†¥(number_field.ring_of_integers K)
theorem measure_theory.measure.absolutely_continuous_iff_with_density_rn_deriv_eq {Î± : Type u_1} {m : measurable_space Î±} {Î¼ Î½ : measure_theory.measure Î±} [Î¼.have_lebesgue_decomposition Î½] : Î¼.absolutely_continuous Î½ â†” Î½.with_density (Î¼.rn_deriv Î½) = Î¼
theorem diff_cont_on_cl.has_fpower_series_on_ball {E : Type u} [normed_group E] [normed_space â„‚ E] [complete_space E] {R : nnreal} {c : â„‚} {f : â„‚ â†’ E} (hf : diff_cont_on_cl â„‚ f (metric.ball c â†‘R)) (hR : 0 < R) : has_fpower_series_on_ball f (cauchy_power_series f c â†‘R) c â†‘R
theorem fundamental_groupoid_functor.proj_map {I : Type u} (X : I â†’ Top) (i : I) (xâ‚€ xâ‚ : â†¥(fundamental_groupoid.fundamental_groupoid_functor.obj (Top.of (Î  (i : I), â†¥(X i))))) (p : xâ‚€ âŸ¶ xâ‚) : (fundamental_groupoid_functor.proj X i).map p = path.homotopic.proj i p
theorem nat.sub_succ' (a b : â„•) : a - b.succ = a - b - 1
theorem discrete_topology_induced {X : Type u_1} {Y : Type u_2} [tY : topological_space Y] [discrete_topology Y] {f : X â†’ Y} (hf : function.injective f) : discrete_topology X
theorem matrix.pivot.mul_list_transvec_row_last_row {ğ•œ : Type u_3} [field ğ•œ] {r : â„•} (M : matrix (fin r âŠ• unit) (fin r âŠ• unit) ğ•œ) (hM : M (sum.inr ()) (sum.inr ()) â‰  0) (i : fin r) : M.mul (matrix.pivot.list_transvec_row M).prod (sum.inr ()) (sum.inl i) = 0
theorem filter.is_bounded.is_cobounded_flip {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} {f : filter Î±} [is_trans Î± r] [f.ne_bot] : filter.is_bounded r f â†’ filter.is_cobounded (flip r) f
theorem cardinal.cantor_function_injective {c : â„} (h1 : 0 < c) (h2 : c < 1 / 2) : function.injective (cardinal.cantor_function c)
theorem orientation.rotation_pi {V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) : o.rotation â†‘real.pi = linear_isometry_equiv.neg â„
theorem polynomial.dickson_one_one_mul (R : Type u_1) [comm_ring R] (m n : â„•) : polynomial.dickson 1 1 (m * n) = (polynomial.dickson 1 1 m).comp (polynomial.dickson 1 1 n)
theorem max_cases {Î± : Type u} [linear_order Î±] (a b : Î±) : linear_order.max a b = a âˆ§ b â‰¤ a âˆ¨ linear_order.max a b = b âˆ§ a < b
theorem finset.prod_comm' {Î² : Type u} {Î± : Type v} {Î³ : Type w} [comm_monoid Î²] {s : finset Î³} {t : Î³ â†’ finset Î±} {t' : finset Î±} {s' : Î± â†’ finset Î³} (h : âˆ€ (x : Î³) (y : Î±), x âˆˆ s âˆ§ y âˆˆ t x â†” x âˆˆ s' y âˆ§ y âˆˆ t') {f : Î³ â†’ Î± â†’ Î²} : s.prod (Î» (x : Î³), (t x).prod (Î» (y : Î±), f x y)) = t'.prod (Î» (y : Î±), (s' y).prod (Î» (x : Î³), f x y))
theorem affine_subspace.le_def' {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] (s1 s2 : affine_subspace k P) : s1 â‰¤ s2 â†” âˆ€ (p : P), p âˆˆ s1 â†’ p âˆˆ s2
theorem sylow.normalizer_sup_eq_top {G : Type u_1} [group G] {p : â„•} [fact (nat.prime p)] {N : subgroup G} [N.normal] [fintype (sylow p â†¥N)] (P : sylow p â†¥N) : (subgroup.map N.subtype â†‘P).normalizer âŠ” N = âŠ¤
theorem dense.quotient {Î± : Type u} [setoid Î±] [topological_space Î±] {s : set Î±} (H : dense s) : dense (quotient.mk '' s)
theorem complete_lattice.lsum_comp_map_range_to_span_singleton {Î¹ : Type u_1} {R : Type u_2} {N : Type u_5} [dec_Î¹ : decidable_eq Î¹] [semiring R] [add_comm_monoid N] [module R N] [Î  (m : R), decidable (m â‰  0)] (p : Î¹ â†’ submodule R N) {v : Î¹ â†’ N} (hv : âˆ€ (i : Î¹), v i âˆˆ p i) : (â‡‘(dfinsupp.lsum â„•) (Î» (i : Î¹), (p i).subtype)).comp ((dfinsupp.map_range.linear_map (Î» (i : Î¹), linear_map.to_span_singleton R â†¥(p i) âŸ¨v i, _âŸ©)).comp (finsupp_lequiv_dfinsupp R).to_linear_map) = finsupp.total Î¹ N R v
theorem cauchy_seq_of_edist_le_geometric {Î± : Type u_1} [pseudo_emetric_space Î±] (r C : ennreal) (hr : r < 1) (hC : C â‰  âŠ¤) {f : â„• â†’ Î±} (hu : âˆ€ (n : â„•), has_edist.edist (f n) (f (n + 1)) â‰¤ C * r ^ n) : cauchy_seq f
theorem subring.closure_le {R : Type u} [ring R] {s : set R} {t : subring R} : subring.closure s â‰¤ t â†” s âŠ† â†‘t
theorem exists_pos_lt_subset_ball {Î± : Type u} [pseudo_metric_space Î±] [proper_space Î±] {x : Î±} {r : â„} {s : set Î±} (hr : 0 < r) (hs : is_closed s) (h : s âŠ† metric.ball x r) : âˆƒ (r' : â„) (H : r' âˆˆ set.Ioo 0 r), s âŠ† metric.ball x r'
theorem measure_theory.vadd_invariant_measure_tfae (G : Type u_1) {Î± : Type u_3} {m : measurable_space Î±} [add_group G] [add_action G Î±] [measurable_space G] [has_measurable_vadd G Î±] (Î¼ : measure_theory.measure Î±) : [measure_theory.vadd_invariant_measure G Î± Î¼, âˆ€ (c : G) (s : set Î±), measurable_set s â†’ â‡‘Î¼ (has_vadd.vadd c â»Â¹' s) = â‡‘Î¼ s, âˆ€ (c : G) (s : set Î±), measurable_set s â†’ â‡‘Î¼ (c +áµ¥ s) = â‡‘Î¼ s, âˆ€ (c : G) (s : set Î±), â‡‘Î¼ (has_vadd.vadd c â»Â¹' s) = â‡‘Î¼ s, âˆ€ (c : G) (s : set Î±), â‡‘Î¼ (c +áµ¥ s) = â‡‘Î¼ s, âˆ€ (c : G), measure_theory.measure.map (has_vadd.vadd c) Î¼ = Î¼, âˆ€ (c : G), measure_theory.measure_preserving (has_vadd.vadd c) Î¼ Î¼].tfae
theorem linear_map.adjoint_inner_right {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] [inner_product_space ğ•œ F] [finite_dimensional ğ•œ E] [finite_dimensional ğ•œ F] (A : E â†’â‚—[ğ•œ] F) (x : E) (y : F) : has_inner.inner x (â‡‘(â‡‘linear_map.adjoint A) y) = has_inner.inner (â‡‘A x) y
theorem strict_convex_space.of_strict_convex_closed_unit_ball (ğ•œ : Type u_1) {E : Type u_2} [normed_linear_ordered_field ğ•œ] [normed_group E] [normed_space ğ•œ E] [normed_space â„ E] [linear_map.compatible_smul E E ğ•œ â„] (h : strict_convex ğ•œ (metric.closed_ball 0 1)) : strict_convex_space ğ•œ E
theorem quadratic_form.to_fun_eq_coe {R : Type u_2} {M : Type u_3} [add_comm_group M] [ring R] [module R M] {Q : quadratic_form R M} : Q.to_fun = â‡‘Q
theorem category_theory.initial_mono {C : Type u} [category_theory.category C] [category_theory.limits.has_finite_products C] {I : C} (B : C) (t : category_theory.limits.is_initial I) [category_theory.cartesian_closed C] : category_theory.mono (t.to B)
theorem category_theory.limits.image.Î¹_zero' {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_equalizers C] {X Y : C} {f : X âŸ¶ Y} (h : f = 0) [category_theory.limits.has_image f] : category_theory.limits.image.Î¹ f = 0
theorem measure_theory.ext_of_generate_finite {Î± : Type u_1} {m0 : measurable_space Î±} {Î¼ Î½ : measure_theory.measure Î±} (C : set (set Î±)) (hA : m0 = measurable_space.generate_from C) (hC : is_pi_system C) [measure_theory.is_finite_measure Î¼] (hÎ¼Î½ : âˆ€ (s : set Î±), s âˆˆ C â†’ â‡‘Î¼ s = â‡‘Î½ s) (h_univ : â‡‘Î¼ set.univ = â‡‘Î½ set.univ) : Î¼ = Î½
theorem subgroup.mul_normal {G : Type u_1} [group G] (H N : subgroup G) [N.normal] : â†‘(H âŠ” N) = â†‘H * â†‘N
theorem generalized_continued_fraction.squash_seq_eq_self_of_terminated {K : Type u_1} {n : â„•} {s : seq (generalized_continued_fraction.pair K)} [division_ring K] (terminated_at_succ_n : s.terminated_at (n + 1)) : generalized_continued_fraction.squash_seq s n = s
theorem finset.affine_combination_eq_weighted_vsub_of_point_vadd_of_sum_eq_one {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {Î¹ : Type u_4} (s : finset Î¹) (w : Î¹ â†’ k) (p : Î¹ â†’ P) (h : s.sum (Î» (i : Î¹), w i) = 1) (b : P) : â‡‘(s.affine_combination p) w = â‡‘(s.weighted_vsub_of_point p b) w +áµ¥ b
theorem acc.game_add {Î± : Type u_1} {Î² : Type u_2} {rÎ± : Î± â†’ Î± â†’ Prop} {rÎ² : Î² â†’ Î² â†’ Prop} {a : Î±} {b : Î²} (ha : acc rÎ± a) (hb : acc rÎ² b) : acc (relation.game_add rÎ± rÎ²) (a, b)
theorem exists_Union_eq_closed_subset {Î¹ : Type u_1} {X : Type u_2} [topological_space X] [normal_space X] {u : Î¹ â†’ set X} (uo : âˆ€ (i : Î¹), is_open (u i)) (uf : âˆ€ (x : X), {i : Î¹ | x âˆˆ u i}.finite) (uU : (â‹ƒ (i : Î¹), u i) = set.univ) : âˆƒ (v : Î¹ â†’ set X), set.Union v = set.univ âˆ§ (âˆ€ (i : Î¹), is_closed (v i)) âˆ§ âˆ€ (i : Î¹), v i âŠ† u i
theorem continuous_on.strongly_measurable_at_filter_nhds_within {Î± : Type u_1} {Î² : Type u_2} [measurable_space Î±] [topological_space Î±] [opens_measurable_space Î±] [topological_space Î²] [topological_space.pseudo_metrizable_space Î²] [second_countable_topology_either Î± Î²] {f : Î± â†’ Î²} {s : set Î±} {Î¼ : measure_theory.measure Î±} (hf : continuous_on f s) (hs : measurable_set s) (x : Î±) : strongly_measurable_at_filter f (nhds_within x s) Î¼
theorem category_theory.monad.has_limit_of_comp_forget_has_limit {C : Type uâ‚} [category_theory.category C] {T : category_theory.monad C} {J : Type u} [category_theory.category J] (D : J â¥¤ T.algebra) [category_theory.limits.has_limit (D â‹™ T.forget)] : category_theory.limits.has_limit D
theorem tendsto_one_plus_div_rpow_exp (t : â„) : filter.tendsto (Î» (x : â„), (1 + t / x) ^ x) filter.at_top (nhds (real.exp t))
theorem convex.antitone_on_of_deriv_nonpos {D : set â„} (hD : convex â„ D) {f : â„ â†’ â„} (hf : continuous_on f D) (hf' : differentiable_on â„ f (interior D)) (hf'_nonpos : âˆ€ (x : â„), x âˆˆ interior D â†’ deriv f x â‰¤ 0) : antitone_on f D
theorem function.involutive.eq_iff {Î± : Sort u} {f : Î± â†’ Î±} (h : function.involutive f) {x y : Î±} : f x = y â†” x = f y
theorem zmod.nat_cast_zmod_val {n : â„•} [fact (0 < n)] (a : zmod n) : â†‘(a.val) = a
theorem nat.frequently_modeq {n : â„•} (h : n â‰  0) (d : â„•) : âˆƒá¶  (m : â„•) in filter.at_top, m â‰¡ d [MOD n]
theorem basis.eq_of_repr_eq_repr {Î¹ : Type u_1} {R : Type u_3} {M : Type u_5} [semiring R] [add_comm_monoid M] [module R M] {bâ‚ bâ‚‚ : basis Î¹ R M} (h : âˆ€ (x : M) (i : Î¹), â‡‘(â‡‘(bâ‚.repr) x) i = â‡‘(â‡‘(bâ‚‚.repr) x) i) : bâ‚ = bâ‚‚
theorem is_local_min.has_deriv_at_eq_zero {f : â„ â†’ â„} {f' a : â„} (h : is_local_min f a) (hf : has_deriv_at f f' a) : f' = 0
theorem analytic_on.cont_diff_on {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {f : E â†’ F} {s : set E} [complete_space F] (h : analytic_on ğ•œ f s) {n : with_top â„•} : cont_diff_on ğ•œ n f s
theorem monoid_algebra.mem_span_support {k : Type uâ‚} {G : Type uâ‚‚} [semiring k] [mul_one_class G] (f : monoid_algebra k G) : f âˆˆ submodule.span k (â‡‘(monoid_algebra.of k G) '' â†‘(f.support))
theorem category_theory.functor.initial_of_adjunction {C : Type v} [category_theory.small_category C] {D : Type v} [category_theory.small_category D] {L : C â¥¤ D} {R : D â¥¤ C} (adj : L âŠ£ R) : L.initial
theorem list.prod_eq_zero_iff {Mâ‚€ : Type u_6} [monoid_with_zero Mâ‚€] [nontrivial Mâ‚€] [no_zero_divisors Mâ‚€] {L : list Mâ‚€} : L.prod = 0 â†” 0 âˆˆ L
theorem is_torsion.add_subgroup {G : Type u_1} [add_group G] (tG : add_monoid.is_torsion G) (H : add_subgroup G) : add_monoid.is_torsion â†¥H
theorem right.one_lt_mul' {Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_mul.mul) has_le.le] {a b : Î±} (ha : 1 < a) (hb : 1 < b) : 1 < a * b
theorem convex.mem_Ioo {ğ•œ : Type u_1} [linear_ordered_field ğ•œ] {x y : ğ•œ} (h : x < y) {z : ğ•œ} : z âˆˆ set.Ioo x y â†” âˆƒ (a b : ğ•œ), 0 < a âˆ§ 0 < b âˆ§ a + b = 1 âˆ§ a * x + b * y = z
theorem generalized_continued_fraction.terminated_stable {K : Type u_1} {g : generalized_continued_fraction K} {n m : â„•} (n_le_m : n â‰¤ m) (terminated_at_n : g.terminated_at n) : g.terminated_at m
theorem is_submonoid.pow_mem {M : Type u_1} [monoid M] {s : set M} {a : M} (hs : is_submonoid s) (h : a âˆˆ s) {n : â„•} : a ^ n âˆˆ s
theorem has_fderiv_within_at.has_mfderiv_within_at {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {E' : Type u_3} [normed_group E'] [normed_space ğ•œ E'] {f : E â†’ E'} {s : set E} {x : E} {f' : tangent_space (model_with_corners_self ğ•œ E) x â†’L[ğ•œ] tangent_space (model_with_corners_self ğ•œ E') (f x)} : has_fderiv_within_at f f' s x â†’ has_mfderiv_within_at (model_with_corners_self ğ•œ E) (model_with_corners_self ğ•œ E') f s x f'
theorem affine_subspace.span_points_subset_coe_of_subset_coe {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : set P} {s1 : affine_subspace k P} (h : s âŠ† â†‘s1) : span_points k s âŠ† â†‘s1
theorem fintype.exists_lt_sum_fiber_of_nsmul_lt_sum {Î± : Type u} {Î² : Type v} {M : Type w} [decidable_eq Î²] [fintype Î±] [fintype Î²] (f : Î± â†’ Î²) {w : Î± â†’ M} {b : M} [linear_ordered_cancel_add_comm_monoid M] (hb : fintype.card Î² â€¢ b < finset.univ.sum (Î» (x : Î±), w x)) : âˆƒ (y : Î²), b < (finset.filter (Î» (x : Î±), f x = y) finset.univ).sum (Î» (x : Î±), w x)
theorem continuous_map.dist_le {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [compact_space Î±] [metric_space Î²] {f g : C(Î±, Î²)} {C : â„} (C0 : 0 â‰¤ C) : has_dist.dist f g â‰¤ C â†” âˆ€ (x : Î±), has_dist.dist (â‡‘f x) (â‡‘g x) â‰¤ C
theorem leibniz_cross {R : Type u_1} [comm_ring R] (u v w : fin 3 â†’ R) : â‡‘(â‡‘cross_product u) (â‡‘(â‡‘cross_product v) w) = â‡‘(â‡‘cross_product (â‡‘(â‡‘cross_product u) v)) w + â‡‘(â‡‘cross_product v) (â‡‘(â‡‘cross_product u) w)
theorem finset.card_mul_le_card_mul {Î± : Type u_1} {Î² : Type u_2} (r : Î± â†’ Î² â†’ Prop) {s : finset Î±} {t : finset Î²} {m n : â„•} [Î  (a : Î±) (b : Î²), decidable (r a b)] (hm : âˆ€ (a : Î±), a âˆˆ s â†’ m â‰¤ (finset.bipartite_above r t a).card) (hn : âˆ€ (b : Î²), b âˆˆ t â†’ (finset.bipartite_below r s b).card â‰¤ n) : s.card * m â‰¤ t.card * n
theorem metric.forall_of_forall_mem_ball {Î± : Type u} [pseudo_metric_space Î±] (p : Î± â†’ Prop) (x : Î±) (H : âˆƒá¶  (R : â„) in filter.at_top, âˆ€ (y : Î±), y âˆˆ metric.ball x R â†’ p y) (y : Î±) : p y
theorem is_upper_set.to_dual {Î± : Type u_1} [has_le Î±] {s : set Î±áµ’áµˆ} : is_upper_set s â†’ is_lower_set (â‡‘order_dual.to_dual â»Â¹' s)
theorem algebra.left_comm {R : Type u} {A : Type w} [comm_semiring R] [semiring A] [algebra R A] (x : A) (r : R) (y : A) : x * (â‡‘(algebra_map R A) r * y) = â‡‘(algebra_map R A) r * (x * y)
theorem is_primitive_root.disjoint {R : Type u_5} [comm_ring R] [is_domain R] {k l : â„•} (h : k â‰  l) : disjoint (primitive_roots k R) (primitive_roots l R)
theorem is_right_regular_of_right_cancel_semigroup {R : Type u_1} [right_cancel_semigroup R] (g : R) : is_right_regular g
theorem finite_cover_balls_of_compact {Î± : Type u} [pseudo_metric_space Î±] {s : set Î±} (hs : is_compact s) {e : â„} (he : 0 < e) : âˆƒ (t : set Î±) (H : t âŠ† s), t.finite âˆ§ s âŠ† â‹ƒ (x : Î±) (H : x âˆˆ t), metric.ball x e
theorem set.Icc_diff_pi_univ_Ioo_subset {Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_2} [decidable_eq Î¹] [Î  (i : Î¹), linear_order (Î± i)] (x y x' y' : Î  (i : Î¹), Î± i) : set.Icc x y  set.univ.pi (Î» (i : Î¹), set.Ioo (x' i) (y' i)) âŠ† (â‹ƒ (i : Î¹), set.Icc x (function.update y i (x' i))) âˆª â‹ƒ (i : Î¹), set.Icc (function.update x i (y' i)) y
theorem le_nhds_of_cauchy_adhp {Î± : Type u} [uniform_space Î±] {f : filter Î±} {x : Î±} (hf : cauchy f) (adhs : cluster_pt x f) : f â‰¤ nhds x
theorem equiv.perm.cycle_factors_finset_injective {Î± : Type u_1} [decidable_eq Î±] [fintype Î±] : function.injective equiv.perm.cycle_factors_finset
theorem units.coe_dvd {Î± : Type u_1} [monoid Î±] {a : Î±} {u : Î±Ë£} : â†‘u âˆ£ a
theorem fintype.exists_card_fiber_le_of_card_le_nsmul {Î± : Type u} {Î² : Type v} {M : Type w} [decidable_eq Î²] [fintype Î±] [fintype Î²] (f : Î± â†’ Î²) {b : M} [linear_ordered_comm_ring M] [nonempty Î²] (hb : â†‘(fintype.card Î±) â‰¤ fintype.card Î² â€¢ b) : âˆƒ (y : Î²), â†‘((finset.filter (Î» (x : Î±), f x = y) finset.univ).card) â‰¤ b
theorem finset.sum_card_inter {Î± : Type u_2} [decidable_eq Î±] {s : finset Î±} {B : finset (finset Î±)} {n : â„•} (h : âˆ€ (a : Î±), a âˆˆ s â†’ (finset.filter (has_mem.mem a) B).card = n) : B.sum (Î» (t : finset Î±), (s âˆ© t).card) = s.card * n
theorem finset.exists_le_sum_fiber_of_sum_fiber_nonpos_of_nsmul_le_sum {Î± : Type u} {Î² : Type v} {M : Type w} [decidable_eq Î²] {s : finset Î±} {t : finset Î²} {f : Î± â†’ Î²} {w : Î± â†’ M} {b : M} [linear_ordered_cancel_add_comm_monoid M] (hf : âˆ€ (y : Î²), y âˆ‰ t â†’ (finset.filter (Î» (x : Î±), f x = y) s).sum (Î» (x : Î±), w x) â‰¤ 0) (ht : t.nonempty) (hb : t.card â€¢ b â‰¤ s.sum (Î» (x : Î±), w x)) : âˆƒ (y : Î²) (H : y âˆˆ t), b â‰¤ (finset.filter (Î» (x : Î±), f x = y) s).sum (Î» (x : Î±), w x)
theorem reflection_reflection {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] (K : submodule ğ•œ E) [complete_space â†¥K] (p : E) : â‡‘(reflection K) (â‡‘(reflection K) p) = p
theorem real.summable_one_div_nat_pow {p : â„•} : summable (Î» (n : â„•), 1 / â†‘n ^ p) â†” 1 < p
theorem is_compact_of_finite_subfamily_closed {Î± : Type u} [topological_space Î±] {s : set Î±} (h : âˆ€ {Î¹ : Type u} (Z : Î¹ â†’ set Î±), (âˆ€ (i : Î¹), is_closed (Z i)) â†’ (s âˆ© â‹‚ (i : Î¹), Z i) = âˆ… â†’ (âˆƒ (t : finset Î¹), (s âˆ© â‹‚ (i : Î¹) (H : i âˆˆ t), Z i) = âˆ…)) : is_compact s
theorem compact_open_separated_mul_left {G : Type w} [topological_space G] [group G] [topological_group G] {K U : set G} (hK : is_compact K) (hU : is_open U) (hKU : K âŠ† U) : âˆƒ (V : set G) (H : V âˆˆ nhds 1), V * K âŠ† U
theorem no_min_order.infinite {Î± : Type u_1} [preorder Î±] [nonempty Î±] [no_min_order Î±] : infinite Î±
theorem cont_diff_succ_iff_fderiv_apply {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] [complete_space ğ•œ] [finite_dimensional ğ•œ E] {n : â„•} {f : E â†’ F} : cont_diff ğ•œ â†‘(n + 1) f â†” differentiable ğ•œ f âˆ§ âˆ€ (y : E), cont_diff ğ•œ â†‘n (Î» (x : E), â‡‘(fderiv ğ•œ f x) y)
theorem matrix.det_from_blocksâ‚‚â‚‚ {m : Type u} {n : Type u'} {Î± : Type v} [fintype n] [decidable_eq n] [comm_ring Î±] [fintype m] [decidable_eq m] (A : matrix m m Î±) (B : matrix m n Î±) (C : matrix n m Î±) (D : matrix n n Î±) [invertible D] : (matrix.from_blocks A B C D).det = D.det * (A - (B.mul (â…Ÿ D)).mul C).det
theorem linear_map.aeval_eq_aeval_mod_charpoly {R : Type u} {M : Type v} [comm_ring R] [nontrivial R] [add_comm_group M] [module R M] [module.free R M] [module.finite R M] (f : M â†’â‚—[R] M) (p : polynomial R) : â‡‘(polynomial.aeval f) p = â‡‘(polynomial.aeval f) (p %â‚˜ f.charpoly)
theorem Top.presheaf.is_gluing_iff_eq_res {X : Top} (F : Top.presheaf (Type v) X) {Î¹ : Type v} (U : Î¹ â†’ topological_space.opens â†¥X) (sf : Top.presheaf.sheaf_condition_equalizer_products.pi_opens F U) (s : F.obj (opposite.op (supr U))) : F.is_gluing U ((F.pi_opens_iso_sections_family U).hom sf) s â†” Top.presheaf.sheaf_condition_equalizer_products.res F U s = sf
theorem monotone_on.convex_on_of_deriv {D : set â„} (hD : convex â„ D) {f : â„ â†’ â„} (hf : continuous_on f D) (hf' : differentiable_on â„ f (interior D)) (hf'_mono : monotone_on (deriv f) (interior D)) : convex_on â„ D f
theorem antitone.cauchy_seq_alternating_series_of_tendsto_zero {f : â„• â†’ â„} (hfa : antitone f) (hf0 : filter.tendsto f filter.at_top (nhds 0)) : cauchy_seq (Î» (n : â„•), (finset.range (n + 1)).sum (Î» (i : â„•), (-1) ^ i * f i))
theorem Vieta_formula_quadratic {Î± : Type u} [non_unital_comm_ring Î±] {b c x : Î±} (h : x * x - b * x + c = 0) : âˆƒ (y : Î±), y * y - b * y + c = 0 âˆ§ x + y = b âˆ§ x * y = c
theorem is_min_on.of_is_local_min_on_of_convex_on_Icc {Î² : Type u_2} [ordered_add_comm_group Î²] [module â„ Î²] [ordered_smul â„ Î²] {f : â„ â†’ Î²} {a b : â„} (a_lt_b : a < b) (h_local_min : is_local_min_on f (set.Icc a b) a) (h_conv : convex_on â„ (set.Icc a b) f) : is_min_on f (set.Icc a b) a
theorem free_product.ext_hom {Î¹ : Type u_1} {M : Î¹ â†’ Type u_2} [Î  (i : Î¹), monoid (M i)] {N : Type u_3} [monoid N] (f g : free_product M â†’* N) (h : âˆ€ (i : Î¹), f.comp free_product.of = g.comp free_product.of) : f = g
theorem con.ext_iff {M : Type u_1} [has_mul M] {c d : con M} : (âˆ€ (x y : M), â‡‘c x y â†” â‡‘d x y) â†” c = d
theorem finsupp.inner_sum {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {Î¹ : Type u_3} (l : Î¹ â†’â‚€ ğ•œ) (v : Î¹ â†’ E) (x : E) : has_inner.inner x (l.sum (Î» (i : Î¹) (a : ğ•œ), a â€¢ v i)) = l.sum (Î» (i : Î¹) (a : ğ•œ), a â€¢ has_inner.inner x (v i))
theorem power_series.le_order_add {R : Type u_1} [semiring R] (Ï† Ïˆ : power_series R) : linear_order.min Ï†.order Ïˆ.order â‰¤ (Ï† + Ïˆ).order
theorem norm_mk_nonneg {M : Type u_1} [semi_normed_group M] (S : add_subgroup M) (m : M) : 0 â‰¤ âˆ¥â‡‘(quotient_add_group.mk' S) mâˆ¥
theorem norm_add_mul_self {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {x y : E} : âˆ¥x + yâˆ¥ * âˆ¥x + yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + 2 * â‡‘is_R_or_C.re (has_inner.inner x y) + âˆ¥yâˆ¥ * âˆ¥yâˆ¥
theorem local_homeomorph.has_fderiv_at_symm {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] (f : local_homeomorph E F) {f' : E â‰ƒL[ğ•œ] F} {a : F} (ha : a âˆˆ f.to_local_equiv.target) (htff' : has_fderiv_at â‡‘f â†‘f' (â‡‘(f.symm) a)) : has_fderiv_at â‡‘(f.symm) â†‘(f'.symm) a
theorem setoid.mk_classes_classes {Î± : Type u_1} (r : setoid Î±) : setoid.mk_classes r.classes setoid.classes_eqv_classes = r
theorem generate_from_eq_prod {Î± : Type u_1} {Î² : Type u_3} [measurable_space Î±] [measurable_space Î²] {C : set (set Î±)} {D : set (set Î²)} (hC : measurable_space.generate_from C = _inst_1) (hD : measurable_space.generate_from D = _inst_3) (h2C : is_countably_spanning C) (h2D : is_countably_spanning D) : measurable_space.generate_from (set.image2 has_set_prod.prod C D) = prod.measurable_space
theorem cardinal.mk_Ici_real (a : â„) : cardinal.mk â†¥(set.Ici a) = cardinal.continuum
theorem vitali_family.ae_tendsto_measure_inter_div_of_measurable_set {Î± : Type u_1} [metric_space Î±] {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (v : vitali_family Î¼) [sigma_compact_space Î±] [borel_space Î±] [measure_theory.is_locally_finite_measure Î¼] {s : set Î±} (hs : measurable_set s) : âˆ€áµ (x : Î±) âˆ‚Î¼, filter.tendsto (Î» (a : set Î±), â‡‘Î¼ (s âˆ© a) / â‡‘Î¼ a) (v.filter_at x) (nhds (s.indicator 1 x))
theorem same_ray.symm {R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {x y : M} (h : same_ray R x y) : same_ray R y x
theorem polynomial.gal.gal_action_hom_bijective_of_prime_degree {p : polynomial â„š} (p_irr : irreducible p) (p_deg : nat.prime p.nat_degree) (p_roots : fintype.card â†¥(p.root_set â„‚) = fintype.card â†¥(p.root_set â„) + 2) : function.bijective â‡‘(polynomial.gal.gal_action_hom p â„‚)
theorem add_equiv.symm_apply_apply {M : Type u_6} {N : Type u_7} [has_add M] [has_add N] (e : M â‰ƒ+ N) (x : M) : â‡‘(e.symm) (â‡‘e x) = x
theorem measure_theory.measure.preimage_null_of_map_null {Î± : Type u_1} {Î² : Type u_2} {m0 : measurable_space Î±} [measurable_space Î²] {Î¼ : measure_theory.measure Î±} {f : Î± â†’ Î²} (hf : ae_measurable f Î¼) {s : set Î²} (hs : â‡‘(measure_theory.measure.map f Î¼) s = 0) : â‡‘Î¼ (f â»Â¹' s) = 0
theorem formal_multilinear_series.comp_along_composition_bound {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [nondiscrete_normed_field ğ•œ] [normed_group E] [normed_space ğ•œ E] [normed_group F] [normed_space ğ•œ F] [normed_group G] [normed_space ğ•œ G] {n : â„•} (p : formal_multilinear_series ğ•œ E F) (c : composition n) (f : continuous_multilinear_map ğ•œ (Î» (i : fin c.length), F) G) (v : fin n â†’ E) : âˆ¥â‡‘(continuous_multilinear_map.comp_along_composition p c f) vâˆ¥ â‰¤ âˆ¥fâˆ¥ * finset.univ.prod (Î» (i : fin c.length), âˆ¥p (c.blocks_fun i)âˆ¥) * finset.univ.prod (Î» (i : fin n), âˆ¥v iâˆ¥)
theorem submonoid.closure_mono {M : Type u_1} [mul_one_class M] â¦ƒs t : set Mâ¦„ (h : s âŠ† t) : submonoid.closure s â‰¤ submonoid.closure t
theorem one_div_lt_one_div {Î± : Type u_1} [linear_ordered_field Î±] {a b : Î±} (ha : 0 < a) (hb : 0 < b) : 1 / a < 1 / b â†” b < a
theorem convex_iff_div {ğ•œ : Type u_1} {E : Type u_2} [linear_ordered_field ğ•œ] [add_comm_group E] [module ğ•œ E] {s : set E} : convex ğ•œ s â†” âˆ€ â¦ƒx y : Eâ¦„, x âˆˆ s â†’ y âˆˆ s â†’ âˆ€ â¦ƒa b : ğ•œâ¦„, 0 â‰¤ a â†’ 0 â‰¤ b â†’ 0 < a + b â†’ (a / (a + b)) â€¢ x + (b / (a + b)) â€¢ y âˆˆ s
theorem innerSL_apply_norm {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {x : E} : âˆ¥â‡‘innerSL xâˆ¥ = âˆ¥xâˆ¥
theorem filter.at_top_le_cofinite {Î± : Type u_2} [preorder Î±] [no_max_order Î±] : filter.at_top â‰¤ filter.cofinite
theorem padic_int.lift_spec {p : â„•} [hp_prime : fact (nat.prime p)] {R : Type u_1} [non_assoc_semiring R] {f : Î  (k : â„•), R â†’+* zmod (p ^ k)} (f_compat : âˆ€ (k1 k2 : â„•) (hk : k1 â‰¤ k2), (zmod.cast_hom _ (zmod (p ^ k1))).comp (f k2) = f k1) (n : â„•) : (padic_int.to_zmod_pow n).comp (padic_int.lift f_compat) = f n
theorem local_ring.of_unique_max_ideal {R : Type u} [comm_semiring R] (h : âˆƒ! (I : ideal R), I.is_maximal) : local_ring R
theorem finset.prod_subtype_map_embedding {Î² : Type u} {Î± : Type v} [comm_monoid Î²] {p : Î± â†’ Prop} {s : finset {x // p x}} {f : {x // p x} â†’ Î²} {g : Î± â†’ Î²} (h : âˆ€ (x : {x // p x}), x âˆˆ s â†’ g â†‘x = f x) : (finset.map (function.embedding.subtype (Î» (x : Î±), p x)) s).prod (Î» (x : Î±), g x) = s.prod (Î» (x : {x // p x}), f x)
theorem set.mem_fintype_sum {Î± : Type u_2} {Î¹ : Type u_5} [add_comm_monoid Î±] [fintype Î¹] (f : Î¹ â†’ set Î±) (a : Î±) : a âˆˆ finset.univ.sum (Î» (i : Î¹), f i) â†” âˆƒ (g : Î¹ â†’ Î±) (hg : âˆ€ (i : Î¹), g i âˆˆ f i), finset.univ.sum (Î» (i : Î¹), g i) = a
theorem polynomial.taylor_coeff {R : Type u_1} [semiring R] (r : R) (f : polynomial R) (n : â„•) : (â‡‘(polynomial.taylor r) f).coeff n = polynomial.eval r (â‡‘(polynomial.hasse_deriv n) f)
theorem nat.upto.wf {p : â„• â†’ Prop} : (âˆƒ (x : â„•), p x) â†’ well_founded (nat.upto.gt p)
theorem measure_theory.tendsto_uniformly_on_of_ae_tendsto {Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_3} {m : measurable_space Î±} [metric_space Î²] {Î¼ : measure_theory.measure Î±} [semilattice_sup Î¹] [nonempty Î¹] [encodable Î¹] {f : Î¹ â†’ Î± â†’ Î²} {g : Î± â†’ Î²} {s : set Î±} (hf : âˆ€ (n : Î¹), measure_theory.strongly_measurable (f n)) (hg : measure_theory.strongly_measurable g) (hsm : measurable_set s) (hs : â‡‘Î¼ s â‰  âŠ¤) (hfg : âˆ€áµ (x : Î±) âˆ‚Î¼, x âˆˆ s â†’ filter.tendsto (Î» (n : Î¹), f n x) filter.at_top (nhds (g x))) {Îµ : â„} (hÎµ : 0 < Îµ) : âˆƒ (t : set Î±) (H : t âŠ† s), measurable_set t âˆ§ â‡‘Î¼ t â‰¤ ennreal.of_real Îµ âˆ§ tendsto_uniformly_on f g filter.at_top (s  t)
theorem exists_closed_cover_approximates_linear_on_of_has_fderiv_within_at {E : Type u_1} {F : Type u_2} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] [normed_group F] [normed_space â„ F] [topological_space.second_countable_topology F] (f : E â†’ F) (s : set E) (f' : E â†’ (E â†’L[â„] F)) (hf' : âˆ€ (x : E), x âˆˆ s â†’ has_fderiv_within_at f (f' x) s x) (r : (E â†’L[â„] F) â†’ nnreal) (rpos : âˆ€ (A : E â†’L[â„] F), r A â‰  0) : âˆƒ (t : â„• â†’ set E) (A : â„• â†’ (E â†’L[â„] F)), (âˆ€ (n : â„•), is_closed (t n)) âˆ§ (s âŠ† â‹ƒ (n : â„•), t n) âˆ§ (âˆ€ (n : â„•), approximates_linear_on f (A n) (s âˆ© t n) (r (A n))) âˆ§ (s.nonempty â†’ âˆ€ (n : â„•), âˆƒ (y : E) (H : y âˆˆ s), A n = f' y)
theorem bilin_form.restrict_nondegenerate_iff_is_compl_orthogonal {V : Type u_9} {K : Type u_10} [field K] [add_comm_group V] [module K V] [finite_dimensional K V] {B : bilin_form K V} {W : subspace K V} (bâ‚ : B.is_refl) : (B.restrict W).nondegenerate â†” is_compl W (B.orthogonal W)
theorem category_theory.presieve.family_of_elements.compatible.functor_pushforward {C : Type uâ‚} [category_theory.category C] {D : Type uâ‚‚} [category_theory.category D] {K : category_theory.grothendieck_topology D} {G : C â¥¤ D} (hG : category_theory.compatible_preserving K G) (â„± : category_theory.SheafOfTypes K) {Z : C} {T : category_theory.presieve Z} {x : category_theory.presieve.family_of_elements (G.op â‹™ â„±.val) T} (h : x.compatible) : (category_theory.presieve.family_of_elements.functor_pushforward G x).compatible
theorem mv_polynomial.prod_X_add_C_eval {R : Type u_1} [comm_semiring R] (Ïƒ : Type u_2) [fintype Ïƒ] (r : Ïƒ â†’ R) : finset.univ.prod (Î» (i : Ïƒ), â‡‘polynomial.C (r i) + polynomial.X) = (finset.range (fintype.card Ïƒ + 1)).sum (Î» (i : â„•), (finset.powerset_len i finset.univ).sum (Î» (t : finset Ïƒ), t.prod (Î» (i : Ïƒ), â‡‘polynomial.C (r i))) * polynomial.X ^ (fintype.card Ïƒ - i))
theorem norm_image_sub_le_of_norm_deriv_right_le_segment {E : Type u_1} [normed_group E] [normed_space â„ E] {f : â„ â†’ E} {a b : â„} {f' : â„ â†’ E} {C : â„} (hf : continuous_on f (set.Icc a b)) (hf' : âˆ€ (x : â„), x âˆˆ set.Ico a b â†’ has_deriv_within_at f (f' x) (set.Ici x) x) (bound : âˆ€ (x : â„), x âˆˆ set.Ico a b â†’ âˆ¥f' xâˆ¥ â‰¤ C) (x : â„) (H : x âˆˆ set.Icc a b) : âˆ¥f x - f aâˆ¥ â‰¤ C * (x - a)
theorem has_lt.lt.ne_top {Î± : Type u} [preorder Î±] [order_top Î±] {a b : Î±} (h : a < b) : a â‰  âŠ¤
theorem subgroup.closure_mono {G : Type u_1} [group G] â¦ƒh k : set Gâ¦„ (h' : h âŠ† k) : subgroup.closure h â‰¤ subgroup.closure k
theorem con.lift_surjective_of_surjective {M : Type u_1} {P : Type u_3} [mul_one_class M] [mul_one_class P] {c : con M} {f : M â†’* P} (h : c â‰¤ con.ker f) (hf : function.surjective â‡‘f) : function.surjective â‡‘(c.lift f h)
theorem squeeze_zero' {Î± : Type u_1} {f g : Î± â†’ â„} {tâ‚€ : filter Î±} (hf : âˆ€á¶  (t : Î±) in tâ‚€, 0 â‰¤ f t) (hft : âˆ€á¶  (t : Î±) in tâ‚€, f t â‰¤ g t) (g0 : filter.tendsto g tâ‚€ (nhds 0)) : filter.tendsto f tâ‚€ (nhds 0)
theorem nnreal.inner_le_Lp_mul_Lq_tsum {Î¹ : Type u} {f g : Î¹ â†’ nnreal} {p q : â„} (hpq : p.is_conjugate_exponent q) (hf : summable (Î» (i : Î¹), f i ^ p)) (hg : summable (Î» (i : Î¹), g i ^ q)) : summable (Î» (i : Î¹), f i * g i) âˆ§ âˆ‘' (i : Î¹), f i * g i â‰¤ (âˆ‘' (i : Î¹), f i ^ p) ^ (1 / p) * (âˆ‘' (i : Î¹), g i ^ q) ^ (1 / q)
theorem finite_dimensional.of_fintype_basis {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {Î¹ : Type w} [fintype Î¹] (h : basis Î¹ K V) : finite_dimensional K V
theorem set.pairwise.subsingleton {Î± : Type u_1} {s : set Î±} : s.pairwise âŠ¥ â†’ s.subsingleton
theorem is_o_pow_const_mul_const_pow_const_pow_of_norm_lt {R : Type u_1} [normed_ring R] (k : â„•) {râ‚ : R} {râ‚‚ : â„} (h : âˆ¥râ‚âˆ¥ < râ‚‚) : (Î» (n : â„•), â†‘n ^ k * râ‚ ^ n) =o[filter.at_top] Î» (n : â„•), râ‚‚ ^ n
theorem list.drop_append_eq_append_drop {Î± : Type u} {lâ‚ lâ‚‚ : list Î±} {n : â„•} : list.drop n (lâ‚ ++ lâ‚‚) = list.drop n lâ‚ ++ list.drop (n - lâ‚.length) lâ‚‚
theorem fintype.linear_independent_iff' {Î¹ : Type u_1} {R : Type u_3} {M : Type u_5} {v : Î¹ â†’ M} [semiring R] [add_comm_monoid M] [module R M] [fintype Î¹] : linear_independent R v â†” (â‡‘(linear_map.lsum R (Î» (i : Î¹), R) â„•) (Î» (i : Î¹), linear_map.id.smul_right (v i))).ker = âŠ¥
theorem category_theory.grothendieck_topology.intersection_covering {C : Type u} [category_theory.category C] {X : C} {S R : category_theory.sieve X} (J : category_theory.grothendieck_topology C) (rj : R âˆˆ â‡‘J X) (sj : S âˆˆ â‡‘J X) : R âŠ“ S âˆˆ â‡‘J X
theorem category_theory.limits.initial_mono_class.of_terminal {C : Type uâ‚} [category_theory.category C] [category_theory.limits.has_initial C] [category_theory.limits.has_terminal C] (h : category_theory.mono (category_theory.limits.initial.to (âŠ¤_ C))) : category_theory.limits.initial_mono_class C
theorem first_order.language.age_direct_limit {L : first_order.language} {Î¹ : Type w} [preorder Î¹] [is_directed Î¹ has_le.le] [nonempty Î¹] (G : Î¹ â†’ Type (max w w')) [Î  (i : Î¹), L.Structure (G i)] (f : Î  (i j : Î¹), i â‰¤ j â†’ L.embedding (G i) (G j)) [directed_system G (Î» (i j : Î¹) (h : i â‰¤ j), â‡‘(f i j h))] : L.age (first_order.language.direct_limit G f) = â‹ƒ (i : Î¹), L.age (G i)
theorem witt_vector.add_is_polyâ‚‚ {p : â„•} [fact (nat.prime p)] : witt_vector.is_polyâ‚‚ p (Î» (_x : Type u_1) (_x_1 : comm_ring _x), has_add.add)
theorem finprod_mem_insert_of_eq_one_if_not_mem {Î± : Type u_1} {M : Type u_5} [comm_monoid M] {f : Î± â†’ M} {a : Î±} {s : set Î±} (h : a âˆ‰ s â†’ f a = 1) : finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ has_insert.insert a s), f i)) = finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), f i))
theorem is_extr_filter.dual {Î± : Type u} {Î² : Type v} [preorder Î²] {f : Î± â†’ Î²} {l : filter Î±} {a : Î±} : is_extr_filter f l a â†’ is_extr_filter (â‡‘order_dual.to_dual âˆ˜ f) l a
theorem is_dedekind_domain.height_one_spectrum.int_valuation_exists_uniformizer {R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] (v : is_dedekind_domain.height_one_spectrum R) : âˆƒ (Ï€ : R), v.int_valuation_def Ï€ = â†‘(â‡‘multiplicative.of_add (-1))
theorem commute.add_pow {R : Type u_1} [semiring R] {x y : R} (h : commute x y) (n : â„•) : (x + y) ^ n = (finset.range (n + 1)).sum (Î» (m : â„•), x ^ m * y ^ (n - m) * â†‘(n.choose m))
theorem trans_gen_of_pred_of_gt {Î± : Type u_1} [partial_order Î±] [pred_order Î±] [is_pred_archimedean Î±] (r : Î± â†’ Î± â†’ Prop) {n m : Î±} (h : âˆ€ (i : Î±), i âˆˆ set.Ioc m n â†’ r i (order.pred i)) (hnm : m < n) : relation.trans_gen r n m
theorem monoid_hom.map_mclosure {M : Type u_1} {N : Type u_2} [mul_one_class M] [mul_one_class N] (f : M â†’* N) (s : set M) : submonoid.map f (submonoid.closure s) = submonoid.closure (â‡‘f '' s)
theorem submonoid.localization_map.exists_of_sec_mk' {M : Type u_1} [comm_monoid M] {S : submonoid M} {N : Type u_2} [comm_monoid N] (f : S.localization_map N) (x : M) (y : â†¥S) : âˆƒ (c : â†¥S), x * â†‘((f.sec (f.mk' x y)).snd) * â†‘c = (f.sec (f.mk' x y)).fst * â†‘y * â†‘c
theorem maximal_orthonormal_iff_orthogonal_complement_eq_bot {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {v : set E} (hv : orthonormal ğ•œ coe) : (âˆ€ (u : set E), u âŠ‡ v â†’ orthonormal ğ•œ coe â†’ u = v) â†” (submodule.span ğ•œ v)á—® = âŠ¥
theorem multilinear_map.exists_bound_of_continuous {ğ•œ : Type u} {Î¹ : Type v} {E : Î¹ â†’ Type wE} {G : Type wG} [decidable_eq Î¹] [fintype Î¹] [nondiscrete_normed_field ğ•œ] [Î  (i : Î¹), normed_group (E i)] [Î  (i : Î¹), normed_space ğ•œ (E i)] [normed_group G] [normed_space ğ•œ G] (f : multilinear_map ğ•œ E G) (hf : continuous â‡‘f) : âˆƒ (C : â„), 0 < C âˆ§ âˆ€ (m : Î  (i : Î¹), E i), âˆ¥â‡‘f mâˆ¥ â‰¤ C * finset.univ.prod (Î» (i : Î¹), âˆ¥m iâˆ¥)
theorem char.quadratic_char_exists_neg_one {F : Type u_1} [field F] [fintype F] [decidable_eq F] (hF : ring_char F â‰  2) : âˆƒ (a : F), char.quadratic_char F a = -1
theorem re_inner_eq_norm_add_mul_self_sub_norm_mul_self_sub_norm_mul_self_div_two {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] (x y : E) : â‡‘is_R_or_C.re (has_inner.inner x y) = (âˆ¥x + yâˆ¥ * âˆ¥x + yâˆ¥ - âˆ¥xâˆ¥ * âˆ¥xâˆ¥ - âˆ¥yâˆ¥ * âˆ¥yâˆ¥) / 2
theorem add_subgroup.zero_mem {G : Type u_1} [add_group G] (H : add_subgroup G) : 0 âˆˆ H
theorem finset.exists_smaller_set {Î± : Type u_1} (A : finset Î±) (i : â„•) (hâ‚ : i â‰¤ A.card) : âˆƒ (B : finset Î±), B âŠ† A âˆ§ B.card = i
theorem measure_theory.tendsto_in_measure_of_tendsto_ae_of_strongly_measurable {Î± : Type u_1} {E : Type u_3} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [metric_space E] {f : â„• â†’ Î± â†’ E} {g : Î± â†’ E} [measure_theory.is_finite_measure Î¼] (hf : âˆ€ (n : â„•), measure_theory.strongly_measurable (f n)) (hg : measure_theory.strongly_measurable g) (hfg : âˆ€áµ (x : Î±) âˆ‚Î¼, filter.tendsto (Î» (n : â„•), f n x) filter.at_top (nhds (g x))) : measure_theory.tendsto_in_measure Î¼ f filter.at_top g
theorem category_theory.abelian.functor.left_derived_zero_to_self_natural {C : Type u} [category_theory.category C] {D : Type u} [category_theory.category D] (F : C â¥¤ D) [category_theory.abelian C] [category_theory.abelian D] [F.additive] [category_theory.enough_projectives C] {X Y : C} (f : X âŸ¶ Y) (P : category_theory.ProjectiveResolution X) (Q : category_theory.ProjectiveResolution Y) : (F.left_derived 0).map f â‰« category_theory.abelian.functor.left_derived_zero_to_self_app F Q = category_theory.abelian.functor.left_derived_zero_to_self_app F P â‰« F.map f
theorem metric.cauchy_seq_iff' {Î± : Type u} {Î² : Type v} [pseudo_metric_space Î±] [nonempty Î²] [semilattice_sup Î²] {u : Î² â†’ Î±} : cauchy_seq u â†” âˆ€ (Îµ : â„), Îµ > 0 â†’ (âˆƒ (N : Î²), âˆ€ (n : Î²), n â‰¥ N â†’ has_dist.dist (u n) (u N) < Îµ)
theorem bounded_continuous_function.continuous_comp {Î± : Type u} {Î² : Type v} {Î³ : Type w} [topological_space Î±] [pseudo_metric_space Î²] [pseudo_metric_space Î³] {G : Î² â†’ Î³} {C : nnreal} (H : lipschitz_with C G) : continuous (bounded_continuous_function.comp G H)
theorem order_iso.map_tsub {M : Type u_1} {N : Type u_2} [preorder M] [has_add M] [has_sub M] [has_ordered_sub M] [partial_order N] [has_add N] [has_sub N] [has_ordered_sub N] (e : M â‰ƒo N) (h_add : âˆ€ (a b : M), â‡‘e (a + b) = â‡‘e a + â‡‘e b) (a b : M) : â‡‘e (a - b) = â‡‘e a - â‡‘e b
theorem Top.presheaf.covering_of_presieve.supr_eq_of_mem_grothendieck {X : Top} (U : topological_space.opens â†¥X) (R : category_theory.presieve U) (hR : category_theory.sieve.generate R âˆˆ â‡‘(opens.grothendieck_topology â†¥X) U) : supr (Top.presheaf.covering_of_presieve U R) = U
theorem equiv.cardinal_eq {Î± Î² : Type u} (e : Î± â‰ƒ Î²) : cardinal.mk Î± = cardinal.mk Î²
theorem tendsto_div_of_monotone_of_exists_subseq_tendsto_div (u : â„• â†’ â„) (l : â„) (hmono : monotone u) (hlim : âˆ€ (a : â„), 1 < a â†’ (âˆƒ (c : â„• â†’ â„•), (âˆ€á¶  (n : â„•) in filter.at_top, â†‘(c (n + 1)) â‰¤ a * â†‘(c n)) âˆ§ filter.tendsto c filter.at_top filter.at_top âˆ§ filter.tendsto (Î» (n : â„•), u (c n) / â†‘(c n)) filter.at_top (nhds l))) : filter.tendsto (Î» (n : â„•), u n / â†‘n) filter.at_top (nhds l)
theorem monovary_on.sum_comp_perm_smul_le_sum_smul {Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [linear_ordered_ring Î±] [linear_ordered_add_comm_group Î²] [module Î± Î²] [ordered_smul Î± Î²] {s : finset Î¹} {Ïƒ : equiv.perm Î¹} {f : Î¹ â†’ Î±} {g : Î¹ â†’ Î²} (hfg : monovary_on f g â†‘s) (hÏƒ : {x : Î¹ | â‡‘Ïƒ x â‰  x} âŠ† â†‘s) : s.sum (Î» (i : Î¹), f (â‡‘Ïƒ i) â€¢ g i) â‰¤ s.sum (Î» (i : Î¹), f i â€¢ g i)
theorem strict_convex.preimage_add_left {ğ•œ : Type u_1} {E : Type u_3} [ordered_semiring ğ•œ] [topological_space E] [add_cancel_comm_monoid E] [has_continuous_add E] [module ğ•œ E] {s : set E} (hs : strict_convex ğ•œ s) (z : E) : strict_convex ğ•œ ((Î» (x : E), x + z) â»Â¹' s)
theorem dense_range_stone_cech_unit {Î± : Type u} [topological_space Î±] : dense_range stone_cech_unit
theorem vsub_mem_vector_span (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : set P} {p1 p2 : P} (hp1 : p1 âˆˆ s) (hp2 : p2 âˆˆ s) : p1 -áµ¥ p2 âˆˆ vector_span k s
theorem measure_theory.integrable.ae_eq_of_with_densityáµ¥_eq {Î± : Type u_1} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {E : Type u_3} [normed_group E] [normed_space â„ E] [complete_space E] {f g : Î± â†’ E} (hf : measure_theory.integrable f Î¼) (hg : measure_theory.integrable g Î¼) (hfg : Î¼.with_densityáµ¥ f = Î¼.with_densityáµ¥ g) : f =áµ[Î¼] g
theorem pgame.fuzzy.lf {x y : pgame} (h : x.fuzzy y) : x.lf y
theorem algebra.norm_eq_prod_embeddings (K : Type u_4) {L : Type u_5} [field K] [field L] [algebra K L] (E : Type u_7) [field E] [algebra K E] [finite_dimensional K L] [is_separable K L] [is_alg_closed E] {x : L} : â‡‘(algebra_map K E) (â‡‘(algebra.norm K) x) = finset.univ.prod (Î» (Ïƒ : L â†’â‚[K] E), â‡‘Ïƒ x)
theorem euclidean_geometry.orthogonal_projection_mem {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace â„ P} [nonempty â†¥s] [complete_space â†¥(s.direction)] (p : P) : â†‘(â‡‘(euclidean_geometry.orthogonal_projection s) p) âˆˆ s
theorem is_free_group.unique_lift {G : Type u_1} [group G] [is_free_group G] {H : Type u_2} [group H] (f : is_free_group.generators G â†’ H) : âˆƒ! (F : G â†’* H), âˆ€ (a : is_free_group.generators G), â‡‘F (is_free_group.of a) = f a
theorem probability_theory.meas_ge_le_variance_div_sq {Î© : Type u_1} [measure_theory.measure_space Î©] [measure_theory.is_probability_measure measure_theory.measure_space.volume] {X : Î© â†’ â„} (hX : measure_theory.mem_â„’p X 2 measure_theory.measure_space.volume) {c : â„} (hc : 0 < c) : â‡‘measure_theory.measure_space.volume {Ï‰ : Î© | c â‰¤ |X Ï‰ - âˆ« (a : Î©), X a|} â‰¤ ennreal.of_real (probability_theory.variance X measure_theory.measure_space.volume / c ^ 2)
theorem finset.sup_indep.bUnion {Î± : Type u_1} {Î¹ : Type u_3} {Î¹' : Type u_4} [distrib_lattice Î±] [order_bot Î±] [decidable_eq Î¹] {s : finset Î¹'} {g : Î¹' â†’ finset Î¹} {f : Î¹ â†’ Î±} (hs : s.sup_indep (Î» (i : Î¹'), (g i).sup f)) (hg : âˆ€ (i' : Î¹'), i' âˆˆ s â†’ (g i').sup_indep f) : (s.bUnion g).sup_indep f
theorem measure_theory.measurable_image_of_fderiv_within {E : Type u_1} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] {s : set E} {f : E â†’ E} {f' : E â†’ (E â†’L[â„] E)} [measurable_space E] [borel_space E] (hs : measurable_set s) (hf' : âˆ€ (x : E), x âˆˆ s â†’ has_fderiv_within_at f (f' x) s x) (hf : set.inj_on f s) : measurable_set (f '' s)
theorem tsub_lt_tsub_iff_left_of_le_of_le {Î± : Type u_1} [canonically_ordered_add_monoid Î±] [has_sub Î±] [has_ordered_sub Î±] {a b c : Î±} [contravariant_class Î± Î± has_add.add has_le.le] [contravariant_class Î± Î± has_add.add has_lt.lt] (hâ‚ : b â‰¤ a) (hâ‚‚ : c â‰¤ a) : a - b < a - c â†” c < b
theorem inner_product_space.is_self_adjoint.coe_re_apply_inner_self_apply {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {T : E â†’L[ğ•œ] E} (hT : inner_product_space.is_self_adjoint â†‘T) (x : E) : â†‘(T.re_apply_inner_self x) = has_inner.inner (â‡‘T x) x
theorem probability_theory.indep_fun.integral_mul_of_integrable {Î± : Type u_1} {mÎ± : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {X Y : Î± â†’ â„} (hXY : probability_theory.indep_fun X Y Î¼) (hX : measure_theory.integrable X Î¼) (hY : measure_theory.integrable Y Î¼) : measure_theory.integral Î¼ (X * Y) = measure_theory.integral Î¼ X * measure_theory.integral Î¼ Y
theorem ae_strongly_measurable_iff_ae_measurable_separable {Î± : Type u_1} {Î² : Type u_2} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [topological_space Î²] {f : Î± â†’ Î²} [topological_space.pseudo_metrizable_space Î²] [measurable_space Î²] [borel_space Î²] : measure_theory.ae_strongly_measurable f Î¼ â†” ae_measurable f Î¼ âˆ§ âˆƒ (t : set Î²), topological_space.is_separable t âˆ§ âˆ€áµ (x : Î±) âˆ‚Î¼, f x âˆˆ t
theorem quotient_group.monoid_hom_ext {G : Type u} [group G] (N : subgroup G) [nN : N.normal] {H : Type v} [group H] â¦ƒf g : G â§¸ N â†’* Hâ¦„ (h : f.comp (quotient_group.mk' N) = g.comp (quotient_group.mk' N)) : f = g
theorem local_equiv.eq_on_source.target_eq {Î± : Type u_1} {Î² : Type u_2} {e e' : local_equiv Î± Î²} (h : e â‰ˆ e') : e.target = e'.target
theorem submonoid.localization_map.lift_spec {M : Type u_1} [comm_monoid M] {S : submonoid M} {N : Type u_2} [comm_monoid N] {P : Type u_3} [comm_monoid P] (f : S.localization_map N) {g : M â†’* P} (hg : âˆ€ (y : â†¥S), is_unit (â‡‘g â†‘y)) (z : N) (v : P) : â‡‘(f.lift hg) z = v â†” â‡‘g (f.sec z).fst = â‡‘g â†‘((f.sec z).snd) * v
theorem bounded_std_simplex (Î¹ : Type u_1) [fintype Î¹] : metric.bounded (std_simplex â„ Î¹)
theorem finprod_mem_union_inter {Î± : Type u_1} {M : Type u_5} [comm_monoid M] {f : Î± â†’ M} {s t : set Î±} (hs : s.finite) (ht : t.finite) : finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s âˆª t), f i)) * finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s âˆ© t), f i)) = finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), f i)) * finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ t), f i))
theorem intermediate_field.adjoin_le_subfield (F : Type u_1) [field F] {E : Type u_2} [field E] [algebra F E] (S : set E) {K : subfield E} (HF : set.range â‡‘(algebra_map F E) âŠ† â†‘K) (HS : S âŠ† â†‘K) : (intermediate_field.adjoin F S).to_subfield â‰¤ K
theorem linear_recurrence.is_sol_iff_mem_sol_space {Î± : Type u_1} [comm_semiring Î±] (E : linear_recurrence Î±) (u : â„• â†’ Î±) : E.is_solution u â†” u âˆˆ E.sol_space
theorem mv_polynomial.is_domain_fin (R : Type u) [comm_ring R] [is_domain R] (n : â„•) : is_domain (mv_polynomial (fin n) R)
theorem comp_symm_mem_uniformity_sets {Î± : Type u_1} [uniform_space Î±] {s : set (Î± Ã— Î±)} (hs : s âˆˆ uniformity Î±) : âˆƒ (t : set (Î± Ã— Î±)) (H : t âˆˆ uniformity Î±), symmetric_rel t âˆ§ comp_rel t t âŠ† s
theorem measure_theory.measure.measure_to_measurable_inter {Î± : Type u_1} {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {s t : set Î±} (hs : measurable_set s) (ht : â‡‘Î¼ t â‰  âŠ¤) : â‡‘Î¼ (measure_theory.to_measurable Î¼ t âˆ© s) = â‡‘Î¼ (t âˆ© s)
theorem cont_mdiff_on.comp {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners ğ•œ E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] {f : M â†’ M'} {s : set M} {n : with_top â„•} {E'' : Type u_14} [normed_group E''] [normed_space ğ•œ E''] {H'' : Type u_15} [topological_space H''] {I'' : model_with_corners ğ•œ E'' H''} {M'' : Type u_16} [topological_space M''] [charted_space H'' M''] {t : set M'} {g : M' â†’ M''} (hg : cont_mdiff_on I' I'' n g t) (hf : cont_mdiff_on I I' n f s) (st : s âŠ† f â»Â¹' t) : cont_mdiff_on I I'' n (g âˆ˜ f) s
theorem finset.affine_combination_apply {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {Î¹ : Type u_4} (s : finset Î¹) (w : Î¹ â†’ k) (p : Î¹ â†’ P) : â‡‘(s.affine_combination p) w = â‡‘(s.weighted_vsub_of_point p (classical.choice add_torsor.nonempty)) w +áµ¥ classical.choice add_torsor.nonempty
theorem fin.cast_to_equiv {n m : â„•} (h : n = m) : (fin.cast h).to_equiv = equiv.cast _
theorem metric.ediam_le_of_forall_dist_le {Î± : Type u} [pseudo_metric_space Î±] {s : set Î±} {C : â„} (h : âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (y : Î±), y âˆˆ s â†’ has_dist.dist x y â‰¤ C) : emetric.diam s â‰¤ ennreal.of_real C
theorem Sup_within_of_ord_connected {Î± : Type u_1} [conditionally_complete_linear_order Î±] {s : set Î±} [hs : s.ord_connected] â¦ƒt : set â†¥sâ¦„ (ht : t.nonempty) (h_bdd : bdd_above t) : has_Sup.Sup (coe '' t) âˆˆ s
theorem category_theory.is_connected_zigzag {J : Type uâ‚} [category_theory.category J] [category_theory.is_connected J] (jâ‚ jâ‚‚ : J) : category_theory.zigzag jâ‚ jâ‚‚
theorem inner_product_geometry.cos_angle {V : Type u_1} [inner_product_space â„ V] (x y : V) : real.cos (inner_product_geometry.angle x y) = has_inner.inner x y / (âˆ¥xâˆ¥ * âˆ¥yâˆ¥)
theorem homeomorph.is_o_congr {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] {E : Type u_3} [has_norm E] {F : Type u_4} [has_norm F] (e : Î± â‰ƒâ‚œ Î²) {b : Î²} {f : Î² â†’ E} {g : Î² â†’ F} : f =o[nhds b] g â†” (f âˆ˜ â‡‘e) =o[nhds (â‡‘(e.symm) b)] (g âˆ˜ â‡‘e)
theorem totally_bounded.bounded {Î± : Type u} [pseudo_metric_space Î±] {s : set Î±} (h : totally_bounded s) : metric.bounded s
theorem measure_theory.conservative.id {Î± : Type u_2} [measurable_space Î±] (Î¼ : measure_theory.measure Î±) : measure_theory.conservative id Î¼
theorem measure_theory.measure.eq_of_ae_eq {X : Type u_1} {Y : Type u_2} [topological_space X] {m : measurable_space X} [topological_space Y] [t2_space Y] {Î¼ : measure_theory.measure X} [Î¼.is_open_pos_measure] {f g : X â†’ Y} (h : f =áµ[Î¼] g) (hf : continuous f) (hg : continuous g) : f = g
theorem measurable.find {Î± : Type u_1} {Î² : Type u_2} {mÎ² : measurable_space Î²} {m : measurable_space Î±} {f : â„• â†’ Î± â†’ Î²} {p : â„• â†’ Î± â†’ Prop} [Î  (n : â„•), decidable_pred (p n)] (hf : âˆ€ (n : â„•), measurable (f n)) (hp : âˆ€ (n : â„•), measurable_set {x : Î± | p n x}) (h : âˆ€ (x : Î±), âˆƒ (n : â„•), p n x) : measurable (Î» (x : Î±), f (nat.find _) x)
theorem is_min_on.of_is_local_min_of_convex_univ {E : Type u_1} {Î² : Type u_2} [add_comm_group E] [topological_space E] [module â„ E] [topological_add_group E] [has_continuous_smul â„ E] [ordered_add_comm_group Î²] [module â„ Î²] [ordered_smul â„ Î²] {f : E â†’ Î²} {a : E} (h_local_min : is_local_min f a) (h_conv : convex_on â„ set.univ f) (x : E) : f a â‰¤ f x
theorem category_theory.nat_iso.is_iso_of_is_iso_app {C : Type uâ‚} [category_theory.category C] {D : Type uâ‚‚} [category_theory.category D] {F G : C â¥¤ D} (Î± : F âŸ¶ G) [âˆ€ (X : C), category_theory.is_iso (Î±.app X)] : category_theory.is_iso Î±
theorem right.one_le_inv_iff {Î± : Type u} [group Î±] [has_le Î±] [covariant_class Î± Î± (function.swap has_mul.mul) has_le.le] {a : Î±} : 1 â‰¤ aâ»Â¹ â†” a â‰¤ 1
theorem orthonormal.two_zsmul_oangle_neg_self_right {V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) (x : V) : 2 â€¢ hb.oangle x (-x) = 0
theorem subsingleton_floor_ring {Î± : Type u_1} [linear_ordered_ring Î±] : subsingleton (floor_ring Î±)
theorem sum_div_pow_sq_le_div_sq (N : â„•) {j : â„} (hj : 0 < j) {c : â„} (hc : 1 < c) : (finset.filter (Î» (i : â„•), j < c ^ i) (finset.range N)).sum (Î» (i : â„•), 1 / (c ^ i) ^ 2) â‰¤ c ^ 3 * (c - 1)â»Â¹ / j ^ 2
theorem orthonormal.inner_finsupp_eq_sum_right {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {Î¹ : Type u_4} {v : Î¹ â†’ E} (hv : orthonormal ğ•œ v) (lâ‚ lâ‚‚ : Î¹ â†’â‚€ ğ•œ) : has_inner.inner (â‡‘(finsupp.total Î¹ E ğ•œ v) lâ‚) (â‡‘(finsupp.total Î¹ E ğ•œ v) lâ‚‚) = lâ‚‚.sum (Î» (i : Î¹) (y : ğ•œ), â‡‘(star_ring_end ğ•œ) (â‡‘lâ‚ i) * y)
theorem category_theory.normal_epi_category.pushout_of_epi {C : Type u_1} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_finite_coproducts C] [category_theory.limits.has_cokernels C] [category_theory.normal_epi_category C] {X Y Z : C} (a : X âŸ¶ Y) (b : X âŸ¶ Z) [category_theory.epi a] [category_theory.epi b] : category_theory.limits.has_colimit (category_theory.limits.span a b)
theorem nat.eq_of_test_bit_eq {n m : â„•} (h : âˆ€ (i : â„•), n.test_bit i = m.test_bit i) : n = m
theorem tendsto_nhds_of_cauchy_seq_of_subseq {Î± : Type u} {Î² : Type v} [uniform_space Î±] [semilattice_sup Î²] {u : Î² â†’ Î±} (hu : cauchy_seq u) {Î¹ : Type u_1} {f : Î¹ â†’ Î²} {p : filter Î¹} [p.ne_bot] (hf : filter.tendsto f p filter.at_top) {a : Î±} (ha : filter.tendsto (u âˆ˜ f) p (nhds a)) : filter.tendsto u filter.at_top (nhds a)
theorem matrix.mul_nonsing_inv {n : Type u'} {Î± : Type v} [fintype n] [decidable_eq n] [comm_ring Î±] (A : matrix n n Î±) (h : is_unit A.det) : A.mul Aâ»Â¹ = 1
theorem category_theory.limits.has_strict_initial_objects_of_initial_is_strict {C : Type u} [category_theory.category C] [category_theory.limits.has_initial C] (h : âˆ€ (A : C) (f : A âŸ¶ âŠ¥_ C), category_theory.is_iso f) : category_theory.limits.has_strict_initial_objects C
theorem affine_subspace.mem_direction_iff_eq_vsub_right {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : affine_subspace k P} {p : P} (hp : p âˆˆ s) (v : V) : v âˆˆ s.direction â†” âˆƒ (p2 : P) (H : p2 âˆˆ s), v = p2 -áµ¥ p
theorem has_sum_iff_tendsto_nat_of_nonneg {f : â„• â†’ â„} (hf : âˆ€ (i : â„•), 0 â‰¤ f i) (r : â„) : has_sum f r â†” filter.tendsto (Î» (n : â„•), (finset.range n).sum (Î» (i : â„•), f i)) filter.at_top (nhds r)
theorem filter.tendsto.at_bot_mul_neg {Î± : Type u} {Î² : Type v} [linear_ordered_field Î±] [topological_space Î±] [order_topology Î±] {l : filter Î²} {f g : Î² â†’ Î±} {C : Î±} (hC : C < 0) (hf : filter.tendsto f l filter.at_bot) (hg : filter.tendsto g l (nhds C)) : filter.tendsto (Î» (x : Î²), f x * g x) l filter.at_top
theorem complete_lattice.independent.disjoint_bsupr {Î¹ : Type u_1} {Î± : Type u_2} [complete_lattice Î±] {t : Î¹ â†’ Î±} (ht : complete_lattice.independent t) {x : Î¹} {y : set Î¹} (hx : x âˆ‰ y) : disjoint (t x) (â¨† (i : Î¹) (H : i âˆˆ y), t i)
theorem algebra.finite_presentation.quotient {R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] {I : ideal A} (h : I.fg) (hfp : algebra.finite_presentation R A) : algebra.finite_presentation R (A â§¸ I)
theorem submodule.finset_span_is_compact_element {R : Type u_1} {M : Type u_4} [semiring R] [add_comm_monoid M] [module R M] (S : finset M) : complete_lattice.is_compact_element (submodule.span R â†‘S)
theorem zero_lt.left.mul_lt_one_of_lt_of_lt {Î± : Type u} {a b : Î±} [mul_one_class Î±] [has_zero Î±] [preorder Î±] [zero_lt.pos_mul_strict_mono Î±] (ha : a < 1) (hb : b < 1) (a0 : 0 < a) : a * b < 1
theorem finset.order_emb_of_fin_singleton {Î± : Type u_1} [linear_order Î±] (a : Î±) (i : fin 1) : â‡‘({a}.order_emb_of_fin _) i = a
theorem is_glb.bdd_below {Î± : Type u} [preorder Î±] {s : set Î±} {a : Î±} (h : is_glb s a) : bdd_below s
theorem filter.is_bounded_iff {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} {f : filter Î±} : filter.is_bounded r f â†” âˆƒ (s : set Î±) (H : s âˆˆ f.sets) (b : Î±), s âŠ† {x : Î± | r x b}
theorem measure_theory.measure.ae_ae_of_ae_prod {Î± : Type u_1} {Î² : Type u_3} [measurable_space Î±] [measurable_space Î²] {Î¼ : measure_theory.measure Î±} {Î½ : measure_theory.measure Î²} [measure_theory.sigma_finite Î½] {p : Î± Ã— Î² â†’ Prop} (h : âˆ€áµ (z : Î± Ã— Î²) âˆ‚Î¼.prod Î½, p z) : âˆ€áµ (x : Î±) âˆ‚Î¼, âˆ€áµ (y : Î²) âˆ‚Î½, p (x, y)
theorem complex.eq_on_of_eq_on_frontier {E : Type u} [normed_group E] [normed_space â„‚ E] {F : Type v} [normed_group F] [normed_space â„‚ F] [nontrivial E] {f g : E â†’ F} {U : set E} (hU : metric.bounded U) (hf : diff_cont_on_cl â„‚ f U) (hg : diff_cont_on_cl â„‚ g U) (hfg : set.eq_on f g (frontier U)) : set.eq_on f g U
theorem has_compact_support.norm {Î± : Type u_1} {E : Type u_3} [normed_group E] [topological_space Î±] {f : Î± â†’ E} : has_compact_support f â†’ has_compact_support (Î» (x : Î±), âˆ¥f xâˆ¥)
theorem padic_norm.one (p : â„•) : padic_norm p 1 = 1
theorem sub_eq_add_neg {G : Type u_1} [sub_neg_monoid G] (a b : G) : a - b = a + -b
theorem clifford_algebra.submodule_map_pow_reverse {R : Type u_1} [comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] (Q : quadratic_form R M) (p : submodule R (clifford_algebra Q)) (n : â„•) : submodule.map clifford_algebra.reverse (p ^ n) = submodule.map clifford_algebra.reverse p ^ n
theorem psigma.subtype_ext {Î± : Sort u_1} {Î² : Sort u_2} {p : Î± â†’ Î² â†’ Prop} {xâ‚€ xâ‚ : Î£' (a : Î±), subtype (p a)} : xâ‚€.fst = xâ‚.fst â†’ â†‘(xâ‚€.snd) = â†‘(xâ‚.snd) â†’ xâ‚€ = xâ‚
theorem category_theory.over.construct_products.over_binary_product_of_pullback {C : Type u} [category_theory.category C] [category_theory.limits.has_pullbacks C] {B : C} : category_theory.limits.has_binary_products (category_theory.over B)
theorem uniform_embedding_iff' {Î² : Type v} {Î³ : Type w} [emetric_space Î³] [emetric_space Î²] {f : Î³ â†’ Î²} : uniform_embedding f â†” (âˆ€ (Îµ : ennreal), Îµ > 0 â†’ (âˆƒ (Î´ : ennreal) (H : Î´ > 0), âˆ€ {a b : Î³}, has_edist.edist a b < Î´ â†’ has_edist.edist (f a) (f b) < Îµ)) âˆ§ âˆ€ (Î´ : ennreal), Î´ > 0 â†’ (âˆƒ (Îµ : ennreal) (H : Îµ > 0), âˆ€ {a b : Î³}, has_edist.edist (f a) (f b) < Îµ â†’ has_edist.edist a b < Î´)
theorem besicovitch.card_le_of_separated {E : Type u_1} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] (s : finset E) (hs : âˆ€ (c : E), c âˆˆ s â†’ âˆ¥câˆ¥ â‰¤ 2) (h : âˆ€ (c : E), c âˆˆ s â†’ âˆ€ (d : E), d âˆˆ s â†’ c â‰  d â†’ 1 â‰¤ âˆ¥c - dâˆ¥) : s.card â‰¤ 5 ^ finite_dimensional.finrank â„ E
theorem fermat_42.neg_of_minimal {a b c : â„¤} : fermat_42.minimal a b c â†’ fermat_42.minimal a b (-c)
theorem fractional_ideal.is_fractional_adjoin_integral {R : Type u_1} [comm_ring R] (S : submonoid R) {P : Type u_2} [comm_ring P] [algebra R P] [loc : is_localization S P] (x : P) (hx : is_integral R x) : is_fractional S (algebra.adjoin R {x}).to_submodule
theorem affine_map.comp_apply {k : Type u_1} {V1 : Type u_2} {P1 : Type u_3} {V2 : Type u_4} {P2 : Type u_5} {V3 : Type u_6} {P3 : Type u_7} [ring k] [add_comm_group V1] [module k V1] [add_torsor V1 P1] [add_comm_group V2] [module k V2] [add_torsor V2 P2] [add_comm_group V3] [module k V3] [add_torsor V3 P3] (f : P2 â†’áµƒ[k] P3) (g : P1 â†’áµƒ[k] P2) (p : P1) : â‡‘(f.comp g) p = â‡‘f (â‡‘g p)
theorem colex.mem_le_of_singleton_le {Î± : Type u_1} [linear_order Î±] {r : Î±} {s : finset Î±} : {r}.to_colex â‰¤ s.to_colex â†” âˆƒ (x : Î±) (H : x âˆˆ s), r â‰¤ x
theorem formal_multilinear_series.is_o_one_of_lt_radius {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field ğ•œ] [normed_group E] [normed_space ğ•œ E] [normed_group F] [normed_space ğ•œ F] (p : formal_multilinear_series ğ•œ E F) {r : nnreal} (h : â†‘r < p.radius) : (Î» (n : â„•), âˆ¥p nâˆ¥ * â†‘r ^ n) =o[filter.at_top] Î» (_x : â„•), 1
theorem probability_theory.tendsto_integral_truncation {Î± : Type u_1} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {f : Î± â†’ â„} (hf : measure_theory.integrable f Î¼) : filter.tendsto (Î» (A : â„), âˆ« (x : Î±), probability_theory.truncation f A x âˆ‚Î¼) filter.at_top (nhds (âˆ« (x : Î±), f x âˆ‚Î¼))
theorem measure_theory.unif_integrable_of_tendsto_Lp {Î± : Type u_1} {Î² : Type u_2} {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) [normed_group Î²] {p : ennreal} {f : â„• â†’ Î± â†’ Î²} {g : Î± â†’ Î²} (hp : 1 â‰¤ p) (hp' : p â‰  âŠ¤) (hf : âˆ€ (n : â„•), measure_theory.mem_â„’p (f n) p Î¼) (hg : measure_theory.mem_â„’p g p Î¼) (hfg : filter.tendsto (Î» (n : â„•), measure_theory.snorm (f n - g) p Î¼) filter.at_top (nhds 0)) : measure_theory.unif_integrable f p Î¼
theorem exists_subset_affine_independent_affine_span_eq_top {k : Type u_1} {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : set P} (h : affine_independent k (Î» (p : â†¥s), â†‘p)) : âˆƒ (t : set P), s âŠ† t âˆ§ affine_independent k (Î» (p : â†¥t), â†‘p) âˆ§ affine_span k t = âŠ¤
theorem complete_lattice.set_independent.disjoint_Sup {Î± : Type u_1} [complete_lattice Î±] {s : set Î±} (hs : complete_lattice.set_independent s) {x : Î±} {y : set Î±} (hx : x âˆˆ s) (hy : y âŠ† s) (hxy : x âˆ‰ y) : disjoint x (has_Sup.Sup y)
theorem group_topology.continuous_inv' {Î± : Type u} [group Î±] (g : group_topology Î±) : continuous has_inv.inv
theorem concave_on.comp_linear_map {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} {Î² : Type u_4} [ordered_semiring ğ•œ] [add_comm_monoid E] [add_comm_monoid F] [ordered_add_comm_monoid Î²] [module ğ•œ E] [module ğ•œ F] [has_scalar ğ•œ Î²] {f : F â†’ Î²} {s : set F} (hf : concave_on ğ•œ s f) (g : E â†’â‚—[ğ•œ] F) : concave_on ğ•œ (â‡‘g â»Â¹' s) (f âˆ˜ â‡‘g)
theorem add_pos_of_pos_of_nonneg {Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : 0 < a) (hb : 0 â‰¤ b) : 0 < a + b
theorem measure_theory.measure.add_haar_eq_zero_of_disjoint_translates_aux {E : Type u_1} [normed_group E] [normed_space â„ E] [measurable_space E] [borel_space E] [finite_dimensional â„ E] (Î¼ : measure_theory.measure E) [Î¼.is_add_haar_measure] {s : set E} (u : â„• â†’ E) (sb : metric.bounded s) (hu : metric.bounded (set.range u)) (hs : pairwise (disjoint on Î» (n : â„•), {u n} + s)) (h's : measurable_set s) : â‡‘Î¼ s = 0
theorem continuous_on.ae_measurable {Î± : Type u_1} {Î² : Type u_2} [measurable_space Î±] [topological_space Î±] [opens_measurable_space Î±] [measurable_space Î²] [topological_space Î²] [borel_space Î²] {f : Î± â†’ Î²} {s : set Î±} {Î¼ : measure_theory.measure Î±} (hf : continuous_on f s) (hs : measurable_set s) : ae_measurable f (Î¼.restrict s)
theorem polynomial.cyclotomic_mul_prime_dvd_eq_pow (R : Type u_1) {p n : â„•} [hp : fact (nat.prime p)] [ring R] [char_p R p] (hn : p âˆ£ n) : polynomial.cyclotomic (n * p) R = polynomial.cyclotomic n R ^ p
theorem ideal.polynomial.is_integral_is_localization_polynomial_quotient {R : Type u_1} [comm_ring R] {Râ‚˜ : Type u_3} {Sâ‚˜ : Type u_4} [comm_ring Râ‚˜] [comm_ring Sâ‚˜] (P : ideal (polynomial R)) (pX : polynomial R) (hpX : pX âˆˆ P) [algebra (R â§¸ ideal.comap polynomial.C P) Râ‚˜] [is_localization.away (polynomial.map (ideal.quotient.mk (ideal.comap polynomial.C P)) pX).leading_coeff Râ‚˜] [algebra (polynomial R â§¸ P) Sâ‚˜] [is_localization (submonoid.map â†‘(P.quotient_map polynomial.C le_rfl) (submonoid.powers (polynomial.map (ideal.quotient.mk (ideal.comap polynomial.C P)) pX).leading_coeff)) Sâ‚˜] : (is_localization.map Sâ‚˜ (P.quotient_map polynomial.C le_rfl) _).is_integral
theorem category_theory.eq_whisker {C : Type u} [category_theory.category C] {X Y Z : C} {f g : X âŸ¶ Y} (w : f = g) (h : Y âŸ¶ Z) : f â‰« h = g â‰« h
theorem has_deriv_within_at.Ici_of_Ioi {ğ•œ : Type u} [nondiscrete_normed_field ğ•œ] {F : Type v} [normed_group F] [normed_space ğ•œ F] {f : ğ•œ â†’ F} {f' : F} {x : ğ•œ} [partial_order ğ•œ] : has_deriv_within_at f f' (set.Ioi x) x â†’ has_deriv_within_at f f' (set.Ici x) x
theorem lp.tendsto_lp_of_tendsto_pi {Î± : Type u_1} {E : Î± â†’ Type u_2} {p : ennreal} [Î  (i : Î±), normed_group (E i)] [fact (1 â‰¤ p)] {F : â„• â†’ â†¥(lp E p)} (hF : cauchy_seq F) {f : â†¥(lp E p)} (hf : filter.tendsto (id (Î» (i : â„•), â‡‘(F i))) filter.at_top (nhds â‡‘f)) : filter.tendsto F filter.at_top (nhds f)
theorem norm_le_insert {E : Type u_3} [semi_normed_group E] (u v : E) : âˆ¥vâˆ¥ â‰¤ âˆ¥uâˆ¥ + âˆ¥u - vâˆ¥
theorem measure_theory.integral_integral_add' {Î± : Type u_1} {Î² : Type u_3} {E : Type u_6} [measurable_space Î±] [measurable_space Î²] {Î¼ : measure_theory.measure Î±} {Î½ : measure_theory.measure Î²} [normed_group E] [measure_theory.sigma_finite Î½] [normed_space â„ E] [complete_space E] [measure_theory.sigma_finite Î¼] â¦ƒf g : Î± Ã— Î² â†’ Eâ¦„ (hf : measure_theory.integrable f (Î¼.prod Î½)) (hg : measure_theory.integrable g (Î¼.prod Î½)) : âˆ« (x : Î±), âˆ« (y : Î²), (f + g) (x, y) âˆ‚Î½ âˆ‚Î¼ = âˆ« (x : Î±), âˆ« (y : Î²), f (x, y) âˆ‚Î½ âˆ‚Î¼ + âˆ« (x : Î±), âˆ« (y : Î²), g (x, y) âˆ‚Î½ âˆ‚Î¼
theorem antivary_on.sum_smul_le_sum_comp_perm_smul {Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [linear_ordered_ring Î±] [linear_ordered_add_comm_group Î²] [module Î± Î²] [ordered_smul Î± Î²] {s : finset Î¹} {Ïƒ : equiv.perm Î¹} {f : Î¹ â†’ Î±} {g : Î¹ â†’ Î²} (hfg : antivary_on f g â†‘s) (hÏƒ : {x : Î¹ | â‡‘Ïƒ x â‰  x} âŠ† â†‘s) : s.sum (Î» (i : Î¹), f i â€¢ g i) â‰¤ s.sum (Î» (i : Î¹), f (â‡‘Ïƒ i) â€¢ g i)
theorem concave_on_of_deriv2_nonpos {D : set â„} (hD : convex â„ D) {f : â„ â†’ â„} (hf : continuous_on f D) (hf' : differentiable_on â„ f (interior D)) (hf'' : differentiable_on â„ (deriv f) (interior D)) (hf''_nonpos : âˆ€ (x : â„), x âˆˆ interior D â†’ deriv^[2] f x â‰¤ 0) : concave_on â„ D f
theorem con.lift_mk' {M : Type u_1} {P : Type u_3} [mul_one_class M] [mul_one_class P] {c : con M} {f : M â†’* P} (H : c â‰¤ con.ker f) (x : M) : â‡‘(c.lift f H) (â‡‘(c.mk') x) = â‡‘f x
theorem approximates_linear_on.to_inv {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {f : E â†’ F} {f' : E â‰ƒL[ğ•œ] F} {s : set E} {c : nnreal} (hf : approximates_linear_on f â†‘f' s c) (hc : subsingleton E âˆ¨ c < âˆ¥â†‘(f'.symm)âˆ¥â‚Šâ»Â¹) : approximates_linear_on â‡‘((hf.to_local_equiv hc).symm) â†‘(f'.symm) (f '' s) (âˆ¥â†‘(f'.symm)âˆ¥â‚Š * (âˆ¥â†‘(f'.symm)âˆ¥â‚Šâ»Â¹ - c)â»Â¹ * c)
theorem set.image2_eq_Union {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} (f : Î± â†’ Î² â†’ Î³) (s : set Î±) (t : set Î²) : set.image2 f s t = â‹ƒ (i : Î±) (H : i âˆˆ s) (j : Î²) (H : j âˆˆ t), {f i j}
theorem set.finite_of_forall_between_eq_endpoints {Î± : Type u_1} [linear_order Î±] (s : set Î±) (h : âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (y : Î±), y âˆˆ s â†’ âˆ€ (z : Î±), z âˆˆ s â†’ x â‰¤ y â†’ y â‰¤ z â†’ x = y âˆ¨ y = z) : s.finite
theorem padic_seq.lift_index_left {p : â„•} [fact (nat.prime p)] {f : padic_seq p} (hf : Â¬f â‰ˆ 0) (v1 v3 : â„•) : padic_norm p (â‡‘f (padic_seq.stationary_point hf)) = padic_norm p (â‡‘f (linear_order.max v1 (linear_order.max (padic_seq.stationary_point hf) v3)))
theorem deriv_forall_lt_or_forall_gt_of_forall_ne {f f' : â„ â†’ â„} {s : set â„} (hs : convex â„ s) (hf : âˆ€ (x : â„), x âˆˆ s â†’ has_deriv_at f (f' x) x) {m : â„} (hf' : âˆ€ (x : â„), x âˆˆ s â†’ f' x â‰  m) : (âˆ€ (x : â„), x âˆˆ s â†’ f' x < m) âˆ¨ âˆ€ (x : â„), x âˆˆ s â†’ m < f' x
theorem is_primitive_root.squarefree_minpoly_mod {n : â„•} {K : Type u_8} [field K] {Î¼ : K} (h : is_primitive_root Î¼ n) [char_zero K] {p : â„•} [fact (nat.prime p)] (hdiv : Â¬p âˆ£ n) : squarefree (polynomial.map (int.cast_ring_hom (zmod p)) (minpoly â„¤ Î¼))
theorem is_torsion_free.subgroup {G : Type u_1} [group G] (tG : monoid.is_torsion_free G) (H : subgroup G) : monoid.is_torsion_free â†¥H
theorem finset.univ_perm_fin_succ {n : â„•} : finset.univ = finset.map equiv.perm.decompose_fin.symm.to_embedding finset.univ
theorem add_semiconj_by.transitive {S : Type u} [add_semigroup S] : transitive (Î» (a b : S), âˆƒ (c : S), add_semiconj_by c a b)
theorem convex_on.exists_ge_of_center_mass {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} {Î¹ : Type u_5} [linear_ordered_field ğ•œ] [add_comm_group E] [linear_ordered_add_comm_group Î²] [module ğ•œ E] [module ğ•œ Î²] [ordered_smul ğ•œ Î²] {s : set E} {f : E â†’ Î²} {t : finset Î¹} {w : Î¹ â†’ ğ•œ} {p : Î¹ â†’ E} (h : convex_on ğ•œ s f) (hwâ‚€ : âˆ€ (i : Î¹), i âˆˆ t â†’ 0 â‰¤ w i) (hwâ‚ : 0 < t.sum (Î» (i : Î¹), w i)) (hp : âˆ€ (i : Î¹), i âˆˆ t â†’ p i âˆˆ s) : âˆƒ (i : Î¹) (H : i âˆˆ t), f (t.center_mass w p) â‰¤ f (p i)
theorem nat.eq_prime_pow_of_dvd_least_prime_pow {a p k : â„•} (pp : nat.prime p) (hâ‚ : Â¬a âˆ£ p ^ k) (hâ‚‚ : a âˆ£ p ^ (k + 1)) : a = p ^ (k + 1)
theorem subgroup.nilpotency_class_le {G : Type u_1} [group G] (H : subgroup G) [hG : group.is_nilpotent G] : group.nilpotency_class â†¥H â‰¤ group.nilpotency_class G
theorem category_theory.transfer_nat_trans_self_of_iso {C : Type uâ‚} {D : Type uâ‚‚} [category_theory.category C] [category_theory.category D] {Lâ‚ Lâ‚‚ : C â¥¤ D} {Râ‚ Râ‚‚ : D â¥¤ C} (adjâ‚ : Lâ‚ âŠ£ Râ‚) (adjâ‚‚ : Lâ‚‚ âŠ£ Râ‚‚) (f : Lâ‚‚ âŸ¶ Lâ‚) [category_theory.is_iso (â‡‘(category_theory.transfer_nat_trans_self adjâ‚ adjâ‚‚) f)] : category_theory.is_iso f
theorem category_theory.subobject.mk_eq_of_comm {C : Type uâ‚} [category_theory.category C] {B A : C} {X : category_theory.subobject B} (f : A âŸ¶ B) [category_theory.mono f] (i : A â‰… â†‘X) (w : i.hom â‰« X.arrow = f) : category_theory.subobject.mk f = X
theorem algebraic_geometry.Î“_Spec.right_triangle (R : CommRing) : algebraic_geometry.identity_to_Î“_Spec.app (algebraic_geometry.Spec.to_LocallyRingedSpace.obj (opposite.op R)) â‰« algebraic_geometry.Spec.to_LocallyRingedSpace.map (algebraic_geometry.Spec_Î“_identity.inv.app R).op = ğŸ™ ((ğŸ­ algebraic_geometry.LocallyRingedSpace).obj (algebraic_geometry.Spec.to_LocallyRingedSpace.obj (opposite.op R)))
theorem category_theory.presieve.is_sheaf_for_singleton_iso {C : Type uâ‚} [category_theory.category C] {X : C} (P : Cáµ’áµ– â¥¤ Type w) : category_theory.presieve.is_sheaf_for P (category_theory.presieve.singleton (ğŸ™ X))
theorem convex.affine_image {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [ordered_ring ğ•œ] [add_comm_group E] [add_comm_group F] [module ğ•œ E] [module ğ•œ F] {s : set E} (f : E â†’áµƒ[ğ•œ] F) (hs : convex ğ•œ s) : convex ğ•œ (â‡‘f '' s)
theorem complex.has_deriv_at_cosh (x : â„‚) : has_deriv_at complex.cosh (complex.sinh x) x
theorem metric.to_inductive_limit_commute {X : â„• â†’ Type u} [Î  (n : â„•), metric_space (X n)] {f : Î  (n : â„•), X n â†’ X (n + 1)} (I : âˆ€ (n : â„•), isometry (f n)) (n : â„•) : metric.to_inductive_limit I n.succ âˆ˜ f n = metric.to_inductive_limit I n
theorem one_hom.congr_fun {M : Type u_3} {N : Type u_4} [has_one M] [has_one N] {f g : one_hom M N} (h : f = g) (x : M) : â‡‘f x = â‡‘g x
theorem connected_components_preimage_singleton {Î± : Type u} [topological_space Î±] {x : Î±} : coe â»Â¹' {â†‘x} = connected_component x
theorem ordinal.unbounded_of_unbounded_sUnion {Î± : Type u_1} (r : Î± â†’ Î± â†’ Prop) [wo : is_well_order Î± r] {s : set (set Î±)} (hâ‚ : set.unbounded r (â‹ƒâ‚€s)) (hâ‚‚ : cardinal.mk â†¥s < strict_order.cof r) : âˆƒ (x : set Î±) (H : x âˆˆ s), set.unbounded r x
theorem continuous_linear_map.is_compact_closure_image_coe_of_bounded {ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {F : Type u_6} [normed_group F] [nondiscrete_normed_field ğ•œ] [nondiscrete_normed_field ğ•œâ‚‚] [normed_space ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} {E' : Type u_10} [semi_normed_group E'] [normed_space ğ•œ E'] [ring_hom_isometric Ïƒâ‚â‚‚] [proper_space F] {s : set (E' â†’SL[Ïƒâ‚â‚‚] F)} (hb : metric.bounded s) : is_compact (closure (coe_fn '' s))
theorem category_theory.limits.is_iso_limit_cone_parallel_pair_of_epi {C : Type u} [category_theory.category C] {X Y : C} {f g : X âŸ¶ Y} {c : category_theory.limits.fork f g} (h : category_theory.limits.is_limit c) [category_theory.epi c.Î¹] : category_theory.is_iso c.Î¹
theorem padic_val_rat.div (p : â„•) [p_prime : fact (nat.prime p)] {q r : â„š} (hq : q â‰  0) (hr : r â‰  0) : padic_val_rat p (q / r) = padic_val_rat p q - padic_val_rat p r
theorem interval_integrable_iff {E : Type u_3} [normed_group E] {f : â„ â†’ E} {a b : â„} {Î¼ : measure_theory.measure â„} : interval_integrable f Î¼ a b â†” measure_theory.integrable_on f (set.interval_oc a b) Î¼
theorem linear_map.continuous_iff_is_closed_ker {ğ•œ : Type u} [hnorm : nondiscrete_normed_field ğ•œ] {E : Type v} [add_comm_group E] [module ğ•œ E] [topological_space E] [topological_add_group E] [has_continuous_smul ğ•œ E] (l : E â†’â‚—[ğ•œ] ğ•œ) : continuous â‡‘l â†” is_closed â†‘(l.ker)
theorem matrix.det_fin_three {R : Type v} [comm_ring R] (A : matrix (fin 3) (fin 3) R) : A.det = A 0 0 * A 1 1 * A 2 2 - A 0 0 * A 1 2 * A 2 1 - A 0 1 * A 1 0 * A 2 2 + A 0 1 * A 1 2 * A 2 0 + A 0 2 * A 1 0 * A 2 1 - A 0 2 * A 1 1 * A 2 0
theorem category_theory.reflects_mono {C : Type uâ‚} {D : Type uâ‚‚} [category_theory.category C] [category_theory.category D] (F : C â¥¤ D) {X Y : C} (f : X âŸ¶ Y) [category_theory.limits.reflects_limit (category_theory.limits.cospan f f) F] [category_theory.mono (F.map f)] : category_theory.mono f
theorem zero_ne_one {Mâ‚€ : Type u_1} [mul_zero_one_class Mâ‚€] [nontrivial Mâ‚€] : 0 â‰  1
theorem equiv.mul_swap_mul_self {Î± : Type u} [decidable_eq Î±] (i j : Î±) (Ïƒ : equiv.perm Î±) : Ïƒ * equiv.swap i j * equiv.swap i j = Ïƒ
theorem nat.three_dvd_iff (n : â„•) : 3 âˆ£ n â†” 3 âˆ£ (10.digits n).sum
theorem circle_integral.integral_sub_zpow_of_undef {n : â„¤} {c w : â„‚} {R : â„} (hn : n < 0) (hw : w âˆˆ metric.sphere c |R|) : âˆ® (z : â„‚) in C(c, R), (z - w) ^ n = 0
theorem category_theory.presieve.extend_restrict {C : Type uâ‚} [category_theory.category C] {P : Cáµ’áµ– â¥¤ Type w} {X : C} {R : category_theory.presieve X} {x : category_theory.presieve.family_of_elements P â‡‘(category_theory.sieve.generate R)} (t : x.compatible) : (category_theory.presieve.family_of_elements.restrict _ x).sieve_extend = x
theorem category_theory.strong_mono_of_strong_mono {C : Type u} [category_theory.category C] {P Q R : C} (f : P âŸ¶ Q) (g : Q âŸ¶ R) [category_theory.strong_mono (f â‰« g)] : category_theory.strong_mono f
theorem rat_cast_smul_eq {E : Type u_1} (R : Type u_2) (S : Type u_3) [add_comm_group E] [division_ring R] [division_ring S] [module R E] [module S E] (r : â„š) (x : E) : â†‘r â€¢ x = â†‘r â€¢ x
theorem category_theory.limits.cotrident.coequalizer_ext {J : Type v} {C : Type u} [category_theory.category C] {X Y : C} {f : J â†’ (X âŸ¶ Y)} [nonempty J] (s : category_theory.limits.cotrident f) {W : C} {k l : s.X âŸ¶ W} (h : s.Ï€ â‰« k = s.Ï€ â‰« l) (j : category_theory.limits.walking_parallel_family J) : s.Î¹.app j â‰« k = s.Î¹.app j â‰« l
theorem polynomial.degree_cyclotomic (n : â„•) (R : Type u_1) [ring R] [nontrivial R] : (polynomial.cyclotomic n R).degree = â†‘(n.totient)
theorem interval_integral.interval_integrable_deriv_of_nonneg {a b : â„} {g' g : â„ â†’ â„} (hcont : continuous_on g (set.interval a b)) (hderiv : âˆ€ (x : â„), x âˆˆ set.Ioo (linear_order.min a b) (linear_order.max a b) â†’ has_deriv_at g (g' x) x) (hpos : âˆ€ (x : â„), x âˆˆ set.Ioo (linear_order.min a b) (linear_order.max a b) â†’ 0 â‰¤ g' x) : interval_integrable g' measure_theory.measure_space.volume a b
theorem measurable_set_of_differentiable_at_of_is_complete (ğ•œ : Type u_1) [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] (f : E â†’ F) [measurable_space E] [opens_measurable_space E] {K : set (E â†’L[ğ•œ] F)} (hK : is_complete K) : measurable_set {x : E | differentiable_at ğ•œ f x âˆ§ fderiv ğ•œ f x âˆˆ K}
theorem polynomial.leading_coeff_multiset_prod {R : Type u} [comm_semiring R] [no_zero_divisors R] (t : multiset (polynomial R)) : t.prod.leading_coeff = (multiset.map (Î» (f : polynomial R), f.leading_coeff) t).prod
theorem category_theory.is_pullback.zero_left {C : Type uâ‚} [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_zero_morphisms C] (X : C) : category_theory.is_pullback 0 0 (ğŸ™ X) 0
theorem nat.prime.pow_dvd_factorial_iff {p n r b : â„•} (hp : nat.prime p) (hbn : nat.log p n < b) : p ^ r âˆ£ n.factorial â†” r â‰¤ (finset.Ico 1 b).sum (Î» (i : â„•), n / p ^ i)
theorem list.nat.length_antidiagonal (n : â„•) : (list.nat.antidiagonal n).length = n + 1
theorem monotone.iterate_le_of_le {Î± : Type u_1} [preorder Î±] {f g : Î± â†’ Î±} (hf : monotone f) (h : f â‰¤ g) (n : â„•) : f^[n] â‰¤ (g^[n])
theorem filter.tendsto.at_top_add {Î± : Type u} {Î² : Type v} [topological_space Î±] [linear_ordered_add_comm_group Î±] [order_topology Î±] {l : filter Î²} {f g : Î² â†’ Î±} {C : Î±} (hf : filter.tendsto f l filter.at_top) (hg : filter.tendsto g l (nhds C)) : filter.tendsto (Î» (x : Î²), f x + g x) l filter.at_top
theorem finset.subtype_map {Î± : Type u_1} {s : finset Î±} (p : Î± â†’ Prop) [decidable_pred p] : finset.map (function.embedding.subtype p) (finset.subtype p s) = finset.filter p s
theorem affine_independent.mem_affine_span_iff {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {Î¹ : Type u_4} [nontrivial k] {p : Î¹ â†’ P} (ha : affine_independent k p) (i : Î¹) (s : set Î¹) : p i âˆˆ affine_span k (p '' s) â†” i âˆˆ s
theorem add_con.lift_surjective_of_surjective {M : Type u_1} {P : Type u_3} [add_zero_class M] [add_zero_class P] {c : add_con M} {f : M â†’+ P} (h : c â‰¤ add_con.ker f) (hf : function.surjective â‡‘f) : function.surjective â‡‘(c.lift f h)
theorem is_pi_system_prod {Î± : Type u_1} {Î² : Type u_3} [measurable_space Î±] [measurable_space Î²] : is_pi_system (set.image2 has_set_prod.prod {s : set Î± | measurable_set s} {t : set Î² | measurable_set t})
theorem orientation.fin_orthonormal_basis_orthonormal {E : Type u_1} [inner_product_space â„ E] {n : â„•} (hn : 0 < n) (h : finite_dimensional.finrank â„ E = n) (x : orientation â„ E (fin n)) : orthonormal â„ â‡‘(orientation.fin_orthonormal_basis hn h x)
theorem category_theory.limits.has_equalizers_of_has_limit_parallel_pair (C : Type u) [category_theory.category C] [âˆ€ {X Y : C} {f g : X âŸ¶ Y}, category_theory.limits.has_limit (category_theory.limits.parallel_pair f g)] : category_theory.limits.has_equalizers C
theorem add_submonoid.supr_induction {M : Type u_1} [add_zero_class M] {Î¹ : Sort u_2} (S : Î¹ â†’ add_submonoid M) {C : M â†’ Prop} {x : M} (hx : x âˆˆ â¨† (i : Î¹), S i) (hp : âˆ€ (i : Î¹) (x : M), x âˆˆ S i â†’ C x) (h1 : C 0) (hmul : âˆ€ (x y : M), C x â†’ C y â†’ C (x + y)) : C x
theorem fourier_add_half_inv_index {n : â„¤} (hn : n â‰  0) (z : â†¥circle) : â‡‘(fourier n) (â‡‘exp_map_circle ((â†‘n)â»Â¹ * real.pi) * z) = -â‡‘(fourier n) z
theorem with_top.is_glb_Inf' {Î² : Type u_1} [conditionally_complete_lattice Î²] {s : set (with_top Î²)} (hs : bdd_below s) : is_glb s (has_Inf.Inf s)
theorem fin.succ_above_pos {n : â„•} (p : fin (n + 2)) (i : fin (n + 1)) (h : 0 < i) : 0 < â‡‘(p.succ_above) i
theorem category_theory.whisker_eq {C : Type u} [category_theory.category C] {X Y Z : C} (f : X âŸ¶ Y) {g h : Y âŸ¶ Z} (w : g = h) : f â‰« g = f â‰« h
theorem directed_of_inf {Î± : Type u} {Î² : Type v} [semilattice_inf Î±] {r : Î² â†’ Î² â†’ Prop} {f : Î± â†’ Î²} (hf : âˆ€ (aâ‚ aâ‚‚ : Î±), aâ‚ â‰¤ aâ‚‚ â†’ r (f aâ‚‚) (f aâ‚)) : directed r f
theorem module.free.rank_matrix (R : Type u) [ring R] [strong_rank_condition R] (m : Type v) (n : Type w) [fintype m] [fintype n] : module.rank R (matrix m n R) = (cardinal.mk m).lift * (cardinal.mk n).lift
theorem matrix.map_op_smul' {n : Type u_3} {Î± : Type v} {Î² : Type w} [has_mul Î±] [has_mul Î²] (f : Î± â†’ Î²) (r : Î±) (A : matrix n n Î±) (hf : âˆ€ (aâ‚ aâ‚‚ : Î±), f (aâ‚ * aâ‚‚) = f aâ‚ * f aâ‚‚) : (mul_opposite.op r â€¢ A).map f = mul_opposite.op (f r) â€¢ A.map f
theorem has_strict_deriv_at.has_strict_fderiv_at {ğ•œ : Type u} [nondiscrete_normed_field ğ•œ] {F : Type v} [normed_group F] [normed_space ğ•œ F] {f : ğ•œ â†’ F} {f' : F} {x : ğ•œ} : has_strict_deriv_at f f' x â†’ has_strict_fderiv_at f (1.smul_right f') x
theorem nat.le_pow_iff_clog_le {b : â„•} (hb : 1 < b) {x y : â„•} : x â‰¤ b ^ y â†” nat.clog b x â‰¤ y
theorem monoid_hom.map_exists_left_inv {M : Type u_3} {N : Type u_4} {F : Type u_8} {mM : mul_one_class M} {mN : mul_one_class N} [monoid_hom_class F M N] (f : F) {x : M} (hx : âˆƒ (y : M), y * x = 1) : âˆƒ (y : N), y * â‡‘f x = 1
theorem metric.is_closed_cthickening {Î± : Type u} [pseudo_emetric_space Î±] {Î´ : â„} {E : set Î±} : is_closed (metric.cthickening Î´ E)
theorem discrete_topology_iff_nhds {X : Type u_1} [topological_space X] : discrete_topology X â†” nhds = has_pure.pure
theorem generalized_continued_fraction.exists_rat_eq_of_terminates {K : Type u_1} [linear_ordered_field K] [floor_ring K] {v : K} (terminates : (generalized_continued_fraction.of v).terminates) : âˆƒ (q : â„š), v = â†‘q
theorem algebraic_geometry.LocallyRingedSpace.to_Î“_Spec_preim_basic_open_eq (X : algebraic_geometry.LocallyRingedSpace) (r : â†¥(algebraic_geometry.LocallyRingedSpace.Î“.obj (opposite.op X))) : X.to_Î“_Spec_fun â»Â¹' (prime_spectrum.basic_open r).val = (X.to_RingedSpace.basic_open r).val
theorem algebra.discr_not_zero_of_basis {Î¹ : Type w} [fintype Î¹] (K : Type u) {L : Type v} [field K] [field L] [algebra K L] [module.finite K L] [is_separable K L] (b : basis Î¹ K L) : algebra.discr K â‡‘b â‰  0
theorem finset.sum_smul_vsub_eq_weighted_vsub_of_point_sub {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {Î¹ : Type u_4} (s : finset Î¹) (w : Î¹ â†’ k) (pâ‚ pâ‚‚ : Î¹ â†’ P) (b : P) : s.sum (Î» (i : Î¹), w i â€¢ (pâ‚ i -áµ¥ pâ‚‚ i)) = â‡‘(s.weighted_vsub_of_point pâ‚ b) w - â‡‘(s.weighted_vsub_of_point pâ‚‚ b) w
theorem map_neg {G : Type u_6} {H : Type u_7} {F : Type u_8} [add_group G] [subtraction_monoid H] [add_monoid_hom_class F G H] (f : F) (a : G) : â‡‘f (-a) = -â‡‘f a
theorem has_deriv_at.comp {ğ•œ : Type u} [nondiscrete_normed_field ğ•œ] (x : ğ•œ) {ğ•œ' : Type u_1} [nondiscrete_normed_field ğ•œ'] [normed_algebra ğ•œ ğ•œ'] {h : ğ•œ â†’ ğ•œ'} {hâ‚‚ : ğ•œ' â†’ ğ•œ'} {h' hâ‚‚' : ğ•œ'} (hhâ‚‚ : has_deriv_at hâ‚‚ hâ‚‚' (h x)) (hh : has_deriv_at h h' x) : has_deriv_at (hâ‚‚ âˆ˜ h) (hâ‚‚' * h') x
theorem submonoid.prod_mem {M : Type u_1} [comm_monoid M] (S : submonoid M) {Î¹ : Type u_2} {t : finset Î¹} {f : Î¹ â†’ M} (h : âˆ€ (c : Î¹), c âˆˆ t â†’ f c âˆˆ S) : t.prod (Î» (c : Î¹), f c) âˆˆ S
theorem category_theory.over.construct_products.has_over_limit_discrete_of_wide_pullback_limit {J : Type v} {C : Type u} [category_theory.category C] {B : C} (F : category_theory.discrete J â¥¤ category_theory.over B) [category_theory.limits.has_limit (category_theory.over.construct_products.wide_pullback_diagram_of_diagram_over B F)] : category_theory.limits.has_limit F
theorem ideal.prod_eq_bot {R : Type u_1} [comm_ring R] [is_domain R] {s : multiset (ideal R)} : s.prod = âŠ¥ â†” âˆƒ (I : ideal R) (H : I âˆˆ s), I = âŠ¥
theorem measure_theory.measure.exists_positive_of_not_mutually_singular {Î± : Type u_1} {m : measurable_space Î±} (Î¼ Î½ : measure_theory.measure Î±) [measure_theory.is_finite_measure Î¼] [measure_theory.is_finite_measure Î½] (h : Â¬Î¼.mutually_singular Î½) : âˆƒ (Îµ : nnreal), 0 < Îµ âˆ§ âˆƒ (E : set Î±), measurable_set E âˆ§ 0 < â‡‘Î½ E âˆ§ 0.restrict E â‰¤ (Î¼.to_signed_measure - (Îµ â€¢ Î½).to_signed_measure).restrict E
theorem uniform_inducing.uniform_embedding {Î± : Type u_1} {Î² : Type u_2} [uniform_space Î±] [uniform_space Î²] [separated_space Î±] {f : Î± â†’ Î²} (hf : uniform_inducing f) : uniform_embedding f
theorem tsum_mul_tsum {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [topological_space Î±] [regular_space Î±] [non_unital_non_assoc_semiring Î±] [topological_semiring Î±] {f : Î² â†’ Î±} {g : Î³ â†’ Î±} (hf : summable f) (hg : summable g) (hfg : summable (Î» (x : Î² Ã— Î³), f x.fst * g x.snd)) : (âˆ‘' (x : Î²), f x) * âˆ‘' (y : Î³), g y = âˆ‘' (z : Î² Ã— Î³), f z.fst * g z.snd
theorem measure_theory.measurable_set_range_of_continuous_injective {Î³ : Type u_3} [tÎ³ : topological_space Î³] [polish_space Î³] {Î² : Type u_1} [topological_space Î²] [t2_space Î²] [measurable_space Î²] [borel_space Î²] {f : Î³ â†’ Î²} (f_cont : continuous f) (f_inj : function.injective f) : measurable_set (set.range f)
theorem inner_product_space.is_self_adjoint.has_eigenvector_of_is_local_extr_on {ğ•œ : Type u_1} [is_R_or_C ğ•œ] {E : Type u_2} [inner_product_space ğ•œ E] [complete_space E] {T : E â†’L[ğ•œ] E} (hT : inner_product_space.is_self_adjoint â†‘T) {xâ‚€ : E} (hxâ‚€ : xâ‚€ â‰  0) (hextr : is_local_extr_on T.re_apply_inner_self (metric.sphere 0 âˆ¥xâ‚€âˆ¥) xâ‚€) : module.End.has_eigenvector â†‘T â†‘((Î» (x : E), T.re_apply_inner_self x / âˆ¥xâˆ¥ ^ 2) xâ‚€) xâ‚€
theorem padic_norm.triangle_ineq (p : â„•) [hp : fact (nat.prime p)] (q r : â„š) : padic_norm p (q + r) â‰¤ padic_norm p q + padic_norm p r
theorem is_max_filter.dual {Î± : Type u} {Î² : Type v} [preorder Î²] {f : Î± â†’ Î²} {l : filter Î±} {a : Î±} : is_max_filter f l a â†’ is_min_filter (â‡‘order_dual.to_dual âˆ˜ f) l a
theorem module.End.eigenspace_restrict_eq_bot {R : Type v} {M : Type w} [comm_ring R] [add_comm_group M] [module R M] {f : module.End R M} {p : submodule R M} (hfp : âˆ€ (x : M), x âˆˆ p â†’ â‡‘f x âˆˆ p) {Î¼ : R} (hÎ¼p : disjoint (f.eigenspace Î¼) p) : module.End.eigenspace (linear_map.restrict f hfp) Î¼ = âŠ¥
theorem integrable_of_is_O_exp_neg {f : â„ â†’ â„} {a b : â„} (h0 : 0 < b) (h1 : continuous_on f (set.Ici a)) (h2 : f =O[filter.at_top] Î» (x : â„), real.exp (-b * x)) : measure_theory.integrable_on f (set.Ioi a) measure_theory.measure_space.volume
theorem measure_theory.add_haar_measure_eq_volume  : measure_theory.measure.add_haar_measure topological_space.positive_compacts.Icc01 = measure_theory.measure_space.volume
theorem algebra.finite_presentation.self (R : Type u_1) [comm_ring R] : algebra.finite_presentation R R
theorem antitone.pairwise_disjoint_on_Ioo_pred {Î± : Type u_1} {Î² : Type u_2} [linear_order Î±] [pred_order Î±] [preorder Î²] {f : Î± â†’ Î²} (hf : antitone f) : pairwise (disjoint on Î» (n : Î±), set.Ioo (f n) (f (order.pred n)))
theorem finsum_mem_of_eq_on_zero {Î± : Type u_1} {M : Type u_5} [add_comm_monoid M] {f : Î± â†’ M} {s : set Î±} (hf : set.eq_on f 0 s) : finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), f i)) = 0
theorem submonoid.localization_map.mk'_sec {M : Type u_1} [comm_monoid M] {S : submonoid M} {N : Type u_2} [comm_monoid N] (f : S.localization_map N) (z : N) : f.mk' (f.sec z).fst (f.sec z).snd = z
theorem nat.exists_strict_mono (Î± : Type u) [preorder Î±] [nonempty Î±] [no_max_order Î±] : âˆƒ (f : â„• â†’ Î±), strict_mono f
theorem has_lt.lt.ne_bot {Î± : Type u} [preorder Î±] [order_bot Î±] {a b : Î±} (h : a < b) : b â‰  âŠ¥
theorem filter.eventually_eq.germ_eq {Î± : Type u_1} {Î² : Type u_2} {l : filter Î±} {f g : Î± â†’ Î²} : f =á¶ [l] g â†’ â†‘f = â†‘g
theorem orientation.oangle_neg_right {V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) {x y : V} (hx : x â‰  0) (hy : y â‰  0) : o.oangle x (-y) = o.oangle x y + â†‘real.pi
theorem is_localization.algebra_map_surjective_of_fintype {R : Type u} [comm_ring R] (S : submonoid R) {L : Type u} [comm_ring L] [algebra R L] [is_localization S L] [fintype R] : function.surjective â‡‘(algebra_map R L)
theorem finset.sum_bij' {Î² : Type u} {Î± : Type v} {Î³ : Type w} [add_comm_monoid Î²] {s : finset Î±} {t : finset Î³} {f : Î± â†’ Î²} {g : Î³ â†’ Î²} (i : Î  (a : Î±), a âˆˆ s â†’ Î³) (hi : âˆ€ (a : Î±) (ha : a âˆˆ s), i a ha âˆˆ t) (h : âˆ€ (a : Î±) (ha : a âˆˆ s), f a = g (i a ha)) (j : Î  (a : Î³), a âˆˆ t â†’ Î±) (hj : âˆ€ (a : Î³) (ha : a âˆˆ t), j a ha âˆˆ s) (left_inv : âˆ€ (a : Î±) (ha : a âˆˆ s), j (i a ha) _ = a) (right_inv : âˆ€ (a : Î³) (ha : a âˆˆ t), i (j a ha) _ = a) : s.sum (Î» (x : Î±), f x) = t.sum (Î» (x : Î³), g x)
theorem well_founded.fix_eq {Î± : Sort u} {C : Î± â†’ Sort v} {r : Î± â†’ Î± â†’ Prop} (hwf : well_founded r) (F : Î  (x : Î±), (Î  (y : Î±), r y x â†’ C y) â†’ C x) (x : Î±) : hwf.fix F x = F x (Î» (y : Î±) (h : r y x), hwf.fix F y)
theorem to_matrix_rotation (a : â†¥circle) : â‡‘(linear_map.to_matrix complex.basis_one_I complex.basis_one_I) â†‘((â‡‘rotation a).to_linear_equiv) = â‡‘(matrix.plane_conformal_matrix â†‘a.re â†‘a.im _)
theorem is_dedekind_domain.height_one_spectrum.int_valuation_lt_one_iff_dvd {R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] (v : is_dedekind_domain.height_one_spectrum R) (r : R) : v.int_valuation_def r < 1 â†” v.as_ideal âˆ£ ideal.span {r}
theorem measure_theory.integral_fn_integral_sub {Î± : Type u_1} {Î² : Type u_3} {E : Type u_6} [measurable_space Î±] [measurable_space Î²] {Î¼ : measure_theory.measure Î±} {Î½ : measure_theory.measure Î²} [normed_group E] [measure_theory.sigma_finite Î½] [normed_space â„ E] [complete_space E] [measure_theory.sigma_finite Î¼] {E' : Type u_7} [normed_group E'] [complete_space E'] [normed_space â„ E'] â¦ƒf g : Î± Ã— Î² â†’ Eâ¦„ (F : E â†’ E') (hf : measure_theory.integrable f (Î¼.prod Î½)) (hg : measure_theory.integrable g (Î¼.prod Î½)) : âˆ« (x : Î±), F (âˆ« (y : Î²), f (x, y) - g (x, y) âˆ‚Î½) âˆ‚Î¼ = âˆ« (x : Î±), F (âˆ« (y : Î²), f (x, y) âˆ‚Î½ - âˆ« (y : Î²), g (x, y) âˆ‚Î½) âˆ‚Î¼
theorem subgroup.exists_right_complement'_of_coprime_of_fintype {G : Type u} [group G] [fintype G] {N : subgroup G} [N.normal] (hN : (fintype.card â†¥N).coprime N.index) : âˆƒ (H : subgroup G), N.is_complement' H
theorem minpoly.eq_X_sub_C_of_algebra_map_inj {A : Type u_1} {B : Type u_2} [comm_ring A] [ring B] [algebra A B] [nontrivial B] (a : A) (hf : function.injective â‡‘(algebra_map A B)) : minpoly A (â‡‘(algebra_map A B) a) = polynomial.X - â‡‘polynomial.C a
theorem affine.simplex.face_points' {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {n : â„•} (s : affine.simplex k P n) {fs : finset (fin (n + 1))} {m : â„•} (h : fs.card = m + 1) : (s.face h).points = s.points âˆ˜ â‡‘(fs.order_emb_of_fin h)
theorem is_square.inv {Î± : Type u_2} [division_monoid Î±] {a : Î±} : is_square a â†’ is_square aâ»Â¹
theorem exp_sum_of_commute {ğ•‚ : Type u_1} {ğ”¸ : Type u_2} [is_R_or_C ğ•‚] [normed_ring ğ”¸] [normed_algebra ğ•‚ ğ”¸] [complete_space ğ”¸] {Î¹ : Type u_3} (s : finset Î¹) (f : Î¹ â†’ ğ”¸) (h : âˆ€ (i : Î¹), i âˆˆ s â†’ âˆ€ (j : Î¹), j âˆˆ s â†’ commute (f i) (f j)) : exp ğ•‚ (s.sum (Î» (i : Î¹), f i)) = s.noncomm_prod (Î» (i : Î¹), exp ğ•‚ (f i)) _
theorem finset.sized_slice {Î± : Type u_1} {ğ’œ : finset (finset Î±)} {r : â„•} : set.sized r â†‘(ğ’œ.slice r)
theorem ennreal.prod_lt_top {Î± : Type u_1} {s : finset Î±} {f : Î± â†’ ennreal} (h : âˆ€ (a : Î±), a âˆˆ s â†’ f a â‰  âŠ¤) : s.prod (Î» (a : Î±), f a) < âŠ¤
theorem line_map_slope_slope_sub_div_sub {k : Type u_1} {E : Type u_2} {PE : Type u_3} [field k] [add_comm_group E] [module k E] [add_torsor E PE] (f : k â†’ PE) (a b c : k) (h : a â‰  c) : â‡‘(affine_map.line_map (slope f a b) (slope f b c)) ((c - b) / (c - a)) = slope f a c
theorem linear_pmap.sup_h_of_disjoint {R : Type u_1} [ring R] {E : Type u_2} [add_comm_group E] [module R E] {F : Type u_3} [add_comm_group F] [module R F] (f g : linear_pmap R E F) (h : disjoint f.domain g.domain) (x : â†¥(f.domain)) (y : â†¥(g.domain)) (hxy : â†‘x = â†‘y) : â‡‘f x = â‡‘g y
theorem centroid_mem_affine_span_of_card_eq_add_one (k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] {Î¹ : Type u_4} [char_zero k] {s : finset Î¹} (p : Î¹ â†’ P) {n : â„•} (h : s.card = n + 1) : finset.centroid k s p âˆˆ affine_span k (set.range p)
theorem affine_subspace.mem_affine_span_singleton (k : Type u_1) (V : Type u_2) {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] (p1 p2 : P) : p1 âˆˆ affine_span k {p2} â†” p1 = p2
theorem category_theory.triangulated.pretriangulated.rot_of_dist_triangle (C : Type u) [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.has_shift C â„¤] [category_theory.preadditive C] [âˆ€ (n : â„¤), (category_theory.shift_functor C n).additive] [category_theory.triangulated.pretriangulated C] (T : category_theory.triangulated.triangle C) (H : T âˆˆ dist_triang C) : T.rotate âˆˆ dist_triang C
theorem polynomial.cyclotomic_one (R : Type u_1) [ring R] : polynomial.cyclotomic 1 R = polynomial.X - 1
theorem continuous_on.measurable_piecewise {Î± : Type u_1} {Î³ : Type u_3} [topological_space Î±] [measurable_space Î±] [opens_measurable_space Î±] [topological_space Î³] [measurable_space Î³] [borel_space Î³] {f g : Î± â†’ Î³} {s : set Î±} [Î  (j : Î±), decidable (j âˆˆ s)] (hf : continuous_on f s) (hg : continuous_on g sá¶œ) (hs : measurable_set s) : measurable (s.piecewise f g)
theorem interval_integrable.def {E : Type u_3} [normed_group E] {f : â„ â†’ E} {a b : â„} {Î¼ : measure_theory.measure â„} (h : interval_integrable f Î¼ a b) : measure_theory.integrable_on f (set.interval_oc a b) Î¼
theorem nnreal.is_greatest_Lp {Î¹ : Type u} (s : finset Î¹) (f : Î¹ â†’ nnreal) {p q : â„} (hpq : p.is_conjugate_exponent q) : is_greatest ((Î» (g : Î¹ â†’ nnreal), s.sum (Î» (i : Î¹), f i * g i)) '' {g : Î¹ â†’ nnreal | s.sum (Î» (i : Î¹), g i ^ q) â‰¤ 1}) (s.sum (Î» (i : Î¹), f i ^ p) ^ (1 / p))
theorem padic_norm.zero (p : â„•) : padic_norm p 0 = 0
theorem measurable_set.measure_eq_supr_is_closed_of_ne_top {Î± : Type u_1} [measurable_space Î±] [topological_space Î±] {Î¼ : measure_theory.measure Î±} [Î¼.weakly_regular] â¦ƒA : set Î±â¦„ (hA : measurable_set A) (h'A : â‡‘Î¼ A â‰  âŠ¤) : â‡‘Î¼ A = â¨† (K : set Î±) (H : K âŠ† A) (h : is_closed K), â‡‘Î¼ K
theorem finsupp.distrib_mul_action_hom_ext' {Î± : Type u_1} {M : Type u_5} {N : Type u_7} {R : Type u_11} [semiring R] [add_comm_monoid M] [add_comm_monoid N] [distrib_mul_action R M] [distrib_mul_action R N] {f g : (Î± â†’â‚€ M) â†’+[R] N} (h : âˆ€ (a : Î±), f.comp (finsupp.distrib_mul_action_hom.single a) = g.comp (finsupp.distrib_mul_action_hom.single a)) : f = g
theorem module.finite.injective_of_surjective_endomorphism {R : Type u_1} [comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] (f : M â†’â‚—[R] M) [hfg : module.finite R M] (f_surj : function.surjective â‡‘f) : function.injective â‡‘f
theorem spectrum.subset_polynomial_aeval {ğ•œ : Type u} {A : Type v} [field ğ•œ] [ring A] [algebra ğ•œ A] (a : A) (p : polynomial ğ•œ) : (Î» (k : ğ•œ), polynomial.eval k p) '' spectrum ğ•œ a âŠ† spectrum ğ•œ (â‡‘(polynomial.aeval a) p)
theorem metric.inf_dist_zero_of_mem_closure {Î± : Type u} [pseudo_metric_space Î±] {s : set Î±} {x : Î±} (hx : x âˆˆ closure s) : metric.inf_dist x s = 0
theorem euclidean_geometry.angle_eq_of_ne {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {p1 p2 : P} (h : p1 â‰  p2) : euclidean_geometry.angle p1 p2 p1 = 0
theorem linear_equiv.dim_eq {R : Type u} [ring R] {M : Type v} [add_comm_group M] [module R M] {Mâ‚ : Type v} [add_comm_group Mâ‚] [module R Mâ‚] (f : M â‰ƒâ‚—[R] Mâ‚) : module.rank R M = module.rank R Mâ‚
theorem interval_integral.continuous_within_at_of_dominated_interval {E : Type u_3} [normed_group E] [complete_space E] [normed_space â„ E] {Î¼ : measure_theory.measure â„} {X : Type u_5} [topological_space X] [topological_space.first_countable_topology X] {F : X â†’ â„ â†’ E} {xâ‚€ : X} {bound : â„ â†’ â„} {a b : â„} {s : set X} (hF_meas : âˆ€á¶  (x : X) in nhds_within xâ‚€ s, measure_theory.ae_strongly_measurable (F x) (Î¼.restrict (set.interval_oc a b))) (h_bound : âˆ€á¶  (x : X) in nhds_within xâ‚€ s, âˆ€áµ (t : â„) âˆ‚Î¼, t âˆˆ set.interval_oc a b â†’ âˆ¥F x tâˆ¥ â‰¤ bound t) (bound_integrable : interval_integrable bound Î¼ a b) (h_cont : âˆ€áµ (t : â„) âˆ‚Î¼, t âˆˆ set.interval_oc a b â†’ continuous_within_at (Î» (x : X), F x t) s xâ‚€) : continuous_within_at (Î» (x : X), âˆ« (t : â„) in a..b, F x t âˆ‚Î¼) s xâ‚€
theorem ext_chart_preimage_mem_nhds {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] (I : model_with_corners ğ•œ E H) {M : Type u_4} [topological_space M] [charted_space H M] (x : M) {t : set M} (ht : t âˆˆ nhds x) : â‡‘((ext_chart_at I x).symm) â»Â¹' t âˆˆ nhds (â‡‘(ext_chart_at I x) x)
theorem set.Icc_union_Icc {Î± : Type u_1} [linear_order Î±] {a b c d : Î±} (hâ‚ : linear_order.min a b < linear_order.max c d) (hâ‚‚ : linear_order.min c d < linear_order.max a b) : set.Icc a b âˆª set.Icc c d = set.Icc (linear_order.min a c) (linear_order.max b d)
theorem set_of_is_preconnected_subset_of_ordered {Î± : Type u} [conditionally_complete_linear_order Î±] [topological_space Î±] [order_topology Î±] : {s : set Î± | is_preconnected s} âŠ† set.range (function.uncurry set.Icc) âˆª set.range (function.uncurry set.Ico) âˆª set.range (function.uncurry set.Ioc) âˆª set.range (function.uncurry set.Ioo) âˆª (set.range set.Ici âˆª set.range set.Ioi âˆª set.range set.Iic âˆª set.range set.Iio âˆª {set.univ, âˆ…})
theorem matrix.det_eq_of_forall_col_eq_smul_add_pred {R : Type v} [comm_ring R] {n : â„•} {A B : matrix (fin (n + 1)) (fin (n + 1)) R} (c : fin n â†’ R) (A_zero : âˆ€ (i : fin (n + 1)), A i 0 = B i 0) (A_succ : âˆ€ (i : fin (n + 1)) (j : fin n), A i j.succ = B i j.succ + c j * A i (â‡‘fin.cast_succ j)) : A.det = B.det
theorem real.Lp_add_le_tsum_of_nonneg {Î¹ : Type u} {f g : Î¹ â†’ â„} {p : â„} (hp : 1 â‰¤ p) (hf : âˆ€ (i : Î¹), 0 â‰¤ f i) (hg : âˆ€ (i : Î¹), 0 â‰¤ g i) (hf_sum : summable (Î» (i : Î¹), f i ^ p)) (hg_sum : summable (Î» (i : Î¹), g i ^ p)) : summable (Î» (i : Î¹), (f i + g i) ^ p) âˆ§ (âˆ‘' (i : Î¹), (f i + g i) ^ p) ^ (1 / p) â‰¤ (âˆ‘' (i : Î¹), f i ^ p) ^ (1 / p) + (âˆ‘' (i : Î¹), g i ^ p) ^ (1 / p)
theorem metric.diam_ball {Î± : Type u} [pseudo_metric_space Î±] {x : Î±} {r : â„} (h : 0 â‰¤ r) : metric.diam (metric.ball x r) â‰¤ 2 * r
theorem fin.succ_above_left_injective {n : â„•} : function.injective fin.succ_above
theorem laurent_polynomial.mul_T_assoc {R : Type u_1} [semiring R] (f : laurent_polynomial R) (m n : â„¤) : f * laurent_polynomial.T m * laurent_polynomial.T n = f * laurent_polynomial.T (m + n)
theorem finset.order_emb_of_fin_unique' {Î± : Type u_1} [linear_order Î±] {s : finset Î±} {k : â„•} (h : s.card = k) {f : fin k â†ªo Î±} (hfs : âˆ€ (x : fin k), â‡‘f x âˆˆ s) : f = s.order_emb_of_fin h
theorem has_sbtw.sbtw.cyclic_right {Î± : Type u_1} [circular_preorder Î±] {a b c : Î±} (h : has_sbtw.sbtw a b c) : has_sbtw.sbtw c a b
theorem nilpotency_class_quotient_le {G : Type u_1} [group G] (H : subgroup G) [H.normal] [h : group.is_nilpotent G] : group.nilpotency_class (G â§¸ H) â‰¤ group.nilpotency_class G
theorem Top.presheaf.stalk_hom_ext {C : Type u} [category_theory.category C] [category_theory.limits.has_colimits C] {X : Top} (F : Top.presheaf C X) {x : â†¥X} {Y : C} {fâ‚ fâ‚‚ : F.stalk x âŸ¶ Y} (ih : âˆ€ (U : topological_space.opens â†¥X) (hxU : x âˆˆ U), F.germ âŸ¨x, hxUâŸ© â‰« fâ‚ = F.germ âŸ¨x, hxUâŸ© â‰« fâ‚‚) : fâ‚ = fâ‚‚
theorem submodule.coe_norm {ğ•œ : Type u_1} {_x : ring ğ•œ} {E : Type u_2} [semi_normed_group E] {_x_1 : module ğ•œ E} {s : submodule ğ•œ E} (x : â†¥s) : âˆ¥xâˆ¥ = âˆ¥â†‘xâˆ¥
theorem geometry.simplicial_complex.disjoint_or_exists_inter_eq_convex_hull {ğ•œ : Type u_1} {E : Type u_2} [ordered_ring ğ•œ] [add_comm_group E] [module ğ•œ E] {K : geometry.simplicial_complex ğ•œ E} {s t : finset E} (hs : s âˆˆ K.faces) (ht : t âˆˆ K.faces) : disjoint (â‡‘(convex_hull ğ•œ) â†‘s) (â‡‘(convex_hull ğ•œ) â†‘t) âˆ¨ âˆƒ (u : finset E) (H : u âˆˆ K.faces), â‡‘(convex_hull ğ•œ) â†‘s âˆ© â‡‘(convex_hull ğ•œ) â†‘t = â‡‘(convex_hull ğ•œ) â†‘u
theorem sylow.exists_subgroup_card_pow_prime_le {G : Type u} [group G] [fintype G] (p : â„•) {n m : â„•} [hp : fact (nat.prime p)] (hdvd : p ^ m âˆ£ fintype.card G) (H : subgroup G) (hH : fintype.card â†¥H = p ^ n) (hnm : n â‰¤ m) : âˆƒ (K : subgroup G), fintype.card â†¥K = p ^ m âˆ§ H â‰¤ K
theorem integral_closure.is_fraction_ring_of_finite_extension {A : Type u_4} (K : Type u_5) [comm_ring A] [is_domain A] (L : Type u_6) [field K] [field L] [algebra A K] [is_fraction_ring A K] [algebra A L] [algebra K L] [is_scalar_tower A K L] [finite_dimensional K L] : is_fraction_ring â†¥(integral_closure A L) L
theorem measure_theory.strongly_measurable_const' {Î± : Type u_1} {Î² : Type u_2} {m : measurable_space Î±} [topological_space Î²] {f : Î± â†’ Î²} (hf : âˆ€ (x y : Î±), f x = f y) : measure_theory.strongly_measurable f
theorem antitone.concave_on_univ_of_deriv {f : â„ â†’ â„} (hf : differentiable â„ f) (hf'_anti : antitone (deriv f)) : concave_on â„ set.univ f
theorem tendsto_subseq_of_frequently_bounded {X : Type u_1} [pseudo_metric_space X] [proper_space X] {s : set X} (hs : metric.bounded s) {x : â„• â†’ X} (hx : âˆƒá¶  (n : â„•) in filter.at_top, x n âˆˆ s) : âˆƒ (a : X) (H : a âˆˆ closure s) (Ï† : â„• â†’ â„•), strict_mono Ï† âˆ§ filter.tendsto (x âˆ˜ Ï†) filter.at_top (nhds a)
theorem algebraic_topology.dold_kan.cs_down_0_not_rel_left (j : â„•) : Â¬algebraic_topology.dold_kan.c.rel 0 j
theorem affine.simplex.centroid_eq_iff {k : Type u_1} {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] [char_zero k] {n : â„•} (s : affine.simplex k P n) {fsâ‚ fsâ‚‚ : finset (fin (n + 1))} {mâ‚ mâ‚‚ : â„•} (hâ‚ : fsâ‚.card = mâ‚ + 1) (hâ‚‚ : fsâ‚‚.card = mâ‚‚ + 1) : finset.centroid k fsâ‚ s.points = finset.centroid k fsâ‚‚ s.points â†” fsâ‚ = fsâ‚‚
theorem char.quadratic_char_mul {F : Type u_1} [field F] [fintype F] [decidable_eq F] (a b : F) : char.quadratic_char F (a * b) = char.quadratic_char F a * char.quadratic_char F b
theorem add_submonoid.localization_map.map_add_right {M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {N : Type u_2} [add_comm_monoid N] {P : Type u_3} [add_comm_monoid P] (f : S.localization_map N) {g : M â†’+ P} {T : add_submonoid P} (hy : âˆ€ (y : â†¥S), â‡‘g â†‘y âˆˆ T) {Q : Type u_4} [add_comm_monoid Q] {k : T.localization_map Q} (z : N) : â‡‘(f.map hy k) z + â‡‘(k.to_map) (â‡‘g â†‘((f.sec z).snd)) = â‡‘(k.to_map) (â‡‘g (f.sec z).fst)
theorem vector_span_range_eq_span_range_vsub_right (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {Î¹ : Type u_4} (p : Î¹ â†’ P) (i0 : Î¹) : vector_span k (set.range p) = submodule.span k (set.range (Î» (i : Î¹), p i -áµ¥ p i0))
theorem isometry_subtype_coe {Î± : Type u} [pseudo_emetric_space Î±] {s : set Î±} : isometry coe
theorem finset.sum_pow_mul_eq_add_pow {Î± : Type u_1} {R : Type u_2} [comm_semiring R] (a b : R) (s : finset Î±) : s.powerset.sum (Î» (t : finset Î±), a ^ t.card * b ^ (s.card - t.card)) = (a + b) ^ s.card
theorem interval_integral.measure_integral_sub_linear_is_o_of_tendsto_ae_of_le' {Î¹ : Type u_1} {E : Type u_3} [normed_group E] [complete_space E] [normed_space â„ E] {f : â„ â†’ E} {c : E} {l l' : filter â„} {lt : filter Î¹} {Î¼ : measure_theory.measure â„} {u v : Î¹ â†’ â„} [l'.is_measurably_generated] [filter.tendsto_Ixx_class set.Ioc l l'] (hfm : strongly_measurable_at_filter f l' Î¼) (hf : filter.tendsto f (l' âŠ“ Î¼.ae) (nhds c)) (hl : Î¼.finite_at_filter l') (hu : filter.tendsto u lt l) (hv : filter.tendsto v lt l) (huv : u â‰¤á¶ [lt] v) : (Î» (t : Î¹), âˆ« (x : â„) in u t..v t, f x âˆ‚Î¼ - (â‡‘Î¼ (set.Ioc (u t) (v t))).to_real â€¢ c) =o[lt] Î» (t : Î¹), (â‡‘Î¼ (set.Ioc (u t) (v t))).to_real
theorem ideal.comap_of_equiv {R : Type u} {S : Type v} [ring R] [ring S] (I : ideal R) (f : R â‰ƒ+* S) : ideal.comap â†‘f (ideal.comap â†‘(f.symm) I) = I
theorem subfield.mul_mem {K : Type u} [field K] (s : subfield K) {x y : K} : x âˆˆ s â†’ y âˆˆ s â†’ x * y âˆˆ s
theorem right.add_lt_add {Î± : Type u_1} [has_add Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b c d : Î±} (hâ‚ : a < b) (hâ‚‚ : c < d) : a + c < b + d
theorem has_ssubset.ssubset.ne {Î± : Type u} [has_ssubset Î±] [is_irrefl Î± has_ssubset.ssubset] {a b : Î±} : a âŠ‚ b â†’ a â‰  b
theorem affine_subspace.direction_top (k : Type u_1) (V : Type u_2) (P : Type u_3) [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] : âŠ¤.direction = âŠ¤
theorem is_right_regular_of_mul_eq_one {R : Type u_1} {a b : R} [monoid R] (h : a * b = 1) : is_right_regular a
theorem measurable.le_map {Î± : Type u_1} {Î² : Type u_2} {mâ‚ : measurable_space Î±} {mâ‚‚ : measurable_space Î²} {f : Î± â†’ Î²} : measurable f â†’ mâ‚‚ â‰¤ measurable_space.map f mâ‚
theorem asymptotics.bound_of_is_O_cofinite {Î± : Type u_1} {E : Type u_3} {F'' : Type u_10} [has_norm E] [normed_group F''] {f : Î± â†’ E} {g'' : Î± â†’ F''} (h : f =O[filter.cofinite] g'') : âˆƒ (C : â„) (H : C > 0), âˆ€ â¦ƒx : Î±â¦„, g'' x â‰  0 â†’ âˆ¥f xâˆ¥ â‰¤ C * âˆ¥g'' xâˆ¥
theorem normed_ring.inverse_add_norm_diff_second_order {R : Type u_1} [normed_ring R] [complete_space R] (x : RË£) : (Î» (t : R), ring.inverse (â†‘x + t) - â†‘xâ»Â¹ + â†‘xâ»Â¹ * t * â†‘xâ»Â¹) =O[nhds 0] Î» (t : R), âˆ¥tâˆ¥ ^ 2
theorem star_convex.preimage_add_left {ğ•œ : Type u_1} {E : Type u_2} [ordered_semiring ğ•œ] [add_comm_monoid E] [module ğ•œ E] {x z : E} {s : set E} (hs : star_convex ğ•œ (x + z) s) : star_convex ğ•œ x ((Î» (x : E), x + z) â»Â¹' s)
theorem monoid_algebra.mem_adjoint_support {R : Type u_1} {M : Type u_2} [comm_semiring R] [monoid M] (f : monoid_algebra R M) : f âˆˆ algebra.adjoin R (â‡‘(monoid_algebra.of R M) '' â†‘(f.support))
theorem polynomial.gal.restrict_smul {F : Type u_1} [field F] {p : polynomial F} {E : Type u_2} [field E] [algebra F E] [fact (polynomial.splits (algebra_map F E) p)] (Ï• : E â‰ƒâ‚[F] E) (x : â†¥(p.root_set E)) : â†‘(â‡‘(polynomial.gal.restrict p E) Ï• â€¢ x) = â‡‘Ï• â†‘x
theorem linear_independent_iff_card_eq_finrank_span {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {Î¹ : Type u_1} [fintype Î¹] {b : Î¹ â†’ V} : linear_independent K b â†” fintype.card Î¹ = set.finrank K (set.range b)
theorem inner_product_geometry.sin_angle_sub_add_angle_sub_rev_eq_sin_angle {V : Type u_1} [inner_product_space â„ V] {x y : V} (hx : x â‰  0) (hy : y â‰  0) : real.sin (inner_product_geometry.angle x (x - y) + inner_product_geometry.angle y (y - x)) = real.sin (inner_product_geometry.angle x y)
theorem is_right_regular_iff {R : Type u_1} [has_mul R] {a : R} : is_right_regular a â†” is_smul_regular R (mul_opposite.op a)
theorem interior_convex_hull_aff_basis {Î¹ : Type u_1} {E : Type u_2} [fintype Î¹] [normed_group E] [normed_space â„ E] (b : affine_basis Î¹ â„ E) : interior (â‡‘(convex_hull â„) (set.range b.points)) = {x : E | âˆ€ (i : Î¹), 0 < â‡‘(b.coord i) x}
theorem box_integral.integrable.tendsto_integral_sum_to_filter_prod_self_inf_Union_eq_uniformity {Î¹ : Type u} {E : Type v} {F : Type w} [normed_group E] [normed_space â„ E] [normed_group F] [normed_space â„ F] {I : box_integral.box Î¹} [fintype Î¹] {l : box_integral.integration_params} {f : (Î¹ â†’ â„) â†’ E} {vol : box_integral.box_additive_map Î¹ (E â†’L[â„] F) âŠ¤} (h : box_integral.integrable I l f vol) : filter.tendsto (Î» (Ï€ : box_integral.tagged_prepartition I Ã— box_integral.tagged_prepartition I), (box_integral.integral_sum f vol Ï€.fst, box_integral.integral_sum f vol Ï€.snd)) ((l.to_filter I).prod (l.to_filter I) âŠ“ filter.principal {Ï€ : box_integral.tagged_prepartition I Ã— box_integral.tagged_prepartition I | Ï€.fst.Union = Ï€.snd.Union}) (uniformity F)
theorem set.subset_bUnion_of_mem {Î± : Type u_1} {Î² : Type u_2} {s : set Î±} {u : Î± â†’ set Î²} {x : Î±} (xs : x âˆˆ s) : u x âŠ† â‹ƒ (x : Î±) (H : x âˆˆ s), u x
theorem cont_diff_bump_of_inner.dist_normed_convolution_le {G : Type u_2} {E' : Type u_4} [normed_group E'] {g : G â†’ E'} [measurable_space G] {Î¼ : measure_theory.measure G} [normed_space â„ E'] [inner_product_space â„ G] [complete_space E'] {Ï† : cont_diff_bump_of_inner 0} [borel_space G] [measure_theory.is_locally_finite_measure Î¼] [Î¼.is_open_pos_measure] [finite_dimensional â„ G] [Î¼.is_add_left_invariant] {xâ‚€ : G} {Îµ : â„} (hmg : measure_theory.ae_strongly_measurable g Î¼) (hg : âˆ€ (x : G), x âˆˆ metric.ball xâ‚€ Ï†.R â†’ has_dist.dist (g x) (g xâ‚€) â‰¤ Îµ) : has_dist.dist (convolution (Ï†.normed Î¼) g (continuous_linear_map.lsmul â„ â„) Î¼ xâ‚€) (g xâ‚€) â‰¤ Îµ
theorem submodule.mem_orthogonal {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] (K : submodule ğ•œ E) (v : E) : v âˆˆ Ká—® â†” âˆ€ (u : E), u âˆˆ K â†’ has_inner.inner u v = 0
theorem add_con.eq {M : Type u_1} [has_add M] (c : add_con M) {a b : M} : â†‘a = â†‘b â†” â‡‘c a b
theorem order_of_pos {G : Type u} [fintype G] [left_cancel_monoid G] (x : G) : 0 < order_of x
theorem set.Inter_subset_of_subset {Î± : Type u_1} {Î¹ : Sort u_4} {s : Î¹ â†’ set Î±} {t : set Î±} (i : Î¹) (h : s i âŠ† t) : (â‹‚ (i : Î¹), s i) âŠ† t
theorem set.subsingleton_coe {Î± : Type u} (s : set Î±) : subsingleton â†¥s â†” s.subsingleton
theorem map_Sup_of_continuous_at_of_monotone {Î± : Type u} {Î² : Type v} [complete_linear_order Î±] [topological_space Î±] [order_topology Î±] [complete_linear_order Î²] [topological_space Î²] [order_topology Î²] {f : Î± â†’ Î²} {s : set Î±} (Cf : continuous_at f (has_Sup.Sup s)) (Mf : monotone f) (fbot : f âŠ¥ = âŠ¥) : f (has_Sup.Sup s) = has_Sup.Sup (f '' s)
theorem nsmul_eq_smul_cast (R : Type u_2) {M : Type u_5} [semiring R] [add_comm_monoid M] [module R M] (n : â„•) (b : M) : n â€¢ b = â†‘n â€¢ b
theorem first_order.language.embedding.is_elementary_of_exists {L : first_order.language} {M : Type u_3} {N : Type u_4} [L.Structure M] [L.Structure N] (f : L.embedding M N) (htv : âˆ€ (n : â„•) (Ï† : L.bounded_formula empty (n + 1)) (x : fin n â†’ M) (a : N), Ï†.realize inhabited.default (fin.snoc (â‡‘f âˆ˜ x) a) â†’ (âˆƒ (b : M), Ï†.realize inhabited.default (fin.snoc (â‡‘f âˆ˜ x) (â‡‘f b)))) {n : â„•} (Ï† : L.formula (fin n)) (x : fin n â†’ M) : Ï†.realize (â‡‘f âˆ˜ x) â†” Ï†.realize x
theorem cont_diff_at.fst {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {G : Type u_4} [normed_group G] [normed_space ğ•œ G] {n : with_top â„•} {f : E â†’ F Ã— G} {x : E} (hf : cont_diff_at ğ•œ n f x) : cont_diff_at ğ•œ n (Î» (x : E), (f x).fst) x
theorem complex.norm_dslope_le_div_of_maps_to_ball {E : Type u_1} [normed_group E] [normed_space â„‚ E] {Râ‚ Râ‚‚ : â„} {f : â„‚ â†’ E} {c z : â„‚} (hd : differentiable_on â„‚ f (metric.ball c Râ‚)) (h_maps : set.maps_to f (metric.ball c Râ‚) (metric.ball (f c) Râ‚‚)) (hz : z âˆˆ metric.ball c Râ‚) : âˆ¥dslope f c zâˆ¥ â‰¤ Râ‚‚ / Râ‚
theorem absolute_value.is_admissible.exists_partition {R : Type u_1} [euclidean_domain R] {abv : absolute_value R â„¤} {Î¹ : Type u_2} [fintype Î¹] {Îµ : â„} (hÎµ : 0 < Îµ) {b : R} (hb : b â‰  0) (A : Î¹ â†’ R) (h : abv.is_admissible) : âˆƒ (t : Î¹ â†’ fin (h.card Îµ)), âˆ€ (iâ‚€ iâ‚ : Î¹), t iâ‚€ = t iâ‚ â†’ â†‘(â‡‘abv (A iâ‚ % b - A iâ‚€ % b)) < â‡‘abv b â€¢ Îµ
theorem measure_theory.outer_measure.trim_sup {Î± : Type u_1} [measurable_space Î±] (mâ‚ mâ‚‚ : measure_theory.outer_measure Î±) : (mâ‚ âŠ” mâ‚‚).trim = mâ‚.trim âŠ” mâ‚‚.trim
theorem int.exists_least_of_bdd {P : â„¤ â†’ Prop} (Hbdd : âˆƒ (b : â„¤), âˆ€ (z : â„¤), P z â†’ b â‰¤ z) (Hinh : âˆƒ (z : â„¤), P z) : âˆƒ (lb : â„¤), P lb âˆ§ âˆ€ (z : â„¤), P z â†’ lb â‰¤ z
theorem complex.exists_root {f : polynomial â„‚} (hf : 0 < f.degree) : âˆƒ (z : â„‚), f.is_root z
theorem mem_gal_basis_iff (K : Type u_1) (L : Type u_2) [field K] [field L] [algebra K L] (U : set (L â‰ƒâ‚[K] L)) : U âˆˆ gal_basis K L â†” U âˆˆ subgroup.carrier '' fixed_by_finite K L
theorem category_theory.functor.conj_eq_to_hom_iff_heq {C : Type uâ‚} [category_theory.category C] {W X Y Z : C} (f : W âŸ¶ X) (g : Y âŸ¶ Z) (h : W = Y) (h' : X = Z) : f = category_theory.eq_to_hom h â‰« g â‰« category_theory.eq_to_hom _ â†” f == g
theorem affine_independent.finrank_vector_span_image_finset {k : Type u_1} {V : Type u_2} {P : Type u_3} {Î¹ : Type u_4} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] {p : Î¹ â†’ P} (hi : affine_independent k p) {s : finset Î¹} {n : â„•} (hc : s.card = n + 1) : finite_dimensional.finrank k â†¥(vector_span k â†‘(finset.image p s)) = n
theorem asymptotics.is_O.eventually_mul_div_cancel {Î± : Type u_1} {ğ•œ : Type u_14} [normed_field ğ•œ] {l : filter Î±} {u v : Î± â†’ ğ•œ} (h : u =O[l] v) : u / v * v =á¶ [l] u
theorem disjoint_nhds_within_of_mem_discrete {Î± : Type u} [topological_space Î±] {s : set Î±} [discrete_topology â†¥s] {x : Î±} (hx : x âˆˆ s) : âˆƒ (U : set Î±) (H : U âˆˆ nhds_within x {x}á¶œ), disjoint U s
theorem finset.bdd_below {Î± : Type u} [semilattice_inf Î±] [nonempty Î±] (s : finset Î±) : bdd_below â†‘s
theorem vsub_eq_zero_iff_eq {G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] {p1 p2 : P} : p1 -áµ¥ p2 = 0 â†” p1 = p2
theorem is_ring_hom.map_sub {Î± : Type u} {Î² : Type v} [ring Î±] [ring Î²] {f : Î± â†’ Î²} {x y : Î±} (hf : is_ring_hom f) : f (x - y) = f x - f y
theorem monovary_on.sum_comp_perm_mul_eq_sum_mul_iff {Î¹ : Type u_1} {Î± : Type u_2} [linear_ordered_ring Î±] {s : finset Î¹} {Ïƒ : equiv.perm Î¹} {f g : Î¹ â†’ Î±} (hfg : monovary_on f g â†‘s) (hÏƒ : {x : Î¹ | â‡‘Ïƒ x â‰  x} âŠ† â†‘s) : s.sum (Î» (i : Î¹), f (â‡‘Ïƒ i) * g i) = s.sum (Î» (i : Î¹), f i * g i) â†” monovary_on (f âˆ˜ â‡‘Ïƒ) g â†‘s
theorem function.update_comp_eq_of_injective {Î± : Sort u} {Î±' : Sort w} [decidable_eq Î±] [decidable_eq Î±'] {Î² : Sort u_1} (g : Î±' â†’ Î²) {f : Î± â†’ Î±'} (hf : function.injective f) (i : Î±) (a : Î²) : function.update g (f i) a âˆ˜ f = function.update (g âˆ˜ f) i a
theorem continuous_at_right_of_monotone_on_of_exists_between {Î± : Type u_1} {Î² : Type u_2} [linear_order Î±] [topological_space Î±] [order_topology Î±] [linear_order Î²] [topological_space Î²] [order_topology Î²] {f : Î± â†’ Î²} {s : set Î±} {a : Î±} (h_mono : monotone_on f s) (hs : s âˆˆ nhds_within a (set.Ici a)) (hfs : âˆ€ (b : Î²), b > f a â†’ (âˆƒ (c : Î±) (H : c âˆˆ s), f c âˆˆ set.Ioo (f a) b)) : continuous_within_at f (set.Ici a) a
theorem category_theory.limits.biproduct.cone_point_unique_up_to_iso_hom {J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (f : J â†’ C) [category_theory.limits.has_biproduct f] {b : category_theory.limits.bicone f} (hb : b.is_bilimit) : (hb.is_limit.cone_point_unique_up_to_iso (category_theory.limits.biproduct.is_limit f)).hom = category_theory.limits.biproduct.lift b.Ï€
theorem phragmen_lindelof.eq_on_quadrant_III {E : Type u_1} [normed_group E] [normed_space â„‚ E] {f g : â„‚ â†’ E} (hdf : diff_cont_on_cl â„‚ f (set.Iio 0 Ã—â„‚ set.Iio 0)) (hBf : âˆƒ (c : â„) (H : c < 2) (B : â„), f =O[filter.comap complex.abs filter.at_top âŠ“ filter.principal (set.Iio 0 Ã—â„‚ set.Iio 0)] Î» (z : â„‚), real.exp (B * complex.abs z ^ c)) (hdg : diff_cont_on_cl â„‚ g (set.Iio 0 Ã—â„‚ set.Iio 0)) (hBg : âˆƒ (c : â„) (H : c < 2) (B : â„), g =O[filter.comap complex.abs filter.at_top âŠ“ filter.principal (set.Iio 0 Ã—â„‚ set.Iio 0)] Î» (z : â„‚), real.exp (B * complex.abs z ^ c)) (hre : âˆ€ (x : â„), x â‰¤ 0 â†’ f â†‘x = g â†‘x) (him : âˆ€ (x : â„), x â‰¤ 0 â†’ f (â†‘x * complex.I) = g (â†‘x * complex.I)) : set.eq_on f g {z : â„‚ | z.re â‰¤ 0 âˆ§ z.im â‰¤ 0}
theorem not_interval_integrable_of_sub_inv_is_O_punctured {F : Type u_2} [normed_group F] {f : â„ â†’ F} {a b c : â„} (hf : (Î» (x : â„), (x - c)â»Â¹) =O[nhds_within c {c}á¶œ] f) (hne : a â‰  b) (hc : c âˆˆ set.interval a b) : Â¬interval_integrable f measure_theory.measure_space.volume a b
theorem measure_theory.lintegral_with_density_eq_lintegral_mulâ‚€' {Î± : Type u_1} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {f : Î± â†’ ennreal} (hf : ae_measurable f Î¼) {g : Î± â†’ ennreal} (hg : ae_measurable g (Î¼.with_density f)) : âˆ«â» (a : Î±), g a âˆ‚Î¼.with_density f = âˆ«â» (a : Î±), (f * g) a âˆ‚Î¼
theorem add_monoid_algebra.mem_span_support {k : Type uâ‚} {G : Type uâ‚‚} [semiring k] [add_zero_class G] (f : add_monoid_algebra k G) : f âˆˆ submodule.span k (â‡‘(add_monoid_algebra.of k G) '' â†‘(f.support))
theorem category_theory.limits.mono_of_is_limit_fork {C : Type u} [category_theory.category C] {X Y : C} {f g : X âŸ¶ Y} {c : category_theory.limits.fork f g} (i : category_theory.limits.is_limit c) : category_theory.mono c.Î¹
theorem add_con.lift_comp_mk' {M : Type u_1} {P : Type u_3} [add_zero_class M] [add_zero_class P] {c : add_con M} {f : M â†’+ P} (H : c â‰¤ add_con.ker f) : (c.lift f H).comp c.mk' = f
theorem add_monoid_hom.map_finsupp_sum {Î± : Type u_1} {M : Type u_5} {N : Type u_7} {P : Type u_8} [has_zero M] [add_comm_monoid N] [add_comm_monoid P] (h : N â†’+ P) (f : Î± â†’â‚€ M) (g : Î± â†’ M â†’ N) : â‡‘h (f.sum g) = f.sum (Î» (a : Î±) (b : M), â‡‘h (g a b))
theorem zmod.Ï‡â‚ˆ'_eq_Ï‡â‚„_mul_Ï‡â‚ˆ (a : zmod 8) : â‡‘zmod.Ï‡â‚ˆ' a = â‡‘zmod.Ï‡â‚„ â†‘a * â‡‘zmod.Ï‡â‚ˆ a
theorem left.one_lt_mul' {Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a b : Î±} (ha : 1 < a) (hb : 1 < b) : 1 < a * b
theorem topological_vector_bundle_core.continuous_proj {R : Type u_1} {B : Type u_3} {F : Type u_4} [nondiscrete_normed_field R] [normed_group F] [normed_space R F] [topological_space B] {Î¹ : Type u_6} (Z : topological_vector_bundle_core R B F Î¹) : continuous Z.proj
theorem fintype.exists_ne_map_eq_of_infinite {Î± : Type u_1} {Î² : Type u_2} [infinite Î±] [fintype Î²] (f : Î± â†’ Î²) : âˆƒ (x y : Î±), x â‰  y âˆ§ f x = f y
theorem map_bit1 {F : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [non_assoc_semiring Î±] [non_assoc_semiring Î²] [ring_hom_class F Î± Î²] (f : F) (a : Î±) : â‡‘f (bit1 a) = bit1 (â‡‘f a)
theorem metric.exists_dist_lt_of_Hausdorff_dist_lt {Î± : Type u} [pseudo_metric_space Î±] {s t : set Î±} {x : Î±} {r : â„} (h : x âˆˆ s) (H : metric.Hausdorff_dist s t < r) (fin : emetric.Hausdorff_edist s t â‰  âŠ¤) : âˆƒ (y : Î±) (H : y âˆˆ t), has_dist.dist x y < r
theorem associates.eq_pow_find_of_dvd_irreducible_pow {Î± : Type u_1} [cancel_comm_monoid_with_zero Î±] [unique_factorization_monoid Î±] {a p : associates Î±} (hp : irreducible p) [Î  (n : â„•), decidable (a âˆ£ p ^ n)] {n : â„•} (h : a âˆ£ p ^ n) : a = p ^ nat.find _
theorem subsemiring.list_prod_mem {R : Type u_1} [semiring R] (s : subsemiring R) {l : list R} : (âˆ€ (x : R), x âˆˆ l â†’ x âˆˆ s) â†’ l.prod âˆˆ s
theorem continuous_linear_map.op_norm_add_le {ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_normed_group E] [semi_normed_group F] [nondiscrete_normed_field ğ•œ] [nondiscrete_normed_field ğ•œâ‚‚] [normed_space ğ•œ E] [normed_space ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} [ring_hom_isometric Ïƒâ‚â‚‚] (f g : E â†’SL[Ïƒâ‚â‚‚] F) : âˆ¥f + gâˆ¥ â‰¤ âˆ¥fâˆ¥ + âˆ¥gâˆ¥
theorem measure_theory.ae_strongly_measurable.integral_prod_right' {Î± : Type u_1} {Î² : Type u_3} {E : Type u_6} [measurable_space Î±] [measurable_space Î²] {Î¼ : measure_theory.measure Î±} {Î½ : measure_theory.measure Î²} [normed_group E] [measure_theory.sigma_finite Î½] [normed_space â„ E] [complete_space E] â¦ƒf : Î± Ã— Î² â†’ Eâ¦„ (hf : measure_theory.ae_strongly_measurable f (Î¼.prod Î½)) : measure_theory.ae_strongly_measurable (Î» (x : Î±), âˆ« (y : Î²), f (x, y) âˆ‚Î½) Î¼
theorem AddMon.filtered_colimits.colimit_add_mk_eq {J : Type v} [category_theory.small_category J] (F : J â¥¤ AddMon) [category_theory.is_filtered J] (x y : Î£ (j : J), â†¥(F.obj j)) (k : J) (f : x.fst âŸ¶ k) (g : y.fst âŸ¶ k) : AddMon.filtered_colimits.M.mk F x + AddMon.filtered_colimits.M.mk F y = AddMon.filtered_colimits.M.mk F âŸ¨k, â‡‘(F.map f) x.snd + â‡‘(F.map g) y.sndâŸ©
theorem absolute_value.exists_partition_int (n : â„•) {Îµ : â„} (hÎµ : 0 < Îµ) {b : â„¤} (hb : b â‰  0) (A : fin n â†’ â„¤) : âˆƒ (t : fin n â†’ fin âŒˆ1 / ÎµâŒ‰â‚Š), âˆ€ (iâ‚€ iâ‚ : fin n), t iâ‚€ = t iâ‚ â†’ â†‘|A iâ‚ % b - A iâ‚€ % b| < |b| â€¢ Îµ
theorem measure_theory.measure.add_haar_preimage_continuous_linear_map {E : Type u_1} [normed_group E] [normed_space â„ E] [measurable_space E] [borel_space E] [finite_dimensional â„ E] (Î¼ : measure_theory.measure E) [Î¼.is_add_haar_measure] {f : E â†’L[â„] E} (hf : â‡‘linear_map.det â†‘f â‰  0) (s : set E) : â‡‘Î¼ (â‡‘f â»Â¹' s) = ennreal.of_real |(â‡‘linear_map.det â†‘f)â»Â¹| * â‡‘Î¼ s
theorem add_monoid.is_torsion_free.not_torsion {G : Type u_1} [add_group G] [hN : nontrivial G] : add_monoid.is_torsion_free G â†’ Â¬add_monoid.is_torsion G
theorem local_homeomorph.preimage_interior {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] (e : local_homeomorph Î± Î²) (s : set Î²) : e.to_local_equiv.source âˆ© â‡‘e â»Â¹' interior s = e.to_local_equiv.source âˆ© interior (â‡‘e â»Â¹' s)
theorem mul_equiv.map_inv {G : Type u_10} {H : Type u_11} [group G] [division_monoid H] (h : G â‰ƒ* H) (x : G) : â‡‘h xâ»Â¹ = (â‡‘h x)â»Â¹
theorem same_ray.nonneg_smul_left {R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {x y : M} {r : R} (h : same_ray R x y) (hr : 0 â‰¤ r) : same_ray R (r â€¢ x) y
theorem orientation.oangle_rotation_oangle_left {V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) (x y : V) : o.oangle (â‡‘(o.rotation (o.oangle x y)) x) y = 0
theorem uniformity_has_basis_closure {Î± : Type u_1} [uniform_space Î±] : (uniformity Î±).has_basis (Î» (V : set (Î± Ã— Î±)), V âˆˆ uniformity Î±) closure
theorem finite_dimensional.finrank_eq_card_basis' {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] {Î¹ : Type w} (h : basis Î¹ K V) : â†‘(finite_dimensional.finrank K V) = cardinal.mk Î¹
theorem finsupp.coe_fn_injective {Î± : Type u_1} {M : Type u_5} [has_zero M] : function.injective coe_fn
theorem formal_multilinear_series.lt_radius_of_is_O {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field ğ•œ] [normed_group E] [normed_space ğ•œ E] [normed_group F] [normed_space ğ•œ F] (p : formal_multilinear_series ğ•œ E F) {r : nnreal} (hâ‚€ : r â‰  0) {a : â„} (ha : a âˆˆ set.Ioo (-1) 1) (hp : (Î» (n : â„•), âˆ¥p nâˆ¥ * â†‘r ^ n) =O[filter.at_top] has_pow.pow a) : â†‘r < p.radius
theorem fin.update_snoc_last {n : â„•} {Î± : fin (n + 1) â†’ Type u} (x : Î± (fin.last n)) (p : Î  (i : fin n), Î± (â‡‘fin.cast_succ i)) (z : Î± (fin.last n)) : function.update (fin.snoc p x) (fin.last n) z = fin.snoc p z
theorem exists_open_between_and_is_compact_closure {Î± : Type u} [topological_space Î±] [locally_compact_space Î±] [regular_space Î±] {K U : set Î±} (hK : is_compact K) (hU : is_open U) (hKU : K âŠ† U) : âˆƒ (V : set Î±), is_open V âˆ§ K âŠ† V âˆ§ closure V âŠ† U âˆ§ is_compact (closure V)
theorem char_p.quotient' {R : Type u_1} [comm_ring R] (p : â„•) [char_p R p] (I : ideal R) (h : âˆ€ (x : â„•), â†‘x âˆˆ I â†’ â†‘x = 0) : char_p (R â§¸ I) p
theorem is_alg_closed.is_cyclotomic_extension (K : Type u_1) [field K] [is_alg_closed K] (S : set â„•+) : is_cyclotomic_extension S K K
theorem has_subset.subset.trans {Î± : Type u} [has_subset Î±] [is_trans Î± has_subset.subset] {a b c : Î±} : a âŠ† b â†’ b âŠ† c â†’ a âŠ† c
theorem measure_theory.condexp_indicator_aux {Î± : Type u_1} {F' : Type u_7} [normed_group F'] [normed_space â„ F'] [complete_space F'] {m m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {f : Î± â†’ F'} {s : set Î±} (hm : m â‰¤ m0) (hs : measurable_set s) (hf : f =áµ[Î¼.restrict sá¶œ] 0) : measure_theory.condexp m Î¼ (s.indicator f) =áµ[Î¼] s.indicator (measure_theory.condexp m Î¼ f)
theorem circle_deg1_lift.tendsto_translation_number (f : circle_deg1_lift) (x : â„) : filter.tendsto (Î» (n : â„•), (â‡‘(f ^ n) x - x) / â†‘n) filter.at_top (nhds f.translation_number)
theorem csupr_eq_of_forall_le_of_forall_lt_exists_gt {Î± : Type u_1} {Î¹ : Sort u_3} [conditionally_complete_lattice Î±] {b : Î±} [nonempty Î¹] {f : Î¹ â†’ Î±} (hâ‚ : âˆ€ (i : Î¹), f i â‰¤ b) (hâ‚‚ : âˆ€ (w : Î±), w < b â†’ (âˆƒ (i : Î¹), w < f i)) : (â¨† (i : Î¹), f i) = b
theorem concave_on.inf {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [ordered_semiring ğ•œ] [add_comm_monoid E] [linear_ordered_add_comm_monoid Î²] [has_scalar ğ•œ E] [module ğ•œ Î²] [ordered_smul ğ•œ Î²] {s : set E} {f g : E â†’ Î²} (hf : concave_on ğ•œ s f) (hg : concave_on ğ•œ s g) : concave_on ğ•œ s (f âŠ“ g)
theorem finsupp.add_sum_erase' {Î± : Type u_1} {M : Type u_5} {N : Type u_7} [has_zero M] [add_comm_monoid N] (f : Î± â†’â‚€ M) (y : Î±) (g : Î± â†’ M â†’ N) (hg : âˆ€ (i : Î±), g i 0 = 0) : g y (â‡‘f y) + (finsupp.erase y f).sum g = f.sum g
theorem category_theory.strong_mono_comp {C : Type u} [category_theory.category C] {P Q R : C} (f : P âŸ¶ Q) (g : Q âŸ¶ R) [category_theory.strong_mono f] [category_theory.strong_mono g] : category_theory.strong_mono (f â‰« g)
theorem measure_theory.outer_measure.mk_metric_mono_smul {X : Type u_2} [emetric_space X] {mâ‚ mâ‚‚ : ennreal â†’ ennreal} {c : ennreal} (hc : c â‰  âŠ¤) (h0 : c â‰  0) (hle : mâ‚ â‰¤á¶ [nhds_within 0 (set.Ici 0)] c â€¢ mâ‚‚) : measure_theory.outer_measure.mk_metric mâ‚ â‰¤ c â€¢ measure_theory.outer_measure.mk_metric mâ‚‚
theorem measurable_of_tendsto_ennreal' {Î± : Type u_1} [measurable_space Î±] {Î¹ : Type u_2} {f : Î¹ â†’ Î± â†’ ennreal} {g : Î± â†’ ennreal} (u : filter Î¹) [u.ne_bot] [u.is_countably_generated] (hf : âˆ€ (i : Î¹), measurable (f i)) (lim : filter.tendsto f u (nhds g)) : measurable g
theorem smul_inv'' {M : Type u} [monoid M] {F : Type v} [division_ring F] [mul_semiring_action M F] (x : M) (m : F) : x â€¢ mâ»Â¹ = (x â€¢ m)â»Â¹
theorem edist_le_tsum_of_edist_le_of_tendsto {Î± : Type u_1} [pseudo_emetric_space Î±] {f : â„• â†’ Î±} (d : â„• â†’ ennreal) (hf : âˆ€ (n : â„•), has_edist.edist (f n) (f n.succ) â‰¤ d n) {a : Î±} (ha : filter.tendsto f filter.at_top (nhds a)) (n : â„•) : has_edist.edist (f n) a â‰¤ âˆ‘' (m : â„•), d (n + m)
theorem measure_theory.measure.add_haar_preimage_linear_equiv {E : Type u_1} [normed_group E] [normed_space â„ E] [measurable_space E] [borel_space E] [finite_dimensional â„ E] (Î¼ : measure_theory.measure E) [Î¼.is_add_haar_measure] (f : E â‰ƒâ‚—[â„] E) (s : set E) : â‡‘Î¼ (â‡‘f â»Â¹' s) = ennreal.of_real |â‡‘linear_map.det â†‘(f.symm)| * â‡‘Î¼ s
theorem category_theory.category_of_elements.to_from_costructured_arrow_eq {C : Type u} [category_theory.category C] (F : Cáµ’áµ– â¥¤ Type v) : (category_theory.category_of_elements.from_costructured_arrow F).right_op â‹™ category_theory.category_of_elements.to_costructured_arrow F = ğŸ­ (category_theory.costructured_arrow category_theory.yoneda F)
theorem probability_theory.cond_is_probability_measure {Î± : Type u_1} {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) {s : set Î±} [measure_theory.is_finite_measure Î¼] (hcs : â‡‘Î¼ s â‰  0) : measure_theory.is_probability_measure (probability_theory.cond Î¼ s)
theorem orientation.two_zsmul_oangle_neg_self_right {V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) (x : V) : 2 â€¢ o.oangle x (-x) = 0
theorem monoid_with_zero_hom.ext_int {M : Type u_1} [monoid_with_zero M] {f g : â„¤ â†’*â‚€ M} (h_neg_one : â‡‘f (-1) = â‡‘g (-1)) (h_nat : f.comp int.of_nat_hom.to_monoid_with_zero_hom = g.comp int.of_nat_hom.to_monoid_with_zero_hom) : f = g
theorem normed_group_hom.op_norm_le_bound {Vâ‚ : Type u_2} {Vâ‚‚ : Type u_3} [semi_normed_group Vâ‚] [semi_normed_group Vâ‚‚] (f : normed_group_hom Vâ‚ Vâ‚‚) {M : â„} (hMp : 0 â‰¤ M) (hM : âˆ€ (x : Vâ‚), âˆ¥â‡‘f xâˆ¥ â‰¤ M * âˆ¥xâˆ¥) : âˆ¥fâˆ¥ â‰¤ M
theorem set.image_id' {Î± : Type u} (s : set Î±) : (Î» (x : Î±), x) '' s = s
theorem inner_product_geometry.angle_zero_left {V : Type u_1} [inner_product_space â„ V] (x : V) : inner_product_geometry.angle 0 x = real.pi / 2
theorem fin.strict_mono_unique {n : â„•} {Î± : Type u_1} [preorder Î±] {f g : fin n â†’ Î±} (hf : strict_mono f) (hg : strict_mono g) (h : set.range f = set.range g) : f = g
theorem is_square_of_char_two' {R : Type u_1} [fintype R] [comm_ring R] [is_reduced R] [char_p R 2] (a : R) : is_square a
theorem measure_theory.measure.restrict_apply' {Î± : Type u_1} {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {s t : set Î±} (hs : measurable_set s) : â‡‘(Î¼.restrict s) t = â‡‘Î¼ (t âˆ© s)
theorem asymptotics.is_O_iff_eventually {Î± : Type u_1} {E : Type u_3} {F' : Type u_7} [has_norm E] [semi_normed_group F'] {f : Î± â†’ E} {g' : Î± â†’ F'} {l : filter Î±} : f =O[l] g' â†” âˆ€á¶  (c : â„) in filter.at_top, âˆ€á¶  (x : Î±) in l, âˆ¥f xâˆ¥ â‰¤ c * âˆ¥g' xâˆ¥
theorem submodule.infi_orthogonal {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {Î¹ : Type u_3} (K : Î¹ â†’ submodule ğ•œ E) : (â¨… (i : Î¹), (K i)á—®) = (supr K)á—®
theorem mem_adjoin_of_smul_prime_pow_smul_of_minpoly_is_eiseinstein_at {R : Type u} {K : Type v} {L : Type z} {p : R} [comm_ring R] [field K] [field L] [algebra K L] [algebra R L] [algebra R K] [is_scalar_tower R K L] [is_separable K L] [is_domain R] [normalized_gcd_monoid R] [is_fraction_ring R K] [is_integrally_closed R] {B : power_basis K L} (hp : prime p) (hBint : is_integral R B.gen) {n : â„•} {z : L} (hzint : is_integral R z) (hz : p ^ n â€¢ z âˆˆ algebra.adjoin R {B.gen}) (hei : (minpoly R B.gen).is_eisenstein_at (submodule.span R {p})) : z âˆˆ algebra.adjoin R {B.gen}
theorem metric.bounded_range_iff {Î± : Type u} {Î² : Type v} [pseudo_metric_space Î±] {f : Î² â†’ Î±} : metric.bounded (set.range f) â†” âˆƒ (C : â„), âˆ€ (x y : Î²), has_dist.dist (f x) (f y) â‰¤ C
theorem matrix.pow_eq_aeval_mod_charpoly {R : Type u} [comm_ring R] {n : Type v} [decidable_eq n] [fintype n] (M : matrix n n R) (k : â„•) : M ^ k = â‡‘(polynomial.aeval M) (polynomial.X ^ k %â‚˜ M.charpoly)
theorem finset.induction_on_min {Î± : Type u_1} [linear_order Î±] [decidable_eq Î±] {p : finset Î± â†’ Prop} (s : finset Î±) (h0 : p âˆ…) (step : âˆ€ (a : Î±) (s : finset Î±), (âˆ€ (x : Î±), x âˆˆ s â†’ a < x) â†’ p s â†’ p (has_insert.insert a s)) : p s
theorem category_theory.normal_epi_category.has_colimit_parallel_pair {C : Type u_1} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_finite_coproducts C] [category_theory.limits.has_cokernels C] [category_theory.normal_epi_category C] {X Y : C} (f g : X âŸ¶ Y) : category_theory.limits.has_colimit (category_theory.limits.parallel_pair f g)
theorem affine_independent.affine_span_eq_top_iff_card_eq_finrank_add_one {k : Type u_1} {V : Type u_2} {P : Type u_3} {Î¹ : Type u_4} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] [finite_dimensional k V] [fintype Î¹] {p : Î¹ â†’ P} (hi : affine_independent k p) : affine_span k (set.range p) = âŠ¤ â†” fintype.card Î¹ = finite_dimensional.finrank k V + 1
theorem euclidean_geometry.angle_midpoint_eq_pi {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] (p1 p2 : P) (hp1p2 : p1 â‰  p2) : euclidean_geometry.angle p1 (midpoint â„ p1 p2) p2 = real.pi
theorem fixed_points_submonoid_sup (M : Type u_1) (Î± : Type u_2) [monoid M] [mul_action M Î±] {P Q : submonoid M} : mul_action.fixed_points â†¥(P âŠ” Q) Î± = mul_action.fixed_points â†¥P Î± âˆ© mul_action.fixed_points â†¥Q Î±
theorem set.center_units_eq {M : Type u_1} [group_with_zero M] : set.center MË£ = coe â»Â¹' set.center M
theorem measure_theory.outer_measure.is_metric.finset_Union_of_pairwise_separated {Î¹ : Type u_1} {X : Type u_2} [emetric_space X] {Î¼ : measure_theory.outer_measure X} (hm : Î¼.is_metric) {I : finset Î¹} {s : Î¹ â†’ set X} (hI : âˆ€ (i : Î¹), i âˆˆ I â†’ âˆ€ (j : Î¹), j âˆˆ I â†’ i â‰  j â†’ is_metric_separated (s i) (s j)) : â‡‘Î¼ (â‹ƒ (i : Î¹) (H : i âˆˆ I), s i) = I.sum (Î» (i : Î¹), â‡‘Î¼ (s i))
theorem list.nth_of_fn {Î± : Type u} {n : â„•} (f : fin n â†’ Î±) (i : â„•) : (list.of_fn f).nth i = list.of_fn_nth_val f i
theorem tendsto_pow_const_mul_const_pow_of_abs_lt_one (k : â„•) {r : â„} (hr : |r| < 1) : filter.tendsto (Î» (n : â„•), â†‘n ^ k * r ^ n) filter.at_top (nhds 0)
theorem norm_add_pow_two {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {x y : E} : âˆ¥x + yâˆ¥ ^ 2 = âˆ¥xâˆ¥ ^ 2 + 2 * â‡‘is_R_or_C.re (has_inner.inner x y) + âˆ¥yâˆ¥ ^ 2
theorem real_inner_div_norm_mul_norm_eq_one_iff {F : Type u_3} [inner_product_space â„ F] (x y : F) : has_inner.inner x y / (âˆ¥xâˆ¥ * âˆ¥yâˆ¥) = 1 â†” x â‰  0 âˆ§ âˆƒ (r : â„), 0 < r âˆ§ y = r â€¢ x
theorem bump_covering.exists_is_subordinate_of_prop {Î¹ : Type u} {X : Type v} [topological_space X] {s : set X} [normal_space X] [paracompact_space X] (p : (X â†’ â„) â†’ Prop) (h01 : âˆ€ (s t : set X), is_closed s â†’ is_closed t â†’ disjoint s t â†’ (âˆƒ (f : C(X, â„)), p â‡‘f âˆ§ set.eq_on â‡‘f 0 s âˆ§ set.eq_on â‡‘f 1 t âˆ§ âˆ€ (x : X), â‡‘f x âˆˆ set.Icc 0 1)) (hs : is_closed s) (U : Î¹ â†’ set X) (ho : âˆ€ (i : Î¹), is_open (U i)) (hU : s âŠ† â‹ƒ (i : Î¹), U i) : âˆƒ (f : bump_covering Î¹ X s), (âˆ€ (i : Î¹), p â‡‘(â‡‘f i)) âˆ§ f.is_subordinate U
theorem pfun.fix_fwd {Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’. Î² âŠ• Î±} (a a' : Î±) (ha' : sum.inr a' âˆˆ f a) : f.fix a = f.fix a'
theorem is_closed_fixed_points {Î± : Type u_1} [topological_space Î±] [t2_space Î±] {f : Î± â†’ Î±} (hf : continuous f) : is_closed (function.fixed_points f)
theorem is_preconnected.convex {s : set â„} : is_preconnected s â†’ convex â„ s
theorem circle_deg1_lift.units_semiconj_of_translation_number_eq {fâ‚ fâ‚‚ : circle_deg1_liftË£} (h : â†‘fâ‚.translation_number = â†‘fâ‚‚.translation_number) : âˆƒ (F : circle_deg1_lift), function.semiconj â‡‘F â‡‘fâ‚ â‡‘fâ‚‚
theorem add_con.ker_rel {M : Type u_1} {P : Type u_3} [add_zero_class M] [add_zero_class P] (f : M â†’+ P) {x y : M} : â‡‘(add_con.ker f) x y â†” â‡‘f x = â‡‘f y
theorem category_theory.eq_to_hom_map {C : Type uâ‚} [category_theory.category C] {D : Type uâ‚‚} [category_theory.category D] (F : C â¥¤ D) {X Y : C} (p : X = Y) : F.map (category_theory.eq_to_hom p) = category_theory.eq_to_hom _
theorem measure_theory.map_with_density_abs_det_fderiv_eq_add_haar {E : Type u_1} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] {s : set E} {f : E â†’ E} {f' : E â†’ (E â†’L[â„] E)} [measurable_space E] [borel_space E] (Î¼ : measure_theory.measure E) [Î¼.is_add_haar_measure] (hs : measurable_set s) (hf' : âˆ€ (x : E), x âˆˆ s â†’ has_fderiv_within_at f (f' x) s x) (hf : set.inj_on f s) (h'f : measurable f) : measure_theory.measure.map f ((Î¼.restrict s).with_density (Î» (x : E), ennreal.of_real |(f' x).det|)) = Î¼.restrict (f '' s)
theorem con.Inf_to_setoid {M : Type u_1} [has_mul M] (S : set (con M)) : (has_Inf.Inf S).to_setoid = has_Inf.Inf (con.to_setoid '' S)
theorem filter.at_top_Ioi_eq {Î± : Type u_3} [semilattice_sup Î±] (a : Î±) : filter.at_top = filter.comap coe filter.at_top
theorem tsum_mul_tsum_eq_tsum_sum_range_of_summable_norm {Î± : Type u_1} [normed_ring Î±] [complete_space Î±] {f g : â„• â†’ Î±} (hf : summable (Î» (x : â„•), âˆ¥f xâˆ¥)) (hg : summable (Î» (x : â„•), âˆ¥g xâˆ¥)) : (âˆ‘' (n : â„•), f n) * âˆ‘' (n : â„•), g n = âˆ‘' (n : â„•), (finset.range (n + 1)).sum (Î» (k : â„•), f k * g (n - k))
theorem real.tendsto_sum_range_one_div_nat_succ_at_top  : filter.tendsto (Î» (n : â„•), (finset.range n).sum (Î» (i : â„•), 1 / (â†‘i + 1))) filter.at_top filter.at_top
theorem unique_factorization_monoid.factors_eq_normalized_factors {M : Type u_1} [cancel_comm_monoid_with_zero M] [decidable_eq M] [unique_factorization_monoid M] [unique MË£] (x : M) : unique_factorization_monoid.factors x = unique_factorization_monoid.normalized_factors x
theorem function.update_comp_eq_of_not_mem_range {Î± : Sort u_1} {Î² : Type u_2} {Î³ : Sort u_3} [decidable_eq Î²] (g : Î² â†’ Î³) {f : Î± â†’ Î²} {i : Î²} (a : Î³) (h : i âˆ‰ set.range f) : function.update g i a âˆ˜ f = g âˆ˜ f
theorem map_exp_of_mem_ball {ğ•‚ : Type u_1} {ğ”¸ : Type u_2} {ğ”¹ : Type u_3} [nondiscrete_normed_field ğ•‚] [normed_ring ğ”¸] [normed_ring ğ”¹] [normed_algebra ğ•‚ ğ”¸] [normed_algebra ğ•‚ ğ”¹] [complete_space ğ”¸] {F : Type u_4} [ring_hom_class F ğ”¸ ğ”¹] (f : F) (hf : continuous â‡‘f) (x : ğ”¸) (hx : x âˆˆ emetric.ball 0 (exp_series ğ•‚ ğ”¸).radius) : â‡‘f (exp ğ•‚ x) = exp ğ•‚ (â‡‘f x)
theorem convex.is_preconnected {s : set â„} : convex â„ s â†’ is_preconnected s
theorem filter.tendsto_at_top_at_top {Î± : Type u_3} {Î² : Type u_4} [nonempty Î±] [semilattice_sup Î±] [preorder Î²] {f : Î± â†’ Î²} : filter.tendsto f filter.at_top filter.at_top â†” âˆ€ (b : Î²), âˆƒ (i : Î±), âˆ€ (a : Î±), i â‰¤ a â†’ b â‰¤ f a
theorem subsemiring.ext {R : Type u} [non_assoc_semiring R] {S T : subsemiring R} (h : âˆ€ (x : R), x âˆˆ S â†” x âˆˆ T) : S = T
theorem exists_forall_deriv_within_Icc_eq_of_lipschitz_of_continuous {E : Type u_1} [normed_group E] [normed_space â„ E] [complete_space E] {v : â„ â†’ E â†’ E} {t_min tâ‚€ t_max : â„} (htâ‚€ : tâ‚€ âˆˆ set.Icc t_min t_max) (xâ‚€ : E) {C R : â„} (hR : 0 â‰¤ R) {L : nnreal} (Hlip : âˆ€ (t : â„), t âˆˆ set.Icc t_min t_max â†’ lipschitz_on_with L (v t) (metric.closed_ball xâ‚€ R)) (Hcont : âˆ€ (x : E), x âˆˆ metric.closed_ball xâ‚€ R â†’ continuous_on (Î» (t : â„), v t x) (set.Icc t_min t_max)) (Hnorm : âˆ€ (t : â„), t âˆˆ set.Icc t_min t_max â†’ âˆ€ (x : E), x âˆˆ metric.closed_ball xâ‚€ R â†’ âˆ¥v t xâˆ¥ â‰¤ C) (Hmul_le : C * linear_order.max (t_max - tâ‚€) (tâ‚€ - t_min) â‰¤ R) : âˆƒ (f : â„ â†’ E), f tâ‚€ = xâ‚€ âˆ§ âˆ€ (t : â„), t âˆˆ set.Icc t_min t_max â†’ has_deriv_within_at f (v t (f t)) (set.Icc t_min t_max) t
theorem real.diam_eq {s : set â„} (h : metric.bounded s) : metric.diam s = has_Sup.Sup s - has_Inf.Inf s
theorem is_primitive_root.card_nth_roots {R : Type u_5} [comm_ring R] [is_domain R] {Î¶ : R} {n : â„•} (h : is_primitive_root Î¶ n) : â‡‘multiset.card (polynomial.nth_roots n 1) = n
theorem category_theory.is_filtered.tulip {C : Type u} [category_theory.category C] [category_theory.is_filtered C] {jâ‚ jâ‚‚ jâ‚ƒ kâ‚ kâ‚‚ l : C} (fâ‚ : jâ‚ âŸ¶ kâ‚) (fâ‚‚ : jâ‚‚ âŸ¶ kâ‚) (fâ‚ƒ : jâ‚‚ âŸ¶ kâ‚‚) (fâ‚„ : jâ‚ƒ âŸ¶ kâ‚‚) (gâ‚ : jâ‚ âŸ¶ l) (gâ‚‚ : jâ‚ƒ âŸ¶ l) : âˆƒ (s : C) (Î± : kâ‚ âŸ¶ s) (Î² : l âŸ¶ s) (Î³ : kâ‚‚ âŸ¶ s), fâ‚ â‰« Î± = gâ‚ â‰« Î² âˆ§ fâ‚‚ â‰« Î± = fâ‚ƒ â‰« Î³ âˆ§ fâ‚„ â‰« Î³ = gâ‚‚ â‰« Î²
theorem finset.mul_prod_erase {Î² : Type u} {Î± : Type v} [comm_monoid Î²] [decidable_eq Î±] (s : finset Î±) (f : Î± â†’ Î²) {a : Î±} (h : a âˆˆ s) : f a * (s.erase a).prod (Î» (x : Î±), f x) = s.prod (Î» (x : Î±), f x)
theorem topological_fiber_bundle_core.is_topological_fiber_bundle {Î¹ : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core Î¹ B F) : is_topological_fiber_bundle F Z.proj
theorem has_le.le.dual {Î± : Type u_1} [has_le Î±] {a b : Î±} : b â‰¤ a â†’ â‡‘order_dual.to_dual a â‰¤ â‡‘order_dual.to_dual b
theorem uniform_space.completion.eq_of_dist_eq_zero {Î± : Type u} [pseudo_metric_space Î±] (x y : uniform_space.completion Î±) (h : has_dist.dist x y = 0) : x = y
theorem prod_induced_induced {Î² : Type v} {Î´ : Type u_2} [topological_space Î²] [topological_space Î´] {Î± : Type u_1} {Î³ : Type u_3} (f : Î± â†’ Î²) (g : Î³ â†’ Î´) : prod.topological_space = topological_space.induced (Î» (p : Î± Ã— Î³), (f p.fst, g p.snd)) prod.topological_space
theorem pgame.zero_mul_equiv (x : pgame) : (0 * x).equiv 0
theorem euclidean_geometry.dist_eq_abs_sub_dist_iff_angle_eq_zero {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {p1 p2 p3 : P} (hp1p2 : p1 â‰  p2) (hp3p2 : p3 â‰  p2) : has_dist.dist p1 p3 = |has_dist.dist p1 p2 - has_dist.dist p3 p2| â†” euclidean_geometry.angle p1 p2 p3 = 0
theorem W_type.cardinal_mk_le_max_aleph_0_of_fintype {Î± : Type u} {Î² : Î± â†’ Type u} [Î  (a : Î±), fintype (Î² a)] : cardinal.mk (W_type Î²) â‰¤ linear_order.max (cardinal.mk Î±) cardinal.aleph_0
theorem exists_cont_diff_bump_function_of_mem_nhds {E : Type u_1} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] {x : E} {s : set E} (hs : s âˆˆ nhds x) : âˆƒ (f : E â†’ â„), f =á¶ [nhds x] 1 âˆ§ (âˆ€ (y : E), f y âˆˆ set.Icc 0 1) âˆ§ cont_diff â„ âŠ¤ f âˆ§ has_compact_support f âˆ§ tsupport f âŠ† s
theorem ray_pos_smul {R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {v : M} (h : v â‰  0) {r : R} (hr : 0 < r) (hrv : r â€¢ v â‰  0) : ray_of_ne_zero R (r â€¢ v) hrv = ray_of_ne_zero R v h
theorem category_theory.cover_dense.types.pushforward_family_compatible {C : Type u_1} [category_theory.category C] {D : Type u_3} [category_theory.category D] {K : category_theory.grothendieck_topology D} {G : C â¥¤ D} (H : category_theory.cover_dense K G) [category_theory.full G] {â„± : Dáµ’áµ– â¥¤ Type v} {â„±' : category_theory.SheafOfTypes K} (Î± : G.op â‹™ â„± âŸ¶ G.op â‹™ â„±'.val) {X : D} (x : â„±.obj (opposite.op X)) : (category_theory.cover_dense.types.pushforward_family H Î± x).compatible
theorem mem_nhds_within_Ioi_iff_exists_Ioo_subset {Î± : Type u} [topological_space Î±] [linear_order Î±] [order_topology Î±] [no_max_order Î±] {a : Î±} {s : set Î±} : s âˆˆ nhds_within a (set.Ioi a) â†” âˆƒ (u : Î±) (H : u âˆˆ set.Ioi a), set.Ioo a u âŠ† s
theorem with_top.prod_lt_top {Î¹ : Type u_1} {R : Type u_8} [canonically_ordered_comm_semiring R] [nontrivial R] [decidable_eq R] {s : finset Î¹} {f : Î¹ â†’ with_top R} (h : âˆ€ (i : Î¹), i âˆˆ s â†’ f i â‰  âŠ¤) : s.prod (Î» (i : Î¹), f i) < âŠ¤
theorem basis.det_units_smul {R : Type u_1} [comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {Î¹ : Type u_4} [decidable_eq Î¹] [fintype Î¹] (e : basis Î¹ R M) (w : Î¹ â†’ RË£) : â‡‘(e.det) â‡‘(e.units_smul w) = finset.univ.prod (Î» (i : Î¹), â†‘(w i))
theorem antivary.sum_smul_le_sum_comp_perm_smul {Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [linear_ordered_ring Î±] [linear_ordered_add_comm_group Î²] [module Î± Î²] [ordered_smul Î± Î²] {Ïƒ : equiv.perm Î¹} {f : Î¹ â†’ Î±} {g : Î¹ â†’ Î²} [fintype Î¹] (hfg : antivary f g) : finset.univ.sum (Î» (i : Î¹), f i â€¢ g i) â‰¤ finset.univ.sum (Î» (i : Î¹), f (â‡‘Ïƒ i) â€¢ g i)
theorem charted_space.locally_compact (H : Type u) (M : Type u_2) [topological_space H] [topological_space M] [charted_space H M] [locally_compact_space H] : locally_compact_space M
theorem not_or_distrib {a b : Prop} : Â¬(a âˆ¨ b) â†” Â¬a âˆ§ Â¬b
theorem modular_group.eq_smul_self_of_mem_fdo_mem_fdo {g : matrix.special_linear_group (fin 2) â„¤} {z : upper_half_plane} (hz : z âˆˆ modular_group.fdo) (hg : g â€¢ z âˆˆ modular_group.fdo) : z = g â€¢ z
theorem finset.prod_ite_eq' {Î² : Type u} {Î± : Type v} [comm_monoid Î²] [decidable_eq Î±] (s : finset Î±) (a : Î±) (b : Î± â†’ Î²) : s.prod (Î» (x : Î±), ite (x = a) (b x) 1) = ite (a âˆˆ s) (b a) 1
theorem no_zero_smul_divisors.of_algebra_map_injective {R : Type u_1} {A : Type u_2} [comm_semiring R] [semiring A] [algebra R A] [no_zero_divisors A] (h : function.injective â‡‘(algebra_map R A)) : no_zero_smul_divisors R A
theorem cardinal.lift_sup {Î¹ : Type v} (f : Î¹ â†’ cardinal) : (cardinal.sup f).lift = cardinal.sup (Î» (i : Î¹), (f i).lift)
theorem algebraic_geometry.Scheme.pullback.lift_comp_Î¹ {X Y Z : algebraic_geometry.Scheme} (ğ’° : X.open_cover) (f : X âŸ¶ Z) (g : Y âŸ¶ Z) [âˆ€ (i : ğ’°.J), category_theory.limits.has_pullback (ğ’°.map i â‰« f) g] (i : ğ’°.J) : category_theory.limits.pullback.lift category_theory.limits.pullback.snd (category_theory.limits.pullback.fst â‰« algebraic_geometry.Scheme.pullback.p2 ğ’° f g) _ â‰« (algebraic_geometry.Scheme.pullback.gluing ğ’° f g).Î¹ i = category_theory.limits.pullback.fst
theorem list.nth_le_join {Î± : Type u_1} (L : list (list Î±)) {i j : â„•} (hi : i < L.length) (hj : j < (L.nth_le i hi).length) : L.join.nth_le ((list.take i (list.map list.length L)).sum + j) _ = (L.nth_le i hi).nth_le j hj
theorem asymptotics.is_O.of_neg_left {Î± : Type u_1} {F : Type u_4} {E' : Type u_6} [has_norm F] [semi_normed_group E'] {g : Î± â†’ F} {f' : Î± â†’ E'} {l : filter Î±} : (Î» (x : Î±), -f' x) =O[l] g â†’ f' =O[l] g
theorem category_theory.transfer_nat_trans_self_symm_of_iso {C : Type uâ‚} {D : Type uâ‚‚} [category_theory.category C] [category_theory.category D] {Lâ‚ Lâ‚‚ : C â¥¤ D} {Râ‚ Râ‚‚ : D â¥¤ C} (adjâ‚ : Lâ‚ âŠ£ Râ‚) (adjâ‚‚ : Lâ‚‚ âŠ£ Râ‚‚) (f : Râ‚ âŸ¶ Râ‚‚) [category_theory.is_iso (â‡‘((category_theory.transfer_nat_trans_self adjâ‚ adjâ‚‚).symm) f)] : category_theory.is_iso f
theorem game.not_lf {x y : game} : Â¬x.lf y â†” y â‰¤ x
theorem set.sized.shadow {Î± : Type u_1} [decidable_eq Î±] {ğ’œ : finset (finset Î±)} {r : â„•} (hğ’œ : set.sized r â†‘ğ’œ) : set.sized (r - 1) â†‘(ğ’œ.shadow)
theorem eq_orthogonal_projection_of_eq_submodule {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {K : submodule ğ•œ E} [complete_space â†¥K] {K' : submodule ğ•œ E} [complete_space â†¥K'] (h : K = K') (u : E) : â†‘(â‡‘(orthogonal_projection K) u) = â†‘(â‡‘(orthogonal_projection K') u)
theorem is_add_submonoid.list_sum_mem {M : Type u_1} [add_monoid M] {s : set M} (hs : is_add_submonoid s) {l : list M} : (âˆ€ (x : M), x âˆˆ l â†’ x âˆˆ s) â†’ l.sum âˆˆ s
theorem affine_span_insert_affine_span (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (p : P) (ps : set P) : affine_span k (has_insert.insert p â†‘(affine_span k ps)) = affine_span k (has_insert.insert p ps)
theorem representation.char_conj {k : Type u_1} {G : Type u_2} {V : Type u_3} [comm_ring k] [group G] [add_comm_group V] [module k V] (Ï : representation k G V) (g h : G) : Ï.character (h * g * hâ»Â¹) = Ï.character g
theorem finite_dimensional_vector_span_of_finite (k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : set P} (h : s.finite) : finite_dimensional k â†¥(vector_span k s)
theorem add_monoid.image_closure {M : Type u_1} [add_monoid M] {A : Type u_2} [add_monoid A] {f : M â†’ A} (hf : is_add_monoid_hom f) (s : set M) : f '' add_monoid.closure s = add_monoid.closure (f '' s)
theorem measure_theory.outer_measure.trim_add {Î± : Type u_1} [measurable_space Î±] (mâ‚ mâ‚‚ : measure_theory.outer_measure Î±) : (mâ‚ + mâ‚‚).trim = mâ‚.trim + mâ‚‚.trim
theorem mul_action.card_eq_sum_card_group_div_card_stabilizer (Î± : Type u) (Î² : Type v) [group Î±] [mul_action Î± Î²] [fintype Î±] [fintype Î²] [fintype (quotient (mul_action.orbit_rel Î± Î²))] [Î  (b : Î²), fintype â†¥(mul_action.stabilizer Î± b)] : fintype.card Î² = finset.univ.sum (Î» (Ï‰ : quotient (mul_action.orbit_rel Î± Î²)), fintype.card Î± / fintype.card â†¥(mul_action.stabilizer Î± Ï‰.out'))
theorem finset.exists_ne_map_eq_of_card_lt_of_maps_to {Î± : Type u_1} {Î² : Type u_2} {s : finset Î±} {t : finset Î²} (hc : t.card < s.card) {f : Î± â†’ Î²} (hf : âˆ€ (a : Î±), a âˆˆ s â†’ f a âˆˆ t) : âˆƒ (x : Î±) (H : x âˆˆ s) (y : Î±) (H : y âˆˆ s), x â‰  y âˆ§ f x = f y
theorem is_artinian.surjective_of_injective_endomorphism {R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] [is_artinian R M] (f : M â†’â‚—[R] M) (s : function.injective â‡‘f) : function.surjective â‡‘f
theorem algebraic_topology.dold_kan.HÏƒ_eq_zero {C : Type u_1} [category_theory.category C] [category_theory.preadditive C] {X : category_theory.simplicial_object C} (q : â„•) : (algebraic_topology.dold_kan.HÏƒ q).f 0 = 0
theorem box_integral.has_integral_of_le_Henstock_of_forall_is_o {Î¹ : Type u} {E : Type v} {F : Type w} [normed_group E] [normed_space â„ E] [normed_group F] [normed_space â„ F] {I : box_integral.box Î¹} [fintype Î¹] {l : box_integral.integration_params} {f : (Î¹ â†’ â„) â†’ E} {vol : box_integral.box_additive_map Î¹ (E â†’L[â„] F) âŠ¤} (hl : l â‰¤ box_integral.integration_params.Henstock) (B : box_integral.box_additive_map Î¹ â„ â†‘I) (hB0 : âˆ€ (J : box_integral.box Î¹), 0 â‰¤ â‡‘B J) (g : box_integral.box_additive_map Î¹ F â†‘I) (s : set (Î¹ â†’ â„)) (hs : s.countable) (Hâ‚ : âˆ€ (c : nnreal) (x : Î¹ â†’ â„), x âˆˆ â‡‘box_integral.box.Icc I âˆ© s â†’ âˆ€ (Îµ : â„), Îµ > 0 â†’ (âˆƒ (Î´ : â„) (H : Î´ > 0), âˆ€ (J : box_integral.box Î¹), J â‰¤ I â†’ â‡‘box_integral.box.Icc J âŠ† metric.closed_ball x Î´ â†’ x âˆˆ â‡‘box_integral.box.Icc J â†’ (â†¥(l.bDistortion) â†’ J.distortion â‰¤ c) â†’ has_dist.dist (â‡‘(â‡‘vol J) (f x)) (â‡‘g J) â‰¤ Îµ)) (Hâ‚‚ : âˆ€ (c : nnreal) (x : Î¹ â†’ â„), x âˆˆ â‡‘box_integral.box.Icc I  s â†’ âˆ€ (Îµ : â„), Îµ > 0 â†’ (âˆƒ (Î´ : â„) (H : Î´ > 0), âˆ€ (J : box_integral.box Î¹), J â‰¤ I â†’ â‡‘box_integral.box.Icc J âŠ† metric.closed_ball x Î´ â†’ x âˆˆ â‡‘box_integral.box.Icc J â†’ (â†¥(l.bDistortion) â†’ J.distortion â‰¤ c) â†’ has_dist.dist (â‡‘(â‡‘vol J) (f x)) (â‡‘g J) â‰¤ Îµ * â‡‘B J)) : box_integral.has_integral I l f vol (â‡‘g I)
theorem set.prod_subset_prod_iff {Î± : Type u_1} {Î² : Type u_2} {s sâ‚ : set Î±} {t tâ‚ : set Î²} : s Ã—Ë¢ t âŠ† sâ‚ Ã—Ë¢ tâ‚ â†” s âŠ† sâ‚ âˆ§ t âŠ† tâ‚ âˆ¨ s = âˆ… âˆ¨ t = âˆ…
theorem ring_hom.domain_local_ring {R : Type u_1} {S : Type u_2} [comm_semiring R] [comm_semiring S] [H : local_ring S] (f : R â†’+* S) [is_local_ring_hom f] : local_ring R
theorem nat.prod_pow_pos_of_zero_not_mem_support {f : â„• â†’â‚€ â„•} (hf : 0 âˆ‰ f.support) : 0 < f.prod has_pow.pow
theorem dGamma_integral_abs_convergent (s : â„) (hs : 1 < s) : measure_theory.integrable_on (Î» (x : â„), âˆ¥real.exp (-x) * real.log x * x ^ (s - 1)âˆ¥) (set.Ioi 0) measure_theory.measure_space.volume
theorem finset.sum_product_right' {Î² : Type u} {Î± : Type v} {Î³ : Type w} [add_comm_monoid Î²] {s : finset Î³} {t : finset Î±} {f : Î³ â†’ Î± â†’ Î²} : (s.product t).sum (Î» (x : Î³ Ã— Î±), f x.fst x.snd) = t.sum (Î» (y : Î±), s.sum (Î» (x : Î³), f x y))
theorem modular_group.norm_sq_S_smul_lt_one {z : upper_half_plane} (h : 1 < â‡‘complex.norm_sq â†‘z) : â‡‘complex.norm_sq â†‘(modular_group.S â€¢ z) < 1
theorem self_adjoint.mem_spectrum_eq_re {A : Type u_1} [normed_ring A] [normed_algebra â„‚ A] [complete_space A] [star_ring A] [cstar_ring A] [star_module â„‚ A] [nontrivial A] {a : A} (ha : a âˆˆ self_adjoint A) {z : â„‚} (hz : z âˆˆ spectrum â„‚ a) : z = â†‘(z.re)
theorem linear_map.pi_apply_eq_sum_univ {R : Type u_1} {M : Type u_9} {Î¹ : Type u_17} [semiring R] [add_comm_monoid M] [module R M] [fintype Î¹] [decidable_eq Î¹] (f : (Î¹ â†’ R) â†’â‚—[R] M) (x : Î¹ â†’ R) : â‡‘f x = finset.univ.sum (Î» (i : Î¹), x i â€¢ â‡‘f (Î» (j : Î¹), ite (i = j) 1 0))
theorem continuous_on_of_locally_uniform_approx_of_continuous_within_at {Î± : Type u_1} {Î² : Type u_2} [uniform_space Î²] {f : Î± â†’ Î²} {s : set Î±} [topological_space Î±] (L : âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (u : set (Î² Ã— Î²)), u âˆˆ uniformity Î² â†’ (âˆƒ (t : set Î±) (H : t âˆˆ nhds_within x s) (F : Î± â†’ Î²), continuous_within_at F s x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u)) : continuous_on f s
theorem dense_sInter_of_GÎ´ {Î± : Type u_1} [topological_space Î±] [baire_space Î±] {S : set (set Î±)} (ho : âˆ€ (s : set Î±), s âˆˆ S â†’ is_GÎ´ s) (hS : S.countable) (hd : âˆ€ (s : set Î±), s âˆˆ S â†’ dense s) : dense (â‹‚â‚€ S)
theorem category_theory.glue_data.Î¹_jointly_surjective {C : Type uâ‚} [category_theory.category C] (D : category_theory.glue_data C) [category_theory.limits.has_multicoequalizer D.diagram] (F : C â¥¤ Type v) [category_theory.limits.preserves_colimit D.diagram.multispan F] [Î  (i j k : D.J), category_theory.limits.preserves_limit (category_theory.limits.cospan (D.f i j) (D.f i k)) F] (x : F.obj D.glued) : âˆƒ (i : D.J) (y : F.obj (D.U i)), F.map (D.Î¹ i) y = x
theorem interval_integral.measure_integral_sub_linear_is_o_of_tendsto_ae' {Î¹ : Type u_1} {E : Type u_3} [normed_group E] [complete_space E] [normed_space â„ E] {f : â„ â†’ E} {c : E} {l l' : filter â„} {lt : filter Î¹} {Î¼ : measure_theory.measure â„} {u v : Î¹ â†’ â„} [l'.is_measurably_generated] [filter.tendsto_Ixx_class set.Ioc l l'] (hfm : strongly_measurable_at_filter f l' Î¼) (hf : filter.tendsto f (l' âŠ“ Î¼.ae) (nhds c)) (hl : Î¼.finite_at_filter l') (hu : filter.tendsto u lt l) (hv : filter.tendsto v lt l) : (Î» (t : Î¹), âˆ« (x : â„) in u t..v t, f x âˆ‚Î¼ - âˆ« (x : â„) in u t..v t, c âˆ‚Î¼) =o[lt] Î» (t : Î¹), âˆ« (x : â„) in u t..v t, 1 âˆ‚Î¼
theorem unique_factorization_monoid.count_normalized_factors_eq {R : Type u_2} [cancel_comm_monoid_with_zero R] [unique_factorization_monoid R] [nontrivial R] [normalization_monoid R] [decidable_eq R] {p x : R} (hp : irreducible p) (hnorm : â‡‘normalize p = p) {n : â„•} (hle : p ^ n âˆ£ x) (hlt : Â¬p ^ (n + 1) âˆ£ x) : multiset.count p (unique_factorization_monoid.normalized_factors x) = n
theorem closure_operator.closure_mem_mkâ‚ƒ {Î± : Type u_1} [partial_order Î±] {f : Î± â†’ Î±} {p : Î± â†’ Prop} {hf : âˆ€ (x : Î±), x â‰¤ f x} {hfp : âˆ€ (x : Î±), p (f x)} {hmin : âˆ€ â¦ƒx y : Î±â¦„, x â‰¤ y â†’ p y â†’ f x â‰¤ y} (x : Î±) : p (â‡‘(closure_operator.mkâ‚ƒ f p hf hfp hmin) x)
theorem matrix.det_minor_equiv_self {m : Type u_1} {n : Type u_2} [decidable_eq n] [fintype n] [decidable_eq m] [fintype m] {R : Type v} [comm_ring R] (e : n â‰ƒ m) (A : matrix m m R) : (A.minor â‡‘e â‡‘e).det = A.det
theorem measure_theory.measure.mk_metric_le_liminf_sum {X : Type u_2} [emetric_space X] [measurable_space X] [borel_space X] {Î² : Type u_1} {Î¹ : Î² â†’ Type u_3} [hÎ¹ : Î  (n : Î²), fintype (Î¹ n)] (s : set X) {l : filter Î²} (r : Î² â†’ ennreal) (hr : filter.tendsto r l (nhds 0)) (t : Î  (n : Î²), Î¹ n â†’ set X) (ht : âˆ€á¶  (n : Î²) in l, âˆ€ (i : Î¹ n), emetric.diam (t n i) â‰¤ r n) (hst : âˆ€á¶  (n : Î²) in l, s âŠ† â‹ƒ (i : Î¹ n), t n i) (m : ennreal â†’ ennreal) : â‡‘(measure_theory.measure.mk_metric m) s â‰¤ l.liminf (Î» (n : Î²), finset.univ.sum (Î» (i : Î¹ n), m (emetric.diam (t n i))))
theorem tsum_coe_mul_geometric_of_norm_lt_1 {ğ•œ : Type u_1} [normed_field ğ•œ] [complete_space ğ•œ] {r : ğ•œ} (hr : âˆ¥râˆ¥ < 1) : âˆ‘' (n : â„•), â†‘n * r ^ n = r / (1 - r) ^ 2
theorem category_theory.simplicial_object.Î´_comp_Ïƒ_of_gt {C : Type u} [category_theory.category C] (X : category_theory.simplicial_object C) {n : â„•} {i : fin (n + 2)} {j : fin (n + 1)} (H : â‡‘fin.cast_succ j < i) : X.Ïƒ (â‡‘fin.cast_succ j) â‰« X.Î´ i.succ = X.Î´ i â‰« X.Ïƒ j
theorem add_monoid_algebra.ring_hom_ext' {k : Type uâ‚} {G : Type uâ‚‚} {R : Type u_1} [semiring k] [add_monoid G] [semiring R] {f g : add_monoid_algebra k G â†’+* R} (hâ‚ : f.comp add_monoid_algebra.single_zero_ring_hom = g.comp add_monoid_algebra.single_zero_ring_hom) (h_of : â†‘f.comp (add_monoid_algebra.of k G) = â†‘g.comp (add_monoid_algebra.of k G)) : f = g
theorem is_left_regular.ne_zero {R : Type u_1} {a : R} [mul_zero_class R] [nontrivial R] (la : is_left_regular a) : a â‰  0
theorem cInf_union {Î± : Type u_1} [conditionally_complete_lattice Î±] {s t : set Î±} (hs : bdd_below s) (sne : s.nonempty) (ht : bdd_below t) (tne : t.nonempty) : has_Inf.Inf (s âˆª t) = has_Inf.Inf s âŠ“ has_Inf.Inf t
theorem asymptotics.is_O_with.norm_left {Î± : Type u_1} {F : Type u_4} {E' : Type u_6} [has_norm F] [semi_normed_group E'] {c : â„} {g : Î± â†’ F} {f' : Î± â†’ E'} {l : filter Î±} : asymptotics.is_O_with c l f' g â†’ asymptotics.is_O_with c l (Î» (x : Î±), âˆ¥f' xâˆ¥) g
theorem span_gram_schmidt (ğ•œ : Type u_1) {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {Î¹ : Type u_3} [linear_order Î¹] [order_bot Î¹] [locally_finite_order Î¹] [is_well_order Î¹ has_lt.lt] [succ_order Î¹] [is_succ_archimedean Î¹] (f : Î¹ â†’ E) (c : Î¹) : submodule.span ğ•œ (gram_schmidt ğ•œ f '' set.Iio c) = submodule.span ğ•œ (f '' set.Iio c)
theorem submodule.bsupr_eq_range_dfinsupp_lsum {Î¹ : Type u_1} {R : Type u_2} {N : Type u_5} [dec_Î¹ : decidable_eq Î¹] [semiring R] [add_comm_monoid N] [module R N] (p : Î¹ â†’ Prop) [decidable_pred p] (S : Î¹ â†’ submodule R N) : (â¨† (i : Î¹) (h : p i), S i) = ((â‡‘(dfinsupp.lsum â„•) (Î» (i : Î¹), (S i).subtype)).comp (dfinsupp.filter_linear_map R (Î» (i : Î¹), â†¥(S i)) p)).range
theorem path.homotopic.proj_left_prod {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] {aâ‚ aâ‚‚ : Î±} {bâ‚ bâ‚‚ : Î²} (qâ‚ : path.homotopic.quotient aâ‚ aâ‚‚) (qâ‚‚ : path.homotopic.quotient bâ‚ bâ‚‚) : path.homotopic.proj_left (path.homotopic.prod qâ‚ qâ‚‚) = qâ‚
theorem complete_lattice.independent_iff_dfinsupp_sum_add_hom_injective {Î¹ : Type u_1} {N : Type u_5} [dec_Î¹ : decidable_eq Î¹] [add_comm_group N] (p : Î¹ â†’ add_subgroup N) : complete_lattice.independent p â†” function.injective â‡‘(dfinsupp.sum_add_hom (Î» (i : Î¹), (p i).subtype))
theorem list.prod_inv {G : Type u_7} [comm_group G] (L : list G) : (L.prod)â»Â¹ = (list.map (Î» (x : G), xâ»Â¹) L).prod
theorem subsingleton_or_nontrivial (Î± : Type u_1) : subsingleton Î± âˆ¨ nontrivial Î±
theorem affine_subspace.direction_sup {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s1 s2 : affine_subspace k P} {p1 p2 : P} (hp1 : p1 âˆˆ s1) (hp2 : p2 âˆˆ s2) : (s1 âŠ” s2).direction = s1.direction âŠ” s2.direction âŠ” submodule.span k {p2 -áµ¥ p1}
theorem category_theory.limits.is_limit.of_nat_iso.cone_fac {J : Type uâ‚} [category_theory.category J] {C : Type uâ‚ƒ} [category_theory.category C] {F : J â¥¤ C} {X : C} (h : category_theory.yoneda.obj X â‹™ category_theory.ulift_functor â‰… F.cones) (s : category_theory.limits.cone F) : (category_theory.limits.is_limit.of_nat_iso.limit_cone h).extend (category_theory.limits.is_limit.of_nat_iso.hom_of_cone h s) = s
theorem polynomial.exists_approx_polynomial_aux {Fq : Type u_1} [fintype Fq] [ring Fq] {d m : â„•} (hm : fintype.card Fq ^ d â‰¤ m) (b : polynomial Fq) (A : fin m.succ â†’ polynomial Fq) (hA : âˆ€ (i : fin m.succ), (A i).degree < b.degree) : âˆƒ (iâ‚€ iâ‚ : fin m.succ), iâ‚€ â‰  iâ‚ âˆ§ (A iâ‚ - A iâ‚€).degree < â†‘(b.nat_degree - d)
theorem iterated_fderiv_within_inter {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {s u : set E} {f : E â†’ F} {x : E} {n : â„•} (hu : u âˆˆ nhds x) (hs : unique_diff_on ğ•œ s) (xs : x âˆˆ s) : iterated_fderiv_within ğ•œ n f (s âˆ© u) x = iterated_fderiv_within ğ•œ n f s x
theorem cont_mdiff_exp_map_circle  : cont_mdiff (model_with_corners_self â„ â„) (model_with_corners_self â„ (euclidean_space â„ (fin 1))) âŠ¤ â‡‘exp_map_circle
theorem submodule.mapq_comp {R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] (p : submodule R M) {Râ‚‚ : Type u_3} {Mâ‚‚ : Type u_4} [ring Râ‚‚] [add_comm_group Mâ‚‚] [module Râ‚‚ Mâ‚‚] {Ï„â‚â‚‚ : R â†’+* Râ‚‚} {Râ‚ƒ : Type u_5} {Mâ‚ƒ : Type u_6} [ring Râ‚ƒ] [add_comm_group Mâ‚ƒ] [module Râ‚ƒ Mâ‚ƒ] (pâ‚‚ : submodule Râ‚‚ Mâ‚‚) (pâ‚ƒ : submodule Râ‚ƒ Mâ‚ƒ) {Ï„â‚‚â‚ƒ : Râ‚‚ â†’+* Râ‚ƒ} {Ï„â‚â‚ƒ : R â†’+* Râ‚ƒ} [ring_hom_comp_triple Ï„â‚â‚‚ Ï„â‚‚â‚ƒ Ï„â‚â‚ƒ] (f : M â†’â‚›â‚—[Ï„â‚â‚‚] Mâ‚‚) (g : Mâ‚‚ â†’â‚›â‚—[Ï„â‚‚â‚ƒ] Mâ‚ƒ) (hf : p â‰¤ submodule.comap f pâ‚‚) (hg : pâ‚‚ â‰¤ submodule.comap g pâ‚ƒ) (h : p â‰¤ submodule.comap f (submodule.comap g pâ‚ƒ) := _) : p.mapq pâ‚ƒ (g.comp f) h = (pâ‚‚.mapq pâ‚ƒ g hg).comp (p.mapq pâ‚‚ f hf)
theorem char.quadratic_char_eq_pow_of_char_ne_two {F : Type u_1} [field F] [fintype F] [decidable_eq F] (hF : ring_char F â‰  2) {a : F} (ha : a â‰  0) : char.quadratic_char F a = ite (a ^ (fintype.card F / 2) = 1) 1 (-1)
theorem measure_theory.ae_restrict_congr_set {Î± : Type u_1} {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {s t : Î± â†’ Prop} (hst : s =áµ[Î¼] t) {p : Î± â†’ Prop} : (âˆ€áµ (x : Î±) âˆ‚Î¼.restrict s, p x) â†” âˆ€áµ (x : Î±) âˆ‚Î¼.restrict t, p x
theorem cont_diff_at.smul {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {x : E} {n : with_top â„•} {f : E â†’ ğ•œ} {g : E â†’ F} (hf : cont_diff_at ğ•œ n f x) (hg : cont_diff_at ğ•œ n g x) : cont_diff_at ğ•œ n (Î» (x : E), f x â€¢ g x) x
theorem ring_hom.srange_top_of_surjective {R : Type u} {S : Type v} [non_assoc_semiring R] [non_assoc_semiring S] (f : R â†’+* S) (hf : function.surjective â‡‘f) : f.srange = âŠ¤
theorem exp_series_eq_exp_series (ğ•‚ : Type u_1) (ğ•‚' : Type u_2) (ğ”¸ : Type u_3) [field ğ•‚] [field ğ•‚'] [ring ğ”¸] [algebra ğ•‚ ğ”¸] [algebra ğ•‚' ğ”¸] [topological_space ğ”¸] [topological_ring ğ”¸] (n : â„•) (x : ğ”¸) : â‡‘(exp_series ğ•‚ ğ”¸ n) (Î» (_x : fin n), x) = â‡‘(exp_series ğ•‚' ğ”¸ n) (Î» (_x : fin n), x)
theorem is_conformal_map_iff {E : Type u_1} {F : Type u_2} [inner_product_space â„ E] [inner_product_space â„ F] (f : E â†’L[â„] F) : is_conformal_map f â†” âˆƒ (c : â„), 0 < c âˆ§ âˆ€ (u v : E), has_inner.inner (â‡‘f u) (â‡‘f v) = c * has_inner.inner u v
theorem filter.map_mapâ‚‚_antidistrib_right {Î± : Type u_1} {Î±' : Type u_2} {Î² : Type u_3} {Î³ : Type u_5} {Î´ : Type u_7} {m : Î± â†’ Î² â†’ Î³} {f : filter Î±} {g : filter Î²} {n : Î³ â†’ Î´} {m' : Î² â†’ Î±' â†’ Î´} {n' : Î± â†’ Î±'} (h_antidistrib : âˆ€ (a : Î±) (b : Î²), n (m a b) = m' b (n' a)) : filter.map n (filter.mapâ‚‚ m f g) = filter.mapâ‚‚ m' g (filter.map n' f)
theorem nat.factorization_central_binom_of_two_mul_self_lt_three_mul {p n : â„•} (n_big : 2 < n) (p_le_n : p â‰¤ n) (big : 2 * n < 3 * p) : â‡‘(n.central_binom.factorization) p = 0
theorem set.Icc_diff_pi_univ_Ioc_subset {Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_2} [decidable_eq Î¹] [Î  (i : Î¹), linear_order (Î± i)] (x y z : Î  (i : Î¹), Î± i) : set.Icc x z  set.univ.pi (Î» (i : Î¹), set.Ioc (y i) (z i)) âŠ† â‹ƒ (i : Î¹), set.Icc x (function.update z i (y i))
theorem inner_product_geometry.norm_sub_eq_add_norm_of_angle_eq_pi {V : Type u_1} [inner_product_space â„ V] {x y : V} (h : inner_product_geometry.angle x y = real.pi) : âˆ¥x - yâˆ¥ = âˆ¥xâˆ¥ + âˆ¥yâˆ¥
theorem monotone.dual_right {Î± : Type u} {Î² : Type v} [preorder Î±] [preorder Î²] {f : Î± â†’ Î²} : monotone f â†’ antitone (â‡‘order_dual.to_dual âˆ˜ f)
theorem units_inv_smul {R : Type u_1} [linear_ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] (u : RË£) (v : module.ray R M) : uâ»Â¹ â€¢ v = u â€¢ v
theorem is_compact.exists_forall_ge {Î± : Type u_1} {Î² : Type u_2} [conditionally_complete_linear_order Î±] [topological_space Î±] [order_topology Î±] [topological_space Î²] {s : set Î²} : is_compact s â†’ s.nonempty â†’ âˆ€ {f : Î² â†’ Î±}, continuous_on f s â†’ (âˆƒ (x : Î²) (H : x âˆˆ s), âˆ€ (y : Î²), y âˆˆ s â†’ f y â‰¤ f x)
theorem is_open.polish_space {Î± : Type u_1} [topological_space Î±] [polish_space Î±] {s : set Î±} (hs : is_open s) : polish_space â†¥s
theorem category_theory.limits.zero_of_from_zero {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_zero_morphisms C] {X : C} (f : 0 âŸ¶ X) : f = 0
theorem clifford_algebra_quaternion.to_quaternion_involute_reverse {R : Type u_1} [comm_ring R] {câ‚ câ‚‚ : R} (c : clifford_algebra (clifford_algebra_quaternion.Q câ‚ câ‚‚)) : â‡‘clifford_algebra_quaternion.to_quaternion (â‡‘clifford_algebra.involute (â‡‘clifford_algebra.reverse c)) = â‡‘quaternion_algebra.conj (â‡‘clifford_algebra_quaternion.to_quaternion c)
theorem lucas_primality (p : â„•) (a : zmod p) (ha : a ^ (p - 1) = 1) (hd : âˆ€ (q : â„•), nat.prime q â†’ q âˆ£ p - 1 â†’ a ^ ((p - 1) / q) â‰  1) : nat.prime p
theorem Profinite.is_closed_map {X Y : Profinite} (f : X âŸ¶ Y) : is_closed_map â‡‘f
theorem normed_group_hom.lipschitz {Vâ‚ : Type u_2} {Vâ‚‚ : Type u_3} [semi_normed_group Vâ‚] [semi_normed_group Vâ‚‚] (f : normed_group_hom Vâ‚ Vâ‚‚) : lipschitz_with âŸ¨âˆ¥fâˆ¥, _âŸ© â‡‘f
theorem set.abs_sub_right_of_mem_interval {Î± : Type u} [linear_ordered_add_comm_group Î±] {a b x : Î±} (h : x âˆˆ set.interval a b) : |b - x| â‰¤ |b - a|
theorem metric.diam_eq_zero_of_unbounded {Î± : Type u} [pseudo_metric_space Î±] {s : set Î±} (h : Â¬metric.bounded s) : metric.diam s = 0
theorem is_integral_closure.exists_smul_eq_mul {R : Type u_1} {S : Type u_2} [comm_ring R] [is_domain R] [comm_ring S] {L : Type u_3} [field L] [algebra R S] [algebra S L] [algebra R L] [is_scalar_tower R S L] [is_integral_closure S R L] (h : algebra.is_algebraic R L) (inj : function.injective â‡‘(algebra_map R L)) (a : S) {b : S} (hb : b â‰  0) : âˆƒ (c : S) (d : R) (H : d â‰  0), d â€¢ a = b * c
theorem antivary_on.sum_smul_eq_sum_comp_perm_smul_iff {Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [linear_ordered_ring Î±] [linear_ordered_add_comm_group Î²] [module Î± Î²] [ordered_smul Î± Î²] {s : finset Î¹} {Ïƒ : equiv.perm Î¹} {f : Î¹ â†’ Î±} {g : Î¹ â†’ Î²} (hfg : antivary_on f g â†‘s) (hÏƒ : {x : Î¹ | â‡‘Ïƒ x â‰  x} âŠ† â†‘s) : s.sum (Î» (i : Î¹), f (â‡‘Ïƒ i) â€¢ g i) = s.sum (Î» (i : Î¹), f i â€¢ g i) â†” antivary_on (f âˆ˜ â‡‘Ïƒ) g â†‘s
theorem bornology.is_bounded.compl {Î± : Type u_2} [bornology Î±] {s : set Î±} : bornology.is_bounded s â†’ bornology.is_cobounded sá¶œ
theorem closure_Ioi' {Î± : Type u} [topological_space Î±] [linear_order Î±] [order_topology Î±] [densely_ordered Î±] {a : Î±} (h : (set.Ioi a).nonempty) : closure (set.Ioi a) = set.Ici a
theorem semidirect_product.hom_ext {N : Type u_1} {G : Type u_2} {H : Type u_3} [group N] [group G] [group H] {Ï† : G â†’* mul_aut N} {f g : N â‹Š[Ï†] G â†’* H} (hl : f.comp semidirect_product.inl = g.comp semidirect_product.inl) (hr : f.comp semidirect_product.inr = g.comp semidirect_product.inr) : f = g
theorem strict_convex_on.lt_on_open_segment' {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [ordered_semiring ğ•œ] [add_comm_monoid E] [linear_ordered_add_comm_monoid Î²] [has_scalar ğ•œ E] [module ğ•œ Î²] [ordered_smul ğ•œ Î²] {s : set E} {f : E â†’ Î²} (hf : strict_convex_on ğ•œ s f) {x y : E} (hx : x âˆˆ s) (hy : y âˆˆ s) (hxy : x â‰  y) {a b : ğ•œ} (ha : 0 < a) (hb : 0 < b) (hab : a + b = 1) : f (a â€¢ x + b â€¢ y) < linear_order.max (f x) (f y)
theorem finset.prod_induction {Î± : Type v} {s : finset Î±} {M : Type u_1} [comm_monoid M] (f : Î± â†’ M) (p : M â†’ Prop) (p_mul : âˆ€ (a b : M), p a â†’ p b â†’ p (a * b)) (p_one : p 1) (p_s : âˆ€ (x : Î±), x âˆˆ s â†’ p (f x)) : p (s.prod (Î» (x : Î±), f x))
theorem concave_on.le_map_center_mass {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} {Î¹ : Type u_5} [linear_ordered_field ğ•œ] [add_comm_group E] [ordered_add_comm_group Î²] [module ğ•œ E] [module ğ•œ Î²] [ordered_smul ğ•œ Î²] {s : set E} {f : E â†’ Î²} {t : finset Î¹} {w : Î¹ â†’ ğ•œ} {p : Î¹ â†’ E} (hf : concave_on ğ•œ s f) (hâ‚€ : âˆ€ (i : Î¹), i âˆˆ t â†’ 0 â‰¤ w i) (hâ‚ : 0 < t.sum (Î» (i : Î¹), w i)) (hmem : âˆ€ (i : Î¹), i âˆˆ t â†’ p i âˆˆ s) : t.center_mass w (f âˆ˜ p) â‰¤ f (t.center_mass w p)
theorem strict_anti.dual_right {Î± : Type u} {Î² : Type v} [preorder Î±] [preorder Î²] {f : Î± â†’ Î²} : strict_anti f â†’ strict_mono (â‡‘order_dual.to_dual âˆ˜ f)
theorem add_group.fg_iff_add_monoid.fg {G : Type u_3} [add_group G] : add_group.fg G â†” add_monoid.fg G
theorem category_theory.limits.limit.pre_eq {J : Type uâ‚} [category_theory.category J] {K : Type uâ‚‚} [category_theory.category K] {C : Type u} [category_theory.category C] {F : J â¥¤ C} [category_theory.limits.has_limit F] {E : K â¥¤ J} [category_theory.limits.has_limit (E â‹™ F)] (s : category_theory.limits.limit_cone (E â‹™ F)) (t : category_theory.limits.limit_cone F) : category_theory.limits.limit.pre F E = (category_theory.limits.limit.iso_limit_cone t).hom â‰« s.is_limit.lift (category_theory.limits.cone.whisker E t.cone) â‰« (category_theory.limits.limit.iso_limit_cone s).inv
theorem continuous_of_continuous_at_one {G : Type w} [topological_space G] [group G] [topological_group G] {M : Type u_1} {hom : Type u_2} [mul_one_class M] [topological_space M] [has_continuous_mul M] [monoid_hom_class hom G M] (f : hom) (hf : continuous_at â‡‘f 1) : continuous â‡‘f
theorem add_subgroup.normed_mk.apply {M : Type u_1} [semi_normed_group M] (S : add_subgroup M) (m : M) : â‡‘(S.normed_mk) m = â‡‘(quotient_add_group.mk' S) m
theorem matrix.is_diag.kronecker {Î± : Type u_1} {n : Type u_4} {m : Type u_5} [mul_zero_class Î±] {A : matrix m m Î±} {B : matrix n n Î±} (hA : A.is_diag) (hB : B.is_diag) : (matrix.kronecker_map has_mul.mul A B).is_diag
theorem has_deriv_at_exp_zero_of_radius_pos {ğ•‚ : Type u_1} [nondiscrete_normed_field ğ•‚] [complete_space ğ•‚] (h : 0 < (exp_series ğ•‚ ğ•‚).radius) : has_deriv_at (exp ğ•‚) 1 0
theorem set.Union_Inter_of_antitone {Î¹ : Type u_1} {Î¹' : Type u_2} {Î± : Type u_3} [fintype Î¹] [preorder Î¹'] [is_directed Î¹' (function.swap has_le.le)] [nonempty Î¹'] {s : Î¹ â†’ Î¹' â†’ set Î±} (hs : âˆ€ (i : Î¹), antitone (s i)) : (â‹ƒ (j : Î¹'), â‹‚ (i : Î¹), s i j) = â‹‚ (i : Î¹), â‹ƒ (j : Î¹'), s i j
theorem add_subgroup.supr_induction' {G : Type u_1} [add_group G] {Î¹ : Sort u_2} (S : Î¹ â†’ add_subgroup G) {C : Î  (x : G), (x âˆˆ â¨† (i : Î¹), S i) â†’ Prop} (hp : âˆ€ (i : Î¹) (x : G) (H : x âˆˆ S i), C x _) (h1 : C 0 _) (hmul : âˆ€ (x y : G) (hx : x âˆˆ â¨† (i : Î¹), S i) (hy : y âˆˆ â¨† (i : Î¹), S i), C x hx â†’ C y hy â†’ C (x + y) _) {x : G} (hx : x âˆˆ â¨† (i : Î¹), S i) : C x hx
theorem function.injective.cod_restrict {Î± : Type u} {Î² : Type v} {t : set Î²} {f : Î± â†’ Î²} (h : âˆ€ (x : Î±), f x âˆˆ t) : function.injective f â†’ function.injective (set.cod_restrict f t h)
theorem simple_graph.walk.take_spec {V : Type u} {G : simple_graph V} [decidable_eq V] {u v w : V} (p : G.walk v w) (h : u âˆˆ p.support) : (p.take_until u h).append (p.drop_until u h) = p
theorem measure_theory.simple_func.lintegral_mono {Î± : Type u_1} {m : measurable_space Î±} {Î¼ Î½ : measure_theory.measure Î±} {f g : measure_theory.simple_func Î± ennreal} (hfg : f â‰¤ g) (hÎ¼Î½ : Î¼ â‰¤ Î½) : f.lintegral Î¼ â‰¤ g.lintegral Î½
theorem subgroup.eq_one_of_noncomm_prod_eq_one_of_independent {G : Type u_1} [group G] {Î¹ : Type u_2} (s : finset Î¹) (f : Î¹ â†’ G) (comm : âˆ€ (x : Î¹), x âˆˆ s â†’ âˆ€ (y : Î¹), y âˆˆ s â†’ commute (f x) (f y)) (K : Î¹ â†’ subgroup G) (hind : complete_lattice.independent K) (hmem : âˆ€ (x : Î¹), x âˆˆ s â†’ f x âˆˆ K x) (heq1 : s.noncomm_prod f comm = 1) (i : Î¹) (H : i âˆˆ s) : f i = 1
theorem pi.sum_norm_apply_le_norm {Î¹ : Type u_2} {Ï€ : Î¹ â†’ Type u_1} [fintype Î¹] [Î  (i : Î¹), semi_normed_group (Ï€ i)] (x : Î  (i : Î¹), Ï€ i) : finset.univ.sum (Î» (i : Î¹), âˆ¥x iâˆ¥) â‰¤ fintype.card Î¹ â€¢ âˆ¥xâˆ¥
theorem pnat.xgcd_type.rq_eq (u : pnat.xgcd_type) : u.r + (u.bp + 1) * u.q = u.ap + 1
theorem ordinal.infinite_pigeonhole {Î² Î± : Type u} (f : Î² â†’ Î±) (hâ‚ : cardinal.aleph_0 â‰¤ cardinal.mk Î²) (hâ‚‚ : cardinal.mk Î± < (cardinal.mk Î²).ord.cof) : âˆƒ (a : Î±), cardinal.mk â†¥(f â»Â¹' {a}) = cardinal.mk Î²
theorem measure_theory.ae_cover.integral_eq_of_tendsto {Î± : Type u_1} {Î¹ : Type u_2} {E : Type u_3} [measurable_space Î±] {Î¼ : measure_theory.measure Î±} {l : filter Î¹} [normed_group E] [normed_space â„ E] [complete_space E] [l.ne_bot] [l.is_countably_generated] {Ï† : Î¹ â†’ set Î±} (hÏ† : measure_theory.ae_cover Î¼ l Ï†) {f : Î± â†’ E} (I : E) (hfi : measure_theory.integrable f Î¼) (h : filter.tendsto (Î» (n : Î¹), âˆ« (x : Î±) in Ï† n, f x âˆ‚Î¼) l (nhds I)) : âˆ« (x : Î±), f x âˆ‚Î¼ = I
theorem finset.le_prod_nonempty_of_submultiplicative_on_pred {Î¹ : Type u_1} {M : Type u_4} {N : Type u_5} [comm_monoid M] [ordered_comm_monoid N] (f : M â†’ N) (p : M â†’ Prop) (h_mul : âˆ€ (x y : M), p x â†’ p y â†’ f (x * y) â‰¤ f x * f y) (hp_mul : âˆ€ (x y : M), p x â†’ p y â†’ p (x * y)) (g : Î¹ â†’ M) (s : finset Î¹) (hs_nonempty : s.nonempty) (hs : âˆ€ (i : Î¹), i âˆˆ s â†’ p (g i)) : f (s.prod (Î» (i : Î¹), g i)) â‰¤ s.prod (Î» (i : Î¹), f (g i))
theorem set.finite.bounded {Î± : Type u} [pseudo_metric_space Î±] {s : set Î±} (h : s.finite) : metric.bounded s
theorem is_compact_univ_pi {Î¹ : Type u_1} {Ï€ : Î¹ â†’ Type u_2} [Î  (i : Î¹), topological_space (Ï€ i)] {s : Î  (i : Î¹), set (Ï€ i)} (h : âˆ€ (i : Î¹), is_compact (s i)) : is_compact (set.univ.pi s)
theorem polynomial.degree_list_prod {R : Type u} [semiring R] [no_zero_divisors R] [nontrivial R] (l : list (polynomial R)) : l.prod.degree = (list.map polynomial.degree l).sum
theorem equiv_functor.map_equiv_trans (f : Type uâ‚€ â†’ Type uâ‚) [equiv_functor f] {Î± Î² Î³ : Type uâ‚€} (ab : Î± â‰ƒ Î²) (bc : Î² â‰ƒ Î³) : (equiv_functor.map_equiv f ab).trans (equiv_functor.map_equiv f bc) = equiv_functor.map_equiv f (ab.trans bc)
theorem is_smul_regular.one {R : Type u_1} (M : Type u_3) [monoid R] [mul_action R M] : is_smul_regular M 1
theorem category_theory.grothendieck_topology.is_glb_Inf {C : Type u} [category_theory.category C] (s : set (category_theory.grothendieck_topology C)) : is_glb s (has_Inf.Inf s)
theorem cont_diff.cont_diff_fderiv_apply {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {m n : with_top â„•} {f : E â†’ F} (hf : cont_diff ğ•œ n f) (hmn : m + 1 â‰¤ n) : cont_diff ğ•œ m (Î» (p : E Ã— E), â‡‘(fderiv ğ•œ f p.fst) p.snd)
theorem monoid_hom.map_finsupp_prod {Î± : Type u_1} {M : Type u_5} {N : Type u_7} {P : Type u_8} [has_zero M] [comm_monoid N] [comm_monoid P] (h : N â†’* P) (f : Î± â†’â‚€ M) (g : Î± â†’ M â†’ N) : â‡‘h (f.prod g) = f.prod (Î» (a : Î±) (b : M), â‡‘h (g a b))
theorem real.is_O_one_exp_comp {Î± : Type u_1} {l : filter Î±} {f : Î± â†’ â„} : ((Î» (x : Î±), 1) =O[l] Î» (x : Î±), real.exp (f x)) â†” filter.is_bounded_under ge l f
theorem first_order.language.Theory.exists_large_model_of_infinite_model {L : first_order.language} (T : L.Theory) (Îº : cardinal) (M : Type w') [L.Structure M] [M âŠ¨ T] [infinite M] : âˆƒ (N : T.Model), Îº.lift â‰¤ cardinal.mk â†¥N
theorem add_subgroup.coe_norm {E : Type u_1} [semi_normed_group E] {s : add_subgroup E} (x : â†¥s) : âˆ¥xâˆ¥ = âˆ¥â†‘xâˆ¥
theorem real.exists_extension_norm_eq {E : Type u_1} [semi_normed_group E] [normed_space â„ E] (p : subspace â„ E) (f : â†¥p â†’L[â„] â„) : âˆƒ (g : E â†’L[â„] â„), (âˆ€ (x : â†¥p), â‡‘g â†‘x = â‡‘f x) âˆ§ âˆ¥gâˆ¥ = âˆ¥fâˆ¥
theorem setoid.ker_eq_lift_of_injective {Î± : Type u_1} {Î² : Type u_2} {r : setoid Î±} (f : Î± â†’ Î²) (H : âˆ€ (x y : Î±), r.rel x y â†’ f x = f y) (h : function.injective (quotient.lift f H)) : setoid.ker f = r
theorem emetric.Hausdorff_edist_zero_iff_eq_of_closed {Î± : Type u} [pseudo_emetric_space Î±] {s t : set Î±} (hs : is_closed s) (ht : is_closed t) : emetric.Hausdorff_edist s t = 0 â†” s = t
theorem reflexive_ne_imp_iff {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} [is_refl Î± r] {x y : Î±} : x â‰  y â†’ r x y â†” r x y
theorem linear_ordered_comm_group_with_zero.pure_le_nhds_fun (Î“â‚€ : Type u_1) [linear_ordered_comm_group_with_zero Î“â‚€] : has_pure.pure â‰¤ linear_ordered_comm_group_with_zero.nhds_fun Î“â‚€
theorem fin.cons_injective2 {n : â„•} {Î± : fin (n + 1) â†’ Type u} : function.injective2 fin.cons
theorem orientation.oangle_add_cyc3_neg_left {V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) {x y z : V} (hx : x â‰  0) (hy : y â‰  0) (hz : z â‰  0) : o.oangle (-x) y + o.oangle (-y) z + o.oangle (-z) x = â†‘real.pi
theorem div_eq_one_of_eq {G : Type u_2} [group G] {a b : G} : a = b â†’ a / b = 1
theorem has_le.le.trans_lt {Î± : Type u} [preorder Î±] {a b c : Î±} : a â‰¤ b â†’ b < c â†’ a < c
theorem normed_group_hom.op_norm_zero_iff {Vâ‚ : Type u_1} {Vâ‚‚ : Type u_2} [normed_group Vâ‚] [normed_group Vâ‚‚] {f : normed_group_hom Vâ‚ Vâ‚‚} : âˆ¥fâˆ¥ = 0 â†” f = 0
theorem lt_add_of_sub_left_lt {Î± : Type u} [add_comm_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b c : Î±} : a - b < c â†’ a < b + c
theorem power_basis.trace_gen_eq_sum_roots {S : Type u_2} [comm_ring S] {K : Type u_4} [field K] {F : Type u_6} [field F] [algebra K S] [algebra K F] [nontrivial S] (pb : power_basis K S) (hf : polynomial.splits (algebra_map K F) (minpoly K pb.gen)) : â‡‘(algebra_map K F) (â‡‘(algebra.trace K S) pb.gen) = (polynomial.map (algebra_map K F) (minpoly K pb.gen)).roots.sum
theorem add_submonoid.bot_or_exists_ne_zero {M : Type u_1} [add_zero_class M] (S : add_submonoid M) : S = âŠ¥ âˆ¨ âˆƒ (x : M) (H : x âˆˆ S), x â‰  0
theorem loc_unif_bound_dGamma_integrand {t : â„‚} {s1 s2 x : â„} (ht1 : s1 â‰¤ t.re) (ht2 : t.re â‰¤ s2) (hx : 0 < x) : âˆ¥dGamma_integrand t xâˆ¥ â‰¤ dGamma_integrand_real s1 x + dGamma_integrand_real s2 x
theorem submonoid.closure_induction' {M : Type u_1} [mul_one_class M] (s : set M) {p : Î  (x : M), x âˆˆ submonoid.closure s â†’ Prop} (Hs : âˆ€ (x : M) (h : x âˆˆ s), p x _) (H1 : p 1 _) (Hmul : âˆ€ (x : M) (hx : x âˆˆ submonoid.closure s) (y : M) (hy : y âˆˆ submonoid.closure s), p x hx â†’ p y hy â†’ p (x * y) _) {x : M} (hx : x âˆˆ submonoid.closure s) : p x hx
theorem module.free.finrank_finsupp (R : Type u) [ring R] [strong_rank_condition R] {Î¹ : Type v} [fintype Î¹] : finite_dimensional.finrank R (Î¹ â†’â‚€ R) = fintype.card Î¹
theorem category_theory.limits.is_iso_limit_cone_parallel_pair_of_eq {C : Type u} [category_theory.category C] {X Y : C} {f g : X âŸ¶ Y} (hâ‚€ : f = g) {c : category_theory.limits.fork f g} (h : category_theory.limits.is_limit c) : category_theory.is_iso c.Î¹
theorem measure_theory.measure.regular_of_is_mul_left_invariant {G : Type u_1} [group G] [topological_space G] [t2_space G] [topological_group G] [measurable_space G] [borel_space G] [topological_space.second_countable_topology G] {Î¼ : measure_theory.measure G} [measure_theory.sigma_finite Î¼] [Î¼.is_mul_left_invariant] {K : set G} (hK : is_compact K) (h2K : (interior K).nonempty) (hÎ¼K : â‡‘Î¼ K â‰  âŠ¤) : Î¼.regular
theorem polynomial.nat_degree_sub_eq_of_prod_eq {R : Type u} [semiring R] [no_zero_divisors R] {pâ‚ pâ‚‚ qâ‚ qâ‚‚ : polynomial R} (hpâ‚ : pâ‚ â‰  0) (hqâ‚ : qâ‚ â‰  0) (hpâ‚‚ : pâ‚‚ â‰  0) (hqâ‚‚ : qâ‚‚ â‰  0) (h_eq : pâ‚ * qâ‚‚ = pâ‚‚ * qâ‚) : â†‘(pâ‚.nat_degree) - â†‘(qâ‚.nat_degree) = â†‘(pâ‚‚.nat_degree) - â†‘(qâ‚‚.nat_degree)
theorem cardinal.lift_sup_le {Î¹ : Type v} (f : Î¹ â†’ cardinal) (t : cardinal) (w : âˆ€ (i : Î¹), (f i).lift â‰¤ t) : (cardinal.sup f).lift â‰¤ t
theorem cluster_pt_principal_iff {Î± : Type u} [topological_space Î±] {x : Î±} {s : set Î±} : cluster_pt x (filter.principal s) â†” âˆ€ (U : set Î±), U âˆˆ nhds x â†’ (U âˆ© s).nonempty
theorem fintype.exists_card_fiber_lt_of_card_lt_mul {Î± : Type u} {Î² : Type v} [decidable_eq Î²] [fintype Î±] [fintype Î²] (f : Î± â†’ Î²) {n : â„•} (hn : fintype.card Î± < fintype.card Î² * n) : âˆƒ (y : Î²), (finset.filter (Î» (x : Î±), f x = y) finset.univ).card < n
theorem dfinsupp.coe_fn_injective {Î¹ : Type u} {Î² : Î¹ â†’ Type v} [Î  (i : Î¹), has_zero (Î² i)] : function.injective coe_fn
theorem nonarchimedean_group.prod_self_subset {G : Type u_1} [group G] [topological_space G] [nonarchimedean_group G] {U : set (G Ã— G)} (hU : U âˆˆ nhds 1) : âˆƒ (V : open_subgroup G), â†‘V Ã—Ë¢ â†‘V âŠ† U
theorem add_submonoid.supr_induction' {M : Type u_1} [add_zero_class M] {Î¹ : Sort u_2} (S : Î¹ â†’ add_submonoid M) {C : Î  (x : M), (x âˆˆ â¨† (i : Î¹), S i) â†’ Prop} (hp : âˆ€ (i : Î¹) (x : M) (H : x âˆˆ S i), C x _) (h1 : C 0 _) (hmul : âˆ€ (x y : M) (hx : x âˆˆ â¨† (i : Î¹), S i) (hy : y âˆˆ â¨† (i : Î¹), S i), C x hx â†’ C y hy â†’ C (x + y) _) {x : M} (hx : x âˆˆ â¨† (i : Î¹), S i) : C x hx
theorem submodule.mem_supr_iff_exists_finset {R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] {Î¹ : Type u_3} {p : Î¹ â†’ submodule R M} {m : M} : (m âˆˆ â¨† (i : Î¹), p i) â†” âˆƒ (s : finset Î¹), m âˆˆ â¨† (i : Î¹) (H : i âˆˆ s), p i
theorem list.prod_eq_zero {Mâ‚€ : Type u_6} [monoid_with_zero Mâ‚€] {L : list Mâ‚€} (h : 0 âˆˆ L) : L.prod = 0
theorem alternating_map.eq_smul_basis_det {R : Type u_1} [comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {Î¹ : Type u_4} [decidable_eq Î¹] [fintype Î¹] (e : basis Î¹ R M) (f : alternating_map R M R Î¹) : f = â‡‘f â‡‘e â€¢ e.det
theorem order.pfilter.inf_mem {P : Type u_1} [semilattice_inf P] {x y : P} {F : order.pfilter P} (hx : x âˆˆ F) (hy : y âˆˆ F) : x âŠ“ y âˆˆ F
theorem con.symm {M : Type u_1} [has_mul M] (c : con M) {x y : M} : â‡‘c x y â†’ â‡‘c y x
theorem convex.second_derivative_within_at_symmetric {E : Type u_1} {F : Type u_2} [normed_group E] [normed_space â„ E] [normed_group F] [normed_space â„ F] {s : set E} (s_conv : convex â„ s) (hne : (interior s).nonempty) {f : E â†’ F} {f' : E â†’ (E â†’L[â„] F)} {f'' : E â†’L[â„] E â†’L[â„] F} (hf : âˆ€ (x : E), x âˆˆ interior s â†’ has_fderiv_at f (f' x) x) {x : E} (xs : x âˆˆ s) (hx : has_fderiv_within_at f' f'' (interior s) x) (v w : E) : â‡‘(â‡‘f'' v) w = â‡‘(â‡‘f'' w) v
theorem function.bij_on_fixed_pts_comp {Î± : Type u} {Î² : Type v} (f : Î± â†’ Î²) (g : Î² â†’ Î±) : set.bij_on g (function.fixed_points (f âˆ˜ g)) (function.fixed_points (g âˆ˜ f))
theorem continuous_linear_map.to_ring_inverse {R : Type u_1} {M : Type u_2} {Mâ‚‚ : Type u_3} [topological_space M] [topological_space Mâ‚‚] [ring R] [add_comm_group M] [topological_add_group M] [module R M] [add_comm_group Mâ‚‚] [module R Mâ‚‚] (e : M â‰ƒL[R] Mâ‚‚) (f : M â†’L[R] Mâ‚‚) : f.inverse = (ring.inverse (â†‘(e.symm).comp f)).comp â†‘(e.symm)
theorem orientation.rotation_symm {V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) (Î¸ : real.angle) : (o.rotation Î¸).symm = o.rotation (-Î¸)
theorem has_strict_deriv_at.real_of_complex {e : â„‚ â†’ â„‚} {e' : â„‚} {z : â„} (h : has_strict_deriv_at e e' â†‘z) : has_strict_deriv_at (Î» (x : â„), (e â†‘x).re) e'.re z
theorem cont_diff_prod_assoc {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {G : Type u_4} [normed_group G] [normed_space ğ•œ G] : cont_diff ğ•œ âŠ¤ â‡‘(equiv.prod_assoc E F G)
theorem continuous_linear_map.exists_preimage_norm_le {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] (f : E â†’L[ğ•œ] F) [complete_space F] [complete_space E] (surj : function.surjective â‡‘f) : âˆƒ (C : â„) (H : C > 0), âˆ€ (y : F), âˆƒ (x : E), â‡‘f x = y âˆ§ âˆ¥xâˆ¥ â‰¤ C * âˆ¥yâˆ¥
theorem measure_theory.is_add_fundamental_domain.measure_eq {G : Type u_1} {Î± : Type u_2} [add_group G] [add_action G Î±] [measurable_space Î±] {s t : set Î±} {Î¼ : measure_theory.measure Î±} [measurable_space G] [has_measurable_vadd G Î±] [measure_theory.vadd_invariant_measure G Î± Î¼] [encodable G] (hs : measure_theory.is_add_fundamental_domain G s Î¼) (ht : measure_theory.is_add_fundamental_domain G t Î¼) : â‡‘Î¼ s = â‡‘Î¼ t
theorem ring_equiv.map_zero {R : Type u_4} {S : Type u_5} [non_unital_non_assoc_semiring R] [non_unital_non_assoc_semiring S] (f : R â‰ƒ+* S) : â‡‘f 0 = 0
theorem fin_succ_equiv'_zero {n : â„•} : fin_succ_equiv' 0 = fin_succ_equiv n
theorem complex.conj_conj {R : Type u} [comm_semiring R] [star_ring R] (x : R) : â‡‘(star_ring_end R) (â‡‘(star_ring_end R) x) = x
theorem submonoid.localization_map.map_mul_left {M : Type u_1} [comm_monoid M] {S : submonoid M} {N : Type u_2} [comm_monoid N] {P : Type u_3} [comm_monoid P] (f : S.localization_map N) {g : M â†’* P} {T : submonoid P} (hy : âˆ€ (y : â†¥S), â‡‘g â†‘y âˆˆ T) {Q : Type u_4} [comm_monoid Q] {k : T.localization_map Q} (z : N) : â‡‘(k.to_map) (â‡‘g â†‘((f.sec z).snd)) * â‡‘(f.map hy k) z = â‡‘(k.to_map) (â‡‘g (f.sec z).fst)
theorem category_theory.grothendieck_topology.superset_covering {C : Type u} [category_theory.category C] {X : C} {S R : category_theory.sieve X} (J : category_theory.grothendieck_topology C) (Hss : S â‰¤ R) (sjx : S âˆˆ â‡‘J X) : R âˆˆ â‡‘J X
theorem subfield.list_prod_mem {K : Type u} [field K] (s : subfield K) {l : list K} : (âˆ€ (x : K), x âˆˆ l â†’ x âˆˆ s) â†’ l.prod âˆˆ s
theorem affine.simplex.ext {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {n : â„•} {s1 s2 : affine.simplex k P n} (h : âˆ€ (i : fin (n + 1)), s1.points i = s2.points i) : s1 = s2
theorem measurable_set.image_of_measurable_inj_on {Î³ : Type u_3} [tÎ³ : topological_space Î³] [polish_space Î³] [measurable_space Î³] [borel_space Î³] {Î² : Type u_4} [tÎ² : topological_space Î²] [t2_space Î²] [measurable_space Î²] [borel_space Î²] {s : set Î³} {f : Î³ â†’ Î²} [topological_space.second_countable_topology Î²] (hs : measurable_set s) (f_meas : measurable f) (f_inj : set.inj_on f s) : measurable_set (f '' s)
theorem intermediate_field.fixing_subgroup_is_closed {K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (E : intermediate_field K L) [finite_dimensional K â†¥E] : is_closed â†‘(E.fixing_subgroup)
theorem finset.weighted_vsub_of_point_apply_const {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {Î¹ : Type u_4} (s : finset Î¹) (w : Î¹ â†’ k) (p b : P) : â‡‘(s.weighted_vsub_of_point (Î» (_x : Î¹), p) b) w = s.sum (Î» (i : Î¹), w i) â€¢ (p -áµ¥ b)
theorem list.nat.nodup_antidiagonal_tuple (k n : â„•) : (list.nat.antidiagonal_tuple k n).nodup
theorem finset.order_emb_of_fin_zero {Î± : Type u_1} [linear_order Î±] {s : finset Î±} {k : â„•} (h : s.card = k) (hz : 0 < k) : â‡‘(s.order_emb_of_fin h) âŸ¨0, hzâŸ© = s.min' _
theorem metric.Hausdorff_dist_zero_iff_closure_eq_closure {Î± : Type u} [pseudo_metric_space Î±] {s t : set Î±} (fin : emetric.Hausdorff_edist s t â‰  âŠ¤) : metric.Hausdorff_dist s t = 0 â†” closure s = closure t
theorem free_group.of_injective {Î± : Type u} : function.injective free_group.of
theorem mul_eq_zero_comm {Mâ‚€ : Type u_1} [mul_zero_class Mâ‚€] [no_zero_divisors Mâ‚€] {a b : Mâ‚€} : a * b = 0 â†” b * a = 0
theorem colex.colex_le_of_subset {Î± : Type u_1} [linear_order Î±] {A B : finset Î±} (h : A âŠ† B) : A.to_colex â‰¤ B.to_colex
theorem continuous_on.comp_fract' {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [linear_ordered_ring Î±] [floor_ring Î±] [topological_space Î±] [order_topology Î±] [topological_add_group Î±] [topological_space Î²] [topological_space Î³] {f : Î² â†’ Î± â†’ Î³} (h : continuous_on (function.uncurry f) (set.univ Ã—Ë¢ set.Icc 0 1)) (hf : âˆ€ (s : Î²), f s 0 = f s 1) : continuous (Î» (st : Î² Ã— Î±), f st.fst (int.fract st.snd))
theorem class_group.exists_mem_finset_approx {R : Type u_1} {S : Type u_2} [euclidean_domain R] [comm_ring S] [is_domain S] [algebra R S] {abv : absolute_value R â„¤} {Î¹ : Type u_5} [decidable_eq Î¹] [fintype Î¹] (bS : basis Î¹ R S) (adm : abv.is_admissible) [infinite R] [decidable_eq R] (a : S) {b : R} (hb : b â‰  0) : âˆƒ (q : S) (r : R) (H : r âˆˆ class_group.finset_approx bS adm), â‡‘abv (â‡‘(algebra.norm R) (r â€¢ a - b â€¢ q)) < â‡‘abv (â‡‘(algebra.norm R) (â‡‘(algebra_map R S) b))
theorem is_unit.mul_right_dvd {Î± : Type u_1} [monoid Î±] {a b u : Î±} (hu : is_unit u) : a * u âˆ£ b â†” a âˆ£ b
theorem padic_norm.padic_norm_p_lt_one {p : â„•} (hp : 1 < p) : padic_norm p â†‘p < 1
theorem fin.pred_succ_above_pred {n : â„•} {a : fin (n + 2)} {b : fin (n + 1)} (ha : a â‰  0) (hb : b â‰  0) (hk : â‡‘(a.succ_above) b â‰  0 := _) : â‡‘((a.pred ha).succ_above) (b.pred hb) = (â‡‘(a.succ_above) b).pred hk
theorem polynomial.alg_hom_ext' {R : Type u} {A' : Type u_1} {B' : Type u_2} [comm_semiring A'] [semiring B'] [comm_semiring R] [algebra R A'] [algebra R B'] {f g : polynomial A' â†’â‚[R] B'} (hâ‚ : f.comp (is_scalar_tower.to_alg_hom R A' (polynomial A')) = g.comp (is_scalar_tower.to_alg_hom R A' (polynomial A'))) (hâ‚‚ : â‡‘f polynomial.X = â‡‘g polynomial.X) : f = g
theorem monotone.forall_le_of_antitone {Î± : Type u} [semilattice_sup Î±] {Î² : Type u_1} [preorder Î²] {f g : Î± â†’ Î²} (hf : monotone f) (hg : antitone g) (h : f â‰¤ g) (m n : Î±) : f m â‰¤ g n
theorem polynomial.cyclotomic_eq_geom_sum {R : Type u_1} [comm_ring R] {p : â„•} (hp : nat.prime p) : polynomial.cyclotomic p R = (finset.range p).sum (Î» (i : â„•), polynomial.X ^ i)
theorem box_integral.integrable_of_continuous_on {Î¹ : Type u} {E : Type v} [normed_group E] [normed_space â„ E] [fintype Î¹] (l : box_integral.integration_params) [complete_space E] {I : box_integral.box Î¹} {f : (Î¹ â†’ â„) â†’ E} (hc : continuous_on f (â‡‘box_integral.box.Icc I)) (Î¼ : measure_theory.measure (Î¹ â†’ â„)) [measure_theory.is_locally_finite_measure Î¼] : box_integral.integrable I l f Î¼.to_box_additive.to_smul
theorem has_strict_fderiv_at.to_local_left_inverse {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] [cs : complete_space E] {f : E â†’ F} {f' : E â‰ƒL[ğ•œ] F} {a : E} (hf : has_strict_fderiv_at f â†‘f' a) {g : F â†’ E} (hg : âˆ€á¶  (x : E) in nhds a, g (f x) = x) : has_strict_fderiv_at g â†‘(f'.symm) (f a)
theorem category_theory.is_iso_of_mono_of_strong_epi {C : Type u} [category_theory.category C] {P Q : C} (f : P âŸ¶ Q) [category_theory.mono f] [category_theory.strong_epi f] : category_theory.is_iso f
theorem measure_theory.forall_measure_preimage_add_right_iff {G : Type u_1} [measurable_space G] [has_add G] [has_measurable_add G] (Î¼ : measure_theory.measure G) : (âˆ€ (g : G) (A : set G), measurable_set A â†’ â‡‘Î¼ ((Î» (h : G), h + g) â»Â¹' A) = â‡‘Î¼ A) â†” Î¼.is_add_right_invariant
theorem basis.to_matrix_mul_to_matrix {Î¹ : Type u_1} {Î¹' : Type u_2} {R : Type u_5} {M : Type u_6} [comm_semiring R] [add_comm_monoid M] [module R M] (b : basis Î¹ R M) (b' : basis Î¹' R M) {Î¹'' : Type u_3} [fintype Î¹'] (b'' : Î¹'' â†’ M) : (b.to_matrix â‡‘b').mul (b'.to_matrix b'') = b.to_matrix b''
theorem add_subgroup.closure_induction' {G : Type u_1} [add_group G] {k : set G} {p : Î  (x : G), x âˆˆ add_subgroup.closure k â†’ Prop} (Hs : âˆ€ (x : G) (h : x âˆˆ k), p x _) (H1 : p 0 _) (Hmul : âˆ€ (x : G) (hx : x âˆˆ add_subgroup.closure k) (y : G) (hy : y âˆˆ add_subgroup.closure k), p x hx â†’ p y hy â†’ p (x + y) _) (Hinv : âˆ€ (x : G) (hx : x âˆˆ add_subgroup.closure k), p x hx â†’ p (-x) _) {x : G} (hx : x âˆˆ add_subgroup.closure k) : p x hx
theorem homological_complex.eq_to_hom_comp_d {Î¹ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {c : complex_shape Î¹} (C : homological_complex V c) {i i' j : Î¹} (rij : c.rel i j) (rij' : c.rel i' j) : category_theory.eq_to_hom _ â‰« C.d i' j = C.d i j
theorem generalized_continued_fraction.exists_rat_eq_nth_convergent {K : Type u_1} [linear_ordered_field K] [floor_ring K] (v : K) (n : â„•) : âˆƒ (q : â„š), (generalized_continued_fraction.of v).convergents n = â†‘q
theorem ennreal.inner_le_Lp_mul_Lq {Î¹ : Type u} (s : finset Î¹) (f g : Î¹ â†’ ennreal) {p q : â„} (hpq : p.is_conjugate_exponent q) : s.sum (Î» (i : Î¹), f i * g i) â‰¤ s.sum (Î» (i : Î¹), f i ^ p) ^ (1 / p) * s.sum (Î» (i : Î¹), g i ^ q) ^ (1 / q)
theorem phragmen_lindelof.right_half_plane_of_tendsto_zero_on_real {E : Type u_1} [normed_group E] [normed_space â„‚ E] {C : â„} {f : â„‚ â†’ E} {z : â„‚} (hd : diff_cont_on_cl â„‚ f {z : â„‚ | 0 < z.re}) (hexp : âˆƒ (c : â„) (H : c < 2) (B : â„), f =O[filter.comap complex.abs filter.at_top âŠ“ filter.principal {z : â„‚ | 0 < z.re}] Î» (z : â„‚), real.exp (B * complex.abs z ^ c)) (hre : filter.tendsto (Î» (x : â„), f â†‘x) filter.at_top (nhds 0)) (him : âˆ€ (x : â„), âˆ¥f (â†‘x * complex.I)âˆ¥ â‰¤ C) (hz : 0 â‰¤ z.re) : âˆ¥f zâˆ¥ â‰¤ C
theorem cont_mdiff_on_of_locally_cont_mdiff_on {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners ğ•œ E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] {f : M â†’ M'} {s : set M} {n : with_top â„•} (h : âˆ€ (x : M), x âˆˆ s â†’ (âˆƒ (u : set M), is_open u âˆ§ x âˆˆ u âˆ§ cont_mdiff_on I I' n f (s âˆ© u))) : cont_mdiff_on I I' n f s
theorem mv_polynomial.hom_congr_vars {R : Type u} {S : Type v} {Ïƒ : Type u_1} [comm_semiring R] [comm_semiring S] {fâ‚ fâ‚‚ : mv_polynomial Ïƒ R â†’+* S} {pâ‚ pâ‚‚ : mv_polynomial Ïƒ R} (hC : fâ‚.comp mv_polynomial.C = fâ‚‚.comp mv_polynomial.C) (hv : âˆ€ (i : Ïƒ), i âˆˆ pâ‚.vars â†’ i âˆˆ pâ‚‚.vars â†’ â‡‘fâ‚ (mv_polynomial.X i) = â‡‘fâ‚‚ (mv_polynomial.X i)) (hp : pâ‚ = pâ‚‚) : â‡‘fâ‚ pâ‚ = â‡‘fâ‚‚ pâ‚‚
theorem is_smul_regular.pow {R : Type u_1} {M : Type u_3} {a : R} [monoid R] [mul_action R M] (n : â„•) (ra : is_smul_regular M a) : is_smul_regular M (a ^ n)
theorem lie_algebra.is_nilpotent_iff_forall {R : Type uâ‚} {L : Type uâ‚‚} [comm_ring R] [lie_ring L] [lie_algebra R L] [is_noetherian R L] : lie_algebra.is_nilpotent R L â†” âˆ€ (x : L), is_nilpotent (â‡‘(lie_algebra.ad R L) x)
theorem orthonormal.oangle_neg_self_left {V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) {x : V} (hx : x â‰  0) : hb.oangle (-x) x = â†‘real.pi
theorem formal_multilinear_series.id_apply_one' (ğ•œ : Type u_1) (E : Type u_2) [nondiscrete_normed_field ğ•œ] [normed_group E] [normed_space ğ•œ E] {n : â„•} (h : n = 1) (v : fin n â†’ E) : â‡‘(formal_multilinear_series.id ğ•œ E n) v = v âŸ¨0, _âŸ©
theorem affine_subspace.mem_direction_iff_eq_vsub {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : affine_subspace k P} (h : â†‘s.nonempty) (v : V) : v âˆˆ s.direction â†” âˆƒ (p1 : P) (H : p1 âˆˆ s) (p2 : P) (H : p2 âˆˆ s), v = p1 -áµ¥ p2
theorem normed_ring.summable_geometric_of_norm_lt_1 {R : Type u_4} [normed_ring R] [complete_space R] (x : R) (h : âˆ¥xâˆ¥ < 1) : summable (Î» (n : â„•), x ^ n)
theorem antilipschitz_with.of_le_mul_nndist {Î± : Type u_1} {Î² : Type u_2} [pseudo_metric_space Î±] [pseudo_metric_space Î²] {K : nnreal} {f : Î± â†’ Î²} : (âˆ€ (x y : Î±), has_nndist.nndist x y â‰¤ K * has_nndist.nndist (f x) (f y)) â†’ antilipschitz_with K f
theorem exp_char_one_iff_char_zero (R : Type u) [semiring R] [nontrivial R] (p q : â„•) [char_p R p] [exp_char R q] : q = 1 â†” p = 0
theorem affine_subspace.affine_span_eq_top_iff_vector_span_eq_top_of_nonempty (k : Type u_1) (V : Type u_2) (P : Type u_3) [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {s : set P} (hs : s.nonempty) : affine_span k s = âŠ¤ â†” vector_span k s = âŠ¤
theorem metric.totally_bounded_of_finite_discretization {Î± : Type u} [pseudo_metric_space Î±] {s : set Î±} (H : âˆ€ (Îµ : â„), Îµ > 0 â†’ (âˆƒ (Î² : Type u) (_x : fintype Î²) (F : â†¥s â†’ Î²), âˆ€ (x y : â†¥s), F x = F y â†’ has_dist.dist â†‘x â†‘y < Îµ)) : totally_bounded s
theorem is_chain.exists_max_chain {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} {c : set Î±} (hc : is_chain r c) : âˆƒ (M : set Î±), is_max_chain r M âˆ§ c âŠ† M
theorem prod.map_comp_map {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} {Î´ : Type u_4} {Îµ : Type u_5} {Î¶ : Type u_6} (f : Î± â†’ Î²) (f' : Î³ â†’ Î´) (g : Î² â†’ Îµ) (g' : Î´ â†’ Î¶) : prod.map g g' âˆ˜ prod.map f f' = prod.map (g âˆ˜ f) (g' âˆ˜ f')
theorem multilinear_map.map_piecewise_smul {R : Type u} {Î¹ : Type u'} {Mâ‚ : Î¹ â†’ Type vâ‚} {Mâ‚‚ : Type vâ‚‚} [decidable_eq Î¹] [comm_semiring R] [Î  (i : Î¹), add_comm_monoid (Mâ‚ i)] [add_comm_monoid Mâ‚‚] [Î  (i : Î¹), module R (Mâ‚ i)] [module R Mâ‚‚] (f : multilinear_map R Mâ‚ Mâ‚‚) (c : Î¹ â†’ R) (m : Î  (i : Î¹), Mâ‚ i) (s : finset Î¹) : â‡‘f (s.piecewise (Î» (i : Î¹), c i â€¢ m i) m) = s.prod (Î» (i : Î¹), c i) â€¢ â‡‘f m
theorem gauge_nonneg {E : Type u_1} [add_comm_group E] [module â„ E] {s : set E} (x : E) : 0 â‰¤ gauge s x
theorem category_theory.presieve.family_of_elements.compatible.sieve_extend {C : Type uâ‚} [category_theory.category C] {P : Cáµ’áµ– â¥¤ Type w} {X : C} {R : category_theory.presieve X} {x : category_theory.presieve.family_of_elements P R} (hx : x.compatible) : x.sieve_extend.compatible
theorem interior_frontier {Î± : Type u} [topological_space Î±] {s : set Î±} (h : is_closed s) : interior (frontier s) = âˆ…
theorem subring.multiset_prod_mem {R : Type u_1} [comm_ring R] (s : subring R) (m : multiset R) : (âˆ€ (a : R), a âˆˆ m â†’ a âˆˆ s) â†’ m.prod âˆˆ s
theorem first_order.language.Structure.cg_iff {L : first_order.language} {M : Type u_3} [L.Structure M] : first_order.language.Structure.cg L M â†” âˆƒ (S : set M), S.countable âˆ§ â‡‘(first_order.language.substructure.closure L) S = âŠ¤
theorem complex.has_deriv_at_Gamma_integral {s : â„‚} (hs : 1 < s.re) : measure_theory.integrable_on (Î» (x : â„), â†‘(real.exp (-x)) * â†‘(real.log x) * â†‘x ^ (s - 1)) (set.Ioi 0) measure_theory.measure_space.volume âˆ§ has_deriv_at complex.Gamma_integral (âˆ« (x : â„) in set.Ioi 0, â†‘(real.exp (-x)) * â†‘(real.log x) * â†‘x ^ (s - 1)) s
theorem category_theory.limits.has_pushout_symmetry {C : Type u} [category_theory.category C] {X Y Z : C} (f : X âŸ¶ Y) (g : X âŸ¶ Z) [category_theory.limits.has_pushout f g] : category_theory.limits.has_pushout g f
theorem isometry.embedding {Î± : Type u} {Î² : Type v} [emetric_space Î±] [pseudo_emetric_space Î²] {f : Î± â†’ Î²} (hf : isometry f) : embedding f
theorem monoid_hom.unop_map_list_prod {M : Type u_3} {N : Type u_4} [monoid M] [monoid N] (f : M â†’* Náµáµ’áµ–) (l : list M) : mul_opposite.unop (â‡‘f l.prod) = (list.map (mul_opposite.unop âˆ˜ â‡‘f) l).reverse.prod
theorem continuous_linear_map.adjoint_inner_right {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] [inner_product_space ğ•œ F] [complete_space E] [complete_space F] (A : E â†’L[ğ•œ] F) (x : E) (y : F) : has_inner.inner x (â‡‘(â‡‘continuous_linear_map.adjoint A) y) = has_inner.inner (â‡‘A x) y
theorem valuation.supp_quot {R : Type u_2} {Î“â‚€ : Type u_3} [comm_ring R] [linear_ordered_comm_monoid_with_zero Î“â‚€] (v : valuation R Î“â‚€) {J : ideal R} (hJ : J â‰¤ v.supp) : (v.on_quot hJ).supp = ideal.map (ideal.quotient.mk J) v.supp
theorem finset.order_emb_of_fin_eq_order_emb_of_fin_iff {Î± : Type u_1} [linear_order Î±] {k l : â„•} {s : finset Î±} {i : fin k} {j : fin l} {h : s.card = k} {h' : s.card = l} : â‡‘(s.order_emb_of_fin h) i = â‡‘(s.order_emb_of_fin h') j â†” â†‘i = â†‘j
theorem mem_omega_limit_iff_frequentlyâ‚‚ {Ï„ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [topological_space Î²] (f : filter Ï„) (Ï• : Ï„ â†’ Î± â†’ Î²) (s : set Î±) (y : Î²) : y âˆˆ omega_limit f Ï• s â†” âˆ€ (n : set Î²), n âˆˆ nhds y â†’ (âˆƒá¶  (t : Ï„) in f, (Ï• t '' s âˆ© n).nonempty)
theorem cont_diff_within_at.prod {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {G : Type u_4} [normed_group G] [normed_space ğ•œ G] {x : E} {n : with_top â„•} {s : set E} {f : E â†’ F} {g : E â†’ G} (hf : cont_diff_within_at ğ•œ n f s x) (hg : cont_diff_within_at ğ•œ n g s x) : cont_diff_within_at ğ•œ n (Î» (x : E), (f x, g x)) s x
theorem span_fourier_closure_eq_top  : (submodule.span â„‚ (set.range fourier)).topological_closure = âŠ¤
theorem monotone_on.map_bdd_below {Î± : Type u} {Î² : Type v} [preorder Î±] [preorder Î²] {f : Î± â†’ Î²} {s t : set Î±} (Hf : monotone_on f t) (Hst : s âŠ† t) : (lower_bounds s âˆ© t).nonempty â†’ bdd_below (f '' s)
theorem measure_theory.add_haar_image_le_mul_of_det_lt {E : Type u_1} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] [measurable_space E] [borel_space E] (Î¼ : measure_theory.measure E) [Î¼.is_add_haar_measure] (A : E â†’L[â„] E) {m : nnreal} (hm : ennreal.of_real |A.det| < â†‘m) : âˆ€á¶  (Î´ : nnreal) in nhds_within 0 (set.Ioi 0), âˆ€ (s : set E) (f : E â†’ E), approximates_linear_on f A s Î´ â†’ â‡‘Î¼ (f '' s) â‰¤ â†‘m * â‡‘Î¼ s
theorem filter.tendsto.mul_at_bot {Î± : Type u} {Î² : Type v} [linear_ordered_field Î±] [topological_space Î±] [order_topology Î±] {l : filter Î²} {f g : Î² â†’ Î±} {C : Î±} (hC : 0 < C) (hf : filter.tendsto f l (nhds C)) (hg : filter.tendsto g l filter.at_bot) : filter.tendsto (Î» (x : Î²), f x * g x) l filter.at_bot
theorem category_theory.limits.has_finite_biproducts.of_has_finite_products {C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_finite_products C] : category_theory.limits.has_finite_biproducts C
theorem add_submonoid.localization_map.lift_spec_add {M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {N : Type u_2} [add_comm_monoid N] {P : Type u_3} [add_comm_monoid P] (f : S.localization_map N) {g : M â†’+ P} (hg : âˆ€ (y : â†¥S), is_add_unit (â‡‘g â†‘y)) (z : N) (w v : P) : â‡‘(f.lift hg) z + w = v â†” â‡‘g (f.sec z).fst + w = â‡‘g â†‘((f.sec z).snd) + v
theorem is_smul_regular.mul_and_mul_iff {R : Type u_1} {M : Type u_3} {a b : R} [has_scalar R M] [has_mul R] [is_scalar_tower R R M] : is_smul_regular M (a * b) âˆ§ is_smul_regular M (b * a) â†” is_smul_regular M a âˆ§ is_smul_regular M b
theorem strict_concave_on_of_deriv2_neg {D : set â„} (hD : convex â„ D) {f : â„ â†’ â„} (hf : continuous_on f D) (hf' : differentiable_on â„ f (interior D)) (hf'' : âˆ€ (x : â„), x âˆˆ interior D â†’ deriv^[2] f x < 0) : strict_concave_on â„ D f
theorem matrix.is_hermitian.from_blocks {Î± : Type u_1} {m : Type u_3} {n : Type u_4} [non_unital_semiring Î±] [star_ring Î±] {A : matrix m m Î±} {B : matrix m n Î±} {C : matrix n m Î±} {D : matrix n n Î±} (hA : A.is_hermitian) (hBC : B.conj_transpose = C) (hD : D.is_hermitian) : (matrix.from_blocks A B C D).is_hermitian
theorem finite_dimensional.finrank_map_le (K : Type u) {V : Type v} [division_ring K] [add_comm_group V] [module K V] {Vâ‚‚ : Type v'} [add_comm_group Vâ‚‚] [module K Vâ‚‚] (f : V â†’â‚—[K] Vâ‚‚) (p : submodule K V) [finite_dimensional K â†¥p] : finite_dimensional.finrank K â†¥(submodule.map f p) â‰¤ finite_dimensional.finrank K â†¥p
theorem vsub_right_cancel_iff {G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] {p1 p2 p : P} : p -áµ¥ p1 = p -áµ¥ p2 â†” p1 = p2
theorem quotient_norm_add_le {M : Type u_1} [semi_normed_group M] (S : add_subgroup M) (x y : M â§¸ S) : âˆ¥x + yâˆ¥ â‰¤ âˆ¥xâˆ¥ + âˆ¥yâˆ¥
theorem category_theory.mem_ess_image_of_unit_is_iso {C : Type uâ‚} {D : Type uâ‚‚} [category_theory.category C] [category_theory.category D] {i : D â¥¤ C} [category_theory.is_right_adjoint i] (A : C) [category_theory.is_iso ((category_theory.adjunction.of_right_adjoint i).unit.app A)] : A âˆˆ i.ess_image
theorem category_theory.limits.complete_lattice.prod_eq_inf {Î± : Type u} [semilattice_inf Î±] [order_top Î±] (x y : Î±) : (x â¨¯ y) = x âŠ“ y
theorem list.split_wrt_composition_join {Î± : Type u_1} (L : list (list Î±)) (c : composition L.join.length) (h : list.map list.length L = c.blocks) : L.join.split_wrt_composition c = L
theorem matrix.circulant_smul {Î± : Type u_1} {n : Type u_4} {R : Type u_5} [has_sub n] [has_scalar R Î±] (k : R) (v : n â†’ Î±) : matrix.circulant (k â€¢ v) = k â€¢ matrix.circulant v
theorem affine_subspace.vadd_mem_iff_mem_direction {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : affine_subspace k P} (v : V) {p : P} (hp : p âˆˆ s) : v +áµ¥ p âˆˆ s â†” v âˆˆ s.direction
theorem is_noetherian_of_tower (R : Type u_1) {S : Type u_2} {M : Type u_3} [semiring R] [semiring S] [add_comm_monoid M] [has_scalar R S] [module S M] [module R M] [is_scalar_tower R S M] (h : is_noetherian R M) : is_noetherian S M
theorem category_theory.is_connected_of_zigzag {J : Type uâ‚} [category_theory.category J] [nonempty J] (h : âˆ€ (jâ‚ jâ‚‚ : J), âˆƒ (l : list J), list.chain category_theory.zag jâ‚ l âˆ§ (jâ‚ :: l).last _ = jâ‚‚) : category_theory.is_connected J
theorem ideal.is_maximal_of_is_maximal_disjoint {R : Type u_1} {S : Type u_2} [comm_ring R] [comm_ring S] (y : R) [algebra R S] [is_localization.away y S] [ideal.is_jacobson R] (I : ideal R) (hI : I.is_maximal) (hy : y âˆ‰ I) : (ideal.map (algebra_map R S) I).is_maximal
theorem continuous_map.subalgebra_is_R_or_C_topological_closure_eq_top_of_separates_points {ğ•œ : Type u_1} {X : Type u_2} [is_R_or_C ğ•œ] [topological_space X] [compact_space X] (A : subalgebra ğ•œ C(X, ğ•œ)) (hA : A.separates_points) (hA' : continuous_map.conj_invariant_subalgebra (subalgebra.restrict_scalars â„ A)) : A.topological_closure = âŠ¤
theorem is_open_iff_ball_subset {Î± : Type u_1} [uniform_space Î±] {s : set Î±} : is_open s â†” âˆ€ (x : Î±), x âˆˆ s â†’ (âˆƒ (V : set (Î± Ã— Î±)) (H : V âˆˆ uniformity Î±), uniform_space.ball x V âŠ† s)
theorem matrix.pivot.exists_list_transvec_mul_mul_list_transvec_eq_diagonal_aux {ğ•œ : Type u_3} [field ğ•œ] (n : Type) [fintype n] [decidable_eq n] (M : matrix n n ğ•œ) : âˆƒ (L L' : list (matrix.transvection_struct n ğ•œ)) (D : n â†’ ğ•œ), ((list.map matrix.transvection_struct.to_matrix L).prod.mul M).mul (list.map matrix.transvection_struct.to_matrix L').prod = matrix.diagonal D
theorem affine.simplex.face_centroid_eq_iff {k : Type u_1} {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] [char_zero k] {n : â„•} (s : affine.simplex k P n) {fsâ‚ fsâ‚‚ : finset (fin (n + 1))} {mâ‚ mâ‚‚ : â„•} (hâ‚ : fsâ‚.card = mâ‚ + 1) (hâ‚‚ : fsâ‚‚.card = mâ‚‚ + 1) : finset.centroid k finset.univ (s.face hâ‚).points = finset.centroid k finset.univ (s.face hâ‚‚).points â†” fsâ‚ = fsâ‚‚
theorem con.lift_range {M : Type u_1} {P : Type u_3} [mul_one_class M] [mul_one_class P] {c : con M} {f : M â†’* P} (H : c â‰¤ con.ker f) : (c.lift f H).mrange = f.mrange
theorem topological_group_of_lie_group {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {H : Type u_2} [topological_space H] {E : Type u_3} [normed_group E] [normed_space ğ•œ E] (I : model_with_corners ğ•œ E H) {G : Type u_5} [topological_space G] [charted_space H G] [group G] [lie_group I G] : topological_group G
theorem metric.uniform_continuous_inf_dist_pt {Î± : Type u} [pseudo_metric_space Î±] (s : set Î±) : uniform_continuous (Î» (x : Î±), metric.inf_dist x s)
theorem ideal.is_maximal_iff_is_maximal_disjoint {R : Type u_1} (S : Type u_2) [comm_ring R] [comm_ring S] (y : R) [algebra R S] [is_localization.away y S] [H : ideal.is_jacobson R] (J : ideal S) : J.is_maximal â†” (ideal.comap (algebra_map R S) J).is_maximal âˆ§ y âˆ‰ ideal.comap (algebra_map R S) J
theorem continuous_map.homotopy.heq_path_of_eq_image {Xâ‚ Xâ‚‚ Y : Top} {f : C(â†¥Xâ‚, â†¥Y)} {g : C(â†¥Xâ‚‚, â†¥Y)} {xâ‚€ xâ‚ : â†¥Xâ‚} {xâ‚‚ xâ‚ƒ : â†¥Xâ‚‚} {p : path xâ‚€ xâ‚} {q : path xâ‚‚ xâ‚ƒ} (hfg : âˆ€ (t : â†¥unit_interval), â‡‘f (â‡‘p t) = â‡‘g (â‡‘q t)) : (fundamental_groupoid.fundamental_groupoid_functor.map f).map âŸ¦pâŸ§ == (fundamental_groupoid.fundamental_groupoid_functor.map g).map âŸ¦qâŸ§
theorem setoid.eq_eqv_class_of_mem {Î± : Type u_1} {c : set (set Î±)} (H : âˆ€ (a : Î±), âˆƒ! (b : set Î±) (H : b âˆˆ c), a âˆˆ b) {s : set Î±} {y : Î±} (hs : s âˆˆ c) (hy : y âˆˆ s) : s = {x : Î± | (setoid.mk_classes c H).rel x y}
theorem measurable_set_of_differentiable_within_at_Ici_of_is_complete {F : Type u_1} [normed_group F] [normed_space â„ F] (f : â„ â†’ F) {K : set F} (hK : is_complete K) : measurable_set {x : â„ | differentiable_within_at â„ f (set.Ici x) x âˆ§ deriv_within f (set.Ici x) x âˆˆ K}
theorem category_theory.subobject.inf_pullback {C : Type uâ‚} [category_theory.category C] [category_theory.limits.has_pullbacks C] {X Y : C} (g : X âŸ¶ Y) (fâ‚ fâ‚‚ : category_theory.subobject Y) : (category_theory.subobject.pullback g).obj (fâ‚ âŠ“ fâ‚‚) = (category_theory.subobject.pullback g).obj fâ‚ âŠ“ (category_theory.subobject.pullback g).obj fâ‚‚
theorem ring_hom.unop_map_list_prod {Î² : Type u} {Î³ : Type w} [semiring Î²] [semiring Î³] (f : Î² â†’+* Î³áµáµ’áµ–) (l : list Î²) : mul_opposite.unop (â‡‘f l.prod) = (list.map (mul_opposite.unop âˆ˜ â‡‘f) l).reverse.prod
theorem ordinal.principal_mul_iff_le_two_or_omega_opow_opow {o : ordinal} : ordinal.principal has_mul.mul o â†” o â‰¤ 2 âˆ¨ âˆƒ (a : ordinal), o = ordinal.omega ^ ordinal.omega ^ a
theorem simple_graph.degree_le_max_degree {V : Type u} (G : simple_graph V) [fintype V] [decidable_rel G.adj] (v : V) : G.degree v â‰¤ G.max_degree
theorem homotopy.null_homotopic_map_comp {Î¹ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape Î¹} {C D E : homological_complex V c} (hom : Î  (i j : Î¹), C.X i âŸ¶ D.X j) (g : D âŸ¶ E) : homotopy.null_homotopic_map hom â‰« g = homotopy.null_homotopic_map (Î» (i j : Î¹), hom i j â‰« g.f j)
theorem orientation.rotation_eq_basis_rotation {V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) (h : b.orientation = o) (Î¸ : â„) : o.rotation â†‘Î¸ = hb.rotation â†‘Î¸
theorem intermediate_field.multiset_prod_mem {K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) (m : multiset L) : (âˆ€ (a : L), a âˆˆ m â†’ a âˆˆ S) â†’ m.prod âˆˆ S
theorem discrete_valuation_ring.of_ufd_of_unique_irreducible {R : Type u} [comm_ring R] [is_domain R] [unique_factorization_monoid R] (hâ‚ : âˆƒ (p : R), irreducible p) (hâ‚‚ : âˆ€ â¦ƒp q : Râ¦„, irreducible p â†’ irreducible q â†’ associated p q) : discrete_valuation_ring R
theorem function.semiconj.maps_to_fixed_pts {Î± : Type u} {Î² : Type v} {fa : Î± â†’ Î±} {fb : Î² â†’ Î²} {g : Î± â†’ Î²} (h : function.semiconj g fa fb) : set.maps_to g (function.fixed_points fa) (function.fixed_points fb)
theorem discrete_valuation_ring.exists_irreducible (R : Type u) [comm_ring R] [is_domain R] [discrete_valuation_ring R] : âˆƒ (Ï– : R), irreducible Ï–
theorem right.one_le_mul {Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_mul.mul) has_le.le] {a b : Î±} (ha : 1 â‰¤ a) (hb : 1 â‰¤ b) : 1 â‰¤ a * b
theorem is_closed.exists_closed_singleton {Î± : Type u_1} [topological_space Î±] [t0_space Î±] [compact_space Î±] {S : set Î±} (hS : is_closed S) (hne : S.nonempty) : âˆƒ (x : Î±), x âˆˆ S âˆ§ is_closed {x}
theorem sum_div_nat_floor_pow_sq_le_div_sq (N : â„•) {j : â„} (hj : 0 < j) {c : â„} (hc : 1 < c) : (finset.filter (Î» (i : â„•), j < â†‘âŒŠc ^ iâŒ‹â‚Š) (finset.range N)).sum (Î» (i : â„•), 1 / â†‘âŒŠc ^ iâŒ‹â‚Š ^ 2) â‰¤ c ^ 5 * (c - 1)â»Â¹ ^ 3 / j ^ 2
theorem linear_independent_le_span {R : Type u} [ring R] [strong_rank_condition R] {M : Type v} [add_comm_group M] [module R M] {Î¹ : Type u_1} (v : Î¹ â†’ M) (i : linear_independent R v) (w : set M) [fintype â†¥w] (s : submodule.span R w = âŠ¤) : cardinal.mk Î¹ â‰¤ â†‘(fintype.card â†¥w)
theorem inv_le_of_inv_le' {Î± : Type u} [group Î±] [has_le Î±] [covariant_class Î± Î± has_mul.mul has_le.le] [covariant_class Î± Î± (function.swap has_mul.mul) has_le.le] {a b : Î±} : aâ»Â¹ â‰¤ b â†’ bâ»Â¹ â‰¤ a
theorem real.inner_le_Lp_mul_Lq_of_nonneg {Î¹ : Type u} (s : finset Î¹) {f g : Î¹ â†’ â„} {p q : â„} (hpq : p.is_conjugate_exponent q) (hf : âˆ€ (i : Î¹), i âˆˆ s â†’ 0 â‰¤ f i) (hg : âˆ€ (i : Î¹), i âˆˆ s â†’ 0 â‰¤ g i) : s.sum (Î» (i : Î¹), f i * g i) â‰¤ s.sum (Î» (i : Î¹), f i ^ p) ^ (1 / p) * s.sum (Î» (i : Î¹), g i ^ q) ^ (1 / q)
theorem metric.second_countable_of_countable_discretization {Î± : Type u} [metric_space Î±] (H : âˆ€ (Îµ : â„), Îµ > 0 â†’ (âˆƒ (Î² : Type u_1) (_x : encodable Î²) (F : Î± â†’ Î²), âˆ€ (x y : Î±), F x = F y â†’ has_dist.dist x y â‰¤ Îµ)) : topological_space.second_countable_topology Î±
theorem vector_span_singleton (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (p : P) : vector_span k {p} = âŠ¥
theorem zero_lt.left.mul_le_one_of_le_of_le {Î± : Type u} {a b : Î±} [mul_zero_one_class Î±] [partial_order Î±] [zero_lt.pos_mul_mono Î±] (ha : a â‰¤ 1) (hb : b â‰¤ 1) (a0 : 0 â‰¤ a) : a * b â‰¤ 1
theorem add_monoid_algebra.alg_hom_ext' {k : Type uâ‚} {G : Type uâ‚‚} [comm_semiring k] [add_monoid G] {A : Type uâ‚ƒ} [semiring A] [algebra k A] â¦ƒÏ†â‚ Ï†â‚‚ : add_monoid_algebra k G â†’â‚[k] Aâ¦„ (h : â†‘Ï†â‚.comp (add_monoid_algebra.of k G) = â†‘Ï†â‚‚.comp (add_monoid_algebra.of k G)) : Ï†â‚ = Ï†â‚‚
theorem has_sum_sum_of_ne_finset_zero {Î± : Type u_1} {Î² : Type u_2} [add_comm_monoid Î±] [topological_space Î±] {f : Î² â†’ Î±} {s : finset Î²} (hf : âˆ€ (b : Î²), b âˆ‰ s â†’ f b = 0) : has_sum f (s.sum (Î» (b : Î²), f b))
theorem has_ftaylor_series_up_to_on.differentiable_at {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {s : set E} {f : E â†’ F} {x : E} {n : with_top â„•} {p : E â†’ formal_multilinear_series ğ•œ E F} (h : has_ftaylor_series_up_to_on n f p s) (hn : 1 â‰¤ n) (hx : s âˆˆ nhds x) : differentiable_at ğ•œ f x
theorem matrix.circulant_mul {Î± : Type u_1} {n : Type u_4} [semiring Î±] [fintype n] [add_group n] (v w : n â†’ Î±) : (matrix.circulant v).mul (matrix.circulant w) = matrix.circulant ((matrix.circulant v).mul_vec w)
theorem add_submonoid.localization_map.lift_spec {M : Type u_1} [add_comm_monoid M] {S : add_submonoid M} {N : Type u_2} [add_comm_monoid N] {P : Type u_3} [add_comm_monoid P] (f : S.localization_map N) {g : M â†’+ P} (hg : âˆ€ (y : â†¥S), is_add_unit (â‡‘g â†‘y)) (z : N) (v : P) : â‡‘(f.lift hg) z = v â†” â‡‘g (f.sec z).fst = â‡‘g â†‘((f.sec z).snd) + v
theorem quotient_norm_neg {M : Type u_1} [semi_normed_group M] {S : add_subgroup M} (x : M â§¸ S) : âˆ¥-xâˆ¥ = âˆ¥xâˆ¥
theorem add_monoid_hom.mul_op_ext {Î± : Type u_1} {Î² : Type u_2} [add_zero_class Î±] [add_zero_class Î²] (f g : Î±áµáµ’áµ– â†’+ Î²) (h : f.comp mul_opposite.op_add_equiv.to_add_monoid_hom = g.comp mul_opposite.op_add_equiv.to_add_monoid_hom) : f = g
theorem category_theory.is_preconnected_induction {J : Type uâ‚} [category_theory.category J] [category_theory.is_preconnected J] (Z : J â†’ Sort u_1) (hâ‚ : Î  {jâ‚ jâ‚‚ : J}, (jâ‚ âŸ¶ jâ‚‚) â†’ Z jâ‚ â†’ Z jâ‚‚) (hâ‚‚ : Î  {jâ‚ jâ‚‚ : J}, (jâ‚ âŸ¶ jâ‚‚) â†’ Z jâ‚‚ â†’ Z jâ‚) {jâ‚€ : J} (x : Z jâ‚€) (j : J) : nonempty (Z j)
theorem measure_theory.measure.add_haar_eq_zero_of_disjoint_translates {E : Type u_1} [normed_group E] [normed_space â„ E] [measurable_space E] [borel_space E] [finite_dimensional â„ E] (Î¼ : measure_theory.measure E) [Î¼.is_add_haar_measure] {s : set E} (u : â„• â†’ E) (hu : metric.bounded (set.range u)) (hs : pairwise (disjoint on Î» (n : â„•), {u n} + s)) (h's : measurable_set s) : â‡‘Î¼ s = 0
theorem bounded_continuous_function.continuous_eval {Î± : Type u} {Î² : Type v} [topological_space Î±] [pseudo_metric_space Î²] : continuous (Î» (p : bounded_continuous_function Î± Î² Ã— Î±), â‡‘(p.fst) p.snd)
theorem eq_orthogonal_projection_of_mem_orthogonal {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {K : submodule ğ•œ E} [complete_space â†¥K] {u v : E} (hv : v âˆˆ K) (hvo : u - v âˆˆ Ká—®) : â†‘(â‡‘(orthogonal_projection K) u) = v
theorem linear_independent.map' {Î¹ : Type u_1} {R : Type u_3} {M : Type u_5} {M' : Type u_6} {v : Î¹ â†’ M} [semiring R] [add_comm_monoid M] [add_comm_monoid M'] [module R M] [module R M'] (hv : linear_independent R v) (f : M â†’â‚—[R] M') (hf_inj : f.ker = âŠ¥) : linear_independent R (â‡‘f âˆ˜ v)
theorem abs_inner_le_norm {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] (x y : E) : is_R_or_C.abs (has_inner.inner x y) â‰¤ âˆ¥xâˆ¥ * âˆ¥yâˆ¥
theorem submodule.supr_eq_to_submodule_range {Î¹ : Type u_1} {S : Type u_3} {R : Type u_4} [decidable_eq Î¹] [add_monoid Î¹] [comm_semiring S] [semiring R] [algebra S R] (A : Î¹ â†’ submodule S R) [set_like.graded_monoid A] : (â¨† (i : Î¹), A i) = (direct_sum.coe_alg_hom A).range.to_submodule
theorem measure_theory.outer_measure.binfi_apply' {Î± : Type u_1} {Î¹ : Type u_2} (I : set Î¹) (m : Î¹ â†’ measure_theory.outer_measure Î±) {s : set Î±} (hs : s.nonempty) : (â‡‘â¨… (i : Î¹) (H : i âˆˆ I), m i) s = â¨… (t : â„• â†’ set Î±) (h2 : s âŠ† set.Union t), âˆ‘' (n : â„•), â¨… (i : Î¹) (H : i âˆˆ I), â‡‘(m i) (t n)
theorem norm_sub_pow_two {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {x y : E} : âˆ¥x - yâˆ¥ ^ 2 = âˆ¥xâˆ¥ ^ 2 - 2 * â‡‘is_R_or_C.re (has_inner.inner x y) + âˆ¥yâˆ¥ ^ 2
theorem direct_sum.is_internal.is_compl {R : Type u} [semiring R] {Î¹ : Type v} [dec_Î¹ : decidable_eq Î¹] {M : Type u_1} [add_comm_monoid M] [module R M] {A : Î¹ â†’ submodule R M} {i j : Î¹} (hij : i â‰  j) (h : set.univ = {i, j}) (hi : direct_sum.is_internal A) : is_compl (A i) (A j)
theorem measure_theory.integral_eq_zero_of_mul_left_eq_neg {G : Type u_4} {E : Type u_5} [measurable_space G] [normed_group E] [normed_space â„ E] [complete_space E] {Î¼ : measure_theory.measure G} {f : G â†’ E} {g : G} [group G] [has_measurable_mul G] [Î¼.is_mul_left_invariant] (hf' : âˆ€ (x : G), f (g * x) = -f x) : âˆ« (x : G), f x âˆ‚Î¼ = 0
theorem category_theory.limits.coequalizer.Ï€_of_eq {C : Type u} [category_theory.category C] {X Y : C} {f g : X âŸ¶ Y} [category_theory.limits.has_coequalizer f g] (h : f = g) : category_theory.is_iso (category_theory.limits.coequalizer.Ï€ f g)
theorem interval_integral.fderiv_integral {E : Type u_3} [normed_group E] [complete_space E] [normed_space â„ E] {f : â„ â†’ E} {a b : â„} (hf : interval_integrable f measure_theory.measure_space.volume a b) (hmeas_a : strongly_measurable_at_filter f (nhds a) measure_theory.measure_space.volume) (hmeas_b : strongly_measurable_at_filter f (nhds b) measure_theory.measure_space.volume) (ha : continuous_at f a) (hb : continuous_at f b) : fderiv â„ (Î» (p : â„ Ã— â„), âˆ« (x : â„) in p.fst..p.snd, f x) (a, b) = (continuous_linear_map.snd â„ â„ â„).smul_right (f b) - (continuous_linear_map.fst â„ â„ â„).smul_right (f a)
theorem exp_neg_integrable_on_Ioi (a : â„) {b : â„} (h : 0 < b) : measure_theory.integrable_on (Î» (x : â„), real.exp (-b * x)) (set.Ioi a) measure_theory.measure_space.volume
theorem polynomial.cyclotomic'_splits {K : Type u_1} [field K] (n : â„•) : polynomial.splits (ring_hom.id K) (polynomial.cyclotomic' n K)
theorem category_theory.sieve.generate_of_contains_split_epi {C : Type uâ‚} [category_theory.category C] {X Y : C} {R : category_theory.presieve X} (f : Y âŸ¶ X) [category_theory.split_epi f] (hf : R f) : category_theory.sieve.generate R = âŠ¤
theorem set.Inter_eq_Inter_finset' {Î± : Type u_1} {Î¹' : Sort u_5} (s : Î¹' â†’ set Î±) : (â‹‚ (i : Î¹'), s i) = â‹‚ (t : finset (plift Î¹')) (i : plift Î¹') (H : i âˆˆ t), s i.down
theorem vector.map_id {Î± : Type u_1} {n : â„•} (v : vector Î± n) : vector.map id v = v
theorem algebra.finite_presentation.mv_polynomial_of_finite_presentation {R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] (hfp : algebra.finite_presentation R A) (Î¹ : Type u_3) [fintype Î¹] : algebra.finite_presentation R (mv_polynomial Î¹ A)
theorem monotone.map_bdd_below {Î± : Type u} {Î² : Type v} [preorder Î±] [preorder Î²] {f : Î± â†’ Î²} (Hf : monotone f) {s : set Î±} : bdd_below s â†’ bdd_below (f '' s)
theorem measure_theory.measure.restrict_to_outer_measure_eq_to_outer_measure_restrict {Î± : Type u_1} {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {s : set Î±} (h : measurable_set s) : (Î¼.restrict s).to_outer_measure = â‡‘(measure_theory.outer_measure.restrict s) Î¼.to_outer_measure
theorem set.finite_of_fintype {Î± : Type u} (s : set Î±) [h : fintype â†¥s] : s.finite
theorem padic_val_rat.defn (p : â„•) [p_prime : fact (nat.prime p)] {q : â„š} {n d : â„¤} (hqz : q â‰  0) (qdf : q = rat.mk n d) : padic_val_rat p q = â†‘((multiplicity â†‘p n).get _) - â†‘((multiplicity â†‘p d).get _)
theorem Top.presheaf.covering_of_presieve.first_obj_iso_pi_opens_Ï€ {C : Type u} [category_theory.category C] [category_theory.limits.has_products C] {X : Top} (F : Top.presheaf C X) (U : topological_space.opens â†¥X) (R : category_theory.presieve U) (f : Î£ (V : topological_space.opens â†¥X), {f // R f}) : (Top.presheaf.covering_of_presieve.first_obj_iso_pi_opens F U R).hom â‰« category_theory.limits.pi.Ï€ (Î» (i : Î£ (V : topological_space.opens â†¥X), {f // R f}), F.obj (opposite.op (Top.presheaf.covering_of_presieve U R i))) f = category_theory.limits.pi.Ï€ (Î» (f : Î£ (V : topological_space.opens â†¥X), {f // R f}), F.obj (opposite.op f.fst)) f
theorem lower_central_series_length_eq_nilpotency_class {G : Type u_1} [group G] [hG : group.is_nilpotent G] : nat.find _ = group.nilpotency_class G
theorem is_local_min_on.has_fderiv_within_at_eq_zero {E : Type u} [normed_group E] [normed_space â„ E] {f : E â†’ â„} {a : E} {f' : E â†’L[â„] â„} {s : set E} (h : is_local_min_on f s a) (hf : has_fderiv_within_at f f' s a) {y : E} (hy : y âˆˆ pos_tangent_cone_at s a) (hy' : -y âˆˆ pos_tangent_cone_at s a) : â‡‘f' y = 0
theorem norm_add_mul_self_real {F : Type u_3} [inner_product_space â„ F] {x y : F} : âˆ¥x + yâˆ¥ * âˆ¥x + yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + 2 * has_inner.inner x y + âˆ¥yâˆ¥ * âˆ¥yâˆ¥
theorem intermediate_field.smul_mem {K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) {y : L} : y âˆˆ S â†’ âˆ€ {x : K}, x â€¢ y âˆˆ S
theorem category_theory.idempotents.to_karoubi_comp_karoubi_functor_category_embedding (J : Type u_1) (C : Type u_2) [category_theory.category J] [category_theory.category C] : category_theory.idempotents.to_karoubi (J â¥¤ C) â‹™ category_theory.idempotents.karoubi_functor_category_embedding J C = (category_theory.whiskering_right J C (category_theory.idempotents.karoubi C)).obj (category_theory.idempotents.to_karoubi C)
theorem tactic.ring2.horner_expr.cseval_of_csexpr {Î± : Type u_1} [comm_semiring Î±] (t : tree Î±) (r : tactic.ring2.csring_expr) : (tactic.ring2.horner_expr.of_csexpr r).is_cs âˆ§ tactic.ring2.horner_expr.cseval t (tactic.ring2.horner_expr.of_csexpr r) = tactic.ring2.csring_expr.eval t r
theorem finset.weighted_vsub_vadd_affine_combination {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {Î¹ : Type u_4} (s : finset Î¹) (wâ‚ wâ‚‚ : Î¹ â†’ k) (p : Î¹ â†’ P) : â‡‘(s.weighted_vsub p) wâ‚ +áµ¥ â‡‘(s.affine_combination p) wâ‚‚ = â‡‘(s.affine_combination p) (wâ‚ + wâ‚‚)
theorem affine_subspace.direction_affine_span_insert {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : affine_subspace k P} {p1 p2 : P} (hp1 : p1 âˆˆ s) : (affine_span k (has_insert.insert p2 â†‘s)).direction = submodule.span k {p2 -áµ¥ p1} âŠ” s.direction
theorem filter.tendsto.neg_mul_at_bot {Î± : Type u} {Î² : Type v} [linear_ordered_field Î±] [topological_space Î±] [order_topology Î±] {l : filter Î²} {f g : Î² â†’ Î±} {C : Î±} (hC : C < 0) (hf : filter.tendsto f l (nhds C)) (hg : filter.tendsto g l filter.at_bot) : filter.tendsto (Î» (x : Î²), f x * g x) l filter.at_top
theorem category_theory.limits.initial_mono_class.of_is_terminal {C : Type uâ‚} [category_theory.category C] {I T : C} (hI : category_theory.limits.is_initial I) (hT : category_theory.limits.is_terminal T) (f : category_theory.mono (hI.to T)) : category_theory.limits.initial_mono_class C
theorem set.countable.preimage_cexp {s : set â„‚} : s.countable â†’ (complex.exp â»Â¹' s).countable
theorem matrix.is_diag_iff_diagonal_diag {Î± : Type u_1} {n : Type u_4} [has_zero Î±] [decidable_eq n] (A : matrix n n Î±) : A.is_diag â†” matrix.diagonal A.diag = A
theorem metric.tendsto_locally_uniformly_on_iff {Î± : Type u} {Î² : Type v} [pseudo_metric_space Î±] {Î¹ : Type u_1} [topological_space Î²] {F : Î¹ â†’ Î² â†’ Î±} {f : Î² â†’ Î±} {p : filter Î¹} {s : set Î²} : tendsto_locally_uniformly_on F f p s â†” âˆ€ (Îµ : â„), Îµ > 0 â†’ âˆ€ (x : Î²), x âˆˆ s â†’ (âˆƒ (t : set Î²) (H : t âˆˆ nhds_within x s), âˆ€á¶  (n : Î¹) in p, âˆ€ (y : Î²), y âˆˆ t â†’ has_dist.dist (f y) (F n y) < Îµ)
theorem lp.norm_le_of_tendsto {Î± : Type u_1} {E : Î± â†’ Type u_2} {p : ennreal} [Î  (i : Î±), normed_group (E i)] {Î¹ : Type u_3} {l : filter Î¹} [l.ne_bot] [fact (1 â‰¤ p)] {C : â„} {F : Î¹ â†’ â†¥(lp E p)} (hCF : âˆ€á¶  (k : Î¹) in l, âˆ¥F kâˆ¥ â‰¤ C) {f : â†¥(lp E p)} (hf : filter.tendsto (id (Î» (i : Î¹), â‡‘(F i))) l (nhds â‡‘f)) : âˆ¥fâˆ¥ â‰¤ C
theorem metric.Hausdorff_dist_image {Î± : Type u} {Î² : Type v} [pseudo_metric_space Î±] [pseudo_metric_space Î²] {s t : set Î±} {Î¦ : Î± â†’ Î²} (h : isometry Î¦) : metric.Hausdorff_dist (Î¦ '' s) (Î¦ '' t) = metric.Hausdorff_dist s t
theorem add_monoid_hom.map_zero {M : Type u_3} {N : Type u_4} [add_zero_class M] [add_zero_class N] (f : M â†’+ N) : â‡‘f 0 = 0
theorem cont_mdiff_neg_sphere {E : Type u_1} [inner_product_space â„ E] {n : â„•} [fact (finite_dimensional.finrank â„ E = n + 1)] : cont_mdiff (model_with_corners_self â„ (euclidean_space â„ (fin n))) (model_with_corners_self â„ (euclidean_space â„ (fin n))) âŠ¤ (Î» (x : â†¥(metric.sphere 0 1)), -x)
theorem module.End.supr_generalized_eigenspace_eq_top {K : Type v} {V : Type w} [field K] [add_comm_group V] [module K V] [is_alg_closed K] [finite_dimensional K V] (f : module.End K V) : (â¨† (Î¼ : K) (k : â„•), â‡‘(f.generalized_eigenspace Î¼) k) = âŠ¤
theorem is_submonoid.list_prod_mem {M : Type u_1} [monoid M] {s : set M} (hs : is_submonoid s) {l : list M} : (âˆ€ (x : M), x âˆˆ l â†’ x âˆˆ s) â†’ l.prod âˆˆ s
theorem normed_group.tendsto_at_top {Î± : Type u_1} [nonempty Î±] [semilattice_sup Î±] {Î² : Type u_2} [semi_normed_group Î²] {f : Î± â†’ Î²} {b : Î²} : filter.tendsto f filter.at_top (nhds b) â†” âˆ€ (Îµ : â„), 0 < Îµ â†’ (âˆƒ (N : Î±), âˆ€ (n : Î±), N â‰¤ n â†’ âˆ¥f n - bâˆ¥ < Îµ)
theorem list.sum_reverse_noncomm {G : Type u_7} [add_group G] (L : list G) : L.reverse.sum = -(list.map (Î» (x : G), -x) L).sum
theorem measure_theory.is_open_pos_measure_of_mul_left_invariant_of_regular {G : Type u_1} [measurable_space G] [topological_space G] [borel_space G] {Î¼ : measure_theory.measure G} [group G] [topological_group G] [Î¼.is_mul_left_invariant] [Î¼.regular] (hâ‚€ : Î¼ â‰  0) : Î¼.is_open_pos_measure
theorem iterated_deriv_succ {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {F : Type u_2} [normed_group F] [normed_space ğ•œ F] {n : â„•} {f : ğ•œ â†’ F} : iterated_deriv (n + 1) f = deriv (iterated_deriv n f)
theorem tsum_supr_decodeâ‚‚ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [add_comm_monoid Î±] [topological_space Î±] [t2_space Î±] [encodable Î³] [complete_lattice Î²] (m : Î² â†’ Î±) (m0 : m âŠ¥ = 0) (s : Î³ â†’ Î²) : âˆ‘' (i : â„•), m (â¨† (b : Î³) (H : b âˆˆ encodable.decodeâ‚‚ Î³ i), s b) = âˆ‘' (b : Î³), m (s b)
theorem is_group_hom.map_one {Î± : Type u} {Î² : Type v} [group Î±] [group Î²] {f : Î± â†’ Î²} (hf : is_group_hom f) : f 1 = 1
theorem has_ftaylor_series_up_to_on_succ_iff_right {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {s : set E} {f : E â†’ F} {p : E â†’ formal_multilinear_series ğ•œ E F} {n : â„•} : has_ftaylor_series_up_to_on â†‘(n + 1) f p s â†” (âˆ€ (x : E), x âˆˆ s â†’ (p x 0).uncurry0 = f x) âˆ§ (âˆ€ (x : E), x âˆˆ s â†’ has_fderiv_within_at (Î» (y : E), p y 0) (p x 1).curry_left s x) âˆ§ has_ftaylor_series_up_to_on â†‘n (Î» (x : E), â‡‘(continuous_multilinear_curry_fin1 ğ•œ E F) (p x 1)) (Î» (x : E), (p x).shift) s
theorem filter.eq_top_of_ne_bot {Î± : Type u} [subsingleton Î±] (l : filter Î±) [l.ne_bot] : l = âŠ¤
theorem real.tendsto_mul_log_one_plus_div_at_top (t : â„) : filter.tendsto (Î» (x : â„), x * real.log (1 + t / x)) filter.at_top (nhds t)
theorem continuous.snd {Î± : Type u} {Î² : Type v} {Î³ : Type u_1} [topological_space Î±] [topological_space Î²] [topological_space Î³] {f : Î± â†’ Î² Ã— Î³} (hf : continuous f) : continuous (Î» (a : Î±), (f a).snd)
theorem nonneg_of_neg_nonpos {Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± has_add.add has_le.le] {a : Î±} : -a â‰¤ 0 â†’ 0 â‰¤ a
theorem subgroup.mem_closure_singleton {G : Type u_1} [group G] {x y : G} : y âˆˆ subgroup.closure {x} â†” âˆƒ (n : â„¤), x ^ n = y
theorem setoid.eqv_gen_eq {Î± : Type u_1} (r : Î± â†’ Î± â†’ Prop) : eqv_gen.setoid r = has_Inf.Inf {s : setoid Î± | âˆ€ â¦ƒx y : Î±â¦„, r x y â†’ s.rel x y}
theorem add_subgroup.list_sum_mem {G : Type u_1} [add_group G] (K : add_subgroup G) {l : list G} : (âˆ€ (x : G), x âˆˆ l â†’ x âˆˆ K) â†’ l.sum âˆˆ K
theorem controlled_closure_of_complete {G : Type u_1} [normed_group G] [complete_space G] {H : Type u_2} [normed_group H] {f : normed_group_hom G H} {K : add_subgroup H} {C Îµ : â„} (hC : 0 < C) (hÎµ : 0 < Îµ) (hyp : f.surjective_on_with K C) : f.surjective_on_with K.topological_closure (C + Îµ)
theorem ufm_of_gcd_of_wf_dvd_monoid {Î± : Type u_1} [cancel_comm_monoid_with_zero Î±] [wf_dvd_monoid Î±] [gcd_monoid Î±] : unique_factorization_monoid Î±
theorem category_theory.essentially_small_iff (C : Type u) [category_theory.category C] : category_theory.essentially_small C â†” small (category_theory.skeleton C) âˆ§ category_theory.locally_small C
theorem int.eq_of_mod_eq_of_nat_abs_sub_lt_nat_abs {a b c : â„¤} (h1 : a % b = c) (h2 : (a - c).nat_abs < b.nat_abs) : a = c
theorem power_series.order_X {R : Type u_1} [semiring R] [nontrivial R] : power_series.X.order = 1
theorem linear_equiv.det_symm_mul_det {M : Type u_2} [add_comm_group M] {A : Type u_1} [comm_ring A] [module A M] (f : M â‰ƒâ‚—[A] M) : â‡‘linear_map.det â†‘(f.symm) * â‡‘linear_map.det â†‘f = 1
theorem simplex_category.Î´_comp_Ïƒ_self {n : â„•} {i : fin (n + 1)} : simplex_category.Î´ (â‡‘fin.cast_succ i) â‰« simplex_category.Ïƒ i = ğŸ™ (simplex_category.mk n)
theorem measure_theory.is_fundamental_domain.map_restrict_quotient {G : Type u_1} [group G] [measurable_space G] [topological_space G] [topological_group G] [borel_space G] {Î¼ : measure_theory.measure G} {Î“ : subgroup G} {ğ“• : set G} (hğ“• : measure_theory.is_fundamental_domain â†¥(Î“.opposite) ğ“• Î¼) [encodable â†¥Î“] [measurable_space (G â§¸ Î“)] [borel_space (G â§¸ Î“)] [t2_space (G â§¸ Î“)] [topological_space.second_countable_topology (G â§¸ Î“)] (K : topological_space.positive_compacts (G â§¸ Î“)) [Î“.normal] [Î¼.is_haar_measure] [Î¼.is_mul_right_invariant] (hğ“•_finite : â‡‘Î¼ ğ“• < âŠ¤) : measure_theory.measure.map â‡‘(quotient_group.mk' Î“) (Î¼.restrict ğ“•) = â‡‘Î¼ (ğ“• âˆ© â‡‘(quotient_group.mk' Î“) â»Â¹' â†‘K) â€¢ measure_theory.measure.haar_measure K
theorem measure_theory.integral_indicator {Î± : Type u_1} {E : Type u_3} [measurable_space Î±] [normed_group E] {f : Î± â†’ E} {s : set Î±} {Î¼ : measure_theory.measure Î±} [complete_space E] [normed_space â„ E] (hs : measurable_set s) : âˆ« (x : Î±), s.indicator f x âˆ‚Î¼ = âˆ« (x : Î±) in s, f x âˆ‚Î¼
theorem category_theory.presieve.is_sheaf_iso {C : Type uâ‚} [category_theory.category C] {P : Cáµ’áµ– â¥¤ Type w} (J : category_theory.grothendieck_topology C) {P' : Cáµ’áµ– â¥¤ Type w} (i : P â‰… P') (h : category_theory.presieve.is_sheaf J P) : category_theory.presieve.is_sheaf J P'
theorem category_theory.arrow.square_to_iso_invert {T : Type u} [category_theory.category T] (i : category_theory.arrow T) {X Y : T} (p : X â‰… Y) (sq : i âŸ¶ category_theory.arrow.mk p.hom) : i.hom â‰« sq.right â‰« p.inv = sq.left
theorem cardinal.nsmul_lt_aleph_0_iff_of_ne_zero {n : â„•} {a : cardinal} (h : n â‰  0) : n â€¢ a < cardinal.aleph_0 â†” a < cardinal.aleph_0
theorem filter.eventually_eq.eventually_eq_nhds {Î± : Type u} {Î² : Type v} [topological_space Î±] {f g : Î± â†’ Î²} {a : Î±} (h : f =á¶ [nhds a] g) : âˆ€á¶  (y : Î±) in nhds a, f =á¶ [nhds y] g
theorem abs_real_inner_le_norm {F : Type u_3} [inner_product_space â„ F] (x y : F) : |has_inner.inner x y| â‰¤ âˆ¥xâˆ¥ * âˆ¥yâˆ¥
theorem Gromov_Hausdorff.isometry_optimal_GH_injl (X : Type u) (Y : Type v) [metric_space X] [compact_space X] [nonempty X] [metric_space Y] [compact_space Y] [nonempty Y] : isometry (Gromov_Hausdorff.optimal_GH_injl X Y)
theorem set.finset_sum_mem_finset_sum {Î± : Type u_2} {Î¹ : Type u_5} [add_comm_monoid Î±] (t : finset Î¹) (f : Î¹ â†’ set Î±) (g : Î¹ â†’ Î±) (hg : âˆ€ (i : Î¹), i âˆˆ t â†’ g i âˆˆ f i) : t.sum (Î» (i : Î¹), g i) âˆˆ t.sum (Î» (i : Î¹), f i)
theorem lt_neg_add_of_add_lt {Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b c : Î±} : a + b < c â†’ b < -a + c
theorem complex.norm_eq_norm_of_is_max_on_of_ball_subset {E : Type u} [normed_group E] [normed_space â„‚ E] {F : Type v} [normed_group F] [normed_space â„‚ F] {f : E â†’ F} {s : set E} {z w : E} (hd : diff_cont_on_cl â„‚ f s) (hz : is_max_on (has_norm.norm âˆ˜ f) s z) (hsub : metric.ball z (has_dist.dist w z) âŠ† s) : âˆ¥f wâˆ¥ = âˆ¥f zâˆ¥
theorem linear_independent.restrict_scalars {Î¹ : Type u_1} {R : Type u_3} {K : Type u_4} {M : Type u_5} {v : Î¹ â†’ M} [semiring R] [add_comm_monoid M] [module R M] [semiring K] [smul_with_zero R K] [module K M] [is_scalar_tower R K M] (hinj : function.injective (Î» (r : R), r â€¢ 1)) (li : linear_independent K v) : linear_independent R v
theorem star_convex_iff_pointwise_add_subset {ğ•œ : Type u_1} {E : Type u_2} [ordered_semiring ğ•œ] [add_comm_monoid E] [has_scalar ğ•œ E] {x : E} {s : set E} : star_convex ğ•œ x s â†” âˆ€ â¦ƒa b : ğ•œâ¦„, 0 â‰¤ a â†’ 0 â‰¤ b â†’ a + b = 1 â†’ a â€¢ {x} + b â€¢ s âŠ† s
theorem basic_smooth_vector_bundle_core.smooth_const_section {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {M : Type u_4} [topological_space M] [charted_space H M] [Is : smooth_manifold_with_corners I M] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] (Z : basic_smooth_vector_bundle_core I M E') (v : E') (h : âˆ€ (i j : â†¥(charted_space.atlas H M)) (x : M), x âˆˆ i.val.to_local_equiv.source âˆ© j.val.to_local_equiv.source â†’ â‡‘(Z.coord_change i j (â‡‘(i.val) x)) v = v) : smooth I (I.prod (model_with_corners_self ğ•œ E')) (show M â†’ Z.to_topological_vector_bundle_core.total_space, from Î» (x : M), âŸ¨x, vâŸ©)
theorem category_theory.functor.final.cofinal_of_colimit_comp_coyoneda_iso_punit {C : Type v} [category_theory.small_category C] {D : Type v} [category_theory.small_category D] (F : C â¥¤ D) [F.final] (I : Î  (d : D), category_theory.limits.colimit (F â‹™ category_theory.coyoneda.obj (opposite.op d)) â‰… punit) : F.final
theorem conformal_at_iff' {E : Type u_1} {F : Type u_2} [inner_product_space â„ E] [inner_product_space â„ F] {f : E â†’ F} {x : E} : conformal_at f x â†” âˆƒ (c : â„), 0 < c âˆ§ âˆ€ (u v : E), has_inner.inner (â‡‘(fderiv â„ f x) u) (â‡‘(fderiv â„ f x) v) = c * has_inner.inner u v
theorem measure_theory.integral_eq_of_has_deriv_within_at_off_countable_of_le {E : Type u} [normed_group E] [normed_space â„ E] [complete_space E] (f f' : â„ â†’ E) {a b : â„} (hle : a â‰¤ b) {s : set â„} (hs : s.countable) (Hc : continuous_on f (set.Icc a b)) (Hd : âˆ€ (x : â„), x âˆˆ set.Ioo a b  s â†’ has_deriv_at f (f' x) x) (Hi : interval_integrable f' measure_theory.measure_space.volume a b) : âˆ« (x : â„) in a..b, f' x = f b - f a
theorem measure_theory.lintegral_prod_symm {Î± : Type u_1} {Î² : Type u_3} [measurable_space Î±] [measurable_space Î²] {Î¼ : measure_theory.measure Î±} {Î½ : measure_theory.measure Î²} [measure_theory.sigma_finite Î½] [measure_theory.sigma_finite Î¼] (f : Î± Ã— Î² â†’ ennreal) (hf : ae_measurable f (Î¼.prod Î½)) : âˆ«â» (z : Î± Ã— Î²), f z âˆ‚Î¼.prod Î½ = âˆ«â» (y : Î²), âˆ«â» (x : Î±), f (x, y) âˆ‚Î¼ âˆ‚Î½
theorem inner_product_geometry.angle_eq_pi_iff {V : Type u_1} [inner_product_space â„ V] {x y : V} : inner_product_geometry.angle x y = real.pi â†” x â‰  0 âˆ§ âˆƒ (r : â„), r < 0 âˆ§ y = r â€¢ x
theorem category_theory.monad.forget_creates_colimits.commuting {C : Type uâ‚} [category_theory.category C] {T : category_theory.monad C} {J : Type u} [category_theory.category J] {D : J â¥¤ T.algebra} (c : category_theory.limits.cocone (D â‹™ T.forget)) (t : category_theory.limits.is_colimit c) [category_theory.limits.preserves_colimit (D â‹™ T.forget) â†‘T] (j : J) : â†‘T.map (c.Î¹.app j) â‰« category_theory.monad.forget_creates_colimits.lambda c t = (D.obj j).a â‰« c.Î¹.app j
theorem is_localization.exists_integer_multiple' {R : Type u_1} [comm_ring R] (M : submonoid R) {S : Type u_2} [comm_ring S] [algebra R S] [is_localization M S] (a : S) : âˆƒ (b : â†¥M), is_localization.is_integer R (a * â‡‘(algebra_map R S) â†‘b)
theorem btw_cyclic {Î± : Type u_1} [circular_preorder Î±] {a b c : Î±} : has_btw.btw a b c â†” has_btw.btw c a b
theorem add_subgroup.surjective_normed_mk {M : Type u_1} [semi_normed_group M] (S : add_subgroup M) : function.surjective â‡‘(S.normed_mk)
theorem dihedral_group.order_of_r_one {n : â„•} : order_of (dihedral_group.r 1) = n
theorem function.surjective.nontrivial {Î± : Type u_1} {Î² : Type u_2} [nontrivial Î²] {f : Î± â†’ Î²} (hf : function.surjective f) : nontrivial Î±
theorem matrix.update_row_eq_transvection {n : Type u_1} {R : Type uâ‚‚} [decidable_eq n] [comm_ring R] (i j : n) [fintype n] (c : R) : 1.update_row i (1 i + c â€¢ 1 j) = matrix.transvection i j c
theorem exists_dvd_and_dvd_of_dvd_mul {Î± : Type u_1} [cancel_comm_monoid_with_zero Î±] [gcd_monoid Î±] {m n k : Î±} (H : k âˆ£ m * n) : âˆƒ (dâ‚ : Î±) (hdâ‚ : dâ‚ âˆ£ m) (dâ‚‚ : Î±) (hdâ‚‚ : dâ‚‚ âˆ£ n), k = dâ‚ * dâ‚‚
theorem dense.closure {Î± : Type u} [topological_space Î±] {s : set Î±} : dense s â†’ dense (closure s)
theorem ordinal.cof_lsub_def_nonempty (o : ordinal) : {a : cardinal | âˆƒ {Î¹ : Type u} (f : Î¹ â†’ ordinal), ordinal.lsub f = o âˆ§ cardinal.mk Î¹ = a}.nonempty
theorem finset.card_powerset {Î± : Type u_1} (s : finset Î±) : s.powerset.card = 2 ^ s.card
theorem has_strict_fderiv_at_exp_of_mem_ball {ğ•‚ : Type u_1} {ğ”¸ : Type u_2} [nondiscrete_normed_field ğ•‚] [normed_comm_ring ğ”¸] [normed_algebra ğ•‚ ğ”¸] [complete_space ğ”¸] [char_zero ğ•‚] {x : ğ”¸} (hx : x âˆˆ emetric.ball 0 (exp_series ğ•‚ ğ”¸).radius) : has_strict_fderiv_at (exp ğ•‚) (exp ğ•‚ x â€¢ 1) x
theorem category_theory.limits.kernel.Î¹_of_mono {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} (f : X âŸ¶ Y) [category_theory.limits.has_zero_object C] [category_theory.limits.has_kernel f] [category_theory.mono f] : category_theory.limits.kernel.Î¹ f = 0
theorem is_unit.dvd {Î± : Type u_1} [monoid Î±] {a u : Î±} (hu : is_unit u) : u âˆ£ a
theorem measurable_limsup' {Î± : Type u_1} {Î´ : Type u_5} [topological_space Î±] [measurable_space Î±] [borel_space Î±] [measurable_space Î´] [complete_linear_order Î±] [order_topology Î±] [topological_space.second_countable_topology Î±] {Î¹ : Type u_2} {Î¹' : Type u_3} {f : Î¹ â†’ Î´ â†’ Î±} {u : filter Î¹} (hf : âˆ€ (i : Î¹), measurable (f i)) {p : Î¹' â†’ Prop} {s : Î¹' â†’ set Î¹} (hu : u.has_countable_basis p s) (hs : âˆ€ (i : Î¹'), (s i).countable) : measurable (Î» (x : Î´), u.limsup (Î» (i : Î¹), f i x))
theorem is_cyclotomic_extension.number_field (S : set â„•+) (K : Type w) (L : Type z) [field K] [field L] [algebra K L] [h : number_field K] [fintype â†¥S] [is_cyclotomic_extension S K L] : number_field L
theorem subalgebra.mul_to_submodule {R : Type u_1} {A : Type u_2} [comm_semiring R] [comm_semiring A] [algebra R A] (S T : subalgebra R A) : S.to_submodule * T.to_submodule = (S âŠ” T).to_submodule
theorem eq_zero_of_same_ray_self_neg {R : Type u_1} [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {x : M} [no_zero_smul_divisors R M] (h : same_ray R x (-x)) : x = 0
theorem measure_theory.measure.eq_rn_deriv {Î± : Type u_1} {m : measurable_space Î±} {Î¼ Î½ : measure_theory.measure Î±} [measure_theory.sigma_finite Î½] {s : measure_theory.measure Î±} {f : Î± â†’ ennreal} (hf : measurable f) (hs : s.mutually_singular Î½) (hadd : Î¼ = s + Î½.with_density f) : f =áµ[Î½] Î¼.rn_deriv Î½
theorem fin.antitone_iff_succ_le {n : â„•} {Î± : Type u_1} [preorder Î±] {f : fin (n + 1) â†’ Î±} : antitone f â†” âˆ€ (i : fin n), f i.succ â‰¤ f (â‡‘fin.cast_succ i)
theorem is_square_zero (M : Type u_1) [monoid_with_zero M] : is_square 0
theorem basis.finite_of_vector_space_index_of_dim_lt_aleph_0 {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] (h : module.rank K V < cardinal.aleph_0) : (basis.of_vector_space_index K V).finite
theorem cont_mdiff_within_at_iff {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {M : Type u_4} [topological_space M] [charted_space H M] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners ğ•œ E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] {f : M â†’ M'} {s : set M} {x : M} {n : with_top â„•} : cont_mdiff_within_at I I' n f s x â†” continuous_within_at f s x âˆ§ cont_diff_within_at ğ•œ n (â‡‘(ext_chart_at I' (f x)) âˆ˜ f âˆ˜ â‡‘((ext_chart_at I x).symm)) ((ext_chart_at I x).target âˆ© â‡‘((ext_chart_at I x).symm) â»Â¹' (s âˆ© f â»Â¹' (ext_chart_at I' (f x)).source)) (â‡‘(ext_chart_at I x) x)
theorem inner_product_space.is_self_adjoint.invariant_orthogonal_eigenspace {ğ•œ : Type u_1} [is_R_or_C ğ•œ] {E : Type u_2} [inner_product_space ğ•œ E] {T : E â†’â‚—[ğ•œ] E} (hT : inner_product_space.is_self_adjoint T) (Î¼ : ğ•œ) (v : E) (hv : v âˆˆ (module.End.eigenspace T Î¼)á—®) : â‡‘T v âˆˆ (module.End.eigenspace T Î¼)á—®
theorem is_regular.pow_iff {R : Type u_1} {a : R} [monoid R] {n : â„•} (n0 : 0 < n) : is_regular (a ^ n) â†” is_regular a
theorem category_theory.is_subterminal_of_mono_terminal_from {C : Type uâ‚} [category_theory.category C] {A : C} [category_theory.limits.has_terminal C] [category_theory.mono (category_theory.limits.terminal.from A)] : category_theory.is_subterminal A
theorem Top.stalk_to_fiber_surjective {X : Top} {T : â†¥X â†’ Type v} (P : Top.local_predicate T) (x : â†¥X) (w : âˆ€ (t : T x), âˆƒ (U : topological_space.open_nhds x) (f : Î  (y : â†¥(U.val)), T â†‘y) (h : P.to_prelocal_predicate.pred f), f âŸ¨x, _âŸ© = t) : function.surjective (Top.stalk_to_fiber P x)
theorem finset.induction_on_pi_of_choice {Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_2} [fintype Î¹] [decidable_eq Î¹] [Î  (i : Î¹), decidable_eq (Î± i)] (r : Î  (i : Î¹), Î± i â†’ finset (Î± i) â†’ Prop) (H_ex : âˆ€ (i : Î¹) (s : finset (Î± i)), s.nonempty â†’ (âˆƒ (x : Î± i) (H : x âˆˆ s), r i x (s.erase x))) {p : (Î  (i : Î¹), finset (Î± i)) â†’ Prop} (f : Î  (i : Î¹), finset (Î± i)) (h0 : p (Î» (_x : Î¹), âˆ…)) (step : âˆ€ (g : Î  (i : Î¹), finset (Î± i)) (i : Î¹) (x : Î± i), r i x (g i) â†’ p g â†’ p (function.update g i (has_insert.insert x (g i)))) : p f
theorem is_local_max_on.has_fderiv_within_at_nonpos {E : Type u} [normed_group E] [normed_space â„ E] {f : E â†’ â„} {a : E} {f' : E â†’L[â„] â„} {s : set E} (h : is_local_max_on f s a) (hf : has_fderiv_within_at f f' s a) {y : E} (hy : y âˆˆ pos_tangent_cone_at s a) : â‡‘f' y â‰¤ 0
theorem category_theory.is_connected.of_any_functor_const_on_obj {J : Type uâ‚} [category_theory.category J] [nonempty J] (h : âˆ€ {Î± : Type uâ‚} (F : J â¥¤ category_theory.discrete Î±) (j j' : J), F.obj j = F.obj j') : category_theory.is_connected J
theorem category_theory.is_iso_of_reflects_iso {C : Type uâ‚} [category_theory.category C] {D : Type uâ‚‚} [category_theory.category D] {A B : C} (f : A âŸ¶ B) (F : C â¥¤ D) [category_theory.is_iso (F.map f)] [category_theory.reflects_isomorphisms F] : category_theory.is_iso f
theorem affine_independent.of_comp {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {Î¹ : Type u_4} {Vâ‚‚ : Type u_5} {Pâ‚‚ : Type u_6} [add_comm_group Vâ‚‚] [module k Vâ‚‚] [add_torsor Vâ‚‚ Pâ‚‚] {p : Î¹ â†’ P} (f : P â†’áµƒ[k] Pâ‚‚) (hai : affine_independent k (â‡‘f âˆ˜ p)) : affine_independent k p
theorem convolution_flip {ğ•œ : Type u_1} {G : Type u_2} {E : Type u_3} {E' : Type u_4} {F : Type u_6} [normed_group E] [normed_group E'] [normed_group F] {f : G â†’ E} {g : G â†’ E'} [nondiscrete_normed_field ğ•œ] [normed_space ğ•œ E] [normed_space ğ•œ E'] [normed_space ğ•œ F] (L : E â†’L[ğ•œ] E' â†’L[ğ•œ] F) [measurable_space G] {Î¼ : measure_theory.measure G} [normed_space â„ F] [complete_space F] [add_comm_group G] [topological_space G] [topological_add_group G] [borel_space G] [Î¼.is_add_left_invariant] [Î¼.is_neg_invariant] : convolution g f L.flip Î¼ = convolution f g L Î¼
theorem subsemiring.closure_le {R : Type u} [non_assoc_semiring R] {s : set R} {t : subsemiring R} : subsemiring.closure s â‰¤ t â†” s âŠ† â†‘t
theorem geometric_hahn_banach_open {E : Type u_2} [normed_group E] [normed_space â„ E] {s t : set E} (hsâ‚ : convex â„ s) (hsâ‚‚ : is_open s) (ht : convex â„ t) (disj : disjoint s t) : âˆƒ (f : E â†’L[â„] â„) (u : â„), (âˆ€ (a : E), a âˆˆ s â†’ â‡‘f a < u) âˆ§ âˆ€ (b : E), b âˆˆ t â†’ u â‰¤ â‡‘f b
theorem eventually_singleton_add_smul_subset {ğ•œ : Type u_1} {E : Type u_2} [normed_field ğ•œ] [semi_normed_group E] [normed_space ğ•œ E] {x : E} {s : set E} (hs : metric.bounded s) {u : set E} (hu : u âˆˆ nhds x) : âˆ€á¶  (r : ğ•œ) in nhds 0, {x} + r â€¢ s âŠ† u
theorem normed_ring.inverse_add_nth_order {R : Type u_1} [normed_ring R] [complete_space R] (x : RË£) (n : â„•) : âˆ€á¶  (t : R) in nhds 0, ring.inverse (â†‘x + t) = (finset.range n).sum (Î» (i : â„•), (-â†‘xâ»Â¹ * t) ^ i) * â†‘xâ»Â¹ + (-â†‘xâ»Â¹ * t) ^ n * ring.inverse (â†‘x + t)
theorem dense.diff_finset {Î± : Type u} [topological_space Î±] [t1_space Î±] [âˆ€ (x : Î±), (nhds_within x {x}á¶œ).ne_bot] {s : set Î±} (hs : dense s) (t : finset Î±) : dense (s  â†‘t)
theorem linear_map.det_zero {ğ•œ : Type u_1} [field ğ•œ] {M : Type u_2} [add_comm_group M] [module ğ•œ M] : â‡‘linear_map.det 0 = 0 ^ finite_dimensional.finrank ğ•œ M
theorem measure_theory.outer_measure.of_function_union_of_top_of_nonempty_inter {Î± : Type u_1} {m : set Î± â†’ ennreal} {m_empty : m âˆ… = 0} {s t : set Î±} (h : âˆ€ (u : set Î±), (s âˆ© u).nonempty â†’ (t âˆ© u).nonempty â†’ m u = âŠ¤) : â‡‘(measure_theory.outer_measure.of_function m m_empty) (s âˆª t) = â‡‘(measure_theory.outer_measure.of_function m m_empty) s + â‡‘(measure_theory.outer_measure.of_function m m_empty) t
theorem category_theory.limits.has_initial_of_has_initial_of_preserves_colimit {C : Type uâ‚} [category_theory.category C] {D : Type uâ‚‚} [category_theory.category D] (G : C â¥¤ D) [category_theory.limits.has_initial C] [category_theory.limits.preserves_colimit (category_theory.functor.empty C) G] : category_theory.limits.has_initial D
theorem add_con.mk'_surjective {M : Type u_1} [add_zero_class M] {c : add_con M} : function.surjective â‡‘(c.mk')
theorem category_theory.abelian.functor.right_derived_zero_to_self_natural {C : Type u} [category_theory.category C] {D : Type u} [category_theory.category D] (F : C â¥¤ D) [category_theory.abelian C] [category_theory.abelian D] [F.additive] [category_theory.enough_injectives C] {X Y : C} (f : X âŸ¶ Y) (P : category_theory.InjectiveResolution X) (Q : category_theory.InjectiveResolution Y) : F.map f â‰« category_theory.abelian.functor.right_derived_zero_to_self_app_inv F Q = category_theory.abelian.functor.right_derived_zero_to_self_app_inv F P â‰« (F.right_derived 0).map f
theorem is_antichain.max_minimals {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} {s t : set Î±} (ht : is_antichain r t) (h : minimals r s âŠ† t) (hs : âˆ€ â¦ƒa : Î±â¦„, a âˆˆ t â†’ (âˆƒ (b : Î±) (H : b âˆˆ minimals r s), r a b)) : minimals r s = t
theorem measure_theory.integral_condexp_L2_eq {Î± : Type u_1} {E' : Type u_5} {ğ•œ : Type u_11} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E'] [complete_space E'] [normed_space â„ E'] {m m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {s : set Î±} (hm : m â‰¤ m0) (f : â†¥(measure_theory.Lp E' 2 Î¼)) (hs : measurable_set s) (hÎ¼s : â‡‘Î¼ s â‰  âŠ¤) : âˆ« (x : Î±) in s, â‡‘(â‡‘(measure_theory.condexp_L2 ğ•œ hm) f) x âˆ‚Î¼ = âˆ« (x : Î±) in s, â‡‘f x âˆ‚Î¼
theorem interval_integral.integral_comp_mul_deriv' {a b : â„} {f f' g : â„ â†’ â„} (h : âˆ€ (x : â„), x âˆˆ set.interval a b â†’ has_deriv_at f (f' x) x) (h' : continuous_on f' (set.interval a b)) (hg : continuous_on g (f '' set.interval a b)) : âˆ« (x : â„) in a..b, (g âˆ˜ f) x * f' x = âˆ« (x : â„) in f a..f b, g x
theorem group.normal_closure.is_subgroup {G : Type u_1} [group G] (s : set G) : is_subgroup (group.normal_closure s)
theorem function.is_fixed_pt.map {Î± : Type u} {Î² : Type v} {fa : Î± â†’ Î±} {fb : Î² â†’ Î²} {x : Î±} (hx : function.is_fixed_pt fa x) {g : Î± â†’ Î²} (h : function.semiconj g fa fb) : function.is_fixed_pt fb (g x)
theorem iterated_deriv_eq_iterate {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {F : Type u_2} [normed_group F] [normed_space ğ•œ F] {n : â„•} {f : ğ•œ â†’ F} : iterated_deriv n f = deriv^[n] f
theorem nat.cast_le_pow_div_sub {K : Type u_1} [linear_ordered_field K] {a : K} (H : 1 < a) (n : â„•) : â†‘n â‰¤ a ^ n / (a - 1)
theorem finset.imageâ‚‚_image_left_anticomm {Î± : Type u_1} {Î±' : Type u_2} {Î² : Type u_3} {Î³ : Type u_5} {Î´ : Type u_7} [decidable_eq Î±'] [decidable_eq Î³] [decidable_eq Î´] {s : finset Î±} {t : finset Î²} {f : Î±' â†’ Î² â†’ Î³} {g : Î± â†’ Î±'} {f' : Î² â†’ Î± â†’ Î´} {g' : Î´ â†’ Î³} (h_left_anticomm : âˆ€ (a : Î±) (b : Î²), f (g a) b = g' (f' b a)) : finset.imageâ‚‚ f (finset.image g s) t = finset.image g' (finset.imageâ‚‚ f' t s)
theorem category_theory.subobject.mk_eq_mk_of_comm {C : Type uâ‚} [category_theory.category C] {B Aâ‚ Aâ‚‚ : C} (f : Aâ‚ âŸ¶ B) (g : Aâ‚‚ âŸ¶ B) [category_theory.mono f] [category_theory.mono g] (i : Aâ‚ â‰… Aâ‚‚) (w : i.hom â‰« g = f) : category_theory.subobject.mk f = category_theory.subobject.mk g
theorem set.pairwise_disjoint.set_independent {Î± : Type u_1} [order.frame Î±] {s : set Î±} : s.pairwise_disjoint id â†’ complete_lattice.set_independent s
theorem euclidean_geometry.exists_circumcenter_eq_of_cospherical {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {ps : set P} {n : â„•} [finite_dimensional â„ V] (hd : finite_dimensional.finrank â„ V = n) (hc : euclidean_geometry.cospherical ps) : âˆƒ (c : P), âˆ€ (sx : affine.simplex â„ P n), set.range sx.points âŠ† ps â†’ sx.circumcenter = c
theorem strict_mono_on.continuous_at_left_of_image_mem_nhds_within {Î± : Type u_1} {Î² : Type u_2} [linear_order Î±] [topological_space Î±] [order_topology Î±] [linear_order Î²] [topological_space Î²] [order_topology Î²] [densely_ordered Î²] {f : Î± â†’ Î²} {s : set Î±} {a : Î±} (h_mono : strict_mono_on f s) (hs : s âˆˆ nhds_within a (set.Iic a)) (hfs : f '' s âˆˆ nhds_within (f a) (set.Iic (f a))) : continuous_within_at f (set.Iic a) a
theorem eventually_closure_subset_of_is_compact_absorbing_of_is_open_of_omega_limit_subset {Ï„ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [topological_space Î²] (f : filter Ï„) (Ï• : Ï„ â†’ Î± â†’ Î²) (s : set Î±) [t2_space Î²] {c : set Î²} (hcâ‚ : is_compact c) (hcâ‚‚ : âˆ€á¶  (t : Ï„) in f, set.maps_to (Ï• t) s c) {n : set Î²} (hnâ‚ : is_open n) (hnâ‚‚ : omega_limit f Ï• s âŠ† n) : âˆƒ (u : set Ï„) (H : u âˆˆ f), closure (set.image2 Ï• u s) âŠ† n
theorem uv.mem_compression {Î± : Type u_1} [generalized_boolean_algebra Î±] [decidable_rel disjoint] [decidable_rel has_le.le] {s : finset Î±} {u v a : Î±} : a âˆˆ uv.compression u v s â†” a âˆˆ s âˆ§ uv.compress u v a âˆˆ s âˆ¨ a âˆ‰ s âˆ§ âˆƒ (b : Î±) (H : b âˆˆ s), uv.compress u v b = a
theorem continuous_linear_map.norm_id_of_nontrivial_seminorm {ğ•œ : Type u_1} {E : Type u_4} [semi_normed_group E] [nondiscrete_normed_field ğ•œ] [normed_space ğ•œ E] (h : âˆƒ (x : E), âˆ¥xâˆ¥ â‰  0) : âˆ¥continuous_linear_map.id ğ•œ Eâˆ¥ = 1
theorem is_local_min_on.fderiv_within_eq_zero {E : Type u} [normed_group E] [normed_space â„ E] {f : E â†’ â„} {a : E} {s : set E} (h : is_local_min_on f s a) {y : E} (hy : y âˆˆ pos_tangent_cone_at s a) (hy' : -y âˆˆ pos_tangent_cone_at s a) : â‡‘(fderiv_within â„ f s a) y = 0
theorem mvqpf.cofix.bisim' {n : â„•} {F : typevec (n + 1) â†’ Type u} [mvfunctor F] [q : mvqpf F] {Î± : typevec n} {Î² : Type u_1} (Q : Î² â†’ Prop) (u v : Î² â†’ mvqpf.cofix F Î±) (h : âˆ€ (x : Î²), Q x â†’ (âˆƒ (a : (mvqpf.P F).A) (f' : ((mvqpf.P F).drop.B a).arrow Î±) (fâ‚€ fâ‚ : (mvqpf.P F).last.B a â†’ mvqpf.cofix F Î±), (u x).dest = mvqpf.abs âŸ¨a, (mvqpf.P F).append_contents f' fâ‚€âŸ© âˆ§ (v x).dest = mvqpf.abs âŸ¨a, (mvqpf.P F).append_contents f' fâ‚âŸ© âˆ§ âˆ€ (i : (mvqpf.P F).last.B a), âˆƒ (x' : Î²), Q x' âˆ§ fâ‚€ i = u x' âˆ§ fâ‚ i = v x')) (x : Î²) : Q x â†’ u x = v x
theorem linear_independent_finset_map_embedding_subtype {R : Type u_3} {M : Type u_5} [semiring R] [add_comm_monoid M] [module R M] (s : set M) (li : linear_independent R coe) (t : finset â†¥s) : linear_independent R coe
theorem finset.affine_combination_vsub {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {Î¹ : Type u_4} (s : finset Î¹) (wâ‚ wâ‚‚ : Î¹ â†’ k) (p : Î¹ â†’ P) : â‡‘(s.affine_combination p) wâ‚ -áµ¥ â‡‘(s.affine_combination p) wâ‚‚ = â‡‘(s.weighted_vsub p) (wâ‚ - wâ‚‚)
theorem category_theory.strong_epi_of_strong_epi {C : Type u} [category_theory.category C] {P Q R : C} (f : P âŸ¶ Q) (g : Q âŸ¶ R) [category_theory.strong_epi (f â‰« g)] : category_theory.strong_epi g
theorem continuous_at_cpow {p : â„‚ Ã— â„‚} (hp_fst : 0 < p.fst.re âˆ¨ p.fst.im â‰  0) : continuous_at (Î» (x : â„‚ Ã— â„‚), x.fst ^ x.snd) p
theorem closed_ball_pi' {Î² : Type v} {Ï€ : Î² â†’ Type u_1} [fintype Î²] [Î  (b : Î²), pseudo_metric_space (Ï€ b)] [nonempty Î²] (x : Î  (b : Î²), Ï€ b) (r : â„) : metric.closed_ball x r = set.univ.pi (Î» (b : Î²), metric.closed_ball (x b) r)
theorem real.cos_pi_div_three  : real.cos (real.pi / 3) = 1 / 2
theorem fin.univ_succ_above (n : â„•) (p : fin (n + 1)) : finset.univ = finset.cons p (finset.map p.succ_above.to_embedding finset.univ) _
theorem inner_product_geometry.conformal_at.preserves_angle {E : Type u_1} {F : Type u_2} [inner_product_space â„ E] [inner_product_space â„ F] {f : E â†’ F} {x : E} {f' : E â†’L[â„] F} (h : has_fderiv_at f f' x) (H : conformal_at f x) (u v : E) : inner_product_geometry.angle (â‡‘f' u) (â‡‘f' v) = inner_product_geometry.angle u v
theorem power_series.exp_mul_exp_eq_exp_add {A : Type u_1} [comm_ring A] [algebra â„š A] (a b : A) : â‡‘(power_series.rescale a) (power_series.exp A) * â‡‘(power_series.rescale b) (power_series.exp A) = â‡‘(power_series.rescale (a + b)) (power_series.exp A)
theorem measure_theory.measure.ext_iff_of_bUnion_eq_univ {Î± : Type u_1} {Î¹ : Type u_5} {m0 : measurable_space Î±} {Î¼ Î½ : measure_theory.measure Î±} {S : set Î¹} {s : Î¹ â†’ set Î±} (hc : S.countable) (hs : (â‹ƒ (i : Î¹) (H : i âˆˆ S), s i) = set.univ) : Î¼ = Î½ â†” âˆ€ (i : Î¹), i âˆˆ S â†’ Î¼.restrict (s i) = Î½.restrict (s i)
theorem measure_theory.Lp_meas.ae_fin_strongly_measurable' {Î± : Type u_1} {F : Type u_6} {ğ•œ : Type u_11} {p : ennreal} [is_R_or_C ğ•œ] [normed_group F] [normed_space ğ•œ F] {m m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (hm : m â‰¤ m0) (f : â†¥(measure_theory.Lp_meas F ğ•œ m p Î¼)) (hp_ne_zero : p â‰  0) (hp_ne_top : p â‰  âŠ¤) : âˆƒ (g : Î± â†’ F), measure_theory.fin_strongly_measurable g (Î¼.trim hm) âˆ§ â‡‘f =áµ[Î¼] g
theorem nat.pow_two_sub_pow_two (a b : â„•) : a ^ 2 - b ^ 2 = (a + b) * (a - b)
theorem pequiv.single_mul_single_right {k : Type u_1} {l : Type u_2} {m : Type u_3} {n : Type u_4} {Î± : Type v} [fintype n] [fintype k] [decidable_eq n] [decidable_eq k] [decidable_eq m] [semiring Î±] (a : m) (b : n) (c : k) (M : matrix k l Î±) : (pequiv.single a b).to_matrix.mul ((pequiv.single b c).to_matrix.mul M) = (pequiv.single a c).to_matrix.mul M
theorem exists_subset_Union_ball_radius_pos_lt {Î± : Type u} {Î¹ : Type v} [metric_space Î±] [proper_space Î±] {c : Î¹ â†’ Î±} {s : set Î±} {r : Î¹ â†’ â„} (hr : âˆ€ (i : Î¹), 0 < r i) (hs : is_closed s) (uf : âˆ€ (x : Î±), x âˆˆ s â†’ {i : Î¹ | x âˆˆ metric.ball (c i) (r i)}.finite) (us : s âŠ† â‹ƒ (i : Î¹), metric.ball (c i) (r i)) : âˆƒ (r' : Î¹ â†’ â„), (s âŠ† â‹ƒ (i : Î¹), metric.ball (c i) (r' i)) âˆ§ âˆ€ (i : Î¹), r' i âˆˆ set.Ioo 0 (r i)
theorem is_primitive_root.minpoly_dvd_X_pow_sub_one {n : â„•} {K : Type u_8} [field K] {Î¼ : K} (h : is_primitive_root Î¼ n) [char_zero K] : minpoly â„¤ Î¼ âˆ£ polynomial.X ^ n - 1
theorem circle_deg1_lift.semiconj_of_group_action_of_forall_translation_number_eq {G : Type u_1} [group G] (fâ‚ fâ‚‚ : G â†’* circle_deg1_lift) (h : âˆ€ (g : G), (â‡‘fâ‚ g).translation_number = (â‡‘fâ‚‚ g).translation_number) : âˆƒ (F : circle_deg1_lift), âˆ€ (g : G), function.semiconj â‡‘F â‡‘(â‡‘fâ‚ g) â‡‘(â‡‘fâ‚‚ g)
theorem finsum_mem_finset_product' {Î± : Type u_1} {Î² : Type u_2} {M : Type u_5} [add_comm_monoid M] [decidable_eq Î±] [decidable_eq Î²] (s : finset (Î± Ã— Î²)) (f : Î± Ã— Î² â†’ M) : finsum (Î» (ab : Î± Ã— Î²), finsum (Î» (h : ab âˆˆ s), f ab)) = finsum (Î» (a : Î±), finsum (Î» (b : Î²), finsum (Î» (h : b âˆˆ finset.image prod.snd (finset.filter (Î» (ab : Î± Ã— Î²), ab.fst = a) s)), f (a, b))))
theorem add_subgroup.le_normalizer_map {G : Type u_1} [add_group G] {H : add_subgroup G} {N : Type u_3} [add_group N] (f : G â†’+ N) : add_subgroup.map f H.normalizer â‰¤ (add_subgroup.map f H).normalizer
theorem function.injective.comap_cofinite_eq {Î± : Type u_2} {Î² : Type u_3} {f : Î± â†’ Î²} (hf : function.injective f) : filter.comap f filter.cofinite = filter.cofinite
theorem fintype.prod_bijective {Î± : Type u_1} {Î² : Type u_2} {M : Type u_3} [fintype Î±] [fintype Î²] [comm_monoid M] (e : Î± â†’ Î²) (he : function.bijective e) (f : Î± â†’ M) (g : Î² â†’ M) (h : âˆ€ (x : Î±), f x = g (e x)) : finset.univ.prod (Î» (x : Î±), f x) = finset.univ.prod (Î» (x : Î²), g x)
theorem complex.alg_hom_ext {A : Type u_3} [semiring A] [algebra â„ A] â¦ƒf g : â„‚ â†’â‚[â„] Aâ¦„ (h : â‡‘f complex.I = â‡‘g complex.I) : f = g
theorem affine_map.to_fun_eq_coe {k : Type u_1} {V1 : Type u_2} {P1 : Type u_3} {V2 : Type u_4} {P2 : Type u_5} [ring k] [add_comm_group V1] [module k V1] [add_torsor V1 P1] [add_comm_group V2] [module k V2] [add_torsor V2 P2] (f : P1 â†’áµƒ[k] P2) : f.to_fun = â‡‘f
theorem dist_le_of_le_geometric_of_tendstoâ‚€ {Î± : Type u_1} [pseudo_metric_space Î±] (r C : â„) (hr : r < 1) {f : â„• â†’ Î±} (hu : âˆ€ (n : â„•), has_dist.dist (f n) (f (n + 1)) â‰¤ C * r ^ n) {a : Î±} (ha : filter.tendsto f filter.at_top (nhds a)) : has_dist.dist (f 0) a â‰¤ C / (1 - r)
theorem category_theory.cover_dense.compatible_preserving {C : Type u_1} [category_theory.category C] {D : Type u_3} [category_theory.category D] {K : category_theory.grothendieck_topology D} {G : C â¥¤ D} (H : category_theory.cover_dense K G) [category_theory.full G] [category_theory.faithful G] : category_theory.compatible_preserving K G
theorem matrix.left_inv_eq_left_inv {n : Type u'} {Î± : Type v} [fintype n] [decidable_eq n] [comm_ring Î±] {A B C : matrix n n Î±} (h : B.mul A = 1) (g : C.mul A = 1) : B = C
theorem multilinear_map.restr_norm_le {ğ•œ : Type u} {G : Type wG} {G' : Type wG'} [nondiscrete_normed_field ğ•œ] [normed_group G] [normed_space ğ•œ G] [normed_group G'] [normed_space ğ•œ G'] {k n : â„•} (f : multilinear_map ğ•œ (Î» (i : fin n), G) G') (s : finset (fin n)) (hk : s.card = k) (z : G) {C : â„} (H : âˆ€ (m : fin n â†’ G), âˆ¥â‡‘f mâˆ¥ â‰¤ C * finset.univ.prod (Î» (i : fin n), âˆ¥m iâˆ¥)) (v : fin k â†’ G) : âˆ¥â‡‘(f.restr s hk z) vâˆ¥ â‰¤ C * âˆ¥zâˆ¥ ^ (n - k) * finset.univ.prod (Î» (i : fin k), âˆ¥v iâˆ¥)
theorem add_monoid_algebra.non_unital_alg_hom_ext (k : Type uâ‚) {G : Type uâ‚‚} [semiring k] [has_add G] {A : Type uâ‚ƒ} [non_unital_non_assoc_semiring A] [distrib_mul_action k A] {Ï†â‚ Ï†â‚‚ : add_monoid_algebra k G â†’â‚™â‚[k] A} (h : âˆ€ (x : G), â‡‘Ï†â‚ (finsupp.single x 1) = â‡‘Ï†â‚‚ (finsupp.single x 1)) : Ï†â‚ = Ï†â‚‚
theorem maps_to_tangent_cone_pi {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {Î¹ : Type u_2} [decidable_eq Î¹] {E : Î¹ â†’ Type u_3} [Î  (i : Î¹), normed_group (E i)] [Î  (i : Î¹), normed_space ğ•œ (E i)] {s : Î  (i : Î¹), set (E i)} {x : Î  (i : Î¹), E i} {i : Î¹} (hi : âˆ€ (j : Î¹), j â‰  i â†’ x j âˆˆ closure (s j)) : set.maps_to â‡‘(linear_map.single i) (tangent_cone_at ğ•œ (s i) (x i)) (tangent_cone_at ğ•œ (set.univ.pi s) x)
theorem module.punctured_nhds_ne_bot (R : Type u_1) (M : Type u_2) [ring R] [topological_space R] [topological_space M] [add_comm_group M] [has_continuous_add M] [module R M] [has_continuous_smul R M] [nontrivial M] [(nhds_within 0 {0}á¶œ).ne_bot] [no_zero_smul_divisors R M] (x : M) : (nhds_within x {x}á¶œ).ne_bot
theorem asymptotics.is_o.of_norm_left {Î± : Type u_1} {F : Type u_4} {E' : Type u_6} [has_norm F] [semi_normed_group E'] {g : Î± â†’ F} {f' : Î± â†’ E'} {l : filter Î±} : (Î» (x : Î±), âˆ¥f' xâˆ¥) =o[l] g â†’ f' =o[l] g
theorem orthogonal_family.linear_isometry_equiv_symm_apply_single {Î¹ : Type u_1} {ğ•œ : Type u_2} [is_R_or_C ğ•œ] {E : Type u_3} [inner_product_space ğ•œ E] [cplt : complete_space E] {G : Î¹ â†’ Type u_4} [Î  (i : Î¹), inner_product_space ğ•œ (G i)] {V : Î  (i : Î¹), G i â†’â‚—áµ¢[ğ•œ] E} (hV : orthogonal_family ğ•œ V) [âˆ€ (i : Î¹), complete_space (G i)] (hV' : (â¨† (i : Î¹), (V i).to_linear_map.range).topological_closure = âŠ¤) {i : Î¹} (x : G i) : â‡‘((hV.linear_isometry_equiv hV').symm) (lp.single 2 i x) = â‡‘(V i) x
theorem basis.mk_coord_apply_ne {Î¹ : Type u_1} {R : Type u_3} {M : Type u_5} {v : Î¹ â†’ M} [ring R] [add_comm_group M] [module R M] {hli : linear_independent R v} {hsp : submodule.span R (set.range v) = âŠ¤} {i j : Î¹} (h : j â‰  i) : â‡‘((basis.mk hli hsp).coord i) (v j) = 0
theorem continuous_map.homotopy.eval_at_eq {X Y : Top} {f g : C(â†¥X, â†¥Y)} (H : f.homotopy g) (x : â†¥X) : âŸ¦H.eval_at xâŸ§ = continuous_map.homotopy.hcast _ â‰« (fundamental_groupoid.fundamental_groupoid_functor.map H.ulift_map).map (continuous_map.homotopy.prod_to_prod_Top_I unit_interval.uhpath01 (ğŸ™ x)) â‰« continuous_map.homotopy.hcast _
theorem add_submonoid.closure_eq {M : Type u_1} [add_zero_class M] (S : add_submonoid M) : add_submonoid.closure â†‘S = S
theorem algebra.discr_eq_det_embeddings_matrix_reindex_pow_two {Î¹ : Type w} [fintype Î¹] (K : Type u) {L : Type v} (E : Type z) [field K] [field L] [field E] [algebra K L] [algebra K E] [module.finite K L] [is_alg_closed E] (b : Î¹ â†’ L) [decidable_eq Î¹] [is_separable K L] (e : Î¹ â‰ƒ (L â†’â‚[K] E)) : â‡‘(algebra_map K E) (algebra.discr K b) = (algebra.embeddings_matrix_reindex K E b e).det ^ 2
theorem category_theory.limits.has_pullbacks_of_has_binary_products_of_has_equalizers (C : Type u) [ğ’ : category_theory.category C] [category_theory.limits.has_binary_products C] [category_theory.limits.has_equalizers C] : category_theory.limits.has_pullbacks C
theorem loc_compact_Haus_tot_disc_of_zero_dim {H : Type u_1} [topological_space H] [locally_compact_space H] [t2_space H] [totally_disconnected_space H] : topological_space.is_topological_basis {s : set H | is_clopen s}
theorem bounded_continuous_function.dist_coe_le_dist {Î± : Type u} {Î² : Type v} [topological_space Î±] [pseudo_metric_space Î²] {f g : bounded_continuous_function Î± Î²} (x : Î±) : has_dist.dist (â‡‘f x) (â‡‘g x) â‰¤ has_dist.dist f g
theorem category_theory.limits.has_limits_of_size_shrink (C : Type u) [category_theory.category C] [category_theory.limits.has_limits_of_size C] : category_theory.limits.has_limits_of_size C
theorem add_con.comap_eq {M : Type u_1} {N : Type u_2} [add_zero_class M] [add_zero_class N] {c : add_con M} {f : N â†’+ M} : add_con.comap â‡‘f _ c = add_con.ker (c.mk'.comp f)
theorem is_dedekind_domain.height_one_spectrum.int_valuation.map_zero' {R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] (v : is_dedekind_domain.height_one_spectrum R) : v.int_valuation_def 0 = 0
theorem ideal.quotient.mkâ‚_surjective (Râ‚ : Type u_3) {A : Type u_5} [comm_semiring Râ‚] [comm_ring A] [algebra Râ‚ A] (I : ideal A) : function.surjective â‡‘(ideal.quotient.mkâ‚ Râ‚ I)
theorem finsum_mem_union {Î± : Type u_1} {M : Type u_5} [add_comm_monoid M] {f : Î± â†’ M} {s t : set Î±} (hst : disjoint s t) (hs : s.finite) (ht : t.finite) : finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s âˆª t), f i)) = finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), f i)) + finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ t), f i))
theorem lt_tsub_iff_right {Î± : Type u_1} {a b c : Î±} [linear_order Î±] [add_comm_semigroup Î±] [has_sub Î±] [has_ordered_sub Î±] : a < b - c â†” a + c < b
theorem affine.triangle.orthocenter_mem_affine_span {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] (t : affine.triangle â„ P) : t.orthocenter âˆˆ affine_span â„ (set.range t.points)
theorem cardinal.mk_Iic_real (a : â„) : cardinal.mk â†¥(set.Iic a) = cardinal.continuum
theorem generalized_continued_fraction.squash_seq_nth_of_not_terminated {K : Type u_1} {n : â„•} {s : seq (generalized_continued_fraction.pair K)} [division_ring K] {gp_n gp_succ_n : generalized_continued_fraction.pair K} (s_nth_eq : s.nth n = option.some gp_n) (s_succ_nth_eq : s.nth (n + 1) = option.some gp_succ_n) : (generalized_continued_fraction.squash_seq s n).nth n = option.some {a := gp_n.a, b := gp_n.b + gp_succ_n.a / gp_succ_n.b}
theorem opens.pretopology_to_grothendieck (T : Type u) [topological_space T] : category_theory.pretopology.to_grothendieck (topological_space.opens T) (opens.pretopology T) = opens.grothendieck_topology T
theorem is_compact.exists_forall_le {Î± : Type u_1} {Î² : Type u_2} [conditionally_complete_linear_order Î±] [topological_space Î±] [order_topology Î±] [topological_space Î²] {s : set Î²} (hs : is_compact s) (ne_s : s.nonempty) {f : Î² â†’ Î±} (hf : continuous_on f s) : âˆƒ (x : Î²) (H : x âˆˆ s), âˆ€ (y : Î²), y âˆˆ s â†’ f x â‰¤ f y
theorem mv_polynomial.induction_on {R : Type u} {Ïƒ : Type u_1} [comm_semiring R] {M : mv_polynomial Ïƒ R â†’ Prop} (p : mv_polynomial Ïƒ R) (h_C : âˆ€ (a : R), M (â‡‘mv_polynomial.C a)) (h_add : âˆ€ (p q : mv_polynomial Ïƒ R), M p â†’ M q â†’ M (p + q)) (h_X : âˆ€ (p : mv_polynomial Ïƒ R) (n : Ïƒ), M p â†’ M (p * mv_polynomial.X n)) : M p
theorem module.End.map_generalized_eigenrange_le {K : Type v} {V : Type w} [field K] [add_comm_group V] [module K V] {f : module.End K V} {Î¼ : K} {n : â„•} : submodule.map f (f.generalized_eigenrange Î¼ n) â‰¤ f.generalized_eigenrange Î¼ n
theorem category_theory.limits.zero_of_to_zero {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_zero_morphisms C] {X : C} (f : X âŸ¶ 0) : f = 0
theorem nat.partition.count_of_sums_of_ne_zero {n : â„•} {l : multiset â„•} (hl : l.sum = n) {i : â„•} (hi : i â‰  0) : multiset.count i (nat.partition.of_sums n l hl).parts = multiset.count i l
theorem category_theory.sheaf.subcanonical.of_yoneda_is_sheaf {C : Type u} [category_theory.category C] (J : category_theory.grothendieck_topology C) (h : âˆ€ (X : C), category_theory.presieve.is_sheaf J (category_theory.yoneda.obj X)) : category_theory.sheaf.subcanonical J
theorem affine_independent.comp_embedding {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {Î¹ : Type u_4} {Î¹2 : Type u_5} (f : Î¹2 â†ª Î¹) {p : Î¹ â†’ P} (ha : affine_independent k p) : affine_independent k (p âˆ˜ â‡‘f)
theorem interval_integral.deriv_integral_of_tendsto_ae_right {E : Type u_3} [normed_group E] [complete_space E] [normed_space â„ E] {f : â„ â†’ E} {c : E} {a b : â„} (hf : interval_integrable f measure_theory.measure_space.volume a b) (hmeas : strongly_measurable_at_filter f (nhds b) measure_theory.measure_space.volume) (hb : filter.tendsto f (nhds b âŠ“ measure_theory.measure_space.volume.ae) (nhds c)) : deriv (Î» (u : â„), âˆ« (x : â„) in a..u, f x) b = c
theorem add_equiv.map_finsupp_sum {Î± : Type u_1} {M : Type u_5} {N : Type u_7} {P : Type u_8} [has_zero M] [add_comm_monoid N] [add_comm_monoid P] (h : N â‰ƒ+ P) (f : Î± â†’â‚€ M) (g : Î± â†’ M â†’ N) : â‡‘h (f.sum g) = f.sum (Î» (a : Î±) (b : M), â‡‘h (g a b))
theorem con.refl {M : Type u_1} [has_mul M] (c : con M) (x : M) : â‡‘c x x
theorem colex.hom_lt_iff {Î± : Type u_1} {Î² : Type u_2} [linear_order Î±] [decidable_eq Î²] [preorder Î²] {f : Î± â†’ Î²} (hâ‚ : strict_mono f) (A B : finset Î±) : (finset.image f A).to_colex < (finset.image f B).to_colex â†” A.to_colex < B.to_colex
theorem seminorm.absorbent_ball {ğ•œ : Type u_3} {E : Type u_4} [normed_field ğ•œ] [add_comm_group E] [module ğ•œ E] (p : seminorm ğ•œ E) {r : â„} {x : E} (hpr : â‡‘p x < r) : absorbent ğ•œ (p.ball x r)
theorem finite_dimensional.fact_finite_dimensional_of_finrank_eq_succ {K : Type u_1} {V : Type u_2} [field K] [add_comm_group V] [module K V] (n : â„•) [fact (finite_dimensional.finrank K V = n + 1)] : finite_dimensional K V
theorem has_lt.lt.le {Î± : Type u} [preorder Î±] {a b : Î±} : a < b â†’ a â‰¤ b
theorem mul_equiv.map_prod {Î² : Type u} {Î± : Type v} {Î³ : Type w} [comm_monoid Î²] [comm_monoid Î³] (g : Î² â‰ƒ* Î³) (f : Î± â†’ Î²) (s : finset Î±) : â‡‘g (s.prod (Î» (x : Î±), f x)) = s.prod (Î» (x : Î±), â‡‘g (f x))
theorem interval_integral.continuous_at_of_dominated_interval {E : Type u_3} [normed_group E] [complete_space E] [normed_space â„ E] {Î¼ : measure_theory.measure â„} {X : Type u_5} [topological_space X] [topological_space.first_countable_topology X] {F : X â†’ â„ â†’ E} {xâ‚€ : X} {bound : â„ â†’ â„} {a b : â„} (hF_meas : âˆ€á¶  (x : X) in nhds xâ‚€, measure_theory.ae_strongly_measurable (F x) (Î¼.restrict (set.interval_oc a b))) (h_bound : âˆ€á¶  (x : X) in nhds xâ‚€, âˆ€áµ (t : â„) âˆ‚Î¼, t âˆˆ set.interval_oc a b â†’ âˆ¥F x tâˆ¥ â‰¤ bound t) (bound_integrable : interval_integrable bound Î¼ a b) (h_cont : âˆ€áµ (t : â„) âˆ‚Î¼, t âˆˆ set.interval_oc a b â†’ continuous_at (Î» (x : X), F x t) xâ‚€) : continuous_at (Î» (x : X), âˆ« (t : â„) in a..b, F x t âˆ‚Î¼) xâ‚€
theorem has_deriv_at.lhopital_zero_at_bot {l : filter â„} {f f' g g' : â„ â†’ â„} (hff' : âˆ€á¶  (x : â„) in filter.at_bot, has_deriv_at f (f' x) x) (hgg' : âˆ€á¶  (x : â„) in filter.at_bot, has_deriv_at g (g' x) x) (hg' : âˆ€á¶  (x : â„) in filter.at_bot, g' x â‰  0) (hfbot : filter.tendsto f filter.at_bot (nhds 0)) (hgbot : filter.tendsto g filter.at_bot (nhds 0)) (hdiv : filter.tendsto (Î» (x : â„), f' x / g' x) filter.at_bot l) : filter.tendsto (Î» (x : â„), f x / g x) filter.at_bot l
theorem fintype.eq_of_subsingleton_of_sum_eq {M : Type u_4} [add_comm_monoid M] {Î¹ : Type u_1} [subsingleton Î¹] {s : finset Î¹} {f : Î¹ â†’ M} {b : M} (h : s.sum (Î» (i : Î¹), f i) = b) (i : Î¹) (H : i âˆˆ s) : f i = b
theorem has_strict_fderiv_at.map_implicit_function_eq {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] [complete_space ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] [complete_space E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] [finite_dimensional ğ•œ F] {f : E â†’ F} {f' : E â†’L[ğ•œ] F} {a : E} (hf : has_strict_fderiv_at f f' a) (hf' : f'.range = âŠ¤) : âˆ€á¶  (p : F Ã— â†¥(f'.ker)) in nhds (f a, 0), f (has_strict_fderiv_at.implicit_function f f' hf hf' p.fst p.snd) = p.fst
theorem real.sin_lt {x : â„} (h : 0 < x) : real.sin x < x
theorem is_add_regular_of_cancel_add_monoid {R : Type u_1} [add_cancel_monoid R] (g : R) : is_add_regular g
theorem add_salem_spencer_frontier {ğ•œ : Type u_4} {E : Type u_5} [linear_ordered_field ğ•œ] [topological_space E] [add_comm_monoid E] [module ğ•œ E] {s : set E} (hsâ‚€ : is_closed s) (hsâ‚ : strict_convex ğ•œ s) : add_salem_spencer (frontier s)
theorem subsemiring.mul_mem {R : Type u} [non_assoc_semiring R] (s : subsemiring R) {x y : R} : x âˆˆ s â†’ y âˆˆ s â†’ x * y âˆˆ s
theorem submodule.mem_span_finite_of_mem_span {R : Type u_1} {M : Type u_4} [semiring R] [add_comm_monoid M] [module R M] {S : set M} {x : M} (hx : x âˆˆ submodule.span R S) : âˆƒ (T : finset M), â†‘T âŠ† S âˆ§ x âˆˆ submodule.span R â†‘T
theorem category_theory.abelian.pseudoelement.pseudo_surjective_of_epi {C : Type u} [category_theory.category C] [category_theory.abelian C] {P Q : C} (f : P âŸ¶ Q) [category_theory.epi f] : function.surjective â‡‘f
theorem dfinsupp.add_hom_ext {Î¹ : Type u} {Î² : Î¹ â†’ Type v} [dec : decidable_eq Î¹] [Î  (i : Î¹), add_zero_class (Î² i)] {Î³ : Type w} [add_zero_class Î³] â¦ƒf g : (Î â‚€ (i : Î¹), Î² i) â†’+ Î³â¦„ (H : âˆ€ (i : Î¹) (y : Î² i), â‡‘f (dfinsupp.single i y) = â‡‘g (dfinsupp.single i y)) : f = g
theorem affine_subspace.le_def {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] (s1 s2 : affine_subspace k P) : s1 â‰¤ s2 â†” â†‘s1 âŠ† â†‘s2
theorem add_monoid_hom.ext_int {A : Type u_1} [add_monoid A] {f g : â„¤ â†’+ A} (h1 : â‡‘f 1 = â‡‘g 1) : f = g
theorem zsmul_right_injective {Î± : Type u_1} [linear_ordered_add_comm_group Î±] {n : â„¤} (hn : n â‰  0) : function.injective (Î» (_x : Î±), n â€¢ _x)
theorem right.add_neg_of_nonpos_of_neg {Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±} (ha : a â‰¤ 0) (hb : b < 0) : a + b < 0
theorem function.periodic.bounded_of_continuous {Î± : Type u} [pseudo_metric_space Î±] {f : â„ â†’ Î±} {c : â„} (hp : function.periodic f c) (hc : c â‰  0) (hf : continuous f) : metric.bounded (set.range f)
theorem orthonormal.oangle_add {V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) {x y z : V} (hx : x â‰  0) (hy : y â‰  0) (hz : z â‰  0) : hb.oangle x y + hb.oangle y z = hb.oangle x z
theorem metric.cthickening_cthickening_subset {Î± : Type u} [pseudo_emetric_space Î±] {Î´ Îµ : â„} (hÎµ : 0 â‰¤ Îµ) (hÎ´ : 0 â‰¤ Î´) (s : set Î±) : metric.cthickening Îµ (metric.cthickening Î´ s) âŠ† metric.cthickening (Îµ + Î´) s
theorem convex_hull_eq {R : Type u_1} {E : Type u_2} [linear_ordered_field R] [add_comm_group E] [module R E] (s : set E) : â‡‘(convex_hull R) s = {x : E | âˆƒ (Î¹ : Type u') (t : finset Î¹) (w : Î¹ â†’ R) (z : Î¹ â†’ E) (hwâ‚€ : âˆ€ (i : Î¹), i âˆˆ t â†’ 0 â‰¤ w i) (hwâ‚ : t.sum (Î» (i : Î¹), w i) = 1) (hz : âˆ€ (i : Î¹), i âˆˆ t â†’ z i âˆˆ s), t.center_mass w z = x}
theorem inv_of_one_lt_inv {Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a : Î±} : 1 < aâ»Â¹ â†’ a < 1
theorem subgroup.normal_closure_le_normal {G : Type u_1} [group G] {s : set G} {N : subgroup G} [N.normal] (h : s âŠ† â†‘N) : subgroup.normal_closure s â‰¤ N
theorem polynomial.nat_degree_cyclotomic (n : â„•) (R : Type u_1) [ring R] [nontrivial R] : (polynomial.cyclotomic n R).nat_degree = n.totient
theorem cardinal.mk_Iio_real (a : â„) : cardinal.mk â†¥(set.Iio a) = cardinal.continuum
theorem directed_on.directed_coe {Î± : Type u} {r : Î± â†’ Î± â†’ Prop} {s : set Î±} : directed_on r s â†’ directed r coe
theorem module.free.finrank_matrix (R : Type u) [ring R] [strong_rank_condition R] (m n : Type v) [fintype m] [fintype n] : finite_dimensional.finrank R (matrix m n R) = fintype.card m * fintype.card n
theorem vitali.exists_disjoint_subfamily_covering_enlargment {Î± : Type u_1} (t : set (set Î±)) (Î´ : set Î± â†’ â„) (Ï„ : â„) (hÏ„ : 1 < Ï„) (Î´nonneg : âˆ€ (a : set Î±), a âˆˆ t â†’ 0 â‰¤ Î´ a) (R : â„) (Î´le : âˆ€ (a : set Î±), a âˆˆ t â†’ Î´ a â‰¤ R) (hne : âˆ€ (a : set Î±), a âˆˆ t â†’ a.nonempty) : âˆƒ (u : set (set Î±)) (H : u âŠ† t), u.pairwise_disjoint id âˆ§ âˆ€ (a : set Î±), a âˆˆ t â†’ (âˆƒ (b : set Î±) (H : b âˆˆ u), (a âˆ© b).nonempty âˆ§ Î´ a â‰¤ Ï„ * Î´ b)
theorem polynomial.eval_multiset_prod {R : Type u} [comm_semiring R] (s : multiset (polynomial R)) (x : R) : polynomial.eval x s.prod = (multiset.map (polynomial.eval x) s).prod
theorem setoid.lift_unique {Î± : Type u_1} {Î² : Type u_2} {r : setoid Î±} {f : Î± â†’ Î²} (H : r â‰¤ setoid.ker f) (g : quotient r â†’ Î²) (Hg : f = g âˆ˜ quotient.mk) : quotient.lift f H = g
theorem matrix.det_reindex_linear_equiv_self {m : Type u_2} {n : Type u_3} (R : Type u_11) [comm_ring R] [fintype m] [decidable_eq m] [fintype n] [decidable_eq n] (e : m â‰ƒ n) (M : matrix m m R) : (â‡‘(matrix.reindex_linear_equiv R R e e) M).det = M.det
theorem convex.strict_convex {ğ•œ : Type u_1} {E : Type u_3} [ordered_semiring ğ•œ] [topological_space E] [add_comm_monoid E] [module ğ•œ E] {s : set E} (h : is_open s) (hs : convex ğ•œ s) : strict_convex ğ•œ s
theorem is_right_regular_zero_iff_subsingleton {R : Type u_1} [mul_zero_class R] : is_right_regular 0 â†” subsingleton R
theorem cont_mdiff.cont_diff {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {n : with_top â„•} {f : E â†’ E'} : cont_mdiff (model_with_corners_self ğ•œ E) (model_with_corners_self ğ•œ E') n f â†’ cont_diff ğ•œ n f
theorem continuous.exists_forall_le' {Î± : Type u_1} {Î² : Type u_2} [conditionally_complete_linear_order Î±] [topological_space Î±] [order_topology Î±] [topological_space Î²] {f : Î² â†’ Î±} (hf : continuous f) (xâ‚€ : Î²) (h : âˆ€á¶  (x : Î²) in filter.cocompact Î², f xâ‚€ â‰¤ f x) : âˆƒ (x : Î²), âˆ€ (y : Î²), f x â‰¤ f y
theorem category_theory.cover_dense.sheaf_hom_eq {C : Type u_1} [category_theory.category C] {D : Type u_3} [category_theory.category D] {K : category_theory.grothendieck_topology D} {A : Type u_7} [category_theory.category A] {G : C â¥¤ D} (H : category_theory.cover_dense K G) [category_theory.full G] {â„± : Dáµ’áµ– â¥¤ A} {â„±' : category_theory.Sheaf K A} (Î± : â„± âŸ¶ â„±'.val) : H.sheaf_hom (category_theory.whisker_left G.op Î±) = Î±
theorem measure_theory.is_add_fundamental_domain.ess_sup_measure_restrict {G : Type u_1} {Î± : Type u_2} [add_group G] [add_action G Î±] [measurable_space Î±] {s : set Î±} {Î¼ : measure_theory.measure Î±} [measurable_space G] [has_measurable_vadd G Î±] [measure_theory.vadd_invariant_measure G Î± Î¼] [encodable G] (hs : measure_theory.is_add_fundamental_domain G s Î¼) {f : Î± â†’ ennreal} (hf : âˆ€ (Î³ : G) (x : Î±), f (Î³ +áµ¥ x) = f x) : ess_sup f (Î¼.restrict s) = ess_sup f Î¼
theorem pgame.mk_le_mk {xl xr : Type u_1} {xL : xl â†’ pgame} {xR : xr â†’ pgame} {yl yr : Type u_1} {yL : yl â†’ pgame} {yR : yr â†’ pgame} : pgame.mk xl xr xL xR â‰¤ pgame.mk yl yr yL yR â†” (âˆ€ (i : xl), (xL i).lf (pgame.mk yl yr yL yR)) âˆ§ âˆ€ (j : yr), (pgame.mk xl xr xL xR).lf (yR j)
theorem is_complemented_of_Sup_atoms_eq_top {Î± : Type u_1} [complete_lattice Î±] [is_modular_lattice Î±] [is_compactly_generated Î±] (h : has_Sup.Sup {a : Î± | is_atom a} = âŠ¤) : is_complemented Î±
theorem monoid_hom.map_closure {G : Type u_1} [group G] {N : Type u_3} [group N] (f : G â†’* N) (s : set G) : subgroup.map f (subgroup.closure s) = subgroup.closure (â‡‘f '' s)
theorem affine.simplex.points_with_circumcenter_eq_circumcenter {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {n : â„•} (s : affine.simplex â„ P n) : s.points_with_circumcenter affine.simplex.points_with_circumcenter_index.circumcenter_index = s.circumcenter
theorem subsemiring.multiset_sum_mem {R : Type u} [non_assoc_semiring R] (s : subsemiring R) (m : multiset R) : (âˆ€ (a : R), a âˆˆ m â†’ a âˆˆ s) â†’ m.sum âˆˆ s
theorem basis.ext {Î¹ : Type u_1} {R : Type u_3} {M : Type u_5} [semiring R] [add_comm_monoid M] [module R M] (b : basis Î¹ R M) {Râ‚ : Type u_9} [semiring Râ‚] {Ïƒ : R â†’+* Râ‚} {Mâ‚ : Type u_10} [add_comm_monoid Mâ‚] [module Râ‚ Mâ‚] {fâ‚ fâ‚‚ : M â†’â‚›â‚—[Ïƒ] Mâ‚} (h : âˆ€ (i : Î¹), â‡‘fâ‚ (â‡‘b i) = â‡‘fâ‚‚ (â‡‘b i)) : fâ‚ = fâ‚‚
theorem coe_lower_central_series_ideal_quot_eq {R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] {I : lie_ideal R L} (k : â„•) : â†‘(lie_module.lower_central_series R L (L â§¸ I) k) = â†‘(lie_module.lower_central_series R (L â§¸ I) (L â§¸ I) k)
theorem int.modeq.pow_card_sub_one_eq_one {p : â„•} (hp : nat.prime p) {n : â„¤} (hpn : is_coprime n â†‘p) : n ^ (p - 1) â‰¡ 1 [ZMOD â†‘p]
theorem finset.sum_induction {Î± : Type v} {s : finset Î±} {M : Type u_1} [add_comm_monoid M] (f : Î± â†’ M) (p : M â†’ Prop) (p_mul : âˆ€ (a b : M), p a â†’ p b â†’ p (a + b)) (p_one : p 0) (p_s : âˆ€ (x : Î±), x âˆˆ s â†’ p (f x)) : p (s.sum (Î» (x : Î±), f x))
theorem left.add_neg' {Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : a < 0) (hb : b < 0) : a + b < 0
theorem affine_independent_iff_le_finrank_vector_span (k : Type u_1) {V : Type u_2} {P : Type u_3} {Î¹ : Type u_4} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] [fintype Î¹] (p : Î¹ â†’ P) {n : â„•} (hc : fintype.card Î¹ = n + 1) : affine_independent k p â†” n â‰¤ finite_dimensional.finrank k â†¥(vector_span k (set.range p))
theorem submodule.span_eq_restrict_scalars (R : Type u_1) (A : Type u_2) (M : Type u_3) [comm_semiring R] [semiring A] [algebra R A] [add_comm_monoid M] [module R M] [module A M] [is_scalar_tower R A M] (X : set M) (hsur : function.surjective â‡‘(algebra_map R A)) : submodule.span R X = submodule.restrict_scalars R (submodule.span A X)
theorem matrix.det_neg_eq_smul {n : Type u_2} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] (A : matrix n n R) : (-A).det = (-1) ^ fintype.card n â€¢ A.det
theorem inner_product_geometry.angle_nonneg {V : Type u_1} [inner_product_space â„ V] (x y : V) : 0 â‰¤ inner_product_geometry.angle x y
theorem sub_mul_add_eq_of_mul_add_eq_mul_add {Î± : Type u} [non_unital_non_assoc_ring Î±] {a b c d e : Î±} : a * e + c = b * e + d â†’ (a - b) * e + c = d
theorem cont_diff_on_succ_iff_fderiv_within {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {s : set E} {f : E â†’ F} {n : â„•} (hs : unique_diff_on ğ•œ s) : cont_diff_on ğ•œ â†‘(n + 1) f s â†” differentiable_on ğ•œ f s âˆ§ cont_diff_on ğ•œ â†‘n (Î» (y : E), fderiv_within ğ•œ f s y) s
theorem cont_mdiff_within_at_iff' {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {M : Type u_4} [topological_space M] [charted_space H M] [Is : smooth_manifold_with_corners I M] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {H' : Type u_6} [topological_space H'] {I' : model_with_corners ğ•œ E' H'} {M' : Type u_7} [topological_space M'] [charted_space H' M'] [I's : smooth_manifold_with_corners I' M'] {f : M â†’ M'} {s : set M} {x : M} {n : with_top â„•} {x' : M} {y : M'} (hx : x' âˆˆ (charted_space.chart_at H x).to_local_equiv.source) (hy : f x' âˆˆ (charted_space.chart_at H' y).to_local_equiv.source) : cont_mdiff_within_at I I' n f s x' â†” continuous_within_at f s x' âˆ§ cont_diff_within_at ğ•œ n (â‡‘(ext_chart_at I' y) âˆ˜ f âˆ˜ â‡‘((ext_chart_at I x).symm)) ((ext_chart_at I x).target âˆ© â‡‘((ext_chart_at I x).symm) â»Â¹' (s âˆ© f â»Â¹' (ext_chart_at I' y).source)) (â‡‘(ext_chart_at I x) x')
theorem is_localization.is_localization_is_localization_at_prime_is_localization {R : Type u_1} [comm_ring R] (M : submonoid R) {S : Type u_2} [comm_ring S] [algebra R S] (T : Type u_4) [comm_ring T] [algebra R T] [algebra S T] [is_scalar_tower R S T] [is_localization M S] (p : ideal S) [Hp : p.is_prime] [is_localization.at_prime T p] : is_localization.at_prime T (ideal.comap (algebra_map R S) p)
theorem orientation.oangle_eq_two_zsmul_oangle_sub_of_norm_eq {V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) {x y z : V} (hxyne : x â‰  y) (hxzne : x â‰  z) (hxy : âˆ¥xâˆ¥ = âˆ¥yâˆ¥) (hxz : âˆ¥xâˆ¥ = âˆ¥zâˆ¥) : o.oangle y z = 2 â€¢ o.oangle (y - x) (z - x)
theorem has_fpower_series_on_ball.fderiv {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {p : formal_multilinear_series ğ•œ E F} {r : ennreal} {f : E â†’ F} {x : E} [complete_space F] (h : has_fpower_series_on_ball f p x r) : has_fpower_series_on_ball (fderiv ğ•œ f) (â†‘(continuous_multilinear_curry_fin1 ğ•œ E F).comp_formal_multilinear_series (p.change_origin_series 1)) x r
theorem is_primitive_root.sub_one_norm_eq_eval_cyclotomic {n : â„•+} {K : Type u} {L : Type v} [field L] {Î¶ : L} (hÎ¶ : is_primitive_root Î¶ â†‘n) [field K] [algebra K L] [ne_zero â†‘â†‘n] [is_cyclotomic_extension {n} K L] (h : 2 < â†‘n) (hirr : irreducible (polynomial.cyclotomic â†‘n K)) : â‡‘(algebra.norm K) (Î¶ - 1) = â†‘(polynomial.eval 1 (polynomial.cyclotomic â†‘n â„¤))
theorem exists_lt_of_lt_cSup {Î± : Type u_1} [conditionally_complete_linear_order Î±] {s : set Î±} {b : Î±} (hs : s.nonempty) (hb : b < has_Sup.Sup s) : âˆƒ (a : Î±) (H : a âˆˆ s), b < a
theorem interval_integral.integral_has_strict_deriv_at_of_tendsto_ae_right {E : Type u_3} [normed_group E] [complete_space E] [normed_space â„ E] {f : â„ â†’ E} {c : E} {a b : â„} (hf : interval_integrable f measure_theory.measure_space.volume a b) (hmeas : strongly_measurable_at_filter f (nhds b) measure_theory.measure_space.volume) (hb : filter.tendsto f (nhds b âŠ“ measure_theory.measure_space.volume.ae) (nhds c)) : has_strict_deriv_at (Î» (u : â„), âˆ« (x : â„) in a..u, f x) c b
theorem collinear_empty (k : Type u_1) {V : Type u_2} (P : Type u_3) [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] : collinear k âˆ…
theorem iterated_fderiv_within_succ_eq_comp_right {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {s : set E} {f : E â†’ F} {x : E} {n : â„•} (hs : unique_diff_on ğ•œ s) (hx : x âˆˆ s) : iterated_fderiv_within ğ•œ (n + 1) f s x = (â‡‘(continuous_multilinear_curry_right_equiv' ğ•œ n E F) âˆ˜ iterated_fderiv_within ğ•œ n (Î» (y : E), fderiv_within ğ•œ f s y) s) x
theorem dimH_range_le_of_locally_lipschitz_on {X : Type u_2} {Y : Type u_3} [emetric_space X] [emetric_space Y] [topological_space.second_countable_topology X] {f : X â†’ Y} (hf : âˆ€ (x : X), âˆƒ (C : nnreal) (s : set X) (H : s âˆˆ nhds x), lipschitz_on_with C f s) : dimH (set.range f) â‰¤ dimH set.univ
theorem measure_theory.conservative.measure_mem_forall_ge_image_not_mem_eq_zero {Î± : Type u_2} [measurable_space Î±] {f : Î± â†’ Î±} {s : set Î±} {Î¼ : measure_theory.measure Î±} (hf : measure_theory.conservative f Î¼) (hs : measurable_set s) (n : â„•) : â‡‘Î¼ {x âˆˆ s | âˆ€ (m : â„•), m â‰¥ n â†’ f^[m] x âˆ‰ s} = 0
theorem unique_mdiff_on.unique_diff_on {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {s : set E} : unique_mdiff_on (model_with_corners_self ğ•œ E) s â†’ unique_diff_on ğ•œ s
theorem pred.rec {Î± : Type u_1} [preorder Î±] [pred_order Î±] [is_pred_archimedean Î±] {P : Î± â†’ Prop} {m : Î±} (h0 : P m) (h1 : âˆ€ (n : Î±), n â‰¤ m â†’ P n â†’ P (order.pred n)) â¦ƒn : Î±â¦„ (hmn : n â‰¤ m) : P n
theorem right.one_lt_mul {Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_mul.mul) has_lt.lt] {a b : Î±} (ha : 1 < a) (hb : 1 < b) : 1 < a * b
theorem sum_eight_sq_mul_sum_eight_sq {R : Type u_1} [comm_ring R] {xâ‚ xâ‚‚ xâ‚ƒ xâ‚„ xâ‚… xâ‚† xâ‚‡ xâ‚ˆ yâ‚ yâ‚‚ yâ‚ƒ yâ‚„ yâ‚… yâ‚† yâ‚‡ yâ‚ˆ : R} : (xâ‚ ^ 2 + xâ‚‚ ^ 2 + xâ‚ƒ ^ 2 + xâ‚„ ^ 2 + xâ‚… ^ 2 + xâ‚† ^ 2 + xâ‚‡ ^ 2 + xâ‚ˆ ^ 2) * (yâ‚ ^ 2 + yâ‚‚ ^ 2 + yâ‚ƒ ^ 2 + yâ‚„ ^ 2 + yâ‚… ^ 2 + yâ‚† ^ 2 + yâ‚‡ ^ 2 + yâ‚ˆ ^ 2) = (xâ‚ * yâ‚ - xâ‚‚ * yâ‚‚ - xâ‚ƒ * yâ‚ƒ - xâ‚„ * yâ‚„ - xâ‚… * yâ‚… - xâ‚† * yâ‚† - xâ‚‡ * yâ‚‡ - xâ‚ˆ * yâ‚ˆ) ^ 2 + (xâ‚ * yâ‚‚ + xâ‚‚ * yâ‚ + xâ‚ƒ * yâ‚„ - xâ‚„ * yâ‚ƒ + xâ‚… * yâ‚† - xâ‚† * yâ‚… - xâ‚‡ * yâ‚ˆ + xâ‚ˆ * yâ‚‡) ^ 2 + (xâ‚ * yâ‚ƒ - xâ‚‚ * yâ‚„ + xâ‚ƒ * yâ‚ + xâ‚„ * yâ‚‚ + xâ‚… * yâ‚‡ + xâ‚† * yâ‚ˆ - xâ‚‡ * yâ‚… - xâ‚ˆ * yâ‚†) ^ 2 + (xâ‚ * yâ‚„ + xâ‚‚ * yâ‚ƒ - xâ‚ƒ * yâ‚‚ + xâ‚„ * yâ‚ + xâ‚… * yâ‚ˆ - xâ‚† * yâ‚‡ + xâ‚‡ * yâ‚† - xâ‚ˆ * yâ‚…) ^ 2 + (xâ‚ * yâ‚… - xâ‚‚ * yâ‚† - xâ‚ƒ * yâ‚‡ - xâ‚„ * yâ‚ˆ + xâ‚… * yâ‚ + xâ‚† * yâ‚‚ + xâ‚‡ * yâ‚ƒ + xâ‚ˆ * yâ‚„) ^ 2 + (xâ‚ * yâ‚† + xâ‚‚ * yâ‚… - xâ‚ƒ * yâ‚ˆ + xâ‚„ * yâ‚‡ - xâ‚… * yâ‚‚ + xâ‚† * yâ‚ - xâ‚‡ * yâ‚„ + xâ‚ˆ * yâ‚ƒ) ^ 2 + (xâ‚ * yâ‚‡ + xâ‚‚ * yâ‚ˆ + xâ‚ƒ * yâ‚… - xâ‚„ * yâ‚† - xâ‚… * yâ‚ƒ + xâ‚† * yâ‚„ + xâ‚‡ * yâ‚ - xâ‚ˆ * yâ‚‚) ^ 2 + (xâ‚ * yâ‚ˆ - xâ‚‚ * yâ‚‡ + xâ‚ƒ * yâ‚† + xâ‚„ * yâ‚… - xâ‚… * yâ‚„ - xâ‚† * yâ‚ƒ + xâ‚‡ * yâ‚‚ + xâ‚ˆ * yâ‚) ^ 2
theorem char_zero.of_module (R : Type u_2) (M : Type u_5) [semiring R] [add_comm_monoid M] [module R M] [has_one M] [char_zero M] : char_zero R
theorem left.add_neg_of_neg_of_nonpos {Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : a < 0) (hb : b â‰¤ 0) : a + b < 0
theorem add_submonoid.fg_iff {M : Type u_1} [add_monoid M] (P : add_submonoid M) : P.fg â†” âˆƒ (S : set M), add_submonoid.closure S = P âˆ§ S.finite
theorem basis.ext_alternating {Î¹ : Type u_6} [decidable_eq Î¹] {Î¹â‚ : Type u_7} [fintype Î¹] {R' : Type u_8} {Nâ‚ : Type u_9} {Nâ‚‚ : Type u_10} [comm_semiring R'] [add_comm_monoid Nâ‚] [add_comm_monoid Nâ‚‚] [module R' Nâ‚] [module R' Nâ‚‚] {f g : alternating_map R' Nâ‚ Nâ‚‚ Î¹} (e : basis Î¹â‚ R' Nâ‚) (h : âˆ€ (v : Î¹ â†’ Î¹â‚), function.injective v â†’ â‡‘f (Î» (i : Î¹), â‡‘e (v i)) = â‡‘g (Î» (i : Î¹), â‡‘e (v i))) : f = g
theorem list.chain.induction {Î± : Type u} {r : Î± â†’ Î± â†’ Prop} {a b : Î±} (p : Î± â†’ Prop) (l : list Î±) (h : list.chain r a l) (hb : (a :: l).last _ = b) (carries : âˆ€ â¦ƒx y : Î±â¦„, r x y â†’ p y â†’ p x) (final : p b) (i : Î±) (H : i âˆˆ a :: l) : p i
theorem continuous_multilinear_map.op_norm_le_bound {ğ•œ : Type u} {Î¹ : Type v} {E : Î¹ â†’ Type wE} {G : Type wG} [decidable_eq Î¹] [fintype Î¹] [nondiscrete_normed_field ğ•œ] [Î  (i : Î¹), normed_group (E i)] [Î  (i : Î¹), normed_space ğ•œ (E i)] [normed_group G] [normed_space ğ•œ G] (f : continuous_multilinear_map ğ•œ E G) {M : â„} (hMp : 0 â‰¤ M) (hM : âˆ€ (m : Î  (i : Î¹), E i), âˆ¥â‡‘f mâˆ¥ â‰¤ M * finset.univ.prod (Î» (i : Î¹), âˆ¥m iâˆ¥)) : âˆ¥fâˆ¥ â‰¤ M
theorem category_theory.preadditive.exact_iff_homology_zero {V : Type u} [category_theory.category V] [category_theory.limits.has_images V] [category_theory.limits.has_zero_object V] [category_theory.preadditive V] [category_theory.limits.has_kernels V] [category_theory.limits.has_cokernels V] {A B C : V} (f : A âŸ¶ B) (g : B âŸ¶ C) : category_theory.exact f g â†” âˆƒ (w : f â‰« g = 0), nonempty (homology f g w â‰… 0)
theorem category_theory.is_subterminal_of_is_iso_diag {C : Type uâ‚} [category_theory.category C] {A : C} [category_theory.limits.has_binary_product A A] [category_theory.is_iso (category_theory.limits.diag A)] : category_theory.is_subterminal A
theorem measure_theory.measure.map_haar_inv {G : Type u_1} [comm_group G] [topological_space G] [topological_group G] [t2_space G] [measurable_space G] [borel_space G] [locally_compact_space G] [topological_space.second_countable_topology G] (Î¼ : measure_theory.measure G) [Î¼.is_haar_measure] : measure_theory.measure.map has_inv.inv Î¼ = Î¼
theorem category_theory.is_subterminal.is_iso_diag {C : Type uâ‚} [category_theory.category C] {A : C} (hA : category_theory.is_subterminal A) [category_theory.limits.has_binary_product A A] : category_theory.is_iso (category_theory.limits.diag A)
theorem fixed_points.to_alg_hom_bijective (G : Type u) (F : Type v) [group G] [field F] [fintype G] [mul_semiring_action G F] [has_faithful_smul G F] : function.bijective (mul_semiring_action.to_alg_hom â†¥(fixed_points.subfield G F) F)
theorem perfection_map.id (p : â„•) [fact (nat.prime p)] (R : Type uâ‚) [comm_semiring R] [char_p R p] [perfect_ring R p] : perfection_map p (ring_hom.id R)
theorem is_fraction_ring.char_zero_of_is_fraction_ring (R : Type u_1) {K : Type u_2} [comm_ring R] [field K] [algebra R K] [is_fraction_ring R K] [char_zero R] : char_zero K
theorem eq_orthogonal_projection_of_mem_orthogonal' {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {K : submodule ğ•œ E} [complete_space â†¥K] {u v z : E} (hv : v âˆˆ K) (hz : z âˆˆ Ká—®) (hu : u = v + z) : â†‘(â‡‘(orthogonal_projection K) u) = v
theorem metric.Hausdorff_dist_triangle' {Î± : Type u} [pseudo_metric_space Î±] {s t u : set Î±} (fin : emetric.Hausdorff_edist t u â‰  âŠ¤) : metric.Hausdorff_dist s u â‰¤ metric.Hausdorff_dist s t + metric.Hausdorff_dist t u
theorem lower_semicontinuous_on.add' {Î± : Type u_1} [topological_space Î±] {s : set Î±} {Î³ : Type u_4} [linear_ordered_add_comm_monoid Î³] [topological_space Î³] [order_topology Î³] {f g : Î± â†’ Î³} (hf : lower_semicontinuous_on f s) (hg : lower_semicontinuous_on g s) (hcont : âˆ€ (x : Î±), x âˆˆ s â†’ continuous_at (Î» (p : Î³ Ã— Î³), p.fst + p.snd) (f x, g x)) : lower_semicontinuous_on (Î» (z : Î±), f z + g z) s
theorem complex.Gamma_add_one (s : â„‚) (h2 : s â‰  0) : (s + 1).Gamma = s * s.Gamma
theorem con.ker_apply_eq_preimage {M : Type u_1} {P : Type u_3} [mul_one_class M] [mul_one_class P] {f : M â†’* P} (x : M) : â‡‘(con.ker f) x = â‡‘f â»Â¹' {â‡‘f x}
theorem module.free.finrank_pi_fintype (R : Type u) [ring R] [strong_rank_condition R] {Î¹ : Type v} [fintype Î¹] {M : Î¹ â†’ Type w} [Î  (i : Î¹), add_comm_group (M i)] [Î  (i : Î¹), module R (M i)] [âˆ€ (i : Î¹), module.free R (M i)] [âˆ€ (i : Î¹), module.finite R (M i)] : finite_dimensional.finrank R (Î  (i : Î¹), M i) = finset.univ.sum (Î» (i : Î¹), finite_dimensional.finrank R (M i))
theorem convex_independent_set_iff_not_mem_convex_hull_diff {ğ•œ : Type u_1} {E : Type u_2} [ordered_semiring ğ•œ] [add_comm_group E] [module ğ•œ E] {s : set E} : convex_independent ğ•œ (Î» (x : â†¥s), â†‘x) â†” âˆ€ (x : E), x âˆˆ s â†’ x âˆ‰ â‡‘(convex_hull ğ•œ) (s  {x})
theorem one_lt_inv' {Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a : Î±} : 1 < aâ»Â¹ â†” a < 1
theorem antitone.sup {Î± : Type u} {Î² : Type v} [preorder Î±] [semilattice_sup Î²] {f g : Î± â†’ Î²} (hf : antitone f) (hg : antitone g) : antitone (f âŠ” g)
theorem dense.bUnion_uniformity_ball {Î± : Type u_1} [uniform_space Î±] {s : set Î±} {U : set (Î± Ã— Î±)} (hs : dense s) (hU : U âˆˆ uniformity Î±) : (â‹ƒ (x : Î±) (H : x âˆˆ s), uniform_space.ball x U) = set.univ
theorem linear_map.ext_on {R : Type u_1} {Râ‚‚ : Type u_2} {M : Type u_4} {Mâ‚‚ : Type u_5} [semiring R] [add_comm_monoid M] [module R M] [semiring Râ‚‚] [add_comm_monoid Mâ‚‚] [module Râ‚‚ Mâ‚‚] {Ïƒâ‚â‚‚ : R â†’+* Râ‚‚} {s : set M} {f g : M â†’â‚›â‚—[Ïƒâ‚â‚‚] Mâ‚‚} (hv : submodule.span R s = âŠ¤) (h : set.eq_on â‡‘f â‡‘g s) : f = g
theorem irrational_sqrt_two  : irrational (real.sqrt 2)
theorem is_compact.bdd_below_image {Î± : Type u} {Î² : Type v} [topological_space Î±] [linear_order Î±] [order_closed_topology Î±] [nonempty Î±] [topological_space Î²] {f : Î² â†’ Î±} {K : set Î²} (hK : is_compact K) (hf : continuous_on f K) : bdd_below (f '' K)
theorem pi.single_commute {I : Type u} {f : I â†’ Type v} [decidable_eq I] [Î  (i : I), add_zero_class (f i)] : pairwise (Î» (i j : I), âˆ€ (x : f i) (y : f j), add_commute (pi.single i x) (pi.single j y))
theorem filter.Coprod_cofinite {Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_2} [fintype Î¹] : filter.Coprod (Î» (i : Î¹), filter.cofinite) = filter.cofinite
theorem ring_hom.range_top_of_surjective {R : Type u} {S : Type v} [ring R] [ring S] (f : R â†’+* S) (hf : function.surjective â‡‘f) : f.range = âŠ¤
theorem finset.inf_univ_eq_infi {Î± : Type u_1} {Î² : Type u_2} [fintype Î±] [complete_lattice Î²] (f : Î± â†’ Î²) : finset.univ.inf f = infi f
theorem unique_diff_on.pi {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] (Î¹ : Type u_2) [fintype Î¹] (E : Î¹ â†’ Type u_3) [Î  (i : Î¹), normed_group (E i)] [Î  (i : Î¹), normed_space ğ•œ (E i)] (s : Î  (i : Î¹), set (E i)) (I : set Î¹) (h : âˆ€ (i : Î¹), i âˆˆ I â†’ unique_diff_on ğ•œ (s i)) : unique_diff_on ğ•œ (I.pi s)
theorem category_theory.limits.has_colimits_of_shape_op_of_has_limits_of_shape {C : Type uâ‚} [category_theory.category C] {J : Type uâ‚‚} [category_theory.category J] [category_theory.limits.has_limits_of_shape Jáµ’áµ– C] : category_theory.limits.has_colimits_of_shape J Cáµ’áµ–
theorem continuous_map.compact_open_eq_compact_convergence {Î± : Type uâ‚} {Î² : Type uâ‚‚} [topological_space Î±] [uniform_space Î²] : continuous_map.compact_open = continuous_map.compact_convergence_topology
theorem monotone.ne_of_lt_of_lt_int {Î± : Type u} [preorder Î±] {f : â„¤ â†’ Î±} (hf : monotone f) (n : â„¤) {x : Î±} (h1 : f n < x) (h2 : x < f (n + 1)) (a : â„¤) : f a â‰  x
theorem homotopy.map_null_homotopic_map' {Î¹ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape Î¹} {C D : homological_complex V c} {W : Type u_2} [category_theory.category W] [category_theory.preadditive W] (G : V â¥¤ W) [G.additive] (hom : Î  (i j : Î¹), c.rel j i â†’ (C.X i âŸ¶ D.X j)) : (G.map_homological_complex c).map (homotopy.null_homotopic_map' hom) = homotopy.null_homotopic_map' (Î» (i j : Î¹) (hij : c.rel j i), G.map (hom i j hij))
theorem measure_theory.analytic_set.Union {Î± : Type u_1} [topological_space Î±] {Î¹ : Type u_2} [encodable Î¹] {s : Î¹ â†’ set Î±} (hs : âˆ€ (n : Î¹), measure_theory.analytic_set (s n)) : measure_theory.analytic_set (â‹ƒ (n : Î¹), s n)
theorem matrix.det_conj_of_mul_eq_one {A : Type u_5} [comm_ring A] {m : Type u_6} {n : Type u_7} [fintype m] [fintype n] [decidable_eq m] [decidable_eq n] {M : matrix m n A} {M' : matrix n m A} {N : matrix n n A} (hMM' : M.mul M' = 1) (hM'M : M'.mul M = 1) : ((M.mul N).mul M').det = N.det
theorem ordinal.fp_bfamily_unbounded {o : ordinal} {f : Î  (b : ordinal), b < o â†’ ordinal â†’ ordinal} (H : âˆ€ (i : ordinal) (hi : i < o), ordinal.is_normal (f i hi)) : set.unbounded has_lt.lt (â‹‚ (i : ordinal) (hi : i < o), function.fixed_points (f i hi))
theorem clifford_algebra.even_odd_induction {R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] (Q : quadratic_form R M) (n : zmod 2) {P : Î  (x : clifford_algebra Q), x âˆˆ clifford_algebra.even_odd Q n â†’ Prop} (hr : âˆ€ (v : clifford_algebra Q) (h : v âˆˆ (clifford_algebra.Î¹ Q).range ^ n.val), P v _) (hadd : âˆ€ {x y : clifford_algebra Q} {hx : x âˆˆ clifford_algebra.even_odd Q n} {hy : y âˆˆ clifford_algebra.even_odd Q n}, P x hx â†’ P y hy â†’ P (x + y) _) (hÎ¹Î¹_mul : âˆ€ (mâ‚ mâ‚‚ : M) {x : clifford_algebra Q} {hx : x âˆˆ clifford_algebra.even_odd Q n}, P x hx â†’ P (â‡‘(clifford_algebra.Î¹ Q) mâ‚ * â‡‘(clifford_algebra.Î¹ Q) mâ‚‚ * x) _) (x : clifford_algebra Q) (hx : x âˆˆ clifford_algebra.even_odd Q n) : P x hx
theorem category_theory.cover_dense.iso_of_restrict_iso {C : Type u_1} [category_theory.category C] {D : Type u_3} [category_theory.category D] {K : category_theory.grothendieck_topology D} {A : Type u_7} [category_theory.category A] {G : C â¥¤ D} (H : category_theory.cover_dense K G) [category_theory.full G] {â„± â„±' : category_theory.Sheaf K A} (Î± : â„± âŸ¶ â„±') (i : category_theory.is_iso (category_theory.whisker_left G.op Î±.val)) : category_theory.is_iso Î±
theorem finite_of_is_noetherian_linear_independent {R : Type u} [ring R] [strong_rank_condition R] {M : Type v} [add_comm_group M] [module R M] [is_noetherian R M] {s : set M} (hi : linear_independent R coe) : s.finite
theorem cont_mdiff.cod_restrict_sphere {E : Type u_1} [inner_product_space â„ E] {F : Type u_2} [normed_group F] [normed_space â„ F] {H : Type u_3} [topological_space H] {I : model_with_corners â„ F H} {M : Type u_4} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {n : â„•} [fact (finite_dimensional.finrank â„ E = n + 1)] {m : with_top â„•} {f : M â†’ E} (hf : cont_mdiff I (model_with_corners_self â„ E) m f) (hf' : âˆ€ (x : M), f x âˆˆ metric.sphere 0 1) : cont_mdiff I (model_with_corners_self â„ (euclidean_space â„ (fin n))) m (set.cod_restrict (Î» (x : M), f x) (metric.sphere 0 1) hf')
theorem filter.frequently.eventually {Î± : Type u} {f : ultrafilter Î±} {p : Î± â†’ Prop} : (âˆƒá¶  (x : Î±) in â†‘f, p x) â†’ (âˆ€á¶  (x : Î±) in â†‘f, p x)
theorem affine_basis.to_matrix_inv_vec_mul_to_matrix {Î¹ : Type uâ‚} {k : Type uâ‚‚} {V : Type uâ‚ƒ} {P : Type uâ‚„} [add_comm_group V] [add_torsor V P] [comm_ring k] [module k V] [decidable_eq Î¹] [fintype Î¹] (b bâ‚‚ : affine_basis Î¹ k P) (x : P) : matrix.vec_mul (â‡‘(b.coords) x) (b.to_matrix bâ‚‚.points)â»Â¹ = â‡‘(bâ‚‚.coords) x
theorem orthonormal_iff_ite {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {Î¹ : Type u_4} [dec_Î¹ : decidable_eq Î¹] {v : Î¹ â†’ E} : orthonormal ğ•œ v â†” âˆ€ (i j : Î¹), has_inner.inner (v i) (v j) = ite (i = j) 1 0
theorem continuous_linear_map.continuousâ‚‚ {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {G : Type u_4} [normed_group G] [normed_space ğ•œ G] (f : E â†’L[ğ•œ] F â†’L[ğ•œ] G) : continuous (function.uncurry (Î» (x : E) (y : F), â‡‘(â‡‘f x) y))
theorem generalized_continued_fraction.int_fract_pair.of_inv_fr_num_lt_num_of_pos {q : â„š} (q_pos : 0 < q) : (generalized_continued_fraction.int_fract_pair.of qâ»Â¹).fr.num < q.num
theorem has_lt.lt.exists_lt_lt {Î± : Type u_1} [has_lt Î±] {a b : Î±} (h : a < b) : Â¬a â‹– b â†’ (âˆƒ (c : Î±), a < c âˆ§ c < b)
theorem one_div_lt_one_div_of_neg {Î± : Type u_1} [linear_ordered_field Î±] {a b : Î±} (ha : a < 0) (hb : b < 0) : 1 / a < 1 / b â†” b < a
theorem ideal.supr_infi_eq_top_iff_pairwise {Î¹ : Type u_1} {R : Type u_2} [comm_semiring R] {t : finset Î¹} (h : t.nonempty) (I : Î¹ â†’ ideal R) : (â¨† (i : Î¹) (H : i âˆˆ t), â¨… (j : Î¹) (hj : j âˆˆ t) (ij : j â‰  i), I j) = âŠ¤ â†” â†‘t.pairwise (Î» (i j : Î¹), I i âŠ” I j = âŠ¤)
theorem is_o_pow_const_const_pow_of_one_lt {R : Type u_1} [normed_ring R] (k : â„•) {r : â„} (hr : 1 < r) : (Î» (n : â„•), â†‘n ^ k) =o[filter.at_top] Î» (n : â„•), r ^ n
theorem affine_subspace.span_union (k : Type u_1) (V : Type u_2) {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] (s t : set P) : affine_span k (s âˆª t) = affine_span k s âŠ” affine_span k t
theorem tactic.coherence.assoc_lift_hom {C : Type u} [category_theory.category C] [category_theory.monoidal_category C] {W X Y Z : C} [category_theory.monoidal_category.lift_obj W] [category_theory.monoidal_category.lift_obj X] [category_theory.monoidal_category.lift_obj Y] (f : W âŸ¶ X) (g : X âŸ¶ Y) (h : Y âŸ¶ Z) [category_theory.monoidal_category.lift_hom f] [category_theory.monoidal_category.lift_hom g] : f â‰« g â‰« h = (f â‰« g) â‰« h
theorem category_theory.abelian.coimage.fac {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_kernels C] [category_theory.limits.has_cokernels C] {P Q : C} (f : P âŸ¶ Q) : category_theory.abelian.coimage.Ï€ f â‰« category_theory.abelian.factor_thru_coimage f = f
theorem emetric.nonempty_compacts.is_closed_in_closeds {Î± : Type u} [emetric_space Î±] [complete_space Î±] : is_closed (set.range topological_space.nonempty_compacts.to_closeds)
theorem orientation.eq_rotation_self_iff {V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) (x : V) (Î¸ : real.angle) : x = â‡‘(o.rotation Î¸) x â†” x = 0 âˆ¨ Î¸ = 0
theorem algebra.discr_is_integral {Î¹ : Type w} [fintype Î¹] (K : Type u) {L : Type v} [field K] [field L] [algebra K L] [module.finite K L] {R : Type z} [comm_ring R] [algebra R K] [algebra R L] [is_scalar_tower R K L] {b : Î¹ â†’ L} (h : âˆ€ (i : Î¹), is_integral R (b i)) : is_integral R (algebra.discr K b)
theorem has_strict_fderiv_at_of_has_fderiv_at_of_continuous_at {ğ•œ : Type u_3} [is_R_or_C ğ•œ] {G : Type u_4} [normed_group G] [normed_space ğ•œ G] {H : Type u_5} [normed_group H] [normed_space ğ•œ H] {f : G â†’ H} {f' : G â†’ (G â†’L[ğ•œ] H)} {x : G} (hder : âˆ€á¶  (y : G) in nhds x, has_fderiv_at f (f' y) y) (hcont : continuous_at f' x) : has_strict_fderiv_at f (f' x) x
theorem ring_hom.domain_nontrivial {Î± : Type u_2} {Î² : Type u_3} {rÎ± : non_assoc_semiring Î±} {rÎ² : non_assoc_semiring Î²} (f : Î± â†’+* Î²) [nontrivial Î²] : nontrivial Î±
theorem seminorm.le_insert' {ğ•œ : Type u_3} {E : Type u_4} [semi_normed_ring ğ•œ] [add_comm_group E] [module ğ•œ E] (p : seminorm ğ•œ E) (x y : E) : â‡‘p x â‰¤ â‡‘p y + â‡‘p (x - y)
theorem add_subgroup.closure_mono {G : Type u_1} [add_group G] â¦ƒh k : set Gâ¦„ (h' : h âŠ† k) : add_subgroup.closure h â‰¤ add_subgroup.closure k
theorem cardinal.infinite_pigeonhole_card_lt {Î² Î± : Type u} (f : Î² â†’ Î±) (w : cardinal.mk Î± < cardinal.mk Î²) (w' : cardinal.aleph_0 â‰¤ cardinal.mk Î±) : âˆƒ (a : Î±), cardinal.mk Î± < cardinal.mk â†¥(f â»Â¹' {a})
theorem category_theory.elementwise_of {Î± : Sort u_1} (hh : Î±) {Î² : Prop} (x : tactic.calculated_Prop Î² hh . "derive_elementwise_proof") : Î²
theorem polynomial.nat_degree_le_of_degree_le {R : Type u} [semiring R] {p : polynomial R} {n : â„•} : p.degree â‰¤ â†‘n â†’ p.nat_degree â‰¤ n
theorem convex_independent.injective {ğ•œ : Type u_1} {E : Type u_2} {Î¹ : Type u_3} [ordered_semiring ğ•œ] [add_comm_group E] [module ğ•œ E] {p : Î¹ â†’ E} (hc : convex_independent ğ•œ p) : function.injective p
theorem besicovitch.ae_tendsto_rn_deriv {Î² : Type u} [metric_space Î²] [measurable_space Î²] [borel_space Î²] [sigma_compact_space Î²] [has_besicovitch_covering Î²] (Ï Î¼ : measure_theory.measure Î²) [measure_theory.is_locally_finite_measure Î¼] [measure_theory.is_locally_finite_measure Ï] : âˆ€áµ (x : Î²) âˆ‚Î¼, filter.tendsto (Î» (r : â„), â‡‘Ï (metric.closed_ball x r) / â‡‘Î¼ (metric.closed_ball x r)) (nhds_within 0 (set.Ioi 0)) (nhds (Ï.rn_deriv Î¼ x))
theorem category_theory.limits.complete_lattice.colimit_eq_supr {Î± : Type u} [complete_lattice Î±] {J : Type u} [category_theory.small_category J] (F : J â¥¤ Î±) : category_theory.limits.colimit F = supr F.obj
theorem finsum_mem_add_distrib {Î± : Type u_1} {M : Type u_5} [add_comm_monoid M] {f g : Î± â†’ M} {s : set Î±} (hs : s.finite) : finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), f i + g i)) = finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), f i)) + finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), g i))
theorem bounded_continuous_function.arzela_ascoli {Î± : Type u} {Î² : Type v} [topological_space Î±] [compact_space Î±] [pseudo_metric_space Î²] [t2_space Î²] (s : set Î²) (hs : is_compact s) (A : set (bounded_continuous_function Î± Î²)) (in_s : âˆ€ (f : bounded_continuous_function Î± Î²) (x : Î±), f âˆˆ A â†’ â‡‘f x âˆˆ s) (H : âˆ€ (x : Î±) (Îµ : â„), Îµ > 0 â†’ (âˆƒ (U : set Î±) (H : U âˆˆ nhds x), âˆ€ (y : Î±), y âˆˆ U â†’ âˆ€ (z : Î±), z âˆˆ U â†’ âˆ€ (f : bounded_continuous_function Î± Î²), f âˆˆ A â†’ has_dist.dist (â‡‘f y) (â‡‘f z) < Îµ)) : is_compact (closure A)
theorem has_deriv_within_at.limsup_slope_norm_le {E : Type u} [normed_group E] [normed_space â„ E] {f : â„ â†’ E} {f' : E} {s : set â„} {x r : â„} (hf : has_deriv_within_at f f' s x) (hr : âˆ¥f'âˆ¥ < r) : âˆ€á¶  (z : â„) in nhds_within x s, âˆ¥z - xâˆ¥â»Â¹ * (âˆ¥f zâˆ¥ - âˆ¥f xâˆ¥) < r
theorem liouville_with.frequently_lt_rpow_neg {p q x : â„} (h : liouville_with p x) (hlt : q < p) : âˆƒá¶  (n : â„•) in filter.at_top, âˆƒ (m : â„¤), x â‰  â†‘m / â†‘n âˆ§ |x - â†‘m / â†‘n| < â†‘n ^ -q
theorem matrix.det_one_add_col_mul_row {m : Type u} {Î± : Type v} [comm_ring Î±] [fintype m] [decidable_eq m] (u v : m â†’ Î±) : (1 + (matrix.col u).mul (matrix.row v)).det = 1 + matrix.dot_product v u
theorem zero_lt.left.mul_lt_one_of_le_of_lt {Î± : Type u} {a b : Î±} [mul_one_class Î±] [has_zero Î±] [preorder Î±] [zero_lt.pos_mul_strict_mono Î±] (ha : a â‰¤ 1) (hb : b < 1) (a0 : 0 < a) : a * b < 1
theorem real.abs_log_sub_add_sum_range_le {x : â„} (h : |x| < 1) (n : â„•) : |(finset.range n).sum (Î» (i : â„•), x ^ (i + 1) / (â†‘i + 1)) + real.log (1 - x)| â‰¤ |x| ^ (n + 1) / (1 - |x|)
theorem affine.simplex.circumradius_nonneg {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {n : â„•} (s : affine.simplex â„ P n) : 0 â‰¤ s.circumradius
theorem monoid_hom.map_prod {Î² : Type u} {Î± : Type v} {Î³ : Type w} [comm_monoid Î²] [comm_monoid Î³] (g : Î² â†’* Î³) (f : Î± â†’ Î²) (s : finset Î±) : â‡‘g (s.prod (Î» (x : Î±), f x)) = s.prod (Î» (x : Î±), â‡‘g (f x))
theorem category_theory.limits.prod_comparison_inv_natural {C : Type u} [category_theory.category C] {D : Type uâ‚‚} [category_theory.category D] (F : C â¥¤ D) {A A' B B' : C} [category_theory.limits.has_binary_product A B] [category_theory.limits.has_binary_product A' B'] [category_theory.limits.has_binary_product (F.obj A) (F.obj B)] [category_theory.limits.has_binary_product (F.obj A') (F.obj B')] (f : A âŸ¶ A') (g : B âŸ¶ B') [category_theory.is_iso (category_theory.limits.prod_comparison F A B)] [category_theory.is_iso (category_theory.limits.prod_comparison F A' B')] : category_theory.inv (category_theory.limits.prod_comparison F A B) â‰« F.map (category_theory.limits.prod.map f g) = category_theory.limits.prod.map (F.map f) (F.map g) â‰« category_theory.inv (category_theory.limits.prod_comparison F A' B')
theorem affine_subspace.vector_span_eq_top_of_affine_span_eq_top (k : Type u_1) (V : Type u_2) (P : Type u_3) [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {s : set P} (h : affine_span k s = âŠ¤) : vector_span k s = âŠ¤
theorem thickened_indicator_tendsto_indicator_closure {Î± : Type u_1} [pseudo_emetric_space Î±] {Î´seq : â„• â†’ â„} (Î´seq_pos : âˆ€ (n : â„•), 0 < Î´seq n) (Î´seq_lim : filter.tendsto Î´seq filter.at_top (nhds 0)) (E : set Î±) : filter.tendsto (Î» (n : â„•), â‡‘(thickened_indicator _ E)) filter.at_top (nhds ((closure E).indicator (Î» (x : Î±), 1)))
theorem affine.triangle.affine_span_orthocenter_point_le_altitude {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] (t : affine.triangle â„ P) (i : fin 3) : affine_span â„ {t.orthocenter, t.points i} â‰¤ affine.simplex.altitude t i
theorem cont_diff_on.prod_map {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {n : with_top â„•} {E' : Type u_4} [normed_group E'] [normed_space ğ•œ E'] {F' : Type u_5} [normed_group F'] [normed_space ğ•œ F'] {s : set E} {t : set E'} {f : E â†’ F} {g : E' â†’ F'} (hf : cont_diff_on ğ•œ n f s) (hg : cont_diff_on ğ•œ n g t) : cont_diff_on ğ•œ n (prod.map f g) (s Ã—Ë¢ t)
theorem cont_diff.snd' {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {G : Type u_4} [normed_group G] [normed_space ğ•œ G] {n : with_top â„•} {f : F â†’ G} (hf : cont_diff ğ•œ n f) : cont_diff ğ•œ n (Î» (x : E Ã— F), f x.snd)
theorem finset.nonempty.sym2 {Î± : Type u_1} [decidable_eq Î±] {s : finset Î±} : s.nonempty â†’ s.sym2.nonempty
theorem exists_open_nhds_one_mul_subset {M : Type u_4} [topological_space M] [monoid M] [has_continuous_mul M] {U : set M} (hU : U âˆˆ nhds 1) : âˆƒ (V : set M), is_open V âˆ§ 1 âˆˆ V âˆ§ V * V âŠ† U
theorem has_fpower_series_at.apply_eq_zero {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} [nondiscrete_normed_field ğ•œ] [normed_group E] [normed_space ğ•œ E] [normed_group F] [normed_space ğ•œ F] {p : formal_multilinear_series ğ•œ E F} {x : E} (h : has_fpower_series_at 0 p x) (n : â„•) (y : E) : â‡‘(p n) (Î» (i : fin n), y) = 0
theorem lipschitz_with.dist_le_mul {Î± : Type u} {Î² : Type v} [pseudo_metric_space Î±] [pseudo_metric_space Î²] {K : nnreal} {f : Î± â†’ Î²} : lipschitz_with K f â†’ âˆ€ (x y : Î±), has_dist.dist (f x) (f y) â‰¤ â†‘K * has_dist.dist x y
theorem module.free.finrank_direct_sum (R : Type u) [ring R] [strong_rank_condition R] {Î¹ : Type v} [fintype Î¹] (M : Î¹ â†’ Type w) [Î  (i : Î¹), add_comm_group (M i)] [Î  (i : Î¹), module R (M i)] [âˆ€ (i : Î¹), module.free R (M i)] [âˆ€ (i : Î¹), module.finite R (M i)] : finite_dimensional.finrank R (direct_sum Î¹ (Î» (i : Î¹), M i)) = finset.univ.sum (Î» (i : Î¹), finite_dimensional.finrank R (M i))
theorem concave_on.translate_left {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [ordered_semiring ğ•œ] [add_comm_monoid E] [ordered_add_comm_monoid Î²] [module ğ•œ E] [has_scalar ğ•œ Î²] {s : set E} {f : E â†’ Î²} (hf : concave_on ğ•œ s f) (c : E) : concave_on ğ•œ ((Î» (z : E), c + z) â»Â¹' s) (f âˆ˜ Î» (z : E), z + c)
theorem mem_nhds_within_Iic_iff_exists_Icc_subset {Î± : Type u} [topological_space Î±] [linear_order Î±] [order_topology Î±] [no_min_order Î±] [densely_ordered Î±] {a : Î±} {s : set Î±} : s âˆˆ nhds_within a (set.Iic a) â†” âˆƒ (l : Î±), l < a âˆ§ set.Icc l a âŠ† s
theorem nat.factorization_eq_of_coprime_right {p a b : â„•} (hab : a.coprime b) (hpb : p âˆˆ b.factors) : â‡‘((a * b).factorization) p = â‡‘(b.factorization) p
theorem lie_submodule.lie_ideal_oper_eq_linear_span {R : Type u} {L : Type v} {M : Type w} [comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M] (N : lie_submodule R L M) (I : lie_ideal R L) : â†‘â…I,Nâ† = submodule.span R {m : M | âˆƒ (x : â†¥I) (n : â†¥N), â…â†‘x,â†‘nâ† = m}
theorem minpoly.degree_pos {A : Type u_1} {B : Type u_2} [comm_ring A] [ring B] [algebra A B] [nontrivial B] {x : B} (hx : is_integral A x) : 0 < (minpoly A x).degree
theorem is_conformal_map_iff_is_complex_or_conj_linear {g : â„‚ â†’L[â„] â„‚} : is_conformal_map g â†” ((âˆƒ (map : â„‚ â†’L[â„‚] â„‚), continuous_linear_map.restrict_scalars â„ map = g) âˆ¨ âˆƒ (map : â„‚ â†’L[â„‚] â„‚), continuous_linear_map.restrict_scalars â„ map = g.comp â†‘complex.conj_cle) âˆ§ g â‰  0
theorem is_min.to_dual {Î± : Type u_1} [has_le Î±] {a : Î±} : is_min a â†’ is_max (â‡‘order_dual.to_dual a)
theorem orthonormal.oangle_add_cyc3_neg_left {V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) {x y z : V} (hx : x â‰  0) (hy : y â‰  0) (hz : z â‰  0) : hb.oangle (-x) y + hb.oangle (-y) z + hb.oangle (-z) x = â†‘real.pi
theorem inner_product_geometry.sin_angle_add_angle_sub_add_angle_sub_eq_zero {V : Type u_1} [inner_product_space â„ V] {x y : V} (hx : x â‰  0) (hy : y â‰  0) : real.sin (inner_product_geometry.angle x y + inner_product_geometry.angle x (x - y) + inner_product_geometry.angle y (y - x)) = 0
theorem nat.fib_gcd (m n : â„•) : nat.fib (m.gcd n) = (nat.fib m).gcd (nat.fib n)
theorem convex.closure_subset_image_homothety_interior_of_one_lt {E : Type u_2} [add_comm_group E] [module â„ E] [topological_space E] [topological_add_group E] [has_continuous_smul â„ E] {s : set E} (hs : convex â„ s) {x : E} (hx : x âˆˆ interior s) (t : â„) (ht : 1 < t) : closure s âŠ† â‡‘(affine_map.homothety x t) '' interior s
theorem is_cyclotomic_extension.prime_ne_two_norm_zeta_sub_one {p : â„•+} {K : Type u} (L : Type v) [field K] [field L] [algebra K L] [ne_zero â†‘â†‘p] [hpri : fact (nat.prime â†‘p)] [hcyc : is_cyclotomic_extension {p} K L] (hirr : irreducible (polynomial.cyclotomic â†‘p K)) (h : p â‰  2) : â‡‘(algebra.norm K) (is_cyclotomic_extension.zeta p K L - 1) = â†‘p
theorem asymptotics.is_o.neg_right {Î± : Type u_1} {E : Type u_3} {F' : Type u_7} [has_norm E] [semi_normed_group F'] {f : Î± â†’ E} {g' : Î± â†’ F'} {l : filter Î±} : f =o[l] g' â†’ (f =o[l] Î» (x : Î±), -g' x)
theorem real.sqrt_one_add_sinh_sq (x : â„) : real.sqrt (1 + real.sinh x ^ 2) = real.cosh x
theorem measure_theory.measure.add_haar_image_linear_map {E : Type u_1} [normed_group E] [normed_space â„ E] [measurable_space E] [borel_space E] [finite_dimensional â„ E] (Î¼ : measure_theory.measure E) [Î¼.is_add_haar_measure] (f : E â†’â‚—[â„] E) (s : set E) : â‡‘Î¼ (â‡‘f '' s) = ennreal.of_real |â‡‘linear_map.det f| * â‡‘Î¼ s
theorem supr_inf_le_inf_Sup {Î± : Type u_1} [complete_lattice Î±] {a : Î±} {s : set Î±} : (â¨† (b : Î±) (H : b âˆˆ s), a âŠ“ b) â‰¤ a âŠ“ has_Sup.Sup s
theorem quotient_norm_nonneg {M : Type u_1} [semi_normed_group M] (S : add_subgroup M) (x : M â§¸ S) : 0 â‰¤ âˆ¥xâˆ¥
theorem unique_mdiff_on.smooth_bundle_preimage {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {M : Type u_4} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {s : set M} {F : Type u_8} [normed_group F] [normed_space ğ•œ F] (Z : basic_smooth_vector_bundle_core I M F) (hs : unique_mdiff_on I s) : unique_mdiff_on (I.prod (model_with_corners_self ğ•œ F)) (Z.to_topological_vector_bundle_core.proj â»Â¹' s)
theorem function.commute.right_bij_on_fixed_pts_comp {Î± : Type u} {f g : Î± â†’ Î±} (h : function.commute f g) : set.bij_on g (function.fixed_points (f âˆ˜ g)) (function.fixed_points (f âˆ˜ g))
theorem is_complete_image_iff {Î± : Type u_1} {Î² : Type u_2} [uniform_space Î±] [uniform_space Î²] {m : Î± â†’ Î²} {s : set Î±} (hm : uniform_inducing m) : is_complete (m '' s) â†” is_complete s
theorem tsum_lt_tsum_of_nonneg {i : â„•} {f g : â„• â†’ â„} (h0 : âˆ€ (b : â„•), 0 â‰¤ f b) (h : âˆ€ (b : â„•), f b â‰¤ g b) (hi : f i < g i) (hg : summable g) : âˆ‘' (n : â„•), f n < âˆ‘' (n : â„•), g n
theorem is_preirreducible.subset_irreducible {Î± : Type u} [topological_space Î±] {S U Z : set Î±} (hZ : is_preirreducible Z) (hU : U.nonempty) (hU' : is_open U) (hâ‚ : U âŠ† S) (hâ‚‚ : S âŠ† Z) : is_irreducible S
theorem continuous_at_of_tendsto_nhds {Î± : Type u} {Î² : Type v} [topological_space Î±] [topological_space Î²] [t1_space Î²] {f : Î± â†’ Î²} {a : Î±} {b : Î²} (h : filter.tendsto f (nhds a) (nhds b)) : continuous_at f a
theorem matrix.sum_cramer {n : Type u} [decidable_eq n] [fintype n] {Î± : Type v} [comm_ring Î±] (A : matrix n n Î±) {Î² : Type u_1} (s : finset Î²) (f : Î² â†’ n â†’ Î±) : s.sum (Î» (x : Î²), â‡‘(A.cramer) (f x)) = â‡‘(A.cramer) (s.sum (Î» (x : Î²), f x))
theorem monoid_algebra.alg_hom_ext {k : Type uâ‚} {G : Type uâ‚‚} [comm_semiring k] [monoid G] {A : Type uâ‚ƒ} [semiring A] [algebra k A] â¦ƒÏ†â‚ Ï†â‚‚ : monoid_algebra k G â†’â‚[k] Aâ¦„ (h : âˆ€ (x : G), â‡‘Ï†â‚ (finsupp.single x 1) = â‡‘Ï†â‚‚ (finsupp.single x 1)) : Ï†â‚ = Ï†â‚‚
theorem topological_space.is_topological_basis.sum {Î± : Type u} {Î² : Type u_1} [topological_space Î±] [topological_space Î²] {s : set (set Î±)} (hs : topological_space.is_topological_basis s) {t : set (set Î²)} (ht : topological_space.is_topological_basis t) : topological_space.is_topological_basis ((Î» (u : set Î±), sum.inl '' u) '' s âˆª (Î» (u : set Î²), sum.inr '' u) '' t)
theorem add_hom.congr_arg {M : Type u_3} {N : Type u_4} [has_add M] [has_add N] (f : add_hom M N) {x y : M} (h : x = y) : â‡‘f x = â‡‘f y
theorem zmod.legendre_sym_neg_one (p : â„•) [fact (nat.prime p)] (hp : p â‰  2) : zmod.legendre_sym p (-1) = â‡‘zmod.Ï‡â‚„ â†‘p
theorem subgroup.closure_mul_image_eq_top {G : Type u_1} [group G] {H : subgroup G} {R S : set G} (hR : R âˆˆ subgroup.right_transversals â†‘H) (hR1 : 1 âˆˆ R) (hS : subgroup.closure S = âŠ¤) : subgroup.closure ((Î» (g : G), âŸ¨g * (â†‘(subgroup.mem_right_transversals.to_fun hR g))â»Â¹, _âŸ©) '' (R * S)) = âŠ¤
theorem category_theory.induct_on_objects {J : Type uâ‚} [category_theory.category J] [category_theory.is_preconnected J] (p : set J) {jâ‚€ : J} (h0 : jâ‚€ âˆˆ p) (h1 : âˆ€ {jâ‚ jâ‚‚ : J}, (jâ‚ âŸ¶ jâ‚‚) â†’ (jâ‚ âˆˆ p â†” jâ‚‚ âˆˆ p)) (j : J) : j âˆˆ p
theorem measure_theory.lintegral_supr {Î± : Type u_1} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {f : â„• â†’ Î± â†’ ennreal} (hf : âˆ€ (n : â„•), measurable (f n)) (h_mono : monotone f) : âˆ«â» (a : Î±), (â¨† (n : â„•), f n a) âˆ‚Î¼ = â¨† (n : â„•), âˆ«â» (a : Î±), f n a âˆ‚Î¼
theorem mul_neg_one {Î± : Type u} [mul_one_class Î±] [has_distrib_neg Î±] (a : Î±) : a * -1 = -a
theorem measure_theory.measure.haar.is_left_invariant_haar_content {G : Type u_1} [group G] [topological_space G] [topological_group G] [t2_space G] {Kâ‚€ : topological_space.positive_compacts G} (g : G) (K : topological_space.compacts G) : â‡‘(measure_theory.measure.haar.haar_content Kâ‚€) (topological_space.compacts.map (Î» (b : G), g * b) _ K) = â‡‘(measure_theory.measure.haar.haar_content Kâ‚€) K
theorem three_pos {Î± : Type u} [ordered_semiring Î±] [nontrivial Î±] : 0 < 3
theorem norm_image_sub_le_of_norm_deriv_le_segment' {E : Type u_1} [normed_group E] [normed_space â„ E] {f : â„ â†’ E} {a b : â„} {f' : â„ â†’ E} {C : â„} (hf : âˆ€ (x : â„), x âˆˆ set.Icc a b â†’ has_deriv_within_at f (f' x) (set.Icc a b) x) (bound : âˆ€ (x : â„), x âˆˆ set.Ico a b â†’ âˆ¥f' xâˆ¥ â‰¤ C) (x : â„) (H : x âˆˆ set.Icc a b) : âˆ¥f x - f aâˆ¥ â‰¤ C * (x - a)
theorem indexed_partition.index_out' {Î¹ : Type u_1} {Î± : Type u_2} {s : Î¹ â†’ set Î±} (hs : indexed_partition s) (x : hs.quotient) : hs.index (quotient.out' x) = hs.index (â‡‘(hs.out) x)
theorem affine.simplex.monge_point_vsub_face_centroid_weights_with_circumcenter_eq_sub {n : â„•} {iâ‚ iâ‚‚ : fin (n + 3)} (h : iâ‚ â‰  iâ‚‚) : affine.simplex.monge_point_vsub_face_centroid_weights_with_circumcenter iâ‚ iâ‚‚ = affine.simplex.monge_point_weights_with_circumcenter n - affine.simplex.centroid_weights_with_circumcenter {iâ‚, iâ‚‚}á¶œ
theorem finset.max'_singleton {Î± : Type u_1} [linear_order Î±] (a : Î±) : {a}.max' _ = a
theorem nat.partrec.code.exists_code {f : â„• â†’. â„•} : nat.partrec f â†” âˆƒ (c : nat.partrec.code), c.eval = f
theorem path.homotopic.comp_prod_eq_prod_comp {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] {aâ‚ aâ‚‚ aâ‚ƒ : Î±} {bâ‚ bâ‚‚ bâ‚ƒ : Î²} (qâ‚ : path.homotopic.quotient aâ‚ aâ‚‚) (qâ‚‚ : path.homotopic.quotient bâ‚ bâ‚‚) (râ‚ : path.homotopic.quotient aâ‚‚ aâ‚ƒ) (râ‚‚ : path.homotopic.quotient bâ‚‚ bâ‚ƒ) : (path.homotopic.prod qâ‚ qâ‚‚).comp (path.homotopic.prod râ‚ râ‚‚) = path.homotopic.prod (qâ‚.comp râ‚) (qâ‚‚.comp râ‚‚)
theorem category_theory.is_pullback.of_is_product {C : Type uâ‚} [category_theory.category C] {X Y Z : C} {c : category_theory.limits.binary_fan X Y} (h : category_theory.limits.is_limit c) (t : category_theory.limits.is_terminal Z) : category_theory.is_pullback c.fst c.snd (t.from ((category_theory.limits.pair X Y).obj {as := category_theory.limits.walking_pair.left})) (t.from ((category_theory.limits.pair X Y).obj {as := category_theory.limits.walking_pair.right}))
theorem continuous_map.continuous_eval' {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] [locally_compact_space Î±] : continuous (Î» (p : C(Î±, Î²) Ã— Î±), â‡‘(p.fst) p.snd)
theorem inner_product_geometry.cos_angle_sub_add_angle_sub_rev_eq_neg_cos_angle {V : Type u_1} [inner_product_space â„ V] {x y : V} (hx : x â‰  0) (hy : y â‰  0) : real.cos (inner_product_geometry.angle x (x - y) + inner_product_geometry.angle y (y - x)) = -real.cos (inner_product_geometry.angle x y)
theorem add_is_add_left_regular_iff {R : Type u_1} {a : R} [add_semigroup R] (b : R) (ha : is_add_left_regular a) : is_add_left_regular (a + b) â†” is_add_left_regular b
theorem metric.complete_of_convergent_controlled_sequences {Î± : Type u} [pseudo_metric_space Î±] (B : â„• â†’ â„) (hB : âˆ€ (n : â„•), 0 < B n) (H : âˆ€ (u : â„• â†’ Î±), (âˆ€ (N n m : â„•), N â‰¤ n â†’ N â‰¤ m â†’ has_dist.dist (u n) (u m) < B N) â†’ (âˆƒ (x : Î±), filter.tendsto u filter.at_top (nhds x))) : complete_space Î±
theorem convex_hull_exists_dist_ge {E : Type u_2} [semi_normed_group E] [normed_space â„ E] {s : set E} {x : E} (hx : x âˆˆ â‡‘(convex_hull â„) s) (y : E) : âˆƒ (x' : E) (H : x' âˆˆ s), has_dist.dist x y â‰¤ has_dist.dist x' y
theorem continuous_multilinear_map.op_norm_add_le {ğ•œ : Type u} {Î¹ : Type v} {E : Î¹ â†’ Type wE} {G : Type wG} [decidable_eq Î¹] [fintype Î¹] [nondiscrete_normed_field ğ•œ] [Î  (i : Î¹), normed_group (E i)] [Î  (i : Î¹), normed_space ğ•œ (E i)] [normed_group G] [normed_space ğ•œ G] (f g : continuous_multilinear_map ğ•œ E G) : âˆ¥f + gâˆ¥ â‰¤ âˆ¥fâˆ¥ + âˆ¥gâˆ¥
theorem topological_group.continuous_conj {G : Type w} [topological_space G] [has_inv G] [has_mul G] [has_continuous_mul G] (g : G) : continuous (Î» (h : G), g * h * gâ»Â¹)
theorem inner_product_geometry.norm_sub_eq_abs_sub_norm_iff_angle_eq_zero {V : Type u_1} [inner_product_space â„ V] {x y : V} (hx : x â‰  0) (hy : y â‰  0) : âˆ¥x - yâˆ¥ = |âˆ¥xâˆ¥ - âˆ¥yâˆ¥| â†” inner_product_geometry.angle x y = 0
theorem vitali.exists_disjoint_subfamily_covering_enlargment_closed_ball {Î± : Type u_1} [metric_space Î±] (t : set (set Î±)) (R : â„) (ht : âˆ€ (s : set Î±), s âˆˆ t â†’ (âˆƒ (x : Î±) (r : â„), s = metric.closed_ball x r âˆ§ r â‰¤ R)) : âˆƒ (u : set (set Î±)) (H : u âŠ† t), u.pairwise_disjoint id âˆ§ âˆ€ (a : set Î±), a âˆˆ t â†’ (âˆƒ (x : Î±) (r : â„), metric.closed_ball x r âˆˆ u âˆ§ a âŠ† metric.closed_ball x (5 * r))
theorem convex.mem_Ico {ğ•œ : Type u_1} [linear_ordered_field ğ•œ] {x y : ğ•œ} (h : x < y) {z : ğ•œ} : z âˆˆ set.Ico x y â†” âˆƒ (a b : ğ•œ), 0 < a âˆ§ 0 â‰¤ b âˆ§ a + b = 1 âˆ§ a * x + b * y = z
theorem neg_pow_two {R : Type uâ‚} [monoid R] [has_distrib_neg R] (a : R) : (-a) ^ 2 = a ^ 2
theorem submodule.no_zero_smul_divisors_iff_torsion_eq_bot {R : Type u_1} {M : Type u_2} [comm_semiring R] [add_comm_monoid M] [module R M] [no_zero_divisors R] [nontrivial R] : no_zero_smul_divisors R M â†” submodule.torsion R M = âŠ¥
theorem pi_nat.cylinder_longest_prefix_eq_of_longest_prefix_lt_first_diff {E : â„• â†’ Type u_1} [Î  (n : â„•), topological_space (E n)] [âˆ€ (n : â„•), discrete_topology (E n)] {x y : Î  (n : â„•), E n} {s : set (Î  (n : â„•), E n)} (hs : is_closed s) (hne : s.nonempty) (H : pi_nat.longest_prefix x s < pi_nat.first_diff x y) (xs : x âˆ‰ s) (ys : y âˆ‰ s) : pi_nat.cylinder x (pi_nat.longest_prefix x s) = pi_nat.cylinder y (pi_nat.longest_prefix y s)
theorem add_action.card_eq_sum_card_add_group_sub_card_stabilizer (Î± : Type u) (Î² : Type v) [add_group Î±] [add_action Î± Î²] [fintype Î±] [fintype Î²] [fintype (quotient (add_action.orbit_rel Î± Î²))] [Î  (b : Î²), fintype â†¥(add_action.stabilizer Î± b)] : fintype.card Î² = finset.univ.sum (Î» (Ï‰ : quotient (add_action.orbit_rel Î± Î²)), fintype.card Î± / fintype.card â†¥(add_action.stabilizer Î± Ï‰.out'))
theorem local_equiv.eq_on_source.restr {Î± : Type u_1} {Î² : Type u_2} {e e' : local_equiv Î± Î²} (he : e â‰ˆ e') (s : set Î±) : e.restr s â‰ˆ e'.restr s
theorem mul_self_sub_mul_self {R : Type x} [comm_ring R] (a b : R) : a * a - b * b = (a + b) * (a - b)
theorem function.injective.no_zero_divisors {Mâ‚€ : Type u_1} {Mâ‚€' : Type u_3} [has_mul Mâ‚€] [has_zero Mâ‚€] [has_mul Mâ‚€'] [has_zero Mâ‚€'] [no_zero_divisors Mâ‚€'] (f : Mâ‚€ â†’ Mâ‚€') (hf : function.injective f) (zero : f 0 = 0) (mul : âˆ€ (x y : Mâ‚€), f (x * y) = f x * f y) : no_zero_divisors Mâ‚€
theorem continuous_map.continuous_uncurry {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [topological_space Î±] [topological_space Î²] [topological_space Î³] [locally_compact_space Î±] [locally_compact_space Î²] : continuous continuous_map.uncurry
theorem matrix.circulant_is_symm_apply {Î± : Type u_1} {n : Type u_4} [add_group n] {v : n â†’ Î±} (h : (matrix.circulant v).is_symm) (i : n) : v (-i) = v i
theorem set.finite.finite_subsets {Î± : Type u} {a : set Î±} (h : a.finite) : {b : set Î± | b âŠ† a}.finite
theorem mv_polynomial.esymm_eq_sum_monomial (Ïƒ : Type u_1) (R : Type u_2) [comm_semiring R] [fintype Ïƒ] (n : â„•) : mv_polynomial.esymm Ïƒ R n = (finset.powerset_len n finset.univ).sum (Î» (t : finset Ïƒ), â‡‘(mv_polynomial.monomial (t.sum (Î» (i : Ïƒ), finsupp.single i 1))) 1)
theorem normed_group_hom.equalizer.lift_norm_noninc {V : Type u_1} {W : Type u_2} {Vâ‚ : Type u_3} [semi_normed_group V] [semi_normed_group W] [semi_normed_group Vâ‚] {f g : normed_group_hom V W} (Ï† : normed_group_hom Vâ‚ V) (h : f.comp Ï† = g.comp Ï†) (hÏ† : Ï†.norm_noninc) : (normed_group_hom.equalizer.lift Ï† h).norm_noninc
theorem measure_theory.outer_measure.infi_apply {Î± : Type u_1} {Î¹ : Sort u_2} [nonempty Î¹] (m : Î¹ â†’ measure_theory.outer_measure Î±) (s : set Î±) : (â‡‘â¨… (i : Î¹), m i) s = â¨… (t : â„• â†’ set Î±) (h2 : s âŠ† set.Union t), âˆ‘' (n : â„•), â¨… (i : Î¹), â‡‘(m i) (t n)
theorem measure_theory.uniform_integrable_subsingleton {Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_3} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [normed_group Î²] {p : ennreal} {f : Î¹ â†’ Î± â†’ Î²} [subsingleton Î¹] (hp_one : 1 â‰¤ p) (hp_top : p â‰  âŠ¤) (hf : âˆ€ (i : Î¹), measure_theory.strongly_measurable (f i)) (hf' : âˆ€ (i : Î¹), measure_theory.mem_â„’p (f i) p Î¼) : measure_theory.uniform_integrable f p Î¼
theorem add_con.ker_eq_lift_of_injective {M : Type u_1} {P : Type u_3} [add_zero_class M] [add_zero_class P] (c : add_con M) (f : M â†’+ P) (H : c â‰¤ add_con.ker f) (h : function.injective â‡‘(c.lift f H)) : add_con.ker f = c
theorem matrix.right_inv_eq_right_inv {n : Type u'} {Î± : Type v} [fintype n] [decidable_eq n] [comm_ring Î±] {A B C : matrix n n Î±} (h : A.mul B = 1) (g : A.mul C = 1) : B = C
theorem mv_polynomial.mem_map_C_iff {R : Type u} {Ïƒ : Type v} [comm_ring R] {I : ideal R} {f : mv_polynomial Ïƒ R} : f âˆˆ ideal.map mv_polynomial.C I â†” âˆ€ (m : Ïƒ â†’â‚€ â„•), mv_polynomial.coeff m f âˆˆ I
theorem continuous_linear_map.has_sum {Î¹ : Type u_10} {R : Type u_11} {Râ‚‚ : Type u_12} {M : Type u_13} {Mâ‚‚ : Type u_14} [semiring R] [semiring Râ‚‚] [add_comm_monoid M] [module R M] [add_comm_monoid Mâ‚‚] [module Râ‚‚ Mâ‚‚] [topological_space M] [topological_space Mâ‚‚] {Ïƒ : R â†’+* Râ‚‚} {f : Î¹ â†’ M} (Ï† : M â†’SL[Ïƒ] Mâ‚‚) {x : M} (hf : has_sum f x) : has_sum (Î» (b : Î¹), â‡‘Ï† (f b)) (â‡‘Ï† x)
theorem filter.exists_ultrafilter_le {Î± : Type u} (f : filter Î±) [h : f.ne_bot] : âˆƒ (u : ultrafilter Î±), â†‘u â‰¤ f
theorem orthonormal.eq_iff_norm_eq_of_oangle_eq_zero {V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) {x y : V} (h : hb.oangle x y = 0) : x = y â†” âˆ¥xâˆ¥ = âˆ¥yâˆ¥
theorem subgroup.is_normal_topological_closure {G : Type u_1} [topological_space G] [group G] [topological_group G] (N : subgroup G) [N.normal] : N.topological_closure.normal
theorem linear_independent.injective_total {Î¹ : Type u_1} {R : Type u_3} {M : Type u_5} {v : Î¹ â†’ M} [ring R] [add_comm_group M] [module R M] : linear_independent R v â†’ function.injective â‡‘(finsupp.total Î¹ M R v)
theorem set.subsingleton_of_image {Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} (hf : function.injective f) (s : set Î±) (hs : (f '' s).subsingleton) : s.subsingleton
theorem affine_subspace.exists_of_lt {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {s1 s2 : affine_subspace k P} (h : s1 < s2) : âˆƒ (p : P) (H : p âˆˆ s2), p âˆ‰ s1
theorem mem_ball_comp {Î² : Type u_2} {V W : set (Î² Ã— Î²)} {x y z : Î²} (h : y âˆˆ uniform_space.ball x V) (h' : z âˆˆ uniform_space.ball y W) : z âˆˆ uniform_space.ball x (comp_rel V W)
theorem monotone_on.dual_right {Î± : Type u} {Î² : Type v} [preorder Î±] [preorder Î²] {f : Î± â†’ Î²} {s : set Î±} : monotone_on f s â†’ antitone_on (â‡‘order_dual.to_dual âˆ˜ f) s
theorem finite_dimensional.finrank_fin_fun (K : Type u) [division_ring K] {n : â„•} : finite_dimensional.finrank K (fin n â†’ K) = n
theorem vsub_self {G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] (p : P) : p -áµ¥ p = 0
theorem submodule.eq_smul_of_le_smul_of_le_jacobson {R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] {I J : ideal R} {N : submodule R M} (hN : N.fg) (hIN : N â‰¤ I â€¢ N) (hIjac : I â‰¤ J.jacobson) : N = J â€¢ N
theorem right.mul_lt_mul {Î± : Type u_1} [has_mul Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_le.le] [covariant_class Î± Î± (function.swap has_mul.mul) has_lt.lt] {a b c d : Î±} (hâ‚ : a < b) (hâ‚‚ : c < d) : a * c < b * d
theorem metric.bounded_of_bdd_above_of_bdd_below {Î± : Type u} [pseudo_metric_space Î±] [preorder Î±] [compact_Icc_space Î±] {s : set Î±} (hâ‚ : bdd_above s) (hâ‚‚ : bdd_below s) : metric.bounded s
theorem nsmul_eq_mod_nsmul {M : Type u_1} [add_monoid M] {x : M} (m : â„•) {n : â„•} (h : n â€¢ x = 0) : m â€¢ x = (m % n) â€¢ x
theorem real_inner_sub_sub_self {F : Type u_3} [inner_product_space â„ F] {x y : F} : has_inner.inner (x - y) (x - y) = has_inner.inner x x - 2 * has_inner.inner x y + has_inner.inner y y
theorem linear_map.continuous_of_seq_closed_graph {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] [complete_space F] [complete_space E] (g : E â†’â‚—[ğ•œ] F) (hg : âˆ€ (u : â„• â†’ E) (x : E) (y : F), filter.tendsto u filter.at_top (nhds x) â†’ filter.tendsto (â‡‘g âˆ˜ u) filter.at_top (nhds y) â†’ y = â‡‘g x) : continuous â‡‘g
theorem category_theory.sheaf.is_sheaf_for_trans {C : Type u} [category_theory.category C] {X : C} (P : Cáµ’áµ– â¥¤ Type v) (R S : category_theory.sieve X) (hR : category_theory.presieve.is_sheaf_for P â‡‘R) (hR' : âˆ€ â¦ƒY : Câ¦„ â¦ƒf : Y âŸ¶ Xâ¦„, â‡‘S f â†’ category_theory.presieve.is_separated_for P â‡‘(category_theory.sieve.pullback f R)) (hS : âˆ€ â¦ƒY : Câ¦„ â¦ƒf : Y âŸ¶ Xâ¦„, â‡‘R f â†’ category_theory.presieve.is_sheaf_for P â‡‘(category_theory.sieve.pullback f S)) : category_theory.presieve.is_sheaf_for P â‡‘S
theorem asymptotics.is_O_with_iff {Î± : Type u_1} {E : Type u_3} {F : Type u_4} [has_norm E] [has_norm F] {c : â„} {f : Î± â†’ E} {g : Î± â†’ F} {l : filter Î±} : asymptotics.is_O_with c l f g â†” âˆ€á¶  (x : Î±) in l, âˆ¥f xâˆ¥ â‰¤ c * âˆ¥g xâˆ¥
theorem multilinear_map.map_sum_finset_aux {R : Type u} {Î¹ : Type u'} {Mâ‚ : Î¹ â†’ Type vâ‚} {Mâ‚‚ : Type vâ‚‚} [decidable_eq Î¹] [semiring R] [Î  (i : Î¹), add_comm_monoid (Mâ‚ i)] [add_comm_monoid Mâ‚‚] [Î  (i : Î¹), module R (Mâ‚ i)] [module R Mâ‚‚] (f : multilinear_map R Mâ‚ Mâ‚‚) {Î± : Î¹ â†’ Type u_1} (g : Î  (i : Î¹), Î± i â†’ Mâ‚ i) (A : Î  (i : Î¹), finset (Î± i)) [fintype Î¹] {n : â„•} (h : finset.univ.sum (Î» (i : Î¹), (A i).card) = n) : â‡‘f (Î» (i : Î¹), (A i).sum (Î» (j : Î± i), g i j)) = (fintype.pi_finset A).sum (Î» (r : Î  (a : Î¹), Î± a), â‡‘f (Î» (i : Î¹), g i (r i)))
theorem category_theory.limits.is_iso_limit_cocone_parallel_pair_of_epi {C : Type u} [category_theory.category C] {X Y : C} {f g : X âŸ¶ Y} {c : category_theory.limits.cofork f g} (h : category_theory.limits.is_colimit c) [category_theory.mono c.Ï€] : category_theory.is_iso c.Ï€
theorem add_monoid_hom.map_list_sum {M : Type u_3} {N : Type u_4} [add_monoid M] [add_monoid N] (f : M â†’+ N) (l : list M) : â‡‘f l.sum = (list.map â‡‘f l).sum
theorem inner_product_space.is_self_adjoint.direct_sum_is_internal {ğ•œ : Type u_1} [is_R_or_C ğ•œ] [dec_ğ•œ : decidable_eq ğ•œ] {E : Type u_2} [inner_product_space ğ•œ E] {T : E â†’â‚—[ğ•œ] E} (hT : inner_product_space.is_self_adjoint T) [finite_dimensional ğ•œ E] : direct_sum.is_internal (Î» (Î¼ : module.End.eigenvalues T), module.End.eigenspace T â†‘Î¼)
theorem exists_seq_of_forall_finset_exists' {Î± : Type u_1} (P : Î± â†’ Prop) (r : Î± â†’ Î± â†’ Prop) [is_symm Î± r] (h : âˆ€ (s : finset Î±), (âˆ€ (x : Î±), x âˆˆ s â†’ P x) â†’ (âˆƒ (y : Î±), P y âˆ§ âˆ€ (x : Î±), x âˆˆ s â†’ r x y)) : âˆƒ (f : â„• â†’ Î±), (âˆ€ (n : â„•), P (f n)) âˆ§ âˆ€ (m n : â„•), m â‰  n â†’ r (f m) (f n)
theorem zmod.euler_criterion_units (p : â„•) [fact (nat.prime p)] (x : (zmod p)Ë£) : (âˆƒ (y : (zmod p)Ë£), y ^ 2 = x) â†” x ^ (p / 2) = 1
theorem category_theory.free_bicategory.normalize_aux_congr {B : Type u} [quiver B] {a b c : B} (p : quiver.path a b) {f g : category_theory.free_bicategory.hom b c} (Î· : f âŸ¶ g) : category_theory.free_bicategory.normalize_aux p f = category_theory.free_bicategory.normalize_aux p g
theorem transcendental.irrational {r : â„} (tr : transcendental â„š r) : irrational r
theorem riesz_extension {E : Type u_2} [add_comm_group E] [module â„ E] (s : convex_cone â„ E) (f : linear_pmap â„ E â„) (nonneg : âˆ€ (x : â†¥(f.domain)), â†‘x âˆˆ s â†’ 0 â‰¤ â‡‘f x) (dense : âˆ€ (y : E), âˆƒ (x : â†¥(f.domain)), â†‘x + y âˆˆ s) : âˆƒ (g : E â†’â‚—[â„] â„), (âˆ€ (x : â†¥(f.domain)), â‡‘g â†‘x = â‡‘f x) âˆ§ âˆ€ (x : E), x âˆˆ s â†’ 0 â‰¤ â‡‘g x
theorem ae_measurable.ae_strongly_measurable {Î± : Type u_1} {Î² : Type u_2} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [topological_space Î²] {f : Î± â†’ Î²} [measurable_space Î²] [topological_space.pseudo_metrizable_space Î²] [opens_measurable_space Î²] [topological_space.second_countable_topology Î²] (hf : ae_measurable f Î¼) : measure_theory.ae_strongly_measurable f Î¼
theorem finsum_mem_induction {Î± : Type u_1} {M : Type u_5} [add_comm_monoid M] {f : Î± â†’ M} {s : set Î±} (p : M â†’ Prop) (hpâ‚€ : p 0) (hpâ‚ : âˆ€ (x y : M), p x â†’ p y â†’ p (x + y)) (hpâ‚‚ : âˆ€ (x : Î±), x âˆˆ s â†’ p (f x)) : p (finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), f i)))
theorem multiples.add_mem {M : Type u_1} [add_monoid M] {x y z : M} : y âˆˆ multiples x â†’ z âˆˆ multiples x â†’ y + z âˆˆ multiples x
theorem torus_integrable.torus_integrable_const {n : â„•} {E : Type u_1} [normed_group E] (a : E) (c : fin n â†’ â„‚) (R : fin n â†’ â„) : torus_integrable (Î» (_x : fin n â†’ â„‚), a) c R
theorem orthonormal.oangle_rotation {V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) (x y : V) (Î¸ : real.angle) : hb.oangle (â‡‘(hb.rotation Î¸) x) (â‡‘(hb.rotation Î¸) y) = hb.oangle x y
theorem abs_inner_div_norm_mul_norm_eq_one_of_ne_zero_of_ne_zero_mul {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {x : E} {r : ğ•œ} (hx : x â‰  0) (hr : r â‰  0) : is_R_or_C.abs (has_inner.inner x (r â€¢ x)) / (âˆ¥xâˆ¥ * âˆ¥r â€¢ xâˆ¥) = 1
theorem measure_theory.tendsto_integral_of_L1 {Î± : Type u_1} {E : Type u_2} [normed_group E] [normed_space â„ E] [complete_space E] {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {Î¹ : Type u_3} (f : Î± â†’ E) (hfi : measure_theory.integrable f Î¼) {F : Î¹ â†’ Î± â†’ E} {l : filter Î¹} (hFi : âˆ€á¶  (i : Î¹) in l, measure_theory.integrable (F i) Î¼) (hF : filter.tendsto (Î» (i : Î¹), âˆ«â» (x : Î±), â†‘âˆ¥F i x - f xâˆ¥â‚Š âˆ‚Î¼) l (nhds 0)) : filter.tendsto (Î» (i : Î¹), âˆ« (x : Î±), F i x âˆ‚Î¼) l (nhds (âˆ« (x : Î±), f x âˆ‚Î¼))
theorem cont_mdiff_on_symm_of_mem_maximal_atlas {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] {I : model_with_corners ğ•œ E H} {M : Type u_4} [topological_space M] [charted_space H M] [Is : smooth_manifold_with_corners I M] {n : with_top â„•} {e : local_homeomorph M H} (h : e âˆˆ smooth_manifold_with_corners.maximal_atlas I M) : cont_mdiff_on I I n â‡‘(e.symm) e.to_local_equiv.target
theorem finsupp.sum_ite_eq' {Î± : Type u_1} {M : Type u_5} {N : Type u_7} [has_zero M] [add_comm_monoid N] [decidable_eq Î±] (f : Î± â†’â‚€ M) (a : Î±) (b : Î± â†’ M â†’ N) : f.sum (Î» (x : Î±) (v : M), ite (x = a) (b x v) 0) = ite (a âˆˆ f.support) (b a (â‡‘f a)) 0
theorem orthonormal.oangle_smul_right_self_of_nonneg {V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) (x : V) {r : â„} (hr : 0 â‰¤ r) : hb.oangle x (r â€¢ x) = 0
theorem left.one_le_inv_iff {Î± : Type u} [group Î±] [has_le Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a : Î±} : 1 â‰¤ aâ»Â¹ â†” a â‰¤ 1
theorem same_ray.exists_nonneg_left {R : Type u_1} [linear_ordered_field R] {M : Type u_2} [add_comm_group M] [module R M] {x y : M} (h : same_ray R x y) (hx : x â‰  0) : âˆƒ (r : R), 0 â‰¤ r âˆ§ r â€¢ x = y
theorem module.directed_system.map_self {R : Type u} [ring R] {Î¹ : Type v} [preorder Î¹] {G : Î¹ â†’ Type w} [Î  (i : Î¹), add_comm_group (G i)] [Î  (i : Î¹), module R (G i)] (f : Î  (i j : Î¹), i â‰¤ j â†’ (G i â†’â‚—[R] G j)) [directed_system G (Î» (i j : Î¹) (h : i â‰¤ j), â‡‘(f i j h))] (i : Î¹) (x : G i) (h : i â‰¤ i) : â‡‘(f i i h) x = x
theorem first_order.language.Theory.exists_elementary_embedding_card_eq {L : first_order.language} (M : Type w') [L.Structure M] [iM : infinite M] (Îº : cardinal) (h1 : L.card.lift â‰¤ Îº.lift) (h2 : (cardinal.mk M).lift â‰¤ Îº.lift) : âˆƒ (N : category_theory.bundled L.Structure), nonempty (L.elementary_embedding M â†¥N) âˆ§ cardinal.mk â†¥N = Îº.lift
theorem cardinal.lift_mk_le' {Î± : Type u} {Î² : Type v} : (cardinal.mk Î±).lift â‰¤ (cardinal.mk Î²).lift â†” nonempty (Î± â†ª Î²)
theorem metric.Hausdorff_dist_empty' {Î± : Type u} [pseudo_metric_space Î±] {s : set Î±} : metric.Hausdorff_dist âˆ… s = 0
theorem module.End.eigenspaces_independent {K : Type v} {V : Type w} [field K] [add_comm_group V] [module K V] (f : module.End K V) : complete_lattice.independent f.eigenspace
theorem category_theory.presheaf.subsingleton_iff_is_separated_for {C : Type uâ‚} [category_theory.category C] {A : Type uâ‚‚} [category_theory.category A] (P : Cáµ’áµ– â¥¤ A) {X : C} (S : category_theory.sieve X) : (âˆ€ (c : category_theory.limits.cone (S.arrows.diagram.op â‹™ P)), subsingleton (c âŸ¶ P.map_cone S.arrows.cocone.op)) â†” âˆ€ (E : Aáµ’áµ–), category_theory.presieve.is_separated_for (P â‹™ category_theory.coyoneda.obj E) â‡‘S
theorem list.head_add_tail_sum (L : list â„•) : L.head + L.tail.sum = L.sum
theorem nat.perm_factors_mul {a b : â„•} (ha : a â‰  0) (hb : b â‰  0) : (a * b).factors ~ a.factors ++ b.factors
theorem continuous_linear_map.le_op_norm {ğ•œ : Type u_1} {ğ•œâ‚‚ : Type u_2} {E : Type u_4} {F : Type u_6} [semi_normed_group E] [semi_normed_group F] [nondiscrete_normed_field ğ•œ] [nondiscrete_normed_field ğ•œâ‚‚] [normed_space ğ•œ E] [normed_space ğ•œâ‚‚ F] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} [ring_hom_isometric Ïƒâ‚â‚‚] (f : E â†’SL[Ïƒâ‚â‚‚] F) (x : E) : âˆ¥â‡‘f xâˆ¥ â‰¤ âˆ¥fâˆ¥ * âˆ¥xâˆ¥
theorem zero_lt.left.one_lt_mul_of_lt_of_lt {Î± : Type u} {a b : Î±} [mul_one_class Î±] [has_zero Î±] [preorder Î±] [zero_lt.pos_mul_strict_mono Î±] (ha : 1 < a) (hb : 1 < b) (a0 : 0 < a) : 1 < a * b
theorem real.rpow_sum_le_const_mul_sum_rpow_of_nonneg {Î¹ : Type u} (s : finset Î¹) {f : Î¹ â†’ â„} {p : â„} (hp : 1 â‰¤ p) (hf : âˆ€ (i : Î¹), i âˆˆ s â†’ 0 â‰¤ f i) : s.sum (Î» (i : Î¹), f i) ^ p â‰¤ â†‘(s.card) ^ (p - 1) * s.sum (Î» (i : Î¹), f i ^ p)
theorem linear_map.det_to_matrix_eq_det_to_matrix {M : Type u_2} [add_comm_group M] {Î¹ : Type u_4} [decidable_eq Î¹] [fintype Î¹] {A : Type u_5} [comm_ring A] [module A M] {Îº : Type u_6} [fintype Îº] [decidable_eq Îº] (b : basis Î¹ A M) (c : basis Îº A M) (f : M â†’â‚—[A] M) : (â‡‘(linear_map.to_matrix b b) f).det = (â‡‘(linear_map.to_matrix c c) f).det
theorem set.partially_well_ordered_on.partially_well_ordered_on_sublist_forallâ‚‚ {Î± : Type u_1} (r : Î± â†’ Î± â†’ Prop) [is_refl Î± r] [is_trans Î± r] {s : set Î±} (h : s.partially_well_ordered_on r) : {l : list Î± | âˆ€ (x : Î±), x âˆˆ l â†’ x âˆˆ s}.partially_well_ordered_on (list.sublist_forallâ‚‚ r)
theorem category_theory.functor.left_derived_map_eq {C : Type u} [category_theory.category C] {D : Type u_1} [category_theory.category D] [category_theory.preadditive C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_equalizers C] [category_theory.limits.has_images C] [category_theory.has_projective_resolutions C] [category_theory.preadditive D] [category_theory.limits.has_zero_object D] [category_theory.limits.has_equalizers D] [category_theory.limits.has_cokernels D] [category_theory.limits.has_images D] [category_theory.limits.has_image_maps D] (F : C â¥¤ D) [F.additive] (n : â„•) {X Y : C} (f : X âŸ¶ Y) {P : category_theory.ProjectiveResolution X} {Q : category_theory.ProjectiveResolution Y} (g : P.complex âŸ¶ Q.complex) (w : g â‰« Q.Ï€ = P.Ï€ â‰« (chain_complex.singleâ‚€ C).map f) : (F.left_derived n).map f = (F.left_derived_obj_iso n P).hom â‰« (homology_functor D (complex_shape.down â„•) n).map ((F.map_homological_complex (complex_shape.down â„•)).map g) â‰« (F.left_derived_obj_iso n Q).inv
theorem fin.cons_snoc_eq_snoc_cons {n : â„•} {Î² : Type u_1} (a : Î²) (q : fin n â†’ Î²) (b : Î²) : fin.cons a (fin.snoc q b) = fin.snoc (fin.cons a q) b
theorem nat.squarefree_mul {m n : â„•} (hmn : m.coprime n) : squarefree (m * n) â†” squarefree m âˆ§ squarefree n
theorem is_pullback.map {C : Type uâ‚} [category_theory.category C] {D : Type uâ‚‚} [category_theory.category D] (F : C â¥¤ D) {W X Y Z : C} {f : W âŸ¶ X} {g : W âŸ¶ Y} {h : X âŸ¶ Z} {i : Y âŸ¶ Z} [category_theory.limits.preserves_limit (category_theory.limits.cospan h i) F] (s : category_theory.is_pullback f g h i) : category_theory.is_pullback (F.map f) (F.map g) (F.map h) (F.map i)
theorem euclidean_geometry.angle_add_angle_eq_pi_of_angle_eq_pi {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] (p1 : P) {p2 p3 p4 : P} (h : euclidean_geometry.angle p2 p3 p4 = real.pi) : euclidean_geometry.angle p1 p3 p2 + euclidean_geometry.angle p1 p3 p4 = real.pi
theorem category_theory.limits.colimit.pre_eq {J : Type uâ‚} [category_theory.category J] {K : Type uâ‚‚} [category_theory.category K] {C : Type u} [category_theory.category C] {F : J â¥¤ C} [category_theory.limits.has_colimit F] {E : K â¥¤ J} [category_theory.limits.has_colimit (E â‹™ F)] (s : category_theory.limits.colimit_cocone (E â‹™ F)) (t : category_theory.limits.colimit_cocone F) : category_theory.limits.colimit.pre F E = (category_theory.limits.colimit.iso_colimit_cocone s).hom â‰« s.is_colimit.desc (category_theory.limits.cocone.whisker E t.cocone) â‰« (category_theory.limits.colimit.iso_colimit_cocone t).inv
theorem emetric.mem_closure_iff {Î± : Type u} [pseudo_emetric_space Î±] {x : Î±} {s : set Î±} : x âˆˆ closure s â†” âˆ€ (Îµ : ennreal), Îµ > 0 â†’ (âˆƒ (y : Î±) (H : y âˆˆ s), has_edist.edist x y < Îµ)
theorem category_theory.limits.has_finite_coproducts_of_has_coproducts (C : Type u) [category_theory.category C] [category_theory.limits.has_coproducts C] : category_theory.limits.has_finite_coproducts C
theorem ring_equiv.map_mul {R : Type u_4} {S : Type u_5} [has_mul R] [has_add R] [has_mul S] [has_add S] (e : R â‰ƒ+* S) (x y : R) : â‡‘e (x * y) = â‡‘e x * â‡‘e y
theorem seq.ge_stable {Î± : Type u} (s : seq Î±) {aâ‚™ : Î±} {n m : â„•} (m_le_n : m â‰¤ n) (s_nth_eq_some : s.nth n = option.some aâ‚™) : âˆƒ (aâ‚˜ : Î±), s.nth m = option.some aâ‚˜
theorem lipschitz_on_with.of_le_add_mul' {Î± : Type u} [pseudo_metric_space Î±] {s : set Î±} {f : Î± â†’ â„} (K : â„) (h : âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (y : Î±), y âˆˆ s â†’ f x â‰¤ f y + K * has_dist.dist x y) : lipschitz_on_with K.to_nnreal f s
theorem nat.not_exists_sq {n m : â„•} (hl : m * m < n) (hr : n < (m + 1) * (m + 1)) : Â¬âˆƒ (t : â„•), t * t = n
theorem pi.single_eq_of_ne' {I : Type u} {f : I â†’ Type vâ‚} [decidable_eq I] [Î  (i : I), has_zero (f i)] {i i' : I} (h : i â‰  i') (x : f i) : pi.single i x i' = 0
theorem complete_space_of_is_complete_univ {Î± : Type u} [uniform_space Î±] (h : is_complete set.univ) : complete_space Î±
theorem multiset.Ico_eq_zero {Î± : Type u_1} [preorder Î±] [locally_finite_order Î±] {a b : Î±} : Â¬a < b â†’ multiset.Ico a b = 0
theorem multilinear_map.map_piecewise_add {R : Type u} {Î¹ : Type u'} {Mâ‚ : Î¹ â†’ Type vâ‚} {Mâ‚‚ : Type vâ‚‚} [decidable_eq Î¹] [semiring R] [Î  (i : Î¹), add_comm_monoid (Mâ‚ i)] [add_comm_monoid Mâ‚‚] [Î  (i : Î¹), module R (Mâ‚ i)] [module R Mâ‚‚] (f : multilinear_map R Mâ‚ Mâ‚‚) (m m' : Î  (i : Î¹), Mâ‚ i) (t : finset Î¹) : â‡‘f (t.piecewise (m + m') m') = t.powerset.sum (Î» (s : finset Î¹), â‡‘f (s.piecewise m m'))
theorem continuous_at.fst'' {Î± : Type u} {Î² : Type v} {Î³ : Type u_1} [topological_space Î±] [topological_space Î²] [topological_space Î³] {f : Î± â†’ Î³} {x : Î± Ã— Î²} (hf : continuous_at f x.fst) : continuous_at (Î» (x : Î± Ã— Î²), f x.fst) x
theorem polynomial.cyclotomic_irreducible_pow_of_irreducible_pow {p : â„•} (hp : nat.prime p) {R : Type u_1} [comm_ring R] [is_domain R] {n m : â„•} (hmn : m â‰¤ n) (h : irreducible (polynomial.cyclotomic (p ^ n) R)) : irreducible (polynomial.cyclotomic (p ^ m) R)
theorem finite_dimensional.finrank_pos_iff_exists_ne_zero {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] : 0 < finite_dimensional.finrank K V â†” âˆƒ (x : V), x â‰  0
theorem linear_independent.eq_of_smul_apply_eq_smul_apply {Î¹ : Type u_1} {R : Type u_3} [ring R] {M : Type u_2} [add_comm_group M] [module R M] {v : Î¹ â†’ M} (li : linear_independent R v) (c d : R) (i j : Î¹) (hc : c â‰  0) (h : c â€¢ v i = d â€¢ v j) : i = j
theorem category_theory.limits.complete_lattice.pullback_eq_inf {Î± : Type u} [semilattice_inf Î±] [order_top Î±] {x y z : Î±} (f : x âŸ¶ z) (g : y âŸ¶ z) : category_theory.limits.pullback f g = x âŠ“ y
theorem dense_bInter_of_GÎ´ {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [baire_space Î±] {S : set Î²} {f : Î  (x : Î²), x âˆˆ S â†’ set Î±} (ho : âˆ€ (s : Î²) (H : s âˆˆ S), is_GÎ´ (f s H)) (hS : S.countable) (hd : âˆ€ (s : Î²) (H : s âˆˆ S), dense (f s H)) : dense (â‹‚ (s : Î²) (H : s âˆˆ S), f s H)
theorem besicovitch.tau_package.color_lt {Î± : Type u_1} [metric_space Î±] {Î² : Type u} [nonempty Î²] (p : besicovitch.tau_package Î² Î±) {i : ordinal} (hi : i < p.last_step) {N : â„•} (hN : is_empty (besicovitch.satellite_config Î± N p.Ï„)) : p.color i < N
theorem metric.uniform_cauchy_seq_on_iff {Î± : Type u} {Î² : Type v} [pseudo_metric_space Î±] [nonempty Î²] [semilattice_sup Î²] {Î³ : Type u_1} {F : Î² â†’ Î³ â†’ Î±} {s : set Î³} : uniform_cauchy_seq_on F filter.at_top s â†” âˆ€ (Îµ : â„), Îµ > 0 â†’ (âˆƒ (N : Î²), âˆ€ (m : Î²), m â‰¥ N â†’ âˆ€ (n : Î²), n â‰¥ N â†’ âˆ€ (x : Î³), x âˆˆ s â†’ has_dist.dist (F m x) (F n x) < Îµ)
theorem orthonormal.inner_products_summable {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {Î¹ : Type u_4} (x : E) {v : Î¹ â†’ E} (hv : orthonormal ğ•œ v) : summable (Î» (i : Î¹), âˆ¥has_inner.inner (v i) xâˆ¥ ^ 2)
theorem mem_closure_iff_seq_limit {X : Type u_1} [topological_space X] [sequential_space X] {s : set X} {a : X} : a âˆˆ closure s â†” âˆƒ (x : â„• â†’ X), (âˆ€ (n : â„•), x n âˆˆ s) âˆ§ filter.tendsto x filter.at_top (nhds a)
theorem finite_dimensional.exists_relation_sum_zero_pos_coefficient_of_dim_succ_lt_card {L : Type u_1} [linear_ordered_field L] {W : Type v} [add_comm_group W] [module L W] [finite_dimensional L W] {t : finset W} (h : finite_dimensional.finrank L W + 1 < t.card) : âˆƒ (f : W â†’ L), t.sum (Î» (e : W), f e â€¢ e) = 0 âˆ§ t.sum (Î» (e : W), f e) = 0 âˆ§ âˆƒ (x : W) (H : x âˆˆ t), 0 < f x
theorem ring_hom.eq_on_set_closure {R : Type u} {S : Type v} [ring R] [ring S] {f g : R â†’+* S} {s : set R} (h : set.eq_on â‡‘f â‡‘g s) : set.eq_on â‡‘f â‡‘g â†‘(subring.closure s)
theorem finset.affine_combination_of_eq_one_of_eq_zero {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {Î¹ : Type u_4} (s : finset Î¹) (w : Î¹ â†’ k) (p : Î¹ â†’ P) {i : Î¹} (his : i âˆˆ s) (hwi : w i = 1) (hw0 : âˆ€ (i2 : Î¹), i2 âˆˆ s â†’ i2 â‰  i â†’ w i2 = 0) : â‡‘(s.affine_combination p) w = p i
theorem edist_le_range_sum_of_edist_le {Î± : Type u} [pseudo_emetric_space Î±] {f : â„• â†’ Î±} (n : â„•) {d : â„• â†’ ennreal} (hd : âˆ€ {k : â„•}, k < n â†’ has_edist.edist (f k) (f (k + 1)) â‰¤ d k) : has_edist.edist (f 0) (f n) â‰¤ (finset.range n).sum (Î» (i : â„•), d i)
theorem function.periodic.tendsto_at_top_interval_integral_of_pos {T : â„} {g : â„ â†’ â„} (hg : function.periodic g T) (h_int : âˆ€ (tâ‚ tâ‚‚ : â„), interval_integrable g measure_theory.measure_space.volume tâ‚ tâ‚‚) (hâ‚€ : 0 < âˆ« (x : â„) in 0..T, g x) (hT : 0 < T) : filter.tendsto (Î» (t : â„), âˆ« (x : â„) in 0..t, g x) filter.at_top filter.at_top
theorem padic_val_rat.finite_int_prime_iff {p : â„•} [p_prime : fact (nat.prime p)] {a : â„¤} : multiplicity.finite â†‘p a â†” a â‰  0
theorem inner_product_geometry.inner_eq_neg_mul_norm_iff_angle_eq_pi {V : Type u_1} [inner_product_space â„ V] {x y : V} (hx : x â‰  0) (hy : y â‰  0) : has_inner.inner x y = -(âˆ¥xâˆ¥ * âˆ¥yâˆ¥) â†” inner_product_geometry.angle x y = real.pi
theorem char.quadratic_char_sq_one {F : Type u_1} [field F] [fintype F] [decidable_eq F] {a : F} (ha : a â‰  0) : char.quadratic_char F a ^ 2 = 1
theorem is_bounded_linear_map_continuous_multilinear_map_comp_linear {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {G : Type u_4} [normed_group G] [normed_space ğ•œ G] {Î¹ : Type u_5} [decidable_eq Î¹] [fintype Î¹] (g : G â†’L[ğ•œ] E) : is_bounded_linear_map ğ•œ (Î» (f : continuous_multilinear_map ğ•œ (Î» (i : Î¹), E) F), f.comp_continuous_linear_map (Î» (_x : Î¹), g))
theorem generalized_continued_fraction.int_fract_pair.nth_stream_fr_nonneg_lt_one {K : Type u_1} {v : K} {n : â„•} [linear_ordered_field K] [floor_ring K] {ifp_n : generalized_continued_fraction.int_fract_pair K} (nth_stream_eq : generalized_continued_fraction.int_fract_pair.stream v n = option.some ifp_n) : 0 â‰¤ ifp_n.fr âˆ§ ifp_n.fr < 1
theorem metric.uniform_embedding_iff' {Î² : Type v} {Î³ : Type w} [metric_space Î³] [metric_space Î²] {f : Î³ â†’ Î²} : uniform_embedding f â†” (âˆ€ (Îµ : â„), Îµ > 0 â†’ (âˆƒ (Î´ : â„) (H : Î´ > 0), âˆ€ {a b : Î³}, has_dist.dist a b < Î´ â†’ has_dist.dist (f a) (f b) < Îµ)) âˆ§ âˆ€ (Î´ : â„), Î´ > 0 â†’ (âˆƒ (Îµ : â„) (H : Îµ > 0), âˆ€ {a b : Î³}, has_dist.dist (f a) (f b) < Îµ â†’ has_dist.dist a b < Î´)
theorem matrix.is_unit_iff_is_unit_det {n : Type u'} {Î± : Type v} [fintype n] [decidable_eq n] [comm_ring Î±] (A : matrix n n Î±) : is_unit A â†” is_unit A.det
theorem function.cantor_injective {Î± : Type u_1} (f : set Î± â†’ Î±) : Â¬function.injective f
theorem finite_field.exists_root_sum_quadratic {R : Type u_2} [comm_ring R] [is_domain R] [fintype R] {f g : polynomial R} (hf2 : f.degree = 2) (hg2 : g.degree = 2) (hR : fintype.card R % 2 = 1) : âˆƒ (a b : R), polynomial.eval a f + polynomial.eval b g = 0
theorem affine.simplex.monge_point_eq_of_range_eq {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {n : â„•} {sâ‚ sâ‚‚ : affine.simplex â„ P n} (h : set.range sâ‚.points = set.range sâ‚‚.points) : sâ‚.monge_point = sâ‚‚.monge_point
theorem order.lt_succ_of_not_is_max {Î± : Type u_1} [preorder Î±] [succ_order Î±] {a : Î±} : Â¬is_max a â†’ a < order.succ a
theorem ring_equiv.unop_map_list_prod {R : Type u_4} {S : Type u_5} [semiring R] [semiring S] (f : R â‰ƒ+* Sáµáµ’áµ–) (l : list R) : mul_opposite.unop (â‡‘f l.prod) = (list.map (mul_opposite.unop âˆ˜ â‡‘f) l).reverse.prod
theorem module.End.eigenvectors_linear_independent {K : Type v} {V : Type w} [field K] [add_comm_group V] [module K V] (f : module.End K V) (Î¼s : set K) (xs : â†¥Î¼s â†’ V) (h_eigenvec : âˆ€ (Î¼ : â†¥Î¼s), f.has_eigenvector â†‘Î¼ (xs Î¼)) : linear_independent K xs
theorem seq_continuous.continuous {X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] {f : X â†’ Y} [sequential_space X] : seq_continuous f â†’ continuous f
theorem cont_diff_on_fderiv_within_apply {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {m n : with_top â„•} {s : set E} {f : E â†’ F} (hf : cont_diff_on ğ•œ n f s) (hs : unique_diff_on ğ•œ s) (hmn : m + 1 â‰¤ n) : cont_diff_on ğ•œ m (Î» (p : E Ã— E), â‡‘(fderiv_within ğ•œ f s p.fst) p.snd) (s Ã—Ë¢ set.univ)
theorem add_monoid.not_is_torsion_free_iff (G : Type u_1) [add_monoid G] : Â¬add_monoid.is_torsion_free G â†” âˆƒ (g : G), g â‰  0 âˆ§ is_of_fin_add_order g
theorem add_order_of_pos {G : Type u} [fintype G] [add_left_cancel_monoid G] (x : G) : 0 < add_order_of x
theorem finset.weighted_vsub_apply {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {Î¹ : Type u_4} (s : finset Î¹) (w : Î¹ â†’ k) (p : Î¹ â†’ P) : â‡‘(s.weighted_vsub p) w = s.sum (Î» (i : Î¹), w i â€¢ (p i -áµ¥ classical.choice add_torsor.nonempty))
theorem subsemigroup.closure_induction' {M : Type u_1} [has_mul M] (s : set M) {p : Î  (x : M), x âˆˆ subsemigroup.closure s â†’ Prop} (Hs : âˆ€ (x : M) (h : x âˆˆ s), p x _) (Hmul : âˆ€ (x : M) (hx : x âˆˆ subsemigroup.closure s) (y : M) (hy : y âˆˆ subsemigroup.closure s), p x hx â†’ p y hy â†’ p (x * y) _) {x : M} (hx : x âˆˆ subsemigroup.closure s) : p x hx
theorem metric.Hausdorff_dist_le_diam {Î± : Type u} [pseudo_metric_space Î±] {s t : set Î±} (hs : s.nonempty) (bs : metric.bounded s) (ht : t.nonempty) (bt : metric.bounded t) : metric.Hausdorff_dist s t â‰¤ metric.diam (s âˆª t)
theorem mem_omega_limit_singleton_iff_map_cluster_point {Ï„ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [topological_space Î²] (f : filter Ï„) (Ï• : Ï„ â†’ Î± â†’ Î²) (x : Î±) (y : Î²) : y âˆˆ omega_limit f Ï• {x} â†” map_cluster_pt y f (Î» (t : Ï„), Ï• t x)
theorem right.add_nonpos {Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±} (ha : a â‰¤ 0) (hb : b â‰¤ 0) : a + b â‰¤ 0
theorem subsemigroup.subset_closure {M : Type u_1} [has_mul M] {s : set M} : s âŠ† â†‘(subsemigroup.closure s)
theorem convex_on.sup {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [ordered_semiring ğ•œ] [add_comm_monoid E] [linear_ordered_add_comm_monoid Î²] [has_scalar ğ•œ E] [module ğ•œ Î²] [ordered_smul ğ•œ Î²] {s : set E} {f g : E â†’ Î²} (hf : convex_on ğ•œ s f) (hg : convex_on ğ•œ s g) : convex_on ğ•œ s (f âŠ” g)
theorem filter.tendsto.op_zero_is_bounded_under_le' {Î± : Type u_1} {E : Type u_3} {F : Type u_4} {G : Type u_5} [semi_normed_group E] [semi_normed_group F] [semi_normed_group G] {f : Î± â†’ E} {g : Î± â†’ F} {l : filter Î±} (hf : filter.tendsto f l (nhds 0)) (hg : filter.is_bounded_under has_le.le l (has_norm.norm âˆ˜ g)) (op : E â†’ F â†’ G) (h_op : âˆƒ (A : â„), âˆ€ (x : E) (y : F), âˆ¥op x yâˆ¥ â‰¤ A * âˆ¥xâˆ¥ * âˆ¥yâˆ¥) : filter.tendsto (Î» (x : Î±), op (f x) (g x)) l (nhds 0)
theorem padic_val_rat.zero (m : â„•) : padic_val_rat m 0 = 0
theorem add_con.coe_add {M : Type u_1} [has_add M] {c : add_con M} (x y : M) : â†‘(x + y) = â†‘x + â†‘y
theorem continuous_map.continuous_curry' {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [topological_space Î±] [topological_space Î²] [topological_space Î³] (f : C(Î± Ã— Î², Î³)) : continuous f.curry'
theorem gauge_zero {E : Type u_1} [add_comm_group E] [module â„ E] {s : set E} : gauge s 0 = 0
theorem rel_supr_sum {Î± : Type u_1} {Î² : Type u_2} {Î´ : Type u_4} [add_comm_monoid Î±] [topological_space Î±] [t2_space Î±] [complete_lattice Î²] (m : Î² â†’ Î±) (m0 : m âŠ¥ = 0) (R : Î± â†’ Î± â†’ Prop) (m_supr : âˆ€ (s : â„• â†’ Î²), R (m (â¨† (i : â„•), s i)) (âˆ‘' (i : â„•), m (s i))) (s : Î´ â†’ Î²) (t : finset Î´) : R (m (â¨† (d : Î´) (H : d âˆˆ t), s d)) (t.sum (Î» (d : Î´), m (s d)))
theorem cardinal.lift_mk_eq' {Î± : Type u} {Î² : Type v} : (cardinal.mk Î±).lift = (cardinal.mk Î²).lift â†” nonempty (Î± â‰ƒ Î²)
theorem support_factorization {Î± : Type u_1} [cancel_comm_monoid_with_zero Î±] [unique_factorization_monoid Î±] [normalization_monoid Î±] [decidable_eq Î±] {n : Î±} : (factorization n).support = (unique_factorization_monoid.normalized_factors n).to_finset
theorem finset.subset_div {Î± : Type u_2} [decidable_eq Î±] [has_div Î±] {u : finset Î±} {s t : set Î±} : â†‘u âŠ† s / t â†’ (âˆƒ (s' t' : finset Î±), â†‘s' âŠ† s âˆ§ â†‘t' âŠ† t âˆ§ u âŠ† s' / t')
theorem inner_product_geometry.angle_sub_eq_angle_sub_rev_of_norm_eq {V : Type u_1} [inner_product_space â„ V] {x y : V} (h : âˆ¥xâˆ¥ = âˆ¥yâˆ¥) : inner_product_geometry.angle x (x - y) = inner_product_geometry.angle y (y - x)
theorem intermediate_field.adjoin_adjoin_left (F : Type u_1) [field F] {E : Type u_2} [field E] [algebra F E] (S T : set E) : â†‘(intermediate_field.adjoin â†¥(intermediate_field.adjoin F S) T) = intermediate_field.adjoin F (S âˆª T)
theorem commute.add_pow' {R : Type u_1} [semiring R] {x y : R} (h : commute x y) (n : â„•) : (x + y) ^ n = (finset.nat.antidiagonal n).sum (Î» (m : â„• Ã— â„•), n.choose m.fst â€¢ (x ^ m.fst * y ^ m.snd))
theorem inner_product_space.is_self_adjoint.orthogonal_supr_eigenspaces_invariant {ğ•œ : Type u_1} [is_R_or_C ğ•œ] {E : Type u_2} [inner_product_space ğ•œ E] {T : E â†’â‚—[ğ•œ] E} (hT : inner_product_space.is_self_adjoint T) â¦ƒv : Eâ¦„ (hv : v âˆˆ (â¨† (Î¼ : ğ•œ), module.End.eigenspace T Î¼)á—®) : â‡‘T v âˆˆ (â¨† (Î¼ : ğ•œ), module.End.eigenspace T Î¼)á—®
theorem quotient.induction_on' {Î± : Sort u_1} {sâ‚ : setoid Î±} {p : quotient sâ‚ â†’ Prop} (q : quotient sâ‚) (h : âˆ€ (a : Î±), p (quotient.mk' a)) : p q
theorem complete_lattice.independent.dfinsupp_lsum_injective {Î¹ : Type u_1} {R : Type u_2} {N : Type u_5} [dec_Î¹ : decidable_eq Î¹] [ring R] [add_comm_group N] [module R N] {p : Î¹ â†’ submodule R N} (h : complete_lattice.independent p) : function.injective â‡‘(â‡‘(dfinsupp.lsum â„•) (Î» (i : Î¹), (p i).subtype))
theorem besicovitch.exists_disjoint_closed_ball_covering_ae_of_finite_measure_aux {Î± : Type u_1} [metric_space Î±] [topological_space.second_countable_topology Î±] [measurable_space Î±] [opens_measurable_space Î±] [has_besicovitch_covering Î±] (Î¼ : measure_theory.measure Î±) [measure_theory.is_finite_measure Î¼] (f : Î± â†’ set â„) (s : set Î±) (hf : âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (Î´ : â„), Î´ > 0 â†’ (f x âˆ© set.Ioo 0 Î´).nonempty) : âˆƒ (t : set (Î± Ã— â„)), t.countable âˆ§ (âˆ€ (p : Î± Ã— â„), p âˆˆ t â†’ p.fst âˆˆ s) âˆ§ (âˆ€ (p : Î± Ã— â„), p âˆˆ t â†’ p.snd âˆˆ f p.fst) âˆ§ â‡‘Î¼ (s  â‹ƒ (p : Î± Ã— â„) (hp : p âˆˆ t), metric.closed_ball p.fst p.snd) = 0 âˆ§ t.pairwise_disjoint (Î» (p : Î± Ã— â„), metric.closed_ball p.fst p.snd)
theorem ring_hom.map_mul {Î± : Type u_2} {Î² : Type u_3} {rÎ± : non_assoc_semiring Î±} {rÎ² : non_assoc_semiring Î²} (f : Î± â†’+* Î²) (a b : Î±) : â‡‘f (a * b) = â‡‘f a * â‡‘f b
theorem list.sum_take_map_length_lt1 {Î± : Type u_1} (L : list (list Î±)) {i j : â„•} (hi : i < L.length) (hj : j < (L.nth_le i hi).length) : (list.take i (list.map list.length L)).sum + j < (list.take (i + 1) (list.map list.length L)).sum
theorem subtype.exists' {Î± : Sort u_1} {p : Î± â†’ Prop} {q : Î  (x : Î±), p x â†’ Prop} : (âˆƒ (x : Î±) (h : p x), q x h) â†” âˆƒ (x : {a // p a}), q â†‘x _
theorem zmod.pow_card {p : â„•} [fact (nat.prime p)] (x : zmod p) : x ^ p = x
theorem add_con.induction_onâ‚‚ {M : Type u_1} {N : Type u_2} [has_add M] [has_add N] {c : add_con M} {d : add_con N} {C : c.quotient â†’ d.quotient â†’ Prop} (p : c.quotient) (q : d.quotient) (H : âˆ€ (x : M) (y : N), C â†‘x â†‘y) : C p q
theorem strongly_measurable_of_tendsto {Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_3} {m : measurable_space Î±} [topological_space Î²] [topological_space.pseudo_metrizable_space Î²] (u : filter Î¹) [u.ne_bot] [u.is_countably_generated] {f : Î¹ â†’ Î± â†’ Î²} {g : Î± â†’ Î²} (hf : âˆ€ (i : Î¹), measure_theory.strongly_measurable (f i)) (lim : filter.tendsto f u (nhds g)) : measure_theory.strongly_measurable g
theorem measure_theory.integral_integral_swap {Î± : Type u_1} {Î² : Type u_3} {E : Type u_6} [measurable_space Î±] [measurable_space Î²] {Î¼ : measure_theory.measure Î±} {Î½ : measure_theory.measure Î²} [normed_group E] [measure_theory.sigma_finite Î½] [normed_space â„ E] [complete_space E] [measure_theory.sigma_finite Î¼] â¦ƒf : Î± â†’ Î² â†’ Eâ¦„ (hf : measure_theory.integrable (function.uncurry f) (Î¼.prod Î½)) : âˆ« (x : Î±), âˆ« (y : Î²), f x y âˆ‚Î½ âˆ‚Î¼ = âˆ« (y : Î²), âˆ« (x : Î±), f x y âˆ‚Î¼ âˆ‚Î½
theorem list.split_on_p_spec {Î± : Type u} (p : Î± â†’ Prop) [decidable_pred p] (as : list Î±) : (list.zip_with has_append.append (list.split_on_p p as) (list.map (Î» (x : Î±), [x]) (list.filter p as) ++ [list.nil])).join = as
theorem bdd_above.convolution_exists_at {ğ•œ : Type u_1} {G : Type u_2} {E : Type u_3} {E' : Type u_4} {F : Type u_6} [normed_group E] [normed_group E'] [normed_group F] {f : G â†’ E} {g : G â†’ E'} [nondiscrete_normed_field ğ•œ] [normed_space ğ•œ E] [normed_space ğ•œ E'] [normed_space ğ•œ F] (L : E â†’L[ğ•œ] E' â†’L[ğ•œ] F) [measurable_space G] {Î¼ : measure_theory.measure G} [add_comm_group G] [has_measurable_addâ‚‚ G] [has_measurable_neg G] [Î¼.is_add_left_invariant] [measure_theory.sigma_finite Î¼] {xâ‚€ : G} {s : set G} (hbg : bdd_above ((Î» (i : G), âˆ¥g iâˆ¥) '' ((Î» (t : G), xâ‚€ - t) â»Â¹' s))) (hs : measurable_set s) (h2s : function.support (Î» (t : G), â‡‘(â‡‘L (f t)) (g (xâ‚€ - t))) âŠ† s) (hf : measure_theory.integrable_on f s Î¼) (hmf : measure_theory.ae_strongly_measurable f Î¼) (hmg : measure_theory.ae_strongly_measurable g Î¼) : convolution_exists_at f g xâ‚€ L Î¼
theorem add_con.refl {M : Type u_1} [has_add M] (c : add_con M) (x : M) : â‡‘c x x
theorem lt_of_tsub_lt_tsub_right_of_le {Î± : Type u_1} [canonically_ordered_add_monoid Î±] [has_sub Î±] [has_ordered_sub Î±] {a b c : Î±} (h : c â‰¤ b) (h2 : a - c < b - c) : a < b
theorem real.Sup_nonpos (S : set â„) (hS : âˆ€ (x : â„), x âˆˆ S â†’ x â‰¤ 0) : has_Sup.Sup S â‰¤ 0
theorem map_Inf_of_continuous_at_of_monotone {Î± : Type u} {Î² : Type v} [complete_linear_order Î±] [topological_space Î±] [order_topology Î±] [complete_linear_order Î²] [topological_space Î²] [order_topology Î²] {f : Î± â†’ Î²} {s : set Î±} (Cf : continuous_at f (has_Inf.Inf s)) (Mf : monotone f) (ftop : f âŠ¤ = âŠ¤) : f (has_Inf.Inf s) = has_Inf.Inf (f '' s)
theorem is_preconnected.subset_closure {Î± : Type u} [topological_space Î±] {s t : set Î±} (H : is_preconnected s) (Kst : s âŠ† t) (Ktcs : t âŠ† closure s) : is_preconnected t
theorem convex.norm_image_sub_le_of_norm_has_fderiv_within_le' {E : Type u_1} [normed_group E] [normed_space â„ E] {ğ•œ : Type u_3} {G : Type u_4} [is_R_or_C ğ•œ] [normed_space ğ•œ E] [normed_group G] [normed_space ğ•œ G] {f : E â†’ G} {C : â„} {s : set E} {x y : E} {f' : E â†’ (E â†’L[ğ•œ] G)} {Ï† : E â†’L[ğ•œ] G} (hf : âˆ€ (x : E), x âˆˆ s â†’ has_fderiv_within_at f (f' x) s x) (bound : âˆ€ (x : E), x âˆˆ s â†’ âˆ¥f' x - Ï†âˆ¥ â‰¤ C) (hs : convex â„ s) (xs : x âˆˆ s) (ys : y âˆˆ s) : âˆ¥f y - f x - â‡‘Ï† (y - x)âˆ¥ â‰¤ C * âˆ¥y - xâˆ¥
theorem supr_limsup_dimH {X : Type u_2} [emetric_space X] [topological_space.second_countable_topology X] (s : set X) : (â¨† (x : X), (nhds_within x s).small_sets.limsup dimH) = dimH s
theorem same_ray.smul {R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {x y : M} {S : Type u_3} [monoid S] [distrib_mul_action S M] [smul_comm_class R S M] (h : same_ray R x y) (s : S) : same_ray R (s â€¢ x) (s â€¢ y)
theorem map_sub {G : Type u_6} {H : Type u_7} {F : Type u_8} [add_group G] [subtraction_monoid H] [add_monoid_hom_class F G H] (f : F) (a b : G) : â‡‘f (a - b) = â‡‘f a - â‡‘f b
theorem exists_subset_Union_ball_radius_lt {Î± : Type u} {Î¹ : Type v} [metric_space Î±] [proper_space Î±] {c : Î¹ â†’ Î±} {s : set Î±} {r : Î¹ â†’ â„} (hs : is_closed s) (uf : âˆ€ (x : Î±), x âˆˆ s â†’ {i : Î¹ | x âˆˆ metric.ball (c i) (r i)}.finite) (us : s âŠ† â‹ƒ (i : Î¹), metric.ball (c i) (r i)) : âˆƒ (r' : Î¹ â†’ â„), (s âŠ† â‹ƒ (i : Î¹), metric.ball (c i) (r' i)) âˆ§ âˆ€ (i : Î¹), r' i < r i
theorem is_add_group_hom.to_is_add_monoid_hom {Î± : Type u} {Î² : Type v} [add_group Î±] [add_group Î²] {f : Î± â†’ Î²} (hf : is_add_group_hom f) : is_add_monoid_hom f
theorem category_theory.abelian.pseudoelement.mono_of_zero_of_map_zero {C : Type u} [category_theory.category C] [category_theory.abelian C] {P Q : C} (f : P âŸ¶ Q) : (âˆ€ (a : â†¥P), â‡‘f a = 0 â†’ a = 0) â†’ category_theory.mono f
theorem normed_group_hom.norm_id_le (V : Type u_1) [semi_normed_group V] : âˆ¥normed_group_hom.id Vâˆ¥ â‰¤ 1
theorem category_theory.yoneda.is_iso {C : Type uâ‚} [category_theory.category C] {X Y : C} (f : X âŸ¶ Y) [category_theory.is_iso (category_theory.yoneda.map f)] : category_theory.is_iso f
theorem affine_subspace.direction_le {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {s1 s2 : affine_subspace k P} (h : s1 â‰¤ s2) : s1.direction â‰¤ s2.direction
theorem concave_on.le_map_set_average {Î± : Type u_1} {E : Type u_2} {m0 : measurable_space Î±} [normed_group E] [normed_space â„ E] [complete_space E] {Î¼ : measure_theory.measure Î±} {s : set E} {t : set Î±} {f : Î± â†’ E} {g : E â†’ â„} (hg : concave_on â„ s g) (hgc : continuous_on g s) (hsc : is_closed s) (h0 : â‡‘Î¼ t â‰  0) (ht : â‡‘Î¼ t â‰  âŠ¤) (hfs : âˆ€áµ (x : Î±) âˆ‚Î¼.restrict t, f x âˆˆ s) (hfi : measure_theory.integrable_on f t Î¼) (hgi : measure_theory.integrable_on (g âˆ˜ f) t Î¼) : â¨ (x : Î±) in t, g (f x) âˆ‚Î¼ â‰¤ g (â¨ (x : Î±) in t, f x âˆ‚Î¼)
theorem orthonormal.rotation_eq_rotation_neg_of_orientation_eq_neg {V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) {bâ‚‚ : basis (fin 2) â„ V} (hbâ‚‚ : orthonormal â„ â‡‘bâ‚‚) (ho : b.orientation = -bâ‚‚.orientation) (Î¸ : real.angle) : hb.rotation Î¸ = hbâ‚‚.rotation (-Î¸)
theorem strict_convex_on_univ_of_deriv2_pos {f : â„ â†’ â„} (hf' : differentiable â„ f) (hf'' : âˆ€ (x : â„), 0 < deriv^[2] f x) : strict_convex_on â„ set.univ f
theorem antitone_on.concave_on_of_deriv {D : set â„} (hD : convex â„ D) {f : â„ â†’ â„} (hf : continuous_on f D) (hf' : differentiable_on â„ f (interior D)) (h_anti : antitone_on (deriv f) (interior D)) : concave_on â„ D f
theorem category_theory.over.construct_products.over_product_of_wide_pullback {J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_limits_of_shape (category_theory.limits.wide_pullback_shape J) C] {B : C} : category_theory.limits.has_limits_of_shape (category_theory.discrete J) (category_theory.over B)
theorem fractional_ideal.right_inverse_eq (K : Type u_3) [field K] {Râ‚ : Type u_4} [comm_ring Râ‚] [is_domain Râ‚] [algebra Râ‚ K] [is_fraction_ring Râ‚ K] (I J : fractional_ideal (non_zero_divisors Râ‚) K) (h : I * J = 1) : J = Iâ»Â¹
theorem fourier_subalgebra_conj_invariant  : continuous_map.conj_invariant_subalgebra (subalgebra.restrict_scalars â„ fourier_subalgebra)
theorem is_GÎ´_sInter {Î± : Type u_1} [topological_space Î±] {S : set (set Î±)} (h : âˆ€ (s : set Î±), s âˆˆ S â†’ is_GÎ´ s) (hS : S.countable) : is_GÎ´ (â‹‚â‚€ S)
theorem continuous_linear_map.smul_comp_LpL_apply {Î± : Type u_1} {E : Type u_2} {F : Type u_3} {m0 : measurable_space Î±} {p : ennreal} {Î¼ : measure_theory.measure Î±} [normed_group E] [normed_group F] {ğ•œ : Type u_5} [nondiscrete_normed_field ğ•œ] [normed_space ğ•œ E] [normed_space ğ•œ F] [fact (1 â‰¤ p)] {ğ•œ' : Type u_4} [normed_field ğ•œ'] [normed_space ğ•œ' F] [smul_comm_class ğ•œ ğ•œ' F] (c : ğ•œ') (L : E â†’L[ğ•œ] F) (f : â†¥(measure_theory.Lp E p Î¼)) : â‡‘(continuous_linear_map.comp_LpL p Î¼ (c â€¢ L)) f = c â€¢ â‡‘(continuous_linear_map.comp_LpL p Î¼ L) f
theorem embedding_sigma_map {Î¹ : Type u_5} {Ïƒ : Î¹ â†’ Type u_6} [Î  (i : Î¹), topological_space (Ïƒ i)] {Ï„ : Î¹ â†’ Type u_1} [Î  (i : Î¹), topological_space (Ï„ i)] {f : Î  (i : Î¹), Ïƒ i â†’ Ï„ i} (hf : âˆ€ (i : Î¹), embedding (f i)) : embedding (sigma.map id f)
theorem path.trans_pi_eq_pi_trans {Î¹ : Type u_3} {Ï‡ : Î¹ â†’ Type u_4} [Î  (i : Î¹), topological_space (Ï‡ i)] {as bs cs : Î  (i : Î¹), Ï‡ i} (Î³â‚€ : Î  (i : Î¹), path (as i) (bs i)) (Î³â‚ : Î  (i : Î¹), path (bs i) (cs i)) : (path.pi Î³â‚€).trans (path.pi Î³â‚) = path.pi (Î» (i : Î¹), (Î³â‚€ i).trans (Î³â‚ i))
theorem matrix.is_symm.ext_iff {Î± : Type u_1} {n : Type u_3} {A : matrix n n Î±} : A.is_symm â†” âˆ€ (i j : n), A j i = A i j
theorem category_theory.limits.complete_lattice.finite_colimit_eq_finset_univ_sup {Î± J : Type u} [category_theory.small_category J] [category_theory.fin_category J] [semilattice_sup Î±] [order_bot Î±] (F : J â¥¤ Î±) : category_theory.limits.colimit F = finset.univ.sup F.obj
theorem category_theory.limits.kernel.lift_map {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y Z X' Y' Z' : C} (f : X âŸ¶ Y) (g : Y âŸ¶ Z) [category_theory.limits.has_kernel g] (w : f â‰« g = 0) (f' : X' âŸ¶ Y') (g' : Y' âŸ¶ Z') [category_theory.limits.has_kernel g'] (w' : f' â‰« g' = 0) (p : X âŸ¶ X') (q : Y âŸ¶ Y') (r : Z âŸ¶ Z') (hâ‚ : f â‰« q = p â‰« f') (hâ‚‚ : g â‰« r = q â‰« g') : category_theory.limits.kernel.lift g f w â‰« category_theory.limits.kernel.map g g' q r hâ‚‚ = p â‰« category_theory.limits.kernel.lift g' f' w'
theorem measurable.of_le_map {Î± : Type u_1} {Î² : Type u_2} {mâ‚ : measurable_space Î±} {mâ‚‚ : measurable_space Î²} {f : Î± â†’ Î²} : mâ‚‚ â‰¤ measurable_space.map f mâ‚ â†’ measurable f
theorem measure_theory.exists_lt_lower_semicontinuous_integral_lt {Î± : Type u_1} [topological_space Î±] [measurable_space Î±] [borel_space Î±] {Î¼ : measure_theory.measure Î±} [Î¼.weakly_regular] [measure_theory.sigma_finite Î¼] (f : Î± â†’ â„) (hf : measure_theory.integrable f Î¼) {Îµ : â„} (Îµpos : 0 < Îµ) : âˆƒ (g : Î± â†’ ereal), (âˆ€ (x : Î±), â†‘(f x) < g x) âˆ§ lower_semicontinuous g âˆ§ measure_theory.integrable (Î» (x : Î±), (g x).to_real) Î¼ âˆ§ (âˆ€áµ (x : Î±) âˆ‚Î¼, g x < âŠ¤) âˆ§ âˆ« (x : Î±), (g x).to_real âˆ‚Î¼ < âˆ« (x : Î±), f x âˆ‚Î¼ + Îµ
theorem besicovitch.ae_tendsto_measure_inter_div {Î² : Type u} [metric_space Î²] [measurable_space Î²] [borel_space Î²] [sigma_compact_space Î²] [has_besicovitch_covering Î²] (Î¼ : measure_theory.measure Î²) [measure_theory.is_locally_finite_measure Î¼] (s : set Î²) : âˆ€áµ (x : Î²) âˆ‚Î¼.restrict s, filter.tendsto (Î» (r : â„), â‡‘Î¼ (s âˆ© metric.closed_ball x r) / â‡‘Î¼ (metric.closed_ball x r)) (nhds_within 0 (set.Ioi 0)) (nhds 1)
theorem continuous_prod_of_continuous_lipschitz {Î± : Type u} {Î² : Type v} {Î³ : Type w} [pseudo_emetric_space Î±] [topological_space Î²] [pseudo_emetric_space Î³] (f : Î± Ã— Î² â†’ Î³) (K : nnreal) (ha : âˆ€ (a : Î±), continuous (Î» (y : Î²), f (a, y))) (hb : âˆ€ (b : Î²), lipschitz_with K (Î» (x : Î±), f (x, b))) : continuous f
theorem differentiable_on.has_fpower_series_on_ball {E : Type u} [normed_group E] [normed_space â„‚ E] [complete_space E] {R : nnreal} {c : â„‚} {f : â„‚ â†’ E} (hd : differentiable_on â„‚ f (metric.closed_ball c â†‘R)) (hR : 0 < R) : has_fpower_series_on_ball f (cauchy_power_series f c â†‘R) c â†‘R
theorem measure_theory.measure.prod_eq_generate_from {Î± : Type u_1} {Î² : Type u_3} [measurable_space Î±] [measurable_space Î²] {Î¼ : measure_theory.measure Î±} {Î½ : measure_theory.measure Î²} {C : set (set Î±)} {D : set (set Î²)} (hC : measurable_space.generate_from C = _inst_1) (hD : measurable_space.generate_from D = _inst_3) (h2C : is_pi_system C) (h2D : is_pi_system D) (h3C : Î¼.finite_spanning_sets_in C) (h3D : Î½.finite_spanning_sets_in D) {Î¼Î½ : measure_theory.measure (Î± Ã— Î²)} (hâ‚ : âˆ€ (s : set Î±), s âˆˆ C â†’ âˆ€ (t : set Î²), t âˆˆ D â†’ â‡‘Î¼Î½ (s Ã—Ë¢ t) = â‡‘Î¼ s * â‡‘Î½ t) : Î¼.prod Î½ = Î¼Î½
theorem category_theory.is_iso_of_op {C : Type uâ‚} [category_theory.category C] {X Y : C} (f : X âŸ¶ Y) [category_theory.is_iso f.op] : category_theory.is_iso f
theorem Top.presheaf.is_sheaf_of_iso {C : Type u} [category_theory.category C] [category_theory.limits.has_products C] {X : Top} {F G : Top.presheaf C X} (Î± : F â‰… G) (h : F.is_sheaf) : G.is_sheaf
theorem linear_map.continuous_on_pi {Î¹ : Type u_1} {ğ•œ : Type u_2} {F : Type u_3} [fintype Î¹] [semiring ğ•œ] [topological_space ğ•œ] [add_comm_monoid F] [module ğ•œ F] [topological_space F] [has_continuous_add F] [has_continuous_smul ğ•œ F] (f : (Î¹ â†’ ğ•œ) â†’â‚—[ğ•œ] F) : continuous â‡‘f
theorem measure_theory.measurable_embedding_of_fderiv_within {E : Type u_1} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] {s : set E} {f : E â†’ E} {f' : E â†’ (E â†’L[â„] E)} [measurable_space E] [borel_space E] (hs : measurable_set s) (hf' : âˆ€ (x : E), x âˆˆ s â†’ has_fderiv_within_at f (f' x) s x) (hf : set.inj_on f s) : measurable_embedding (s.restrict f)
theorem category_theory.limits.kernel.Î¹_of_zero {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (X Y : C) : category_theory.is_iso (category_theory.limits.kernel.Î¹ 0)
theorem le_of_sub_nonpos {Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±} : a - b â‰¤ 0 â†’ a â‰¤ b
theorem trans_gen_of_succ_of_gt {Î± : Type u_1} [partial_order Î±] [succ_order Î±] [is_succ_archimedean Î±] (r : Î± â†’ Î± â†’ Prop) {n m : Î±} (h : âˆ€ (i : Î±), i âˆˆ set.Ico m n â†’ r (order.succ i) i) (hmn : m < n) : relation.trans_gen r n m
theorem vitali_family.mul_measure_le_of_subset_lt_lim_ratio_meas {Î± : Type u_1} [metric_space Î±] {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} (v : vitali_family Î¼) [sigma_compact_space Î±] [borel_space Î±] [measure_theory.is_locally_finite_measure Î¼] {Ï : measure_theory.measure Î±} [measure_theory.is_locally_finite_measure Ï] (hÏ : Ï.absolutely_continuous Î¼) {q : nnreal} {s : set Î±} (h : s âŠ† {x : Î± | â†‘q < v.lim_ratio_meas hÏ x}) : â†‘q * â‡‘Î¼ s â‰¤ â‡‘Ï s
theorem nat.four_pow_le_two_mul_self_mul_central_binom (n : â„•) (n_pos : 0 < n) : 4 ^ n â‰¤ 2 * n * n.central_binom
theorem measure_theory.pdf.is_uniform.integral_eq {Î± : Type u_1} {m : measurable_space Î±} {â„™ : measure_theory.measure Î±} [measure_theory.is_finite_measure Â«â„™Â»] {X : Î± â†’ â„} {s : set â„} (hms : measurable_set s) (hns : â‡‘measure_theory.measure_space.volume s â‰  0) (hnt : â‡‘measure_theory.measure_space.volume s â‰  âŠ¤) (huX : measure_theory.pdf.is_uniform X s Â«â„™Â» measure_theory.measure_space.volume) : âˆ« (x : Î±), X x âˆ‚Â«â„™Â» = (â‡‘measure_theory.measure_space.volume s)â»Â¹.to_real * âˆ« (x : â„) in s, x
theorem continuous_multilinear_map.map_add_univ {R : Type u} {Î¹ : Type v} {Mâ‚ : Î¹ â†’ Type wâ‚} {Mâ‚‚ : Type wâ‚‚} [decidable_eq Î¹] [semiring R] [Î  (i : Î¹), add_comm_monoid (Mâ‚ i)] [add_comm_monoid Mâ‚‚] [Î  (i : Î¹), module R (Mâ‚ i)] [module R Mâ‚‚] [Î  (i : Î¹), topological_space (Mâ‚ i)] [topological_space Mâ‚‚] (f : continuous_multilinear_map R Mâ‚ Mâ‚‚) [fintype Î¹] (m m' : Î  (i : Î¹), Mâ‚ i) : â‡‘f (m + m') = finset.univ.sum (Î» (s : finset Î¹), â‡‘f (s.piecewise m m'))
theorem closure_compl_singleton {Î± : Type u} [topological_space Î±] (x : Î±) [(nhds_within x {x}á¶œ).ne_bot] : closure {x}á¶œ = set.univ
theorem concave_on.comp_affine_map {ğ•œ : Type u_1} {E : Type u_2} {F : Type u_3} {Î² : Type u_4} [linear_ordered_field ğ•œ] [add_comm_group E] [add_comm_group F] [ordered_add_comm_monoid Î²] [module ğ•œ E] [module ğ•œ F] [has_scalar ğ•œ Î²] {f : F â†’ Î²} (g : E â†’áµƒ[ğ•œ] F) {s : set F} (hf : concave_on ğ•œ s f) : concave_on ğ•œ (â‡‘g â»Â¹' s) (f âˆ˜ â‡‘g)
theorem padic_val_rat.one {p : â„•} : padic_val_rat p 1 = 0
theorem subobject_of_le_as_image_to_kernel {V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {A B C : V} (f : A âŸ¶ B) [category_theory.limits.has_image f] (g : B âŸ¶ C) [category_theory.limits.has_kernel g] (w : f â‰« g = 0) (h : category_theory.limits.image_subobject f â‰¤ category_theory.limits.kernel_subobject g) : (category_theory.limits.image_subobject f).of_le (category_theory.limits.kernel_subobject g) h = image_to_kernel f g w
theorem function.injective2.right {Î± : Sort u_1} {Î² : Sort u_2} {Î³ : Sort u_3} {f : Î± â†’ Î² â†’ Î³} (hf : function.injective2 f) (a : Î±) : function.injective (f a)
theorem is_group_hom.to_is_monoid_hom {Î± : Type u} {Î² : Type v} [group Î±] [group Î²] {f : Î± â†’ Î²} (hf : is_group_hom f) : is_monoid_hom f
theorem category_theory.limits.coequalizer.hom_ext {C : Type u} [category_theory.category C] {X Y : C} {f g : X âŸ¶ Y} [category_theory.limits.has_coequalizer f g] {W : C} {k l : category_theory.limits.coequalizer f g âŸ¶ W} (h : category_theory.limits.coequalizer.Ï€ f g â‰« k = category_theory.limits.coequalizer.Ï€ f g â‰« l) : k = l
theorem even.strict_convex_on_pow {n : â„•} (hn : even n) (h : n â‰  0) : strict_convex_on â„ set.univ (Î» (x : â„), x ^ n)
theorem polynomial.is_noetherian_ring {R : Type u} [comm_ring R] [is_noetherian_ring R] : is_noetherian_ring (polynomial R)
theorem convex.image_sub_le_mul_sub_of_deriv_le {D : set â„} (hD : convex â„ D) {f : â„ â†’ â„} (hf : continuous_on f D) (hf' : differentiable_on â„ f (interior D)) {C : â„} (le_hf' : âˆ€ (x : â„), x âˆˆ interior D â†’ deriv f x â‰¤ C) (x : â„) (H : x âˆˆ D) (y : â„) (H_1 : y âˆˆ D) : x â‰¤ y â†’ f y - f x â‰¤ C * (y - x)
theorem is_left_regular_iff {R : Type u_1} [has_mul R] {a : R} : is_left_regular a â†” is_smul_regular R a
theorem matrix.kronecker_map_bilinear_mul_mul {R : Type u_1} {Î± : Type u_2} {Î² : Type u_4} {Î³ : Type u_6} {l : Type u_8} {m : Type u_9} {n : Type u_10} {l' : Type u_14} {m' : Type u_15} {n' : Type u_16} [comm_semiring R] [fintype m] [fintype m'] [non_unital_non_assoc_semiring Î±] [non_unital_non_assoc_semiring Î²] [non_unital_non_assoc_semiring Î³] [module R Î±] [module R Î²] [module R Î³] (f : Î± â†’â‚—[R] Î² â†’â‚—[R] Î³) (h_comm : âˆ€ (a b : Î±) (a' b' : Î²), â‡‘(â‡‘f (a * b)) (a' * b') = â‡‘(â‡‘f a) a' * â‡‘(â‡‘f b) b') (A : matrix l m Î±) (B : matrix m n Î±) (A' : matrix l' m' Î²) (B' : matrix m' n' Î²) : â‡‘(â‡‘(matrix.kronecker_map_bilinear f) (A.mul B)) (A'.mul B') = (â‡‘(â‡‘(matrix.kronecker_map_bilinear f) A) A').mul (â‡‘(â‡‘(matrix.kronecker_map_bilinear f) B) B')
theorem finset.sup_product_left {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [semilattice_sup Î±] [order_bot Î±] (s : finset Î²) (t : finset Î³) (f : Î² Ã— Î³ â†’ Î±) : (s.product t).sup f = s.sup (Î» (i : Î²), t.sup (Î» (i' : Î³), f (i, i')))
theorem is_dedekind_domain_inv.is_dedekind_domain {A : Type u_2} [comm_ring A] [is_domain A] (h : is_dedekind_domain_inv A) : is_dedekind_domain A
theorem filter.tendsto_at_bot_of_monotone_of_filter {Î¹ : Type u_1} {Î± : Type u_3} [preorder Î¹] [preorder Î±] {l : filter Î¹} {u : Î¹ â†’ Î±} (h : monotone u) [l.ne_bot] (hu : filter.tendsto u l filter.at_bot) : filter.tendsto u filter.at_bot filter.at_bot
theorem equiv_iff_same_ray {R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {vâ‚ vâ‚‚ : ray_vector R M} : vâ‚ â‰ˆ vâ‚‚ â†” same_ray R â†‘vâ‚ â†‘vâ‚‚
theorem four_pos {Î± : Type u} [ordered_semiring Î±] [nontrivial Î±] : 0 < 4
theorem finsum_comp {Î± : Type u_1} {Î² : Type u_2} {M : Type u_5} [add_comm_monoid M] {g : Î² â†’ M} (e : Î± â†’ Î²) (heâ‚€ : function.bijective e) : finsum (Î» (i : Î±), g (e i)) = finsum (Î» (j : Î²), g j)
theorem euclidean_geometry.angle_nonneg {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] (p1 p2 p3 : P) : 0 â‰¤ euclidean_geometry.angle p1 p2 p3
theorem nat.choose_two_right (n : â„•) : n.choose 2 = n * (n - 1) / 2
theorem eq_sum_orthogonal_projection_self_orthogonal_complement {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] (K : submodule ğ•œ E) [complete_space E] [complete_space â†¥K] (w : E) : w = â†‘(â‡‘(orthogonal_projection K) w) + â†‘(â‡‘(orthogonal_projection Ká—®) w)
theorem affine_subspace.sup_direction_lt_of_nonempty_of_inter_empty {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {s1 s2 : affine_subspace k P} (h1 : â†‘s1.nonempty) (h2 : â†‘s2.nonempty) (he : â†‘s1 âˆ© â†‘s2 = âˆ…) : s1.direction âŠ” s2.direction < (s1 âŠ” s2).direction
theorem category_theory.equivalence.unit_inverse_comp {C : Type uâ‚} [category_theory.category C] {D : Type uâ‚‚} [category_theory.category D] (e : C â‰Œ D) (Y : D) : e.unit.app (e.inverse.obj Y) â‰« e.inverse.map (e.counit.app Y) = ğŸ™ (e.inverse.obj Y)
theorem eq.trans_gt {Î± : Type u} [preorder Î±] {a b c : Î±} : b = c â†’ a < b â†’ a < c
theorem module.free.finrank_eq_rank (R : Type u) (M : Type v) [ring R] [strong_rank_condition R] [add_comm_group M] [module R M] [module.free R M] [module.finite R M] : â†‘(finite_dimensional.finrank R M) = module.rank R M
theorem continuous_map.exists_restrict_eq_forall_mem_of_closed {Y : Type u_2} [topological_space Y] [normal_space Y] {s : set Y} (f : C(â†¥s, â„)) {t : set â„} [t.ord_connected] (ht : âˆ€ (x : â†¥s), â‡‘f x âˆˆ t) (hne : t.nonempty) (hs : is_closed s) : âˆƒ (g : C(Y, â„)), (âˆ€ (y : Y), â‡‘g y âˆˆ t) âˆ§ continuous_map.restrict s g = f
theorem ereal.continuous_at_add {p : ereal Ã— ereal} (h : p.fst â‰  âŠ¤ âˆ¨ p.snd â‰  âŠ¥) (h' : p.fst â‰  âŠ¥ âˆ¨ p.snd â‰  âŠ¤) : continuous_at (Î» (p : ereal Ã— ereal), p.fst + p.snd) p
theorem tendsto_uniformly_on.comp {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} {Î¹ : Type u_4} [uniform_space Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : set Î±} {p : filter Î¹} (h : tendsto_uniformly_on F f p s) (g : Î³ â†’ Î±) : tendsto_uniformly_on (Î» (n : Î¹), F n âˆ˜ g) (f âˆ˜ g) p (g â»Â¹' s)
theorem dense_compl_singleton {Î± : Type u} [topological_space Î±] (x : Î±) [(nhds_within x {x}á¶œ).ne_bot] : dense {x}á¶œ
theorem fin.snoc_init_self {n : â„•} {Î± : fin (n + 1) â†’ Type u} (q : Î  (i : fin (n + 1)), Î± i) : fin.snoc (fin.init q) (q (fin.last n)) = q
theorem algebra.smul_mul_assoc {R : Type u} {A : Type w} [comm_semiring R] [semiring A] [algebra R A] (r : R) (x y : A) : r â€¢ x * y = r â€¢ (x * y)
theorem not_small_ordinal  : Â¬small ordinal
theorem metric.closure_eq_Inter_cthickening {Î± : Type u} [pseudo_emetric_space Î±] (E : set Î±) : closure E = â‹‚ (Î´ : â„) (h : 0 < Î´), metric.cthickening Î´ E
theorem strict_convex_on.neg {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [ordered_semiring ğ•œ] [add_comm_monoid E] [ordered_add_comm_group Î²] [has_scalar ğ•œ E] [module ğ•œ Î²] {s : set E} {f : E â†’ Î²} : strict_convex_on ğ•œ s f â†’ strict_concave_on ğ•œ s (-f)
theorem submodule.finrank_lt {K : Type u} {V : Type v} [field K] [add_comm_group V] [module K V] [finite_dimensional K V] {s : submodule K V} (h : s < âŠ¤) : finite_dimensional.finrank K â†¥s < finite_dimensional.finrank K V
theorem measure_theory.continuous_map.inner_to_Lp {Î± : Type u_1} [topological_space Î±] [measure_theory.measure_space Î±] [borel_space Î±] {ğ•œ : Type u_2} [is_R_or_C ğ•œ] (Î¼ : measure_theory.measure Î±) [measure_theory.is_finite_measure Î¼] [compact_space Î±] (f g : C(Î±, ğ•œ)) : has_inner.inner (â‡‘(continuous_map.to_Lp 2 Î¼ ğ•œ) f) (â‡‘(continuous_map.to_Lp 2 Î¼ ğ•œ) g) = âˆ« (x : Î±), â‡‘(star_ring_end ğ•œ) (â‡‘f x) * â‡‘g x âˆ‚Î¼
theorem eq_of_has_deriv_right_eq {E : Type u_1} [normed_group E] [normed_space â„ E] {f : â„ â†’ E} {a b : â„} {f' g : â„ â†’ E} (derivf : âˆ€ (x : â„), x âˆˆ set.Ico a b â†’ has_deriv_within_at f (f' x) (set.Ici x) x) (derivg : âˆ€ (x : â„), x âˆˆ set.Ico a b â†’ has_deriv_within_at g (f' x) (set.Ici x) x) (fcont : continuous_on f (set.Icc a b)) (gcont : continuous_on g (set.Icc a b)) (hi : f a = g a) (y : â„) (H : y âˆˆ set.Icc a b) : f y = g y
theorem orientation.oangle_eq_pi_sub_two_zsmul_oangle_sub_of_norm_eq {V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) {x y : V} (hn : x â‰  y) (h : âˆ¥xâˆ¥ = âˆ¥yâˆ¥) : o.oangle y x = â†‘real.pi - 2 â€¢ o.oangle (y - x) y
theorem add_is_add_right_regular_iff {R : Type u_1} {a : R} [add_semigroup R] (b : R) (ha : is_add_right_regular a) : is_add_right_regular (b + a) â†” is_add_right_regular b
theorem summable.tendsto_cofinite_zero {Î± : Type u_1} {G : Type u_5} [topological_space G] [add_comm_group G] [topological_add_group G] {f : Î± â†’ G} (hf : summable f) : filter.tendsto f filter.cofinite (nhds 0)
theorem complex.integral_boundary_rect_of_differentiable_on_real {E : Type u} [normed_group E] [normed_space â„‚ E] [complete_space E] (f : â„‚ â†’ E) (z w : â„‚) (Hd : differentiable_on â„ f (set.interval z.re w.re Ã—â„‚ set.interval z.im w.im)) (Hi : measure_theory.integrable_on (Î» (z : â„‚), complex.I â€¢ â‡‘(fderiv â„ f z) 1 - â‡‘(fderiv â„ f z) complex.I) (set.interval z.re w.re Ã—â„‚ set.interval z.im w.im) measure_theory.measure_space.volume) : (((âˆ« (x : â„) in z.re..w.re, f (â†‘x + â†‘(z.im) * complex.I)) - âˆ« (x : â„) in z.re..w.re, f (â†‘x + â†‘(w.im) * complex.I)) + complex.I â€¢ âˆ« (y : â„) in z.im..w.im, f (â†‘(w.re) + â†‘y * complex.I)) - complex.I â€¢ âˆ« (y : â„) in z.im..w.im, f (â†‘(z.re) + â†‘y * complex.I) = âˆ« (x : â„) in z.re..w.re, âˆ« (y : â„) in z.im..w.im, complex.I â€¢ â‡‘(fderiv â„ f (â†‘x + â†‘y * complex.I)) 1 - â‡‘(fderiv â„ f (â†‘x + â†‘y * complex.I)) complex.I
theorem finite_dimensional_of_is_compact_closed_ball (ğ•œ : Type u) [nondiscrete_normed_field ğ•œ] {E : Type v} [normed_group E] [normed_space ğ•œ E] [complete_space ğ•œ] {r : â„} (rpos : 0 < r) {c : E} (h : is_compact (metric.closed_ball c r)) : finite_dimensional ğ•œ E
theorem is_add_group_hom.injective_iff {Î± : Type u} {Î² : Type v} [add_group Î±] [add_group Î²] {f : Î± â†’ Î²} (hf : is_add_group_hom f) : function.injective f â†” âˆ€ (a : Î±), f a = 0 â†’ a = 0
theorem uniformity_dist_of_mem_uniformity {Î± : Type u} {Î² : Type v} [linear_order Î²] {U : filter (Î± Ã— Î±)} (z : Î²) (D : Î± â†’ Î± â†’ Î²) (H : âˆ€ (s : set (Î± Ã— Î±)), s âˆˆ U â†” âˆƒ (Îµ : Î²) (H : Îµ > z), âˆ€ {a b : Î±}, D a b < Îµ â†’ (a, b) âˆˆ s) : U = â¨… (Îµ : Î²) (H : Îµ > z), filter.principal {p : Î± Ã— Î± | D p.fst p.snd < Îµ}
theorem monovary.sum_comp_perm_smul_le_sum_smul {Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [linear_ordered_ring Î±] [linear_ordered_add_comm_group Î²] [module Î± Î²] [ordered_smul Î± Î²] {Ïƒ : equiv.perm Î¹} {f : Î¹ â†’ Î±} {g : Î¹ â†’ Î²} [fintype Î¹] (hfg : monovary f g) : finset.univ.sum (Î» (i : Î¹), f (â‡‘Ïƒ i) â€¢ g i) â‰¤ finset.univ.sum (Î» (i : Î¹), f i â€¢ g i)
theorem nat.exists_lt_and_lt_iff_not_dvd (m : â„•) {n : â„•} (hn : 0 < n) : (âˆƒ (k : â„•), n * k < m âˆ§ m < n * (k + 1)) â†” Â¬n âˆ£ m
theorem iterated_deriv_within_eq_equiv_comp {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {F : Type u_2} [normed_group F] [normed_space ğ•œ F] {n : â„•} {f : ğ•œ â†’ F} {s : set ğ•œ} : iterated_deriv_within n f s = â‡‘((continuous_multilinear_map.pi_field_equiv ğ•œ (fin n) F).symm) âˆ˜ iterated_fderiv_within ğ•œ n f s
theorem preimage_interior_subset_interior_preimage {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] {f : Î± â†’ Î²} {s : set Î²} (hf : continuous f) : f â»Â¹' interior s âŠ† interior (f â»Â¹' s)
theorem tsum_ite_eq_extract {Î± : Type u_1} {Î² : Type u_2} [add_comm_group Î±] [topological_space Î±] [topological_add_group Î±] {f : Î² â†’ Î±} [t2_space Î±] [decidable_eq Î²] (hf : summable f) (b : Î²) : âˆ‘' (n : Î²), f n = f b + âˆ‘' (n : Î²), ite (n = b) 0 (f n)
theorem polynomial.monic_X_pow_sub_C {R : Type u} [ring R] (a : R) {n : â„•} (h : n â‰  0) : (polynomial.X ^ n - â‡‘polynomial.C a).monic
theorem generalized_continued_fraction.succ_nth_fib_le_of_nth_denom {K : Type u_1} {v : K} {n : â„•} [linear_ordered_field K] [floor_ring K] (hyp : n = 0 âˆ¨ Â¬(generalized_continued_fraction.of v).terminated_at (n - 1)) : â†‘(nat.fib (n + 1)) â‰¤ (generalized_continued_fraction.of v).denominators n
theorem map_supr_of_continuous_at_of_monotone {Î± : Type u} {Î² : Type v} [complete_linear_order Î±] [topological_space Î±] [order_topology Î±] [complete_linear_order Î²] [topological_space Î²] [order_topology Î²] {Î¹ : Sort u_1} {f : Î± â†’ Î²} {g : Î¹ â†’ Î±} (Cf : continuous_at f (supr g)) (Mf : monotone f) (fbot : f âŠ¥ = âŠ¥) : f (â¨† (i : Î¹), g i) = â¨† (i : Î¹), f (g i)
theorem concave_on_univ_of_deriv2_nonpos {f : â„ â†’ â„} (hf' : differentiable â„ f) (hf'' : differentiable â„ (deriv f)) (hf''_nonpos : âˆ€ (x : â„), deriv^[2] f x â‰¤ 0) : concave_on â„ set.univ f
theorem category_theory.functor_skeletal {C : Type uâ‚} [category_theory.category C] {D : Type uâ‚‚} [category_theory.category D] [âˆ€ (X Y : C), subsingleton (X âŸ¶ Y)] (hC : category_theory.skeletal C) : category_theory.skeletal (D â¥¤ C)
theorem ratfunc.induction_on' {K : Type u} [hring : comm_ring K] [hdomain : is_domain K] {P : ratfunc K â†’ Prop} (x : ratfunc K) (f : âˆ€ (p q : polynomial K), q â‰  0 â†’ P (ratfunc.mk p q)) : P x
theorem submodule.supr_eq_range_dfinsupp_lsum {Î¹ : Type u_1} {R : Type u_2} {N : Type u_5} [dec_Î¹ : decidable_eq Î¹] [semiring R] [add_comm_monoid N] [module R N] (p : Î¹ â†’ submodule R N) : supr p = (â‡‘(dfinsupp.lsum â„•) (Î» (i : Î¹), (p i).subtype)).range
theorem refl_trans_gen_of_succ_of_ge {Î± : Type u_1} [partial_order Î±] [succ_order Î±] [is_succ_archimedean Î±] (r : Î± â†’ Î± â†’ Prop) {n m : Î±} (h : âˆ€ (i : Î±), i âˆˆ set.Ico m n â†’ r (order.succ i) i) (hmn : m â‰¤ n) : relation.refl_trans_gen r n m
theorem urysohns.CU.continuous_lim {X : Type u_1} [topological_space X] [normal_space X] (c : urysohns.CU X) : continuous c.lim
theorem fintype.exists_le_card_fiber_of_mul_le_card {Î± : Type u} {Î² : Type v} [decidable_eq Î²] [fintype Î±] [fintype Î²] (f : Î± â†’ Î²) {n : â„•} [nonempty Î²] (hn : fintype.card Î² * n â‰¤ fintype.card Î±) : âˆƒ (y : Î²), n â‰¤ (finset.filter (Î» (x : Î±), f x = y) finset.univ).card
theorem real.coe_fib_eq'  : (Î» (n : â„•), â†‘(nat.fib n)) = Î» (n : â„•), (golden_ratio ^ n - golden_conj ^ n) / real.sqrt 5
theorem inducing.is_open_map {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] {f : Î± â†’ Î²} (hi : inducing f) (ho : is_open (set.range f)) : is_open_map f
theorem filter.map_coe_Iio_at_bot {Î± : Type u_3} [semilattice_inf Î±] [no_min_order Î±] (a : Î±) : filter.map coe filter.at_bot = filter.at_bot
theorem measure_theory.mem_â„’p.induction_strongly_measurable {Î± : Type u_1} {F : Type u_6} {p : ennreal} [normed_group F] {m m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [fact (1 â‰¤ p)] [normed_space â„ F] (hm : m â‰¤ m0) (hp_ne_top : p â‰  âŠ¤) (P : (Î± â†’ F) â†’ Prop) (h_ind : âˆ€ (c : F) â¦ƒs : set Î±â¦„, measurable_set s â†’ â‡‘Î¼ s < âŠ¤ â†’ P (s.indicator (Î» (_x : Î±), c))) (h_add : âˆ€ â¦ƒf g : Î± â†’ Fâ¦„, disjoint (function.support f) (function.support g) â†’ measure_theory.mem_â„’p f p Î¼ â†’ measure_theory.mem_â„’p g p Î¼ â†’ measure_theory.strongly_measurable f â†’ measure_theory.strongly_measurable g â†’ P f â†’ P g â†’ P (f + g)) (h_closed : is_closed {f : â†¥(measure_theory.Lp_meas F â„ m p Î¼) | P â‡‘f}) (h_ae : âˆ€ â¦ƒf g : Î± â†’ Fâ¦„, f =áµ[Î¼] g â†’ measure_theory.mem_â„’p f p Î¼ â†’ P f â†’ P g) â¦ƒf : Î± â†’ Fâ¦„ (hf : measure_theory.mem_â„’p f p Î¼) (hfm : measure_theory.ae_strongly_measurable' m f Î¼) : P f
theorem nilpotent_of_mul_equiv {G : Type u_1} [group G] {G' : Type u_2} [group G'] [h : group.is_nilpotent G] (f : G â‰ƒ* G') : group.is_nilpotent G'
theorem minpoly.eq_X_sub_C {A : Type u_1} (B : Type u_2) [field A] [ring B] [algebra A B] [nontrivial B] (a : A) : minpoly A (â‡‘(algebra_map A B) a) = polynomial.X - â‡‘polynomial.C a
theorem emetric.Hausdorff_edist_le_of_mem_edist {Î± : Type u} [pseudo_emetric_space Î±] {s t : set Î±} {r : ennreal} (H1 : âˆ€ (x : Î±), x âˆˆ s â†’ (âˆƒ (y : Î±) (H : y âˆˆ t), has_edist.edist x y â‰¤ r)) (H2 : âˆ€ (x : Î±), x âˆˆ t â†’ (âˆƒ (y : Î±) (H : y âˆˆ s), has_edist.edist x y â‰¤ r)) : emetric.Hausdorff_edist s t â‰¤ r
theorem polynomial.eval_list_prod {R : Type u} [comm_semiring R] (l : list (polynomial R)) (x : R) : polynomial.eval x l.prod = (list.map (polynomial.eval x) l).prod
theorem tangent_bundle_model_space_chart_at {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {H : Type u_3} [topological_space H] (I : model_with_corners ğ•œ E H) (p : tangent_bundle I H) : (charted_space.chart_at (model_prod H E) p).to_local_equiv = (equiv.sigma_equiv_prod H E).to_local_equiv
theorem complex.liouville_theorem_aux {F : Type v} [normed_group F] [normed_space â„‚ F] {f : â„‚ â†’ F} (hf : differentiable â„‚ f) (hb : metric.bounded (set.range f)) (z w : â„‚) : f z = f w
theorem matrix.is_hermitian_diagonal {n : Type u_4} [decidable_eq n] (v : n â†’ â„) : (matrix.diagonal v).is_hermitian
theorem category_theory.comp_cover_lifting {C : Type u_1} [category_theory.category C] {D : Type u_3} [category_theory.category D] {E : Type u_5} [category_theory.category E] {J : category_theory.grothendieck_topology C} {K : category_theory.grothendieck_topology D} {L : category_theory.grothendieck_topology E} {F : C â¥¤ D} (hu : category_theory.cover_lifting J K F) {G : D â¥¤ E} (hv : category_theory.cover_lifting K L G) : category_theory.cover_lifting J L (F â‹™ G)
theorem measure_theory.simple_func.measurable {Î± : Type u_1} {Î² : Type u_2} [measurable_space Î±] [measurable_space Î²] (f : measure_theory.simple_func Î± Î²) : measurable â‡‘f
theorem category_theory.frobenius_morphism_iso_of_exp_comparison_iso {C : Type u} [category_theory.category C] {D : Type u'} [category_theory.category D] [category_theory.limits.has_finite_products C] [category_theory.limits.has_finite_products D] (F : C â¥¤ D) {L : D â¥¤ C} [category_theory.cartesian_closed C] [category_theory.cartesian_closed D] [category_theory.limits.preserves_limits_of_shape (category_theory.discrete category_theory.limits.walking_pair) F] (h : L âŠ£ F) (A : C) [i : category_theory.is_iso (category_theory.exp_comparison F A)] : category_theory.is_iso (category_theory.frobenius_morphism F h A)
theorem nat.fib_add_two_strict_mono  : strict_mono (Î» (n : â„•), nat.fib (n + 2))
theorem mul_equiv.map_mul {M : Type u_6} {N : Type u_7} [has_mul M] [has_mul N] (f : M â‰ƒ* N) (x y : M) : â‡‘f (x * y) = â‡‘f x * â‡‘f y
theorem matrix.is_diag_zero {Î± : Type u_1} {n : Type u_4} [has_zero Î±] : 0.is_diag
theorem representation.average_map_invariant {k : Type u_1} {G : Type u_2} {V : Type u_3} [comm_semiring k] [group G] [add_comm_monoid V] [module k V] (Ï : representation k G V) [fintype G] [invertible â†‘(fintype.card G)] (v : V) : â‡‘(Ï.average_map) v âˆˆ Ï.invariants
theorem finset.prod_add_prod_eq {Î² : Type u} {Î± : Type v} [comm_semiring Î²] {s : finset Î±} {i : Î±} {f g h : Î± â†’ Î²} (hi : i âˆˆ s) (h1 : g i + h i = f i) (h2 : âˆ€ (j : Î±), j âˆˆ s â†’ j â‰  i â†’ g j = f j) (h3 : âˆ€ (j : Î±), j âˆˆ s â†’ j â‰  i â†’ h j = f j) : s.prod (Î» (i : Î±), g i) + s.prod (Î» (i : Î±), h i) = s.prod (Î» (i : Î±), f i)
theorem finset.mem_powerset_len {Î± : Type u_1} {n : â„•} {s t : finset Î±} : s âˆˆ finset.powerset_len n t â†” s âŠ† t âˆ§ s.card = n
theorem set.Union_eq_Union_finset {Î± : Type u_1} {Î¹ : Type u_4} (s : Î¹ â†’ set Î±) : (â‹ƒ (i : Î¹), s i) = â‹ƒ (t : finset Î¹) (i : Î¹) (H : i âˆˆ t), s i
theorem phragmen_lindelof.is_O_sub_exp_exp {E : Type u_1} [normed_group E] {a : â„} {f g : â„‚ â†’ E} {l : filter â„‚} {u : â„‚ â†’ â„} (hBf : âˆƒ (c : â„) (H : c < a) (B : â„), f =O[l] Î» (z : â„‚), real.exp (B * real.exp (c * |u z|))) (hBg : âˆƒ (c : â„) (H : c < a) (B : â„), g =O[l] Î» (z : â„‚), real.exp (B * real.exp (c * |u z|))) : âˆƒ (c : â„) (H : c < a) (B : â„), (f - g) =O[l] Î» (z : â„‚), real.exp (B * real.exp (c * |u z|))
theorem exponent_exists.is_add_torsion {G : Type u_1} [add_group G] (h : add_monoid.exponent_exists G) : add_monoid.is_torsion G
theorem bounded_continuous_function.arzela_ascoliâ‚ {Î± : Type u} {Î² : Type v} [topological_space Î±] [compact_space Î±] [pseudo_metric_space Î²] [compact_space Î²] (A : set (bounded_continuous_function Î± Î²)) (closed : is_closed A) (H : âˆ€ (x : Î±) (Îµ : â„), Îµ > 0 â†’ (âˆƒ (U : set Î±) (H : U âˆˆ nhds x), âˆ€ (y : Î±), y âˆˆ U â†’ âˆ€ (z : Î±), z âˆˆ U â†’ âˆ€ (f : bounded_continuous_function Î± Î²), f âˆˆ A â†’ has_dist.dist (â‡‘f y) (â‡‘f z) < Îµ)) : is_compact A
theorem quotient.induction_onâ‚ƒ' {Î± : Sort u_1} {Î² : Sort u_2} {Î³ : Sort u_3} {sâ‚ : setoid Î±} {sâ‚‚ : setoid Î²} {sâ‚ƒ : setoid Î³} {p : quotient sâ‚ â†’ quotient sâ‚‚ â†’ quotient sâ‚ƒ â†’ Prop} (qâ‚ : quotient sâ‚) (qâ‚‚ : quotient sâ‚‚) (qâ‚ƒ : quotient sâ‚ƒ) (h : âˆ€ (aâ‚ : Î±) (aâ‚‚ : Î²) (aâ‚ƒ : Î³), p (quotient.mk' aâ‚) (quotient.mk' aâ‚‚) (quotient.mk' aâ‚ƒ)) : p qâ‚ qâ‚‚ qâ‚ƒ
theorem is_scalar_tower.of_algebra_map_eq' {R : Type u} {S : Type v} {A : Type w} [comm_semiring R] [comm_semiring S] [semiring A] [algebra R S] [algebra S A] [algebra R A] (h : algebra_map R A = (algebra_map S A).comp (algebra_map R S)) : is_scalar_tower R S A
theorem int.zpow_le_iff_le_log {R : Type u_1} [linear_ordered_field R] [floor_ring R] {b : â„•} (hb : 1 < b) {x : â„¤} {r : R} (hr : 0 < r) : â†‘b ^ x â‰¤ r â†” x â‰¤ int.log b r
theorem submodule.exists_sum_mem_mem_orthogonal {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] (K : submodule ğ•œ E) [complete_space â†¥K] (v : E) : âˆƒ (y : E) (H : y âˆˆ K) (z : E) (H : z âˆˆ Ká—®), v = y + z
theorem mul_hom.eq_on_mclosure {M : Type u_1} {N : Type u_2} [has_mul M] [has_mul N] {f g : M â†’â‚™* N} {s : set M} (h : set.eq_on â‡‘f â‡‘g s) : set.eq_on â‡‘f â‡‘g â†‘(subsemigroup.closure s)
theorem local_homeomorph.has_strict_fderiv_at_symm {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] (f : local_homeomorph E F) {f' : E â‰ƒL[ğ•œ] F} {a : F} (ha : a âˆˆ f.to_local_equiv.target) (htff' : has_strict_fderiv_at â‡‘f â†‘f' (â‡‘(f.symm) a)) : has_strict_fderiv_at â‡‘(f.symm) â†‘(f'.symm) a
theorem convex_independent.mono {ğ•œ : Type u_1} {E : Type u_2} [ordered_semiring ğ•œ] [add_comm_group E] [module ğ•œ E] {s t : set E} (hc : convex_independent ğ•œ (Î» (x : â†¥t), â†‘x)) (hs : s âŠ† t) : convex_independent ğ•œ (Î» (x : â†¥s), â†‘x)
theorem category_theory.abelian.epi_fst_of_factor_thru_epi_mono_factorization {C : Type u} [category_theory.category C] [category_theory.abelian C] [category_theory.limits.has_pullbacks C] {W X Y Z : C} (f : X âŸ¶ Z) (g : Y âŸ¶ Z) (gâ‚ : Y âŸ¶ W) [category_theory.epi gâ‚] (gâ‚‚ : W âŸ¶ Z) [category_theory.mono gâ‚‚] (hg : gâ‚ â‰« gâ‚‚ = g) (f' : X âŸ¶ W) (hf : f' â‰« gâ‚‚ = f) (t : category_theory.limits.pullback_cone f g) (ht : category_theory.limits.is_limit t) : category_theory.epi t.fst
theorem exists_open_singleton_of_open_finite {Î± : Type u} [topological_space Î±] [t0_space Î±] {s : set Î±} (hfin : s.finite) (hne : s.nonempty) (ho : is_open s) : âˆƒ (x : Î±) (H : x âˆˆ s), is_open {x}
theorem equiv.perm.swap_induction_on' {Î± : Type u} [decidable_eq Î±] [fintype Î±] {P : equiv.perm Î± â†’ Prop} (f : equiv.perm Î±) : P 1 â†’ (âˆ€ (f : equiv.perm Î±) (x y : Î±), x â‰  y â†’ P f â†’ P (f * equiv.swap x y)) â†’ P f
theorem local_homeomorph.is_image.of_preimage_eq' {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] {e : local_homeomorph Î± Î²} {s : set Î±} {t : set Î²} : e.to_local_equiv.source âˆ© â‡‘e â»Â¹' (e.to_local_equiv.target âˆ© t) = e.to_local_equiv.source âˆ© s â†’ e.is_image s t
theorem coe_coe {Î± : Sort u_1} {Î² : Sort u_2} {Î³ : Sort u_3} [has_coe Î± Î²] [has_coe_t Î² Î³] (a : Î±) : â†‘a = â†‘â†‘a
theorem metric.inf_dist_empty {Î± : Type u} [pseudo_metric_space Î±] {x : Î±} : metric.inf_dist x âˆ… = 0
theorem exists_nat_pow_near {Î± : Type u_1} [linear_ordered_ring Î±] [archimedean Î±] {x y : Î±} (hx : 1 â‰¤ x) (hy : 1 < y) : âˆƒ (n : â„•), y ^ n â‰¤ x âˆ§ x < y ^ (n + 1)
theorem measure_theory.Lp_meas_to_Lp_trim_lie_symm_indicator {Î± : Type u_1} {F : Type u_6} {p : ennreal} [normed_group F] {m m0 : measurable_space Î±} [one_le_p : fact (1 â‰¤ p)] [normed_space â„ F] {hm : m â‰¤ m0} {s : set Î±} {Î¼ : measure_theory.measure Î±} (hs : measurable_set s) (hÎ¼s : â‡‘(Î¼.trim hm) s â‰  âŠ¤) (c : F) : â†‘(â‡‘((measure_theory.Lp_meas_to_Lp_trim_lie F â„ p Î¼ hm).symm) (measure_theory.indicator_const_Lp p hs hÎ¼s c)) = measure_theory.indicator_const_Lp p _ _ c
theorem finprod_mem_range' {Î± : Type u_1} {Î² : Type u_2} {M : Type u_5} [comm_monoid M] {f : Î± â†’ M} {g : Î² â†’ Î±} (hg : set.inj_on g (function.mul_support (f âˆ˜ g))) : finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ set.range g), f i)) = finprod (Î» (j : Î²), f (g j))
theorem is_noetherian.dim_lt_aleph_0 (K : Type u) (V : Type v) [division_ring K] [add_comm_group V] [module K V] [is_noetherian K V] : module.rank K V < cardinal.aleph_0
theorem fermat_42.minimal_comm {a b c : â„¤} : fermat_42.minimal a b c â†’ fermat_42.minimal b a c
theorem strict_convex_space.of_norm_add_lt {E : Type u_2} [normed_group E] [normed_space â„ E] {a b : â„} (ha : 0 < a) (hb : 0 < b) (hab : a + b = 1) (h : âˆ€ (x y : E), âˆ¥xâˆ¥ â‰¤ 1 â†’ âˆ¥yâˆ¥ â‰¤ 1 â†’ x â‰  y â†’ âˆ¥a â€¢ x + b â€¢ yâˆ¥ < 1) : strict_convex_space â„ E
theorem complex.cos_add_sin_mul_I_pow (n : â„•) (z : â„‚) : (complex.cos z + complex.sin z * complex.I) ^ n = complex.cos (â†‘n * z) + complex.sin (â†‘n * z) * complex.I
theorem category_theory.colimit_adj.restrict_yoneda_hom_equiv_natural {C : Type uâ‚} [category_theory.small_category C] {â„° : Type uâ‚‚} [category_theory.category â„°] (A : C â¥¤ â„°) (P : Cáµ’áµ– â¥¤ Type uâ‚) (Eâ‚ Eâ‚‚ : â„°) (g : Eâ‚ âŸ¶ Eâ‚‚) {c : category_theory.limits.cocone ((category_theory.category_of_elements.Ï€ P).left_op â‹™ A)} (t : category_theory.limits.is_colimit c) (k : c.X âŸ¶ Eâ‚) : â‡‘(category_theory.colimit_adj.restrict_yoneda_hom_equiv A P Eâ‚‚ t) (k â‰« g) = â‡‘(category_theory.colimit_adj.restrict_yoneda_hom_equiv A P Eâ‚ t) k â‰« (category_theory.colimit_adj.restricted_yoneda A).map g
theorem homotopy.comp_null_homotopic_map' {Î¹ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape Î¹} {C D E : homological_complex V c} (f : C âŸ¶ D) (hom : Î  (i j : Î¹), c.rel j i â†’ (D.X i âŸ¶ E.X j)) : f â‰« homotopy.null_homotopic_map' hom = homotopy.null_homotopic_map' (Î» (i j : Î¹) (hij : c.rel j i), f.f i â‰« hom i j hij)
theorem category_theory.limits.braid_natural {C : Type u} [category_theory.category C] [category_theory.limits.has_binary_products C] {W X Y Z : C} (f : X âŸ¶ Y) (g : Z âŸ¶ W) : category_theory.limits.prod.map f g â‰« (category_theory.limits.prod.braiding Y W).hom = (category_theory.limits.prod.braiding X Z).hom â‰« category_theory.limits.prod.map g f
theorem first_order.language.elementary_embedding.comp_assoc {L : first_order.language} {M : Type u_3} {N : Type u_4} {P : Type u_5} {Q : Type u_6} [L.Structure M] [L.Structure N] [L.Structure P] [L.Structure Q] (f : L.elementary_embedding M N) (g : L.elementary_embedding N P) (h : L.elementary_embedding P Q) : (h.comp g).comp f = h.comp (g.comp f)
theorem emetric.subset_countable_closure_of_almost_dense_set {Î± : Type u} [pseudo_emetric_space Î±] (s : set Î±) (hs : âˆ€ (Îµ : ennreal), Îµ > 0 â†’ (âˆƒ (t : set Î±), t.countable âˆ§ s âŠ† â‹ƒ (x : Î±) (H : x âˆˆ t), emetric.closed_ball x Îµ)) : âˆƒ (t : set Î±) (H : t âŠ† s), t.countable âˆ§ s âŠ† closure t
theorem ideal.exists_le_maximal {Î± : Type u} [semiring Î±] (I : ideal Î±) (hI : I â‰  âŠ¤) : âˆƒ (M : ideal Î±), M.is_maximal âˆ§ I â‰¤ M
theorem linear_map.is_unit_det {M : Type u_2} [add_comm_group M] {A : Type u_1} [comm_ring A] [module A M] (f : M â†’â‚—[A] M) (hf : is_unit f) : is_unit (â‡‘linear_map.det f)
theorem direction_affine_span (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P) : (affine_span k s).direction = vector_span k s
theorem is_max.eq_top {Î± : Type u} [partial_order Î±] [order_top Î±] {a : Î±} : is_max a â†’ a = âŠ¤
theorem edist_le_tsum_of_edist_le_of_tendstoâ‚€ {Î± : Type u_1} [pseudo_emetric_space Î±] {f : â„• â†’ Î±} (d : â„• â†’ ennreal) (hf : âˆ€ (n : â„•), has_edist.edist (f n) (f n.succ) â‰¤ d n) {a : Î±} (ha : filter.tendsto f filter.at_top (nhds a)) : has_edist.edist (f 0) a â‰¤ âˆ‘' (m : â„•), d m
theorem is_compact_of_finite_subcover {Î± : Type u} [topological_space Î±] {s : set Î±} (h : âˆ€ {Î¹ : Type u} (U : Î¹ â†’ set Î±), (âˆ€ (i : Î¹), is_open (U i)) â†’ (s âŠ† â‹ƒ (i : Î¹), U i) â†’ (âˆƒ (t : finset Î¹), s âŠ† â‹ƒ (i : Î¹) (H : i âˆˆ t), U i)) : is_compact s
theorem intermediate_field.sub_mem {K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) {x y : L} : x âˆˆ S â†’ y âˆˆ S â†’ x - y âˆˆ S
theorem function.periodic.interval_integral_add_eq_of_pos {E : Type u_1} [normed_group E] [normed_space â„ E] [complete_space E] {f : â„ â†’ E} {T : â„} (hf : function.periodic f T) (hT : 0 < T) (t s : â„) : âˆ« (x : â„) in t..t + T, f x = âˆ« (x : â„) in s..s + T, f x
theorem add_subgroup.sub_mem {G : Type u_1} [add_group G] (H : add_subgroup G) {x y : G} (hx : x âˆˆ H) (hy : y âˆˆ H) : x - y âˆˆ H
theorem subadditive.tendsto_lim {u : â„• â†’ â„} (h : subadditive u) (hbdd : bdd_below (set.range (Î» (n : â„•), u n / â†‘n))) : filter.tendsto (Î» (n : â„•), u n / â†‘n) filter.at_top (nhds h.lim)
theorem add_monoid_hom.map_finsum_mem' {Î± : Type u_1} {M : Type u_5} {N : Type u_6} [add_comm_monoid M] [add_comm_monoid N] {s : set Î±} {f : Î± â†’ M} (g : M â†’+ N) (hâ‚€ : (s âˆ© function.support f).finite) : â‡‘g (finsum (Î» (j : Î±), finsum (Î» (H : j âˆˆ s), f j))) = finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), â‡‘g (f i)))
theorem measure_theory.hahn_decomposition {Î± : Type u_1} [measurable_space Î±] {Î¼ Î½ : measure_theory.measure Î±} [measure_theory.is_finite_measure Î¼] [measure_theory.is_finite_measure Î½] : âˆƒ (s : set Î±), measurable_set s âˆ§ (âˆ€ (t : set Î±), measurable_set t â†’ t âŠ† s â†’ â‡‘Î½ t â‰¤ â‡‘Î¼ t) âˆ§ âˆ€ (t : set Î±), measurable_set t â†’ t âŠ† sá¶œ â†’ â‡‘Î¼ t â‰¤ â‡‘Î½ t
theorem order_bot.bdd_below {Î³ : Type w} [preorder Î³] [order_bot Î³] (s : set Î³) : bdd_below s
theorem metric.Hausdorff_dist_triangle {Î± : Type u} [pseudo_metric_space Î±] {s t u : set Î±} (fin : emetric.Hausdorff_edist s t â‰  âŠ¤) : metric.Hausdorff_dist s u â‰¤ metric.Hausdorff_dist s t + metric.Hausdorff_dist t u
theorem monovary_on.sum_comp_perm_smul_eq_sum_smul_iff {Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [linear_ordered_ring Î±] [linear_ordered_add_comm_group Î²] [module Î± Î²] [ordered_smul Î± Î²] {s : finset Î¹} {Ïƒ : equiv.perm Î¹} {f : Î¹ â†’ Î±} {g : Î¹ â†’ Î²} (hfg : monovary_on f g â†‘s) (hÏƒ : {x : Î¹ | â‡‘Ïƒ x â‰  x} âŠ† â†‘s) : s.sum (Î» (i : Î¹), f (â‡‘Ïƒ i) â€¢ g i) = s.sum (Î» (i : Î¹), f i â€¢ g i) â†” monovary_on (f âˆ˜ â‡‘Ïƒ) g â†‘s
theorem finset.le_sum_card {Î± : Type u_2} [decidable_eq Î±] {B : finset (finset Î±)} {n : â„•} [fintype Î±] (h : âˆ€ (a : Î±), n â‰¤ (finset.filter (has_mem.mem a) B).card) : fintype.card Î± * n â‰¤ B.sum (Î» (s : finset Î±), s.card)
theorem orientation.oangle_add_swap {V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) {x y z : V} (hx : x â‰  0) (hy : y â‰  0) (hz : z â‰  0) : o.oangle y z + o.oangle x y = o.oangle x z
theorem function.periodic.tendsto_at_top_interval_integral_of_pos' {T : â„} {g : â„ â†’ â„} (hg : function.periodic g T) (h_int : âˆ€ (tâ‚ tâ‚‚ : â„), interval_integrable g measure_theory.measure_space.volume tâ‚ tâ‚‚) (hâ‚€ : âˆ€ (x : â„), 0 < g x) (hT : 0 < T) : filter.tendsto (Î» (t : â„), âˆ« (x : â„) in 0..t, g x) filter.at_top filter.at_top
theorem finset.finite_to_set {Î± : Type u} (s : finset Î±) : â†‘s.finite
theorem unop_map_list_prod {M : Type u_3} {N : Type u_4} [monoid M] [monoid N] {F : Type u_1} [monoid_hom_class F M Náµáµ’áµ–] (f : F) (l : list M) : mul_opposite.unop (â‡‘f l.prod) = (list.map (mul_opposite.unop âˆ˜ â‡‘f) l).reverse.prod
theorem category_theory.limits.is_colimit.of_nat_iso.cocone_of_hom_fac {J : Type uâ‚} [category_theory.category J] {C : Type uâ‚ƒ} [category_theory.category C] {F : J â¥¤ C} {X : C} (h : category_theory.coyoneda.obj (opposite.op X) â‹™ category_theory.ulift_functor â‰… F.cocones) {Y : C} (f : X âŸ¶ Y) : category_theory.limits.is_colimit.of_nat_iso.cocone_of_hom h f = (category_theory.limits.is_colimit.of_nat_iso.colimit_cocone h).extend f
theorem finsupp.span_eq_range_total {M : Type u_2} (R : Type u_5) [semiring R] [add_comm_monoid M] [module R M] (s : set M) : submodule.span R s = (finsupp.total â†¥s M R coe).range
theorem map_nonunit {R : Type u} {S : Type v} [comm_semiring R] [local_ring R] [comm_semiring S] [local_ring S] (f : R â†’+* S) [is_local_ring_hom f] (a : R) (h : a âˆˆ local_ring.maximal_ideal R) : â‡‘f a âˆˆ local_ring.maximal_ideal S
theorem subsingleton_of_zero_eq_one {Mâ‚€ : Type u_1} [mul_zero_one_class Mâ‚€] : 0 = 1 â†’ subsingleton Mâ‚€
theorem list.nth_le_drop {Î± : Type u} (L : list Î±) {i j : â„•} (h : i + j < L.length) : L.nth_le (i + j) h = (list.drop i L).nth_le j _
theorem set.definable.image_comp {M : Type w} {A : set M} {L : first_order.language} [L.Structure M] {Î± : Type u_1} {Î² : Type u_2} {s : set (Î² â†’ M)} (h : A.definable L s) (f : Î± â†’ Î²) [fintype Î±] [fintype Î²] : A.definable L ((Î» (g : Î² â†’ M), g âˆ˜ f) '' s)
theorem cont_diff_within_at_fst {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {n : with_top â„•} {s : set (E Ã— F)} {p : E Ã— F} : cont_diff_within_at ğ•œ n prod.fst s p
theorem group.fg_iff {G : Type u_3} [group G] : group.fg G â†” âˆƒ (S : set G), subgroup.closure S = âŠ¤ âˆ§ S.finite
theorem differentiable_at.mdifferentiable_at {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {E' : Type u_3} [normed_group E'] [normed_space ğ•œ E'] {f : E â†’ E'} {x : E} : differentiable_at ğ•œ f x â†’ mdifferentiable_at (model_with_corners_self ğ•œ E) (model_with_corners_self ğ•œ E') f x
theorem linear_map.span_singleton_eq_range (R : Type u_1) (M : Type u_4) [semiring R] [add_comm_monoid M] [module R M] (x : M) : submodule.span R {x} = (linear_map.to_span_singleton R M x).range
theorem nat.even_pow {m n : â„•} : even (m ^ n) â†” even m âˆ§ n â‰  0
theorem linear_isometry_equiv.reflections_generate {F : Type u_3} [inner_product_space â„ F] [finite_dimensional â„ F] : subgroup.closure (set.range (Î» (v : F), reflection (submodule.span â„ {v})á—®)) = âŠ¤
theorem orientation.oangle_sub_eq_oangle_sub_rev_of_norm_eq {V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) {x y : V} (h : âˆ¥xâˆ¥ = âˆ¥yâˆ¥) : o.oangle x (x - y) = o.oangle (y - x) y
theorem ring.neg_one_ne_one_of_char_ne_two {R : Type u_1} [non_assoc_ring R] [nontrivial R] (hR : ring_char R â‰  2) : -1 â‰  1
theorem star_module.re_add_im {E : Type u_1} [add_comm_group E] [star_add_monoid E] [module â„‚ E] [star_module â„‚ E] (x : E) : â†‘(â‡‘star_module.re x) + complex.I â€¢ â†‘(â‡‘star_module.im x) = x
theorem left.inv_le_one_iff {Î± : Type u} [group Î±] [has_le Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a : Î±} : aâ»Â¹ â‰¤ 1 â†” 1 â‰¤ a
theorem cinfi_mono {Î± : Type u_1} {Î¹ : Sort u_3} [conditionally_complete_lattice Î±] {f g : Î¹ â†’ Î±} (B : bdd_below (set.range f)) (H : âˆ€ (x : Î¹), f x â‰¤ g x) : infi f â‰¤ infi g
theorem has_le.le.absolutely_continuous {Î± : Type u_1} {m0 : measurable_space Î±} {Î¼ Î½ : measure_theory.measure Î±} (h : Î¼ â‰¤ Î½) : Î¼.absolutely_continuous Î½
theorem finset.sum_card {Î± : Type u_2} [decidable_eq Î±] {B : finset (finset Î±)} {n : â„•} [fintype Î±] (h : âˆ€ (a : Î±), (finset.filter (has_mem.mem a) B).card = n) : B.sum (Î» (s : finset Î±), s.card) = fintype.card Î± * n
theorem power_series.coeff_order {R : Type u_1} [semiring R] {Ï† : power_series R} (h : Ï†.order.dom) : â‡‘(power_series.coeff R (Ï†.order.get h)) Ï† â‰  0
theorem local_equiv.eq_on_source.trans' {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} {e e' : local_equiv Î± Î²} {f f' : local_equiv Î² Î³} (he : e â‰ˆ e') (hf : f â‰ˆ f') : e.trans f â‰ˆ e'.trans f'
theorem lt_tsub_iff_left_of_le {Î± : Type u_1} [canonically_ordered_add_monoid Î±] [has_sub Î±] [has_ordered_sub Î±] {a b c : Î±} [contravariant_class Î± Î± has_add.add has_le.le] (h : c â‰¤ b) : a < b - c â†” c + a < b
theorem dense.diff_finite {Î± : Type u} [topological_space Î±] [t1_space Î±] [âˆ€ (x : Î±), (nhds_within x {x}á¶œ).ne_bot] {s : set Î±} (hs : dense s) {t : set Î±} (ht : t.finite) : dense (s  t)
theorem continuous_within_at_of_locally_uniform_approx_of_continuous_within_at {Î± : Type u_1} {Î² : Type u_2} [uniform_space Î²] {f : Î± â†’ Î²} {s : set Î±} {x : Î±} [topological_space Î±] (hx : x âˆˆ s) (L : âˆ€ (u : set (Î² Ã— Î²)), u âˆˆ uniformity Î² â†’ (âˆƒ (t : set Î±) (H : t âˆˆ nhds_within x s) (F : Î± â†’ Î²), continuous_within_at F s x âˆ§ âˆ€ (y : Î±), y âˆˆ t â†’ (f y, F y) âˆˆ u)) : continuous_within_at f s x
theorem weighted_vsub_mem_vector_span {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {Î¹ : Type u_4} {s : finset Î¹} {w : Î¹ â†’ k} (h : s.sum (Î» (i : Î¹), w i) = 0) (p : Î¹ â†’ P) : â‡‘(s.weighted_vsub p) w âˆˆ vector_span k (set.range p)
theorem neg_strict_concave_on_iff {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [ordered_semiring ğ•œ] [add_comm_monoid E] [ordered_add_comm_group Î²] [has_scalar ğ•œ E] [module ğ•œ Î²] {s : set E} {f : E â†’ Î²} : strict_concave_on ğ•œ s (-f) â†” strict_convex_on ğ•œ s f
theorem interval_integral.fderiv_integral_of_tendsto_ae {E : Type u_3} [normed_group E] [complete_space E] [normed_space â„ E] {f : â„ â†’ E} {ca cb : E} {a b : â„} (hf : interval_integrable f measure_theory.measure_space.volume a b) (hmeas_a : strongly_measurable_at_filter f (nhds a) measure_theory.measure_space.volume) (hmeas_b : strongly_measurable_at_filter f (nhds b) measure_theory.measure_space.volume) (ha : filter.tendsto f (nhds a âŠ“ measure_theory.measure_space.volume.ae) (nhds ca)) (hb : filter.tendsto f (nhds b âŠ“ measure_theory.measure_space.volume.ae) (nhds cb)) : fderiv â„ (Î» (p : â„ Ã— â„), âˆ« (x : â„) in p.fst..p.snd, f x) (a, b) = (continuous_linear_map.snd â„ â„ â„).smul_right cb - (continuous_linear_map.fst â„ â„ â„).smul_right ca
theorem zero_lt.right.mul_pos {Î± : Type u} {a b : Î±} [mul_zero_class Î±] [preorder Î±] [zero_lt.mul_pos_strict_mono Î±] (ha : 0 < a) (hb : 0 < b) : 0 < a * b
theorem left.add_neg_of_nonpos_of_neg {Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b : Î±} (ha : a â‰¤ 0) (hb : b < 0) : a + b < 0
theorem cSup_singleton {Î± : Type u_1} [conditionally_complete_lattice Î±] (a : Î±) : has_Sup.Sup {a} = a
theorem fintype.exists_sum_fiber_le_of_sum_le_nsmul {Î± : Type u} {Î² : Type v} {M : Type w} [decidable_eq Î²] [fintype Î±] [fintype Î²] (f : Î± â†’ Î²) {w : Î± â†’ M} {b : M} [linear_ordered_cancel_add_comm_monoid M] [nonempty Î²] (hb : finset.univ.sum (Î» (x : Î±), w x) â‰¤ fintype.card Î² â€¢ b) : âˆƒ (y : Î²), (finset.filter (Î» (x : Î±), f x = y) finset.univ).sum (Î» (x : Î±), w x) â‰¤ b
theorem mem_nhds_within_Ici_iff_exists_Icc_subset {Î± : Type u} [topological_space Î±] [linear_order Î±] [order_topology Î±] [no_max_order Î±] [densely_ordered Î±] {a : Î±} {s : set Î±} : s âˆˆ nhds_within a (set.Ici a) â†” âˆƒ (u : Î±), a < u âˆ§ set.Icc a u âŠ† s
theorem inner_product_space.of_core.inner_mul_inner_self_le {ğ•œ : Type u_1} {F : Type u_3} [is_R_or_C ğ•œ] [add_comm_group F] [module ğ•œ F] [c : inner_product_space.core ğ•œ F] (x y : F) : is_R_or_C.abs (has_inner.inner x y) * is_R_or_C.abs (has_inner.inner y x) â‰¤ â‡‘is_R_or_C.re (has_inner.inner x x) * â‡‘is_R_or_C.re (has_inner.inner y y)
theorem trans_gen_of_pred_of_reflexive {Î± : Type u_1} [linear_order Î±] [pred_order Î±] [is_pred_archimedean Î±] (r : Î± â†’ Î± â†’ Prop) {n m : Î±} (hr : reflexive r) (h1 : âˆ€ (i : Î±), i âˆˆ set.Ioc m n â†’ r i (order.pred i)) (h2 : âˆ€ (i : Î±), i âˆˆ set.Ioc n m â†’ r (order.pred i) i) : relation.trans_gen r n m
theorem matrix.det_unique {R : Type v} [comm_ring R] {n : Type u_1} [unique n] [decidable_eq n] [fintype n] (A : matrix n n R) : A.det = A inhabited.default inhabited.default
theorem category_theory.limits.is_iso_colimit_cocone_parallel_pair_of_eq {C : Type u} [category_theory.category C] {X Y : C} {f g : X âŸ¶ Y} (hâ‚€ : f = g) {c : category_theory.limits.cofork f g} (h : category_theory.limits.is_colimit c) : category_theory.is_iso c.Ï€
theorem real.add_one_le_exp_of_nonneg {x : â„} (hx : 0 â‰¤ x) : x + 1 â‰¤ real.exp x
theorem padic_norm.add_eq_max_of_ne (p : â„•) [hp : fact (nat.prime p)] {q r : â„š} (hne : padic_norm p q â‰  padic_norm p r) : padic_norm p (q + r) = linear_order.max (padic_norm p q) (padic_norm p r)
theorem geom_gold_conj_is_sol_fib_rec  : fib_rec.is_solution (has_pow.pow golden_conj)
theorem add_subgroup.norm_normed_mk {M : Type u_1} [semi_normed_group M] (S : add_subgroup M) (h : â†‘(S.topological_closure) â‰  set.univ) : âˆ¥S.normed_mkâˆ¥ = 1
theorem ascending_central_series_le_upper {G : Type u_1} [group G] (H : â„• â†’ subgroup G) (hH : is_ascending_central_series H) (n : â„•) : H n â‰¤ upper_central_series G n
theorem continuous_of_continuous_at_zero {G : Type w} [topological_space G] [add_group G] [topological_add_group G] {M : Type u_1} {hom : Type u_2} [add_zero_class M] [topological_space M] [has_continuous_add M] [add_monoid_hom_class hom G M] (f : hom) (hf : continuous_at â‡‘f 0) : continuous â‡‘f
theorem continuous_map.exists_tendsto_compact_open_iff_forall {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] [locally_compact_space Î±] [t2_space Î±] [t2_space Î²] {Î¹ : Type u_3} {l : filter Î¹} [l.ne_bot] (F : Î¹ â†’ C(Î±, Î²)) : (âˆƒ (f : C(Î±, Î²)), filter.tendsto F l (nhds f)) â†” âˆ€ (s : set Î±), is_compact s â†’ (âˆƒ (f : C(â†¥s, Î²)), filter.tendsto (Î» (i : Î¹), continuous_map.restrict s (F i)) l (nhds f))
theorem metric.exists_lt_mem_ball_of_mem_ball {Î± : Type u} [pseudo_metric_space Î±] {x y : Î±} {Îµ : â„} (h : x âˆˆ metric.ball y Îµ) : âˆƒ (Îµ' : â„) (H : Îµ' < Îµ), x âˆˆ metric.ball y Îµ'
theorem closure_convex_hull_extreme_points {E : Type u_1} [normed_group E] [normed_space â„ E] {s : set E} (hscomp : is_compact s) (hAconv : convex â„ s) : closure (â‡‘(convex_hull â„) (set.extreme_points â„ s)) = s
theorem multilinear_map.mk_continuous_norm_le {ğ•œ : Type u} {Î¹ : Type v} {E : Î¹ â†’ Type wE} {G : Type wG} [decidable_eq Î¹] [fintype Î¹] [nondiscrete_normed_field ğ•œ] [Î  (i : Î¹), normed_group (E i)] [Î  (i : Î¹), normed_space ğ•œ (E i)] [normed_group G] [normed_space ğ•œ G] (f : multilinear_map ğ•œ E G) {C : â„} (hC : 0 â‰¤ C) (H : âˆ€ (m : Î  (i : Î¹), E i), âˆ¥â‡‘f mâˆ¥ â‰¤ C * finset.univ.prod (Î» (i : Î¹), âˆ¥m iâˆ¥)) : âˆ¥f.mk_continuous C Hâˆ¥ â‰¤ C
theorem metric.mem_closure_iff {Î± : Type u} [pseudo_metric_space Î±] {s : set Î±} {a : Î±} : a âˆˆ closure s â†” âˆ€ (Îµ : â„), Îµ > 0 â†’ (âˆƒ (b : Î±) (H : b âˆˆ s), has_dist.dist a b < Îµ)
theorem filter.tendsto.at_top_mul {Î± : Type u} {Î² : Type v} [linear_ordered_field Î±] [topological_space Î±] [order_topology Î±] {l : filter Î²} {f g : Î² â†’ Î±} {C : Î±} (hC : 0 < C) (hf : filter.tendsto f l filter.at_top) (hg : filter.tendsto g l (nhds C)) : filter.tendsto (Î» (x : Î²), f x * g x) l filter.at_top
theorem metric.cauchy_seq_iff {Î± : Type u} {Î² : Type v} [pseudo_metric_space Î±] [nonempty Î²] [semilattice_sup Î²] {u : Î² â†’ Î±} : cauchy_seq u â†” âˆ€ (Îµ : â„), Îµ > 0 â†’ (âˆƒ (N : Î²), âˆ€ (m : Î²), m â‰¥ N â†’ âˆ€ (n : Î²), n â‰¥ N â†’ has_dist.dist (u m) (u n) < Îµ)
theorem orthonormal.conj_lie_symm {V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) : hb.conj_lie.symm = hb.conj_lie
theorem real.inner_le_Lp_mul_Lq_has_sum_of_nonneg {Î¹ : Type u} {f g : Î¹ â†’ â„} {p q : â„} (hpq : p.is_conjugate_exponent q) {A B : â„} (hA : 0 â‰¤ A) (hB : 0 â‰¤ B) (hf : âˆ€ (i : Î¹), 0 â‰¤ f i) (hg : âˆ€ (i : Î¹), 0 â‰¤ g i) (hf_sum : has_sum (Î» (i : Î¹), f i ^ p) (A ^ p)) (hg_sum : has_sum (Î» (i : Î¹), g i ^ q) (B ^ q)) : âˆƒ (C : â„), 0 â‰¤ C âˆ§ C â‰¤ A * B âˆ§ has_sum (Î» (i : Î¹), f i * g i) C
theorem category_theory.abelian.pseudo_equal_trans {C : Type u} [category_theory.category C] [category_theory.abelian C] {P : C} : transitive (category_theory.abelian.pseudo_equal P)
theorem first_order.language.substructure.subset_closure {L : first_order.language} {M : Type w} [L.Structure M] {s : set M} : s âŠ† â†‘(â‡‘(first_order.language.substructure.closure L) s)
theorem modular_group.smul_eq_lc_row0_add {g : matrix.special_linear_group (fin 2) â„¤} (z : upper_half_plane) {p : fin 2 â†’ â„¤} (hp : is_coprime (p 0) (p 1)) (hg : â†‘g 1 = p) : â†‘(g â€¢ z) = â†‘(â‡‘(modular_group.lc_row0 p) â†‘â†‘g) / (â†‘(p 0) ^ 2 + â†‘(p 1) ^ 2) + (â†‘(p 1) * â†‘z - â†‘(p 0)) / ((â†‘(p 0) ^ 2 + â†‘(p 1) ^ 2) * (â†‘(p 0) * â†‘z + â†‘(p 1)))
theorem prod_mem {B : Type u_3} {S : B} {M : Type u_1} [comm_monoid M] [set_like B M] [submonoid_class B M] {Î¹ : Type u_2} {t : finset Î¹} {f : Î¹ â†’ M} (h : âˆ€ (c : Î¹), c âˆˆ t â†’ f c âˆˆ S) : t.prod (Î» (c : Î¹), f c) âˆˆ S
theorem exists_ratio_deriv_eq_ratio_slope (f : â„ â†’ â„) {a b : â„} (hab : a < b) (hfc : continuous_on f (set.Icc a b)) (hfd : differentiable_on â„ f (set.Ioo a b)) (g : â„ â†’ â„) (hgc : continuous_on g (set.Icc a b)) (hgd : differentiable_on â„ g (set.Ioo a b)) : âˆƒ (c : â„) (H : c âˆˆ set.Ioo a b), (g b - g a) * deriv f c = (f b - f a) * deriv g c
theorem formal_multilinear_series.radius_right_inv_pos_of_radius_pos {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] (p : formal_multilinear_series ğ•œ E F) (i : E â‰ƒL[ğ•œ] F) (hp : 0 < p.radius) : 0 < (p.right_inv i).radius
theorem is_dedekind_domain_iff_is_dedekind_domain_inv {A : Type u_2} [comm_ring A] [is_domain A] : is_dedekind_domain A â†” is_dedekind_domain_inv A
theorem finrank_eq_one_iff_of_nonzero {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] (v : V) (nz : v â‰  0) : finite_dimensional.finrank K V = 1 â†” submodule.span K {v} = âŠ¤
theorem inner_product_geometry.norm_sub_sq_eq_norm_sq_add_norm_sq_iff_angle_eq_pi_div_two {V : Type u_1} [inner_product_space â„ V] (x y : V) : âˆ¥x - yâˆ¥ * âˆ¥x - yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + âˆ¥yâˆ¥ * âˆ¥yâˆ¥ â†” inner_product_geometry.angle x y = real.pi / 2
theorem volume_region_between_eq_lintegral {Î± : Type u_1} [measurable_space Î±] {Î¼ : measure_theory.measure Î±} {f g : Î± â†’ â„} {s : set Î±} [measure_theory.sigma_finite Î¼] (hf : ae_measurable f (Î¼.restrict s)) (hg : ae_measurable g (Î¼.restrict s)) (hs : measurable_set s) : â‡‘(Î¼.prod measure_theory.measure_space.volume) (region_between f g s) = âˆ«â» (y : Î±) in s, ennreal.of_real ((g - f) y) âˆ‚Î¼
theorem con.con_gen_mono {M : Type u_1} [has_mul M] {r s : M â†’ M â†’ Prop} (h : âˆ€ (x y : M), r x y â†’ s x y) : con_gen r â‰¤ con_gen s
theorem algebraic_geometry.LocallyRingedSpace.to_Î“_Spec_map_basic_open_eq (X : algebraic_geometry.LocallyRingedSpace) (r : â†¥(algebraic_geometry.LocallyRingedSpace.Î“.obj (opposite.op X))) : X.to_Î“_Spec_map_basic_open r = X.to_RingedSpace.basic_open r
theorem zero_lt.right.one_le_mul_of_le_of_le {Î± : Type u} {a b : Î±} [mul_zero_one_class Î±] [partial_order Î±] [zero_lt.mul_pos_mono Î±] (ha : 1 â‰¤ a) (hb : 1 â‰¤ b) (b0 : 0 â‰¤ b) : 1 â‰¤ a * b
theorem even.convex_on_pow {n : â„•} (hn : even n) : convex_on â„ set.univ (Î» (x : â„), x ^ n)
theorem cont_diff_on_succ_iff_fderiv_of_open {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {s : set E} {f : E â†’ F} {n : â„•} (hs : is_open s) : cont_diff_on ğ•œ â†‘(n + 1) f s â†” differentiable_on ğ•œ f s âˆ§ cont_diff_on ğ•œ â†‘n (Î» (y : E), fderiv ğ•œ f y) s
theorem multiset.sub_le_iff_le_add {Î± : Type u_1} [decidable_eq Î±] {s t u : multiset Î±} : s - t â‰¤ u â†” s â‰¤ u + t
theorem continuous_map.continuous_coe' {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] [locally_compact_space Î±] : continuous coe_fn
theorem disjoint_nested_nhds {Î± : Type u} [topological_space Î±] [regular_space Î±] {x y : Î±} (h : x â‰  y) : âˆƒ (Uâ‚ : set Î±) (H : Uâ‚ âˆˆ nhds x) (Vâ‚ : set Î±) (H : Vâ‚ âˆˆ nhds x) (Uâ‚‚ : set Î±) (H : Uâ‚‚ âˆˆ nhds y) (Vâ‚‚ : set Î±) (H : Vâ‚‚ âˆˆ nhds y), is_closed Vâ‚ âˆ§ is_closed Vâ‚‚ âˆ§ is_open Uâ‚ âˆ§ is_open Uâ‚‚ âˆ§ Vâ‚ âŠ† Uâ‚ âˆ§ Vâ‚‚ âŠ† Uâ‚‚ âˆ§ Uâ‚ âˆ© Uâ‚‚ = âˆ…
theorem has_dvd.dvd.mul_left {Î± : Type u_1} [comm_semigroup Î±] {a b : Î±} (h : a âˆ£ b) (c : Î±) : a âˆ£ c * b
theorem has_deriv_within_at_iff_has_fderiv_within_at {ğ•œ : Type u} [nondiscrete_normed_field ğ•œ] {F : Type v} [normed_group F] [normed_space ğ•œ F] {f : ğ•œ â†’ F} {x : ğ•œ} {s : set ğ•œ} {f' : F} : has_deriv_within_at f f' s x â†” has_fderiv_within_at f (1.smul_right f') s x
theorem smooth_bump_covering.exists_immersion_euclidean {Î¹ : Type uÎ¹} {E : Type uE} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] {H : Type uH} [topological_space H] {I : model_with_corners â„ E H} {M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] [t2_space M] [fintype Î¹] (f : (smooth_bump_covering Î¹ I M)) : âˆƒ (n : â„•) (e : M â†’ euclidean_space â„ (fin n)), smooth I (model_with_corners_self â„ (euclidean_space â„ (fin n))) e âˆ§ function.injective e âˆ§ âˆ€ (x : M), function.injective â‡‘(mfderiv I (model_with_corners_self â„ (euclidean_space â„ (fin n))) e x)
theorem monoid_with_zero_hom.map_zpow {Gâ‚€ : Type u_1} {Gâ‚€' : Type u_2} [group_with_zero Gâ‚€] [group_with_zero Gâ‚€'] (f : Gâ‚€ â†’*â‚€ Gâ‚€') (x : Gâ‚€) (n : â„¤) : â‡‘f (x ^ n) = â‡‘f x ^ n
theorem bdd_below.image2 {Î± : Type u} {Î² : Type v} {Î³ : Type w} [preorder Î±] [preorder Î²] [preorder Î³] {f : Î± â†’ Î² â†’ Î³} {s : set Î±} {t : set Î²} (hâ‚€ : âˆ€ (b : Î²), monotone (function.swap f b)) (hâ‚ : âˆ€ (a : Î±), monotone (f a)) : bdd_below s â†’ bdd_below t â†’ bdd_below (set.image2 f s t)
theorem count_succ_eq_count {p : â„• â†’ Prop} [decidable_pred p] {n : â„•} : Â¬p n â†’ nat.count p (n + 1) = nat.count p n
theorem con.div {M : Type u_1} [group M] (c : con M) {w x y z : M} : â‡‘c w x â†’ â‡‘c y z â†’ â‡‘c (w / y) (x / z)
theorem smooth_partition_of_unity.exists_is_subordinate {Î¹ : Type uÎ¹} {E : Type uE} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] {H : Type uH} [topological_space H] {I : model_with_corners â„ E H} {M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] [t2_space M] [sigma_compact_space M] {s : set M} (hs : is_closed s) (U : Î¹ â†’ set M) (ho : âˆ€ (i : Î¹), is_open (U i)) (hU : s âŠ† â‹ƒ (i : Î¹), U i) : âˆƒ (f : smooth_partition_of_unity Î¹ I M s), f.is_subordinate U
theorem neg.is_add_group_hom {Î± : Type u} [add_comm_group Î±] : is_add_group_hom has_neg.neg
theorem line_map_slope_line_map_slope_line_map {k : Type u_1} {E : Type u_2} {PE : Type u_3} [field k] [add_comm_group E] [module k E] [add_torsor E PE] (f : k â†’ PE) (a b r : k) : â‡‘(affine_map.line_map (slope f (â‡‘(affine_map.line_map a b) r) b) (slope f a (â‡‘(affine_map.line_map a b) r))) r = slope f a b
theorem nat.partrec.code.smn  : âˆƒ (f : nat.partrec.code â†’ â„• â†’ nat.partrec.code), computableâ‚‚ f âˆ§ âˆ€ (c : nat.partrec.code) (n x : â„•), (f c n).eval x = c.eval (nat.mkpair n x)
theorem affine_independent.finrank_vector_span {k : Type u_1} {V : Type u_2} {P : Type u_3} {Î¹ : Type u_4} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] [fintype Î¹] {p : Î¹ â†’ P} (hi : affine_independent k p) {n : â„•} (hc : fintype.card Î¹ = n + 1) : finite_dimensional.finrank k â†¥(vector_span k (set.range p)) = n
theorem free_group.red.sublist {Î± : Type u} {Lâ‚ Lâ‚‚ : list (Î± Ã— bool)} : free_group.red Lâ‚ Lâ‚‚ â†’ Lâ‚‚ <+ Lâ‚
theorem zmod.quadratic_reciprocity (p q : â„•) [fact (nat.prime p)] [fact (nat.prime q)] (hp1 : p â‰  2) (hq1 : q â‰  2) (hpq : p â‰  q) : zmod.legendre_sym q â†‘p * zmod.legendre_sym p â†‘q = (-1) ^ (p / 2 * (q / 2))
theorem continuous_map.exists_extension_forall_mem_of_closed_embedding {X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] [normal_space Y] (f : C(X, â„)) {t : set â„} {e : X â†’ Y} [hs : t.ord_connected] (hf : âˆ€ (x : X), â‡‘f x âˆˆ t) (hne : t.nonempty) (he : closed_embedding e) : âˆƒ (g : C(Y, â„)), (âˆ€ (y : Y), â‡‘g y âˆˆ t) âˆ§ â‡‘g âˆ˜ e = â‡‘f
theorem is_algebraic_iff_is_integral {K : Type u} {A : Type v} [field K] [ring A] [algebra K A] {x : A} : is_algebraic K x â†” is_integral K x
theorem probability_theory.cond_count_add_compl_eq {Î± : Type u_1} [measurable_space Î±] [measurable_singleton_class Î±] {s : set Î±} (u t : set Î±) (hs : s.finite) : â‡‘(probability_theory.cond_count (s âˆ© u)) t * â‡‘(probability_theory.cond_count s) u + â‡‘(probability_theory.cond_count (s âˆ© uá¶œ)) t * â‡‘(probability_theory.cond_count s) uá¶œ = â‡‘(probability_theory.cond_count s) t
theorem has_dvd.dvd.mul_right {Î± : Type u_1} [semigroup Î±] {a b : Î±} (h : a âˆ£ b) (c : Î±) : a âˆ£ b * c
theorem same_ray.exists_eq_smul {R : Type u_1} [linear_ordered_field R] {M : Type u_2} [add_comm_group M] [module R M] {vâ‚ vâ‚‚ : M} (h : same_ray R vâ‚ vâ‚‚) : âˆƒ (u : M) (a b : R), 0 â‰¤ a âˆ§ 0 â‰¤ b âˆ§ a + b = 1 âˆ§ vâ‚ = a â€¢ u âˆ§ vâ‚‚ = b â€¢ u
theorem finset.exists_lt_card_fiber_of_mul_lt_card_of_maps_to {Î± : Type u} {Î² : Type v} [decidable_eq Î²] {s : finset Î±} {t : finset Î²} {f : Î± â†’ Î²} {n : â„•} (hf : âˆ€ (a : Î±), a âˆˆ s â†’ f a âˆˆ t) (hn : t.card * n < s.card) : âˆƒ (y : Î²) (H : y âˆˆ t), n < (finset.filter (Î» (x : Î±), f x = y) s).card
theorem is_lub.of_subset_of_superset {Î± : Type u} [preorder Î±] {a : Î±} {s t p : set Î±} (hs : is_lub s a) (hp : is_lub p a) (hst : s âŠ† t) (htp : t âŠ† p) : is_lub t a
theorem polynomial.map_cyclotomic_int (n : â„•) (R : Type u_1) [ring R] : polynomial.map (int.cast_ring_hom R) (polynomial.cyclotomic n â„¤) = polynomial.cyclotomic n R
theorem char.quadratic_char_eq_one_of_char_two {F : Type u_1} [field F] [fintype F] [decidable_eq F] (hF : ring_char F = 2) {a : F} (ha : a â‰  0) : char.quadratic_char F a = 1
theorem polynomial.nat_degree_prod {R : Type u} {Î¹ : Type w} (s : finset Î¹) [comm_semiring R] [no_zero_divisors R] (f : Î¹ â†’ polynomial R) (h : âˆ€ (i : Î¹), i âˆˆ s â†’ f i â‰  0) : (s.prod (Î» (i : Î¹), f i)).nat_degree = s.sum (Î» (i : Î¹), (f i).nat_degree)
theorem measure_theory.uniform_integrable_iff {Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_3} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [normed_group Î²] {p : ennreal} {f : Î¹ â†’ Î± â†’ Î²} [measure_theory.is_finite_measure Î¼] (hp : 1 â‰¤ p) (hp' : p â‰  âŠ¤) : measure_theory.uniform_integrable f p Î¼ â†” (âˆ€ (i : Î¹), measure_theory.strongly_measurable (f i)) âˆ§ âˆ€ (Îµ : â„), 0 < Îµ â†’ (âˆƒ (C : nnreal), âˆ€ (i : Î¹), measure_theory.snorm ({x : Î± | C â‰¤ âˆ¥f i xâˆ¥â‚Š}.indicator (f i)) p Î¼ â‰¤ ennreal.of_real Îµ)
theorem has_deriv_at_of_has_deriv_at_of_ne {E : Type u_1} [normed_group E] [normed_space â„ E] {f g : â„ â†’ E} {x : â„} (f_diff : âˆ€ (y : â„), y â‰  x â†’ has_deriv_at f (g y) y) (hf : continuous_at f x) (hg : continuous_at g x) : has_deriv_at f (g x) x
theorem affinity_unit_closed_ball {E : Type u_2} [normed_group E] [normed_space â„ E] {r : â„} (hr : 0 â‰¤ r) (x : E) : x +áµ¥ r â€¢ metric.closed_ball 0 1 = metric.closed_ball x r
theorem nat.asc_factorial_eq_div (n k : â„•) : n.asc_factorial k = (n + k).factorial / n.factorial
theorem orthonormal.two_zsmul_oangle_smul_smul_self {V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) (x : V) {râ‚ râ‚‚ : â„} : 2 â€¢ hb.oangle (râ‚ â€¢ x) (râ‚‚ â€¢ x) = 0
theorem simple_graph.adj.card_common_neighbors_lt_degree {V : Type u} [fintype V] {G : simple_graph V} [decidable_rel G.adj] {v w : V} (h : G.adj v w) : fintype.card â†¥(G.common_neighbors v w) < G.degree v
theorem matrix.aeval_self_charpoly {R : Type u} [comm_ring R] {n : Type w} [decidable_eq n] [fintype n] (M : matrix n n R) : â‡‘(polynomial.aeval M) M.charpoly = 0
theorem ring_hom.map_sclosure {R : Type u} {S : Type v} [non_assoc_semiring R] [non_assoc_semiring S] (f : R â†’+* S) (s : set R) : subsemiring.map f (subsemiring.closure s) = subsemiring.closure (â‡‘f '' s)
theorem category_theory.idempotents.is_idempotent_complete_iff_has_equalizer_of_id_and_idempotent (C : Type u_1) [category_theory.category C] : category_theory.is_idempotent_complete C â†” âˆ€ (X : C) (p : X âŸ¶ X), p â‰« p = p â†’ category_theory.limits.has_equalizer (ğŸ™ X) p
theorem exists_dual_vector'' (ğ•œ : Type v) [is_R_or_C ğ•œ] {E : Type u} [normed_group E] [normed_space ğ•œ E] (x : E) : âˆƒ (g : E â†’L[ğ•œ] ğ•œ), âˆ¥gâˆ¥ â‰¤ 1 âˆ§ â‡‘g x = â†‘âˆ¥xâˆ¥
theorem set.definable.image_comp_embedding {M : Type w} {A : set M} {L : first_order.language} [L.Structure M] {Î± : Type u_1} {Î² : Type u_2} {s : set (Î² â†’ M)} (h : A.definable L s) (f : Î± â†ª Î²) [fintype Î²] : A.definable L ((Î» (g : Î² â†’ M), g âˆ˜ â‡‘f) '' s)
theorem metric.closure_eq_Inter_thickening {Î± : Type u} [pseudo_emetric_space Î±] (E : set Î±) : closure E = â‹‚ (Î´ : â„) (h : 0 < Î´), metric.thickening Î´ E
theorem polynomial.of_finsupp_inj {R : Type u} [semiring R] {a b : add_monoid_algebra R â„•} : {to_finsupp := a} = {to_finsupp := b} â†” a = b
theorem cont_diff_at.snd'' {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {G : Type u_4} [normed_group G] [normed_space ğ•œ G] {n : with_top â„•} {f : F â†’ G} {x : E Ã— F} (hf : cont_diff_at ğ•œ n f x.snd) : cont_diff_at ğ•œ n (Î» (x : E Ã— F), f x.snd) x
theorem fin.univ_succ (n : â„•) : finset.univ = finset.cons 0 (finset.map {to_fun := fin.succ n, inj' := _} finset.univ) _
theorem vector.scanl_head {n : â„•} {Î± : Type u_1} {Î² : Type u_2} (f : Î² â†’ Î± â†’ Î²) (b : Î²) (v : vector Î± n) : (vector.scanl f b v).head = b
theorem monotone.bUnion_Ico_Ioc_map_succ {Î± : Type u_1} {Î² : Type u_2} [linear_order Î±] [succ_order Î±] [is_succ_archimedean Î±] [linear_order Î²] {f : Î± â†’ Î²} (hf : monotone f) (m n : Î±) : (â‹ƒ (i : Î±) (H : i âˆˆ set.Ico m n), set.Ioc (f i) (f (order.succ i))) = set.Ioc (f m) (f n)
theorem measure_theory.measure.eq_on_open_of_ae_eq {X : Type u_1} {Y : Type u_2} [topological_space X] {m : measurable_space X} [topological_space Y] [t2_space Y] {Î¼ : measure_theory.measure X} [Î¼.is_open_pos_measure] {U : set X} {f g : X â†’ Y} (h : f =áµ[Î¼.restrict U] g) (hU : is_open U) (hf : continuous_on f U) (hg : continuous_on g U) : set.eq_on f g U
theorem polynomial.cyclotomic.is_coprime_rat {n m : â„•} (h : n â‰  m) : is_coprime (polynomial.cyclotomic n â„š) (polynomial.cyclotomic m â„š)
theorem is_cyclotomic_extension.rat.discr_prime_pow_eq_unit_mul_pow' {p : â„•+} {k : â„•} {K : Type u} [field K] [char_zero K] {Î¶ : K} [hp : fact (nat.prime â†‘p)] [is_cyclotomic_extension {p ^ k} â„š K] (hÎ¶ : is_primitive_root Î¶ â†‘(p ^ k)) : âˆƒ (u : â„¤Ë£) (n : â„•), algebra.discr â„š â‡‘((is_primitive_root.sub_one_power_basis â„š hÎ¶).basis) = â†‘u * â†‘p ^ n
theorem nnreal.pow_arith_mean_le_arith_mean_pow {Î¹ : Type u} (s : finset Î¹) (w z : Î¹ â†’ nnreal) (hw' : s.sum (Î» (i : Î¹), w i) = 1) (n : â„•) : s.sum (Î» (i : Î¹), w i * z i) ^ n â‰¤ s.sum (Î» (i : Î¹), w i * z i ^ n)
theorem ring_equiv.to_add_monoid_hom_commutes {R : Type u_4} {S : Type u_5} [non_assoc_semiring R] [non_assoc_semiring S] (f : R â‰ƒ+* S) : â†‘f.to_add_monoid_hom = â†‘f.to_add_monoid_hom
theorem antivary.sum_mul_le_sum_comp_perm_mul {Î¹ : Type u_1} {Î± : Type u_2} [linear_ordered_ring Î±] {Ïƒ : equiv.perm Î¹} {f g : Î¹ â†’ Î±} [fintype Î¹] (hfg : antivary f g) : finset.univ.sum (Î» (i : Î¹), f i * g i) â‰¤ finset.univ.sum (Î» (i : Î¹), f (â‡‘Ïƒ i) * g i)
theorem matrix.nonsing_inv_mul {n : Type u'} {Î± : Type v} [fintype n] [decidable_eq n] [comm_ring Î±] (A : matrix n n Î±) (h : is_unit A.det) : Aâ»Â¹.mul A = 1
theorem interval_integral.has_deriv_at_integral_of_dominated_loc_of_deriv_le {ğ•œ : Type u_1} [is_R_or_C ğ•œ] {Î¼ : measure_theory.measure â„} {E : Type u_2} [normed_group E] [normed_space â„ E] [normed_space ğ•œ E] [complete_space E] {a b Îµ : â„} {bound : â„ â†’ â„} {F F' : ğ•œ â†’ â„ â†’ E} {xâ‚€ : ğ•œ} (Îµ_pos : 0 < Îµ) (hF_meas : âˆ€á¶  (x : ğ•œ) in nhds xâ‚€, measure_theory.ae_strongly_measurable (F x) (Î¼.restrict (set.interval_oc a b))) (hF_int : interval_integrable (F xâ‚€) Î¼ a b) (hF'_meas : measure_theory.ae_strongly_measurable (F' xâ‚€) (Î¼.restrict (set.interval_oc a b))) (h_bound : âˆ€áµ (t : â„) âˆ‚Î¼, t âˆˆ set.interval_oc a b â†’ âˆ€ (x : ğ•œ), x âˆˆ metric.ball xâ‚€ Îµ â†’ âˆ¥F' x tâˆ¥ â‰¤ bound t) (bound_integrable : interval_integrable bound Î¼ a b) (h_diff : âˆ€áµ (t : â„) âˆ‚Î¼, t âˆˆ set.interval_oc a b â†’ âˆ€ (x : ğ•œ), x âˆˆ metric.ball xâ‚€ Îµ â†’ has_deriv_at (Î» (x : ğ•œ), F x t) (F' x t) x) : interval_integrable (F' xâ‚€) Î¼ a b âˆ§ has_deriv_at (Î» (x : ğ•œ), âˆ« (t : â„) in a..b, F x t âˆ‚Î¼) (âˆ« (t : â„) in a..b, F' xâ‚€ t âˆ‚Î¼) xâ‚€
theorem has_fderiv_at_integral_of_dominated_of_fderiv_le {Î± : Type u_1} [measurable_space Î±] {Î¼ : measure_theory.measure Î±} {ğ•œ : Type u_2} [is_R_or_C ğ•œ] {E : Type u_3} [normed_group E] [normed_space â„ E] [normed_space ğ•œ E] [complete_space E] {H : Type u_4} [normed_group H] [normed_space ğ•œ H] {F : H â†’ Î± â†’ E} {F' : H â†’ Î± â†’ (H â†’L[ğ•œ] E)} {xâ‚€ : H} {bound : Î± â†’ â„} {Îµ : â„} (Îµ_pos : 0 < Îµ) (hF_meas : âˆ€á¶  (x : H) in nhds xâ‚€, measure_theory.ae_strongly_measurable (F x) Î¼) (hF_int : measure_theory.integrable (F xâ‚€) Î¼) (hF'_meas : measure_theory.ae_strongly_measurable (F' xâ‚€) Î¼) (h_bound : âˆ€áµ (a : Î±) âˆ‚Î¼, âˆ€ (x : H), x âˆˆ metric.ball xâ‚€ Îµ â†’ âˆ¥F' x aâˆ¥ â‰¤ bound a) (bound_integrable : measure_theory.integrable bound Î¼) (h_diff : âˆ€áµ (a : Î±) âˆ‚Î¼, âˆ€ (x : H), x âˆˆ metric.ball xâ‚€ Îµ â†’ has_fderiv_at (Î» (x : H), F x a) (F' x a) x) : has_fderiv_at (Î» (x : H), âˆ« (a : Î±), F x a âˆ‚Î¼) (âˆ« (a : Î±), F' xâ‚€ a âˆ‚Î¼) xâ‚€
theorem metric.inf_dist_lt_iff {Î± : Type u} [pseudo_metric_space Î±] {s : set Î±} {x : Î±} {r : â„} (hs : s.nonempty) : metric.inf_dist x s < r â†” âˆƒ (y : Î±) (H : y âˆˆ s), has_dist.dist x y < r
theorem is_add_submonoid.multiset_sum_mem {M : Type u_1} [add_comm_monoid M] {s : set M} (hs : is_add_submonoid s) (m : multiset M) : (âˆ€ (a : M), a âˆˆ m â†’ a âˆˆ s) â†’ m.sum âˆˆ s
theorem polynomial.C'_mem_lifts {R : Type u} [semiring R] {S : Type v} [semiring S] {f : R â†’+* S} {s : S} (h : s âˆˆ set.range â‡‘f) : â‡‘polynomial.C s âˆˆ polynomial.lifts f
theorem affine_subspace.direction_inf {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] (s1 s2 : affine_subspace k P) : (s1 âŠ“ s2).direction â‰¤ s1.direction âŠ“ s2.direction
theorem ae_mono' {Î± : Type u_1} {m0 : measurable_space Î±} {Î¼ Î½ : measure_theory.measure Î±} : Î¼.absolutely_continuous Î½ â†’ Î¼.ae â‰¤ Î½.ae
theorem padic_val_rat.self {p : â„•} (hp : 1 < p) : padic_val_rat p â†‘p = 1
theorem list.take_append_eq_append_take {Î± : Type u} {lâ‚ lâ‚‚ : list Î±} {n : â„•} : list.take n (lâ‚ ++ lâ‚‚) = list.take n lâ‚ ++ list.take (n - lâ‚.length) lâ‚‚
theorem nat.factorization_inj  : set.inj_on nat.factorization {x : â„• | x â‰  0}
theorem add_submonoid.bot_or_nontrivial {M : Type u_1} [add_zero_class M] (S : add_submonoid M) : S = âŠ¥ âˆ¨ nontrivial â†¥S
theorem star_convex_iff_div {ğ•œ : Type u_1} {E : Type u_2} [linear_ordered_field ğ•œ] [add_comm_group E] [module ğ•œ E] {x : E} {s : set E} : star_convex ğ•œ x s â†” âˆ€ â¦ƒy : Eâ¦„, y âˆˆ s â†’ âˆ€ â¦ƒa b : ğ•œâ¦„, 0 â‰¤ a â†’ 0 â‰¤ b â†’ 0 < a + b â†’ (a / (a + b)) â€¢ x + (b / (a + b)) â€¢ y âˆˆ s
theorem norm_add_pow_two_real {F : Type u_3} [inner_product_space â„ F] {x y : F} : âˆ¥x + yâˆ¥ ^ 2 = âˆ¥xâˆ¥ ^ 2 + 2 * has_inner.inner x y + âˆ¥yâˆ¥ ^ 2
theorem finset.prod_mul_prod_compl {Î² : Type u} {Î± : Type v} [comm_monoid Î²] [fintype Î±] [decidable_eq Î±] (s : finset Î±) (f : Î± â†’ Î²) : s.prod (Î» (i : Î±), f i) * sá¶œ.prod (Î» (i : Î±), f i) = finset.univ.prod (Î» (i : Î±), f i)
theorem ideal.le_of_dvd {R : Type u} [comm_semiring R] {I J : ideal R} : I âˆ£ J â†’ J â‰¤ I
theorem list.sorted.insertion_sort_eq {Î± : Type uu} {r : Î± â†’ Î± â†’ Prop} [decidable_rel r] {l : list Î±} (h : list.sorted r l) : list.insertion_sort r l = l
theorem has_subset.subset.antisymm' {Î± : Type u} [has_subset Î±] {a b : Î±} [is_antisymm Î± has_subset.subset] (h : a âŠ† b) (h' : b âŠ† a) : b = a
theorem category_theory.limits.wide_equalizer.hom_ext {J : Type v} {C : Type u} [category_theory.category C] {X Y : C} {f : J â†’ (X âŸ¶ Y)} [category_theory.limits.has_wide_equalizer f] [nonempty J] {W : C} {k l : W âŸ¶ category_theory.limits.wide_equalizer f} (h : k â‰« category_theory.limits.wide_equalizer.Î¹ f = l â‰« category_theory.limits.wide_equalizer.Î¹ f) : k = l
theorem nat.pow_dvd_pow_iff_le_right {x k l : â„•} (w : 1 < x) : x ^ k âˆ£ x ^ l â†” k â‰¤ l
theorem fintype.univ_of_is_empty {Î± : Type u_1} [is_empty Î±] : finset.univ = âˆ…
theorem is_topological_fiber_bundle.surjective_proj {B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z â†’ B} [topological_space Z] [nonempty F] (h : is_topological_fiber_bundle F proj) : function.surjective proj
theorem matrix.det_mul_right_comm {m : Type u_1} [decidable_eq m] [fintype m] {R : Type v} [comm_ring R] (M N P : matrix m m R) : ((M.mul N).mul P).det = ((M.mul P).mul N).det
theorem measure_theory.map_prod_mul_eq_swap {G : Type u_1} [measurable_space G] [group G] [has_measurable_mulâ‚‚ G] (Î¼ Î½ : measure_theory.measure G) [measure_theory.sigma_finite Î½] [measure_theory.sigma_finite Î¼] [Î¼.is_mul_left_invariant] : measure_theory.measure.map (Î» (z : G Ã— G), (z.snd, z.snd * z.fst)) (Î¼.prod Î½) = Î½.prod Î¼
theorem mul_action.stabilizer_smul_eq_stabilizer_map_conj {Î± : Type u} {Î² : Type v} [group Î±] [mul_action Î± Î²] (g : Î±) (x : Î²) : mul_action.stabilizer Î± (g â€¢ x) = subgroup.map (mul_equiv.to_monoid_hom (â‡‘mul_aut.conj g)) (mul_action.stabilizer Î± x)
theorem simplex_category.Î´_comp_Ïƒ_of_gt {n : â„•} {i : fin (n + 2)} {j : fin (n + 1)} (H : â‡‘fin.cast_succ j < i) : simplex_category.Î´ i.succ â‰« simplex_category.Ïƒ (â‡‘fin.cast_succ j) = simplex_category.Ïƒ j â‰« simplex_category.Î´ i
theorem strict_convex_on.ae_eq_const_or_map_average_lt {Î± : Type u_1} {E : Type u_2} {m0 : measurable_space Î±} [normed_group E] [normed_space â„ E] [complete_space E] {Î¼ : measure_theory.measure Î±} {s : set E} {f : Î± â†’ E} {g : E â†’ â„} [measure_theory.is_finite_measure Î¼] (hg : strict_convex_on â„ s g) (hgc : continuous_on g s) (hsc : is_closed s) (hfs : âˆ€áµ (x : Î±) âˆ‚Î¼, f x âˆˆ s) (hfi : measure_theory.integrable f Î¼) (hgi : measure_theory.integrable (g âˆ˜ f) Î¼) : f =áµ[Î¼] function.const Î± (â¨ (x : Î±), f x âˆ‚Î¼) âˆ¨ g (â¨ (x : Î±), f x âˆ‚Î¼) < â¨ (x : Î±), g (f x) âˆ‚Î¼
theorem measure_theory.finite_measure.tendsto_lintegral_nn_of_le_const {Î± : Type u_1} [measurable_space Î±] [topological_space Î±] [opens_measurable_space Î±] (Î¼ : measure_theory.finite_measure Î±) {fs : â„• â†’ bounded_continuous_function Î± nnreal} {c : nnreal} (fs_le_const : âˆ€ (n : â„•) (a : Î±), â‡‘(fs n) a â‰¤ c) {f : Î± â†’ nnreal} (fs_lim : âˆ€ (a : Î±), filter.tendsto (Î» (n : â„•), â‡‘(fs n) a) filter.at_top (nhds (f a))) : filter.tendsto (Î» (n : â„•), âˆ«â» (a : Î±), â†‘(â‡‘(fs n) a) âˆ‚â†‘Î¼) filter.at_top (nhds (âˆ«â» (a : Î±), â†‘(f a) âˆ‚â†‘Î¼))
theorem balanced_ball_zero {ğ•œ : Type u_3} {E : Type u_4} [normed_field ğ•œ] [semi_normed_group E] [normed_space ğ•œ E] {r : â„} : balanced ğ•œ (metric.ball 0 r)
theorem tendsto_uniformly.tendsto_at {Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_4} [uniform_space Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : filter Î¹} (h : tendsto_uniformly F f p) (x : Î±) : filter.tendsto (Î» (n : Î¹), F n x) p (nhds (f x))
theorem subfield.ext {K : Type u} [field K] {S T : subfield K} (h : âˆ€ (x : K), x âˆˆ S â†” x âˆˆ T) : S = T
theorem filter.tendsto.at_bot_mul_const {Î± : Type u_3} {Î² : Type u_4} [linear_ordered_field Î±] {l : filter Î²} {f : Î² â†’ Î±} {r : Î±} (hr : 0 < r) (hf : filter.tendsto f l filter.at_bot) : filter.tendsto (Î» (x : Î²), f x * r) l filter.at_bot
theorem category_theory.abelian.of_coimage_image_comparison_is_iso.has_images {C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_kernels C] [category_theory.limits.has_cokernels C] [âˆ€ {X Y : C} (f : X âŸ¶ Y), category_theory.is_iso (category_theory.abelian.coimage_image_comparison f)] : category_theory.limits.has_images C
theorem alg_equiv.coe_ring_hom_commutes {R : Type u} {Aâ‚ : Type v} {Aâ‚‚ : Type w} [comm_semiring R] [semiring Aâ‚] [semiring Aâ‚‚] [algebra R Aâ‚] [algebra R Aâ‚‚] (e : Aâ‚ â‰ƒâ‚[R] Aâ‚‚) : â†‘â†‘e = â†‘â†‘e
theorem add_con.mk'_ker {M : Type u_1} [add_zero_class M] (c : add_con M) : add_con.ker c.mk' = c
theorem measure_theory.Lp.mul_meas_ge_le_pow_norm' {Î± : Type u_1} {E : Type u_2} {m0 : measurable_space Î±} {p : ennreal} {Î¼ : measure_theory.measure Î±} [normed_group E] (f : â†¥(measure_theory.Lp E p Î¼)) (hp_ne_zero : p â‰  0) (hp_ne_top : p â‰  âŠ¤) (Îµ : ennreal) : Îµ ^ p.to_real * â‡‘Î¼ {x : Î± | Îµ â‰¤ â†‘âˆ¥â‡‘f xâˆ¥â‚Š} â‰¤ ennreal.of_real âˆ¥fâˆ¥ ^ p.to_real
theorem Mon.filtered_colimits.colimit_mul_mk_eq {J : Type v} [category_theory.small_category J] (F : J â¥¤ Mon) [category_theory.is_filtered J] (x y : Î£ (j : J), â†¥(F.obj j)) (k : J) (f : x.fst âŸ¶ k) (g : y.fst âŸ¶ k) : Mon.filtered_colimits.M.mk F x * Mon.filtered_colimits.M.mk F y = Mon.filtered_colimits.M.mk F âŸ¨k, â‡‘(F.map f) x.snd * â‡‘(F.map g) y.sndâŸ©
theorem is_closed.not_mem_iff_inf_dist_pos {Î± : Type u} [pseudo_metric_space Î±] {s : set Î±} {x : Î±} (h : is_closed s) (hs : s.nonempty) : x âˆ‰ s â†” 0 < metric.inf_dist x s
theorem nat.partrec.code.eval_prec_succ (cf cg : nat.partrec.code) (a k : â„•) : (cf.prec cg).eval (nat.mkpair a k.succ) = (cf.prec cg).eval (nat.mkpair a k) >>= Î» (ih : â„•), cg.eval (nat.mkpair a (nat.mkpair k ih))
theorem iterated_deriv_eq_equiv_comp {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {F : Type u_2} [normed_group F] [normed_space ğ•œ F] {n : â„•} {f : ğ•œ â†’ F} : iterated_deriv n f = â‡‘((continuous_multilinear_map.pi_field_equiv ğ•œ (fin n) F).symm) âˆ˜ iterated_fderiv ğ•œ n f
theorem continuous_at.fst {Î± : Type u} {Î² : Type v} {Î³ : Type u_1} [topological_space Î±] [topological_space Î²] [topological_space Î³] {f : Î± â†’ Î² Ã— Î³} {x : Î±} (hf : continuous_at f x) : continuous_at (Î» (a : Î±), (f a).fst) x
theorem is_topological_fiber_bundle.quotient_map_proj {B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z â†’ B} [topological_space Z] [nonempty F] (h : is_topological_fiber_bundle F proj) : quotient_map proj
theorem closure_Ioo {Î± : Type u} [topological_space Î±] [linear_order Î±] [order_topology Î±] [densely_ordered Î±] {a b : Î±} (hab : a â‰  b) : closure (set.Ioo a b) = set.Icc a b
theorem monoid_with_zero_hom.ext_iff {M : Type u_3} {N : Type u_4} [mul_zero_one_class M] [mul_zero_one_class N] {f g : M â†’*â‚€ N} : f = g â†” âˆ€ (x : M), â‡‘f x = â‡‘g x
theorem ordering.compares.swap {Î± : Type u_1} [has_lt Î±] {a b : Î±} {o : ordering} : o.compares b a â†’ o.swap.compares a b
theorem antitone_on.map_bdd_above {Î± : Type u} {Î² : Type v} [preorder Î±] [preorder Î²] {f : Î± â†’ Î²} {s t : set Î±} (Hf : antitone_on f t) (Hst : s âŠ† t) : (upper_bounds s âˆ© t).nonempty â†’ bdd_below (f '' s)
theorem group_topology.continuous_mul' {Î± : Type u} [group Î±] (g : group_topology Î±) : continuous (Î» (p : Î± Ã— Î±), p.fst * p.snd)
theorem metric.bounded_union {Î± : Type u} [pseudo_metric_space Î±] {s t : set Î±} : metric.bounded (s âˆª t) â†” metric.bounded s âˆ§ metric.bounded t
theorem category_theory.le_of_hom {X : Type u} [preorder X] {x y : X} (h : x âŸ¶ y) : x â‰¤ y
theorem quiver.shortest_path_spec {V : Type u} [quiver V] (r : V) [quiver.rooted_connected r] {a : V} (p : quiver.path r a) : (quiver.shortest_path r a).length â‰¤ p.length
theorem matrix.conj_transpose_eq_adjoint {ğ•œ : Type u_1} [is_R_or_C ğ•œ] {m : Type u_5} {n : Type u_6} [fintype m] [decidable_eq m] [fintype n] [decidable_eq n] (A : matrix m n ğ•œ) : â‡‘matrix.to_lin' A.conj_transpose = â‡‘linear_map.adjoint (â‡‘matrix.to_lin' A)
theorem metric.inf_dist_singleton {Î± : Type u} [pseudo_metric_space Î±] {x y : Î±} : metric.inf_dist x {y} = has_dist.dist x y
theorem is_regular.and_of_mul_of_mul {R : Type u_1} {a b : R} [semigroup R] (ab : is_regular (a * b)) (ba : is_regular (b * a)) : is_regular a âˆ§ is_regular b
theorem monotone.pairwise_disjoint_on_Ico_succ {Î± : Type u_1} {Î² : Type u_2} [linear_order Î±] [succ_order Î±] [preorder Î²] {f : Î± â†’ Î²} (hf : monotone f) : pairwise (disjoint on Î» (n : Î±), set.Ico (f n) (f (order.succ n)))
theorem zero_lt.right.one_lt_mul_of_lt_of_lt {Î± : Type u} {a b : Î±} [mul_one_class Î±] [has_zero Î±] [preorder Î±] [zero_lt.mul_pos_strict_mono Î±] (ha : 1 < a) (hb : 1 < b) (b0 : 0 < b) : 1 < a * b
theorem measure_theory.exists_upper_semicontinuous_le_lintegral_le {Î± : Type u_1} [topological_space Î±] [measurable_space Î±] [borel_space Î±] {Î¼ : measure_theory.measure Î±} [Î¼.weakly_regular] (f : Î± â†’ nnreal) (int_f : âˆ«â» (x : Î±), â†‘(f x) âˆ‚Î¼ â‰  âŠ¤) {Îµ : ennreal} (Îµ0 : Îµ â‰  0) : âˆƒ (g : Î± â†’ nnreal), (âˆ€ (x : Î±), g x â‰¤ f x) âˆ§ upper_semicontinuous g âˆ§ âˆ«â» (x : Î±), â†‘(f x) âˆ‚Î¼ â‰¤ âˆ«â» (x : Î±), â†‘(g x) âˆ‚Î¼ + Îµ
theorem has_lt.lt.dual {Î± : Type u_1} [has_lt Î±] {a b : Î±} : b < a â†’ â‡‘order_dual.to_dual a < â‡‘order_dual.to_dual b
theorem sub_neg_of_lt {Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b : Î±} : a < b â†’ a - b < 0
theorem cardinal.mk_quaternion (R : Type u_1) [has_one R] [has_neg R] : cardinal.mk (quaternion R) = cardinal.mk R ^ 4
theorem finset.image_imageâ‚‚_right_comm {Î± : Type u_1} {Î² : Type u_3} {Î²' : Type u_4} {Î³ : Type u_5} {Î´ : Type u_7} [decidable_eq Î²'] [decidable_eq Î³] [decidable_eq Î´] {s : finset Î±} {t : finset Î²} {f : Î± â†’ Î²' â†’ Î³} {g : Î² â†’ Î²'} {f' : Î± â†’ Î² â†’ Î´} {g' : Î´ â†’ Î³} (h_right_comm : âˆ€ (a : Î±) (b : Î²), f a (g b) = g' (f' a b)) : finset.imageâ‚‚ f s (finset.image g t) = finset.image g' (finset.imageâ‚‚ f' s t)
theorem orthonormal.oangle_rev {V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) (x y : V) : hb.oangle y x = -hb.oangle x y
theorem is_local_min.deriv_eq_zero {f : â„ â†’ â„} {a : â„} (h : is_local_min f a) : deriv f a = 0
theorem bilin_form.is_Ortho.not_is_ortho_basis_self_of_nondegenerate {R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] {n : Type w} [nontrivial R] {B : bilin_form R M} {v : basis n R M} (h : B.is_Ortho â‡‘v) (hB : B.nondegenerate) (i : n) : Â¬B.is_ortho (â‡‘v i) (â‡‘v i)
theorem basis.to_matrix_is_unit_smul {Î¹ : Type u_1} {Râ‚‚ : Type u_7} {Mâ‚‚ : Type u_8} [comm_ring Râ‚‚] [add_comm_group Mâ‚‚] [module Râ‚‚ Mâ‚‚] [decidable_eq Î¹] (e : basis Î¹ Râ‚‚ Mâ‚‚) {w : Î¹ â†’ Râ‚‚} (hw : âˆ€ (i : Î¹), is_unit (w i)) : e.to_matrix â‡‘(e.is_unit_smul hw) = matrix.diagonal w
theorem spectrum.nonempty_of_is_alg_closed_of_finite_dimensional (ğ•œ : Type u) {A : Type v} [field ğ•œ] [ring A] [algebra ğ•œ A] [is_alg_closed ğ•œ] [nontrivial A] [I : finite_dimensional ğ•œ A] (a : A) : âˆƒ (k : ğ•œ), k âˆˆ spectrum ğ•œ a
theorem intermediate_field.neg_mem {K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) {x : L} : x âˆˆ S â†’ -x âˆˆ S
theorem mt {a b : Prop} (hâ‚ : a â†’ b) (hâ‚‚ : Â¬b) : Â¬a
theorem bornology.is_cobounded.compl {Î± : Type u_2} [bornology Î±] {s : set Î±} : bornology.is_cobounded s â†’ bornology.is_bounded sá¶œ
theorem function.periodic_orbit_def {Î± : Type u_1} (f : Î± â†’ Î±) (x : Î±) : function.periodic_orbit f x = â†‘(list.map (Î» (n : â„•), f^[n] x) (list.range (function.minimal_period f x)))
theorem measure_theory.set_integral_condexp {Î± : Type u_1} {F' : Type u_7} [normed_group F'] [normed_space â„ F'] [complete_space F'] {m m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {f : Î± â†’ F'} {s : set Î±} (hm : m â‰¤ m0) [measure_theory.sigma_finite (Î¼.trim hm)] (hf : measure_theory.integrable f Î¼) (hs : measurable_set s) : âˆ« (x : Î±) in s, measure_theory.condexp m Î¼ f x âˆ‚Î¼ = âˆ« (x : Î±) in s, f x âˆ‚Î¼
theorem convex.lipschitz_on_with_of_nnnorm_fderiv_within_le {E : Type u_1} [normed_group E] [normed_space â„ E] {ğ•œ : Type u_3} {G : Type u_4} [is_R_or_C ğ•œ] [normed_space ğ•œ E] [normed_group G] [normed_space ğ•œ G] {f : E â†’ G} {s : set E} {C : nnreal} (hf : differentiable_on ğ•œ f s) (bound : âˆ€ (x : E), x âˆˆ s â†’ âˆ¥fderiv_within ğ•œ f s xâˆ¥â‚Š â‰¤ C) (hs : convex â„ s) : lipschitz_on_with C f s
theorem antivary_on.sum_smul_eq_sum_smul_comp_perm_iff {Î¹ : Type u_1} {Î± : Type u_2} {Î² : Type u_3} [linear_ordered_ring Î±] [linear_ordered_add_comm_group Î²] [module Î± Î²] [ordered_smul Î± Î²] {s : finset Î¹} {Ïƒ : equiv.perm Î¹} {f : Î¹ â†’ Î±} {g : Î¹ â†’ Î²} (hfg : antivary_on f g â†‘s) (hÏƒ : {x : Î¹ | â‡‘Ïƒ x â‰  x} âŠ† â†‘s) : s.sum (Î» (i : Î¹), f i â€¢ g (â‡‘Ïƒ i)) = s.sum (Î» (i : Î¹), f i â€¢ g i) â†” antivary_on f (g âˆ˜ â‡‘Ïƒ) â†‘s
theorem semiconj_by.one_right {M : Type u} [mul_one_class M] (a : M) : semiconj_by a 1 1
theorem category_theory.nat_trans.mono_app_of_mono {C : Type uâ‚} [category_theory.category C] {D : Type uâ‚‚} [category_theory.category D] {F G : C â¥¤ D} (Î± : F âŸ¶ G) [âˆ€ (X : C), category_theory.mono (Î±.app X)] : category_theory.mono Î±
theorem submonoid.localization_map.mul_inv_left {M : Type u_1} [comm_monoid M] {S : submonoid M} {N : Type u_2} [comm_monoid N] {f : M â†’* N} (h : âˆ€ (y : â†¥S), is_unit (â‡‘f â†‘y)) (y : â†¥S) (w z : N) : w * â†‘(â‡‘(is_unit.lift_right (f.restrict S) h) y)â»Â¹ = z â†” w = â‡‘f â†‘y * z
theorem measure_theory.mul_meas_ge_le_lintegralâ‚€ {Î± : Type u_1} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {f : Î± â†’ ennreal} (hf : ae_measurable f Î¼) (Îµ : ennreal) : Îµ * â‡‘Î¼ {x : Î± | Îµ â‰¤ f x} â‰¤ âˆ«â» (a : Î±), f a âˆ‚Î¼
theorem subfield.one_mem {K : Type u} [field K] (s : subfield K) : 1 âˆˆ s
theorem basis.ext' {Î¹ : Type u_1} {R : Type u_3} {M : Type u_5} [semiring R] [add_comm_monoid M] [module R M] (b : basis Î¹ R M) {Râ‚ : Type u_9} [semiring Râ‚] {Ïƒ : R â†’+* Râ‚} {Ïƒ' : Râ‚ â†’+* R} [ring_hom_inv_pair Ïƒ Ïƒ'] [ring_hom_inv_pair Ïƒ' Ïƒ] {Mâ‚ : Type u_10} [add_comm_monoid Mâ‚] [module Râ‚ Mâ‚] {fâ‚ fâ‚‚ : M â‰ƒâ‚›â‚—[Ïƒ] Mâ‚} (h : âˆ€ (i : Î¹), â‡‘fâ‚ (â‡‘b i) = â‡‘fâ‚‚ (â‡‘b i)) : fâ‚ = fâ‚‚
theorem category_theory.is_cofiltered.inf_objs_exists {C : Type u} [category_theory.category C] [category_theory.is_cofiltered C] (O : finset C) : âˆƒ (S : C), âˆ€ {X : C}, X âˆˆ O â†’ nonempty (S âŸ¶ X)
theorem measure_theory.Lp.induction {Î± : Type u_1} {E : Type u_4} [measurable_space Î±] [normed_group E] {p : ennreal} {Î¼ : measure_theory.measure Î±} [fact (1 â‰¤ p)] (hp_ne_top : p â‰  âŠ¤) (P : â†¥(measure_theory.Lp E p Î¼) â†’ Prop) (h_ind : âˆ€ (c : E) {s : set Î±} (hs : measurable_set s) (hÎ¼s : â‡‘Î¼ s < âŠ¤), P â†‘(measure_theory.Lp.simple_func.indicator_const p hs _ c)) (h_add : âˆ€ â¦ƒf g : Î± â†’ Eâ¦„ (hf : measure_theory.mem_â„’p f p Î¼) (hg : measure_theory.mem_â„’p g p Î¼), disjoint (function.support f) (function.support g) â†’ P (measure_theory.mem_â„’p.to_Lp f hf) â†’ P (measure_theory.mem_â„’p.to_Lp g hg) â†’ P (measure_theory.mem_â„’p.to_Lp f hf + measure_theory.mem_â„’p.to_Lp g hg)) (h_closed : is_closed {f : â†¥(measure_theory.Lp E p Î¼) | P f}) (f : â†¥(measure_theory.Lp E p Î¼)) : P f
theorem finset.fold_ite' {Î± : Type u_1} {Î² : Type u_2} {op : Î² â†’ Î² â†’ Î²} [hc : is_commutative Î² op] [ha : is_associative Î² op] {f : Î± â†’ Î²} {b : Î²} {s : finset Î±} {g : Î± â†’ Î²} (hb : op b b = b) (p : Î± â†’ Prop) [decidable_pred p] : finset.fold op b (Î» (i : Î±), ite (p i) (f i) (g i)) s = op (finset.fold op b f (finset.filter p s)) (finset.fold op b g (finset.filter (Î» (i : Î±), Â¬p i) s))
theorem box_integral.integrable_iff_cauchy_basis {Î¹ : Type u} {E : Type v} {F : Type w} [normed_group E] [normed_space â„ E] [normed_group F] [normed_space â„ F] {I : box_integral.box Î¹} [fintype Î¹] {l : box_integral.integration_params} {f : (Î¹ â†’ â„) â†’ E} {vol : box_integral.box_additive_map Î¹ (E â†’L[â„] F) âŠ¤} [complete_space F] : box_integral.integrable I l f vol â†” âˆ€ (Îµ : â„), Îµ > 0 â†’ (âˆƒ (r : nnreal â†’ (Î¹ â†’ â„) â†’ â†¥(set.Ioi 0)), (âˆ€ (c : nnreal), l.r_cond (r c)) âˆ§ âˆ€ (câ‚ câ‚‚ : nnreal) (Ï€â‚ Ï€â‚‚ : box_integral.tagged_prepartition I), l.mem_base_set I câ‚ (r câ‚) Ï€â‚ â†’ Ï€â‚.is_partition â†’ l.mem_base_set I câ‚‚ (r câ‚‚) Ï€â‚‚ â†’ Ï€â‚‚.is_partition â†’ has_dist.dist (box_integral.integral_sum f vol Ï€â‚) (box_integral.integral_sum f vol Ï€â‚‚) â‰¤ Îµ)
theorem box_integral.integrable.dist_integral_sum_sum_integral_le_of_mem_base_set {Î¹ : Type u} {E : Type v} {F : Type w} [normed_group E] [normed_space â„ E] [normed_group F] [normed_space â„ F] {I : box_integral.box Î¹} {Ï€ : box_integral.tagged_prepartition I} [fintype Î¹] {l : box_integral.integration_params} {f : (Î¹ â†’ â„) â†’ E} {vol : box_integral.box_additive_map Î¹ (E â†’L[â„] F) âŠ¤} {c : nnreal} {Îµ : â„} [complete_space F] (h : box_integral.integrable I l f vol) (h0 : 0 < Îµ) (hÏ€ : l.mem_base_set I c (h.convergence_r Îµ c) Ï€) : has_dist.dist (box_integral.integral_sum f vol Ï€) (Ï€.to_prepartition.boxes.sum (Î» (J : box_integral.box Î¹), box_integral.integral J l f vol)) â‰¤ Îµ
theorem char.is_square_neg_one_iff {F : Type u_1} [field F] [fintype F] : is_square (-1) â†” fintype.card F % 4 â‰  3
theorem is_fixed_pt_of_tendsto_iterate {Î± : Type u_1} [topological_space Î±] [t2_space Î±] {f : Î± â†’ Î±} {x y : Î±} (hy : filter.tendsto (Î» (n : â„•), f^[n] x) filter.at_top (nhds y)) (hf : continuous_at f y) : function.is_fixed_pt f y
theorem has_sum_fourier_series (f : â†¥(measure_theory.Lp â„‚ 2 haar_circle)) : has_sum (Î» (i : â„¤), â‡‘(â‡‘(fourier_series.repr) f) i â€¢ fourier_Lp 2 i) f
theorem generalized_continued_fraction.succ_nth_convergent'_eq_squash_gcf_nth_convergent' {K : Type u_1} {n : â„•} {g : generalized_continued_fraction K} [division_ring K] : g.convergents' (n + 1) = (g.squash_gcf n).convergents' n
theorem basis.nonempty_fintype_index_of_dim_lt_aleph_0 {R : Type u} [ring R] [strong_rank_condition R] {M : Type v} [add_comm_group M] [module R M] {Î¹ : Type u_1} (b : basis Î¹ R M) (h : module.rank R M < cardinal.aleph_0) : nonempty (fintype Î¹)
theorem complex.circle_integral_sub_center_inv_smul_eq_of_differentiable_on_annulus_off_countable {E : Type u} [normed_group E] [normed_space â„‚ E] [complete_space E] {c : â„‚} {r R : â„} (h0 : 0 < r) (hle : r â‰¤ R) {f : â„‚ â†’ E} {s : set â„‚} (hs : s.countable) (hc : continuous_on f (metric.closed_ball c R  metric.ball c r)) (hd : âˆ€ (z : â„‚), z âˆˆ metric.ball c R  metric.closed_ball c r  s â†’ differentiable_at â„‚ f z) : âˆ® (z : â„‚) in C(c, R), (z - c)â»Â¹ â€¢ f z = âˆ® (z : â„‚) in C(c, r), (z - c)â»Â¹ â€¢ f z
theorem affine.simplex.points_with_circumcenter_point {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {n : â„•} (s : affine.simplex â„ P n) (i : fin (n + 1)) : s.points_with_circumcenter (affine.simplex.points_with_circumcenter_index.point_index i) = s.points i
theorem category_theory.limits.has_coproducts_opposite {C : Type uâ‚} [category_theory.category C] (X : Type vâ‚) [category_theory.limits.has_products_of_shape X C] : category_theory.limits.has_coproducts_of_shape X Cáµ’áµ–
theorem lower_semicontinuous.add' {Î± : Type u_1} [topological_space Î±] {Î³ : Type u_4} [linear_ordered_add_comm_monoid Î³] [topological_space Î³] [order_topology Î³] {f g : Î± â†’ Î³} (hf : lower_semicontinuous f) (hg : lower_semicontinuous g) (hcont : âˆ€ (x : Î±), continuous_at (Î» (p : Î³ Ã— Î³), p.fst + p.snd) (f x, g x)) : lower_semicontinuous (Î» (z : Î±), f z + g z)
theorem edist_ne_top_of_mem_ball {Î² : Type u_2} [emetric_space Î²] {a : Î²} {r : ennreal} (x y : â†¥(emetric.ball a r)) : has_edist.edist x.val y.val â‰  âŠ¤
theorem finsupp.comap_domain_zero {Î± : Type u_1} {Î² : Type u_2} {M : Type u_5} [has_zero M] (f : Î± â†’ Î²) (hif : set.inj_on f (f â»Â¹' â†‘(0.support)) := _) : finsupp.comap_domain f 0 hif = 0
theorem convex.null_measurable_set {E : Type u_1} [normed_group E] [normed_space â„ E] [measurable_space E] [borel_space E] [finite_dimensional â„ E] (Î¼ : measure_theory.measure E) [Î¼.is_add_haar_measure] {s : set E} (hs : convex â„ s) : measure_theory.null_measurable_set s Î¼
theorem le_neg_add_of_add_le {Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b c : Î±} : a + b â‰¤ c â†’ b â‰¤ -a + c
theorem is_totally_separated.is_totally_disconnected {Î± : Type u} [topological_space Î±] {s : set Î±} (H : is_totally_separated s) : is_totally_disconnected s
theorem bornology.is_vonN_bounded_singleton {ğ•œ : Type u_1} {E : Type u_2} [normed_field ğ•œ] [add_comm_group E] [module ğ•œ E] [topological_space E] [has_continuous_smul ğ•œ E] (x : E) : bornology.is_vonN_bounded ğ•œ {x}
theorem one_div_le_one_div_of_neg {Î± : Type u_1} [linear_ordered_field Î±] {a b : Î±} (ha : a < 0) (hb : b < 0) : 1 / a â‰¤ 1 / b â†” b â‰¤ a
theorem linear_map.is_Ortho.not_is_ortho_basis_self_of_separating_left {R : Type u_1} {M : Type u_5} {n : Type u_14} [comm_ring R] [add_comm_group M] [module R M] {I I' : R â†’+* R} [nontrivial R] {B : M â†’â‚›â‚—[I] M â†’â‚›â‚—[I'] R} {v : basis n R M} (h : B.is_Ortho â‡‘v) (hB : B.separating_left) (i : n) : Â¬B.is_ortho (â‡‘v i) (â‡‘v i)
theorem finsupp.on_finset_sum {Î± : Type u_1} {M : Type u_5} {N : Type u_7} [has_zero M] [add_comm_monoid N] {s : finset Î±} {f : Î± â†’ M} {g : Î± â†’ M â†’ N} (hf : âˆ€ (a : Î±), f a â‰  0 â†’ a âˆˆ s) (hg : âˆ€ (a : Î±), g a 0 = 0) : (finsupp.on_finset s f hf).sum g = s.sum (Î» (a : Î±), g a (f a))
theorem is_open_prod_iff' {Î± : Type u} {Î² : Type v} [topological_space Î±] [topological_space Î²] {s : set Î±} {t : set Î²} : is_open (s Ã—Ë¢ t) â†” is_open s âˆ§ is_open t âˆ¨ s = âˆ… âˆ¨ t = âˆ…
theorem modular_group.exists_row_one_eq_and_min_re (z : upper_half_plane) {cd : fin 2 â†’ â„¤} (hcd : is_coprime (cd 0) (cd 1)) : âˆƒ (g : matrix.special_linear_group (fin 2) â„¤), â†‘g 1 = cd âˆ§ âˆ€ (g' : matrix.special_linear_group (fin 2) â„¤), â†‘g 1 = â†‘g' 1 â†’ |(g â€¢ z).re| â‰¤ |(g' â€¢ z).re|
theorem set.Union_lift_const {Î± : Type u_1} {Î¹ : Type u_2} {Î² : Type u_3} {S : Î¹ â†’ set Î±} {f : Î  (i : Î¹), â†¥(S i) â†’ Î²} {hf : âˆ€ (i j : Î¹) (x : Î±) (hxi : x âˆˆ S i) (hxj : x âˆˆ S j), f i âŸ¨x, hxiâŸ© = f j âŸ¨x, hxjâŸ©} {T : set Î±} {hT : T âŠ† set.Union S} (c : â†¥T) (ci : Î  (i : Î¹), â†¥(S i)) (hci : âˆ€ (i : Î¹), â†‘(ci i) = â†‘c) (cÎ² : Î²) (h : âˆ€ (i : Î¹), f i (ci i) = cÎ²) : set.Union_lift S f hf T hT c = cÎ²
theorem measure_theory.exists_subordinate_pairwise_disjoint {Î¹ : Type u_1} {Î± : Type u_2} {m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} [encodable Î¹] {s : Î¹ â†’ set Î±} (h : âˆ€ (i : Î¹), measure_theory.null_measurable_set (s i) Î¼) (hd : pairwise (measure_theory.ae_disjoint Î¼ on s)) : âˆƒ (t : Î¹ â†’ set Î±), (âˆ€ (i : Î¹), t i âŠ† s i) âˆ§ (âˆ€ (i : Î¹), s i =áµ[Î¼] t i) âˆ§ (âˆ€ (i : Î¹), measurable_set (t i)) âˆ§ pairwise (disjoint on t)
theorem add_subgroup.closure_induction {G : Type u_1} [add_group G] {k : set G} {p : G â†’ Prop} {x : G} (h : x âˆˆ add_subgroup.closure k) (Hk : âˆ€ (x : G), x âˆˆ k â†’ p x) (H1 : p 0) (Hmul : âˆ€ (x y : G), p x â†’ p y â†’ p (x + y)) (Hinv : âˆ€ (x : G), p x â†’ p (-x)) : p x
theorem Top.presheaf.is_sheaf_iff_is_sheaf_unique_gluing_types {X : Top} (F : Top.presheaf (Type v) X) : F.is_sheaf â†” F.is_sheaf_unique_gluing
theorem category_theory.limits.cokernel.Ï€_of_zero {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (X Y : C) : category_theory.is_iso (category_theory.limits.cokernel.Ï€ 0)
theorem set.Inter_eq_Inter_finset {Î± : Type u_1} {Î¹ : Type u_4} (s : Î¹ â†’ set Î±) : (â‹‚ (i : Î¹), s i) = â‹‚ (t : finset Î¹) (i : Î¹) (H : i âˆˆ t), s i
theorem lipschitz_with.uniform_continuous {Î± : Type u} {Î² : Type v} [pseudo_emetric_space Î±] [pseudo_emetric_space Î²] {K : nnreal} {f : Î± â†’ Î²} (hf : lipschitz_with K f) : uniform_continuous f
theorem approximates_linear_on.exists_homeomorph_extension {E : Type u_1} [normed_group E] [normed_space â„ E] {F : Type u_2} [normed_group F] [normed_space â„ F] [finite_dimensional â„ F] {s : set E} {f : E â†’ F} {f' : E â‰ƒL[â„] F} {c : nnreal} (hf : approximates_linear_on f â†‘f' s c) (hc : subsingleton E âˆ¨ lipschitz_extension_constant F * c < âˆ¥â†‘(f'.symm)âˆ¥â‚Šâ»Â¹) : âˆƒ (g : E â‰ƒâ‚œ F), set.eq_on f â‡‘g s
theorem direct_sum.linear_map_ext (R : Type u) [semiring R] {Î¹ : Type v} [dec_Î¹ : decidable_eq Î¹] {M : Î¹ â†’ Type w} [Î  (i : Î¹), add_comm_monoid (M i)] [Î  (i : Î¹), module R (M i)] {N : Type uâ‚} [add_comm_monoid N] [module R N] â¦ƒÏˆ Ïˆ' : direct_sum Î¹ (Î» (i : Î¹), M i) â†’â‚—[R] Nâ¦„ (H : âˆ€ (i : Î¹), Ïˆ.comp (direct_sum.lof R Î¹ M i) = Ïˆ'.comp (direct_sum.lof R Î¹ M i)) : Ïˆ = Ïˆ'
theorem neg_cross {R : Type u_1} [comm_ring R] (v w : fin 3 â†’ R) : -â‡‘(â‡‘cross_product v) w = â‡‘(â‡‘cross_product w) v
theorem padic_val_rat.padic_val_rat_le_padic_val_rat_iff (p : â„•) [p_prime : fact (nat.prime p)] {nâ‚ nâ‚‚ dâ‚ dâ‚‚ : â„¤} (hnâ‚ : nâ‚ â‰  0) (hnâ‚‚ : nâ‚‚ â‰  0) (hdâ‚ : dâ‚ â‰  0) (hdâ‚‚ : dâ‚‚ â‰  0) : padic_val_rat p (rat.mk nâ‚ dâ‚) â‰¤ padic_val_rat p (rat.mk nâ‚‚ dâ‚‚) â†” âˆ€ (n : â„•), â†‘p ^ n âˆ£ nâ‚ * dâ‚‚ â†’ â†‘p ^ n âˆ£ nâ‚‚ * dâ‚
theorem function.periodic_orbit_eq_cycle_map {Î± : Type u_1} (f : Î± â†’ Î±) (x : Î±) : function.periodic_orbit f x = cycle.map (Î» (n : â„•), f^[n] x) â†‘(list.range (function.minimal_period f x))
theorem is_R_or_C.conj_conj {R : Type u} [comm_semiring R] [star_ring R] (x : R) : â‡‘(star_ring_end R) (â‡‘(star_ring_end R) x) = x
theorem has_fderiv_within_at.maps_to_tangent_cone {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {f : E â†’ F} {s : set E} {f' : E â†’L[ğ•œ] F} {x : E} (h : has_fderiv_within_at f f' s x) : set.maps_to â‡‘f' (tangent_cone_at ğ•œ s x) (tangent_cone_at ğ•œ (f '' s) (f x))
theorem set.definable.image_comp_sum_inl_fin {M : Type w} {A : set M} {L : first_order.language} [L.Structure M] {Î± : Type u_1} (m : â„•) {s : set (Î± âŠ• fin m â†’ M)} (h : A.definable L s) : A.definable L ((Î» (g : Î± âŠ• fin m â†’ M), g âˆ˜ sum.inl) '' s)
theorem approximates_linear_on.lipschitz_on_with {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {f : E â†’ F} {f' : E â†’L[ğ•œ] F} {s : set E} {c : nnreal} : approximates_linear_on f f' s c â†’ lipschitz_on_with c (f - â‡‘f') s
theorem cont_diff_on.ftaylor_series_within {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {s : set E} {f : E â†’ F} {n : with_top â„•} (h : cont_diff_on ğ•œ n f s) (hs : unique_diff_on ğ•œ s) : has_ftaylor_series_up_to_on n f (ftaylor_series_within ğ•œ f s) s
theorem metric.emetric_ball_nnreal {Î± : Type u} [pseudo_metric_space Î±] {x : Î±} {Îµ : nnreal} : emetric.ball x â†‘Îµ = metric.ball x â†‘Îµ
theorem list.sum_take_map_length_lt2 {Î± : Type u_1} (L : list (list Î±)) {i j : â„•} (hi : i < L.length) (hj : j < (L.nth_le i hi).length) : (list.take i (list.map list.length L)).sum + j < L.join.length
theorem asymptotics.is_O.of_norm_norm {Î± : Type u_1} {E' : Type u_6} {F' : Type u_7} [semi_normed_group E'] [semi_normed_group F'] {f' : Î± â†’ E'} {g' : Î± â†’ F'} {l : filter Î±} : ((Î» (x : Î±), âˆ¥f' xâˆ¥) =O[l] Î» (x : Î±), âˆ¥g' xâˆ¥) â†’ f' =O[l] g'
theorem continuous_linear_map.norm_smul_right_apply {ğ•œ : Type u_1} {E : Type u_4} {Fâ‚— : Type u_7} [normed_group E] [normed_group Fâ‚—] [nondiscrete_normed_field ğ•œ] [normed_space ğ•œ E] [normed_space ğ•œ Fâ‚—] (c : E â†’L[ğ•œ] ğ•œ) (f : Fâ‚—) : âˆ¥c.smul_right fâˆ¥ = âˆ¥câˆ¥ * âˆ¥fâˆ¥
theorem padic_val_rat.mul (p : â„•) [p_prime : fact (nat.prime p)] {q r : â„š} (hq : q â‰  0) (hr : r â‰  0) : padic_val_rat p (q * r) = padic_val_rat p q + padic_val_rat p r
theorem linear_ordered_comm_group_with_zero.singleton_nhds_of_ne_zero {Î“â‚€ : Type u_1} [linear_ordered_comm_group_with_zero Î“â‚€] (Î³ : Î“â‚€) (h : Î³ â‰  0) : {Î³} âˆˆ nhds Î³
theorem module.End.exists_eigenvalue {K : Type v} {V : Type w} [field K] [add_comm_group V] [module K V] [is_alg_closed K] [finite_dimensional K V] [nontrivial V] (f : module.End K V) : âˆƒ (c : K), f.has_eigenvalue c
theorem Gromov_Hausdorff.to_GH_space_eq_to_GH_space_iff_isometric {X : Type u} [metric_space X] [compact_space X] [nonempty X] {Y : Type v} [metric_space Y] [compact_space Y] [nonempty Y] : Gromov_Hausdorff.to_GH_space X = Gromov_Hausdorff.to_GH_space Y â†” nonempty (X â‰ƒáµ¢ Y)
theorem induced_topology_pure {Î± : Type u} : topological_space.induced has_pure.pure ultrafilter.topological_space = âŠ¥
theorem lucas_lehmer.mersenne_coe_X (p : â„•) : â†‘(mersenne p) = 0
theorem category_theory.comp_right_adjoint_mate {C : Type uâ‚} [category_theory.category C] [category_theory.monoidal_category C] {X Y Z : C} [category_theory.has_right_dual X] [category_theory.has_right_dual Y] [category_theory.has_right_dual Z] {f : X âŸ¶ Y} {g : Y âŸ¶ Z} : (f â‰« g)á˜ = gá˜ â‰« fá˜
theorem isometry_id {Î± : Type u} [pseudo_emetric_space Î±] : isometry id
theorem asymptotics.is_o.exists_eq_mul {Î± : Type u_1} {ğ•œ : Type u_14} [normed_field ğ•œ] {l : filter Î±} {u v : Î± â†’ ğ•œ} : u =o[l] v â†’ (âˆƒ (Ï† : Î± â†’ ğ•œ) (hÏ† : filter.tendsto Ï† l (nhds 0)), u =á¶ [l] Ï† * v)
theorem finset.prod_bij' {Î² : Type u} {Î± : Type v} {Î³ : Type w} [comm_monoid Î²] {s : finset Î±} {t : finset Î³} {f : Î± â†’ Î²} {g : Î³ â†’ Î²} (i : Î  (a : Î±), a âˆˆ s â†’ Î³) (hi : âˆ€ (a : Î±) (ha : a âˆˆ s), i a ha âˆˆ t) (h : âˆ€ (a : Î±) (ha : a âˆˆ s), f a = g (i a ha)) (j : Î  (a : Î³), a âˆˆ t â†’ Î±) (hj : âˆ€ (a : Î³) (ha : a âˆˆ t), j a ha âˆˆ s) (left_inv : âˆ€ (a : Î±) (ha : a âˆˆ s), j (i a ha) _ = a) (right_inv : âˆ€ (a : Î³) (ha : a âˆˆ t), i (j a ha) _ = a) : s.prod (Î» (x : Î±), f x) = t.prod (Î» (x : Î³), g x)
theorem finite_dimensional.of_subalgebra_to_submodule {K : Type u_1} {V : Type u_2} [field K] [ring V] [algebra K V] {s : subalgebra K V} (h : finite_dimensional K â†¥(s.to_submodule)) : finite_dimensional K â†¥s
theorem list.map_length_split_wrt_composition {Î± : Type u_1} (l : list Î±) (c : composition l.length) : list.map list.length (l.split_wrt_composition c) = c.blocks
theorem pnat.xgcd_type.step_wf (u : pnat.xgcd_type) (hr : u.r â‰  0) : sizeof u.step < sizeof u
theorem eq_of_forall_edist_le {Î³ : Type w} [emetric_space Î³] {x y : Î³} (h : âˆ€ (Îµ : ennreal), Îµ > 0 â†’ has_edist.edist x y â‰¤ Îµ) : x = y
theorem is_fraction_ring.is_algebraic_iff (A : Type u_4) (K : Type u_5) (C : Type u_6) [comm_ring A] [is_domain A] [field K] [algebra A K] [is_fraction_ring A K] [comm_ring C] [algebra A C] [algebra K C] [is_scalar_tower A K C] {x : C} : is_algebraic A x â†” is_algebraic K x
theorem line_map_lt_map_iff_slope_lt_slope_right {k : Type u_1} {E : Type u_2} [linear_ordered_field k] [ordered_add_comm_group E] [module k E] [ordered_smul k E] {f : k â†’ E} {a b r : k} (h : 0 < (1 - r) * (b - a)) : â‡‘(affine_map.line_map (f a) (f b)) r < f (â‡‘(affine_map.line_map a b) r) â†” slope f (â‡‘(affine_map.line_map a b) r) b < slope f a b
theorem finset.centroid_map (k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] {Î¹ : Type u_4} {Î¹â‚‚ : Type u_5} (sâ‚‚ : finset Î¹â‚‚) (e : Î¹â‚‚ â†ª Î¹) (p : Î¹ â†’ P) : finset.centroid k (finset.map e sâ‚‚) p = finset.centroid k sâ‚‚ (p âˆ˜ â‡‘e)
theorem is_of_fin_order_iff_coe {G : Type u} [monoid G] (H : submonoid G) (x : â†¥H) : is_of_fin_order x â†” is_of_fin_order â†‘x
theorem continuous_on.exists_forall_le' {Î± : Type u_1} {Î² : Type u_2} [conditionally_complete_linear_order Î±] [topological_space Î±] [order_topology Î±] [topological_space Î²] {s : set Î²} {f : Î² â†’ Î±} (hf : continuous_on f s) (hsc : is_closed s) {xâ‚€ : Î²} (hâ‚€ : xâ‚€ âˆˆ s) (hc : âˆ€á¶  (x : Î²) in filter.cocompact Î² âŠ“ filter.principal s, f xâ‚€ â‰¤ f x) : âˆƒ (x : Î²) (H : x âˆˆ s), âˆ€ (y : Î²), y âˆˆ s â†’ f x â‰¤ f y
theorem setoid.eqv_classes_of_disjoint_union {Î± : Type u_1} {c : set (set Î±)} (hu : â‹ƒâ‚€c = set.univ) (H : c.pairwise_disjoint id) (a : Î±) : âˆƒ! (b : set Î±) (H : b âˆˆ c), a âˆˆ b
theorem unique_diff_within_at_convex {G : Type u_4} [normed_group G] [normed_space â„ G] {s : set G} (conv : convex â„ s) (hs : (interior s).nonempty) {x : G} (hx : x âˆˆ closure s) : unique_diff_within_at â„ s x
theorem nat.prime_counting'_add_le {a k : â„•} (h0 : 0 < a) (h1 : a < k) (n : â„•) : (k + n).prime_counting' â‰¤ k.prime_counting' + a.totient * (n / a + 1)
theorem smooth_bump_function.exists_r_pos_lt_subset_ball {E : Type uE} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] {H : Type uH} [topological_space H] {I : model_with_corners â„ E H} {M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M] {c : M} (f : smooth_bump_function I c) {s : set M} (hsc : is_closed s) (hs : s âŠ† function.support â‡‘f) : âˆƒ (r : â„) (hr : r âˆˆ set.Ioo 0 f.to_cont_diff_bump.to_cont_diff_bump_of_inner.R), s âŠ† (charted_space.chart_at H c).to_local_equiv.source âˆ© â‡‘(ext_chart_at I c) â»Â¹' euclidean.ball (â‡‘(ext_chart_at I c) c) r
theorem parser.nat_of_done_as_digit {cb : char_buffer} {n n' val : â„•} (h : parser.nat cb n = parse_result.done n' val) (hn : n' â‰¤ buffer.size cb) (k : â„•) (hk : k < n') : n â‰¤ k â†’ '0' â‰¤ buffer.read cb âŸ¨k, _âŸ© âˆ§ buffer.read cb âŸ¨k, _âŸ© â‰¤ '9'
theorem prime_multiset.prod_zero  : 0.prod = 1
theorem setoid.eq_iff_classes_eq {Î± : Type u_1} {râ‚ râ‚‚ : setoid Î±} : râ‚ = râ‚‚ â†” âˆ€ (x : Î±), {y : Î± | râ‚.rel x y} = {y : Î± | râ‚‚.rel x y}
theorem measure_theory.is_open_pos_measure_of_mul_left_invariant_of_compact {G : Type u_1} [measurable_space G] [topological_space G] [borel_space G] {Î¼ : measure_theory.measure G} [group G] [topological_group G] [Î¼.is_mul_left_invariant] (K : set G) (hK : is_compact K) (h : â‡‘Î¼ K â‰  0) : Î¼.is_open_pos_measure
theorem exists_norm_le_le_norm_sub_of_finset {ğ•œ : Type u} [nondiscrete_normed_field ğ•œ] {E : Type v} [normed_group E] [normed_space ğ•œ E] [complete_space ğ•œ] {c : ğ•œ} (hc : 1 < âˆ¥câˆ¥) {R : â„} (hR : âˆ¥câˆ¥ < R) (h : Â¬finite_dimensional ğ•œ E) (s : finset E) : âˆƒ (x : E), âˆ¥xâˆ¥ â‰¤ R âˆ§ âˆ€ (y : E), y âˆˆ s â†’ 1 â‰¤ âˆ¥y - xâˆ¥
theorem homotopy.null_homotopic_map'_comp {Î¹ : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape Î¹} {C D E : homological_complex V c} (hom : Î  (i j : Î¹), c.rel j i â†’ (C.X i âŸ¶ D.X j)) (g : D âŸ¶ E) : homotopy.null_homotopic_map' hom â‰« g = homotopy.null_homotopic_map' (Î» (i j : Î¹) (hij : c.rel j i), hom i j hij â‰« g.f j)
theorem module.free.rank_lt_aleph_0 (R : Type u) (M : Type v) [ring R] [strong_rank_condition R] [add_comm_group M] [module R M] [module.free R M] [module.finite R M] : module.rank R M < cardinal.aleph_0
theorem filter.tendsto_pow_at_top {Î± : Type u_3} [ordered_semiring Î±] {n : â„•} (hn : 1 â‰¤ n) : filter.tendsto (Î» (x : Î±), x ^ n) filter.at_top filter.at_top
theorem set.Union_eq_Union_finset' {Î± : Type u_1} {Î¹' : Sort u_5} (s : Î¹' â†’ set Î±) : (â‹ƒ (i : Î¹'), s i) = â‹ƒ (t : finset (plift Î¹')) (i : plift Î¹') (H : i âˆˆ t), s i.down
theorem nat.arithmetic_function.sum_eq_iff_sum_smul_moebius_eq {R : Type u_1} [add_comm_group R] {f g : â„• â†’ R} : (âˆ€ (n : â„•), 0 < n â†’ n.divisors.sum (Î» (i : â„•), f i) = g n) â†” âˆ€ (n : â„•), 0 < n â†’ n.divisors_antidiagonal.sum (Î» (x : â„• Ã— â„•), â‡‘nat.arithmetic_function.moebius x.fst â€¢ g x.snd) = f n
theorem category_theory.limits.biprod.symmetry {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_binary_biproducts C] (P Q : C) : (category_theory.limits.biprod.braiding P Q).hom â‰« (category_theory.limits.biprod.braiding Q P).hom = ğŸ™ (P âŠ Q)
theorem complex.abs_deriv_le_one_of_maps_to_ball {f : â„‚ â†’ â„‚} {c : â„‚} {R : â„} (hd : differentiable_on â„‚ f (metric.ball c R)) (h_maps : set.maps_to f (metric.ball c R) (metric.ball c R)) (hc : f c = c) (hâ‚€ : 0 < R) : complex.abs (deriv f c) â‰¤ 1
theorem polynomial.X_pow_mem_lifts {R : Type u} [semiring R] {S : Type v} [semiring S] (f : R â†’+* S) (n : â„•) : polynomial.X ^ n âˆˆ polynomial.lifts f
theorem category_theory.monad.algebra_iso_of_iso {C : Type uâ‚} [category_theory.category C] (T : category_theory.monad C) {A B : T.algebra} (f : A âŸ¶ B) [category_theory.is_iso f.f] : category_theory.is_iso f
theorem monovary.sum_mul_comp_perm_eq_sum_mul_iff {Î¹ : Type u_1} {Î± : Type u_2} [linear_ordered_ring Î±] {Ïƒ : equiv.perm Î¹} {f g : Î¹ â†’ Î±} [fintype Î¹] (hfg : monovary f g) : finset.univ.sum (Î» (i : Î¹), f i * g (â‡‘Ïƒ i)) = finset.univ.sum (Î» (i : Î¹), f i * g i) â†” monovary f (g âˆ˜ â‡‘Ïƒ)
theorem inner_product_space.is_self_adjoint.has_eigenvalue_infi_of_finite_dimensional {ğ•œ : Type u_1} [is_R_or_C ğ•œ] {E : Type u_2} [inner_product_space ğ•œ E] [finite_dimensional ğ•œ E] [nontrivial E] {T : E â†’â‚—[ğ•œ] E} (hT : inner_product_space.is_self_adjoint T) : module.End.has_eigenvalue T (â†‘â¨… (x : {x // x â‰  0}), â‡‘is_R_or_C.re (has_inner.inner (â‡‘T â†‘x) â†‘x) / âˆ¥â†‘xâˆ¥ ^ 2)
theorem polynomial.leading_coeff_div_by_monic_of_monic {R : Type u} [comm_ring R] {p q : polynomial R} (hmonic : q.monic) (hdegree : q.degree â‰¤ p.degree) : (p /â‚˜ q).leading_coeff = p.leading_coeff
theorem subsemiring.subset_closure {R : Type u} [non_assoc_semiring R] {s : set R} : s âŠ† â†‘(subsemiring.closure s)
theorem measure_theory.condexp_indicator {Î± : Type u_1} {F' : Type u_7} [normed_group F'] [normed_space â„ F'] [complete_space F'] {m m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {f : Î± â†’ F'} {s : set Î±} (hf_int : measure_theory.integrable f Î¼) (hs : measurable_set s) : measure_theory.condexp m Î¼ (s.indicator f) =áµ[Î¼] s.indicator (measure_theory.condexp m Î¼ f)
theorem nat.factorization_eq_of_coprime_left {p a b : â„•} (hab : a.coprime b) (hpa : p âˆˆ a.factors) : â‡‘((a * b).factorization) p = â‡‘(a.factorization) p
theorem pnat.factor_multiset_le_iff {m n : â„•+} : m.factor_multiset â‰¤ n.factor_multiset â†” m âˆ£ n
theorem mul_eq_zero {Mâ‚€ : Type u_1} [mul_zero_class Mâ‚€] [no_zero_divisors Mâ‚€] {a b : Mâ‚€} : a * b = 0 â†” a = 0 âˆ¨ b = 0
theorem seminorm.le_insert {ğ•œ : Type u_3} {E : Type u_4} [semi_normed_ring ğ•œ] [add_comm_group E] [module ğ•œ E] (p : seminorm ğ•œ E) (x y : E) : â‡‘p y â‰¤ â‡‘p x + â‡‘p (x - y)
theorem orthonormal.oangle_smul_smul_self_of_nonneg {V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) (x : V) {râ‚ râ‚‚ : â„} (hrâ‚ : 0 â‰¤ râ‚) (hrâ‚‚ : 0 â‰¤ râ‚‚) : hb.oangle (râ‚ â€¢ x) (râ‚‚ â€¢ x) = 0
theorem continuous_linear_equiv.comp_cont_diff_within_at_iff {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {G : Type u_4} [normed_group G] [normed_space ğ•œ G] {s : set E} {f : E â†’ F} {x : E} {n : with_top â„•} (e : F â‰ƒL[ğ•œ] G) : cont_diff_within_at ğ•œ n (â‡‘e âˆ˜ f) s x â†” cont_diff_within_at ğ•œ n f s x
theorem real.sinh_arsinh (x : â„) : real.sinh (real.arsinh x) = x
theorem list.length_pos_of_sum_pos {M : Type u_3} [add_monoid M] [preorder M] (L : list M) (h : 0 < L.sum) : 0 < L.length
theorem orthogonal_family.independent {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {Î¹ : Type u_4} {V : Î¹ â†’ submodule ğ•œ E} (hV : orthogonal_family ğ•œ (Î» (i : Î¹), (V i).subtypeâ‚—áµ¢)) : complete_lattice.independent V
theorem sum_inner {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {Î¹ : Type u_3} (s : finset Î¹) (f : Î¹ â†’ E) (x : E) : has_inner.inner (s.sum (Î» (i : Î¹), f i)) x = s.sum (Î» (i : Î¹), has_inner.inner (f i) x)
theorem nonarchimedean_group.nonarchimedean_of_emb {G : Type u_1} [group G] [topological_space G] [nonarchimedean_group G] {H : Type u_2} [group H] [topological_space H] [topological_group H] (f : G â†’* H) (emb : open_embedding â‡‘f) : nonarchimedean_group H
theorem padic_val_rat.of_int {p : â„•} {z : â„¤} : padic_val_rat p â†‘z = â†‘(padic_val_int p z)
theorem submodule.fg_iff_compact {R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] (s : submodule R M) : s.fg â†” complete_lattice.is_compact_element s
theorem right.mul_lt_one' {Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_mul.mul) has_le.le] {a b : Î±} (ha : a < 1) (hb : b < 1) : a * b < 1
theorem dfinsupp.lift_add_hom_single_add_hom {Î¹ : Type u} {Î² : Î¹ â†’ Type v} [dec : decidable_eq Î¹] [Î  (i : Î¹), add_comm_monoid (Î² i)] : â‡‘dfinsupp.lift_add_hom (dfinsupp.single_add_hom Î²) = add_monoid_hom.id (Î â‚€ (i : Î¹), Î² i)
theorem measure_theory.integrable_condexp_ind_smul {Î± : Type u_1} {G : Type u_8} [normed_group G] {m m0 : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {s : set Î±} [normed_space â„ G] (hm : m â‰¤ m0) [measure_theory.sigma_finite (Î¼.trim hm)] (hs : measurable_set s) (hÎ¼s : â‡‘Î¼ s â‰  âŠ¤) (x : G) : measure_theory.integrable â‡‘(measure_theory.condexp_ind_smul hm hs hÎ¼s x) Î¼
theorem lipschitz_on_with.holder_on_with {X : Type u_1} {Y : Type u_2} [pseudo_emetric_space X] [pseudo_emetric_space Y] {C : nnreal} {f : X â†’ Y} {s : set X} : lipschitz_on_with C f s â†’ holder_on_with C 1 f s
theorem finset.sum_comp {Î² : Type u} {Î± : Type v} {Î³ : Type w} {s : finset Î±} [add_comm_monoid Î²] [decidable_eq Î³] (f : Î³ â†’ Î²) (g : Î± â†’ Î³) : s.sum (Î» (a : Î±), f (g a)) = (finset.image g s).sum (Î» (b : Î³), (finset.filter (Î» (a : Î±), g a = b) s).card â€¢ f b)
theorem zero_lt.preorder.right.mul_le_one_of_le_of_le {Î± : Type u} {a b : Î±} [mul_one_class Î±] [has_zero Î±] [preorder Î±] [zero_lt.mul_pos_mono Î±] (ha : a â‰¤ 1) (hb : b â‰¤ 1) (b0 : 0 < b) : a * b â‰¤ 1
theorem monoid_with_zero_hom.map_inv {Gâ‚€ : Type u_2} {Gâ‚€' : Type u_4} [group_with_zero Gâ‚€] [group_with_zero Gâ‚€'] (f : Gâ‚€ â†’*â‚€ Gâ‚€') (a : Gâ‚€) : â‡‘f aâ»Â¹ = (â‡‘f a)â»Â¹
theorem category_theory.limits.coprod.symmetry {C : Type u} [category_theory.category C] [category_theory.limits.has_binary_coproducts C] (P Q : C) : (category_theory.limits.coprod.braiding P Q).hom â‰« (category_theory.limits.coprod.braiding Q P).hom = ğŸ™ (P â¨¿ Q)
theorem orientation.det_rotation {V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) (Î¸ : real.angle) : â‡‘linear_map.det â†‘((o.rotation Î¸).to_linear_equiv) = 1
theorem category_theory.limits.cones.cone_iso_of_hom_iso {J : Type uâ‚} [category_theory.category J] {C : Type uâ‚ƒ} [category_theory.category C] {K : J â¥¤ C} {c d : category_theory.limits.cone K} (f : c âŸ¶ d) [i : category_theory.is_iso f.hom] : category_theory.is_iso f
theorem galois_connection.exists_eq_l {Î± : Type u} {Î² : Type v} [preorder Î±] [partial_order Î²] {l : Î± â†’ Î²} {u : Î² â†’ Î±} (gc : galois_connection l u) (b : Î²) : (âˆƒ (a : Î±), b = l a) â†” b = l (u b)
theorem set.Inter_Union_of_monotone {Î¹ : Type u_1} {Î¹' : Type u_2} {Î± : Type u_3} [fintype Î¹] [preorder Î¹'] [is_directed Î¹' (function.swap has_le.le)] [nonempty Î¹'] {s : Î¹ â†’ Î¹' â†’ set Î±} (hs : âˆ€ (i : Î¹), monotone (s i)) : (â‹‚ (j : Î¹'), â‹ƒ (i : Î¹), s i j) = â‹ƒ (i : Î¹), â‹‚ (j : Î¹'), s i j
theorem convex.average_mem {Î± : Type u_1} {E : Type u_2} {m0 : measurable_space Î±} [normed_group E] [normed_space â„ E] [complete_space E] {Î¼ : measure_theory.measure Î±} {s : set E} {f : Î± â†’ E} [measure_theory.is_finite_measure Î¼] (hs : convex â„ s) (hsc : is_closed s) (hÎ¼ : Î¼ â‰  0) (hfs : âˆ€áµ (x : Î±) âˆ‚Î¼, f x âˆˆ s) (hfi : measure_theory.integrable f Î¼) : â¨ (x : Î±), f x âˆ‚Î¼ âˆˆ s
theorem add_monoid.is_torsion_free.prod {Î· : Type u_1} {Gs : Î· â†’ Type u_2} [Î  (i : Î·), add_group (Gs i)] (tfGs : âˆ€ (i : Î·), add_monoid.is_torsion_free (Gs i)) : add_monoid.is_torsion_free (Î  (i : Î·), Gs i)
theorem module.direct_limit.exists_of {R : Type u} [ring R] {Î¹ : Type v} [dec_Î¹ : decidable_eq Î¹] [preorder Î¹] {G : Î¹ â†’ Type w} [Î  (i : Î¹), add_comm_group (G i)] [Î  (i : Î¹), module R (G i)] {f : Î  (i j : Î¹), i â‰¤ j â†’ (G i â†’â‚—[R] G j)} [nonempty Î¹] [is_directed Î¹ has_le.le] (z : module.direct_limit G f) : âˆƒ (i : Î¹) (x : G i), â‡‘(module.direct_limit.of R Î¹ G f i) x = z
theorem simple_graph.is_adj_matrix_adj_matrix {V : Type u_1} (Î± : Type u_2) (G : simple_graph V) [decidable_rel G.adj] [has_zero Î±] [has_one Î±] : (simple_graph.adj_matrix Î± G).is_adj_matrix
theorem category_theory.is_iso.of_epi_section {C : Type uâ‚} [category_theory.category C] {X Y : C} {f : X âŸ¶ Y} [category_theory.split_epi f] [category_theory.epi (category_theory.section_ f)] : category_theory.is_iso f
theorem char.quadratic_char_eq_zero_iff {F : Type u_1} [field F] [fintype F] [decidable_eq F] (a : F) : char.quadratic_char F a = 0 â†” a = 0
theorem affine_subspace.vsub_left_mem_direction_iff_mem {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : affine_subspace k P} {p : P} (hp : p âˆˆ s) (p2 : P) : p -áµ¥ p2 âˆˆ s.direction â†” p2 âˆˆ s
theorem dvd_of_mul_right_eq {Î± : Type u_1} [semigroup Î±] {a b : Î±} (c : Î±) (h : a * c = b) : a âˆ£ b
theorem compact_of_is_closed_subset {Î± : Type u} [topological_space Î±] {s t : set Î±} (hs : is_compact s) (ht : is_closed t) (h : t âŠ† s) : is_compact t
theorem continuous_inf_dom_rightâ‚‚ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} {f : Î± â†’ Î² â†’ Î³} {ta1 ta2 : topological_space Î±} {tb1 tb2 : topological_space Î²} {tc1 : topological_space Î³} (h : continuous (Î» (p : Î± Ã— Î²), f p.fst p.snd)) : continuous (Î» (p : Î± Ã— Î²), f p.fst p.snd)
theorem monoid_hom.map_one {M : Type u_3} {N : Type u_4} [mul_one_class M] [mul_one_class N] (f : M â†’* N) : â‡‘f 1 = 1
theorem measure_theory.L2.inner_indicator_const_Lp_eq_set_integral_inner {Î± : Type u_1} {E : Type u_2} (ğ•œ : Type u_4) [is_R_or_C ğ•œ] [measurable_space Î±] {Î¼ : measure_theory.measure Î±} [inner_product_space ğ•œ E] {s : set Î±} (f : â†¥(measure_theory.Lp E 2 Î¼)) (hs : measurable_set s) (c : E) (hÎ¼s : â‡‘Î¼ s â‰  âŠ¤) : has_inner.inner (measure_theory.indicator_const_Lp 2 hs hÎ¼s c) f = âˆ« (x : Î±) in s, has_inner.inner c (â‡‘f x) âˆ‚Î¼
theorem vsub_vadd {G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] (p1 p2 : P) : p1 -áµ¥ p2 +áµ¥ p2 = p1
theorem configuration.has_lines.card_le (P L : Type u) [has_mem P L] [configuration.has_lines P L] [fintype P] [fintype L] : fintype.card P â‰¤ fintype.card L
theorem euclidean_geometry.dist_eq_abs_sub_dist_of_angle_eq_zero {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {p1 p2 p3 : P} (h : euclidean_geometry.angle p1 p2 p3 = 0) : has_dist.dist p1 p3 = |has_dist.dist p1 p2 - has_dist.dist p3 p2|
theorem finset.sum_smul_vsub_const_eq_weighted_vsub_of_point_sub {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {Î¹ : Type u_4} (s : finset Î¹) (w : Î¹ â†’ k) (pâ‚ : Î¹ â†’ P) (pâ‚‚ b : P) : s.sum (Î» (i : Î¹), w i â€¢ (pâ‚ i -áµ¥ pâ‚‚)) = â‡‘(s.weighted_vsub_of_point pâ‚ b) w - s.sum (Î» (i : Î¹), w i) â€¢ (pâ‚‚ -áµ¥ b)
theorem set.countable_iff_exists_surjective_to_subtype {Î± : Type u} {s : set Î±} (hs : s.nonempty) : s.countable â†” âˆƒ (f : â„• â†’ â†¥s), function.surjective f
theorem has_strict_deriv_at_exp_of_mem_ball {ğ•‚ : Type u_1} [nondiscrete_normed_field ğ•‚] [complete_space ğ•‚] [char_zero ğ•‚] {x : ğ•‚} (hx : x âˆˆ emetric.ball 0 (exp_series ğ•‚ ğ•‚).radius) : has_strict_deriv_at (exp ğ•‚) (exp ğ•‚ x) x
theorem dense_bUnion_interior_of_closed {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [baire_space Î±] {S : set Î²} {f : Î² â†’ set Î±} (hc : âˆ€ (s : Î²), s âˆˆ S â†’ is_closed (f s)) (hS : S.countable) (hU : (â‹ƒ (s : Î²) (H : s âˆˆ S), f s) = set.univ) : dense (â‹ƒ (s : Î²) (H : s âˆˆ S), interior (f s))
theorem fin.succ_above_pred_above {n : â„•} {p : fin n} {i : fin (n + 1)} (h : i â‰  â‡‘fin.cast_succ p) : â‡‘((â‡‘fin.cast_succ p).succ_above) (p.pred_above i) = i
theorem euclidean_geometry.reflection_eq_self_iff {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace â„ P} [nonempty â†¥s] [complete_space â†¥(s.direction)] (p : P) : â‡‘(euclidean_geometry.reflection s) p = p â†” p âˆˆ s
theorem fintype.card_of_subsingleton {Î± : Type u_1} (a : Î±) [subsingleton Î±] : fintype.card Î± = 1
theorem category_theory.over.construct_products.over_products_of_wide_pullbacks {C : Type u} [category_theory.category C] [category_theory.limits.has_wide_pullbacks C] {B : C} : category_theory.limits.has_products (category_theory.over B)
theorem real_inner_div_norm_mul_norm_eq_neg_one_iff {F : Type u_3} [inner_product_space â„ F] (x y : F) : has_inner.inner x y / (âˆ¥xâˆ¥ * âˆ¥yâˆ¥) = -1 â†” x â‰  0 âˆ§ âˆƒ (r : â„), r < 0 âˆ§ y = r â€¢ x
theorem is_of_fin_add_order.add {G : Type u} {x y : G} [add_comm_monoid G] (hx : is_of_fin_add_order x) (hy : is_of_fin_add_order y) : is_of_fin_add_order (x + y)
theorem convolution_eq_swap {ğ•œ : Type u_1} {G : Type u_2} {E : Type u_3} {E' : Type u_4} {F : Type u_6} [normed_group E] [normed_group E'] [normed_group F] {f : G â†’ E} {g : G â†’ E'} {x : G} [nondiscrete_normed_field ğ•œ] [normed_space ğ•œ E] [normed_space ğ•œ E'] [normed_space ğ•œ F] (L : E â†’L[ğ•œ] E' â†’L[ğ•œ] F) [measurable_space G] {Î¼ : measure_theory.measure G} [normed_space â„ F] [complete_space F] [add_comm_group G] [topological_space G] [topological_add_group G] [borel_space G] [Î¼.is_add_left_invariant] [Î¼.is_neg_invariant] : convolution f g L Î¼ x = âˆ« (t : G), â‡‘(â‡‘L (f (x - t))) (g t) âˆ‚Î¼
theorem minpoly.not_is_unit (A : Type u_1) {B : Type u_2} [comm_ring A] [ring B] [algebra A B] (x : B) [nontrivial B] : Â¬is_unit (minpoly A x)
theorem filter.infi_ne_bot_of_directed' {Î± : Type u} {Î¹ : Sort x} {f : Î¹ â†’ filter Î±} [nonempty Î¹] (hd : directed ge f) (hb : âˆ€ (i : Î¹), (f i).ne_bot) : (infi f).ne_bot
theorem int_smul_eq_zsmul {M : Type u_5} [add_comm_group M] (h : module â„¤ M) (n : â„¤) (x : M) : n â€¢ x = n â€¢ x
theorem finset.centroid_eq_center_mass {R : Type u_1} {E : Type u_2} {Î¹ : Type u_4} [linear_ordered_field R] [add_comm_group E] [module R E] (s : finset Î¹) (hs : s.nonempty) (p : Î¹ â†’ E) : finset.centroid R s p = s.center_mass (finset.centroid_weights R s) p
theorem has_lt.lt.not_is_min {Î± : Type u_1} [preorder Î±] {a b : Î±} (h : b < a) : Â¬is_min a
theorem local_homeomorph.continuous_at_iff_continuous_at_comp_left {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [topological_space Î±] [topological_space Î²] [topological_space Î³] (e : local_homeomorph Î± Î²) {f : Î³ â†’ Î±} {x : Î³} (h : f â»Â¹' e.to_local_equiv.source âˆˆ nhds x) : continuous_at f x â†” continuous_at (â‡‘e âˆ˜ f) x
theorem sub_nonneg_of_le {Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±} : b â‰¤ a â†’ 0 â‰¤ a - b
theorem path.truncate_continuous_family {X : Type u_1} [topological_space X] {a b : X} (Î³ : path a b) : continuous (Î» (x : â„ Ã— â„ Ã— â†¥unit_interval), â‡‘(Î³.truncate x.fst x.snd.fst) x.snd.snd)
theorem mfderiv_eq_fderiv {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {E' : Type u_3} [normed_group E'] [normed_space ğ•œ E'] {f : E â†’ E'} {x : E} : mfderiv (model_with_corners_self ğ•œ E) (model_with_corners_self ğ•œ E') f x = fderiv ğ•œ f x
theorem is_complete.nonempty_Inter_of_nonempty_bInter {Î± : Type u} [pseudo_metric_space Î±] {s : â„• â†’ set Î±} (h0 : is_complete (s 0)) (hs : âˆ€ (n : â„•), is_closed (s n)) (h's : âˆ€ (n : â„•), metric.bounded (s n)) (h : âˆ€ (N : â„•), (â‹‚ (n : â„•) (H : n â‰¤ N), s n).nonempty) (h' : filter.tendsto (Î» (n : â„•), metric.diam (s n)) filter.at_top (nhds 0)) : (â‹‚ (n : â„•), s n).nonempty
theorem compact_open_separated_mul_right {G : Type w} [topological_space G] [group G] [topological_group G] {K U : set G} (hK : is_compact K) (hU : is_open U) (hKU : K âŠ† U) : âˆƒ (V : set G) (H : V âˆˆ nhds 1), K * V âŠ† U
theorem ideal.subset_union_prime {Î¹ : Type u_1} {R : Type u} [comm_ring R] {s : finset Î¹} {f : Î¹ â†’ ideal R} (a b : Î¹) (hp : âˆ€ (i : Î¹), i âˆˆ s â†’ i â‰  a â†’ i â‰  b â†’ (f i).is_prime) {I : ideal R} : (â†‘I âŠ† â‹ƒ (i : Î¹) (H : i âˆˆ â†‘s), â†‘(f i)) â†” âˆƒ (i : Î¹) (H : i âˆˆ s), I â‰¤ f i
theorem intermediate_field.algebra_map_mem {K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) (x : K) : â‡‘(algebra_map K L) x âˆˆ S
theorem list.next_or_eq_next_or_of_mem_of_ne {Î± : Type u_1} [decidable_eq Î±] (xs : list Î±) (x d d' : Î±) (x_mem : x âˆˆ xs) (x_ne : x â‰  xs.last _) : xs.next_or x d = xs.next_or x d'
theorem is_preconnected.intermediate_value {X : Type u} {Î± : Type v} [topological_space X] [linear_order Î±] [topological_space Î±] [order_closed_topology Î±] {s : set X} (hs : is_preconnected s) {a b : X} (ha : a âˆˆ s) (hb : b âˆˆ s) {f : X â†’ Î±} (hf : continuous_on f s) : set.Icc (f a) (f b) âŠ† f '' s
theorem basis.mk_coord_apply_eq {Î¹ : Type u_1} {R : Type u_3} {M : Type u_5} {v : Î¹ â†’ M} [ring R] [add_comm_group M] [module R M] {hli : linear_independent R v} {hsp : submodule.span R (set.range v) = âŠ¤} (i : Î¹) : â‡‘((basis.mk hli hsp).coord i) (v i) = 1
theorem multiset.Icc_eq_zero {Î± : Type u_1} [preorder Î±] [locally_finite_order Î±] {a b : Î±} : Â¬a â‰¤ b â†’ multiset.Icc a b = 0
theorem add_monoid_hom.congr_fun {M : Type u_3} {N : Type u_4} [add_zero_class M] [add_zero_class N] {f g : M â†’+ N} (h : f = g) (x : M) : â‡‘f x = â‡‘g x
theorem euclidean_geometry.mul_dist_eq_mul_dist_of_cospherical_of_angle_eq_zero {V : Type u_1} [inner_product_space â„ V] {P : Type u_2} [metric_space P] [normed_add_torsor V P] {a b c d p : P} (h : euclidean_geometry.cospherical {a, b, c, d}) (hab : a â‰  b) (hcd : c â‰  d) (hapb : euclidean_geometry.angle a p b = 0) (hcpd : euclidean_geometry.angle c p d = 0) : has_dist.dist a p * has_dist.dist b p = has_dist.dist c p * has_dist.dist d p
theorem one_le_pow_mul_abs_eval_div {K : Type u_1} [linear_ordered_field K] {f : polynomial â„¤} {a b : â„¤} (b0 : 0 < b) (fab : polynomial.eval (â†‘a / â†‘b) (polynomial.map (algebra_map â„¤ K) f) â‰  0) : 1 â‰¤ â†‘b ^ f.nat_degree * |polynomial.eval (â†‘a / â†‘b) (polynomial.map (algebra_map â„¤ K) f)|
theorem antitone.pairwise_disjoint_on_Ioo_succ {Î± : Type u_1} {Î² : Type u_2} [linear_order Î±] [succ_order Î±] [preorder Î²] {f : Î± â†’ Î²} (hf : antitone f) : pairwise (disjoint on Î» (n : Î±), set.Ioo (f (order.succ n)) (f n))
theorem pnat.factor_multiset_of_prime (p : nat.primes) : â†‘p.factor_multiset = prime_multiset.of_prime p
theorem units.coe_neg {Î± : Type u} [ring Î±] (u : Î±Ë£) : â†‘-u = -â†‘u
theorem con.con_gen_idem {M : Type u_1} [has_mul M] (r : M â†’ M â†’ Prop) : con_gen â‡‘(con_gen r) = con_gen r
theorem measure_theory.measure_limsup_eq_zero {Î± : Type u_1} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {s : â„• â†’ set Î±} (hs : âˆ‘' (i : â„•), â‡‘Î¼ (s i) â‰  âŠ¤) : â‡‘Î¼ (filter.at_top.limsup s) = 0
theorem algebra.discr_power_basis_eq_prod' (K : Type u) {L : Type v} (E : Type z) [field K] [field L] [field E] [algebra K L] [algebra K E] [module.finite K L] [is_alg_closed E] (pb : power_basis K L) [is_separable K L] (e : fin pb.dim â‰ƒ (L â†’â‚[K] E)) : â‡‘(algebra_map K E) (algebra.discr K â‡‘(pb.basis)) = finset.univ.prod (Î» (i : fin pb.dim), (finset.filter (Î» (j : fin pb.dim), i < j) finset.univ).prod (Î» (j : fin pb.dim), -((â‡‘(â‡‘e j) pb.gen - â‡‘(â‡‘e i) pb.gen) * (â‡‘(â‡‘e i) pb.gen - â‡‘(â‡‘e j) pb.gen))))
theorem metric.emetric_closed_ball {Î± : Type u} [pseudo_metric_space Î±] {x : Î±} {Îµ : â„} (h : 0 â‰¤ Îµ) : emetric.closed_ball x (ennreal.of_real Îµ) = metric.closed_ball x Îµ
theorem power_basis.finite_dimensional {S : Type u_2} [comm_ring S] {K : Type u_6} [field K] [algebra K S] (pb : power_basis K S) : finite_dimensional K S
theorem is_primitive_root.nth_roots_one_eq_bUnion_primitive_roots' {R : Type u_5} [comm_ring R] [is_domain R] {Î¶ : R} {n : â„•+} (h : is_primitive_root Î¶ â†‘n) : polynomial.nth_roots_finset â†‘n R = â†‘n.divisors.bUnion (Î» (i : â„•), primitive_roots i R)
theorem measure_theory.ae_disjoint.exists_disjoint_diff {Î± : Type u_2} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {s t : set Î±} (h : measure_theory.ae_disjoint Î¼ s t) : âˆƒ (u : set Î±), measurable_set u âˆ§ â‡‘Î¼ u = 0 âˆ§ disjoint (s  u) t
theorem add_lt_of_lt_sub_left {Î± : Type u} [add_comm_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b c : Î±} : b < c - a â†’ a + b < c
theorem add_monoid.exists_list_of_mem_closure {M : Type u_1} [add_monoid M] {s : set M} {a : M} (h : a âˆˆ add_monoid.closure s) : âˆƒ (l : list M), (âˆ€ (x : M), x âˆˆ l â†’ x âˆˆ s) âˆ§ l.sum = a
theorem dense_iff_exists_between {Î± : Type u} [topological_space Î±] [linear_order Î±] [order_topology Î±] [densely_ordered Î±] [nontrivial Î±] {s : set Î±} : dense s â†” âˆ€ (a b : Î±), a < b â†’ (âˆƒ (c : Î±) (H : c âˆˆ s), a < c âˆ§ c < b)
theorem caratheodory.mem_convex_hull_erase {ğ•œ : Type u_1} {E : Type u} [linear_ordered_field ğ•œ] [add_comm_group E] [module ğ•œ E] [decidable_eq E] {t : finset E} (h : Â¬affine_independent ğ•œ coe) {x : E} (m : x âˆˆ â‡‘(convex_hull ğ•œ) â†‘t) : âˆƒ (y : â†¥â†‘t), x âˆˆ â‡‘(convex_hull ğ•œ) â†‘(t.erase â†‘y)
theorem inv_lt {Î± : Type u_1} [linear_ordered_field Î±] {a b : Î±} (ha : 0 < a) (hb : 0 < b) : aâ»Â¹ < b â†” bâ»Â¹ < a
theorem cont_diff.dimH_range_le {E : Type u_4} {F : Type u_5} [normed_group E] [normed_space â„ E] [finite_dimensional â„ E] [normed_group F] [normed_space â„ F] {f : E â†’ F} (h : cont_diff â„ 1 f) : dimH (set.range f) â‰¤ â†‘(finite_dimensional.finrank â„ E)
theorem nat.mem_factors_mul_left {p a b : â„•} (hpa : p âˆˆ a.factors) (hb : b â‰  0) : p âˆˆ (a * b).factors
theorem subgroup.card_subgroup_dvd_card {Î± : Type u_1} [group Î±] [fintype Î±] (s : subgroup Î±) [fintype â†¥s] : fintype.card â†¥s âˆ£ fintype.card Î±
theorem submodule.mem_supr_iff_exists_dfinsupp' {Î¹ : Type u_1} {R : Type u_2} {N : Type u_5} [dec_Î¹ : decidable_eq Î¹] [semiring R] [add_comm_monoid N] [module R N] (p : Î¹ â†’ submodule R N) [Î  (i : Î¹) (x : â†¥(p i)), decidable (x â‰  0)] (x : N) : x âˆˆ supr p â†” âˆƒ (f : Î â‚€ (i : Î¹), â†¥(p i)), f.sum (Î» (i : Î¹) (xi : â†¥(p i)), â†‘xi) = x
theorem category_theory.functor.pi_ext {I : Type wâ‚€} {C : I â†’ Type uâ‚} [Î  (i : I), category_theory.category (C i)] {A : Type uâ‚} [category_theory.category A] (f f' : A â¥¤ Î  (i : I), C i) (h : âˆ€ (i : I), f â‹™ category_theory.pi.eval C i = f' â‹™ category_theory.pi.eval C i) : f = f'
theorem Top.presheaf.covering_of_presieve.first_obj_iso_comp_left_res_eq {C : Type u} [category_theory.category C] [category_theory.limits.has_products C] {X : Top} (F : Top.presheaf C X) (U : topological_space.opens â†¥X) (R : category_theory.presieve U) : category_theory.presheaf.first_map R F â‰« (Top.presheaf.covering_of_presieve.second_obj_iso_pi_inters F U R).hom = (Top.presheaf.covering_of_presieve.first_obj_iso_pi_opens F U R).hom â‰« Top.presheaf.sheaf_condition_equalizer_products.left_res F (Top.presheaf.covering_of_presieve U R)
theorem exists_Union_ball_eq_radius_lt {Î± : Type u} {Î¹ : Type v} [metric_space Î±] [proper_space Î±] {c : Î¹ â†’ Î±} {r : Î¹ â†’ â„} (uf : âˆ€ (x : Î±), {i : Î¹ | x âˆˆ metric.ball (c i) (r i)}.finite) (uU : (â‹ƒ (i : Î¹), metric.ball (c i) (r i)) = set.univ) : âˆƒ (r' : Î¹ â†’ â„), (â‹ƒ (i : Î¹), metric.ball (c i) (r' i)) = set.univ âˆ§ âˆ€ (i : Î¹), r' i < r i
theorem strict_order.cof_nonempty {Î± : Type u_1} (r : Î± â†’ Î± â†’ Prop) [is_irrefl Î± r] : {c : cardinal | âˆƒ (S : set Î±), set.unbounded r S âˆ§ cardinal.mk â†¥S = c}.nonempty
theorem zsmul_eq_smul_cast (R : Type u_2) {M : Type u_5} [ring R] [add_comm_group M] [module R M] (n : â„¤) (b : M) : n â€¢ b = â†‘n â€¢ b
theorem filter.has_basis.mem_lift_iff {Î± : Type u_1} {Î³ : Type u_3} {Î¹ : Sort u_2} {p : Î¹ â†’ Prop} {s : Î¹ â†’ set Î±} {f : filter Î±} (hf : f.has_basis p s) {Î² : Î¹ â†’ Type u_4} {pg : Î  (i : Î¹), Î² i â†’ Prop} {sg : Î  (i : Î¹), Î² i â†’ set Î³} {g : set Î± â†’ filter Î³} (hg : âˆ€ (i : Î¹), (g (s i)).has_basis (pg i) (sg i)) (gm : monotone g) {s_1 : set Î³} : s_1 âˆˆ f.lift g â†” âˆƒ (i : Î¹) (hi : p i) (x : Î² i) (hx : pg i x), sg i x âŠ† s_1
theorem module.free.rank_finsupp' (R : Type u) [ring R] [strong_rank_condition R] {Î¹ : Type u} : module.rank R (Î¹ â†’â‚€ R) = cardinal.mk Î¹
theorem complete_lattice.Iic_coatomic_of_compact_element {Î± : Type u_1} [complete_lattice Î±] {k : Î±} (h : complete_lattice.is_compact_element k) : is_coatomic â†¥(set.Iic k)
theorem set.sized.subset_powerset_len_univ {Î± : Type u_1} [fintype Î±] {ğ’œ : finset (finset Î±)} {r : â„•} : set.sized r â†‘ğ’œ â†’ ğ’œ âŠ† finset.powerset_len r finset.univ
theorem subsemigroup.closure_inductionâ‚‚ {M : Type u_1} [has_mul M] {s : set M} {p : M â†’ M â†’ Prop} {x y : M} (hx : x âˆˆ subsemigroup.closure s) (hy : y âˆˆ subsemigroup.closure s) (Hs : âˆ€ (x : M), x âˆˆ s â†’ âˆ€ (y : M), y âˆˆ s â†’ p x y) (Hmul_left : âˆ€ (x y z : M), p x z â†’ p y z â†’ p (x * y) z) (Hmul_right : âˆ€ (x y z : M), p z x â†’ p z y â†’ p z (x * y)) : p x y
theorem affine_subspace.span_empty (k : Type u_1) (V : Type u_2) (P : Type u_3) [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] : affine_span k âˆ… = âŠ¥
theorem set.Inter_Union_of_antitone {Î¹ : Type u_1} {Î¹' : Type u_2} {Î± : Type u_3} [fintype Î¹] [preorder Î¹'] [is_directed Î¹' has_le.le] [nonempty Î¹'] {s : Î¹ â†’ Î¹' â†’ set Î±} (hs : âˆ€ (i : Î¹), antitone (s i)) : (â‹‚ (j : Î¹'), â‹ƒ (i : Î¹), s i j) = â‹ƒ (i : Î¹), â‹‚ (j : Î¹'), s i j
theorem euclidean_geometry.cospherical.affine_independent {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {s : set P} (hs : euclidean_geometry.cospherical s) {p : fin 3 â†’ P} (hps : set.range p âŠ† s) (hpi : function.injective p) : affine_independent â„ p
theorem not_is_left_regular_zero_iff {R : Type u_1} [mul_zero_class R] : Â¬is_left_regular 0 â†” nontrivial R
theorem is_compact.bounded {Î± : Type u} [pseudo_metric_space Î±] {s : set Î±} (h : is_compact s) : metric.bounded s
theorem holor.sum_unit_vec_mul_slice {Î± : Type} {d : â„•} {ds : list â„•} [ring Î±] (x : holor Î± (d :: ds)) : (finset.range d).attach.sum (Î» (i : {x // x âˆˆ finset.range d}), (holor.unit_vec d â†‘i).mul (x.slice â†‘i _)) = x
theorem category_theory.cosimplicial_object.Î´_comp_Ïƒ_succ {C : Type u} [category_theory.category C] (X : category_theory.cosimplicial_object C) {n : â„•} {i : fin (n + 1)} : X.Î´ i.succ â‰« X.Ïƒ i = ğŸ™ (X.obj (simplex_category.mk n))
theorem category_theory.id_cover_preserving {C : Type uâ‚} [category_theory.category C] (J : category_theory.grothendieck_topology C) : category_theory.cover_preserving J J (ğŸ­ C)
theorem set.finite.bdd_above {Î± : Type u} [semilattice_sup Î±] [nonempty Î±] {s : set Î±} (hs : s.finite) : bdd_above s
theorem polynomial.degree_multiset_prod {R : Type u} [comm_semiring R] [no_zero_divisors R] (t : multiset (polynomial R)) [nontrivial R] : t.prod.degree = (multiset.map (Î» (f : polynomial R), f.degree) t).sum
theorem category_theory.essentially_small_iff_of_thin {C : Type u} [category_theory.category C] [âˆ€ (X Y : C), subsingleton (X âŸ¶ Y)] : category_theory.essentially_small C â†” small (category_theory.skeleton C)
theorem dite_not {Î± : Sort u_1} (P : Prop) [decidable P] (x : Â¬P â†’ Î±) (y : Â¬Â¬P â†’ Î±) : dite (Â¬P) x y = dite P (Î» (h : P), y _) x
theorem subring.closure_eq {R : Type u} [ring R] (s : subring R) : subring.closure â†‘s = s
theorem algebra.adjoin_inductionâ‚‚ {R : Type u} {A : Type v} [comm_semiring R] [semiring A] [algebra R A] {s : set A} {p : A â†’ A â†’ Prop} {a b : A} (ha : a âˆˆ algebra.adjoin R s) (hb : b âˆˆ algebra.adjoin R s) (Hs : âˆ€ (x : A), x âˆˆ s â†’ âˆ€ (y : A), y âˆˆ s â†’ p x y) (Halg : âˆ€ (râ‚ râ‚‚ : R), p (â‡‘(algebra_map R A) râ‚) (â‡‘(algebra_map R A) râ‚‚)) (Halg_left : âˆ€ (r : R) (x : A), x âˆˆ s â†’ p (â‡‘(algebra_map R A) r) x) (Halg_right : âˆ€ (r : R) (x : A), x âˆˆ s â†’ p x (â‡‘(algebra_map R A) r)) (Hadd_left : âˆ€ (xâ‚ xâ‚‚ y : A), p xâ‚ y â†’ p xâ‚‚ y â†’ p (xâ‚ + xâ‚‚) y) (Hadd_right : âˆ€ (x yâ‚ yâ‚‚ : A), p x yâ‚ â†’ p x yâ‚‚ â†’ p x (yâ‚ + yâ‚‚)) (Hmul_left : âˆ€ (xâ‚ xâ‚‚ y : A), p xâ‚ y â†’ p xâ‚‚ y â†’ p (xâ‚ * xâ‚‚) y) (Hmul_right : âˆ€ (x yâ‚ yâ‚‚ : A), p x yâ‚ â†’ p x yâ‚‚ â†’ p x (yâ‚ * yâ‚‚)) : p a b
theorem filter.supr_ultrafilter_le_eq {Î± : Type u} (f : filter Î±) : (â¨† (g : ultrafilter Î±) (hg : â†‘g â‰¤ f), â†‘g) = f
theorem inner_product_geometry.norm_eq_of_angle_sub_eq_angle_sub_rev_of_angle_ne_pi {V : Type u_1} [inner_product_space â„ V] {x y : V} (h : inner_product_geometry.angle x (x - y) = inner_product_geometry.angle y (y - x)) (hpi : inner_product_geometry.angle x y â‰  real.pi) : âˆ¥xâˆ¥ = âˆ¥yâˆ¥
theorem multiple_mem_span_of_mem_localization_span {R S : Type u} [comm_ring R] [comm_ring S] (M : submonoid R) (R' : Type u) [comm_ring R'] [algebra R R'] [algebra R' S] [algebra R S] [is_scalar_tower R R' S] [is_localization M R'] (s : set S) (x : S) (hx : x âˆˆ submodule.span R' s) : âˆƒ (t : â†¥M), t â€¢ x âˆˆ submodule.span R s
theorem category_theory.grothendieck_topology.plus.is_sheaf_plus_plus {C : Type u} [category_theory.category C] (J : category_theory.grothendieck_topology C) {D : Type w} [category_theory.category D] [category_theory.concrete_category D] [category_theory.limits.preserves_limits (category_theory.forget D)] [âˆ€ (X : C), category_theory.limits.has_colimits_of_shape (J.cover X)áµ’áµ– D] [âˆ€ (P : Cáµ’áµ– â¥¤ D) (X : C) (S : J.cover X), category_theory.limits.has_multiequalizer (S.index P)] [Î  (X : C), category_theory.limits.preserves_colimits_of_shape (J.cover X)áµ’áµ– (category_theory.forget D)] [category_theory.reflects_isomorphisms (category_theory.forget D)] (P : Cáµ’áµ– â¥¤ D) : category_theory.presheaf.is_sheaf J (J.plus_obj (J.plus_obj P))
theorem formal_multilinear_series.left_inv_remove_zero {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] (p : formal_multilinear_series ğ•œ E F) (i : E â‰ƒL[ğ•œ] F) : p.remove_zero.left_inv i = p.left_inv i
theorem Top.presheaf.presieve_of_covering.fork_Î¹_comp_pi_opens_to_first_obj_to_pi_opens_eq {C : Type u} [category_theory.category C] [category_theory.limits.has_products C] {X : Top} (F : Top.presheaf C X) {Î¹ : Type v} (U : Î¹ â†’ topological_space.opens â†¥X) (s : category_theory.limits.fork (Top.presheaf.sheaf_condition_equalizer_products.left_res F U) (Top.presheaf.sheaf_condition_equalizer_products.right_res F U)) : s.Î¹ â‰« Top.presheaf.presieve_of_covering.pi_opens_to_first_obj F U â‰« Top.presheaf.presieve_of_covering.first_obj_to_pi_opens F U = s.Î¹
theorem monoid_algebra.ring_hom_ext {k : Type uâ‚} {G : Type uâ‚‚} {R : Type u_1} [semiring k] [mul_one_class G] [semiring R] {f g : monoid_algebra k G â†’+* R} (hâ‚ : âˆ€ (b : k), â‡‘f (finsupp.single 1 b) = â‡‘g (finsupp.single 1 b)) (h_of : âˆ€ (a : G), â‡‘f (finsupp.single a 1) = â‡‘g (finsupp.single a 1)) : f = g
theorem measure_theory.measure.prod_eq {Î± : Type u_1} {Î² : Type u_3} [measurable_space Î±] [measurable_space Î²] {Î¼ : measure_theory.measure Î±} {Î½ : measure_theory.measure Î²} [measure_theory.sigma_finite Î½] [measure_theory.sigma_finite Î¼] {Î¼Î½ : measure_theory.measure (Î± Ã— Î²)} (h : âˆ€ (s : set Î±) (t : set Î²), measurable_set s â†’ measurable_set t â†’ â‡‘Î¼Î½ (s Ã—Ë¢ t) = â‡‘Î¼ s * â‡‘Î½ t) : Î¼.prod Î½ = Î¼Î½
theorem csupr_mono {Î± : Type u_1} {Î¹ : Sort u_3} [conditionally_complete_lattice Î±] {f g : Î¹ â†’ Î±} (B : bdd_above (set.range g)) (H : âˆ€ (x : Î¹), f x â‰¤ g x) : supr f â‰¤ supr g
theorem add_con.zsmul {M : Type u_1} [add_group M] (c : add_con M) (n : â„¤) {w x : M} : â‡‘c w x â†’ â‡‘c (n â€¢ w) (n â€¢ x)
theorem cont_diff_on.cont_mdiff_on {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {E' : Type u_5} [normed_group E'] [normed_space ğ•œ E'] {n : with_top â„•} {f : E â†’ E'} {s : set E} : cont_diff_on ğ•œ n f s â†’ cont_mdiff_on (model_with_corners_self ğ•œ E) (model_with_corners_self ğ•œ E') n f s
theorem mul_smul_comm {Î± : Type u_6} {Î² : Type u_7} [has_mul Î²] [has_scalar Î± Î²] [smul_comm_class Î± Î² Î²] (s : Î±) (x y : Î²) : x * s â€¢ y = s â€¢ (x * y)
theorem closure_operator_gi_self {Î± : Type u_1} [partial_order Î±] (c : closure_operator Î±) : _.closure_operator = c
theorem well_founded.is_sup_closed_compact (Î± : Type u_1) [complete_lattice Î±] : well_founded gt â†’ complete_lattice.is_sup_closed_compact Î±
theorem affine.simplex.range_face_points {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {n : â„•} (s : affine.simplex k P n) {fs : finset (fin (n + 1))} {m : â„•} (h : fs.card = m + 1) : set.range (s.face h).points = s.points '' â†‘fs
theorem lipschitz_on_with.dimH_image_le {X : Type u_2} {Y : Type u_3} [emetric_space X] [emetric_space Y] {K : nnreal} {f : X â†’ Y} {s : set X} (h : lipschitz_on_with K f s) : dimH (f '' s) â‰¤ dimH s
theorem finite_dimensional.nontrivial_of_finrank_pos {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] (h : 0 < finite_dimensional.finrank K V) : nontrivial V
theorem set.subsingleton.dimH_zero {X : Type u_2} [emetric_space X] {s : set X} (h : s.subsingleton) : dimH s = 0
theorem tfae_mem_nhds_within_Ioi {Î± : Type u} [topological_space Î±] [linear_order Î±] [order_topology Î±] {a b : Î±} (hab : a < b) (s : set Î±) : [s âˆˆ nhds_within a (set.Ioi a), s âˆˆ nhds_within a (set.Ioc a b), s âˆˆ nhds_within a (set.Ioo a b), âˆƒ (u : Î±) (H : u âˆˆ set.Ioc a b), set.Ioo a u âŠ† s, âˆƒ (u : Î±) (H : u âˆˆ set.Ioi a), set.Ioo a u âŠ† s].tfae
theorem algebra.discr_is_unit_of_basis {Î¹ : Type w} [fintype Î¹] (K : Type u) {L : Type v} [field K] [field L] [algebra K L] [module.finite K L] [is_separable K L] (b : basis Î¹ K L) : is_unit (algebra.discr K â‡‘b)
theorem smul_unit_ball_of_pos {E : Type u_2} [semi_normed_group E] [normed_space â„ E] {r : â„} (hr : 0 < r) : r â€¢ metric.ball 0 1 = metric.ball 0 r
theorem orthonormal.inner_right_finsupp {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {Î¹ : Type u_4} {v : Î¹ â†’ E} (hv : orthonormal ğ•œ v) (l : Î¹ â†’â‚€ ğ•œ) (i : Î¹) : has_inner.inner (v i) (â‡‘(finsupp.total Î¹ E ğ•œ v) l) = â‡‘l i
theorem ite_not {Î± : Sort u_1} (P : Prop) [decidable P] (a b : Î±) : ite (Â¬P) a b = ite P b a
theorem is_chain.symm {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} {s : set Î±} (h : is_chain r s) : is_chain (flip r) s
theorem emetric.Hausdorff_edist_le_of_inf_edist {Î± : Type u} [pseudo_emetric_space Î±] {s t : set Î±} {r : ennreal} (H1 : âˆ€ (x : Î±), x âˆˆ s â†’ emetric.inf_edist x t â‰¤ r) (H2 : âˆ€ (x : Î±), x âˆˆ t â†’ emetric.inf_edist x s â‰¤ r) : emetric.Hausdorff_edist s t â‰¤ r
theorem linear_map.comp_multilinear_map_alternatization {R : Type u_1} [semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {N' : Type u_5} [add_comm_group N'] [module R N'] {Î¹ : Type u_6} [decidable_eq Î¹] {N'â‚‚ : Type u_7} [add_comm_group N'â‚‚] [module R N'â‚‚] [fintype Î¹] (g : N' â†’â‚—[R] N'â‚‚) (f : multilinear_map R (Î» (_x : Î¹), M) N') : â‡‘multilinear_map.alternatization (g.comp_multilinear_map f) = â‡‘(g.comp_alternating_map) (â‡‘multilinear_map.alternatization f)
theorem uniform_embedding.to_isometry {Î± : Type u_1} {Î² : Type u_2} [uniform_space Î±] [metric_space Î²] {f : Î± â†’ Î²} (h : uniform_embedding f) : isometry f
theorem asymptotics.is_o_of_tendsto' {Î± : Type u_1} {ğ•œ : Type u_14} [normed_field ğ•œ] {l : filter Î±} {f g : Î± â†’ ğ•œ} (hgf : âˆ€á¶  (x : Î±) in l, g x = 0 â†’ f x = 0) : filter.tendsto (Î» (x : Î±), f x / g x) l (nhds 0) â†’ f =o[l] g
theorem is_antichain.sperner {Î± : Type u_2} [fintype Î±] {ğ’œ : finset (finset Î±)} (hğ’œ : is_antichain has_subset.subset â†‘ğ’œ) : ğ’œ.card â‰¤ (fintype.card Î±).choose (fintype.card Î± / 2)
theorem is_primitive_root.totient_le_degree_minpoly {n : â„•} {K : Type u_8} [field K] {Î¼ : K} (h : is_primitive_root Î¼ n) [char_zero K] : n.totient â‰¤ (minpoly â„¤ Î¼).nat_degree
theorem finset.card_mul_le_card_shadow_mul {Î± : Type u_2} [decidable_eq Î±] [fintype Î±] {ğ’œ : finset (finset Î±)} {r : â„•} (hğ’œ : set.sized r â†‘ğ’œ) : ğ’œ.card * r â‰¤ ğ’œ.shadow.card * (fintype.card Î± - r + 1)
theorem ennreal.sub_top {a : ennreal} : a - âŠ¤ = 0
theorem module.equiv_direct_sum_of_is_torsion {R : Type u} [comm_ring R] [is_domain R] [is_principal_ideal_ring R] {N : Type (max u v)} [add_comm_group N] [module R N] [h' : module.finite R N] (hN : module.is_torsion R N) : âˆƒ (Î¹ : Type u) [_inst_8 : fintype Î¹] (p : Î¹ â†’ R) [_inst_9 : âˆ€ (i : Î¹), irreducible (p i)] (e : Î¹ â†’ â„•), nonempty (N â‰ƒâ‚—[R] direct_sum Î¹ (Î» (i : Î¹), R â§¸ submodule.span R {p i ^ e i}))
theorem vadd_mem_span_points_of_mem_span_points_of_mem_vector_span (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {s : set P} {p : P} {v : V} (hp : p âˆˆ span_points k s) (hv : v âˆˆ vector_span k s) : v +áµ¥ p âˆˆ span_points k s
theorem set.pairwise_disjoint.countable_of_nonempty_interior {Î± : Type u} [t : topological_space Î±] [topological_space.separable_space Î±] {Î¹ : Type u_1} {s : Î¹ â†’ set Î±} {a : set Î¹} (h : a.pairwise_disjoint s) (ha : âˆ€ (i : Î¹), i âˆˆ a â†’ (interior (s i)).nonempty) : a.countable
theorem category_theory.concrete_category.mono_of_injective {C : Type v} [category_theory.category C] [category_theory.concrete_category C] {X Y : C} (f : X âŸ¶ Y) (i : function.injective â‡‘f) : category_theory.mono f
theorem affine_subspace.coe_injective {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] : function.injective coe
theorem is_cyclic_of_subgroup_is_domain {R : Type u_1} {G : Type u_2} [comm_ring R] [is_domain R] [group G] [fintype G] (f : G â†’* R) (hf : function.injective â‡‘f) : is_cyclic G
theorem Top.range_pullback_map {W X Y Z S T : Top} (fâ‚ : W âŸ¶ S) (fâ‚‚ : X âŸ¶ S) (gâ‚ : Y âŸ¶ T) (gâ‚‚ : Z âŸ¶ T) (iâ‚ : W âŸ¶ Y) (iâ‚‚ : X âŸ¶ Z) (iâ‚ƒ : S âŸ¶ T) [Hâ‚ƒ : category_theory.mono iâ‚ƒ] (eqâ‚ : fâ‚ â‰« iâ‚ƒ = iâ‚ â‰« gâ‚) (eqâ‚‚ : fâ‚‚ â‰« iâ‚ƒ = iâ‚‚ â‰« gâ‚‚) : set.range â‡‘(category_theory.limits.pullback.map fâ‚ fâ‚‚ gâ‚ gâ‚‚ iâ‚ iâ‚‚ iâ‚ƒ eqâ‚ eqâ‚‚) = â‡‘category_theory.limits.pullback.fst â»Â¹' set.range â‡‘iâ‚ âˆ© â‡‘category_theory.limits.pullback.snd â»Â¹' set.range â‡‘iâ‚‚
theorem finset.exists_sum_fiber_le_of_maps_to_of_sum_le_nsmul {Î± : Type u} {Î² : Type v} {M : Type w} [decidable_eq Î²] {s : finset Î±} {t : finset Î²} {f : Î± â†’ Î²} {w : Î± â†’ M} {b : M} [linear_ordered_cancel_add_comm_monoid M] (hf : âˆ€ (a : Î±), a âˆˆ s â†’ f a âˆˆ t) (ht : t.nonempty) (hb : s.sum (Î» (x : Î±), w x) â‰¤ t.card â€¢ b) : âˆƒ (y : Î²) (H : y âˆˆ t), (finset.filter (Î» (x : Î±), f x = y) s).sum (Î» (x : Î±), w x) â‰¤ b
theorem euclidean_geometry.reflection_involutive {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] (s : affine_subspace â„ P) [nonempty â†¥s] [complete_space â†¥(s.direction)] : function.involutive â‡‘(euclidean_geometry.reflection s)
theorem inner_product_geometry.angle_add_angle_sub_add_angle_sub_eq_pi {V : Type u_1} [inner_product_space â„ V] {x y : V} (hx : x â‰  0) (hy : y â‰  0) : inner_product_geometry.angle x y + inner_product_geometry.angle x (x - y) + inner_product_geometry.angle y (y - x) = real.pi
theorem affine.simplex.centroid_eq_affine_combination_of_points_with_circumcenter {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {n : â„•} (s : affine.simplex â„ P n) (fs : finset (fin (n + 1))) : finset.centroid â„ fs s.points = â‡‘(finset.univ.affine_combination s.points_with_circumcenter) (affine.simplex.centroid_weights_with_circumcenter fs)
theorem finset.sum_card_slice_div_choose_le_one {ğ•œ : Type u_1} {Î± : Type u_2} [linear_ordered_field ğ•œ] {ğ’œ : finset (finset Î±)} [fintype Î±] (hğ’œ : is_antichain has_subset.subset â†‘ğ’œ) : (finset.range (fintype.card Î± + 1)).sum (Î» (r : â„•), â†‘((ğ’œ.slice r).card) / â†‘((fintype.card Î±).choose r)) â‰¤ 1
theorem le_gronwall_bound_of_liminf_deriv_right_le {f f' : â„ â†’ â„} {Î´ K Îµ a b : â„} (hf : continuous_on f (set.Icc a b)) (hf' : âˆ€ (x : â„), x âˆˆ set.Ico a b â†’ âˆ€ (r : â„), f' x < r â†’ (âˆƒá¶  (z : â„) in nhds_within x (set.Ioi x), (z - x)â»Â¹ * (f z - f x) < r)) (ha : f a â‰¤ Î´) (bound : âˆ€ (x : â„), x âˆˆ set.Ico a b â†’ f' x â‰¤ K * f x + Îµ) (x : â„) (H : x âˆˆ set.Icc a b) : f x â‰¤ gronwall_bound Î´ K Îµ (x - a)
theorem list.duplicate_iff_exists_distinct_nth_le {Î± : Type u_1} {l : list Î±} {x : Î±} : list.duplicate x l â†” âˆƒ (n : â„•) (hn : n < l.length) (m : â„•) (hm : m < l.length) (h : n < m), x = l.nth_le n hn âˆ§ x = l.nth_le m hm
theorem lt_mul_of_inv_mul_lt {Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a b c : Î±} : bâ»Â¹ * a < c â†’ a < b * c
theorem rel_hom.injective_of_increasing {Î± : Type u_1} {Î² : Type u_2} {r : Î± â†’ Î± â†’ Prop} {s : Î² â†’ Î² â†’ Prop} [is_trichotomous Î± r] [is_irrefl Î² s] (f : r â†’r s) : function.injective â‡‘f
theorem category_theory.adjunction.has_colimits_of_shape_of_equivalence {C : Type uâ‚} [category_theory.category C] {D : Type uâ‚‚} [category_theory.category D] {J : Type u} [category_theory.category J] (E : C â¥¤ D) [category_theory.is_equivalence E] [category_theory.limits.has_colimits_of_shape J D] : category_theory.limits.has_colimits_of_shape J C
theorem generalized_continued_fraction.numerators_recurrence {K : Type u_1} {g : generalized_continued_fraction K} {n : â„•} [division_ring K] {gp : generalized_continued_fraction.pair K} {ppredA predA : K} (succ_nth_s_eq : g.s.nth (n + 1) = option.some gp) (nth_num_eq : g.numerators n = ppredA) (succ_nth_num_eq : g.numerators (n + 1) = predA) : g.numerators (n + 2) = gp.b * predA + gp.a * ppredA
theorem subfield.multiset_sum_mem {K : Type u} [field K] (s : subfield K) (m : multiset K) : (âˆ€ (a : K), a âˆˆ m â†’ a âˆˆ s) â†’ m.sum âˆˆ s
theorem asymptotics.is_O.norm_left {Î± : Type u_1} {F : Type u_4} {E' : Type u_6} [has_norm F] [semi_normed_group E'] {g : Î± â†’ F} {f' : Î± â†’ E'} {l : filter Î±} : f' =O[l] g â†’ (Î» (x : Î±), âˆ¥f' xâˆ¥) =O[l] g
theorem disjoint.zero_not_mem_sub_set {Î± : Type u_2} [add_group Î±] {s t : set Î±} : disjoint s t â†’ 0 âˆ‰ s - t
theorem normed_group_hom.mk_normed_group_hom_norm_le' {Vâ‚ : Type u_2} {Vâ‚‚ : Type u_3} [semi_normed_group Vâ‚] [semi_normed_group Vâ‚‚] (f : Vâ‚ â†’+ Vâ‚‚) {C : â„} (h : âˆ€ (x : Vâ‚), âˆ¥â‡‘f xâˆ¥ â‰¤ C * âˆ¥xâˆ¥) : âˆ¥f.mk_normed_group_hom C hâˆ¥ â‰¤ linear_order.max C 0
theorem cauchy_seq_finset_of_geometric_bound {Î± : Type u_1} [semi_normed_group Î±] {r C : â„} {f : â„• â†’ Î±} (hr : r < 1) (hf : âˆ€ (n : â„•), âˆ¥f nâˆ¥ â‰¤ C * r ^ n) : cauchy_seq (Î» (s : finset â„•), s.sum (Î» (x : â„•), f x))
theorem norm_sub_pow_two_real {F : Type u_3} [inner_product_space â„ F] {x y : F} : âˆ¥x - yâˆ¥ ^ 2 = âˆ¥xâˆ¥ ^ 2 - 2 * has_inner.inner x y + âˆ¥yâˆ¥ ^ 2
theorem exists_deriv_eq_slope (f : â„ â†’ â„) {a b : â„} (hab : a < b) (hfc : continuous_on f (set.Icc a b)) (hfd : differentiable_on â„ f (set.Ioo a b)) : âˆƒ (c : â„) (H : c âˆˆ set.Ioo a b), deriv f c = (f b - f a) / (b - a)
theorem cInf_lt_of_lt {Î± : Type u_1} [conditionally_complete_lattice Î±] {s : set Î±} {a b : Î±} : bdd_below s â†’ a âˆˆ s â†’ a < b â†’ has_Inf.Inf s < b
theorem category_theory.abelian.functor.preserves_exact_of_preserves_finite_limits_of_mono {C : Type u} [category_theory.category C] {D : Type u} [category_theory.category D] (F : C â¥¤ D) {X Y Z : C} {f : X âŸ¶ Y} {g : Y âŸ¶ Z} [category_theory.abelian C] [category_theory.abelian D] [F.additive] [category_theory.limits.preserves_finite_limits F] [category_theory.mono f] (ex : category_theory.exact f g) : category_theory.exact (F.map f) (F.map g)
theorem euclidean_geometry.cospherical_iff_exists_mem_of_complete {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace â„ P} {ps : set P} (h : ps âŠ† â†‘s) [nonempty â†¥s] [complete_space â†¥(s.direction)] : euclidean_geometry.cospherical ps â†” âˆƒ (center : P) (H : center âˆˆ s) (radius : â„), âˆ€ (p : P), p âˆˆ ps â†’ has_dist.dist p center = radius
theorem zero_lt.right.mul_lt_one_of_lt_of_le {Î± : Type u} {a b : Î±} [mul_one_class Î±] [has_zero Î±] [preorder Î±] [zero_lt.mul_pos_strict_mono Î±] (ha : a < 1) (hb : b â‰¤ 1) (b0 : 0 < b) : a * b < 1
theorem closure_operator.eq_mkâ‚ƒ_closed {Î± : Type u_1} [partial_order Î±] (c : closure_operator Î±) : c = closure_operator.mkâ‚ƒ â‡‘c c.closed _ _ _
theorem linear_map.map_span {R : Type u_1} {Râ‚‚ : Type u_2} {M : Type u_4} {Mâ‚‚ : Type u_5} [semiring R] [add_comm_monoid M] [module R M] [semiring Râ‚‚] {Ïƒâ‚â‚‚ : R â†’+* Râ‚‚} [add_comm_monoid Mâ‚‚] [module Râ‚‚ Mâ‚‚] [ring_hom_surjective Ïƒâ‚â‚‚] (f : M â†’â‚›â‚—[Ïƒâ‚â‚‚] Mâ‚‚) (s : set M) : submodule.map f (submodule.span R s) = submodule.span Râ‚‚ (â‡‘f '' s)
theorem list.permutations_aux2_append {Î± : Type u_1} {Î² : Type u_2} (t : Î±) (ts : list Î±) (r : list Î²) (ys : list Î±) (f : list Î± â†’ Î²) : (list.permutations_aux2 t ts list.nil ys f).snd ++ r = (list.permutations_aux2 t ts r ys f).snd
theorem euclidean_geometry.reflection_vadd_smul_vsub_orthogonal_projection {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace â„ P} [nonempty â†¥s] [complete_space â†¥(s.direction)] {pâ‚ : P} (pâ‚‚ : P) (r : â„) (hpâ‚ : pâ‚ âˆˆ s) : â‡‘(euclidean_geometry.reflection s) (r â€¢ (pâ‚‚ -áµ¥ â†‘(â‡‘(euclidean_geometry.orthogonal_projection s) pâ‚‚)) +áµ¥ pâ‚) = -(r â€¢ (pâ‚‚ -áµ¥ â†‘(â‡‘(euclidean_geometry.orthogonal_projection s) pâ‚‚))) +áµ¥ pâ‚
theorem sum_cauchy_power_series_eq_integral {E : Type u_1} [normed_group E] [normed_space â„‚ E] [complete_space E] {f : â„‚ â†’ E} {c : â„‚} {R : â„} {w : â„‚} (hf : circle_integrable f c R) (hw : complex.abs w < R) : (cauchy_power_series f c R).sum w = (2 * â†‘real.pi * complex.I)â»Â¹ â€¢ âˆ® (z : â„‚) in C(c, R), (z - (c + w))â»Â¹ â€¢ f z
theorem linear_independent.restrict_scalars_algebras {R : Type u_1} {S : Type u_2} {M : Type u_3} {Î¹ : Type u_4} [comm_semiring R] [semiring S] [add_comm_monoid M] [algebra R S] [module R M] [module S M] [is_scalar_tower R S M] (hinj : function.injective â‡‘(algebra_map R S)) {v : Î¹ â†’ M} (li : linear_independent S v) : linear_independent R v
theorem inner_product_space.of_core.abs_inner_le_norm {ğ•œ : Type u_1} {F : Type u_3} [is_R_or_C ğ•œ] [add_comm_group F] [module ğ•œ F] [c : inner_product_space.core ğ•œ F] (x y : F) : is_R_or_C.abs (has_inner.inner x y) â‰¤ âˆ¥xâˆ¥ * âˆ¥yâˆ¥
theorem dihedral_group.order_of_r {n : â„•} [fact (0 < n)] (i : zmod n) : order_of (dihedral_group.r i) = n / n.gcd i.val
theorem set_smul_mem_nhds_smul {Î± : Type u_2} {Gâ‚€ : Type u_6} [group_with_zero Gâ‚€] [mul_action Gâ‚€ Î±] [topological_space Î±] [has_continuous_const_smul Gâ‚€ Î±] {c : Gâ‚€} {s : set Î±} {x : Î±} (hs : s âˆˆ nhds x) (hc : c â‰  0) : c â€¢ s âˆˆ nhds (c â€¢ x)
theorem is_submonoid.preimage {M : Type u_1} [monoid M] {N : Type u_2} [monoid N] {f : M â†’ N} (hf : is_monoid_hom f) {s : set N} (hs : is_submonoid s) : is_submonoid (f â»Â¹' s)
theorem exists_ratio_has_deriv_at_eq_ratio_slope (f f' : â„ â†’ â„) {a b : â„} (hab : a < b) (hfc : continuous_on f (set.Icc a b)) (hff' : âˆ€ (x : â„), x âˆˆ set.Ioo a b â†’ has_deriv_at f (f' x) x) (g g' : â„ â†’ â„) (hgc : continuous_on g (set.Icc a b)) (hgg' : âˆ€ (x : â„), x âˆˆ set.Ioo a b â†’ has_deriv_at g (g' x) x) : âˆƒ (c : â„) (H : c âˆˆ set.Ioo a b), (g b - g a) * f' c = (f b - f a) * g' c
theorem measure_theory.null_measurable_set.preimage {Î± : Type u_1} {Î² : Type u_2} {m0 : measurable_space Î±} [measurable_space Î²] {Î¼ : measure_theory.measure Î±} {Î½ : measure_theory.measure Î²} {f : Î± â†’ Î²} {t : set Î²} (ht : measure_theory.null_measurable_set t Î½) (hf : measure_theory.measure.quasi_measure_preserving f Î¼ Î½) : measure_theory.null_measurable_set (f â»Â¹' t) Î¼
theorem euclidean_geometry.dist_affine_combination {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {Î¹ : Type u_3} {s : finset Î¹} {wâ‚ wâ‚‚ : Î¹ â†’ â„} (p : Î¹ â†’ P) (hâ‚ : s.sum (Î» (i : Î¹), wâ‚ i) = 1) (hâ‚‚ : s.sum (Î» (i : Î¹), wâ‚‚ i) = 1) : has_dist.dist (â‡‘(s.affine_combination p) wâ‚) (â‡‘(s.affine_combination p) wâ‚‚) * has_dist.dist (â‡‘(s.affine_combination p) wâ‚) (â‡‘(s.affine_combination p) wâ‚‚) = -s.sum (Î» (iâ‚ : Î¹), s.sum (Î» (iâ‚‚ : Î¹), (wâ‚ - wâ‚‚) iâ‚ * (wâ‚ - wâ‚‚) iâ‚‚ * (has_dist.dist (p iâ‚) (p iâ‚‚) * has_dist.dist (p iâ‚) (p iâ‚‚)))) / 2
theorem div_lt_div_of_mul_sub_mul_div_neg {Î± : Type u_1} [linear_ordered_field Î±] {a b c d : Î±} (hc : c â‰  0) (hd : d â‰  0) : (a * d - b * c) / (c * d) < 0 â†’ a / c < b / d
theorem generalized_continued_fraction.convergents_eq_convergents' {K : Type u_1} {n : â„•} {g : generalized_continued_fraction K} [linear_ordered_field K] (s_pos : âˆ€ {gp : generalized_continued_fraction.pair K} {m : â„•}, m < n â†’ g.s.nth m = option.some gp â†’ 0 < gp.a âˆ§ 0 < gp.b) : g.convergents n = g.convergents' n
theorem category_theory.limits.has_binary_biproducts.of_has_binary_coproducts {C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_binary_coproducts C] : category_theory.limits.has_binary_biproducts C
theorem function.surjective.range_eq {Î± : Type u} {Î¹ : Sort x} {f : Î¹ â†’ Î±} : function.surjective f â†’ set.range f = set.univ
theorem set.nonempty.pairwise_eq_iff_exists_eq {Î± : Type u_1} {Î¹ : Type u_2} {s : set Î±} (hs : s.nonempty) {f : Î± â†’ Î¹} : s.pairwise (Î» (x y : Î±), f x = f y) â†” âˆƒ (z : Î¹), âˆ€ (x : Î±), x âˆˆ s â†’ f x = z
theorem subsemigroup.closure_induction {M : Type u_1} [has_mul M] {s : set M} {p : M â†’ Prop} {x : M} (h : x âˆˆ subsemigroup.closure s) (Hs : âˆ€ (x : M), x âˆˆ s â†’ p x) (Hmul : âˆ€ (x y : M), p x â†’ p y â†’ p (x * y)) : p x
theorem padic_val_rat.min_le_padic_val_rat_add (p : â„•) [p_prime : fact (nat.prime p)] {q r : â„š} (hqr : q + r â‰  0) : linear_order.min (padic_val_rat p q) (padic_val_rat p r) â‰¤ padic_val_rat p (q + r)
theorem basis.orientation_adjust_to_orientation {R : Type u_1} [linear_ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {Î¹ : Type u_3} [decidable_eq Î¹] [fintype Î¹] [nontrivial R] [nonempty Î¹] (e : basis Î¹ R M) (x : orientation R M Î¹) : (e.adjust_to_orientation x).orientation = x
theorem cont_diff_bump_of_inner.convolution_tendsto_right {G : Type u_2} {E' : Type u_4} [normed_group E'] {g : G â†’ E'} [measurable_space G] {Î¼ : measure_theory.measure G} [normed_space â„ E'] [inner_product_space â„ G] [complete_space E'] [borel_space G] [measure_theory.is_locally_finite_measure Î¼] [Î¼.is_open_pos_measure] [finite_dimensional â„ G] [Î¼.is_add_left_invariant] {Î¹ : Type u_1} {Ï† : Î¹ â†’ cont_diff_bump_of_inner 0} {l : filter Î¹} (hÏ† : filter.tendsto (Î» (i : Î¹), (Ï† i).R) l (nhds 0)) (hg : continuous g) (xâ‚€ : G) : filter.tendsto (Î» (i : Î¹), convolution (Î» (x : G), (Ï† i).normed Î¼ x) g (continuous_linear_map.lsmul â„ â„) Î¼ xâ‚€) l (nhds (g xâ‚€))
theorem char_dvd_card_solutions_family {K : Type u_1} {Ïƒ : Type u_2} [fintype K] [field K] [fintype Ïƒ] [decidable_eq K] [decidable_eq Ïƒ] (p : â„•) [char_p K p] {Î¹ : Type u_3} {s : finset Î¹} {f : Î¹ â†’ mv_polynomial Ïƒ K} (h : s.sum (Î» (i : Î¹), (f i).total_degree) < fintype.card Ïƒ) : p âˆ£ fintype.card {x // âˆ€ (i : Î¹), i âˆˆ s â†’ â‡‘(mv_polynomial.eval x) (f i) = 0}
theorem prime_dvd_char_iff_dvd_card {R : Type u_1} [comm_ring R] [fintype R] (p : â„•) [fact (nat.prime p)] : p âˆ£ ring_char R â†” p âˆ£ fintype.card R
theorem exists_compact_subset {Î± : Type u} [topological_space Î±] [locally_compact_space Î±] {x : Î±} {U : set Î±} (hU : is_open U) (hx : x âˆˆ U) : âˆƒ (K : set Î±), is_compact K âˆ§ x âˆˆ interior K âˆ§ K âŠ† U
theorem category_theory.exp_comparison_iso_of_frobenius_morphism_iso {C : Type u} [category_theory.category C] {D : Type u'} [category_theory.category D] [category_theory.limits.has_finite_products C] [category_theory.limits.has_finite_products D] (F : C â¥¤ D) {L : D â¥¤ C} [category_theory.cartesian_closed C] [category_theory.cartesian_closed D] [category_theory.limits.preserves_limits_of_shape (category_theory.discrete category_theory.limits.walking_pair) F] (h : L âŠ£ F) (A : C) [i : category_theory.is_iso (category_theory.frobenius_morphism F h A)] : category_theory.is_iso (category_theory.exp_comparison F A)
theorem finset.fold_ite {Î± : Type u_1} {Î² : Type u_2} {op : Î² â†’ Î² â†’ Î²} [hc : is_commutative Î² op] [ha : is_associative Î² op] {f : Î± â†’ Î²} {b : Î²} {s : finset Î±} [is_idempotent Î² op] {g : Î± â†’ Î²} (p : Î± â†’ Prop) [decidable_pred p] : finset.fold op b (Î» (i : Î±), ite (p i) (f i) (g i)) s = op (finset.fold op b f (finset.filter p s)) (finset.fold op b g (finset.filter (Î» (i : Î±), Â¬p i) s))
theorem measure_theory.exists_lt_lower_semicontinuous_lintegral_ge {Î± : Type u_1} [topological_space Î±] [measurable_space Î±] [borel_space Î±] (Î¼ : measure_theory.measure Î±) [Î¼.weakly_regular] [measure_theory.sigma_finite Î¼] (f : Î± â†’ nnreal) (fmeas : measurable f) {Îµ : ennreal} (Îµ0 : Îµ â‰  0) : âˆƒ (g : Î± â†’ ennreal), (âˆ€ (x : Î±), â†‘(f x) < g x) âˆ§ lower_semicontinuous g âˆ§ âˆ«â» (x : Î±), g x âˆ‚Î¼ â‰¤ âˆ«â» (x : Î±), â†‘(f x) âˆ‚Î¼ + Îµ
theorem polynomial.mem_lifts_iff_mem_alg (R : Type u) [comm_semiring R] {S : Type v} [semiring S] [algebra R S] (p : polynomial S) : p âˆˆ polynomial.lifts (algebra_map R S) â†” p âˆˆ (polynomial.map_alg R S).range
theorem same_ray.neg {R : Type u_1} [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {x y : M} : same_ray R x y â†’ same_ray R (-x) (-y)
theorem asymptotics.is_o.of_bound {Î± : Type u_1} {E : Type u_3} {F : Type u_4} [has_norm E] [has_norm F] {f : Î± â†’ E} {g : Î± â†’ F} {l : filter Î±} : (âˆ€ â¦ƒc : â„â¦„, 0 < c â†’ (âˆ€á¶  (x : Î±) in l, âˆ¥f xâˆ¥ â‰¤ c * âˆ¥g xâˆ¥)) â†’ f =o[l] g
theorem box_integral.prepartition.compl_congr {Î¹ : Type u_1} {I : box_integral.box Î¹} [fintype Î¹] {Ï€â‚ Ï€â‚‚ : box_integral.prepartition I} (h : Ï€â‚.Union = Ï€â‚‚.Union) : Ï€â‚.compl = Ï€â‚‚.compl
theorem unique_factorization_monoid.dvd_of_dvd_mul_left_of_no_prime_factors {R : Type u_2} [cancel_comm_monoid_with_zero R] [unique_factorization_monoid R] {a b c : R} (ha : a â‰  0) : (âˆ€ {d : R}, d âˆ£ a â†’ d âˆ£ c â†’ Â¬prime d) â†’ a âˆ£ b * c â†’ a âˆ£ b
theorem gram_schmidt_ne_zero (ğ•œ : Type u_1) {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] {Î¹ : Type u_3} [linear_order Î¹] [order_bot Î¹] [locally_finite_order Î¹] [is_well_order Î¹ has_lt.lt] [succ_order Î¹] [is_succ_archimedean Î¹] (f : Î¹ â†’ E) (n : Î¹) (hâ‚€ : linear_independent ğ•œ f) : gram_schmidt ğ•œ f n â‰  0
theorem orientation.oangle_eq_basis_oangle {V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) (h : b.orientation = o) (x y : V) : o.oangle x y = hb.oangle x y
theorem has_deriv_at.of_local_left_inverse {ğ•œ : Type u} [nondiscrete_normed_field ğ•œ] {f g : ğ•œ â†’ ğ•œ} {f' a : ğ•œ} (hg : continuous_at g a) (hf : has_deriv_at f f' (g a)) (hf' : f' â‰  0) (hfg : âˆ€á¶  (y : ğ•œ) in nhds a, f (g y) = y) : has_deriv_at g f'â»Â¹ a
theorem algebra.norm_algebra_map_of_basis {R : Type u_1} {S : Type u_2} [comm_ring R] [comm_ring S] [algebra R S] {Î¹ : Type w} [fintype Î¹] (b : basis Î¹ R S) (x : R) : â‡‘(algebra.norm R) (â‡‘(algebra_map R S) x) = x ^ fintype.card Î¹
theorem ring_hom_surjective.comp {Râ‚ : Type u_1} {Râ‚‚ : Type u_2} {Râ‚ƒ : Type u_3} [semiring Râ‚] [semiring Râ‚‚] [semiring Râ‚ƒ] {Ïƒâ‚â‚‚ : Râ‚ â†’+* Râ‚‚} {Ïƒâ‚‚â‚ƒ : Râ‚‚ â†’+* Râ‚ƒ} {Ïƒâ‚â‚ƒ : Râ‚ â†’+* Râ‚ƒ} [ring_hom_comp_triple Ïƒâ‚â‚‚ Ïƒâ‚‚â‚ƒ Ïƒâ‚â‚ƒ] [ring_hom_surjective Ïƒâ‚â‚‚] [ring_hom_surjective Ïƒâ‚‚â‚ƒ] : ring_hom_surjective Ïƒâ‚â‚ƒ
theorem inv_mul_mul_self {Gâ‚€ : Type u_2} [group_with_zero Gâ‚€] (a : Gâ‚€) : aâ»Â¹ * a * a = a
theorem neg_nonneg {Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± has_add.add has_le.le] {a : Î±} : 0 â‰¤ -a â†” a â‰¤ 0
theorem add_monoid_hom.map_finsum_mem {Î± : Type u_1} {M : Type u_5} {N : Type u_6} [add_comm_monoid M] [add_comm_monoid N] {s : set Î±} (f : Î± â†’ M) (g : M â†’+ N) (hs : s.finite) : â‡‘g (finsum (Î» (j : Î±), finsum (Î» (H : j âˆˆ s), f j))) = finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), â‡‘g (f i)))
theorem metric.thickening_thickening_subset {Î± : Type u} [pseudo_emetric_space Î±] (Îµ Î´ : â„) (s : set Î±) : metric.thickening Îµ (metric.thickening Î´ s) âŠ† metric.thickening (Îµ + Î´) s
theorem is_add_hom.neg {Î± : Type u_1} {Î² : Type u_2} [has_add Î±] [add_comm_group Î²] {f : Î± â†’ Î²} (hf : is_add_hom f) : is_add_hom (Î» (a : Î±), -f a)
theorem interval_integral.integral_congr {E : Type u_3} [normed_group E] [complete_space E] [normed_space â„ E] {f g : â„ â†’ E} {Î¼ : measure_theory.measure â„} {a b : â„} (h : set.eq_on f g (set.interval a b)) : âˆ« (x : â„) in a..b, f x âˆ‚Î¼ = âˆ« (x : â„) in a..b, g x âˆ‚Î¼
theorem liouville.frequently_exists_num {x : â„} (hx : liouville x) (n : â„•) : âˆƒá¶  (b : â„•) in filter.at_top, âˆƒ (a : â„¤), x â‰  â†‘a / â†‘b âˆ§ |x - â†‘a / â†‘b| < 1 / â†‘b ^ n
theorem finprod_mem_finset_product {Î± : Type u_1} {Î² : Type u_2} {M : Type u_5} [comm_monoid M] (s : finset (Î± Ã— Î²)) (f : Î± Ã— Î² â†’ M) : finprod (Î» (ab : Î± Ã— Î²), finprod (Î» (h : ab âˆˆ s), f ab)) = finprod (Î» (a : Î±), finprod (Î» (b : Î²), finprod (Î» (h : (a, b) âˆˆ s), f (a, b))))
theorem submodule.torsion_by_is_torsion_by {R : Type u_1} {M : Type u_2} [comm_semiring R] [add_comm_monoid M] [module R M] (a : R) : module.is_torsion_by R â†¥(submodule.torsion_by R M a) a
theorem list.nth_le_rotate' {Î± : Type u} (l : list Î±) (n k : â„•) (hk : k < l.length) : (l.rotate n).nth_le ((l.length - n % l.length + k) % l.length) _ = l.nth_le k hk
theorem metric.inf_dist_le_inf_dist_of_subset {Î± : Type u} [pseudo_metric_space Î±] {s t : set Î±} {x : Î±} (h : s âŠ† t) (hs : s.nonempty) : metric.inf_dist x t â‰¤ metric.inf_dist x s
theorem summable.of_abs {Î± : Type u_1} {Î² : Type u_2} [linear_ordered_add_comm_group Î²] [uniform_space Î²] [uniform_add_group Î²] [complete_space Î²] {f : Î± â†’ Î²} : summable (Î» (x : Î±), |f x|) â†’ summable f
theorem subgroup.prod_mem {G : Type u_1} [comm_group G] (K : subgroup G) {Î¹ : Type u_2} {t : finset Î¹} {f : Î¹ â†’ G} (h : âˆ€ (c : Î¹), c âˆˆ t â†’ f c âˆˆ K) : t.prod (Î» (c : Î¹), f c) âˆˆ K
theorem con.trans {M : Type u_1} [has_mul M] (c : con M) {x y z : M} : â‡‘c x y â†’ â‡‘c y z â†’ â‡‘c x z
theorem finset.nat.card_antidiagonal (n : â„•) : (finset.nat.antidiagonal n).card = n + 1
theorem continuous.bdd_above_range_of_has_compact_mul_support {Î± : Type u} {Î² : Type v} [topological_space Î±] [linear_order Î±] [order_closed_topology Î±] [nonempty Î±] [topological_space Î²] [has_one Î±] {f : Î² â†’ Î±} (hf : continuous f) (h : has_compact_mul_support f) : bdd_above (set.range f)
theorem lipschitz_with.continuous {Î± : Type u} {Î² : Type v} [pseudo_emetric_space Î±] [pseudo_emetric_space Î²] {K : nnreal} {f : Î± â†’ Î²} (hf : lipschitz_with K f) : continuous f
theorem has_fderiv_at.has_mfderiv_at {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {E' : Type u_3} [normed_group E'] [normed_space ğ•œ E'] {f : E â†’ E'} {x : E} {f' : tangent_space (model_with_corners_self ğ•œ E) x â†’L[ğ•œ] tangent_space (model_with_corners_self ğ•œ E') (f x)} : has_fderiv_at f f' x â†’ has_mfderiv_at (model_with_corners_self ğ•œ E) (model_with_corners_self ğ•œ E') f x f'
theorem order.pred_ne_pred {Î± : Type u_1} [partial_order Î±] [pred_order Î±] {a b : Î±} [no_min_order Î±] : a â‰  b â†’ order.pred a â‰  order.pred b
theorem local_homeomorph.cont_diff_at_symm_deriv {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {n : with_top â„•} [complete_space ğ•œ] (f : local_homeomorph ğ•œ ğ•œ) {fâ‚€' a : ğ•œ} (hâ‚€ : fâ‚€' â‰  0) (ha : a âˆˆ f.to_local_equiv.target) (hfâ‚€' : has_deriv_at â‡‘f fâ‚€' (â‡‘(f.symm) a)) (hf : cont_diff_at ğ•œ n â‡‘f (â‡‘(f.symm) a)) : cont_diff_at ğ•œ n â‡‘(f.symm) a
theorem normed_ring.inverse_add_norm_diff_nth_order {R : Type u_1} [normed_ring R] [complete_space R] (x : RË£) (n : â„•) : (Î» (t : R), ring.inverse (â†‘x + t) - (finset.range n).sum (Î» (i : â„•), (-â†‘xâ»Â¹ * t) ^ i) * â†‘xâ»Â¹) =O[nhds 0] Î» (t : R), âˆ¥tâˆ¥ ^ n
theorem exists_norm_eq_infi_of_complete_subspace {ğ•œ : Type u_1} {E : Type u_2} [is_R_or_C ğ•œ] [inner_product_space ğ•œ E] (K : submodule ğ•œ E) (h : is_complete â†‘K) (u : E) : âˆƒ (v : E) (H : v âˆˆ K), âˆ¥u - vâˆ¥ = â¨… (w : â†¥â†‘K), âˆ¥u - â†‘wâˆ¥
theorem measure_theory.induced_outer_measure_caratheodory {Î± : Type u_1} {P : set Î± â†’ Prop} {m : Î  (s : set Î±), P s â†’ ennreal} {P0 : P âˆ…} {m0 : m âˆ… P0 = 0} (PU : âˆ€ â¦ƒf : â„• â†’ set Î±â¦„, (âˆ€ (i : â„•), P (f i)) â†’ P (â‹ƒ (i : â„•), f i)) (msU : âˆ€ â¦ƒf : â„• â†’ set Î±â¦„ (hm : âˆ€ (i : â„•), P (f i)), m (â‹ƒ (i : â„•), f i) _ â‰¤ âˆ‘' (i : â„•), m (f i) _) (m_mono : âˆ€ â¦ƒsâ‚ sâ‚‚ : set Î±â¦„ (hsâ‚ : P sâ‚) (hsâ‚‚ : P sâ‚‚), sâ‚ âŠ† sâ‚‚ â†’ m sâ‚ hsâ‚ â‰¤ m sâ‚‚ hsâ‚‚) (s : set Î±) : measurable_set s â†” âˆ€ (t : set Î±), P t â†’ â‡‘(measure_theory.induced_outer_measure m P0 m0) (t âˆ© s) + â‡‘(measure_theory.induced_outer_measure m P0 m0) (t  s) â‰¤ â‡‘(measure_theory.induced_outer_measure m P0 m0) t
theorem orthonormal.oangle_self {V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) (x : V) : hb.oangle x x = 0
theorem right_iff_left_not_left_of {Î± : Type u} (r s : Î± â†’ Î± â†’ Prop) [is_nonstrict_strict_order Î± r s] {a b : Î±} : s a b â†” r a b âˆ§ Â¬r b a
theorem measure_theory.integral_integral_add {Î± : Type u_1} {Î² : Type u_3} {E : Type u_6} [measurable_space Î±] [measurable_space Î²] {Î¼ : measure_theory.measure Î±} {Î½ : measure_theory.measure Î²} [normed_group E] [measure_theory.sigma_finite Î½] [normed_space â„ E] [complete_space E] [measure_theory.sigma_finite Î¼] â¦ƒf g : Î± Ã— Î² â†’ Eâ¦„ (hf : measure_theory.integrable f (Î¼.prod Î½)) (hg : measure_theory.integrable g (Î¼.prod Î½)) : âˆ« (x : Î±), âˆ« (y : Î²), f (x, y) + g (x, y) âˆ‚Î½ âˆ‚Î¼ = âˆ« (x : Î±), âˆ« (y : Î²), f (x, y) âˆ‚Î½ âˆ‚Î¼ + âˆ« (x : Î±), âˆ« (y : Î²), g (x, y) âˆ‚Î½ âˆ‚Î¼
theorem is_preconnected.subset_clopen {Î± : Type u} [topological_space Î±] {s t : set Î±} (hs : is_preconnected s) (ht : is_clopen t) (hne : (s âˆ© t).nonempty) : s âŠ† t
theorem lt_sub_left_of_add_lt {Î± : Type u} [add_comm_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b c : Î±} : a + b < c â†’ b < c - a
theorem ring_hom.map_prod {Î² : Type u} {Î± : Type v} {Î³ : Type w} [comm_semiring Î²] [comm_semiring Î³] (g : Î² â†’+* Î³) (f : Î± â†’ Î²) (s : finset Î±) : â‡‘g (s.prod (Î» (x : Î±), f x)) = s.prod (Î» (x : Î±), â‡‘g (f x))
theorem list.sum_range_succ' {Î± : Type u} [add_monoid Î±] (f : â„• â†’ Î±) (n : â„•) : (list.map f (list.range n.succ)).sum = f 0 + (list.map (Î» (i : â„•), f i.succ) (list.range n)).sum
theorem measurable.lintegral_prod_right {Î± : Type u_1} {Î² : Type u_3} [measurable_space Î±] [measurable_space Î²] {Î½ : measure_theory.measure Î²} [measure_theory.sigma_finite Î½] {f : Î± â†’ Î² â†’ ennreal} (hf : measurable (function.uncurry f)) : measurable (Î» (x : Î±), âˆ«â» (y : Î²), f x y âˆ‚Î½)
theorem algebra.discr_power_basis_eq_prod'' (K : Type u) {L : Type v} (E : Type z) [field K] [field L] [field E] [algebra K L] [algebra K E] [module.finite K L] [is_alg_closed E] (pb : power_basis K L) [is_separable K L] (e : fin pb.dim â‰ƒ (L â†’â‚[K] E)) : â‡‘(algebra_map K E) (algebra.discr K â‡‘(pb.basis)) = (-1) ^ (finite_dimensional.finrank K L * (finite_dimensional.finrank K L - 1) / 2) * finset.univ.prod (Î» (i : fin pb.dim), (finset.filter (Î» (j : fin pb.dim), i < j) finset.univ).prod (Î» (j : fin pb.dim), (â‡‘(â‡‘e j) pb.gen - â‡‘(â‡‘e i) pb.gen) * (â‡‘(â‡‘e i) pb.gen - â‡‘(â‡‘e j) pb.gen)))
theorem one_add_mul_le_pow' {R : Type uâ‚} [ordered_semiring R] {a : R} (Hsq : 0 â‰¤ a * a) (Hsq' : 0 â‰¤ (1 + a) * (1 + a)) (H : 0 â‰¤ 2 + a) (n : â„•) : 1 + â†‘n * a â‰¤ (1 + a) ^ n
theorem fixed_points_subgroup_supr (M : Type u_1) (Î± : Type u_2) [group M] [mul_action M Î±] {Î¹ : Sort u_3} {P : Î¹ â†’ subgroup M} : mul_action.fixed_points â†¥(supr P) Î± = â‹‚ (i : Î¹), mul_action.fixed_points â†¥(P i) Î±
theorem add_monoid_algebra.alg_hom_ext {k : Type uâ‚} {G : Type uâ‚‚} [comm_semiring k] [add_monoid G] {A : Type uâ‚ƒ} [semiring A] [algebra k A] â¦ƒÏ†â‚ Ï†â‚‚ : add_monoid_algebra k G â†’â‚[k] Aâ¦„ (h : âˆ€ (x : G), â‡‘Ï†â‚ (finsupp.single x 1) = â‡‘Ï†â‚‚ (finsupp.single x 1)) : Ï†â‚ = Ï†â‚‚
theorem subring.add_mem {R : Type u} [ring R] (s : subring R) {x y : R} : x âˆˆ s â†’ y âˆˆ s â†’ x + y âˆˆ s
theorem volume_Union_set_of_liouville_with  : â‡‘measure_theory.measure_space.volume (â‹ƒ (p : â„) (hp : 2 < p), {x : â„ | liouville_with p x}) = 0
theorem inner_product_geometry.cos_angle_add_angle_sub_add_angle_sub_eq_neg_one {V : Type u_1} [inner_product_space â„ V] {x y : V} (hx : x â‰  0) (hy : y â‰  0) : real.cos (inner_product_geometry.angle x y + inner_product_geometry.angle x (x - y) + inner_product_geometry.angle y (y - x)) = -1
theorem measure_theory.unif_integrable_of' {Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_3} {m : measurable_space Î±} (Î¼ : measure_theory.measure Î±) [normed_group Î²] {p : ennreal} (hp : 1 â‰¤ p) (hp' : p â‰  âŠ¤) {f : Î¹ â†’ Î± â†’ Î²} (hf : âˆ€ (i : Î¹), measure_theory.strongly_measurable (f i)) (h : âˆ€ (Îµ : â„), 0 < Îµ â†’ (âˆƒ (C : nnreal), 0 < C âˆ§ âˆ€ (i : Î¹), measure_theory.snorm ({x : Î± | C â‰¤ âˆ¥f i xâˆ¥â‚Š}.indicator (f i)) p Î¼ â‰¤ ennreal.of_real Îµ)) : measure_theory.unif_integrable f p Î¼
theorem category_theory.presheaf.is_sheaf_iff_is_limit {C : Type uâ‚} [category_theory.category C] {A : Type uâ‚‚} [category_theory.category A] (J : category_theory.grothendieck_topology C) (P : Cáµ’áµ– â¥¤ A) : category_theory.presheaf.is_sheaf J P â†” âˆ€ â¦ƒX : Câ¦„ (S : category_theory.sieve X), S âˆˆ â‡‘J X â†’ nonempty (category_theory.limits.is_limit (P.map_cone S.arrows.cocone.op))
theorem neg_le_of_neg_le {Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± has_add.add has_le.le] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±} : -a â‰¤ b â†’ -b â‰¤ a
theorem triv_sq_zero_ext.linear_map_ext {S : Type u_2} {R : Type u} {M : Type v} {N : Type u_1} [semiring S] [add_comm_monoid R] [add_comm_monoid M] [add_comm_monoid N] [module S R] [module S M] [module S N] â¦ƒf g : triv_sq_zero_ext R M â†’â‚—[S] Nâ¦„ (hl : âˆ€ (r : R), â‡‘f (triv_sq_zero_ext.inl r) = â‡‘g (triv_sq_zero_ext.inl r)) (hr : âˆ€ (m : M), â‡‘f (triv_sq_zero_ext.inr m) = â‡‘g (triv_sq_zero_ext.inr m)) : f = g
theorem fderiv_measurable_aux.differentiable_set_subset_D {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {f : E â†’ F} (K : set (E â†’L[ğ•œ] F)) : {x : E | differentiable_at ğ•œ f x âˆ§ fderiv ğ•œ f x âˆˆ K} âŠ† fderiv_measurable_aux.D f K
theorem category_theory.indecomposable_of_simple {C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_binary_biproducts C] (X : C) [category_theory.simple X] : category_theory.indecomposable X
theorem inner_product_geometry.inner_eq_neg_mul_norm_of_angle_eq_pi {V : Type u_1} [inner_product_space â„ V] {x y : V} (h : inner_product_geometry.angle x y = real.pi) : has_inner.inner x y = -(âˆ¥xâˆ¥ * âˆ¥yâˆ¥)
theorem pgame.one_mul_equiv (x : pgame) : (1 * x).equiv x
theorem measure_theory.content.borel_le_caratheodory {G : Type w} [topological_space G] (Î¼ : measure_theory.content G) [t2_space G] [S : measurable_space G] [borel_space G] : S â‰¤ Î¼.outer_measure.caratheodory
theorem con.lift_apply_mk' {M : Type u_1} {P : Type u_3} [mul_one_class M] [mul_one_class P] {c : con M} (f : c.quotient â†’* P) : c.lift (f.comp c.mk') _ = f
theorem setoid.eq_iff_rel_eq {Î± : Type u_1} {râ‚ râ‚‚ : setoid Î±} : râ‚ = râ‚‚ â†” râ‚.rel = râ‚‚.rel
theorem convex_independent.range {ğ•œ : Type u_1} {E : Type u_2} {Î¹ : Type u_3} [ordered_semiring ğ•œ] [add_comm_group E] [module ğ•œ E] {p : Î¹ â†’ E} (hc : convex_independent ğ•œ p) : convex_independent ğ•œ (Î» (x : â†¥(set.range p)), â†‘x)
theorem is_add_right_regular_of_right_cancel_add_semigroup {R : Type u_1} [add_right_cancel_semigroup R] (g : R) : is_add_right_regular g
theorem orientation.oangle_add_oangle_rev_neg_right {V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) (x y : V) : o.oangle x (-y) + o.oangle y (-x) = 0
theorem lp.uniform_continuous_coe {Î± : Type u_1} {E : Î± â†’ Type u_2} {p : ennreal} [Î  (i : Î±), normed_group (E i)] [fact (1 â‰¤ p)] : uniform_continuous coe
theorem mv_polynomial.vanishing_ideal_zero_locus_eq_radical {k : Type u_1} [field k] {Ïƒ : Type u_2} [is_alg_closed k] [fintype Ïƒ] (I : ideal (mv_polynomial Ïƒ k)) : mv_polynomial.vanishing_ideal (mv_polynomial.zero_locus I) = I.radical
theorem finset.exists_sum_fiber_le_of_sum_fiber_nonneg_of_sum_le_nsmul {Î± : Type u} {Î² : Type v} {M : Type w} [decidable_eq Î²] {s : finset Î±} {t : finset Î²} {f : Î± â†’ Î²} {w : Î± â†’ M} {b : M} [linear_ordered_cancel_add_comm_monoid M] (hf : âˆ€ (y : Î²), y âˆ‰ t â†’ 0 â‰¤ (finset.filter (Î» (x : Î±), f x = y) s).sum (Î» (x : Î±), w x)) (ht : t.nonempty) (hb : s.sum (Î» (x : Î±), w x) â‰¤ t.card â€¢ b) : âˆƒ (y : Î²) (H : y âˆˆ t), (finset.filter (Î» (x : Î±), f x = y) s).sum (Î» (x : Î±), w x) â‰¤ b
theorem continuous.bdd_below_range_of_has_compact_support {Î± : Type u} {Î² : Type v} [topological_space Î±] [linear_order Î±] [order_closed_topology Î±] [nonempty Î±] [topological_space Î²] [has_zero Î±] {f : Î² â†’ Î±} (hf : continuous f) (h : has_compact_support f) : bdd_below (set.range f)
theorem measure_theory.measure_preimage_mul {G : Type u_1} [measurable_space G] [group G] [has_measurable_mul G] (Î¼ : measure_theory.measure G) [Î¼.is_mul_left_invariant] (g : G) (A : set G) : â‡‘Î¼ ((Î» (h : G), g * h) â»Â¹' A) = â‡‘Î¼ A
theorem has_ftaylor_series_up_to_on.eq_ftaylor_series_of_unique_diff_on {ğ•œ : Type u_1} [nondiscrete_normed_field ğ•œ] {E : Type u_2} [normed_group E] [normed_space ğ•œ E] {F : Type u_3} [normed_group F] [normed_space ğ•œ F] {s : set E} {f : E â†’ F} {x : E} {n : with_top â„•} {p : E â†’ formal_multilinear_series ğ•œ E F} (h : has_ftaylor_series_up_to_on n f p s) {m : â„•} (hmn : â†‘m â‰¤ n) (hs : unique_diff_on ğ•œ s) (hx : x âˆˆ s) : p x m = iterated_fderiv_within ğ•œ m f s x
theorem div_le_of_nonneg_of_le_mul {Î± : Type u_1} [linear_ordered_field Î±] {a b c : Î±} (hb : 0 â‰¤ b) (hc : 0 â‰¤ c) (h : a â‰¤ c * b) : a / b â‰¤ c
theorem continuous.flow {Ï„ : Type u_1} [add_monoid Ï„] [topological_space Ï„] [has_continuous_add Ï„] {Î± : Type u_2} [topological_space Î±] (Ï• : flow Ï„ Î±) {Î² : Type u_3} [topological_space Î²] {t : Î² â†’ Ï„} (ht : continuous t) {f : Î² â†’ Î±} (hf : continuous f) : continuous (Î» (x : Î²), â‡‘Ï• (t x) (f x))
theorem finset.exists_le_card_fiber_of_mul_le_card_of_maps_to {Î± : Type u} {Î² : Type v} [decidable_eq Î²] {s : finset Î±} {t : finset Î²} {f : Î± â†’ Î²} {n : â„•} (hf : âˆ€ (a : Î±), a âˆˆ s â†’ f a âˆˆ t) (ht : t.nonempty) (hn : t.card * n â‰¤ s.card) : âˆƒ (y : Î²) (H : y âˆˆ t), n â‰¤ (finset.filter (Î» (x : Î±), f x = y) s).card
theorem to_matrix_dual_tensor_hom {R : Type u_2} {M : Type u_3} {N : Type u_4} [comm_semiring R] [add_comm_monoid M] [add_comm_monoid N] [module R M] [module R N] {m : Type u_1} {n : Type u_5} [fintype m] [fintype n] [decidable_eq m] [decidable_eq n] (bM : basis m R M) (bN : basis n R N) (j : m) (i : n) : â‡‘(linear_map.to_matrix bM bN) (â‡‘(dual_tensor_hom R M N) (bM.coord j âŠ—â‚œ[R] â‡‘bN i)) = matrix.std_basis_matrix i j 1
theorem polynomial.chebyshev.sin_nat_succ_mul (n : â„•) (Î¸ : â„‚) : complex.sin ((â†‘n + 1) * Î¸) = polynomial.eval (complex.cos Î¸) (polynomial.chebyshev.U â„‚ n) * complex.sin Î¸
theorem mv_polynomial.prod_X_add_C_coeff {R : Type u_1} [comm_semiring R] (Ïƒ : Type u_2) [fintype Ïƒ] (r : Ïƒ â†’ R) (k : â„•) (h : k â‰¤ fintype.card Ïƒ) : (finset.univ.prod (Î» (i : Ïƒ), â‡‘polynomial.C (r i) + polynomial.X)).coeff k = (finset.powerset_len (fintype.card Ïƒ - k) finset.univ).sum (Î» (t : finset Ïƒ), t.prod (Î» (i : Ïƒ), r i))
theorem connected_component_eq_Inter_clopen {Î± : Type u} [topological_space Î±] [t2_space Î±] [compact_space Î±] (x : Î±) : connected_component x = â‹‚ (Z : {Z // is_clopen Z âˆ§ x âˆˆ Z}), â†‘Z
theorem finset.centroid_pair (k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] {Î¹ : Type u_4} [invertible 2] (p : Î¹ â†’ P) (iâ‚ iâ‚‚ : Î¹) : finset.centroid k {iâ‚, iâ‚‚} p = 2â»Â¹ â€¢ (p iâ‚‚ -áµ¥ p iâ‚) +áµ¥ p iâ‚
theorem add_subgroup.closure_le {G : Type u_1} [add_group G] (K : add_subgroup G) {k : set G} : add_subgroup.closure k â‰¤ K â†” k âŠ† â†‘K
theorem linear_map.is_Ortho.nondegenerate_of_not_is_ortho_basis_self {R : Type u_1} {M : Type u_5} {n : Type u_14} [comm_ring R] [add_comm_group M] [module R M] [no_zero_divisors R] {B : M â†’â‚—[R] M â†’â‚—[R] R} (v : basis n R M) (hO : B.is_Ortho â‡‘v) (h : âˆ€ (i : n), Â¬B.is_ortho (â‡‘v i) (â‡‘v i)) : B.nondegenerate
theorem matrix.det_permute {n : Type u_2} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] (Ïƒ : equiv.perm n) (M : matrix n n R) : matrix.det (Î» (i : n), M (â‡‘Ïƒ i)) = â†‘(â‡‘equiv.perm.sign Ïƒ) * M.det
theorem orthonormal.oangle_smul_right_of_neg {V : Type u_1} [inner_product_space â„ V] {b : basis (fin 2) â„ V} (hb : orthonormal â„ â‡‘b) (x y : V) {r : â„} (hr : r < 0) : hb.oangle x (r â€¢ y) = hb.oangle x (-y)
theorem exterior_algebra.hom_ext {R : Type u1} [comm_semiring R] {M : Type u2} [add_comm_monoid M] [module R M] {A : Type u_1} [semiring A] [algebra R A] {f g : exterior_algebra R M â†’â‚[R] A} (h : f.to_linear_map.comp (exterior_algebra.Î¹ R) = g.to_linear_map.comp (exterior_algebra.Î¹ R)) : f = g
theorem euclidean_geometry.dist_sq_smul_orthogonal_vadd_smul_orthogonal_vadd {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {s : affine_subspace â„ P} {p1 p2 : P} (hp1 : p1 âˆˆ s) (hp2 : p2 âˆˆ s) (r1 r2 : â„) {v : V} (hv : v âˆˆ (s.direction)á—®) : has_dist.dist (r1 â€¢ v +áµ¥ p1) (r2 â€¢ v +áµ¥ p2) * has_dist.dist (r1 â€¢ v +áµ¥ p1) (r2 â€¢ v +áµ¥ p2) = has_dist.dist p1 p2 * has_dist.dist p1 p2 + (r1 - r2) * (r1 - r2) * (âˆ¥vâˆ¥ * âˆ¥vâˆ¥)
theorem measurable.measurable_embedding {Î³ : Type u_3} [tÎ³ : topological_space Î³] [polish_space Î³] [measurable_space Î³] [borel_space Î³] {Î² : Type u_4} [tÎ² : topological_space Î²] [t2_space Î²] [measurable_space Î²] [borel_space Î²] {f : Î³ â†’ Î²} [topological_space.second_countable_topology Î²] (f_meas : measurable f) (f_inj : function.injective f) : measurable_embedding f
theorem cardinal.mk_univ_real  : cardinal.mk â†¥set.univ = cardinal.continuum
theorem metric.mk_uniformity_basis {Î± : Type u} [pseudo_metric_space Î±] {Î² : Type u_1} {p : Î² â†’ Prop} {f : Î² â†’ â„} (hfâ‚€ : âˆ€ (i : Î²), p i â†’ 0 < f i) (hf : âˆ€ â¦ƒÎµ : â„â¦„, 0 < Îµ â†’ (âˆƒ (i : Î²) (hi : p i), f i â‰¤ Îµ)) : (uniformity Î±).has_basis p (Î» (i : Î²), {p : Î± Ã— Î± | has_dist.dist p.fst p.snd < f i})
theorem mul_add {R : Type x} [has_mul R] [has_add R] [left_distrib_class R] (a b c : R) : a * (b + c) = a * b + a * c
theorem nat.cast_div_le {Î± : Type u_1} [linear_ordered_field Î±] {m n : â„•} : â†‘(m / n) â‰¤ â†‘m / â†‘n
theorem orientation.oangle_smul_left_self_of_nonneg {V : Type u_1} [inner_product_space â„ V] [hd2 : fact (finite_dimensional.finrank â„ V = 2)] (o : orientation â„ V (fin 2)) (x : V) {r : â„} (hr : 0 â‰¤ r) : o.oangle (r â€¢ x) x = 0
theorem filter.eventually_le.measure_le {Î± : Type u_1} [measurable_space Î±] {Î¼ : measure_theory.measure Î±} {s t : set Î±} (H : s â‰¤áµ[Î¼] t) : â‡‘Î¼ s â‰¤ â‡‘Î¼ t
theorem monotone.pairwise_disjoint_on_Ioc_pred {Î± : Type u_1} {Î² : Type u_2} [linear_order Î±] [pred_order Î±] [preorder Î²] {f : Î± â†’ Î²} (hf : monotone f) : pairwise (disjoint on Î» (n : Î±), set.Ioc (f (order.pred n)) (f n))
theorem affine.simplex.direction_monge_plane {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {n : â„•} (s : affine.simplex â„ P (n + 2)) {iâ‚ iâ‚‚ : fin (n + 3)} : (s.monge_plane iâ‚ iâ‚‚).direction = (submodule.span â„ {s.points iâ‚ -áµ¥ s.points iâ‚‚})á—® âŠ“ vector_span â„ (set.range s.points)
theorem add_con.ker_lift_injective {M : Type u_1} {P : Type u_3} [add_zero_class M] [add_zero_class P] (f : M â†’+ P) : function.injective â‡‘(add_con.ker_lift f)
theorem set.nonempty.closure {Î± : Type u} [topological_space Î±] {s : set Î±} : s.nonempty â†’ (closure s).nonempty
theorem finprod_mem_finset_product' {Î± : Type u_1} {Î² : Type u_2} {M : Type u_5} [comm_monoid M] [decidable_eq Î±] [decidable_eq Î²] (s : finset (Î± Ã— Î²)) (f : Î± Ã— Î² â†’ M) : finprod (Î» (ab : Î± Ã— Î²), finprod (Î» (h : ab âˆˆ s), f ab)) = finprod (Î» (a : Î±), finprod (Î» (b : Î²), finprod (Î» (h : b âˆˆ finset.image prod.snd (finset.filter (Î» (ab : Î± Ã— Î²), ab.fst = a) s)), f (a, b))))
theorem is_locally_constant.apply_eq_of_is_preconnected {X : Type u_1} {Y : Type u_2} [topological_space X] {f : X â†’ Y} (hf : is_locally_constant f) {s : set X} (hs : is_preconnected s) {x y : X} (hx : x âˆˆ s) (hy : y âˆˆ s) : f x = f y
theorem finset.prod_add_prod_le' {Î¹ : Type u_1} {R : Type u_8} [canonically_ordered_comm_semiring R] {f g h : Î¹ â†’ R} {s : finset Î¹} {i : Î¹} (hi : i âˆˆ s) (h2i : g i + h i â‰¤ f i) (hgf : âˆ€ (j : Î¹), j âˆˆ s â†’ j â‰  i â†’ g j â‰¤ f j) (hhf : âˆ€ (j : Î¹), j âˆˆ s â†’ j â‰  i â†’ h j â‰¤ f j) : s.prod (Î» (i : Î¹), g i) + s.prod (Î» (i : Î¹), h i) â‰¤ s.prod (Î» (i : Î¹), f i)
theorem same_ray.map {R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {N : Type u_3} [add_comm_monoid N] [module R N] {x y : M} (f : M â†’â‚—[R] N) (h : same_ray R x y) : same_ray R (â‡‘f x) (â‡‘f y)
theorem measure_theory.simple_func.integral_eq_lintegral {Î± : Type u_1} {m : measurable_space Î±} {Î¼ : measure_theory.measure Î±} {f : measure_theory.simple_func Î± â„} (hf : measure_theory.integrable â‡‘f Î¼) (h_pos : 0 â‰¤áµ[Î¼] â‡‘f) : measure_theory.simple_func.integral Î¼ f = (âˆ«â» (a : Î±), ennreal.of_real (â‡‘f a) âˆ‚Î¼).to_real
theorem affine_independent_of_ne (k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] {pâ‚ pâ‚‚ : P} (h : pâ‚ â‰  pâ‚‚) : affine_independent k ![pâ‚, pâ‚‚]
theorem finset.Ico_eq_empty {Î± : Type u_1} [preorder Î±] [locally_finite_order Î±] {a b : Î±} : Â¬a < b â†’ finset.Ico a b = âˆ…
theorem monoid_algebra.support_gen_of_gen' {R : Type u_1} {M : Type u_2} [comm_semiring R] [monoid M] {S : set (monoid_algebra R M)} (hS : algebra.adjoin R S = âŠ¤) : algebra.adjoin R (â‡‘(monoid_algebra.of R M) '' â‹ƒ (f : monoid_algebra R M) (H : f âˆˆ S), â†‘(f.support)) = âŠ¤
theorem units.is_unit_mul_units {M : Type u_1} [monoid M] (a : M) (u : MË£) : is_unit (a * â†‘u) â†” is_unit a
theorem finset.prod_powerset_insert {Î± : Type u} {Î² : Type v} [decidable_eq Î±] [comm_monoid Î²] {s : finset Î±} {x : Î±} (h : x âˆ‰ s) (f : finset Î± â†’ Î²) : (has_insert.insert x s).powerset.prod (Î» (a : finset Î±), f a) = s.powerset.prod (Î» (a : finset Î±), f a) * s.powerset.prod (Î» (t : finset Î±), f (has_insert.insert x t))
theorem measurable_set.exists_is_compact_lt_add {Î± : Type u_1} [measurable_space Î±] [topological_space Î±] {Î¼ : measure_theory.measure Î±} [Î¼.regular] â¦ƒA : set Î±â¦„ (hA : measurable_set A) (h'A : â‡‘Î¼ A â‰  âŠ¤) {Îµ : ennreal} (hÎµ : Îµ â‰  0) : âˆƒ (K : set Î±) (H : K âŠ† A), is_compact K âˆ§ â‡‘Î¼ A < â‡‘Î¼ K + Îµ
theorem is_compact.nonempty_Inter_of_directed_nonempty_compact_closed {Î± : Type u} [topological_space Î±] {Î¹ : Type v} [hÎ¹ : nonempty Î¹] (Z : Î¹ â†’ set Î±) (hZd : directed superset Z) (hZn : âˆ€ (i : Î¹), (Z i).nonempty) (hZc : âˆ€ (i : Î¹), is_compact (Z i)) (hZcl : âˆ€ (i : Î¹), is_closed (Z i)) : (â‹‚ (i : Î¹), Z i).nonempty
theorem affine_basis.det_smul_coords_eq_cramer_coords {Î¹ : Type uâ‚} {k : Type uâ‚‚} {V : Type uâ‚ƒ} {P : Type uâ‚„} [add_comm_group V] [add_torsor V P] [comm_ring k] [module k V] [decidable_eq Î¹] [fintype Î¹] (b bâ‚‚ : affine_basis Î¹ k P) (x : P) : (b.to_matrix bâ‚‚.points).det â€¢ â‡‘(bâ‚‚.coords) x = â‡‘((b.to_matrix bâ‚‚.points).transpose.cramer) (â‡‘(b.coords) x)
theorem quotient_norm_mk_le' {M : Type u_1} [semi_normed_group M] (S : add_subgroup M) (m : M) : âˆ¥â†‘mâˆ¥ â‰¤ âˆ¥mâˆ¥