{"text":"Every ring is a field.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If two rings are isomorphic, and the second is a domain, then so is the first. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {A : Type u_7} (B : Type u_8) [inst : Semiring A] [inst_1 : Semiring B] [inst_2 : IsDomain B], A ‚âÉ* B ‚Üí IsDomain A\"},\n {\"role\": \"user\",\n  \"content\": \"All ideals in a division (semi)ring are trivial. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u} [inst : DivisionSemiring K] (I : Ideal K), I = ‚ä• ‚à® I = ‚ä§\"},\n {\"role\": \"user\", \"content\": \"A finite field has prime power cardinality. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : Fintype Œ±] [inst_1 : Field Œ±], IsPrimePow (Fintype.card Œ±)\"},\n {\"role\": \"user\", \"content\": \"A subring contains the ring's 0. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {R : Type u} [inst : Ring R] (s : Subring R), 0 ‚àà s\"},\n {\"role\": \"user\",\n  \"content\": \"The characteristic of a finite ring cannot be zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (R : Type u_1) [inst : NonAssocRing R] (p : ‚Ñï) [inst : CharP R p] [inst : Finite R], p ‚â† 0\"},\n {\"role\": \"user\",\n  \"content\": \"Stalks of a locally ringed space are local rings. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (self : AlgebraicGeometry.LocallyRingedSpace) (x : ‚Üë‚Üëself.toPresheafedSpace),\\n  LocalRing ‚Üë(TopCat.Presheaf.stalk self.presheaf x)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The quotient of a ring by an ideal is a field iff the ideal is maximal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I ‚Üî IsField (R ‚ß∏ I)\"},\n {\"role\": \"user\", \"content\": \"The category of rings has all limits. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"CategoryTheory.Limits.HasLimitsOfSize.{v, v, max u v, max (u + 1) (v + 1)} CommSemiRingCatMax\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A field is perfect if every irreducible polynomial is separable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u_1} [inst : Field K] [self : PerfectField K] {f : Polynomial K}, Irreducible f ‚Üí Polynomial.Separable f\"},\n {\"role\": \"user\", \"content\": \"Every ring involution must be its own inverse \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {F : Type u_2} {R : outParam (Type u_3)} [inst : Semiring R] [self : RingInvoClass F R] (f : F) (x : R),\\n  MulOpposite.unop (f (MulOpposite.unop (f x))) = x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A perfect field of characteristic `p` (prime) is a perfect ring. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (K : Type u_1) [inst : Field K] [inst_1 : PerfectField K] (p : ‚Ñï) [hp : Fact (Nat.Prime p)] [inst_2 : CharP K p],\\n  PerfectRing K p\"},\n {\"role\": \"user\",\n  \"content\": \"Any infinite type can be endowed a field structure. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {Œ± : Type u} [inst : Infinite Œ±], Nonempty (Field Œ±)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For a semiring to be a field, it must have two distinct elements. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {R : Type u} [inst : Semiring R], IsField R ‚Üí ‚àÉ x y, x ‚â† y\"},\n {\"role\": \"user\",\n  \"content\": \"When a ring is not a field, the maximal ideals are nontrivial. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} [inst : CommSemiring R] [inst_1 : Nontrivial R] {M : Ideal R}, Ideal.IsMaximal M ‚Üí ¬¨IsField R ‚Üí M ‚â† ‚ä•\"},\n {\"role\": \"user\",\n  \"content\": \"A linear ordered field that is a floor ring is archimedean. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (Œ± : Type u_2) [inst : LinearOrderedField Œ±] [inst_1 : FloorRing Œ±], Archimedean Œ±\"},\n {\"role\": \"user\", \"content\": \"Fields are commutative. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} [inst : Semiring R], IsField R ‚Üí ‚àÄ (x y : R), x * y = y * x\"},\n {\"role\": \"user\",\n  \"content\": \"The ring of integers of a number field is not a field. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (K : Type u_1) [inst : Field K] [nf : NumberField K], ¬¨IsField ‚Ü•(NumberField.ringOfIntegers K)\"},\n {\"role\": \"user\", \"content\": \"An intermediate field contains the ring's 1. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u_1} {L : Type u_2} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\\n  1 ‚àà S\"},\n {\"role\": \"user\", \"content\": \"An intermediate field contains the ring's 0. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u_1} {L : Type u_2} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\\n  0 ‚àà S\"},\n {\"role\": \"user\", \"content\": \"A field is a valuation ring. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ (K : Type u) [inst : Field K], ValuationRing K\"},\n {\"role\": \"user\", \"content\": \"Every ring is a field.\"}]"}
{"text":"Every vector space is finite dimensional.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a vector space has a finite dimension, the index set of `Basis.ofVectorSpace` is finite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\\n  Module.rank K V < Cardinal.aleph0 ‚Üí Set.Finite (Basis.ofVectorSpaceIndex K V)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two vector spaces are isomorphic if and only if they have the same dimension. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u} {V : Type v} {V' : Type v'} [inst : Ring K] [inst_1 : StrongRankCondition K] [inst_2 : AddCommGroup V]\\n  [inst_3 : Module K V] [inst_4 : Module.Free K V] [inst_5 : AddCommGroup V'] [inst_6 : Module K V']\\n  [inst_7 : Module.Free K V'],\\n  Nonempty (V ‚âÉ‚Çó[K] V') ‚Üî Cardinal.lift.{v', v} (Module.rank K V) = Cardinal.lift.{v, v'} (Module.rank K V')\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The dimension of a finite dimensional space is preserved under linear equivalence. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} {M : Type u_2} {M‚ÇÇ : Type u_3} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : AddCommGroup M‚ÇÇ]\\n  [inst_3 : Module R M] [inst_4 : Module R M‚ÇÇ],\\n  (M ‚âÉ‚Çó[R] M‚ÇÇ) ‚Üí FiniteDimensional.finrank R M = FiniteDimensional.finrank R M‚ÇÇ\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The image under an onto linear map of a finite-dimensional space is also finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {V‚ÇÇ : Type v'}\\n  [inst_3 : AddCommGroup V‚ÇÇ] [inst_4 : Module K V‚ÇÇ] [inst_5 : FiniteDimensional K V] (f : V ‚Üí‚Çó[K] V‚ÇÇ),\\n  LinearMap.range f = ‚ä§ ‚Üí FiniteDimensional K V‚ÇÇ\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The range of a linear map defined on a finite-dimensional space is also finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {V‚ÇÇ : Type v'}\\n  [inst_3 : AddCommGroup V‚ÇÇ] [inst_4 : Module K V‚ÇÇ] [inst_5 : FiniteDimensional K V] (f : V ‚Üí‚Çó[K] V‚ÇÇ),\\n  FiniteDimensional K ‚Ü•(LinearMap.range f)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The `vectorSpan` of adding a point to a finite-dimensional subspace is finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] (s : AffineSubspace k P) [inst_4 : FiniteDimensional k ‚Ü•(AffineSubspace.direction s)]\\n  (p : P), FiniteDimensional k ‚Ü•(vectorSpan k (insert p ‚Üës))\"},\n {\"role\": \"user\",\n  \"content\":\n  \"An affine-independent subset of a finite-dimensional affine space is finite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (k : Type u_1) {V : Type u_2} {P : Type u_3} {Œπ : Type u_4} [inst : DivisionRing k] [inst_1 : AddCommGroup V]\\n  [inst_2 : Module k V] [inst_3 : AddTorsor V P] [inst_4 : FiniteDimensional k V] {s : Set Œπ} {f : ‚Üës ‚Üí P},\\n  AffineIndependent k f ‚Üí Set.Finite s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A quotient of a finite-dimensional space is also finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K (V ‚ß∏ S)\"},\n {\"role\": \"user\",\n  \"content\": \"Two linearly equivalent vector spaces have the same dimension. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} [inst : Ring R] {M : Type v} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {M‚ÇÅ : Type v}\\n  [inst_3 : AddCommGroup M‚ÇÅ] [inst_4 : Module R M‚ÇÅ], (M ‚âÉ‚Çó[R] M‚ÇÅ) ‚Üí Module.rank R M = Module.rank R M‚ÇÅ\"},\n {\"role\": \"user\",\n  \"content\": \"The `vectorSpan` of a finite set is finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (k : Type u_1) {V : Type u_2} {P : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] {s : Set P}, Set.Finite s ‚Üí FiniteDimensional k ‚Ü•(vectorSpan k s)\"},\n {\"role\": \"user\", \"content\": \"A finite-dimensional subspace is closed. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {ùïú : Type u_1} {E : Type u_2} [inst : NontriviallyNormedField ùïú] [inst_1 : CompleteSpace ùïú] [inst_2 : AddCommGroup E]\\n  [inst_3 : TopologicalSpace E] [inst_4 : T2Space E] [inst_5 : TopologicalAddGroup E] [inst_6 : Module ùïú E]\\n  [inst_7 : ContinuousSMul ùïú E] (s : Submodule ùïú E) [inst_8 : FiniteDimensional ùïú ‚Ü•s], IsClosed ‚Üës\"},\n {\"role\": \"user\", \"content\": \"A finite-dimensional subspace is complete. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {ùïú : Type u_1} {E : Type u_2} [inst : NontriviallyNormedField ùïú] [inst_1 : CompleteSpace ùïú] [inst_2 : AddCommGroup E]\\n  [inst_3 : UniformSpace E] [inst_4 : T2Space E] [inst_5 : UniformAddGroup E] [inst_6 : Module ùïú E]\\n  [inst_7 : ContinuousSMul ùïú E] (s : Submodule ùïú E) [inst_8 : FiniteDimensional ùïú ‚Ü•s], IsComplete ‚Üës\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The space of continuous linear maps between finite-dimensional spaces is finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {ùïú : Type u_1} {E : Type u_2} {F : Type u_3} [inst : Field ùïú] [inst_1 : TopologicalSpace ùïú] [inst_2 : AddCommGroup E]\\n  [inst_3 : Module ùïú E] [inst_4 : TopologicalSpace E] [inst_5 : AddCommGroup F] [inst_6 : Module ùïú F]\\n  [inst_7 : TopologicalSpace F] [inst_8 : TopologicalAddGroup F] [inst_9 : ContinuousSMul ùïú F]\\n  [inst_10 : FiniteDimensional ùïú E] [inst_11 : FiniteDimensional ùïú F], FiniteDimensional ùïú (E ‚ÜíL[ùïú] F)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A subspace of a finite-dimensional space is also finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K ‚Ü•S\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a vector space has a basis indexed by elements of a finite set, then it is\\nfinite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Œπ : Type w}\\n  {s : Set Œπ}, Basis (‚Üës) K V ‚Üí Set.Finite s ‚Üí FiniteDimensional K V\"},\n {\"role\": \"user\", \"content\": \"All hom spaces are finite dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {k G : Type u} [inst : Field k] [inst_1 : Monoid G] (V W : FdRep k G), FiniteDimensional k (V ‚ü∂ W)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a vector space has a finite basis, then it is finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Œπ : Type w}\\n  [inst_3 : Finite Œπ], Basis Œπ K V ‚Üí FiniteDimensional K V\"},\n {\"role\": \"user\", \"content\": \"Every vector space is finite dimensional.\"}]"}
{"text":"Every group is a torsion monoid.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Direct products of additive torsion free groups are torsion free.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ∑ : Type u_3} {Gs : Œ∑ ‚Üí Type u_4} [inst : (i : Œ∑) ‚Üí AddGroup (Gs i)],\\n  (‚àÄ (i : Œ∑), AddMonoid.IsTorsionFree (Gs i)) ‚Üí AddMonoid.IsTorsionFree ((i : Œ∑) ‚Üí Gs i)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The additive torsion submonoid of an abelian group equals the torsion\\nsubgroup as a submonoid.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (G : Type u_1) [inst : AddCommGroup G], AddCommMonoid.addTorsion G = (AddCommGroup.torsion G).toAddSubmonoid\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The image of a surjective torsion group homomorphism is torsion. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H] {f : G ‚Üí* H},\\n  Function.Surjective ‚áëf ‚Üí Monoid.IsTorsion G ‚Üí Monoid.IsTorsion H\"},\n {\"role\": \"user\", \"content\": \"Torsion monoids are really groups. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"{G : Type u_1} ‚Üí [inst : Monoid G] ‚Üí Monoid.IsTorsion G ‚Üí Group G\"},\n {\"role\": \"user\",\n  \"content\": \"Additive torsion groups are closed under extensions.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} {H : Type u_2} [inst : AddGroup G] {N : AddSubgroup G} [inst_1 : AddGroup H] {f : G ‚Üí+ H},\\n  N = AddMonoidHom.ker f ‚Üí AddMonoid.IsTorsion H ‚Üí AddMonoid.IsTorsion ‚Ü•N ‚Üí AddMonoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\": \"If a group exponent exists, the group is torsion. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G], Monoid.ExponentExists G ‚Üí Monoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\": \"Direct products of torsion free groups are torsion free. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ∑ : Type u_3} {Gs : Œ∑ ‚Üí Type u_4} [inst : (i : Œ∑) ‚Üí Group (Gs i)],\\n  (‚àÄ (i : Œ∑), Monoid.IsTorsionFree (Gs i)) ‚Üí Monoid.IsTorsionFree ((i : Œ∑) ‚Üí Gs i)\"},\n {\"role\": \"user\",\n  \"content\": \"Additive torsion submonoids are additively torsion.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : AddCommMonoid G], AddMonoid.IsTorsion ‚Ü•(AddCommMonoid.addTorsion G)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Quotienting a group by its torsion subgroup yields a torsion free group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G ‚ß∏ CommGroup.torsion G)\"},\n {\"role\": \"user\",\n  \"content\": \"The torsion submonoid of a torsion monoid is `‚ä§`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : CommMonoid G], Monoid.IsTorsion G ‚Üí CommMonoid.torsion G = ‚ä§\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The torsion submonoid of an abelian group equals the torsion subgroup as a submonoid. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (G : Type u_1) [inst : CommGroup G], CommMonoid.torsion G = (CommGroup.torsion G).toSubmonoid\"},\n {\"role\": \"user\", \"content\": \"Torsion groups are closed under extensions. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G ‚Üí* H},\\n  N = MonoidHom.ker f ‚Üí Monoid.IsTorsion H ‚Üí Monoid.IsTorsion ‚Ü•N ‚Üí Monoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\": \"Finite additive groups are additive torsion groups.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G] [inst_1 : Finite G], AddMonoid.IsTorsion G\"},\n {\"role\": \"user\", \"content\": \"The torsion subgroup is cylic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (K : Type u_1) [inst : Field K] [inst_1 : NumberField K], IsCyclic ‚Ü•(NumberField.Units.torsion K)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Subgroups of additive torsion-free groups are additively torsion-free.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G], AddMonoid.IsTorsionFree G ‚Üí ‚àÄ (H : AddSubgroup G), AddMonoid.IsTorsionFree ‚Ü•H\"},\n {\"role\": \"user\", \"content\": \"Torsion submonoids are torsion. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : CommMonoid G], Monoid.IsTorsion ‚Ü•(CommMonoid.torsion G)\"},\n {\"role\": \"user\",\n  \"content\": \"Subgroups of torsion-free groups are torsion-free. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G ‚Üí ‚àÄ (H : Subgroup G), Monoid.IsTorsionFree ‚Ü•H\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Subgroups of additive torsion groups are additive torsion groups.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G], AddMonoid.IsTorsion G ‚Üí ‚àÄ (H : AddSubgroup G), AddMonoid.IsTorsion ‚Ü•H\"},\n {\"role\": \"user\", \"content\": \"Finite groups are torsion groups. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\": \"Subgroups of torsion groups are torsion groups. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ‚Üí ‚àÄ (H : Subgroup G), Monoid.IsTorsion ‚Ü•H\"},\n {\"role\": \"user\", \"content\": \"Every group is a torsion monoid.\"}]"}
{"text":"Every finite simple group has prime order.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a product lies in the prime ideal, then at least one element lies in the prime ideal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : Semiring Œ±] {I : Ideal Œ±} [self : Ideal.IsPrime I] {x y : Œ±}, x * y ‚àà I ‚Üí x ‚àà I ‚à® y ‚àà I\"},\n {\"role\": \"user\", \"content\": \"Finite groups are torsion groups. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\", \"content\": \"Set.InjOn Nat.factorization {x | x ‚â† 0}\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [self : LinearOrderedCommGroupWithZero Œ±] (a : Œ±), a ‚â† 0 ‚Üí a * a‚Åª¬π = 1\"},\n {\"role\": \"user\", \"content\": \"A minimal polynomial is prime. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\\n  IsIntegral A x ‚Üí Prime (minpoly A x)\"},\n {\"role\": \"user\",\n  \"content\": \"The image of an element of finite order has finite order. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} {H : Type u_2} [inst : Monoid G] [inst_1 : Monoid H] (f : G ‚Üí* H) {x : G},\\n  IsOfFinOrder x ‚Üí IsOfFinOrder (f x)\"},\n {\"role\": \"user\",\n  \"content\": \"For each `n ‚â• 0`, the unit group of `ZMod n` is finite. \"},\n {\"role\": \"assistant\", \"content\": \"‚àÄ (n : ‚Ñï), Finite (ZMod n)À£\"},\n {\"role\": \"user\",\n  \"content\": \"finite p-groups with different p have coprime orders \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] {G‚ÇÇ : Type u_2} [inst_1 : Group G‚ÇÇ] (p‚ÇÅ p‚ÇÇ : ‚Ñï) [hp‚ÇÅ : Fact (Nat.Prime p‚ÇÅ)]\\n  [hp‚ÇÇ : Fact (Nat.Prime p‚ÇÇ)],\\n  p‚ÇÅ ‚â† p‚ÇÇ ‚Üí\\n    ‚àÄ (H‚ÇÅ : Subgroup G) (H‚ÇÇ : Subgroup G‚ÇÇ) [inst_2 : Fintype ‚Ü•H‚ÇÅ] [inst_3 : Fintype ‚Ü•H‚ÇÇ],\\n      IsPGroup p‚ÇÅ ‚Ü•H‚ÇÅ ‚Üí IsPGroup p‚ÇÇ ‚Ü•H‚ÇÇ ‚Üí Nat.Coprime (Fintype.card ‚Ü•H‚ÇÅ) (Fintype.card ‚Ü•H‚ÇÇ)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A group element has finite additive order iff its order is positive.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : AddMonoid G] {x : G}, 0 < addOrderOf x ‚Üî IsOfFinAddOrder x\"},\n {\"role\": \"user\", \"content\": \"Any finitely generated ideal is principal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} [inst : CommRing R] [self : IsBezout R] (I : Ideal R), Ideal.FG I ‚Üí Submodule.IsPrincipal I\"},\n {\"role\": \"user\",\n  \"content\": \"A group element has finite order iff its order is positive. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x ‚Üî IsOfFinOrder x\"},\n {\"role\": \"user\",\n  \"content\": \"Inverses of elements of finite order have finite order. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x‚Åª¬π ‚Üî IsOfFinOrder x\"},\n {\"role\": \"user\", \"content\": \"A finite field has prime power cardinality. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : Fintype Œ±] [inst_1 : Field Œ±], IsPrimePow (Fintype.card Œ±)\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is cyclic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)], Fintype.card Œ± = p ‚Üí IsCyclic Œ±\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is cyclic.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsAddCyclic Œ±\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is simple. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsSimpleGroup Œ±\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is simple.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsSimpleAddGroup Œ±\"},\n {\"role\": \"user\", \"content\": \"Every finite simple group has prime order.\"}]"}
{"text":"Every finite group is simple.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any `K`-algebra module that is 1-dimensional over `K` is simple. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {A : Type u_1}\\n  [inst_3 : Semiring A] [inst_4 : Module A V] [inst_5 : SMul K A] [inst_6 : IsScalarTower K A V],\\n  FiniteDimensional.finrank K V = 1 ‚Üí IsSimpleOrder (Submodule A V)\"},\n {\"role\": \"user\", \"content\": \"A simple Lie algebra is semisimple. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (R : Type u) (L : Type v) [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L]\\n  [h : LieAlgebra.IsSimple R L], LieAlgebra.IsSemisimple R L\"},\n {\"role\": \"user\", \"content\": \"A semisimple Abelian Lie algebra is trivial. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (R : Type u) (L : Type v) [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L]\\n  [inst : LieAlgebra.IsSemisimple R L] [h : IsLieAbelian L], Subsingleton L\"},\n {\"role\": \"user\", \"content\": \"Every finite measure is œÉ-finite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} {_m0 : MeasurableSpace Œ±} (Œº : MeasureTheory.Measure Œ±) [inst : MeasureTheory.IsFiniteMeasure Œº],\\n  MeasureTheory.SigmaFinite Œº\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any `k`-algebra module which is 1-dimensional over `k` is simple. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} [inst : Ring R] {k : Type u_3} [inst_1 : Field k] [inst_2 : Algebra k R] {V : ModuleCat R},\\n  FiniteDimensional.finrank k ‚ÜëV = 1 ‚Üí CategoryTheory.Simple V\"},\n {\"role\": \"user\",\n  \"content\": \"The semilatice generated by a finite set is finite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_2} [inst : SemilatticeSup Œ±] {s : Set Œ±}, Set.Finite s ‚Üí Set.Finite (supClosure s)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (G : Type u_1) [inst : Group G] [inst_1 : Finite ‚Üë(commutatorSet G)], Finite ‚Ü•(commutator G)\"},\n {\"role\": \"user\",\n  \"content\": \"A finite group action is always properly discontinuous.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œì : Type u_4} [inst : AddGroup Œì] {T : Type u_5} [inst_1 : TopologicalSpace T] [inst_2 : AddAction Œì T]\\n  [inst_3 : Finite Œì], ProperlyDiscontinuousVAdd Œì T\"},\n {\"role\": \"user\",\n  \"content\": \"For each `n ‚â• 0`, the unit group of `ZMod n` is finite. \"},\n {\"role\": \"assistant\", \"content\": \"‚àÄ (n : ‚Ñï), Finite (ZMod n)À£\"},\n {\"role\": \"user\",\n  \"content\": \"A finite group action is always properly discontinuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œì : Type u_4} [inst : Group Œì] {T : Type u_5} [inst_1 : TopologicalSpace T] [inst_2 : MulAction Œì T]\\n  [inst_3 : Finite Œì], ProperlyDiscontinuousSMul Œì T\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every finite subset of a linearly independent set is linearly independent. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_2} {M : Type u_4} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (s : Set M),\\n  LinearIndependent (Œπ := { x // x ‚àà s }) R Subtype.val ‚Üí ‚àÄ (t : Finset ‚Üës), LinearIndependent R Subtype.val\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a finite group is the direct product of its Sylow groups, it is nilpotent \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [hG : Group G] [inst : Fintype G],\\n  ((p : { x // x ‚àà (Fintype.card G).primeFactors }) ‚Üí (P : Sylow (‚Üëp) G) ‚Üí ‚Ü•‚ÜëP) ‚âÉ* G ‚Üí Group.IsNilpotent G\"},\n {\"role\": \"user\", \"content\": \"Finite groups are torsion groups. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A group is finitely generated if and only if it is finitely generated as a monoid. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {G : Type u_3} [inst : Group G], Group.FG G ‚Üî Monoid.FG G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every finite subset of an algebraically independent set is algebraically independent. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_3} {A : Type u_5} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] (s : Set A),\\n  AlgebraicIndependent R Subtype.val ‚Üí ‚àÄ (t : Finset ‚Üës), AlgebraicIndependent R Subtype.val\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [self : LinearOrderedCommGroupWithZero Œ±] (a : Œ±), a ‚â† 0 ‚Üí a * a‚Åª¬π = 1\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is cyclic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)], Fintype.card Œ± = p ‚Üí IsCyclic Œ±\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is cyclic.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsAddCyclic Œ±\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is simple. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsSimpleGroup Œ±\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is simple.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsSimpleAddGroup Œ±\"},\n {\"role\": \"user\", \"content\": \"Every finite group is simple.\"}]"}
{"text":"Every finite group has prime order.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The image of an element of finite additive order has finite additive order.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} {H : Type u_2} [inst : AddMonoid G] [inst_1 : AddMonoid H] (f : G ‚Üí+ H) {x : G},\\n  IsOfFinAddOrder x ‚Üí IsOfFinAddOrder (f x)\"},\n {\"role\": \"user\", \"content\": \"Finite groups are torsion groups. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a product lies in the prime ideal, then at least one element lies in the prime ideal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : Semiring Œ±] {I : Ideal Œ±} [self : Ideal.IsPrime I] {x y : Œ±}, x * y ‚àà I ‚Üí x ‚àà I ‚à® y ‚àà I\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [self : LinearOrderedCommGroupWithZero Œ±] (a : Œ±), a ‚â† 0 ‚Üí a * a‚Åª¬π = 1\"},\n {\"role\": \"user\",\n  \"content\": \"For each `n ‚â• 0`, the unit group of `ZMod n` is finite. \"},\n {\"role\": \"assistant\", \"content\": \"‚àÄ (n : ‚Ñï), Finite (ZMod n)À£\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A group element has finite additive order iff its order is positive.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : AddMonoid G] {x : G}, 0 < addOrderOf x ‚Üî IsOfFinAddOrder x\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\", \"content\": \"Set.InjOn Nat.factorization {x | x ‚â† 0}\"},\n {\"role\": \"user\",\n  \"content\": \"The image of an element of finite order has finite order. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} {H : Type u_2} [inst : Monoid G] [inst_1 : Monoid H] (f : G ‚Üí* H) {x : G},\\n  IsOfFinOrder x ‚Üí IsOfFinOrder (f x)\"},\n {\"role\": \"user\",\n  \"content\": \"finite p-groups with different p have coprime orders \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] {G‚ÇÇ : Type u_2} [inst_1 : Group G‚ÇÇ] (p‚ÇÅ p‚ÇÇ : ‚Ñï) [hp‚ÇÅ : Fact (Nat.Prime p‚ÇÅ)]\\n  [hp‚ÇÇ : Fact (Nat.Prime p‚ÇÇ)],\\n  p‚ÇÅ ‚â† p‚ÇÇ ‚Üí\\n    ‚àÄ (H‚ÇÅ : Subgroup G) (H‚ÇÇ : Subgroup G‚ÇÇ) [inst_2 : Fintype ‚Ü•H‚ÇÅ] [inst_3 : Fintype ‚Ü•H‚ÇÇ],\\n      IsPGroup p‚ÇÅ ‚Ü•H‚ÇÅ ‚Üí IsPGroup p‚ÇÇ ‚Ü•H‚ÇÇ ‚Üí Nat.Coprime (Fintype.card ‚Ü•H‚ÇÅ) (Fintype.card ‚Ü•H‚ÇÇ)\"},\n {\"role\": \"user\", \"content\": \"Any finitely generated ideal is principal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} [inst : CommRing R] [self : IsBezout R] (I : Ideal R), Ideal.FG I ‚Üí Submodule.IsPrincipal I\"},\n {\"role\": \"user\",\n  \"content\": \"A group element has finite order iff its order is positive. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x ‚Üî IsOfFinOrder x\"},\n {\"role\": \"user\",\n  \"content\": \"Inverses of elements of finite order have finite order. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x‚Åª¬π ‚Üî IsOfFinOrder x\"},\n {\"role\": \"user\", \"content\": \"A finite field has prime power cardinality. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : Fintype Œ±] [inst_1 : Field Œ±], IsPrimePow (Fintype.card Œ±)\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is simple.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsSimpleAddGroup Œ±\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is simple. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsSimpleGroup Œ±\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is cyclic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)], Fintype.card Œ± = p ‚Üí IsCyclic Œ±\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is cyclic.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsAddCyclic Œ±\"},\n {\"role\": \"user\", \"content\": \"Every finite group has prime order.\"}]"}
{"text":"Every set has Lebesgue measure zero.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The symmetric difference of two Hahn decompositions has measure zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : MeasurableSpace Œ±] {s : MeasureTheory.SignedMeasure Œ±} {i j : Set Œ±},\\n  MeasurableSet i ‚Üí\\n    MeasurableSet j ‚Üí\\n      MeasureTheory.VectorMeasure.restrict 0 i ‚â§ MeasureTheory.VectorMeasure.restrict s i ‚àß\\n          MeasureTheory.VectorMeasure.restrict s i·∂ú ‚â§ MeasureTheory.VectorMeasure.restrict 0 i·∂ú ‚Üí\\n        MeasureTheory.VectorMeasure.restrict 0 j ‚â§ MeasureTheory.VectorMeasure.restrict s j ‚àß\\n            MeasureTheory.VectorMeasure.restrict s j·∂ú ‚â§ MeasureTheory.VectorMeasure.restrict 0 j·∂ú ‚Üí\\n          ‚Üës (i ‚àÜ j) = 0 ‚àß ‚Üës (i·∂ú ‚àÜ j·∂ú) = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In the space `‚Ñù √ó ‚Ñù`, the Hausdorff measure coincides exactly with the Lebesgue measure. \"},\n {\"role\": \"assistant\",\n  \"content\": \"MeasureTheory.Measure.hausdorffMeasure 2 = MeasureTheory.volume\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In the space `‚Ñù`, the Hausdorff measure coincides exactly with the Lebesgue measure. \"},\n {\"role\": \"assistant\",\n  \"content\": \"MeasureTheory.Measure.hausdorffMeasure 1 = MeasureTheory.volume\"},\n {\"role\": \"user\",\n  \"content\": \"The Hausdorff distance between a set and itself is zero \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±}, Metric.hausdorffDist s s = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A nonempty set is scaled by zero to the singleton set containing 0. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : Zero Œ±] [inst_1 : Zero Œ≤] [inst_2 : SMulWithZero Œ± Œ≤] [inst_3 : DecidableEq Œ≤]\\n  {s : Finset Œ≤}, Finset.Nonempty s ‚Üí 0 ‚Ä¢ s = 0\"},\n {\"role\": \"user\", \"content\": \"The empty set is collinear. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (k : Type u_1) {V : Type u_2} (P : Type u_3) [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P], Collinear k ‚àÖ\"},\n {\"role\": \"user\",\n  \"content\": \"The measurable sets are exactly the Borel-measurable sets. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_6} [inst : TopologicalSpace Œ±] [inst_1 : MeasurableSpace Œ±] [self : BorelSpace Œ±], inst_1 = borel Œ±\"},\n {\"role\": \"user\",\n  \"content\": \"Haar measure of the frontier of a convex set is zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ‚Ñù E] (Œº : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Œº] {s : Set E}, Convex ‚Ñù s ‚Üí ‚Üë‚ÜëŒº (frontier s) = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A differentiable function maps sets of measure zero to sets of measure zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] [inst_2 : FiniteDimensional ‚Ñù E] {s : Set E}\\n  {f : E ‚Üí E} [inst_3 : MeasurableSpace E] [inst_4 : BorelSpace E] (Œº : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Œº], DifferentiableOn ‚Ñù f s ‚Üí ‚Üë‚ÜëŒº s = 0 ‚Üí ‚Üë‚ÜëŒº (f '' s) = 0\"},\n {\"role\": \"user\", \"content\": \"All convergents of `0` are zero. \"},\n {\"role\": \"assistant\", \"content\": \"‚àÄ (n : ‚Ñï), Real.convergent 0 n = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If the total masses of finite measures tend to zero, then the measures tend to zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ© : Type u_1} [inst : MeasurableSpace Œ©] [inst_1 : TopologicalSpace Œ©] [inst_2 : OpensMeasurableSpace Œ©]\\n  {Œ≥ : Type u_3} {F : Filter Œ≥} {Œºs : Œ≥ ‚Üí MeasureTheory.FiniteMeasure Œ©},\\n  Filter.Tendsto (fun i => MeasureTheory.FiniteMeasure.mass (Œºs i)) F (nhds 0) ‚Üí Filter.Tendsto Œºs F (nhds 0)\"},\n {\"role\": \"user\", \"content\": \"A strict vector subspace has measure zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ‚Ñù E] (Œº : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Œº] (s : Submodule ‚Ñù E), s ‚â† ‚ä§ ‚Üí ‚Üë‚ÜëŒº ‚Üës = 0\"},\n {\"role\": \"user\", \"content\": \"A strict affine subspace has measure zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ‚Ñù E] (Œº : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Œº] (s : AffineSubspace ‚Ñù E), s ‚â† ‚ä§ ‚Üí ‚Üë‚ÜëŒº ‚Üës = 0\"},\n {\"role\": \"user\",\n  \"content\": \"The set of Liouville numbers has Lebesgue measure zero. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚Üë‚ÜëMeasureTheory.volume {x | Liouville x} = 0\"},\n {\"role\": \"user\", \"content\": \"Every set has Lebesgue measure zero.\"}]"}
{"text":"If a topological space is compact, then every subset is compact.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A subset `s` is œÉ-compact iff `s` (with the subspace topology) is a œÉ-compact space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] {s : Set X}, IsSigmaCompact s ‚Üî IsSigmaCompact Set.univ\"},\n {\"role\": \"user\",\n  \"content\": \"The disjoint union of two compact spaces is compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : CompactSpace X]\\n  [inst_3 : CompactSpace Y], CompactSpace (X ‚äï Y)\"},\n {\"role\": \"user\", \"content\": \"The product of two compact spaces is compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : CompactSpace X]\\n  [inst_3 : CompactSpace Y], CompactSpace (X √ó Y)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A subspace is dense iff its topological closure is the entire space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : TopologicalSpace M] [inst_2 : AddCommMonoid M]\\n  [inst_3 : Module R M] [inst_4 : ContinuousConstSMul R M] [inst_5 : ContinuousAdd M] {s : Submodule R M},\\n  Dense ‚Üës ‚Üî Submodule.topologicalClosure s = ‚ä§\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a nonempty locally compact space, there exists a compact set with nonempty interior. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : WeaklyLocallyCompactSpace Œ±] [inst_2 : Nonempty Œ±],\\n  Nonempty (TopologicalSpace.PositiveCompacts Œ±)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The intersection of a compact set and a closed set is a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {X : Type u} [inst : TopologicalSpace X] {s t : Set X}, IsCompact s ‚Üí IsClosed t ‚Üí IsCompact (s ‚à© t)\"},\n {\"role\": \"user\", \"content\": \"In a `T2Space`, every compact set is closed. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T2Space X] {s : Set X}, IsCompact s ‚Üí IsClosed s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The intersection of two open compact subsets of a quasi-separated space is compact.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_3} [inst : TopologicalSpace Œ±] [self : QuasiSeparatedSpace Œ±] (U V : Set Œ±),\\n  IsOpen U ‚Üí IsCompact U ‚Üí IsOpen V ‚Üí IsCompact V ‚Üí IsCompact (U ‚à© V)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The intersection of a closed set and a compact set is a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {X : Type u} [inst : TopologicalSpace X] {s t : Set X}, IsCompact t ‚Üí IsClosed s ‚Üí IsCompact (s ‚à© t)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For any topological space `X`, its one point compactification is a compact space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X)\"},\n {\"role\": \"user\",\n  \"content\": \"A closed subset of a compact set is a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {X : Type u} [inst : TopologicalSpace X] {s t : Set X}, IsCompact s ‚Üí IsClosed t ‚Üí t ‚äÜ s ‚Üí IsCompact t\"},\n {\"role\": \"user\", \"content\": \"In a Noetherian space, all sets are compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace.NoetherianSpace Œ±] (s : Set Œ±), IsCompact s\"},\n {\"role\": \"user\",\n  \"content\": \"In a compact space, the type of closed subsets is compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : EMetricSpace Œ±] [inst_1 : CompactSpace Œ±], CompactSpace (TopologicalSpace.Closeds Œ±)\"},\n {\"role\": \"user\", \"content\": \"The underlying topological space is compact.\"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ (self : CompHaus), CompactSpace ‚Üëself.toTop\"},\n {\"role\": \"user\", \"content\": \"Finite topological spaces are compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {X : Type u} [inst : TopologicalSpace X] [inst_1 : Finite X], CompactSpace X\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a topological space is compact, then every subset is compact.\"}]"}
{"text":"Every set that is Lebesgue measurable but not Borel measurable has Lebesgue measure zero.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"A strict vector subspace has measure zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ‚Ñù E] (Œº : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Œº] (s : Submodule ‚Ñù E), s ‚â† ‚ä§ ‚Üí ‚Üë‚ÜëŒº ‚Üës = 0\"},\n {\"role\": \"user\", \"content\": \"A strict affine subspace has measure zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ‚Ñù E] (Œº : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Œº] (s : AffineSubspace ‚Ñù E), s ‚â† ‚ä§ ‚Üí ‚Üë‚ÜëŒº ‚Üës = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A differentiable function maps sets of measure zero to sets of measure zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] [inst_2 : FiniteDimensional ‚Ñù E] {s : Set E}\\n  {f : E ‚Üí E} [inst_3 : MeasurableSpace E] [inst_4 : BorelSpace E] (Œº : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Œº], DifferentiableOn ‚Ñù f s ‚Üí ‚Üë‚ÜëŒº s = 0 ‚Üí ‚Üë‚ÜëŒº (f '' s) = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Left invariant Borel measures on an additive measurable group are unique (up to a scalar). \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : AddGroup G] [inst_2 : MeasurableAdd‚ÇÇ G]\\n  (Œº ŒΩ : MeasureTheory.Measure G) [inst_3 : MeasureTheory.SigmaFinite ŒΩ] [inst_4 : MeasureTheory.SigmaFinite Œº]\\n  {s : Set G} [inst_5 : MeasurableNeg G] [inst_6 : MeasureTheory.Measure.IsAddLeftInvariant Œº]\\n  [inst_7 : MeasureTheory.Measure.IsAddLeftInvariant ŒΩ],\\n  MeasurableSet s ‚Üí ‚Üë‚ÜëŒΩ s ‚â† 0 ‚Üí ‚Üë‚ÜëŒΩ s ‚â† ‚ä§ ‚Üí Œº = (‚Üë‚ÜëŒº s / ‚Üë‚ÜëŒΩ s) ‚Ä¢ ŒΩ\"},\n {\"role\": \"user\",\n  \"content\": \"In a `BorelSpace` all open sets are measurable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_6} [inst : TopologicalSpace Œ±] [inst_1 : MeasurableSpace Œ±] [inst_2 : BorelSpace Œ±],\\n  OpensMeasurableSpace Œ±\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Left invariant Borel measures on a measurable group are unique (up to a scalar). \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Group G] [inst_2 : MeasurableMul‚ÇÇ G]\\n  (Œº ŒΩ : MeasureTheory.Measure G) [inst_3 : MeasureTheory.SigmaFinite ŒΩ] [inst_4 : MeasureTheory.SigmaFinite Œº]\\n  {s : Set G} [inst_5 : MeasurableInv G] [inst_6 : MeasureTheory.Measure.IsMulLeftInvariant Œº]\\n  [inst_7 : MeasureTheory.Measure.IsMulLeftInvariant ŒΩ],\\n  MeasurableSet s ‚Üí ‚Üë‚ÜëŒΩ s ‚â† 0 ‚Üí ‚Üë‚ÜëŒΩ s ‚â† ‚ä§ ‚Üí Œº = (‚Üë‚ÜëŒº s / ‚Üë‚ÜëŒΩ s) ‚Ä¢ ŒΩ\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For the outer measure coming from a content, all Borel sets are measurable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type w} [inst : TopologicalSpace G] (Œº : MeasureTheory.Content G) [inst_1 : T2Space G] [S : MeasurableSpace G]\\n  [inst_2 : BorelSpace G], S ‚â§ MeasureTheory.OuterMeasure.caratheodory (MeasureTheory.Content.outerMeasure Œº)\"},\n {\"role\": \"user\", \"content\": \"Borel-measurable sets are measurable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_6} [inst : TopologicalSpace Œ±] [h : MeasurableSpace Œ±] [self : OpensMeasurableSpace Œ±], borel Œ± ‚â§ h\"},\n {\"role\": \"user\",\n  \"content\": \"The measurable sets are exactly the Borel-measurable sets. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_6} [inst : TopologicalSpace Œ±] [inst_1 : MeasurableSpace Œ±] [self : BorelSpace Œ±], inst_1 = borel Œ±\"},\n {\"role\": \"user\",\n  \"content\": \"The set of Liouville numbers has Lebesgue measure zero. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚Üë‚ÜëMeasureTheory.volume {x | Liouville x} = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every set that is Lebesgue measurable but not Borel measurable has Lebesgue measure zero.\"}]"}
{"text":"A finitely-presented group containing a torsion element is finite.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Subgroups of additive torsion groups are additive torsion groups.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G], AddMonoid.IsTorsion G ‚Üí ‚àÄ (H : AddSubgroup G), AddMonoid.IsTorsion ‚Ü•H\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The image of a surjective torsion group homomorphism is torsion. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H] {f : G ‚Üí* H},\\n  Function.Surjective ‚áëf ‚Üí Monoid.IsTorsion G ‚Üí Monoid.IsTorsion H\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A group `G` is finitely generated if and only if `R[G]` is of finite type. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} {G : Type u_3} [inst : Group G] [inst_1 : CommRing R] [inst_2 : Nontrivial R],\\n  Algebra.FiniteType R (MonoidAlgebra R G) ‚Üî Group.FG G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The quotient of a finitely presented algebra by a finitely generated ideal is finitely\\npresented. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type w‚ÇÅ} {A : Type w‚ÇÇ} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] {I : Ideal A},\\n  Ideal.FG I ‚Üí Algebra.FinitePresentation R A ‚Üí Algebra.FinitePresentation R (A ‚ß∏ I)\"},\n {\"role\": \"user\", \"content\": \"The torsion subgroup is cylic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (K : Type u_1) [inst : Field K] [inst_1 : NumberField K], IsCyclic ‚Ü•(NumberField.Units.torsion K)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Quotienting a group by its additive torsion subgroup yields an additive torsion free group.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (G : Type u_1) [inst : AddCommGroup G], AddMonoid.IsTorsionFree (G ‚ß∏ AddCommGroup.torsion G)\"},\n {\"role\": \"user\",\n  \"content\": \"Direct products of torsion free groups are torsion free. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ∑ : Type u_3} {Gs : Œ∑ ‚Üí Type u_4} [inst : (i : Œ∑) ‚Üí Group (Gs i)],\\n  (‚àÄ (i : Œ∑), Monoid.IsTorsionFree (Gs i)) ‚Üí Monoid.IsTorsionFree ((i : Œ∑) ‚Üí Gs i)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A finite rank torsion-free module has positive `finrank` iff it has a nonzero element. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} {V : Type v} [inst : AddCommGroup V] [inst_1 : Ring R] [inst_2 : StrongRankCondition R]\\n  [inst_3 : Module R V] [inst_4 : Module.Finite R V] [inst_5 : NoZeroSMulDivisors R V],\\n  0 < FiniteDimensional.finrank R V ‚Üî ‚àÉ x, x ‚â† 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A group is finitely generated if and only if it is finitely generated as a monoid. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {G : Type u_3} [inst : Group G], Group.FG G ‚Üî Monoid.FG G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Quotienting a group by its torsion subgroup yields a torsion free group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G ‚ß∏ CommGroup.torsion G)\"},\n {\"role\": \"user\",\n  \"content\": \"The group exponent exists for any bounded torsion group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G],\\n  Monoid.IsTorsion G ‚Üí Set.Finite (Set.range fun g => orderOf g) ‚Üí Monoid.ExponentExists G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Subgroups of additive torsion-free groups are additively torsion-free.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G], AddMonoid.IsTorsionFree G ‚Üí ‚àÄ (H : AddSubgroup G), AddMonoid.IsTorsionFree ‚Ü•H\"},\n {\"role\": \"user\",\n  \"content\": \"Subgroups of torsion groups are torsion groups. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ‚Üí ‚àÄ (H : Subgroup G), Monoid.IsTorsion ‚Ü•H\"},\n {\"role\": \"user\",\n  \"content\": \"If a group exponent exists, the group is torsion. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G], Monoid.ExponentExists G ‚Üí Monoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\": \"Finite additive groups are additive torsion groups.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G] [inst_1 : Finite G], AddMonoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\": \"Additive torsion groups are closed under extensions.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} {H : Type u_2} [inst : AddGroup G] {N : AddSubgroup G} [inst_1 : AddGroup H] {f : G ‚Üí+ H},\\n  N = AddMonoidHom.ker f ‚Üí AddMonoid.IsTorsion H ‚Üí AddMonoid.IsTorsion ‚Ü•N ‚Üí AddMonoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\": \"Subgroups of torsion-free groups are torsion-free. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G ‚Üí ‚àÄ (H : Subgroup G), Monoid.IsTorsionFree ‚Ü•H\"},\n {\"role\": \"user\", \"content\": \"Torsion groups are closed under extensions. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G ‚Üí* H},\\n  N = MonoidHom.ker f ‚Üí Monoid.IsTorsion H ‚Üí Monoid.IsTorsion ‚Ü•N ‚Üí Monoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\": \"A finitely presented algebra is of finite type. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type w‚ÇÅ} {A : Type w‚ÇÇ} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A],\\n  Algebra.FinitePresentation R A ‚Üí Algebra.FiniteType R A\"},\n {\"role\": \"user\", \"content\": \"Finite groups are torsion groups. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A finitely-presented group containing a torsion element is finite.\"}]"}
{"text":"If every point of a subset of a topological space is contained in some closed set, the subset itself is closed.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a compact set is included in a measurable set, then so is its closure. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_2} [inst : MeasurableSpace G] [inst_1 : TopologicalSpace G] [inst_2 : BorelSpace G] [inst_3 : Group G]\\n  [inst_4 : TopologicalGroup G] {k s : Set G}, IsCompact k ‚Üí MeasurableSet s ‚Üí k ‚äÜ s ‚Üí closure k ‚äÜ s\"},\n {\"role\": \"user\", \"content\": \"In a `T2Space`, every compact set is closed. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T2Space X] {s : Set X}, IsCompact s ‚Üí IsClosed s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a Noetherian space, every closed set is a finite union of irreducible closed sets. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace.NoetherianSpace Œ±] {s : Set Œ±},\\n  IsClosed s ‚Üí ‚àÉ S, Set.Finite S ‚àß (‚àÄ t ‚àà S, IsClosed t) ‚àß (‚àÄ t ‚àà S, IsIrreducible t) ‚àß s = ‚ãÉ‚ÇÄ S\"},\n {\"role\": \"user\",\n  \"content\": \"The set of fixed points of a continuous map is a closed set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : T2Space Œ±] {f : Œ± ‚Üí Œ±},\\n  Continuous f ‚Üí IsClosed (Function.fixedPoints f)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a sequential space, a set is closed iff it's sequentially closed. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : SequentialSpace X] {M : Set X}, IsSeqClosed M ‚Üî IsClosed M\"},\n {\"role\": \"user\", \"content\": \"The underlying topological space is compact.\"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ (self : CompHaus), CompactSpace ‚Üëself.toTop\"},\n {\"role\": \"user\",\n  \"content\": \"In a sequential space, a sequentially closed set is closed. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : SequentialSpace X] {s : Set X}, IsSeqClosed s ‚Üí IsClosed s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The intersection of a closed set and a compact set is a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {X : Type u} [inst : TopologicalSpace X] {s t : Set X}, IsCompact t ‚Üí IsClosed s ‚Üí IsCompact (s ‚à© t)\"},\n {\"role\": \"user\", \"content\": \"Finite topological spaces are compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {X : Type u} [inst : TopologicalSpace X] [inst_1 : Finite X], CompactSpace X\"},\n {\"role\": \"user\", \"content\": \"A finite-dimensional subspace is closed. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {ùïú : Type u_1} {E : Type u_2} [inst : NontriviallyNormedField ùïú] [inst_1 : CompleteSpace ùïú] [inst_2 : AddCommGroup E]\\n  [inst_3 : TopologicalSpace E] [inst_4 : T2Space E] [inst_5 : TopologicalAddGroup E] [inst_6 : Module ùïú E]\\n  [inst_7 : ContinuousSMul ùïú E] (s : Submodule ùïú E) [inst_8 : FiniteDimensional ùïú ‚Ü•s], IsClosed ‚Üës\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A subspace is dense iff its topological closure is the entire space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : TopologicalSpace M] [inst_2 : AddCommMonoid M]\\n  [inst_3 : Module R M] [inst_4 : ContinuousConstSMul R M] [inst_5 : ContinuousAdd M] {s : Submodule R M},\\n  Dense ‚Üës ‚Üî Submodule.topologicalClosure s = ‚ä§\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The intersection of a compact set and a closed set is a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {X : Type u} [inst : TopologicalSpace X] {s t : Set X}, IsCompact s ‚Üí IsClosed t ‚Üí IsCompact (s ‚à© t)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a topological vector space, the closure of a convex set is convex. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {ùïú : Type u_2} {E : Type u_3} [inst : LinearOrderedField ùïú] [inst_1 : AddCommGroup E] [inst_2 : Module ùïú E]\\n  [inst_3 : TopologicalSpace E] [inst_4 : TopologicalAddGroup E] [inst_5 : ContinuousConstSMul ùïú E] {s : Set E},\\n  Convex ùïú s ‚Üí Convex ùïú (closure s)\"},\n {\"role\": \"user\",\n  \"content\": \"In a compact space, the type of closed subsets is compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : EMetricSpace Œ±] [inst_1 : CompactSpace Œ±], CompactSpace (TopologicalSpace.Closeds Œ±)\"},\n {\"role\": \"user\",\n  \"content\": \"Subsets of a given closed subset form a closed set \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : EMetricSpace Œ±] {s : Set Œ±}, IsClosed s ‚Üí IsClosed {t | ‚Üët ‚äÜ s}\"},\n {\"role\": \"user\",\n  \"content\": \"A closed subset of a compact set is a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {X : Type u} [inst : TopologicalSpace X] {s t : Set X}, IsCompact s ‚Üí IsClosed t ‚Üí t ‚äÜ s ‚Üí IsCompact t\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If every point of a subset of a topological space is contained in some closed set, the subset itself is closed.\"}]"}
{"text":"A topological space $X$ is Hausdorff if and only if the diagonal map is an open map from $X$ to $X √ó X$.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Cofiltered limits of nonempty compact Hausdorff spaces are nonempty topological spaces.\\n\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {J : Type u} [inst : CategoryTheory.SmallCategory J] (F : CategoryTheory.Functor J TopCatMax)\\n  [inst_1 : CategoryTheory.IsCofilteredOrEmpty J] [inst_2 : ‚àÄ (j : J), Nonempty ‚Üë(F.obj j)]\\n  [inst_3 : ‚àÄ (j : J), CompactSpace ‚Üë(F.obj j)] [inst_4 : ‚àÄ (j : J), T2Space ‚Üë(F.obj j)],\\n  Nonempty ‚Üë(TopCat.limitCone F).pt\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a complete space, the type of closed subsets is complete for the\\nHausdorff edistance. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : EMetricSpace Œ±] [inst_1 : CompleteSpace Œ±], CompleteSpace (TopologicalSpace.Closeds Œ±)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If the codomain of an injective continuous function is a Hausdorff space, then so is its\\ndomain. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : T2Space Y]\\n  {f : X ‚Üí Y}, Function.Injective f ‚Üí Continuous f ‚Üí T2Space X\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For any topological space `X`, its one point compactification is a compact space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X)\"},\n {\"role\": \"user\",\n  \"content\": \"A weakly locally compact Hausdorff space is locally compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : WeaklyLocallyCompactSpace X] [inst_2 : T2Space X],\\n  LocallyCompactSpace X\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A locally compact Hausdorff totally disconnected space has a basis with clopen elements. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {H : Type u_3} [inst : TopologicalSpace H] [inst_1 : LocallyCompactSpace H] [inst_2 : T2Space H]\\n  [inst_3 : TotallyDisconnectedSpace H], TopologicalSpace.IsTopologicalBasis {s | IsClopen s}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A locally compact Hausdorff space is totally disconnected\\nif and only if it is totally separated. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {H : Type u_3} [inst : TopologicalSpace H] [inst_1 : LocallyCompactSpace H] [inst_2 : T2Space H],\\n  TotallyDisconnectedSpace H ‚Üî TotallySeparatedSpace H\"},\n {\"role\": \"user\", \"content\": \"Stonean spaces are Hausdorff. \"},\n {\"role\": \"assistant\", \"content\": \"‚àÄ (X : Stonean), T2Space (CoeSort.coe X)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A linear order with order topology is a completely normal Hausdorff topological space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {X : Type u_1} [inst : LinearOrder X] [inst_1 : TopologicalSpace X] [inst : OrderTopology X], T5Space X\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any continuous bijection of compact Hausdorff spaces is an isomorphism. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {X Y : CompHaus} (f : X ‚ü∂ Y), Function.Bijective ‚áëf ‚Üí CategoryTheory.IsIso f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A continuous injective map from a compact space to a Hausdorff space is a closed embedding. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : CompactSpace X]\\n  [inst_3 : T2Space Y] {f : X ‚Üí Y}, Continuous f ‚Üí Function.Injective f ‚Üí ClosedEmbedding f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any continuous function on compact Hausdorff spaces is a closed map. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {X Y : CompHaus} (f : X ‚ü∂ Y), IsClosedMap ‚áëf\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every two points in a Hausdorff space admit disjoint open neighbourhoods. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {X : Type u} [inst : TopologicalSpace X] [self : T2Space X] (x y : X),\\n  x ‚â† y ‚Üí ‚àÉ u v, IsOpen u ‚àß IsOpen v ‚àß x ‚àà u ‚àß y ‚àà v ‚àß Disjoint u v\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A continuous surjective map from a compact space to a Hausdorff space is a quotient map. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : CompactSpace X]\\n  [inst_3 : T2Space Y] {f : X ‚Üí Y}, Function.Surjective f ‚Üí Continuous f ‚Üí QuotientMap f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A continuous map from a compact space to a Hausdorff space is a closed map. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : CompactSpace X]\\n  [inst_3 : T2Space Y] {f : X ‚Üí Y}, Continuous f ‚Üí IsClosedMap f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A topological space $X$ is Hausdorff if and only if the diagonal map is an open map from $X$ to $X √ó X$.\"}]"}
{"text":"Any finite order element in a group is equal to the identity.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If an element in a group has order two, then it is its own inverse. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] {x : G}, orderOf x = 2 ‚Üí x‚Åª¬π = x\"},\n {\"role\": \"user\",\n  \"content\": \"The chosen element of the base group itself is the identity \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œπ : Type u_1} {G : Œπ ‚Üí Type u_2} {H : Type u_3} [inst : (i : Œπ) ‚Üí Group (G i)] [inst_1 : Group H]\\n  {œÜ : (i : Œπ) ‚Üí H ‚Üí* G i} (self : Monoid.PushoutI.NormalWord.Transversal œÜ) (i : Œπ),\\n  1 ‚àà Monoid.PushoutI.NormalWord.Transversal.set self i\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Commuting elements of finite order are closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Monoid G] {x y : G}, Commute x y ‚Üí IsOfFinOrder x ‚Üí IsOfFinOrder y ‚Üí IsOfFinOrder (x * y)\"},\n {\"role\": \"user\", \"content\": \"Any element commutes with itself. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {S : Type u_2} [inst : Mul S] (a : S), Commute a a\"},\n {\"role\": \"user\", \"content\": \"Any element commutes with itself.\"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {S : Type u_2} [inst : Add S] (a : S), AddCommute a a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Inverses of elements of finite additive order\\nhave finite additive order.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G] {x : G}, IsOfFinAddOrder (-x) ‚Üî IsOfFinAddOrder x\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is simple.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsSimpleAddGroup Œ±\"},\n {\"role\": \"user\",\n  \"content\": \"Elements of finite additive order are closed under addition.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : AddCommMonoid G] {x y : G}, IsOfFinAddOrder x ‚Üí IsOfFinAddOrder y ‚Üí IsOfFinAddOrder (x + y)\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is simple. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsSimpleGroup Œ±\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is cyclic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)], Fintype.card Œ± = p ‚Üí IsCyclic Œ±\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is cyclic.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsAddCyclic Œ±\"},\n {\"role\": \"user\",\n  \"content\": \"Elements of finite order are of finite order in submonoids.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : AddMonoid G] {H : AddSubmonoid G} {x : ‚Ü•H}, IsOfFinAddOrder ‚Üëx ‚Üî IsOfFinAddOrder x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The image of an element of finite additive order has finite additive order.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} {H : Type u_2} [inst : AddMonoid G] [inst_1 : AddMonoid H] (f : G ‚Üí+ H) {x : G},\\n  IsOfFinAddOrder x ‚Üí IsOfFinAddOrder (f x)\"},\n {\"role\": \"user\",\n  \"content\": \"The image of an element of finite order has finite order. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} {H : Type u_2} [inst : Monoid G] [inst_1 : Monoid H] (f : G ‚Üí* H) {x : G},\\n  IsOfFinOrder x ‚Üí IsOfFinOrder (f x)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A group element has finite additive order iff its order is positive.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : AddMonoid G] {x : G}, 0 < addOrderOf x ‚Üî IsOfFinAddOrder x\"},\n {\"role\": \"user\",\n  \"content\": \"Elements of finite order are closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : CommMonoid G] {x y : G}, IsOfFinOrder x ‚Üí IsOfFinOrder y ‚Üí IsOfFinOrder (x * y)\"},\n {\"role\": \"user\",\n  \"content\": \"Inverses of elements of finite order have finite order. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x‚Åª¬π ‚Üî IsOfFinOrder x\"},\n {\"role\": \"user\",\n  \"content\": \"A group element has finite order iff its order is positive. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x ‚Üî IsOfFinOrder x\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [self : LinearOrderedCommGroupWithZero Œ±] (a : Œ±), a ‚â† 0 ‚Üí a * a‚Åª¬π = 1\"},\n {\"role\": \"user\",\n  \"content\": \"Any finite order element in a group is equal to the identity.\"}]"}
{"text":"If a subgroup of a group is torsion-free, then the group itself is torsion free.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"Additive torsion groups are closed under extensions.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} {H : Type u_2} [inst : AddGroup G] {N : AddSubgroup G} [inst_1 : AddGroup H] {f : G ‚Üí+ H},\\n  N = AddMonoidHom.ker f ‚Üí AddMonoid.IsTorsion H ‚Üí AddMonoid.IsTorsion ‚Ü•N ‚Üí AddMonoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The additive torsion submonoid of an abelian group equals the torsion\\nsubgroup as a submonoid.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (G : Type u_1) [inst : AddCommGroup G], AddCommMonoid.addTorsion G = (AddCommGroup.torsion G).toAddSubmonoid\"},\n {\"role\": \"user\",\n  \"content\": \"The image of a quotient is torsion iff the group is torsion. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G ‚Üí* H},\\n  Function.Surjective ‚áëf ‚Üí N = MonoidHom.ker f ‚Üí Monoid.IsTorsion ‚Ü•N ‚Üí (Monoid.IsTorsion H ‚Üî Monoid.IsTorsion G)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Quotienting by the torsion submodule gives a torsion-free module. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M],\\n  Submodule.torsion R (M ‚ß∏ Submodule.torsion R M) = ‚ä•\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The Nielsen-Schreier theorem: a subgroup of a free group is free. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u} [inst : Group G] [inst_1 : IsFreeGroup G] (H : Subgroup G), IsFreeGroup ‚Ü•H\"},\n {\"role\": \"user\",\n  \"content\": \"A nontrivial torsion-free group is not torsion. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G ‚Üí ¬¨Monoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\": \"If a group exponent exists, the group is torsion. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G], Monoid.ExponentExists G ‚Üí Monoid.IsTorsion G\"},\n {\"role\": \"user\", \"content\": \"The torsion subgroup is cylic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (K : Type u_1) [inst : Field K] [inst_1 : NumberField K], IsCyclic ‚Ü•(NumberField.Units.torsion K)\"},\n {\"role\": \"user\", \"content\": \"Torsion groups are closed under extensions. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G ‚Üí* H},\\n  N = MonoidHom.ker f ‚Üí Monoid.IsTorsion H ‚Üí Monoid.IsTorsion ‚Ü•N ‚Üí Monoid.IsTorsion G\"},\n {\"role\": \"user\", \"content\": \"Torsion submonoids are torsion. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : CommMonoid G], Monoid.IsTorsion ‚Ü•(CommMonoid.torsion G)\"},\n {\"role\": \"user\", \"content\": \"Finite groups are torsion groups. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Subgroups of additive torsion groups are additive torsion groups.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G], AddMonoid.IsTorsion G ‚Üí ‚àÄ (H : AddSubgroup G), AddMonoid.IsTorsion ‚Ü•H\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The torsion submonoid of an abelian group equals the torsion subgroup as a submonoid. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (G : Type u_1) [inst : CommGroup G], CommMonoid.torsion G = (CommGroup.torsion G).toSubmonoid\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Direct products of additive torsion free groups are torsion free.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ∑ : Type u_3} {Gs : Œ∑ ‚Üí Type u_4} [inst : (i : Œ∑) ‚Üí AddGroup (Gs i)],\\n  (‚àÄ (i : Œ∑), AddMonoid.IsTorsionFree (Gs i)) ‚Üí AddMonoid.IsTorsionFree ((i : Œ∑) ‚Üí Gs i)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Quotienting a group by its additive torsion subgroup yields an additive torsion free group.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (G : Type u_1) [inst : AddCommGroup G], AddMonoid.IsTorsionFree (G ‚ß∏ AddCommGroup.torsion G)\"},\n {\"role\": \"user\",\n  \"content\": \"Subgroups of torsion groups are torsion groups. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ‚Üí ‚àÄ (H : Subgroup G), Monoid.IsTorsion ‚Ü•H\"},\n {\"role\": \"user\",\n  \"content\": \"Direct products of torsion free groups are torsion free. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ∑ : Type u_3} {Gs : Œ∑ ‚Üí Type u_4} [inst : (i : Œ∑) ‚Üí Group (Gs i)],\\n  (‚àÄ (i : Œ∑), Monoid.IsTorsionFree (Gs i)) ‚Üí Monoid.IsTorsionFree ((i : Œ∑) ‚Üí Gs i)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Subgroups of additive torsion-free groups are additively torsion-free.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G], AddMonoid.IsTorsionFree G ‚Üí ‚àÄ (H : AddSubgroup G), AddMonoid.IsTorsionFree ‚Ü•H\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Quotienting a group by its torsion subgroup yields a torsion free group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G ‚ß∏ CommGroup.torsion G)\"},\n {\"role\": \"user\",\n  \"content\": \"Subgroups of torsion-free groups are torsion-free. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G ‚Üí ‚àÄ (H : Subgroup G), Monoid.IsTorsionFree ‚Ü•H\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a subgroup of a group is torsion-free, then the group itself is torsion free.\"}]"}
{"text":"Every injective homomorphism from a finitely generated free group to itself is surjective.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"An epimorphism is surjective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} {M : Type u_2} {R‚ÇÇ : Type u_3} {M‚ÇÇ : Type u_4} [inst : Ring R] [inst_1 : Ring R‚ÇÇ]\\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommGroup M‚ÇÇ] [inst_4 : Module R M] [inst_5 : Module R‚ÇÇ M‚ÇÇ] {œÑ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ}\\n  [inst_6 : RingHomSurjective œÑ‚ÇÅ‚ÇÇ] {f : M ‚Üí‚Çõ‚Çó[œÑ‚ÇÅ‚ÇÇ] M‚ÇÇ},\\n  (‚àÄ (u v : M‚ÇÇ ‚Üí‚Çó[R‚ÇÇ] M‚ÇÇ ‚ß∏ LinearMap.range f), LinearMap.comp u f = LinearMap.comp v f ‚Üí u = v) ‚Üí LinearMap.range f = ‚ä§\"},\n {\"role\": \"user\", \"content\": \"A group homomorphism sends 1 to 1. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Group Œ±] [inst_1 : Group Œ≤] {f : Œ± ‚Üí Œ≤}, IsGroupHom f ‚Üí f 1 = 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A monoid homomorphism `f` induces an injective homomorphism on the quotient by `f`'s kernel. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {M : Type u_1} {P : Type u_3} [inst : MulOneClass M] [inst_1 : MulOneClass P] (f : M ‚Üí* P),\\n  Function.Injective ‚áë(Con.kerLift f)\"},\n {\"role\": \"user\", \"content\": \"A group homomorphism is a monoid homomorphism. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Group Œ±] [inst_1 : Group Œ≤] {f : Œ± ‚Üí Œ≤}, IsGroupHom f ‚Üí IsMonoidHom f\"},\n {\"role\": \"user\",\n  \"content\": \"A group homomorphism sends inverses to inverses. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Group Œ±] [inst_1 : Group Œ≤] {f : Œ± ‚Üí Œ≤}, IsGroupHom f ‚Üí ‚àÄ (a : Œ±), f a‚Åª¬π = (f a)‚Åª¬π\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The canonical map from the type to the free group is an injection. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {Œ± : Type u}, Function.Injective FreeGroup.of\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The induced algebra morphism from the quotient by the kernel is injective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R‚ÇÅ : Type u_1} {A : Type u_3} {B : Type u_4} [inst : CommSemiring R‚ÇÅ] [inst_1 : CommRing A] [inst_2 : CommRing B]\\n  [inst_3 : Algebra R‚ÇÅ A] [inst_4 : Algebra R‚ÇÅ B] (f : A ‚Üí‚Çê[R‚ÇÅ] B), Function.Injective ‚áë(Ideal.kerLiftAlg f)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The natural homomorphism from a monoid to its quotient by a congruence relation is\\nsurjective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {M : Type u_1} [inst : MulOneClass M] {c : Con M}, Function.Surjective ‚áë(Con.mk' c)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any surjective endomorphism of a Noetherian module is bijective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsNoetherian R M] (f : M ‚Üí‚Çó[R] M), Function.Surjective ‚áëf ‚Üí Function.Bijective ‚áëf\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The image of a surjective torsion group homomorphism is torsion. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H] {f : G ‚Üí* H},\\n  Function.Surjective ‚áëf ‚Üí Monoid.IsTorsion G ‚Üí Monoid.IsTorsion H\"},\n {\"role\": \"user\", \"content\": \"Group homomorphisms preserve inverse. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_6} {H : Type u_7} {F : Type u_8} [inst : Group G] [inst_1 : DivisionMonoid H]\\n  [inst_2 : MonoidHomClass F G H] (f : F) (a : G), f a‚Åª¬π = (f a)‚Åª¬π\"},\n {\"role\": \"user\",\n  \"content\":\n  \"On a finite-dimensional space, an injective linear map is surjective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] {f : V ‚Üí‚Çó[K] V}, Function.Injective ‚áëf ‚Üí Function.Surjective ‚áëf\"},\n {\"role\": \"user\",\n  \"content\": \"Any injective endomorphism of an Artinian module is bijective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsArtinian R M] (f : M ‚Üí‚Çó[R] M), Function.Injective ‚áëf ‚Üí Function.Bijective ‚áëf\"},\n {\"role\": \"user\",\n  \"content\":\n  \"An additive group homomorphism is injective if its kernel is trivial.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : AddGroup Œ±] [inst_1 : AddGroup Œ≤] {f : Œ± ‚Üí Œ≤},\\n  IsAddGroupHom f ‚Üí (Function.Injective f ‚Üî ‚àÄ (a : Œ±), f a = 0 ‚Üí a = 0)\"},\n {\"role\": \"user\", \"content\": \"The ring homomorphism is surjective \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R‚ÇÅ : Type u_1} {R‚ÇÇ : Type u_2} [inst : Semiring R‚ÇÅ] [inst_1 : Semiring R‚ÇÇ] {œÉ : R‚ÇÅ ‚Üí+* R‚ÇÇ}\\n  [self : RingHomSurjective œÉ], Function.Surjective ‚áëœÉ\"},\n {\"role\": \"user\",\n  \"content\": \"Every graph homomorphism from a complete graph is injective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {V : Type u} {W : Type v} {G' : SimpleGraph W} (f : ‚ä§ ‚Üíg G'), Function.Injective ‚áëf\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any surjective endomorphism of a Noetherian module is injective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsNoetherian R M] (f : M ‚Üí‚Çó[R] M), Function.Surjective ‚áëf ‚Üí Function.Injective ‚áëf\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any injective polynomial map over an algebraic extension of a finite field is surjective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œπ : Type u_1} {K : Type u_2} {R : Type u_3} [inst : Field K] [inst_1 : Finite K] [inst_2 : CommRing R]\\n  [inst_3 : Finite Œπ] [inst_4 : Algebra K R],\\n  Algebra.IsAlgebraic K R ‚Üí\\n    ‚àÄ (ps : Œπ ‚Üí MvPolynomial Œπ R),\\n      (Function.Injective fun v i => (MvPolynomial.eval v) (ps i)) ‚Üí\\n        Function.Surjective fun v i => (MvPolynomial.eval v) (ps i)\"},\n {\"role\": \"user\",\n  \"content\": \"A group homomorphism is injective iff its kernel is trivial. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Group Œ±] [inst_1 : Group Œ≤] {f : Œ± ‚Üí Œ≤},\\n  IsGroupHom f ‚Üí (Function.Injective f ‚Üî ‚àÄ (a : Œ±), f a = 1 ‚Üí a = 1)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any injective endomorphism of an Artinian module is surjective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsArtinian R M] (f : M ‚Üí‚Çó[R] M), Function.Injective ‚áëf ‚Üí Function.Surjective ‚áëf\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every injective homomorphism from a finitely generated free group to itself is surjective.\"}]"}
{"text":"Every division ring is either a field or finite.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"A finite space is bounded. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_4} [inst : Bornology Œ±] [inst_1 : Finite Œ±], BoundedSpace Œ±\"},\n {\"role\": \"user\",\n  \"content\": \"An intermediate field is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u_1} {L : Type u_2} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\\n  {x y : L}, x ‚àà S ‚Üí y ‚àà S ‚Üí x * y ‚àà S\"},\n {\"role\": \"user\", \"content\": \"A subfield is closed under division. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u} [inst : Field K] (s : Subfield K) {x y : K}, x ‚àà s ‚Üí y ‚àà s ‚Üí x / y ‚àà s\"},\n {\"role\": \"user\",\n  \"content\": \"A field extension is algebraic if it is finite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (K : Type u_1) (A : Type u_5) [inst : Field K] [inst_1 : Ring A] [inst_2 : Algebra K A]\\n  [inst_3 : FiniteDimensional K A], Algebra.IsAlgebraic K A\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A finite domain is a field. See also `littleWedderburn` and `Fintype.divisionRingOfIsDomain`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (D : Type u_1) [inst : Finite D] [inst : Ring D] [inst_1 : IsDomain D], IsField D\"},\n {\"role\": \"user\",\n  \"content\": \"A linear ordered field that is a floor ring is archimedean. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (Œ± : Type u_2) [inst : LinearOrderedField Œ±] [inst_1 : FloorRing Œ±], Archimedean Œ±\"},\n {\"role\": \"user\",\n  \"content\": \"A normed division ring is a topological division ring. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : NormedDivisionRing Œ±], TopologicalDivisionRing Œ±\"},\n {\"role\": \"user\",\n  \"content\": \"The characteristic of a finite ring cannot be zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (R : Type u_1) [inst : NonAssocRing R] (p : ‚Ñï) [inst : CharP R p] [inst : Finite R], p ‚â† 0\"},\n {\"role\": \"user\", \"content\": \"A finite field has prime power cardinality. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : Fintype Œ±] [inst_1 : Field Œ±], IsPrimePow (Fintype.card Œ±)\"},\n {\"role\": \"user\",\n  \"content\": \"Natural division is always less than division in the field. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : LinearOrderedSemifield Œ±] {m n : ‚Ñï}, ‚Üë(m / n) ‚â§ ‚Üëm / ‚Üën\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For a semiring to be a field, it must have two distinct elements. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {R : Type u} [inst : Semiring R], IsField R ‚Üí ‚àÉ x y, x ‚â† y\"},\n {\"role\": \"user\",\n  \"content\": \"All ideals in a division (semi)ring are trivial. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u} [inst : DivisionSemiring K] (I : Ideal K), I = ‚ä• ‚à® I = ‚ä§\"},\n {\"role\": \"user\", \"content\": \"The ground set is finite \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} {M : Matroid Œ±} [self : Matroid.Finite M], Set.Finite M.E\"},\n {\"role\": \"user\",\n  \"content\": \"Natural division is the floor of field division. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_2} [inst : LinearOrderedSemifield Œ±] [inst_1 : FloorSemiring Œ±] (m n : ‚Ñï), ‚åä‚Üëm / ‚Üën‚åã‚Çä = m / n\"},\n {\"role\": \"user\", \"content\": \"The category of rings has all limits. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"CategoryTheory.Limits.HasLimitsOfSize.{v, v, max u v, max (u + 1) (v + 1)} CommSemiRingCatMax\"},\n {\"role\": \"user\", \"content\": \"An intermediate field contains the ring's 0. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u_1} {L : Type u_2} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\\n  0 ‚àà S\"},\n {\"role\": \"user\", \"content\": \"An intermediate field contains the ring's 1. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u_1} {L : Type u_2} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\\n  1 ‚àà S\"},\n {\"role\": \"user\",\n  \"content\": \"An intermediate field is closed under division. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u_1} {L : Type u_2} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\\n  {x y : L}, x ‚àà S ‚Üí y ‚àà S ‚Üí x / y ‚àà S\"},\n {\"role\": \"user\", \"content\": \"A field is a valuation ring. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ (K : Type u) [inst : Field K], ValuationRing K\"},\n {\"role\": \"user\", \"content\": \"A valued division ring is separated. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u_1} [inst : DivisionRing K] {Œì‚ÇÄ : Type u_2} [inst_1 : LinearOrderedCommGroupWithZero Œì‚ÇÄ]\\n  [inst_2 : Valued K Œì‚ÇÄ], SeparatedSpace K\"},\n {\"role\": \"user\",\n  \"content\": \"Every division ring is either a field or finite.\"}]"}
{"text":"Every natural number is the product of two primes.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The numerator and denominator are coprime: it is in \\\"reduced form\\\". \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ (self : ‚Ñö), Nat.Coprime (Int.natAbs self.num) self.den\"},\n {\"role\": \"user\", \"content\": \"`2` is not a factor of an odd natural number. \"},\n {\"role\": \"assistant\", \"content\": \"‚àÄ {m n : ‚Ñï}, Odd n ‚Üí m ‚à£ n ‚Üí m ‚â† 2\"},\n {\"role\": \"user\",\n  \"content\": \"The exponential characteristic is a prime number or one. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (R : Type u) [inst : Semiring R] (q : ‚Ñï) [hq : ExpChar R q], Nat.Prime q ‚à® q = 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ (n : ‚Ñï), Nat.factorization n = 0 ‚Üî n = 0 ‚à® n = 1\"},\n {\"role\": \"user\",\n  \"content\": \"In a group of exponent two, every element is its own inverse. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G], Monoid.exponent G = 2 ‚Üí ‚àÄ (x : G), x‚Åª¬π = x\"},\n {\"role\": \"user\", \"content\": \"A minimal polynomial is prime. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\\n  IsIntegral A x ‚Üí Prime (minpoly A x)\"},\n {\"role\": \"user\",\n  \"content\": \"All composite numbers are Fermat pseudoprimes to base 1.\\n\"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {n : ‚Ñï}, 1 < n ‚Üí ¬¨Nat.Prime n ‚Üí Nat.FermatPsp n 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"We relate a finite product over primes to an infinite sum over smooth numbers. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} [inst : NormedCommRing R] [inst_1 : CompleteSpace R] {f : ‚Ñï ‚Üí R},\\n  f 1 = 1 ‚Üí\\n    (‚àÄ {m n : ‚Ñï}, Nat.Coprime m n ‚Üí f (m * n) = f m * f n) ‚Üí\\n      (‚àÄ {p : ‚Ñï}, Nat.Prime p ‚Üí Summable fun n => ‚Äñf (p ^ n)‚Äñ) ‚Üí\\n        ‚àÄ (N : ‚Ñï),\\n          (Summable fun m => ‚Äñf ‚Üëm‚Äñ) ‚àß\\n            HasSum (fun m => f ‚Üëm) (Finset.prod (Nat.primesBelow N) fun p => ‚àë' (n : ‚Ñï), f (p ^ n))\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A prime natural number is prime in `‚Ñ§[i]` if and only if it is `3` mod `4` \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ (p : ‚Ñï) [inst : Fact (Nat.Prime p)], Prime ‚Üëp ‚Üî p % 4 = 3\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two positive naturals are equal if their prime padic valuations are equal \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (a b : ‚Ñï), a ‚â† 0 ‚Üí b ‚â† 0 ‚Üí (a = b ‚Üî ‚àÄ (p : ‚Ñï), Nat.Prime p ‚Üí padicValNat p a = padicValNat p b)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a product lies in the prime ideal, then at least one element lies in the prime ideal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : Semiring Œ±] {I : Ideal Œ±} [self : Ideal.IsPrime I] {x y : Œ±}, x * y ‚àà I ‚Üí x ‚àà I ‚à® y ‚àà I\"},\n {\"role\": \"user\",\n  \"content\": \"The only divisors of prime powers are prime powers. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : CancelCommMonoidWithZero Œ±] [dec_irr : (p : Associates Œ±) ‚Üí Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid Œ±] [dec : DecidableEq Œ±] [dec' : DecidableEq (Associates Œ±)] {a p : Associates Œ±},\\n  Irreducible p ‚Üí\\n    ‚àÄ [inst_2 : (n : ‚Ñï) ‚Üí Decidable (a ‚à£ p ^ n)] {n : ‚Ñï} (h : a ‚à£ p ^ n),\\n      a = p ^ Nat.find (_ : ‚àÉ n, (fun n => a ‚à£ p ^ n) n)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {m n : ‚Ñï}, (‚àÄ (a : ‚Ñï), m ‚à£ a ‚Üî n ‚à£ a) ‚Üî m = n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {m n : ‚Ñï}, (‚àÄ (a : ‚Ñï), a ‚à£ m ‚Üî a ‚à£ n) ‚Üî m = n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {a b x y u v : ‚Ñï}, a = x ^ 2 + y ^ 2 ‚Üí b = u ^ 2 + v ^ 2 ‚Üí ‚àÉ r s, a * b = r ^ 2 + s ^ 2\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\", \"content\": \"Set.InjOn Nat.factorization {x | x ‚â† 0}\"},\n {\"role\": \"user\",\n  \"content\": \"Every natural number is the product of two primes.\"}]"}
{"text":"Every even number is the square of a natural number.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The real square root is at most the natural square root plus one \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {a : ‚Ñï}, Real.sqrt ‚Üëa ‚â§ ‚Üë(Nat.sqrt a) + 1\"},\n {\"role\": \"user\",\n  \"content\": \"In a group of exponent two, every element is its own inverse. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G], Monoid.exponent G = 2 ‚Üí ‚àÄ (x : G), x‚Åª¬π = x\"},\n {\"role\": \"user\", \"content\": \"`2` is not a factor of an odd natural number. \"},\n {\"role\": \"assistant\", \"content\": \"‚àÄ {m n : ‚Ñï}, Odd n ‚Üí m ‚à£ n ‚Üí m ‚â† 2\"},\n {\"role\": \"user\",\n  \"content\": \"The sum of two squares is zero iff both elements are zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : LinearOrderedRing Œ±] {x y : Œ±}, x * x + y * y = 0 ‚Üî x = 0 ‚àß y = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a finite field of odd characteristic, not every element is a square. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {F : Type u_3} [inst : Field F] [inst_1 : Finite F], ringChar F ‚â† 2 ‚Üí ‚àÉ a, ¬¨IsSquare a\"},\n {\"role\": \"user\",\n  \"content\": \"A natural number is odd iff it has residue `1` or `3` mod `4`\"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {n : ‚Ñï}, n % 2 = 1 ‚Üî n % 4 = 1 ‚à® n % 4 = 3\"},\n {\"role\": \"user\",\n  \"content\": \"The natural square root is at most the real square root \"},\n {\"role\": \"assistant\", \"content\": \"‚àÄ {a : ‚Ñï}, ‚Üë(Nat.sqrt a) ‚â§ Real.sqrt ‚Üëa\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The special case of Graham's conjecture where all numbers are squarefree. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {n : ‚Ñï} (f : ‚Ñï ‚Üí ‚Ñï), (‚àÄ k < n, Squarefree (f k)) ‚Üí Nat.GrahamConjecture n f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {m n : ‚Ñï}, (‚àÄ (a : ‚Ñï), a ‚à£ m ‚Üî a ‚à£ n) ‚Üî m = n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {n : ‚Ñï}, IsSquare (-1) ‚Üí ‚àÉ x y, n = x ^ 2 + y ^ 2\"},\n {\"role\": \"user\",\n  \"content\": \"The convolution of two even functions is also even. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {ùïú : Type uùïú} {G : Type uG} {E : Type uE} {E' : Type uE'} {F : Type uF} [inst : NormedAddCommGroup E]\\n  [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedAddCommGroup F] {f : G ‚Üí E} {g : G ‚Üí E'} {x : G}\\n  [inst_3 : NontriviallyNormedField ùïú] [inst_4 : NormedSpace ùïú E] [inst_5 : NormedSpace ùïú E'] [inst_6 : NormedSpace ùïú F]\\n  (L : E ‚ÜíL[ùïú] E' ‚ÜíL[ùïú] F) [inst_7 : MeasurableSpace G] {Œº : MeasureTheory.Measure G} [inst_8 : NormedSpace ‚Ñù F]\\n  [inst_9 : AddCommGroup G] [inst_10 : MeasureTheory.Measure.IsAddLeftInvariant Œº]\\n  [inst_11 : MeasureTheory.Measure.IsNegInvariant Œº] [inst_12 : MeasurableNeg G] [inst_13 : MeasurableAdd G],\\n  (‚àÄ·µê (x : G) ‚àÇŒº, f (-x) = f x) ‚Üí (‚àÄ·µê (x : G) ‚àÇŒº, g (-x) = g x) ‚Üí convolution f g L (-x) = convolution f g L x\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\", \"content\": \"Set.InjOn Nat.factorization {x | x ‚â† 0}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"**Euler's four-square identity**, a version for natural numbers. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (a b c d x y z w : ‚Ñï),\\n  Int.natAbs (‚Üëa * ‚Üëx - ‚Üëb * ‚Üëy - ‚Üëc * ‚Üëz - ‚Üëd * ‚Üëw) ^ 2 + Int.natAbs (‚Üëa * ‚Üëy + ‚Üëb * ‚Üëx + ‚Üëc * ‚Üëw - ‚Üëd * ‚Üëz) ^ 2 +\\n        Int.natAbs (‚Üëa * ‚Üëz - ‚Üëb * ‚Üëw + ‚Üëc * ‚Üëx + ‚Üëd * ‚Üëy) ^ 2 +\\n      Int.natAbs (‚Üëa * ‚Üëw + ‚Üëb * ‚Üëz - ‚Üëc * ‚Üëy + ‚Üëd * ‚Üëx) ^ 2 =\\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a finite field of characteristic `2`, all elements are squares. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {F : Type u_3} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 ‚Üí ‚àÄ (a : F), IsSquare a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {m n : ‚Ñï}, (‚àÄ (a : ‚Ñï), m ‚à£ a ‚Üî n ‚à£ a) ‚Üî m = n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {a b x y u v : ‚Ñï}, a = x ^ 2 + y ^ 2 ‚Üí b = u ^ 2 + v ^ 2 ‚Üí ‚àÉ r s, a * b = r ^ 2 + s ^ 2\"},\n {\"role\": \"user\",\n  \"content\": \"Every even number is the square of a natural number.\"}]"}
{"text":"Every normal subgroup of a group has finite index.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"Inverses of elements of finite order have finite order. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x‚Åª¬π ‚Üî IsOfFinOrder x\"},\n {\"role\": \"user\",\n  \"content\": \"Elements of finite order are of finite order in submonoids.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : AddMonoid G] {H : AddSubmonoid G} {x : ‚Ü•H}, IsOfFinAddOrder ‚Üëx ‚Üî IsOfFinAddOrder x\"},\n {\"role\": \"user\", \"content\": \"A subgroup is closed under division. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {M : Type u_5} {S : Type u_6} [inst : DivInvMonoid M] [inst_1 : SetLike S M] [hSM : SubgroupClass S M] {H : S}\\n  {x y : M}, x ‚àà H ‚Üí y ‚àà H ‚Üí x / y ‚àà H\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a module has a finite dimension, all bases are indexed by a finite type. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} [inst : Ring R] [inst_1 : StrongRankCondition R] {M : Type v} [inst_2 : AddCommGroup M]\\n  [inst_3 : Module R M] {Œπ : Type u_2}, Basis Œπ R M ‚Üí Module.rank R M < Cardinal.aleph0 ‚Üí Nonempty (Fintype Œπ)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (G : Type u_1) [inst : Group G] [inst_1 : Finite ‚Üë(commutatorSet G)], Finite ‚Ü•(commutator G)\"},\n {\"role\": \"user\", \"content\": \"Elements of disjoint, normal subgroups commute.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G] (H‚ÇÅ H‚ÇÇ : AddSubgroup G),\\n  AddSubgroup.Normal H‚ÇÅ ‚Üí AddSubgroup.Normal H‚ÇÇ ‚Üí Disjoint H‚ÇÅ H‚ÇÇ ‚Üí ‚àÄ (x y : G), x ‚àà H‚ÇÅ ‚Üí y ‚àà H‚ÇÇ ‚Üí AddCommute x y\"},\n {\"role\": \"user\",\n  \"content\": \"The topological closure of a normal subgroup is normal.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N)\"},\n {\"role\": \"user\", \"content\": \"A subgroup is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x ‚àà H ‚Üí y ‚àà H ‚Üí x * y ‚àà H\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is cyclic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)], Fintype.card Œ± = p ‚Üí IsCyclic Œ±\"},\n {\"role\": \"user\",\n  \"content\": \"Elements of disjoint, normal subgroups commute. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] (H‚ÇÅ H‚ÇÇ : Subgroup G),\\n  Subgroup.Normal H‚ÇÅ ‚Üí Subgroup.Normal H‚ÇÇ ‚Üí Disjoint H‚ÇÅ H‚ÇÇ ‚Üí ‚àÄ (x y : G), x ‚àà H‚ÇÅ ‚Üí y ‚àà H‚ÇÇ ‚Üí Commute x y\"},\n {\"role\": \"user\",\n  \"content\": \"For each `n ‚â• 0`, the unit group of `ZMod n` is finite. \"},\n {\"role\": \"assistant\", \"content\": \"‚àÄ (n : ‚Ñï), Finite (ZMod n)À£\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A finite subgroup of the unit group of an integral domain is cyclic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} {G : Type u_2} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\\n  (f : G ‚Üí* R), Function.Injective ‚áëf ‚Üí IsCyclic G\"},\n {\"role\": \"user\", \"content\": \"A finite index subgroup has finite quotient. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"{G : Type u_1} ‚Üí [inst : Group G] ‚Üí (H : Subgroup G) ‚Üí [inst_1 : Subgroup.FiniteIndex H] ‚Üí Fintype (G ‚ß∏ H)\"},\n {\"role\": \"user\",\n  \"content\": \"The submodule generated by a finite set is finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (K : Type u) {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {A : Set V},\\n  Set.Finite A ‚Üí FiniteDimensional K ‚Ü•(Submodule.span K A)\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is simple. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsSimpleGroup Œ±\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a module has a finite dimension, all bases are indexed by a finite set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} [inst : Ring R] [inst_1 : StrongRankCondition R] {M : Type v} [inst_2 : AddCommGroup M]\\n  [inst_3 : Module R M] {Œπ : Type u_2} {s : Set Œπ}, Basis (‚Üës) R M ‚Üí Module.rank R M < Cardinal.aleph0 ‚Üí Set.Finite s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A subgroup is finitely generated if and only if it is finitely generated as a submonoid. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_3} [inst : Group G] (P : Subgroup G), Subgroup.FG P ‚Üî Submonoid.FG P.toSubmonoid\"},\n {\"role\": \"user\",\n  \"content\":\n  \"**Schreier's Lemma**: A finite index subgroup of a finitely generated\\ngroup is finitely generated. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] (H : Subgroup G) [hG : Group.FG G] [inst_1 : Subgroup.FiniteIndex H], Group.FG ‚Ü•H\"},\n {\"role\": \"user\", \"content\": \"The additive subgroup has finite index \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_2} [inst : AddGroup G] {H : AddSubgroup G} [self : AddSubgroup.FiniteIndex H], AddSubgroup.index H ‚â† 0\"},\n {\"role\": \"user\", \"content\": \"The subgroup has finite index \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.FiniteIndex H], Subgroup.index H ‚â† 0\"},\n {\"role\": \"user\",\n  \"content\": \"Every normal subgroup of a group has finite index.\"}]"}
{"text":"The characteristic polynomial of every matrix has real roots.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"An irreducible polynomial of prime degree with 1-3 non-real roots has full Galois group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {p : Polynomial ‚Ñö},\\n  Irreducible p ‚Üí\\n    Nat.Prime (Polynomial.natDegree p) ‚Üí\\n      Fintype.card ‚Üë(Polynomial.rootSet p ‚Ñù) + 1 ‚â§ Fintype.card ‚Üë(Polynomial.rootSet p ‚ÑÇ) ‚Üí\\n        Fintype.card ‚Üë(Polynomial.rootSet p ‚ÑÇ) ‚â§ Fintype.card ‚Üë(Polynomial.rootSet p ‚Ñù) + 3 ‚Üí\\n          Function.Bijective ‚áë(Polynomial.Gal.galActionHom p ‚ÑÇ)\"},\n {\"role\": \"user\",\n  \"content\": \"An element is a root of its minimal polynomial. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (A : Type u_1) {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B),\\n  (Polynomial.aeval x) (minpoly A x) = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The eigenvalues of a positive semi-definite matrix are non-negative \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {n : Type u_2} {ùïú : Type u_4} [inst : Fintype n] [inst_1 : IsROrC ùïú] [inst_2 : DecidableEq n] {A : Matrix n n ùïú}\\n  (hA : Matrix.PosSemidef A) (i : n), 0 ‚â§ Matrix.IsHermitian.eigenvalues (_ : Matrix.IsHermitian A) i\"},\n {\"role\": \"user\",\n  \"content\":\n  \"An irreducible polynomial of prime degree with two non-real roots has full Galois group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {p : Polynomial ‚Ñö},\\n  Irreducible p ‚Üí\\n    Nat.Prime (Polynomial.natDegree p) ‚Üí\\n      Fintype.card ‚Üë(Polynomial.rootSet p ‚ÑÇ) = Fintype.card ‚Üë(Polynomial.rootSet p ‚Ñù) + 2 ‚Üí\\n        Function.Bijective ‚áë(Polynomial.Gal.galActionHom p ‚ÑÇ)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"An algebraic integer whose conjugates are all of norm one is a root of unity. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (K : Type u_1) [inst : Field K] [inst_1 : NumberField K] (A : Type u_2) [inst_2 : NormedField A]\\n  [inst_3 : IsAlgClosed A] [inst_4 : NormedAlgebra ‚Ñö A] {x : K},\\n  IsIntegral ‚Ñ§ x ‚Üí (‚àÄ (œÜ : K ‚Üí+* A), ‚ÄñœÜ x‚Äñ = 1) ‚Üí ‚àÉ n, ‚àÉ (_ : 0 < n), x ^ n = 1\"},\n {\"role\": \"user\", \"content\": \"Every identity matrix is diagonal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} {n : Type u_4} [inst : DecidableEq n] [inst_1 : Zero Œ±] [inst_2 : One Œ±], Matrix.IsDiag 1\"},\n {\"role\": \"user\",\n  \"content\": \"The degree of a minimal polynomial is positive. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : Nontrivial B], IsIntegral A x ‚Üí 0 < Polynomial.degree (minpoly A x)\"},\n {\"role\": \"user\",\n  \"content\": \"Every polynomial is a polynomial in finitely many variables. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {œÉ : Type u_1} {R : Type u_4} [inst : CommSemiring R] (p : MvPolynomial œÉ R),\\n  ‚àÉ n f, ‚àÉ (_ : Function.Injective f), ‚àÉ q, p = (MvPolynomial.rename f) q\"},\n {\"role\": \"user\",\n  \"content\": \"Any element of the spectrum of a selfadjoint is real. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {A : Type u_1} [inst : NormedRing A] [inst_1 : NormedAlgebra ‚ÑÇ A] [inst_2 : CompleteSpace A] [inst_3 : StarRing A]\\n  [inst_4 : CstarRing A] [inst_5 : StarModule ‚ÑÇ A] (a : ‚Ü•(selfAdjoint A)) {z : ‚ÑÇ}, z ‚àà spectrum ‚ÑÇ ‚Üëa ‚Üí z = ‚Üëz.re\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A nonzero Hermitian matrix has an eigenvector with nonzero eigenvalue. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {ùïú : Type u_1} [inst : IsROrC ùïú] {n : Type u_2} [inst_1 : Fintype n] [inst_2 : DecidableEq n] {A : Matrix n n ùïú},\\n  Matrix.IsHermitian A ‚Üí A ‚â† 0 ‚Üí ‚àÉ v t, t ‚â† 0 ‚àß v ‚â† 0 ‚àß Matrix.mulVec A v = t ‚Ä¢ v\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The minimal polynomial of a nonzero element has nonzero constant coefficient. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\\n  IsIntegral A x ‚Üí x ‚â† 0 ‚Üí Polynomial.coeff (minpoly A x) 0 ‚â† 0\"},\n {\"role\": \"user\",\n  \"content\": \"The eigenvalues of a self-adjoint operator are real. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {ùïú : Type u_1} [inst : IsROrC ùïú] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ùïú E]\\n  {T : E ‚Üí‚Çó[ùïú] E}, LinearMap.IsSymmetric T ‚Üí ‚àÄ {Œº : ùïú}, Module.End.HasEigenvalue T Œº ‚Üí (starRingEnd ùïú) Œº = Œº\"},\n {\"role\": \"user\",\n  \"content\": \"The eigenvalues of a positive definite matrix are positive \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {n : Type u_2} {ùïú : Type u_4} [inst : Fintype n] [inst_1 : IsROrC ùïú] [inst_2 : DecidableEq n] {A : Matrix n n ùïú}\\n  (hA : Matrix.PosDef A) (i : n), 0 < Matrix.IsHermitian.eigenvalues (_ : Matrix.IsHermitian A) i\"},\n {\"role\": \"user\",\n  \"content\":\n  \"**Fundamental theorem of algebra**: every non constant complex polynomial\\nhas a root \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {f : Polynomial ‚ÑÇ}, 0 < Polynomial.degree f ‚Üí ‚àÉ z, Polynomial.IsRoot f z\"},\n {\"role\": \"user\",\n  \"content\": \"The diagonal elements of a complex hermitian matrix are real. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} {n : Type u_4} [inst : IsROrC Œ±] {A : Matrix n n Œ±},\\n  Matrix.IsHermitian A ‚Üí (fun i => ‚Üë(IsROrC.re (Matrix.diag A i))) = Matrix.diag A\"},\n {\"role\": \"user\",\n  \"content\": \"The characteristic polynomial of every matrix has real roots.\"}]"}
{"text":"In a commutative ring, every prime ideal is contained in a unique maximal ideal.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The surjective image of a principal ideal ring is again a principal ideal ring. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} {S : Type u_1} [inst : Ring R] [inst_1 : Ring S] [inst_2 : IsPrincipalIdealRing R] (f : R ‚Üí+* S),\\n  Function.Surjective ‚áëf ‚Üí IsPrincipalIdealRing S\"},\n {\"role\": \"user\",\n  \"content\": \"This ideal is maximal in the collection of proper ideals. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {P : Type u_1} [inst : LE P] {I : Order.Ideal P} [self : Order.Ideal.IsMaximal I] ‚¶ÉJ : Order.Ideal P‚¶Ñ,\\n  I < J ‚Üí ‚ÜëJ = Set.univ\"},\n {\"role\": \"user\",\n  \"content\": \"When a ring is not a field, the maximal ideals are nontrivial. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} [inst : CommSemiring R] [inst_1 : Nontrivial R] {M : Ideal R}, Ideal.IsMaximal M ‚Üí ¬¨IsField R ‚Üí M ‚â† ‚ä•\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a noetherian ring, every ideal contains a product of prime ideals\\n([samuel, ¬ß 3.3, Lemma 3])\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (R : Type u) [inst : CommRing R] [inst_1 : IsNoetherianRing R] (I : Ideal R),\\n  ‚àÉ Z, Multiset.prod (Multiset.map PrimeSpectrum.asIdeal Z) ‚â§ I\"},\n {\"role\": \"user\",\n  \"content\": \"The kernel of a homomorphism to a field is a maximal ideal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} {K : Type u_2} {F : Type u_3} [inst : Ring R] [inst_1 : Field K] [inst_2 : RingHomClass F R K] (f : F),\\n  Function.Surjective ‚áëf ‚Üí Ideal.IsMaximal (RingHom.ker f)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The prime spectrum of a commutative ring is a compact topological space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} [inst : CommRing R], CompactSpace (PrimeSpectrum R)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a product lies in the prime ideal, then at least one element lies in the prime ideal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : Semiring Œ±] {I : Ideal Œ±} [self : Ideal.IsPrime I] {x y : Œ±}, x * y ‚àà I ‚Üí x ‚àà I ‚à® y ‚àà I\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The `Ideal.closure` of a maximal ideal in a complete normed ring is the ideal itself. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] {I : Ideal R}, Ideal.IsMaximal I ‚Üí Ideal.closure I = I\"},\n {\"role\": \"user\", \"content\": \"Any finitely generated ideal is principal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} [inst : CommRing R] [self : IsBezout R] (I : Ideal R), Ideal.FG I ‚Üí Submodule.IsPrincipal I\"},\n {\"role\": \"user\",\n  \"content\": \"Maximal ideals in complete normed rings are closed. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] {I : Ideal R} [hI : Ideal.IsMaximal I], IsClosed ‚ÜëI\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The unique maximal ideal of the localization at `I.primeCompl` lies over the ideal `I`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} [inst : CommSemiring R] {I : Ideal R} [hI : Ideal.IsPrime I],\\n  Ideal.comap (algebraMap R (Localization.AtPrime I)) (LocalRing.maximalIdeal (Localization (Ideal.primeCompl I))) = I\"},\n {\"role\": \"user\",\n  \"content\": \"Krull's theorem: a nontrivial ring has a maximal ideal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (Œ± : Type u) [inst : Semiring Œ±] [inst_1 : Nontrivial Œ±], ‚àÉ M, Ideal.IsMaximal M\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If the quotient by an ideal is a field, then the ideal is maximal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} [inst : CommRing R] (I : Ideal R), IsField (R ‚ß∏ I) ‚Üí Ideal.IsMaximal I\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The quotient of a ring by an ideal is a field iff the ideal is maximal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I ‚Üî IsField (R ‚ß∏ I)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If all prime ideals in a commutative ring are principal, so are all other ideals. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} [inst : CommRing R],\\n  (‚àÄ (P : Ideal R), Ideal.IsPrime P ‚Üí Submodule.IsPrincipal P) ‚Üí IsPrincipalIdealRing R\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a commutative ring, every prime ideal is contained in a unique maximal ideal.\"}]"}
{"text":"Every continuous function is uniformly continuous.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"Uniform equicontinuity implies equicontinuity. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œπ : Type u_1} {Œ± : Type u_6} {Œ≤ : Type u_7} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] {F : Œπ ‚Üí Œ≤ ‚Üí Œ±},\\n  UniformEquicontinuous F ‚Üí Equicontinuous F\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A sequentially continuous function defined on a sequential space is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : SequentialSpace X]\\n  {f : X ‚Üí Y}, SeqContinuous f ‚Üí Continuous f\"},\n {\"role\": \"user\",\n  \"content\": \"A continuous function is bounded above on a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : TopologicalSpace Œ≤]\\n  [inst_3 : ClosedIciTopology Œ±] [inst_4 : Nonempty Œ±] {f : Œ≤ ‚Üí Œ±} {K : Set Œ≤},\\n  IsCompact K ‚Üí ContinuousOn f K ‚Üí BddAbove (f '' K)\"},\n {\"role\": \"user\", \"content\": \"A single function is uniformly integrable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {Œπ : Type u_3} {m : MeasurableSpace Œ±} (Œº : MeasureTheory.Measure Œ±)\\n  [inst : NormedAddCommGroup Œ≤] {p : ENNReal} [inst_1 : Subsingleton Œπ],\\n  1 ‚â§ p ‚Üí p ‚â† ‚ä§ ‚Üí ‚àÄ {f : Œπ ‚Üí Œ± ‚Üí Œ≤}, (‚àÄ (i : Œπ), MeasureTheory.Mem‚Ñíp (f i) p) ‚Üí MeasureTheory.UnifIntegrable f p Œº\"},\n {\"role\": \"user\", \"content\": \"A Lipschitz function is uniformly continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoEMetricSpace Œ±] [inst_1 : PseudoEMetricSpace Œ≤] {K : NNReal} {f : Œ± ‚Üí Œ≤},\\n  LipschitzWith K f ‚Üí UniformContinuous f\"},\n {\"role\": \"user\",\n  \"content\": \"Each function of an equicontinuous family is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œπ : Type u_1} {X : Type u_3} {Œ± : Type u_6} [inst : TopologicalSpace X] [inst_1 : UniformSpace Œ±] {F : Œπ ‚Üí X ‚Üí Œ±},\\n  Equicontinuous F ‚Üí ‚àÄ (i : Œπ), Continuous (F i)\"},\n {\"role\": \"user\", \"content\": \"Uniform continuity of the function \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_4} {Œ≤ : Type u_5} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] (self : Œ± ‚âÉ·µ§ Œ≤),\\n  UniformContinuous self.toFun\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A constant sequence of functions is uniformly integrable in the probability sense. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {Œπ : Type u_3} {m : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±}\\n  [inst : NormedAddCommGroup Œ≤] {p : ENNReal} {g : Œ± ‚Üí Œ≤},\\n  1 ‚â§ p ‚Üí p ‚â† ‚ä§ ‚Üí MeasureTheory.Mem‚Ñíp g p ‚Üí MeasureTheory.UniformIntegrable (fun x => g) p Œº\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A function which can be locally uniformly approximated by continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤} [inst_1 : TopologicalSpace Œ±],\\n  (‚àÄ (x : Œ±), ‚àÄ u ‚àà uniformity Œ≤, ‚àÉ t ‚àà nhds x, ‚àÉ F, ContinuousAt F x ‚àß ‚àÄ y ‚àà t, (f y, F y) ‚àà u) ‚Üí Continuous f\"},\n {\"role\": \"user\",\n  \"content\": \"A locally uniform limit of continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {p : Filter Œπ}\\n  [inst_1 : TopologicalSpace Œ±],\\n  TendstoLocallyUniformly F f p ‚Üí (‚àÄ·∂† (n : Œπ) in p, Continuous (F n)) ‚Üí ‚àÄ [inst_2 : Filter.NeBot p], Continuous f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A function which can be uniformly approximated by continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤} [inst_1 : TopologicalSpace Œ±],\\n  (‚àÄ u ‚àà uniformity Œ≤, ‚àÉ F, Continuous F ‚àß ‚àÄ (y : Œ±), (f y, F y) ‚àà u) ‚Üí Continuous f\"},\n {\"role\": \"user\", \"content\": \"A constant function is uniformly integrable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {Œπ : Type u_3} {m : MeasurableSpace Œ±} (Œº : MeasureTheory.Measure Œ±)\\n  [inst : NormedAddCommGroup Œ≤] {p : ENNReal} {g : Œ± ‚Üí Œ≤},\\n  1 ‚â§ p ‚Üí p ‚â† ‚ä§ ‚Üí MeasureTheory.Mem‚Ñíp g p ‚Üí MeasureTheory.UnifIntegrable (fun x => g) p Œº\"},\n {\"role\": \"user\",\n  \"content\": \"A uniform limit of continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {p : Filter Œπ}\\n  [inst_1 : TopologicalSpace Œ±],\\n  TendstoUniformly F f p ‚Üí (‚àÄ·∂† (n : Œπ) in p, Continuous (F n)) ‚Üí ‚àÄ [inst_2 : Filter.NeBot p], Continuous f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Each function of a uniformly equicontinuous family is uniformly continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œπ : Type u_1} {Œ± : Type u_6} {Œ≤ : Type u_7} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] {F : Œπ ‚Üí Œ≤ ‚Üí Œ±},\\n  UniformEquicontinuous F ‚Üí ‚àÄ (i : Œπ), UniformContinuous (F i)\"},\n {\"role\": \"user\",\n  \"content\": \"Every continuous function is uniformly continuous.\"}]"}
{"text":"Every uniformly continuous function is bounded above.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A constant sequence of functions is uniformly integrable in the probability sense. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {Œπ : Type u_3} {m : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±}\\n  [inst : NormedAddCommGroup Œ≤] {p : ENNReal} {g : Œ± ‚Üí Œ≤},\\n  1 ‚â§ p ‚Üí p ‚â† ‚ä§ ‚Üí MeasureTheory.Mem‚Ñíp g p ‚Üí MeasureTheory.UniformIntegrable (fun x => g) p Œº\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a directed order, the union of bounded above sets is bounded above. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : Preorder Œ±] [inst_1 : IsDirected Œ± fun x x_1 => x ‚â§ x_1] {s t : Set Œ±},\\n  BddAbove s ‚Üí BddAbove t ‚Üí BddAbove (s ‚à™ t)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A function which can be locally uniformly approximated by continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤} [inst_1 : TopologicalSpace Œ±],\\n  (‚àÄ (x : Œ±), ‚àÄ u ‚àà uniformity Œ≤, ‚àÉ t ‚àà nhds x, ‚àÉ F, ContinuousAt F x ‚àß ‚àÄ y ‚àà t, (f y, F y) ‚àà u) ‚Üí Continuous f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The image of a totally bounded set under a uniformly continuous map is totally bounded. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [uniformSpace : UniformSpace Œ±] [inst : UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤} {s : Set Œ±},\\n  TotallyBounded s ‚Üí UniformContinuous f ‚Üí TotallyBounded (f '' s)\"},\n {\"role\": \"user\", \"content\": \"A constant function is uniformly integrable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {Œπ : Type u_3} {m : MeasurableSpace Œ±} (Œº : MeasureTheory.Measure Œ±)\\n  [inst : NormedAddCommGroup Œ≤] {p : ENNReal} {g : Œ± ‚Üí Œ≤},\\n  1 ‚â§ p ‚Üí p ‚â† ‚ä§ ‚Üí MeasureTheory.Mem‚Ñíp g p ‚Üí MeasureTheory.UnifIntegrable (fun x => g) p Œº\"},\n {\"role\": \"user\", \"content\": \"A Lipschitz function is uniformly continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoEMetricSpace Œ±] [inst_1 : PseudoEMetricSpace Œ≤] {K : NNReal} {f : Œ± ‚Üí Œ≤},\\n  LipschitzWith K f ‚Üí UniformContinuous f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A function which can be uniformly approximated by continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤} [inst_1 : TopologicalSpace Œ±],\\n  (‚àÄ u ‚àà uniformity Œ≤, ‚àÉ F, Continuous F ‚àß ‚àÄ (y : Œ±), (f y, F y) ‚àà u) ‚Üí Continuous f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A finite union of sets which are all bounded above is still bounded above.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Preorder Œ±] [inst_1 : IsDirected Œ± fun x x_1 => x ‚â§ x_1] [inst_2 : Nonempty Œ±]\\n  {I : Set Œ≤} {S : Œ≤ ‚Üí Set Œ±}, Set.Finite I ‚Üí (BddAbove (‚ãÉ i ‚àà I, S i) ‚Üî ‚àÄ i ‚àà I, BddAbove (S i))\"},\n {\"role\": \"user\", \"content\": \"A continuous, periodic function is bounded. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {f : ‚Ñù ‚Üí Œ±} {c : ‚Ñù},\\n  Function.Periodic f c ‚Üí c ‚â† 0 ‚Üí Continuous f ‚Üí Bornology.IsBounded (Set.range f)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Each function of a uniformly equicontinuous family is uniformly continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œπ : Type u_1} {Œ± : Type u_6} {Œ≤ : Type u_7} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] {F : Œπ ‚Üí Œ≤ ‚Üí Œ±},\\n  UniformEquicontinuous F ‚Üí ‚àÄ (i : Œπ), UniformContinuous (F i)\"},\n {\"role\": \"user\",\n  \"content\": \"A continuous function with compact support is bounded below. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : TopologicalSpace Œ≤]\\n  [inst_3 : ClosedIicTopology Œ±] [inst_4 : Zero Œ±] {f : Œ≤ ‚Üí Œ±},\\n  Continuous f ‚Üí HasCompactSupport f ‚Üí BddBelow (Set.range f)\"},\n {\"role\": \"user\", \"content\": \"A finite set is bounded above.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : Preorder Œ±] [inst_1 : IsDirected Œ± fun x x_1 => x ‚â§ x_1] [inst_2 : Nonempty Œ±] {s : Set Œ±},\\n  Set.Finite s ‚Üí BddAbove s\"},\n {\"role\": \"user\",\n  \"content\": \"A locally uniform limit of continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {p : Filter Œπ}\\n  [inst_1 : TopologicalSpace Œ±],\\n  TendstoLocallyUniformly F f p ‚Üí (‚àÄ·∂† (n : Œπ) in p, Continuous (F n)) ‚Üí ‚àÄ [inst_2 : Filter.NeBot p], Continuous f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The indexed supremum of a function is bounded above by a uniform bound\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} {Œπ : Sort u_4} [inst : ConditionallyCompleteLattice Œ±] [inst_1 : Nonempty Œπ] {f : Œπ ‚Üí Œ±} {c : Œ±},\\n  (‚àÄ (x : Œπ), f x ‚â§ c) ‚Üí iSup f ‚â§ c\"},\n {\"role\": \"user\",\n  \"content\": \"A continuous function is bounded below on a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : TopologicalSpace Œ≤]\\n  [inst_3 : ClosedIicTopology Œ±] [inst_4 : Nonempty Œ±] {f : Œ≤ ‚Üí Œ±} {K : Set Œ≤},\\n  IsCompact K ‚Üí ContinuousOn f K ‚Üí BddBelow (f '' K)\"},\n {\"role\": \"user\",\n  \"content\": \"A uniform limit of continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {p : Filter Œπ}\\n  [inst_1 : TopologicalSpace Œ±],\\n  TendstoUniformly F f p ‚Üí (‚àÄ·∂† (n : Œπ) in p, Continuous (F n)) ‚Üí ‚àÄ [inst_2 : Filter.NeBot p], Continuous f\"},\n {\"role\": \"user\",\n  \"content\": \"A continuous function with compact support is bounded above. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : TopologicalSpace Œ≤]\\n  [inst_3 : ClosedIciTopology Œ±] [inst_4 : Zero Œ±] {f : Œ≤ ‚Üí Œ±},\\n  Continuous f ‚Üí HasCompactSupport f ‚Üí BddAbove (Set.range f)\"},\n {\"role\": \"user\",\n  \"content\": \"A continuous function is bounded above on a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : TopologicalSpace Œ≤]\\n  [inst_3 : ClosedIciTopology Œ±] [inst_4 : Nonempty Œ±] {f : Œ≤ ‚Üí Œ±} {K : Set Œ≤},\\n  IsCompact K ‚Üí ContinuousOn f K ‚Üí BddAbove (f '' K)\"},\n {\"role\": \"user\",\n  \"content\": \"Every uniformly continuous function is bounded above.\"}]"}
{"text":"If every compact subset of a topological space is closed, then the space is compact.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any continuous function on compact Hausdorff spaces is a closed map. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {X Y : CompHaus} (f : X ‚ü∂ Y), IsClosedMap ‚áëf\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The intersection of two open compact subsets of a quasi-separated space is compact.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_3} [inst : TopologicalSpace Œ±] [self : QuasiSeparatedSpace Œ±] (U V : Set Œ±),\\n  IsOpen U ‚Üí IsCompact U ‚Üí IsOpen V ‚Üí IsCompact V ‚Üí IsCompact (U ‚à© V)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a compact set is included in a measurable set, then so is its closure. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_2} [inst : MeasurableSpace G] [inst_1 : TopologicalSpace G] [inst_2 : BorelSpace G] [inst_3 : Group G]\\n  [inst_4 : TopologicalGroup G] {k s : Set G}, IsCompact k ‚Üí MeasurableSet s ‚Üí k ‚äÜ s ‚Üí closure k ‚äÜ s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a topological vector space, the closure of a convex set is convex. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {ùïú : Type u_2} {E : Type u_3} [inst : LinearOrderedField ùïú] [inst_1 : AddCommGroup E] [inst_2 : Module ùïú E]\\n  [inst_3 : TopologicalSpace E] [inst_4 : TopologicalAddGroup E] [inst_5 : ContinuousConstSMul ùïú E] {s : Set E},\\n  Convex ùïú s ‚Üí Convex ùïú (closure s)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The set of compact operators from a normed space to a complete topological vector space is\\nclosed. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {ùïú‚ÇÅ : Type u_1} {ùïú‚ÇÇ : Type u_2} [inst : NontriviallyNormedField ùïú‚ÇÅ] [inst_1 : NormedField ùïú‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : ùïú‚ÇÅ ‚Üí+* ùïú‚ÇÇ}\\n  {M‚ÇÅ : Type u_3} {M‚ÇÇ : Type u_4} [inst_2 : SeminormedAddCommGroup M‚ÇÅ] [inst_3 : AddCommGroup M‚ÇÇ]\\n  [inst_4 : NormedSpace ùïú‚ÇÅ M‚ÇÅ] [inst_5 : Module ùïú‚ÇÇ M‚ÇÇ] [inst_6 : UniformSpace M‚ÇÇ] [inst_7 : UniformAddGroup M‚ÇÇ]\\n  [inst_8 : ContinuousConstSMul ùïú‚ÇÇ M‚ÇÇ] [inst_9 : T2Space M‚ÇÇ] [inst_10 : CompleteSpace M‚ÇÇ],\\n  IsClosed {f | IsCompactOperator ‚áëf}\"},\n {\"role\": \"user\", \"content\": \"In a Noetherian space, all sets are compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace.NoetherianSpace Œ±] (s : Set Œ±), IsCompact s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For any topological space `X`, its one point compactification is a compact space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A subspace is dense iff its topological closure is the entire space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : TopologicalSpace M] [inst_2 : AddCommMonoid M]\\n  [inst_3 : Module R M] [inst_4 : ContinuousConstSMul R M] [inst_5 : ContinuousAdd M] {s : Submodule R M},\\n  Dense ‚Üës ‚Üî Submodule.topologicalClosure s = ‚ä§\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The intersection of a compact set and a closed set is a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {X : Type u} [inst : TopologicalSpace X] {s t : Set X}, IsCompact s ‚Üí IsClosed t ‚Üí IsCompact (s ‚à© t)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The intersection of a closed set and a compact set is a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {X : Type u} [inst : TopologicalSpace X] {s t : Set X}, IsCompact t ‚Üí IsClosed s ‚Üí IsCompact (s ‚à© t)\"},\n {\"role\": \"user\", \"content\": \"In a `T2Space`, every compact set is closed. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T2Space X] {s : Set X}, IsCompact s ‚Üí IsClosed s\"},\n {\"role\": \"user\",\n  \"content\": \"A closed subset of a compact set is a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {X : Type u} [inst : TopologicalSpace X] {s t : Set X}, IsCompact s ‚Üí IsClosed t ‚Üí t ‚äÜ s ‚Üí IsCompact t\"},\n {\"role\": \"user\", \"content\": \"The underlying topological space is compact.\"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ (self : CompHaus), CompactSpace ‚Üëself.toTop\"},\n {\"role\": \"user\",\n  \"content\": \"In a compact space, the type of closed subsets is compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : EMetricSpace Œ±] [inst_1 : CompactSpace Œ±], CompactSpace (TopologicalSpace.Closeds Œ±)\"},\n {\"role\": \"user\", \"content\": \"Finite topological spaces are compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {X : Type u} [inst : TopologicalSpace X] [inst_1 : Finite X], CompactSpace X\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If every compact subset of a topological space is closed, then the space is compact.\"}]"}
{"text":"In a commutative ring, the sum of idempotent elements is idempotent.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"The center of a monoid acts commutatively on that monoid. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {M : Type u_1} [inst : Monoid M], SMulCommClass M (‚Ü•(Submonoid.center M)) M\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Commuting elements of finite order are closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Monoid G] {x y : G}, Commute x y ‚Üí IsOfFinOrder x ‚Üí IsOfFinOrder y ‚Üí IsOfFinOrder (x * y)\"},\n {\"role\": \"user\", \"content\": \"Equivalence closure is idempotent. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} (r : Œ± ‚Üí Œ± ‚Üí Prop), EqvGen.Setoid (Setoid.Rel (EqvGen.Setoid r)) = EqvGen.Setoid r\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Commuting elements of finite additive order are closed under addition.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : AddMonoid G] {x y : G},\\n  AddCommute x y ‚Üí IsOfFinAddOrder x ‚Üí IsOfFinAddOrder y ‚Üí IsOfFinAddOrder (x + y)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a semigroup, the product of right-regular elements is right-regular. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} [inst : Semigroup R] {a b : R}, IsRightRegular a ‚Üí IsRightRegular b ‚Üí IsRightRegular (a * b)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Scalar multiplication commutes with the inclusion of each component into the direct sum. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (R : Type u) [inst : Semiring R] {Œπ : Type v} [dec_Œπ : DecidableEq Œπ] {M : Œπ ‚Üí Type w}\\n  [inst_1 : (i : Œπ) ‚Üí AddCommMonoid (M i)] [inst_2 : (i : Œπ) ‚Üí Module R (M i)] (i : Œπ) (c : R) (x : M i),\\n  (DirectSum.of M i) (c ‚Ä¢ x) = c ‚Ä¢ (DirectSum.of M i) x\"},\n {\"role\": \"user\",\n  \"content\": \"Addition is commutative in an additive commutative semigroup. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {M : Type u} [self : AddCancelCommMonoid M] (a b : M), a + b = b + a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The sum of two elements of an additive subsemigroup belongs to the subsemigroup. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} [inst : NonAssocSemiring R] (self : Subsemiring R) {a b : R},\\n  a ‚àà self.carrier ‚Üí b ‚àà self.carrier ‚Üí a + b ‚àà self.carrier\"},\n {\"role\": \"user\",\n  \"content\": \"the condition that the given endomorphism is an idempotent \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {C : Type u_1} [inst : CategoryTheory.Category.{u_2, u_1} C] (self : CategoryTheory.Idempotents.Karoubi C),\\n  CategoryTheory.CategoryStruct.comp self.p self.p = self.p\"},\n {\"role\": \"user\", \"content\": \"Any element commutes with itself.\"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {S : Type u_2} [inst : Add S] (a : S), AddCommute a a\"},\n {\"role\": \"user\", \"content\": \"Any element commutes with itself. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {S : Type u_2} [inst : Mul S] (a : S), Commute a a\"},\n {\"role\": \"user\",\n  \"content\": \"Scalar multiplication commutes with direct sums. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (R : Type u) [inst : Semiring R] {Œπ : Type v} [dec_Œπ : DecidableEq Œπ] {M : Œπ ‚Üí Type w}\\n  [inst_1 : (i : Œπ) ‚Üí AddCommMonoid (M i)] [inst_2 : (i : Œπ) ‚Üí Module R (M i)] (s : Finset Œπ) (c : R)\\n  (x : (i : ‚Üë‚Üës) ‚Üí M ‚Üëi), (DirectSum.mk M s) (c ‚Ä¢ x) = c ‚Ä¢ (DirectSum.mk M s) x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"By definition, a ring isomorphism preserves the additive structure. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {F : Type u_7} {R : outParam (Type u_8)} {S : outParam (Type u_9)} [inst : Mul R] [inst_1 : Add R] [inst_2 : Mul S]\\n  [inst_3 : Add S] [self : RingEquivClass F R S] (f : F) (a b : R), f (a + b) = f a + f b\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Moving to the opposite additive commutative monoid commutes with summing. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ≤ : Type u} {Œ± : Type v} [inst : AddCommMonoid Œ≤] {s : Finset Œ±} (f : Œ± ‚Üí Œ≤),\\n  MulOpposite.op (Finset.sum s fun x => f x) = Finset.sum s fun x => MulOpposite.op (f x)\"},\n {\"role\": \"user\", \"content\": \"A ring isomorphism preserves multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_4} {S : Type u_5} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R ‚âÉ+* S)\\n  (x y : R), e (x * y) = e x * e y\"},\n {\"role\": \"user\",\n  \"content\": \"Multiplication is commutative in a commutative semigroup. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_2} [self : StrictOrderedCommRing Œ±] (a b : Œ±), a * b = b * a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A finitely generated idempotent ideal is generated by an idempotent element \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} [inst : CommRing R] (I : Ideal R),\\n  Ideal.FG I ‚Üí (IsIdempotentElem I ‚Üî ‚àÉ e, IsIdempotentElem e ‚àß I = Submodule.span R {e})\"},\n {\"role\": \"user\", \"content\": \"An abelian category is idempotent complete. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (D : Type u_2) [inst : CategoryTheory.Category.{u_3, u_2} D] [inst_1 : CategoryTheory.Abelian D],\\n  CategoryTheory.IsIdempotentComplete D\"},\n {\"role\": \"user\", \"content\": \"A ring isomorphism preserves addition. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_4} {S : Type u_5} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R ‚âÉ+* S)\\n  (x y : R), e (x + y) = e x + e y\"},\n {\"role\": \"user\",\n  \"content\": \"Multiplication in a boolean ring is idempotent. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {Œ± : Type u_4} [self : BooleanRing Œ±] (a : Œ±), a * a = a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a commutative ring, the sum of idempotent elements is idempotent.\"}]"}
{"text":"The number of partitions of a finite set is a prime number.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Factoring a prime gives the corresponding one-element multiset. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (p : Nat.Primes), PNat.factorMultiset ‚Üëp = PrimeMultiset.ofPrime p\"},\n {\"role\": \"user\", \"content\": \"The partition is supremum-independent \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : Lattice Œ±] [inst_1 : OrderBot Œ±] {a : Œ±} (self : Finpartition a), Finset.SupIndep self.parts id\"},\n {\"role\": \"user\",\n  \"content\": \"Every finite convergent corresponds to a rational number. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K) (n : ‚Ñï),\\n  ‚àÉ q, GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n = ‚Üëq\"},\n {\"role\": \"user\",\n  \"content\": \"The set of finite subsets of a countable set is countable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {s : Set Œ±}, Set.Countable s ‚Üí Set.Countable {t | Set.Finite t ‚àß t ‚äÜ s}\"},\n {\"role\": \"user\",\n  \"content\": \"A Dedekind domain is a PID if its set of primes is finite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R],\\n  Set.Finite {I | Ideal.IsPrime I} ‚Üí IsPrincipalIdealRing R\"},\n {\"role\": \"user\",\n  \"content\": \"The semilatice generated by a finite set is finite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_2} [inst : SemilatticeSup Œ±] {s : Set Œ±}, Set.Finite s ‚Üí Set.Finite (supClosure s)\"},\n {\"role\": \"user\", \"content\": \"A product of finite numbers is still finite \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œπ : Type u_1} {R : Type u_8} [inst : CommMonoidWithZero R] [inst_1 : NoZeroDivisors R] [inst_2 : Nontrivial R]\\n  [inst_3 : DecidableEq R] [inst_4 : LT R] {s : Finset Œπ} {f : Œπ ‚Üí WithTop R},\\n  (‚àÄ i ‚àà s, f i ‚â† ‚ä§) ‚Üí (Finset.prod s fun i => f i) < ‚ä§\"},\n {\"role\": \"user\", \"content\": \"Any finitely generated ideal is principal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} [inst : CommRing R] [self : IsBezout R] (I : Ideal R), Ideal.FG I ‚Üí Submodule.IsPrincipal I\"},\n {\"role\": \"user\", \"content\": \"A finite union of finsets is finite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Finset Œ≤), Set.Finite (Set.range f) ‚Üí Set.Finite (‚ãÉ a, ‚Üë(f a))\"},\n {\"role\": \"user\",\n  \"content\": \"The only divisors of prime powers are prime powers. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : CancelCommMonoidWithZero Œ±] [dec_irr : (p : Associates Œ±) ‚Üí Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid Œ±] [dec : DecidableEq Œ±] [dec' : DecidableEq (Associates Œ±)] {a p : Associates Œ±},\\n  Irreducible p ‚Üí\\n    ‚àÄ [inst_2 : (n : ‚Ñï) ‚Üí Decidable (a ‚à£ p ^ n)] {n : ‚Ñï} (h : a ‚à£ p ^ n),\\n      a = p ^ Nat.find (_ : ‚àÉ n, (fun n => a ‚à£ p ^ n) n)\"},\n {\"role\": \"user\",\n  \"content\": \"There are finitely many subsets of a given finite set \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {a : Set Œ±}, Set.Finite a ‚Üí Set.Finite {b | b ‚äÜ a}\"},\n {\"role\": \"user\", \"content\": \"A minimal polynomial is prime. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\\n  IsIntegral A x ‚Üí Prime (minpoly A x)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The variable of the power series ring over an integral domain is prime.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R], Prime PowerSeries.X\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is cyclic.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsAddCyclic Œ±\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is cyclic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)], Fintype.card Œ± = p ‚Üí IsCyclic Œ±\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is simple.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsSimpleAddGroup Œ±\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is simple. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsSimpleGroup Œ±\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\", \"content\": \"Set.InjOn Nat.factorization {x | x ‚â† 0}\"},\n {\"role\": \"user\", \"content\": \"A finite field has prime power cardinality. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : Fintype Œ±] [inst_1 : Field Œ±], IsPrimePow (Fintype.card Œ±)\"},\n {\"role\": \"user\",\n  \"content\": \"The number of partitions of a finite set is a prime number.\"}]"}
{"text":"If a poset has a maximal element, then it has a unique minimal element.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The adjoint is maximal in the sense that it contains every formal adjoint. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {ùïú : Type u_1} {E : Type u_2} {F : Type u_3} [inst : IsROrC ùïú] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : InnerProductSpace ùïú E] [inst_3 : NormedAddCommGroup F] [inst_4 : InnerProductSpace ùïú F] {T : E ‚Üí‚Çó.[ùïú] F}\\n  {S : F ‚Üí‚Çó.[ùïú] E},\\n  Dense ‚ÜëT.domain ‚Üí ‚àÄ [inst_5 : CompleteSpace E], LinearPMap.IsFormalAdjoint T S ‚Üí S ‚â§ LinearPMap.adjoint T\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A word and its maximal reduction correspond to the same element of the additive free\\ngroup.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {L : List (Œ± √ó Bool)} [inst : DecidableEq Œ±], FreeAddGroup.mk (FreeAddGroup.reduce L) = FreeAddGroup.mk L\"},\n {\"role\": \"user\",\n  \"content\": \"The only constant in a maximal ideal over a field is `0`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} [inst : Ring R],\\n  IsField R ‚Üí ‚àÄ (I : Ideal (Polynomial R)) [hI : Ideal.IsMaximal I] (x : R), Polynomial.C x ‚àà I ‚Üí x = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a monoid with zero, if zero equals one, then zero is the only element. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {M‚ÇÄ : Type u_2} [inst : MulZeroOneClass M‚ÇÄ], 0 = 1 ‚Üí ‚àÄ (a : M‚ÇÄ), a = 0\"},\n {\"role\": \"user\",\n  \"content\": \"Any element of a set is more than the set infimum. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_9} [self : CompleteSemilatticeInf Œ±] (s : Set Œ±), ‚àÄ a ‚àà s, sInf s ‚â§ a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a product lies in the prime ideal, then at least one element lies in the prime ideal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : Semiring Œ±] {I : Ideal Œ±} [self : Ideal.IsPrime I] {x y : Œ±}, x * y ‚àà I ‚Üí x ‚àà I ‚à® y ‚àà I\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a word reduces to another word, then they have a common maximal reduction. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {L‚ÇÅ L‚ÇÇ : List (Œ± √ó Bool)} [inst : DecidableEq Œ±],\\n  FreeGroup.Red L‚ÇÅ L‚ÇÇ ‚Üí FreeGroup.reduce L‚ÇÅ = FreeGroup.reduce L‚ÇÇ\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a word reduces to another word, then they have a common maximal reduction.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {L‚ÇÅ L‚ÇÇ : List (Œ± √ó Bool)} [inst : DecidableEq Œ±],\\n  FreeAddGroup.Red L‚ÇÅ L‚ÇÇ ‚Üí FreeAddGroup.reduce L‚ÇÅ = FreeAddGroup.reduce L‚ÇÇ\"},\n {\"role\": \"user\",\n  \"content\": \"A nonzero ideal has an element of minimal norm. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} {S : Type u_2} [inst : EuclideanDomain R] [inst_1 : CommRing S] [inst_2 : IsDomain S]\\n  [inst_3 : Algebra R S] (abv : AbsoluteValue R ‚Ñ§) (I : ‚Ü•(nonZeroDivisors (Ideal S))),\\n  ‚àÉ b ‚àà ‚ÜëI, b ‚â† 0 ‚àß ‚àÄ c ‚àà ‚ÜëI, abv ((Algebra.norm R) c) < abv ((Algebra.norm R) b) ‚Üí c = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"**Zorn's lemma**\\n\\nIf every chain has an upper bound, then there exists a maximal element. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} {r : Œ± ‚Üí Œ± ‚Üí Prop},\\n  (‚àÄ (c : Set Œ±), IsChain r c ‚Üí ‚àÉ ub, ‚àÄ a ‚àà c, r a ub) ‚Üí\\n    (‚àÄ {a b c : Œ±}, r a b ‚Üí r b c ‚Üí r a c) ‚Üí ‚àÉ m, ‚àÄ (a : Œ±), r m a ‚Üí r a m\"},\n {\"role\": \"user\", \"content\": \"Also known as the maximality axiom. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] (J : CategoryTheory.GrothendieckTopology C) (X : C),\\n  ‚ä§ ‚àà CategoryTheory.GrothendieckTopology.sieves J X\"},\n {\"role\": \"user\",\n  \"content\": \"A greatest element of a set is the supremum of this set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : ConditionallyCompleteLattice Œ±] {s : Set Œ±} {a : Œ±}, IsGreatest s a ‚Üí sSup s = a\"},\n {\"role\": \"user\",\n  \"content\": \"A least element of a set is the infimum of this set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : ConditionallyCompleteLattice Œ±] {s : Set Œ±} {a : Œ±}, IsLeast s a ‚Üí sInf s = a\"},\n {\"role\": \"user\",\n  \"content\": \"Any element of a set is less than the set supremum. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_9} [self : CompleteSemilatticeSup Œ±] (s : Set Œ±), ‚àÄ a ‚àà s, a ‚â§ sSup s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A word and its maximal reduction correspond to the same element of the free group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {L : List (Œ± √ó Bool)} [inst : DecidableEq Œ±], FreeGroup.mk (FreeGroup.reduce L) = FreeGroup.mk L\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a poset has a maximal element, then it has a unique minimal element.\"}]"}
{"text":"The automorphism group of an Abelian group is cyclic.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [self : LinearOrderedCommGroupWithZero Œ±] (a : Œ±), a ‚â† 0 ‚Üí a * a‚Åª¬π = 1\"},\n {\"role\": \"user\", \"content\": \"An abelian category has finite biproducts. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Abelian C],\\n  CategoryTheory.Limits.HasFiniteBiproducts C\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any inner regular Haar measure is invariant under inversion in an abelian group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : CommGroup G] [inst_1 : TopologicalSpace G] [inst_2 : TopologicalGroup G]\\n  [inst_3 : MeasurableSpace G] [inst_4 : BorelSpace G] (Œº : MeasureTheory.Measure G)\\n  [inst_5 : MeasureTheory.Measure.IsHaarMeasure Œº] [inst_6 : LocallyCompactSpace G]\\n  [inst_7 : MeasureTheory.Measure.InnerRegular Œº], MeasureTheory.Measure.IsInvInvariant Œº\"},\n {\"role\": \"user\", \"content\": \"Finite groups are torsion groups. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\"},\n {\"role\": \"user\", \"content\": \"A group homomorphism is a monoid homomorphism. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Group Œ±] [inst_1 : Group Œ≤] {f : Œ± ‚Üí Œ≤}, IsGroupHom f ‚Üí IsMonoidHom f\"},\n {\"role\": \"user\",\n  \"content\": \"Abelian groups have nilpotency class at most one \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_2} [inst : CommGroup G], Group.nilpotencyClass G ‚â§ 1\"},\n {\"role\": \"user\",\n  \"content\": \"The action of an additive group on an orbit is transitive.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u} [inst : AddGroup G] {Œ± : Type v} [inst_1 : AddAction G Œ±] (a : Œ±),\\n  AddAction.IsPretransitive G ‚Üë(AddAction.orbit G a)\"},\n {\"role\": \"user\",\n  \"content\": \"The center of a group acts commutatively on that group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G], SMulCommClass G (‚Ü•(Subgroup.center G)) G\"},\n {\"role\": \"user\", \"content\": \"An abelian category is idempotent complete. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (D : Type u_2) [inst : CategoryTheory.Category.{u_3, u_2} D] [inst_1 : CategoryTheory.Abelian D],\\n  CategoryTheory.IsIdempotentComplete D\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The torsion submonoid of an abelian group equals the torsion subgroup as a submonoid. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (G : Type u_1) [inst : CommGroup G], CommMonoid.torsion G = (CommGroup.torsion G).toSubmonoid\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The product of group homomorphisms is a group homomorphism if the target is commutative. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Group Œ±] [inst_1 : CommGroup Œ≤] {f g : Œ± ‚Üí Œ≤},\\n  IsGroupHom f ‚Üí IsGroupHom g ‚Üí IsGroupHom fun a => f a * g a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The right regular action of an additive group on itself is transitive.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_2} [inst : AddGroup G], AddAction.IsPretransitive G·µÉ·µí·µñ G\"},\n {\"role\": \"user\", \"content\": \"The torsion subgroup is cylic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (K : Type u_1) [inst : Field K] [inst_1 : NumberField K], IsCyclic ‚Ü•(NumberField.Units.torsion K)\"},\n {\"role\": \"user\", \"content\": \"Abelian groups are nilpotent \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {G : Type u_2} [inst : CommGroup G], Group.IsNilpotent G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The quotient by the center of a group of cardinality `p ^ 2` is cyclic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {p : ‚Ñï} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\\n  Fintype.card G = p ^ 2 ‚Üí IsCyclic (G ‚ß∏ Subgroup.center G)\"},\n {\"role\": \"user\", \"content\": \"Every subgroup of `‚Ñ§` is cyclic. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ (H : AddSubgroup ‚Ñ§), ‚àÉ a, H = AddSubgroup.closure {a}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A finite subgroup of the units of an integral domain is cyclic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (S : Subgroup RÀ£) [inst_2 : Finite ‚Ü•S], IsCyclic ‚Ü•S\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A finite subgroup of the unit group of an integral domain is cyclic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} {G : Type u_2} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\\n  (f : G ‚Üí* R), Function.Injective ‚áëf ‚Üí IsCyclic G\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is cyclic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)], Fintype.card Œ± = p ‚Üí IsCyclic Œ±\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is cyclic.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsAddCyclic Œ±\"},\n {\"role\": \"user\",\n  \"content\": \"The automorphism group of an Abelian group is cyclic.\"}]"}
{"text":"If a function from the unit interval to itself has a fixed point, then it has points of all positive periods.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a function is locally integrable, then it is integrable on any compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {X : Type u_1} {E : Type u_3} [inst : MeasurableSpace X] [inst_1 : TopologicalSpace X] [inst_2 : NormedAddCommGroup E]\\n  {f : X ‚Üí E} {Œº : MeasureTheory.Measure X} {k : Set X},\\n  MeasureTheory.LocallyIntegrable f ‚Üí IsCompact k ‚Üí MeasureTheory.IntegrableOn f k\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a function is locally Lipschitz around a point, then it is continuous at this point. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoMetricSpace Œ±] [inst_1 : PseudoMetricSpace Œ≤] {f : Œ± ‚Üí Œ≤} {x : Œ±} {r : ‚Ñù},\\n  0 < r ‚Üí ‚àÄ (K : ‚Ñù), (‚àÄ (y : Œ±), dist y x < r ‚Üí dist (f y) (f x) ‚â§ K * dist y x) ‚Üí ContinuousAt f x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `f` sends two periodic points `x` and `y` of positive periods to the same point,\\nthen `x = y`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} {f : Œ± ‚Üí Œ±} {x y : Œ±} {m n : ‚Ñï},\\n  Function.IsPeriodicPt f m x ‚Üí Function.IsPeriodicPt f n y ‚Üí 0 < m ‚Üí 0 < n ‚Üí f x = f y ‚Üí x = y\"},\n {\"role\": \"user\",\n  \"content\": \"A continuous function is bounded above on a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : TopologicalSpace Œ≤]\\n  [inst_3 : ClosedIciTopology Œ±] [inst_4 : Nonempty Œ±] {f : Œ≤ ‚Üí Œ±} {K : Set Œ≤},\\n  IsCompact K ‚Üí ContinuousOn f K ‚Üí BddAbove (f '' K)\"},\n {\"role\": \"user\",\n  \"content\": \"A uniform limit of continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {p : Filter Œπ}\\n  [inst_1 : TopologicalSpace Œ±],\\n  TendstoUniformly F f p ‚Üí (‚àÄ·∂† (n : Œπ) in p, Continuous (F n)) ‚Üí ‚àÄ [inst_2 : Filter.NeBot p], Continuous f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If two functions are equal in the relevant interval, their interval integrals are also equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {E : Type u_3} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] {f g : ‚Ñù ‚Üí E} {Œº : MeasureTheory.Measure ‚Ñù}\\n  {a b : ‚Ñù}, Set.EqOn f g (Set.uIcc a b) ‚Üí ‚à´ (x : ‚Ñù) in a..b, f x ‚àÇŒº = ‚à´ (x : ‚Ñù) in a..b, g x ‚àÇŒº\"},\n {\"role\": \"user\", \"content\": \"A continuous, periodic function is bounded. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {f : ‚Ñù ‚Üí Œ±} {c : ‚Ñù},\\n  Function.Periodic f c ‚Üí c ‚â† 0 ‚Üí Continuous f ‚Üí Bornology.IsBounded (Set.range f)\"},\n {\"role\": \"user\", \"content\": \"For the identity map, all points are periodic. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {Œ± : Type u_1} (n : ‚Ñï) (x : Œ±), Function.IsPeriodicPt id n x\"},\n {\"role\": \"user\", \"content\": \"A constant function is uniformly integrable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {Œπ : Type u_3} {m : MeasurableSpace Œ±} (Œº : MeasureTheory.Measure Œ±)\\n  [inst : NormedAddCommGroup Œ≤] {p : ENNReal} {g : Œ± ‚Üí Œ≤},\\n  1 ‚â§ p ‚Üí p ‚â† ‚ä§ ‚Üí MeasureTheory.Mem‚Ñíp g p ‚Üí MeasureTheory.UnifIntegrable (fun x => g) p Œº\"},\n {\"role\": \"user\",\n  \"content\": \"A continuous, periodic function has compact range. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {f : ‚Ñù ‚Üí Œ±} {c : ‚Ñù},\\n  Function.Periodic f c ‚Üí c ‚â† 0 ‚Üí Continuous f ‚Üí IsCompact (Set.range f)\"},\n {\"role\": \"user\",\n  \"content\": \"The set of fixed points of a continuous map is a closed set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : T2Space Œ±] {f : Œ± ‚Üí Œ±},\\n  Continuous f ‚Üí IsClosed (Function.fixedPoints f)\"},\n {\"role\": \"user\", \"content\": \"Any point is a periodic point of period `0`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} (f : Œ± ‚Üí Œ±) (x : Œ±), Function.IsPeriodicPt f 0 x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A fixed point of `f` is a periodic point of `f` of any prescribed period. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} {f : Œ± ‚Üí Œ±} {x : Œ±}, Function.IsFixedPt f x ‚Üí ‚àÄ (n : ‚Ñï), Function.IsPeriodicPt f n x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a function from the unit interval to itself has a fixed point, then it has points of all positive periods.\"}]"}
{"text":"The complement of the union of two sets contains the union of their complements.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"The product of two dense sets is a dense set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {s : Set Œ±} {t : Set Œ≤},\\n  Dense s ‚Üí Dense t ‚Üí Dense (s √óÀ¢ t)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a directed order, the union of two sets is bounded above if and only if both sets are. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : Preorder Œ±] [inst_1 : IsDirected Œ± fun x x_1 => x ‚â§ x_1] {s t : Set Œ±},\\n  BddAbove (s ‚à™ t) ‚Üî BddAbove s ‚àß BddAbove t\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The supremum of two subspaces is equal to the span of their union. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  (S T : Set (Projectivization K V)),\\n  Projectivization.Subspace.span (S ‚à™ T) = Projectivization.Subspace.span S ‚äî Projectivization.Subspace.span T\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The set difference of a compact set and an open set is a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {X : Type u} [inst : TopologicalSpace X] {s t : Set X}, IsCompact s ‚Üí IsOpen t ‚Üí IsCompact (s \\\\ t)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The intersection of a closed set and a compact set is a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {X : Type u} [inst : TopologicalSpace X] {s t : Set X}, IsCompact t ‚Üí IsClosed s ‚Üí IsCompact (s ‚à© t)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If two sets belong to a filter, then their intersection belongs to the filter as well. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} (self : Filter Œ±) {x y : Set Œ±}, x ‚àà self.sets ‚Üí y ‚àà self.sets ‚Üí x ‚à© y ‚àà self.sets\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a codirected order, the union of two sets is bounded below if and only if both sets are. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : Preorder Œ±] [inst_1 : IsDirected Œ± fun x x_1 => x ‚â• x_1] {s t : Set Œ±},\\n  BddBelow (s ‚à™ t) ‚Üî BddBelow s ‚àß BddBelow t\"},\n {\"role\": \"user\", \"content\": \"A finite union of finsets is finite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Finset Œ≤), Set.Finite (Set.range f) ‚Üí Set.Finite (‚ãÉ a, ‚Üë(f a))\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The intersection of a disjoint covering by two open sets of a clopen set will be clopen. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {X : Type u} [inst : TopologicalSpace X] {s a b : Set X},\\n  IsClopen s ‚Üí s ‚äÜ a ‚à™ b ‚Üí IsOpen a ‚Üí IsOpen b ‚Üí Disjoint a b ‚Üí IsClopen (s ‚à© a)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The union of all sets in a compact exhaustion equals the entire space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {X : Type u_4} [inst : TopologicalSpace X] (self : CompactExhaustion X),\\n  ‚ãÉ n, CompactExhaustion.toFun self n = Set.univ\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a compact set is covered by two open sets, then we can cover it by two compact subsets. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T2Space X] {K U V : Set X},\\n  IsCompact K ‚Üí IsOpen U ‚Üí IsOpen V ‚Üí K ‚äÜ U ‚à™ V ‚Üí ‚àÉ K‚ÇÅ K‚ÇÇ, IsCompact K‚ÇÅ ‚àß IsCompact K‚ÇÇ ‚àß K‚ÇÅ ‚äÜ U ‚àß K‚ÇÇ ‚äÜ V ‚àß K = K‚ÇÅ ‚à™ K‚ÇÇ\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The intersection of a compact set and a closed set is a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {X : Type u} [inst : TopologicalSpace X] {s t : Set X}, IsCompact s ‚Üí IsClosed t ‚Üí IsCompact (s ‚à© t)\"},\n {\"role\": \"user\",\n  \"content\": \"The span of a union of sets is the sup of their spans. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (k : Type u_1) (V : Type u_2) {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [S : AddTorsor V P] (s t : Set P), affineSpan k (s ‚à™ t) = affineSpan k s ‚äî affineSpan k t\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The cardinality of a union is at most the sum of the cardinalities\\nof the two sets. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} (S T : Set Œ±), Cardinal.mk ‚Üë(S ‚à™ T) ‚â§ Cardinal.mk ‚ÜëS + Cardinal.mk ‚ÜëT\"},\n {\"role\": \"user\",\n  \"content\": \"The disjoint union of two compact spaces is compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : CompactSpace X]\\n  [inst_3 : CompactSpace Y], CompactSpace (X ‚äï Y)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The indicator of a disjoint union of two sets is the sum of the indicators of the sets. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} {E : Type u_2} {m0 : MeasurableSpace Œ±} {p : ENNReal} {Œº : MeasureTheory.Measure Œ±}\\n  [inst : NormedAddCommGroup E] {s t : Set Œ±} (hs : MeasurableSet s) (ht : MeasurableSet t) (hŒºs : ‚Üë‚ÜëŒº s ‚â† ‚ä§)\\n  (hŒºt : ‚Üë‚ÜëŒº t ‚â† ‚ä§),\\n  s ‚à© t = ‚àÖ ‚Üí\\n    ‚àÄ (c : E),\\n      MeasureTheory.indicatorConstLp p (_ : MeasurableSet (s ‚à™ t)) (_ : ‚Üë‚ÜëŒº (s ‚à™ t) ‚â† ‚ä§) c =\\n        MeasureTheory.indicatorConstLp p hs hŒºs c + MeasureTheory.indicatorConstLp p ht hŒºt c\"},\n {\"role\": \"user\", \"content\": \"The union of two bounded sets is bounded. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {ùïú : Type u_1} {E : Type u_3} [inst : SeminormedRing ùïú] [inst_1 : SMul ùïú E] [inst_2 : Zero E]\\n  [inst_3 : TopologicalSpace E] {s‚ÇÅ s‚ÇÇ : Set E},\\n  Bornology.IsVonNBounded ùïú s‚ÇÅ ‚Üí Bornology.IsVonNBounded ùïú s‚ÇÇ ‚Üí Bornology.IsVonNBounded ùïú (s‚ÇÅ ‚à™ s‚ÇÇ)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The complement of a set has the same frontier as the original set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] (s : Set Œ±), frontier s·∂ú = frontier s\"},\n {\"role\": \"user\", \"content\": \"The complement of a closed set is an open set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±} [self : IsClosed s], IsOpen s·∂ú\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The complement of the union of two sets contains the union of their complements.\"}]"}
{"text":"The square root of an rational number is rational.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"There is a rational power between any two positive elements of an archimedean ordered field. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {n : ‚Ñï} {Œ± : Type u_1} [inst : LinearOrderedField Œ±] [inst_1 : Archimedean Œ±],\\n  n ‚â† 0 ‚Üí ‚àÄ {x y : Œ±}, x < y ‚Üí 0 < y ‚Üí ‚àÉ q, 0 < q ‚àß x < ‚Üëq ^ n ‚àß ‚Üëq ^ n < y\"},\n {\"role\": \"user\",\n  \"content\": \"The conjugate of the golden ratio is irrational. \"},\n {\"role\": \"assistant\", \"content\": \"Irrational goldenConj\"},\n {\"role\": \"user\",\n  \"content\": \"An ideal is radical iff it is equal to its radical. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} [inst : CommSemiring R] {I : Ideal R}, Ideal.radical I = I ‚Üî Ideal.IsRadical I\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The numerator and denominator are coprime: it is in \\\"reduced form\\\". \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ (self : ‚Ñö), Nat.Coprime (Int.natAbs self.num) self.den\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Commutativity of a square is preserved when taking quotients by an ideal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} {S : Type v} [inst : CommRing R] [inst_1 : CommRing S] {R' : Type u_5} {S' : Type u_6}\\n  [inst_2 : CommRing R'] [inst_3 : CommRing S'] {f : R ‚Üí+* S} {f' : R' ‚Üí+* S'} {g : R ‚Üí+* R'} {g' : S ‚Üí+* S'}\\n  (hfg : RingHom.comp f' g = RingHom.comp g' f) (I : Ideal S'),\\n  let leq := (_ : Ideal.comap f (Ideal.comap g' I) ‚â§ Ideal.comap g (Ideal.comap f' I));\\n  RingHom.comp (Ideal.quotientMap I g' (_ : Ideal.comap g' I ‚â§ Ideal.comap g' I))\\n      (Ideal.quotientMap (Ideal.comap g' I) f\\n        (_ : Ideal.comap f (Ideal.comap g' I) ‚â§ Ideal.comap f (Ideal.comap g' I))) =\\n    RingHom.comp (Ideal.quotientMap I f' (_ : Ideal.comap f' I ‚â§ Ideal.comap f' I))\\n      (Ideal.quotientMap (Ideal.comap f' I) g leq)\"},\n {\"role\": \"user\", \"content\": \"**Irrationality of the Square Root of 2** \"},\n {\"role\": \"assistant\", \"content\": \"Irrational (Real.sqrt 2)\"},\n {\"role\": \"user\",\n  \"content\": \"A quadratic has roots if its discriminant has square roots \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u_1} [inst : Field K] [inst_1 : NeZero 2] {a b c : K},\\n  a ‚â† 0 ‚Üí (‚àÉ s, discrim a b c = s * s) ‚Üí ‚àÉ x, a * x * x + b * x + c = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The product of a Liouville number and a nonzero rational number is again a Liouville number.  \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {p x : ‚Ñù} {r : ‚Ñö}, LiouvilleWith p x ‚Üí r ‚â† 0 ‚Üí LiouvilleWith p (x * ‚Üër)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Let `r` be an irrational number. Then `B‚Å∫_r` and `B‚Å∫'_r` are equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {r : ‚Ñù}, Irrational r ‚Üí {x | ‚àÉ k > 0, beattySeq' r k = x} = {x | ‚àÉ k > 0, beattySeq r k = x}\"},\n {\"role\": \"user\",\n  \"content\": \"If a rational is not a p-adic integer, it is not an integer. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (p : ‚Ñï) {a : ‚Ñö} [hp : Fact (Nat.Prime p)], 1 < padicNorm p a ‚Üí ¬¨Rat.isInt a = true\"},\n {\"role\": \"user\",\n  \"content\":\n  \"An algebraic integer whose conjugates are all of norm one is a root of unity. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (K : Type u_1) [inst : Field K] [inst_1 : NumberField K] (A : Type u_2) [inst_2 : NormedField A]\\n  [inst_3 : IsAlgClosed A] [inst_4 : NormedAlgebra ‚Ñö A] {x : K},\\n  IsIntegral ‚Ñ§ x ‚Üí (‚àÄ (œÜ : K ‚Üí+* A), ‚ÄñœÜ x‚Äñ = 1) ‚Üí ‚àÉ n, ‚àÉ (_ : 0 < n), x ^ n = 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The real square root is at most the natural square root plus one \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {a : ‚Ñï}, Real.sqrt ‚Üëa ‚â§ ‚Üë(Nat.sqrt a) + 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"There is an irrational number `r` between any two reals `x < r < y`. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {x y : ‚Ñù}, x < y ‚Üí ‚àÉ r, Irrational r ‚àß x < r ‚àß r < y\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Rational numbers are dense in a linear ordered archimedean field. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {ùïú : Type u_1} [inst : LinearOrderedField ùïú] [inst_1 : TopologicalSpace ùïú] [inst_2 : OrderTopology ùïú]\\n  [inst_3 : Archimedean ùïú], DenseRange Rat.cast\"},\n {\"role\": \"user\",\n  \"content\": \"The natural square root is at most the real square root \"},\n {\"role\": \"assistant\", \"content\": \"‚àÄ {a : ‚Ñï}, ‚Üë(Nat.sqrt a) ‚â§ Real.sqrt ‚Üëa\"},\n {\"role\": \"user\", \"content\": \"A transcendental real number is irrational. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {r : ‚Ñù}, Transcendental ‚Ñö r ‚Üí Irrational r\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A rational number has only finitely many good rational approximations. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ (Œæ : ‚Ñö), Set.Finite {q | |Œæ - q| < 1 / ‚Üëq.den ^ 2}\"},\n {\"role\": \"user\",\n  \"content\": \"The continued fraction of a rational number terminates. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (q : ‚Ñö), GeneralizedContinuedFraction.Terminates (GeneralizedContinuedFraction.of q)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every terminating continued fraction corresponds to a rational number. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] {v : K},\\n  GeneralizedContinuedFraction.Terminates (GeneralizedContinuedFraction.of v) ‚Üí ‚àÉ q, v = ‚Üëq\"},\n {\"role\": \"user\",\n  \"content\": \"Every finite convergent corresponds to a rational number. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K) (n : ‚Ñï),\\n  ‚àÉ q, GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n = ‚Üëq\"},\n {\"role\": \"user\",\n  \"content\": \"The square root of an rational number is rational.\"}]"}
{"text":"If a module over a ring is free, then the ring is commutative.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The rank of a finite product of free modules is the sum of the ranks. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u} {Œ∑ : Type u‚ÇÅ'} {œÜ : Œ∑ ‚Üí Type u_1} [inst : Ring K] [inst_1 : StrongRankCondition K]\\n  [inst_2 : (i : Œ∑) ‚Üí AddCommGroup (œÜ i)] [inst_3 : (i : Œ∑) ‚Üí Module K (œÜ i)] [inst_4 : ‚àÄ (i : Œ∑), Module.Free K (œÜ i)]\\n  [inst_5 : Finite Œ∑], Module.rank K ((i : Œ∑) ‚Üí œÜ i) = Cardinal.sum fun i => Module.rank K (œÜ i)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any surjective endomorphism of a Noetherian module is bijective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsNoetherian R M] (f : M ‚Üí‚Çó[R] M), Function.Surjective ‚áëf ‚Üí Function.Bijective ‚áëf\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any surjective endomorphism of a Noetherian module is injective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsNoetherian R M] (f : M ‚Üí‚Çó[R] M), Function.Surjective ‚áëf ‚Üí Function.Injective ‚áëf\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Quotienting by the torsion submodule gives a torsion-free module. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M],\\n  Submodule.torsion R (M ‚ß∏ Submodule.torsion R M) = ‚ä•\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The category of modules has enough projectives, since every module is a quotient of a free\\nmodule. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} [inst : Ring R], CategoryTheory.EnoughProjectives (ModuleCat R)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A module over a semiring is `Finite` if it is finitely generated as a module. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} {M : Type u_4} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\\n  [self : Module.Finite R M], Submodule.FG ‚ä§\"},\n {\"role\": \"user\", \"content\": \"Every Lie algebra is a module over itself. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} {L : Type v} [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L], LieModule R L L\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two finite and free modules are isomorphic if and only if they have the same (finite) rank. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} {M : Type v} {N : Type w} [inst : Ring R] [inst_1 : StrongRankCondition R] [inst_2 : AddCommGroup M]\\n  [inst_3 : Module R M] [inst_4 : Module.Free R M] [inst_5 : Module.Finite R M] [inst_6 : AddCommGroup N]\\n  [inst_7 : Module R N] [inst_8 : Module.Free R N] [inst_9 : Module.Finite R N],\\n  Nonempty (M ‚âÉ‚Çó[R] N) ‚Üî FiniteDimensional.finrank R M = FiniteDimensional.finrank R N\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a free module is finite, then any arbitrary basis is finite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : Nontrivial R] [inst_2 : AddCommGroup M] [inst_3 : Module R M]\\n  {Œπ : Type u_3} [inst_4 : Module.Finite R M], Basis Œπ R M ‚Üí Finite Œπ\"},\n {\"role\": \"user\",\n  \"content\": \"A module with a finite ring of scalars is additively torsion. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (R : Type u_3) (M : Type u_4) [inst : AddCommMonoid M] [inst_1 : Ring R] [inst_2 : Finite R] [inst_3 : Module R M],\\n  AddMonoid.IsTorsion M\"},\n {\"role\": \"user\", \"content\": \"Modules over the trivial ring are Noetherian. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (R : Type u_1) (M : Type u_2) [inst : Subsingleton R] [inst : Semiring R] [inst_1 : AddCommMonoid M]\\n  [inst_2 : Module R M], IsNoetherian R M\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The lattice of submodules of a module over a division ring is atomistic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u_3} {V : Type u_4} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\\n  IsAtomistic (Submodule K V)\"},\n {\"role\": \"user\",\n  \"content\": \"The product of finitely many free modules is free. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œπ : Type u_1} (R : Type u) [inst : Semiring R] (M : Œπ ‚Üí Type u_2) [inst_1 : Finite Œπ]\\n  [inst_2 : (i : Œπ) ‚Üí AddCommMonoid (M i)] [inst_3 : (i : Œπ) ‚Üí Module R (M i)]\\n  [inst_4 : ‚àÄ (i : Œπ), Module.Free R (M i)], Module.Free R ((i : Œπ) ‚Üí M i)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A module over a division ring is noetherian if and only if it is finitely generated. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\\n  IsNoetherian K V ‚Üî Module.Finite K V\"},\n {\"role\": \"user\",\n  \"content\": \"If a module over a ring is free, then the ring is commutative.\"}]"}
{"text":"If the set of units of a ring forms a group then the ring is commutative.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"Multiplication is commutative. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_5} [self : SeminormedCommRing Œ±] (x y : Œ±), x * y = y * x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A finite subgroup of the unit group of an integral domain is cyclic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} {G : Type u_2} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\\n  (f : G ‚Üí* R), Function.Injective ‚áëf ‚Üí IsCyclic G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Self-adjoint elements commute if and only if their product is self-adjoint. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_3} [inst : Mul R] [inst_1 : StarMul R] {x y : R},\\n  IsSelfAdjoint x ‚Üí IsSelfAdjoint y ‚Üí (Commute x y ‚Üî IsSelfAdjoint (x * y))\"},\n {\"role\": \"user\", \"content\": \"A ring isomorphism preserves multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_4} {S : Type u_5} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R ‚âÉ+* S)\\n  (x y : R), e (x * y) = e x * e y\"},\n {\"role\": \"user\", \"content\": \"Any element commutes with itself. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {S : Type u_2} [inst : Mul S] (a : S), Commute a a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Commuting elements of finite order are closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Monoid G] {x y : G}, Commute x y ‚Üí IsOfFinOrder x ‚Üí IsOfFinOrder y ‚Üí IsOfFinOrder (x * y)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A finite subgroup of the units of an integral domain is cyclic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (S : Subgroup RÀ£) [inst_2 : Finite ‚Ü•S], IsCyclic ‚Ü•S\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If all prime ideals in a commutative ring are principal, so are all other ideals. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} [inst : CommRing R],\\n  (‚àÄ (P : Ideal R), Ideal.IsPrime P ‚Üí Submodule.IsPrincipal P) ‚Üí IsPrincipalIdealRing R\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The prime spectrum of a commutative ring is a compact topological space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} [inst : CommRing R], CompactSpace (PrimeSpectrum R)\"},\n {\"role\": \"user\", \"content\": \"A group homomorphism is a monoid homomorphism. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Group Œ±] [inst_1 : Group Œ≤] {f : Œ± ‚Üí Œ≤}, IsGroupHom f ‚Üí IsMonoidHom f\"},\n {\"role\": \"user\",\n  \"content\": \"Composition of non-unital ring homomorphisms is associative. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_3} {Œ≥ : Type u_4} [inst : NonUnitalNonAssocSemiring Œ±]\\n  [inst_1 : NonUnitalNonAssocSemiring Œ≤] [inst_2 : NonUnitalNonAssocSemiring Œ≥] {Œ¥ : Type u_5}\\n  {x : NonUnitalNonAssocSemiring Œ¥} (f : Œ± ‚Üí‚Çô+* Œ≤) (g : Œ≤ ‚Üí‚Çô+* Œ≥) (h : Œ≥ ‚Üí‚Çô+* Œ¥),\\n  NonUnitalRingHom.comp (NonUnitalRingHom.comp h g) f = NonUnitalRingHom.comp h (NonUnitalRingHom.comp g f)\"},\n {\"role\": \"user\", \"content\": \"Fields are commutative. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} [inst : Semiring R], IsField R ‚Üí ‚àÄ (x y : R), x * y = y * x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The inverse of a group homomorphism is a group homomorphism if the target is commutative. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Group Œ±] [inst_1 : CommGroup Œ≤] {f : Œ± ‚Üí Œ≤},\\n  IsGroupHom f ‚Üí IsGroupHom fun a => (f a)‚Åª¬π\"},\n {\"role\": \"user\",\n  \"content\": \"Multiplication is commutative in a commutative semigroup. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_2} [self : StrictOrderedCommRing Œ±] (a b : Œ±), a * b = b * a\"},\n {\"role\": \"user\",\n  \"content\": \"The center of a monoid acts commutatively on that monoid. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {M : Type u_1} [inst : Monoid M], SMulCommClass M (‚Ü•(Submonoid.center M)) M\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The group of units of a complete normed ring is an open subset of the ring. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R], IsOpen {x | IsUnit x}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The product of group homomorphisms is a group homomorphism if the target is commutative. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Group Œ±] [inst_1 : CommGroup Œ≤] {f g : Œ± ‚Üí Œ≤},\\n  IsGroupHom f ‚Üí IsGroupHom g ‚Üí IsGroupHom fun a => f a * g a\"},\n {\"role\": \"user\",\n  \"content\": \"The center of a group acts commutatively on that group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G], SMulCommClass G (‚Ü•(Subgroup.center G)) G\"},\n {\"role\": \"user\",\n  \"content\": \"The units of a complete normed ring form a Lie group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] {ùïú : Type u_2} [inst_2 : NontriviallyNormedField ùïú]\\n  [inst_3 : NormedAlgebra ùïú R], LieGroup (modelWithCornersSelf ùïú R) RÀ£\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If the set of units of a ring forms a group then the ring is commutative.\"}]"}
{"text":"Every natural number larger than `10` is the sum of a square and a prime.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"All composite numbers are Fermat pseudoprimes to base 1.\\n\"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {n : ‚Ñï}, 1 < n ‚Üí ¬¨Nat.Prime n ‚Üí Nat.FermatPsp n 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {m n : ‚Ñï}, (‚àÄ (a : ‚Ñï), m ‚à£ a ‚Üî n ‚à£ a) ‚Üî m = n\"},\n {\"role\": \"user\",\n  \"content\": \"The natural square root is at most the real square root \"},\n {\"role\": \"assistant\", \"content\": \"‚àÄ {a : ‚Ñï}, ‚Üë(Nat.sqrt a) ‚â§ Real.sqrt ‚Üëa\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ (n : ‚Ñï), Nat.factorization n = 0 ‚Üî n = 0 ‚à® n = 1\"},\n {\"role\": \"user\",\n  \"content\": \"The only divisors of prime powers are prime powers. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : CancelCommMonoidWithZero Œ±] [dec_irr : (p : Associates Œ±) ‚Üí Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid Œ±] [dec : DecidableEq Œ±] [dec' : DecidableEq (Associates Œ±)] {a p : Associates Œ±},\\n  Irreducible p ‚Üí\\n    ‚àÄ [inst_2 : (n : ‚Ñï) ‚Üí Decidable (a ‚à£ p ^ n)] {n : ‚Ñï} (h : a ‚à£ p ^ n),\\n      a = p ^ Nat.find (_ : ‚àÉ n, (fun n => a ‚à£ p ^ n) n)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"We relate a finite product over primes to an infinite sum over smooth numbers. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} [inst : NormedCommRing R] [inst_1 : CompleteSpace R] {f : ‚Ñï ‚Üí R},\\n  f 1 = 1 ‚Üí\\n    (‚àÄ {m n : ‚Ñï}, Nat.Coprime m n ‚Üí f (m * n) = f m * f n) ‚Üí\\n      (‚àÄ {p : ‚Ñï}, Nat.Prime p ‚Üí Summable fun n => ‚Äñf (p ^ n)‚Äñ) ‚Üí\\n        ‚àÄ (N : ‚Ñï),\\n          (Summable fun m => ‚Äñf ‚Üëm‚Äñ) ‚àß\\n            HasSum (fun m => f ‚Üëm) (Finset.prod (Nat.primesBelow N) fun p => ‚àë' (n : ‚Ñï), f (p ^ n))\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The special case of Graham's conjecture where all numbers are squarefree. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {n : ‚Ñï} (f : ‚Ñï ‚Üí ‚Ñï), (‚àÄ k < n, Squarefree (f k)) ‚Üí Nat.GrahamConjecture n f\"},\n {\"role\": \"user\",\n  \"content\": \"The exponential characteristic is a prime number or one. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (R : Type u) [inst : Semiring R] (q : ‚Ñï) [hq : ExpChar R q], Nat.Prime q ‚à® q = 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The product of the prime factors of `n` that are less than `N` is an `N`-smooth number. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (n N : ‚Ñï), List.prod (List.filter (fun x => decide (x < N)) (Nat.factors n)) ‚àà Nat.smoothNumbers N\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A prime natural number is prime in `‚Ñ§[i]` if and only if it is `3` mod `4` \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ (p : ‚Ñï) [inst : Fact (Nat.Prime p)], Prime ‚Üëp ‚Üî p % 4 = 3\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The real square root is at most the natural square root plus one \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {a : ‚Ñï}, Real.sqrt ‚Üëa ‚â§ ‚Üë(Nat.sqrt a) + 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {n : ‚Ñï}, IsSquare (-1) ‚Üí ‚àÉ x y, n = x ^ 2 + y ^ 2\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The square of the smallest prime factor of a composite number `n` is at most `n`.\\n\"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {n : ‚Ñï}, 0 < n ‚Üí ¬¨Nat.Prime n ‚Üí Nat.minFac n ^ 2 ‚â§ n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {a b x y u v : ‚Ñï}, a = x ^ 2 + y ^ 2 ‚Üí b = u ^ 2 + v ^ 2 ‚Üí ‚àÉ r s, a * b = r ^ 2 + s ^ 2\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\", \"content\": \"Set.InjOn Nat.factorization {x | x ‚â† 0}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every natural number larger than `10` is the sum of a square and a prime.\"}]"}
{"text":"The initial object of a category is isomorphic to its terminal object.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"An equivalence of categories transfers enough injectives. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] [inst_1 : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D]\\n  (e : CategoryTheory.Functor C D) [inst_2 : CategoryTheory.IsEquivalence e]\\n  [inst_3 : CategoryTheory.EnoughInjectives D], CategoryTheory.EnoughInjectives C\"},\n {\"role\": \"user\",\n  \"content\": \"There is an initial functor from a small category. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {J : Type u} [inst : CategoryTheory.Category.{v, u} J] [self : CategoryTheory.InitiallySmall J],\\n  ‚àÉ S x F, CategoryTheory.Functor.Initial F\"},\n {\"role\": \"user\",\n  \"content\": \"Each connected component of the category is connected. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {J : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J] (j : CategoryTheory.ConnectedComponents J),\\n  CategoryTheory.IsConnected (CategoryTheory.Component j)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The map from the (any as stated) initial object to any other object is a\\nmonomorphism \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] [self : CategoryTheory.Limits.InitialMonoClass C] {I : C}\\n  (X : C) (hI : CategoryTheory.Limits.IsInitial I), CategoryTheory.Mono (CategoryTheory.Limits.IsInitial.to hI X)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any category with pushouts and initial object has binary coproducts. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (C : Type u) [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Limits.HasInitial C]\\n  [inst_2 : CategoryTheory.Limits.HasPushouts C], CategoryTheory.Limits.HasBinaryCoproducts C\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A category in which coimage-image comparisons are all isomorphisms has images. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Preadditive C]\\n  [inst_2 : CategoryTheory.Limits.HasKernels C] [inst_3 : CategoryTheory.Limits.HasCokernels C]\\n  [inst_4 : ‚àÄ {X Y : C} (f : X ‚ü∂ Y), CategoryTheory.IsIso (CategoryTheory.Abelian.coimageImageComparison f)],\\n  CategoryTheory.Limits.HasImages C\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a connected category, any two objects are related by `Zigzag`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {J : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J] [inst_1 : CategoryTheory.IsConnected J] (j‚ÇÅ j‚ÇÇ : J),\\n  CategoryTheory.Zigzag j‚ÇÅ j‚ÇÇ\"},\n {\"role\": \"user\",\n  \"content\": \"A category with finite biproducts has a zero object. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (C : Type u) [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\\n  [inst_2 : CategoryTheory.Limits.HasFiniteBiproducts C], CategoryTheory.Limits.HasZeroObject C\"},\n {\"role\": \"user\", \"content\": \"Any morphism to an initial object is epi. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] {X Y : C},\\n  CategoryTheory.Limits.IsInitial X ‚Üí ‚àÄ (f : Y ‚ü∂ X), CategoryTheory.Epi f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If there are zero morphisms, any terminal object is a zero object. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], CategoryTheory.Limits.HasZeroObject C\"},\n {\"role\": \"user\",\n  \"content\": \"Any two morphisms from an initial object are equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] {X Y : C},\\n  CategoryTheory.Limits.IsInitial X ‚Üí ‚àÄ (f g : X ‚ü∂ Y), f = g\"},\n {\"role\": \"user\", \"content\": \"Any morphism from a terminal object is mono. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] {X Y : C},\\n  CategoryTheory.Limits.IsTerminal X ‚Üí ‚àÄ (f : X ‚ü∂ Y), CategoryTheory.Mono f\"},\n {\"role\": \"user\", \"content\": \"The category `D` has isomorphic objects equal \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D]\\n  {F : CategoryTheory.Functor D C}, CategoryTheory.IsSkeletonOf C D F ‚Üí CategoryTheory.Skeletal D\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The subcategory of subterminal objects is an exponential ideal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] [inst_1 : CategoryTheory.Limits.HasFiniteProducts C]\\n  [inst_2 : CategoryTheory.CartesianClosed C], CategoryTheory.ExponentialIdeal (CategoryTheory.subterminalInclusion C)\"},\n {\"role\": \"user\",\n  \"content\": \"Any two morphisms to a terminal object are equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] {X Y : C},\\n  CategoryTheory.Limits.IsTerminal X ‚Üí ‚àÄ (f g : Y ‚ü∂ X), f = g\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The initial object of a category is isomorphic to its terminal object.\"}]"}
{"text":"If the composition of two functions is continuous, then each of them is continuous.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If two functions are equal in the relevant interval, their interval integrals are also equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {E : Type u_3} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] {f g : ‚Ñù ‚Üí E} {Œº : MeasureTheory.Measure ‚Ñù}\\n  {a b : ‚Ñù}, Set.EqOn f g (Set.uIcc a b) ‚Üí ‚à´ (x : ‚Ñù) in a..b, f x ‚àÇŒº = ‚à´ (x : ‚Ñù) in a..b, g x ‚àÇŒº\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A sequentially continuous function defined on a sequential space is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : SequentialSpace X]\\n  {f : X ‚Üí Y}, SeqContinuous f ‚Üí Continuous f\"},\n {\"role\": \"user\",\n  \"content\": \"A continuous function is bounded above on a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : TopologicalSpace Œ≤]\\n  [inst_3 : ClosedIciTopology Œ±] [inst_4 : Nonempty Œ±] {f : Œ≤ ‚Üí Œ±} {K : Set Œ≤},\\n  IsCompact K ‚Üí ContinuousOn f K ‚Üí BddAbove (f '' K)\"},\n {\"role\": \"user\",\n  \"content\": \"A locally uniform limit of continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {p : Filter Œπ}\\n  [inst_1 : TopologicalSpace Œ±],\\n  TendstoLocallyUniformly F f p ‚Üí (‚àÄ·∂† (n : Œπ) in p, Continuous (F n)) ‚Üí ‚àÄ [inst_2 : Filter.NeBot p], Continuous f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A function which can be locally uniformly approximated by continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤} [inst_1 : TopologicalSpace Œ±],\\n  (‚àÄ (x : Œ±), ‚àÄ u ‚àà uniformity Œ≤, ‚àÉ t ‚àà nhds x, ‚àÉ F, ContinuousAt F x ‚àß ‚àÄ y ‚àà t, (f y, F y) ‚àà u) ‚Üí Continuous f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Each function of a uniformly equicontinuous family is uniformly continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œπ : Type u_1} {Œ± : Type u_6} {Œ≤ : Type u_7} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] {F : Œπ ‚Üí Œ≤ ‚Üí Œ±},\\n  UniformEquicontinuous F ‚Üí ‚àÄ (i : Œπ), UniformContinuous (F i)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A function which can be uniformly approximated by continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤} [inst_1 : TopologicalSpace Œ±],\\n  (‚àÄ u ‚àà uniformity Œ≤, ‚àÉ F, Continuous F ‚àß ‚àÄ (y : Œ±), (f y, F y) ‚àà u) ‚Üí Continuous f\"},\n {\"role\": \"user\",\n  \"content\": \"Each function of an equicontinuous family is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œπ : Type u_1} {X : Type u_3} {Œ± : Type u_6} [inst : TopologicalSpace X] [inst_1 : UniformSpace Œ±] {F : Œπ ‚Üí X ‚Üí Œ±},\\n  Equicontinuous F ‚Üí ‚àÄ (i : Œπ), Continuous (F i)\"},\n {\"role\": \"user\",\n  \"content\": \"A uniform limit of continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {p : Filter Œπ}\\n  [inst_1 : TopologicalSpace Œ±],\\n  TendstoUniformly F f p ‚Üí (‚àÄ·∂† (n : Œπ) in p, Continuous (F n)) ‚Üí ‚àÄ [inst_2 : Filter.NeBot p], Continuous f\"},\n {\"role\": \"user\",\n  \"content\": \"The composition of two cocontinuous functors is cocontinuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {C : Type u_1} [inst : CategoryTheory.Category.{u_4, u_1} C] {D : Type u_2}\\n  [inst_1 : CategoryTheory.Category.{u_5, u_2} D] {E : Type u_3} [inst_2 : CategoryTheory.Category.{u_6, u_3} E]\\n  (G : CategoryTheory.Functor C D) (G' : CategoryTheory.Functor D E) (J : CategoryTheory.GrothendieckTopology C)\\n  (K : CategoryTheory.GrothendieckTopology D) {L : CategoryTheory.GrothendieckTopology E}\\n  [inst_3 : CategoryTheory.Functor.IsCocontinuous G J K] [inst_4 : CategoryTheory.Functor.IsCocontinuous G' K L],\\n  CategoryTheory.Functor.IsCocontinuous (CategoryTheory.Functor.comp G G') J L\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If two continuous functions are equal on a dense set, then they are equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : T2Space X]\\n  {s : Set Y}, Dense s ‚Üí ‚àÄ {f g : Y ‚Üí X}, Continuous f ‚Üí Continuous g ‚Üí Set.EqOn f g s ‚Üí f = g\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If two continuous functions are a.e. equal, then they are equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\\n  [inst_2 : T2Space Y] {Œº : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure Œº] {f g : X ‚Üí Y},\\n  f =·∂†[MeasureTheory.Measure.ae Œº] g ‚Üí Continuous f ‚Üí Continuous g ‚Üí f = g\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If the composition of two functions is continuous, then each of them is continuous.\"}]"}
{"text":"If `a` commutes with `b` and `b` commutes with `c` then `a` commutes with `c`.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"If `a` is invertible and `a = b`, then `‚Öüa = ‚Öüb`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : Monoid Œ±] (a b : Œ±) [inst_1 : Invertible a] [inst_2 : Invertible b], a = b ‚Üí ‚Öüa = ‚Öüb\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Self-adjoint elements commute if and only if their product is self-adjoint. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_3} [inst : Mul R] [inst_1 : StarMul R] {x y : R},\\n  IsSelfAdjoint x ‚Üí IsSelfAdjoint y ‚Üí (Commute x y ‚Üî IsSelfAdjoint (x * y))\"},\n {\"role\": \"user\",\n  \"content\": \"Equality behind `Commute a b`; useful for rewriting. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {S : Type u_2} [inst : Mul S] {a b : S}, Commute a b ‚Üí a * b = b * a\"},\n {\"role\": \"user\", \"content\": \"If `a % b = c` then `b` divides `a - c`. \"},\n {\"role\": \"assistant\", \"content\": \"‚àÄ {a b c : ‚Ñ§}, a % b = c ‚Üí b ‚à£ a - c\"},\n {\"role\": \"user\",\n  \"content\":\n  \"`X` commutes with everything, even when the coefficients are noncommutative. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} [inst : Semiring R] {p : Polynomial R}, Polynomial.X * p = p * Polynomial.X\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `a` and `b` fall within the same cycle WRT `c`, then they are congruent modulo `p`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : LinearOrderedAddCommGroup Œ±] [hŒ± : Archimedean Œ±] {p : Œ±} (hp : 0 < p) {a b c : Œ±},\\n  toIcoMod hp c a = toIcoMod hp c b ‚Üî a ‚â° b [PMOD p]\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Transitivity for `BEq`. If `a == b` and `b == c` then `a == c`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : BEq Œ±] [self : PartialEquivBEq Œ±] {a b c : Œ±},\\n  (a == b) = true ‚Üí (b == c) = true ‚Üí (a == c) = true\"},\n {\"role\": \"user\",\n  \"content\": \"If `c ‚Ä¢ a < c ‚Ä¢ b` for some positive `c`, then `a < b`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} {M : Type u_2} [inst : OrderedSemiring R] [inst_1 : OrderedAddCommMonoid M] [inst_2 : SMulWithZero R M]\\n  [self : OrderedSMul R M] {a b : M} {c : R}, c ‚Ä¢ a < c ‚Ä¢ b ‚Üí 0 < c ‚Üí a < b\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For every pair of elements `a` and `b` there is a `c` such that `r a c` and `r b c` \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} {r : Œ± ‚Üí Œ± ‚Üí Prop} [self : IsDirected Œ± r] (a b : Œ±), ‚àÉ c, r a c ‚àß r b c\"},\n {\"role\": \"user\", \"content\": \"Any element commutes with itself.\"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {S : Type u_2} [inst : Add S] (a : S), AddCommute a a\"},\n {\"role\": \"user\", \"content\": \"Any element commutes with itself. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {S : Type u_2} [inst : Mul S] (a : S), Commute a a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If both `a` and `b` commute with `c`, then their product commutes with `c`.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {S : Type u_2} [inst : AddSemigroup S] {a b c : S}, AddCommute a c ‚Üí AddCommute b c ‚Üí AddCommute (a + b) c\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If both `a` and `b` commute with `c`, then their product commutes with `c`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {S : Type u_2} [inst : Semigroup S] {a b c : S}, Commute a c ‚Üí Commute b c ‚Üí Commute (a * b) c\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `a` commutes with both `b` and `c`, then it commutes with their sum.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {S : Type u_2} [inst : AddSemigroup S] {a b c : S}, AddCommute a b ‚Üí AddCommute a c ‚Üí AddCommute a (b + c)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `a` commutes with both `b` and `c`, then it commutes with their product. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {S : Type u_2} [inst : Semigroup S] {a b c : S}, Commute a b ‚Üí Commute a c ‚Üí Commute a (b * c)\"},\n {\"role\": \"user\",\n  \"content\": \"If `a` commutes with `b`, then `b` commutes with `a`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {S : Type u_2} [inst : Mul S] {a b : S}, Commute a b ‚Üí Commute b a\"},\n {\"role\": \"user\",\n  \"content\": \"If `a` commutes with `b`, then `b` commutes with `a`.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {S : Type u_2} [inst : Add S] {a b : S}, AddCommute a b ‚Üí AddCommute b a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `a` commutes with `b` and `b` commutes with `c` then `a` commutes with `c`.\"}]"}
{"text":"If an element maps to zero under a ring homomorphism, then it is zero.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If two ring homomorphisms are equal on a set, then they are equal on its subsemiring closure. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} {S : Type v} [inst : NonAssocSemiring R] [inst_1 : NonAssocSemiring S] {f g : R ‚Üí+* S} {s : Set R},\\n  Set.EqOn (‚áëf) (‚áëg) s ‚Üí Set.EqOn ‚áëf ‚áëg ‚Üë(Subsemiring.closure s)\"},\n {\"role\": \"user\",\n  \"content\": \"In degree `0`, the null homotopic map `HœÉ` is zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {C : Type u_1} [inst : CategoryTheory.Category.{u_2, u_1} C] [inst_1 : CategoryTheory.Preadditive C]\\n  {X : CategoryTheory.SimplicialObject C} (q : ‚Ñï), HomologicalComplex.Hom.f (AlgebraicTopology.DoldKan.HœÉ q) 0 = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In an integral domain, a sum indexed by a nontrivial homomorphism from a finite group is zero.\\n\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} {G : Type u_2} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Fintype G]\\n  (f : G ‚Üí* R), f ‚â† 1 ‚Üí (Finset.sum Finset.univ fun g => f g) = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If two ring homomorphisms are equal on a set, then they are equal on its subfield closure. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u} {L : Type v} [inst : Field K] [inst_1 : Field L] {f g : K ‚Üí+* L} {s : Set K},\\n  Set.EqOn (‚áëf) (‚áëg) s ‚Üí Set.EqOn ‚áëf ‚áëg ‚Üë(Subfield.closure s)\"},\n {\"role\": \"user\", \"content\": \"Ring homomorphisms map one to one. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_3} {x : NonAssocSemiring Œ±} {x_1 : NonAssocSemiring Œ≤} (f : Œ± ‚Üí+* Œ≤), f 1 = 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If the algebra map `R ‚Üí+* A` is injective and `R` has characteristic zero then so does `A`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} {A : Type u_2} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A],\\n  Function.Injective ‚áë(algebraMap R A) ‚Üí ‚àÄ [inst : CharZero R], CharZero A\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a monoid with zero, zero equals one if and only if all elements of that semiring\\nare equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {M‚ÇÄ : Type u_2} [inst : MulZeroOneClass M‚ÇÄ], 0 = 1 ‚Üî Subsingleton M‚ÇÄ\"},\n {\"role\": \"user\",\n  \"content\": \"A ring is a `‚Ñö`-algebra iff it has equal characteristic zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (R : Type u_1) [inst : CommRing R], Nonempty (Algebra ‚Ñö R) ‚Üî ‚àÄ (I : Ideal R), I ‚â† ‚ä§ ‚Üí CharZero (R ‚ß∏ I)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If two ring homomorphisms are equal on a set, then they are equal on its subring closure. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] {f g : R ‚Üí+* S} {s : Set R},\\n  Set.EqOn (‚áëf) (‚áëg) s ‚Üí Set.EqOn ‚áëf ‚áëg ‚Üë(Subring.closure s)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a monoid with zero, if zero equals one, then zero is the only element. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {M‚ÇÄ : Type u_2} [inst : MulZeroOneClass M‚ÇÄ], 0 = 1 ‚Üí ‚àÄ (a : M‚ÇÄ), a = 0\"},\n {\"role\": \"user\", \"content\": \"The ring homomorphism is an isometry. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R‚ÇÅ : Type u_5} {R‚ÇÇ : Type u_6} [inst : Semiring R‚ÇÅ] [inst_1 : Semiring R‚ÇÇ] [inst_2 : Norm R‚ÇÅ] [inst_3 : Norm R‚ÇÇ]\\n  {œÉ : R‚ÇÅ ‚Üí+* R‚ÇÇ} [self : RingHomIsometric œÉ] {x : R‚ÇÅ}, ‚ÄñœÉ x‚Äñ = ‚Äñx‚Äñ\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A subring of a ring with no zero divisors has no zero divisors. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} [inst : Ring R] [inst_1 : NoZeroDivisors R] (s : Subring R), NoZeroDivisors ‚Ü•s\"},\n {\"role\": \"user\",\n  \"content\": \"The zero morphism maps every pseudoelement to 0. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Abelian C] {P : C} (Q : C)\\n  (a : CategoryTheory.Abelian.Pseudoelement P), CategoryTheory.Abelian.Pseudoelement.pseudoApply 0 a = 0\"},\n {\"role\": \"user\",\n  \"content\": \"An element is in the kernel if and only if it maps to zero.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} {S : Type v} {F : Type u_1} [inst : Semiring R] [inst_1 : Semiring S] [rcf : RingHomClass F R S] (f : F)\\n  {r : R}, r ‚àà RingHom.ker f ‚Üî f r = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A morphism that is injective on pseudoelements only maps the zero element to zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Abelian C] {P Q : C} (f : P ‚ü∂ Q),\\n  Function.Injective (CategoryTheory.Abelian.Pseudoelement.pseudoApply f) ‚Üí\\n    ‚àÄ (a : CategoryTheory.Abelian.Pseudoelement P), CategoryTheory.Abelian.Pseudoelement.pseudoApply f a = 0 ‚Üí a = 0\"},\n {\"role\": \"user\", \"content\": \"An additive group homomorphism sends 0 to 0.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : AddGroup Œ±] [inst_1 : AddGroup Œ≤] {f : Œ± ‚Üí Œ≤}, IsAddGroupHom f ‚Üí f 0 = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A morphism that only maps the zero pseudoelement to zero is a monomorphism. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Abelian C] {P Q : C} (f : P ‚ü∂ Q),\\n  (‚àÄ (a : CategoryTheory.Abelian.Pseudoelement P), CategoryTheory.Abelian.Pseudoelement.pseudoApply f a = 0 ‚Üí a = 0) ‚Üí\\n    CategoryTheory.Mono f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a ring homomorphism `R ‚Üí+* A` is injective and `R` has characteristic zero\\nthen so does `A`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} {A : Type u_2} [inst : Semiring R] [inst_1 : Semiring A] {f : R ‚Üí+* A},\\n  Function.Injective ‚áëf ‚Üí ‚àÄ [inst : CharZero R], CharZero A\"},\n {\"role\": \"user\", \"content\": \"A ring isomorphism sends zero to zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_4} {S : Type u_5} [inst : NonUnitalNonAssocSemiring R] [inst_1 : NonUnitalNonAssocSemiring S]\\n  (f : R ‚âÉ+* S), f 0 = 0\"},\n {\"role\": \"user\", \"content\": \"Ring homomorphisms map zero to zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_3} {x : NonAssocSemiring Œ±} {x_1 : NonAssocSemiring Œ≤} (f : Œ± ‚Üí+* Œ≤), f 0 = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If an element maps to zero under a ring homomorphism, then it is zero.\"}]"}
{"text":"Implication `‚Üí` is symmetric. If `P ‚Üí Q` then `Q ‚Üí P`.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The proposition that a bi-Heyting homomorphism preserves the Heyting implication.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {F : Type u_6} {Œ± : outParam (Type u_7)} {Œ≤ : outParam (Type u_8)} [inst : BiheytingAlgebra Œ±]\\n  [inst_1 : BiheytingAlgebra Œ≤] [self : BiheytingHomClass F Œ± Œ≤] (f : F) (a b : Œ±), f (a ‚á® b) = f a ‚á® f b\"},\n {\"role\": \"user\",\n  \"content\": \"If `f,g` is reflexive, then `g,f` is reflexive. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {A B : C} {f g : A ‚ü∂ B}\\n  [inst_1 : CategoryTheory.IsReflexivePair f g], CategoryTheory.IsReflexivePair g f\"},\n {\"role\": \"user\", \"content\": \"Additive congruence relations are symmetric.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {M : Type u_1} [inst : Add M] (c : AddCon M) {x y : M}, c x y ‚Üí c y x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Corollary of the third isomorphism theorem: `[S : T] [M : S] = [M : T]` \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] (S T : Submodule R M),\\n  T ‚â§ S ‚Üí\\n    ‚àÄ [inst_3 : DecidablePred fun x => x ‚àà Submodule.map (Submodule.mkQ T) S] [inst_4 : Fintype (M ‚ß∏ S)]\\n      [inst_5 : Fintype (M ‚ß∏ T)],\\n      Fintype.card ‚Ü•(Submodule.map (Submodule.mkQ T) S) * Fintype.card (M ‚ß∏ S) = Fintype.card (M ‚ß∏ T)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The proposition that a Heyting homomorphism preserves the Heyting implication.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {F : Type u_6} {Œ± : outParam (Type u_7)} {Œ≤ : outParam (Type u_8)} [inst : HeytingAlgebra Œ±]\\n  [inst_1 : HeytingAlgebra Œ≤] [self : HeytingHomClass F Œ± Œ≤] (f : F) (a b : Œ±), f (a ‚á® b) = f a ‚á® f b\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `P` holds for `f : X ‚ü∂ Y`, then `P` holds for `f ‚à£_ U` for any `U`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme},\\n  AlgebraicGeometry.PropertyIsLocalAtTarget P ‚Üí\\n    ‚àÄ {X Y : AlgebraicGeometry.Scheme} (f : X ‚ü∂ Y) (U : TopologicalSpace.Opens ‚Üë‚ÜëY.toPresheafedSpace), P f ‚Üí P (f ‚à£_ U)\"},\n {\"role\": \"user\", \"content\": \"Congruence relations are symmetric. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {M : Type u_1} [inst : Mul M] (c : Con M) {x y : M}, c x y ‚Üí c y x\"},\n {\"role\": \"user\",\n  \"content\": \"`P` as a morphism property respects isomorphisms \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {P : AlgebraicGeometry.AffineTargetMorphismProperty},\\n  AlgebraicGeometry.AffineTargetMorphismProperty.IsLocal P ‚Üí\\n    CategoryTheory.MorphismProperty.RespectsIso (AlgebraicGeometry.AffineTargetMorphismProperty.toProperty P)\"},\n {\"role\": \"user\", \"content\": \"`x ‚á® y` is equal to `y ‚äî x·∂ú` \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [self : BooleanAlgebra Œ±] (x y : Œ±), x ‚á® y = y ‚äî x·∂ú\"},\n {\"role\": \"user\",\n  \"content\":\n  \"An antisymmetric relation `(¬∑‚â§¬∑)` satisfies `a ‚â§ b ‚Üí b ‚â§ a ‚Üí a = b`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop} [self : Antisymm r] {a b : Œ±}, r a b ‚Üí r b a ‚Üí a = b\"},\n {\"role\": \"user\", \"content\": \"monotonicity of `‚â§` with respect to `‚Üí` \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {a b c d : Œ±} [inst : Preorder Œ±], c ‚â§ a ‚Üí b ‚â§ d ‚Üí a ‚â§ b ‚Üí c ‚â§ d\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `‚àÄ I > J, P I` implies `P J`, then `P` holds for all submodules. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\\n  [inst_3 : IsNoetherian R M] {P : Submodule R M ‚Üí Prop},\\n  (‚àÄ (I : Submodule R M), (‚àÄ J > I, P J) ‚Üí P I) ‚Üí ‚àÄ (I : Submodule R M), P I\"},\n {\"role\": \"user\", \"content\": \"An equivalence relation is reflexive: `x ~ x` \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop}, Equivalence r ‚Üí ‚àÄ (x : Œ±), r x x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"An equivalence relation is transitive: `x ~ y` and `y ~ z` implies `x ~ z` \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop}, Equivalence r ‚Üí ‚àÄ {x y z : Œ±}, r x y ‚Üí r y z ‚Üí r x z\"},\n {\"role\": \"user\", \"content\": \"`P` respects isomorphisms. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme},\\n  AlgebraicGeometry.PropertyIsLocalAtTarget P ‚Üí CategoryTheory.MorphismProperty.RespectsIso P\"},\n {\"role\": \"user\",\n  \"content\": \"If `p` and `q` are irreducible, then `p ‚à£ q` implies `q ‚à£ p`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : Monoid Œ±] {p q : Œ±}, Irreducible p ‚Üí Irreducible q ‚Üí p ‚à£ q ‚Üí q ‚à£ p\"},\n {\"role\": \"user\", \"content\": \"`(P ‚ü∂ P‚Å∫)‚Å∫ = P‚Å∫ ‚ü∂ P‚Å∫‚Å∫` \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] (J : CategoryTheory.GrothendieckTopology C) {D : Type w}\\n  [inst_1 : CategoryTheory.Category.{max v u, w} D]\\n  [inst_2 :\\n    ‚àÄ (P : CategoryTheory.Functor C·µí·µñ D) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover J X),\\n      CategoryTheory.Limits.HasMultiequalizer (CategoryTheory.GrothendieckTopology.Cover.index S P)]\\n  (P : CategoryTheory.Functor C·µí·µñ D)\\n  [inst_3 : ‚àÄ (X : C), CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.GrothendieckTopology.Cover J X)·µí·µñ D],\\n  CategoryTheory.GrothendieckTopology.plusMap J (CategoryTheory.GrothendieckTopology.toPlus J P) =\\n    CategoryTheory.GrothendieckTopology.toPlus J (CategoryTheory.GrothendieckTopology.plusObj J P)\"},\n {\"role\": \"user\",\n  \"content\": \"An equivalence relation is symmetric: `x ~ y` implies `y ~ x` \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop}, Equivalence r ‚Üí ‚àÄ {x y : Œ±}, r x y ‚Üí r y x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Implication `‚Üí` is transitive. If `P ‚Üí Q` and `Q ‚Üí R` then `P ‚Üí R`. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {p q r : Prop}, (p ‚Üí q) ‚Üí (q ‚Üí r) ‚Üí p ‚Üí r\"},\n {\"role\": \"user\",\n  \"content\": \"Implication `‚Üí` is symmetric. If `P ‚Üí Q` then `Q ‚Üí P`.\"}]"}
{"text":"Two natural numbers are equal if and only if they are both divisible by some prime number.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If an integer with larger absolute value divides an integer, it is\\nzero. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {a b : ‚Ñ§}, a ‚à£ b ‚Üí Int.natAbs b < Int.natAbs a ‚Üí b = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two finite cardinals are equal iff they are equal their to_nat are equal \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {c d : Cardinal.{u_1}}, c < Cardinal.aleph0 ‚Üí d < Cardinal.aleph0 ‚Üí (Cardinal.toNat c = Cardinal.toNat d ‚Üî c = d)\"},\n {\"role\": \"user\",\n  \"content\": \"Pre-games defined by natural numbers are numeric. \"},\n {\"role\": \"assistant\", \"content\": \"‚àÄ (n : ‚Ñï), SetTheory.PGame.Numeric ‚Üën\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ (n : ‚Ñï), Nat.factorization n = 0 ‚Üî n = 0 ‚à® n = 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The numerator and denominator are coprime: it is in \\\"reduced form\\\". \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ (self : ‚Ñö), Nat.Coprime (Int.natAbs self.num) self.den\"},\n {\"role\": \"user\",\n  \"content\": \"Infinitely many natural numbers are equal to `d` mod `n`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {n : ‚Ñï}, n ‚â† 0 ‚Üí ‚àÄ (d : ‚Ñï), ‚àÉ·∂† (m : ‚Ñï) in Filter.atTop, m ‚â° d [MOD n]\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {a b x y u v : ‚Ñï}, a = x ^ 2 + y ^ 2 ‚Üí b = u ^ 2 + v ^ 2 ‚Üí ‚àÉ r s, a * b = r ^ 2 + s ^ 2\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two positive naturals are equal if their prime padic valuations are equal \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (a b : ‚Ñï), a ‚â† 0 ‚Üí b ‚â† 0 ‚Üí (a = b ‚Üî ‚àÄ (p : ‚Ñï), Nat.Prime p ‚Üí padicValNat p a = padicValNat p b)\"},\n {\"role\": \"user\",\n  \"content\": \"Any common divisor of both elements is a divisor of the GCD. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_2} [inst : CancelCommMonoidWithZero Œ±] [self : GCDMonoid Œ±] {a b c : Œ±}, a ‚à£ c ‚Üí a ‚à£ b ‚Üí a ‚à£ gcd c b\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If two integers are congruent to a sufficiently large modulus,\\nthey are equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {a b c : ‚Ñ§}, a % b = c ‚Üí Int.natAbs (a - c) < Int.natAbs b ‚Üí a = c\"},\n {\"role\": \"user\",\n  \"content\": \"The only divisors of prime powers are prime powers. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : CancelCommMonoidWithZero Œ±] [dec_irr : (p : Associates Œ±) ‚Üí Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid Œ±] [dec : DecidableEq Œ±] [dec' : DecidableEq (Associates Œ±)] {a p : Associates Œ±},\\n  Irreducible p ‚Üí\\n    ‚àÄ [inst_2 : (n : ‚Ñï) ‚Üí Decidable (a ‚à£ p ^ n)] {n : ‚Ñï} (h : a ‚à£ p ^ n),\\n      a = p ^ Nat.find (_ : ‚àÉ n, (fun n => a ‚à£ p ^ n) n)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A prime natural number is prime in `‚Ñ§[i]` if and only if it is `3` mod `4` \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ (p : ‚Ñï) [inst : Fact (Nat.Prime p)], Prime ‚Üëp ‚Üî p % 4 = 3\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A natural number `m` divides the sum `n + m` if and only if `m` divides `n`.\"},\n {\"role\": \"assistant\", \"content\": \"‚àÄ {m n : ‚Ñï}, m ‚à£ n + m ‚Üî m ‚à£ n\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\", \"content\": \"Set.InjOn Nat.factorization {x | x ‚â† 0}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A natural number `m` divides the sum `m + n` if and only if `m` divides `n`.\"},\n {\"role\": \"assistant\", \"content\": \"‚àÄ {m n : ‚Ñï}, m ‚à£ m + n ‚Üî m ‚à£ n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a small natural number is divisible by a larger natural number,\\nthe small number is zero. \"},\n {\"role\": \"assistant\", \"content\": \"‚àÄ {a b : ‚Ñï}, a ‚à£ b ‚Üí b < a ‚Üí b = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {m n : ‚Ñï}, (‚àÄ (a : ‚Ñï), m ‚à£ a ‚Üî n ‚à£ a) ‚Üî m = n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {m n : ‚Ñï}, (‚àÄ (a : ‚Ñï), a ‚à£ m ‚Üî a ‚à£ n) ‚Üî m = n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they are both divisible by some prime number.\"}]"}
{"text":"Every ring is a field.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any conditionally complete linearly ordered field is archimedean. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : ConditionallyCompleteLinearOrderedField Œ±], Archimedean Œ±\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If two rings are isomorphic, and the second is a domain, then so is the first. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {A : Type u_1} (B : Type u_2) [inst : Ring A] [inst_1 : Ring B] [inst_2 : IsDomain B], A ‚âÉ+* B ‚Üí IsDomain A\"},\n {\"role\": \"user\", \"content\": \"A field extension is integral if it is finite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (K : Type u_1) (L : Type u_2) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L]\\n  [inst_3 : FiniteDimensional K L], Algebra.IsIntegral K L\"},\n {\"role\": \"user\",\n  \"content\": \"All ideals in a division (semi)ring are trivial. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u} [inst : DivisionSemiring K] (I : Ideal K), I = ‚ä• ‚à® I = ‚ä§\"},\n {\"role\": \"user\", \"content\": \"A finite field has prime power cardinality. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : Fintype Œ±] [inst_1 : Field Œ±], IsPrimePow (Fintype.card Œ±)\"},\n {\"role\": \"user\", \"content\": \"A subring contains the ring's 0. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {R : Type u} [inst : Ring R] (s : Subring R), 0 ‚àà s\"},\n {\"role\": \"user\",\n  \"content\": \"The characteristic of a finite ring cannot be zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (R : Type u_1) [inst : NonAssocRing R] (p : ‚Ñï) [inst : CharP R p] [inst : Finite R], p ‚â† 0\"},\n {\"role\": \"user\",\n  \"content\": \"Stalks of a locally ringed space are local rings. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (self : AlgebraicGeometry.LocallyRingedSpace) (x : ‚Üë‚Üëself.toPresheafedSpace),\\n  LocalRing ‚Üë(TopCat.Presheaf.stalk self.presheaf x)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The quotient of a ring by an ideal is a field iff the ideal is maximal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I ‚Üî IsField (R ‚ß∏ I)\"},\n {\"role\": \"user\", \"content\": \"The category of rings has all limits. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"CategoryTheory.Limits.HasLimitsOfSize.{v, v, max u v, max (u + 1) (v + 1)} CommSemiRingCatMax\"},\n {\"role\": \"user\", \"content\": \"Every ring involution must be its own inverse \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {F : Type u_1} {R : outParam (Type u_2)} [inst : Semiring R] [self : RingInvoClass F R] (f : F) (x : R),\\n  MulOpposite.unop (‚Üëf (MulOpposite.unop (‚Üëf x))) = x\"},\n {\"role\": \"user\",\n  \"content\": \"Any infinite type can be endowed a field structure. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {Œ± : Type u} [inst : Infinite Œ±], Nonempty (Field Œ±)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For a semiring to be a field, it must have two distinct elements. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {R : Type u} [inst : Semiring R], IsField R ‚Üí ‚àÉ x y, x ‚â† y\"},\n {\"role\": \"user\",\n  \"content\": \"When a ring is not a field, the maximal ideals are nontrivial. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} [inst : CommSemiring R] [inst_1 : Nontrivial R] {M : Ideal R}, Ideal.IsMaximal M ‚Üí ¬¨IsField R ‚Üí M ‚â† ‚ä•\"},\n {\"role\": \"user\",\n  \"content\": \"A linear ordered field that is a floor ring is archimedean. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (Œ± : Type u_1) [inst : LinearOrderedField Œ±] [inst_1 : FloorRing Œ±], Archimedean Œ±\"},\n {\"role\": \"user\", \"content\": \"Fields are commutative. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} [inst : Semiring R], IsField R ‚Üí ‚àÄ (x y : R), x * y = y * x\"},\n {\"role\": \"user\",\n  \"content\": \"The ring of integers of a number field is not a field. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (K : Type u_1) [inst : Field K] [nf : NumberField K], ¬¨IsField { x // x ‚àà NumberField.ringOfIntegers K }\"},\n {\"role\": \"user\", \"content\": \"An intermediate field contains the ring's 1. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\\n  1 ‚àà S\"},\n {\"role\": \"user\", \"content\": \"An intermediate field contains the ring's 0. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\\n  0 ‚àà S\"},\n {\"role\": \"user\", \"content\": \"A field is a valuation ring. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ (K : Type u) [inst : Field K], ValuationRing K\"},\n {\"role\": \"user\", \"content\": \"Every ring is a field.\"}]"}
{"text":"Every vector space is finite dimensional.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a vector space has a finite dimension, the index set of `Basis.ofVectorSpace` is finite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\\n  Module.rank K V < Cardinal.aleph0 ‚Üí Set.Finite (Basis.ofVectorSpaceIndex K V)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The dimension of a finite dimensional space is preserved under linear equivalence. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} {M : Type u_2} {M‚ÇÇ : Type u_3} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : AddCommGroup M‚ÇÇ]\\n  [inst_3 : Module R M] [inst_4 : Module R M‚ÇÇ],\\n  (M ‚âÉ‚Çó[R] M‚ÇÇ) ‚Üí FiniteDimensional.finrank R M = FiniteDimensional.finrank R M‚ÇÇ\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two vector spaces are isomorphic if and only if they have the same dimension. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u} {V : Type v} {V' : Type v'} [inst : Ring K] [inst_1 : StrongRankCondition K] [inst_2 : AddCommGroup V]\\n  [inst_3 : Module K V] [inst_4 : Module.Free K V] [inst_5 : AddCommGroup V'] [inst_6 : Module K V']\\n  [inst_7 : Module.Free K V'],\\n  Nonempty (V ‚âÉ‚Çó[K] V') ‚Üî Cardinal.lift (Module.rank K V) = Cardinal.lift (Module.rank K V')\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The image under an onto linear map of a finite-dimensional space is also finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {V‚ÇÇ : Type v'}\\n  [inst_3 : AddCommGroup V‚ÇÇ] [inst_4 : Module K V‚ÇÇ] [inst_5 : FiniteDimensional K V] (f : V ‚Üí‚Çó[K] V‚ÇÇ),\\n  LinearMap.range f = ‚ä§ ‚Üí FiniteDimensional K V‚ÇÇ\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The range of a linear map defined on a finite-dimensional space is also finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {V‚ÇÇ : Type v'}\\n  [inst_3 : AddCommGroup V‚ÇÇ] [inst_4 : Module K V‚ÇÇ] [inst_5 : FiniteDimensional K V] (f : V ‚Üí‚Çó[K] V‚ÇÇ),\\n  FiniteDimensional K { x // x ‚àà LinearMap.range f }\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The `vectorSpan` of adding a point to a finite-dimensional subspace is finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] (s : AffineSubspace k P)\\n  [inst_4 : FiniteDimensional k { x // x ‚àà AffineSubspace.direction s }] (p : P),\\n  FiniteDimensional k { x // x ‚àà vectorSpan k (insert p ‚Üës) }\"},\n {\"role\": \"user\",\n  \"content\":\n  \"An affine-independent subset of a finite-dimensional affine space is finite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (k : Type u_1) {V : Type u_2} {P : Type u_4} {Œπ : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V]\\n  [inst_2 : Module k V] [inst_3 : AddTorsor V P] [inst_4 : FiniteDimensional k V] {s : Set Œπ} {f : ‚Üës ‚Üí P},\\n  AffineIndependent k f ‚Üí Set.Finite s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A quotient of a finite-dimensional space is also finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K (V ‚ß∏ S)\"},\n {\"role\": \"user\",\n  \"content\": \"Two linearly equivalent vector spaces have the same dimension. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} [inst : Ring R] {M : Type v} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {M‚ÇÅ : Type v}\\n  [inst_3 : AddCommGroup M‚ÇÅ] [inst_4 : Module R M‚ÇÅ], (M ‚âÉ‚Çó[R] M‚ÇÅ) ‚Üí Module.rank R M = Module.rank R M‚ÇÅ\"},\n {\"role\": \"user\",\n  \"content\": \"The `vectorSpan` of a finite set is finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (k : Type u_2) {V : Type u_3} {P : Type u_1} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] {s : Set P}, Set.Finite s ‚Üí FiniteDimensional k { x // x ‚àà vectorSpan k s }\"},\n {\"role\": \"user\", \"content\": \"A finite-dimensional subspace is closed. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {ùïú : Type u} [inst : NontriviallyNormedField ùïú] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ùïú E] [inst_3 : CompleteSpace ùïú] (s : Submodule ùïú E)\\n  [inst_4 : FiniteDimensional ùïú { x // x ‚àà s }], IsClosed ‚Üës\"},\n {\"role\": \"user\", \"content\": \"A finite-dimensional subspace is complete. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {ùïú : Type u} [inst : NontriviallyNormedField ùïú] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ùïú E] [inst_3 : CompleteSpace ùïú] (s : Submodule ùïú E)\\n  [inst_4 : FiniteDimensional ùïú { x // x ‚àà s }], IsComplete ‚Üës\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The space of continuous linear maps between finite-dimensional spaces is finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {ùïú : Type u_1} {E : Type u_2} {F : Type u_3} [inst : Field ùïú] [inst_1 : TopologicalSpace ùïú] [inst_2 : AddCommGroup E]\\n  [inst_3 : Module ùïú E] [inst_4 : TopologicalSpace E] [inst_5 : AddCommGroup F] [inst_6 : Module ùïú F]\\n  [inst_7 : TopologicalSpace F] [inst_8 : TopologicalAddGroup F] [inst_9 : ContinuousSMul ùïú F]\\n  [inst_10 : FiniteDimensional ùïú E] [inst_11 : FiniteDimensional ùïú F], FiniteDimensional ùïú (E ‚ÜíL[ùïú] F)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A subspace of a finite-dimensional space is also finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K { x // x ‚àà S }\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a vector space has a basis indexed by elements of a finite set, then it is\\nfinite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Œπ : Type w}\\n  {s : Set Œπ}, Basis (‚Üës) K V ‚Üí Set.Finite s ‚Üí FiniteDimensional K V\"},\n {\"role\": \"user\", \"content\": \"All hom spaces are finite dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {k G : Type u} [inst : Field k] [inst_1 : Monoid G] (V W : FdRep k G), FiniteDimensional k (V ‚ü∂ W)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a vector space has a finite basis, then it is finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Œπ : Type w}\\n  [inst_3 : Finite Œπ], Basis Œπ K V ‚Üí FiniteDimensional K V\"},\n {\"role\": \"user\", \"content\": \"Every vector space is finite dimensional.\"}]"}
{"text":"Every group is a torsion monoid.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Quotienting a group by its additive torsion subgroup yields an additive torsion free group.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (G : Type u_1) [inst : AddCommGroup G], AddMonoid.IsTorsionFree (G ‚ß∏ AddCommGroup.torsion G)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The additive torsion submonoid of an abelian group equals the torsion\\nsubgroup as a submonoid.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (G : Type u_1) [inst : AddCommGroup G], AddCommMonoid.addTorsion G = (AddCommGroup.torsion G).toAddSubmonoid\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Direct products of additive torsion free groups are torsion free.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ∑ : Type u_1} {Gs : Œ∑ ‚Üí Type u_2} [inst : (i : Œ∑) ‚Üí AddGroup (Gs i)],\\n  (‚àÄ (i : Œ∑), AddMonoid.IsTorsionFree (Gs i)) ‚Üí AddMonoid.IsTorsionFree ((i : Œ∑) ‚Üí Gs i)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The image of a surjective torsion group homomorphism is torsion. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H] {f : G ‚Üí* H},\\n  Function.Surjective ‚Üëf ‚Üí Monoid.IsTorsion G ‚Üí Monoid.IsTorsion H\"},\n {\"role\": \"user\", \"content\": \"Torsion monoids are really groups. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"{G : Type u_1} ‚Üí [inst : Monoid G] ‚Üí Monoid.IsTorsion G ‚Üí Group G\"},\n {\"role\": \"user\",\n  \"content\": \"Additive torsion groups are closed under extensions.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} {H : Type u_2} [inst : AddGroup G] {N : AddSubgroup G} [inst_1 : AddGroup H] {f : G ‚Üí+ H},\\n  N = AddMonoidHom.ker f ‚Üí AddMonoid.IsTorsion H ‚Üí AddMonoid.IsTorsion { x // x ‚àà N } ‚Üí AddMonoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\": \"If a group exponent exists, the group is torsion. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G], Monoid.ExponentExists G ‚Üí Monoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\": \"Direct products of torsion free groups are torsion free. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ∑ : Type u_1} {Gs : Œ∑ ‚Üí Type u_2} [inst : (i : Œ∑) ‚Üí Group (Gs i)],\\n  (‚àÄ (i : Œ∑), Monoid.IsTorsionFree (Gs i)) ‚Üí Monoid.IsTorsionFree ((i : Œ∑) ‚Üí Gs i)\"},\n {\"role\": \"user\",\n  \"content\": \"Additive torsion submonoids are additively torsion.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : AddCommMonoid G], AddMonoid.IsTorsion { x // x ‚àà AddCommMonoid.addTorsion G }\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Quotienting a group by its torsion subgroup yields a torsion free group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G ‚ß∏ CommGroup.torsion G)\"},\n {\"role\": \"user\",\n  \"content\": \"The torsion submonoid of a torsion monoid is `‚ä§`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : CommMonoid G], Monoid.IsTorsion G ‚Üí CommMonoid.torsion G = ‚ä§\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The torsion submonoid of an abelian group equals the torsion subgroup as a submonoid. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (G : Type u_1) [inst : CommGroup G], CommMonoid.torsion G = (CommGroup.torsion G).toSubmonoid\"},\n {\"role\": \"user\", \"content\": \"Torsion groups are closed under extensions. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G ‚Üí* H},\\n  N = MonoidHom.ker f ‚Üí Monoid.IsTorsion H ‚Üí Monoid.IsTorsion { x // x ‚àà N } ‚Üí Monoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\": \"Finite additive groups are additive torsion groups.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G] [inst_1 : Finite G], AddMonoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Subgroups of additive torsion-free groups are additively torsion-free.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G],\\n  AddMonoid.IsTorsionFree G ‚Üí ‚àÄ (H : AddSubgroup G), AddMonoid.IsTorsionFree { x // x ‚àà H }\"},\n {\"role\": \"user\", \"content\": \"Torsion submonoids are torsion. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : CommMonoid G], Monoid.IsTorsion { x // x ‚àà CommMonoid.torsion G }\"},\n {\"role\": \"user\",\n  \"content\": \"Subgroups of torsion-free groups are torsion-free. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G ‚Üí ‚àÄ (H : Subgroup G), Monoid.IsTorsionFree { x // x ‚àà H }\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Subgroups of additive torsion groups are additive torsion groups.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G], AddMonoid.IsTorsion G ‚Üí ‚àÄ (H : AddSubgroup G), AddMonoid.IsTorsion { x // x ‚àà H }\"},\n {\"role\": \"user\", \"content\": \"Finite groups are torsion groups. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\": \"Subgroups of torsion groups are torsion groups. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ‚Üí ‚àÄ (H : Subgroup G), Monoid.IsTorsion { x // x ‚àà H }\"},\n {\"role\": \"user\", \"content\": \"Every group is a torsion monoid.\"}]"}
{"text":"Every finite simple group has prime order.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a product lies in the prime ideal, then at least one element lies in the prime ideal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : Semiring Œ±] {I : Ideal Œ±} [self : Ideal.IsPrime I] {x y : Œ±}, x * y ‚àà I ‚Üí x ‚àà I ‚à® y ‚àà I\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\", \"content\": \"Set.InjOn Nat.factorization {x | x ‚â† 0}\"},\n {\"role\": \"user\", \"content\": \"Finite groups are torsion groups. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [self : LinearOrderedCommGroupWithZero Œ±] (a : Œ±), a ‚â† 0 ‚Üí a * a‚Åª¬π = 1\"},\n {\"role\": \"user\", \"content\": \"A minimal polynomial is prime. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\\n  IsIntegral A x ‚Üí Prime (minpoly A x)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Inverses of elements of finite additive order have finite additive order.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G] {x : G}, IsOfFinAddOrder x ‚Üí IsOfFinAddOrder (-x)\"},\n {\"role\": \"user\",\n  \"content\": \"The image of an element of finite order has finite order. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_2} {H : Type u_1} [inst : Monoid G] [inst_1 : Monoid H] (f : G ‚Üí* H) {x : G},\\n  IsOfFinOrder x ‚Üí IsOfFinOrder (‚Üëf x)\"},\n {\"role\": \"user\",\n  \"content\": \"finite p-groups with different p have coprime orders \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_2} [inst : Group G] {G‚ÇÇ : Type u_1} [inst_1 : Group G‚ÇÇ] (p‚ÇÅ p‚ÇÇ : ‚Ñï) [hp‚ÇÅ : Fact (Nat.Prime p‚ÇÅ)]\\n  [hp‚ÇÇ : Fact (Nat.Prime p‚ÇÇ)],\\n  p‚ÇÅ ‚â† p‚ÇÇ ‚Üí\\n    ‚àÄ (H‚ÇÅ : Subgroup G) (H‚ÇÇ : Subgroup G‚ÇÇ) [inst_2 : Fintype { x // x ‚àà H‚ÇÅ }] [inst_3 : Fintype { x // x ‚àà H‚ÇÇ }],\\n      IsPGroup p‚ÇÅ { x // x ‚àà H‚ÇÅ } ‚Üí\\n        IsPGroup p‚ÇÇ { x // x ‚àà H‚ÇÇ } ‚Üí Nat.coprime (Fintype.card { x // x ‚àà H‚ÇÅ }) (Fintype.card { x // x ‚àà H‚ÇÇ })\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A group element has finite additive order iff its order is positive.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : AddMonoid G] {x : G}, 0 < addOrderOf x ‚Üî IsOfFinAddOrder x\"},\n {\"role\": \"user\", \"content\": \"Any finitely generated ideal is principal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} [inst : CommRing R] [self : IsBezout R] (I : Ideal R), Ideal.FG I ‚Üí Submodule.IsPrincipal I\"},\n {\"role\": \"user\",\n  \"content\": \"A group element has finite order iff its order is positive. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x ‚Üî IsOfFinOrder x\"},\n {\"role\": \"user\",\n  \"content\": \"Inverses of elements of finite order have finite order. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x‚Åª¬π ‚Üî IsOfFinOrder x\"},\n {\"role\": \"user\", \"content\": \"A finite field has prime power cardinality. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : Fintype Œ±] [inst_1 : Field Œ±], IsPrimePow (Fintype.card Œ±)\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is cyclic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)], Fintype.card Œ± = p ‚Üí IsCyclic Œ±\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is cyclic.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsAddCyclic Œ±\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is simple. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsSimpleGroup Œ±\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is simple.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsSimpleAddGroup Œ±\"},\n {\"role\": \"user\", \"content\": \"Every finite simple group has prime order.\"}]"}
{"text":"Every finite group is simple.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"Finite additive groups are additive torsion groups.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G] [inst_1 : Finite G], AddMonoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A subgroup is finitely generated if and only if it is finitely generated as a submonoid. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] (P : Subgroup G), Subgroup.FG P ‚Üî Submonoid.FG P.toSubmonoid\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any `K`-algebra module that is 1-dimensional over `K` is simple. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {A : Type u_1}\\n  [inst_3 : Semiring A] [inst_4 : Module A V] [inst_5 : SMul K A] [inst_6 : IsScalarTower K A V],\\n  FiniteDimensional.finrank K V = 1 ‚Üí IsSimpleOrder (Submodule A V)\"},\n {\"role\": \"user\", \"content\": \"A simple Lie algebra is semisimple. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (R : Type u) (L : Type v) [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L]\\n  [h : LieAlgebra.IsSimple R L], LieAlgebra.IsSemisimple R L\"},\n {\"role\": \"user\", \"content\": \"A semisimple Abelian Lie algebra is trivial. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (R : Type u) (L : Type v) [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L]\\n  [inst : LieAlgebra.IsSemisimple R L] [h : IsLieAbelian L], Subsingleton L\"},\n {\"role\": \"user\", \"content\": \"Every finite measure is œÉ-finite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} {_m0 : MeasurableSpace Œ±} (Œº : MeasureTheory.Measure Œ±) [inst : MeasureTheory.IsFiniteMeasure Œº],\\n  MeasureTheory.SigmaFinite Œº\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any `k`-algebra module which is 1-dimensional over `k` is simple. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_2} [inst : Ring R] {k : Type u_1} [inst_1 : Field k] [inst_2 : Algebra k R] {V : ModuleCat R},\\n  FiniteDimensional.finrank k ‚ÜëV = 1 ‚Üí CategoryTheory.Simple V\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (G : Type u_1) [inst : Group G] [inst_1 : Finite ‚Üë(commutatorSet G)], Finite { x // x ‚àà commutator G }\"},\n {\"role\": \"user\",\n  \"content\": \"A finite group action is always properly discontinuous.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œì : Type u_1} [inst : AddGroup Œì] {T : Type u_2} [inst_1 : TopologicalSpace T] [inst_2 : AddAction Œì T]\\n  [inst_3 : Finite Œì], ProperlyDiscontinuousVAdd Œì T\"},\n {\"role\": \"user\",\n  \"content\": \"A finite group action is always properly discontinuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œì : Type u_1} [inst : Group Œì] {T : Type u_2} [inst_1 : TopologicalSpace T] [inst_2 : MulAction Œì T]\\n  [inst_3 : Finite Œì], ProperlyDiscontinuousSMul Œì T\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every finite subset of a linearly independent set is linearly independent. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (s : Set M),\\n  LinearIndependent R Subtype.val ‚Üí ‚àÄ (t : Finset ‚Üës), LinearIndependent R Subtype.val\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a finite group is the direct product of its Sylow groups, it is nilpotent \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [hG : Group G] [inst : Fintype G],\\n  ((p : { x // x ‚àà (Nat.factorization (Fintype.card G)).support }) ‚Üí (P : Sylow (‚Üëp) G) ‚Üí { x // x ‚àà ‚ÜëP }) ‚âÉ* G ‚Üí\\n    Group.IsNilpotent G\"},\n {\"role\": \"user\", \"content\": \"Finite groups are torsion groups. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A group is finitely generated if and only if it is finitely generated as a monoid. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {G : Type u_1} [inst : Group G], Group.FG G ‚Üî Monoid.FG G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every finite subset of an algebraically independent set is algebraically independent. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_2} {A : Type u_1} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] (s : Set A),\\n  AlgebraicIndependent R Subtype.val ‚Üí ‚àÄ (t : Finset ‚Üës), AlgebraicIndependent R Subtype.val\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [self : LinearOrderedCommGroupWithZero Œ±] (a : Œ±), a ‚â† 0 ‚Üí a * a‚Åª¬π = 1\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is cyclic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)], Fintype.card Œ± = p ‚Üí IsCyclic Œ±\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is cyclic.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsAddCyclic Œ±\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is simple. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsSimpleGroup Œ±\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is simple.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsSimpleAddGroup Œ±\"},\n {\"role\": \"user\", \"content\": \"Every finite group is simple.\"}]"}
{"text":"Every finite group has prime order.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The image of an element of finite additive order has finite additive order.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_2} {H : Type u_1} [inst : AddMonoid G] [inst_1 : AddMonoid H] (f : G ‚Üí+ H) {x : G},\\n  IsOfFinAddOrder x ‚Üí IsOfFinAddOrder (‚Üëf x)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Inverses of elements of finite additive order have finite additive order.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G] {x : G}, IsOfFinAddOrder x ‚Üí IsOfFinAddOrder (-x)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a product lies in the prime ideal, then at least one element lies in the prime ideal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : Semiring Œ±] {I : Ideal Œ±} [self : Ideal.IsPrime I] {x y : Œ±}, x * y ‚àà I ‚Üí x ‚àà I ‚à® y ‚àà I\"},\n {\"role\": \"user\", \"content\": \"Finite groups are torsion groups. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [self : LinearOrderedCommGroupWithZero Œ±] (a : Œ±), a ‚â† 0 ‚Üí a * a‚Åª¬π = 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A group element has finite additive order iff its order is positive.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : AddMonoid G] {x : G}, 0 < addOrderOf x ‚Üî IsOfFinAddOrder x\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\", \"content\": \"Set.InjOn Nat.factorization {x | x ‚â† 0}\"},\n {\"role\": \"user\",\n  \"content\": \"The image of an element of finite order has finite order. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_2} {H : Type u_1} [inst : Monoid G] [inst_1 : Monoid H] (f : G ‚Üí* H) {x : G},\\n  IsOfFinOrder x ‚Üí IsOfFinOrder (‚Üëf x)\"},\n {\"role\": \"user\",\n  \"content\": \"finite p-groups with different p have coprime orders \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_2} [inst : Group G] {G‚ÇÇ : Type u_1} [inst_1 : Group G‚ÇÇ] (p‚ÇÅ p‚ÇÇ : ‚Ñï) [hp‚ÇÅ : Fact (Nat.Prime p‚ÇÅ)]\\n  [hp‚ÇÇ : Fact (Nat.Prime p‚ÇÇ)],\\n  p‚ÇÅ ‚â† p‚ÇÇ ‚Üí\\n    ‚àÄ (H‚ÇÅ : Subgroup G) (H‚ÇÇ : Subgroup G‚ÇÇ) [inst_2 : Fintype { x // x ‚àà H‚ÇÅ }] [inst_3 : Fintype { x // x ‚àà H‚ÇÇ }],\\n      IsPGroup p‚ÇÅ { x // x ‚àà H‚ÇÅ } ‚Üí\\n        IsPGroup p‚ÇÇ { x // x ‚àà H‚ÇÇ } ‚Üí Nat.coprime (Fintype.card { x // x ‚àà H‚ÇÅ }) (Fintype.card { x // x ‚àà H‚ÇÇ })\"},\n {\"role\": \"user\", \"content\": \"Any finitely generated ideal is principal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} [inst : CommRing R] [self : IsBezout R] (I : Ideal R), Ideal.FG I ‚Üí Submodule.IsPrincipal I\"},\n {\"role\": \"user\",\n  \"content\": \"A group element has finite order iff its order is positive. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x ‚Üî IsOfFinOrder x\"},\n {\"role\": \"user\",\n  \"content\": \"Inverses of elements of finite order have finite order. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x‚Åª¬π ‚Üî IsOfFinOrder x\"},\n {\"role\": \"user\", \"content\": \"A finite field has prime power cardinality. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : Fintype Œ±] [inst_1 : Field Œ±], IsPrimePow (Fintype.card Œ±)\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is simple.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsSimpleAddGroup Œ±\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is simple. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsSimpleGroup Œ±\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is cyclic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)], Fintype.card Œ± = p ‚Üí IsCyclic Œ±\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is cyclic.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsAddCyclic Œ±\"},\n {\"role\": \"user\", \"content\": \"Every finite group has prime order.\"}]"}
{"text":"Every set has Lebesgue measure zero.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In the space `Œπ ‚Üí ‚Ñù`, the Hausdorff measure coincides exactly with the Lebesgue measure. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œπ : Type u_1} [inst : Fintype Œπ], MeasureTheory.Measure.hausdorffMeasure ‚Üë(Fintype.card Œπ) = MeasureTheory.volume\"},\n {\"role\": \"user\", \"content\": \"The empty set has zero diameter \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±], Metric.diam ‚àÖ = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The symmetric difference of two Hahn decompositions has measure zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : MeasurableSpace Œ±] {s : MeasureTheory.SignedMeasure Œ±} {i j : Set Œ±},\\n  MeasurableSet i ‚Üí\\n    MeasurableSet j ‚Üí\\n      MeasureTheory.VectorMeasure.restrict 0 i ‚â§ MeasureTheory.VectorMeasure.restrict s i ‚àß\\n          MeasureTheory.VectorMeasure.restrict s i·∂ú ‚â§ MeasureTheory.VectorMeasure.restrict 0 i·∂ú ‚Üí\\n        MeasureTheory.VectorMeasure.restrict 0 j ‚â§ MeasureTheory.VectorMeasure.restrict s j ‚àß\\n            MeasureTheory.VectorMeasure.restrict s j·∂ú ‚â§ MeasureTheory.VectorMeasure.restrict 0 j·∂ú ‚Üí\\n          ‚Üës (i ‚àÜ j) = 0 ‚àß ‚Üës (i·∂ú ‚àÜ j·∂ú) = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In the space `‚Ñù √ó ‚Ñù`, the Hausdorff measure coincides exactly with the Lebesgue measure. \"},\n {\"role\": \"assistant\",\n  \"content\": \"MeasureTheory.Measure.hausdorffMeasure 2 = MeasureTheory.volume\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In the space `‚Ñù`, the Hausdorff measure coincides exactly with the Lebesgue measure. \"},\n {\"role\": \"assistant\",\n  \"content\": \"MeasureTheory.Measure.hausdorffMeasure 1 = MeasureTheory.volume\"},\n {\"role\": \"user\",\n  \"content\": \"The Hausdorff distance between a set and itself is zero \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±}, Metric.hausdorffDist s s = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A nonempty set is scaled by zero to the singleton set containing 0. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : Zero Œ±] [inst_1 : Zero Œ≤] [inst_2 : SMulWithZero Œ± Œ≤] [inst_3 : DecidableEq Œ≤]\\n  {s : Finset Œ≤}, Finset.Nonempty s ‚Üí 0 ‚Ä¢ s = 0\"},\n {\"role\": \"user\", \"content\": \"The empty set is collinear. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (k : Type u_1) {V : Type u_2} (P : Type u_3) [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P], Collinear k ‚àÖ\"},\n {\"role\": \"user\",\n  \"content\": \"Haar measure of the frontier of a convex set is zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ‚Ñù E] (Œº : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Œº] {s : Set E}, Convex ‚Ñù s ‚Üí ‚Üë‚ÜëŒº (frontier s) = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A differentiable function maps sets of measure zero to sets of measure zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] [inst_2 : FiniteDimensional ‚Ñù E] {s : Set E}\\n  {f : E ‚Üí E} [inst_3 : MeasurableSpace E] [inst_4 : BorelSpace E] (Œº : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Œº], DifferentiableOn ‚Ñù f s ‚Üí ‚Üë‚ÜëŒº s = 0 ‚Üí ‚Üë‚ÜëŒº (f '' s) = 0\"},\n {\"role\": \"user\", \"content\": \"All convergents of `0` are zero. \"},\n {\"role\": \"assistant\", \"content\": \"‚àÄ (n : ‚Ñï), Real.convergent 0 n = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If the total masses of finite measures tend to zero, then the measures tend to zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ© : Type u_2} [inst : MeasurableSpace Œ©] [inst_1 : TopologicalSpace Œ©] [inst_2 : OpensMeasurableSpace Œ©]\\n  {Œ≥ : Type u_1} {F : Filter Œ≥} {Œºs : Œ≥ ‚Üí MeasureTheory.FiniteMeasure Œ©},\\n  Filter.Tendsto (fun i => MeasureTheory.FiniteMeasure.mass (Œºs i)) F (nhds 0) ‚Üí Filter.Tendsto Œºs F (nhds 0)\"},\n {\"role\": \"user\", \"content\": \"A strict vector subspace has measure zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ‚Ñù E] (Œº : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Œº] (s : Submodule ‚Ñù E), s ‚â† ‚ä§ ‚Üí ‚Üë‚ÜëŒº ‚Üës = 0\"},\n {\"role\": \"user\", \"content\": \"A strict affine subspace has measure zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ‚Ñù E] (Œº : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Œº] (s : AffineSubspace ‚Ñù E), s ‚â† ‚ä§ ‚Üí ‚Üë‚ÜëŒº ‚Üës = 0\"},\n {\"role\": \"user\",\n  \"content\": \"The set of Liouville numbers has Lebesgue measure zero. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚Üë‚ÜëMeasureTheory.volume {x | Liouville x} = 0\"},\n {\"role\": \"user\", \"content\": \"Every set has Lebesgue measure zero.\"}]"}
{"text":"If a topological space is compact, then every subset is compact.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"The product of two compact spaces is compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] [inst_2 : CompactSpace Œ±]\\n  [inst_3 : CompactSpace Œ≤], CompactSpace (Œ± √ó Œ≤)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A subspace is dense iff its topological closure is the entire space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : TopologicalSpace M] [inst_2 : AddCommMonoid M]\\n  [inst_3 : Module R M] [inst_4 : ContinuousConstSMul R M] [inst_5 : ContinuousAdd M] {s : Submodule R M},\\n  Dense ‚Üës ‚Üî Submodule.topologicalClosure s = ‚ä§\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a nonempty locally compact space, there exists a compact set with nonempty interior. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : LocallyCompactSpace Œ±] [inst_2 : Nonempty Œ±],\\n  Nonempty (TopologicalSpace.PositiveCompacts Œ±)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The intersection of a compact set and a closed set is a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s t : Set Œ±}, IsCompact s ‚Üí IsClosed t ‚Üí IsCompact (s ‚à© t)\"},\n {\"role\": \"user\", \"content\": \"In a `T2Space`, every compact set is closed. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : T2Space Œ±] {s : Set Œ±}, IsCompact s ‚Üí IsClosed s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a locally compact T‚ÇÇ space, every compact set has an open neighborhood with compact closure.\\n\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LocallyCompactSpace Œ±] [inst_2 : T2Space Œ±] {K : Set Œ±},\\n  IsCompact K ‚Üí ‚àÉ V, IsOpen V ‚àß K ‚äÜ V ‚àß IsCompact (closure V)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The intersection of two open compact subsets of a quasi-separated space is compact.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [self : QuasiSeparatedSpace Œ±] (U V : Set Œ±),\\n  IsOpen U ‚Üí IsCompact U ‚Üí IsOpen V ‚Üí IsCompact V ‚Üí IsCompact (U ‚à© V)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The intersection of a closed set and a compact set is a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s t : Set Œ±}, IsCompact t ‚Üí IsClosed s ‚Üí IsCompact (s ‚à© t)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a locally compact space every point has a compact neighborhood. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LocallyCompactSpace Œ±] (x : Œ±), ‚àÉ K, IsCompact K ‚àß K ‚àà nhds x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For any topological space `X`, its one point compactification is a compact space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X)\"},\n {\"role\": \"user\",\n  \"content\": \"A closed subset of a compact set is a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s t : Set Œ±}, IsCompact s ‚Üí IsClosed t ‚Üí t ‚äÜ s ‚Üí IsCompact t\"},\n {\"role\": \"user\", \"content\": \"In a Noetherian space, all sets are compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace.NoetherianSpace Œ±] (s : Set Œ±), IsCompact s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a locally compact space, every compact set is contained in the interior of a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LocallyCompactSpace Œ±] {K : Set Œ±},\\n  IsCompact K ‚Üí ‚àÉ K', IsCompact K' ‚àß K ‚äÜ interior K'\"},\n {\"role\": \"user\",\n  \"content\": \"In a compact space, the type of closed subsets is compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : EMetricSpace Œ±] [inst_1 : CompactSpace Œ±], CompactSpace (TopologicalSpace.Closeds Œ±)\"},\n {\"role\": \"user\", \"content\": \"The underlying topological space is compact.\"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ (self : CompHaus), CompactSpace ‚Üëself.toTop\"},\n {\"role\": \"user\", \"content\": \"Finite topological spaces are compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : Finite Œ±], CompactSpace Œ±\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a topological space is compact, then every subset is compact.\"}]"}
{"text":"Every set that is Lebesgue measurable but not Borel measurable has Lebesgue measure zero.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a set is a right-neighborhood of all of its points, then it is measurable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : MeasurableSpace Œ±] [inst_2 : BorelSpace Œ±]\\n  [inst_3 : LinearOrder Œ±] [inst_4 : OrderTopology Œ±] [inst_5 : TopologicalSpace.SecondCountableTopology Œ±] {s : Set Œ±},\\n  (‚àÄ (x : Œ±), x ‚àà s ‚Üí s ‚àà nhdsWithin x (Set.Ioi x)) ‚Üí MeasurableSet s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A nonempty set is scaled by zero to the singleton set containing 0. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : Zero Œ±] [inst_1 : Zero Œ≤] [inst_2 : SMulWithZero Œ± Œ≤] [inst_3 : DecidableEq Œ≤]\\n  {s : Finset Œ≤}, Finset.Nonempty s ‚Üí 0 ‚Ä¢ s = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If the total masses of finite measures tend to zero, then the measures tend to zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ© : Type u_2} [inst : MeasurableSpace Œ©] [inst_1 : TopologicalSpace Œ©] [inst_2 : OpensMeasurableSpace Œ©]\\n  {Œ≥ : Type u_1} {F : Filter Œ≥} {Œºs : Œ≥ ‚Üí MeasureTheory.FiniteMeasure Œ©},\\n  Filter.Tendsto (fun i => MeasureTheory.FiniteMeasure.mass (Œºs i)) F (nhds 0) ‚Üí Filter.Tendsto Œºs F (nhds 0)\"},\n {\"role\": \"user\", \"content\": \"A strict vector subspace has measure zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ‚Ñù E] (Œº : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Œº] (s : Submodule ‚Ñù E), s ‚â† ‚ä§ ‚Üí ‚Üë‚ÜëŒº ‚Üës = 0\"},\n {\"role\": \"user\", \"content\": \"A strict affine subspace has measure zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ‚Ñù E] (Œº : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Œº] (s : AffineSubspace ‚Ñù E), s ‚â† ‚ä§ ‚Üí ‚Üë‚ÜëŒº ‚Üës = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Left invariant Borel measures on an additive measurable group are unique (up to a scalar). \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : AddGroup G] [inst_2 : MeasurableAdd‚ÇÇ G]\\n  (Œº ŒΩ : MeasureTheory.Measure G) [inst_3 : MeasureTheory.SigmaFinite ŒΩ] [inst_4 : MeasureTheory.SigmaFinite Œº]\\n  {s : Set G} [inst_5 : MeasurableNeg G] [inst_6 : MeasureTheory.Measure.IsAddLeftInvariant Œº]\\n  [inst_7 : MeasureTheory.Measure.IsAddLeftInvariant ŒΩ],\\n  MeasurableSet s ‚Üí ‚Üë‚ÜëŒΩ s ‚â† 0 ‚Üí ‚Üë‚ÜëŒΩ s ‚â† ‚ä§ ‚Üí Œº = (‚Üë‚ÜëŒº s / ‚Üë‚ÜëŒΩ s) ‚Ä¢ ŒΩ\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A differentiable function maps sets of measure zero to sets of measure zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] [inst_2 : FiniteDimensional ‚Ñù E] {s : Set E}\\n  {f : E ‚Üí E} [inst_3 : MeasurableSpace E] [inst_4 : BorelSpace E] (Œº : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure Œº], DifferentiableOn ‚Ñù f s ‚Üí ‚Üë‚ÜëŒº s = 0 ‚Üí ‚Üë‚ÜëŒº (f '' s) = 0\"},\n {\"role\": \"user\",\n  \"content\": \"In a `BorelSpace` all open sets are measurable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : MeasurableSpace Œ±] [inst_2 : BorelSpace Œ±],\\n  OpensMeasurableSpace Œ±\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Left invariant Borel measures on a measurable group are unique (up to a scalar). \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Group G] [inst_2 : MeasurableMul‚ÇÇ G]\\n  (Œº ŒΩ : MeasureTheory.Measure G) [inst_3 : MeasureTheory.SigmaFinite ŒΩ] [inst_4 : MeasureTheory.SigmaFinite Œº]\\n  {s : Set G} [inst_5 : MeasurableInv G] [inst_6 : MeasureTheory.Measure.IsMulLeftInvariant Œº]\\n  [inst_7 : MeasureTheory.Measure.IsMulLeftInvariant ŒΩ],\\n  MeasurableSet s ‚Üí ‚Üë‚ÜëŒΩ s ‚â† 0 ‚Üí ‚Üë‚ÜëŒΩ s ‚â† ‚ä§ ‚Üí Œº = (‚Üë‚ÜëŒº s / ‚Üë‚ÜëŒΩ s) ‚Ä¢ ŒΩ\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For the outer measure coming from a content, all Borel sets are measurable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type w} [inst : TopologicalSpace G] (Œº : MeasureTheory.Content G) [inst_1 : T2Space G] [S : MeasurableSpace G]\\n  [inst_2 : BorelSpace G], S ‚â§ MeasureTheory.OuterMeasure.caratheodory (MeasureTheory.Content.outerMeasure Œº)\"},\n {\"role\": \"user\",\n  \"content\": \"The set of Liouville numbers has Lebesgue measure zero. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚Üë‚ÜëMeasureTheory.volume {x | Liouville x} = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every set that is Lebesgue measurable but not Borel measurable has Lebesgue measure zero.\"}]"}
{"text":"A finitely-presented group containing a torsion element is finite.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"A module with a finite ring of scalars is additively torsion. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (R : Type u_1) (M : Type u_2) [inst : AddCommMonoid M] [inst_1 : Ring R] [inst_2 : Finite R] [inst_3 : Module R M],\\n  AddMonoid.IsTorsion M\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The group exponent exists for any bounded additive torsion group.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G],\\n  AddMonoid.IsTorsion G ‚Üí Set.Finite (Set.range fun g => addOrderOf g) ‚Üí AddMonoid.ExponentExists G\"},\n {\"role\": \"user\",\n  \"content\": \"A nontrivial torsion group is not torsion-free. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G ‚Üí ¬¨Monoid.IsTorsionFree G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Subgroups of additive torsion groups are additive torsion groups.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G], AddMonoid.IsTorsion G ‚Üí ‚àÄ (H : AddSubgroup G), AddMonoid.IsTorsion { x // x ‚àà H }\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The quotient of a finitely presented algebra by a finitely generated ideal is finitely\\npresented. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type w‚ÇÅ} {A : Type w‚ÇÇ} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] {I : Ideal A},\\n  Ideal.FG I ‚Üí Algebra.FinitePresentation R A ‚Üí Algebra.FinitePresentation R (A ‚ß∏ I)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The image of a surjective torsion group homomorphism is torsion. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H] {f : G ‚Üí* H},\\n  Function.Surjective ‚Üëf ‚Üí Monoid.IsTorsion G ‚Üí Monoid.IsTorsion H\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Quotienting a group by its additive torsion subgroup yields an additive torsion free group.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (G : Type u_1) [inst : AddCommGroup G], AddMonoid.IsTorsionFree (G ‚ß∏ AddCommGroup.torsion G)\"},\n {\"role\": \"user\",\n  \"content\": \"Direct products of torsion free groups are torsion free. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ∑ : Type u_1} {Gs : Œ∑ ‚Üí Type u_2} [inst : (i : Œ∑) ‚Üí Group (Gs i)],\\n  (‚àÄ (i : Œ∑), Monoid.IsTorsionFree (Gs i)) ‚Üí Monoid.IsTorsionFree ((i : Œ∑) ‚Üí Gs i)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A group is finitely generated if and only if it is finitely generated as a monoid. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {G : Type u_1} [inst : Group G], Group.FG G ‚Üî Monoid.FG G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Quotienting a group by its torsion subgroup yields a torsion free group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G ‚ß∏ CommGroup.torsion G)\"},\n {\"role\": \"user\",\n  \"content\": \"The group exponent exists for any bounded torsion group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G],\\n  Monoid.IsTorsion G ‚Üí Set.Finite (Set.range fun g => orderOf g) ‚Üí Monoid.ExponentExists G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Subgroups of additive torsion-free groups are additively torsion-free.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G],\\n  AddMonoid.IsTorsionFree G ‚Üí ‚àÄ (H : AddSubgroup G), AddMonoid.IsTorsionFree { x // x ‚àà H }\"},\n {\"role\": \"user\",\n  \"content\": \"Subgroups of torsion groups are torsion groups. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ‚Üí ‚àÄ (H : Subgroup G), Monoid.IsTorsion { x // x ‚àà H }\"},\n {\"role\": \"user\",\n  \"content\": \"If a group exponent exists, the group is torsion. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G], Monoid.ExponentExists G ‚Üí Monoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\": \"Finite additive groups are additive torsion groups.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G] [inst_1 : Finite G], AddMonoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\": \"Additive torsion groups are closed under extensions.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} {H : Type u_2} [inst : AddGroup G] {N : AddSubgroup G} [inst_1 : AddGroup H] {f : G ‚Üí+ H},\\n  N = AddMonoidHom.ker f ‚Üí AddMonoid.IsTorsion H ‚Üí AddMonoid.IsTorsion { x // x ‚àà N } ‚Üí AddMonoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\": \"Subgroups of torsion-free groups are torsion-free. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G ‚Üí ‚àÄ (H : Subgroup G), Monoid.IsTorsionFree { x // x ‚àà H }\"},\n {\"role\": \"user\", \"content\": \"Torsion groups are closed under extensions. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G ‚Üí* H},\\n  N = MonoidHom.ker f ‚Üí Monoid.IsTorsion H ‚Üí Monoid.IsTorsion { x // x ‚àà N } ‚Üí Monoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\": \"A finitely presented algebra is of finite type. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type w‚ÇÅ} {A : Type w‚ÇÇ} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A],\\n  Algebra.FinitePresentation R A ‚Üí Algebra.FiniteType R A\"},\n {\"role\": \"user\", \"content\": \"Finite groups are torsion groups. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A finitely-presented group containing a torsion element is finite.\"}]"}
{"text":"If every point of a subset of a topological space is contained in some closed set, the subset itself is closed.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The upper closure of a finite set is closed in the lower topology. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : LowerTopology Œ±] {s : Set Œ±},\\n  Set.Finite s ‚Üí IsClosed ‚Üë(upperClosure s)\"},\n {\"role\": \"user\", \"content\": \"In a `T2Space`, every compact set is closed. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : T2Space Œ±] {s : Set Œ±}, IsCompact s ‚Üí IsClosed s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a Noetherian space, every closed set is a finite union of irreducible closed sets. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace.NoetherianSpace Œ±] {s : Set Œ±},\\n  IsClosed s ‚Üí\\n    ‚àÉ S, Set.Finite S ‚àß (‚àÄ (t : Set Œ±), t ‚àà S ‚Üí IsClosed t) ‚àß (‚àÄ (t : Set Œ±), t ‚àà S ‚Üí IsIrreducible t) ‚àß s = ‚ãÉ‚ÇÄ S\"},\n {\"role\": \"user\",\n  \"content\": \"The set of fixed points of a continuous map is a closed set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : T2Space Œ±] {f : Œ± ‚Üí Œ±},\\n  Continuous f ‚Üí IsClosed (Function.fixedPoints f)\"},\n {\"role\": \"user\", \"content\": \"The underlying topological space is compact.\"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ (self : CompHaus), CompactSpace ‚Üëself.toTop\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a sequential space, a set is closed iff it's sequentially closed. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : SequentialSpace X] {M : Set X}, IsSeqClosed M ‚Üî IsClosed M\"},\n {\"role\": \"user\",\n  \"content\": \"In a sequential space, a sequentially closed set is closed. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : SequentialSpace X] {s : Set X}, IsSeqClosed s ‚Üí IsClosed s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The intersection of a closed set and a compact set is a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s t : Set Œ±}, IsCompact t ‚Üí IsClosed s ‚Üí IsCompact (s ‚à© t)\"},\n {\"role\": \"user\", \"content\": \"Finite topological spaces are compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : Finite Œ±], CompactSpace Œ±\"},\n {\"role\": \"user\", \"content\": \"A finite-dimensional subspace is closed. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {ùïú : Type u} [inst : NontriviallyNormedField ùïú] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ùïú E] [inst_3 : CompleteSpace ùïú] (s : Submodule ùïú E)\\n  [inst_4 : FiniteDimensional ùïú { x // x ‚àà s }], IsClosed ‚Üës\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A subspace is dense iff its topological closure is the entire space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : TopologicalSpace M] [inst_2 : AddCommMonoid M]\\n  [inst_3 : Module R M] [inst_4 : ContinuousConstSMul R M] [inst_5 : ContinuousAdd M] {s : Submodule R M},\\n  Dense ‚Üës ‚Üî Submodule.topologicalClosure s = ‚ä§\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The intersection of a compact set and a closed set is a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s t : Set Œ±}, IsCompact s ‚Üí IsClosed t ‚Üí IsCompact (s ‚à© t)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a topological vector space, the closure of a convex set is convex. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {ùïú : Type u_2} {E : Type u_1} [inst : LinearOrderedField ùïú] [inst_1 : AddCommGroup E] [inst_2 : Module ùïú E]\\n  [inst_3 : TopologicalSpace E] [inst_4 : TopologicalAddGroup E] [inst_5 : ContinuousConstSMul ùïú E] {s : Set E},\\n  Convex ùïú s ‚Üí Convex ùïú (closure s)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a locally compact space, every compact set is contained in the interior of a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LocallyCompactSpace Œ±] {K : Set Œ±},\\n  IsCompact K ‚Üí ‚àÉ K', IsCompact K' ‚àß K ‚äÜ interior K'\"},\n {\"role\": \"user\",\n  \"content\": \"In a compact space, the type of closed subsets is compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : EMetricSpace Œ±] [inst_1 : CompactSpace Œ±], CompactSpace (TopologicalSpace.Closeds Œ±)\"},\n {\"role\": \"user\",\n  \"content\": \"Subsets of a given closed subset form a closed set \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : EMetricSpace Œ±] {s : Set Œ±}, IsClosed s ‚Üí IsClosed {t | ‚Üët ‚äÜ s}\"},\n {\"role\": \"user\",\n  \"content\": \"A closed subset of a compact set is a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s t : Set Œ±}, IsCompact s ‚Üí IsClosed t ‚Üí t ‚äÜ s ‚Üí IsCompact t\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If every point of a subset of a topological space is contained in some closed set, the subset itself is closed.\"}]"}
{"text":"A topological space $X$ is Hausdorff if and only if the diagonal map is an open map from $X$ to $X √ó X$.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Cofiltered limits of nonempty compact Hausdorff spaces are nonempty topological spaces.\\n\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {J : Type u} [inst : CategoryTheory.SmallCategory J] (F : CategoryTheory.Functor J TopCatMax)\\n  [inst_1 : CategoryTheory.IsCofilteredOrEmpty J] [inst_2 : ‚àÄ (j : J), Nonempty ‚Üë(F.obj j)]\\n  [inst_3 : ‚àÄ (j : J), CompactSpace ‚Üë(F.obj j)] [inst_4 : ‚àÄ (j : J), T2Space ‚Üë(F.obj j)],\\n  Nonempty ‚Üë(TopCat.limitCone F).pt\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a complete space, the type of closed subsets is complete for the\\nHausdorff edistance. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : EMetricSpace Œ±] [inst_1 : CompleteSpace Œ±], CompleteSpace (TopologicalSpace.Closeds Œ±)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If the codomain of an injective continuous function is a Hausdorff space, then so is its\\ndomain. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] [inst_2 : T2Space Œ≤] {f : Œ± ‚Üí Œ≤},\\n  Function.Injective f ‚Üí Continuous f ‚Üí T2Space Œ±\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For any topological space `X`, its one point compactification is a compact space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A locally compact Hausdorff totally disconnected space has a basis with clopen elements. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {H : Type u_1} [inst : TopologicalSpace H] [inst_1 : LocallyCompactSpace H] [inst_2 : T2Space H]\\n  [inst_3 : TotallyDisconnectedSpace H], TopologicalSpace.IsTopologicalBasis {s | IsClopen s}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A locally compact Hausdorff space is totally disconnected\\nif and only if it is totally separated. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {H : Type u_1} [inst : TopologicalSpace H] [inst_1 : LocallyCompactSpace H] [inst_2 : T2Space H],\\n  TotallyDisconnectedSpace H ‚Üî TotallySeparatedSpace H\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A linear order with order topology is a completely normal Hausdorff topological space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {X : Type u_1} [inst : LinearOrder X] [inst_1 : TopologicalSpace X] [inst : OrderTopology X], T5Space X\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any continuous bijection of compact Hausdorff spaces is an isomorphism. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {X Y : CompHaus} (f : X ‚ü∂ Y), Function.Bijective ‚Üëf ‚Üí CategoryTheory.IsIso f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A continuous injective map from a compact space to a Hausdorff space is a closed embedding. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] [inst_2 : CompactSpace Œ±]\\n  [inst_3 : T2Space Œ≤] {f : Œ± ‚Üí Œ≤}, Continuous f ‚Üí Function.Injective f ‚Üí ClosedEmbedding f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any continuous function on compact Hausdorff spaces is a closed map. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {X Y : CompHaus} (f : X ‚ü∂ Y), IsClosedMap ‚Üëf\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every two points in a Hausdorff space admit disjoint open neighbourhoods. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [self : T2Space Œ±] (x y : Œ±),\\n  x ‚â† y ‚Üí ‚àÉ u v, IsOpen u ‚àß IsOpen v ‚àß x ‚àà u ‚àß y ‚àà v ‚àß Disjoint u v\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A continuous surjective map from a compact space to a Hausdorff space is a quotient map. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] [inst_2 : CompactSpace Œ±]\\n  [inst_3 : T2Space Œ≤] {f : Œ± ‚Üí Œ≤}, Function.Surjective f ‚Üí Continuous f ‚Üí QuotientMap f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A continuous map from a compact space to a Hausdorff space is a closed map. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] [inst_2 : CompactSpace Œ±]\\n  [inst_3 : T2Space Œ≤] {f : Œ± ‚Üí Œ≤}, Continuous f ‚Üí IsClosedMap f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A topological space $X$ is Hausdorff if and only if the diagonal map is an open map from $X$ to $X √ó X$.\"}]"}
{"text":"Any finite order element in a group is equal to the identity.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A finite subgroup of the unit group of an integral domain is cyclic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\\n  (f : G ‚Üí* R), Function.Injective ‚Üëf ‚Üí IsCyclic G\"},\n {\"role\": \"user\", \"content\": \"Any element commutes with itself. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {S : Type u_1} [inst : Mul S] (a : S), Commute a a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Commuting elements of finite order are closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Monoid G] {x y : G}, Commute x y ‚Üí IsOfFinOrder x ‚Üí IsOfFinOrder y ‚Üí IsOfFinOrder (x * y)\"},\n {\"role\": \"user\", \"content\": \"Any element commutes with itself.\"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {S : Type u_1} [inst : Add S] (a : S), AddCommute a a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Inverses of elements of finite additive order\\nhave finite additive order.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G] {x : G}, IsOfFinAddOrder (-x) ‚Üî IsOfFinAddOrder x\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is simple.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsSimpleAddGroup Œ±\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is simple. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsSimpleGroup Œ±\"},\n {\"role\": \"user\",\n  \"content\": \"Elements of finite additive order are closed under addition.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : AddCommMonoid G] {x y : G}, IsOfFinAddOrder x ‚Üí IsOfFinAddOrder y ‚Üí IsOfFinAddOrder (x + y)\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is cyclic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)], Fintype.card Œ± = p ‚Üí IsCyclic Œ±\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is cyclic.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsAddCyclic Œ±\"},\n {\"role\": \"user\",\n  \"content\": \"Elements of finite order are of finite order in submonoids.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : AddMonoid G] (H : AddSubmonoid G) (x : { x // x ‚àà H }), IsOfFinAddOrder x ‚Üî IsOfFinAddOrder ‚Üëx\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Inverses of elements of finite additive order have finite additive order.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G] {x : G}, IsOfFinAddOrder x ‚Üí IsOfFinAddOrder (-x)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The image of an element of finite additive order has finite additive order.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_2} {H : Type u_1} [inst : AddMonoid G] [inst_1 : AddMonoid H] (f : G ‚Üí+ H) {x : G},\\n  IsOfFinAddOrder x ‚Üí IsOfFinAddOrder (‚Üëf x)\"},\n {\"role\": \"user\",\n  \"content\": \"The image of an element of finite order has finite order. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_2} {H : Type u_1} [inst : Monoid G] [inst_1 : Monoid H] (f : G ‚Üí* H) {x : G},\\n  IsOfFinOrder x ‚Üí IsOfFinOrder (‚Üëf x)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A group element has finite additive order iff its order is positive.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : AddMonoid G] {x : G}, 0 < addOrderOf x ‚Üî IsOfFinAddOrder x\"},\n {\"role\": \"user\",\n  \"content\": \"Elements of finite order are closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : CommMonoid G] {x y : G}, IsOfFinOrder x ‚Üí IsOfFinOrder y ‚Üí IsOfFinOrder (x * y)\"},\n {\"role\": \"user\",\n  \"content\": \"Inverses of elements of finite order have finite order. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x‚Åª¬π ‚Üî IsOfFinOrder x\"},\n {\"role\": \"user\",\n  \"content\": \"A group element has finite order iff its order is positive. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x ‚Üî IsOfFinOrder x\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [self : LinearOrderedCommGroupWithZero Œ±] (a : Œ±), a ‚â† 0 ‚Üí a * a‚Åª¬π = 1\"},\n {\"role\": \"user\",\n  \"content\": \"Any finite order element in a group is equal to the identity.\"}]"}
{"text":"If a subgroup of a group is torsion-free, then the group itself is torsion free.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"A nontrivial torsion group is not torsion-free. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G ‚Üí ¬¨Monoid.IsTorsionFree G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The image of a surjective torsion group homomorphism is torsion. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H] {f : G ‚Üí* H},\\n  Function.Surjective ‚Üëf ‚Üí Monoid.IsTorsion G ‚Üí Monoid.IsTorsion H\"},\n {\"role\": \"user\",\n  \"content\": \"Additive torsion groups are closed under extensions.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} {H : Type u_2} [inst : AddGroup G] {N : AddSubgroup G} [inst_1 : AddGroup H] {f : G ‚Üí+ H},\\n  N = AddMonoidHom.ker f ‚Üí AddMonoid.IsTorsion H ‚Üí AddMonoid.IsTorsion { x // x ‚àà N } ‚Üí AddMonoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The additive torsion submonoid of an abelian group equals the torsion\\nsubgroup as a submonoid.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (G : Type u_1) [inst : AddCommGroup G], AddCommMonoid.addTorsion G = (AddCommGroup.torsion G).toAddSubmonoid\"},\n {\"role\": \"user\",\n  \"content\": \"The image of a quotient is torsion iff the group is torsion. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G ‚Üí* H},\\n  Function.Surjective ‚Üëf ‚Üí\\n    N = MonoidHom.ker f ‚Üí Monoid.IsTorsion { x // x ‚àà N } ‚Üí (Monoid.IsTorsion H ‚Üî Monoid.IsTorsion G)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Quotienting by the torsion submodule gives a torsion-free module. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_2} {M : Type u_1} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M],\\n  Submodule.torsion R (M ‚ß∏ Submodule.torsion R M) = ‚ä•\"},\n {\"role\": \"user\",\n  \"content\": \"A nontrivial torsion-free group is not torsion. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G ‚Üí ¬¨Monoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\": \"If a group exponent exists, the group is torsion. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G], Monoid.ExponentExists G ‚Üí Monoid.IsTorsion G\"},\n {\"role\": \"user\", \"content\": \"Torsion groups are closed under extensions. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G ‚Üí* H},\\n  N = MonoidHom.ker f ‚Üí Monoid.IsTorsion H ‚Üí Monoid.IsTorsion { x // x ‚àà N } ‚Üí Monoid.IsTorsion G\"},\n {\"role\": \"user\", \"content\": \"Torsion submonoids are torsion. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : CommMonoid G], Monoid.IsTorsion { x // x ‚àà CommMonoid.torsion G }\"},\n {\"role\": \"user\", \"content\": \"Finite groups are torsion groups. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Subgroups of additive torsion groups are additive torsion groups.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G], AddMonoid.IsTorsion G ‚Üí ‚àÄ (H : AddSubgroup G), AddMonoid.IsTorsion { x // x ‚àà H }\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The torsion submonoid of an abelian group equals the torsion subgroup as a submonoid. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (G : Type u_1) [inst : CommGroup G], CommMonoid.torsion G = (CommGroup.torsion G).toSubmonoid\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Direct products of additive torsion free groups are torsion free.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ∑ : Type u_1} {Gs : Œ∑ ‚Üí Type u_2} [inst : (i : Œ∑) ‚Üí AddGroup (Gs i)],\\n  (‚àÄ (i : Œ∑), AddMonoid.IsTorsionFree (Gs i)) ‚Üí AddMonoid.IsTorsionFree ((i : Œ∑) ‚Üí Gs i)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Quotienting a group by its additive torsion subgroup yields an additive torsion free group.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (G : Type u_1) [inst : AddCommGroup G], AddMonoid.IsTorsionFree (G ‚ß∏ AddCommGroup.torsion G)\"},\n {\"role\": \"user\",\n  \"content\": \"Subgroups of torsion groups are torsion groups. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ‚Üí ‚àÄ (H : Subgroup G), Monoid.IsTorsion { x // x ‚àà H }\"},\n {\"role\": \"user\",\n  \"content\": \"Direct products of torsion free groups are torsion free. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ∑ : Type u_1} {Gs : Œ∑ ‚Üí Type u_2} [inst : (i : Œ∑) ‚Üí Group (Gs i)],\\n  (‚àÄ (i : Œ∑), Monoid.IsTorsionFree (Gs i)) ‚Üí Monoid.IsTorsionFree ((i : Œ∑) ‚Üí Gs i)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Subgroups of additive torsion-free groups are additively torsion-free.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G],\\n  AddMonoid.IsTorsionFree G ‚Üí ‚àÄ (H : AddSubgroup G), AddMonoid.IsTorsionFree { x // x ‚àà H }\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Quotienting a group by its torsion subgroup yields a torsion free group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G ‚ß∏ CommGroup.torsion G)\"},\n {\"role\": \"user\",\n  \"content\": \"Subgroups of torsion-free groups are torsion-free. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G ‚Üí ‚àÄ (H : Subgroup G), Monoid.IsTorsionFree { x // x ‚àà H }\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a subgroup of a group is torsion-free, then the group itself is torsion free.\"}]"}
{"text":"Every injective homomorphism from a finitely generated free group to itself is surjective.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"An epimorphism is surjective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} {M : Type u_3} {R‚ÇÇ : Type u_2} {M‚ÇÇ : Type u_4} [inst : Ring R] [inst_1 : Ring R‚ÇÇ]\\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommGroup M‚ÇÇ] [inst_4 : Module R M] [inst_5 : Module R‚ÇÇ M‚ÇÇ] {œÑ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ}\\n  [inst_6 : RingHomSurjective œÑ‚ÇÅ‚ÇÇ] {f : M ‚Üí‚Çõ‚Çó[œÑ‚ÇÅ‚ÇÇ] M‚ÇÇ},\\n  (‚àÄ (u v : M‚ÇÇ ‚Üí‚Çó[R‚ÇÇ] M‚ÇÇ ‚ß∏ LinearMap.range f), LinearMap.comp u f = LinearMap.comp v f ‚Üí u = v) ‚Üí LinearMap.range f = ‚ä§\"},\n {\"role\": \"user\", \"content\": \"A group homomorphism sends 1 to 1. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Group Œ±] [inst_1 : Group Œ≤] {f : Œ± ‚Üí Œ≤}, IsGroupHom f ‚Üí f 1 = 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A monoid homomorphism `f` induces an injective homomorphism on the quotient by `f`'s kernel. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {M : Type u_1} {P : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass P] (f : M ‚Üí* P),\\n  Function.Injective ‚Üë(Con.kerLift f)\"},\n {\"role\": \"user\", \"content\": \"A group homomorphism is a monoid homomorphism. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Group Œ±] [inst_1 : Group Œ≤] {f : Œ± ‚Üí Œ≤}, IsGroupHom f ‚Üí IsMonoidHom f\"},\n {\"role\": \"user\",\n  \"content\": \"A group homomorphism sends inverses to inverses. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Group Œ±] [inst_1 : Group Œ≤] {f : Œ± ‚Üí Œ≤}, IsGroupHom f ‚Üí ‚àÄ (a : Œ±), f a‚Åª¬π = (f a)‚Åª¬π\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The canonical map from the type to the free group is an injection. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {Œ± : Type u}, Function.Injective FreeGroup.of\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The induced algebra morphism from the quotient by the kernel is injective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R‚ÇÅ : Type u_1} {A : Type u_2} {B : Type u_3} [inst : CommSemiring R‚ÇÅ] [inst_1 : CommRing A] [inst_2 : CommRing B]\\n  [inst_3 : Algebra R‚ÇÅ A] [inst_4 : Algebra R‚ÇÅ B] (f : A ‚Üí‚Çê[R‚ÇÅ] B), Function.Injective ‚Üë(Ideal.kerLiftAlg f)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The natural homomorphism from a monoid to its quotient by a congruence relation is\\nsurjective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {M : Type u_1} [inst : MulOneClass M] {c : Con M}, Function.Surjective ‚Üë(Con.mk' c)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any surjective endomorphism of a Noetherian module is bijective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsNoetherian R M] (f : M ‚Üí‚Çó[R] M), Function.Surjective ‚Üëf ‚Üí Function.Bijective ‚Üëf\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The image of a surjective torsion group homomorphism is torsion. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H] {f : G ‚Üí* H},\\n  Function.Surjective ‚Üëf ‚Üí Monoid.IsTorsion G ‚Üí Monoid.IsTorsion H\"},\n {\"role\": \"user\", \"content\": \"Group homomorphisms preserve inverse. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\\n  [inst_2 : MonoidHomClass F G H] (f : F) (a : G), ‚Üëf a‚Åª¬π = (‚Üëf a)‚Åª¬π\"},\n {\"role\": \"user\",\n  \"content\":\n  \"On a finite-dimensional space, an injective linear map is surjective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] {f : V ‚Üí‚Çó[K] V}, Function.Injective ‚Üëf ‚Üí Function.Surjective ‚Üëf\"},\n {\"role\": \"user\",\n  \"content\": \"Any injective endomorphism of an Artinian module is bijective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsArtinian R M] (f : M ‚Üí‚Çó[R] M), Function.Injective ‚Üëf ‚Üí Function.Bijective ‚Üëf\"},\n {\"role\": \"user\",\n  \"content\":\n  \"An additive group homomorphism is injective if its kernel is trivial.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : AddGroup Œ±] [inst_1 : AddGroup Œ≤] {f : Œ± ‚Üí Œ≤},\\n  IsAddGroupHom f ‚Üí (Function.Injective f ‚Üî ‚àÄ (a : Œ±), f a = 0 ‚Üí a = 0)\"},\n {\"role\": \"user\", \"content\": \"The ring homomorphism is surjective \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R‚ÇÅ : Type u_1} {R‚ÇÇ : Type u_2} [inst : Semiring R‚ÇÅ] [inst_1 : Semiring R‚ÇÇ] {œÉ : R‚ÇÅ ‚Üí+* R‚ÇÇ}\\n  [self : RingHomSurjective œÉ], Function.Surjective ‚ÜëœÉ\"},\n {\"role\": \"user\",\n  \"content\": \"Every graph homomorphism from a complete graph is injective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {V : Type u} {W : Type v} {G' : SimpleGraph W} (f : ‚ä§ ‚Üíg G'), Function.Injective ‚Üëf\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any surjective endomorphism of a Noetherian module is injective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsNoetherian R M] (f : M ‚Üí‚Çó[R] M), Function.Surjective ‚Üëf ‚Üí Function.Injective ‚Üëf\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any injective polynomial map over an algebraic extension of a finite field is surjective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œπ : Type u_1} {K : Type u_2} {R : Type u_3} [inst : Field K] [inst_1 : Finite K] [inst_2 : CommRing R]\\n  [inst_3 : Finite Œπ] [inst_4 : Algebra K R],\\n  Algebra.IsAlgebraic K R ‚Üí\\n    ‚àÄ (ps : Œπ ‚Üí MvPolynomial Œπ R),\\n      (Function.Injective fun v i => ‚Üë(MvPolynomial.eval v) (ps i)) ‚Üí\\n        Function.Surjective fun v i => ‚Üë(MvPolynomial.eval v) (ps i)\"},\n {\"role\": \"user\",\n  \"content\": \"A group homomorphism is injective iff its kernel is trivial. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Group Œ±] [inst_1 : Group Œ≤] {f : Œ± ‚Üí Œ≤},\\n  IsGroupHom f ‚Üí (Function.Injective f ‚Üî ‚àÄ (a : Œ±), f a = 1 ‚Üí a = 1)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any injective endomorphism of an Artinian module is surjective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsArtinian R M] (f : M ‚Üí‚Çó[R] M), Function.Injective ‚Üëf ‚Üí Function.Surjective ‚Üëf\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every injective homomorphism from a finitely generated free group to itself is surjective.\"}]"}
{"text":"Every division ring is either a field or finite.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"A finite set is bounded \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±}, Set.Finite s ‚Üí Metric.Bounded s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any conditionally complete linearly ordered field is archimedean. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : ConditionallyCompleteLinearOrderedField Œ±], Archimedean Œ±\"},\n {\"role\": \"user\",\n  \"content\": \"An intermediate field is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\\n  {x y : L}, x ‚àà S ‚Üí y ‚àà S ‚Üí x * y ‚àà S\"},\n {\"role\": \"user\", \"content\": \"A subfield is closed under division. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u} [inst : Field K] (s : Subfield K) {x y : K}, x ‚àà s ‚Üí y ‚àà s ‚Üí x / y ‚àà s\"},\n {\"role\": \"user\",\n  \"content\": \"A field extension is algebraic if it is finite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (K : Type u_1) (L : Type u_2) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L]\\n  [inst_3 : FiniteDimensional K L], Algebra.IsAlgebraic K L\"},\n {\"role\": \"user\",\n  \"content\": \"A linear ordered field that is a floor ring is archimedean. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (Œ± : Type u_1) [inst : LinearOrderedField Œ±] [inst_1 : FloorRing Œ±], Archimedean Œ±\"},\n {\"role\": \"user\",\n  \"content\": \"A normed division ring is a topological division ring. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : NormedDivisionRing Œ±], TopologicalDivisionRing Œ±\"},\n {\"role\": \"user\",\n  \"content\": \"The characteristic of a finite ring cannot be zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (R : Type u_1) [inst : NonAssocRing R] (p : ‚Ñï) [inst : CharP R p] [inst : Finite R], p ‚â† 0\"},\n {\"role\": \"user\", \"content\": \"A finite field has prime power cardinality. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : Fintype Œ±] [inst_1 : Field Œ±], IsPrimePow (Fintype.card Œ±)\"},\n {\"role\": \"user\",\n  \"content\": \"Natural division is always less than division in the field. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : LinearOrderedSemifield Œ±] {m n : ‚Ñï}, ‚Üë(m / n) ‚â§ ‚Üëm / ‚Üën\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For a semiring to be a field, it must have two distinct elements. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {R : Type u} [inst : Semiring R], IsField R ‚Üí ‚àÉ x y, x ‚â† y\"},\n {\"role\": \"user\",\n  \"content\": \"All ideals in a division (semi)ring are trivial. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u} [inst : DivisionSemiring K] (I : Ideal K), I = ‚ä• ‚à® I = ‚ä§\"},\n {\"role\": \"user\",\n  \"content\": \"Natural division is the floor of field division. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : LinearOrderedSemifield Œ±] [inst_1 : FloorSemiring Œ±] (m n : ‚Ñï), ‚åä‚Üëm / ‚Üën‚åã‚Çä = m / n\"},\n {\"role\": \"user\", \"content\": \"The category of rings has all limits. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"CategoryTheory.Limits.HasLimitsOfSize.{v, v, max u v, max (u + 1) (v + 1)} CommSemiRingCatMax\"},\n {\"role\": \"user\", \"content\": \"An intermediate field contains the ring's 0. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\\n  0 ‚àà S\"},\n {\"role\": \"user\", \"content\": \"A field extension is integral if it is finite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (K : Type u_1) (L : Type u_2) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L]\\n  [inst_3 : FiniteDimensional K L], Algebra.IsIntegral K L\"},\n {\"role\": \"user\", \"content\": \"An intermediate field contains the ring's 1. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\\n  1 ‚àà S\"},\n {\"role\": \"user\",\n  \"content\": \"An intermediate field is closed under division. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\\n  {x y : L}, x ‚àà S ‚Üí y ‚àà S ‚Üí x / y ‚àà S\"},\n {\"role\": \"user\", \"content\": \"A field is a valuation ring. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ (K : Type u) [inst : Field K], ValuationRing K\"},\n {\"role\": \"user\", \"content\": \"A valued division ring is separated. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u_1} [inst : DivisionRing K] {Œì‚ÇÄ : Type u_2} [inst_1 : LinearOrderedCommGroupWithZero Œì‚ÇÄ]\\n  [inst_2 : Valued K Œì‚ÇÄ], SeparatedSpace K\"},\n {\"role\": \"user\",\n  \"content\": \"Every division ring is either a field or finite.\"}]"}
{"text":"Every natural number is the product of two primes.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A binomial coefficient is the product of its prime factors, which are at most `n`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (n k : ‚Ñï),\\n  k ‚â§ n ‚Üí (Finset.prod (Finset.range (n + 1)) fun p => p ^ ‚Üë(Nat.factorization (Nat.choose n k)) p) = Nat.choose n k\"},\n {\"role\": \"user\",\n  \"content\": \"The only prime factor of prime `p` is `p` itself. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {p q : ‚Ñï}, Nat.Prime p ‚Üí ‚Üë(Nat.factorization p) q ‚â† 0 ‚Üí p = q\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a finite field of characteristic `2`, all elements are squares. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 ‚Üí ‚àÄ (a : F), IsSquare a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The numerator and denominator are coprime: it is in \\\"reduced form\\\". \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ (self : ‚Ñö), Nat.coprime (Int.natAbs self.num) self.den\"},\n {\"role\": \"user\", \"content\": \"`2` is not a factor of an odd natural number. \"},\n {\"role\": \"assistant\", \"content\": \"‚àÄ {m n : ‚Ñï}, Odd n ‚Üí m ‚à£ n ‚Üí m ‚â† 2\"},\n {\"role\": \"user\",\n  \"content\": \"The exponential characteristic is a prime number or one. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (R : Type u) [inst : Semiring R] (q : ‚Ñï) [hq : ExpChar R q], Nat.Prime q ‚à® q = 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ (n : ‚Ñï), Nat.factorization n = 0 ‚Üî n = 0 ‚à® n = 1\"},\n {\"role\": \"user\", \"content\": \"A minimal polynomial is prime. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\\n  IsIntegral A x ‚Üí Prime (minpoly A x)\"},\n {\"role\": \"user\",\n  \"content\": \"All composite numbers are Fermat pseudoprimes to base 1.\\n\"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {n : ‚Ñï}, 1 < n ‚Üí ¬¨Nat.Prime n ‚Üí FermatPsp n 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A prime natural number is prime in `‚Ñ§[i]` if and only if it is `3` mod `4` \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ (p : ‚Ñï) [inst : Fact (Nat.Prime p)], Prime ‚Üëp ‚Üî p % 4 = 3\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two positive naturals are equal if their prime padic valuations are equal \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (a b : ‚Ñï), a ‚â† 0 ‚Üí b ‚â† 0 ‚Üí (a = b ‚Üî ‚àÄ (p : ‚Ñï), Nat.Prime p ‚Üí padicValNat p a = padicValNat p b)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a product lies in the prime ideal, then at least one element lies in the prime ideal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : Semiring Œ±] {I : Ideal Œ±} [self : Ideal.IsPrime I] {x y : Œ±}, x * y ‚àà I ‚Üí x ‚àà I ‚à® y ‚àà I\"},\n {\"role\": \"user\",\n  \"content\": \"The only divisors of prime powers are prime powers. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : CancelCommMonoidWithZero Œ±] [dec_irr : (p : Associates Œ±) ‚Üí Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid Œ±] [dec : DecidableEq Œ±] [dec' : DecidableEq (Associates Œ±)] {a p : Associates Œ±},\\n  Irreducible p ‚Üí\\n    ‚àÄ [inst_2 : (n : ‚Ñï) ‚Üí Decidable (a ‚à£ p ^ n)] {n : ‚Ñï} (h : a ‚à£ p ^ n),\\n      a = p ^ Nat.find (_ : ‚àÉ n, (fun n => a ‚à£ p ^ n) n)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {m n : ‚Ñï}, (‚àÄ (a : ‚Ñï), m ‚à£ a ‚Üî n ‚à£ a) ‚Üî m = n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {m n : ‚Ñï}, (‚àÄ (a : ‚Ñï), a ‚à£ m ‚Üî a ‚à£ n) ‚Üî m = n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {a b x y u v : ‚Ñï}, a = x ^ 2 + y ^ 2 ‚Üí b = u ^ 2 + v ^ 2 ‚Üí ‚àÉ r s, a * b = r ^ 2 + s ^ 2\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\", \"content\": \"Set.InjOn Nat.factorization {x | x ‚â† 0}\"},\n {\"role\": \"user\",\n  \"content\": \"Every natural number is the product of two primes.\"}]"}
{"text":"Every even number is the square of a natural number.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The `n`th power of a quadratic character is itself, when `n` is odd. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} [inst : CommRing R] {R' : Type v} [inst_1 : CommRing R'] {œá : MulChar R R'},\\n  MulChar.IsQuadratic œá ‚Üí ‚àÄ {n : ‚Ñï}, Odd n ‚Üí œá ^ n = œá\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The real square root is at most the natural square root plus one \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {a : ‚Ñï}, Real.sqrt ‚Üëa ‚â§ ‚Üë(Nat.sqrt a) + 1\"},\n {\"role\": \"user\", \"content\": \"`2` is not a factor of an odd natural number. \"},\n {\"role\": \"assistant\", \"content\": \"‚àÄ {m n : ‚Ñï}, Odd n ‚Üí m ‚à£ n ‚Üí m ‚â† 2\"},\n {\"role\": \"user\",\n  \"content\": \"The sum of two squares is zero iff both elements are zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : LinearOrderedRing Œ±] {x y : Œ±}, x * x + y * y = 0 ‚Üî x = 0 ‚àß y = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a finite field of odd characteristic, not every element is a square. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F ‚â† 2 ‚Üí ‚àÉ a, ¬¨IsSquare a\"},\n {\"role\": \"user\",\n  \"content\": \"A natural number is odd iff it has residue `1` or `3` mod `4`\"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {n : ‚Ñï}, n % 2 = 1 ‚Üî n % 4 = 1 ‚à® n % 4 = 3\"},\n {\"role\": \"user\",\n  \"content\": \"The natural square root is at most the real square root \"},\n {\"role\": \"assistant\", \"content\": \"‚àÄ {a : ‚Ñï}, ‚Üë(Nat.sqrt a) ‚â§ Real.sqrt ‚Üëa\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {m n : ‚Ñï}, (‚àÄ (a : ‚Ñï), a ‚à£ m ‚Üî a ‚à£ n) ‚Üî m = n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {n : ‚Ñï}, IsSquare (-1) ‚Üí ‚àÉ x y, n = x ^ 2 + y ^ 2\"},\n {\"role\": \"user\",\n  \"content\": \"The convolution of two even functions is also even. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {ùïú : Type uùïú} {G : Type uG} {E : Type uE} {E' : Type uE'} {F : Type uF} [inst : NormedAddCommGroup E]\\n  [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedAddCommGroup F] {f : G ‚Üí E} {g : G ‚Üí E'} {x : G}\\n  [inst_3 : NontriviallyNormedField ùïú] [inst_4 : NormedSpace ùïú E] [inst_5 : NormedSpace ùïú E'] [inst_6 : NormedSpace ùïú F]\\n  (L : E ‚ÜíL[ùïú] E' ‚ÜíL[ùïú] F) [inst_7 : MeasurableSpace G] {Œº : MeasureTheory.Measure G} [inst_8 : NormedSpace ‚Ñù F]\\n  [inst_9 : AddCommGroup G] [inst_10 : MeasureTheory.Measure.IsAddLeftInvariant Œº]\\n  [inst_11 : MeasureTheory.Measure.IsNegInvariant Œº] [inst_12 : MeasurableNeg G] [inst_13 : MeasurableAdd G],\\n  (‚àÄ·µê (x : G) ‚àÇŒº, f (-x) = f x) ‚Üí (‚àÄ·µê (x : G) ‚àÇŒº, g (-x) = g x) ‚Üí convolution f g L (-x) = convolution f g L x\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\", \"content\": \"Set.InjOn Nat.factorization {x | x ‚â† 0}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"**Euler's four-square identity**, a version for natural numbers. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (a b c d x y z w : ‚Ñï),\\n  Int.natAbs (‚Üëa * ‚Üëx - ‚Üëb * ‚Üëy - ‚Üëc * ‚Üëz - ‚Üëd * ‚Üëw) ^ 2 + Int.natAbs (‚Üëa * ‚Üëy + ‚Üëb * ‚Üëx + ‚Üëc * ‚Üëw - ‚Üëd * ‚Üëz) ^ 2 +\\n        Int.natAbs (‚Üëa * ‚Üëz - ‚Üëb * ‚Üëw + ‚Üëc * ‚Üëx + ‚Üëd * ‚Üëy) ^ 2 +\\n      Int.natAbs (‚Üëa * ‚Üëw + ‚Üëb * ‚Üëz - ‚Üëc * ‚Üëy + ‚Üëd * ‚Üëx) ^ 2 =\\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a finite field of characteristic `2`, all elements are squares. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 ‚Üí ‚àÄ (a : F), IsSquare a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {m n : ‚Ñï}, (‚àÄ (a : ‚Ñï), m ‚à£ a ‚Üî n ‚à£ a) ‚Üî m = n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {a b x y u v : ‚Ñï}, a = x ^ 2 + y ^ 2 ‚Üí b = u ^ 2 + v ^ 2 ‚Üí ‚àÉ r s, a * b = r ^ 2 + s ^ 2\"},\n {\"role\": \"user\",\n  \"content\": \"Every even number is the square of a natural number.\"}]"}
{"text":"Every normal subgroup of a group has finite index.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is cyclic.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsAddCyclic Œ±\"},\n {\"role\": \"user\",\n  \"content\": \"Inverses of elements of finite order have finite order. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x‚Åª¬π ‚Üî IsOfFinOrder x\"},\n {\"role\": \"user\", \"content\": \"A subgroup is closed under division. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {M : Type u_1} {S : Type u_2} [inst : DivInvMonoid M] [inst_1 : SetLike S M] [hSM : SubgroupClass S M] {H : S}\\n  {x y : M}, x ‚àà H ‚Üí y ‚àà H ‚Üí x / y ‚àà H\"},\n {\"role\": \"user\",\n  \"content\": \"Elements of finite order are of finite order in submonoids.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : AddMonoid G] (H : AddSubmonoid G) (x : { x // x ‚àà H }), IsOfFinAddOrder x ‚Üî IsOfFinAddOrder ‚Üëx\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a module has a finite dimension, all bases are indexed by a finite type. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} [inst : Ring R] [inst_1 : StrongRankCondition R] {M : Type v} [inst_2 : AddCommGroup M]\\n  [inst_3 : Module R M] {Œπ : Type u_1}, Basis Œπ R M ‚Üí Module.rank R M < Cardinal.aleph0 ‚Üí Nonempty (Fintype Œπ)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (G : Type u_1) [inst : Group G] [inst_1 : Finite ‚Üë(commutatorSet G)], Finite { x // x ‚àà commutator G }\"},\n {\"role\": \"user\", \"content\": \"Elements of disjoint, normal subgroups commute.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G] (H‚ÇÅ H‚ÇÇ : AddSubgroup G),\\n  AddSubgroup.Normal H‚ÇÅ ‚Üí AddSubgroup.Normal H‚ÇÇ ‚Üí Disjoint H‚ÇÅ H‚ÇÇ ‚Üí ‚àÄ (x y : G), x ‚àà H‚ÇÅ ‚Üí y ‚àà H‚ÇÇ ‚Üí AddCommute x y\"},\n {\"role\": \"user\",\n  \"content\": \"The topological closure of a normal subgroup is normal.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N)\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is cyclic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)], Fintype.card Œ± = p ‚Üí IsCyclic Œ±\"},\n {\"role\": \"user\", \"content\": \"A subgroup is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x ‚àà H ‚Üí y ‚àà H ‚Üí x * y ‚àà H\"},\n {\"role\": \"user\",\n  \"content\": \"Elements of disjoint, normal subgroups commute. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] (H‚ÇÅ H‚ÇÇ : Subgroup G),\\n  Subgroup.Normal H‚ÇÅ ‚Üí Subgroup.Normal H‚ÇÇ ‚Üí Disjoint H‚ÇÅ H‚ÇÇ ‚Üí ‚àÄ (x y : G), x ‚àà H‚ÇÅ ‚Üí y ‚àà H‚ÇÇ ‚Üí Commute x y\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A finite subgroup of the unit group of an integral domain is cyclic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\\n  (f : G ‚Üí* R), Function.Injective ‚Üëf ‚Üí IsCyclic G\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is simple. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsSimpleGroup Œ±\"},\n {\"role\": \"user\", \"content\": \"A finite index subgroup has finite quotient. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"{G : Type u_1} ‚Üí [inst : Group G] ‚Üí (H : Subgroup G) ‚Üí [inst_1 : Subgroup.FiniteIndex H] ‚Üí Fintype (G ‚ß∏ H)\"},\n {\"role\": \"user\",\n  \"content\": \"The submodule generated by a finite set is finite-dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (K : Type u) {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {A : Set V},\\n  Set.Finite A ‚Üí FiniteDimensional K { x // x ‚àà Submodule.span K A }\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a module has a finite dimension, all bases are indexed by a finite set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} [inst : Ring R] [inst_1 : StrongRankCondition R] {M : Type v} [inst_2 : AddCommGroup M]\\n  [inst_3 : Module R M] {Œπ : Type u_1} {s : Set Œπ}, Basis (‚Üës) R M ‚Üí Module.rank R M < Cardinal.aleph0 ‚Üí Set.Finite s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A subgroup is finitely generated if and only if it is finitely generated as a submonoid. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] (P : Subgroup G), Subgroup.FG P ‚Üî Submonoid.FG P.toSubmonoid\"},\n {\"role\": \"user\",\n  \"content\":\n  \"**Schreier's Lemma**: A finite index subgroup of a finitely generated\\ngroup is finitely generated. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] (H : Subgroup G) [hG : Group.FG G] [inst_1 : Subgroup.FiniteIndex H],\\n  Group.FG { x // x ‚àà H }\"},\n {\"role\": \"user\", \"content\": \"The additive subgroup has finite index \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G] {H : AddSubgroup G} [self : AddSubgroup.FiniteIndex H], AddSubgroup.index H ‚â† 0\"},\n {\"role\": \"user\", \"content\": \"The subgroup has finite index \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.FiniteIndex H], Subgroup.index H ‚â† 0\"},\n {\"role\": \"user\",\n  \"content\": \"Every normal subgroup of a group has finite index.\"}]"}
{"text":"The characteristic polynomial of every matrix has real roots.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"All generalized eigenvalues are eigenvalues. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type v} {M : Type w} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] {f : Module.End R M}\\n  {Œº : R} {k : ‚Ñï}, Module.End.HasGeneralizedEigenvalue f Œº k ‚Üí Module.End.HasEigenvalue f Œº\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The degree of a minimal polynomial, as a natural number, is positive. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {A : Type u_2} {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : Nontrivial B], IsIntegral A x ‚Üí 0 < Polynomial.natDegree (minpoly A x)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A polynomial splits if and only if it has as many roots as its degree. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type v} [inst : Field K] {p : Polynomial K},\\n  Polynomial.Splits (RingHom.id K) p ‚Üî ‚ÜëMultiset.card (Polynomial.roots p) = Polynomial.natDegree p\"},\n {\"role\": \"user\",\n  \"content\":\n  \"An irreducible polynomial of prime degree with 1-3 non-real roots has full Galois group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {p : Polynomial ‚Ñö},\\n  Irreducible p ‚Üí\\n    Nat.Prime (Polynomial.natDegree p) ‚Üí\\n      Fintype.card ‚Üë(Polynomial.rootSet p ‚Ñù) + 1 ‚â§ Fintype.card ‚Üë(Polynomial.rootSet p ‚ÑÇ) ‚Üí\\n        Fintype.card ‚Üë(Polynomial.rootSet p ‚ÑÇ) ‚â§ Fintype.card ‚Üë(Polynomial.rootSet p ‚Ñù) + 3 ‚Üí\\n          Function.Bijective ‚Üë(Polynomial.Gal.galActionHom p ‚ÑÇ)\"},\n {\"role\": \"user\",\n  \"content\": \"An element is a root of its minimal polynomial. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (A : Type u_2) {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B),\\n  ‚Üë(Polynomial.aeval x) (minpoly A x) = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"An irreducible polynomial of prime degree with two non-real roots has full Galois group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {p : Polynomial ‚Ñö},\\n  Irreducible p ‚Üí\\n    Nat.Prime (Polynomial.natDegree p) ‚Üí\\n      Fintype.card ‚Üë(Polynomial.rootSet p ‚ÑÇ) = Fintype.card ‚Üë(Polynomial.rootSet p ‚Ñù) + 2 ‚Üí\\n        Function.Bijective ‚Üë(Polynomial.Gal.galActionHom p ‚ÑÇ)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"An algebraic integer whose conjugates are all of norm one is a root of unity. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (K : Type u_1) [inst : Field K] [inst_1 : NumberField K] (A : Type u_2) [inst_2 : NormedField A]\\n  [inst_3 : IsAlgClosed A] [inst_4 : NormedAlgebra ‚Ñö A] {x : K},\\n  IsIntegral ‚Ñ§ x ‚Üí (‚àÄ (œÜ : K ‚Üí+* A), ‚Äñ‚ÜëœÜ x‚Äñ = 1) ‚Üí ‚àÉ n x_1, x ^ n = 1\"},\n {\"role\": \"user\", \"content\": \"Every identity matrix is diagonal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_2} {n : Type u_1} [inst : DecidableEq n] [inst_1 : Zero Œ±] [inst_2 : One Œ±], Matrix.IsDiag 1\"},\n {\"role\": \"user\",\n  \"content\": \"The degree of a minimal polynomial is positive. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {A : Type u_2} {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : Nontrivial B], IsIntegral A x ‚Üí 0 < Polynomial.degree (minpoly A x)\"},\n {\"role\": \"user\",\n  \"content\": \"Every polynomial is a polynomial in finitely many variables. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {œÉ : Type u_1} {R : Type u_2} [inst : CommSemiring R] (p : MvPolynomial œÉ R),\\n  ‚àÉ n f _hf q, p = ‚Üë(MvPolynomial.rename f) q\"},\n {\"role\": \"user\",\n  \"content\": \"Any element of the spectrum of a selfadjoint is real. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {A : Type u_1} [inst : NormedRing A] [inst_1 : NormedAlgebra ‚ÑÇ A] [inst_2 : CompleteSpace A] [inst_3 : StarRing A]\\n  [inst_4 : CstarRing A] [inst_5 : StarModule ‚ÑÇ A] (a : { x // x ‚àà selfAdjoint A }) {z : ‚ÑÇ},\\n  z ‚àà spectrum ‚ÑÇ ‚Üëa ‚Üí z = ‚Üëz.re\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The minimal polynomial of a nonzero element has nonzero constant coefficient. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\\n  IsIntegral A x ‚Üí x ‚â† 0 ‚Üí Polynomial.coeff (minpoly A x) 0 ‚â† 0\"},\n {\"role\": \"user\",\n  \"content\": \"The eigenvalues of a self-adjoint operator are real. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {ùïú : Type u_1} [inst : IsROrC ùïú] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ùïú E]\\n  {T : E ‚Üí‚Çó[ùïú] E}, LinearMap.IsSymmetric T ‚Üí ‚àÄ {Œº : ùïú}, Module.End.HasEigenvalue T Œº ‚Üí ‚Üë(starRingEnd ùïú) Œº = Œº\"},\n {\"role\": \"user\",\n  \"content\":\n  \"**Fundamental theorem of algebra**: every non constant complex polynomial\\nhas a root \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {f : Polynomial ‚ÑÇ}, 0 < Polynomial.degree f ‚Üí ‚àÉ z, Polynomial.IsRoot f z\"},\n {\"role\": \"user\",\n  \"content\": \"The diagonal elements of a complex hermitian matrix are real. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_2} {n : Type u_1} [inst : IsROrC Œ±] {A : Matrix n n Œ±},\\n  Matrix.IsHermitian A ‚Üí (fun i => ‚Üë(‚ÜëIsROrC.re (Matrix.diag A i))) = Matrix.diag A\"},\n {\"role\": \"user\",\n  \"content\": \"The characteristic polynomial of every matrix has real roots.\"}]"}
{"text":"In a commutative ring, every prime ideal is contained in a unique maximal ideal.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"The kernel of a homomorphism to a domain is a prime ideal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} {S : Type v} {F : Type u_1} [inst : Ring R] [inst_1 : Ring S] [inst_2 : IsDomain S]\\n  [inst_3 : RingHomClass F R S] (f : F), Ideal.IsPrime (RingHom.ker f)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The surjective image of a principal ideal ring is again a principal ideal ring. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} {S : Type u_1} [inst : Ring R] [inst_1 : Ring S] [inst_2 : IsPrincipalIdealRing R] (f : R ‚Üí+* S),\\n  Function.Surjective ‚Üëf ‚Üí IsPrincipalIdealRing S\"},\n {\"role\": \"user\",\n  \"content\": \"This ideal is maximal in the collection of proper ideals. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {P : Type u_1} [inst : LE P] {I : Order.Ideal P} [self : Order.Ideal.IsMaximal I] ‚¶ÉJ : Order.Ideal P‚¶Ñ,\\n  I < J ‚Üí ‚ÜëJ = Set.univ\"},\n {\"role\": \"user\",\n  \"content\": \"When a ring is not a field, the maximal ideals are nontrivial. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} [inst : CommSemiring R] [inst_1 : Nontrivial R] {M : Ideal R}, Ideal.IsMaximal M ‚Üí ¬¨IsField R ‚Üí M ‚â† ‚ä•\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a noetherian ring, every ideal contains a product of prime ideals\\n([samuel, ¬ß 3.3, Lemma 3])\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (R : Type u) [inst : CommRing R] [inst_1 : IsNoetherianRing R] (I : Ideal R),\\n  ‚àÉ Z, Multiset.prod (Multiset.map PrimeSpectrum.asIdeal Z) ‚â§ I\"},\n {\"role\": \"user\",\n  \"content\": \"The kernel of a homomorphism to a field is a maximal ideal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} {K : Type u_2} {F : Type u_3} [inst : Ring R] [inst_1 : Field K] [inst_2 : RingHomClass F R K] (f : F),\\n  Function.Surjective ‚Üëf ‚Üí Ideal.IsMaximal (RingHom.ker f)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The prime spectrum of a commutative ring is a compact topological space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} [inst : CommRing R], CompactSpace (PrimeSpectrum R)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a product lies in the prime ideal, then at least one element lies in the prime ideal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : Semiring Œ±] {I : Ideal Œ±} [self : Ideal.IsPrime I] {x y : Œ±}, x * y ‚àà I ‚Üí x ‚àà I ‚à® y ‚àà I\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The `Ideal.closure` of a maximal ideal in a complete normed ring is the ideal itself. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] {I : Ideal R}, Ideal.IsMaximal I ‚Üí Ideal.closure I = I\"},\n {\"role\": \"user\", \"content\": \"Any finitely generated ideal is principal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} [inst : CommRing R] [self : IsBezout R] (I : Ideal R), Ideal.FG I ‚Üí Submodule.IsPrincipal I\"},\n {\"role\": \"user\",\n  \"content\": \"Maximal ideals in complete normed rings are closed. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] {I : Ideal R} [hI : Ideal.IsMaximal I], IsClosed ‚ÜëI\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The unique maximal ideal of the localization at `I.prime_compl` lies over the ideal `I`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} [inst : CommSemiring R] {I : Ideal R} [hI : Ideal.IsPrime I],\\n  Ideal.comap (algebraMap R (Localization.AtPrime I)) (LocalRing.maximalIdeal (Localization (Ideal.primeCompl I))) = I\"},\n {\"role\": \"user\",\n  \"content\": \"Krull's theorem: a nontrivial ring has a maximal ideal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (Œ± : Type u) [inst : Semiring Œ±] [inst_1 : Nontrivial Œ±], ‚àÉ M, Ideal.IsMaximal M\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If the quotient by an ideal is a field, then the ideal is maximal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} [inst : CommRing R] (I : Ideal R), IsField (R ‚ß∏ I) ‚Üí Ideal.IsMaximal I\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The quotient of a ring by an ideal is a field iff the ideal is maximal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I ‚Üî IsField (R ‚ß∏ I)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If all prime ideals in a commutative ring are principal, so are all other ideals. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} [inst : CommRing R],\\n  (‚àÄ (P : Ideal R), Ideal.IsPrime P ‚Üí Submodule.IsPrincipal P) ‚Üí IsPrincipalIdealRing R\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a commutative ring, every prime ideal is contained in a unique maximal ideal.\"}]"}
{"text":"Every continuous function is uniformly continuous.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If two continuous functions are a.e. equal, then they are equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\\n  [inst_2 : T2Space Y] {Œº : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure Œº] {f g : X ‚Üí Y},\\n  f =·∂†[MeasureTheory.Measure.ae Œº] g ‚Üí Continuous f ‚Üí Continuous g ‚Üí f = g\"},\n {\"role\": \"user\", \"content\": \"Uniform equicontinuity implies equicontinuity. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] {F : Œπ ‚Üí Œ≤ ‚Üí Œ±},\\n  UniformEquicontinuous F ‚Üí Equicontinuous F\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A sequentially continuous function defined on a sequential space is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : SequentialSpace X]\\n  {f : X ‚Üí Y}, SeqContinuous f ‚Üí Continuous f\"},\n {\"role\": \"user\",\n  \"content\": \"A continuous function is bounded above on a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderClosedTopology Œ±]\\n  [inst_3 : TopologicalSpace Œ≤] [inst_4 : Nonempty Œ±] {f : Œ≤ ‚Üí Œ±} {K : Set Œ≤},\\n  IsCompact K ‚Üí ContinuousOn f K ‚Üí BddAbove (f '' K)\"},\n {\"role\": \"user\", \"content\": \"A single function is uniformly integrable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_3} {Œ≤ : Type u_2} {Œπ : Type u_1} {m : MeasurableSpace Œ±} (Œº : MeasureTheory.Measure Œ±)\\n  [inst : NormedAddCommGroup Œ≤] {p : ENNReal} [inst_1 : Subsingleton Œπ],\\n  1 ‚â§ p ‚Üí p ‚â† ‚ä§ ‚Üí ‚àÄ {f : Œπ ‚Üí Œ± ‚Üí Œ≤}, (‚àÄ (i : Œπ), MeasureTheory.Mem‚Ñíp (f i) p) ‚Üí MeasureTheory.UnifIntegrable f p Œº\"},\n {\"role\": \"user\",\n  \"content\": \"Each function of an equicontinuous family is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œπ : Type u_1} {X : Type u_2} {Œ± : Type u_3} [inst : TopologicalSpace X] [inst_1 : UniformSpace Œ±] {F : Œπ ‚Üí X ‚Üí Œ±},\\n  Equicontinuous F ‚Üí ‚àÄ (i : Œπ), Continuous (F i)\"},\n {\"role\": \"user\", \"content\": \"Uniform continuity of the function \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] (self : Œ± ‚âÉ·µ§ Œ≤),\\n  UniformContinuous self.toFun\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A constant sequence of functions is uniformly integrable in the probability sense. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {Œπ : Type u_3} {m : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±}\\n  [inst : NormedAddCommGroup Œ≤] {p : ENNReal} {g : Œ± ‚Üí Œ≤},\\n  1 ‚â§ p ‚Üí p ‚â† ‚ä§ ‚Üí MeasureTheory.Mem‚Ñíp g p ‚Üí MeasureTheory.UniformIntegrable (fun x => g) p Œº\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A function which can be locally uniformly approximated by continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤} [inst_1 : TopologicalSpace Œ±],\\n  (‚àÄ (x : Œ±) (u : Set (Œ≤ √ó Œ≤)),\\n      u ‚àà uniformity Œ≤ ‚Üí ‚àÉ t, t ‚àà nhds x ‚àß ‚àÉ F, ContinuousAt F x ‚àß ‚àÄ (y : Œ±), y ‚àà t ‚Üí (f y, F y) ‚àà u) ‚Üí\\n    Continuous f\"},\n {\"role\": \"user\",\n  \"content\": \"A locally uniform limit of continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {p : Filter Œπ}\\n  [inst_1 : TopologicalSpace Œ±],\\n  TendstoLocallyUniformly F f p ‚Üí (‚àÄ·∂† (n : Œπ) in p, Continuous (F n)) ‚Üí ‚àÄ [inst_2 : Filter.NeBot p], Continuous f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A function which can be uniformly approximated by continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤} [inst_1 : TopologicalSpace Œ±],\\n  (‚àÄ (u : Set (Œ≤ √ó Œ≤)), u ‚àà uniformity Œ≤ ‚Üí ‚àÉ F, Continuous F ‚àß ‚àÄ (y : Œ±), (f y, F y) ‚àà u) ‚Üí Continuous f\"},\n {\"role\": \"user\", \"content\": \"A constant function is uniformly integrable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {Œπ : Type u_3} {m : MeasurableSpace Œ±} (Œº : MeasureTheory.Measure Œ±)\\n  [inst : NormedAddCommGroup Œ≤] {p : ENNReal} {g : Œ± ‚Üí Œ≤},\\n  1 ‚â§ p ‚Üí p ‚â† ‚ä§ ‚Üí MeasureTheory.Mem‚Ñíp g p ‚Üí MeasureTheory.UnifIntegrable (fun x => g) p Œº\"},\n {\"role\": \"user\",\n  \"content\": \"A uniform limit of continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {p : Filter Œπ}\\n  [inst_1 : TopologicalSpace Œ±],\\n  TendstoUniformly F f p ‚Üí (‚àÄ·∂† (n : Œπ) in p, Continuous (F n)) ‚Üí ‚àÄ [inst_2 : Filter.NeBot p], Continuous f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Each function of a uniformly equicontinuous family is uniformly continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] {F : Œπ ‚Üí Œ≤ ‚Üí Œ±},\\n  UniformEquicontinuous F ‚Üí ‚àÄ (i : Œπ), UniformContinuous (F i)\"},\n {\"role\": \"user\",\n  \"content\": \"Every continuous function is uniformly continuous.\"}]"}
{"text":"Every uniformly continuous function is bounded above.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The indexed infimum of a function is bounded above by the value taken at one point\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} {Œπ : Sort u_2} [inst : ConditionallyCompleteLattice Œ±] {f : Œπ ‚Üí Œ±},\\n  BddBelow (Set.range f) ‚Üí ‚àÄ (c : Œπ), iInf f ‚â§ f c\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A constant sequence of functions is uniformly integrable in the probability sense. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {Œπ : Type u_3} {m : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±}\\n  [inst : NormedAddCommGroup Œ≤] {p : ENNReal} {g : Œ± ‚Üí Œ≤},\\n  1 ‚â§ p ‚Üí p ‚â† ‚ä§ ‚Üí MeasureTheory.Mem‚Ñíp g p ‚Üí MeasureTheory.UniformIntegrable (fun x => g) p Œº\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The union of two sets is bounded above if and only if each of the sets is.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ≥ : Type w} [inst : SemilatticeInf Œ≥] {s t : Set Œ≥}, BddBelow (s ‚à™ t) ‚Üî BddBelow s ‚àß BddBelow t\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A function which can be locally uniformly approximated by continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤} [inst_1 : TopologicalSpace Œ±],\\n  (‚àÄ (x : Œ±) (u : Set (Œ≤ √ó Œ≤)),\\n      u ‚àà uniformity Œ≤ ‚Üí ‚àÉ t, t ‚àà nhds x ‚àß ‚àÉ F, ContinuousAt F x ‚àß ‚àÄ (y : Œ±), y ‚àà t ‚Üí (f y, F y) ‚àà u) ‚Üí\\n    Continuous f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The image of a totally bounded set under a uniformly continuous map is totally bounded. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤} {s : Set Œ±},\\n  TotallyBounded s ‚Üí UniformContinuous f ‚Üí TotallyBounded (f '' s)\"},\n {\"role\": \"user\", \"content\": \"A constant function is uniformly integrable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {Œπ : Type u_3} {m : MeasurableSpace Œ±} (Œº : MeasureTheory.Measure Œ±)\\n  [inst : NormedAddCommGroup Œ≤] {p : ENNReal} {g : Œ± ‚Üí Œ≤},\\n  1 ‚â§ p ‚Üí p ‚â† ‚ä§ ‚Üí MeasureTheory.Mem‚Ñíp g p ‚Üí MeasureTheory.UnifIntegrable (fun x => g) p Œº\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A function which can be uniformly approximated by continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤} [inst_1 : TopologicalSpace Œ±],\\n  (‚àÄ (u : Set (Œ≤ √ó Œ≤)), u ‚àà uniformity Œ≤ ‚Üí ‚àÉ F, Continuous F ‚àß ‚àÄ (y : Œ±), (f y, F y) ‚àà u) ‚Üí Continuous f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A finite union of sets which are all bounded above is still bounded above.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : SemilatticeSup Œ±] [inst_1 : Nonempty Œ±] {I : Set Œ≤} {S : Œ≤ ‚Üí Set Œ±},\\n  Set.Finite I ‚Üí (BddAbove (‚ãÉ (i : Œ≤) (_ : i ‚àà I), S i) ‚Üî ‚àÄ (i : Œ≤), i ‚àà I ‚Üí BddAbove (S i))\"},\n {\"role\": \"user\", \"content\": \"A continuous, periodic function is bounded. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {f : ‚Ñù ‚Üí Œ±} {c : ‚Ñù},\\n  Function.Periodic f c ‚Üí c ‚â† 0 ‚Üí Continuous f ‚Üí Metric.Bounded (Set.range f)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Each function of a uniformly equicontinuous family is uniformly continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] {F : Œπ ‚Üí Œ≤ ‚Üí Œ±},\\n  UniformEquicontinuous F ‚Üí ‚àÄ (i : Œπ), UniformContinuous (F i)\"},\n {\"role\": \"user\",\n  \"content\": \"A continuous function with compact support is bounded below. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderClosedTopology Œ±]\\n  [inst_3 : TopologicalSpace Œ≤] [inst_4 : Zero Œ±] {f : Œ≤ ‚Üí Œ±},\\n  Continuous f ‚Üí HasCompactSupport f ‚Üí BddBelow (Set.range f)\"},\n {\"role\": \"user\", \"content\": \"A finite set is bounded above.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : SemilatticeSup Œ±] [inst_1 : Nonempty Œ±] {s : Set Œ±}, Set.Finite s ‚Üí BddAbove s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The indexed supremum of a function is bounded above by a uniform bound\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_2} {Œπ : Sort u_1} [inst : ConditionallyCompleteLattice Œ±] [inst_1 : Nonempty Œπ] {f : Œπ ‚Üí Œ±} {c : Œ±},\\n  (‚àÄ (x : Œπ), f x ‚â§ c) ‚Üí iSup f ‚â§ c\"},\n {\"role\": \"user\",\n  \"content\": \"A locally uniform limit of continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {p : Filter Œπ}\\n  [inst_1 : TopologicalSpace Œ±],\\n  TendstoLocallyUniformly F f p ‚Üí (‚àÄ·∂† (n : Œπ) in p, Continuous (F n)) ‚Üí ‚àÄ [inst_2 : Filter.NeBot p], Continuous f\"},\n {\"role\": \"user\",\n  \"content\": \"A continuous function is bounded below on a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderClosedTopology Œ±]\\n  [inst_3 : TopologicalSpace Œ≤] [inst_4 : Nonempty Œ±] {f : Œ≤ ‚Üí Œ±} {K : Set Œ≤},\\n  IsCompact K ‚Üí ContinuousOn f K ‚Üí BddBelow (f '' K)\"},\n {\"role\": \"user\",\n  \"content\": \"A uniform limit of continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {p : Filter Œπ}\\n  [inst_1 : TopologicalSpace Œ±],\\n  TendstoUniformly F f p ‚Üí (‚àÄ·∂† (n : Œπ) in p, Continuous (F n)) ‚Üí ‚àÄ [inst_2 : Filter.NeBot p], Continuous f\"},\n {\"role\": \"user\",\n  \"content\": \"A continuous function with compact support is bounded above. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderClosedTopology Œ±]\\n  [inst_3 : TopologicalSpace Œ≤] [inst_4 : Zero Œ±] {f : Œ≤ ‚Üí Œ±},\\n  Continuous f ‚Üí HasCompactSupport f ‚Üí BddAbove (Set.range f)\"},\n {\"role\": \"user\",\n  \"content\": \"A continuous function is bounded above on a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderClosedTopology Œ±]\\n  [inst_3 : TopologicalSpace Œ≤] [inst_4 : Nonempty Œ±] {f : Œ≤ ‚Üí Œ±} {K : Set Œ≤},\\n  IsCompact K ‚Üí ContinuousOn f K ‚Üí BddAbove (f '' K)\"},\n {\"role\": \"user\",\n  \"content\": \"Every uniformly continuous function is bounded above.\"}]"}
{"text":"If every compact subset of a topological space is closed, then the space is compact.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any continuous function on compact Hausdorff spaces is a closed map. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {X Y : CompHaus} (f : X ‚ü∂ Y), IsClosedMap ‚Üëf\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The intersection of two open compact subsets of a quasi-separated space is compact.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [self : QuasiSeparatedSpace Œ±] (U V : Set Œ±),\\n  IsOpen U ‚Üí IsCompact U ‚Üí IsOpen V ‚Üí IsCompact V ‚Üí IsCompact (U ‚à© V)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a topological vector space, the closure of a convex set is convex. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {ùïú : Type u_2} {E : Type u_1} [inst : LinearOrderedField ùïú] [inst_1 : AddCommGroup E] [inst_2 : Module ùïú E]\\n  [inst_3 : TopologicalSpace E] [inst_4 : TopologicalAddGroup E] [inst_5 : ContinuousConstSMul ùïú E] {s : Set E},\\n  Convex ùïú s ‚Üí Convex ùïú (closure s)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a locally compact space every point has a compact neighborhood. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LocallyCompactSpace Œ±] (x : Œ±), ‚àÉ K, IsCompact K ‚àß K ‚àà nhds x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The set of compact operators from a normed space to a complete topological vector space is\\nclosed. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {ùïú‚ÇÅ : Type u_1} {ùïú‚ÇÇ : Type u_2} [inst : NontriviallyNormedField ùïú‚ÇÅ] [inst_1 : NormedField ùïú‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : ùïú‚ÇÅ ‚Üí+* ùïú‚ÇÇ}\\n  {M‚ÇÅ : Type u_3} {M‚ÇÇ : Type u_4} [inst_2 : SeminormedAddCommGroup M‚ÇÅ] [inst_3 : AddCommGroup M‚ÇÇ]\\n  [inst_4 : NormedSpace ùïú‚ÇÅ M‚ÇÅ] [inst_5 : Module ùïú‚ÇÇ M‚ÇÇ] [inst_6 : UniformSpace M‚ÇÇ] [inst_7 : UniformAddGroup M‚ÇÇ]\\n  [inst_8 : ContinuousConstSMul ùïú‚ÇÇ M‚ÇÇ] [inst_9 : T2Space M‚ÇÇ] [inst_10 : CompleteSpace M‚ÇÇ],\\n  IsClosed {f | IsCompactOperator ‚Üëf}\"},\n {\"role\": \"user\", \"content\": \"In a Noetherian space, all sets are compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace.NoetherianSpace Œ±] (s : Set Œ±), IsCompact s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For any topological space `X`, its one point compactification is a compact space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A subspace is dense iff its topological closure is the entire space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : TopologicalSpace M] [inst_2 : AddCommMonoid M]\\n  [inst_3 : Module R M] [inst_4 : ContinuousConstSMul R M] [inst_5 : ContinuousAdd M] {s : Submodule R M},\\n  Dense ‚Üës ‚Üî Submodule.topologicalClosure s = ‚ä§\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The intersection of a compact set and a closed set is a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s t : Set Œ±}, IsCompact s ‚Üí IsClosed t ‚Üí IsCompact (s ‚à© t)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The intersection of a closed set and a compact set is a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s t : Set Œ±}, IsCompact t ‚Üí IsClosed s ‚Üí IsCompact (s ‚à© t)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a locally compact T‚ÇÇ space, every compact set has an open neighborhood with compact closure.\\n\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LocallyCompactSpace Œ±] [inst_2 : T2Space Œ±] {K : Set Œ±},\\n  IsCompact K ‚Üí ‚àÉ V, IsOpen V ‚àß K ‚äÜ V ‚àß IsCompact (closure V)\"},\n {\"role\": \"user\", \"content\": \"In a `T2Space`, every compact set is closed. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : T2Space Œ±] {s : Set Œ±}, IsCompact s ‚Üí IsClosed s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a locally compact space, every compact set is contained in the interior of a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LocallyCompactSpace Œ±] {K : Set Œ±},\\n  IsCompact K ‚Üí ‚àÉ K', IsCompact K' ‚àß K ‚äÜ interior K'\"},\n {\"role\": \"user\",\n  \"content\": \"A closed subset of a compact set is a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s t : Set Œ±}, IsCompact s ‚Üí IsClosed t ‚Üí t ‚äÜ s ‚Üí IsCompact t\"},\n {\"role\": \"user\", \"content\": \"The underlying topological space is compact.\"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ (self : CompHaus), CompactSpace ‚Üëself.toTop\"},\n {\"role\": \"user\",\n  \"content\": \"In a compact space, the type of closed subsets is compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : EMetricSpace Œ±] [inst_1 : CompactSpace Œ±], CompactSpace (TopologicalSpace.Closeds Œ±)\"},\n {\"role\": \"user\", \"content\": \"Finite topological spaces are compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : Finite Œ±], CompactSpace Œ±\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If every compact subset of a topological space is closed, then the space is compact.\"}]"}
{"text":"In a commutative ring, the sum of idempotent elements is idempotent.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"Equivalence closure is idempotent. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} (r : Œ± ‚Üí Œ± ‚Üí Prop), EqvGen.Setoid (Setoid.Rel (EqvGen.Setoid r)) = EqvGen.Setoid r\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Commuting elements of finite order are closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Monoid G] {x y : G}, Commute x y ‚Üí IsOfFinOrder x ‚Üí IsOfFinOrder y ‚Üí IsOfFinOrder (x * y)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Commuting elements of finite additive order are closed under addition.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : AddMonoid G] {x y : G},\\n  AddCommute x y ‚Üí IsOfFinAddOrder x ‚Üí IsOfFinAddOrder y ‚Üí IsOfFinAddOrder (x + y)\"},\n {\"role\": \"user\",\n  \"content\": \"The center of a monoid acts commutatively on that monoid. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {M : Type u_1} [inst : Monoid M], SMulCommClass M { x // x ‚àà Submonoid.center M } M\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a semigroup, the product of right-regular elements is right-regular. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} [inst : Semigroup R] {a b : R}, IsRightRegular a ‚Üí IsRightRegular b ‚Üí IsRightRegular (a * b)\"},\n {\"role\": \"user\",\n  \"content\": \"Addition is commutative in an additive commutative semigroup. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {M : Type u} [self : AddCancelCommMonoid M] (a b : M), a + b = b + a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Scalar multiplication commutes with the inclusion of each component into the direct sum. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (R : Type u) [inst : Semiring R] {Œπ : Type v} [dec_Œπ : DecidableEq Œπ] {M : Œπ ‚Üí Type w}\\n  [inst_1 : (i : Œπ) ‚Üí AddCommMonoid (M i)] [inst_2 : (i : Œπ) ‚Üí Module R (M i)] (i : Œπ) (c : R) (x : M i),\\n  ‚Üë(DirectSum.of M i) (c ‚Ä¢ x) = c ‚Ä¢ ‚Üë(DirectSum.of M i) x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The sum of two elements of an additive subsemigroup belongs to the subsemigroup. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} [inst : NonAssocSemiring R] (self : Subsemiring R) {a b : R},\\n  a ‚àà self.carrier ‚Üí b ‚àà self.carrier ‚Üí a + b ‚àà self.carrier\"},\n {\"role\": \"user\",\n  \"content\": \"the condition that the given endomorphism is an idempotent \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {C : Type u_1} [inst : CategoryTheory.Category C] (self : CategoryTheory.Idempotents.Karoubi C),\\n  CategoryTheory.CategoryStruct.comp self.p self.p = self.p\"},\n {\"role\": \"user\", \"content\": \"Any element commutes with itself.\"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {S : Type u_1} [inst : Add S] (a : S), AddCommute a a\"},\n {\"role\": \"user\", \"content\": \"Any element commutes with itself. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {S : Type u_1} [inst : Mul S] (a : S), Commute a a\"},\n {\"role\": \"user\",\n  \"content\": \"Scalar multiplication commutes with direct sums. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (R : Type u) [inst : Semiring R] {Œπ : Type v} [dec_Œπ : DecidableEq Œπ] {M : Œπ ‚Üí Type w}\\n  [inst_1 : (i : Œπ) ‚Üí AddCommMonoid (M i)] [inst_2 : (i : Œπ) ‚Üí Module R (M i)] (s : Finset Œπ) (c : R)\\n  (x : (i : ‚Üë‚Üës) ‚Üí M ‚Üëi), ‚Üë(DirectSum.mk M s) (c ‚Ä¢ x) = c ‚Ä¢ ‚Üë(DirectSum.mk M s) x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"By definition, a ring isomorphism preserves the additive structure. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {F : Type u_1} {R : outParam (Type u_2)} {S : outParam (Type u_3)} [inst : Mul R] [inst_1 : Add R] [inst_2 : Mul S]\\n  [inst_3 : Add S] [self : RingEquivClass F R S] (f : F) (a b : R), ‚Üëf (a + b) = ‚Üëf a + ‚Üëf b\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Moving to the opposite additive commutative monoid commutes with summing. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ≤ : Type u} {Œ± : Type v} [inst : AddCommMonoid Œ≤] {s : Finset Œ±} (f : Œ± ‚Üí Œ≤),\\n  MulOpposite.op (Finset.sum s fun x => f x) = Finset.sum s fun x => MulOpposite.op (f x)\"},\n {\"role\": \"user\", \"content\": \"A ring isomorphism preserves multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R ‚âÉ+* S)\\n  (x y : R), ‚Üëe (x * y) = ‚Üëe x * ‚Üëe y\"},\n {\"role\": \"user\",\n  \"content\": \"Multiplication is commutative in a commutative semigroup. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [self : StrictOrderedCommRing Œ±] (a b : Œ±), a * b = b * a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A finitely generated idempotent ideal is generated by an idempotent element \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} [inst : CommRing R] (I : Ideal R),\\n  Ideal.FG I ‚Üí (IsIdempotentElem I ‚Üî ‚àÉ e, IsIdempotentElem e ‚àß I = Submodule.span R {e})\"},\n {\"role\": \"user\", \"content\": \"An abelian category is idempotent complete. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (D : Type u_1) [inst : CategoryTheory.Category D] [inst_1 : CategoryTheory.Abelian D],\\n  CategoryTheory.IsIdempotentComplete D\"},\n {\"role\": \"user\", \"content\": \"A ring isomorphism preserves addition. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R ‚âÉ+* S)\\n  (x y : R), ‚Üëe (x + y) = ‚Üëe x + ‚Üëe y\"},\n {\"role\": \"user\",\n  \"content\": \"Multiplication in a boolean ring is idempotent. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {Œ± : Type u_1} [self : BooleanRing Œ±] (a : Œ±), a * a = a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a commutative ring, the sum of idempotent elements is idempotent.\"}]"}
{"text":"The number of partitions of a finite set is a prime number.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"A finpartition gives rise to a setoid partition \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} (f : Finpartition Set.univ), Setoid.IsPartition ‚Üëf.parts\"},\n {\"role\": \"user\",\n  \"content\": \"Every finite convergent corresponds to a rational number. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K) (n : ‚Ñï),\\n  ‚àÉ q, GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n = ‚Üëq\"},\n {\"role\": \"user\", \"content\": \"The partition is supremum-independent \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : Lattice Œ±] [inst_1 : OrderBot Œ±] {a : Œ±} (self : Finpartition a), Finset.SupIndep self.parts id\"},\n {\"role\": \"user\",\n  \"content\": \"The set of finite subsets of a countable set is countable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {s : Set Œ±}, Set.Countable s ‚Üí Set.Countable {t | Set.Finite t ‚àß t ‚äÜ s}\"},\n {\"role\": \"user\",\n  \"content\": \"A Dedekind domain is a PID if its set of primes is finite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R],\\n  Set.Finite {I | Ideal.IsPrime I} ‚Üí IsPrincipalIdealRing R\"},\n {\"role\": \"user\", \"content\": \"A product of finite numbers is still finite \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œπ : Type u_2} {R : Type u_1} [inst : CommMonoidWithZero R] [inst_1 : NoZeroDivisors R] [inst_2 : Nontrivial R]\\n  [inst_3 : DecidableEq R] [inst_4 : LT R] {s : Finset Œπ} {f : Œπ ‚Üí WithTop R},\\n  (‚àÄ (i : Œπ), i ‚àà s ‚Üí f i ‚â† ‚ä§) ‚Üí (Finset.prod s fun i => f i) < ‚ä§\"},\n {\"role\": \"user\", \"content\": \"Any finitely generated ideal is principal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} [inst : CommRing R] [self : IsBezout R] (I : Ideal R), Ideal.FG I ‚Üí Submodule.IsPrincipal I\"},\n {\"role\": \"user\", \"content\": \"A finite set is bounded \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±}, Set.Finite s ‚Üí Metric.Bounded s\"},\n {\"role\": \"user\", \"content\": \"A finite union of finsets is finite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Finset Œ≤), Set.Finite (Set.range f) ‚Üí Set.Finite (‚ãÉ (a : Œ±), ‚Üë(f a))\"},\n {\"role\": \"user\",\n  \"content\": \"The only divisors of prime powers are prime powers. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : CancelCommMonoidWithZero Œ±] [dec_irr : (p : Associates Œ±) ‚Üí Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid Œ±] [dec : DecidableEq Œ±] [dec' : DecidableEq (Associates Œ±)] {a p : Associates Œ±},\\n  Irreducible p ‚Üí\\n    ‚àÄ [inst_2 : (n : ‚Ñï) ‚Üí Decidable (a ‚à£ p ^ n)] {n : ‚Ñï} (h : a ‚à£ p ^ n),\\n      a = p ^ Nat.find (_ : ‚àÉ n, (fun n => a ‚à£ p ^ n) n)\"},\n {\"role\": \"user\", \"content\": \"A minimal polynomial is prime. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\\n  IsIntegral A x ‚Üí Prime (minpoly A x)\"},\n {\"role\": \"user\",\n  \"content\": \"There are finitely many subsets of a given finite set \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {a : Set Œ±}, Set.Finite a ‚Üí Set.Finite {b | b ‚äÜ a}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The variable of the power series ring over an integral domain is prime.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R], Prime PowerSeries.X\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is cyclic.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsAddCyclic Œ±\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is cyclic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)], Fintype.card Œ± = p ‚Üí IsCyclic Œ±\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is simple.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsSimpleAddGroup Œ±\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is simple. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsSimpleGroup Œ±\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\", \"content\": \"Set.InjOn Nat.factorization {x | x ‚â† 0}\"},\n {\"role\": \"user\", \"content\": \"A finite field has prime power cardinality. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : Fintype Œ±] [inst_1 : Field Œ±], IsPrimePow (Fintype.card Œ±)\"},\n {\"role\": \"user\",\n  \"content\": \"The number of partitions of a finite set is a prime number.\"}]"}
{"text":"If a poset has a maximal element, then it has a unique minimal element.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"The image of an element of finite order has finite order. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_2} {H : Type u_1} [inst : Monoid G] [inst_1 : Monoid H] (f : G ‚Üí* H) {x : G},\\n  IsOfFinOrder x ‚Üí IsOfFinOrder (‚Üëf x)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If the quotient by an ideal is a field, then the ideal is maximal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} [inst : CommRing R] (I : Ideal R), IsField (R ‚ß∏ I) ‚Üí Ideal.IsMaximal I\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The adjoint is maximal in the sense that it contains every formal adjoint. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {ùïú : Type u_1} {E : Type u_2} {F : Type u_3} [inst : IsROrC ùïú] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : InnerProductSpace ùïú E] [inst_3 : NormedAddCommGroup F] [inst_4 : InnerProductSpace ùïú F] {T : E ‚Üí‚Çó.[ùïú] F}\\n  {S : F ‚Üí‚Çó.[ùïú] E},\\n  Dense ‚ÜëT.domain ‚Üí ‚àÄ [inst_5 : CompleteSpace E], LinearPMap.IsFormalAdjoint T S ‚Üí S ‚â§ LinearPMap.adjoint T\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A word and its maximal reduction correspond to the same element of the additive free\\ngroup.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {L : List (Œ± √ó Bool)} [inst : DecidableEq Œ±], FreeAddGroup.mk (FreeAddGroup.reduce L) = FreeAddGroup.mk L\"},\n {\"role\": \"user\",\n  \"content\": \"The only constant in a maximal ideal over a field is `0`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} [inst : Ring R],\\n  IsField R ‚Üí ‚àÄ (I : Ideal (Polynomial R)) [hI : Ideal.IsMaximal I] (x : R), ‚ÜëPolynomial.C x ‚àà I ‚Üí x = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a monoid with zero, if zero equals one, then zero is the only element. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {M‚ÇÄ : Type u_1} [inst : MulZeroOneClass M‚ÇÄ], 0 = 1 ‚Üí ‚àÄ (a : M‚ÇÄ), a = 0\"},\n {\"role\": \"user\",\n  \"content\": \"Any element of a set is more than the set infimum. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [self : CompleteSemilatticeInf Œ±] (s : Set Œ±) (a : Œ±), a ‚àà s ‚Üí sInf s ‚â§ a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a product lies in the prime ideal, then at least one element lies in the prime ideal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : Semiring Œ±] {I : Ideal Œ±} [self : Ideal.IsPrime I] {x y : Œ±}, x * y ‚àà I ‚Üí x ‚àà I ‚à® y ‚àà I\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a word reduces to another word, then they have a common maximal reduction. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {L‚ÇÅ L‚ÇÇ : List (Œ± √ó Bool)} [inst : DecidableEq Œ±],\\n  FreeGroup.Red L‚ÇÅ L‚ÇÇ ‚Üí FreeGroup.reduce L‚ÇÅ = FreeGroup.reduce L‚ÇÇ\"},\n {\"role\": \"user\",\n  \"content\": \"A nonzero ideal has an element of minimal norm. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_2} {S : Type u_1} [inst : EuclideanDomain R] [inst_1 : CommRing S] [inst_2 : IsDomain S]\\n  [inst_3 : Algebra R S] (abv : AbsoluteValue R ‚Ñ§) (I : { x // x ‚àà nonZeroDivisors (Ideal S) }),\\n  ‚àÉ b, b ‚àà ‚ÜëI ‚àß b ‚â† 0 ‚àß ‚àÄ (c : S), c ‚àà ‚ÜëI ‚Üí ‚Üëabv (‚Üë(Algebra.norm R) c) < ‚Üëabv (‚Üë(Algebra.norm R) b) ‚Üí c = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a word reduces to another word, then they have a common maximal reduction.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {L‚ÇÅ L‚ÇÇ : List (Œ± √ó Bool)} [inst : DecidableEq Œ±],\\n  FreeAddGroup.Red L‚ÇÅ L‚ÇÇ ‚Üí FreeAddGroup.reduce L‚ÇÅ = FreeAddGroup.reduce L‚ÇÇ\"},\n {\"role\": \"user\",\n  \"content\":\n  \"**Zorn's lemma**\\n\\nIf every chain has an upper bound, then there exists a maximal element. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} {r : Œ± ‚Üí Œ± ‚Üí Prop},\\n  (‚àÄ (c : Set Œ±), IsChain r c ‚Üí ‚àÉ ub, ‚àÄ (a : Œ±), a ‚àà c ‚Üí r a ub) ‚Üí\\n    (‚àÄ {a b c : Œ±}, r a b ‚Üí r b c ‚Üí r a c) ‚Üí ‚àÉ m, ‚àÄ (a : Œ±), r m a ‚Üí r a m\"},\n {\"role\": \"user\",\n  \"content\": \"A greatest element of a set is the supremum of this set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : ConditionallyCompleteLattice Œ±] {s : Set Œ±} {a : Œ±}, IsGreatest s a ‚Üí sSup s = a\"},\n {\"role\": \"user\",\n  \"content\": \"A least element of a set is the infimum of this set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : ConditionallyCompleteLattice Œ±] {s : Set Œ±} {a : Œ±}, IsLeast s a ‚Üí sInf s = a\"},\n {\"role\": \"user\",\n  \"content\": \"Any element of a set is less than the set supremum. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [self : CompleteSemilatticeSup Œ±] (s : Set Œ±) (a : Œ±), a ‚àà s ‚Üí a ‚â§ sSup s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A word and its maximal reduction correspond to the same element of the free group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {L : List (Œ± √ó Bool)} [inst : DecidableEq Œ±], FreeGroup.mk (FreeGroup.reduce L) = FreeGroup.mk L\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a poset has a maximal element, then it has a unique minimal element.\"}]"}
{"text":"The automorphism group of an Abelian group is cyclic.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Subgroups of additive torsion groups are additive torsion groups.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G], AddMonoid.IsTorsion G ‚Üí ‚àÄ (H : AddSubgroup G), AddMonoid.IsTorsion { x // x ‚àà H }\"},\n {\"role\": \"user\", \"content\": \"An abelian category has finite biproducts. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C],\\n  CategoryTheory.Limits.HasFiniteBiproducts C\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [self : LinearOrderedCommGroupWithZero Œ±] (a : Œ±), a ‚â† 0 ‚Üí a * a‚Åª¬π = 1\"},\n {\"role\": \"user\", \"content\": \"Finite groups are torsion groups. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any Haar measure is invariant under inversion in an abelian group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : CommGroup G] [inst_1 : TopologicalSpace G] [inst_2 : TopologicalGroup G] [inst_3 : T2Space G]\\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\\n  (Œº : MeasureTheory.Measure G) [inst_7 : MeasureTheory.Measure.IsHaarMeasure Œº] [inst_8 : LocallyCompactSpace G],\\n  MeasureTheory.Measure.IsInvInvariant Œº\"},\n {\"role\": \"user\",\n  \"content\": \"Abelian groups have nilpotency class at most one \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : CommGroup G], Group.nilpotencyClass G ‚â§ 1\"},\n {\"role\": \"user\", \"content\": \"A group homomorphism is a monoid homomorphism. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Group Œ±] [inst_1 : Group Œ≤] {f : Œ± ‚Üí Œ≤}, IsGroupHom f ‚Üí IsMonoidHom f\"},\n {\"role\": \"user\",\n  \"content\": \"The action of an additive group on an orbit is transitive.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : AddGroup Œ±] [inst_1 : AddAction Œ± Œ≤] (x : Œ≤),\\n  AddAction.IsPretransitive Œ± ‚Üë(AddAction.orbit Œ± x)\"},\n {\"role\": \"user\",\n  \"content\": \"The center of a group acts commutatively on that group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G], SMulCommClass G { x // x ‚àà Subgroup.center G } G\"},\n {\"role\": \"user\", \"content\": \"An abelian category is idempotent complete. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (D : Type u_1) [inst : CategoryTheory.Category D] [inst_1 : CategoryTheory.Abelian D],\\n  CategoryTheory.IsIdempotentComplete D\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The torsion submonoid of an abelian group equals the torsion subgroup as a submonoid. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (G : Type u_1) [inst : CommGroup G], CommMonoid.torsion G = (CommGroup.torsion G).toSubmonoid\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The product of group homomorphisms is a group homomorphism if the target is commutative. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Group Œ±] [inst_1 : CommGroup Œ≤] {f g : Œ± ‚Üí Œ≤},\\n  IsGroupHom f ‚Üí IsGroupHom g ‚Üí IsGroupHom fun a => f a * g a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The right regular action of an additive group on itself is transitive.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : AddGroup G], AddAction.IsPretransitive G·µÉ·µí·µñ G\"},\n {\"role\": \"user\", \"content\": \"Abelian groups are nilpotent \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The quotient by the center of a group of cardinality `p ^ 2` is cyclic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {p : ‚Ñï} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\\n  Fintype.card G = p ^ 2 ‚Üí IsCyclic (G ‚ß∏ Subgroup.center G)\"},\n {\"role\": \"user\", \"content\": \"Every subgroup of `‚Ñ§` is cyclic. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ (H : AddSubgroup ‚Ñ§), ‚àÉ a, H = AddSubgroup.closure {a}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A finite subgroup of the units of an integral domain is cyclic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (S : Subgroup RÀ£) [inst_2 : Finite { x // x ‚àà S }],\\n  IsCyclic { x // x ‚àà S }\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A finite subgroup of the unit group of an integral domain is cyclic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\\n  (f : G ‚Üí* R), Function.Injective ‚Üëf ‚Üí IsCyclic G\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is cyclic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)], Fintype.card Œ± = p ‚Üí IsCyclic Œ±\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is cyclic.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : Fintype Œ±] {p : ‚Ñï} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Œ± = p ‚Üí IsAddCyclic Œ±\"},\n {\"role\": \"user\",\n  \"content\": \"The automorphism group of an Abelian group is cyclic.\"}]"}
{"text":"If a function from the unit interval to itself has a fixed point, then it has points of all positive periods.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a function is locally Lipschitz around a point, then it is continuous at this point. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoMetricSpace Œ±] [inst_1 : PseudoMetricSpace Œ≤] {f : Œ± ‚Üí Œ≤} {x : Œ±} {r : ‚Ñù},\\n  0 < r ‚Üí ‚àÄ (K : ‚Ñù), (‚àÄ (y : Œ±), dist y x < r ‚Üí dist (f y) (f x) ‚â§ K * dist y x) ‚Üí ContinuousAt f x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `f` sends two periodic points `x` and `y` of positive periods to the same point,\\nthen `x = y`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} {f : Œ± ‚Üí Œ±} {x y : Œ±} {m n : ‚Ñï},\\n  Function.IsPeriodicPt f m x ‚Üí Function.IsPeriodicPt f n y ‚Üí 0 < m ‚Üí 0 < n ‚Üí f x = f y ‚Üí x = y\"},\n {\"role\": \"user\",\n  \"content\": \"A continuous function is bounded above on a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderClosedTopology Œ±]\\n  [inst_3 : TopologicalSpace Œ≤] [inst_4 : Nonempty Œ±] {f : Œ≤ ‚Üí Œ±} {K : Set Œ≤},\\n  IsCompact K ‚Üí ContinuousOn f K ‚Üí BddAbove (f '' K)\"},\n {\"role\": \"user\",\n  \"content\": \"A uniform limit of continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {p : Filter Œπ}\\n  [inst_1 : TopologicalSpace Œ±],\\n  TendstoUniformly F f p ‚Üí (‚àÄ·∂† (n : Œπ) in p, Continuous (F n)) ‚Üí ‚àÄ [inst_2 : Filter.NeBot p], Continuous f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If two functions are equal in the relevant interval, their interval integrals are also equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] {f g : ‚Ñù ‚Üí E} {Œº : MeasureTheory.Measure ‚Ñù}\\n  {a b : ‚Ñù}, Set.EqOn f g (Set.uIcc a b) ‚Üí ‚à´ (x : ‚Ñù) in a..b, f x ‚àÇŒº = ‚à´ (x : ‚Ñù) in a..b, g x ‚àÇŒº\"},\n {\"role\": \"user\", \"content\": \"A continuous, periodic function is bounded. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {f : ‚Ñù ‚Üí Œ±} {c : ‚Ñù},\\n  Function.Periodic f c ‚Üí c ‚â† 0 ‚Üí Continuous f ‚Üí Metric.Bounded (Set.range f)\"},\n {\"role\": \"user\", \"content\": \"For the identity map, all points are periodic. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {Œ± : Type u_1} (n : ‚Ñï) (x : Œ±), Function.IsPeriodicPt id n x\"},\n {\"role\": \"user\", \"content\": \"A constant function is uniformly integrable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {Œπ : Type u_3} {m : MeasurableSpace Œ±} (Œº : MeasureTheory.Measure Œ±)\\n  [inst : NormedAddCommGroup Œ≤] {p : ENNReal} {g : Œ± ‚Üí Œ≤},\\n  1 ‚â§ p ‚Üí p ‚â† ‚ä§ ‚Üí MeasureTheory.Mem‚Ñíp g p ‚Üí MeasureTheory.UnifIntegrable (fun x => g) p Œº\"},\n {\"role\": \"user\",\n  \"content\": \"A continuous, periodic function has compact range. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {f : ‚Ñù ‚Üí Œ±} {c : ‚Ñù},\\n  Function.Periodic f c ‚Üí c ‚â† 0 ‚Üí Continuous f ‚Üí IsCompact (Set.range f)\"},\n {\"role\": \"user\",\n  \"content\": \"The set of fixed points of a continuous map is a closed set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : T2Space Œ±] {f : Œ± ‚Üí Œ±},\\n  Continuous f ‚Üí IsClosed (Function.fixedPoints f)\"},\n {\"role\": \"user\", \"content\": \"Any point is a periodic point of period `0`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} (f : Œ± ‚Üí Œ±) (x : Œ±), Function.IsPeriodicPt f 0 x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A fixed point of `f` is a periodic point of `f` of any prescribed period. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} {f : Œ± ‚Üí Œ±} {x : Œ±}, Function.IsFixedPt f x ‚Üí ‚àÄ (n : ‚Ñï), Function.IsPeriodicPt f n x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a function from the unit interval to itself has a fixed point, then it has points of all positive periods.\"}]"}
{"text":"The complement of the union of two sets contains the union of their complements.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The supremum of two subspaces is equal to the span of their union. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (S T : Set (‚Ñô K V)),\\n  Projectivization.Subspace.span (S ‚à™ T) = Projectivization.Subspace.span S ‚äî Projectivization.Subspace.span T\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The intersection of a closed set and a compact set is a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s t : Set Œ±}, IsCompact t ‚Üí IsClosed s ‚Üí IsCompact (s ‚à© t)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If two sets belong to a filter, then their intersection belongs to the filter as well. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} (self : Filter Œ±) {x y : Set Œ±}, x ‚àà self.sets ‚Üí y ‚àà self.sets ‚Üí x ‚à© y ‚àà self.sets\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The set difference of a compact set and an open set is a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s t : Set Œ±}, IsCompact s ‚Üí IsOpen t ‚Üí IsCompact (s \\\\ t)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The union of two sets is bounded above if and only if each of the sets is.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ≥ : Type w} [inst : SemilatticeInf Œ≥] {s t : Set Œ≥}, BddBelow (s ‚à™ t) ‚Üî BddBelow s ‚àß BddBelow t\"},\n {\"role\": \"user\", \"content\": \"A finite union of finsets is finite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Finset Œ≤), Set.Finite (Set.range f) ‚Üí Set.Finite (‚ãÉ (a : Œ±), ‚Üë(f a))\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The intersection of a disjoint covering by two open sets of a clopen set will be clopen. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {Z a b : Set Œ±},\\n  IsClopen Z ‚Üí Z ‚äÜ a ‚à™ b ‚Üí IsOpen a ‚Üí IsOpen b ‚Üí Disjoint a b ‚Üí IsClopen (Z ‚à© a)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The union of all sets in a compact exhaustion equals the entire space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] (self : CompactExhaustion X),\\n  ‚ãÉ (n : ‚Ñï), CompactExhaustion.toFun self n = Set.univ\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a compact set is covered by two open sets, then we can cover it by two compact subsets. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : T2Space Œ±] {K U V : Set Œ±},\\n  IsCompact K ‚Üí IsOpen U ‚Üí IsOpen V ‚Üí K ‚äÜ U ‚à™ V ‚Üí ‚àÉ K‚ÇÅ K‚ÇÇ, IsCompact K‚ÇÅ ‚àß IsCompact K‚ÇÇ ‚àß K‚ÇÅ ‚äÜ U ‚àß K‚ÇÇ ‚äÜ V ‚àß K = K‚ÇÅ ‚à™ K‚ÇÇ\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The intersection of a compact set and a closed set is a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s t : Set Œ±}, IsCompact s ‚Üí IsClosed t ‚Üí IsCompact (s ‚à© t)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The union of two sets is bounded above if and only if each of the sets is. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ≥ : Type w} [inst : SemilatticeSup Œ≥] {s t : Set Œ≥}, BddAbove (s ‚à™ t) ‚Üî BddAbove s ‚àß BddAbove t\"},\n {\"role\": \"user\",\n  \"content\": \"The span of a union of sets is the sup of their spans. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (k : Type u_2) (V : Type u_3) {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [S : AddTorsor V P] (s t : Set P), affineSpan k (s ‚à™ t) = affineSpan k s ‚äî affineSpan k t\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The cardinality of a union is at most the sum of the cardinalities\\nof the two sets. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} (S T : Set Œ±), Cardinal.mk ‚Üë(S ‚à™ T) ‚â§ Cardinal.mk ‚ÜëS + Cardinal.mk ‚ÜëT\"},\n {\"role\": \"user\",\n  \"content\": \"The disjoint union of two compact spaces is compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] [inst_2 : CompactSpace Œ±]\\n  [inst_3 : CompactSpace Œ≤], CompactSpace (Œ± ‚äï Œ≤)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The union of two sets is bounded iff each of the sets is bounded. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s t : Set Œ±}, Metric.Bounded (s ‚à™ t) ‚Üî Metric.Bounded s ‚àß Metric.Bounded t\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The indicator of a disjoint union of two sets is the sum of the indicators of the sets. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} {E : Type u_2} {m0 : MeasurableSpace Œ±} {p : ENNReal} {Œº : MeasureTheory.Measure Œ±}\\n  [inst : NormedAddCommGroup E] {s t : Set Œ±} (hs : MeasurableSet s) (ht : MeasurableSet t) (hŒºs : ‚Üë‚ÜëŒº s ‚â† ‚ä§)\\n  (hŒºt : ‚Üë‚ÜëŒº t ‚â† ‚ä§),\\n  s ‚à© t = ‚àÖ ‚Üí\\n    ‚àÄ (c : E),\\n      MeasureTheory.indicatorConstLp p (_ : MeasurableSet (s ‚à™ t)) (_ : ‚Üë‚ÜëŒº (s ‚à™ t) ‚â† ‚ä§) c =\\n        MeasureTheory.indicatorConstLp p hs hŒºs c + MeasureTheory.indicatorConstLp p ht hŒºt c\"},\n {\"role\": \"user\", \"content\": \"The union of two bounded sets is bounded. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s t : Set Œ±}, Metric.Bounded s ‚Üí Metric.Bounded t ‚Üí Metric.Bounded (s ‚à™ t)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The complement of a set has the same frontier as the original set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] (s : Set Œ±), frontier s·∂ú = frontier s\"},\n {\"role\": \"user\", \"content\": \"The complement of a closed set is an open set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±} [self : IsClosed s], IsOpen s·∂ú\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The complement of the union of two sets contains the union of their complements.\"}]"}
{"text":"The square root of an rational number is rational.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A quadratic has roots if and only if its discriminant equals some square.\\n\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} [inst : CommRing R] {a b c : R} [inst_1 : NeZero 2] [inst_2 : NoZeroDivisors R],\\n  a ‚â† 0 ‚Üí ‚àÄ (x : R), a * x * x + b * x + c = 0 ‚Üî discrim a b c = (2 * a * x + b) ^ 2\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A quadratic has no root if its discriminant has no square root. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} [inst : CommRing R] {a b c : R},\\n  (‚àÄ (s : R), discrim a b c ‚â† s ^ 2) ‚Üí ‚àÄ (x : R), a * x * x + b * x + c ‚â† 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"There is a rational power between any two positive elements of an archimedean ordered field. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {n : ‚Ñï} {Œ± : Type u_1} [inst : LinearOrderedField Œ±] [inst_1 : Archimedean Œ±],\\n  n ‚â† 0 ‚Üí ‚àÄ {x y : Œ±}, x < y ‚Üí 0 < y ‚Üí ‚àÉ q, 0 < q ‚àß x < ‚Üëq ^ n ‚àß ‚Üëq ^ n < y\"},\n {\"role\": \"user\",\n  \"content\": \"The conjugate of the golden ratio is irrational. \"},\n {\"role\": \"assistant\", \"content\": \"Irrational goldenConj\"},\n {\"role\": \"user\",\n  \"content\": \"An ideal is radical iff it is equal to its radical. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} [inst : CommSemiring R] {I : Ideal R}, Ideal.radical I = I ‚Üî Ideal.IsRadical I\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Commutativity of a square is preserved when taking quotients by an ideal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} {S : Type v} [inst : CommRing R] [inst_1 : CommRing S] {R' : Type u_1} {S' : Type u_2}\\n  [inst_2 : CommRing R'] [inst_3 : CommRing S'] {f : R ‚Üí+* S} {f' : R' ‚Üí+* S'} {g : R ‚Üí+* R'} {g' : S ‚Üí+* S'}\\n  (hfg : RingHom.comp f' g = RingHom.comp g' f) (I : Ideal S'),\\n  let leq := (_ : Ideal.comap f (Ideal.comap g' I) ‚â§ Ideal.comap g (Ideal.comap f' I));\\n  RingHom.comp (Ideal.quotientMap I g' (_ : Ideal.comap g' I ‚â§ Ideal.comap g' I))\\n      (Ideal.quotientMap (Ideal.comap g' I) f\\n        (_ : Ideal.comap f (Ideal.comap g' I) ‚â§ Ideal.comap f (Ideal.comap g' I))) =\\n    RingHom.comp (Ideal.quotientMap I f' (_ : Ideal.comap f' I ‚â§ Ideal.comap f' I))\\n      (Ideal.quotientMap (Ideal.comap f' I) g leq)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The numerator and denominator are coprime: it is in \\\"reduced form\\\". \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ (self : ‚Ñö), Nat.coprime (Int.natAbs self.num) self.den\"},\n {\"role\": \"user\", \"content\": \"**Irrationality of the Square Root of 2** \"},\n {\"role\": \"assistant\", \"content\": \"Irrational (Real.sqrt 2)\"},\n {\"role\": \"user\",\n  \"content\": \"A quadratic has roots if its discriminant has square roots \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u_1} [inst : Field K] [inst_1 : NeZero 2] {a b c : K},\\n  a ‚â† 0 ‚Üí (‚àÉ s, discrim a b c = s * s) ‚Üí ‚àÉ x, a * x * x + b * x + c = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The product of a Liouville number and a nonzero rational number is again a Liouville number.  \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {p x : ‚Ñù} {r : ‚Ñö}, LiouvilleWith p x ‚Üí r ‚â† 0 ‚Üí LiouvilleWith p (x * ‚Üër)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"An algebraic integer whose conjugates are all of norm one is a root of unity. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (K : Type u_1) [inst : Field K] [inst_1 : NumberField K] (A : Type u_2) [inst_2 : NormedField A]\\n  [inst_3 : IsAlgClosed A] [inst_4 : NormedAlgebra ‚Ñö A] {x : K},\\n  IsIntegral ‚Ñ§ x ‚Üí (‚àÄ (œÜ : K ‚Üí+* A), ‚Äñ‚ÜëœÜ x‚Äñ = 1) ‚Üí ‚àÉ n x_1, x ^ n = 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The real square root is at most the natural square root plus one \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {a : ‚Ñï}, Real.sqrt ‚Üëa ‚â§ ‚Üë(Nat.sqrt a) + 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"There is an irrational number `r` between any two reals `x < r < y`. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {x y : ‚Ñù}, x < y ‚Üí ‚àÉ r, Irrational r ‚àß x < r ‚àß r < y\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Rational numbers are dense in a linear ordered archimedean field. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {ùïú : Type u_1} [inst : LinearOrderedField ùïú] [inst_1 : TopologicalSpace ùïú] [inst_2 : OrderTopology ùïú]\\n  [inst_3 : Archimedean ùïú], DenseRange Rat.cast\"},\n {\"role\": \"user\",\n  \"content\": \"The natural square root is at most the real square root \"},\n {\"role\": \"assistant\", \"content\": \"‚àÄ {a : ‚Ñï}, ‚Üë(Nat.sqrt a) ‚â§ Real.sqrt ‚Üëa\"},\n {\"role\": \"user\", \"content\": \"A transcendental real number is irrational. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {r : ‚Ñù}, Transcendental ‚Ñö r ‚Üí Irrational r\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A rational number has only finitely many good rational approximations. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ (Œæ : ‚Ñö), Set.Finite {q | |Œæ - q| < 1 / ‚Üëq.den ^ 2}\"},\n {\"role\": \"user\",\n  \"content\": \"The continued fraction of a rational number terminates. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (q : ‚Ñö), GeneralizedContinuedFraction.Terminates (GeneralizedContinuedFraction.of q)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every terminating continued fraction corresponds to a rational number. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] {v : K},\\n  GeneralizedContinuedFraction.Terminates (GeneralizedContinuedFraction.of v) ‚Üí ‚àÉ q, v = ‚Üëq\"},\n {\"role\": \"user\",\n  \"content\": \"Every finite convergent corresponds to a rational number. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K) (n : ‚Ñï),\\n  ‚àÉ q, GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n = ‚Üëq\"},\n {\"role\": \"user\",\n  \"content\": \"The square root of an rational number is rational.\"}]"}
{"text":"If a module over a ring is free, then the ring is commutative.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"The center of a monoid acts commutatively on that monoid. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {M : Type u_1} [inst : Monoid M], SMulCommClass M { x // x ‚àà Submonoid.center M } M\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A commutative star monoid is a star module over itself via `Monoid.toMulAction`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} [inst : CommMonoid R] [inst_1 : StarSemigroup R], StarModule R R\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any injective endomorphism of an Artinian module is surjective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsArtinian R M] (f : M ‚Üí‚Çó[R] M), Function.Injective ‚Üëf ‚Üí Function.Surjective ‚Üëf\"},\n {\"role\": \"user\", \"content\": \"The module of finite matrices is free. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (R : Type u) (M : Type v) [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\\n  [inst_3 : Module.Free R M] {m : Type u_1} {n : Type u_2} [inst_4 : Finite m] [inst_5 : Finite n],\\n  Module.Free R (Matrix m n M)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The rank of a finite product of free modules is the sum of the ranks. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u} {Œ∑ : Type u‚ÇÅ'} {œÜ : Œ∑ ‚Üí Type u_1} [inst : Ring K] [inst_1 : StrongRankCondition K]\\n  [inst_2 : (i : Œ∑) ‚Üí AddCommGroup (œÜ i)] [inst_3 : (i : Œ∑) ‚Üí Module K (œÜ i)] [inst_4 : ‚àÄ (i : Œ∑), Module.Free K (œÜ i)]\\n  [inst_5 : Finite Œ∑], Module.rank K ((i : Œ∑) ‚Üí œÜ i) = Cardinal.sum fun i => Module.rank K (œÜ i)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any surjective endomorphism of a Noetherian module is bijective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsNoetherian R M] (f : M ‚Üí‚Çó[R] M), Function.Surjective ‚Üëf ‚Üí Function.Bijective ‚Üëf\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any surjective endomorphism of a Noetherian module is injective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsNoetherian R M] (f : M ‚Üí‚Çó[R] M), Function.Surjective ‚Üëf ‚Üí Function.Injective ‚Üëf\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Quotienting by the torsion submodule gives a torsion-free module. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_2} {M : Type u_1} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M],\\n  Submodule.torsion R (M ‚ß∏ Submodule.torsion R M) = ‚ä•\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The category of modules has enough projectives, since every module is a quotient of a free\\nmodule. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} [inst : Ring R], CategoryTheory.EnoughProjectives (ModuleCat R)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A module over a semiring is `Finite` if it is finitely generated as a module. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\\n  [self : Module.Finite R M], Submodule.FG ‚ä§\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two finite and free modules are isomorphic if and only if they have the same (finite) rank. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} {M : Type v} {N : Type w} [inst : Ring R] [inst_1 : StrongRankCondition R] [inst_2 : AddCommGroup M]\\n  [inst_3 : Module R M] [inst_4 : Module.Free R M] [inst_5 : Module.Finite R M] [inst_6 : AddCommGroup N]\\n  [inst_7 : Module R N] [inst_8 : Module.Free R N] [inst_9 : Module.Finite R N],\\n  Nonempty (M ‚âÉ‚Çó[R] N) ‚Üî FiniteDimensional.finrank R M = FiniteDimensional.finrank R N\"},\n {\"role\": \"user\",\n  \"content\": \"A module with a finite ring of scalars is additively torsion. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (R : Type u_1) (M : Type u_2) [inst : AddCommMonoid M] [inst_1 : Ring R] [inst_2 : Finite R] [inst_3 : Module R M],\\n  AddMonoid.IsTorsion M\"},\n {\"role\": \"user\", \"content\": \"Modules over the trivial ring are Noetherian. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (R : Type u_1) (M : Type u_2) [inst : Subsingleton R] [inst : Semiring R] [inst_1 : AddCommMonoid M]\\n  [inst_2 : Module R M], IsNoetherian R M\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The lattice of submodules of a module over a division ring is atomistic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u_1} {V : Type u} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\\n  IsAtomistic (Submodule K V)\"},\n {\"role\": \"user\",\n  \"content\": \"The product of finitely many free modules is free. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œπ : Type u_1} (R : Type u) [inst : Semiring R] (M : Œπ ‚Üí Type u_2) [inst_1 : Finite Œπ]\\n  [inst_2 : (i : Œπ) ‚Üí AddCommMonoid (M i)] [inst_3 : (i : Œπ) ‚Üí Module R (M i)]\\n  [inst_4 : ‚àÄ (i : Œπ), Module.Free R (M i)], Module.Free R ((i : Œπ) ‚Üí M i)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A module over a division ring is noetherian if and only if it is finitely generated. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\\n  IsNoetherian K V ‚Üî Module.Finite K V\"},\n {\"role\": \"user\",\n  \"content\": \"If a module over a ring is free, then the ring is commutative.\"}]"}
{"text":"If the set of units of a ring forms a group then the ring is commutative.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"Multiplication is monotone in an ordered commutative group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [self : OrderedCommGroup Œ±] (a b : Œ±), a ‚â§ b ‚Üí ‚àÄ (c : Œ±), c * a ‚â§ c * b\"},\n {\"role\": \"user\",\n  \"content\": \"Any commutative ring satisfies the `StrongRankCondition`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (R : Type u_1) [inst : CommRing R] [inst_1 : Nontrivial R], StrongRankCondition R\"},\n {\"role\": \"user\", \"content\": \"Any element commutes with itself.\"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {S : Type u_1} [inst : Add S] (a : S), AddCommute a a\"},\n {\"role\": \"user\", \"content\": \"Multiplication is commutative. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [self : SeminormedCommRing Œ±] (x y : Œ±), x * y = y * x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A finite subgroup of the unit group of an integral domain is cyclic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\\n  (f : G ‚Üí* R), Function.Injective ‚Üëf ‚Üí IsCyclic G\"},\n {\"role\": \"user\", \"content\": \"A ring isomorphism preserves multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R ‚âÉ+* S)\\n  (x y : R), ‚Üëe (x * y) = ‚Üëe x * ‚Üëe y\"},\n {\"role\": \"user\", \"content\": \"Any element commutes with itself. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {S : Type u_1} [inst : Mul S] (a : S), Commute a a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Commuting elements of finite order are closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Monoid G] {x y : G}, Commute x y ‚Üí IsOfFinOrder x ‚Üí IsOfFinOrder y ‚Üí IsOfFinOrder (x * y)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A finite subgroup of the units of an integral domain is cyclic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (S : Subgroup RÀ£) [inst_2 : Finite { x // x ‚àà S }],\\n  IsCyclic { x // x ‚àà S }\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The prime spectrum of a commutative ring is a compact topological space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} [inst : CommRing R], CompactSpace (PrimeSpectrum R)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If all prime ideals in a commutative ring are principal, so are all other ideals. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} [inst : CommRing R],\\n  (‚àÄ (P : Ideal R), Ideal.IsPrime P ‚Üí Submodule.IsPrincipal P) ‚Üí IsPrincipalIdealRing R\"},\n {\"role\": \"user\", \"content\": \"A group homomorphism is a monoid homomorphism. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Group Œ±] [inst_1 : Group Œ≤] {f : Œ± ‚Üí Œ≤}, IsGroupHom f ‚Üí IsMonoidHom f\"},\n {\"role\": \"user\",\n  \"content\": \"Composition of non-unital ring homomorphisms is associative. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_3} {Œ≥ : Type u_4} [inst : NonUnitalNonAssocSemiring Œ±]\\n  [inst_1 : NonUnitalNonAssocSemiring Œ≤] [inst_2 : NonUnitalNonAssocSemiring Œ≥] {Œ¥ : Type u_1}\\n  {x : NonUnitalNonAssocSemiring Œ¥} (f : Œ± ‚Üí‚Çô+* Œ≤) (g : Œ≤ ‚Üí‚Çô+* Œ≥) (h : Œ≥ ‚Üí‚Çô+* Œ¥),\\n  NonUnitalRingHom.comp (NonUnitalRingHom.comp h g) f = NonUnitalRingHom.comp h (NonUnitalRingHom.comp g f)\"},\n {\"role\": \"user\", \"content\": \"Fields are commutative. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} [inst : Semiring R], IsField R ‚Üí ‚àÄ (x y : R), x * y = y * x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The inverse of a group homomorphism is a group homomorphism if the target is commutative. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Group Œ±] [inst_1 : CommGroup Œ≤] {f : Œ± ‚Üí Œ≤},\\n  IsGroupHom f ‚Üí IsGroupHom fun a => (f a)‚Åª¬π\"},\n {\"role\": \"user\",\n  \"content\": \"Multiplication is commutative in a commutative semigroup. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [self : StrictOrderedCommRing Œ±] (a b : Œ±), a * b = b * a\"},\n {\"role\": \"user\",\n  \"content\": \"The center of a monoid acts commutatively on that monoid. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {M : Type u_1} [inst : Monoid M], SMulCommClass M { x // x ‚àà Submonoid.center M } M\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The group of units of a complete normed ring is an open subset of the ring. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R], IsOpen {x | IsUnit x}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The product of group homomorphisms is a group homomorphism if the target is commutative. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Group Œ±] [inst_1 : CommGroup Œ≤] {f g : Œ± ‚Üí Œ≤},\\n  IsGroupHom f ‚Üí IsGroupHom g ‚Üí IsGroupHom fun a => f a * g a\"},\n {\"role\": \"user\",\n  \"content\": \"The center of a group acts commutatively on that group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {G : Type u_1} [inst : Group G], SMulCommClass G { x // x ‚àà Subgroup.center G } G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If the set of units of a ring forms a group then the ring is commutative.\"}]"}
{"text":"Every natural number larger than `10` is the sum of a square and a prime.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a small natural number is divisible by a larger natural number,\\nthe small number is zero. \"},\n {\"role\": \"assistant\", \"content\": \"‚àÄ {a b : ‚Ñï}, a ‚à£ b ‚Üí b < a ‚Üí b = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {m n : ‚Ñï}, (‚àÄ (a : ‚Ñï), a ‚à£ m ‚Üî a ‚à£ n) ‚Üî m = n\"},\n {\"role\": \"user\",\n  \"content\": \"All composite numbers are Fermat pseudoprimes to base 1.\\n\"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {n : ‚Ñï}, 1 < n ‚Üí ¬¨Nat.Prime n ‚Üí FermatPsp n 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {m n : ‚Ñï}, (‚àÄ (a : ‚Ñï), m ‚à£ a ‚Üî n ‚à£ a) ‚Üî m = n\"},\n {\"role\": \"user\",\n  \"content\": \"The natural square root is at most the real square root \"},\n {\"role\": \"assistant\", \"content\": \"‚àÄ {a : ‚Ñï}, ‚Üë(Nat.sqrt a) ‚â§ Real.sqrt ‚Üëa\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ (n : ‚Ñï), Nat.factorization n = 0 ‚Üî n = 0 ‚à® n = 1\"},\n {\"role\": \"user\",\n  \"content\": \"The only divisors of prime powers are prime powers. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : CancelCommMonoidWithZero Œ±] [dec_irr : (p : Associates Œ±) ‚Üí Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid Œ±] [dec : DecidableEq Œ±] [dec' : DecidableEq (Associates Œ±)] {a p : Associates Œ±},\\n  Irreducible p ‚Üí\\n    ‚àÄ [inst_2 : (n : ‚Ñï) ‚Üí Decidable (a ‚à£ p ^ n)] {n : ‚Ñï} (h : a ‚à£ p ^ n),\\n      a = p ^ Nat.find (_ : ‚àÉ n, (fun n => a ‚à£ p ^ n) n)\"},\n {\"role\": \"user\",\n  \"content\": \"The exponential characteristic is a prime number or one. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (R : Type u) [inst : Semiring R] (q : ‚Ñï) [hq : ExpChar R q], Nat.Prime q ‚à® q = 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A prime natural number is prime in `‚Ñ§[i]` if and only if it is `3` mod `4` \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ (p : ‚Ñï) [inst : Fact (Nat.Prime p)], Prime ‚Üëp ‚Üî p % 4 = 3\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The real square root is at most the natural square root plus one \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {a : ‚Ñï}, Real.sqrt ‚Üëa ‚â§ ‚Üë(Nat.sqrt a) + 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {n : ‚Ñï}, IsSquare (-1) ‚Üí ‚àÉ x y, n = x ^ 2 + y ^ 2\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The square of the smallest prime factor of a composite number `n` is at most `n`.\\n\"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {n : ‚Ñï}, 0 < n ‚Üí ¬¨Nat.Prime n ‚Üí Nat.minFac n ^ 2 ‚â§ n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {a b x y u v : ‚Ñï}, a = x ^ 2 + y ^ 2 ‚Üí b = u ^ 2 + v ^ 2 ‚Üí ‚àÉ r s, a * b = r ^ 2 + s ^ 2\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\", \"content\": \"Set.InjOn Nat.factorization {x | x ‚â† 0}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every natural number larger than `10` is the sum of a square and a prime.\"}]"}
{"text":"The initial object of a category is isomorphic to its terminal object.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"Any morphism from a terminal object is split mono. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X Y : C},\\n  CategoryTheory.Limits.IsTerminal X ‚Üí ‚àÄ (f : X ‚ü∂ Y), CategoryTheory.IsSplitMono f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The forgetful functor from monoid objects to the ambient category reflects isomorphisms. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.MonoidalCategory C],\\n  CategoryTheory.ReflectsIsomorphisms (Mon_.forget C)\"},\n {\"role\": \"user\",\n  \"content\": \"Each connected component of the category is connected. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {J : Type u‚ÇÅ} [inst : CategoryTheory.Category J] (j : CategoryTheory.ConnectedComponents J),\\n  CategoryTheory.IsConnected (CategoryTheory.Component j)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The map from the (any as stated) initial object to any other object is a\\nmonomorphism \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] [self : CategoryTheory.Limits.InitialMonoClass C] {I : C} (X : C)\\n  (hI : CategoryTheory.Limits.IsInitial I), CategoryTheory.Mono (CategoryTheory.Limits.IsInitial.to hI X)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any category with pushouts and initial object has binary coproducts. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (C : Type u) [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C]\\n  [inst_2 : CategoryTheory.Limits.HasPushouts C], CategoryTheory.Limits.HasBinaryCoproducts C\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A category in which coimage-image comparisons are all isomorphisms has images. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Preadditive C]\\n  [inst_2 : CategoryTheory.Limits.HasKernels C] [inst_3 : CategoryTheory.Limits.HasCokernels C]\\n  [inst_4 : ‚àÄ {X Y : C} (f : X ‚ü∂ Y), CategoryTheory.IsIso (CategoryTheory.Abelian.coimageImageComparison f)],\\n  CategoryTheory.Limits.HasImages C\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a connected category, any two objects are related by `Zigzag`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {J : Type u‚ÇÅ} [inst : CategoryTheory.Category J] [inst_1 : CategoryTheory.IsConnected J] (j‚ÇÅ j‚ÇÇ : J),\\n  CategoryTheory.Zigzag j‚ÇÅ j‚ÇÇ\"},\n {\"role\": \"user\",\n  \"content\": \"A category with finite biproducts has a zero object. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (C : Type u) [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\\n  [inst_2 : CategoryTheory.Limits.HasFiniteBiproducts C], CategoryTheory.Limits.HasZeroObject C\"},\n {\"role\": \"user\", \"content\": \"Any morphism to an initial object is epi. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X Y : C},\\n  CategoryTheory.Limits.IsInitial X ‚Üí ‚àÄ (f : Y ‚ü∂ X), CategoryTheory.Epi f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If there are zero morphisms, any terminal object is a zero object. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], CategoryTheory.Limits.HasZeroObject C\"},\n {\"role\": \"user\",\n  \"content\": \"Any two morphisms from an initial object are equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X Y : C}, CategoryTheory.Limits.IsInitial X ‚Üí ‚àÄ (f g : X ‚ü∂ Y), f = g\"},\n {\"role\": \"user\", \"content\": \"Any morphism from a terminal object is mono. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X Y : C},\\n  CategoryTheory.Limits.IsTerminal X ‚Üí ‚àÄ (f : X ‚ü∂ Y), CategoryTheory.Mono f\"},\n {\"role\": \"user\", \"content\": \"The category `D` has isomorphic objects equal \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D]\\n  {F : CategoryTheory.Functor D C}, CategoryTheory.IsSkeletonOf C D F ‚Üí CategoryTheory.Skeletal D\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The subcategory of subterminal objects is an exponential ideal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasFiniteProducts C]\\n  [inst_2 : CategoryTheory.CartesianClosed C], CategoryTheory.ExponentialIdeal (CategoryTheory.subterminalInclusion C)\"},\n {\"role\": \"user\",\n  \"content\": \"Any two morphisms to a terminal object are equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X Y : C},\\n  CategoryTheory.Limits.IsTerminal X ‚Üí ‚àÄ (f g : Y ‚ü∂ X), f = g\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The initial object of a category is isomorphic to its terminal object.\"}]"}
{"text":"If the composition of two functions is continuous, then each of them is continuous.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"A continuous function is bounded below on a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderClosedTopology Œ±]\\n  [inst_3 : TopologicalSpace Œ≤] [inst_4 : Nonempty Œ±] {f : Œ≤ ‚Üí Œ±} {K : Set Œ≤},\\n  IsCompact K ‚Üí ContinuousOn f K ‚Üí BddBelow (f '' K)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If two functions are equal in the relevant interval, their interval integrals are also equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] {f g : ‚Ñù ‚Üí E} {Œº : MeasureTheory.Measure ‚Ñù}\\n  {a b : ‚Ñù}, Set.EqOn f g (Set.uIcc a b) ‚Üí ‚à´ (x : ‚Ñù) in a..b, f x ‚àÇŒº = ‚à´ (x : ‚Ñù) in a..b, g x ‚àÇŒº\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A sequentially continuous function defined on a sequential space is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : SequentialSpace X]\\n  {f : X ‚Üí Y}, SeqContinuous f ‚Üí Continuous f\"},\n {\"role\": \"user\",\n  \"content\": \"A locally uniform limit of continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {p : Filter Œπ}\\n  [inst_1 : TopologicalSpace Œ±],\\n  TendstoLocallyUniformly F f p ‚Üí (‚àÄ·∂† (n : Œπ) in p, Continuous (F n)) ‚Üí ‚àÄ [inst_2 : Filter.NeBot p], Continuous f\"},\n {\"role\": \"user\",\n  \"content\": \"A continuous function is bounded above on a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderClosedTopology Œ±]\\n  [inst_3 : TopologicalSpace Œ≤] [inst_4 : Nonempty Œ±] {f : Œ≤ ‚Üí Œ±} {K : Set Œ≤},\\n  IsCompact K ‚Üí ContinuousOn f K ‚Üí BddAbove (f '' K)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A function which can be locally uniformly approximated by continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤} [inst_1 : TopologicalSpace Œ±],\\n  (‚àÄ (x : Œ±) (u : Set (Œ≤ √ó Œ≤)),\\n      u ‚àà uniformity Œ≤ ‚Üí ‚àÉ t, t ‚àà nhds x ‚àß ‚àÉ F, ContinuousAt F x ‚àß ‚àÄ (y : Œ±), y ‚àà t ‚Üí (f y, F y) ‚àà u) ‚Üí\\n    Continuous f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Each function of a uniformly equicontinuous family is uniformly continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] {F : Œπ ‚Üí Œ≤ ‚Üí Œ±},\\n  UniformEquicontinuous F ‚Üí ‚àÄ (i : Œπ), UniformContinuous (F i)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A function which can be uniformly approximated by continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤} [inst_1 : TopologicalSpace Œ±],\\n  (‚àÄ (u : Set (Œ≤ √ó Œ≤)), u ‚àà uniformity Œ≤ ‚Üí ‚àÉ F, Continuous F ‚àß ‚àÄ (y : Œ±), (f y, F y) ‚àà u) ‚Üí Continuous f\"},\n {\"role\": \"user\",\n  \"content\": \"Each function of an equicontinuous family is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œπ : Type u_1} {X : Type u_2} {Œ± : Type u_3} [inst : TopologicalSpace X] [inst_1 : UniformSpace Œ±] {F : Œπ ‚Üí X ‚Üí Œ±},\\n  Equicontinuous F ‚Üí ‚àÄ (i : Œπ), Continuous (F i)\"},\n {\"role\": \"user\",\n  \"content\": \"A uniform limit of continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {p : Filter Œπ}\\n  [inst_1 : TopologicalSpace Œ±],\\n  TendstoUniformly F f p ‚Üí (‚àÄ·∂† (n : Œπ) in p, Continuous (F n)) ‚Üí ‚àÄ [inst_2 : Filter.NeBot p], Continuous f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If two continuous functions are equal on a dense set, then they are equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] [inst_2 : T2Space Œ±] {s : Set Œ≤},\\n  Dense s ‚Üí ‚àÄ {f g : Œ≤ ‚Üí Œ±}, Continuous f ‚Üí Continuous g ‚Üí Set.EqOn f g s ‚Üí f = g\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If two continuous functions are a.e. equal, then they are equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\\n  [inst_2 : T2Space Y] {Œº : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure Œº] {f g : X ‚Üí Y},\\n  f =·∂†[MeasureTheory.Measure.ae Œº] g ‚Üí Continuous f ‚Üí Continuous g ‚Üí f = g\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If the composition of two functions is continuous, then each of them is continuous.\"}]"}
{"text":"If `a` commutes with `b` and `b` commutes with `c` then `a` commutes with `c`.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"Equality behind `Commute a b`; useful for rewriting. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {S : Type u_1} [inst : Mul S] {a b : S}, Commute a b ‚Üí a * b = b * a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"`X` commutes with everything, even when the coefficients are noncommutative. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} [inst : Semiring R] {p : Polynomial R}, Polynomial.X * p = p * Polynomial.X\"},\n {\"role\": \"user\", \"content\": \"If `a % b = c` then `b` divides `a - c`. \"},\n {\"role\": \"assistant\", \"content\": \"‚àÄ {a b c : ‚Ñ§}, a % b = c ‚Üí b ‚à£ a - c\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Transitivity for `BEq`. If `a == b` and `b == c` then `a == c`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : BEq Œ±] [self : PartialEquivBEq Œ±] {a b c : Œ±},\\n  (a == b) = true ‚Üí (b == c) = true ‚Üí (a == c) = true\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `a` and `b` fall within the same cycle WRT `c`, then they are congruent modulo `p`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : LinearOrderedAddCommGroup Œ±] [hŒ± : Archimedean Œ±] {p : Œ±} (hp : 0 < p) {a b c : Œ±},\\n  toIcoMod hp c a = toIcoMod hp c b ‚Üî a ‚â° b [PMOD p]\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For every pair of elements `a` and `b` there is a `c` such that `r a c` and `r b c` \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} {r : Œ± ‚Üí Œ± ‚Üí Prop} [self : IsDirected Œ± r] (a b : Œ±), ‚àÉ c, r a c ‚àß r b c\"},\n {\"role\": \"user\",\n  \"content\": \"If `c ‚Ä¢ a < c ‚Ä¢ b` for some positive `c`, then `a < b`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} {M : Type u_2} [inst : OrderedSemiring R] [inst_1 : OrderedAddCommMonoid M] [inst_2 : SMulWithZero R M]\\n  [self : OrderedSMul R M] {a b : M} {c : R}, c ‚Ä¢ a < c ‚Ä¢ b ‚Üí 0 < c ‚Üí a < b\"},\n {\"role\": \"user\", \"content\": \"Any element commutes with itself.\"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {S : Type u_1} [inst : Add S] (a : S), AddCommute a a\"},\n {\"role\": \"user\", \"content\": \"Any element commutes with itself. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {S : Type u_1} [inst : Mul S] (a : S), Commute a a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If both `a` and `b` commute with `c`, then their product commutes with `c`.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a c ‚Üí AddCommute b c ‚Üí AddCommute (a + b) c\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If both `a` and `b` commute with `c`, then their product commutes with `c`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a c ‚Üí Commute b c ‚Üí Commute (a * b) c\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `a` commutes with both `b` and `c`, then it commutes with their sum.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a b ‚Üí AddCommute a c ‚Üí AddCommute a (b + c)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `a` commutes with both `b` and `c`, then it commutes with their product. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b ‚Üí Commute a c ‚Üí Commute a (b * c)\"},\n {\"role\": \"user\",\n  \"content\": \"If `a` commutes with `b`, then `b` commutes with `a`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {S : Type u_1} [inst : Mul S] {a b : S}, Commute a b ‚Üí Commute b a\"},\n {\"role\": \"user\",\n  \"content\": \"If `a` commutes with `b`, then `b` commutes with `a`.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {S : Type u_1} [inst : Add S] {a b : S}, AddCommute a b ‚Üí AddCommute b a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `a` commutes with `b` and `b` commutes with `c` then `a` commutes with `c`.\"}]"}
{"text":"If an element maps to zero under a ring homomorphism, then it is zero.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"The ring homomorphism is surjective \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R‚ÇÅ : Type u_1} {R‚ÇÇ : Type u_2} [inst : Semiring R‚ÇÅ] [inst_1 : Semiring R‚ÇÇ] {œÉ : R‚ÇÅ ‚Üí+* R‚ÇÇ}\\n  [self : RingHomSurjective œÉ], Function.Surjective ‚ÜëœÉ\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If two ring homomorphisms are equal on a set, then they are equal on its subsemiring closure. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} {S : Type v} [inst : NonAssocSemiring R] [inst_1 : NonAssocSemiring S] {f g : R ‚Üí+* S} {s : Set R},\\n  Set.EqOn (‚Üëf) (‚Üëg) s ‚Üí Set.EqOn ‚Üëf ‚Üëg ‚Üë(Subsemiring.closure s)\"},\n {\"role\": \"user\",\n  \"content\": \"In degree `0`, the null homotopic map `HœÉ` is zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {C : Type u_2} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Preadditive C]\\n  {X : CategoryTheory.SimplicialObject C} (q : ‚Ñï), HomologicalComplex.Hom.f (AlgebraicTopology.DoldKan.HœÉ q) 0 = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In an integral domain, a sum indexed by a nontrivial homomorphism from a finite group is zero.\\n\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Fintype G]\\n  (f : G ‚Üí* R), f ‚â† 1 ‚Üí (Finset.sum Finset.univ fun g => ‚Üëf g) = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If two ring homomorphisms are equal on a set, then they are equal on its subfield closure. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {K : Type u} {L : Type v} [inst : Field K] [inst_1 : Field L] {f g : K ‚Üí+* L} {s : Set K},\\n  Set.EqOn (‚Üëf) (‚Üëg) s ‚Üí Set.EqOn ‚Üëf ‚Üëg ‚Üë(Subfield.closure s)\"},\n {\"role\": \"user\", \"content\": \"Ring homomorphisms map one to one. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {x : NonAssocSemiring Œ±} {x_1 : NonAssocSemiring Œ≤} (f : Œ± ‚Üí+* Œ≤), ‚Üëf 1 = 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If the algebra map `R ‚Üí+* A` is injective and `R` has characteristic zero then so does `A`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} {A : Type u_2} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A],\\n  Function.Injective ‚Üë(algebraMap R A) ‚Üí ‚àÄ [inst : CharZero R], CharZero A\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a monoid with zero, zero equals one if and only if all elements of that semiring\\nare equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {M‚ÇÄ : Type u_1} [inst : MulZeroOneClass M‚ÇÄ], 0 = 1 ‚Üî Subsingleton M‚ÇÄ\"},\n {\"role\": \"user\",\n  \"content\": \"A ring is a `‚Ñö`-algebra iff it has equal characteristic zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (R : Type u_1) [inst : CommRing R], Nonempty (Algebra ‚Ñö R) ‚Üî ‚àÄ (I : Ideal R), I ‚â† ‚ä§ ‚Üí CharZero (R ‚ß∏ I)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If two ring homomorphisms are equal on a set, then they are equal on its subring closure. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] {f g : R ‚Üí+* S} {s : Set R},\\n  Set.EqOn (‚Üëf) (‚Üëg) s ‚Üí Set.EqOn ‚Üëf ‚Üëg ‚Üë(Subring.closure s)\"},\n {\"role\": \"user\", \"content\": \"The ring homomorphism is an isometry. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R‚ÇÅ : Type u_1} {R‚ÇÇ : Type u_2} [inst : Semiring R‚ÇÅ] [inst_1 : Semiring R‚ÇÇ] [inst_2 : Norm R‚ÇÅ] [inst_3 : Norm R‚ÇÇ]\\n  {œÉ : R‚ÇÅ ‚Üí+* R‚ÇÇ} [self : RingHomIsometric œÉ] {x : R‚ÇÅ}, ‚Äñ‚ÜëœÉ x‚Äñ = ‚Äñx‚Äñ\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a monoid with zero, if zero equals one, then zero is the only element. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {M‚ÇÄ : Type u_1} [inst : MulZeroOneClass M‚ÇÄ], 0 = 1 ‚Üí ‚àÄ (a : M‚ÇÄ), a = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A subring of a ring with no zero divisors has no zero divisors. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} [inst : Ring R] [inst_1 : NoZeroDivisors R] (s : Subring R), NoZeroDivisors { x // x ‚àà s }\"},\n {\"role\": \"user\",\n  \"content\": \"The zero morphism maps every pseudoelement to 0. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C] {P : C} (Q : C)\\n  (a : CategoryTheory.Abelian.Pseudoelement P), CategoryTheory.Abelian.Pseudoelement.pseudoApply 0 a = 0\"},\n {\"role\": \"user\",\n  \"content\": \"An element is in the kernel if and only if it maps to zero.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u} {S : Type v} {F : Type u_1} [inst : Semiring R] [inst_1 : Semiring S] [rcf : RingHomClass F R S] (f : F)\\n  {r : R}, r ‚àà RingHom.ker f ‚Üî ‚Üëf r = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A morphism that is injective on pseudoelements only maps the zero element to zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C] {P Q : C} (f : P ‚ü∂ Q),\\n  Function.Injective (CategoryTheory.Abelian.Pseudoelement.pseudoApply f) ‚Üí\\n    ‚àÄ (a : CategoryTheory.Abelian.Pseudoelement P), CategoryTheory.Abelian.Pseudoelement.pseudoApply f a = 0 ‚Üí a = 0\"},\n {\"role\": \"user\", \"content\": \"An additive group homomorphism sends 0 to 0.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : AddGroup Œ±] [inst_1 : AddGroup Œ≤] {f : Œ± ‚Üí Œ≤}, IsAddGroupHom f ‚Üí f 0 = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A morphism that only maps the zero pseudoelement to zero is a monomorphism. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C] {P Q : C} (f : P ‚ü∂ Q),\\n  (‚àÄ (a : CategoryTheory.Abelian.Pseudoelement P), CategoryTheory.Abelian.Pseudoelement.pseudoApply f a = 0 ‚Üí a = 0) ‚Üí\\n    CategoryTheory.Mono f\"},\n {\"role\": \"user\", \"content\": \"A ring isomorphism sends zero to zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_2} {S : Type u_1} [inst : NonUnitalNonAssocSemiring R] [inst_1 : NonUnitalNonAssocSemiring S]\\n  (f : R ‚âÉ+* S), ‚Üëf 0 = 0\"},\n {\"role\": \"user\", \"content\": \"Ring homomorphisms map zero to zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {x : NonAssocSemiring Œ±} {x_1 : NonAssocSemiring Œ≤} (f : Œ± ‚Üí+* Œ≤), ‚Üëf 0 = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If an element maps to zero under a ring homomorphism, then it is zero.\"}]"}
{"text":"Implication `‚Üí` is symmetric. If `P ‚Üí Q` then `Q ‚Üí P`.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"If `circulant v` is symmetric, `‚àÄ i j : I, v (- i) = v i`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_2} {n : Type u_1} [inst : AddGroup n] {v : n ‚Üí Œ±},\\n  Matrix.IsSymm (Matrix.circulant v) ‚Üí ‚àÄ (i : n), v (-i) = v i\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The proposition that a bi-Heyting homomorphism preserves the Heyting implication.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {F : Type u_1} {Œ± : outParam (Type u_2)} {Œ≤ : outParam (Type u_3)} [inst : BiheytingAlgebra Œ±]\\n  [inst_1 : BiheytingAlgebra Œ≤] [self : BiheytingHomClass F Œ± Œ≤] (f : F) (a b : Œ±), ‚Üëf (a ‚á® b) = ‚Üëf a ‚á® ‚Üëf b\"},\n {\"role\": \"user\",\n  \"content\": \"If `f,g` is reflexive, then `g,f` is reflexive. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {A B : C} {f g : A ‚ü∂ B} [inst_1 : CategoryTheory.IsReflexivePair f g],\\n  CategoryTheory.IsReflexivePair g f\"},\n {\"role\": \"user\", \"content\": \"Additive congruence relations are symmetric.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {M : Type u_1} [inst : Add M] (c : AddCon M) {x y : M}, ‚Üëc x y ‚Üí ‚Üëc y x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Corollary of the third isomorphism theorem: `[S : T] [M : S] = [M : T]` \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] (S T : Submodule R M),\\n  T ‚â§ S ‚Üí\\n    ‚àÄ [inst_3 : DecidablePred fun x => x ‚àà Submodule.map (Submodule.mkQ T) S] [inst_4 : Fintype (M ‚ß∏ S)]\\n      [inst_5 : Fintype (M ‚ß∏ T)],\\n      Fintype.card { x // x ‚àà Submodule.map (Submodule.mkQ T) S } * Fintype.card (M ‚ß∏ S) = Fintype.card (M ‚ß∏ T)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The proposition that a Heyting homomorphism preserves the Heyting implication.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {F : Type u_1} {Œ± : outParam (Type u_2)} {Œ≤ : outParam (Type u_3)} [inst : HeytingAlgebra Œ±]\\n  [inst_1 : HeytingAlgebra Œ≤] [self : HeytingHomClass F Œ± Œ≤] (f : F) (a b : Œ±), ‚Üëf (a ‚á® b) = ‚Üëf a ‚á® ‚Üëf b\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `P` holds for `f : X ‚ü∂ Y`, then `P` holds for `f ‚à£_ U` for any `U`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme},\\n  AlgebraicGeometry.PropertyIsLocalAtTarget P ‚Üí\\n    ‚àÄ {X Y : AlgebraicGeometry.Scheme} (f : X ‚ü∂ Y) (U : TopologicalSpace.Opens ‚Üë‚ÜëY.toPresheafedSpace), P f ‚Üí P (f ‚à£_ U)\"},\n {\"role\": \"user\", \"content\": \"Congruence relations are symmetric. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {M : Type u_1} [inst : Mul M] (c : Con M) {x y : M}, ‚Üëc x y ‚Üí ‚Üëc y x\"},\n {\"role\": \"user\",\n  \"content\": \"`P` as a morphism property respects isomorphisms \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {P : AlgebraicGeometry.AffineTargetMorphismProperty},\\n  AlgebraicGeometry.AffineTargetMorphismProperty.IsLocal P ‚Üí\\n    CategoryTheory.MorphismProperty.RespectsIso (AlgebraicGeometry.AffineTargetMorphismProperty.toProperty P)\"},\n {\"role\": \"user\", \"content\": \"`x ‚á® y` is equal to `y ‚äî x·∂ú` \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} [self : BooleanAlgebra Œ±] (x y : Œ±), x ‚á® y = y ‚äî x·∂ú\"},\n {\"role\": \"user\",\n  \"content\":\n  \"An antisymmetric relation `(¬∑‚â§¬∑)` satisfies `a ‚â§ b ‚Üí b ‚â§ a ‚Üí a = b`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop} [self : Antisymm r] {a b : Œ±}, r a b ‚Üí r b a ‚Üí a = b\"},\n {\"role\": \"user\", \"content\": \"monotonicity of `‚â§` with respect to `‚Üí` \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u} {a b c d : Œ±} [inst : Preorder Œ±], c ‚â§ a ‚Üí b ‚â§ d ‚Üí a ‚â§ b ‚Üí c ‚â§ d\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `‚àÄ I > J, P I` implies `P J`, then `P` holds for all submodules. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\\n  [inst_3 : IsNoetherian R M] {P : Submodule R M ‚Üí Prop},\\n  (‚àÄ (I : Submodule R M), (‚àÄ (J : Submodule R M), J > I ‚Üí P J) ‚Üí P I) ‚Üí ‚àÄ (I : Submodule R M), P I\"},\n {\"role\": \"user\", \"content\": \"An equivalence relation is reflexive: `x ~ x` \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop}, Equivalence r ‚Üí ‚àÄ (x : Œ±), r x x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"An equivalence relation is transitive: `x ~ y` and `y ~ z` implies `x ~ z` \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop}, Equivalence r ‚Üí ‚àÄ {x y z : Œ±}, r x y ‚Üí r y z ‚Üí r x z\"},\n {\"role\": \"user\", \"content\": \"`P` respects isomorphisms. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme},\\n  AlgebraicGeometry.PropertyIsLocalAtTarget P ‚Üí CategoryTheory.MorphismProperty.RespectsIso P\"},\n {\"role\": \"user\",\n  \"content\": \"If `p` and `q` are irreducible, then `p ‚à£ q` implies `q ‚à£ p`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : Monoid Œ±] {p q : Œ±}, Irreducible p ‚Üí Irreducible q ‚Üí p ‚à£ q ‚Üí q ‚à£ p\"},\n {\"role\": \"user\", \"content\": \"`(P ‚ü∂ P‚Å∫)‚Å∫ = P‚Å∫ ‚ü∂ P‚Å∫‚Å∫` \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] (J : CategoryTheory.GrothendieckTopology C) {D : Type w}\\n  [inst_1 : CategoryTheory.Category D]\\n  [inst_2 :\\n    ‚àÄ (P : CategoryTheory.Functor C·µí·µñ D) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover J X),\\n      CategoryTheory.Limits.HasMultiequalizer (CategoryTheory.GrothendieckTopology.Cover.index S P)]\\n  (P : CategoryTheory.Functor C·µí·µñ D)\\n  [inst_3 : ‚àÄ (X : C), CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.GrothendieckTopology.Cover J X)·µí·µñ D],\\n  CategoryTheory.GrothendieckTopology.plusMap J (CategoryTheory.GrothendieckTopology.toPlus J P) =\\n    CategoryTheory.GrothendieckTopology.toPlus J (CategoryTheory.GrothendieckTopology.plusObj J P)\"},\n {\"role\": \"user\",\n  \"content\": \"An equivalence relation is symmetric: `x ~ y` implies `y ~ x` \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Sort u} {r : Œ± ‚Üí Œ± ‚Üí Prop}, Equivalence r ‚Üí ‚àÄ {x y : Œ±}, r x y ‚Üí r y x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Implication `‚Üí` is transitive. If `P ‚Üí Q` and `Q ‚Üí R` then `P ‚Üí R`. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {p q r : Prop}, (p ‚Üí q) ‚Üí (q ‚Üí r) ‚Üí p ‚Üí r\"},\n {\"role\": \"user\",\n  \"content\": \"Implication `‚Üí` is symmetric. If `P ‚Üí Q` then `Q ‚Üí P`.\"}]"}
{"text":"Two natural numbers are equal if and only if they are both divisible by some prime number.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"An element a divides the sum a + b if and only if a divides b.\"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {Œ± : Type u_1} [inst : Ring Œ±] {a b : Œ±}, a ‚à£ a + b ‚Üî a ‚à£ b\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two finite cardinals are equal iff they are equal their to_nat are equal \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {c d : Cardinal.{u_1}}, c < Cardinal.aleph0 ‚Üí d < Cardinal.aleph0 ‚Üí (‚ÜëCardinal.toNat c = ‚ÜëCardinal.toNat d ‚Üî c = d)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If an integer with larger absolute value divides an integer, it is\\nzero. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {a b : ‚Ñ§}, a ‚à£ b ‚Üí Int.natAbs b < Int.natAbs a ‚Üí b = 0\"},\n {\"role\": \"user\",\n  \"content\": \"Pre-games defined by natural numbers are numeric. \"},\n {\"role\": \"assistant\", \"content\": \"‚àÄ (n : ‚Ñï), PGame.Numeric ‚Üën\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The numerator and denominator are coprime: it is in \\\"reduced form\\\". \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ (self : ‚Ñö), Nat.coprime (Int.natAbs self.num) self.den\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ (n : ‚Ñï), Nat.factorization n = 0 ‚Üî n = 0 ‚à® n = 1\"},\n {\"role\": \"user\",\n  \"content\": \"Infinitely many natural numbers are equal to `d` mod `n`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {n : ‚Ñï}, n ‚â† 0 ‚Üí ‚àÄ (d : ‚Ñï), ‚àÉ·∂† (m : ‚Ñï) in Filter.atTop, m ‚â° d [MOD n]\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {a b x y u v : ‚Ñï}, a = x ^ 2 + y ^ 2 ‚Üí b = u ^ 2 + v ^ 2 ‚Üí ‚àÉ r s, a * b = r ^ 2 + s ^ 2\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two positive naturals are equal if their prime padic valuations are equal \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ (a b : ‚Ñï), a ‚â† 0 ‚Üí b ‚â† 0 ‚Üí (a = b ‚Üî ‚àÄ (p : ‚Ñï), Nat.Prime p ‚Üí padicValNat p a = padicValNat p b)\"},\n {\"role\": \"user\",\n  \"content\": \"Any common divisor of both elements is a divisor of the GCD. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : CancelCommMonoidWithZero Œ±] [self : GCDMonoid Œ±] {a b c : Œ±}, a ‚à£ c ‚Üí a ‚à£ b ‚Üí a ‚à£ gcd c b\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If two integers are congruent to a sufficiently large modulus,\\nthey are equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {a b c : ‚Ñ§}, a % b = c ‚Üí Int.natAbs (a - c) < Int.natAbs b ‚Üí a = c\"},\n {\"role\": \"user\",\n  \"content\": \"The only divisors of prime powers are prime powers. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"‚àÄ {Œ± : Type u_1} [inst : CancelCommMonoidWithZero Œ±] [dec_irr : (p : Associates Œ±) ‚Üí Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid Œ±] [dec : DecidableEq Œ±] [dec' : DecidableEq (Associates Œ±)] {a p : Associates Œ±},\\n  Irreducible p ‚Üí\\n    ‚àÄ [inst_2 : (n : ‚Ñï) ‚Üí Decidable (a ‚à£ p ^ n)] {n : ‚Ñï} (h : a ‚à£ p ^ n),\\n      a = p ^ Nat.find (_ : ‚àÉ n, (fun n => a ‚à£ p ^ n) n)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A prime natural number is prime in `‚Ñ§[i]` if and only if it is `3` mod `4` \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ (p : ‚Ñï) [inst : Fact (Nat.Prime p)], Prime ‚Üëp ‚Üî p % 4 = 3\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A natural number `m` divides the sum `n + m` if and only if `m` divides `n`.\"},\n {\"role\": \"assistant\", \"content\": \"‚àÄ {m n : ‚Ñï}, m ‚à£ n + m ‚Üî m ‚à£ n\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\", \"content\": \"Set.InjOn Nat.factorization {x | x ‚â† 0}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A natural number `m` divides the sum `m + n` if and only if `m` divides `n`.\"},\n {\"role\": \"assistant\", \"content\": \"‚àÄ {m n : ‚Ñï}, m ‚à£ m + n ‚Üî m ‚à£ n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a small natural number is divisible by a larger natural number,\\nthe small number is zero. \"},\n {\"role\": \"assistant\", \"content\": \"‚àÄ {a b : ‚Ñï}, a ‚à£ b ‚Üí b < a ‚Üí b = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {m n : ‚Ñï}, (‚àÄ (a : ‚Ñï), m ‚à£ a ‚Üî n ‚à£ a) ‚Üî m = n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"role\": \"assistant\",\n  \"content\": \"‚àÄ {m n : ‚Ñï}, (‚àÄ (a : ‚Ñï), a ‚à£ m ‚Üî a ‚à£ n) ‚Üî m = n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they are both divisible by some prime number.\"}]"}
