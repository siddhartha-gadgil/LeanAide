 : (‚àÄ {Œπ : Type uŒπ} {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] [inst_2 : FiniteDimensional ‚Ñù E]
  {H : Type uH} [inst_3 : TopologicalSpace H] {I : ModelWithCorners ‚Ñù E H} {M : Type uM} [inst_4 : TopologicalSpace M]
  [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] {s : Set M} [inst_7 : T2Space M]
  {f : SmoothBumpCovering Œπ I M s} {U : (a : M) ‚Üí Set M},
  (BumpCovering.IsSubordinate (SmoothBumpCovering.toBumpCovering f) fun (i : Œπ) ‚Ü¶ U (SmoothBumpCovering.c s f i)) ‚Üî
    (SmoothBumpCovering.IsSubordinate f U))
unknown universe level 'uH' ; identifiers [Œπ, uŒπ, E, uE, inst, NormedAddCommGroup, E, inst_1, NormedSpace, E, inst_2, FiniteDimensional, E, H, uH, inst_3, TopologicalSpace, H, I, ModelWithCorners, E, H, M, uM, inst_4, TopologicalSpace, M, inst_5, ChartedSpace, H, M, inst_6, SmoothManifoldWithCorners, I, M, s, Set, M, inst_7, T2Space, M, f, SmoothBumpCovering, Œπ, I, M, s, U, a, M, Set, M, BumpCovering.IsSubordinate, SmoothBumpCovering.toBumpCovering, f, i, Œπ, U, SmoothBumpCovering.c, s, f, i, SmoothBumpCovering.IsSubordinate, f, U] (during elaboration) for (‚àÄ {Œπ : Type uŒπ} {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] [inst_2 : FiniteDimensional ‚Ñù E]
  {H : Type uH} [inst_3 : TopologicalSpace H] {I : ModelWithCorners ‚Ñù E H} {M : Type uM} [inst_4 : TopologicalSpace M]
  [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] {s : Set M} [inst_7 : T2Space M]
  {f : SmoothBumpCovering Œπ I M s} {U : (a : M) ‚Üí Set M},
  (BumpCovering.IsSubordinate (SmoothBumpCovering.toBumpCovering f) fun (i : Œπ) ‚Ü¶ U (SmoothBumpCovering.c s f i)) ‚Üî
    (SmoothBumpCovering.IsSubordinate f U))

 : (‚àÄ {Œπ : Type u_1} {V : Type u} [inst : CategoryTheory.Category V] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms V]
  {c : ComplexShape Œπ} {A : HomologicalComplex V c} {B : HomologicalComplex V c} [inst_2 : SizeOf Œπ] [inst_3 : SizeOf V]
  (f : (i : Œπ) ‚Üí HomologicalComplex.X A i ‚ü∂ HomologicalComplex.X B i)
  (comm' :
    autoParam
      (‚àÄ (i : Œπ) (j : Œπ) (a : ComplexShape.Rel c i j),
        CategoryTheory.CategoryStruct.comp (f i) (HomologicalComplex.d B i j) =
          CategoryTheory.CategoryStruct.comp (HomologicalComplex.d A i j) (f j))
      _auto‚úù),
  sizeOf (HomologicalComplex.Hom.mk f) = 1)
<input>:9:11: expected token

 : (‚àÄ {Œ± : Type u} (m : MeasureTheory.OuterMeasure Œ±) {s : Set Œ±},
  (MeasurableSet s) ‚Üî (‚àÄ (t : Set Œ±), ‚Üëm t = ‚Üëm (t ‚à© s) + ‚Üëm (t \ s)))
failed to synthesize instance
  MeasurableSpace Œ± ; identifiers [Œ±, u, m, MeasureTheory.OuterMeasure, Œ±, s, Set, Œ±, MeasurableSet, s, t, Set, Œ±, m, t, m, t, s, m, t, s] (during elaboration) for (‚àÄ {Œ± : Type u} (m : MeasureTheory.OuterMeasure Œ±) {s : Set Œ±},
  (MeasurableSet s) ‚Üî (‚àÄ (t : Set Œ±), ‚Üëm t = ‚Üëm (t ‚à© s) + ‚Üëm (t \ s)))

 : (‚àÄ {L : FirstOrder.Language} (M : Type w) [inst : FirstOrder.Language.Structure L M]
  {œÜ : FirstOrder.Language.Sentence L}, (M ‚ä® FirstOrder.Language.Formula.not œÜ) ‚Üî (¬¨(M ‚ä® œÜ)))
ambiguous, possible interpretations 
  M ‚ä® ?m.497 : Prop
  
  M ‚ä® FirstOrder.Language.Formula.not œÜ : Prop ; identifiers [L, FirstOrder.Language, M, w, inst, FirstOrder.Language.Structure, L, M, œÜ, FirstOrder.Language.Sentence, L, M, FirstOrder.Language.Formula.not, œÜ, M, FirstOrder.Language.Formula.not, œÜ, M, œÜ, M, œÜ] (during elaboration) for (‚àÄ {L : FirstOrder.Language} (M : Type w) [inst : FirstOrder.Language.Structure L M]
  {œÜ : FirstOrder.Language.Sentence L}, (M ‚ä® FirstOrder.Language.Formula.not œÜ) ‚Üî (¬¨(M ‚ä® œÜ)))

 : (‚àÄ (A : Type u_1) [inst : CommRing A] (K : Type u_2) [inst_1 : Field K] [inst_2 : Algebra A K]
  (a : ValuationRing.ValueGroup A K) (b : ValuationRing.ValueGroup A K), (a < b) ‚Üî (a < b))
failed to synthesize instance
  LT (ValuationRing.ValueGroup A K) ; identifiers [A, u_1, inst, CommRing, A, K, u_2, inst_1, Field, K, inst_2, Algebra, A, K, a, ValuationRing.ValueGroup, A, K, b, ValuationRing.ValueGroup, A, K, a, b, a, b] (during elaboration) for (‚àÄ (A : Type u_1) [inst : CommRing A] (K : Type u_2) [inst_1 : Field K] [inst_2 : Algebra A K]
  (a : ValuationRing.ValueGroup A K) (b : ValuationRing.ValueGroup A K), (a < b) ‚Üî (a < b))

 : (‚àÄ {P : AlgebraicGeometry.AffineTargetMorphismProperty}
  (self : AlgebraicGeometry.AffineTargetMorphismProperty.IsLocal P) {X : AlgebraicGeometry.Scheme}
  {Y : AlgebraicGeometry.Scheme} [inst : AlgebraicGeometry.IsAffine Y] (f : X ‚ü∂ Y)
  (r :
    ‚Üë((CategoryTheory.Functor.toPrefunctor
            (AlgebraicGeometry.PresheafedSpace.presheaf
              (AlgebraicGeometry.SheafedSpace.toPresheafedSpace
                (AlgebraicGeometry.LocallyRingedSpace.toSheafedSpace
                  (AlgebraicGeometry.Scheme.toLocallyRingedSpace Y))))).obj
        (Opposite.op ‚ä§)))
  (a : P f), P (f ‚à£_ AlgebraicGeometry.Scheme.basicOpen Y r))
synthesized type class instance is not definitionally equal to expression inferred by typing rules, synthesized
  CategoryTheory.Category.opposite
inferred
  CategoryTheory.Category.opposite ; identifiers [P, AlgebraicGeometry.AffineTargetMorphismProperty, self, AlgebraicGeometry.AffineTargetMorphismProperty.IsLocal, P, X, AlgebraicGeometry.Scheme, Y, AlgebraicGeometry.Scheme, inst, AlgebraicGeometry.IsAffine, Y, f, X, Y, r, CategoryTheory.Functor.toPrefunctor, AlgebraicGeometry.PresheafedSpace.presheaf, AlgebraicGeometry.SheafedSpace.toPresheafedSpace, AlgebraicGeometry.LocallyRingedSpace.toSheafedSpace, AlgebraicGeometry.Scheme.toLocallyRingedSpace, Y, obj, Opposite.op, a, P, f, P, f, AlgebraicGeometry.Scheme.basicOpen, Y, r] (during elaboration) for (‚àÄ {P : AlgebraicGeometry.AffineTargetMorphismProperty}
  (self : AlgebraicGeometry.AffineTargetMorphismProperty.IsLocal P) {X : AlgebraicGeometry.Scheme}
  {Y : AlgebraicGeometry.Scheme} [inst : AlgebraicGeometry.IsAffine Y] (f : X ‚ü∂ Y)
  (r :
    ‚Üë((CategoryTheory.Functor.toPrefunctor
            (AlgebraicGeometry.PresheafedSpace.presheaf
              (AlgebraicGeometry.SheafedSpace.toPresheafedSpace
                (AlgebraicGeometry.LocallyRingedSpace.toSheafedSpace
                  (AlgebraicGeometry.Scheme.toLocallyRingedSpace Y))))).obj
        (Opposite.op ‚ä§)))
  (a : P f), P (f ‚à£_ AlgebraicGeometry.Scheme.basicOpen Y r))

 : (‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} {f : X ‚ü∂ Y}
  {F : CategoryTheory.Limits.MonoFactorisation f} [inst_1 : SizeOf C]
  (lift :
    (F' : CategoryTheory.Limits.MonoFactorisation f) ‚Üí
      CategoryTheory.Limits.MonoFactorisation.I F ‚ü∂ CategoryTheory.Limits.MonoFactorisation.I F')
  (lift_fac :
    autoParam
      (‚àÄ (F' : CategoryTheory.Limits.MonoFactorisation f),
        CategoryTheory.CategoryStruct.comp (lift F') (CategoryTheory.Limits.MonoFactorisation.m F') =
          CategoryTheory.Limits.MonoFactorisation.m F)
      _auto‚úù),
  sizeOf (CategoryTheory.Limits.IsImage.mk lift) = 1)
<input>:11:11: expected token

 : (‚àÄ {Œ± : Type u} [inst : SizeOf Œ±], sizeOf RegularExpression.zero = 1)
typeclass instance problem is stuck, it is often due to metavariables
  SizeOf (RegularExpression ?m.6826) ; identifiers [Œ±, u, inst, SizeOf, Œ±, sizeOf, RegularExpression.zero] (during elaboration) for (‚àÄ {Œ± : Type u} [inst : SizeOf Œ±], sizeOf RegularExpression.zero = 1)

 : (‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : NonAssocSemiring Œ±] [inst_1 : Preorder Œ±] [inst_2 : NonAssocSemiring Œ≤]
  [inst_3 : Preorder Œ≤] (self : Œ± ‚Üí+*o Œ≤), Monotone (OneHom.toFun ‚Üë‚Üë(OrderRingHom.toRingHom self)))
type mismatch
  self.toRingHom
has type
  Œ± ‚Üí+* Œ≤ : Type (max u_1 u_2)
but is expected to have type
  OneHom (?m.1739 self) (?m.1740 self) : Type (max ?u.194 ?u.193) ; identifiers [Œ±, u_1, Œ≤, u_2, inst, NonAssocSemiring, Œ±, inst_1, Preorder, Œ±, inst_2, NonAssocSemiring, Œ≤, inst_3, Preorder, Œ≤, self, Œ±, Œ≤, Monotone, OneHom.toFun, OrderRingHom.toRingHom, self] (during elaboration) for (‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : NonAssocSemiring Œ±] [inst_1 : Preorder Œ±] [inst_2 : NonAssocSemiring Œ≤]
  [inst_3 : Preorder Œ≤] (self : Œ± ‚Üí+*o Œ≤), Monotone (OneHom.toFun ‚Üë‚Üë(OrderRingHom.toRingHom self)))

 : (‚àÄ {G : Type u_1} [inst : Group G] (n : ‚Ñï) (q : G),
  (q ‚àà lowerCentralSeries G (n + 1)) ‚Üî
    (q ‚àà
      Subgroup.closure
        {x : G | ‚àÉ (p : G), (p ‚àà lowerCentralSeries G n) ‚àß (‚àÉ (q : G), (q ‚àà ‚ä§) ‚àß (p * q * p‚Åª¬π * q‚Åª¬π = x))}))
typeclass instance problem is stuck, it is often due to metavariables
  Membership G (?m.2902 n q‚úù x p q) ; identifiers [G, u_1, inst, Group, G, n, q, G, q, lowerCentralSeries, G, n, q, Subgroup.closure, x, G, p, G, p, lowerCentralSeries, G, n, q, G, q, p, q, p, q, x] (during elaboration) for (‚àÄ {G : Type u_1} [inst : Group G] (n : ‚Ñï) (q : G),
  (q ‚àà lowerCentralSeries G (n + 1)) ‚Üî
    (q ‚àà
      Subgroup.closure
        {x : G | ‚àÉ (p : G), (p ‚àà lowerCentralSeries G n) ‚àß (‚àÉ (q : G), (q ‚àà ‚ä§) ‚àß (p * q * p‚Åª¬π * q‚Åª¬π = x))}))

 : (‚àÄ {C : Type u} [inst : SizeOf C], sizeOf CategoryTheory.FreeMonoidalCategory.Unit = 1)
typeclass instance problem is stuck, it is often due to metavariables
  SizeOf (CategoryTheory.FreeMonoidalCategory ?m.6826) ; identifiers [C, u, inst, SizeOf, C, sizeOf, CategoryTheory.FreeMonoidalCategory.Unit] (during elaboration) for (‚àÄ {C : Type u} [inst : SizeOf C], sizeOf CategoryTheory.FreeMonoidalCategory.Unit = 1)

 : (‚àÄ (C : Type u) [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C]
  [inst_2 : CategoryTheory.Limits.HasBinaryCoproducts C] (P : C) (Q : C),
  Œ≤_ P Q = CategoryTheory.Limits.coprod.braiding P Q)
type mismatch
  CategoryTheory.Limits.coprod.braiding P Q
has type
  P ‚®ø Q ‚âÖ Q ‚®ø P : Type ?u.6
but is expected to have type
  CategoryTheory.MonoidalCategory.tensorObj P Q ‚âÖ CategoryTheory.MonoidalCategory.tensorObj Q P : Type ?u.6 ; identifiers [C, u, inst, CategoryTheory.Category, C, inst_1, CategoryTheory.Limits.HasInitial, C, inst_2, CategoryTheory.Limits.HasBinaryCoproducts, C, P, C, Q, C, P, Q, CategoryTheory.Limits.coprod.braiding, P, Q] (during elaboration) for (‚àÄ (C : Type u) [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C]
  [inst_2 : CategoryTheory.Limits.HasBinaryCoproducts C] (P : C) (Q : C),
  Œ≤_ P Q = CategoryTheory.Limits.coprod.braiding P Q)

 : (‚àÄ {Œ± : Type u_1} [inst : Mul Œ±] {s : Set Œ±} {t : Set Œ±} {a : Œ±},
  (a ‚àà s * t) ‚Üî (‚àÉ (x : Œ±), ‚àÉ (y : Œ±), (x ‚àà s) ‚àß ((y ‚àà t) ‚àß (x * y = a))))
failed to synthesize instance
  HMul (Set Œ±) (Set Œ±) ?m.1993 ; identifiers [Œ±, u_1, inst, Mul, Œ±, s, Set, Œ±, t, Set, Œ±, a, Œ±, a, s, t, x, Œ±, y, Œ±, x, s, y, t, x, y, a] (during elaboration) for (‚àÄ {Œ± : Type u_1} [inst : Mul Œ±] {s : Set Œ±} {t : Set Œ±} {a : Œ±},
  (a ‚àà s * t) ‚Üî (‚àÉ (x : Œ±), ‚àÉ (y : Œ±), (x ‚àà s) ‚àß ((y ‚àà t) ‚àß (x * y = a))))

 : (‚àÄ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommGroup M] (self : Module.Core R M) (r : R) (x : M)
  (y : M), r ‚Ä¢ (x + y) = r ‚Ä¢ x + r ‚Ä¢ y)
failed to synthesize instance
  HSMul R M ?m.54 ; identifiers [R, u_1, M, u_2, inst, Semiring, R, inst_1, AddCommGroup, M, self, Module.Core, R, M, r, R, x, M, y, M, r, x, y, r, x, r, y] (during elaboration) for (‚àÄ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommGroup M] (self : Module.Core R M) (r : R) (x : M)
  (y : M), r ‚Ä¢ (x + y) = r ‚Ä¢ x + r ‚Ä¢ y)

 : (‚àÄ {G : Type u_1} {Œ± : Type u_2} [inst : One G] [inst_1 : SMul G Œ±] [inst_2 : MeasurableSpace Œ±] {s : Set Œ±}
  {Œº : autoParam (MeasureTheory.Measure Œ±) _auto‚úù} (self : MeasureTheory.IsFundamentalDomain G s),
  Pairwise (MeasureTheory.AEDisjoint Œº on fun (g : G) ‚Ü¶ g ‚Ä¢ s))
<input>:2:48: expected token

 : (‚àÄ {R : Type u} [inst : SizeOf R], sizeOf Rack.PreEnvelGroup.unit = 1)
typeclass instance problem is stuck, it is often due to metavariables
  SizeOf (Rack.PreEnvelGroup ?m.6826) ; identifiers [R, u, inst, SizeOf, R, sizeOf, Rack.PreEnvelGroup.unit] (during elaboration) for (‚àÄ {R : Type u} [inst : SizeOf R], sizeOf Rack.PreEnvelGroup.unit = 1)

 : (‚àÄ {R : Type u_1} [inst : Semiring R] (h : IsField R) (a : R) (b : R), a / b = a / b)
failed to synthesize instance
  HDiv R R ?m.293 ; identifiers [R, u_1, inst, Semiring, R, h, IsField, R, a, R, b, R, a, b, a, b] (during elaboration) for (‚àÄ {R : Type u_1} [inst : Semiring R] (h : IsField R) (a : R) (b : R), a / b = a / b)

 : (‚àÄ {X : TopCat} (x : ‚ÜëX) (a : TopologicalSpace.OpenNhds x) (b : TopologicalSpace.OpenNhds x), (a < b) ‚Üî (a < b))
type mismatch
  X
has type
  TopCat : Type (?u.3 + 1)
but is expected to have type
  Sort ?u.5 : Type ?u.5 ; identifiers [X, TopCat, x, X, a, TopologicalSpace.OpenNhds, x, b, TopologicalSpace.OpenNhds, x, a, b, a, b] (during elaboration) for (‚àÄ {X : TopCat} (x : ‚ÜëX) (a : TopologicalSpace.OpenNhds x) (b : TopologicalSpace.OpenNhds x), (a < b) ‚Üî (a < b))

 : (‚àÄ {J : Type u_2} [inst : CategoryTheory.SmallCategory J] [inst_1 : CategoryTheory.IsFiltered J]
  (F : CategoryTheory.Functor J GroupCat) (a : ‚Üë(GroupCat.FilteredColimits.G F)) (b : ‚Üë(GroupCat.FilteredColimits.G F)),
  a / b = a / b)
type mismatch
  GroupCat.FilteredColimits.G F
has type
  MonCat : Type ((max ?u.50 u_2) + 1)
but is expected to have type
  Sort ?u.49 : Type ?u.49 ; identifiers [J, u_2, inst, CategoryTheory.SmallCategory, J, inst_1, CategoryTheory.IsFiltered, J, F, CategoryTheory.Functor, J, GroupCat, a, GroupCat.FilteredColimits.G, F, b, GroupCat.FilteredColimits.G, F, a, b, a, b] (during elaboration) for (‚àÄ {J : Type u_2} [inst : CategoryTheory.SmallCategory J] [inst_1 : CategoryTheory.IsFiltered J]
  (F : CategoryTheory.Functor J GroupCat) (a : ‚Üë(GroupCat.FilteredColimits.G F)) (b : ‚Üë(GroupCat.FilteredColimits.G F)),
  a / b = a / b)

 : (‚àÄ {Œ± : Type u_1} {m : MeasurableSpace Œ±} {f : (a : Œ±) ‚Üí Œ±} {Œº : autoParam (MeasureTheory.Measure Œ±) _auto‚úù}
  (self : Ergodic f), MeasureTheory.MeasurePreserving f)
<input>:1:109: expected token

 : (‚àÄ {Œπ : Type uŒπ} {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] {H : Type uH}
  [inst_2 : TopologicalSpace H] {I : ModelWithCorners ‚Ñù E H} {M : Type uM} [inst_3 : TopologicalSpace M]
  [inst_4 : ChartedSpace H M] {s : optParam (Set M) Set.univ} (self : SmoothPartitionOfUnity Œπ I M s) (x : M),
  ‚àë·∂† (i : Œπ), ‚Üë(SmoothPartitionOfUnity.toFun s self i) x ‚â§ 1)
unknown universe level 'uH' ; identifiers [Œπ, uŒπ, E, uE, inst, NormedAddCommGroup, E, inst_1, NormedSpace, E, H, uH, inst_2, TopologicalSpace, H, I, ModelWithCorners, E, H, M, uM, inst_3, TopologicalSpace, M, inst_4, ChartedSpace, H, M, s, optParam, Set, M, Set.univ, self, SmoothPartitionOfUnity, Œπ, I, M, s, x, M, i, Œπ, SmoothPartitionOfUnity.toFun, s, self, i, x] (during elaboration) for (‚àÄ {Œπ : Type uŒπ} {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] {H : Type uH}
  [inst_2 : TopologicalSpace H] {I : ModelWithCorners ‚Ñù E H} {M : Type uM} [inst_3 : TopologicalSpace M]
  [inst_4 : ChartedSpace H M] {s : optParam (Set M) Set.univ} (self : SmoothPartitionOfUnity Œπ I M s) (x : M),
  ‚àë·∂† (i : Œπ), ‚Üë(SmoothPartitionOfUnity.toFun s self i) x ‚â§ 1)

 : (‚àÄ {ùïú : Type u} [inst : NontriviallyNormedField ùïú] {F : Type v} [inst_1 : NormedAddCommGroup F]
  [inst_2 : NormedSpace ùïú F] {f : (a : ùïú) ‚Üí F} {f' : F} {x : ùïú},
  (HasStrictDerivAt f f' x) ‚Üî (HasStrictFDerivAt f (ContinuousLinearMap.smulRight 1 f') x))
typeclass instance problem is stuck, it is often due to metavariables
  NormedSpace ?m.8251 F ; identifiers [ùïú, u, inst, NontriviallyNormedField, ùïú, F, v, inst_1, NormedAddCommGroup, F, inst_2, NormedSpace, ùïú, F, f, a, ùïú, F, f', F, x, ùïú, HasStrictDerivAt, f, f', x, HasStrictFDerivAt, f, ContinuousLinearMap.smulRight, f', x] (during elaboration) for (‚àÄ {ùïú : Type u} [inst : NontriviallyNormedField ùïú] {F : Type v} [inst_1 : NormedAddCommGroup F]
  [inst_2 : NormedSpace ùïú F] {f : (a : ùïú) ‚Üí F} {f' : F} {x : ùïú},
  (HasStrictDerivAt f f' x) ‚Üî (HasStrictFDerivAt f (ContinuousLinearMap.smulRight 1 f') x))

 : (‚àÄ {R : Type u} [inst : CommRing R] {W : WeierstrassCurve R} [inst_1 : SizeOf R],
  sizeOf WeierstrassCurve.Point.zero = 1)
typeclass instance problem is stuck, it is often due to metavariables
  SizeOf (WeierstrassCurve.Point ?m.7697) ; identifiers [R, u, inst, CommRing, R, W, WeierstrassCurve, R, inst_1, SizeOf, R, sizeOf, WeierstrassCurve.Point.zero] (during elaboration) for (‚àÄ {R : Type u} [inst : CommRing R] {W : WeierstrassCurve R} [inst_1 : SizeOf R],
  sizeOf WeierstrassCurve.Point.zero = 1)

 : (‚àÄ {Œ± : Type u_1} [inst : Div Œ±] {s : Set Œ±} {t : Set Œ±} {a : Œ±},
  (a ‚àà s / t) ‚Üî (‚àÉ (x : Œ±), ‚àÉ (y : Œ±), (x ‚àà s) ‚àß ((y ‚àà t) ‚àß (x / y = a))))
failed to synthesize instance
  HDiv (Set Œ±) (Set Œ±) ?m.284 ; identifiers [Œ±, u_1, inst, Div, Œ±, s, Set, Œ±, t, Set, Œ±, a, Œ±, a, s, t, x, Œ±, y, Œ±, x, s, y, t, x, y, a] (during elaboration) for (‚àÄ {Œ± : Type u_1} [inst : Div Œ±] {s : Set Œ±} {t : Set Œ±} {a : Œ±},
  (a ‚àà s / t) ‚Üî (‚àÉ (x : Œ±), ‚àÉ (y : Œ±), (x ‚àà s) ‚àß ((y ‚àà t) ‚àß (x / y = a))))

 : (‚àÄ {B : Type u‚ÇÅ} [inst : CategoryTheory.Bicategory B] {C : Type u‚ÇÇ} [inst_1 : CategoryTheory.Bicategory C]
  {F : CategoryTheory.OplaxFunctor B C} [inst_2 : SizeOf B] [inst_3 : SizeOf C]
  (mapIdIso :
    (a : B) ‚Üí
      (‚Üë(CategoryTheory.OplaxFunctor.toPrelaxFunctor F)).map (CategoryTheory.CategoryStruct.id a) ‚âÖ
        CategoryTheory.CategoryStruct.id ((‚Üë(CategoryTheory.OplaxFunctor.toPrelaxFunctor F)).obj a))
  (mapCompIso :
    {a : B} ‚Üí
      {b : B} ‚Üí
        {c : B} ‚Üí
          (f : a ‚ü∂ b) ‚Üí
            (g : b ‚ü∂ c) ‚Üí
              (‚Üë(CategoryTheory.OplaxFunctor.toPrelaxFunctor F)).map (CategoryTheory.CategoryStruct.comp f g) ‚âÖ
                CategoryTheory.CategoryStruct.comp ((‚Üë(CategoryTheory.OplaxFunctor.toPrelaxFunctor F)).map f)
                  ((‚Üë(CategoryTheory.OplaxFunctor.toPrelaxFunctor F)).map g))
  (mapIdIso_hom : autoParam (‚àÄ {a : B}, (mapIdIso a).hom = CategoryTheory.OplaxFunctor.mapId F a) _auto‚úù)
  (mapCompIso_hom :
    autoParam
      (‚àÄ {a : B} {b : B} {c : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c),
        (mapCompIso f g).hom = CategoryTheory.OplaxFunctor.mapComp F f g)
      _auto‚úù¬π),
  sizeOf (CategoryTheory.OplaxFunctor.PseudoCore.mk mapIdIso mapCompIso) = 1)
<input>:16:103: expected token

 : (‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : VAdd Œ± Œ≤] {t : Set Œ≤} {a : Œ±} {x : Œ≤},
  (x ‚àà a +·µ• t) ‚Üî (‚àÉ (y : Œ≤), (y ‚àà t) ‚àß (a +·µ• y = x)))
failed to synthesize instance
  HVAdd Œ± (Set Œ≤) ?m.29 ; identifiers [Œ±, u_2, Œ≤, u_1, inst, VAdd, Œ±, Œ≤, t, Set, Œ≤, a, Œ±, x, Œ≤, x, a, t, y, Œ≤, y, t, a, y, x] (during elaboration) for (‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : VAdd Œ± Œ≤] {t : Set Œ≤} {a : Œ±} {x : Œ≤},
  (x ‚àà a +·µ• t) ‚Üî (‚àÉ (y : Œ≤), (y ‚àà t) ‚àß (a +·µ• y = x)))

 : (‚àÄ (M : Type u_1) [inst : CancelMonoidWithZero M] [inst_1 : DecidableEq M] [inst_2 : Fintype M] (a : M) (b : M),
  a / b = a / b)
failed to synthesize instance
  HDiv M M ?m.289 ; identifiers [M, u_1, inst, CancelMonoidWithZero, M, inst_1, DecidableEq, M, inst_2, Fintype, M, a, M, b, M, a, b, a, b] (during elaboration) for (‚àÄ (M : Type u_1) [inst : CancelMonoidWithZero M] [inst_1 : DecidableEq M] [inst_2 : Fintype M] (a : M) (b : M),
  a / b = a / b)

 : (‚àÄ {Œ± : Type u} [inst : Group Œ±] (self : GroupTopology Œ±), TopologicalGroup Œ±)
failed to synthesize instance
  TopologicalSpace Œ± ; identifiers [Œ±, u, inst, Group, Œ±, self, GroupTopology, Œ±, TopologicalGroup, Œ±] (during elaboration) for (‚àÄ {Œ± : Type u} [inst : Group Œ±] (self : GroupTopology Œ±), TopologicalGroup Œ±)

 : (‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Preorder Œ±] [inst_1 : Preorder Œ≤] [inst_2 : AddZeroClass Œ±]
  [inst_3 : AddZeroClass Œ≤] (self : Œ± ‚Üí+o Œ≤), Monotone (ZeroHom.toFun ‚Üë(OrderAddMonoidHom.toAddMonoidHom self)))
typeclass instance problem is stuck, it is often due to metavariables
  Preorder (?m.2800 self) ; identifiers [Œ±, u_1, Œ≤, u_2, inst, Preorder, Œ±, inst_1, Preorder, Œ≤, inst_2, AddZeroClass, Œ±, inst_3, AddZeroClass, Œ≤, self, Œ±, Œ≤, Monotone, ZeroHom.toFun, OrderAddMonoidHom.toAddMonoidHom, self] (during elaboration) for (‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Preorder Œ±] [inst_1 : Preorder Œ≤] [inst_2 : AddZeroClass Œ±]
  [inst_3 : AddZeroClass Œ≤] (self : Œ± ‚Üí+o Œ≤), Monotone (ZeroHom.toFun ‚Üë(OrderAddMonoidHom.toAddMonoidHom self)))

 : (‚àÄ {R : Type u_1} [inst : Ring R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {U : Submodule R M}
  {x : M} {y : M}, (x ‚â° y [SMOD U]) ‚Üî (Submodule.Quotient.mk x = Submodule.Quotient.mk y))
typeclass instance problem is stuck, it is often due to metavariables
  Module ?m.4151 M ; identifiers [R, u_1, inst, Ring, R, M, u_2, inst_1, AddCommGroup, M, inst_2, Module, R, M, U, Submodule, R, M, x, M, y, M, x, y, U, Submodule.Quotient.mk, x, Submodule.Quotient.mk, y] (during elaboration) for (‚àÄ {R : Type u_1} [inst : Ring R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {U : Submodule R M}
  {x : M} {y : M}, (x ‚â° y [SMOD U]) ‚Üî (Submodule.Quotient.mk x = Submodule.Quotient.mk y))

 : (‚àÄ {G : Type u_1} [inst : Monoid G] (a : G) (b : G), a / b = a / b)
failed to synthesize instance
  HDiv G G ?m.277 ; identifiers [G, u_1, inst, Monoid, G, a, G, b, G, a, b, a, b] (during elaboration) for (‚àÄ {G : Type u_1} [inst : Monoid G] (a : G) (b : G), a / b = a / b)

 : (‚àÄ {J : Type u‚ÇÅ} [inst : CategoryTheory.Category J] {C : Type u‚ÇÉ} [inst_1 : CategoryTheory.Category C]
  {F : CategoryTheory.Functor J C} {t : CategoryTheory.Limits.Cone F} (self : CategoryTheory.Limits.IsLimit t)
  (s : CategoryTheory.Limits.Cone F) (m : CategoryTheory.Limits.Cone.pt s ‚ü∂ CategoryTheory.Limits.Cone.pt t)
  (x :
    ‚àÄ (j : J),
      CategoryTheory.CategoryStruct.comp m (CategoryTheory.NatTrans.app (CategoryTheory.Limits.Cone.œÄ t) j) =
        CategoryTheory.NatTrans.app (CategoryTheory.Limits.Cone.œÄ s) j),
  m = CategoryTheory.Limits.IsLimit.lift self s)
unknown universe level 'u‚ÇÉ' ; identifiers [J, u‚ÇÅ, inst, CategoryTheory.Category, J, C, u‚ÇÉ, inst_1, CategoryTheory.Category, C, F, CategoryTheory.Functor, J, C, t, CategoryTheory.Limits.Cone, F, self, CategoryTheory.Limits.IsLimit, t, s, CategoryTheory.Limits.Cone, F, m, CategoryTheory.Limits.Cone.pt, s, CategoryTheory.Limits.Cone.pt, t, x, j, J, CategoryTheory.CategoryStruct.comp, m, CategoryTheory.NatTrans.app, CategoryTheory.Limits.Cone.œÄ, t, j, CategoryTheory.NatTrans.app, CategoryTheory.Limits.Cone.œÄ, s, j, m, CategoryTheory.Limits.IsLimit.lift, self, s] (during elaboration) for (‚àÄ {J : Type u‚ÇÅ} [inst : CategoryTheory.Category J] {C : Type u‚ÇÉ} [inst_1 : CategoryTheory.Category C]
  {F : CategoryTheory.Functor J C} {t : CategoryTheory.Limits.Cone F} (self : CategoryTheory.Limits.IsLimit t)
  (s : CategoryTheory.Limits.Cone F) (m : CategoryTheory.Limits.Cone.pt s ‚ü∂ CategoryTheory.Limits.Cone.pt t)
  (x :
    ‚àÄ (j : J),
      CategoryTheory.CategoryStruct.comp m (CategoryTheory.NatTrans.app (CategoryTheory.Limits.Cone.œÄ t) j) =
        CategoryTheory.NatTrans.app (CategoryTheory.Limits.Cone.œÄ s) j),
  m = CategoryTheory.Limits.IsLimit.lift self s)

 : (‚àÄ {X : TopCat} {x : ‚ÜëX} {y : ‚ÜëX} (e : Inseparable x y), nhds y ‚â§ nhds x)
type mismatch
  X
has type
  TopCat : Type (?u.3 + 1)
but is expected to have type
  Sort ?u.5 : Type ?u.5 ; identifiers [X, TopCat, x, X, y, X, e, Inseparable, x, y, nhds, y, nhds, x] (during elaboration) for (‚àÄ {X : TopCat} {x : ‚ÜëX} {y : ‚ÜëX} (e : Inseparable x y), nhds y ‚â§ nhds x)

 : (‚àÄ {Œ± : Type u_1} [inst : Sub Œ±] {f : Filter Œ±} {g : Filter Œ±} {s : Set Œ±},
  (s ‚àà f - g) ‚Üî (‚àÉ (t‚ÇÅ : Set Œ±), ‚àÉ (t‚ÇÇ : Set Œ±), (t‚ÇÅ ‚àà f) ‚àß ((t‚ÇÇ ‚àà g) ‚àß (t‚ÇÅ - t‚ÇÇ ‚äÜ s))))
failed to synthesize instance
  HSub (Filter Œ±) (Filter Œ±) ?m.812 ; identifiers [Œ±, u_1, inst, Sub, Œ±, f, Filter, Œ±, g, Filter, Œ±, s, Set, Œ±, s, f, g, t‚ÇÅ, Set, Œ±, t‚ÇÇ, Set, Œ±, t‚ÇÅ, f, t‚ÇÇ, g, t‚ÇÅ, t‚ÇÇ, s] (during elaboration) for (‚àÄ {Œ± : Type u_1} [inst : Sub Œ±] {f : Filter Œ±} {g : Filter Œ±} {s : Set Œ±},
  (s ‚àà f - g) ‚Üî (‚àÉ (t‚ÇÅ : Set Œ±), ‚àÉ (t‚ÇÇ : Set Œ±), (t‚ÇÅ ‚àà f) ‚àß ((t‚ÇÇ ‚àà g) ‚àß (t‚ÇÅ - t‚ÇÇ ‚äÜ s))))

 : (‚àÄ {G : Type u_1} {Œ± : Type u_2} [inst : One G] [inst_1 : SMul G Œ±] [inst_2 : MeasurableSpace Œ±] {s : Set Œ±}
  {Œº : autoParam (MeasureTheory.Measure Œ±) _auto‚úù} (self : MeasureTheory.IsFundamentalDomain G s),
  MeasureTheory.NullMeasurableSet s)
<input>:2:48: expected token

 : (‚àÄ {Œπ : Type u} {Œ± : (a : Œπ) ‚Üí Type v} [inst : (i : Œπ) ‚Üí Preorder (Œ± i)] (i : Œπ), Monotone (Function.eval i))
typeclass instance problem is stuck, it is often due to metavariables
  Preorder (?m.497 i i) ; identifiers [Œπ, u, Œ±, a, Œπ, v, inst, i, Œπ, Preorder, Œ±, i, i, Œπ, Monotone, Function.eval, i] (during elaboration) for (‚àÄ {Œπ : Type u} {Œ± : (a : Œπ) ‚Üí Type v} [inst : (i : Œπ) ‚Üí Preorder (Œ± i)] (i : Œπ), Monotone (Function.eval i))

 : (‚àÄ {Œ± : Type u_1} [inst : GeneralizedBooleanAlgebra Œ±] (a : Œ±) (b : Œ±), a - b = a - b)
failed to synthesize instance
  HSub Œ± Œ± ?m.435 ; identifiers [Œ±, u_1, inst, GeneralizedBooleanAlgebra, Œ±, a, Œ±, b, Œ±, a, b, a, b] (during elaboration) for (‚àÄ {Œ± : Type u_1} [inst : GeneralizedBooleanAlgebra Œ±] (a : Œ±) (b : Œ±), a - b = a - b)

 : (‚àÄ {R : Type u} [inst : Ring R] {Q : TypeMax} [inst_1 : AddCommGroup Q] [inst_2 : Module R Q] {M : Type (max u v)}
  {N : Type (max u v)} [inst_3 : AddCommGroup M] [inst_4 : AddCommGroup N] [inst_5 : Module R M] [inst_6 : Module R N]
  {i : M ‚Üí‚Çó[R] N} {f : M ‚Üí‚Çó[R] Q} (self : Module.Baer.ExtensionOf i f),
  LinearMap.range i ‚â§ LinearPMap.domain (Module.Baer.ExtensionOf.toLinearPMap self))
stuck at solving universe constraint
  max u ?u.9 =?= max u v
while trying to unify
  (M ‚Üí‚Çó[R] N) R R Ring.toSemiring Ring.toSemiring (RingHom.id R) M N ((M ‚Üí‚Çó[R] N) M inst_3) ((M ‚Üí‚Çó[R] N) N inst_4)
    inst_5 inst_6
with
  M ‚Üí‚Çó[R] N ; identifiers [R, u, inst, Ring, R, Q, TypeMax, inst_1, AddCommGroup, Q, inst_2, Module, R, Q, M, u, v, N, u, v, inst_3, AddCommGroup, M, inst_4, AddCommGroup, N, inst_5, Module, R, M, inst_6, Module, R, N, i, M, R, N, f, M, R, Q, self, Module.Baer.ExtensionOf, i, f, LinearMap.range, i, LinearPMap.domain, Module.Baer.ExtensionOf.toLinearPMap, self] (during elaboration) for (‚àÄ {R : Type u} [inst : Ring R] {Q : TypeMax} [inst_1 : AddCommGroup Q] [inst_2 : Module R Q] {M : Type (max u v)}
  {N : Type (max u v)} [inst_3 : AddCommGroup M] [inst_4 : AddCommGroup N] [inst_5 : Module R M] [inst_6 : Module R N]
  {i : M ‚Üí‚Çó[R] N} {f : M ‚Üí‚Çó[R] Q} (self : Module.Baer.ExtensionOf i f),
  LinearMap.range i ‚â§ LinearPMap.domain (Module.Baer.ExtensionOf.toLinearPMap self))

 : (‚àÄ (C : Type u) [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasTerminal C]
  [inst_2 : CategoryTheory.Limits.HasBinaryProducts C] (X : C) (Y : C),
  Œ≤_ X Y = CategoryTheory.Limits.prod.braiding X Y)
type mismatch
  CategoryTheory.Limits.prod.braiding X Y
has type
  X ‚®Ø Y ‚âÖ Y ‚®Ø X : Type ?u.6
but is expected to have type
  CategoryTheory.MonoidalCategory.tensorObj X Y ‚âÖ CategoryTheory.MonoidalCategory.tensorObj Y X : Type ?u.6 ; identifiers [C, u, inst, CategoryTheory.Category, C, inst_1, CategoryTheory.Limits.HasTerminal, C, inst_2, CategoryTheory.Limits.HasBinaryProducts, C, X, C, Y, C, X, Y, CategoryTheory.Limits.prod.braiding, X, Y] (during elaboration) for (‚àÄ (C : Type u) [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasTerminal C]
  [inst_2 : CategoryTheory.Limits.HasBinaryProducts C] (X : C) (Y : C),
  Œ≤_ X Y = CategoryTheory.Limits.prod.braiding X Y)

 : (‚àÄ {R : Type u_1} {M‚ÇÅ : Type u_2} {M‚ÇÇ : Type u_3} [inst : Semiring R] [inst_1 : AddCommMonoid M‚ÇÅ]
  [inst_2 : AddCommMonoid M‚ÇÇ] [inst_3 : Module R M‚ÇÅ] [inst_4 : Module R M‚ÇÇ] {Q‚ÇÅ : QuadraticForm R M‚ÇÅ}
  {Q‚ÇÇ : QuadraticForm R M‚ÇÇ} (self : QuadraticForm.Isometry Q‚ÇÅ Q‚ÇÇ) (m : M‚ÇÅ),
  ‚ÜëQ‚ÇÇ (AddHom.toFun (LinearMap.toAddHom ‚Üë(QuadraticForm.Isometry.toLinearEquiv self)) m) = ‚ÜëQ‚ÇÅ m)
unknown constant 'QuadraticForm.Isometry' ; identifiers [R, u_1, M‚ÇÅ, u_2, M‚ÇÇ, u_3, inst, Semiring, R, inst_1, AddCommMonoid, M‚ÇÅ, inst_2, AddCommMonoid, M‚ÇÇ, inst_3, Module, R, M‚ÇÅ, inst_4, Module, R, M‚ÇÇ, Q‚ÇÅ, QuadraticForm, R, M‚ÇÅ, Q‚ÇÇ, QuadraticForm, R, M‚ÇÇ, self, QuadraticForm.Isometry, Q‚ÇÅ, Q‚ÇÇ, m, M‚ÇÅ, Q‚ÇÇ, AddHom.toFun, LinearMap.toAddHom, QuadraticForm.Isometry.toLinearEquiv, self, m, Q‚ÇÅ, m] (during elaboration) for (‚àÄ {R : Type u_1} {M‚ÇÅ : Type u_2} {M‚ÇÇ : Type u_3} [inst : Semiring R] [inst_1 : AddCommMonoid M‚ÇÅ]
  [inst_2 : AddCommMonoid M‚ÇÇ] [inst_3 : Module R M‚ÇÅ] [inst_4 : Module R M‚ÇÇ] {Q‚ÇÅ : QuadraticForm R M‚ÇÅ}
  {Q‚ÇÇ : QuadraticForm R M‚ÇÇ} (self : QuadraticForm.Isometry Q‚ÇÅ Q‚ÇÇ) (m : M‚ÇÅ),
  ‚ÜëQ‚ÇÇ (AddHom.toFun (LinearMap.toAddHom ‚Üë(QuadraticForm.Isometry.toLinearEquiv self)) m) = ‚ÜëQ‚ÇÅ m)

 : (‚àÄ {G : Type u_1} {Œ± : Type u_2} [inst : Zero G] [inst_1 : VAdd G Œ±] [inst_2 : MeasurableSpace Œ±] {s : Set Œ±}
  {Œº : autoParam (MeasureTheory.Measure Œ±) _auto‚úù} (self : MeasureTheory.IsAddFundamentalDomain G s),
  ‚àÄ·µê (x : Œ±) ‚àÇŒº, ‚àÉ (g : G), g +·µ• x ‚àà s)
<input>:2:48: expected token

 : (‚àÄ {X : TopCat} {x : ‚ÜëX} {y : ‚ÜëX} (e : Inseparable x y), nhds x ‚â§ nhds y)
type mismatch
  X
has type
  TopCat : Type (?u.3 + 1)
but is expected to have type
  Sort ?u.5 : Type ?u.5 ; identifiers [X, TopCat, x, X, y, X, e, Inseparable, x, y, nhds, x, nhds, y] (during elaboration) for (‚àÄ {X : TopCat} {x : ‚ÜëX} {y : ‚ÜëX} (e : Inseparable x y), nhds x ‚â§ nhds y)

 : (‚àÄ (self : YoungDiagram), IsLowerSet ‚Üë(YoungDiagram.cells self))
typeclass instance problem is stuck, it is often due to metavariables
  LE (?m.330 self) ; identifiers [self, YoungDiagram, IsLowerSet, YoungDiagram.cells, self] (during elaboration) for (‚àÄ (self : YoungDiagram), IsLowerSet ‚Üë(YoungDiagram.cells self))

 : (‚àÄ {M : Type u_1} [inst : AddCommMonoid M] {S : AddSubmonoid M} {N : Type u_2} [inst_1 : AddCommMonoid N]
  (self : AddSubmonoid.LocalizationMap S N) (x : M) (y : M),
  (ZeroHom.toFun (‚Üë(AddSubmonoid.LocalizationMap.toAddMonoidHom self)) x =
      ZeroHom.toFun (‚Üë(AddSubmonoid.LocalizationMap.toAddMonoidHom self)) y) ‚Üî
    (‚àÉ (c : { x : M // x ‚àà S }), ‚Üëc + x = ‚Üëc + y))
typeclass instance problem is stuck, it is often due to metavariables
  Zero (?m.9539 self x y) ; identifiers [M, u_1, inst, AddCommMonoid, M, S, AddSubmonoid, M, N, u_2, inst_1, AddCommMonoid, N, self, AddSubmonoid.LocalizationMap, S, N, x, M, y, M, ZeroHom.toFun, AddSubmonoid.LocalizationMap.toAddMonoidHom, self, x, ZeroHom.toFun, AddSubmonoid.LocalizationMap.toAddMonoidHom, self, y, c, x, M, x, S, c, x, c, y] (during elaboration) for (‚àÄ {M : Type u_1} [inst : AddCommMonoid M] {S : AddSubmonoid M} {N : Type u_2} [inst_1 : AddCommMonoid N]
  (self : AddSubmonoid.LocalizationMap S N) (x : M) (y : M),
  (ZeroHom.toFun (‚Üë(AddSubmonoid.LocalizationMap.toAddMonoidHom self)) x =
      ZeroHom.toFun (‚Üë(AddSubmonoid.LocalizationMap.toAddMonoidHom self)) y) ‚Üî
    (‚àÉ (c : { x : M // x ‚àà S }), ‚Üëc + x = ‚Üëc + y))

 : (‚àÄ {Œ± : Type u_1} {s : Set Œ±} {a : Œ±} [inst : Star Œ±], (a ‚àà star s) ‚Üî (star a ‚àà s))
failed to synthesize instance
  Star (Set Œ±) ; identifiers [Œ±, u_1, s, Set, Œ±, a, Œ±, inst, Star, Œ±, a, star, s, star, a, s] (during elaboration) for (‚àÄ {Œ± : Type u_1} {s : Set Œ±} {a : Œ±} [inst : Star Œ±], (a ‚àà star s) ‚Üî (star a ‚àà s))

(‚àÄ {Œ± : Type ua} {Œ≤ : Type ub} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] {f : (a : Œ±) ‚Üí Œ≤},
  (UniformContinuous f) ‚Üî
    (‚àÄ (r : Set (Œ≤ √ó Œ≤)) (a : r ‚àà uniformity Œ≤), {x : Œ± √ó Œ± | (f (Prod.fst x), f (Prod.snd x)) ‚àà r} ‚àà uniformity Œ±))
unknown universe level 'ua' ; identifiers [Œ±, ua, Œ≤, ub, inst, UniformSpace, Œ±, inst_1, UniformSpace, Œ≤, f, a, Œ±, Œ≤, UniformContinuous, f, r, Set, Œ≤, Œ≤, a, r, uniformity, Œ≤, x, Œ±, Œ±, f, Prod.fst, x, f, Prod.snd, x, r, uniformity, Œ±] (during elaboration) for (‚àÄ {Œ± : Type ua} {Œ≤ : Type ub} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] {f : (a : Œ±) ‚Üí Œ≤},
  (UniformContinuous f) ‚Üî
    (‚àÄ (r : Set (Œ≤ √ó Œ≤)) (a : r ‚àà uniformity Œ≤), {x : Œ± √ó Œ± | (f (Prod.fst x), f (Prod.snd x)) ‚àà r} ‚àà uniformity Œ±))

(‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] [inst_1 : OrderTop Œ±] (x : ‚Üë(Set.Iic ‚ä§)) (y : ‚Üë(Set.Iic ‚ä§)),
  (‚Üë{ toFun := ((Equiv.toFun (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1))),
            invFun := ((Equiv.invFun (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1))),
            left_inv := (((Equiv.left_inv (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1)))),
            right_inv := (((Equiv.right_inv (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1)))) }
        x ‚â§
      ‚Üë{ toFun := ((Equiv.toFun (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1))),
            invFun := ((Equiv.invFun (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1))),
            left_inv := (((Equiv.left_inv (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1)))),
            right_inv := (((Equiv.right_inv (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1)))) }
        y) ‚Üî
    (‚Üë{ toFun := ((Equiv.toFun (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1))),
            invFun := ((Equiv.invFun (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1))),
            left_inv := (((Equiv.left_inv (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1)))),
            right_inv := (((Equiv.right_inv (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1)))) }
        x ‚â§
      ‚Üë{ toFun := ((Equiv.toFun (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1))),
            invFun := ((Equiv.invFun (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1))),
            left_inv := (((Equiv.left_inv (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1)))),
            right_inv := (((Equiv.right_inv (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1)))) }
        y))
type mismatch
  Set.Iic ‚ä§
has type
  Set ?m.26 : Type ?u.25
but is expected to have type
  Sort ?u.21 : Type ?u.21 ; identifiers [Œ±, u_1, inst, Preorder, Œ±, inst_1, OrderTop, Œ±, x, Set.Iic, y, Set.Iic, toFun, Equiv.toFun, Equiv.subtypeUnivEquiv, OrderIso.IicTop.proof_1, invFun, Equiv.invFun, Equiv.subtypeUnivEquiv, OrderIso.IicTop.proof_1, left_inv, Equiv.left_inv, Equiv.subtypeUnivEquiv, OrderIso.IicTop.proof_1, right_inv, Equiv.right_inv, Equiv.subtypeUnivEquiv, OrderIso.IicTop.proof_1, x, toFun, Equiv.toFun, Equiv.subtypeUnivEquiv, OrderIso.IicTop.proof_1, invFun, Equiv.invFun, Equiv.subtypeUnivEquiv, OrderIso.IicTop.proof_1, left_inv, Equiv.left_inv, Equiv.subtypeUnivEquiv, OrderIso.IicTop.proof_1, right_inv, Equiv.right_inv, Equiv.subtypeUnivEquiv, OrderIso.IicTop.proof_1, y, toFun, Equiv.toFun, Equiv.subtypeUnivEquiv, OrderIso.IicTop.proof_1, invFun, Equiv.invFun, Equiv.subtypeUnivEquiv, OrderIso.IicTop.proof_1, left_inv, Equiv.left_inv, Equiv.subtypeUnivEquiv, OrderIso.IicTop.proof_1, right_inv, Equiv.right_inv, Equiv.subtypeUnivEquiv, OrderIso.IicTop.proof_1, x, toFun, Equiv.toFun, Equiv.subtypeUnivEquiv, OrderIso.IicTop.proof_1, invFun, Equiv.invFun, Equiv.subtypeUnivEquiv, OrderIso.IicTop.proof_1, left_inv, Equiv.left_inv, Equiv.subtypeUnivEquiv, OrderIso.IicTop.proof_1, right_inv, Equiv.right_inv, Equiv.subtypeUnivEquiv, OrderIso.IicTop.proof_1, y] (during elaboration) for (‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] [inst_1 : OrderTop Œ±] (x : ‚Üë(Set.Iic ‚ä§)) (y : ‚Üë(Set.Iic ‚ä§)),
  (‚Üë{ toFun := ((Equiv.toFun (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1))),
            invFun := ((Equiv.invFun (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1))),
            left_inv := (((Equiv.left_inv (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1)))),
            right_inv := (((Equiv.right_inv (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1)))) }
        x ‚â§
      ‚Üë{ toFun := ((Equiv.toFun (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1))),
            invFun := ((Equiv.invFun (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1))),
            left_inv := (((Equiv.left_inv (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1)))),
            right_inv := (((Equiv.right_inv (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1)))) }
        y) ‚Üî
    (‚Üë{ toFun := ((Equiv.toFun (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1))),
            invFun := ((Equiv.invFun (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1))),
            left_inv := (((Equiv.left_inv (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1)))),
            right_inv := (((Equiv.right_inv (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1)))) }
        x ‚â§
      ‚Üë{ toFun := ((Equiv.toFun (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1))),
            invFun := ((Equiv.invFun (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1))),
            left_inv := (((Equiv.left_inv (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1)))),
            right_inv := (((Equiv.right_inv (Equiv.subtypeUnivEquiv OrderIso.IicTop.proof_1)))) }
        y))

(‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] {A : C},
  (CategoryTheory.IsSubterminal A) ‚Üî (‚àÄ ‚¶ÉZ : C‚¶Ñ (f : Z ‚ü∂ A) (g : Z ‚ü∂ A), f = g))
unknown universe level 'v‚ÇÅ' ; identifiers [C, u‚ÇÅ, inst, CategoryTheory.Category, v‚ÇÅ, u‚ÇÅ, C, A, C, CategoryTheory.IsSubterminal, A, Z, C, f, Z, A, g, Z, A, f, g] (during elaboration) for (‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] {A : C},
  (CategoryTheory.IsSubterminal A) ‚Üî (‚àÄ ‚¶ÉZ : C‚¶Ñ (f : Z ‚ü∂ A) (g : Z ‚ü∂ A), f = g))

(‚àÄ {J : Type v} [inst : CategoryTheory.SmallCategory J] {F : CategoryTheory.Functor J CommRingCat} [inst_1 : SizeOf J],
  sizeOf CommRingCat.Colimits.Prequotient.one = 1)
typeclass instance problem is stuck, it is often due to metavariables
  SizeOf (CommRingCat.Colimits.Prequotient ?m.13078) ; identifiers [J, v, inst, CategoryTheory.SmallCategory, J, F, CategoryTheory.Functor, J, CommRingCat, inst_1, SizeOf, J, sizeOf, CommRingCat.Colimits.Prequotient.one] (during elaboration) for (‚àÄ {J : Type v} [inst : CategoryTheory.SmallCategory J] {F : CategoryTheory.Functor J CommRingCat} [inst_1 : SizeOf J],
  sizeOf CommRingCat.Colimits.Prequotient.one = 1)

(‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} {l : Filter Œ±} {r : (a : Œ≤) ‚Üí (a : Œ≥) ‚Üí Prop} {f : (a : Œ±) ‚Üí Œ≤}
  {g : (a : Œ±) ‚Üí Œ≥}, (Filter.Germ.LiftRel r ‚Üëf ‚Üëg) ‚Üî (‚àÄ·∂† (x : Œ±) in l, r (f x) (g x)))
type mismatch
  g
has type
  Œ± ‚Üí Œ≥ : Type (max u_1 u_3)
but is expected to have type
  Filter.Germ ?m.223 Œ≥ : Type (max ?u.30 u_3) ; identifiers [Œ±, u_1, Œ≤, u_2, Œ≥, u_3, l, Filter, Œ±, r, a, Œ≤, a, Œ≥, f, a, Œ±, Œ≤, g, a, Œ±, Œ≥, Filter.Germ.LiftRel, r, f, g, x, Œ±, l, r, f, x, g, x] (during elaboration) for (‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} {l : Filter Œ±} {r : (a : Œ≤) ‚Üí (a : Œ≥) ‚Üí Prop} {f : (a : Œ±) ‚Üí Œ≤}
  {g : (a : Œ±) ‚Üí Œ≥}, (Filter.Germ.LiftRel r ‚Üëf ‚Üëg) ‚Üî (‚àÄ·∂† (x : Œ±) in l, r (f x) (g x)))

(‚àÄ {J : Type u‚ÇÅ} [inst : SizeOf J], sizeOf CategoryTheory.Bicone.right = 1)
typeclass instance problem is stuck, it is often due to metavariables
  SizeOf (CategoryTheory.Bicone ?m.6881) ; identifiers [J, u‚ÇÅ, inst, SizeOf, J, sizeOf, CategoryTheory.Bicone.right] (during elaboration) for (‚àÄ {J : Type u‚ÇÅ} [inst : SizeOf J], sizeOf CategoryTheory.Bicone.right = 1)

(‚àÄ {L : FirstOrder.Language} (M : Type w) [inst : FirstOrder.Language.Structure L M]
  {œÜ : FirstOrder.Language.Sentence L}, (M ‚ä® FirstOrder.Language.Formula.not œÜ) ‚Üî (¬¨(M ‚ä® œÜ)))
ambiguous, possible interpretations 
  M ‚ä® ?m.508 : Prop
  
  M ‚ä® FirstOrder.Language.Formula.not œÜ : Prop ; identifiers [L, FirstOrder.Language, M, w, inst, FirstOrder.Language.Structure, L, M, œÜ, FirstOrder.Language.Sentence, L, M, FirstOrder.Language.Formula.not, œÜ, M, FirstOrder.Language.Formula.not, œÜ, M, œÜ, M, œÜ] (during elaboration) for (‚àÄ {L : FirstOrder.Language} (M : Type w) [inst : FirstOrder.Language.Structure L M]
  {œÜ : FirstOrder.Language.Sentence L}, (M ‚ä® FirstOrder.Language.Formula.not œÜ) ‚Üî (¬¨(M ‚ä® œÜ)))

(‚àÄ {J : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J] [inst_1 : SizeOf J],
  sizeOf CategoryTheory.BiconeHom.right_id = 1)
unknown universe level 'v‚ÇÅ' ; identifiers [J, u‚ÇÅ, inst, CategoryTheory.Category, v‚ÇÅ, u‚ÇÅ, J, inst_1, SizeOf, J, sizeOf, CategoryTheory.BiconeHom.right_id] (during elaboration) for (‚àÄ {J : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J] [inst_1 : SizeOf J],
  sizeOf CategoryTheory.BiconeHom.right_id = 1)

(‚àÄ {R : Type u_1} [inst : Semiring R] (h : IsField R) (a : R) (b : R), a / b = a / b)
failed to synthesize instance
  HDiv R R ?m.293 ; identifiers [R, u_1, inst, Semiring, R, h, IsField, R, a, R, b, R, a, b, a, b] (during elaboration) for (‚àÄ {R : Type u_1} [inst : Semiring R] (h : IsField R) (a : R) (b : R), a / b = a / b)

(‚àÄ {Œ± : Type u_1} {l : List Œ±}, (Multiset.Nodup ‚Üël) ‚Üî (List.Nodup l))
type mismatch
  l
has type
  List Œ± : Type u_1
but is expected to have type
  Multiset ?m.117 : Type u_1 ; identifiers [Œ±, u_1, l, List, Œ±, Multiset.Nodup, l, List.Nodup, l] (during elaboration) for (‚àÄ {Œ± : Type u_1} {l : List Œ±}, (Multiset.Nodup ‚Üël) ‚Üî (List.Nodup l))

(CategoryTheory.BundledHom.ParentProjection fun {Œ± : Type u_1} (h : AddGroup Œ±) ‚Ü¶ SubNegMonoid.toAddMonoid)
typeclass instance problem is stuck, it is often due to metavariables
  SubNegMonoid ?m.41 ; identifiers [CategoryTheory.BundledHom.ParentProjection, Œ±, u_1, h, AddGroup, Œ±, SubNegMonoid.toAddMonoid] (during elaboration) for (CategoryTheory.BundledHom.ParentProjection fun {Œ± : Type u_1} (h : AddGroup Œ±) ‚Ü¶ SubNegMonoid.toAddMonoid)

(‚àÄ {Œπ : Type uŒπ} {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] [inst_2 : FiniteDimensional ‚Ñù E]
  {H : Type uH} [inst_3 : TopologicalSpace H] {I : ModelWithCorners ‚Ñù E H} {M : Type uM} [inst_4 : TopologicalSpace M]
  [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] {s : Set M} [inst_7 : T2Space M]
  {f : SmoothBumpCovering Œπ I M s} {U : (a : M) ‚Üí Set M},
  (BumpCovering.IsSubordinate (SmoothBumpCovering.toBumpCovering f) fun (i : Œπ) ‚Ü¶ U (SmoothBumpCovering.c s f i)) ‚Üî
    (SmoothBumpCovering.IsSubordinate f U))
unknown universe level 'uH' ; identifiers [Œπ, uŒπ, E, uE, inst, NormedAddCommGroup, E, inst_1, NormedSpace, E, inst_2, FiniteDimensional, E, H, uH, inst_3, TopologicalSpace, H, I, ModelWithCorners, E, H, M, uM, inst_4, TopologicalSpace, M, inst_5, ChartedSpace, H, M, inst_6, SmoothManifoldWithCorners, I, M, s, Set, M, inst_7, T2Space, M, f, SmoothBumpCovering, Œπ, I, M, s, U, a, M, Set, M, BumpCovering.IsSubordinate, SmoothBumpCovering.toBumpCovering, f, i, Œπ, U, SmoothBumpCovering.c, s, f, i, SmoothBumpCovering.IsSubordinate, f, U] (during elaboration) for (‚àÄ {Œπ : Type uŒπ} {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] [inst_2 : FiniteDimensional ‚Ñù E]
  {H : Type uH} [inst_3 : TopologicalSpace H] {I : ModelWithCorners ‚Ñù E H} {M : Type uM} [inst_4 : TopologicalSpace M]
  [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] {s : Set M} [inst_7 : T2Space M]
  {f : SmoothBumpCovering Œπ I M s} {U : (a : M) ‚Üí Set M},
  (BumpCovering.IsSubordinate (SmoothBumpCovering.toBumpCovering f) fun (i : Œπ) ‚Ü¶ U (SmoothBumpCovering.c s f i)) ‚Üî
    (SmoothBumpCovering.IsSubordinate f U))

(‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : SMul Œ± Œ≤] {f : Filter Œ±} {g : Filter Œ≤} {t : Set Œ≤},
  (t ‚àà f ‚Ä¢ g) ‚Üî (‚àÉ (t‚ÇÅ : Set Œ±), ‚àÉ (t‚ÇÇ : Set Œ≤), (t‚ÇÅ ‚àà f) ‚àß ((t‚ÇÇ ‚àà g) ‚àß (t‚ÇÅ ‚Ä¢ t‚ÇÇ ‚äÜ t))))
failed to synthesize instance
  HSMul (Filter Œ±) (Filter Œ≤) ?m.33 ; identifiers [Œ±, u_2, Œ≤, u_3, inst, SMul, Œ±, Œ≤, f, Filter, Œ±, g, Filter, Œ≤, t, Set, Œ≤, t, f, g, t‚ÇÅ, Set, Œ±, t‚ÇÇ, Set, Œ≤, t‚ÇÅ, f, t‚ÇÇ, g, t‚ÇÅ, t‚ÇÇ, t] (during elaboration) for (‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : SMul Œ± Œ≤] {f : Filter Œ±} {g : Filter Œ≤} {t : Set Œ≤},
  (t ‚àà f ‚Ä¢ g) ‚Üî (‚àÉ (t‚ÇÅ : Set Œ±), ‚àÉ (t‚ÇÇ : Set Œ≤), (t‚ÇÅ ‚àà f) ‚àß ((t‚ÇÇ ‚àà g) ‚àß (t‚ÇÅ ‚Ä¢ t‚ÇÇ ‚äÜ t))))

(‚àÄ {A : Type u_1} [inst : AddZeroClass A] {a : AddSubmonoid A} {b : AddSubmonoid A},
  (‚Üë{
            toFun :=
              ((fun (S : AddSubmonoid A) ‚Ü¶
                {
                  toSubsemigroup :=
                    (({ carrier := ((‚ÜëMultiplicative.toAdd ‚Åª¬π' ‚ÜëS)),
                      mul_mem' :=
                        (((fun {a : Multiplicative A} ‚Ü¶
                          (_ :
                            ‚àÄ {b : Multiplicative A} (ha : a ‚àà ‚ÜëMultiplicative.toAdd ‚Åª¬π' ‚ÜëS)
                              (hb : b ‚àà ‚ÜëMultiplicative.toAdd ‚Åª¬π' ‚ÜëS),
                              ‚ÜëMultiplicative.toAdd a + ‚ÜëMultiplicative.toAdd b ‚àà
                                AddSubsemigroup.carrier (AddSubmonoid.toAddSubsemigroup S))))) })),
                  one_mem' := (((AddSubmonoid.zero_mem' S))) })),
            invFun :=
              ((fun (S : Submonoid (Multiplicative A)) ‚Ü¶
                {
                  toAddSubsemigroup :=
                    (({ carrier := ((‚ÜëMultiplicative.ofAdd ‚Åª¬π' ‚ÜëS)),
                      add_mem' :=
                        (((fun {a : A} ‚Ü¶
                          (_ :
                            ‚àÄ {b : A} (ha : a ‚àà ‚ÜëMultiplicative.ofAdd ‚Åª¬π' ‚ÜëS) (hb : b ‚àà ‚ÜëMultiplicative.ofAdd ‚Åª¬π' ‚ÜëS),
                              a * b ‚àà Subsemigroup.carrier (Submonoid.toSubsemigroup S))))) })),
                  zero_mem' := (((Submonoid.one_mem' S))) })),
            left_inv :=
              (((fun (x : AddSubmonoid A) ‚Ü¶
                (_ :
                  (fun (S : Submonoid (Multiplicative A)) ‚Ü¶
                        {
                          toAddSubsemigroup :=
                            (({ carrier := ((‚ÜëMultiplicative.ofAdd ‚Åª¬π' ‚ÜëS)),
                              add_mem' :=
                                (((fun {a : A} ‚Ü¶
                                  (_ :
                                    ‚àÄ {b : A} (ha : a ‚àà ‚ÜëMultiplicative.ofAdd ‚Åª¬π' ‚ÜëS)
                                      (hb : b ‚àà ‚ÜëMultiplicative.ofAdd ‚Åª¬π' ‚ÜëS),
                                      a * b ‚àà Subsemigroup.carrier (Submonoid.toSubsemigroup S))))) })),
                          zero_mem' := (((Submonoid.one_mem' S))) })
                      ((fun (S : AddSubmonoid A) ‚Ü¶
                          {
                            toSubsemigroup :=
                              (({ carrier := ((‚ÜëMultiplicative.toAdd ‚Åª¬π' ‚ÜëS)),
                                mul_mem' :=
                                  (((fun {a : Multiplicative A} ‚Ü¶
                                    (_ :
                                      ‚àÄ {b : Multiplicative A} (ha : a ‚àà ‚ÜëMultiplicative.toAdd ‚Åª¬π' ‚ÜëS)
                                        (hb : b ‚àà ‚ÜëMultiplicative.toAdd ‚Åª¬π' ‚ÜëS),
                                        ‚ÜëMultiplicative.toAdd a + ‚ÜëMultiplicative.toAdd b ‚àà
                                          AddSubsemigroup.carrier (AddSubmonoid.toAddSubsemigroup S))))) })),
                            one_mem' := (((AddSubmonoid.zero_mem' S))) })
                        x) =
                    x)))),
            right_inv :=
              (((fun (x : Submonoid (Multiplicative A)) ‚Ü¶
                (_ :
                  (fun (S : AddSubmonoid A) ‚Ü¶
                        {
                          toSubsemigroup :=
                            (({ carrier := ((‚ÜëMultiplicative.toAdd ‚Åª¬π' ‚ÜëS)),
                              mul_mem' :=
                                (((fun {a : Multiplicative A} ‚Ü¶
                                  (_ :
                                    ‚àÄ {b : Multiplicative A} (ha : a ‚àà ‚ÜëMultiplicative.toAdd ‚Åª¬π' ‚ÜëS)
                                      (hb : b ‚àà ‚ÜëMultiplicative.toAdd ‚Åª¬π' ‚ÜëS),
                                      ‚ÜëMultiplicative.toAdd a + ‚ÜëMultiplicative.toAdd b ‚àà
                                        AddSubsemigroup.carrier (AddSubmonoid.toAddSubsemigroup S))))) })),
                          one_mem' := (((AddSubmonoid.zero_mem' S))) })
                      ((fun (S : Submonoid (Multiplicative A)) ‚Ü¶
                          {
                            toAddSubsemigroup :=
                              (({ carrier := ((‚ÜëMultiplicative.ofAdd ‚Åª¬π' ‚ÜëS)),
                                add_mem' :=
                                  (((fun {a : A} ‚Ü¶
                                    (_ :
                                      ‚àÄ {b : A} (ha : a ‚àà ‚ÜëMultiplicative.ofAdd ‚Åª¬π' ‚ÜëS)
                                        (hb : b ‚àà ‚ÜëMultiplicative.ofAdd ‚Åª¬π' ‚ÜëS),
                                        a * b ‚àà Subsemigroup.carrier (Submonoid.toSubsemigroup S))))) })),
                            zero_mem' := (((Submonoid.one_mem' S))) })
                        x) =
                    x)))) }
        a ‚â§
      ‚Üë{
            toFun :=
              ((fun (S : AddSubmonoid A) ‚Ü¶
                {
                  toSubsemigroup :=
                    (({ carrier := ((‚ÜëMultiplicative.toAdd ‚Åª¬π' ‚ÜëS)),
                      mul_mem' :=
                        (((fun {a : Multiplicative A} ‚Ü¶
                          (_ :
                            ‚àÄ {b : Multiplicative A} (ha : a ‚àà ‚ÜëMultiplicative.toAdd ‚Åª¬π' ‚ÜëS)
                              (hb : b ‚àà ‚ÜëMultiplicative.toAdd ‚Åª¬π' ‚ÜëS),
                              ‚ÜëMultiplicative.toAdd a + ‚ÜëMultiplicative.toAdd b ‚àà
                                AddSubsemigroup.carrier (AddSubmonoid.toAddSubsemigroup S))))) })),
                  one_mem' := (((AddSubmonoid.zero_mem' S))) })),
            invFun :=
              ((fun (S : Submonoid (Multiplicative A)) ‚Ü¶
                {
                  toAddSubsemigroup :=
                    (({ carrier := ((‚ÜëMultiplicative.ofAdd ‚Åª¬π' ‚ÜëS)),
                      add_mem' :=
                        (((fun {a : A} ‚Ü¶
                          (_ :
                            ‚àÄ {b : A} (ha : a ‚àà ‚ÜëMultiplicative.ofAdd ‚Åª¬π' ‚ÜëS) (hb : b ‚àà ‚ÜëMultiplicative.ofAdd ‚Åª¬π' ‚ÜëS),
                              a * b ‚àà Subsemigroup.carrier (Submonoid.toSubsemigroup S))))) })),
                  zero_mem' := (((Submonoid.one_mem' S))) })),
            left_inv :=
              (((fun (x : AddSubmonoid A) ‚Ü¶
                (_ :
                  (fun (S : Submonoid (Multiplicative A)) ‚Ü¶
                        {
                          toAddSubsemigroup :=
                            (({ carrier := ((‚ÜëMultiplicative.ofAdd ‚Åª¬π' ‚ÜëS)),
                              add_mem' :=
                                (((fun {a : A} ‚Ü¶
                                  (_ :
                                    ‚àÄ {b : A} (ha : a ‚àà ‚ÜëMultiplicative.ofAdd ‚Åª¬π' ‚ÜëS)
                                      (hb : b ‚àà ‚ÜëMultiplicative.ofAdd ‚Åª¬π' ‚ÜëS),
                                      a * b ‚àà Subsemigroup.carrier (Submonoid.toSubsemigroup S))))) })),
                          zero_mem' := (((Submonoid.one_mem' S))) })
                      ((fun (S : AddSubmonoid A) ‚Ü¶
                          {
                            toSubsemigroup :=
                              (({ carrier := ((‚ÜëMultiplicative.toAdd ‚Åª¬π' ‚ÜëS)),
                                mul_mem' :=
                                  (((fun {a : Multiplicative A} ‚Ü¶
                                    (_ :
                                      ‚àÄ {b : Multiplicative A} (ha : a ‚àà ‚ÜëMultiplicative.toAdd ‚Åª¬π' ‚ÜëS)
                                        (hb : b ‚àà ‚ÜëMultiplicative.toAdd ‚Åª¬π' ‚ÜëS),
                                        ‚ÜëMultiplicative.toAdd a + ‚ÜëMultiplicative.toAdd b ‚àà
                                          AddSubsemigroup.carrier (AddSubmonoid.toAddSubsemigroup S))))) })),
                            one_mem' := (((AddSubmonoid.zero_mem' S))) })
                        x) =
                    x)))),
            right_inv :=
              (((fun (x : Submonoid (Multiplicative A)) ‚Ü¶
                (_ :
                  (fun (S : AddSubmonoid A) ‚Ü¶
                        {
                          toSubsemigroup :=
                            (({ carrier := ((‚ÜëMultiplicative.toAdd ‚Åª¬π' ‚ÜëS)),
                              mul_mem' :=
                                (((fun {a : Multiplicative A} ‚Ü¶
                                  (_ :
                                    ‚àÄ {b : Multiplicative A} (ha : a ‚àà ‚ÜëMultiplicative.toAdd ‚Åª¬π' ‚ÜëS)
                                      (hb : b ‚àà ‚ÜëMultiplicative.toAdd ‚Åª¬π' ‚ÜëS),
                                      ‚ÜëMultiplicative.toAdd a + ‚ÜëMultiplicative.toAdd b ‚àà
                                        AddSubsemigroup.carrier (AddSubmonoid.toAddSubsemigroup S))))) })),
                          one_mem' := (((AddSubmonoid.zero_mem' S))) })
                      ((fun (S : Submonoid (Multiplicative A)) ‚Ü¶
                          {
                            toAddSubsemigroup :=
                              (({ carrier := ((‚ÜëMultiplicative.ofAdd ‚Åª¬π' ‚ÜëS)),
                                add_mem' :=
                                  (((fun {a : A} ‚Ü¶
                                    (_ :
                                      ‚àÄ {b : A} (ha : a ‚àà ‚ÜëMultiplicative.ofAdd ‚Åª¬π' ‚ÜëS)
                                        (hb : b ‚àà ‚ÜëMultiplicative.ofAdd ‚Åª¬π' ‚ÜëS),
                                        a * b ‚àà Subsemigroup.carrier (Submonoid.toSubsemigroup S))))) })),
                            zero_mem' := (((Submonoid.one_mem' S))) })
                        x) =
                    x)))) }
        b) ‚Üî
    (‚Üë{
            toFun :=
              ((fun (S : AddSubmonoid A) ‚Ü¶
                {
                  toSubsemigroup :=
                    (({ carrier := ((‚ÜëMultiplicative.toAdd ‚Åª¬π' ‚ÜëS)),
                      mul_mem' :=
                        (((fun {a : Multiplicative A} ‚Ü¶
                          (_ :
                            ‚àÄ {b : Multiplicative A} (ha : a ‚àà ‚ÜëMultiplicative.toAdd ‚Åª¬π' ‚ÜëS)
                              (hb : b ‚àà ‚ÜëMultiplicative.toAdd ‚Åª¬π' ‚ÜëS),
                              ‚ÜëMultiplicative.toAdd a + ‚ÜëMultiplicative.toAdd b ‚àà
                                AddSubsemigroup.carrier (AddSubmonoid.toAddSubsemigroup S))))) })),
                  one_mem' := (((AddSubmonoid.zero_mem' S))) })),
            invFun :=
              ((fun (S : Submonoid (Multiplicative A)) ‚Ü¶
                {
                  toAddSubsemigroup :=
                    (({ carrier := ((‚ÜëMultiplicative.ofAdd ‚Åª¬π' ‚ÜëS)),
                      add_mem' :=
                        (((fun {a : A} ‚Ü¶
                          (_ :
                            ‚àÄ {b : A} (ha : a ‚àà ‚ÜëMultiplicative.ofAdd ‚Åª¬π' ‚ÜëS) (hb : b ‚àà ‚ÜëMultiplicative.ofAdd ‚Åª¬π' ‚ÜëS),
                              a * b ‚àà Subsemigroup.carrier (Submonoid.toSubsemigroup S))))) })),
                  zero_mem' := (((Submonoid.one_mem' S))) })),
            left_inv :=
              (((fun (x : AddSubmonoid A) ‚Ü¶
                (_ :
                  (fun (S : Submonoid (Multiplicative A)) ‚Ü¶
                        {
                          toAddSubsemigroup :=
                            (({ carrier := ((‚ÜëMultiplicative.ofAdd ‚Åª¬π' ‚ÜëS)),
                              add_mem' :=
                                (((fun {a : A} ‚Ü¶
                                  (_ :
                                    ‚àÄ {b : A} (ha : a ‚àà ‚ÜëMultiplicative.ofAdd ‚Åª¬π' ‚ÜëS)
                                      (hb : b ‚àà ‚ÜëMultiplicative.ofAdd ‚Åª¬π' ‚ÜëS),
                                      a * b ‚àà Subsemigroup.carrier (Submonoid.toSubsemigroup S))))) })),
                          zero_mem' := (((Submonoid.one_mem' S))) })
                      ((fun (S : AddSubmonoid A) ‚Ü¶
                          {
                            toSubsemigroup :=
                              (({ carrier := ((‚ÜëMultiplicative.toAdd ‚Åª¬π' ‚ÜëS)),
                                mul_mem' :=
                                  (((fun {a : Multiplicative A} ‚Ü¶
                                    (_ :
                                      ‚àÄ {b : Multiplicative A} (ha : a ‚àà ‚ÜëMultiplicative.toAdd ‚Åª¬π' ‚ÜëS)
                                        (hb : b ‚àà ‚ÜëMultiplicative.toAdd ‚Åª¬π' ‚ÜëS),
                                        ‚ÜëMultiplicative.toAdd a + ‚ÜëMultiplicative.toAdd b ‚àà
                                          AddSubsemigroup.carrier (AddSubmonoid.toAddSubsemigroup S))))) })),
                            one_mem' := (((AddSubmonoid.zero_mem' S))) })
                        x) =
                    x)))),
            right_inv :=
              (((fun (x : Submonoid (Multiplicative A)) ‚Ü¶
                (_ :
                  (fun (S : AddSubmonoid A) ‚Ü¶
                        {
                          toSubsemigroup :=
                            (({ carrier := ((‚ÜëMultiplicative.toAdd ‚Åª¬π' ‚ÜëS)),
                              mul_mem' :=
                                (((fun {a : Multiplicative A} ‚Ü¶
                                  (_ :
                                    ‚àÄ {b : Multiplicative A} (ha : a ‚àà ‚ÜëMultiplicative.toAdd ‚Åª¬π' ‚ÜëS)
                                      (hb : b ‚àà ‚ÜëMultiplicative.toAdd ‚Åª¬π' ‚ÜëS),
                                      ‚ÜëMultiplicative.toAdd a + ‚ÜëMultiplicative.toAdd b ‚àà
                                        AddSubsemigroup.carrier (AddSubmonoid.toAddSubsemigroup S))))) })),
                          one_mem' := (((AddSubmonoid.zero_mem' S))) })
                      ((fun (S : Submonoid (Multiplicative A)) ‚Ü¶
                          {
                            toAddSubsemigroup :=
                              (({ carrier := ((‚ÜëMultiplicative.ofAdd ‚Åª¬π' ‚ÜëS)),
                                add_mem' :=
                                  (((fun {a : A} ‚Ü¶
                                    (_ :
                                      ‚àÄ {b : A} (ha : a ‚àà ‚ÜëMultiplicative.ofAdd ‚Åª¬π' ‚ÜëS)
                                        (hb : b ‚àà ‚ÜëMultiplicative.ofAdd ‚Åª¬π' ‚ÜëS),
                                        a * b ‚àà Subsemigroup.carrier (Submonoid.toSubsemigroup S))))) })),
                            zero_mem' := (((Submonoid.one_mem' S))) })
                        x) =
                    x)))) }
        a ‚â§
      ‚Üë{
            toFun :=
              ((fun (S : AddSubmonoid A) ‚Ü¶
                {
                  toSubsemigroup :=
                    (({ carrier := ((‚ÜëMultiplicative.toAdd ‚Åª¬π' ‚ÜëS)),
                      mul_mem' :=
                        (((fun {a : Multiplicative A} ‚Ü¶
                          (_ :
                            ‚àÄ {b : Multiplicative A} (ha : a ‚àà ‚ÜëMultiplicative.toAdd ‚Åª¬π' ‚ÜëS)
                              (hb : b ‚àà ‚ÜëMultiplicative.toAdd ‚Åª¬π' ‚ÜëS),
                              ‚ÜëMultiplicative.toAdd a + ‚ÜëMultiplicative.toAdd b ‚àà
                                AddSubsemigroup.carrier (AddSubmonoid.toAddSubsemigroup S))))) })),
                  one_mem' := (((AddSubmonoid.zero_mem' S))) })),
            invFun :=
              ((fun (S : Submonoid (Multiplicative A)) ‚Ü¶
                {
                  toAddSubsemigroup :=
                    (({ carrier := ((‚ÜëMultiplicative.ofAdd ‚Åª¬π' ‚ÜëS)),
                      add_mem' :=
                        (((fun {a : A} ‚Ü¶
                          (_ :
                            ‚àÄ {b : A} (ha : a ‚àà ‚ÜëMultiplicative.ofAdd ‚Åª¬π' ‚ÜëS) (hb : b ‚àà ‚ÜëMultiplicative.ofAdd ‚Åª¬π' ‚ÜëS),
                              a * b ‚àà Subsemigroup.carrier (Submonoid.toSubsemigroup S))))) })),
                  zero_mem' := (((Submonoid.one_mem' S))) })),
            left_inv :=
              (((fun (x : AddSubmonoid A) ‚Ü¶
                (_ :
                  (fun (S : Submonoid (Multiplicative A)) ‚Ü¶
                        {
                          toAddSubsemigroup :=
                            (({ carrier := ((‚ÜëMultiplicative.ofAdd ‚Åª¬π' ‚ÜëS)),
                              add_mem' :=
                                (((fun {a : A} ‚Ü¶
                                  (_ :
                                    ‚àÄ {b : A} (ha : a ‚àà ‚ÜëMultiplicative.ofAdd ‚Åª¬π' ‚ÜëS)
                                      (hb : b ‚àà ‚ÜëMultiplicative.ofAdd ‚Åª¬π' ‚ÜëS),
                                      a * b ‚àà Subsemigroup.carrier (Submonoid.toSubsemigroup S))))) })),
                          zero_mem' := (((Submonoid.one_mem' S))) })
                      ((fun (S : AddSubmonoid A) ‚Ü¶
                          {
                            toSubsemigroup :=
                              (({ carrier := ((‚ÜëMultiplicative.toAdd ‚Åª¬π' ‚ÜëS)),
                                mul_mem' :=
                                  (((fun {a : Multiplicative A} ‚Ü¶
                                    (_ :
                                      ‚àÄ {b : Multiplicative A} (ha : a ‚àà ‚ÜëMultiplicative.toAdd ‚Åª¬π' ‚ÜëS)
                                        (hb : b ‚àà ‚ÜëMultiplicative.toAdd ‚Åª¬π' ‚ÜëS),
                                        ‚ÜëMultiplicative.toAdd a + ‚ÜëMultiplicative.toAdd b ‚àà
                                          AddSubsemigroup.carrier (AddSubmonoid.toAddSubsemigroup S))))) })),
                            one_mem' := (((AddSubmonoid.zero_mem' S))) })
                        x) =
                    x)))),
            right_inv :=
              (((fun (x : Submonoid (Multiplicative A)) ‚Ü¶
                (_ :
                  (fun (S : AddSubmonoid A) ‚Ü¶
                        {
                          toSubsemigroup :=
                            (({ carrier := ((‚ÜëMultiplicative.toAdd ‚Åª¬π' ‚ÜëS)),
                              mul_mem' :=
                                (((fun {a : Multiplicative A} ‚Ü¶
                                  (_ :
                                    ‚àÄ {b : Multiplicative A} (ha : a ‚àà ‚ÜëMultiplicative.toAdd ‚Åª¬π' ‚ÜëS)
                                      (hb : b ‚àà ‚ÜëMultiplicative.toAdd ‚Åª¬π' ‚ÜëS),
                                      ‚ÜëMultiplicative.toAdd a + ‚ÜëMultiplicative.toAdd b ‚àà
                                        AddSubsemigroup.carrier (AddSubmonoid.toAddSubsemigroup S))))) })),
                          one_mem' := (((AddSubmonoid.zero_mem' S))) })
                      ((fun (S : Submonoid (Multiplicative A)) ‚Ü¶
                          {
                            toAddSubsemigroup :=
                              (({ carrier := ((‚ÜëMultiplicative.ofAdd ‚Åª¬π' ‚ÜëS)),
                                add_mem' :=
                                  (((fun {a : A} ‚Ü¶
                                    (_ :
                                      ‚àÄ {b : A} (ha : a ‚àà ‚ÜëMultiplicative.ofAdd ‚Åª¬π' ‚ÜëS)
                                        (hb : b ‚àà ‚ÜëMultiplicative.ofAdd ‚Åª¬π' ‚ÜëS),
                                        a * b ‚àà Subsemigroup.carrier (Submonoid.toSubsemigroup S))))) })),
                            zero_mem' := (((Submonoid.one_mem' S))) })
                        x) =
                    x)))) }
        b))
<input>:8:22: expected '}'

(‚àÄ {G : Type u_1} [inst : Group G] {S : Type u_6} (H : S) [inst_1 : SetLike S G] [inst_2 : SubgroupClass S G],
  ‚Üë‚ÜëH = Subtype.val)
type mismatch
  H
has type
  S : Type u_6
but is expected to have type
  Subtype (?m.164168 H) ‚Üí ?m.164167 H : Sort (imax (max 1 ?u.147) ?u.147) ; identifiers [G, u_1, inst, Group, G, S, u_6, H, S, inst_1, SetLike, S, G, inst_2, SubgroupClass, S, G, H, Subtype.val] (during elaboration) for (‚àÄ {G : Type u_1} [inst : Group G] {S : Type u_6} (H : S) [inst_1 : SetLike S G] [inst_2 : SubgroupClass S G],
  ‚Üë‚ÜëH = Subtype.val)

(‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] {a : ‚ÜëSet.univ} {b : ‚ÜëSet.univ},
  (‚Üë(Equiv.Set.univ Œ±) a ‚â§ ‚Üë(Equiv.Set.univ Œ±) b) ‚Üî (‚Üë(Equiv.Set.univ Œ±) a ‚â§ ‚Üë(Equiv.Set.univ Œ±) b))
type mismatch
  Set.univ
has type
  Set ?m.9 : Type ?u.8
but is expected to have type
  Sort ?u.7 : Type ?u.7 ; identifiers [Œ±, u_1, inst, Preorder, Œ±, a, Set.univ, b, Set.univ, Equiv.Set.univ, Œ±, a, Equiv.Set.univ, Œ±, b, Equiv.Set.univ, Œ±, a, Equiv.Set.univ, Œ±, b] (during elaboration) for (‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] {a : ‚ÜëSet.univ} {b : ‚ÜëSet.univ},
  (‚Üë(Equiv.Set.univ Œ±) a ‚â§ ‚Üë(Equiv.Set.univ Œ±) b) ‚Üî (‚Üë(Equiv.Set.univ Œ±) a ‚â§ ‚Üë(Equiv.Set.univ Œ±) b))

(‚àÄ {J : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J] [inst_1 : SizeOf J],
  sizeOf CategoryTheory.BiconeHom.left_id = 1)
unknown universe level 'v‚ÇÅ' ; identifiers [J, u‚ÇÅ, inst, CategoryTheory.Category, v‚ÇÅ, u‚ÇÅ, J, inst_1, SizeOf, J, sizeOf, CategoryTheory.BiconeHom.left_id] (during elaboration) for (‚àÄ {J : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J] [inst_1 : SizeOf J],
  sizeOf CategoryTheory.BiconeHom.left_id = 1)

(‚àÄ {R : Type u} [inst : Ring R] {J : Type w} [inst_1 : CategoryTheory.Category.{v, w} J]
  {F : CategoryTheory.Functor J (ModuleCat R)} [inst_2 : SizeOf R] [inst_3 : SizeOf J],
  sizeOf ModuleCat.Colimits.Prequotient.zero = 1)
typeclass instance problem is stuck, it is often due to metavariables
  SizeOf (ModuleCat.Colimits.Prequotient ?m.13886) ; identifiers [R, u, inst, Ring, R, J, w, inst_1, CategoryTheory.Category, v, w, J, F, CategoryTheory.Functor, J, ModuleCat, R, inst_2, SizeOf, R, inst_3, SizeOf, J, sizeOf, ModuleCat.Colimits.Prequotient.zero] (during elaboration) for (‚àÄ {R : Type u} [inst : Ring R] {J : Type w} [inst_1 : CategoryTheory.Category.{v, w} J]
  {F : CategoryTheory.Functor J (ModuleCat R)} [inst_2 : SizeOf R] [inst_3 : SizeOf J],
  sizeOf ModuleCat.Colimits.Prequotient.zero = 1)

(‚àÄ {R : Type u_1} {R‚ÇÇ : Type u_3} {M : Type u_9} {M‚ÇÇ : Type u_12} [inst : Semiring R] [inst_1 : Semiring R‚ÇÇ]
  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M‚ÇÇ] [inst_4 : Module R M] [inst_5 : Module R‚ÇÇ M‚ÇÇ] {œÑ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ}
  {F : Type u_20} [sc : SemilinearMapClass F œÑ‚ÇÅ‚ÇÇ M M‚ÇÇ] [inst_6 : RingHomSurjective œÑ‚ÇÅ‚ÇÇ] {f : F} {x : M‚ÇÇ},
  (x ‚àà LinearMap.range f) ‚Üî (‚àÉ (y : M), ‚Üëf y = x))
unknown universe level 'u_12' ; identifiers [R, u_1, R‚ÇÇ, u_3, M, u_9, M‚ÇÇ, u_12, inst, Semiring, R, inst_1, Semiring, R‚ÇÇ, inst_2, AddCommMonoid, M, inst_3, AddCommMonoid, M‚ÇÇ, inst_4, Module, R, M, inst_5, Module, R‚ÇÇ, M‚ÇÇ, œÑ‚ÇÅ‚ÇÇ, R, R‚ÇÇ, F, u_20, sc, SemilinearMapClass, F, œÑ‚ÇÅ‚ÇÇ, M, M‚ÇÇ, inst_6, RingHomSurjective, œÑ‚ÇÅ‚ÇÇ, f, F, x, M‚ÇÇ, x, LinearMap.range, f, y, M, f, y, x] (during elaboration) for (‚àÄ {R : Type u_1} {R‚ÇÇ : Type u_3} {M : Type u_9} {M‚ÇÇ : Type u_12} [inst : Semiring R] [inst_1 : Semiring R‚ÇÇ]
  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M‚ÇÇ] [inst_4 : Module R M] [inst_5 : Module R‚ÇÇ M‚ÇÇ] {œÑ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ}
  {F : Type u_20} [sc : SemilinearMapClass F œÑ‚ÇÅ‚ÇÇ M M‚ÇÇ] [inst_6 : RingHomSurjective œÑ‚ÇÅ‚ÇÇ] {f : F} {x : M‚ÇÇ},
  (x ‚àà LinearMap.range f) ‚Üî (‚àÉ (y : M), ‚Üëf y = x))

(‚àÄ {Œ± : Type u} [inst : SizeOf Œ±], sizeOf none = 1)
typeclass instance problem is stuck, it is often due to metavariables
  SizeOf (Option ?m.6881) ; identifiers [Œ±, u, inst, SizeOf, Œ±, sizeOf, none] (during elaboration) for (‚àÄ {Œ± : Type u} [inst : SizeOf Œ±], sizeOf none = 1)

(‚àÄ {M : Type u_1} [hM : MonoidWithZero M] (h : ‚àÄ (a : M), (IsUnit a) ‚à® (a = 0)) (a : M) (b : M), a / b = a / b)
failed to synthesize instance
  HDiv M M ?m.779 ; identifiers [M, u_1, hM, MonoidWithZero, M, h, a, M, IsUnit, a, a, a, M, b, M, a, b, a, b] (during elaboration) for (‚àÄ {M : Type u_1} [hM : MonoidWithZero M] (h : ‚àÄ (a : M), (IsUnit a) ‚à® (a = 0)) (a : M) (b : M), a / b = a / b)

(‚àÄ {Œ± : Type u} [inst : SizeOf Œ±], sizeOf LazyList.nil = 1)
typeclass instance problem is stuck, it is often due to metavariables
  SizeOf (LazyList ?m.6881) ; identifiers [Œ±, u, inst, SizeOf, Œ±, sizeOf, LazyList.nil] (during elaboration) for (‚àÄ {Œ± : Type u} [inst : SizeOf Œ±], sizeOf LazyList.nil = 1)

(‚àÄ {X : TopCat} {x : ‚ÜëX} {y : ‚ÜëX} (e : Inseparable x y), nhds y ‚â§ nhds x)
type mismatch
  X
has type
  TopCat : Type (?u.3 + 1)
but is expected to have type
  Sort ?u.5 : Type ?u.5 ; identifiers [X, TopCat, x, X, y, X, e, Inseparable, x, y, nhds, y, nhds, x] (during elaboration) for (‚àÄ {X : TopCat} {x : ‚ÜëX} {y : ‚ÜëX} (e : Inseparable x y), nhds y ‚â§ nhds x)

(‚àÄ {K : Type u_1} {Œì : (a : K) ‚Üí Type u_2} {Œõ : Type u_3} {œÉ : Type u_4} [inst : SizeOf K]
  [inst_1 : (a : K) ‚Üí SizeOf (Œì a)] [inst_2 : SizeOf Œõ] [inst_3 : SizeOf œÉ] (a : (a : œÉ) ‚Üí Œõ),
  sizeOf (Turing.TM2.Stmt.goto a) = 1)
typeclass instance problem is stuck, it is often due to metavariables
  SizeOf (Turing.TM2.Stmt (?m.6994 a) Œõ œÉ) ; identifiers [K, u_1, Œì, a, K, u_2, Œõ, u_3, œÉ, u_4, inst, SizeOf, K, inst_1, a, K, SizeOf, Œì, a, inst_2, SizeOf, Œõ, inst_3, SizeOf, œÉ, a, a, œÉ, Œõ, sizeOf, Turing.TM2.Stmt.goto, a] (during elaboration) for (‚àÄ {K : Type u_1} {Œì : (a : K) ‚Üí Type u_2} {Œõ : Type u_3} {œÉ : Type u_4} [inst : SizeOf K]
  [inst_1 : (a : K) ‚Üí SizeOf (Œì a)] [inst_2 : SizeOf Œõ] [inst_3 : SizeOf œÉ] (a : (a : œÉ) ‚Üí Œõ),
  sizeOf (Turing.TM2.Stmt.goto a) = 1)

(‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : SMul Œ± Œ≤] {t : Set Œ≤} {a : Œ±} {x : Œ≤},
  (x ‚àà a ‚Ä¢ t) ‚Üî (‚àÉ (y : Œ≤), (y ‚àà t) ‚àß (a ‚Ä¢ y = x)))
failed to synthesize instance
  HSMul Œ± (Set Œ≤) ?m.29 ; identifiers [Œ±, u_2, Œ≤, u_3, inst, SMul, Œ±, Œ≤, t, Set, Œ≤, a, Œ±, x, Œ≤, x, a, t, y, Œ≤, y, t, a, y, x] (during elaboration) for (‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : SMul Œ± Œ≤] {t : Set Œ≤} {a : Œ±} {x : Œ≤},
  (x ‚àà a ‚Ä¢ t) ‚Üî (‚àÉ (y : Œ≤), (y ‚àà t) ‚àß (a ‚Ä¢ y = x)))

(‚àÄ {R : Type u} {A : Type v} [inst : CommSemiring R] [inst_1 : StarRing R] [inst_2 : NonUnitalSemiring A]
  [inst_3 : StarRing A] [inst_4 : Module R A] [inst_5 : IsScalarTower R A A] [inst_6 : SMulCommClass R A A]
  [inst_7 : StarModule R A], Monotone star)
typeclass instance problem is stuck, it is often due to metavariables
  Preorder ?m.10739 ; identifiers [R, u, A, v, inst, CommSemiring, R, inst_1, StarRing, R, inst_2, NonUnitalSemiring, A, inst_3, StarRing, A, inst_4, Module, R, A, inst_5, IsScalarTower, R, A, A, inst_6, SMulCommClass, R, A, A, inst_7, StarModule, R, A, Monotone, star] (during elaboration) for (‚àÄ {R : Type u} {A : Type v} [inst : CommSemiring R] [inst_1 : StarRing R] [inst_2 : NonUnitalSemiring A]
  [inst_3 : StarRing A] [inst_4 : Module R A] [inst_5 : IsScalarTower R A A] [inst_6 : SMulCommClass R A A]
  [inst_7 : StarModule R A], Monotone star)

