 : ‚àÄ {Œ± : Type u_1} {f : (a : Œ±) ‚Üí ENNReal} {s : Finset Œ±} (h : Finset.sum s fun (a : Œ±) ‚Ü¶ f a = 1) (h' : ‚àÄ (a : Œ±) (x : ¬¨ a ‚àà s) , f a = 0) {a : Œ±} (ha : ¬¨ a ‚àà s) , ‚Üë Pmf.ofFinset f s h h' a = 0
failed to synthesize instance
  AddCommMonoid Prop ; identifiers [Œ±, u_1, f, a, Œ±, ENNReal, s, Finset, Œ±, h, Finset.sum, s, a, Œ±, f, a, h', a, Œ±, x, a, s, f, a, a, Œ±, ha, a, s, Pmf.ofFinset, f, s, h, h', a] (during elaboration)

 : ‚àÄ {Œ± : Type u_1} {f : (a : Œ±) ‚Üí ENNReal} {s : Finset Œ±} (h : Finset.sum s fun (a : Œ±) ‚Ü¶ f a = 1) (h' : ‚àÄ (a : Œ±) (x : ¬¨ a ‚àà s) , f a = 0) {a : Œ±} (ha : ¬¨ a ‚àà s) , f a = 0
failed to synthesize instance
  AddCommMonoid Prop ; identifiers [Œ±, u_1, f, a, Œ±, ENNReal, s, Finset, Œ±, h, Finset.sum, s, a, Œ±, f, a, h', a, Œ±, x, a, s, f, a, a, Œ±, ha, a, s, f, a] (during elaboration)

 : ‚àÄ {V : Type u_2} {W : Type u_3} {V‚ÇÅ : Type u_1} [inst : SeminormedAddCommGroup V] [inst_1 : SeminormedAddCommGroup W] [inst_2 : SeminormedAddCommGroup V‚ÇÅ] {f : NormedAddGroupHom V W} {g : NormedAddGroupHom V W} (œÜ : NormedAddGroupHom V‚ÇÅ V) (h : NormedAddGroupHom.comp f œÜ = NormedAddGroupHom.comp g œÜ) (C : ‚Ñù) (hœÜ : ‚Äñ œÜ ‚Äñ ‚â§ C) , ‚Äñ NormedAddGroupHom.Equalizer.lift œÜ h ‚Äñ ‚â§ C
<input>:1:325: expected term

 : ‚àÄ {V : Type u_2} {W : Type u_3} {V‚ÇÅ : Type u_1} [inst : SeminormedAddCommGroup V] [inst_1 : SeminormedAddCommGroup W] [inst_2 : SeminormedAddCommGroup V‚ÇÅ] {f : NormedAddGroupHom V W} {g : NormedAddGroupHom V W} (œÜ : NormedAddGroupHom V‚ÇÅ V) (h : NormedAddGroupHom.comp f œÜ = NormedAddGroupHom.comp g œÜ) (C : ‚Ñù) (hœÜ : ‚Äñ œÜ ‚Äñ ‚â§ C) , ‚Äñ œÜ ‚Äñ ‚â§ C
<input>:1:325: expected term

{Œ± : Type u_1} [MulOneClass Œ±] [LT Œ±] [CovariantClass Œ± Œ± Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1 fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] [ContravariantClass Œ± Œ± Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1 fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] (a : Œ±) {b : Œ±}  : a < b * a ‚Üî 1 * a < b * a = a < b * a ‚Üî 1 * a < b * a
<input>:1:285: expected end of input

{Œ± : Type u_1} [MulOneClass Œ±] [LT Œ±] [CovariantClass Œ± Œ± Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1 fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] [ContravariantClass Œ± Œ± Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1 fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] (a : Œ±) {b : Œ±}  : a < b * a ‚Üî a < b * a
application type mismatch
  CovariantClass Œ± Œ± Function.swap
argument
  Function.swap
has type
  ((x : ?m.19) ‚Üí (y : ?m.20) ‚Üí ?m.21 x y) ‚Üí
    (y : ?m.20) ‚Üí (x : ?m.19) ‚Üí ?m.21 x y : Sort (imax (imax ?u.18 ?u.17 ?u.16) ?u.17 ?u.18 ?u.16)
but is expected to have type
  Œ± ‚Üí Œ± ‚Üí Œ± : Type u_1 ; identifiers [Œ±, u_1, MulOneClass, Œ±, LT, Œ±, CovariantClass, Œ±, Œ±, Function.swap, x, Œ±, x_1, Œ±, x, x_1, x, Œ±, x_1, Œ±, x, x_1, ContravariantClass, Œ±, Œ±, Function.swap, x, Œ±, x_1, Œ±, x, x_1, x, Œ±, x_1, Œ±, x, x_1, a, Œ±, b, Œ±, a, b, a, a, b, a] (during elaboration)

{Œ± : Type u_1} [GeneralizedCoheytingAlgebra Œ±] {a : Œ±} {b : Œ±} {c : Œ±} (h : a ‚äî c ‚â§ b ‚äî c)  : a \ c ‚â§ b \ c = a \ c ‚â§ b \ c
<input>:1:108: expected end of input

{Œ± : Type u_1} [GeneralizedCoheytingAlgebra Œ±] {a : Œ±} {b : Œ±} {c : Œ±} (h : a ‚äî c ‚â§ b ‚äî c)  : a ‚äî c \ c ‚â§ b \ c = a ‚äî c \ c ‚â§ b \ c
<input>:1:112: expected end of input

{n : ‚Ñï} {f : Vector ‚Ñï n ‚Üí. ‚Ñï} (pf : Nat.Partrec' f) {m : ‚Ñï} {n : ‚Ñï} {f : Vector ‚Ñï n ‚Üí. ‚Ñï} (g : (a : Fin n) ‚Üí Vector ‚Ñï m ‚Üí. ‚Ñï) (a : Nat.Partrec' f) (a : ‚àÄ (i : Fin n) , Nat.Partrec' g i) (a_ih : Partrec f) (a_ih_1 : ‚àÄ (i : Fin n) , Partrec g i)  : ‚àÄ (i : Fin n) , Partrec g i
application type mismatch
  Nat.Partrec' g
argument
  g
has type
  Fin n ‚Üí Vector ‚Ñï m ‚Üí. ‚Ñï : Type
but is expected to have type
  Vector ‚Ñï ?m.51 ‚Üí. ‚Ñï : Type ; identifiers [n, f, Vector, n, pf, Nat.Partrec', f, m, n, f, Vector, n, g, a, Fin, n, Vector, m, a, Nat.Partrec', f, a, i, Fin, n, Nat.Partrec', g, i, a_ih, Partrec, f, a_ih_1, i, Fin, n, Partrec, g, i, i, Fin, n, Partrec, g, i] (during elaboration)

{Œ± : Type u_1} {l : Filter Œ±} {R : Type u_2} [Distrib R] (f : Filter.Germ l R) (g : Filter.Germ l R) (h : Filter.Germ l R) (f : (a : Œ±) ‚Üí R) (g : (a : Œ±) ‚Üí R) (h : (a : Œ±) ‚Üí R)  : f * g + h =·∂†[l] f * g + f * h = f * g + h =·∂†[l] f * g + f * h
application type mismatch
  f * g + h =·∂†[l] ?m.81592 =·∂†[l] f * g + f * h
argument
  ?m.81592 =·∂†[l] f * g + f * h
has type
  Prop : Type
but is expected to have type
  Œ± ‚Üí R : Type (max u_2 u_1) ; identifiers [Œ±, u_1, l, Filter, Œ±, R, u_2, Distrib, R, f, Filter.Germ, l, R, g, Filter.Germ, l, R, h, Filter.Germ, l, R, f, a, Œ±, R, g, a, Œ±, R, h, a, Œ±, R, f, g, h, l, f, g, f, h, f, g, h, l, f, g, f, h] (during elaboration)

{Œ± : Type u_2} {Œ≤ : Type u_1} [AddMonoid Œ±] [AddAction Œ± Œ≤] {a : Œ≤} (motive : (x : ‚Üë AddAction.orbit Œ± a) ‚Üí Prop) (x : ‚Üë AddAction.orbit Œ± a) (h_1 : ‚àÄ (b : Œ≤) (x : Œ±) (hx : fun (x : Œ±) ‚Ü¶ x +·µ• a x = b) , motive {val := ((b)) , property := (((Exists.intro x hx =: ‚àÉ (y : Œ±) , fun (x : Œ±) ‚Ü¶ x +·µ• a y = b)))}) (val : Œ≤) (property : val ‚àà AddAction.orbit Œ± a)  : ‚àÄ (w : Œ±) (h : fun (x : Œ±) ‚Ü¶ x +·µ• a w = val) , motive {val := ((val)) , property := ((Exists.intro w h))}
<input>:1:260: expected term

{M‚ÇÄ : Type u_1} [inst : MonoidWithZero M‚ÇÄ] {a : M‚ÇÄ} (h : IsUnit Ring.inverse a) (h_1 : Subsingleton M‚ÇÄ) (h_2 : (subsingleton_or_nontrivial M‚ÇÄ =: (Subsingleton M‚ÇÄ : Prop) ‚à® (Nontrivial M‚ÇÄ : Prop)) = (Or.inl h_1 =: (Subsingleton M‚ÇÄ : Prop) ‚à® (Nontrivial M‚ÇÄ : Prop)))  : Or.inl h_1 = subsingleton_or_nontrivial M‚ÇÄ
<input>:1:143: expected term

 : ‚àÄ {G : Type u_1} [inst : AddGroup G] (self : AddSubgroup G) {x : G} (a : x ‚àà AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup AddSubgroup.toAddSubmonoid self) , - x ‚àà AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup AddSubgroup.toAddSubmonoid self
function expected at
  AddSubsemigroup.carrier ?m.79766 AddSubgroup.toAddSubmonoid
term has type
  Prop ; identifiers [G, u_1, inst, AddGroup, G, self, AddSubgroup, G, x, G, a, x, AddSubsemigroup.carrier, AddSubmonoid.toAddSubsemigroup, AddSubgroup.toAddSubmonoid, self, x, AddSubsemigroup.carrier, AddSubmonoid.toAddSubsemigroup, AddSubgroup.toAddSubmonoid, self] (during elaboration)

 : ‚àÄ (G : Type u_1) [inst : AddGroup G] (self : AddSubgroup G) {x : G} (a : x ‚àà AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup self . 1) , - x ‚àà AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup self . 1
function expected at
  AddSubsemigroup.carrier ?m.79766 self
term has type
  Prop ; identifiers [G, u_1, inst, AddGroup, G, self, AddSubgroup, G, x, G, a, x, AddSubsemigroup.carrier, AddSubmonoid.toAddSubsemigroup, self, x, AddSubsemigroup.carrier, AddSubmonoid.toAddSubsemigroup, self] (during elaboration)

{K : Type v} {V : Type w} [Field K] [AddCommGroup V] [Module K V] (f : Module.End K V) (Œºs : Set K) (xs : (a : ‚Üë Œºs) ‚Üí V) (h_eigenvec : ‚àÄ (Œº : ‚Üë Œºs) , Module.End.HasEigenvector f ‚Üë Œº xs Œº) (Œº : {x : K // x ‚àà Œºs})  : Module.End.HasEigenvector f ‚Üë Œº xs Œº
type mismatch
  Œºs
has type
  Set K : Type v
but is expected to have type
  Sort ?u.1398 : Type ?u.1398 ; identifiers [K, v, V, w, Field, K, AddCommGroup, V, Module, K, V, f, Module.End, K, V, Œºs, Set, K, xs, a, Œºs, V, h_eigenvec, Œº, Œºs, Module.End.HasEigenvector, f, Œº, xs, Œº, Œº, x, K, x, Œºs, Module.End.HasEigenvector, f, Œº, xs, Œº] (during elaboration)

{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [Primcodable Œ±] [Primcodable Œ≤] [Primcodable Œ≥] {p : (a : Œ±) ‚Üí Prop} {q : (a : Œ≤) ‚Üí Prop} {r : (a : Œ≥) ‚Üí Prop} (x : p ‚â§‚ÇÄ r) (x_1 : q ‚â§‚ÇÄ r) (f : (a : Œ±) ‚Üí Œ≥) (c‚ÇÅ : Computable f) (h‚ÇÅ : ‚àÄ (a : Œ±) , (p a : Prop) ‚Üî (r f a : Prop)) (g : (a : Œ≤) ‚Üí Œ≥) (c‚ÇÇ : Computable g) (h‚ÇÇ : ‚àÄ (a : Œ≤) , (q a : Prop) ‚Üî (r g a : Prop)) (x : Œ± ‚äï Œ≤) (val : Œ±) (h : x = Sum.inl val)  : Sum.inl val = x
application type mismatch
  r f
argument
  f
has type
  Œ± ‚Üí Œ≥ : Type (max u_1 u_3)
but is expected to have type
  Œ≥ : Type u_3 ; identifiers [Œ±, u_1, Œ≤, u_2, Œ≥, u_3, Primcodable, Œ±, Primcodable, Œ≤, Primcodable, Œ≥, p, a, Œ±, q, a, Œ≤, r, a, Œ≥, x, p, r, x_1, q, r, f, a, Œ±, Œ≥, c‚ÇÅ, Computable, f, h‚ÇÅ, a, Œ±, p, a, r, f, a, g, a, Œ≤, Œ≥, c‚ÇÇ, Computable, g, h‚ÇÇ, a, Œ≤, q, a, r, g, a, x, Œ±, Œ≤, val, Œ±, h, x, Sum.inl, val, Sum.inl, val, x] (during elaboration)

{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [Primcodable Œ±] [Primcodable Œ≤] [Primcodable Œ≥] {p : (a : Œ±) ‚Üí Prop} {q : (a : Œ≤) ‚Üí Prop} {r : (a : Œ≥) ‚Üí Prop} (x : p ‚â§‚ÇÄ r) (x_1 : q ‚â§‚ÇÄ r) (f : (a : Œ±) ‚Üí Œ≥) (c‚ÇÅ : Computable f) (h‚ÇÅ : ‚àÄ (a : Œ±) , (p a : Prop) ‚Üî (r f a : Prop)) (g : (a : Œ≤) ‚Üí Œ≥) (c‚ÇÇ : Computable g) (h‚ÇÇ : ‚àÄ (a : Œ≤) , (q a : Prop) ‚Üî (r g a : Prop)) (x : Œ± ‚äï Œ≤) (val : Œ±) (h : x = Sum.inl val)  : p val ‚Üî r f val
application type mismatch
  r f
argument
  f
has type
  Œ± ‚Üí Œ≥ : Type (max u_1 u_3)
but is expected to have type
  Œ≥ : Type u_3 ; identifiers [Œ±, u_1, Œ≤, u_2, Œ≥, u_3, Primcodable, Œ±, Primcodable, Œ≤, Primcodable, Œ≥, p, a, Œ±, q, a, Œ≤, r, a, Œ≥, x, p, r, x_1, q, r, f, a, Œ±, Œ≥, c‚ÇÅ, Computable, f, h‚ÇÅ, a, Œ±, p, a, r, f, a, g, a, Œ≤, Œ≥, c‚ÇÇ, Computable, g, h‚ÇÇ, a, Œ≤, q, a, r, g, a, x, Œ±, Œ≤, val, Œ±, h, x, Sum.inl, val, p, val, r, f, val] (during elaboration)

{R : Type u‚ÇÅ} [StrictOrderedSemiring R] {a : R} (h : 0 ‚â§ a) (ha : a ‚â§ 1) {i : ‚Ñï} {j : ‚Ñï} (hij : i ‚â§ j) (k : ‚Ñï) (hk : j = i + k)  : a ^ j ‚â§ a ^ i = a ^ j ‚â§ a ^ i
<input>:1:145: expected end of input

{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [Primcodable Œ±] [Primcodable Œ≤] [Primcodable Œ≥] {p : (a : Œ±) ‚Üí Prop} {q : (a : Œ≤) ‚Üí Prop} {r : (a : Œ≥) ‚Üí Prop} (x : p ‚â§‚ÇÄ r) (x_1 : q ‚â§‚ÇÄ r) (f : (a : Œ±) ‚Üí Œ≥) (c‚ÇÅ : Computable f) (h‚ÇÅ : ‚àÄ (a : Œ±) , (p a : Prop) ‚Üî (r f a : Prop)) (g : (a : Œ≤) ‚Üí Œ≥) (c‚ÇÇ : Computable g) (h‚ÇÇ : ‚àÄ (a : Œ≤) , (q a : Prop) ‚Üî (r g a : Prop)) (x : Œ± ‚äï Œ≤) (val : Œ≤) (h : x = Sum.inr val)  : Sum.inr val = x
application type mismatch
  r f
argument
  f
has type
  Œ± ‚Üí Œ≥ : Type (max u_1 u_3)
but is expected to have type
  Œ≥ : Type u_3 ; identifiers [Œ±, u_1, Œ≤, u_2, Œ≥, u_3, Primcodable, Œ±, Primcodable, Œ≤, Primcodable, Œ≥, p, a, Œ±, q, a, Œ≤, r, a, Œ≥, x, p, r, x_1, q, r, f, a, Œ±, Œ≥, c‚ÇÅ, Computable, f, h‚ÇÅ, a, Œ±, p, a, r, f, a, g, a, Œ≤, Œ≥, c‚ÇÇ, Computable, g, h‚ÇÇ, a, Œ≤, q, a, r, g, a, x, Œ±, Œ≤, val, Œ≤, h, x, Sum.inr, val, Sum.inr, val, x] (during elaboration)

{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [Primcodable Œ±] [Primcodable Œ≤] [Primcodable Œ≥] {p : (a : Œ±) ‚Üí Prop} {q : (a : Œ≤) ‚Üí Prop} {r : (a : Œ≥) ‚Üí Prop} (x : p ‚â§‚ÇÄ r) (x_1 : q ‚â§‚ÇÄ r) (f : (a : Œ±) ‚Üí Œ≥) (c‚ÇÅ : Computable f) (h‚ÇÅ : ‚àÄ (a : Œ±) , (p a : Prop) ‚Üî (r f a : Prop)) (g : (a : Œ≤) ‚Üí Œ≥) (c‚ÇÇ : Computable g) (h‚ÇÇ : ‚àÄ (a : Œ≤) , (q a : Prop) ‚Üî (r g a : Prop)) (x : Œ± ‚äï Œ≤) (val : Œ≤) (h : x = Sum.inr val)  : q val ‚Üî r g val
application type mismatch
  r f
argument
  f
has type
  Œ± ‚Üí Œ≥ : Type (max u_1 u_3)
but is expected to have type
  Œ≥ : Type u_3 ; identifiers [Œ±, u_1, Œ≤, u_2, Œ≥, u_3, Primcodable, Œ±, Primcodable, Œ≤, Primcodable, Œ≥, p, a, Œ±, q, a, Œ≤, r, a, Œ≥, x, p, r, x_1, q, r, f, a, Œ±, Œ≥, c‚ÇÅ, Computable, f, h‚ÇÅ, a, Œ±, p, a, r, f, a, g, a, Œ≤, Œ≥, c‚ÇÇ, Computable, g, h‚ÇÇ, a, Œ≤, q, a, r, g, a, x, Œ±, Œ≤, val, Œ≤, h, x, Sum.inr, val, q, val, r, g, val] (during elaboration)

{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [Primcodable Œ±] [Primcodable Œ≤] [Primcodable Œ≥] {p : (a : Œ±) ‚Üí Prop} {q : (a : Œ≤) ‚Üí Prop} {r : (a : Œ≥) ‚Üí Prop} (x : p ‚â§‚ÇÄ r) (x_1 : q ‚â§‚ÇÄ r) (f : (a : Œ±) ‚Üí Œ≥) (c‚ÇÅ : Computable f) (h‚ÇÅ : ‚àÄ (a : Œ±) , (p a : Prop) ‚Üî (r f a : Prop)) (g : (a : Œ≤) ‚Üí Œ≥) (c‚ÇÇ : Computable g) (h‚ÇÇ : ‚àÄ (a : Œ≤) , (q a : Prop) ‚Üî (r g a : Prop)) (x : Œ± ‚äï Œ≤)  : x = x
application type mismatch
  r f
argument
  f
has type
  Œ± ‚Üí Œ≥ : Type (max u_1 u_3)
but is expected to have type
  Œ≥ : Type u_3 ; identifiers [Œ±, u_1, Œ≤, u_2, Œ≥, u_3, Primcodable, Œ±, Primcodable, Œ≤, Primcodable, Œ≥, p, a, Œ±, q, a, Œ≤, r, a, Œ≥, x, p, r, x_1, q, r, f, a, Œ±, Œ≥, c‚ÇÅ, Computable, f, h‚ÇÅ, a, Œ±, p, a, r, f, a, g, a, Œ≤, Œ≥, c‚ÇÇ, Computable, g, h‚ÇÇ, a, Œ≤, q, a, r, g, a, x, Œ±, Œ≤, x, x] (during elaboration)

 : ‚àÄ {Œ± : Type u} [inst : SizeOf Œ±] , sizeOf LazyList.nil = 1
typeclass instance problem is stuck, it is often due to metavariables
  SizeOf (LazyList ?m.6756) ; identifiers [Œ±, u, inst, SizeOf, Œ±, sizeOf, LazyList.nil] (during elaboration)

{M‚ÇÄ : Type u_1} [inst : MonoidWithZero M‚ÇÄ] {a : M‚ÇÄ} (h : IsUnit Ring.inverse a) (h_1 : Subsingleton M‚ÇÄ) (h_2 : (subsingleton_or_nontrivial M‚ÇÄ =: (Subsingleton M‚ÇÄ : Prop) ‚à® (Nontrivial M‚ÇÄ : Prop)) = (Or.inl h_1 =: (Subsingleton M‚ÇÄ : Prop) ‚à® (Nontrivial M‚ÇÄ : Prop))) (M : Type u_1) (inst : Monoid M) (a : M) (a' : M) (e'_3 : a = a') (h : a' = a) (a' : M)  : a = a
<input>:1:143: expected term

 : ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : MeasurableSpace Œ±] [inst_1 : MeasurableSpace Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (self : MeasurableEmbedding f) ‚¶É s : Set Œ± ‚¶Ñ (a : MeasurableSet s) , MeasurableSet f '' s
application type mismatch
  Set.image (MeasurableSet ?m.353)
argument
  MeasurableSet ?m.353
has type
  Prop : Type
but is expected to have type
  Œ± ‚Üí ?m.79608 self a : Type (max ?u.146 u_1) ; identifiers [Œ±, u_1, Œ≤, u_2, inst, MeasurableSpace, Œ±, inst_1, MeasurableSpace, Œ≤, f, a, Œ±, Œ≤, self, MeasurableEmbedding, f, s, Set, Œ±, a, MeasurableSet, s, MeasurableSet, f, s] (during elaboration)

 : ‚àÄ (Œ± : Type u_1) (Œ≤ : Type u_2) [inst : MeasurableSpace Œ±] [inst_1 : MeasurableSpace Œ≤] (f : (a : Œ±) ‚Üí Œ≤) (self : MeasurableEmbedding f) ‚¶É s : Set Œ± ‚¶Ñ (a : MeasurableSet s) , MeasurableSet f '' s
application type mismatch
  Set.image (MeasurableSet ?m.353)
argument
  MeasurableSet ?m.353
has type
  Prop : Type
but is expected to have type
  Œ± ‚Üí ?m.79608 Œ± Œ≤ f self a : Type (max ?u.146 u_1) ; identifiers [Œ±, u_1, Œ≤, u_2, inst, MeasurableSpace, Œ±, inst_1, MeasurableSpace, Œ≤, f, a, Œ±, Œ≤, self, MeasurableEmbedding, f, s, Set, Œ±, a, MeasurableSet, s, MeasurableSet, f, s] (during elaboration)

{G : Type u_1} [Group G] (H : Subgroup G) (a : G) (b : G)  : Setoid.Rel Doset.setoid ‚Üë Subgroup.toSubmonoid H ‚Üë ‚ä• a b ‚Üî Setoid.Rel Doset.setoid ‚Üë Subgroup.toSubmonoid H ‚Üë ‚ä• a b
function expected at
  Setoid.Rel ?m.80159 ?m.80160 H
term has type
  Prop ; identifiers [G, u_1, Group, G, H, Subgroup, G, a, G, b, G, Setoid.Rel, Doset.setoid, Subgroup.toSubmonoid, H, a, b, Setoid.Rel, Doset.setoid, Subgroup.toSubmonoid, H, a, b] (during elaboration)

{M‚ÇÄ : Type u_1} [inst : MonoidWithZero M‚ÇÄ] {a : M‚ÇÄ} (h : IsUnit Ring.inverse a) (h_1 : Subsingleton M‚ÇÄ) (h_2 : (subsingleton_or_nontrivial M‚ÇÄ =: (Subsingleton M‚ÇÄ : Prop) ‚à® (Nontrivial M‚ÇÄ : Prop)) = (Or.inl h_1 =: (Subsingleton M‚ÇÄ : Prop) ‚à® (Nontrivial M‚ÇÄ : Prop))) (M : Type u_1) (inst : Monoid M) (a : M) (a' : M) (e'_3 : a = a') (h : a' = a)  : a = a'
<input>:1:143: expected term

{M‚ÇÄ : Type u_1} [inst : MonoidWithZero M‚ÇÄ] {a : M‚ÇÄ} (h : IsUnit Ring.inverse a) (h_1 : Subsingleton M‚ÇÄ) (h_2 : (subsingleton_or_nontrivial M‚ÇÄ =: (Subsingleton M‚ÇÄ : Prop) ‚à® (Nontrivial M‚ÇÄ : Prop)) = (Or.inl h_1 =: (Subsingleton M‚ÇÄ : Prop) ‚à® (Nontrivial M‚ÇÄ : Prop))) (M : Type u_1) (inst : Monoid M) (a : M) (a' : M) (e'_3 : a = a')  : a' = a'
<input>:1:143: expected term

{M‚ÇÄ : Type u_1} [inst : MonoidWithZero M‚ÇÄ] {a : M‚ÇÄ} (h : IsUnit Ring.inverse a) (h_1 : Nontrivial M‚ÇÄ) (h_2 : (subsingleton_or_nontrivial M‚ÇÄ =: (Subsingleton M‚ÇÄ : Prop) ‚à® (Nontrivial M‚ÇÄ : Prop)) = (Or.inr h_1 =: (Subsingleton M‚ÇÄ : Prop) ‚à® (Nontrivial M‚ÇÄ : Prop)))  : Or.inr h_1 = subsingleton_or_nontrivial M‚ÇÄ
<input>:1:141: expected term

 : ‚àÄ {E : Type u_1} {F : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] [inst_2 : NormedAddCommGroup F] [inst_3 : NormedSpace ‚Ñù F] (self : SchwartzMap E F) , ContDiff ‚Ñù ‚ä§ SchwartzMap.toFun self
function expected at
  ContDiff ‚Ñù ‚ä§ SchwartzMap.toFun
term has type
  Prop ; identifiers [E, u_1, F, u_2, inst, NormedAddCommGroup, E, inst_1, NormedSpace, E, inst_2, NormedAddCommGroup, F, inst_3, NormedSpace, F, self, SchwartzMap, E, F, ContDiff, SchwartzMap.toFun, self] (during elaboration)

 : ‚àÄ (E : Type u_1) (F : Type u_2) [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] [inst_2 : NormedAddCommGroup F] [inst_3 : NormedSpace ‚Ñù F] (self : SchwartzMap E F) , ContDiff ‚Ñù ‚ä§ self . 1
function expected at
  ContDiff ‚Ñù ‚ä§ ‚Üëself
term has type
  Prop ; identifiers [E, u_1, F, u_2, inst, NormedAddCommGroup, E, inst_1, NormedSpace, E, inst_2, NormedAddCommGroup, F, inst_3, NormedSpace, F, self, SchwartzMap, E, F, ContDiff, self] (during elaboration)

{ùïú : Type u_1} {E : Type u_2} [OrderedSemiring ùïú] [AddCommMonoid E] [Module ùïú E] (x : ConvexCone ùïú E) (x_1 : E) (x_2 : E)  : ‚àÉ (x_3 : E) , x_2 = 0 ‚àß x_3 ‚àà x ‚àß x_2 + x_3 = x_1 = x_2 = 0 ‚àß ‚àÉ (x_3 : E) , x_3 ‚àà x ‚àß x_2 + x_3 = x_1
<input>:1:181: expected end of input

{ùïú : Type u_1} {E : Type u_2} [OrderedSemiring ùïú] [AddCommMonoid E] [Module ùïú E] (x : ConvexCone ùïú E) (x_1 : E)  : ‚àÉ (a : E) , a ‚àà x ‚àß a = x_1 = x_1 ‚àà x
<input>:1:149: expected end of input

{J : Type v} [CategoryTheory.SmallCategory J] (F : CategoryTheory.Functor J TypeMax) [CategoryTheory.IsFilteredOrEmpty J] {i : J} {j : J} {xi : CategoryTheory.Functor.toPrefunctor F . obj i} {xj : CategoryTheory.Functor.toPrefunctor F . obj j}  : EqvGen CategoryTheory.Limits.Types.Quot.Rel F {fst := ((i)) , snd := ((xi))} {fst := ((j)) , snd := ((xj))} ‚Üî EqvGen CategoryTheory.Limits.Types.Quot.Rel F {fst := ((i)) , snd := ((xi))} {fst := ((j)) , snd := ((xj))}
function expected at
  F.toPrefunctor
term has type
  J ‚•§q TypeMax ; identifiers [J, v, CategoryTheory.SmallCategory, J, F, CategoryTheory.Functor, J, TypeMax, CategoryTheory.IsFilteredOrEmpty, J, i, J, j, J, xi, CategoryTheory.Functor.toPrefunctor, F, obj, i, xj, CategoryTheory.Functor.toPrefunctor, F, obj, j, EqvGen, CategoryTheory.Limits.Types.Quot.Rel, F, fst, i, snd, xi, fst, j, snd, xj, EqvGen, CategoryTheory.Limits.Types.Quot.Rel, F, fst, i, snd, xi, fst, j, snd, xj] (during elaboration)

{R : Type u} [CommRing R] [IsBezout R] {x : R} {y : R} {z : R} (hx : z ‚à£ x) (hy : z ‚à£ y)  : z ‚à£ x = z ‚à£ x
<input>:1:98: expected end of input

{R : Type u} [CommRing R] [IsBezout R] {x : R} {y : R} {z : R} (hx : z ‚à£ x) (hy : z ‚à£ y)  : z ‚à£ y = z ‚à£ y
<input>:1:98: expected end of input

(ùïú : Type u_3) (E : Type u_2) [OrderedSemiring ùïú] [AddCommGroup E] [Module ùïú E] [TopologicalSpace E] [TopologicalAddGroup E] {Œπ : Type u_1} (b : (a : Œπ) ‚Üí Set E) (p : (a : Œπ) ‚Üí Prop) (hbasis : Filter.HasBasis nhds 0 p b) (hconvex : ‚àÄ (i : Œπ) (a : p i) , Convex ùïú b i) (x : E) (i : Œπ) (hi : fun (x : E) ‚Ü¶ p x i)  : Convex ùïú b i
invalid universe level, ?u.80758 is not greater than 0 ; identifiers [ùïú, u_3, E, u_2, OrderedSemiring, ùïú, AddCommGroup, E, Module, ùïú, E, TopologicalSpace, E, TopologicalAddGroup, E, Œπ, u_1, b, a, Œπ, Set, E, p, a, Œπ, hbasis, Filter.HasBasis, nhds, p, b, hconvex, i, Œπ, a, p, i, Convex, ùïú, b, i, x, E, i, Œπ, hi, x, E, p, x, i, Convex, ùïú, b, i] (during elaboration)

{Œ± : Type u_1} {Œ≤ : Type u_2} {s : Set Œ±} {t : Set Œ±} {f : (a : Œ±) ‚Üí Œ≤} (hf : Function.Injective f) (h : f '' s ‚äÜ f '' t)  : s ‚äÜ t = s ‚äÜ t
<input>:1:131: expected end of input

{Œ± : Type u_1} {Œ≤ : Type u_2} {s : Set Œ±} {t : Set Œ±} {f : (a : Œ±) ‚Üí Œ≤} (hf : Function.Injective f) (h : f '' s ‚äÜ f '' t)  : f ‚Åª¬π' f '' s ‚äÜ t = f ‚Åª¬π' f '' s ‚äÜ t
<input>:1:142: expected end of input

(q : ‚Ñö)  : q ‚â§ ‚Üë q = q ‚â§ ‚Üë q
<input>:1:19: expected end of input

