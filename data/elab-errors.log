{L : FirstOrder.Language} {M : Type w'} [FirstOrder.Language.IsOrdered L] [FirstOrder.Language.Structure L M] [LE M] [FirstOrder.Language.OrderedStructure L M] {a : M} {b : M}  : (FirstOrder.Language.Structure.RelMap FirstOrder.Language.leSymb ![a, b]) ‚Üî
  (FirstOrder.Language.Structure.RelMap FirstOrder.Language.leSymb ![a, b])
typeclass instance problem is stuck, it is often due to metavariables
  FirstOrder.Language.Structure ?m.268 M ; identifiers [L, FirstOrder.Language, M, w', FirstOrder.Language.IsOrdered, L, FirstOrder.Language.Structure, L, M, LE, M, FirstOrder.Language.OrderedStructure, L, M, a, M, b, M, FirstOrder.Language.Structure.RelMap, FirstOrder.Language.leSymb, a, b, FirstOrder.Language.Structure.RelMap, FirstOrder.Language.leSymb, a, b] (during elaboration) for {L : FirstOrder.Language}  -> {M : Type w'}  -> [FirstOrder.Language.IsOrdered L]  -> [FirstOrder.Language.Structure L M]  -> [LE M]  -> [FirstOrder.Language.OrderedStructure L M]  -> {a : M}  -> {b : M}   -> (FirstOrder.Language.Structure.RelMap FirstOrder.Language.leSymb ![a, b]) ‚Üî
  (FirstOrder.Language.Structure.RelMap FirstOrder.Language.leSymb ![a, b])

{Œ± : Type u_1} {a : Œ±} {b : Œ±}  : ((¬¨(a ‚àà {b})) ‚Üî (a ‚â† b)) = ((¬¨(a ‚àà {b})) ‚Üî (a ‚â† b))
typeclass instance problem is stuck, it is often due to metavariables
  Singleton Œ± ?m.931 ; identifiers [Œ±, u_1, a, Œ±, b, Œ±, a, b, b, a, b, a, b, b, a, b] (during elaboration) for {Œ± : Type u_1}  -> {a : Œ±}  -> {b : Œ±}   -> ((¬¨(a ‚àà {b})) ‚Üî (a ‚â† b)) = ((¬¨(a ‚àà {b})) ‚Üî (a ‚â† b))

 : (‚àÄ {Œπ : Type uŒπ} {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] [inst_2 : FiniteDimensional ‚Ñù E]
  {H : Type uH} [inst_3 : TopologicalSpace H] {I : ModelWithCorners ‚Ñù E H} {M : Type uM} [inst_4 : TopologicalSpace M]
  [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] {s : Set M} [inst_7 : T2Space M]
  {f : SmoothBumpCovering Œπ I M s} {U : (a : M) ‚Üí Set M},
  (BumpCovering.IsSubordinate (SmoothBumpCovering.toBumpCovering f) fun (i : Œπ) ‚Ü¶ U (SmoothBumpCovering.c s f i)) ‚Üî
    (SmoothBumpCovering.IsSubordinate f U))
unknown universe level 'uH' ; identifiers [Œπ, uŒπ, E, uE, inst, NormedAddCommGroup, E, inst_1, NormedSpace, E, inst_2, FiniteDimensional, E, H, uH, inst_3, TopologicalSpace, H, I, ModelWithCorners, E, H, M, uM, inst_4, TopologicalSpace, M, inst_5, ChartedSpace, H, M, inst_6, SmoothManifoldWithCorners, I, M, s, Set, M, inst_7, T2Space, M, f, SmoothBumpCovering, Œπ, I, M, s, U, a, M, Set, M, BumpCovering.IsSubordinate, SmoothBumpCovering.toBumpCovering, f, i, Œπ, U, SmoothBumpCovering.c, s, f, i, SmoothBumpCovering.IsSubordinate, f, U] (during elaboration) for (‚àÄ {Œπ : Type uŒπ} {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] [inst_2 : FiniteDimensional ‚Ñù E]
  {H : Type uH} [inst_3 : TopologicalSpace H] {I : ModelWithCorners ‚Ñù E H} {M : Type uM} [inst_4 : TopologicalSpace M]
  [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] {s : Set M} [inst_7 : T2Space M]
  {f : SmoothBumpCovering Œπ I M s} {U : (a : M) ‚Üí Set M},
  (BumpCovering.IsSubordinate (SmoothBumpCovering.toBumpCovering f) fun (i : Œπ) ‚Ü¶ U (SmoothBumpCovering.c s f i)) ‚Üî
    (SmoothBumpCovering.IsSubordinate f U))

 : ‚àÄ {Œπ : Type uŒπ} {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] [inst_2 : FiniteDimensional ‚Ñù E]
  {H : Type uH} [inst_3 : TopologicalSpace H] {I : ModelWithCorners ‚Ñù E H} {M : Type uM} [inst_4 : TopologicalSpace M]
  [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] {s : Set M} [inst_7 : T2Space M]
  {f : SmoothBumpCovering Œπ I M s} {U : (a : M) ‚Üí Set M},
  (BumpCovering.IsSubordinate (SmoothBumpCovering.toBumpCovering f) fun (i : Œπ) ‚Ü¶ U (SmoothBumpCovering.c s f i)) ‚Üî
    (BumpCovering.IsSubordinate (SmoothBumpCovering.toBumpCovering f) fun (i : Œπ) ‚Ü¶ U (SmoothBumpCovering.c s f i))
unknown universe level 'uH' ; identifiers [Œπ, uŒπ, E, uE, inst, NormedAddCommGroup, E, inst_1, NormedSpace, E, inst_2, FiniteDimensional, E, H, uH, inst_3, TopologicalSpace, H, I, ModelWithCorners, E, H, M, uM, inst_4, TopologicalSpace, M, inst_5, ChartedSpace, H, M, inst_6, SmoothManifoldWithCorners, I, M, s, Set, M, inst_7, T2Space, M, f, SmoothBumpCovering, Œπ, I, M, s, U, a, M, Set, M, BumpCovering.IsSubordinate, SmoothBumpCovering.toBumpCovering, f, i, Œπ, U, SmoothBumpCovering.c, s, f, i, BumpCovering.IsSubordinate, SmoothBumpCovering.toBumpCovering, f, i, Œπ, U, SmoothBumpCovering.c, s, f, i] (during elaboration) for ‚àÄ {Œπ : Type uŒπ} {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] [inst_2 : FiniteDimensional ‚Ñù E]
  {H : Type uH} [inst_3 : TopologicalSpace H] {I : ModelWithCorners ‚Ñù E H} {M : Type uM} [inst_4 : TopologicalSpace M]
  [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] {s : Set M} [inst_7 : T2Space M]
  {f : SmoothBumpCovering Œπ I M s} {U : (a : M) ‚Üí Set M},
  (BumpCovering.IsSubordinate (SmoothBumpCovering.toBumpCovering f) fun (i : Œπ) ‚Ü¶ U (SmoothBumpCovering.c s f i)) ‚Üî
    (BumpCovering.IsSubordinate (SmoothBumpCovering.toBumpCovering f) fun (i : Œπ) ‚Ü¶ U (SmoothBumpCovering.c s f i))

{ùïú : Type u_2} {E : Type u_1} [IsROrC ùïú] [NormedAddCommGroup E] [InnerProductSpace ùïú E] (x : E)  : ((x ‚àà ‚ä§·óÆ) ‚Üî (x ‚àà ‚ä•)) = ((x ‚àà ‚ä§·óÆ) ‚Üî (x ‚àà ‚ä•))
typeclass instance problem is stuck, it is often due to metavariables
  Membership E (?m.3858 x) ; identifiers [ùïú, u_2, E, u_1, IsROrC, ùïú, NormedAddCommGroup, E, InnerProductSpace, ùïú, E, x, E, x, x, x, x] (during elaboration) for {ùïú : Type u_2}  -> {E : Type u_1}  -> [IsROrC ùïú]  -> [NormedAddCommGroup E]  -> [InnerProductSpace ùïú E]  -> (x : E)   -> ((x ‚àà ‚ä§·óÆ) ‚Üî (x ‚àà ‚ä•)) = ((x ‚àà ‚ä§·óÆ) ‚Üî (x ‚àà ‚ä•))

{ùïú : Type u_2} {E : Type u_1} [IsROrC ùïú] [NormedAddCommGroup E] [InnerProductSpace ùïú E] (x : E)  : ((x ‚àà ‚ä§·óÆ) ‚Üî (x = 0)) = ((x ‚àà ‚ä§·óÆ) ‚Üî (x = 0))
typeclass instance problem is stuck, it is often due to metavariables
  InnerProductSpace (?m.2643 x) E ; identifiers [ùïú, u_2, E, u_1, IsROrC, ùïú, NormedAddCommGroup, E, InnerProductSpace, ùïú, E, x, E, x, x, x, x] (during elaboration) for {ùïú : Type u_2}  -> {E : Type u_1}  -> [IsROrC ùïú]  -> [NormedAddCommGroup E]  -> [InnerProductSpace ùïú E]  -> (x : E)   -> ((x ‚àà ‚ä§·óÆ) ‚Üî (x = 0)) = ((x ‚àà ‚ä§·óÆ) ‚Üî (x = 0))

{ùïú : Type u_1} {E : Type u_2} [SeminormedRing ùïú] [SMul ùïú E] {s : Set E} {t : Set E} (ht : Balanced ùïú t) (h : s ‚äÜ t) ‚¶Éx : E‚¶Ñ (hx : x ‚àà balancedHull ùïú s) (r : ùïú) (h_1 : ‚àÉ (x_1 : ‚Äñr‚Äñ ‚â§ 1), x ‚àà r ‚Ä¢ s) (hr : ‚Äñr‚Äñ ‚â§ 1) (h_2 : x ‚àà r ‚Ä¢ s) (y : E) (h_3 : (y ‚àà s) ‚àß ((fun (x : E) ‚Ü¶ r ‚Ä¢ x) y = x)) (hy : y ‚àà s) (right : (fun (x : E) ‚Ü¶ r ‚Ä¢ x) y = x) (hx : (fun (x : E) ‚Ü¶ r ‚Ä¢ x) y ‚àà balancedHull ùïú s)  : y ‚àà t
failed to synthesize instance
  HSMul ùïú (Set E) ?m.614 ; identifiers [ùïú, u_1, E, u_2, SeminormedRing, ùïú, SMul, ùïú, E, s, Set, E, t, Set, E, ht, Balanced, ùïú, t, h, s, t, x, E, hx, x, balancedHull, ùïú, s, r, ùïú, h_1, x_1, r, x, r, s, hr, r, h_2, x, r, s, y, E, h_3, y, s, x, E, r, x, y, x, hy, y, s, right, x, E, r, x, y, x, hx, x, E, r, x, y, balancedHull, ùïú, s, y, t] (during elaboration) for {ùïú : Type u_1}  -> {E : Type u_2}  -> [SeminormedRing ùïú]  -> [SMul ùïú E]  -> {s : Set E}  -> {t : Set E}  -> (ht : Balanced ùïú t)  -> (h : s ‚äÜ t)  -> ‚¶Éx : E‚¶Ñ  -> (hx : x ‚àà balancedHull ùïú s)  -> (r : ùïú)  -> (h_1 : ‚àÉ (x_1 : ‚Äñr‚Äñ ‚â§ 1), x ‚àà r ‚Ä¢ s)  -> (hr : ‚Äñr‚Äñ ‚â§ 1)  -> (h_2 : x ‚àà r ‚Ä¢ s)  -> (y : E)  -> (h_3 : (y ‚àà s) ‚àß ((fun (x : E) ‚Ü¶ r ‚Ä¢ x) y = x))  -> (hy : y ‚àà s)  -> (right : (fun (x : E) ‚Ü¶ r ‚Ä¢ x) y = x)  -> (hx : (fun (x : E) ‚Ü¶ r ‚Ä¢ x) y ‚àà balancedHull ùïú s)   -> y ‚àà t

{Œ± : Type u_2} {m0 : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {Œ≥ : Type u_1} (f : (a : Œ±) ‚Üí Œ≥) (g : (a : Œ±) ‚Üí Œ≥) (s : Set Œ±) (hs_zero : ‚Üë‚ÜëŒº s = 0) (h_ss : s·∂ú ‚äÜ {a : Œ± | (if (a ‚àà s) then f a else g a) = g a}) {Œ± : Type u_2} [HasSubset Œ±] (a : Œ±) (a_1 : Œ±) (e_a : a = a_1) (a_2 : Œ±) (a_3 : Œ±) (e_a : a_2 = a_3)  : (a ‚äÜ a_2) = (a ‚äÜ a_2)
failed to synthesize instance
  Decidable (a ‚àà s) ; identifiers [Œ±, u_2, m0, MeasurableSpace, Œ±, Œº, MeasureTheory.Measure, Œ±, Œ≥, u_1, f, a, Œ±, Œ≥, g, a, Œ±, Œ≥, s, Set, Œ±, hs_zero, Œº, s, h_ss, s, a, Œ±, a, s, f, a, g, a, g, a, Œ±, u_2, HasSubset, Œ±, a, Œ±, a_1, Œ±, e_a, a, a_1, a_2, Œ±, a_3, Œ±, e_a, a_2, a_3, a, a_2, a, a_2] (during elaboration) for {Œ± : Type u_2}  -> {m0 : MeasurableSpace Œ±}  -> {Œº : MeasureTheory.Measure Œ±}  -> {Œ≥ : Type u_1}  -> (f : (a : Œ±) ‚Üí Œ≥)  -> (g : (a : Œ±) ‚Üí Œ≥)  -> (s : Set Œ±)  -> (hs_zero : ‚Üë‚ÜëŒº s = 0)  -> (h_ss : s·∂ú ‚äÜ {a : Œ± | (if (a ‚àà s) then f a else g a) = g a})  -> {Œ± : Type u_2}  -> [HasSubset Œ±]  -> (a : Œ±)  -> (a_1 : Œ±)  -> (e_a : a = a_1)  -> (a_2 : Œ±)  -> (a_3 : Œ±)  -> (e_a : a_2 = a_3)   -> (a ‚äÜ a_2) = (a ‚äÜ a_2)

{Œ± : Type u_2} {m0 : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {Œ≥ : Type u_1} (f : (a : Œ±) ‚Üí Œ≥) (g : (a : Œ±) ‚Üí Œ≥) (s : Set Œ±) (hs_zero : ‚Üë‚ÜëŒº s = 0) (h_ss : s·∂ú ‚äÜ {a : Œ± | (if (a ‚àà s) then f a else g a) = g a})  : s = s
failed to synthesize instance
  Decidable (a ‚àà s) ; identifiers [Œ±, u_2, m0, MeasurableSpace, Œ±, Œº, MeasureTheory.Measure, Œ±, Œ≥, u_1, f, a, Œ±, Œ≥, g, a, Œ±, Œ≥, s, Set, Œ±, hs_zero, Œº, s, h_ss, s, a, Œ±, a, s, f, a, g, a, g, a, s, s] (during elaboration) for {Œ± : Type u_2}  -> {m0 : MeasurableSpace Œ±}  -> {Œº : MeasureTheory.Measure Œ±}  -> {Œ≥ : Type u_1}  -> (f : (a : Œ±) ‚Üí Œ≥)  -> (g : (a : Œ±) ‚Üí Œ≥)  -> (s : Set Œ±)  -> (hs_zero : ‚Üë‚ÜëŒº s = 0)  -> (h_ss : s·∂ú ‚äÜ {a : Œ± | (if (a ‚àà s) then f a else g a) = g a})   -> s = s

{Œ± : Type u_2} {m0 : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {Œ≥ : Type u_1} (f : (a : Œ±) ‚Üí Œ≥) (g : (a : Œ±) ‚Üí Œ≥) (s : Set Œ±) (hs_zero : ‚Üë‚ÜëŒº s = 0) (h_ss : s·∂ú ‚äÜ {a : Œ± | (if (a ‚àà s) then f a else g a) = g a})  : s·∂ú·∂ú = s·∂ú·∂ú
failed to synthesize instance
  Decidable (a ‚àà s) ; identifiers [Œ±, u_2, m0, MeasurableSpace, Œ±, Œº, MeasureTheory.Measure, Œ±, Œ≥, u_1, f, a, Œ±, Œ≥, g, a, Œ±, Œ≥, s, Set, Œ±, hs_zero, Œº, s, h_ss, s, a, Œ±, a, s, f, a, g, a, g, a, s, s] (during elaboration) for {Œ± : Type u_2}  -> {m0 : MeasurableSpace Œ±}  -> {Œº : MeasureTheory.Measure Œ±}  -> {Œ≥ : Type u_1}  -> (f : (a : Œ±) ‚Üí Œ≥)  -> (g : (a : Œ±) ‚Üí Œ≥)  -> (s : Set Œ±)  -> (hs_zero : ‚Üë‚ÜëŒº s = 0)  -> (h_ss : s·∂ú ‚äÜ {a : Œ± | (if (a ‚àà s) then f a else g a) = g a})   -> s·∂ú·∂ú = s·∂ú·∂ú

{C : Type u_2} [CategoryTheory.Category C] {X : C} {Y : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Y} {s : CategoryTheory.Limits.Fork f g} {t : CategoryTheory.Limits.Fork f g} (i : CategoryTheory.Limits.Cone.pt s ‚âÖ CategoryTheory.Limits.Cone.pt t) (w : autoParam (CategoryTheory.CategoryStruct.comp i.hom (CategoryTheory.Limits.Fork.Œπ t) = CategoryTheory.Limits.Fork.Œπ s)
  _auto‚úù)  : CategoryTheory.Limits.Fork.Œπ s = CategoryTheory.CategoryStruct.comp i.hom (CategoryTheory.Limits.Fork.Œπ t)
<input>:2:7: expected token

{ùïú : Type u_2} {E : Type u_1} [OrderedSemiring ùïú] [AddCommGroup E] [Module ùïú E] {s : Set E} (hc : ‚àÄ (t : Set E) (a : t ‚äÜ s), s ‚à© ‚Üë(convexHull ùïú) t ‚äÜ t) (t : Set { x : E // x ‚àà s }) (x : { x : E // x ‚àà s }) (h : ‚Üëx ‚àà ‚Üë(convexHull ùïú) (Subtype.val '' t))  : (x ‚àà t) = (x ‚àà t)
type mismatch
  x
has type
  { x // x ‚àà s } : Type u_1
but is expected to have type
  ?m.1136 hc t x : outParam (Type ?u.845) ; identifiers [ùïú, u_2, E, u_1, OrderedSemiring, ùïú, AddCommGroup, E, Module, ùïú, E, s, Set, E, hc, t, Set, E, a, t, s, s, convexHull, ùïú, t, t, t, Set, x, E, x, s, x, x, E, x, s, h, x, convexHull, ùïú, Subtype.val, t, x, t, x, t] (during elaboration) for {ùïú : Type u_2}  -> {E : Type u_1}  -> [OrderedSemiring ùïú]  -> [AddCommGroup E]  -> [Module ùïú E]  -> {s : Set E}  -> (hc : ‚àÄ (t : Set E) (a : t ‚äÜ s), s ‚à© ‚Üë(convexHull ùïú) t ‚äÜ t)  -> (t : Set { x : E // x ‚àà s })  -> (x : { x : E // x ‚àà s })  -> (h : ‚Üëx ‚àà ‚Üë(convexHull ùïú) (Subtype.val '' t))   -> (x ‚àà t) = (x ‚àà t)

 : (‚àÄ {Œπ : Type u_1} {V : Type u} [inst : CategoryTheory.Category V] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms V]
  {c : ComplexShape Œπ} {A : HomologicalComplex V c} {B : HomologicalComplex V c} [inst_2 : SizeOf Œπ] [inst_3 : SizeOf V]
  (f : (i : Œπ) ‚Üí HomologicalComplex.X A i ‚ü∂ HomologicalComplex.X B i)
  (comm' :
    autoParam
      (‚àÄ (i : Œπ) (j : Œπ) (a : ComplexShape.Rel c i j),
        CategoryTheory.CategoryStruct.comp (f i) (HomologicalComplex.d B i j) =
          CategoryTheory.CategoryStruct.comp (HomologicalComplex.d A i j) (f j))
      _auto‚úù),
  sizeOf (HomologicalComplex.Hom.mk f) = 1)
<input>:9:11: expected token

 : ‚àÄ {Œπ : Type u_1} {V : Type u} [inst : CategoryTheory.Category V] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms V]
  {c : ComplexShape Œπ} {A : HomologicalComplex V c} {B : HomologicalComplex V c} [inst_2 : SizeOf Œπ] [inst_3 : SizeOf V]
  (f : (i : Œπ) ‚Üí HomologicalComplex.X A i ‚ü∂ HomologicalComplex.X B i)
  (comm' :
    autoParam
      (‚àÄ (i : Œπ) (j : Œπ) (a : ComplexShape.Rel c i j),
        CategoryTheory.CategoryStruct.comp (f i) (HomologicalComplex.d B i j) =
          CategoryTheory.CategoryStruct.comp (HomologicalComplex.d A i j) (f j))
      _auto‚úù),
  1 = 1
<input>:9:11: expected token

{Œ± : Type u_1} {M : Type u_3} (R : Type u_2) [Semiring R] [AddCommMonoid M] [Module R M] {s : Finset Œ±} {f : (a : Œ±) ‚Üí R} (g : (a : Œ±) ‚Üí M) (hf : ‚àÄ (a : Œ±) (a_1 : f a ‚â† 0), a ‚àà s)  : ‚àÄ (x : Œ±) (a : x ‚àà Finset.filter (fun (a : Œ±) ‚Ü¶ f a ‚â† 0) s), f x ‚Ä¢ g x = f x ‚Ä¢ g x
failed to synthesize instance
  DecidablePred fun a => f a ‚â† 0 ; identifiers [Œ±, u_1, M, u_3, R, u_2, Semiring, R, AddCommMonoid, M, Module, R, M, s, Finset, Œ±, f, a, Œ±, R, g, a, Œ±, M, hf, a, Œ±, a_1, f, a, a, s, x, Œ±, a, x, Finset.filter, a, Œ±, f, a, s, f, x, g, x, f, x, g, x] (during elaboration) for {Œ± : Type u_1}  -> {M : Type u_3}  -> (R : Type u_2)  -> [Semiring R]  -> [AddCommMonoid M]  -> [Module R M]  -> {s : Finset Œ±}  -> {f : (a : Œ±) ‚Üí R}  -> (g : (a : Œ±) ‚Üí M)  -> (hf : ‚àÄ (a : Œ±) (a_1 : f a ‚â† 0), a ‚àà s)   -> ‚àÄ (x : Œ±) (a : x ‚àà Finset.filter (fun (a : Œ±) ‚Ü¶ f a ‚â† 0) s), f x ‚Ä¢ g x = f x ‚Ä¢ g x

{Œ± : Type u_1} (x : Subtype Setoid.IsPartition) (y : Subtype Setoid.IsPartition) (hx : x ‚â§ y) (hy : y ‚â§ x) (h : Setoid.mkClasses ‚Üëx (Setoid.Partition.le.proof_1 x) = Setoid.mkClasses ‚Üëy (Setoid.Partition.le.proof_2 y))  : (x = y) = (x = y)
application type mismatch
  Setoid.mkClasses ?m.2267 (_ : ‚àÄ (a : ?m.5707), ‚àÉ! b x, a ‚àà b)
argument
  Setoid.Partition.le.proof_2 y
has type
  ‚àÄ (a : ?m.5707), ‚àÉ! b x, a ‚àà b : Prop
but is expected to have type
  ‚àÄ (a : ?m.5708 x y hx hy), ‚àÉ! b x_1, a ‚àà b : Prop ; identifiers [Œ±, u_1, x, Subtype, Setoid.IsPartition, y, Subtype, Setoid.IsPartition, hx, x, y, hy, y, x, h, Setoid.mkClasses, x, Setoid.Partition.le.proof_1, x, Setoid.mkClasses, y, Setoid.Partition.le.proof_2, y, x, y, x, y] (during elaboration) for {Œ± : Type u_1}  -> (x : Subtype Setoid.IsPartition)  -> (y : Subtype Setoid.IsPartition)  -> (hx : x ‚â§ y)  -> (hy : y ‚â§ x)  -> (h : Setoid.mkClasses ‚Üëx (Setoid.Partition.le.proof_1 x) = Setoid.mkClasses ‚Üëy (Setoid.Partition.le.proof_2 y))   -> (x = y) = (x = y)

{Œ± : Type u_1} (x : Subtype Setoid.IsPartition) (y : Subtype Setoid.IsPartition) (hx : x ‚â§ y) (hy : y ‚â§ x) (h : Setoid.mkClasses ‚Üëx (Setoid.Partition.le.proof_1 x) = Setoid.mkClasses ‚Üëy (Setoid.Partition.le.proof_2 y))  : (‚Üëx = ‚Üëy) = (‚Üëx = ‚Üëy)
type mismatch
  y
has type
  Subtype Setoid.IsPartition : Type ?u.8
but is expected to have type
  ?m.5928 x y hx hy h : Sort ?u.5682 ; identifiers [Œ±, u_1, x, Subtype, Setoid.IsPartition, y, Subtype, Setoid.IsPartition, hx, x, y, hy, y, x, h, Setoid.mkClasses, x, Setoid.Partition.le.proof_1, x, Setoid.mkClasses, y, Setoid.Partition.le.proof_2, y, x, y, x, y] (during elaboration) for {Œ± : Type u_1}  -> (x : Subtype Setoid.IsPartition)  -> (y : Subtype Setoid.IsPartition)  -> (hx : x ‚â§ y)  -> (hy : y ‚â§ x)  -> (h : Setoid.mkClasses ‚Üëx (Setoid.Partition.le.proof_1 x) = Setoid.mkClasses ‚Üëy (Setoid.Partition.le.proof_2 y))   -> (‚Üëx = ‚Üëy) = (‚Üëx = ‚Üëy)

{Œ± : Type u_1} [HeytingAlgebra Œ±]  : (‚ä•·∂ú = ‚ä§) = (‚ä•·∂ú = ‚ä§)
typeclass instance problem is stuck, it is often due to metavariables
  Top ?m.2795 ; identifiers [Œ±, u_1, HeytingAlgebra, Œ±] (during elaboration) for {Œ± : Type u_1}  -> [HeytingAlgebra Œ±]   -> (‚ä•·∂ú = ‚ä§) = (‚ä•·∂ú = ‚ä§)

{Œ± : Type u_1} [HeytingAlgebra Œ±]  : (‚ä• ‚á® ‚ä• = ‚ä§) = (‚ä• ‚á® ‚ä• = ‚ä§)
typeclass instance problem is stuck, it is often due to metavariables
  Top ?m.4000 ; identifiers [Œ±, u_1, HeytingAlgebra, Œ±] (during elaboration) for {Œ± : Type u_1}  -> [HeytingAlgebra Œ±]   -> (‚ä• ‚á® ‚ä• = ‚ä§) = (‚ä• ‚á® ‚ä• = ‚ä§)

{Œ± : Type u_1} [HeytingAlgebra Œ±]  : ‚ä§ = ‚ä§
typeclass instance problem is stuck, it is often due to metavariables
  Top ?m.701 ; identifiers [Œ±, u_1, HeytingAlgebra, Œ±] (during elaboration) for {Œ± : Type u_1}  -> [HeytingAlgebra Œ±]   -> ‚ä§ = ‚ä§

{Œ± : Type u} {Œ≤ : Type v} [Fintype Œ≤] (r : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Prop) [(a : Œ±) ‚Üí DecidablePred (r a)] (r' : (a : Œ±) ‚Üí Finset Œ≤ := fun (a : Œ±) ‚Ü¶ Finset.filter (fun (b : Œ≤) ‚Ü¶ r a b) Finset.univ) (h : ‚àÄ (A : Finset Œ±), Finset.filter (fun (b : Œ≤) ‚Ü¶ ‚àÉ (a : Œ±), (a ‚àà A) ‚àß (r a b)) Finset.univ = Finset.biUnion A r') (h' : ‚àÄ (f : (a : Œ±) ‚Üí Œ≤) (x : Œ±), (r x (f x)) ‚Üî (f x ‚àà r' x)) (A : Finset Œ±)  : ‚àÄ (A : Finset Œ±), Finset.filter (fun (b : Œ≤) ‚Ü¶ ‚àÉ (a : Œ±), (a ‚àà A) ‚àß (r a b)) Finset.univ = Finset.biUnion A r'
failed to synthesize instance
  DecidableEq Œ≤ ; identifiers [Œ±, u, Œ≤, v, Fintype, Œ≤, r, a, Œ±, a, Œ≤, a, Œ±, DecidablePred, r, a, r', a, Œ±, Finset, Œ≤, a, Œ±, Finset.filter, b, Œ≤, r, a, b, Finset.univ, h, A, Finset, Œ±, Finset.filter, b, Œ≤, a, Œ±, a, A, r, a, b, Finset.univ, Finset.biUnion, A, r', h', f, a, Œ±, Œ≤, x, Œ±, r, x, f, x, f, x, r', x, A, Finset, Œ±, A, Finset, Œ±, Finset.filter, b, Œ≤, a, Œ±, a, A, r, a, b, Finset.univ, Finset.biUnion, A, r'] (during elaboration) for {Œ± : Type u}  -> {Œ≤ : Type v}  -> [Fintype Œ≤]  -> (r : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Prop)  -> [(a : Œ±) ‚Üí DecidablePred (r a)]  -> (r' : (a : Œ±) ‚Üí Finset Œ≤ := fun (a : Œ±) ‚Ü¶ Finset.filter (fun (b : Œ≤) ‚Ü¶ r a b) Finset.univ)  -> (h : ‚àÄ (A : Finset Œ±), Finset.filter (fun (b : Œ≤) ‚Ü¶ ‚àÉ (a : Œ±), (a ‚àà A) ‚àß (r a b)) Finset.univ = Finset.biUnion A r')  -> (h' : ‚àÄ (f : (a : Œ±) ‚Üí Œ≤) (x : Œ±), (r x (f x)) ‚Üî (f x ‚àà r' x))  -> (A : Finset Œ±)   -> ‚àÄ (A : Finset Œ±), Finset.filter (fun (b : Œ≤) ‚Ü¶ ‚àÉ (a : Œ±), (a ‚àà A) ‚àß (r a b)) Finset.univ = Finset.biUnion A r'

{R : Type u_3} {S : Type u_1} [CommRing R] [CommRing S] (f : R ‚Üí+* S) {X : ModuleCat R} (x : ‚ÜëX) (x' : ‚ÜëX)  : (1 ‚äó‚Çú[R] (x + x') = 1 ‚äó‚Çú[R] x + 1 ‚äó‚Çú[R] x') = (1 ‚äó‚Çú[R] (x + x') = 1 ‚äó‚Çú[R] x + 1 ‚äó‚Çú[R] x')
type mismatch
  X
has type
  ModuleCat R : Type (max u_3 (?u.531 + 1))
but is expected to have type
  Sort ?u.661 : Type ?u.661 ; identifiers [R, u_3, S, u_1, CommRing, R, CommRing, S, f, R, S, X, ModuleCat, R, x, X, x', X, R, x, x', R, x, R, x', R, x, x', R, x, R, x'] (during elaboration) for {R : Type u_3}  -> {S : Type u_1}  -> [CommRing R]  -> [CommRing S]  -> (f : R ‚Üí+* S)  -> {X : ModuleCat R}  -> (x : ‚ÜëX)  -> (x' : ‚ÜëX)   -> (1 ‚äó‚Çú[R] (x + x') = 1 ‚äó‚Çú[R] x + 1 ‚äó‚Çú[R] x') = (1 ‚äó‚Çú[R] (x + x') = 1 ‚äó‚Çú[R] x + 1 ‚äó‚Çú[R] x')

{R : Type u_3} {S : Type u_1} [CommRing R] [CommRing S] (f : R ‚Üí+* S) {X : ModuleCat R} (x : ‚ÜëX) (x' : ‚ÜëX)  : 1 ‚äó‚Çú[R] x + 1 ‚äó‚Çú[R] x' = 1 ‚äó‚Çú[R] x + 1 ‚äó‚Çú[R] x'
type mismatch
  X
has type
  ModuleCat R : Type (max u_3 (?u.531 + 1))
but is expected to have type
  Sort ?u.661 : Type ?u.661 ; identifiers [R, u_3, S, u_1, CommRing, R, CommRing, S, f, R, S, X, ModuleCat, R, x, X, x', X, R, x, R, x', R, x, R, x'] (during elaboration) for {R : Type u_3}  -> {S : Type u_1}  -> [CommRing R]  -> [CommRing S]  -> (f : R ‚Üí+* S)  -> {X : ModuleCat R}  -> (x : ‚ÜëX)  -> (x' : ‚ÜëX)   -> 1 ‚äó‚Çú[R] x + 1 ‚äó‚Çú[R] x' = 1 ‚äó‚Çú[R] x + 1 ‚äó‚Çú[R] x'

{R : Type u} {A : Type v} {B : Type w} [CommSemiring R] [Semiring A] [Semiring B] [Algebra R A] [Algebra R B] (toRingHom : A ‚Üí+* B) (commutes' : ‚àÄ (r : R), OneHom.toFun (‚Üë‚ÜëtoRingHom) (‚Üë(algebraMap R A) r) = ‚Üë(algebraMap R B) r) (toRingHom_1 : A ‚Üí+* B) (commutes'_1 : ‚àÄ (r : R), OneHom.toFun (‚Üë‚ÜëtoRingHom_1) (‚Üë(algebraMap R A) r) = ‚Üë(algebraMap R B) r) (a : { toRingHom := ((toRingHom)), commutes' := ((commutes')) } =
  { toRingHom := ((toRingHom_1)), commutes' := ((commutes'_1)) })  : ‚àÄ (toRingHom_eq : toRingHom = toRingHom_1), toRingHom = toRingHom_1
type mismatch
  toRingHom_1
has type
  A ‚Üí+* B : Type (max v w)
but is expected to have type
  OneHom (?m.7752 toRingHom commutes' toRingHom_1 r)
    (?m.7748 toRingHom commutes' toRingHom_1 r) : Type (max ?u.3580 ?u.3579) ; identifiers [R, u, A, v, B, w, CommSemiring, R, Semiring, A, Semiring, B, Algebra, R, A, Algebra, R, B, toRingHom, A, B, commutes', r, R, OneHom.toFun, toRingHom, algebraMap, R, A, r, algebraMap, R, B, r, toRingHom_1, A, B, commutes'_1, r, R, OneHom.toFun, toRingHom_1, algebraMap, R, A, r, algebraMap, R, B, r, a, toRingHom, toRingHom, commutes', commutes', toRingHom, toRingHom_1, commutes', commutes'_1, toRingHom_eq, toRingHom, toRingHom_1, toRingHom, toRingHom_1] (during elaboration) for {R : Type u}  -> {A : Type v}  -> {B : Type w}  -> [CommSemiring R]  -> [Semiring A]  -> [Semiring B]  -> [Algebra R A]  -> [Algebra R B]  -> (toRingHom : A ‚Üí+* B)  -> (commutes' : ‚àÄ (r : R), OneHom.toFun (‚Üë‚ÜëtoRingHom) (‚Üë(algebraMap R A) r) = ‚Üë(algebraMap R B) r)  -> (toRingHom_1 : A ‚Üí+* B)  -> (commutes'_1 : ‚àÄ (r : R), OneHom.toFun (‚Üë‚ÜëtoRingHom_1) (‚Üë(algebraMap R A) r) = ‚Üë(algebraMap R B) r)  -> (a : { toRingHom := ((toRingHom)), commutes' := ((commutes')) } =
  { toRingHom := ((toRingHom_1)), commutes' := ((commutes'_1)) })   -> ‚àÄ (toRingHom_eq : toRingHom = toRingHom_1), toRingHom = toRingHom_1

{Œ± : Type u} {Œ≤ : Type v} [Fintype Œ≤] (r : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Prop) [(a : Œ±) ‚Üí DecidablePred (r a)] (r' : (a : Œ±) ‚Üí Finset Œ≤ := fun (a : Œ±) ‚Ü¶ Finset.filter (fun (b : Œ≤) ‚Ü¶ r a b) Finset.univ) (h : ‚àÄ (A : Finset Œ±), Finset.filter (fun (b : Œ≤) ‚Ü¶ ‚àÉ (a : Œ±), (a ‚àà A) ‚àß (r a b)) Finset.univ = Finset.biUnion A r') (h' : ‚àÄ (f : (a : Œ±) ‚Üí Œ≤) (x : Œ±), (r x (f x)) ‚Üî (f x ‚àà r' x)) (f : (a : Œ±) ‚Üí Œ≤) (x : Œ±) (f : (a : Œ±) ‚Üí Œ≤) (x : Œ±)  : (r x (f x)) ‚Üî (f x ‚àà r' x)
failed to synthesize instance
  DecidableEq Œ≤ ; identifiers [Œ±, u, Œ≤, v, Fintype, Œ≤, r, a, Œ±, a, Œ≤, a, Œ±, DecidablePred, r, a, r', a, Œ±, Finset, Œ≤, a, Œ±, Finset.filter, b, Œ≤, r, a, b, Finset.univ, h, A, Finset, Œ±, Finset.filter, b, Œ≤, a, Œ±, a, A, r, a, b, Finset.univ, Finset.biUnion, A, r', h', f, a, Œ±, Œ≤, x, Œ±, r, x, f, x, f, x, r', x, f, a, Œ±, Œ≤, x, Œ±, f, a, Œ±, Œ≤, x, Œ±, r, x, f, x, f, x, r', x] (during elaboration) for {Œ± : Type u}  -> {Œ≤ : Type v}  -> [Fintype Œ≤]  -> (r : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Prop)  -> [(a : Œ±) ‚Üí DecidablePred (r a)]  -> (r' : (a : Œ±) ‚Üí Finset Œ≤ := fun (a : Œ±) ‚Ü¶ Finset.filter (fun (b : Œ≤) ‚Ü¶ r a b) Finset.univ)  -> (h : ‚àÄ (A : Finset Œ±), Finset.filter (fun (b : Œ≤) ‚Ü¶ ‚àÉ (a : Œ±), (a ‚àà A) ‚àß (r a b)) Finset.univ = Finset.biUnion A r')  -> (h' : ‚àÄ (f : (a : Œ±) ‚Üí Œ≤) (x : Œ±), (r x (f x)) ‚Üî (f x ‚àà r' x))  -> (f : (a : Œ±) ‚Üí Œ≤)  -> (x : Œ±)  -> (f : (a : Œ±) ‚Üí Œ≤)  -> (x : Œ±)   -> (r x (f x)) ‚Üî (f x ‚àà r' x)

{C : Type u_2} [CategoryTheory.Category C] ‚¶ÉX : C‚¶Ñ ‚¶ÉS : CategoryTheory.Sieve X‚¶Ñ (H‚ÇÅ : S ‚àà
  (fun (X : C) (S : CategoryTheory.Sieve X) ‚Ü¶
      ‚àÄ {Y : C} (f : Y ‚ü∂ X), ‚àÉ (Z : C), ‚àÉ (g : Z ‚ü∂ Y), S.arrows (CategoryTheory.CategoryStruct.comp g f))
    X) (R : CategoryTheory.Sieve X) (H‚ÇÇ : ‚àÄ ‚¶ÉY : C‚¶Ñ ‚¶Éf : Y ‚ü∂ X‚¶Ñ (a : S.arrows f),
  CategoryTheory.Sieve.pullback f R ‚àà
    (fun (X : C) (S : CategoryTheory.Sieve X) ‚Ü¶
        ‚àÄ {Y : C} (f : Y ‚ü∂ X), ‚àÉ (Z : C), ‚àÉ (g : Z ‚ü∂ Y), S.arrows (CategoryTheory.CategoryStruct.comp g f))
      Y) {Y : C} (f : Y ‚ü∂ X)  : ‚àÉ (Z : C), ‚àÉ (g : Z ‚ü∂ Y), S.arrows (CategoryTheory.CategoryStruct.comp g f)
failed to synthesize instance
  Membership (CategoryTheory.Sieve X) (CategoryTheory.Sieve X ‚Üí Prop) ; identifiers [C, u_2, CategoryTheory.Category, C, X, C, S, CategoryTheory.Sieve, X, H‚ÇÅ, S, X, C, S, CategoryTheory.Sieve, X, Y, C, f, Y, X, Z, C, g, Z, Y, S.arrows, CategoryTheory.CategoryStruct.comp, g, f, X, R, CategoryTheory.Sieve, X, H‚ÇÇ, Y, C, f, Y, X, a, S.arrows, f, CategoryTheory.Sieve.pullback, f, R, X, C, S, CategoryTheory.Sieve, X, Y, C, f, Y, X, Z, C, g, Z, Y, S.arrows, CategoryTheory.CategoryStruct.comp, g, f, Y, Y, C, f, Y, X, Z, C, g, Z, Y, S.arrows, CategoryTheory.CategoryStruct.comp, g, f] (during elaboration) for {C : Type u_2}  -> [CategoryTheory.Category C]  -> ‚¶ÉX : C‚¶Ñ  -> ‚¶ÉS : CategoryTheory.Sieve X‚¶Ñ  -> (H‚ÇÅ : S ‚àà
  (fun (X : C) (S : CategoryTheory.Sieve X) ‚Ü¶
      ‚àÄ {Y : C} (f : Y ‚ü∂ X), ‚àÉ (Z : C), ‚àÉ (g : Z ‚ü∂ Y), S.arrows (CategoryTheory.CategoryStruct.comp g f))
    X)  -> (R : CategoryTheory.Sieve X)  -> (H‚ÇÇ : ‚àÄ ‚¶ÉY : C‚¶Ñ ‚¶Éf : Y ‚ü∂ X‚¶Ñ (a : S.arrows f),
  CategoryTheory.Sieve.pullback f R ‚àà
    (fun (X : C) (S : CategoryTheory.Sieve X) ‚Ü¶
        ‚àÄ {Y : C} (f : Y ‚ü∂ X), ‚àÉ (Z : C), ‚àÉ (g : Z ‚ü∂ Y), S.arrows (CategoryTheory.CategoryStruct.comp g f))
      Y)  -> {Y : C}  -> (f : Y ‚ü∂ X)   -> ‚àÉ (Z : C), ‚àÉ (g : Z ‚ü∂ Y), S.arrows (CategoryTheory.CategoryStruct.comp g f)

{R : Type u} {A : Type v} {B : Type w} [CommSemiring R] [Semiring A] [Semiring B] [Algebra R A] [Algebra R B] (toRingHom : A ‚Üí+* B) (commutes' : ‚àÄ (r : R), OneHom.toFun (‚Üë‚ÜëtoRingHom) (‚Üë(algebraMap R A) r) = ‚Üë(algebraMap R B) r) (toRingHom_1 : A ‚Üí+* B) (commutes'_1 : ‚àÄ (r : R), OneHom.toFun (‚Üë‚ÜëtoRingHom_1) (‚Üë(algebraMap R A) r) = ‚Üë(algebraMap R B) r) (a : toRingHom = toRingHom_1) (h : toRingHom_1 = toRingHom) (toRingHom_2 : A ‚Üí+* B)  : toRingHom = toRingHom
type mismatch
  toRingHom_1
has type
  A ‚Üí+* B : Type (max v w)
but is expected to have type
  OneHom (?m.7342 toRingHom commutes' toRingHom_1 r)
    (?m.7338 toRingHom commutes' toRingHom_1 r) : Type (max ?u.3580 ?u.3579) ; identifiers [R, u, A, v, B, w, CommSemiring, R, Semiring, A, Semiring, B, Algebra, R, A, Algebra, R, B, toRingHom, A, B, commutes', r, R, OneHom.toFun, toRingHom, algebraMap, R, A, r, algebraMap, R, B, r, toRingHom_1, A, B, commutes'_1, r, R, OneHom.toFun, toRingHom_1, algebraMap, R, A, r, algebraMap, R, B, r, a, toRingHom, toRingHom_1, h, toRingHom_1, toRingHom, toRingHom_2, A, B, toRingHom, toRingHom] (during elaboration) for {R : Type u}  -> {A : Type v}  -> {B : Type w}  -> [CommSemiring R]  -> [Semiring A]  -> [Semiring B]  -> [Algebra R A]  -> [Algebra R B]  -> (toRingHom : A ‚Üí+* B)  -> (commutes' : ‚àÄ (r : R), OneHom.toFun (‚Üë‚ÜëtoRingHom) (‚Üë(algebraMap R A) r) = ‚Üë(algebraMap R B) r)  -> (toRingHom_1 : A ‚Üí+* B)  -> (commutes'_1 : ‚àÄ (r : R), OneHom.toFun (‚Üë‚ÜëtoRingHom_1) (‚Üë(algebraMap R A) r) = ‚Üë(algebraMap R B) r)  -> (a : toRingHom = toRingHom_1)  -> (h : toRingHom_1 = toRingHom)  -> (toRingHom_2 : A ‚Üí+* B)   -> toRingHom = toRingHom

{R : Type u} {A : Type v} {B : Type w} [CommSemiring R] [Semiring A] [Semiring B] [Algebra R A] [Algebra R B] (toRingHom : A ‚Üí+* B) (commutes' : ‚àÄ (r : R), OneHom.toFun (‚Üë‚ÜëtoRingHom) (‚Üë(algebraMap R A) r) = ‚Üë(algebraMap R B) r) (toRingHom_1 : A ‚Üí+* B) (commutes'_1 : ‚àÄ (r : R), OneHom.toFun (‚Üë‚ÜëtoRingHom_1) (‚Üë(algebraMap R A) r) = ‚Üë(algebraMap R B) r) (a : toRingHom = toRingHom_1) (h : toRingHom_1 = toRingHom) (commutes'_2 : ‚àÄ (r : R), OneHom.toFun (‚Üë‚ÜëtoRingHom) (‚Üë(algebraMap R A) r) = ‚Üë(algebraMap R B) r) (a : toRingHom = toRingHom) (h : HEq a (Eq.refl toRingHom))  : { toRingHom := ((toRingHom)), commutes' := ((commutes')) } = { toRingHom := ((toRingHom)), commutes' := ((commutes')) }
type mismatch
  toRingHom
has type
  A ‚Üí+* B : Type (max v w)
but is expected to have type
  OneHom (?m.13500 toRingHom commutes' toRingHom_1 commutes'_1 a h r)
    (?m.13484 toRingHom commutes' toRingHom_1 commutes'_1 a h r) : Type (max ?u.7031 ?u.7030) ; identifiers [R, u, A, v, B, w, CommSemiring, R, Semiring, A, Semiring, B, Algebra, R, A, Algebra, R, B, toRingHom, A, B, commutes', r, R, OneHom.toFun, toRingHom, algebraMap, R, A, r, algebraMap, R, B, r, toRingHom_1, A, B, commutes'_1, r, R, OneHom.toFun, toRingHom_1, algebraMap, R, A, r, algebraMap, R, B, r, a, toRingHom, toRingHom_1, h, toRingHom_1, toRingHom, commutes'_2, r, R, OneHom.toFun, toRingHom, algebraMap, R, A, r, algebraMap, R, B, r, a, toRingHom, toRingHom, h, HEq, a, Eq.refl, toRingHom, toRingHom, toRingHom, commutes', commutes', toRingHom, toRingHom, commutes', commutes'] (during elaboration) for {R : Type u}  -> {A : Type v}  -> {B : Type w}  -> [CommSemiring R]  -> [Semiring A]  -> [Semiring B]  -> [Algebra R A]  -> [Algebra R B]  -> (toRingHom : A ‚Üí+* B)  -> (commutes' : ‚àÄ (r : R), OneHom.toFun (‚Üë‚ÜëtoRingHom) (‚Üë(algebraMap R A) r) = ‚Üë(algebraMap R B) r)  -> (toRingHom_1 : A ‚Üí+* B)  -> (commutes'_1 : ‚àÄ (r : R), OneHom.toFun (‚Üë‚ÜëtoRingHom_1) (‚Üë(algebraMap R A) r) = ‚Üë(algebraMap R B) r)  -> (a : toRingHom = toRingHom_1)  -> (h : toRingHom_1 = toRingHom)  -> (commutes'_2 : ‚àÄ (r : R), OneHom.toFun (‚Üë‚ÜëtoRingHom) (‚Üë(algebraMap R A) r) = ‚Üë(algebraMap R B) r)  -> (a : toRingHom = toRingHom)  -> (h : HEq a (Eq.refl toRingHom))   -> { toRingHom := ((toRingHom)), commutes' := ((commutes')) } = { toRingHom := ((toRingHom)), commutes' := ((commutes')) }

{R : Type u} {A : Type v} {B : Type w} [CommSemiring R] [Semiring A] [Semiring B] [Algebra R A] [Algebra R B] (toRingHom : A ‚Üí+* B) (commutes' : ‚àÄ (r : R), OneHom.toFun (‚Üë‚ÜëtoRingHom) (‚Üë(algebraMap R A) r) = ‚Üë(algebraMap R B) r) (toRingHom_1 : A ‚Üí+* B) (commutes'_1 : ‚àÄ (r : R), OneHom.toFun (‚Üë‚ÜëtoRingHom_1) (‚Üë(algebraMap R A) r) = ‚Üë(algebraMap R B) r) (a : toRingHom = toRingHom_1) (h : toRingHom_1 = toRingHom)  : toRingHom = toRingHom_1
type mismatch
  toRingHom_1
has type
  A ‚Üí+* B : Type (max v w)
but is expected to have type
  OneHom (?m.7335 toRingHom commutes' toRingHom_1 r)
    (?m.7331 toRingHom commutes' toRingHom_1 r) : Type (max ?u.3580 ?u.3579) ; identifiers [R, u, A, v, B, w, CommSemiring, R, Semiring, A, Semiring, B, Algebra, R, A, Algebra, R, B, toRingHom, A, B, commutes', r, R, OneHom.toFun, toRingHom, algebraMap, R, A, r, algebraMap, R, B, r, toRingHom_1, A, B, commutes'_1, r, R, OneHom.toFun, toRingHom_1, algebraMap, R, A, r, algebraMap, R, B, r, a, toRingHom, toRingHom_1, h, toRingHom_1, toRingHom, toRingHom, toRingHom_1] (during elaboration) for {R : Type u}  -> {A : Type v}  -> {B : Type w}  -> [CommSemiring R]  -> [Semiring A]  -> [Semiring B]  -> [Algebra R A]  -> [Algebra R B]  -> (toRingHom : A ‚Üí+* B)  -> (commutes' : ‚àÄ (r : R), OneHom.toFun (‚Üë‚ÜëtoRingHom) (‚Üë(algebraMap R A) r) = ‚Üë(algebraMap R B) r)  -> (toRingHom_1 : A ‚Üí+* B)  -> (commutes'_1 : ‚àÄ (r : R), OneHom.toFun (‚Üë‚ÜëtoRingHom_1) (‚Üë(algebraMap R A) r) = ‚Üë(algebraMap R B) r)  -> (a : toRingHom = toRingHom_1)  -> (h : toRingHom_1 = toRingHom)   -> toRingHom = toRingHom_1

{R : Type u} {A : Type v} {B : Type w} [CommSemiring R] [Semiring A] [Semiring B] [Algebra R A] [Algebra R B] (toRingHom : A ‚Üí+* B) (commutes' : ‚àÄ (r : R), OneHom.toFun (‚Üë‚ÜëtoRingHom) (‚Üë(algebraMap R A) r) = ‚Üë(algebraMap R B) r) (toRingHom_1 : A ‚Üí+* B) (commutes'_1 : ‚àÄ (r : R), OneHom.toFun (‚Üë‚ÜëtoRingHom_1) (‚Üë(algebraMap R A) r) = ‚Üë(algebraMap R B) r) (a : toRingHom = toRingHom_1)  : toRingHom_1 = toRingHom_1
type mismatch
  toRingHom_1
has type
  A ‚Üí+* B : Type (max v w)
but is expected to have type
  OneHom (?m.7330 toRingHom commutes' toRingHom_1 r)
    (?m.7326 toRingHom commutes' toRingHom_1 r) : Type (max ?u.3580 ?u.3579) ; identifiers [R, u, A, v, B, w, CommSemiring, R, Semiring, A, Semiring, B, Algebra, R, A, Algebra, R, B, toRingHom, A, B, commutes', r, R, OneHom.toFun, toRingHom, algebraMap, R, A, r, algebraMap, R, B, r, toRingHom_1, A, B, commutes'_1, r, R, OneHom.toFun, toRingHom_1, algebraMap, R, A, r, algebraMap, R, B, r, a, toRingHom, toRingHom_1, toRingHom_1, toRingHom_1] (during elaboration) for {R : Type u}  -> {A : Type v}  -> {B : Type w}  -> [CommSemiring R]  -> [Semiring A]  -> [Semiring B]  -> [Algebra R A]  -> [Algebra R B]  -> (toRingHom : A ‚Üí+* B)  -> (commutes' : ‚àÄ (r : R), OneHom.toFun (‚Üë‚ÜëtoRingHom) (‚Üë(algebraMap R A) r) = ‚Üë(algebraMap R B) r)  -> (toRingHom_1 : A ‚Üí+* B)  -> (commutes'_1 : ‚àÄ (r : R), OneHom.toFun (‚Üë‚ÜëtoRingHom_1) (‚Üë(algebraMap R A) r) = ‚Üë(algebraMap R B) r)  -> (a : toRingHom = toRingHom_1)   -> toRingHom_1 = toRingHom_1

{L : FirstOrder.Language} {M : Type w'} [FirstOrder.Language.IsOrdered L] [FirstOrder.Language.Structure L M] [LE M] [FirstOrder.Language.OrderedStructure L M] {a : M} {b : M}  : (FirstOrder.Language.Structure.RelMap FirstOrder.Language.leSymb ![a, b]) ‚Üî
  (FirstOrder.Language.Structure.RelMap FirstOrder.Language.leSymb ![a, b])
typeclass instance problem is stuck, it is often due to metavariables
  FirstOrder.Language.Structure ?m.268 M ; identifiers [L, FirstOrder.Language, M, w', FirstOrder.Language.IsOrdered, L, FirstOrder.Language.Structure, L, M, LE, M, FirstOrder.Language.OrderedStructure, L, M, a, M, b, M, FirstOrder.Language.Structure.RelMap, FirstOrder.Language.leSymb, a, b, FirstOrder.Language.Structure.RelMap, FirstOrder.Language.leSymb, a, b] (during elaboration) for {L : FirstOrder.Language}  -> {M : Type w'}  -> [FirstOrder.Language.IsOrdered L]  -> [FirstOrder.Language.Structure L M]  -> [LE M]  -> [FirstOrder.Language.OrderedStructure L M]  -> {a : M}  -> {b : M}   -> (FirstOrder.Language.Structure.RelMap FirstOrder.Language.leSymb ![a, b]) ‚Üî
  (FirstOrder.Language.Structure.RelMap FirstOrder.Language.leSymb ![a, b])

{Œ± : Type u_1} {a : Œ±} {b : Œ±}  : ((¬¨(a ‚àà {b})) ‚Üî (a ‚â† b)) = ((¬¨(a ‚àà {b})) ‚Üî (a ‚â† b))
typeclass instance problem is stuck, it is often due to metavariables
  Singleton Œ± ?m.931 ; identifiers [Œ±, u_1, a, Œ±, b, Œ±, a, b, b, a, b, a, b, b, a, b] (during elaboration) for {Œ± : Type u_1}  -> {a : Œ±}  -> {b : Œ±}   -> ((¬¨(a ‚àà {b})) ‚Üî (a ‚â† b)) = ((¬¨(a ‚àà {b})) ‚Üî (a ‚â† b))

 : (‚àÄ {Œπ : Type uŒπ} {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] [inst_2 : FiniteDimensional ‚Ñù E]
  {H : Type uH} [inst_3 : TopologicalSpace H] {I : ModelWithCorners ‚Ñù E H} {M : Type uM} [inst_4 : TopologicalSpace M]
  [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] {s : Set M} [inst_7 : T2Space M]
  {f : SmoothBumpCovering Œπ I M s} {U : (a : M) ‚Üí Set M},
  (BumpCovering.IsSubordinate (SmoothBumpCovering.toBumpCovering f) fun (i : Œπ) ‚Ü¶ U (SmoothBumpCovering.c s f i)) ‚Üî
    (SmoothBumpCovering.IsSubordinate f U))
unknown universe level 'uH' ; identifiers [Œπ, uŒπ, E, uE, inst, NormedAddCommGroup, E, inst_1, NormedSpace, E, inst_2, FiniteDimensional, E, H, uH, inst_3, TopologicalSpace, H, I, ModelWithCorners, E, H, M, uM, inst_4, TopologicalSpace, M, inst_5, ChartedSpace, H, M, inst_6, SmoothManifoldWithCorners, I, M, s, Set, M, inst_7, T2Space, M, f, SmoothBumpCovering, Œπ, I, M, s, U, a, M, Set, M, BumpCovering.IsSubordinate, SmoothBumpCovering.toBumpCovering, f, i, Œπ, U, SmoothBumpCovering.c, s, f, i, SmoothBumpCovering.IsSubordinate, f, U] (during elaboration) for (‚àÄ {Œπ : Type uŒπ} {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] [inst_2 : FiniteDimensional ‚Ñù E]
  {H : Type uH} [inst_3 : TopologicalSpace H] {I : ModelWithCorners ‚Ñù E H} {M : Type uM} [inst_4 : TopologicalSpace M]
  [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] {s : Set M} [inst_7 : T2Space M]
  {f : SmoothBumpCovering Œπ I M s} {U : (a : M) ‚Üí Set M},
  (BumpCovering.IsSubordinate (SmoothBumpCovering.toBumpCovering f) fun (i : Œπ) ‚Ü¶ U (SmoothBumpCovering.c s f i)) ‚Üî
    (SmoothBumpCovering.IsSubordinate f U))

 : ‚àÄ {Œπ : Type uŒπ} {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] [inst_2 : FiniteDimensional ‚Ñù E]
  {H : Type uH} [inst_3 : TopologicalSpace H] {I : ModelWithCorners ‚Ñù E H} {M : Type uM} [inst_4 : TopologicalSpace M]
  [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] {s : Set M} [inst_7 : T2Space M]
  {f : SmoothBumpCovering Œπ I M s} {U : (a : M) ‚Üí Set M},
  (BumpCovering.IsSubordinate (SmoothBumpCovering.toBumpCovering f) fun (i : Œπ) ‚Ü¶ U (SmoothBumpCovering.c s f i)) ‚Üî
    (BumpCovering.IsSubordinate (SmoothBumpCovering.toBumpCovering f) fun (i : Œπ) ‚Ü¶ U (SmoothBumpCovering.c s f i))
unknown universe level 'uH' ; identifiers [Œπ, uŒπ, E, uE, inst, NormedAddCommGroup, E, inst_1, NormedSpace, E, inst_2, FiniteDimensional, E, H, uH, inst_3, TopologicalSpace, H, I, ModelWithCorners, E, H, M, uM, inst_4, TopologicalSpace, M, inst_5, ChartedSpace, H, M, inst_6, SmoothManifoldWithCorners, I, M, s, Set, M, inst_7, T2Space, M, f, SmoothBumpCovering, Œπ, I, M, s, U, a, M, Set, M, BumpCovering.IsSubordinate, SmoothBumpCovering.toBumpCovering, f, i, Œπ, U, SmoothBumpCovering.c, s, f, i, BumpCovering.IsSubordinate, SmoothBumpCovering.toBumpCovering, f, i, Œπ, U, SmoothBumpCovering.c, s, f, i] (during elaboration) for ‚àÄ {Œπ : Type uŒπ} {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] [inst_2 : FiniteDimensional ‚Ñù E]
  {H : Type uH} [inst_3 : TopologicalSpace H] {I : ModelWithCorners ‚Ñù E H} {M : Type uM} [inst_4 : TopologicalSpace M]
  [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] {s : Set M} [inst_7 : T2Space M]
  {f : SmoothBumpCovering Œπ I M s} {U : (a : M) ‚Üí Set M},
  (BumpCovering.IsSubordinate (SmoothBumpCovering.toBumpCovering f) fun (i : Œπ) ‚Ü¶ U (SmoothBumpCovering.c s f i)) ‚Üî
    (BumpCovering.IsSubordinate (SmoothBumpCovering.toBumpCovering f) fun (i : Œπ) ‚Ü¶ U (SmoothBumpCovering.c s f i))

{ùïú : Type u_2} {E : Type u_1} [IsROrC ùïú] [NormedAddCommGroup E] [InnerProductSpace ùïú E] (x : E)  : ((x ‚àà ‚ä§·óÆ) ‚Üî (x ‚àà ‚ä•)) = ((x ‚àà ‚ä§·óÆ) ‚Üî (x ‚àà ‚ä•))
typeclass instance problem is stuck, it is often due to metavariables
  Membership E (?m.3858 x) ; identifiers [ùïú, u_2, E, u_1, IsROrC, ùïú, NormedAddCommGroup, E, InnerProductSpace, ùïú, E, x, E, x, x, x, x] (during elaboration) for {ùïú : Type u_2}  -> {E : Type u_1}  -> [IsROrC ùïú]  -> [NormedAddCommGroup E]  -> [InnerProductSpace ùïú E]  -> (x : E)   -> ((x ‚àà ‚ä§·óÆ) ‚Üî (x ‚àà ‚ä•)) = ((x ‚àà ‚ä§·óÆ) ‚Üî (x ‚àà ‚ä•))

{ùïú : Type u_2} {E : Type u_1} [IsROrC ùïú] [NormedAddCommGroup E] [InnerProductSpace ùïú E] (x : E)  : ((x ‚àà ‚ä§·óÆ) ‚Üî (x = 0)) = ((x ‚àà ‚ä§·óÆ) ‚Üî (x = 0))
typeclass instance problem is stuck, it is often due to metavariables
  InnerProductSpace (?m.2643 x) E ; identifiers [ùïú, u_2, E, u_1, IsROrC, ùïú, NormedAddCommGroup, E, InnerProductSpace, ùïú, E, x, E, x, x, x, x] (during elaboration) for {ùïú : Type u_2}  -> {E : Type u_1}  -> [IsROrC ùïú]  -> [NormedAddCommGroup E]  -> [InnerProductSpace ùïú E]  -> (x : E)   -> ((x ‚àà ‚ä§·óÆ) ‚Üî (x = 0)) = ((x ‚àà ‚ä§·óÆ) ‚Üî (x = 0))

{ùïú : Type u_1} {E : Type u_2} [SeminormedRing ùïú] [SMul ùïú E] {s : Set E} {t : Set E} (ht : Balanced ùïú t) (h : s ‚äÜ t) ‚¶Éx : E‚¶Ñ (hx : x ‚àà balancedHull ùïú s) (r : ùïú) (h_1 : ‚àÉ (x_1 : ‚Äñr‚Äñ ‚â§ 1), x ‚àà r ‚Ä¢ s) (hr : ‚Äñr‚Äñ ‚â§ 1) (h_2 : x ‚àà r ‚Ä¢ s) (y : E) (h_3 : (y ‚àà s) ‚àß ((fun (x : E) ‚Ü¶ r ‚Ä¢ x) y = x)) (hy : y ‚àà s) (right : (fun (x : E) ‚Ü¶ r ‚Ä¢ x) y = x) (hx : (fun (x : E) ‚Ü¶ r ‚Ä¢ x) y ‚àà balancedHull ùïú s)  : y ‚àà t
failed to synthesize instance
  HSMul ùïú (Set E) ?m.614 ; identifiers [ùïú, u_1, E, u_2, SeminormedRing, ùïú, SMul, ùïú, E, s, Set, E, t, Set, E, ht, Balanced, ùïú, t, h, s, t, x, E, hx, x, balancedHull, ùïú, s, r, ùïú, h_1, x_1, r, x, r, s, hr, r, h_2, x, r, s, y, E, h_3, y, s, x, E, r, x, y, x, hy, y, s, right, x, E, r, x, y, x, hx, x, E, r, x, y, balancedHull, ùïú, s, y, t] (during elaboration) for {ùïú : Type u_1}  -> {E : Type u_2}  -> [SeminormedRing ùïú]  -> [SMul ùïú E]  -> {s : Set E}  -> {t : Set E}  -> (ht : Balanced ùïú t)  -> (h : s ‚äÜ t)  -> ‚¶Éx : E‚¶Ñ  -> (hx : x ‚àà balancedHull ùïú s)  -> (r : ùïú)  -> (h_1 : ‚àÉ (x_1 : ‚Äñr‚Äñ ‚â§ 1), x ‚àà r ‚Ä¢ s)  -> (hr : ‚Äñr‚Äñ ‚â§ 1)  -> (h_2 : x ‚àà r ‚Ä¢ s)  -> (y : E)  -> (h_3 : (y ‚àà s) ‚àß ((fun (x : E) ‚Ü¶ r ‚Ä¢ x) y = x))  -> (hy : y ‚àà s)  -> (right : (fun (x : E) ‚Ü¶ r ‚Ä¢ x) y = x)  -> (hx : (fun (x : E) ‚Ü¶ r ‚Ä¢ x) y ‚àà balancedHull ùïú s)   -> y ‚àà t

{Œ± : Type u_2} {m0 : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {Œ≥ : Type u_1} (f : (a : Œ±) ‚Üí Œ≥) (g : (a : Œ±) ‚Üí Œ≥) (s : Set Œ±) (hs_zero : ‚Üë‚ÜëŒº s = 0) (h_ss : s·∂ú ‚äÜ {a : Œ± | (if (a ‚àà s) then f a else g a) = g a}) {Œ± : Type u_2} [HasSubset Œ±] (a : Œ±) (a_1 : Œ±) (e_a : a = a_1) (a_2 : Œ±) (a_3 : Œ±) (e_a : a_2 = a_3)  : (a ‚äÜ a_2) = (a ‚äÜ a_2)
failed to synthesize instance
  Decidable (a ‚àà s) ; identifiers [Œ±, u_2, m0, MeasurableSpace, Œ±, Œº, MeasureTheory.Measure, Œ±, Œ≥, u_1, f, a, Œ±, Œ≥, g, a, Œ±, Œ≥, s, Set, Œ±, hs_zero, Œº, s, h_ss, s, a, Œ±, a, s, f, a, g, a, g, a, Œ±, u_2, HasSubset, Œ±, a, Œ±, a_1, Œ±, e_a, a, a_1, a_2, Œ±, a_3, Œ±, e_a, a_2, a_3, a, a_2, a, a_2] (during elaboration) for {Œ± : Type u_2}  -> {m0 : MeasurableSpace Œ±}  -> {Œº : MeasureTheory.Measure Œ±}  -> {Œ≥ : Type u_1}  -> (f : (a : Œ±) ‚Üí Œ≥)  -> (g : (a : Œ±) ‚Üí Œ≥)  -> (s : Set Œ±)  -> (hs_zero : ‚Üë‚ÜëŒº s = 0)  -> (h_ss : s·∂ú ‚äÜ {a : Œ± | (if (a ‚àà s) then f a else g a) = g a})  -> {Œ± : Type u_2}  -> [HasSubset Œ±]  -> (a : Œ±)  -> (a_1 : Œ±)  -> (e_a : a = a_1)  -> (a_2 : Œ±)  -> (a_3 : Œ±)  -> (e_a : a_2 = a_3)   -> (a ‚äÜ a_2) = (a ‚äÜ a_2)

{Œ± : Type u_2} {m0 : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {Œ≥ : Type u_1} (f : (a : Œ±) ‚Üí Œ≥) (g : (a : Œ±) ‚Üí Œ≥) (s : Set Œ±) (hs_zero : ‚Üë‚ÜëŒº s = 0) (h_ss : s·∂ú ‚äÜ {a : Œ± | (if (a ‚àà s) then f a else g a) = g a})  : s = s
failed to synthesize instance
  Decidable (a ‚àà s) ; identifiers [Œ±, u_2, m0, MeasurableSpace, Œ±, Œº, MeasureTheory.Measure, Œ±, Œ≥, u_1, f, a, Œ±, Œ≥, g, a, Œ±, Œ≥, s, Set, Œ±, hs_zero, Œº, s, h_ss, s, a, Œ±, a, s, f, a, g, a, g, a, s, s] (during elaboration) for {Œ± : Type u_2}  -> {m0 : MeasurableSpace Œ±}  -> {Œº : MeasureTheory.Measure Œ±}  -> {Œ≥ : Type u_1}  -> (f : (a : Œ±) ‚Üí Œ≥)  -> (g : (a : Œ±) ‚Üí Œ≥)  -> (s : Set Œ±)  -> (hs_zero : ‚Üë‚ÜëŒº s = 0)  -> (h_ss : s·∂ú ‚äÜ {a : Œ± | (if (a ‚àà s) then f a else g a) = g a})   -> s = s

{Œ± : Type u_2} {m0 : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {Œ≥ : Type u_1} (f : (a : Œ±) ‚Üí Œ≥) (g : (a : Œ±) ‚Üí Œ≥) (s : Set Œ±) (hs_zero : ‚Üë‚ÜëŒº s = 0) (h_ss : s·∂ú ‚äÜ {a : Œ± | (if (a ‚àà s) then f a else g a) = g a})  : s·∂ú·∂ú = s·∂ú·∂ú
failed to synthesize instance
  Decidable (a ‚àà s) ; identifiers [Œ±, u_2, m0, MeasurableSpace, Œ±, Œº, MeasureTheory.Measure, Œ±, Œ≥, u_1, f, a, Œ±, Œ≥, g, a, Œ±, Œ≥, s, Set, Œ±, hs_zero, Œº, s, h_ss, s, a, Œ±, a, s, f, a, g, a, g, a, s, s] (during elaboration) for {Œ± : Type u_2}  -> {m0 : MeasurableSpace Œ±}  -> {Œº : MeasureTheory.Measure Œ±}  -> {Œ≥ : Type u_1}  -> (f : (a : Œ±) ‚Üí Œ≥)  -> (g : (a : Œ±) ‚Üí Œ≥)  -> (s : Set Œ±)  -> (hs_zero : ‚Üë‚ÜëŒº s = 0)  -> (h_ss : s·∂ú ‚äÜ {a : Œ± | (if (a ‚àà s) then f a else g a) = g a})   -> s·∂ú·∂ú = s·∂ú·∂ú

{C : Type u_2} [CategoryTheory.Category C] {X : C} {Y : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Y} {s : CategoryTheory.Limits.Fork f g} {t : CategoryTheory.Limits.Fork f g} (i : CategoryTheory.Limits.Cone.pt s ‚âÖ CategoryTheory.Limits.Cone.pt t) (w : autoParam (CategoryTheory.CategoryStruct.comp i.hom (CategoryTheory.Limits.Fork.Œπ t) = CategoryTheory.Limits.Fork.Œπ s)
  _auto‚úù)  : CategoryTheory.Limits.Fork.Œπ s = CategoryTheory.CategoryStruct.comp i.hom (CategoryTheory.Limits.Fork.Œπ t)
<input>:2:7: expected token

{ùïú : Type u_2} {E : Type u_1} [OrderedSemiring ùïú] [AddCommGroup E] [Module ùïú E] {s : Set E} (hc : ‚àÄ (t : Set E) (a : t ‚äÜ s), s ‚à© ‚Üë(convexHull ùïú) t ‚äÜ t) (t : Set { x : E // x ‚àà s }) (x : { x : E // x ‚àà s }) (h : ‚Üëx ‚àà ‚Üë(convexHull ùïú) (Subtype.val '' t))  : (x ‚àà t) = (x ‚àà t)
type mismatch
  x
has type
  { x // x ‚àà s } : Type u_1
but is expected to have type
  ?m.1136 hc t x : outParam (Type ?u.845) ; identifiers [ùïú, u_2, E, u_1, OrderedSemiring, ùïú, AddCommGroup, E, Module, ùïú, E, s, Set, E, hc, t, Set, E, a, t, s, s, convexHull, ùïú, t, t, t, Set, x, E, x, s, x, x, E, x, s, h, x, convexHull, ùïú, Subtype.val, t, x, t, x, t] (during elaboration) for {ùïú : Type u_2}  -> {E : Type u_1}  -> [OrderedSemiring ùïú]  -> [AddCommGroup E]  -> [Module ùïú E]  -> {s : Set E}  -> (hc : ‚àÄ (t : Set E) (a : t ‚äÜ s), s ‚à© ‚Üë(convexHull ùïú) t ‚äÜ t)  -> (t : Set { x : E // x ‚àà s })  -> (x : { x : E // x ‚àà s })  -> (h : ‚Üëx ‚àà ‚Üë(convexHull ùïú) (Subtype.val '' t))   -> (x ‚àà t) = (x ‚àà t)

{L : FirstOrder.Language} {M : Type w'} [FirstOrder.Language.IsOrdered L] [FirstOrder.Language.Structure L M] [LE M] [FirstOrder.Language.OrderedStructure L M] {a : M} {b : M}  : (FirstOrder.Language.Structure.RelMap FirstOrder.Language.leSymb ![a, b]) ‚Üî
  (FirstOrder.Language.Structure.RelMap FirstOrder.Language.leSymb ![a, b])
typeclass instance problem is stuck, it is often due to metavariables
  FirstOrder.Language.Structure ?m.268 M ; identifiers [L, FirstOrder.Language, M, w', FirstOrder.Language.IsOrdered, L, FirstOrder.Language.Structure, L, M, LE, M, FirstOrder.Language.OrderedStructure, L, M, a, M, b, M, FirstOrder.Language.Structure.RelMap, FirstOrder.Language.leSymb, a, b, FirstOrder.Language.Structure.RelMap, FirstOrder.Language.leSymb, a, b] (during elaboration) for {L : FirstOrder.Language}  -> {M : Type w'}  -> [FirstOrder.Language.IsOrdered L]  -> [FirstOrder.Language.Structure L M]  -> [LE M]  -> [FirstOrder.Language.OrderedStructure L M]  -> {a : M}  -> {b : M}   -> (FirstOrder.Language.Structure.RelMap FirstOrder.Language.leSymb ![a, b]) ‚Üî
  (FirstOrder.Language.Structure.RelMap FirstOrder.Language.leSymb ![a, b])

{Œ± : Type u_1} {a : Œ±} {b : Œ±}  : ((¬¨(a ‚àà {b})) ‚Üî (a ‚â† b)) = ((¬¨(a ‚àà {b})) ‚Üî (a ‚â† b))
typeclass instance problem is stuck, it is often due to metavariables
  Singleton Œ± ?m.931 ; identifiers [Œ±, u_1, a, Œ±, b, Œ±, a, b, b, a, b, a, b, b, a, b] (during elaboration) for {Œ± : Type u_1}  -> {a : Œ±}  -> {b : Œ±}   -> ((¬¨(a ‚àà {b})) ‚Üî (a ‚â† b)) = ((¬¨(a ‚àà {b})) ‚Üî (a ‚â† b))

 : (‚àÄ {Œπ : Type uŒπ} {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] [inst_2 : FiniteDimensional ‚Ñù E]
  {H : Type uH} [inst_3 : TopologicalSpace H] {I : ModelWithCorners ‚Ñù E H} {M : Type uM} [inst_4 : TopologicalSpace M]
  [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] {s : Set M} [inst_7 : T2Space M]
  {f : SmoothBumpCovering Œπ I M s} {U : (a : M) ‚Üí Set M},
  (BumpCovering.IsSubordinate (SmoothBumpCovering.toBumpCovering f) fun (i : Œπ) ‚Ü¶ U (SmoothBumpCovering.c s f i)) ‚Üî
    (SmoothBumpCovering.IsSubordinate f U))
unknown universe level 'uH' ; identifiers [Œπ, uŒπ, E, uE, inst, NormedAddCommGroup, E, inst_1, NormedSpace, E, inst_2, FiniteDimensional, E, H, uH, inst_3, TopologicalSpace, H, I, ModelWithCorners, E, H, M, uM, inst_4, TopologicalSpace, M, inst_5, ChartedSpace, H, M, inst_6, SmoothManifoldWithCorners, I, M, s, Set, M, inst_7, T2Space, M, f, SmoothBumpCovering, Œπ, I, M, s, U, a, M, Set, M, BumpCovering.IsSubordinate, SmoothBumpCovering.toBumpCovering, f, i, Œπ, U, SmoothBumpCovering.c, s, f, i, SmoothBumpCovering.IsSubordinate, f, U] (during elaboration) for (‚àÄ {Œπ : Type uŒπ} {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] [inst_2 : FiniteDimensional ‚Ñù E]
  {H : Type uH} [inst_3 : TopologicalSpace H] {I : ModelWithCorners ‚Ñù E H} {M : Type uM} [inst_4 : TopologicalSpace M]
  [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] {s : Set M} [inst_7 : T2Space M]
  {f : SmoothBumpCovering Œπ I M s} {U : (a : M) ‚Üí Set M},
  (BumpCovering.IsSubordinate (SmoothBumpCovering.toBumpCovering f) fun (i : Œπ) ‚Ü¶ U (SmoothBumpCovering.c s f i)) ‚Üî
    (SmoothBumpCovering.IsSubordinate f U))

 : ‚àÄ {Œπ : Type uŒπ} {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] [inst_2 : FiniteDimensional ‚Ñù E]
  {H : Type uH} [inst_3 : TopologicalSpace H] {I : ModelWithCorners ‚Ñù E H} {M : Type uM} [inst_4 : TopologicalSpace M]
  [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] {s : Set M} [inst_7 : T2Space M]
  {f : SmoothBumpCovering Œπ I M s} {U : (a : M) ‚Üí Set M},
  (BumpCovering.IsSubordinate (SmoothBumpCovering.toBumpCovering f) fun (i : Œπ) ‚Ü¶ U (SmoothBumpCovering.c s f i)) ‚Üî
    (BumpCovering.IsSubordinate (SmoothBumpCovering.toBumpCovering f) fun (i : Œπ) ‚Ü¶ U (SmoothBumpCovering.c s f i))
unknown universe level 'uH' ; identifiers [Œπ, uŒπ, E, uE, inst, NormedAddCommGroup, E, inst_1, NormedSpace, E, inst_2, FiniteDimensional, E, H, uH, inst_3, TopologicalSpace, H, I, ModelWithCorners, E, H, M, uM, inst_4, TopologicalSpace, M, inst_5, ChartedSpace, H, M, inst_6, SmoothManifoldWithCorners, I, M, s, Set, M, inst_7, T2Space, M, f, SmoothBumpCovering, Œπ, I, M, s, U, a, M, Set, M, BumpCovering.IsSubordinate, SmoothBumpCovering.toBumpCovering, f, i, Œπ, U, SmoothBumpCovering.c, s, f, i, BumpCovering.IsSubordinate, SmoothBumpCovering.toBumpCovering, f, i, Œπ, U, SmoothBumpCovering.c, s, f, i] (during elaboration) for ‚àÄ {Œπ : Type uŒπ} {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] [inst_2 : FiniteDimensional ‚Ñù E]
  {H : Type uH} [inst_3 : TopologicalSpace H] {I : ModelWithCorners ‚Ñù E H} {M : Type uM} [inst_4 : TopologicalSpace M]
  [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] {s : Set M} [inst_7 : T2Space M]
  {f : SmoothBumpCovering Œπ I M s} {U : (a : M) ‚Üí Set M},
  (BumpCovering.IsSubordinate (SmoothBumpCovering.toBumpCovering f) fun (i : Œπ) ‚Ü¶ U (SmoothBumpCovering.c s f i)) ‚Üî
    (BumpCovering.IsSubordinate (SmoothBumpCovering.toBumpCovering f) fun (i : Œπ) ‚Ü¶ U (SmoothBumpCovering.c s f i))

{ùïú : Type u_2} {E : Type u_1} [IsROrC ùïú] [NormedAddCommGroup E] [InnerProductSpace ùïú E] (x : E)  : ((x ‚àà ‚ä§·óÆ) ‚Üî (x ‚àà ‚ä•)) = ((x ‚àà ‚ä§·óÆ) ‚Üî (x ‚àà ‚ä•))
typeclass instance problem is stuck, it is often due to metavariables
  Membership E (?m.3858 x) ; identifiers [ùïú, u_2, E, u_1, IsROrC, ùïú, NormedAddCommGroup, E, InnerProductSpace, ùïú, E, x, E, x, x, x, x] (during elaboration) for {ùïú : Type u_2}  -> {E : Type u_1}  -> [IsROrC ùïú]  -> [NormedAddCommGroup E]  -> [InnerProductSpace ùïú E]  -> (x : E)   -> ((x ‚àà ‚ä§·óÆ) ‚Üî (x ‚àà ‚ä•)) = ((x ‚àà ‚ä§·óÆ) ‚Üî (x ‚àà ‚ä•))

{ùïú : Type u_2} {E : Type u_1} [IsROrC ùïú] [NormedAddCommGroup E] [InnerProductSpace ùïú E] (x : E)  : ((x ‚àà ‚ä§·óÆ) ‚Üî (x = 0)) = ((x ‚àà ‚ä§·óÆ) ‚Üî (x = 0))
typeclass instance problem is stuck, it is often due to metavariables
  InnerProductSpace (?m.2643 x) E ; identifiers [ùïú, u_2, E, u_1, IsROrC, ùïú, NormedAddCommGroup, E, InnerProductSpace, ùïú, E, x, E, x, x, x, x] (during elaboration) for {ùïú : Type u_2}  -> {E : Type u_1}  -> [IsROrC ùïú]  -> [NormedAddCommGroup E]  -> [InnerProductSpace ùïú E]  -> (x : E)   -> ((x ‚àà ‚ä§·óÆ) ‚Üî (x = 0)) = ((x ‚àà ‚ä§·óÆ) ‚Üî (x = 0))

{ùïú : Type u_1} {E : Type u_2} [SeminormedRing ùïú] [SMul ùïú E] {s : Set E} {t : Set E} (ht : Balanced ùïú t) (h : s ‚äÜ t) ‚¶Éx : E‚¶Ñ (hx : x ‚àà balancedHull ùïú s) (r : ùïú) (h_1 : ‚àÉ (x_1 : ‚Äñr‚Äñ ‚â§ 1), x ‚àà r ‚Ä¢ s) (hr : ‚Äñr‚Äñ ‚â§ 1) (h_2 : x ‚àà r ‚Ä¢ s) (y : E) (h_3 : (y ‚àà s) ‚àß ((fun (x : E) ‚Ü¶ r ‚Ä¢ x) y = x)) (hy : y ‚àà s) (right : (fun (x : E) ‚Ü¶ r ‚Ä¢ x) y = x) (hx : (fun (x : E) ‚Ü¶ r ‚Ä¢ x) y ‚àà balancedHull ùïú s)  : y ‚àà t
failed to synthesize instance
  HSMul ùïú (Set E) ?m.614 ; identifiers [ùïú, u_1, E, u_2, SeminormedRing, ùïú, SMul, ùïú, E, s, Set, E, t, Set, E, ht, Balanced, ùïú, t, h, s, t, x, E, hx, x, balancedHull, ùïú, s, r, ùïú, h_1, x_1, r, x, r, s, hr, r, h_2, x, r, s, y, E, h_3, y, s, x, E, r, x, y, x, hy, y, s, right, x, E, r, x, y, x, hx, x, E, r, x, y, balancedHull, ùïú, s, y, t] (during elaboration) for {ùïú : Type u_1}  -> {E : Type u_2}  -> [SeminormedRing ùïú]  -> [SMul ùïú E]  -> {s : Set E}  -> {t : Set E}  -> (ht : Balanced ùïú t)  -> (h : s ‚äÜ t)  -> ‚¶Éx : E‚¶Ñ  -> (hx : x ‚àà balancedHull ùïú s)  -> (r : ùïú)  -> (h_1 : ‚àÉ (x_1 : ‚Äñr‚Äñ ‚â§ 1), x ‚àà r ‚Ä¢ s)  -> (hr : ‚Äñr‚Äñ ‚â§ 1)  -> (h_2 : x ‚àà r ‚Ä¢ s)  -> (y : E)  -> (h_3 : (y ‚àà s) ‚àß ((fun (x : E) ‚Ü¶ r ‚Ä¢ x) y = x))  -> (hy : y ‚àà s)  -> (right : (fun (x : E) ‚Ü¶ r ‚Ä¢ x) y = x)  -> (hx : (fun (x : E) ‚Ü¶ r ‚Ä¢ x) y ‚àà balancedHull ùïú s)   -> y ‚àà t

{Œ± : Type u_2} {m0 : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {Œ≥ : Type u_1} (f : (a : Œ±) ‚Üí Œ≥) (g : (a : Œ±) ‚Üí Œ≥) (s : Set Œ±) (hs_zero : ‚Üë‚ÜëŒº s = 0) (h_ss : s·∂ú ‚äÜ {a : Œ± | (if (a ‚àà s) then f a else g a) = g a}) {Œ± : Type u_2} [HasSubset Œ±] (a : Œ±) (a_1 : Œ±) (e_a : a = a_1) (a_2 : Œ±) (a_3 : Œ±) (e_a : a_2 = a_3)  : (a ‚äÜ a_2) = (a ‚äÜ a_2)
failed to synthesize instance
  Decidable (a ‚àà s) ; identifiers [Œ±, u_2, m0, MeasurableSpace, Œ±, Œº, MeasureTheory.Measure, Œ±, Œ≥, u_1, f, a, Œ±, Œ≥, g, a, Œ±, Œ≥, s, Set, Œ±, hs_zero, Œº, s, h_ss, s, a, Œ±, a, s, f, a, g, a, g, a, Œ±, u_2, HasSubset, Œ±, a, Œ±, a_1, Œ±, e_a, a, a_1, a_2, Œ±, a_3, Œ±, e_a, a_2, a_3, a, a_2, a, a_2] (during elaboration) for {Œ± : Type u_2}  -> {m0 : MeasurableSpace Œ±}  -> {Œº : MeasureTheory.Measure Œ±}  -> {Œ≥ : Type u_1}  -> (f : (a : Œ±) ‚Üí Œ≥)  -> (g : (a : Œ±) ‚Üí Œ≥)  -> (s : Set Œ±)  -> (hs_zero : ‚Üë‚ÜëŒº s = 0)  -> (h_ss : s·∂ú ‚äÜ {a : Œ± | (if (a ‚àà s) then f a else g a) = g a})  -> {Œ± : Type u_2}  -> [HasSubset Œ±]  -> (a : Œ±)  -> (a_1 : Œ±)  -> (e_a : a = a_1)  -> (a_2 : Œ±)  -> (a_3 : Œ±)  -> (e_a : a_2 = a_3)   -> (a ‚äÜ a_2) = (a ‚äÜ a_2)

{Œ± : Type u_2} {m0 : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {Œ≥ : Type u_1} (f : (a : Œ±) ‚Üí Œ≥) (g : (a : Œ±) ‚Üí Œ≥) (s : Set Œ±) (hs_zero : ‚Üë‚ÜëŒº s = 0) (h_ss : s·∂ú ‚äÜ {a : Œ± | (if (a ‚àà s) then f a else g a) = g a})  : s = s
failed to synthesize instance
  Decidable (a ‚àà s) ; identifiers [Œ±, u_2, m0, MeasurableSpace, Œ±, Œº, MeasureTheory.Measure, Œ±, Œ≥, u_1, f, a, Œ±, Œ≥, g, a, Œ±, Œ≥, s, Set, Œ±, hs_zero, Œº, s, h_ss, s, a, Œ±, a, s, f, a, g, a, g, a, s, s] (during elaboration) for {Œ± : Type u_2}  -> {m0 : MeasurableSpace Œ±}  -> {Œº : MeasureTheory.Measure Œ±}  -> {Œ≥ : Type u_1}  -> (f : (a : Œ±) ‚Üí Œ≥)  -> (g : (a : Œ±) ‚Üí Œ≥)  -> (s : Set Œ±)  -> (hs_zero : ‚Üë‚ÜëŒº s = 0)  -> (h_ss : s·∂ú ‚äÜ {a : Œ± | (if (a ‚àà s) then f a else g a) = g a})   -> s = s

{Œ± : Type u_2} {m0 : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {Œ≥ : Type u_1} (f : (a : Œ±) ‚Üí Œ≥) (g : (a : Œ±) ‚Üí Œ≥) (s : Set Œ±) (hs_zero : ‚Üë‚ÜëŒº s = 0) (h_ss : s·∂ú ‚äÜ {a : Œ± | (if (a ‚àà s) then f a else g a) = g a})  : s·∂ú·∂ú = s·∂ú·∂ú
failed to synthesize instance
  Decidable (a ‚àà s) ; identifiers [Œ±, u_2, m0, MeasurableSpace, Œ±, Œº, MeasureTheory.Measure, Œ±, Œ≥, u_1, f, a, Œ±, Œ≥, g, a, Œ±, Œ≥, s, Set, Œ±, hs_zero, Œº, s, h_ss, s, a, Œ±, a, s, f, a, g, a, g, a, s, s] (during elaboration) for {Œ± : Type u_2}  -> {m0 : MeasurableSpace Œ±}  -> {Œº : MeasureTheory.Measure Œ±}  -> {Œ≥ : Type u_1}  -> (f : (a : Œ±) ‚Üí Œ≥)  -> (g : (a : Œ±) ‚Üí Œ≥)  -> (s : Set Œ±)  -> (hs_zero : ‚Üë‚ÜëŒº s = 0)  -> (h_ss : s·∂ú ‚äÜ {a : Œ± | (if (a ‚àà s) then f a else g a) = g a})   -> s·∂ú·∂ú = s·∂ú·∂ú

{C : Type u_2} [CategoryTheory.Category C] {X : C} {Y : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Y} {s : CategoryTheory.Limits.Fork f g} {t : CategoryTheory.Limits.Fork f g} (i : CategoryTheory.Limits.Cone.pt s ‚âÖ CategoryTheory.Limits.Cone.pt t) (w : autoParam (CategoryTheory.CategoryStruct.comp i.hom (CategoryTheory.Limits.Fork.Œπ t) = CategoryTheory.Limits.Fork.Œπ s)
  _auto‚úù)  : CategoryTheory.Limits.Fork.Œπ s = CategoryTheory.CategoryStruct.comp i.hom (CategoryTheory.Limits.Fork.Œπ t)
<input>:2:7: expected token

{ùïú : Type u_2} {E : Type u_1} [OrderedSemiring ùïú] [AddCommGroup E] [Module ùïú E] {s : Set E} (hc : ‚àÄ (t : Set E) (a : t ‚äÜ s), s ‚à© ‚Üë(convexHull ùïú) t ‚äÜ t) (t : Set { x : E // x ‚àà s }) (x : { x : E // x ‚àà s }) (h : ‚Üëx ‚àà ‚Üë(convexHull ùïú) (Subtype.val '' t))  : (x ‚àà t) = (x ‚àà t)
type mismatch
  x
has type
  { x // x ‚àà s } : Type u_1
but is expected to have type
  ?m.1136 hc t x : outParam (Type ?u.845) ; identifiers [ùïú, u_2, E, u_1, OrderedSemiring, ùïú, AddCommGroup, E, Module, ùïú, E, s, Set, E, hc, t, Set, E, a, t, s, s, convexHull, ùïú, t, t, t, Set, x, E, x, s, x, x, E, x, s, h, x, convexHull, ùïú, Subtype.val, t, x, t, x, t] (during elaboration) for {ùïú : Type u_2}  -> {E : Type u_1}  -> [OrderedSemiring ùïú]  -> [AddCommGroup E]  -> [Module ùïú E]  -> {s : Set E}  -> (hc : ‚àÄ (t : Set E) (a : t ‚äÜ s), s ‚à© ‚Üë(convexHull ùïú) t ‚äÜ t)  -> (t : Set { x : E // x ‚àà s })  -> (x : { x : E // x ‚àà s })  -> (h : ‚Üëx ‚àà ‚Üë(convexHull ùïú) (Subtype.val '' t))   -> (x ‚àà t) = (x ‚àà t)

 : (‚àÄ {Œπ : Type u_1} {V : Type u} [inst : CategoryTheory.Category V] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms V]
  {c : ComplexShape Œπ} {A : HomologicalComplex V c} {B : HomologicalComplex V c} [inst_2 : SizeOf Œπ] [inst_3 : SizeOf V]
  (f : (i : Œπ) ‚Üí HomologicalComplex.X A i ‚ü∂ HomologicalComplex.X B i)
  (comm' :
    autoParam
      (‚àÄ (i : Œπ) (j : Œπ) (a : ComplexShape.Rel c i j),
        CategoryTheory.CategoryStruct.comp (f i) (HomologicalComplex.d B i j) =
          CategoryTheory.CategoryStruct.comp (HomologicalComplex.d A i j) (f j))
      _auto‚úù),
  sizeOf (HomologicalComplex.Hom.mk f) = 1)
<input>:9:11: expected token

 : ‚àÄ {Œπ : Type u_1} {V : Type u} [inst : CategoryTheory.Category V] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms V]
  {c : ComplexShape Œπ} {A : HomologicalComplex V c} {B : HomologicalComplex V c} [inst_2 : SizeOf Œπ] [inst_3 : SizeOf V]
  (f : (i : Œπ) ‚Üí HomologicalComplex.X A i ‚ü∂ HomologicalComplex.X B i)
  (comm' :
    autoParam
      (‚àÄ (i : Œπ) (j : Œπ) (a : ComplexShape.Rel c i j),
        CategoryTheory.CategoryStruct.comp (f i) (HomologicalComplex.d B i j) =
          CategoryTheory.CategoryStruct.comp (HomologicalComplex.d A i j) (f j))
      _auto‚úù),
  1 = 1
<input>:9:11: expected token

{Œ± : Type u_1} {M : Type u_3} (R : Type u_2) [Semiring R] [AddCommMonoid M] [Module R M] {s : Finset Œ±} {f : (a : Œ±) ‚Üí R} (g : (a : Œ±) ‚Üí M) (hf : ‚àÄ (a : Œ±) (a_1 : f a ‚â† 0), a ‚àà s)  : ‚àÄ (x : Œ±) (a : x ‚àà Finset.filter (fun (a : Œ±) ‚Ü¶ f a ‚â† 0) s), f x ‚Ä¢ g x = f x ‚Ä¢ g x
failed to synthesize instance
  DecidablePred fun a => f a ‚â† 0 ; identifiers [Œ±, u_1, M, u_3, R, u_2, Semiring, R, AddCommMonoid, M, Module, R, M, s, Finset, Œ±, f, a, Œ±, R, g, a, Œ±, M, hf, a, Œ±, a_1, f, a, a, s, x, Œ±, a, x, Finset.filter, a, Œ±, f, a, s, f, x, g, x, f, x, g, x] (during elaboration) for {Œ± : Type u_1}  -> {M : Type u_3}  -> (R : Type u_2)  -> [Semiring R]  -> [AddCommMonoid M]  -> [Module R M]  -> {s : Finset Œ±}  -> {f : (a : Œ±) ‚Üí R}  -> (g : (a : Œ±) ‚Üí M)  -> (hf : ‚àÄ (a : Œ±) (a_1 : f a ‚â† 0), a ‚àà s)   -> ‚àÄ (x : Œ±) (a : x ‚àà Finset.filter (fun (a : Œ±) ‚Ü¶ f a ‚â† 0) s), f x ‚Ä¢ g x = f x ‚Ä¢ g x

{Œ± : Type u_1} (x : Subtype Setoid.IsPartition) (y : Subtype Setoid.IsPartition) (hx : x ‚â§ y) (hy : y ‚â§ x) (h : Setoid.mkClasses ‚Üëx (Setoid.Partition.le.proof_1 x) = Setoid.mkClasses ‚Üëy (Setoid.Partition.le.proof_2 y))  : (x = y) = (x = y)
application type mismatch
  Setoid.mkClasses ?m.2267 (_ : ‚àÄ (a : ?m.5707), ‚àÉ! b x, a ‚àà b)
argument
  Setoid.Partition.le.proof_2 y
has type
  ‚àÄ (a : ?m.5707), ‚àÉ! b x, a ‚àà b : Prop
but is expected to have type
  ‚àÄ (a : ?m.5708 x y hx hy), ‚àÉ! b x_1, a ‚àà b : Prop ; identifiers [Œ±, u_1, x, Subtype, Setoid.IsPartition, y, Subtype, Setoid.IsPartition, hx, x, y, hy, y, x, h, Setoid.mkClasses, x, Setoid.Partition.le.proof_1, x, Setoid.mkClasses, y, Setoid.Partition.le.proof_2, y, x, y, x, y] (during elaboration) for {Œ± : Type u_1}  -> (x : Subtype Setoid.IsPartition)  -> (y : Subtype Setoid.IsPartition)  -> (hx : x ‚â§ y)  -> (hy : y ‚â§ x)  -> (h : Setoid.mkClasses ‚Üëx (Setoid.Partition.le.proof_1 x) = Setoid.mkClasses ‚Üëy (Setoid.Partition.le.proof_2 y))   -> (x = y) = (x = y)

{Œ± : Type u_1} (x : Subtype Setoid.IsPartition) (y : Subtype Setoid.IsPartition) (hx : x ‚â§ y) (hy : y ‚â§ x) (h : Setoid.mkClasses ‚Üëx (Setoid.Partition.le.proof_1 x) = Setoid.mkClasses ‚Üëy (Setoid.Partition.le.proof_2 y))  : (‚Üëx = ‚Üëy) = (‚Üëx = ‚Üëy)
type mismatch
  y
has type
  Subtype Setoid.IsPartition : Type ?u.8
but is expected to have type
  ?m.5928 x y hx hy h : Sort ?u.5682 ; identifiers [Œ±, u_1, x, Subtype, Setoid.IsPartition, y, Subtype, Setoid.IsPartition, hx, x, y, hy, y, x, h, Setoid.mkClasses, x, Setoid.Partition.le.proof_1, x, Setoid.mkClasses, y, Setoid.Partition.le.proof_2, y, x, y, x, y] (during elaboration) for {Œ± : Type u_1}  -> (x : Subtype Setoid.IsPartition)  -> (y : Subtype Setoid.IsPartition)  -> (hx : x ‚â§ y)  -> (hy : y ‚â§ x)  -> (h : Setoid.mkClasses ‚Üëx (Setoid.Partition.le.proof_1 x) = Setoid.mkClasses ‚Üëy (Setoid.Partition.le.proof_2 y))   -> (‚Üëx = ‚Üëy) = (‚Üëx = ‚Üëy)

{Œ± : Type u_1} [HeytingAlgebra Œ±]  : (‚ä•·∂ú = ‚ä§) = (‚ä•·∂ú = ‚ä§)
typeclass instance problem is stuck, it is often due to metavariables
  Top ?m.2795 ; identifiers [Œ±, u_1, HeytingAlgebra, Œ±] (during elaboration) for {Œ± : Type u_1}  -> [HeytingAlgebra Œ±]   -> (‚ä•·∂ú = ‚ä§) = (‚ä•·∂ú = ‚ä§)

{Œ± : Type u_1} [HeytingAlgebra Œ±]  : (‚ä• ‚á® ‚ä• = ‚ä§) = (‚ä• ‚á® ‚ä• = ‚ä§)
typeclass instance problem is stuck, it is often due to metavariables
  Top ?m.4000 ; identifiers [Œ±, u_1, HeytingAlgebra, Œ±] (during elaboration) for {Œ± : Type u_1}  -> [HeytingAlgebra Œ±]   -> (‚ä• ‚á® ‚ä• = ‚ä§) = (‚ä• ‚á® ‚ä• = ‚ä§)

{Œ± : Type u_1} [HeytingAlgebra Œ±]  : ‚ä§ = ‚ä§
typeclass instance problem is stuck, it is often due to metavariables
  Top ?m.701 ; identifiers [Œ±, u_1, HeytingAlgebra, Œ±] (during elaboration) for {Œ± : Type u_1}  -> [HeytingAlgebra Œ±]   -> ‚ä§ = ‚ä§

{Œ± : Type u} {Œ≤ : Type v} [Fintype Œ≤] (r : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Prop) [(a : Œ±) ‚Üí DecidablePred (r a)] (r' : (a : Œ±) ‚Üí Finset Œ≤ := fun (a : Œ±) ‚Ü¶ Finset.filter (fun (b : Œ≤) ‚Ü¶ r a b) Finset.univ) (h : ‚àÄ (A : Finset Œ±), Finset.filter (fun (b : Œ≤) ‚Ü¶ ‚àÉ (a : Œ±), (a ‚àà A) ‚àß (r a b)) Finset.univ = Finset.biUnion A r') (h' : ‚àÄ (f : (a : Œ±) ‚Üí Œ≤) (x : Œ±), (r x (f x)) ‚Üî (f x ‚àà r' x)) (A : Finset Œ±)  : ‚àÄ (A : Finset Œ±), Finset.filter (fun (b : Œ≤) ‚Ü¶ ‚àÉ (a : Œ±), (a ‚àà A) ‚àß (r a b)) Finset.univ = Finset.biUnion A r'
failed to synthesize instance
  DecidableEq Œ≤ ; identifiers [Œ±, u, Œ≤, v, Fintype, Œ≤, r, a, Œ±, a, Œ≤, a, Œ±, DecidablePred, r, a, r', a, Œ±, Finset, Œ≤, a, Œ±, Finset.filter, b, Œ≤, r, a, b, Finset.univ, h, A, Finset, Œ±, Finset.filter, b, Œ≤, a, Œ±, a, A, r, a, b, Finset.univ, Finset.biUnion, A, r', h', f, a, Œ±, Œ≤, x, Œ±, r, x, f, x, f, x, r', x, A, Finset, Œ±, A, Finset, Œ±, Finset.filter, b, Œ≤, a, Œ±, a, A, r, a, b, Finset.univ, Finset.biUnion, A, r'] (during elaboration) for {Œ± : Type u}  -> {Œ≤ : Type v}  -> [Fintype Œ≤]  -> (r : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Prop)  -> [(a : Œ±) ‚Üí DecidablePred (r a)]  -> (r' : (a : Œ±) ‚Üí Finset Œ≤ := fun (a : Œ±) ‚Ü¶ Finset.filter (fun (b : Œ≤) ‚Ü¶ r a b) Finset.univ)  -> (h : ‚àÄ (A : Finset Œ±), Finset.filter (fun (b : Œ≤) ‚Ü¶ ‚àÉ (a : Œ±), (a ‚àà A) ‚àß (r a b)) Finset.univ = Finset.biUnion A r')  -> (h' : ‚àÄ (f : (a : Œ±) ‚Üí Œ≤) (x : Œ±), (r x (f x)) ‚Üî (f x ‚àà r' x))  -> (A : Finset Œ±)   -> ‚àÄ (A : Finset Œ±), Finset.filter (fun (b : Œ≤) ‚Ü¶ ‚àÉ (a : Œ±), (a ‚àà A) ‚àß (r a b)) Finset.univ = Finset.biUnion A r'

{R : Type u_3} {S : Type u_1} [CommRing R] [CommRing S] (f : R ‚Üí+* S) {X : ModuleCat R} (x : ‚ÜëX) (x' : ‚ÜëX)  : (1 ‚äó‚Çú[R] (x + x') = 1 ‚äó‚Çú[R] x + 1 ‚äó‚Çú[R] x') = (1 ‚äó‚Çú[R] (x + x') = 1 ‚äó‚Çú[R] x + 1 ‚äó‚Çú[R] x')
type mismatch
  X
has type
  ModuleCat R : Type (max u_3 (?u.531 + 1))
but is expected to have type
  Sort ?u.661 : Type ?u.661 ; identifiers [R, u_3, S, u_1, CommRing, R, CommRing, S, f, R, S, X, ModuleCat, R, x, X, x', X, R, x, x', R, x, R, x', R, x, x', R, x, R, x'] (during elaboration) for {R : Type u_3}  -> {S : Type u_1}  -> [CommRing R]  -> [CommRing S]  -> (f : R ‚Üí+* S)  -> {X : ModuleCat R}  -> (x : ‚ÜëX)  -> (x' : ‚ÜëX)   -> (1 ‚äó‚Çú[R] (x + x') = 1 ‚äó‚Çú[R] x + 1 ‚äó‚Çú[R] x') = (1 ‚äó‚Çú[R] (x + x') = 1 ‚äó‚Çú[R] x + 1 ‚äó‚Çú[R] x')

{R : Type u_3} {S : Type u_1} [CommRing R] [CommRing S] (f : R ‚Üí+* S) {X : ModuleCat R} (x : ‚ÜëX) (x' : ‚ÜëX)  : 1 ‚äó‚Çú[R] x + 1 ‚äó‚Çú[R] x' = 1 ‚äó‚Çú[R] x + 1 ‚äó‚Çú[R] x'
type mismatch
  X
has type
  ModuleCat R : Type (max u_3 (?u.531 + 1))
but is expected to have type
  Sort ?u.661 : Type ?u.661 ; identifiers [R, u_3, S, u_1, CommRing, R, CommRing, S, f, R, S, X, ModuleCat, R, x, X, x', X, R, x, R, x', R, x, R, x'] (during elaboration) for {R : Type u_3}  -> {S : Type u_1}  -> [CommRing R]  -> [CommRing S]  -> (f : R ‚Üí+* S)  -> {X : ModuleCat R}  -> (x : ‚ÜëX)  -> (x' : ‚ÜëX)   -> 1 ‚äó‚Çú[R] x + 1 ‚äó‚Çú[R] x' = 1 ‚äó‚Çú[R] x + 1 ‚äó‚Çú[R] x'

{R : Type u} {A : Type v} {B : Type w} [CommSemiring R] [Semiring A] [Semiring B] [Algebra R A] [Algebra R B] (toRingHom : A ‚Üí+* B) (commutes' : ‚àÄ (r : R), OneHom.toFun (‚Üë‚ÜëtoRingHom) (‚Üë(algebraMap R A) r) = ‚Üë(algebraMap R B) r) (toRingHom_1 : A ‚Üí+* B) (commutes'_1 : ‚àÄ (r : R), OneHom.toFun (‚Üë‚ÜëtoRingHom_1) (‚Üë(algebraMap R A) r) = ‚Üë(algebraMap R B) r) (a : { toRingHom := ((toRingHom)), commutes' := ((commutes')) } =
  { toRingHom := ((toRingHom_1)), commutes' := ((commutes'_1)) })  : ‚àÄ (toRingHom_eq : toRingHom = toRingHom_1), toRingHom = toRingHom_1
type mismatch
  toRingHom_1
has type
  A ‚Üí+* B : Type (max v w)
but is expected to have type
  OneHom (?m.7752 toRingHom commutes' toRingHom_1 r)
    (?m.7748 toRingHom commutes' toRingHom_1 r) : Type (max ?u.3580 ?u.3579) ; identifiers [R, u, A, v, B, w, CommSemiring, R, Semiring, A, Semiring, B, Algebra, R, A, Algebra, R, B, toRingHom, A, B, commutes', r, R, OneHom.toFun, toRingHom, algebraMap, R, A, r, algebraMap, R, B, r, toRingHom_1, A, B, commutes'_1, r, R, OneHom.toFun, toRingHom_1, algebraMap, R, A, r, algebraMap, R, B, r, a, toRingHom, toRingHom, commutes', commutes', toRingHom, toRingHom_1, commutes', commutes'_1, toRingHom_eq, toRingHom, toRingHom_1, toRingHom, toRingHom_1] (during elaboration) for {R : Type u}  -> {A : Type v}  -> {B : Type w}  -> [CommSemiring R]  -> [Semiring A]  -> [Semiring B]  -> [Algebra R A]  -> [Algebra R B]  -> (toRingHom : A ‚Üí+* B)  -> (commutes' : ‚àÄ (r : R), OneHom.toFun (‚Üë‚ÜëtoRingHom) (‚Üë(algebraMap R A) r) = ‚Üë(algebraMap R B) r)  -> (toRingHom_1 : A ‚Üí+* B)  -> (commutes'_1 : ‚àÄ (r : R), OneHom.toFun (‚Üë‚ÜëtoRingHom_1) (‚Üë(algebraMap R A) r) = ‚Üë(algebraMap R B) r)  -> (a : { toRingHom := ((toRingHom)), commutes' := ((commutes')) } =
  { toRingHom := ((toRingHom_1)), commutes' := ((commutes'_1)) })   -> ‚àÄ (toRingHom_eq : toRingHom = toRingHom_1), toRingHom = toRingHom_1

{Œ± : Type u} {Œ≤ : Type v} [Fintype Œ≤] (r : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Prop) [(a : Œ±) ‚Üí DecidablePred (r a)] (r' : (a : Œ±) ‚Üí Finset Œ≤ := fun (a : Œ±) ‚Ü¶ Finset.filter (fun (b : Œ≤) ‚Ü¶ r a b) Finset.univ) (h : ‚àÄ (A : Finset Œ±), Finset.filter (fun (b : Œ≤) ‚Ü¶ ‚àÉ (a : Œ±), (a ‚àà A) ‚àß (r a b)) Finset.univ = Finset.biUnion A r') (h' : ‚àÄ (f : (a : Œ±) ‚Üí Œ≤) (x : Œ±), (r x (f x)) ‚Üî (f x ‚àà r' x)) (f : (a : Œ±) ‚Üí Œ≤) (x : Œ±) (f : (a : Œ±) ‚Üí Œ≤) (x : Œ±)  : (r x (f x)) ‚Üî (f x ‚àà r' x)
failed to synthesize instance
  DecidableEq Œ≤ ; identifiers [Œ±, u, Œ≤, v, Fintype, Œ≤, r, a, Œ±, a, Œ≤, a, Œ±, DecidablePred, r, a, r', a, Œ±, Finset, Œ≤, a, Œ±, Finset.filter, b, Œ≤, r, a, b, Finset.univ, h, A, Finset, Œ±, Finset.filter, b, Œ≤, a, Œ±, a, A, r, a, b, Finset.univ, Finset.biUnion, A, r', h', f, a, Œ±, Œ≤, x, Œ±, r, x, f, x, f, x, r', x, f, a, Œ±, Œ≤, x, Œ±, f, a, Œ±, Œ≤, x, Œ±, r, x, f, x, f, x, r', x] (during elaboration) for {Œ± : Type u}  -> {Œ≤ : Type v}  -> [Fintype Œ≤]  -> (r : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Prop)  -> [(a : Œ±) ‚Üí DecidablePred (r a)]  -> (r' : (a : Œ±) ‚Üí Finset Œ≤ := fun (a : Œ±) ‚Ü¶ Finset.filter (fun (b : Œ≤) ‚Ü¶ r a b) Finset.univ)  -> (h : ‚àÄ (A : Finset Œ±), Finset.filter (fun (b : Œ≤) ‚Ü¶ ‚àÉ (a : Œ±), (a ‚àà A) ‚àß (r a b)) Finset.univ = Finset.biUnion A r')  -> (h' : ‚àÄ (f : (a : Œ±) ‚Üí Œ≤) (x : Œ±), (r x (f x)) ‚Üî (f x ‚àà r' x))  -> (f : (a : Œ±) ‚Üí Œ≤)  -> (x : Œ±)  -> (f : (a : Œ±) ‚Üí Œ≤)  -> (x : Œ±)   -> (r x (f x)) ‚Üî (f x ‚àà r' x)

{C : Type u_2} [CategoryTheory.Category C] ‚¶ÉX : C‚¶Ñ ‚¶ÉS : CategoryTheory.Sieve X‚¶Ñ (H‚ÇÅ : S ‚àà
  (fun (X : C) (S : CategoryTheory.Sieve X) ‚Ü¶
      ‚àÄ {Y : C} (f : Y ‚ü∂ X), ‚àÉ (Z : C), ‚àÉ (g : Z ‚ü∂ Y), S.arrows (CategoryTheory.CategoryStruct.comp g f))
    X) (R : CategoryTheory.Sieve X) (H‚ÇÇ : ‚àÄ ‚¶ÉY : C‚¶Ñ ‚¶Éf : Y ‚ü∂ X‚¶Ñ (a : S.arrows f),
  CategoryTheory.Sieve.pullback f R ‚àà
    (fun (X : C) (S : CategoryTheory.Sieve X) ‚Ü¶
        ‚àÄ {Y : C} (f : Y ‚ü∂ X), ‚àÉ (Z : C), ‚àÉ (g : Z ‚ü∂ Y), S.arrows (CategoryTheory.CategoryStruct.comp g f))
      Y) {Y : C} (f : Y ‚ü∂ X)  : ‚àÉ (Z : C), ‚àÉ (g : Z ‚ü∂ Y), S.arrows (CategoryTheory.CategoryStruct.comp g f)
failed to synthesize instance
  Membership (CategoryTheory.Sieve X) (CategoryTheory.Sieve X ‚Üí Prop) ; identifiers [C, u_2, CategoryTheory.Category, C, X, C, S, CategoryTheory.Sieve, X, H‚ÇÅ, S, X, C, S, CategoryTheory.Sieve, X, Y, C, f, Y, X, Z, C, g, Z, Y, S.arrows, CategoryTheory.CategoryStruct.comp, g, f, X, R, CategoryTheory.Sieve, X, H‚ÇÇ, Y, C, f, Y, X, a, S.arrows, f, CategoryTheory.Sieve.pullback, f, R, X, C, S, CategoryTheory.Sieve, X, Y, C, f, Y, X, Z, C, g, Z, Y, S.arrows, CategoryTheory.CategoryStruct.comp, g, f, Y, Y, C, f, Y, X, Z, C, g, Z, Y, S.arrows, CategoryTheory.CategoryStruct.comp, g, f] (during elaboration) for {C : Type u_2}  -> [CategoryTheory.Category C]  -> ‚¶ÉX : C‚¶Ñ  -> ‚¶ÉS : CategoryTheory.Sieve X‚¶Ñ  -> (H‚ÇÅ : S ‚àà
  (fun (X : C) (S : CategoryTheory.Sieve X) ‚Ü¶
      ‚àÄ {Y : C} (f : Y ‚ü∂ X), ‚àÉ (Z : C), ‚àÉ (g : Z ‚ü∂ Y), S.arrows (CategoryTheory.CategoryStruct.comp g f))
    X)  -> (R : CategoryTheory.Sieve X)  -> (H‚ÇÇ : ‚àÄ ‚¶ÉY : C‚¶Ñ ‚¶Éf : Y ‚ü∂ X‚¶Ñ (a : S.arrows f),
  CategoryTheory.Sieve.pullback f R ‚àà
    (fun (X : C) (S : CategoryTheory.Sieve X) ‚Ü¶
        ‚àÄ {Y : C} (f : Y ‚ü∂ X), ‚àÉ (Z : C), ‚àÉ (g : Z ‚ü∂ Y), S.arrows (CategoryTheory.CategoryStruct.comp g f))
      Y)  -> {Y : C}  -> (f : Y ‚ü∂ X)   -> ‚àÉ (Z : C), ‚àÉ (g : Z ‚ü∂ Y), S.arrows (CategoryTheory.CategoryStruct.comp g f)

{R : Type u} {A : Type v} {B : Type w} [CommSemiring R] [Semiring A] [Semiring B] [Algebra R A] [Algebra R B] (toRingHom : A ‚Üí+* B) (commutes' : ‚àÄ (r : R), OneHom.toFun (‚Üë‚ÜëtoRingHom) (‚Üë(algebraMap R A) r) = ‚Üë(algebraMap R B) r) (toRingHom_1 : A ‚Üí+* B) (commutes'_1 : ‚àÄ (r : R), OneHom.toFun (‚Üë‚ÜëtoRingHom_1) (‚Üë(algebraMap R A) r) = ‚Üë(algebraMap R B) r) (a : toRingHom = toRingHom_1) (h : toRingHom_1 = toRingHom) (toRingHom_2 : A ‚Üí+* B)  : toRingHom = toRingHom
type mismatch
  toRingHom_1
has type
  A ‚Üí+* B : Type (max v w)
but is expected to have type
  OneHom (?m.7342 toRingHom commutes' toRingHom_1 r)
    (?m.7338 toRingHom commutes' toRingHom_1 r) : Type (max ?u.3580 ?u.3579) ; identifiers [R, u, A, v, B, w, CommSemiring, R, Semiring, A, Semiring, B, Algebra, R, A, Algebra, R, B, toRingHom, A, B, commutes', r, R, OneHom.toFun, toRingHom, algebraMap, R, A, r, algebraMap, R, B, r, toRingHom_1, A, B, commutes'_1, r, R, OneHom.toFun, toRingHom_1, algebraMap, R, A, r, algebraMap, R, B, r, a, toRingHom, toRingHom_1, h, toRingHom_1, toRingHom, toRingHom_2, A, B, toRingHom, toRingHom] (during elaboration) for {R : Type u}  -> {A : Type v}  -> {B : Type w}  -> [CommSemiring R]  -> [Semiring A]  -> [Semiring B]  -> [Algebra R A]  -> [Algebra R B]  -> (toRingHom : A ‚Üí+* B)  -> (commutes' : ‚àÄ (r : R), OneHom.toFun (‚Üë‚ÜëtoRingHom) (‚Üë(algebraMap R A) r) = ‚Üë(algebraMap R B) r)  -> (toRingHom_1 : A ‚Üí+* B)  -> (commutes'_1 : ‚àÄ (r : R), OneHom.toFun (‚Üë‚ÜëtoRingHom_1) (‚Üë(algebraMap R A) r) = ‚Üë(algebraMap R B) r)  -> (a : toRingHom = toRingHom_1)  -> (h : toRingHom_1 = toRingHom)  -> (toRingHom_2 : A ‚Üí+* B)   -> toRingHom = toRingHom

{R : Type u} {A : Type v} {B : Type w} [CommSemiring R] [Semiring A] [Semiring B] [Algebra R A] [Algebra R B] (toRingHom : A ‚Üí+* B) (commutes' : ‚àÄ (r : R), OneHom.toFun (‚Üë‚ÜëtoRingHom) (‚Üë(algebraMap R A) r) = ‚Üë(algebraMap R B) r) (toRingHom_1 : A ‚Üí+* B) (commutes'_1 : ‚àÄ (r : R), OneHom.toFun (‚Üë‚ÜëtoRingHom_1) (‚Üë(algebraMap R A) r) = ‚Üë(algebraMap R B) r) (a : toRingHom = toRingHom_1) (h : toRingHom_1 = toRingHom) (commutes'_2 : ‚àÄ (r : R), OneHom.toFun (‚Üë‚ÜëtoRingHom) (‚Üë(algebraMap R A) r) = ‚Üë(algebraMap R B) r) (a : toRingHom = toRingHom) (h : HEq a (Eq.refl toRingHom))  : { toRingHom := ((toRingHom)), commutes' := ((commutes')) } = { toRingHom := ((toRingHom)), commutes' := ((commutes')) }
type mismatch
  toRingHom
has type
  A ‚Üí+* B : Type (max v w)
but is expected to have type
  OneHom (?m.13500 toRingHom commutes' toRingHom_1 commutes'_1 a h r)
    (?m.13484 toRingHom commutes' toRingHom_1 commutes'_1 a h r) : Type (max ?u.7031 ?u.7030) ; identifiers [R, u, A, v, B, w, CommSemiring, R, Semiring, A, Semiring, B, Algebra, R, A, Algebra, R, B, toRingHom, A, B, commutes', r, R, OneHom.toFun, toRingHom, algebraMap, R, A, r, algebraMap, R, B, r, toRingHom_1, A, B, commutes'_1, r, R, OneHom.toFun, toRingHom_1, algebraMap, R, A, r, algebraMap, R, B, r, a, toRingHom, toRingHom_1, h, toRingHom_1, toRingHom, commutes'_2, r, R, OneHom.toFun, toRingHom, algebraMap, R, A, r, algebraMap, R, B, r, a, toRingHom, toRingHom, h, HEq, a, Eq.refl, toRingHom, toRingHom, toRingHom, commutes', commutes', toRingHom, toRingHom, commutes', commutes'] (during elaboration) for {R : Type u}  -> {A : Type v}  -> {B : Type w}  -> [CommSemiring R]  -> [Semiring A]  -> [Semiring B]  -> [Algebra R A]  -> [Algebra R B]  -> (toRingHom : A ‚Üí+* B)  -> (commutes' : ‚àÄ (r : R), OneHom.toFun (‚Üë‚ÜëtoRingHom) (‚Üë(algebraMap R A) r) = ‚Üë(algebraMap R B) r)  -> (toRingHom_1 : A ‚Üí+* B)  -> (commutes'_1 : ‚àÄ (r : R), OneHom.toFun (‚Üë‚ÜëtoRingHom_1) (‚Üë(algebraMap R A) r) = ‚Üë(algebraMap R B) r)  -> (a : toRingHom = toRingHom_1)  -> (h : toRingHom_1 = toRingHom)  -> (commutes'_2 : ‚àÄ (r : R), OneHom.toFun (‚Üë‚ÜëtoRingHom) (‚Üë(algebraMap R A) r) = ‚Üë(algebraMap R B) r)  -> (a : toRingHom = toRingHom)  -> (h : HEq a (Eq.refl toRingHom))   -> { toRingHom := ((toRingHom)), commutes' := ((commutes')) } = { toRingHom := ((toRingHom)), commutes' := ((commutes')) }

{R : Type u} {A : Type v} {B : Type w} [CommSemiring R] [Semiring A] [Semiring B] [Algebra R A] [Algebra R B] (toRingHom : A ‚Üí+* B) (commutes' : ‚àÄ (r : R), OneHom.toFun (‚Üë‚ÜëtoRingHom) (‚Üë(algebraMap R A) r) = ‚Üë(algebraMap R B) r) (toRingHom_1 : A ‚Üí+* B) (commutes'_1 : ‚àÄ (r : R), OneHom.toFun (‚Üë‚ÜëtoRingHom_1) (‚Üë(algebraMap R A) r) = ‚Üë(algebraMap R B) r) (a : toRingHom = toRingHom_1) (h : toRingHom_1 = toRingHom)  : toRingHom = toRingHom_1
type mismatch
  toRingHom_1
has type
  A ‚Üí+* B : Type (max v w)
but is expected to have type
  OneHom (?m.7335 toRingHom commutes' toRingHom_1 r)
    (?m.7331 toRingHom commutes' toRingHom_1 r) : Type (max ?u.3580 ?u.3579) ; identifiers [R, u, A, v, B, w, CommSemiring, R, Semiring, A, Semiring, B, Algebra, R, A, Algebra, R, B, toRingHom, A, B, commutes', r, R, OneHom.toFun, toRingHom, algebraMap, R, A, r, algebraMap, R, B, r, toRingHom_1, A, B, commutes'_1, r, R, OneHom.toFun, toRingHom_1, algebraMap, R, A, r, algebraMap, R, B, r, a, toRingHom, toRingHom_1, h, toRingHom_1, toRingHom, toRingHom, toRingHom_1] (during elaboration) for {R : Type u}  -> {A : Type v}  -> {B : Type w}  -> [CommSemiring R]  -> [Semiring A]  -> [Semiring B]  -> [Algebra R A]  -> [Algebra R B]  -> (toRingHom : A ‚Üí+* B)  -> (commutes' : ‚àÄ (r : R), OneHom.toFun (‚Üë‚ÜëtoRingHom) (‚Üë(algebraMap R A) r) = ‚Üë(algebraMap R B) r)  -> (toRingHom_1 : A ‚Üí+* B)  -> (commutes'_1 : ‚àÄ (r : R), OneHom.toFun (‚Üë‚ÜëtoRingHom_1) (‚Üë(algebraMap R A) r) = ‚Üë(algebraMap R B) r)  -> (a : toRingHom = toRingHom_1)  -> (h : toRingHom_1 = toRingHom)   -> toRingHom = toRingHom_1

{R : Type u} {A : Type v} {B : Type w} [CommSemiring R] [Semiring A] [Semiring B] [Algebra R A] [Algebra R B] (toRingHom : A ‚Üí+* B) (commutes' : ‚àÄ (r : R), OneHom.toFun (‚Üë‚ÜëtoRingHom) (‚Üë(algebraMap R A) r) = ‚Üë(algebraMap R B) r) (toRingHom_1 : A ‚Üí+* B) (commutes'_1 : ‚àÄ (r : R), OneHom.toFun (‚Üë‚ÜëtoRingHom_1) (‚Üë(algebraMap R A) r) = ‚Üë(algebraMap R B) r) (a : toRingHom = toRingHom_1)  : toRingHom_1 = toRingHom_1
type mismatch
  toRingHom_1
has type
  A ‚Üí+* B : Type (max v w)
but is expected to have type
  OneHom (?m.7330 toRingHom commutes' toRingHom_1 r)
    (?m.7326 toRingHom commutes' toRingHom_1 r) : Type (max ?u.3580 ?u.3579) ; identifiers [R, u, A, v, B, w, CommSemiring, R, Semiring, A, Semiring, B, Algebra, R, A, Algebra, R, B, toRingHom, A, B, commutes', r, R, OneHom.toFun, toRingHom, algebraMap, R, A, r, algebraMap, R, B, r, toRingHom_1, A, B, commutes'_1, r, R, OneHom.toFun, toRingHom_1, algebraMap, R, A, r, algebraMap, R, B, r, a, toRingHom, toRingHom_1, toRingHom_1, toRingHom_1] (during elaboration) for {R : Type u}  -> {A : Type v}  -> {B : Type w}  -> [CommSemiring R]  -> [Semiring A]  -> [Semiring B]  -> [Algebra R A]  -> [Algebra R B]  -> (toRingHom : A ‚Üí+* B)  -> (commutes' : ‚àÄ (r : R), OneHom.toFun (‚Üë‚ÜëtoRingHom) (‚Üë(algebraMap R A) r) = ‚Üë(algebraMap R B) r)  -> (toRingHom_1 : A ‚Üí+* B)  -> (commutes'_1 : ‚àÄ (r : R), OneHom.toFun (‚Üë‚ÜëtoRingHom_1) (‚Üë(algebraMap R A) r) = ‚Üë(algebraMap R B) r)  -> (a : toRingHom = toRingHom_1)   -> toRingHom_1 = toRingHom_1

