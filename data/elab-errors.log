 : (‚àÄ {Œπ : Type uŒπ} {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] [inst_2 : FiniteDimensional ‚Ñù E]
  {H : Type uH} [inst_3 : TopologicalSpace H] {I : ModelWithCorners ‚Ñù E H} {M : Type uM} [inst_4 : TopologicalSpace M]
  [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] {s : Set M} [inst_7 : T2Space M]
  {f : SmoothBumpCovering Œπ I M s} {U : (a : M) ‚Üí Set M},
  (BumpCovering.IsSubordinate (SmoothBumpCovering.toBumpCovering f) fun (i : Œπ) ‚Ü¶ U (SmoothBumpCovering.c s f i)) ‚Üî
    (SmoothBumpCovering.IsSubordinate f U))
unknown universe level 'uH' ; identifiers [Œπ, uŒπ, E, uE, inst, NormedAddCommGroup, E, inst_1, NormedSpace, E, inst_2, FiniteDimensional, E, H, uH, inst_3, TopologicalSpace, H, I, ModelWithCorners, E, H, M, uM, inst_4, TopologicalSpace, M, inst_5, ChartedSpace, H, M, inst_6, SmoothManifoldWithCorners, I, M, s, Set, M, inst_7, T2Space, M, f, SmoothBumpCovering, Œπ, I, M, s, U, a, M, Set, M, BumpCovering.IsSubordinate, SmoothBumpCovering.toBumpCovering, f, i, Œπ, U, SmoothBumpCovering.c, s, f, i, SmoothBumpCovering.IsSubordinate, f, U] (during elaboration) for (‚àÄ {Œπ : Type uŒπ} {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] [inst_2 : FiniteDimensional ‚Ñù E]
  {H : Type uH} [inst_3 : TopologicalSpace H] {I : ModelWithCorners ‚Ñù E H} {M : Type uM} [inst_4 : TopologicalSpace M]
  [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] {s : Set M} [inst_7 : T2Space M]
  {f : SmoothBumpCovering Œπ I M s} {U : (a : M) ‚Üí Set M},
  (BumpCovering.IsSubordinate (SmoothBumpCovering.toBumpCovering f) fun (i : Œπ) ‚Ü¶ U (SmoothBumpCovering.c s f i)) ‚Üî
    (SmoothBumpCovering.IsSubordinate f U))

 : (‚àÄ {Œπ : Type u_1} {V : Type u} [inst : CategoryTheory.Category V] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms V]
  {c : ComplexShape Œπ} {A : HomologicalComplex V c} {B : HomologicalComplex V c} [inst_2 : SizeOf Œπ] [inst_3 : SizeOf V]
  (f : (i : Œπ) ‚Üí HomologicalComplex.X A i ‚ü∂ HomologicalComplex.X B i)
  (comm' :
    autoParam
      (‚àÄ (i : Œπ) (j : Œπ) (a : ComplexShape.Rel c i j),
        CategoryTheory.CategoryStruct.comp (f i) (HomologicalComplex.d B i j) =
          CategoryTheory.CategoryStruct.comp (HomologicalComplex.d A i j) (f j))
      _auto‚úù),
  sizeOf (HomologicalComplex.Hom.mk f) = 1)
<input>:9:11: expected token

 : (‚àÄ {Œ± : Type u} (m : MeasureTheory.OuterMeasure Œ±) {s : Set Œ±},
  (MeasurableSet s) ‚Üî (‚àÄ (t : Set Œ±), ‚Üëm t = ‚Üëm (t ‚à© s) + ‚Üëm (t \ s)))
failed to synthesize instance
  MeasurableSpace Œ± ; identifiers [Œ±, u, m, MeasureTheory.OuterMeasure, Œ±, s, Set, Œ±, MeasurableSet, s, t, Set, Œ±, m, t, m, t, s, m, t, s] (during elaboration) for (‚àÄ {Œ± : Type u} (m : MeasureTheory.OuterMeasure Œ±) {s : Set Œ±},
  (MeasurableSet s) ‚Üî (‚àÄ (t : Set Œ±), ‚Üëm t = ‚Üëm (t ‚à© s) + ‚Üëm (t \ s)))

 : (‚àÄ {L : FirstOrder.Language} (M : Type w) [inst : FirstOrder.Language.Structure L M]
  {œÜ : FirstOrder.Language.Sentence L}, (M ‚ä® FirstOrder.Language.Formula.not œÜ) ‚Üî (¬¨(M ‚ä® œÜ)))
ambiguous, possible interpretations 
  M ‚ä® ?m.497 : Prop
  
  M ‚ä® FirstOrder.Language.Formula.not œÜ : Prop ; identifiers [L, FirstOrder.Language, M, w, inst, FirstOrder.Language.Structure, L, M, œÜ, FirstOrder.Language.Sentence, L, M, FirstOrder.Language.Formula.not, œÜ, M, FirstOrder.Language.Formula.not, œÜ, M, œÜ, M, œÜ] (during elaboration) for (‚àÄ {L : FirstOrder.Language} (M : Type w) [inst : FirstOrder.Language.Structure L M]
  {œÜ : FirstOrder.Language.Sentence L}, (M ‚ä® FirstOrder.Language.Formula.not œÜ) ‚Üî (¬¨(M ‚ä® œÜ)))

 : (‚àÄ (A : Type u_1) [inst : CommRing A] (K : Type u_2) [inst_1 : Field K] [inst_2 : Algebra A K]
  (a : ValuationRing.ValueGroup A K) (b : ValuationRing.ValueGroup A K), (a < b) ‚Üî (a < b))
failed to synthesize instance
  LT (ValuationRing.ValueGroup A K) ; identifiers [A, u_1, inst, CommRing, A, K, u_2, inst_1, Field, K, inst_2, Algebra, A, K, a, ValuationRing.ValueGroup, A, K, b, ValuationRing.ValueGroup, A, K, a, b, a, b] (during elaboration) for (‚àÄ (A : Type u_1) [inst : CommRing A] (K : Type u_2) [inst_1 : Field K] [inst_2 : Algebra A K]
  (a : ValuationRing.ValueGroup A K) (b : ValuationRing.ValueGroup A K), (a < b) ‚Üî (a < b))

 : (‚àÄ {P : AlgebraicGeometry.AffineTargetMorphismProperty}
  (self : AlgebraicGeometry.AffineTargetMorphismProperty.IsLocal P) {X : AlgebraicGeometry.Scheme}
  {Y : AlgebraicGeometry.Scheme} [inst : AlgebraicGeometry.IsAffine Y] (f : X ‚ü∂ Y)
  (r :
    ‚Üë((CategoryTheory.Functor.toPrefunctor
            (AlgebraicGeometry.PresheafedSpace.presheaf
              (AlgebraicGeometry.SheafedSpace.toPresheafedSpace
                (AlgebraicGeometry.LocallyRingedSpace.toSheafedSpace
                  (AlgebraicGeometry.Scheme.toLocallyRingedSpace Y))))).obj
        (Opposite.op ‚ä§)))
  (a : P f), P (f ‚à£_ AlgebraicGeometry.Scheme.basicOpen Y r))
synthesized type class instance is not definitionally equal to expression inferred by typing rules, synthesized
  CategoryTheory.Category.opposite
inferred
  CategoryTheory.Category.opposite ; identifiers [P, AlgebraicGeometry.AffineTargetMorphismProperty, self, AlgebraicGeometry.AffineTargetMorphismProperty.IsLocal, P, X, AlgebraicGeometry.Scheme, Y, AlgebraicGeometry.Scheme, inst, AlgebraicGeometry.IsAffine, Y, f, X, Y, r, CategoryTheory.Functor.toPrefunctor, AlgebraicGeometry.PresheafedSpace.presheaf, AlgebraicGeometry.SheafedSpace.toPresheafedSpace, AlgebraicGeometry.LocallyRingedSpace.toSheafedSpace, AlgebraicGeometry.Scheme.toLocallyRingedSpace, Y, obj, Opposite.op, a, P, f, P, f, AlgebraicGeometry.Scheme.basicOpen, Y, r] (during elaboration) for (‚àÄ {P : AlgebraicGeometry.AffineTargetMorphismProperty}
  (self : AlgebraicGeometry.AffineTargetMorphismProperty.IsLocal P) {X : AlgebraicGeometry.Scheme}
  {Y : AlgebraicGeometry.Scheme} [inst : AlgebraicGeometry.IsAffine Y] (f : X ‚ü∂ Y)
  (r :
    ‚Üë((CategoryTheory.Functor.toPrefunctor
            (AlgebraicGeometry.PresheafedSpace.presheaf
              (AlgebraicGeometry.SheafedSpace.toPresheafedSpace
                (AlgebraicGeometry.LocallyRingedSpace.toSheafedSpace
                  (AlgebraicGeometry.Scheme.toLocallyRingedSpace Y))))).obj
        (Opposite.op ‚ä§)))
  (a : P f), P (f ‚à£_ AlgebraicGeometry.Scheme.basicOpen Y r))

 : (‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} {f : X ‚ü∂ Y}
  {F : CategoryTheory.Limits.MonoFactorisation f} [inst_1 : SizeOf C]
  (lift :
    (F' : CategoryTheory.Limits.MonoFactorisation f) ‚Üí
      CategoryTheory.Limits.MonoFactorisation.I F ‚ü∂ CategoryTheory.Limits.MonoFactorisation.I F')
  (lift_fac :
    autoParam
      (‚àÄ (F' : CategoryTheory.Limits.MonoFactorisation f),
        CategoryTheory.CategoryStruct.comp (lift F') (CategoryTheory.Limits.MonoFactorisation.m F') =
          CategoryTheory.Limits.MonoFactorisation.m F)
      _auto‚úù),
  sizeOf (CategoryTheory.Limits.IsImage.mk lift) = 1)
<input>:11:11: expected token

 : (‚àÄ {Œ± : Type u} [inst : SizeOf Œ±], sizeOf RegularExpression.zero = 1)
typeclass instance problem is stuck, it is often due to metavariables
  SizeOf (RegularExpression ?m.6756) ; identifiers [Œ±, u, inst, SizeOf, Œ±, sizeOf, RegularExpression.zero] (during elaboration) for (‚àÄ {Œ± : Type u} [inst : SizeOf Œ±], sizeOf RegularExpression.zero = 1)

 : (‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : NonAssocSemiring Œ±] [inst_1 : Preorder Œ±] [inst_2 : NonAssocSemiring Œ≤]
  [inst_3 : Preorder Œ≤] (self : Œ± ‚Üí+*o Œ≤), Monotone (OneHom.toFun ‚Üë‚Üë(OrderRingHom.toRingHom self)))
type mismatch
  self.toRingHom
has type
  Œ± ‚Üí+* Œ≤ : Type (max u_1 u_2)
but is expected to have type
  OneHom (?m.1709 self) (?m.1710 self) : Type (max ?u.184 ?u.183) ; identifiers [Œ±, u_1, Œ≤, u_2, inst, NonAssocSemiring, Œ±, inst_1, Preorder, Œ±, inst_2, NonAssocSemiring, Œ≤, inst_3, Preorder, Œ≤, self, Œ±, Œ≤, Monotone, OneHom.toFun, OrderRingHom.toRingHom, self] (during elaboration) for (‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : NonAssocSemiring Œ±] [inst_1 : Preorder Œ±] [inst_2 : NonAssocSemiring Œ≤]
  [inst_3 : Preorder Œ≤] (self : Œ± ‚Üí+*o Œ≤), Monotone (OneHom.toFun ‚Üë‚Üë(OrderRingHom.toRingHom self)))

 : (‚àÄ {G : Type u_1} [inst : Group G] (n : ‚Ñï) (q : G),
  (q ‚àà lowerCentralSeries G (n + 1)) ‚Üî
    (q ‚àà
      Subgroup.closure
        {x : G | ‚àÉ (p : G), (p ‚àà lowerCentralSeries G n) ‚àß (‚àÉ (q : G), (q ‚àà ‚ä§) ‚àß (p * q * p‚Åª¬π * q‚Åª¬π = x))}))
typeclass instance problem is stuck, it is often due to metavariables
  Membership G (?m.2897 n q‚úù x p q) ; identifiers [G, u_1, inst, Group, G, n, q, G, q, lowerCentralSeries, G, n, q, Subgroup.closure, x, G, p, G, p, lowerCentralSeries, G, n, q, G, q, p, q, p, q, x] (during elaboration) for (‚àÄ {G : Type u_1} [inst : Group G] (n : ‚Ñï) (q : G),
  (q ‚àà lowerCentralSeries G (n + 1)) ‚Üî
    (q ‚àà
      Subgroup.closure
        {x : G | ‚àÉ (p : G), (p ‚àà lowerCentralSeries G n) ‚àß (‚àÉ (q : G), (q ‚àà ‚ä§) ‚àß (p * q * p‚Åª¬π * q‚Åª¬π = x))}))

 : (‚àÄ {C : Type u} [inst : SizeOf C], sizeOf CategoryTheory.FreeMonoidalCategory.Unit = 1)
typeclass instance problem is stuck, it is often due to metavariables
  SizeOf (CategoryTheory.FreeMonoidalCategory ?m.6756) ; identifiers [C, u, inst, SizeOf, C, sizeOf, CategoryTheory.FreeMonoidalCategory.Unit] (during elaboration) for (‚àÄ {C : Type u} [inst : SizeOf C], sizeOf CategoryTheory.FreeMonoidalCategory.Unit = 1)

 : (‚àÄ (C : Type u) [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C]
  [inst_2 : CategoryTheory.Limits.HasBinaryCoproducts C] (P : C) (Q : C),
  Œ≤_ P Q = CategoryTheory.Limits.coprod.braiding P Q)
type mismatch
  CategoryTheory.Limits.coprod.braiding P Q
has type
  P ‚®ø Q ‚âÖ Q ‚®ø P : Type ?u.6
but is expected to have type
  CategoryTheory.MonoidalCategory.tensorObj P Q ‚âÖ CategoryTheory.MonoidalCategory.tensorObj Q P : Type ?u.6 ; identifiers [C, u, inst, CategoryTheory.Category, C, inst_1, CategoryTheory.Limits.HasInitial, C, inst_2, CategoryTheory.Limits.HasBinaryCoproducts, C, P, C, Q, C, P, Q, CategoryTheory.Limits.coprod.braiding, P, Q] (during elaboration) for (‚àÄ (C : Type u) [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C]
  [inst_2 : CategoryTheory.Limits.HasBinaryCoproducts C] (P : C) (Q : C),
  Œ≤_ P Q = CategoryTheory.Limits.coprod.braiding P Q)

 : (‚àÄ {Œ± : Type u_1} [inst : Mul Œ±] {s : Set Œ±} {t : Set Œ±} {a : Œ±},
  (a ‚àà s * t) ‚Üî (‚àÉ (x : Œ±), ‚àÉ (y : Œ±), (x ‚àà s) ‚àß ((y ‚àà t) ‚àß (x * y = a))))
failed to synthesize instance
  HMul (Set Œ±) (Set Œ±) ?m.1969 ; identifiers [Œ±, u_1, inst, Mul, Œ±, s, Set, Œ±, t, Set, Œ±, a, Œ±, a, s, t, x, Œ±, y, Œ±, x, s, y, t, x, y, a] (during elaboration) for (‚àÄ {Œ± : Type u_1} [inst : Mul Œ±] {s : Set Œ±} {t : Set Œ±} {a : Œ±},
  (a ‚àà s * t) ‚Üî (‚àÉ (x : Œ±), ‚àÉ (y : Œ±), (x ‚àà s) ‚àß ((y ‚àà t) ‚àß (x * y = a))))

 : (‚àÄ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommGroup M] (self : Module.Core R M) (r : R) (x : M)
  (y : M), r ‚Ä¢ (x + y) = r ‚Ä¢ x + r ‚Ä¢ y)
failed to synthesize instance
  HSMul R M ?m.54 ; identifiers [R, u_1, M, u_2, inst, Semiring, R, inst_1, AddCommGroup, M, self, Module.Core, R, M, r, R, x, M, y, M, r, x, y, r, x, r, y] (during elaboration) for (‚àÄ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommGroup M] (self : Module.Core R M) (r : R) (x : M)
  (y : M), r ‚Ä¢ (x + y) = r ‚Ä¢ x + r ‚Ä¢ y)

 : (‚àÄ {G : Type u_1} {Œ± : Type u_2} [inst : One G] [inst_1 : SMul G Œ±] [inst_2 : MeasurableSpace Œ±] {s : Set Œ±}
  {Œº : autoParam (MeasureTheory.Measure Œ±) _auto‚úù} (self : MeasureTheory.IsFundamentalDomain G s),
  Pairwise (MeasureTheory.AEDisjoint Œº on fun (g : G) ‚Ü¶ g ‚Ä¢ s))
<input>:2:48: expected token

 : (‚àÄ {R : Type u} [inst : SizeOf R], sizeOf Rack.PreEnvelGroup.unit = 1)
typeclass instance problem is stuck, it is often due to metavariables
  SizeOf (Rack.PreEnvelGroup ?m.6756) ; identifiers [R, u, inst, SizeOf, R, sizeOf, Rack.PreEnvelGroup.unit] (during elaboration) for (‚àÄ {R : Type u} [inst : SizeOf R], sizeOf Rack.PreEnvelGroup.unit = 1)

 : (‚àÄ {R : Type u_1} [inst : Semiring R] (h : IsField R) (a : R) (b : R), a / b = a / b)
failed to synthesize instance
  HDiv R R ?m.293 ; identifiers [R, u_1, inst, Semiring, R, h, IsField, R, a, R, b, R, a, b, a, b] (during elaboration) for (‚àÄ {R : Type u_1} [inst : Semiring R] (h : IsField R) (a : R) (b : R), a / b = a / b)

 : (‚àÄ {X : TopCat} (x : ‚ÜëX) (a : TopologicalSpace.OpenNhds x) (b : TopologicalSpace.OpenNhds x), (a < b) ‚Üî (a < b))
type mismatch
  X
has type
  TopCat : Type (?u.3 + 1)
but is expected to have type
  Sort ?u.5 : Type ?u.5 ; identifiers [X, TopCat, x, X, a, TopologicalSpace.OpenNhds, x, b, TopologicalSpace.OpenNhds, x, a, b, a, b] (during elaboration) for (‚àÄ {X : TopCat} (x : ‚ÜëX) (a : TopologicalSpace.OpenNhds x) (b : TopologicalSpace.OpenNhds x), (a < b) ‚Üî (a < b))

 : (‚àÄ {J : Type u_2} [inst : CategoryTheory.SmallCategory J] [inst_1 : CategoryTheory.IsFiltered J]
  (F : CategoryTheory.Functor J GroupCat) (a : ‚Üë(GroupCat.FilteredColimits.G F)) (b : ‚Üë(GroupCat.FilteredColimits.G F)),
  a / b = a / b)
type mismatch
  GroupCat.FilteredColimits.G F
has type
  MonCat : Type ((max ?u.50 u_2) + 1)
but is expected to have type
  Sort ?u.49 : Type ?u.49 ; identifiers [J, u_2, inst, CategoryTheory.SmallCategory, J, inst_1, CategoryTheory.IsFiltered, J, F, CategoryTheory.Functor, J, GroupCat, a, GroupCat.FilteredColimits.G, F, b, GroupCat.FilteredColimits.G, F, a, b, a, b] (during elaboration) for (‚àÄ {J : Type u_2} [inst : CategoryTheory.SmallCategory J] [inst_1 : CategoryTheory.IsFiltered J]
  (F : CategoryTheory.Functor J GroupCat) (a : ‚Üë(GroupCat.FilteredColimits.G F)) (b : ‚Üë(GroupCat.FilteredColimits.G F)),
  a / b = a / b)

 : (‚àÄ {Œ± : Type u_1} {m : MeasurableSpace Œ±} {f : (a : Œ±) ‚Üí Œ±} {Œº : autoParam (MeasureTheory.Measure Œ±) _auto‚úù}
  (self : Ergodic f), MeasureTheory.MeasurePreserving f)
<input>:1:109: expected token

 : (‚àÄ {Œπ : Type uŒπ} {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] {H : Type uH}
  [inst_2 : TopologicalSpace H] {I : ModelWithCorners ‚Ñù E H} {M : Type uM} [inst_3 : TopologicalSpace M]
  [inst_4 : ChartedSpace H M] {s : optParam (Set M) Set.univ} (self : SmoothPartitionOfUnity Œπ I M s) (x : M),
  ‚àë·∂† (i : Œπ), ‚Üë(SmoothPartitionOfUnity.toFun s self i) x ‚â§ 1)
unknown universe level 'uH' ; identifiers [Œπ, uŒπ, E, uE, inst, NormedAddCommGroup, E, inst_1, NormedSpace, E, H, uH, inst_2, TopologicalSpace, H, I, ModelWithCorners, E, H, M, uM, inst_3, TopologicalSpace, M, inst_4, ChartedSpace, H, M, s, optParam, Set, M, Set.univ, self, SmoothPartitionOfUnity, Œπ, I, M, s, x, M, i, Œπ, SmoothPartitionOfUnity.toFun, s, self, i, x] (during elaboration) for (‚àÄ {Œπ : Type uŒπ} {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] {H : Type uH}
  [inst_2 : TopologicalSpace H] {I : ModelWithCorners ‚Ñù E H} {M : Type uM} [inst_3 : TopologicalSpace M]
  [inst_4 : ChartedSpace H M] {s : optParam (Set M) Set.univ} (self : SmoothPartitionOfUnity Œπ I M s) (x : M),
  ‚àë·∂† (i : Œπ), ‚Üë(SmoothPartitionOfUnity.toFun s self i) x ‚â§ 1)

 : (‚àÄ {ùïú : Type u} [inst : NontriviallyNormedField ùïú] {F : Type v} [inst_1 : NormedAddCommGroup F]
  [inst_2 : NormedSpace ùïú F] {f : (a : ùïú) ‚Üí F} {f' : F} {x : ùïú},
  (HasStrictDerivAt f f' x) ‚Üî (HasStrictFDerivAt f (ContinuousLinearMap.smulRight 1 f') x))
typeclass instance problem is stuck, it is often due to metavariables
  NormedSpace ?m.8177 F ; identifiers [ùïú, u, inst, NontriviallyNormedField, ùïú, F, v, inst_1, NormedAddCommGroup, F, inst_2, NormedSpace, ùïú, F, f, a, ùïú, F, f', F, x, ùïú, HasStrictDerivAt, f, f', x, HasStrictFDerivAt, f, ContinuousLinearMap.smulRight, f', x] (during elaboration) for (‚àÄ {ùïú : Type u} [inst : NontriviallyNormedField ùïú] {F : Type v} [inst_1 : NormedAddCommGroup F]
  [inst_2 : NormedSpace ùïú F] {f : (a : ùïú) ‚Üí F} {f' : F} {x : ùïú},
  (HasStrictDerivAt f f' x) ‚Üî (HasStrictFDerivAt f (ContinuousLinearMap.smulRight 1 f') x))

 : (‚àÄ {R : Type u} [inst : CommRing R] {W : WeierstrassCurve R} [inst_1 : SizeOf R],
  sizeOf WeierstrassCurve.Point.zero = 1)
typeclass instance problem is stuck, it is often due to metavariables
  SizeOf (WeierstrassCurve.Point ?m.7627) ; identifiers [R, u, inst, CommRing, R, W, WeierstrassCurve, R, inst_1, SizeOf, R, sizeOf, WeierstrassCurve.Point.zero] (during elaboration) for (‚àÄ {R : Type u} [inst : CommRing R] {W : WeierstrassCurve R} [inst_1 : SizeOf R],
  sizeOf WeierstrassCurve.Point.zero = 1)

 : (‚àÄ {Œ± : Type u_1} [inst : Div Œ±] {s : Set Œ±} {t : Set Œ±} {a : Œ±},
  (a ‚àà s / t) ‚Üî (‚àÉ (x : Œ±), ‚àÉ (y : Œ±), (x ‚àà s) ‚àß ((y ‚àà t) ‚àß (x / y = a))))
failed to synthesize instance
  HDiv (Set Œ±) (Set Œ±) ?m.284 ; identifiers [Œ±, u_1, inst, Div, Œ±, s, Set, Œ±, t, Set, Œ±, a, Œ±, a, s, t, x, Œ±, y, Œ±, x, s, y, t, x, y, a] (during elaboration) for (‚àÄ {Œ± : Type u_1} [inst : Div Œ±] {s : Set Œ±} {t : Set Œ±} {a : Œ±},
  (a ‚àà s / t) ‚Üî (‚àÉ (x : Œ±), ‚àÉ (y : Œ±), (x ‚àà s) ‚àß ((y ‚àà t) ‚àß (x / y = a))))

 : (‚àÄ {B : Type u‚ÇÅ} [inst : CategoryTheory.Bicategory B] {C : Type u‚ÇÇ} [inst_1 : CategoryTheory.Bicategory C]
  {F : CategoryTheory.OplaxFunctor B C} [inst_2 : SizeOf B] [inst_3 : SizeOf C]
  (mapIdIso :
    (a : B) ‚Üí
      (‚Üë(CategoryTheory.OplaxFunctor.toPrelaxFunctor F)).map (CategoryTheory.CategoryStruct.id a) ‚âÖ
        CategoryTheory.CategoryStruct.id ((‚Üë(CategoryTheory.OplaxFunctor.toPrelaxFunctor F)).obj a))
  (mapCompIso :
    {a : B} ‚Üí
      {b : B} ‚Üí
        {c : B} ‚Üí
          (f : a ‚ü∂ b) ‚Üí
            (g : b ‚ü∂ c) ‚Üí
              (‚Üë(CategoryTheory.OplaxFunctor.toPrelaxFunctor F)).map (CategoryTheory.CategoryStruct.comp f g) ‚âÖ
                CategoryTheory.CategoryStruct.comp ((‚Üë(CategoryTheory.OplaxFunctor.toPrelaxFunctor F)).map f)
                  ((‚Üë(CategoryTheory.OplaxFunctor.toPrelaxFunctor F)).map g))
  (mapIdIso_hom : autoParam (‚àÄ {a : B}, (mapIdIso a).hom = CategoryTheory.OplaxFunctor.mapId F a) _auto‚úù)
  (mapCompIso_hom :
    autoParam
      (‚àÄ {a : B} {b : B} {c : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c),
        (mapCompIso f g).hom = CategoryTheory.OplaxFunctor.mapComp F f g)
      _auto‚úù¬π),
  sizeOf (CategoryTheory.OplaxFunctor.PseudoCore.mk mapIdIso mapCompIso) = 1)
<input>:16:103: expected token

 : (‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : VAdd Œ± Œ≤] {t : Set Œ≤} {a : Œ±} {x : Œ≤},
  (x ‚àà a +·µ• t) ‚Üî (‚àÉ (y : Œ≤), (y ‚àà t) ‚àß (a +·µ• y = x)))
failed to synthesize instance
  HVAdd Œ± (Set Œ≤) ?m.29 ; identifiers [Œ±, u_2, Œ≤, u_1, inst, VAdd, Œ±, Œ≤, t, Set, Œ≤, a, Œ±, x, Œ≤, x, a, t, y, Œ≤, y, t, a, y, x] (during elaboration) for (‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : VAdd Œ± Œ≤] {t : Set Œ≤} {a : Œ±} {x : Œ≤},
  (x ‚àà a +·µ• t) ‚Üî (‚àÉ (y : Œ≤), (y ‚àà t) ‚àß (a +·µ• y = x)))

 : (‚àÄ (M : Type u_1) [inst : CancelMonoidWithZero M] [inst_1 : DecidableEq M] [inst_2 : Fintype M] (a : M) (b : M),
  a / b = a / b)
failed to synthesize instance
  HDiv M M ?m.289 ; identifiers [M, u_1, inst, CancelMonoidWithZero, M, inst_1, DecidableEq, M, inst_2, Fintype, M, a, M, b, M, a, b, a, b] (during elaboration) for (‚àÄ (M : Type u_1) [inst : CancelMonoidWithZero M] [inst_1 : DecidableEq M] [inst_2 : Fintype M] (a : M) (b : M),
  a / b = a / b)

 : (‚àÄ {Œ± : Type u} [inst : Group Œ±] (self : GroupTopology Œ±), TopologicalGroup Œ±)
failed to synthesize instance
  TopologicalSpace Œ± ; identifiers [Œ±, u, inst, Group, Œ±, self, GroupTopology, Œ±, TopologicalGroup, Œ±] (during elaboration) for (‚àÄ {Œ± : Type u} [inst : Group Œ±] (self : GroupTopology Œ±), TopologicalGroup Œ±)

 : (‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Preorder Œ±] [inst_1 : Preorder Œ≤] [inst_2 : AddZeroClass Œ±]
  [inst_3 : AddZeroClass Œ≤] (self : Œ± ‚Üí+o Œ≤), Monotone (ZeroHom.toFun ‚Üë(OrderAddMonoidHom.toAddMonoidHom self)))
typeclass instance problem is stuck, it is often due to metavariables
  Preorder (?m.2761 self) ; identifiers [Œ±, u_1, Œ≤, u_2, inst, Preorder, Œ±, inst_1, Preorder, Œ≤, inst_2, AddZeroClass, Œ±, inst_3, AddZeroClass, Œ≤, self, Œ±, Œ≤, Monotone, ZeroHom.toFun, OrderAddMonoidHom.toAddMonoidHom, self] (during elaboration) for (‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Preorder Œ±] [inst_1 : Preorder Œ≤] [inst_2 : AddZeroClass Œ±]
  [inst_3 : AddZeroClass Œ≤] (self : Œ± ‚Üí+o Œ≤), Monotone (ZeroHom.toFun ‚Üë(OrderAddMonoidHom.toAddMonoidHom self)))

 : (‚àÄ {R : Type u_1} [inst : Ring R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {U : Submodule R M}
  {x : M} {y : M}, (x ‚â° y [SMOD U]) ‚Üî (Submodule.Quotient.mk x = Submodule.Quotient.mk y))
typeclass instance problem is stuck, it is often due to metavariables
  Module ?m.4151 M ; identifiers [R, u_1, inst, Ring, R, M, u_2, inst_1, AddCommGroup, M, inst_2, Module, R, M, U, Submodule, R, M, x, M, y, M, x, y, U, Submodule.Quotient.mk, x, Submodule.Quotient.mk, y] (during elaboration) for (‚àÄ {R : Type u_1} [inst : Ring R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {U : Submodule R M}
  {x : M} {y : M}, (x ‚â° y [SMOD U]) ‚Üî (Submodule.Quotient.mk x = Submodule.Quotient.mk y))

 : (‚àÄ {G : Type u_1} [inst : Monoid G] (a : G) (b : G), a / b = a / b)
failed to synthesize instance
  HDiv G G ?m.277 ; identifiers [G, u_1, inst, Monoid, G, a, G, b, G, a, b, a, b] (during elaboration) for (‚àÄ {G : Type u_1} [inst : Monoid G] (a : G) (b : G), a / b = a / b)

 : (‚àÄ {J : Type u‚ÇÅ} [inst : CategoryTheory.Category J] {C : Type u‚ÇÉ} [inst_1 : CategoryTheory.Category C]
  {F : CategoryTheory.Functor J C} {t : CategoryTheory.Limits.Cone F} (self : CategoryTheory.Limits.IsLimit t)
  (s : CategoryTheory.Limits.Cone F) (m : CategoryTheory.Limits.Cone.pt s ‚ü∂ CategoryTheory.Limits.Cone.pt t)
  (x :
    ‚àÄ (j : J),
      CategoryTheory.CategoryStruct.comp m (CategoryTheory.NatTrans.app (CategoryTheory.Limits.Cone.œÄ t) j) =
        CategoryTheory.NatTrans.app (CategoryTheory.Limits.Cone.œÄ s) j),
  m = CategoryTheory.Limits.IsLimit.lift self s)
unknown universe level 'u‚ÇÉ' ; identifiers [J, u‚ÇÅ, inst, CategoryTheory.Category, J, C, u‚ÇÉ, inst_1, CategoryTheory.Category, C, F, CategoryTheory.Functor, J, C, t, CategoryTheory.Limits.Cone, F, self, CategoryTheory.Limits.IsLimit, t, s, CategoryTheory.Limits.Cone, F, m, CategoryTheory.Limits.Cone.pt, s, CategoryTheory.Limits.Cone.pt, t, x, j, J, CategoryTheory.CategoryStruct.comp, m, CategoryTheory.NatTrans.app, CategoryTheory.Limits.Cone.œÄ, t, j, CategoryTheory.NatTrans.app, CategoryTheory.Limits.Cone.œÄ, s, j, m, CategoryTheory.Limits.IsLimit.lift, self, s] (during elaboration) for (‚àÄ {J : Type u‚ÇÅ} [inst : CategoryTheory.Category J] {C : Type u‚ÇÉ} [inst_1 : CategoryTheory.Category C]
  {F : CategoryTheory.Functor J C} {t : CategoryTheory.Limits.Cone F} (self : CategoryTheory.Limits.IsLimit t)
  (s : CategoryTheory.Limits.Cone F) (m : CategoryTheory.Limits.Cone.pt s ‚ü∂ CategoryTheory.Limits.Cone.pt t)
  (x :
    ‚àÄ (j : J),
      CategoryTheory.CategoryStruct.comp m (CategoryTheory.NatTrans.app (CategoryTheory.Limits.Cone.œÄ t) j) =
        CategoryTheory.NatTrans.app (CategoryTheory.Limits.Cone.œÄ s) j),
  m = CategoryTheory.Limits.IsLimit.lift self s)

 : (‚àÄ {X : TopCat} {x : ‚ÜëX} {y : ‚ÜëX} (e : Inseparable x y), nhds y ‚â§ nhds x)
type mismatch
  X
has type
  TopCat : Type (?u.3 + 1)
but is expected to have type
  Sort ?u.5 : Type ?u.5 ; identifiers [X, TopCat, x, X, y, X, e, Inseparable, x, y, nhds, y, nhds, x] (during elaboration) for (‚àÄ {X : TopCat} {x : ‚ÜëX} {y : ‚ÜëX} (e : Inseparable x y), nhds y ‚â§ nhds x)

 : (‚àÄ {Œ± : Type u_1} [inst : Sub Œ±] {f : Filter Œ±} {g : Filter Œ±} {s : Set Œ±},
  (s ‚àà f - g) ‚Üî (‚àÉ (t‚ÇÅ : Set Œ±), ‚àÉ (t‚ÇÇ : Set Œ±), (t‚ÇÅ ‚àà f) ‚àß ((t‚ÇÇ ‚àà g) ‚àß (t‚ÇÅ - t‚ÇÇ ‚äÜ s))))
failed to synthesize instance
  HSub (Filter Œ±) (Filter Œ±) ?m.804 ; identifiers [Œ±, u_1, inst, Sub, Œ±, f, Filter, Œ±, g, Filter, Œ±, s, Set, Œ±, s, f, g, t‚ÇÅ, Set, Œ±, t‚ÇÇ, Set, Œ±, t‚ÇÅ, f, t‚ÇÇ, g, t‚ÇÅ, t‚ÇÇ, s] (during elaboration) for (‚àÄ {Œ± : Type u_1} [inst : Sub Œ±] {f : Filter Œ±} {g : Filter Œ±} {s : Set Œ±},
  (s ‚àà f - g) ‚Üî (‚àÉ (t‚ÇÅ : Set Œ±), ‚àÉ (t‚ÇÇ : Set Œ±), (t‚ÇÅ ‚àà f) ‚àß ((t‚ÇÇ ‚àà g) ‚àß (t‚ÇÅ - t‚ÇÇ ‚äÜ s))))

 : (‚àÄ {G : Type u_1} {Œ± : Type u_2} [inst : One G] [inst_1 : SMul G Œ±] [inst_2 : MeasurableSpace Œ±] {s : Set Œ±}
  {Œº : autoParam (MeasureTheory.Measure Œ±) _auto‚úù} (self : MeasureTheory.IsFundamentalDomain G s),
  MeasureTheory.NullMeasurableSet s)
<input>:2:48: expected token

 : (‚àÄ {Œπ : Type u} {Œ± : (a : Œπ) ‚Üí Type v} [inst : (i : Œπ) ‚Üí Preorder (Œ± i)] (i : Œπ), Monotone (Function.eval i))
typeclass instance problem is stuck, it is often due to metavariables
  Preorder (?m.467 i i) ; identifiers [Œπ, u, Œ±, a, Œπ, v, inst, i, Œπ, Preorder, Œ±, i, i, Œπ, Monotone, Function.eval, i] (during elaboration) for (‚àÄ {Œπ : Type u} {Œ± : (a : Œπ) ‚Üí Type v} [inst : (i : Œπ) ‚Üí Preorder (Œ± i)] (i : Œπ), Monotone (Function.eval i))

 : (‚àÄ {Œ± : Type u_1} [inst : GeneralizedBooleanAlgebra Œ±] (a : Œ±) (b : Œ±), a - b = a - b)
failed to synthesize instance
  HSub Œ± Œ± ?m.435 ; identifiers [Œ±, u_1, inst, GeneralizedBooleanAlgebra, Œ±, a, Œ±, b, Œ±, a, b, a, b] (during elaboration) for (‚àÄ {Œ± : Type u_1} [inst : GeneralizedBooleanAlgebra Œ±] (a : Œ±) (b : Œ±), a - b = a - b)

 : (‚àÄ {R : Type u} [inst : Ring R] {Q : TypeMax} [inst_1 : AddCommGroup Q] [inst_2 : Module R Q] {M : Type (max u v)}
  {N : Type (max u v)} [inst_3 : AddCommGroup M] [inst_4 : AddCommGroup N] [inst_5 : Module R M] [inst_6 : Module R N]
  {i : M ‚Üí‚Çó[R] N} {f : M ‚Üí‚Çó[R] Q} (self : Module.Baer.ExtensionOf i f),
  LinearMap.range i ‚â§ LinearPMap.domain (Module.Baer.ExtensionOf.toLinearPMap self))
stuck at solving universe constraint
  max u ?u.9 =?= max u v
while trying to unify
  (M ‚Üí‚Çó[R] N) R R Ring.toSemiring Ring.toSemiring (RingHom.id R) M N ((M ‚Üí‚Çó[R] N) M inst_3) ((M ‚Üí‚Çó[R] N) N inst_4)
    inst_5 inst_6
with
  M ‚Üí‚Çó[R] N ; identifiers [R, u, inst, Ring, R, Q, TypeMax, inst_1, AddCommGroup, Q, inst_2, Module, R, Q, M, u, v, N, u, v, inst_3, AddCommGroup, M, inst_4, AddCommGroup, N, inst_5, Module, R, M, inst_6, Module, R, N, i, M, R, N, f, M, R, Q, self, Module.Baer.ExtensionOf, i, f, LinearMap.range, i, LinearPMap.domain, Module.Baer.ExtensionOf.toLinearPMap, self] (during elaboration) for (‚àÄ {R : Type u} [inst : Ring R] {Q : TypeMax} [inst_1 : AddCommGroup Q] [inst_2 : Module R Q] {M : Type (max u v)}
  {N : Type (max u v)} [inst_3 : AddCommGroup M] [inst_4 : AddCommGroup N] [inst_5 : Module R M] [inst_6 : Module R N]
  {i : M ‚Üí‚Çó[R] N} {f : M ‚Üí‚Çó[R] Q} (self : Module.Baer.ExtensionOf i f),
  LinearMap.range i ‚â§ LinearPMap.domain (Module.Baer.ExtensionOf.toLinearPMap self))

 : (‚àÄ (C : Type u) [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasTerminal C]
  [inst_2 : CategoryTheory.Limits.HasBinaryProducts C] (X : C) (Y : C),
  Œ≤_ X Y = CategoryTheory.Limits.prod.braiding X Y)
type mismatch
  CategoryTheory.Limits.prod.braiding X Y
has type
  X ‚®Ø Y ‚âÖ Y ‚®Ø X : Type ?u.6
but is expected to have type
  CategoryTheory.MonoidalCategory.tensorObj X Y ‚âÖ CategoryTheory.MonoidalCategory.tensorObj Y X : Type ?u.6 ; identifiers [C, u, inst, CategoryTheory.Category, C, inst_1, CategoryTheory.Limits.HasTerminal, C, inst_2, CategoryTheory.Limits.HasBinaryProducts, C, X, C, Y, C, X, Y, CategoryTheory.Limits.prod.braiding, X, Y] (during elaboration) for (‚àÄ (C : Type u) [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasTerminal C]
  [inst_2 : CategoryTheory.Limits.HasBinaryProducts C] (X : C) (Y : C),
  Œ≤_ X Y = CategoryTheory.Limits.prod.braiding X Y)

 : (‚àÄ {G : Type u_1} {Œ± : Type u_2} [inst : Zero G] [inst_1 : VAdd G Œ±] [inst_2 : MeasurableSpace Œ±] {s : Set Œ±}
  {Œº : autoParam (MeasureTheory.Measure Œ±) _auto‚úù} (self : MeasureTheory.IsAddFundamentalDomain G s),
  ‚àÄ·µê (x : Œ±) ‚àÇŒº, ‚àÉ (g : G), g +·µ• x ‚àà s)
<input>:2:48: expected token

 : (‚àÄ {X : TopCat} {x : ‚ÜëX} {y : ‚ÜëX} (e : Inseparable x y), nhds x ‚â§ nhds y)
type mismatch
  X
has type
  TopCat : Type (?u.3 + 1)
but is expected to have type
  Sort ?u.5 : Type ?u.5 ; identifiers [X, TopCat, x, X, y, X, e, Inseparable, x, y, nhds, x, nhds, y] (during elaboration) for (‚àÄ {X : TopCat} {x : ‚ÜëX} {y : ‚ÜëX} (e : Inseparable x y), nhds x ‚â§ nhds y)

 : (‚àÄ (self : YoungDiagram), IsLowerSet ‚Üë(YoungDiagram.cells self))
typeclass instance problem is stuck, it is often due to metavariables
  LE (?m.324 self) ; identifiers [self, YoungDiagram, IsLowerSet, YoungDiagram.cells, self] (during elaboration) for (‚àÄ (self : YoungDiagram), IsLowerSet ‚Üë(YoungDiagram.cells self))

 : (‚àÄ {M : Type u_1} [inst : AddCommMonoid M] {S : AddSubmonoid M} {N : Type u_2} [inst_1 : AddCommMonoid N]
  (self : AddSubmonoid.LocalizationMap S N) (x : M) (y : M),
  (ZeroHom.toFun (‚Üë(AddSubmonoid.LocalizationMap.toAddMonoidHom self)) x =
      ZeroHom.toFun (‚Üë(AddSubmonoid.LocalizationMap.toAddMonoidHom self)) y) ‚Üî
    (‚àÉ (c : { x : M // x ‚àà S }), ‚Üëc + x = ‚Üëc + y))
typeclass instance problem is stuck, it is often due to metavariables
  Zero (?m.9706 self x y) ; identifiers [M, u_1, inst, AddCommMonoid, M, S, AddSubmonoid, M, N, u_2, inst_1, AddCommMonoid, N, self, AddSubmonoid.LocalizationMap, S, N, x, M, y, M, ZeroHom.toFun, AddSubmonoid.LocalizationMap.toAddMonoidHom, self, x, ZeroHom.toFun, AddSubmonoid.LocalizationMap.toAddMonoidHom, self, y, c, x, M, x, S, c, x, c, y] (during elaboration) for (‚àÄ {M : Type u_1} [inst : AddCommMonoid M] {S : AddSubmonoid M} {N : Type u_2} [inst_1 : AddCommMonoid N]
  (self : AddSubmonoid.LocalizationMap S N) (x : M) (y : M),
  (ZeroHom.toFun (‚Üë(AddSubmonoid.LocalizationMap.toAddMonoidHom self)) x =
      ZeroHom.toFun (‚Üë(AddSubmonoid.LocalizationMap.toAddMonoidHom self)) y) ‚Üî
    (‚àÉ (c : { x : M // x ‚àà S }), ‚Üëc + x = ‚Üëc + y))

 : (‚àÄ {Œ± : Type u_1} {s : Set Œ±} {a : Œ±} [inst : Star Œ±], (a ‚àà star s) ‚Üî (star a ‚àà s))
failed to synthesize instance
  Star (Set Œ±) ; identifiers [Œ±, u_1, s, Set, Œ±, a, Œ±, inst, Star, Œ±, a, star, s, star, a, s] (during elaboration) for (‚àÄ {Œ± : Type u_1} {s : Set Œ±} {a : Œ±} [inst : Star Œ±], (a ‚àà star s) ‚Üî (star a ‚àà s))

 : (‚àÄ {Œπ : Type uŒπ} {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] [inst_2 : FiniteDimensional ‚Ñù E]
  {H : Type uH} [inst_3 : TopologicalSpace H] {I : ModelWithCorners ‚Ñù E H} {M : Type uM} [inst_4 : TopologicalSpace M]
  [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] {s : Set M} [inst_7 : T2Space M]
  {f : SmoothBumpCovering Œπ I M s} {U : (a : M) ‚Üí Set M},
  (BumpCovering.IsSubordinate (SmoothBumpCovering.toBumpCovering f) fun (i : Œπ) ‚Ü¶ U (SmoothBumpCovering.c s f i)) ‚Üî
    (SmoothBumpCovering.IsSubordinate f U))
unknown universe level 'uH' ; identifiers [Œπ, uŒπ, E, uE, inst, NormedAddCommGroup, E, inst_1, NormedSpace, E, inst_2, FiniteDimensional, E, H, uH, inst_3, TopologicalSpace, H, I, ModelWithCorners, E, H, M, uM, inst_4, TopologicalSpace, M, inst_5, ChartedSpace, H, M, inst_6, SmoothManifoldWithCorners, I, M, s, Set, M, inst_7, T2Space, M, f, SmoothBumpCovering, Œπ, I, M, s, U, a, M, Set, M, BumpCovering.IsSubordinate, SmoothBumpCovering.toBumpCovering, f, i, Œπ, U, SmoothBumpCovering.c, s, f, i, SmoothBumpCovering.IsSubordinate, f, U] (during elaboration) for (‚àÄ {Œπ : Type uŒπ} {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] [inst_2 : FiniteDimensional ‚Ñù E]
  {H : Type uH} [inst_3 : TopologicalSpace H] {I : ModelWithCorners ‚Ñù E H} {M : Type uM} [inst_4 : TopologicalSpace M]
  [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] {s : Set M} [inst_7 : T2Space M]
  {f : SmoothBumpCovering Œπ I M s} {U : (a : M) ‚Üí Set M},
  (BumpCovering.IsSubordinate (SmoothBumpCovering.toBumpCovering f) fun (i : Œπ) ‚Ü¶ U (SmoothBumpCovering.c s f i)) ‚Üî
    (SmoothBumpCovering.IsSubordinate f U))

 : (‚àÄ {Œπ : Type u_1} {V : Type u} [inst : CategoryTheory.Category V] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms V]
  {c : ComplexShape Œπ} {A : HomologicalComplex V c} {B : HomologicalComplex V c} [inst_2 : SizeOf Œπ] [inst_3 : SizeOf V]
  (f : (i : Œπ) ‚Üí HomologicalComplex.X A i ‚ü∂ HomologicalComplex.X B i)
  (comm' :
    autoParam
      (‚àÄ (i : Œπ) (j : Œπ) (a : ComplexShape.Rel c i j),
        CategoryTheory.CategoryStruct.comp (f i) (HomologicalComplex.d B i j) =
          CategoryTheory.CategoryStruct.comp (HomologicalComplex.d A i j) (f j))
      _auto‚úù),
  sizeOf (HomologicalComplex.Hom.mk f) = 1)
<input>:9:11: expected token

 : (‚àÄ {Œ± : Type u} (m : MeasureTheory.OuterMeasure Œ±) {s : Set Œ±},
  (MeasurableSet s) ‚Üî (‚àÄ (t : Set Œ±), ‚Üëm t = ‚Üëm (t ‚à© s) + ‚Üëm (t \ s)))
failed to synthesize instance
  MeasurableSpace Œ± ; identifiers [Œ±, u, m, MeasureTheory.OuterMeasure, Œ±, s, Set, Œ±, MeasurableSet, s, t, Set, Œ±, m, t, m, t, s, m, t, s] (during elaboration) for (‚àÄ {Œ± : Type u} (m : MeasureTheory.OuterMeasure Œ±) {s : Set Œ±},
  (MeasurableSet s) ‚Üî (‚àÄ (t : Set Œ±), ‚Üëm t = ‚Üëm (t ‚à© s) + ‚Üëm (t \ s)))

 : (‚àÄ {L : FirstOrder.Language} (M : Type w) [inst : FirstOrder.Language.Structure L M]
  {œÜ : FirstOrder.Language.Sentence L}, (M ‚ä® FirstOrder.Language.Formula.not œÜ) ‚Üî (¬¨(M ‚ä® œÜ)))
ambiguous, possible interpretations 
  M ‚ä® ?m.497 : Prop
  
  M ‚ä® FirstOrder.Language.Formula.not œÜ : Prop ; identifiers [L, FirstOrder.Language, M, w, inst, FirstOrder.Language.Structure, L, M, œÜ, FirstOrder.Language.Sentence, L, M, FirstOrder.Language.Formula.not, œÜ, M, FirstOrder.Language.Formula.not, œÜ, M, œÜ, M, œÜ] (during elaboration) for (‚àÄ {L : FirstOrder.Language} (M : Type w) [inst : FirstOrder.Language.Structure L M]
  {œÜ : FirstOrder.Language.Sentence L}, (M ‚ä® FirstOrder.Language.Formula.not œÜ) ‚Üî (¬¨(M ‚ä® œÜ)))

 : (‚àÄ (A : Type u_1) [inst : CommRing A] (K : Type u_2) [inst_1 : Field K] [inst_2 : Algebra A K]
  (a : ValuationRing.ValueGroup A K) (b : ValuationRing.ValueGroup A K), (a < b) ‚Üî (a < b))
failed to synthesize instance
  LT (ValuationRing.ValueGroup A K) ; identifiers [A, u_1, inst, CommRing, A, K, u_2, inst_1, Field, K, inst_2, Algebra, A, K, a, ValuationRing.ValueGroup, A, K, b, ValuationRing.ValueGroup, A, K, a, b, a, b] (during elaboration) for (‚àÄ (A : Type u_1) [inst : CommRing A] (K : Type u_2) [inst_1 : Field K] [inst_2 : Algebra A K]
  (a : ValuationRing.ValueGroup A K) (b : ValuationRing.ValueGroup A K), (a < b) ‚Üî (a < b))

 : (‚àÄ {P : AlgebraicGeometry.AffineTargetMorphismProperty}
  (self : AlgebraicGeometry.AffineTargetMorphismProperty.IsLocal P) {X : AlgebraicGeometry.Scheme}
  {Y : AlgebraicGeometry.Scheme} [inst : AlgebraicGeometry.IsAffine Y] (f : X ‚ü∂ Y)
  (r :
    ‚Üë((CategoryTheory.Functor.toPrefunctor
            (AlgebraicGeometry.PresheafedSpace.presheaf
              (AlgebraicGeometry.SheafedSpace.toPresheafedSpace
                (AlgebraicGeometry.LocallyRingedSpace.toSheafedSpace
                  (AlgebraicGeometry.Scheme.toLocallyRingedSpace Y))))).obj
        (Opposite.op ‚ä§)))
  (a : P f), P (f ‚à£_ AlgebraicGeometry.Scheme.basicOpen Y r))
synthesized type class instance is not definitionally equal to expression inferred by typing rules, synthesized
  CategoryTheory.Category.opposite
inferred
  CategoryTheory.Category.opposite ; identifiers [P, AlgebraicGeometry.AffineTargetMorphismProperty, self, AlgebraicGeometry.AffineTargetMorphismProperty.IsLocal, P, X, AlgebraicGeometry.Scheme, Y, AlgebraicGeometry.Scheme, inst, AlgebraicGeometry.IsAffine, Y, f, X, Y, r, CategoryTheory.Functor.toPrefunctor, AlgebraicGeometry.PresheafedSpace.presheaf, AlgebraicGeometry.SheafedSpace.toPresheafedSpace, AlgebraicGeometry.LocallyRingedSpace.toSheafedSpace, AlgebraicGeometry.Scheme.toLocallyRingedSpace, Y, obj, Opposite.op, a, P, f, P, f, AlgebraicGeometry.Scheme.basicOpen, Y, r] (during elaboration) for (‚àÄ {P : AlgebraicGeometry.AffineTargetMorphismProperty}
  (self : AlgebraicGeometry.AffineTargetMorphismProperty.IsLocal P) {X : AlgebraicGeometry.Scheme}
  {Y : AlgebraicGeometry.Scheme} [inst : AlgebraicGeometry.IsAffine Y] (f : X ‚ü∂ Y)
  (r :
    ‚Üë((CategoryTheory.Functor.toPrefunctor
            (AlgebraicGeometry.PresheafedSpace.presheaf
              (AlgebraicGeometry.SheafedSpace.toPresheafedSpace
                (AlgebraicGeometry.LocallyRingedSpace.toSheafedSpace
                  (AlgebraicGeometry.Scheme.toLocallyRingedSpace Y))))).obj
        (Opposite.op ‚ä§)))
  (a : P f), P (f ‚à£_ AlgebraicGeometry.Scheme.basicOpen Y r))

 : (‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} {f : X ‚ü∂ Y}
  {F : CategoryTheory.Limits.MonoFactorisation f} [inst_1 : SizeOf C]
  (lift :
    (F' : CategoryTheory.Limits.MonoFactorisation f) ‚Üí
      CategoryTheory.Limits.MonoFactorisation.I F ‚ü∂ CategoryTheory.Limits.MonoFactorisation.I F')
  (lift_fac :
    autoParam
      (‚àÄ (F' : CategoryTheory.Limits.MonoFactorisation f),
        CategoryTheory.CategoryStruct.comp (lift F') (CategoryTheory.Limits.MonoFactorisation.m F') =
          CategoryTheory.Limits.MonoFactorisation.m F)
      _auto‚úù),
  sizeOf (CategoryTheory.Limits.IsImage.mk lift) = 1)
<input>:11:11: expected token

 : (‚àÄ {Œ± : Type u} [inst : SizeOf Œ±], sizeOf RegularExpression.zero = 1)
typeclass instance problem is stuck, it is often due to metavariables
  SizeOf (RegularExpression ?m.6756) ; identifiers [Œ±, u, inst, SizeOf, Œ±, sizeOf, RegularExpression.zero] (during elaboration) for (‚àÄ {Œ± : Type u} [inst : SizeOf Œ±], sizeOf RegularExpression.zero = 1)

 : (‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : NonAssocSemiring Œ±] [inst_1 : Preorder Œ±] [inst_2 : NonAssocSemiring Œ≤]
  [inst_3 : Preorder Œ≤] (self : Œ± ‚Üí+*o Œ≤), Monotone (OneHom.toFun ‚Üë‚Üë(OrderRingHom.toRingHom self)))
type mismatch
  self.toRingHom
has type
  Œ± ‚Üí+* Œ≤ : Type (max u_1 u_2)
but is expected to have type
  OneHom (?m.1709 self) (?m.1710 self) : Type (max ?u.184 ?u.183) ; identifiers [Œ±, u_1, Œ≤, u_2, inst, NonAssocSemiring, Œ±, inst_1, Preorder, Œ±, inst_2, NonAssocSemiring, Œ≤, inst_3, Preorder, Œ≤, self, Œ±, Œ≤, Monotone, OneHom.toFun, OrderRingHom.toRingHom, self] (during elaboration) for (‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : NonAssocSemiring Œ±] [inst_1 : Preorder Œ±] [inst_2 : NonAssocSemiring Œ≤]
  [inst_3 : Preorder Œ≤] (self : Œ± ‚Üí+*o Œ≤), Monotone (OneHom.toFun ‚Üë‚Üë(OrderRingHom.toRingHom self)))

 : (‚àÄ {G : Type u_1} [inst : Group G] (n : ‚Ñï) (q : G),
  (q ‚àà lowerCentralSeries G (n + 1)) ‚Üî
    (q ‚àà
      Subgroup.closure
        {x : G | ‚àÉ (p : G), (p ‚àà lowerCentralSeries G n) ‚àß (‚àÉ (q : G), (q ‚àà ‚ä§) ‚àß (p * q * p‚Åª¬π * q‚Åª¬π = x))}))
typeclass instance problem is stuck, it is often due to metavariables
  Membership G (?m.2897 n q‚úù x p q) ; identifiers [G, u_1, inst, Group, G, n, q, G, q, lowerCentralSeries, G, n, q, Subgroup.closure, x, G, p, G, p, lowerCentralSeries, G, n, q, G, q, p, q, p, q, x] (during elaboration) for (‚àÄ {G : Type u_1} [inst : Group G] (n : ‚Ñï) (q : G),
  (q ‚àà lowerCentralSeries G (n + 1)) ‚Üî
    (q ‚àà
      Subgroup.closure
        {x : G | ‚àÉ (p : G), (p ‚àà lowerCentralSeries G n) ‚àß (‚àÉ (q : G), (q ‚àà ‚ä§) ‚àß (p * q * p‚Åª¬π * q‚Åª¬π = x))}))

 : (‚àÄ {C : Type u} [inst : SizeOf C], sizeOf CategoryTheory.FreeMonoidalCategory.Unit = 1)
typeclass instance problem is stuck, it is often due to metavariables
  SizeOf (CategoryTheory.FreeMonoidalCategory ?m.6756) ; identifiers [C, u, inst, SizeOf, C, sizeOf, CategoryTheory.FreeMonoidalCategory.Unit] (during elaboration) for (‚àÄ {C : Type u} [inst : SizeOf C], sizeOf CategoryTheory.FreeMonoidalCategory.Unit = 1)

 : (‚àÄ (C : Type u) [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C]
  [inst_2 : CategoryTheory.Limits.HasBinaryCoproducts C] (P : C) (Q : C),
  Œ≤_ P Q = CategoryTheory.Limits.coprod.braiding P Q)
type mismatch
  CategoryTheory.Limits.coprod.braiding P Q
has type
  P ‚®ø Q ‚âÖ Q ‚®ø P : Type ?u.6
but is expected to have type
  CategoryTheory.MonoidalCategory.tensorObj P Q ‚âÖ CategoryTheory.MonoidalCategory.tensorObj Q P : Type ?u.6 ; identifiers [C, u, inst, CategoryTheory.Category, C, inst_1, CategoryTheory.Limits.HasInitial, C, inst_2, CategoryTheory.Limits.HasBinaryCoproducts, C, P, C, Q, C, P, Q, CategoryTheory.Limits.coprod.braiding, P, Q] (during elaboration) for (‚àÄ (C : Type u) [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C]
  [inst_2 : CategoryTheory.Limits.HasBinaryCoproducts C] (P : C) (Q : C),
  Œ≤_ P Q = CategoryTheory.Limits.coprod.braiding P Q)

 : (‚àÄ {Œ± : Type u_1} [inst : Mul Œ±] {s : Set Œ±} {t : Set Œ±} {a : Œ±},
  (a ‚àà s * t) ‚Üî (‚àÉ (x : Œ±), ‚àÉ (y : Œ±), (x ‚àà s) ‚àß ((y ‚àà t) ‚àß (x * y = a))))
failed to synthesize instance
  HMul (Set Œ±) (Set Œ±) ?m.1969 ; identifiers [Œ±, u_1, inst, Mul, Œ±, s, Set, Œ±, t, Set, Œ±, a, Œ±, a, s, t, x, Œ±, y, Œ±, x, s, y, t, x, y, a] (during elaboration) for (‚àÄ {Œ± : Type u_1} [inst : Mul Œ±] {s : Set Œ±} {t : Set Œ±} {a : Œ±},
  (a ‚àà s * t) ‚Üî (‚àÉ (x : Œ±), ‚àÉ (y : Œ±), (x ‚àà s) ‚àß ((y ‚àà t) ‚àß (x * y = a))))

 : (‚àÄ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommGroup M] (self : Module.Core R M) (r : R) (x : M)
  (y : M), r ‚Ä¢ (x + y) = r ‚Ä¢ x + r ‚Ä¢ y)
failed to synthesize instance
  HSMul R M ?m.54 ; identifiers [R, u_1, M, u_2, inst, Semiring, R, inst_1, AddCommGroup, M, self, Module.Core, R, M, r, R, x, M, y, M, r, x, y, r, x, r, y] (during elaboration) for (‚àÄ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommGroup M] (self : Module.Core R M) (r : R) (x : M)
  (y : M), r ‚Ä¢ (x + y) = r ‚Ä¢ x + r ‚Ä¢ y)

 : (‚àÄ {G : Type u_1} {Œ± : Type u_2} [inst : One G] [inst_1 : SMul G Œ±] [inst_2 : MeasurableSpace Œ±] {s : Set Œ±}
  {Œº : autoParam (MeasureTheory.Measure Œ±) _auto‚úù} (self : MeasureTheory.IsFundamentalDomain G s),
  Pairwise (MeasureTheory.AEDisjoint Œº on fun (g : G) ‚Ü¶ g ‚Ä¢ s))
<input>:2:48: expected token

 : (‚àÄ {R : Type u} [inst : SizeOf R], sizeOf Rack.PreEnvelGroup.unit = 1)
typeclass instance problem is stuck, it is often due to metavariables
  SizeOf (Rack.PreEnvelGroup ?m.6756) ; identifiers [R, u, inst, SizeOf, R, sizeOf, Rack.PreEnvelGroup.unit] (during elaboration) for (‚àÄ {R : Type u} [inst : SizeOf R], sizeOf Rack.PreEnvelGroup.unit = 1)

 : (‚àÄ {R : Type u_1} [inst : Semiring R] (h : IsField R) (a : R) (b : R), a / b = a / b)
failed to synthesize instance
  HDiv R R ?m.293 ; identifiers [R, u_1, inst, Semiring, R, h, IsField, R, a, R, b, R, a, b, a, b] (during elaboration) for (‚àÄ {R : Type u_1} [inst : Semiring R] (h : IsField R) (a : R) (b : R), a / b = a / b)

 : (‚àÄ {X : TopCat} (x : ‚ÜëX) (a : TopologicalSpace.OpenNhds x) (b : TopologicalSpace.OpenNhds x), (a < b) ‚Üî (a < b))
type mismatch
  X
has type
  TopCat : Type (?u.3 + 1)
but is expected to have type
  Sort ?u.5 : Type ?u.5 ; identifiers [X, TopCat, x, X, a, TopologicalSpace.OpenNhds, x, b, TopologicalSpace.OpenNhds, x, a, b, a, b] (during elaboration) for (‚àÄ {X : TopCat} (x : ‚ÜëX) (a : TopologicalSpace.OpenNhds x) (b : TopologicalSpace.OpenNhds x), (a < b) ‚Üî (a < b))

 : (‚àÄ {J : Type u_2} [inst : CategoryTheory.SmallCategory J] [inst_1 : CategoryTheory.IsFiltered J]
  (F : CategoryTheory.Functor J GroupCat) (a : ‚Üë(GroupCat.FilteredColimits.G F)) (b : ‚Üë(GroupCat.FilteredColimits.G F)),
  a / b = a / b)
type mismatch
  GroupCat.FilteredColimits.G F
has type
  MonCat : Type ((max ?u.50 u_2) + 1)
but is expected to have type
  Sort ?u.49 : Type ?u.49 ; identifiers [J, u_2, inst, CategoryTheory.SmallCategory, J, inst_1, CategoryTheory.IsFiltered, J, F, CategoryTheory.Functor, J, GroupCat, a, GroupCat.FilteredColimits.G, F, b, GroupCat.FilteredColimits.G, F, a, b, a, b] (during elaboration) for (‚àÄ {J : Type u_2} [inst : CategoryTheory.SmallCategory J] [inst_1 : CategoryTheory.IsFiltered J]
  (F : CategoryTheory.Functor J GroupCat) (a : ‚Üë(GroupCat.FilteredColimits.G F)) (b : ‚Üë(GroupCat.FilteredColimits.G F)),
  a / b = a / b)

 : (‚àÄ {Œ± : Type u_1} {m : MeasurableSpace Œ±} {f : (a : Œ±) ‚Üí Œ±} {Œº : autoParam (MeasureTheory.Measure Œ±) _auto‚úù}
  (self : Ergodic f), MeasureTheory.MeasurePreserving f)
<input>:1:109: expected token

 : (‚àÄ {Œπ : Type uŒπ} {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] {H : Type uH}
  [inst_2 : TopologicalSpace H] {I : ModelWithCorners ‚Ñù E H} {M : Type uM} [inst_3 : TopologicalSpace M]
  [inst_4 : ChartedSpace H M] {s : optParam (Set M) Set.univ} (self : SmoothPartitionOfUnity Œπ I M s) (x : M),
  ‚àë·∂† (i : Œπ), ‚Üë(SmoothPartitionOfUnity.toFun s self i) x ‚â§ 1)
unknown universe level 'uH' ; identifiers [Œπ, uŒπ, E, uE, inst, NormedAddCommGroup, E, inst_1, NormedSpace, E, H, uH, inst_2, TopologicalSpace, H, I, ModelWithCorners, E, H, M, uM, inst_3, TopologicalSpace, M, inst_4, ChartedSpace, H, M, s, optParam, Set, M, Set.univ, self, SmoothPartitionOfUnity, Œπ, I, M, s, x, M, i, Œπ, SmoothPartitionOfUnity.toFun, s, self, i, x] (during elaboration) for (‚àÄ {Œπ : Type uŒπ} {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] {H : Type uH}
  [inst_2 : TopologicalSpace H] {I : ModelWithCorners ‚Ñù E H} {M : Type uM} [inst_3 : TopologicalSpace M]
  [inst_4 : ChartedSpace H M] {s : optParam (Set M) Set.univ} (self : SmoothPartitionOfUnity Œπ I M s) (x : M),
  ‚àë·∂† (i : Œπ), ‚Üë(SmoothPartitionOfUnity.toFun s self i) x ‚â§ 1)

 : (‚àÄ {ùïú : Type u} [inst : NontriviallyNormedField ùïú] {F : Type v} [inst_1 : NormedAddCommGroup F]
  [inst_2 : NormedSpace ùïú F] {f : (a : ùïú) ‚Üí F} {f' : F} {x : ùïú},
  (HasStrictDerivAt f f' x) ‚Üî (HasStrictFDerivAt f (ContinuousLinearMap.smulRight 1 f') x))
typeclass instance problem is stuck, it is often due to metavariables
  NormedSpace ?m.8177 F ; identifiers [ùïú, u, inst, NontriviallyNormedField, ùïú, F, v, inst_1, NormedAddCommGroup, F, inst_2, NormedSpace, ùïú, F, f, a, ùïú, F, f', F, x, ùïú, HasStrictDerivAt, f, f', x, HasStrictFDerivAt, f, ContinuousLinearMap.smulRight, f', x] (during elaboration) for (‚àÄ {ùïú : Type u} [inst : NontriviallyNormedField ùïú] {F : Type v} [inst_1 : NormedAddCommGroup F]
  [inst_2 : NormedSpace ùïú F] {f : (a : ùïú) ‚Üí F} {f' : F} {x : ùïú},
  (HasStrictDerivAt f f' x) ‚Üî (HasStrictFDerivAt f (ContinuousLinearMap.smulRight 1 f') x))

 : (‚àÄ {R : Type u} [inst : CommRing R] {W : WeierstrassCurve R} [inst_1 : SizeOf R],
  sizeOf WeierstrassCurve.Point.zero = 1)
typeclass instance problem is stuck, it is often due to metavariables
  SizeOf (WeierstrassCurve.Point ?m.7627) ; identifiers [R, u, inst, CommRing, R, W, WeierstrassCurve, R, inst_1, SizeOf, R, sizeOf, WeierstrassCurve.Point.zero] (during elaboration) for (‚àÄ {R : Type u} [inst : CommRing R] {W : WeierstrassCurve R} [inst_1 : SizeOf R],
  sizeOf WeierstrassCurve.Point.zero = 1)

 : (‚àÄ {Œ± : Type u_1} [inst : Div Œ±] {s : Set Œ±} {t : Set Œ±} {a : Œ±},
  (a ‚àà s / t) ‚Üî (‚àÉ (x : Œ±), ‚àÉ (y : Œ±), (x ‚àà s) ‚àß ((y ‚àà t) ‚àß (x / y = a))))
failed to synthesize instance
  HDiv (Set Œ±) (Set Œ±) ?m.284 ; identifiers [Œ±, u_1, inst, Div, Œ±, s, Set, Œ±, t, Set, Œ±, a, Œ±, a, s, t, x, Œ±, y, Œ±, x, s, y, t, x, y, a] (during elaboration) for (‚àÄ {Œ± : Type u_1} [inst : Div Œ±] {s : Set Œ±} {t : Set Œ±} {a : Œ±},
  (a ‚àà s / t) ‚Üî (‚àÉ (x : Œ±), ‚àÉ (y : Œ±), (x ‚àà s) ‚àß ((y ‚àà t) ‚àß (x / y = a))))

 : (‚àÄ {B : Type u‚ÇÅ} [inst : CategoryTheory.Bicategory B] {C : Type u‚ÇÇ} [inst_1 : CategoryTheory.Bicategory C]
  {F : CategoryTheory.OplaxFunctor B C} [inst_2 : SizeOf B] [inst_3 : SizeOf C]
  (mapIdIso :
    (a : B) ‚Üí
      (‚Üë(CategoryTheory.OplaxFunctor.toPrelaxFunctor F)).map (CategoryTheory.CategoryStruct.id a) ‚âÖ
        CategoryTheory.CategoryStruct.id ((‚Üë(CategoryTheory.OplaxFunctor.toPrelaxFunctor F)).obj a))
  (mapCompIso :
    {a : B} ‚Üí
      {b : B} ‚Üí
        {c : B} ‚Üí
          (f : a ‚ü∂ b) ‚Üí
            (g : b ‚ü∂ c) ‚Üí
              (‚Üë(CategoryTheory.OplaxFunctor.toPrelaxFunctor F)).map (CategoryTheory.CategoryStruct.comp f g) ‚âÖ
                CategoryTheory.CategoryStruct.comp ((‚Üë(CategoryTheory.OplaxFunctor.toPrelaxFunctor F)).map f)
                  ((‚Üë(CategoryTheory.OplaxFunctor.toPrelaxFunctor F)).map g))
  (mapIdIso_hom : autoParam (‚àÄ {a : B}, (mapIdIso a).hom = CategoryTheory.OplaxFunctor.mapId F a) _auto‚úù)
  (mapCompIso_hom :
    autoParam
      (‚àÄ {a : B} {b : B} {c : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c),
        (mapCompIso f g).hom = CategoryTheory.OplaxFunctor.mapComp F f g)
      _auto‚úù¬π),
  sizeOf (CategoryTheory.OplaxFunctor.PseudoCore.mk mapIdIso mapCompIso) = 1)
<input>:16:103: expected token

 : (‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : VAdd Œ± Œ≤] {t : Set Œ≤} {a : Œ±} {x : Œ≤},
  (x ‚àà a +·µ• t) ‚Üî (‚àÉ (y : Œ≤), (y ‚àà t) ‚àß (a +·µ• y = x)))
failed to synthesize instance
  HVAdd Œ± (Set Œ≤) ?m.29 ; identifiers [Œ±, u_2, Œ≤, u_1, inst, VAdd, Œ±, Œ≤, t, Set, Œ≤, a, Œ±, x, Œ≤, x, a, t, y, Œ≤, y, t, a, y, x] (during elaboration) for (‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : VAdd Œ± Œ≤] {t : Set Œ≤} {a : Œ±} {x : Œ≤},
  (x ‚àà a +·µ• t) ‚Üî (‚àÉ (y : Œ≤), (y ‚àà t) ‚àß (a +·µ• y = x)))

 : (‚àÄ (M : Type u_1) [inst : CancelMonoidWithZero M] [inst_1 : DecidableEq M] [inst_2 : Fintype M] (a : M) (b : M),
  a / b = a / b)
failed to synthesize instance
  HDiv M M ?m.289 ; identifiers [M, u_1, inst, CancelMonoidWithZero, M, inst_1, DecidableEq, M, inst_2, Fintype, M, a, M, b, M, a, b, a, b] (during elaboration) for (‚àÄ (M : Type u_1) [inst : CancelMonoidWithZero M] [inst_1 : DecidableEq M] [inst_2 : Fintype M] (a : M) (b : M),
  a / b = a / b)

 : (‚àÄ {Œ± : Type u} [inst : Group Œ±] (self : GroupTopology Œ±), TopologicalGroup Œ±)
failed to synthesize instance
  TopologicalSpace Œ± ; identifiers [Œ±, u, inst, Group, Œ±, self, GroupTopology, Œ±, TopologicalGroup, Œ±] (during elaboration) for (‚àÄ {Œ± : Type u} [inst : Group Œ±] (self : GroupTopology Œ±), TopologicalGroup Œ±)

 : (‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Preorder Œ±] [inst_1 : Preorder Œ≤] [inst_2 : AddZeroClass Œ±]
  [inst_3 : AddZeroClass Œ≤] (self : Œ± ‚Üí+o Œ≤), Monotone (ZeroHom.toFun ‚Üë(OrderAddMonoidHom.toAddMonoidHom self)))
typeclass instance problem is stuck, it is often due to metavariables
  Preorder (?m.2761 self) ; identifiers [Œ±, u_1, Œ≤, u_2, inst, Preorder, Œ±, inst_1, Preorder, Œ≤, inst_2, AddZeroClass, Œ±, inst_3, AddZeroClass, Œ≤, self, Œ±, Œ≤, Monotone, ZeroHom.toFun, OrderAddMonoidHom.toAddMonoidHom, self] (during elaboration) for (‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Preorder Œ±] [inst_1 : Preorder Œ≤] [inst_2 : AddZeroClass Œ±]
  [inst_3 : AddZeroClass Œ≤] (self : Œ± ‚Üí+o Œ≤), Monotone (ZeroHom.toFun ‚Üë(OrderAddMonoidHom.toAddMonoidHom self)))

 : (‚àÄ {R : Type u_1} [inst : Ring R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {U : Submodule R M}
  {x : M} {y : M}, (x ‚â° y [SMOD U]) ‚Üî (Submodule.Quotient.mk x = Submodule.Quotient.mk y))
typeclass instance problem is stuck, it is often due to metavariables
  Module ?m.4151 M ; identifiers [R, u_1, inst, Ring, R, M, u_2, inst_1, AddCommGroup, M, inst_2, Module, R, M, U, Submodule, R, M, x, M, y, M, x, y, U, Submodule.Quotient.mk, x, Submodule.Quotient.mk, y] (during elaboration) for (‚àÄ {R : Type u_1} [inst : Ring R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {U : Submodule R M}
  {x : M} {y : M}, (x ‚â° y [SMOD U]) ‚Üî (Submodule.Quotient.mk x = Submodule.Quotient.mk y))

 : (‚àÄ {G : Type u_1} [inst : Monoid G] (a : G) (b : G), a / b = a / b)
failed to synthesize instance
  HDiv G G ?m.277 ; identifiers [G, u_1, inst, Monoid, G, a, G, b, G, a, b, a, b] (during elaboration) for (‚àÄ {G : Type u_1} [inst : Monoid G] (a : G) (b : G), a / b = a / b)

 : (‚àÄ {J : Type u‚ÇÅ} [inst : CategoryTheory.Category J] {C : Type u‚ÇÉ} [inst_1 : CategoryTheory.Category C]
  {F : CategoryTheory.Functor J C} {t : CategoryTheory.Limits.Cone F} (self : CategoryTheory.Limits.IsLimit t)
  (s : CategoryTheory.Limits.Cone F) (m : CategoryTheory.Limits.Cone.pt s ‚ü∂ CategoryTheory.Limits.Cone.pt t)
  (x :
    ‚àÄ (j : J),
      CategoryTheory.CategoryStruct.comp m (CategoryTheory.NatTrans.app (CategoryTheory.Limits.Cone.œÄ t) j) =
        CategoryTheory.NatTrans.app (CategoryTheory.Limits.Cone.œÄ s) j),
  m = CategoryTheory.Limits.IsLimit.lift self s)
unknown universe level 'u‚ÇÉ' ; identifiers [J, u‚ÇÅ, inst, CategoryTheory.Category, J, C, u‚ÇÉ, inst_1, CategoryTheory.Category, C, F, CategoryTheory.Functor, J, C, t, CategoryTheory.Limits.Cone, F, self, CategoryTheory.Limits.IsLimit, t, s, CategoryTheory.Limits.Cone, F, m, CategoryTheory.Limits.Cone.pt, s, CategoryTheory.Limits.Cone.pt, t, x, j, J, CategoryTheory.CategoryStruct.comp, m, CategoryTheory.NatTrans.app, CategoryTheory.Limits.Cone.œÄ, t, j, CategoryTheory.NatTrans.app, CategoryTheory.Limits.Cone.œÄ, s, j, m, CategoryTheory.Limits.IsLimit.lift, self, s] (during elaboration) for (‚àÄ {J : Type u‚ÇÅ} [inst : CategoryTheory.Category J] {C : Type u‚ÇÉ} [inst_1 : CategoryTheory.Category C]
  {F : CategoryTheory.Functor J C} {t : CategoryTheory.Limits.Cone F} (self : CategoryTheory.Limits.IsLimit t)
  (s : CategoryTheory.Limits.Cone F) (m : CategoryTheory.Limits.Cone.pt s ‚ü∂ CategoryTheory.Limits.Cone.pt t)
  (x :
    ‚àÄ (j : J),
      CategoryTheory.CategoryStruct.comp m (CategoryTheory.NatTrans.app (CategoryTheory.Limits.Cone.œÄ t) j) =
        CategoryTheory.NatTrans.app (CategoryTheory.Limits.Cone.œÄ s) j),
  m = CategoryTheory.Limits.IsLimit.lift self s)

 : (‚àÄ {X : TopCat} {x : ‚ÜëX} {y : ‚ÜëX} (e : Inseparable x y), nhds y ‚â§ nhds x)
type mismatch
  X
has type
  TopCat : Type (?u.3 + 1)
but is expected to have type
  Sort ?u.5 : Type ?u.5 ; identifiers [X, TopCat, x, X, y, X, e, Inseparable, x, y, nhds, y, nhds, x] (during elaboration) for (‚àÄ {X : TopCat} {x : ‚ÜëX} {y : ‚ÜëX} (e : Inseparable x y), nhds y ‚â§ nhds x)

 : (‚àÄ {Œ± : Type u_1} [inst : Sub Œ±] {f : Filter Œ±} {g : Filter Œ±} {s : Set Œ±},
  (s ‚àà f - g) ‚Üî (‚àÉ (t‚ÇÅ : Set Œ±), ‚àÉ (t‚ÇÇ : Set Œ±), (t‚ÇÅ ‚àà f) ‚àß ((t‚ÇÇ ‚àà g) ‚àß (t‚ÇÅ - t‚ÇÇ ‚äÜ s))))
failed to synthesize instance
  HSub (Filter Œ±) (Filter Œ±) ?m.804 ; identifiers [Œ±, u_1, inst, Sub, Œ±, f, Filter, Œ±, g, Filter, Œ±, s, Set, Œ±, s, f, g, t‚ÇÅ, Set, Œ±, t‚ÇÇ, Set, Œ±, t‚ÇÅ, f, t‚ÇÇ, g, t‚ÇÅ, t‚ÇÇ, s] (during elaboration) for (‚àÄ {Œ± : Type u_1} [inst : Sub Œ±] {f : Filter Œ±} {g : Filter Œ±} {s : Set Œ±},
  (s ‚àà f - g) ‚Üî (‚àÉ (t‚ÇÅ : Set Œ±), ‚àÉ (t‚ÇÇ : Set Œ±), (t‚ÇÅ ‚àà f) ‚àß ((t‚ÇÇ ‚àà g) ‚àß (t‚ÇÅ - t‚ÇÇ ‚äÜ s))))

 : (‚àÄ {G : Type u_1} {Œ± : Type u_2} [inst : One G] [inst_1 : SMul G Œ±] [inst_2 : MeasurableSpace Œ±] {s : Set Œ±}
  {Œº : autoParam (MeasureTheory.Measure Œ±) _auto‚úù} (self : MeasureTheory.IsFundamentalDomain G s),
  MeasureTheory.NullMeasurableSet s)
<input>:2:48: expected token

 : (‚àÄ {Œπ : Type u} {Œ± : (a : Œπ) ‚Üí Type v} [inst : (i : Œπ) ‚Üí Preorder (Œ± i)] (i : Œπ), Monotone (Function.eval i))
typeclass instance problem is stuck, it is often due to metavariables
  Preorder (?m.467 i i) ; identifiers [Œπ, u, Œ±, a, Œπ, v, inst, i, Œπ, Preorder, Œ±, i, i, Œπ, Monotone, Function.eval, i] (during elaboration) for (‚àÄ {Œπ : Type u} {Œ± : (a : Œπ) ‚Üí Type v} [inst : (i : Œπ) ‚Üí Preorder (Œ± i)] (i : Œπ), Monotone (Function.eval i))

 : (‚àÄ {Œ± : Type u_1} [inst : GeneralizedBooleanAlgebra Œ±] (a : Œ±) (b : Œ±), a - b = a - b)
failed to synthesize instance
  HSub Œ± Œ± ?m.435 ; identifiers [Œ±, u_1, inst, GeneralizedBooleanAlgebra, Œ±, a, Œ±, b, Œ±, a, b, a, b] (during elaboration) for (‚àÄ {Œ± : Type u_1} [inst : GeneralizedBooleanAlgebra Œ±] (a : Œ±) (b : Œ±), a - b = a - b)

 : (‚àÄ {R : Type u} [inst : Ring R] {Q : TypeMax} [inst_1 : AddCommGroup Q] [inst_2 : Module R Q] {M : Type (max u v)}
  {N : Type (max u v)} [inst_3 : AddCommGroup M] [inst_4 : AddCommGroup N] [inst_5 : Module R M] [inst_6 : Module R N]
  {i : M ‚Üí‚Çó[R] N} {f : M ‚Üí‚Çó[R] Q} (self : Module.Baer.ExtensionOf i f),
  LinearMap.range i ‚â§ LinearPMap.domain (Module.Baer.ExtensionOf.toLinearPMap self))
stuck at solving universe constraint
  max u ?u.9 =?= max u v
while trying to unify
  (M ‚Üí‚Çó[R] N) R R Ring.toSemiring Ring.toSemiring (RingHom.id R) M N ((M ‚Üí‚Çó[R] N) M inst_3) ((M ‚Üí‚Çó[R] N) N inst_4)
    inst_5 inst_6
with
  M ‚Üí‚Çó[R] N ; identifiers [R, u, inst, Ring, R, Q, TypeMax, inst_1, AddCommGroup, Q, inst_2, Module, R, Q, M, u, v, N, u, v, inst_3, AddCommGroup, M, inst_4, AddCommGroup, N, inst_5, Module, R, M, inst_6, Module, R, N, i, M, R, N, f, M, R, Q, self, Module.Baer.ExtensionOf, i, f, LinearMap.range, i, LinearPMap.domain, Module.Baer.ExtensionOf.toLinearPMap, self] (during elaboration) for (‚àÄ {R : Type u} [inst : Ring R] {Q : TypeMax} [inst_1 : AddCommGroup Q] [inst_2 : Module R Q] {M : Type (max u v)}
  {N : Type (max u v)} [inst_3 : AddCommGroup M] [inst_4 : AddCommGroup N] [inst_5 : Module R M] [inst_6 : Module R N]
  {i : M ‚Üí‚Çó[R] N} {f : M ‚Üí‚Çó[R] Q} (self : Module.Baer.ExtensionOf i f),
  LinearMap.range i ‚â§ LinearPMap.domain (Module.Baer.ExtensionOf.toLinearPMap self))

 : (‚àÄ (C : Type u) [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasTerminal C]
  [inst_2 : CategoryTheory.Limits.HasBinaryProducts C] (X : C) (Y : C),
  Œ≤_ X Y = CategoryTheory.Limits.prod.braiding X Y)
type mismatch
  CategoryTheory.Limits.prod.braiding X Y
has type
  X ‚®Ø Y ‚âÖ Y ‚®Ø X : Type ?u.6
but is expected to have type
  CategoryTheory.MonoidalCategory.tensorObj X Y ‚âÖ CategoryTheory.MonoidalCategory.tensorObj Y X : Type ?u.6 ; identifiers [C, u, inst, CategoryTheory.Category, C, inst_1, CategoryTheory.Limits.HasTerminal, C, inst_2, CategoryTheory.Limits.HasBinaryProducts, C, X, C, Y, C, X, Y, CategoryTheory.Limits.prod.braiding, X, Y] (during elaboration) for (‚àÄ (C : Type u) [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasTerminal C]
  [inst_2 : CategoryTheory.Limits.HasBinaryProducts C] (X : C) (Y : C),
  Œ≤_ X Y = CategoryTheory.Limits.prod.braiding X Y)

 : (‚àÄ {G : Type u_1} {Œ± : Type u_2} [inst : Zero G] [inst_1 : VAdd G Œ±] [inst_2 : MeasurableSpace Œ±] {s : Set Œ±}
  {Œº : autoParam (MeasureTheory.Measure Œ±) _auto‚úù} (self : MeasureTheory.IsAddFundamentalDomain G s),
  ‚àÄ·µê (x : Œ±) ‚àÇŒº, ‚àÉ (g : G), g +·µ• x ‚àà s)
<input>:2:48: expected token

 : (‚àÄ {X : TopCat} {x : ‚ÜëX} {y : ‚ÜëX} (e : Inseparable x y), nhds x ‚â§ nhds y)
type mismatch
  X
has type
  TopCat : Type (?u.3 + 1)
but is expected to have type
  Sort ?u.5 : Type ?u.5 ; identifiers [X, TopCat, x, X, y, X, e, Inseparable, x, y, nhds, x, nhds, y] (during elaboration) for (‚àÄ {X : TopCat} {x : ‚ÜëX} {y : ‚ÜëX} (e : Inseparable x y), nhds x ‚â§ nhds y)

 : (‚àÄ (self : YoungDiagram), IsLowerSet ‚Üë(YoungDiagram.cells self))
typeclass instance problem is stuck, it is often due to metavariables
  LE (?m.324 self) ; identifiers [self, YoungDiagram, IsLowerSet, YoungDiagram.cells, self] (during elaboration) for (‚àÄ (self : YoungDiagram), IsLowerSet ‚Üë(YoungDiagram.cells self))

 : (‚àÄ {M : Type u_1} [inst : AddCommMonoid M] {S : AddSubmonoid M} {N : Type u_2} [inst_1 : AddCommMonoid N]
  (self : AddSubmonoid.LocalizationMap S N) (x : M) (y : M),
  (ZeroHom.toFun (‚Üë(AddSubmonoid.LocalizationMap.toAddMonoidHom self)) x =
      ZeroHom.toFun (‚Üë(AddSubmonoid.LocalizationMap.toAddMonoidHom self)) y) ‚Üî
    (‚àÉ (c : { x : M // x ‚àà S }), ‚Üëc + x = ‚Üëc + y))
typeclass instance problem is stuck, it is often due to metavariables
  Zero (?m.9706 self x y) ; identifiers [M, u_1, inst, AddCommMonoid, M, S, AddSubmonoid, M, N, u_2, inst_1, AddCommMonoid, N, self, AddSubmonoid.LocalizationMap, S, N, x, M, y, M, ZeroHom.toFun, AddSubmonoid.LocalizationMap.toAddMonoidHom, self, x, ZeroHom.toFun, AddSubmonoid.LocalizationMap.toAddMonoidHom, self, y, c, x, M, x, S, c, x, c, y] (during elaboration) for (‚àÄ {M : Type u_1} [inst : AddCommMonoid M] {S : AddSubmonoid M} {N : Type u_2} [inst_1 : AddCommMonoid N]
  (self : AddSubmonoid.LocalizationMap S N) (x : M) (y : M),
  (ZeroHom.toFun (‚Üë(AddSubmonoid.LocalizationMap.toAddMonoidHom self)) x =
      ZeroHom.toFun (‚Üë(AddSubmonoid.LocalizationMap.toAddMonoidHom self)) y) ‚Üî
    (‚àÉ (c : { x : M // x ‚àà S }), ‚Üëc + x = ‚Üëc + y))

 : (‚àÄ {Œ± : Type u_1} {s : Set Œ±} {a : Œ±} [inst : Star Œ±], (a ‚àà star s) ‚Üî (star a ‚àà s))
failed to synthesize instance
  Star (Set Œ±) ; identifiers [Œ±, u_1, s, Set, Œ±, a, Œ±, inst, Star, Œ±, a, star, s, star, a, s] (during elaboration) for (‚àÄ {Œ± : Type u_1} {s : Set Œ±} {a : Œ±} [inst : Star Œ±], (a ‚àà star s) ‚Üî (star a ‚àà s))

