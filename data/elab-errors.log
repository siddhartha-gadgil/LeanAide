 : (‚àÄ {C : Type u_1} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] {S‚ÇÅ : CategoryTheory.ShortComplex C} {S‚ÇÇ : CategoryTheory.ShortComplex C} {œÜ : S‚ÇÅ ‚ü∂ S‚ÇÇ} {h‚ÇÅ : CategoryTheory.ShortComplex.RightHomologyData S‚ÇÅ} {h‚ÇÇ : CategoryTheory.ShortComplex.RightHomologyData S‚ÇÇ} (self : CategoryTheory.ShortComplex.RightHomologyMapData œÜ h‚ÇÅ h‚ÇÇ) , CategoryTheory.CategoryStruct.comp CategoryTheory.ShortComplex.RightHomologyMapData.œÜQ self CategoryTheory.ShortComplex.RightHomologyData.g' h‚ÇÇ = CategoryTheory.CategoryStruct.comp CategoryTheory.ShortComplex.RightHomologyData.g' h‚ÇÅ CategoryTheory.ShortComplex.Hom.œÑ‚ÇÉ œÜ)
function expected at
  CategoryTheory.CategoryStruct.comp ?m.82047 ?m.161898
term has type
  ?m.1410 ‚ü∂ ?m.1412 ; identifiers [C, u_1, inst, CategoryTheory.Category, C, inst_1, CategoryTheory.Limits.HasZeroMorphisms, C, S‚ÇÅ, CategoryTheory.ShortComplex, C, S‚ÇÇ, CategoryTheory.ShortComplex, C, œÜ, S‚ÇÅ, S‚ÇÇ, h‚ÇÅ, CategoryTheory.ShortComplex.RightHomologyData, S‚ÇÅ, h‚ÇÇ, CategoryTheory.ShortComplex.RightHomologyData, S‚ÇÇ, self, CategoryTheory.ShortComplex.RightHomologyMapData, œÜ, h‚ÇÅ, h‚ÇÇ, CategoryTheory.CategoryStruct.comp, CategoryTheory.ShortComplex.RightHomologyMapData.œÜQ, self, CategoryTheory.ShortComplex.RightHomologyData.g', h‚ÇÇ, CategoryTheory.CategoryStruct.comp, CategoryTheory.ShortComplex.RightHomologyData.g', h‚ÇÅ, CategoryTheory.ShortComplex.Hom.œÑ‚ÇÉ, œÜ] (during elaboration)

 : ‚àÄ (C : Type u_1) [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] (S‚ÇÅ : CategoryTheory.ShortComplex C) (S‚ÇÇ : CategoryTheory.ShortComplex C) (œÜ : S‚ÇÅ ‚ü∂ S‚ÇÇ) (h‚ÇÅ : CategoryTheory.ShortComplex.RightHomologyData S‚ÇÅ) (h‚ÇÇ : CategoryTheory.ShortComplex.RightHomologyData S‚ÇÇ) (self : CategoryTheory.ShortComplex.RightHomologyMapData œÜ h‚ÇÅ h‚ÇÇ) , CategoryTheory.CategoryStruct.comp self . 1 CategoryTheory.ShortComplex.RightHomologyData.g' h‚ÇÇ = CategoryTheory.CategoryStruct.comp CategoryTheory.ShortComplex.RightHomologyData.g' h‚ÇÅ CategoryTheory.ShortComplex.Hom.œÑ‚ÇÉ œÜ
invalid occurrence of `¬∑` notation, it must be surrounded by parentheses (e.g. `(¬∑ + 1)`) ; identifiers [C, u_1, inst, CategoryTheory.Category, C, inst_1, CategoryTheory.Limits.HasZeroMorphisms, C, S‚ÇÅ, CategoryTheory.ShortComplex, C, S‚ÇÇ, CategoryTheory.ShortComplex, C, œÜ, S‚ÇÅ, S‚ÇÇ, h‚ÇÅ, CategoryTheory.ShortComplex.RightHomologyData, S‚ÇÅ, h‚ÇÇ, CategoryTheory.ShortComplex.RightHomologyData, S‚ÇÇ, self, CategoryTheory.ShortComplex.RightHomologyMapData, œÜ, h‚ÇÅ, h‚ÇÇ, CategoryTheory.CategoryStruct.comp, self, CategoryTheory.ShortComplex.RightHomologyData.g', h‚ÇÇ, CategoryTheory.CategoryStruct.comp, CategoryTheory.ShortComplex.RightHomologyData.g', h‚ÇÅ, CategoryTheory.ShortComplex.Hom.œÑ‚ÇÉ, œÜ] (during elaboration)

 : (‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.MonoidalCategory C] {A : Mon_ C} {B : Mon_ C} (self : Bimod A B) , CategoryTheory.CategoryStruct.comp CategoryTheory.MonoidalCategory.tensorHom Mon_.mul A CategoryTheory.CategoryStruct.id Bimod.X self Bimod.actLeft self = CategoryTheory.CategoryStruct.comp CategoryTheory.MonoidalCategory.associator Mon_.X A Mon_.X A Bimod.X self . hom CategoryTheory.CategoryStruct.comp CategoryTheory.MonoidalCategory.tensorHom CategoryTheory.CategoryStruct.id Mon_.X A Bimod.actLeft self Bimod.actLeft self)
function expected at
  CategoryTheory.CategoryStruct.comp ?m.81517 ?m.162100
term has type
  ?m.501 ‚ü∂ ?m.503 ; identifiers [C, u‚ÇÅ, inst, CategoryTheory.Category, C, inst_1, CategoryTheory.MonoidalCategory, C, A, Mon_, C, B, Mon_, C, self, Bimod, A, B, CategoryTheory.CategoryStruct.comp, CategoryTheory.MonoidalCategory.tensorHom, Mon_.mul, A, CategoryTheory.CategoryStruct.id, Bimod.X, self, Bimod.actLeft, self, CategoryTheory.CategoryStruct.comp, CategoryTheory.MonoidalCategory.associator, Mon_.X, A, Mon_.X, A, Bimod.X, self, hom, CategoryTheory.CategoryStruct.comp, CategoryTheory.MonoidalCategory.tensorHom, CategoryTheory.CategoryStruct.id, Mon_.X, A, Bimod.actLeft, self, Bimod.actLeft, self] (during elaboration)

 : ‚àÄ (C : Type u‚ÇÅ) [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.MonoidalCategory C] (A : Mon_ C) (B : Mon_ C) (self : Bimod A B) , CategoryTheory.CategoryStruct.comp CategoryTheory.MonoidalCategory.tensorHom Mon_.mul A CategoryTheory.CategoryStruct.id self . 1 self . 2 = CategoryTheory.CategoryStruct.comp CategoryTheory.MonoidalCategory.associator Mon_.X A Mon_.X A self . 1 . hom CategoryTheory.CategoryStruct.comp CategoryTheory.MonoidalCategory.tensorHom CategoryTheory.CategoryStruct.id Mon_.X A self . 2 self . 2
function expected at
  CategoryTheory.CategoryStruct.comp ?m.81514 ?m.162097
term has type
  ?m.498 ‚ü∂ ?m.500 ; identifiers [C, u‚ÇÅ, inst, CategoryTheory.Category, C, inst_1, CategoryTheory.MonoidalCategory, C, A, Mon_, C, B, Mon_, C, self, Bimod, A, B, CategoryTheory.CategoryStruct.comp, CategoryTheory.MonoidalCategory.tensorHom, Mon_.mul, A, CategoryTheory.CategoryStruct.id, self, self, CategoryTheory.CategoryStruct.comp, CategoryTheory.MonoidalCategory.associator, Mon_.X, A, Mon_.X, A, self, hom, CategoryTheory.CategoryStruct.comp, CategoryTheory.MonoidalCategory.tensorHom, CategoryTheory.CategoryStruct.id, Mon_.X, A, self, self] (during elaboration)

 : (‚àÄ {x : PGame} {y : PGame} , (PGame.Fuzzy x y) ‚Üî (Game.Fuzzy Quotient.mk PGame.setoid x Quotient.mk PGame.setoid y))
application type mismatch
  Game.Fuzzy Quotient.mk
argument
  Quotient.mk
has type
  (s : Setoid ?m.12) ‚Üí ?m.12 ‚Üí Quotient s : Sort (imax (max 1 ?u.11) ?u.11)
but is expected to have type
  Game : Type (?u.10 + 1) ; identifiers [x, PGame, y, PGame, PGame.Fuzzy, x, y, Game.Fuzzy, Quotient.mk, PGame.setoid, x, Quotient.mk, PGame.setoid, y] (during elaboration)

{Œ± : Type u_1} [DecidableEq Œ±] [Monoid Œ±] {s : Finset Œ±} {t : Finset Œ±} (hst : s ‚äÜ t) (x : ‚Ñï) (x : ‚Ñï) (f : Nat.below x) (n : ‚Ñï) (x : Nat.below Nat.succ n)  : (s ^ n + 1 ‚äÜ t ^ n + 1) = (s ^ n + 1 ‚äÜ t ^ n + 1)
application type mismatch
  Nat.below Nat.succ
argument
  Nat.succ
has type
  ‚Ñï ‚Üí ‚Ñï : Type
but is expected to have type
  ‚Ñï : Type ; identifiers [Œ±, u_1, DecidableEq, Œ±, Monoid, Œ±, s, Finset, Œ±, t, Finset, Œ±, hst, s, t, x, x, f, Nat.below, x, n, x, Nat.below, Nat.succ, n, s, n, t, n, s, n, t, n] (during elaboration)

{R : Type u} {L : Type v} [CommRing R] [LieRing L] [LieAlgebra R L] (toSubmodule : Submodule R L) (lie_mem' : ‚àÄ {x : L} {y : L} (a : x ‚àà AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup Submodule.toAddSubmonoid toSubmodule) (a : y ‚àà AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup Submodule.toAddSubmonoid toSubmodule) , ‚ÅÖ x , y ‚ÅÜ ‚àà AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup Submodule.toAddSubmonoid toSubmodule) (toSubmodule_1 : Submodule R L) (lie_mem'_1 : ‚àÄ {x : L} {y : L} (a : x ‚àà AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup Submodule.toAddSubmonoid toSubmodule_1) (a : y ‚àà AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup Submodule.toAddSubmonoid toSubmodule_1) , ‚ÅÖ x , y ‚ÅÜ ‚àà AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup Submodule.toAddSubmonoid toSubmodule_1) (a : {toSubmodule := ((toSubmodule)) , lie_mem' := ((lie_mem'))} = {toSubmodule := ((toSubmodule_1)) , lie_mem' := ((lie_mem'_1))})  : ‚àÄ (toSubmodule_eq : toSubmodule = toSubmodule_1) , toSubmodule = toSubmodule_1
function expected at
  AddSubsemigroup.carrier ?m.80749 Submodule.toAddSubmonoid
term has type
  Prop ; identifiers [R, u, L, v, CommRing, R, LieRing, L, LieAlgebra, R, L, toSubmodule, Submodule, R, L, lie_mem', x, L, y, L, a, x, AddSubsemigroup.carrier, AddSubmonoid.toAddSubsemigroup, Submodule.toAddSubmonoid, toSubmodule, a, y, AddSubsemigroup.carrier, AddSubmonoid.toAddSubsemigroup, Submodule.toAddSubmonoid, toSubmodule, x, y, AddSubsemigroup.carrier, AddSubmonoid.toAddSubsemigroup, Submodule.toAddSubmonoid, toSubmodule, toSubmodule_1, Submodule, R, L, lie_mem'_1, x, L, y, L, a, x, AddSubsemigroup.carrier, AddSubmonoid.toAddSubsemigroup, Submodule.toAddSubmonoid, toSubmodule_1, a, y, AddSubsemigroup.carrier, AddSubmonoid.toAddSubsemigroup, Submodule.toAddSubmonoid, toSubmodule_1, x, y, AddSubsemigroup.carrier, AddSubmonoid.toAddSubsemigroup, Submodule.toAddSubmonoid, toSubmodule_1, a, toSubmodule, toSubmodule, lie_mem', lie_mem', toSubmodule, toSubmodule_1, lie_mem', lie_mem'_1, toSubmodule_eq, toSubmodule, toSubmodule_1, toSubmodule, toSubmodule_1] (during elaboration)

{V : Type u} (x : SimpleGraph V) (x_1 : SimpleGraph V) (Adj : (a : V) ‚Üí (a : V) ‚Üí Prop) (symm : Symmetric Adj) (loopless : Irreflexive Adj) (Adj_1 : (a : V) ‚Üí (a : V) ‚Üí Prop) (symm_1 : Symmetric Adj_1) (loopless_1 : Irreflexive Adj_1) (Adj_2 : SimpleGraph.Adj SimpleGraph.mk Adj = SimpleGraph.Adj SimpleGraph.mk Adj_1) (h : SimpleGraph.Adj SimpleGraph.mk Adj_1 = SimpleGraph.Adj SimpleGraph.mk Adj)  : Adj = Adj_1
application type mismatch
  (fun Adj => SimpleGraph.mk Adj).Adj
argument
  fun Adj => SimpleGraph.mk Adj
has type
  (?m.80 ‚Üí ?m.80 ‚Üí Prop) ‚Üí SimpleGraph ?m.80 : Type ?u.79
but is expected to have type
  SimpleGraph ?m.78 : Type ?u.77 ; identifiers [V, u, x, SimpleGraph, V, x_1, SimpleGraph, V, Adj, a, V, a, V, symm, Symmetric, Adj, loopless, Irreflexive, Adj, Adj_1, a, V, a, V, symm_1, Symmetric, Adj_1, loopless_1, Irreflexive, Adj_1, Adj_2, SimpleGraph.Adj, SimpleGraph.mk, Adj, SimpleGraph.Adj, SimpleGraph.mk, Adj_1, h, SimpleGraph.Adj, SimpleGraph.mk, Adj_1, SimpleGraph.Adj, SimpleGraph.mk, Adj, Adj, Adj_1] (during elaboration)

{R : Type u} {L : Type v} [CommRing R] [LieRing L] [LieAlgebra R L] (toSubmodule : Submodule R L) (lie_mem' : ‚àÄ {x : L} {y : L} (a : x ‚àà AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup Submodule.toAddSubmonoid toSubmodule) (a : y ‚àà AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup Submodule.toAddSubmonoid toSubmodule) , ‚ÅÖ x , y ‚ÅÜ ‚àà AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup Submodule.toAddSubmonoid toSubmodule) (toSubmodule_1 : Submodule R L) (lie_mem'_1 : ‚àÄ {x : L} {y : L} (a : x ‚àà AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup Submodule.toAddSubmonoid toSubmodule_1) (a : y ‚àà AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup Submodule.toAddSubmonoid toSubmodule_1) , ‚ÅÖ x , y ‚ÅÜ ‚àà AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup Submodule.toAddSubmonoid toSubmodule_1) (a : toSubmodule = toSubmodule_1) (h : toSubmodule_1 = toSubmodule) (toSubmodule_2 : Submodule R L)  : toSubmodule = toSubmodule
function expected at
  AddSubsemigroup.carrier ?m.80749 Submodule.toAddSubmonoid
term has type
  Prop ; identifiers [R, u, L, v, CommRing, R, LieRing, L, LieAlgebra, R, L, toSubmodule, Submodule, R, L, lie_mem', x, L, y, L, a, x, AddSubsemigroup.carrier, AddSubmonoid.toAddSubsemigroup, Submodule.toAddSubmonoid, toSubmodule, a, y, AddSubsemigroup.carrier, AddSubmonoid.toAddSubsemigroup, Submodule.toAddSubmonoid, toSubmodule, x, y, AddSubsemigroup.carrier, AddSubmonoid.toAddSubsemigroup, Submodule.toAddSubmonoid, toSubmodule, toSubmodule_1, Submodule, R, L, lie_mem'_1, x, L, y, L, a, x, AddSubsemigroup.carrier, AddSubmonoid.toAddSubsemigroup, Submodule.toAddSubmonoid, toSubmodule_1, a, y, AddSubsemigroup.carrier, AddSubmonoid.toAddSubsemigroup, Submodule.toAddSubmonoid, toSubmodule_1, x, y, AddSubsemigroup.carrier, AddSubmonoid.toAddSubsemigroup, Submodule.toAddSubmonoid, toSubmodule_1, a, toSubmodule, toSubmodule_1, h, toSubmodule_1, toSubmodule, toSubmodule_2, Submodule, R, L, toSubmodule, toSubmodule] (during elaboration)

{M : Type u_1} [MonoidWithZero M] [NoZeroDivisors M] [Nontrivial M] {a : M} {n : ‚Ñï} (h : n = 0) (h_1 : (LE.le.eq_or_gt (zero_le n =: 0 ‚â§ n) =: (n = 0 : Prop) ‚à® (0 < n : Prop)) = (Or.inl h =: (n = 0 : Prop) ‚à® (0 < n : Prop)))  : (Or.inl h) = (LE.le.eq_or_gt (zero_le n))
<input>:1:131: expected term

{V : Type u_1} [TopologicalSpace V] [AddCommMonoid V] [SMul ‚Ñù V] (carrier : Set V) (convex' : Convex ‚Ñù carrier) (isCompact' : IsCompact carrier) (nonempty' : Set.Nonempty carrier) (carrier_1 : Set V) (convex'_1 : Convex ‚Ñù carrier_1) (isCompact'_1 : IsCompact carrier_1) (nonempty'_1 : Set.Nonempty carrier_1) (a : carrier = carrier_1) (h : carrier_1 = carrier) (convex'_2 : Convex ‚Ñù carrier) (isCompact'_2 : IsCompact carrier) (nonempty'_2 : Set.Nonempty carrier) (a : carrier = carrier) (h : HEq a (Eq.refl carrier =: carrier = carrier))  : {carrier := ((carrier)) , convex' := ((convex')) , isCompact' := ((isCompact')) , nonempty' := ((nonempty'))} = {carrier := ((carrier)) , convex' := ((convex')) , isCompact' := ((isCompact')) , nonempty' := ((nonempty'))}
<input>:1:517: expected term

{R : Type u} {L : Type v} [CommRing R] [LieRing L] [LieAlgebra R L] (toSubmodule : Submodule R L) (lie_mem' : ‚àÄ {x : L} {y : L} (a : x ‚àà AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup Submodule.toAddSubmonoid toSubmodule) (a : y ‚àà AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup Submodule.toAddSubmonoid toSubmodule) , ‚ÅÖ x , y ‚ÅÜ ‚àà AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup Submodule.toAddSubmonoid toSubmodule) (toSubmodule_1 : Submodule R L) (lie_mem'_1 : ‚àÄ {x : L} {y : L} (a : x ‚àà AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup Submodule.toAddSubmonoid toSubmodule_1) (a : y ‚àà AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup Submodule.toAddSubmonoid toSubmodule_1) , ‚ÅÖ x , y ‚ÅÜ ‚àà AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup Submodule.toAddSubmonoid toSubmodule_1) (a : toSubmodule = toSubmodule_1) (h : toSubmodule_1 = toSubmodule) (lie_mem'_2 : ‚àÄ {x : L} {y : L} (a : x ‚àà AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup Submodule.toAddSubmonoid toSubmodule) (a : y ‚àà AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup Submodule.toAddSubmonoid toSubmodule) , ‚ÅÖ x , y ‚ÅÜ ‚àà AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup Submodule.toAddSubmonoid toSubmodule) (a : toSubmodule = toSubmodule) (h : HEq a (Eq.refl toSubmodule =: toSubmodule = toSubmodule))  : {toSubmodule := ((toSubmodule)) , lie_mem' := ((lie_mem'))} = {toSubmodule := ((toSubmodule)) , lie_mem' := ((lie_mem'))}
<input>:1:1296: expected term

{R : Type u} {L : Type v} [CommRing R] [LieRing L] [LieAlgebra R L] (toSubmodule : Submodule R L) (lie_mem' : ‚àÄ {x : L} {y : L} (a : x ‚àà AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup Submodule.toAddSubmonoid toSubmodule) (a : y ‚àà AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup Submodule.toAddSubmonoid toSubmodule) , ‚ÅÖ x , y ‚ÅÜ ‚àà AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup Submodule.toAddSubmonoid toSubmodule) (toSubmodule_1 : Submodule R L) (lie_mem'_1 : ‚àÄ {x : L} {y : L} (a : x ‚àà AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup Submodule.toAddSubmonoid toSubmodule_1) (a : y ‚àà AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup Submodule.toAddSubmonoid toSubmodule_1) , ‚ÅÖ x , y ‚ÅÜ ‚àà AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup Submodule.toAddSubmonoid toSubmodule_1) (a : toSubmodule = toSubmodule_1) (h : toSubmodule_1 = toSubmodule)  : toSubmodule = toSubmodule_1
function expected at
  AddSubsemigroup.carrier ?m.80749 Submodule.toAddSubmonoid
term has type
  Prop ; identifiers [R, u, L, v, CommRing, R, LieRing, L, LieAlgebra, R, L, toSubmodule, Submodule, R, L, lie_mem', x, L, y, L, a, x, AddSubsemigroup.carrier, AddSubmonoid.toAddSubsemigroup, Submodule.toAddSubmonoid, toSubmodule, a, y, AddSubsemigroup.carrier, AddSubmonoid.toAddSubsemigroup, Submodule.toAddSubmonoid, toSubmodule, x, y, AddSubsemigroup.carrier, AddSubmonoid.toAddSubsemigroup, Submodule.toAddSubmonoid, toSubmodule, toSubmodule_1, Submodule, R, L, lie_mem'_1, x, L, y, L, a, x, AddSubsemigroup.carrier, AddSubmonoid.toAddSubsemigroup, Submodule.toAddSubmonoid, toSubmodule_1, a, y, AddSubsemigroup.carrier, AddSubmonoid.toAddSubsemigroup, Submodule.toAddSubmonoid, toSubmodule_1, x, y, AddSubsemigroup.carrier, AddSubmonoid.toAddSubsemigroup, Submodule.toAddSubmonoid, toSubmodule_1, a, toSubmodule, toSubmodule_1, h, toSubmodule_1, toSubmodule, toSubmodule, toSubmodule_1] (during elaboration)

{R : Type u} {L : Type v} [CommRing R] [LieRing L] [LieAlgebra R L] (toSubmodule : Submodule R L) (lie_mem' : ‚àÄ {x : L} {y : L} (a : x ‚àà AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup Submodule.toAddSubmonoid toSubmodule) (a : y ‚àà AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup Submodule.toAddSubmonoid toSubmodule) , ‚ÅÖ x , y ‚ÅÜ ‚àà AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup Submodule.toAddSubmonoid toSubmodule) (toSubmodule_1 : Submodule R L) (lie_mem'_1 : ‚àÄ {x : L} {y : L} (a : x ‚àà AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup Submodule.toAddSubmonoid toSubmodule_1) (a : y ‚àà AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup Submodule.toAddSubmonoid toSubmodule_1) , ‚ÅÖ x , y ‚ÅÜ ‚àà AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup Submodule.toAddSubmonoid toSubmodule_1) (a : toSubmodule = toSubmodule_1)  : toSubmodule_1 = toSubmodule_1
function expected at
  AddSubsemigroup.carrier ?m.80749 Submodule.toAddSubmonoid
term has type
  Prop ; identifiers [R, u, L, v, CommRing, R, LieRing, L, LieAlgebra, R, L, toSubmodule, Submodule, R, L, lie_mem', x, L, y, L, a, x, AddSubsemigroup.carrier, AddSubmonoid.toAddSubsemigroup, Submodule.toAddSubmonoid, toSubmodule, a, y, AddSubsemigroup.carrier, AddSubmonoid.toAddSubsemigroup, Submodule.toAddSubmonoid, toSubmodule, x, y, AddSubsemigroup.carrier, AddSubmonoid.toAddSubsemigroup, Submodule.toAddSubmonoid, toSubmodule, toSubmodule_1, Submodule, R, L, lie_mem'_1, x, L, y, L, a, x, AddSubsemigroup.carrier, AddSubmonoid.toAddSubsemigroup, Submodule.toAddSubmonoid, toSubmodule_1, a, y, AddSubsemigroup.carrier, AddSubmonoid.toAddSubsemigroup, Submodule.toAddSubmonoid, toSubmodule_1, x, y, AddSubsemigroup.carrier, AddSubmonoid.toAddSubsemigroup, Submodule.toAddSubmonoid, toSubmodule_1, a, toSubmodule, toSubmodule_1, toSubmodule_1, toSubmodule_1] (during elaboration)

{Œπ : Type u_1} {Œ± : (a : Œπ) ‚Üí Type u_2} {r‚ÇÅ : (a : Œπ) ‚Üí (a : Œπ) ‚Üí Prop} {r‚ÇÇ : (a : Œπ) ‚Üí (a : Œπ) ‚Üí Prop} {s‚ÇÅ : (i : Œπ) ‚Üí (a : Œ± i) ‚Üí (a : Œ± i) ‚Üí Prop} {s‚ÇÇ : (i : Œπ) ‚Üí (a : Œ± i) ‚Üí (a : Œ± i) ‚Üí Prop} (hr : ‚àÄ (a : Œπ) (b : Œπ) (a_1 : r‚ÇÅ a b) , r‚ÇÇ a b) (hs : ‚àÄ (i : Œπ) (a : Œ± i) (b : Œ± i) (a_1 : s‚ÇÅ i a b) , s‚ÇÇ i a b) {a : (i : Œπ) √ó Œ± i} {b : (i : Œπ) √ó Œ± i} (h : Sigma.Lex r‚ÇÅ s‚ÇÅ a b) {i : Œπ} {j : Œπ} (a_1 : Œ± i) (b_1 : Œ± j) (hij : r‚ÇÅ i j) (h_1 : a = {fst := ((i)) , snd := ((a_1))}) (h : Sigma.Lex r‚ÇÅ s‚ÇÅ {fst := ((i)) , snd := ((a_1))} b) (h_2 : b = {fst := ((j)) , snd := ((b_1))}) (h : Sigma.Lex r‚ÇÅ s‚ÇÅ {fst := ((i)) , snd := ((a_1))} {fst := ((j)) , snd := ((b_1))}) (h_3 : HEq h (Sigma.Lex.left a_1 b_1 hij =: Sigma.Lex r‚ÇÅ s‚ÇÅ {fst := ((i)) , snd := ((a_1))} {fst := ((j)) , snd := ((b_1))}))  : r‚ÇÇ i j
<input>:1:703: expected term

{Œπ : Type u_1} {K : Type u_2} {V : Type u_3} [Field K] [AddCommGroup V] [Module K V] {f : (a : Œπ) ‚Üí ‚Ñô K V}  : (¬¨ (LinearIndependent K Projectivization.rep ‚àò f)) ‚Üî (¬¨ (LinearIndependent K Projectivization.rep ‚àò f))
application type mismatch
  ¬¨?m.82840 ‚àò f
argument
  ?m.82840 ‚àò f
has type
  Œπ ‚Üí ?m.862 : Sort (imax (u_1 + 1) ?u.857)
but is expected to have type
  Prop : Type ; identifiers [Œπ, u_1, K, u_2, V, u_3, Field, K, AddCommGroup, V, Module, K, V, f, a, Œπ, K, V, LinearIndependent, K, Projectivization.rep, f, LinearIndependent, K, Projectivization.rep, f] (during elaboration)

{Œ± : Type u_1} {Œ≤ : Type u_2} {m0 : MeasurableSpace Œ±} [MeasurableSpace Œ≤] {Œº : MeasureTheory.Measure Œ±} {f : (a : Œ±) ‚Üí Œ≤} (hf : AEMeasurable f)  : ‚àÄ (h : ¬¨ True) , 0 = 0
failed to synthesize instance
  MeasureTheory.MeasureSpace Œ± ; identifiers [Œ±, u_1, Œ≤, u_2, m0, MeasurableSpace, Œ±, MeasurableSpace, Œ≤, Œº, MeasureTheory.Measure, Œ±, f, a, Œ±, Œ≤, hf, AEMeasurable, f, h, True] (during elaboration)

{Œπ : Type u_1} {Œ± : (a : Œπ) ‚Üí Type u_2} {r‚ÇÅ : (a : Œπ) ‚Üí (a : Œπ) ‚Üí Prop} {r‚ÇÇ : (a : Œπ) ‚Üí (a : Œπ) ‚Üí Prop} {s‚ÇÅ : (i : Œπ) ‚Üí (a : Œ± i) ‚Üí (a : Œ± i) ‚Üí Prop} {s‚ÇÇ : (i : Œπ) ‚Üí (a : Œ± i) ‚Üí (a : Œ± i) ‚Üí Prop} (hr : ‚àÄ (a : Œπ) (b : Œπ) (a_1 : r‚ÇÅ a b) , r‚ÇÇ a b) (hs : ‚àÄ (i : Œπ) (a : Œ± i) (b : Œ± i) (a_1 : s‚ÇÅ i a b) , s‚ÇÇ i a b) {a : (i : Œπ) √ó Œ± i} {b : (i : Œπ) √ó Œ± i} (h : Sigma.Lex r‚ÇÅ s‚ÇÅ a b) {i : Œπ} (a_1 : Œ± i) (b_1 : Œ± i) (hab : s‚ÇÅ i a_1 b_1) (h_1 : a = {fst := ((i)) , snd := ((a_1))}) (h : Sigma.Lex r‚ÇÅ s‚ÇÅ {fst := ((i)) , snd := ((a_1))} b) (h_2 : b = {fst := ((i)) , snd := ((b_1))}) (h : Sigma.Lex r‚ÇÅ s‚ÇÅ {fst := ((i)) , snd := ((a_1))} {fst := ((i)) , snd := ((b_1))}) (h_3 : HEq h (Sigma.Lex.right a_1 b_1 hab =: Sigma.Lex r‚ÇÅ s‚ÇÅ {fst := ((i)) , snd := ((a_1))} {fst := ((i)) , snd := ((b_1))}))  : s‚ÇÇ i a_1 b_1
<input>:1:702: expected term

{M : Type u_1} [MonoidWithZero M] [NoZeroDivisors M] [Nontrivial M] {a : M} {n : ‚Ñï} (h : 0 < n) (h_1 : (LE.le.eq_or_gt (zero_le n =: 0 ‚â§ n) =: (n = 0 : Prop) ‚à® (0 < n : Prop)) = (Or.inr h =: (n = 0 : Prop) ‚à® (0 < n : Prop)))  : (Or.inr h) = (LE.le.eq_or_gt (zero_le n))
<input>:1:131: expected term

 : (‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {J : CategoryTheory.GrothendieckTopology C} {S : CategoryTheory.GrothendieckTopology.Cover J X} (self : CategoryTheory.GrothendieckTopology.Cover.Arrow S) , CategoryTheory.GrothendieckTopology.Cover.sieve S . arrows CategoryTheory.GrothendieckTopology.Cover.Arrow.f self)
function expected at
  (CategoryTheory.GrothendieckTopology.Cover.sieve S).arrows ?m.871
term has type
  Prop ; identifiers [C, u, inst, CategoryTheory.Category, C, X, C, J, CategoryTheory.GrothendieckTopology, C, S, CategoryTheory.GrothendieckTopology.Cover, J, X, self, CategoryTheory.GrothendieckTopology.Cover.Arrow, S, CategoryTheory.GrothendieckTopology.Cover.sieve, S, arrows, CategoryTheory.GrothendieckTopology.Cover.Arrow.f, self] (during elaboration)

 : ‚àÄ (C : Type u) [inst : CategoryTheory.Category C] (X : C) (J : CategoryTheory.GrothendieckTopology C) (S : CategoryTheory.GrothendieckTopology.Cover J X) (self : CategoryTheory.GrothendieckTopology.Cover.Arrow S) , CategoryTheory.GrothendieckTopology.Cover.sieve S . arrows self . 2
invalid occurrence of `¬∑` notation, it must be surrounded by parentheses (e.g. `(¬∑ + 1)`) ; identifiers [C, u, inst, CategoryTheory.Category, C, X, C, J, CategoryTheory.GrothendieckTopology, C, S, CategoryTheory.GrothendieckTopology.Cover, J, X, self, CategoryTheory.GrothendieckTopology.Cover.Arrow, S, CategoryTheory.GrothendieckTopology.Cover.sieve, S, arrows, self] (during elaboration)

 : (‚àÄ {C : Type u} {A : Type u_1} [inst : CategoryTheory.Category C] [inst_1 : AddMonoid A] (self : CategoryTheory.ShiftMkCore C A) (n : A) (X : C) , CategoryTheory.NatTrans.app CategoryTheory.ShiftMkCore.add self n 0 . hom X = CategoryTheory.CategoryStruct.comp CategoryTheory.eqToHom (id (Eq.mpr (id ((add_zero n) ‚ñ∏ (Eq.refl (CategoryTheory.Functor.toPrefunctor CategoryTheory.ShiftMkCore.F self n + 0 . obj X = CategoryTheory.Functor.toPrefunctor CategoryTheory.ShiftMkCore.F self n . obj X)))) (Eq.refl CategoryTheory.Functor.toPrefunctor CategoryTheory.ShiftMkCore.F self n . obj X))) CategoryTheory.NatTrans.app CategoryTheory.ShiftMkCore.zero self . inv CategoryTheory.Functor.toPrefunctor CategoryTheory.ShiftMkCore.F self n . obj X)
function expected at
  CategoryTheory.NatTrans.app ?m.81278 self
term has type
  ?m.61.obj self ‚ü∂ ?m.62.obj self ; identifiers [C, u, A, u_1, inst, CategoryTheory.Category, C, inst_1, AddMonoid, A, self, CategoryTheory.ShiftMkCore, C, A, n, A, X, C, CategoryTheory.NatTrans.app, CategoryTheory.ShiftMkCore.add, self, n, hom, X, CategoryTheory.CategoryStruct.comp, CategoryTheory.eqToHom, id, Eq.mpr, id, add_zero, n, Eq.refl, CategoryTheory.Functor.toPrefunctor, CategoryTheory.ShiftMkCore.F, self, n, obj, X, CategoryTheory.Functor.toPrefunctor, CategoryTheory.ShiftMkCore.F, self, n, obj, X, Eq.refl, CategoryTheory.Functor.toPrefunctor, CategoryTheory.ShiftMkCore.F, self, n, obj, X, CategoryTheory.NatTrans.app, CategoryTheory.ShiftMkCore.zero, self, inv, CategoryTheory.Functor.toPrefunctor, CategoryTheory.ShiftMkCore.F, self, n, obj, X] (during elaboration)

 : ‚àÄ (C : Type u) (A : Type u_1) [inst : CategoryTheory.Category C] [inst_1 : AddMonoid A] (self : CategoryTheory.ShiftMkCore C A) (n : A) (X : C) , CategoryTheory.NatTrans.app self . 3 n 0 . hom X = CategoryTheory.CategoryStruct.comp CategoryTheory.eqToHom (id (Eq.mpr (id ((add_zero n) ‚ñ∏ (Eq.refl (CategoryTheory.Functor.toPrefunctor self . 1 n + 0 . obj X = CategoryTheory.Functor.toPrefunctor self . 1 n . obj X)))) (Eq.refl CategoryTheory.Functor.toPrefunctor self . 1 n . obj X))) CategoryTheory.NatTrans.app self . 2 . inv CategoryTheory.Functor.toPrefunctor self . 1 n . obj X
invalid occurrence of `¬∑` notation, it must be surrounded by parentheses (e.g. `(¬∑ + 1)`) ; identifiers [C, u, A, u_1, inst, CategoryTheory.Category, C, inst_1, AddMonoid, A, self, CategoryTheory.ShiftMkCore, C, A, n, A, X, C, CategoryTheory.NatTrans.app, self, n, hom, X, CategoryTheory.CategoryStruct.comp, CategoryTheory.eqToHom, id, Eq.mpr, id, add_zero, n, Eq.refl, CategoryTheory.Functor.toPrefunctor, self, n, obj, X, CategoryTheory.Functor.toPrefunctor, self, n, obj, X, Eq.refl, CategoryTheory.Functor.toPrefunctor, self, n, obj, X, CategoryTheory.NatTrans.app, self, inv, CategoryTheory.Functor.toPrefunctor, self, n, obj, X] (during elaboration)

{V : Type u_1} {P : Type u_2} [NormedAddCommGroup V] [InnerProductSpace ‚Ñù V] [MetricSpace P] [NormedAddTorsor V P] [Fact (FiniteDimensional.finrank ‚Ñù V = 2 : Prop)] [Module.Oriented ‚Ñù V Fin 2] {p‚ÇÅ : P} {p‚ÇÇ : P} {p‚ÇÉ : P} (h : EuclideanGeometry.oangle p‚ÇÅ p‚ÇÇ p‚ÇÉ = ‚Üë Real.pi)  : ‚Üë Real.pi = EuclideanGeometry.oangle p‚ÇÅ p‚ÇÇ p‚ÇÉ
application type mismatch
  Module.Oriented ‚Ñù V Fin
argument
  Fin
has type
  ‚Ñï ‚Üí Type : Type 1
but is expected to have type
  Type ?u.490 : Type (?u.490 + 1) ; identifiers [V, u_1, P, u_2, NormedAddCommGroup, V, InnerProductSpace, V, MetricSpace, P, NormedAddTorsor, V, P, Fact, FiniteDimensional.finrank, V, Module.Oriented, V, Fin, p‚ÇÅ, P, p‚ÇÇ, P, p‚ÇÉ, P, h, EuclideanGeometry.oangle, p‚ÇÅ, p‚ÇÇ, p‚ÇÉ, Real.pi, Real.pi, EuclideanGeometry.oangle, p‚ÇÅ, p‚ÇÇ, p‚ÇÉ] (during elaboration)

{v : Sat.Valuation} {l : Sat.Literal} (h‚ÇÅ : ‚àÄ (a : Sat.Valuation.neg v Sat.Literal.negate l) , False) (h‚ÇÇ : ‚àÄ (a : Sat.Valuation.neg v l) , False)  : ‚àÄ (a : ‚Ñï) (h‚ÇÅ : ‚àÄ (a : Sat.Valuation.neg v Sat.Literal.negate Sat.Literal.pos a) , False) (h‚ÇÇ : ‚àÄ (a : Sat.Valuation.neg v Sat.Literal.pos a) , False) , False
application type mismatch
  Sat.Valuation.neg v Sat.Literal.negate
argument
  Sat.Literal.negate
has type
  Sat.Literal ‚Üí Sat.Literal : Type
but is expected to have type
  Sat.Literal : Type ; identifiers [v, Sat.Valuation, l, Sat.Literal, h‚ÇÅ, a, Sat.Valuation.neg, v, Sat.Literal.negate, l, False, h‚ÇÇ, a, Sat.Valuation.neg, v, l, False, a, h‚ÇÅ, a, Sat.Valuation.neg, v, Sat.Literal.negate, Sat.Literal.pos, a, False, h‚ÇÇ, a, Sat.Valuation.neg, v, Sat.Literal.pos, a, False, False] (during elaboration)

{v : Sat.Valuation} {l : Sat.Literal} (h‚ÇÅ : ‚àÄ (a : Sat.Valuation.neg v Sat.Literal.negate l) , False) (h‚ÇÇ : ‚àÄ (a : Sat.Valuation.neg v l) , False)  : ‚àÄ (a : ‚Ñï) (h‚ÇÅ : ‚àÄ (a : Sat.Valuation.neg v Sat.Literal.negate Sat.Literal.neg a) , False) (h‚ÇÇ : ‚àÄ (a : Sat.Valuation.neg v Sat.Literal.neg a) , False) , False
application type mismatch
  Sat.Valuation.neg v Sat.Literal.negate
argument
  Sat.Literal.negate
has type
  Sat.Literal ‚Üí Sat.Literal : Type
but is expected to have type
  Sat.Literal : Type ; identifiers [v, Sat.Valuation, l, Sat.Literal, h‚ÇÅ, a, Sat.Valuation.neg, v, Sat.Literal.negate, l, False, h‚ÇÇ, a, Sat.Valuation.neg, v, l, False, a, h‚ÇÅ, a, Sat.Valuation.neg, v, Sat.Literal.negate, Sat.Literal.neg, a, False, h‚ÇÇ, a, Sat.Valuation.neg, v, Sat.Literal.neg, a, False, False] (during elaboration)

{G : Type u_2} {Œ± : Type u_1} [Group G] [MulAction G Œ±] {s : Set Œ±} {x : Œ±} (i : G)  : (‚àÉ (_h : ¬¨ (i = 1)) , x ‚àà i ‚Ä¢ s) = ((¬¨ (i = 1)) ‚àß (x ‚àà i ‚Ä¢ s))
failed to synthesize instance
  HSMul G (Set Œ±) ?m.943 ; identifiers [G, u_2, Œ±, u_1, Group, G, MulAction, G, Œ±, s, Set, Œ±, x, Œ±, i, G, _h, i, x, i, s, i, x, i, s] (during elaboration)

{G : Type u_2} {Œ± : Type u_1} [Group G] [MulAction G Œ±] {s : Set Œ±} {x : Œ±}  : (¬¨ (‚àÉ (x_1 : G) , (¬¨ (x_1 = 1)) ‚àß (x ‚àà x_1 ‚Ä¢ s))) = (‚àÄ (x_1 : G) , ¬¨ ((¬¨ (x_1 = 1)) ‚àß (x ‚àà x_1 ‚Ä¢ s)))
failed to synthesize instance
  HSMul G (Set Œ±) ?m.940 ; identifiers [G, u_2, Œ±, u_1, Group, G, MulAction, G, Œ±, s, Set, Œ±, x, Œ±, x_1, G, x_1, x, x_1, s, x_1, G, x_1, x, x_1, s] (during elaboration)

{G : Type u_2} {Œ± : Type u_1} [Group G] [MulAction G Œ±] {s : Set Œ±} {x : Œ±}  : ‚àÄ (x_1 : G) , (¬¨ ((¬¨ (x_1 = 1)) ‚àß (x ‚àà x_1 ‚Ä¢ s))) = (‚àÄ (a : ¬¨ (x_1 = 1)) , ¬¨ (x ‚àà x_1 ‚Ä¢ s))
failed to synthesize instance
  HSMul G (Set Œ±) ?m.939 ; identifiers [G, u_2, Œ±, u_1, Group, G, MulAction, G, Œ±, s, Set, Œ±, x, Œ±, x_1, G, x_1, x, x_1, s, a, x_1, x, x_1, s] (during elaboration)

 : (‚àÄ {Œ± : Type u_2} {n : Type u_1} {m : Type u_3} [inst : Mul Œ±] [inst_1 : AddCommMonoid Œ±] (A : Matrix m n Œ±) [inst_2 : Fintype n] , (Matrix.HasOrthogonalCols Matrix.transpose A) ‚Üî (Matrix.HasOrthogonalRows A))
function expected at
  Matrix.HasOrthogonalCols Matrix.transpose
term has type
  Prop ; identifiers [Œ±, u_2, n, u_1, m, u_3, inst, Mul, Œ±, inst_1, AddCommMonoid, Œ±, A, Matrix, m, n, Œ±, inst_2, Fintype, n, Matrix.HasOrthogonalCols, Matrix.transpose, A, Matrix.HasOrthogonalRows, A] (during elaboration)

{Œ± : Type u_1} [DecidableEq Œ±] [PartialOrder Œ±] [OrderTop Œ±] [SuccOrder Œ±] {a : WithTop Œ±} {b : WithTop Œ±} (h : a < fun (a : WithTop Œ±) ‚Ü¶ WithTop.instSuccOrderWithTopPreorderToPreorder.match_1 fun (a : WithTop Œ±) ‚Ü¶ WithTop Œ± a fun (_ : Unit) ‚Ü¶ ‚ä§ fun (a : Œ±) ‚Ü¶ if (a = ‚ä§ : Prop) then ‚ä§ else ‚Üë Order.succ a b) (h_1 : a = none)  : none = a
function expected at
  WithTop Œ±
term has type
  Type u_1 ; identifiers [Œ±, u_1, DecidableEq, Œ±, PartialOrder, Œ±, OrderTop, Œ±, SuccOrder, Œ±, a, WithTop, Œ±, b, WithTop, Œ±, h, a, a, WithTop, Œ±, WithTop.instSuccOrderWithTopPreorderToPreorder.match_1, a, WithTop, Œ±, WithTop, Œ±, a, Unit, a, Œ±, a, Order.succ, a, b, h_1, a, none, none, a] (during elaboration)

 : ‚àÄ {Œ± : Type u_2} {n : Type u_1} {m : Type u_3} [inst : Mul Œ±] [inst_1 : AddCommMonoid Œ±] (A : Matrix m n Œ±) [inst_2 : Fintype n] , (Matrix.HasOrthogonalCols Matrix.transpose A) ‚Üî (Matrix.HasOrthogonalCols Matrix.transpose A)
function expected at
  Matrix.HasOrthogonalCols Matrix.transpose
term has type
  Prop ; identifiers [Œ±, u_2, n, u_1, m, u_3, inst, Mul, Œ±, inst_1, AddCommMonoid, Œ±, A, Matrix, m, n, Œ±, inst_2, Fintype, n, Matrix.HasOrthogonalCols, Matrix.transpose, A, Matrix.HasOrthogonalCols, Matrix.transpose, A] (during elaboration)

(p : ‚Ñï) [inst : Fact (Nat.Prime p : Prop)]  : fun (x : ‚Ñï) ‚Ü¶ ‚Üë x = fun (x : ‚Ñï) ‚Ü¶ ‚Üë x
type expected, got
  (fun x => ?m.158240 x = fun x_1 => ?m.158241 x x_1 : ‚Ñï ‚Üí Prop) ; identifiers [p, inst, Fact, Nat.Prime, p, x, x, x, x] (during elaboration)

 : (‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoEMetricSpace Œ±] [inst_1 : PseudoEMetricSpace Œ≤] {K : NNReal} {f : (a : Œ±) ‚Üí Œ≤} (hf : LipschitzWith K f) {p : (a : Œ≤) ‚Üí Prop} (hp : ‚àÄ (x : Œ±) , p f x) , LipschitzWith K fun (x : Œ±) ‚Ü¶ {val := ((f x)) , property := (((hp x)))})
application type mismatch
  p f
argument
  f
has type
  Œ± ‚Üí Œ≤ : Type (max u v)
but is expected to have type
  Œ≤ : Type v ; identifiers [Œ±, u, Œ≤, v, inst, PseudoEMetricSpace, Œ±, inst_1, PseudoEMetricSpace, Œ≤, K, NNReal, f, a, Œ±, Œ≤, hf, LipschitzWith, K, f, p, a, Œ≤, hp, x, Œ±, p, f, x, LipschitzWith, K, x, Œ±, val, f, x, property, hp, x] (during elaboration)

 : ‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoEMetricSpace Œ±] [inst_1 : PseudoEMetricSpace Œ≤] {K : NNReal} {f : (a : Œ±) ‚Üí Œ≤} (hf : LipschitzWith K f) {p : (a : Œ≤) ‚Üí Prop} (hp : ‚àÄ (x : Œ±) , p f x) , LipschitzWith K f
application type mismatch
  p f
argument
  f
has type
  Œ± ‚Üí Œ≤ : Type (max u v)
but is expected to have type
  Œ≤ : Type v ; identifiers [Œ±, u, Œ≤, v, inst, PseudoEMetricSpace, Œ±, inst_1, PseudoEMetricSpace, Œ≤, K, NNReal, f, a, Œ±, Œ≤, hf, LipschitzWith, K, f, p, a, Œ≤, hp, x, Œ±, p, f, x, LipschitzWith, K, f] (during elaboration)

 : (‚àÄ {B : Type u_1} {F : Type u_2} {E : (a : B) ‚Üí Type u_3} [inst : TopologicalSpace B] [inst_1 : TopologicalSpace F] [inst_2 : (x : B) ‚Üí TopologicalSpace E x] (self : FiberPrebundle F E) (e : Pretrivialization F Bundle.TotalSpace.proj) (a : e ‚àà FiberPrebundle.pretrivializationAtlas self) (e' : Pretrivialization F Bundle.TotalSpace.proj) (a : e' ‚àà FiberPrebundle.pretrivializationAtlas self) , ContinuousOn ‚Üë e ‚àò ‚Üë LocalEquiv.symm Pretrivialization.toLocalEquiv e' LocalEquiv.target Pretrivialization.toLocalEquiv e' ‚à© ‚Üë LocalEquiv.symm Pretrivialization.toLocalEquiv e' ‚Åª¬π' LocalEquiv.source Pretrivialization.toLocalEquiv e)
application type mismatch
  TopologicalSpace E
argument
  E
has type
  B ‚Üí Type u_3 : Type (max u_1 (u_3 + 1))
but is expected to have type
  Type ?u.21 : Type (?u.21 + 1) ; identifiers [B, u_1, F, u_2, E, a, B, u_3, inst, TopologicalSpace, B, inst_1, TopologicalSpace, F, inst_2, x, B, TopologicalSpace, E, x, self, FiberPrebundle, F, E, e, Pretrivialization, F, Bundle.TotalSpace.proj, a, e, FiberPrebundle.pretrivializationAtlas, self, e', Pretrivialization, F, Bundle.TotalSpace.proj, a, e', FiberPrebundle.pretrivializationAtlas, self, ContinuousOn, e, LocalEquiv.symm, Pretrivialization.toLocalEquiv, e', LocalEquiv.target, Pretrivialization.toLocalEquiv, e', LocalEquiv.symm, Pretrivialization.toLocalEquiv, e', LocalEquiv.source, Pretrivialization.toLocalEquiv, e] (during elaboration)

 : ‚àÄ (B : Type u_1) (F : Type u_2) (E : (a : B) ‚Üí Type u_3) [inst : TopologicalSpace B] [inst_1 : TopologicalSpace F] [inst_2 : (x : B) ‚Üí TopologicalSpace E x] (self : FiberPrebundle F E) (e : Pretrivialization F Bundle.TotalSpace.proj) (a : e ‚àà self . 1) (e' : Pretrivialization F Bundle.TotalSpace.proj) (a : e' ‚àà self . 1) , ContinuousOn ‚Üë e ‚àò ‚Üë LocalEquiv.symm Pretrivialization.toLocalEquiv e' LocalEquiv.target Pretrivialization.toLocalEquiv e' ‚à© ‚Üë LocalEquiv.symm Pretrivialization.toLocalEquiv e' ‚Åª¬π' LocalEquiv.source Pretrivialization.toLocalEquiv e
application type mismatch
  TopologicalSpace E
argument
  E
has type
  B ‚Üí Type u_3 : Type (max u_1 (u_3 + 1))
but is expected to have type
  Type ?u.21 : Type (?u.21 + 1) ; identifiers [B, u_1, F, u_2, E, a, B, u_3, inst, TopologicalSpace, B, inst_1, TopologicalSpace, F, inst_2, x, B, TopologicalSpace, E, x, self, FiberPrebundle, F, E, e, Pretrivialization, F, Bundle.TotalSpace.proj, a, e, self, e', Pretrivialization, F, Bundle.TotalSpace.proj, a, e', self, ContinuousOn, e, LocalEquiv.symm, Pretrivialization.toLocalEquiv, e', LocalEquiv.target, Pretrivialization.toLocalEquiv, e', LocalEquiv.symm, Pretrivialization.toLocalEquiv, e', LocalEquiv.source, Pretrivialization.toLocalEquiv, e] (during elaboration)

{G : Type u_1} [Group G] (x : Subgroup G) (toSubmonoid : Submonoid G) (inv_mem' : ‚àÄ {x : G} (a : x ‚àà Subsemigroup.carrier Submonoid.toSubsemigroup toSubmonoid) , x ‚Åª¬π ‚àà Subsemigroup.carrier Submonoid.toSubsemigroup toSubmonoid) (h : x = {toSubmonoid := ((toSubmonoid)) , inv_mem' := ((inv_mem'))})  : {toSubmonoid := ((toSubmonoid)) , inv_mem' := ((inv_mem'))} = x
failed to synthesize instance
  Mul (Submonoid G) ; identifiers [G, u_1, Group, G, x, Subgroup, G, toSubmonoid, Submonoid, G, inv_mem', x, G, a, x, Subsemigroup.carrier, Submonoid.toSubsemigroup, toSubmonoid, x, Subsemigroup.carrier, Submonoid.toSubsemigroup, toSubmonoid, h, x, toSubmonoid, toSubmonoid, inv_mem', inv_mem', toSubmonoid, toSubmonoid, inv_mem', inv_mem', x] (during elaboration)

{R : Type u_1} [LinearOrderedSemifield R] [FloorSemiring R] {b : ‚Ñï} (hb : b ‚â§ 1) (r : R) (h : 1 ‚â§ r) (h_1 : (le_total 1 r =: (1 ‚â§ r : Prop) ‚à® (r ‚â§ 1 : Prop)) = (Or.inl h =: (1 ‚â§ r : Prop) ‚à® (r ‚â§ 1 : Prop)))  : (Or.inl h) = (le_total 1 r)
<input>:1:123: expected term

{Œ± : Type u_1} [DecidableEq Œ±] [PartialOrder Œ±] [OrderTop Œ±] [SuccOrder Œ±] {a : WithTop Œ±} {b : WithTop Œ±} (h : a < fun (a : WithTop Œ±) ‚Ü¶ WithTop.instSuccOrderWithTopPreorderToPreorder.match_1 fun (a : WithTop Œ±) ‚Ü¶ WithTop Œ± a fun (_ : Unit) ‚Ü¶ ‚ä§ fun (a : Œ±) ‚Ü¶ if (a = ‚ä§ : Prop) then ‚ä§ else ‚Üë Order.succ a b) (val : Œ±) (h_1 : a = some val) (h : some val < fun (a : WithTop Œ±) ‚Ü¶ WithTop.instSuccOrderWithTopPreorderToPreorder.match_1 fun (a : WithTop Œ±) ‚Ü¶ WithTop Œ± a fun (_ : Unit) ‚Ü¶ ‚ä§ fun (a : Œ±) ‚Ü¶ if (a = ‚ä§ : Prop) then ‚ä§ else ‚Üë Order.succ a b) (h_2 : b = none)  : none = b
function expected at
  WithTop Œ±
term has type
  Type u_1 ; identifiers [Œ±, u_1, DecidableEq, Œ±, PartialOrder, Œ±, OrderTop, Œ±, SuccOrder, Œ±, a, WithTop, Œ±, b, WithTop, Œ±, h, a, a, WithTop, Œ±, WithTop.instSuccOrderWithTopPreorderToPreorder.match_1, a, WithTop, Œ±, WithTop, Œ±, a, Unit, a, Œ±, a, Order.succ, a, b, val, Œ±, h_1, a, some, val, h, some, val, a, WithTop, Œ±, WithTop.instSuccOrderWithTopPreorderToPreorder.match_1, a, WithTop, Œ±, WithTop, Œ±, a, Unit, a, Œ±, a, Order.succ, a, b, h_2, b, none, none, b] (during elaboration)

 : (‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_1} {r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop} {s : (a : Œ≤) ‚Üí (a : Œ≤) ‚Üí Prop} [inst : IsWellOrder Œ± r] [inst_1 : IsWellOrder Œ≤ s] , (Ordinal.type r < Ordinal.type s) ‚Üî (Nonempty r ‚â∫i s))
application type mismatch
  Nonempty r
argument
  r
has type
  Œ± ‚Üí Œ± ‚Üí Prop : Type u_1
but is expected to have type
  Sort ?u.102 : Type ?u.102 ; identifiers [Œ±, u_1, Œ≤, u_1, r, a, Œ±, a, Œ±, s, a, Œ≤, a, Œ≤, inst, IsWellOrder, Œ±, r, inst_1, IsWellOrder, Œ≤, s, Ordinal.type, r, Ordinal.type, s, Nonempty, r, s] (during elaboration)

{Œ± : Type u_3} {M : Type u_2} {N : Type u_4} {R : Type u_1} [Semiring R] [AddCommMonoid M] [Module R M] [AddCommMonoid N] [Module R N] ‚¶É œÜ : Œ± ‚Üí‚ÇÄ M ‚Üí‚Çó[R] N ‚¶Ñ ‚¶É œà : Œ± ‚Üí‚ÇÄ M ‚Üí‚Çó[R] N ‚¶Ñ (h : ‚àÄ (a : Œ±) , LinearMap.comp œÜ Finsupp.lsingle a = LinearMap.comp œà Finsupp.lsingle a) (a : Œ±)  : LinearMap.comp œÜ Finsupp.lsingle a = LinearMap.comp œà Finsupp.lsingle a
function expected at
  LinearMap.comp ?m.2063 ?m.4985
term has type
  ?m.685 ‚Üí‚Çõ‚Çó[?m.699] ?m.687 ; identifiers [Œ±, u_3, M, u_2, N, u_4, R, u_1, Semiring, R, AddCommMonoid, M, Module, R, M, AddCommMonoid, N, Module, R, N, œÜ, Œ±, M, R, N, œà, Œ±, M, R, N, h, a, Œ±, LinearMap.comp, œÜ, Finsupp.lsingle, a, LinearMap.comp, œà, Finsupp.lsingle, a, a, Œ±, LinearMap.comp, œÜ, Finsupp.lsingle, a, LinearMap.comp, œà, Finsupp.lsingle, a] (during elaboration)

{Œ± : Type u} {Œ≤ : Type u_1} [AddGroup Œ±] [Preorder Œ±] [CovariantClass Œ± Œ± fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1 fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] [CovariantClass Œ± Œ± Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1 fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] [Preorder Œ≤] {f : (a : Œ≤) ‚Üí Œ±} {s : Set Œ≤} (hf : StrictMonoOn f s) (x : Œ≤) (hx : x ‚àà s) (x_1 : Œ≤) (hy : x_1 ‚àà s) (hxy : x < x_1)  : f x < f x_1
function expected at
  x_1
term has type
  Œ± ; identifiers [Œ±, u, Œ≤, u_1, AddGroup, Œ±, Preorder, Œ±, CovariantClass, Œ±, Œ±, x, Œ±, x_1, Œ±, x, x_1, x, Œ±, x_1, Œ±, x, x_1, CovariantClass, Œ±, Œ±, Function.swap, x, Œ±, x_1, Œ±, x, x_1, x, Œ±, x_1, Œ±, x, x_1, Preorder, Œ≤, f, a, Œ≤, Œ±, s, Set, Œ≤, hf, StrictMonoOn, f, s, x, Œ≤, hx, x, s, x_1, Œ≤, hy, x_1, s, hxy, x, x_1, f, x, f, x_1] (during elaboration)

{R : Type u_1} [LinearOrderedSemifield R] [FloorSemiring R] {b : ‚Ñï} (hb : b ‚â§ 1) (r : R) (h : 1 ‚â§ r) (h_1 : (le_total 1 r =: (1 ‚â§ r : Prop) ‚à® (r ‚â§ 1 : Prop)) = (Or.inl h =: (1 ‚â§ r : Prop) ‚à® (r ‚â§ 1 : Prop)))  : (‚Üë 0 = 0) = (‚Üë 0 = 0)
<input>:1:123: expected term

{R : Type u_1} [LinearOrderedSemifield R] [FloorSemiring R] {b : ‚Ñï} (hb : b ‚â§ 1) (r : R) (h : 1 ‚â§ r) (h_1 : (le_total 1 r =: (1 ‚â§ r : Prop) ‚à® (r ‚â§ 1 : Prop)) = (Or.inl h =: (1 ‚â§ r : Prop) ‚à® (r ‚â§ 1 : Prop)))  : 0 = 0
<input>:1:123: expected term

{R : Type u_1} [LinearOrderedSemifield R] [FloorSemiring R] {b : ‚Ñï} (hb : b ‚â§ 1) (r : R) (h : r ‚â§ 1) (h_1 : (le_total 1 r =: (1 ‚â§ r : Prop) ‚à® (r ‚â§ 1 : Prop)) = (Or.inr h =: (1 ‚â§ r : Prop) ‚à® (r ‚â§ 1 : Prop)))  : (Or.inr h) = (le_total 1 r)
<input>:1:123: expected term

{Œ± : Type u_1} {Œ≤ : Type u_2} [DecidableEq Œ±] [DecidableEq Œ≤] (f : (a : Œ±) ‚Üí Œ≤) (hf : Function.Injective f) (x : Œ±) (s : Multiset Œ±) ‚¶É y : Œ± ‚¶Ñ {s : Multiset Œ±} (ih : Multiset.map f Multiset.erase s x = Multiset.erase Multiset.map f s f x) (h : x = y) ‚¶É y : Œ± ‚¶Ñ  : y = y
application type mismatch
  Multiset.map f Multiset.erase
argument
  Multiset.erase
has type
  Multiset ?m.68 ‚Üí ?m.68 ‚Üí Multiset ?m.68 : Type ?u.67
but is expected to have type
  Multiset Œ± : Type u_1 ; identifiers [Œ±, u_1, Œ≤, u_2, DecidableEq, Œ±, DecidableEq, Œ≤, f, a, Œ±, Œ≤, hf, Function.Injective, f, x, Œ±, s, Multiset, Œ±, y, Œ±, s, Multiset, Œ±, ih, Multiset.map, f, Multiset.erase, s, x, Multiset.erase, Multiset.map, f, s, f, x, h, x, y, y, Œ±, y, y] (during elaboration)

{X : CompHaus} {Y : CompHaus} {B : CompHaus} (f : X ‚ü∂ B) (g : Y ‚ü∂ B) (x : CategoryTheory.Functor.toPrefunctor CategoryTheory.forget CompHaus . obj CompHaus.pullback f g)  : ‚àÄ (val : ‚Üë CompHaus.toTop X √ó ‚Üë CompHaus.toTop Y) (h : val ‚àà {xy : ‚Üë CompHaus.toTop X √ó ‚Üë CompHaus.toTop Y | ‚Üë f Prod.fst xy = ‚Üë g Prod.snd xy}) , val ‚àà {xy : ‚Üë CompHaus.toTop X √ó ‚Üë CompHaus.toTop Y | ‚Üë f Prod.fst xy = ‚Üë g Prod.snd xy}
function expected at
  ?m.330.toPrefunctor
term has type
  ?m.157 ‚•§q ?m.159 ; identifiers [X, CompHaus, Y, CompHaus, B, CompHaus, f, X, B, g, Y, B, x, CategoryTheory.Functor.toPrefunctor, CategoryTheory.forget, CompHaus, obj, CompHaus.pullback, f, g, val, CompHaus.toTop, X, CompHaus.toTop, Y, h, val, xy, CompHaus.toTop, X, CompHaus.toTop, Y, f, Prod.fst, xy, g, Prod.snd, xy, val, xy, CompHaus.toTop, X, CompHaus.toTop, Y, f, Prod.fst, xy, g, Prod.snd, xy] (during elaboration)

{c : Cardinal .{u_1}} (h : ‚àÄ (n : ‚Ñï) , ‚Üë n ‚â§ c) (hn : c < Cardinal.aleph0) (n : ‚Ñï) (h_1 : c = ‚Üë n)  : ‚Üë n = c
<input>:1:14: expected '//', '|' or '}'

{R : Type u_1} [LinearOrderedSemifield R] [FloorSemiring R] {b : ‚Ñï} (hb : b ‚â§ 1) (r : R) (h : r ‚â§ 1) (h_1 : (le_total 1 r =: (1 ‚â§ r : Prop) ‚à® (r ‚â§ 1 : Prop)) = (Or.inr h =: (1 ‚â§ r : Prop) ‚à® (r ‚â§ 1 : Prop)))  : (- ‚Üë 0 = 0) = (- ‚Üë 0 = 0)
<input>:1:123: expected term

{R : Type u_1} [LinearOrderedSemifield R] [FloorSemiring R] {b : ‚Ñï} (hb : b ‚â§ 1) (r : R) (h : r ‚â§ 1) (h_1 : (le_total 1 r =: (1 ‚â§ r : Prop) ‚à® (r ‚â§ 1 : Prop)) = (Or.inr h =: (1 ‚â§ r : Prop) ‚à® (r ‚â§ 1 : Prop)))  : (- 0 = 0) = (- 0 = 0)
<input>:1:123: expected term

{R : Type u_1} [LinearOrderedSemifield R] [FloorSemiring R] {b : ‚Ñï} (hb : b ‚â§ 1) (r : R) (h : r ‚â§ 1) (h_1 : (le_total 1 r =: (1 ‚â§ r : Prop) ‚à® (r ‚â§ 1 : Prop)) = (Or.inr h =: (1 ‚â§ r : Prop) ‚à® (r ‚â§ 1 : Prop)))  : 0 = 0
<input>:1:123: expected term

{Œ± : Type u_1} [DecidableEq Œ±] [PartialOrder Œ±] [OrderTop Œ±] [SuccOrder Œ±] {a : WithTop Œ±} {b : WithTop Œ±} (h : a < fun (a : WithTop Œ±) ‚Ü¶ WithTop.instSuccOrderWithTopPreorderToPreorder.match_1 fun (a : WithTop Œ±) ‚Ü¶ WithTop Œ± a fun (_ : Unit) ‚Ü¶ ‚ä§ fun (a : Œ±) ‚Ü¶ if (a = ‚ä§ : Prop) then ‚ä§ else ‚Üë Order.succ a b) (val : Œ±) (h_1 : a = some val) (h : some val < fun (a : WithTop Œ±) ‚Ü¶ WithTop.instSuccOrderWithTopPreorderToPreorder.match_1 fun (a : WithTop Œ±) ‚Ü¶ WithTop Œ± a fun (_ : Unit) ‚Ü¶ ‚ä§ fun (a : Œ±) ‚Ü¶ if (a = ‚ä§ : Prop) then ‚ä§ else ‚Üë Order.succ a b) (val_1 : Œ±) (h_2 : b = some val_1) (h : some val < fun (a : WithTop Œ±) ‚Ü¶ WithTop.instSuccOrderWithTopPreorderToPreorder.match_1 fun (a : WithTop Œ±) ‚Ü¶ WithTop Œ± a fun (_ : Unit) ‚Ü¶ ‚ä§ fun (a : Œ±) ‚Ü¶ if (a = ‚ä§ : Prop) then ‚ä§ else ‚Üë Order.succ a some val_1)  : (val ‚â§ val_1) = (val ‚â§ val_1)
function expected at
  WithTop Œ±
term has type
  Type u_1 ; identifiers [Œ±, u_1, DecidableEq, Œ±, PartialOrder, Œ±, OrderTop, Œ±, SuccOrder, Œ±, a, WithTop, Œ±, b, WithTop, Œ±, h, a, a, WithTop, Œ±, WithTop.instSuccOrderWithTopPreorderToPreorder.match_1, a, WithTop, Œ±, WithTop, Œ±, a, Unit, a, Œ±, a, Order.succ, a, b, val, Œ±, h_1, a, some, val, h, some, val, a, WithTop, Œ±, WithTop.instSuccOrderWithTopPreorderToPreorder.match_1, a, WithTop, Œ±, WithTop, Œ±, a, Unit, a, Œ±, a, Order.succ, a, b, val_1, Œ±, h_2, b, some, val_1, h, some, val, a, WithTop, Œ±, WithTop.instSuccOrderWithTopPreorderToPreorder.match_1, a, WithTop, Œ±, WithTop, Œ±, a, Unit, a, Œ±, a, Order.succ, a, some, val_1, val, val_1, val, val_1] (during elaboration)

{Œ± : Type uu} {r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop} [DecidableRel r] (x : List Œ±) (x_1 : List.Sorted r x) (x : List Œ±) (f : List.below (motive := fun (x : List Œ±) ‚Ü¶ ‚àÄ (x_2 : List.Sorted r x) , List.insertionSort r x = x) x) (x_2 : List.Sorted r x) (a : Œ±) (b : Œ±) (l : List Œ±) (h : List.Sorted r a :: b :: l) (x : List.below (motive := fun (x : List Œ±) ‚Ü¶ ‚àÄ (x_3 : List.Sorted r x) , List.insertionSort r x = x) a :: b :: l)  : a :: b :: l = a :: b :: l
application type mismatch
  List.Sorted r a
argument
  a
has type
  Œ± : Type uu
but is expected to have type
  List Œ± : Type uu ; identifiers [Œ±, uu, r, a, Œ±, a, Œ±, DecidableRel, r, x, List, Œ±, x_1, List.Sorted, r, x, x, List, Œ±, f, List.below, motive, x, List, Œ±, x_2, List.Sorted, r, x, List.insertionSort, r, x, x, x, x_2, List.Sorted, r, x, a, Œ±, b, Œ±, l, List, Œ±, h, List.Sorted, r, a, b, l, x, List.below, motive, x, List, Œ±, x_3, List.Sorted, r, x, List.insertionSort, r, x, x, a, b, l, a, b, l, a, b, l] (during elaboration)

 : (‚àÄ {G : Type u_1} [inst : AddGroup G] (self : NonarchAddGroupSeminorm G) (r : G) (s : G) , ZeroHom.toFun NonarchAddGroupSeminorm.toZeroHom self r + s ‚â§ max ZeroHom.toFun NonarchAddGroupSeminorm.toZeroHom self r ZeroHom.toFun NonarchAddGroupSeminorm.toZeroHom self s)
function expected at
  ZeroHom.toFun ?m.665 self
term has type
  ?m.30 ; identifiers [G, u_1, inst, AddGroup, G, self, NonarchAddGroupSeminorm, G, r, G, s, G, ZeroHom.toFun, NonarchAddGroupSeminorm.toZeroHom, self, r, s, max, ZeroHom.toFun, NonarchAddGroupSeminorm.toZeroHom, self, r, ZeroHom.toFun, NonarchAddGroupSeminorm.toZeroHom, self, s] (during elaboration)

 : ‚àÄ (G : Type u_1) [inst : AddGroup G] (self : NonarchAddGroupSeminorm G) (r : G) (s : G) , ZeroHom.toFun self . 1 r + s ‚â§ max ZeroHom.toFun self . 1 r ZeroHom.toFun self . 1 s
invalid occurrence of `¬∑` notation, it must be surrounded by parentheses (e.g. `(¬∑ + 1)`) ; identifiers [G, u_1, inst, AddGroup, G, self, NonarchAddGroupSeminorm, G, r, G, s, G, ZeroHom.toFun, self, r, s, max, ZeroHom.toFun, self, r, ZeroHom.toFun, self, s] (during elaboration)

{Œ± : Type u_1} {Œ≤ : Type u_2} [DecidableEq Œ±] [DecidableEq Œ≤] (f : (a : Œ±) ‚Üí Œ≤) (hf : Function.Injective f) (x : Œ±) (s : Multiset Œ±) ‚¶É y : Œ± ‚¶Ñ {s : Multiset Œ±} (ih : Multiset.map f Multiset.erase s x = Multiset.erase Multiset.map f s f x) (h : x = y) (hxy : x = x) (h : HEq hxy (Eq.refl x =: x = x))  : ‚àÄ (x : Œ±) (a : x ‚àà s) , f x = f x
<input>:1:290: expected term

{Œ± : Type u_1} {ùïú : Type u_2} {E : Type u_3} {F : Type u_4} [IsROrC ùïú] [NormedAddCommGroup E] [NormedSpace ùïú E] [NormedAddCommGroup F] [CompleteSpace F] {u : (a : Œ±) ‚Üí ‚Ñù} [NormedSpace ùïú F] {f : (a : Œ±) ‚Üí (a : E) ‚Üí F} {f' : (a : Œ±) ‚Üí (a : E) ‚Üí E ‚ÜíL[ùïú] F} {x‚ÇÄ : E} (hu : Summable u) (hf : ‚àÄ (n : Œ±) (x : E) , HasFDerivAt f n f' n x x) (hf' : ‚àÄ (n : Œ±) (x : E) , ‚Äñ f' n x ‚Äñ ‚â§ u n) (hf0 : Summable fun (n : Œ±) ‚Ü¶ f n x‚ÇÄ) (x : E) x_1 : NormedSpace ‚Ñù E := NormedSpace.restrictScalars ‚Ñù ùïú E  : ‚àÄ (n : Œ±) (x : E) (x_2 : x ‚àà Set.univ) , HasFDerivAt f n f' n x x
<input>:1:371: expected term

{Œ± : Type u_1} {ùïú : Type u_2} {E : Type u_3} {F : Type u_4} [IsROrC ùïú] [NormedAddCommGroup E] [NormedSpace ùïú E] [NormedAddCommGroup F] [CompleteSpace F] {u : (a : Œ±) ‚Üí ‚Ñù} [NormedSpace ùïú F] {f : (a : Œ±) ‚Üí (a : E) ‚Üí F} {f' : (a : Œ±) ‚Üí (a : E) ‚Üí E ‚ÜíL[ùïú] F} {x‚ÇÄ : E} (hu : Summable u) (hf : ‚àÄ (n : Œ±) (x : E) , HasFDerivAt f n f' n x x) (hf' : ‚àÄ (n : Œ±) (x : E) , ‚Äñ f' n x ‚Äñ ‚â§ u n) (hf0 : Summable fun (n : Œ±) ‚Ü¶ f n x‚ÇÄ) (x : E) x_1 : NormedSpace ‚Ñù E := NormedSpace.restrictScalars ‚Ñù ùïú E  : ‚àÄ (n : Œ±) (x : E) (x_2 : x ‚àà Set.univ) , ‚Äñ f' n x ‚Äñ ‚â§ u n
<input>:1:371: expected term

{Œ± : Type u_1} {Œ≤ : Type u_2} [DecidableEq Œ±] [DecidableEq Œ≤] (f : (a : Œ±) ‚Üí Œ≤) (hf : Function.Injective f) (x : Œ±) (s : Multiset Œ±) ‚¶É y : Œ± ‚¶Ñ {s : Multiset Œ±} (ih : Multiset.map f Multiset.erase s x = Multiset.erase Multiset.map f s f x)  : x = x
application type mismatch
  Multiset.map f Multiset.erase
argument
  Multiset.erase
has type
  Multiset ?m.68 ‚Üí ?m.68 ‚Üí Multiset ?m.68 : Type ?u.67
but is expected to have type
  Multiset Œ± : Type u_1 ; identifiers [Œ±, u_1, Œ≤, u_2, DecidableEq, Œ±, DecidableEq, Œ≤, f, a, Œ±, Œ≤, hf, Function.Injective, f, x, Œ±, s, Multiset, Œ±, y, Œ±, s, Multiset, Œ±, ih, Multiset.map, f, Multiset.erase, s, x, Multiset.erase, Multiset.map, f, s, f, x, x, x] (during elaboration)

{Œ± : Type u_1} [DecidableEq Œ±] [PartialOrder Œ±] [OrderTop Œ±] [SuccOrder Œ±] {a : WithTop Œ±} {b : WithTop Œ±} (h : a < fun (a : WithTop Œ±) ‚Ü¶ WithTop.instSuccOrderWithTopPreorderToPreorder.match_1 fun (a : WithTop Œ±) ‚Ü¶ WithTop Œ± a fun (_ : Unit) ‚Ü¶ ‚ä§ fun (a : Œ±) ‚Ü¶ if (a = ‚ä§ : Prop) then ‚ä§ else ‚Üë Order.succ a b) (val : Œ±) (h_1 : a = some val) (h : some val < fun (a : WithTop Œ±) ‚Ü¶ WithTop.instSuccOrderWithTopPreorderToPreorder.match_1 fun (a : WithTop Œ±) ‚Ü¶ WithTop Œ± a fun (_ : Unit) ‚Ü¶ ‚ä§ fun (a : Œ±) ‚Ü¶ if (a = ‚ä§ : Prop) then ‚ä§ else ‚Üë Order.succ a b) (val_1 : Œ±) (h_2 : b = some val_1)  : some val_1 = b
function expected at
  WithTop Œ±
term has type
  Type u_1 ; identifiers [Œ±, u_1, DecidableEq, Œ±, PartialOrder, Œ±, OrderTop, Œ±, SuccOrder, Œ±, a, WithTop, Œ±, b, WithTop, Œ±, h, a, a, WithTop, Œ±, WithTop.instSuccOrderWithTopPreorderToPreorder.match_1, a, WithTop, Œ±, WithTop, Œ±, a, Unit, a, Œ±, a, Order.succ, a, b, val, Œ±, h_1, a, some, val, h, some, val, a, WithTop, Œ±, WithTop.instSuccOrderWithTopPreorderToPreorder.match_1, a, WithTop, Œ±, WithTop, Œ±, a, Unit, a, Œ±, a, Order.succ, a, b, val_1, Œ±, h_2, b, some, val_1, some, val_1, b] (during elaboration)

{Œ± : Type u_1} [DecidableEq Œ±] [PartialOrder Œ±] [OrderTop Œ±] [SuccOrder Œ±] {a : WithTop Œ±} {b : WithTop Œ±} (h : a < fun (a : WithTop Œ±) ‚Ü¶ WithTop.instSuccOrderWithTopPreorderToPreorder.match_1 fun (a : WithTop Œ±) ‚Ü¶ WithTop Œ± a fun (_ : Unit) ‚Ü¶ ‚ä§ fun (a : Œ±) ‚Ü¶ if (a = ‚ä§ : Prop) then ‚ä§ else ‚Üë Order.succ a b) (val : Œ±) (h_1 : a = some val) (h : some val < fun (a : WithTop Œ±) ‚Ü¶ WithTop.instSuccOrderWithTopPreorderToPreorder.match_1 fun (a : WithTop Œ±) ‚Ü¶ WithTop Œ± a fun (_ : Unit) ‚Ü¶ ‚ä§ fun (a : Œ±) ‚Ü¶ if (a = ‚ä§ : Prop) then ‚ä§ else ‚Üë Order.succ a b)  : b = b
function expected at
  WithTop Œ±
term has type
  Type u_1 ; identifiers [Œ±, u_1, DecidableEq, Œ±, PartialOrder, Œ±, OrderTop, Œ±, SuccOrder, Œ±, a, WithTop, Œ±, b, WithTop, Œ±, h, a, a, WithTop, Œ±, WithTop.instSuccOrderWithTopPreorderToPreorder.match_1, a, WithTop, Œ±, WithTop, Œ±, a, Unit, a, Œ±, a, Order.succ, a, b, val, Œ±, h_1, a, some, val, h, some, val, a, WithTop, Œ±, WithTop.instSuccOrderWithTopPreorderToPreorder.match_1, a, WithTop, Œ±, WithTop, Œ±, a, Unit, a, Œ±, a, Order.succ, a, b, b, b] (during elaboration)

{Œ± : Type u_1} [DecidableEq Œ±] [PartialOrder Œ±] [OrderTop Œ±] [SuccOrder Œ±] {a : WithTop Œ±} {b : WithTop Œ±} (h : a < fun (a : WithTop Œ±) ‚Ü¶ WithTop.instSuccOrderWithTopPreorderToPreorder.match_1 fun (a : WithTop Œ±) ‚Ü¶ WithTop Œ± a fun (_ : Unit) ‚Ü¶ ‚ä§ fun (a : Œ±) ‚Ü¶ if (a = ‚ä§ : Prop) then ‚ä§ else ‚Üë Order.succ a b) (val : Œ±) (h_1 : a = some val)  : some val = a
function expected at
  WithTop Œ±
term has type
  Type u_1 ; identifiers [Œ±, u_1, DecidableEq, Œ±, PartialOrder, Œ±, OrderTop, Œ±, SuccOrder, Œ±, a, WithTop, Œ±, b, WithTop, Œ±, h, a, a, WithTop, Œ±, WithTop.instSuccOrderWithTopPreorderToPreorder.match_1, a, WithTop, Œ±, WithTop, Œ±, a, Unit, a, Œ±, a, Order.succ, a, b, val, Œ±, h_1, a, some, val, some, val, a] (during elaboration)

{Œ± : Type u_1} [DecidableEq Œ±] [PartialOrder Œ±] [OrderTop Œ±] [SuccOrder Œ±] {a : WithTop Œ±} {b : WithTop Œ±} (h : a < fun (a : WithTop Œ±) ‚Ü¶ WithTop.instSuccOrderWithTopPreorderToPreorder.match_1 fun (a : WithTop Œ±) ‚Ü¶ WithTop Œ± a fun (_ : Unit) ‚Ü¶ ‚ä§ fun (a : Œ±) ‚Ü¶ if (a = ‚ä§ : Prop) then ‚ä§ else ‚Üë Order.succ a b)  : a = a
function expected at
  WithTop Œ±
term has type
  Type u_1 ; identifiers [Œ±, u_1, DecidableEq, Œ±, PartialOrder, Œ±, OrderTop, Œ±, SuccOrder, Œ±, a, WithTop, Œ±, b, WithTop, Œ±, h, a, a, WithTop, Œ±, WithTop.instSuccOrderWithTopPreorderToPreorder.match_1, a, WithTop, Œ±, WithTop, Œ±, a, Unit, a, Œ±, a, Order.succ, a, b, a, a] (during elaboration)

{K : Type u_1} {v : K} {n : ‚Ñï} [LinearOrderedField K] [FloorRing K] {ifp_n : GeneralizedContinuedFraction.IntFractPair K} (nth_stream_eq : GeneralizedContinuedFraction.IntFractPair.stream v n = some ifp_n) (n_1 : ‚Ñï) (h : n = Nat.succ n_1) (nth_stream_eq : GeneralizedContinuedFraction.IntFractPair.stream v Nat.succ n_1 = some ifp_n) (w : GeneralizedContinuedFraction.IntFractPair K) (h : (GeneralizedContinuedFraction.IntFractPair.stream v n_1 = some w : Prop) ‚àß ((GeneralizedContinuedFraction.IntFractPair.fr w ‚â† 0 : Prop) ‚àß (GeneralizedContinuedFraction.IntFractPair.of GeneralizedContinuedFraction.IntFractPair.fr w ‚Åª¬π = ifp_n : Prop) : Prop)) (left : GeneralizedContinuedFraction.IntFractPair.stream v n_1 = some w) (right : (GeneralizedContinuedFraction.IntFractPair.fr w ‚â† 0 : Prop) ‚àß (GeneralizedContinuedFraction.IntFractPair.of GeneralizedContinuedFraction.IntFractPair.fr w ‚Åª¬π = ifp_n : Prop)) (left : GeneralizedContinuedFraction.IntFractPair.fr w ‚â† 0) (ifp_of_eq_ifp_n : GeneralizedContinuedFraction.IntFractPair.of GeneralizedContinuedFraction.IntFractPair.fr w ‚Åª¬π = ifp_n)  : ifp_n = GeneralizedContinuedFraction.IntFractPair.of GeneralizedContinuedFraction.IntFractPair.fr w ‚Åª¬π
application type mismatch
  GeneralizedContinuedFraction.IntFractPair.stream v Nat.succ
argument
  Nat.succ
has type
  ‚Ñï ‚Üí ‚Ñï : Type
but is expected to have type
  ‚Ñï : Type ; identifiers [K, u_1, v, K, n, LinearOrderedField, K, FloorRing, K, ifp_n, GeneralizedContinuedFraction.IntFractPair, K, nth_stream_eq, GeneralizedContinuedFraction.IntFractPair.stream, v, n, some, ifp_n, n_1, h, n, Nat.succ, n_1, nth_stream_eq, GeneralizedContinuedFraction.IntFractPair.stream, v, Nat.succ, n_1, some, ifp_n, w, GeneralizedContinuedFraction.IntFractPair, K, h, GeneralizedContinuedFraction.IntFractPair.stream, v, n_1, some, w, GeneralizedContinuedFraction.IntFractPair.fr, w, GeneralizedContinuedFraction.IntFractPair.of, GeneralizedContinuedFraction.IntFractPair.fr, w, ifp_n, left, GeneralizedContinuedFraction.IntFractPair.stream, v, n_1, some, w, right, GeneralizedContinuedFraction.IntFractPair.fr, w, GeneralizedContinuedFraction.IntFractPair.of, GeneralizedContinuedFraction.IntFractPair.fr, w, ifp_n, left, GeneralizedContinuedFraction.IntFractPair.fr, w, ifp_of_eq_ifp_n, GeneralizedContinuedFraction.IntFractPair.of, GeneralizedContinuedFraction.IntFractPair.fr, w, ifp_n, ifp_n, GeneralizedContinuedFraction.IntFractPair.of, GeneralizedContinuedFraction.IntFractPair.fr, w] (during elaboration)

{R : Type u} [CommSemiring R] {I : Ideal R} (hi : Ideal.IsPrimary I) {x : R} {y : R} (x_1 : x * y ‚àà Ideal.radical I) (m : ‚Ñï) (hxy : x * y ^ m ‚àà I) (h : x ^ m ‚àà I) (h_1 : (And.right hi (Eq.mp ((mul_pow x y m =: x * y ^ m = x ^ m * y ^ m) ‚ñ∏ (Eq.refl (x * y ^ m ‚àà I : Prop) =: (x * y ^ m ‚àà I : Prop) = (x * y ^ m ‚àà I : Prop)) =: (x * y ^ m ‚àà I : Prop) = (x ^ m * y ^ m ‚àà I : Prop)) hxy =: x ^ m * y ^ m ‚àà I) =: (x ^ m ‚àà I : Prop) ‚à® (y ^ m ‚àà Ideal.radical I : Prop)) = (Or.inl h =: (x ^ m ‚àà I : Prop) ‚à® (y ^ m ‚àà Ideal.radical I : Prop)))  : (Or.inl h) = (And.right hi (Eq.mp ((mul_pow x y m) ‚ñ∏ (Eq.refl (x * y ^ m ‚àà I))) hxy))
<input>:1:208: expected term

{Œ± : Type u_2} {Œ≤ : Type u_1} [AddCommMonoid Œ±] [TopologicalSpace Œ±] {f : (a : Œ≤) ‚Üí Œ±} (h : Set.Finite Function.support f) (b : Œ≤)  : (f b = 0) = (f b = 0)
function expected at
  Set.Finite ?m.842
term has type
  Prop ; identifiers [Œ±, u_2, Œ≤, u_1, AddCommMonoid, Œ±, TopologicalSpace, Œ±, f, a, Œ≤, Œ±, h, Set.Finite, Function.support, f, b, Œ≤, f, b, f, b] (during elaboration)

 : (‚àÄ {Œ± : Type u} {Œ≤ : Type v} {f : (a : Œ±) ‚Üí Œ≤} {a : Œ±} {l : Filter Œ≤} , (Filter.Tendsto f pure a l) ‚Üî (‚àÄ (s : Set Œ≤) (a_1 : s ‚àà l) , f a ‚àà s))
application type mismatch
  Filter.Tendsto f pure
argument
  pure
has type
  ?m.28 ‚Üí ?m.26 ?m.28 : Type (max ?u.24 ?u.25)
but is expected to have type
  Filter Œ± : Type u ; identifiers [Œ±, u, Œ≤, v, f, a, Œ±, Œ≤, a, Œ±, l, Filter, Œ≤, Filter.Tendsto, f, pure, a, l, s, Set, Œ≤, a_1, s, l, f, a, s] (during elaboration)

 : ‚àÄ {Œ± : Type u} {Œ≤ : Type v} {f : (a : Œ±) ‚Üí Œ≤} {a : Œ±} {l : Filter Œ≤} , (Filter.Tendsto f pure a l) ‚Üî (Filter.Tendsto f pure a l)
application type mismatch
  Filter.Tendsto f pure
argument
  pure
has type
  ?m.28 ‚Üí ?m.26 ?m.28 : Type (max ?u.24 ?u.25)
but is expected to have type
  Filter Œ± : Type u ; identifiers [Œ±, u, Œ≤, v, f, a, Œ±, Œ≤, a, Œ±, l, Filter, Œ≤, Filter.Tendsto, f, pure, a, l, Filter.Tendsto, f, pure, a, l] (during elaboration)

{Œ± : Type u_2} {Œ≤ : Type u_1} [AddCommMonoid Œ±] [TopologicalSpace Œ±] {f : (a : Œ≤) ‚Üí Œ±} (h : Set.Finite Function.support f) (b : Œ≤)  : (‚àÄ (a : f b = 0) , f b = 0) = True
function expected at
  Set.Finite ?m.842
term has type
  Prop ; identifiers [Œ±, u_2, Œ≤, u_1, AddCommMonoid, Œ±, TopologicalSpace, Œ±, f, a, Œ≤, Œ±, h, Set.Finite, Function.support, f, b, Œ≤, a, f, b, f, b, True] (during elaboration)

{J : Type u‚ÇÅ} [inst : CategoryTheory.Category J] {C : Type u‚ÇÉ} [inst_1 : CategoryTheory.Category C] {F : CategoryTheory.Functor J C} {t : CategoryTheory.Limits.Cone F} (self : CategoryTheory.Limits.IsLimit t) (s : CategoryTheory.Limits.Cone F) (j : J)  : ‚àÄ (J : Type u‚ÇÅ) [inst : CategoryTheory.Category J] (C : Type u‚ÇÉ) [inst_2 : CategoryTheory.Category C] (F : CategoryTheory.Functor J C) (t : CategoryTheory.Limits.Cone F) (self : CategoryTheory.Limits.IsLimit t) (s : CategoryTheory.Limits.Cone F) (j : J) , CategoryTheory.CategoryStruct.comp self . 1 s CategoryTheory.NatTrans.app CategoryTheory.Limits.Cone.œÄ t j = CategoryTheory.NatTrans.app CategoryTheory.Limits.Cone.œÄ s j
unknown universe level 'u‚ÇÉ' ; identifiers [J, u‚ÇÅ, inst, CategoryTheory.Category, J, C, u‚ÇÉ, inst_1, CategoryTheory.Category, C, F, CategoryTheory.Functor, J, C, t, CategoryTheory.Limits.Cone, F, self, CategoryTheory.Limits.IsLimit, t, s, CategoryTheory.Limits.Cone, F, j, J, J, u‚ÇÅ, inst, CategoryTheory.Category, J, C, u‚ÇÉ, inst_2, CategoryTheory.Category, C, F, CategoryTheory.Functor, J, C, t, CategoryTheory.Limits.Cone, F, self, CategoryTheory.Limits.IsLimit, t, s, CategoryTheory.Limits.Cone, F, j, J, CategoryTheory.CategoryStruct.comp, self, s, CategoryTheory.NatTrans.app, CategoryTheory.Limits.Cone.œÄ, t, j, CategoryTheory.NatTrans.app, CategoryTheory.Limits.Cone.œÄ, s, j] (during elaboration)

{R : Type u} [CommSemiring R] {I : Ideal R} (hi : Ideal.IsPrimary I) {x : R} {y : R} (x_1 : x * y ‚àà Ideal.radical I) (m : ‚Ñï) (hxy : x * y ^ m ‚àà I) (h : y ^ m ‚àà Ideal.radical I) (h_1 : (And.right hi (Eq.mp ((mul_pow x y m =: x * y ^ m = x ^ m * y ^ m) ‚ñ∏ (Eq.refl (x * y ^ m ‚àà I : Prop) =: (x * y ^ m ‚àà I : Prop) = (x * y ^ m ‚àà I : Prop)) =: (x * y ^ m ‚àà I : Prop) = (x ^ m * y ^ m ‚àà I : Prop)) hxy =: x ^ m * y ^ m ‚àà I) =: (x ^ m ‚àà I : Prop) ‚à® (y ^ m ‚àà Ideal.radical I : Prop)) = (Or.inr h =: (x ^ m ‚àà I : Prop) ‚à® (y ^ m ‚àà Ideal.radical I : Prop)))  : (Or.inr h) = (And.right hi (Eq.mp ((mul_pow x y m) ‚ñ∏ (Eq.refl (x * y ^ m ‚àà I))) hxy))
<input>:1:222: expected term

{V : Type u_1} (G : SimpleGraph V) (s : Set Sym2 V) (a : V) (b : V)  : (‚àÄ (a_1 : (SimpleGraph.Adj G a b) \ (Quotient.mk Sym2.Rel.setoid V (a , b) ‚àà s)) , (SimpleGraph.Adj G a b) \ (Quotient.mk Sym2.Rel.setoid V (a , b) ‚àà s)) = True
application type mismatch
  Set Sym2
argument
  Sym2
has type
  Type ?u.11 ‚Üí Type ?u.11 : Type (?u.11 + 1)
but is expected to have type
  Type ?u.10 : Type (?u.10 + 1) ; identifiers [V, u_1, G, SimpleGraph, V, s, Set, Sym2, V, a, V, b, V, a_1, SimpleGraph.Adj, G, a, b, Quotient.mk, Sym2.Rel.setoid, V, a, b, s, SimpleGraph.Adj, G, a, b, Quotient.mk, Sym2.Rel.setoid, V, a, b, s, True] (during elaboration)

{C : Type u} [inst : CategoryTheory.Category C] [CategoryTheory.HasShift C ‚Ñ§] {T‚ÇÅ : CategoryTheory.Pretriangulated.Triangle C} {T‚ÇÇ : CategoryTheory.Pretriangulated.Triangle C} (self : CategoryTheory.Pretriangulated.TriangleMorphism T‚ÇÅ T‚ÇÇ)  : ‚àÄ (C : Type u) [inst : CategoryTheory.Category C] [inst_2 : CategoryTheory.HasShift C ‚Ñ§] (T‚ÇÅ : CategoryTheory.Pretriangulated.Triangle C) (T‚ÇÇ : CategoryTheory.Pretriangulated.Triangle C) (self : CategoryTheory.Pretriangulated.TriangleMorphism T‚ÇÅ T‚ÇÇ) , CategoryTheory.CategoryStruct.comp CategoryTheory.Pretriangulated.Triangle.mor‚ÇÇ T‚ÇÅ self . 3 = CategoryTheory.CategoryStruct.comp self . 2 CategoryTheory.Pretriangulated.Triangle.mor‚ÇÇ T‚ÇÇ
function expected at
  CategoryTheory.CategoryStruct.comp ?m.81555 ?m.161398
term has type
  ?m.961 ‚ü∂ ?m.963 ; identifiers [C, u, inst, CategoryTheory.Category, C, CategoryTheory.HasShift, C, T‚ÇÅ, CategoryTheory.Pretriangulated.Triangle, C, T‚ÇÇ, CategoryTheory.Pretriangulated.Triangle, C, self, CategoryTheory.Pretriangulated.TriangleMorphism, T‚ÇÅ, T‚ÇÇ, C, u, inst, CategoryTheory.Category, C, inst_2, CategoryTheory.HasShift, C, T‚ÇÅ, CategoryTheory.Pretriangulated.Triangle, C, T‚ÇÇ, CategoryTheory.Pretriangulated.Triangle, C, self, CategoryTheory.Pretriangulated.TriangleMorphism, T‚ÇÅ, T‚ÇÇ, CategoryTheory.CategoryStruct.comp, CategoryTheory.Pretriangulated.Triangle.mor‚ÇÇ, T‚ÇÅ, self, CategoryTheory.CategoryStruct.comp, self, CategoryTheory.Pretriangulated.Triangle.mor‚ÇÇ, T‚ÇÇ] (during elaboration)

 : (‚àÄ {Œ± : Type u_1} [inst : Union Œ±] {a : Part Œ±} {b : Part Œ±} (hab : Part.Dom a ‚à™ b) , Part.Dom a)
application type mismatch
  a.Dom ‚à™ b
argument
  b
has type
  Part Œ± : Type u_1
but is expected to have type
  Prop : Type ; identifiers [Œ±, u_1, inst, Union, Œ±, a, Part, Œ±, b, Part, Œ±, hab, Part.Dom, a, b, Part.Dom, a] (during elaboration)

 : ‚àÄ {Œ± : Type u_1} [inst : Union Œ±] {a : Part Œ±} {b : Part Œ±} (hab : Part.Dom a ‚à™ b) , Part.Dom fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚à™ x_1 <$> a
application type mismatch
  a.Dom ‚à™ b
argument
  b
has type
  Part Œ± : Type u_1
but is expected to have type
  Prop : Type ; identifiers [Œ±, u_1, inst, Union, Œ±, a, Part, Œ±, b, Part, Œ±, hab, Part.Dom, a, b, Part.Dom, x, Œ±, x_1, Œ±, x, x_1, a] (during elaboration)

{ùïú : Type u_1} {E : Type u_2} [SeminormedRing ùïú] [SMul ùïú E] {s : Set E} {t : Set E} (ht : Balanced ùïú t) (h : s ‚äÜ t) ‚¶É x : E ‚¶Ñ (hx : x ‚àà balancedHull ùïú s) (r : ùïú) (h_1 : ‚àÉ (x_1 : ‚Äñ r ‚Äñ ‚â§ 1) , x ‚àà r ‚Ä¢ s) (hr : ‚Äñ r ‚Äñ ‚â§ 1) (h_2 : x ‚àà r ‚Ä¢ s) (y : E) (h_3 : (y ‚àà s : Prop) ‚àß (fun (x : E) ‚Ü¶ r ‚Ä¢ x y = x : Prop)) (hy : y ‚àà s) (right : fun (x : E) ‚Ü¶ r ‚Ä¢ x y = x) (hx : fun (x : E) ‚Ü¶ r ‚Ä¢ x y ‚àà balancedHull ùïú s)  : y ‚àà t
<input>:1:184: expected term

{a : Cardinal .{u_1}} {b : Cardinal .{u_1}} (h : b ‚â† 0)  : (a ‚â§ a * b) = (a ‚â§ a * b)
<input>:1:14: expected '//', '|' or '}'

 : (‚àÄ {c : (a : Type u) ‚Üí Type u} {hom : ‚¶É Œ± : Type u ‚¶Ñ ‚Üí ‚¶É Œ≤ : Type u ‚¶Ñ ‚Üí (x : c Œ±) ‚Üí (x : c Œ≤) ‚Üí Type u} (self : CategoryTheory.BundledHom hom) {Œ± : Type u} {Œ≤ : Type u} {Œ≥ : Type u} (IŒ± : c Œ±) (IŒ≤ : c Œ≤) (IŒ≥ : c Œ≥) (f : hom IŒ± IŒ≤) (g : hom IŒ≤ IŒ≥) , CategoryTheory.BundledHom.toFun self IŒ± IŒ≥ CategoryTheory.BundledHom.comp self IŒ± IŒ≤ IŒ≥ g f = CategoryTheory.BundledHom.toFun self IŒ≤ IŒ≥ g ‚àò CategoryTheory.BundledHom.toFun self IŒ± IŒ≤ f)
application type mismatch
  CategoryTheory.BundledHom.toFun self IŒ± IŒ≥ CategoryTheory.BundledHom.comp
argument
  CategoryTheory.BundledHom.comp
has type
  CategoryTheory.BundledHom ?m.85 ‚Üí
    {Œ± Œ≤ Œ≥ : Type ?u.83} ‚Üí
      (IŒ± : ?m.84 Œ±) ‚Üí (IŒ≤ : ?m.84 Œ≤) ‚Üí (IŒ≥ : ?m.84 Œ≥) ‚Üí ?m.85 IŒ≤ IŒ≥ ‚Üí ?m.85 IŒ± IŒ≤ ‚Üí ?m.85 IŒ± IŒ≥ : Type (?u.83 + 1)
but is expected to have type
  hom IŒ± IŒ≥ : Type u ; identifiers [c, a, u, u, hom, Œ±, u, Œ≤, u, x, c, Œ±, x, c, Œ≤, u, self, CategoryTheory.BundledHom, hom, Œ±, u, Œ≤, u, Œ≥, u, IŒ±, c, Œ±, IŒ≤, c, Œ≤, IŒ≥, c, Œ≥, f, hom, IŒ±, IŒ≤, g, hom, IŒ≤, IŒ≥, CategoryTheory.BundledHom.toFun, self, IŒ±, IŒ≥, CategoryTheory.BundledHom.comp, self, IŒ±, IŒ≤, IŒ≥, g, f, CategoryTheory.BundledHom.toFun, self, IŒ≤, IŒ≥, g, CategoryTheory.BundledHom.toFun, self, IŒ±, IŒ≤, f] (during elaboration)

 : ‚àÄ (c : (a : Type u) ‚Üí Type u) (hom : ‚¶É Œ± : Type u ‚¶Ñ ‚Üí ‚¶É Œ≤ : Type u ‚¶Ñ ‚Üí (x : c Œ±) ‚Üí (x : c Œ≤) ‚Üí Type u) (self : CategoryTheory.BundledHom hom) {Œ± : Type u} {Œ≤ : Type u} {Œ≥ : Type u} (IŒ± : c Œ±) (IŒ≤ : c Œ≤) (IŒ≥ : c Œ≥) (f : hom IŒ± IŒ≤) (g : hom IŒ≤ IŒ≥) , self . 1 IŒ± IŒ≥ self . 3 IŒ± IŒ≤ IŒ≥ g f = self . 1 IŒ≤ IŒ≥ g ‚àò self . 1 IŒ± IŒ≤ f
function expected at
  self
term has type
  CategoryTheory.BundledHom hom ; identifiers [c, a, u, u, hom, Œ±, u, Œ≤, u, x, c, Œ±, x, c, Œ≤, u, self, CategoryTheory.BundledHom, hom, Œ±, u, Œ≤, u, Œ≥, u, IŒ±, c, Œ±, IŒ≤, c, Œ≤, IŒ≥, c, Œ≥, f, hom, IŒ±, IŒ≤, g, hom, IŒ≤, IŒ≥, self, IŒ±, IŒ≥, self, IŒ±, IŒ≤, IŒ≥, g, f, self, IŒ≤, IŒ≥, g, self, IŒ±, IŒ≤, f] (during elaboration)

 : (‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} {l : Filter Œ±} {r : (a : Œ≤) ‚Üí (a : Œ≥) ‚Üí Prop} {f : (a : Œ±) ‚Üí Œ≤} {g : (a : Œ±) ‚Üí Œ≥} , (Filter.Germ.LiftRel r ‚Üë f ‚Üë g) ‚Üî (‚àÄ·∂† (x : Œ±) in l , r f x g x))
application type mismatch
  r f
argument
  f
has type
  Œ± ‚Üí Œ≤ : Type (max u_1 u_2)
but is expected to have type
  Œ≤ : Type u_2 ; identifiers [Œ±, u_1, Œ≤, u_2, Œ≥, u_3, l, Filter, Œ±, r, a, Œ≤, a, Œ≥, f, a, Œ±, Œ≤, g, a, Œ±, Œ≥, Filter.Germ.LiftRel, r, f, g, x, Œ±, l, r, f, x, g, x] (during elaboration)

 : ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} {l : Filter Œ±} {r : (a : Œ≤) ‚Üí (a : Œ≥) ‚Üí Prop} {f : (a : Œ±) ‚Üí Œ≤} {g : (a : Œ±) ‚Üí Œ≥} , (Filter.Germ.LiftRel r ‚Üë f ‚Üë g) ‚Üî (Filter.Germ.LiftRel r ‚Üë f ‚Üë g)
type mismatch
  g
has type
  Œ± ‚Üí Œ≥ : Type (max u_1 u_3)
but is expected to have type
  Filter.Germ ?m.404 Œ≥ : Type (max ?u.218 u_3) ; identifiers [Œ±, u_1, Œ≤, u_2, Œ≥, u_3, l, Filter, Œ±, r, a, Œ≤, a, Œ≥, f, a, Œ±, Œ≤, g, a, Œ±, Œ≥, Filter.Germ.LiftRel, r, f, g, Filter.Germ.LiftRel, r, f, g] (during elaboration)

{M : Type u_2} {N : Type u_1} [AddSemigroup M] [AddSemigroup N] {s : Set M} (f : (a : M) ‚Üí N) (hs : AddSubsemigroup.closure s = ‚ä§) (hmul : ‚àÄ (x : M) (y : M) (a : y ‚àà s) , f x + y = f x + f y) (x : M) (y : M)  : ‚àÄ (y : M) (hy : y ‚àà s) (x : M) , f x + y = f x + f y
failed to synthesize instance
  HAdd N M ?m.159932 ; identifiers [M, u_2, N, u_1, AddSemigroup, M, AddSemigroup, N, s, Set, M, f, a, M, N, hs, AddSubsemigroup.closure, s, hmul, x, M, y, M, a, y, s, f, x, y, f, x, f, y, x, M, y, M, y, M, hy, y, s, x, M, f, x, y, f, x, f, y] (during elaboration)

 : ‚àÄ (Œ± : Type u_1) [inst : Lattice Œ±] [inst_1 : OrderBot Œ±] (a : Œ±) (self : Finpartition a) , ¬¨ (‚ä• ‚àà self . 1)
function expected at
  self
term has type
  Finpartition a ; identifiers [Œ±, u_1, inst, Lattice, Œ±, inst_1, OrderBot, Œ±, a, Œ±, self, Finpartition, a, self] (during elaboration)

{M : Type u_2} {N : Type u_1} [AddSemigroup M] [AddSemigroup N] {s : Set M} (f : (a : M) ‚Üí N) (hs : AddSubsemigroup.closure s = ‚ä§) (hmul : ‚àÄ (x : M) (y : M) (a : y ‚àà s) , f x + y = f x + f y) (x : M) (y : M) (y‚ÇÅ : M) (y‚ÇÇ : M) (h‚ÇÅ : ‚àÄ (x : M) , f x + y‚ÇÅ = f x + f y‚ÇÅ) (h‚ÇÇ : ‚àÄ (x : M) , f x + y‚ÇÇ = f x + f y‚ÇÇ) (x : M)  : ‚àÄ (x : M) , f x + y‚ÇÇ = f x + f y‚ÇÇ
failed to synthesize instance
  HAdd N M ?m.159932 ; identifiers [M, u_2, N, u_1, AddSemigroup, M, AddSemigroup, N, s, Set, M, f, a, M, N, hs, AddSubsemigroup.closure, s, hmul, x, M, y, M, a, y, s, f, x, y, f, x, f, y, x, M, y, M, y‚ÇÅ, M, y‚ÇÇ, M, h‚ÇÅ, x, M, f, x, y‚ÇÅ, f, x, f, y‚ÇÅ, h‚ÇÇ, x, M, f, x, y‚ÇÇ, f, x, f, y‚ÇÇ, x, M, x, M, f, x, y‚ÇÇ, f, x, f, y‚ÇÇ] (during elaboration)

{M : Type u_2} {N : Type u_1} [AddSemigroup M] [AddSemigroup N] {s : Set M} (f : (a : M) ‚Üí N) (hs : AddSubsemigroup.closure s = ‚ä§) (hmul : ‚àÄ (x : M) (y : M) (a : y ‚àà s) , f x + y = f x + f y) (x : M) (y : M) (y‚ÇÅ : M) (y‚ÇÇ : M) (h‚ÇÅ : ‚àÄ (x : M) , f x + y‚ÇÅ = f x + f y‚ÇÅ) (h‚ÇÇ : ‚àÄ (x : M) , f x + y‚ÇÇ = f x + f y‚ÇÇ) (x : M)  : ‚àÄ (x : M) , f x + y‚ÇÅ = f x + f y‚ÇÅ
failed to synthesize instance
  HAdd N M ?m.159932 ; identifiers [M, u_2, N, u_1, AddSemigroup, M, AddSemigroup, N, s, Set, M, f, a, M, N, hs, AddSubsemigroup.closure, s, hmul, x, M, y, M, a, y, s, f, x, y, f, x, f, y, x, M, y, M, y‚ÇÅ, M, y‚ÇÇ, M, h‚ÇÅ, x, M, f, x, y‚ÇÅ, f, x, f, y‚ÇÅ, h‚ÇÇ, x, M, f, x, y‚ÇÇ, f, x, f, y‚ÇÇ, x, M, x, M, f, x, y‚ÇÅ, f, x, f, y‚ÇÅ] (during elaboration)

{Œ± : Type u_1} {m : (a : Set Œ±) ‚Üí ENNReal} {s : Set Œ±} {t : Set Œ±} (h : ‚àÄ (u : Set Œ±) (a : Set.Nonempty s ‚à© u) (a : Set.Nonempty t ‚à© u) , m u = ‚ä§) (u : Set Œ±) (hs : Set.Nonempty s ‚à© u) (ht : Set.Nonempty t ‚à© u)  : m u = ‚ä§
application type mismatch
  Set.Nonempty s ‚à© u
argument
  u
has type
  Set Œ± : Type u_1
but is expected to have type
  Prop : Type ; identifiers [Œ±, u_1, m, a, Set, Œ±, ENNReal, s, Set, Œ±, t, Set, Œ±, h, u, Set, Œ±, a, Set.Nonempty, s, u, a, Set.Nonempty, t, u, m, u, u, Set, Œ±, hs, Set.Nonempty, s, u, ht, Set.Nonempty, t, u, m, u] (during elaboration)

{œÉ : Type u_1} {k : Type u_2} [Field k] (œÜ : MvPowerSeries œÉ k) (u : k À£) (h : ‚Üë MvPowerSeries.constantCoeff œÉ k œÜ = ‚Üë u)  : ‚Üë u = ‚Üë MvPowerSeries.constantCoeff œÉ k œÜ
type mismatch
  u
has type
  kÀ£ : Type u_2
but is expected to have type
  ?m.308 œÜ u h : Sort ?u.235 ; identifiers [œÉ, u_1, k, u_2, Field, k, œÜ, MvPowerSeries, œÉ, k, u, k, h, MvPowerSeries.constantCoeff, œÉ, k, œÜ, u, u, MvPowerSeries.constantCoeff, œÉ, k, œÜ] (during elaboration)

{X : Type u_2} [TopologicalSpace X] {Y : Type u_1} [TopologicalSpace Y] {f : (a : OnePoint X) ‚Üí Y} {x : X}  : (Filter.Tendsto f ‚àò OnePoint.some nhds x nhds f ‚Üë x) ‚Üî (Filter.Tendsto f ‚àò OnePoint.some nhds x nhds f ‚Üë x)
function expected at
  ‚Üënhds
term has type
  OnePoint (?m.55 ‚Üí Filter ?m.55) ; identifiers [X, u_2, TopologicalSpace, X, Y, u_1, TopologicalSpace, Y, f, a, OnePoint, X, Y, x, X, Filter.Tendsto, f, OnePoint.some, nhds, x, nhds, f, x, Filter.Tendsto, f, OnePoint.some, nhds, x, nhds, f, x] (during elaboration)

{R : Type u} [Semiring R] {n : ‚Ñï} {f : Polynomial R}  : (‚àÄ (i : ‚Ñï) (i_1 : i ‚â• n) , f ‚àà LinearMap.ker Polynomial.lcoeff R i) ‚Üî (‚àÄ (i : ‚Ñï) (i_1 : i ‚â• n) , f ‚àà LinearMap.ker Polynomial.lcoeff R i)
function expected at
  LinearMap.ker Polynomial.lcoeff
term has type
  Submodule ?m.114 ?m.116 ; identifiers [R, u, Semiring, R, n, f, Polynomial, R, i, i_1, i, n, f, LinearMap.ker, Polynomial.lcoeff, R, i, i, i_1, i, n, f, LinearMap.ker, Polynomial.lcoeff, R, i] (during elaboration)

{Œ± : Type u_1} [CommMonoidWithZero Œ±] (p : Œ±)  : (¬¨ (IsUnit Associates.mk p)) ‚Üî (¬¨ (IsUnit Associates.mk p))
function expected at
  IsUnit Associates.mk
term has type
  Prop ; identifiers [Œ±, u_1, CommMonoidWithZero, Œ±, p, Œ±, IsUnit, Associates.mk, p, IsUnit, Associates.mk, p] (during elaboration)

{Œ± : Type u_1} {Œ≤ : Type u_2} [LinearOrder Œ≤] [Inf Œ±] (f : (a : Œ±) ‚Üí Œ≤) (inj : Function.Injective f) (hinf : ‚àÄ (x : Œ±) (y : Œ±) , f x ‚äì y = min f x f y) (x : Œ±) (y : Œ±)  : f x ‚äì y = min f x f y
application type mismatch
  f x ‚äì y
argument
  y
has type
  Œ± : Type u_1
but is expected to have type
  Œ≤ : Type u_2 ; identifiers [Œ±, u_1, Œ≤, u_2, LinearOrder, Œ≤, Inf, Œ±, f, a, Œ±, Œ≤, inj, Function.Injective, f, hinf, x, Œ±, y, Œ±, f, x, y, min, f, x, f, y, x, Œ±, y, Œ±, f, x, y, min, f, x, f, y] (during elaboration)

{R : Type u_1} {V : Type u_2} {P : Type u_3} [LinearOrderedField R] [AddCommGroup V] [Module R V] [AddTorsor V P] {s : AffineSubspace R P} {x : P} {y : P} {p‚ÇÅ : P} (h : p‚ÇÅ ‚àà s) (hx : ¬¨ (x ‚àà s : Prop))  : ((¬¨ (y ‚àà s)) ‚àß (‚àÉ (p‚ÇÇ : P) , (p‚ÇÇ ‚àà s) ‚àß (SameRay R x -·µ• p‚ÇÅ y -·µ• p‚ÇÇ))) ‚Üî ((¬¨ (y ‚àà s)) ‚àß (‚àÉ (p‚ÇÇ : P) , (p‚ÇÇ ‚àà s) ‚àß (SameRay R x -·µ• p‚ÇÅ y -·µ• p‚ÇÇ)))
failed to synthesize instance
  AddCommMonoid P ; identifiers [R, u_1, V, u_2, P, u_3, LinearOrderedField, R, AddCommGroup, V, Module, R, V, AddTorsor, V, P, s, AffineSubspace, R, P, x, P, y, P, p‚ÇÅ, P, h, p‚ÇÅ, s, hx, x, s, y, s, p‚ÇÇ, P, p‚ÇÇ, s, SameRay, R, x, p‚ÇÅ, y, p‚ÇÇ, y, s, p‚ÇÇ, P, p‚ÇÇ, s, SameRay, R, x, p‚ÇÅ, y, p‚ÇÇ] (during elaboration)

{V‚ÇÅ : Type u_2} {V‚ÇÇ : Type u_1} [SeminormedAddCommGroup V‚ÇÅ] [SeminormedAddCommGroup V‚ÇÇ] (n : ‚Ñï) (f : NormedAddGroupHom V‚ÇÅ V‚ÇÇ) (b : ‚Ñù) (hb : ‚àÄ (v : V‚ÇÅ) , ‚Äñ NormedAddGroupHom.toFun f v ‚Äñ ‚â§ b * ‚Äñ v ‚Äñ) (v : V‚ÇÅ)  : (‚Äñ n ‚Ä¢ ‚Üë f v ‚Äñ ‚â§ n ‚Ä¢ b * ‚Äñ v ‚Äñ) = (‚Äñ n ‚Ä¢ ‚Üë f v ‚Äñ ‚â§ n ‚Ä¢ b * ‚Äñ v ‚Äñ)
<input>:1:185: expected term

{V‚ÇÅ : Type u_2} {V‚ÇÇ : Type u_1} [SeminormedAddCommGroup V‚ÇÅ] [SeminormedAddCommGroup V‚ÇÇ] (n : ‚Ñï) (f : NormedAddGroupHom V‚ÇÅ V‚ÇÇ) (b : ‚Ñù) (hb : ‚àÄ (v : V‚ÇÅ) , ‚Äñ NormedAddGroupHom.toFun f v ‚Äñ ‚â§ b * ‚Äñ v ‚Äñ) (v : V‚ÇÅ)  : (‚Äñ n ‚Ä¢ ‚Üë f v ‚Äñ ‚â§ n ‚Ä¢ b * ‚Äñ v ‚Äñ) = (‚Äñ n ‚Ä¢ ‚Üë f v ‚Äñ ‚â§ n ‚Ä¢ b * ‚Äñ v ‚Äñ)
<input>:1:185: expected term

{V‚ÇÅ : Type u_2} {V‚ÇÇ : Type u_1} [SeminormedAddCommGroup V‚ÇÅ] [SeminormedAddCommGroup V‚ÇÇ] (n : ‚Ñï) (f : NormedAddGroupHom V‚ÇÅ V‚ÇÇ) (b : ‚Ñù) (hb : ‚àÄ (v : V‚ÇÅ) , ‚Äñ NormedAddGroupHom.toFun f v ‚Äñ ‚â§ b * ‚Äñ v ‚Äñ) (v : V‚ÇÅ)  : (‚Äñ n ‚Ä¢ ‚Üë f v ‚Äñ ‚â§ ‚Üë n * b * ‚Äñ v ‚Äñ) = (‚Äñ n ‚Ä¢ ‚Üë f v ‚Äñ ‚â§ ‚Üë n * b * ‚Äñ v ‚Äñ)
<input>:1:185: expected term

{V‚ÇÅ : Type u_2} {V‚ÇÇ : Type u_1} [SeminormedAddCommGroup V‚ÇÅ] [SeminormedAddCommGroup V‚ÇÇ] (n : ‚Ñï) (f : NormedAddGroupHom V‚ÇÅ V‚ÇÇ) (b : ‚Ñù) (hb : ‚àÄ (v : V‚ÇÅ) , ‚Äñ NormedAddGroupHom.toFun f v ‚Äñ ‚â§ b * ‚Äñ v ‚Äñ) (v : V‚ÇÅ)  : ‚Äñ NormedAddGroupHom.toFun f v ‚Äñ ‚â§ b * ‚Äñ v ‚Äñ
<input>:1:185: expected term

{R : Type u_1} {M : Type u_2} [Semiring R] [AddCommGroup M] (toSMul : SMul R M) (smul_add : ‚àÄ (r : R) (x : M) (y : M) , r ‚Ä¢ x + y = r ‚Ä¢ x + r ‚Ä¢ y) (add_smul : ‚àÄ (r : R) (s : R) (x : M) , r + s ‚Ä¢ x = r ‚Ä¢ x + s ‚Ä¢ x) (mul_smul : ‚àÄ (r : R) (s : R) (x : M) , r * s ‚Ä¢ x = r ‚Ä¢ s ‚Ä¢ x) (one_smul : ‚àÄ (x : M) , 1 ‚Ä¢ x = x) (toSMul_1 : SMul R M) (smul_add_1 : ‚àÄ (r : R) (x : M) (y : M) , r ‚Ä¢ x + y = r ‚Ä¢ x + r ‚Ä¢ y) (add_smul_1 : ‚àÄ (r : R) (s : R) (x : M) , r + s ‚Ä¢ x = r ‚Ä¢ x + s ‚Ä¢ x) (mul_smul_1 : ‚àÄ (r : R) (s : R) (x : M) , r * s ‚Ä¢ x = r ‚Ä¢ s ‚Ä¢ x) (one_smul_1 : ‚àÄ (x : M) , 1 ‚Ä¢ x = x) (a : {toSMul := ((toSMul)) , smul_add := ((smul_add)) , add_smul := ((add_smul)) , mul_smul := ((mul_smul)) , one_smul := ((one_smul))} = {toSMul := ((toSMul_1)) , smul_add := ((smul_add_1)) , add_smul := ((add_smul_1)) , mul_smul := ((mul_smul_1)) , one_smul := ((one_smul_1))})  : ‚àÄ (toSMul_eq : toSMul = toSMul_1) , toSMul = toSMul_1
failed to synthesize instance
  HAdd R M ?m.161013 ; identifiers [R, u_1, M, u_2, Semiring, R, AddCommGroup, M, toSMul, SMul, R, M, smul_add, r, R, x, M, y, M, r, x, y, r, x, r, y, add_smul, r, R, s, R, x, M, r, s, x, r, x, s, x, mul_smul, r, R, s, R, x, M, r, s, x, r, s, x, one_smul, x, M, x, x, toSMul_1, SMul, R, M, smul_add_1, r, R, x, M, y, M, r, x, y, r, x, r, y, add_smul_1, r, R, s, R, x, M, r, s, x, r, x, s, x, mul_smul_1, r, R, s, R, x, M, r, s, x, r, s, x, one_smul_1, x, M, x, x, a, toSMul, toSMul, smul_add, smul_add, add_smul, add_smul, mul_smul, mul_smul, one_smul, one_smul, toSMul, toSMul_1, smul_add, smul_add_1, add_smul, add_smul_1, mul_smul, mul_smul_1, one_smul, one_smul_1, toSMul_eq, toSMul, toSMul_1, toSMul, toSMul_1] (during elaboration)

(x : Num) (x_1 : Num) (a : PosNum) (b : PosNum) (this : Ordering.casesOn PosNum.cmp a b (‚Üë a < ‚Üë b : Prop) (a = b : Prop) (‚Üë b < ‚Üë a : Prop)) (h : PosNum.cmp a b = Ordering.lt)  : Ordering.lt = PosNum.cmp a b
application type mismatch
  Ordering.casesOn PosNum.cmp
argument
  PosNum.cmp
has type
  PosNum ‚Üí PosNum ‚Üí Ordering : Type
but is expected to have type
  Ordering : Type ; identifiers [x, Num, x_1, Num, a, PosNum, b, PosNum, this, Ordering.casesOn, PosNum.cmp, a, b, a, b, a, b, b, a, h, PosNum.cmp, a, b, Ordering.lt, Ordering.lt, PosNum.cmp, a, b] (during elaboration)

{X : Type u_1} (R : Type u_2) [TopologicalSpace X] [Semiring R] [TopologicalSpace R] [TopologicalSemiring R] (s : Set X) (c : C(X , R)) (f : C(X , R)) (hf : f ‚àà AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup {toAddSubsemigroup := (({carrier := (({f : C(X , R) | ‚àÄ (x : X) (a : x ‚àà s ·∂ú) , ‚Üë f x = 0})) , add_mem' := (((fun {f : C(X , R)} {g : C(X , R)} (hf : f ‚àà {f : C(X , R) | ‚àÄ (x : X) (a : x ‚àà s ·∂ú) , ‚Üë f x = 0}) (hg : g ‚àà {f : C(X , R) | ‚àÄ (x : X) (a : x ‚àà s ·∂ú) , ‚Üë f x = 0}) (x : X) (hx : x ‚àà s ·∂ú) ‚Ü¶ of_eq_true (Eq.trans (congrFun (congrArg Eq (Eq.trans (congr (congrArg HAdd.hAdd (hf x hx =: ‚Üë f x = 0) =: HAdd.hAdd ‚Üë f x = HAdd.hAdd 0) (hg x hx =: ‚Üë g x = 0) =: ‚Üë f x + ‚Üë g x = 0 + 0) (add_zero 0 =: 0 + 0 = 0) =: ‚Üë f x + ‚Üë g x = 0) =: Eq ‚Üë f x + ‚Üë g x = Eq 0) 0 =: (‚Üë f x + ‚Üë g x = 0 : Prop) = (0 = 0 : Prop)) (eq_self 0 =: (0 = 0 : Prop) = (True : Prop)) =: (‚Üë f x + ‚Üë g x = 0 : Prop) = (True : Prop)) =: ‚àÄ {f : C(X , R)} {g : C(X , R)} (hf : f ‚àà {f : C(X , R) | ‚àÄ (x : X) (a : x ‚àà s ·∂ú) , ‚Üë f x = 0}) (hg : g ‚àà {f : C(X , R) | ‚àÄ (x : X) (a : x ‚àà s ·∂ú) , ‚Üë f x = 0}) (x : X) (hx : x ‚àà s ·∂ú) , ‚Üë f x + ‚Üë g x = 0)))})) , zero_mem' := (((fun (x : X) (x_1 : x ‚àà s ·∂ú) ‚Ü¶ rfl =: ‚àÄ (x : X) (x_1 : x ‚àà s ·∂ú) , ‚Üë 0 x = ‚Üë 0 x)))}) (x : X) (hx : x ‚àà s ·∂ú)  : ‚Üë f x = 0
<input>:1:604: expected term

{Œπ : Type u_2} {E : Type u_1} [SeminormedAddCommGroup E] [CompleteSpace E] {f : (a : Œπ) ‚Üí E}  : (‚àÄ (Œµ : ‚Ñù) (a : Œµ > 0) , ‚àÉ (s : Finset Œπ) , ‚àÄ (t : Finset Œπ) (a : Disjoint t s) , ‚Äñ Finset.sum t fun (i : Œπ) ‚Ü¶ f i ‚Äñ < Œµ) ‚Üî (‚àÄ (Œµ : ‚Ñù) (a : Œµ > 0) , ‚àÉ (s : Finset Œπ) , ‚àÄ (t : Finset Œπ) (a : Disjoint t s) , ‚Äñ Finset.sum t fun (i : Œπ) ‚Ü¶ f i ‚Äñ < Œµ)
<input>:1:213: expected term

(x : Num) (x_1 : Num) (a : PosNum) (b : PosNum) (this : Ordering.casesOn PosNum.cmp a b (‚Üë a < ‚Üë b : Prop) (a = b : Prop) (‚Üë b < ‚Üë a : Prop)) (h : PosNum.cmp a b = Ordering.eq)  : Ordering.eq = PosNum.cmp a b
application type mismatch
  Ordering.casesOn PosNum.cmp
argument
  PosNum.cmp
has type
  PosNum ‚Üí PosNum ‚Üí Ordering : Type
but is expected to have type
  Ordering : Type ; identifiers [x, Num, x_1, Num, a, PosNum, b, PosNum, this, Ordering.casesOn, PosNum.cmp, a, b, a, b, a, b, b, a, h, PosNum.cmp, a, b, Ordering.eq, Ordering.eq, PosNum.cmp, a, b] (during elaboration)

(x : Num) (x_1 : Num) (a : PosNum) (b : PosNum) (this : Ordering.casesOn PosNum.cmp a b (‚Üë a < ‚Üë b : Prop) (a = b : Prop) (‚Üë b < ‚Üë a : Prop)) (h : PosNum.cmp a b = Ordering.gt)  : Ordering.gt = PosNum.cmp a b
application type mismatch
  Ordering.casesOn PosNum.cmp
argument
  PosNum.cmp
has type
  PosNum ‚Üí PosNum ‚Üí Ordering : Type
but is expected to have type
  Ordering : Type ; identifiers [x, Num, x_1, Num, a, PosNum, b, PosNum, this, Ordering.casesOn, PosNum.cmp, a, b, a, b, a, b, b, a, h, PosNum.cmp, a, b, Ordering.gt, Ordering.gt, PosNum.cmp, a, b] (during elaboration)

{V : Type u} {G : SimpleGraph V} {u : V} {v : V} (p : SimpleGraph.Walk G u v) {e : Sym2 V} {u : V} {v : V} {w : V} (h : SimpleGraph.Adj G u v) (p : SimpleGraph.Walk G v w) (p_ih : (e ‚àà SimpleGraph.Subgraph.edgeSet SimpleGraph.Walk.toSubgraph p : Prop) ‚Üî (e ‚àà SimpleGraph.Walk.edges p : Prop))  : (e ‚àà Quotient.mk Sym2.Rel.setoid V (u , v) :: SimpleGraph.Walk.edges p) = ((e = Quotient.mk Sym2.Rel.setoid V (u , v)) ‚à® (e ‚àà SimpleGraph.Walk.edges p))
failed to synthesize instance
  Membership (Sym2 V) Prop ; identifiers [V, u, G, SimpleGraph, V, u, V, v, V, p, SimpleGraph.Walk, G, u, v, e, Sym2, V, u, V, v, V, w, V, h, SimpleGraph.Adj, G, u, v, p, SimpleGraph.Walk, G, v, w, p_ih, e, SimpleGraph.Subgraph.edgeSet, SimpleGraph.Walk.toSubgraph, p, e, SimpleGraph.Walk.edges, p, e, Quotient.mk, Sym2.Rel.setoid, V, u, v, SimpleGraph.Walk.edges, p, e, Quotient.mk, Sym2.Rel.setoid, V, u, v, e, SimpleGraph.Walk.edges, p] (during elaboration)

 : (‚àÄ {G : Type w} [inst : TopologicalSpace G] [inst_1 : SizeOf G] (toFun : (a : TopologicalSpace.Compacts G) ‚Üí NNReal) (mono' : ‚àÄ (K‚ÇÅ : TopologicalSpace.Compacts G) (K‚ÇÇ : TopologicalSpace.Compacts G) (a : ‚Üë K‚ÇÅ ‚äÜ ‚Üë K‚ÇÇ) , toFun K‚ÇÅ ‚â§ toFun K‚ÇÇ) (sup_disjoint' : ‚àÄ (K‚ÇÅ : TopologicalSpace.Compacts G) (K‚ÇÇ : TopologicalSpace.Compacts G) (a : Disjoint ‚Üë K‚ÇÅ ‚Üë K‚ÇÇ) , toFun K‚ÇÅ ‚äî K‚ÇÇ = toFun K‚ÇÅ + toFun K‚ÇÇ) (sup_le' : ‚àÄ (K‚ÇÅ : TopologicalSpace.Compacts G) (K‚ÇÇ : TopologicalSpace.Compacts G) , toFun K‚ÇÅ ‚äî K‚ÇÇ ‚â§ toFun K‚ÇÅ + toFun K‚ÇÇ) , sizeOf {toFun := ((toFun)) , mono' := ((mono')) , sup_disjoint' := ((sup_disjoint')) , sup_le' := ((sup_le'))} = 1)
application type mismatch
  toFun K‚ÇÅ ‚äî K‚ÇÇ
argument
  K‚ÇÇ
has type
  TopologicalSpace.Compacts G : Type w
but is expected to have type
  NNReal : Type ; identifiers [G, w, inst, TopologicalSpace, G, inst_1, SizeOf, G, toFun, a, TopologicalSpace.Compacts, G, NNReal, mono', K‚ÇÅ, TopologicalSpace.Compacts, G, K‚ÇÇ, TopologicalSpace.Compacts, G, a, K‚ÇÅ, K‚ÇÇ, toFun, K‚ÇÅ, toFun, K‚ÇÇ, sup_disjoint', K‚ÇÅ, TopologicalSpace.Compacts, G, K‚ÇÇ, TopologicalSpace.Compacts, G, a, Disjoint, K‚ÇÅ, K‚ÇÇ, toFun, K‚ÇÅ, K‚ÇÇ, toFun, K‚ÇÅ, toFun, K‚ÇÇ, sup_le', K‚ÇÅ, TopologicalSpace.Compacts, G, K‚ÇÇ, TopologicalSpace.Compacts, G, toFun, K‚ÇÅ, K‚ÇÇ, toFun, K‚ÇÅ, toFun, K‚ÇÇ, sizeOf, toFun, toFun, mono', mono', sup_disjoint', sup_disjoint', sup_le', sup_le'] (during elaboration)

 : ‚àÄ {G : Type w} [inst : TopologicalSpace G] [inst_1 : SizeOf G] (toFun : (a : TopologicalSpace.Compacts G) ‚Üí NNReal) (mono' : ‚àÄ (K‚ÇÅ : TopologicalSpace.Compacts G) (K‚ÇÇ : TopologicalSpace.Compacts G) (a : ‚Üë K‚ÇÅ ‚äÜ ‚Üë K‚ÇÇ) , toFun K‚ÇÅ ‚â§ toFun K‚ÇÇ) (sup_disjoint' : ‚àÄ (K‚ÇÅ : TopologicalSpace.Compacts G) (K‚ÇÇ : TopologicalSpace.Compacts G) (a : Disjoint ‚Üë K‚ÇÅ ‚Üë K‚ÇÇ) , toFun K‚ÇÅ ‚äî K‚ÇÇ = toFun K‚ÇÅ + toFun K‚ÇÇ) (sup_le' : ‚àÄ (K‚ÇÅ : TopologicalSpace.Compacts G) (K‚ÇÇ : TopologicalSpace.Compacts G) , toFun K‚ÇÅ ‚äî K‚ÇÇ ‚â§ toFun K‚ÇÅ + toFun K‚ÇÇ) , 1 = 1
application type mismatch
  toFun K‚ÇÅ ‚äî K‚ÇÇ
argument
  K‚ÇÇ
has type
  TopologicalSpace.Compacts G : Type w
but is expected to have type
  NNReal : Type ; identifiers [G, w, inst, TopologicalSpace, G, inst_1, SizeOf, G, toFun, a, TopologicalSpace.Compacts, G, NNReal, mono', K‚ÇÅ, TopologicalSpace.Compacts, G, K‚ÇÇ, TopologicalSpace.Compacts, G, a, K‚ÇÅ, K‚ÇÇ, toFun, K‚ÇÅ, toFun, K‚ÇÇ, sup_disjoint', K‚ÇÅ, TopologicalSpace.Compacts, G, K‚ÇÇ, TopologicalSpace.Compacts, G, a, Disjoint, K‚ÇÅ, K‚ÇÇ, toFun, K‚ÇÅ, K‚ÇÇ, toFun, K‚ÇÅ, toFun, K‚ÇÇ, sup_le', K‚ÇÅ, TopologicalSpace.Compacts, G, K‚ÇÇ, TopologicalSpace.Compacts, G, toFun, K‚ÇÅ, K‚ÇÇ, toFun, K‚ÇÅ, toFun, K‚ÇÇ] (during elaboration)

{R : Type u_1} {M : Type u_2} [Semiring R] [AddCommGroup M] (toSMul : SMul R M) (smul_add : ‚àÄ (r : R) (x : M) (y : M) , r ‚Ä¢ x + y = r ‚Ä¢ x + r ‚Ä¢ y) (add_smul : ‚àÄ (r : R) (s : R) (x : M) , r + s ‚Ä¢ x = r ‚Ä¢ x + s ‚Ä¢ x) (mul_smul : ‚àÄ (r : R) (s : R) (x : M) , r * s ‚Ä¢ x = r ‚Ä¢ s ‚Ä¢ x) (one_smul : ‚àÄ (x : M) , 1 ‚Ä¢ x = x) (toSMul_1 : SMul R M) (smul_add_1 : ‚àÄ (r : R) (x : M) (y : M) , r ‚Ä¢ x + y = r ‚Ä¢ x + r ‚Ä¢ y) (add_smul_1 : ‚àÄ (r : R) (s : R) (x : M) , r + s ‚Ä¢ x = r ‚Ä¢ x + s ‚Ä¢ x) (mul_smul_1 : ‚àÄ (r : R) (s : R) (x : M) , r * s ‚Ä¢ x = r ‚Ä¢ s ‚Ä¢ x) (one_smul_1 : ‚àÄ (x : M) , 1 ‚Ä¢ x = x) (a : toSMul = toSMul_1) (h : toSMul_1 = toSMul) (toSMul_2 : SMul R M)  : toSMul = toSMul
failed to synthesize instance
  HAdd R M ?m.161013 ; identifiers [R, u_1, M, u_2, Semiring, R, AddCommGroup, M, toSMul, SMul, R, M, smul_add, r, R, x, M, y, M, r, x, y, r, x, r, y, add_smul, r, R, s, R, x, M, r, s, x, r, x, s, x, mul_smul, r, R, s, R, x, M, r, s, x, r, s, x, one_smul, x, M, x, x, toSMul_1, SMul, R, M, smul_add_1, r, R, x, M, y, M, r, x, y, r, x, r, y, add_smul_1, r, R, s, R, x, M, r, s, x, r, x, s, x, mul_smul_1, r, R, s, R, x, M, r, s, x, r, s, x, one_smul_1, x, M, x, x, a, toSMul, toSMul_1, h, toSMul_1, toSMul, toSMul_2, SMul, R, M, toSMul, toSMul] (during elaboration)

 : ‚àÄ (Œ± : Type u_1) (Œ≤ : Type u_2) [inst : Preorder Œ±] [inst_1 : Preorder Œ≤] (self : Œ± ‚Üío Œ≤) , Monotone self . 1
function expected at
  Monotone ‚Üëself
term has type
  Prop ; identifiers [Œ±, u_1, Œ≤, u_2, inst, Preorder, Œ±, inst_1, Preorder, Œ≤, self, Œ±, Œ≤, Monotone, self] (during elaboration)

{Œ± : Type u} {œÉ : Type v} (M : ŒµNFA Œ± œÉ) (x : List Œ±)  : ‚àÖ = ‚àÖ
typeclass instance problem is stuck, it is often due to metavariables
  EmptyCollection (?m.393 M x) ; identifiers [Œ±, u, œÉ, v, M, ŒµNFA, Œ±, œÉ, x, List, Œ±] (during elaboration)

{R : Type u_1} {M : Type u_2} [Semiring R] [AddCommGroup M] (toSMul : SMul R M) (smul_add : ‚àÄ (r : R) (x : M) (y : M) , r ‚Ä¢ x + y = r ‚Ä¢ x + r ‚Ä¢ y) (add_smul : ‚àÄ (r : R) (s : R) (x : M) , r + s ‚Ä¢ x = r ‚Ä¢ x + s ‚Ä¢ x) (mul_smul : ‚àÄ (r : R) (s : R) (x : M) , r * s ‚Ä¢ x = r ‚Ä¢ s ‚Ä¢ x) (one_smul : ‚àÄ (x : M) , 1 ‚Ä¢ x = x) (toSMul_1 : SMul R M) (smul_add_1 : ‚àÄ (r : R) (x : M) (y : M) , r ‚Ä¢ x + y = r ‚Ä¢ x + r ‚Ä¢ y) (add_smul_1 : ‚àÄ (r : R) (s : R) (x : M) , r + s ‚Ä¢ x = r ‚Ä¢ x + s ‚Ä¢ x) (mul_smul_1 : ‚àÄ (r : R) (s : R) (x : M) , r * s ‚Ä¢ x = r ‚Ä¢ s ‚Ä¢ x) (one_smul_1 : ‚àÄ (x : M) , 1 ‚Ä¢ x = x) (a : toSMul = toSMul_1) (h : toSMul_1 = toSMul) (smul_add_2 : ‚àÄ (r : R) (x : M) (y : M) , r ‚Ä¢ x + y = r ‚Ä¢ x + r ‚Ä¢ y) (add_smul_2 : ‚àÄ (r : R) (s : R) (x : M) , r + s ‚Ä¢ x = r ‚Ä¢ x + s ‚Ä¢ x) (mul_smul_2 : ‚àÄ (r : R) (s : R) (x : M) , r * s ‚Ä¢ x = r ‚Ä¢ s ‚Ä¢ x) (one_smul_2 : ‚àÄ (x : M) , 1 ‚Ä¢ x = x) (a : toSMul = toSMul) (h : HEq a (Eq.refl toSMul =: toSMul = toSMul))  : {toSMul := ((toSMul)) , smul_add := ((smul_add)) , add_smul := ((add_smul)) , mul_smul := ((mul_smul)) , one_smul := ((one_smul))} = {toSMul := ((toSMul)) , smul_add := ((smul_add)) , add_smul := ((add_smul)) , mul_smul := ((mul_smul)) , one_smul := ((one_smul))}
<input>:1:912: expected term

{R : Type u_1} {M : Type u_2} [Semiring R] [AddCommGroup M] (toSMul : SMul R M) (smul_add : ‚àÄ (r : R) (x : M) (y : M) , r ‚Ä¢ x + y = r ‚Ä¢ x + r ‚Ä¢ y) (add_smul : ‚àÄ (r : R) (s : R) (x : M) , r + s ‚Ä¢ x = r ‚Ä¢ x + s ‚Ä¢ x) (mul_smul : ‚àÄ (r : R) (s : R) (x : M) , r * s ‚Ä¢ x = r ‚Ä¢ s ‚Ä¢ x) (one_smul : ‚àÄ (x : M) , 1 ‚Ä¢ x = x) (toSMul_1 : SMul R M) (smul_add_1 : ‚àÄ (r : R) (x : M) (y : M) , r ‚Ä¢ x + y = r ‚Ä¢ x + r ‚Ä¢ y) (add_smul_1 : ‚àÄ (r : R) (s : R) (x : M) , r + s ‚Ä¢ x = r ‚Ä¢ x + s ‚Ä¢ x) (mul_smul_1 : ‚àÄ (r : R) (s : R) (x : M) , r * s ‚Ä¢ x = r ‚Ä¢ s ‚Ä¢ x) (one_smul_1 : ‚àÄ (x : M) , 1 ‚Ä¢ x = x) (a : toSMul = toSMul_1) (h : toSMul_1 = toSMul)  : toSMul = toSMul_1
failed to synthesize instance
  HAdd R M ?m.161013 ; identifiers [R, u_1, M, u_2, Semiring, R, AddCommGroup, M, toSMul, SMul, R, M, smul_add, r, R, x, M, y, M, r, x, y, r, x, r, y, add_smul, r, R, s, R, x, M, r, s, x, r, x, s, x, mul_smul, r, R, s, R, x, M, r, s, x, r, s, x, one_smul, x, M, x, x, toSMul_1, SMul, R, M, smul_add_1, r, R, x, M, y, M, r, x, y, r, x, r, y, add_smul_1, r, R, s, R, x, M, r, s, x, r, x, s, x, mul_smul_1, r, R, s, R, x, M, r, s, x, r, s, x, one_smul_1, x, M, x, x, a, toSMul, toSMul_1, h, toSMul_1, toSMul, toSMul, toSMul_1] (during elaboration)

{R : Type u_1} {M : Type u_2} [Semiring R] [AddCommGroup M] (toSMul : SMul R M) (smul_add : ‚àÄ (r : R) (x : M) (y : M) , r ‚Ä¢ x + y = r ‚Ä¢ x + r ‚Ä¢ y) (add_smul : ‚àÄ (r : R) (s : R) (x : M) , r + s ‚Ä¢ x = r ‚Ä¢ x + s ‚Ä¢ x) (mul_smul : ‚àÄ (r : R) (s : R) (x : M) , r * s ‚Ä¢ x = r ‚Ä¢ s ‚Ä¢ x) (one_smul : ‚àÄ (x : M) , 1 ‚Ä¢ x = x) (toSMul_1 : SMul R M) (smul_add_1 : ‚àÄ (r : R) (x : M) (y : M) , r ‚Ä¢ x + y = r ‚Ä¢ x + r ‚Ä¢ y) (add_smul_1 : ‚àÄ (r : R) (s : R) (x : M) , r + s ‚Ä¢ x = r ‚Ä¢ x + s ‚Ä¢ x) (mul_smul_1 : ‚àÄ (r : R) (s : R) (x : M) , r * s ‚Ä¢ x = r ‚Ä¢ s ‚Ä¢ x) (one_smul_1 : ‚àÄ (x : M) , 1 ‚Ä¢ x = x) (a : toSMul = toSMul_1)  : toSMul_1 = toSMul_1
failed to synthesize instance
  HAdd R M ?m.161013 ; identifiers [R, u_1, M, u_2, Semiring, R, AddCommGroup, M, toSMul, SMul, R, M, smul_add, r, R, x, M, y, M, r, x, y, r, x, r, y, add_smul, r, R, s, R, x, M, r, s, x, r, x, s, x, mul_smul, r, R, s, R, x, M, r, s, x, r, s, x, one_smul, x, M, x, x, toSMul_1, SMul, R, M, smul_add_1, r, R, x, M, y, M, r, x, y, r, x, r, y, add_smul_1, r, R, s, R, x, M, r, s, x, r, x, s, x, mul_smul_1, r, R, s, R, x, M, r, s, x, r, s, x, one_smul_1, x, M, x, x, a, toSMul, toSMul_1, toSMul_1, toSMul_1] (during elaboration)

(n : ‚Ñï) {a : Fin n + 1} (ha : ¬¨ (IsMin a : Prop)) (b : Fin n + 1)  : (‚ä• < a) = (‚ä• < a)
failed to synthesize instance
  LE (Fin n + 1) ; identifiers [n, a, Fin, n, ha, IsMin, a, b, Fin, n, a, a] (during elaboration)

(n : ‚Ñï) {a : Fin n + 1} (ha : ¬¨ (IsMin a : Prop)) (b : Fin n + 1)  : (¬¨ (a ‚â§ ‚ä•)) = (¬¨ (a ‚â§ ‚ä•))
failed to synthesize instance
  LE (Fin n + 1) ; identifiers [n, a, Fin, n, ha, IsMin, a, b, Fin, n, a, a] (during elaboration)

{Œ± : Type u} {œÉ : Type v} (M : ŒµNFA Œ± œÉ) (x : List Œ±) (x : List Œ±) (a : Œ±) (ih : ŒµNFA.evalFrom M ‚àÖ x = ‚àÖ)  : ‚àÖ = ‚àÖ
typeclass instance problem is stuck, it is often due to metavariables
  EmptyCollection (?m.592 M x‚úù x a ih) ; identifiers [Œ±, u, œÉ, v, M, ŒµNFA, Œ±, œÉ, x, List, Œ±, x, List, Œ±, a, Œ±, ih, ŒµNFA.evalFrom, M, x] (during elaboration)

(n : ‚Ñï) {a : Fin n + 1} (ha : ¬¨ (IsMin a : Prop)) (b : Fin n + 1)  : (¬¨ (a = ‚ä•)) = (¬¨ (a = ‚ä•))
failed to synthesize instance
  LE (Fin n + 1) ; identifiers [n, a, Fin, n, ha, IsMin, a, b, Fin, n, a, a] (during elaboration)

{x : ‚ÑÇ} {y : ‚ÑÇ}  : ((cexp x = cexp y) ‚Üî (cexp x / cexp y = 1)) = ((cexp x = cexp y) ‚Üî (cexp x / cexp y = 1))
ambiguous, possible interpretations 
  cexp x : ‚ÑÇ
  
  cexp x : ‚ÑÇ ; identifiers [x, y, x, y, x, y, x, y, x, y] (during elaboration)

{x : ‚ÑÇ} {y : ‚ÑÇ}  : (cexp x = cexp y) ‚Üî (cexp x = cexp y)
ambiguous, possible interpretations 
  cexp x : ‚ÑÇ
  
  cexp x : ‚ÑÇ ; identifiers [x, y, x, y, x, y] (during elaboration)

{R : Type u} [Semiring R] {p : Polynomial R} (h : Finset.card Polynomial.support p ‚â§ 1)  : p = p
function expected at
  Finset.card ?m.584
term has type
  ‚Ñï ; identifiers [R, u, Semiring, R, p, Polynomial, R, h, Finset.card, Polynomial.support, p, p, p] (during elaboration)

(n : ‚Ñï) {a : Fin n + 1} (ha : ¬¨ (IsMin a : Prop)) (b : Fin n + 1)  : ((b ‚â§ if (a = 0) then 0 else a - 1) ‚Üî (b < a)) = ((b ‚â§ if (a = 0) then 0 else a - 1) ‚Üî (b < a))
failed to synthesize instance
  LE (Fin n + 1) ; identifiers [n, a, Fin, n, ha, IsMin, a, b, Fin, n, b, a, a, b, a, b, a, a, b, a] (during elaboration)

{G : Type u_1} [Group G] {G' : Type u_2} [Group G'] [Group.FG G] [Group.FG G'] (f : G ‚Üí* G') (hf : Function.Surjective ‚Üë f) (S : Finset G) (h : (Finset.card S = Group.rank G : Prop) ‚àß (Subgroup.closure ‚Üë S = ‚ä§ : Prop)) (hS1 : Finset.card S = Group.rank G) (hS2 : Subgroup.closure ‚Üë S = ‚ä§)  : ‚ä§ = ‚ä§
typeclass instance problem is stuck, it is often due to metavariables
  Top (?m.76950 f hf S h hS1 hS2) ; identifiers [G, u_1, Group, G, G', u_2, Group, G', Group.FG, G, Group.FG, G', f, G, G', hf, Function.Surjective, f, S, Finset, G, h, Finset.card, S, Group.rank, G, Subgroup.closure, S, hS1, Finset.card, S, Group.rank, G, hS2, Subgroup.closure, S] (during elaboration)

{Œ± : Type u} {Œ≤ : Type v} [PseudoEMetricSpace Œ±] [PseudoEMetricSpace Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (h : Isometry f) (x : Œ±) (y : Œ±)  : edist f x f y = edist x y
application type mismatch
  edist f x
argument
  x
has type
  Œ± : Type u
but is expected to have type
  Œ± ‚Üí Œ≤ : Type (max u v) ; identifiers [Œ±, u, Œ≤, v, PseudoEMetricSpace, Œ±, PseudoEMetricSpace, Œ≤, f, a, Œ±, Œ≤, h, Isometry, f, x, Œ±, y, Œ±, edist, f, x, f, y, edist, x, y] (during elaboration)

(n : ‚Ñï) {a : Fin n + 1} (ha : ¬¨ (IsMin a : Prop)) (b : Fin n + 1)  : ((b ‚â§ a - 1) ‚Üî (b < a)) = ((b ‚â§ a - 1) ‚Üî (b < a))
failed to synthesize instance
  LE (Fin n + 1) ; identifiers [n, a, Fin, n, ha, IsMin, a, b, Fin, n, b, a, b, a, b, a, b, a] (during elaboration)

{Œ± : Type u} {Œ≤ : Type v} {f : (a : Œ±) ‚Üí Œ≤} {b : Œ≤} {s : Stream' Œ±} (x : b ‚àà Stream'.map f s) (n : ‚Ñï) (h : b = Stream'.nth Stream'.map f s n)  : Stream'.nth Stream'.map f s n = b
application type mismatch
  Stream'.nth ?m.80406 f
argument
  f
has type
  Œ± ‚Üí Œ≤ : Type (max u v)
but is expected to have type
  ‚Ñï : Type ; identifiers [Œ±, u, Œ≤, v, f, a, Œ±, Œ≤, b, Œ≤, s, Stream', Œ±, x, b, Stream'.map, f, s, n, h, b, Stream'.nth, Stream'.map, f, s, n, Stream'.nth, Stream'.map, f, s, n, b] (during elaboration)

 : (‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] {F : CategoryTheory.Functor C D} {G : CategoryTheory.Functor D C} (self : F ‚ä£ G) {X : C} {Y : D} {g : X ‚ü∂ CategoryTheory.Functor.toPrefunctor G . obj Y} , ‚Üë CategoryTheory.Adjunction.homEquiv self X Y . symm g = CategoryTheory.CategoryStruct.comp CategoryTheory.Functor.toPrefunctor F . map g CategoryTheory.NatTrans.app CategoryTheory.Adjunction.counit self Y)
function expected at
  G.toPrefunctor
term has type
  D ‚•§q C ; identifiers [C, u‚ÇÅ, inst, CategoryTheory.Category, C, D, u‚ÇÇ, inst_1, CategoryTheory.Category, D, F, CategoryTheory.Functor, C, D, G, CategoryTheory.Functor, D, C, self, F, G, X, C, Y, D, g, X, CategoryTheory.Functor.toPrefunctor, G, obj, Y, CategoryTheory.Adjunction.homEquiv, self, X, Y, symm, g, CategoryTheory.CategoryStruct.comp, CategoryTheory.Functor.toPrefunctor, F, map, g, CategoryTheory.NatTrans.app, CategoryTheory.Adjunction.counit, self, Y] (during elaboration)

 : ‚àÄ (C : Type u‚ÇÅ) [inst : CategoryTheory.Category C] (D : Type u‚ÇÇ) [inst_1 : CategoryTheory.Category D] (F : CategoryTheory.Functor C D) (G : CategoryTheory.Functor D C) (self : F ‚ä£ G) {X : C} {Y : D} {g : X ‚ü∂ CategoryTheory.Functor.toPrefunctor G . obj Y} , ‚Üë self . 1 X Y . symm g = CategoryTheory.CategoryStruct.comp CategoryTheory.Functor.toPrefunctor F . map g CategoryTheory.NatTrans.app self . 3 Y
function expected at
  G.toPrefunctor
term has type
  D ‚•§q C ; identifiers [C, u‚ÇÅ, inst, CategoryTheory.Category, C, D, u‚ÇÇ, inst_1, CategoryTheory.Category, D, F, CategoryTheory.Functor, C, D, G, CategoryTheory.Functor, D, C, self, F, G, X, C, Y, D, g, X, CategoryTheory.Functor.toPrefunctor, G, obj, Y, self, X, Y, symm, g, CategoryTheory.CategoryStruct.comp, CategoryTheory.Functor.toPrefunctor, F, map, g, CategoryTheory.NatTrans.app, self, Y] (during elaboration)

(n : ‚Ñï) {a : Fin n + 1} (ha : ¬¨ (IsMin a : Prop)) (b : Fin n + 1)  : ((b ‚â§ a - 1) ‚Üî (‚Üë b < ‚Üë a)) = ((b ‚â§ a - 1) ‚Üî (‚Üë b < ‚Üë a))
failed to synthesize instance
  LE (Fin n + 1) ; identifiers [n, a, Fin, n, ha, IsMin, a, b, Fin, n, b, a, b, a, b, a, b, a] (during elaboration)

{R : Type u_2} {A : Type u_1} [CommSemiring R] [StarRing R] [Semiring A] [Algebra R A] [StarRing A] [StarModule R A] {x : A}  : (x ‚àà Set.range ‚Üë algebraMap R A) ‚Üî (x ‚àà Set.range ‚Üë algebraMap R A)
function expected at
  Set.range ?m.82028 R
term has type
  Prop ; identifiers [R, u_2, A, u_1, CommSemiring, R, StarRing, R, Semiring, A, Algebra, R, A, StarRing, A, StarModule, R, A, x, A, x, Set.range, algebraMap, R, A, x, Set.range, algebraMap, R, A] (during elaboration)

(n : ‚Ñï) {a : Fin n + 1} (ha : ¬¨ (IsMin a : Prop)) (b : Fin n + 1)  : ((‚Üë b ‚â§ ‚Üë a - 1) ‚Üî (‚Üë b < ‚Üë a)) = ((‚Üë b ‚â§ ‚Üë a - 1) ‚Üî (‚Üë b < ‚Üë a))
failed to synthesize instance
  LE (Fin n + 1) ; identifiers [n, a, Fin, n, ha, IsMin, a, b, Fin, n, b, a, b, a, b, a, b, a] (during elaboration)

(x : ‚ÑÇ) (z : ‚ÑÇ) (hz : ‚Äñ z ‚Äñ ‚â§ 1) {E : Type} [Norm E] (a : E) (a_1 : E) (e_a : a = a_1)  : ‚Äñ a ‚Äñ = ‚Äñ a ‚Äñ
<input>:1:28: expected term

{G : Type u_1} [Group G] (H : Subgroup G) [Subgroup.IsCommutative H] [Subgroup.FiniteIndex H] {x : ‚Üë Subgroup.leftTransversals ‚Üë H} {y : ‚Üë Subgroup.leftTransversals ‚Üë H} (h : Subgroup.leftTransversals.diff MonoidHom.id {x : G // x ‚àà H} x y = 1)  : (1 ‚Åª¬π = 1) = (1 ‚Åª¬π = 1)
application type mismatch
  Subgroup.leftTransversals.diff ?m.393 { x // x ‚àà H }
argument
  { x // x ‚àà H }
has type
  Type u_1 : Type (u_1 + 1)
but is expected to have type
  ‚Üë(Subgroup.leftTransversals ‚Üë?m.268) : Type ?u.265 ; identifiers [G, u_1, Group, G, H, Subgroup, G, Subgroup.IsCommutative, H, Subgroup.FiniteIndex, H, x, Subgroup.leftTransversals, H, y, Subgroup.leftTransversals, H, h, Subgroup.leftTransversals.diff, MonoidHom.id, x, G, x, H, x, y] (during elaboration)

{G : Type u_1} [Group G] (H : Subgroup G) [Subgroup.IsCommutative H] [Subgroup.FiniteIndex H] {x : ‚Üë Subgroup.leftTransversals ‚Üë H} {y : ‚Üë Subgroup.leftTransversals ‚Üë H} (h : Subgroup.leftTransversals.diff MonoidHom.id {x : G // x ‚àà H} x y = 1)  : 1 = 1
application type mismatch
  Subgroup.leftTransversals.diff ?m.393 { x // x ‚àà H }
argument
  { x // x ‚àà H }
has type
  Type u_1 : Type (u_1 + 1)
but is expected to have type
  ‚Üë(Subgroup.leftTransversals ‚Üë?m.268) : Type ?u.265 ; identifiers [G, u_1, Group, G, H, Subgroup, G, Subgroup.IsCommutative, H, Subgroup.FiniteIndex, H, x, Subgroup.leftTransversals, H, y, Subgroup.leftTransversals, H, h, Subgroup.leftTransversals.diff, MonoidHom.id, x, G, x, H, x, y] (during elaboration)

{Œ± : Type u_1} [LinearOrderedRing Œ±] [FloorRing Œ±] (a : Œ±) (ha : Int.fract a = 0) (h : (eq_or_ne Int.fract a 0 =: (Int.fract a = 0 : Prop) ‚à® (Int.fract a ‚â† 0 : Prop)) = (Or.inl ha =: (Int.fract a = 0 : Prop) ‚à® (Int.fract a ‚â† 0 : Prop)))  : (Or.inl ha) = (eq_or_ne Int.fract a 0)
<input>:1:112: expected term

(n : ‚Ñï) {a : Fin n + 1} (ha : ¬¨ (IsMin a : Prop)) (b : Fin n + 1)  : ((‚Üë b ‚â§ if (a = 0) then n else ‚Üë a - 1) ‚Üî (‚Üë b < ‚Üë a)) = ((‚Üë b ‚â§ if (a = 0) then n else ‚Üë a - 1) ‚Üî (‚Üë b < ‚Üë a))
failed to synthesize instance
  LE (Fin n + 1) ; identifiers [n, a, Fin, n, ha, IsMin, a, b, Fin, n, b, a, n, a, b, a, b, a, n, a, b, a] (during elaboration)

(G : Type u_1) [TopologicalSpace G] [Group G] [TopologicalGroup G] (a : G) (s : Set G) (hs : s ‚àà nhds a) (this : Filter.Tendsto fun (p : G √ó G) ‚Ü¶ Prod.fst p * Prod.snd p nhds (a , 1) nhds a)  : s ‚àà Filter.map fun (p : G √ó G) ‚Ü¶ Prod.fst p * Prod.snd p nhds (a , 1)
function expected at
  p.snd
term has type
  G ; identifiers [G, u_1, TopologicalSpace, G, Group, G, TopologicalGroup, G, a, G, s, Set, G, hs, s, nhds, a, this, Filter.Tendsto, p, G, G, Prod.fst, p, Prod.snd, p, nhds, a, nhds, a, s, Filter.map, p, G, G, Prod.fst, p, Prod.snd, p, nhds, a] (during elaboration)

{Œ± : Type u} [AddGroup Œ±] [LE Œ±] [CovariantClass Œ± Œ± fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1 fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] [CovariantClass Œ± Œ± Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1 fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {b : Œ±} {c : Œ±} (a : Œ±)  : ((a - b ‚â§ a - c) ‚Üî (c ‚â§ b)) = ((a - b ‚â§ a - c) ‚Üî (c ‚â§ b))
function expected at
  x_1
term has type
  Œ± ; identifiers [Œ±, u, AddGroup, Œ±, LE, Œ±, CovariantClass, Œ±, Œ±, x, Œ±, x_1, Œ±, x, x_1, x, Œ±, x_1, Œ±, x, x_1, CovariantClass, Œ±, Œ±, Function.swap, x, Œ±, x_1, Œ±, x, x_1, x, Œ±, x_1, Œ±, x, x_1, b, Œ±, c, Œ±, a, Œ±, a, b, a, c, c, b, a, b, a, c, c, b] (during elaboration)

(n : ‚Ñï) {a : Fin n + 1} (ha : ¬¨ (IsMin a : Prop)) (b : Fin n + 1)  : ((‚Üë b ‚â§ ‚Üë a - 1) ‚Üî (‚Üë b < ‚Üë a)) = ((‚Üë b ‚â§ ‚Üë a - 1) ‚Üî (‚Üë b < ‚Üë a))
failed to synthesize instance
  LE (Fin n + 1) ; identifiers [n, a, Fin, n, ha, IsMin, a, b, Fin, n, b, a, b, a, b, a, b, a] (during elaboration)

(n : ‚Ñï) {a : Fin n + 1} (ha : ¬¨ (IsMin a : Prop)) (b : Fin n + 1)  : ((‚Üë b + 1 ‚â§ ‚Üë a) ‚Üî (‚Üë b < ‚Üë a)) ‚Üî ((‚Üë b < ‚Üë a) ‚Üî (‚Üë b + 1 ‚â§ ‚Üë a))
failed to synthesize instance
  LE (Fin n + 1) ; identifiers [n, a, Fin, n, ha, IsMin, a, b, Fin, n, b, a, b, a, b, a, b, a] (during elaboration)

(n : ‚Ñï) {a : Fin n + 1} (ha : ¬¨ (IsMin a : Prop)) (b : Fin n + 1)  : ((‚Üë b + 1 ‚â§ ‚Üë a) ‚Üî (‚Üë b < ‚Üë a)) = ((‚Üë b + 1 ‚â§ ‚Üë a) ‚Üî (‚Üë b < ‚Üë a))
failed to synthesize instance
  LE (Fin n + 1) ; identifiers [n, a, Fin, n, ha, IsMin, a, b, Fin, n, b, a, b, a, b, a, b, a] (during elaboration)

{Œ± : Type u} [AddGroup Œ±] [LE Œ±] [CovariantClass Œ± Œ± fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1 fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] [CovariantClass Œ± Œ± Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1 fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {b : Œ±} {c : Œ±} (a : Œ±)  : ((a + - b ‚â§ a - c) ‚Üî (c ‚â§ b)) = ((a + - b ‚â§ a - c) ‚Üî (c ‚â§ b))
function expected at
  x_1
term has type
  Œ± ; identifiers [Œ±, u, AddGroup, Œ±, LE, Œ±, CovariantClass, Œ±, Œ±, x, Œ±, x_1, Œ±, x, x_1, x, Œ±, x_1, Œ±, x, x_1, CovariantClass, Œ±, Œ±, Function.swap, x, Œ±, x_1, Œ±, x, x_1, x, Œ±, x_1, Œ±, x, x_1, b, Œ±, c, Œ±, a, Œ±, a, b, a, c, c, b, a, b, a, c, c, b] (during elaboration)

{Œ± : Type u_1} {c : Set Set Œ±} (x : Œ±) (x_1 : Set Œ±)  : (‚àÉ (_h : x_1 ‚àà c) , ¬¨ (x ‚àà x_1)) = ((x_1 ‚àà c) ‚àß (¬¨ (x ‚àà x_1)))
application type mismatch
  Set Set
argument
  Set
has type
  Type ?u.7 ‚Üí Type ?u.7 : Type (?u.7 + 1)
but is expected to have type
  Type ?u.6 : Type (?u.6 + 1) ; identifiers [Œ±, u_1, c, Set, Set, Œ±, x, Œ±, x_1, Set, Œ±, _h, x_1, c, x, x_1, x_1, c, x, x_1] (during elaboration)

{M : Type u_1} [AddMonoid M] {s : Set M} (hs : IsAddSubmonoid s) (x : List M) (x_1 : ‚àÄ (x_1 : M) (a : x_1 ‚àà x) , x_1 ‚àà s) (x : List M) (f : List.below (motive := fun (x : List M) ‚Ü¶ ‚àÄ (x_2 : ‚àÄ (x_2 : M) (a : x_2 ‚àà x) , x_2 ‚àà s) , List.sum x ‚àà s) x) (x_2 : ‚àÄ (x_2 : M) (a : x_2 ‚àà x) , x_2 ‚àà s) (a : M) (l : List M) (h : ‚àÄ (x : M) (a : x ‚àà a :: l) , x ‚àà s) (x : List.below (motive := fun (x : List M) ‚Ü¶ ‚àÄ (x_3 : ‚àÄ (x_3 : M) (a : x_3 ‚àà x) , x_3 ‚àà s) , List.sum x ‚àà s) a :: l) (x : M)  : (x ‚àà a :: l) = ((x = a) ‚à® (x ‚àà l))
application type mismatch
  List.below (motive := fun x => (‚àÄ (x_3 : M), x_3 ‚àà x ‚Üí x_3 ‚àà s) ‚Üí List.sum x ‚àà s) a
argument
  a
has type
  M : Type u_1
but is expected to have type
  List M : Type u_1 ; identifiers [M, u_1, AddMonoid, M, s, Set, M, hs, IsAddSubmonoid, s, x, List, M, x_1, x_1, M, a, x_1, x, x_1, s, x, List, M, f, List.below, motive, x, List, M, x_2, x_2, M, a, x_2, x, x_2, s, List.sum, x, s, x, x_2, x_2, M, a, x_2, x, x_2, s, a, M, l, List, M, h, x, M, a, x, a, l, x, s, x, List.below, motive, x, List, M, x_3, x_3, M, a, x_3, x, x_3, s, List.sum, x, s, a, l, x, M, x, a, l, x, a, x, l] (during elaboration)

{M : Type u_1} [AddMonoid M] {s : Set M} (hs : IsAddSubmonoid s) (x : List M) (x_1 : ‚àÄ (x_1 : M) (a : x_1 ‚àà x) , x_1 ‚àà s) (x : List M) (f : List.below (motive := fun (x : List M) ‚Ü¶ ‚àÄ (x_2 : ‚àÄ (x_2 : M) (a : x_2 ‚àà x) , x_2 ‚àà s) , List.sum x ‚àà s) x) (x_2 : ‚àÄ (x_2 : M) (a : x_2 ‚àà x) , x_2 ‚àà s) (a : M) (l : List M) (h : ‚àÄ (x : M) (a : x ‚àà a :: l) , x ‚àà s) (x : List.below (motive := fun (x : List M) ‚Ü¶ ‚àÄ (x_3 : ‚àÄ (x_3 : M) (a : x_3 ‚àà x) , x_3 ‚àà s) , List.sum x ‚àà s) a :: l) (x : M)  : (x ‚àà s) = (x ‚àà s)
application type mismatch
  List.below (motive := fun x => (‚àÄ (x_3 : M), x_3 ‚àà x ‚Üí x_3 ‚àà s) ‚Üí List.sum x ‚àà s) a
argument
  a
has type
  M : Type u_1
but is expected to have type
  List M : Type u_1 ; identifiers [M, u_1, AddMonoid, M, s, Set, M, hs, IsAddSubmonoid, s, x, List, M, x_1, x_1, M, a, x_1, x, x_1, s, x, List, M, f, List.below, motive, x, List, M, x_2, x_2, M, a, x_2, x, x_2, s, List.sum, x, s, x, x_2, x_2, M, a, x_2, x, x_2, s, a, M, l, List, M, h, x, M, a, x, a, l, x, s, x, List.below, motive, x, List, M, x_3, x_3, M, a, x_3, x, x_3, s, List.sum, x, s, a, l, x, M, x, s, x, s] (during elaboration)

{M : Type u_1} [AddMonoid M] {s : Set M} (hs : IsAddSubmonoid s) (x : List M) (x_1 : ‚àÄ (x_1 : M) (a : x_1 ‚àà x) , x_1 ‚àà s) (x : List M) (f : List.below (motive := fun (x : List M) ‚Ü¶ ‚àÄ (x_2 : ‚àÄ (x_2 : M) (a : x_2 ‚àà x) , x_2 ‚àà s) , List.sum x ‚àà s) x) (x_2 : ‚àÄ (x_2 : M) (a : x_2 ‚àà x) , x_2 ‚àà s) (a : M) (l : List M) (h : ‚àÄ (x : M) (a : x ‚àà a :: l) , x ‚àà s) (x : List.below (motive := fun (x : List M) ‚Ü¶ ‚àÄ (x_3 : ‚àÄ (x_3 : M) (a : x_3 ‚àà x) , x_3 ‚àà s) , List.sum x ‚àà s) a :: l)  : (‚àÄ (a_1 : M) (a : (a_1 = a) ‚à® (a_1 ‚àà l)) , a_1 ‚àà s) = ((a ‚àà s) ‚àß (‚àÄ (a : M) (a_1 : a ‚àà l) , a ‚àà s))
application type mismatch
  List.below (motive := fun x => (‚àÄ (x_3 : M), x_3 ‚àà x ‚Üí x_3 ‚àà s) ‚Üí List.sum x ‚àà s) a
argument
  a
has type
  M : Type u_1
but is expected to have type
  List M : Type u_1 ; identifiers [M, u_1, AddMonoid, M, s, Set, M, hs, IsAddSubmonoid, s, x, List, M, x_1, x_1, M, a, x_1, x, x_1, s, x, List, M, f, List.below, motive, x, List, M, x_2, x_2, M, a, x_2, x, x_2, s, List.sum, x, s, x, x_2, x_2, M, a, x_2, x, x_2, s, a, M, l, List, M, h, x, M, a, x, a, l, x, s, x, List.below, motive, x, List, M, x_3, x_3, M, a, x_3, x, x_3, s, List.sum, x, s, a, l, a_1, M, a, a_1, a, a_1, l, a_1, s, a, s, a, M, a_1, a, l, a, s] (during elaboration)

{Œ± : Type u} [AddGroup Œ±] [LE Œ±] [CovariantClass Œ± Œ± fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1 fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] [CovariantClass Œ± Œ± Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1 fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {b : Œ±} {c : Œ±} (a : Œ±)  : ((a + - b ‚â§ a + - c) ‚Üî (c ‚â§ b)) = ((a + - b ‚â§ a + - c) ‚Üî (c ‚â§ b))
function expected at
  x_1
term has type
  Œ± ; identifiers [Œ±, u, AddGroup, Œ±, LE, Œ±, CovariantClass, Œ±, Œ±, x, Œ±, x_1, Œ±, x, x_1, x, Œ±, x_1, Œ±, x, x_1, CovariantClass, Œ±, Œ±, Function.swap, x, Œ±, x_1, Œ±, x, x_1, x, Œ±, x_1, Œ±, x, x_1, b, Œ±, c, Œ±, a, Œ±, a, b, a, c, c, b, a, b, a, c, c, b] (during elaboration)

{Œ± : Type u} [AddGroup Œ±] [LE Œ±] [CovariantClass Œ± Œ± fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1 fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] [CovariantClass Œ± Œ± Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1 fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {b : Œ±} {c : Œ±} (a : Œ±)  : ((- a + a + - b ‚â§ - a + a + - c) ‚Üî (c ‚â§ b)) = ((- a + a + - b ‚â§ - a + a + - c) ‚Üî (c ‚â§ b))
function expected at
  x_1
term has type
  Œ± ; identifiers [Œ±, u, AddGroup, Œ±, LE, Œ±, CovariantClass, Œ±, Œ±, x, Œ±, x_1, Œ±, x, x_1, x, Œ±, x_1, Œ±, x, x_1, CovariantClass, Œ±, Œ±, Function.swap, x, Œ±, x_1, Œ±, x, x_1, x, Œ±, x_1, Œ±, x, x_1, b, Œ±, c, Œ±, a, Œ±, a, a, b, a, a, c, c, b, a, a, b, a, a, c, c, b] (during elaboration)

{G : Type u_1} [Group G] (H : Subgroup G) [Subgroup.IsCommutative H] [Subgroup.FiniteIndex H] {x : ‚Üë Subgroup.leftTransversals ‚Üë H} {y : ‚Üë Subgroup.leftTransversals ‚Üë H} {z : ‚Üë Subgroup.leftTransversals ‚Üë H} (h : Subgroup.leftTransversals.diff MonoidHom.id {x : G // x ‚àà H} x y = 1) (h' : Subgroup.leftTransversals.diff MonoidHom.id {x : G // x ‚àà H} y z = 1)  : (1 * 1 = 1) = (1 * 1 = 1)
application type mismatch
  Subgroup.leftTransversals.diff ?m.400 { x // x ‚àà H }
argument
  { x // x ‚àà H }
has type
  Type u_1 : Type (u_1 + 1)
but is expected to have type
  ‚Üë(Subgroup.leftTransversals ‚Üë?m.275) : Type ?u.272 ; identifiers [G, u_1, Group, G, H, Subgroup, G, Subgroup.IsCommutative, H, Subgroup.FiniteIndex, H, x, Subgroup.leftTransversals, H, y, Subgroup.leftTransversals, H, z, Subgroup.leftTransversals, H, h, Subgroup.leftTransversals.diff, MonoidHom.id, x, G, x, H, x, y, h', Subgroup.leftTransversals.diff, MonoidHom.id, x, G, x, H, y, z] (during elaboration)

{G : Type u_1} [Group G] (H : Subgroup G) [Subgroup.IsCommutative H] [Subgroup.FiniteIndex H] {x : ‚Üë Subgroup.leftTransversals ‚Üë H} {y : ‚Üë Subgroup.leftTransversals ‚Üë H} {z : ‚Üë Subgroup.leftTransversals ‚Üë H} (h : Subgroup.leftTransversals.diff MonoidHom.id {x : G // x ‚àà H} x y = 1) (h' : Subgroup.leftTransversals.diff MonoidHom.id {x : G // x ‚àà H} y z = 1)  : 1 = 1
application type mismatch
  Subgroup.leftTransversals.diff ?m.400 { x // x ‚àà H }
argument
  { x // x ‚àà H }
has type
  Type u_1 : Type (u_1 + 1)
but is expected to have type
  ‚Üë(Subgroup.leftTransversals ‚Üë?m.275) : Type ?u.272 ; identifiers [G, u_1, Group, G, H, Subgroup, G, Subgroup.IsCommutative, H, Subgroup.FiniteIndex, H, x, Subgroup.leftTransversals, H, y, Subgroup.leftTransversals, H, z, Subgroup.leftTransversals, H, h, Subgroup.leftTransversals.diff, MonoidHom.id, x, G, x, H, x, y, h', Subgroup.leftTransversals.diff, MonoidHom.id, x, G, x, H, y, z] (during elaboration)

{Œ± : Type u_1} {p : (a : Finset Œ±) ‚Üí Prop} (empty : p ‚àÖ) (cons : ‚àÄ ‚¶É a : Œ± ‚¶Ñ {s : Finset Œ±} (h : ¬¨ (a ‚àà s : Prop)) (a_1 : p s) , p Finset.cons a s h) (x : Finset Œ±) (s : Multiset Œ±) (nd : Multiset.Nodup s)  : ‚àÄ (nd : Multiset.Nodup 0) , p ‚àÖ
application type mismatch
  p Finset.cons
argument
  Finset.cons
has type
  (a : ?m.105) ‚Üí (s : Finset ?m.105) ‚Üí ¬¨a ‚àà s ‚Üí Finset ?m.105 : Type ?u.104
but is expected to have type
  Finset Œ± : Type u_1 ; identifiers [Œ±, u_1, p, a, Finset, Œ±, empty, p, cons, a, Œ±, s, Finset, Œ±, h, a, s, a_1, p, s, p, Finset.cons, a, s, h, x, Finset, Œ±, s, Multiset, Œ±, nd, Multiset.Nodup, s, nd, Multiset.Nodup, p] (during elaboration)

{Œ± : Type u} [AddGroup Œ±] [LE Œ±] [CovariantClass Œ± Œ± fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1 fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] [CovariantClass Œ± Œ± Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1 fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {b : Œ±} {c : Œ±} (a : Œ±)  : ((- b ‚â§ - a + a + - c) ‚Üî (c ‚â§ b)) = ((- b ‚â§ - a + a + - c) ‚Üî (c ‚â§ b))
function expected at
  x_1
term has type
  Œ± ; identifiers [Œ±, u, AddGroup, Œ±, LE, Œ±, CovariantClass, Œ±, Œ±, x, Œ±, x_1, Œ±, x, x_1, x, Œ±, x_1, Œ±, x, x_1, CovariantClass, Œ±, Œ±, Function.swap, x, Œ±, x_1, Œ±, x, x_1, x, Œ±, x_1, Œ±, x, x_1, b, Œ±, c, Œ±, a, Œ±, b, a, a, c, c, b, b, a, a, c, c, b] (during elaboration)

{Œ± : Type u} [AddGroup Œ±] [LE Œ±] [CovariantClass Œ± Œ± fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1 fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] [CovariantClass Œ± Œ± Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1 fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {b : Œ±} {c : Œ±} (a : Œ±)  : ((- b ‚â§ - c) ‚Üî (c ‚â§ b)) = ((- b ‚â§ - c) ‚Üî (c ‚â§ b))
function expected at
  x_1
term has type
  Œ± ; identifiers [Œ±, u, AddGroup, Œ±, LE, Œ±, CovariantClass, Œ±, Œ±, x, Œ±, x_1, Œ±, x, x_1, x, Œ±, x_1, Œ±, x, x_1, CovariantClass, Œ±, Œ±, Function.swap, x, Œ±, x_1, Œ±, x, x_1, x, Œ±, x_1, Œ±, x, x_1, b, Œ±, c, Œ±, a, Œ±, b, c, c, b, b, c, c, b] (during elaboration)

{Œ± : Type u} [AddGroup Œ±] [LE Œ±] [CovariantClass Œ± Œ± fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1 fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] [CovariantClass Œ± Œ± Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1 fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {b : Œ±} {c : Œ±} (a : Œ±)  : (c ‚â§ b) ‚Üî (c ‚â§ b)
function expected at
  x_1
term has type
  Œ± ; identifiers [Œ±, u, AddGroup, Œ±, LE, Œ±, CovariantClass, Œ±, Œ±, x, Œ±, x_1, Œ±, x, x_1, x, Œ±, x_1, Œ±, x, x_1, CovariantClass, Œ±, Œ±, Function.swap, x, Œ±, x_1, Œ±, x, x_1, x, Œ±, x_1, Œ±, x, x_1, b, Œ±, c, Œ±, a, Œ±, c, b, c, b] (during elaboration)

{Œ± : Type u_1} [LinearOrderedRing Œ±] [FloorRing Œ±] (a : Œ±) (ha : Int.fract a ‚â† 0) (h : (eq_or_ne Int.fract a 0 =: (Int.fract a = 0 : Prop) ‚à® (Int.fract a ‚â† 0 : Prop)) = (Or.inr ha =: (Int.fract a = 0 : Prop) ‚à® (Int.fract a ‚â† 0 : Prop)))  : (Or.inr ha) = (eq_or_ne Int.fract a 0)
<input>:1:112: expected term

{Œ± : Type u_2} {m : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {M : Type u_3} [AddCommMonoid M] [TopologicalSpace M] [ContinuousAdd M] {Œπ : Type u_1} {f : (a : Œπ) ‚Üí (a : Œ±) ‚Üí M} (s : Finset Œπ) (hf : ‚àÄ (i : Œπ) (a : i ‚àà s) , MeasureTheory.AEStronglyMeasurable f i Œº) (_g : (a : Œ±) ‚Üí M) (hg : _g ‚àà Multiset.map fun (i : Œπ) ‚Ü¶ f i Finset.val s) (_i : Œπ) (hi : _i ‚àà Finset.val s) (hg : f _i = _g)  : MeasureTheory.AEStronglyMeasurable f _i Œº
function expected at
  MeasureTheory.AEStronglyMeasurable f ?m.80064
term has type
  Prop ; identifiers [Œ±, u_2, m, MeasurableSpace, Œ±, Œº, MeasureTheory.Measure, Œ±, M, u_3, AddCommMonoid, M, TopologicalSpace, M, ContinuousAdd, M, Œπ, u_1, f, a, Œπ, a, Œ±, M, s, Finset, Œπ, hf, i, Œπ, a, i, s, MeasureTheory.AEStronglyMeasurable, f, i, Œº, _g, a, Œ±, M, hg, _g, Multiset.map, i, Œπ, f, i, Finset.val, s, _i, Œπ, hi, _i, Finset.val, s, hg, f, _i, _g, MeasureTheory.AEStronglyMeasurable, f, _i, Œº] (during elaboration)

{x : ‚Ñù} (hx : | x | ‚â§ 1)  : 5 = 5
<input>:1:14: expected ')' or no space before

{x : ‚Ñù} (hx : | x | ‚â§ 1)  : 96 = 96
<input>:1:14: expected ')' or no space before

{f : (a : Ordinal .{u}) ‚Üí Ordinal .{max u v}} (h : ‚àÄ (a : Ordinal .{u}) , f a < f Order.succ a) (H : ‚àÄ (o : Ordinal .{u}) (a : Ordinal.IsLimit o) , Ordinal.bsup o fun (x : Ordinal .{u}) (x_1 : x < o) ‚Ü¶ f x = f o) (o : Ordinal .{u}) (ho : Ordinal.IsLimit o) (this : Ordinal.bsup o fun (x : Ordinal .{u}) (x_1 : x < o) ‚Ü¶ f x = f o)  : ‚àÄ (a : Ordinal .{u}) (x : a < o) , f a < f Order.succ a
<input>:1:18: expected ')'

{f : (a : Ordinal .{u}) ‚Üí Ordinal .{max u v}} (h : ‚àÄ (a : Ordinal .{u}) , f a < f Order.succ a) (H : ‚àÄ (o : Ordinal .{u}) (a : Ordinal.IsLimit o) , Ordinal.bsup o fun (x : Ordinal .{u}) (x_1 : x < o) ‚Ü¶ f x = f o) (o : Ordinal .{u}) (ho : Ordinal.IsLimit o)  : Ordinal.bsup o fun (x : Ordinal .{u}) (x_1 : x < o) ‚Ü¶ f x = f o
<input>:1:18: expected ')'

{C : Type u_1} [inst : CategoryTheory.Category C] {X : CategoryTheory.SimplicialObject.Augmented C} (self : SimplicialObject.Augmented.ExtraDegeneracy X) (n : ‚Ñï) (i : Fin n + 2)  : ‚àÄ (C : Type u_1) [inst : CategoryTheory.Category C] (X : CategoryTheory.SimplicialObject.Augmented C) (self : SimplicialObject.Augmented.ExtraDegeneracy X) (n : ‚Ñï) (i : Fin n + 2) , CategoryTheory.CategoryStruct.comp self . 2 n + 1 CategoryTheory.SimplicialObject.Œ¥ CategoryTheory.Comma.left X Fin.succ i = CategoryTheory.CategoryStruct.comp CategoryTheory.SimplicialObject.Œ¥ CategoryTheory.Comma.left X i self . 2 n
invalid occurrence of `¬∑` notation, it must be surrounded by parentheses (e.g. `(¬∑ + 1)`) ; identifiers [C, u_1, inst, CategoryTheory.Category, C, X, CategoryTheory.SimplicialObject.Augmented, C, self, SimplicialObject.Augmented.ExtraDegeneracy, X, n, i, Fin, n, C, u_1, inst, CategoryTheory.Category, C, X, CategoryTheory.SimplicialObject.Augmented, C, self, SimplicialObject.Augmented.ExtraDegeneracy, X, n, i, Fin, n, CategoryTheory.CategoryStruct.comp, self, n, CategoryTheory.SimplicialObject.Œ¥, CategoryTheory.Comma.left, X, Fin.succ, i, CategoryTheory.CategoryStruct.comp, CategoryTheory.SimplicialObject.Œ¥, CategoryTheory.Comma.left, X, i, self, n] (during elaboration)

{x : ‚Ñù} (hx : | x | ‚â§ 1)  : 2 = 2
<input>:1:14: expected ')' or no space before

(x : ‚ÑÇ) (z : ‚ÑÇ) (hz : ‚Äñ z ‚Äñ ‚â§ 1)  : - 0 = 0
<input>:1:28: expected term

{x : ‚Ñù} (hx : | x | ‚â§ 1)  : (x ^ 2 ‚â§ 1) = (x ^ 2 ‚â§ 1)
<input>:1:14: expected ')' or no space before

{Œ± : Type u_1} {m : MeasurableSpace Œ±} {f : (a : Œ±) ‚Üí Œ±} {Œº : MeasureTheory.Measure Œ±} {Œ≤ : Type u_2} {m' : MeasurableSpace Œ≤} {Œº' : MeasureTheory.Measure Œ≤} {e : Œ± ‚âÉ·µê Œ≤} (h : MeasureTheory.MeasurePreserving ‚Üë e)  : (MeasureTheory.MeasurePreserving f) ‚Üî (MeasureTheory.MeasurePreserving f)
typeclass instance problem is stuck, it is often due to metavariables
  MeasureTheory.MeasureSpace ?m.68252 ; identifiers [Œ±, u_1, m, MeasurableSpace, Œ±, f, a, Œ±, Œ±, Œº, MeasureTheory.Measure, Œ±, Œ≤, u_2, m', MeasurableSpace, Œ≤, Œº', MeasureTheory.Measure, Œ≤, e, Œ±, Œ≤, h, MeasureTheory.MeasurePreserving, e, MeasureTheory.MeasurePreserving, f, MeasureTheory.MeasurePreserving, f] (during elaboration)

{R : Type u_2} {A : Type u_1} [CommSemiring R] [StarRing R] [Semiring A] [Algebra R A] [StarRing A] [StarModule R A] {S : Set StarSubalgebra R A} {x : A} (p : StarSubalgebra R A)  : (p ‚àà S) = (p ‚àà S)
application type mismatch
  Set StarSubalgebra
argument
  StarSubalgebra
has type
  (R : Type ?u.1309) ‚Üí
    (A : Type ?u.1308) ‚Üí
      [inst : CommSemiring R] ‚Üí
        [inst_1 : StarRing R] ‚Üí
          [inst_2 : Semiring A] ‚Üí
            [inst_3 : StarRing A] ‚Üí
              [inst_4 : Algebra R A] ‚Üí [inst : StarModule R A] ‚Üí Type ?u.1308 : Type (max (?u.1308 + 1) (?u.1309 + 1))
but is expected to have type
  Type ?u.1307 : Type (?u.1307 + 1) ; identifiers [R, u_2, A, u_1, CommSemiring, R, StarRing, R, Semiring, A, Algebra, R, A, StarRing, A, StarModule, R, A, S, Set, StarSubalgebra, R, A, x, A, p, StarSubalgebra, R, A, p, S, p, S] (during elaboration)

{x : ‚Ñù} (hx : | x | ‚â§ 1)  : (x * x ‚â§ 1) = (x * x ‚â§ 1)
<input>:1:14: expected ')' or no space before

{Œ± : Type u_1} {Œ≤ : Type u_3} {Œ≥ : Type u_2} {s : Set Œ±} {t : Set Œ≤} {f‚ÇÅ : (a : Œ±) ‚Üí Œ≤} {f‚ÇÇ : (a : Œ±) ‚Üí Œ≤} {g : (a : Œ≤) ‚Üí Œ≥} (h : Set.EqOn g ‚àò f‚ÇÅ g ‚àò f‚ÇÇ s) (hg : Set.InjOn g t) (hf‚ÇÅ : Set.MapsTo f‚ÇÅ s t) (hf‚ÇÇ : Set.MapsTo f‚ÇÇ s t) (x : Œ±) (ha : x ‚àà s)  : f‚ÇÅ x ‚àà t
application type mismatch
  f‚ÇÅ g
argument
  g
has type
  Œ≤ ‚Üí Œ≥ : Type (max u_2 u_3)
but is expected to have type
  Œ± : Type u_1 ; identifiers [Œ±, u_1, Œ≤, u_3, Œ≥, u_2, s, Set, Œ±, t, Set, Œ≤, f‚ÇÅ, a, Œ±, Œ≤, f‚ÇÇ, a, Œ±, Œ≤, g, a, Œ≤, Œ≥, h, Set.EqOn, g, f‚ÇÅ, g, f‚ÇÇ, s, hg, Set.InjOn, g, t, hf‚ÇÅ, Set.MapsTo, f‚ÇÅ, s, t, hf‚ÇÇ, Set.MapsTo, f‚ÇÇ, s, t, x, Œ±, ha, x, s, f‚ÇÅ, x, t] (during elaboration)

{Œ± : Type u_1} {Œ≤ : Type u_3} {Œ≥ : Type u_2} {s : Set Œ±} {t : Set Œ≤} {f‚ÇÅ : (a : Œ±) ‚Üí Œ≤} {f‚ÇÇ : (a : Œ±) ‚Üí Œ≤} {g : (a : Œ≤) ‚Üí Œ≥} (h : Set.EqOn g ‚àò f‚ÇÅ g ‚àò f‚ÇÇ s) (hg : Set.InjOn g t) (hf‚ÇÅ : Set.MapsTo f‚ÇÅ s t) (hf‚ÇÇ : Set.MapsTo f‚ÇÇ s t) (x : Œ±) (ha : x ‚àà s)  : f‚ÇÇ x ‚àà t
application type mismatch
  f‚ÇÅ g
argument
  g
has type
  Œ≤ ‚Üí Œ≥ : Type (max u_2 u_3)
but is expected to have type
  Œ± : Type u_1 ; identifiers [Œ±, u_1, Œ≤, u_3, Œ≥, u_2, s, Set, Œ±, t, Set, Œ≤, f‚ÇÅ, a, Œ±, Œ≤, f‚ÇÇ, a, Œ±, Œ≤, g, a, Œ≤, Œ≥, h, Set.EqOn, g, f‚ÇÅ, g, f‚ÇÇ, s, hg, Set.InjOn, g, t, hf‚ÇÅ, Set.MapsTo, f‚ÇÅ, s, t, hf‚ÇÇ, Set.MapsTo, f‚ÇÇ, s, t, x, Œ±, ha, x, s, f‚ÇÇ, x, t] (during elaboration)

{x : ‚Ñù} (hx : | x | ‚â§ 1)  : (| x * x | ‚â§ 1) = (| x * x | ‚â§ 1)
<input>:1:14: expected ')' or no space before

{Œ± : Type u_1} {Œ≤ : Type u_3} {Œ≥ : Type u_2} {s : Set Œ±} {t : Set Œ≤} {f‚ÇÅ : (a : Œ±) ‚Üí Œ≤} {f‚ÇÇ : (a : Œ±) ‚Üí Œ≤} {g : (a : Œ≤) ‚Üí Œ≥} (h : Set.EqOn g ‚àò f‚ÇÅ g ‚àò f‚ÇÇ s) (hg : Set.InjOn g t) (hf‚ÇÅ : Set.MapsTo f‚ÇÅ s t) (hf‚ÇÇ : Set.MapsTo f‚ÇÇ s t) (x : Œ±) (ha : x ‚àà s)  : g ‚àò f‚ÇÅ x = g ‚àò f‚ÇÇ x
application type mismatch
  f‚ÇÅ g
argument
  g
has type
  Œ≤ ‚Üí Œ≥ : Type (max u_2 u_3)
but is expected to have type
  Œ± : Type u_1 ; identifiers [Œ±, u_1, Œ≤, u_3, Œ≥, u_2, s, Set, Œ±, t, Set, Œ≤, f‚ÇÅ, a, Œ±, Œ≤, f‚ÇÇ, a, Œ±, Œ≤, g, a, Œ≤, Œ≥, h, Set.EqOn, g, f‚ÇÅ, g, f‚ÇÇ, s, hg, Set.InjOn, g, t, hf‚ÇÅ, Set.MapsTo, f‚ÇÅ, s, t, hf‚ÇÇ, Set.MapsTo, f‚ÇÇ, s, t, x, Œ±, ha, x, s, g, f‚ÇÅ, x, g, f‚ÇÇ, x] (during elaboration)

(x : ‚ÑÇ) (z : ‚ÑÇ) (hz : ‚Äñ z ‚Äñ ‚â§ 1)  : z = z ^ Nat.rawCast 1 * Nat.rawCast 1 + 0
<input>:1:28: expected term

{f : (a : Ordinal .{u}) ‚Üí Ordinal .{max u v}} (h : ‚àÄ (a : Ordinal .{u}) , f a < f Order.succ a) (H : ‚àÄ (o : Ordinal .{u}) (a : Ordinal.IsLimit o) , Ordinal.blsub o fun (x : Ordinal .{u}) (x_1 : x < o) ‚Ü¶ f x = f o) (o : Ordinal .{u}) (ho : Ordinal.IsLimit o) (this : Ordinal.blsub o fun (x : Ordinal .{u}) (x_1 : x < o) ‚Ü¶ f x = f o)  : ‚àÄ (a : Ordinal .{u}) (x : a < o) , f a < f Order.succ a
<input>:1:18: expected ')'

{f : (a : Ordinal .{u}) ‚Üí Ordinal .{max u v}} (h : ‚àÄ (a : Ordinal .{u}) , f a < f Order.succ a) (H : ‚àÄ (o : Ordinal .{u}) (a : Ordinal.IsLimit o) , Ordinal.blsub o fun (x : Ordinal .{u}) (x_1 : x < o) ‚Ü¶ f x = f o) (o : Ordinal .{u}) (ho : Ordinal.IsLimit o)  : Ordinal.blsub o fun (x : Ordinal .{u}) (x_1 : x < o) ‚Ü¶ f x = f o
<input>:1:18: expected ')'

{Œ± : Type u_1} {p : (a : Finset Œ±) ‚Üí Prop} (empty : p ‚àÖ) (cons : ‚àÄ ‚¶É a : Œ± ‚¶Ñ {s : Finset Œ±} (h : ¬¨ (a ‚àà s : Prop)) (a_1 : p s) , p Finset.cons a s h) (x : Finset Œ±) (s : Multiset Œ±) (nd : Multiset.Nodup s) ‚¶É a : Œ± ‚¶Ñ {s : Multiset Œ±} (IH : ‚àÄ (nd : Multiset.Nodup s) , p {val := ((s)) , nodup := ((nd))}) (nd : Multiset.Nodup a ::‚Çò s) (m : ¬¨ (a ‚àà s : Prop)) (nd' : Multiset.Nodup s) (h : (Iff.mp (Multiset.nodup_cons =: (Multiset.Nodup a ::‚Çò s : Prop) ‚Üî ((¬¨ (a ‚àà s : Prop) : Prop) ‚àß (Multiset.Nodup s : Prop) : Prop)) nd =: (¬¨ (a ‚àà s : Prop) : Prop) ‚àß (Multiset.Nodup s : Prop)) = ({left := ((m)) , right := ((nd'))} =: (¬¨ (a ‚àà s : Prop) : Prop) ‚àß (Multiset.Nodup s : Prop)))  : ({left := ((m)) , right := ((nd'))}) = (Iff.mp Multiset.nodup_cons nd)
<input>:1:416: expected term

{o : Ordinal .{u}} (ho : Ordinal.IsLimit o) {f : (a : Ordinal .{u}) ‚Üí (a : a < o) ‚Üí Ordinal .{max u v}} (hf : ‚àÄ (a : Ordinal .{u}) (ha : a < o) , f a ha < f Order.succ a (And.right ho a ha =: Order.succ a < o)) (i : Ordinal .{u}) (hi : i < o)  : f i hi < f Order.succ i (And.right ho i hi)
<input>:1:13: expected '//', '|' or '}'

{Œ± : Type u} (l : List Œ±) (n : ‚Ñï) (n : ‚Ñï) (hn : ‚àÄ (l : List Œ±) , List.rotate List.reverse List.rotate l n n = List.reverse l) (l : List Œ±) (h : l = [])  : [] = l
application type mismatch
  List.rotate ?m.79590 List.rotate
argument
  List.rotate
has type
  List ?m.79592 ‚Üí ‚Ñï ‚Üí List ?m.79592 : Type ?u.79591
but is expected to have type
  ‚Ñï : Type ; identifiers [Œ±, u, l, List, Œ±, n, n, hn, l, List, Œ±, List.rotate, List.reverse, List.rotate, l, n, n, List.reverse, l, l, List, Œ±, h, l, l] (during elaboration)

{x : ‚Ñù} (hx : | x | ‚â§ 1)  : 192 = 192
<input>:1:14: expected ')' or no space before

{V : Type u} {G : SimpleGraph V} {u : V} {v : V} (p : SimpleGraph.Walk G u v) {u_1 : V} {v_1 : V} {w : V} (h : SimpleGraph.Adj G u_1 v_1) (p_1 : SimpleGraph.Walk G v_1 w) (h_1 : u = u_1) (h : SimpleGraph.Adj G u v_1) (h_2 : v = w) (p_2 : SimpleGraph.Walk G v_1 v) (h_3 : HEq p SimpleGraph.Walk.cons h p_2)  : (u ‚àà u :: SimpleGraph.Walk.support p_2) = ((u = u) ‚à® (u ‚àà SimpleGraph.Walk.support p_2))
function expected at
  HEq p SimpleGraph.Walk.cons
term has type
  Prop ; identifiers [V, u, G, SimpleGraph, V, u, V, v, V, p, SimpleGraph.Walk, G, u, v, u_1, V, v_1, V, w, V, h, SimpleGraph.Adj, G, u_1, v_1, p_1, SimpleGraph.Walk, G, v_1, w, h_1, u, u_1, h, SimpleGraph.Adj, G, u, v_1, h_2, v, w, p_2, SimpleGraph.Walk, G, v_1, v, h_3, HEq, p, SimpleGraph.Walk.cons, h, p_2, u, u, SimpleGraph.Walk.support, p_2, u, u, u, SimpleGraph.Walk.support, p_2] (during elaboration)

 : (‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.MonoidalCategory C] {A : Mon_ C} (self : Mod_ A) , CategoryTheory.CategoryStruct.comp CategoryTheory.MonoidalCategory.tensorHom Mon_.one A CategoryTheory.CategoryStruct.id Mod_.X self Mod_.act self = CategoryTheory.MonoidalCategory.leftUnitor Mod_.X self . hom)
function expected at
  CategoryTheory.CategoryStruct.comp ?m.81502 ?m.162085
term has type
  ?m.486 ‚ü∂ ?m.488 ; identifiers [C, u‚ÇÅ, inst, CategoryTheory.Category, C, inst_1, CategoryTheory.MonoidalCategory, C, A, Mon_, C, self, Mod_, A, CategoryTheory.CategoryStruct.comp, CategoryTheory.MonoidalCategory.tensorHom, Mon_.one, A, CategoryTheory.CategoryStruct.id, Mod_.X, self, Mod_.act, self, CategoryTheory.MonoidalCategory.leftUnitor, Mod_.X, self, hom] (during elaboration)

 : ‚àÄ (C : Type u‚ÇÅ) [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.MonoidalCategory C] (A : Mon_ C) (self : Mod_ A) , CategoryTheory.CategoryStruct.comp CategoryTheory.MonoidalCategory.tensorHom Mon_.one A CategoryTheory.CategoryStruct.id self . 1 self . 2 = CategoryTheory.MonoidalCategory.leftUnitor self . 1 . hom
function expected at
  CategoryTheory.CategoryStruct.comp ?m.81499 ?m.162082
term has type
  ?m.483 ‚ü∂ ?m.485 ; identifiers [C, u‚ÇÅ, inst, CategoryTheory.Category, C, inst_1, CategoryTheory.MonoidalCategory, C, A, Mon_, C, self, Mod_, A, CategoryTheory.CategoryStruct.comp, CategoryTheory.MonoidalCategory.tensorHom, Mon_.one, A, CategoryTheory.CategoryStruct.id, self, self, CategoryTheory.MonoidalCategory.leftUnitor, self, hom] (during elaboration)

{M : Type u_1} {s : Set M} [Mul M] (h : s ‚äÜ Set.center M) (x : M) (x_1 : x ‚àà ‚ä§) (x_2 : M) (hm : x_2 ‚àà s)  : x * x_2 = x_2 * x
typeclass instance problem is stuck, it is often due to metavariables
  Membership M (?m.627 h x) ; identifiers [M, u_1, s, Set, M, Mul, M, h, s, Set.center, M, x, M, x_1, x, x_2, M, hm, x_2, s, x, x_2, x_2, x] (during elaboration)

{X : Type u_1} [TopologicalSpace X] {x : X} {y : X} {F : Set X} (h : JoinedIn F x y) (hx : x ‚àà F) (hy : y ‚àà F) (h_1 : (JoinedIn.mem h =: (x ‚àà F : Prop) ‚àß (y ‚àà F : Prop)) = ({left := ((hx)) , right := ((hy))} =: (x ‚àà F : Prop) ‚àß (y ‚àà F : Prop)))  : ({left := ((hx)) , right := ((hy))}) = (JoinedIn.mem h)
<input>:1:135: expected term

{Œ± : Type u} (l : List Œ±) (n : ‚Ñï) (n : ‚Ñï) (hn : ‚àÄ (l : List Œ±) , List.rotate List.reverse List.rotate l n n = List.reverse l) (l : List Œ±) (hd : Œ±) (tl : List Œ±) (h : l = hd :: tl)  : hd :: tl = l
application type mismatch
  List.rotate ?m.79590 List.rotate
argument
  List.rotate
has type
  List ?m.79592 ‚Üí ‚Ñï ‚Üí List ?m.79592 : Type ?u.79591
but is expected to have type
  ‚Ñï : Type ; identifiers [Œ±, u, l, List, Œ±, n, n, hn, l, List, Œ±, List.rotate, List.reverse, List.rotate, l, n, n, List.reverse, l, l, List, Œ±, hd, Œ±, tl, List, Œ±, h, l, hd, tl, hd, tl, l] (during elaboration)

{Œ± : Type u_1} {p : (a : Finset Œ±) ‚Üí Prop} (empty : p ‚àÖ) (cons : ‚àÄ ‚¶É a : Œ± ‚¶Ñ {s : Finset Œ±} (h : ¬¨ (a ‚àà s : Prop)) (a_1 : p s) , p Finset.cons a s h) (x : Finset Œ±) (s : Multiset Œ±) (nd : Multiset.Nodup s) ‚¶É a : Œ± ‚¶Ñ {s : Multiset Œ±} (IH : ‚àÄ (nd : Multiset.Nodup s) , p {val := ((s)) , nodup := ((nd))}) (nd : Multiset.Nodup a ::‚Çò s) (m : ¬¨ (a ‚àà s : Prop)) (nd' : Multiset.Nodup s) (h : (Iff.mp (Multiset.nodup_cons =: (Multiset.Nodup a ::‚Çò s : Prop) ‚Üî ((¬¨ (a ‚àà s : Prop) : Prop) ‚àß (Multiset.Nodup s : Prop) : Prop)) nd =: (¬¨ (a ‚àà s : Prop) : Prop) ‚àß (Multiset.Nodup s : Prop)) = ({left := ((m)) , right := ((nd'))} =: (¬¨ (a ‚àà s : Prop) : Prop) ‚àß (Multiset.Nodup s : Prop)))  : p {val := ((s)) , nodup := ((nd'))}
<input>:1:416: expected term

{Œ≤ : Type u_1} [LinearOrder Œ≤] (h : WellFounded fun (x : Œ≤) (x_1 : Œ≤) ‚Ü¶ x < x_1) {f : (a : Œ≤) ‚Üí Œ≤} (hf : StrictMono f) (h‚ÇÅ : ¬¨ (‚àÄ (n : Œ≤) , n ‚â§ f n : Prop)) (h‚ÇÇ : WellFounded.min h fun (x : Œ≤) ‚Ü¶ Preorder.toLT . 1 f x x (Eq.mp (Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun (n : Œ≤) ‚Ü¶ n ‚â§ f n =: (¬¨ (‚àÄ (x : Œ≤) , x ‚â§ f x : Prop) : Prop) = (‚àÉ (x : Œ≤) , ¬¨ (x ‚â§ f x : Prop) : Prop)) (congrArg Exists (funext (fun (n : Œ≤) ‚Ü¶ Mathlib.Tactic.PushNeg.not_le_eq n f n =: ‚àÄ (n : Œ≤) , (¬¨ (n ‚â§ f n : Prop) : Prop) = (f n < n : Prop)) =: fun (x : Œ≤) ‚Ü¶ ¬¨ (x ‚â§ f x : Prop) = fun (x : Œ≤) ‚Ü¶ f x < x) =: (‚àÉ (x : Œ≤) , ¬¨ (x ‚â§ f x : Prop) : Prop) = (‚àÉ (x : Œ≤) , f x < x : Prop)) =: (¬¨ (‚àÄ (x : Œ≤) , x ‚â§ f x : Prop) : Prop) = (‚àÉ (x : Œ≤) , f x < x : Prop)) h‚ÇÅ =: ‚àÉ (x : Œ≤) , f x < x) ‚àà fun (x : Œ≤) ‚Ü¶ Preorder.toLT . 1 f x x)  : (¬¨ (‚àÄ (x : Œ≤) , x ‚â§ f x)) = (‚àÉ (x : Œ≤) , ¬¨ (x ‚â§ f x))
<input>:1:297: expected term

{Œ≤ : Type u_1} [LinearOrder Œ≤] (h : WellFounded fun (x : Œ≤) (x_1 : Œ≤) ‚Ü¶ x < x_1) {f : (a : Œ≤) ‚Üí Œ≤} (hf : StrictMono f) (h‚ÇÅ : ¬¨ (‚àÄ (n : Œ≤) , n ‚â§ f n : Prop)) (h‚ÇÇ : WellFounded.min h fun (x : Œ≤) ‚Ü¶ Preorder.toLT . 1 f x x (Eq.mp (Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun (n : Œ≤) ‚Ü¶ n ‚â§ f n =: (¬¨ (‚àÄ (x : Œ≤) , x ‚â§ f x : Prop) : Prop) = (‚àÉ (x : Œ≤) , ¬¨ (x ‚â§ f x : Prop) : Prop)) (congrArg Exists (funext (fun (n : Œ≤) ‚Ü¶ Mathlib.Tactic.PushNeg.not_le_eq n f n =: ‚àÄ (n : Œ≤) , (¬¨ (n ‚â§ f n : Prop) : Prop) = (f n < n : Prop)) =: fun (x : Œ≤) ‚Ü¶ ¬¨ (x ‚â§ f x : Prop) = fun (x : Œ≤) ‚Ü¶ f x < x) =: (‚àÉ (x : Œ≤) , ¬¨ (x ‚â§ f x : Prop) : Prop) = (‚àÉ (x : Œ≤) , f x < x : Prop)) =: (¬¨ (‚àÄ (x : Œ≤) , x ‚â§ f x : Prop) : Prop) = (‚àÉ (x : Œ≤) , f x < x : Prop)) h‚ÇÅ =: ‚àÉ (x : Œ≤) , f x < x) ‚àà fun (x : Œ≤) ‚Ü¶ Preorder.toLT . 1 f x x)  : f f WellFounded.min h fun (x : Œ≤) ‚Ü¶ Preorder.toLT . 1 f x x (Eq.mp (Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun (n : Œ≤) ‚Ü¶ n ‚â§ f n) (congrArg Exists (funext (fun (n : Œ≤) ‚Ü¶ Mathlib.Tactic.PushNeg.not_le_eq n f n)))) h‚ÇÅ) < f WellFounded.min h fun (x : Œ≤) ‚Ü¶ Preorder.toLT . 1 f x x (Eq.mp (Eq.trans (Mathlib.Tactic.PushNeg.not_forall_eq fun (n : Œ≤) ‚Ü¶ n ‚â§ f n) (congrArg Exists (funext (fun (n : Œ≤) ‚Ü¶ Mathlib.Tactic.PushNeg.not_le_eq n f n)))) h‚ÇÅ)
<input>:1:297: expected term

{Œ© : Type u_2} {Œ≤ : Type u_1} {Œπ : Type u_3} {m : MeasurableSpace Œ©} [TopologicalSpace Œ≤] [Preorder Œπ] {u : (a : Œπ) ‚Üí (a : Œ©) ‚Üí Œ≤} {v : (a : Œπ) ‚Üí (a : Œ©) ‚Üí Œ≤} {f : MeasureTheory.Filtration Œπ m} [MeasurableSpace Œπ] [Add Œ≤] [ContinuousAdd Œ≤] (hu : MeasureTheory.ProgMeasurable f u) (hv : MeasureTheory.ProgMeasurable f v) (i : Œπ)  : MeasureTheory.StronglyMeasurable fun (p : ‚Üë Set.Iic i √ó Œ©) ‚Ü¶ u ‚Üë Prod.fst p Prod.snd p
type mismatch
  Prod.fst
has type
  ?m.844 √ó ?m.845 ‚Üí ?m.844 : Type (max ?u.842 ?u.843)
but is expected to have type
  Œπ : Type u_3 ; identifiers [Œ©, u_2, Œ≤, u_1, Œπ, u_3, m, MeasurableSpace, Œ©, TopologicalSpace, Œ≤, Preorder, Œπ, u, a, Œπ, a, Œ©, Œ≤, v, a, Œπ, a, Œ©, Œ≤, f, MeasureTheory.Filtration, Œπ, m, MeasurableSpace, Œπ, Add, Œ≤, ContinuousAdd, Œ≤, hu, MeasureTheory.ProgMeasurable, f, u, hv, MeasureTheory.ProgMeasurable, f, v, i, Œπ, MeasureTheory.StronglyMeasurable, p, Set.Iic, i, Œ©, u, Prod.fst, p, Prod.snd, p] (during elaboration)

{Œ© : Type u_2} {Œ≤ : Type u_1} {Œπ : Type u_3} {m : MeasurableSpace Œ©} [TopologicalSpace Œ≤] [Preorder Œπ] {u : (a : Œπ) ‚Üí (a : Œ©) ‚Üí Œ≤} {v : (a : Œπ) ‚Üí (a : Œ©) ‚Üí Œ≤} {f : MeasureTheory.Filtration Œπ m} [MeasurableSpace Œπ] [Add Œ≤] [ContinuousAdd Œ≤] (hu : MeasureTheory.ProgMeasurable f u) (hv : MeasureTheory.ProgMeasurable f v) (i : Œπ)  : MeasureTheory.StronglyMeasurable fun (p : ‚Üë Set.Iic i √ó Œ©) ‚Ü¶ v ‚Üë Prod.fst p Prod.snd p
type mismatch
  Prod.fst
has type
  ?m.844 √ó ?m.845 ‚Üí ?m.844 : Type (max ?u.842 ?u.843)
but is expected to have type
  Œπ : Type u_3 ; identifiers [Œ©, u_2, Œ≤, u_1, Œπ, u_3, m, MeasurableSpace, Œ©, TopologicalSpace, Œ≤, Preorder, Œπ, u, a, Œπ, a, Œ©, Œ≤, v, a, Œπ, a, Œ©, Œ≤, f, MeasureTheory.Filtration, Œπ, m, MeasurableSpace, Œπ, Add, Œ≤, ContinuousAdd, Œ≤, hu, MeasureTheory.ProgMeasurable, f, u, hv, MeasureTheory.ProgMeasurable, f, v, i, Œπ, MeasureTheory.StronglyMeasurable, p, Set.Iic, i, Œ©, v, Prod.fst, p, Prod.snd, p] (during elaboration)

(x : CategoryTheory.Limits.Cocone CategoryTheory.Functor.empty Type u_2) (x_1 : CategoryTheory.Limits.Cocone.pt {pt := ((PEmpty)) , Œπ := ((CategoryTheory.Functor.uniqueFromEmpty CategoryTheory.Functor.toPrefunctor CategoryTheory.Functor.const CategoryTheory.Discrete PEmpty . obj PEmpty . inv))} ‚ü∂ CategoryTheory.Limits.Cocone.pt x) (x_2 : ‚àÄ (j : CategoryTheory.Discrete PEmpty) , CategoryTheory.CategoryStruct.comp CategoryTheory.NatTrans.app CategoryTheory.Limits.Cocone.Œπ {pt := ((PEmpty)) , Œπ := ((CategoryTheory.Functor.uniqueFromEmpty CategoryTheory.Functor.toPrefunctor CategoryTheory.Functor.const CategoryTheory.Discrete PEmpty . obj PEmpty . inv))} j x_1 = CategoryTheory.NatTrans.app CategoryTheory.Limits.Cocone.Œπ x j) (x_3 : CategoryTheory.Limits.Cocone.pt {pt := ((PEmpty)) , Œπ := ((CategoryTheory.Functor.uniqueFromEmpty CategoryTheory.Functor.toPrefunctor CategoryTheory.Functor.const CategoryTheory.Discrete PEmpty . obj PEmpty . inv))})  : x_3 = x_3
function expected at
  CategoryTheory.Limits.Cocone ?m.165
term has type
  Type (max (max ?u.4 ?u.3) ?u.5) ; identifiers [x, CategoryTheory.Limits.Cocone, CategoryTheory.Functor.empty, u_2, x_1, CategoryTheory.Limits.Cocone.pt, pt, PEmpty, Œπ, CategoryTheory.Functor.uniqueFromEmpty, CategoryTheory.Functor.toPrefunctor, CategoryTheory.Functor.const, CategoryTheory.Discrete, PEmpty, obj, PEmpty, inv, CategoryTheory.Limits.Cocone.pt, x, x_2, j, CategoryTheory.Discrete, PEmpty, CategoryTheory.CategoryStruct.comp, CategoryTheory.NatTrans.app, CategoryTheory.Limits.Cocone.Œπ, pt, PEmpty, Œπ, CategoryTheory.Functor.uniqueFromEmpty, CategoryTheory.Functor.toPrefunctor, CategoryTheory.Functor.const, CategoryTheory.Discrete, PEmpty, obj, PEmpty, inv, j, x_1, CategoryTheory.NatTrans.app, CategoryTheory.Limits.Cocone.Œπ, x, j, x_3, CategoryTheory.Limits.Cocone.pt, pt, PEmpty, Œπ, CategoryTheory.Functor.uniqueFromEmpty, CategoryTheory.Functor.toPrefunctor, CategoryTheory.Functor.const, CategoryTheory.Discrete, PEmpty, obj, PEmpty, inv, x_3, x_3] (during elaboration)

 : (‚àÄ {Œ± : Type u} (self : UniformSpace.Core Œ±) , Filter.Tendsto Prod.swap UniformSpace.Core.uniformity self UniformSpace.Core.uniformity self)
application type mismatch
  Filter.Tendsto Prod.swap UniformSpace.Core.uniformity
argument
  UniformSpace.Core.uniformity
has type
  UniformSpace.Core ?m.20 ‚Üí Filter (?m.20 √ó ?m.20) : Type ?u.19
but is expected to have type
  Filter (?m.14 √ó ?m.15) : Type (max ?u.12 ?u.13) ; identifiers [Œ±, u, self, UniformSpace.Core, Œ±, Filter.Tendsto, Prod.swap, UniformSpace.Core.uniformity, self, UniformSpace.Core.uniformity, self] (during elaboration)

 : ‚àÄ (Œ± : Type u) (self : UniformSpace.Core Œ±) , Filter.Tendsto Prod.swap self . 1 self . 1
application type mismatch
  Filter.Tendsto Prod.swap self
argument
  self
has type
  UniformSpace.Core Œ± : Type u
but is expected to have type
  Filter (?m.14 √ó ?m.15) : Type (max ?u.12 ?u.13) ; identifiers [Œ±, u, self, UniformSpace.Core, Œ±, Filter.Tendsto, Prod.swap, self, self] (during elaboration)

{Œ± : Type u} {Œ≤ : Type v} [TopologicalSpace Œ±] [TopologicalSpace Œ≤] [T2Space Œ±] {f : (a : Œ±) ‚Üí Œ≤} {g : (a : Œ≤) ‚Üí Œ±} (h : Function.LeftInverse f g) (hf : Continuous f) (hg : Continuous g) (this : Set.EqOn g ‚àò f id closure Set.range g) (x : Œ±) (hx : x ‚àà closure Set.range g)  : g ‚àò f x = id x
application type mismatch
  f id
argument
  id
has type
  ?m.726 ‚Üí ?m.726 : Sort ?u.725
but is expected to have type
  Œ± : Type u ; identifiers [Œ±, u, Œ≤, v, TopologicalSpace, Œ±, TopologicalSpace, Œ≤, T2Space, Œ±, f, a, Œ±, Œ≤, g, a, Œ≤, Œ±, h, Function.LeftInverse, f, g, hf, Continuous, f, hg, Continuous, g, this, Set.EqOn, g, f, id, closure, Set.range, g, x, Œ±, hx, x, closure, Set.range, g, g, f, x, id, x] (during elaboration)

{H : Type u_1} [TopologicalSpace H] {Œ± : Type u_2} [TopologicalSpace Œ±] (e : LocalHomeomorph Œ± H) (x : Œ±) em : (a : Prop) ‚Üí Decidable (a : Prop) := Classical.propDecidable  : fun (x : Œ±) ‚Ü¶ e x = fun (x : Œ±) ‚Ü¶ e x
<input>:1:109: expected end of input

{Œπ : Type u'} {R : Type u_1} {M : Type u_2} {v : (a : Œπ) ‚Üí M} [Ring R] [AddCommGroup M] [Module R M] (hv : LinearIndependent R v)  : ‚ä§ = ‚ä§
typeclass instance problem is stuck, it is often due to metavariables
  Top (?m.2348 hv) ; identifiers [Œπ, u', R, u_1, M, u_2, v, a, Œπ, M, Ring, R, AddCommGroup, M, Module, R, M, hv, LinearIndependent, R, v] (during elaboration)

{M‚ÇÄ : Type u_1} [inst : MonoidWithZero M‚ÇÄ] {a : M‚ÇÄ} (h : IsUnit Ring.inverse a) (h_1 : Subsingleton M‚ÇÄ) (h_2 : (subsingleton_or_nontrivial M‚ÇÄ =: (Subsingleton M‚ÇÄ : Prop) ‚à® (Nontrivial M‚ÇÄ : Prop)) = (Or.inl h_1 =: (Subsingleton M‚ÇÄ : Prop) ‚à® (Nontrivial M‚ÇÄ : Prop)))  : (Or.inl h_1) = (subsingleton_or_nontrivial M‚ÇÄ)
<input>:1:143: expected term

 : (‚àÄ (k : Type u_1) {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V] [inst_3 : AddTorsor V P] {Œπ : Type u_4} (p : (a : Œπ) ‚Üí P) , (AffineIndependent k p) ‚Üî (‚àÄ (s : Finset Œπ) (w : (a : Œπ) ‚Üí k) (a : Finset.sum s fun (i : Œπ) ‚Ü¶ w i = 0) (a : ‚Üë Finset.weightedVSub s p w = 0) (i : Œπ) (a : i ‚àà s) , w i = 0))
failed to synthesize instance
  AddCommMonoid Prop ; identifiers [k, u_1, V, u_2, P, u_3, inst, Ring, k, inst_1, AddCommGroup, V, inst_2, Module, k, V, inst_3, AddTorsor, V, P, Œπ, u_4, p, a, Œπ, P, AffineIndependent, k, p, s, Finset, Œπ, w, a, Œπ, k, a, Finset.sum, s, i, Œπ, w, i, a, Finset.weightedVSub, s, p, w, i, Œπ, a, i, s, w, i] (during elaboration)

{Œ± : Type u_1} [UniformSpace Œ±] (x : Quotient UniformSpace.separationSetoid Œ± √ó Quotient UniformSpace.separationSetoid Œ±) (a : Quotient UniformSpace.separationSetoid Œ±) (b : Quotient UniformSpace.separationSetoid Œ±) (a : Œ±) (b : Œ±) (h : (Quotient.mk UniformSpace.separationSetoid Œ± a , Quotient.mk UniformSpace.separationSetoid Œ± b) ‚àà separationRel Quotient UniformSpace.separationSetoid Œ±) (s : Set Œ± √ó Œ±) (hs : s ‚àà Filter.sets uniformity Œ±) (this : s ‚àà Filter.comap fun (p : Œ± √ó Œ±) ‚Ü¶ (Quotient.mk UniformSpace.separationSetoid Œ± Prod.fst p , Quotient.mk UniformSpace.separationSetoid Œ± Prod.snd p) uniformity Quotient UniformSpace.separationSetoid Œ±) (t : Set Quotient UniformSpace.separationSetoid Œ± √ó Quotient UniformSpace.separationSetoid Œ±) (ht : t ‚àà uniformity Quotient UniformSpace.separationSetoid Œ±) (hts : fun (p : Œ± √ó Œ±) ‚Ü¶ (Quotient.mk UniformSpace.separationSetoid Œ± Prod.fst p , Quotient.mk UniformSpace.separationSetoid Œ± Prod.snd p) ‚Åª¬π' t ‚äÜ s)  : (Quotient.mk UniformSpace.separationSetoid Œ± a , Quotient.mk UniformSpace.separationSetoid Œ± b) ‚àà t
function expected at
  Quotient ?m.79938
term has type
  Sort ?u.12 ; identifiers [Œ±, u_1, UniformSpace, Œ±, x, Quotient, UniformSpace.separationSetoid, Œ±, Quotient, UniformSpace.separationSetoid, Œ±, a, Quotient, UniformSpace.separationSetoid, Œ±, b, Quotient, UniformSpace.separationSetoid, Œ±, a, Œ±, b, Œ±, h, Quotient.mk, UniformSpace.separationSetoid, Œ±, a, Quotient.mk, UniformSpace.separationSetoid, Œ±, b, separationRel, Quotient, UniformSpace.separationSetoid, Œ±, s, Set, Œ±, Œ±, hs, s, Filter.sets, uniformity, Œ±, this, s, Filter.comap, p, Œ±, Œ±, Quotient.mk, UniformSpace.separationSetoid, Œ±, Prod.fst, p, Quotient.mk, UniformSpace.separationSetoid, Œ±, Prod.snd, p, uniformity, Quotient, UniformSpace.separationSetoid, Œ±, t, Set, Quotient, UniformSpace.separationSetoid, Œ±, Quotient, UniformSpace.separationSetoid, Œ±, ht, t, uniformity, Quotient, UniformSpace.separationSetoid, Œ±, hts, p, Œ±, Œ±, Quotient.mk, UniformSpace.separationSetoid, Œ±, Prod.fst, p, Quotient.mk, UniformSpace.separationSetoid, Œ±, Prod.snd, p, t, s, Quotient.mk, UniformSpace.separationSetoid, Œ±, a, Quotient.mk, UniformSpace.separationSetoid, Œ±, b, t] (during elaboration)

{Œ± : Type u} [TopologicalSpace Œ±] [LinearOrder Œ±] [OrderTopology Œ±] [DenselyOrdered Œ±] {a : Œ±} {s : Set Œ±} (ha : s ‚äÜ Set.Ioi a) (hs : ‚àÄ (a_1 : Set.Nonempty s) , ‚àÉ (b : Œ±) , (b > a : Prop) ‚àß (Set.Ioo a b ‚äÜ s : Prop)) (h : Set.Nonempty ‚Üë OrderDual.ofDual ‚Åª¬π' s)  : ‚àÉ (b : Œ±) , (b > a) ‚àß (Set.Ioo a b ‚äÜ s)
application type mismatch
  Set.preimage (Set.Nonempty ?m.3093)
argument
  Set.Nonempty ?m.3093
has type
  Prop : Type
but is expected to have type
  ?m.82339 ha hs ‚Üí Œ± : Type (max u ?u.2900) ; identifiers [Œ±, u, TopologicalSpace, Œ±, LinearOrder, Œ±, OrderTopology, Œ±, DenselyOrdered, Œ±, a, Œ±, s, Set, Œ±, ha, s, Set.Ioi, a, hs, a_1, Set.Nonempty, s, b, Œ±, b, a, Set.Ioo, a, b, s, h, Set.Nonempty, OrderDual.ofDual, s, b, Œ±, b, a, Set.Ioo, a, b, s] (during elaboration)

{V : Type} (G : SimpleGraph V) [Finite V] (a : ‚Üë SimpleGraph.end G) (s : (j : Finset V ·µí·µñ) ‚Üí CategoryTheory.Functor.toPrefunctor SimpleGraph.componentComplFunctor G . obj j) (property : s ‚àà SimpleGraph.end G) (val : Fintype V) (h : (nonempty_fintype V =: Nonempty Fintype V) = (Nonempty.intro val =: Nonempty Fintype V))  : (Nonempty.intro val) = (nonempty_fintype V)
<input>:1:253: expected term

{Œ± : Type u} {Œ≤ : (a : Œ±) ‚Üí Type v} [DecidableEq Œ±] (c : Sigma Œ≤) (l : List Sigma Œ≤) (h : List.NodupKeys c :: l) {Œ± : Type u} {Œ≤ : (a : Œ±) ‚Üí Type v} (entries : List Sigma Œ≤) (entries_1 : List Sigma Œ≤) (e_entries : entries = entries_1)  : ‚àÄ (nodupKeys : List.NodupKeys entries) , {entries := ((entries)) , nodupKeys := ((nodupKeys))} = {entries := ((entries)) , nodupKeys := ((nodupKeys))}
application type mismatch
  List Sigma
argument
  Sigma
has type
  (?m.34 ‚Üí Type ?u.32) ‚Üí Type (max ?u.33 ?u.32) : Type (max (?u.32 + 1) (?u.33 + 1))
but is expected to have type
  Type ?u.31 : Type (?u.31 + 1) ; identifiers [Œ±, u, Œ≤, a, Œ±, v, DecidableEq, Œ±, c, Sigma, Œ≤, l, List, Sigma, Œ≤, h, List.NodupKeys, c, l, Œ±, u, Œ≤, a, Œ±, v, entries, List, Sigma, Œ≤, entries_1, List, Sigma, Œ≤, e_entries, entries, entries_1, nodupKeys, List.NodupKeys, entries, entries, entries, nodupKeys, nodupKeys, entries, entries, nodupKeys, nodupKeys] (during elaboration)

{M‚ÇÄ : Type u_1} [inst : MonoidWithZero M‚ÇÄ] {a : M‚ÇÄ} (h : IsUnit Ring.inverse a) (h_1 : Subsingleton M‚ÇÄ) (h_2 : (subsingleton_or_nontrivial M‚ÇÄ =: (Subsingleton M‚ÇÄ : Prop) ‚à® (Nontrivial M‚ÇÄ : Prop)) = (Or.inl h_1 =: (Subsingleton M‚ÇÄ : Prop) ‚à® (Nontrivial M‚ÇÄ : Prop))) (M : Type u_1) (inst : Monoid M) (a : M) (a' : M) (e'_3 : a = a') (h : a' = a) (a' : M)  : a = a
<input>:1:143: expected term

{M‚ÇÄ : Type u_1} [inst : MonoidWithZero M‚ÇÄ] {a : M‚ÇÄ} (h : IsUnit Ring.inverse a) (h_1 : Subsingleton M‚ÇÄ) (h_2 : (subsingleton_or_nontrivial M‚ÇÄ =: (Subsingleton M‚ÇÄ : Prop) ‚à® (Nontrivial M‚ÇÄ : Prop)) = (Or.inl h_1 =: (Subsingleton M‚ÇÄ : Prop) ‚à® (Nontrivial M‚ÇÄ : Prop))) (M : Type u_1) (inst : Monoid M) (a : M) (a' : M) (e'_3 : a = a') (h : a' = a)  : a = a'
<input>:1:143: expected term

{M‚ÇÄ : Type u_1} [inst : MonoidWithZero M‚ÇÄ] {a : M‚ÇÄ} (h : IsUnit Ring.inverse a) (h_1 : Subsingleton M‚ÇÄ) (h_2 : (subsingleton_or_nontrivial M‚ÇÄ =: (Subsingleton M‚ÇÄ : Prop) ‚à® (Nontrivial M‚ÇÄ : Prop)) = (Or.inl h_1 =: (Subsingleton M‚ÇÄ : Prop) ‚à® (Nontrivial M‚ÇÄ : Prop))) (M : Type u_1) (inst : Monoid M) (a : M) (a' : M) (e'_3 : a = a')  : a' = a'
<input>:1:143: expected term

{ùïú : Type u_1} {E : Type u_2} [SeminormedRing ùïú] [SMul ùïú E] {A : Set E} {B : Set E} (hA : Balanced ùïú A) (hB : Balanced ùïú B) (_a : ùïú) (ha : ‚Äñ _a ‚Äñ ‚â§ 1)  : _a ‚Ä¢ A ‚äÜ A
<input>:1:146: expected term

{ùïú : Type u_1} {E : Type u_2} [SeminormedRing ùïú] [SMul ùïú E] {A : Set E} {B : Set E} (hA : Balanced ùïú A) (hB : Balanced ùïú B) (_a : ùïú) (ha : ‚Äñ _a ‚Äñ ‚â§ 1)  : _a ‚Ä¢ B ‚äÜ B
<input>:1:146: expected term

{M‚ÇÄ : Type u_1} [inst : MonoidWithZero M‚ÇÄ] {a : M‚ÇÄ} (h : IsUnit Ring.inverse a) (h_1 : Nontrivial M‚ÇÄ) (h_2 : (subsingleton_or_nontrivial M‚ÇÄ =: (Subsingleton M‚ÇÄ : Prop) ‚à® (Nontrivial M‚ÇÄ : Prop)) = (Or.inr h_1 =: (Subsingleton M‚ÇÄ : Prop) ‚à® (Nontrivial M‚ÇÄ : Prop)))  : (Or.inr h_1) = (subsingleton_or_nontrivial M‚ÇÄ)
<input>:1:141: expected term

 : (‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (self : IsSpectralMap f) ‚¶É s : Set Œ≤ ‚¶Ñ (a : IsOpen s) (a : IsCompact s) , IsCompact f ‚Åª¬π' s)
application type mismatch
  Set.preimage (IsCompact ?m.994)
argument
  IsCompact ?m.994
has type
  Prop : Type
but is expected to have type
  ?m.80489 self a‚úù a ‚Üí Œ≤ : Type (max u_2 ?u.668) ; identifiers [Œ±, u_1, Œ≤, u_2, inst, TopologicalSpace, Œ±, inst_1, TopologicalSpace, Œ≤, f, a, Œ±, Œ≤, self, IsSpectralMap, f, s, Set, Œ≤, a, IsOpen, s, a, IsCompact, s, IsCompact, f, s] (during elaboration)

 : ‚àÄ (Œ± : Type u_1) (Œ≤ : Type u_2) [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] (f : (a : Œ±) ‚Üí Œ≤) (self : IsSpectralMap f) ‚¶É s : Set Œ≤ ‚¶Ñ (a : IsOpen s) (a : IsCompact s) , IsCompact f ‚Åª¬π' s
application type mismatch
  Set.preimage (IsCompact ?m.994)
argument
  IsCompact ?m.994
has type
  Prop : Type
but is expected to have type
  ?m.80489 Œ± Œ≤ f self a‚úù a ‚Üí Œ≤ : Type (max u_2 ?u.668) ; identifiers [Œ±, u_1, Œ≤, u_2, inst, TopologicalSpace, Œ±, inst_1, TopologicalSpace, Œ≤, f, a, Œ±, Œ≤, self, IsSpectralMap, f, s, Set, Œ≤, a, IsOpen, s, a, IsCompact, s, IsCompact, f, s] (during elaboration)

{M : Type u_2} {N : Type u_1} [MulOneClass M] [MulOneClass N] (f : M ‚Üí* N) (hf : ‚àÄ (x : M) (y : M) , Commute ‚Üë f x ‚Üë f y) (x : M) (y : M)  : Commute ‚Üë f x ‚Üë f y
function expected at
  Commute ?m.42 x
term has type
  Prop ; identifiers [M, u_2, N, u_1, MulOneClass, M, MulOneClass, N, f, M, N, hf, x, M, y, M, Commute, f, x, f, y, x, M, y, M, Commute, f, x, f, y] (during elaboration)

{V : Type u_1} [NormedAddCommGroup V] [InnerProductSpace ‚Ñù V] [Fact (FiniteDimensional.finrank ‚Ñù V = 2 : Prop)] (o : Orientation ‚Ñù V Fin 2) {x : V} {y : V} (h : Orientation.oangle o x y = ‚Üë Real.pi)  : ‚Üë Real.pi = Orientation.oangle o x y
application type mismatch
  Orientation ‚Ñù V Fin
argument
  Fin
has type
  ‚Ñï ‚Üí Type : Type 1
but is expected to have type
  Type ?u.250 : Type (?u.250 + 1) ; identifiers [V, u_1, NormedAddCommGroup, V, InnerProductSpace, V, Fact, FiniteDimensional.finrank, V, o, Orientation, V, Fin, x, V, y, V, h, Orientation.oangle, o, x, y, Real.pi, Real.pi, Orientation.oangle, o, x, y] (during elaboration)

{Œ± : Type u_2} {Œ≤ : Type u_4} {Œ≤' : Type u_3} {Œ≥ : Type u_1} {Œ¥ : Type u_5} {f : Filter Œ±} {g : Filter Œ≤} {m : (a : Œ±) ‚Üí (a : Œ≤') ‚Üí Œ≥} {n : (a : Œ≤) ‚Üí Œ≤'} {m' : (a : Œ≤) ‚Üí (a : Œ±) ‚Üí Œ¥} {n' : (a : Œ¥) ‚Üí Œ≥} (h_right_anticomm : ‚àÄ (a : Œ±) (b : Œ≤) , m a n b = n' m' b a) (a : Œ≤) (b : Œ±)  : m b n a = n' m' a b
application type mismatch
  m a n
argument
  n
has type
  Œ≤ ‚Üí Œ≤' : Type (max u_3 u_4)
but is expected to have type
  Œ≤' : Type u_3 ; identifiers [Œ±, u_2, Œ≤, u_4, Œ≤', u_3, Œ≥, u_1, Œ¥, u_5, f, Filter, Œ±, g, Filter, Œ≤, m, a, Œ±, a, Œ≤', Œ≥, n, a, Œ≤, Œ≤', m', a, Œ≤, a, Œ±, Œ¥, n', a, Œ¥, Œ≥, h_right_anticomm, a, Œ±, b, Œ≤, m, a, n, b, n', m', b, a, a, Œ≤, b, Œ±, m, b, n, a, n', m', a, b] (during elaboration)

{Œ± : Type u} (l : List Œ±) (n : ‚Ñï) (n : ‚Ñï) (hn : ‚àÄ (l : List Œ±) , List.rotate List.reverse List.rotate l n n = List.reverse l) (l : List Œ±)  : l = l
application type mismatch
  List.rotate ?m.79590 List.rotate
argument
  List.rotate
has type
  List ?m.79592 ‚Üí ‚Ñï ‚Üí List ?m.79592 : Type ?u.79591
but is expected to have type
  ‚Ñï : Type ; identifiers [Œ±, u, l, List, Œ±, n, n, hn, l, List, Œ±, List.rotate, List.reverse, List.rotate, l, n, n, List.reverse, l, l, List, Œ±, l, l] (during elaboration)

{Œ± : Type u} {Œπ : Sort w} [TopologicalSpace Œ±] {a : Œ±} {p : (a : Œπ) ‚Üí Prop} {s : (a : Œπ) ‚Üí Set Œ±} (h : Filter.HasBasis nhds a p s) {t : Set Œ±} ‚¶É i : Œπ ‚¶Ñ  : (p i) = (p i)
application type mismatch
  Filter.HasBasis ?m.79905 a
argument
  a
has type
  Œ± : Type u
but is expected to have type
  ?m.33 ‚Üí Prop : Sort (max 1 ?u.30) ; identifiers [Œ±, u, Œπ, w, TopologicalSpace, Œ±, a, Œ±, p, a, Œπ, s, a, Œπ, Set, Œ±, h, Filter.HasBasis, nhds, a, p, s, t, Set, Œ±, i, Œπ, p, i, p, i] (during elaboration)

{C : Type u_2} [CategoryTheory.Category C] [CategoryTheory.Limits.HasZeroMorphisms C] (S : CategoryTheory.ShortComplex C) (hf : CategoryTheory.ShortComplex.f S = 0) (c : CategoryTheory.Limits.KernelFork CategoryTheory.ShortComplex.g S) (hc : CategoryTheory.Limits.IsLimit c)  : 0 = 0
function expected at
  CategoryTheory.Limits.KernelFork ?m.83128
term has type
  Type (max ?u.147 ?u.148) ; identifiers [C, u_2, CategoryTheory.Category, C, CategoryTheory.Limits.HasZeroMorphisms, C, S, CategoryTheory.ShortComplex, C, hf, CategoryTheory.ShortComplex.f, S, c, CategoryTheory.Limits.KernelFork, CategoryTheory.ShortComplex.g, S, hc, CategoryTheory.Limits.IsLimit, c] (during elaboration)

{F : Type v} [NormedAddCommGroup F] [NormedSpace ‚ÑÇ F] {f : (a : ‚ÑÇ) ‚Üí F} (hf : Differentiable ‚ÑÇ f) (hb : Metric.Bounded Set.range f) (z : ‚ÑÇ) (w : ‚ÑÇ) (c : ‚ÑÇ) (C : ‚Ñù) (h : (C > 0 : Prop) ‚àß (‚àÄ (z : ‚ÑÇ) , ‚Äñ f z ‚Äñ ‚â§ C : Prop)) (C‚ÇÄ : C > 0) (hC : ‚àÄ (z : ‚ÑÇ) , ‚Äñ f z ‚Äñ ‚â§ C) (Œµ : ‚Ñù) (Œµ‚ÇÄ : 0 < Œµ)  : ‚àÄ (z : ‚ÑÇ) (x : z ‚àà Metric.sphere c C / Œµ) , ‚Äñ f z ‚Äñ ‚â§ C
<input>:1:207: expected term

{V : Type u_1} {P : Type u_2} [NormedAddCommGroup V] [InnerProductSpace ‚Ñù V] [MetricSpace P] [NormedAddTorsor V P] [Fact (FiniteDimensional.finrank ‚Ñù V = 2 : Prop)] [Module.Oriented ‚Ñù V Fin 2] {p‚ÇÅ : P} {p‚ÇÇ : P} {p‚ÇÉ : P} (h : EuclideanGeometry.oangle p‚ÇÅ p‚ÇÇ p‚ÇÉ = ‚Üë Real.pi / 2)  : 1 = 1
application type mismatch
  Module.Oriented ‚Ñù V Fin
argument
  Fin
has type
  ‚Ñï ‚Üí Type : Type 1
but is expected to have type
  Type ?u.490 : Type (?u.490 + 1) ; identifiers [V, u_1, P, u_2, NormedAddCommGroup, V, InnerProductSpace, V, MetricSpace, P, NormedAddTorsor, V, P, Fact, FiniteDimensional.finrank, V, Module.Oriented, V, Fin, p‚ÇÅ, P, p‚ÇÇ, P, p‚ÇÉ, P, h, EuclideanGeometry.oangle, p‚ÇÅ, p‚ÇÇ, p‚ÇÉ, Real.pi] (during elaboration)

{n : ‚Ñï} {i : Fin Nat.succ n} {j : Fin Nat.succ n} (h : j = i)  : j ‚â§ i
application type mismatch
  Fin Nat.succ
argument
  Nat.succ
has type
  ‚Ñï ‚Üí ‚Ñï : Type
but is expected to have type
  ‚Ñï : Type ; identifiers [n, i, Fin, Nat.succ, n, j, Fin, Nat.succ, n, h, j, i, j, i] (during elaboration)

{n : ‚Ñï} {i : Fin Nat.succ n} {j : Fin Nat.succ n} (h : j = i)  : (if (j = i) then 0 else j + 1 = 0) = (if (j = i) then 0 else j + 1 = 0)
application type mismatch
  Fin Nat.succ
argument
  Nat.succ
has type
  ‚Ñï ‚Üí ‚Ñï : Type
but is expected to have type
  ‚Ñï : Type ; identifiers [n, i, Fin, Nat.succ, n, j, Fin, Nat.succ, n, h, j, i, j, i, j, j, i, j] (during elaboration)

{n : ‚Ñï} {i : Fin Nat.succ n} {j : Fin Nat.succ n} (h : j = i)  : 0 = 0
application type mismatch
  Fin Nat.succ
argument
  Nat.succ
has type
  ‚Ñï ‚Üí ‚Ñï : Type
but is expected to have type
  ‚Ñï : Type ; identifiers [n, i, Fin, Nat.succ, n, j, Fin, Nat.succ, n, h, j, i] (during elaboration)

{Œ± : Type u} [inst : AddGroup Œ±] [LE Œ±] [CovariantClass Œ± Œ± Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1 fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±} {b : Œ±} {Œ± : Type u} [AddGroup Œ±] [LE Œ±] [CovariantClass Œ± Œ± Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1 fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±} {b : Œ±}  : ((0 ‚â§ a - b) ‚Üî (b ‚â§ a)) = ((0 ‚â§ a - b) ‚Üî (b ‚â§ a))
application type mismatch
  CovariantClass Œ± Œ± Function.swap
argument
  Function.swap
has type
  ((x : ?m.19) ‚Üí (y : ?m.20) ‚Üí ?m.21 x y) ‚Üí
    (y : ?m.20) ‚Üí (x : ?m.19) ‚Üí ?m.21 x y : Sort (imax (imax ?u.18 ?u.17 ?u.16) ?u.17 ?u.18 ?u.16)
but is expected to have type
  Œ± ‚Üí Œ± ‚Üí Œ± : Type u ; identifiers [Œ±, u, inst, AddGroup, Œ±, LE, Œ±, CovariantClass, Œ±, Œ±, Function.swap, x, Œ±, x_1, Œ±, x, x_1, x, Œ±, x_1, Œ±, x, x_1, a, Œ±, b, Œ±, Œ±, u, AddGroup, Œ±, LE, Œ±, CovariantClass, Œ±, Œ±, Function.swap, x, Œ±, x_1, Œ±, x, x_1, x, Œ±, x_1, Œ±, x, x_1, a, Œ±, b, Œ±, a, b, b, a, a, b, b, a] (during elaboration)

{Œ± : Type u_1} [AddGroup Œ±] [Preorder Œ±] [DecidableRel fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] [CovariantClass Œ± Œ± fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1 fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] (a : Œ±)  : ‚àÄ (a : a < 0) , 1 = 1
function expected at
  x_1
term has type
  Œ± ; identifiers [Œ±, u_1, AddGroup, Œ±, Preorder, Œ±, DecidableRel, x, Œ±, x_1, Œ±, x, x_1, CovariantClass, Œ±, Œ±, x, Œ±, x_1, Œ±, x, x_1, x, Œ±, x_1, Œ±, x, x_1, a, Œ±, a, a] (during elaboration)

{Œ± : Type u_1} [AddGroup Œ±] [Preorder Œ±] [DecidableRel fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] [CovariantClass Œ± Œ± fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1 fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] (a : Œ±)  : ‚àÄ (a_1 : ¬¨ (a < 0)) , if (- a < 0) then - 1 else 0 = if (- a < 0) then - 1 else 0
function expected at
  x_1
term has type
  Œ± ; identifiers [Œ±, u_1, AddGroup, Œ±, Preorder, Œ±, DecidableRel, x, Œ±, x_1, Œ±, x, x_1, CovariantClass, Œ±, Œ±, x, Œ±, x_1, Œ±, x, x_1, x, Œ±, x_1, Œ±, x, x_1, a, Œ±, a_1, a, a, a] (during elaboration)

{Œ± : Type u} [inst : AddGroup Œ±] [LE Œ±] [CovariantClass Œ± Œ± Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1 fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±} {b : Œ±} {Œ± : Type u} [AddGroup Œ±] [LE Œ±] [CovariantClass Œ± Œ± Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1 fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±} {b : Œ±}  : ((0 + b ‚â§ a - b + b) ‚Üî (b ‚â§ a)) = ((0 + b ‚â§ a - b + b) ‚Üî (b ‚â§ a))
application type mismatch
  CovariantClass Œ± Œ± Function.swap
argument
  Function.swap
has type
  ((x : ?m.19) ‚Üí (y : ?m.20) ‚Üí ?m.21 x y) ‚Üí
    (y : ?m.20) ‚Üí (x : ?m.19) ‚Üí ?m.21 x y : Sort (imax (imax ?u.18 ?u.17 ?u.16) ?u.17 ?u.18 ?u.16)
but is expected to have type
  Œ± ‚Üí Œ± ‚Üí Œ± : Type u ; identifiers [Œ±, u, inst, AddGroup, Œ±, LE, Œ±, CovariantClass, Œ±, Œ±, Function.swap, x, Œ±, x_1, Œ±, x, x_1, x, Œ±, x_1, Œ±, x, x_1, a, Œ±, b, Œ±, Œ±, u, AddGroup, Œ±, LE, Œ±, CovariantClass, Œ±, Œ±, Function.swap, x, Œ±, x_1, Œ±, x, x_1, x, Œ±, x_1, Œ±, x, x_1, a, Œ±, b, Œ±, b, a, b, b, b, a, b, a, b, b, b, a] (during elaboration)

{Œ± : Type u} [inst : AddGroup Œ±] [LE Œ±] [CovariantClass Œ± Œ± Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1 fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±} {b : Œ±} {Œ± : Type u} [AddGroup Œ±] [LE Œ±] [CovariantClass Œ± Œ± Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1 fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±} {b : Œ±}  : ((b ‚â§ a - b + b) ‚Üî (b ‚â§ a)) = ((b ‚â§ a - b + b) ‚Üî (b ‚â§ a))
application type mismatch
  CovariantClass Œ± Œ± Function.swap
argument
  Function.swap
has type
  ((x : ?m.19) ‚Üí (y : ?m.20) ‚Üí ?m.21 x y) ‚Üí
    (y : ?m.20) ‚Üí (x : ?m.19) ‚Üí ?m.21 x y : Sort (imax (imax ?u.18 ?u.17 ?u.16) ?u.17 ?u.18 ?u.16)
but is expected to have type
  Œ± ‚Üí Œ± ‚Üí Œ± : Type u ; identifiers [Œ±, u, inst, AddGroup, Œ±, LE, Œ±, CovariantClass, Œ±, Œ±, Function.swap, x, Œ±, x_1, Œ±, x, x_1, x, Œ±, x_1, Œ±, x, x_1, a, Œ±, b, Œ±, Œ±, u, AddGroup, Œ±, LE, Œ±, CovariantClass, Œ±, Œ±, Function.swap, x, Œ±, x_1, Œ±, x, x_1, x, Œ±, x_1, Œ±, x, x_1, a, Œ±, b, Œ±, b, a, b, b, b, a, b, a, b, b, b, a] (during elaboration)

{Œ± : Type u} [inst : AddGroup Œ±] [LE Œ±] [CovariantClass Œ± Œ± Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1 fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±} {b : Œ±} {Œ± : Type u} [AddGroup Œ±] [LE Œ±] [CovariantClass Œ± Œ± Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1 fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±} {b : Œ±}  : ((b ‚â§ a + - b + b) ‚Üî (b ‚â§ a)) = ((b ‚â§ a + - b + b) ‚Üî (b ‚â§ a))
application type mismatch
  CovariantClass Œ± Œ± Function.swap
argument
  Function.swap
has type
  ((x : ?m.19) ‚Üí (y : ?m.20) ‚Üí ?m.21 x y) ‚Üí
    (y : ?m.20) ‚Üí (x : ?m.19) ‚Üí ?m.21 x y : Sort (imax (imax ?u.18 ?u.17 ?u.16) ?u.17 ?u.18 ?u.16)
but is expected to have type
  Œ± ‚Üí Œ± ‚Üí Œ± : Type u ; identifiers [Œ±, u, inst, AddGroup, Œ±, LE, Œ±, CovariantClass, Œ±, Œ±, Function.swap, x, Œ±, x_1, Œ±, x, x_1, x, Œ±, x_1, Œ±, x, x_1, a, Œ±, b, Œ±, Œ±, u, AddGroup, Œ±, LE, Œ±, CovariantClass, Œ±, Œ±, Function.swap, x, Œ±, x_1, Œ±, x, x_1, x, Œ±, x_1, Œ±, x, x_1, a, Œ±, b, Œ±, b, a, b, b, b, a, b, a, b, b, b, a] (during elaboration)

{Œ± : Type u} [inst : AddGroup Œ±] [LE Œ±] [CovariantClass Œ± Œ± Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1 fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±} {b : Œ±} {Œ± : Type u} [AddGroup Œ±] [LE Œ±] [CovariantClass Œ± Œ± Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1 fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±} {b : Œ±}  : (b ‚â§ a) ‚Üî (b ‚â§ a)
application type mismatch
  CovariantClass Œ± Œ± Function.swap
argument
  Function.swap
has type
  ((x : ?m.19) ‚Üí (y : ?m.20) ‚Üí ?m.21 x y) ‚Üí
    (y : ?m.20) ‚Üí (x : ?m.19) ‚Üí ?m.21 x y : Sort (imax (imax ?u.18 ?u.17 ?u.16) ?u.17 ?u.18 ?u.16)
but is expected to have type
  Œ± ‚Üí Œ± ‚Üí Œ± : Type u ; identifiers [Œ±, u, inst, AddGroup, Œ±, LE, Œ±, CovariantClass, Œ±, Œ±, Function.swap, x, Œ±, x_1, Œ±, x, x_1, x, Œ±, x_1, Œ±, x, x_1, a, Œ±, b, Œ±, Œ±, u, AddGroup, Œ±, LE, Œ±, CovariantClass, Œ±, Œ±, Function.swap, x, Œ±, x_1, Œ±, x, x_1, x, Œ±, x_1, Œ±, x, x_1, a, Œ±, b, Œ±, b, a, b, a] (during elaboration)

 : (‚àÄ {m : (a : Type u_1) ‚Üí Type u_2} [inst : Monad m] {œÉ : Type u_1} [inst_1 : MonadCont m] [inst_2 : LawfulMonadCont m] , LawfulMonad StateT œÉ m)
application type mismatch
  @LawfulMonad StateT
argument
  StateT
has type
  Type ?u.46 ‚Üí (Type ?u.46 ‚Üí Type ?u.45) ‚Üí Type ?u.46 ‚Üí Type (max ?u.46 ?u.45) : Type (max (?u.45 + 1) (?u.46 + 1))
but is expected to have type
  Type ?u.44 ‚Üí Type ?u.43 : Type (max (?u.43 + 1) (?u.44 + 1)) ; identifiers [m, a, u_1, u_2, inst, Monad, m, œÉ, u_1, inst_1, MonadCont, m, inst_2, LawfulMonadCont, m, LawfulMonad, StateT, œÉ, m] (during elaboration)

 : ‚àÄ {m : (a : Type u_1) ‚Üí Type u_2} [inst : Monad m] {œÉ : Type u_1} [inst_1 : MonadCont m] [inst_2 : LawfulMonadCont m] , LawfulMonad StateT œÉ m
application type mismatch
  @LawfulMonad StateT
argument
  StateT
has type
  Type ?u.46 ‚Üí (Type ?u.46 ‚Üí Type ?u.45) ‚Üí Type ?u.46 ‚Üí Type (max ?u.46 ?u.45) : Type (max (?u.45 + 1) (?u.46 + 1))
but is expected to have type
  Type ?u.44 ‚Üí Type ?u.43 : Type (max (?u.43 + 1) (?u.44 + 1)) ; identifiers [m, a, u_1, u_2, inst, Monad, m, œÉ, u_1, inst_1, MonadCont, m, inst_2, LawfulMonadCont, m, LawfulMonad, StateT, œÉ, m] (during elaboration)

{N : Type u_1} {X : Type u_2} [TopologicalSpace X] {x : X} (f : ‚Üë GenLoop N X x) (g : (a : (a : N) ‚Üí ‚Üë unitInterval) ‚Üí X) (h : g = ‚Üë f)  : ‚Üë f = g
type mismatch
  unitInterval
has type
  Set ‚Ñù : Type
but is expected to have type
  Sort ?u.26 : Type ?u.26 ; identifiers [N, u_1, X, u_2, TopologicalSpace, X, x, X, f, GenLoop, N, X, x, g, a, a, N, unitInterval, X, h, g, f, f, g] (during elaboration)

{Œ± : Type u_1} [AddGroup Œ±] [Preorder Œ±] [DecidableRel fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] [CovariantClass Œ± Œ± fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1 fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] (a : Œ±)  : (a < 0) = (a < 0)
function expected at
  x_1
term has type
  Œ± ; identifiers [Œ±, u_1, AddGroup, Œ±, Preorder, Œ±, DecidableRel, x, Œ±, x_1, Œ±, x, x_1, CovariantClass, Œ±, Œ±, x, Œ±, x_1, Œ±, x, x_1, x, Œ±, x_1, Œ±, x, x_1, a, Œ±, a, a] (during elaboration)

{Œ± : Type u_1} [AddGroup Œ±] [Preorder Œ±] [DecidableRel fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] [CovariantClass Œ± Œ± fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1 fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] (a : Œ±) (a_1 : ¬¨ (a < 0 : Prop))  : ‚àÄ (a : 0 < a) , - 1 = - 1
function expected at
  x_1
term has type
  Œ± ; identifiers [Œ±, u_1, AddGroup, Œ±, Preorder, Œ±, DecidableRel, x, Œ±, x_1, Œ±, x, x_1, CovariantClass, Œ±, Œ±, x, Œ±, x_1, Œ±, x, x_1, x, Œ±, x_1, Œ±, x, x_1, a, Œ±, a_1, a, a, a] (during elaboration)

{Œ± : Type u_1} [AddGroup Œ±] [Preorder Œ±] [DecidableRel fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] [CovariantClass Œ± Œ± fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1 fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] (a : Œ±) (a_1 : ¬¨ (a < 0 : Prop))  : ‚àÄ (a : ¬¨ (0 < a)) , 0 = 0
function expected at
  x_1
term has type
  Œ± ; identifiers [Œ±, u_1, AddGroup, Œ±, Preorder, Œ±, DecidableRel, x, Œ±, x_1, Œ±, x, x_1, CovariantClass, Œ±, Œ±, x, Œ±, x_1, Œ±, x, x_1, x, Œ±, x_1, Œ±, x, x_1, a, Œ±, a_1, a, a, a] (during elaboration)

{R : Type u_1} [Rack R] (h : Rack.IsInvolutory R) (x : R) (y : R)  : Shelf.act x Shelf.act x y = y
application type mismatch
  Shelf.act x Shelf.act
argument
  Shelf.act
has type
  ?m.29 ‚Üí ?m.29 ‚Üí ?m.29 : Type ?u.28
but is expected to have type
  R : Type u_1 ; identifiers [R, u_1, Rack, R, h, Rack.IsInvolutory, R, x, R, y, R, Shelf.act, x, Shelf.act, x, y, y] (during elaboration)

{C : Type u‚ÇÅ} {inst : CategoryTheory.Category C} {X : C} {arrows : CategoryTheory.Presieve X} {downward_closed : ‚àÄ {Y : C} {Z : C} {f : Y ‚ü∂ X} (x : arrows f) (g : Z ‚ü∂ Y) , arrows CategoryTheory.CategoryStruct.comp g f} {arrows_1 : CategoryTheory.Presieve X} {downward_closed_1 : ‚àÄ {Y : C} {Z : C} {f : Y ‚ü∂ X} (x : arrows_1 f) (g : Z ‚ü∂ Y) , arrows_1 CategoryTheory.CategoryStruct.comp g f} (x : {arrows := ((arrows)) , downward_closed := ((downward_closed))} = {arrows := ((arrows_1)) , downward_closed := ((downward_closed_1))})  : ‚àÄ (arrows_eq : arrows = arrows_1) , arrows = arrows_1
application type mismatch
  arrows CategoryTheory.CategoryStruct.comp
argument
  CategoryTheory.CategoryStruct.comp
has type
  (?m.555 ‚ü∂ ?m.556) ‚Üí (?m.556 ‚ü∂ ?m.557) ‚Üí (?m.555 ‚ü∂ ?m.557) : Type ?u.552
but is expected to have type
  ?m.550 ‚ü∂ X : Type ?u.7 ; identifiers [C, u‚ÇÅ, inst, CategoryTheory.Category, C, X, C, arrows, CategoryTheory.Presieve, X, downward_closed, Y, C, Z, C, f, Y, X, x, arrows, f, g, Z, Y, arrows, CategoryTheory.CategoryStruct.comp, g, f, arrows_1, CategoryTheory.Presieve, X, downward_closed_1, Y, C, Z, C, f, Y, X, x, arrows_1, f, g, Z, Y, arrows_1, CategoryTheory.CategoryStruct.comp, g, f, x, arrows, arrows, downward_closed, downward_closed, arrows, arrows_1, downward_closed, downward_closed_1, arrows_eq, arrows, arrows_1, arrows, arrows_1] (during elaboration)

{R : Type u‚ÇÅ} [StrictOrderedSemiring R] {a : R} (h : 0 ‚â§ a) (ha : a ‚â§ 1) (i : ‚Ñï) (x : ‚Ñï) (x : ‚Ñï) (f : Nat.below x) (k : ‚Ñï) (x : Nat.below Nat.succ k)  : (a ^ i + k + 1 ‚â§ a ^ i) = (a ^ i + k + 1 ‚â§ a ^ i)
application type mismatch
  Nat.below Nat.succ
argument
  Nat.succ
has type
  ‚Ñï ‚Üí ‚Ñï : Type
but is expected to have type
  ‚Ñï : Type ; identifiers [R, u‚ÇÅ, StrictOrderedSemiring, R, a, R, h, a, ha, a, i, x, x, f, Nat.below, x, k, x, Nat.below, Nat.succ, k, a, i, k, a, i, a, i, k, a, i] (during elaboration)

 : (‚àÄ {F : (a : Type u) ‚Üí Type v} [inst : Applicative F] {G : (a : Type u) ‚Üí Type w} [inst_1 : Applicative G] [inst_2 : (a : Type u) ‚Üí SizeOf F a] [inst_3 : (a : Type u) ‚Üí SizeOf G a] (app : (Œ± : Type u) ‚Üí (a : F Œ±) ‚Üí G Œ±) (preserves_pure' : ‚àÄ {Œ± : Type u} (x : Œ±) , app Œ± pure x = pure x) (preserves_seq' : ‚àÄ {Œ± : Type u} {Œ≤ : Type u} (x : F (a : Œ±) ‚Üí Œ≤) (y : F Œ±) , app Œ≤ Seq.seq x fun (x : Unit) ‚Ü¶ y = Seq.seq app (a : Œ±) ‚Üí Œ≤ x fun (x : Unit) ‚Ü¶ app Œ± y) , sizeOf {app := ((app)) , preserves_pure' := ((preserves_pure')) , preserves_seq' := ((preserves_seq'))} = 1)
application type mismatch
  SizeOf F
argument
  F
has type
  Type u ‚Üí Type v : Type (max (u + 1) (v + 1))
but is expected to have type
  Sort ?u.30 : Type ?u.30 ; identifiers [F, a, u, v, inst, Applicative, F, G, a, u, w, inst_1, Applicative, G, inst_2, a, u, SizeOf, F, a, inst_3, a, u, SizeOf, G, a, app, Œ±, u, a, F, Œ±, G, Œ±, preserves_pure', Œ±, u, x, Œ±, app, Œ±, pure, x, pure, x, preserves_seq', Œ±, u, Œ≤, u, x, F, a, Œ±, Œ≤, y, F, Œ±, app, Œ≤, Seq.seq, x, x, Unit, y, Seq.seq, app, a, Œ±, Œ≤, x, x, Unit, app, Œ±, y, sizeOf, app, app, preserves_pure', preserves_pure', preserves_seq', preserves_seq'] (during elaboration)

 : ‚àÄ {F : (a : Type u) ‚Üí Type v} [inst : Applicative F] {G : (a : Type u) ‚Üí Type w} [inst_1 : Applicative G] [inst_2 : (a : Type u) ‚Üí SizeOf F a] [inst_3 : (a : Type u) ‚Üí SizeOf G a] (app : (Œ± : Type u) ‚Üí (a : F Œ±) ‚Üí G Œ±) (preserves_pure' : ‚àÄ {Œ± : Type u} (x : Œ±) , app Œ± pure x = pure x) (preserves_seq' : ‚àÄ {Œ± : Type u} {Œ≤ : Type u} (x : F (a : Œ±) ‚Üí Œ≤) (y : F Œ±) , app Œ≤ Seq.seq x fun (x : Unit) ‚Ü¶ y = Seq.seq app (a : Œ±) ‚Üí Œ≤ x fun (x : Unit) ‚Ü¶ app Œ± y) , 1 = 1
application type mismatch
  SizeOf F
argument
  F
has type
  Type u ‚Üí Type v : Type (max (u + 1) (v + 1))
but is expected to have type
  Sort ?u.30 : Type ?u.30 ; identifiers [F, a, u, v, inst, Applicative, F, G, a, u, w, inst_1, Applicative, G, inst_2, a, u, SizeOf, F, a, inst_3, a, u, SizeOf, G, a, app, Œ±, u, a, F, Œ±, G, Œ±, preserves_pure', Œ±, u, x, Œ±, app, Œ±, pure, x, pure, x, preserves_seq', Œ±, u, Œ≤, u, x, F, a, Œ±, Œ≤, y, F, Œ±, app, Œ≤, Seq.seq, x, x, Unit, y, Seq.seq, app, a, Œ±, Œ≤, x, x, Unit, app, Œ±, y] (during elaboration)

{R : Type u‚ÇÅ} [StrictOrderedSemiring R] {a : R} (h : 0 ‚â§ a) (ha : a ‚â§ 1) (i : ‚Ñï) (x : ‚Ñï) (x : ‚Ñï) (f : Nat.below x) (k : ‚Ñï) (x : Nat.below Nat.succ k)  : (a ^ i + k + 1 ‚â§ a ^ i) = (a ^ i + k + 1 ‚â§ a ^ i)
application type mismatch
  Nat.below Nat.succ
argument
  Nat.succ
has type
  ‚Ñï ‚Üí ‚Ñï : Type
but is expected to have type
  ‚Ñï : Type ; identifiers [R, u‚ÇÅ, StrictOrderedSemiring, R, a, R, h, a, ha, a, i, x, x, f, Nat.below, x, k, x, Nat.below, Nat.succ, k, a, i, k, a, i, a, i, k, a, i] (during elaboration)

{R : Type u_1} {M : Type u_2} [Semiring R] [AddCommMonoid M] [Module R M] {p : Submodule R M}  : ‚àÄ (h : ‚àÄ (x : M) , x ‚àà p) (x : M) (x_1 : x ‚àà ‚ä§) , x ‚àà p
typeclass instance problem is stuck, it is often due to metavariables
  Membership M (?m.681 h x) ; identifiers [R, u_1, M, u_2, Semiring, R, AddCommMonoid, M, Module, R, M, p, Submodule, R, M, h, x, M, x, p, x, M, x_1, x, x, p] (during elaboration)

{R : Type u‚ÇÅ} [StrictOrderedSemiring R] {a : R} (h : 0 ‚â§ a) (ha : a ‚â§ 1) (i : ‚Ñï) (x : ‚Ñï) (x : ‚Ñï) (f : Nat.below x) (k : ‚Ñï) (x : Nat.below Nat.succ k)  : (a ^ i + k + 1 ‚â§ 1 * a ^ i) = (a ^ i + k + 1 ‚â§ 1 * a ^ i)
application type mismatch
  Nat.below Nat.succ
argument
  Nat.succ
has type
  ‚Ñï ‚Üí ‚Ñï : Type
but is expected to have type
  ‚Ñï : Type ; identifiers [R, u‚ÇÅ, StrictOrderedSemiring, R, a, R, h, a, ha, a, i, x, x, f, Nat.below, x, k, x, Nat.below, Nat.succ, k, a, i, k, a, i, a, i, k, a, i] (during elaboration)

(Œ± : Type) (C : Set Set Œ±) (C' : Set Set Œ±) (e'_2 : C = C') (h : C' = C) (C' : Set Set Œ±)  : C = C
application type mismatch
  Set Set
argument
  Set
has type
  Type ?u.7 ‚Üí Type ?u.7 : Type (?u.7 + 1)
but is expected to have type
  Type ?u.6 : Type (?u.6 + 1) ; identifiers [Œ±, C, Set, Set, Œ±, C', Set, Set, Œ±, e'_2, C, C', h, C', C, C', Set, Set, Œ±, C, C] (during elaboration)

{Œ± : Type u_1} [AddGroup Œ±] [Preorder Œ±] [DecidableRel fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] [CovariantClass Œ± Œ± fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1 fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] (a : Œ±)  : (0 < a) = (0 < a)
function expected at
  x_1
term has type
  Œ± ; identifiers [Œ±, u_1, AddGroup, Œ±, Preorder, Œ±, DecidableRel, x, Œ±, x_1, Œ±, x, x_1, CovariantClass, Œ±, Œ±, x, Œ±, x_1, Œ±, x, x_1, x, Œ±, x_1, Œ±, x, x_1, a, Œ±, a, a] (during elaboration)

{Œ± : Type u_1} [AddGroup Œ±] [Preorder Œ±] [DecidableRel fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] [CovariantClass Œ± Œ± fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1 fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] (a : Œ±)  : ‚àÄ (a : 0 < a) , 1 = 1
function expected at
  x_1
term has type
  Œ± ; identifiers [Œ±, u_1, AddGroup, Œ±, Preorder, Œ±, DecidableRel, x, Œ±, x_1, Œ±, x, x_1, CovariantClass, Œ±, Œ±, x, Œ±, x_1, Œ±, x, x_1, x, Œ±, x_1, Œ±, x, x_1, a, Œ±, a, a] (during elaboration)

(Œ± : Type) (C : Set Set Œ±) (C' : Set Set Œ±) (e'_2 : C = C') (h : C' = C)  : C = C'
application type mismatch
  Set Set
argument
  Set
has type
  Type ?u.7 ‚Üí Type ?u.7 : Type (?u.7 + 1)
but is expected to have type
  Type ?u.6 : Type (?u.6 + 1) ; identifiers [Œ±, C, Set, Set, Œ±, C', Set, Set, Œ±, e'_2, C, C', h, C', C, C, C'] (during elaboration)

(Œ± : Type) (C : Set Set Œ±) (C' : Set Set Œ±) (e'_2 : C = C')  : C' = C'
application type mismatch
  Set Set
argument
  Set
has type
  Type ?u.7 ‚Üí Type ?u.7 : Type (?u.7 + 1)
but is expected to have type
  Type ?u.6 : Type (?u.6 + 1) ; identifiers [Œ±, C, Set, Set, Œ±, C', Set, Set, Œ±, e'_2, C, C', C', C'] (during elaboration)

{Œ± : Type u_1} [LinearOrderedRing Œ±] [FloorRing Œ±] (a : Œ±) (ha : Int.fract a ‚â† 0) (h : (eq_or_ne Int.fract a 0 =: (Int.fract a = 0 : Prop) ‚à® (Int.fract a ‚â† 0 : Prop)) = (Or.inr ha =: (Int.fract a = 0 : Prop) ‚à® (Int.fract a ‚â† 0 : Prop))) (this : ‚Üë ‚åà a ‚åâ = ‚Üë ‚åä a ‚åã + 1)  : a = Mathlib.Tactic.Abel.termg 1 a 0
<input>:1:112: expected term

{Œ± : Type u_1} [LinearOrderedRing Œ±] [FloorRing Œ±] (a : Œ±) (ha : Int.fract a ‚â† 0) (h : (eq_or_ne Int.fract a 0 =: (Int.fract a = 0 : Prop) ‚à® (Int.fract a ‚â† 0 : Prop)) = (Or.inr ha =: (Int.fract a = 0 : Prop) ‚à® (Int.fract a ‚â† 0 : Prop))) (this : ‚Üë ‚åà a ‚åâ = ‚Üë ‚åä a ‚åã + 1)  : 1 = Mathlib.Tactic.Abel.termg 1 1 0
<input>:1:112: expected term

{Œ± : Type u_2} {Œ≤ : Type u_1} [One Œ≤] {l : Filter Œ±} {f : (a : Œ±) ‚Üí Œ≤} (hf : ‚àÄ·∂† (x : Œ±) in l , f x ‚â† 1) {s : Set Œ±} {t : Set Œ±} (h : Set.mulIndicator s f =·∂†[l] Set.mulIndicator t f) (this : ‚àÄ {s : Set Œ±} , Function.mulSupport Set.mulIndicator s f =·∂†[l] s)  : Function.mulSupport Set.mulIndicator s f =·∂†[l] s
function expected at
  Function.mulSupport Set.mulIndicator s
term has type
  Prop ; identifiers [Œ±, u_2, Œ≤, u_1, One, Œ≤, l, Filter, Œ±, f, a, Œ±, Œ≤, hf, x, Œ±, l, f, x, s, Set, Œ±, t, Set, Œ±, h, Set.mulIndicator, s, f, l, Set.mulIndicator, t, f, this, s, Set, Œ±, Function.mulSupport, Set.mulIndicator, s, f, l, s, Function.mulSupport, Set.mulIndicator, s, f, l, s] (during elaboration)

{Œ± : Type u_2} {Œ≤ : Type u_1} [One Œ≤] {l : Filter Œ±} {f : (a : Œ±) ‚Üí Œ≤} (hf : ‚àÄ·∂† (x : Œ±) in l , f x ‚â† 1) {s : Set Œ±} {t : Set Œ±} (h : Set.mulIndicator s f =·∂†[l] Set.mulIndicator t f) (this : ‚àÄ {s : Set Œ±} , Function.mulSupport Set.mulIndicator s f =·∂†[l] s)  : Function.mulSupport Set.mulIndicator t f =·∂†[l] t
function expected at
  Function.mulSupport Set.mulIndicator s
term has type
  Prop ; identifiers [Œ±, u_2, Œ≤, u_1, One, Œ≤, l, Filter, Œ±, f, a, Œ±, Œ≤, hf, x, Œ±, l, f, x, s, Set, Œ±, t, Set, Œ±, h, Set.mulIndicator, s, f, l, Set.mulIndicator, t, f, this, s, Set, Œ±, Function.mulSupport, Set.mulIndicator, s, f, l, s, Function.mulSupport, Set.mulIndicator, t, f, l, t] (during elaboration)

{Œ± : Type u_2} {n : ‚Ñï} {C : (a : Vector3 Œ± Nat.succ n) ‚Üí Sort u_1} (v : Vector3 Œ± Nat.succ n)  : C v = C v
application type mismatch
  Vector3 Œ± Nat.succ
argument
  Nat.succ
has type
  ‚Ñï ‚Üí ‚Ñï : Type
but is expected to have type
  ‚Ñï : Type ; identifiers [Œ±, u_2, n, C, a, Vector3, Œ±, Nat.succ, n, u_1, v, Vector3, Œ±, Nat.succ, n, C, v, C, v] (during elaboration)

(ùïú : Type u_1) {E : Type u_2} [IsROrC ùïú] [NormedAddCommGroup E] [InnerProductSpace ùïú E] {x : E} {y : E} (h : ‚àÄ (v : E) , inner x v = inner y v)  : (x = y) = (x = y)
typeclass instance problem is stuck, it is often due to metavariables
  Inner (?m.145 ùïú v) E ; identifiers [ùïú, u_1, E, u_2, IsROrC, ùïú, NormedAddCommGroup, E, InnerProductSpace, ùïú, E, x, E, y, E, h, v, E, inner, x, v, inner, y, v, x, y, x, y] (during elaboration)

(ùïú : Type u_1) {E : Type u_2} [IsROrC ùïú] [NormedAddCommGroup E] [InnerProductSpace ùïú E] {x : E} {y : E} (h : ‚àÄ (v : E) , inner x v = inner y v)  : (x - y = 0) = (x - y = 0)
typeclass instance problem is stuck, it is often due to metavariables
  Inner (?m.1399 ùïú v) E ; identifiers [ùïú, u_1, E, u_2, IsROrC, ùïú, NormedAddCommGroup, E, InnerProductSpace, ùïú, E, x, E, y, E, h, v, E, inner, x, v, inner, y, v, x, y, x, y] (during elaboration)

{Œ± : Type u_1} [LinearOrderedRing Œ±] [FloorRing Œ±] (a : Œ±) (ha : Int.fract a ‚â† 0) (h : (eq_or_ne Int.fract a 0 =: (Int.fract a = 0 : Prop) ‚à® (Int.fract a ‚â† 0 : Prop)) = (Or.inr ha =: (Int.fract a = 0 : Prop) ‚à® (Int.fract a ‚â† 0 : Prop))) (this : ‚Üë ‚åà a ‚åâ = ‚Üë ‚åä a ‚åã + 1)  : - 1 = - 1
<input>:1:112: expected term

{Œ± : Type u_1} [LinearOrderedRing Œ±] [FloorRing Œ±] (a : Œ±) (ha : Int.fract a ‚â† 0) (h : (eq_or_ne Int.fract a 0 =: (Int.fract a = 0 : Prop) ‚à® (Int.fract a ‚â† 0 : Prop)) = (Or.inr ha =: (Int.fract a = 0 : Prop) ‚à® (Int.fract a ‚â† 0 : Prop))) (this : ‚Üë ‚åà a ‚åâ = ‚Üë ‚åä a ‚åã + 1)  : 1 = 1
<input>:1:112: expected term

 : (‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : NormedSpace ùïú E] [inst_3 : CompleteSpace E] {F : Type u_3} [inst_4 : NormedAddCommGroup F] [inst_5 : NormedSpace ùïú F] [inst_6 : CompleteSpace F] {G : Type u_4} [inst_7 : NormedAddCommGroup G] [inst_8 : NormedSpace ùïú G] [inst_9 : CompleteSpace G] (self : ImplicitFunctionData ùïú E F G) , HasStrictFDerivAt ImplicitFunctionData.leftFun self ImplicitFunctionData.leftDeriv self ImplicitFunctionData.pt self)
application type mismatch
  HasStrictFDerivAt ImplicitFunctionData.leftFun self
argument
  self
has type
  ImplicitFunctionData ùïú E F G : Type (max (max u_2 u_3) u_4)
but is expected to have type
  ImplicitFunctionData ?m.1134 ?m.1136 ?m.1140 ?m.1144 ‚ÜíL[?m.1122]
    ?m.1136 ‚Üí ?m.1140 : Type (max (max (max ?u.1130 ?u.1131) ?u.1132) ?u.1131 ?u.1132) ; identifiers [ùïú, u_1, inst, NontriviallyNormedField, ùïú, E, u_2, inst_1, NormedAddCommGroup, E, inst_2, NormedSpace, ùïú, E, inst_3, CompleteSpace, E, F, u_3, inst_4, NormedAddCommGroup, F, inst_5, NormedSpace, ùïú, F, inst_6, CompleteSpace, F, G, u_4, inst_7, NormedAddCommGroup, G, inst_8, NormedSpace, ùïú, G, inst_9, CompleteSpace, G, self, ImplicitFunctionData, ùïú, E, F, G, HasStrictFDerivAt, ImplicitFunctionData.leftFun, self, ImplicitFunctionData.leftDeriv, self, ImplicitFunctionData.pt, self] (during elaboration)

 : ‚àÄ (ùïú : Type u_1) [inst : NontriviallyNormedField ùïú] (E : Type u_2) [inst_1 : NormedAddCommGroup E] [inst_2 : NormedSpace ùïú E] [inst_3 : CompleteSpace E] (F : Type u_3) [inst_4 : NormedAddCommGroup F] [inst_5 : NormedSpace ùïú F] [inst_6 : CompleteSpace F] (G : Type u_4) [inst_7 : NormedAddCommGroup G] [inst_8 : NormedSpace ùïú G] [inst_9 : CompleteSpace G] (self : ImplicitFunctionData ùïú E F G) , HasStrictFDerivAt self . 1 self . 2 self . 5
invalid occurrence of `¬∑` notation, it must be surrounded by parentheses (e.g. `(¬∑ + 1)`) ; identifiers [ùïú, u_1, inst, NontriviallyNormedField, ùïú, E, u_2, inst_1, NormedAddCommGroup, E, inst_2, NormedSpace, ùïú, E, inst_3, CompleteSpace, E, F, u_3, inst_4, NormedAddCommGroup, F, inst_5, NormedSpace, ùïú, F, inst_6, CompleteSpace, F, G, u_4, inst_7, NormedAddCommGroup, G, inst_8, NormedSpace, ùïú, G, inst_9, CompleteSpace, G, self, ImplicitFunctionData, ùïú, E, F, G, HasStrictFDerivAt, self, self, self] (during elaboration)

{K : Type u_1} {n : ‚Ñï} {s : Stream'.Seq GeneralizedContinuedFraction.Pair K} [DivisionRing K] (terminated_at_succ_n : Stream'.Seq.TerminatedAt s n + 1) (terminated_at_succ_n : Stream'.Seq.get? s n + 1 = none) (h : Stream'.Seq.get? s n = none)  : none = Stream'.Seq.get? s n
application type mismatch
  Stream'.Seq GeneralizedContinuedFraction.Pair
argument
  GeneralizedContinuedFraction.Pair
has type
  Type ?u.10 ‚Üí Type ?u.10 : Type (?u.10 + 1)
but is expected to have type
  Type ?u.9 : Type (?u.9 + 1) ; identifiers [K, u_1, n, s, Stream'.Seq, GeneralizedContinuedFraction.Pair, K, DivisionRing, K, terminated_at_succ_n, Stream'.Seq.TerminatedAt, s, n, terminated_at_succ_n, Stream'.Seq.get?, s, n, none, h, Stream'.Seq.get?, s, n, none, none, Stream'.Seq.get?, s, n] (during elaboration)

{Œ± : Type u_1} {Œ≤ : Type u_2} [TopologicalSpace Œ±] [TopologicalSpace Œ≤] (toLocalEquiv : LocalEquiv Œ± Œ≤) (open_source : IsOpen LocalEquiv.source toLocalEquiv) (open_target : IsOpen LocalEquiv.target toLocalEquiv) (continuous_toFun : ContinuousOn ‚Üë toLocalEquiv LocalEquiv.source toLocalEquiv) (continuous_invFun : ContinuousOn LocalEquiv.invFun toLocalEquiv LocalEquiv.target toLocalEquiv) (toLocalEquiv_1 : LocalEquiv Œ± Œ≤) (open_source_1 : IsOpen LocalEquiv.source toLocalEquiv_1) (open_target_1 : IsOpen LocalEquiv.target toLocalEquiv_1) (continuous_toFun_1 : ContinuousOn ‚Üë toLocalEquiv_1 LocalEquiv.source toLocalEquiv_1) (continuous_invFun_1 : ContinuousOn LocalEquiv.invFun toLocalEquiv_1 LocalEquiv.target toLocalEquiv_1) (a : {toLocalEquiv := ((toLocalEquiv)) , open_source := ((open_source)) , open_target := ((open_target)) , continuous_toFun := ((continuous_toFun)) , continuous_invFun := ((continuous_invFun))} = {toLocalEquiv := ((toLocalEquiv_1)) , open_source := ((open_source_1)) , open_target := ((open_target_1)) , continuous_toFun := ((continuous_toFun_1)) , continuous_invFun := ((continuous_invFun_1))})  : ‚àÄ (toLocalEquiv_eq : toLocalEquiv = toLocalEquiv_1) , toLocalEquiv = toLocalEquiv_1
function expected at
  IsOpen ?m.210
term has type
  Prop ; identifiers [Œ±, u_1, Œ≤, u_2, TopologicalSpace, Œ±, TopologicalSpace, Œ≤, toLocalEquiv, LocalEquiv, Œ±, Œ≤, open_source, IsOpen, LocalEquiv.source, toLocalEquiv, open_target, IsOpen, LocalEquiv.target, toLocalEquiv, continuous_toFun, ContinuousOn, toLocalEquiv, LocalEquiv.source, toLocalEquiv, continuous_invFun, ContinuousOn, LocalEquiv.invFun, toLocalEquiv, LocalEquiv.target, toLocalEquiv, toLocalEquiv_1, LocalEquiv, Œ±, Œ≤, open_source_1, IsOpen, LocalEquiv.source, toLocalEquiv_1, open_target_1, IsOpen, LocalEquiv.target, toLocalEquiv_1, continuous_toFun_1, ContinuousOn, toLocalEquiv_1, LocalEquiv.source, toLocalEquiv_1, continuous_invFun_1, ContinuousOn, LocalEquiv.invFun, toLocalEquiv_1, LocalEquiv.target, toLocalEquiv_1, a, toLocalEquiv, toLocalEquiv, open_source, open_source, open_target, open_target, continuous_toFun, continuous_toFun, continuous_invFun, continuous_invFun, toLocalEquiv, toLocalEquiv_1, open_source, open_source_1, open_target, open_target_1, continuous_toFun, continuous_toFun_1, continuous_invFun, continuous_invFun_1, toLocalEquiv_eq, toLocalEquiv, toLocalEquiv_1, toLocalEquiv, toLocalEquiv_1] (during elaboration)

{Œ± : Type u_1} {Œ≤ : Type u_2} [TopologicalSpace Œ±] [TopologicalSpace Œ≤] (toLocalEquiv : LocalEquiv Œ± Œ≤) (open_source : IsOpen LocalEquiv.source toLocalEquiv) (open_target : IsOpen LocalEquiv.target toLocalEquiv) (continuous_toFun : ContinuousOn ‚Üë toLocalEquiv LocalEquiv.source toLocalEquiv) (continuous_invFun : ContinuousOn LocalEquiv.invFun toLocalEquiv LocalEquiv.target toLocalEquiv) (toLocalEquiv_1 : LocalEquiv Œ± Œ≤) (open_source_1 : IsOpen LocalEquiv.source toLocalEquiv_1) (open_target_1 : IsOpen LocalEquiv.target toLocalEquiv_1) (continuous_toFun_1 : ContinuousOn ‚Üë toLocalEquiv_1 LocalEquiv.source toLocalEquiv_1) (continuous_invFun_1 : ContinuousOn LocalEquiv.invFun toLocalEquiv_1 LocalEquiv.target toLocalEquiv_1) (a : toLocalEquiv = toLocalEquiv_1) (h : toLocalEquiv_1 = toLocalEquiv) (toLocalEquiv_2 : LocalEquiv Œ± Œ≤)  : toLocalEquiv = toLocalEquiv
function expected at
  IsOpen ?m.210
term has type
  Prop ; identifiers [Œ±, u_1, Œ≤, u_2, TopologicalSpace, Œ±, TopologicalSpace, Œ≤, toLocalEquiv, LocalEquiv, Œ±, Œ≤, open_source, IsOpen, LocalEquiv.source, toLocalEquiv, open_target, IsOpen, LocalEquiv.target, toLocalEquiv, continuous_toFun, ContinuousOn, toLocalEquiv, LocalEquiv.source, toLocalEquiv, continuous_invFun, ContinuousOn, LocalEquiv.invFun, toLocalEquiv, LocalEquiv.target, toLocalEquiv, toLocalEquiv_1, LocalEquiv, Œ±, Œ≤, open_source_1, IsOpen, LocalEquiv.source, toLocalEquiv_1, open_target_1, IsOpen, LocalEquiv.target, toLocalEquiv_1, continuous_toFun_1, ContinuousOn, toLocalEquiv_1, LocalEquiv.source, toLocalEquiv_1, continuous_invFun_1, ContinuousOn, LocalEquiv.invFun, toLocalEquiv_1, LocalEquiv.target, toLocalEquiv_1, a, toLocalEquiv, toLocalEquiv_1, h, toLocalEquiv_1, toLocalEquiv, toLocalEquiv_2, LocalEquiv, Œ±, Œ≤, toLocalEquiv, toLocalEquiv] (during elaboration)

{Œ± : Type u_1} [LinearOrderedRing Œ±] [FloorRing Œ±] (a : Œ±) (ha : Int.fract a ‚â† 0) (h : (eq_or_ne Int.fract a 0 =: (Int.fract a = 0 : Prop) ‚à® (Int.fract a ‚â† 0 : Prop)) = (Or.inr ha =: (Int.fract a = 0 : Prop) ‚à® (Int.fract a ‚â† 0 : Prop))) (this : ‚Üë ‚åà a ‚åâ = ‚Üë ‚åä a ‚åã + 1)  : 0 = 0
<input>:1:112: expected term

{H : Type u_1} [TopologicalSpace H] (u : StructureGroupoid H) ‚¶É f : LocalHomeomorph H H ‚¶Ñ (hf : f ‚àà StructureGroupoid.members ‚ä•) hf : f ‚àà {LocalHomeomorph.refl H} ‚à™ {e : LocalHomeomorph H H | LocalEquiv.source LocalHomeomorph.toLocalEquiv e = ‚àÖ} := hf (hf_1 : f = LocalHomeomorph.refl H) (h : (Eq.mp (Mathlib.Geometry.Manifold.ChartedSpace._auxLemma.1 =: (f ‚àà insert LocalHomeomorph.refl H {e : LocalHomeomorph H H | LocalEquiv.source LocalHomeomorph.toLocalEquiv e = ‚àÖ} : Prop) = ((f = LocalHomeomorph.refl H : Prop) ‚à® (f ‚àà {e : LocalHomeomorph H H | LocalEquiv.source LocalHomeomorph.toLocalEquiv e = ‚àÖ} : Prop) : Prop)) hf =: (f = LocalHomeomorph.refl H : Prop) ‚à® (f ‚àà {e : LocalHomeomorph H H | LocalEquiv.source LocalHomeomorph.toLocalEquiv e = ‚àÖ} : Prop)) = (Or.inl hf_1 =: (f = LocalHomeomorph.refl H : Prop) ‚à® (LocalEquiv.source LocalHomeomorph.toLocalEquiv f = ‚àÖ : Prop)))  : (Or.inl hf_1) = (Eq.mp Mathlib.Geometry.Manifold.ChartedSpace._auxLemma.1 hf)
<input>:1:129: expected '/--' or ':'

{Œ± : Type u_1} {Œ≤ : Type u_2} [TopologicalSpace Œ±] [TopologicalSpace Œ≤] (toLocalEquiv : LocalEquiv Œ± Œ≤) (open_source : IsOpen LocalEquiv.source toLocalEquiv) (open_target : IsOpen LocalEquiv.target toLocalEquiv) (continuous_toFun : ContinuousOn ‚Üë toLocalEquiv LocalEquiv.source toLocalEquiv) (continuous_invFun : ContinuousOn LocalEquiv.invFun toLocalEquiv LocalEquiv.target toLocalEquiv) (toLocalEquiv_1 : LocalEquiv Œ± Œ≤) (open_source_1 : IsOpen LocalEquiv.source toLocalEquiv_1) (open_target_1 : IsOpen LocalEquiv.target toLocalEquiv_1) (continuous_toFun_1 : ContinuousOn ‚Üë toLocalEquiv_1 LocalEquiv.source toLocalEquiv_1) (continuous_invFun_1 : ContinuousOn LocalEquiv.invFun toLocalEquiv_1 LocalEquiv.target toLocalEquiv_1) (a : toLocalEquiv = toLocalEquiv_1) (h : toLocalEquiv_1 = toLocalEquiv) (open_source_2 : IsOpen LocalEquiv.source toLocalEquiv) (open_target_2 : IsOpen LocalEquiv.target toLocalEquiv) (continuous_toFun_2 : ContinuousOn ‚Üë toLocalEquiv LocalEquiv.source toLocalEquiv) (continuous_invFun_2 : ContinuousOn LocalEquiv.invFun toLocalEquiv LocalEquiv.target toLocalEquiv) (a : toLocalEquiv = toLocalEquiv) (h : HEq a (Eq.refl toLocalEquiv =: toLocalEquiv = toLocalEquiv))  : {toLocalEquiv := ((toLocalEquiv)) , open_source := ((open_source)) , open_target := ((open_target)) , continuous_toFun := ((continuous_toFun)) , continuous_invFun := ((continuous_invFun))} = {toLocalEquiv := ((toLocalEquiv)) , open_source := ((open_source)) , open_target := ((open_target)) , continuous_toFun := ((continuous_toFun)) , continuous_invFun := ((continuous_invFun))}
<input>:1:1161: expected term

{Œ± : Type u_1} {Œ≤ : Type u_2} [TopologicalSpace Œ±] [TopologicalSpace Œ≤] (toLocalEquiv : LocalEquiv Œ± Œ≤) (open_source : IsOpen LocalEquiv.source toLocalEquiv) (open_target : IsOpen LocalEquiv.target toLocalEquiv) (continuous_toFun : ContinuousOn ‚Üë toLocalEquiv LocalEquiv.source toLocalEquiv) (continuous_invFun : ContinuousOn LocalEquiv.invFun toLocalEquiv LocalEquiv.target toLocalEquiv) (toLocalEquiv_1 : LocalEquiv Œ± Œ≤) (open_source_1 : IsOpen LocalEquiv.source toLocalEquiv_1) (open_target_1 : IsOpen LocalEquiv.target toLocalEquiv_1) (continuous_toFun_1 : ContinuousOn ‚Üë toLocalEquiv_1 LocalEquiv.source toLocalEquiv_1) (continuous_invFun_1 : ContinuousOn LocalEquiv.invFun toLocalEquiv_1 LocalEquiv.target toLocalEquiv_1) (a : toLocalEquiv = toLocalEquiv_1) (h : toLocalEquiv_1 = toLocalEquiv)  : toLocalEquiv = toLocalEquiv_1
function expected at
  IsOpen ?m.210
term has type
  Prop ; identifiers [Œ±, u_1, Œ≤, u_2, TopologicalSpace, Œ±, TopologicalSpace, Œ≤, toLocalEquiv, LocalEquiv, Œ±, Œ≤, open_source, IsOpen, LocalEquiv.source, toLocalEquiv, open_target, IsOpen, LocalEquiv.target, toLocalEquiv, continuous_toFun, ContinuousOn, toLocalEquiv, LocalEquiv.source, toLocalEquiv, continuous_invFun, ContinuousOn, LocalEquiv.invFun, toLocalEquiv, LocalEquiv.target, toLocalEquiv, toLocalEquiv_1, LocalEquiv, Œ±, Œ≤, open_source_1, IsOpen, LocalEquiv.source, toLocalEquiv_1, open_target_1, IsOpen, LocalEquiv.target, toLocalEquiv_1, continuous_toFun_1, ContinuousOn, toLocalEquiv_1, LocalEquiv.source, toLocalEquiv_1, continuous_invFun_1, ContinuousOn, LocalEquiv.invFun, toLocalEquiv_1, LocalEquiv.target, toLocalEquiv_1, a, toLocalEquiv, toLocalEquiv_1, h, toLocalEquiv_1, toLocalEquiv, toLocalEquiv, toLocalEquiv_1] (during elaboration)

{Œ± : Type u_1} {Œ≤ : Type u_2} [TopologicalSpace Œ±] [TopologicalSpace Œ≤] (toLocalEquiv : LocalEquiv Œ± Œ≤) (open_source : IsOpen LocalEquiv.source toLocalEquiv) (open_target : IsOpen LocalEquiv.target toLocalEquiv) (continuous_toFun : ContinuousOn ‚Üë toLocalEquiv LocalEquiv.source toLocalEquiv) (continuous_invFun : ContinuousOn LocalEquiv.invFun toLocalEquiv LocalEquiv.target toLocalEquiv) (toLocalEquiv_1 : LocalEquiv Œ± Œ≤) (open_source_1 : IsOpen LocalEquiv.source toLocalEquiv_1) (open_target_1 : IsOpen LocalEquiv.target toLocalEquiv_1) (continuous_toFun_1 : ContinuousOn ‚Üë toLocalEquiv_1 LocalEquiv.source toLocalEquiv_1) (continuous_invFun_1 : ContinuousOn LocalEquiv.invFun toLocalEquiv_1 LocalEquiv.target toLocalEquiv_1) (a : toLocalEquiv = toLocalEquiv_1)  : toLocalEquiv_1 = toLocalEquiv_1
function expected at
  IsOpen ?m.210
term has type
  Prop ; identifiers [Œ±, u_1, Œ≤, u_2, TopologicalSpace, Œ±, TopologicalSpace, Œ≤, toLocalEquiv, LocalEquiv, Œ±, Œ≤, open_source, IsOpen, LocalEquiv.source, toLocalEquiv, open_target, IsOpen, LocalEquiv.target, toLocalEquiv, continuous_toFun, ContinuousOn, toLocalEquiv, LocalEquiv.source, toLocalEquiv, continuous_invFun, ContinuousOn, LocalEquiv.invFun, toLocalEquiv, LocalEquiv.target, toLocalEquiv, toLocalEquiv_1, LocalEquiv, Œ±, Œ≤, open_source_1, IsOpen, LocalEquiv.source, toLocalEquiv_1, open_target_1, IsOpen, LocalEquiv.target, toLocalEquiv_1, continuous_toFun_1, ContinuousOn, toLocalEquiv_1, LocalEquiv.source, toLocalEquiv_1, continuous_invFun_1, ContinuousOn, LocalEquiv.invFun, toLocalEquiv_1, LocalEquiv.target, toLocalEquiv_1, a, toLocalEquiv, toLocalEquiv_1, toLocalEquiv_1, toLocalEquiv_1] (during elaboration)

{Œ± : Type u_1} [LinearOrderedRing Œ±] [FloorRing Œ±] (a : Œ±) (ha : Int.fract a ‚â† 0) (h : (eq_or_ne Int.fract a 0 =: (Int.fract a = 0 : Prop) ‚à® (Int.fract a ‚â† 0 : Prop)) = (Or.inr ha =: (Int.fract a = 0 : Prop) ‚à® (Int.fract a ‚â† 0 : Prop))) (this : ‚Üë ‚åà a ‚åâ = ‚Üë ‚åä a ‚åã + 1)  : Mathlib.Tactic.Abel.termg 0 1 0 = 0
<input>:1:112: expected term

{Œ± : Type u_1} [LinearOrderedRing Œ±] [FloorRing Œ±] (a : Œ±) (ha : Int.fract a ‚â† 0) (h : (eq_or_ne Int.fract a 0 =: (Int.fract a = 0 : Prop) ‚à® (Int.fract a ‚â† 0 : Prop)) = (Or.inr ha =: (Int.fract a = 0 : Prop) ‚à® (Int.fract a ‚â† 0 : Prop))) (this : ‚Üë ‚åà a ‚åâ = ‚Üë ‚åä a ‚åã + 1)  : Mathlib.Tactic.Abel.termg 0 a 0 = 0
<input>:1:112: expected term

 : (‚àÄ {R : Type u_1} [inst : Add R] [inst_1 : Mul R] {s : Setoid R} {ha : ‚àÄ {w : R} {x : R} {y : R} {z : R} (a : Setoid.r w x) (a : Setoid.r y z) , Setoid.r w + y x + z} {hm : ‚àÄ {w : R} {x : R} {y : R} {z : R} (a : Setoid.r w x) (a : Setoid.r y z) , Setoid.r w * y x * z} {a : R} {b : R} , (‚Üë {toSetoid := ((s)) , add' := ((ha)) , mul' := ((hm))} a b) ‚Üî (Setoid.r a b))
function expected at
  y
term has type
  R ; identifiers [R, u_1, inst, Add, R, inst_1, Mul, R, s, Setoid, R, ha, w, R, x, R, y, R, z, R, a, Setoid.r, w, x, a, Setoid.r, y, z, Setoid.r, w, y, x, z, hm, w, R, x, R, y, R, z, R, a, Setoid.r, w, x, a, Setoid.r, y, z, Setoid.r, w, y, x, z, a, R, b, R, toSetoid, s, add', ha, mul', hm, a, b, Setoid.r, a, b] (during elaboration)

 : ‚àÄ {R : Type u_1} [inst : Add R] [inst_1 : Mul R] {s : Setoid R} {ha : ‚àÄ {w : R} {x : R} {y : R} {z : R} (a : Setoid.r w x) (a : Setoid.r y z) , Setoid.r w + y x + z} {hm : ‚àÄ {w : R} {x : R} {y : R} {z : R} (a : Setoid.r w x) (a : Setoid.r y z) , Setoid.r w * y x * z} {a : R} {b : R} , (‚Üë {toSetoid := ((s)) , add' := ((ha)) , mul' := ((hm))} a b) ‚Üî (‚Üë {toSetoid := ((s)) , add' := ((ha)) , mul' := ((hm))} a b)
function expected at
  y
term has type
  R ; identifiers [R, u_1, inst, Add, R, inst_1, Mul, R, s, Setoid, R, ha, w, R, x, R, y, R, z, R, a, Setoid.r, w, x, a, Setoid.r, y, z, Setoid.r, w, y, x, z, hm, w, R, x, R, y, R, z, R, a, Setoid.r, w, x, a, Setoid.r, y, z, Setoid.r, w, y, x, z, a, R, b, R, toSetoid, s, add', ha, mul', hm, a, b, toSetoid, s, add', ha, mul', hm, a, b] (during elaboration)

{G : Type u_1} [Group G] {H : Subgroup G} [Finite G ‚ß∏ H] (val : Fintype G ‚ß∏ H) (h : (nonempty_fintype G ‚ß∏ H =: Nonempty Fintype G ‚ß∏ H) = (Nonempty.intro val =: Nonempty Fintype G ‚ß∏ H))  : (Nonempty.intro val) = (nonempty_fintype G ‚ß∏ H)
<input>:1:109: expected term

{H : Type u_1} [TopologicalSpace H] (u : StructureGroupoid H) ‚¶É f : LocalHomeomorph H H ‚¶Ñ (hf : f ‚àà StructureGroupoid.members ‚ä•) hf : f ‚àà {LocalHomeomorph.refl H} ‚à™ {e : LocalHomeomorph H H | LocalEquiv.source LocalHomeomorph.toLocalEquiv e = ‚àÖ} := hf (hf_1 : LocalEquiv.source LocalHomeomorph.toLocalEquiv f = ‚àÖ) (h : (Eq.mp (Mathlib.Geometry.Manifold.ChartedSpace._auxLemma.1 =: (f ‚àà insert LocalHomeomorph.refl H {e : LocalHomeomorph H H | LocalEquiv.source LocalHomeomorph.toLocalEquiv e = ‚àÖ} : Prop) = ((f = LocalHomeomorph.refl H : Prop) ‚à® (f ‚àà {e : LocalHomeomorph H H | LocalEquiv.source LocalHomeomorph.toLocalEquiv e = ‚àÖ} : Prop) : Prop)) hf =: (f = LocalHomeomorph.refl H : Prop) ‚à® (f ‚àà {e : LocalHomeomorph H H | LocalEquiv.source LocalHomeomorph.toLocalEquiv e = ‚àÖ} : Prop)) = (Or.inr hf_1 =: (f = LocalHomeomorph.refl H : Prop) ‚à® (LocalEquiv.source LocalHomeomorph.toLocalEquiv f = ‚àÖ : Prop)))  : (Or.inr hf_1) = (Eq.mp Mathlib.Geometry.Manifold.ChartedSpace._auxLemma.1 hf)
<input>:1:129: expected '/--' or ':'

{R : Type u} [CommRing R] (t : Set PrimeSpectrum R) (I : Ideal R) (h : t ‚äÜ PrimeSpectrum.zeroLocus ‚Üë I) (x : R) (k : x ‚àà I) (x_1 : PrimeSpectrum R) (j : x_1 ‚àà t)  : x_1 ‚àà PrimeSpectrum.zeroLocus ‚Üë I
application type mismatch
  Set PrimeSpectrum
argument
  PrimeSpectrum
has type
  (R : Type ?u.11) ‚Üí [inst : CommRing R] ‚Üí Type ?u.11 : Type (?u.11 + 1)
but is expected to have type
  Type ?u.10 : Type (?u.10 + 1) ; identifiers [R, u, CommRing, R, t, Set, PrimeSpectrum, R, I, Ideal, R, h, t, PrimeSpectrum.zeroLocus, I, x, R, k, x, I, x_1, PrimeSpectrum, R, j, x_1, t, x_1, PrimeSpectrum.zeroLocus, I] (during elaboration)

{K : Type u_1} {n : ‚Ñï} {s : Stream'.Seq GeneralizedContinuedFraction.Pair K} [DivisionRing K] (terminated_at_succ_n : Stream'.Seq.TerminatedAt s n + 1) (terminated_at_succ_n : Stream'.Seq.get? s n + 1 = none) (val : GeneralizedContinuedFraction.Pair K) (h : Stream'.Seq.get? s n = some val)  : some val = Stream'.Seq.get? s n
application type mismatch
  Stream'.Seq GeneralizedContinuedFraction.Pair
argument
  GeneralizedContinuedFraction.Pair
has type
  Type ?u.10 ‚Üí Type ?u.10 : Type (?u.10 + 1)
but is expected to have type
  Type ?u.9 : Type (?u.9 + 1) ; identifiers [K, u_1, n, s, Stream'.Seq, GeneralizedContinuedFraction.Pair, K, DivisionRing, K, terminated_at_succ_n, Stream'.Seq.TerminatedAt, s, n, terminated_at_succ_n, Stream'.Seq.get?, s, n, none, val, GeneralizedContinuedFraction.Pair, K, h, Stream'.Seq.get?, s, n, some, val, some, val, Stream'.Seq.get?, s, n] (during elaboration)

{Œ± : Type u_1} {Œ≤ : Type u_2} [UniformSpace Œ±] [UniformSpace Œ≤] (toEquiv : Œ± ‚âÉ Œ≤) (uniformContinuous_toFun : UniformContinuous Equiv.toFun toEquiv) (uniformContinuous_invFun : UniformContinuous Equiv.invFun toEquiv) (toEquiv_1 : Œ± ‚âÉ Œ≤) (uniformContinuous_toFun_1 : UniformContinuous Equiv.toFun toEquiv_1) (uniformContinuous_invFun_1 : UniformContinuous Equiv.invFun toEquiv_1) (a : {toEquiv := ((toEquiv)) , uniformContinuous_toFun := ((uniformContinuous_toFun)) , uniformContinuous_invFun := ((uniformContinuous_invFun))} = {toEquiv := ((toEquiv_1)) , uniformContinuous_toFun := ((uniformContinuous_toFun_1)) , uniformContinuous_invFun := ((uniformContinuous_invFun_1))})  : ‚àÄ (toEquiv_eq : toEquiv = toEquiv_1) , toEquiv = toEquiv_1
function expected at
  UniformContinuous Equiv.toFun
term has type
  Prop ; identifiers [Œ±, u_1, Œ≤, u_2, UniformSpace, Œ±, UniformSpace, Œ≤, toEquiv, Œ±, Œ≤, uniformContinuous_toFun, UniformContinuous, Equiv.toFun, toEquiv, uniformContinuous_invFun, UniformContinuous, Equiv.invFun, toEquiv, toEquiv_1, Œ±, Œ≤, uniformContinuous_toFun_1, UniformContinuous, Equiv.toFun, toEquiv_1, uniformContinuous_invFun_1, UniformContinuous, Equiv.invFun, toEquiv_1, a, toEquiv, toEquiv, uniformContinuous_toFun, uniformContinuous_toFun, uniformContinuous_invFun, uniformContinuous_invFun, toEquiv, toEquiv_1, uniformContinuous_toFun, uniformContinuous_toFun_1, uniformContinuous_invFun, uniformContinuous_invFun_1, toEquiv_eq, toEquiv, toEquiv_1, toEquiv, toEquiv_1] (during elaboration)

{ùïú : Type u_1} [LinearOrderedField ùïú] {x : ùïú} {y : ùïú} (hxy : x ‚â† y) (h : x < y) (h_1 : (Ne.lt_or_lt hxy =: (x < y : Prop) ‚à® (y < x : Prop)) = (Or.inl h =: (x < y : Prop) ‚à® (y < x : Prop)))  : (Or.inl h) = (Ne.lt_or_lt hxy)
<input>:1:105: expected term

‚¶É J : Type u_1 ‚¶Ñ (F : (a : J) ‚Üí CategoryTheory.Grpd) (s : CategoryTheory.Limits.Fan F) (m : CategoryTheory.Limits.Cone.pt s ‚ü∂ CategoryTheory.Limits.Cone.pt CategoryTheory.Grpd.piLimitFan F) (w : ‚àÄ (j : J) , CategoryTheory.CategoryStruct.comp m CategoryTheory.Limits.Fan.proj CategoryTheory.Grpd.piLimitFan F j = CategoryTheory.Limits.Fan.proj s j) (j : J)  : CategoryTheory.CategoryStruct.comp m CategoryTheory.Limits.Fan.proj CategoryTheory.Grpd.piLimitFan F j = CategoryTheory.Limits.Fan.proj s j
function expected at
  ?m.81889.pt
term has type
  ?m.1243 ; identifiers [J, u_1, F, a, J, CategoryTheory.Grpd, s, CategoryTheory.Limits.Fan, F, m, CategoryTheory.Limits.Cone.pt, s, CategoryTheory.Limits.Cone.pt, CategoryTheory.Grpd.piLimitFan, F, w, j, J, CategoryTheory.CategoryStruct.comp, m, CategoryTheory.Limits.Fan.proj, CategoryTheory.Grpd.piLimitFan, F, j, CategoryTheory.Limits.Fan.proj, s, j, j, J, CategoryTheory.CategoryStruct.comp, m, CategoryTheory.Limits.Fan.proj, CategoryTheory.Grpd.piLimitFan, F, j, CategoryTheory.Limits.Fan.proj, s, j] (during elaboration)

{G : Type u_1} [AddMonoid G] {x : G} {n : ‚Ñï} (h : Nat.coprime n addOrderOf x)  : (1 ‚Ä¢ n ‚Ä¢ x = x) = (1 ‚Ä¢ n ‚Ä¢ x = x)
application type mismatch
  Nat.coprime n addOrderOf
argument
  addOrderOf
has type
  ?m.17 ‚Üí ‚Ñï : Type ?u.16
but is expected to have type
  ‚Ñï : Type ; identifiers [G, u_1, AddMonoid, G, x, G, n, h, Nat.coprime, n, addOrderOf, x, n, x, x, n, x, x] (during elaboration)

{Œ± : Type u_1} {m0 : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {ŒΩ : MeasureTheory.Measure Œ±} {Œ± : Type u_1} {m0 : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {ŒΩ : MeasureTheory.Measure Œ±} (h : MeasureTheory.Measure.ae Œº ‚â§ MeasureTheory.Measure.ae ŒΩ) (s : Set Œ±)  : ‚àÄ (hs : ‚àÄ·µê (a : Œ±) ‚àÇ ŒΩ , ¬¨ (a ‚àà s)) , {x : Œ± | fun (a : Œ±) ‚Ü¶ ¬¨ (a ‚àà s) x} ‚àà MeasureTheory.Measure.ae Œº
function expected at
  a ‚àà s
term has type
  Prop ; identifiers [Œ±, u_1, m0, MeasurableSpace, Œ±, Œº, MeasureTheory.Measure, Œ±, ŒΩ, MeasureTheory.Measure, Œ±, Œ±, u_1, m0, MeasurableSpace, Œ±, Œº, MeasureTheory.Measure, Œ±, ŒΩ, MeasureTheory.Measure, Œ±, h, MeasureTheory.Measure.ae, Œº, MeasureTheory.Measure.ae, ŒΩ, s, Set, Œ±, hs, a, Œ±, ŒΩ, a, s, x, Œ±, a, Œ±, a, s, x, MeasureTheory.Measure.ae, Œº] (during elaboration)

{G : Type u_1} [AddMonoid G] {x : G} {n : ‚Ñï} (h : Nat.coprime n addOrderOf x)  : (1 ‚Ä¢ 1 ‚Ä¢ x = x) = (1 ‚Ä¢ 1 ‚Ä¢ x = x)
application type mismatch
  Nat.coprime n addOrderOf
argument
  addOrderOf
has type
  ?m.17 ‚Üí ‚Ñï : Type ?u.16
but is expected to have type
  ‚Ñï : Type ; identifiers [G, u_1, AddMonoid, G, x, G, n, h, Nat.coprime, n, addOrderOf, x, x, x, x, x] (during elaboration)

{H : Type u_1} [TopologicalSpace H] (u : StructureGroupoid H) ‚¶É f : LocalHomeomorph H H ‚¶Ñ (hf : f ‚àà StructureGroupoid.members ‚ä•) hf : f ‚àà {LocalHomeomorph.refl H} ‚à™ {e : LocalHomeomorph H H | LocalEquiv.source LocalHomeomorph.toLocalEquiv e = ‚àÖ} := hf (hf_1 : LocalEquiv.source LocalHomeomorph.toLocalEquiv f = ‚àÖ) (h : (Eq.mp (Mathlib.Geometry.Manifold.ChartedSpace._auxLemma.1 =: (f ‚àà insert LocalHomeomorph.refl H {e : LocalHomeomorph H H | LocalEquiv.source LocalHomeomorph.toLocalEquiv e = ‚àÖ} : Prop) = ((f = LocalHomeomorph.refl H : Prop) ‚à® (f ‚àà {e : LocalHomeomorph H H | LocalEquiv.source LocalHomeomorph.toLocalEquiv e = ‚àÖ} : Prop) : Prop)) hf =: (f = LocalHomeomorph.refl H : Prop) ‚à® (f ‚àà {e : LocalHomeomorph H H | LocalEquiv.source LocalHomeomorph.toLocalEquiv e = ‚àÖ} : Prop)) = (Or.inr hf_1 =: (f = LocalHomeomorph.refl H : Prop) ‚à® (LocalEquiv.source LocalHomeomorph.toLocalEquiv f = ‚àÖ : Prop))) (x : H) (hx : x ‚àà LocalEquiv.source LocalHomeomorph.toLocalEquiv f)  : (x ‚àà ‚àÖ) = (x ‚àà ‚àÖ)
<input>:1:129: expected '/--' or ':'

{G : Type u_1} [AddMonoid G] {x : G} {n : ‚Ñï} (h : Nat.coprime n addOrderOf x)  : (1 ‚Ä¢ x = x) = (1 ‚Ä¢ x = x)
application type mismatch
  Nat.coprime n addOrderOf
argument
  addOrderOf
has type
  ?m.17 ‚Üí ‚Ñï : Type ?u.16
but is expected to have type
  ‚Ñï : Type ; identifiers [G, u_1, AddMonoid, G, x, G, n, h, Nat.coprime, n, addOrderOf, x, x, x, x, x] (during elaboration)

{G : Type u_1} [AddMonoid G] {x : G} {n : ‚Ñï} (h : Nat.coprime n addOrderOf x)  : x = x
application type mismatch
  Nat.coprime n addOrderOf
argument
  addOrderOf
has type
  ?m.17 ‚Üí ‚Ñï : Type ?u.16
but is expected to have type
  ‚Ñï : Type ; identifiers [G, u_1, AddMonoid, G, x, G, n, h, Nat.coprime, n, addOrderOf, x, x, x] (during elaboration)

{Œ± : Type u_1} {Œ≤ : Type u_2} [UniformSpace Œ±] [UniformSpace Œ≤] (toEquiv : Œ± ‚âÉ Œ≤) (uniformContinuous_toFun : UniformContinuous Equiv.toFun toEquiv) (uniformContinuous_invFun : UniformContinuous Equiv.invFun toEquiv) (toEquiv_1 : Œ± ‚âÉ Œ≤) (uniformContinuous_toFun_1 : UniformContinuous Equiv.toFun toEquiv_1) (uniformContinuous_invFun_1 : UniformContinuous Equiv.invFun toEquiv_1) (a : toEquiv = toEquiv_1) (h : toEquiv_1 = toEquiv) (toEquiv_2 : Œ± ‚âÉ Œ≤)  : toEquiv = toEquiv
function expected at
  UniformContinuous Equiv.toFun
term has type
  Prop ; identifiers [Œ±, u_1, Œ≤, u_2, UniformSpace, Œ±, UniformSpace, Œ≤, toEquiv, Œ±, Œ≤, uniformContinuous_toFun, UniformContinuous, Equiv.toFun, toEquiv, uniformContinuous_invFun, UniformContinuous, Equiv.invFun, toEquiv, toEquiv_1, Œ±, Œ≤, uniformContinuous_toFun_1, UniformContinuous, Equiv.toFun, toEquiv_1, uniformContinuous_invFun_1, UniformContinuous, Equiv.invFun, toEquiv_1, a, toEquiv, toEquiv_1, h, toEquiv_1, toEquiv, toEquiv_2, Œ±, Œ≤, toEquiv, toEquiv] (during elaboration)

{Œ± : Type u_1} {Œ≤ : Type u_2} [UniformSpace Œ±] [UniformSpace Œ≤] (toEquiv : Œ± ‚âÉ Œ≤) (uniformContinuous_toFun : UniformContinuous Equiv.toFun toEquiv) (uniformContinuous_invFun : UniformContinuous Equiv.invFun toEquiv) (toEquiv_1 : Œ± ‚âÉ Œ≤) (uniformContinuous_toFun_1 : UniformContinuous Equiv.toFun toEquiv_1) (uniformContinuous_invFun_1 : UniformContinuous Equiv.invFun toEquiv_1) (a : toEquiv = toEquiv_1) (h : toEquiv_1 = toEquiv) (uniformContinuous_toFun_2 : UniformContinuous Equiv.toFun toEquiv) (uniformContinuous_invFun_2 : UniformContinuous Equiv.invFun toEquiv) (a : toEquiv = toEquiv) (h : HEq a (Eq.refl toEquiv =: toEquiv = toEquiv))  : {toEquiv := ((toEquiv)) , uniformContinuous_toFun := ((uniformContinuous_toFun)) , uniformContinuous_invFun := ((uniformContinuous_invFun))} = {toEquiv := ((toEquiv)) , uniformContinuous_toFun := ((uniformContinuous_toFun)) , uniformContinuous_invFun := ((uniformContinuous_invFun))}
<input>:1:621: expected term

{Œ± : Type u_1} {Œ≤ : Type u_2} [UniformSpace Œ±] [UniformSpace Œ≤] (toEquiv : Œ± ‚âÉ Œ≤) (uniformContinuous_toFun : UniformContinuous Equiv.toFun toEquiv) (uniformContinuous_invFun : UniformContinuous Equiv.invFun toEquiv) (toEquiv_1 : Œ± ‚âÉ Œ≤) (uniformContinuous_toFun_1 : UniformContinuous Equiv.toFun toEquiv_1) (uniformContinuous_invFun_1 : UniformContinuous Equiv.invFun toEquiv_1) (a : toEquiv = toEquiv_1) (h : toEquiv_1 = toEquiv)  : toEquiv = toEquiv_1
function expected at
  UniformContinuous Equiv.toFun
term has type
  Prop ; identifiers [Œ±, u_1, Œ≤, u_2, UniformSpace, Œ±, UniformSpace, Œ≤, toEquiv, Œ±, Œ≤, uniformContinuous_toFun, UniformContinuous, Equiv.toFun, toEquiv, uniformContinuous_invFun, UniformContinuous, Equiv.invFun, toEquiv, toEquiv_1, Œ±, Œ≤, uniformContinuous_toFun_1, UniformContinuous, Equiv.toFun, toEquiv_1, uniformContinuous_invFun_1, UniformContinuous, Equiv.invFun, toEquiv_1, a, toEquiv, toEquiv_1, h, toEquiv_1, toEquiv, toEquiv, toEquiv_1] (during elaboration)

{Œ± : Type u_1} {Œ≤ : Type u_2} [UniformSpace Œ±] [UniformSpace Œ≤] (toEquiv : Œ± ‚âÉ Œ≤) (uniformContinuous_toFun : UniformContinuous Equiv.toFun toEquiv) (uniformContinuous_invFun : UniformContinuous Equiv.invFun toEquiv) (toEquiv_1 : Œ± ‚âÉ Œ≤) (uniformContinuous_toFun_1 : UniformContinuous Equiv.toFun toEquiv_1) (uniformContinuous_invFun_1 : UniformContinuous Equiv.invFun toEquiv_1) (a : toEquiv = toEquiv_1)  : toEquiv_1 = toEquiv_1
function expected at
  UniformContinuous Equiv.toFun
term has type
  Prop ; identifiers [Œ±, u_1, Œ≤, u_2, UniformSpace, Œ±, UniformSpace, Œ≤, toEquiv, Œ±, Œ≤, uniformContinuous_toFun, UniformContinuous, Equiv.toFun, toEquiv, uniformContinuous_invFun, UniformContinuous, Equiv.invFun, toEquiv, toEquiv_1, Œ±, Œ≤, uniformContinuous_toFun_1, UniformContinuous, Equiv.toFun, toEquiv_1, uniformContinuous_invFun_1, UniformContinuous, Equiv.invFun, toEquiv_1, a, toEquiv, toEquiv_1, toEquiv_1, toEquiv_1] (during elaboration)

{G : Type u_1} [AddMonoid G] {x : G} {n : ‚Ñï} (h : Nat.coprime n addOrderOf x)  : (0 ‚Ä¢ n ‚Ä¢ x = x) = (0 ‚Ä¢ n ‚Ä¢ x = x)
application type mismatch
  Nat.coprime n addOrderOf
argument
  addOrderOf
has type
  ?m.17 ‚Üí ‚Ñï : Type ?u.16
but is expected to have type
  ‚Ñï : Type ; identifiers [G, u_1, AddMonoid, G, x, G, n, h, Nat.coprime, n, addOrderOf, x, n, x, x, n, x, x] (during elaboration)

{G : Type u_1} [AddMonoid G] {x : G} {n : ‚Ñï} (h : Nat.coprime n addOrderOf x)  : (0 ‚Ä¢ n ‚Ä¢ 0 = 0) = (0 ‚Ä¢ n ‚Ä¢ 0 = 0)
application type mismatch
  Nat.coprime n addOrderOf
argument
  addOrderOf
has type
  ?m.17 ‚Üí ‚Ñï : Type ?u.16
but is expected to have type
  ‚Ñï : Type ; identifiers [G, u_1, AddMonoid, G, x, G, n, h, Nat.coprime, n, addOrderOf, x, n, n] (during elaboration)

{G : Type u_1} [AddMonoid G] {x : G} {n : ‚Ñï} (h : Nat.coprime n addOrderOf x)  : (0 ‚Ä¢ 0 = 0) = (0 ‚Ä¢ 0 = 0)
application type mismatch
  Nat.coprime n addOrderOf
argument
  addOrderOf
has type
  ?m.17 ‚Üí ‚Ñï : Type ?u.16
but is expected to have type
  ‚Ñï : Type ; identifiers [G, u_1, AddMonoid, G, x, G, n, h, Nat.coprime, n, addOrderOf, x] (during elaboration)

{G : Type u_1} [AddMonoid G] {x : G} {n : ‚Ñï} (h : Nat.coprime n addOrderOf x)  : 0 = 0
application type mismatch
  Nat.coprime n addOrderOf
argument
  addOrderOf
has type
  ?m.17 ‚Üí ‚Ñï : Type ?u.16
but is expected to have type
  ‚Ñï : Type ; identifiers [G, u_1, AddMonoid, G, x, G, n, h, Nat.coprime, n, addOrderOf, x] (during elaboration)

{ùïú : Type u_1} [LinearOrderedField ùïú] {x : ùïú} {y : ùïú} (hxy : x ‚â† y) (h : y < x) (h_1 : (Ne.lt_or_lt hxy =: (x < y : Prop) ‚à® (y < x : Prop)) = (Or.inr h =: (x < y : Prop) ‚à® (y < x : Prop)))  : (Or.inr h) = (Ne.lt_or_lt hxy)
<input>:1:105: expected term

{a : ‚Ñï} (a1 : 1 < a) (m : ‚Ñï) (n : ‚Ñï) (h : Pell.yn a1 m ‚à£ Pell.yn a1 n) (hp : n % m > 0) (co : Nat.coprime Pell.yn a1 m Pell.xn a1 m * n / m) (e : m = 0)  : (n % 0 > 0) = (n % 0 > 0)
application type mismatch
  Nat.coprime Pell.yn
argument
  Pell.yn
has type
  1 < ?m.136 ‚Üí ‚Ñï ‚Üí ‚Ñï : Type
but is expected to have type
  ‚Ñï : Type ; identifiers [a, a1, a, m, n, h, Pell.yn, a1, m, Pell.yn, a1, n, hp, n, m, co, Nat.coprime, Pell.yn, a1, m, Pell.xn, a1, m, n, m, e, m, n, n] (during elaboration)

{a : ‚Ñï} (a1 : 1 < a) (m : ‚Ñï) (n : ‚Ñï) (h : Pell.yn a1 m ‚à£ Pell.yn a1 n) (hp : n % m > 0) (co : Nat.coprime Pell.yn a1 m Pell.xn a1 m * n / m) (e : m = 0)  : (n % m > 0) = (n % m > 0)
application type mismatch
  Nat.coprime Pell.yn
argument
  Pell.yn
has type
  1 < ?m.136 ‚Üí ‚Ñï ‚Üí ‚Ñï : Type
but is expected to have type
  ‚Ñï : Type ; identifiers [a, a1, a, m, n, h, Pell.yn, a1, m, Pell.yn, a1, n, hp, n, m, co, Nat.coprime, Pell.yn, a1, m, Pell.xn, a1, m, n, m, e, m, n, m, n, m] (during elaboration)

{G : Type u_1} [AddMonoid G] {x : G} {n : ‚Ñï} (h : Nat.coprime n addOrderOf x) (m : ‚Ñï) (h : n * m % addOrderOf x = 1)  : (m ‚Ä¢ n ‚Ä¢ x = x) = (m ‚Ä¢ n ‚Ä¢ x = x)
application type mismatch
  Nat.coprime n addOrderOf
argument
  addOrderOf
has type
  ?m.17 ‚Üí ‚Ñï : Type ?u.16
but is expected to have type
  ‚Ñï : Type ; identifiers [G, u_1, AddMonoid, G, x, G, n, h, Nat.coprime, n, addOrderOf, x, m, h, n, m, addOrderOf, x, m, n, x, x, m, n, x, x] (during elaboration)

{G : Type u_1} [AddMonoid G] {x : G} {n : ‚Ñï} (h : Nat.coprime n addOrderOf x) (m : ‚Ñï) (h : n * m % addOrderOf x = 1)  : (n * m ‚Ä¢ x = x) = (n * m ‚Ä¢ x = x)
application type mismatch
  Nat.coprime n addOrderOf
argument
  addOrderOf
has type
  ?m.17 ‚Üí ‚Ñï : Type ?u.16
but is expected to have type
  ‚Ñï : Type ; identifiers [G, u_1, AddMonoid, G, x, G, n, h, Nat.coprime, n, addOrderOf, x, m, h, n, m, addOrderOf, x, n, m, x, x, n, m, x, x] (during elaboration)

{Œ± : Type u_1} [LinearOrderedRing Œ±] [FloorRing Œ±] (a : Œ±) (ha : Int.fract a ‚â† 0) (h : (eq_or_ne Int.fract a 0 =: (Int.fract a = 0 : Prop) ‚à® (Int.fract a ‚â† 0 : Prop)) = (Or.inr ha =: (Int.fract a = 0 : Prop) ‚à® (Int.fract a ‚â† 0 : Prop)))  : (‚åà a ‚åâ = ‚åä a ‚åã + 1) = (‚åà a ‚åâ = ‚åä a ‚åã + 1)
<input>:1:112: expected term

{G : Type u_1} [AddMonoid G] {x : G} {n : ‚Ñï} (h : Nat.coprime n addOrderOf x) (m : ‚Ñï) (h : n * m % addOrderOf x = 1)  : (1 ‚Ä¢ x = x) = (1 ‚Ä¢ x = x)
application type mismatch
  Nat.coprime n addOrderOf
argument
  addOrderOf
has type
  ?m.17 ‚Üí ‚Ñï : Type ?u.16
but is expected to have type
  ‚Ñï : Type ; identifiers [G, u_1, AddMonoid, G, x, G, n, h, Nat.coprime, n, addOrderOf, x, m, h, n, m, addOrderOf, x, x, x, x, x] (during elaboration)

{G : Type u_1} [AddMonoid G] {x : G} {n : ‚Ñï} (h : Nat.coprime n addOrderOf x) (m : ‚Ñï) (h : n * m % addOrderOf x = 1)  : x = x
application type mismatch
  Nat.coprime n addOrderOf
argument
  addOrderOf
has type
  ?m.17 ‚Üí ‚Ñï : Type ?u.16
but is expected to have type
  ‚Ñï : Type ; identifiers [G, u_1, AddMonoid, G, x, G, n, h, Nat.coprime, n, addOrderOf, x, m, h, n, m, addOrderOf, x, x, x] (during elaboration)

{Œπ : Type u_2} {œÄ : (a : Œπ) ‚Üí Type u_1} [Finite Œπ] [(i : Œπ) ‚Üí LinearOrder œÄ i] [(i : Œπ) ‚Üí TopologicalSpace œÄ i] [‚àÄ (i : Œπ) , OrderTopology œÄ i] {a : (i : Œπ) ‚Üí œÄ i} {b : (i : Œπ) ‚Üí œÄ i} {x : (i : Œπ) ‚Üí œÄ i} (ha : ‚àÄ (i : Œπ) , a i < x i) (hb : ‚àÄ (i : Œπ) , x i < b i) (x_1 : Œπ) (x_2 : x_1 ‚àà Set.univ)  : a x_1 < x x_1
application type mismatch
  LinearOrder œÄ
argument
  œÄ
has type
  Œπ ‚Üí Type u_1 : Type (max (u_1 + 1) u_2)
but is expected to have type
  Type ?u.19 : Type (?u.19 + 1) ; identifiers [Œπ, u_2, œÄ, a, Œπ, u_1, Finite, Œπ, i, Œπ, LinearOrder, œÄ, i, i, Œπ, TopologicalSpace, œÄ, i, i, Œπ, OrderTopology, œÄ, i, a, i, Œπ, œÄ, i, b, i, Œπ, œÄ, i, x, i, Œπ, œÄ, i, ha, i, Œπ, a, i, x, i, hb, i, Œπ, x, i, b, i, x_1, Œπ, x_2, x_1, Set.univ, a, x_1, x, x_1] (during elaboration)

{Œπ : Type u_2} {œÄ : (a : Œπ) ‚Üí Type u_1} [Finite Œπ] [(i : Œπ) ‚Üí LinearOrder œÄ i] [(i : Œπ) ‚Üí TopologicalSpace œÄ i] [‚àÄ (i : Œπ) , OrderTopology œÄ i] {a : (i : Œπ) ‚Üí œÄ i} {b : (i : Œπ) ‚Üí œÄ i} {x : (i : Œπ) ‚Üí œÄ i} (ha : ‚àÄ (i : Œπ) , a i < x i) (hb : ‚àÄ (i : Œπ) , x i < b i) (x_1 : Œπ) (x_2 : x_1 ‚àà Set.univ)  : x x_1 < b x_1
application type mismatch
  LinearOrder œÄ
argument
  œÄ
has type
  Œπ ‚Üí Type u_1 : Type (max (u_1 + 1) u_2)
but is expected to have type
  Type ?u.19 : Type (?u.19 + 1) ; identifiers [Œπ, u_2, œÄ, a, Œπ, u_1, Finite, Œπ, i, Œπ, LinearOrder, œÄ, i, i, Œπ, TopologicalSpace, œÄ, i, i, Œπ, OrderTopology, œÄ, i, a, i, Œπ, œÄ, i, b, i, Œπ, œÄ, i, x, i, Œπ, œÄ, i, ha, i, Œπ, a, i, x, i, hb, i, Œπ, x, i, b, i, x_1, Œπ, x_2, x_1, Set.univ, x, x_1, b, x_1] (during elaboration)

{Œ± : Type u_1} [LinearOrderedRing Œ±] [FloorRing Œ±] (a : Œ±) (ha : Int.fract a ‚â† 0) (h : (eq_or_ne Int.fract a 0 =: (Int.fract a = 0 : Prop) ‚à® (Int.fract a ‚â† 0 : Prop)) = (Or.inr ha =: (Int.fract a = 0 : Prop) ‚à® (Int.fract a ‚â† 0 : Prop)))  : (‚Üë ‚åä a ‚åã + 1 - 1 < a) = (‚Üë ‚åä a ‚åã + 1 - 1 < a)
<input>:1:112: expected term

{Œ± : Type u_1} {P : (a : Œ±) ‚Üí Prop} {Q : (a : Œ±) ‚Üí Prop} (H : ‚àÄ (a : Œ±) (a_1 : P a) , Q a) (x : Ordnode Œ±) (x : Ordnode Œ±) (f : Ordnode.below (motive := fun (x : Ordnode Œ±) ‚Ü¶ ‚àÄ (a : Ordnode.Any P x) , Ordnode.Any Q x) x) (s : ‚Ñï) (l : Ordnode Œ±) (x : Œ±) (r : Ordnode Œ±) (x_1 : Ordnode.below (motive := fun (x : Ordnode Œ±) ‚Ü¶ ‚àÄ (a : Ordnode.Any P x) , Ordnode.Any Q x) Ordnode.node s l x r)  : ‚àÄ (a : P x) , Q x
application type mismatch
  Ordnode.below (motive := fun x => Ordnode.Any P x ‚Üí Ordnode.Any Q x) Ordnode.node
argument
  Ordnode.node
has type
  ‚Ñï ‚Üí Ordnode ?m.99 ‚Üí ?m.99 ‚Üí Ordnode ?m.99 ‚Üí Ordnode ?m.99 : Type ?u.98
but is expected to have type
  Ordnode Œ± : Type u_1 ; identifiers [Œ±, u_1, P, a, Œ±, Q, a, Œ±, H, a, Œ±, a_1, P, a, Q, a, x, Ordnode, Œ±, x, Ordnode, Œ±, f, Ordnode.below, motive, x, Ordnode, Œ±, a, Ordnode.Any, P, x, Ordnode.Any, Q, x, x, s, l, Ordnode, Œ±, x, Œ±, r, Ordnode, Œ±, x_1, Ordnode.below, motive, x, Ordnode, Œ±, a, Ordnode.Any, P, x, Ordnode.Any, Q, x, Ordnode.node, s, l, x, r, a, P, x, Q, x] (during elaboration)

{Œ± : Type u_1} [LinearOrderedRing Œ±] [FloorRing Œ±] (a : Œ±) (ha : Int.fract a ‚â† 0) (h : (eq_or_ne Int.fract a 0 =: (Int.fract a = 0 : Prop) ‚à® (Int.fract a ‚â† 0 : Prop)) = (Or.inr ha =: (Int.fract a = 0 : Prop) ‚à® (Int.fract a ‚â† 0 : Prop)))  : (‚Üë ‚åä a ‚åã + ‚Üë 1 - 1 < a) = (‚Üë ‚åä a ‚åã + ‚Üë 1 - 1 < a)
<input>:1:112: expected term

{Œ± : Type u_1} [LinearOrderedRing Œ±] [FloorRing Œ±] (a : Œ±) (ha : Int.fract a ‚â† 0) (h : (eq_or_ne Int.fract a 0 =: (Int.fract a = 0 : Prop) ‚à® (Int.fract a ‚â† 0 : Prop)) = (Or.inr ha =: (Int.fract a = 0 : Prop) ‚à® (Int.fract a ‚â† 0 : Prop)))  : (‚Üë ‚åä a ‚åã + 1 - 1 < a) = (‚Üë ‚åä a ‚åã + 1 - 1 < a)
<input>:1:112: expected term

{Œ± : Type u_1} [LinearOrderedRing Œ±] [FloorRing Œ±] (a : Œ±) (ha : Int.fract a ‚â† 0) (h : (eq_or_ne Int.fract a 0 =: (Int.fract a = 0 : Prop) ‚à® (Int.fract a ‚â† 0 : Prop)) = (Or.inr ha =: (Int.fract a = 0 : Prop) ‚à® (Int.fract a ‚â† 0 : Prop)))  : (‚Üë ‚åä a ‚åã < a) = (‚Üë ‚åä a ‚åã < a)
<input>:1:112: expected term

{x : PGame} {y : PGame}  : ((‚àÄ (i : PGame.LeftMoves x) , (‚àÉ (i_1 : PGame.LeftMoves y) , PGame.moveLeft x i ‚â§ PGame.moveLeft y i_1) ‚à® (‚àÉ (j : PGame.RightMoves PGame.moveLeft x i) , PGame.moveRight PGame.moveLeft x i j ‚â§ y)) ‚àß (‚àÄ (j : PGame.RightMoves y) , (‚àÉ (i : PGame.LeftMoves PGame.moveRight y j) , x ‚â§ PGame.moveLeft PGame.moveRight y j i) ‚à® (‚àÉ (j_1 : PGame.RightMoves x) , PGame.moveRight x j_1 ‚â§ PGame.moveRight y j))) ‚Üî ((‚àÄ (i : PGame.LeftMoves x) , (‚àÉ (i_1 : PGame.LeftMoves y) , PGame.moveLeft x i ‚â§ PGame.moveLeft y i_1) ‚à® (‚àÉ (j : PGame.RightMoves PGame.moveLeft x i) , PGame.moveRight PGame.moveLeft x i j ‚â§ y)) ‚àß (‚àÄ (j : PGame.RightMoves y) , (‚àÉ (i : PGame.LeftMoves PGame.moveRight y j) , x ‚â§ PGame.moveLeft PGame.moveRight y j i) ‚à® (‚àÉ (j_1 : PGame.RightMoves x) , PGame.moveRight x j_1 ‚â§ PGame.moveRight y j)))
application type mismatch
  PGame.RightMoves PGame.moveLeft
argument
  PGame.moveLeft
has type
  (g : PGame) ‚Üí PGame.LeftMoves g ‚Üí PGame : Type (?u.71 + 1)
but is expected to have type
  PGame : Type (?u.70 + 1) ; identifiers [x, PGame, y, PGame, i, PGame.LeftMoves, x, i_1, PGame.LeftMoves, y, PGame.moveLeft, x, i, PGame.moveLeft, y, i_1, j, PGame.RightMoves, PGame.moveLeft, x, i, PGame.moveRight, PGame.moveLeft, x, i, j, y, j, PGame.RightMoves, y, i, PGame.LeftMoves, PGame.moveRight, y, j, x, PGame.moveLeft, PGame.moveRight, y, j, i, j_1, PGame.RightMoves, x, PGame.moveRight, x, j_1, PGame.moveRight, y, j, i, PGame.LeftMoves, x, i_1, PGame.LeftMoves, y, PGame.moveLeft, x, i, PGame.moveLeft, y, i_1, j, PGame.RightMoves, PGame.moveLeft, x, i, PGame.moveRight, PGame.moveLeft, x, i, j, y, j, PGame.RightMoves, y, i, PGame.LeftMoves, PGame.moveRight, y, j, x, PGame.moveLeft, PGame.moveRight, y, j, i, j_1, PGame.RightMoves, x, PGame.moveRight, x, j_1, PGame.moveRight, y, j] (during elaboration)

(L : FirstOrder.Language) {Œ± : Type u'} {M : Type w} [FirstOrder.Language.Structure FirstOrder.Language.withConstants L Œ± M] (s : Set Œ±) (œÜ : FirstOrder.Language.Sentence FirstOrder.Language.withConstants L Œ±)  : (M ‚ä® œÜ) = (M ‚ä® œÜ)
application type mismatch
  FirstOrder.Language.Structure FirstOrder.Language.withConstants
argument
  FirstOrder.Language.withConstants
has type
  FirstOrder.Language ‚Üí Type ?u.17 ‚Üí FirstOrder.Language : Type (max (max (?u.17 + 1) (?u.18 + 1)) (?u.19 + 1))
but is expected to have type
  FirstOrder.Language : Type (max (?u.16 + 1) (?u.15 + 1)) ; identifiers [L, FirstOrder.Language, Œ±, u', M, w, FirstOrder.Language.Structure, FirstOrder.Language.withConstants, L, Œ±, M, s, Set, Œ±, œÜ, FirstOrder.Language.Sentence, FirstOrder.Language.withConstants, L, Œ±, M, œÜ, M, œÜ, M, œÜ, M, œÜ] (during elaboration)

{R : Type u_1} [Semiring R] (n : ‚Ñï) (a : R) [Decidable (a = 0 : Prop)] (i : ‚Ñï) (hi : ‚Üë i < ‚Üë n)  : (if (i = n) then a else 0 = 0) = (if (i = n) then a else 0 = 0)
application type mismatch
  if i = n then a else 0 = 0
argument
  0 = 0
has type
  Prop : Type
but is expected to have type
  R : Type u_1 ; identifiers [R, u_1, Semiring, R, n, a, R, Decidable, a, i, hi, i, n, i, n, a, i, n, a] (during elaboration)

 : (‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] [inst_1 : OrderBot Œ±] {a : Œ±} , (IsCoatom ‚Üë OrderDual.toDual a) ‚Üî (IsAtom a))
function expected at
  IsCoatom ?m.28
term has type
  Prop ; identifiers [Œ±, u_1, inst, Preorder, Œ±, inst_1, OrderBot, Œ±, a, Œ±, IsCoatom, OrderDual.toDual, a, IsAtom, a] (during elaboration)

 : ‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] [inst_1 : OrderBot Œ±] {a : Œ±} , (IsCoatom ‚Üë OrderDual.toDual a) ‚Üî (IsCoatom ‚Üë OrderDual.toDual a)
function expected at
  IsCoatom ?m.28
term has type
  Prop ; identifiers [Œ±, u_1, inst, Preorder, Œ±, inst_1, OrderBot, Œ±, a, Œ±, IsCoatom, OrderDual.toDual, a, IsCoatom, OrderDual.toDual, a] (during elaboration)

{Œ± : Type u} {Œ≤ : Type v} {œÜ : Ultrafilter Œ±} [LinearOrder Œ≤] (x : Filter.Germ ‚Üë œÜ Œ≤) (y : Filter.Germ ‚Üë œÜ Œ≤) (a : (a : Œ±) ‚Üí Œ≤) (b : (a : Œ±) ‚Üí Œ≤) (h : ‚Üë a ‚â§ ‚Üë b) (h_1 : (le_total ‚Üë a ‚Üë b =: (‚Üë a ‚â§ ‚Üë b : Prop) ‚à® (‚Üë b ‚â§ ‚Üë a : Prop)) = (Or.inl h =: (‚Üë a ‚â§ ‚Üë b : Prop) ‚à® (‚Üë b ‚â§ ‚Üë a : Prop)))  : (Or.inl h) = (le_total ‚Üë a ‚Üë b)
<input>:1:188: expected term

{V : Type u} {G : SimpleGraph V} {toProd : V √ó V} {is_adj : SimpleGraph.Adj G Prod.fst toProd Prod.snd toProd} {toProd_1 : V √ó V} {is_adj_1 : SimpleGraph.Adj G Prod.fst toProd_1 Prod.snd toProd_1} (x : {toProd := ((toProd)) , is_adj := ((is_adj))} = {toProd := ((toProd_1)) , is_adj := ((is_adj_1))})  : ‚àÄ (toProd_eq : toProd = toProd_1) , toProd = toProd_1
application type mismatch
  SimpleGraph.Adj G Prod.fst
argument
  Prod.fst
has type
  ?m.21 √ó ?m.22 ‚Üí ?m.21 : Type (max ?u.19 ?u.20)
but is expected to have type
  V : Type u ; identifiers [V, u, G, SimpleGraph, V, toProd, V, V, is_adj, SimpleGraph.Adj, G, Prod.fst, toProd, Prod.snd, toProd, toProd_1, V, V, is_adj_1, SimpleGraph.Adj, G, Prod.fst, toProd_1, Prod.snd, toProd_1, x, toProd, toProd, is_adj, is_adj, toProd, toProd_1, is_adj, is_adj_1, toProd_eq, toProd, toProd_1, toProd, toProd_1] (during elaboration)

(x : ENNReal) (y : ENNReal) {z : ‚Ñù} (hz : 0 ‚â§ z)  : ‚àÄ (a : False) , ‚ä§ = ‚ä§
typeclass instance problem is stuck, it is often due to metavariables
  Top (?m.769 x y hz a) ; identifiers [x, ENNReal, y, ENNReal, z, hz, z, a, False] (during elaboration)

{Œ± : Type u_5} {Œ≤ : Type u_4} {Œ≥ : Type u_3} {a : Option Œ±} {b : Option Œ≤} {Œ±' : Type u_1} {Œ¥ : Type u_2} {f : (a : Œ±') ‚Üí (a : Œ≤) ‚Üí Œ≥} {g : (a : Œ±) ‚Üí Œ±'} {f' : (a : Œ≤) ‚Üí (a : Œ±) ‚Üí Œ¥} {g' : (a : Œ¥) ‚Üí Œ≥} (h_left_anticomm : ‚àÄ (a : Œ±) (b : Œ≤) , f g a b = g' f' b a) (h : a = none)  : none = a
application type mismatch
  f g
argument
  g
has type
  Œ± ‚Üí Œ±' : Type (max u_1 u_5)
but is expected to have type
  Œ±' : Type u_1 ; identifiers [Œ±, u_5, Œ≤, u_4, Œ≥, u_3, a, Option, Œ±, b, Option, Œ≤, Œ±', u_1, Œ¥, u_2, f, a, Œ±', a, Œ≤, Œ≥, g, a, Œ±, Œ±', f', a, Œ≤, a, Œ±, Œ¥, g', a, Œ¥, Œ≥, h_left_anticomm, a, Œ±, b, Œ≤, f, g, a, b, g', f', b, a, h, a, none, none, a] (during elaboration)

{Œ± : Type u_5} {Œ≤ : Type u_4} {Œ≥ : Type u_3} {a : Option Œ±} {b : Option Œ≤} {Œ±' : Type u_1} {Œ¥ : Type u_2} {f : (a : Œ±') ‚Üí (a : Œ≤) ‚Üí Œ≥} {g : (a : Œ±) ‚Üí Œ±'} {f' : (a : Œ≤) ‚Üí (a : Œ±) ‚Üí Œ¥} {g' : (a : Œ¥) ‚Üí Œ≥} (h_left_anticomm : ‚àÄ (a : Œ±) (b : Œ≤) , f g a b = g' f' b a) (h : a = none) (h : b = none)  : none = b
application type mismatch
  f g
argument
  g
has type
  Œ± ‚Üí Œ±' : Type (max u_1 u_5)
but is expected to have type
  Œ±' : Type u_1 ; identifiers [Œ±, u_5, Œ≤, u_4, Œ≥, u_3, a, Option, Œ±, b, Option, Œ≤, Œ±', u_1, Œ¥, u_2, f, a, Œ±', a, Œ≤, Œ≥, g, a, Œ±, Œ±', f', a, Œ≤, a, Œ±, Œ¥, g', a, Œ¥, Œ≥, h_left_anticomm, a, Œ±, b, Œ≤, f, g, a, b, g', f', b, a, h, a, none, h, b, none, none, b] (during elaboration)

{Œ± : Type u} {Œ≤ : Type v} {œÜ : Ultrafilter Œ±} [LinearOrder Œ≤] (x : Filter.Germ ‚Üë œÜ Œ≤) (y : Filter.Germ ‚Üë œÜ Œ≤) (a : (a : Œ±) ‚Üí Œ≤) (b : (a : Œ±) ‚Üí Œ≤) (h : ‚Üë b ‚â§ ‚Üë a) (h_1 : (le_total ‚Üë a ‚Üë b =: (‚Üë a ‚â§ ‚Üë b : Prop) ‚à® (‚Üë b ‚â§ ‚Üë a : Prop)) = (Or.inr h =: (‚Üë a ‚â§ ‚Üë b : Prop) ‚à® (‚Üë b ‚â§ ‚Üë a : Prop)))  : (Or.inr h) = (le_total ‚Üë a ‚Üë b)
<input>:1:188: expected term

{Œ© : Type u_1} [MeasurableSpace Œ©] [TopologicalSpace Œ©] [OpensMeasurableSpace Œ©] {Œº : MeasureTheory.FiniteMeasure Œ©} {fs : (a : ‚Ñï) ‚Üí BoundedContinuousFunction Œ© NNReal} {c : NNReal} (fs_le_const : ‚àÄ (n : ‚Ñï) (œâ : Œ©) , ‚Üë fs n œâ ‚â§ c) {f : BoundedContinuousFunction Œ© NNReal} (fs_lim : ‚àÄ (œâ : Œ©) , Filter.Tendsto fun (n : ‚Ñï) ‚Ü¶ ‚Üë fs n œâ Filter.atTop nhds ‚Üë f œâ) (n : ‚Ñï)  : ‚àÄ (œâ : Œ©) , ‚Üë fs n œâ ‚â§ c
type expected, got
  (Filter.Tendsto fun n => ?m.253 n : Filter ‚Ñï ‚Üí Filter ?m.244 ‚Üí Prop) ; identifiers [Œ©, u_1, MeasurableSpace, Œ©, TopologicalSpace, Œ©, OpensMeasurableSpace, Œ©, Œº, MeasureTheory.FiniteMeasure, Œ©, fs, a, BoundedContinuousFunction, Œ©, NNReal, c, NNReal, fs_le_const, n, œâ, Œ©, fs, n, œâ, c, f, BoundedContinuousFunction, Œ©, NNReal, fs_lim, œâ, Œ©, Filter.Tendsto, n, fs, n, œâ, Filter.atTop, nhds, f, œâ, n, œâ, Œ©, fs, n, œâ, c] (during elaboration)

{n : Type u'} {Œ± : Type v} [Fintype n] [DecidableEq n] [CommRing Œ±] (A : Matrix n n Œ±) (h : IsUnit Matrix.det A) (val : Invertible A) (h_1 : (IsUnit.nonempty_invertible (Iff.mpr (Matrix.isUnit_iff_isUnit_det A =: (IsUnit A : Prop) ‚Üî (IsUnit Matrix.det A : Prop)) h =: IsUnit A) =: Nonempty Invertible A) = (Nonempty.intro val =: Nonempty Invertible A))  : (Nonempty.intro val) = (IsUnit.nonempty_invertible (Iff.mpr (Matrix.isUnit_iff_isUnit_det A) h))
<input>:1:211: expected term

{Œ± : Type u_5} {Œ≤ : Type u_4} {Œ≥ : Type u_3} {a : Option Œ±} {b : Option Œ≤} {Œ±' : Type u_1} {Œ¥ : Type u_2} {f : (a : Œ±') ‚Üí (a : Œ≤) ‚Üí Œ≥} {g : (a : Œ±) ‚Üí Œ±'} {f' : (a : Œ≤) ‚Üí (a : Œ±) ‚Üí Œ¥} {g' : (a : Œ¥) ‚Üí Œ≥} (h_left_anticomm : ‚àÄ (a : Œ±) (b : Œ≤) , f g a b = g' f' b a) (h : a = none) (val : Œ≤) (h : b = some val)  : some val = b
application type mismatch
  f g
argument
  g
has type
  Œ± ‚Üí Œ±' : Type (max u_1 u_5)
but is expected to have type
  Œ±' : Type u_1 ; identifiers [Œ±, u_5, Œ≤, u_4, Œ≥, u_3, a, Option, Œ±, b, Option, Œ≤, Œ±', u_1, Œ¥, u_2, f, a, Œ±', a, Œ≤, Œ≥, g, a, Œ±, Œ±', f', a, Œ≤, a, Œ±, Œ¥, g', a, Œ¥, Œ≥, h_left_anticomm, a, Œ±, b, Œ≤, f, g, a, b, g', f', b, a, h, a, none, val, Œ≤, h, b, some, val, some, val, b] (during elaboration)

{Œ± : Type u_1} [PartialOrder Œ±] {a : Œ±}  : {a} = {a}
typeclass instance problem is stuck, it is often due to metavariables
  Singleton Œ± ?m.313 ; identifiers [Œ±, u_1, PartialOrder, Œ±, a, Œ±, a, a, a, a] (during elaboration)

(x : Num) (x_1 : ZNum) (m : Num) (p : PosNum) (a : PosNum) (h : m = Num.pos a) (h : ZNum.pos p = Num.toZNum Num.pos a) (h_1 : Num.toZNum Num.pos a = ZNum.pos p) (a_eq : a = p)  : p = a
application type mismatch
  Num.toZNum Num.pos
argument
  Num.pos
has type
  PosNum ‚Üí Num : Type
but is expected to have type
  Num : Type ; identifiers [x, Num, x_1, ZNum, m, Num, p, PosNum, a, PosNum, h, m, Num.pos, a, h, ZNum.pos, p, Num.toZNum, Num.pos, a, h_1, Num.toZNum, Num.pos, a, ZNum.pos, p, a_eq, a, p, p, a] (during elaboration)

{Œ± : Type u} {Œ≤ : Type u_1} [Group Œ±] [Preorder Œ±] [CovariantClass Œ± Œ± fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1 fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] [CovariantClass Œ± Œ± Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1 fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] [Preorder Œ≤] {f : (a : Œ≤) ‚Üí Œ±} {s : Set Œ≤} (hf : StrictAntiOn f s) (x : Œ≤) (hx : x ‚àà s) (x_1 : Œ≤) (hy : x_1 ‚àà s) (hxy : x < x_1)  : f x_1 < f x
function expected at
  x_1
term has type
  Œ± ; identifiers [Œ±, u, Œ≤, u_1, Group, Œ±, Preorder, Œ±, CovariantClass, Œ±, Œ±, x, Œ±, x_1, Œ±, x, x_1, x, Œ±, x_1, Œ±, x, x_1, CovariantClass, Œ±, Œ±, Function.swap, x, Œ±, x_1, Œ±, x, x_1, x, Œ±, x_1, Œ±, x, x_1, Preorder, Œ≤, f, a, Œ≤, Œ±, s, Set, Œ≤, hf, StrictAntiOn, f, s, x, Œ≤, hx, x, s, x_1, Œ≤, hy, x_1, s, hxy, x, x_1, f, x_1, f, x] (during elaboration)

{n : Type u'} {Œ± : Type v} [Fintype n] [DecidableEq n] [CommRing Œ±] (A : Matrix n n Œ±) (h : IsUnit Matrix.det A) (val : Invertible A) (h_1 : (IsUnit.nonempty_invertible (Iff.mpr (Matrix.isUnit_iff_isUnit_det A =: (IsUnit A : Prop) ‚Üî (IsUnit Matrix.det A : Prop)) h =: IsUnit A) =: Nonempty Invertible A) = (Nonempty.intro val =: Nonempty Invertible A))  : 1 = 1
<input>:1:211: expected term

{Œ± : Type u_5} {Œ≤ : Type u_4} {Œ≥ : Type u_3} {a : Option Œ±} {b : Option Œ≤} {Œ±' : Type u_1} {Œ¥ : Type u_2} {f : (a : Œ±') ‚Üí (a : Œ≤) ‚Üí Œ≥} {g : (a : Œ±) ‚Üí Œ±'} {f' : (a : Œ≤) ‚Üí (a : Œ±) ‚Üí Œ¥} {g' : (a : Œ¥) ‚Üí Œ≥} (h_left_anticomm : ‚àÄ (a : Œ±) (b : Œ≤) , f g a b = g' f' b a) (h : a = none)  : b = b
application type mismatch
  f g
argument
  g
has type
  Œ± ‚Üí Œ±' : Type (max u_1 u_5)
but is expected to have type
  Œ±' : Type u_1 ; identifiers [Œ±, u_5, Œ≤, u_4, Œ≥, u_3, a, Option, Œ±, b, Option, Œ≤, Œ±', u_1, Œ¥, u_2, f, a, Œ±', a, Œ≤, Œ≥, g, a, Œ±, Œ±', f', a, Œ≤, a, Œ±, Œ¥, g', a, Œ¥, Œ≥, h_left_anticomm, a, Œ±, b, Œ≤, f, g, a, b, g', f', b, a, h, a, none, b, b] (during elaboration)

(Œ± : Type u_1) [PartialOrder Œ±] [SupSet Œ±] (isLUB_sSup : ‚àÄ (s : Set Œ±) , IsLUB s sSup s) (s : Set Œ±) (a : Œ±) (ha : a ‚àà s)  : ‚àÄ (b : Œ±) (hb : b ‚àà lowerBounds s) , b ‚â§ a
application type mismatch
  IsLUB s sSup
argument
  sSup
has type
  Set ?m.25 ‚Üí ?m.25 : Type ?u.24
but is expected to have type
  Œ± : Type u_1 ; identifiers [Œ±, u_1, PartialOrder, Œ±, SupSet, Œ±, isLUB_sSup, s, Set, Œ±, IsLUB, s, sSup, s, s, Set, Œ±, a, Œ±, ha, a, s, b, Œ±, hb, b, lowerBounds, s, b, a] (during elaboration)

{Œ± : Type u_2} {Œ≤ : Type u_1} [Sub Œ±] [Zero Œ±] [Sub Œ≤] [Zero Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (h : ‚àÄ (x : Œ±) (y : Œ±) , f x - y = f x - f y) (h‚ÇÄ : f 0 = 0) (x : WithTop Œ±) (x_1 : WithTop Œ±) (x : Œ±) (y : Œ±)  : ‚àÄ (x : Œ±) (y : Œ±) , f x - y = f x - f y
failed to synthesize instance
  HSub Œ≤ Œ± ?m.159252 ; identifiers [Œ±, u_2, Œ≤, u_1, Sub, Œ±, Zero, Œ±, Sub, Œ≤, Zero, Œ≤, f, a, Œ±, Œ≤, h, x, Œ±, y, Œ±, f, x, y, f, x, f, y, h‚ÇÄ, f, x, WithTop, Œ±, x_1, WithTop, Œ±, x, Œ±, y, Œ±, x, Œ±, y, Œ±, f, x, y, f, x, f, y] (during elaboration)

{Œ± : Type u_5} {Œ≤ : Type u_4} {Œ≥ : Type u_3} {a : Option Œ±} {b : Option Œ≤} {Œ±' : Type u_1} {Œ¥ : Type u_2} {f : (a : Œ±') ‚Üí (a : Œ≤) ‚Üí Œ≥} {g : (a : Œ±) ‚Üí Œ±'} {f' : (a : Œ≤) ‚Üí (a : Œ±) ‚Üí Œ¥} {g' : (a : Œ¥) ‚Üí Œ≥} (h_left_anticomm : ‚àÄ (a : Œ±) (b : Œ≤) , f g a b = g' f' b a) (val : Œ±) (h : a = some val)  : some val = a
application type mismatch
  f g
argument
  g
has type
  Œ± ‚Üí Œ±' : Type (max u_1 u_5)
but is expected to have type
  Œ±' : Type u_1 ; identifiers [Œ±, u_5, Œ≤, u_4, Œ≥, u_3, a, Option, Œ±, b, Option, Œ≤, Œ±', u_1, Œ¥, u_2, f, a, Œ±', a, Œ≤, Œ≥, g, a, Œ±, Œ±', f', a, Œ≤, a, Œ±, Œ¥, g', a, Œ¥, Œ≥, h_left_anticomm, a, Œ±, b, Œ≤, f, g, a, b, g', f', b, a, val, Œ±, h, a, some, val, some, val, a] (during elaboration)

{C : Type u_4} [CategoryTheory.Category C] {D : Type u_2} [CategoryTheory.Category D] {S : D} {T : CategoryTheory.Functor C D} {f : CategoryTheory.StructuredArrow S T} {f' : CategoryTheory.StructuredArrow S T} (g : CategoryTheory.Comma.right f ‚ü∂ CategoryTheory.Comma.right f') (w : autoParam (CategoryTheory.CategoryStruct.comp CategoryTheory.Comma.hom f CategoryTheory.Functor.toPrefunctor T . map g = CategoryTheory.Comma.hom f' : Prop) _auto._@.Mathlib.CategoryTheory.StructuredArrow._hyg.577)  : CategoryTheory.Comma.hom f' = CategoryTheory.CategoryStruct.comp CategoryTheory.Comma.hom f CategoryTheory.Functor.toPrefunctor T . map g
function expected at
  CategoryTheory.CategoryStruct.comp ?m.86056 ?m.165836
term has type
  ?m.3979 ‚ü∂ ?m.3981 ; identifiers [C, u_4, CategoryTheory.Category, C, D, u_2, CategoryTheory.Category, D, S, D, T, CategoryTheory.Functor, C, D, f, CategoryTheory.StructuredArrow, S, T, f', CategoryTheory.StructuredArrow, S, T, g, CategoryTheory.Comma.right, f, CategoryTheory.Comma.right, f', w, autoParam, CategoryTheory.CategoryStruct.comp, CategoryTheory.Comma.hom, f, CategoryTheory.Functor.toPrefunctor, T, map, g, CategoryTheory.Comma.hom, f', _auto._, Mathlib.CategoryTheory.StructuredArrow._hyg, CategoryTheory.Comma.hom, f', CategoryTheory.CategoryStruct.comp, CategoryTheory.Comma.hom, f, CategoryTheory.Functor.toPrefunctor, T, map, g] (during elaboration)

 : (‚àÄ (R : Type u_2) {M : Type u_1} [inst : Ring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (a : M) (b : M) , a - b = a - b)
failed to synthesize instance
  HSub M M ?m.750 ; identifiers [R, u_2, M, u_1, inst, Ring, R, inst_1, AddCommMonoid, M, inst_2, Module, R, M, a, M, b, M, a, b, a, b] (during elaboration)

 : ‚àÄ (R : Type u_2) {M : Type u_1} [inst : Ring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (a : M) (b : M) , a - b = a - b
failed to synthesize instance
  HSub M M ?m.750 ; identifiers [R, u_2, M, u_1, inst, Ring, R, inst_1, AddCommMonoid, M, inst_2, Module, R, M, a, M, b, M, a, b, a, b] (during elaboration)

{V : Type u} (s : Set Sym2 V) (t : Set Sym2 V) (v : V) (w : V) em : (a : Prop) ‚Üí Decidable (a : Prop) := Classical.propDecidable (a : ((Quotient.mk Sym2.Rel.setoid V (v , w) ‚àà s : Prop) ‚àß (¬¨ (v = w : Prop) : Prop) : Prop) ‚àß ((Quotient.mk Sym2.Rel.setoid V (v , w) ‚àà t : Prop) ‚àß (¬¨ (v = w : Prop) : Prop) : Prop)) (left : (Quotient.mk Sym2.Rel.setoid V (v , w) ‚àà s : Prop) ‚àß (¬¨ (v = w : Prop) : Prop)) (right : (Quotient.mk Sym2.Rel.setoid V (v , w) ‚àà t : Prop) ‚àß (¬¨ (v = w : Prop) : Prop)) (left : Quotient.mk Sym2.Rel.setoid V (v , w) ‚àà s) (right_1 : ¬¨ (v = w : Prop)) (left_1 : Quotient.mk Sym2.Rel.setoid V (v , w) ‚àà t) (right : ¬¨ (v = w : Prop))  : (Quotient.mk Sym2.Rel.setoid V (v , w) ‚àà s) ‚àß (Quotient.mk Sym2.Rel.setoid V (v , w) ‚àà t)
<input>:1:66: expected end of input

{R : Type u} {M : Type v} [CommSemiring R] [AddCommMonoid M] [Module R M] ‚¶É v : Module.Dual R M ‚¶Ñ  : (v ‚àà ‚ä•) = (v ‚àà ‚ä•)
typeclass instance problem is stuck, it is often due to metavariables
  Membership (Module.Dual R M) ?m.1591 ; identifiers [R, u, M, v, CommSemiring, R, AddCommMonoid, M, Module, R, M, v, Module.Dual, R, M, v, v] (during elaboration)

{Œ± : Type u_5} {Œ≤ : Type u_4} {Œ≥ : Type u_3} {a : Option Œ±} {b : Option Œ≤} {Œ±' : Type u_1} {Œ¥ : Type u_2} {f : (a : Œ±') ‚Üí (a : Œ≤) ‚Üí Œ≥} {g : (a : Œ±) ‚Üí Œ±'} {f' : (a : Œ≤) ‚Üí (a : Œ±) ‚Üí Œ¥} {g' : (a : Œ¥) ‚Üí Œ≥} (h_left_anticomm : ‚àÄ (a : Œ±) (b : Œ≤) , f g a b = g' f' b a) (val : Œ±) (h : a = some val) (h : b = none)  : none = b
application type mismatch
  f g
argument
  g
has type
  Œ± ‚Üí Œ±' : Type (max u_1 u_5)
but is expected to have type
  Œ±' : Type u_1 ; identifiers [Œ±, u_5, Œ≤, u_4, Œ≥, u_3, a, Option, Œ±, b, Option, Œ≤, Œ±', u_1, Œ¥, u_2, f, a, Œ±', a, Œ≤, Œ≥, g, a, Œ±, Œ±', f', a, Œ≤, a, Œ±, Œ¥, g', a, Œ¥, Œ≥, h_left_anticomm, a, Œ±, b, Œ≤, f, g, a, b, g', f', b, a, val, Œ±, h, a, some, val, h, b, none, none, b] (during elaboration)

{V : Type u} (s : Set Sym2 V) (t : Set Sym2 V) (v : V) (w : V) em : (a : Prop) ‚Üí Decidable (a : Prop) := Classical.propDecidable (a : ((Quotient.mk Sym2.Rel.setoid V (v , w) ‚àà s : Prop) ‚àß (Quotient.mk Sym2.Rel.setoid V (v , w) ‚àà t : Prop) : Prop) ‚àß (¬¨ (v = w : Prop) : Prop)) (left : (Quotient.mk Sym2.Rel.setoid V (v , w) ‚àà s : Prop) ‚àß (Quotient.mk Sym2.Rel.setoid V (v , w) ‚àà t : Prop)) (right : ¬¨ (v = w : Prop)) (left : Quotient.mk Sym2.Rel.setoid V (v , w) ‚àà s) (right_1 : Quotient.mk Sym2.Rel.setoid V (v , w) ‚àà t)  : (Quotient.mk Sym2.Rel.setoid V (v , w) ‚àà s) ‚àß (¬¨ (v = w))
<input>:1:66: expected end of input

{V : Type u} (s : Set Sym2 V) (t : Set Sym2 V) (v : V) (w : V) em : (a : Prop) ‚Üí Decidable (a : Prop) := Classical.propDecidable (a : ((Quotient.mk Sym2.Rel.setoid V (v , w) ‚àà s : Prop) ‚àß (Quotient.mk Sym2.Rel.setoid V (v , w) ‚àà t : Prop) : Prop) ‚àß (¬¨ (v = w : Prop) : Prop)) (left : (Quotient.mk Sym2.Rel.setoid V (v , w) ‚àà s : Prop) ‚àß (Quotient.mk Sym2.Rel.setoid V (v , w) ‚àà t : Prop)) (right : ¬¨ (v = w : Prop)) (left : Quotient.mk Sym2.Rel.setoid V (v , w) ‚àà s) (right_1 : Quotient.mk Sym2.Rel.setoid V (v , w) ‚àà t)  : (Quotient.mk Sym2.Rel.setoid V (v , w) ‚àà t) ‚àß (¬¨ (v = w))
<input>:1:66: expected end of input

 : (‚àÄ {C : Type u_2} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] {S‚ÇÅ : CategoryTheory.ShortComplex C} {S‚ÇÇ : CategoryTheory.ShortComplex C} (œÜ : S‚ÇÅ ‚ü∂ S‚ÇÇ) (c‚ÇÅ : CategoryTheory.Limits.CokernelCofork CategoryTheory.ShortComplex.f S‚ÇÅ) (c‚ÇÇ : CategoryTheory.Limits.CokernelCofork CategoryTheory.ShortComplex.f S‚ÇÇ) (f : CategoryTheory.Limits.Cocone.pt c‚ÇÅ ‚ü∂ CategoryTheory.Limits.Cocone.pt c‚ÇÇ) (comm : CategoryTheory.CategoryStruct.comp CategoryTheory.ShortComplex.Hom.œÑ‚ÇÇ œÜ CategoryTheory.Limits.Cofork.œÄ c‚ÇÇ = CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.Cofork.œÄ c‚ÇÅ f) , CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.Cofork.œÄ c‚ÇÅ f = CategoryTheory.CategoryStruct.comp CategoryTheory.ShortComplex.Hom.œÑ‚ÇÇ œÜ CategoryTheory.Limits.Cofork.œÄ c‚ÇÇ)
function expected at
  CategoryTheory.Limits.CokernelCofork ?m.83128
term has type
  Type (max ?u.147 ?u.148) ; identifiers [C, u_2, inst, CategoryTheory.Category, C, inst_1, CategoryTheory.Limits.HasZeroMorphisms, C, S‚ÇÅ, CategoryTheory.ShortComplex, C, S‚ÇÇ, CategoryTheory.ShortComplex, C, œÜ, S‚ÇÅ, S‚ÇÇ, c‚ÇÅ, CategoryTheory.Limits.CokernelCofork, CategoryTheory.ShortComplex.f, S‚ÇÅ, c‚ÇÇ, CategoryTheory.Limits.CokernelCofork, CategoryTheory.ShortComplex.f, S‚ÇÇ, f, CategoryTheory.Limits.Cocone.pt, c‚ÇÅ, CategoryTheory.Limits.Cocone.pt, c‚ÇÇ, comm, CategoryTheory.CategoryStruct.comp, CategoryTheory.ShortComplex.Hom.œÑ‚ÇÇ, œÜ, CategoryTheory.Limits.Cofork.œÄ, c‚ÇÇ, CategoryTheory.CategoryStruct.comp, CategoryTheory.Limits.Cofork.œÄ, c‚ÇÅ, f, CategoryTheory.CategoryStruct.comp, CategoryTheory.Limits.Cofork.œÄ, c‚ÇÅ, f, CategoryTheory.CategoryStruct.comp, CategoryTheory.ShortComplex.Hom.œÑ‚ÇÇ, œÜ, CategoryTheory.Limits.Cofork.œÄ, c‚ÇÇ] (during elaboration)

 : ‚àÄ {C : Type u_2} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] {S‚ÇÅ : CategoryTheory.ShortComplex C} {S‚ÇÇ : CategoryTheory.ShortComplex C} (œÜ : S‚ÇÅ ‚ü∂ S‚ÇÇ) (c‚ÇÅ : CategoryTheory.Limits.CokernelCofork CategoryTheory.ShortComplex.f S‚ÇÅ) (c‚ÇÇ : CategoryTheory.Limits.CokernelCofork CategoryTheory.ShortComplex.f S‚ÇÇ) (f : CategoryTheory.Limits.Cocone.pt c‚ÇÅ ‚ü∂ CategoryTheory.Limits.Cocone.pt c‚ÇÇ) (comm : CategoryTheory.CategoryStruct.comp CategoryTheory.ShortComplex.Hom.œÑ‚ÇÇ œÜ CategoryTheory.Limits.Cofork.œÄ c‚ÇÇ = CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.Cofork.œÄ c‚ÇÅ f) , CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.Cofork.œÄ c‚ÇÅ f = CategoryTheory.CategoryStruct.comp CategoryTheory.ShortComplex.Hom.œÑ‚ÇÇ œÜ CategoryTheory.Limits.Cofork.œÄ c‚ÇÇ
function expected at
  CategoryTheory.Limits.CokernelCofork ?m.83128
term has type
  Type (max ?u.147 ?u.148) ; identifiers [C, u_2, inst, CategoryTheory.Category, C, inst_1, CategoryTheory.Limits.HasZeroMorphisms, C, S‚ÇÅ, CategoryTheory.ShortComplex, C, S‚ÇÇ, CategoryTheory.ShortComplex, C, œÜ, S‚ÇÅ, S‚ÇÇ, c‚ÇÅ, CategoryTheory.Limits.CokernelCofork, CategoryTheory.ShortComplex.f, S‚ÇÅ, c‚ÇÇ, CategoryTheory.Limits.CokernelCofork, CategoryTheory.ShortComplex.f, S‚ÇÇ, f, CategoryTheory.Limits.Cocone.pt, c‚ÇÅ, CategoryTheory.Limits.Cocone.pt, c‚ÇÇ, comm, CategoryTheory.CategoryStruct.comp, CategoryTheory.ShortComplex.Hom.œÑ‚ÇÇ, œÜ, CategoryTheory.Limits.Cofork.œÄ, c‚ÇÇ, CategoryTheory.CategoryStruct.comp, CategoryTheory.Limits.Cofork.œÄ, c‚ÇÅ, f, CategoryTheory.CategoryStruct.comp, CategoryTheory.Limits.Cofork.œÄ, c‚ÇÅ, f, CategoryTheory.CategoryStruct.comp, CategoryTheory.ShortComplex.Hom.œÑ‚ÇÇ, œÜ, CategoryTheory.Limits.Cofork.œÄ, c‚ÇÇ] (during elaboration)

{R : Type u_2} [CommSemiring R] {A : Type u_1} [CommSemiring A] [Algebra R A] (I : Submodule R A) (J : Submodule R A) (r : R) (x : A) (hx : x ‚àà AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup {toAddSubsemigroup := (({carrier := (({x : A | ‚àÄ (y : A) (a : y ‚àà J) , x * y ‚àà I})) , add_mem' := (((fun {a : A} {b : A} (ha : a ‚àà {x : A | ‚àÄ (y : A) (a : y ‚àà J) , x * y ‚àà I}) (hb : b ‚àà {x : A | ‚àÄ (y : A) (a : y ‚àà J) , x * y ‚àà I}) (y : A) (hy : y ‚àà J) ‚Ü¶ Eq.mpr (id ((add_mul a b y =: a + b * y = a * y + b * y) ‚ñ∏ (Eq.refl (a + b * y ‚àà I : Prop) =: (a + b * y ‚àà I : Prop) = (a + b * y ‚àà I : Prop)) =: (a + b * y ‚àà I : Prop) = (a * y + b * y ‚àà I : Prop)) =: (a + b * y ‚àà I : Prop) = (a * y + b * y ‚àà I : Prop)) (Submodule.add_mem I (ha y hy =: a * y ‚àà I) (hb y hy =: b * y ‚àà I) =: a * y + b * y ‚àà I) =: ‚àÄ {a : A} {b : A} (ha : a ‚àà {x : A | ‚àÄ (y : A) (a : y ‚àà J) , x * y ‚àà I}) (hb : b ‚àà {x : A | ‚àÄ (y : A) (a : y ‚àà J) , x * y ‚àà I}) (y : A) (hy : y ‚àà J) , a + b * y ‚àà I)))})) , zero_mem' := (((fun (y : A) (x : y ‚àà J) ‚Ü¶ Eq.mpr (id ((zero_mul y =: 0 * y = 0) ‚ñ∏ (Eq.refl (0 * y ‚àà I : Prop) =: (0 * y ‚àà I : Prop) = (0 * y ‚àà I : Prop)) =: (0 * y ‚àà I : Prop) = (0 ‚àà I : Prop)) =: (0 * y ‚àà I : Prop) = (0 ‚àà I : Prop)) (Submodule.zero_mem I =: 0 ‚àà I) =: ‚àÄ (y : A) (x : y ‚àà J) , 0 * y ‚àà I)))}) (y : A) (hy : y ‚àà J)  : (r ‚Ä¢ x * y ‚àà I) = (r ‚Ä¢ x * y ‚àà I)
<input>:1:481: expected term

{Œ± : Type u_5} {Œ≤ : Type u_4} {Œ≥ : Type u_3} {a : Option Œ±} {b : Option Œ≤} {Œ±' : Type u_1} {Œ¥ : Type u_2} {f : (a : Œ±') ‚Üí (a : Œ≤) ‚Üí Œ≥} {g : (a : Œ±) ‚Üí Œ±'} {f' : (a : Œ≤) ‚Üí (a : Œ±) ‚Üí Œ¥} {g' : (a : Œ¥) ‚Üí Œ≥} (h_left_anticomm : ‚àÄ (a : Œ±) (b : Œ≤) , f g a b = g' f' b a) (val : Œ±) (h : a = some val) (val_1 : Œ≤) (h : b = some val_1)  : some val_1 = b
application type mismatch
  f g
argument
  g
has type
  Œ± ‚Üí Œ±' : Type (max u_1 u_5)
but is expected to have type
  Œ±' : Type u_1 ; identifiers [Œ±, u_5, Œ≤, u_4, Œ≥, u_3, a, Option, Œ±, b, Option, Œ≤, Œ±', u_1, Œ¥, u_2, f, a, Œ±', a, Œ≤, Œ≥, g, a, Œ±, Œ±', f', a, Œ≤, a, Œ±, Œ¥, g', a, Œ¥, Œ≥, h_left_anticomm, a, Œ±, b, Œ≤, f, g, a, b, g', f', b, a, val, Œ±, h, a, some, val, val_1, Œ≤, h, b, some, val_1, some, val_1, b] (during elaboration)

{L : FirstOrder.Language} {M : Type w} [FirstOrder.Language.Structure L M] (s : Set M) {p : (x : M) ‚Üí (a : x ‚àà LowerAdjoint.toFun FirstOrder.Language.Substructure.closure L s) ‚Üí Prop} (Hs : ‚àÄ (x : M) (h : x ‚àà s) , p x (FirstOrder.Language.Substructure.subset_closure h =: x ‚àà ‚Üë LowerAdjoint.toFun FirstOrder.Language.Substructure.closure L s)) (Hfun : ‚àÄ {n : ‚Ñï} (f : FirstOrder.Language.Functions L n) , FirstOrder.Language.ClosedUnder f {x : M | ‚àÉ (hx : x ‚àà LowerAdjoint.toFun FirstOrder.Language.Substructure.closure L s) , p x hx}) {x : M} (hx : x ‚àà LowerAdjoint.toFun FirstOrder.Language.Substructure.closure L s) (x : M) (hx : x ‚àà s)  : p x (FirstOrder.Language.Substructure.subset_closure hx)
<input>:1:270: expected term

{V : Type u_1} {v : V} {w : V} {a : V} {b : V} (h : fun (a : V) (b : V) ‚Ü¶ Quotient.mk Sym2.Rel.setoid V (v , w) = Quotient.mk Sym2.Rel.setoid V (a , b) a b) (Œ± : outParam Type u_1) (Œ≥ : Type u_1) (self : Membership Œ± Œ≥) (a : Œ±) (a_1 : Œ≥) (a' : Œ≥) (e'_5 : a_1 = a') (h : a' = a_1) (a' : Œ≥)  : a_1 = a_1
function expected at
  Quotient.mk ?m.79591 V
term has type
  Quotient ?m.79591 ; identifiers [V, u_1, v, V, w, V, a, V, b, V, h, a, V, b, V, Quotient.mk, Sym2.Rel.setoid, V, v, w, Quotient.mk, Sym2.Rel.setoid, V, a, b, a, b, Œ±, outParam, u_1, Œ≥, u_1, self, Membership, Œ±, Œ≥, a, Œ±, a_1, Œ≥, a', Œ≥, e'_5, a_1, a', h, a', a_1, a', Œ≥, a_1, a_1] (during elaboration)

{R : Type u_2} [CommSemiring R] {A : Type u_1} [CommSemiring A] [Algebra R A] (I : Submodule R A) (J : Submodule R A) (r : R) (x : A) (hx : x ‚àà AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup {toAddSubsemigroup := (({carrier := (({x : A | ‚àÄ (y : A) (a : y ‚àà J) , x * y ‚àà I})) , add_mem' := (((fun {a : A} {b : A} (ha : a ‚àà {x : A | ‚àÄ (y : A) (a : y ‚àà J) , x * y ‚àà I}) (hb : b ‚àà {x : A | ‚àÄ (y : A) (a : y ‚àà J) , x * y ‚àà I}) (y : A) (hy : y ‚àà J) ‚Ü¶ Eq.mpr (id ((add_mul a b y =: a + b * y = a * y + b * y) ‚ñ∏ (Eq.refl (a + b * y ‚àà I : Prop) =: (a + b * y ‚àà I : Prop) = (a + b * y ‚àà I : Prop)) =: (a + b * y ‚àà I : Prop) = (a * y + b * y ‚àà I : Prop)) =: (a + b * y ‚àà I : Prop) = (a * y + b * y ‚àà I : Prop)) (Submodule.add_mem I (ha y hy =: a * y ‚àà I) (hb y hy =: b * y ‚àà I) =: a * y + b * y ‚àà I) =: ‚àÄ {a : A} {b : A} (ha : a ‚àà {x : A | ‚àÄ (y : A) (a : y ‚àà J) , x * y ‚àà I}) (hb : b ‚àà {x : A | ‚àÄ (y : A) (a : y ‚àà J) , x * y ‚àà I}) (y : A) (hy : y ‚àà J) , a + b * y ‚àà I)))})) , zero_mem' := (((fun (y : A) (x : y ‚àà J) ‚Ü¶ Eq.mpr (id ((zero_mul y =: 0 * y = 0) ‚ñ∏ (Eq.refl (0 * y ‚àà I : Prop) =: (0 * y ‚àà I : Prop) = (0 * y ‚àà I : Prop)) =: (0 * y ‚àà I : Prop) = (0 ‚àà I : Prop)) =: (0 * y ‚àà I : Prop) = (0 ‚àà I : Prop)) (Submodule.zero_mem I =: 0 ‚àà I) =: ‚àÄ (y : A) (x : y ‚àà J) , 0 * y ‚àà I)))}) (y : A) (hy : y ‚àà J)  : x * y ‚àà I
<input>:1:481: expected term

{L : FirstOrder.Language} {M : Type w} [FirstOrder.Language.Structure L M] (s : Set M) {p : (x : M) ‚Üí (a : x ‚àà LowerAdjoint.toFun FirstOrder.Language.Substructure.closure L s) ‚Üí Prop} (Hs : ‚àÄ (x : M) (h : x ‚àà s) , p x (FirstOrder.Language.Substructure.subset_closure h =: x ‚àà ‚Üë LowerAdjoint.toFun FirstOrder.Language.Substructure.closure L s)) (Hfun : ‚àÄ {n : ‚Ñï} (f : FirstOrder.Language.Functions L n) , FirstOrder.Language.ClosedUnder f {x : M | ‚àÉ (hx : x ‚àà LowerAdjoint.toFun FirstOrder.Language.Substructure.closure L s) , p x hx}) {x : M} (hx : x ‚àà LowerAdjoint.toFun FirstOrder.Language.Substructure.closure L s)  : ‚àÄ (hx : x ‚àà LowerAdjoint.toFun FirstOrder.Language.Substructure.closure L s) (hc : p x hx) , p x hx
<input>:1:270: expected term

{V : Type u_1} {v : V} {w : V} {a : V} {b : V} (h : fun (a : V) (b : V) ‚Ü¶ Quotient.mk Sym2.Rel.setoid V (v , w) = Quotient.mk Sym2.Rel.setoid V (a , b) a b) (Œ± : outParam Type u_1) (Œ≥ : Type u_1) (self : Membership Œ± Œ≥) (a : Œ±) (a_1 : Œ≥) (a' : Œ≥) (e'_5 : a_1 = a') (h : a' = a_1)  : a_1 = a'
function expected at
  Quotient.mk ?m.79591 V
term has type
  Quotient ?m.79591 ; identifiers [V, u_1, v, V, w, V, a, V, b, V, h, a, V, b, V, Quotient.mk, Sym2.Rel.setoid, V, v, w, Quotient.mk, Sym2.Rel.setoid, V, a, b, a, b, Œ±, outParam, u_1, Œ≥, u_1, self, Membership, Œ±, Œ≥, a, Œ±, a_1, Œ≥, a', Œ≥, e'_5, a_1, a', h, a', a_1, a_1, a'] (during elaboration)

{V : Type u_1} {v : V} {w : V} {a : V} {b : V} (h : fun (a : V) (b : V) ‚Ü¶ Quotient.mk Sym2.Rel.setoid V (v , w) = Quotient.mk Sym2.Rel.setoid V (a , b) a b) (Œ± : outParam Type u_1) (Œ≥ : Type u_1) (self : Membership Œ± Œ≥) (a : Œ±) (a_1 : Œ≥) (a' : Œ≥) (e'_5 : a_1 = a')  : a' = a'
function expected at
  Quotient.mk ?m.79591 V
term has type
  Quotient ?m.79591 ; identifiers [V, u_1, v, V, w, V, a, V, b, V, h, a, V, b, V, Quotient.mk, Sym2.Rel.setoid, V, v, w, Quotient.mk, Sym2.Rel.setoid, V, a, b, a, b, Œ±, outParam, u_1, Œ≥, u_1, self, Membership, Œ±, Œ≥, a, Œ±, a_1, Œ≥, a', Œ≥, e'_5, a_1, a', a', a'] (during elaboration)

(L : FirstOrder.Language) {Œ± : Type u'} {M : Type w} [FirstOrder.Language.Structure FirstOrder.Language.withConstants L Œ± M] (s : Set Œ±) (h : Set.InjOn fun (i : Œ±) ‚Ü¶ ‚Üë FirstOrder.Language.con L i s) (œÜ : FirstOrder.Language.Sentence FirstOrder.Language.withConstants L Œ±) (a : Œ±) (b : Œ±) (a_1 : (a , b) ‚àà s √óÀ¢ s ‚à© Set.diagonal Œ± ·∂ú) (left : (a , b) ‚àà s √óÀ¢ s) (ab : (a , b) ‚àà Set.diagonal Œ± ·∂ú) (as : Prod.fst (a , b) ‚àà s) (bs : Prod.snd (a , b) ‚àà s) (a_2 : FirstOrder.Language.Formula.not FirstOrder.Language.Term.equal FirstOrder.Language.Constants.term FirstOrder.Language.con L a FirstOrder.Language.Constants.term FirstOrder.Language.con L b = œÜ) (contra : ‚Üë FirstOrder.Language.con L a = ‚Üë FirstOrder.Language.con L b)  : Prod.fst (a , b) = Prod.snd (a , b)
application type mismatch
  FirstOrder.Language.Structure FirstOrder.Language.withConstants
argument
  FirstOrder.Language.withConstants
has type
  FirstOrder.Language ‚Üí Type ?u.17 ‚Üí FirstOrder.Language : Type (max (max (?u.17 + 1) (?u.18 + 1)) (?u.19 + 1))
but is expected to have type
  FirstOrder.Language : Type (max (?u.16 + 1) (?u.15 + 1)) ; identifiers [L, FirstOrder.Language, Œ±, u', M, w, FirstOrder.Language.Structure, FirstOrder.Language.withConstants, L, Œ±, M, s, Set, Œ±, h, Set.InjOn, i, Œ±, FirstOrder.Language.con, L, i, s, œÜ, FirstOrder.Language.Sentence, FirstOrder.Language.withConstants, L, Œ±, a, Œ±, b, Œ±, a_1, a, b, s, s, Set.diagonal, Œ±, left, a, b, s, s, ab, a, b, Set.diagonal, Œ±, as, Prod.fst, a, b, s, bs, Prod.snd, a, b, s, a_2, FirstOrder.Language.Formula.not, FirstOrder.Language.Term.equal, FirstOrder.Language.Constants.term, FirstOrder.Language.con, L, a, FirstOrder.Language.Constants.term, FirstOrder.Language.con, L, b, œÜ, contra, FirstOrder.Language.con, L, a, FirstOrder.Language.con, L, b, Prod.fst, a, b, Prod.snd, a, b] (during elaboration)

 : (‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroObject C] [inst_2 : CategoryTheory.Limits.HasZeroMorphisms C] [inst_3 : CategoryTheory.Limits.HasEqualizers C] [inst_4 : CategoryTheory.Limits.HasImages C] {Z : C} (self : CategoryTheory.InjectiveResolution Z) , CategoryTheory.Mono HomologicalComplex.Hom.f CategoryTheory.InjectiveResolution.Œπ self 0)
function expected at
  CategoryTheory.Mono ?m.83987
term has type
  Prop ; identifiers [C, u, inst, CategoryTheory.Category, C, inst_1, CategoryTheory.Limits.HasZeroObject, C, inst_2, CategoryTheory.Limits.HasZeroMorphisms, C, inst_3, CategoryTheory.Limits.HasEqualizers, C, inst_4, CategoryTheory.Limits.HasImages, C, Z, C, self, CategoryTheory.InjectiveResolution, Z, CategoryTheory.Mono, HomologicalComplex.Hom.f, CategoryTheory.InjectiveResolution.Œπ, self] (during elaboration)

 : ‚àÄ (C : Type u) [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroObject C] [inst_2 : CategoryTheory.Limits.HasZeroMorphisms C] [inst_3 : CategoryTheory.Limits.HasEqualizers C] [inst_4 : CategoryTheory.Limits.HasImages C] (Z : C) (self : CategoryTheory.InjectiveResolution Z) , CategoryTheory.Mono HomologicalComplex.Hom.f self . 2 0
function expected at
  CategoryTheory.Mono ?m.83987
term has type
  Prop ; identifiers [C, u, inst, CategoryTheory.Category, C, inst_1, CategoryTheory.Limits.HasZeroObject, C, inst_2, CategoryTheory.Limits.HasZeroMorphisms, C, inst_3, CategoryTheory.Limits.HasEqualizers, C, inst_4, CategoryTheory.Limits.HasImages, C, Z, C, self, CategoryTheory.InjectiveResolution, Z, CategoryTheory.Mono, HomologicalComplex.Hom.f, self] (during elaboration)

{x : PGame}  : ((IsEmpty PGame.LeftMoves x) ‚àß (IsEmpty PGame.RightMoves x)) ‚Üî ((IsEmpty PGame.LeftMoves x) ‚àß (IsEmpty PGame.RightMoves x))
application type mismatch
  IsEmpty PGame.LeftMoves
argument
  PGame.LeftMoves
has type
  PGame ‚Üí Type ?u.7 : Type (?u.7 + 1)
but is expected to have type
  Sort ?u.6 : Type ?u.6 ; identifiers [x, PGame, IsEmpty, PGame.LeftMoves, x, IsEmpty, PGame.RightMoves, x, IsEmpty, PGame.LeftMoves, x, IsEmpty, PGame.RightMoves, x] (during elaboration)

{M : Type u_1} [Mul M] [Subsingleton Subsemigroup M] (x : M) (y : M) (this : ‚àÄ (a : M) , a ‚àà ‚ä•)  : x ‚àà ‚ä•
application type mismatch
  Subsingleton Subsemigroup
argument
  Subsemigroup
has type
  (M : Type ?u.11) ‚Üí [inst : Mul M] ‚Üí Type ?u.11 : Type (?u.11 + 1)
but is expected to have type
  Sort ?u.10 : Type ?u.10 ; identifiers [M, u_1, Mul, M, Subsingleton, Subsemigroup, M, x, M, y, M, this, a, M, a, x] (during elaboration)

{Œ± : Type u_5} {Œ≤ : Type u_4} {Œ≥ : Type u_3} {a : Option Œ±} {b : Option Œ≤} {Œ±' : Type u_1} {Œ¥ : Type u_2} {f : (a : Œ±') ‚Üí (a : Œ≤) ‚Üí Œ≥} {g : (a : Œ±) ‚Üí Œ±'} {f' : (a : Œ≤) ‚Üí (a : Œ±) ‚Üí Œ¥} {g' : (a : Œ¥) ‚Üí Œ≥} (h_left_anticomm : ‚àÄ (a : Œ±) (b : Œ≤) , f g a b = g' f' b a) (val : Œ±) (h : a = some val) (val_1 : Œ≤) (h : b = some val_1)  : ‚àÄ (a : Œ±) (b : Œ≤) , f g a b = g' f' b a
application type mismatch
  f g
argument
  g
has type
  Œ± ‚Üí Œ±' : Type (max u_1 u_5)
but is expected to have type
  Œ±' : Type u_1 ; identifiers [Œ±, u_5, Œ≤, u_4, Œ≥, u_3, a, Option, Œ±, b, Option, Œ≤, Œ±', u_1, Œ¥, u_2, f, a, Œ±', a, Œ≤, Œ≥, g, a, Œ±, Œ±', f', a, Œ≤, a, Œ±, Œ¥, g', a, Œ¥, Œ≥, h_left_anticomm, a, Œ±, b, Œ≤, f, g, a, b, g', f', b, a, val, Œ±, h, a, some, val, val_1, Œ≤, h, b, some, val_1, a, Œ±, b, Œ≤, f, g, a, b, g', f', b, a] (during elaboration)

{Œ± : Type u_5} {Œ≤ : Type u_4} {Œ≥ : Type u_3} {a : Option Œ±} {b : Option Œ≤} {Œ±' : Type u_1} {Œ¥ : Type u_2} {f : (a : Œ±') ‚Üí (a : Œ≤) ‚Üí Œ≥} {g : (a : Œ±) ‚Üí Œ±'} {f' : (a : Œ≤) ‚Üí (a : Œ±) ‚Üí Œ¥} {g' : (a : Œ¥) ‚Üí Œ≥} (h_left_anticomm : ‚àÄ (a : Œ±) (b : Œ≤) , f g a b = g' f' b a) (val : Œ±) (h : a = some val)  : b = b
application type mismatch
  f g
argument
  g
has type
  Œ± ‚Üí Œ±' : Type (max u_1 u_5)
but is expected to have type
  Œ±' : Type u_1 ; identifiers [Œ±, u_5, Œ≤, u_4, Œ≥, u_3, a, Option, Œ±, b, Option, Œ≤, Œ±', u_1, Œ¥, u_2, f, a, Œ±', a, Œ≤, Œ≥, g, a, Œ±, Œ±', f', a, Œ≤, a, Œ±, Œ¥, g', a, Œ¥, Œ≥, h_left_anticomm, a, Œ±, b, Œ≤, f, g, a, b, g', f', b, a, val, Œ±, h, a, some, val, b, b] (during elaboration)

{Œ± : Type u_5} {Œ≤ : Type u_4} {Œ≥ : Type u_3} {a : Option Œ±} {b : Option Œ≤} {Œ±' : Type u_1} {Œ¥ : Type u_2} {f : (a : Œ±') ‚Üí (a : Œ≤) ‚Üí Œ≥} {g : (a : Œ±) ‚Üí Œ±'} {f' : (a : Œ≤) ‚Üí (a : Œ±) ‚Üí Œ¥} {g' : (a : Œ¥) ‚Üí Œ≥} (h_left_anticomm : ‚àÄ (a : Œ±) (b : Œ≤) , f g a b = g' f' b a)  : a = a
application type mismatch
  f g
argument
  g
has type
  Œ± ‚Üí Œ±' : Type (max u_1 u_5)
but is expected to have type
  Œ±' : Type u_1 ; identifiers [Œ±, u_5, Œ≤, u_4, Œ≥, u_3, a, Option, Œ±, b, Option, Œ≤, Œ±', u_1, Œ¥, u_2, f, a, Œ±', a, Œ≤, Œ≥, g, a, Œ±, Œ±', f', a, Œ≤, a, Œ±, Œ¥, g', a, Œ¥, Œ≥, h_left_anticomm, a, Œ±, b, Œ≤, f, g, a, b, g', f', b, a, a, a] (during elaboration)

{Œπ : Type u_3} {R : Type u_1} {M : (a : Œπ) ‚Üí Type u_2} {N : Type u_4} [DecidableEq Œπ] [Semiring R] [(i : Œπ) ‚Üí AddCommMonoid M i] [(i : Œπ) ‚Üí Module R M i] [AddCommMonoid N] [Module R N] ‚¶É œÜ : Œ†‚ÇÄ (i : Œπ) , M i ‚Üí‚Çó[R] N ‚¶Ñ ‚¶É œà : Œ†‚ÇÄ (i : Œπ) , M i ‚Üí‚Çó[R] N ‚¶Ñ (h : ‚àÄ (i : Œπ) , LinearMap.comp œÜ DFinsupp.lsingle i = LinearMap.comp œà DFinsupp.lsingle i) (i : Œπ)  : LinearMap.comp œÜ DFinsupp.lsingle i = LinearMap.comp œà DFinsupp.lsingle i
application type mismatch
  AddCommMonoid M
argument
  M
has type
  Œπ ‚Üí Type u_2 : Type (max (u_2 + 1) u_3)
but is expected to have type
  Type ?u.35 : Type (?u.35 + 1) ; identifiers [Œπ, u_3, R, u_1, M, a, Œπ, u_2, N, u_4, DecidableEq, Œπ, Semiring, R, i, Œπ, AddCommMonoid, M, i, i, Œπ, Module, R, M, i, AddCommMonoid, N, Module, R, N, œÜ, i, Œπ, M, i, R, N, œà, i, Œπ, M, i, R, N, h, i, Œπ, LinearMap.comp, œÜ, DFinsupp.lsingle, i, LinearMap.comp, œà, DFinsupp.lsingle, i, i, Œπ, LinearMap.comp, œÜ, DFinsupp.lsingle, i, LinearMap.comp, œà, DFinsupp.lsingle, i] (during elaboration)

{A : Type u_1} [AddMonoid A] {f : ‚Ñ§ ‚Üí+ A} {g : ‚Ñ§ ‚Üí+ A} (h1 : ‚Üë f 1 = ‚Üë g 1) (this : AddMonoidHom.comp f ‚Üë Int.ofNatHom = AddMonoidHom.comp g ‚Üë Int.ofNatHom) (this' : ‚àÄ (n : ‚Ñï) , ‚Üë f ‚Üë n = ‚Üë g ‚Üë n) (n : ‚Ñ§)  : ‚àÄ (n : ‚Ñï) , ‚Üë f ‚Üë n = ‚Üë g ‚Üë n
type mismatch
  Int.ofNatHom
has type
  ‚Ñï ‚Üí+* ‚Ñ§ : Type
but is expected to have type
  ?m.2246 h1 ‚Üí+ ‚Ñ§ : Type ?u.86 ; identifiers [A, u_1, AddMonoid, A, f, A, g, A, h1, f, g, this, AddMonoidHom.comp, f, Int.ofNatHom, AddMonoidHom.comp, g, Int.ofNatHom, this', n, f, n, g, n, n, n, f, n, g, n] (during elaboration)

 : (‚àÄ {Œ± : Type u_1} [inst : LE Œ±] {a : Œ±} , (IsMax ‚Üë OrderDual.toDual a) ‚Üî (IsMin a))
function expected at
  IsMax ?m.13
term has type
  Prop ; identifiers [Œ±, u_1, inst, LE, Œ±, a, Œ±, IsMax, OrderDual.toDual, a, IsMin, a] (during elaboration)

 : ‚àÄ {Œ± : Type u_1} [inst : LE Œ±] {a : Œ±} , (IsMax ‚Üë OrderDual.toDual a) ‚Üî (IsMax ‚Üë OrderDual.toDual a)
function expected at
  IsMax ?m.13
term has type
  Prop ; identifiers [Œ±, u_1, inst, LE, Œ±, a, Œ±, IsMax, OrderDual.toDual, a, IsMax, OrderDual.toDual, a] (during elaboration)

{Œ± : Type u} {Œ≤ : Type v} [TopologicalSpace Œ±] [LinearOrder Œ≤] [SuccOrder Œ≤] [IsSuccArchimedean Œ≤] [Nonempty Œ≤] {s : (a : Œ≤) ‚Üí Set Œ±} (H : ‚àÄ (n : Œ≤) , IsConnected s n) (K : ‚àÄ (n : Œ≤) , Set.Nonempty s n ‚à© s Order.succ n) (i : Œ≤) (j : Œ≤)  : ‚àÄ (i_1 : Œ≤) (x : i_1 ‚àà Set.Ico i j) , Set.Nonempty s i_1 ‚à© s Order.succ i_1
function expected at
  IsConnected ?m.1641
term has type
  Prop ; identifiers [Œ±, u, Œ≤, v, TopologicalSpace, Œ±, LinearOrder, Œ≤, SuccOrder, Œ≤, IsSuccArchimedean, Œ≤, Nonempty, Œ≤, s, a, Œ≤, Set, Œ±, H, n, Œ≤, IsConnected, s, n, K, n, Œ≤, Set.Nonempty, s, n, s, Order.succ, n, i, Œ≤, j, Œ≤, i_1, Œ≤, x, i_1, Set.Ico, i, j, Set.Nonempty, s, i_1, s, Order.succ, i_1] (during elaboration)

{Œ± : Type u} {Œ≤ : Type v} [TopologicalSpace Œ±] [LinearOrder Œ≤] [SuccOrder Œ≤] [IsSuccArchimedean Œ≤] [Nonempty Œ≤] {s : (a : Œ≤) ‚Üí Set Œ±} (H : ‚àÄ (n : Œ≤) , IsConnected s n) (K : ‚àÄ (n : Œ≤) , Set.Nonempty s n ‚à© s Order.succ n) (i : Œ≤) (j : Œ≤) (i_1 : Œ≤) (x : i_1 ‚àà Set.Ico j i)  : Set.Nonempty s i_1 ‚à© s Order.succ i_1
function expected at
  IsConnected ?m.1641
term has type
  Prop ; identifiers [Œ±, u, Œ≤, v, TopologicalSpace, Œ±, LinearOrder, Œ≤, SuccOrder, Œ≤, IsSuccArchimedean, Œ≤, Nonempty, Œ≤, s, a, Œ≤, Set, Œ±, H, n, Œ≤, IsConnected, s, n, K, n, Œ≤, Set.Nonempty, s, n, s, Order.succ, n, i, Œ≤, j, Œ≤, i_1, Œ≤, x, i_1, Set.Ico, j, i, Set.Nonempty, s, i_1, s, Order.succ, i_1] (during elaboration)

 : (‚àÄ {Œπ : Type uŒπ} {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] [inst_2 : FiniteDimensional ‚Ñù E] {H : Type uH} [inst_3 : TopologicalSpace H] {I : ModelWithCorners ‚Ñù E H} {M : Type uM} [inst_4 : TopologicalSpace M] [inst_5 : ChartedSpace H M] {s : optParam Set M Set.univ} (self : SmoothBumpCovering Œπ I M s) , LocallyFinite fun (i : Œπ) ‚Ü¶ Function.support ‚Üë SmoothBumpCovering.toFun s self i)
unknown universe level 'uŒπ' ; identifiers [Œπ, uŒπ, E, uE, inst, NormedAddCommGroup, E, inst_1, NormedSpace, E, inst_2, FiniteDimensional, E, H, uH, inst_3, TopologicalSpace, H, I, ModelWithCorners, E, H, M, uM, inst_4, TopologicalSpace, M, inst_5, ChartedSpace, H, M, s, optParam, Set, M, Set.univ, self, SmoothBumpCovering, Œπ, I, M, s, LocallyFinite, i, Œπ, Function.support, SmoothBumpCovering.toFun, s, self, i] (during elaboration)

 : ‚àÄ (Œπ : Type uŒπ) (E : Type uE) [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] [inst_2 : FiniteDimensional ‚Ñù E] (H : Type uH) [inst_3 : TopologicalSpace H] (I : ModelWithCorners ‚Ñù E H) (M : Type uM) [inst_4 : TopologicalSpace M] [inst_5 : ChartedSpace H M] (s : optParam Set M Set.univ) (self : SmoothBumpCovering Œπ I M s) , LocallyFinite fun (i : Œπ) ‚Ü¶ Function.support ‚Üë self . 2 i
unknown universe level 'uŒπ' ; identifiers [Œπ, uŒπ, E, uE, inst, NormedAddCommGroup, E, inst_1, NormedSpace, E, inst_2, FiniteDimensional, E, H, uH, inst_3, TopologicalSpace, H, I, ModelWithCorners, E, H, M, uM, inst_4, TopologicalSpace, M, inst_5, ChartedSpace, H, M, s, optParam, Set, M, Set.univ, self, SmoothBumpCovering, Œπ, I, M, s, LocallyFinite, i, Œπ, Function.support, self, i] (during elaboration)

{Œ± : Type u_1} {Œ≤ : Type u_2} [TopologicalSpace Œ±] [TopologicalSpace Œ≤] (toFun : (a : Œ±) ‚Üí Œ≤) (spectral' : IsSpectralMap toFun) (toFun_1 : (a : Œ±) ‚Üí Œ≤) (spectral'_1 : IsSpectralMap toFun_1) (a : toFun = toFun_1) (h : toFun_1 = toFun) (spectral'_2 : IsSpectralMap toFun) (a : toFun = toFun) (h : HEq a (Eq.refl toFun =: toFun = toFun))  : {toFun := ((toFun)) , spectral' := ((spectral'))} = {toFun := ((toFun)) , spectral' := ((spectral'))}
<input>:1:317: expected term

(G : Type u_1) {Œ± : Type u_2} [AddGroup G] [AddAction G Œ±] {U : Set Œ±} (x : Œ±) (motive : (x : ‚àÉ (c : G) , c +·µ• x ‚àà U) ‚Üí Prop) (x_1 : ‚àÉ (c : G) , c +·µ• x ‚àà U) (h_1 : ‚àÄ (g : G) (hg : g +·µ• x ‚àà U) , motive (Exists.intro g hg =: ‚àÉ (c : G) , c +·µ• x ‚àà U))  : ‚àÄ (w : G) (h : w +·µ• x ‚àà U) , motive (Exists.intro w h)
<input>:1:221: expected term

{Œ± : Type u_1} {Œ≤ : Type u_2} [NonAssocSemiring Œ±] [NonAssocSemiring Œ≤] (toMonoidHom : Œ± ‚Üí* Œ≤) (map_zero' : OneHom.toFun ‚Üë toMonoidHom 0 = 0) (map_add' : ‚àÄ (x : Œ±) (y : Œ±) , OneHom.toFun ‚Üë toMonoidHom x + y = OneHom.toFun ‚Üë toMonoidHom x + OneHom.toFun ‚Üë toMonoidHom y) (toMonoidHom_1 : Œ± ‚Üí* Œ≤) (map_zero'_1 : OneHom.toFun ‚Üë toMonoidHom_1 0 = 0) (map_add'_1 : ‚àÄ (x : Œ±) (y : Œ±) , OneHom.toFun ‚Üë toMonoidHom_1 x + y = OneHom.toFun ‚Üë toMonoidHom_1 x + OneHom.toFun ‚Üë toMonoidHom_1 y) (a : {toMonoidHom := ((toMonoidHom)) , map_zero' := ((map_zero')) , map_add' := ((map_add'))} = {toMonoidHom := ((toMonoidHom_1)) , map_zero' := ((map_zero'_1)) , map_add' := ((map_add'_1))})  : ‚àÄ (toMonoidHom_eq : toMonoidHom = toMonoidHom_1) , toMonoidHom = toMonoidHom_1
type mismatch
  toMonoidHom_1
has type
  Œ± ‚Üí* Œ≤ : Type (max u_1 u_2)
but is expected to have type
  OneHom Œ± Œ± : Type u_1 ; identifiers [Œ±, u_1, Œ≤, u_2, NonAssocSemiring, Œ±, NonAssocSemiring, Œ≤, toMonoidHom, Œ±, Œ≤, map_zero', OneHom.toFun, toMonoidHom, map_add', x, Œ±, y, Œ±, OneHom.toFun, toMonoidHom, x, y, OneHom.toFun, toMonoidHom, x, OneHom.toFun, toMonoidHom, y, toMonoidHom_1, Œ±, Œ≤, map_zero'_1, OneHom.toFun, toMonoidHom_1, map_add'_1, x, Œ±, y, Œ±, OneHom.toFun, toMonoidHom_1, x, y, OneHom.toFun, toMonoidHom_1, x, OneHom.toFun, toMonoidHom_1, y, a, toMonoidHom, toMonoidHom, map_zero', map_zero', map_add', map_add', toMonoidHom, toMonoidHom_1, map_zero', map_zero'_1, map_add', map_add'_1, toMonoidHom_eq, toMonoidHom, toMonoidHom_1, toMonoidHom, toMonoidHom_1] (during elaboration)

{Œ± : Type u} [inst : AddCommGroup Œ±] [LE Œ±] [CovariantClass Œ± Œ± fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1 fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±} {b : Œ±} {c : Œ±} {Œ± : Type u} [AddCommGroup Œ±] [LE Œ±] [CovariantClass Œ± Œ± fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1 fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±} {b : Œ±} {c : Œ±}  : ((a - b ‚â§ c) ‚Üî (a ‚â§ b + c)) = ((a - b ‚â§ c) ‚Üî (a ‚â§ b + c))
function expected at
  x_1
term has type
  Œ± ; identifiers [Œ±, u, inst, AddCommGroup, Œ±, LE, Œ±, CovariantClass, Œ±, Œ±, x, Œ±, x_1, Œ±, x, x_1, x, Œ±, x_1, Œ±, x, x_1, a, Œ±, b, Œ±, c, Œ±, Œ±, u, AddCommGroup, Œ±, LE, Œ±, CovariantClass, Œ±, Œ±, x, Œ±, x_1, Œ±, x, x_1, x, Œ±, x_1, Œ±, x, x_1, a, Œ±, b, Œ±, c, Œ±, a, b, c, a, b, c, a, b, c, a, b, c] (during elaboration)

{Œ± : Type u} [inst : AddCommGroup Œ±] [LE Œ±] [CovariantClass Œ± Œ± fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1 fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±} {b : Œ±} {c : Œ±} {Œ± : Type u} [AddCommGroup Œ±] [LE Œ±] [CovariantClass Œ± Œ± fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1 fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±} {b : Œ±} {c : Œ±}  : ((a ‚â§ c + b) ‚Üî (a ‚â§ b + c)) = ((a ‚â§ c + b) ‚Üî (a ‚â§ b + c))
function expected at
  x_1
term has type
  Œ± ; identifiers [Œ±, u, inst, AddCommGroup, Œ±, LE, Œ±, CovariantClass, Œ±, Œ±, x, Œ±, x_1, Œ±, x, x_1, x, Œ±, x_1, Œ±, x, x_1, a, Œ±, b, Œ±, c, Œ±, Œ±, u, AddCommGroup, Œ±, LE, Œ±, CovariantClass, Œ±, Œ±, x, Œ±, x_1, Œ±, x, x_1, x, Œ±, x_1, Œ±, x, x_1, a, Œ±, b, Œ±, c, Œ±, a, c, b, a, b, c, a, c, b, a, b, c] (during elaboration)

{Œ± : Type u} [inst : AddCommGroup Œ±] [LE Œ±] [CovariantClass Œ± Œ± fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1 fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±} {b : Œ±} {c : Œ±} {Œ± : Type u} [AddCommGroup Œ±] [LE Œ±] [CovariantClass Œ± Œ± fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1 fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±} {b : Œ±} {c : Œ±}  : (a ‚â§ b + c) ‚Üî (a ‚â§ b + c)
function expected at
  x_1
term has type
  Œ± ; identifiers [Œ±, u, inst, AddCommGroup, Œ±, LE, Œ±, CovariantClass, Œ±, Œ±, x, Œ±, x_1, Œ±, x, x_1, x, Œ±, x_1, Œ±, x, x_1, a, Œ±, b, Œ±, c, Œ±, Œ±, u, AddCommGroup, Œ±, LE, Œ±, CovariantClass, Œ±, Œ±, x, Œ±, x_1, Œ±, x, x_1, x, Œ±, x_1, Œ±, x, x_1, a, Œ±, b, Œ±, c, Œ±, a, b, c, a, b, c] (during elaboration)

{Œ± : Type u_1} {Œ≤ : Type u_2} [NonAssocSemiring Œ±] [NonAssocSemiring Œ≤] (toMonoidHom : Œ± ‚Üí* Œ≤) (map_zero' : OneHom.toFun ‚Üë toMonoidHom 0 = 0) (map_add' : ‚àÄ (x : Œ±) (y : Œ±) , OneHom.toFun ‚Üë toMonoidHom x + y = OneHom.toFun ‚Üë toMonoidHom x + OneHom.toFun ‚Üë toMonoidHom y) (toMonoidHom_1 : Œ± ‚Üí* Œ≤) (map_zero'_1 : OneHom.toFun ‚Üë toMonoidHom_1 0 = 0) (map_add'_1 : ‚àÄ (x : Œ±) (y : Œ±) , OneHom.toFun ‚Üë toMonoidHom_1 x + y = OneHom.toFun ‚Üë toMonoidHom_1 x + OneHom.toFun ‚Üë toMonoidHom_1 y) (a : toMonoidHom = toMonoidHom_1) (h : toMonoidHom_1 = toMonoidHom) (toMonoidHom_2 : Œ± ‚Üí* Œ≤)  : toMonoidHom = toMonoidHom
type mismatch
  toMonoidHom_1
has type
  Œ± ‚Üí* Œ≤ : Type (max u_1 u_2)
but is expected to have type
  OneHom Œ± Œ± : Type u_1 ; identifiers [Œ±, u_1, Œ≤, u_2, NonAssocSemiring, Œ±, NonAssocSemiring, Œ≤, toMonoidHom, Œ±, Œ≤, map_zero', OneHom.toFun, toMonoidHom, map_add', x, Œ±, y, Œ±, OneHom.toFun, toMonoidHom, x, y, OneHom.toFun, toMonoidHom, x, OneHom.toFun, toMonoidHom, y, toMonoidHom_1, Œ±, Œ≤, map_zero'_1, OneHom.toFun, toMonoidHom_1, map_add'_1, x, Œ±, y, Œ±, OneHom.toFun, toMonoidHom_1, x, y, OneHom.toFun, toMonoidHom_1, x, OneHom.toFun, toMonoidHom_1, y, a, toMonoidHom, toMonoidHom_1, h, toMonoidHom_1, toMonoidHom, toMonoidHom_2, Œ±, Œ≤, toMonoidHom, toMonoidHom] (during elaboration)

{Œ± : Type u_1} [NontriviallyNormedField Œ±] (x : Œ±) (Œµ : ‚Ñù) (Œµ0 : Œµ > 0) (b : Œ±) (h : (0 < ‚Äñ b ‚Äñ : Prop) ‚àß (‚Äñ b ‚Äñ < Œµ : Prop)) (hb0 : 0 < ‚Äñ b ‚Äñ) (hbŒµ : ‚Äñ b ‚Äñ < Œµ)  : (‚Äñ x + b - x ‚Äñ < Œµ) = (‚Äñ x + b - x ‚Äñ < Œµ)
<input>:1:96: expected term

{Œ± : Type u_1} {Œ≤ : Type u_2} [NonAssocSemiring Œ±] [NonAssocSemiring Œ≤] (toMonoidHom : Œ± ‚Üí* Œ≤) (map_zero' : OneHom.toFun ‚Üë toMonoidHom 0 = 0) (map_add' : ‚àÄ (x : Œ±) (y : Œ±) , OneHom.toFun ‚Üë toMonoidHom x + y = OneHom.toFun ‚Üë toMonoidHom x + OneHom.toFun ‚Üë toMonoidHom y) (toMonoidHom_1 : Œ± ‚Üí* Œ≤) (map_zero'_1 : OneHom.toFun ‚Üë toMonoidHom_1 0 = 0) (map_add'_1 : ‚àÄ (x : Œ±) (y : Œ±) , OneHom.toFun ‚Üë toMonoidHom_1 x + y = OneHom.toFun ‚Üë toMonoidHom_1 x + OneHom.toFun ‚Üë toMonoidHom_1 y) (a : toMonoidHom = toMonoidHom_1) (h : toMonoidHom_1 = toMonoidHom) (map_zero'_2 : OneHom.toFun ‚Üë toMonoidHom 0 = 0) (map_add'_2 : ‚àÄ (x : Œ±) (y : Œ±) , OneHom.toFun ‚Üë toMonoidHom x + y = OneHom.toFun ‚Üë toMonoidHom x + OneHom.toFun ‚Üë toMonoidHom y) (a : toMonoidHom = toMonoidHom) (h : HEq a (Eq.refl toMonoidHom =: toMonoidHom = toMonoidHom))  : {toMonoidHom := ((toMonoidHom)) , map_zero' := ((map_zero')) , map_add' := ((map_add'))} = {toMonoidHom := ((toMonoidHom)) , map_zero' := ((map_zero')) , map_add' := ((map_add'))}
<input>:1:794: expected term

{Œ± : Type u_1} {Œ≤ : Type u_2} [NonAssocSemiring Œ±] [NonAssocSemiring Œ≤] (toMonoidHom : Œ± ‚Üí* Œ≤) (map_zero' : OneHom.toFun ‚Üë toMonoidHom 0 = 0) (map_add' : ‚àÄ (x : Œ±) (y : Œ±) , OneHom.toFun ‚Üë toMonoidHom x + y = OneHom.toFun ‚Üë toMonoidHom x + OneHom.toFun ‚Üë toMonoidHom y) (toMonoidHom_1 : Œ± ‚Üí* Œ≤) (map_zero'_1 : OneHom.toFun ‚Üë toMonoidHom_1 0 = 0) (map_add'_1 : ‚àÄ (x : Œ±) (y : Œ±) , OneHom.toFun ‚Üë toMonoidHom_1 x + y = OneHom.toFun ‚Üë toMonoidHom_1 x + OneHom.toFun ‚Üë toMonoidHom_1 y) (a : toMonoidHom = toMonoidHom_1) (h : toMonoidHom_1 = toMonoidHom)  : toMonoidHom = toMonoidHom_1
type mismatch
  toMonoidHom_1
has type
  Œ± ‚Üí* Œ≤ : Type (max u_1 u_2)
but is expected to have type
  OneHom Œ± Œ± : Type u_1 ; identifiers [Œ±, u_1, Œ≤, u_2, NonAssocSemiring, Œ±, NonAssocSemiring, Œ≤, toMonoidHom, Œ±, Œ≤, map_zero', OneHom.toFun, toMonoidHom, map_add', x, Œ±, y, Œ±, OneHom.toFun, toMonoidHom, x, y, OneHom.toFun, toMonoidHom, x, OneHom.toFun, toMonoidHom, y, toMonoidHom_1, Œ±, Œ≤, map_zero'_1, OneHom.toFun, toMonoidHom_1, map_add'_1, x, Œ±, y, Œ±, OneHom.toFun, toMonoidHom_1, x, y, OneHom.toFun, toMonoidHom_1, x, OneHom.toFun, toMonoidHom_1, y, a, toMonoidHom, toMonoidHom_1, h, toMonoidHom_1, toMonoidHom, toMonoidHom, toMonoidHom_1] (during elaboration)

{Œ± : Type u_1} {Œ≤ : Type u_2} [NonAssocSemiring Œ±] [NonAssocSemiring Œ≤] (toMonoidHom : Œ± ‚Üí* Œ≤) (map_zero' : OneHom.toFun ‚Üë toMonoidHom 0 = 0) (map_add' : ‚àÄ (x : Œ±) (y : Œ±) , OneHom.toFun ‚Üë toMonoidHom x + y = OneHom.toFun ‚Üë toMonoidHom x + OneHom.toFun ‚Üë toMonoidHom y) (toMonoidHom_1 : Œ± ‚Üí* Œ≤) (map_zero'_1 : OneHom.toFun ‚Üë toMonoidHom_1 0 = 0) (map_add'_1 : ‚àÄ (x : Œ±) (y : Œ±) , OneHom.toFun ‚Üë toMonoidHom_1 x + y = OneHom.toFun ‚Üë toMonoidHom_1 x + OneHom.toFun ‚Üë toMonoidHom_1 y) (a : toMonoidHom = toMonoidHom_1)  : toMonoidHom_1 = toMonoidHom_1
type mismatch
  toMonoidHom_1
has type
  Œ± ‚Üí* Œ≤ : Type (max u_1 u_2)
but is expected to have type
  OneHom Œ± Œ± : Type u_1 ; identifiers [Œ±, u_1, Œ≤, u_2, NonAssocSemiring, Œ±, NonAssocSemiring, Œ≤, toMonoidHom, Œ±, Œ≤, map_zero', OneHom.toFun, toMonoidHom, map_add', x, Œ±, y, Œ±, OneHom.toFun, toMonoidHom, x, y, OneHom.toFun, toMonoidHom, x, OneHom.toFun, toMonoidHom, y, toMonoidHom_1, Œ±, Œ≤, map_zero'_1, OneHom.toFun, toMonoidHom_1, map_add'_1, x, Œ±, y, Œ±, OneHom.toFun, toMonoidHom_1, x, y, OneHom.toFun, toMonoidHom_1, x, OneHom.toFun, toMonoidHom_1, y, a, toMonoidHom, toMonoidHom_1, toMonoidHom_1, toMonoidHom_1] (during elaboration)

{Œ± : Type ua} [UniformSpace Œ±] {d : Set Œ± √ó Œ±} (s : Set Œ± √ó Œ±) (hd : d ‚àà uniformity Œ±) cl_d : Set Œ± √ó Œ± := {p : Œ± √ó Œ± | ‚àÉ (x : Œ±) , ‚àÉ (y : Œ±) , ((Prod.fst p , x) ‚àà d : Prop) ‚àß (((x , y) ‚àà s : Prop) ‚àß ((y , Prod.snd p) ‚àà d : Prop) : Prop)} (this : ‚àÄ (p : Œ± √ó Œ±) (a : p ‚àà s) , ‚àÉ (t : Set Œ± √ó Œ±) , (t ‚äÜ cl_d : Prop) ‚àß ((IsOpen t : Prop) ‚àß (p ‚àà t : Prop) : Prop)) (t : (p : Œ± √ó Œ±) ‚Üí (a : p ‚àà s) ‚Üí Set Œ± √ó Œ±) (ht : ‚àÄ (p : Œ± √ó Œ±) (a : p ‚àà s) , (t p a ‚äÜ cl_d : Prop) ‚àß ((IsOpen t p a : Prop) ‚àß (p ‚àà t p a : Prop) : Prop)) (p : Œ± √ó Œ±) (hp : p ‚àà s)  : (t p hp ‚äÜ cl_d) ‚àß ((IsOpen t p hp) ‚àß (p ‚àà t p hp))
<input>:1:92: expected end of input

