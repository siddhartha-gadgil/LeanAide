 : ‚àÄ {Œ± : Type u_1} {f : (a : Œ±) ‚Üí ENNReal} {s : Finset Œ±} (h : Finset.sum s fun (a : Œ±) ‚Ü¶ f a = 1) (h' : ‚àÄ (a : Œ±) (x : ¬¨ a ‚àà s) , f a = 0) {a : Œ±} (ha : ¬¨ a ‚àà s) , ‚Üë Pmf.ofFinset f s h h' a = 0
failed to synthesize instance
  AddCommMonoid Prop ; identifiers [Œ±, u_1, f, a, Œ±, ENNReal, s, Finset, Œ±, h, Finset.sum, s, a, Œ±, f, a, h', a, Œ±, x, a, s, f, a, a, Œ±, ha, a, s, Pmf.ofFinset, f, s, h, h', a] (during elaboration)

 : ‚àÄ {Œ± : Type u_1} {f : (a : Œ±) ‚Üí ENNReal} {s : Finset Œ±} (h : Finset.sum s fun (a : Œ±) ‚Ü¶ f a = 1) (h' : ‚àÄ (a : Œ±) (x : ¬¨ a ‚àà s) , f a = 0) {a : Œ±} (ha : ¬¨ a ‚àà s) , f a = 0
failed to synthesize instance
  AddCommMonoid Prop ; identifiers [Œ±, u_1, f, a, Œ±, ENNReal, s, Finset, Œ±, h, Finset.sum, s, a, Œ±, f, a, h', a, Œ±, x, a, s, f, a, a, Œ±, ha, a, s, f, a] (during elaboration)

 : ‚àÄ {V : Type u_2} {W : Type u_3} {V‚ÇÅ : Type u_1} [inst : SeminormedAddCommGroup V] [inst_1 : SeminormedAddCommGroup W] [inst_2 : SeminormedAddCommGroup V‚ÇÅ] {f : NormedAddGroupHom V W} {g : NormedAddGroupHom V W} (œÜ : NormedAddGroupHom V‚ÇÅ V) (h : NormedAddGroupHom.comp f œÜ = NormedAddGroupHom.comp g œÜ) (C : ‚Ñù) (hœÜ : ‚Äñ œÜ ‚Äñ ‚â§ C) , ‚Äñ NormedAddGroupHom.Equalizer.lift œÜ h ‚Äñ ‚â§ C
<input>:1:325: expected term

 : ‚àÄ {V : Type u_2} {W : Type u_3} {V‚ÇÅ : Type u_1} [inst : SeminormedAddCommGroup V] [inst_1 : SeminormedAddCommGroup W] [inst_2 : SeminormedAddCommGroup V‚ÇÅ] {f : NormedAddGroupHom V W} {g : NormedAddGroupHom V W} (œÜ : NormedAddGroupHom V‚ÇÅ V) (h : NormedAddGroupHom.comp f œÜ = NormedAddGroupHom.comp g œÜ) (C : ‚Ñù) (hœÜ : ‚Äñ œÜ ‚Äñ ‚â§ C) , ‚Äñ œÜ ‚Äñ ‚â§ C
<input>:1:325: expected term

{Œ± : Type u_1} [MulOneClass Œ±] [LT Œ±] [CovariantClass Œ± Œ± Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1 fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] [ContravariantClass Œ± Œ± Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1 fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] (a : Œ±) {b : Œ±}  : a < b * a ‚Üî 1 * a < b * a = a < b * a ‚Üî 1 * a < b * a
<input>:1:285: expected end of input

{Œ± : Type u_1} [MulOneClass Œ±] [LT Œ±] [CovariantClass Œ± Œ± Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1 fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] [ContravariantClass Œ± Œ± Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1 fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] (a : Œ±) {b : Œ±}  : a < b * a ‚Üî a < b * a
application type mismatch
  CovariantClass Œ± Œ± Function.swap
argument
  Function.swap
has type
  ((x : ?m.19) ‚Üí (y : ?m.20) ‚Üí ?m.21 x y) ‚Üí
    (y : ?m.20) ‚Üí (x : ?m.19) ‚Üí ?m.21 x y : Sort (imax (imax ?u.18 ?u.17 ?u.16) ?u.17 ?u.18 ?u.16)
but is expected to have type
  Œ± ‚Üí Œ± ‚Üí Œ± : Type u_1 ; identifiers [Œ±, u_1, MulOneClass, Œ±, LT, Œ±, CovariantClass, Œ±, Œ±, Function.swap, x, Œ±, x_1, Œ±, x, x_1, x, Œ±, x_1, Œ±, x, x_1, ContravariantClass, Œ±, Œ±, Function.swap, x, Œ±, x_1, Œ±, x, x_1, x, Œ±, x_1, Œ±, x, x_1, a, Œ±, b, Œ±, a, b, a, a, b, a] (during elaboration)

{Œ± : Type u_1} [GeneralizedCoheytingAlgebra Œ±] {a : Œ±} {b : Œ±} {c : Œ±} (h : a ‚äî c ‚â§ b ‚äî c)  : a \ c ‚â§ b \ c = a \ c ‚â§ b \ c
<input>:1:108: expected end of input

{Œ± : Type u_1} [GeneralizedCoheytingAlgebra Œ±] {a : Œ±} {b : Œ±} {c : Œ±} (h : a ‚äî c ‚â§ b ‚äî c)  : a ‚äî c \ c ‚â§ b \ c = a ‚äî c \ c ‚â§ b \ c
<input>:1:112: expected end of input

{n : ‚Ñï} {f : Vector ‚Ñï n ‚Üí. ‚Ñï} (pf : Nat.Partrec' f) {m : ‚Ñï} {n : ‚Ñï} {f : Vector ‚Ñï n ‚Üí. ‚Ñï} (g : (a : Fin n) ‚Üí Vector ‚Ñï m ‚Üí. ‚Ñï) (a : Nat.Partrec' f) (a : ‚àÄ (i : Fin n) , Nat.Partrec' g i) (a_ih : Partrec f) (a_ih_1 : ‚àÄ (i : Fin n) , Partrec g i)  : ‚àÄ (i : Fin n) , Partrec g i
application type mismatch
  Nat.Partrec' g
argument
  g
has type
  Fin n ‚Üí Vector ‚Ñï m ‚Üí. ‚Ñï : Type
but is expected to have type
  Vector ‚Ñï ?m.51 ‚Üí. ‚Ñï : Type ; identifiers [n, f, Vector, n, pf, Nat.Partrec', f, m, n, f, Vector, n, g, a, Fin, n, Vector, m, a, Nat.Partrec', f, a, i, Fin, n, Nat.Partrec', g, i, a_ih, Partrec, f, a_ih_1, i, Fin, n, Partrec, g, i, i, Fin, n, Partrec, g, i] (during elaboration)

{Œ± : Type u_1} {l : Filter Œ±} {R : Type u_2} [Distrib R] (f : Filter.Germ l R) (g : Filter.Germ l R) (h : Filter.Germ l R) (f : (a : Œ±) ‚Üí R) (g : (a : Œ±) ‚Üí R) (h : (a : Œ±) ‚Üí R)  : f * g + h =·∂†[l] f * g + f * h = f * g + h =·∂†[l] f * g + f * h
application type mismatch
  f * g + h =·∂†[l] ?m.81592 =·∂†[l] f * g + f * h
argument
  ?m.81592 =·∂†[l] f * g + f * h
has type
  Prop : Type
but is expected to have type
  Œ± ‚Üí R : Type (max u_2 u_1) ; identifiers [Œ±, u_1, l, Filter, Œ±, R, u_2, Distrib, R, f, Filter.Germ, l, R, g, Filter.Germ, l, R, h, Filter.Germ, l, R, f, a, Œ±, R, g, a, Œ±, R, h, a, Œ±, R, f, g, h, l, f, g, f, h, f, g, h, l, f, g, f, h] (during elaboration)

{Œ± : Type u_2} {Œ≤ : Type u_1} [AddMonoid Œ±] [AddAction Œ± Œ≤] {a : Œ≤} (motive : (x : ‚Üë AddAction.orbit Œ± a) ‚Üí Prop) (x : ‚Üë AddAction.orbit Œ± a) (h_1 : ‚àÄ (b : Œ≤) (x : Œ±) (hx : fun (x : Œ±) ‚Ü¶ x +·µ• a x = b) , motive {val := ((b)) , property := (((Exists.intro x hx =: ‚àÉ (y : Œ±) , fun (x : Œ±) ‚Ü¶ x +·µ• a y = b)))}) (val : Œ≤) (property : val ‚àà AddAction.orbit Œ± a)  : ‚àÄ (w : Œ±) (h : fun (x : Œ±) ‚Ü¶ x +·µ• a w = val) , motive {val := ((val)) , property := ((Exists.intro w h))}
<input>:1:260: expected term

{M‚ÇÄ : Type u_1} [inst : MonoidWithZero M‚ÇÄ] {a : M‚ÇÄ} (h : IsUnit Ring.inverse a) (h_1 : Subsingleton M‚ÇÄ) (h_2 : (subsingleton_or_nontrivial M‚ÇÄ =: (Subsingleton M‚ÇÄ : Prop) ‚à® (Nontrivial M‚ÇÄ : Prop)) = (Or.inl h_1 =: (Subsingleton M‚ÇÄ : Prop) ‚à® (Nontrivial M‚ÇÄ : Prop)))  : Or.inl h_1 = subsingleton_or_nontrivial M‚ÇÄ
<input>:1:143: expected term

 : ‚àÄ {G : Type u_1} [inst : AddGroup G] (self : AddSubgroup G) {x : G} (a : x ‚àà AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup AddSubgroup.toAddSubmonoid self) , - x ‚àà AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup AddSubgroup.toAddSubmonoid self
function expected at
  AddSubsemigroup.carrier ?m.79766 AddSubgroup.toAddSubmonoid
term has type
  Prop ; identifiers [G, u_1, inst, AddGroup, G, self, AddSubgroup, G, x, G, a, x, AddSubsemigroup.carrier, AddSubmonoid.toAddSubsemigroup, AddSubgroup.toAddSubmonoid, self, x, AddSubsemigroup.carrier, AddSubmonoid.toAddSubsemigroup, AddSubgroup.toAddSubmonoid, self] (during elaboration)

 : ‚àÄ (G : Type u_1) [inst : AddGroup G] (self : AddSubgroup G) {x : G} (a : x ‚àà AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup self . 1) , - x ‚àà AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup self . 1
function expected at
  AddSubsemigroup.carrier ?m.79766 self
term has type
  Prop ; identifiers [G, u_1, inst, AddGroup, G, self, AddSubgroup, G, x, G, a, x, AddSubsemigroup.carrier, AddSubmonoid.toAddSubsemigroup, self, x, AddSubsemigroup.carrier, AddSubmonoid.toAddSubsemigroup, self] (during elaboration)

{K : Type v} {V : Type w} [Field K] [AddCommGroup V] [Module K V] (f : Module.End K V) (Œºs : Set K) (xs : (a : ‚Üë Œºs) ‚Üí V) (h_eigenvec : ‚àÄ (Œº : ‚Üë Œºs) , Module.End.HasEigenvector f ‚Üë Œº xs Œº) (Œº : {x : K // x ‚àà Œºs})  : Module.End.HasEigenvector f ‚Üë Œº xs Œº
type mismatch
  Œºs
has type
  Set K : Type v
but is expected to have type
  Sort ?u.1398 : Type ?u.1398 ; identifiers [K, v, V, w, Field, K, AddCommGroup, V, Module, K, V, f, Module.End, K, V, Œºs, Set, K, xs, a, Œºs, V, h_eigenvec, Œº, Œºs, Module.End.HasEigenvector, f, Œº, xs, Œº, Œº, x, K, x, Œºs, Module.End.HasEigenvector, f, Œº, xs, Œº] (during elaboration)

{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [Primcodable Œ±] [Primcodable Œ≤] [Primcodable Œ≥] {p : (a : Œ±) ‚Üí Prop} {q : (a : Œ≤) ‚Üí Prop} {r : (a : Œ≥) ‚Üí Prop} (x : p ‚â§‚ÇÄ r) (x_1 : q ‚â§‚ÇÄ r) (f : (a : Œ±) ‚Üí Œ≥) (c‚ÇÅ : Computable f) (h‚ÇÅ : ‚àÄ (a : Œ±) , (p a : Prop) ‚Üî (r f a : Prop)) (g : (a : Œ≤) ‚Üí Œ≥) (c‚ÇÇ : Computable g) (h‚ÇÇ : ‚àÄ (a : Œ≤) , (q a : Prop) ‚Üî (r g a : Prop)) (x : Œ± ‚äï Œ≤) (val : Œ±) (h : x = Sum.inl val)  : Sum.inl val = x
application type mismatch
  r f
argument
  f
has type
  Œ± ‚Üí Œ≥ : Type (max u_1 u_3)
but is expected to have type
  Œ≥ : Type u_3 ; identifiers [Œ±, u_1, Œ≤, u_2, Œ≥, u_3, Primcodable, Œ±, Primcodable, Œ≤, Primcodable, Œ≥, p, a, Œ±, q, a, Œ≤, r, a, Œ≥, x, p, r, x_1, q, r, f, a, Œ±, Œ≥, c‚ÇÅ, Computable, f, h‚ÇÅ, a, Œ±, p, a, r, f, a, g, a, Œ≤, Œ≥, c‚ÇÇ, Computable, g, h‚ÇÇ, a, Œ≤, q, a, r, g, a, x, Œ±, Œ≤, val, Œ±, h, x, Sum.inl, val, Sum.inl, val, x] (during elaboration)

{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [Primcodable Œ±] [Primcodable Œ≤] [Primcodable Œ≥] {p : (a : Œ±) ‚Üí Prop} {q : (a : Œ≤) ‚Üí Prop} {r : (a : Œ≥) ‚Üí Prop} (x : p ‚â§‚ÇÄ r) (x_1 : q ‚â§‚ÇÄ r) (f : (a : Œ±) ‚Üí Œ≥) (c‚ÇÅ : Computable f) (h‚ÇÅ : ‚àÄ (a : Œ±) , (p a : Prop) ‚Üî (r f a : Prop)) (g : (a : Œ≤) ‚Üí Œ≥) (c‚ÇÇ : Computable g) (h‚ÇÇ : ‚àÄ (a : Œ≤) , (q a : Prop) ‚Üî (r g a : Prop)) (x : Œ± ‚äï Œ≤) (val : Œ±) (h : x = Sum.inl val)  : p val ‚Üî r f val
application type mismatch
  r f
argument
  f
has type
  Œ± ‚Üí Œ≥ : Type (max u_1 u_3)
but is expected to have type
  Œ≥ : Type u_3 ; identifiers [Œ±, u_1, Œ≤, u_2, Œ≥, u_3, Primcodable, Œ±, Primcodable, Œ≤, Primcodable, Œ≥, p, a, Œ±, q, a, Œ≤, r, a, Œ≥, x, p, r, x_1, q, r, f, a, Œ±, Œ≥, c‚ÇÅ, Computable, f, h‚ÇÅ, a, Œ±, p, a, r, f, a, g, a, Œ≤, Œ≥, c‚ÇÇ, Computable, g, h‚ÇÇ, a, Œ≤, q, a, r, g, a, x, Œ±, Œ≤, val, Œ±, h, x, Sum.inl, val, p, val, r, f, val] (during elaboration)

{R : Type u‚ÇÅ} [StrictOrderedSemiring R] {a : R} (h : 0 ‚â§ a) (ha : a ‚â§ 1) {i : ‚Ñï} {j : ‚Ñï} (hij : i ‚â§ j) (k : ‚Ñï) (hk : j = i + k)  : a ^ j ‚â§ a ^ i = a ^ j ‚â§ a ^ i
<input>:1:145: expected end of input

{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [Primcodable Œ±] [Primcodable Œ≤] [Primcodable Œ≥] {p : (a : Œ±) ‚Üí Prop} {q : (a : Œ≤) ‚Üí Prop} {r : (a : Œ≥) ‚Üí Prop} (x : p ‚â§‚ÇÄ r) (x_1 : q ‚â§‚ÇÄ r) (f : (a : Œ±) ‚Üí Œ≥) (c‚ÇÅ : Computable f) (h‚ÇÅ : ‚àÄ (a : Œ±) , (p a : Prop) ‚Üî (r f a : Prop)) (g : (a : Œ≤) ‚Üí Œ≥) (c‚ÇÇ : Computable g) (h‚ÇÇ : ‚àÄ (a : Œ≤) , (q a : Prop) ‚Üî (r g a : Prop)) (x : Œ± ‚äï Œ≤) (val : Œ≤) (h : x = Sum.inr val)  : Sum.inr val = x
application type mismatch
  r f
argument
  f
has type
  Œ± ‚Üí Œ≥ : Type (max u_1 u_3)
but is expected to have type
  Œ≥ : Type u_3 ; identifiers [Œ±, u_1, Œ≤, u_2, Œ≥, u_3, Primcodable, Œ±, Primcodable, Œ≤, Primcodable, Œ≥, p, a, Œ±, q, a, Œ≤, r, a, Œ≥, x, p, r, x_1, q, r, f, a, Œ±, Œ≥, c‚ÇÅ, Computable, f, h‚ÇÅ, a, Œ±, p, a, r, f, a, g, a, Œ≤, Œ≥, c‚ÇÇ, Computable, g, h‚ÇÇ, a, Œ≤, q, a, r, g, a, x, Œ±, Œ≤, val, Œ≤, h, x, Sum.inr, val, Sum.inr, val, x] (during elaboration)

{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [Primcodable Œ±] [Primcodable Œ≤] [Primcodable Œ≥] {p : (a : Œ±) ‚Üí Prop} {q : (a : Œ≤) ‚Üí Prop} {r : (a : Œ≥) ‚Üí Prop} (x : p ‚â§‚ÇÄ r) (x_1 : q ‚â§‚ÇÄ r) (f : (a : Œ±) ‚Üí Œ≥) (c‚ÇÅ : Computable f) (h‚ÇÅ : ‚àÄ (a : Œ±) , (p a : Prop) ‚Üî (r f a : Prop)) (g : (a : Œ≤) ‚Üí Œ≥) (c‚ÇÇ : Computable g) (h‚ÇÇ : ‚àÄ (a : Œ≤) , (q a : Prop) ‚Üî (r g a : Prop)) (x : Œ± ‚äï Œ≤) (val : Œ≤) (h : x = Sum.inr val)  : q val ‚Üî r g val
application type mismatch
  r f
argument
  f
has type
  Œ± ‚Üí Œ≥ : Type (max u_1 u_3)
but is expected to have type
  Œ≥ : Type u_3 ; identifiers [Œ±, u_1, Œ≤, u_2, Œ≥, u_3, Primcodable, Œ±, Primcodable, Œ≤, Primcodable, Œ≥, p, a, Œ±, q, a, Œ≤, r, a, Œ≥, x, p, r, x_1, q, r, f, a, Œ±, Œ≥, c‚ÇÅ, Computable, f, h‚ÇÅ, a, Œ±, p, a, r, f, a, g, a, Œ≤, Œ≥, c‚ÇÇ, Computable, g, h‚ÇÇ, a, Œ≤, q, a, r, g, a, x, Œ±, Œ≤, val, Œ≤, h, x, Sum.inr, val, q, val, r, g, val] (during elaboration)

{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [Primcodable Œ±] [Primcodable Œ≤] [Primcodable Œ≥] {p : (a : Œ±) ‚Üí Prop} {q : (a : Œ≤) ‚Üí Prop} {r : (a : Œ≥) ‚Üí Prop} (x : p ‚â§‚ÇÄ r) (x_1 : q ‚â§‚ÇÄ r) (f : (a : Œ±) ‚Üí Œ≥) (c‚ÇÅ : Computable f) (h‚ÇÅ : ‚àÄ (a : Œ±) , (p a : Prop) ‚Üî (r f a : Prop)) (g : (a : Œ≤) ‚Üí Œ≥) (c‚ÇÇ : Computable g) (h‚ÇÇ : ‚àÄ (a : Œ≤) , (q a : Prop) ‚Üî (r g a : Prop)) (x : Œ± ‚äï Œ≤)  : x = x
application type mismatch
  r f
argument
  f
has type
  Œ± ‚Üí Œ≥ : Type (max u_1 u_3)
but is expected to have type
  Œ≥ : Type u_3 ; identifiers [Œ±, u_1, Œ≤, u_2, Œ≥, u_3, Primcodable, Œ±, Primcodable, Œ≤, Primcodable, Œ≥, p, a, Œ±, q, a, Œ≤, r, a, Œ≥, x, p, r, x_1, q, r, f, a, Œ±, Œ≥, c‚ÇÅ, Computable, f, h‚ÇÅ, a, Œ±, p, a, r, f, a, g, a, Œ≤, Œ≥, c‚ÇÇ, Computable, g, h‚ÇÇ, a, Œ≤, q, a, r, g, a, x, Œ±, Œ≤, x, x] (during elaboration)

 : ‚àÄ {Œ± : Type u} [inst : SizeOf Œ±] , sizeOf LazyList.nil = 1
typeclass instance problem is stuck, it is often due to metavariables
  SizeOf (LazyList ?m.6756) ; identifiers [Œ±, u, inst, SizeOf, Œ±, sizeOf, LazyList.nil] (during elaboration)

{M‚ÇÄ : Type u_1} [inst : MonoidWithZero M‚ÇÄ] {a : M‚ÇÄ} (h : IsUnit Ring.inverse a) (h_1 : Subsingleton M‚ÇÄ) (h_2 : (subsingleton_or_nontrivial M‚ÇÄ =: (Subsingleton M‚ÇÄ : Prop) ‚à® (Nontrivial M‚ÇÄ : Prop)) = (Or.inl h_1 =: (Subsingleton M‚ÇÄ : Prop) ‚à® (Nontrivial M‚ÇÄ : Prop))) (M : Type u_1) (inst : Monoid M) (a : M) (a' : M) (e'_3 : a = a') (h : a' = a) (a' : M)  : a = a
<input>:1:143: expected term

 : ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : MeasurableSpace Œ±] [inst_1 : MeasurableSpace Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (self : MeasurableEmbedding f) ‚¶É s : Set Œ± ‚¶Ñ (a : MeasurableSet s) , MeasurableSet f '' s
application type mismatch
  Set.image (MeasurableSet ?m.353)
argument
  MeasurableSet ?m.353
has type
  Prop : Type
but is expected to have type
  Œ± ‚Üí ?m.79608 self a : Type (max ?u.146 u_1) ; identifiers [Œ±, u_1, Œ≤, u_2, inst, MeasurableSpace, Œ±, inst_1, MeasurableSpace, Œ≤, f, a, Œ±, Œ≤, self, MeasurableEmbedding, f, s, Set, Œ±, a, MeasurableSet, s, MeasurableSet, f, s] (during elaboration)

 : ‚àÄ (Œ± : Type u_1) (Œ≤ : Type u_2) [inst : MeasurableSpace Œ±] [inst_1 : MeasurableSpace Œ≤] (f : (a : Œ±) ‚Üí Œ≤) (self : MeasurableEmbedding f) ‚¶É s : Set Œ± ‚¶Ñ (a : MeasurableSet s) , MeasurableSet f '' s
application type mismatch
  Set.image (MeasurableSet ?m.353)
argument
  MeasurableSet ?m.353
has type
  Prop : Type
but is expected to have type
  Œ± ‚Üí ?m.79608 Œ± Œ≤ f self a : Type (max ?u.146 u_1) ; identifiers [Œ±, u_1, Œ≤, u_2, inst, MeasurableSpace, Œ±, inst_1, MeasurableSpace, Œ≤, f, a, Œ±, Œ≤, self, MeasurableEmbedding, f, s, Set, Œ±, a, MeasurableSet, s, MeasurableSet, f, s] (during elaboration)

{G : Type u_1} [Group G] (H : Subgroup G) (a : G) (b : G)  : Setoid.Rel Doset.setoid ‚Üë Subgroup.toSubmonoid H ‚Üë ‚ä• a b ‚Üî Setoid.Rel Doset.setoid ‚Üë Subgroup.toSubmonoid H ‚Üë ‚ä• a b
function expected at
  Setoid.Rel ?m.80159 ?m.80160 H
term has type
  Prop ; identifiers [G, u_1, Group, G, H, Subgroup, G, a, G, b, G, Setoid.Rel, Doset.setoid, Subgroup.toSubmonoid, H, a, b, Setoid.Rel, Doset.setoid, Subgroup.toSubmonoid, H, a, b] (during elaboration)

{M‚ÇÄ : Type u_1} [inst : MonoidWithZero M‚ÇÄ] {a : M‚ÇÄ} (h : IsUnit Ring.inverse a) (h_1 : Subsingleton M‚ÇÄ) (h_2 : (subsingleton_or_nontrivial M‚ÇÄ =: (Subsingleton M‚ÇÄ : Prop) ‚à® (Nontrivial M‚ÇÄ : Prop)) = (Or.inl h_1 =: (Subsingleton M‚ÇÄ : Prop) ‚à® (Nontrivial M‚ÇÄ : Prop))) (M : Type u_1) (inst : Monoid M) (a : M) (a' : M) (e'_3 : a = a') (h : a' = a)  : a = a'
<input>:1:143: expected term

{M‚ÇÄ : Type u_1} [inst : MonoidWithZero M‚ÇÄ] {a : M‚ÇÄ} (h : IsUnit Ring.inverse a) (h_1 : Subsingleton M‚ÇÄ) (h_2 : (subsingleton_or_nontrivial M‚ÇÄ =: (Subsingleton M‚ÇÄ : Prop) ‚à® (Nontrivial M‚ÇÄ : Prop)) = (Or.inl h_1 =: (Subsingleton M‚ÇÄ : Prop) ‚à® (Nontrivial M‚ÇÄ : Prop))) (M : Type u_1) (inst : Monoid M) (a : M) (a' : M) (e'_3 : a = a')  : a' = a'
<input>:1:143: expected term

{M‚ÇÄ : Type u_1} [inst : MonoidWithZero M‚ÇÄ] {a : M‚ÇÄ} (h : IsUnit Ring.inverse a) (h_1 : Nontrivial M‚ÇÄ) (h_2 : (subsingleton_or_nontrivial M‚ÇÄ =: (Subsingleton M‚ÇÄ : Prop) ‚à® (Nontrivial M‚ÇÄ : Prop)) = (Or.inr h_1 =: (Subsingleton M‚ÇÄ : Prop) ‚à® (Nontrivial M‚ÇÄ : Prop)))  : Or.inr h_1 = subsingleton_or_nontrivial M‚ÇÄ
<input>:1:141: expected term

 : ‚àÄ {E : Type u_1} {F : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] [inst_2 : NormedAddCommGroup F] [inst_3 : NormedSpace ‚Ñù F] (self : SchwartzMap E F) , ContDiff ‚Ñù ‚ä§ SchwartzMap.toFun self
function expected at
  ContDiff ‚Ñù ‚ä§ SchwartzMap.toFun
term has type
  Prop ; identifiers [E, u_1, F, u_2, inst, NormedAddCommGroup, E, inst_1, NormedSpace, E, inst_2, NormedAddCommGroup, F, inst_3, NormedSpace, F, self, SchwartzMap, E, F, ContDiff, SchwartzMap.toFun, self] (during elaboration)

 : ‚àÄ (E : Type u_1) (F : Type u_2) [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] [inst_2 : NormedAddCommGroup F] [inst_3 : NormedSpace ‚Ñù F] (self : SchwartzMap E F) , ContDiff ‚Ñù ‚ä§ self . 1
function expected at
  ContDiff ‚Ñù ‚ä§ ‚Üëself
term has type
  Prop ; identifiers [E, u_1, F, u_2, inst, NormedAddCommGroup, E, inst_1, NormedSpace, E, inst_2, NormedAddCommGroup, F, inst_3, NormedSpace, F, self, SchwartzMap, E, F, ContDiff, self] (during elaboration)

{ùïú : Type u_1} {E : Type u_2} [OrderedSemiring ùïú] [AddCommMonoid E] [Module ùïú E] (x : ConvexCone ùïú E) (x_1 : E) (x_2 : E)  : ‚àÉ (x_3 : E) , x_2 = 0 ‚àß x_3 ‚àà x ‚àß x_2 + x_3 = x_1 = x_2 = 0 ‚àß ‚àÉ (x_3 : E) , x_3 ‚àà x ‚àß x_2 + x_3 = x_1
<input>:1:181: expected end of input

{ùïú : Type u_1} {E : Type u_2} [OrderedSemiring ùïú] [AddCommMonoid E] [Module ùïú E] (x : ConvexCone ùïú E) (x_1 : E)  : ‚àÉ (a : E) , a ‚àà x ‚àß a = x_1 = x_1 ‚àà x
<input>:1:149: expected end of input

{J : Type v} [CategoryTheory.SmallCategory J] (F : CategoryTheory.Functor J TypeMax) [CategoryTheory.IsFilteredOrEmpty J] {i : J} {j : J} {xi : CategoryTheory.Functor.toPrefunctor F . obj i} {xj : CategoryTheory.Functor.toPrefunctor F . obj j}  : EqvGen CategoryTheory.Limits.Types.Quot.Rel F {fst := ((i)) , snd := ((xi))} {fst := ((j)) , snd := ((xj))} ‚Üî EqvGen CategoryTheory.Limits.Types.Quot.Rel F {fst := ((i)) , snd := ((xi))} {fst := ((j)) , snd := ((xj))}
function expected at
  F.toPrefunctor
term has type
  J ‚•§q TypeMax ; identifiers [J, v, CategoryTheory.SmallCategory, J, F, CategoryTheory.Functor, J, TypeMax, CategoryTheory.IsFilteredOrEmpty, J, i, J, j, J, xi, CategoryTheory.Functor.toPrefunctor, F, obj, i, xj, CategoryTheory.Functor.toPrefunctor, F, obj, j, EqvGen, CategoryTheory.Limits.Types.Quot.Rel, F, fst, i, snd, xi, fst, j, snd, xj, EqvGen, CategoryTheory.Limits.Types.Quot.Rel, F, fst, i, snd, xi, fst, j, snd, xj] (during elaboration)

{R : Type u} [CommRing R] [IsBezout R] {x : R} {y : R} {z : R} (hx : z ‚à£ x) (hy : z ‚à£ y)  : z ‚à£ x = z ‚à£ x
<input>:1:98: expected end of input

{R : Type u} [CommRing R] [IsBezout R] {x : R} {y : R} {z : R} (hx : z ‚à£ x) (hy : z ‚à£ y)  : z ‚à£ y = z ‚à£ y
<input>:1:98: expected end of input

(ùïú : Type u_3) (E : Type u_2) [OrderedSemiring ùïú] [AddCommGroup E] [Module ùïú E] [TopologicalSpace E] [TopologicalAddGroup E] {Œπ : Type u_1} (b : (a : Œπ) ‚Üí Set E) (p : (a : Œπ) ‚Üí Prop) (hbasis : Filter.HasBasis nhds 0 p b) (hconvex : ‚àÄ (i : Œπ) (a : p i) , Convex ùïú b i) (x : E) (i : Œπ) (hi : fun (x : E) ‚Ü¶ p x i)  : Convex ùïú b i
invalid universe level, ?u.80758 is not greater than 0 ; identifiers [ùïú, u_3, E, u_2, OrderedSemiring, ùïú, AddCommGroup, E, Module, ùïú, E, TopologicalSpace, E, TopologicalAddGroup, E, Œπ, u_1, b, a, Œπ, Set, E, p, a, Œπ, hbasis, Filter.HasBasis, nhds, p, b, hconvex, i, Œπ, a, p, i, Convex, ùïú, b, i, x, E, i, Œπ, hi, x, E, p, x, i, Convex, ùïú, b, i] (during elaboration)

{Œ± : Type u_1} {Œ≤ : Type u_2} {s : Set Œ±} {t : Set Œ±} {f : (a : Œ±) ‚Üí Œ≤} (hf : Function.Injective f) (h : f '' s ‚äÜ f '' t)  : s ‚äÜ t = s ‚äÜ t
<input>:1:131: expected end of input

{Œ± : Type u_1} {Œ≤ : Type u_2} {s : Set Œ±} {t : Set Œ±} {f : (a : Œ±) ‚Üí Œ≤} (hf : Function.Injective f) (h : f '' s ‚äÜ f '' t)  : f ‚Åª¬π' f '' s ‚äÜ t = f ‚Åª¬π' f '' s ‚äÜ t
<input>:1:142: expected end of input

(q : ‚Ñö)  : q ‚â§ ‚Üë q = q ‚â§ ‚Üë q
<input>:1:19: expected end of input

 : ‚àÄ {Œ± : Type u_1} {f : (a : Œ±) ‚Üí ENNReal} {s : Finset Œ±} (h : Finset.sum s fun (a : Œ±) ‚Ü¶ f a = 1) (h' : ‚àÄ (a : Œ±) (x : ¬¨ a ‚àà s) , f a = 0) {a : Œ±} (ha : ¬¨ a ‚àà s) , ‚Üë Pmf.ofFinset f s h h' a = 0
failed to synthesize instance
  AddCommMonoid Prop ; identifiers [Œ±, u_1, f, a, Œ±, ENNReal, s, Finset, Œ±, h, Finset.sum, s, a, Œ±, f, a, h', a, Œ±, x, a, s, f, a, a, Œ±, ha, a, s, Pmf.ofFinset, f, s, h, h', a] (during elaboration)

 : ‚àÄ {Œ± : Type u_1} {f : (a : Œ±) ‚Üí ENNReal} {s : Finset Œ±} (h : Finset.sum s fun (a : Œ±) ‚Ü¶ f a = 1) (h' : ‚àÄ (a : Œ±) (x : ¬¨ a ‚àà s) , f a = 0) {a : Œ±} (ha : ¬¨ a ‚àà s) , f a = 0
failed to synthesize instance
  AddCommMonoid Prop ; identifiers [Œ±, u_1, f, a, Œ±, ENNReal, s, Finset, Œ±, h, Finset.sum, s, a, Œ±, f, a, h', a, Œ±, x, a, s, f, a, a, Œ±, ha, a, s, f, a] (during elaboration)

 : ‚àÄ {V : Type u_2} {W : Type u_3} {V‚ÇÅ : Type u_1} [inst : SeminormedAddCommGroup V] [inst_1 : SeminormedAddCommGroup W] [inst_2 : SeminormedAddCommGroup V‚ÇÅ] {f : NormedAddGroupHom V W} {g : NormedAddGroupHom V W} (œÜ : NormedAddGroupHom V‚ÇÅ V) (h : NormedAddGroupHom.comp f œÜ = NormedAddGroupHom.comp g œÜ) (C : ‚Ñù) (hœÜ : ‚Äñ œÜ ‚Äñ ‚â§ C) , ‚Äñ NormedAddGroupHom.Equalizer.lift œÜ h ‚Äñ ‚â§ C
<input>:1:325: expected term

 : ‚àÄ {V : Type u_2} {W : Type u_3} {V‚ÇÅ : Type u_1} [inst : SeminormedAddCommGroup V] [inst_1 : SeminormedAddCommGroup W] [inst_2 : SeminormedAddCommGroup V‚ÇÅ] {f : NormedAddGroupHom V W} {g : NormedAddGroupHom V W} (œÜ : NormedAddGroupHom V‚ÇÅ V) (h : NormedAddGroupHom.comp f œÜ = NormedAddGroupHom.comp g œÜ) (C : ‚Ñù) (hœÜ : ‚Äñ œÜ ‚Äñ ‚â§ C) , ‚Äñ œÜ ‚Äñ ‚â§ C
<input>:1:325: expected term

{Œ± : Type u_1} [MulOneClass Œ±] [LT Œ±] [CovariantClass Œ± Œ± Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1 fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] [ContravariantClass Œ± Œ± Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1 fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] (a : Œ±) {b : Œ±}  : a < b * a ‚Üî 1 * a < b * a = a < b * a ‚Üî 1 * a < b * a
<input>:1:285: expected end of input

{Œ± : Type u_1} [MulOneClass Œ±] [LT Œ±] [CovariantClass Œ± Œ± Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1 fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] [ContravariantClass Œ± Œ± Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1 fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] (a : Œ±) {b : Œ±}  : a < b * a ‚Üî a < b * a
application type mismatch
  CovariantClass Œ± Œ± Function.swap
argument
  Function.swap
has type
  ((x : ?m.19) ‚Üí (y : ?m.20) ‚Üí ?m.21 x y) ‚Üí
    (y : ?m.20) ‚Üí (x : ?m.19) ‚Üí ?m.21 x y : Sort (imax (imax ?u.18 ?u.17 ?u.16) ?u.17 ?u.18 ?u.16)
but is expected to have type
  Œ± ‚Üí Œ± ‚Üí Œ± : Type u_1 ; identifiers [Œ±, u_1, MulOneClass, Œ±, LT, Œ±, CovariantClass, Œ±, Œ±, Function.swap, x, Œ±, x_1, Œ±, x, x_1, x, Œ±, x_1, Œ±, x, x_1, ContravariantClass, Œ±, Œ±, Function.swap, x, Œ±, x_1, Œ±, x, x_1, x, Œ±, x_1, Œ±, x, x_1, a, Œ±, b, Œ±, a, b, a, a, b, a] (during elaboration)

{Œ± : Type u_1} [GeneralizedCoheytingAlgebra Œ±] {a : Œ±} {b : Œ±} {c : Œ±} (h : a ‚äî c ‚â§ b ‚äî c)  : a \ c ‚â§ b \ c = a \ c ‚â§ b \ c
<input>:1:108: expected end of input

{Œ± : Type u_1} [GeneralizedCoheytingAlgebra Œ±] {a : Œ±} {b : Œ±} {c : Œ±} (h : a ‚äî c ‚â§ b ‚äî c)  : a ‚äî c \ c ‚â§ b \ c = a ‚äî c \ c ‚â§ b \ c
<input>:1:112: expected end of input

{n : ‚Ñï} {f : Vector ‚Ñï n ‚Üí. ‚Ñï} (pf : Nat.Partrec' f) {m : ‚Ñï} {n : ‚Ñï} {f : Vector ‚Ñï n ‚Üí. ‚Ñï} (g : (a : Fin n) ‚Üí Vector ‚Ñï m ‚Üí. ‚Ñï) (a : Nat.Partrec' f) (a : ‚àÄ (i : Fin n) , Nat.Partrec' g i) (a_ih : Partrec f) (a_ih_1 : ‚àÄ (i : Fin n) , Partrec g i)  : ‚àÄ (i : Fin n) , Partrec g i
application type mismatch
  Nat.Partrec' g
argument
  g
has type
  Fin n ‚Üí Vector ‚Ñï m ‚Üí. ‚Ñï : Type
but is expected to have type
  Vector ‚Ñï ?m.51 ‚Üí. ‚Ñï : Type ; identifiers [n, f, Vector, n, pf, Nat.Partrec', f, m, n, f, Vector, n, g, a, Fin, n, Vector, m, a, Nat.Partrec', f, a, i, Fin, n, Nat.Partrec', g, i, a_ih, Partrec, f, a_ih_1, i, Fin, n, Partrec, g, i, i, Fin, n, Partrec, g, i] (during elaboration)

{Œ± : Type u_1} {l : Filter Œ±} {R : Type u_2} [Distrib R] (f : Filter.Germ l R) (g : Filter.Germ l R) (h : Filter.Germ l R) (f : (a : Œ±) ‚Üí R) (g : (a : Œ±) ‚Üí R) (h : (a : Œ±) ‚Üí R)  : f * g + h =·∂†[l] f * g + f * h = f * g + h =·∂†[l] f * g + f * h
application type mismatch
  f * g + h =·∂†[l] ?m.81592 =·∂†[l] f * g + f * h
argument
  ?m.81592 =·∂†[l] f * g + f * h
has type
  Prop : Type
but is expected to have type
  Œ± ‚Üí R : Type (max u_2 u_1) ; identifiers [Œ±, u_1, l, Filter, Œ±, R, u_2, Distrib, R, f, Filter.Germ, l, R, g, Filter.Germ, l, R, h, Filter.Germ, l, R, f, a, Œ±, R, g, a, Œ±, R, h, a, Œ±, R, f, g, h, l, f, g, f, h, f, g, h, l, f, g, f, h] (during elaboration)

{Œ± : Type u_2} {Œ≤ : Type u_1} [AddMonoid Œ±] [AddAction Œ± Œ≤] {a : Œ≤} (motive : (x : ‚Üë AddAction.orbit Œ± a) ‚Üí Prop) (x : ‚Üë AddAction.orbit Œ± a) (h_1 : ‚àÄ (b : Œ≤) (x : Œ±) (hx : fun (x : Œ±) ‚Ü¶ x +·µ• a x = b) , motive {val := ((b)) , property := (((Exists.intro x hx =: ‚àÉ (y : Œ±) , fun (x : Œ±) ‚Ü¶ x +·µ• a y = b)))}) (val : Œ≤) (property : val ‚àà AddAction.orbit Œ± a)  : ‚àÄ (w : Œ±) (h : fun (x : Œ±) ‚Ü¶ x +·µ• a w = val) , motive {val := ((val)) , property := ((Exists.intro w h))}
<input>:1:260: expected term

{M‚ÇÄ : Type u_1} [inst : MonoidWithZero M‚ÇÄ] {a : M‚ÇÄ} (h : IsUnit Ring.inverse a) (h_1 : Subsingleton M‚ÇÄ) (h_2 : (subsingleton_or_nontrivial M‚ÇÄ =: (Subsingleton M‚ÇÄ : Prop) ‚à® (Nontrivial M‚ÇÄ : Prop)) = (Or.inl h_1 =: (Subsingleton M‚ÇÄ : Prop) ‚à® (Nontrivial M‚ÇÄ : Prop)))  : Or.inl h_1 = subsingleton_or_nontrivial M‚ÇÄ
<input>:1:143: expected term

 : ‚àÄ {G : Type u_1} [inst : AddGroup G] (self : AddSubgroup G) {x : G} (a : x ‚àà AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup AddSubgroup.toAddSubmonoid self) , - x ‚àà AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup AddSubgroup.toAddSubmonoid self
function expected at
  AddSubsemigroup.carrier ?m.79766 AddSubgroup.toAddSubmonoid
term has type
  Prop ; identifiers [G, u_1, inst, AddGroup, G, self, AddSubgroup, G, x, G, a, x, AddSubsemigroup.carrier, AddSubmonoid.toAddSubsemigroup, AddSubgroup.toAddSubmonoid, self, x, AddSubsemigroup.carrier, AddSubmonoid.toAddSubsemigroup, AddSubgroup.toAddSubmonoid, self] (during elaboration)

 : ‚àÄ (G : Type u_1) [inst : AddGroup G] (self : AddSubgroup G) {x : G} (a : x ‚àà AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup self . 1) , - x ‚àà AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup self . 1
function expected at
  AddSubsemigroup.carrier ?m.79766 self
term has type
  Prop ; identifiers [G, u_1, inst, AddGroup, G, self, AddSubgroup, G, x, G, a, x, AddSubsemigroup.carrier, AddSubmonoid.toAddSubsemigroup, self, x, AddSubsemigroup.carrier, AddSubmonoid.toAddSubsemigroup, self] (during elaboration)

{K : Type v} {V : Type w} [Field K] [AddCommGroup V] [Module K V] (f : Module.End K V) (Œºs : Set K) (xs : (a : ‚Üë Œºs) ‚Üí V) (h_eigenvec : ‚àÄ (Œº : ‚Üë Œºs) , Module.End.HasEigenvector f ‚Üë Œº xs Œº) (Œº : {x : K // x ‚àà Œºs})  : Module.End.HasEigenvector f ‚Üë Œº xs Œº
type mismatch
  Œºs
has type
  Set K : Type v
but is expected to have type
  Sort ?u.1398 : Type ?u.1398 ; identifiers [K, v, V, w, Field, K, AddCommGroup, V, Module, K, V, f, Module.End, K, V, Œºs, Set, K, xs, a, Œºs, V, h_eigenvec, Œº, Œºs, Module.End.HasEigenvector, f, Œº, xs, Œº, Œº, x, K, x, Œºs, Module.End.HasEigenvector, f, Œº, xs, Œº] (during elaboration)

{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [Primcodable Œ±] [Primcodable Œ≤] [Primcodable Œ≥] {p : (a : Œ±) ‚Üí Prop} {q : (a : Œ≤) ‚Üí Prop} {r : (a : Œ≥) ‚Üí Prop} (x : p ‚â§‚ÇÄ r) (x_1 : q ‚â§‚ÇÄ r) (f : (a : Œ±) ‚Üí Œ≥) (c‚ÇÅ : Computable f) (h‚ÇÅ : ‚àÄ (a : Œ±) , (p a : Prop) ‚Üî (r f a : Prop)) (g : (a : Œ≤) ‚Üí Œ≥) (c‚ÇÇ : Computable g) (h‚ÇÇ : ‚àÄ (a : Œ≤) , (q a : Prop) ‚Üî (r g a : Prop)) (x : Œ± ‚äï Œ≤) (val : Œ±) (h : x = Sum.inl val)  : Sum.inl val = x
application type mismatch
  r f
argument
  f
has type
  Œ± ‚Üí Œ≥ : Type (max u_1 u_3)
but is expected to have type
  Œ≥ : Type u_3 ; identifiers [Œ±, u_1, Œ≤, u_2, Œ≥, u_3, Primcodable, Œ±, Primcodable, Œ≤, Primcodable, Œ≥, p, a, Œ±, q, a, Œ≤, r, a, Œ≥, x, p, r, x_1, q, r, f, a, Œ±, Œ≥, c‚ÇÅ, Computable, f, h‚ÇÅ, a, Œ±, p, a, r, f, a, g, a, Œ≤, Œ≥, c‚ÇÇ, Computable, g, h‚ÇÇ, a, Œ≤, q, a, r, g, a, x, Œ±, Œ≤, val, Œ±, h, x, Sum.inl, val, Sum.inl, val, x] (during elaboration)

{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [Primcodable Œ±] [Primcodable Œ≤] [Primcodable Œ≥] {p : (a : Œ±) ‚Üí Prop} {q : (a : Œ≤) ‚Üí Prop} {r : (a : Œ≥) ‚Üí Prop} (x : p ‚â§‚ÇÄ r) (x_1 : q ‚â§‚ÇÄ r) (f : (a : Œ±) ‚Üí Œ≥) (c‚ÇÅ : Computable f) (h‚ÇÅ : ‚àÄ (a : Œ±) , (p a : Prop) ‚Üî (r f a : Prop)) (g : (a : Œ≤) ‚Üí Œ≥) (c‚ÇÇ : Computable g) (h‚ÇÇ : ‚àÄ (a : Œ≤) , (q a : Prop) ‚Üî (r g a : Prop)) (x : Œ± ‚äï Œ≤) (val : Œ±) (h : x = Sum.inl val)  : p val ‚Üî r f val
application type mismatch
  r f
argument
  f
has type
  Œ± ‚Üí Œ≥ : Type (max u_1 u_3)
but is expected to have type
  Œ≥ : Type u_3 ; identifiers [Œ±, u_1, Œ≤, u_2, Œ≥, u_3, Primcodable, Œ±, Primcodable, Œ≤, Primcodable, Œ≥, p, a, Œ±, q, a, Œ≤, r, a, Œ≥, x, p, r, x_1, q, r, f, a, Œ±, Œ≥, c‚ÇÅ, Computable, f, h‚ÇÅ, a, Œ±, p, a, r, f, a, g, a, Œ≤, Œ≥, c‚ÇÇ, Computable, g, h‚ÇÇ, a, Œ≤, q, a, r, g, a, x, Œ±, Œ≤, val, Œ±, h, x, Sum.inl, val, p, val, r, f, val] (during elaboration)

{R : Type u‚ÇÅ} [StrictOrderedSemiring R] {a : R} (h : 0 ‚â§ a) (ha : a ‚â§ 1) {i : ‚Ñï} {j : ‚Ñï} (hij : i ‚â§ j) (k : ‚Ñï) (hk : j = i + k)  : a ^ j ‚â§ a ^ i = a ^ j ‚â§ a ^ i
<input>:1:145: expected end of input

{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [Primcodable Œ±] [Primcodable Œ≤] [Primcodable Œ≥] {p : (a : Œ±) ‚Üí Prop} {q : (a : Œ≤) ‚Üí Prop} {r : (a : Œ≥) ‚Üí Prop} (x : p ‚â§‚ÇÄ r) (x_1 : q ‚â§‚ÇÄ r) (f : (a : Œ±) ‚Üí Œ≥) (c‚ÇÅ : Computable f) (h‚ÇÅ : ‚àÄ (a : Œ±) , (p a : Prop) ‚Üî (r f a : Prop)) (g : (a : Œ≤) ‚Üí Œ≥) (c‚ÇÇ : Computable g) (h‚ÇÇ : ‚àÄ (a : Œ≤) , (q a : Prop) ‚Üî (r g a : Prop)) (x : Œ± ‚äï Œ≤) (val : Œ≤) (h : x = Sum.inr val)  : Sum.inr val = x
application type mismatch
  r f
argument
  f
has type
  Œ± ‚Üí Œ≥ : Type (max u_1 u_3)
but is expected to have type
  Œ≥ : Type u_3 ; identifiers [Œ±, u_1, Œ≤, u_2, Œ≥, u_3, Primcodable, Œ±, Primcodable, Œ≤, Primcodable, Œ≥, p, a, Œ±, q, a, Œ≤, r, a, Œ≥, x, p, r, x_1, q, r, f, a, Œ±, Œ≥, c‚ÇÅ, Computable, f, h‚ÇÅ, a, Œ±, p, a, r, f, a, g, a, Œ≤, Œ≥, c‚ÇÇ, Computable, g, h‚ÇÇ, a, Œ≤, q, a, r, g, a, x, Œ±, Œ≤, val, Œ≤, h, x, Sum.inr, val, Sum.inr, val, x] (during elaboration)

{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [Primcodable Œ±] [Primcodable Œ≤] [Primcodable Œ≥] {p : (a : Œ±) ‚Üí Prop} {q : (a : Œ≤) ‚Üí Prop} {r : (a : Œ≥) ‚Üí Prop} (x : p ‚â§‚ÇÄ r) (x_1 : q ‚â§‚ÇÄ r) (f : (a : Œ±) ‚Üí Œ≥) (c‚ÇÅ : Computable f) (h‚ÇÅ : ‚àÄ (a : Œ±) , (p a : Prop) ‚Üî (r f a : Prop)) (g : (a : Œ≤) ‚Üí Œ≥) (c‚ÇÇ : Computable g) (h‚ÇÇ : ‚àÄ (a : Œ≤) , (q a : Prop) ‚Üî (r g a : Prop)) (x : Œ± ‚äï Œ≤) (val : Œ≤) (h : x = Sum.inr val)  : q val ‚Üî r g val
application type mismatch
  r f
argument
  f
has type
  Œ± ‚Üí Œ≥ : Type (max u_1 u_3)
but is expected to have type
  Œ≥ : Type u_3 ; identifiers [Œ±, u_1, Œ≤, u_2, Œ≥, u_3, Primcodable, Œ±, Primcodable, Œ≤, Primcodable, Œ≥, p, a, Œ±, q, a, Œ≤, r, a, Œ≥, x, p, r, x_1, q, r, f, a, Œ±, Œ≥, c‚ÇÅ, Computable, f, h‚ÇÅ, a, Œ±, p, a, r, f, a, g, a, Œ≤, Œ≥, c‚ÇÇ, Computable, g, h‚ÇÇ, a, Œ≤, q, a, r, g, a, x, Œ±, Œ≤, val, Œ≤, h, x, Sum.inr, val, q, val, r, g, val] (during elaboration)

{Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [Primcodable Œ±] [Primcodable Œ≤] [Primcodable Œ≥] {p : (a : Œ±) ‚Üí Prop} {q : (a : Œ≤) ‚Üí Prop} {r : (a : Œ≥) ‚Üí Prop} (x : p ‚â§‚ÇÄ r) (x_1 : q ‚â§‚ÇÄ r) (f : (a : Œ±) ‚Üí Œ≥) (c‚ÇÅ : Computable f) (h‚ÇÅ : ‚àÄ (a : Œ±) , (p a : Prop) ‚Üî (r f a : Prop)) (g : (a : Œ≤) ‚Üí Œ≥) (c‚ÇÇ : Computable g) (h‚ÇÇ : ‚àÄ (a : Œ≤) , (q a : Prop) ‚Üî (r g a : Prop)) (x : Œ± ‚äï Œ≤)  : x = x
application type mismatch
  r f
argument
  f
has type
  Œ± ‚Üí Œ≥ : Type (max u_1 u_3)
but is expected to have type
  Œ≥ : Type u_3 ; identifiers [Œ±, u_1, Œ≤, u_2, Œ≥, u_3, Primcodable, Œ±, Primcodable, Œ≤, Primcodable, Œ≥, p, a, Œ±, q, a, Œ≤, r, a, Œ≥, x, p, r, x_1, q, r, f, a, Œ±, Œ≥, c‚ÇÅ, Computable, f, h‚ÇÅ, a, Œ±, p, a, r, f, a, g, a, Œ≤, Œ≥, c‚ÇÇ, Computable, g, h‚ÇÇ, a, Œ≤, q, a, r, g, a, x, Œ±, Œ≤, x, x] (during elaboration)

 : ‚àÄ {Œ± : Type u} [inst : SizeOf Œ±] , sizeOf LazyList.nil = 1
typeclass instance problem is stuck, it is often due to metavariables
  SizeOf (LazyList ?m.6756) ; identifiers [Œ±, u, inst, SizeOf, Œ±, sizeOf, LazyList.nil] (during elaboration)

{M‚ÇÄ : Type u_1} [inst : MonoidWithZero M‚ÇÄ] {a : M‚ÇÄ} (h : IsUnit Ring.inverse a) (h_1 : Subsingleton M‚ÇÄ) (h_2 : (subsingleton_or_nontrivial M‚ÇÄ =: (Subsingleton M‚ÇÄ : Prop) ‚à® (Nontrivial M‚ÇÄ : Prop)) = (Or.inl h_1 =: (Subsingleton M‚ÇÄ : Prop) ‚à® (Nontrivial M‚ÇÄ : Prop))) (M : Type u_1) (inst : Monoid M) (a : M) (a' : M) (e'_3 : a = a') (h : a' = a) (a' : M)  : a = a
<input>:1:143: expected term

 : ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : MeasurableSpace Œ±] [inst_1 : MeasurableSpace Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (self : MeasurableEmbedding f) ‚¶É s : Set Œ± ‚¶Ñ (a : MeasurableSet s) , MeasurableSet f '' s
application type mismatch
  Set.image (MeasurableSet ?m.353)
argument
  MeasurableSet ?m.353
has type
  Prop : Type
but is expected to have type
  Œ± ‚Üí ?m.79608 self a : Type (max ?u.146 u_1) ; identifiers [Œ±, u_1, Œ≤, u_2, inst, MeasurableSpace, Œ±, inst_1, MeasurableSpace, Œ≤, f, a, Œ±, Œ≤, self, MeasurableEmbedding, f, s, Set, Œ±, a, MeasurableSet, s, MeasurableSet, f, s] (during elaboration)

 : ‚àÄ (Œ± : Type u_1) (Œ≤ : Type u_2) [inst : MeasurableSpace Œ±] [inst_1 : MeasurableSpace Œ≤] (f : (a : Œ±) ‚Üí Œ≤) (self : MeasurableEmbedding f) ‚¶É s : Set Œ± ‚¶Ñ (a : MeasurableSet s) , MeasurableSet f '' s
application type mismatch
  Set.image (MeasurableSet ?m.353)
argument
  MeasurableSet ?m.353
has type
  Prop : Type
but is expected to have type
  Œ± ‚Üí ?m.79608 Œ± Œ≤ f self a : Type (max ?u.146 u_1) ; identifiers [Œ±, u_1, Œ≤, u_2, inst, MeasurableSpace, Œ±, inst_1, MeasurableSpace, Œ≤, f, a, Œ±, Œ≤, self, MeasurableEmbedding, f, s, Set, Œ±, a, MeasurableSet, s, MeasurableSet, f, s] (during elaboration)

{G : Type u_1} [Group G] (H : Subgroup G) (a : G) (b : G)  : Setoid.Rel Doset.setoid ‚Üë Subgroup.toSubmonoid H ‚Üë ‚ä• a b ‚Üî Setoid.Rel Doset.setoid ‚Üë Subgroup.toSubmonoid H ‚Üë ‚ä• a b
function expected at
  Setoid.Rel ?m.80159 ?m.80160 H
term has type
  Prop ; identifiers [G, u_1, Group, G, H, Subgroup, G, a, G, b, G, Setoid.Rel, Doset.setoid, Subgroup.toSubmonoid, H, a, b, Setoid.Rel, Doset.setoid, Subgroup.toSubmonoid, H, a, b] (during elaboration)

{M‚ÇÄ : Type u_1} [inst : MonoidWithZero M‚ÇÄ] {a : M‚ÇÄ} (h : IsUnit Ring.inverse a) (h_1 : Subsingleton M‚ÇÄ) (h_2 : (subsingleton_or_nontrivial M‚ÇÄ =: (Subsingleton M‚ÇÄ : Prop) ‚à® (Nontrivial M‚ÇÄ : Prop)) = (Or.inl h_1 =: (Subsingleton M‚ÇÄ : Prop) ‚à® (Nontrivial M‚ÇÄ : Prop))) (M : Type u_1) (inst : Monoid M) (a : M) (a' : M) (e'_3 : a = a') (h : a' = a)  : a = a'
<input>:1:143: expected term

{M‚ÇÄ : Type u_1} [inst : MonoidWithZero M‚ÇÄ] {a : M‚ÇÄ} (h : IsUnit Ring.inverse a) (h_1 : Subsingleton M‚ÇÄ) (h_2 : (subsingleton_or_nontrivial M‚ÇÄ =: (Subsingleton M‚ÇÄ : Prop) ‚à® (Nontrivial M‚ÇÄ : Prop)) = (Or.inl h_1 =: (Subsingleton M‚ÇÄ : Prop) ‚à® (Nontrivial M‚ÇÄ : Prop))) (M : Type u_1) (inst : Monoid M) (a : M) (a' : M) (e'_3 : a = a')  : a' = a'
<input>:1:143: expected term

{M‚ÇÄ : Type u_1} [inst : MonoidWithZero M‚ÇÄ] {a : M‚ÇÄ} (h : IsUnit Ring.inverse a) (h_1 : Nontrivial M‚ÇÄ) (h_2 : (subsingleton_or_nontrivial M‚ÇÄ =: (Subsingleton M‚ÇÄ : Prop) ‚à® (Nontrivial M‚ÇÄ : Prop)) = (Or.inr h_1 =: (Subsingleton M‚ÇÄ : Prop) ‚à® (Nontrivial M‚ÇÄ : Prop)))  : Or.inr h_1 = subsingleton_or_nontrivial M‚ÇÄ
<input>:1:141: expected term

 : ‚àÄ {E : Type u_1} {F : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] [inst_2 : NormedAddCommGroup F] [inst_3 : NormedSpace ‚Ñù F] (self : SchwartzMap E F) , ContDiff ‚Ñù ‚ä§ SchwartzMap.toFun self
function expected at
  ContDiff ‚Ñù ‚ä§ SchwartzMap.toFun
term has type
  Prop ; identifiers [E, u_1, F, u_2, inst, NormedAddCommGroup, E, inst_1, NormedSpace, E, inst_2, NormedAddCommGroup, F, inst_3, NormedSpace, F, self, SchwartzMap, E, F, ContDiff, SchwartzMap.toFun, self] (during elaboration)

 : ‚àÄ (E : Type u_1) (F : Type u_2) [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] [inst_2 : NormedAddCommGroup F] [inst_3 : NormedSpace ‚Ñù F] (self : SchwartzMap E F) , ContDiff ‚Ñù ‚ä§ self . 1
function expected at
  ContDiff ‚Ñù ‚ä§ ‚Üëself
term has type
  Prop ; identifiers [E, u_1, F, u_2, inst, NormedAddCommGroup, E, inst_1, NormedSpace, E, inst_2, NormedAddCommGroup, F, inst_3, NormedSpace, F, self, SchwartzMap, E, F, ContDiff, self] (during elaboration)

{ùïú : Type u_1} {E : Type u_2} [OrderedSemiring ùïú] [AddCommMonoid E] [Module ùïú E] (x : ConvexCone ùïú E) (x_1 : E) (x_2 : E)  : ‚àÉ (x_3 : E) , x_2 = 0 ‚àß x_3 ‚àà x ‚àß x_2 + x_3 = x_1 = x_2 = 0 ‚àß ‚àÉ (x_3 : E) , x_3 ‚àà x ‚àß x_2 + x_3 = x_1
<input>:1:181: expected end of input

{ùïú : Type u_1} {E : Type u_2} [OrderedSemiring ùïú] [AddCommMonoid E] [Module ùïú E] (x : ConvexCone ùïú E) (x_1 : E)  : ‚àÉ (a : E) , a ‚àà x ‚àß a = x_1 = x_1 ‚àà x
<input>:1:149: expected end of input

{J : Type v} [CategoryTheory.SmallCategory J] (F : CategoryTheory.Functor J TypeMax) [CategoryTheory.IsFilteredOrEmpty J] {i : J} {j : J} {xi : CategoryTheory.Functor.toPrefunctor F . obj i} {xj : CategoryTheory.Functor.toPrefunctor F . obj j}  : EqvGen CategoryTheory.Limits.Types.Quot.Rel F {fst := ((i)) , snd := ((xi))} {fst := ((j)) , snd := ((xj))} ‚Üî EqvGen CategoryTheory.Limits.Types.Quot.Rel F {fst := ((i)) , snd := ((xi))} {fst := ((j)) , snd := ((xj))}
function expected at
  F.toPrefunctor
term has type
  J ‚•§q TypeMax ; identifiers [J, v, CategoryTheory.SmallCategory, J, F, CategoryTheory.Functor, J, TypeMax, CategoryTheory.IsFilteredOrEmpty, J, i, J, j, J, xi, CategoryTheory.Functor.toPrefunctor, F, obj, i, xj, CategoryTheory.Functor.toPrefunctor, F, obj, j, EqvGen, CategoryTheory.Limits.Types.Quot.Rel, F, fst, i, snd, xi, fst, j, snd, xj, EqvGen, CategoryTheory.Limits.Types.Quot.Rel, F, fst, i, snd, xi, fst, j, snd, xj] (during elaboration)

{R : Type u} [CommRing R] [IsBezout R] {x : R} {y : R} {z : R} (hx : z ‚à£ x) (hy : z ‚à£ y)  : z ‚à£ x = z ‚à£ x
<input>:1:98: expected end of input

{R : Type u} [CommRing R] [IsBezout R] {x : R} {y : R} {z : R} (hx : z ‚à£ x) (hy : z ‚à£ y)  : z ‚à£ y = z ‚à£ y
<input>:1:98: expected end of input

(ùïú : Type u_3) (E : Type u_2) [OrderedSemiring ùïú] [AddCommGroup E] [Module ùïú E] [TopologicalSpace E] [TopologicalAddGroup E] {Œπ : Type u_1} (b : (a : Œπ) ‚Üí Set E) (p : (a : Œπ) ‚Üí Prop) (hbasis : Filter.HasBasis nhds 0 p b) (hconvex : ‚àÄ (i : Œπ) (a : p i) , Convex ùïú b i) (x : E) (i : Œπ) (hi : fun (x : E) ‚Ü¶ p x i)  : Convex ùïú b i
invalid universe level, ?u.80758 is not greater than 0 ; identifiers [ùïú, u_3, E, u_2, OrderedSemiring, ùïú, AddCommGroup, E, Module, ùïú, E, TopologicalSpace, E, TopologicalAddGroup, E, Œπ, u_1, b, a, Œπ, Set, E, p, a, Œπ, hbasis, Filter.HasBasis, nhds, p, b, hconvex, i, Œπ, a, p, i, Convex, ùïú, b, i, x, E, i, Œπ, hi, x, E, p, x, i, Convex, ùïú, b, i] (during elaboration)

{Œ± : Type u_1} {Œ≤ : Type u_2} {s : Set Œ±} {t : Set Œ±} {f : (a : Œ±) ‚Üí Œ≤} (hf : Function.Injective f) (h : f '' s ‚äÜ f '' t)  : s ‚äÜ t = s ‚äÜ t
<input>:1:131: expected end of input

{Œ± : Type u_1} {Œ≤ : Type u_2} {s : Set Œ±} {t : Set Œ±} {f : (a : Œ±) ‚Üí Œ≤} (hf : Function.Injective f) (h : f '' s ‚äÜ f '' t)  : f ‚Åª¬π' f '' s ‚äÜ t = f ‚Åª¬π' f '' s ‚äÜ t
<input>:1:142: expected end of input

(q : ‚Ñö)  : q ‚â§ ‚Üë q = q ‚â§ ‚Üë q
<input>:1:19: expected end of input

 : (‚àÄ {ùïú : Type u} [inst : NontriviallyNormedField ùïú] {E : Type uE} [inst_1 : NormedAddCommGroup E] [inst_2 : NormedSpace ùïú E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ùïú F] {n : ‚Ñï‚àû} {f : (a : E) ‚Üí F} {p : (a : E) ‚Üí FormalMultilinearSeries ùïú E F} (self : HasFTaylorSeriesUpTo n f p) (x : E) , ContinuousMultilinearMap.uncurry0 p x 0 = f x)
unknown universe level 'uE' ; identifiers [ùïú, u, inst, NontriviallyNormedField, ùïú, E, uE, inst_1, NormedAddCommGroup, E, inst_2, NormedSpace, ùïú, E, F, uF, inst_3, NormedAddCommGroup, F, inst_4, NormedSpace, ùïú, F, n, f, a, E, F, p, a, E, FormalMultilinearSeries, ùïú, E, F, self, HasFTaylorSeriesUpTo, n, f, p, x, E, ContinuousMultilinearMap.uncurry0, p, x, f, x] (during elaboration)

 : ‚àÄ (ùïú : Type u) [inst : NontriviallyNormedField ùïú] (E : Type uE) [inst_1 : NormedAddCommGroup E] [inst_2 : NormedSpace ùïú E] (F : Type uF) [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ùïú F] (n : ‚Ñï‚àû) (f : (a : E) ‚Üí F) (p : (a : E) ‚Üí FormalMultilinearSeries ùïú E F) (self : HasFTaylorSeriesUpTo n f p) (x : E) , ContinuousMultilinearMap.uncurry0 p x 0 = f x
unknown universe level 'uE' ; identifiers [ùïú, u, inst, NontriviallyNormedField, ùïú, E, uE, inst_1, NormedAddCommGroup, E, inst_2, NormedSpace, ùïú, E, F, uF, inst_3, NormedAddCommGroup, F, inst_4, NormedSpace, ùïú, F, n, f, a, E, F, p, a, E, FormalMultilinearSeries, ùïú, E, F, self, HasFTaylorSeriesUpTo, n, f, p, x, E, ContinuousMultilinearMap.uncurry0, p, x, f, x] (during elaboration)

{Œ± : Type u_1} {Œ≤ : Type u_2} {f : (a : Œ±) ‚Üí Œ≤} {c : Œ±} [AddZeroClass Œ±] (h : Function.Periodic f c)  : f 0 + c = f 0
failed to synthesize instance
  HAdd Œ≤ Œ± ?m.160896 ; identifiers [Œ±, u_1, Œ≤, u_2, f, a, Œ±, Œ≤, c, Œ±, AddZeroClass, Œ±, h, Function.Periodic, f, c, f, c, f] (during elaboration)

 : (‚àÄ {R : Type u} {A : Type v} [inst : CommSemiring R] [inst_1 : Ring A] [inst_2 : Algebra R A] {r : R} {a : A} , (r ‚àà resolventSet R a : Prop) ‚Üî (IsUnit ‚Üë algebraMap R A r - a : Prop))
function expected at
  IsUnit ?m.721
term has type
  Prop ; identifiers [R, u, A, v, inst, CommSemiring, R, inst_1, Ring, A, inst_2, Algebra, R, A, r, R, a, A, r, resolventSet, R, a, IsUnit, algebraMap, R, A, r, a] (during elaboration)

 : (‚àÄ {L : FirstOrder.Language} {M : Type w} {N : Type w'} [inst : FirstOrder.Language.Structure L M] [inst_1 : FirstOrder.Language.Structure L N] (self : FirstOrder.Language.Embedding L M N) {n : ‚Ñï} (r : FirstOrder.Language.Relations L n) (x : (a : Fin n) ‚Üí M) , (FirstOrder.Language.Structure.RelMap r Function.Embedding.toFun FirstOrder.Language.Embedding.toEmbedding self ‚àò x : Prop) ‚Üî (FirstOrder.Language.Structure.RelMap r x : Prop))
unknown universe level 'w'' ; identifiers [L, FirstOrder.Language, M, w, N, w', inst, FirstOrder.Language.Structure, L, M, inst_1, FirstOrder.Language.Structure, L, N, self, FirstOrder.Language.Embedding, L, M, N, n, r, FirstOrder.Language.Relations, L, n, x, a, Fin, n, M, FirstOrder.Language.Structure.RelMap, r, Function.Embedding.toFun, FirstOrder.Language.Embedding.toEmbedding, self, x, FirstOrder.Language.Structure.RelMap, r, x] (during elaboration)

 : ‚àÄ (L : FirstOrder.Language) (M : Type w) (N : Type w') [inst : FirstOrder.Language.Structure L M] [inst_1 : FirstOrder.Language.Structure L N] (self : FirstOrder.Language.Embedding L M N) {n : ‚Ñï} (r : FirstOrder.Language.Relations L n) (x : (a : Fin n) ‚Üí M) , (FirstOrder.Language.Structure.RelMap r Function.Embedding.toFun self . 1 ‚àò x) ‚Üî (FirstOrder.Language.Structure.RelMap r x)
unknown universe level 'w'' ; identifiers [L, FirstOrder.Language, M, w, N, w', inst, FirstOrder.Language.Structure, L, M, inst_1, FirstOrder.Language.Structure, L, N, self, FirstOrder.Language.Embedding, L, M, N, n, r, FirstOrder.Language.Relations, L, n, x, a, Fin, n, M, FirstOrder.Language.Structure.RelMap, r, Function.Embedding.toFun, self, x, FirstOrder.Language.Structure.RelMap, r, x] (during elaboration)

{R : Type u_1} [AddGroup R] [StarAddMonoid R] {x : R}  : (x ‚àà AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup AddSubgroup.toAddSubmonoid selfAdjoint R) ‚Üî (x ‚àà AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup AddSubgroup.toAddSubmonoid selfAdjoint R)
function expected at
  AddSubsemigroup.carrier ?m.80103 AddSubgroup.toAddSubmonoid
term has type
  Prop ; identifiers [R, u_1, AddGroup, R, StarAddMonoid, R, x, R, x, AddSubsemigroup.carrier, AddSubmonoid.toAddSubsemigroup, AddSubgroup.toAddSubmonoid, selfAdjoint, R, x, AddSubsemigroup.carrier, AddSubmonoid.toAddSubsemigroup, AddSubgroup.toAddSubmonoid, selfAdjoint, R] (during elaboration)

{R : Type u_3} {S : Type u_1} {M : Type u_2} {s : S} [SMul R M] [SMul R S] [SMul S M] [IsScalarTower R S M] (a : R) (ab : IsSMulRegular M a ‚Ä¢ s) (c : M) (d : M) (cd : fun (m : M) ‚Ü¶ a ‚Ä¢ m ‚àò fun (x : M) ‚Ü¶ s ‚Ä¢ x c = fun (m : M) ‚Ü¶ a ‚Ä¢ m ‚àò fun (x : M) ‚Ü¶ s ‚Ä¢ x d)  : (a ‚Ä¢ s ‚Ä¢ c = a ‚Ä¢ s ‚Ä¢ d) = (a ‚Ä¢ s ‚Ä¢ c = a ‚Ä¢ s ‚Ä¢ d)
failed to synthesize instance
  HSMul Prop S ?m.90 ; identifiers [R, u_3, S, u_1, M, u_2, s, S, SMul, R, M, SMul, R, S, SMul, S, M, IsScalarTower, R, S, M, a, R, ab, IsSMulRegular, M, a, s, c, M, d, M, cd, m, M, a, m, x, M, s, x, c, m, M, a, m, x, M, s, x, d, a, s, c, a, s, d, a, s, c, a, s, d] (during elaboration)

{R : Type u_3} {S : Type u_1} {M : Type u_2} {s : S} [SMul R M] [SMul R S] [SMul S M] [IsScalarTower R S M] (a : R) (ab : IsSMulRegular M a ‚Ä¢ s) (c : M) (d : M) (cd : fun (m : M) ‚Ü¶ a ‚Ä¢ m ‚àò fun (x : M) ‚Ü¶ s ‚Ä¢ x c = fun (m : M) ‚Ü¶ a ‚Ä¢ m ‚àò fun (x : M) ‚Ü¶ s ‚Ä¢ x d)  : (a ‚Ä¢ s ‚Ä¢ c = a ‚Ä¢ s ‚Ä¢ d) = (a ‚Ä¢ s ‚Ä¢ c = a ‚Ä¢ s ‚Ä¢ d)
failed to synthesize instance
  HSMul Prop S ?m.90 ; identifiers [R, u_3, S, u_1, M, u_2, s, S, SMul, R, M, SMul, R, S, SMul, S, M, IsScalarTower, R, S, M, a, R, ab, IsSMulRegular, M, a, s, c, M, d, M, cd, m, M, a, m, x, M, s, x, c, m, M, a, m, x, M, s, x, d, a, s, c, a, s, d, a, s, c, a, s, d] (during elaboration)

{o : Type u_4} {m' : (a : o) ‚Üí Type u_1} {n' : (a : o) ‚Üí Type u_2} {Œ± : Type u_3} [DecidableEq o] [Zero Œ±] (M : (i : o) ‚Üí Matrix m' i n' i Œ±) (ik : (i : o) √ó m' i) (jk : (i : o) √ó n' i) (fst : o) (snd : m' fst) (h : ik = {fst := ((fst)) , snd := ((snd))})  : {fst := ((fst)) , snd := ((snd))} = ik
application type mismatch
  Matrix m'
argument
  m'
has type
  o ‚Üí Type u_1 : Type (max (u_1 + 1) u_4)
but is expected to have type
  Type ?u.40 : Type (?u.40 + 1) ; identifiers [o, u_4, m', a, o, u_1, n', a, o, u_2, Œ±, u_3, DecidableEq, o, Zero, Œ±, M, i, o, Matrix, m', i, n', i, Œ±, ik, i, o, m', i, jk, i, o, n', i, fst, o, snd, m', fst, h, ik, fst, fst, snd, snd, fst, fst, snd, snd, ik] (during elaboration)

{o : Type u_4} {m' : (a : o) ‚Üí Type u_1} {n' : (a : o) ‚Üí Type u_2} {Œ± : Type u_3} [DecidableEq o] [Zero Œ±] (M : (i : o) ‚Üí Matrix m' i n' i Œ±) (ik : (i : o) √ó m' i) (jk : (i : o) √ó n' i) (fst : o) (snd : m' fst) (h : ik = {fst := ((fst)) , snd := ((snd))}) (t : (i : o) √ó n' i)  : Sigma.fst jk = Sigma.fst {fst := ((fst)) , snd := ((snd))}
application type mismatch
  Matrix m'
argument
  m'
has type
  o ‚Üí Type u_1 : Type (max (u_1 + 1) u_4)
but is expected to have type
  Type ?u.40 : Type (?u.40 + 1) ; identifiers [o, u_4, m', a, o, u_1, n', a, o, u_2, Œ±, u_3, DecidableEq, o, Zero, Œ±, M, i, o, Matrix, m', i, n', i, Œ±, ik, i, o, m', i, jk, i, o, n', i, fst, o, snd, m', fst, h, ik, fst, fst, snd, snd, t, i, o, n', i, Sigma.fst, jk, Sigma.fst, fst, fst, snd, snd] (during elaboration)

{o : Type u_4} {m' : (a : o) ‚Üí Type u_1} {n' : (a : o) ‚Üí Type u_2} {Œ± : Type u_3} [DecidableEq o] [Zero Œ±] (M : (i : o) ‚Üí Matrix m' i n' i Œ±) (ik : (i : o) √ó m' i) (jk : (i : o) √ó n' i) (fst : o) (snd : m' fst) (h : ik = {fst := ((fst)) , snd := ((snd))}) (fst_1 : o) (snd_1 : n' fst_1) (h : jk = {fst := ((fst_1)) , snd := ((snd_1))})  : {fst := ((fst_1)) , snd := ((snd_1))} = jk
application type mismatch
  Matrix m'
argument
  m'
has type
  o ‚Üí Type u_1 : Type (max (u_1 + 1) u_4)
but is expected to have type
  Type ?u.40 : Type (?u.40 + 1) ; identifiers [o, u_4, m', a, o, u_1, n', a, o, u_2, Œ±, u_3, DecidableEq, o, Zero, Œ±, M, i, o, Matrix, m', i, n', i, Œ±, ik, i, o, m', i, jk, i, o, n', i, fst, o, snd, m', fst, h, ik, fst, fst, snd, snd, fst_1, o, snd_1, n', fst_1, h, jk, fst, fst_1, snd, snd_1, fst, fst_1, snd, snd_1, jk] (during elaboration)

{o : Type u_4} {m' : (a : o) ‚Üí Type u_1} {n' : (a : o) ‚Üí Type u_2} {Œ± : Type u_3} [DecidableEq o] [Zero Œ±] (M : (i : o) ‚Üí Matrix m' i n' i Œ±) (ik : (i : o) √ó m' i) (jk : (i : o) √ó n' i) (fst : o) (snd : m' fst) (h : ik = {fst := ((fst)) , snd := ((snd))})  : jk = jk
application type mismatch
  Matrix m'
argument
  m'
has type
  o ‚Üí Type u_1 : Type (max (u_1 + 1) u_4)
but is expected to have type
  Type ?u.40 : Type (?u.40 + 1) ; identifiers [o, u_4, m', a, o, u_1, n', a, o, u_2, Œ±, u_3, DecidableEq, o, Zero, Œ±, M, i, o, Matrix, m', i, n', i, Œ±, ik, i, o, m', i, jk, i, o, n', i, fst, o, snd, m', fst, h, ik, fst, fst, snd, snd, jk, jk] (during elaboration)

{o : Type u_4} {m' : (a : o) ‚Üí Type u_1} {n' : (a : o) ‚Üí Type u_2} {Œ± : Type u_3} [DecidableEq o] [Zero Œ±] (M : (i : o) ‚Üí Matrix m' i n' i Œ±) (ik : (i : o) √ó m' i) (jk : (i : o) √ó n' i)  : ik = ik
application type mismatch
  Matrix m'
argument
  m'
has type
  o ‚Üí Type u_1 : Type (max (u_1 + 1) u_4)
but is expected to have type
  Type ?u.40 : Type (?u.40 + 1) ; identifiers [o, u_4, m', a, o, u_1, n', a, o, u_2, Œ±, u_3, DecidableEq, o, Zero, Œ±, M, i, o, Matrix, m', i, n', i, Œ±, ik, i, o, m', i, jk, i, o, n', i, ik, ik] (during elaboration)

{n : ‚Ñï} {a : Cardinal .{u}}  : (‚Üë n = a) ‚Üî (‚Üë n = a)
<input>:1:22: expected '//', '|' or '}'

{X : Type u_1} [TopologicalSpace X] (toSetoid : Setoid X) (isOpen_setOf_rel : ‚àÄ (x : X) , IsOpen setOf Setoid.Rel toSetoid x) (toSetoid_1 : Setoid X) (isOpen_setOf_rel_1 : ‚àÄ (x : X) , IsOpen setOf Setoid.Rel toSetoid_1 x) (a : {toSetoid := ((toSetoid)) , isOpen_setOf_rel := ((isOpen_setOf_rel))} = {toSetoid := ((toSetoid_1)) , isOpen_setOf_rel := ((isOpen_setOf_rel_1))})  : ‚àÄ (toSetoid_eq : toSetoid = toSetoid_1) , toSetoid = toSetoid_1
function expected at
  IsOpen ?m.219
term has type
  Prop ; identifiers [X, u_1, TopologicalSpace, X, toSetoid, Setoid, X, isOpen_setOf_rel, x, X, IsOpen, setOf, Setoid.Rel, toSetoid, x, toSetoid_1, Setoid, X, isOpen_setOf_rel_1, x, X, IsOpen, setOf, Setoid.Rel, toSetoid_1, x, a, toSetoid, toSetoid, isOpen_setOf_rel, isOpen_setOf_rel, toSetoid, toSetoid_1, isOpen_setOf_rel, isOpen_setOf_rel_1, toSetoid_eq, toSetoid, toSetoid_1, toSetoid, toSetoid_1] (during elaboration)

{Œ± : Type u} {Œ≤ : Type v} [PseudoEMetricSpace Œ±] [PseudoEMetricSpace Œ≤] {K : NNReal} {f : (a : Œ±) ‚Üí Œ≤} (h : LipschitzWith K f) (x : Œ±) (y : Œ±)  : edist f x f y ‚â§ ‚Üë K * edist x y
application type mismatch
  edist f x
argument
  x
has type
  Œ± : Type u
but is expected to have type
  Œ± ‚Üí Œ≤ : Type (max u v) ; identifiers [Œ±, u, Œ≤, v, PseudoEMetricSpace, Œ±, PseudoEMetricSpace, Œ≤, K, NNReal, f, a, Œ±, Œ≤, h, LipschitzWith, K, f, x, Œ±, y, Œ±, edist, f, x, f, y, K, edist, x, y] (during elaboration)

{Œ± : Type u} {Œ≤ : Type v} [Preorder Œ±] [Preorder Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {a : Œ±} (hf : StrictMono f) (ha : IsMax f a) (h : ¬¨ (IsMax a : Prop)) (w : Œ±) (hb : a < w)  : f a < f w
function expected at
  IsMax f
term has type
  Prop ; identifiers [Œ±, u, Œ≤, v, Preorder, Œ±, Preorder, Œ≤, f, a, Œ±, Œ≤, a, Œ±, hf, StrictMono, f, ha, IsMax, f, a, h, IsMax, a, w, Œ±, hb, a, w, f, a, f, w] (during elaboration)

{X : Type u_1} [TopologicalSpace X] (toSetoid : Setoid X) (isOpen_setOf_rel : ‚àÄ (x : X) , IsOpen setOf Setoid.Rel toSetoid x) (toSetoid_1 : Setoid X) (isOpen_setOf_rel_1 : ‚àÄ (x : X) , IsOpen setOf Setoid.Rel toSetoid_1 x) (a : toSetoid = toSetoid_1) (h : toSetoid_1 = toSetoid) (toSetoid_2 : Setoid X)  : toSetoid = toSetoid
function expected at
  IsOpen ?m.219
term has type
  Prop ; identifiers [X, u_1, TopologicalSpace, X, toSetoid, Setoid, X, isOpen_setOf_rel, x, X, IsOpen, setOf, Setoid.Rel, toSetoid, x, toSetoid_1, Setoid, X, isOpen_setOf_rel_1, x, X, IsOpen, setOf, Setoid.Rel, toSetoid_1, x, a, toSetoid, toSetoid_1, h, toSetoid_1, toSetoid, toSetoid_2, Setoid, X, toSetoid, toSetoid] (during elaboration)

{X : Type u_1} [TopologicalSpace X] (toSetoid : Setoid X) (isOpen_setOf_rel : ‚àÄ (x : X) , IsOpen setOf Setoid.Rel toSetoid x) (toSetoid_1 : Setoid X) (isOpen_setOf_rel_1 : ‚àÄ (x : X) , IsOpen setOf Setoid.Rel toSetoid_1 x) (a : toSetoid = toSetoid_1) (h : toSetoid_1 = toSetoid) (isOpen_setOf_rel_2 : ‚àÄ (x : X) , IsOpen setOf Setoid.Rel toSetoid x) (a : toSetoid = toSetoid) (h : HEq a (Eq.refl toSetoid =: toSetoid = toSetoid))  : {toSetoid := ((toSetoid)) , isOpen_setOf_rel := ((isOpen_setOf_rel))} = {toSetoid := ((toSetoid)) , isOpen_setOf_rel := ((isOpen_setOf_rel))}
<input>:1:404: expected term

{X : Type u_1} [TopologicalSpace X] (toSetoid : Setoid X) (isOpen_setOf_rel : ‚àÄ (x : X) , IsOpen setOf Setoid.Rel toSetoid x) (toSetoid_1 : Setoid X) (isOpen_setOf_rel_1 : ‚àÄ (x : X) , IsOpen setOf Setoid.Rel toSetoid_1 x) (a : toSetoid = toSetoid_1) (h : toSetoid_1 = toSetoid)  : toSetoid = toSetoid_1
function expected at
  IsOpen ?m.219
term has type
  Prop ; identifiers [X, u_1, TopologicalSpace, X, toSetoid, Setoid, X, isOpen_setOf_rel, x, X, IsOpen, setOf, Setoid.Rel, toSetoid, x, toSetoid_1, Setoid, X, isOpen_setOf_rel_1, x, X, IsOpen, setOf, Setoid.Rel, toSetoid_1, x, a, toSetoid, toSetoid_1, h, toSetoid_1, toSetoid, toSetoid, toSetoid_1] (during elaboration)

{X : Type u_1} [TopologicalSpace X] (toSetoid : Setoid X) (isOpen_setOf_rel : ‚àÄ (x : X) , IsOpen setOf Setoid.Rel toSetoid x) (toSetoid_1 : Setoid X) (isOpen_setOf_rel_1 : ‚àÄ (x : X) , IsOpen setOf Setoid.Rel toSetoid_1 x) (a : toSetoid = toSetoid_1)  : toSetoid_1 = toSetoid_1
function expected at
  IsOpen ?m.219
term has type
  Prop ; identifiers [X, u_1, TopologicalSpace, X, toSetoid, Setoid, X, isOpen_setOf_rel, x, X, IsOpen, setOf, Setoid.Rel, toSetoid, x, toSetoid_1, Setoid, X, isOpen_setOf_rel_1, x, X, IsOpen, setOf, Setoid.Rel, toSetoid_1, x, a, toSetoid, toSetoid_1, toSetoid_1, toSetoid_1] (during elaboration)

(Œ± : Type u) [Nonempty Œ±] (h : Finite Œ±) (h_1 : (finite_or_infinite Œ± =: (Finite Œ± : Prop) ‚à® (Infinite Œ± : Prop)) = (Or.inl h =: (Finite Œ± : Prop) ‚à® (Infinite Œ± : Prop)))  : Or.inl h = finite_or_infinite Œ±
<input>:1:71: expected term

{op : (a : Ordinal .{u}) ‚Üí (a : Ordinal .{u}) ‚Üí Ordinal .{u}} {a : Ordinal .{u}} {o : Ordinal .{u}} (hao : a < o) (H : Ordinal.IsNormal op a) (ho : Ordinal.Principal op o) (ho' : Ordinal.IsLimit o)  : (op a o ‚â§ o) = (op a o ‚â§ o)
<input>:1:19: expected ')'

{Œ± : Type u_1} {p : (a : Multiset Œ±) ‚Üí Prop} (S : Multiset Œ±) (h‚ÇÅ : p 0) (h‚ÇÇ : ‚àÄ {a : Œ±} {s : Multiset Œ±} (a_1 : a ‚àà S) (a_2 : s ‚äÜ S) (a_3 : p s) , p insert a s)  : ‚àÄ (x : 0 ‚äÜ S) , p 0
application type mismatch
  p insert
argument
  insert
has type
  ?m.163 ‚Üí ?m.165 ‚Üí ?m.165 : Type (max ?u.161 ?u.162)
but is expected to have type
  Multiset Œ± : Type u_1 ; identifiers [Œ±, u_1, p, a, Multiset, Œ±, S, Multiset, Œ±, h‚ÇÅ, p, h‚ÇÇ, a, Œ±, s, Multiset, Œ±, a_1, a, S, a_2, s, S, a_3, p, s, p, insert, a, s, x, S, p] (during elaboration)

{Œ± : Type u_1} {p : (a : Multiset Œ±) ‚Üí Prop} (S : Multiset Œ±) (h‚ÇÅ : p 0) (h‚ÇÇ : ‚àÄ {a : Œ±} {s : Multiset Œ±} (a_1 : a ‚àà S) (a_2 : s ‚äÜ S) (a_3 : p s) , p insert a s) (x : Œ±) (x_1 : Multiset Œ±) (hps : fun (T : Multiset Œ±) ‚Ü¶ ‚àÄ (a : T ‚äÜ S) , p T x_1) (hs : x ::‚Çò x_1 ‚äÜ S) (hS : x ‚àà S) (sS : x_1 ‚äÜ S)  : p x_1
application type mismatch
  p insert
argument
  insert
has type
  ?m.163 ‚Üí ?m.165 ‚Üí ?m.165 : Type (max ?u.161 ?u.162)
but is expected to have type
  Multiset Œ± : Type u_1 ; identifiers [Œ±, u_1, p, a, Multiset, Œ±, S, Multiset, Œ±, h‚ÇÅ, p, h‚ÇÇ, a, Œ±, s, Multiset, Œ±, a_1, a, S, a_2, s, S, a_3, p, s, p, insert, a, s, x, Œ±, x_1, Multiset, Œ±, hps, T, Multiset, Œ±, a, T, S, p, T, x_1, hs, x, x_1, S, hS, x, S, sS, x_1, S, p, x_1] (during elaboration)

{op : (a : Ordinal .{u}) ‚Üí (a : Ordinal .{u}) ‚Üí Ordinal .{u}} {a : Ordinal .{u}} {o : Ordinal .{u}} (hao : a < o) (H : Ordinal.IsNormal op a) (ho : Ordinal.Principal op o) (ho' : Ordinal.IsLimit o) (b : Ordinal .{u}) (hbo : b < o)  : op a b < o
<input>:1:19: expected ')'

(Œ± : Type u) [Nonempty Œ±] (h : Infinite Œ±) (h_1 : (finite_or_infinite Œ± =: (Finite Œ± : Prop) ‚à® (Infinite Œ± : Prop)) = (Or.inr h =: (Finite Œ± : Prop) ‚à® (Infinite Œ± : Prop)))  : Or.inr h = finite_or_infinite Œ±
<input>:1:73: expected term

{n : Type u'} {Œ± : Type v} [Fintype n] [DecidableEq n] [CommRing Œ±] (A : Matrix n n Œ±) (val : Invertible A) (h : (IsUnit.nonempty_invertible (Iff.mpr (Matrix.isUnit_iff_isUnit_det A =: (IsUnit A : Prop) ‚Üî (IsUnit Matrix.det A : Prop)) h_det =: IsUnit A) =: Nonempty Invertible A) = (Nonempty.intro val =: Nonempty Invertible A))  : Nonempty.intro val = IsUnit.nonempty_invertible Iff.mpr Matrix.isUnit_iff_isUnit_det A h_det
<input>:1:183: expected term

{n : Type u'} {Œ± : Type v} [Fintype n] [DecidableEq n] [CommRing Œ±] (A : Matrix n n Œ±) (val : Invertible A) (h : (IsUnit.nonempty_invertible (Iff.mpr (Matrix.isUnit_iff_isUnit_det A =: (IsUnit A : Prop) ‚Üî (IsUnit Matrix.det A : Prop)) h_det =: IsUnit A) =: Nonempty Invertible A) = (Nonempty.intro val =: Nonempty Invertible A))  : ‚Öü A = ‚Öü A
<input>:1:183: expected term

{Œ± : Type u_1} {Œ≤ : Type u_2} {e : LocalEquiv Œ± Œ≤} {s : Set Œ±} {t : Set Œ≤} {e' : LocalEquiv Œ± Œ≤} (h : LocalEquiv.IsImage e s t) (hs : LocalEquiv.source e ‚à© s = LocalEquiv.source e' ‚à© s) (heq : Set.EqOn ‚Üë e ‚Üë e' LocalEquiv.source e ‚à© s) ‚¶É y : Œ≤ ‚¶Ñ (a : y ‚àà ‚Üë e '' LocalEquiv.source e ‚à© s) (x : Œ±) (h : (x ‚àà LocalEquiv.source e ‚à© s : Prop) ‚àß (‚Üë e x = y : Prop)) (hx : x ‚àà LocalEquiv.source e ‚à© s) (right : ‚Üë e x = y) hx' : x ‚àà LocalEquiv.source e ‚à© s := hx  : ‚Üë e x = ‚Üë e' x
<input>:1:414: expected '/--' or ':'

 : (‚àÄ {X : Type u_1} [inst : NormedAddCommGroup X] {M : Type u_2} [inst_1 : Ring M] [inst_2 : Module M X] {P : M} (self : IsLprojection X P) (x : X) , ‚Äñ x ‚Äñ = ‚Äñ P ‚Ä¢ x ‚Äñ + ‚Äñ 1 - P ‚Ä¢ x ‚Äñ)
<input>:1:157: expected term

 : ‚àÄ (X : Type u_1) [inst : NormedAddCommGroup X] (M : Type u_2) [inst_1 : Ring M] [inst_2 : Module M X] (P : M) (self : IsLprojection X P) (x : X) , ‚Äñ x ‚Äñ = ‚Äñ P ‚Ä¢ x ‚Äñ + ‚Äñ 1 - P ‚Ä¢ x ‚Äñ
<input>:1:156: expected term

 : (‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : NormedSpace ùïú E] {H : Type u_3} [inst_3 : TopologicalSpace H] (self : ModelWithCorners ùïú E H) , UniqueDiffOn ùïú LocalEquiv.target ModelWithCorners.toLocalEquiv self)
function expected at
  UniqueDiffOn ùïú ?m.352
term has type
  Prop ; identifiers [ùïú, u_1, inst, NontriviallyNormedField, ùïú, E, u_2, inst_1, NormedAddCommGroup, E, inst_2, NormedSpace, ùïú, E, H, u_3, inst_3, TopologicalSpace, H, self, ModelWithCorners, ùïú, E, H, UniqueDiffOn, ùïú, LocalEquiv.target, ModelWithCorners.toLocalEquiv, self] (during elaboration)

 : ‚àÄ (ùïú : Type u_1) [inst : NontriviallyNormedField ùïú] (E : Type u_2) [inst_1 : NormedAddCommGroup E] [inst_2 : NormedSpace ùïú E] (H : Type u_3) [inst_3 : TopologicalSpace H] (self : ModelWithCorners ùïú E H) , UniqueDiffOn ùïú LocalEquiv.target self . 1
function expected at
  UniqueDiffOn ùïú ?m.352
term has type
  Prop ; identifiers [ùïú, u_1, inst, NontriviallyNormedField, ùïú, E, u_2, inst_1, NormedAddCommGroup, E, inst_2, NormedSpace, ùïú, E, H, u_3, inst_3, TopologicalSpace, H, self, ModelWithCorners, ùïú, E, H, UniqueDiffOn, ùïú, LocalEquiv.target, self] (during elaboration)

{Œ± : Type u_1} {Œ≤ : Type u_2} {e : LocalEquiv Œ± Œ≤} {s : Set Œ±} {t : Set Œ≤} {e' : LocalEquiv Œ± Œ≤} (h : LocalEquiv.IsImage e s t) (hs : LocalEquiv.source e ‚à© s = LocalEquiv.source e' ‚à© s) (heq : Set.EqOn ‚Üë e ‚Üë e' LocalEquiv.source e ‚à© s) ‚¶É y : Œ≤ ‚¶Ñ (a : y ‚àà ‚Üë e '' LocalEquiv.source e ‚à© s) (x : Œ±) (h : (x ‚àà LocalEquiv.source e ‚à© s : Prop) ‚àß (‚Üë e x = y : Prop)) (hx : x ‚àà LocalEquiv.source e ‚à© s) (right : ‚Üë e x = y) hx' : x ‚àà LocalEquiv.source e ‚à© s := hx  : x = x
<input>:1:414: expected '/--' or ':'

{Œ≤ : Type u} {Œ± : Type v} [inst : CommMonoid Œ≤] {p : (a : Œ±) ‚Üí Prop} {F : Fintype Subtype p} (s : Finset Œ±) (h : ‚àÄ (x : Œ±) , (x ‚àà s : Prop) ‚Üî (p x : Prop)) (f : (a : Œ±) ‚Üí Œ≤) (this : fun (x : Œ±) ‚Ü¶ x ‚àà s = p) {F : Fintype {x : Œ± // x ‚àà s}} (h : ‚àÄ (x : Œ±) , (x ‚àà s : Prop) ‚Üî (fun (x : Œ±) ‚Ü¶ x ‚àà s x : Prop)) (Œ± : Type v) (inst : Fintype Œ±) (inst' : Fintype Œ±) (e'_2 : inst = inst') (h : inst' = inst) (inst' : Fintype Œ±)  : inst = inst
application type mismatch
  Fintype Subtype
argument
  Subtype
has type
  (?m.21 ‚Üí Prop) ‚Üí Sort (max 1 ?u.20) : Type (max 1 ?u.20)
but is expected to have type
  Type ?u.19 : Type (?u.19 + 1) ; identifiers [Œ≤, u, Œ±, v, inst, CommMonoid, Œ≤, p, a, Œ±, F, Fintype, Subtype, p, s, Finset, Œ±, h, x, Œ±, x, s, p, x, f, a, Œ±, Œ≤, this, x, Œ±, x, s, p, F, Fintype, x, Œ±, x, s, h, x, Œ±, x, s, x, Œ±, x, s, x, Œ±, v, inst, Fintype, Œ±, inst', Fintype, Œ±, e'_2, inst, inst', h, inst', inst, inst', Fintype, Œ±, inst, inst] (during elaboration)

{Œ≤ : Type u} {Œ± : Type v} [inst : CommMonoid Œ≤] {p : (a : Œ±) ‚Üí Prop} {F : Fintype Subtype p} (s : Finset Œ±) (h : ‚àÄ (x : Œ±) , (x ‚àà s : Prop) ‚Üî (p x : Prop)) (f : (a : Œ±) ‚Üí Œ≤) (this : fun (x : Œ±) ‚Ü¶ x ‚àà s = p) {F : Fintype {x : Œ± // x ‚àà s}} (h : ‚àÄ (x : Œ±) , (x ‚àà s : Prop) ‚Üî (fun (x : Œ±) ‚Ü¶ x ‚àà s x : Prop)) (Œ± : Type v) (inst : Fintype Œ±) (inst' : Fintype Œ±) (e'_2 : inst = inst') (h : inst' = inst)  : inst = inst'
application type mismatch
  Fintype Subtype
argument
  Subtype
has type
  (?m.21 ‚Üí Prop) ‚Üí Sort (max 1 ?u.20) : Type (max 1 ?u.20)
but is expected to have type
  Type ?u.19 : Type (?u.19 + 1) ; identifiers [Œ≤, u, Œ±, v, inst, CommMonoid, Œ≤, p, a, Œ±, F, Fintype, Subtype, p, s, Finset, Œ±, h, x, Œ±, x, s, p, x, f, a, Œ±, Œ≤, this, x, Œ±, x, s, p, F, Fintype, x, Œ±, x, s, h, x, Œ±, x, s, x, Œ±, x, s, x, Œ±, v, inst, Fintype, Œ±, inst', Fintype, Œ±, e'_2, inst, inst', h, inst', inst, inst, inst'] (during elaboration)

{Œ≤ : Type u} {Œ± : Type v} [inst : CommMonoid Œ≤] {p : (a : Œ±) ‚Üí Prop} {F : Fintype Subtype p} (s : Finset Œ±) (h : ‚àÄ (x : Œ±) , (x ‚àà s : Prop) ‚Üî (p x : Prop)) (f : (a : Œ±) ‚Üí Œ≤) (this : fun (x : Œ±) ‚Ü¶ x ‚àà s = p) {F : Fintype {x : Œ± // x ‚àà s}} (h : ‚àÄ (x : Œ±) , (x ‚àà s : Prop) ‚Üî (fun (x : Œ±) ‚Ü¶ x ‚àà s x : Prop)) (Œ± : Type v) (inst : Fintype Œ±) (inst' : Fintype Œ±) (e'_2 : inst = inst')  : inst' = inst'
application type mismatch
  Fintype Subtype
argument
  Subtype
has type
  (?m.21 ‚Üí Prop) ‚Üí Sort (max 1 ?u.20) : Type (max 1 ?u.20)
but is expected to have type
  Type ?u.19 : Type (?u.19 + 1) ; identifiers [Œ≤, u, Œ±, v, inst, CommMonoid, Œ≤, p, a, Œ±, F, Fintype, Subtype, p, s, Finset, Œ±, h, x, Œ±, x, s, p, x, f, a, Œ±, Œ≤, this, x, Œ±, x, s, p, F, Fintype, x, Œ±, x, s, h, x, Œ±, x, s, x, Œ±, x, s, x, Œ±, v, inst, Fintype, Œ±, inst', Fintype, Œ±, e'_2, inst, inst', inst', inst'] (during elaboration)

{Œ© : Type u_1} {Œπ : Type u_2} {m0 : MeasurableSpace Œ©} {Œº : MeasureTheory.Measure Œ©} [MeasureTheory.IsProbabilityMeasure Œº] {s : (a : Œπ) ‚Üí MeasurableSpace Œ©} [SemilatticeSup Œπ] [NoMaxOrder Œπ] [Nonempty Œπ] (h_le : ‚àÄ (n : Œπ) , s n ‚â§ m0) (h_indep : ProbabilityTheory.iIndep s) ns : (a : Œπ) ‚Üí Set Œπ := Set.Iic (hnsp : ‚àÄ (i : Œπ) , BddAbove ns i) (t : Set Œπ) (a : ‚àÉ (x : Œπ) , x ‚àà {x : Œπ | ‚àÄ ‚¶É a : Œπ ‚¶Ñ (a_1 : a ‚àà t) , a ‚â§ x}) (a : Œπ) (ha : a ‚àà {x : Œπ | ‚àÄ ‚¶É a : Œπ ‚¶Ñ (a_1 : a ‚àà t) , a ‚â§ x}) (b : Œπ) (hb : a < b) (c : Œπ) (hc : b ‚â§ c) (hct : c ‚àà t)  : c ‚â§ a
<input>:1:277: expected end of input

{M : Type u_2} [AddZeroClass M] {Œπ : Sort u_1} {S : (a : Œπ) ‚Üí AddSubmonoid M} {x : M} (motive : (x : ‚àÉ (i : Œπ) , x ‚àà S i) ‚Üí Prop) (x_1 : ‚àÉ (i : Œπ) , x ‚àà S i) (h_1 : ‚àÄ (i : Œπ) (hi : x ‚àà S i) , motive (Exists.intro i hi =: ‚àÉ (i : Œπ) , x ‚àà S i))  : ‚àÄ (w : Œπ) (h : x ‚àà S w) , motive Exists.intro w h
<input>:1:219: expected term

(n : ‚Ñï) {a : Fin n + 1} (ha : ¬¨ (IsMax a : Prop)) (b : Fin n + 1)  : (a < ‚ä§) = (a < ‚ä§)
failed to synthesize instance
  LE (Fin n + 1) ; identifiers [n, a, Fin, n, ha, IsMax, a, b, Fin, n, a, a] (during elaboration)

{V : Type u_1} [NormedAddCommGroup V] [InnerProductSpace ‚Ñù V] [Fact (FiniteDimensional.finrank ‚Ñù V = 2 : Prop)] (o : Orientation ‚Ñù V Fin 2) {x : V} {y : V} (h : Orientation.oangle o x y = ‚Üë - Real.pi / 2)  : ‚Üë - Real.pi / 2 = Orientation.oangle o x y
<input>:1:190: unexpected token at this precedence level; consider parenthesizing the term

(n : ‚Ñï) {a : Fin n + 1} (ha : ¬¨ (IsMax a : Prop)) (b : Fin n + 1)  : (¬¨ (‚ä§ ‚â§ a : Prop)) = (¬¨ (‚ä§ ‚â§ a : Prop))
failed to synthesize instance
  LE (Fin n + 1) ; identifiers [n, a, Fin, n, ha, IsMax, a, b, Fin, n, a, a] (during elaboration)

(n : ‚Ñï) {a : Fin n + 1} (ha : ¬¨ (IsMax a : Prop)) (b : Fin n + 1)  : (¬¨ (a = ‚ä§ : Prop)) = (¬¨ (a = ‚ä§ : Prop))
failed to synthesize instance
  LE (Fin n + 1) ; identifiers [n, a, Fin, n, ha, IsMax, a, b, Fin, n, a, a] (during elaboration)

(n : ‚Ñï) {a : Fin n + 1} (ha : ¬¨ (IsMax a : Prop)) (b : Fin n + 1)  : ((a < b : Prop) ‚Üî (a + 1 ‚â§ b : Prop)) = ((a < b : Prop) ‚Üî (a + 1 ‚â§ b : Prop))
failed to synthesize instance
  LE (Fin n + 1) ; identifiers [n, a, Fin, n, ha, IsMax, a, b, Fin, n, a, b, a, b, a, b, a, b] (during elaboration)

 : (‚àÄ {Œ± : Type u_1} [inst : SDiff Œ±] {a : Part Œ±} {b : Part Œ±} (hab : Part.Dom a \ b) , Part.Dom b)
application type mismatch
  a.Dom \ b
argument
  b
has type
  Part Œ± : Type u_1
but is expected to have type
  Prop : Type ; identifiers [Œ±, u_1, inst, SDiff, Œ±, a, Part, Œ±, b, Part, Œ±, hab, Part.Dom, a, b, Part.Dom, b] (during elaboration)

 : ‚àÄ {Œ± : Type u_1} [inst : SDiff Œ±] {a : Part Œ±} {b : Part Œ±} (hab : Part.Dom a \ b) , Part.Dom fun (b_1 : Part.Dom fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x \ x_1 <$> a) ‚Ü¶ fun (y : (a : Œ±) ‚Üí Œ±) ‚Ü¶ Part.map y fun (x : Unit) ‚Ü¶ b () Part.get fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x \ x_1 <$> a b_1 hab . 1
application type mismatch
  a.Dom \ b
argument
  b
has type
  Part Œ± : Type u_1
but is expected to have type
  Prop : Type ; identifiers [Œ±, u_1, inst, SDiff, Œ±, a, Part, Œ±, b, Part, Œ±, hab, Part.Dom, a, b, Part.Dom, b_1, Part.Dom, x, Œ±, x_1, Œ±, x, x_1, a, y, a, Œ±, Œ±, Part.map, y, x, Unit, b, Part.get, x, Œ±, x_1, Œ±, x, x_1, a, b_1, hab] (during elaboration)

(n : ‚Ñï) {a : Fin n + 1} (ha : ¬¨ (IsMax a : Prop)) (b : Fin n + 1)  : ((‚Üë a < ‚Üë b : Prop) ‚Üî (a + 1 ‚â§ b : Prop)) = ((‚Üë a < ‚Üë b : Prop) ‚Üî (a + 1 ‚â§ b : Prop))
failed to synthesize instance
  LE (Fin n + 1) ; identifiers [n, a, Fin, n, ha, IsMax, a, b, Fin, n, a, b, a, b, a, b, a, b] (during elaboration)

 : (- 1 = ‚Üë - 1) = (- 1 = ‚Üë - 1)
<input>:1:12: unexpected token at this precedence level; consider parenthesizing the term

(n : ‚Ñï) {a : Fin n + 1} (ha : ¬¨ (IsMax a : Prop)) (b : Fin n + 1)  : ((‚Üë a < ‚Üë b : Prop) ‚Üî (‚Üë a + 1 ‚â§ ‚Üë b : Prop)) = ((‚Üë a < ‚Üë b : Prop) ‚Üî (‚Üë a + 1 ‚â§ ‚Üë b : Prop))
failed to synthesize instance
  LE (Fin n + 1) ; identifiers [n, a, Fin, n, ha, IsMax, a, b, Fin, n, a, b, a, b, a, b, a, b] (during elaboration)

 : (‚àÄ {R : Type u} {Œπ : Type u'} {M‚ÇÅ : (a : Œπ) ‚Üí Type v} {M‚ÇÇ : Type w} [inst : Semiring R] [inst_1 : (i : Œπ) ‚Üí AddCommMonoid M‚ÇÅ i] [inst_2 : AddCommMonoid M‚ÇÇ] [inst_3 : (i : Œπ) ‚Üí Module R M‚ÇÅ i] [inst_4 : Module R M‚ÇÇ] (self : MultilinearMap R M‚ÇÅ M‚ÇÇ) [inst_5 : DecidableEq Œπ] (m : (i : Œπ) ‚Üí M‚ÇÅ i) (i : Œπ) (x : M‚ÇÅ i) (y : M‚ÇÅ i) , MultilinearMap.toFun self Function.update m i x + y = MultilinearMap.toFun self Function.update m i x + MultilinearMap.toFun self Function.update m i y)
application type mismatch
  AddCommMonoid M‚ÇÅ
argument
  M‚ÇÅ
has type
  Œπ ‚Üí Type v : Type (max u' (v + 1))
but is expected to have type
  Type ?u.20 : Type (?u.20 + 1) ; identifiers [R, u, Œπ, u', M‚ÇÅ, a, Œπ, v, M‚ÇÇ, w, inst, Semiring, R, inst_1, i, Œπ, AddCommMonoid, M‚ÇÅ, i, inst_2, AddCommMonoid, M‚ÇÇ, inst_3, i, Œπ, Module, R, M‚ÇÅ, i, inst_4, Module, R, M‚ÇÇ, self, MultilinearMap, R, M‚ÇÅ, M‚ÇÇ, inst_5, DecidableEq, Œπ, m, i, Œπ, M‚ÇÅ, i, i, Œπ, x, M‚ÇÅ, i, y, M‚ÇÅ, i, MultilinearMap.toFun, self, Function.update, m, i, x, y, MultilinearMap.toFun, self, Function.update, m, i, x, MultilinearMap.toFun, self, Function.update, m, i, y] (during elaboration)

 : ‚àÄ (R : Type u) (Œπ : Type u') (M‚ÇÅ : (a : Œπ) ‚Üí Type v) (M‚ÇÇ : Type w) [inst : Semiring R] [inst_1 : (i : Œπ) ‚Üí AddCommMonoid M‚ÇÅ i] [inst_2 : AddCommMonoid M‚ÇÇ] [inst_3 : (i : Œπ) ‚Üí Module R M‚ÇÅ i] [inst_4 : Module R M‚ÇÇ] (self : MultilinearMap R M‚ÇÅ M‚ÇÇ) [inst : DecidableEq Œπ] (m : (i : Œπ) ‚Üí M‚ÇÅ i) (i : Œπ) (x : M‚ÇÅ i) (y : M‚ÇÅ i) , self . 1 Function.update m i x + y = self . 1 Function.update m i x + self . 1 Function.update m i y
application type mismatch
  AddCommMonoid M‚ÇÅ
argument
  M‚ÇÅ
has type
  Œπ ‚Üí Type v : Type (max u' (v + 1))
but is expected to have type
  Type ?u.20 : Type (?u.20 + 1) ; identifiers [R, u, Œπ, u', M‚ÇÅ, a, Œπ, v, M‚ÇÇ, w, inst, Semiring, R, inst_1, i, Œπ, AddCommMonoid, M‚ÇÅ, i, inst_2, AddCommMonoid, M‚ÇÇ, inst_3, i, Œπ, Module, R, M‚ÇÅ, i, inst_4, Module, R, M‚ÇÇ, self, MultilinearMap, R, M‚ÇÅ, M‚ÇÇ, inst, DecidableEq, Œπ, m, i, Œπ, M‚ÇÅ, i, i, Œπ, x, M‚ÇÅ, i, y, M‚ÇÅ, i, self, Function.update, m, i, x, y, self, Function.update, m, i, x, self, Function.update, m, i, y] (during elaboration)

 : (‚àÄ {Œ± : Type u} [inst : SizeOf Œ±] , sizeOf LazyList.nil = 1)
typeclass instance problem is stuck, it is often due to metavariables
  SizeOf (LazyList ?m.6756) ; identifiers [Œ±, u, inst, SizeOf, Œ±, sizeOf, LazyList.nil] (during elaboration)

{Œ± : Type u_1} [OrderedAddCommGroup Œ±] {a : Œ±} (ha : 0 ‚â§ a) (m : ‚Ñ§) (n : ‚Ñ§) (h : m ‚â§ n)  : (m ‚Ä¢ a + n - m ‚Ä¢ a = n ‚Ä¢ a) = (m ‚Ä¢ a + n - m ‚Ä¢ a = n ‚Ä¢ a)
failed to synthesize instance
  HAdd Œ± ‚Ñ§ ?m.161069 ; identifiers [Œ±, u_1, OrderedAddCommGroup, Œ±, a, Œ±, ha, a, m, n, h, m, n, m, a, n, m, a, n, a, m, a, n, m, a, n, a] (during elaboration)

{V : Type w'} [FirstOrder.Language.Structure FirstOrder.Language.graph V] (œÜ : FirstOrder.Language.Sentence FirstOrder.Language.graph)  : (V ‚ä® œÜ) = (V ‚ä® œÜ)
unknown universe level 'w'' ; identifiers [V, w', FirstOrder.Language.Structure, FirstOrder.Language.graph, V, œÜ, FirstOrder.Language.Sentence, FirstOrder.Language.graph, V, œÜ, V, œÜ, V, œÜ, V, œÜ] (during elaboration)

{V : Type w'} [FirstOrder.Language.Structure FirstOrder.Language.graph V]  : (‚àÄ (a : FirstOrder.Language.Sentence FirstOrder.Language.graph) (a_1 : (a = FirstOrder.Language.Relations.irreflexive FirstOrder.Language.adj : Prop) ‚à® (a = FirstOrder.Language.Relations.symmetric FirstOrder.Language.adj : Prop)) , V ‚ä® a) = ((V ‚ä® FirstOrder.Language.Relations.irreflexive FirstOrder.Language.adj : Prop) ‚àß (‚àÄ (a : FirstOrder.Language.Sentence FirstOrder.Language.graph) (a_1 : a = FirstOrder.Language.Relations.symmetric FirstOrder.Language.adj) , V ‚ä® a : Prop))
unknown universe level 'w'' ; identifiers [V, w', FirstOrder.Language.Structure, FirstOrder.Language.graph, V, a, FirstOrder.Language.Sentence, FirstOrder.Language.graph, a_1, a, FirstOrder.Language.Relations.irreflexive, FirstOrder.Language.adj, a, FirstOrder.Language.Relations.symmetric, FirstOrder.Language.adj, V, a, V, a, V, FirstOrder.Language.Relations.irreflexive, FirstOrder.Language.adj, V, FirstOrder.Language.Relations.irreflexive, FirstOrder.Language.adj, a, FirstOrder.Language.Sentence, FirstOrder.Language.graph, a_1, a, FirstOrder.Language.Relations.symmetric, FirstOrder.Language.adj, V, a, V, a] (during elaboration)

{V : Type w'} [FirstOrder.Language.Structure FirstOrder.Language.graph V]  : (‚àÄ (a : FirstOrder.Language.Sentence FirstOrder.Language.graph) (a_1 : a = FirstOrder.Language.Relations.symmetric FirstOrder.Language.adj) , V ‚ä® a) = (V ‚ä® FirstOrder.Language.Relations.symmetric FirstOrder.Language.adj)
unknown universe level 'w'' ; identifiers [V, w', FirstOrder.Language.Structure, FirstOrder.Language.graph, V, a, FirstOrder.Language.Sentence, FirstOrder.Language.graph, a_1, a, FirstOrder.Language.Relations.symmetric, FirstOrder.Language.adj, V, a, V, a, V, FirstOrder.Language.Relations.symmetric, FirstOrder.Language.adj, V, FirstOrder.Language.Relations.symmetric, FirstOrder.Language.adj] (during elaboration)

{R : Type u_1} [CommRing R] (asIdeal : Ideal R) (isPrime : Ideal.IsPrime asIdeal) (ne_bot : asIdeal ‚â† ‚ä•) (asIdeal_1 : Ideal R) (isPrime_1 : Ideal.IsPrime asIdeal_1) (ne_bot_1 : asIdeal_1 ‚â† ‚ä•) (a : asIdeal = asIdeal_1) (h : asIdeal_1 = asIdeal) (isPrime_2 : Ideal.IsPrime asIdeal) (ne_bot_2 : asIdeal ‚â† ‚ä•) (a : asIdeal = asIdeal) (h : HEq a (Eq.refl asIdeal =: asIdeal = asIdeal))  : {asIdeal := ((asIdeal)) , isPrime := ((isPrime)) , ne_bot := ((ne_bot))} = {asIdeal := ((asIdeal)) , isPrime := ((isPrime)) , ne_bot := ((ne_bot))}
<input>:1:358: expected term

{K : Type u} {V : Type v} [DivisionRing K] [AddCommGroup V] [Module K V] (Œπ : Type u_1) [Unique Œπ] (h : FiniteDimensional.finrank K V = 1) (v : V) (hv : v ‚â† 0)  : {v} = {v}
typeclass instance problem is stuck, it is often due to metavariables
  Singleton V (?m.1867 Œπ h v hv) ; identifiers [K, u, V, v, DivisionRing, K, AddCommGroup, V, Module, K, V, Œπ, u_1, Unique, Œπ, h, FiniteDimensional.finrank, K, V, v, V, hv, v, v, v, v, v] (during elaboration)

{P : AlgebraicGeometry.AffineTargetMorphismProperty} (hP : CategoryTheory.MorphismProperty.RespectsIso AlgebraicGeometry.AffineTargetMorphismProperty.toProperty P) {X : AlgebraicGeometry.Scheme} {Y : AlgebraicGeometry.Scheme} {Z : AlgebraicGeometry.Scheme} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) [CategoryTheory.IsIso g] [AlgebraicGeometry.IsAffine Z] [AlgebraicGeometry.IsAffine Y]  : (AlgebraicGeometry.AffineTargetMorphismProperty.toProperty P f) ‚Üî (AlgebraicGeometry.AffineTargetMorphismProperty.toProperty P f)
function expected at
  CategoryTheory.MorphismProperty.RespectsIso ?m.79589
term has type
  Prop ; identifiers [P, AlgebraicGeometry.AffineTargetMorphismProperty, hP, CategoryTheory.MorphismProperty.RespectsIso, AlgebraicGeometry.AffineTargetMorphismProperty.toProperty, P, X, AlgebraicGeometry.Scheme, Y, AlgebraicGeometry.Scheme, Z, AlgebraicGeometry.Scheme, f, X, Y, g, Y, Z, CategoryTheory.IsIso, g, AlgebraicGeometry.IsAffine, Z, AlgebraicGeometry.IsAffine, Y, AlgebraicGeometry.AffineTargetMorphismProperty.toProperty, P, f, AlgebraicGeometry.AffineTargetMorphismProperty.toProperty, P, f] (during elaboration)

{Œ± : Sort u_1} {Œ≤ : Sort u_2} [Finite Œ≤] (f : (a : Œ±) ‚Üí Œ≤) (H : Function.Injective f) (val : Fintype PLift Œ≤) (h : (nonempty_fintype PLift Œ≤ =: Nonempty Fintype PLift Œ≤) = (Nonempty.intro val =: Nonempty Fintype PLift Œ≤))  : Nonempty.intro val = nonempty_fintype PLift Œ≤
<input>:1:142: expected term

{Œ± : Type u_2} {Œπ : Type u_1} {m0 : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} [Countable Œπ] {s : (a : Œπ) ‚Üí Set Œ±} (hd : Pairwise Disjoint on s) (hm : ‚àÄ (i : Œπ) , MeasurableSet s i) (i : Œπ)  : MeasurableSet s i
type expected, got
  (?m.79791 on s : Œπ ‚Üí Œπ ‚Üí ?m.40) ; identifiers [Œ±, u_2, Œπ, u_1, m0, MeasurableSpace, Œ±, Œº, MeasureTheory.Measure, Œ±, Countable, Œπ, s, a, Œπ, Set, Œ±, hd, Pairwise, Disjoint, s, hm, i, Œπ, MeasurableSet, s, i, i, Œπ, MeasurableSet, s, i] (during elaboration)

{Œ± : Type u_1} {E' : Type u_2} [SeminormedAddCommGroup E'] {l : Filter Œ±} {f‚ÇÅ : (a : Œ±) ‚Üí E'} {f‚ÇÇ : (a : Œ±) ‚Üí E'} (h : f‚ÇÇ =o[l] f‚ÇÅ)  : (f‚ÇÅ =O[l] f‚ÇÅ + f‚ÇÇ) = (f‚ÇÅ =O[l] f‚ÇÅ + f‚ÇÇ)
failed to synthesize
  CoeT (Œ± ‚Üí E') x Prop
(deterministic) timeout at 'typeclass', maximum number of heartbeats (20000) has been reached (use 'set_option synthInstance.maxHeartbeats <num>' to set the limit) ; identifiers [Œ±, u_1, E', u_2, SeminormedAddCommGroup, E', l, Filter, Œ±, f‚ÇÅ, a, Œ±, E', f‚ÇÇ, a, Œ±, E', h, f‚ÇÇ, l, f‚ÇÅ, f‚ÇÅ, l, f‚ÇÅ, f‚ÇÇ, f‚ÇÅ, l, f‚ÇÅ, f‚ÇÇ] (during elaboration)

{Œ± : Type u} {s : Stream' Œ±} (x : ‚Ñï) (x_1 : ‚Ñï) (x : ‚Ñï) (f : Nat.below (motive := fun (x : ‚Ñï) ‚Ü¶ ‚àÄ {s : Stream' Œ±} (x_2 : ‚Ñï) , List.take x Stream'.take x_2 s = Stream'.take min x_2 x s) x) {s : Stream' Œ±} (x_2 : ‚Ñï) (n : ‚Ñï) (x : Nat.below (motive := fun (x : ‚Ñï) ‚Ü¶ ‚àÄ {s : Stream' Œ±} (x_3 : ‚Ñï) , List.take x Stream'.take x_3 s = Stream'.take min x_3 x s) 0)  : [] = []
function expected at
  List.take x ?m.79956
term has type
  List ?m.30 ; identifiers [Œ±, u, s, Stream', Œ±, x, x_1, x, f, Nat.below, motive, x, s, Stream', Œ±, x_2, List.take, x, Stream'.take, x_2, s, Stream'.take, min, x_2, x, s, x, s, Stream', Œ±, x_2, n, x, Nat.below, motive, x, s, Stream', Œ±, x_3, List.take, x, Stream'.take, x_3, s, Stream'.take, min, x_3, x, s] (during elaboration)

{R : Type u} {A : Type v} {inst : CommSemiring R} {inst_1 : NonUnitalNonAssocSemiring A} {inst_2 : Module R A} {inst_3 : Star A} {toNonUnitalSubalgebra : NonUnitalSubalgebra R A} {star_mem' : ‚àÄ {a : A} (_ha : a ‚àà AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup NonUnitalSubsemiring.toAddSubmonoid NonUnitalSubalgebra.toNonUnitalSubsemiring toNonUnitalSubalgebra) , star a ‚àà AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup NonUnitalSubsemiring.toAddSubmonoid NonUnitalSubalgebra.toNonUnitalSubsemiring toNonUnitalSubalgebra} {toNonUnitalSubalgebra_1 : NonUnitalSubalgebra R A} {star_mem'_1 : ‚àÄ {a : A} (_ha : a ‚àà AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup NonUnitalSubsemiring.toAddSubmonoid NonUnitalSubalgebra.toNonUnitalSubsemiring toNonUnitalSubalgebra_1) , star a ‚àà AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup NonUnitalSubsemiring.toAddSubmonoid NonUnitalSubalgebra.toNonUnitalSubsemiring toNonUnitalSubalgebra_1} (x : {toNonUnitalSubalgebra := ((toNonUnitalSubalgebra)) , star_mem' := ((star_mem'))} = {toNonUnitalSubalgebra := ((toNonUnitalSubalgebra_1)) , star_mem' := ((star_mem'_1))})  : ‚àÄ (toNonUnitalSubalgebra_eq : toNonUnitalSubalgebra = toNonUnitalSubalgebra_1) , toNonUnitalSubalgebra = toNonUnitalSubalgebra_1
function expected at
  AddSubsemigroup.carrier ?m.80289 NonUnitalSubsemiring.toAddSubmonoid
term has type
  Prop ; identifiers [R, u, A, v, inst, CommSemiring, R, inst_1, NonUnitalNonAssocSemiring, A, inst_2, Module, R, A, inst_3, Star, A, toNonUnitalSubalgebra, NonUnitalSubalgebra, R, A, star_mem', a, A, _ha, a, AddSubsemigroup.carrier, AddSubmonoid.toAddSubsemigroup, NonUnitalSubsemiring.toAddSubmonoid, NonUnitalSubalgebra.toNonUnitalSubsemiring, toNonUnitalSubalgebra, star, a, AddSubsemigroup.carrier, AddSubmonoid.toAddSubsemigroup, NonUnitalSubsemiring.toAddSubmonoid, NonUnitalSubalgebra.toNonUnitalSubsemiring, toNonUnitalSubalgebra, toNonUnitalSubalgebra_1, NonUnitalSubalgebra, R, A, star_mem'_1, a, A, _ha, a, AddSubsemigroup.carrier, AddSubmonoid.toAddSubsemigroup, NonUnitalSubsemiring.toAddSubmonoid, NonUnitalSubalgebra.toNonUnitalSubsemiring, toNonUnitalSubalgebra_1, star, a, AddSubsemigroup.carrier, AddSubmonoid.toAddSubsemigroup, NonUnitalSubsemiring.toAddSubmonoid, NonUnitalSubalgebra.toNonUnitalSubsemiring, toNonUnitalSubalgebra_1, x, toNonUnitalSubalgebra, toNonUnitalSubalgebra, star_mem', star_mem', toNonUnitalSubalgebra, toNonUnitalSubalgebra_1, star_mem', star_mem'_1, toNonUnitalSubalgebra_eq, toNonUnitalSubalgebra, toNonUnitalSubalgebra_1, toNonUnitalSubalgebra, toNonUnitalSubalgebra_1] (during elaboration)

{Œ± : Type u} {s : Stream' Œ±} (x : ‚Ñï) (x_1 : ‚Ñï) (x : ‚Ñï) (f : Nat.below (motive := fun (x : ‚Ñï) ‚Ü¶ ‚àÄ {s : Stream' Œ±} (x_2 : ‚Ñï) , List.take x Stream'.take x_2 s = Stream'.take min x_2 x s) x) {s : Stream' Œ±} (x_2 : ‚Ñï) (m : ‚Ñï) (x : Nat.below (motive := fun (x : ‚Ñï) ‚Ü¶ ‚àÄ {s : Stream' Œ±} (x_3 : ‚Ñï) , List.take x Stream'.take x_3 s = Stream'.take min x_3 x s) m)  : [] = []
function expected at
  List.take x ?m.79956
term has type
  List ?m.30 ; identifiers [Œ±, u, s, Stream', Œ±, x, x_1, x, f, Nat.below, motive, x, s, Stream', Œ±, x_2, List.take, x, Stream'.take, x_2, s, Stream'.take, min, x_2, x, s, x, s, Stream', Œ±, x_2, m, x, Nat.below, motive, x, s, Stream', Œ±, x_3, List.take, x, Stream'.take, x_3, s, Stream'.take, min, x_3, x, s, m] (during elaboration)

{Œ± : Type u_1} {m : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} (r : ENNReal) (f : (a : Œ±) ‚Üí ENNReal) (s : MeasureTheory.SimpleFunc Œ± ENNReal) (hs : ‚Üë s ‚â§ fun (a : Œ±) ‚Ü¶ f a) (x : Œ±)  : ‚Üë s x ‚â§ fun (a : Œ±) ‚Ü¶ f a x
function expected at
  f a
term has type
  ENNReal ; identifiers [Œ±, u_1, m, MeasurableSpace, Œ±, Œº, MeasureTheory.Measure, Œ±, r, ENNReal, f, a, Œ±, ENNReal, s, MeasureTheory.SimpleFunc, Œ±, ENNReal, hs, s, a, Œ±, f, a, x, Œ±, s, x, a, Œ±, f, a, x] (during elaboration)

{V : Type u} [CategoryTheory.Category V] [CategoryTheory.Limits.HasImages V] {A : V} {B : V} {C : V} (f : A ‚ü∂ B) (g : B ‚ü∂ C) [CategoryTheory.Limits.HasZeroMorphisms V] [CategoryTheory.Limits.HasEqualizers V] [CategoryTheory.Limits.HasCokernels V] (h : CategoryTheory.Exact f g) (this : CategoryTheory.CategoryStruct.comp CategoryTheory.Subobject.arrow CategoryTheory.Limits.kernelSubobject g CategoryTheory.Limits.cokernel.œÄ f = 0)  : 0 = 0
function expected at
  CategoryTheory.CategoryStruct.comp ?m.81327 ?m.162248
term has type
  ?m.749 ‚ü∂ ?m.751 ; identifiers [V, u, CategoryTheory.Category, V, CategoryTheory.Limits.HasImages, V, A, V, B, V, C, V, f, A, B, g, B, C, CategoryTheory.Limits.HasZeroMorphisms, V, CategoryTheory.Limits.HasEqualizers, V, CategoryTheory.Limits.HasCokernels, V, h, CategoryTheory.Exact, f, g, this, CategoryTheory.CategoryStruct.comp, CategoryTheory.Subobject.arrow, CategoryTheory.Limits.kernelSubobject, g, CategoryTheory.Limits.cokernel.œÄ, f] (during elaboration)

{F : PFunctor} {motive : {n : ‚Ñï} ‚Üí (a : PFunctor.Approx.CofixA F n) ‚Üí (a_1 : PFunctor.Approx.CofixA F n + 1) ‚Üí (x : PFunctor.Approx.Agree a a_1) ‚Üí Prop} {n : ‚Ñï} {a : PFunctor.Approx.CofixA F n} {a_1 : PFunctor.Approx.CofixA F n + 1} (x : PFunctor.Approx.Agree a a_1) (ih : ‚àÄ {n : ‚Ñï} (a : PFunctor.Approx.CofixA F n) (a_2 : PFunctor.Approx.CofixA F n + 1) (x : PFunctor.Approx.Agree a a_2) (x_1 : PFunctor.Approx.Agree.below x) , motive a a_2 x) {n : ‚Ñï} {a : PFunctor.A F} (x : (a : PFunctor.B F a) ‚Üí PFunctor.Approx.CofixA F n) (x' : (a : PFunctor.B F a) ‚Üí PFunctor.Approx.CofixA F n + 1) (a_2 : ‚àÄ (i : PFunctor.B F a) , PFunctor.Approx.Agree x i x' i) (a_ih : ‚àÄ (i : PFunctor.B F a) , PFunctor.Approx.Agree.below (a_2 i =: PFunctor.Approx.Agree x i x' i))  : ‚àÄ (i : PFunctor.B F a) , PFunctor.Approx.Agree.below a_2 i
<input>:1:722: expected term

{F : PFunctor} {motive : {n : ‚Ñï} ‚Üí (a : PFunctor.Approx.CofixA F n) ‚Üí (a_1 : PFunctor.Approx.CofixA F n + 1) ‚Üí (x : PFunctor.Approx.Agree a a_1) ‚Üí Prop} {n : ‚Ñï} {a : PFunctor.Approx.CofixA F n} {a_1 : PFunctor.Approx.CofixA F n + 1} (x : PFunctor.Approx.Agree a a_1) (ih : ‚àÄ {n : ‚Ñï} (a : PFunctor.Approx.CofixA F n) (a_2 : PFunctor.Approx.CofixA F n + 1) (x : PFunctor.Approx.Agree a a_2) (x_1 : PFunctor.Approx.Agree.below x) , motive a a_2 x) {n : ‚Ñï} {a : PFunctor.A F} (x : (a : PFunctor.B F a) ‚Üí PFunctor.Approx.CofixA F n) (x' : (a : PFunctor.B F a) ‚Üí PFunctor.Approx.CofixA F n + 1) (a_2 : ‚àÄ (i : PFunctor.B F a) , PFunctor.Approx.Agree x i x' i) (a_ih : ‚àÄ (i : PFunctor.B F a) , PFunctor.Approx.Agree.below (a_2 i =: PFunctor.Approx.Agree x i x' i)) (i : PFunctor.B F a)  : PFunctor.Approx.Agree x i x' i
<input>:1:722: expected term

{F : PFunctor} {motive : {n : ‚Ñï} ‚Üí (a : PFunctor.Approx.CofixA F n) ‚Üí (a_1 : PFunctor.Approx.CofixA F n + 1) ‚Üí (x : PFunctor.Approx.Agree a a_1) ‚Üí Prop} {n : ‚Ñï} {a : PFunctor.Approx.CofixA F n} {a_1 : PFunctor.Approx.CofixA F n + 1} (x : PFunctor.Approx.Agree a a_1) (ih : ‚àÄ {n : ‚Ñï} (a : PFunctor.Approx.CofixA F n) (a_2 : PFunctor.Approx.CofixA F n + 1) (x : PFunctor.Approx.Agree a a_2) (x_1 : PFunctor.Approx.Agree.below x) , motive a a_2 x) {n : ‚Ñï} {a : PFunctor.A F} (x : (a : PFunctor.B F a) ‚Üí PFunctor.Approx.CofixA F n) (x' : (a : PFunctor.B F a) ‚Üí PFunctor.Approx.CofixA F n + 1) (a_2 : ‚àÄ (i : PFunctor.B F a) , PFunctor.Approx.Agree x i x' i) (a_ih : ‚àÄ (i : PFunctor.B F a) , PFunctor.Approx.Agree.below (a_2 i =: PFunctor.Approx.Agree x i x' i)) (i : PFunctor.B F a)  : PFunctor.Approx.Agree.below a_2 i
<input>:1:722: expected term

{G : Type u_1} [Group G] (œï : G ‚âÉ* G) (g : G) (hg : g ‚àà Subgroup.comap MulEquiv.toMonoidHom œï Subgroup.center G) (h : G)  : (h * g = g * h) = (h * g = g * h)
function expected at
  Subgroup.comap ?m.2929 ?m.161967
term has type
  Subgroup ?m.696 ; identifiers [G, u_1, Group, G, œï, G, G, g, G, hg, g, Subgroup.comap, MulEquiv.toMonoidHom, œï, Subgroup.center, G, h, G, h, g, g, h, h, g, g, h] (during elaboration)

 : (‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : NonUnitalNonAssocSemiring Œ±] [inst_1 : NonUnitalNonAssocSemiring Œ≤] (self : Œ± ‚Üí‚Çô+* Œ≤) , MulHom.toFun NonUnitalRingHom.toMulHom self 0 = 0)
function expected at
  MulHom.toFun ?m.550 self
term has type
  ?m.39 ; identifiers [Œ±, u_1, Œ≤, u_2, inst, NonUnitalNonAssocSemiring, Œ±, inst_1, NonUnitalNonAssocSemiring, Œ≤, self, Œ±, Œ≤, MulHom.toFun, NonUnitalRingHom.toMulHom, self] (during elaboration)

 : ‚àÄ (Œ± : Type u_1) (Œ≤ : Type u_2) [inst : NonUnitalNonAssocSemiring Œ±] [inst_1 : NonUnitalNonAssocSemiring Œ≤] (self : Œ± ‚Üí‚Çô+* Œ≤) , MulHom.toFun self . 1 0 = 0
invalid occurrence of `¬∑` notation, it must be surrounded by parentheses (e.g. `(¬∑ + 1)`) ; identifiers [Œ±, u_1, Œ≤, u_2, inst, NonUnitalNonAssocSemiring, Œ±, inst_1, NonUnitalNonAssocSemiring, Œ≤, self, Œ±, Œ≤, MulHom.toFun, self] (during elaboration)

(a : ‚Ñï) (b : ‚Ñï) (c : ‚Ñï) (this : a + b % c = a % c + b % c % c)  : (a + b % c + if (c ‚â§ a % c + b % c : Prop) then c else 0 = a % c + b % c) = (a + b % c + if (c ‚â§ a % c + b % c : Prop) then c else 0 = a % c + b % c)
application type mismatch
  if c ‚â§ a % c + b % c then c else 0 = a % c + b % c
argument
  0 = a % c + b % c
has type
  Prop : Type
but is expected to have type
  ‚Ñï : Type ; identifiers [a, b, c, this, a, b, c, a, c, b, c, c, a, b, c, c, a, c, b, c, c, a, c, b, c, a, b, c, c, a, c, b, c, c, a, c, b, c] (during elaboration)

{Œ± : Type u_1} [LinearOrder Œ±] [LocallyFiniteOrder Œ±] (a : Œ±) (b : Œ±) (c : Œ±) (h : b ‚â§ c) (h_1 : (le_total b c =: (b ‚â§ c : Prop) ‚à® (c ‚â§ b : Prop)) = (Or.inl h =: (b ‚â§ c : Prop) ‚à® (c ‚â§ b : Prop)))  : Or.inl h = le_total b c
<input>:1:112: expected term

{M : Type u_1} [Add M] {s : Set M} {p : (a : M) ‚Üí (a : M) ‚Üí Prop} {x : M} {y : M} (hx : x ‚àà AddSubsemigroup.closure s) (hy : y ‚àà AddSubsemigroup.closure s) (Hs : ‚àÄ (x : M) (a : x ‚àà s) (y : M) (a : y ‚àà s) , p x y) (Hmul_left : ‚àÄ (x : M) (y : M) (z : M) (a : p x z) (a : p y z) , p x + y z) (Hmul_right : ‚àÄ (x : M) (y : M) (z : M) (a : p z x) (a : p z y) , p z x + y) (x : M) (xs : x ‚àà s)  : ‚àÄ (y : M) (a : y ‚àà s) , p x y
function expected at
  y
term has type
  M ; identifiers [M, u_1, Add, M, s, Set, M, p, a, M, a, M, x, M, y, M, hx, x, AddSubsemigroup.closure, s, hy, y, AddSubsemigroup.closure, s, Hs, x, M, a, x, s, y, M, a, y, s, p, x, y, Hmul_left, x, M, y, M, z, M, a, p, x, z, a, p, y, z, p, x, y, z, Hmul_right, x, M, y, M, z, M, a, p, z, x, a, p, z, y, p, z, x, y, x, M, xs, x, s, y, M, a, y, s, p, x, y] (during elaboration)

{M : Type u_1} [Add M] {s : Set M} {p : (a : M) ‚Üí (a : M) ‚Üí Prop} {x : M} {y : M} (hx : x ‚àà AddSubsemigroup.closure s) (hy : y ‚àà AddSubsemigroup.closure s) (Hs : ‚àÄ (x : M) (a : x ‚àà s) (y : M) (a : y ‚àà s) , p x y) (Hmul_left : ‚àÄ (x : M) (y : M) (z : M) (a : p x z) (a : p y z) , p x + y z) (Hmul_right : ‚àÄ (x : M) (y : M) (z : M) (a : p z x) (a : p z y) , p z x + y) (x : M) (xs : x ‚àà s)  : ‚àÄ (z : M) (x_1 : M) (h‚ÇÅ : p x z) (h‚ÇÇ : p x x_1) , p x z + x_1
function expected at
  y
term has type
  M ; identifiers [M, u_1, Add, M, s, Set, M, p, a, M, a, M, x, M, y, M, hx, x, AddSubsemigroup.closure, s, hy, y, AddSubsemigroup.closure, s, Hs, x, M, a, x, s, y, M, a, y, s, p, x, y, Hmul_left, x, M, y, M, z, M, a, p, x, z, a, p, y, z, p, x, y, z, Hmul_right, x, M, y, M, z, M, a, p, z, x, a, p, z, y, p, z, x, y, x, M, xs, x, s, z, M, x_1, M, h‚ÇÅ, p, x, z, h‚ÇÇ, p, x, x_1, p, x, z, x_1] (during elaboration)

{M : Type u_1} [Add M] {s : Set M} {p : (a : M) ‚Üí (a : M) ‚Üí Prop} {x : M} {y : M} (hx : x ‚àà AddSubsemigroup.closure s) (hy : y ‚àà AddSubsemigroup.closure s) (Hs : ‚àÄ (x : M) (a : x ‚àà s) (y : M) (a : y ‚àà s) , p x y) (Hmul_left : ‚àÄ (x : M) (y : M) (z : M) (a : p x z) (a : p y z) , p x + y z) (Hmul_right : ‚àÄ (x : M) (y : M) (z : M) (a : p z x) (a : p z y) , p z x + y)  : ‚àÄ (x : M) (x_1 : M) (h‚ÇÅ : p x y) (h‚ÇÇ : p x_1 y) , p x + x_1 y
function expected at
  y
term has type
  M ; identifiers [M, u_1, Add, M, s, Set, M, p, a, M, a, M, x, M, y, M, hx, x, AddSubsemigroup.closure, s, hy, y, AddSubsemigroup.closure, s, Hs, x, M, a, x, s, y, M, a, y, s, p, x, y, Hmul_left, x, M, y, M, z, M, a, p, x, z, a, p, y, z, p, x, y, z, Hmul_right, x, M, y, M, z, M, a, p, z, x, a, p, z, y, p, z, x, y, x, M, x_1, M, h‚ÇÅ, p, x, y, h‚ÇÇ, p, x_1, y, p, x, x_1, y] (during elaboration)

{Œ± : Type u} [Group Œ±] [LT Œ±] [CovariantClass Œ± Œ± Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1 fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] {a : Œ±}  : ((a ‚Åª¬π < 1 : Prop) ‚Üî (1 < a : Prop)) = ((a ‚Åª¬π < 1 : Prop) ‚Üî (1 < a : Prop))
application type mismatch
  CovariantClass Œ± Œ± Function.swap
argument
  Function.swap
has type
  ((x : ?m.19) ‚Üí (y : ?m.20) ‚Üí ?m.21 x y) ‚Üí
    (y : ?m.20) ‚Üí (x : ?m.19) ‚Üí ?m.21 x y : Sort (imax (imax ?u.18 ?u.17 ?u.16) ?u.17 ?u.18 ?u.16)
but is expected to have type
  Œ± ‚Üí Œ± ‚Üí Œ± : Type u ; identifiers [Œ±, u, Group, Œ±, LT, Œ±, CovariantClass, Œ±, Œ±, Function.swap, x, Œ±, x_1, Œ±, x, x_1, x, Œ±, x_1, Œ±, x, x_1, a, Œ±, a, a, a, a] (during elaboration)

{Œ± : Type u} [Group Œ±] [LT Œ±] [CovariantClass Œ± Œ± Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1 fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] {a : Œ±}  : ((a ‚Åª¬π * a < 1 * a : Prop) ‚Üî (1 < a : Prop)) = ((a ‚Åª¬π * a < 1 * a : Prop) ‚Üî (1 < a : Prop))
application type mismatch
  CovariantClass Œ± Œ± Function.swap
argument
  Function.swap
has type
  ((x : ?m.19) ‚Üí (y : ?m.20) ‚Üí ?m.21 x y) ‚Üí
    (y : ?m.20) ‚Üí (x : ?m.19) ‚Üí ?m.21 x y : Sort (imax (imax ?u.18 ?u.17 ?u.16) ?u.17 ?u.18 ?u.16)
but is expected to have type
  Œ± ‚Üí Œ± ‚Üí Œ± : Type u ; identifiers [Œ±, u, Group, Œ±, LT, Œ±, CovariantClass, Œ±, Œ±, Function.swap, x, Œ±, x_1, Œ±, x, x_1, x, Œ±, x_1, Œ±, x, x_1, a, Œ±, a, a, a, a, a, a, a, a] (during elaboration)

{Œ± : Type u} [Group Œ±] [LT Œ±] [CovariantClass Œ± Œ± Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1 fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] {a : Œ±}  : ((1 < 1 * a : Prop) ‚Üî (1 < a : Prop)) = ((1 < 1 * a : Prop) ‚Üî (1 < a : Prop))
application type mismatch
  CovariantClass Œ± Œ± Function.swap
argument
  Function.swap
has type
  ((x : ?m.19) ‚Üí (y : ?m.20) ‚Üí ?m.21 x y) ‚Üí
    (y : ?m.20) ‚Üí (x : ?m.19) ‚Üí ?m.21 x y : Sort (imax (imax ?u.18 ?u.17 ?u.16) ?u.17 ?u.18 ?u.16)
but is expected to have type
  Œ± ‚Üí Œ± ‚Üí Œ± : Type u ; identifiers [Œ±, u, Group, Œ±, LT, Œ±, CovariantClass, Œ±, Œ±, Function.swap, x, Œ±, x_1, Œ±, x, x_1, x, Œ±, x_1, Œ±, x, x_1, a, Œ±, a, a, a, a] (during elaboration)

(a : Ordinal .{u_1}) {b : Ordinal .{u_1}} (hb : 0 < b) (Œ± : Type (u_1 + 1)) (self : LE Œ±) (a : Œ±) (a' : Œ±) (e'_3 : a = a') (a_1 : Œ±) (h : a' = a) (a' : Œ±)  : a = a
<input>:1:13: expected ')'

{Œ± : Type u} [Group Œ±] [LT Œ±] [CovariantClass Œ± Œ± Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1 fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] {a : Œ±}  : (1 < a) ‚Üî (1 < a)
application type mismatch
  CovariantClass Œ± Œ± Function.swap
argument
  Function.swap
has type
  ((x : ?m.19) ‚Üí (y : ?m.20) ‚Üí ?m.21 x y) ‚Üí
    (y : ?m.20) ‚Üí (x : ?m.19) ‚Üí ?m.21 x y : Sort (imax (imax ?u.18 ?u.17 ?u.16) ?u.17 ?u.18 ?u.16)
but is expected to have type
  Œ± ‚Üí Œ± ‚Üí Œ± : Type u ; identifiers [Œ±, u, Group, Œ±, LT, Œ±, CovariantClass, Œ±, Œ±, Function.swap, x, Œ±, x_1, Œ±, x, x_1, x, Œ±, x_1, Œ±, x, x_1, a, Œ±, a, a] (during elaboration)

(a : Ordinal .{u_1}) {b : Ordinal .{u_1}} (hb : 0 < b) (Œ± : Type (u_1 + 1)) (self : LE Œ±) (a : Œ±) (a' : Œ±) (e'_3 : a = a') (a_1 : Œ±) (h : a' = a)  : a = a'
<input>:1:13: expected ')'

(a : Ordinal .{u_1}) {b : Ordinal .{u_1}} (hb : 0 < b) (Œ± : Type (u_1 + 1)) (self : LE Œ±) (a : Œ±) (a' : Œ±) (e'_3 : a = a') (a_1 : Œ±)  : a' = a'
<input>:1:13: expected ')'

(a : Ordinal .{u_1}) {b : Ordinal .{u_1}} (hb : 0 < b)  : (a = a * 1) = (a = a * 1)
<input>:1:13: expected ')'

(a : Ordinal .{u_1}) {b : Ordinal .{u_1}} (hb : 0 < b)  : a = a
<input>:1:13: expected ')'

{Œ± : Type u_1} [LinearOrder Œ±] [LocallyFiniteOrder Œ±] (a : Œ±) (b : Œ±) (c : Œ±) (h : c ‚â§ b) (h_1 : (le_total b c =: (b ‚â§ c : Prop) ‚à® (c ‚â§ b : Prop)) = (Or.inr h =: (b ‚â§ c : Prop) ‚à® (c ‚â§ b : Prop)))  : Or.inr h = le_total b c
<input>:1:112: expected term

{Œ± : Sort u_1} {Œ≤ : Sort u_2} {r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop} {s : (a : Œ≤) ‚Üí (a : Œ≤) ‚Üí Prop} {Œ¥ : (a : Quot r) ‚Üí (a : Quot s) ‚Üí Prop} (q‚ÇÅ : Quot r) (q‚ÇÇ : Quot s) (h : ‚àÄ (a : Œ±) (b : Œ≤) , Œ¥ Quot.mk r a Quot.mk s b) (a‚ÇÅ : Œ±)  : ‚àÄ (a‚ÇÇ : Œ≤) , Œ¥ Quot.mk r a‚ÇÅ Quot.mk s a‚ÇÇ
application type mismatch
  Œ¥ Quot.mk
argument
  Quot.mk
has type
  (r : ?m.80 ‚Üí ?m.80 ‚Üí Prop) ‚Üí ?m.80 ‚Üí Quot r : Sort (imax (max 1 ?u.79) ?u.79)
but is expected to have type
  Quot r : Sort u_1 ; identifiers [Œ±, u_1, Œ≤, u_2, r, a, Œ±, a, Œ±, s, a, Œ≤, a, Œ≤, Œ¥, a, Quot, r, a, Quot, s, q‚ÇÅ, Quot, r, q‚ÇÇ, Quot, s, h, a, Œ±, b, Œ≤, Œ¥, Quot.mk, r, a, Quot.mk, s, b, a‚ÇÅ, Œ±, a‚ÇÇ, Œ≤, Œ¥, Quot.mk, r, a‚ÇÅ, Quot.mk, s, a‚ÇÇ] (during elaboration)

{Œ± : Type u_1} {Œ≤ : Type u_2} (p : Pmf Œ±) (f : (a : Œ±) ‚Üí Pmf Œ≤) (b : Œ≤) (this : ‚àÄ (a : Œ±) , if (‚Üë p a = 0 : Prop) then 0 else ‚Üë p a * ‚Üë f a b = ‚Üë p a * ‚Üë f a b) (a : Œ±)  : (‚Üë p a = 0) = (‚Üë p a = 0)
failed to synthesize instance
  OfNat (Sort ?u.26) 0 ; identifiers [Œ±, u_1, Œ≤, u_2, p, Pmf, Œ±, f, a, Œ±, Pmf, Œ≤, b, Œ≤, this, a, Œ±, p, a, p, a, f, a, b, p, a, f, a, b, a, Œ±, p, a, p, a] (during elaboration)

{Œ± : Type u_1} {Œ≤ : Type u_2} (p : Pmf Œ±) (f : (a : Œ±) ‚Üí Pmf Œ≤) (b : Œ≤) (this : ‚àÄ (a : Œ±) , if (‚Üë p a = 0 : Prop) then 0 else ‚Üë p a * ‚Üë f a b = ‚Üë p a * ‚Üë f a b) (a : Œ±)  : ‚àÄ (h : ‚Üë p a = 0) , 0 = 0
failed to synthesize instance
  OfNat (Sort ?u.26) 0 ; identifiers [Œ±, u_1, Œ≤, u_2, p, Pmf, Œ±, f, a, Œ±, Pmf, Œ≤, b, Œ≤, this, a, Œ±, p, a, p, a, f, a, b, p, a, f, a, b, a, Œ±, h, p, a] (during elaboration)

{Œ± : Type u_1} {Œ≤ : Type u_2} (p : Pmf Œ±) (f : (a : Œ±) ‚Üí Pmf Œ≤) (b : Œ≤) (this : ‚àÄ (a : Œ±) , if (‚Üë p a = 0 : Prop) then 0 else ‚Üë p a * ‚Üë f a b = ‚Üë p a * ‚Üë f a b) (a : Œ±)  : ‚àÄ (h : ¬¨ (‚Üë p a = 0)) , ‚Üë f a b = ‚Üë f a b
failed to synthesize instance
  OfNat (Sort ?u.26) 0 ; identifiers [Œ±, u_1, Œ≤, u_2, p, Pmf, Œ±, f, a, Œ±, Pmf, Œ≤, b, Œ≤, this, a, Œ±, p, a, p, a, f, a, b, p, a, f, a, b, a, Œ±, h, p, a, f, a, b, f, a, b] (during elaboration)

{Œ± : Type u_1} {Œ≤ : Type u_2} (p : Pmf Œ±) (f : (a : Œ±) ‚Üí Pmf Œ≤) (b : Œ≤) (this : ‚àÄ (a : Œ±) , if (‚Üë p a = 0 : Prop) then 0 else ‚Üë p a * ‚Üë f a b = ‚Üë p a * ‚Üë f a b) (a : Œ±)  : ‚àÄ (a_1 : ¬¨ (‚Üë p a = 0)) , ‚Üë p a * ‚Üë f a b = ‚Üë p a * ‚Üë f a b
failed to synthesize instance
  OfNat (Sort ?u.26) 0 ; identifiers [Œ±, u_1, Œ≤, u_2, p, Pmf, Œ±, f, a, Œ±, Pmf, Œ≤, b, Œ≤, this, a, Œ±, p, a, p, a, f, a, b, p, a, f, a, b, a, Œ±, a_1, p, a, p, a, f, a, b, p, a, f, a, b] (during elaboration)

{Œ± : Type u_1} {Œ≤ : Type u_2} (p : Pmf Œ±) (f : (a : Œ±) ‚Üí Pmf Œ≤) (b : Œ≤) (this : ‚àÄ (a : Œ±) , if (‚Üë p a = 0 : Prop) then 0 else ‚Üë p a * ‚Üë f a b = ‚Üë p a * ‚Üë f a b) (a : Œ±)  : ‚àÄ (a : Œ±) , if (‚Üë p a = 0) then 0 else ‚Üë p a * ‚Üë f a b = ‚Üë p a * ‚Üë f a b
failed to synthesize instance
  OfNat (Sort ?u.26) 0 ; identifiers [Œ±, u_1, Œ≤, u_2, p, Pmf, Œ±, f, a, Œ±, Pmf, Œ≤, b, Œ≤, this, a, Œ±, p, a, p, a, f, a, b, p, a, f, a, b, a, Œ±, a, Œ±, p, a, p, a, f, a, b, p, a, f, a, b] (during elaboration)

{Œ± : Type u} [TopologicalSpace Œ±] {Œπ : (a : Œ±) ‚Üí Sort u_1} {p : (a : Œ±) ‚Üí (a : Œπ a) ‚Üí Prop} {s : (a : Œ±) ‚Üí (a : Œπ a) ‚Üí Set Œ±} (h‚ÇÅ : ‚àÄ (a : Œ±) , Filter.HasBasis nhds a p a s a) (h‚ÇÇ : ‚àÄ (a : Œ±) (i : Œπ a) (a_1 : p a i) , IsClosed s a i) (a : Œ±)  : Filter.HasBasis nhds a p a s a
application type mismatch
  Filter.HasBasis ?m.79915 a
argument
  a
has type
  Œ± : Type u
but is expected to have type
  ?m.43 ‚Üí Prop : Sort (max 1 ?u.40) ; identifiers [Œ±, u, TopologicalSpace, Œ±, Œπ, a, Œ±, u_1, p, a, Œ±, a, Œπ, a, s, a, Œ±, a, Œπ, a, Set, Œ±, h‚ÇÅ, a, Œ±, Filter.HasBasis, nhds, a, p, a, s, a, h‚ÇÇ, a, Œ±, i, Œπ, a, a_1, p, a, i, IsClosed, s, a, i, a, Œ±, Filter.HasBasis, nhds, a, p, a, s, a] (during elaboration)

{Œ± : Type u} [TopologicalSpace Œ±] {Œπ : (a : Œ±) ‚Üí Sort u_1} {p : (a : Œ±) ‚Üí (a : Œπ a) ‚Üí Prop} {s : (a : Œ±) ‚Üí (a : Œπ a) ‚Üí Set Œ±} (h‚ÇÅ : ‚àÄ (a : Œ±) , Filter.HasBasis nhds a p a s a) (h‚ÇÇ : ‚àÄ (a : Œ±) (i : Œπ a) (a_1 : p a i) , IsClosed s a i) (a : Œ±)  : ‚àÄ (i : Œπ a) (a_1 : p a i) , IsClosed s a i
application type mismatch
  Filter.HasBasis ?m.79915 a
argument
  a
has type
  Œ± : Type u
but is expected to have type
  ?m.43 ‚Üí Prop : Sort (max 1 ?u.40) ; identifiers [Œ±, u, TopologicalSpace, Œ±, Œπ, a, Œ±, u_1, p, a, Œ±, a, Œπ, a, s, a, Œ±, a, Œπ, a, Set, Œ±, h‚ÇÅ, a, Œ±, Filter.HasBasis, nhds, a, p, a, s, a, h‚ÇÇ, a, Œ±, i, Œπ, a, a_1, p, a, i, IsClosed, s, a, i, a, Œ±, i, Œπ, a, a_1, p, a, i, IsClosed, s, a, i] (during elaboration)

{R : Type u_2} [CommSemiring R] (M : Submonoid R) (S : Type u_1) [CommSemiring S] [Algebra R S] [IsLocalization M S] {I : {p : Ideal S // Ideal.IsPrime p}} {I' : {p : Ideal S // Ideal.IsPrime p}}  : ‚àÄ (h : I ‚â§ I') (x : R) (hx : x ‚àà ‚Üë ‚Üë {toFun := ((fun (p : {p : Ideal S // Ideal.IsPrime p}) ‚Ü¶ {val := ((Ideal.comap algebraMap R S ‚Üë p)) , property := ((Iff.mp IsLocalization.isPrime_iff_isPrime_disjoint M S ‚Üë p Subtype.property p))})) , invFun := ((fun (p : {p : Ideal R // (Ideal.IsPrime p) ‚àß (Disjoint ‚Üë M ‚Üë p)}) ‚Ü¶ {val := ((Ideal.map algebraMap R S ‚Üë p)) , property := ((IsLocalization.isPrime_of_isPrime_disjoint M S ‚Üë p And.left Subtype.property p And.right Subtype.property p))})) , left_inv := ((fun (J : {p : Ideal S // Ideal.IsPrime p}) ‚Ü¶ Subtype.eq IsLocalization.map_comap M S ‚Üë J)) , right_inv := ((fun (I : {p : Ideal R // (Ideal.IsPrime p) ‚àß (Disjoint ‚Üë M ‚Üë p)}) ‚Ü¶ Subtype.eq IsLocalization.comap_map_of_isPrime_disjoint M S ‚Üë I And.left Subtype.property I And.right Subtype.property I))} I) , ‚Üë algebraMap R S x ‚àà ‚Üë I'
type mismatch
  I'
has type
  { p // Ideal.IsPrime p } : Type u_1
but is expected to have type
  ?m.1423 M S h x hx : Type ?u.1108 ; identifiers [R, u_2, CommSemiring, R, M, Submonoid, R, S, u_1, CommSemiring, S, Algebra, R, S, IsLocalization, M, S, I, p, Ideal, S, Ideal.IsPrime, p, I', p, Ideal, S, Ideal.IsPrime, p, h, I, I', x, R, hx, x, toFun, p, p, Ideal, S, Ideal.IsPrime, p, val, Ideal.comap, algebraMap, R, S, p, property, Iff.mp, IsLocalization.isPrime_iff_isPrime_disjoint, M, S, p, Subtype.property, p, invFun, p, p, Ideal, R, Ideal.IsPrime, p, Disjoint, M, p, val, Ideal.map, algebraMap, R, S, p, property, IsLocalization.isPrime_of_isPrime_disjoint, M, S, p, And.left, Subtype.property, p, And.right, Subtype.property, p, left_inv, J, p, Ideal, S, Ideal.IsPrime, p, Subtype.eq, IsLocalization.map_comap, M, S, J, right_inv, I, p, Ideal, R, Ideal.IsPrime, p, Disjoint, M, p, Subtype.eq, IsLocalization.comap_map_of_isPrime_disjoint, M, S, I, And.left, Subtype.property, I, And.right, Subtype.property, I, I, algebraMap, R, S, x, I'] (during elaboration)

{Œ± : Type u} {n : ‚Ñï} {x : Œ±} [LinearOrderedRing Œ±] (hn : n ‚â† 0) (h : Finset.sum Finset.range n fun (i : ‚Ñï) ‚Ü¶ x ^ i = 0) (h : ‚àÄ (_ : x = - 1) , ¬¨ (Even n : Prop)) (hx : (x = - 1 : Prop) ‚à® (x ‚â† - 1 : Prop)) (hx_1 : x = - 1) (h_1 : hx = (Or.inl hx_1 =: (x = - 1 : Prop) ‚à® (x ‚â† - 1 : Prop)))  : Or.inl hx_1 = hx
<input>:1:248: expected term

{Œ± : Type u} [LinearOrder Œ±] (a : Œ±) (b : Œ±) (lt : a < b)  : (if (a ‚â§ b : Prop) then a else b = if (b ‚â§ a : Prop) then b else a) = (if (a ‚â§ b : Prop) then a else b = if (b ‚â§ a : Prop) then b else a)
application type mismatch
  if a ‚â§ b then a else b = if b ‚â§ a then b else a
argument
  b = if b ‚â§ a then b else a
has type
  Prop : Type
but is expected to have type
  Œ± : Type u ; identifiers [Œ±, u, LinearOrder, Œ±, a, Œ±, b, Œ±, lt, a, b, a, b, a, b, b, a, b, a, a, b, a, b, b, a, b, a] (during elaboration)

 : (‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Inf Œ±] [inst_1 : Inf Œ≤] (self : InfHom Œ± Œ≤) (a : Œ±) (b : Œ±) , InfHom.toFun self a ‚äì b = InfHom.toFun self a ‚äì InfHom.toFun self b)
application type mismatch
  InfHom.toFun self a ‚äì b
argument
  b
has type
  Œ± : Type u_1
but is expected to have type
  Œ≤ : Type u_2 ; identifiers [Œ±, u_1, Œ≤, u_2, inst, Inf, Œ±, inst_1, Inf, Œ≤, self, InfHom, Œ±, Œ≤, a, Œ±, b, Œ±, InfHom.toFun, self, a, b, InfHom.toFun, self, a, InfHom.toFun, self, b] (during elaboration)

 : ‚àÄ (Œ± : Type u_1) (Œ≤ : Type u_2) [inst : Inf Œ±] [inst_1 : Inf Œ≤] (self : InfHom Œ± Œ≤) (a : Œ±) (b : Œ±) , self . 1 a ‚äì b = self . 1 a ‚äì self . 1 b
invalid occurrence of `¬∑` notation, it must be surrounded by parentheses (e.g. `(¬∑ + 1)`) ; identifiers [Œ±, u_1, Œ≤, u_2, inst, Inf, Œ±, inst_1, Inf, Œ≤, self, InfHom, Œ±, Œ≤, a, Œ±, b, Œ±, self, a, b, self, a, self, b] (during elaboration)

{Œ± : Type u} [LinearOrder Œ±] (a : Œ±) (b : Œ±) (h : (a = b : Prop) ‚à® (b < a : Prop)) (eq : a = b)  : (if (a ‚â§ b : Prop) then a else b = if (b ‚â§ a : Prop) then b else a) = (if (a ‚â§ b : Prop) then a else b = if (b ‚â§ a : Prop) then b else a)
application type mismatch
  if a ‚â§ b then a else b = if b ‚â§ a then b else a
argument
  b = if b ‚â§ a then b else a
has type
  Prop : Type
but is expected to have type
  Œ± : Type u ; identifiers [Œ±, u, LinearOrder, Œ±, a, Œ±, b, Œ±, h, a, b, b, a, eq, a, b, a, b, a, b, b, a, b, a, a, b, a, b, b, a, b, a] (during elaboration)

{Œ± : Type u_1} {r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop} [IsWellOrder Œ± r] {c : Cardinal .{u_1}} (H : ‚àÄ (S : Set Œ±) (a : Set.Unbounded r S) , c ‚â§ Cardinal.mk ‚Üë S) (d : Cardinal .{u_1}) (a : d ‚àà {c : Cardinal .{u_1} | ‚àÉ (S : Set Œ±) , (Set.Unbounded r S : Prop) ‚àß (Cardinal.mk ‚Üë S = c : Prop)}) (S : Set Œ±) (h : (Set.Unbounded r S : Prop) ‚àß (Cardinal.mk ‚Üë S = d : Prop)) (h : Set.Unbounded r S) (right : Cardinal.mk ‚Üë S = d)  : c ‚â§ Cardinal.mk ‚Üë S
<input>:1:78: expected '//', '|' or '}'

{V : Type u_1} {P : Type u_2} [NormedAddCommGroup V] [InnerProductSpace ‚Ñù V] [MetricSpace P] [NormedAddTorsor V P] [Fact (FiniteDimensional.finrank ‚Ñù V = 2 : Prop)] [Module.Oriented ‚Ñù V Fin 2] {p‚ÇÅ : P} {p‚ÇÇ : P} {p‚ÇÉ : P} (h : EuclideanGeometry.oangle p‚ÇÅ p‚ÇÇ p‚ÇÉ = ‚Üë Real.pi / 2)  : 1 = 1
application type mismatch
  Module.Oriented ‚Ñù V Fin
argument
  Fin
has type
  ‚Ñï ‚Üí Type : Type 1
but is expected to have type
  Type ?u.490 : Type (?u.490 + 1) ; identifiers [V, u_1, P, u_2, NormedAddCommGroup, V, InnerProductSpace, V, MetricSpace, P, NormedAddTorsor, V, P, Fact, FiniteDimensional.finrank, V, Module.Oriented, V, Fin, p‚ÇÅ, P, p‚ÇÇ, P, p‚ÇÉ, P, h, EuclideanGeometry.oangle, p‚ÇÅ, p‚ÇÇ, p‚ÇÉ, Real.pi] (during elaboration)

{Œ± : Type u} [LinearOrder Œ±] (a : Œ±) (b : Œ±) (h : (a = b : Prop) ‚à® (b < a : Prop)) (gt : b < a)  : (if (a ‚â§ b : Prop) then a else b = if (b ‚â§ a : Prop) then b else a) = (if (a ‚â§ b : Prop) then a else b = if (b ‚â§ a : Prop) then b else a)
application type mismatch
  if a ‚â§ b then a else b = if b ‚â§ a then b else a
argument
  b = if b ‚â§ a then b else a
has type
  Prop : Type
but is expected to have type
  Œ± : Type u ; identifiers [Œ±, u, LinearOrder, Œ±, a, Œ±, b, Œ±, h, a, b, b, a, gt, b, a, a, b, a, b, b, a, b, a, a, b, a, b, b, a, b, a] (during elaboration)

 : (‚àÄ {V : Type u_2} {W : Type u_3} {V‚ÇÅ : Type u_1} [inst : SeminormedAddCommGroup V] [inst_1 : SeminormedAddCommGroup W] [inst_2 : SeminormedAddCommGroup V‚ÇÅ] {f : NormedAddGroupHom V W} {g : NormedAddGroupHom V W} (œÜ : NormedAddGroupHom V‚ÇÅ V) (h : NormedAddGroupHom.comp f œÜ = NormedAddGroupHom.comp g œÜ) (C : ‚Ñù) (hœÜ : ‚Äñ œÜ ‚Äñ ‚â§ C) , ‚Äñ NormedAddGroupHom.Equalizer.lift œÜ h ‚Äñ ‚â§ C)
<input>:1:326: expected term

 : ‚àÄ {V : Type u_2} {W : Type u_3} {V‚ÇÅ : Type u_1} [inst : SeminormedAddCommGroup V] [inst_1 : SeminormedAddCommGroup W] [inst_2 : SeminormedAddCommGroup V‚ÇÅ] {f : NormedAddGroupHom V W} {g : NormedAddGroupHom V W} (œÜ : NormedAddGroupHom V‚ÇÅ V) (h : NormedAddGroupHom.comp f œÜ = NormedAddGroupHom.comp g œÜ) (C : ‚Ñù) (hœÜ : ‚Äñ œÜ ‚Äñ ‚â§ C) , ‚Äñ œÜ ‚Äñ ‚â§ C
<input>:1:325: expected term

{V‚ÇÅ : Type u_3} {V‚ÇÇ : Type u_2} {V‚ÇÉ : Type u_1} [SeminormedAddCommGroup V‚ÇÅ] [SeminormedAddCommGroup V‚ÇÇ] [SeminormedAddCommGroup V‚ÇÉ] (g : NormedAddGroupHom V‚ÇÇ V‚ÇÉ) (f : NormedAddGroupHom V‚ÇÅ V‚ÇÇ) (v : V‚ÇÅ)  : (‚Äñ g ‚Äñ * ‚Äñ f ‚Äñ * ‚Äñ v ‚Äñ = ‚Äñ g ‚Äñ * ‚Äñ f ‚Äñ * ‚Äñ v ‚Äñ) = (‚Äñ g ‚Äñ * ‚Äñ f ‚Äñ * ‚Äñ v ‚Äñ = ‚Äñ g ‚Äñ * ‚Äñ f ‚Äñ * ‚Äñ v ‚Äñ)
<input>:1:211: expected term

{V‚ÇÅ : Type u_3} {V‚ÇÇ : Type u_2} {V‚ÇÉ : Type u_1} [SeminormedAddCommGroup V‚ÇÅ] [SeminormedAddCommGroup V‚ÇÇ] [SeminormedAddCommGroup V‚ÇÉ] (g : NormedAddGroupHom V‚ÇÇ V‚ÇÉ) (f : NormedAddGroupHom V‚ÇÅ V‚ÇÇ) (v : V‚ÇÅ)  : ‚Äñ g ‚Äñ * ‚Äñ f ‚Äñ * ‚Äñ v ‚Äñ = ‚Äñ g ‚Äñ * ‚Äñ f ‚Äñ * ‚Äñ v ‚Äñ
<input>:1:210: expected term

{Œ± : Type u} {n : ‚Ñï} {x : Œ±} [LinearOrderedRing Œ±] (hn : n ‚â† 0) (h : Finset.sum Finset.range n fun (i : ‚Ñï) ‚Ü¶ x ^ i = 0) (h : ‚àÄ (_ : x = - 1) , ¬¨ (Even n : Prop)) (hx : (x = - 1 : Prop) ‚à® (x ‚â† - 1 : Prop)) (hx_1 : x = - 1) (h_1 : hx = (Or.inl hx_1 =: (x = - 1 : Prop) ‚à® (x ‚â† - 1 : Prop)))  : ¬¨ (Even n)
<input>:1:248: expected term

{Œ± : Type u} {n : ‚Ñï} {x : Œ±} [LinearOrderedRing Œ±] (hn : n ‚â† 0) (h : Finset.sum Finset.range n fun (i : ‚Ñï) ‚Ü¶ x ^ i = 0) (h : ‚àÄ (_ : x = - 1) , ¬¨ (Even n : Prop)) (hx : (x = - 1 : Prop) ‚à® (x ‚â† - 1 : Prop)) (hx_1 : x = - 1) (h_1 : hx = (Or.inl hx_1 =: (x = - 1 : Prop) ‚à® (x ‚â† - 1 : Prop)))  : ‚àÄ (a : False) , 0 = 0
<input>:1:248: expected term

{Œ± : Type u} {n : ‚Ñï} {x : Œ±} [LinearOrderedRing Œ±] (hn : n ‚â† 0) (h : Finset.sum Finset.range n fun (i : ‚Ñï) ‚Ü¶ x ^ i = 0) (h : ‚àÄ (_ : x = - 1) , ¬¨ (Even n : Prop)) (hx : (x = - 1 : Prop) ‚à® (x ‚â† - 1 : Prop)) (hx_1 : x = - 1) (h_1 : hx = (Or.inl hx_1 =: (x = - 1 : Prop) ‚à® (x ‚â† - 1 : Prop)))  : ‚àÄ (a : ¬¨ False) , 1 = 1
<input>:1:248: expected term

{Œ± : Type u} {p : (a : Œ±) ‚Üí Prop} {f : Filter Œ±} (H : ‚àÄ {q : (a : Œ±) ‚Üí Prop} (a : ‚àÄ·∂† (x : Œ±) in f , q x) , ‚àÉ (x : Œ±) , (p x : Prop) ‚àß (q x : Prop)) (hp : ‚àÄ·∂† (x : Œ±) in f , ¬¨ (fun (x : Œ±) ‚Ü¶ p x x : Prop))  : ‚àÉ (x : Œ±) , (p x) ‚àß (¬¨ (fun (x : Œ±) ‚Ü¶ p x x : Prop))
function expected at
  p x
term has type
  Prop ; identifiers [Œ±, u, p, a, Œ±, f, Filter, Œ±, H, q, a, Œ±, a, x, Œ±, f, q, x, x, Œ±, p, x, q, x, hp, x, Œ±, f, x, Œ±, p, x, x, x, Œ±, p, x, x, Œ±, p, x, x] (during elaboration)

{Œ± : Type u} {n : ‚Ñï} {x : Œ±} [LinearOrderedRing Œ±] (hn : n ‚â† 0) (h : Finset.sum Finset.range n fun (i : ‚Ñï) ‚Ü¶ x ^ i = 0) (h : ‚àÄ (_ : x = - 1) , ¬¨ (Even n : Prop)) (hx : (x = - 1 : Prop) ‚à® (x ‚â† - 1 : Prop)) (hx_1 : x ‚â† - 1) (h : hx = (Or.inr hx_1 =: (x = - 1 : Prop) ‚à® (x ‚â† - 1 : Prop)))  : Or.inr hx_1 = hx
<input>:1:246: expected term

{Œ± : Type u} {n : ‚Ñï} {x : Œ±} [LinearOrderedRing Œ±] (hn : n ‚â† 0) (h : Finset.sum Finset.range n fun (i : ‚Ñï) ‚Ü¶ x ^ i = 0) (h : ‚àÄ (_ : x = - 1) , ¬¨ (Even n : Prop)) (hx : (x = - 1 : Prop) ‚à® (x ‚â† - 1 : Prop))  : hx = hx
function expected at
  Finset.sum ?m.378 ?m.79528
term has type
  ?m.34 ; identifiers [Œ±, u, n, x, Œ±, LinearOrderedRing, Œ±, hn, n, h, Finset.sum, Finset.range, n, i, x, i, h, x, Even, n, hx, x, x, hx, hx] (during elaboration)

{Œ± : Type u_1} [LinearOrder Œ±] [LocallyFiniteOrder Œ±] (a : Œ±) (b : Œ±) (c : Œ±) (h : c ‚â§ b) (h_1 : (le_total b c =: (b ‚â§ c : Prop) ‚à® (c ‚â§ b : Prop)) = (Or.inr h =: (b ‚â§ c : Prop) ‚à® (c ‚â§ b : Prop))) (x : Œ±)  : ((((a ‚â§ x : Prop) ‚àß (x < b : Prop) : Prop) ‚àß (¬¨ ((c ‚â§ x : Prop) ‚àß (x < b : Prop) : Prop) : Prop) : Prop) ‚Üî ((a ‚â§ x : Prop) ‚àß (x < c : Prop) : Prop)) = ((((a ‚â§ x : Prop) ‚àß (x < b : Prop) : Prop) ‚àß (¬¨ ((c ‚â§ x : Prop) ‚àß (x < b : Prop) : Prop) : Prop) : Prop) ‚Üî ((a ‚â§ x : Prop) ‚àß (x < c : Prop) : Prop))
<input>:1:112: expected term

{m : ‚Ñï} {n : ‚Ñï} (hn : 0 < n) (h : n < m) (this : ‚àÄ {n : ‚Ñï} (a : 0 < n) , Nat.factorial n < Nat.factorial Nat.succ n)  : ‚àÄ (hn : 0 < n) , Nat.factorial n < Nat.factorial Nat.succ n
application type mismatch
  Nat.factorial Nat.succ
argument
  Nat.succ
has type
  ‚Ñï ‚Üí ‚Ñï : Type
but is expected to have type
  ‚Ñï : Type ; identifiers [m, n, hn, n, h, n, m, this, n, a, n, Nat.factorial, n, Nat.factorial, Nat.succ, n, hn, n, Nat.factorial, n, Nat.factorial, Nat.succ, n] (during elaboration)

{R : Type u_1} [inst : CommRing R] [IsDomain R] (K : Type u_2) [Field K] [inst_3 : Algebra R K] [IsFractionRing R K] (a : IsIntegralClosure R R K) (algebraMap_injective' : Function.Injective ‚Üë algebraMap R K) (cl : ‚àÄ {x : K} , (IsIntegral R x : Prop) ‚Üî (‚àÉ (y : R) , ‚Üë algebraMap R K y = x : Prop)) {x : K} (hx : IsIntegral R x)  : (IsIntegral R x) ‚Üî (‚àÉ (y : R) , ‚Üë algebraMap R K y = x)
function expected at
  Function.Injective ?m.81526
term has type
  Prop ; identifiers [R, u_1, inst, CommRing, R, IsDomain, R, K, u_2, Field, K, inst_3, Algebra, R, K, IsFractionRing, R, K, a, IsIntegralClosure, R, R, K, algebraMap_injective', Function.Injective, algebraMap, R, K, cl, x, K, IsIntegral, R, x, y, R, algebraMap, R, K, y, x, x, K, hx, IsIntegral, R, x, IsIntegral, R, x, y, R, algebraMap, R, K, y, x] (during elaboration)

{m : ‚Ñï} {n : ‚Ñï} (hn : 0 < n) (h : n < m) (this : ‚àÄ {n : ‚Ñï} (a : 0 < n) , Nat.factorial n < Nat.factorial Nat.succ n) {k : ‚Ñï} (hnk : Nat.le Nat.succ n k) (ih : ‚àÄ (hn : 0 < n) , (Nat.factorial n < Nat.factorial k : Prop)) (hn : 0 < n)  : (Nat.factorial n < Nat.factorial k)
application type mismatch
  Nat.factorial Nat.succ
argument
  Nat.succ
has type
  ‚Ñï ‚Üí ‚Ñï : Type
but is expected to have type
  ‚Ñï : Type ; identifiers [m, n, hn, n, h, n, m, this, n, a, n, Nat.factorial, n, Nat.factorial, Nat.succ, n, k, hnk, Nat.le, Nat.succ, n, k, ih, hn, n, Nat.factorial, n, Nat.factorial, k, hn, n, Nat.factorial, n, Nat.factorial, k] (during elaboration)

(A : Type u_1) [AddCommGroup A] (H : ‚àÄ {n : ‚Ñ§} (_hn : n ‚â† 0) , n ‚Ä¢ ‚ä§ = ‚ä§) {n : ‚Ñ§} (a : A) (hn : n ‚â† 0)  : (n = 0) = (n = 0)
typeclass instance problem is stuck, it is often due to metavariables
  Top (?m.2940 A _hn) ; identifiers [A, u_1, AddCommGroup, A, H, n, _hn, n, n, n, a, A, hn, n, n, n] (during elaboration)

(A : Type u_1) [AddCommGroup A] (H : ‚àÄ {n : ‚Ñ§} (_hn : n ‚â† 0) , n ‚Ä¢ ‚ä§ = ‚ä§) {n : ‚Ñ§} (a : A) (hn : n ‚â† 0)  : ‚àÄ (h : n = 0) , 0 = 0
typeclass instance problem is stuck, it is often due to metavariables
  Top (?m.2990 A _hn) ; identifiers [A, u_1, AddCommGroup, A, H, n, _hn, n, n, n, a, A, hn, n, h, n] (during elaboration)

{C : Type u} [CategoryTheory.Groupoid C] (arrows : (c : C) ‚Üí (d : C) ‚Üí Set c ‚ü∂ d) (inv : ‚àÄ {c : C} {d : C} {p : c ‚ü∂ d} (a : p ‚àà arrows c d) , CategoryTheory.Groupoid.inv p ‚àà arrows d c) (mul : ‚àÄ {c : C} {d : C} {e : C} {p : c ‚ü∂ d} (a : p ‚àà arrows c d) {q : d ‚ü∂ e} (a : q ‚àà arrows d e) , CategoryTheory.CategoryStruct.comp p q ‚àà arrows c e) (arrows_1 : (c : C) ‚Üí (d : C) ‚Üí Set c ‚ü∂ d) (inv_1 : ‚àÄ {c : C} {d : C} {p : c ‚ü∂ d} (a : p ‚àà arrows_1 c d) , CategoryTheory.Groupoid.inv p ‚àà arrows_1 d c) (mul_1 : ‚àÄ {c : C} {d : C} {e : C} {p : c ‚ü∂ d} (a : p ‚àà arrows_1 c d) {q : d ‚ü∂ e} (a : q ‚àà arrows_1 d e) , CategoryTheory.CategoryStruct.comp p q ‚àà arrows_1 c e) (a : {arrows := ((arrows)) , inv := ((inv)) , mul := ((mul))} = {arrows := ((arrows_1)) , inv := ((inv_1)) , mul := ((mul_1))})  : ‚àÄ (arrows_eq : arrows = arrows_1) , arrows = arrows_1
application type mismatch
  Set c
argument
  c
has type
  C : Type u
but is expected to have type
  Type ?u.52 : Type (?u.52 + 1) ; identifiers [C, u, CategoryTheory.Groupoid, C, arrows, c, C, d, C, Set, c, d, inv, c, C, d, C, p, c, d, a, p, arrows, c, d, CategoryTheory.Groupoid.inv, p, arrows, d, c, mul, c, C, d, C, e, C, p, c, d, a, p, arrows, c, d, q, d, e, a, q, arrows, d, e, CategoryTheory.CategoryStruct.comp, p, q, arrows, c, e, arrows_1, c, C, d, C, Set, c, d, inv_1, c, C, d, C, p, c, d, a, p, arrows_1, c, d, CategoryTheory.Groupoid.inv, p, arrows_1, d, c, mul_1, c, C, d, C, e, C, p, c, d, a, p, arrows_1, c, d, q, d, e, a, q, arrows_1, d, e, CategoryTheory.CategoryStruct.comp, p, q, arrows_1, c, e, a, arrows, arrows, inv, inv, mul, mul, arrows, arrows_1, inv, inv_1, mul, mul_1, arrows_eq, arrows, arrows_1, arrows, arrows_1] (during elaboration)

{Œ± : Type u_1} [LinearOrder Œ±] [LocallyFiniteOrder Œ±] (a : Œ±) (b : Œ±) (c : Œ±) (h : c ‚â§ b) (h_1 : (le_total b c =: (b ‚â§ c : Prop) ‚à® (c ‚â§ b : Prop)) = (Or.inr h =: (b ‚â§ c : Prop) ‚à® (c ‚â§ b : Prop))) (x : Œ±)  : (((a ‚â§ x : Prop) ‚àß ((x < b : Prop) ‚àß (¬¨ ((c ‚â§ x : Prop) ‚àß (x < b : Prop) : Prop) : Prop) : Prop) : Prop) ‚Üî ((a ‚â§ x : Prop) ‚àß (x < c : Prop) : Prop)) = (((a ‚â§ x : Prop) ‚àß ((x < b : Prop) ‚àß (¬¨ ((c ‚â§ x : Prop) ‚àß (x < b : Prop) : Prop) : Prop) : Prop) : Prop) ‚Üî ((a ‚â§ x : Prop) ‚àß (x < c : Prop) : Prop))
<input>:1:112: expected term

(A : Type u_1) [AddCommGroup A] (H : ‚àÄ {n : ‚Ñ§} (_hn : n ‚â† 0) , n ‚Ä¢ ‚ä§ = ‚ä§) {n : ‚Ñ§} (a : A) (hn : n ‚â† 0) (h : ¬¨ (n = 0 : Prop))  : (n = 0) = (n = 0)
typeclass instance problem is stuck, it is often due to metavariables
  Top (?m.2962 A _hn) ; identifiers [A, u_1, AddCommGroup, A, H, n, _hn, n, n, n, a, A, hn, n, h, n, n, n] (during elaboration)

(A : Type u_1) [AddCommGroup A] (H : ‚àÄ {n : ‚Ñ§} (_hn : n ‚â† 0) , n ‚Ä¢ ‚ä§ = ‚ä§) {n : ‚Ñ§} (a : A) (hn : n ‚â† 0) (h : ¬¨ (n = 0 : Prop))  : (a ‚àà n ‚Ä¢ ‚ä§) = (a ‚àà n ‚Ä¢ ‚ä§)
typeclass instance problem is stuck, it is often due to metavariables
  Membership A (?m.8924 A H a hn h) ; identifiers [A, u_1, AddCommGroup, A, H, n, _hn, n, n, n, a, A, hn, n, h, n, a, n, a, n] (during elaboration)

{C : Type u} [CategoryTheory.Groupoid C] (arrows : (c : C) ‚Üí (d : C) ‚Üí Set c ‚ü∂ d) (inv : ‚àÄ {c : C} {d : C} {p : c ‚ü∂ d} (a : p ‚àà arrows c d) , CategoryTheory.Groupoid.inv p ‚àà arrows d c) (mul : ‚àÄ {c : C} {d : C} {e : C} {p : c ‚ü∂ d} (a : p ‚àà arrows c d) {q : d ‚ü∂ e} (a : q ‚àà arrows d e) , CategoryTheory.CategoryStruct.comp p q ‚àà arrows c e) (arrows_1 : (c : C) ‚Üí (d : C) ‚Üí Set c ‚ü∂ d) (inv_1 : ‚àÄ {c : C} {d : C} {p : c ‚ü∂ d} (a : p ‚àà arrows_1 c d) , CategoryTheory.Groupoid.inv p ‚àà arrows_1 d c) (mul_1 : ‚àÄ {c : C} {d : C} {e : C} {p : c ‚ü∂ d} (a : p ‚àà arrows_1 c d) {q : d ‚ü∂ e} (a : q ‚àà arrows_1 d e) , CategoryTheory.CategoryStruct.comp p q ‚àà arrows_1 c e) (a : arrows = arrows_1) (h : arrows_1 = arrows) (arrows_2 : (c : C) ‚Üí (d : C) ‚Üí Set c ‚ü∂ d)  : arrows = arrows
application type mismatch
  Set c
argument
  c
has type
  C : Type u
but is expected to have type
  Type ?u.52 : Type (?u.52 + 1) ; identifiers [C, u, CategoryTheory.Groupoid, C, arrows, c, C, d, C, Set, c, d, inv, c, C, d, C, p, c, d, a, p, arrows, c, d, CategoryTheory.Groupoid.inv, p, arrows, d, c, mul, c, C, d, C, e, C, p, c, d, a, p, arrows, c, d, q, d, e, a, q, arrows, d, e, CategoryTheory.CategoryStruct.comp, p, q, arrows, c, e, arrows_1, c, C, d, C, Set, c, d, inv_1, c, C, d, C, p, c, d, a, p, arrows_1, c, d, CategoryTheory.Groupoid.inv, p, arrows_1, d, c, mul_1, c, C, d, C, e, C, p, c, d, a, p, arrows_1, c, d, q, d, e, a, q, arrows_1, d, e, CategoryTheory.CategoryStruct.comp, p, q, arrows_1, c, e, a, arrows, arrows_1, h, arrows_1, arrows, arrows_2, c, C, d, C, Set, c, d, arrows, arrows] (during elaboration)

{Œ± : Type u_1} [LinearOrder Œ±] [LocallyFiniteOrder Œ±] (a : Œ±) (b : Œ±) (c : Œ±) (h : c ‚â§ b) (h_1 : (le_total b c =: (b ‚â§ c : Prop) ‚à® (c ‚â§ b : Prop)) = (Or.inr h =: (b ‚â§ c : Prop) ‚à® (c ‚â§ b : Prop))) (x : Œ±)  : (((a ‚â§ x : Prop) ‚àß ((x < b : Prop) ‚àß (‚àÄ (a : x < b) , ¬¨ (c ‚â§ x : Prop) : Prop) : Prop) : Prop) ‚Üî ((a ‚â§ x : Prop) ‚àß (x < c : Prop) : Prop)) = (((a ‚â§ x : Prop) ‚àß ((x < b : Prop) ‚àß (‚àÄ (a : x < b) , ¬¨ (c ‚â§ x : Prop) : Prop) : Prop) : Prop) ‚Üî ((a ‚â§ x : Prop) ‚àß (x < c : Prop) : Prop))
<input>:1:112: expected term

{Œ± : Type u_1} [LinearOrder Œ±] [LocallyFiniteOrder Œ±] (a : Œ±) (b : Œ±) (c : Œ±) (h : c ‚â§ b) (h_1 : (le_total b c =: (b ‚â§ c : Prop) ‚à® (c ‚â§ b : Prop)) = (Or.inr h =: (b ‚â§ c : Prop) ‚à® (c ‚â§ b : Prop))) (x : Œ±) (hx : x < c)  : ‚àÄ (x_1 : x < b) , x < c
<input>:1:112: expected term

{C : Type u} [CategoryTheory.Groupoid C] (arrows : (c : C) ‚Üí (d : C) ‚Üí Set c ‚ü∂ d) (inv : ‚àÄ {c : C} {d : C} {p : c ‚ü∂ d} (a : p ‚àà arrows c d) , CategoryTheory.Groupoid.inv p ‚àà arrows d c) (mul : ‚àÄ {c : C} {d : C} {e : C} {p : c ‚ü∂ d} (a : p ‚àà arrows c d) {q : d ‚ü∂ e} (a : q ‚àà arrows d e) , CategoryTheory.CategoryStruct.comp p q ‚àà arrows c e) (arrows_1 : (c : C) ‚Üí (d : C) ‚Üí Set c ‚ü∂ d) (inv_1 : ‚àÄ {c : C} {d : C} {p : c ‚ü∂ d} (a : p ‚àà arrows_1 c d) , CategoryTheory.Groupoid.inv p ‚àà arrows_1 d c) (mul_1 : ‚àÄ {c : C} {d : C} {e : C} {p : c ‚ü∂ d} (a : p ‚àà arrows_1 c d) {q : d ‚ü∂ e} (a : q ‚àà arrows_1 d e) , CategoryTheory.CategoryStruct.comp p q ‚àà arrows_1 c e) (a : arrows = arrows_1) (h : arrows_1 = arrows) (inv_2 : ‚àÄ {c : C} {d : C} {p : c ‚ü∂ d} (a : p ‚àà arrows c d) , CategoryTheory.Groupoid.inv p ‚àà arrows d c) (mul_2 : ‚àÄ {c : C} {d : C} {e : C} {p : c ‚ü∂ d} (a : p ‚àà arrows c d) {q : d ‚ü∂ e} (a : q ‚àà arrows d e) , CategoryTheory.CategoryStruct.comp p q ‚àà arrows c e) (a : arrows = arrows) (h : HEq a (Eq.refl arrows =: arrows = arrows))  : {arrows := ((arrows)) , inv := ((inv)) , mul := ((mul))} = {arrows := ((arrows)) , inv := ((inv)) , mul := ((mul))}
<input>:1:1015: expected term

{C : Type u} [CategoryTheory.Groupoid C] (arrows : (c : C) ‚Üí (d : C) ‚Üí Set c ‚ü∂ d) (inv : ‚àÄ {c : C} {d : C} {p : c ‚ü∂ d} (a : p ‚àà arrows c d) , CategoryTheory.Groupoid.inv p ‚àà arrows d c) (mul : ‚àÄ {c : C} {d : C} {e : C} {p : c ‚ü∂ d} (a : p ‚àà arrows c d) {q : d ‚ü∂ e} (a : q ‚àà arrows d e) , CategoryTheory.CategoryStruct.comp p q ‚àà arrows c e) (arrows_1 : (c : C) ‚Üí (d : C) ‚Üí Set c ‚ü∂ d) (inv_1 : ‚àÄ {c : C} {d : C} {p : c ‚ü∂ d} (a : p ‚àà arrows_1 c d) , CategoryTheory.Groupoid.inv p ‚àà arrows_1 d c) (mul_1 : ‚àÄ {c : C} {d : C} {e : C} {p : c ‚ü∂ d} (a : p ‚àà arrows_1 c d) {q : d ‚ü∂ e} (a : q ‚àà arrows_1 d e) , CategoryTheory.CategoryStruct.comp p q ‚àà arrows_1 c e) (a : arrows = arrows_1) (h : arrows_1 = arrows)  : arrows = arrows_1
application type mismatch
  Set c
argument
  c
has type
  C : Type u
but is expected to have type
  Type ?u.52 : Type (?u.52 + 1) ; identifiers [C, u, CategoryTheory.Groupoid, C, arrows, c, C, d, C, Set, c, d, inv, c, C, d, C, p, c, d, a, p, arrows, c, d, CategoryTheory.Groupoid.inv, p, arrows, d, c, mul, c, C, d, C, e, C, p, c, d, a, p, arrows, c, d, q, d, e, a, q, arrows, d, e, CategoryTheory.CategoryStruct.comp, p, q, arrows, c, e, arrows_1, c, C, d, C, Set, c, d, inv_1, c, C, d, C, p, c, d, a, p, arrows_1, c, d, CategoryTheory.Groupoid.inv, p, arrows_1, d, c, mul_1, c, C, d, C, e, C, p, c, d, a, p, arrows_1, c, d, q, d, e, a, q, arrows_1, d, e, CategoryTheory.CategoryStruct.comp, p, q, arrows_1, c, e, a, arrows, arrows_1, h, arrows_1, arrows, arrows, arrows_1] (during elaboration)

{C : Type u} [CategoryTheory.Groupoid C] (arrows : (c : C) ‚Üí (d : C) ‚Üí Set c ‚ü∂ d) (inv : ‚àÄ {c : C} {d : C} {p : c ‚ü∂ d} (a : p ‚àà arrows c d) , CategoryTheory.Groupoid.inv p ‚àà arrows d c) (mul : ‚àÄ {c : C} {d : C} {e : C} {p : c ‚ü∂ d} (a : p ‚àà arrows c d) {q : d ‚ü∂ e} (a : q ‚àà arrows d e) , CategoryTheory.CategoryStruct.comp p q ‚àà arrows c e) (arrows_1 : (c : C) ‚Üí (d : C) ‚Üí Set c ‚ü∂ d) (inv_1 : ‚àÄ {c : C} {d : C} {p : c ‚ü∂ d} (a : p ‚àà arrows_1 c d) , CategoryTheory.Groupoid.inv p ‚àà arrows_1 d c) (mul_1 : ‚àÄ {c : C} {d : C} {e : C} {p : c ‚ü∂ d} (a : p ‚àà arrows_1 c d) {q : d ‚ü∂ e} (a : q ‚àà arrows_1 d e) , CategoryTheory.CategoryStruct.comp p q ‚àà arrows_1 c e) (a : arrows = arrows_1)  : arrows_1 = arrows_1
application type mismatch
  Set c
argument
  c
has type
  C : Type u
but is expected to have type
  Type ?u.52 : Type (?u.52 + 1) ; identifiers [C, u, CategoryTheory.Groupoid, C, arrows, c, C, d, C, Set, c, d, inv, c, C, d, C, p, c, d, a, p, arrows, c, d, CategoryTheory.Groupoid.inv, p, arrows, d, c, mul, c, C, d, C, e, C, p, c, d, a, p, arrows, c, d, q, d, e, a, q, arrows, d, e, CategoryTheory.CategoryStruct.comp, p, q, arrows, c, e, arrows_1, c, C, d, C, Set, c, d, inv_1, c, C, d, C, p, c, d, a, p, arrows_1, c, d, CategoryTheory.Groupoid.inv, p, arrows_1, d, c, mul_1, c, C, d, C, e, C, p, c, d, a, p, arrows_1, c, d, q, d, e, a, q, arrows_1, d, e, CategoryTheory.CategoryStruct.comp, p, q, arrows_1, c, e, a, arrows, arrows_1, arrows_1, arrows_1] (during elaboration)

{Œ± : Type u_1} (S : Set Set Œ±) (x : Œ±)  : (¬¨ (‚àÉ (x_1 : Set Œ±) , (x_1 ‚àà S : Prop) ‚àß (x ‚àà x_1 : Prop) : Prop)) = (‚àÄ (x_1 : Set Œ±) , ¬¨ ((x_1 ‚àà S : Prop) ‚àß (x ‚àà x_1 : Prop) : Prop))
application type mismatch
  Set Set
argument
  Set
has type
  Type ?u.7 ‚Üí Type ?u.7 : Type (?u.7 + 1)
but is expected to have type
  Type ?u.6 : Type (?u.6 + 1) ; identifiers [Œ±, u_1, S, Set, Set, Œ±, x, Œ±, x_1, Set, Œ±, x_1, S, x, x_1, x_1, Set, Œ±, x_1, S, x, x_1] (during elaboration)

{Œ± : Type u_1} (S : Set Set Œ±) (x : Œ±)  : ‚àÄ (x_1 : Set Œ±) , (¬¨ ((x_1 ‚àà S : Prop) ‚àß (x ‚àà x_1 : Prop) : Prop)) = (‚àÄ (a : x_1 ‚àà S) , ¬¨ (x ‚àà x_1 : Prop))
application type mismatch
  Set Set
argument
  Set
has type
  Type ?u.7 ‚Üí Type ?u.7 : Type (?u.7 + 1)
but is expected to have type
  Type ?u.6 : Type (?u.6 + 1) ; identifiers [Œ±, u_1, S, Set, Set, Œ±, x, Œ±, x_1, Set, Œ±, x_1, S, x, x_1, a, x_1, S, x, x_1] (during elaboration)

{Œ± : Type u} {Œ≤ : Type v} [PseudoEMetricSpace Œ±] {s : Set Œ±} [PseudoEMetricSpace Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {t : Set Œ≤} {a : Œ±} {b : Œ≤} (Œµ : ENNReal) (x : 0 < Œµ) (Œ¥ : ENNReal) (x : 0 < Œ¥) (x : Œ±)  : (‚àÄ (a : (edist x a < Œ¥ : Prop) ‚àß (x ‚àà s : Prop)) , (edist f x b < Œµ : Prop) ‚àß (f x ‚àà t : Prop)) = (‚àÄ (a : edist x a < Œ¥) (a : x ‚àà s) , (edist f x b < Œµ : Prop) ‚àß (f x ‚àà t : Prop))
application type mismatch
  edist f x
argument
  x
has type
  Œ± : Type u
but is expected to have type
  Œ± ‚Üí Œ≤ : Type (max u v) ; identifiers [Œ±, u, Œ≤, v, PseudoEMetricSpace, Œ±, s, Set, Œ±, PseudoEMetricSpace, Œ≤, f, a, Œ±, Œ≤, t, Set, Œ≤, a, Œ±, b, Œ≤, Œµ, ENNReal, x, Œµ, Œ¥, ENNReal, x, Œ¥, x, Œ±, a, edist, x, a, Œ¥, x, s, edist, f, x, b, Œµ, f, x, t, a, edist, x, a, Œ¥, a, x, s, edist, f, x, b, Œµ, f, x, t] (during elaboration)

{Œ± : Type u_1} (S : Set Set Œ±) (x : Œ±) (i : Set Œ±)  : (i ‚àà S) = (i ‚àà S)
application type mismatch
  Set Set
argument
  Set
has type
  Type ?u.7 ‚Üí Type ?u.7 : Type (?u.7 + 1)
but is expected to have type
  Type ?u.6 : Type (?u.6 + 1) ; identifiers [Œ±, u_1, S, Set, Set, Œ±, x, Œ±, i, Set, Œ±, i, S, i, S] (during elaboration)

{Œ± : Type ua} [UniformSpace Œ±] {x : Œ±} {s : Set Œ±}  : ({p : Œ± √ó Œ± | ‚àÄ (a : Prod.fst p = x) , Prod.snd p ‚àà s} ‚àà uniformity Œ±) ‚Üî ({p : Œ± √ó Œ± | ‚àÄ (a : Prod.fst p = x) , Prod.snd p ‚àà s} ‚àà uniformity Œ±)
unknown universe level 'ua' ; identifiers [Œ±, ua, UniformSpace, Œ±, x, Œ±, s, Set, Œ±, p, Œ±, Œ±, a, Prod.fst, p, x, Prod.snd, p, s, uniformity, Œ±, p, Œ±, Œ±, a, Prod.fst, p, x, Prod.snd, p, s, uniformity, Œ±] (during elaboration)

(A : Type u_1) [AddCommGroup A] (H : ‚àÄ {n : ‚Ñ§} (_hn : n ‚â† 0) , n ‚Ä¢ ‚ä§ = ‚ä§) {n : ‚Ñ§} (a : A) (hn : n ‚â† 0)  : (a ‚àà n ‚Ä¢ ‚ä§) = (a ‚àà n ‚Ä¢ ‚ä§)
typeclass instance problem is stuck, it is often due to metavariables
  Membership A (?m.8892 A H a hn) ; identifiers [A, u_1, AddCommGroup, A, H, n, _hn, n, n, n, a, A, hn, n, a, n, a, n] (during elaboration)

{Œ± : Type u} {Œ≤ : Type v} [PseudoEMetricSpace Œ±] {s : Set Œ±} [PseudoEMetricSpace Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {t : Set Œ≤} {a : Œ±} {b : Œ≤} (Œµ : ENNReal) (x : 0 < Œµ) (Œ¥ : ENNReal) (x : 0 < Œ¥) (x : Œ±) em : (a : Prop) ‚Üí Decidable (a : Prop) := Classical.propDecidable (a_1 : ‚àÄ (a : edist x a < Œ¥) (a : x ‚àà s) , (edist f x b < Œµ : Prop) ‚àß (f x ‚àà t : Prop)) (h : ‚àÄ (a : x ‚àà s) , (edist f x b < Œµ : Prop) ‚àß (f x ‚àà t : Prop)) (a_2 : x ‚àà s) (a : edist x a < Œ¥) (h : (edist f x b < Œµ : Prop) ‚àß (f x ‚àà t : Prop))  : ‚àÄ (left : edist f x b < Œµ) (right : f x ‚àà t) , (f x ‚àà t) ‚àß (edist f x b < Œµ)
<input>:1:193: expected end of input

{B : Type u‚ÇÅ} [CategoryTheory.Bicategory B] {C : Type u‚ÇÇ} [CategoryTheory.Bicategory C] {F : CategoryTheory.OplaxFunctor B C} {G : CategoryTheory.OplaxFunctor B C} {Œ± : F ‚ü∂ G} {Œ≤ : F ‚ü∂ G} {m : Œ± ‚ü∂ Œ≤} {n : Œ± ‚ü∂ Œ≤} (w : ‚àÄ (b : B) , m . app b = n . app b)  : ‚àÄ (x : B) , m . app x = n . app x
function expected at
  m
term has type
  Œ± ‚ü∂ Œ≤ ; identifiers [B, u‚ÇÅ, CategoryTheory.Bicategory, B, C, u‚ÇÇ, CategoryTheory.Bicategory, C, F, CategoryTheory.OplaxFunctor, B, C, G, CategoryTheory.OplaxFunctor, B, C, Œ±, F, G, Œ≤, F, G, m, Œ±, Œ≤, n, Œ±, Œ≤, w, b, B, m, app, b, n, app, b, x, B, m, app, x, n, app, x] (during elaboration)

{C : Type u‚ÇÅ} [CategoryTheory.Category C] [CategoryTheory.MonoidalCategory C] {A : Mon_ C} {B : Mon_ C} {M : Bimod A B} {N : Bimod A B} (hom : Bimod.X M ‚ü∂ Bimod.X N) (left_act_hom : autoParam (CategoryTheory.CategoryStruct.comp Bimod.actLeft M hom = CategoryTheory.CategoryStruct.comp CategoryTheory.MonoidalCategory.tensorHom CategoryTheory.CategoryStruct.id Mon_.X A hom Bimod.actLeft N : Prop) _auto._@.Mathlib.CategoryTheory.Monoidal.Bimod._hyg.1664) (right_act_hom : autoParam (CategoryTheory.CategoryStruct.comp Bimod.actRight M hom = CategoryTheory.CategoryStruct.comp CategoryTheory.MonoidalCategory.tensorHom hom CategoryTheory.CategoryStruct.id Mon_.X B Bimod.actRight N : Prop) _auto._@.Mathlib.CategoryTheory.Monoidal.Bimod._hyg.1692) (hom_1 : Bimod.X M ‚ü∂ Bimod.X N) (left_act_hom_1 : autoParam (CategoryTheory.CategoryStruct.comp Bimod.actLeft M hom_1 = CategoryTheory.CategoryStruct.comp CategoryTheory.MonoidalCategory.tensorHom CategoryTheory.CategoryStruct.id Mon_.X A hom_1 Bimod.actLeft N : Prop) _auto._@.Mathlib.CategoryTheory.Monoidal.Bimod._hyg.1664) (right_act_hom_1 : autoParam (CategoryTheory.CategoryStruct.comp Bimod.actRight M hom_1 = CategoryTheory.CategoryStruct.comp CategoryTheory.MonoidalCategory.tensorHom hom_1 CategoryTheory.CategoryStruct.id Mon_.X B Bimod.actRight N : Prop) _auto._@.Mathlib.CategoryTheory.Monoidal.Bimod._hyg.1692) (a : Bimod.Hom.mk hom = Bimod.Hom.mk hom_1)  : ‚àÄ (hom_eq : hom = hom_1) , hom = hom_1
function expected at
  CategoryTheory.CategoryStruct.comp ?m.82510 ?m.162353
term has type
  ?m.1854 ‚ü∂ ?m.1856 ; identifiers [C, u‚ÇÅ, CategoryTheory.Category, C, CategoryTheory.MonoidalCategory, C, A, Mon_, C, B, Mon_, C, M, Bimod, A, B, N, Bimod, A, B, hom, Bimod.X, M, Bimod.X, N, left_act_hom, autoParam, CategoryTheory.CategoryStruct.comp, Bimod.actLeft, M, hom, CategoryTheory.CategoryStruct.comp, CategoryTheory.MonoidalCategory.tensorHom, CategoryTheory.CategoryStruct.id, Mon_.X, A, hom, Bimod.actLeft, N, _auto._, Mathlib.CategoryTheory.Monoidal.Bimod._hyg, right_act_hom, autoParam, CategoryTheory.CategoryStruct.comp, Bimod.actRight, M, hom, CategoryTheory.CategoryStruct.comp, CategoryTheory.MonoidalCategory.tensorHom, hom, CategoryTheory.CategoryStruct.id, Mon_.X, B, Bimod.actRight, N, _auto._, Mathlib.CategoryTheory.Monoidal.Bimod._hyg, hom_1, Bimod.X, M, Bimod.X, N, left_act_hom_1, autoParam, CategoryTheory.CategoryStruct.comp, Bimod.actLeft, M, hom_1, CategoryTheory.CategoryStruct.comp, CategoryTheory.MonoidalCategory.tensorHom, CategoryTheory.CategoryStruct.id, Mon_.X, A, hom_1, Bimod.actLeft, N, _auto._, Mathlib.CategoryTheory.Monoidal.Bimod._hyg, right_act_hom_1, autoParam, CategoryTheory.CategoryStruct.comp, Bimod.actRight, M, hom_1, CategoryTheory.CategoryStruct.comp, CategoryTheory.MonoidalCategory.tensorHom, hom_1, CategoryTheory.CategoryStruct.id, Mon_.X, B, Bimod.actRight, N, _auto._, Mathlib.CategoryTheory.Monoidal.Bimod._hyg, a, Bimod.Hom.mk, hom, Bimod.Hom.mk, hom_1, hom_eq, hom, hom_1, hom, hom_1] (during elaboration)

{M : Type u_1} [AddMonoid M] [Preorder M] [CovariantClass M M fun (x : M) (x_1 : M) ‚Ü¶ x + x_1 fun (x : M) (x_1 : M) ‚Ü¶ x ‚â§ x_1] {x : M} (hx : x ‚â§ 0) (x_1 : ‚Ñï) (x_2 : ‚Ñï) (f : Nat.below x_2) (k : ‚Ñï) (x_3 : Nat.below Nat.succ k)  : (k + 1 ‚Ä¢ x ‚â§ 0) = (k + 1 ‚Ä¢ x ‚â§ 0)
function expected at
  x_1
term has type
  M ; identifiers [M, u_1, AddMonoid, M, Preorder, M, CovariantClass, M, M, x, M, x_1, M, x, x_1, x, M, x_1, M, x, x_1, x, M, hx, x, x_1, x_2, f, Nat.below, x_2, k, x_3, Nat.below, Nat.succ, k, k, x, k, x] (during elaboration)

{Œ± : Type u} {Œ≤ : Type v} [PseudoEMetricSpace Œ±] {s : Set Œ±} [PseudoEMetricSpace Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {t : Set Œ≤} {a : Œ±} {b : Œ≤} (Œµ : ENNReal) (x : 0 < Œµ) (Œ¥ : ENNReal) (x : 0 < Œ¥) (x : Œ±) em : (a : Prop) ‚Üí Decidable (a : Prop) := Classical.propDecidable (a_1 : ‚àÄ (a_1 : x ‚àà s) (a : edist x a < Œ¥) , (f x ‚àà t : Prop) ‚àß (edist f x b < Œµ : Prop)) (h : ‚àÄ (a : edist x a < Œ¥) , (f x ‚àà t : Prop) ‚àß (edist f x b < Œµ : Prop)) (a_2 : edist x a < Œ¥) (a_3 : x ‚àà s) (h : (f x ‚àà t : Prop) ‚àß (edist f x b < Œµ : Prop))  : ‚àÄ (left : f x ‚àà t) (right : edist f x b < Œµ) , (edist f x b < Œµ) ‚àß (f x ‚àà t)
<input>:1:193: expected end of input

{c : (a : Type u_1) ‚Üí Type u_1} {hom : ‚¶É Œ± : Type u_1 ‚¶Ñ ‚Üí ‚¶É Œ≤ : Type u_1 ‚¶Ñ ‚Üí (x : c Œ±) ‚Üí (x : c Œ≤) ‚Üí Type u_1} [CategoryTheory.BundledHom hom] {d : (a : Type u_1) ‚Üí Type u_1} {hom_d : ‚¶É Œ± : Type u_1 ‚¶Ñ ‚Üí ‚¶É Œ≤ : Type u_1 ‚¶Ñ ‚Üí (x : d Œ±) ‚Üí (x : d Œ≤) ‚Üí Type u_1} [CategoryTheory.BundledHom hom_d] (obj : ‚¶É Œ± : Type u_1 ‚¶Ñ ‚Üí (a : c Œ±) ‚Üí d Œ±) (map : {X : CategoryTheory.Bundled c} ‚Üí {Y : CategoryTheory.Bundled c} ‚Üí (a : X ‚ü∂ Y) ‚Üí CategoryTheory.Bundled.map obj X ‚ü∂ CategoryTheory.Bundled.map obj Y) (h_map : ‚àÄ {X : CategoryTheory.Bundled c} {Y : CategoryTheory.Bundled c} (f : X ‚ü∂ Y) , ‚Üë map f = ‚Üë f) {X : CategoryTheory.Bundled c} {Y : CategoryTheory.Bundled c} {f : X ‚ü∂ Y}  : ‚Üë map f = ‚Üë f
type mismatch
  f
has type
  X ‚ü∂ Y : Type u_1
but is expected to have type
  ?m.159011 obj map h_map : Sort ?u.158706 ; identifiers [c, a, u_1, u_1, hom, Œ±, u_1, Œ≤, u_1, x, c, Œ±, x, c, Œ≤, u_1, CategoryTheory.BundledHom, hom, d, a, u_1, u_1, hom_d, Œ±, u_1, Œ≤, u_1, x, d, Œ±, x, d, Œ≤, u_1, CategoryTheory.BundledHom, hom_d, obj, Œ±, u_1, a, c, Œ±, d, Œ±, map, X, CategoryTheory.Bundled, c, Y, CategoryTheory.Bundled, c, a, X, Y, CategoryTheory.Bundled.map, obj, X, CategoryTheory.Bundled.map, obj, Y, h_map, X, CategoryTheory.Bundled, c, Y, CategoryTheory.Bundled, c, f, X, Y, map, f, f, X, CategoryTheory.Bundled, c, Y, CategoryTheory.Bundled, c, f, X, Y, map, f, f] (during elaboration)

{c : (a : Type u_1) ‚Üí Type u_1} {hom : ‚¶É Œ± : Type u_1 ‚¶Ñ ‚Üí ‚¶É Œ≤ : Type u_1 ‚¶Ñ ‚Üí (x : c Œ±) ‚Üí (x : c Œ≤) ‚Üí Type u_1} [CategoryTheory.BundledHom hom] {d : (a : Type u_1) ‚Üí Type u_1} {hom_d : ‚¶É Œ± : Type u_1 ‚¶Ñ ‚Üí ‚¶É Œ≤ : Type u_1 ‚¶Ñ ‚Üí (x : d Œ±) ‚Üí (x : d Œ≤) ‚Üí Type u_1} [CategoryTheory.BundledHom hom_d] (obj : ‚¶É Œ± : Type u_1 ‚¶Ñ ‚Üí (a : c Œ±) ‚Üí d Œ±) (map : {X : CategoryTheory.Bundled c} ‚Üí {Y : CategoryTheory.Bundled c} ‚Üí (a : X ‚ü∂ Y) ‚Üí CategoryTheory.Bundled.map obj X ‚ü∂ CategoryTheory.Bundled.map obj Y) (h_map : ‚àÄ {X : CategoryTheory.Bundled c} {Y : CategoryTheory.Bundled c} (f : X ‚ü∂ Y) , ‚Üë map f = ‚Üë f) {X : CategoryTheory.Bundled c} {Y : CategoryTheory.Bundled c} {f : X ‚ü∂ Y}  : (‚Üë fun {X : CategoryTheory.Bundled c} {Y : CategoryTheory.Bundled c} ‚Ü¶ map f = ‚Üë f) = (‚Üë fun {X : CategoryTheory.Bundled c} {Y : CategoryTheory.Bundled c} ‚Ü¶ map f = ‚Üë f)
type mismatch
  f
has type
  X ‚ü∂ Y : Type u_1
but is expected to have type
  ?m.158984 obj map f : Sort ?u.158565 ; identifiers [c, a, u_1, u_1, hom, Œ±, u_1, Œ≤, u_1, x, c, Œ±, x, c, Œ≤, u_1, CategoryTheory.BundledHom, hom, d, a, u_1, u_1, hom_d, Œ±, u_1, Œ≤, u_1, x, d, Œ±, x, d, Œ≤, u_1, CategoryTheory.BundledHom, hom_d, obj, Œ±, u_1, a, c, Œ±, d, Œ±, map, X, CategoryTheory.Bundled, c, Y, CategoryTheory.Bundled, c, a, X, Y, CategoryTheory.Bundled.map, obj, X, CategoryTheory.Bundled.map, obj, Y, h_map, X, CategoryTheory.Bundled, c, Y, CategoryTheory.Bundled, c, f, X, Y, map, f, f, X, CategoryTheory.Bundled, c, Y, CategoryTheory.Bundled, c, f, X, Y, X, CategoryTheory.Bundled, c, Y, CategoryTheory.Bundled, c, map, f, f, X, CategoryTheory.Bundled, c, Y, CategoryTheory.Bundled, c, map, f, f] (during elaboration)

{Œ± : Type u_1} [DecidableEq Option Œ±] (s : Finset Option Œ±) (a : Option Œ±) (a : Œ±)  : (a ‚àà none) = (none = some a)
application type mismatch
  DecidableEq Option
argument
  Option
has type
  Type ?u.7 ‚Üí Type ?u.7 : Type (?u.7 + 1)
but is expected to have type
  Sort ?u.6 : Type ?u.6 ; identifiers [Œ±, u_1, DecidableEq, Option, Œ±, s, Finset, Option, Œ±, a, Option, Œ±, a, Œ±, a, none, none, some, a] (during elaboration)

 : (‚àÄ {Œ± : Type u_1} [inst : Union Œ±] {a : Part Œ±} {b : Part Œ±} (hab : Part.Dom a ‚à™ b) , Part.Dom a)
application type mismatch
  a.Dom ‚à™ b
argument
  b
has type
  Part Œ± : Type u_1
but is expected to have type
  Prop : Type ; identifiers [Œ±, u_1, inst, Union, Œ±, a, Part, Œ±, b, Part, Œ±, hab, Part.Dom, a, b, Part.Dom, a] (during elaboration)

 : ‚àÄ {Œ± : Type u_1} [inst : Union Œ±] {a : Part Œ±} {b : Part Œ±} (hab : Part.Dom a ‚à™ b) , Part.Dom fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚à™ x_1 <$> a
application type mismatch
  a.Dom ‚à™ b
argument
  b
has type
  Part Œ± : Type u_1
but is expected to have type
  Prop : Type ; identifiers [Œ±, u_1, inst, Union, Œ±, a, Part, Œ±, b, Part, Œ±, hab, Part.Dom, a, b, Part.Dom, x, Œ±, x_1, Œ±, x, x_1, a] (during elaboration)

{c : (a : Type u_1) ‚Üí Type u_1} {hom : ‚¶É Œ± : Type u_1 ‚¶Ñ ‚Üí ‚¶É Œ≤ : Type u_1 ‚¶Ñ ‚Üí (x : c Œ±) ‚Üí (x : c Œ≤) ‚Üí Type u_1} [CategoryTheory.BundledHom hom] {d : (a : Type u_1) ‚Üí Type u_1} {hom_d : ‚¶É Œ± : Type u_1 ‚¶Ñ ‚Üí ‚¶É Œ≤ : Type u_1 ‚¶Ñ ‚Üí (x : d Œ±) ‚Üí (x : d Œ≤) ‚Üí Type u_1} [CategoryTheory.BundledHom hom_d] (obj : ‚¶É Œ± : Type u_1 ‚¶Ñ ‚Üí (a : c Œ±) ‚Üí d Œ±) (map : {X : CategoryTheory.Bundled c} ‚Üí {Y : CategoryTheory.Bundled c} ‚Üí (a : X ‚ü∂ Y) ‚Üí CategoryTheory.Bundled.map obj X ‚ü∂ CategoryTheory.Bundled.map obj Y) (h_map : ‚àÄ {X : CategoryTheory.Bundled c} {Y : CategoryTheory.Bundled c} (f : X ‚ü∂ Y) , ‚Üë map f = ‚Üë f) {X : CategoryTheory.Bundled c} {Y : CategoryTheory.Bundled c} {f : X ‚ü∂ Y}  : ‚Üë f = ‚Üë f
type mismatch
  f
has type
  X ‚ü∂ Y : Type u_1
but is expected to have type
  ?m.158999 obj map h_map : Sort ?u.158706 ; identifiers [c, a, u_1, u_1, hom, Œ±, u_1, Œ≤, u_1, x, c, Œ±, x, c, Œ≤, u_1, CategoryTheory.BundledHom, hom, d, a, u_1, u_1, hom_d, Œ±, u_1, Œ≤, u_1, x, d, Œ±, x, d, Œ≤, u_1, CategoryTheory.BundledHom, hom_d, obj, Œ±, u_1, a, c, Œ±, d, Œ±, map, X, CategoryTheory.Bundled, c, Y, CategoryTheory.Bundled, c, a, X, Y, CategoryTheory.Bundled.map, obj, X, CategoryTheory.Bundled.map, obj, Y, h_map, X, CategoryTheory.Bundled, c, Y, CategoryTheory.Bundled, c, f, X, Y, map, f, f, X, CategoryTheory.Bundled, c, Y, CategoryTheory.Bundled, c, f, X, Y, f, f] (during elaboration)

 : (‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {T‚ÇÅ : CategoryTheory.Monad C} {T‚ÇÇ : CategoryTheory.Monad C} (self : CategoryTheory.MonadHom T‚ÇÅ T‚ÇÇ) (X : C) , CategoryTheory.CategoryStruct.comp CategoryTheory.NatTrans.app CategoryTheory.Monad.Œº T‚ÇÅ X CategoryTheory.NatTrans.app CategoryTheory.MonadHom.toNatTrans self X = CategoryTheory.CategoryStruct.comp CategoryTheory.CategoryStruct.comp CategoryTheory.Functor.toPrefunctor CategoryTheory.Monad.toFunctor T‚ÇÅ . map CategoryTheory.NatTrans.app CategoryTheory.MonadHom.toNatTrans self X CategoryTheory.NatTrans.app CategoryTheory.MonadHom.toNatTrans self CategoryTheory.Functor.toPrefunctor CategoryTheory.Monad.toFunctor T‚ÇÇ . obj X CategoryTheory.NatTrans.app CategoryTheory.Monad.Œº T‚ÇÇ X)
function expected at
  CategoryTheory.CategoryStruct.comp ?m.82129 ?m.162635
term has type
  ?m.443 ‚ü∂ ?m.445 ; identifiers [C, u‚ÇÅ, inst, CategoryTheory.Category, C, T‚ÇÅ, CategoryTheory.Monad, C, T‚ÇÇ, CategoryTheory.Monad, C, self, CategoryTheory.MonadHom, T‚ÇÅ, T‚ÇÇ, X, C, CategoryTheory.CategoryStruct.comp, CategoryTheory.NatTrans.app, CategoryTheory.Monad.Œº, T‚ÇÅ, X, CategoryTheory.NatTrans.app, CategoryTheory.MonadHom.toNatTrans, self, X, CategoryTheory.CategoryStruct.comp, CategoryTheory.CategoryStruct.comp, CategoryTheory.Functor.toPrefunctor, CategoryTheory.Monad.toFunctor, T‚ÇÅ, map, CategoryTheory.NatTrans.app, CategoryTheory.MonadHom.toNatTrans, self, X, CategoryTheory.NatTrans.app, CategoryTheory.MonadHom.toNatTrans, self, CategoryTheory.Functor.toPrefunctor, CategoryTheory.Monad.toFunctor, T‚ÇÇ, obj, X, CategoryTheory.NatTrans.app, CategoryTheory.Monad.Œº, T‚ÇÇ, X] (during elaboration)

 : ‚àÄ (C : Type u‚ÇÅ) [inst : CategoryTheory.Category C] (T‚ÇÅ : CategoryTheory.Monad C) (T‚ÇÇ : CategoryTheory.Monad C) (self : CategoryTheory.MonadHom T‚ÇÅ T‚ÇÇ) (X : C) , CategoryTheory.CategoryStruct.comp CategoryTheory.NatTrans.app CategoryTheory.Monad.Œº T‚ÇÅ X CategoryTheory.NatTrans.app self . 1 X = CategoryTheory.CategoryStruct.comp CategoryTheory.CategoryStruct.comp CategoryTheory.Functor.toPrefunctor CategoryTheory.Monad.toFunctor T‚ÇÅ . map CategoryTheory.NatTrans.app self . 1 X CategoryTheory.NatTrans.app self . 1 CategoryTheory.Functor.toPrefunctor CategoryTheory.Monad.toFunctor T‚ÇÇ . obj X CategoryTheory.NatTrans.app CategoryTheory.Monad.Œº T‚ÇÇ X
function expected at
  CategoryTheory.CategoryStruct.comp ?m.82123 ?m.162629
term has type
  ?m.437 ‚ü∂ ?m.439 ; identifiers [C, u‚ÇÅ, inst, CategoryTheory.Category, C, T‚ÇÅ, CategoryTheory.Monad, C, T‚ÇÇ, CategoryTheory.Monad, C, self, CategoryTheory.MonadHom, T‚ÇÅ, T‚ÇÇ, X, C, CategoryTheory.CategoryStruct.comp, CategoryTheory.NatTrans.app, CategoryTheory.Monad.Œº, T‚ÇÅ, X, CategoryTheory.NatTrans.app, self, X, CategoryTheory.CategoryStruct.comp, CategoryTheory.CategoryStruct.comp, CategoryTheory.Functor.toPrefunctor, CategoryTheory.Monad.toFunctor, T‚ÇÅ, map, CategoryTheory.NatTrans.app, self, X, CategoryTheory.NatTrans.app, self, CategoryTheory.Functor.toPrefunctor, CategoryTheory.Monad.toFunctor, T‚ÇÇ, obj, X, CategoryTheory.NatTrans.app, CategoryTheory.Monad.Œº, T‚ÇÇ, X] (during elaboration)

{C : Type u‚ÇÅ} [CategoryTheory.Category C] [CategoryTheory.MonoidalCategory C] {A : Mon_ C} {B : Mon_ C} {M : Bimod A B} {N : Bimod A B} (hom : Bimod.X M ‚ü∂ Bimod.X N) (left_act_hom : autoParam (CategoryTheory.CategoryStruct.comp Bimod.actLeft M hom = CategoryTheory.CategoryStruct.comp CategoryTheory.MonoidalCategory.tensorHom CategoryTheory.CategoryStruct.id Mon_.X A hom Bimod.actLeft N : Prop) _auto._@.Mathlib.CategoryTheory.Monoidal.Bimod._hyg.1664) (right_act_hom : autoParam (CategoryTheory.CategoryStruct.comp Bimod.actRight M hom = CategoryTheory.CategoryStruct.comp CategoryTheory.MonoidalCategory.tensorHom hom CategoryTheory.CategoryStruct.id Mon_.X B Bimod.actRight N : Prop) _auto._@.Mathlib.CategoryTheory.Monoidal.Bimod._hyg.1692) (hom_1 : Bimod.X M ‚ü∂ Bimod.X N) (left_act_hom_1 : autoParam (CategoryTheory.CategoryStruct.comp Bimod.actLeft M hom_1 = CategoryTheory.CategoryStruct.comp CategoryTheory.MonoidalCategory.tensorHom CategoryTheory.CategoryStruct.id Mon_.X A hom_1 Bimod.actLeft N : Prop) _auto._@.Mathlib.CategoryTheory.Monoidal.Bimod._hyg.1664) (right_act_hom_1 : autoParam (CategoryTheory.CategoryStruct.comp Bimod.actRight M hom_1 = CategoryTheory.CategoryStruct.comp CategoryTheory.MonoidalCategory.tensorHom hom_1 CategoryTheory.CategoryStruct.id Mon_.X B Bimod.actRight N : Prop) _auto._@.Mathlib.CategoryTheory.Monoidal.Bimod._hyg.1692) (a : hom = hom_1) (h : hom_1 = hom) (hom_2 : Bimod.X M ‚ü∂ Bimod.X N)  : hom = hom
function expected at
  CategoryTheory.CategoryStruct.comp ?m.82510 ?m.162353
term has type
  ?m.1854 ‚ü∂ ?m.1856 ; identifiers [C, u‚ÇÅ, CategoryTheory.Category, C, CategoryTheory.MonoidalCategory, C, A, Mon_, C, B, Mon_, C, M, Bimod, A, B, N, Bimod, A, B, hom, Bimod.X, M, Bimod.X, N, left_act_hom, autoParam, CategoryTheory.CategoryStruct.comp, Bimod.actLeft, M, hom, CategoryTheory.CategoryStruct.comp, CategoryTheory.MonoidalCategory.tensorHom, CategoryTheory.CategoryStruct.id, Mon_.X, A, hom, Bimod.actLeft, N, _auto._, Mathlib.CategoryTheory.Monoidal.Bimod._hyg, right_act_hom, autoParam, CategoryTheory.CategoryStruct.comp, Bimod.actRight, M, hom, CategoryTheory.CategoryStruct.comp, CategoryTheory.MonoidalCategory.tensorHom, hom, CategoryTheory.CategoryStruct.id, Mon_.X, B, Bimod.actRight, N, _auto._, Mathlib.CategoryTheory.Monoidal.Bimod._hyg, hom_1, Bimod.X, M, Bimod.X, N, left_act_hom_1, autoParam, CategoryTheory.CategoryStruct.comp, Bimod.actLeft, M, hom_1, CategoryTheory.CategoryStruct.comp, CategoryTheory.MonoidalCategory.tensorHom, CategoryTheory.CategoryStruct.id, Mon_.X, A, hom_1, Bimod.actLeft, N, _auto._, Mathlib.CategoryTheory.Monoidal.Bimod._hyg, right_act_hom_1, autoParam, CategoryTheory.CategoryStruct.comp, Bimod.actRight, M, hom_1, CategoryTheory.CategoryStruct.comp, CategoryTheory.MonoidalCategory.tensorHom, hom_1, CategoryTheory.CategoryStruct.id, Mon_.X, B, Bimod.actRight, N, _auto._, Mathlib.CategoryTheory.Monoidal.Bimod._hyg, a, hom, hom_1, h, hom_1, hom, hom_2, Bimod.X, M, Bimod.X, N, hom, hom] (during elaboration)

{Œ± : Type u} [TopologicalSpace Œ±] (x : Œ±) (C : Set Œ±)  : (ClusterPt x Filter.principal C ‚à© {x} ·∂ú) ‚Üî (ClusterPt x Filter.principal C ‚à© {x} ·∂ú)
application type mismatch
  ClusterPt x Filter.principal
argument
  Filter.principal
has type
  Set ?m.23 ‚Üí Filter ?m.23 : Type ?u.22
but is expected to have type
  Filter Œ± : Type u ; identifiers [Œ±, u, TopologicalSpace, Œ±, x, Œ±, C, Set, Œ±, ClusterPt, x, Filter.principal, C, x, x, ClusterPt, x, Filter.principal, C, x, x] (during elaboration)

{c‚ÇÅ : Nat.Partrec.Code} {c‚ÇÇ : Nat.Partrec.Code} {n‚ÇÅ : ‚Ñï} {n‚ÇÇ : ‚Ñï} (h : Nat.Partrec.Code.curry c‚ÇÅ n‚ÇÅ = Nat.Partrec.Code.curry c‚ÇÇ n‚ÇÇ)  : ‚àÄ (a_eq : c‚ÇÅ = c‚ÇÇ) (a_eq : Nat.Partrec.Code.pair Nat.Partrec.Code.const n‚ÇÅ Nat.Partrec.Code.id = Nat.Partrec.Code.pair Nat.Partrec.Code.const n‚ÇÇ Nat.Partrec.Code.id) , c‚ÇÅ = c‚ÇÇ
application type mismatch
  Nat.Partrec.Code.pair Nat.Partrec.Code.const
argument
  Nat.Partrec.Code.const
has type
  ‚Ñï ‚Üí Nat.Partrec.Code : Type
but is expected to have type
  Nat.Partrec.Code : Type ; identifiers [c‚ÇÅ, Nat.Partrec.Code, c‚ÇÇ, Nat.Partrec.Code, n‚ÇÅ, n‚ÇÇ, h, Nat.Partrec.Code.curry, c‚ÇÅ, n‚ÇÅ, Nat.Partrec.Code.curry, c‚ÇÇ, n‚ÇÇ, a_eq, c‚ÇÅ, c‚ÇÇ, a_eq, Nat.Partrec.Code.pair, Nat.Partrec.Code.const, n‚ÇÅ, Nat.Partrec.Code.id, Nat.Partrec.Code.pair, Nat.Partrec.Code.const, n‚ÇÇ, Nat.Partrec.Code.id, c‚ÇÅ, c‚ÇÇ] (during elaboration)

{C : Type u‚ÇÅ} [CategoryTheory.Category C] [CategoryTheory.MonoidalCategory C] {A : Mon_ C} {B : Mon_ C} {M : Bimod A B} {N : Bimod A B} (hom : Bimod.X M ‚ü∂ Bimod.X N) (left_act_hom : autoParam (CategoryTheory.CategoryStruct.comp Bimod.actLeft M hom = CategoryTheory.CategoryStruct.comp CategoryTheory.MonoidalCategory.tensorHom CategoryTheory.CategoryStruct.id Mon_.X A hom Bimod.actLeft N : Prop) _auto._@.Mathlib.CategoryTheory.Monoidal.Bimod._hyg.1664) (right_act_hom : autoParam (CategoryTheory.CategoryStruct.comp Bimod.actRight M hom = CategoryTheory.CategoryStruct.comp CategoryTheory.MonoidalCategory.tensorHom hom CategoryTheory.CategoryStruct.id Mon_.X B Bimod.actRight N : Prop) _auto._@.Mathlib.CategoryTheory.Monoidal.Bimod._hyg.1692) (hom_1 : Bimod.X M ‚ü∂ Bimod.X N) (left_act_hom_1 : autoParam (CategoryTheory.CategoryStruct.comp Bimod.actLeft M hom_1 = CategoryTheory.CategoryStruct.comp CategoryTheory.MonoidalCategory.tensorHom CategoryTheory.CategoryStruct.id Mon_.X A hom_1 Bimod.actLeft N : Prop) _auto._@.Mathlib.CategoryTheory.Monoidal.Bimod._hyg.1664) (right_act_hom_1 : autoParam (CategoryTheory.CategoryStruct.comp Bimod.actRight M hom_1 = CategoryTheory.CategoryStruct.comp CategoryTheory.MonoidalCategory.tensorHom hom_1 CategoryTheory.CategoryStruct.id Mon_.X B Bimod.actRight N : Prop) _auto._@.Mathlib.CategoryTheory.Monoidal.Bimod._hyg.1692) (a : hom = hom_1) (h : hom_1 = hom)  : hom = hom_1
function expected at
  CategoryTheory.CategoryStruct.comp ?m.82510 ?m.162353
term has type
  ?m.1854 ‚ü∂ ?m.1856 ; identifiers [C, u‚ÇÅ, CategoryTheory.Category, C, CategoryTheory.MonoidalCategory, C, A, Mon_, C, B, Mon_, C, M, Bimod, A, B, N, Bimod, A, B, hom, Bimod.X, M, Bimod.X, N, left_act_hom, autoParam, CategoryTheory.CategoryStruct.comp, Bimod.actLeft, M, hom, CategoryTheory.CategoryStruct.comp, CategoryTheory.MonoidalCategory.tensorHom, CategoryTheory.CategoryStruct.id, Mon_.X, A, hom, Bimod.actLeft, N, _auto._, Mathlib.CategoryTheory.Monoidal.Bimod._hyg, right_act_hom, autoParam, CategoryTheory.CategoryStruct.comp, Bimod.actRight, M, hom, CategoryTheory.CategoryStruct.comp, CategoryTheory.MonoidalCategory.tensorHom, hom, CategoryTheory.CategoryStruct.id, Mon_.X, B, Bimod.actRight, N, _auto._, Mathlib.CategoryTheory.Monoidal.Bimod._hyg, hom_1, Bimod.X, M, Bimod.X, N, left_act_hom_1, autoParam, CategoryTheory.CategoryStruct.comp, Bimod.actLeft, M, hom_1, CategoryTheory.CategoryStruct.comp, CategoryTheory.MonoidalCategory.tensorHom, CategoryTheory.CategoryStruct.id, Mon_.X, A, hom_1, Bimod.actLeft, N, _auto._, Mathlib.CategoryTheory.Monoidal.Bimod._hyg, right_act_hom_1, autoParam, CategoryTheory.CategoryStruct.comp, Bimod.actRight, M, hom_1, CategoryTheory.CategoryStruct.comp, CategoryTheory.MonoidalCategory.tensorHom, hom_1, CategoryTheory.CategoryStruct.id, Mon_.X, B, Bimod.actRight, N, _auto._, Mathlib.CategoryTheory.Monoidal.Bimod._hyg, a, hom, hom_1, h, hom_1, hom, hom, hom_1] (during elaboration)

{C : Type u‚ÇÅ} [CategoryTheory.Category C] [CategoryTheory.MonoidalCategory C] {A : Mon_ C} {B : Mon_ C} {M : Bimod A B} {N : Bimod A B} (hom : Bimod.X M ‚ü∂ Bimod.X N) (left_act_hom : autoParam (CategoryTheory.CategoryStruct.comp Bimod.actLeft M hom = CategoryTheory.CategoryStruct.comp CategoryTheory.MonoidalCategory.tensorHom CategoryTheory.CategoryStruct.id Mon_.X A hom Bimod.actLeft N : Prop) _auto._@.Mathlib.CategoryTheory.Monoidal.Bimod._hyg.1664) (right_act_hom : autoParam (CategoryTheory.CategoryStruct.comp Bimod.actRight M hom = CategoryTheory.CategoryStruct.comp CategoryTheory.MonoidalCategory.tensorHom hom CategoryTheory.CategoryStruct.id Mon_.X B Bimod.actRight N : Prop) _auto._@.Mathlib.CategoryTheory.Monoidal.Bimod._hyg.1692) (hom_1 : Bimod.X M ‚ü∂ Bimod.X N) (left_act_hom_1 : autoParam (CategoryTheory.CategoryStruct.comp Bimod.actLeft M hom_1 = CategoryTheory.CategoryStruct.comp CategoryTheory.MonoidalCategory.tensorHom CategoryTheory.CategoryStruct.id Mon_.X A hom_1 Bimod.actLeft N : Prop) _auto._@.Mathlib.CategoryTheory.Monoidal.Bimod._hyg.1664) (right_act_hom_1 : autoParam (CategoryTheory.CategoryStruct.comp Bimod.actRight M hom_1 = CategoryTheory.CategoryStruct.comp CategoryTheory.MonoidalCategory.tensorHom hom_1 CategoryTheory.CategoryStruct.id Mon_.X B Bimod.actRight N : Prop) _auto._@.Mathlib.CategoryTheory.Monoidal.Bimod._hyg.1692) (a : hom = hom_1)  : hom_1 = hom_1
function expected at
  CategoryTheory.CategoryStruct.comp ?m.82510 ?m.162353
term has type
  ?m.1854 ‚ü∂ ?m.1856 ; identifiers [C, u‚ÇÅ, CategoryTheory.Category, C, CategoryTheory.MonoidalCategory, C, A, Mon_, C, B, Mon_, C, M, Bimod, A, B, N, Bimod, A, B, hom, Bimod.X, M, Bimod.X, N, left_act_hom, autoParam, CategoryTheory.CategoryStruct.comp, Bimod.actLeft, M, hom, CategoryTheory.CategoryStruct.comp, CategoryTheory.MonoidalCategory.tensorHom, CategoryTheory.CategoryStruct.id, Mon_.X, A, hom, Bimod.actLeft, N, _auto._, Mathlib.CategoryTheory.Monoidal.Bimod._hyg, right_act_hom, autoParam, CategoryTheory.CategoryStruct.comp, Bimod.actRight, M, hom, CategoryTheory.CategoryStruct.comp, CategoryTheory.MonoidalCategory.tensorHom, hom, CategoryTheory.CategoryStruct.id, Mon_.X, B, Bimod.actRight, N, _auto._, Mathlib.CategoryTheory.Monoidal.Bimod._hyg, hom_1, Bimod.X, M, Bimod.X, N, left_act_hom_1, autoParam, CategoryTheory.CategoryStruct.comp, Bimod.actLeft, M, hom_1, CategoryTheory.CategoryStruct.comp, CategoryTheory.MonoidalCategory.tensorHom, CategoryTheory.CategoryStruct.id, Mon_.X, A, hom_1, Bimod.actLeft, N, _auto._, Mathlib.CategoryTheory.Monoidal.Bimod._hyg, right_act_hom_1, autoParam, CategoryTheory.CategoryStruct.comp, Bimod.actRight, M, hom_1, CategoryTheory.CategoryStruct.comp, CategoryTheory.MonoidalCategory.tensorHom, hom_1, CategoryTheory.CategoryStruct.id, Mon_.X, B, Bimod.actRight, N, _auto._, Mathlib.CategoryTheory.Monoidal.Bimod._hyg, a, hom, hom_1, hom_1, hom_1] (during elaboration)

{Œ± : Type u_1} [DecidableEq Option Œ±] (s : Finset Option Œ±) (a : Option Œ±) (x : Œ±) (a : Œ±)  : (a ‚àà some x) = (some x = some a)
application type mismatch
  DecidableEq Option
argument
  Option
has type
  Type ?u.7 ‚Üí Type ?u.7 : Type (?u.7 + 1)
but is expected to have type
  Sort ?u.6 : Type ?u.6 ; identifiers [Œ±, u_1, DecidableEq, Option, Œ±, s, Finset, Option, Œ±, a, Option, Œ±, x, Œ±, a, Œ±, a, some, x, some, x, some, a] (during elaboration)

{Œ± : Type u_1} [DecidableEq Option Œ±] (s : Finset Option Œ±) (a : Option Œ±) (x : Œ±)  : (‚àÄ (a : Œ±) (a_1 : x = a) , some a ‚àà s) = (some x ‚àà s)
application type mismatch
  DecidableEq Option
argument
  Option
has type
  Type ?u.7 ‚Üí Type ?u.7 : Type (?u.7 + 1)
but is expected to have type
  Sort ?u.6 : Type ?u.6 ; identifiers [Œ±, u_1, DecidableEq, Option, Œ±, s, Finset, Option, Œ±, a, Option, Œ±, x, Œ±, a, Œ±, a_1, x, a, some, a, s, some, x, s] (during elaboration)

(f : StieltjesFunction) {a : ‚Ñù} {b : ‚Ñù} (hab : a < b) (A : Disjoint Set.Ioo a b {b})  : - 1 = - 1
application type mismatch
  Disjoint Set.Ioo a
argument
  a
has type
  ‚Ñù : Type
but is expected to have type
  ?m.26 ‚Üí ?m.26 ‚Üí Set ?m.26 : Type ?u.25 ; identifiers [f, StieltjesFunction, a, b, hab, a, b, A, Disjoint, Set.Ioo, a, b, b, b] (during elaboration)

{ùïú : Type u_2} {E : Type u_1} [OrderedSemiring ùïú] [AddCommGroup E] [Module ùïú E] {s : Set E} (hc : ‚àÄ (t : Set E) (a : t ‚äÜ s) , s ‚à© ‚Üë convexHull ùïú t ‚äÜ t) (t : Set {x : E // x ‚àà s}) (x : {x : E // x ‚àà s}) (h : ‚Üë x ‚àà ‚Üë convexHull ùïú Subtype.val '' t)  : (x ‚àà t) = (x ‚àà t)
type mismatch
  x
has type
  { x // x ‚àà s } : Type u_1
but is expected to have type
  ?m.1011 hc t x : Type ?u.912 ; identifiers [ùïú, u_2, E, u_1, OrderedSemiring, ùïú, AddCommGroup, E, Module, ùïú, E, s, Set, E, hc, t, Set, E, a, t, s, s, convexHull, ùïú, t, t, t, Set, x, E, x, s, x, x, E, x, s, h, x, convexHull, ùïú, Subtype.val, t, x, t, x, t] (during elaboration)

{R : Type u} {A : Type v} [CommSemiring R] [Semiring A] [Algebra R A] {s : Set A} {p : (a : A) ‚Üí Prop} {x : A} (h : x ‚àà Algebra.adjoin R s) (Hs : ‚àÄ (x : A) (a : x ‚àà s) , p x) (Halg : ‚àÄ (r : R) , p ‚Üë algebraMap R A r) (Hadd : ‚àÄ (x : A) (y : A) (a : p x) (a : p y) , p x + y) (Hmul : ‚àÄ (x : A) (y : A) (a : p x) (a : p y) , p x * y)  : ‚àÄ {a : A} {b : A} (a_1 : p a) (a_2 : p b) , p a * b
type mismatch
  algebraMap
has type
  (R : Type ?u.600) ‚Üí
    (A : Type ?u.599) ‚Üí
      [inst : CommSemiring R] ‚Üí
        [inst_1 : Semiring A] ‚Üí [inst_2 : Algebra R A] ‚Üí R ‚Üí+* A : Type (max (?u.599 + 1) (?u.600 + 1))
but is expected to have type
  A : Type v ; identifiers [R, u, A, v, CommSemiring, R, Semiring, A, Algebra, R, A, s, Set, A, p, a, A, x, A, h, x, Algebra.adjoin, R, s, Hs, x, A, a, x, s, p, x, Halg, r, R, p, algebraMap, R, A, r, Hadd, x, A, y, A, a, p, x, a, p, y, p, x, y, Hmul, x, A, y, A, a, p, x, a, p, y, p, x, y, a, A, b, A, a_1, p, a, a_2, p, b, p, a, b] (during elaboration)

(n : ‚Ñï) (b : Bool) (n : ‚Ñï) (h : n ‚â† 0) (ih : Nat.digits 2 n = List.map fun (b : Bool) ‚Ü¶ bif b then 1 else 0 Nat.bits n) (h_1 : b = false)  : false = b
type mismatch
  List.map fun b => bif b then 1 else ?m.68 b
has type
  List Bool ‚Üí List ?m.46 : Type ?u.41
but is expected to have type
  List ‚Ñï : Type ; identifiers [n, b, Bool, n, h, n, ih, Nat.digits, n, List.map, b, Bool, b, Nat.bits, n, h_1, b, false, false, b] (during elaboration)

{Œ± : Type u_1} {s : Finset Œ±} [Nonempty Œ±] (H : Finset.card s ‚â§ 1) (h : Finset.Nonempty s) (x : Œ±) (hx : x ‚àà s) (y : Œ±) (hy : y ‚àà s)  : (y ‚àà {x}) = (y ‚àà {x})
typeclass instance problem is stuck, it is often due to metavariables
  Singleton Œ± (?m.1045 H h x hx y hy) ; identifiers [Œ±, u_1, s, Finset, Œ±, Nonempty, Œ±, H, Finset.card, s, h, Finset.Nonempty, s, x, Œ±, hx, x, s, y, Œ±, hy, y, s, y, x, x, y, x, x] (during elaboration)

{R : Type u} {A : Type v} [CommSemiring R] [Semiring A] [Algebra R A] {s : Set A} {p : (a : A) ‚Üí Prop} {x : A} (h : x ‚àà Algebra.adjoin R s) (Hs : ‚àÄ (x : A) (a : x ‚àà s) , p x) (Halg : ‚àÄ (r : R) , p ‚Üë algebraMap R A r) (Hadd : ‚àÄ (x : A) (y : A) (a : p x) (a : p y) , p x + y) (Hmul : ‚àÄ (x : A) (y : A) (a : p x) (a : p y) , p x * y)  : p ‚Üë algebraMap R A 1
type mismatch
  algebraMap
has type
  (R : Type ?u.600) ‚Üí
    (A : Type ?u.599) ‚Üí
      [inst : CommSemiring R] ‚Üí
        [inst_1 : Semiring A] ‚Üí [inst_2 : Algebra R A] ‚Üí R ‚Üí+* A : Type (max (?u.599 + 1) (?u.600 + 1))
but is expected to have type
  A : Type v ; identifiers [R, u, A, v, CommSemiring, R, Semiring, A, Algebra, R, A, s, Set, A, p, a, A, x, A, h, x, Algebra.adjoin, R, s, Hs, x, A, a, x, s, p, x, Halg, r, R, p, algebraMap, R, A, r, Hadd, x, A, y, A, a, p, x, a, p, y, p, x, y, Hmul, x, A, y, A, a, p, x, a, p, y, p, x, y, p, algebraMap, R, A] (during elaboration)

 : (‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {G : CategoryTheory.Comonad C} (self : CategoryTheory.Comonad.Coalgebra G) , CategoryTheory.CategoryStruct.comp CategoryTheory.Comonad.Coalgebra.a self CategoryTheory.NatTrans.app CategoryTheory.Comonad.Œ¥ G CategoryTheory.Comonad.Coalgebra.A self = CategoryTheory.CategoryStruct.comp CategoryTheory.Comonad.Coalgebra.a self CategoryTheory.Functor.toPrefunctor CategoryTheory.Comonad.toFunctor G . map CategoryTheory.Comonad.Coalgebra.a self)
function expected at
  CategoryTheory.CategoryStruct.comp ?m.81002 ?m.160851
term has type
  ?m.424 ‚ü∂ ?m.426 ; identifiers [C, u‚ÇÅ, inst, CategoryTheory.Category, C, G, CategoryTheory.Comonad, C, self, CategoryTheory.Comonad.Coalgebra, G, CategoryTheory.CategoryStruct.comp, CategoryTheory.Comonad.Coalgebra.a, self, CategoryTheory.NatTrans.app, CategoryTheory.Comonad.Œ¥, G, CategoryTheory.Comonad.Coalgebra.A, self, CategoryTheory.CategoryStruct.comp, CategoryTheory.Comonad.Coalgebra.a, self, CategoryTheory.Functor.toPrefunctor, CategoryTheory.Comonad.toFunctor, G, map, CategoryTheory.Comonad.Coalgebra.a, self] (during elaboration)

{R : Type u} {A : Type v} [CommSemiring R] [Semiring A] [Algebra R A] {s : Set A} {p : (a : A) ‚Üí Prop} {x : A} (h : x ‚àà Algebra.adjoin R s) (Hs : ‚àÄ (x : A) (a : x ‚àà s) , p x) (Halg : ‚àÄ (r : R) , p ‚Üë algebraMap R A r) (Hadd : ‚àÄ (x : A) (y : A) (a : p x) (a : p y) , p x + y) (Hmul : ‚àÄ (x : A) (y : A) (a : p x) (a : p y) , p x * y)  : ‚àÄ {a : A} {b : A} (a_1 : p a) (a_2 : p b) , p a + b
type mismatch
  algebraMap
has type
  (R : Type ?u.600) ‚Üí
    (A : Type ?u.599) ‚Üí
      [inst : CommSemiring R] ‚Üí
        [inst_1 : Semiring A] ‚Üí [inst_2 : Algebra R A] ‚Üí R ‚Üí+* A : Type (max (?u.599 + 1) (?u.600 + 1))
but is expected to have type
  A : Type v ; identifiers [R, u, A, v, CommSemiring, R, Semiring, A, Algebra, R, A, s, Set, A, p, a, A, x, A, h, x, Algebra.adjoin, R, s, Hs, x, A, a, x, s, p, x, Halg, r, R, p, algebraMap, R, A, r, Hadd, x, A, y, A, a, p, x, a, p, y, p, x, y, Hmul, x, A, y, A, a, p, x, a, p, y, p, x, y, a, A, b, A, a_1, p, a, a_2, p, b, p, a, b] (during elaboration)

 : ‚àÄ (C : Type u‚ÇÅ) [inst : CategoryTheory.Category C] (G : CategoryTheory.Comonad C) (self : CategoryTheory.Comonad.Coalgebra G) , CategoryTheory.CategoryStruct.comp self . 2 CategoryTheory.NatTrans.app CategoryTheory.Comonad.Œ¥ G self . 1 = CategoryTheory.CategoryStruct.comp self . 2 CategoryTheory.Functor.toPrefunctor CategoryTheory.Comonad.toFunctor G . map self . 2
invalid occurrence of `¬∑` notation, it must be surrounded by parentheses (e.g. `(¬∑ + 1)`) ; identifiers [C, u‚ÇÅ, inst, CategoryTheory.Category, C, G, CategoryTheory.Comonad, C, self, CategoryTheory.Comonad.Coalgebra, G, CategoryTheory.CategoryStruct.comp, self, CategoryTheory.NatTrans.app, CategoryTheory.Comonad.Œ¥, G, self, CategoryTheory.CategoryStruct.comp, self, CategoryTheory.Functor.toPrefunctor, CategoryTheory.Comonad.toFunctor, G, map, self] (during elaboration)

{G : Type u_1} {P : Type u_2} [AddGroup G] [AddTorsor G P] (p : P)  : ({p} -·µ• {p} = {0}) = ({p} -·µ• {p} = {0})
typeclass instance problem is stuck, it is often due to metavariables
  Singleton P (?m.1960 p) ; identifiers [G, u_1, P, u_2, AddGroup, G, AddTorsor, G, P, p, P, p, p, p, p, p, p, p, p] (during elaboration)

{Œ± : Type u_1} {s : Set Œ±} [BooleanAlgebra Œ±] (hs : IsAntichain fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1 s) (x : Œ±) (ha : x ‚àà compl ‚Åª¬π' s) (x_1 : Œ±) (ha' : x_1 ‚àà compl ‚Åª¬π' s) (hne : x ‚â† x_1) (hle : fun (x : Œ±) (x_2 : Œ±) ‚Ü¶ x ‚â§ x_2 x x_1) (h : x_1 ·∂ú = x ·∂ú)  : x ·∂ú = x_1 ·∂ú
function expected at
  x_1
term has type
  Œ± ; identifiers [Œ±, u_1, s, Set, Œ±, BooleanAlgebra, Œ±, hs, IsAntichain, x, Œ±, x_1, Œ±, x, x_1, s, x, Œ±, ha, x, compl, s, x_1, Œ±, ha', x_1, compl, s, hne, x, x_1, hle, x, Œ±, x_2, Œ±, x, x_2, x, x_1, h, x_1, x, x, x_1] (during elaboration)

{Œ± : Type u_1} {s : Finset Œ±} [Nonempty Œ±] (H : Finset.card s ‚â§ 1) (h : Finset.Nonempty s) (x : Œ±) (hx : x ‚àà s) (y : Œ±) (hy : y ‚àà s)  : (x ‚àà {x}) = (x ‚àà {x})
typeclass instance problem is stuck, it is often due to metavariables
  Singleton Œ± (?m.1045 H h x hx y hy) ; identifiers [Œ±, u_1, s, Finset, Œ±, Nonempty, Œ±, H, Finset.card, s, h, Finset.Nonempty, s, x, Œ±, hx, x, s, y, Œ±, hy, y, s, x, x, x, x, x, x] (during elaboration)

{G : Type u_1} {P : Type u_2} [AddGroup G] [AddTorsor G P] (p : P)  : ({p -·µ• p} = {0}) = ({p -·µ• p} = {0})
typeclass instance problem is stuck, it is often due to metavariables
  Singleton ‚Ñï (?m.560 p) ; identifiers [G, u_1, P, u_2, AddGroup, G, AddTorsor, G, P, p, P, p, p, p, p] (during elaboration)

{G : Type u_1} {P : Type u_2} [AddGroup G] [AddTorsor G P] (p : P)  : {0} = {0}
typeclass instance problem is stuck, it is often due to metavariables
  Singleton ‚Ñï (?m.212 p) ; identifiers [G, u_1, P, u_2, AddGroup, G, AddTorsor, G, P, p, P] (during elaboration)

{R : Type u} {A : Type v} [CommSemiring R] [Semiring A] [Algebra R A] {s : Set A} {p : (a : A) ‚Üí Prop} {x : A} (h : x ‚àà Algebra.adjoin R s) (Hs : ‚àÄ (x : A) (a : x ‚àà s) , p x) (Halg : ‚àÄ (r : R) , p ‚Üë algebraMap R A r) (Hadd : ‚àÄ (x : A) (y : A) (a : p x) (a : p y) , p x + y) (Hmul : ‚àÄ (x : A) (y : A) (a : p x) (a : p y) , p x * y)  : p ‚Üë algebraMap R A 0
type mismatch
  algebraMap
has type
  (R : Type ?u.600) ‚Üí
    (A : Type ?u.599) ‚Üí
      [inst : CommSemiring R] ‚Üí
        [inst_1 : Semiring A] ‚Üí [inst_2 : Algebra R A] ‚Üí R ‚Üí+* A : Type (max (?u.599 + 1) (?u.600 + 1))
but is expected to have type
  A : Type v ; identifiers [R, u, A, v, CommSemiring, R, Semiring, A, Algebra, R, A, s, Set, A, p, a, A, x, A, h, x, Algebra.adjoin, R, s, Hs, x, A, a, x, s, p, x, Halg, r, R, p, algebraMap, R, A, r, Hadd, x, A, y, A, a, p, x, a, p, y, p, x, y, Hmul, x, A, y, A, a, p, x, a, p, y, p, x, y, p, algebraMap, R, A] (during elaboration)

{E : Type u} [NormedAddCommGroup E] [NormedSpace ‚ÑÇ E] {f : (a : E) ‚Üí ‚ÑÇ} {c : E} (hf : ‚àÄ·∂† (z : E) in nhds c , DifferentiableAt ‚ÑÇ f z) (hc : IsLocalMin norm ‚àò f c) (h : ¬¨ (f c = 0 : Prop)) (h1 : ‚àÄ·∂† (z : E) in nhds c , f z ‚â† 0) (h2 : IsLocalMax norm ‚àò f ‚Åª¬π c)  : (‚àÄ (a : E) , True) = True
type expected, got
  (IsLocalMin norm ‚àò ?m.80670 : ?m.824 ‚Üí Prop) ; identifiers [E, u, NormedAddCommGroup, E, NormedSpace, E, f, a, E, c, E, hf, z, E, nhds, c, DifferentiableAt, f, z, hc, IsLocalMin, norm, f, c, h, f, c, h1, z, E, nhds, c, f, z, h2, IsLocalMax, norm, f, c, a, E, True, True] (during elaboration)

{cells : Finset ‚Ñï √ó ‚Ñï} {isLowerSet : IsLowerSet ‚Üë cells} {cells_1 : Finset ‚Ñï √ó ‚Ñï} {isLowerSet_1 : IsLowerSet ‚Üë cells_1} (x : {cells := ((cells)) , isLowerSet := ((isLowerSet))} = {cells := ((cells_1)) , isLowerSet := ((isLowerSet_1))})  : ‚àÄ (cells_eq : cells = cells_1) , cells = cells_1
type mismatch
  cells_1
has type
  Finset ‚Ñï √ó ‚Ñï : Type
but is expected to have type
  Set ?m.833 : Type ; identifiers [cells, Finset, isLowerSet, IsLowerSet, cells, cells_1, Finset, isLowerSet_1, IsLowerSet, cells_1, x, cells, cells, isLowerSet, isLowerSet, cells, cells_1, isLowerSet, isLowerSet_1, cells_eq, cells, cells_1, cells, cells_1] (during elaboration)

 : (‚àÄ {ùïú : Type u_1} {E : Type u_2} {Œπ : Type u_3} [inst : NormedField ùïú] [inst_1 : AddCommGroup E] [inst_2 : Module ùïú E] [inst_3 : Nonempty Œπ] {p : SeminormFamily ùïú E Œπ} [topology : TopologicalSpace E] (self : WithSeminorms p) , topology = ModuleFilterBasis.topology SeminormFamily.moduleFilterBasis p)
function expected at
  ModuleFilterBasis.topology ?m.83532
term has type
  TopologicalSpace ?m.1801 ; identifiers [ùïú, u_1, E, u_2, Œπ, u_3, inst, NormedField, ùïú, inst_1, AddCommGroup, E, inst_2, Module, ùïú, E, inst_3, Nonempty, Œπ, p, SeminormFamily, ùïú, E, Œπ, topology, TopologicalSpace, E, self, WithSeminorms, p, topology, ModuleFilterBasis.topology, SeminormFamily.moduleFilterBasis, p] (during elaboration)

 : ‚àÄ (ùïú : Type u_1) (E : Type u_2) (Œπ : Type u_3) [inst : NormedField ùïú] [inst_1 : AddCommGroup E] [inst_2 : Module ùïú E] [inst_3 : Nonempty Œπ] (p : SeminormFamily ùïú E Œπ) [topology : TopologicalSpace E] (self : WithSeminorms p) , topology = ModuleFilterBasis.topology SeminormFamily.moduleFilterBasis p
function expected at
  ModuleFilterBasis.topology ?m.83532
term has type
  TopologicalSpace ?m.1801 ; identifiers [ùïú, u_1, E, u_2, Œπ, u_3, inst, NormedField, ùïú, inst_1, AddCommGroup, E, inst_2, Module, ùïú, E, inst_3, Nonempty, Œπ, p, SeminormFamily, ùïú, E, Œπ, topology, TopologicalSpace, E, self, WithSeminorms, p, topology, ModuleFilterBasis.topology, SeminormFamily.moduleFilterBasis, p] (during elaboration)

{Œ± : Type u_1} [Group Œ±] [IsCyclic Œ±] (x : Œ±) (y : Œ±) (w : Œ±) (hg_1 : ‚àÄ (x : Œ±) , x ‚àà Subgroup.zpowers w) (w_1 : ‚Ñ§) (hn : fun (x : Œ±) (x_1 : ‚Ñ§) ‚Ü¶ x ^ x_1 w w_1 = x)  : y ‚àà Subgroup.zpowers w
function expected at
  x_1
term has type
  ‚Ñ§ ; identifiers [Œ±, u_1, Group, Œ±, IsCyclic, Œ±, x, Œ±, y, Œ±, w, Œ±, hg_1, x, Œ±, x, Subgroup.zpowers, w, w_1, hn, x, Œ±, x_1, x, x_1, w, w_1, x, y, Subgroup.zpowers, w] (during elaboration)

{s : Set ‚Ñï} {m : ‚Ñï} (hm : m < sInf s) (h : s = ‚àÖ) (h_1 : (Set.eq_empty_or_nonempty s =: (s = ‚àÖ : Prop) ‚à® (Set.Nonempty s : Prop)) = (Or.inl h =: (s = ‚àÖ : Prop) ‚à® (Set.Nonempty s : Prop)))  : Or.inl h = Set.eq_empty_or_nonempty s
<input>:1:86: expected term

{s : Set ‚Ñï} {m : ‚Ñï} (hm : m < sInf s) (h : s = ‚àÖ) (h_1 : (Set.eq_empty_or_nonempty s =: (s = ‚àÖ : Prop) ‚à® (Set.Nonempty s : Prop)) = (Or.inl h =: (s = ‚àÖ : Prop) ‚à® (Set.Nonempty s : Prop)))  : ‚àÖ = s
<input>:1:86: expected term

{s : Set ‚Ñï} {m : ‚Ñï} (hm : m < sInf s) (h : Set.Nonempty s) (h_1 : (Set.eq_empty_or_nonempty s =: (s = ‚àÖ : Prop) ‚à® (Set.Nonempty s : Prop)) = (Or.inr h =: (s = ‚àÖ : Prop) ‚à® (Set.Nonempty s : Prop)))  : Or.inr h = Set.eq_empty_or_nonempty s
<input>:1:95: expected term

 : (‚àÄ {Œ± : Type u_1} {p : (a : Œ± ·µí·µà) ‚Üí Prop} , (‚àÉ (a : Œ± ·µí·µà) , p a : Prop) ‚Üî (‚àÉ (a : Œ±) , p ‚Üë OrderDual.toDual a : Prop))
type mismatch
  OrderDual.toDual
has type
  ?m.26 ‚âÉ ?m.26·µí·µà : Type u_1
but is expected to have type
  Œ±·µí·µà : Type u_1 ; identifiers [Œ±, u_1, p, a, Œ±, a, Œ±, p, a, a, Œ±, p, OrderDual.toDual, a] (during elaboration)

(f : StieltjesFunction) {a : ‚Ñù} {b : ‚Ñù} (hab : a < b) (A : Disjoint Set.Ioo a b {b})  : 1 = 1
application type mismatch
  Disjoint Set.Ioo a
argument
  a
has type
  ‚Ñù : Type
but is expected to have type
  ?m.26 ‚Üí ?m.26 ‚Üí Set ?m.26 : Type ?u.25 ; identifiers [f, StieltjesFunction, a, b, hab, a, b, A, Disjoint, Set.Ioo, a, b, b, b] (during elaboration)

(f : StieltjesFunction) {a : ‚Ñù} {b : ‚Ñù} (hab : a < b) (A : Disjoint Set.Ioo a b {b})  : 0 = 0
application type mismatch
  Disjoint Set.Ioo a
argument
  a
has type
  ‚Ñù : Type
but is expected to have type
  ?m.26 ‚Üí ?m.26 ‚Üí Set ?m.26 : Type ?u.25 ; identifiers [f, StieltjesFunction, a, b, hab, a, b, A, Disjoint, Set.Ioo, a, b, b, b] (during elaboration)

{Œ± : Type u_1} {m0 : MeasurableSpace Œ±} {Œπ : Type u_2} [Finite Œπ] (Œº : (a : Œπ) ‚Üí MeasureTheory.Measure Œ±) [‚àÄ (i : Œπ) , MeasureTheory.SigmaFinite Œº i] (val : Fintype Œπ) (h : (nonempty_fintype Œπ =: Nonempty Fintype Œπ) = (Nonempty.intro val =: Nonempty Fintype Œπ))  : Nonempty.intro val = nonempty_fintype Œπ
<input>:1:194: expected term

{Œπ : Type u_1} {Œ± : (a : Œπ) ‚Üí Type u_2} [Fintype Œπ] {m : (i : Œπ) ‚Üí MeasureTheory.OuterMeasure Œ± i} {s : Set (i : Œπ) ‚Üí Œ± i} (i : Œπ)  : ‚àÄ (a : (x : Œπ) ‚Üí Œ± x) (a_1 : a ‚àà s) , a i = a i
application type mismatch
  MeasureTheory.OuterMeasure Œ±
argument
  Œ±
has type
  Œπ ‚Üí Type u_2 : Type (max u_1 (u_2 + 1))
but is expected to have type
  Type ?u.19 : Type (?u.19 + 1) ; identifiers [Œπ, u_1, Œ±, a, Œπ, u_2, Fintype, Œπ, m, i, Œπ, MeasureTheory.OuterMeasure, Œ±, i, s, Set, i, Œπ, Œ±, i, i, Œπ, a, x, Œπ, Œ±, x, a_1, a, s, a, i, a, i] (during elaboration)

(n : ‚Ñï) (b : Bool) (n : ‚Ñï) (h : n ‚â† 0) (ih : Nat.digits 2 n = List.map fun (b : Bool) ‚Ü¶ bif b then 1 else 0 Nat.bits n) (h : b = true)  : true = b
type mismatch
  List.map fun b => bif b then 1 else ?m.68 b
has type
  List Bool ‚Üí List ?m.46 : Type ?u.41
but is expected to have type
  List ‚Ñï : Type ; identifiers [n, b, Bool, n, h, n, ih, Nat.digits, n, List.map, b, Bool, b, Nat.bits, n, h, b, true, true, b] (during elaboration)

(p : Prop) U : (x : Prop) ‚Üí Prop := fun (x : Prop) ‚Ü¶ ((x : Prop) = (True : Prop) : Prop) ‚à® (p : Prop) V : (x : Prop) ‚Üí Prop := fun (x : Prop) ‚Ü¶ ((x : Prop) = (False : Prop) : Prop) ‚à® (p : Prop) (exU : ‚àÉ (x : Prop) , U (x : Prop)) (exV : ‚àÉ (x : Prop) , V (x : Prop)) u : Prop := (Classical.choose exU : Prop) v : Prop := (Classical.choose exV : Prop) (u_def : U (u : Prop)) (v_def : V (v : Prop)) (not_uv_or_p : ((u : Prop) ‚â† (v : Prop) : Prop) ‚à® (p : Prop)) (hp : p) (hpred : U = V) (h‚ÇÄ : ‚àÄ (exU : ‚àÉ (x : Prop) , U (x : Prop)) (exV : ‚àÉ (x : Prop) , V (x : Prop)) , (Classical.choose exU : Prop) = (Classical.choose exV : Prop))  : u = v
<input>:1:13: expected end of input

(p : Prop) U : (x : Prop) ‚Üí Prop := fun (x : Prop) ‚Ü¶ ((x : Prop) = (True : Prop) : Prop) ‚à® (p : Prop) V : (x : Prop) ‚Üí Prop := fun (x : Prop) ‚Ü¶ ((x : Prop) = (False : Prop) : Prop) ‚à® (p : Prop) (exU : ‚àÉ (x : Prop) , U (x : Prop)) (exV : ‚àÉ (x : Prop) , V (x : Prop)) u : Prop := (Classical.choose exU : Prop) v : Prop := (Classical.choose exV : Prop) (u_def : U (u : Prop)) (v_def : V (v : Prop)) (not_uv_or_p : ((u : Prop) ‚â† (v : Prop) : Prop) ‚à® (p : Prop)) (hp : p) (hpred : U = V) (h‚ÇÄ : ‚àÄ (exU : ‚àÉ (x : Prop) , U (x : Prop)) (exV : ‚àÉ (x : Prop) , V (x : Prop)) , (Classical.choose exU : Prop) = (Classical.choose exV : Prop))  : (Classical.choose exU) = (Classical.choose exV)
<input>:1:13: expected end of input

{Œ± : Type u_1} [Fintype Œ±] [DecidableEq Œ±] {l : List Equiv.Perm Œ±} (hl : ‚àÄ (g : Equiv.Perm Œ±) (a : g ‚àà l) , Equiv.Perm.IsSwap g)  : (Even List.length l) ‚Üî (Even List.length l)
application type mismatch
  List Equiv.Perm
argument
  Equiv.Perm
has type
  Sort ?u.21 ‚Üí Sort (max 1 ?u.21) : Type (max 1 ?u.21)
but is expected to have type
  Type ?u.20 : Type (?u.20 + 1) ; identifiers [Œ±, u_1, Fintype, Œ±, DecidableEq, Œ±, l, List, Equiv.Perm, Œ±, hl, g, Equiv.Perm, Œ±, a, g, l, Equiv.Perm.IsSwap, g, Even, List.length, l, Even, List.length, l] (during elaboration)

(C : Type u_1) [CategoryTheory.Category C] [CategoryTheory.Precoherent C] (P : CategoryTheory.Functor C ·µí·µñ Type w) (h : ‚àÄ (B : C) (Œ± : Type) [inst_2 : Fintype Œ±] (X : (a : Œ±) ‚Üí C) (œÄ : (a : Œ±) ‚Üí X a ‚ü∂ B) (a : CategoryTheory.EffectiveEpiFamily X œÄ) , CategoryTheory.Presieve.IsSheafFor P CategoryTheory.Presieve.ofArrows X œÄ) {B : C} (S : CategoryTheory.Presieve B) (a : S ‚àà CategoryTheory.Coverage.covering CategoryTheory.coherentCoverage C B) (Œ± : Type) (h_1 : ‚àÉ (x : Fintype Œ±) , ‚àÉ (X : (a : Œ±) ‚Üí C) , ‚àÉ (œÄ : (a : Œ±) ‚Üí X a ‚ü∂ B) , (S = CategoryTheory.Presieve.ofArrows X œÄ : Prop) ‚àß (CategoryTheory.EffectiveEpiFamily X œÄ : Prop)) (w : Fintype Œ±) (h_2 : ‚àÉ (X : (a : Œ±) ‚Üí C) , ‚àÉ (œÄ : (a : Œ±) ‚Üí X a ‚ü∂ B) , (S = CategoryTheory.Presieve.ofArrows X œÄ : Prop) ‚àß (CategoryTheory.EffectiveEpiFamily X œÄ : Prop)) (X : (a : Œ±) ‚Üí C) (h_3 : ‚àÉ (œÄ : (a : Œ±) ‚Üí X a ‚ü∂ B) , (S = CategoryTheory.Presieve.ofArrows X œÄ : Prop) ‚àß (CategoryTheory.EffectiveEpiFamily X œÄ : Prop)) (œÄ : (a : Œ±) ‚Üí X a ‚ü∂ B) (h_4 : (S = CategoryTheory.Presieve.ofArrows X œÄ : Prop) ‚àß (CategoryTheory.EffectiveEpiFamily X œÄ : Prop)) (left : S = CategoryTheory.Presieve.ofArrows X œÄ) (hS : CategoryTheory.EffectiveEpiFamily X œÄ)  : CategoryTheory.Presieve.ofArrows X œÄ = S
function expected at
  CategoryTheory.Functor C·µí·µñ Type
term has type
  Type (max ?u.7 u_1 1) ; identifiers [C, u_1, CategoryTheory.Category, C, CategoryTheory.Precoherent, C, P, CategoryTheory.Functor, C, w, h, B, C, Œ±, inst_2, Fintype, Œ±, X, a, Œ±, C, œÄ, a, Œ±, X, a, B, a, CategoryTheory.EffectiveEpiFamily, X, œÄ, CategoryTheory.Presieve.IsSheafFor, P, CategoryTheory.Presieve.ofArrows, X, œÄ, B, C, S, CategoryTheory.Presieve, B, a, S, CategoryTheory.Coverage.covering, CategoryTheory.coherentCoverage, C, B, Œ±, h_1, x, Fintype, Œ±, X, a, Œ±, C, œÄ, a, Œ±, X, a, B, S, CategoryTheory.Presieve.ofArrows, X, œÄ, CategoryTheory.EffectiveEpiFamily, X, œÄ, w, Fintype, Œ±, h_2, X, a, Œ±, C, œÄ, a, Œ±, X, a, B, S, CategoryTheory.Presieve.ofArrows, X, œÄ, CategoryTheory.EffectiveEpiFamily, X, œÄ, X, a, Œ±, C, h_3, œÄ, a, Œ±, X, a, B, S, CategoryTheory.Presieve.ofArrows, X, œÄ, CategoryTheory.EffectiveEpiFamily, X, œÄ, œÄ, a, Œ±, X, a, B, h_4, S, CategoryTheory.Presieve.ofArrows, X, œÄ, CategoryTheory.EffectiveEpiFamily, X, œÄ, left, S, CategoryTheory.Presieve.ofArrows, X, œÄ, hS, CategoryTheory.EffectiveEpiFamily, X, œÄ, CategoryTheory.Presieve.ofArrows, X, œÄ, S] (during elaboration)

(C : Type u_1) [CategoryTheory.Category C] [CategoryTheory.Precoherent C] (P : CategoryTheory.Functor C ·µí·µñ Type w) (h : ‚àÄ (B : C) (Œ± : Type) [inst_2 : Fintype Œ±] (X : (a : Œ±) ‚Üí C) (œÄ : (a : Œ±) ‚Üí X a ‚ü∂ B) (a : CategoryTheory.EffectiveEpiFamily X œÄ) , CategoryTheory.Presieve.IsSheafFor P CategoryTheory.Presieve.ofArrows X œÄ) {B : C} (S : CategoryTheory.Presieve B) (a : S ‚àà CategoryTheory.Coverage.covering CategoryTheory.coherentCoverage C B) (Œ± : Type) (h_1 : ‚àÉ (x : Fintype Œ±) , ‚àÉ (X : (a : Œ±) ‚Üí C) , ‚àÉ (œÄ : (a : Œ±) ‚Üí X a ‚ü∂ B) , (S = CategoryTheory.Presieve.ofArrows X œÄ : Prop) ‚àß (CategoryTheory.EffectiveEpiFamily X œÄ : Prop)) (w : Fintype Œ±) (h_2 : ‚àÉ (X : (a : Œ±) ‚Üí C) , ‚àÉ (œÄ : (a : Œ±) ‚Üí X a ‚ü∂ B) , (S = CategoryTheory.Presieve.ofArrows X œÄ : Prop) ‚àß (CategoryTheory.EffectiveEpiFamily X œÄ : Prop)) (X : (a : Œ±) ‚Üí C) (h_3 : ‚àÉ (œÄ : (a : Œ±) ‚Üí X a ‚ü∂ B) , (S = CategoryTheory.Presieve.ofArrows X œÄ : Prop) ‚àß (CategoryTheory.EffectiveEpiFamily X œÄ : Prop)) (œÄ : (a : Œ±) ‚Üí X a ‚ü∂ B) (h_4 : (S = CategoryTheory.Presieve.ofArrows X œÄ : Prop) ‚àß (CategoryTheory.EffectiveEpiFamily X œÄ : Prop)) (left : S = CategoryTheory.Presieve.ofArrows X œÄ) (hS : CategoryTheory.EffectiveEpiFamily X œÄ)  : CategoryTheory.Presieve.IsSheafFor P CategoryTheory.Presieve.ofArrows X œÄ
function expected at
  CategoryTheory.Functor C·µí·µñ Type
term has type
  Type (max ?u.7 u_1 1) ; identifiers [C, u_1, CategoryTheory.Category, C, CategoryTheory.Precoherent, C, P, CategoryTheory.Functor, C, w, h, B, C, Œ±, inst_2, Fintype, Œ±, X, a, Œ±, C, œÄ, a, Œ±, X, a, B, a, CategoryTheory.EffectiveEpiFamily, X, œÄ, CategoryTheory.Presieve.IsSheafFor, P, CategoryTheory.Presieve.ofArrows, X, œÄ, B, C, S, CategoryTheory.Presieve, B, a, S, CategoryTheory.Coverage.covering, CategoryTheory.coherentCoverage, C, B, Œ±, h_1, x, Fintype, Œ±, X, a, Œ±, C, œÄ, a, Œ±, X, a, B, S, CategoryTheory.Presieve.ofArrows, X, œÄ, CategoryTheory.EffectiveEpiFamily, X, œÄ, w, Fintype, Œ±, h_2, X, a, Œ±, C, œÄ, a, Œ±, X, a, B, S, CategoryTheory.Presieve.ofArrows, X, œÄ, CategoryTheory.EffectiveEpiFamily, X, œÄ, X, a, Œ±, C, h_3, œÄ, a, Œ±, X, a, B, S, CategoryTheory.Presieve.ofArrows, X, œÄ, CategoryTheory.EffectiveEpiFamily, X, œÄ, œÄ, a, Œ±, X, a, B, h_4, S, CategoryTheory.Presieve.ofArrows, X, œÄ, CategoryTheory.EffectiveEpiFamily, X, œÄ, left, S, CategoryTheory.Presieve.ofArrows, X, œÄ, hS, CategoryTheory.EffectiveEpiFamily, X, œÄ, CategoryTheory.Presieve.IsSheafFor, P, CategoryTheory.Presieve.ofArrows, X, œÄ] (during elaboration)

{X : Type u_1} (R : Type u_2) [TopologicalSpace X] [Semiring R] [TopologicalSpace R] [TopologicalSemiring R] (s : Set X) (c : C(X , R)) (f : C(X , R)) (hf : f ‚àà AddSubsemigroup.carrier AddSubmonoid.toAddSubsemigroup {toAddSubsemigroup := (({carrier := (({f : C(X , R) | ‚àÄ (x : X) (a : x ‚àà s ·∂ú) , ‚Üë f x = 0})) , add_mem' := (((fun {f : C(X , R)} {g : C(X , R)} (hf : f ‚àà {f : C(X , R) | ‚àÄ (x : X) (a : x ‚àà s ·∂ú) , ‚Üë f x = 0}) (hg : g ‚àà {f : C(X , R) | ‚àÄ (x : X) (a : x ‚àà s ·∂ú) , ‚Üë f x = 0}) (x : X) (hx : x ‚àà s ·∂ú) ‚Ü¶ of_eq_true (Eq.trans (congrFun (congrArg Eq (Eq.trans (congr (congrArg HAdd.hAdd (hf x hx =: ‚Üë f x = 0) =: HAdd.hAdd ‚Üë f x = HAdd.hAdd 0) (hg x hx =: ‚Üë g x = 0) =: ‚Üë f x + ‚Üë g x = 0 + 0) (add_zero 0 =: 0 + 0 = 0) =: ‚Üë f x + ‚Üë g x = 0) =: Eq ‚Üë f x + ‚Üë g x = Eq 0) 0 =: (‚Üë f x + ‚Üë g x = 0 : Prop) = (0 = 0 : Prop)) (eq_self 0 =: (0 = 0 : Prop) = (True : Prop)) =: (‚Üë f x + ‚Üë g x = 0 : Prop) = (True : Prop)) =: ‚àÄ {f : C(X , R)} {g : C(X , R)} (hf : f ‚àà {f : C(X , R) | ‚àÄ (x : X) (a : x ‚àà s ·∂ú) , ‚Üë f x = 0}) (hg : g ‚àà {f : C(X , R) | ‚àÄ (x : X) (a : x ‚àà s ·∂ú) , ‚Üë f x = 0}) (x : X) (hx : x ‚àà s ·∂ú) , ‚Üë f x + ‚Üë g x = 0)))})) , zero_mem' := (((fun (x : X) (x_1 : x ‚àà s ·∂ú) ‚Ü¶ rfl =: ‚àÄ (x : X) (x_1 : x ‚àà s ·∂ú) , ‚Üë 0 x = ‚Üë 0 x)))}) (x : X) (hx : x ‚àà s ·∂ú)  : ‚Üë f x = 0
<input>:1:604: expected term

{Œ± : Type u_1} [Ring Œ±] {a : Œ±} [LinearOrder Œ±] (h : | a | = a) (h_1 : (abs_choice a =: (| a | = a : Prop) ‚à® (| a | = - a : Prop)) = (Or.inl h =: (| a | = a : Prop) ‚à® (| a | = - a : Prop)))  : Or.inl h = abs_choice a
<input>:1:53: expected ')' or no space before

{Œ± : Type u_1} [Ring Œ±] {a : Œ±} [LinearOrder Œ±] (h : | a | = - a) (h_1 : (abs_choice a =: (| a | = a : Prop) ‚à® (| a | = - a : Prop)) = (Or.inr h =: (| a | = a : Prop) ‚à® (| a | = - a : Prop)))  : Or.inr h = abs_choice a
<input>:1:53: expected ')' or no space before

{f : (a : ‚Ñù) ‚Üí ‚Ñù} {f' : (a : ‚Ñù) ‚Üí ‚Ñù} {a : ‚Ñù} {b : ‚Ñù} {l : ‚Ñù} (hab : a < b) (hfa : Filter.Tendsto f nhdsWithin a Set.Ioi a nhds l) (hfb : Filter.Tendsto f nhdsWithin b Set.Iio b nhds l) (hff' : ‚àÄ (x : ‚Ñù) (a : x ‚àà Set.Ioo a b) , HasDerivAt f f' x x) (this : ContinuousOn f Set.Ioo a b) (hcont : ContinuousOn extendFrom Set.Ioo a b f Set.Icc a b) (c : ‚Ñù) (h : (c ‚àà Set.Ioo a b : Prop) ‚àß (IsLocalExtr extendFrom Set.Ioo a b f c : Prop)) (hc : c ‚àà Set.Ioo a b) (hcextr : IsLocalExtr extendFrom Set.Ioo a b f c)  : HasDerivAt f f' c c
application type mismatch
  Filter.Tendsto f nhdsWithin
argument
  nhdsWithin
has type
  ?m.41 ‚Üí Set ?m.41 ‚Üí Filter ?m.41 : Type ?u.40
but is expected to have type
  Filter ‚Ñù : Type ; identifiers [f, a, f', a, a, b, l, hab, a, b, hfa, Filter.Tendsto, f, nhdsWithin, a, Set.Ioi, a, nhds, l, hfb, Filter.Tendsto, f, nhdsWithin, b, Set.Iio, b, nhds, l, hff', x, a, x, Set.Ioo, a, b, HasDerivAt, f, f', x, x, this, ContinuousOn, f, Set.Ioo, a, b, hcont, ContinuousOn, extendFrom, Set.Ioo, a, b, f, Set.Icc, a, b, c, h, c, Set.Ioo, a, b, IsLocalExtr, extendFrom, Set.Ioo, a, b, f, c, hc, c, Set.Ioo, a, b, hcextr, IsLocalExtr, extendFrom, Set.Ioo, a, b, f, c, HasDerivAt, f, f', c, c] (during elaboration)

{Œ± : Type u_1} {m0 : MeasurableSpace Œ±} {Œπ : Type u_2} [Finite Œπ] (Œº : (a : Œπ) ‚Üí MeasureTheory.Measure Œ±) [‚àÄ (i : Œπ) , MeasureTheory.SigmaFinite Œº i] (val : Fintype Œπ) (h : (nonempty_fintype Œπ =: Nonempty Fintype Œπ) = (Nonempty.intro val =: Nonempty Fintype Œπ)) (this : ‚àÄ (n : ‚Ñï) , MeasurableSet ‚ãÇ (i : Œπ) , MeasureTheory.spanningSets Œº i n) (n : ‚Ñï)  : MeasurableSet ‚ãÇ (i : Œπ) , MeasureTheory.spanningSets Œº i n
<input>:1:194: expected term

{R : Type u} {I : Type v} [CommSemiring R] {z : R} {s : (a : I) ‚Üí R} {t : Finset I} ‚¶É a : I ‚¶Ñ {r : Finset I} (har : ¬¨ (a ‚àà r : Prop)) (ih : ‚àÄ (x : Set.Pairwise ‚Üë r IsCoprime on s) (x : ‚àÄ (i : I) (a : i ‚àà r) , s i ‚à£ z) , Finset.prod r fun (x : I) ‚Ü¶ s x ‚à£ z) (Hs : Set.Pairwise ‚Üë insert a r IsCoprime on s) (Hs1 : ‚àÄ (i : I) (a : i ‚àà insert a r) , s i ‚à£ z) (aux1 : a ‚àà ‚Üë insert a r) (i : I) (hir : i ‚àà r) (a_1 : a = i)  : ‚àÄ (hir : a ‚àà r) , False
type expected, got
  (?m.79502 on s : I ‚Üí I ‚Üí ?m.60) ; identifiers [R, u, I, v, CommSemiring, R, z, R, s, a, I, R, t, Finset, I, a, I, r, Finset, I, har, a, r, ih, x, Set.Pairwise, r, IsCoprime, s, x, i, I, a, i, r, s, i, z, Finset.prod, r, x, I, s, x, z, Hs, Set.Pairwise, insert, a, r, IsCoprime, s, Hs1, i, I, a, i, insert, a, r, s, i, z, aux1, a, insert, a, r, i, I, hir, i, r, a_1, a, i, hir, a, r, False] (during elaboration)

{R : Type u} {I : Type v} [CommSemiring R] {z : R} {s : (a : I) ‚Üí R} {t : Finset I} ‚¶É a : I ‚¶Ñ {r : Finset I} (har : ¬¨ (a ‚àà r : Prop)) (ih : ‚àÄ (x : Set.Pairwise ‚Üë r IsCoprime on s) (x : ‚àÄ (i : I) (a : i ‚àà r) , s i ‚à£ z) , Finset.prod r fun (x : I) ‚Ü¶ s x ‚à£ z) (Hs : Set.Pairwise ‚Üë insert a r IsCoprime on s) (Hs1 : ‚àÄ (i : I) (a : i ‚àà insert a r) , s i ‚à£ z) (aux1 : a ‚àà ‚Üë insert a r)  : s a ‚à£ z
type expected, got
  (?m.79502 on s : I ‚Üí I ‚Üí ?m.60) ; identifiers [R, u, I, v, CommSemiring, R, z, R, s, a, I, R, t, Finset, I, a, I, r, Finset, I, har, a, r, ih, x, Set.Pairwise, r, IsCoprime, s, x, i, I, a, i, r, s, i, z, Finset.prod, r, x, I, s, x, z, Hs, Set.Pairwise, insert, a, r, IsCoprime, s, Hs1, i, I, a, i, insert, a, r, s, i, z, aux1, a, insert, a, r, s, a, z] (during elaboration)

{f : (a : ‚Ñù) ‚Üí ‚Ñù} {f' : (a : ‚Ñù) ‚Üí ‚Ñù} {a : ‚Ñù} {b : ‚Ñù} {l : ‚Ñù} (hab : a < b) (hfa : Filter.Tendsto f nhdsWithin a Set.Ioi a nhds l) (hfb : Filter.Tendsto f nhdsWithin b Set.Iio b nhds l) (hff' : ‚àÄ (x : ‚Ñù) (a : x ‚àà Set.Ioo a b) , HasDerivAt f f' x x) (x : ‚Ñù) (hx : x ‚àà Set.Ioo a b)  : HasDerivAt f f' x x
application type mismatch
  Filter.Tendsto f nhdsWithin
argument
  nhdsWithin
has type
  ?m.41 ‚Üí Set ?m.41 ‚Üí Filter ?m.41 : Type ?u.40
but is expected to have type
  Filter ‚Ñù : Type ; identifiers [f, a, f', a, a, b, l, hab, a, b, hfa, Filter.Tendsto, f, nhdsWithin, a, Set.Ioi, a, nhds, l, hfb, Filter.Tendsto, f, nhdsWithin, b, Set.Iio, b, nhds, l, hff', x, a, x, Set.Ioo, a, b, HasDerivAt, f, f', x, x, x, hx, x, Set.Ioo, a, b, HasDerivAt, f, f', x, x] (during elaboration)

(n : ‚Ñï) (b : Bool) (n : ‚Ñï) (h : n ‚â† 0) (ih : Nat.digits 2 n = List.map fun (b : Bool) ‚Ü¶ bif b then 1 else 0 Nat.bits n)  : b = b
type mismatch
  List.map fun b => bif b then 1 else ?m.68 b
has type
  List Bool ‚Üí List ?m.46 : Type ?u.41
but is expected to have type
  List ‚Ñï : Type ; identifiers [n, b, Bool, n, h, n, ih, Nat.digits, n, List.map, b, Bool, b, Nat.bits, n, b, b] (during elaboration)

{G : Type u_1} [AddGroup G] {H : AddSubgroup G} [Finite G ‚ß∏ H] (val : Fintype G ‚ß∏ H) (h : (nonempty_fintype G ‚ß∏ H =: Nonempty Fintype G ‚ß∏ H) = (Nonempty.intro val =: Nonempty Fintype G ‚ß∏ H))  : Nonempty.intro val = nonempty_fintype G ‚ß∏ H
<input>:1:115: expected term

{M : Type u_1} {inst : CommMonoidWithZero M} {S : Submonoid M} {N : Type u_2} {inst_1 : CommMonoidWithZero N} {toLocalizationMap : Submonoid.LocalizationMap S N} {map_zero' : OneHom.toFun ‚Üë Submonoid.LocalizationMap.toMonoidHom toLocalizationMap 0 = 0} {toLocalizationMap_1 : Submonoid.LocalizationMap S N} {map_zero'_1 : OneHom.toFun ‚Üë Submonoid.LocalizationMap.toMonoidHom toLocalizationMap_1 0 = 0} (x : {toLocalizationMap := ((toLocalizationMap)) , map_zero' := ((map_zero'))} = {toLocalizationMap := ((toLocalizationMap_1)) , map_zero' := ((map_zero'_1))})  : ‚àÄ (toLocalizationMap_eq : toLocalizationMap = toLocalizationMap_1) , toLocalizationMap = toLocalizationMap_1
function expected at
  OneHom.toFun ?m.1615 toLocalizationMap
term has type
  ?m.1054 ; identifiers [M, u_1, inst, CommMonoidWithZero, M, S, Submonoid, M, N, u_2, inst_1, CommMonoidWithZero, N, toLocalizationMap, Submonoid.LocalizationMap, S, N, map_zero', OneHom.toFun, Submonoid.LocalizationMap.toMonoidHom, toLocalizationMap, toLocalizationMap_1, Submonoid.LocalizationMap, S, N, map_zero'_1, OneHom.toFun, Submonoid.LocalizationMap.toMonoidHom, toLocalizationMap_1, x, toLocalizationMap, toLocalizationMap, map_zero', map_zero', toLocalizationMap, toLocalizationMap_1, map_zero', map_zero'_1, toLocalizationMap_eq, toLocalizationMap, toLocalizationMap_1, toLocalizationMap, toLocalizationMap_1] (during elaboration)

{H : Type u_1} [TopologicalSpace H] {Œ± : Type u_2} [TopologicalSpace Œ±] (e : LocalHomeomorph Œ± H) (x : Œ±) em : (a : Prop) ‚Üí Decidable (a : Prop) := Classical.propDecidable  : fun (x : Œ±) ‚Ü¶ e x = fun (x : Œ±) ‚Ü¶ e x
<input>:1:109: expected end of input

{Œ± : Type u} {Œ≤ : Type v} (as : List Œ±) (bs : List Œ≤) (head : Œ±) (tail : List Œ±) (tail_ih : ‚àÄ (bs : List Œ≤) , List.zipRight tail bs = Prod.fst List.zipRight' tail bs) (bs : List Œ≤) (h : bs = [])  : [] = bs
function expected at
  ?m.185.fst
term has type
  ?m.39 ; identifiers [Œ±, u, Œ≤, v, as, List, Œ±, bs, List, Œ≤, head, Œ±, tail, List, Œ±, tail_ih, bs, List, Œ≤, List.zipRight, tail, bs, Prod.fst, List.zipRight', tail, bs, bs, List, Œ≤, h, bs, bs] (during elaboration)

{Œ± : Type u_4} {Œ≤ : Type u_1} {Œπ : Type u_2} {Œ∫ : Type u_3} [VAdd Œ± Œ≤] (b : (a : Œπ) ‚Üí Œ±) (c : (a : Œ∫) ‚Üí Œ≤) (_x : Œ≤) (motive : (x : _x ‚àà Set.range fun (p : Œπ √ó Œ∫) ‚Ü¶ b Prod.fst p +·µ• c Prod.snd p) ‚Üí Prop) (x : _x ‚àà Set.range fun (p : Œπ √ó Œ∫) ‚Ü¶ b Prod.fst p +·µ• c Prod.snd p) (h_1 : ‚àÄ (i : Œπ) (j : Œ∫) (h : fun (p : Œπ √ó Œ∫) ‚Ü¶ b Prod.fst p +·µ• c Prod.snd p (i , j) = _x) , motive (Exists.intro (i , j) h =: ‚àÉ (y : Œπ √ó Œ∫) , fun (p : Œπ √ó Œ∫) ‚Ü¶ b Prod.fst p +·µ• c Prod.snd p y = _x)) (w : Œπ √ó Œ∫) (h : fun (p : Œπ √ó Œ∫) ‚Ü¶ b Prod.fst p +·µ• c Prod.snd p w = _x)  : ‚àÄ (fst : Œπ) (snd : Œ∫) (h : fun (p : Œπ √ó Œ∫) ‚Ü¶ b Prod.fst p +·µ• c Prod.snd p (fst , snd) = _x) , motive Exists.intro (fst , snd) h
<input>:1:395: expected term

{Œ± : Type u} [DecidableEq Œ±] {a : Œ±} {b : Œ±} (l : List Œ±) (x : a ‚â† b) h : a ‚â† b := x  : ‚àÄ (a : False) , 0 = 0
<input>:1:72: expected end of input

{Œ± : Type u} {Œ≤ : Type v} (as : List Œ±) (bs : List Œ≤) (head : Œ±) (tail : List Œ±) (tail_ih : ‚àÄ (bs : List Œ≤) , List.zipRight tail bs = Prod.fst List.zipRight' tail bs) (bs : List Œ≤) (head_1 : Œ≤) (tail_1 : List Œ≤) (h : bs = head_1 :: tail_1)  : head_1 :: tail_1 = bs
function expected at
  ?m.185.fst
term has type
  ?m.39 ; identifiers [Œ±, u, Œ≤, v, as, List, Œ±, bs, List, Œ≤, head, Œ±, tail, List, Œ±, tail_ih, bs, List, Œ≤, List.zipRight, tail, bs, Prod.fst, List.zipRight', tail, bs, bs, List, Œ≤, head_1, Œ≤, tail_1, List, Œ≤, h, bs, head_1, tail_1, head_1, tail_1, bs] (during elaboration)

{Œ± : Type u_1} (h : Œ±) (s : Stream'.Seq GeneralizedContinuedFraction.Pair Œ±) (h_1 : Œ±) (s_1 : Stream'.Seq GeneralizedContinuedFraction.Pair Œ±) (a : (h = h_1 : Prop) ‚àß (s = s_1 : Prop)) (left : h = h_1) (right : s = s_1) (h_2 : h_1 = h) (h_3 : Œ±)  : h = h
application type mismatch
  Stream'.Seq GeneralizedContinuedFraction.Pair
argument
  GeneralizedContinuedFraction.Pair
has type
  Type ?u.10 ‚Üí Type ?u.10 : Type (?u.10 + 1)
but is expected to have type
  Type ?u.9 : Type (?u.9 + 1) ; identifiers [Œ±, u_1, h, Œ±, s, Stream'.Seq, GeneralizedContinuedFraction.Pair, Œ±, h_1, Œ±, s_1, Stream'.Seq, GeneralizedContinuedFraction.Pair, Œ±, a, h, h_1, s, s_1, left, h, h_1, right, s, s_1, h_2, h_1, h, h_3, Œ±, h, h] (during elaboration)

{Œ± : Type u_1} [CommSemiring Œ±] (E : LinearRecurrence Œ±) {u : (a : ‚Ñï) ‚Üí Œ±} {v : (a : ‚Ñï) ‚Üí Œ±} (hu : u ‚àà {u : (a : ‚Ñï) ‚Üí Œ± | LinearRecurrence.IsSolution E u}) (hv : v ‚àà {u : (a : ‚Ñï) ‚Üí Œ± | LinearRecurrence.IsSolution E u}) (n : ‚Ñï)  : u n + LinearRecurrence.order E = Finset.sum Finset.univ fun (i : Fin LinearRecurrence.order E) ‚Ü¶ LinearRecurrence.coeffs E i * u n + ‚Üë i
application type mismatch
  Fin LinearRecurrence.order
argument
  LinearRecurrence.order
has type
  LinearRecurrence ?m.726 ‚Üí ‚Ñï : Type ?u.725
but is expected to have type
  ‚Ñï : Type ; identifiers [Œ±, u_1, CommSemiring, Œ±, E, LinearRecurrence, Œ±, u, a, Œ±, v, a, Œ±, hu, u, u, a, Œ±, LinearRecurrence.IsSolution, E, u, hv, v, u, a, Œ±, LinearRecurrence.IsSolution, E, u, n, u, n, LinearRecurrence.order, E, Finset.sum, Finset.univ, i, Fin, LinearRecurrence.order, E, LinearRecurrence.coeffs, E, i, u, n, i] (during elaboration)

{Œ± : Type u_1} [CommSemiring Œ±] (E : LinearRecurrence Œ±) {u : (a : ‚Ñï) ‚Üí Œ±} {v : (a : ‚Ñï) ‚Üí Œ±} (hu : u ‚àà {u : (a : ‚Ñï) ‚Üí Œ± | LinearRecurrence.IsSolution E u}) (hv : v ‚àà {u : (a : ‚Ñï) ‚Üí Œ± | LinearRecurrence.IsSolution E u}) (n : ‚Ñï)  : v n + LinearRecurrence.order E = Finset.sum Finset.univ fun (i : Fin LinearRecurrence.order E) ‚Ü¶ LinearRecurrence.coeffs E i * v n + ‚Üë i
application type mismatch
  Fin LinearRecurrence.order
argument
  LinearRecurrence.order
has type
  LinearRecurrence ?m.726 ‚Üí ‚Ñï : Type ?u.725
but is expected to have type
  ‚Ñï : Type ; identifiers [Œ±, u_1, CommSemiring, Œ±, E, LinearRecurrence, Œ±, u, a, Œ±, v, a, Œ±, hu, u, u, a, Œ±, LinearRecurrence.IsSolution, E, u, hv, v, u, a, Œ±, LinearRecurrence.IsSolution, E, u, n, v, n, LinearRecurrence.order, E, Finset.sum, Finset.univ, i, Fin, LinearRecurrence.order, E, LinearRecurrence.coeffs, E, i, v, n, i] (during elaboration)

{G : Type u_1} [Group G] (h : Subsingleton Subgroup G) (x : G) (y : G) (this : ‚àÄ (i : G) , i = 1)  : x = 1
application type mismatch
  Subsingleton Subgroup
argument
  Subgroup
has type
  (G : Type ?u.11) ‚Üí [inst : Group G] ‚Üí Type ?u.11 : Type (?u.11 + 1)
but is expected to have type
  Sort ?u.10 : Type ?u.10 ; identifiers [G, u_1, Group, G, h, Subsingleton, Subgroup, G, x, G, y, G, this, i, G, i, x] (during elaboration)

{G : Type u_1} [Group G] (h : Subsingleton Subgroup G) (x : G) (y : G) (this : ‚àÄ (i : G) , i = 1)  : y = 1
application type mismatch
  Subsingleton Subgroup
argument
  Subgroup
has type
  (G : Type ?u.11) ‚Üí [inst : Group G] ‚Üí Type ?u.11 : Type (?u.11 + 1)
but is expected to have type
  Sort ?u.10 : Type ?u.10 ; identifiers [G, u_1, Group, G, h, Subsingleton, Subgroup, G, x, G, y, G, this, i, G, i, y] (during elaboration)

(R : Type u_1) [inst : CommRing R] (n : ‚Ñï) (ŒΩ : ‚Ñï) (h : ŒΩ ‚â§ n) (h' : ŒΩ < n) {Œ± : Type u_1} {Œ≤ : Type u_1} {Œ≥ : outParam Type u_1} [HMul Œ± Œ≤ Œ≥] (a : Œ±) (a_1 : Œ±) (e_a : a = a_1) (a_2 : Œ≤) (a_3 : Œ≤) (e_a : a_2 = a_3)  : a * a_2 = a * a_2
function expected at
  outParam Type
term has type
  Type 1 ; identifiers [R, u_1, inst, CommRing, R, n, ŒΩ, h, ŒΩ, n, h', ŒΩ, n, Œ±, u_1, Œ≤, u_1, Œ≥, outParam, u_1, HMul, Œ±, Œ≤, Œ≥, a, Œ±, a_1, Œ±, e_a, a, a_1, a_2, Œ≤, a_3, Œ≤, e_a, a_2, a_3, a, a_2, a, a_2] (during elaboration)

(R : Type u_1) [inst : CommRing R] (n : ‚Ñï) (ŒΩ : ‚Ñï) (h : ŒΩ ‚â§ n) (h' : ŒΩ < n)  : - 1 ^ n - ŒΩ = - 1 ^ n - ŒΩ
failed to synthesize instance
  Neg ‚Ñï ; identifiers [R, u_1, inst, CommRing, R, n, ŒΩ, h, ŒΩ, n, h', ŒΩ, n, n, ŒΩ, n, ŒΩ] (during elaboration)

{Œ± : Type u} {Œ≤ : Type v} (as : List Œ±) (bs : List Œ≤) (head : Œ±) (tail : List Œ±) (tail_ih : ‚àÄ (bs : List Œ≤) , List.zipRight tail bs = Prod.fst List.zipRight' tail bs) (bs : List Œ≤) (head_1 : Œ≤) (tail_1 : List Œ≤) (h : bs = head_1 :: tail_1)  : ‚àÄ (bs : List Œ≤) , List.zipRight tail bs = Prod.fst List.zipRight' tail bs
function expected at
  ?m.185.fst
term has type
  ?m.39 ; identifiers [Œ±, u, Œ≤, v, as, List, Œ±, bs, List, Œ≤, head, Œ±, tail, List, Œ±, tail_ih, bs, List, Œ≤, List.zipRight, tail, bs, Prod.fst, List.zipRight', tail, bs, bs, List, Œ≤, head_1, Œ≤, tail_1, List, Œ≤, h, bs, head_1, tail_1, bs, List, Œ≤, List.zipRight, tail, bs, Prod.fst, List.zipRight', tail, bs] (during elaboration)

{Œ± : Type u} {Œ≤ : Type v} (as : List Œ±) (bs : List Œ≤) (head : Œ±) (tail : List Œ±) (tail_ih : ‚àÄ (bs : List Œ≤) , List.zipRight tail bs = Prod.fst List.zipRight' tail bs) (bs : List Œ≤)  : bs = bs
function expected at
  ?m.185.fst
term has type
  ?m.39 ; identifiers [Œ±, u, Œ≤, v, as, List, Œ±, bs, List, Œ≤, head, Œ±, tail, List, Œ±, tail_ih, bs, List, Œ≤, List.zipRight, tail, bs, Prod.fst, List.zipRight', tail, bs, bs, List, Œ≤, bs, bs] (during elaboration)

{R : Type u_2} {M : Type u_1} {M' : Type u_3} [Ring R] [AddCommGroup M] [AddCommGroup M'] [Module R M] [Module R M'] {s : Set M} {f : M ‚Üí‚Çó[R] M'} (hs : LinearIndependent R fun (x : ‚Üë s) ‚Ü¶ ‚Üë x) (hf_inj : Disjoint Submodule.span R s LinearMap.ker f)  : ‚àÄ (a : M) (a_1 : a ‚àà Set.range fun (x : ‚Üë s) ‚Ü¶ ‚Üë x) , ‚Üë f a = ‚Üë f a
type mismatch
  s
has type
  Set M : Type u_1
but is expected to have type
  Sort ?u.3401 : Type ?u.3401 ; identifiers [R, u_2, M, u_1, M', u_3, Ring, R, AddCommGroup, M, AddCommGroup, M', Module, R, M, Module, R, M', s, Set, M, f, M, R, M', hs, LinearIndependent, R, x, s, x, hf_inj, Disjoint, Submodule.span, R, s, LinearMap.ker, f, a, M, a_1, a, Set.range, x, s, x, f, a, f, a] (during elaboration)

{Œ± : Type u_1} (h : Œ±) (s : Stream'.Seq GeneralizedContinuedFraction.Pair Œ±) (h_1 : Œ±) (s_1 : Stream'.Seq GeneralizedContinuedFraction.Pair Œ±) (a : (h = h_1 : Prop) ‚àß (s = s_1 : Prop)) (left : h = h_1) (right : s = s_1) (h_2 : h_1 = h) (left : h = h) (h_3 : HEq left (Eq.refl h =: h = h)) (h_4 : s_1 = s) (s_2 : Stream'.Seq GeneralizedContinuedFraction.Pair Œ±)  : s = s
<input>:1:279: expected term

{R : Type u_2} {M : Type u_1} {M' : Type u_3} [Ring R] [AddCommGroup M] [AddCommGroup M'] [Module R M] [Module R M'] {s : Set M} {f : M ‚Üí‚Çó[R] M'} (hs : LinearIndependent R fun (x : ‚Üë s) ‚Ü¶ ‚Üë x) (hf_inj : Disjoint Submodule.span R s LinearMap.ker f)  : ‚àÄ (a : M) (a_1 : a ‚àà s) , ‚Üë f a = ‚Üë f a
type mismatch
  s
has type
  Set M : Type u_1
but is expected to have type
  Sort ?u.3401 : Type ?u.3401 ; identifiers [R, u_2, M, u_1, M', u_3, Ring, R, AddCommGroup, M, AddCommGroup, M', Module, R, M, Module, R, M', s, Set, M, f, M, R, M', hs, LinearIndependent, R, x, s, x, hf_inj, Disjoint, Submodule.span, R, s, LinearMap.ker, f, a, M, a_1, a, s, f, a, f, a] (during elaboration)

{Œπ : Type u_2} {M : Type u_1} [Monoid M] [Preorder M] [CovariantClass M M fun (x : M) (x_1 : M) ‚Ü¶ x * x_1 fun (x : M) (x_1 : M) ‚Ü¶ x < x_1] [CovariantClass M M fun (x : M) (x_1 : M) ‚Ü¶ x * x_1 fun (x : M) (x_1 : M) ‚Ü¶ x ‚â§ x_1] [CovariantClass M M Function.swap fun (x : M) (x_1 : M) ‚Ü¶ x * x_1 fun (x : M) (x_1 : M) ‚Ü¶ x < x_1] [CovariantClass M M Function.swap fun (x : M) (x_1 : M) ‚Ü¶ x * x_1 fun (x : M) (x_1 : M) ‚Ü¶ x ‚â§ x_1] {l : List Œπ} (f : (a : Œπ) ‚Üí M) (g : (a : Œπ) ‚Üí M) (h‚ÇÅ : ‚àÄ (i : Œπ) (a : i ‚àà l) , f i ‚â§ g i) (h‚ÇÇ : ‚àÉ (i : Œπ) , (i ‚àà l : Prop) ‚àß (f i < g i : Prop)) (h‚ÇÅ : ‚àÄ (i : Œπ) (a : i ‚àà []) , f i ‚â§ g i) (h‚ÇÇ : ‚àÉ (i : Œπ) , (i ‚àà [] : Prop) ‚àß (f i < g i : Prop)) (w : Œπ) (h : (w ‚àà [] : Prop) ‚àß (f w < g w : Prop)) (left : w ‚àà []) (right : f w < g w)  : [] = []
function expected at
  x_1
term has type
  M ; identifiers [Œπ, u_2, M, u_1, Monoid, M, Preorder, M, CovariantClass, M, M, x, M, x_1, M, x, x_1, x, M, x_1, M, x, x_1, CovariantClass, M, M, x, M, x_1, M, x, x_1, x, M, x_1, M, x, x_1, CovariantClass, M, M, Function.swap, x, M, x_1, M, x, x_1, x, M, x_1, M, x, x_1, CovariantClass, M, M, Function.swap, x, M, x_1, M, x, x_1, x, M, x_1, M, x, x_1, l, List, Œπ, f, a, Œπ, M, g, a, Œπ, M, h‚ÇÅ, i, Œπ, a, i, l, f, i, g, i, h‚ÇÇ, i, Œπ, i, l, f, i, g, i, h‚ÇÅ, i, Œπ, a, i, f, i, g, i, h‚ÇÇ, i, Œπ, i, f, i, g, i, w, Œπ, h, w, f, w, g, w, left, w, right, f, w, g, w] (during elaboration)

{Œ± : Type u_1} (h : Œ±) (s : Stream'.Seq GeneralizedContinuedFraction.Pair Œ±) (h_1 : Œ±) (s_1 : Stream'.Seq GeneralizedContinuedFraction.Pair Œ±) (a : (h = h_1 : Prop) ‚àß (s = s_1 : Prop)) (left : h = h_1) (right : s = s_1) (h_2 : h_1 = h) (left : h = h) (h_3 : HEq left (Eq.refl h =: h = h)) (h_4 : s_1 = s) (right : s = s) (h_5 : HEq right (Eq.refl s =: s = s))  : {h := ((h)) , s := ((s))} = {h := ((h)) , s := ((s))}
<input>:1:279: expected term

{Œ± : Type u_1} (h : Œ±) (s : Stream'.Seq GeneralizedContinuedFraction.Pair Œ±) (h_1 : Œ±) (s_1 : Stream'.Seq GeneralizedContinuedFraction.Pair Œ±) (a : (h = h_1 : Prop) ‚àß (s = s_1 : Prop)) (left : h = h_1) (right : s = s_1) (h_2 : h_1 = h) (left : h = h) (h_3 : HEq left (Eq.refl h =: h = h)) (h_4 : s_1 = s)  : s = s_1
<input>:1:279: expected term

{Œ± : Type u_1} (h : Œ±) (s : Stream'.Seq GeneralizedContinuedFraction.Pair Œ±) (h_1 : Œ±) (s_1 : Stream'.Seq GeneralizedContinuedFraction.Pair Œ±) (a : (h = h_1 : Prop) ‚àß (s = s_1 : Prop)) (left : h = h_1) (right : s = s_1) (h_2 : h_1 = h) (left : h = h) (h_3 : HEq left (Eq.refl h =: h = h))  : s_1 = s_1
<input>:1:279: expected term

{Œ± : Type u_1} (h : Œ±) (s : Stream'.Seq GeneralizedContinuedFraction.Pair Œ±) (h_1 : Œ±) (s_1 : Stream'.Seq GeneralizedContinuedFraction.Pair Œ±) (a : (h = h_1 : Prop) ‚àß (s = s_1 : Prop)) (left : h = h_1) (right : s = s_1) (h_2 : h_1 = h)  : h = h_1
application type mismatch
  Stream'.Seq GeneralizedContinuedFraction.Pair
argument
  GeneralizedContinuedFraction.Pair
has type
  Type ?u.10 ‚Üí Type ?u.10 : Type (?u.10 + 1)
but is expected to have type
  Type ?u.9 : Type (?u.9 + 1) ; identifiers [Œ±, u_1, h, Œ±, s, Stream'.Seq, GeneralizedContinuedFraction.Pair, Œ±, h_1, Œ±, s_1, Stream'.Seq, GeneralizedContinuedFraction.Pair, Œ±, a, h, h_1, s, s_1, left, h, h_1, right, s, s_1, h_2, h_1, h, h, h_1] (during elaboration)

{Œ± : Type u_1} (h : Œ±) (s : Stream'.Seq GeneralizedContinuedFraction.Pair Œ±) (h_1 : Œ±) (s_1 : Stream'.Seq GeneralizedContinuedFraction.Pair Œ±) (a : (h = h_1 : Prop) ‚àß (s = s_1 : Prop)) (left : h = h_1) (right : s = s_1)  : h_1 = h_1
application type mismatch
  Stream'.Seq GeneralizedContinuedFraction.Pair
argument
  GeneralizedContinuedFraction.Pair
has type
  Type ?u.10 ‚Üí Type ?u.10 : Type (?u.10 + 1)
but is expected to have type
  Type ?u.9 : Type (?u.9 + 1) ; identifiers [Œ±, u_1, h, Œ±, s, Stream'.Seq, GeneralizedContinuedFraction.Pair, Œ±, h_1, Œ±, s_1, Stream'.Seq, GeneralizedContinuedFraction.Pair, Œ±, a, h, h_1, s, s_1, left, h, h_1, right, s, s_1, h_1, h_1] (during elaboration)

{m : (a : Type u_1) ‚Üí Type u_2} {Œ± : Type u_1} {Œ±_1 : Type u_1} {p : (a : Œ±_1) ‚Üí Prop} {f : (a : Œ±) ‚Üí Œ±_1} [Functor m] [LawfulFunctor m] {x : m Œ±} (hx : SatisfiesM fun (a : Œ±) ‚Ü¶ p f a x)  : ‚àÄ {a : Œ±} (h : p f a) , p f a
application type mismatch
  p f
argument
  f
has type
  Œ± ‚Üí Œ±_1 : Type u_1
but is expected to have type
  Œ±_1 : Type u_1 ; identifiers [m, a, u_1, u_2, Œ±, u_1, Œ±_1, u_1, p, a, Œ±_1, f, a, Œ±, Œ±_1, Functor, m, LawfulFunctor, m, x, m, Œ±, hx, SatisfiesM, a, Œ±, p, f, a, x, a, Œ±, h, p, f, a, p, f, a] (during elaboration)

 : (‚àÄ {n : ‚Ñï} {m : ‚Ñï} (eq : n = m) {a : Fin n} {b : Fin n} , (‚Üë {toFun := ((Fin.castLE (Eq.le eq =: n ‚â§ m))) , invFun := ((Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ‚â§ n))) , left_inv := (((fun (x : Fin n) ‚Ü¶ (_ : Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ‚â§ n) Fin.castLE (Eq.le eq =: n ‚â§ m) x = x) =: ‚àÄ (x : Fin n) , Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ‚â§ n) Fin.castLE (Eq.le eq =: n ‚â§ m) x = x))) , right_inv := (((fun (x : Fin m) ‚Ü¶ (_ : Fin.castLE (Eq.le eq =: n ‚â§ m) Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ‚â§ n) x = x) =: ‚àÄ (x : Fin m) , Fin.castLE (Eq.le eq =: n ‚â§ m) Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ‚â§ n) x = x)))} a ‚â§ ‚Üë {toFun := ((Fin.castLE (Eq.le eq =: n ‚â§ m))) , invFun := ((Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ‚â§ n))) , left_inv := (((fun (x : Fin n) ‚Ü¶ (_ : Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ‚â§ n) Fin.castLE (Eq.le eq =: n ‚â§ m) x = x) =: ‚àÄ (x : Fin n) , Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ‚â§ n) Fin.castLE (Eq.le eq =: n ‚â§ m) x = x))) , right_inv := (((fun (x : Fin m) ‚Ü¶ (_ : Fin.castLE (Eq.le eq =: n ‚â§ m) Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ‚â§ n) x = x) =: ‚àÄ (x : Fin m) , Fin.castLE (Eq.le eq =: n ‚â§ m) Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ‚â§ n) x = x)))} b : Prop) ‚Üî (‚Üë {toFun := ((Fin.castLE (Eq.le eq =: n ‚â§ m))) , invFun := ((Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ‚â§ n))) , left_inv := (((fun (x : Fin n) ‚Ü¶ (_ : Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ‚â§ n) Fin.castLE (Eq.le eq =: n ‚â§ m) x = x) =: ‚àÄ (x : Fin n) , Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ‚â§ n) Fin.castLE (Eq.le eq =: n ‚â§ m) x = x))) , right_inv := (((fun (x : Fin m) ‚Ü¶ (_ : Fin.castLE (Eq.le eq =: n ‚â§ m) Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ‚â§ n) x = x) =: ‚àÄ (x : Fin m) , Fin.castLE (Eq.le eq =: n ‚â§ m) Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ‚â§ n) x = x)))} a ‚â§ ‚Üë {toFun := ((Fin.castLE (Eq.le eq =: n ‚â§ m))) , invFun := ((Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ‚â§ n))) , left_inv := (((fun (x : Fin n) ‚Ü¶ (_ : Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ‚â§ n) Fin.castLE (Eq.le eq =: n ‚â§ m) x = x) =: ‚àÄ (x : Fin n) , Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ‚â§ n) Fin.castLE (Eq.le eq =: n ‚â§ m) x = x))) , right_inv := (((fun (x : Fin m) ‚Ü¶ (_ : Fin.castLE (Eq.le eq =: n ‚â§ m) Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ‚â§ n) x = x) =: ‚àÄ (x : Fin m) , Fin.castLE (Eq.le eq =: n ‚â§ m) Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ‚â§ n) x = x)))} b : Prop))
<input>:1:98: expected term

 : ‚àÄ {n : ‚Ñï} {m : ‚Ñï} (eq : n = m) {a : Fin n} {b : Fin n} , (‚Üë {toFun := ((Fin.castLE (Eq.le eq =: n ‚â§ m))) , invFun := ((Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ‚â§ n))) , left_inv := (((fun (x : Fin n) ‚Ü¶ Fin.eq_of_veq (rfl =: ‚Üë Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ‚â§ n) Fin.castLE (Eq.le eq =: n ‚â§ m) x = ‚Üë Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ‚â§ n) Fin.castLE (Eq.le eq =: n ‚â§ m) x) =: ‚àÄ (x : Fin n) , Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ‚â§ n) Fin.castLE (Eq.le eq =: n ‚â§ m) x = x))) , right_inv := (((fun (x : Fin m) ‚Ü¶ Fin.eq_of_veq (rfl =: ‚Üë Fin.castLE (Eq.le eq =: n ‚â§ m) Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ‚â§ n) x = ‚Üë Fin.castLE (Eq.le eq =: n ‚â§ m) Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ‚â§ n) x) =: ‚àÄ (x : Fin m) , Fin.castLE (Eq.le eq =: n ‚â§ m) Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ‚â§ n) x = x)))} a ‚â§ ‚Üë {toFun := ((Fin.castLE (Eq.le eq =: n ‚â§ m))) , invFun := ((Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ‚â§ n))) , left_inv := (((fun (x : Fin n) ‚Ü¶ Fin.eq_of_veq (rfl =: ‚Üë Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ‚â§ n) Fin.castLE (Eq.le eq =: n ‚â§ m) x = ‚Üë Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ‚â§ n) Fin.castLE (Eq.le eq =: n ‚â§ m) x) =: ‚àÄ (x : Fin n) , Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ‚â§ n) Fin.castLE (Eq.le eq =: n ‚â§ m) x = x))) , right_inv := (((fun (x : Fin m) ‚Ü¶ Fin.eq_of_veq (rfl =: ‚Üë Fin.castLE (Eq.le eq =: n ‚â§ m) Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ‚â§ n) x = ‚Üë Fin.castLE (Eq.le eq =: n ‚â§ m) Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ‚â§ n) x) =: ‚àÄ (x : Fin m) , Fin.castLE (Eq.le eq =: n ‚â§ m) Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ‚â§ n) x = x)))} b) ‚Üî (‚Üë {toFun := ((Fin.castLE (Eq.le eq =: n ‚â§ m))) , invFun := ((Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ‚â§ n))) , left_inv := (((fun (x : Fin n) ‚Ü¶ Fin.eq_of_veq (rfl =: ‚Üë Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ‚â§ n) Fin.castLE (Eq.le eq =: n ‚â§ m) x = ‚Üë Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ‚â§ n) Fin.castLE (Eq.le eq =: n ‚â§ m) x) =: ‚àÄ (x : Fin n) , Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ‚â§ n) Fin.castLE (Eq.le eq =: n ‚â§ m) x = x))) , right_inv := (((fun (x : Fin m) ‚Ü¶ Fin.eq_of_veq (rfl =: ‚Üë Fin.castLE (Eq.le eq =: n ‚â§ m) Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ‚â§ n) x = ‚Üë Fin.castLE (Eq.le eq =: n ‚â§ m) Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ‚â§ n) x) =: ‚àÄ (x : Fin m) , Fin.castLE (Eq.le eq =: n ‚â§ m) Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ‚â§ n) x = x)))} a ‚â§ ‚Üë {toFun := ((Fin.castLE (Eq.le eq =: n ‚â§ m))) , invFun := ((Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ‚â§ n))) , left_inv := (((fun (x : Fin n) ‚Ü¶ Fin.eq_of_veq (rfl =: ‚Üë Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ‚â§ n) Fin.castLE (Eq.le eq =: n ‚â§ m) x = ‚Üë Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ‚â§ n) Fin.castLE (Eq.le eq =: n ‚â§ m) x) =: ‚àÄ (x : Fin n) , Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ‚â§ n) Fin.castLE (Eq.le eq =: n ‚â§ m) x = x))) , right_inv := (((fun (x : Fin m) ‚Ü¶ Fin.eq_of_veq (rfl =: ‚Üë Fin.castLE (Eq.le eq =: n ‚â§ m) Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ‚â§ n) x = ‚Üë Fin.castLE (Eq.le eq =: n ‚â§ m) Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ‚â§ n) x) =: ‚àÄ (x : Fin m) , Fin.castLE (Eq.le eq =: n ‚â§ m) Fin.castLE (Eq.le (Eq.symm eq =: m = n) =: m ‚â§ n) x = x)))} b)
<input>:1:97: expected term

{Œ± : Type u_1} {s : Set Œ±} (motive : (hs : Set.Nonempty s) ‚Üí Prop) (hs : Set.Nonempty s) (h_1 : ‚àÄ (a : Œ±) (ha : a ‚àà s) , motive (Exists.intro a ha =: ‚àÉ (x : Œ±) , x ‚àà s))  : ‚àÄ (w : Œ±) (h : w ‚àà s) , motive Exists.intro w h
<input>:1:148: expected term

{M : Type u_1} {N : Type u_2} {Œ± : Type u_3} [VAdd M Œ±] [VAdd N Œ±] [VAdd N ·µÉ·µí·µñ Œ±] [IsCentralVAdd N Œ±] [VAddCommClass M N Œ±] (m : M) (n : N ·µÉ·µí·µñ) (a : Œ±)  : (m +·µ• n +·µ• a = n +·µ• m +·µ• a) = (m +·µ• n +·µ• a = n +·µ• m +·µ• a)
failed to synthesize instance
  HVAdd M N·µÉ·µí·µñ ?m.93 ; identifiers [M, u_1, N, u_2, Œ±, u_3, VAdd, M, Œ±, VAdd, N, Œ±, VAdd, N, Œ±, IsCentralVAdd, N, Œ±, VAddCommClass, M, N, Œ±, m, M, n, N, a, Œ±, m, n, a, n, m, a, m, n, a, n, m, a] (during elaboration)

{Œ± : Type u} {xs : List Œ±} (head : Œ±) (tail : List Œ±) (tail_ih : ‚Üë FreeMonoid.toList List.traverse Functor.Const.mk' ‚àò FreeMonoid.of tail = tail) {Œ± : Type u} (a : Œ±) (a_1 : Œ±) (e_a : a = a_1) (a_2 : Œ±) (a_3 : Œ±) (e_a : a_2 = a_3)  : (a = a_2) = (a = a_2)
type mismatch
  tail
has type
  List Œ± : Type u
but is expected to have type
  ?m.555482 head tail ‚Üí ?m.555483 head tail : Sort (imax ?u.20 ?u.18) ; identifiers [Œ±, u, xs, List, Œ±, head, Œ±, tail, List, Œ±, tail_ih, FreeMonoid.toList, List.traverse, Functor.Const.mk', FreeMonoid.of, tail, tail, Œ±, u, a, Œ±, a_1, Œ±, e_a, a, a_1, a_2, Œ±, a_3, Œ±, e_a, a_2, a_3, a, a_2, a, a_2] (during elaboration)

{Œ± : Type u} {f : (a : Œ±) ‚Üí Œ±} {g : (a : ‚Ñï) ‚Üí (a : Œ±) ‚Üí Œ±} (H : ‚àÄ (n : ‚Ñï) , Function.Semiconj f g n g n + 1) (n : ‚Ñï) (k : ‚Ñï) (n : ‚Ñï) (ihn : ‚àÄ (k : ‚Ñï) , Function.Semiconj f ^[n] g k g n + k) (k : ‚Ñï)  : Function.Semiconj f g k g k + 1
application type mismatch
  Function.Semiconj f g
argument
  g
has type
  ‚Ñï ‚Üí Œ± ‚Üí Œ± : Type u
but is expected to have type
  Œ± ‚Üí Œ± : Type u ; identifiers [Œ±, u, f, a, Œ±, Œ±, g, a, a, Œ±, Œ±, H, n, Function.Semiconj, f, g, n, g, n, n, k, n, ihn, k, Function.Semiconj, f, n, g, k, g, n, k, k, Function.Semiconj, f, g, k, g, k] (during elaboration)

{Œ± : Type u} {xs : List Œ±} (head : Œ±) (tail : List Œ±) (tail_ih : ‚Üë FreeMonoid.toList List.traverse Functor.Const.mk' ‚àò FreeMonoid.of tail = tail)  : tail = ‚Üë FreeMonoid.toList List.traverse Functor.Const.mk' ‚àò FreeMonoid.of tail
type mismatch
  ?m.555443 ‚àò ?m.634540
has type
  ?m.555437 ‚Üí ?m.555439 : Sort (imax ?u.555436 ?u.555434)
but is expected to have type
  List Œ± : Type u ; identifiers [Œ±, u, xs, List, Œ±, head, Œ±, tail, List, Œ±, tail_ih, FreeMonoid.toList, List.traverse, Functor.Const.mk', FreeMonoid.of, tail, tail, tail, FreeMonoid.toList, List.traverse, Functor.Const.mk', FreeMonoid.of, tail] (during elaboration)

{Œ± : Type u} {xs : List Œ±} (head : Œ±) (tail : List Œ±) (tail_ih : ‚Üë FreeMonoid.toList List.traverse Functor.Const.mk' ‚àò FreeMonoid.of tail = tail)  : head :: tail = head :: tail
type mismatch
  tail
has type
  List Œ± : Type u
but is expected to have type
  ?m.555457 head tail ‚Üí ?m.555458 head tail : Sort (imax ?u.20 ?u.18) ; identifiers [Œ±, u, xs, List, Œ±, head, Œ±, tail, List, Œ±, tail_ih, FreeMonoid.toList, List.traverse, Functor.Const.mk', FreeMonoid.of, tail, tail, head, tail, head, tail] (during elaboration)

 : (‚àÄ {Œπ : Type uŒπ} {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] [inst_2 : FiniteDimensional ‚Ñù E] {H : Type uH} [inst_3 : TopologicalSpace H] {I : ModelWithCorners ‚Ñù E H} {M : Type uM} [inst_4 : TopologicalSpace M] [inst_5 : ChartedSpace H M] {s : optParam Set M Set.univ} (self : SmoothBumpCovering Œπ I M s) , LocallyFinite fun (i : Œπ) ‚Ü¶ Function.support ‚Üë SmoothBumpCovering.toFun s self i)
unknown universe level 'uŒπ' ; identifiers [Œπ, uŒπ, E, uE, inst, NormedAddCommGroup, E, inst_1, NormedSpace, E, inst_2, FiniteDimensional, E, H, uH, inst_3, TopologicalSpace, H, I, ModelWithCorners, E, H, M, uM, inst_4, TopologicalSpace, M, inst_5, ChartedSpace, H, M, s, optParam, Set, M, Set.univ, self, SmoothBumpCovering, Œπ, I, M, s, LocallyFinite, i, Œπ, Function.support, SmoothBumpCovering.toFun, s, self, i] (during elaboration)

 : ‚àÄ (Œπ : Type uŒπ) (E : Type uE) [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] [inst_2 : FiniteDimensional ‚Ñù E] (H : Type uH) [inst_3 : TopologicalSpace H] (I : ModelWithCorners ‚Ñù E H) (M : Type uM) [inst_4 : TopologicalSpace M] [inst_5 : ChartedSpace H M] (s : optParam Set M Set.univ) (self : SmoothBumpCovering Œπ I M s) , LocallyFinite fun (i : Œπ) ‚Ü¶ Function.support ‚Üë self . 2 i
unknown universe level 'uŒπ' ; identifiers [Œπ, uŒπ, E, uE, inst, NormedAddCommGroup, E, inst_1, NormedSpace, E, inst_2, FiniteDimensional, E, H, uH, inst_3, TopologicalSpace, H, I, ModelWithCorners, E, H, M, uM, inst_4, TopologicalSpace, M, inst_5, ChartedSpace, H, M, s, optParam, Set, M, Set.univ, self, SmoothBumpCovering, Œπ, I, M, s, LocallyFinite, i, Œπ, Function.support, self, i] (during elaboration)

{b : Ordinal .{u_1}} {o : Ordinal .{u_1}} (hb : 1 < b) (ho : o ‚â† 0) (hbo : b ‚â§ o)  : (b ^ 1 ‚â§ o) = (b ^ 1 ‚â§ o)
<input>:1:13: expected '//', '|' or '}'

{K : Type u_1} {v : K} {n : ‚Ñï} [LinearOrderedField K] [FloorRing K] {b : K} (nth_part_denom_eq : Stream'.Seq.get? GeneralizedContinuedFraction.partialDenominators GeneralizedContinuedFraction.of v n = some b) (not_terminated_at_n : ¬¨ (GeneralizedContinuedFraction.TerminatedAt GeneralizedContinuedFraction.of v n : Prop)) (hB : 0 < GeneralizedContinuedFraction.denominators GeneralizedContinuedFraction.of v n) {Œ± : Type u_1} [LE Œ±] (a : Œ±) (a_1 : Œ±) (e_a : a = a_1) (a_2 : Œ±) (a_3 : Œ±) (e_a : a_2 = a_3)  : (a ‚â§ a_2) = (a ‚â§ a_2)
application type mismatch
  Stream'.Seq.get? ?m.79761 GeneralizedContinuedFraction.of
argument
  GeneralizedContinuedFraction.of
has type
  ?m.79763 ‚Üí GeneralizedContinuedFraction ?m.79763 : Type ?u.79762
but is expected to have type
  ‚Ñï : Type ; identifiers [K, u_1, v, K, n, LinearOrderedField, K, FloorRing, K, b, K, nth_part_denom_eq, Stream'.Seq.get?, GeneralizedContinuedFraction.partialDenominators, GeneralizedContinuedFraction.of, v, n, some, b, not_terminated_at_n, GeneralizedContinuedFraction.TerminatedAt, GeneralizedContinuedFraction.of, v, n, hB, GeneralizedContinuedFraction.denominators, GeneralizedContinuedFraction.of, v, n, Œ±, u_1, LE, Œ±, a, Œ±, a_1, Œ±, e_a, a, a_1, a_2, Œ±, a_3, Œ±, e_a, a_2, a_3, a, a_2, a, a_2] (during elaboration)

{R : Type u_1} [Semiring R] (n : ‚Ñï)  : if (n = 1) then 1 else 0 = if (n = 1) then 1 else 0
failed to synthesize instance
  OfNat (Sort ?u.11) 1 ; identifiers [R, u_1, Semiring, R, n, n, n] (during elaboration)

{M : Type u_1} [Monoid M] (S : Submonoid M) {Œπ : Type u_2} (t : Finset Œπ) (f : (a : Œπ) ‚Üí M) (comm : Set.Pairwise ‚Üë t fun (a : Œπ) (b : Œπ) ‚Ü¶ Commute f a f b) (h : ‚àÄ (c : Œπ) (a : c ‚àà t) , f c ‚àà S) (y : M) (a : ‚àÉ (a : Œπ) , (a ‚àà Finset.val t : Prop) ‚àß (f a = y : Prop)) (x : Œπ) (h_1 : (x ‚àà Finset.val t : Prop) ‚àß (f x = y : Prop)) (hx : x ‚àà Finset.val t) (right : f x = y)  : f x ‚àà S
application type mismatch
  Commute f a
argument
  a
has type
  Œπ : Type u_2
but is expected to have type
  Œπ ‚Üí M : Type (max u_1 u_2) ; identifiers [M, u_1, Monoid, M, S, Submonoid, M, Œπ, u_2, t, Finset, Œπ, f, a, Œπ, M, comm, Set.Pairwise, t, a, Œπ, b, Œπ, Commute, f, a, f, b, h, c, Œπ, a, c, t, f, c, S, y, M, a, a, Œπ, a, Finset.val, t, f, a, y, x, Œπ, h_1, x, Finset.val, t, f, x, y, hx, x, Finset.val, t, right, f, x, y, f, x, S] (during elaboration)

{ùïú : Type u_1} {E : Type u_2} [NontriviallyNormedField ùïú] [NormedAddCommGroup E] [NormedSpace ùïú E] {f : (a : ùïú) ‚Üí E} {a : ùïú} {s : Set ùïú} (h : ContinuousOn dslope f a s) (x : ùïú) (hx : x ‚àà s)  : ContinuousWithinAt dslope f a s x
function expected at
  ContinuousOn dslope ?m.620
term has type
  Prop ; identifiers [ùïú, u_1, E, u_2, NontriviallyNormedField, ùïú, NormedAddCommGroup, E, NormedSpace, ùïú, E, f, a, ùïú, E, a, ùïú, s, Set, ùïú, h, ContinuousOn, dslope, f, a, s, x, ùïú, hx, x, s, ContinuousWithinAt, dslope, f, a, s, x] (during elaboration)

{Œπ : Type u_2} {M : Type u_1} [Monoid M] [Preorder M] [CovariantClass M M fun (x : M) (x_1 : M) ‚Ü¶ x * x_1 fun (x : M) (x_1 : M) ‚Ü¶ x < x_1] [CovariantClass M M fun (x : M) (x_1 : M) ‚Ü¶ x * x_1 fun (x : M) (x_1 : M) ‚Ü¶ x ‚â§ x_1] [CovariantClass M M Function.swap fun (x : M) (x_1 : M) ‚Ü¶ x * x_1 fun (x : M) (x_1 : M) ‚Ü¶ x < x_1] [CovariantClass M M Function.swap fun (x : M) (x_1 : M) ‚Ü¶ x * x_1 fun (x : M) (x_1 : M) ‚Ü¶ x ‚â§ x_1] {l : List Œπ} (f : (a : Œπ) ‚Üí M) (g : (a : Œπ) ‚Üí M) (h‚ÇÅ : ‚àÄ (i : Œπ) (a : i ‚àà l) , f i ‚â§ g i) (h‚ÇÇ : ‚àÉ (i : Œπ) , (i ‚àà l : Prop) ‚àß (f i < g i : Prop)) (i : Œπ) (l : List Œπ) (ihl : ‚àÄ (h‚ÇÅ : ‚àÄ (i : Œπ) (a : i ‚àà l) , f i ‚â§ g i) (h‚ÇÇ : ‚àÉ (i : Œπ) , (i ‚àà l : Prop) ‚àß (f i < g i : Prop)) , List.prod List.map f l < List.prod List.map g l) (h‚ÇÅ : ‚àÄ (i_1 : Œπ) (a : i_1 ‚àà i :: l) , f i_1 ‚â§ g i_1) (h‚ÇÇ : ‚àÉ (i_1 : Œπ) , (i_1 ‚àà i :: l : Prop) ‚àß (f i_1 < g i_1 : Prop)) (h : f i < g i) (h_1 : (Eq.mp (Mathlib.Data.List.BigOperators.Basic._auxLemma.3 =: (‚àÉ (x : Œπ) , (x ‚àà i :: l : Prop) ‚àß (f x < g x : Prop) : Prop) = ((f i < g i : Prop) ‚à® (‚àÉ (x : Œπ) , (x ‚àà l : Prop) ‚àß (f x < g x : Prop) : Prop) : Prop)) h‚ÇÇ =: (f i < g i : Prop) ‚à® (‚àÉ (x : Œπ) , (x ‚àà l : Prop) ‚àß (f x < g x : Prop) : Prop)) = (Or.inl h =: (f i < g i : Prop) ‚à® (‚àÉ (x : Œπ) , (x ‚àà l : Prop) ‚àß (f x < g x : Prop) : Prop)))  : Or.inl h = Eq.mp Mathlib.Data.List.BigOperators.Basic._auxLemma.3 h‚ÇÇ
<input>:1:947: expected term

{o : Type u_5} {m' : (a : o) ‚Üí Type u_1} {n' : (a : o) ‚Üí Type u_2} {Œ± : Type u_3} {Œ≤ : Type u_4} [DecidableEq o] [Zero Œ±] [Zero Œ≤] (M : (i : o) ‚Üí Matrix m' i n' i Œ±) (f : (a : Œ±) ‚Üí Œ≤) (hf : f 0 = 0) (i : (i : o) √ó m' i) (x : (i : o) √ó n' i)  : ‚àÄ (h : ¬¨ (Sigma.fst i = Sigma.fst x)) , 0 = 0
application type mismatch
  Matrix m'
argument
  m'
has type
  o ‚Üí Type u_1 : Type (max (u_1 + 1) u_5)
but is expected to have type
  Type ?u.47 : Type (?u.47 + 1) ; identifiers [o, u_5, m', a, o, u_1, n', a, o, u_2, Œ±, u_3, Œ≤, u_4, DecidableEq, o, Zero, Œ±, Zero, Œ≤, M, i, o, Matrix, m', i, n', i, Œ±, f, a, Œ±, Œ≤, hf, f, i, i, o, m', i, x, i, o, n', i, h, Sigma.fst, i, Sigma.fst, x] (during elaboration)

{Œ± : Type u} {C : (a : FreeGroup Œ±) ‚Üí Prop} (z : FreeGroup Œ±) (C1 : C 1) (Cp : ‚àÄ (x : Œ±) , C pure x) (Ci : ‚àÄ (x : Œ±) (a : C pure x) , C pure x ‚Åª¬π) (Cm : ‚àÄ (x : FreeGroup Œ±) (y : FreeGroup Œ±) (a : C x) (a : C y) , C x * y) (L : List Œ± √ó Bool) (x : Œ± √ó Bool) (_tl : List Œ± √ó Bool) (ih : C Quot.mk FreeGroup.Red.Step _tl) (x : Œ±) (b : Bool)  : C pure x
application type mismatch
  C pure
argument
  pure
has type
  ?m.59 ‚Üí ?m.57 ?m.59 : Type (max ?u.55 ?u.56)
but is expected to have type
  FreeGroup Œ± : Type u ; identifiers [Œ±, u, C, a, FreeGroup, Œ±, z, FreeGroup, Œ±, C1, C, Cp, x, Œ±, C, pure, x, Ci, x, Œ±, a, C, pure, x, C, pure, x, Cm, x, FreeGroup, Œ±, y, FreeGroup, Œ±, a, C, x, a, C, y, C, x, y, L, List, Œ±, Bool, x, Œ±, Bool, _tl, List, Œ±, Bool, ih, C, Quot.mk, FreeGroup.Red.Step, _tl, x, Œ±, b, Bool, C, pure, x] (during elaboration)

{v : Sat.Valuation} {l : Sat.Literal} {a : Prop} {c : Sat.Clause} {b : Prop} (h‚ÇÅ : Sat.Literal.reify v l (a : Prop)) (h‚ÇÇ : Sat.Clause.reify v c (b : Prop)) (H : ¬¨ (Sat.Valuation.satisfies v Sat.Clause.cons l c : Prop)) (h : Sat.Valuation.satisfies v c)  : ‚àÄ (x : Sat.Valuation.neg v l) , Sat.Valuation.satisfies v c
application type mismatch
  Sat.Valuation.satisfies v Sat.Clause.cons
argument
  Sat.Clause.cons
has type
  Sat.Literal ‚Üí Sat.Clause ‚Üí Sat.Clause : Type
but is expected to have type
  Sat.Clause : Type ; identifiers [v, Sat.Valuation, l, Sat.Literal, a, c, Sat.Clause, b, h‚ÇÅ, Sat.Literal.reify, v, l, a, h‚ÇÇ, Sat.Clause.reify, v, c, b, H, Sat.Valuation.satisfies, v, Sat.Clause.cons, l, c, h, Sat.Valuation.satisfies, v, c, x, Sat.Valuation.neg, v, l, Sat.Valuation.satisfies, v, c] (during elaboration)

(x : WType WType.NatŒ≤) (x : WType WType.NatŒ≤) (f : WType.ibelow x) (f : (a : WType.NatŒ≤ WType.NatŒ±.zero) ‚Üí WType WType.NatŒ≤) (x : WType.ibelow WType.mk WType.NatŒ±.zero f) (x : Empty)  : x = x
function expected at
  WType.ibelow ?m.80340
term has type
  Prop ; identifiers [x, WType, WType.NatŒ≤, x, WType, WType.NatŒ≤, f, WType.ibelow, x, f, a, WType.NatŒ≤, WType.NatŒ±.zero, WType, WType.NatŒ≤, x, WType.ibelow, WType.mk, WType.NatŒ±.zero, f, x, Empty, x, x] (during elaboration)

{Œπ : Type u_2} {M : Type u_1} [Monoid M] [Preorder M] [CovariantClass M M fun (x : M) (x_1 : M) ‚Ü¶ x * x_1 fun (x : M) (x_1 : M) ‚Ü¶ x < x_1] [CovariantClass M M fun (x : M) (x_1 : M) ‚Ü¶ x * x_1 fun (x : M) (x_1 : M) ‚Ü¶ x ‚â§ x_1] [CovariantClass M M Function.swap fun (x : M) (x_1 : M) ‚Ü¶ x * x_1 fun (x : M) (x_1 : M) ‚Ü¶ x < x_1] [CovariantClass M M Function.swap fun (x : M) (x_1 : M) ‚Ü¶ x * x_1 fun (x : M) (x_1 : M) ‚Ü¶ x ‚â§ x_1] {l : List Œπ} (f : (a : Œπ) ‚Üí M) (g : (a : Œπ) ‚Üí M) (h‚ÇÅ : ‚àÄ (i : Œπ) (a : i ‚àà l) , f i ‚â§ g i) (h‚ÇÇ : ‚àÉ (i : Œπ) , (i ‚àà l : Prop) ‚àß (f i < g i : Prop)) (i : Œπ) (l : List Œπ) (ihl : ‚àÄ (h‚ÇÅ : ‚àÄ (i : Œπ) (a : i ‚àà l) , f i ‚â§ g i) (h‚ÇÇ : ‚àÉ (i : Œπ) , (i ‚àà l : Prop) ‚àß (f i < g i : Prop)) , List.prod List.map f l < List.prod List.map g l) (h‚ÇÅ : ‚àÄ (i_1 : Œπ) (a : i_1 ‚àà i :: l) , f i_1 ‚â§ g i_1) (h‚ÇÇ : ‚àÉ (i_1 : Œπ) , (i_1 ‚àà i :: l : Prop) ‚àß (f i_1 < g i_1 : Prop)) (h : ‚àÉ (x : Œπ) , (x ‚àà l : Prop) ‚àß (f x < g x : Prop)) (h_1 : (Eq.mp (Mathlib.Data.List.BigOperators.Basic._auxLemma.3 =: (‚àÉ (x : Œπ) , (x ‚àà i :: l : Prop) ‚àß (f x < g x : Prop) : Prop) = ((f i < g i : Prop) ‚à® (‚àÉ (x : Œπ) , (x ‚àà l : Prop) ‚àß (f x < g x : Prop) : Prop) : Prop)) h‚ÇÇ =: (f i < g i : Prop) ‚à® (‚àÉ (x : Œπ) , (x ‚àà l : Prop) ‚àß (f x < g x : Prop) : Prop)) = (Or.inr h =: (f i < g i : Prop) ‚à® (‚àÉ (x : Œπ) , (x ‚àà l : Prop) ‚àß (f x < g x : Prop) : Prop)))  : Or.inr h = Eq.mp Mathlib.Data.List.BigOperators.Basic._auxLemma.3 h‚ÇÇ
<input>:1:985: expected term

{Œ± : Type u_1} [MeasurableSpace Œ±] {p : (a : Œ±) ‚Üí Prop} [MeasurableSingletonClass Œ±] (x : Subtype p)  : {x} = {x}
typeclass instance problem is stuck, it is often due to metavariables
  Singleton (Subtype p) (?m.343 x) ; identifiers [Œ±, u_1, MeasurableSpace, Œ±, p, a, Œ±, MeasurableSingletonClass, Œ±, x, Subtype, p, x, x, x, x] (during elaboration)

{o : Type u_5} {m' : (a : o) ‚Üí Type u_1} {n' : (a : o) ‚Üí Type u_2} {Œ± : Type u_3} {Œ≤ : Type u_4} [DecidableEq o] [Zero Œ±] [Zero Œ≤] (M : (i : o) ‚Üí Matrix m' i n' i Œ±) (f : (a : Œ±) ‚Üí Œ≤) (hf : f 0 = 0) (i : (i : o) √ó m' i) (x : (i : o) √ó n' i) (h : Sigma.fst i = Sigma.fst x)  : Sigma.fst x = Sigma.fst i
application type mismatch
  Matrix m'
argument
  m'
has type
  o ‚Üí Type u_1 : Type (max (u_1 + 1) u_5)
but is expected to have type
  Type ?u.47 : Type (?u.47 + 1) ; identifiers [o, u_5, m', a, o, u_1, n', a, o, u_2, Œ±, u_3, Œ≤, u_4, DecidableEq, o, Zero, Œ±, Zero, Œ≤, M, i, o, Matrix, m', i, n', i, Œ±, f, a, Œ±, Œ≤, hf, f, i, i, o, m', i, x, i, o, n', i, h, Sigma.fst, i, Sigma.fst, x, Sigma.fst, x, Sigma.fst, i] (during elaboration)

{C : Type u} [CategoryTheory.Category C] {F : CategoryTheory.Functor C ·µí·µñ Type w} (G : CategoryTheory.GrothendieckTopology.Subpresheaf F) (a : G = ‚ä§)  : ‚ä§ = G
function expected at
  CategoryTheory.Functor C·µí·µñ Type
term has type
  Type (max ?u.7 u 1) ; identifiers [C, u, CategoryTheory.Category, C, F, CategoryTheory.Functor, C, w, G, CategoryTheory.GrothendieckTopology.Subpresheaf, F, a, G, G] (during elaboration)

{Œ± : Type u} [inst : AddGroup Œ±] [LT Œ±] [CovariantClass Œ± Œ± fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1 fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] {a : Œ±} {b : Œ±} {c : Œ±} {Œ± : Type u} [AddGroup Œ±] [LT Œ±] [CovariantClass Œ± Œ± fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1 fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] {a : Œ±} {b : Œ±} {c : Œ±}  : ((- b + a < c : Prop) ‚Üî (a < b + c : Prop)) = ((- b + a < c : Prop) ‚Üî (a < b + c : Prop))
function expected at
  x_1
term has type
  Œ± ; identifiers [Œ±, u, inst, AddGroup, Œ±, LT, Œ±, CovariantClass, Œ±, Œ±, x, Œ±, x_1, Œ±, x, x_1, x, Œ±, x_1, Œ±, x, x_1, a, Œ±, b, Œ±, c, Œ±, Œ±, u, AddGroup, Œ±, LT, Œ±, CovariantClass, Œ±, Œ±, x, Œ±, x_1, Œ±, x, x_1, x, Œ±, x_1, Œ±, x, x_1, a, Œ±, b, Œ±, c, Œ±, b, a, c, a, b, c, b, a, c, a, b, c] (during elaboration)

{Œ± : Type u} [inst : AddGroup Œ±] [LT Œ±] [CovariantClass Œ± Œ± fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1 fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] {a : Œ±} {b : Œ±} {c : Œ±} {Œ± : Type u} [AddGroup Œ±] [LT Œ±] [CovariantClass Œ± Œ± fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1 fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] {a : Œ±} {b : Œ±} {c : Œ±}  : ((b + - b + a < b + c : Prop) ‚Üî (a < b + c : Prop)) = ((b + - b + a < b + c : Prop) ‚Üî (a < b + c : Prop))
function expected at
  x_1
term has type
  Œ± ; identifiers [Œ±, u, inst, AddGroup, Œ±, LT, Œ±, CovariantClass, Œ±, Œ±, x, Œ±, x_1, Œ±, x, x_1, x, Œ±, x_1, Œ±, x, x_1, a, Œ±, b, Œ±, c, Œ±, Œ±, u, AddGroup, Œ±, LT, Œ±, CovariantClass, Œ±, Œ±, x, Œ±, x_1, Œ±, x, x_1, x, Œ±, x_1, Œ±, x, x_1, a, Œ±, b, Œ±, c, Œ±, b, b, a, b, c, a, b, c, b, b, a, b, c, a, b, c] (during elaboration)

{Œ± : Type u} [inst : AddGroup Œ±] [LT Œ±] [CovariantClass Œ± Œ± fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1 fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] {a : Œ±} {b : Œ±} {c : Œ±} {Œ± : Type u} [AddGroup Œ±] [LT Œ±] [CovariantClass Œ± Œ± fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1 fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] {a : Œ±} {b : Œ±} {c : Œ±}  : (a < b + c) ‚Üî (a < b + c)
function expected at
  x_1
term has type
  Œ± ; identifiers [Œ±, u, inst, AddGroup, Œ±, LT, Œ±, CovariantClass, Œ±, Œ±, x, Œ±, x_1, Œ±, x, x_1, x, Œ±, x_1, Œ±, x, x_1, a, Œ±, b, Œ±, c, Œ±, Œ±, u, AddGroup, Œ±, LT, Œ±, CovariantClass, Œ±, Œ±, x, Œ±, x_1, Œ±, x, x_1, x, Œ±, x_1, Œ±, x, x_1, a, Œ±, b, Œ±, c, Œ±, a, b, c, a, b, c] (during elaboration)

{Œ± : Type u_1} (motive : (x : List Œ±) ‚Üí (x : List Œ±) ‚Üí Prop) (x : List Œ±) (x_1 : List Œ±) (h_1 : ‚àÄ (ys : List Œ±) , motive [] ys) (h_2 : ‚àÄ (xs : List Œ±) , motive xs []) (h_3 : ‚àÄ (x : Œ±) (xs : List Œ±) (y : Œ±) (ys : List Œ±) , motive x :: xs y :: ys) (head : Œ±) (tail : List Œ±)  : ‚àÄ (head_1 : Œ±) (tail_1 : List Œ±) , motive head :: tail head_1 :: tail_1
application type mismatch
  motive x
argument
  x
has type
  Œ± : Type u_1
but is expected to have type
  List Œ± : Type u_1 ; identifiers [Œ±, u_1, motive, x, List, Œ±, x, List, Œ±, x, List, Œ±, x_1, List, Œ±, h_1, ys, List, Œ±, motive, ys, h_2, xs, List, Œ±, motive, xs, h_3, x, Œ±, xs, List, Œ±, y, Œ±, ys, List, Œ±, motive, x, xs, y, ys, head, Œ±, tail, List, Œ±, head_1, Œ±, tail_1, List, Œ±, motive, head, tail, head_1, tail_1] (during elaboration)

{K : (a : Option Turing.PartrecToTM2.Œì') ‚Üí Finset Turing.PartrecToTM2.Œõ'} {S : Finset Turing.PartrecToTM2.Œõ'} (q : Turing.PartrecToTM2.Œõ')  : (‚àÄ (h : ‚àÉ (x : Option Turing.PartrecToTM2.Œì') , q ‚àà K x) , Turing.TM2.SupportsStmt S Turing.PartrecToTM2.tr q) = (‚àÄ (x : Option Turing.PartrecToTM2.Œì') (h : q ‚àà K x) , Turing.TM2.SupportsStmt S Turing.PartrecToTM2.tr q)
function expected at
  Turing.TM2.SupportsStmt S ?m.79267
term has type
  Prop ; identifiers [K, a, Option, Turing.PartrecToTM2.Œì', Finset, Turing.PartrecToTM2.Œõ', S, Finset, Turing.PartrecToTM2.Œõ', q, Turing.PartrecToTM2.Œõ', h, x, Option, Turing.PartrecToTM2.Œì', q, K, x, Turing.TM2.SupportsStmt, S, Turing.PartrecToTM2.tr, q, x, Option, Turing.PartrecToTM2.Œì', h, q, K, x, Turing.TM2.SupportsStmt, S, Turing.PartrecToTM2.tr, q] (during elaboration)

{a : ‚Ñù} {b : ‚Ñù} (hab : a < b) {l : Filter ‚Ñù} {f : (a : ‚Ñù) ‚Üí ‚Ñù} {g : (a : ‚Ñù) ‚Üí ‚Ñù} (hdf : DifferentiableOn ‚Ñù f Set.Ioo a b) (hcf : ContinuousOn f Set.Ico a b) (hcg : ContinuousOn g Set.Ico a b) (hg' : ‚àÄ (x : ‚Ñù) (a : x ‚àà Set.Ioo a b) , deriv g x ‚â† 0) (hfa : f a = 0) (hga : g a = 0) (hdiv : Filter.Tendsto fun (x : ‚Ñù) ‚Ü¶ deriv f x / deriv g x nhdsWithin a Set.Ioi a l)  : 0 = f a
application type mismatch
  DifferentiableOn ‚Ñù f Set.Ioo
argument
  Set.Ioo
has type
  ?m.48 ‚Üí ?m.48 ‚Üí Set ?m.48 : Type ?u.47
but is expected to have type
  Set ‚Ñù : Type ; identifiers [a, b, hab, a, b, l, Filter, f, a, g, a, hdf, DifferentiableOn, f, Set.Ioo, a, b, hcf, ContinuousOn, f, Set.Ico, a, b, hcg, ContinuousOn, g, Set.Ico, a, b, hg', x, a, x, Set.Ioo, a, b, deriv, g, x, hfa, f, a, hga, g, a, hdiv, Filter.Tendsto, x, deriv, f, x, deriv, g, x, nhdsWithin, a, Set.Ioi, a, l, f, a] (during elaboration)

 : (‚àÄ {Œ± : Type u_1} [inst : MetricSpace Œ±] {m : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} (self : VitaliFamily Œº) (s : Set Œ±) (f : (x : Œ±) ‚Üí Set Set Œ±) (a : ‚àÄ (x : Œ±) (a : x ‚àà s) , f x ‚äÜ VitaliFamily.setsAt self x) (a : ‚àÄ (x : Œ±) (a : x ‚àà s) (Œµ : ‚Ñù) (a : Œµ > 0) , ‚àÉ (a : Set Œ±) , (a ‚àà f x : Prop) ‚àß (a ‚äÜ Metric.closedBall x Œµ : Prop)) , ‚àÉ (t : Set Œ± √ó Set Œ±) , (‚àÄ (p : Œ± √ó Set Œ±) (a : p ‚àà t) , Prod.fst p ‚àà s : Prop) ‚àß ((Set.PairwiseDisjoint t fun (p : Œ± √ó Set Œ±) ‚Ü¶ Prod.snd p : Prop) ‚àß ((‚àÄ (p : Œ± √ó Set Œ±) (a : p ‚àà t) , Prod.snd p ‚àà f Prod.fst p : Prop) ‚àß (‚Üë ‚Üë Œº s \ ‚ãÉ (p : Œ± √ó Set Œ±) (_ : p ‚àà t) , Prod.snd p = 0 : Prop) : Prop) : Prop))
application type mismatch
  Set Set
argument
  Set
has type
  Type ?u.107 ‚Üí Type ?u.107 : Type (?u.107 + 1)
but is expected to have type
  Type ?u.106 : Type (?u.106 + 1) ; identifiers [Œ±, u_1, inst, MetricSpace, Œ±, m, MeasurableSpace, Œ±, Œº, MeasureTheory.Measure, Œ±, self, VitaliFamily, Œº, s, Set, Œ±, f, x, Œ±, Set, Set, Œ±, a, x, Œ±, a, x, s, f, x, VitaliFamily.setsAt, self, x, a, x, Œ±, a, x, s, Œµ, a, Œµ, a, Set, Œ±, a, f, x, a, Metric.closedBall, x, Œµ, t, Set, Œ±, Set, Œ±, p, Œ±, Set, Œ±, a, p, t, Prod.fst, p, s, Set.PairwiseDisjoint, t, p, Œ±, Set, Œ±, Prod.snd, p, p, Œ±, Set, Œ±, a, p, t, Prod.snd, p, f, Prod.fst, p, Œº, s, p, Œ±, Set, Œ±, p, t, Prod.snd, p] (during elaboration)

 : ‚àÄ (Œ± : Type u_1) [inst : MetricSpace Œ±] (m : MeasurableSpace Œ±) (Œº : MeasureTheory.Measure Œ±) (self : VitaliFamily Œº) (s : Set Œ±) (f : (x : Œ±) ‚Üí Set Set Œ±) (a : ‚àÄ (x : Œ±) (a : x ‚àà s) , f x ‚äÜ self . 1 x) (a : ‚àÄ (x : Œ±) (a : x ‚àà s) (Œµ : ‚Ñù) (a : Œµ > 0) , ‚àÉ (a : Set Œ±) , (a ‚àà f x) ‚àß (a ‚äÜ Metric.closedBall x Œµ)) , ‚àÉ (t : Set Œ± √ó Set Œ±) , (‚àÄ (p : Œ± √ó Set Œ±) (a : p ‚àà t) , Prod.fst p ‚àà s) ‚àß ((Set.PairwiseDisjoint t fun (p : Œ± √ó Set Œ±) ‚Ü¶ Prod.snd p : Prop) ‚àß ((‚àÄ (p : Œ± √ó Set Œ±) (a : p ‚àà t) , Prod.snd p ‚àà f Prod.fst p : Prop) ‚àß (‚Üë ‚Üë Œº s \ ‚ãÉ (p : Œ± √ó Set Œ±) (_ : p ‚àà t) , Prod.snd p = 0 : Prop) : Prop))
application type mismatch
  Set Set
argument
  Set
has type
  Type ?u.107 ‚Üí Type ?u.107 : Type (?u.107 + 1)
but is expected to have type
  Type ?u.106 : Type (?u.106 + 1) ; identifiers [Œ±, u_1, inst, MetricSpace, Œ±, m, MeasurableSpace, Œ±, Œº, MeasureTheory.Measure, Œ±, self, VitaliFamily, Œº, s, Set, Œ±, f, x, Œ±, Set, Set, Œ±, a, x, Œ±, a, x, s, f, x, self, x, a, x, Œ±, a, x, s, Œµ, a, Œµ, a, Set, Œ±, a, f, x, a, Metric.closedBall, x, Œµ, t, Set, Œ±, Set, Œ±, p, Œ±, Set, Œ±, a, p, t, Prod.fst, p, s, Set.PairwiseDisjoint, t, p, Œ±, Set, Œ±, Prod.snd, p, p, Œ±, Set, Œ±, a, p, t, Prod.snd, p, f, Prod.fst, p, Œº, s, p, Œ±, Set, Œ±, p, t, Prod.snd, p] (during elaboration)

{a : ‚Ñù} {b : ‚Ñù} (hab : a < b) {l : Filter ‚Ñù} {f : (a : ‚Ñù) ‚Üí ‚Ñù} {g : (a : ‚Ñù) ‚Üí ‚Ñù} (hdf : DifferentiableOn ‚Ñù f Set.Ioo a b) (hcf : ContinuousOn f Set.Ico a b) (hcg : ContinuousOn g Set.Ico a b) (hg' : ‚àÄ (x : ‚Ñù) (a : x ‚àà Set.Ioo a b) , deriv g x ‚â† 0) (hfa : f a = 0) (hga : g a = 0) (hdiv : Filter.Tendsto fun (x : ‚Ñù) ‚Ü¶ deriv f x / deriv g x nhdsWithin a Set.Ioi a l)  : 0 = g a
application type mismatch
  DifferentiableOn ‚Ñù f Set.Ioo
argument
  Set.Ioo
has type
  ?m.48 ‚Üí ?m.48 ‚Üí Set ?m.48 : Type ?u.47
but is expected to have type
  Set ‚Ñù : Type ; identifiers [a, b, hab, a, b, l, Filter, f, a, g, a, hdf, DifferentiableOn, f, Set.Ioo, a, b, hcf, ContinuousOn, f, Set.Ico, a, b, hcg, ContinuousOn, g, Set.Ico, a, b, hg', x, a, x, Set.Ioo, a, b, deriv, g, x, hfa, f, a, hga, g, a, hdiv, Filter.Tendsto, x, deriv, f, x, deriv, g, x, nhdsWithin, a, Set.Ioi, a, l, g, a] (during elaboration)

{R : Type u} {A : Type v} {B : Type w} {inst : Monoid R} {inst_1 : NonUnitalNonAssocSemiring A} {inst_2 : DistribMulAction R A} {inst_3 : NonUnitalNonAssocSemiring B} {inst_4 : DistribMulAction R B} {toDistribMulActionHom : A ‚Üí+[R] B} {map_mul' : ‚àÄ (x : A) (y : A) , MulActionHom.toFun DistribMulActionHom.toMulActionHom toDistribMulActionHom x * y = MulActionHom.toFun DistribMulActionHom.toMulActionHom toDistribMulActionHom x * MulActionHom.toFun DistribMulActionHom.toMulActionHom toDistribMulActionHom y} {toDistribMulActionHom_1 : A ‚Üí+[R] B} {map_mul'_1 : ‚àÄ (x : A) (y : A) , MulActionHom.toFun DistribMulActionHom.toMulActionHom toDistribMulActionHom_1 x * y = MulActionHom.toFun DistribMulActionHom.toMulActionHom toDistribMulActionHom_1 x * MulActionHom.toFun DistribMulActionHom.toMulActionHom toDistribMulActionHom_1 y} (x : {toDistribMulActionHom := ((toDistribMulActionHom)) , map_mul' := ((map_mul'))} = {toDistribMulActionHom := ((toDistribMulActionHom_1)) , map_mul' := ((map_mul'_1))})  : ‚àÄ (toDistribMulActionHom_eq : toDistribMulActionHom = toDistribMulActionHom_1) , toDistribMulActionHom = toDistribMulActionHom_1
function expected at
  MulActionHom.toFun ?m.84462 toDistribMulActionHom
term has type
  ?m.82400 ; identifiers [R, u, A, v, B, w, inst, Monoid, R, inst_1, NonUnitalNonAssocSemiring, A, inst_2, DistribMulAction, R, A, inst_3, NonUnitalNonAssocSemiring, B, inst_4, DistribMulAction, R, B, toDistribMulActionHom, A, R, B, A, R, B, map_mul', x, A, y, A, MulActionHom.toFun, DistribMulActionHom.toMulActionHom, toDistribMulActionHom, x, y, MulActionHom.toFun, DistribMulActionHom.toMulActionHom, toDistribMulActionHom, x, MulActionHom.toFun, DistribMulActionHom.toMulActionHom, toDistribMulActionHom, y, toDistribMulActionHom_1, A, R, B, A, R, B, map_mul'_1, x, A, y, A, MulActionHom.toFun, DistribMulActionHom.toMulActionHom, toDistribMulActionHom_1, x, y, MulActionHom.toFun, DistribMulActionHom.toMulActionHom, toDistribMulActionHom_1, x, MulActionHom.toFun, DistribMulActionHom.toMulActionHom, toDistribMulActionHom_1, y, x, toDistribMulActionHom, toDistribMulActionHom, map_mul', map_mul', toDistribMulActionHom, toDistribMulActionHom_1, map_mul', map_mul'_1, toDistribMulActionHom_eq, toDistribMulActionHom, toDistribMulActionHom_1, toDistribMulActionHom, toDistribMulActionHom_1] (during elaboration)

{Œπ : Type u_1} [Countable Œπ] {E : (a : Œπ) ‚Üí Type u_2} [(i : Œπ) ‚Üí TopologicalSpace E i] [‚àÄ (i : Œπ) , PolishSpace E i] (val : Encodable Œπ) (h : (nonempty_encodable Œπ =: Nonempty Encodable Œπ) = (Nonempty.intro val =: Nonempty Encodable Œπ))  : Nonempty.intro val = nonempty_encodable Œπ
<input>:1:165: expected term

 : ‚àÄ (Œ± : Type u_1) (self : MeasureTheory.OuterMeasure Œ±) , self . 1 ‚àÖ = 0
invalid occurrence of `¬∑` notation, it must be surrounded by parentheses (e.g. `(¬∑ + 1)`) ; identifiers [Œ±, u_1, self, MeasureTheory.OuterMeasure, Œ±, self] (during elaboration)

{Œπ : Type u_1} {Œ± : (a : Œπ) ‚Üí Type u_2} {t : (i : Œπ) ‚Üí Set Œ± i} {f : (i : Œπ) ‚Üí Œ± i} (i : Œπ)  : (f i ‚àà t i) = (f i ‚àà t i)
application type mismatch
  Set Œ±
argument
  Œ±
has type
  Œπ ‚Üí Type u_2 : Type (max u_1 (u_2 + 1))
but is expected to have type
  Type ?u.15 : Type (?u.15 + 1) ; identifiers [Œπ, u_1, Œ±, a, Œπ, u_2, t, i, Œπ, Set, Œ±, i, f, i, Œπ, Œ±, i, i, Œπ, f, i, t, i, f, i, t, i] (during elaboration)

{n : ‚Ñï} (c : CompositionAsSet n) (j : Fin n + 1) (a : ‚àÉ (a : Fin Composition.length CompositionAsSet.toComposition c + 1) , (a ‚àà Finset.univ : Prop) ‚àß (‚Üë RelEmbedding.toEmbedding Composition.boundary CompositionAsSet.toComposition c a = j : Prop)) (i : Fin Composition.length CompositionAsSet.toComposition c + 1) (h : (i ‚àà Finset.univ : Prop) ‚àß (‚Üë RelEmbedding.toEmbedding Composition.boundary CompositionAsSet.toComposition c i = j : Prop)) (left : i ‚àà Finset.univ) (hi : ‚Üë RelEmbedding.toEmbedding Composition.boundary CompositionAsSet.toComposition c i = j)  : j = ‚Üë RelEmbedding.toEmbedding Composition.boundary CompositionAsSet.toComposition c i
application type mismatch
  Fin Composition.length
argument
  Composition.length
has type
  Composition ?m.1144 ‚Üí ‚Ñï : Type
but is expected to have type
  ‚Ñï : Type ; identifiers [n, c, CompositionAsSet, n, j, Fin, n, a, a, Fin, Composition.length, CompositionAsSet.toComposition, c, a, Finset.univ, RelEmbedding.toEmbedding, Composition.boundary, CompositionAsSet.toComposition, c, a, j, i, Fin, Composition.length, CompositionAsSet.toComposition, c, h, i, Finset.univ, RelEmbedding.toEmbedding, Composition.boundary, CompositionAsSet.toComposition, c, i, j, left, i, Finset.univ, hi, RelEmbedding.toEmbedding, Composition.boundary, CompositionAsSet.toComposition, c, i, j, j, RelEmbedding.toEmbedding, Composition.boundary, CompositionAsSet.toComposition, c, i] (during elaboration)

 : (‚àÄ {S‚ÇÅ : Type u_1} {S‚ÇÇ : Type u_2} [inst : Shelf S‚ÇÅ] [inst_1 : Shelf S‚ÇÇ] (self : ShelfHom S‚ÇÅ S‚ÇÇ) {x : S‚ÇÅ} {y : S‚ÇÅ} , ShelfHom.toFun self Shelf.act x y = Shelf.act ShelfHom.toFun self x ShelfHom.toFun self y)
application type mismatch
  ShelfHom.toFun self Shelf.act
argument
  Shelf.act
has type
  ?m.49 ‚Üí ?m.49 ‚Üí ?m.49 : Type ?u.48
but is expected to have type
  S‚ÇÅ : Type u_1 ; identifiers [S‚ÇÅ, u_1, S‚ÇÇ, u_2, inst, Shelf, S‚ÇÅ, inst_1, Shelf, S‚ÇÇ, self, ShelfHom, S‚ÇÅ, S‚ÇÇ, x, S‚ÇÅ, y, S‚ÇÅ, ShelfHom.toFun, self, Shelf.act, x, y, Shelf.act, ShelfHom.toFun, self, x, ShelfHom.toFun, self, y] (during elaboration)

 : ‚àÄ (S‚ÇÅ : Type u_1) (S‚ÇÇ : Type u_2) [inst : Shelf S‚ÇÅ] [inst_1 : Shelf S‚ÇÇ] (self : ShelfHom S‚ÇÅ S‚ÇÇ) {x : S‚ÇÅ} {y : S‚ÇÅ} , self . 1 Shelf.act x y = Shelf.act self . 1 x self . 1 y
invalid occurrence of `¬∑` notation, it must be surrounded by parentheses (e.g. `(¬∑ + 1)`) ; identifiers [S‚ÇÅ, u_1, S‚ÇÇ, u_2, inst, Shelf, S‚ÇÅ, inst_1, Shelf, S‚ÇÇ, self, ShelfHom, S‚ÇÅ, S‚ÇÇ, x, S‚ÇÅ, y, S‚ÇÅ, self, Shelf.act, x, y, Shelf.act, self, x, self, y] (during elaboration)

{c : ‚Ñù} (hc : 1 < c) (i : ‚Ñï) (cpos : 0 < c) (hi : i > 0) hident : 1 ‚â§ i := hi  : c = c ^ Nat.rawCast 1 * Nat.rawCast 1 + 0
<input>:1:64: expected end of input

{c : ‚Ñù} (hc : 1 < c) (i : ‚Ñï) (cpos : 0 < c) (hi : i > 0) hident : 1 ‚â§ i := hi  : c ‚Åª¬π = c ‚Åª¬π
<input>:1:64: expected end of input

{Œ± : Type u_2} {M : Type u_1} [OrderedAddCommMonoid M] (i : Œ±) {f : (a : Œ±) ‚Üí M} (hf : Set.Finite Function.support f) (h : ‚àÄ (j : Œ±) , 0 ‚â§ f j)  : ‚àÄ (j : Œ±) (x : j ‚àà insert i Set.Finite.toFinset hf) , 0 ‚â§ f j
function expected at
  Set.Finite ?m.841
term has type
  Prop ; identifiers [Œ±, u_2, M, u_1, OrderedAddCommMonoid, M, i, Œ±, f, a, Œ±, M, hf, Set.Finite, Function.support, f, h, j, Œ±, f, j, j, Œ±, x, j, insert, i, Set.Finite.toFinset, hf, f, j] (during elaboration)

{c : ‚Ñù} (hc : 1 < c) (i : ‚Ñï) (cpos : 0 < c) (hi : i > 0) hident : 1 ‚â§ i := hi  : - 0 = 0
<input>:1:64: expected end of input

{Œ≤ : Type u_1} [SeminormedAddCommGroup Œ≤] [NormedSpace ‚Ñù Œ≤] {t : ‚Ñù} (ht : 0 ‚â§ t) (x : Œ≤)  : (‚Äñ t ‚Ä¢ x ‚Äñ = t * ‚Äñ x ‚Äñ) = (‚Äñ t ‚Ä¢ x ‚Äñ = t * ‚Äñ x ‚Äñ)
<input>:1:103: expected term

{Œ≤ : Type u_1} [SeminormedAddCommGroup Œ≤] [NormedSpace ‚Ñù Œ≤] {t : ‚Ñù} (ht : 0 ‚â§ t) (x : Œ≤)  : (‚Äñ t ‚Äñ * ‚Äñ x ‚Äñ = t * ‚Äñ x ‚Äñ) = (‚Äñ t ‚Äñ * ‚Äñ x ‚Äñ = t * ‚Äñ x ‚Äñ)
<input>:1:99: expected term

{c : ‚Ñù} (hc : 1 < c) (i : ‚Ñï) (cpos : 0 < c) (hi : i > 0) hident : 1 ‚â§ i := hi  : i = i ^ Nat.rawCast 1 * Nat.rawCast 1 + 0
<input>:1:64: expected end of input

{Œ≤ : Type u_1} [SeminormedAddCommGroup Œ≤] [NormedSpace ‚Ñù Œ≤] {t : ‚Ñù} (ht : 0 ‚â§ t) (x : Œ≤)  : (| t | * ‚Äñ x ‚Äñ = t * ‚Äñ x ‚Äñ) = (| t | * ‚Äñ x ‚Äñ = t * ‚Äñ x ‚Äñ)
<input>:1:93: expected ')', '_', '‚Üë', '‚Ü•', '‚áë', identifier or no space before

{Œ≤ : Type u_1} [SeminormedAddCommGroup Œ≤] [NormedSpace ‚Ñù Œ≤] {t : ‚Ñù} (ht : 0 ‚â§ t) (x : Œ≤)  : t * ‚Äñ x ‚Äñ = t * ‚Äñ x ‚Äñ
<input>:1:102: expected term

{Œπ : Type u} {X : Type v} [TopologicalSpace X] {E : Type u_1} [AddCommMonoid E] [SMulWithZero ‚Ñù E] [TopologicalSpace E] [ContinuousSMul ‚Ñù E] {s : Set X} (f : PartitionOfUnity Œπ X s) [ContinuousAdd E] {g : (a : Œπ) ‚Üí (a : X) ‚Üí E} (hg : ‚àÄ (i : Œπ) (x : X) (a : x ‚àà tsupport ‚Üë ‚Üë f i) , ContinuousAt g i x) (i : Œπ)  : ‚àÄ (x : X) (a : x ‚àà tsupport ‚Üë ‚Üë f i) , ContinuousAt g i x
failed to synthesize instance
  TopologicalSpace Œπ ; identifiers [Œπ, u, X, v, TopologicalSpace, X, E, u_1, AddCommMonoid, E, SMulWithZero, E, TopologicalSpace, E, ContinuousSMul, E, s, Set, X, f, PartitionOfUnity, Œπ, X, s, ContinuousAdd, E, g, a, Œπ, a, X, E, hg, i, Œπ, x, X, a, x, tsupport, f, i, ContinuousAt, g, i, x, i, Œπ, x, X, a, x, tsupport, f, i, ContinuousAt, g, i, x] (during elaboration)

{E : Type u_1} [SeminormedAddGroup E] (a : E)  : (0 ‚â§ ‚Äñ a ‚Äñ) = (0 ‚â§ ‚Äñ a ‚Äñ)
<input>:1:59: expected term

{Œ≤ : Type u_1} [LinearOrder Œ≤] [NoMaxOrder Œ≤] {u : (a : ‚Ñï) ‚Üí Œ≤} (hu : Filter.Tendsto u Filter.atTop Filter.atTop) (œÜ : (a : ‚Ñï) ‚Üí ‚Ñï) (h : StrictMono œÜ) (h' : ‚àÄ (n : ‚Ñï) (k : ‚Ñï) (a : k < œÜ n) , u k < u œÜ n) (x : ‚Ñï) (m : ‚Ñï) (hnm : x < m)  : œÜ x < œÜ m
application type mismatch
  u œÜ
argument
  œÜ
has type
  ‚Ñï ‚Üí ‚Ñï : Type
but is expected to have type
  ‚Ñï : Type ; identifiers [Œ≤, u_1, LinearOrder, Œ≤, NoMaxOrder, Œ≤, u, a, Œ≤, hu, Filter.Tendsto, u, Filter.atTop, Filter.atTop, œÜ, a, h, StrictMono, œÜ, h', n, k, a, k, œÜ, n, u, k, u, œÜ, n, x, m, hnm, x, m, œÜ, x, œÜ, m] (during elaboration)

{Œ± : Type u_3} {M : Type u_2} {M' : Type u_1} {N : Type u_4} [Zero M] [Zero M'] [CommMonoid N] {f : (a : M) ‚Üí M'} {hf : f 0 = 0} {g : Œ± ‚Üí‚ÇÄ M} {h : (a : Œ±) ‚Üí (a : M') ‚Üí N} (h0 : ‚àÄ (a : Œ±) , h a 0 = 1) (x : Œ±) (x_1 : x ‚àà Finsupp.support g) (H : ¬¨ (x ‚àà Finsupp.support Finsupp.mapRange f hf g : Prop))  : h x 0 = 1
function expected at
  ?m.83122.support
term has type
  Finset ?m.1260 ; identifiers [Œ±, u_3, M, u_2, M', u_1, N, u_4, Zero, M, Zero, M', CommMonoid, N, f, a, M, M', hf, f, g, Œ±, M, h, a, Œ±, a, M', N, h0, a, Œ±, h, a, x, Œ±, x_1, x, Finsupp.support, g, H, x, Finsupp.support, Finsupp.mapRange, f, hf, g, h, x] (during elaboration)

{Œ± : Type u_3} {M : Type u_2} {M' : Type u_1} {N : Type u_4} [Zero M] [Zero M'] [CommMonoid N] {f : (a : M) ‚Üí M'} {hf : f 0 = 0} {g : Œ± ‚Üí‚ÇÄ M} {h : (a : Œ±) ‚Üí (a : M') ‚Üí N} (h0 : ‚àÄ (a : Œ±) , h a 0 = 1) (x : Œ±) (x_1 : x ‚àà Finsupp.support g) (H : ¬¨ (x ‚àà Finsupp.support Finsupp.mapRange f hf g : Prop))  : (h x 0 = 1) = (h x 0 = 1)
function expected at
  ?m.83122.support
term has type
  Finset ?m.1260 ; identifiers [Œ±, u_3, M, u_2, M', u_1, N, u_4, Zero, M, Zero, M', CommMonoid, N, f, a, M, M', hf, f, g, Œ±, M, h, a, Œ±, a, M', N, h0, a, Œ±, h, a, x, Œ±, x_1, x, Finsupp.support, g, H, x, Finsupp.support, Finsupp.mapRange, f, hf, g, h, x, h, x] (during elaboration)

{Œ± : Type u_3} {M : Type u_2} {M' : Type u_1} {N : Type u_4} [Zero M] [Zero M'] [CommMonoid N] {f : (a : M) ‚Üí M'} {hf : f 0 = 0} {g : Œ± ‚Üí‚ÇÄ M} {h : (a : Œ±) ‚Üí (a : M') ‚Üí N} (h0 : ‚àÄ (a : Œ±) , h a 0 = 1) (x : Œ±) (x_1 : x ‚àà Finsupp.support g) (H : ¬¨ (x ‚àà Finsupp.support Finsupp.mapRange f hf g : Prop))  : 1 = 1
function expected at
  ?m.83122.support
term has type
  Finset ?m.1260 ; identifiers [Œ±, u_3, M, u_2, M', u_1, N, u_4, Zero, M, Zero, M', CommMonoid, N, f, a, M, M', hf, f, g, Œ±, M, h, a, Œ±, a, M', N, h0, a, Œ±, h, a, x, Œ±, x_1, x, Finsupp.support, g, H, x, Finsupp.support, Finsupp.mapRange, f, hf, g] (during elaboration)

(Œ± : Type u_1) (r : {r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop // IsWellOrder Œ± r}) (wo : fun (r : {r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop // IsWellOrder Œ± r}) ‚Ü¶ Ordinal.type ‚Üë r r = ‚®Ö (r : {r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop // IsWellOrder Œ± r}) , Ordinal.type ‚Üë r)  : ‚®Ö (r : {r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop // IsWellOrder Œ± r}) , Ordinal.type ‚Üë r = fun (r : {r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop // IsWellOrder Œ± r}) ‚Ü¶ Ordinal.type ‚Üë r r
type mismatch
  r
has type
  { r // IsWellOrder Œ± r } : Type u_1
but is expected to have type
  ?m.45 ‚Üí ?m.45 ‚Üí Prop : Type ?u.44 ; identifiers [Œ±, u_1, r, r, a, Œ±, a, Œ±, IsWellOrder, Œ±, r, wo, r, r, a, Œ±, a, Œ±, IsWellOrder, Œ±, r, Ordinal.type, r, r, r, r, a, Œ±, a, Œ±, IsWellOrder, Œ±, r, Ordinal.type, r, r, r, a, Œ±, a, Œ±, IsWellOrder, Œ±, r, Ordinal.type, r, r, r, a, Œ±, a, Œ±, IsWellOrder, Œ±, r, Ordinal.type, r, r] (during elaboration)

(Œ± : Type u_1) (Œ≤ : Type u_2) [UniformSpace Œ≤] (ùîñ : Set Set Œ±) (i : Set Œ±)  : (i ‚àà ùîñ) = (i ‚àà ùîñ)
application type mismatch
  Set Set
argument
  Set
has type
  Type ?u.14 ‚Üí Type ?u.14 : Type (?u.14 + 1)
but is expected to have type
  Type ?u.13 : Type (?u.13 + 1) ; identifiers [Œ±, u_1, Œ≤, u_2, UniformSpace, Œ≤, ùîñ, Set, Set, Œ±, i, Set, Œ±, i, ùîñ, i, ùîñ] (during elaboration)

{Œ± : Type u_2} {Œ≤ : Type u_4} {Œ≤' : Type u_3} {Œ≥ : Type u_1} {Œ¥ : Type u_5} {f : Filter Œ±} {g : Filter Œ≤} {m : (a : Œ±) ‚Üí (a : Œ≤') ‚Üí Œ≥} {n : (a : Œ≤) ‚Üí Œ≤'} {m' : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Œ¥} {n' : (a : Œ¥) ‚Üí Œ≥} (h_right_comm : ‚àÄ (a : Œ±) (b : Œ≤) , m a n b = n' m' a b) (a : Œ±) (b : Œ≤)  : m a n b = n' m' a b
application type mismatch
  m a n
argument
  n
has type
  Œ≤ ‚Üí Œ≤' : Type (max u_3 u_4)
but is expected to have type
  Œ≤' : Type u_3 ; identifiers [Œ±, u_2, Œ≤, u_4, Œ≤', u_3, Œ≥, u_1, Œ¥, u_5, f, Filter, Œ±, g, Filter, Œ≤, m, a, Œ±, a, Œ≤', Œ≥, n, a, Œ≤, Œ≤', m', a, Œ±, a, Œ≤, Œ¥, n', a, Œ¥, Œ≥, h_right_comm, a, Œ±, b, Œ≤, m, a, n, b, n', m', a, b, a, Œ±, b, Œ≤, m, a, n, b, n', m', a, b] (during elaboration)

(Œ± : Type u_1) (Œ≤ : Type u_2) [UniformSpace Œ≤] (ùîñ : Set Set Œ±) (s : Set Œ±)  : (s ‚àà ùîñ) = (s ‚àà ùîñ)
application type mismatch
  Set Set
argument
  Set
has type
  Type ?u.14 ‚Üí Type ?u.14 : Type (?u.14 + 1)
but is expected to have type
  Type ?u.13 : Type (?u.13 + 1) ; identifiers [Œ±, u_1, Œ≤, u_2, UniformSpace, Œ≤, ùîñ, Set, Set, Œ±, s, Set, Œ±, s, ùîñ, s, ùîñ] (during elaboration)

{M : Type u_2} {N : Type u_1} [MulOneClass M] [MulOneClass N] (f : M ‚Üí* N) (hf : ‚àÄ (x : M) (y : M) , Commute ‚Üë f x ‚Üë f y) (x : M) (y : M)  : Commute ‚Üë f x ‚Üë f y
function expected at
  Commute ?m.42 x
term has type
  Prop ; identifiers [M, u_2, N, u_1, MulOneClass, M, MulOneClass, N, f, M, N, hf, x, M, y, M, Commute, f, x, f, y, x, M, y, M, Commute, f, x, f, y] (during elaboration)

{Œ± : Type u_1} {m : MeasurableSpace Œ±} {M : Type u_2} [TopologicalSpace M] [OrderedAddCommMonoid M] [OrderClosedTopology M] (v : MeasureTheory.VectorMeasure Œ± M) (w : MeasureTheory.VectorMeasure Œ± M) {f : (a : ‚Ñï) ‚Üí Set Œ±} (hf‚ÇÅ : ‚àÄ (n : ‚Ñï) , MeasurableSet f n) (hf‚ÇÇ : ‚àÄ (n : ‚Ñï) , MeasureTheory.VectorMeasure.restrict v f n ‚â§ MeasureTheory.VectorMeasure.restrict w f n) (a : Set Œ±) (ha‚ÇÅ : MeasurableSet a) (ha‚ÇÇ : a ‚äÜ ‚ãÉ (n : ‚Ñï) , f n) (ha‚ÇÉ : ‚ãÉ (n : ‚Ñï) , a ‚à© disjointed f n = a) (ha‚ÇÑ : Pairwise Disjoint on fun (n : ‚Ñï) ‚Ü¶ a ‚à© disjointed f n)  : a = ‚ãÉ (n : ‚Ñï) , a ‚à© disjointed f n
function expected at
  MeasurableSet ?m.1001
term has type
  Prop ; identifiers [Œ±, u_1, m, MeasurableSpace, Œ±, M, u_2, TopologicalSpace, M, OrderedAddCommMonoid, M, OrderClosedTopology, M, v, MeasureTheory.VectorMeasure, Œ±, M, w, MeasureTheory.VectorMeasure, Œ±, M, f, a, Set, Œ±, hf‚ÇÅ, n, MeasurableSet, f, n, hf‚ÇÇ, n, MeasureTheory.VectorMeasure.restrict, v, f, n, MeasureTheory.VectorMeasure.restrict, w, f, n, a, Set, Œ±, ha‚ÇÅ, MeasurableSet, a, ha‚ÇÇ, a, n, f, n, ha‚ÇÉ, n, a, disjointed, f, n, a, ha‚ÇÑ, Pairwise, Disjoint, n, a, disjointed, f, n, a, n, a, disjointed, f, n] (during elaboration)

{Œ± : Type u_1} {m : MeasurableSpace Œ±} {M : Type u_2} [TopologicalSpace M] [OrderedAddCommMonoid M] [OrderClosedTopology M] (v : MeasureTheory.VectorMeasure Œ± M) (w : MeasureTheory.VectorMeasure Œ± M) {f : (a : ‚Ñï) ‚Üí Set Œ±} (hf‚ÇÅ : ‚àÄ (n : ‚Ñï) , MeasurableSet f n) (hf‚ÇÇ : ‚àÄ (n : ‚Ñï) , MeasureTheory.VectorMeasure.restrict v f n ‚â§ MeasureTheory.VectorMeasure.restrict w f n) (a : Set Œ±) (ha‚ÇÅ : MeasurableSet a) (ha‚ÇÇ : a ‚äÜ ‚ãÉ (n : ‚Ñï) , f n) (ha‚ÇÉ : ‚ãÉ (n : ‚Ñï) , a ‚à© disjointed f n = a) (ha‚ÇÑ : Pairwise Disjoint on fun (n : ‚Ñï) ‚Ü¶ a ‚à© disjointed f n)  : ((‚Üë v a ‚â§ ‚Üë w a : Prop)) = ((‚Üë v a ‚â§ ‚Üë w a : Prop))
function expected at
  MeasurableSet ?m.1001
term has type
  Prop ; identifiers [Œ±, u_1, m, MeasurableSpace, Œ±, M, u_2, TopologicalSpace, M, OrderedAddCommMonoid, M, OrderClosedTopology, M, v, MeasureTheory.VectorMeasure, Œ±, M, w, MeasureTheory.VectorMeasure, Œ±, M, f, a, Set, Œ±, hf‚ÇÅ, n, MeasurableSet, f, n, hf‚ÇÇ, n, MeasureTheory.VectorMeasure.restrict, v, f, n, MeasureTheory.VectorMeasure.restrict, w, f, n, a, Set, Œ±, ha‚ÇÅ, MeasurableSet, a, ha‚ÇÇ, a, n, f, n, ha‚ÇÉ, n, a, disjointed, f, n, a, ha‚ÇÑ, Pairwise, Disjoint, n, a, disjointed, f, n, v, a, w, a, v, a, w, a] (during elaboration)

{Œ± : Type u} [AddGroup Œ±] [LE Œ±] [CovariantClass Œ± Œ± fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1 fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±} {b : Œ±}  : ((0 ‚â§ - b + a : Prop) ‚Üî (b ‚â§ a : Prop)) = ((0 ‚â§ - b + a : Prop) ‚Üî (b ‚â§ a : Prop))
function expected at
  x_1
term has type
  Œ± ; identifiers [Œ±, u, AddGroup, Œ±, LE, Œ±, CovariantClass, Œ±, Œ±, x, Œ±, x_1, Œ±, x, x_1, x, Œ±, x_1, Œ±, x, x_1, a, Œ±, b, Œ±, b, a, b, a, b, a, b, a] (during elaboration)

{Œ± : Type u_1} {Œ≤ : Type u_2} {rŒ± : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop} {rŒ≤ : (a : Œ≤) ‚Üí (a : Œ≤) ‚Üí Prop} (f : (a : Œ±) ‚Üí Œ≤) (fib : Relation.Fibration rŒ± rŒ≤ f) {a : Œ±} (ha : Acc rŒ± a) (a : Œ±) (h : ‚àÄ (y : Œ±) (a : rŒ± y a) , Acc rŒ± y) (ih : ‚àÄ (y : Œ±) (a : rŒ± y a) , Acc rŒ≤ f y) (b : Œ≤) (hr : rŒ≤ b f a)  : ‚àÉ (a' : Œ±) , (rŒ± a' a) ‚àß (f a' = b)
application type mismatch
  Acc rŒ≤ f
argument
  f
has type
  Œ± ‚Üí Œ≤ : Type (max u_1 u_2)
but is expected to have type
  Œ≤ : Type u_2 ; identifiers [Œ±, u_1, Œ≤, u_2, rŒ±, a, Œ±, a, Œ±, rŒ≤, a, Œ≤, a, Œ≤, f, a, Œ±, Œ≤, fib, Relation.Fibration, rŒ±, rŒ≤, f, a, Œ±, ha, Acc, rŒ±, a, a, Œ±, h, y, Œ±, a, rŒ±, y, a, Acc, rŒ±, y, ih, y, Œ±, a, rŒ±, y, a, Acc, rŒ≤, f, y, b, Œ≤, hr, rŒ≤, b, f, a, a', Œ±, rŒ±, a', a, f, a', b] (during elaboration)

{M : Type u_1} [AddMonoid M] [LinearOrder M] [CovariantClass M M fun (x : M) (x_1 : M) ‚Ü¶ x + x_1 fun (x : M) (x_1 : M) ‚Ü¶ x ‚â§ x_1] {x : M} {n : ‚Ñï} (hn : n ‚â† 0)  : (((n ‚Ä¢ x ‚â§ 0 : Prop) ‚àß (0 ‚â§ n ‚Ä¢ x : Prop) : Prop) ‚Üî ((x ‚â§ 0 : Prop) ‚àß (0 ‚â§ x : Prop) : Prop)) = (((n ‚Ä¢ x ‚â§ 0 : Prop) ‚àß (0 ‚â§ n ‚Ä¢ x : Prop) : Prop) ‚Üî ((x ‚â§ 0 : Prop) ‚àß (0 ‚â§ x : Prop) : Prop))
function expected at
  x_1
term has type
  M ; identifiers [M, u_1, AddMonoid, M, LinearOrder, M, CovariantClass, M, M, x, M, x_1, M, x, x_1, x, M, x_1, M, x, x_1, x, M, n, hn, n, n, x, n, x, x, x, n, x, n, x, x, x] (during elaboration)

{Œ± : Type u_1} {Œ≤ : Type u_2} {rŒ± : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop} {rŒ≤ : (a : Œ≤) ‚Üí (a : Œ≤) ‚Üí Prop} (f : (a : Œ±) ‚Üí Œ≤) (fib : Relation.Fibration rŒ± rŒ≤ f) {a : Œ±} (ha : Acc rŒ± a) (a : Œ±) (h : ‚àÄ (y : Œ±) (a : rŒ± y a) , Acc rŒ± y) (ih : ‚àÄ (y : Œ±) (a : rŒ± y a) , Acc rŒ≤ f y) (b : Œ≤) (hr : rŒ≤ b f a) (a' : Œ±) (h : (rŒ± a' a : Prop) ‚àß (f a' = b : Prop)) (hr' : rŒ± a' a) (right : f a' = b)  : ‚àÄ (hr : rŒ≤ f a' f a) , Acc rŒ≤ f a'
application type mismatch
  Acc rŒ≤ f
argument
  f
has type
  Œ± ‚Üí Œ≤ : Type (max u_1 u_2)
but is expected to have type
  Œ≤ : Type u_2 ; identifiers [Œ±, u_1, Œ≤, u_2, rŒ±, a, Œ±, a, Œ±, rŒ≤, a, Œ≤, a, Œ≤, f, a, Œ±, Œ≤, fib, Relation.Fibration, rŒ±, rŒ≤, f, a, Œ±, ha, Acc, rŒ±, a, a, Œ±, h, y, Œ±, a, rŒ±, y, a, Acc, rŒ±, y, ih, y, Œ±, a, rŒ±, y, a, Acc, rŒ≤, f, y, b, Œ≤, hr, rŒ≤, b, f, a, a', Œ±, h, rŒ±, a', a, f, a', b, hr', rŒ±, a', a, right, f, a', b, hr, rŒ≤, f, a', f, a, Acc, rŒ≤, f, a'] (during elaboration)

{Œ± : Type u} [AddGroup Œ±] [LE Œ±] [CovariantClass Œ± Œ± fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1 fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±} {b : Œ±}  : ((b + 0 ‚â§ b + - b + a : Prop) ‚Üî (b ‚â§ a : Prop)) = ((b + 0 ‚â§ b + - b + a : Prop) ‚Üî (b ‚â§ a : Prop))
function expected at
  x_1
term has type
  Œ± ; identifiers [Œ±, u, AddGroup, Œ±, LE, Œ±, CovariantClass, Œ±, Œ±, x, Œ±, x_1, Œ±, x, x_1, x, Œ±, x_1, Œ±, x, x_1, a, Œ±, b, Œ±, b, b, b, a, b, a, b, b, b, a, b, a] (during elaboration)

 : (‚àÄ {Œ± : Type u} {Œ≤ : Type v} {r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop} {Œπ : Sort u_1} {f : (a : Œπ) ‚Üí Œ≤} {g : (a : Œ≤) ‚Üí Œ±} , (Directed r g ‚àò f : Prop) ‚Üî (Directed g ‚Åª¬π'o r f : Prop))
type mismatch
  ?m.79219 ‚àò f
has type
  Œπ ‚Üí ?m.33 : Sort (imax u_1 ?u.28)
but is expected to have type
  Prop : Type ; identifiers [Œ±, u, Œ≤, v, r, a, Œ±, a, Œ±, Œπ, u_1, f, a, Œπ, Œ≤, g, a, Œ≤, Œ±, Directed, r, g, f, Directed, g, r, f] (during elaboration)

 : ‚àÄ {Œ± : Type u} {Œ≤ : Type v} {r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop} {Œπ : Sort u_1} {f : (a : Œπ) ‚Üí Œ≤} {g : (a : Œ≤) ‚Üí Œ±} , (Directed r g ‚àò f) ‚Üî (Directed r g ‚àò f)
application type mismatch
  Iff (?m.79218 ‚àò f)
argument
  ?m.79218 ‚àò f
has type
  Œπ ‚Üí ?m.32 : Sort (imax u_1 ?u.27)
but is expected to have type
  Prop : Type ; identifiers [Œ±, u, Œ≤, v, r, a, Œ±, a, Œ±, Œπ, u_1, f, a, Œπ, Œ≤, g, a, Œ≤, Œ±, Directed, r, g, f, Directed, r, g, f] (during elaboration)

{Œ± : Type u} [AddGroup Œ±] [LE Œ±] [CovariantClass Œ± Œ± fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1 fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±} {b : Œ±}  : ((b ‚â§ b + - b + a : Prop) ‚Üî (b ‚â§ a : Prop)) = ((b ‚â§ b + - b + a : Prop) ‚Üî (b ‚â§ a : Prop))
function expected at
  x_1
term has type
  Œ± ; identifiers [Œ±, u, AddGroup, Œ±, LE, Œ±, CovariantClass, Œ±, Œ±, x, Œ±, x_1, Œ±, x, x_1, x, Œ±, x_1, Œ±, x, x_1, a, Œ±, b, Œ±, b, b, b, a, b, a, b, b, b, a, b, a] (during elaboration)

{Œ± : Type u} [AddGroup Œ±] [LE Œ±] [CovariantClass Œ± Œ± fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1 fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±} {b : Œ±}  : (b ‚â§ a) ‚Üî (b ‚â§ a)
function expected at
  x_1
term has type
  Œ± ; identifiers [Œ±, u, AddGroup, Œ±, LE, Œ±, CovariantClass, Œ±, Œ±, x, Œ±, x_1, Œ±, x, x_1, x, Œ±, x_1, Œ±, x, x_1, a, Œ±, b, Œ±, b, a, b, a] (during elaboration)

{M : Type u_1} [AddMonoid M] [LinearOrder M] [CovariantClass M M fun (x : M) (x_1 : M) ‚Ü¶ x + x_1 fun (x : M) (x_1 : M) ‚Ü¶ x ‚â§ x_1] {x : M} {n : ‚Ñï} (hn : n ‚â† 0)  : (((x ‚â§ 0 : Prop) ‚àß (0 ‚â§ n ‚Ä¢ x : Prop) : Prop) ‚Üî ((x ‚â§ 0 : Prop) ‚àß (0 ‚â§ x : Prop) : Prop)) = (((x ‚â§ 0 : Prop) ‚àß (0 ‚â§ n ‚Ä¢ x : Prop) : Prop) ‚Üî ((x ‚â§ 0 : Prop) ‚àß (0 ‚â§ x : Prop) : Prop))
function expected at
  x_1
term has type
  M ; identifiers [M, u_1, AddMonoid, M, LinearOrder, M, CovariantClass, M, M, x, M, x_1, M, x, x_1, x, M, x_1, M, x, x_1, x, M, n, hn, n, x, n, x, x, x, x, n, x, x, x] (during elaboration)

{M : Type u_1} [AddMonoid M] [LinearOrder M] [CovariantClass M M fun (x : M) (x_1 : M) ‚Ü¶ x + x_1 fun (x : M) (x_1 : M) ‚Ü¶ x ‚â§ x_1] {x : M} {n : ‚Ñï} (hn : n ‚â† 0)  : ((x ‚â§ 0 : Prop) ‚àß (0 ‚â§ x : Prop)) ‚Üî ((x ‚â§ 0 : Prop) ‚àß (0 ‚â§ x : Prop))
function expected at
  x_1
term has type
  M ; identifiers [M, u_1, AddMonoid, M, LinearOrder, M, CovariantClass, M, M, x, M, x_1, M, x, x_1, x, M, x_1, M, x, x_1, x, M, n, hn, n, x, x, x, x] (during elaboration)

{M : Type u_1} [AddMonoid M] {s : Set M} {a : M} (hs : IsAddSubmonoid s) (h : a ‚àà s) (x : ‚Ñï) (x : ‚Ñï) (f : Nat.below x) (n : ‚Ñï) (x : Nat.below Nat.succ n)  : (n + 1 ‚Ä¢ a ‚àà s) = (n + 1 ‚Ä¢ a ‚àà s)
application type mismatch
  Nat.below Nat.succ
argument
  Nat.succ
has type
  ‚Ñï ‚Üí ‚Ñï : Type
but is expected to have type
  ‚Ñï : Type ; identifiers [M, u_1, AddMonoid, M, s, Set, M, a, M, hs, IsAddSubmonoid, s, h, a, s, x, x, f, Nat.below, x, n, x, Nat.below, Nat.succ, n, n, a, s, n, a, s] (during elaboration)

{R : Type u} {œÉ : Type u_1} [CommSemiring R] (a : R) (n : œÉ ‚Üí‚ÇÄ ‚Ñï) (hn : n ‚àà MvPolynomial.support ‚Üë MvPolynomial.C a) (this : n ‚àà {0})  : (n ‚àà {0}) = (n ‚àà {0})
function expected at
  MvPolynomial.support ?m.159088
term has type
  Finset (?m.383 ‚Üí‚ÇÄ ‚Ñï) ; identifiers [R, u, œÉ, u_1, CommSemiring, R, a, R, n, œÉ, hn, n, MvPolynomial.support, MvPolynomial.C, a, this, n, n, n] (during elaboration)

{Œ± : Type u_1} [SeminormedRing Œ±] (x : ‚Ñï) (x : ‚Ñï) (f : Nat.below x) (n : ‚Ñï) (x : Nat.below Nat.succ n)  : (‚Äñ ‚Üë n + 1 ‚Äñ ‚â§ ‚Üë n + 1 * ‚Äñ 1 ‚Äñ) = (‚Äñ ‚Üë n + 1 ‚Äñ ‚â§ ‚Üë n + 1 * ‚Äñ 1 ‚Äñ)
<input>:1:119: expected term

{C : Type u‚ÇÅ} [CategoryTheory.Category C] [CategoryTheory.MonoidalCategory C] {A : Mon_ C} {M : Mod_ A} {N : Mod_ A} (hom : Mod_.X M ‚ü∂ Mod_.X N) (act_hom : autoParam (CategoryTheory.CategoryStruct.comp Mod_.act M hom = CategoryTheory.CategoryStruct.comp CategoryTheory.MonoidalCategory.tensorHom CategoryTheory.CategoryStruct.id Mon_.X A hom Mod_.act N : Prop) _auto._@.Mathlib.CategoryTheory.Monoidal.Mod_._hyg.396) (hom_1 : Mod_.X M ‚ü∂ Mod_.X N) (act_hom_1 : autoParam (CategoryTheory.CategoryStruct.comp Mod_.act M hom_1 = CategoryTheory.CategoryStruct.comp CategoryTheory.MonoidalCategory.tensorHom CategoryTheory.CategoryStruct.id Mon_.X A hom_1 Mod_.act N : Prop) _auto._@.Mathlib.CategoryTheory.Monoidal.Mod_._hyg.396) (a : Mod_.Hom.mk hom = Mod_.Hom.mk hom_1)  : ‚àÄ (hom_eq : hom = hom_1) , hom = hom_1
function expected at
  CategoryTheory.CategoryStruct.comp ?m.82488 ?m.162331
term has type
  ?m.1833 ‚ü∂ ?m.1835 ; identifiers [C, u‚ÇÅ, CategoryTheory.Category, C, CategoryTheory.MonoidalCategory, C, A, Mon_, C, M, Mod_, A, N, Mod_, A, hom, Mod_.X, M, Mod_.X, N, act_hom, autoParam, CategoryTheory.CategoryStruct.comp, Mod_.act, M, hom, CategoryTheory.CategoryStruct.comp, CategoryTheory.MonoidalCategory.tensorHom, CategoryTheory.CategoryStruct.id, Mon_.X, A, hom, Mod_.act, N, _auto._, Mathlib.CategoryTheory.Monoidal.Mod_._hyg, hom_1, Mod_.X, M, Mod_.X, N, act_hom_1, autoParam, CategoryTheory.CategoryStruct.comp, Mod_.act, M, hom_1, CategoryTheory.CategoryStruct.comp, CategoryTheory.MonoidalCategory.tensorHom, CategoryTheory.CategoryStruct.id, Mon_.X, A, hom_1, Mod_.act, N, _auto._, Mathlib.CategoryTheory.Monoidal.Mod_._hyg, a, Mod_.Hom.mk, hom, Mod_.Hom.mk, hom_1, hom_eq, hom, hom_1, hom, hom_1] (during elaboration)

{Œ± : Type u_1} [SeminormedRing Œ±] (x : ‚Ñï) (x : ‚Ñï) (f : Nat.below x) (n : ‚Ñï) (x : Nat.below Nat.succ n)  : (‚Äñ ‚Üë n + 1 ‚Äñ ‚â§ ‚Üë n + 1 * ‚Äñ 1 ‚Äñ) = (‚Äñ ‚Üë n + 1 ‚Äñ ‚â§ ‚Üë n + 1 * ‚Äñ 1 ‚Äñ)
<input>:1:119: expected term

{C : Type u} [CategoryTheory.Category C] (J : CategoryTheory.GrothendieckTopology C) {D : Type w} [CategoryTheory.Category D] [‚àÄ (P : CategoryTheory.Functor C ·µí·µñ D) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover J X) , CategoryTheory.Limits.HasMultiequalizer CategoryTheory.GrothendieckTopology.Cover.index S P] [‚àÄ (X : C) , CategoryTheory.Limits.HasColimitsOfShape CategoryTheory.GrothendieckTopology.Cover J X ·µí·µñ D] {P : CategoryTheory.Functor C ·µí·µñ D} {Q : CategoryTheory.Functor C ·µí·µñ D} (Œ∑ : P ‚ü∂ Q) (hQ : CategoryTheory.Presheaf.IsSheaf J Q) (Œ≥ : CategoryTheory.GrothendieckTopology.plusObj J P ‚ü∂ Q) (hŒ≥ : CategoryTheory.CategoryStruct.comp CategoryTheory.GrothendieckTopology.toPlus J P Œ≥ = Œ∑)  : Œ∑ = CategoryTheory.CategoryStruct.comp CategoryTheory.GrothendieckTopology.toPlus J P Œ≥
function expected at
  CategoryTheory.Limits.HasMultiequalizer ?m.81901
term has type
  Prop ; identifiers [C, u, CategoryTheory.Category, C, J, CategoryTheory.GrothendieckTopology, C, D, w, CategoryTheory.Category, D, P, CategoryTheory.Functor, C, D, X, C, S, CategoryTheory.GrothendieckTopology.Cover, J, X, CategoryTheory.Limits.HasMultiequalizer, CategoryTheory.GrothendieckTopology.Cover.index, S, P, X, C, CategoryTheory.Limits.HasColimitsOfShape, CategoryTheory.GrothendieckTopology.Cover, J, X, D, P, CategoryTheory.Functor, C, D, Q, CategoryTheory.Functor, C, D, Œ∑, P, Q, hQ, CategoryTheory.Presheaf.IsSheaf, J, Q, Œ≥, CategoryTheory.GrothendieckTopology.plusObj, J, P, Q, hŒ≥, CategoryTheory.CategoryStruct.comp, CategoryTheory.GrothendieckTopology.toPlus, J, P, Œ≥, Œ∑, Œ∑, CategoryTheory.CategoryStruct.comp, CategoryTheory.GrothendieckTopology.toPlus, J, P, Œ≥] (during elaboration)

{R : Type u} [CommRing R] (I : Ideal R) ‚¶É a : Polynomial R ‚¶Ñ (a_1 : a ‚àà ‚Üë Submodule.map Polynomial.monomial 1 I) (r : R) (h : (r ‚àà ‚Üë I : Prop) ‚àß (‚Üë Polynomial.monomial 1 r = a : Prop)) (hr : r ‚àà ‚Üë I) (right : ‚Üë Polynomial.monomial 1 r = a)  : (r ‚àà I ^ 1) = (r ‚àà I ^ 1)
type mismatch
  I
has type
  Ideal R : Type u
but is expected to have type
  ?m.2812 I a_1 r h : Type ?u.618 ; identifiers [R, u, CommRing, R, I, Ideal, R, a, Polynomial, R, a_1, a, Submodule.map, Polynomial.monomial, I, r, R, h, r, I, Polynomial.monomial, r, a, hr, r, I, right, Polynomial.monomial, r, a, r, I, r, I] (during elaboration)

{Œ± : Type u_1} [SeminormedRing Œ±] (x : ‚Ñï) (x : ‚Ñï) (f : Nat.below x) (n : ‚Ñï) (x : Nat.below Nat.succ n)  : (‚Äñ ‚Üë n + 1 ‚Äñ ‚â§ ‚Üë n + 1 * ‚Äñ 1 ‚Äñ) = (‚Äñ ‚Üë n + 1 ‚Äñ ‚â§ ‚Üë n + 1 * ‚Äñ 1 ‚Äñ)
<input>:1:119: expected term

{Œ± : Type u_1} [SeminormedRing Œ±] (x : ‚Ñï) (x : ‚Ñï) (f : Nat.below x) (n : ‚Ñï) (x : Nat.below Nat.succ n)  : (‚Äñ ‚Üë n + 1 ‚Äñ ‚â§ ‚Üë n * ‚Äñ 1 ‚Äñ + 1 * ‚Äñ 1 ‚Äñ) = (‚Äñ ‚Üë n + 1 ‚Äñ ‚â§ ‚Üë n * ‚Äñ 1 ‚Äñ + 1 * ‚Äñ 1 ‚Äñ)
<input>:1:119: expected term

{C : Type u‚ÇÅ} [CategoryTheory.Category C] [CategoryTheory.MonoidalCategory C] {A : Mon_ C} {M : Mod_ A} {N : Mod_ A} (hom : Mod_.X M ‚ü∂ Mod_.X N) (act_hom : autoParam (CategoryTheory.CategoryStruct.comp Mod_.act M hom = CategoryTheory.CategoryStruct.comp CategoryTheory.MonoidalCategory.tensorHom CategoryTheory.CategoryStruct.id Mon_.X A hom Mod_.act N : Prop) _auto._@.Mathlib.CategoryTheory.Monoidal.Mod_._hyg.396) (hom_1 : Mod_.X M ‚ü∂ Mod_.X N) (act_hom_1 : autoParam (CategoryTheory.CategoryStruct.comp Mod_.act M hom_1 = CategoryTheory.CategoryStruct.comp CategoryTheory.MonoidalCategory.tensorHom CategoryTheory.CategoryStruct.id Mon_.X A hom_1 Mod_.act N : Prop) _auto._@.Mathlib.CategoryTheory.Monoidal.Mod_._hyg.396) (a : hom = hom_1) (h : hom_1 = hom) (hom_2 : Mod_.X M ‚ü∂ Mod_.X N)  : hom = hom
function expected at
  CategoryTheory.CategoryStruct.comp ?m.82488 ?m.162331
term has type
  ?m.1833 ‚ü∂ ?m.1835 ; identifiers [C, u‚ÇÅ, CategoryTheory.Category, C, CategoryTheory.MonoidalCategory, C, A, Mon_, C, M, Mod_, A, N, Mod_, A, hom, Mod_.X, M, Mod_.X, N, act_hom, autoParam, CategoryTheory.CategoryStruct.comp, Mod_.act, M, hom, CategoryTheory.CategoryStruct.comp, CategoryTheory.MonoidalCategory.tensorHom, CategoryTheory.CategoryStruct.id, Mon_.X, A, hom, Mod_.act, N, _auto._, Mathlib.CategoryTheory.Monoidal.Mod_._hyg, hom_1, Mod_.X, M, Mod_.X, N, act_hom_1, autoParam, CategoryTheory.CategoryStruct.comp, Mod_.act, M, hom_1, CategoryTheory.CategoryStruct.comp, CategoryTheory.MonoidalCategory.tensorHom, CategoryTheory.CategoryStruct.id, Mon_.X, A, hom_1, Mod_.act, N, _auto._, Mathlib.CategoryTheory.Monoidal.Mod_._hyg, a, hom, hom_1, h, hom_1, hom, hom_2, Mod_.X, M, Mod_.X, N, hom, hom] (during elaboration)

{Œ± : Type u_1} {m : MeasurableSpace Œ±} {M : Type u_2} [TopologicalSpace M] [OrderedAddCommMonoid M] [OrderClosedTopology M] (v : MeasureTheory.VectorMeasure Œ± M) (w : MeasureTheory.VectorMeasure Œ± M) {f : (a : ‚Ñï) ‚Üí Set Œ±} (hf‚ÇÅ : ‚àÄ (n : ‚Ñï) , MeasurableSet f n) (hf‚ÇÇ : ‚àÄ (n : ‚Ñï) , MeasureTheory.VectorMeasure.restrict v f n ‚â§ MeasureTheory.VectorMeasure.restrict w f n) (a : Set Œ±) (ha‚ÇÅ : MeasurableSet a) (ha‚ÇÇ : a ‚äÜ ‚ãÉ (n : ‚Ñï) , f n) (ha‚ÇÉ : ‚ãÉ (n : ‚Ñï) , a ‚à© disjointed f n = a) (ha‚ÇÑ : Pairwise Disjoint on fun (n : ‚Ñï) ‚Ü¶ a ‚à© disjointed f n) (n : ‚Ñï)  : MeasurableSet f n
function expected at
  MeasurableSet ?m.1001
term has type
  Prop ; identifiers [Œ±, u_1, m, MeasurableSpace, Œ±, M, u_2, TopologicalSpace, M, OrderedAddCommMonoid, M, OrderClosedTopology, M, v, MeasureTheory.VectorMeasure, Œ±, M, w, MeasureTheory.VectorMeasure, Œ±, M, f, a, Set, Œ±, hf‚ÇÅ, n, MeasurableSet, f, n, hf‚ÇÇ, n, MeasureTheory.VectorMeasure.restrict, v, f, n, MeasureTheory.VectorMeasure.restrict, w, f, n, a, Set, Œ±, ha‚ÇÅ, MeasurableSet, a, ha‚ÇÇ, a, n, f, n, ha‚ÇÉ, n, a, disjointed, f, n, a, ha‚ÇÑ, Pairwise, Disjoint, n, a, disjointed, f, n, n, MeasurableSet, f, n] (during elaboration)

{Œ± : Type u_1} {m : MeasurableSpace Œ±} {M : Type u_2} [TopologicalSpace M] [OrderedAddCommMonoid M] [OrderClosedTopology M] (v : MeasureTheory.VectorMeasure Œ± M) (w : MeasureTheory.VectorMeasure Œ± M) {f : (a : ‚Ñï) ‚Üí Set Œ±} (hf‚ÇÅ : ‚àÄ (n : ‚Ñï) , MeasurableSet f n) (hf‚ÇÇ : ‚àÄ (n : ‚Ñï) , MeasureTheory.VectorMeasure.restrict v f n ‚â§ MeasureTheory.VectorMeasure.restrict w f n) (a : Set Œ±) (ha‚ÇÅ : MeasurableSet a) (ha‚ÇÇ : a ‚äÜ ‚ãÉ (n : ‚Ñï) , f n) (ha‚ÇÉ : ‚ãÉ (n : ‚Ñï) , a ‚à© disjointed f n = a) (ha‚ÇÑ : Pairwise Disjoint on fun (n : ‚Ñï) ‚Ü¶ a ‚à© disjointed f n) (n : ‚Ñï)  : MeasureTheory.VectorMeasure.restrict v f n ‚â§ MeasureTheory.VectorMeasure.restrict w f n
function expected at
  MeasurableSet ?m.1001
term has type
  Prop ; identifiers [Œ±, u_1, m, MeasurableSpace, Œ±, M, u_2, TopologicalSpace, M, OrderedAddCommMonoid, M, OrderClosedTopology, M, v, MeasureTheory.VectorMeasure, Œ±, M, w, MeasureTheory.VectorMeasure, Œ±, M, f, a, Set, Œ±, hf‚ÇÅ, n, MeasurableSet, f, n, hf‚ÇÇ, n, MeasureTheory.VectorMeasure.restrict, v, f, n, MeasureTheory.VectorMeasure.restrict, w, f, n, a, Set, Œ±, ha‚ÇÅ, MeasurableSet, a, ha‚ÇÇ, a, n, f, n, ha‚ÇÉ, n, a, disjointed, f, n, a, ha‚ÇÑ, Pairwise, Disjoint, n, a, disjointed, f, n, n, MeasureTheory.VectorMeasure.restrict, v, f, n, MeasureTheory.VectorMeasure.restrict, w, f, n] (during elaboration)

{C : Type u‚ÇÅ} [CategoryTheory.Category C] [CategoryTheory.MonoidalCategory C] {A : Mon_ C} {M : Mod_ A} {N : Mod_ A} (hom : Mod_.X M ‚ü∂ Mod_.X N) (act_hom : autoParam (CategoryTheory.CategoryStruct.comp Mod_.act M hom = CategoryTheory.CategoryStruct.comp CategoryTheory.MonoidalCategory.tensorHom CategoryTheory.CategoryStruct.id Mon_.X A hom Mod_.act N : Prop) _auto._@.Mathlib.CategoryTheory.Monoidal.Mod_._hyg.396) (hom_1 : Mod_.X M ‚ü∂ Mod_.X N) (act_hom_1 : autoParam (CategoryTheory.CategoryStruct.comp Mod_.act M hom_1 = CategoryTheory.CategoryStruct.comp CategoryTheory.MonoidalCategory.tensorHom CategoryTheory.CategoryStruct.id Mon_.X A hom_1 Mod_.act N : Prop) _auto._@.Mathlib.CategoryTheory.Monoidal.Mod_._hyg.396) (a : hom = hom_1) (h : hom_1 = hom)  : hom = hom_1
function expected at
  CategoryTheory.CategoryStruct.comp ?m.82488 ?m.162331
term has type
  ?m.1833 ‚ü∂ ?m.1835 ; identifiers [C, u‚ÇÅ, CategoryTheory.Category, C, CategoryTheory.MonoidalCategory, C, A, Mon_, C, M, Mod_, A, N, Mod_, A, hom, Mod_.X, M, Mod_.X, N, act_hom, autoParam, CategoryTheory.CategoryStruct.comp, Mod_.act, M, hom, CategoryTheory.CategoryStruct.comp, CategoryTheory.MonoidalCategory.tensorHom, CategoryTheory.CategoryStruct.id, Mon_.X, A, hom, Mod_.act, N, _auto._, Mathlib.CategoryTheory.Monoidal.Mod_._hyg, hom_1, Mod_.X, M, Mod_.X, N, act_hom_1, autoParam, CategoryTheory.CategoryStruct.comp, Mod_.act, M, hom_1, CategoryTheory.CategoryStruct.comp, CategoryTheory.MonoidalCategory.tensorHom, CategoryTheory.CategoryStruct.id, Mon_.X, A, hom_1, Mod_.act, N, _auto._, Mathlib.CategoryTheory.Monoidal.Mod_._hyg, a, hom, hom_1, h, hom_1, hom, hom, hom_1] (during elaboration)

{C : Type u‚ÇÅ} [CategoryTheory.Category C] [CategoryTheory.MonoidalCategory C] {A : Mon_ C} {M : Mod_ A} {N : Mod_ A} (hom : Mod_.X M ‚ü∂ Mod_.X N) (act_hom : autoParam (CategoryTheory.CategoryStruct.comp Mod_.act M hom = CategoryTheory.CategoryStruct.comp CategoryTheory.MonoidalCategory.tensorHom CategoryTheory.CategoryStruct.id Mon_.X A hom Mod_.act N : Prop) _auto._@.Mathlib.CategoryTheory.Monoidal.Mod_._hyg.396) (hom_1 : Mod_.X M ‚ü∂ Mod_.X N) (act_hom_1 : autoParam (CategoryTheory.CategoryStruct.comp Mod_.act M hom_1 = CategoryTheory.CategoryStruct.comp CategoryTheory.MonoidalCategory.tensorHom CategoryTheory.CategoryStruct.id Mon_.X A hom_1 Mod_.act N : Prop) _auto._@.Mathlib.CategoryTheory.Monoidal.Mod_._hyg.396) (a : hom = hom_1)  : hom_1 = hom_1
function expected at
  CategoryTheory.CategoryStruct.comp ?m.82488 ?m.162331
term has type
  ?m.1833 ‚ü∂ ?m.1835 ; identifiers [C, u‚ÇÅ, CategoryTheory.Category, C, CategoryTheory.MonoidalCategory, C, A, Mon_, C, M, Mod_, A, N, Mod_, A, hom, Mod_.X, M, Mod_.X, N, act_hom, autoParam, CategoryTheory.CategoryStruct.comp, Mod_.act, M, hom, CategoryTheory.CategoryStruct.comp, CategoryTheory.MonoidalCategory.tensorHom, CategoryTheory.CategoryStruct.id, Mon_.X, A, hom, Mod_.act, N, _auto._, Mathlib.CategoryTheory.Monoidal.Mod_._hyg, hom_1, Mod_.X, M, Mod_.X, N, act_hom_1, autoParam, CategoryTheory.CategoryStruct.comp, Mod_.act, M, hom_1, CategoryTheory.CategoryStruct.comp, CategoryTheory.MonoidalCategory.tensorHom, CategoryTheory.CategoryStruct.id, Mon_.X, A, hom_1, Mod_.act, N, _auto._, Mathlib.CategoryTheory.Monoidal.Mod_._hyg, a, hom, hom_1, hom_1, hom_1] (during elaboration)

{n : ‚Ñï} (c : CompositionAsSet n) (j : Fin n + 1) (a : ‚àÉ (i : ‚Ñï) , (i < Finset.card CompositionAsSet.boundaries c : Prop) ‚àß (List.sum List.take i CompositionAsSet.blocks c = ‚Üë j : Prop)) (i : ‚Ñï) (h : (i < Finset.card CompositionAsSet.boundaries c : Prop) ‚àß (List.sum List.take i CompositionAsSet.blocks c = ‚Üë j : Prop)) (i_lt : i < Finset.card CompositionAsSet.boundaries c) (hi : List.sum List.take i CompositionAsSet.blocks c = ‚Üë j) {n : ‚Ñï} (val : ‚Ñï) (val_1 : ‚Ñï) (e_val : val = val_1)  : ‚àÄ (isLt : val < n) , {val := ((val)) , isLt := ((isLt))} = {val := ((val)) , isLt := ((isLt))}
function expected at
  Finset.card ?m.1501
term has type
  ‚Ñï ; identifiers [n, c, CompositionAsSet, n, j, Fin, n, a, i, i, Finset.card, CompositionAsSet.boundaries, c, List.sum, List.take, i, CompositionAsSet.blocks, c, j, i, h, i, Finset.card, CompositionAsSet.boundaries, c, List.sum, List.take, i, CompositionAsSet.blocks, c, j, i_lt, i, Finset.card, CompositionAsSet.boundaries, c, hi, List.sum, List.take, i, CompositionAsSet.blocks, c, j, n, val, val_1, e_val, val, val_1, isLt, val, n, val, val, isLt, isLt, val, val, isLt, isLt] (during elaboration)

{I : Type u_1} {f : (a : I) ‚Üí Type u_2} [(i : I) ‚Üí OrderedRing f i] (x : (i : I) ‚Üí f i) (x_1 : (i : I) ‚Üí f i) (ha : 0 ‚â§ x) (hb : 0 ‚â§ x_1) (x_2 : I)  : OfNat.ofNat 0 x_2 ‚â§ x x_2
application type mismatch
  OrderedRing f
argument
  f
has type
  I ‚Üí Type u_2 : Type (max u_1 (u_2 + 1))
but is expected to have type
  Type ?u.15 : Type (?u.15 + 1) ; identifiers [I, u_1, f, a, I, u_2, i, I, OrderedRing, f, i, x, i, I, f, i, x_1, i, I, f, i, ha, x, hb, x_1, x_2, I, OfNat.ofNat, x_2, x, x_2] (during elaboration)

{I : Type u_1} {f : (a : I) ‚Üí Type u_2} [(i : I) ‚Üí OrderedRing f i] (x : (i : I) ‚Üí f i) (x_1 : (i : I) ‚Üí f i) (ha : 0 ‚â§ x) (hb : 0 ‚â§ x_1) (x_2 : I)  : OfNat.ofNat 0 x_2 ‚â§ x_1 x_2
application type mismatch
  OrderedRing f
argument
  f
has type
  I ‚Üí Type u_2 : Type (max u_1 (u_2 + 1))
but is expected to have type
  Type ?u.15 : Type (?u.15 + 1) ; identifiers [I, u_1, f, a, I, u_2, i, I, OrderedRing, f, i, x, i, I, f, i, x_1, i, I, f, i, ha, x, hb, x_1, x_2, I, OfNat.ofNat, x_2, x_1, x_2] (during elaboration)

{Œπ : Type u_1} {Œ± : (a : Œπ) ‚Üí Type u_2} {i : Œπ} {f : Filter Œ± i} (H : IsEmpty (j : Œπ) ‚Üí Œ± j) (h : (isEmpty_or_nonempty (j : Œπ) ‚Üí Œ± j =: (IsEmpty (j : Œπ) ‚Üí Œ± j : Prop) ‚à® (Nonempty (j : Œπ) ‚Üí Œ± j : Prop)) = (Or.inl H =: (IsEmpty (j : Œπ) ‚Üí Œ± j : Prop) ‚à® (Nonempty (j : Œπ) ‚Üí Œ± j : Prop)))  : Or.inl H = isEmpty_or_nonempty (j : Œπ) ‚Üí Œ± j
<input>:1:134: expected term

{R : Type u_1} {A : Type u_2} [CommSemiring R] [StarRing R] [Semiring A] [Algebra R A] [StarRing A] [StarModule R A] {S : StarSubalgebra R A} (h : ‚àÄ (x : A) , x ‚àà S) (x : A)  : ‚àÄ (x_1 : x ‚àà ‚ä§) , x ‚àà S
typeclass instance problem is stuck, it is often due to metavariables
  Membership A (?m.1968 h x) ; identifiers [R, u_1, A, u_2, CommSemiring, R, StarRing, R, Semiring, A, Algebra, R, A, StarRing, A, StarModule, R, A, S, StarSubalgebra, R, A, h, x, A, x, S, x, A, x_1, x, x, S] (during elaboration)

{Œ± : Type u_2} {M : Type u_1} [AddCommMonoid M] {f : (a : Œ±) ‚Üí M} {s : Set Œ±} (p : (a : M) ‚Üí Prop) (hp‚ÇÄ : p 0) (hp‚ÇÅ : ‚àÄ (x : M) (y : M) (a : p x) (a : p y) , p x + y) (hp‚ÇÇ : ‚àÄ (x : Œ±) (a : x ‚àà s) , p f x) (x : Œ±)  : ‚àÄ (a : x ‚àà s) , p f x
failed to synthesize
  CoeT M x Prop
(deterministic) timeout at 'typeclass', maximum number of heartbeats (20000) has been reached (use 'set_option synthInstance.maxHeartbeats <num>' to set the limit) ; identifiers [Œ±, u_2, M, u_1, AddCommMonoid, M, f, a, Œ±, M, s, Set, Œ±, p, a, M, hp‚ÇÄ, p, hp‚ÇÅ, x, M, y, M, a, p, x, a, p, y, p, x, y, hp‚ÇÇ, x, Œ±, a, x, s, p, f, x, x, Œ±, a, x, s, p, f, x] (during elaboration)

{Œ± : Type u_1} [SemilatticeInf Œ±] [OrderBot Œ±] {s : Finset Œ±} (hs : Set.Intersecting ‚Üë s) (h : ‚àÄ (t : Finset Œ±) (a : Set.Intersecting ‚Üë t) (a : s ‚äÜ t) , s = t) ‚¶É a : Œ± ‚¶Ñ ‚¶É b : Œ± ‚¶Ñ (hab : a ‚â§ b) (ha : a ‚àà ‚Üë s)  : (b ‚àà ‚Üë s) = (b ‚àà ‚Üë s)
type mismatch
  s
has type
  Finset Œ± : Type u_1
but is expected to have type
  ?m.3390 hs h hab ha : Type ?u.2710 ; identifiers [Œ±, u_1, SemilatticeInf, Œ±, OrderBot, Œ±, s, Finset, Œ±, hs, Set.Intersecting, s, h, t, Finset, Œ±, a, Set.Intersecting, t, a, s, t, s, t, a, Œ±, b, Œ±, hab, a, b, ha, a, s, b, s, b, s] (during elaboration)

(Œ± : Type u_1) [OrderedCommGroup Œ±] {n : ‚Ñ§} (hn : 0 ‚â§ n) (a : Œ±) (b : Œ±) (hab : a ‚â§ b)  : (fun (x : Œ±) ‚Ü¶ x ^ n a ‚â§ fun (x : Œ±) ‚Ü¶ x ^ n b) = (fun (x : Œ±) ‚Ü¶ x ^ n a ‚â§ fun (x : Œ±) ‚Ü¶ x ^ n b)
function expected at
  n
term has type
  ‚Ñ§ ; identifiers [Œ±, u_1, OrderedCommGroup, Œ±, n, hn, n, a, Œ±, b, Œ±, hab, a, b, x, Œ±, x, n, a, x, Œ±, x, n, b, x, Œ±, x, n, a, x, Œ±, x, n, b] (during elaboration)

(Œ± : Type u_1) [OrderedCommGroup Œ±] {n : ‚Ñ§} (hn : 0 ‚â§ n) (a : Œ±) (b : Œ±) (hab : a ‚â§ b)  : (1 ‚â§ fun (x : Œ±) ‚Ü¶ x ^ n b / fun (x : Œ±) ‚Ü¶ x ^ n a) = (1 ‚â§ fun (x : Œ±) ‚Ü¶ x ^ n b / fun (x : Œ±) ‚Ü¶ x ^ n a)
function expected at
  n
term has type
  ‚Ñ§ ; identifiers [Œ±, u_1, OrderedCommGroup, Œ±, n, hn, n, a, Œ±, b, Œ±, hab, a, b, x, Œ±, x, n, b, x, Œ±, x, n, a, x, Œ±, x, n, b, x, Œ±, x, n, a] (during elaboration)

{Œ± : Type u} {Œ≤ : (a : Œ±) ‚Üí Type v} (x : AList Œ≤) (x_1 : AList Œ≤) (x_2 : AList.entries x = AList.entries x_1) (l‚ÇÅ : List Sigma Œ≤) (h‚ÇÅ : List.NodupKeys l‚ÇÅ) (l‚ÇÇ : List Sigma Œ≤) (nodupKeys : List.NodupKeys l‚ÇÇ) (H : AList.entries {entries := ((l‚ÇÅ)) , nodupKeys := ((h‚ÇÅ))} = AList.entries {entries := ((l‚ÇÇ)) , nodupKeys := ((nodupKeys))}) {Œ± : Type u} {Œ≤ : (a : Œ±) ‚Üí Type v} (entries : List Sigma Œ≤) (entries_1 : List Sigma Œ≤) (e_entries : entries = entries_1) (entries_2 : List Sigma Œ≤) (e_entries : entries = entries_2)  : List.NodupKeys entries_2
application type mismatch
  List Sigma
argument
  Sigma
has type
  (?m.58 ‚Üí Type ?u.56) ‚Üí Type (max ?u.57 ?u.56) : Type (max (?u.56 + 1) (?u.57 + 1))
but is expected to have type
  Type ?u.55 : Type (?u.55 + 1) ; identifiers [Œ±, u, Œ≤, a, Œ±, v, x, AList, Œ≤, x_1, AList, Œ≤, x_2, AList.entries, x, AList.entries, x_1, l‚ÇÅ, List, Sigma, Œ≤, h‚ÇÅ, List.NodupKeys, l‚ÇÅ, l‚ÇÇ, List, Sigma, Œ≤, nodupKeys, List.NodupKeys, l‚ÇÇ, H, AList.entries, entries, l‚ÇÅ, nodupKeys, h‚ÇÅ, AList.entries, entries, l‚ÇÇ, nodupKeys, nodupKeys, Œ±, u, Œ≤, a, Œ±, v, entries, List, Sigma, Œ≤, entries_1, List, Sigma, Œ≤, e_entries, entries, entries_1, entries_2, List, Sigma, Œ≤, e_entries, entries, entries_2, List.NodupKeys, entries_2] (during elaboration)

{Œ± : Type u} {Œ≤ : (a : Œ±) ‚Üí Type v} (x : AList Œ≤) (x_1 : AList Œ≤) (x_2 : AList.entries x = AList.entries x_1) (l‚ÇÅ : List Sigma Œ≤) (h‚ÇÅ : List.NodupKeys l‚ÇÅ) (l‚ÇÇ : List Sigma Œ≤) (nodupKeys : List.NodupKeys l‚ÇÇ) (H : AList.entries {entries := ((l‚ÇÅ)) , nodupKeys := ((h‚ÇÅ))} = AList.entries {entries := ((l‚ÇÇ)) , nodupKeys := ((nodupKeys))}) {Œ± : Type u} {Œ≤ : (a : Œ±) ‚Üí Type v} (entries : List Sigma Œ≤) (entries_1 : List Sigma Œ≤) (e_entries : entries = entries_1)  : ‚àÄ (nodupKeys : List.NodupKeys entries) , {entries := ((entries)) , nodupKeys := ((nodupKeys))} = {entries := ((entries)) , nodupKeys := ((nodupKeys))}
application type mismatch
  List Sigma
argument
  Sigma
has type
  (?m.58 ‚Üí Type ?u.56) ‚Üí Type (max ?u.57 ?u.56) : Type (max (?u.56 + 1) (?u.57 + 1))
but is expected to have type
  Type ?u.55 : Type (?u.55 + 1) ; identifiers [Œ±, u, Œ≤, a, Œ±, v, x, AList, Œ≤, x_1, AList, Œ≤, x_2, AList.entries, x, AList.entries, x_1, l‚ÇÅ, List, Sigma, Œ≤, h‚ÇÅ, List.NodupKeys, l‚ÇÅ, l‚ÇÇ, List, Sigma, Œ≤, nodupKeys, List.NodupKeys, l‚ÇÇ, H, AList.entries, entries, l‚ÇÅ, nodupKeys, h‚ÇÅ, AList.entries, entries, l‚ÇÇ, nodupKeys, nodupKeys, Œ±, u, Œ≤, a, Œ±, v, entries, List, Sigma, Œ≤, entries_1, List, Sigma, Œ≤, e_entries, entries, entries_1, nodupKeys, List.NodupKeys, entries, entries, entries, nodupKeys, nodupKeys, entries, entries, nodupKeys, nodupKeys] (during elaboration)

{R : Type u_1} [LinearOrder R] [OrderTop R] (s : Multiset Tropical R) ‚¶É s : Tropical R ‚¶Ñ {x : Multiset Tropical R} (IH : Tropical.untrop Multiset.sum x = Multiset.inf Multiset.map Tropical.untrop x)  : Multiset.inf Multiset.map Tropical.untrop x = Tropical.untrop Multiset.sum x
application type mismatch
  Multiset Tropical
argument
  Tropical
has type
  Type ?u.812 ‚Üí Type ?u.812 : Type (?u.812 + 1)
but is expected to have type
  Type ?u.811 : Type (?u.811 + 1) ; identifiers [R, u_1, LinearOrder, R, OrderTop, R, s, Multiset, Tropical, R, s, Tropical, R, x, Multiset, Tropical, R, IH, Tropical.untrop, Multiset.sum, x, Multiset.inf, Multiset.map, Tropical.untrop, x, Multiset.inf, Multiset.map, Tropical.untrop, x, Tropical.untrop, Multiset.sum, x] (during elaboration)

{Œ± : Type u_1} {l : List (a : Œ±) ‚Üí Œ±} {f : (a : Œ±) ‚Üí Œ±} (hl : ‚àÄ (f : (a : Œ±) ‚Üí Œ±) (a : f ‚àà l) , Function.Injective f) (hf : Function.Injective f)  : ‚àÄ {f : (a : Œ±) ‚Üí Œ±} (hl : ‚àÄ (f : (a : Œ±) ‚Üí Œ±) (a : f ‚àà []) , Function.Injective f) (hf : Function.Injective f) , Function.Injective f
unknown identifier 'a' ; identifiers [Œ±, u_1, l, List, a, Œ±, Œ±, f, a, Œ±, Œ±, hl, f, a, Œ±, Œ±, a, f, l, Function.Injective, f, hf, Function.Injective, f, f, a, Œ±, Œ±, hl, f, a, Œ±, Œ±, a, f, Function.Injective, f, hf, Function.Injective, f, Function.Injective, f] (during elaboration)

{X : Type u_1} [TopologicalSpace X] {x‚ÇÄ : X} {x‚ÇÅ : X} {p‚ÇÄ : Path x‚ÇÄ x‚ÇÅ} {p‚ÇÅ : Path x‚ÇÄ x‚ÇÅ} (F : Path.Homotopy p‚ÇÄ p‚ÇÅ) (t : ‚Üë unitInterval) (val : ‚Ñù) (property : val ‚àà unitInterval) (left : 0 ‚â§ val) (right : val ‚â§ 1)  : (0 ‚â§ val) ‚àß (val ‚â§ 1)
type mismatch
  unitInterval
has type
  Set ‚Ñù : Type
but is expected to have type
  Sort ?u.505 : Type ?u.505 ; identifiers [X, u_1, TopologicalSpace, X, x‚ÇÄ, X, x‚ÇÅ, X, p‚ÇÄ, Path, x‚ÇÄ, x‚ÇÅ, p‚ÇÅ, Path, x‚ÇÄ, x‚ÇÅ, F, Path.Homotopy, p‚ÇÄ, p‚ÇÅ, t, unitInterval, val, property, val, unitInterval, left, val, right, val, val, val] (during elaboration)

{V : Type w'} (G : SimpleGraph V) (x : V) (x_1 : V)  : (SimpleGraph.Adj FirstOrder.Language.simpleGraphOfStructure V x x_1) ‚Üî (SimpleGraph.Adj FirstOrder.Language.simpleGraphOfStructure V x x_1)
unknown universe level 'w'' ; identifiers [V, w', G, SimpleGraph, V, x, V, x_1, V, SimpleGraph.Adj, FirstOrder.Language.simpleGraphOfStructure, V, x, x_1, SimpleGraph.Adj, FirstOrder.Language.simpleGraphOfStructure, V, x, x_1] (during elaboration)

(R : Type u_1) [CommSemiring R] (M : Type u_2) [AddCommMonoid M] [Module R M] (r : R) (m : M)  : (r * 1 ‚äó‚Çú[R] m = r ‚äó‚Çú[R] m) = (r * 1 ‚äó‚Çú[R] m = r ‚äó‚Çú[R] m)
failed to synthesize instance
  HMul R (TensorProduct R ?m.275 M) ?m.161958 ; identifiers [R, u_1, CommSemiring, R, M, u_2, AddCommMonoid, M, Module, R, M, r, R, m, M, r, R, m, r, R, m, r, R, m, r, R, m] (during elaboration)

{C : Type u} [inst : CategoryTheory.Category C] [CategoryTheory.HasShift C ‚Ñ§] {T‚ÇÅ : CategoryTheory.Pretriangulated.Triangle C} {T‚ÇÇ : CategoryTheory.Pretriangulated.Triangle C} (self : CategoryTheory.Pretriangulated.TriangleMorphism T‚ÇÅ T‚ÇÇ)  : ‚àÄ (C : Type u) [inst : CategoryTheory.Category C] [inst_2 : CategoryTheory.HasShift C ‚Ñ§] (T‚ÇÅ : CategoryTheory.Pretriangulated.Triangle C) (T‚ÇÇ : CategoryTheory.Pretriangulated.Triangle C) (self : CategoryTheory.Pretriangulated.TriangleMorphism T‚ÇÅ T‚ÇÇ) , CategoryTheory.CategoryStruct.comp CategoryTheory.Pretriangulated.Triangle.mor‚ÇÇ T‚ÇÅ self . 3 = CategoryTheory.CategoryStruct.comp self . 2 CategoryTheory.Pretriangulated.Triangle.mor‚ÇÇ T‚ÇÇ
function expected at
  CategoryTheory.CategoryStruct.comp ?m.81555 ?m.161398
term has type
  ?m.961 ‚ü∂ ?m.963 ; identifiers [C, u, inst, CategoryTheory.Category, C, CategoryTheory.HasShift, C, T‚ÇÅ, CategoryTheory.Pretriangulated.Triangle, C, T‚ÇÇ, CategoryTheory.Pretriangulated.Triangle, C, self, CategoryTheory.Pretriangulated.TriangleMorphism, T‚ÇÅ, T‚ÇÇ, C, u, inst, CategoryTheory.Category, C, inst_2, CategoryTheory.HasShift, C, T‚ÇÅ, CategoryTheory.Pretriangulated.Triangle, C, T‚ÇÇ, CategoryTheory.Pretriangulated.Triangle, C, self, CategoryTheory.Pretriangulated.TriangleMorphism, T‚ÇÅ, T‚ÇÇ, CategoryTheory.CategoryStruct.comp, CategoryTheory.Pretriangulated.Triangle.mor‚ÇÇ, T‚ÇÅ, self, CategoryTheory.CategoryStruct.comp, self, CategoryTheory.Pretriangulated.Triangle.mor‚ÇÇ, T‚ÇÇ] (during elaboration)

{Œ± : Type u_2} {Œ≤ : Type u_1} {M : Type u_3} [CommMonoid M] {f : (a : Œ±) ‚Üí M} {s : Set Œ≤} {g : (a : Œ≤) ‚Üí Œ±} (hg : Set.InjOn g s ‚à© Function.mulSupport f ‚àò g)  : 1 = 1
application type mismatch
  Set.InjOn g s ‚à© Function.mulSupport f ‚àò g
argument
  Function.mulSupport f ‚àò g
has type
  Œ≤ ‚Üí Prop : Type u_1
but is expected to have type
  Prop : Type ; identifiers [Œ±, u_2, Œ≤, u_1, M, u_3, CommMonoid, M, f, a, Œ±, M, s, Set, Œ≤, g, a, Œ≤, Œ±, hg, Set.InjOn, g, s, Function.mulSupport, f, g] (during elaboration)

{Œ± : Type u_1} {a : Œ±} {s : Multiset Œ±} {t : Multiset Œ±} em : (a : Prop) ‚Üí Decidable (a : Prop) := Classical.propDecidable (a_1 : (¬¨ (a ‚àà s : Prop) : Prop) ‚àß (Multiset.Disjoint t s : Prop)) (left : ¬¨ (a ‚àà s : Prop)) (right : Multiset.Disjoint t s)  : ‚àÄ ‚¶É a : Œ± ‚¶Ñ (a_2 : a ‚àà s) (a : a ‚àà t) , False
<input>:1:60: expected end of input

{Œ± : Type u_1} {a : Œ±} {s : Multiset Œ±} {t : Multiset Œ±} em : (a : Prop) ‚Üí Decidable (a : Prop) := Classical.propDecidable (a_1 : (¬¨ (a ‚àà s : Prop) : Prop) ‚àß (Multiset.Disjoint s t : Prop)) (left : ¬¨ (a ‚àà s : Prop)) (right : Multiset.Disjoint s t)  : ‚àÄ ‚¶É a : Œ± ‚¶Ñ (a_2 : a ‚àà t) (a : a ‚àà s) , False
<input>:1:60: expected end of input

{Œπ : Type u_1} {Œ± : (a : Œπ) ‚Üí Type u_2} {i : Œπ} {f : Filter Œ± i} (H : IsEmpty (j : Œπ) ‚Üí Œ± j) (h : (isEmpty_or_nonempty (j : Œπ) ‚Üí Œ± j =: (IsEmpty (j : Œπ) ‚Üí Œ± j : Prop) ‚à® (Nonempty (j : Œπ) ‚Üí Œ± j : Prop)) = (Or.inl H =: (IsEmpty (j : Œπ) ‚Üí Œ± j : Prop) ‚à® (Nonempty (j : Œπ) ‚Üí Œ± j : Prop)))  : (¬¨ ((Nonempty (i : Œπ) ‚Üí Œ± i : Prop) ‚àß (Filter.NeBot f : Prop) : Prop)) = (‚àÄ (a : Nonempty (i : Œπ) ‚Üí Œ± i) , ¬¨ (Filter.NeBot f : Prop))
<input>:1:134: expected term

{Œ± : Type u_1} {Œπ : Sort u_2} [ConditionallyCompleteLattice Œ±] {f : (a : Œπ) ‚Üí Œ±} {g : (a : Œπ) ‚Üí Œ±} (B : BddAbove Set.range g) (H : ‚àÄ (x : Œπ) , f x ‚â§ g x) (h : IsEmpty Œπ) (h_1 : (isEmpty_or_nonempty Œπ =: (IsEmpty Œπ : Prop) ‚à® (Nonempty Œπ : Prop)) = (Or.inl h =: (IsEmpty Œπ : Prop) ‚à® (Nonempty Œπ : Prop)))  : Or.inl h = isEmpty_or_nonempty Œπ
<input>:1:201: expected term

