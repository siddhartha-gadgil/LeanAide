{"text": "Every ring is a field.", "fullPrompt": "/-- `‚Ñ§` with its usual ring structure is not a field. -/\ntheorem  : ¬¨is_field ‚Ñ§ :=\n\n/-- `polynomial R` is never a field for any ring `R`. -/\ntheorem {R : Type u} [ring R] : ¬¨is_field (polynomial R) :=\n\n/-- An element of an algebra over a field is algebraic if and only if it is integral. -/\ntheorem {K : Type u} {A : Type v} [field K] [ring A] [algebra K A] {x : A} : is_algebraic K x ‚Üî is_integral K x :=\n\n/-- An element of a ring multiplied by the additive inverse of one is the element's additive  inverse. -/\ntheorem {Œ± : Type u} [mul_one_class Œ±] [has_distrib_neg Œ±] (a : Œ±) : a * -1 = -a :=\n\n/-- There is a field structure on type if and only if its cardinality is a prime power. -/\ntheorem {Œ± : Type u} : nonempty (field Œ±) ‚Üî is_prime_pow (cardinal.mk Œ±) :=\n\n/-- The characteristic of a finite ring cannot be zero. -/\ntheorem (R : Type u) [non_assoc_ring R] (p : ‚Ñï) [hc : char_p R p] [fintype R] : p ‚â† 0 :=\n\n/-- The additive inverse of one multiplied by an element of a ring is the element's additive  inverse. -/\ntheorem {Œ± : Type u} [mul_one_class Œ±] [has_distrib_neg Œ±] (a : Œ±) : (-1) * a = -a :=\n\n/-- Any infinite type can be endowed a field structure. -/\ntheorem {Œ± : Type u} [infinite Œ±] : nonempty (field Œ±) :=\n\n/--  For each field, and for each nonzero element of said field, there is a unique inverse. Since `is_field` doesn't remember the data of an `inv` function and as such, a lemma that there is a unique inverse could be useful. -/\ntheorem (R : Type u) [ring R] (hf : is_field R) (x : R) : x ‚â† 0 ‚Üí (‚àÉ! (y : R), x * y = 1) :=\n\n/-- Right multiplication in a ring is an additive monoid morphism. -/\ntheorem {Œ≥ : Type u_1} [non_unital_non_assoc_semiring Œ≥] (x : Œ≥) : is_add_monoid_hom (Œª (y : Œ≥), y * x) :=\n\n/-- Left multiplication in a ring is an additive monoid morphism. -/\ntheorem {Œ≥ : Type u_1} [non_unital_non_assoc_semiring Œ≥] (x : Œ≥) : is_add_monoid_hom (Œª (y : Œ≥), x * y) :=\n\n/-- An integral element of an algebra is algebraic. -/\ntheorem (R : Type u) {A : Type v} [comm_ring R] [ring A] [algebra R A] [nontrivial R] {x : A} : is_integral R x ‚Üí is_algebraic R x :=\n\n/-- Every ring is a field. -/\ntheorem "}
{"text": "Every vector space is finite dimensional.", "fullPrompt": "/-- If a vector space has a finite basis, then it is finite-dimensional. -/\ntheorem {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {Œπ : Type w} [fintype Œπ] (h : basis Œπ K V) : finite_dimensional K V :=\n\n/-- A finite dimensional space is nontrivial if it has positive `finrank`. -/\ntheorem {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] (h : 0 < finite_dimensional.finrank K V) : nontrivial V :=\n\n/-- A finite dimensional space that is a subsingleton has zero `finrank`. -/\ntheorem {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [h : subsingleton V] : finite_dimensional.finrank K V = 0 :=\n\n/-- A nontrivial finite dimensional space has positive `finrank`. -/\ntheorem {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] [h : nontrivial V] : 0 < finite_dimensional.finrank K V :=\n\n/-- A finite dimensional space has positive `finrank` iff it is nontrivial. -/\ntheorem {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] : 0 < finite_dimensional.finrank K V ‚Üî nontrivial V :=\n\n/-- A finite dimensional space has positive `finrank` iff it has a nonzero element. -/\ntheorem {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] : 0 < finite_dimensional.finrank K V ‚Üî ‚àÉ (x : V), x ‚â† 0 :=\n\n/--  In a finite-dimensional space, its dimension (seen as a cardinal) coincides with its `finrank`. -/\ntheorem (K : Type u) (V : Type v) [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] : ‚Üë(finite_dimensional.finrank K V) = module.rank K V :=\n\n/-- In an `n`-dimensional space, the rank is at most `m`. -/\ntheorem {R : Type u_1} [ring R] [strong_rank_condition R] (n : ‚Ñï) {m : ‚Ñï} (v : fin m ‚Üí fin n ‚Üí R) : linear_independent R v ‚Üí m ‚â§ n :=\n\n/-- A module has dimension 1 iff there is some `v : V` so `{v}` is a basis. -/\ntheorem {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] (Œπ : Type u_1) [unique Œπ] : finite_dimensional.finrank K V = 1 ‚Üî nonempty (basis Œπ K V) :=\n\n/-- A free module with a basis indexed by a `fintype` is finite. -/\ntheorem {R : Type u_1} {M : Type u_2} {Œπ : Type u_3} [comm_ring R] [add_comm_group M] [module R M] [fintype Œπ] (b : basis Œπ R M) : module.finite R M :=\n\n/--  A finite dimensional space has zero `finrank` iff it is a subsingleton. This is the `finrank` version of `dim_zero_iff`. -/\ntheorem {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] : finite_dimensional.finrank K V = 0 ‚Üî subsingleton V :=\n\n/-- The vector space of functions on `fin n` has finrank equal to `n`. -/\ntheorem (K : Type u) [division_ring K] {n : ‚Ñï} : finite_dimensional.finrank K (fin n ‚Üí K) = n :=\n\n/-- An affine-independent subset of a finite-dimensional affine space is finite. -/\ntheorem (k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] [finite_dimensional k V] {s : set P} (hi : affine_independent k coe) : s.finite :=\n\n/-- Every vector space is finite dimensional. -/\ntheorem "}
{"text": "Every group is a torsion monoid.", "fullPrompt": "/-- A monoid is not a torsion monoid if it has an element of infinite order. -/\ntheorem (G : Type u_1) [monoid G] : ¬¨monoid.is_torsion G ‚Üî ‚àÉ (g : G), ¬¨is_of_fin_order g :=\n\n/-- A nontrivial monoid is not torsion-free if any nontrivial element has finite order. -/\ntheorem (G : Type u_1) [monoid G] : ¬¨monoid.is_torsion_free G ‚Üî ‚àÉ (g : G), g ‚â† 1 ‚àß is_of_fin_order g :=\n\n/-- Finite groups are torsion groups. -/\ntheorem {G : Type u_1} [group G] [fintype G] : monoid.is_torsion G :=\n\n/-- A group homomorphism is a monoid homomorphism. -/\ntheorem {Œ± : Type u} {Œ≤ : Type v} [group Œ±] [group Œ≤] {f : Œ± ‚Üí Œ≤} (hf : is_group_hom f) : is_monoid_hom f :=\n\n/-- A group is finitely generated if and only if it is finitely generated as a monoid. -/\ntheorem {G : Type u_3} [group G] : group.fg G ‚Üî monoid.fg G :=\n\n/-- A map to a group preserving multiplication is a monoid homomorphism. -/\ntheorem {Œ± : Type u} {Œ≤ : Type v} [mul_one_class Œ±] [group Œ≤] {f : Œ± ‚Üí Œ≤} (hf : is_mul_hom f) : is_monoid_hom f :=\n\n/-- A nontrivial torsion-free group is not torsion. -/\ntheorem {G : Type u_1} [group G] [hN : nontrivial G] : monoid.is_torsion_free G ‚Üí ¬¨monoid.is_torsion G :=\n\n/-- A nontrivial torsion group is not torsion-free. -/\ntheorem {G : Type u_1} [group G] [hN : nontrivial G] : monoid.is_torsion G ‚Üí ¬¨monoid.is_torsion_free G :=\n\n/-- A monoid is a submonoid of itself. -/\ntheorem {M : Type u_1} [monoid M] : is_submonoid set.univ :=\n\n/-- Direct products of torsion free groups are torsion free. -/\ntheorem {Œ∑ : Type u_1} {Gs : Œ∑ ‚Üí Type u_2} [Œ† (i : Œ∑), group (Gs i)] (tfGs : ‚àÄ (i : Œ∑), monoid.is_torsion_free (Gs i)) : monoid.is_torsion_free (Œ† (i : Œ∑), Gs i) :=\n\n/-- A group `G` is finitely generated if and only if `add_monoid_algebra R G` is of finite type. -/\ntheorem {R : Type u_1} {G : Type u_2} [comm_group G] [comm_ring R] [nontrivial R] : algebra.finite_type R (monoid_algebra R G) ‚Üî group.fg G :=\n\n/-- An additive group homomorphism is an additive monoid homomorphism. -/\ntheorem {Œ± : Type u} {Œ≤ : Type v} [add_group Œ±] [add_group Œ≤] {f : Œ± ‚Üí Œ≤} (hf : is_add_group_hom f) : is_add_monoid_hom f :=\n\n/-- The additive torsion submonoid of an additive torsion monoid is `‚ä§`. -/\ntheorem {G : Type u_1} [add_comm_monoid G] (tG : add_monoid.is_torsion G) : add_comm_monoid.add_torsion G = ‚ä§ :=\n\n/-- An additive monoid is not a torsion monoid if it has an element of infinite order. -/\ntheorem (G : Type u_1) [add_monoid G] : ¬¨add_monoid.is_torsion G ‚Üî ‚àÉ (g : G), ¬¨is_of_fin_add_order g :=\n\n/-- The torsion submonoid of a torsion monoid is `‚ä§`. -/\ntheorem {G : Type u_1} [comm_monoid G] (tG : monoid.is_torsion G) : comm_monoid.torsion G = ‚ä§ :=\n\n/-- Every group is a torsion monoid. -/\ntheorem "}
{"text": "Every finite simple group has prime order.", "fullPrompt": "/-- A finite group of prime order is simple. -/\ntheorem {Œ± : Type u} [group Œ±] [fintype Œ±] {p : ‚Ñï} [hp : fact (nat.prime p)] (h : fintype.card Œ± = p) : is_simple_group Œ± :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem {Œ± : Type u} [group Œ±] [fintype Œ±] {p : ‚Ñï} [hp : fact (nat.prime p)] (h : fintype.card Œ± = p) : is_cyclic Œ± :=\n\n/-- A group element has finite order iff its order is positive. -/\ntheorem {G : Type u} {x : G} [monoid G] : 0 < order_of x ‚Üî is_of_fin_order x :=\n\n/--  For every prime `p` dividing the order of a finite group `G` there exists an element of order `p` in `G`. This is known as Cauchy's theorem. -/\ntheorem {G : Type u_1} [group G] [fintype G] (p : ‚Ñï) [hp : fact (nat.prime p)] (hdvd : p ‚à£ fintype.card G) : ‚àÉ (x : G), order_of x = p :=\n\n/--  For every prime `p` dividing the order of a finite additive group `G` there exists an element of order `p` in `G`. This is the additive version of Cauchy's theorem. -/\ntheorem {G : Type u_1} [add_group G] [fintype G] (p : ‚Ñï) [hp : fact (nat.prime p)] (hdvd : p ‚à£ fintype.card G) : ‚àÉ (x : G), add_order_of x = p :=\n\n/-- A group element has finite additive order iff its order is positive. -/\ntheorem {G : Type u} {x : G} [add_monoid G] : 0 < add_order_of x ‚Üî is_of_fin_add_order x :=\n\n/-- A p-group is nilpotent -/\ntheorem {G : Type u_1} [hG : group G] [hf : fintype G] {p : ‚Ñï} [hp : fact (nat.prime p)] (h : is_p_group p G) : group.is_nilpotent G :=\n\n/-- A finite field has prime power cardinality. -/\ntheorem {Œ± : Type u_1} [fintype Œ±] [field Œ±] : is_prime_pow (fintype.card Œ±) :=\n\n/-- Inverses of elements of finite order have finite order. -/\ntheorem {G : Type u} [group G] {x : G} : is_of_fin_order x‚Åª¬π ‚Üî is_of_fin_order x :=\n\n/-- If a direct product has finite order then so does each component. -/\ntheorem {Œ∑ : Type u_1} {Gs : Œ∑ ‚Üí Type u_2} [Œ† (i : Œ∑), monoid (Gs i)] {x : Œ† (i : Œ∑), Gs i} (h : is_of_fin_order x) (i : Œ∑) : is_of_fin_order (x i) :=\n\n/-- Commuting elements of finite order are closed under multiplication. -/\ntheorem {G : Type u} {y : G} [monoid G] {x : G} (h : commute x y) (hx : is_of_fin_order x) (hy : is_of_fin_order y) : is_of_fin_order (x * y) :=\n\n/-- Any descending central series for a group is bounded below by the lower central series. -/\ntheorem {G : Type u_1} [group G] (H : ‚Ñï ‚Üí subgroup G) (hH : is_descending_central_series H) (n : ‚Ñï) : lower_central_series G n ‚â§ H n :=\n\n/-- Every finite simple group has prime order. -/\ntheorem "}
{"text": "Every finite group is simple.", "fullPrompt": "/-- A finite group of prime order is simple. -/\ntheorem {Œ± : Type u} [group Œ±] [fintype Œ±] {p : ‚Ñï} [hp : fact (nat.prime p)] (h : fintype.card Œ± = p) : is_simple_group Œ± :=\n\n/-- Finite groups are torsion groups. -/\ntheorem {G : Type u_1} [group G] [fintype G] : monoid.is_torsion G :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem {Œ± : Type u} [group Œ±] [fintype Œ±] {p : ‚Ñï} [hp : fact (nat.prime p)] (h : fintype.card Œ± = p) : is_cyclic Œ± :=\n\n/-- A group homomorphism is injective iff its kernel is trivial. -/\ntheorem {Œ± : Type u} {Œ≤ : Type v} [group Œ±] [group Œ≤] {f : Œ± ‚Üí Œ≤} (hf : is_group_hom f) : function.injective f ‚Üî ‚àÄ (a : Œ±), f a = 1 ‚Üí a = 1 :=\n\n/-- A group element has finite order iff its order is positive. -/\ntheorem {G : Type u} {x : G} [monoid G] : 0 < order_of x ‚Üî is_of_fin_order x :=\n\n/-- A subobject is simple iff it is an atom in the subobject lattice. -/\ntheorem {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] {X : C} (Y : category_theory.subobject X) : category_theory.simple ‚ÜëY ‚Üî is_atom Y :=\n\n/-- A group is finitely generated if and only if it is finitely generated as a monoid. -/\ntheorem {G : Type u_3} [group G] : group.fg G ‚Üî monoid.fg G :=\n\n/-- A group element has finite additive order iff its order is positive. -/\ntheorem {G : Type u} {x : G} [add_monoid G] : 0 < add_order_of x ‚Üî is_of_fin_add_order x :=\n\n/-- A group homomorphism is a monoid homomorphism. -/\ntheorem {Œ± : Type u} {Œ≤ : Type v} [group Œ±] [group Œ≤] {f : Œ± ‚Üí Œ≤} (hf : is_group_hom f) : is_monoid_hom f :=\n\n/-- Moving to the opposite group or group_with_zero commutes with taking powers. -/\ntheorem {M : Type u} [div_inv_monoid M] (x : M) (z : ‚Ñ§) : mul_opposite.op (x ^ z) = mul_opposite.op x ^ z :=\n\n/-- If `X` has subobject lattice `{‚ä•, ‚ä§}`, then `X` is simple. -/\ntheorem {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] (X : C) [is_simple_order (category_theory.subobject X)] : category_theory.simple X :=\n\n/--  For every prime `p` dividing the order of a finite group `G` there exists an element of order `p` in `G`. This is known as Cauchy's theorem. -/\ntheorem {G : Type u_1} [group G] [fintype G] (p : ‚Ñï) [hp : fact (nat.prime p)] (hdvd : p ‚à£ fintype.card G) : ‚àÉ (x : G), order_of x = p :=\n\n/--  **Burnside's lemma** : given a finite group `G` acting on a set `X`, the average number of elements fixed by each `g ‚àà G` is the number of orbits. -/\ntheorem (Œ± : Type u) (Œ≤ : Type v) [group Œ±] [mul_action Œ± Œ≤] [fintype Œ±] [Œ† (a : Œ±), fintype ‚Ü•(mul_action.fixed_by Œ± Œ≤ a)] [fintype (quotient (mul_action.orbit_rel Œ± Œ≤))] : finset.univ.sum (Œª (a : Œ±), fintype.card ‚Ü•(mul_action.fixed_by Œ± Œ≤ a)) = fintype.card (quotient (mul_action.orbit_rel Œ± Œ≤)) * fintype.card Œ± :=\n\n/-- In an integral domain, a sum indexed by a nontrivial homomorphism from a finite group is zero. -/\ntheorem {R : Type u_1} {G : Type u_2} [comm_ring R] [is_domain R] [group G] [fintype G] (f : G ‚Üí* R) (hf : f ‚â† 1) : finset.univ.sum (Œª (g : G), ‚áëf g) = 0 :=\n\n/--  In an integral domain, a sum indexed by a homomorphism from a finite group is zero, unless the homomorphism is trivial, in which case the sum is equal to the cardinality of the group. -/\ntheorem {R : Type u_1} {G : Type u_2} [comm_ring R] [is_domain R] [group G] [fintype G] (f : G ‚Üí* R) [decidable (f = 1)] : finset.univ.sum (Œª (g : G), ‚áëf g) = ite (f = 1) ‚Üë(fintype.card G) 0 :=\n\n/-- Every finite group is simple. -/\ntheorem "}
{"text": "Every finite group has prime order.", "fullPrompt": "/-- A finite group of prime order is cyclic. -/\ntheorem {Œ± : Type u} [group Œ±] [fintype Œ±] {p : ‚Ñï} [hp : fact (nat.prime p)] (h : fintype.card Œ± = p) : is_cyclic Œ± :=\n\n/-- A finite group of prime order is simple. -/\ntheorem {Œ± : Type u} [group Œ±] [fintype Œ±] {p : ‚Ñï} [hp : fact (nat.prime p)] (h : fintype.card Œ± = p) : is_simple_group Œ± :=\n\n/-- A group element has finite order iff its order is positive. -/\ntheorem {G : Type u} {x : G} [monoid G] : 0 < order_of x ‚Üî is_of_fin_order x :=\n\n/--  For every prime `p` dividing the order of a finite group `G` there exists an element of order `p` in `G`. This is known as Cauchy's theorem. -/\ntheorem {G : Type u_1} [group G] [fintype G] (p : ‚Ñï) [hp : fact (nat.prime p)] (hdvd : p ‚à£ fintype.card G) : ‚àÉ (x : G), order_of x = p :=\n\n/-- A group element has finite additive order iff its order is positive. -/\ntheorem {G : Type u} {x : G} [add_monoid G] : 0 < add_order_of x ‚Üî is_of_fin_add_order x :=\n\n/--  For every prime `p` dividing the order of a finite additive group `G` there exists an element of order `p` in `G`. This is the additive version of Cauchy's theorem. -/\ntheorem {G : Type u_1} [add_group G] [fintype G] (p : ‚Ñï) [hp : fact (nat.prime p)] (hdvd : p ‚à£ fintype.card G) : ‚àÉ (x : G), add_order_of x = p :=\n\n/-- Inverses of elements of finite order have finite order. -/\ntheorem {G : Type u} [group G] {x : G} : is_of_fin_order x‚Åª¬π ‚Üî is_of_fin_order x :=\n\n/-- Finite groups are torsion groups. -/\ntheorem {G : Type u_1} [group G] [fintype G] : monoid.is_torsion G :=\n\n/-- A finite field has prime power cardinality. -/\ntheorem {Œ± : Type u_1} [fintype Œ±] [field Œ±] : is_prime_pow (fintype.card Œ±) :=\n\n/-- Elements of finite order are closed under multiplication. -/\ntheorem {G : Type u} {x y : G} [comm_monoid G] (hx : is_of_fin_order x) (hy : is_of_fin_order y) : is_of_fin_order (x * y) :=\n\n/-- If a direct product has finite order then so does each component. -/\ntheorem {Œ∑ : Type u_1} {Gs : Œ∑ ‚Üí Type u_2} [Œ† (i : Œ∑), monoid (Gs i)] {x : Œ† (i : Œ∑), Gs i} (h : is_of_fin_order x) (i : Œ∑) : is_of_fin_order (x i) :=\n\n/-- If a direct product has finite additive order then so does each component. -/\ntheorem {Œ∑ : Type u_1} {Gs : Œ∑ ‚Üí Type u_2} [Œ† (i : Œ∑), add_monoid (Gs i)] {x : Œ† (i : Œ∑), Gs i} (h : is_of_fin_add_order x) (i : Œ∑) : is_of_fin_add_order (x i) :=\n\n/--  **Burnside's lemma** : given a finite group `G` acting on a set `X`, the average number of elements fixed by each `g ‚àà G` is the number of orbits. -/\ntheorem (Œ± : Type u) (Œ≤ : Type v) [group Œ±] [mul_action Œ± Œ≤] [fintype Œ±] [Œ† (a : Œ±), fintype ‚Ü•(mul_action.fixed_by Œ± Œ≤ a)] [fintype (quotient (mul_action.orbit_rel Œ± Œ≤))] : finset.univ.sum (Œª (a : Œ±), fintype.card ‚Ü•(mul_action.fixed_by Œ± Œ≤ a)) = fintype.card (quotient (mul_action.orbit_rel Œ± Œ≤)) * fintype.card Œ± :=\n\n/-- In an integral domain, a sum indexed by a nontrivial homomorphism from a finite group is zero. -/\ntheorem {R : Type u_1} {G : Type u_2} [comm_ring R] [is_domain R] [group G] [fintype G] (f : G ‚Üí* R) (hf : f ‚â† 1) : finset.univ.sum (Œª (g : G), ‚áëf g) = 0 :=\n\n/--  In an integral domain, a sum indexed by a homomorphism from a finite group is zero, unless the homomorphism is trivial, in which case the sum is equal to the cardinality of the group. -/\ntheorem {R : Type u_1} {G : Type u_2} [comm_ring R] [is_domain R] [group G] [fintype G] (f : G ‚Üí* R) [decidable (f = 1)] : finset.univ.sum (Œª (g : G), ‚áëf g) = ite (f = 1) ‚Üë(fintype.card G) 0 :=\n\n/-- Every finite group has prime order. -/\ntheorem "}
{"text": "Every set has Lebesgue measure zero.", "fullPrompt": "/-- The set of Liouville numbers has Lebesgue measure zero. -/\ntheorem  : ‚áëmeasure_theory.measure_space.volume {x : ‚Ñù | liouville x} = 0 :=\n\n/-- The empty set has zero diameter -/\ntheorem {Œ± : Type u} [pseudo_metric_space Œ±] : metric.diam ‚àÖ = 0 :=\n\n/-- The diameter of the empty set vanishes -/\ntheorem {Œ± : Type u} [pseudo_emetric_space Œ±] : emetric.diam ‚àÖ = 0 :=\n\n/--  The set of numbers satisfying the Liouville condition with some exponent `p > 2` has Lebesgue measure zero. -/\ntheorem  : ‚áëmeasure_theory.measure_space.volume (‚ãÉ (p : ‚Ñù) (hp : 2 < p), {x : ‚Ñù | liouville_with p x}) = 0 :=\n\n/-- The product of the constant function `0` over any set equals `0`. -/\ntheorem {Œ± : Type u_1} {M : Type u_5} [add_comm_monoid M] (s : set Œ±) : finsum (Œª (i : Œ±), finsum (Œª (H : i ‚àà s), 0)) = 0 :=\n\n/-- Every set has a measurable superset. Declare this as local instance as needed. -/\ntheorem {Œ± : Type u_1} {m : measurable_space Œ±} (s : set Œ±) : nonempty {t // s ‚äÜ t ‚àß measurable_set t} :=\n\n/-- If an additive indicator function is not equal to `0` at a point, then that point is in the set. -/\ntheorem {Œ± : Type u_1} {M : Type u_4} [has_zero M] {s : set Œ±} {f : Œ± ‚Üí M} {a : Œ±} (h : s.indicator f a ‚â† 0) : a ‚àà s :=\n\n/-- The sum of any function over an empty set is `0`. -/\ntheorem {Œ± : Type u_1} {M : Type u_5} [add_comm_monoid M] {f : Œ± ‚Üí M} : finsum (Œª (i : Œ±), finsum (Œª (H : i ‚àà ‚àÖ), f i)) = 0 :=\n\n/-- The diameter of a set is always nonnegative -/\ntheorem {Œ± : Type u} [pseudo_metric_space Œ±] {s : set Œ±} : 0 ‚â§ metric.diam s :=\n\n/-- Constant zero function has sum `0` -/\ntheorem {Œ± : Type u_1} {Œ≤ : Type u_2} [add_comm_monoid Œ±] [topological_space Œ±] : has_sum (Œª (b : Œ≤), 0) 0 :=\n\n/-- The Hausdorff distance between a set and itself is zero -/\ntheorem {Œ± : Type u} [pseudo_metric_space Œ±] {s : set Œ±} : metric.Hausdorff_dist s s = 0 :=\n\n/-- The minimal distance of a point to a set containing it vanishes -/\ntheorem {Œ± : Type u} [pseudo_metric_space Œ±] {s : set Œ±} {x : Œ±} (h : x ‚àà s) : metric.inf_dist x s = 0 :=\n\n/-- A transvection preserves Lebesgue measure. -/\ntheorem {Œπ : Type u_1} [fintype Œπ] [decidable_eq Œπ] (t : matrix.transvection_struct Œπ ‚Ñù) : measure_theory.measure_preserving ‚áë(‚áëmatrix.to_lin' t.to_matrix) measure_theory.measure_space.volume measure_theory.measure_space.volume :=\n\n/-- In the space `Œπ ‚Üí ‚Ñù`, Hausdorff measure coincides exactly with Lebesgue measure. -/\ntheorem {Œπ : Type u_1} [fintype Œπ] : measure_theory.measure.hausdorff_measure ‚Üë(fintype.card Œπ) = measure_theory.measure_space.volume :=\n\n/-- The Haar measure equals the Lebesgue measure on `‚Ñù^Œπ`. -/\ntheorem (Œπ : Type u_1) [fintype Œπ] : measure_theory.measure.add_haar_measure (topological_space.positive_compacts.pi_Icc01 Œπ) = measure_theory.measure_space.volume :=\n\n/--  A useful consequence of the Lebesgue number lemma: given any compact set `K` contained in an open set `U`, we can find an (open) entourage `V` such that the ball of size `V` about any point of `K` is contained in `U`. -/\ntheorem {Œ± : Type u_1} [uniform_space Œ±] {K U : set Œ±} (hK : is_compact K) (hU : is_open U) (hKU : K ‚äÜ U) : ‚àÉ (V : set (Œ± √ó Œ±)) (H : V ‚àà uniformity Œ±), is_open V ‚àß ‚àÄ (x : Œ±), x ‚àà K ‚Üí uniform_space.ball x V ‚äÜ U :=\n\n/-- The Lebesgue integral is measurable. This shows that the integrand of (the right-hand-side of)  Tonelli's theorem is measurable.  This version has the argument `f` in curried form. -/\ntheorem {Œ± : Type u_1} {Œ≤ : Type u_3} [measurable_space Œ±] [measurable_space Œ≤] {ŒΩ : measure_theory.measure Œ≤} [measure_theory.sigma_finite ŒΩ] {f : Œ± ‚Üí Œ≤ ‚Üí ennreal} (hf : measurable (function.uncurry f)) : measurable (Œª (x : Œ±), ‚à´‚Åª (y : Œ≤), f x y ‚àÇŒΩ) :=\n\n/-- The Lebesgue integral is measurable. This shows that the integrand of (the right-hand-side of)  Tonelli's theorem is measurable. -/\ntheorem {Œ± : Type u_1} {Œ≤ : Type u_3} [measurable_space Œ±] [measurable_space Œ≤] {ŒΩ : measure_theory.measure Œ≤} [measure_theory.sigma_finite ŒΩ] {f : Œ± √ó Œ≤ ‚Üí ennreal} (hf : measurable f) : measurable (Œª (x : Œ±), ‚à´‚Åª (y : Œ≤), f (x, y) ‚àÇŒΩ) :=\n\n/-- Every set has Lebesgue measure zero. -/\ntheorem "}
{"text": "If a topological space is compact, then every subset is compact.", "fullPrompt": "/-- A closed subset of a compact set is a compact set. -/\ntheorem {Œ± : Type u} [topological_space Œ±] {s t : set Œ±} (hs : is_compact s) (ht : is_closed t) (h : t ‚äÜ s) : is_compact t :=\n\n/-- In a locally compact space, every compact set is contained in the interior of a compact set. -/\ntheorem {Œ± : Type u} [topological_space Œ±] [locally_compact_space Œ±] {K : set Œ±} (hK : is_compact K) : ‚àÉ (K' : set Œ±), is_compact K' ‚àß K ‚äÜ interior K' :=\n\n/-- The intersection of a compact set and a closed set is a compact set. -/\ntheorem {Œ± : Type u} [topological_space Œ±] {s t : set Œ±} (hs : is_compact s) (ht : is_closed t) : is_compact (s ‚à© t) :=\n\n/-- The intersection of a closed set and a compact set is a compact set. -/\ntheorem {Œ± : Type u} [topological_space Œ±] {s t : set Œ±} (ht : is_compact t) (hs : is_closed s) : is_compact (s ‚à© t) :=\n\n/-- In a `t2_space`, every compact set is closed. -/\ntheorem {Œ± : Type u} [topological_space Œ±] [t2_space Œ±] {s : set Œ±} (hs : is_compact s) : is_closed s :=\n\n/-- In a locally compact T‚ÇÇ space, every point has an open neighborhood with compact closure -/\ntheorem {Œ± : Type u} [topological_space Œ±] [locally_compact_space Œ±] [t2_space Œ±] (x : Œ±) : ‚àÉ (U : set Œ±), is_open U ‚àß x ‚àà U ‚àß is_compact (closure U) :=\n\n/--  Every separated topological group in which there exists a compact set with nonempty interior is locally compact. -/\ntheorem {G : Type w} [topological_space G] [group G] [topological_group G] [t2_space G] (K : topological_space.positive_compacts G) : locally_compact_space G :=\n\n/-- A compact set is bounded above -/\ntheorem {Œ± : Type u} [topological_space Œ±] [linear_order Œ±] [order_closed_topology Œ±] [nonempty Œ±] {s : set Œ±} (hs : is_compact s) : bdd_above s :=\n\n/-- An unordered closed interval is compact. -/\ntheorem {Œ± : Type u_1} [linear_order Œ±] [topological_space Œ±] [compact_Icc_space Œ±] {a b : Œ±} : is_compact (set.interval a b) :=\n\n/-- Subsets of a bounded set are also bounded -/\ntheorem {Œ± : Type u} [pseudo_metric_space Œ±] {s t : set Œ±} (incl : s ‚äÜ t) : metric.bounded t ‚Üí metric.bounded s :=\n\n/-- A locally compact Hausdorff space is totally disconnected  if and only if it is totally separated. -/\ntheorem {H : Type u_1} [topological_space H] [locally_compact_space H] [t2_space H] : totally_disconnected_space H ‚Üî totally_separated_space H :=\n\n/-- A locally compact Hausdorff totally disconnected space has a basis with clopen elements. -/\ntheorem {H : Type u_1} [topological_space H] [locally_compact_space H] [t2_space H] [totally_disconnected_space H] : topological_space.is_topological_basis {s : set H | is_clopen s} :=\n\n/-- The span of a finite subset is compact in the lattice of submodules. -/\ntheorem {R : Type u_1} {M : Type u_4} [semiring R] [add_comm_monoid M] [module R M] (S : finset M) : complete_lattice.is_compact_element (submodule.span R ‚ÜëS) :=\n\n/-- The span of a finite subset is compact in the lattice of submodules. -/\ntheorem {R : Type u_1} {M : Type u_4} [semiring R] [add_comm_monoid M] [module R M] (S : set M) (h : S.finite) : complete_lattice.is_compact_element (submodule.span R S) :=\n\n/-- If a topological space is compact, then every subset is compact. -/\ntheorem "}
{"text": "Every set that is Lebesgue measurable but not Borel measurable has Lebesgue measure zero.", "fullPrompt": "/-- The set of Liouville numbers has Lebesgue measure zero. -/\ntheorem  : ‚áëmeasure_theory.measure_space.volume {x : ‚Ñù | liouville x} = 0 :=\n\n/-- Every set has a measurable superset. Declare this as local instance as needed. -/\ntheorem {Œ± : Type u_1} {m : measurable_space Œ±} (s : set Œ±) : nonempty {t // s ‚äÜ t ‚àß measurable_set t} :=\n\n/--  The set of numbers satisfying the Liouville condition with some exponent `p > 2` has Lebesgue measure zero. -/\ntheorem  : ‚áëmeasure_theory.measure_space.volume (‚ãÉ (p : ‚Ñù) (hp : 2 < p), {x : ‚Ñù | liouville_with p x}) = 0 :=\n\n/-- The empty set has zero diameter -/\ntheorem {Œ± : Type u} [pseudo_metric_space Œ±] : metric.diam ‚àÖ = 0 :=\n\n/-- In a Polish space, a set is clopenable if and only if it is Borel-measurable. -/\ntheorem {Œ≥ : Type u_3} [tŒ≥ : topological_space Œ≥] [polish_space Œ≥] [measurable_space Œ≥] [borel_space Œ≥] {s : set Œ≥} : polish_space.is_clopenable s ‚Üî measurable_set s :=\n\n/-- A strongly measurable function is measurable. -/\ntheorem {Œ± : Type u_1} {Œ≤ : Type u_2} {f : Œ± ‚Üí Œ≤} {m : measurable_space Œ±} [topological_space Œ≤] [topological_space.pseudo_metrizable_space Œ≤] [measurable_space Œ≤] [borel_space Œ≤] (hf : measure_theory.strongly_measurable f) : measurable f :=\n\n/-- The diameter of the empty set vanishes -/\ntheorem {Œ± : Type u} [pseudo_emetric_space Œ±] : emetric.diam ‚àÖ = 0 :=\n\n/-- A sequential limit of measurable `‚Ñù‚â•0` valued functions is measurable. -/\ntheorem {Œ± : Type u_1} [measurable_space Œ±] {f : ‚Ñï ‚Üí Œ± ‚Üí nnreal} {g : Œ± ‚Üí nnreal} (hf : ‚àÄ (i : ‚Ñï), measurable (f i)) (lim : filter.tendsto f filter.at_top (nhds g)) : measurable g :=\n\n/-- The range of a strongly measurable function is separable. -/\ntheorem {Œ± : Type u_1} {Œ≤ : Type u_2} {f : Œ± ‚Üí Œ≤} {m : measurable_space Œ±} [topological_space Œ≤] (hf : measure_theory.strongly_measurable f) : topological_space.is_separable (set.range f) :=\n\n/-- A sequential limit of measurable `‚Ñù‚â•0‚àû` valued functions is measurable. -/\ntheorem {Œ± : Type u_1} [measurable_space Œ±] {f : ‚Ñï ‚Üí Œ± ‚Üí ennreal} {g : Œ± ‚Üí ennreal} (hf : ‚àÄ (i : ‚Ñï), measurable (f i)) (lim : filter.tendsto f filter.at_top (nhds g)) : measurable g :=\n\n/-- The diameter of a set is always nonnegative -/\ntheorem {Œ± : Type u} [pseudo_metric_space Œ±] {s : set Œ±} : 0 ‚â§ metric.diam s :=\n\n/-- The product of the constant function `0` over any set equals `0`. -/\ntheorem {Œ± : Type u_1} {M : Type u_5} [add_comm_monoid M] (s : set Œ±) : finsum (Œª (i : Œ±), finsum (Œª (H : i ‚àà s), 0)) = 0 :=\n\n/-- A transvection preserves Lebesgue measure. -/\ntheorem {Œπ : Type u_1} [fintype Œπ] [decidable_eq Œπ] (t : matrix.transvection_struct Œπ ‚Ñù) : measure_theory.measure_preserving ‚áë(‚áëmatrix.to_lin' t.to_matrix) measure_theory.measure_space.volume measure_theory.measure_space.volume :=\n\n/-- In the space `Œπ ‚Üí ‚Ñù`, Hausdorff measure coincides exactly with Lebesgue measure. -/\ntheorem {Œπ : Type u_1} [fintype Œπ] : measure_theory.measure.hausdorff_measure ‚Üë(fintype.card Œπ) = measure_theory.measure_space.volume :=\n\n/-- The Haar measure equals the Lebesgue measure on `‚Ñù^Œπ`. -/\ntheorem (Œπ : Type u_1) [fintype Œπ] : measure_theory.measure.add_haar_measure (topological_space.positive_compacts.pi_Icc01 Œπ) = measure_theory.measure_space.volume :=\n\n/--  A useful consequence of the Lebesgue number lemma: given any compact set `K` contained in an open set `U`, we can find an (open) entourage `V` such that the ball of size `V` about any point of `K` is contained in `U`. -/\ntheorem {Œ± : Type u_1} [uniform_space Œ±] {K U : set Œ±} (hK : is_compact K) (hU : is_open U) (hKU : K ‚äÜ U) : ‚àÉ (V : set (Œ± √ó Œ±)) (H : V ‚àà uniformity Œ±), is_open V ‚àß ‚àÄ (x : Œ±), x ‚àà K ‚Üí uniform_space.ball x V ‚äÜ U :=\n\n/-- The Lebesgue integral is measurable. This shows that the integrand of (the right-hand-side of)  Tonelli's theorem is measurable.  This version has the argument `f` in curried form. -/\ntheorem {Œ± : Type u_1} {Œ≤ : Type u_3} [measurable_space Œ±] [measurable_space Œ≤] {ŒΩ : measure_theory.measure Œ≤} [measure_theory.sigma_finite ŒΩ] {f : Œ± ‚Üí Œ≤ ‚Üí ennreal} (hf : measurable (function.uncurry f)) : measurable (Œª (x : Œ±), ‚à´‚Åª (y : Œ≤), f x y ‚àÇŒΩ) :=\n\n/-- The Lebesgue integral is measurable. This shows that the integrand of (the right-hand-side of)  Tonelli's theorem is measurable. -/\ntheorem {Œ± : Type u_1} {Œ≤ : Type u_3} [measurable_space Œ±] [measurable_space Œ≤] {ŒΩ : measure_theory.measure Œ≤} [measure_theory.sigma_finite ŒΩ] {f : Œ± √ó Œ≤ ‚Üí ennreal} (hf : measurable f) : measurable (Œª (x : Œ±), ‚à´‚Åª (y : Œ≤), f (x, y) ‚àÇŒΩ) :=\n\n/--  The **Heine‚ÄìBorel theorem**: In a proper Hausdorff space, a set is compact if and only if it is closed and bounded. -/\ntheorem {Œ± : Type u} [pseudo_metric_space Œ±] {s : set Œ±} [t2_space Œ±] [proper_space Œ±] : is_compact s ‚Üî is_closed s ‚àß metric.bounded s :=\n\n/-- The **Heine‚ÄìBorel theorem**: In a proper space, the closure of a bounded set is compact. -/\ntheorem {Œ± : Type u} [pseudo_metric_space Œ±] {s : set Œ±} [proper_space Œ±] (h : metric.bounded s) : is_compact (closure s) :=\n\n/-- The **Heine‚ÄìBorel theorem**: In a proper space, a closed bounded set is compact. -/\ntheorem {Œ± : Type u} [pseudo_metric_space Œ±] {s : set Œ±} [proper_space Œ±] (hc : is_closed s) (hb : metric.bounded s) : is_compact s :=\n\n/--  The hard part of the Lusin separation theorem saying that two disjoint analytic sets are contained in disjoint Borel sets (see the full statement in `analytic_set.measurably_separable`). Here, we prove this when our analytic sets are the ranges of functions from `‚Ñï ‚Üí ‚Ñï`. -/\ntheorem {Œ± : Type u_1} [topological_space Œ±] [t2_space Œ±] [measurable_space Œ±] [borel_space Œ±] {f g : (‚Ñï ‚Üí ‚Ñï) ‚Üí Œ±} (hf : continuous f) (hg : continuous g) (h : disjoint (set.range f) (set.range g)) : measure_theory.measurably_separable (set.range f) (set.range g) :=\n\n/-- Every set that is Lebesgue measurable but not Borel measurable has Lebesgue measure zero. -/\ntheorem "}
{"text": "A finitely-presented group containing a torsion element is finite.", "fullPrompt": "/-- Finite groups are torsion groups. -/\ntheorem {G : Type u_1} [group G] [fintype G] : monoid.is_torsion G :=\n\n/-- A nontrivial torsion group is not torsion-free. -/\ntheorem {G : Type u_1} [group G] [hN : nontrivial G] : monoid.is_torsion G ‚Üí ¬¨monoid.is_torsion_free G :=\n\n/-- A nontrivial torsion-free group is not torsion. -/\ntheorem {G : Type u_1} [group G] [hN : nontrivial G] : monoid.is_torsion_free G ‚Üí ¬¨monoid.is_torsion G :=\n\n/-- A group is finitely generated if and only if it is finitely generated as a monoid. -/\ntheorem {G : Type u_3} [group G] : group.fg G ‚Üî monoid.fg G :=\n\n/-- Direct products of torsion free groups are torsion free. -/\ntheorem {Œ∑ : Type u_1} {Gs : Œ∑ ‚Üí Type u_2} [Œ† (i : Œ∑), group (Gs i)] (tfGs : ‚àÄ (i : Œ∑), monoid.is_torsion_free (Gs i)) : monoid.is_torsion_free (Œ† (i : Œ∑), Gs i) :=\n\n/-- A nontrivial monoid is not torsion-free if any nontrivial element has finite order. -/\ntheorem (G : Type u_1) [monoid G] : ¬¨monoid.is_torsion_free G ‚Üî ‚àÉ (g : G), g ‚â† 1 ‚àß is_of_fin_order g :=\n\n/-- A finitely presented algebra is of finite type. -/\ntheorem {R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] : algebra.finite_presentation R A ‚Üí algebra.finite_type R A :=\n\n/-- A group `G` is finitely generated if and only if `add_monoid_algebra R G` is of finite type. -/\ntheorem {R : Type u_1} {G : Type u_2} [comm_group G] [comm_ring R] [nontrivial R] : algebra.finite_type R (monoid_algebra R G) ‚Üî group.fg G :=\n\n/-- A group element has finite order iff its order is positive. -/\ntheorem {G : Type u} {x : G} [monoid G] : 0 < order_of x ‚Üî is_of_fin_order x :=\n\n/--  An algebra over a Noetherian ring is finitely generated if and only if it is finitely presented. -/\ntheorem {R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] [is_noetherian_ring R] : algebra.finite_type R A ‚Üî algebra.finite_presentation R A :=\n\n/-- If a direct product has finite order then so does each component. -/\ntheorem {Œ∑ : Type u_1} {Gs : Œ∑ ‚Üí Type u_2} [Œ† (i : Œ∑), monoid (Gs i)] {x : Œ† (i : Œ∑), Gs i} (h : is_of_fin_order x) (i : Œ∑) : is_of_fin_order (x i) :=\n\n/-- A group element has finite additive order iff its order is positive. -/\ntheorem {G : Type u} {x : G} [add_monoid G] : 0 < add_order_of x ‚Üî is_of_fin_add_order x :=\n\n/-- A finitely-presented group containing a torsion element is finite. -/\ntheorem "}
{"text": "If every point of a subset of a topological space is contained in some closed set, the subset itself is closed.", "fullPrompt": "/-- A closed subset of a compact set is a compact set. -/\ntheorem {Œ± : Type u} [topological_space Œ±] {s t : set Œ±} (hs : is_compact s) (ht : is_closed t) (h : t ‚äÜ s) : is_compact t :=\n\n/-- A set is sequentially closed if it is closed. -/\ntheorem {X : Type u_1} [topological_space X] {s : set X} (hs : is_closed s) : is_seq_closed s :=\n\n/-- The intersection of a compact set and a closed set is a compact set. -/\ntheorem {Œ± : Type u} [topological_space Œ±] {s t : set Œ±} (hs : is_compact s) (ht : is_closed t) : is_compact (s ‚à© t) :=\n\n/-- In a sequential space, a set is closed iff it's sequentially closed. -/\ntheorem {X : Type u_1} [topological_space X] [sequential_space X] {s : set X} : is_seq_closed s ‚Üî is_closed s :=\n\n/-- The intersection of a closed set and a compact set is a compact set. -/\ntheorem {Œ± : Type u} [topological_space Œ±] {s t : set Œ±} (ht : is_compact t) (hs : is_closed s) : is_compact (s ‚à© t) :=\n\n/-- The frontier of a closed set has no interior point. -/\ntheorem {Œ± : Type u} [topological_space Œ±] {s : set Œ±} (h : is_closed s) : interior (frontier s) = ‚àÖ :=\n\n/-- The frontier of a set is closed. -/\ntheorem {Œ± : Type u} [topological_space Œ±] {s : set Œ±} : is_closed (frontier s) :=\n\n/-- The edistance to a closed set depends continuously on the point and the set -/\ntheorem {Œ± : Type u} [emetric_space Œ±] : continuous (Œª (p : Œ± √ó topological_space.closeds Œ±), emetric.inf_edist p.fst ‚Üë(p.snd)) :=\n\n/-- In a locally compact space, every compact set is contained in the interior of a compact set. -/\ntheorem {Œ± : Type u} [topological_space Œ±] [locally_compact_space Œ±] {K : set Œ±} (hK : is_compact K) : ‚àÉ (K' : set Œ±), is_compact K' ‚àß K ‚äÜ interior K' :=\n\n/-- The minimal distance of a point to a set containing it vanishes -/\ntheorem {Œ± : Type u} [pseudo_metric_space Œ±] {s : set Œ±} {x : Œ±} (h : x ‚àà s) : metric.inf_dist x s = 0 :=\n\n/-- The minimal distance to a set is continuous in point -/\ntheorem {Œ± : Type u} [pseudo_metric_space Œ±] (s : set Œ±) : continuous (Œª (x : Œ±), metric.inf_dist x s) :=\n\n/-- In a `t2_space`, every compact set is closed. -/\ntheorem {Œ± : Type u} [topological_space Œ±] [t2_space Œ±] {s : set Œ±} (hs : is_compact s) : is_closed s :=\n\n/-- Every member of an open set in a compact Hausdorff totally disconnected space  is contained in a clopen set contained in the open set. -/\ntheorem {Œ± : Type u} [topological_space Œ±] [t2_space Œ±] [compact_space Œ±] [totally_disconnected_space Œ±] {x : Œ±} {U : set Œ±} (is_open : _root_.is_open U) (memU : x ‚àà U) : ‚àÉ (V : set Œ±) (hV : is_clopen V), x ‚àà V ‚àß V ‚äÜ U :=\n\n/-- If every point of a subset of a topological space is contained in some closed set, the subset itself is closed. -/\ntheorem "}
{"text": "A topological space $X$ is Hausdorff if and only if the diagonal map is an open map from $X$ to $X √ó X$.", "fullPrompt": "/-- The second projection in a product of topological spaces sends open sets to open sets. -/\ntheorem {Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [topological_space Œ≤] : is_open_map prod.snd :=\n\n/-- The first projection in a product of topological spaces sends open sets to open sets. -/\ntheorem {Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [topological_space Œ≤] : is_open_map prod.fst :=\n\n/-- The Hausdorff distance between a set and itself is zero -/\ntheorem {Œ± : Type u} [pseudo_metric_space Œ±] {s : set Œ±} : metric.Hausdorff_dist s s = 0 :=\n\n/-- The Hausdorff distance satisfies the triangular inequality -/\ntheorem {Œ± : Type u} [pseudo_emetric_space Œ±] {s t u : set Œ±} : emetric.Hausdorff_edist s u ‚â§ emetric.Hausdorff_edist s t + emetric.Hausdorff_edist t u :=\n\n/-- The distance to a set is controlled by the Hausdorff distance -/\ntheorem {Œ± : Type u} [pseudo_emetric_space Œ±] {x : Œ±} {s t : set Œ±} (h : x ‚àà s) : emetric.inf_edist x t ‚â§ emetric.Hausdorff_edist s t :=\n\n/-- An inducing map with an open range is an open map. -/\ntheorem {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {f : Œ± ‚Üí Œ≤} (hi : inducing f) (ho : is_open (set.range f)) : is_open_map f :=\n\n/-- The Hausdorff edistance of a set to itself vanishes -/\ntheorem {Œ± : Type u} [pseudo_emetric_space Œ±] {s : set Œ±} : emetric.Hausdorff_edist s s = 0 :=\n\n/-- If X is is_compact then pr‚ÇÇ : X √ó Y ‚Üí Y is a closed map -/\ntheorem {X : Type u_1} [topological_space X] [compact_space X] {Y : Type u_2} [topological_space Y] : is_closed_map prod.snd :=\n\n/-- The Hausdorff distance is nonnegative -/\ntheorem {Œ± : Type u} [pseudo_metric_space Œ±] {s t : set Œ±} : 0 ‚â§ metric.Hausdorff_dist s t :=\n\n/-- The Hausdorff distance from `s` to `t` and from `t` to `s` coincide -/\ntheorem {Œ± : Type u} [pseudo_metric_space Œ±] {s t : set Œ±} : metric.Hausdorff_dist s t = metric.Hausdorff_dist t s :=\n\n/-- A Hausdorff space with a clopen basis is totally separated. -/\ntheorem {Œ± : Type u} [topological_space Œ±] [t2_space Œ±] (h : topological_space.is_topological_basis {s : set Œ± | is_clopen s}) : totally_separated_space Œ± :=\n\n/--  Given an inducing map of a topological space into a pseudo metrizable space, the source space is also pseudo metrizable. -/\ntheorem {X : Type u_2} {Y : Type u_3} [topological_space X] [topological_space Y] [topological_space.pseudo_metrizable_space Y] {f : X ‚Üí Y} (hf : inducing f) : topological_space.pseudo_metrizable_space X :=\n\n/-- The projection on the base of a topological bundle created from core is an open map -/\ntheorem {Œπ : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core Œπ B F) : is_open_map Z.proj :=\n\n/-- The projection from a topological fiber bundle to its base is an open map. -/\ntheorem {B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z ‚Üí B} [topological_space Z] (h : is_topological_fiber_bundle F proj) : is_open_map proj :=\n\n/--  The diagonal map from the total space of the fibrewise product of two topological vector bundles `E‚ÇÅ`, `E‚ÇÇ` into `total_space E‚ÇÅ √ó total_space E‚ÇÇ` is `inducing`. -/\ntheorem {B : Type u_3} (E‚ÇÅ : B ‚Üí Type u_6) (E‚ÇÇ : B ‚Üí Type u_7) [topological_space (bundle.total_space E‚ÇÅ)] [topological_space (bundle.total_space E‚ÇÇ)] : inducing (Œª (p : bundle.total_space (Œª (x : B), E‚ÇÅ x √ó E‚ÇÇ x)), (‚ü®p.fst, p.snd.fst‚ü©, ‚ü®p.fst, p.snd.snd‚ü©)) :=\n\n/--  In a normed ring, the coercion from `RÀ£` (equipped with the induced topology from the embedding in `R √ó R`) to `R` is an open map. -/\ntheorem {R : Type u_1} [normed_ring R] [complete_space R] : is_open_map coe :=\n\n/-- If `f` is an affine map, then its linear part is an open map iff `f` is an open map. -/\ntheorem {ùïú : Type u_1} {V : Type u_2} {V‚ÇÇ : Type u_4} {P : Type u_8} {P‚ÇÇ : Type u_9} [normed_field ùïú] [semi_normed_group V] [semi_normed_group V‚ÇÇ] [normed_space ùïú V] [normed_space ùïú V‚ÇÇ] [pseudo_metric_space P] [pseudo_metric_space P‚ÇÇ] [normed_add_torsor V P] [normed_add_torsor V‚ÇÇ P‚ÇÇ] {f : P ‚Üí·µÉ[ùïú] P‚ÇÇ} : is_open_map ‚áë(f.linear) ‚Üî is_open_map ‚áëf :=\n\n/-- The projection on the base of a topological vector bundle created from core is an open map -/\ntheorem {R : Type u_1} {B : Type u_3} {F : Type u_4} [nondiscrete_normed_field R] [normed_group F] [normed_space R F] [topological_space B] {Œπ : Type u_6} (Z : topological_vector_bundle_core R B F Œπ) : is_open_map Z.proj :=\n\n/-- If a function has a non-zero strict derivative at all points, then it is an open map. -/\ntheorem {ùïú : Type u_1} [nondiscrete_normed_field ùïú] [complete_space ùïú] {f f' : ùïú ‚Üí ùïú} (hf : ‚àÄ (x : ùïú), has_strict_deriv_at f (f' x) x) (h0 : ‚àÄ (x : ùïú), f' x ‚â† 0) : is_open_map f :=\n\n/-- A topological space $X$ is Hausdorff if and only if the diagonal map is an open map from $X$ to $X √ó X$. -/\ntheorem "}
{"text": "Any finite order element in a group is equal to the identity.", "fullPrompt": "/-- A group element has finite order iff its order is positive. -/\ntheorem {G : Type u} {x : G} [monoid G] : 0 < order_of x ‚Üî is_of_fin_order x :=\n\n/-- Elements of finite order are closed under multiplication. -/\ntheorem {G : Type u} {x y : G} [comm_monoid G] (hx : is_of_fin_order x) (hy : is_of_fin_order y) : is_of_fin_order (x * y) :=\n\n/-- Inverses of elements of finite order have finite order. -/\ntheorem {G : Type u} [group G] {x : G} : is_of_fin_order x‚Åª¬π ‚Üî is_of_fin_order x :=\n\n/-- Commuting elements of finite order are closed under multiplication. -/\ntheorem {G : Type u} {y : G} [monoid G] {x : G} (h : commute x y) (hx : is_of_fin_order x) (hy : is_of_fin_order y) : is_of_fin_order (x * y) :=\n\n/-- A group element has finite additive order iff its order is positive. -/\ntheorem {G : Type u} {x : G} [add_monoid G] : 0 < add_order_of x ‚Üî is_of_fin_add_order x :=\n\n/-- Inverses of elements of finite additive order have finite additive order. -/\ntheorem {G : Type u} [add_group G] {x : G} : is_of_fin_add_order (-x) ‚Üî is_of_fin_add_order x :=\n\n/-- Inverses of elements of finite additive order have finite additive order. -/\ntheorem {G : Type u} [add_group G] {x : G} (hx : is_of_fin_add_order x) : is_of_fin_add_order (-x) :=\n\n/-- Elements of finite additive order are closed under addition. -/\ntheorem {G : Type u} {x y : G} [add_comm_monoid G] (hx : is_of_fin_add_order x) (hy : is_of_fin_add_order y) : is_of_fin_add_order (x + y) :=\n\n/-- The identity is a group homomorphism. -/\ntheorem {Œ± : Type u} [group Œ±] : is_group_hom id :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem {Œ± : Type u} [group Œ±] [fintype Œ±] {p : ‚Ñï} [hp : fact (nat.prime p)] (h : fintype.card Œ± = p) : is_cyclic Œ± :=\n\n/-- Commuting elements of finite additive order are closed under addition. -/\ntheorem {G : Type u} {y : G} [add_monoid G] {x : G} (h : add_commute x y) (hx : is_of_fin_add_order x) (hy : is_of_fin_add_order y) : is_of_fin_add_order (x + y) :=\n\n/--  For every prime `p` dividing the order of a finite group `G` there exists an element of order `p` in `G`. This is known as Cauchy's theorem. -/\ntheorem {G : Type u_1} [group G] [fintype G] (p : ‚Ñï) [hp : fact (nat.prime p)] (hdvd : p ‚à£ fintype.card G) : ‚àÉ (x : G), order_of x = p :=\n\n/-- A nontrivial monoid is not torsion-free if any nontrivial element has finite order. -/\ntheorem (G : Type u_1) [monoid G] : ¬¨monoid.is_torsion_free G ‚Üî ‚àÉ (g : G), g ‚â† 1 ‚àß is_of_fin_order g :=\n\n/-- 0 is of finite order in any additive monoid. -/\ntheorem {G : Type u} [add_monoid G] : is_of_fin_add_order 0 :=\n\n/-- Elements of finite order are of finite order in submonoids. -/\ntheorem {G : Type u} [monoid G] (H : submonoid G) (x : ‚Ü•H) : is_of_fin_order x ‚Üî is_of_fin_order ‚Üëx :=\n\n/-- Inverses of elements of finite order have finite order. -/\ntheorem {G : Type u} [group G] {x : G} (hx : is_of_fin_order x) : is_of_fin_order x‚Åª¬π :=\n\n/-- Any finite order element in a group is equal to the identity. -/\ntheorem "}
{"text": "If a subgroup of a group is torsion-free, then the group itself is torsion free.", "fullPrompt": "/-- A nontrivial torsion group is not torsion-free. -/\ntheorem {G : Type u_1} [group G] [hN : nontrivial G] : monoid.is_torsion G ‚Üí ¬¨monoid.is_torsion_free G :=\n\n/-- A nontrivial torsion-free group is not torsion. -/\ntheorem {G : Type u_1} [group G] [hN : nontrivial G] : monoid.is_torsion_free G ‚Üí ¬¨monoid.is_torsion G :=\n\n/-- Direct products of torsion free groups are torsion free. -/\ntheorem {Œ∑ : Type u_1} {Gs : Œ∑ ‚Üí Type u_2} [Œ† (i : Œ∑), group (Gs i)] (tfGs : ‚àÄ (i : Œ∑), monoid.is_torsion_free (Gs i)) : monoid.is_torsion_free (Œ† (i : Œ∑), Gs i) :=\n\n/-- Finite groups are torsion groups. -/\ntheorem {G : Type u_1} [group G] [fintype G] : monoid.is_torsion G :=\n\n/-- A nontrivial monoid is not torsion-free if any nontrivial element has finite order. -/\ntheorem (G : Type u_1) [monoid G] : ¬¨monoid.is_torsion_free G ‚Üî ‚àÉ (g : G), g ‚â† 1 ‚àß is_of_fin_order g :=\n\n/-- A monoid is not a torsion monoid if it has an element of infinite order. -/\ntheorem (G : Type u_1) [monoid G] : ¬¨monoid.is_torsion G ‚Üî ‚àÉ (g : G), ¬¨is_of_fin_order g :=\n\n/-- A group is finitely generated if and only if it is finitely generated as a monoid. -/\ntheorem {G : Type u_3} [group G] : group.fg G ‚Üî monoid.fg G :=\n\n/-- A p-group is nilpotent -/\ntheorem {G : Type u_1} [hG : group G] [hf : fintype G] {p : ‚Ñï} [hp : fact (nat.prime p)] (h : is_p_group p G) : group.is_nilpotent G :=\n\n/-- A group homomorphism is injective iff its kernel is trivial. -/\ntheorem {Œ± : Type u} {Œ≤ : Type v} [group Œ±] [group Œ≤] {f : Œ± ‚Üí Œ≤} (hf : is_group_hom f) : function.injective f ‚Üî ‚àÄ (a : Œ±), f a = 1 ‚Üí a = 1 :=\n\n/-- A group `G` is finitely generated if and only if `add_monoid_algebra R G` is of finite type. -/\ntheorem {R : Type u_1} {G : Type u_2} [comm_group G] [comm_ring R] [nontrivial R] : algebra.finite_type R (monoid_algebra R G) ‚Üî group.fg G :=\n\n/-- A group element has finite additive order iff its order is positive. -/\ntheorem {G : Type u} {x : G} [add_monoid G] : 0 < add_order_of x ‚Üî is_of_fin_add_order x :=\n\n/-- A group element has finite order iff its order is positive. -/\ntheorem {G : Type u} {x : G} [monoid G] : 0 < order_of x ‚Üî is_of_fin_order x :=\n\n/-- Direct products of additive torsion free groups are torsion free. -/\ntheorem {Œ∑ : Type u_1} {Gs : Œ∑ ‚Üí Type u_2} [Œ† (i : Œ∑), add_group (Gs i)] (tfGs : ‚àÄ (i : Œ∑), add_monoid.is_torsion_free (Gs i)) : add_monoid.is_torsion_free (Œ† (i : Œ∑), Gs i) :=\n\n/-- Quotienting a group by its additive torsion subgroup yields an additive torsion free group. -/\ntheorem (G : Type u_1) [add_comm_group G] : add_monoid.is_torsion_free (G ‚ß∏ add_torsion G) :=\n\n/-- Quotienting a group by its torsion subgroup yields a torsion free group. -/\ntheorem (G : Type u_1) [comm_group G] : monoid.is_torsion_free (G ‚ß∏ torsion G) :=\n\n/-- If a subgroup of a group is torsion-free, then the group itself is torsion free. -/\ntheorem "}
{"text": "Every injective homomorphism from a finitely generated free group to itself is surjective.", "fullPrompt": "/-- The canonical injection from the type to the free group is an injection. -/\ntheorem {Œ± : Type u} : function.injective free_group.of :=\n\n/-- A group homomorphism is injective iff its kernel is trivial. -/\ntheorem {Œ± : Type u} {Œ≤ : Type v} [group Œ±] [group Œ≤] {f : Œ± ‚Üí Œ≤} (hf : is_group_hom f) : function.injective f ‚Üî ‚àÄ (a : Œ±), f a = 1 ‚Üí a = 1 :=\n\n/-- An additive group homomorphism is injective if its kernel is trivial. -/\ntheorem {Œ± : Type u} {Œ≤ : Type v} [add_group Œ±] [add_group Œ≤] {f : Œ± ‚Üí Œ≤} (hf : is_add_group_hom f) : function.injective f ‚Üî ‚àÄ (a : Œ±), f a = 0 ‚Üí a = 0 :=\n\n/-- Given a map f from Œ± to Œ≤, the natural map from the quotient of Œ± by the kernel of f is    injective. -/\ntheorem {Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚Üí Œ≤) : function.injective (quotient.lift f _) :=\n\n/--  If two words correspond to the same element in the free group, then they have a common maximal reduction. This is the proof that the function that sends an element of the free group to its maximal reduction is well-defined. -/\ntheorem {Œ± : Type u} {L‚ÇÅ L‚ÇÇ : list (Œ± √ó bool)} [decidable_eq Œ±] (H : free_group.mk L‚ÇÅ = free_group.mk L‚ÇÇ) : free_group.reduce L‚ÇÅ = free_group.reduce L‚ÇÇ :=\n\n/-- A group homomorphism sends 1 to 1. -/\ntheorem {Œ± : Type u} {Œ≤ : Type v} [group Œ±] [group Œ≤] {f : Œ± ‚Üí Œ≤} (hf : is_group_hom f) : f 1 = 1 :=\n\n/--  Adding a group element to the point `p` is an injective function. -/\ntheorem {G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] (p : P) : function.injective (Œª (_x : G), _x +·µ• p) :=\n\n/--  A word and its maximal reduction correspond to the same element of the free group. -/\ntheorem {Œ± : Type u} {L : list (Œ± √ó bool)} [decidable_eq Œ±] : free_group.mk (free_group.reduce L) = free_group.mk L :=\n\n/-- A group homomorphism is a monoid homomorphism. -/\ntheorem {Œ± : Type u} {Œ≤ : Type v} [group Œ±] [group Œ≤] {f : Œ± ‚Üí Œ≤} (hf : is_group_hom f) : is_monoid_hom f :=\n\n/-- A free module with a basis indexed by a `fintype` is finite. -/\ntheorem {R : Type u_1} {M : Type u_2} {Œπ : Type u_3} [comm_ring R] [add_comm_group M] [module R M] [fintype Œπ] (b : basis Œπ R M) : module.finite R M :=\n\n/--  If two words have a common maximal reduction, then they correspond to the same element in the free group. -/\ntheorem {Œ± : Type u} {L‚ÇÅ L‚ÇÇ : list (Œ± √ó bool)} [decidable_eq Œ±] (H : free_group.reduce L‚ÇÅ = free_group.reduce L‚ÇÇ) : free_group.mk L‚ÇÅ = free_group.mk L‚ÇÇ :=\n\n/-- Direct products of torsion free groups are torsion free. -/\ntheorem {Œ∑ : Type u_1} {Gs : Œ∑ ‚Üí Type u_2} [Œ† (i : Œ∑), group (Gs i)] (tfGs : ‚àÄ (i : Œ∑), monoid.is_torsion_free (Gs i)) : monoid.is_torsion_free (Œ† (i : Œ∑), Gs i) :=\n\n/-- An `add_monoid` homomorphism `f` induces an injective homomorphism on the quotient by `f`'s kernel. -/\ntheorem {M : Type u_1} {P : Type u_3} [add_zero_class M] [add_zero_class P] (f : M ‚Üí+ P) : function.injective ‚áë(add_con.ker_lift f) :=\n\n/-- A monoid homomorphism `f` induces an injective homomorphism on the quotient by `f`'s kernel. -/\ntheorem {M : Type u_1} {P : Type u_3} [mul_one_class M] [mul_one_class P] (f : M ‚Üí* P) : function.injective ‚áë(con.ker_lift f) :=\n\n/-- Every injective homomorphism from a finitely generated free group to itself is surjective. -/\ntheorem "}
{"text": "Every division ring is either a field or finite.", "fullPrompt": "/-- A division_ring is one-dimensional as a vector space over itself. -/\ntheorem (K : Type u) [division_ring K] : finite_dimensional.finrank K K = 1 :=\n\n/-- A module over a division ring is noetherian if and only if it is finitely generated. -/\ntheorem {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] : is_noetherian K V ‚Üî module.finite K V :=\n\n/-- The characteristic of a finite ring cannot be zero. -/\ntheorem (R : Type u) [non_assoc_ring R] (p : ‚Ñï) [hc : char_p R p] [fintype R] : p ‚â† 0 :=\n\n/--  A prime that does not divide the cardinality of a finite commutative ring `R` is a unit in `R`. -/\ntheorem {R : Type u_1} [comm_ring R] [fintype R] (p : ‚Ñï) [fact (nat.prime p)] (hp : p ‚à£ fintype.card R) : ¬¨is_unit ‚Üëp :=\n\n/--  A prime `p` is a unit in a finite commutative ring `R` iff it does not divide the characteristic. -/\ntheorem (R : Type u_1) [comm_ring R] [fintype R] (p : ‚Ñï) [fact (nat.prime p)] : is_unit ‚Üëp ‚Üî ¬¨p ‚à£ ring_char R :=\n\n/-- A field extension is integral if it is finite. -/\ntheorem (K : Type u_1) (L : Type u_2) [field K] [field L] [algebra K L] [finite_dimensional K L] : algebra.is_integral K L :=\n\n/--  An algebra over a Noetherian ring is finitely generated if and only if it is finitely presented. -/\ntheorem {R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] [is_noetherian_ring R] : algebra.finite_type R A ‚Üî algebra.finite_presentation R A :=\n\n/-- `polynomial R` is never a field for any ring `R`. -/\ntheorem {R : Type u} [ring R] : ¬¨is_field (polynomial R) :=\n\n/-- If an element a divides another element b in a commutative ring, a divides the sum of b and  another element c iff a divides c. -/\ntheorem {Œ± : Type u} [non_unital_ring Œ±] {a b c : Œ±} (h : a ‚à£ b) : a ‚à£ b + c ‚Üî a ‚à£ c :=\n\n/-- A field extension is algebraic if it is finite. -/\ntheorem (K : Type u_1) (L : Type u_2) [field K] [field L] [algebra K L] [finite : finite_dimensional K L] : algebra.is_algebraic K L :=\n\n/-- Elements of finite order are closed under multiplication. -/\ntheorem {G : Type u} {x y : G} [comm_monoid G] (hx : is_of_fin_order x) (hy : is_of_fin_order y) : is_of_fin_order (x * y) :=\n\n/-- `R` is finitely presented as `R`-algebra. -/\ntheorem (R : Type u_1) [comm_ring R] : algebra.finite_presentation R R :=\n\n/-- If `v` is a valuation on a division ring then `v(x) = 0` iff `x = 0`. -/\ntheorem {Œì‚ÇÄ : Type u_3} [linear_ordered_comm_monoid_with_zero Œì‚ÇÄ] [nontrivial Œì‚ÇÄ] {K : Type u_1} [division_ring K] (v : valuation K Œì‚ÇÄ) {x : K} : ‚áëv x = 0 ‚Üî x = 0 :=\n\n/--  In a noetherian module over a division ring, if a basis is indexed by a set, that set is finite. -/\ntheorem {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {Œπ : Type u_1} {s : set Œπ} [is_noetherian K V] (b : basis ‚Ü•s K V) : s.finite :=\n\n/--  Over a characteristic-zero division ring, the centroids of two faces of a simplex are equal if and only if those faces are given by the same subset of points. -/\ntheorem {k : Type u_1} {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] [char_zero k] {n : ‚Ñï} (s : affine.simplex k P n) {fs‚ÇÅ fs‚ÇÇ : finset (fin (n + 1))} {m‚ÇÅ m‚ÇÇ : ‚Ñï} (h‚ÇÅ : fs‚ÇÅ.card = m‚ÇÅ + 1) (h‚ÇÇ : fs‚ÇÇ.card = m‚ÇÇ + 1) : finset.centroid k finset.univ (s.face h‚ÇÅ).points = finset.centroid k finset.univ (s.face h‚ÇÇ).points ‚Üî fs‚ÇÅ = fs‚ÇÇ :=\n\n/--  The dimension of a noetherian module over a division ring, as a cardinal, is strictly less than the first infinite cardinal `‚Ñµ‚ÇÄ`. -/\ntheorem (K : Type u) (V : Type v) [division_ring K] [add_comm_group V] [module K V] [is_noetherian K V] : module.rank K V < cardinal.aleph_0 :=\n\n/--  Over a characteristic-zero division ring, the centroids given by two subsets of the points of a simplex are equal if and only if those faces are given by the same subset of points. -/\ntheorem {k : Type u_1} {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] [char_zero k] {n : ‚Ñï} (s : affine.simplex k P n) {fs‚ÇÅ fs‚ÇÇ : finset (fin (n + 1))} {m‚ÇÅ m‚ÇÇ : ‚Ñï} (h‚ÇÅ : fs‚ÇÅ.card = m‚ÇÅ + 1) (h‚ÇÇ : fs‚ÇÇ.card = m‚ÇÇ + 1) : finset.centroid k fs‚ÇÅ s.points = finset.centroid k fs‚ÇÇ s.points ‚Üî fs‚ÇÅ = fs‚ÇÇ :=\n\n/-- Every division ring is either a field or finite. -/\ntheorem "}
{"text": "Every natural number is the product of two primes.", "fullPrompt": "/-- Every nonzero natural number has a unique prime factorization -/\ntheorem  : set.inj_on nat.factorization {x : ‚Ñï | x ‚â† 0} :=\n\n/-- Two natural numbers are equal if and only if the have the same multiples. -/\ntheorem {m n : ‚Ñï} : (‚àÄ (a : ‚Ñï), m ‚à£ a ‚Üî n ‚à£ a) ‚Üî m = n :=\n\n/-- The only numbers with empty prime factorization are `0` and `1` -/\ntheorem (n : ‚Ñï) : n.factorization = 0 ‚Üî n = 0 ‚à® n = 1 :=\n\n/-- Two natural numbers are equal if and only if the have the same divisors. -/\ntheorem {m n : ‚Ñï} : (‚àÄ (a : ‚Ñï), a ‚à£ m ‚Üî a ‚à£ n) ‚Üî m = n :=\n\n/--  An equivalent definition for prime powers: `n` is a prime power iff there is a unique prime dividing it. -/\ntheorem {n : ‚Ñï} : is_prime_pow n ‚Üî ‚àÉ! (p : ‚Ñï), nat.prime p ‚àß p ‚à£ n :=\n\n/--  An equivalent definition for prime powers: `n` is a prime power iff there is a prime `p` and a natural `k` such that `n` can be written as `p^(k+1)`. -/\ntheorem {R : Type u_1} [comm_monoid_with_zero R] (n : R) : is_prime_pow n ‚Üî ‚àÉ (p : R) (k : ‚Ñï), prime p ‚àß p ^ (k + 1) = n :=\n\n/-- A prime `p` satisfies `p % 2 = 1` if and only if `p ‚â† 2`. -/\ntheorem {p : ‚Ñï} [fact (nat.prime p)] : p % 2 = 1 ‚Üî p ‚â† 2 :=\n\n/-- If the factorization of `n` contains just one number `p` then `n` is a power of `p` -/\ntheorem {n p k : ‚Ñï} (hn : n ‚â† 0) (h : n.factorization = finsupp.single p k) : n = p ^ k :=\n\n/-- The prime factorizations of coprime `a` and `b` are disjoint -/\ntheorem {a b : ‚Ñï} (hab : a.coprime b) : disjoint a.factorization.support b.factorization.support :=\n\n/-- Prime `p` divides the product of a list `L` iff it divides some `a ‚àà L` -/\ntheorem {M : Type u_1} [comm_monoid_with_zero M] {p : M} {L : list M} (pp : prime p) : p ‚à£ L.prod ‚Üî ‚àÉ (a : M) (H : a ‚àà L), p ‚à£ a :=\n\n/--  Euclid's theorem on the **infinitude of primes**. Here given in the form: for every `n`, there exists a prime number `p ‚â• n`. -/\ntheorem (n : ‚Ñï) : ‚àÉ (p : ‚Ñï), n ‚â§ p ‚àß nat.prime p :=\n\n/--  Euclid's lemma: if `a ‚à£ b * c` and `gcd a b = 1` then `a ‚à£ c`. Compare with `is_coprime.dvd_of_dvd_mul_right` and `unique_factorization_monoid.dvd_of_dvd_mul_right_of_no_prime_factors` -/\ntheorem {a b c : ‚Ñ§} (habc : a ‚à£ b * c) (hab : a.gcd b = 1) : a ‚à£ c :=\n\n/-- A version of `nat.exists_infinite_primes` using the `bdd_above` predicate. -/\ntheorem  : ¬¨bdd_above {p : ‚Ñï | nat.prime p} :=\n\n/-- A version of `nat.exists_infinite_primes` using the `set.infinite` predicate. -/\ntheorem  : {p : ‚Ñï | nat.prime p}.infinite :=\n\n/-- For any positive `k : ‚Ñï` there are infinitely many primes `p` such that `p ‚â° 1 [MOD k]`. -/\ntheorem {k : ‚Ñï} (n : ‚Ñï) (hpos : 0 < k) : ‚àÉ (p : ‚Ñï), nat.prime p ‚àß n ‚â§ p ‚àß p ‚â° 1 [MOD k] :=\n\n/-- If we start with a multiset of primes, take the product and then factor it, we get back the original multiset. -/\ntheorem (v : prime_multiset) : v.prod.factor_multiset = v :=\n\n/-- Every natural number is the product of two primes. -/\ntheorem "}
{"text": "Every even number is the square of a natural number.", "fullPrompt": "/--  If `m` and `n` are natural numbers, then the natural number `m^n` is even if and only if `m` is even and `n` is positive. -/\ntheorem {m n : ‚Ñï} : even (m ^ n) ‚Üî even m ‚àß n ‚â† 0 :=\n\n/-- In a finite field of odd characteristic, not every element is a square. -/\ntheorem {F : Type u_3} [field F] [fintype F] (hF : ring_char F ‚â† 2) : ‚àÉ (a : F), ¬¨is_square a :=\n\n/-- A natural number is odd iff it has residue `1` or `3` mod `4` -/\ntheorem {n : ‚Ñï} : n % 2 = 1 ‚Üî n % 4 = 1 ‚à® n % 4 = 3 :=\n\n/-- Two natural numbers are equal if and only if the have the same multiples. -/\ntheorem {m n : ‚Ñï} : (‚àÄ (a : ‚Ñï), m ‚à£ a ‚Üî n ‚à£ a) ‚Üî m = n :=\n\n/-- Two natural numbers are equal if and only if the have the same divisors. -/\ntheorem {m n : ‚Ñï} : (‚àÄ (a : ‚Ñï), a ‚à£ m ‚Üî a ‚à£ n) ‚Üî m = n :=\n\n/-- The sum of two squares is zero iff both elements are zero. -/\ntheorem {Œ± : Type u} [linear_ordered_ring Œ±] {x y : Œ±} : x * x + y * y = 0 ‚Üî x = 0 ‚àß y = 0 :=\n\n/-- Note that most of the lemmas about powers of two refer to it as `sq`. -/\ntheorem {M : Type u} [monoid M] (a : M) : a ^ 2 = a * a :=\n\n/-- There are no perfect squares strictly between m¬≤ and (m+1)¬≤ -/\ntheorem {n m : ‚Ñï} (hl : m * m < n) (hr : n < (m + 1) * (m + 1)) : ¬¨‚àÉ (t : ‚Ñï), t * t = n :=\n\n/-- `0` is always a square (in a monoid with zero). -/\ntheorem (M : Type u_1) [monoid_with_zero M] : is_square 0 :=\n\n/-- Natural division is always less than division in the field. -/\ntheorem {Œ± : Type u_1} [linear_ordered_field Œ±] {m n : ‚Ñï} : ‚Üë(m / n) ‚â§ ‚Üëm / ‚Üën :=\n\n/-- The only numbers with empty prime factorization are `0` and `1` -/\ntheorem (n : ‚Ñï) : n.factorization = 0 ‚Üî n = 0 ‚à® n = 1 :=\n\n/-- **Alias** of the reverse direction of is_square_iff_exists_sq`. -/\ntheorem {Œ± : Type u_2} [monoid Œ±] (m : Œ±) : (‚àÉ (c : Œ±), m = c ^ 2) ‚Üí is_square m :=\n\n/-- Every even number is the square of a natural number. -/\ntheorem "}
{"text": "Every normal subgroup of a group has finite index.", "fullPrompt": "/-- The normal closure of a set is a subgroup. -/\ntheorem {G : Type u_1} [group G] (s : set G) : is_subgroup (group.normal_closure s) :=\n\n/-- The normal closure of s is a normal subgroup. -/\ntheorem {G : Type u_1} {s : set G} [group G] : is_normal_subgroup (group.normal_closure s) :=\n\n/-- The normal closure of s is the smallest normal subgroup containing s. -/\ntheorem {G : Type u_1} [group G] {s t : set G} (ht : is_normal_subgroup t) (h : s ‚äÜ t) : group.normal_closure s ‚äÜ t :=\n\n/-- A group element has finite order iff its order is positive. -/\ntheorem {G : Type u} {x : G} [monoid G] : 0 < order_of x ‚Üî is_of_fin_order x :=\n\n/-- Any ascending central series for a group is bounded above by the upper central series. -/\ntheorem {G : Type u_1} [group G] (H : ‚Ñï ‚Üí subgroup G) (hH : is_ascending_central_series H) (n : ‚Ñï) : H n ‚â§ upper_central_series G n :=\n\n/-- Any descending central series for a group is bounded below by the lower central series. -/\ntheorem {G : Type u_1} [group G] (H : ‚Ñï ‚Üí subgroup G) (hH : is_descending_central_series H) (n : ‚Ñï) : lower_central_series G n ‚â§ H n :=\n\n/-- The upper central series of a group is an ascending central series. -/\ntheorem (G : Type u_1) [group G] : is_ascending_central_series (upper_central_series G) :=\n\n/-- A finite group of prime order is simple. -/\ntheorem {Œ± : Type u} [group Œ±] [fintype Œ±] {p : ‚Ñï} [hp : fact (nat.prime p)] (h : fintype.card Œ± = p) : is_simple_group Œ± :=\n\n/-- The lower central series of a group is a descending central series. -/\ntheorem {G : Type u_1} [group G] : is_descending_central_series (lower_central_series G) :=\n\n/-- A p-group is nilpotent -/\ntheorem {G : Type u_1} [hG : group G] [hf : fintype G] {p : ‚Ñï} [hp : fact (nat.prime p)] (h : is_p_group p G) : group.is_nilpotent G :=\n\n/-- If a subgroup of a topological group has `1` in its interior, then it is open. -/\ntheorem {G : Type u_1} [group G] [topological_space G] [topological_group G] {H : subgroup G} (h_1_int : 1 ‚àà interior ‚ÜëH) : is_open ‚ÜëH :=\n\n/-- If a direct product has finite order then so does each component. -/\ntheorem {Œ∑ : Type u_1} {Gs : Œ∑ ‚Üí Type u_2} [Œ† (i : Œ∑), monoid (Gs i)] {x : Œ† (i : Œ∑), Gs i} (h : is_of_fin_order x) (i : Œ∑) : is_of_fin_order (x i) :=\n\n/-- For finite index types, the `subgroup.pi` is generated by the embeddings of the groups. -/\ntheorem {Œ∑ : Type u_5} {f : Œ∑ ‚Üí Type u_6} [Œ† (i : Œ∑), group (f i)] [decidable_eq Œ∑] [fintype Œ∑] {H : Œ† (i : Œ∑), subgroup (f i)} {J : subgroup (Œ† (i : Œ∑), f i)} : subgroup.pi set.univ H ‚â§ J ‚Üî ‚àÄ (i : Œ∑), subgroup.map (monoid_hom.single f i) (H i) ‚â§ J :=\n\n/-- For finite index types, the `subgroup.pi` is generated by the embeddings of the additive groups. -/\ntheorem {Œ∑ : Type u_5} {f : Œ∑ ‚Üí Type u_6} [Œ† (i : Œ∑), add_group (f i)] [decidable_eq Œ∑] [fintype Œ∑] {H : Œ† (i : Œ∑), add_subgroup (f i)} {J : add_subgroup (Œ† (i : Œ∑), f i)} : add_subgroup.pi set.univ H ‚â§ J ‚Üî ‚àÄ (i : Œ∑), add_subgroup.map (add_monoid_hom.single f i) (H i) ‚â§ J :=\n\n/-- **Schreier's Lemma**: A finite index subgroup of a finitely generated  group is finitely generated. -/\ntheorem {G : Type u_1} [group G] {H : subgroup G} [hG : group.fg G] (hH : H.index ‚â† 0) : group.fg ‚Ü•H :=\n\n/-- Frattini's Argument: If `N` is a normal subgroup of `G`, and if `P` is a Sylow `p`-subgroup  of `N`, then `N_G(P) ‚äî N = G`. -/\ntheorem {G : Type u_1} [group G] {p : ‚Ñï} [fact (nat.prime p)] {N : subgroup G} [N.normal] [fintype (sylow p ‚Ü•N)] (P : sylow p ‚Ü•N) : (subgroup.map N.subtype ‚ÜëP).normalizer ‚äî N = ‚ä§ :=\n\n/-- The normal closure of `s` is the smallest normal subgroup containing `s`. -/\ntheorem {G : Type u_1} [group G] {s : set G} {N : subgroup G} [N.normal] (h : s ‚äÜ ‚ÜëN) : subgroup.normal_closure s ‚â§ N :=\n\n/-- Every normal subgroup of a group has finite index. -/\ntheorem "}
{"text": "The characteristic polynomial of every matrix has real roots.", "fullPrompt": "/-- The **Cayley-Hamilton Theorem**, that the characteristic polynomial of a matrix, applied to the matrix itself, is zero.  This holds over any commutative ring.  See `linear_map.aeval_self_charpoly` for the equivalent statement about endomorphisms. -/\ntheorem {R : Type u} [comm_ring R] {n : Type w} [decidable_eq n] [fintype n] (M : matrix n n R) : ‚áë(polynomial.aeval M) M.charpoly = 0 :=\n\n/-- Characteristic `‚â† 2` and nontrivial implies that `-1 ‚â† 1`. -/\ntheorem {R : Type u_1} [non_assoc_ring R] [nontrivial R] (hR : ring_char R ‚â† 2) : -1 ‚â† 1 :=\n\n/-- The exponential characteristic is one iff the characteristic is zero. -/\ntheorem (R : Type u) [semiring R] [nontrivial R] (p q : ‚Ñï) [char_p R p] [exp_char R q] : q = 1 ‚Üî p = 0 :=\n\n/-- Determinant of 0x0 matrix -/\ntheorem {R : Type v} [comm_ring R] {A : matrix (fin 0) (fin 0) R} : A.det = 1 :=\n\n/-- The exponential characteristic is one if the characteristic is zero. -/\ntheorem (R : Type u) [semiring R] (q : ‚Ñï) [hp : char_p R 0] [hq : exp_char R q] : q = 1 :=\n\n/-- The exponential characteristic is one if the characteristic is zero. -/\ntheorem (R : Type u) [semiring R] [nontrivial R] (p : ‚Ñï) [hp : char_p R p] [hq : exp_char R 1] : p = 0 :=\n\n/-- The characteristic equals the exponential characteristic iff the former is prime. -/\ntheorem (R : Type u) [semiring R] (p q : ‚Ñï) [hp : char_p R p] [hq : exp_char R q] : p = q ‚Üî nat.prime p :=\n\n/-- A helper lemma: the characteristic is prime if it is non-zero. -/\ntheorem (R : Type u) [semiring R] [nontrivial R] [no_zero_divisors R] {p : ‚Ñï} [hp : char_p R p] (p_ne_zero : p ‚â† 0) : nat.prime p :=\n\n/--  The characteristic polynomial of the map `Œª x, a * x` is the minimal polynomial of `a`.  In combination with `det_eq_sign_charpoly_coeff` or `trace_eq_neg_charpoly_coeff` and a bit of rewriting, this will allow us to conclude the field norm resp. trace of `x` is the product resp. sum of `x`'s conjugates. -/\ntheorem {K : Type u_1} {S : Type u_2} [field K] [comm_ring S] [algebra K S] (h : power_basis K S) : (‚áë(algebra.left_mul_matrix h.basis) h.gen).charpoly = minpoly K h.gen :=\n\n/-- The exponential characteristic is a prime number or one. -/\ntheorem (R : Type u) [semiring R] [nontrivial R] [no_zero_divisors R] (q : ‚Ñï) [hq : exp_char R q] : nat.prime q ‚à® q = 1 :=\n\n/-- If `R` has characteristic `0`, then so does Frac(R). -/\ntheorem (R : Type u_1) {K : Type u_2} [comm_ring R] [field K] [algebra R K] [is_fraction_ring R K] [char_zero R] : char_zero K :=\n\n/-- Transposing a matrix preserves the determinant. -/\ntheorem {n : Type u_2} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] (M : matrix n n R) : M.transpose.det = M.det :=\n\n/-- The number of complex roots equals the number of real roots plus    the number of roots not fixed by complex conjugation (i.e. with some imaginary component). -/\ntheorem (p : polynomial ‚Ñö) : (p.root_set ‚ÑÇ).to_finset.card = (p.root_set ‚Ñù).to_finset.card + (‚áë(polynomial.gal.gal_action_hom p ‚ÑÇ) (‚áë(polynomial.gal.restrict p ‚ÑÇ) (alg_equiv.restrict_scalars ‚Ñö complex.conj_ae))).support.card :=\n\n/-- The geometric sequence `q^n` is a solution of `E` iff  `q` is a root of `E`'s characteristic polynomial. -/\ntheorem {Œ± : Type u_1} [comm_ring Œ±] (E : linear_recurrence Œ±) (q : Œ±) : E.is_solution (Œª (n : ‚Ñï), q ^ n) ‚Üî E.char_poly.is_root q :=\n\n/--  The **Cayley-Hamilton Theorem**, that the characteristic polynomial of a linear map, applied to the linear map itself, is zero.  See `matrix.aeval_self_charpoly` for the equivalent statement about matrices. -/\ntheorem {R : Type u} {M : Type v} [comm_ring R] [nontrivial R] [add_comm_group M] [module R M] [module.free R M] [module.finite R M] (f : M ‚Üí‚Çó[R] M) : ‚áë(polynomial.aeval f) f.charpoly = 0 :=\n\n/-- `charpoly f` is the characteristic polynomial of the matrix of `f` in any basis. -/\ntheorem {R : Type u} {M : Type v} [comm_ring R] [nontrivial R] [add_comm_group M] [module R M] [module.free R M] [module.finite R M] (f : M ‚Üí‚Çó[R] M) {Œπ : Type w} [fintype Œπ] (b : basis Œπ R M) : (‚áë(linear_map.to_matrix b b) f).charpoly = f.charpoly :=\n\n/-- The characteristic polynomial of every matrix has real roots. -/\ntheorem "}
{"text": "In a commutative ring, every prime ideal is contained in a unique maximal ideal.", "fullPrompt": "/--  A prime that does not divide the cardinality of a finite commutative ring `R` is a unit in `R`. -/\ntheorem {R : Type u_1} [comm_ring R] [fintype R] (p : ‚Ñï) [fact (nat.prime p)] (hp : p ‚à£ fintype.card R) : ¬¨is_unit ‚Üëp :=\n\n/--  A prime `p` is a unit in a finite commutative ring `R` iff it does not divide the characteristic. -/\ntheorem (R : Type u_1) [comm_ring R] [fintype R] (p : ‚Ñï) [fact (nat.prime p)] : is_unit ‚Üëp ‚Üî ¬¨p ‚à£ ring_char R :=\n\n/--  The prime divisors of the characteristic of a finite commutative ring are exactly the prime divisors of its cardinality. -/\ntheorem {R : Type u_1} [comm_ring R] [fintype R] (p : ‚Ñï) [fact (nat.prime p)] : p ‚à£ ring_char R ‚Üî p ‚à£ fintype.card R :=\n\n/-- The variable of the power series ring over an integral domain is prime. -/\ntheorem {R : Type u_1} [comm_ring R] [is_domain R] : prime power_series.X :=\n\n/-- A minimal polynomial is prime. -/\ntheorem {A : Type u_1} {B : Type u_2} [field A] [ring B] [is_domain B] [algebra A B] {x : B} (hx : is_integral A x) : prime (minpoly A x) :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem  : set.inj_on nat.factorization {x : ‚Ñï | x ‚â† 0} :=\n\n/-- Hilbert basis theorem: a polynomial ring over a noetherian ring is a noetherian ring. -/\ntheorem {R : Type u} [comm_ring R] [is_noetherian_ring R] : is_noetherian_ring (polynomial R) :=\n\n/-- A localization always has cardinality less than or equal to the base ring. -/\ntheorem {R : Type u} [comm_ring R] (S : submonoid R) {L : Type u} [comm_ring L] [algebra R L] [is_localization S L] : cardinal.mk L ‚â§ cardinal.mk R :=\n\n/-- An integral domain in which there is an irreducible element `p` such that every nonzero element is associated to a power of `p` is a discrete valuation ring. -/\ntheorem {R : Type u} [comm_ring R] [is_domain R] (hR : discrete_valuation_ring.has_unit_mul_pow_irreducible_factorization R) : discrete_valuation_ring R :=\n\n/--  An algebra over a Noetherian ring is finitely generated if and only if it is finitely presented. -/\ntheorem {R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] [is_noetherian_ring R] : algebra.finite_type R A ‚Üî algebra.finite_presentation R A :=\n\n/-- If an element a divides another element b in a commutative ring, a divides the sum of b and  another element c iff a divides c. -/\ntheorem {Œ± : Type u} [non_unital_ring Œ±] {a b c : Œ±} (h : a ‚à£ b) : a ‚à£ b + c ‚Üî a ‚à£ c :=\n\n/-- A helper lemma: the characteristic is prime if it is non-zero. -/\ntheorem (R : Type u) [semiring R] [nontrivial R] [no_zero_divisors R] {p : ‚Ñï} [hp : char_p R p] (p_ne_zero : p ‚â† 0) : nat.prime p :=\n\n/-- If an element a divides another element c in a commutative ring, a divides the sum of another  element b with c iff a divides b. -/\ntheorem {Œ± : Type u} [non_unital_ring Œ±] {a b c : Œ±} (h : a ‚à£ c) : a ‚à£ b + c ‚Üî a ‚à£ b :=\n\n/-- an integral domain is a DVR iff it's a PID with a unique non-zero prime ideal -/\ntheorem (R : Type u) [comm_ring R] [is_domain R] : discrete_valuation_ring R ‚Üî is_principal_ideal_ring R ‚àß ‚àÉ! (P : ideal R), P ‚â† ‚ä• ‚àß P.is_prime :=\n\n/-- The kernel of a homomorphism to a domain is a prime ideal. -/\ntheorem {R : Type u} {S : Type v} [ring R] [ring S] [is_domain S] (f : R ‚Üí+* S) : f.ker.is_prime :=\n\n/-- Given a submodule `M ‚äÜ R` and a prime ideal `p` of `S = M‚Åª¬πR`, with `f : R ‚Üí+* S` the localization map, then `T = S‚Çö` is the localization of `R` at `f‚Åª¬π(p)`. -/\ntheorem {R : Type u_1} [comm_ring R] (M : submonoid R) {S : Type u_2} [comm_ring S] [algebra R S] (T : Type u_4) [comm_ring T] [algebra R T] [algebra S T] [is_scalar_tower R S T] [is_localization M S] (p : ideal S) [Hp : p.is_prime] [is_localization.at_prime T p] : is_localization.at_prime T (ideal.comap (algebra_map R S) p) :=\n\n/--  If `f` is a non constant polynomial with coefficients in `R`, and `P` is a prime ideal in `R`, then if every coefficient in `R` except the leading coefficient is in `P`, and the trailing coefficient is not in `P^2` and no non units in `R` divide `f`, then `f` is irreducible. -/\ntheorem {R : Type u_1} [comm_ring R] [is_domain R] {f : polynomial R} {P : ideal R} (hP : P.is_prime) (hfl : f.leading_coeff ‚àâ P) (hfP : ‚àÄ (n : ‚Ñï), ‚Üën < f.degree ‚Üí f.coeff n ‚àà P) (hfd0 : 0 < f.degree) (h0 : f.coeff 0 ‚àâ P ^ 2) (hu : f.is_primitive) : irreducible f :=\n\n/-- The image of the maximal ideal of the source is contained within the maximal ideal of the target. -/\ntheorem {R : Type u} {S : Type v} [comm_semiring R] [local_ring R] [comm_semiring S] [local_ring S] (f : R ‚Üí+* S) [is_local_ring_hom f] (a : R) (h : a ‚àà local_ring.maximal_ideal R) : ‚áëf a ‚àà local_ring.maximal_ideal S :=\n\n/-- The kernel of a homomorphism to a field is a maximal ideal. -/\ntheorem {R : Type u_1} {K : Type u_2} [ring R] [field K] (f : R ‚Üí+* K) (hf : function.surjective ‚áëf) : f.ker.is_maximal :=\n\n/-- If `R` is a Jacobson ring, and `P` is a maximal ideal of `polynomial R`,  then `R ‚Üí R[X]/P` is an integral map. -/\ntheorem {R : Type u_1} [comm_ring R] [ideal.is_jacobson R] (P : ideal (polynomial R)) [hP : P.is_maximal] : ((ideal.quotient.mk P).comp polynomial.C).is_integral :=\n\n/-- An element of a DVR is irreducible iff it is a uniformizer, that is, generates the  maximal ideal of R -/\ntheorem {R : Type u} [comm_ring R] [is_domain R] [discrete_valuation_ring R] (œñ : R) : irreducible œñ ‚Üî local_ring.maximal_ideal R = ideal.span {œñ} :=\n\n/-- In a commutative ring, every prime ideal is contained in a unique maximal ideal. -/\ntheorem "}
{"text": "Every continuous function is uniformly continuous.", "fullPrompt": "/-- The new distance is uniformly continuous. -/\ntheorem {Œ± : Type u} [pseudo_metric_space Œ±] : uniform_continuous (Œª (p : uniform_space.completion Œ± √ó uniform_space.completion Œ±), has_dist.dist p.fst p.snd) :=\n\n/-- The minimal distance to a set is uniformly continuous in point -/\ntheorem {Œ± : Type u} [pseudo_metric_space Œ±] (s : set Œ±) : uniform_continuous (Œª (x : Œ±), metric.inf_dist x s) :=\n\n/-- The minimal distance to a set (as `‚Ñù‚â•0`) is uniformly continuous in point -/\ntheorem {Œ± : Type u} [pseudo_metric_space Œ±] (s : set Œ±) : uniform_continuous (Œª (x : Œ±), metric.inf_nndist x s) :=\n\n/-- The indexed supremum of a function is bounded above by a uniform bound -/\ntheorem {Œ± : Type u_1} {Œπ : Sort u_3} [conditionally_complete_lattice Œ±] [nonempty Œπ] {f : Œπ ‚Üí Œ±} {c : Œ±} (H : ‚àÄ (x : Œπ), f x ‚â§ c) : supr f ‚â§ c :=\n\n/-- On an empty space, bounded continuous functions are at distance 0 -/\ntheorem {Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [pseudo_metric_space Œ≤] {f g : bounded_continuous_function Œ± Œ≤} [is_empty Œ±] : has_dist.dist f g = 0 :=\n\n/-- In a sequential space, continuity and sequential continuity coincide. -/\ntheorem {X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] {f : X ‚Üí Y} [sequential_space X] : continuous f ‚Üî seq_continuous f :=\n\n/-- The minimal distance to a set is continuous in point -/\ntheorem {Œ± : Type u} [pseudo_metric_space Œ±] (s : set Œ±) : continuous (Œª (x : Œ±), metric.inf_dist x s) :=\n\n/--  If `f` is a Lipschitz continuous map, then the Hausdorff dimension of its range is at most the Hausdorff dimension of its domain. -/\ntheorem {X : Type u_2} {Y : Type u_3} [emetric_space X] [emetric_space Y] {K : nnreal} {f : X ‚Üí Y} (h : lipschitz_with K f) : dimH (set.range f) ‚â§ dimH set.univ :=\n\n/-- A continuous surjective open map is a quotient map. -/\ntheorem {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {f : Œ± ‚Üí Œ≤} (open_map : is_open_map f) (cont : continuous f) (surj : function.surjective f) : quotient_map f :=\n\n/-- The indexed minimum of a function is bounded below by a uniform lower bound -/\ntheorem {Œ± : Type u_1} {Œπ : Sort u_3} [conditionally_complete_lattice Œ±] [nonempty Œπ] {f : Œπ ‚Üí Œ±} {c : Œ±} (H : ‚àÄ (x : Œπ), c ‚â§ f x) : c ‚â§ infi f :=\n\n/-- The minimal distance to a set (as `‚Ñù‚â•0`) is continuous in point -/\ntheorem {Œ± : Type u} [pseudo_metric_space Œ±] (s : set Œ±) : continuous (Œª (x : Œ±), metric.inf_nndist x s) :=\n\n/-- The indexed supremum of a function is bounded below by the value taken at one point -/\ntheorem {Œ± : Type u_1} {Œπ : Sort u_3} [conditionally_complete_lattice Œ±] {f : Œπ ‚Üí Œ±} (H : bdd_above (set.range f)) (c : Œπ) : f c ‚â§ supr f :=\n\n/-- A H√∂lder continuous function is uniformly continuous -/\ntheorem {X : Type u_1} {Y : Type u_2} [pseudo_emetric_space X] [pseudo_emetric_space Y] {C r : nnreal} {f : X ‚Üí Y} (hf : holder_with C r f) (h0 : 0 < r) : uniform_continuous f :=\n\n/-- A H√∂lder continuous function is uniformly continuous -/\ntheorem {X : Type u_1} {Y : Type u_2} [pseudo_emetric_space X] [pseudo_emetric_space Y] {C r : nnreal} {f : X ‚Üí Y} {s : set X} (hf : holder_on_with C r f s) (h0 : 0 < r) : uniform_continuous_on f s :=\n\n/-- A Lipschitz function is uniformly continuous -/\ntheorem {Œ± : Type u} {Œ≤ : Type v} [pseudo_emetric_space Œ±] [pseudo_emetric_space Œ≤] {K : nnreal} {f : Œ± ‚Üí Œ≤} (hf : lipschitz_with K f) : uniform_continuous f :=\n\n/-- The composition operator (in the target) with a Lipschitz map is uniformly continuous -/\ntheorem {Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type w} [topological_space Œ±] [pseudo_metric_space Œ≤] [pseudo_metric_space Œ≥] {G : Œ≤ ‚Üí Œ≥} {C : nnreal} (H : lipschitz_with C G) : uniform_continuous (bounded_continuous_function.comp G H) :=\n\n/-- The coercion from `lp E p` to `Œ† i, E i` is uniformly continuous. -/\ntheorem {Œ± : Type u_1} {E : Œ± ‚Üí Type u_2} {p : ennreal} [Œ† (i : Œ±), normed_group (E i)] [fact (1 ‚â§ p)] : uniform_continuous coe :=\n\n/--  Heine-Cantor: a continuous function on a compact set of a separated uniform space is uniformly continuous. -/\ntheorem {Œ± : Type u_1} {Œ≤ : Type u_2} [uniform_space Œ±] [uniform_space Œ≤] [separated_space Œ±] {s : set Œ±} {f : Œ± ‚Üí Œ≤} (hs : is_compact s) (hf : continuous_on f s) : uniform_continuous_on f s :=\n\n/--  Heine-Cantor: a continuous function on a compact separated set of a uniform space is uniformly continuous. -/\ntheorem {Œ± : Type u_1} {Œ≤ : Type u_2} [uniform_space Œ±] [uniform_space Œ≤] {s : set Œ±} {f : Œ± ‚Üí Œ≤} (hs : is_compact s) (hs' : is_separated s) (hf : continuous_on f s) : uniform_continuous_on f s :=\n\n/-- Every continuous function is uniformly continuous. -/\ntheorem "}
{"text": "Every uniformly continuous function is bounded above.", "fullPrompt": "/-- The indexed supremum of a function is bounded above by a uniform bound -/\ntheorem {Œ± : Type u_1} {Œπ : Sort u_3} [conditionally_complete_lattice Œ±] [nonempty Œπ] {f : Œπ ‚Üí Œ±} {c : Œ±} (H : ‚àÄ (x : Œπ), f x ‚â§ c) : supr f ‚â§ c :=\n\n/-- The indexed minimum of a function is bounded below by a uniform lower bound -/\ntheorem {Œ± : Type u_1} {Œπ : Sort u_3} [conditionally_complete_lattice Œ±] [nonempty Œπ] {f : Œπ ‚Üí Œ±} {c : Œ±} (H : ‚àÄ (x : Œπ), c ‚â§ f x) : c ‚â§ infi f :=\n\n/-- The indexed supremum of a function is bounded below by the value taken at one point -/\ntheorem {Œ± : Type u_1} {Œπ : Sort u_3} [conditionally_complete_lattice Œ±] {f : Œπ ‚Üí Œ±} (H : bdd_above (set.range f)) (c : Œπ) : f c ‚â§ supr f :=\n\n/-- When there is a global maximum, every set is bounded above. -/\ntheorem {Œ≥ : Type w} [preorder Œ≥] [order_top Œ≥] (s : set Œ≥) : bdd_above s :=\n\n/-- A compact set is bounded above -/\ntheorem {Œ± : Type u} [topological_space Œ±] [linear_order Œ±] [order_closed_topology Œ±] [nonempty Œ±] {s : set Œ±} (hs : is_compact s) : bdd_above s :=\n\n/-- The minimal distance to a set is uniformly continuous in point -/\ntheorem {Œ± : Type u} [pseudo_metric_space Œ±] (s : set Œ±) : uniform_continuous (Œª (x : Œ±), metric.inf_dist x s) :=\n\n/-- The minimal distance to a set (as `‚Ñù‚â•0`) is uniformly continuous in point -/\ntheorem {Œ± : Type u} [pseudo_metric_space Œ±] (s : set Œ±) : uniform_continuous (Œª (x : Œ±), metric.inf_nndist x s) :=\n\n/-- Adding a point to a set preserves its boundedness above. -/\ntheorem {Œ≥ : Type w} [semilattice_sup Œ≥] (a : Œ≥) {s : set Œ≥} : bdd_above (has_insert.insert a s) ‚Üî bdd_above s :=\n\n/-- The indexed infimum of a function is bounded above by the value taken at one point -/\ntheorem {Œ± : Type u_1} {Œπ : Sort u_3} [conditionally_complete_lattice Œ±] {f : Œπ ‚Üí Œ±} (H : bdd_below (set.range f)) (c : Œπ) : infi f ‚â§ f c :=\n\n/-- The new distance is uniformly continuous. -/\ntheorem {Œ± : Type u} [pseudo_metric_space Œ±] : uniform_continuous (Œª (p : uniform_space.completion Œ± √ó uniform_space.completion Œ±), has_dist.dist p.fst p.snd) :=\n\n/-- Adding a point to a set preserves its boundedness below. -/\ntheorem {Œ≥ : Type w} [semilattice_inf Œ≥] (a : Œ≥) {s : set Œ≥} : bdd_below (has_insert.insert a s) ‚Üî bdd_below s :=\n\n/-- On an empty space, bounded continuous functions are at distance 0 -/\ntheorem {Œ± : Type u} {Œ≤ : Type v} [topological_space Œ±] [pseudo_metric_space Œ≤] {f g : bounded_continuous_function Œ± Œ≤} [is_empty Œ±] : has_dist.dist f g = 0 :=\n\n/-- Composing on the left by a uniformly continuous function preserves  uniform convergence on a set -/\ntheorem {Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} {Œπ : Type u_4} [uniform_space Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {s : set Œ±} {p : filter Œπ} [uniform_space Œ≥] {g : Œ≤ ‚Üí Œ≥} (h : tendsto_uniformly_on F f p s) (hg : uniform_continuous g) : tendsto_uniformly_on (Œª (i : Œπ), g ‚àò F i) (g ‚àò f) p s :=\n\n/-- Composing on the left by a uniformly continuous function preserves uniform convergence -/\ntheorem {Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} {Œπ : Type u_4} [uniform_space Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {p : filter Œπ} [uniform_space Œ≥] {g : Œ≤ ‚Üí Œ≥} (h : tendsto_uniformly F f p) (hg : uniform_continuous g) : tendsto_uniformly (Œª (i : Œπ), g ‚àò F i) (g ‚àò f) p :=\n\n/-- The composition operator (in the target) with a Lipschitz map is uniformly continuous -/\ntheorem {Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type w} [topological_space Œ±] [pseudo_metric_space Œ≤] [pseudo_metric_space Œ≥] {G : Œ≤ ‚Üí Œ≥} {C : nnreal} (H : lipschitz_with C G) : uniform_continuous (bounded_continuous_function.comp G H) :=\n\n/-- The coercion from `lp E p` to `Œ† i, E i` is uniformly continuous. -/\ntheorem {Œ± : Type u_1} {E : Œ± ‚Üí Type u_2} {p : ennreal} [Œ† (i : Œ±), normed_group (E i)] [fact (1 ‚â§ p)] : uniform_continuous coe :=\n\n/--  Heine-Cantor: a continuous function on a compact set of a separated uniform space is uniformly continuous. -/\ntheorem {Œ± : Type u_1} {Œ≤ : Type u_2} [uniform_space Œ±] [uniform_space Œ≤] [separated_space Œ±] {s : set Œ±} {f : Œ± ‚Üí Œ≤} (hs : is_compact s) (hf : continuous_on f s) : uniform_continuous_on f s :=\n\n/--  Heine-Cantor: a continuous function on a compact separated set of a uniform space is uniformly continuous. -/\ntheorem {Œ± : Type u_1} {Œ≤ : Type u_2} [uniform_space Œ±] [uniform_space Œ≤] {s : set Œ±} {f : Œ± ‚Üí Œ≤} (hs : is_compact s) (hs' : is_separated s) (hf : continuous_on f s) : uniform_continuous_on f s :=\n\n/-- Every uniformly continuous function is bounded above. -/\ntheorem "}
{"text": "If every compact subset of a topological space is closed, then the space is compact.", "fullPrompt": "/-- A closed subset of a compact set is a compact set. -/\ntheorem {Œ± : Type u} [topological_space Œ±] {s t : set Œ±} (hs : is_compact s) (ht : is_closed t) (h : t ‚äÜ s) : is_compact t :=\n\n/-- The intersection of a compact set and a closed set is a compact set. -/\ntheorem {Œ± : Type u} [topological_space Œ±] {s t : set Œ±} (hs : is_compact s) (ht : is_closed t) : is_compact (s ‚à© t) :=\n\n/-- The intersection of a closed set and a compact set is a compact set. -/\ntheorem {Œ± : Type u} [topological_space Œ±] {s t : set Œ±} (ht : is_compact t) (hs : is_closed s) : is_compact (s ‚à© t) :=\n\n/-- In a `t2_space`, every compact set is closed. -/\ntheorem {Œ± : Type u} [topological_space Œ±] [t2_space Œ±] {s : set Œ±} (hs : is_compact s) : is_closed s :=\n\n/-- In a locally compact space, every compact set is contained in the interior of a compact set. -/\ntheorem {Œ± : Type u} [topological_space Œ±] [locally_compact_space Œ±] {K : set Œ±} (hK : is_compact K) : ‚àÉ (K' : set Œ±), is_compact K' ‚àß K ‚äÜ interior K' :=\n\n/-- In a locally compact T‚ÇÇ space, every point has an open neighborhood with compact closure -/\ntheorem {Œ± : Type u} [topological_space Œ±] [locally_compact_space Œ±] [t2_space Œ±] (x : Œ±) : ‚àÉ (U : set Œ±), is_open U ‚àß x ‚àà U ‚àß is_compact (closure U) :=\n\n/-- A compact set is bounded above -/\ntheorem {Œ± : Type u} [topological_space Œ±] [linear_order Œ±] [order_closed_topology Œ±] [nonempty Œ±] {s : set Œ±} (hs : is_compact s) : bdd_above s :=\n\n/-- An unordered closed interval is compact. -/\ntheorem {Œ± : Type u_1} [linear_order Œ±] [topological_space Œ±] [compact_Icc_space Œ±] {a b : Œ±} : is_compact (set.interval a b) :=\n\n/-- A set is sequentially closed if it is closed. -/\ntheorem {X : Type u_1} [topological_space X] {s : set X} (hs : is_closed s) : is_seq_closed s :=\n\n/-- In a sequential space, a set is closed iff it's sequentially closed. -/\ntheorem {X : Type u_1} [topological_space X] [sequential_space X] {s : set X} : is_seq_closed s ‚Üî is_closed s :=\n\n/--  Every separated topological group in which there exists a compact set with nonempty interior is locally compact. -/\ntheorem {G : Type w} [topological_space G] [group G] [topological_group G] [t2_space G] (K : topological_space.positive_compacts G) : locally_compact_space G :=\n\n/-- If X is is_compact then pr‚ÇÇ : X √ó Y ‚Üí Y is a closed map -/\ntheorem {X : Type u_1} [topological_space X] [compact_space X] {Y : Type u_2} [topological_space Y] : is_closed_map prod.snd :=\n\n/--  The **Banach-Alaoglu theorem**: the polar set of a neighborhood `s` of the origin in a normed space `E` is a compact subset of `weak_dual ùïú E`. -/\ntheorem (ùïú : Type u_1) [nondiscrete_normed_field ùïú] {E : Type u_2} [semi_normed_group E] [normed_space ùïú E] [proper_space ùïú] {s : set E} (s_nhd : s ‚àà nhds 0) : is_compact (weak_dual.polar ùïú s) :=\n\n/--  A family `F` of functions in `C(Œ±, Œ≤)` converges in the compact-open topology, if and only if it converges in the compact-open topology on each compact subset of `Œ±`. -/\ntheorem {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] [locally_compact_space Œ±] [t2_space Œ±] [t2_space Œ≤] {Œπ : Type u_3} {l : filter Œπ} [l.ne_bot] (F : Œπ ‚Üí C(Œ±, Œ≤)) : (‚àÉ (f : C(Œ±, Œ≤)), filter.tendsto F l (nhds f)) ‚Üî ‚àÄ (s : set Œ±), is_compact s ‚Üí (‚àÉ (f : C(‚Ü•s, Œ≤)), filter.tendsto (Œª (i : Œπ), continuous_map.restrict s (F i)) l (nhds f)) :=\n\n/-- A reformulation of the definition of locally compact space: In a locally compact space,  every open set containing `x` has a compact subset containing `x` in its interior. -/\ntheorem {Œ± : Type u} [topological_space Œ±] [locally_compact_space Œ±] {x : Œ±} {U : set Œ±} (hU : is_open U) (hx : x ‚àà U) : ‚àÉ (K : set Œ±), is_compact K ‚àß x ‚àà interior K ‚àß K ‚äÜ U :=\n\n/-- If every compact subset of a topological space is closed, then the space is compact. -/\ntheorem "}
{"text": "In a commutative ring, the sum of idempotent elements is idempotent.", "fullPrompt": "/-- Compressing an element is idempotent. -/\ntheorem {Œ± : Type u_1} [generalized_boolean_algebra Œ±] [decidable_rel disjoint] [decidable_rel has_le.le] (u v a : Œ±) : uv.compress u v (uv.compress u v a) = uv.compress u v a :=\n\n/-- An element of a ring multiplied by the additive inverse of one is the element's additive  inverse. -/\ntheorem {Œ± : Type u} [mul_one_class Œ±] [has_distrib_neg Œ±] (a : Œ±) : a * -1 = -a :=\n\n/-- The identity map is an additive monoid homomorphism. -/\ntheorem {Œ± : Type u} [add_zero_class Œ±] : is_add_monoid_hom id :=\n\n/-- The identity map is a ring homomorphism. -/\ntheorem {Œ± : Type u} [ring Œ±] : is_ring_hom id :=\n\n/-- The identity map preserves addition -/\ntheorem {Œ± : Type u} [has_add Œ±] : is_add_hom id :=\n\n/-- Commuting elements of finite additive order are closed under addition. -/\ntheorem {G : Type u} {y : G} [add_monoid G] {x : G} (h : add_commute x y) (hx : is_of_fin_add_order x) (hy : is_of_fin_add_order y) : is_of_fin_add_order (x + y) :=\n\n/-- If an element a divides another element b in a commutative ring, a divides the sum of b and  another element c iff a divides c. -/\ntheorem {Œ± : Type u} [non_unital_ring Œ±] {a b c : Œ±} (h : a ‚à£ b) : a ‚à£ b + c ‚Üî a ‚à£ c :=\n\n/-- The additive inverse of one multiplied by an element of a ring is the element's additive  inverse. -/\ntheorem {Œ± : Type u} [mul_one_class Œ±] [has_distrib_neg Œ±] (a : Œ±) : (-1) * a = -a :=\n\n/-- Ring homomorphisms preserve additive inverses. -/\ntheorem {Œ± : Type u} {Œ≤ : Type v} [ring Œ±] [ring Œ≤] {f : Œ± ‚Üí Œ≤} {x : Œ±} (hf : is_ring_hom f) : f (-x) = -f x :=\n\n/-- Left multiplication in a ring is an additive monoid morphism. -/\ntheorem {Œ≥ : Type u_1} [non_unital_non_assoc_semiring Œ≥] (x : Œ≥) : is_add_monoid_hom (Œª (y : Œ≥), x * y) :=\n\n/-- Right multiplication in a ring is an additive monoid morphism. -/\ntheorem {Œ≥ : Type u_1} [non_unital_non_assoc_semiring Œ≥] (x : Œ≥) : is_add_monoid_hom (Œª (y : Œ≥), y * x) :=\n\n/-- An additive group homomorphism is an additive monoid homomorphism. -/\ntheorem {Œ± : Type u} {Œ≤ : Type v} [add_group Œ±] [add_group Œ≤] {f : Œ± ‚Üí Œ≤} (hf : is_add_group_hom f) : is_add_monoid_hom f :=\n\n/--  A prime that does not divide the cardinality of a finite commutative ring `R` is a unit in `R`. -/\ntheorem {R : Type u_1} [comm_ring R] [fintype R] (p : ‚Ñï) [fact (nat.prime p)] (hp : p ‚à£ fintype.card R) : ¬¨is_unit ‚Üëp :=\n\n/--  A prime `p` is a unit in a finite commutative ring `R` iff it does not divide the characteristic. -/\ntheorem (R : Type u_1) [comm_ring R] [fintype R] (p : ‚Ñï) [fact (nat.prime p)] : is_unit ‚Üëp ‚Üî ¬¨p ‚à£ ring_char R :=\n\n/--  The prime divisors of the characteristic of a finite commutative ring are exactly the prime divisors of its cardinality. -/\ntheorem {R : Type u_1} [comm_ring R] [fintype R] (p : ‚Ñï) [fact (nat.prime p)] : p ‚à£ ring_char R ‚Üî p ‚à£ fintype.card R :=\n\n/-- If an element a divides another element c in a commutative ring, a divides the sum of another  element b with c iff a divides b. -/\ntheorem {Œ± : Type u} [non_unital_ring Œ±] {a b c : Œ±} (h : a ‚à£ c) : a ‚à£ b + c ‚Üî a ‚à£ b :=\n\n/-- In a commutative ring, the sum of idempotent elements is idempotent. -/\ntheorem "}
{"text": "The number of partitions of a finite set is a prime number.", "fullPrompt": "/-- Factoring a prime gives the corresponding one-element multiset. -/\ntheorem (p : nat.primes) : ‚Üëp.factor_multiset = prime_multiset.of_prime p :=\n\n/-- A finite field has prime power cardinality. -/\ntheorem {Œ± : Type u_1} [fintype Œ±] [field Œ±] : is_prime_pow (fintype.card Œ±) :=\n\n/--  An equivalent definition for prime powers: `n` is a prime power iff there is a unique prime dividing it. -/\ntheorem {n : ‚Ñï} : is_prime_pow n ‚Üî ‚àÉ! (p : ‚Ñï), nat.prime p ‚àß p ‚à£ n :=\n\n/-- Prime `p` divides the product of a list `L` iff it divides some `a ‚àà L` -/\ntheorem {M : Type u_1} [comm_monoid_with_zero M] {p : M} {L : list M} (pp : prime p) : p ‚à£ L.prod ‚Üî ‚àÉ (a : M) (H : a ‚àà L), p ‚à£ a :=\n\n/-- A finite group of prime order is simple. -/\ntheorem {Œ± : Type u} [group Œ±] [fintype Œ±] {p : ‚Ñï} [hp : fact (nat.prime p)] (h : fintype.card Œ± = p) : is_simple_group Œ± :=\n\n/-- **Number of Subsets of a Set** -/\ntheorem {Œ± : Type u_1} (s : finset Œ±) : s.powerset.card = 2 ^ s.card :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem {Œ± : Type u} [group Œ±] [fintype Œ±] {p : ‚Ñï} [hp : fact (nat.prime p)] (h : fintype.card Œ± = p) : is_cyclic Œ± :=\n\n/--  A prime that does not divide the cardinality of a finite commutative ring `R` is a unit in `R`. -/\ntheorem {R : Type u_1} [comm_ring R] [fintype R] (p : ‚Ñï) [fact (nat.prime p)] (hp : p ‚à£ fintype.card R) : ¬¨is_unit ‚Üëp :=\n\n/--  The prime divisors of the characteristic of a finite commutative ring are exactly the prime divisors of its cardinality. -/\ntheorem {R : Type u_1} [comm_ring R] [fintype R] (p : ‚Ñï) [fact (nat.prime p)] : p ‚à£ ring_char R ‚Üî p ‚à£ fintype.card R :=\n\n/-- If the factorization of `n` contains just one number `p` then `n` is a power of `p` -/\ntheorem {n p k : ‚Ñï} (hn : n ‚â† 0) (h : n.factorization = finsupp.single p k) : n = p ^ k :=\n\n/--  For every prime `p` dividing the order of a finite group `G` there exists an element of order `p` in `G`. This is known as Cauchy's theorem. -/\ntheorem {G : Type u_1} [group G] [fintype G] (p : ‚Ñï) [hp : fact (nat.prime p)] (hdvd : p ‚à£ fintype.card G) : ‚àÉ (x : G), order_of x = p :=\n\n/--  An equivalent definition for prime powers: `n` is a prime power iff there is a prime `p` and a natural `k` such that `n` can be written as `p^(k+1)`. -/\ntheorem {R : Type u_1} [comm_monoid_with_zero R] (n : R) : is_prime_pow n ‚Üî ‚àÉ (p : R) (k : ‚Ñï), prime p ‚àß p ^ (k + 1) = n :=\n\n/-- The exponential characteristic is a prime number or one. -/\ntheorem (R : Type u) [semiring R] [nontrivial R] [no_zero_divisors R] (q : ‚Ñï) [hq : exp_char R q] : nat.prime q ‚à® q = 1 :=\n\n/--  Euclid's theorem on the **infinitude of primes**. Here given in the form: for every `n`, there exists a prime number `p ‚â• n`. -/\ntheorem (n : ‚Ñï) : ‚àÉ (p : ‚Ñï), n ‚â§ p ‚àß nat.prime p :=\n\n/-- The number of partitions of a finite set is a prime number. -/\ntheorem "}
{"text": "If a poset has a maximal element, then it has a unique minimal element.", "fullPrompt": "/-- If `Œ±` is a preorder with no maximal element, then `at_top ‚â§ cofinite`. -/\ntheorem {Œ± : Type u_2} [preorder Œ±] [no_max_order Œ±] : filter.at_top ‚â§ filter.cofinite :=\n\n/--  If `Œ±` is a nonempty preorder with no minimal or maximal elements, then there exists a strictly monotone function `f : ‚Ñ§ ‚Üí Œ±`. -/\ntheorem (Œ± : Type u) [preorder Œ±] [nonempty Œ±] [no_min_order Œ±] [no_max_order Œ±] : ‚àÉ (f : ‚Ñ§ ‚Üí Œ±), strict_mono f :=\n\n/-- The supremum of a singleton is the element of the singleton -/\ntheorem {Œ± : Type u_1} [conditionally_complete_lattice Œ±] (a : Œ±) : has_Sup.Sup {a} = a :=\n\n/-- The infimum of a singleton is the element of the singleton -/\ntheorem {Œ± : Type u_1} [conditionally_complete_lattice Œ±] (a : Œ±) : has_Inf.Inf {a} = a :=\n\n/--  If `Œ±` is a nonempty preorder with no maximal elements, then there exists a strictly monotone function `‚Ñï ‚Üí Œ±`. -/\ntheorem (Œ± : Type u) [preorder Œ±] [nonempty Œ±] [no_max_order Œ±] : ‚àÉ (f : ‚Ñï ‚Üí Œ±), strict_mono f :=\n\n/--  If `Œ±` is a nonempty preorder with no minimal elements, then there exists a strictly antitone function `‚Ñï ‚Üí Œ±`. -/\ntheorem (Œ± : Type u) [preorder Œ±] [nonempty Œ±] [no_min_order Œ±] : ‚àÉ (f : ‚Ñï ‚Üí Œ±), strict_anti f :=\n\n/-- If `X` has subobject lattice `{‚ä•, ‚ä§}`, then `X` is simple. -/\ntheorem {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] (X : C) [is_simple_order (category_theory.subobject X)] : category_theory.simple X :=\n\n/-- Every chain is contained in a maximal chain. This generalizes Hausdorff's maximality principle. -/\ntheorem {Œ± : Type u_1} {r : Œ± ‚Üí Œ± ‚Üí Prop} {c : set Œ±} (hc : is_chain r c) : ‚àÉ (M : set Œ±), is_max_chain r M ‚àß c ‚äÜ M :=\n\n/--  **Hausdorff's maximality principle**  There exists a maximal totally ordered set of `Œ±`. Note that we do not require `Œ±` to be partially ordered by `r`. -/\ntheorem {Œ± : Type u_1} {r : Œ± ‚Üí Œ± ‚Üí Prop} : is_max_chain r (max_chain r) :=\n\n/--  If `Œ±` is a preorder with no maximal elements, then there exists a strictly monotone function `‚Ñï ‚Üí Œ±` with any prescribed value of `f 0`. -/\ntheorem {Œ± : Type u} [preorder Œ±] [no_max_order Œ±] (a : Œ±) : ‚àÉ (f : ‚Ñï ‚Üí Œ±), strict_mono f ‚àß f 0 = a :=\n\n/-- `X` is simple iff it has subobject lattice `{‚ä•, ‚ä§}`. -/\ntheorem {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] (X : C) : category_theory.simple X ‚Üî is_simple_order (category_theory.subobject X) :=\n\n/-- If `s` has a least element, then it is bounded below. -/\ntheorem {Œ± : Type u} [preorder Œ±] {s : set Œ±} {a : Œ±} (h : is_least s a) : bdd_below s :=\n\n/--  A nonempty preorder with no maximal element is infinite. This is not an instance to avoid a cycle with `infinite Œ± ‚Üí nontrivial Œ± ‚Üí nonempty Œ±`. -/\ntheorem {Œ± : Type u_1} [preorder Œ±] [nonempty Œ±] [no_max_order Œ±] : infinite Œ± :=\n\n/--  A nonempty preorder with no minimal element is infinite. This is not an instance to avoid a cycle with `infinite Œ± ‚Üí nontrivial Œ± ‚Üí nonempty Œ±`. -/\ntheorem {Œ± : Type u_1} [preorder Œ±] [nonempty Œ±] [no_min_order Œ±] : infinite Œ± :=\n\n/--  A compact element `k` has the property that any `b < k` lies below a \"maximal element below `k`\", which is to say `[‚ä•, k]` is coatomic. -/\ntheorem {Œ± : Type u_1} [complete_lattice Œ±] {k : Œ±} (h : complete_lattice.is_compact_element k) : is_coatomic ‚Ü•(set.Iic k) :=\n\n/--  **Zorn's lemma**  If every chain has an upper bound, then there exists a maximal element. -/\ntheorem {Œ± : Type u_1} {r : Œ± ‚Üí Œ± ‚Üí Prop} (h : ‚àÄ (c : set Œ±), is_chain r c ‚Üí (‚àÉ (ub : Œ±), ‚àÄ (a : Œ±), a ‚àà c ‚Üí r a ub)) (trans : ‚àÄ {a b c : Œ±}, r a b ‚Üí r b c ‚Üí r a c) : ‚àÉ (m : Œ±), ‚àÄ (a : Œ±), r m a ‚Üí r a m :=\n\n/--  Given a subgroup `H` of a decidable linearly ordered archimedean abelian group `G`, if there exists a minimal element `a` of `H ‚à© G_{>0}` then `H` is generated by `a`. -/\ntheorem {G : Type u_1} [linear_ordered_add_comm_group G] [archimedean G] {H : add_subgroup G} {a : G} (ha : is_least {g : G | g ‚àà H ‚àß 0 < g} a) : H = add_subgroup.closure {a} :=\n\n/--  If `r` is a well-founded relation, then any nonempty set has a minimal element with respect to `r`. -/\ntheorem {Œ± : Type u_1} {r : Œ± ‚Üí Œ± ‚Üí Prop} (H : well_founded r) (s : set Œ±) : s.nonempty ‚Üí (‚àÉ (a : Œ±) (H : a ‚àà s), ‚àÄ (x : Œ±), x ‚àà s ‚Üí ¬¨r x a) :=\n\n/-- If a poset has a maximal element, then it has a unique minimal element. -/\ntheorem "}
{"text": "The automorphism group of an Abelian group is cyclic.", "fullPrompt": "/-- A finite group of prime order is cyclic. -/\ntheorem {Œ± : Type u} [group Œ±] [fintype Œ±] {p : ‚Ñï} [hp : fact (nat.prime p)] (h : fintype.card Œ± = p) : is_cyclic Œ± :=\n\n/-- A group homomorphism is a monoid homomorphism. -/\ntheorem {Œ± : Type u} {Œ≤ : Type v} [group Œ±] [group Œ≤] {f : Œ± ‚Üí Œ≤} (hf : is_group_hom f) : is_monoid_hom f :=\n\n/-- A map to a group preserving multiplication is a monoid homomorphism. -/\ntheorem {Œ± : Type u} {Œ≤ : Type v} [mul_one_class Œ±] [group Œ≤] {f : Œ± ‚Üí Œ≤} (hf : is_mul_hom f) : is_monoid_hom f :=\n\n/-- A group homomorphism sends 1 to 1. -/\ntheorem {Œ± : Type u} {Œ≤ : Type v} [group Œ±] [group Œ≤] {f : Œ± ‚Üí Œ≤} (hf : is_group_hom f) : f 1 = 1 :=\n\n/-- Commuting elements of finite order are closed under multiplication. -/\ntheorem {G : Type u} {y : G} [monoid G] {x : G} (h : commute x y) (hx : is_of_fin_order x) (hy : is_of_fin_order y) : is_of_fin_order (x * y) :=\n\n/-- The inverse of a group homomorphism is a group homomorphism if the target is commutative. -/\ntheorem {Œ± : Type u_1} {Œ≤ : Type u_2} [group Œ±] [comm_group Œ≤] {f : Œ± ‚Üí Œ≤} (hf : is_group_hom f) : is_group_hom (Œª (a : Œ±), (f a)‚Åª¬π) :=\n\n/-- A finite group of prime order is simple. -/\ntheorem {Œ± : Type u} [group Œ±] [fintype Œ±] {p : ‚Ñï} [hp : fact (nat.prime p)] (h : fintype.card Œ± = p) : is_simple_group Œ± :=\n\n/-- Inversion is a group homomorphism if the group is commutative. -/\ntheorem {Œ± : Type u} [comm_group Œ±] : is_group_hom has_inv.inv :=\n\n/--  Adding a group element to the point `p` is an injective function. -/\ntheorem {G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] (p : P) : function.injective (Œª (_x : G), _x +·µ• p) :=\n\n/-- Finite groups are torsion groups. -/\ntheorem {G : Type u_1} [group G] [fintype G] : monoid.is_torsion G :=\n\n/-- Direct products of torsion free groups are torsion free. -/\ntheorem {Œ∑ : Type u_1} {Gs : Œ∑ ‚Üí Type u_2} [Œ† (i : Œ∑), group (Gs i)] (tfGs : ‚àÄ (i : Œ∑), monoid.is_torsion_free (Gs i)) : monoid.is_torsion_free (Œ† (i : Œ∑), Gs i) :=\n\n/-- A group homomorphism is injective iff its kernel is trivial. -/\ntheorem {Œ± : Type u} {Œ≤ : Type v} [group Œ±] [group Œ≤] {f : Œ± ‚Üí Œ≤} (hf : is_group_hom f) : function.injective f ‚Üî ‚àÄ (a : Œ±), f a = 1 ‚Üí a = 1 :=\n\n/-- A semisimple Abelian Lie algebra is trivial. -/\ntheorem (R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] [lie_algebra.is_semisimple R L] [h : is_lie_abelian L] : subsingleton L :=\n\n/--  Note that the inequality can be strict; e.g., the inclusion of an Abelian subalgebra of a simple algebra. -/\ntheorem {R : Type u} {L : Type v} {L' : Type w‚ÇÇ} [comm_ring R] [lie_ring L] [lie_algebra R L] [lie_ring L'] [lie_algebra R L'] (f : L ‚Üí‚Çó‚ÅÖR‚ÅÜ L') {I‚ÇÅ I‚ÇÇ : lie_ideal R L} : lie_ideal.map f ‚ÅÖI‚ÇÅ,I‚ÇÇ‚ÅÜ ‚â§ ‚ÅÖlie_ideal.map f I‚ÇÅ,lie_ideal.map f I‚ÇÇ‚ÅÜ :=\n\n/-- Abelian groups have nilpotency class at most one -/\ntheorem {G : Type u_1} [comm_group G] : group.nilpotency_class G ‚â§ 1 :=\n\n/--  If an order automorphism `fa` is semiconjugate to an order embedding `fb` by a function `g` and `g'` is an order right adjoint of `g` (i.e. `g' y = Sup {x | f x ‚â§ y}`), then `fb` is semiconjugate to `fa` by `g'`.  This is a version of Proposition 2.1 from [√âtienne Ghys, Groupes d'homeomorphismes du cercle et cohomologie bornee][ghys87:groupes]. -/\ntheorem {Œ± : Type u_1} {Œ≤ : Type u_2} [partial_order Œ±] [preorder Œ≤] {fa : Œ± ‚âÉo Œ±} {fb : Œ≤ ‚Ü™o Œ≤} {g : Œ± ‚Üí Œ≤} (h : function.semiconj g ‚áëfa ‚áëfb) {g' : Œ≤ ‚Üí Œ±} (hg' : is_order_right_adjoint g g') : function.semiconj g' ‚áëfb ‚áëfa :=\n\n/-- The automorphism group of an Abelian group is cyclic. -/\ntheorem "}
{"text": "If a function from the unit interval to itself has a fixed point, then it has points of all positive periods.", "fullPrompt": "/-- A fixed point of `f` is a periodic point of `f` of any prescribed period. -/\ntheorem {Œ± : Type u_1} {f : Œ± ‚Üí Œ±} {x : Œ±} (hf : function.is_fixed_pt f x) (n : ‚Ñï) : function.is_periodic_pt f n x :=\n\n/-- Any point is a periodic point of period `0`. -/\ntheorem {Œ± : Type u_1} (f : Œ± ‚Üí Œ±) (x : Œ±) : function.is_periodic_pt f 0 x :=\n\n/-- If `x` is a fixed point of `f ‚àò g` and `g`, then it is a fixed point of `f`. -/\ntheorem {Œ± : Type u} {f g : Œ± ‚Üí Œ±} {x : Œ±} (hfg : function.is_fixed_pt (f ‚àò g) x) (hg : function.is_fixed_pt g x) : function.is_fixed_pt f x :=\n\n/-- Every point is a fixed point of `id`. -/\ntheorem {Œ± : Type u} (x : Œ±) : function.is_fixed_pt id x :=\n\n/-- If `x` is a fixed point of `f` and `g`, then it is a fixed point of `f ‚àò g`. -/\ntheorem {Œ± : Type u} {f g : Œ± ‚Üí Œ±} {x : Œ±} (hf : function.is_fixed_pt f x) (hg : function.is_fixed_pt g x) : function.is_fixed_pt (f ‚àò g) x :=\n\n/-- If `x` is a fixed point of `f`, then `f x = x`. This is useful, e.g., for `rw` or `simp`. -/\ntheorem {Œ± : Type u} {f : Œ± ‚Üí Œ±} {x : Œ±} (hf : function.is_fixed_pt f x) : f x = x :=\n\n/-- If a function is `antiperiodic` with antiperiod `c`, then it is also `periodic` with period  `2 * c`. -/\ntheorem {Œ± : Type u_1} {Œ≤ : Type u_2} {f : Œ± ‚Üí Œ≤} {c : Œ±} [semiring Œ±] [add_group Œ≤] (h : function.antiperiodic f c) : function.periodic f (2 * c) :=\n\n/-- For the identity map, all points are periodic. -/\ntheorem {Œ± : Type u_1} (n : ‚Ñï) (x : Œ±) : function.is_periodic_pt id n x :=\n\n/--  The fixed point lemma for normal functions: any normal function has an unbounded set of fixed points. -/\ntheorem {f : ordinal ‚Üí ordinal} (H : ordinal.is_normal f) : set.unbounded has_lt.lt (function.fixed_points f) :=\n\n/--  An interval of length `a` filtered over a periodic predicate of period `a` has cardinality equal to the number naturals below `a` for which `p a` is true. -/\ntheorem (n a : ‚Ñï) (p : ‚Ñï ‚Üí Prop) [decidable_pred p] (pp : function.periodic p a) : ‚áëmultiset.card (multiset.filter p (multiset.Ico n (n + a))) = nat.count p a :=\n\n/--  If self-maps `f` and `g` commute, then `g` is bijective on the set of fixed points of `f ‚àò g`. This is a particular case of `function.bij_on_fixed_pts_comp`. -/\ntheorem {Œ± : Type u} {f g : Œ± ‚Üí Œ±} (h : function.commute f g) : set.bij_on g (function.fixed_points (f ‚àò g)) (function.fixed_points (f ‚àò g)) :=\n\n/--  If self-maps `f` and `g` commute, then `f` is bijective on the set of fixed points of `f ‚àò g`. This is a particular case of `function.bij_on_fixed_pts_comp`. -/\ntheorem {Œ± : Type u} {f g : Œ± ‚Üí Œ±} (h : function.commute f g) : set.bij_on f (function.fixed_points (f ‚àò g)) (function.fixed_points (f ‚àò g)) :=\n\n/--  If `f` sends two periodic points `x` and `y` of positive periods to the same point, then `x = y`. -/\ntheorem {Œ± : Type u_1} {f : Œ± ‚Üí Œ±} {x y : Œ±} {m n : ‚Ñï} (hx : function.is_periodic_pt f m x) (hy : function.is_periodic_pt f n y) (hm : 0 < m) (hn : 0 < n) (h : f x = f y) : x = y :=\n\n/--  If `f` sends two periodic points `x` and `y` of the same positive period to the same point, then `x = y`. For a similar statement about points of different periods see `eq_of_apply_eq`. -/\ntheorem {Œ± : Type u_1} {f : Œ± ‚Üí Œ±} {x y : Œ±} {n : ‚Ñï} (hx : function.is_periodic_pt f n x) (hy : function.is_periodic_pt f n y) (hn : 0 < n) (h : f x = f y) : x = y :=\n\n/-- If a function from the unit interval to itself has a fixed point, then it has points of all positive periods. -/\ntheorem "}
{"text": "The complement of the union of two sets contains the union of their complements.", "fullPrompt": "/-- The union of two sets is bounded iff each of the sets is bounded. -/\ntheorem {Œ± : Type u} [pseudo_metric_space Œ±] {s t : set Œ±} : metric.bounded (s ‚à™ t) ‚Üî metric.bounded s ‚àß metric.bounded t :=\n\n/-- The union of two sets is bounded above if and only if each of the sets is. -/\ntheorem {Œ≥ : Type w} [semilattice_inf Œ≥] {s t : set Œ≥} : bdd_below (s ‚à™ t) ‚Üî bdd_below s ‚àß bdd_below t :=\n\n/-- The union of two sets is bounded above if and only if each of the sets is. -/\ntheorem {Œ≥ : Type w} [semilattice_sup Œ≥] {s t : set Œ≥} : bdd_above (s ‚à™ t) ‚Üî bdd_above s ‚àß bdd_above t :=\n\n/-- The union of two bounded sets is bounded. -/\ntheorem {Œ± : Type u} [pseudo_metric_space Œ±] {s t : set Œ±} (hs : metric.bounded s) (ht : metric.bounded t) : metric.bounded (s ‚à™ t) :=\n\n/-- The union of two GŒ¥ sets is a GŒ¥ set. -/\ntheorem {Œ± : Type u_1} [topological_space Œ±] {s t : set Œ±} (hs : is_GŒ¥ s) (ht : is_GŒ¥ t) : is_GŒ¥ (s ‚à™ t) :=\n\n/-- Subsets of a bounded set are also bounded -/\ntheorem {Œ± : Type u} [pseudo_metric_space Œ±] {s t : set Œ±} (incl : s ‚äÜ t) : metric.bounded t ‚Üí metric.bounded s :=\n\n/-- The intersection of a compact set and a closed set is a compact set. -/\ntheorem {Œ± : Type u} [topological_space Œ±] {s t : set Œ±} (hs : is_compact s) (ht : is_closed t) : is_compact (s ‚à© t) :=\n\n/-- The intersection of a closed set and a compact set is a compact set. -/\ntheorem {Œ± : Type u} [topological_space Œ±] {s t : set Œ±} (ht : is_compact t) (hs : is_closed s) : is_compact (s ‚à© t) :=\n\n/-- If the elements of a set are independent, then any pair within that set is disjoint. -/\ntheorem {Œ± : Type u_1} {Œπ : Type u_3} [complete_lattice Œ±] {t : Œπ ‚Üí Œ±} (ht : complete_lattice.independent t) : pairwise (disjoint on t) :=\n\n/-- The substructure generated by a set includes the set. -/\ntheorem {L : first_order.language} {M : Type w} [L.Structure M] {s : set M} : s ‚äÜ ‚Üë(‚áë(first_order.language.substructure.closure L) s) :=\n\n/-- A closed subset of a compact set is a compact set. -/\ntheorem {Œ± : Type u} [topological_space Œ±] {s t : set Œ±} (hs : is_compact s) (ht : is_closed t) (h : t ‚äÜ s) : is_compact t :=\n\n/-- If `s` is bounded, then so is `s ‚à© t` -/\ntheorem {Œ± : Type u} [preorder Œ±] {s t : set Œ±} (h : bdd_above s) : bdd_above (s ‚à© t) :=\n\n/-- The complement of the union of two sets contains the union of their complements. -/\ntheorem "}
{"text": "The square root of an rational number is rational.", "fullPrompt": "/-- The conjugate of the golden ratio is irrational. -/\ntheorem  : irrational golden_conj :=\n\n/-- The golden ratio is irrational. -/\ntheorem  : irrational golden_ratio :=\n\n/-- Note that most of the lemmas about powers of two refer to it as `sq`. -/\ntheorem {M : Type u} [monoid M] (a : M) : a ^ 2 = a * a :=\n\n/-- **Alias** of the reverse direction of is_square_iff_exists_sq`. -/\ntheorem {Œ± : Type u_2} [monoid Œ±] (m : Œ±) : (‚àÉ (c : Œ±), m = c ^ 2) ‚Üí is_square m :=\n\n/-- Natural division is always less than division in the field. -/\ntheorem {Œ± : Type u_1} [linear_ordered_field Œ±] {m n : ‚Ñï} : ‚Üë(m / n) ‚â§ ‚Üëm / ‚Üën :=\n\n/-- **Alias** of the forward direction of is_square_iff_exists_sq`. -/\ntheorem {Œ± : Type u_2} [monoid Œ±] (m : Œ±) : is_square m ‚Üí (‚àÉ (c : Œ±), m = c ^ 2) :=\n\n/-- The zeroth Pythagorean triple is all zeros. -/\ntheorem  : pythagorean_triple 0 0 0 :=\n\n/-- The sum of two squares is zero iff both elements are zero. -/\ntheorem {Œ± : Type u} [linear_ordered_ring Œ±] {x y : Œ±} : x * x + y * y = 0 ‚Üî x = 0 ‚àß y = 0 :=\n\n/-- The square of the quadratic character on nonzero arguments is `1`. -/\ntheorem {F : Type u_1} [field F] [fintype F] [decidable_eq F] {a : F} (ha : a ‚â† 0) : char.quadratic_char F a ^ 2 = 1 :=\n\n/-- If `p` and `q` are irreducible, then `p ‚à£ q` implies `q ‚à£ p`. -/\ntheorem {Œ± : Type u_1} [monoid Œ±] {p q : Œ±} (hp : irreducible p) (hq : irreducible q) : p ‚à£ q ‚Üí q ‚à£ p :=\n\n/-- A non-zero `a : F` is a square if and only if `a ^ (#F / 2) = 1`. -/\ntheorem {F : Type u_3} [field F] [fintype F] (hF : ring_char F ‚â† 2) {a : F} (ha : a ‚â† 0) : is_square a ‚Üî a ^ (fintype.card F / 2) = 1 :=\n\n/-- In a finite field of odd characteristic, not every element is a square. -/\ntheorem {F : Type u_3} [field F] [fintype F] (hF : ring_char F ‚â† 2) : ‚àÉ (a : F), ¬¨is_square a :=\n\n/-- The real square root is at most the natural square root plus one -/\ntheorem {a : ‚Ñï} : real.sqrt ‚Üëa ‚â§ ‚Üë(nat.sqrt a) + 1 :=\n\n/-- The natural square root is at most the real square root -/\ntheorem {a : ‚Ñï} : ‚Üë(nat.sqrt a) ‚â§ real.sqrt ‚Üëa :=\n\n/-- A quadratic has no root if its discriminant has no square root. -/\ntheorem {R : Type u_1} [comm_ring R] [is_domain R] {a b c : R} (h2 : 2 ‚â† 0) (ha : a ‚â† 0) (h : ‚àÄ (s : R), discrim a b c ‚â† s * s) (x : R) : a * x * x + b * x + c ‚â† 0 :=\n\n/-- The product of a Liouville number and a nonzero rational number is again a Liouville number. -/\ntheorem {p x : ‚Ñù} {r : ‚Ñö} (h : liouville_with p x) (hr : r ‚â† 0) : liouville_with p (x * ‚Üër) :=\n\n/-- Every terminating continued fraction corresponds to a rational number. -/\ntheorem {K : Type u_1} [linear_ordered_field K] [floor_ring K] {v : K} (terminates : (generalized_continued_fraction.of v).terminates) : ‚àÉ (q : ‚Ñö), v = ‚Üëq :=\n\n/-- Every finite convergent corresponds to a rational number. -/\ntheorem {K : Type u_1} [linear_ordered_field K] [floor_ring K] (v : K) (n : ‚Ñï) : ‚àÉ (q : ‚Ñö), (generalized_continued_fraction.of v).convergents n = ‚Üëq :=\n\n/-- The continued fraction of a rational number terminates. -/\ntheorem (q : ‚Ñö) : (generalized_continued_fraction.of q).terminates :=\n\n/-- The p-adic value of an integer `z ‚â† 0` is its p-adic_value as a rational -/\ntheorem {p n : ‚Ñï} : padic_val_rat p ‚Üën = ‚Üë(padic_val_nat p n) :=\n\n/-- The p-adic value of an integer `z ‚â† 0` is its p-adic_value as a rational -/\ntheorem {p : ‚Ñï} {z : ‚Ñ§} : padic_val_rat p ‚Üëz = ‚Üë(padic_val_int p z) :=\n\n/--  If `E` is a vector space over two division rings `R` and `S`, then scalar multiplications agree on rational numbers in `R` and `S`. -/\ntheorem {E : Type u_1} (R : Type u_2) (S : Type u_3) [add_comm_group E] [division_ring R] [division_ring S] [module R E] [module S E] (r : ‚Ñö) (x : E) : ‚Üër ‚Ä¢ x = ‚Üër ‚Ä¢ x :=\n\n/-- The square root of an rational number is rational. -/\ntheorem "}
{"text": "If a module over a ring is free, then the ring is commutative.", "fullPrompt": "/-- A free module with a basis indexed by a `fintype` is finite. -/\ntheorem {R : Type u_1} {M : Type u_2} {Œπ : Type u_3} [comm_ring R] [add_comm_group M] [module R M] [fintype Œπ] (b : basis Œπ R M) : module.finite R M :=\n\n/-- The rank of a free module `M` over `R` is the cardinality of `choose_basis_index R M`. -/\ntheorem (R : Type u) (M : Type v) [ring R] [strong_rank_condition R] [add_comm_group M] [module R M] [module.free R M] : module.rank R M = cardinal.mk (module.free.choose_basis_index R M) :=\n\n/-- A module over a division ring is noetherian if and only if it is finitely generated. -/\ntheorem {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] : is_noetherian K V ‚Üî module.finite K V :=\n\n/-- A module has dimension 1 iff there is some `v : V` so `{v}` is a basis. -/\ntheorem {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] (Œπ : Type u_1) [unique Œπ] : finite_dimensional.finrank K V = 1 ‚Üî nonempty (basis Œπ K V) :=\n\n/-- Hilbert basis theorem: a polynomial ring over a noetherian ring is a noetherian ring. -/\ntheorem {R : Type u} [comm_ring R] [is_noetherian_ring R] : is_noetherian_ring (polynomial R) :=\n\n/-- If an element a divides another element b in a commutative ring, a divides the sum of b and  another element c iff a divides c. -/\ntheorem {Œ± : Type u} [non_unital_ring Œ±] {a b c : Œ±} (h : a ‚à£ b) : a ‚à£ b + c ‚Üî a ‚à£ c :=\n\n/--  If two words have a common maximal reduction, then they correspond to the same element in the free group. -/\ntheorem {Œ± : Type u} {L‚ÇÅ L‚ÇÇ : list (Œ± √ó bool)} [decidable_eq Œ±] (H : free_group.reduce L‚ÇÅ = free_group.reduce L‚ÇÇ) : free_group.mk L‚ÇÅ = free_group.mk L‚ÇÇ :=\n\n/-- The identity map is a ring homomorphism. -/\ntheorem {Œ± : Type u} [ring Œ±] : is_ring_hom id :=\n\n/-- Left multiplication in a ring is an additive monoid morphism. -/\ntheorem {Œ≥ : Type u_1} [non_unital_non_assoc_semiring Œ≥] (x : Œ≥) : is_add_monoid_hom (Œª (y : Œ≥), x * y) :=\n\n/-- Ring homomorphisms map zero to zero. -/\ntheorem {Œ± : Type u} {Œ≤ : Type v} [ring Œ±] [ring Œ≤] {f : Œ± ‚Üí Œ≤} (hf : is_ring_hom f) : f 0 = 0 :=\n\n/-- A division_ring is one-dimensional as a vector space over itself. -/\ntheorem (K : Type u) [division_ring K] : finite_dimensional.finrank K K = 1 :=\n\n/-- Right multiplication in a ring is an additive monoid morphism. -/\ntheorem {Œ≥ : Type u_1} [non_unital_non_assoc_semiring Œ≥] (x : Œ≥) : is_add_monoid_hom (Œª (y : Œ≥), y * x) :=\n\n/-- If a module over a ring is free, then the ring is commutative. -/\ntheorem "}
{"text": "If the set of units of a ring forms a group then the ring is commutative.", "fullPrompt": "/--  A prime that does not divide the cardinality of a finite commutative ring `R` is a unit in `R`. -/\ntheorem {R : Type u_1} [comm_ring R] [fintype R] (p : ‚Ñï) [fact (nat.prime p)] (hp : p ‚à£ fintype.card R) : ¬¨is_unit ‚Üëp :=\n\n/-- An element of a ring multiplied by the additive inverse of one is the element's additive  inverse. -/\ntheorem {Œ± : Type u} [mul_one_class Œ±] [has_distrib_neg Œ±] (a : Œ±) : a * -1 = -a :=\n\n/--  A prime `p` is a unit in a finite commutative ring `R` iff it does not divide the characteristic. -/\ntheorem (R : Type u_1) [comm_ring R] [fintype R] (p : ‚Ñï) [fact (nat.prime p)] : is_unit ‚Üëp ‚Üî ¬¨p ‚à£ ring_char R :=\n\n/-- Commuting elements of finite order are closed under multiplication. -/\ntheorem {G : Type u} {y : G} [monoid G] {x : G} (h : commute x y) (hx : is_of_fin_order x) (hy : is_of_fin_order y) : is_of_fin_order (x * y) :=\n\n/-- The additive inverse of one multiplied by an element of a ring is the element's additive  inverse. -/\ntheorem {Œ± : Type u} [mul_one_class Œ±] [has_distrib_neg Œ±] (a : Œ±) : (-1) * a = -a :=\n\n/-- Units of a monoid divide any element of the monoid. -/\ntheorem {Œ± : Type u_1} [monoid Œ±] {a u : Œ±} (hu : is_unit u) : u ‚à£ a :=\n\n/-- Left multiplication in a ring is an additive monoid morphism. -/\ntheorem {Œ≥ : Type u_1} [non_unital_non_assoc_semiring Œ≥] (x : Œ≥) : is_add_monoid_hom (Œª (y : Œ≥), x * y) :=\n\n/-- Right multiplication in a ring is an additive monoid morphism. -/\ntheorem {Œ≥ : Type u_1} [non_unital_non_assoc_semiring Œ≥] (x : Œ≥) : is_add_monoid_hom (Œª (y : Œ≥), y * x) :=\n\n/-- If an element a divides another element b in a commutative ring, a divides the sum of b and  another element c iff a divides c. -/\ntheorem {Œ± : Type u} [non_unital_ring Œ±] {a b c : Œ±} (h : a ‚à£ b) : a ‚à£ b + c ‚Üî a ‚à£ c :=\n\n/-- Elements of finite order are closed under multiplication. -/\ntheorem {G : Type u} {x y : G} [comm_monoid G] (hx : is_of_fin_order x) (hy : is_of_fin_order y) : is_of_fin_order (x * y) :=\n\n/-- A map to a group preserving multiplication is a monoid homomorphism. -/\ntheorem {Œ± : Type u} {Œ≤ : Type v} [mul_one_class Œ±] [group Œ≤] {f : Œ± ‚Üí Œ≤} (hf : is_mul_hom f) : is_monoid_hom f :=\n\n/-- The inverse of a group homomorphism is a group homomorphism if the target is commutative. -/\ntheorem {Œ± : Type u_1} {Œ≤ : Type u_2} [group Œ±] [comm_group Œ≤] {f : Œ± ‚Üí Œ≤} (hf : is_group_hom f) : is_group_hom (Œª (a : Œ±), (f a)‚Åª¬π) :=\n\n/-- When lowered to a prop, `matrix.diagonal_invertible_equiv_invertible` forms an `iff`. -/\ntheorem {n : Type u'} {Œ± : Type v} [fintype n] [decidable_eq n] [comm_ring Œ±] {v : n ‚Üí Œ±} : is_unit (matrix.diagonal v) ‚Üî is_unit v :=\n\n/-- When lowered to a prop, `matrix.invertible_equiv_det_invertible` forms an `iff`. -/\ntheorem {n : Type u'} {Œ± : Type v} [fintype n] [decidable_eq n] [comm_ring Œ±] (A : matrix n n Œ±) : is_unit A ‚Üî is_unit A.det :=\n\n/--  *Engel's theorem*.  Note that this implies all traditional forms of Engel's theorem via `lie_module.nontrivial_max_triv_of_is_nilpotent`, `lie_module.is_nilpotent_iff_forall`, `lie_algebra.is_nilpotent_iff_forall`. -/\ntheorem {R : Type u‚ÇÅ} {L : Type u‚ÇÇ} [comm_ring R] [lie_ring L] [lie_algebra R L] [is_noetherian R L] : lie_algebra.is_engelian R L :=\n\n/--  The map `B.polar : set E ‚Üí set F` forms an order-reversing Galois connection with `B.flip.polar : set F ‚Üí set E`. We use `order_dual.to_dual` and `order_dual.of_dual` to express that `polar` is order-reversing. -/\ntheorem {ùïú : Type u_1} {E : Type u_2} {F : Type u_3} [normed_comm_ring ùïú] [add_comm_monoid E] [add_comm_monoid F] [module ùïú E] [module ùïú F] (B : E ‚Üí‚Çó[ùïú] F ‚Üí‚Çó[ùïú] ùïú) : galois_connection (‚áëorder_dual.to_dual ‚àò B.polar) (B.flip.polar ‚àò ‚áëorder_dual.of_dual) :=\n\n/--  If a family of submodules is `independent`, then a choice of nonzero vector from each submodule forms a linearly independent family. -/\ntheorem {Œπ : Type u_1} {R : Type u_2} {N : Type u_5} [ring R] [add_comm_group N] [module R N] [no_zero_smul_divisors R N] (p : Œπ ‚Üí submodule R N) (hp : complete_lattice.independent p) {v : Œπ ‚Üí N} (hv : ‚àÄ (i : Œπ), v i ‚àà p i) (hv' : ‚àÄ (i : Œπ), v i ‚â† 0) : linear_independent R v :=\n\n/-- If the set of units of a ring forms a group then the ring is commutative. -/\ntheorem "}
{"text": "Every natural number larger than `10` is the sum of a square and a prime.", "fullPrompt": "/--  **Fermat's theorem on the sum of two squares**. Every prime congruent to 1 mod 4 is the sum of two squares. Also known as **Fermat's Christmas theorem**. -/\ntheorem {p : ‚Ñï} [fact (nat.prime p)] (hp : p % 4 = 1) : ‚àÉ (a b : ‚Ñï), a ^ 2 + b ^ 2 = p :=\n\n/-- There are no perfect squares strictly between m¬≤ and (m+1)¬≤ -/\ntheorem {n m : ‚Ñï} (hl : m * m < n) (hr : n < (m + 1) * (m + 1)) : ¬¨‚àÉ (t : ‚Ñï), t * t = n :=\n\n/-- The sum of two squares is zero iff both elements are zero. -/\ntheorem {Œ± : Type u} [linear_ordered_ring Œ±] {x y : Œ±} : x * x + y * y = 0 ‚Üî x = 0 ‚àß y = 0 :=\n\n/--  Euclid's theorem on the **infinitude of primes**. Here given in the form: for every `n`, there exists a prime number `p ‚â• n`. -/\ntheorem (n : ‚Ñï) : ‚àÉ (p : ‚Ñï), n ‚â§ p ‚àß nat.prime p :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem  : set.inj_on nat.factorization {x : ‚Ñï | x ‚â† 0} :=\n\n/-- The only numbers with empty prime factorization are `0` and `1` -/\ntheorem (n : ‚Ñï) : n.factorization = 0 ‚Üî n = 0 ‚à® n = 1 :=\n\n/-- For any natural numbers n, a, and b, one of the following holds: 1. n < a 2. n ‚â• b 3. n ‚àà Ico a b -/\ntheorem (n a b : ‚Ñï) : n < a ‚à® b ‚â§ n ‚à® n ‚àà list.Ico a b :=\n\n/-- Two natural numbers are equal if and only if the have the same multiples. -/\ntheorem {m n : ‚Ñï} : (‚àÄ (a : ‚Ñï), m ‚à£ a ‚Üî n ‚à£ a) ‚Üî m = n :=\n\n/-- A natural number `m` divides the sum `m + n` if and only if `m` divides `n`. -/\ntheorem {m n : ‚Ñï} : m ‚à£ m + n ‚Üî m ‚à£ n :=\n\n/-- A natural number `m` divides the sum `n + m` if and only if `m` divides `n`. -/\ntheorem {m n : ‚Ñï} : m ‚à£ n + m ‚Üî m ‚à£ n :=\n\n/-- Two natural numbers are equal if and only if the have the same divisors. -/\ntheorem {m n : ‚Ñï} : (‚àÄ (a : ‚Ñï), a ‚à£ m ‚Üî a ‚à£ n) ‚Üî m = n :=\n\n/-- A prime `p` satisfies `p % 2 = 1` if and only if `p ‚â† 2`. -/\ntheorem {p : ‚Ñï} [fact (nat.prime p)] : p % 2 = 1 ‚Üî p ‚â† 2 :=\n\n/-- Every natural number larger than `10` is the sum of a square and a prime. -/\ntheorem "}
{"text": "The initial object of a category is isomorphic to its terminal object.", "fullPrompt": "/-- If there are zero morphisms, any terminal object is a zero object. -/\ntheorem {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_terminal C] : category_theory.limits.has_zero_object C :=\n\n/--  To show a category is a `initial_mono_class` it suffices to show every morphism out of the initial object is a monomorphism. -/\ntheorem {C : Type u‚ÇÅ} [category_theory.category C] [category_theory.limits.has_initial C] (h : ‚àÄ (X : C), category_theory.mono (category_theory.limits.initial.to X)) : category_theory.limits.initial_mono_class C :=\n\n/-- If the unique morphism from `A` to a terminal object is a monomorphism, `A` is subterminal. The converse of `is_subterminal.mono_is_terminal_from`. -/\ntheorem {C : Type u‚ÇÅ} [category_theory.category C] {A T : C} (hT : category_theory.limits.is_terminal T) [category_theory.mono (hT.from A)] : category_theory.is_subterminal A :=\n\n/-- If `A` is subterminal, the unique morphism from it to a terminal object is a monomorphism. The converse of `is_subterminal_of_mono_is_terminal_from`. -/\ntheorem {C : Type u‚ÇÅ} [category_theory.category C] {A : C} (hA : category_theory.is_subterminal A) {T : C} (hT : category_theory.limits.is_terminal T) : category_theory.mono (hT.from A) :=\n\n/-- Any simple object in a preadditive category is indecomposable. -/\ntheorem {C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_binary_biproducts C] (X : C) [category_theory.simple X] : category_theory.indecomposable X :=\n\n/-- If a preadditive category has all cokernels, then it also has all coequalizers. -/\ntheorem {C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_cokernels C] : category_theory.limits.has_coequalizers C :=\n\n/-- If `A` is subterminal, the unique morphism from it to the terminal object is a monomorphism. The converse of `is_subterminal_of_mono_terminal_from`. -/\ntheorem {C : Type u‚ÇÅ} [category_theory.category C] {A : C} [category_theory.limits.has_terminal C] (hA : category_theory.is_subterminal A) : category_theory.mono (category_theory.limits.terminal.from A) :=\n\n/-- If the unique morphism from `A` to the terminal object is a monomorphism, `A` is subterminal. The converse of `is_subterminal.mono_terminal_from`. -/\ntheorem {C : Type u‚ÇÅ} [category_theory.category C] {A : C} [category_theory.limits.has_terminal C] [category_theory.mono (category_theory.limits.terminal.from A)] : category_theory.is_subterminal A :=\n\n/-- If a preadditive category has all kernels, then it also has all equalizers. -/\ntheorem {C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_kernels C] : category_theory.limits.has_equalizers C :=\n\n/-- If there are zero morphisms, any initial object is a zero object. -/\ntheorem {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_initial C] : category_theory.limits.has_zero_object C :=\n\n/-- Construct terminal object in the over category. This isn't an instance as it's not typically the way we want to define terminal objects. (For instance, this gives a terminal object which is different from the generic one given by `over_product_of_wide_pullback` above.) -/\ntheorem {C : Type u} [category_theory.category C] (B : C) : category_theory.limits.has_terminal (category_theory.over B) :=\n\n/-- In a preadditive category, if the coproduct over `f : J ‚Üí C` exists,    then the biproduct over `f` exists. -/\ntheorem {C : Type u} [category_theory.category C] [category_theory.preadditive C] {J : Type v} [fintype J] (f : J ‚Üí C) [category_theory.limits.has_coproduct f] : category_theory.limits.has_biproduct f :=\n\n/-- If `C` has an initial object and binary coproducts, then it has finite coproducts. -/\ntheorem {C : Type u} [category_theory.category C] [category_theory.limits.has_binary_coproducts C] [category_theory.limits.has_initial C] : category_theory.limits.has_finite_coproducts C :=\n\n/-- If `C` has a terminal object and binary products, then it has finite products. -/\ntheorem {C : Type u} [category_theory.category C] [category_theory.limits.has_binary_products C] [category_theory.limits.has_terminal C] : category_theory.limits.has_finite_products C :=\n\n/--  If `c` is a colimiting binary coproduct cocone, and we have an initial object, then we have `is_pushout 0 0 c.inl c.inr` (where each `0` is the unique morphism from the initial object). -/\ntheorem {C : Type u‚ÇÅ} [category_theory.category C] {Z X Y : C} {c : category_theory.limits.binary_cofan X Y} (h : category_theory.limits.is_colimit c) (t : category_theory.limits.is_initial Z) : category_theory.is_pushout (t.to ((category_theory.limits.pair X Y).obj {as := category_theory.limits.walking_pair.left})) (t.to ((category_theory.limits.pair X Y).obj {as := category_theory.limits.walking_pair.right})) c.inl c.inr :=\n\n/-- If `C` has a initial object and `G` preserves initial objects, then `D` has a initial object also. Note this property is somewhat unique to colimits of the empty diagram: for general `J`, if `C` has colimits of shape `J` and `G` preserves them, then `D` does not necessarily have colimits of shape `J`. -/\ntheorem {C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (G : C ‚•§ D) [category_theory.limits.has_initial C] [category_theory.limits.preserves_colimit (category_theory.functor.empty C) G] : category_theory.limits.has_initial D :=\n\n/--  To show a category is a `initial_mono_class` it suffices to show the unique morphism from the initial object to a terminal object is a monomorphism. -/\ntheorem {C : Type u‚ÇÅ} [category_theory.category C] [category_theory.limits.has_initial C] [category_theory.limits.has_terminal C] (h : category_theory.mono (category_theory.limits.initial.to (‚ä§_ C))) : category_theory.limits.initial_mono_class C :=\n\n/--  If `c` is a limiting binary product cone, and we have a terminal object, then we have `is_pullback c.fst c.snd 0 0` (where each `0` is the unique morphism to the terminal object). -/\ntheorem {C : Type u‚ÇÅ} [category_theory.category C] {X Y Z : C} {c : category_theory.limits.binary_fan X Y} (h : category_theory.limits.is_limit c) (t : category_theory.limits.is_terminal Z) : category_theory.is_pullback c.fst c.snd (t.from ((category_theory.limits.pair X Y).obj {as := category_theory.limits.walking_pair.left})) (t.from ((category_theory.limits.pair X Y).obj {as := category_theory.limits.walking_pair.right})) :=\n\n/-- If `C` has a terminal object and `G` preserves terminal objects, then `D` has a terminal object also. Note this property is somewhat unique to (co)limits of the empty diagram: for general `J`, if `C` has limits of shape `J` and `G` preserves them, then `D` does not necessarily have limits of shape `J`. -/\ntheorem {C : Type u‚ÇÅ} [category_theory.category C] {D : Type u‚ÇÇ} [category_theory.category D] (G : C ‚•§ D) [category_theory.limits.has_terminal C] [category_theory.limits.preserves_limit (category_theory.functor.empty C) G] : category_theory.limits.has_terminal D :=\n\n/--  If all but one object in a diagram is strict terminal, the the limit is isomorphic to the said object via `limit.œÄ`. -/\ntheorem {C : Type u} [category_theory.category C] [category_theory.limits.has_strict_terminal_objects C] {J : Type v} [category_theory.small_category J] (F : J ‚•§ C) [category_theory.limits.has_limit F] (i : J) (H : Œ† (j : J), j ‚â† i ‚Üí category_theory.limits.is_terminal (F.obj j)) [subsingleton (i ‚ü∂ i)] : category_theory.is_iso (category_theory.limits.limit.œÄ F i) :=\n\n/-- The initial object of a category is isomorphic to its terminal object. -/\ntheorem "}
{"text": "If the composition of two functions is continuous, then each of them is continuous.", "fullPrompt": "/-- If `x` is a fixed point of `f` and `g`, then it is a fixed point of `f ‚àò g`. -/\ntheorem {Œ± : Type u} {f g : Œ± ‚Üí Œ±} {x : Œ±} (hf : function.is_fixed_pt f x) (hg : function.is_fixed_pt g x) : function.is_fixed_pt (f ‚àò g) x :=\n\n/-- Composition by an surjective function on the left is itself surjective. -/\ntheorem {Œ± : Sort u} {Œ≤ : Sort v} {Œ≥ : Sort w} {g : Œ≤ ‚Üí Œ≥} (hg : function.surjective g) : function.surjective (function.comp g) :=\n\n/-- If `x` is a fixed point of `f ‚àò g` and `g`, then it is a fixed point of `f`. -/\ntheorem {Œ± : Type u} {f g : Œ± ‚Üí Œ±} {x : Œ±} (hfg : function.is_fixed_pt (f ‚àò g) x) (hg : function.is_fixed_pt g x) : function.is_fixed_pt f x :=\n\n/-- Composition by an injective function on the left is itself injective. -/\ntheorem {Œ± : Sort u_1} {Œ≤ : Sort u_2} {Œ≥ : Sort u_3} {g : Œ≤ ‚Üí Œ≥} (hg : function.injective g) : function.injective (function.comp g) :=\n\n/-- Composition by an bijective function on the left is itself bijective. -/\ntheorem {Œ± : Sort u} {Œ≤ : Sort v} {Œ≥ : Sort w} {g : Œ≤ ‚Üí Œ≥} (hg : function.bijective g) : function.bijective (function.comp g) :=\n\n/-- The inclusion of a fiber into the total space is a continuous map. -/\ntheorem {Œπ : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core Œπ B F) (b : B) : continuous (bundle.total_space_mk b) :=\n\n/-- In a sequential space, continuity and sequential continuity coincide. -/\ntheorem {X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] {f : X ‚Üí Y} [sequential_space X] : continuous f ‚Üî seq_continuous f :=\n\n/--  If a composition of a function `f` followed by an injection `g` is locally constant, then the locally constant property descends to `f`. -/\ntheorem {X : Type u_1} [topological_space X] {Œ± : Type u_2} {Œ≤ : Type u_3} (f : X ‚Üí Œ±) (g : Œ± ‚Üí Œ≤) (h : is_locally_constant (g ‚àò f)) (inj : function.injective g) : is_locally_constant f :=\n\n/-- Any map `f` sends fixed points of `g ‚àò f` to fixed points of `f ‚àò g`. -/\ntheorem {Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Œ≤) (g : Œ≤ ‚Üí Œ±) : set.maps_to f (function.fixed_points (g ‚àò f)) (function.fixed_points (f ‚àò g)) :=\n\n/-- Conjugation is jointly continuous on `G √ó G` when both `mul` and `inv` are continuous. -/\ntheorem {G : Type w} [topological_space G] [has_inv G] [has_mul G] [has_continuous_mul G] [has_continuous_inv G] : continuous (Œª (g : G √ó G), g.fst * g.snd * (g.fst)‚Åª¬π) :=\n\n/-- Conjugation is jointly continuous on `G √ó G` when both `mul` and `inv` are continuous. -/\ntheorem {G : Type w} [topological_space G] [has_neg G] [has_add G] [has_continuous_add G] [has_continuous_neg G] : continuous (Œª (g : G √ó G), g.fst + g.snd + -g.fst) :=\n\n/-- The currying process is a continuous map between function spaces. -/\ntheorem {Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [topological_space Œ±] [topological_space Œ≤] [topological_space Œ≥] [locally_compact_space (Œ± √ó Œ≤)] : continuous continuous_map.curry :=\n\n/-- A locally uniform limit of continuous functions is continuous. -/\ntheorem {Œ± : Type u_1} {Œ≤ : Type u_2} {Œπ : Type u_4} [uniform_space Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {p : filter Œπ} [topological_space Œ±] (h : tendsto_locally_uniformly F f p) (hc : ‚àÄ·∂† (n : Œπ) in p, continuous (F n)) [p.ne_bot] : continuous f :=\n\n/-- A uniform limit of continuous functions is continuous. -/\ntheorem {Œ± : Type u_1} {Œ≤ : Type u_2} {Œπ : Type u_4} [uniform_space Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {p : filter Œπ} [topological_space Œ±] (h : tendsto_uniformly F f p) (hc : ‚àÄ·∂† (n : Œπ) in p, continuous (F n)) [p.ne_bot] : continuous f :=\n\n/-- A function which can be locally uniformly approximated by continuous functions is continuous. -/\ntheorem {Œ± : Type u_1} {Œ≤ : Type u_2} [uniform_space Œ≤] {f : Œ± ‚Üí Œ≤} [topological_space Œ±] (L : ‚àÄ (x : Œ±) (u : set (Œ≤ √ó Œ≤)), u ‚àà uniformity Œ≤ ‚Üí (‚àÉ (t : set Œ±) (H : t ‚àà nhds x) (F : Œ± ‚Üí Œ≤), continuous_at F x ‚àß ‚àÄ (y : Œ±), y ‚àà t ‚Üí (f y, F y) ‚àà u)) : continuous f :=\n\n/-- A function which can be uniformly approximated by continuous functions is continuous. -/\ntheorem {Œ± : Type u_1} {Œ≤ : Type u_2} [uniform_space Œ≤] {f : Œ± ‚Üí Œ≤} [topological_space Œ±] (L : ‚àÄ (u : set (Œ≤ √ó Œ≤)), u ‚àà uniformity Œ≤ ‚Üí (‚àÉ (F : Œ± ‚Üí Œ≤), continuous F ‚àß ‚àÄ (y : Œ±), (f y, F y) ‚àà u)) : continuous f :=\n\n/-- If the composition of two functions is continuous, then each of them is continuous. -/\ntheorem "}
{"text": "If `a` commutes with `b` and `b` commutes with `c` then `a` commutes with `c`.", "fullPrompt": "/-- If `a` commutes with both `b` and `c`, then it commutes with their product. -/\ntheorem {S : Type u_1} [semigroup S] {a b c : S} (hab : commute a b) (hac : commute a c) : commute a (b * c) :=\n\n/-- If both `a` and `b` commute with `c`, then their product commutes with `c`. -/\ntheorem {S : Type u_1} [semigroup S] {a b c : S} (hac : commute a c) (hbc : commute b c) : commute (a * b) c :=\n\n/-- If both `a` and `b` commute with `c`, then their product commutes with `c`. -/\ntheorem {S : Type u_1} [add_semigroup S] {a b c : S} (hac : add_commute a c) (hbc : add_commute b c) : add_commute (a + b) c :=\n\n/-- If `a` commutes with both `b` and `c`, then it commutes with their sum. -/\ntheorem {S : Type u_1} [add_semigroup S] {a b c : S} (hab : add_commute a b) (hac : add_commute a c) : add_commute a (b + c) :=\n\n/-- If `a` commutes with `b`, then `b` commutes with `a`. -/\ntheorem {S : Type u_1} [has_mul S] {a b : S} (h : commute a b) : commute b a :=\n\n/-- If `a` commutes with `b`, then `b` commutes with `a`. -/\ntheorem {S : Type u_1} [has_add S] {a b : S} (h : add_commute a b) : add_commute b a :=\n\n/-- Any element commutes with itself. -/\ntheorem {S : Type u_1} [has_mul S] (a : S) : commute a a :=\n\n/-- Any element commutes with itself. -/\ntheorem {S : Type u_1} [has_add S] (a : S) : add_commute a a :=\n\n/-- Equality behind `commute a b`; useful for rewriting. -/\ntheorem {S : Type u_1} [has_mul S] {a b : S} (h : commute a b) : a * b = b * a :=\n\n/-- Commuting elements of finite order are closed under multiplication. -/\ntheorem {G : Type u} {y : G} [monoid G] {x : G} (h : commute x y) (hx : is_of_fin_order x) (hy : is_of_fin_order y) : is_of_fin_order (x * y) :=\n\n/-- Moving to the opposite group or group_with_zero commutes with taking powers. -/\ntheorem {M : Type u} [div_inv_monoid M] (x : M) (z : ‚Ñ§) : mul_opposite.op (x ^ z) = mul_opposite.op x ^ z :=\n\n/--  The inverse of a map which preserves multiplication, preserves multiplication when the target is commutative. -/\ntheorem {Œ± : Type u_1} {Œ≤ : Type u_2} [mul_one_class Œ±] [comm_group Œ≤] {f : Œ± ‚Üí Œ≤} (hf : is_monoid_hom f) : is_monoid_hom (Œª (a : Œ±), (f a)‚Åª¬π) :=\n\n/-- If `a` commutes with `b` and `b` commutes with `c` then `a` commutes with `c`. -/\ntheorem "}
{"text": "If an element maps to zero under a ring homomorphism, then it is zero.", "fullPrompt": "/-- Ring homomorphisms map zero to zero. -/\ntheorem {Œ± : Type u} {Œ≤ : Type v} [ring Œ±] [ring Œ≤] {f : Œ± ‚Üí Œ≤} (hf : is_ring_hom f) : f 0 = 0 :=\n\n/-- An additive group homomorphism sends 0 to 0. -/\ntheorem {Œ± : Type u} {Œ≤ : Type v} [add_group Œ±] [add_group Œ≤] {f : Œ± ‚Üí Œ≤} (hf : is_add_group_hom f) : f 0 = 0 :=\n\n/-- The identity map is a ring homomorphism. -/\ntheorem {Œ± : Type u} [ring Œ±] : is_ring_hom id :=\n\n/-- Ring homomorphisms preserve additive inverses. -/\ntheorem {Œ± : Type u} {Œ≤ : Type v} [ring Œ±] [ring Œ≤] {f : Œ± ‚Üí Œ≤} {x : Œ±} (hf : is_ring_hom f) : f (-x) = -f x :=\n\n/-- A ring homomorphism is also a semiring homomorphism. -/\ntheorem {Œ± : Type u} {Œ≤ : Type v} [ring Œ±] [ring Œ≤] {f : Œ± ‚Üí Œ≤} (hf : is_ring_hom f) : is_semiring_hom f :=\n\n/-- A map of rings that is a semiring homomorphism is also a ring homomorphism. -/\ntheorem {Œ± : Type u} {Œ≤ : Type v} [ring Œ±] [ring Œ≤] {f : Œ± ‚Üí Œ≤} (H : is_semiring_hom f) : is_ring_hom f :=\n\n/-- If there are zero morphisms, any initial object is a zero object. -/\ntheorem {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_initial C] : category_theory.limits.has_zero_object C :=\n\n/-- A group homomorphism is injective iff its kernel is trivial. -/\ntheorem {Œ± : Type u} {Œ≤ : Type v} [group Œ±] [group Œ≤] {f : Œ± ‚Üí Œ≤} (hf : is_group_hom f) : function.injective f ‚Üî ‚àÄ (a : Œ±), f a = 1 ‚Üí a = 1 :=\n\n/-- An additive group homomorphism is injective if its kernel is trivial. -/\ntheorem {Œ± : Type u} {Œ≤ : Type v} [add_group Œ±] [add_group Œ≤] {f : Œ± ‚Üí Œ≤} (hf : is_add_group_hom f) : function.injective f ‚Üî ‚àÄ (a : Œ±), f a = 0 ‚Üí a = 0 :=\n\n/-- The characteristic of a finite ring cannot be zero. -/\ntheorem (R : Type u) [non_assoc_ring R] (p : ‚Ñï) [hc : char_p R p] [fintype R] : p ‚â† 0 :=\n\n/-- The negation of an additive group homomorphism is an additive group homomorphism if the target is commutative. -/\ntheorem {Œ± : Type u_1} {Œ≤ : Type u_2} [add_group Œ±] [add_comm_group Œ≤] {f : Œ± ‚Üí Œ≤} (hf : is_add_group_hom f) : is_add_group_hom (Œª (a : Œ±), -f a) :=\n\n/-- If `R` has characteristic `0`, then so does Frac(R). -/\ntheorem (R : Type u_1) {K : Type u_2} [comm_ring R] [field K] [algebra R K] [is_fraction_ring R K] [char_zero R] : char_zero K :=\n\n/--  If `i : R ‚Üí K` is a ring homomorphism, `f` is a polynomial with coefficients in `R`, `a, b` are elements of `R`, with `i b` invertible, then there is a `D ‚àà R` such that `b ^ f.nat_degree * f (a / b)` equals `i D`. -/\ntheorem {R : Type u_1} {K : Type u_2} [semiring R] [comm_semiring K] {b : R} {bi : K} (i : R ‚Üí+* K) (f : polynomial R) (a : R) (bu : bi * ‚áëi b = 1) : denoms_clearable a b f.nat_degree f i :=\n\n/-- The range of a surjective ring homomorphism is the whole of the codomain. -/\ntheorem {R : Type u} {S : Type v} [non_assoc_semiring R] [non_assoc_semiring S] (f : R ‚Üí+* S) (hf : function.surjective ‚áëf) : f.srange = ‚ä§ :=\n\n/-- The range of a surjective ring homomorphism is the whole of the codomain. -/\ntheorem {R : Type u} {S : Type v} [ring R] [ring S] (f : R ‚Üí+* S) (hf : function.surjective ‚áëf) : f.range = ‚ä§ :=\n\n/--  A ring homomorphism f : Z[X_1, X_2, ...] ‚Üí R is determined by the evaluations f(X_1), f(X_2), ... -/\ntheorem {S : Type v} [comm_ring S] {R : Type u} (c : ‚Ñ§ ‚Üí+* S) (f : mv_polynomial R ‚Ñ§ ‚Üí+* S) (x : mv_polynomial R ‚Ñ§) : mv_polynomial.eval‚ÇÇ c (‚áëf ‚àò mv_polynomial.X) x = ‚áëf x :=\n\n/-- If an element maps to zero under a ring homomorphism, then it is zero. -/\ntheorem "}
{"text": "Implication `‚Üí` is symmetric. If `P ‚Üí Q` then `Q ‚Üí P`.", "fullPrompt": "/-- Implication `‚Üí` is transitive. If `P ‚Üí Q` and `Q ‚Üí R` then `P ‚Üí R`. -/\ntheorem {p q r : Prop} (h‚ÇÅ : implies p q) (h‚ÇÇ : implies q r) : implies p r :=\n\n/-- Modus tollens. If an implication is true, then so is its contrapositive. -/\ntheorem {a b : Prop} (h‚ÇÅ : a ‚Üí b) (h‚ÇÇ : ¬¨b) : ¬¨a :=\n\n/-- If `p` and `q` are irreducible, then `p ‚à£ q` implies `q ‚à£ p`. -/\ntheorem {Œ± : Type u_1} [monoid Œ±] {p q : Œ±} (hp : irreducible p) (hq : irreducible q) : p ‚à£ q ‚Üí q ‚à£ p :=\n\n/-- See `inv_lt_inv_of_lt` for the implication from right-to-left with one fewer assumption. -/\ntheorem {Œ± : Type u_1} [linear_ordered_field Œ±] {a b : Œ±} (ha : 0 < a) (hb : 0 < b) : a‚Åª¬π < b‚Åª¬π ‚Üî b < a :=\n\n/-- monotonicity of `‚â§` with respect to `‚Üí` -/\ntheorem {Œ± : Type u} {a b c d : Œ±} [preorder Œ±] (hca : c ‚â§ a) (hbd : b ‚â§ d) : a ‚â§ b ‚Üí c ‚â§ d :=\n\n/--  If a reflexive relation `r : Œ± ‚Üí Œ± ‚Üí Prop` holds over `x y : Œ±`, then it holds whether or not `x ‚â† y`. -/\ntheorem {Œ± : Type u_1} {r : Œ± ‚Üí Œ± ‚Üí Prop} (h : reflexive r) {x y : Œ±} : x ‚â† y ‚Üí r x y ‚Üî r x y :=\n\n/-- Composing two associative operations of `f : Œ± ‚Üí Œ± ‚Üí Œ±` on the left is equal to an associative operation on the left. -/\ntheorem {Œ± : Type u_1} (f : Œ± ‚Üí Œ± ‚Üí Œ±) [is_associative Œ± f] (x y : Œ±) : f x ‚àò f y = f (f x y) :=\n\n/--  One of de Morgan's laws: the negation of a conjunction is logically equivalent to the disjunction of the negations. -/\ntheorem {a b : Prop} : ¬¨(a ‚àß b) ‚Üî ¬¨a ‚à® ¬¨b :=\n\n/-- Negation of the condition `P : Prop` in a `dite` is the same as swapping the branches. -/\ntheorem {Œ± : Sort u_1} (P : Prop) [decidable P] (x : ¬¨P ‚Üí Œ±) (y : ¬¨¬¨P ‚Üí Œ±) : dite (¬¨P) x y = dite P (Œª (h : P), y _) x :=\n\n/-- `‚à®` distributes over `‚àß` (on the right). -/\ntheorem {a b c : Prop} : a ‚àß b ‚à® c ‚Üî (a ‚à® c) ‚àß (b ‚à® c) :=\n\n/-- See `inv_le_inv_of_le` for the implication from right-to-left with one fewer assumption. -/\ntheorem {Œ± : Type u_1} [linear_ordered_field Œ±] {a b : Œ±} (ha : 0 < a) (hb : 0 < b) : a‚Åª¬π ‚â§ b‚Åª¬π ‚Üî b ‚â§ a :=\n\n/-- `‚à®` distributes over `‚àß` (on the left). -/\ntheorem {a b c : Prop} : a ‚à® b ‚àß c ‚Üî (a ‚à® b) ‚àß (a ‚à® c) :=\n\n/-- Implication `‚Üí` is symmetric. If `P ‚Üí Q` then `Q ‚Üí P`. -/\ntheorem "}
{"text": "Two natural numbers are equal if and only if they are both divisible by some prime number.", "fullPrompt": "/-- Two natural numbers are equal if and only if the have the same multiples. -/\ntheorem {m n : ‚Ñï} : (‚àÄ (a : ‚Ñï), m ‚à£ a ‚Üî n ‚à£ a) ‚Üî m = n :=\n\n/-- Two natural numbers are equal if and only if the have the same divisors. -/\ntheorem {m n : ‚Ñï} : (‚àÄ (a : ‚Ñï), a ‚à£ m ‚Üî a ‚à£ n) ‚Üî m = n :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem  : set.inj_on nat.factorization {x : ‚Ñï | x ‚â† 0} :=\n\n/--  An equivalent definition for prime powers: `n` is a prime power iff there is a unique prime dividing it. -/\ntheorem {n : ‚Ñï} : is_prime_pow n ‚Üî ‚àÉ! (p : ‚Ñï), nat.prime p ‚àß p ‚à£ n :=\n\n/-- A natural number `m` divides the sum `m + n` if and only if `m` divides `n`. -/\ntheorem {m n : ‚Ñï} : m ‚à£ m + n ‚Üî m ‚à£ n :=\n\n/-- A prime `p` satisfies `p % 2 = 1` if and only if `p ‚â† 2`. -/\ntheorem {p : ‚Ñï} [fact (nat.prime p)] : p % 2 = 1 ‚Üî p ‚â† 2 :=\n\n/-- A natural number `m` divides the sum `n + m` if and only if `m` divides `n`. -/\ntheorem {m n : ‚Ñï} : m ‚à£ n + m ‚Üî m ‚à£ n :=\n\n/-- `m` is not divisible by `n` iff it is between `n * k` and `n * (k + 1)` for some `k`. -/\ntheorem (m : ‚Ñï) {n : ‚Ñï} (hn : 0 < n) : (‚àÉ (k : ‚Ñï), n * k < m ‚àß m < n * (k + 1)) ‚Üî ¬¨n ‚à£ m :=\n\n/--  An equivalent definition for prime powers: `n` is a prime power iff there is a prime `p` and a natural `k` such that `n` can be written as `p^(k+1)`. -/\ntheorem {R : Type u_1} [comm_monoid_with_zero R] (n : R) : is_prime_pow n ‚Üî ‚àÉ (p : R) (k : ‚Ñï), prime p ‚àß p ^ (k + 1) = n :=\n\n/-- If `n > 0` then `m` is not divisible by `n` iff it is between `n * k` and `n * (k + 1)`  for some `k`. -/\ntheorem (m : ‚Ñ§) {n : ‚Ñ§} (hn : 0 < n) : (‚àÉ (k : ‚Ñ§), n * k < m ‚àß m < n * (k + 1)) ‚Üî ¬¨n ‚à£ m :=\n\n/-- A natural number is odd iff it has residue `1` or `3` mod `4` -/\ntheorem {n : ‚Ñï} : n % 2 = 1 ‚Üî n % 4 = 1 ‚à® n % 4 = 3 :=\n\n/-- The only numbers with empty prime factorization are `0` and `1` -/\ntheorem (n : ‚Ñï) : n.factorization = 0 ‚Üî n = 0 ‚à® n = 1 :=\n\n/-- The exponential characteristic is a prime number or one. -/\ntheorem (R : Type u) [semiring R] [nontrivial R] [no_zero_divisors R] (q : ‚Ñï) [hq : exp_char R q] : nat.prime q ‚à® q = 1 :=\n\n/--  Euclid's theorem on the **infinitude of primes**. Here given in the form: for every `n`, there exists a prime number `p ‚â• n`. -/\ntheorem (n : ‚Ñï) : ‚àÉ (p : ‚Ñï), n ‚â§ p ‚àß nat.prime p :=\n\n/-- Infinitely many natural numbers are equal to `d` mod `n`. -/\ntheorem {n : ‚Ñï} (h : n ‚â† 0) (d : ‚Ñï) : ‚àÉ·∂† (m : ‚Ñï) in filter.at_top, m ‚â° d [MOD n] :=\n\n/--  If a small natural number is divisible by a larger natural number, the small number is zero. -/\ntheorem {a b : ‚Ñï} (w : a ‚à£ b) (h : b < a) : b = 0 :=\n\n/-- Two natural numbers are equal if and only if they are both divisible by some prime number. -/\ntheorem "}
