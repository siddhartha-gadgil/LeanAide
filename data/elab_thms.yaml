- doc_string: "Triangle inequality for the nonnegative distance"
  theorem: "{Î± : Type u} [pseudo_metric_space Î±] (x y z : Î±) : has_nndist.nndist x z â‰¤ has_nndist.nndist x y + has_nndist.nndist y z"

- doc_string: "**Alias** of sub_neg`."
  theorem: "{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b : Î±} : a - b < 0 â†” a < b"

- doc_string: "Assumes left covariance."
  theorem: "{Î± : Type u} {a b : Î±} [mul_one_class Î±] [has_zero Î±] [preorder Î±] [zero_lt.pos_mul_mono Î±] (ha : a â‰¤ 1) (hb : b â‰¤ 1) (a0 : 0 < a) : a * b â‰¤ 1"

- doc_string: "If `R` is an additive monoid, an element in `add_units R` is add-regular."
  theorem: "{R : Type u_1} [add_monoid R] (a : add_units R) : is_add_regular â†‘a"

- doc_string: " For every prime `p` dividing the order of a finite additive group `G` there exists an element of order `p` in `G`. This is the additive version of Cauchy's theorem."
  theorem: "{G : Type u_1} [add_group G] [fintype G] (p : â„•) [hp : fact (nat.prime p)] (hdvd : p âˆ£ fintype.card G) : âˆƒ (x : G), add_order_of x = p"

- doc_string: "**Alias** of the forward direction of sub_lt_iff_lt_add`."
  theorem: "{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b c : Î±} : a - c < b â†’ a < b + c"

- doc_string: "All values of a function `f âˆˆ std_simplex ð•œ Î¹` belong to `[0, 1]`."
  theorem: "{R : Type u_1} {Î¹ : Type u_4} [linear_ordered_field R] [fintype Î¹] {f : Î¹ â†’ R} (hf : f âˆˆ std_simplex R Î¹) (x : Î¹) : f x âˆˆ set.Icc 0 1"

- doc_string: " The neighbourhoods {Î³ | Î³ < Î³â‚€} of 0 form a directed set indexed by the invertible elements Î³â‚€."
  theorem: "(Î“â‚€ : Type u_1) [linear_ordered_comm_group_with_zero Î“â‚€] : directed ge (Î» (Î³â‚€ : Î“â‚€Ë£), filter.principal {Î³ : Î“â‚€ | Î³ < â†‘Î³â‚€})"

- doc_string: "The Legendre symbol of `p` and `a` is zero iff `p âˆ£ a`."
  theorem: "(p : â„•) [fact (nat.prime p)] (a : â„¤) : zmod.legendre_sym p a = 0 â†” â†‘a = 0"

- doc_string: "The Hausdorff distance is nonnegative"
  theorem: "{Î± : Type u} [pseudo_metric_space Î±] {s t : set Î±} : 0 â‰¤ metric.Hausdorff_dist s t"

- doc_string: "In a non-trivial integral domain, an element is regular iff it is non-zero."
  theorem: "{R : Type u_1} {a : R} [cancel_monoid_with_zero R] [nontrivial R] : is_regular a â†” a â‰  0"

- doc_string: "This is a special case of `with_top.coe_sub` in the `ennreal` namespace"
  theorem: "{r p : nnreal} : â†‘(r - p) = â†‘r - â†‘p"

- doc_string: "Any descending central series for a group is bounded below by the lower central series."
  theorem: "{G : Type u_1} [group G] (H : â„• â†’ subgroup G) (hH : is_descending_central_series H) (n : â„•) : lower_central_series G n â‰¤ H n"

- doc_string: "A sequential limit of measurable `â„â‰¥0âˆž` valued functions is measurable."
  theorem: "{Î± : Type u_1} [measurable_space Î±] {f : â„• â†’ Î± â†’ ennreal} {g : Î± â†’ ennreal} (hf : âˆ€ (i : â„•), measurable (f i)) (lim : filter.tendsto f filter.at_top (nhds g)) : measurable g"

- doc_string: "In a local ring the characteristics is either zero or a prime power."
  theorem: "(R : Type u_1) [comm_ring R] [local_ring R] (q : â„•) [char_R_q : char_p R q] : q = 0 âˆ¨ is_prime_pow q"

- doc_string: "Any power of a left-regular element is left-regular."
  theorem: "{R : Type u_1} {a : R} [monoid R] (n : â„•) (rla : is_left_regular a) : is_left_regular (a ^ n)"

- doc_string: " The square of the cosine of `Ï€ / 6` is `3 / 4` (this is sometimes more convenient than the result for cosine itself)."
  theorem: " : real.cos (real.pi / 6) ^ 2 = 3 / 4"

- doc_string: "An element `a` is right-regular if and only if a positive power of `a` is right-regular."
  theorem: "{R : Type u_1} {a : R} [monoid R] {n : â„•} (n0 : 0 < n) : is_right_regular (a ^ n) â†” is_right_regular a"

- doc_string: "A binary injective function is injective when only the left argument varies."
  theorem: "{Î± : Sort u_1} {Î² : Sort u_2} {Î³ : Sort u_3} {f : Î± â†’ Î² â†’ Î³} (hf : function.injective2 f) (b : Î²) : function.injective (Î» (a : Î±), f a b)"

- doc_string: "Any point is a periodic point of period `0`."
  theorem: "{Î± : Type u_1} (f : Î± â†’ Î±) (x : Î±) : function.is_periodic_pt f 0 x"

- doc_string: "**Alias** of the reverse direction of is_atom_dual_iff_is_coatom`."
  theorem: "{Î± : Type u_1} [preorder Î±] [order_top Î±] {a : Î±} : is_coatom a â†’ is_atom (â‡‘order_dual.to_dual a)"

- doc_string: " An injective function from a nontrivial type has an argument at which it does not take a given value."
  theorem: "{Î± : Type u_1} {Î² : Type u_2} [nontrivial Î±] {f : Î± â†’ Î²} (hf : function.injective f) (y : Î²) : âˆƒ (x : Î±), f x â‰  y"

- doc_string: "The set of natural number multiples of an element of an `add_monoid` `M` is an `add_submonoid` of `M`."
  theorem: "{M : Type u_1} [add_monoid M] (x : M) : is_add_submonoid (multiples x)"

- doc_string: "A continuous surjective open map is a quotient map."
  theorem: "{Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] {f : Î± â†’ Î²} (open_map : is_open_map f) (cont : continuous f) (surj : function.surjective f) : quotient_map f"

- doc_string: "Infinite ordinals that are cardinals are unbounded."
  theorem: " : set.unbounded has_lt.lt {b : ordinal | b.card.ord = b âˆ§ ordinal.omega â‰¤ b}"

- doc_string: "If `irreducible (cyclotomic (p ^ n) R)` then `irreducible (cyclotomic p R).`"
  theorem: "{p : â„•} (hp : nat.prime p) {R : Type u_1} [comm_ring R] [is_domain R] {n : â„•} (hn : n â‰  0) (h : irreducible (polynomial.cyclotomic (p ^ n) R)) : irreducible (polynomial.cyclotomic p R)"

- doc_string: "Deprecated: use `fun_like.congr_fun` instead."
  theorem: "{M : Type u_3} {N : Type u_4} [has_zero M] [has_zero N] {f g : zero_hom M N} (h : f = g) (x : M) : â‡‘f x = â‡‘g x"

- doc_string: "an n-digit number in base b + 2 is less than (b + 2)^n"
  theorem: "{b : â„•} {l : list â„•} (hl : âˆ€ (x : â„•), x âˆˆ l â†’ x < b + 2) : nat.of_digits (b + 2) l < (b + 2) ^ l.length"

- doc_string: " Embedding `i : fin n` into `fin (n + 1)` using a pivot `p` that is lesser results in a value that is greater than `p`."
  theorem: "{n : â„•} (p : fin (n + 1)) (i : fin n) : p < â‡‘(p.succ_above) i â†” p â‰¤ â‡‘fin.cast_succ i"

- doc_string: "A special case of `ring_hom.eq_int_cast'` that happens to be true definitionally"
  theorem: "(R : Type u_1) [ring R] : algebra_map â„¤ R = int.cast_ring_hom R"

- doc_string: "A natural number is odd iff it has residue `1` or `3` mod `4`"
  theorem: "{n : â„•} : n % 2 = 1 â†” n % 4 = 1 âˆ¨ n % 4 = 3"

- doc_string: " `submodule.orthogonal` gives a `galois_connection` between `submodule ð•œ E` and its `order_dual`."
  theorem: "(ð•œ : Type u_1) (E : Type u_2) [is_R_or_C ð•œ] [inner_product_space ð•œ E] : galois_connection submodule.orthogonal submodule.orthogonal"

- doc_string: " If `S` is the localization of the Jacobson ring `R` at the submonoid generated by `y : R`, then `S` is Jacobson."
  theorem: "{R : Type u_1} {S : Type u_2} [comm_ring R] [comm_ring S] (y : R) [algebra R S] [is_localization.away y S] [H : ideal.is_jacobson R] : ideal.is_jacobson S"

- doc_string: " The inverse of a map which preserves multiplication, preserves multiplication when the target is commutative."
  theorem: "{Î± : Type u_1} {Î² : Type u_2} [mul_one_class Î±] [comm_group Î²] {f : Î± â†’ Î²} (hf : is_monoid_hom f) : is_monoid_hom (Î» (a : Î±), (f a)â»Â¹)"

- doc_string: "The exponential characteristic is one if the characteristic is zero."
  theorem: "(R : Type u) [semiring R] (q : â„•) [hp : char_p R 0] [hq : exp_char R q] : q = 1"

- doc_string: "**Alias** of the reverse direction of mul_sub_mul_div_mul_nonpos_iff`."
  theorem: "{Î± : Type u_1} [linear_ordered_field Î±] {a b c d : Î±} (hc : c â‰  0) (hd : d â‰  0) : a / c â‰¤ b / d â†’ (a * d - b * c) / (c * d) â‰¤ 0"

- doc_string: "In a preadditive category, if the product over `f : J â†’ C` exists,    then the biproduct over `f` exists."
  theorem: "{C : Type u} [category_theory.category C] [category_theory.preadditive C] {J : Type v} [fintype J] (f : J â†’ C) [category_theory.limits.has_product f] : category_theory.limits.has_biproduct f"

- doc_string: "Uses `right` co(ntra)variant."
  theorem: "{Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± (function.swap has_mul.mul) has_lt.lt] {a : Î±} : 1 < aâ»Â¹ â†” a < 1"

- doc_string: "An element a divides the sum a + b if and only if a divides b."
  theorem: "{Î± : Type u} [ring Î±] {a b : Î±} : a âˆ£ a + b â†” a âˆ£ b"

- doc_string: "Extracts the erased value, if it is a proof."
  theorem: "{p : Prop} (a : erased p) : p"

- doc_string: "**Alias** of div_eq_mul_inv`."
  theorem: "{G : Type u_1} [div_inv_monoid G] (a b : G) : a / b = a * bâ»Â¹"

- doc_string: "**Alias** of int.nat_abs_sq`."
  theorem: "(x : â„¤) : â†‘(x.nat_abs) ^ 2 = x ^ 2"

- doc_string: "The sine of `Ï€ / 6` is `1 / 2`."
  theorem: " : real.sin (real.pi / 6) = 1 / 2"

- doc_string: "Any map `f` sends fixed points of `g âˆ˜ f` to fixed points of `f âˆ˜ g`."
  theorem: "{Î± : Type u} {Î² : Type v} (f : Î± â†’ Î²) (g : Î² â†’ Î±) : set.maps_to f (function.fixed_points (g âˆ˜ f)) (function.fixed_points (f âˆ˜ g))"

- doc_string: "A category with finite biproducts has binary biproducts.  This is not an instance as typically in concrete categories there will be an alternative construction with nicer definitional properties."
  theorem: "(C : Type u) [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_finite_biproducts C] : category_theory.limits.has_binary_biproducts C"

- doc_string: "**Alias** of the forward direction of lt_inv_mul_iff_mul_lt`."
  theorem: "{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b c : Î±} : b < -a + c â†’ a + b < c"

- doc_string: " Multiplication on the left by a nonzero element of a normed division ring tends to infinity at infinity. TODO: use `bornology.cobounded` instead of `filter.comap has_norm.norm filter.at_top`."
  theorem: "{Î± : Type u_1} [normed_division_ring Î±] {a : Î±} (ha : a â‰  0) : filter.tendsto (has_mul.mul a) (filter.comap has_norm.norm filter.at_top) (filter.comap has_norm.norm filter.at_top)"

- doc_string: "**Alias** of mul_lt_mul_left'`."
  theorem: "{Î± : Type u_1} [has_mul Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {b c : Î±} (bc : b < c) (a : Î±) : a * b < a * c"

- doc_string: "The relation `â‰¤` on a preorder is reflexive."
  theorem: "{Î± : Type u} [preorder Î±] (a : Î±) : a â‰¤ a"

- doc_string: "**Alias** of left.mul_lt_one`."
  theorem: "{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a b : Î±} (ha : a < 1) (hb : b < 1) : a * b < 1"

- doc_string: "`X` is simple iff it has subobject lattice `{âŠ¥, âŠ¤}`."
  theorem: "{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] (X : C) : category_theory.simple X â†” is_simple_order (category_theory.subobject X)"

- doc_string: "`set.image` is monotone. See `set.image_image` for the statement in terms of `âŠ†`."
  theorem: "{Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} : monotone (set.image f)"

- doc_string: " The real exponential function tends to `0` at `-âˆž` or, equivalently, `exp(-x)` tends to `0` at `+âˆž`"
  theorem: " : filter.tendsto (Î» (x : â„), real.exp (-x)) filter.at_top (nhds 0)"

- doc_string: " If `x = y` then `y â‰¤ x`. Note: this lemma uses `y â‰¤ x` instead of `x â‰¥ y`, because `le` is used almost exclusively in mathlib."
  theorem: "{Î± : Type u} [preorder Î±] {x y : Î±} (h : x = y) : y â‰¤ x"

- doc_string: "A balanced set absorbs itself."
  theorem: "{ð•œ : Type u_1} {E : Type u_3} [normed_field ð•œ] [add_comm_group E] [module ð•œ E] {A : set E} (hA : balanced ð•œ A) : absorbs ð•œ A A"

- doc_string: "Shorthand for using projection notation with `function.bijective_iff_exists_unique`."
  theorem: "{Î± : Sort u_1} {Î² : Sort u_2} {f : Î± â†’ Î²} (hf : function.bijective f) (b : Î²) : âˆƒ! (a : Î±), f a = b"

- doc_string: "**Alias** of le_of_eq`."
  theorem: "{Î± : Type u} [preorder Î±] {a b : Î±} : a = b â†’ a â‰¤ b"

- doc_string: " A triple is still a triple if you multiply `x`, `y` and `z` by a constant `k`."
  theorem: "{x y z : â„¤} (h : pythagorean_triple x y z) (k : â„¤) : pythagorean_triple (k * x) (k * y) (k * z)"

- doc_string: "The indexed supremum of a function is bounded below by the value taken at one point"
  theorem: "{Î± : Type u_1} {Î¹ : Sort u_3} [conditionally_complete_lattice Î±] {f : Î¹ â†’ Î±} (H : bdd_above (set.range f)) (c : Î¹) : f c â‰¤ supr f"

- doc_string: "**Alias** of the reverse direction of order.succ_eq_iff_is_max`."
  theorem: "{Î± : Type u_1} [partial_order Î±] [succ_order Î±] {a : Î±} : is_max a â†’ order.succ a = a"

- doc_string: "A non-zero `a : F` is a square if and only if `a ^ (#F / 2) = 1`."
  theorem: "{F : Type u_3} [field F] [fintype F] (hF : ring_char F â‰  2) {a : F} (ha : a â‰  0) : is_square a â†” a ^ (fintype.card F / 2) = 1"

- doc_string: "Over the ring `zmod (p^(n+1))`, we produce the `n+1`st Witt polynomial by expanding the `n`th Witt polynomial by `p`."
  theorem: "(p n : â„•) : witt_polynomial p (zmod (p ^ (n + 1))) (n + 1) = â‡‘(mv_polynomial.expand p) (witt_polynomial p (zmod (p ^ (n + 1))) n)"

- doc_string: "The value of the quadratic character at `-1`"
  theorem: "{F : Type u_1} [field F] [fintype F] [decidable_eq F] (hF : ring_char F â‰  2) : char.quadratic_char F (-1) = â‡‘zmod.Ï‡â‚„ â†‘(fintype.card F)"

- doc_string: "The pseudoelement induced by an arrow is zero precisely when that arrow is zero"
  theorem: "{C : Type u} [category_theory.category C] [category_theory.abelian C] {P : C} (a : category_theory.over P) : â†‘a = 0 â†” a.hom = 0"

- doc_string: "`âˆ§` distributes over `âˆ¨` (on the left)."
  theorem: "{a b c : Prop} : a âˆ§ (b âˆ¨ c) â†” a âˆ§ b âˆ¨ a âˆ§ c"

- doc_string: "Quantifying over a set is antitone in the set"
  theorem: "{Î± : Type u_1} {P : Î± â†’ Prop} : antitone (Î» (s : set Î±), âˆ€ (x : Î±), x âˆˆ s â†’ P x)"

- doc_string: "**Alias** of lt_trans'`."
  theorem: "{Î± : Type u} [preorder Î±] {a b c : Î±} : b < c â†’ a < b â†’ a < c"

- doc_string: "`âˆ§` distributes over `âˆ¨` (on the right)."
  theorem: "{a b c : Prop} : (a âˆ¨ b) âˆ§ c â†” a âˆ§ c âˆ¨ b âˆ§ c"

- doc_string: "The normal closure of s is a normal subgroup."
  theorem: "{G : Type u_1} {s : set G} [group G] : is_normal_subgroup (group.normal_closure s)"

- doc_string: "The identity is `C^âˆž`."
  theorem: "{ð•œ : Type u_1} [nondiscrete_normed_field ð•œ] {E : Type u_2} [normed_group E] [normed_space ð•œ E] {n : with_top â„•} : cont_diff ð•œ n id"

- doc_string: "**Alias** of the reverse direction of sub_lt_iff_lt_add`."
  theorem: "{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b c : Î±} : a < b + c â†’ a - c < b"

- doc_string: "The relation `â‰¤` on a preorder is transitive."
  theorem: "{Î± : Type u} [preorder Î±] {a b c : Î±} : a â‰¤ b â†’ b â‰¤ c â†’ a â‰¤ c"

- doc_string: "The currying process is a continuous map between function spaces."
  theorem: "{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [topological_space Î±] [topological_space Î²] [topological_space Î³] [locally_compact_space (Î± Ã— Î²)] : continuous continuous_map.curry"

- doc_string: "Assumes right covariance."
  theorem: "{Î± : Type u} {a b : Î±} [mul_zero_one_class Î±] [partial_order Î±] [zero_lt.mul_pos_mono Î±] (ha : a â‰¤ 1) (hb : b â‰¤ 1) (b0 : 0 < b) : a * b â‰¤ 1"

- doc_string: "If `t` is bounded, then so is `s âˆ© t`"
  theorem: "{Î± : Type u} [preorder Î±] {s t : set Î±} (h : bdd_above t) : bdd_above (s âˆ© t)"

- doc_string: "The closure of a (pre)connected set is (pre)connected as well."
  theorem: "{Î± : Type u} [topological_space Î±] {s : set Î±} (H : is_preconnected s) : is_preconnected (closure s)"

- doc_string: "In a field `F`, `X ^ n - 1` is separable iff `â†‘n â‰  0`."
  theorem: "{F : Type u} [field F] {n : â„•} : (polynomial.X ^ n - 1).separable â†” â†‘n â‰  0"

- doc_string: "**Alias** of le_antisymm`."
  theorem: "{Î± : Type u} [partial_order Î±] {a b : Î±} : a â‰¤ b â†’ b â‰¤ a â†’ a = b"

- doc_string: "`pure : Î± â†’ ultrafilter Î±` defines a dense embedding of `Î±` in `ultrafilter Î±`."
  theorem: "{Î± : Type u} : dense_embedding has_pure.pure"

- doc_string: " The weights in the centroid sum to 1, if the number of points, converted to `k`, is not zero."
  theorem: "{k : Type u_1} [division_ring k] {Î¹ : Type u_4} (s : finset Î¹) (h : â†‘(s.card) â‰  0) : s.sum (Î» (i : Î¹), finset.centroid_weights k s i) = 1"

- doc_string: "**Alias** of not_le_of_lt`."
  theorem: "{Î± : Type u} [preorder Î±] {a b : Î±} (h : a < b) : Â¬b â‰¤ a"

- doc_string: "Addition of a `u : add_units M` on the left doesn't affect `is_add_unit`."
  theorem: "{M : Type u_1} [add_monoid M] (u : add_units M) (a : M) : is_add_unit (â†‘u + a) â†” is_add_unit a"

- doc_string: "Assumes right covariance. The lemma assuming left covariance is `left.add_neg_of_neg_of_nonpos`."
  theorem: "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b : Î±} (ha : a < 0) (hb : b â‰¤ 0) : a + b < 0"

- doc_string: "A product is regular if and only if the factors are."
  theorem: "{R : Type u_1} {a b : R} [comm_semigroup R] : is_regular (a * b) â†” is_regular a âˆ§ is_regular b"

- doc_string: " We intentionally restrict the type of `Î±` in this lemma so that this is a safer to use in simp than `forall_swap`."
  theorem: "{Î± : Type u_1} {p : Prop} {q : Î± â†’ Prop} : p â†’ âˆ€ (x : Î±), q x â†” âˆ€ (x : Î±), p â†’ q x"

- doc_string: "The closure of the interval `[a, b)` is the closed interval `[a, b]`."
  theorem: "{Î± : Type u} [topological_space Î±] [linear_order Î±] [order_topology Î±] [densely_ordered Î±] {a b : Î±} (hab : a â‰  b) : closure (set.Ico a b) = set.Icc a b"

- doc_string: "The frontier of a set is closed."
  theorem: "{Î± : Type u} [topological_space Î±] {s : set Î±} : is_closed (frontier s)"

- doc_string: "A `dite` whose results do not actually depend on the condition may be reduced to an `ite`."
  theorem: "{Î± : Sort u_1} (P : Prop) [decidable P] (a b : Î±) : dite P (Î» (h : P), a) (Î» (h : Â¬P), b) = ite P a b"

- doc_string: " If self-maps `f` and `g` commute, then `f` is bijective on the set of fixed points of `f âˆ˜ g`. This is a particular case of `function.bij_on_fixed_pts_comp`."
  theorem: "{Î± : Type u} {f g : Î± â†’ Î±} (h : function.commute f g) : set.bij_on f (function.fixed_points (f âˆ˜ g)) (function.fixed_points (f âˆ˜ g))"

- doc_string: "**Alias** of the forward direction of is_max_filter_dual_iff`."
  theorem: "{Î± : Type u} {Î² : Type v} [preorder Î²] {f : Î± â†’ Î²} {l : filter Î±} {a : Î±} : is_max_filter (â‡‘order_dual.to_dual âˆ˜ f) l a â†’ is_min_filter f l a"

- doc_string: " Assumes left covariance. The lemma assuming right covariance is `right.mul_lt_one`."
  theorem: "{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a b : Î±} (ha : a < 1) (hb : b < 1) : a * b < 1"

- doc_string: "Multiplicative congruence relations preserve natural powers."
  theorem: "{M : Type u_1} [monoid M] (c : con M) (n : â„•) {w x : M} : â‡‘c w x â†’ â‡‘c (w ^ n) (x ^ n)"

- doc_string: " `finsupp.single a b` is injective in `a`. For the statement that it is injective in `b`, see `finsupp.single_injective`"
  theorem: "{Î± : Type u_1} {M : Type u_5} [has_zero M] {b : M} (h : b â‰  0) : function.injective (Î» (a : Î±), finsupp.single a b)"

- doc_string: "Deprecated. Use `fun_like.ext_iff`."
  theorem: "{R : Type u_2} {Î“â‚€ : Type u_3} [ring R] [linear_ordered_comm_monoid_with_zero Î“â‚€] {vâ‚ vâ‚‚ : valuation R Î“â‚€} : vâ‚ = vâ‚‚ â†” âˆ€ (r : R), â‡‘vâ‚ r = â‡‘vâ‚‚ r"

- doc_string: "**Alias** of `left.add_nonpos`."
  theorem: "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : a â‰¤ 0) (hb : b â‰¤ 0) : a + b â‰¤ 0"

- doc_string: "**Alias** of the forward direction of same_ray_neg_iff`."
  theorem: "{R : Type u_1} [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {x y : M} : same_ray R (-x) (-y) â†’ same_ray R x y"

- doc_string: "`âˆ¨` distributes over `âˆ§` (on the left)."
  theorem: "{a b c : Prop} : a âˆ¨ b âˆ§ c â†” (a âˆ¨ b) âˆ§ (a âˆ¨ c)"

- doc_string: "**Alias** of left.mul_lt_one'`."
  theorem: "{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a b : Î±} (ha : a < 1) (hb : b < 1) : a * b < 1"

- doc_string: "**Alias** of lt_asymm`."
  theorem: "{Î± : Type u} [preorder Î±] {a b : Î±} (h : a < b) : Â¬b < a"

- doc_string: "Commuting elements of finite additive order are closed under addition."
  theorem: "{G : Type u} {y : G} [add_monoid G] {x : G} (h : add_commute x y) (hx : is_of_fin_add_order x) (hy : is_of_fin_add_order y) : is_of_fin_add_order (x + y)"

- doc_string: "**Alias** of dvd_pow`."
  theorem: "{M : Type u} [monoid M] {x y : M} (hxy : x âˆ£ y) {n : â„•} (hn : n â‰  0) : x âˆ£ y ^ n"

- doc_string: " The minimal distance from `x` to `s` is bounded by the distance from `y` to `s`, modulo the distance between `x` and `y`"
  theorem: "{Î± : Type u} [pseudo_metric_space Î±] {s : set Î±} {x y : Î±} : metric.inf_dist x s â‰¤ metric.inf_dist y s + has_dist.dist x y"

- doc_string: "An element of `R` admitting a left inverse is `M`-regular."
  theorem: "{R : Type u_1} {M : Type u_3} {a b : R} [monoid R] [mul_action R M] (h : a * b = 1) : is_smul_regular M b"

- doc_string: "A module over a division ring is noetherian if and only if it is finitely generated."
  theorem: "{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] : is_noetherian K V â†” module.finite K V"

- doc_string: "**Alias** of lt_of_le_of_ne`."
  theorem: "{Î± : Type u} [partial_order Î±] {a b : Î±} : a â‰¤ b â†’ a â‰  b â†’ a < b"

- doc_string: " If `Î±` has no zero divisors, then for elements `a, b : Î±`, `a * b` is nonzero iff so is `b * a`."
  theorem: "{Mâ‚€ : Type u_1} [mul_zero_class Mâ‚€] [no_zero_divisors Mâ‚€] {a b : Mâ‚€} : a * b â‰  0 â†” b * a â‰  0"

- doc_string: "Assumes right covariance. The lemma assuming left covariance is `left.add_pos_of_nonneg_of_pos`."
  theorem: "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±} (ha : 0 â‰¤ a) (hb : 0 < b) : 0 < a + b"

- doc_string: "**Alias** of the forward direction of sub_le_iff_le_add'`."
  theorem: "{Î± : Type u} [add_comm_group Î±] [has_le Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b c : Î±} : a - b â‰¤ c â†’ a â‰¤ b + c"

- doc_string: "The Hausdorff distance between a set and itself is zero"
  theorem: "{Î± : Type u} [pseudo_metric_space Î±] {s : set Î±} : metric.Hausdorff_dist s s = 0"

- doc_string: " A set `s` is not bounded above if and only if for each `x` there exists `y âˆˆ s` that is greater than `x`. A version for preorders is called `not_bdd_above_iff'`."
  theorem: "{Î± : Type u_1} [linear_order Î±] {s : set Î±} : Â¬bdd_above s â†” âˆ€ (x : Î±), âˆƒ (y : Î±) (H : y âˆˆ s), x < y"

- doc_string: "If matrix A is right invertible, then its inverse equals its right inverse."
  theorem: "{n : Type u'} {Î± : Type v} [fintype n] [decidable_eq n] [comm_ring Î±] {A B : matrix n n Î±} (h : A.mul B = 1) : Aâ»Â¹ = B"

- doc_string: "The functor Compactum_to_CompHaus is essentially surjective."
  theorem: " : category_theory.ess_surj Compactum_to_CompHaus"

- doc_string: "The 1 of the quotient of a monoid by a congruence relation is the equivalence class of the    monoid's 1."
  theorem: "{M : Type u_1} [mul_one_class M] {c : con M} : â†‘1 = 1"

- doc_string: "The element `0` is regular if and only if `R` is trivial."
  theorem: "{R : Type u_1} [mul_zero_class R] (h : is_regular 0) : subsingleton R"

- doc_string: "**Alias** of left.inv_lt_one_iff`."
  theorem: "{Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a : Î±} : aâ»Â¹ < 1 â†” 1 < a"

- doc_string: "**Alias** of left.mul_lt_one_of_lt_of_le`."
  theorem: "{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a b : Î±} (ha : a < 1) (hb : b â‰¤ 1) : a * b < 1"

- doc_string: "`cut_expand r` is well-founded when `r` is."
  theorem: "{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} (hr : well_founded r) : well_founded (relation.cut_expand r)"

- doc_string: "A group homomorphism is injective iff its kernel is trivial."
  theorem: "{Î± : Type u} {Î² : Type v} [group Î±] [group Î²] {f : Î± â†’ Î²} (hf : is_group_hom f) : function.injective f â†” âˆ€ (a : Î±), f a = 1 â†’ a = 1"

- doc_string: "The multiplicity of `a` as root of `(X - a) ^ n` is `n`."
  theorem: "{R : Type u} [comm_ring R] [is_domain R] (a : R) (n : â„•) : polynomial.root_multiplicity a ((polynomial.X - â‡‘polynomial.C a) ^ n) = n"

- doc_string: " The Hausdorff distance to the empty set vanishes (if you want to have the more reasonable value âˆž instead, use `Hausdorff_edist`, which takes values in â„â‰¥0âˆž)"
  theorem: "{Î± : Type u} [pseudo_metric_space Î±] {s : set Î±} : metric.Hausdorff_dist s âˆ… = 0"

- doc_string: "For the single implications with fewer assumptions, see `one_div_le_one_div_of_le` and  `le_of_one_div_le_one_div`"
  theorem: "{Î± : Type u_1} [linear_ordered_field Î±] {a b : Î±} (ha : 0 < a) (hb : 0 < b) : 1 / a â‰¤ 1 / b â†” b â‰¤ a"

- doc_string: "In a finite field of characteristic `2`, all elements are squares."
  theorem: "{F : Type u_3} [field F] [fintype F] (hF : ring_char F = 2) (a : F) : is_square a"

- doc_string: "The set of Liouville numbers has Lebesgue measure zero."
  theorem: " : â‡‘measure_theory.measure_space.volume {x : â„ | liouville x} = 0"

- doc_string: "The submonoid generated by a set is contained in any submonoid that contains the set."
  theorem: "{M : Type u_1} [monoid M] {s t : set M} (ht : is_submonoid t) (h : s âŠ† t) : monoid.closure s âŠ† t"

- doc_string: "**Alias** of int.abs_le_self_sq`."
  theorem: "(a : â„¤) : â†‘(a.nat_abs) â‰¤ a ^ 2"

- doc_string: "A list with product greater than one must have positive length."
  theorem: "{M : Type u_3} [monoid M] [preorder M] (L : list M) (h : 1 < L.prod) : 0 < L.length"

- doc_string: "**Alias** of left.mul_lt_one_of_le_of_lt`."
  theorem: "{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a b : Î±} (ha : a â‰¤ 1) (hb : b < 1) : a * b < 1"

- doc_string: "If an element a divides another element b in a commutative ring, a divides the sum of b and  another element c iff a divides c."
  theorem: "{Î± : Type u} [non_unital_ring Î±] {a b c : Î±} (h : a âˆ£ b) : a âˆ£ b + c â†” a âˆ£ c"

- doc_string: "A map to a group preserving multiplication is a monoid homomorphism."
  theorem: "{Î± : Type u} {Î² : Type v} [mul_one_class Î±] [group Î²] {f : Î± â†’ Î²} (hf : is_mul_hom f) : is_monoid_hom f"

- doc_string: "**Alias** of the reverse direction of inv_mul_lt_iff_lt_mul`."
  theorem: "{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b c : Î±} : a < b + c â†’ -b + a < c"

- doc_string: "The sequence `dense_seq Î±` has dense range."
  theorem: "(Î± : Type u) [t : topological_space Î±] [topological_space.separable_space Î±] [nonempty Î±] : dense_range (topological_space.dense_seq Î±)"

- doc_string: "The minimal distance to a set (as `â„â‰¥0`) is Lipschitz in point with constant 1"
  theorem: "{Î± : Type u} [pseudo_metric_space Î±] (s : set Î±) : lipschitz_with 1 (Î» (x : Î±), metric.inf_nndist x s)"

- doc_string: "A list with product not one must have positive length."
  theorem: "{M : Type u_3} [monoid M] (L : list M) (h : L.prod â‰  1) : 0 < L.length"

- doc_string: "A compact Hausdorff space is totally disconnected if and only if it is totally separated, this  is also true for locally compact spaces."
  theorem: "{Î± : Type u} [topological_space Î±] [t2_space Î±] [compact_space Î±] : totally_disconnected_space Î± â†” totally_separated_space Î±"

- doc_string: "Comparison test of convergence of `â„â‰¥0`-valued series."
  theorem: "{Î² : Type u_2} {f g : Î² â†’ nnreal} (hgf : âˆ€ (b : Î²), g b â‰¤ f b) : summable f â†’ summable g"

- doc_string: " Every element is less than its closure. This property is sometimes referred to as extensivity or inflationarity."
  theorem: "{Î± : Type u_1} [partial_order Î±] (c : closure_operator Î±) (x : Î±) : x â‰¤ â‡‘c x"

- doc_string: "**Alias** of set.inj_on_of_injective`."
  theorem: "{Î± : Type u} {Î² : Type v} {f : Î± â†’ Î²} (h : function.injective f) (s : set Î±) : set.inj_on f s"

- doc_string: "Transposing a matrix preserves the determinant."
  theorem: "{n : Type u_2} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] (M : matrix n n R) : M.transpose.det = M.det"

- doc_string: "See `inv_lt_inv_of_lt` for the implication from right-to-left with one fewer assumption."
  theorem: "{Î± : Type u_1} [linear_ordered_field Î±] {a b : Î±} (ha : 0 < a) (hb : 0 < b) : aâ»Â¹ < bâ»Â¹ â†” b < a"

- doc_string: "Equivalence closure of binary relations is monotone."
  theorem: "{Î± : Type u_1} {r s : Î± â†’ Î± â†’ Prop} (h : âˆ€ (x y : Î±), r x y â†’ s x y) : eqv_gen.setoid r â‰¤ eqv_gen.setoid s"

- doc_string: " Assumes right covariance. The lemma assuming left covariance is `left.mul_lt_one_of_lt_of_le`."
  theorem: "{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_mul.mul) has_lt.lt] {a b : Î±} (ha : a < 1) (hb : b â‰¤ 1) : a * b < 1"

- doc_string: "Alias of `nat.mul_div_mul`"
  theorem: "(a b : â„•) {c : â„•} (hc : 0 < c) : c * a / (c * b) = a / b"

- doc_string: "The first projection in a product is a topological fiber bundle."
  theorem: "{B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] : is_topological_fiber_bundle F prod.fst"

- doc_string: "A semiring is `nontrivial` provided that there exists a nontrivial module over this semiring."
  theorem: "(R : Type u_1) (M : Type u_2) [semiring R] [nontrivial M] [add_comm_monoid M] [module R M] : nontrivial R"

- doc_string: " **The SchrÃ¶der-Bernstein Theorem**: Given injections `Î± â†’ Î²` and `Î² â†’ Î±`, we can get a bijection `Î± â†’ Î²`."
  theorem: "{Î± : Type u} {Î² : Type v} {f : Î± â†’ Î²} {g : Î² â†’ Î±} (hf : function.injective f) (hg : function.injective g) : âˆƒ (h : Î± â†’ Î²), function.bijective h"

- doc_string: " Assumes right covariance. The lemma assuming left covariance is `left.mul_le_one`."
  theorem: "{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_mul.mul) has_le.le] {a b : Î±} (ha : a â‰¤ 1) (hb : b â‰¤ 1) : a * b â‰¤ 1"

- doc_string: " Predicate asserting that word `wâ‚` can be reduced to `wâ‚‚` in one step, i.e. there are words `wâ‚ƒ wâ‚„` and letter `x` such that `wâ‚ = wâ‚ƒxxâ»Â¹wâ‚„` and `wâ‚‚ = wâ‚ƒwâ‚„`"
  theorem: "{Î± : Type u} {Lâ‚ Lâ‚‚ : list (Î± Ã— bool)} : free_group.red.step Lâ‚ Lâ‚‚ â†’ Lâ‚‚.length + 2 = Lâ‚.length"

- doc_string: "The quadratic character is `1` or `-1` on nonzero arguments."
  theorem: "{F : Type u_1} [field F] [fintype F] [decidable_eq F] {a : F} (ha : a â‰  0) : char.quadratic_char F a = 1 âˆ¨ char.quadratic_char F a = -1"

- doc_string: "  An element is left-regular if and only if multiplying it on the left by a left-regular element is left-regular."
  theorem: "{R : Type u_1} {a : R} [semigroup R] (b : R) (ha : is_left_regular a) : is_left_regular (a * b) â†” is_left_regular b"

- doc_string: "**Alias** of the reverse direction of le_inv_mul_iff_mul_le`."
  theorem: "{Î± : Type u} [group Î±] [has_le Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a b c : Î±} : a * b â‰¤ c â†’ b â‰¤ aâ»Â¹ * c"

- doc_string: " **BÃ©zout's lemma**: given `x y : â„•`, `gcd x y = x * a + y * b`, where `a = gcd_a x y` and `b = gcd_b x y` are computed by the extended Euclidean algorithm."
  theorem: "(x y : â„•) : â†‘(x.gcd y) = â†‘x * x.gcd_a y + â†‘y * x.gcd_b y"

- doc_string: "if `-a â‰¤ b` then `-b â‰¤ a` on `ereal`."
  theorem: "{a b : ereal} (h : -a â‰¤ b) : -b â‰¤ a"

- doc_string: "In a sequential space, a set is closed iff it's sequentially closed."
  theorem: "{X : Type u_1} [topological_space X] [sequential_space X] {s : set X} : is_seq_closed s â†” is_closed s"

- doc_string: "Sophie Germain's identity, see <https://www.cut-the-knot.org/blue/SophieGermainIdentity.shtml>."
  theorem: "{R : Type u_1} [comm_ring R] {a b : R} : a ^ 4 + 4 * b ^ 4 = ((a - b) ^ 2 + b ^ 2) * ((a + b) ^ 2 + b ^ 2)"

- doc_string: "Assumes left covariance."
  theorem: "{Î± : Type u} {a b : Î±} [mul_one_class Î±] [has_zero Î±] [preorder Î±] [zero_lt.pos_mul_strict_mono Î±] (ha : 1 â‰¤ a) (hb : 1 < b) (a0 : 0 < a) : 1 < a * b"

- doc_string: "For rewriting in the reverse direction, see `fin.cast_nat_add_right`."
  theorem: "{n n' : â„•} (m : â„•) (i : fin n') (h : n' = n) : â‡‘(fin.nat_add m) (â‡‘(fin.cast h) i) = â‡‘(fin.cast _) (â‡‘(fin.nat_add m) i)"

- doc_string: "A sequential limit of measurable `â„â‰¥0` valued functions is measurable."
  theorem: "{Î± : Type u_1} [measurable_space Î±] {f : â„• â†’ Î± â†’ nnreal} {g : Î± â†’ nnreal} (hf : âˆ€ (i : â„•), measurable (f i)) (lim : filter.tendsto f filter.at_top (nhds g)) : measurable g"

- doc_string: "Assumes left covariance."
  theorem: "{Î± : Type u} {a b : Î±} [mul_one_class Î±] [has_zero Î±] [preorder Î±] [zero_lt.pos_mul_mono Î±] (ha : 1 < a) (hb : 1 â‰¤ b) (a0 : 0 < a) : 1 < a * b"

- doc_string: "Composition by an surjective function on the left is itself surjective."
  theorem: "{Î± : Sort u} {Î² : Sort v} {Î³ : Sort w} {g : Î² â†’ Î³} (hg : function.surjective g) : function.surjective (function.comp g)"

- doc_string: " If `Î±` has no zero divisors, then the product of two elements is nonzero iff both of them are nonzero."
  theorem: "{Mâ‚€ : Type u_1} [mul_zero_class Mâ‚€] [no_zero_divisors Mâ‚€] {a b : Mâ‚€} : a * b â‰  0 â†” a â‰  0 âˆ§ b â‰  0"

- doc_string: " Assumes left covariance. The lemma assuming right covariance is `right.mul_lt_one'`."
  theorem: "{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a b : Î±} (ha : a < 1) (hb : b < 1) : a * b < 1"

- doc_string: "  If an element `b` becomes left-regular after multiplying it on the left by a left-regular element, then `b` is left-regular."
  theorem: "{R : Type u_1} {a b : R} [semigroup R] (ab : is_left_regular (a * b)) : is_left_regular b"

- doc_string: "Assumes right covariance."
  theorem: "{Î± : Type u} {a b : Î±} [mul_one_class Î±] [has_zero Î±] [preorder Î±] [zero_lt.mul_pos_strict_mono Î±] (ha : a < 1) (hb : b < 1) (b0 : 0 < b) : a * b < 1"

- doc_string: "The minimal distance to a set is Lipschitz in point with constant 1"
  theorem: "{Î± : Type u} [pseudo_metric_space Î±] (s : set Î±) : lipschitz_with 1 (Î» (x : Î±), metric.inf_dist x s)"

- doc_string: "Finite groups are torsion groups."
  theorem: "{G : Type u_1} [group G] [fintype G] : monoid.is_torsion G"

- doc_string: "Any infinite type can be endowed a field structure."
  theorem: "{Î± : Type u} [infinite Î±] : nonempty (field Î±)"

- doc_string: "**Alias** of left.inv_lt_one_iff`."
  theorem: "{Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a : Î±} : aâ»Â¹ < 1 â†” 1 < a"

- doc_string: "Assumes right covariance. The lemma assuming left covariance is `left.add_pos_of_pos_of_nonneg`."
  theorem: "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b : Î±} (ha : 0 < a) (hb : 0 â‰¤ b) : 0 < a + b"

- doc_string: "**Alias** of lt_of_lt_of_eq'`."
  theorem: "{Î± : Type u} [preorder Î±] {a b c : Î±} : b < c â†’ a = b â†’ a < c"

- doc_string: "If `x` is a fixed point of `f`, then `f x = x`. This is useful, e.g., for `rw` or `simp`."
  theorem: "{Î± : Type u} {f : Î± â†’ Î±} {x : Î±} (hf : function.is_fixed_pt f x) : f x = x"

- doc_string: "The inverse of the golden ratio is the opposite of its conjugate."
  theorem: " : golden_ratioâ»Â¹ = -golden_conj"

- doc_string: " Multiplying `a` by itself and then dividing by itself results in `a` (whether or not `a` is zero)."
  theorem: "{Gâ‚€ : Type u_2} [group_with_zero Gâ‚€] (a : Gâ‚€) : a * a / a = a"

- doc_string: "If `p` and `q` are irreducible, then `p âˆ£ q` implies `q âˆ£ p`."
  theorem: "{Î± : Type u_1} [monoid Î±] {p q : Î±} (hp : irreducible p) (hq : irreducible q) : p âˆ£ q â†’ q âˆ£ p"

- doc_string: "A finite group of prime order is cyclic."
  theorem: "{Î± : Type u} [group Î±] [fintype Î±] {p : â„•} [hp : fact (nat.prime p)] (h : fintype.card Î± = p) : is_cyclic Î±"

- doc_string: " An element of a `cancel_monoid_with_zero` fixed by right multiplication by an element other than one must be zero."
  theorem: "{Mâ‚€ : Type u_1} [cancel_monoid_with_zero Mâ‚€] {a b : Mâ‚€} (hâ‚ : b â‰  1) (hâ‚‚ : a * b = a) : a = 0"

- doc_string: "Affine subspaces are convex."
  theorem: "{ð•œ : Type u_1} {E : Type u_2} [ordered_ring ð•œ] [add_comm_group E] [module ð•œ E] (Q : affine_subspace ð•œ E) : convex ð•œ â†‘Q"

- doc_string: "If `a` and `b` are equal mod `c`, `a - b` is zero mod `c`."
  theorem: "{a b c : â„•} (h : a % c = b % c) : (a - b) % c = 0"

- doc_string: "Two `v w : vector Î± n` are equal iff they are equal at every single index."
  theorem: "{n : â„•} {Î± : Type u_1} {v w : vector Î± n} (h : âˆ€ (m : fin n), v.nth m = w.nth m) : v = w"

- doc_string: "When multiplication is commutative, `star` preserves division."
  theorem: "{R : Type u} [field R] [star_ring R] (x y : R) : has_star.star (x / y) = has_star.star x / has_star.star y"

- doc_string: "The definition of `centroid_weights_indicator`."
  theorem: "(k : Type u_1) [division_ring k] {Î¹ : Type u_4} (s : finset Î¹) : finset.centroid_weights_indicator k s = â†‘s.indicator (finset.centroid_weights k s)"

- doc_string: " If `h : a âˆˆ {x | p x}` then `h.out : p x`. These are definitionally equal, but this can nevertheless be useful for various reasons, e.g. to apply further projection notation or in an argument to `simp`."
  theorem: "{Î± : Type u} {p : Î± â†’ Prop} {a : Î±} (h : a âˆˆ {x : Î± | p x}) : p a"

- doc_string: "Updating the first element of a tuple does not change the tail."
  theorem: "{n : â„•} {Î± : fin (n + 1) â†’ Type u} (q : Î  (i : fin (n + 1)), Î± i) (z : Î± 0) : fin.tail (function.update q 0 z) = fin.tail q"

- doc_string: "The shadow is monotone."
  theorem: "{Î± : Type u_1} [decidable_eq Î±] : monotone finset.shadow"

- doc_string: " When `R` is commutative and permits an `algebra_map`, `pi.const_ring_hom` is equal to that map."
  theorem: "(R : Type u_1) (A : Type u_2) [comm_semiring R] : pi.const_ring_hom A R = algebra_map R (A â†’ R)"

- doc_string: "Euler's product formula for the totient function."
  theorem: "(n : â„•) : â†‘(n.totient) = â†‘n * n.factors.to_finset.prod (Î» (p : â„•), 1 - (â†‘p)â»Â¹)"

- doc_string: " If `Î±` is a preorder with no maximal elements, then there exists a strictly monotone function `â„• â†’ Î±` with any prescribed value of `f 0`."
  theorem: "{Î± : Type u} [preorder Î±] [no_max_order Î±] (a : Î±) : âˆƒ (f : â„• â†’ Î±), strict_mono f âˆ§ f 0 = a"

- doc_string: "The function `(c,d) â†’ |cz+d|^2` is proper, that is, preimages of bounded-above sets are finite."
  theorem: "(z : upper_half_plane) : filter.tendsto (Î» (p : fin 2 â†’ â„¤), â‡‘complex.norm_sq (â†‘(p 0) * â†‘z + â†‘(p 1))) filter.cofinite filter.at_top"

- doc_string: "**Alias** of eq_of_le_of_not_lt`."
  theorem: "{Î± : Type u} [partial_order Î±] {a b : Î±} (hab : a â‰¤ b) (hba : Â¬a < b) : a = b"

- doc_string: "**Alias** of the forward direction of set.inj_on_iff_injective`."
  theorem: "{Î± : Type u} {Î² : Type v} {s : set Î±} {f : Î± â†’ Î²} : set.inj_on f s â†’ function.injective (s.restrict f)"

- doc_string: "Extensionality for `poly Î±`"
  theorem: "{Î± : Type u_1} {f g : poly Î±} : (âˆ€ (x : Î± â†’ â„•), â‡‘f x = â‡‘g x) â†’ f = g"

- doc_string: "A natural number `m` divides the sum `m + n` if and only if `m` divides `n`."
  theorem: "{m n : â„•} : m âˆ£ m + n â†” m âˆ£ n"

- doc_string: "An element admitting a left inverse is left-regular."
  theorem: "{R : Type u_1} {a b : R} [monoid R] (h : b * a = 1) : is_left_regular a"

- doc_string: "**Wilson's Lemma**: the product of `1`, ..., `p-1` is `-1` modulo `p`."
  theorem: "(p : â„•) [fact (nat.prime p)] : â†‘((p - 1).factorial) = -1"

- doc_string: "**Alias** of the forward direction of is_min_on_dual_iff`."
  theorem: "{Î± : Type u} {Î² : Type v} [preorder Î²] {f : Î± â†’ Î²} {s : set Î±} {a : Î±} : is_min_on (â‡‘order_dual.to_dual âˆ˜ f) s a â†’ is_max_on f s a"

- doc_string: " Multiplication on the right by a nonzero element of a normed division ring tends to infinity at infinity. TODO: use `bornology.cobounded` instead of `filter.comap has_norm.norm filter.at_top`."
  theorem: "{Î± : Type u_1} [normed_division_ring Î±] {a : Î±} (ha : a â‰  0) : filter.tendsto (Î» (x : Î±), x * a) (filter.comap has_norm.norm filter.at_top) (filter.comap has_norm.norm filter.at_top)"

- doc_string: "A unit in a monoid is regular."
  theorem: "{R : Type u_1} {a : R} [monoid R] (ua : is_unit a) : is_regular a"

- doc_string: " Given an inducing map of a topological space into a pseudo metrizable space, the source space is also pseudo metrizable."
  theorem: "{X : Type u_2} {Y : Type u_3} [topological_space X] [topological_space Y] [topological_space.pseudo_metrizable_space Y] {f : X â†’ Y} (hf : inducing f) : topological_space.pseudo_metrizable_space X"

- doc_string: "**Alias** of quaternion.commute_conj_conj`."
  theorem: "{R : Type u_1} [comm_ring R] {a b : quaternion R} (h : commute a b) : commute (â‡‘quaternion.conj a) (â‡‘quaternion.conj b)"

- doc_string: "A nontrivial torsion group is not torsion-free."
  theorem: "{G : Type u_1} [group G] [hN : nontrivial G] : monoid.is_torsion G â†’ Â¬monoid.is_torsion_free G"

- doc_string: "Note: `sym2.map_id` will not simplify `sym2.map id z` due to `sym2.map_congr`."
  theorem: "{Î± : Type u_1} : sym2.map (Î» (x : Î±), x) = id"

- doc_string: "The element `0` is left-regular if and only if `R` is trivial."
  theorem: "{R : Type u_1} [mul_zero_class R] : is_left_regular 0 â†” subsingleton R"

- doc_string: "Colex is an extension of the base ordering on Î±."
  theorem: "{Î± : Type u_1} [linear_order Î±] {r s : Î±} : {r}.to_colex â‰¤ {s}.to_colex â†” r â‰¤ s"

- doc_string: "An additive group homomorphism sends negations to negations."
  theorem: "{Î± : Type u} {Î² : Type v} [add_group Î±] [add_group Î²] {f : Î± â†’ Î²} (hf : is_add_group_hom f) (a : Î±) : f (-a) = -f a"

- doc_string: "`part` eta expansion"
  theorem: "{Î± : Type u_1} (o : part Î±) : {dom := o.dom, get := Î» (h : o.dom), o.get h} = o"

- doc_string: "See `add_tsub_cancel_left` for the equality if `contravariant_class Î± Î± (+) (â‰¤)`."
  theorem: "{Î± : Type u_1} [preorder Î±] [add_comm_semigroup Î±] [has_sub Î±] [has_ordered_sub Î±] {a b : Î±} : a + b - a â‰¤ b"

- doc_string: "Uses `left` co(ntra)variant."
  theorem: "{Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a : Î±} : 1 < aâ»Â¹ â†” a < 1"

- doc_string: "If `S` is a finite `R`-algebra, then `S' = Mâ»Â¹S` is a finite `R' = Mâ»Â¹R`-algebra."
  theorem: " : ring_hom.localization_preserves ring_hom.finite"

- doc_string: " If words `wâ‚ wâ‚‚` are such that `wâ‚` reduces to `wâ‚‚`, then `wâ‚‚` reduces to the maximal reduction of `wâ‚`."
  theorem: "{Î± : Type u} {Lâ‚ Lâ‚‚ : list (Î± Ã— bool)} [decidable_eq Î±] (H : free_group.red Lâ‚ Lâ‚‚) : free_group.red Lâ‚‚ (free_group.reduce Lâ‚)"

- doc_string: "**Alias** of mul_lt_mul_left'`."
  theorem: "{Î± : Type u_1} [has_add Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {b c : Î±} (bc : b < c) (a : Î±) : a + b < a + c"

- doc_string: " If `f` is a Lipschitz continuous map, then the Hausdorff dimension of its range is at most the Hausdorff dimension of its domain."
  theorem: "{X : Type u_2} {Y : Type u_3} [emetric_space X] [emetric_space Y] {K : nnreal} {f : X â†’ Y} (h : lipschitz_with K f) : dimH (set.range f) â‰¤ dimH set.univ"

- doc_string: "Composing two additions on the right by `y` and `x` is equal to a addition on the right by `y + x`."
  theorem: "{Î± : Type u_1} [add_semigroup Î±] (x y : Î±) : ((Î» (_x : Î±), _x + x) âˆ˜ Î» (_x : Î±), _x + y) = Î» (_x : Î±), _x + (y + x)"

- doc_string: "The first projection in a product is a trivial topological fiber bundle."
  theorem: "{B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] : is_trivial_topological_fiber_bundle F prod.fst"

- doc_string: "A field extension is integral if it is finite."
  theorem: "(K : Type u_1) (L : Type u_2) [field K] [field L] [algebra K L] [finite_dimensional K L] : algebra.is_integral K L"

- doc_string: "The identity affine map acts as the identity."
  theorem: "(k : Type u_1) {V1 : Type u_2} {P1 : Type u_3} [ring k] [add_comm_group V1] [module k V1] [add_torsor V1 P1] (p : P1) : â‡‘(affine_map.id k P1) p = p"

- doc_string: "As a map from the right argument to a unary function, `f` is injective."
  theorem: "{Î± : Sort u_1} {Î² : Sort u_2} {Î³ : Sort u_3} {f : Î± â†’ Î² â†’ Î³} (hf : function.injective2 f) [nonempty Î±] : function.injective (Î» (b : Î²) (a : Î±), f a b)"

- doc_string: "`zero_locus` and `vanishing_ideal` form a galois connection."
  theorem: "(R : Type u) [comm_ring R] : galois_connection (Î» (s : set R), prime_spectrum.zero_locus s) (Î» (t : (set (prime_spectrum R))áµ’áµˆ), â†‘(prime_spectrum.vanishing_ideal t))"

- doc_string: " A version of `antisymm'` with `r` explicit.  This lemma matches the lemmas from lean core in `init.algebra.classes`, but is missing there."
  theorem: "{Î± : Type u} (r : Î± â†’ Î± â†’ Prop) [is_antisymm Î± r] {a b : Î±} : r a b â†’ r b a â†’ b = a"

- doc_string: " A series of non-negative real numbers converges to `r` in the sense of `has_sum` if and only if the sequence of partial sum converges to `r`."
  theorem: "{f : â„• â†’ nnreal} {r : nnreal} : has_sum f r â†” filter.tendsto (Î» (n : â„•), (finset.range n).sum (Î» (i : â„•), f i)) filter.at_top (nhds r)"

- doc_string: "Congruence lemma for constructing `ex.exp`."
  theorem: "{Î± : Type u} [comm_semiring Î±] {p p' : Î±} {ps ps' : â„•} : p = p' â†’ ps = ps' â†’ p ^ ps = p' ^ ps'"

- doc_string: "The number of square roots of `a` modulo `p` is determined by the Legendre symbol."
  theorem: "(p : â„•) [fact (nat.prime p)] (hp : p â‰  2) (a : â„¤) : â†‘({x : zmod p | x ^ 2 = â†‘a}.to_finset.card) = zmod.legendre_sym p a + 1"

- doc_string: "A version of `le_refl` where the argument is implicit"
  theorem: "{Î± : Type u} [preorder Î±] {a : Î±} : a â‰¤ a"

- doc_string: "If a nondegenerate configuration has a unique point on any two lines, then `|L| â‰¤ |P|`."
  theorem: "(P L : Type u) [has_mem P L] [configuration.has_points P L] [fintype P] [fintype L] : fintype.card L â‰¤ fintype.card P"

- doc_string: " The fixed point lemma for normal functions: any normal function has an unbounded set of fixed points."
  theorem: "{f : ordinal â†’ ordinal} (H : ordinal.is_normal f) : set.unbounded has_lt.lt (function.fixed_points f)"

- doc_string: " The edist of `x` to `s` is bounded by the sum of the edist of `y` to `s` and the edist from `x` to `y`"
  theorem: "{Î± : Type u} [pseudo_emetric_space Î±] {x y : Î±} {s : set Î±} : emetric.inf_edist x s â‰¤ emetric.inf_edist y s + has_edist.edist x y"

- doc_string: "Additive congruence relations preserve negation."
  theorem: "{M : Type u_1} [add_group M] (c : add_con M) {w x : M} : â‡‘c w x â†’ â‡‘c (-w) (-x)"

- doc_string: "Any power of a right-regular element is right-regular."
  theorem: "{R : Type u_1} {a : R} [monoid R] (n : â„•) (rra : is_right_regular a) : is_right_regular (a ^ n)"

- doc_string: "An isometry from an emetric space is injective"
  theorem: "{Î² : Type v} [pseudo_emetric_space Î²] {Î± : Type u} [emetric_space Î±] {f : Î± â†’ Î²} (h : isometry f) : function.injective f"

- doc_string: "In the model space, chart_at is always the identity"
  theorem: "{H : Type u_1} [topological_space H] {x : H} : charted_space.chart_at H x = local_homeomorph.refl H"

- doc_string: "An element admitting a left additive opposite is add-left-regular."
  theorem: "{R : Type u_1} {a b : R} [add_monoid R] (h : b + a = 0) : is_add_left_regular a"

- doc_string: "If `s` has a least element, then it is bounded below."
  theorem: "{Î± : Type u} [preorder Î±] {s : set Î±} {a : Î±} (h : is_least s a) : bdd_below s"

- doc_string: "The canonical perfection map from the perfection of a ring."
  theorem: "(p : â„•) [fact (nat.prime p)] (R : Type uâ‚) [comm_semiring R] [char_p R p] : perfection_map p (perfection.coeff R p 0)"

- doc_string: "A subobject is simple iff it is an atom in the subobject lattice."
  theorem: "{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] {X : C} (Y : category_theory.subobject X) : category_theory.simple â†‘Y â†” is_atom Y"

- doc_string: "A version of `zero_lt_one : 0 < 1` for a `canonically_ordered_comm_semiring`."
  theorem: "{Î± : Type u} [canonically_ordered_comm_semiring Î±] [nontrivial Î±] : 0 < 1"

- doc_string: "**Alias** of the reverse direction of sub_eq_zero`."
  theorem: "{G : Type u_2} [add_group G] {a b : G} : a = b â†’ a - b = 0"

- doc_string: "`sinh` is bijective, both injective and surjective."
  theorem: " : function.bijective real.sinh"

- doc_string: "Euler's Criterion: a nonzero `a : zmod p` is a square if and only if `x ^ (p / 2) = 1`."
  theorem: "(p : â„•) [fact (nat.prime p)] {a : zmod p} (ha : a â‰  0) : is_square a â†” a ^ (p / 2) = 1"

- doc_string: "Adding a point to a set preserves its boundedness above."
  theorem: "{Î³ : Type w} [semilattice_sup Î³] (a : Î³) {s : set Î³} : bdd_above (has_insert.insert a s) â†” bdd_above s"

- doc_string: "**Alias** of neg_one_sq`."
  theorem: "{R : Type uâ‚} [monoid R] [has_distrib_neg R] : (-1) ^ 2 = 1"

- doc_string: "**Alias** of lt_of_le_of_lt'`."
  theorem: "{Î± : Type u} [preorder Î±] {a b c : Î±} : b â‰¤ c â†’ a < b â†’ a < c"

- doc_string: "Any category with pullbacks and terminal object has binary products."
  theorem: "(C : Type u) [category_theory.category C] [category_theory.limits.has_terminal C] [category_theory.limits.has_pullbacks C] : category_theory.limits.has_binary_products C"

- doc_string: "If `s` is bounded, then so is `s âˆ© t`"
  theorem: "{Î± : Type u} [preorder Î±] {s t : set Î±} (h : bdd_above s) : bdd_above (s âˆ© t)"

- doc_string: "Entourages are neighborhoods of the diagonal."
  theorem: "{Î± : Type u_1} [uniform_space Î±] (x : Î±) : nhds (x, x) â‰¤ uniformity Î±"

- doc_string: "`padic_val_int p 1` is 0 for any `p`."
  theorem: "{p : â„•} : padic_val_int p 1 = 0"

- doc_string: " Assumes left covariance. The lemma assuming right covariance is `right.mul_lt_one_of_lt_of_le`."
  theorem: "{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a b : Î±} (ha : a < 1) (hb : b â‰¤ 1) : a * b < 1"

- doc_string: "The directed sUnion of a set S of preconnected subsets is preconnected."
  theorem: "{Î± : Type u} [topological_space Î±] {S : set (set Î±)} (K : directed_on has_subset.subset S) (H : âˆ€ (s : set Î±), s âˆˆ S â†’ is_preconnected s) : is_preconnected (â‹ƒâ‚€S)"

- doc_string: "**Alias** of the reverse direction of order.pred_eq_iff_is_min`."
  theorem: "{Î± : Type u_1} [partial_order Î±] [pred_order Î±] {a : Î±} : is_min a â†’ order.pred a = a"

- doc_string: "Iff version of extensionality rule for additive congruence relations."
  theorem: "{M : Type u_1} [has_add M] {c d : add_con M} : (âˆ€ (x y : M), â‡‘c x y â†” â‡‘d x y) â†” c = d"

- doc_string: " If two words correspond to the same element in the free group, then they have a common maximal reduction. This is the proof that the function that sends an element of the free group to its maximal reduction is well-defined."
  theorem: "{Î± : Type u} {Lâ‚ Lâ‚‚ : list (Î± Ã— bool)} [decidable_eq Î±] (H : free_group.mk Lâ‚ = free_group.mk Lâ‚‚) : free_group.reduce Lâ‚ = free_group.reduce Lâ‚‚"

- doc_string: " The extended psuedodistance on a subset of a pseudoemetric space is the restriction of the original pseudodistance, by definition"
  theorem: "{Î± : Type u} [pseudo_emetric_space Î±] {p : Î± â†’ Prop} (x y : subtype p) : has_edist.edist x y = has_edist.edist â†‘x â†‘y"

- doc_string: "The closure of the interval `(a, b]` is the closed interval `[a, b]`."
  theorem: "{Î± : Type u} [topological_space Î±] [linear_order Î±] [order_topology Î±] [densely_ordered Î±] {a b : Î±} (hab : a â‰  b) : closure (set.Ioc a b) = set.Icc a b"

- doc_string: "Assumes right covariance."
  theorem: "{Î± : Type u} {a b : Î±} [mul_one_class Î±] [has_zero Î±] [preorder Î±] [zero_lt.mul_pos_mono Î±] (ha : 1 â‰¤ a) (hb : 1 < b) (b0 : 0 < b) : 1 < a * b"

- doc_string: "The diameter of a set is always nonnegative"
  theorem: "{Î± : Type u} [pseudo_metric_space Î±] {s : set Î±} : 0 â‰¤ metric.diam s"

- doc_string: "If a subgroup of an additive topological group has `0` in its interior, then it is open."
  theorem: "{G : Type u_1} [add_group G] [topological_space G] [topological_add_group G] {H : add_subgroup G} (h_1_int : 0 âˆˆ interior â†‘H) : is_open â†‘H"

- doc_string: "When multiplication is commutative, `star` preserves division."
  theorem: "{R : Type u} [comm_group R] [star_semigroup R] (x y : R) : has_star.star (x / y) = has_star.star x / has_star.star y"

- doc_string: "The element `0` is `M`-regular when `M` is trivial."
  theorem: "{R : Type u_1} {M : Type u_3} [monoid_with_zero R] [has_zero M] [mul_action_with_zero R M] [sM : subsingleton M] : is_smul_regular M 0"

- doc_string: "The second projection in a product is a trivial topological fiber bundle."
  theorem: "{B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] : is_trivial_topological_fiber_bundle F prod.snd"

- doc_string: "The exponential characteristic is one if the characteristic is zero."
  theorem: "(R : Type u) [semiring R] [nontrivial R] (p : â„•) [hp : char_p R p] [hq : exp_char R 1] : p = 0"

- doc_string: "1 is in the set of natural number powers of an element of a monoid."
  theorem: "{M : Type u_1} [monoid M] {x : M} : 1 âˆˆ powers x"

- doc_string: "**Alias** of le_trans'`."
  theorem: "{Î± : Type u} [preorder Î±] {a b c : Î±} : b â‰¤ c â†’ a â‰¤ b â†’ a â‰¤ c"

- doc_string: "If there are zero morphisms, any initial object is a zero object."
  theorem: "{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_initial C] : category_theory.limits.has_zero_object C"

- doc_string: " If `Ï„` is a `canonically_ordered_add_monoid` (e.g., `â„•` or `â„â‰¥0`), then the notions `is_fw_invariant` and `is_invariant` are equivalent."
  theorem: "{Ï„ : Type u_1} {Î± : Type u_2} [canonically_ordered_add_monoid Ï„] {Ï• : Ï„ â†’ Î± â†’ Î±} {s : set Î±} : is_fw_invariant Ï• s â†” is_invariant Ï• s"

- doc_string: "The Hausdorff edistance of a set to itself vanishes"
  theorem: "{Î± : Type u} [pseudo_emetric_space Î±] {s : set Î±} : emetric.Hausdorff_edist s s = 0"

- doc_string: " Euclid's theorem on the **infinitude of primes**. Here given in the form: for every `n`, there exists a prime number `p â‰¥ n`."
  theorem: "(n : â„•) : âˆƒ (p : â„•), n â‰¤ p âˆ§ nat.prime p"

- doc_string: "Prefer `neg_zero` if `subtraction_monoid` is available."
  theorem: "{Î± : Type u} [mul_zero_class Î±] [has_distrib_neg Î±] : -0 = 0"

- doc_string: "Any element commutes with itself."
  theorem: "{S : Type u_1} [has_add S] (a : S) : add_commute a a"

- doc_string: "The image of a monoid hom is a submonoid of the codomain."
  theorem: "{M : Type u_1} [monoid M] {Î³ : Type u_2} [monoid Î³] {f : M â†’ Î³} (hf : is_monoid_hom f) : is_submonoid (set.range f)"

- doc_string: "**Alias** of the forward direction of le_inv_mul_iff_mul_le`."
  theorem: "{Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b c : Î±} : b â‰¤ -a + c â†’ a + b â‰¤ c"

- doc_string: "The `0` element is not `M`-regular, on a non-trivial module."
  theorem: "{R : Type u_1} {M : Type u_3} [monoid_with_zero R] [has_zero M] [mul_action_with_zero R M] [nM : nontrivial M] : Â¬is_smul_regular M 0"

- doc_string: "If any two objects in an nonempty category are related by `zigzag`, the category is connected."
  theorem: "{J : Type uâ‚} [category_theory.category J] [nonempty J] (h : âˆ€ (jâ‚ jâ‚‚ : J), category_theory.zigzag jâ‚ jâ‚‚) : category_theory.is_connected J"

- doc_string: "The characteristic of a finite ring cannot be zero."
  theorem: "(R : Type u) [non_assoc_ring R] (p : â„•) [hc : char_p R p] [fintype R] : p â‰  0"

- doc_string: "See `int.induction_on'` for an induction in both directions."
  theorem: "{P : â„¤ â†’ Prop} {m : â„¤} (h0 : P m) (h1 : âˆ€ (n : â„¤), n â‰¤ m â†’ P n â†’ P (n - 1)) (n : â„¤) : n â‰¤ m â†’ P n"

- doc_string: "`zpow b` and `int.log b` (almost) form a Galois connection."
  theorem: "{R : Type u_1} [linear_ordered_field R] [floor_ring R] {b : â„•} (hb : 1 < b) {x : â„¤} {r : R} (hr : 0 < r) : r < â†‘b ^ x â†” int.log b r < x"

- doc_string: " Given a Borel-measurable set in a Polish space, there exists a finer Polish topology making it clopen. This is in fact an equivalence, see `is_clopenable_iff_measurable_set`."
  theorem: "{Î± : Type u_1} [topological_space Î±] [polish_space Î±] [measurable_space Î±] [borel_space Î±] {s : set Î±} (hs : measurable_set s) : polish_space.is_clopenable s"

- doc_string: "Contrapositive form of `nat.factorization_central_binom_eq_zero_of_two_mul_lt`"
  theorem: "{p n : â„•} (h_pos : 0 < â‡‘(n.central_binom.factorization) p) : p â‰¤ 2 * n"

- doc_string: "A p-group is nilpotent"
  theorem: "{G : Type u_1} [hG : group G] [hf : fintype G] {p : â„•} [hp : fact (nat.prime p)] (h : is_p_group p G) : group.is_nilpotent G"

- doc_string: "A unit is `M`-regular."
  theorem: "{R : Type u_1} (M : Type u_3) {a : R} [monoid R] [mul_action R M] (ua : is_unit a) : is_smul_regular M a"

- doc_string: "Given a map f from Î± to Î², the natural map from the quotient of Î± by the kernel of f is    injective."
  theorem: "{Î± : Type u_1} {Î² : Type u_2} (f : Î± â†’ Î²) : function.injective (quotient.lift f _)"

- doc_string: "Relation `Î» f g, tendsto (Î» x, (f x, g x)) l (ð“¤ Î±)` is reflexive."
  theorem: "{Î± : Type u_1} {Î² : Type u_2} [uniform_space Î±] (f : Î² â†’ Î±) (l : filter Î²) : filter.tendsto (Î» (x : Î²), (f x, f x)) l (uniformity Î±)"

- doc_string: "If presheaf of `Jâ‚`-closed sieves is a `Jâ‚‚`-sheaf then `Jâ‚ â‰¤ Jâ‚‚`. Note the converse is true by `classifier_is_sheaf` and `is_sheaf_of_le`."
  theorem: "{C : Type u} [category_theory.category C] {Jâ‚ Jâ‚‚ : category_theory.grothendieck_topology C} (h : category_theory.presieve.is_sheaf Jâ‚ (category_theory.functor.closed_sieves Jâ‚‚)) : Jâ‚ â‰¤ Jâ‚‚"

- doc_string: "Cyclotomic polynomials are always nonnegative on inputs one or more."
  theorem: "(n : â„•) {R : Type u_1} [linear_ordered_comm_ring R] {x : R} (hx : 1 â‰¤ x) : 0 â‰¤ polynomial.eval x (polynomial.cyclotomic n R)"

- doc_string: "The edistance to a closed set depends continuously on the point and the set"
  theorem: "{Î± : Type u} [emetric_space Î±] : continuous (Î» (p : Î± Ã— topological_space.closeds Î±), emetric.inf_edist p.fst â†‘(p.snd))"

- doc_string: "A list with product less than one must have positive length."
  theorem: "{M : Type u_3} [monoid M] [preorder M] (L : list M) (h : L.prod < 1) : 0 < L.length"

- doc_string: "The union of two GÎ´ sets is a GÎ´ set."
  theorem: "{Î± : Type u_1} [topological_space Î±] {s t : set Î±} (hs : is_GÎ´ s) (ht : is_GÎ´ t) : is_GÎ´ (s âˆª t)"

- doc_string: "Harmonic series is not unconditionally summable."
  theorem: " : Â¬summable (Î» (n : â„•), 1 / â†‘n)"

- doc_string: "**Alias** of eq_or_gt_of_le`."
  theorem: "{Î± : Type u} [partial_order Î±] {a b : Î±} (h : a â‰¤ b) : b = a âˆ¨ a < b"

- doc_string: "A subset of `â„•` containing zero and closed under `nat.succ` contains all of `â„•`."
  theorem: "{S : set â„•} (hb : 0 âˆˆ S) (h_ind : âˆ€ (k : â„•), k âˆˆ S â†’ k + 1 âˆˆ S) (n : â„•) : n âˆˆ S"

- doc_string: "**Alias** of the reverse direction of inv_mul_le_iff_le_mul`."
  theorem: "{Î± : Type u} [group Î±] [has_le Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a b c : Î±} : a â‰¤ b * c â†’ bâ»Â¹ * a â‰¤ c"

- doc_string: "Characteristic `â‰  2` in a domain implies that `-a = a` iff `a = 0`."
  theorem: "{R : Type u_1} [non_assoc_ring R] [nontrivial R] [no_zero_divisors R] (hR : ring_char R â‰  2) {a : R} : -a = a â†” a = 0"

- doc_string: "The quadratic character takes the value `1` on nonzero squares."
  theorem: "{F : Type u_1} [field F] [fintype F] [decidable_eq F] {a : F} (ha : a â‰  0) : char.quadratic_char F (a ^ 2) = 1"

- doc_string: "The edist to a set depends continuously on the point"
  theorem: "{Î± : Type u} [pseudo_emetric_space Î±] {s : set Î±} : continuous (Î» (x : Î±), emetric.inf_edist x s)"

- doc_string: "**Alias** of the forward direction of mul_sub_mul_div_mul_nonpos_iff`."
  theorem: "{Î± : Type u_1} [linear_ordered_field Î±] {a b c d : Î±} (hc : c â‰  0) (hd : d â‰  0) : (a * d - b * c) / (c * d) â‰¤ 0 â†’ a / c â‰¤ b / d"

- doc_string: "the coercion `opens Î± â†’ set Î±` applied to a pair is the same as taking the first component"
  theorem: "{Î± : Type u_1} [topological_space Î±] {U : set Î±} {hU : is_open U} : â†‘âŸ¨U, hUâŸ© = U"

- doc_string: " Converting the value of a `fin (n + 1)` to `fin (n + 1)` results in the same value."
  theorem: "{n : â„•} (a : fin (n + 1)) : â†‘(a.val) = a"

- doc_string: "The projection on the base of a topological bundle created from core is an open map"
  theorem: "{Î¹ : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core Î¹ B F) : is_open_map Z.proj"

- doc_string: "An element of `R` is algebraic, when viewed as an element of the `R`-algebra `A`."
  theorem: "{R : Type u} {A : Type v} [comm_ring R] [ring A] [algebra R A] [nontrivial R] (x : R) : is_algebraic R (â‡‘(algebra_map R A) x)"

- doc_string: " Assumes left covariance. The lemma assuming right covariance is `right.one_lt_mul`."
  theorem: "{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a b : Î±} (ha : 1 < a) (hb : 1 < b) : 1 < a * b"

- doc_string: "Composing two additions on the left by `y` then `x` is equal to a addition on the left by `x + y`."
  theorem: "{Î± : Type u_1} [add_semigroup Î±] (x y : Î±) : has_add.add x âˆ˜ has_add.add y = has_add.add (x + y)"

- doc_string: "A subset of `â„•` containing `b : â„•` and closed under `nat.succ` contains every `n â‰¥ b`."
  theorem: "{b : â„•} {S : set â„•} (hb : b âˆˆ S) (h_ind : âˆ€ (k : â„•), k âˆˆ S â†’ k + 1 âˆˆ S) {n : â„•} (hbn : b â‰¤ n) : n âˆˆ S"

- doc_string: "**Alias** of the reverse direction of szemeredi_regularity.step_bound_pos_iff`."
  theorem: "{n : â„•} : 0 < n â†’ 0 < szemeredi_regularity.step_bound n"

- doc_string: "An element of an `add_monoid` is in the set of that element's natural number multiples."
  theorem: "{M : Type u_1} [add_monoid M] {x : M} : x âˆˆ multiples x"

- doc_string: "`complex.abs (complex.exp z) â†’ âˆž` as `complex.re z â†’ âˆž`. TODO: use `bornology.cobounded`."
  theorem: " : filter.tendsto complex.exp (filter.comap complex.re filter.at_top) (filter.comap complex.abs filter.at_top)"

- doc_string: "The map `coe_fn : (r â†ªr s) â†’ (Î± â†’ Î²)` is injective."
  theorem: "{Î± : Type u_1} {Î² : Type u_2} {r : Î± â†’ Î± â†’ Prop} {s : Î² â†’ Î² â†’ Prop} : function.injective coe_fn"

- doc_string: "Any category with finite coproducts and coequalizers has all finite colimits.  See <https://stacks.math.columbia.edu/tag/002Q>."
  theorem: "{C : Type u} [category_theory.category C] [category_theory.limits.has_finite_coproducts C] [category_theory.limits.has_coequalizers C] : category_theory.limits.has_finite_colimits C"

- doc_string: "A group element has finite additive order iff its order is positive."
  theorem: "{G : Type u} {x : G} [add_monoid G] : 0 < add_order_of x â†” is_of_fin_add_order x"

- doc_string: "This is not a simp lemma, since we usually want simp to keep `star_ring_end` bundled. For example, for complex conjugation, we don't want simp to turn `conj x` into the bare function `star x` automatically since most lemmas are about `conj x`."
  theorem: "{R : Type u} [comm_semiring R] [star_ring R] {x : R} : â‡‘(star_ring_end R) x = has_star.star x"

- doc_string: "Conjugation is jointly continuous on `G Ã— G` when both `mul` and `inv` are continuous."
  theorem: "{G : Type w} [topological_space G] [has_inv G] [has_mul G] [has_continuous_mul G] [has_continuous_inv G] : continuous (Î» (g : G Ã— G), g.fst * g.snd * (g.fst)â»Â¹)"

- doc_string: "Constant zero function has sum `0`"
  theorem: "{Î± : Type u_1} {Î² : Type u_2} [add_comm_monoid Î±] [topological_space Î±] : has_sum (Î» (b : Î²), 0) 0"

- doc_string: "Given a closed embedding into a Polish space, the source space is also Polish."
  theorem: "{Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] [polish_space Î²] {f : Î± â†’ Î²} (hf : closed_embedding f) : polish_space Î±"

- doc_string: " The `cons` and `head`/`tail` functions are mutually inverse, unlike in the case of `list` where this only holds for nonempty lists."
  theorem: "{Î“ : Type u_1} [inhabited Î“] (l : turing.list_blank Î“) : âˆƒ (a : Î“) (l' : turing.list_blank Î“), l = turing.list_blank.cons a l'"

- doc_string: "Show that an element extracted from `P : âˆƒ a, p a` using `P.some` satisfies `p`."
  theorem: "{Î± : Sort u_1} {p : Î± â†’ Prop} (P : âˆƒ (a : Î±), p a) : p P.some"

- doc_string: "Compressing an element is idempotent."
  theorem: "{Î± : Type u_1} [generalized_boolean_algebra Î±] [decidable_rel disjoint] [decidable_rel has_le.le] (u v a : Î±) : uv.compress u v (uv.compress u v a) = uv.compress u v a"

- doc_string: " If a reflexive relation `r : Î± â†’ Î± â†’ Prop` holds over `x y : Î±`, then it holds whether or not `x â‰  y`."
  theorem: "{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} (h : reflexive r) {x y : Î±} : x â‰  y â†’ r x y â†” r x y"

- doc_string: "The upper central series of a group is an ascending central series."
  theorem: "(G : Type u_1) [group G] : is_ascending_central_series (upper_central_series G)"

- doc_string: "A prime `p` satisfies `p % 2 = 1` if and only if `p â‰  2`."
  theorem: "{p : â„•} [fact (nat.prime p)] : p % 2 = 1 â†” p â‰  2"

- doc_string: " The elements of the Hilbert basis `fourier_series` for `Lp â„‚ 2 haar_circle` are the functions `fourier_Lp 2`, the monomials `Î» z, z ^ n` on the circle considered as elements of `L2`."
  theorem: " : â‡‘fourier_series = fourier_Lp 2"

- doc_string: "Composing a `list.map` with another `list.map` is equal to a single `list.map` of composed functions."
  theorem: "{Î± : Type u} {Î² : Type v} {Î³ : Type w} (g : Î² â†’ Î³) (f : Î± â†’ Î²) : list.map g âˆ˜ list.map f = list.map (g âˆ˜ f)"

- doc_string: "In a non-trivial `mul_zero_class`, the `0` element is not right-regular."
  theorem: "{R : Type u_1} [mul_zero_class R] : Â¬is_right_regular 0 â†” nontrivial R"

- doc_string: "The minimal distance to a set is bounded by the distance to any point in this set"
  theorem: "{Î± : Type u} [pseudo_metric_space Î±] {s : set Î±} {x y : Î±} (h : y âˆˆ s) : metric.inf_dist x s â‰¤ has_dist.dist x y"

- doc_string: "A `finset` for an empty type is empty."
  theorem: "{Î± : Type u_1} [is_empty Î±] (s : finset Î±) : s = âˆ…"

- doc_string: "An open subgroup of a nonarchimedean ring contains the square of another one."
  theorem: "{R : Type u_1} [ring R] [topological_space R] [nonarchimedean_ring R] (U : open_add_subgroup R) : âˆƒ (V : open_add_subgroup R), â†‘V * â†‘V âŠ† â†‘U"

- doc_string: "**Alias** of the reverse direction of is_top_to_dual_iff`."
  theorem: "{Î± : Type u_1} [has_le Î±] {a : Î±} : is_bot a â†’ is_top (â‡‘order_dual.to_dual a)"

- doc_string: "If `s` has a least upper bound, then it is bounded above."
  theorem: "{Î± : Type u} [preorder Î±] {s : set Î±} {a : Î±} (h : is_lub s a) : bdd_above s"

- doc_string: "As a map from the left argument to a unary function, `f` is injective."
  theorem: "{Î± : Sort u_1} {Î² : Sort u_2} {Î³ : Sort u_3} {f : Î± â†’ Î² â†’ Î³} (hf : function.injective2 f) [nonempty Î²] : function.injective f"

- doc_string: "An unordered closed interval is compact."
  theorem: "{Î± : Type u_1} [linear_order Î±] [topological_space Î±] [compact_Icc_space Î±] {a b : Î±} : is_compact (set.interval a b)"

- doc_string: "Definition of `â‰¤` for congruence relations."
  theorem: "{M : Type u_1} [has_mul M] {c d : con M} : c â‰¤ d â†” âˆ€ {x y : M}, â‡‘c x y â†’ â‡‘d x y"

- doc_string: "The main characterization theorem for additive principal ordinals."
  theorem: "{o : ordinal} : ordinal.principal has_add.add o â†” o = 0 âˆ¨ âˆƒ (a : ordinal), o = ordinal.omega ^ a"

- doc_string: "Embedding `i : fin n` into `fin (n + 1)` is always about some hole `p`."
  theorem: "{n : â„•} (p : fin (n + 1)) (i : fin n) : â‡‘fin.cast_succ i < p âˆ¨ p < i.succ"

- doc_string: "Shows that the fractional parts of the stream are smaller than one."
  theorem: "{K : Type u_1} {v : K} {n : â„•} [linear_ordered_field K] [floor_ring K] {ifp_n : generalized_continued_fraction.int_fract_pair K} (nth_stream_eq : generalized_continued_fraction.int_fract_pair.stream v n = option.some ifp_n) : ifp_n.fr < 1"

- doc_string: "Note that most of the lemmas about powers of two refer to it as `sq`."
  theorem: "{M : Type u} [monoid M] (a : M) : a ^ 2 = a * a"

- doc_string: " In the characteristic zero case, the weights in the centroid sum to 1 if the number of points is not zero."
  theorem: "(k : Type u_1) [division_ring k] {Î¹ : Type u_4} (s : finset Î¹) [char_zero k] (h : s.card â‰  0) : s.sum (Î» (i : Î¹), finset.centroid_weights k s i) = 1"

- doc_string: " A prime that does not divide the cardinality of a finite commutative ring `R` is a unit in `R`."
  theorem: "{R : Type u_1} [comm_ring R] [fintype R] (p : â„•) [fact (nat.prime p)] (hp : p âˆ£ fintype.card R) : Â¬is_unit â†‘p"

- doc_string: "**Alias** of left.inv_le_one_iff`."
  theorem: "{Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± has_add.add has_le.le] {a : Î±} : -a â‰¤ 0 â†” 0 â‰¤ a"

- doc_string: "If the factorization of `n` contains just one number `p` then `n` is a power of `p`"
  theorem: "{n p k : â„•} (hn : n â‰  0) (h : n.factorization = finsupp.single p k) : n = p ^ k"

- doc_string: "A semiring homomorphism is an additive monoid homomorphism."
  theorem: "{Î± : Type u} {Î² : Type v} [semiring Î±] [semiring Î²] {f : Î± â†’ Î²} (hf : is_semiring_hom f) : is_add_monoid_hom f"

- doc_string: "The edist is antitone with respect to inclusion."
  theorem: "{Î± : Type u} [pseudo_emetric_space Î±] {x : Î±} {s t : set Î±} (h : s âŠ† t) : emetric.inf_edist x t â‰¤ emetric.inf_edist x s"

- doc_string: "**Alias** of the reverse direction of finset.Icc_eq_empty_iff`."
  theorem: "{Î± : Type u_1} [preorder Î±] [locally_finite_order Î±] {a b : Î±} : Â¬a â‰¤ b â†’ finset.Icc a b = âˆ…"

- doc_string: "less-than is well-founded"
  theorem: " : well_founded nat.lt"

- doc_string: "A list with sum not zero must have positive length."
  theorem: "{M : Type u_3} [add_monoid M] (L : list M) (h : L.sum â‰  0) : 0 < L.length"

- doc_string: "**Alias** of left.one_lt_mul`."
  theorem: "{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a b : Î±} (ha : 1 < a) (hb : 1 < b) : 1 < a * b"

- doc_string: "The (pre)image under `inv` of `Ioo 0 a` is `Ioi aâ»Â¹`."
  theorem: "{k : Type u} [linear_ordered_field k] {a : k} (ha : 0 < a) : (set.Ioo 0 a)â»Â¹ = set.Ioi aâ»Â¹"

- doc_string: "Duplicate of `eq.subset'`, which currently has elaboration problems."
  theorem: "{Î± : Type u_1} {s t : set Î±} : s = t â†’ s âŠ† t"

- doc_string: "Characterize the equality of points by the vanishing of their extended distance"
  theorem: "{Î³ : Type w} [emetric_space Î³] {x y : Î³} : has_edist.edist x y = 0 â†” x = y"

- doc_string: "This is a special case of `tsub_zero`, which should be used instead of this.  This is needed to prove `has_ordered_sub (multiset Î±)`."
  theorem: "{Î± : Type u_1} [decidable_eq Î±] (s : multiset Î±) : s - 0 = s"

- doc_string: "Transferring from field to is_field"
  theorem: "(R : Type u) [field R] : is_field R"

- doc_string: "Additive congruence relations are symmetric."
  theorem: "{M : Type u_1} [has_add M] (c : add_con M) {x y : M} : â‡‘c x y â†’ â‡‘c y x"

- doc_string: "The nonsingular inverse is the same as the general `ring.inverse`."
  theorem: "{n : Type u'} {Î± : Type v} [fintype n] [decidable_eq n] [comm_ring Î±] (A : matrix n n Î±) : Aâ»Â¹ = ring.inverse A"

- doc_string: " Every element is less than its closure. This property is sometimes referred to as extensivity or inflationarity."
  theorem: "{Î± : Type u_1} {Î² : Type u_4} [preorder Î±] [preorder Î²] {u : Î² â†’ Î±} (l : lower_adjoint u) (x : Î±) : x â‰¤ u (â‡‘l x)"

- doc_string: "By definition, if `x` is not invertible then `inverse x = 0`."
  theorem: "{Mâ‚€ : Type u_1} [monoid_with_zero Mâ‚€] (x : Mâ‚€) (h : Â¬is_unit x) : ring.inverse x = 0"

- doc_string: "A family with at most one point is convex independent."
  theorem: "{ð•œ : Type u_1} {E : Type u_2} {Î¹ : Type u_3} [ordered_semiring ð•œ] [add_comm_group E] [module ð•œ E] [subsingleton Î¹] (p : Î¹ â†’ E) : convex_independent ð•œ p"

- doc_string: "**Alias** of the reverse direction of is_square_iff_exists_sq`."
  theorem: "{Î± : Type u_2} [monoid Î±] (m : Î±) : (âˆƒ (c : Î±), m = c ^ 2) â†’ is_square m"

- doc_string: "In a preadditive category, if the coproduct over `f : J â†’ C` exists,    then the biproduct over `f` exists."
  theorem: "{C : Type u} [category_theory.category C] [category_theory.preadditive C] {J : Type v} [fintype J] (f : J â†’ C) [category_theory.limits.has_coproduct f] : category_theory.limits.has_biproduct f"

- doc_string: "The opposite of the golden ratio is the inverse of its conjugate."
  theorem: " : golden_conjâ»Â¹ = -golden_ratio"

- doc_string: " If `Î±` is a preorder with no maximal elements, then there exists a strictly antitone function `â„• â†’ Î±` with any prescribed value of `f 0`."
  theorem: "{Î± : Type u} [preorder Î±] [no_min_order Î±] (a : Î±) : âˆƒ (f : â„• â†’ Î±), strict_anti f âˆ§ f 0 = a"

- doc_string: "**Alias** of left.one_lt_inv_iff`."
  theorem: "{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a : Î±} : 0 < -a â†” a < 0"

- doc_string: "If `A` is subterminal, the unique morphism from it to a terminal object is a monomorphism. The converse of `is_subterminal_of_mono_is_terminal_from`."
  theorem: "{C : Type uâ‚} [category_theory.category C] {A : C} (hA : category_theory.is_subterminal A) {T : C} (hT : category_theory.limits.is_terminal T) : category_theory.mono (hT.from A)"

- doc_string: "If an element `b` becomes add-right-regular after adding to it on the right a add-right-regular element, then `b` is add-right-regular."
  theorem: "{R : Type u_1} {a b : R} [add_semigroup R] (ab : is_add_right_regular (b + a)) : is_add_right_regular b"

- doc_string: "The inclusion of a fiber into the total space is a continuous map."
  theorem: "{Î¹ : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core Î¹ B F) (b : B) : continuous (bundle.total_space_mk b)"

- doc_string: " If `Î±` is a nonempty preorder with no minimal or maximal elements, then there exists a strictly monotone function `f : â„¤ â†’ Î±`."
  theorem: "(Î± : Type u) [preorder Î±] [nonempty Î±] [no_min_order Î±] [no_max_order Î±] : âˆƒ (f : â„¤ â†’ Î±), strict_mono f"

- doc_string: "Given `f : Î± â†’ Î²`, if `Î±` is nonempty then `Î²` is also nonempty.  `nonempty` cannot be a `functor`, because `functor` is restricted to `Type`."
  theorem: "{Î± : Sort u_1} {Î² : Sort u_2} (f : Î± â†’ Î²) : nonempty Î± â†’ nonempty Î²"

- doc_string: "an n-digit number in base b is less than b^n if b â‰¥ 2"
  theorem: "{b : â„•} {l : list â„•} (hb : 2 â‰¤ b) (hl : âˆ€ (x : â„•), x âˆˆ l â†’ x < b) : nat.of_digits b l < b ^ l.length"

- doc_string: "`a` semiconjugates `x` to `a + x + -a`."
  theorem: "{G : Type u} [add_group G] (a x : G) : add_semiconj_by a x (a + x + -a)"

- doc_string: " The map `coe_fn : (r â‰ƒr s) â†’ (Î± â†’ Î²)` is injective. Lean fails to parse `function.injective (Î» e : r â‰ƒr s, (e : Î± â†’ Î²))`, so we use a trick to say the same."
  theorem: "{Î± : Type u_1} {Î² : Type u_2} {r : Î± â†’ Î± â†’ Prop} {s : Î² â†’ Î² â†’ Prop} : function.injective coe_fn"

- doc_string: "A locally compact Hausdorff space is totally disconnected  if and only if it is totally separated."
  theorem: "{H : Type u_1} [topological_space H] [locally_compact_space H] [t2_space H] : totally_disconnected_space H â†” totally_separated_space H"

- doc_string: " `x` is the only fixed point of `point_reflection x`. This lemma requires `x + x = y + y â†” x = y`. There is no typeclass to use here, so we add it as an explicit argument."
  theorem: "{G : Type u_1} {P : Type u_2} [add_group G] [add_torsor G P] {x y : P} (h : function.injective bit0) : â‡‘(equiv.point_reflection x) y = y â†” y = x"

- doc_string: "An extensionality lemma in terms of the coercion to a pi-type. We prove this explicitly rather than deriving it so that it is in terms of the coercion rather than the projection `.sieves`."
  theorem: "{C : Type u} [category_theory.category C] {Jâ‚ Jâ‚‚ : category_theory.grothendieck_topology C} (h : â‡‘Jâ‚ = â‡‘Jâ‚‚) : Jâ‚ = Jâ‚‚"

- doc_string: "A ring homomorphism is also a semiring homomorphism."
  theorem: "{Î± : Type u} {Î² : Type v} [ring Î±] [ring Î²] {f : Î± â†’ Î²} (hf : is_ring_hom f) : is_semiring_hom f"

- doc_string: " The metric space uniform structure on â„š (which presupposes the existence of real numbers) agrees with the one coming directly from (abs : â„š â†’ â„š)."
  theorem: " : is_absolute_value.uniform_space has_abs.abs = pseudo_metric_space.to_uniform_space"

- doc_string: "`ordinal.induction` but for `nat_ordinal`."
  theorem: "{p : nat_ordinal â†’ Prop} (i : nat_ordinal) (h : âˆ€ (j : nat_ordinal), (âˆ€ (k : nat_ordinal), k < j â†’ p k) â†’ p j) : p i"

- doc_string: "Brahmagupta-Fibonacci identity or Diophantus identity, see <https://en.wikipedia.org/wiki/Brahmagupta%E2%80%93Fibonacci_identity>.  This sign choice here corresponds to the signs obtained by multiplying two complex numbers."
  theorem: "{R : Type u_1} [comm_ring R] {xâ‚ xâ‚‚ yâ‚ yâ‚‚ : R} : (xâ‚ ^ 2 + xâ‚‚ ^ 2) * (yâ‚ ^ 2 + yâ‚‚ ^ 2) = (xâ‚ * yâ‚ - xâ‚‚ * yâ‚‚) ^ 2 + (xâ‚ * yâ‚‚ + xâ‚‚ * yâ‚) ^ 2"

- doc_string: " An interval of length `a` filtered over a periodic predicate of period `a` has cardinality equal to the number naturals below `a` for which `p a` is true."
  theorem: "(n a : â„•) (p : â„• â†’ Prop) [decidable_pred p] (pp : function.periodic p a) : â‡‘multiset.card (multiset.filter p (multiset.Ico n (n + a))) = nat.count p a"

- doc_string: "Composing two multiplications on the right by `y` and `x` is equal to a multiplication on the right by `y * x`."
  theorem: "{Î± : Type u_1} [semigroup Î±] (x y : Î±) : ((Î» (_x : Î±), _x * x) âˆ˜ Î» (_x : Î±), _x * y) = Î» (_x : Î±), _x * (y * x)"

- doc_string: "A finite dimensional space that is a subsingleton has zero `finrank`."
  theorem: "{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [h : subsingleton V] : finite_dimensional.finrank K V = 0"

- doc_string: "The `nat.partrec.code.evaln` function is primitive recursive."
  theorem: " : primrec (Î» (a : (â„• Ã— nat.partrec.code) Ã— â„•), nat.partrec.code.evaln a.fst.fst a.fst.snd a.snd)"

- doc_string: " Coercing a `special_linear_group` via `GL_pos` and `GL` is the same as coercing striaght to a matrix."
  theorem: "{n : Type u} [decidable_eq n] [fintype n] {R : Type v} [linear_ordered_comm_ring R] (g : matrix.special_linear_group n R) : â†‘â†‘â†‘g = â†‘g"

- doc_string: "Assumes right covariance. The lemma assuming left covariance is `left.add_pos'`."
  theorem: "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±} (ha : 0 < a) (hb : 0 < b) : 0 < a + b"

- doc_string: "**Alias** of the reverse direction of list.pw_filter_eq_self`."
  theorem: "{Î± : Type u_1} {R : Î± â†’ Î± â†’ Prop} [decidable_rel R] {l : list Î±} : list.pairwise R l â†’ list.pw_filter R l = l"

- doc_string: "The sequence `A âŸ¶ A âŠž B âŸ¶ B` is exact."
  theorem: "{ð’œ : Type u_1} [category_theory.category ð’œ] [category_theory.preadditive ð’œ] [category_theory.limits.has_kernels ð’œ] [category_theory.limits.has_images ð’œ] [category_theory.limits.has_binary_biproducts ð’œ] (A B : ð’œ) : category_theory.exact category_theory.limits.biprod.inl category_theory.limits.biprod.snd"

- doc_string: "The upper shadow is monotone."
  theorem: "{Î± : Type u_1} [decidable_eq Î±] [fintype Î±] : monotone finset.up_shadow"

- doc_string: "The additive inverse of one multiplied by an element of a ring is the element's additive  inverse."
  theorem: "{Î± : Type u} [mul_one_class Î±] [has_distrib_neg Î±] (a : Î±) : (-1) * a = -a"

- doc_string: "Given an element `a` of a commutative semigroup with zero, there exists another element whose    product with zero equals `a` iff `a` equals zero."
  theorem: "{Î± : Type u_1} [semigroup_with_zero Î±] {a : Î±} : 0 âˆ£ a â†” a = 0"

- doc_string: "The range of a strongly measurable function is separable."
  theorem: "{Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} {m : measurable_space Î±} [topological_space Î²] (hf : measure_theory.strongly_measurable f) : topological_space.is_separable (set.range f)"

- doc_string: "**Alias** of the reverse direction of strict_anti_on_to_dual_comp_iff`."
  theorem: "{Î± : Type u} {Î² : Type v} [preorder Î±] [preorder Î²] {f : Î± â†’ Î²} {s : set Î±} : strict_mono_on f s â†’ strict_anti_on (â‡‘order_dual.to_dual âˆ˜ f) s"

- doc_string: "**Alias** of lt_mul_of_inv_mul_lt`."
  theorem: "{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b c : Î±} : -b + a < c â†’ a < b + c"

- doc_string: "Assumes right covariance."
  theorem: "{Î± : Type u} {a b : Î±} [mul_zero_class Î±] [partial_order Î±] [zero_lt.mul_pos_mono Î±] (ha : 0 â‰¤ a) (hb : 0 â‰¤ b) : 0 â‰¤ a * b"

- doc_string: "**Alias** of not_btw_of_sbtw`."
  theorem: "{Î± : Type u_1} [circular_preorder Î±] {a b c : Î±} (h : has_sbtw.sbtw a b c) : Â¬has_btw.btw c b a"

- doc_string: "**Alias** of le_of_mul_le_mul_left'`."
  theorem: "{Î± : Type u_1} [has_add Î±] [has_le Î±] [contravariant_class Î± Î± has_add.add has_le.le] {a b c : Î±} (bc : a + b â‰¤ a + c) : b â‰¤ c"

- doc_string: " A word and its maximal reduction correspond to the same element of the free group."
  theorem: "{Î± : Type u} {L : list (Î± Ã— bool)} [decidable_eq Î±] : free_group.mk (free_group.reduce L) = free_group.mk L"

- doc_string: "A set is sequentially closed if it is closed."
  theorem: "{X : Type u_1} [topological_space X] {s : set X} (hs : is_closed s) : is_seq_closed s"

- doc_string: "This is `algebra.norm_eq_zero_iff` composed with `algebra.norm_apply`."
  theorem: "{K : Type u_4} {L : Type u_5} [field K] [field L] [algebra K L] [finite_dimensional K L] {x : L} : â‡‘linear_map.det (â‡‘(algebra.lmul K L) x) = 0 â†” x = 0"

- doc_string: "`padic_val_nat p 1` is 0 for any `p`."
  theorem: "{p : â„•} : padic_val_nat p 1 = 0"

- doc_string: "A version of `x.property` or `x.2` where `p` is syntactically applied to the coercion of `x`  instead of `x.1`. A similar result is `subtype.mem` in `data.set.basic`."
  theorem: "{Î± : Sort u_1} {p : Î± â†’ Prop} (x : subtype p) : p â†‘x"

- doc_string: " For any subset `s` of `Î±`, the restriction of continuous functions to `s` is continuous as a function from `C(Î±, Î²)` to `C(s, Î²)` with their respective compact-open topologies."
  theorem: "{Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] (s : set Î±) : continuous (Î» (F : C(Î±, Î²)), continuous_map.restrict s F)"

- doc_string: "Tell `simp` what the entries are in a transposed matrix.  Compare with `mul_apply`, `diagonal_apply_eq`, etc."
  theorem: "{m : Type u_2} {n : Type u_3} {Î± : Type v} (M : matrix m n Î±) (i : m) (j : n) : M.transpose j i = M i j"

- doc_string: "Conjugation by a fixed element is continuous when `add` is continuous."
  theorem: "{G : Type w} [topological_space G] [has_neg G] [has_add G] [has_continuous_add G] (g : G) : continuous (Î» (h : G), g + h + -g)"

- doc_string: "The product of the constant function `1` over any set equals `1`."
  theorem: "{Î± : Type u_1} {M : Type u_5} [comm_monoid M] (s : set Î±) : finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), 1)) = 1"

- doc_string: "0 is in the set of natural number multiples of an element of an `add_monoid`."
  theorem: "{M : Type u_1} [add_monoid M] {x : M} : 0 âˆˆ multiples x"

- doc_string: "Composing two multiplications on the left by `y` then `x` is equal to a multiplication on the left by `x * y`."
  theorem: "{Î± : Type u_1} [semigroup Î±] (x y : Î±) : has_mul.mul x âˆ˜ has_mul.mul y = has_mul.mul (x * y)"

- doc_string: " Dividing `a` by the result of dividing `a` by itself results in `a` (whether or not `a` is zero)."
  theorem: "{Gâ‚€ : Type u_2} [group_with_zero Gâ‚€] (a : Gâ‚€) : a / (a / a) = a"

- doc_string: " A closed embedding is proper, ie, inverse images of compact sets are contained in compacts. Moreover, the preimage of a compact set is compact, see `closed_embedding.is_compact_preimage`."
  theorem: "{Î± : Type u} {Î² : Type v} [topological_space Î±] [topological_space Î²] {f : Î± â†’ Î²} (hf : closed_embedding f) : filter.tendsto f (filter.cocompact Î±) (filter.cocompact Î²)"

- doc_string: "Rectangles of countably spanning sets are countably spanning."
  theorem: "{Î± : Type u_1} {Î² : Type u_3} {C : set (set Î±)} {D : set (set Î²)} (hC : is_countably_spanning C) (hD : is_countably_spanning D) : is_countably_spanning (set.image2 has_set_prod.prod C D)"

- doc_string: "In a finite field of odd characteristic, not every element is a square."
  theorem: "{F : Type u_3} [field F] [fintype F] (hF : ring_char F â‰  2) : âˆƒ (a : F), Â¬is_square a"

- doc_string: "**Alias** of the reverse direction of is_extr_on_dual_iff`."
  theorem: "{Î± : Type u} {Î² : Type v} [preorder Î²] {f : Î± â†’ Î²} {s : set Î±} {a : Î±} : is_extr_on f s a â†’ is_extr_on (â‡‘order_dual.to_dual âˆ˜ f) s a"

- doc_string: "A version of `measurable_div_const` that assumes `has_measurable_mul` instead of  `has_measurable_div`. This can be nice to avoid unnecessary type-class assumptions."
  theorem: "{G : Type u_1} [div_inv_monoid G] [measurable_space G] [has_measurable_mul G] (g : G) : measurable (Î» (h : G), h / g)"

- doc_string: "The diameter of the empty set vanishes"
  theorem: "{Î± : Type u} [pseudo_emetric_space Î±] : emetric.diam âˆ… = 0"

- doc_string: "The map `coe_fn : (r â†’r s) â†’ (Î± â†’ Î²)` is injective."
  theorem: "{Î± : Type u_1} {Î² : Type u_2} {r : Î± â†’ Î± â†’ Prop} {s : Î² â†’ Î² â†’ Prop} : function.injective coe_fn"

- doc_string: "The identity map preserves addition"
  theorem: "{Î± : Type u} [has_add Î±] : is_add_hom id"

- doc_string: "A helper lemma: the characteristic is prime if it is non-zero."
  theorem: "(R : Type u) [semiring R] [nontrivial R] [no_zero_divisors R] {p : â„•} [hp : char_p R p] (p_ne_zero : p â‰  0) : nat.prime p"

- doc_string: "**Alias** of dvd_trans`."
  theorem: "{Î± : Type u_1} [semigroup Î±] {a b c : Î±} : a âˆ£ b â†’ b âˆ£ c â†’ a âˆ£ c"

- doc_string: "`polynomial R` is never a field for any ring `R`."
  theorem: "{R : Type u} [ring R] : Â¬is_field (polynomial R)"

- doc_string: "The list `list.insertion_sort r l` is `list.sorted` with respect to `r`."
  theorem: "{Î± : Type uu} (r : Î± â†’ Î± â†’ Prop) [decidable_rel r] [is_total Î± r] [is_trans Î± r] (l : list Î±) : list.sorted r (list.insertion_sort r l)"

- doc_string: " Any two maps `f : Î± â†’ Î²` and `g : Î² â†’ Î±` are inverse of each other on the sets of fixed points of `f âˆ˜ g` and `g âˆ˜ f`, respectively."
  theorem: "{Î± : Type u} {Î² : Type v} (f : Î± â†’ Î²) (g : Î² â†’ Î±) : set.inv_on f g (function.fixed_points (f âˆ˜ g)) (function.fixed_points (g âˆ˜ f))"

- doc_string: "If `a % b = c` then `b` divides `a - c`."
  theorem: "{a b c : â„¤} (h : a % b = c) : b âˆ£ a - c"

- doc_string: "A localization always has cardinality less than or equal to the base ring."
  theorem: "{R : Type u} [comm_ring R] (S : submonoid R) {L : Type u} [comm_ring L] [algebra R L] [is_localization S L] : cardinal.mk L â‰¤ cardinal.mk R"

- doc_string: " Two compositions (possibly of different integers) coincide if and only if they have the same sequence of blocks."
  theorem: "{c c' : Î£ (n : â„•), composition n} : c = c' â†” c.snd.blocks = c'.snd.blocks"

- doc_string: "**Alias** of nat.coe_nat_dvd`."
  theorem: "{Î± : Type u_1} [semiring Î±] {m n : â„•} (h : m âˆ£ n) : â†‘m âˆ£ â†‘n"

- doc_string: "Any family is compressed along two identical elements."
  theorem: "{Î± : Type u_1} [generalized_boolean_algebra Î±] [decidable_rel disjoint] [decidable_rel has_le.le] (u : Î±) (s : finset Î±) : uv.is_compressed u u s"

- doc_string: "Subsets of a bounded set are also bounded"
  theorem: "{Î± : Type u} [pseudo_metric_space Î±] {s t : set Î±} (incl : s âŠ† t) : metric.bounded t â†’ metric.bounded s"

- doc_string: "Inverses of elements of finite additive order have finite additive order."
  theorem: "{G : Type u} [add_group G] {x : G} (hx : is_of_fin_add_order x) : is_of_fin_add_order (-x)"

- doc_string: "A prime natural number is prime in `â„¤[i]` if and only if it is `3` mod `4`"
  theorem: "(p : â„•) [hp : fact (nat.prime p)] : prime â†‘p â†” p % 4 = 3"

- doc_string: " A prime `p` is a unit in a finite commutative ring `R` iff it does not divide the characteristic."
  theorem: "(R : Type u_1) [comm_ring R] [fintype R] (p : â„•) [fact (nat.prime p)] : is_unit â†‘p â†” Â¬p âˆ£ ring_char R"

- doc_string: "**Alias** of the forward direction of dense_closure`."
  theorem: "{Î± : Type u} [topological_space Î±] {s : set Î±} : dense (closure s) â†’ dense s"

- doc_string: " If a composition of a function `f` followed by an injection `g` is locally constant, then the locally constant property descends to `f`."
  theorem: "{X : Type u_1} [topological_space X] {Î± : Type u_2} {Î² : Type u_3} (f : X â†’ Î±) (g : Î± â†’ Î²) (h : is_locally_constant (g âˆ˜ f)) (inj : function.injective g) : is_locally_constant f"

- doc_string: "The indexed supremum of a function is bounded above by a uniform bound"
  theorem: "{Î± : Type u_1} {Î¹ : Sort u_3} [conditionally_complete_lattice Î±] [nonempty Î¹] {f : Î¹ â†’ Î±} {c : Î±} (H : âˆ€ (x : Î¹), f x â‰¤ c) : supr f â‰¤ c"

- doc_string: " The geometric mean is less than or equal to the arithmetic mean, weighted version for two `nnreal` numbers."
  theorem: "(wâ‚ wâ‚‚ pâ‚ pâ‚‚ : nnreal) : wâ‚ + wâ‚‚ = 1 â†’ pâ‚ ^ â†‘wâ‚ * pâ‚‚ ^ â†‘wâ‚‚ â‰¤ wâ‚ * pâ‚ + wâ‚‚ * pâ‚‚"

- doc_string: " Euclid's lemma: if `a âˆ£ b * c` and `gcd a b = 1` then `a âˆ£ c`. Compare with `is_coprime.dvd_of_dvd_mul_right` and `unique_factorization_monoid.dvd_of_dvd_mul_right_of_no_prime_factors`"
  theorem: "{a b c : â„¤} (habc : a âˆ£ b * c) (hab : a.gcd b = 1) : a âˆ£ c"

- doc_string: " The square of the sine of `Ï€ / 3` is `3 / 4` (this is sometimes more convenient than the result for cosine itself)."
  theorem: " : real.sin (real.pi / 3) ^ 2 = 3 / 4"

- doc_string: "The function `r â†¦ râ»Â¹` tends to `0` on the right as `r â†’ +âˆž`."
  theorem: "{Î± : Type u} [linear_ordered_field Î±] [topological_space Î±] [order_topology Î±] : filter.tendsto (Î» (r : Î±), râ»Â¹) filter.at_top (nhds_within 0 (set.Ioi 0))"

- doc_string: "In the special case `n = 1`, `quaternion 1` is a cyclic group (of order `4`)."
  theorem: " : is_cyclic (quaternion_group 1)"

- doc_string: "The exponential characteristic is a prime number or one."
  theorem: "(R : Type u) [semiring R] [nontrivial R] [no_zero_divisors R] (q : â„•) [hq : exp_char R q] : nat.prime q âˆ¨ q = 1"

- doc_string: "If both `a` and `b` commute with `c`, then their product commutes with `c`."
  theorem: "{S : Type u_1} [semigroup S] {a b c : S} (hac : commute a c) (hbc : commute b c) : commute (a * b) c"

- doc_string: "Assumes left covariance. The lemma assuming right covariance is `right.add_pos_of_pos_of_nonneg`."
  theorem: "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : 0 < a) (hb : 0 â‰¤ b) : 0 < a + b"

- doc_string: "See `tsub_tsub_le` for an inequality."
  theorem: "{Î± : Type u_1} [canonically_ordered_add_monoid Î±] [has_sub Î±] [has_ordered_sub Î±] {a b : Î±} [contravariant_class Î± Î± has_add.add has_le.le] (h : a â‰¤ b) : b - (b - a) = a"

- doc_string: "A subset of a cospherical set is cospherical."
  theorem: "{P : Type u_2} [metric_space P] {psâ‚ psâ‚‚ : set P} (hs : psâ‚ âŠ† psâ‚‚) (hc : euclidean_geometry.cospherical psâ‚‚) : euclidean_geometry.cospherical psâ‚"

- doc_string: "This lemma has an abbreviated name because it is used frequently."
  theorem: "{a b : ennreal} (h : a < b) : add_le_cancellable a"

- doc_string: "`quot.mk r` is a surjective function."
  theorem: "{Î± : Sort u_1} (r : Î± â†’ Î± â†’ Prop) : function.surjective (quot.mk r)"

- doc_string: "If `x ^ n = 1`, then `x ^ m` is the same as `x ^ (m % n)`"
  theorem: "{M : Type u_1} [monoid M] {x : M} (m : â„•) {n : â„•} (h : x ^ n = 1) : x ^ m = x ^ (m % n)"

- doc_string: "Left multiplication in a ring is an additive monoid morphism."
  theorem: "{Î³ : Type u_1} [non_unital_non_assoc_semiring Î³] (x : Î³) : is_add_monoid_hom (Î» (y : Î³), x * y)"

- doc_string: "The closure of the interval `(-âˆž, a)` is the interval `(-âˆž, a]`."
  theorem: "{Î± : Type u} [topological_space Î±] [linear_order Î±] [order_topology Î±] [densely_ordered Î±] (a : Î±) [no_min_order Î±] : closure (set.Iio a) = set.Iic a"

- doc_string: "**Alias** of `left.add_neg_of_nonpos_of_neg`."
  theorem: "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b : Î±} (ha : a â‰¤ 0) (hb : b < 0) : a + b < 0"

- doc_string: "**Alias** of the forward direction of is_clopen_iff_frontier_eq_empty`."
  theorem: "{Î± : Type u} [topological_space Î±] {s : set Î±} : is_clopen s â†’ frontier s = âˆ…"

- doc_string: "`R` is integrally closed iff it is the integral closure of itself in its field of fractions."
  theorem: "{R : Type u_1} [comm_ring R] [is_domain R] (K : Type u_2) [field K] [algebra R K] [is_fraction_ring R K] : is_integrally_closed R â†” is_integral_closure R R K"

- doc_string: " *Engel's theorem*.  Note that this implies all traditional forms of Engel's theorem via `lie_module.nontrivial_max_triv_of_is_nilpotent`, `lie_module.is_nilpotent_iff_forall`, `lie_algebra.is_nilpotent_iff_forall`."
  theorem: "{R : Type uâ‚} {L : Type uâ‚‚} [comm_ring R] [lie_ring L] [lie_algebra R L] [is_noetherian R L] : lie_algebra.is_engelian R L"

- doc_string: "Determinant of 1x1 matrix"
  theorem: "{R : Type v} [comm_ring R] (A : matrix (fin 1) (fin 1) R) : A.det = A 0 0"

- doc_string: " An algebra over a Noetherian ring is finitely generated if and only if it is finitely presented."
  theorem: "{R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] [is_noetherian_ring R] : algebra.finite_type R A â†” algebra.finite_presentation R A"

- doc_string: " Given a closed set `s` in a Polish space, one can construct a finer Polish topology for which `s` is both open and closed."
  theorem: "{Î± : Type u_1} [topological_space Î±] [polish_space Î±] {s : set Î±} (hs : is_closed s) : polish_space.is_clopenable s"

- doc_string: "**Alias** of the reverse direction of is_coatom_dual_iff_is_atom`."
  theorem: "{Î± : Type u_1} [preorder Î±] [order_bot Î±] {a : Î±} : is_atom a â†’ is_coatom (â‡‘order_dual.to_dual a)"

- doc_string: "`sinh` is strictly monotone."
  theorem: " : strict_mono real.sinh"

- doc_string: " Adding a group element to the point `p` is an injective function."
  theorem: "{G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] (p : P) : function.injective (Î» (_x : G), _x +áµ¥ p)"

- doc_string: "A stronger version of `mul_right_injective`"
  theorem: "{Î± : Type u} [decidable_eq Î±] (i j : Î±) : function.involutive (has_mul.mul (equiv.swap i j))"

- doc_string: " The first theorem that characterises the function `reduce`: a word reduces to its maximal reduction."
  theorem: "{Î± : Type u} {L : list (Î± Ã— bool)} [decidable_eq Î±] : free_group.red L (free_group.reduce L)"

- doc_string: "Two metric space structures with the same distance coincide."
  theorem: "{Î± : Type u_1} {m m' : metric_space Î±} (h : pseudo_metric_space.to_has_dist = pseudo_metric_space.to_has_dist) : m = m'"

- doc_string: " Converting a `fin (n + 1)` to `â„•` and back results in the same value."
  theorem: "{n : â„•} (a : fin (n + 1)) : â†‘â†‘a = a"

- doc_string: " To show a reflexive relation `r : Î± â†’ Î± â†’ Prop` holds over `x y : Î±`, it suffices to show it holds when `x â‰  y`."
  theorem: "{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} (h : reflexive r) {x y : Î±} (hr : x â‰  y â†’ r x y) : r x y"

- doc_string: "The golden ratio is irrational."
  theorem: " : irrational golden_ratio"

- doc_string: "The set of natural number powers of an element of a monoid is closed under multiplication."
  theorem: "{M : Type u_1} [monoid M] {x y z : M} : y âˆˆ powers x â†’ z âˆˆ powers x â†’ y * z âˆˆ powers x"

- doc_string: "Extensionality rule for congruence relations."
  theorem: "{M : Type u_1} [has_mul M] {c d : con M} (H : âˆ€ (x y : M), â‡‘c x y â†” â‡‘d x y) : c = d"

- doc_string: "The resolvent is a unit when the argument is in the resolvent set."
  theorem: "{R : Type u} {A : Type v} [comm_semiring R] [ring A] [algebra R A] {r : R} {a : A} : r âˆˆ resolvent_set R a â†” is_unit (resolvent a r)"

- doc_string: "**Alias** of lt_of_eq_of_lt`."
  theorem: "{Î± : Type u} [preorder Î±] {a b c : Î±} (hab : a = b) (hbc : b < c) : a < c"

- doc_string: " Young's inequality, `â„â‰¥0` version. We use `{p q : â„â‰¥0}` in order to avoid constructing witnesses of `0 â‰¤ p` and `0 â‰¤ q` for the denominators."
  theorem: "(a b : nnreal) {p q : nnreal} (hp : 1 < p) (hpq : 1 / p + 1 / q = 1) : a * b â‰¤ a ^ â†‘p / p + b ^ â†‘q / q"

- doc_string: " If all elements in a list are bounded below by `1`, then the length of the list is bounded by the sum of the elements."
  theorem: "(L : list â„•) (h : âˆ€ (i : â„•), i âˆˆ L â†’ 1 â‰¤ i) : L.length â‰¤ L.sum"

- doc_string: "The negation of an additive group homomorphism is an additive group homomorphism if the target is commutative."
  theorem: "{Î± : Type u_1} {Î² : Type u_2} [add_group Î±] [add_comm_group Î²] {f : Î± â†’ Î²} (hf : is_add_group_hom f) : is_add_group_hom (Î» (a : Î±), -f a)"

- doc_string: " Assumes left covariance. The lemma assuming right covariance is `right.one_le_mul`."
  theorem: "{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a b : Î±} (ha : 1 â‰¤ a) (hb : 1 â‰¤ b) : 1 â‰¤ a * b"

- doc_string: "`legendre_sym p a = -1` iff`a` is a nonsquare mod `p`."
  theorem: "(p : â„•) [fact (nat.prime p)] {a : â„¤} : zmod.legendre_sym p a = -1 â†” Â¬is_square â†‘a"

- doc_string: "**Alias** of not_sbtw_of_btw`."
  theorem: "{Î± : Type u_1} [circular_preorder Î±] {a b c : Î±} (h : has_btw.btw a b c) : Â¬has_sbtw.sbtw c b a"

- doc_string: "The `star` map in a normed star group is an isometry"
  theorem: "{E : Type u_2} [semi_normed_group E] [star_add_monoid E] [normed_star_group E] : isometry has_star.star"

- doc_string: "See also `continuous_map.continuous_coe'`"
  theorem: "{Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [compact_space Î±] [metric_space Î²] : continuous coe_fn"

- doc_string: "Assumes left covariance. The lemma assuming right covariance is `right.add_pos'`."
  theorem: "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : 0 < a) (hb : 0 < b) : 0 < a + b"

- doc_string: "Finite wide pushouts are finite colimits, so if `C` has all finite colimits, it also has finite wide pushouts"
  theorem: "(C : Type u) [category_theory.category C] [category_theory.limits.has_finite_colimits C] : category_theory.limits.has_finite_wide_pushouts C"

- doc_string: "If `find p = some i`, then `p i` holds"
  theorem: "{n : â„•} (p : fin n â†’ Prop) [decidable_pred p] {i : fin n} (hi : i âˆˆ fin.find p) : p i"

- doc_string: "The identity map is a ring homomorphism."
  theorem: "{Î± : Type u} [ring Î±] : is_ring_hom id"

- doc_string: "`clifford_algebra.involute` is analogous to `complex.conj`."
  theorem: "(c : clifford_algebra clifford_algebra_complex.Q) : â‡‘clifford_algebra_complex.to_complex (â‡‘clifford_algebra.involute c) = â‡‘(star_ring_end â„‚) (â‡‘clifford_algebra_complex.to_complex c)"

- doc_string: "Composition by an bijective function on the left is itself bijective."
  theorem: "{Î± : Sort u} {Î² : Sort v} {Î³ : Sort w} {g : Î² â†’ Î³} (hg : function.bijective g) : function.bijective (function.comp g)"

- doc_string: "**Alias** of int.le_self_sq`."
  theorem: "(b : â„¤) : b â‰¤ b ^ 2"

- doc_string: "If `z âˆˆ ð’Ÿáµ’`, and `n : â„¤`, then `|z + n| > 1`."
  theorem: "{z : upper_half_plane} (hz : z âˆˆ modular_group.fdo) (n : â„¤) : 1 < â‡‘complex.norm_sq â†‘(modular_group.T ^ n â€¢ z)"

- doc_string: " If `C` has disjoint coproducts, any morphism out of initial is mono. Note it isn't true in general that `C` has strict initial objects, for instance consider the category of types and partial functions."
  theorem: "{C : Type u} [category_theory.category C] [category_theory.limits.coproducts_disjoint C] : category_theory.limits.initial_mono_class C"

- doc_string: " Cyclotomic polynomials are always positive on inputs larger than one. Similar to `cyclotomic_pos` but with the condition on the input rather than index of the cyclotomic polynomial."
  theorem: "(n : â„•) {R : Type u_1} [linear_ordered_comm_ring R] {x : R} (hx : 1 < x) : 0 < polynomial.eval x (polynomial.cyclotomic n R)"

- doc_string: "Given subsets `t` and `s` of a monoid `M`, if `s âŠ† t`, the submonoid of `M` generated by `s` is    contained in the submonoid generated by `t`."
  theorem: "{M : Type u_1} [monoid M] {s t : set M} (h : s âŠ† t) : monoid.closure s âŠ† monoid.closure t"

- doc_string: "If a preadditive category has all cokernels, then it also has all coequalizers."
  theorem: "{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_cokernels C] : category_theory.limits.has_coequalizers C"

- doc_string: "A `fintype` can be given a field structure iff its cardinality is a prime power."
  theorem: "{Î± : Type u_1} [fintype Î±] : nonempty (field Î±) â†” is_prime_pow (fintype.card Î±)"

- doc_string: "When there is a global maximum, every set is bounded above."
  theorem: "{Î³ : Type w} [preorder Î³] [order_top Î³] (s : set Î³) : bdd_above s"

- doc_string: "The Haudorff edistances of `s` to `t` and of `t` to `s` coincide"
  theorem: "{Î± : Type u} [pseudo_emetric_space Î±] {s t : set Î±} : emetric.Hausdorff_edist s t = emetric.Hausdorff_edist t s"

- doc_string: "**Alias** of left.one_le_mul`."
  theorem: "{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a b : Î±} (ha : 1 â‰¤ a) (hb : 1 â‰¤ b) : 1 â‰¤ a * b"

- doc_string: "Updating the last element of a tuple does not change the beginning."
  theorem: "{n : â„•} {Î± : fin (n + 1) â†’ Type u} (q : Î  (i : fin (n + 1)), Î± i) (z : Î± (fin.last n)) : fin.init (function.update q (fin.last n) z) = fin.init q"

- doc_string: "**Alias** of ne_of_lt`."
  theorem: "{Î± : Type u} [preorder Î±] {a b : Î±} (h : a < b) : a â‰  b"

- doc_string: " Assumes right covariance. The lemma assuming left covariance is `left.mul_lt_one_of_le_of_lt`."
  theorem: "{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_mul.mul) has_le.le] {a b : Î±} (ha : a â‰¤ 1) (hb : b < 1) : a * b < 1"

- doc_string: "Mapping intermediate fields along the identity does not change them"
  theorem: "{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (E : intermediate_field K L) : E.map (alg_hom.id K L) = E"

- doc_string: "The range of an indexed cardinal function, whose outputs live in a higher universe than the    inputs, is always bounded above."
  theorem: "{Î¹ : Type u} (f : Î¹ â†’ cardinal) : bdd_above (set.range f)"

- doc_string: "Equality behind `add_semiconj_by a x y`; useful for rewriting."
  theorem: "{S : Type u} [has_add S] {a x y : S} (h : add_semiconj_by a x y) : a + x = y + a"

- doc_string: "Every ultrafilter `u` on `ultrafilter Î±` converges to a unique  point of `ultrafilter Î±`, namely `mjoin u`."
  theorem: "{Î± : Type u} {u : ultrafilter (ultrafilter Î±)} {x : ultrafilter Î±} : â†‘u â‰¤ nhds x â†” x = mjoin u"

- doc_string: "The quotient map by a group action is open."
  theorem: "{Î“ : Type u_4} [group Î“] {T : Type u_5} [topological_space T] [mul_action Î“ T] [has_continuous_const_smul Î“ T] : is_open_map quotient.mk"

- doc_string: " `(k*x, k*y, k*z)` is a Pythagorean triple if and only if `(x, y, z)` is also a triple."
  theorem: "{x y z : â„¤} (k : â„¤) (hk : k â‰  0) : pythagorean_triple (k * x) (k * y) (k * z) â†” pythagorean_triple x y z"

- doc_string: " Converting an in-range number to `fin (n + 1)` produces a result whose value is the original number."
  theorem: "{n a : â„•} (h : a < n + 1) : â†‘a.val = a"

- doc_string: "The distance to a set is controlled by the Hausdorff distance"
  theorem: "{Î± : Type u} [pseudo_emetric_space Î±] {x : Î±} {s t : set Î±} (h : x âˆˆ s) : emetric.inf_edist x t â‰¤ emetric.Hausdorff_edist s t"

- doc_string: "`ord âˆ˜ aleph` enumerates the infinite ordinals that are cardinals."
  theorem: " : cardinal.ord âˆ˜ cardinal.aleph = ordinal.enum_ord {b : ordinal | b.card.ord = b âˆ§ ordinal.omega â‰¤ b}"

- doc_string: "A preadditive category with finite coproducts has finite biproducts."
  theorem: "{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_finite_coproducts C] : category_theory.limits.has_finite_biproducts C"

- doc_string: " The sum over the complement of a finset tends to `0` when the finset grows to cover the whole space. This does not need a summability assumption, as otherwise all sums are zero."
  theorem: "{Î± : Type u_1} (f : Î± â†’ nnreal) : filter.tendsto (Î» (s : finset Î±), âˆ‘' (b : {x // x âˆ‰ s}), f â†‘b) filter.at_top (nhds 0)"

- doc_string: " So-named because the outer coercion is `int.cast` into `zmod`. For `int.cast` into an arbitrary ring, see `zmod.int_cast_cast`."
  theorem: "{n : â„•} (a : zmod n) : â†‘â†‘a = a"

- doc_string: "**Alias** of the reverse direction of mul_sub_mul_div_mul_neg_iff`."
  theorem: "{Î± : Type u_1} [linear_ordered_field Î±] {a b c d : Î±} (hc : c â‰  0) (hd : d â‰  0) : a / c < b / d â†’ (a * d - b * c) / (c * d) < 0"

- doc_string: "A regular element of a `nontrivial` `mul_zero_class` is non-zero."
  theorem: "{R : Type u_1} {a : R} [mul_zero_class R] [nontrivial R] (la : is_regular a) : a â‰  0"

- doc_string: " For each field, and for each nonzero element of said field, there is a unique inverse. Since `is_field` doesn't remember the data of an `inv` function and as such, a lemma that there is a unique inverse could be useful."
  theorem: "(R : Type u) [ring R] (hf : is_field R) (x : R) : x â‰  0 â†’ (âˆƒ! (y : R), x * y = 1)"

- doc_string: "Conjugation acting on fixed element of the additive group is continuous when both   `add` and `neg` are continuous."
  theorem: "{G : Type w} [topological_space G] [has_neg G] [has_add G] [has_continuous_add G] [has_continuous_neg G] (h : G) : continuous (Î» (g : G), g + h + -g)"

- doc_string: " A version of `measurable_const` that assumes `f x = f y` for all `x, y`. This version works for functions between empty types."
  theorem: "{Î± : Type u_1} {Î² : Type u_2} [measurable_space Î±] [measurable_space Î²] {f : Î² â†’ Î±} (hf : âˆ€ (x y : Î²), f x = f y) : measurable f"

- doc_string: "The first projection in a product of topological spaces sends open sets to open sets."
  theorem: "{Î± : Type u} {Î² : Type v} [topological_space Î±] [topological_space Î²] : is_open_map prod.fst"

- doc_string: "**Alias** of the forward direction of is_seq_closed_iff_is_closed`."
  theorem: "{X : Type u_1} [topological_space X] [sequential_space X] {s : set X} : is_seq_closed s â†’ is_closed s"

- doc_string: " In the characteristic zero case, the weights in the centroid sum to 1 if the number of points is `n + 1`."
  theorem: "(k : Type u_1) [division_ring k] {Î¹ : Type u_4} (s : finset Î¹) [char_zero k] {n : â„•} (h : s.card = n + 1) : s.sum (Î» (i : Î¹), finset.centroid_weights k s i) = 1"

- doc_string: '$\lim_{x\to-\infty}|x|=+\infty$'
  theorem: "{Î± : Type u_3} [linear_ordered_add_comm_group Î±] : filter.tendsto has_abs.abs filter.at_bot filter.at_top"

- doc_string: "If a preadditive category has all kernels, then it also has all equalizers."
  theorem: "{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_kernels C] : category_theory.limits.has_equalizers C"

- doc_string: "**Alias** of the reverse direction of monotone_on_to_dual_comp_iff`."
  theorem: "{Î± : Type u} {Î² : Type v} [preorder Î±] [preorder Î²] {f : Î± â†’ Î²} {s : set Î±} : antitone_on f s â†’ monotone_on (â‡‘order_dual.to_dual âˆ˜ f) s"

- doc_string: "Elements of a cancel monoid are regular.  Cancel semigroups do not appear to exist."
  theorem: "{R : Type u_1} [cancel_monoid R] (g : R) : is_regular g"

- doc_string: "The negation of a map which preserves addition, preserves addition when the target is commutative."
  theorem: "{Î± : Type u_1} {Î² : Type u_2} [add_zero_class Î±] [add_comm_group Î²] {f : Î± â†’ Î²} (hf : is_add_monoid_hom f) : is_add_monoid_hom (Î» (a : Î±), -f a)"

- doc_string: "If the domain of a `dense_inducing` map is a separable space, then so is the codomain."
  theorem: "{Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] {i : Î± â†’ Î²} (di : dense_inducing i) [topological_space.separable_space Î±] : topological_space.separable_space Î²"

- doc_string: "Deprecated: use `fun_like.ext_iff` instead."
  theorem: "{M : Type u_3} {N : Type u_4} [has_zero M] [has_zero N] {f g : zero_hom M N} : f = g â†” âˆ€ (x : M), â‡‘f x = â‡‘g x"

- doc_string: "Function extensionality, proven using quotients."
  theorem: "{Î± : Sort u} {Î² : Î± â†’ Sort v} {fâ‚ fâ‚‚ : Î  (x : Î±), Î² x} (h : âˆ€ (x : Î±), fâ‚ x = fâ‚‚ x) : fâ‚ = fâ‚‚"

- doc_string: "We have the congruence `legendre_sym p a â‰¡ a ^ (p / 2) mod p`."
  theorem: "(p : â„•) (a : â„¤) [hp : fact (nat.prime p)] : â†‘(zmod.legendre_sym p a) = â†‘a ^ (p / 2)"

- doc_string: " Assumes right covariance. The lemma assuming left covariance is `left.one_lt_mul_of_lt_of_le`."
  theorem: "{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_mul.mul) has_lt.lt] {a b : Î±} (ha : 1 < a) (hb : 1 â‰¤ b) : 1 < a * b"

- doc_string: "**Alias** of left.neg_le_self`."
  theorem: "{Î± : Type u} [add_group Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a : Î±} (h : 0 â‰¤ a) : -a â‰¤ a"

- doc_string: "`padic_val_nat p 0` is 0 for any `p`."
  theorem: "{p : â„•} : padic_val_nat p 0 = 0"

- doc_string: "The order of the formal power series `X^n` is `n`."
  theorem: "{R : Type u_1} [semiring R] [nontrivial R] (n : â„•) : (power_series.X ^ n).order = â†‘n"

- doc_string: "The sequence `B âŸ¶ A âŠž B âŸ¶ A` is exact."
  theorem: "{ð’œ : Type u_1} [category_theory.category ð’œ] [category_theory.preadditive ð’œ] [category_theory.limits.has_kernels ð’œ] [category_theory.limits.has_images ð’œ] [category_theory.limits.has_binary_biproducts ð’œ] (A B : ð’œ) : category_theory.exact category_theory.limits.biprod.inr category_theory.limits.biprod.fst"

- doc_string: " A module over a `subsingleton` semiring is a `subsingleton`. We cannot register this as an instance because Lean has no way to guess `R`."
  theorem: "(R : Type u_1) (M : Type u_2) [semiring R] [subsingleton R] [add_comm_monoid M] [module R M] : subsingleton M"

- doc_string: "The order of the monomial `a*X^n` is `n` if `a â‰  0`."
  theorem: "{R : Type u_1} [semiring R] (n : â„•) (a : R) (h : a â‰  0) : (â‡‘(power_series.monomial R n) a).order = â†‘n"

- doc_string: " Every separated topological group in which there exists a compact set with nonempty interior is locally compact."
  theorem: "{G : Type w} [topological_space G] [group G] [topological_group G] [t2_space G] (K : topological_space.positive_compacts G) : locally_compact_space G"

- doc_string: "**Alias** of lt_asymm`."
  theorem: "{Î± : Type u} [preorder Î±] {a b : Î±} (h : a < b) : Â¬b < a"

- doc_string: "`cyclotomic n R` is different from `0`."
  theorem: "(n : â„•) (R : Type u_1) [ring R] [nontrivial R] : polynomial.cyclotomic n R â‰  0"

- doc_string: "**Alias** of left.inv_lt_one_iff`."
  theorem: "{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a : Î±} : -a < 0 â†” 0 < a"

- doc_string: "If an element `b` becomes add-left-regular after adding to it on the left a add-left-regular element, then `b` is add-left-regular."
  theorem: "{R : Type u_1} {a b : R} [add_semigroup R] (ab : is_add_left_regular (a + b)) : is_add_left_regular b"

- doc_string: "The `n`-th ghost component of `teichmuller p r` is `r ^ p ^ n`."
  theorem: "(p : â„•) {R : Type u_1} [hp : fact (nat.prime p)] [comm_ring R] (r : R) (n : â„•) : â‡‘(witt_vector.ghost_component n) (â‡‘(witt_vector.teichmuller p) r) = r ^ p ^ n"

- doc_string: " If `Î±` is a nonempty preorder with no minimal elements, then there exists a strictly antitone function `â„• â†’ Î±`."
  theorem: "(Î± : Type u) [preorder Î±] [nonempty Î±] [no_min_order Î±] : âˆƒ (f : â„• â†’ Î±), strict_anti f"

- doc_string: " **Church-Rosser theorem** for word reduction: If `w1 w2 w3` are words such that `w1` reduces to `w2` and `w3` respectively, then there is a word `w4` such that `w2` and `w3` reduce to `w4` respectively. This is also known as Newman's diamond lemma."
  theorem: "{Î± : Type u} {Lâ‚ Lâ‚‚ Lâ‚ƒ : list (Î± Ã— bool)} : free_group.red Lâ‚ Lâ‚‚ â†’ free_group.red Lâ‚ Lâ‚ƒ â†’ relation.join free_group.red Lâ‚‚ Lâ‚ƒ"

- doc_string: "In a semigroup, the product of left-regular elements is left-regular."
  theorem: "{R : Type u_1} {a b : R} [semigroup R] (lra : is_left_regular a) (lrb : is_left_regular b) : is_left_regular (a * b)"

- doc_string: "`âŠ¤`, coerced to a set, is the whole set of points."
  theorem: "(k : Type u_1) (V : Type u_2) (P : Type u_3) [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] : â†‘âŠ¤ = set.univ"

- doc_string: "Elements of a left cancel semigroup are left regular."
  theorem: "{R : Type u_1} [left_cancel_semigroup R] (g : R) : is_left_regular g"

- doc_string: "The projection from a topological fiber bundle to its base is an open map."
  theorem: "{B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z â†’ B} [topological_space Z] (h : is_topological_fiber_bundle F proj) : is_open_map proj"

- doc_string: "In a preadditive category, if all binary products exist, then all binary biproducts exist."
  theorem: "{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_binary_products C] : category_theory.limits.has_binary_biproducts C"

- doc_string: "**Alias** of `left.add_neg'`."
  theorem: "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : a < 0) (hb : b < 0) : a + b < 0"

- doc_string: "Express `edist` in terms of `nndist`"
  theorem: "{Î± : Type u} [pseudo_metric_space Î±] (x y : Î±) : has_edist.edist x y = â†‘(has_nndist.nndist x y)"

- doc_string: "Any category with finite products and equalizers has all finite limits.  See <https://stacks.math.columbia.edu/tag/002O>."
  theorem: "{C : Type u} [category_theory.category C] [category_theory.limits.has_finite_products C] [category_theory.limits.has_equalizers C] : category_theory.limits.has_finite_limits C"

- doc_string: "The set of natural number powers of an element of a submonoid is a subset of the submonoid."
  theorem: "{M : Type u_1} [monoid M] {s : set M} {a : M} (hs : is_submonoid s) (h : a âˆˆ s) : powers a âŠ† s"

- doc_string: "**Alias** of lt_trans`."
  theorem: "{Î± : Type u} [preorder Î±] {a b c : Î±} : a < b â†’ b < c â†’ a < c"

- doc_string: "**Alias** of the reverse direction of is_square_inv`."
  theorem: "{Î± : Type u_2} [subtraction_monoid Î±] {a : Î±} : even a â†’ even (-a)"

- doc_string: " `reduce` is idempotent, i.e. the maximal reduction of the maximal reduction of a word is the maximal reduction of the word."
  theorem: "{Î± : Type u} {L : list (Î± Ã— bool)} [decidable_eq Î±] : free_group.reduce (free_group.reduce L) = free_group.reduce L"

- doc_string: " In a (semi)normed group, negation `x â†¦ -x` tends to infinity at infinity. TODO: use `bornology.cobounded` instead of `filter.comap has_norm.norm filter.at_top`."
  theorem: "{E : Type u_3} [semi_normed_group E] : filter.tendsto has_neg.neg (filter.comap has_norm.norm filter.at_top) (filter.comap has_norm.norm filter.at_top)"

- doc_string: "There is a field structure on type if and only if its cardinality is a prime power."
  theorem: "{Î± : Type u} : nonempty (field Î±) â†” is_prime_pow (cardinal.mk Î±)"

- doc_string: "If both `a` and `b` commute with `c`, then their product commutes with `c`."
  theorem: "{S : Type u_1} [add_semigroup S] {a b c : S} (hac : add_commute a c) (hbc : add_commute b c) : add_commute (a + b) c"

- doc_string: "The `semi_normed_group.core` induced by a `normed_group.core`."
  theorem: "{E : Type u_1} [add_comm_group E] [has_norm E] (C : normed_group.core E) : semi_normed_group.core E"

- doc_string: "**Alias** of the forward direction of even_iff_exists_bit0`."
  theorem: "{Î± : Type u_2} [has_add Î±] {a : Î±} : even a â†’ (âˆƒ (b : Î±), a = bit0 b)"

- doc_string: "The Hausdorff distance satisfies the triangular inequality"
  theorem: "{Î± : Type u} [pseudo_emetric_space Î±] {s t u : set Î±} : emetric.Hausdorff_edist s u â‰¤ emetric.Hausdorff_edist s t + emetric.Hausdorff_edist t u"

- doc_string: "The projection on the base of a topological bundle created from core is continuous"
  theorem: "{Î¹ : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core Î¹ B F) : continuous Z.proj"

- doc_string: "This lemma has an abbreviated name because it is used frequently."
  theorem: "{a : nnreal} : add_le_cancellable â†‘a"

- doc_string: "A semisimple Abelian Lie algebra is trivial."
  theorem: "(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] [lie_algebra.is_semisimple R L] [h : is_lie_abelian L] : subsingleton L"

- doc_string: "Cyclic permutations preserve the triple product. See also `triple_product_eq_det`."
  theorem: "{R : Type u_1} [comm_ring R] (u v w : fin 3 â†’ R) : matrix.dot_product u (â‡‘(â‡‘cross_product v) w) = matrix.dot_product v (â‡‘(â‡‘cross_product w) u)"

- doc_string: "For `p â‰  0, p â‰  1, `padic_val_rat p p` is 1."
  theorem: "{p : â„•} (hp : 1 < p) : padic_val_nat p p = 1"

- doc_string: "The element `0` is right-regular if and only if `R` is trivial."
  theorem: "{R : Type u_1} [mul_zero_class R] (h : is_right_regular 0) : subsingleton R"

- doc_string: "**Alias** of the reverse direction of monotone_to_dual_comp_iff`."
  theorem: "{Î± : Type u} {Î² : Type v} [preorder Î±] [preorder Î²] {f : Î± â†’ Î²} : antitone f â†’ monotone (â‡‘order_dual.to_dual âˆ˜ f)"

- doc_string: " In the trivial charted_space structure of a space modelled over itself through the identity, the atlas members are just the identity"
  theorem: "{H : Type u_1} [topological_space H] {e : local_homeomorph H H} : e âˆˆ charted_space.atlas H H â†” e = local_homeomorph.refl H"

- doc_string: "Finite wide pullbacks are finite limits, so if `C` has all finite limits, it also has finite wide pullbacks"
  theorem: "(C : Type u) [category_theory.category C] [category_theory.limits.has_finite_limits C] : category_theory.limits.has_finite_wide_pullbacks C"

- doc_string: "The infimum of a singleton is the element of the singleton"
  theorem: "{Î± : Type u_1} [conditionally_complete_lattice Î±] (a : Î±) : has_Inf.Inf {a} = a"

- doc_string: "The element `0` is regular if and only if `R` is trivial."
  theorem: "{R : Type u_1} [mul_zero_class R] : is_regular 0 â†” subsingleton R"

- doc_string: "If a category has all products then in particular it has finite products."
  theorem: "(C : Type u) [category_theory.category C] [category_theory.limits.has_products C] : category_theory.limits.has_finite_products C"

- doc_string: "Two holors are equal if all their slices are equal."
  theorem: "{Î± : Type} {d : â„•} {ds : list â„•} (x y : holor Î± (d :: ds)) (h : x.slice = y.slice) : x = y"

- doc_string: "**Alias** of le_of_mul_le_mul_left'`."
  theorem: "{Î± : Type u_1} [has_mul Î±] [has_le Î±] [contravariant_class Î± Î± has_mul.mul has_le.le] {a b c : Î±} (bc : a * b â‰¤ a * c) : b â‰¤ c"

- doc_string: " The characteristic polynomial of the map `Î» x, a * x` is the minimal polynomial of `a`.  In combination with `det_eq_sign_charpoly_coeff` or `trace_eq_neg_charpoly_coeff` and a bit of rewriting, this will allow us to conclude the field norm resp. trace of `x` is the product resp. sum of `x`'s conjugates."
  theorem: "{K : Type u_1} {S : Type u_2} [field K] [comm_ring S] [algebra K S] (h : power_basis K S) : (â‡‘(algebra.left_mul_matrix h.basis) h.gen).charpoly = minpoly K h.gen"

- doc_string: "The empty set has zero diameter"
  theorem: "{Î± : Type u} [pseudo_metric_space Î±] : metric.diam âˆ… = 0"

- doc_string: " If `Î±` is a separable space and `f : Î± â†’ Î²` is a continuous map with dense range, then `Î²` is a separable space as well. E.g., the completion of a separable uniform space is separable."
  theorem: "{Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space.separable_space Î±] [topological_space Î²] {f : Î± â†’ Î²} (h : dense_range f) (h' : continuous f) : topological_space.separable_space Î²"

- doc_string: "**Fermat's Little Theorem**: for all nonzero `a : zmod p`, we have `a ^ (p - 1) = 1`."
  theorem: "{p : â„•} [fact (nat.prime p)] {a : zmod p} (ha : a â‰  0) : a ^ (p - 1) = 1"

- doc_string: "Conjugation is jointly continuous on `G Ã— G` when both `mul` and `inv` are continuous."
  theorem: "{G : Type w} [topological_space G] [has_neg G] [has_add G] [has_continuous_add G] [has_continuous_neg G] : continuous (Î» (g : G Ã— G), g.fst + g.snd + -g.fst)"

- doc_string: " Alias of `zsmul_right_inj`, for ease of discovery alongside `zsmul_le_zsmul_iff'` and `zsmul_lt_zsmul_iff'`."
  theorem: "{Î± : Type u_1} [linear_ordered_comm_group Î±] {n : â„¤} {a b : Î±} (hn : n â‰  0) : a ^ n = b ^ n â†” a = b"

- doc_string: "The cardinality of the antidiagonal of `n` is `n+1`."
  theorem: "(n : â„•) : â‡‘multiset.card (multiset.nat.antidiagonal n) = n + 1"

- doc_string: "If `a` commutes with `b`, then `b` commutes with `a`."
  theorem: "{S : Type u_1} [has_add S] {a b : S} (h : add_commute a b) : add_commute b a"

- doc_string: "The range of `pure : Î± â†’ ultrafilter Î±` is dense in `ultrafilter Î±`."
  theorem: "{Î± : Type u} : dense_range has_pure.pure"

- doc_string: "The minimal distance to a set (as `â„â‰¥0`) is continuous in point"
  theorem: "{Î± : Type u} [pseudo_metric_space Î±] (s : set Î±) : continuous (Î» (x : Î±), metric.inf_nndist x s)"

- doc_string: "**Alias** of sbtw_asymm`."
  theorem: "{Î± : Type u_1} [circular_preorder Î±] {a b c : Î±} (h : has_sbtw.sbtw a b c) : Â¬has_sbtw.sbtw c b a"

- doc_string: " To get differentiability at `0` of the auxiliary functions, we need to know that their limit is `0`, to be able to apply general differentiability extension theorems. This limit is checked in this lemma."
  theorem: "(n : â„•) : filter.tendsto (Î» (x : â„), polynomial.eval x (exp_neg_inv_glue.P_aux n) * real.exp (-xâ»Â¹) / x ^ (2 * n)) (nhds_within 0 (set.Ioi 0)) (nhds 0)"

- doc_string: "The only numbers with empty prime factorization are `0` and `1`"
  theorem: "(n : â„•) : n.factorization = 0 â†” n = 0 âˆ¨ n = 1"

- doc_string: "**Alias** of the reverse direction of order.succ_ne_succ_iff`."
  theorem: "{Î± : Type u_1} [partial_order Î±] [succ_order Î±] {a b : Î±} [no_max_order Î±] : a â‰  b â†’ order.succ a â‰  order.succ b"

- doc_string: "See `tsub_tsub_cancel_of_le` for the equality."
  theorem: "{Î± : Type u_1} [preorder Î±] [add_comm_semigroup Î±] [has_sub Î±] [has_ordered_sub Î±] {a b : Î±} : b - (b - a) â‰¤ a"

- doc_string: "A specialized ext lemma for equality of sigma types over an indexed subtype."
  theorem: "{Î± : Type u_1} {Î² : Type u_2} {p : Î± â†’ Î² â†’ Prop} {xâ‚€ xâ‚ : Î£ (a : Î±), subtype (p a)} : xâ‚€.fst = xâ‚.fst â†’ â†‘(xâ‚€.snd) = â†‘(xâ‚.snd) â†’ xâ‚€ = xâ‚"

- doc_string: "**Alias** of the reverse direction of bounded_space_subtype_iff`."
  theorem: "{Î± : Type u_1} [bornology Î±] {p : Î± â†’ Prop} : bornology.is_bounded {x : Î± | p x} â†’ bounded_space (subtype p)"

- doc_string: "In a monoid with zero, either zero and one are nonequal, or zero is the only element."
  theorem: "{Mâ‚€ : Type u_1} [mul_zero_one_class Mâ‚€] : 0 â‰  1 âˆ¨ âˆ€ (a : Mâ‚€), a = 0"

- doc_string: "If the domain of a `dense_embedding` is a separable space, then so is its codomain."
  theorem: "{Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] {e : Î± â†’ Î²} (de : dense_embedding e) [topological_space.separable_space Î±] : topological_space.separable_space Î²"

- doc_string: "In a `t2_space`, every compact set is closed."
  theorem: "{Î± : Type u} [topological_space Î±] [t2_space Î±] {s : set Î±} (hs : is_compact s) : is_closed s"

- doc_string: " Convenience lemma. The `a - 1` is not using truncated substraction, as opposed to the definition of `nat.desc_factorial` as a natural."
  theorem: "(S : Type u_1) [ring S] (a : â„•) : â†‘(a.desc_factorial 2) = â†‘a * (â†‘a - 1)"

- doc_string: "**Alias** of sbtw_trans_right`."
  theorem: "{Î± : Type u_1} [circular_preorder Î±] {a b c d : Î±} (hbc : has_sbtw.sbtw a b c) (hcd : has_sbtw.sbtw a c d) : has_sbtw.sbtw a b d"

- doc_string: "Deprecated: use `fun_like.congr_arg` instead."
  theorem: "{M : Type u_3} {N : Type u_4} [has_one M] [has_one N] (f : one_hom M N) {x y : M} (h : x = y) : â‡‘f x = â‡‘f y"

- doc_string: "The number of solutions to `x^2 = a` is determined by the quadratic character."
  theorem: "{F : Type u_1} [field F] [fintype F] [decidable_eq F] (hF : ring_char F â‰  2) (a : F) : â†‘({x : F | x ^ 2 = a}.to_finset.card) = char.quadratic_char F a + 1"

- doc_string: "We prefer to use the bundled `rev_at` over unbundled `rev_at_fun`."
  theorem: "(N i : â„•) : polynomial.rev_at_fun N i = â‡‘(polynomial.rev_at N) i"

- doc_string: "**Alias** of the reverse direction of lt_inv_mul_iff_mul_lt`."
  theorem: "{Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a b c : Î±} : a * b < c â†’ b < aâ»Â¹ * c"

- doc_string: "For the identity map, all points are periodic."
  theorem: "{Î± : Type u_1} (n : â„•) (x : Î±) : function.is_periodic_pt id n x"

- doc_string: "Assumes right covariance. The lemma assuming left covariance is `left.add_neg`."
  theorem: "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b : Î±} (ha : a < 0) (hb : b < 0) : a + b < 0"

- doc_string: "The new distance is uniformly continuous."
  theorem: "{Î± : Type u} [pseudo_metric_space Î±] : uniform_continuous (Î» (p : uniform_space.completion Î± Ã— uniform_space.completion Î±), has_dist.dist p.fst p.snd)"

- doc_string: "The conjugate of the golden ratio is irrational."
  theorem: " : irrational golden_conj"

- doc_string: "The sets of factors of coprime `a` and `b` are disjoint"
  theorem: "{a b : â„•} (hab : a.coprime b) : a.factors.disjoint b.factors"

- doc_string: "The order on `Î¹ â†’â‚€ â„•` is well-founded."
  theorem: "(Î¹ : Type u_3) : well_founded has_lt.lt"

- doc_string: " For nonzero integers `a` and `b`, `gcd a b` is the smallest positive natural number that can be written in the form `a * x + b * y` for some pair of integers `x` and `y`"
  theorem: "{a b : â„¤} (ha : a â‰  0) : is_least {n : â„• | 0 < n âˆ§ âˆƒ (x y : â„¤), â†‘n = a * x + b * y} (a.gcd b)"

- doc_string: "Assumes right covariance."
  theorem: "{Î± : Type u} {a b : Î±} [mul_one_class Î±] [has_zero Î±] [preorder Î±] [zero_lt.mul_pos_strict_mono Î±] (ha : 1 < a) (hb : 1 â‰¤ b) (b0 : 0 < b) : 1 < a * b"

- doc_string: "**Alias** of the forward direction of antisymm_rel_iff_eq`."
  theorem: "{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} [is_refl Î± r] [is_antisymm Î± r] {a b : Î±} : antisymm_rel r a b â†’ a = b"

- doc_string: "`a â‰¤ b` as natural numbers if and only if `a â‰¤ b` in `fin n`."
  theorem: "{n : â„•} {a b : fin n} : â†‘a â‰¤ â†‘b â†” a â‰¤ b"

- doc_string: "**Alias** of the reverse direction of order.pred_lt_pred_iff`."
  theorem: "{Î± : Type u_1} [preorder Î±] [pred_order Î±] {a b : Î±} [no_min_order Î±] : a < b â†’ order.pred a < order.pred b"

- doc_string: "If `L/K` is an algebraic field extension, then the Krull topology on `L â‰ƒâ‚[K] L` is  totally disconnected."
  theorem: "{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (h_int : algebra.is_integral K L) : is_totally_disconnected set.univ"

- doc_string: "0 is of finite order in any additive monoid."
  theorem: "{G : Type u} [add_monoid G] : is_of_fin_add_order 0"

- doc_string: "In an additive semigroup, the sum of add-left-regular elements is add-left.regular."
  theorem: "{R : Type u_1} {a b : R} [add_semigroup R] (lra : is_add_left_regular a) (lrb : is_add_left_regular b) : is_add_left_regular (a + b)"

- doc_string: "**Alias** of lt_of_mul_lt_mul_left'`."
  theorem: "{Î± : Type u_1} [has_mul Î±] [has_lt Î±] [contravariant_class Î± Î± has_mul.mul has_lt.lt] {a b c : Î±} (bc : a * b < a * c) : b < c"

- doc_string: " Reformulation of well founded induction on ordinals as a lemma that works with the `induction` tactic, as in `induction i using ordinal.induction with i IH`."
  theorem: "{p : ordinal â†’ Prop} (i : ordinal) (h : âˆ€ (j : ordinal), (âˆ€ (k : ordinal), k < j â†’ p k) â†’ p j) : p i"

- doc_string: "`sinh` is injective, `âˆ€ a b, sinh a = sinh b â†’ a = b`."
  theorem: " : function.injective real.sinh"

- doc_string: "Uses `right` co(ntra)variant."
  theorem: "{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a : Î±} : 0 < -a â†” a < 0"

- doc_string: "Multiplicative congruence relations preserve inversion."
  theorem: "{M : Type u_1} [group M] (c : con M) {w x : M} : â‡‘c w x â†’ â‡‘c wâ»Â¹ xâ»Â¹"

- doc_string: "`quotient.mk` is a surjective function."
  theorem: "(Î± : Sort u_1) [s : setoid Î±] : function.surjective quotient.mk"

- doc_string: "The normal closure of s is the smallest normal subgroup containing s."
  theorem: "{G : Type u_1} [group G] {s t : set G} (ht : is_normal_subgroup t) (h : s âŠ† t) : group.normal_closure s âŠ† t"

- doc_string: "There exists at most one `floor_semiring` structure on a linear ordered semiring."
  theorem: "{Î± : Type u_1} [linear_ordered_semiring Î±] : subsingleton (floor_semiring Î±)"

- doc_string: "**Sum of a Geometric Series**"
  theorem: "{r : nnreal} (hr : r < 1) : has_sum (Î» (n : â„•), r ^ n) (1 - r)â»Â¹"

- doc_string: "Any element commutes with itself."
  theorem: "{S : Type u_1} [has_mul S] (a : S) : commute a a"

- doc_string: "Uses `right` co(ntra)variant."
  theorem: "{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a : Î±} : -a < 0 â†” 0 < a"

- doc_string: " An element a of a semigroup with a distributive negation divides the negation of an element b iff a divides b."
  theorem: "{Î± : Type u} [semigroup Î±] [has_distrib_neg Î±] (a b : Î±) : a âˆ£ -b â†” a âˆ£ b"

- doc_string: "**Alias** of `left.add_neg_of_neg_of_nonpos`."
  theorem: "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : a < 0) (hb : b â‰¤ 0) : a + b < 0"

- doc_string: "Additive congruence relations preserve subtraction."
  theorem: "{M : Type u_1} [add_group M] (c : add_con M) {w x y z : M} : â‡‘c w x â†’ â‡‘c y z â†’ â‡‘c (w - y) (x - z)"

- doc_string: " Conjugation acting on fixed element of the group is continuous when both `mul` and `inv` are continuous."
  theorem: "{G : Type w} [topological_space G] [has_inv G] [has_mul G] [has_continuous_mul G] [has_continuous_inv G] (h : G) : continuous (Î» (g : G), g * h * gâ»Â¹)"

- doc_string: "On an empty space, bounded continuous functions are at distance 0"
  theorem: "{Î± : Type u} {Î² : Type v} [topological_space Î±] [pseudo_metric_space Î²] {f g : bounded_continuous_function Î± Î²} [is_empty Î±] : has_dist.dist f g = 0"

- doc_string: "The right inverse of an isometry is an isometry."
  theorem: "{Î± : Type u} {Î² : Type v} [pseudo_emetric_space Î±] [pseudo_emetric_space Î²] {f : Î± â†’ Î²} {g : Î² â†’ Î±} (h : isometry f) (hg : function.right_inverse g f) : isometry g"

- doc_string: "**Alias** of the forward direction of le_sub_iff_add_le'`."
  theorem: "{Î± : Type u} [add_comm_group Î±] [has_le Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b c : Î±} : b â‰¤ c - a â†’ a + b â‰¤ c"

- doc_string: "A monoid `M` is finitely generated if and only if `monoid_algebra R M` is of finite type."
  theorem: "{R : Type u_1} {M : Type u_2} [comm_monoid M] [comm_ring R] [nontrivial R] : algebra.finite_type R (monoid_algebra R M) â†” monoid.fg M"

- doc_string: "An integral element of an algebra is algebraic."
  theorem: "(R : Type u) {A : Type v} [comm_ring R] [ring A] [algebra R A] [nontrivial R] {x : A} : is_integral R x â†’ is_algebraic R x"

- doc_string: "**Alias** of the forward direction of le_sub_iff_add_le`."
  theorem: "{Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b c : Î±} : a â‰¤ c - b â†’ a + b â‰¤ c"

- doc_string: "For `p â‰  0, p â‰  1, `padic_val_int p p` is 1."
  theorem: "{p : â„•} (hp : 1 < p) : padic_val_int p â†‘p = 1"

- doc_string: "A nontrivial monoid is not torsion-free if any nontrivial element has finite order."
  theorem: "(G : Type u_1) [monoid G] : Â¬monoid.is_torsion_free G â†” âˆƒ (g : G), g â‰  1 âˆ§ is_of_fin_order g"

- doc_string: " A nonempty preorder with no maximal element is infinite. This is not an instance to avoid a cycle with `infinite Î± â†’ nontrivial Î± â†’ nonempty Î±`."
  theorem: "{Î± : Type u_1} [preorder Î±] [nonempty Î±] [no_max_order Î±] : infinite Î±"

- doc_string: "**Alias** of mul_sub_left_distrib`."
  theorem: "{Î± : Type u} [non_unital_non_assoc_ring Î±] (a b c : Î±) : a * (b - c) = a * b - a * c"

- doc_string: "**Alias** of the reverse direction of multiset.Ioc_eq_zero_iff`."
  theorem: "{Î± : Type u_1} [preorder Î±] [locally_finite_order Î±] {a b : Î±} : Â¬a < b â†’ multiset.Ioc a b = 0"

- doc_string: "A monoid is a submonoid of itself."
  theorem: "{M : Type u_1} [monoid M] : is_submonoid set.univ"

- doc_string: "See `lt_tsub_iff_left_of_le` for a weaker statement in a partial order."
  theorem: "{Î± : Type u_1} {a b c : Î±} [linear_order Î±] [add_comm_semigroup Î±] [has_sub Î±] [has_ordered_sub Î±] : a < b - c â†” c + a < b"

- doc_string: "**Alias** of lt_of_lt_of_le`."
  theorem: "{Î± : Type u} [preorder Î±] {a b c : Î±} : a < b â†’ b â‰¤ c â†’ a < c"

- doc_string: "For any `y < 1` and any positive `x`, there exists `n : â„•` with `y ^ n < x`."
  theorem: "{Î± : Type u_1} [linear_ordered_field Î±] [archimedean Î±] {x y : Î±} (hx : 0 < x) (hy : y < 1) : âˆƒ (n : â„•), y ^ n < x"

- doc_string: "If `s` is bounded, then so is `s âˆ© t`"
  theorem: "{Î± : Type u} [preorder Î±] {s t : set Î±} (h : bdd_below s) : bdd_below (s âˆ© t)"

- doc_string: "If `1 < p`, then `q p`, the smallest prime factor of `mersenne p`, is more than 2."
  theorem: "(p' : â„•) : 2 < lucas_lehmer.q (p' + 2)"

- doc_string: "Any map on a subsingleton is an isometry"
  theorem: "{Î± : Type u} {Î² : Type v} [pseudo_emetric_space Î±] [pseudo_emetric_space Î²] {f : Î± â†’ Î²} [subsingleton Î±] : isometry f"

- doc_string: "The closure of the interval `(a, +âˆž)` is the closed interval `[a, +âˆž)`."
  theorem: "{Î± : Type u} [topological_space Î±] [linear_order Î±] [order_topology Î±] [densely_ordered Î±] (a : Î±) [no_max_order Î±] : closure (set.Ioi a) = set.Ici a"

- doc_string: "`cyclotomic n â„¤` is irreducible."
  theorem: "{n : â„•} (hpos : 0 < n) : irreducible (polynomial.cyclotomic n â„¤)"

- doc_string: "If `v` is a valuation on a division ring then `v(x) = 0` iff `x = 0`."
  theorem: "{Î“â‚€ : Type u_3} [linear_ordered_comm_monoid_with_zero Î“â‚€] [nontrivial Î“â‚€] {K : Type u_1} [division_ring K] (v : valuation K Î“â‚€) {x : K} : â‡‘v x = 0 â†” x = 0"

- doc_string: "A ray does not equal its own negation."
  theorem: "{R : Type u_1} [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] [no_zero_smul_divisors R M] (x : module.ray R M) : x â‰  -x"

- doc_string: "`{a}.min' _` is `a`."
  theorem: "{Î± : Type u_1} [linear_order Î±] (a : Î±) : {a}.min' _ = a"

- doc_string: "A list with negative sum must have positive length."
  theorem: "{M : Type u_3} [add_monoid M] [preorder M] (L : list M) (h : L.sum < 0) : 0 < L.length"

- doc_string: "If `s` has a greatest element, then it is bounded above."
  theorem: "{Î± : Type u} [preorder Î±] {s : set Î±} {a : Î±} (h : is_greatest s a) : bdd_above s"

- doc_string: "Assumes left covariance. The lemma assuming right covariance is `right.add_pos`."
  theorem: "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b : Î±} (ha : 0 < a) (hb : 0 < b) : 0 < a + b"

- doc_string: "An `add_monoid` is an `add_submonoid` of itself."
  theorem: "{M : Type u_1} [add_monoid M] : is_add_submonoid set.univ"

- doc_string: "`option.map f` is injective if `f` is injective."
  theorem: "{Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} (Hf : function.injective f) : function.injective (option.map f)"

- doc_string: "The set of fixed points of the conjugation action of `G` on itself is the center of `G`."
  theorem: "{G : Type u_2} [group G] : mul_action.fixed_points (conj_act G) G = â†‘(subgroup.center G)"

- doc_string: "**Alias** of the reverse direction of strict_anti_to_dual_comp_iff`."
  theorem: "{Î± : Type u} {Î² : Type v} [preorder Î±] [preorder Î²] {f : Î± â†’ Î²} : strict_mono f â†’ strict_anti (â‡‘order_dual.to_dual âˆ˜ f)"

- doc_string: "**Alias** of le_of_le_of_eq'`."
  theorem: "{Î± : Type u} [preorder Î±] {a b c : Î±} : b â‰¤ c â†’ a = b â†’ a â‰¤ c"

- doc_string: "Bernoulli's inequality for `n : â„•`, `-2 â‰¤ a`."
  theorem: "{R : Type uâ‚} [linear_ordered_ring R] {a : R} (H : -2 â‰¤ a) (n : â„•) : 1 + â†‘n * a â‰¤ (1 + a) ^ n"

- doc_string: "**Alias** of the forward direction of left.one_le_inv_iff`."
  theorem: "{Î± : Type u} [group Î±] [has_le Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a : Î±} : 1 â‰¤ aâ»Â¹ â†’ a â‰¤ 1"

- doc_string: "If an additive indicator function is not equal to `0` at a point, then that point is in the set."
  theorem: "{Î± : Type u_1} {M : Type u_4} [has_zero M] {s : set Î±} {f : Î± â†’ M} {a : Î±} (h : s.indicator f a â‰  0) : a âˆˆ s"

- doc_string: "Composing two associative operations of `f : Î± â†’ Î± â†’ Î±` on the left is equal to an associative operation on the left."
  theorem: "{Î± : Type u_1} (f : Î± â†’ Î± â†’ Î±) [is_associative Î± f] (x y : Î±) : f x âˆ˜ f y = f (f x y)"

- doc_string: "To match `mul_one_eq_id`."
  theorem: "{Mâ‚€ : Type u_1} [mul_zero_class Mâ‚€] : (Î» (_x : Mâ‚€), _x * 0) = function.const Mâ‚€ 0"

- doc_string: " One of de Morgan's laws: the negation of a conjunction is logically equivalent to the disjunction of the negations."
  theorem: "{a b : Prop} : Â¬(a âˆ§ b) â†” Â¬a âˆ¨ Â¬b"

- doc_string: 'Every pair `![c, d]` of coprime integers is the "bottom_row" of some element `g=[[*,*],[c,d]]` of `SL(2,â„¤)`.'
  theorem: "{R : Type u_1} [comm_ring R] : set.surj_on (Î» (g : matrix.special_linear_group (fin 2) R), â†‘g 1) set.univ {cd : fin 2 â†’ R | is_coprime (cd 0) (cd 1)}"

- doc_string: "**Alias** of left.one_lt_mul'`."
  theorem: "{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a b : Î±} (ha : 1 < a) (hb : 1 < b) : 1 < a * b"

- doc_string: "Given binary relations `r, s` with `r` contained in `s`, the smallest additive congruence relation containing `s` contains the smallest additive congruence relation containing `r`."
  theorem: "{M : Type u_1} [has_add M] {r s : M â†’ M â†’ Prop} (h : âˆ€ (x y : M), r x y â†’ s x y) : add_con_gen r â‰¤ add_con_gen s"

- doc_string: " A set `s` is not bounded below if and only if for each `x` there exists `y âˆˆ s` that is less than `x`. A version for preorders is called `not_bdd_below_iff'`."
  theorem: "{Î± : Type u_1} [linear_order Î±] {s : set Î±} : Â¬bdd_below s â†” âˆ€ (x : Î±), âˆƒ (y : Î±) (H : y âˆˆ s), y < x"

- doc_string: " The cardinality of `fin (bit0 k)` is even, `fact` version. This `fact` is needed as an instance by `matrix.special_linear_group.has_neg`."
  theorem: "{k : â„•} : fact (even (fintype.card (fin (bit0 k))))"

- doc_string: "`raise l n` is an non-decreasing sequence."
  theorem: "(l : list â„•) (n : â„•) : list.sorted has_le.le (denumerable.raise l n)"

- doc_string: "A right-regular element of a `nontrivial` `mul_zero_class` is non-zero."
  theorem: "{R : Type u_1} {a : R} [mul_zero_class R] [nontrivial R] (ra : is_right_regular a) : a â‰  0"

- doc_string: "A Hausdorff space with a clopen basis is totally separated."
  theorem: "{Î± : Type u} [topological_space Î±] [t2_space Î±] (h : topological_space.is_topological_basis {s : set Î± | is_clopen s}) : totally_separated_space Î±"

- doc_string: "**Alias** of the reverse direction of finset.Ioc_eq_empty_iff`."
  theorem: "{Î± : Type u_1} [preorder Î±] [locally_finite_order Î±] {a b : Î±} : Â¬a < b â†’ finset.Ioc a b = âˆ…"

- doc_string: "**Alias** of the forward direction of lt_inv_mul_iff_mul_lt`."
  theorem: "{Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a b c : Î±} : b < aâ»Â¹ * c â†’ a * b < c"

- doc_string: "If multiplying by `1` on either side is the identity, `1` is regular."
  theorem: "{R : Type u_1} [mul_one_class R] : is_regular 1"

- doc_string: "Construct `has_binary_product Q P` from `has_binary_product P Q`. This can't be an instance, as it would cause a loop in typeclass search."
  theorem: "{C : Type u} [category_theory.category C] (P Q : C) [category_theory.limits.has_binary_product P Q] : category_theory.limits.has_binary_product Q P"

- doc_string: "If X is is_compact then prâ‚‚ : X Ã— Y â†’ Y is a closed map"
  theorem: "{X : Type u_1} [topological_space X] [compact_space X] {Y : Type u_2} [topological_space Y] : is_closed_map prod.snd"

- doc_string: " An equivalent definition for prime powers: `n` is a prime power iff there is a unique prime dividing it."
  theorem: "{n : â„•} : is_prime_pow n â†” âˆƒ! (p : â„•), nat.prime p âˆ§ p âˆ£ n"

- doc_string: "Every point is a fixed point of `id`."
  theorem: "{Î± : Type u} (x : Î±) : function.is_fixed_pt id x"

- doc_string: "Extensionality rule for additive congruence relations."
  theorem: "{M : Type u_1} [has_add M] {c d : add_con M} (H : âˆ€ (x y : M), â‡‘c x y â†” â‡‘d x y) : c = d"

- doc_string: "See also `algebra.norm_eq_zero_iff'` if you already have rewritten with `algebra.norm_apply`."
  theorem: "{K : Type u_4} {L : Type u_5} [field K] [field L] [algebra K L] [finite_dimensional K L] {x : L} : â‡‘(algebra.norm K) x = 0 â†” x = 0"

- doc_string: "Characterize the equality of points with the vanishing of the nonnegative distance"
  theorem: "{Î³ : Type w} [metric_space Î³] {x y : Î³} : has_nndist.nndist x y = 0 â†” x = y"

- doc_string: "**Alias** of the forward direction of sub_pos`."
  theorem: "{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b : Î±} : 0 < a - b â†’ b < a"

- doc_string: "The Legendre symbol of `a^2` at `p` is 1 if `p âˆ¤ a`."
  theorem: "(p : â„•) [fact (nat.prime p)] (a : â„¤) (ha : â†‘a â‰  0) : zmod.legendre_sym p (a ^ 2) = 1"

- doc_string: "Dedekind's linear independence of characters"
  theorem: "(G : Type u_1) [monoid G] (L : Type u_2) [comm_ring L] [no_zero_divisors L] : linear_independent L (Î» (f : G â†’* L), â‡‘f)"

- doc_string: "The product of any function over an empty set is `1`."
  theorem: "{Î± : Type u_1} {M : Type u_5} [comm_monoid M] {f : Î± â†’ M} : finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ âˆ…), f i)) = 1"

- doc_string: "The function `x â†¦ xâ»Â¹` tends to `+âˆž` on the right of `0`."
  theorem: "{Î± : Type u} [linear_ordered_field Î±] [topological_space Î±] [order_topology Î±] : filter.tendsto (Î» (x : Î±), xâ»Â¹) (nhds_within 0 (set.Ioi 0)) filter.at_top"

- doc_string: "Composition by an injective function on the left is itself injective."
  theorem: "{Î± : Sort u_1} {Î² : Sort u_2} {Î³ : Sort u_3} {g : Î² â†’ Î³} (hg : function.injective g) : function.injective (function.comp g)"

- doc_string: " If the codomain of an injective function is a subsingleton, then the domain is a subsingleton as well."
  theorem: "{Î± : Sort u} {Î² : Sort v} {f : Î± â†’ Î²} (hf : function.injective f) [subsingleton Î²] : subsingleton Î±"

- doc_string: "Subtracting the point `p` is an injective function."
  theorem: "{G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] (p : P) : function.injective (Î» (_x : P), _x -áµ¥ p)"

- doc_string: "**Alias** of not_is_max_of_lt`."
  theorem: "{Î± : Type u_1} [preorder Î±] {a b : Î±} (h : a < b) : Â¬is_max a"

- doc_string: "If `0 < n`, then `a 1` has order `2 * n`."
  theorem: "{n : â„•} : order_of (quaternion_group.a 1) = 2 * n"

- doc_string: "A finset is bounded above."
  theorem: "{Î± : Type u} [semilattice_sup Î±] [nonempty Î±] (s : finset Î±) : bdd_above â†‘s"

- doc_string: "If all points are equal to a given point `x`, then `Î±` is a subsingleton."
  theorem: "{Î± : Sort u_1} (x : Î±) (h : âˆ€ (y : Î±), y = x) : subsingleton Î±"

- doc_string: "**Alias** of left.one_lt_mul_of_lt_of_le`."
  theorem: "{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a b : Î±} (ha : 1 < a) (hb : 1 â‰¤ b) : 1 < a * b"

- doc_string: "The intersection of two `add_submonoid`s of an `add_monoid` `M` is an `add_submonoid` of M."
  theorem: "{M : Type u_1} [add_monoid M] {sâ‚ sâ‚‚ : set M} (isâ‚ : is_add_submonoid sâ‚) (isâ‚‚ : is_add_submonoid sâ‚‚) : is_add_submonoid (sâ‚ âˆ© sâ‚‚)"

- doc_string: "`same_ray.neg` as an `iff`."
  theorem: "{R : Type u_1} [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {x y : M} : same_ray R (-x) (-y) â†” same_ray R x y"

- doc_string: "Assumes left covariance. The lemma assuming right covariance is `right.add_neg`."
  theorem: "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b : Î±} (ha : a < 0) (hb : b < 0) : a + b < 0"

- doc_string: "If a direct product has finite order then so does each component."
  theorem: "{Î· : Type u_1} {Gs : Î· â†’ Type u_2} [Î  (i : Î·), monoid (Gs i)] {x : Î  (i : Î·), Gs i} (h : is_of_fin_order x) (i : Î·) : is_of_fin_order (x i)"

- doc_string: "If `x` and `y` are joined in the set `F`, then they are joined in the subtype `F`."
  theorem: "{X : Type u_1} [topological_space X] {x y : X} {F : set X} (h : joined_in F x y) : joined âŸ¨x, _âŸ© âŸ¨y, _âŸ©"

- doc_string: "**Alias** of the forward direction of measurable_iff_comap_le`."
  theorem: "{Î± : Type u_1} {Î² : Type u_2} {mâ‚ : measurable_space Î±} {mâ‚‚ : measurable_space Î²} {f : Î± â†’ Î²} : measurable f â†’ measurable_space.comap f mâ‚‚ â‰¤ mâ‚"

- doc_string: "**Alias** of the reverse direction of le_sub_iff_add_le'`."
  theorem: "{Î± : Type u} [add_comm_group Î±] [has_le Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b c : Î±} : a + b â‰¤ c â†’ b â‰¤ c - a"

- doc_string: "In a semigroup, the product of right-regular elements is right-regular."
  theorem: "{R : Type u_1} {a b : R} [semigroup R] (rra : is_right_regular a) (rrb : is_right_regular b) : is_right_regular (a * b)"

- doc_string: "If two points belong to some set, their edistance is bounded by the diameter of the set"
  theorem: "{Î± : Type u} [pseudo_emetric_space Î±] {x y : Î±} {s : set Î±} (hx : x âˆˆ s) (hy : y âˆˆ s) : has_edist.edist x y â‰¤ emetric.diam s"

- doc_string: " For `f : â„• â†’ â„â‰¥0`, then `âˆ‘' k, f (k + i)` tends to zero. This does not require a summability assumption on `f`, as otherwise all sums are zero."
  theorem: "(f : â„• â†’ nnreal) : filter.tendsto (Î» (i : â„•), âˆ‘' (k : â„•), f (k + i)) filter.at_top (nhds 0)"

- doc_string: "Elements of an add left cancel semigroup are add-left-regular."
  theorem: "{R : Type u_1} [add_left_cancel_semigroup R] (g : R) : is_add_left_regular g"

- doc_string: "A sort of triangle inequality."
  theorem: "{Î± : Type u} [linear_order Î±] {a b c : Î±} : set.interval a c âŠ† set.interval a b âˆª set.interval b c"

- doc_string: "**Alias** of `left.add_neg`."
  theorem: "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b : Î±} (ha : a < 0) (hb : b < 0) : a + b < 0"

- doc_string: "A finite field has prime power cardinality."
  theorem: "{Î± : Type u_1} [fintype Î±] [field Î±] : is_prime_pow (fintype.card Î±)"

- doc_string: "A group is finitely generated if and only if it is finitely generated as a monoid."
  theorem: "{G : Type u_3} [group G] : group.fg G â†” monoid.fg G"

- doc_string: "**Alias** of the forward direction of left.one_lt_inv_iff`."
  theorem: "{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a : Î±} : 0 < -a â†’ a < 0"

- doc_string: "The second projection in a product is a topological fiber bundle."
  theorem: "{B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] : is_topological_fiber_bundle F prod.snd"

- doc_string: "The function `x ^ (1 / x)` tends to `1` at `+âˆž`."
  theorem: " : filter.tendsto (Î» (x : â„), x ^ (1 / x)) filter.at_top (nhds 1)"

- doc_string: "A set in a linear ordered field is strictly convex if and only if it is convex."
  theorem: "{ð•œ : Type u_1} [linear_ordered_field ð•œ] [topological_space ð•œ] [order_topology ð•œ] {s : set ð•œ} : strict_convex ð•œ s â†” convex ð•œ s"

- doc_string: "If `C` has a terminal object and binary products, then it has finite products."
  theorem: "{C : Type u} [category_theory.category C] [category_theory.limits.has_binary_products C] [category_theory.limits.has_terminal C] : category_theory.limits.has_finite_products C"

- doc_string: "Extra simp lemma that `dsimp` can use. `simp` will never use this."
  theorem: "{G : Type u_10} [add_group G] (a : G) : â‡‘(equiv.symm (equiv.add_right a)) = Î» (x : G), x + -a"

- doc_string: "**Alias** of lt_of_le_not_le`."
  theorem: "{Î± : Type u} [preorder Î±] {a b : Î±} : a â‰¤ b â†’ Â¬b â‰¤ a â†’ a < b"

- doc_string: "A stronger version of `mul_left_injective`"
  theorem: "{Î± : Type u} [decidable_eq Î±] (i j : Î±) : function.involutive (Î» (_x : equiv.perm Î±), _x * equiv.swap i j)"

- doc_string: " If `u` is a monotone function with linear ordered codomain and the range of `u` is not bounded below, then `tendsto u at_bot at_bot`."
  theorem: "{Î¹ : Type u_1} {Î± : Type u_3} [preorder Î¹] [linear_order Î±] {u : Î¹ â†’ Î±} (h : monotone u) (H : Â¬bdd_below (set.range u)) : filter.tendsto u filter.at_bot filter.at_bot"

- doc_string: " Right `mul` by a `k : Î±` over `[ring Î±]` is injective, if `k` is not a zero divisor. The typeclass that restricts all terms of `Î±` to have this property is `no_zero_divisors`."
  theorem: "{Î± : Type u} [non_unital_non_assoc_ring Î±] (k : Î±) (h : âˆ€ (x : Î±), x * k = 0 â†’ x = 0) : is_right_regular k"

- doc_string: "**Alias** of btw_cyclic_right`."
  theorem: "{Î± : Type u_1} [circular_preorder Î±] {a b c : Î±} (h : has_btw.btw a b c) : has_btw.btw c a b"

- doc_string: "See `lt_of_tsub_lt_tsub_right_of_le` for a weaker statement in a partial order."
  theorem: "{Î± : Type u_1} {a b c : Î±} [linear_order Î±] [add_comm_semigroup Î±] [has_sub Î±] [has_ordered_sub Î±] (h : a - c < b - c) : a < b"

- doc_string: "In a locally compact Tâ‚‚ space, every point has an open neighborhood with compact closure"
  theorem: "{Î± : Type u} [topological_space Î±] [locally_compact_space Î±] [t2_space Î±] (x : Î±) : âˆƒ (U : set Î±), is_open U âˆ§ x âˆˆ U âˆ§ is_compact (closure U)"

- doc_string: "The real logarithm function tends to `+âˆž` at `+âˆž`."
  theorem: " : filter.tendsto real.log filter.at_top filter.at_top"

- doc_string: " An integral domain in which there is an irreducible element `p` such that every nonzero element is associated to a power of `p` is a unique factorization domain. See `discrete_valuation_ring.of_has_unit_mul_pow_irreducible_factorization`."
  theorem: "{R : Type u_1} [comm_ring R] (hR : discrete_valuation_ring.has_unit_mul_pow_irreducible_factorization R) [is_domain R] : unique_factorization_monoid R"

- doc_string: "Dividing out by a prime factor reduces the padic_val_nat by 1."
  theorem: "{p : â„•} [p_prime : fact (nat.prime p)] {b : â„•} (dvd : p âˆ£ b) : padic_val_nat p (b / p) = padic_val_nat p b - 1"

- doc_string: "If a function is `antiperiodic` with antiperiod `c`, then it is also `periodic` with period  `2 * c`."
  theorem: "{Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} {c : Î±} [semiring Î±] [add_group Î²] (h : function.antiperiodic f c) : function.periodic f (2 * c)"

- doc_string: "The intersection of an indexed set of submonoids of a monoid `M` is a submonoid of `M`."
  theorem: "{M : Type u_1} [monoid M] {Î¹ : Sort u_2} {s : Î¹ â†’ set M} (h : âˆ€ (y : Î¹), is_submonoid (s y)) : is_submonoid (set.Inter s)"

- doc_string: "`same_ray` is reflexive."
  theorem: "{R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] (x : M) : same_ray R x x"

- doc_string: "This lemma is analogous to `quotient.mk_out'`."
  theorem: "{Î¹ : Type u_1} {Î± : Type u_2} {s : Î¹ â†’ set Î±} (hs : indexed_partition s) (x : Î±) : â‡‘(hs.out) (hs.proj x) = hs.some (hs.index x)"

- doc_string: "`option Î±` is a `subsingleton` if and only if `Î±` is empty."
  theorem: "{Î± : Type u_1} : subsingleton (option Î±) â†” is_empty Î±"

- doc_string: "**KÃ¶nig's theorem**"
  theorem: "{Î¹ : Type u_1} (f g : Î¹ â†’ cardinal) (H : âˆ€ (i : Î¹), f i < g i) : cardinal.sum f < cardinal.prod g"

- doc_string: "**Alias** of `left.add_pos'`."
  theorem: "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : 0 < a) (hb : 0 < b) : 0 < a + b"

- doc_string: "Associative racks are uninteresting."
  theorem: "{R : Type u_1} [rack R] {x y z : R} : shelf.act x (shelf.act y z) = shelf.act (shelf.act x y) z â†” shelf.act x z = z"

- doc_string: " The Double Negation Theorem: `Â¬ Â¬ P` is equivalent to `P`. The left-to-right direction, double negation elimination (DNE), is classically true but not constructively."
  theorem: "{a : Prop} : Â¬Â¬a â†” a"

- doc_string: " A nonempty separable space admits a sequence with dense range. Instead of running `cases` on the conclusion of this lemma, you might want to use `topological_space.dense_seq` and `topological_space.dense_range_dense_seq`.  If `Î±` might be empty, then `exists_countable_dense` is the main way to use separability of `Î±`."
  theorem: "(Î± : Type u) [t : topological_space Î±] [topological_space.separable_space Î±] [nonempty Î±] : âˆƒ (u : â„• â†’ Î±), dense_range u"

- doc_string: "Inverses of elements of finite order have finite order."
  theorem: "{G : Type u} [group G] {x : G} : is_of_fin_order xâ»Â¹ â†” is_of_fin_order x"

- doc_string: " `finsupp.single a b` is injective in `b`. For the statement that it is injective in `a`, see `finsupp.single_left_injective`"
  theorem: "{Î± : Type u_1} {M : Type u_5} [has_zero M] (a : Î±) : function.injective (finsupp.single a)"

- doc_string: "Rectangles formed by Ï€-systems form a Ï€-system."
  theorem: "{Î± : Type u_1} {Î² : Type u_3} {C : set (set Î±)} {D : set (set Î²)} (hC : is_pi_system C) (hD : is_pi_system D) : is_pi_system (set.image2 has_set_prod.prod C D)"

- doc_string: " We can write both `n.factorization p` and `n.factors.count p` to represent the power of `p` in the factorization of `n`: we declare the former to be the simp-normal form. However, since `factorization` is a finsupp it's noncomputable.  This theorem can also be used in reverse to compute values of `factorization n p` when required."
  theorem: "{n p : â„•} : list.count p n.factors = â‡‘(n.factorization) p"

- doc_string: " A set `s` is not bounded above if and only if for each `x` there exists `y âˆˆ s` such that `x` is not greater than or equal to `y`. This version only assumes `preorder` structure and uses `Â¬(y â‰¤ x)`. A version for linear orders is called `not_bdd_above_iff`."
  theorem: "{Î± : Type u} [preorder Î±] {s : set Î±} : Â¬bdd_above s â†” âˆ€ (x : Î±), âˆƒ (y : Î±) (H : y âˆˆ s), Â¬y â‰¤ x"

- doc_string: " Pythagorean triples are interchangable, i.e `x * x + y * y = y * y + x * x = z * z`. This comes from additive commutativity."
  theorem: "{x y z : â„¤} : pythagorean_triple x y z â†” pythagorean_triple y x z"

- doc_string: "`int.clog b` and `zpow b` (almost) form a Galois connection."
  theorem: "{R : Type u_1} [linear_ordered_field R] [floor_ring R] {b : â„•} (hb : 1 < b) {x : â„¤} {r : R} (hr : 0 < r) : r â‰¤ â†‘b ^ x â†” int.clog b r â‰¤ x"

- doc_string: "Induction principle starting at a non-zero number. For maps to a `Sort*` see `le_rec_on`."
  theorem: "{P : â„• â†’ Prop} {m : â„•} (h0 : P m) (h1 : âˆ€ (n : â„•), m â‰¤ n â†’ P n â†’ P (n + 1)) (n : â„•) : m â‰¤ n â†’ P n"

- doc_string: "Inverses of elements of finite additive order have finite additive order."
  theorem: "{G : Type u} [add_group G] {x : G} : is_of_fin_add_order (-x) â†” is_of_fin_add_order x"

- doc_string: "The minimal distance to a set is continuous in point"
  theorem: "{Î± : Type u} [pseudo_metric_space Î±] (s : set Î±) : continuous (Î» (x : Î±), metric.inf_dist x s)"

- doc_string: "**Alias** of the reverse direction of measurable_iff_comap_le`."
  theorem: "{Î± : Type u_1} {Î² : Type u_2} {mâ‚ : measurable_space Î±} {mâ‚‚ : measurable_space Î²} {f : Î± â†’ Î²} : measurable_space.comap f mâ‚‚ â‰¤ mâ‚ â†’ measurable f"

- doc_string: "Assumes left covariance."
  theorem: "{Î± : Type u} {a b : Î±} [mul_zero_class Î±] [partial_order Î±] [zero_lt.pos_mul_mono Î±] (ha : 0 â‰¤ a) (hb : 0 â‰¤ b) : 0 â‰¤ a * b"

- doc_string: " The auxiliary set corresponding to the composition of partial sums asymptotically contains all possible compositions."
  theorem: " : filter.tendsto (Î» (N : â„•), formal_multilinear_series.comp_partial_sum_target 0 N N) filter.at_top filter.at_top"

- doc_string: "A finitely presented algebra is of finite type."
  theorem: "{R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] : algebra.finite_presentation R A â†’ algebra.finite_type R A"

- doc_string: "`a < b` as natural numbers if and only if `a < b` in `fin n`."
  theorem: "{n : â„•} {a b : fin n} : â†‘a < â†‘b â†” a < b"

- doc_string: "Right multiplication in a ring is an additive monoid morphism."
  theorem: "{Î³ : Type u_1} [non_unital_non_assoc_semiring Î³] (x : Î³) : is_add_monoid_hom (Î» (y : Î³), y * x)"

- doc_string: "**Alias** of lt_or_eq_of_le`."
  theorem: "{Î± : Type u} [partial_order Î±] {a b : Î±} : a â‰¤ b â†’ a < b âˆ¨ a = b"

- doc_string: "See also `continuous_map.continuous_eval_const`"
  theorem: "{Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] [locally_compact_space Î±] (a : Î±) : continuous (Î» (f : C(Î±, Î²)), â‡‘f a)"

- doc_string: "**Alias** of the forward direction of order.pred_lt_pred_iff`."
  theorem: "{Î± : Type u_1} [preorder Î±] [pred_order Î±] {a b : Î±} [no_min_order Î±] : order.pred a < order.pred b â†’ a < b"

- doc_string: "Given two elements `b`, `c` of a `cancel_monoid_with_zero` and a nonzero element `a`, `a*b` divides `a*c` iff `b` divides `c`."
  theorem: "{Î± : Type u_1} [cancel_monoid_with_zero Î±] {a b c : Î±} (ha : a â‰  0) : a * b âˆ£ a * c â†” b âˆ£ c"

- doc_string: " Commutativity of additive actions is a symmetric relation. This lemma can't be an instance because this would cause a loop in the instance search graph."
  theorem: "(M : Type u_1) (N : Type u_2) (Î± : Type u_3) [has_vadd M Î±] [has_vadd N Î±] [vadd_comm_class M N Î±] : vadd_comm_class N M Î±"

- doc_string: "In a commutative monoid, an element `a` divides an element `b` iff `a` divides all left    associates of `b`."
  theorem: "{Î± : Type u_1} [comm_monoid Î±] (a b u : Î±) (hu : is_unit u) : a âˆ£ u * b â†” a âˆ£ b"

- doc_string: "Assumes left covariance."
  theorem: "{Î± : Type u} {a b : Î±} [mul_one_class Î±] [has_zero Î±] [preorder Î±] [zero_lt.pos_mul_mono Î±] (ha : 1 â‰¤ a) (hb : 1 â‰¤ b) (a0 : 0 < a) : 1 â‰¤ a * b"

- doc_string: "The intersection of an open dense set with a dense set is a dense set."
  theorem: "{Î± : Type u} [topological_space Î±] {s t : set Î±} (hs : dense s) (ht : dense t) (hso : is_open s) : dense (s âˆ© t)"

- doc_string: "An element `a` is `M`-regular if and only if a positive power of `a` is `M`-regular."
  theorem: "{R : Type u_1} {M : Type u_3} {a : R} [monoid R] [mul_action R M] {n : â„•} (n0 : 0 < n) : is_smul_regular M (a ^ n) â†” is_smul_regular M a"

- doc_string: "Taylor's formula."
  theorem: "{R : Type u_1} [comm_ring R] (f : polynomial R) (r : R) : (â‡‘(polynomial.taylor r) f).sum (Î» (i : â„•) (a : R), â‡‘polynomial.C a * (polynomial.X - â‡‘polynomial.C r) ^ i) = f"

- doc_string: "Any element additively semiconjugates `0` to `0`."
  theorem: "{M : Type u} [add_zero_class M] (a : M) : add_semiconj_by a 0 0"

- doc_string: " The `n+1`-th iterated derivative can be obtained by taking the `n`-th derivative of the derivative."
  theorem: "{ð•œ : Type u_1} [nondiscrete_normed_field ð•œ] {F : Type u_2} [normed_group F] [normed_space ð•œ F] {n : â„•} {f : ð•œ â†’ F} : iterated_deriv (n + 1) f = iterated_deriv n (deriv f)"

- doc_string: "Assumes left covariance."
  theorem: "{Î± : Type u} {a b : Î±} [mul_zero_one_class Î±] [partial_order Î±] [zero_lt.pos_mul_mono Î±] (ha : 1 â‰¤ a) (hb : 1 â‰¤ b) (a0 : 0 â‰¤ a) : 1 â‰¤ a * b"

- doc_string: "Assumes right covariance. The lemma assuming left covariance is `left.add_nonneg`."
  theorem: "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±} (ha : 0 â‰¤ a) (hb : 0 â‰¤ b) : 0 â‰¤ a + b"

- doc_string: " The main proof-by-reflection theorem. Given reflected csring expressions `râ‚` and `râ‚‚` plus a storage `t` of atoms, if both expressions go to the same Horner normal form, then the original non-reflected expressions are equal. `H` follows from kernel reduction and is therefore `rfl`."
  theorem: "{Î± : Type u_1} [comm_semiring Î±] (t : tree Î±) (râ‚ râ‚‚ : tactic.ring2.csring_expr) (H : tactic.ring2.horner_expr.of_csexpr râ‚ = tactic.ring2.horner_expr.of_csexpr râ‚‚) : tactic.ring2.csring_expr.eval t râ‚ = tactic.ring2.csring_expr.eval t râ‚‚"

- doc_string: "An integral domain in which there is an irreducible element `p` such that every nonzero element is associated to a power of `p` is a discrete valuation ring."
  theorem: "{R : Type u} [comm_ring R] [is_domain R] (hR : discrete_valuation_ring.has_unit_mul_pow_irreducible_factorization R) : discrete_valuation_ring R"

- doc_string: "We have `2 â‰  0` in a nontrivial ring whose characteristic is not `2`."
  theorem: "{R : Type u_1} [non_assoc_semiring R] [nontrivial R] (hR : ring_char R â‰  2) : 2 â‰  0"

- doc_string: "`of_fn` on an empty domain is the empty list."
  theorem: "{Î± : Type u} (f : fin 0 â†’ Î±) : list.of_fn f = list.nil"

- doc_string: "In a commutative monoid, an element `a` divides an element `b` iff all  left associates of `a` divide `b`."
  theorem: "{Î± : Type u_1} [comm_monoid Î±] (a b u : Î±) (hu : is_unit u) : u * a âˆ£ b â†” a âˆ£ b"

- doc_string: "Harmonic series is not unconditionally summable."
  theorem: " : Â¬summable (Î» (n : â„•), (â†‘n)â»Â¹)"

- doc_string: "The characteristic equals the exponential characteristic iff the former is prime."
  theorem: "(R : Type u) [semiring R] (p q : â„•) [hp : char_p R p] [hq : exp_char R q] : p = q â†” nat.prime p"

- doc_string: "If `X` has subobject lattice `{âŠ¥, âŠ¤}`, then `X` is simple."
  theorem: "{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] (X : C) [is_simple_order (category_theory.subobject X)] : category_theory.simple X"

- doc_string: "If a category has all binary coproducts and all coequalizers, then it also has all pushouts.    As usual, this is not an instance, since there may be a more direct way to construct    pushouts."
  theorem: "(C : Type u) [ð’ž : category_theory.category C] [category_theory.limits.has_binary_coproducts C] [category_theory.limits.has_coequalizers C] : category_theory.limits.has_pushouts C"

- doc_string: "The inverse of a group homomorphism is a group homomorphism if the target is commutative."
  theorem: "{Î± : Type u_1} {Î² : Type u_2} [group Î±] [comm_group Î²] {f : Î± â†’ Î²} (hf : is_group_hom f) : is_group_hom (Î» (a : Î±), (f a)â»Â¹)"

- doc_string: " The product of a list of positive natural numbers is positive, and likewise for any nontrivial ordered semiring."
  theorem: "{R : Type u_8} [ordered_semiring R] [nontrivial R] (l : list R) (h : âˆ€ (a : R), a âˆˆ l â†’ 0 < a) : 0 < l.prod"

- doc_string: "If a subgroup of a topological group has `1` in its interior, then it is open."
  theorem: "{G : Type u_1} [group G] [topological_space G] [topological_group G] {H : subgroup G} (h_1_int : 1 âˆˆ interior â†‘H) : is_open â†‘H"

- doc_string: "The cross product of two vectors is perpendicular to the first vector."
  theorem: "{R : Type u_1} [comm_ring R] (v w : fin 3 â†’ R) : matrix.dot_product v (â‡‘(â‡‘cross_product v) w) = 0"

- doc_string: "**Alias** of the forward direction of is_compact_iff_ultrafilter_le_nhds`."
  theorem: "{Î± : Type u} [topological_space Î±] {s : set Î±} : is_compact s â†’ âˆ€ (f : ultrafilter Î±), â†‘f â‰¤ filter.principal s â†’ (âˆƒ (a : Î±) (H : a âˆˆ s), â†‘f â‰¤ nhds a)"

- doc_string: "There is no surjection from `Î± : Type u` into `Type u`. This theorem  demonstrates why `Type : Type` would be inconsistent in Lean."
  theorem: "{Î± : Type u} (f : Î± â†’ Type (max u v)) : Â¬function.surjective f"

- doc_string: "See also `continuous_map.continuous_eval'`"
  theorem: "{Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [compact_space Î±] [metric_space Î²] : continuous (Î» (p : C(Î±, Î²) Ã— Î±), â‡‘(p.fst) p.snd)"

- doc_string: " The inverse of a map which preserves multiplication, preserves multiplication when the target is commutative."
  theorem: "{Î± : Type u_1} {Î² : Type u_2} [has_mul Î±] [comm_group Î²] {f : Î± â†’ Î²} (hf : is_mul_hom f) : is_mul_hom (Î» (a : Î±), (f a)â»Â¹)"

- doc_string: "The set of natural number powers of an element of a monoid `M` is a submonoid of `M`."
  theorem: "{M : Type u_1} [monoid M] (x : M) : is_submonoid (powers x)"

- doc_string: "Zero additively semiconjugates any element to itself."
  theorem: "{M : Type u} [add_zero_class M] (x : M) : add_semiconj_by 0 x x"

- doc_string: "`int.clog b` and `zpow b` (almost) form a Galois connection."
  theorem: "{R : Type u_1} [linear_ordered_field R] [floor_ring R] {b : â„•} (hb : 1 < b) {x : â„¤} {r : R} (hr : 0 < r) : â†‘b ^ x < r â†” x < int.clog b r"

- doc_string: "If `t` is bounded, then so is `s âˆ© t`"
  theorem: "{Î± : Type u} [preorder Î±] {s t : set Î±} (h : bdd_below t) : bdd_below (s âˆ© t)"

- doc_string: "If `A` is subterminal, the unique morphism from it to the terminal object is a monomorphism. The converse of `is_subterminal_of_mono_terminal_from`."
  theorem: "{C : Type uâ‚} [category_theory.category C] {A : C} [category_theory.limits.has_terminal C] (hA : category_theory.is_subterminal A) : category_theory.mono (category_theory.limits.terminal.from A)"

- doc_string: "The image of an `add_monoid` hom is an `add_submonoid` of the codomain."
  theorem: "{M : Type u_1} [add_monoid M] {Î³ : Type u_2} [add_monoid Î³] {f : M â†’ Î³} (hf : is_add_monoid_hom f) : is_add_submonoid (set.range f)"

- doc_string: "Equality behind `commute a b`; useful for rewriting."
  theorem: "{S : Type u_1} [has_mul S] {a b : S} (h : commute a b) : a * b = b * a"

- doc_string: "The determinant of `conj_lie`, as a linear map."
  theorem: " : â‡‘linear_map.det â†‘(complex.conj_lie.to_linear_equiv) = -1"

- doc_string: "`dvd` is injective in the left argument"
  theorem: " : function.injective has_dvd.dvd"

- doc_string: " The sequential closure of a set is contained in the closure of that set. The converse is not true."
  theorem: "{X : Type u_1} [topological_space X] (s : set X) : seq_closure s âŠ† closure s"

- doc_string: "The composition of `quotient.mk` and a function with dense range has dense range."
  theorem: "{Î± : Type u} {Î² : Type v} [setoid Î±] [topological_space Î±] {f : Î² â†’ Î±} (hf : dense_range f) : dense_range (quotient.mk âˆ˜ f)"

- doc_string: "**Alias** of `left.add_pos_of_nonneg_of_pos`."
  theorem: "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b : Î±} (ha : 0 â‰¤ a) (hb : 0 < b) : 0 < a + b"

- doc_string: " **Hausdorff's maximality principle**  There exists a maximal totally ordered set of `Î±`. Note that we do not require `Î±` to be partially ordered by `r`."
  theorem: "{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} : is_max_chain r (max_chain r)"

- doc_string: "Assumes left covariance."
  theorem: "{Î± : Type u} {a b : Î±} [mul_one_class Î±] [has_zero Î±] [preorder Î±] [zero_lt.pos_mul_mono Î±] (ha : a < 1) (hb : b â‰¤ 1) (a0 : 0 < a) : a * b < 1"

- doc_string: "**Alias** of the reverse direction of is_min_to_dual_iff`."
  theorem: "{Î± : Type u_1} [has_le Î±] {a : Î±} : is_max a â†’ is_min (â‡‘order_dual.to_dual a)"

- doc_string: "Indexed version of the above lemma `exists_lt_of_lt_cSup`. When `b < supr f`, there is an element `i` such that `b < f i`."
  theorem: "{Î± : Type u_1} {Î¹ : Sort u_3} [conditionally_complete_linear_order Î±] {b : Î±} [nonempty Î¹] {f : Î¹ â†’ Î±} (h : b < supr f) : âˆƒ (i : Î¹), b < f i"

- doc_string: "A closed interval in a densely ordered conditionally complete linear order is preconnected."
  theorem: "{Î± : Type u} [conditionally_complete_linear_order Î±] [topological_space Î±] [order_topology Î±] [densely_ordered Î±] {a b : Î±} : is_preconnected (set.Icc a b)"

- doc_string: "Two filters are equal when their underlying sets are equal."
  theorem: "{P : Type u_1} [preorder P] (s t : order.pfilter P) (h : â†‘s = â†‘t) : s = t"

- doc_string: " In a linear ordered field, for positive `a` and `b` we have `aâ»Â¹ â‰¤ b â†” bâ»Â¹ â‰¤ a`. See also `inv_le_of_inv_le` for a one-sided implication with one fewer assumption."
  theorem: "{Î± : Type u_1} [linear_ordered_field Î±] {a b : Î±} (ha : 0 < a) (hb : 0 < b) : aâ»Â¹ â‰¤ b â†” bâ»Â¹ â‰¤ a"

- doc_string: "Assumes left covariance. The lemma assuming right covariance is `right.add_nonneg`."
  theorem: "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : 0 â‰¤ a) (hb : 0 â‰¤ b) : 0 â‰¤ a + b"

- doc_string: "A finite dimensional space has positive `finrank` iff it is nontrivial."
  theorem: "{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] : 0 < finite_dimensional.finrank K V â†” nontrivial V"

- doc_string: "The range of any family of ordinals is bounded above. See also `lsub_not_mem_range`."
  theorem: "{Î¹ : Type u} (f : Î¹ â†’ ordinal) : bdd_above (set.range f)"

- doc_string: "**Alias** of the forward direction of is_extr_filter_dual_iff`."
  theorem: "{Î± : Type u} {Î² : Type v} [preorder Î²] {f : Î± â†’ Î²} {l : filter Î±} {a : Î±} : is_extr_filter (â‡‘order_dual.to_dual âˆ˜ f) l a â†’ is_extr_filter f l a"

- doc_string: "Given two elements `a`, `b` of a commutative `cancel_monoid_with_zero` and a nonzero  element `c`, `a*c` divides `b*c` iff `a` divides `b`."
  theorem: "{Î± : Type u_1} [cancel_comm_monoid_with_zero Î±] {a b c : Î±} (hc : c â‰  0) : a * c âˆ£ b * c â†” a âˆ£ b"

- doc_string: "Any partial order can be extended to a linear order."
  theorem: "{Î± : Type u} (r : Î± â†’ Î± â†’ Prop) [is_partial_order Î± r] : âˆƒ (s : Î± â†’ Î± â†’ Prop) (_x : is_linear_order Î± s), r â‰¤ s"

- doc_string: "If `a` commutes with both `b` and `c`, then it commutes with their product."
  theorem: "{S : Type u_1} [semigroup S] {a b c : S} (hab : commute a b) (hac : commute a c) : commute a (b * c)"

- doc_string: "The sum of any function over an empty set is `0`."
  theorem: "{Î± : Type u_1} {M : Type u_5} [add_comm_monoid M] {f : Î± â†’ M} : finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ âˆ…), f i)) = 0"

- doc_string: "The zeroth Pythagorean triple is all zeros."
  theorem: " : pythagorean_triple 0 0 0"

- doc_string: "If a 2-vector `p` satisfies `is_coprime (p 0) (p 1)`, then `p â‰  0`."
  theorem: "{R : Type u} [comm_semiring R] [nontrivial R] {p : fin 2 â†’ R} (h : is_coprime (p 0) (p 1)) : p â‰  0"

- doc_string: "Adding a point to a set preserves its boundedness below."
  theorem: "{Î³ : Type w} [semilattice_inf Î³] (a : Î³) {s : set Î³} : bdd_below (has_insert.insert a s) â†” bdd_below s"

- doc_string: "A finite group of prime order is simple."
  theorem: "{Î± : Type u} [group Î±] [fintype Î±] {p : â„•} [hp : fact (nat.prime p)] (h : fintype.card Î± = p) : is_simple_group Î±"

- doc_string: "**Kaminski's Equation**"
  theorem: "(f : bool â†’ bool) (x : bool) : f (f (f x)) = f x"

- doc_string: "**Alias** of ge_antisymm`."
  theorem: "{Î± : Type u} [partial_order Î±] {a b : Î±} : a â‰¤ b â†’ b â‰¤ a â†’ b = a"

- doc_string: "TODO: Generalise to `finite_cancel_monoid`."
  theorem: "{G : Type u} {x : G} {n : â„•} [fintype G] [group G] : x ^ n = 1 â†” x ^ n.gcd (fintype.card G) = 1"

- doc_string: " If `p` is a prime such that `p âˆ£ n`, then `expand R p (cyclotomic n R) = cyclotomic (p * n) R`."
  theorem: "{p n : â„•} (hp : nat.prime p) (hdiv : p âˆ£ n) (R : Type u_1) [comm_ring R] : â‡‘(polynomial.expand R p) (polynomial.cyclotomic n R) = polynomial.cyclotomic (n * p) R"

- doc_string: "The element `0` is `M`-regular if and only if `M` is trivial."
  theorem: "{R : Type u_1} {M : Type u_3} [monoid_with_zero R] [has_zero M] [mul_action_with_zero R M] (h : is_smul_regular M 0) : subsingleton M"

- doc_string: "A module has dimension 1 iff there is some `v : V` so `{v}` is a basis."
  theorem: "{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] (Î¹ : Type u_1) [unique Î¹] : finite_dimensional.finrank K V = 1 â†” nonempty (basis Î¹ K V)"

- doc_string: "Elements of finite order are closed under multiplication."
  theorem: "{G : Type u} {x y : G} [comm_monoid G] (hx : is_of_fin_order x) (hy : is_of_fin_order y) : is_of_fin_order (x * y)"

- doc_string: " The localization at of an integral domain to a set of non-zero elements is an integral domain. See note [reducible non-instances]."
  theorem: "{A : Type u_6} [comm_ring A] [is_domain A] {M : submonoid A} (hM : M â‰¤ non_zero_divisors A) : is_domain (localization M)"

- doc_string: "**Alias** of mul_sub_right_distrib`."
  theorem: "{Î± : Type u} [non_unital_non_assoc_ring Î±] (a b c : Î±) : (a - b) * c = a * c - b * c"

- doc_string: "A map of rings that is a semiring homomorphism is also a ring homomorphism."
  theorem: "{Î± : Type u} {Î² : Type v} [ring Î±] [ring Î²] {f : Î± â†’ Î²} (H : is_semiring_hom f) : is_ring_hom f"

- doc_string: "**Alias** of the reverse direction of tsub_nonpos`."
  theorem: "{Î± : Type u_1} [preorder Î±] [add_comm_monoid Î±] [has_sub Î±] [has_ordered_sub Î±] {a b : Î±} : a â‰¤ b â†’ a - b â‰¤ 0"

- doc_string: "In a preadditive category, if the product of `X` and `Y` exists, then the    binary biproduct of `X` and `Y` exists."
  theorem: "{C : Type u} [category_theory.category C] [category_theory.preadditive C] (X Y : C) [category_theory.limits.has_binary_product X Y] : category_theory.limits.has_binary_biproduct X Y"

- doc_string: "A nontrivial finite dimensional space has positive `finrank`."
  theorem: "{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] [h : nontrivial V] : 0 < finite_dimensional.finrank K V"

- doc_string: "The second projection in a product of topological spaces sends open sets to open sets."
  theorem: "{Î± : Type u} {Î² : Type v} [topological_space Î±] [topological_space Î²] : is_open_map prod.snd"

- doc_string: "Direct products of torsion free groups are torsion free."
  theorem: "{Î· : Type u_1} {Gs : Î· â†’ Type u_2} [Î  (i : Î·), group (Gs i)] (tfGs : âˆ€ (i : Î·), monoid.is_torsion_free (Gs i)) : monoid.is_torsion_free (Î  (i : Î·), Gs i)"

- doc_string: " Shows that the recurrence relation (`convergents`) and direct evaluation (`convergents'`) of a (regular) continued fraction coincide."
  theorem: "{K : Type u_1} [linear_ordered_field K] {c : continued_fraction K} : â†‘c.convergents = â†‘c.convergents'"

- doc_string: "**Alias** of the reverse direction of left.one_lt_inv_iff`."
  theorem: "{Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a : Î±} : a < 1 â†’ 1 < aâ»Â¹"

- doc_string: "The union of two bounded sets is bounded."
  theorem: "{Î± : Type u} [pseudo_metric_space Î±] {s t : set Î±} (hs : metric.bounded s) (ht : metric.bounded t) : metric.bounded (s âˆª t)"

- doc_string: "A version of `nat.exists_infinite_primes` using the `bdd_above` predicate."
  theorem: " : Â¬bdd_above {p : â„• | nat.prime p}"

- doc_string: "**Alias** of the forward direction of left.inv_lt_one_iff`."
  theorem: "{Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a : Î±} : aâ»Â¹ < 1 â†’ 1 < a"

- doc_string: "**Alias** of the forward direction of is_extr_on_dual_iff`."
  theorem: "{Î± : Type u} {Î² : Type v} [preorder Î²] {f : Î± â†’ Î²} {s : set Î±} {a : Î±} : is_extr_on (â‡‘order_dual.to_dual âˆ˜ f) s a â†’ is_extr_on f s a"

- doc_string: " Theorems about `padic_norm_e` are named with a `'` so the names do not conflict with the equivalent theorems about `norm` (`âˆ¥ âˆ¥`)."
  theorem: "{p : â„•} [fact (nat.prime p)] : padic_norm_e 1 = 1"

- doc_string: " A version of `comm` with `r` explicit.  This lemma matches the lemmas from lean core in `init.algebra.classes`, but is missing there."
  theorem: "{Î± : Type u} (r : Î± â†’ Î± â†’ Prop) [is_symm Î± r] {a b : Î±} : r a b â†” r b a"

- doc_string: "For natural numbers the filters `cofinite` and `at_top` coincide."
  theorem: " : filter.cofinite = filter.at_top"

- doc_string: "A variant"
  theorem: "{F : Type u_1} [field F] [fintype F] [decidable_eq F] {a : F} (ha : a â‰  0) : char.quadratic_char F a = -1 â†” Â¬char.quadratic_char F a = 1"

- doc_string: "**Alias** of the forward direction of is_square_iff_exists_sq`."
  theorem: "{Î± : Type u_2} [monoid Î±] (m : Î±) : is_square m â†’ (âˆƒ (c : Î±), m = c ^ 2)"

- doc_string: "**Alias** of left.one_lt_mul_of_le_of_lt`."
  theorem: "{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a b : Î±} (ha : 1 â‰¤ a) (hb : 1 < b) : 1 < a * b"

- doc_string: "The cardinality of a quaternion algebra, as a type."
  theorem: "{R : Type u_1} (câ‚ câ‚‚ : R) : cardinal.mk (quaternion_algebra R câ‚ câ‚‚) = cardinal.mk R ^ 4"

- doc_string: "A strongly measurable function is measurable."
  theorem: "{Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} {m : measurable_space Î±} [topological_space Î²] [topological_space.pseudo_metrizable_space Î²] [measurable_space Î²] [borel_space Î²] (hf : measure_theory.strongly_measurable f) : measurable f"

- doc_string: "Cauchy condensation test for a series of `nnreal` version."
  theorem: "{f : â„• â†’ nnreal} (hf : âˆ€ â¦ƒm n : â„•â¦„, 0 < m â†’ m â‰¤ n â†’ f n â‰¤ f m) : summable (Î» (k : â„•), 2 ^ k * f (2 ^ k)) â†” summable f"

- doc_string: "**Alias** of left.mul_le_one`."
  theorem: "{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a b : Î±} (ha : a â‰¤ 1) (hb : b â‰¤ 1) : a * b â‰¤ 1"

- doc_string: "**Alias** of left.inv_le_one_iff`."
  theorem: "{Î± : Type u} [group Î±] [has_le Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a : Î±} : aâ»Â¹ â‰¤ 1 â†” 1 â‰¤ a"

- doc_string: " A `comm_ring` `K` which is the localization of an integral domain `R` at `R - {0}` is an integral domain."
  theorem: "(A : Type u_4) [comm_ring A] [is_domain A] {K : Type u_5} [comm_ring K] [algebra A K] [is_fraction_ring A K] : is_domain K"

- doc_string: "A free module with a basis indexed by a `fintype` is finite."
  theorem: "{R : Type u_1} {M : Type u_2} {Î¹ : Type u_3} [comm_ring R] [add_comm_group M] [module R M] [fintype Î¹] (b : basis Î¹ R M) : module.finite R M"

- doc_string: "  If an element `b` becomes right-regular after multiplying it on the right by a right-regular element, then `b` is right-regular."
  theorem: "{R : Type u_1} {a b : R} [semigroup R] (ab : is_right_regular (b * a)) : is_right_regular b"

- doc_string: "`pow b` and `log b` (almost) form a Galois connection."
  theorem: "{b : â„•} (hb : 1 < b) {x y : â„•} (hy : 0 < y) : b ^ x â‰¤ y â†” x â‰¤ nat.log b y"

- doc_string: "monotonicity of `â‰¤` with respect to `â†’`"
  theorem: "{Î± : Type u} {a b c d : Î±} [preorder Î±] (hca : c â‰¤ a) (hbd : b â‰¤ d) : a â‰¤ b â†’ c â‰¤ d"

- doc_string: " The comap of the cocompact filter on `Î²` by a continuous function `f : Î± â†’ Î²` is less than or equal to the cocompact filter on `Î±`. This is a reformulation of the fact that images of compact sets are compact."
  theorem: "{Î± : Type u} {Î² : Type v} [topological_space Î±] [topological_space Î²] {f : Î± â†’ Î²} (hf : continuous f) : filter.comap f (filter.cocompact Î²) â‰¤ filter.cocompact Î±"

- doc_string: "**Alias** of the forward direction of is_max_on_dual_iff`."
  theorem: "{Î± : Type u} {Î² : Type v} [preorder Î²] {f : Î± â†’ Î²} {s : set Î±} {a : Î±} : is_max_on (â‡‘order_dual.to_dual âˆ˜ f) s a â†’ is_min_on f s a"

- doc_string: "**Alias** of sbtw_of_btw_not_btw`."
  theorem: "{Î± : Type u_1} [circular_preorder Î±] {a b c : Î±} (habc : has_btw.btw a b c) (hcba : Â¬has_btw.btw c b a) : has_sbtw.sbtw a b c"

- doc_string: "Assumes right covariance."
  theorem: "{Î± : Type u} {a b : Î±} [mul_one_class Î±] [has_zero Î±] [preorder Î±] [zero_lt.mul_pos_mono Î±] (ha : 1 â‰¤ a) (hb : 1 â‰¤ b) (b0 : 0 < b) : 1 â‰¤ a * b"

- doc_string: "If `p âˆ¤ a`, then `legendre_sym p a` is `1` or `-1`."
  theorem: "(p : â„•) [fact (nat.prime p)] (a : â„¤) (ha : â†‘a â‰  0) : zmod.legendre_sym p a = 1 âˆ¨ zmod.legendre_sym p a = -1"

- doc_string: "**Alias** of the reverse direction of is_bot_to_dual_iff`."
  theorem: "{Î± : Type u_1} [has_le Î±] {a : Î±} : is_top a â†’ is_bot (â‡‘order_dual.to_dual a)"

- doc_string: "**Alias** of the forward direction of odd_iff_exists_bit1`."
  theorem: "{Î± : Type u_2} [semiring Î±] {a : Î±} : odd a â†’ (âˆƒ (b : Î±), a = bit1 b)"

- doc_string: "A rewrite lemma for `padic_val_nat p (q * r)` with conditions `q â‰  0`, `r â‰  0`."
  theorem: "(p : â„•) [p_prime : fact (nat.prime p)] {q r : â„•} (hq : q â‰  0) (hr : r â‰  0) : padic_val_nat p (q * r) = padic_val_nat p q + padic_val_nat p r"

- doc_string: "Deprecated: use `fun_like.congr_fun` instead."
  theorem: "{M : Type u_3} {N : Type u_4} [has_add M] [has_add N] {f g : add_hom M N} (h : f = g) (x : M) : â‡‘f x = â‡‘g x"

- doc_string: " To show a category is a `initial_mono_class` it suffices to show every morphism out of the initial object is a monomorphism."
  theorem: "{C : Type uâ‚} [category_theory.category C] [category_theory.limits.has_initial C] (h : âˆ€ (X : C), category_theory.mono (category_theory.limits.initial.to X)) : category_theory.limits.initial_mono_class C"

- doc_string: "Uniformizers are nonzero."
  theorem: "{R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] (K : Type u_2) [field K] [algebra R K] [is_fraction_ring R K] (v : is_dedekind_domain.height_one_spectrum R) : classical.some _ â‰  0"

- doc_string: "In the model space, the identity is in any maximal atlas."
  theorem: "{H : Type u} [topological_space H] (G : structure_groupoid H) : local_homeomorph.refl H âˆˆ structure_groupoid.maximal_atlas H G"

- doc_string: "Two elements are related by a congruence relation `c` iff they are represented by the same    element of the quotient by `c`."
  theorem: "{M : Type u_1} [has_mul M] (c : con M) {a b : M} : â†‘a = â†‘b â†” â‡‘c a b"

- doc_string: "A fixed point of `f` is a periodic point of `f` of any prescribed period."
  theorem: "{Î± : Type u_1} {f : Î± â†’ Î±} {x : Î±} (hf : function.is_fixed_pt f x) (n : â„•) : function.is_periodic_pt f n x"

- doc_string: "Uses `left` co(ntra)variant."
  theorem: "{Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a : Î±} : aâ»Â¹ < 1 â†” 1 < a"

- doc_string: "Two elements `a` and `b` are add-regular if and only if both sums `a + b` and `b + a` are add-regular."
  theorem: "{R : Type u_1} {a b : R} [add_semigroup R] : is_add_regular (a + b) âˆ§ is_add_regular (b + a) â†” is_add_regular a âˆ§ is_add_regular b"

- doc_string: "**Alias** of the forward direction of inv_mul_lt_iff_lt_mul`."
  theorem: "{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b c : Î±} : -b + a < c â†’ a < b + c"

- doc_string: "**Alias** of sq_sub_sq`."
  theorem: "{R : Type uâ‚} [comm_ring R] (a b : R) : a ^ 2 - b ^ 2 = (a + b) * (a - b)"

- doc_string: "Finset **stars and bars** for the case `n = 2`."
  theorem: "{Î± : Type u_1} [decidable_eq Î±] (s : finset Î±) : s.sym2.card = s.card * (s.card + 1) / 2"

- doc_string: "A compact set is bounded above"
  theorem: "{Î± : Type u} [topological_space Î±] [linear_order Î±] [order_closed_topology Î±] [nonempty Î±] {s : set Î±} (hs : is_compact s) : bdd_above s"

- doc_string: "The prime factorizations of coprime `a` and `b` are disjoint"
  theorem: "{a b : â„•} (hab : a.coprime b) : disjoint a.factorization.support b.factorization.support"

- doc_string: "**Alias** of the forward direction of is_min_filter_dual_iff`."
  theorem: "{Î± : Type u} {Î² : Type v} [preorder Î²] {f : Î± â†’ Î²} {l : filter Î±} {a : Î±} : is_min_filter (â‡‘order_dual.to_dual âˆ˜ f) l a â†’ is_max_filter f l a"

- doc_string: "**Alias** of eq_of_ge_of_not_gt`."
  theorem: "{Î± : Type u} [partial_order Î±] {a b : Î±} (hab : a â‰¤ b) (hba : Â¬a < b) : b = a"

- doc_string: "The function `exp(x)/x^n` tends to `+âˆž` at `+âˆž`, for any natural number `n`"
  theorem: "(n : â„•) : filter.tendsto (Î» (x : â„), real.exp x / x ^ n) filter.at_top filter.at_top"

- doc_string: "A version of `measurable_sub_const` that assumes `has_measurable_add` instead of  `has_measurable_sub`. This can be nice to avoid unnecessary type-class assumptions."
  theorem: "{G : Type u_1} [sub_neg_monoid G] [measurable_space G] [has_measurable_add G] (g : G) : measurable (Î» (h : G), h - g)"

- doc_string: "Shows that the integer parts of the stream are at least one."
  theorem: "{K : Type u_1} {v : K} {n : â„•} [linear_ordered_field K] [floor_ring K] {ifp_succ_n : generalized_continued_fraction.int_fract_pair K} (succ_nth_stream_eq : generalized_continued_fraction.int_fract_pair.stream v (n + 1) = option.some ifp_succ_n) : 1 â‰¤ ifp_succ_n.b"

- doc_string: " Rewriting equality in the dependent type `Î£ (a : composition n), composition a.length)` in non-dependent terms with lists, requiring that the blocks coincide."
  theorem: "{n : â„•} (i j : Î£ (a : composition n), composition a.length) : i = j â†” i.fst.blocks = j.fst.blocks âˆ§ i.snd.blocks = j.snd.blocks"

- doc_string: "The lower central series of a group is a descending central series."
  theorem: "{G : Type u_1} [group G] : is_descending_central_series (lower_central_series G)"

- doc_string: " The polar `polar ð•œ s` of a set `s : E` is a closed subset when the weak star topology is used."
  theorem: "(ð•œ : Type u_1) [nondiscrete_normed_field ð•œ] {E : Type u_2} [semi_normed_group E] [normed_space ð•œ E] (s : set E) : is_closed (weak_dual.polar ð•œ s)"

- doc_string: " The order of the `â†”` has been chosen so that `rw sbtw_cyclic` cycles to the right while `rw â†sbtw_cyclic` cycles to the left (thus following the prepended arrow)."
  theorem: "{Î± : Type u_1} [circular_preorder Î±] {a b c : Î±} : has_sbtw.sbtw a b c â†” has_sbtw.sbtw c a b"

- doc_string: "Over a ring `R` of characteristic zero, `Î» n, cyclotomic n R` is injective."
  theorem: "{R : Type u_1} [comm_ring R] [char_zero R] : function.injective (Î» (n : â„•), polynomial.cyclotomic n R)"

- doc_string: "The intersection of a compact set and a closed set is a compact set."
  theorem: "{Î± : Type u} [topological_space Î±] {s t : set Î±} (hs : is_compact s) (ht : is_closed t) : is_compact (s âˆ© t)"

- doc_string: "`padic_val_int p 0` is 0 for any `p`."
  theorem: "{p : â„•} : padic_val_int p 0 = 0"

- doc_string: "The 0 of the quotient of an `add_monoid` by an additive congruence relation is the equivalence class of the `add_monoid`'s 0."
  theorem: "{M : Type u_1} [add_zero_class M] {c : add_con M} : â†‘0 = 0"

- doc_string: " Euclid's lemma: if `a âˆ£ b * c` and `gcd a c = 1` then `a âˆ£ b`. Compare with `is_coprime.dvd_of_dvd_mul_left` and `unique_factorization_monoid.dvd_of_dvd_mul_left_of_no_prime_factors`"
  theorem: "{a b c : â„¤} (habc : a âˆ£ b * c) (hab : a.gcd c = 1) : a âˆ£ b"

- doc_string: "`nndist x x` vanishes"
  theorem: "{Î± : Type u} [pseudo_metric_space Î±] (a : Î±) : has_nndist.nndist a a = 0"

- doc_string: "In a monoid with zero, if zero equals one, then zero is the only element."
  theorem: "{Mâ‚€ : Type u_1} [mul_zero_one_class Mâ‚€] (h : 0 = 1) (a : Mâ‚€) : a = 0"

- doc_string: "The functor Compactum_to_CompHaus is faithful."
  theorem: " : category_theory.faithful Compactum_to_CompHaus"

- doc_string: "`âˆ¨` distributes over `âˆ§` (on the right)."
  theorem: "{a b c : Prop} : a âˆ§ b âˆ¨ c â†” (a âˆ¨ c) âˆ§ (b âˆ¨ c)"

- doc_string: "**Alias** of the forward direction of le_inv_mul_iff_mul_le`."
  theorem: "{Î± : Type u} [group Î±] [has_le Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a b c : Î±} : b â‰¤ aâ»Â¹ * c â†’ a * b â‰¤ c"

- doc_string: "An element of a monoid is in the set of that element's natural number powers."
  theorem: "{M : Type u_1} [monoid M] {x : M} : x âˆˆ powers x"

- doc_string: "Determinant of 0x0 matrix"
  theorem: "{R : Type v} [comm_ring R] {A : matrix (fin 0) (fin 0) R} : A.det = 1"

- doc_string: " Assumes left covariance. The lemma assuming right covariance is `right.mul_lt_one_of_le_of_lt`."
  theorem: "{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a b : Î±} (ha : a â‰¤ 1) (hb : b < 1) : a * b < 1"

- doc_string: "`-a â‰¤ b â†” -b â‰¤ a` on `ereal`."
  theorem: "{a b : ereal} : -a â‰¤ b â†” -b â‰¤ a"

- doc_string: "Addition of a `u : add_units M` on the right doesn't affect `is_add_unit`."
  theorem: "{M : Type u_1} [add_monoid M] (a : M) (u : add_units M) : is_add_unit (a + â†‘u) â†” is_add_unit a"

- doc_string: "**Cantor's theorem**"
  theorem: "(a : cardinal) : a < 2 ^ a"

- doc_string: "If a direct product has finite additive order then so does each component."
  theorem: "{Î· : Type u_1} {Gs : Î· â†’ Type u_2} [Î  (i : Î·), add_monoid (Gs i)] {x : Î  (i : Î·), Gs i} (h : is_of_fin_add_order x) (i : Î·) : is_of_fin_add_order (x i)"

- doc_string: "The cross product of two vectors is perpendicular to the second vector."
  theorem: "{R : Type u_1} [comm_ring R] (v w : fin 3 â†’ R) : matrix.dot_product w (â‡‘(â‡‘cross_product v) w) = 0"

- doc_string: " If `u` is a monotone function with linear ordered codomain and the range of `u` is not bounded above, then `tendsto u at_top at_top`."
  theorem: "{Î¹ : Type u_1} {Î± : Type u_3} [preorder Î¹] [linear_order Î±] {u : Î¹ â†’ Î±} (h : monotone u) (H : Â¬bdd_above (set.range u)) : filter.tendsto u filter.at_top filter.at_top"

- doc_string: "Multiplicative congruence relations preserve multiplication."
  theorem: "{M : Type u_1} [has_mul M] (c : con M) {w x y z : M} : â‡‘c w x â†’ â‡‘c y z â†’ â‡‘c (w * y) (x * z)"

- doc_string: "**Alias** of the reverse direction of sub_lt_iff_lt_add'`."
  theorem: "{Î± : Type u} [add_comm_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b c : Î±} : a < b + c â†’ a - b < c"

- doc_string: "The determinant of `conj_lie`, as a linear equiv."
  theorem: " : â‡‘linear_equiv.det complex.conj_lie.to_linear_equiv = -1"

- doc_string: "The p-adic value of an natural is its p-adic_value as an integer"
  theorem: "{p n : â„•} : padic_val_int p â†‘n = padic_val_nat p n"

- doc_string: "See `inv_le_inv_of_le` for the implication from right-to-left with one fewer assumption."
  theorem: "{Î± : Type u_1} [linear_ordered_field Î±] {a b : Î±} (ha : 0 < a) (hb : 0 < b) : aâ»Â¹ â‰¤ bâ»Â¹ â†” b â‰¤ a"

- doc_string: "Inversion is a group homomorphism if the group is commutative."
  theorem: "{Î± : Type u} [comm_group Î±] : is_group_hom has_inv.inv"

- doc_string: "The closure of a totally bounded set is totally bounded."
  theorem: "{Î± : Type u} [uniform_space Î±] {s : set Î±} (h : totally_bounded s) : totally_bounded (closure s)"

- doc_string: "The function `x ^ (-1 / x)` tends to `1` at `+âˆž`."
  theorem: " : filter.tendsto (Î» (x : â„), x ^ ((-1) / x)) filter.at_top (nhds 1)"

- doc_string: " The set of cluster points of a filter is closed. In particular, the set of limit points of a sequence is closed."
  theorem: "{Î± : Type u} [topological_space Î±] {f : filter Î±} : is_closed {x : Î± | cluster_pt x f}"

- doc_string: "**Alias** of not_lt_of_le`."
  theorem: "{Î± : Type u} [preorder Î±] {a b : Î±} (h : a â‰¤ b) : Â¬b < a"

- doc_string: "If `x` is a fixed point of `f` and `g`, then it is a fixed point of `f âˆ˜ g`."
  theorem: "{Î± : Type u} {f g : Î± â†’ Î±} {x : Î±} (hf : function.is_fixed_pt f x) (hg : function.is_fixed_pt g x) : function.is_fixed_pt (f âˆ˜ g) x"

- doc_string: "The intersection of an indexed set of `add_submonoid`s of an `add_monoid` `M` is an `add_submonoid` of `M`."
  theorem: "{M : Type u_1} [add_monoid M] {Î¹ : Sort u_2} {s : Î¹ â†’ set M} (h : âˆ€ (y : Î¹), is_add_submonoid (s y)) : is_add_submonoid (set.Inter s)"

- doc_string: "Deprecated: use `fun_like.ext_iff` instead."
  theorem: "{M : Type u_3} {N : Type u_4} [has_one M] [has_one N] {f g : one_hom M N} : f = g â†” âˆ€ (x : M), â‡‘f x = â‡‘g x"

- doc_string: " Composing an independent indexed family with an injective function on the index results in another indepedendent indexed family."
  theorem: "{Î¹ : Sort u_1} {Î¹' : Sort u_2} {Î± : Type u_3} [complete_lattice Î±] {s : Î¹ â†’ Î±} (hs : complete_lattice.independent s) (f : Î¹' â†’ Î¹) (hf : function.injective f) : complete_lattice.independent (s âˆ˜ f)"

- doc_string: "Ordinals that are cardinals are unbounded."
  theorem: " : set.unbounded has_lt.lt {b : ordinal | b.card.ord = b}"

- doc_string: "Uses `right` co(ntra)variant."
  theorem: "{Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± (function.swap has_mul.mul) has_lt.lt] {a : Î±} : aâ»Â¹ < 1 â†” 1 < a"

- doc_string: "The closure of a set `s` is dense if and only if `s` is dense."
  theorem: "{Î± : Type u} [topological_space Î±] {s : set Î±} : dense (closure s) â†” dense s"

- doc_string: "**Alias** of the reverse direction of left.one_lt_inv_iff`."
  theorem: "{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a : Î±} : a < 0 â†’ 0 < -a"

- doc_string: "When `p âˆ¤ a`, then `legendre_sym p a = 1` iff `a` is a square mod `p`."
  theorem: "(p : â„•) [fact (nat.prime p)] {a : â„¤} (ha0 : â†‘a â‰  0) : zmod.legendre_sym p a = 1 â†” is_square â†‘a"

- doc_string: "In a sequential space, continuity and sequential continuity coincide."
  theorem: "{X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] {f : X â†’ Y} [sequential_space X] : continuous f â†” seq_continuous f"

- doc_string: "**Alias** of le_of_eq_of_le`."
  theorem: "{Î± : Type u} [preorder Î±] {a b c : Î±} (hab : a = b) (hbc : b â‰¤ c) : a â‰¤ c"

- doc_string: "See `int.induction_on'` for an induction in both directions."
  theorem: "{P : â„¤ â†’ Prop} {m : â„¤} (h0 : P m) (h1 : âˆ€ (n : â„¤), m â‰¤ n â†’ P n â†’ P (n + 1)) (n : â„¤) : m â‰¤ n â†’ P n"

- doc_string: "The `0` element is not `M`-regular, on a non-trivial module."
  theorem: "{R : Type u_1} {M : Type u_3} [monoid_with_zero R] [has_zero M] [mul_action_with_zero R M] : Â¬is_smul_regular M 0 â†” nontrivial M"

- doc_string: "A space is totally disconnected iff its connected components are singletons."
  theorem: "{Î± : Type u} [topological_space Î±] : totally_disconnected_space Î± â†” âˆ€ (x : Î±), connected_component x = {x}"

- doc_string: "An additive group homomorphism sends 0 to 0."
  theorem: "{Î± : Type u} {Î² : Type v} [add_group Î±] [add_group Î²] {f : Î± â†’ Î²} (hf : is_add_group_hom f) : f 0 = 0"

- doc_string: " The Roth number is a subadditive function. Note that by Fekete's lemma this shows that the limit `roth_number_nat N / N` exists, but Roth's theorem gives the stronger result that this limit is actually `0`."
  theorem: "(M N : â„•) : â‡‘roth_number_nat (M + N) â‰¤ â‡‘roth_number_nat M + â‡‘roth_number_nat N"

- doc_string: "The diameter is monotonous with respect to inclusion"
  theorem: "{Î± : Type u} [pseudo_emetric_space Î±] {s t : set Î±} (h : s âŠ† t) : emetric.diam s â‰¤ emetric.diam t"

- doc_string: "A field extension is algebraic if it is finite."
  theorem: "(K : Type u_1) (L : Type u_2) [field K] [field L] [algebra K L] [finite : finite_dimensional K L] : algebra.is_algebraic K L"

- doc_string: " If two words have a common maximal reduction, then they correspond to the same element in the free group."
  theorem: "{Î± : Type u} {Lâ‚ Lâ‚‚ : list (Î± Ã— bool)} [decidable_eq Î±] (H : free_group.reduce Lâ‚ = free_group.reduce Lâ‚‚) : free_group.mk Lâ‚ = free_group.mk Lâ‚‚"

- doc_string: "The exponential map in `ð•‚ = â„` or `ð•‚ = â„‚` has strict derivative `1` at zero."
  theorem: "{ð•‚ : Type u_1} [is_R_or_C ð•‚] : has_strict_deriv_at (exp ð•‚) 1 0"

- doc_string: " In a finite-dimensional space, its dimension (seen as a cardinal) coincides with its `finrank`."
  theorem: "(K : Type u) (V : Type v) [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] : â†‘(finite_dimensional.finrank K V) = module.rank K V"

- doc_string: "**Alias** of `left.add_pos`."
  theorem: "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b : Î±} (ha : 0 < a) (hb : 0 < b) : 0 < a + b"

- doc_string: "Given a map `f : N â†’ M` and an equivalence relation `r` on `Î²`, the equivalence relation    induced on `Î±` by `f` equals the kernel of `r`'s quotient map composed with `f`."
  theorem: "{Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} {r : setoid Î²} : setoid.comap f r = setoid.ker (quotient.mk âˆ˜ f)"

- doc_string: "The minimal distance to a set (as `â„â‰¥0`) is uniformly continuous in point"
  theorem: "{Î± : Type u} [pseudo_metric_space Î±] (s : set Î±) : uniform_continuous (Î» (x : Î±), metric.inf_nndist x s)"

- doc_string: "Commuting elements of finite order are closed under multiplication."
  theorem: "{G : Type u} {y : G} [monoid G] {x : G} (h : commute x y) (hx : is_of_fin_order x) (hy : is_of_fin_order y) : is_of_fin_order (x * y)"

- doc_string: "Moving to the opposite group or group_with_zero commutes with taking powers."
  theorem: "{M : Type u} [div_inv_monoid M] (x : M) (z : â„¤) : mul_opposite.op (x ^ z) = mul_opposite.op x ^ z"

- doc_string: "**Alias** of the reverse direction of is_max_on_dual_iff`."
  theorem: "{Î± : Type u} {Î² : Type v} [preorder Î²] {f : Î± â†’ Î²} {s : set Î±} {a : Î±} : is_min_on f s a â†’ is_max_on (â‡‘order_dual.to_dual âˆ˜ f) s a"

- doc_string: " A version of `antisymm` with `r` explicit.  This lemma matches the lemmas from lean core in `init.algebra.classes`, but is missing there."
  theorem: "{Î± : Type u} (r : Î± â†’ Î± â†’ Prop) [is_antisymm Î± r] {a b : Î±} : r a b â†’ r b a â†’ a = b"

- doc_string: "The Legendre symbol depends only on `a` mod `p`."
  theorem: "(p : â„•) [fact (nat.prime p)] (a : â„¤) : zmod.legendre_sym p a = zmod.legendre_sym p (a % â†‘p)"

- doc_string: "A division_ring is one-dimensional as a vector space over itself."
  theorem: "(K : Type u) [division_ring K] : finite_dimensional.finrank K K = 1"

- doc_string: "Bernoulli's inequality reformulated to estimate `a^n`."
  theorem: "{R : Type uâ‚} [linear_ordered_ring R] {a : R} (H : -1 â‰¤ a) (n : â„•) : 1 + â†‘n * (a - 1) â‰¤ a ^ n"

- doc_string: "A map to an additive group preserving addition is an additive monoid homomorphism."
  theorem: "{Î± : Type u} {Î² : Type v} [add_zero_class Î±] [add_group Î²] {f : Î± â†’ Î²} (hf : is_add_hom f) : is_add_monoid_hom f"

- doc_string: "The presheaf of `J`-closed sieves is a `J`-sheaf. The proof of this is adapted from [MM92], Chatper III, Section 7, Lemma 1."
  theorem: "{C : Type u} [category_theory.category C] (Jâ‚ : category_theory.grothendieck_topology C) : category_theory.presieve.is_sheaf Jâ‚ (category_theory.functor.closed_sieves Jâ‚)"

- doc_string: "Show that `nat.choose` is increasing for small values of the right argument."
  theorem: "{r n : â„•} (h : r < n / 2) : n.choose r â‰¤ n.choose (r + 1)"

- doc_string: "**Alias** of the forward direction of lt_sub_iff_add_lt`."
  theorem: "{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b c : Î±} : a < c - b â†’ a + b < c"

- doc_string: "The indexed minimum of a function is bounded below by a uniform lower bound"
  theorem: "{Î± : Type u_1} {Î¹ : Sort u_3} [conditionally_complete_lattice Î±] [nonempty Î¹] {f : Î¹ â†’ Î±} {c : Î±} (H : âˆ€ (x : Î¹), c â‰¤ f x) : c â‰¤ infi f"

- doc_string: "Note that `star_one` is already a global simp lemma, but this one works with dsimp too"
  theorem: "{Î± : Type u_1} : has_star.star 1 = 1"

- doc_string: "The real exponential function tends to `+âˆž` at `+âˆž`."
  theorem: " : filter.tendsto real.exp filter.at_top filter.at_top"

- doc_string: "Pullback a `nontrivial` instance along a function sending `0` to `0` and `1` to `1`."
  theorem: "{Mâ‚€ : Type u_1} {Mâ‚€' : Type u_3} [mul_zero_one_class Mâ‚€] [nontrivial Mâ‚€] [has_zero Mâ‚€'] [has_one Mâ‚€'] (f : Mâ‚€' â†’ Mâ‚€) (zero : f 0 = 0) (one : f 1 = 1) : nontrivial Mâ‚€'"

- doc_string: " `smul` is a closed map in the second argument.  The lemma that `smul` is a closed map in the first argument (for a normed space over a complete normed field) is `is_closed_map_smul_left` in `analysis.normed_space.finite_dimension`."
  theorem: "{Î± : Type u_2} {Gâ‚€ : Type u_4} [topological_space Î±] [group_with_zero Gâ‚€] [mul_action Gâ‚€ Î±] [has_continuous_const_smul Gâ‚€ Î±] {c : Gâ‚€} (hc : c â‰  0) : is_closed_map (Î» (x : Î±), c â€¢ x)"

- doc_string: "**Alias** of btw_of_sbtw`."
  theorem: "{Î± : Type u_1} [circular_preorder Î±] {a b c : Î±} (h : has_sbtw.sbtw a b c) : has_btw.btw a b c"

- doc_string: " If `a â‰¤ b`, then `(b, +âˆž) âŠ† [a, +âˆž)`. In preorders, this is just an implication. If you need the equivalence in dense linear orders, use `Ioi_subset_Ici_iff`."
  theorem: "{Î± : Type u_1} [preorder Î±] {a b : Î±} (h : a â‰¤ b) : set.Ioi b âŠ† set.Ici a"

- doc_string: "The product of the constant function `0` over any set equals `0`."
  theorem: "{Î± : Type u_1} {M : Type u_5} [add_comm_monoid M] (s : set Î±) : finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), 0)) = 0"

- doc_string: "The trace map from a finite field to its prime field is nongedenerate."
  theorem: "(F : Type u_1) [field F] [fintype F] {a : F} (ha : a â‰  0) : âˆƒ (b : F), â‡‘(algebra.trace (zmod (ring_char F)) F) (a * b) â‰  0"

- doc_string: "TODO: Generalise to `submonoid.powers`."
  theorem: "{G : Type u} {x : G} [fintype G] [group G] [decidable_eq G] : finset.image (Î» (i : â„•), x ^ i) (finset.range (order_of x)) = â†‘(subgroup.zpowers x).to_finset"

- doc_string: "**Alias** of the reverse direction of complete_lattice.is_Sup_finite_compact_iff_is_sup_closed_compact`."
  theorem: "(Î± : Type u_1) [complete_lattice Î±] : complete_lattice.is_sup_closed_compact Î± â†’ complete_lattice.is_Sup_finite_compact Î±"

- doc_string: " The second theorem that characterises the function `reduce`: the maximal reduction of a word only reduces to itself."
  theorem: "{Î± : Type u} {Lâ‚ Lâ‚‚ : list (Î± Ã— bool)} [decidable_eq Î±] (H : free_group.red (free_group.reduce Lâ‚) Lâ‚‚) : free_group.reduce Lâ‚ = Lâ‚‚"

- doc_string: "If `0 < n`, then `quaternion_group n` has `4n` elements."
  theorem: "{n : â„•} [fact (0 < n)] : fintype.card (quaternion_group n) = 4 * n"

- doc_string: "A set is contained in its affine span."
  theorem: "(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P) : s âŠ† â†‘(affine_span k s)"

- doc_string: "The edist to a set is bounded above by the edist to any of its points"
  theorem: "{Î± : Type u} [pseudo_emetric_space Î±] {x y : Î±} {s : set Î±} (h : y âˆˆ s) : emetric.inf_edist x s â‰¤ has_edist.edist x y"

- doc_string: "See Theorem 6.6, CÄƒlugÄƒreanu"
  theorem: "{Î± : Type u_1} [complete_lattice Î±] [is_modular_lattice Î±] [is_compactly_generated Î±] [is_atomistic Î±] : is_complemented Î±"

- doc_string: "Construct terminal object in the over category. This isn't an instance as it's not typically the way we want to define terminal objects. (For instance, this gives a terminal object which is different from the generic one given by `over_product_of_wide_pullback` above.)"
  theorem: "{C : Type u} [category_theory.category C] (B : C) : category_theory.limits.has_terminal (category_theory.over B)"

- doc_string: "A nonzero object has nontrivial subobject lattice."
  theorem: "{C : Type uâ‚} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] {X : C} (h : Â¬category_theory.limits.is_zero X) : nontrivial (category_theory.subobject X)"

- doc_string: " If `P : â„¤ â†’ Prop` is a predicate such that the set `{m : P m}` is bounded above and nonempty, then this set has the greatest element. This lemma uses classical logic to avoid assumption `[decidable_pred P]`. See `int.greatest_of_bdd` for a constructive counterpart."
  theorem: "{P : â„¤ â†’ Prop} (Hbdd : âˆƒ (b : â„¤), âˆ€ (z : â„¤), P z â†’ z â‰¤ b) (Hinh : âˆƒ (z : â„¤), P z) : âˆƒ (ub : â„¤), P ub âˆ§ âˆ€ (z : â„¤), P z â†’ z â‰¤ ub"

- doc_string: "The zeroth cyclotomic polyomial is `1`."
  theorem: "(R : Type u_1) [ring R] : polynomial.cyclotomic 0 R = 1"

- doc_string: " Dividing by an element is the same as multiplying by its inverse.  This is a duplicate of `div_inv_monoid.div_eq_mul_inv` ensuring that the types unfold better."
  theorem: "{G : Type u_1} [div_inv_monoid G] (a b : G) : a / b = a * bâ»Â¹"

- doc_string: "If there are zero morphisms, any terminal object is a zero object."
  theorem: "{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_terminal C] : category_theory.limits.has_zero_object C"

- doc_string: " The function `x^(-n)` tends to `0` at `+âˆž` for any positive natural `n`. A version for positive real powers exists as `tendsto_rpow_neg_at_top`."
  theorem: "{Î± : Type u} [linear_ordered_field Î±] [topological_space Î±] [order_topology Î±] {n : â„•} (hn : 1 â‰¤ n) : filter.tendsto (Î» (x : Î±), x ^ -â†‘n) filter.at_top (nhds 0)"

- doc_string: "If `F` has odd characteristic, then for nonzero `a : F`, we have that `a ^ (#F / 2) = Â±1`."
  theorem: "{F : Type u_3} [field F] [fintype F] (hF : ring_char F â‰  2) {a : F} (ha : a â‰  0) : a ^ (fintype.card F / 2) = 1 âˆ¨ a ^ (fintype.card F / 2) = -1"

- doc_string: "In a non-trivial ring, the element `0` is not left-regular -- with typeclasses."
  theorem: "{R : Type u_1} [mul_zero_class R] [nR : nontrivial R] : Â¬is_left_regular 0"

- doc_string: "Extra simp lemma that `dsimp` can use. `simp` will never use this."
  theorem: "{G : Type u_10} [group G] (a : G) : â‡‘(equiv.symm (equiv.mul_right a)) = Î» (x : G), x * aâ»Â¹"

- doc_string: "A function `f` on `fin (n + 1)` is monotone if and only if `f i â‰¤ f (i + 1)` for all `i`."
  theorem: "{n : â„•} {Î± : Type u_1} [preorder Î±] {f : fin (n + 1) â†’ Î±} : monotone f â†” âˆ€ (i : fin n), f (â‡‘fin.cast_succ i) â‰¤ f i.succ"

- doc_string: "The determinant of `conj_ae`, as a linear equiv."
  theorem: " : â‡‘linear_equiv.det complex.conj_ae.to_linear_equiv = -1"

- doc_string: "A version of `padic_val_rat.pow` for `padic_val_nat`"
  theorem: "(p q n : â„•) [fact (nat.prime p)] (hq : q â‰  0) : padic_val_nat p (q ^ n) = n * padic_val_nat p q"

- doc_string: "The Hausdorff distance from `s` to `t` and from `t` to `s` coincide"
  theorem: "{Î± : Type u} [pseudo_metric_space Î±] {s t : set Î±} : metric.Hausdorff_dist s t = metric.Hausdorff_dist t s"

- doc_string: "We have that `ring_char (zmod n) = n`."
  theorem: "(n : â„•) : ring_char (zmod n) = n"

- doc_string: "**Alias** of the reverse direction of strict_mono_on_to_dual_comp_iff`."
  theorem: "{Î± : Type u} {Î² : Type v} [preorder Î±] [preorder Î²] {f : Î± â†’ Î²} {s : set Î±} : strict_anti_on f s â†’ strict_mono_on (â‡‘order_dual.to_dual âˆ˜ f) s"

- doc_string: " If `x` is in the base field `K`, then the norm is `x ^ [L : K]`.  (If `L` is not finite-dimensional over `K`, then `norm = 1 = x ^ 0 = x ^ (finrank L K)`.)"
  theorem: "{K : Type u_4} {L : Type u_5} [field K] [field L] [algebra K L] (x : K) : â‡‘(algebra.norm K) (â‡‘(algebra_map K L) x) = x ^ finite_dimensional.finrank K L"

- doc_string: "A reversed version of `fin.cast_eq_cast` that is easier to rewrite with."
  theorem: "{n m : â„•} (h : fin n = fin m) : cast h = â‡‘(fin.cast _)"

- doc_string: "A version of `nat.div_lt_self` using successors, rather than additional hypotheses."
  theorem: "(n b : â„•) : (n + 1) / (b + 2) < n + 1"

- doc_string: "If `f : Î± â†’ Î²` is `0`-antilipschitz, then `Î±` is a `subsingleton`."
  theorem: "{Î± : Type u_1} {Î² : Type u_2} [emetric_space Î±] [pseudo_emetric_space Î²] {f : Î± â†’ Î²} (h : antilipschitz_with 0 f) : subsingleton Î±"

- doc_string: "  An element is right-regular if and only if multiplying it on the right with a right-regular element is right-regular."
  theorem: "{R : Type u_1} {a : R} [semigroup R] (b : R) (ha : is_right_regular a) : is_right_regular (b * a) â†” is_right_regular b"

- doc_string: "UV-compression is injective on the elements it moves. See `uv.compress`."
  theorem: "{Î± : Type u_1} [generalized_boolean_algebra Î±] (u v : Î±) : set.inj_on (Î» (x : Î±), (x âŠ” u)  v) {x : Î± | disjoint u x âˆ§ v â‰¤ x}"

- doc_string: "**Alias** of the reverse direction of order.pred_lt_iff_not_is_min`."
  theorem: "{Î± : Type u_1} [preorder Î±] [pred_order Î±] {a : Î±} : Â¬is_min a â†’ order.pred a < a"

- doc_string: "If a point `x` belongs to `s`, then its edist to `s` vanishes"
  theorem: "{Î± : Type u} [pseudo_emetric_space Î±] {x : Î±} {s : set Î±} (h : x âˆˆ s) : emetric.inf_edist x s = 0"

- doc_string: "The element `0` is `M`-regular if and only if `M` is trivial."
  theorem: "{R : Type u_1} {M : Type u_3} [monoid_with_zero R] [has_zero M] [mul_action_with_zero R M] : is_smul_regular M 0 â†” subsingleton M"

- doc_string: "A group element has finite order iff its order is positive."
  theorem: "{G : Type u} {x : G} [monoid G] : 0 < order_of x â†” is_of_fin_order x"

- doc_string: "The square of the symbol is 1 if `p âˆ¤ a`."
  theorem: "(p : â„•) [fact (nat.prime p)] (a : â„¤) (ha : â†‘a â‰  0) : zmod.legendre_sym p a ^ 2 = 1"

- doc_string: "**Alias** of lt_of_lt_of_le'`."
  theorem: "{Î± : Type u} [preorder Î±] {a b c : Î±} : b < c â†’ a â‰¤ b â†’ a < c"

- doc_string: "The element `0` is left-regular if and only if `R` is trivial."
  theorem: "{R : Type u_1} [mul_zero_class R] (h : is_left_regular 0) : subsingleton R"

- doc_string: "A group `G` is finitely generated if and only if `add_monoid_algebra R G` is of finite type."
  theorem: "{R : Type u_1} {G : Type u_2} [comm_group G] [comm_ring R] [nontrivial R] : algebra.finite_type R (monoid_algebra R G) â†” group.fg G"

- doc_string: "One direction of `tsub_eq_zero_iff_le`, as a `@[simp]`-lemma."
  theorem: "{Î± : Type u_1} [canonically_ordered_add_monoid Î±] [has_sub Î±] [has_ordered_sub Î±] {a b : Î±} (h : a â‰¤ b) : a - b = 0"

- doc_string: "A monoid is not a torsion monoid if it has an element of infinite order."
  theorem: "(G : Type u_1) [monoid G] : Â¬monoid.is_torsion G â†” âˆƒ (g : G), Â¬is_of_fin_order g"

- doc_string: "If `C` has an initial object and binary coproducts, then it has finite coproducts."
  theorem: "{C : Type u} [category_theory.category C] [category_theory.limits.has_binary_coproducts C] [category_theory.limits.has_initial C] : category_theory.limits.has_finite_coproducts C"

- doc_string: "**Alias** of lt_of_le_of_ne'`."
  theorem: "{Î± : Type u} [partial_order Î±] {a b : Î±} : a â‰¤ b â†’ b â‰  a â†’ a < b"

- doc_string: " Coercing an in-range number to `fin (n + 1)`, and converting back to `â„•`, results in that number."
  theorem: "{n a : â„•} (h : a < n + 1) : â†‘â†‘a = a"

- doc_string: "`a â‰¤ -b â†’ b â‰¤ -a` on ereal"
  theorem: "{a b : ereal} (h : a â‰¤ -b) : b â‰¤ -a"

- doc_string: " Every positive `x` is between two successive integer powers of another `y` greater than one. This is the same as `exists_mem_Ioc_zpow`, but with â‰¤ and < the other way around."
  theorem: "{Î± : Type u_1} [linear_ordered_field Î±] [archimedean Î±] {x y : Î±} (hx : 0 < x) (hy : 1 < y) : âˆƒ (n : â„¤), x âˆˆ set.Ico (y ^ n) (y ^ (n + 1))"

- doc_string: "**Alias** of the forward direction of order.pred_le_pred_iff`."
  theorem: "{Î± : Type u_1} [preorder Î±] [pred_order Î±] {a b : Î±} [no_min_order Î±] : order.pred a â‰¤ order.pred b â†’ a â‰¤ b"

- doc_string: "Any sieve is smaller than its closure."
  theorem: "{C : Type u} [category_theory.category C] (Jâ‚ : category_theory.grothendieck_topology C) {X : C} (S : category_theory.sieve X) : S â‰¤ Jâ‚.close S"

- doc_string: " If `R` is a ring which is a topological semiring, then it is automatically a topological ring. This exists so that one can place a topological ring structure on `R` without explicitly proving `continuous_neg`."
  theorem: "{Î± : Type u_1} [topological_space Î±] [non_assoc_ring Î±] (h : topological_semiring Î±) : topological_ring Î±"

- doc_string: "**Alias** of eq_or_lt_of_le`."
  theorem: "{Î± : Type u} [partial_order Î±] {a b : Î±} (h : a â‰¤ b) : a = b âˆ¨ a < b"

- doc_string: "The Jordan decomposition of a signed measure is unique."
  theorem: "{Î± : Type u_1} [measurable_space Î±] : function.injective measure_theory.jordan_decomposition.to_signed_measure"

- doc_string: "The set of natural number multiples of an element of an `add_submonoid` is a subset of the `add_submonoid`."
  theorem: "{M : Type u_1} [add_monoid M] {s : set M} {a : M} (hs : is_add_submonoid s) (h : a âˆˆ s) : multiples a âŠ† s"

- doc_string: "**Alias** of lt_of_lt_of_eq`."
  theorem: "{Î± : Type u} [preorder Î±] {a b c : Î±} (hab : a < b) (hbc : b = c) : a < c"

- doc_string: "The indexed infimum of a function is bounded above by the value taken at one point"
  theorem: "{Î± : Type u_1} {Î¹ : Sort u_3} [conditionally_complete_lattice Î±] {f : Î¹ â†’ Î±} (H : bdd_below (set.range f)) (c : Î¹) : infi f â‰¤ f c"

- doc_string: " If `find p` returns `some i`, then `p j` does not hold for `j < i`, i.e., `i` is minimal among the indices where `p` holds."
  theorem: "{n : â„•} {p : fin n â†’ Prop} [decidable_pred p] {i : fin n} (hi : i âˆˆ fin.find p) {j : fin n} (hj : j < i) : Â¬p j"

- doc_string: "**Alias** of the reverse direction of le_sub_iff_add_le`."
  theorem: "{Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b c : Î±} : a + b â‰¤ c â†’ a â‰¤ c - b"

- doc_string: " Assumes right covariance. The lemma assuming left covariance is `left.mul_lt_one`."
  theorem: "{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_mul.mul) has_lt.lt] {a b : Î±} (ha : a < 1) (hb : b < 1) : a * b < 1"

- doc_string: "An explicit version of **BÃ©zout's lemma** for Euclidean domains."
  theorem: "{R : Type u} [euclidean_domain R] [decidable_eq R] (a b : R) : euclidean_domain.gcd a b = a * euclidean_domain.gcd_a a b + b * euclidean_domain.gcd_b a b"

- doc_string: "The identity map preserves multiplication."
  theorem: "{Î± : Type u} [has_mul Î±] : is_mul_hom id"

- doc_string: "The identity map is a semiring homomorphism."
  theorem: "{Î± : Type u} [semiring Î±] : is_semiring_hom id"

- doc_string: "A minimal polynomial is not `1`."
  theorem: "(A : Type u_1) {B : Type u_2} [comm_ring A] [ring B] [algebra A B] (x : B) [nontrivial B] : minpoly A x â‰  1"

- doc_string: "A surjective map has dense range."
  theorem: "{Î² : Type u_2} [topological_space Î²] {Îº : Type u_5} {f : Îº â†’ Î²} (hf : function.surjective f) : dense_range f"

- doc_string: "In an `n`-dimensional space, the rank is at most `m`."
  theorem: "{R : Type u_1} [ring R] [strong_rank_condition R] (n : â„•) {m : â„•} (v : fin m â†’ fin n â†’ R) : linear_independent R v â†’ m â‰¤ n"

- doc_string: " For `f : â„• â†’ Î±`, then `âˆ‘' k, f (k + i)` tends to zero. This does not require a summability assumption on `f`, as otherwise all sums are zero."
  theorem: "{Î± : Type u_1} [add_comm_group Î±] [topological_space Î±] [topological_add_group Î±] [t2_space Î±] (f : â„• â†’ Î±) : filter.tendsto (Î» (i : â„•), âˆ‘' (k : â„•), f (k + i)) filter.at_top (nhds 0)"

- doc_string: "**Alias** of `left.add_nonneg`."
  theorem: "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : 0 â‰¤ a) (hb : 0 â‰¤ b) : 0 â‰¤ a + b"

- doc_string: "Colex is an extension of the base ordering on Î±."
  theorem: "{Î± : Type u_1} [linear_order Î±] {r s : Î±} : {r}.to_colex < {s}.to_colex â†” r < s"

- doc_string: "The intersection of a closed set and a compact set is a compact set."
  theorem: "{Î± : Type u} [topological_space Î±] {s t : set Î±} (ht : is_compact t) (hs : is_closed s) : is_compact (s âˆ© t)"

- doc_string: "If `0 < n`, then `dihedral_group n` has `2n` elements."
  theorem: "{n : â„•} [fact (0 < n)] : fintype.card (dihedral_group n) = 2 * n"

- doc_string: "In a locally compact space, every compact set is contained in the interior of a compact set."
  theorem: "{Î± : Type u} [topological_space Î±] [locally_compact_space Î±] {K : set Î±} (hK : is_compact K) : âˆƒ (K' : set Î±), is_compact K' âˆ§ K âŠ† interior K'"

- doc_string: "Out of three elements of a `linear_ordered_ring`, two must have the same sign."
  theorem: "{Î± : Type u} [linear_ordered_ring Î±] (a b c : Î±) : 0 â‰¤ a * b âˆ¨ 0 â‰¤ b * c âˆ¨ 0 â‰¤ c * a"

- doc_string: "If `s` and `t` are bounded above sets in a `semilattice_sup`, then so is `s âˆª t`."
  theorem: "{Î³ : Type w} [semilattice_sup Î³] {s t : set Î³} : bdd_above s â†’ bdd_above t â†’ bdd_above (s âˆª t)"

- doc_string: "The union of two sets is bounded above if and only if each of the sets is."
  theorem: "{Î³ : Type w} [semilattice_inf Î³] {s t : set Î³} : bdd_below (s âˆª t) â†” bdd_below s âˆ§ bdd_below t"

- doc_string: "The finrank of `(Î¹ â†’ R)` is `fintype.card Î¹`."
  theorem: "(R : Type u) [ring R] [strong_rank_condition R] {Î¹ : Type v} [fintype Î¹] : finite_dimensional.finrank R (Î¹ â†’ R) = fintype.card Î¹"

- doc_string: "Any category with products and equalizers has all limits.  See <https://stacks.math.columbia.edu/tag/002N>."
  theorem: "{C : Type u} [category_theory.category C] [category_theory.limits.has_products C] [category_theory.limits.has_equalizers C] : category_theory.limits.has_limits C"

- doc_string: "An alternative version of `subtype.forall`. This one is useful if Lean cannot figure out `q`  when using `subtype.forall` from right to left."
  theorem: "{Î± : Sort u_1} {p : Î± â†’ Prop} {q : Î  (x : Î±), p x â†’ Prop} : (âˆ€ (x : Î±) (h : p x), q x h) â†” âˆ€ (x : {a // p a}), q â†‘x _"

- doc_string: "1 is of finite order in any monoid."
  theorem: "{G : Type u} [monoid G] : is_of_fin_order 1"

- doc_string: "If matrix A is left invertible, then its inverse equals its left inverse."
  theorem: "{n : Type u'} {Î± : Type v} [fintype n] [decidable_eq n] [comm_ring Î±] {A B : matrix n n Î±} (h : B.mul A = 1) : Aâ»Â¹ = B"

- doc_string: "To match `one_mul_eq_id`."
  theorem: "{Mâ‚€ : Type u_1} [mul_zero_class Mâ‚€] : has_mul.mul 0 = function.const Mâ‚€ 0"

- doc_string: "**Alias** of zero_lt_one`."
  theorem: "{Î± : Type u} [ordered_semiring Î±] [nontrivial Î±] : 0 < 1"

- doc_string: " `disjointed f` is the unique sequence that is pairwise disjoint and has the same partial sups as `f`."
  theorem: "{Î± : Type u_1} [generalized_boolean_algebra Î±] {f d : â„• â†’ Î±} (hdisj : pairwise (disjoint on d)) (hsups : partial_sups d = partial_sups f) : d = disjointed f"

- doc_string: "Deprecated: use `fun_like.congr_arg` instead."
  theorem: "{M : Type u_3} {N : Type u_4} [has_zero M] [has_zero N] (f : zero_hom M N) {x y : M} (h : x = y) : â‡‘f x = â‡‘f y"

- doc_string: "**Alias** of left.one_le_inv_iff`."
  theorem: "{Î± : Type u} [group Î±] [has_le Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a : Î±} : 1 â‰¤ aâ»Â¹ â†” a â‰¤ 1"

- doc_string: "**Alias** of left.inv_lt_one_iff`."
  theorem: "{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a : Î±} : -a < 0 â†” 0 < a"

- doc_string: "See also `continuous_map.continuous_eval_const`"
  theorem: "{Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [compact_space Î±] [metric_space Î²] (x : Î±) : continuous (Î» (f : C(Î±, Î²)), â‡‘f x)"

- doc_string: " Left `mul` by a `k : Î±` over `[ring Î±]` is injective, if `k` is not a zero divisor. The typeclass that restricts all terms of `Î±` to have this property is `no_zero_divisors`."
  theorem: "{Î± : Type u} [non_unital_non_assoc_ring Î±] (k : Î±) (h : âˆ€ (x : Î±), k * x = 0 â†’ x = 0) : is_left_regular k"

- doc_string: "`mul_action.to_perm` is injective on faithful actions."
  theorem: "{Î± : Type u} {Î² : Type v} [group Î±] [mul_action Î± Î²] [has_faithful_smul Î± Î²] : function.injective mul_action.to_perm"

- doc_string: "**Alias** of the forward direction of filter.tendsto_iff_comap`."
  theorem: "{Î± : Type u} {Î² : Type v} {f : Î± â†’ Î²} {lâ‚ : filter Î±} {lâ‚‚ : filter Î²} : filter.tendsto f lâ‚ lâ‚‚ â†’ lâ‚ â‰¤ filter.comap f lâ‚‚"

- doc_string: "**Alias** of the reverse direction of inv_mul_lt_iff_lt_mul`."
  theorem: "{Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a b c : Î±} : a < b * c â†’ bâ»Â¹ * a < c"

- doc_string: "The vector space of functions on a fintype Î¹ has finrank equal to the cardinality of Î¹."
  theorem: "(K : Type u) [division_ring K] {Î¹ : Type v} [fintype Î¹] : finite_dimensional.finrank K (Î¹ â†’ K) = fintype.card Î¹"

- doc_string: " The distance from `x` to `s` or `t` is controlled in terms of the Hausdorff distance between `s` and `t`"
  theorem: "{Î± : Type u} [pseudo_emetric_space Î±] {x : Î±} {s t : set Î±} : emetric.inf_edist x t â‰¤ emetric.inf_edist x s + emetric.Hausdorff_edist s t"

- doc_string: "The composition of Frobenius and Verschiebung is multiplication by `p`."
  theorem: "{p : â„•} {R : Type u_1} [hp : fact (nat.prime p)] [comm_ring R] (x : witt_vector p R) : â‡‘witt_vector.frobenius (â‡‘witt_vector.verschiebung x) = x * â†‘p"

- doc_string: "Shows that the fractional parts of the stream are nonnegative."
  theorem: "{K : Type u_1} {v : K} {n : â„•} [linear_ordered_field K] [floor_ring K] {ifp_n : generalized_continued_fraction.int_fract_pair K} (nth_stream_eq : generalized_continued_fraction.int_fract_pair.stream v n = option.some ifp_n) : 0 â‰¤ ifp_n.fr"

- doc_string: "Non-zero elements of an integral domain are regular."
  theorem: "{R : Type u_1} {a : R} [cancel_monoid_with_zero R] (a0 : a â‰  0) : is_regular a"

- doc_string: "Two natural numbers are equal if and only if the have the same multiples."
  theorem: "{m n : â„•} : (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n"

- doc_string: "The identity is a group homomorphism."
  theorem: "{Î± : Type u} [group Î±] : is_group_hom id"

- doc_string: "**Alias** of the forward direction of function.injective_iff_pairwise_ne`."
  theorem: "{Î± : Type u_1} {Î¹ : Type u_2} {f : Î¹ â†’ Î±} : function.injective f â†’ pairwise (ne on f)"

- doc_string: " The negation of an element a of a semigroup with a distributive negation divides another element b iff a divides b."
  theorem: "{Î± : Type u} [semigroup Î±] [has_distrib_neg Î±] (a b : Î±) : -a âˆ£ b â†” a âˆ£ b"

- doc_string: "**Alias** of le_of_eq_of_le'`."
  theorem: "{Î± : Type u} [preorder Î±] {a b c : Î±} : b = c â†’ a â‰¤ b â†’ a â‰¤ c"

- doc_string: "When lowered to a prop, `matrix.diagonal_invertible_equiv_invertible` forms an `iff`."
  theorem: "{n : Type u'} {Î± : Type v} [fintype n] [decidable_eq n] [comm_ring Î±] {v : n â†’ Î±} : is_unit (matrix.diagonal v) â†” is_unit v"

- doc_string: "**Alias** of lt_of_mul_lt_mul_left'`."
  theorem: "{Î± : Type u_1} [has_add Î±] [has_lt Î±] [contravariant_class Î± Î± has_add.add has_lt.lt] {a b c : Î±} (bc : a + b < a + c) : b < c"

- doc_string: "If the elements of a set are independent, then any pair within that set is disjoint."
  theorem: "{Î± : Type u_1} {Î¹ : Type u_3} [complete_lattice Î±] {t : Î¹ â†’ Î±} (ht : complete_lattice.independent t) : pairwise (disjoint on t)"

- doc_string: "Every set has a measurable superset. Declare this as local instance as needed."
  theorem: "{Î± : Type u_1} {m : measurable_space Î±} (s : set Î±) : nonempty {t // s âŠ† t âˆ§ measurable_set t}"

- doc_string: "An element a divides the sum b + a if and only if a divides b."
  theorem: "{Î± : Type u} [ring Î±] {a b : Î±} : a âˆ£ b + a â†” a âˆ£ b"

- doc_string: "The intersection of a dense set with an open dense set is a dense set."
  theorem: "{Î± : Type u} [topological_space Î±] {s t : set Î±} (hs : dense s) (ht : dense t) (hto : is_open t) : dense (s âˆ© t)"

- doc_string: "Assumes left covariance. The lemma assuming right covariance is `right.add_nonpos`."
  theorem: "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : a â‰¤ 0) (hb : b â‰¤ 0) : a + b â‰¤ 0"

- doc_string: " If `Ï„` is a `canonically_ordered_add_monoid` (e.g., `â„•` or `â„â‰¥0`), then the notions `is_fw_invariant` and `is_invariant` are equivalent."
  theorem: "{Ï„ : Type u_1} {Î± : Type u_2} [canonically_ordered_add_monoid Ï„] {Ï• : Ï„ â†’ Î± â†’ Î±} {s : set Î±} (h : is_fw_invariant Ï• s) : is_invariant Ï• s"

- doc_string: " **Cantor's diagonal argument** implies that there are no surjective functions from `Î±` to `set Î±`."
  theorem: "{Î± : Type u_1} (f : Î± â†’ set Î±) : Â¬function.surjective f"

- doc_string: " A finite dimensional vector space Over an `is_R_or_C` is a proper metric space.  This is not an instance because it would cause a search for `finite_dimensional ?x E` before `is_R_or_C ?x`."
  theorem: "(K : Type u_1) [is_R_or_C K] (E : Type u_2) [normed_group E] [normed_space K E] [finite_dimensional K E] : proper_space E"

- doc_string: "An open set is a GÎ´ set."
  theorem: "{Î± : Type u_1} [topological_space Î±] {s : set Î±} (h : is_open s) : is_GÎ´ s"

- doc_string: "**Alias** of the forward direction of list.mem_map`."
  theorem: "{Î± : Type u} {Î² : Type v} {f : Î± â†’ Î²} {b : Î²} {l : list Î±} : b âˆˆ list.map f l â†’ (âˆƒ (a : Î±), a âˆˆ l âˆ§ f a = b)"

- doc_string: "In an additive semigroup, the sum of add-right-regular elements is add-right-regular."
  theorem: "{R : Type u_1} {a b : R} [add_semigroup R] (rra : is_add_right_regular a) (rrb : is_add_right_regular b) : is_add_right_regular (a + b)"

- doc_string: "**Alias** of the reverse direction of filter.germ.coe_tendsto`."
  theorem: "{Î± : Type u_1} {Î² : Type u_2} {l : filter Î±} {f : Î± â†’ Î²} {lb : filter Î²} : filter.tendsto f l lb â†’ â†‘f.tendsto lb"

- doc_string: "See `add_tsub_cancel_right` for the equality if `contravariant_class Î± Î± (+) (â‰¤)`."
  theorem: "{Î± : Type u_1} [preorder Î±] [has_add Î±] [has_sub Î±] [has_ordered_sub Î±] {a b : Î±} : a + b - b â‰¤ a"

- doc_string: "The variable of the power series ring over an integral domain is prime."
  theorem: "{R : Type u_1} [comm_ring R] [is_domain R] : prime power_series.X"

- doc_string: "For rewriting in the reverse direction, see `fin.cast_add_nat_left`."
  theorem: "{n n' m : â„•} (i : fin n') (h : n' = n) : â‡‘(fin.add_nat m) (â‡‘(fin.cast h) i) = â‡‘(fin.cast _) (â‡‘(fin.add_nat m) i)"

- doc_string: " For every prime `p` dividing the order of a finite group `G` there exists an element of order `p` in `G`. This is known as Cauchy's theorem."
  theorem: "{G : Type u_1} [group G] [fintype G] (p : â„•) [hp : fact (nat.prime p)] (hdvd : p âˆ£ fintype.card G) : âˆƒ (x : G), order_of x = p"

- doc_string: "**Alias** of the reverse direction of lt_sub_iff_add_lt`."
  theorem: "{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b c : Î±} : a + b < c â†’ a < c - b"

- doc_string: "A characterization of `enum_ord`: it is the unique strict monotonic function with range `S`."
  theorem: "{S : set ordinal} (f : ordinal â†’ ordinal) (hS : set.unbounded has_lt.lt S) : strict_mono f âˆ§ set.range f = S â†” f = ordinal.enum_ord S"

- doc_string: "  Two elements `a` and `b` are regular if and only if both products `a * b` and `b * a` are regular."
  theorem: "{R : Type u_1} {a b : R} [semigroup R] : is_regular (a * b) âˆ§ is_regular (b * a) â†” is_regular a âˆ§ is_regular b"

- doc_string: "**Alias** of lt_mul_of_inv_mul_lt`."
  theorem: "{Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a b c : Î±} : bâ»Â¹ * a < c â†’ a < b * c"

- doc_string: "If there's more than 1 element, the min' is less than the max'. An alternate version of `min'_lt_max'` which is sometimes more convenient."
  theorem: "{Î± : Type u_1} [linear_order Î±] (s : finset Î±) (hâ‚‚ : 1 < s.card) : s.min' _ < s.max' _"

- doc_string: "Let `X` be a topological space, and suppose that for all distinct `x,y âˆˆ X`, there  is some clopen set `U` such that `x âˆˆ U` and `y âˆ‰ U`. Then `X` is totally disconnected."
  theorem: "{X : Type u_1} [topological_space X] (hX : âˆ€ {x y : X}, x â‰  y â†’ (âˆƒ (U : set X) (h_clopen : is_clopen U), x âˆˆ U âˆ§ y âˆ‰ U)) : is_totally_disconnected set.univ"

- doc_string: "Embedding `i : fin n` into `fin (n + 1)` is always about some hole `p`."
  theorem: "{n : â„•} (p : fin (n + 1)) (i : fin n) : â‡‘fin.cast_succ i < p âˆ¨ p â‰¤ â‡‘fin.cast_succ i"

- doc_string: "`cast_succ i` is positive when `i` is positive"
  theorem: "{n : â„•} {i : fin (n + 1)} (h : 0 < i) : 0 < â‡‘fin.cast_succ i"

- doc_string: "Prime `p` divides the product of a list `L` iff it divides some `a âˆˆ L`"
  theorem: "{M : Type u_1} [comm_monoid_with_zero M] {p : M} {L : list M} (pp : prime p) : p âˆ£ L.prod â†” âˆƒ (a : M) (H : a âˆˆ L), p âˆ£ a"

- doc_string: " Assumes right covariance. The lemma assuming left covariance is `left.one_lt_mul_of_le_of_lt`."
  theorem: "{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_mul.mul) has_le.le] {a b : Î±} (ha : 1 â‰¤ a) (hb : 1 < b) : 1 < a * b"

- doc_string: " The cast of the successor is the succesor of the cast. See `fin.succ_cast_eq` for rewriting in the reverse direction."
  theorem: "{n n' : â„•} (i : fin n) (h : n.succ = n'.succ) : â‡‘(fin.cast h) i.succ = (â‡‘(fin.cast _) i).succ"

- doc_string: "The finite field `F` has even cardinality iff it has characteristic `2`."
  theorem: "{F : Type u_3} [field F] [fintype F] : ring_char F = 2 â†” fintype.card F % 2 = 0"

- doc_string: "For `a : F`, `quadratic_char F a = -1 â†” Â¬ is_square a`."
  theorem: "{F : Type u_1} [field F] [fintype F] [decidable_eq F] {a : F} : char.quadratic_char F a = -1 â†” Â¬is_square a"

- doc_string: "Law of Excluded Middle."
  theorem: "(p : Prop) [decidable p] : p âˆ¨ Â¬p"

- doc_string: "Indexed version of the above lemma `exists_lt_of_cInf_lt` When `infi f < a`, there is an element `i` such that `f i < a`."
  theorem: "{Î± : Type u_1} {Î¹ : Sort u_3} [conditionally_complete_linear_order Î±] {a : Î±} [nonempty Î¹] {f : Î¹ â†’ Î±} (h : infi f < a) : âˆƒ (i : Î¹), f i < a"

- doc_string: " An equivalent definition for prime powers: `n` is a prime power iff there is a prime `p` and a natural `k` such that `n` can be written as `p^(k+1)`."
  theorem: "{R : Type u_1} [comm_monoid_with_zero R] (n : R) : is_prime_pow n â†” âˆƒ (p : R) (k : â„•), prime p âˆ§ p ^ (k + 1) = n"

- doc_string: "Triangle inequality for the extended distance"
  theorem: "{Î± : Type u} [pseudo_emetric_space Î±] (x y z : Î±) : has_edist.edist x y â‰¤ has_edist.edist z x + has_edist.edist z y"

- doc_string: "The sum of two squares is zero iff both elements are zero."
  theorem: "{Î± : Type u} [linear_ordered_ring Î±] {x y : Î±} : x * x + y * y = 0 â†” x = 0 âˆ§ y = 0"

- doc_string: "Assumes right covariance. The lemma assuming left covariance is `left.add_neg'`."
  theorem: "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±} (ha : a < 0) (hb : b < 0) : a + b < 0"

- doc_string: "A `finset` of a subsingleton type has cardinality at most one."
  theorem: "{Î± : Type u_1} [subsingleton Î±] (s : finset Î±) : s.card â‰¤ 1"

- doc_string: "An element admitting a right additive opposite is add-right-regular."
  theorem: "{R : Type u_1} {a b : R} [add_monoid R] (h : a + b = 0) : is_add_right_regular a"

- doc_string: "A nontrivial torsion-free group is not torsion."
  theorem: "{G : Type u_1} [group G] [hN : nontrivial G] : monoid.is_torsion_free G â†’ Â¬monoid.is_torsion G"

- doc_string: "Two gcfs `g` and `g'` are equal if and only if their components are equal."
  theorem: "{Î± : Type u_1} {g g' : generalized_continued_fraction Î±} : g = g' â†” g.h = g'.h âˆ§ g.s = g'.s"

- doc_string: "The first coefficient of `id ð•œ E` is the identity."
  theorem: "(ð•œ : Type u_1) (E : Type u_2) [nondiscrete_normed_field ð•œ] [normed_group E] [normed_space ð•œ E] (v : fin 1 â†’ E) : â‡‘(formal_multilinear_series.id ð•œ E 1) v = v 0"

- doc_string: "If `s âŠ† t`, then the diameter of `s` is bounded by that of `t`, provided `t` is bounded."
  theorem: "{Î± : Type u} [pseudo_metric_space Î±] {s t : set Î±} (h : s âŠ† t) (ht : metric.bounded t) : metric.diam s â‰¤ metric.diam t"

- doc_string: "Additive congruence relations preserve addition."
  theorem: "{M : Type u_1} [has_add M] (c : add_con M) {w x y z : M} : â‡‘c w x â†’ â‡‘c y z â†’ â‡‘c (w + y) (x + z)"

- doc_string: "Empty relation is well-founded"
  theorem: "{Î± : Sort u} : well_founded empty_relation"

- doc_string: "The reduction step does not change the product vector."
  theorem: "(u : pnat.xgcd_type) (hr : u.r â‰  0) : u.step.v = u.v.swap"

- doc_string: "A set is contained in its `span_points`."
  theorem: "(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P) : s âŠ† span_points k s"

- doc_string: "**Alias** of the forward direction of order.succ_lt_succ_iff`."
  theorem: "{Î± : Type u_1} [preorder Î±] [succ_order Î±] {a b : Î±} [no_max_order Î±] : order.succ a < order.succ b â†’ a < b"

- doc_string: "An inequality involving `2`."
  theorem: "{Î± : Type u_1} [linear_ordered_field Î±] {a : Î±} (a2 : 2 â‰¤ a) : (1 - 1 / a)â»Â¹ â‰¤ 2"

- doc_string: "For `n â‰  1`, the `n`-th coefficient of `id ð•œ E` is zero, by definition."
  theorem: "(ð•œ : Type u_1) (E : Type u_2) [nondiscrete_normed_field ð•œ] [normed_group E] [normed_space ð•œ E] {n : â„•} (h : n â‰  1) : formal_multilinear_series.id ð•œ E n = 0"

- doc_string: " The `cons` and `head`/`tail` functions are mutually inverse, unlike in the case of `list` where this only holds for nonempty lists."
  theorem: "{Î“ : Type u_1} [inhabited Î“] (l : turing.list_blank Î“) : turing.list_blank.cons l.head l.tail = l"

- doc_string: "Moving to the opposite monoid commutes with taking powers."
  theorem: "{M : Type u} [monoid M] (x : M) (n : â„•) : mul_opposite.op (x ^ n) = mul_opposite.op x ^ n"

- doc_string: "`opow b` and `log b` (almost) form a Galois connection."
  theorem: "{b x c : ordinal} (b1 : 1 < b) (x0 : 0 < x) : b ^ c â‰¤ x â†” c â‰¤ ordinal.log b x"

- doc_string: " `fin` as a map from `â„•` to `Type` is injective. Note that since this is a statement about equality of types, using it should be avoided if possible."
  theorem: " : function.injective fin"

- doc_string: "The kernel of the natural homomorphism from a monoid to its quotient by a congruence    relation `c` equals `c`."
  theorem: "{M : Type u_1} [mul_one_class M] (c : con M) : con.ker c.mk' = c"

- doc_string: "A pair (i, j) is contained in the antidiagonal of `n` if and only if `i + j = n`."
  theorem: "{n : â„•} {x : â„• Ã— â„•} : x âˆˆ list.nat.antidiagonal n â†” x.fst + x.snd = n"

- doc_string: " Note we use `â†‘i = 0` instead of `i = 0` as `fin 0` has no `0`. This means that we cannot state this with `pi.single` as we did with `matrix.circulant_single`."
  theorem: "(Î± : Type u_1) [has_zero Î±] [has_one Î±] (n : â„•) : matrix.circulant (Î» (i : fin n), ite (â†‘i = 0) 1 0) = 1"

- doc_string: "**Alias** of pow_two`."
  theorem: "{M : Type u} [monoid M] (a : M) : a ^ 2 = a * a"

- doc_string: "`has_colimits_of_size_shrink.{v u} C` tries to obtain `has_colimits_of_size.{v u} C` from some other `has_colimits_of_size C`."
  theorem: "(C : Type u) [category_theory.category C] [category_theory.limits.has_colimits_of_size C] : category_theory.limits.has_colimits_of_size C"

- doc_string: "**Alias** of the forward direction of left.one_le_inv_iff`."
  theorem: "{Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± has_add.add has_le.le] {a : Î±} : 0 â‰¤ -a â†’ a â‰¤ 0"

- doc_string: " While `fin.coe_order_iso_apply` is a more general case of this, we mark this `simp` anyway as it is eligible for `dsimp`."
  theorem: "{n m : â„•} (h : n = m) (i : fin n) : â†‘(â‡‘(fin.cast h) i) = â†‘i"

- doc_string: "`âŠ¥`, coerced to a set, is the empty set."
  theorem: "(k : Type u_1) (V : Type u_2) (P : Type u_3) [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] : â†‘âŠ¥ = âˆ…"

- doc_string: "**Alias** of dvd.intro_left`."
  theorem: "{Î± : Type u_1} [comm_semigroup Î±] {a b : Î±} (c : Î±) (h : c * a = b) : a âˆ£ b"

- doc_string: "One semiconjugates any element to itself."
  theorem: "{M : Type u} [mul_one_class M] (x : M) : semiconj_by 1 x x"

- doc_string: "Assumes right covariance."
  theorem: "{Î± : Type u} {a b : Î±} [mul_one_class Î±] [has_zero Î±] [preorder Î±] [zero_lt.mul_pos_mono Î±] (ha : a â‰¤ 1) (hb : b < 1) (b0 : 0 < b) : a * b < 1"

- doc_string: "The basis of open subgroups for the topology on a ring determined by a valuation."
  theorem: "{R : Type u} [ring R] {Î“â‚€ : Type v} [linear_ordered_comm_group_with_zero Î“â‚€] (v : valuation R Î“â‚€) : ring_subgroups_basis (Î» (Î³ : Î“â‚€Ë£), v.lt_add_subgroup Î³)"

- doc_string: "**Alias** of the forward direction of inseparable_iff_nhds_eq`."
  theorem: "{X : Type u_1} [topological_space X] {x y : X} : inseparable x y â†’ nhds x = nhds y"

- doc_string: "**Alias** of decidable.eq_or_lt_of_le`."
  theorem: "{Î± : Type u} [partial_order Î±] [decidable_rel has_le.le] {a b : Î±} (hab : a â‰¤ b) : a = b âˆ¨ a < b"

- doc_string: "Assumes left covariance."
  theorem: "{Î± : Type u} {a b : Î±} [mul_zero_class Î±] [preorder Î±] [zero_lt.pos_mul_strict_mono Î±] (ha : 0 < a) (hb : 0 < b) : 0 < a * b"

- doc_string: "An orthonormal set is linearly independent."
  theorem: "{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [inner_product_space ð•œ E] {Î¹ : Type u_4} {v : Î¹ â†’ E} (hv : orthonormal ð•œ v) : linear_independent ð•œ v"

- doc_string: "Express `dist` in terms of `nndist`"
  theorem: "{Î± : Type u} [pseudo_metric_space Î±] (x y : Î±) : has_dist.dist x y = â†‘(has_nndist.nndist x y)"

- doc_string: "The function `lmul_left_right : ð•œ' Ã— ð•œ' â†’ (ð•œ' â†’L[ð•œ] ð•œ')` is a bounded bilinear map."
  theorem: "(ð•œ : Type u_1) [nondiscrete_normed_field ð•œ] (ð•œ' : Type u_2) [normed_ring ð•œ'] [normed_algebra ð•œ ð•œ'] : is_bounded_bilinear_map ð•œ (Î» (p : ð•œ' Ã— ð•œ'), â‡‘(â‡‘(continuous_linear_map.lmul_left_right ð•œ ð•œ') p.fst) p.snd)"

- doc_string: "**Alias** of zero_lt_two`."
  theorem: "{Î± : Type u} [ordered_semiring Î±] [nontrivial Î±] : 0 < 2"

- doc_string: "The intersection of two submonoids of a monoid `M` is a submonoid of `M`."
  theorem: "{M : Type u_1} [monoid M] {sâ‚ sâ‚‚ : set M} (isâ‚ : is_submonoid sâ‚) (isâ‚‚ : is_submonoid sâ‚‚) : is_submonoid (sâ‚ âˆ© sâ‚‚)"

- doc_string: "An element is a root of its minimal polynomial."
  theorem: "(A : Type u_1) {B : Type u_2} [comm_ring A] [ring B] [algebra A B] (x : B) : â‡‘(polynomial.aeval x) (minpoly A x) = 0"

- doc_string: " An element of a `cancel_monoid_with_zero` fixed by left multiplication by an element other than one must be zero."
  theorem: "{Mâ‚€ : Type u_1} [cancel_monoid_with_zero Mâ‚€] {a b : Mâ‚€} (hâ‚ : b â‰  1) (hâ‚‚ : b * a = a) : a = 0"

- doc_string: "Uses `right` co(ntra)variant."
  theorem: "{Î± : Type u} [group Î±] [has_le Î±] [covariant_class Î± Î± (function.swap has_mul.mul) has_le.le] {a : Î±} : aâ»Â¹ â‰¤ 1 â†” 1 â‰¤ a"

- doc_string: " A finite dimensional space has zero `finrank` iff it is a subsingleton. This is the `finrank` version of `dim_zero_iff`."
  theorem: "{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] : finite_dimensional.finrank K V = 0 â†” subsingleton V"

- doc_string: "If `monoid_algebra R M` is of finite type then `M` is finitely generated."
  theorem: "{R : Type u_1} {M : Type u_2} [comm_monoid M] [comm_ring R] [nontrivial R] [h : algebra.finite_type R (monoid_algebra R M)] : monoid.fg M"

- doc_string: "Assumes right covariance. The lemma assuming left covariance is `left.add_pos`."
  theorem: "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b : Î±} (ha : 0 < a) (hb : 0 < b) : 0 < a + b"

- doc_string: "The minimal distance of a point to a set containing it vanishes"
  theorem: "{Î± : Type u} [pseudo_metric_space Î±] {s : set Î±} {x : Î±} (h : x âˆˆ s) : metric.inf_dist x s = 0"

- doc_string: 'The "most used" implication of `add_and_add_iff`, with split hypotheses, instead of `âˆ§`.'
  theorem: "{R : Type u_1} {a b : R} [add_semigroup R] (ab : is_add_regular (a + b)) (ba : is_add_regular (b + a)) : is_add_regular a âˆ§ is_add_regular b"

- doc_string: "Another way of expressing `strong_induction_on`: the `(<)` relation is well-founded."
  theorem: "{Î± : Type u_1} : well_founded has_lt.lt"

- doc_string: "Additive congruence relations are transitive."
  theorem: "{M : Type u_1} [has_add M] (c : add_con M) {x y z : M} : â‡‘c x y â†’ â‡‘c y z â†’ â‡‘c x z"

- doc_string: "When we have `[comm_semiring R]`, the function `C` is the same as `algebra_map R R[X]`.  (But note that `C` is defined when `R` is not necessarily commutative, in which case `algebra_map` is not available.)"
  theorem: "{R : Type u} [comm_semiring R] (r : R) : â‡‘polynomial.C r = â‡‘(algebra_map R (polynomial R)) r"

- doc_string: " A set `s` is not bounded below if and only if for each `x` there exists `y âˆˆ s` such that `x` is not less than or equal to `y`. This version only assumes `preorder` structure and uses `Â¬(x â‰¤ y)`. A version for linear orders is called `not_bdd_below_iff`."
  theorem: "{Î± : Type u} [preorder Î±] {s : set Î±} : Â¬bdd_below s â†” âˆ€ (x : Î±), âˆƒ (y : Î±) (H : y âˆˆ s), Â¬x â‰¤ y"

- doc_string: "The coercion to the quotient of a congruence relation commutes with multiplication (by    definition)."
  theorem: "{M : Type u_1} [has_mul M] {c : con M} (x y : M) : â†‘(x * y) = â†‘x * â†‘y"

- doc_string: "Odd Bernoulli numbers (greater than 1) are zero."
  theorem: "{n : â„•} (h_odd : odd n) (hlt : 1 < n) : bernoulli' n = 0"

- doc_string: "**Alias** of the reverse direction of sub_pos`."
  theorem: "{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b : Î±} : b < a â†’ 0 < a - b"

- doc_string: "the minimal distance is always nonnegative"
  theorem: "{Î± : Type u} [pseudo_metric_space Î±] {s : set Î±} {x : Î±} : 0 â‰¤ metric.inf_dist x s"

- doc_string: "Any nonempty Polish space is the continuous image of the fundamental space `â„• â†’ â„•`."
  theorem: "(Î± : Type u_1) [topological_space Î±] [polish_space Î±] [nonempty Î±] : âˆƒ (f : (â„• â†’ â„•) â†’ Î±), continuous f âˆ§ function.surjective f"

- doc_string: "Expressing the product of two polynomials as a double sum."
  theorem: "{R : Type u} [semiring R] {p q : polynomial R} : p * q = p.support.sum (Î» (i : â„•), q.sum (Î» (j : â„•) (a : R), â‡‘(polynomial.monomial (i + j)) (p.coeff i * a)))"

- doc_string: "`â„¤` with its usual ring structure is not a field."
  theorem: " : Â¬is_field â„¤"

- doc_string: "If the unique morphism from `A` to a terminal object is a monomorphism, `A` is subterminal. The converse of `is_subterminal.mono_is_terminal_from`."
  theorem: "{C : Type uâ‚} [category_theory.category C] {A T : C} (hT : category_theory.limits.is_terminal T) [category_theory.mono (hT.from A)] : category_theory.is_subterminal A"

- doc_string: " Assumes left covariance. The lemma assuming right covariance is `right.one_lt_mul_of_lt_of_le`."
  theorem: "{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a b : Î±} (ha : 1 < a) (hb : 1 â‰¤ b) : 1 < a * b"

- doc_string: "The last element of a `vector`, given that the vector is at least one element."
  theorem: "{n : â„•} {Î± : Type u_1} {v : vector Î± (n + 1)} : v.last = v.nth (fin.last n)"

- doc_string: "For any natural numbers n, a, and b, one of the following holds: 1. n < a 2. n â‰¥ b 3. n âˆˆ Ico a b"
  theorem: "(n a b : â„•) : n < a âˆ¨ b â‰¤ n âˆ¨ n âˆˆ list.Ico a b"

- doc_string: "Two pseudo metric space structures with the same distance function coincide."
  theorem: "{Î± : Type u_1} {m m' : pseudo_metric_space Î±} (h : pseudo_metric_space.to_has_dist = pseudo_metric_space.to_has_dist) : m = m'"

- doc_string: "Given all finite wide pullbacks in `C`, construct finite products in `C/B`."
  theorem: "{C : Type u} [category_theory.category C] [category_theory.limits.has_finite_wide_pullbacks C] {B : C} : category_theory.limits.has_finite_products (category_theory.over B)"

- doc_string: "Definition of `â‰¤` for additive congruence relations."
  theorem: "{M : Type u_1} [has_add M] {c d : add_con M} : c â‰¤ d â†” âˆ€ {x y : M}, â‡‘c x y â†’ â‡‘d x y"

- doc_string: "The identity map is a monoid homomorphism."
  theorem: "{Î± : Type u} [mul_one_class Î±] : is_monoid_hom id"

- doc_string: "When we have `[comm_semiring R]`, the function `C` is the same as `algebra_map R R[T;Tâ»Â¹]`. (But note that `C` is defined when `R` is not necessarily commutative, in which case `algebra_map` is not available.)"
  theorem: "{R : Type u_1} [comm_semiring R] (r : R) : â‡‘laurent_polynomial.C r = â‡‘(algebra_map R (laurent_polynomial R)) r"

- doc_string: " Assumes left covariance. The lemma assuming right covariance is `right.mul_le_one`."
  theorem: "{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a b : Î±} (ha : a â‰¤ 1) (hb : b â‰¤ 1) : a * b â‰¤ 1"

- doc_string: " **Fermat's theorem on the sum of two squares**. Every prime congruent to 1 mod 4 is the sum of two squares. Also known as **Fermat's Christmas theorem**."
  theorem: "{p : â„•} [fact (nat.prime p)] (hp : p % 4 = 1) : âˆƒ (a b : â„•), a ^ 2 + b ^ 2 = p"

- doc_string: "`map_alg` is the morphism induced by `R â†’ S`."
  theorem: "{R : Type u} [comm_semiring R] {S : Type v} [semiring S] [algebra R S] (p : polynomial R) : â‡‘(polynomial.map_alg R S) p = polynomial.map (algebra_map R S) p"

- doc_string: "If `a` commutes with `b`, then `b` commutes with `a`."
  theorem: "{S : Type u_1} [has_mul S] {a b : S} (h : commute a b) : commute b a"

- doc_string: "In a Polish space, a set is clopenable if and only if it is Borel-measurable."
  theorem: "{Î³ : Type u_3} [tÎ³ : topological_space Î³] [polish_space Î³] [measurable_space Î³] [borel_space Î³] {s : set Î³} : polish_space.is_clopenable s â†” measurable_set s"

- doc_string: "**Alias** of the forward direction of left.inv_lt_one_iff`."
  theorem: "{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a : Î±} : -a < 0 â†’ 0 < a"

- doc_string: "A subset of a monoid is contained in the submonoid it generates."
  theorem: "{M : Type u_1} [monoid M] {s : set M} : s âŠ† monoid.closure s"

- doc_string: "Any category with coproducts and coequalizers has all colimits.  See <https://stacks.math.columbia.edu/tag/002P>."
  theorem: "{C : Type u} [category_theory.category C] [category_theory.limits.has_coproducts C] [category_theory.limits.has_coequalizers C] : category_theory.limits.has_colimits C"

- doc_string: "The union of two sets is bounded above if and only if each of the sets is."
  theorem: "{Î³ : Type w} [semilattice_sup Î³] {s t : set Î³} : bdd_above (s âˆª t) â†” bdd_above s âˆ§ bdd_above t"

- doc_string: "**Alias** of the forward direction of left.inv_le_one_iff`."
  theorem: "{Î± : Type u} [group Î±] [has_le Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a : Î±} : aâ»Â¹ â‰¤ 1 â†’ 1 â‰¤ a"

- doc_string: " Two lists of sublists are equal iff their joins coincide, as well as the lengths of the sublists."
  theorem: "{Î± : Type u_1} (L L' : list (list Î±)) : L = L' â†” L.join = L'.join âˆ§ list.map list.length L = list.map list.length L'"

- doc_string: "**Alias** of the reverse direction of is_min_on_dual_iff`."
  theorem: "{Î± : Type u} {Î² : Type v} [preorder Î²] {f : Î± â†’ Î²} {s : set Î±} {a : Î±} : is_max_on f s a â†’ is_min_on (â‡‘order_dual.to_dual âˆ˜ f) s a"

- doc_string: "The new distance is an extension of the original distance."
  theorem: "{Î± : Type u} [pseudo_metric_space Î±] (x y : Î±) : has_dist.dist â†‘x â†‘y = has_dist.dist x y"

- doc_string: "The sum of two well-founded games is well-founded."
  theorem: "{Î± : Type u_1} {Î² : Type u_2} {rÎ± : Î± â†’ Î± â†’ Prop} {rÎ² : Î² â†’ Î² â†’ Prop} (hÎ± : well_founded rÎ±) (hÎ² : well_founded rÎ²) : well_founded (relation.game_add rÎ± rÎ²)"

- doc_string: "`âˆ i in nat.divisors n, cyclotomic i R = X ^ n - 1`."
  theorem: "{n : â„•} (hpos : 0 < n) (R : Type u_1) [comm_ring R] : n.divisors.prod (Î» (i : â„•), polynomial.cyclotomic i R) = polynomial.X ^ n - 1"

- doc_string: " `tail` and `init` commute. We state this lemma in a non-dependent setting, as otherwise it would involve a cast to convince Lean that the two types are equal, making it harder to use."
  theorem: "{n : â„•} {Î² : Type u_1} (q : fin (n + 2) â†’ Î²) : fin.tail (fin.init q) = fin.init (fin.tail q)"

- doc_string: "The exponential map in `ð•‚ = â„` or `ð•‚ = â„‚` has derivative `1` at zero."
  theorem: "{ð•‚ : Type u_1} [is_R_or_C ð•‚] : has_deriv_at (exp ð•‚) 1 0"

- doc_string: "A Cauchy sequence in a complete space converges"
  theorem: "{Î± : Type u} {Î² : Type v} [uniform_space Î±] [semilattice_sup Î²] [complete_space Î±] {u : Î² â†’ Î±} (H : cauchy_seq u) : âˆƒ (x : Î±), filter.tendsto u filter.at_top (nhds x)"

- doc_string: "If `a` commutes with both `b` and `c`, then it commutes with their sum."
  theorem: "{S : Type u_1} [add_semigroup S] {a b c : S} (hab : add_commute a b) (hac : add_commute a c) : add_commute a (b + c)"

- doc_string: "`sinh` is surjective, `âˆ€ b, âˆƒ a, sinh a = b`. In this case, we use `a = arsinh b`."
  theorem: " : function.surjective real.sinh"

- doc_string: "Congruence lemma for constructing `ex.prod`."
  theorem: "{Î± : Type u} [comm_semiring Î±] {p p' ps ps' : Î±} : p = p' â†’ ps = ps' â†’ p * ps = p' * ps'"

- doc_string: "Bernoulli's inequality reformulated to estimate `(n : K)`."
  theorem: "{K : Type u_1} [linear_ordered_field K] {a : K} (H : 1 < a) (n : â„•) : â†‘n â‰¤ (a ^ n - 1) / (a - 1)"

- doc_string: "**Alias** of the reverse direction of sub_nonpos`."
  theorem: "{Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±} : a â‰¤ b â†’ a - b â‰¤ 0"

- doc_string: " Note: this lemma is specifically about `fintype.of_is_empty`. For a statement about arbitrary `fintype` instances, use `fintype.card_eq_zero_iff`."
  theorem: "{Î± : Type u_1} [is_empty Î±] : fintype.card Î± = 0"

- doc_string: "The class number of a principal ideal domain is `1`."
  theorem: "{R : Type u_1} {K : Type u_2} [comm_ring R] [field K] [algebra R K] [is_fraction_ring R K] [is_domain R] [is_principal_ideal_ring R] : fintype.card (class_group R K) = 1"

- doc_string: "Multiplicative congruence relations preserve integer powers."
  theorem: "{M : Type u_1} [group M] (c : con M) (n : â„¤) {w x : M} : â‡‘c w x â†’ â‡‘c (w ^ n) (x ^ n)"

- doc_string: "The ray given by the negation of a nonzero vector."
  theorem: "(R : Type u_1) [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] (v : M) (h : v â‰  0) : -ray_of_ne_zero R v h = ray_of_ne_zero R (-v) _"

- doc_string: "For nonzero `a : F`, `quadratic_char F a = 1 â†” is_square a`."
  theorem: "{F : Type u_1} [field F] [fintype F] [decidable_eq F] {a : F} (ha : a â‰  0) : char.quadratic_char F a = 1 â†” is_square a"

- doc_string: "An additive unit in an additive monoid is add-regular."
  theorem: "{R : Type u_1} {a : R} [add_monoid R] (ua : is_add_unit a) : is_add_regular a"

- doc_string: "Ring homomorphisms map zero to zero."
  theorem: "{Î± : Type u} {Î² : Type v} [ring Î±] [ring Î²] {f : Î± â†’ Î²} (hf : is_ring_hom f) : f 0 = 0"

- doc_string: "`![a, b, ...] 1` is equal to `b`.   The simplifier needs a special lemma for length `â‰¥ 2`, in addition to  `cons_val_succ`, because `1 : fin 1 = 0 : fin 1`."
  theorem: "{Î± : Type u} {m : â„•} (x : Î±) (u : fin m.succ â†’ Î±) : matrix.vec_cons x u 1 = matrix.vec_head u"

- doc_string: "Pushforward a `nontrivial` instance along an injective function."
  theorem: "{Î± : Type u_1} {Î² : Type u_2} [nontrivial Î±] {f : Î± â†’ Î²} (hf : function.injective f) : nontrivial Î²"

- doc_string: "`choose n r` is maximised when `r` is `n/2`."
  theorem: "(r n : â„•) : n.choose r â‰¤ n.choose (n / 2)"

- doc_string: "A semiring is local if it is nontrivial and the set of nonunits is closed under the addition."
  theorem: "{R : Type u} [comm_semiring R] [nontrivial R] (h : âˆ€ (a b : R), a âˆˆ nonunits R â†’ b âˆˆ nonunits R â†’ a + b âˆˆ nonunits R) : local_ring R"

- doc_string: "The identity map is an additive monoid homomorphism."
  theorem: "{Î± : Type u} [add_zero_class Î±] : is_add_monoid_hom id"

- doc_string: "An injective sequence `f : â„• â†’ â„•` tends to infinity at infinity."
  theorem: "{f : â„• â†’ â„•} (hf : function.injective f) : filter.tendsto f filter.at_top filter.at_top"

- doc_string: "The rank of a free module `M` over `R` is the cardinality of `choose_basis_index R M`."
  theorem: "(R : Type u) (M : Type v) [ring R] [strong_rank_condition R] [add_comm_group M] [module R M] [module.free R M] : module.rank R M = cardinal.mk (module.free.choose_basis_index R M)"

- doc_string: " Any finite-dimensional vector space over a proper field is proper. We do not register this as an instance to avoid an instance loop when trying to prove the properness of `ð•œ`, and the search for `ð•œ` as an unknown metavariable. Declare the instance explicitly when needed."
  theorem: "(ð•œ : Type u) [nondiscrete_normed_field ð•œ] (E : Type v) [normed_group E] [normed_space ð•œ E] [proper_space ð•œ] [finite_dimensional ð•œ E] : proper_space E"

- doc_string: "If adding `0` on either side is the identity, `0` is regular."
  theorem: "{R : Type u_1} [add_zero_class R] : is_add_regular 0"

- doc_string: "In a non-trivial ring, the element `0` is not regular -- with typeclasses."
  theorem: "{R : Type u_1} [mul_zero_class R] [nontrivial R] : Â¬is_regular 0"

- doc_string: "Assumes left covariance. The lemma assuming right covariance is `right.add_pos_of_nonneg_of_pos`."
  theorem: "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b : Î±} (ha : 0 â‰¤ a) (hb : 0 < b) : 0 < a + b"

- doc_string: "Implication `â†’` is transitive. If `P â†’ Q` and `Q â†’ R` then `P â†’ R`."
  theorem: "{p q r : Prop} (hâ‚ : implies p q) (hâ‚‚ : implies q r) : implies p r"

- doc_string: "**Alias** of decidable.lt_or_eq_of_le`."
  theorem: "{Î± : Type u} [partial_order Î±] [decidable_rel has_le.le] {a b : Î±} (hab : a â‰¤ b) : a < b âˆ¨ a = b"

- doc_string: "**Alias** of the forward direction of sub_neg`."
  theorem: "{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b : Î±} : a - b < 0 â†’ a < b"

- doc_string: "`centroid_weights` at any point."
  theorem: "(k : Type u_1) [division_ring k] {Î¹ : Type u_4} (s : finset Î¹) (i : Î¹) : finset.centroid_weights k s i = (â†‘(s.card))â»Â¹"

- doc_string: "**Alias** of le_of_le_of_eq`."
  theorem: "{Î± : Type u} [preorder Î±] {a b c : Î±} (hab : a â‰¤ b) (hbc : b = c) : a â‰¤ c"

- doc_string: "If `n > 0` then `m` is not divisible by `n` iff it is between `n * k` and `n * (k + 1)`  for some `k`."
  theorem: "(m : â„¤) {n : â„¤} (hn : 0 < n) : (âˆƒ (k : â„¤), n * k < m âˆ§ m < n * (k + 1)) â†” Â¬n âˆ£ m"

- doc_string: "In a preadditive category, if the coproduct of `X` and `Y` exists, then the    binary biproduct of `X` and `Y` exists."
  theorem: "{C : Type u} [category_theory.category C] [category_theory.preadditive C] (X Y : C) [category_theory.limits.has_binary_coproduct X Y] : category_theory.limits.has_binary_biproduct X Y"

- doc_string: "If `C` has all colimits of diagrams `pair X Y`, then it has all binary coproducts"
  theorem: "(C : Type u) [category_theory.category C] [âˆ€ {X Y : C}, category_theory.limits.has_colimit (category_theory.limits.pair X Y)] : category_theory.limits.has_binary_coproducts C"

- doc_string: "If `0 < n`, then `xa i` has order 4."
  theorem: "{n : â„•} [hpos : fact (0 < n)] (i : zmod (2 * n)) : order_of (quaternion_group.xa i) = 4"

- doc_string: "A sum is add-regular if and only if the summands are."
  theorem: "{R : Type u_1} {a b : R} [add_comm_semigroup R] : is_add_regular (a + b) â†” is_add_regular a âˆ§ is_add_regular b"

- doc_string: " Assumes left covariance. The lemma assuming right covariance is `right.one_lt_mul_of_le_of_lt`."
  theorem: "{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a b : Î±} (ha : 1 â‰¤ a) (hb : 1 < b) : 1 < a * b"

- doc_string: "If `x` is a fixed point of `f âˆ˜ g` and `g`, then it is a fixed point of `f`."
  theorem: "{Î± : Type u} {f g : Î± â†’ Î±} {x : Î±} (hfg : function.is_fixed_pt (f âˆ˜ g) x) (hg : function.is_fixed_pt g x) : function.is_fixed_pt f x"

- doc_string: " If a word reduces to another word, then they have a common maximal reduction."
  theorem: "{Î± : Type u} {Lâ‚ Lâ‚‚ : list (Î± Ã— bool)} [decidable_eq Î±] (H : free_group.red Lâ‚ Lâ‚‚) : free_group.reduce Lâ‚ = free_group.reduce Lâ‚‚"

- doc_string: "Two natural numbers are equal if and only if the have the same divisors."
  theorem: "{m n : â„•} : (âˆ€ (a : â„•), a âˆ£ m â†” a âˆ£ n) â†” m = n"

- doc_string: " Given an embedding of a topological space into a metrizable space, the source space is also metrizable."
  theorem: "{X : Type u_2} {Y : Type u_3} [topological_space X] [topological_space Y] [topological_space.metrizable_space Y] {f : X â†’ Y} (hf : embedding f) : topological_space.metrizable_space X"

- doc_string: "The `last` element of a vector is the `head` of the `reverse` vector."
  theorem: "{n : â„•} {Î± : Type u_1} {v : vector Î± (n + 1)} : v.reverse.head = v.last"

- doc_string: "**Alias** of le_trans`."
  theorem: "{Î± : Type u} [preorder Î±] {a b c : Î±} : a â‰¤ b â†’ b â‰¤ c â†’ a â‰¤ c"

- doc_string: "The identity is an additive group homomorphism."
  theorem: "{Î± : Type u} [add_group Î±] : is_add_group_hom id"

- doc_string: " Note this is not an instance as `char_zero` implies `nontrivial`, and this would risk forming a loop."
  theorem: "{R : Type u_1} [ordered_semiring R] [nontrivial R] : char_zero R"

- doc_string: " If `Î±` has no zero divisors, then the product of two elements equals zero iff one of them equals zero."
  theorem: "{Mâ‚€ : Type u_1} [mul_zero_class Mâ‚€] [no_zero_divisors Mâ‚€] {a b : Mâ‚€} : 0 = a * b â†” a = 0 âˆ¨ b = 0"

- doc_string: "`pure : Î± â†’ ultrafilter Î±` defines a dense inducing of `Î±` in `ultrafilter Î±`."
  theorem: "{Î± : Type u} : dense_inducing has_pure.pure"

- doc_string: "The `0`-th auxiliary function `f_aux 0` coincides with `exp_neg_inv_glue`, by definition."
  theorem: " : exp_neg_inv_glue.f_aux 0 = exp_neg_inv_glue"

- doc_string: "Ring homomorphisms preserve additive inverses."
  theorem: "{Î± : Type u} {Î² : Type v} [ring Î±] [ring Î²] {f : Î± â†’ Î²} {x : Î±} (hf : is_ring_hom f) : f (-x) = -f x"

- doc_string: "**Alias** of the reverse direction of set.sized_union`."
  theorem: "{Î± : Type u_1} {A B : set (finset Î±)} {r : â„•} : set.sized r A âˆ§ set.sized r B â†’ set.sized r (A âˆª B)"

- doc_string: "If `0 < n`, then `sr i` has order 2."
  theorem: "{n : â„•} (i : zmod n) : order_of (dihedral_group.sr i) = 2"

- doc_string: "The map `coe_fn : (r â‰ƒ s) â†’ (r â†’ s)` is injective."
  theorem: "{Î± : Sort u} {Î² : Sort v} : function.injective coe_fn"

- doc_string: "Any open set is the union of the basis sets contained in it."
  theorem: "{Î± : Type u} [t : topological_space Î±] {B : set (set Î±)} (hB : topological_space.is_topological_basis B) {u : set Î±} (ou : is_open u) : u = â‹ƒâ‚€{s âˆˆ B | s âŠ† u}"

- doc_string: "**Alias** of the forward direction of order.succ_le_succ_iff`."
  theorem: "{Î± : Type u_1} [preorder Î±] [succ_order Î±] {a b : Î±} [no_max_order Î±] : order.succ a â‰¤ order.succ b â†’ a â‰¤ b"

- doc_string: "A natural number `m` divides the sum `n + m` if and only if `m` divides `n`."
  theorem: "{m n : â„•} : m âˆ£ n + m â†” m âˆ£ n"

- doc_string: "A minimal polynomial is prime."
  theorem: "{A : Type u_1} {B : Type u_2} [field A] [ring B] [is_domain B] [algebra A B] {x : B} (hx : is_integral A x) : prime (minpoly A x)"

- doc_string: "**Alias** of the forward direction of sub_nonneg`."
  theorem: "{Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±} : 0 â‰¤ a - b â†’ b â‰¤ a"

- doc_string: "**Alias** of the reverse direction of nat.count_succ_eq_succ_count_iff`."
  theorem: "{p : â„• â†’ Prop} [decidable_pred p] {n : â„•} : p n â†’ nat.count p (n + 1) = nat.count p n + 1"

- doc_string: "A version of `nat.sub_succ` in the form `_ - 1` instead of `nat.pred _`."
  theorem: "(a b : â„•) : a - b.succ = a - b - 1"

- doc_string: "An involution commutes across an equality. Compare to `function.injective.eq_iff`."
  theorem: "{Î± : Sort u} {f : Î± â†’ Î±} (h : function.involutive f) {x y : Î±} : f x = y â†” x = f y"

- doc_string: " So-named because the coercion is `nat.cast` into `zmod`. For `nat.cast` into an arbitrary ring, see `zmod.nat_cast_val`."
  theorem: "{n : â„•} [fact (0 < n)] (a : zmod n) : â†‘(a.val) = a"

- doc_string: " Product of elements of a list `L` equals zero if and only if `0 âˆˆ L`. See also `list.prod_eq_zero` for an implication that needs weaker typeclass assumptions."
  theorem: "{Mâ‚€ : Type u_6} [monoid_with_zero Mâ‚€] [nontrivial Mâ‚€] [no_zero_divisors Mâ‚€] {L : list Mâ‚€} : L.prod = 0 â†” 0 âˆˆ L"

- doc_string: " Assumes right covariance. The lemma assuming left covariance is `left.one_lt_mul'`."
  theorem: "{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_mul.mul) has_le.le] {a b : Î±} (ha : 1 < a) (hb : 1 < b) : 1 < a * b"

- doc_string: "Submonoids are closed under natural powers."
  theorem: "{M : Type u_1} [monoid M] {s : set M} {a : M} (hs : is_submonoid s) (h : a âˆˆ s) {n : â„•} : a ^ n âˆˆ s"

- doc_string: "Elements of a right cancel semigroup are right regular."
  theorem: "{R : Type u_1} [right_cancel_semigroup R] (g : R) : is_right_regular g"

- doc_string: " If `x` is an adherent (cluster) point for a Cauchy filter `f`, then it is a limit point for `f`."
  theorem: "{Î± : Type u} [uniform_space Î±] {f : filter Î±} {x : Î±} (hf : cauchy f) (adhs : cluster_pt x f) : f â‰¤ nhds x"

- doc_string: "Two permutations `f g : perm Î±` have the same cycle factors iff they are the same."
  theorem: "{Î± : Type u_1} [decidable_eq Î±] [fintype Î±] : function.injective equiv.perm.cycle_factors_finset"

- doc_string: " Test for convergence of the `p`-series: the real-valued series `âˆ‘' n : â„•, 1 / n ^ p` converges if and only if `1 < p`."
  theorem: "{p : â„•} : summable (Î» (n : â„•), 1 / â†‘n ^ p) â†” 1 < p"

- doc_string: " A nonempty preorder with no minimal element is infinite. This is not an instance to avoid a cycle with `infinite Î± â†’ nontrivial Î± â†’ nonempty Î±`."
  theorem: "{Î± : Type u_1} [preorder Î±] [nonempty Î±] [no_min_order Î±] : infinite Î±"

- doc_string: "Iff version of extensionality rule for congruence relations."
  theorem: "{M : Type u_1} [has_mul M] {c d : con M} : (âˆ€ (x y : M), â‡‘c x y â†” â‡‘d x y) â†” c = d"

- doc_string: "`same_ray` is symmetric."
  theorem: "{R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {x y : M} (h : same_ray R x y) : same_ray R y x"

- doc_string: "For the single implications with fewer assumptions, see `one_div_lt_one_div_of_lt` and  `lt_of_one_div_lt_one_div`"
  theorem: "{Î± : Type u_1} [linear_ordered_field Î±] {a b : Î±} (ha : 0 < a) (hb : 0 < b) : 1 / a < 1 / b â†” b < a"

- doc_string: "If `Î±` is a preorder with no maximal element, then `at_top â‰¤ cofinite`."
  theorem: "{Î± : Type u_2} [preorder Î±] [no_max_order Î±] : filter.at_top â‰¤ filter.cofinite"

- doc_string: "The `k`th coefficient of `polynomial.taylor r f` is `(polynomial.hasse_deriv k f).eval r`."
  theorem: "{R : Type u_1} [semiring R] (r : R) (f : polynomial R) (n : â„•) : (â‡‘(polynomial.taylor r) f).coeff n = polynomial.eval r (â‡‘(polynomial.hasse_deriv n) f)"

- doc_string: 'The "greater than" relation on `upto p` is well founded if (and only if) there exists a value satisfying `p`.'
  theorem: "{p : â„• â†’ Prop} : (âˆƒ (x : â„•), p x) â†’ well_founded (nat.upto.gt p)"

- doc_string: "If a vector space has a finite basis, then it is finite-dimensional."
  theorem: "{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {Î¹ : Type w} [fintype Î¹] (h : basis Î¹ K V) : finite_dimensional K V"

- doc_string: "**Alias** of the reverse direction of is_extr_filter_dual_iff`."
  theorem: "{Î± : Type u} {Î² : Type v} [preorder Î²] {f : Î± â†’ Î²} {l : filter Î±} {a : Î±} : is_extr_filter f l a â†’ is_extr_filter (â‡‘order_dual.to_dual âˆ˜ f) l a"

- doc_string: "If `F` has odd characteristic, then `quadratic_char F` takes the value `-1`."
  theorem: "{F : Type u_1} [field F] [fintype F] [decidable_eq F] (hF : ring_char F â‰  2) : âˆƒ (a : F), char.quadratic_char F a = -1"

- doc_string: "The image of stone_cech_unit is dense. (But stone_cech_unit need  not be an embedding, for example if Î± is not Hausdorff.)"
  theorem: "{Î± : Type u} [topological_space Î±] : dense_range stone_cech_unit"

- doc_string: " Auxiliary lemma: Multivariate polynomials over an integral domain with variables indexed by `fin n` form an integral domain. This fact is proven inductively, and then used to prove the general case without any finiteness hypotheses. See `mv_polynomial.is_domain` for the general case."
  theorem: "(R : Type u) [comm_ring R] [is_domain R] (n : â„•) : is_domain (mv_polynomial (fin n) R)"

- doc_string: "In a connected category, any two objects are related by `zigzag`."
  theorem: "{J : Type uâ‚} [category_theory.category J] [category_theory.is_connected J] (jâ‚ jâ‚‚ : J) : category_theory.zigzag jâ‚ jâ‚‚"

- doc_string: "Uses `right` co(ntra)variant."
  theorem: "{Î± : Type u} [group Î±] [has_le Î±] [covariant_class Î± Î± (function.swap has_mul.mul) has_le.le] {a : Î±} : 1 â‰¤ aâ»Â¹ â†” a â‰¤ 1"

- doc_string: "There exists at most one `floor_ring` structure on a given linear ordered ring."
  theorem: "{Î± : Type u_1} [linear_ordered_ring Î±] : subsingleton (floor_ring Î±)"

- doc_string: "The `nonsing_inv` of `A` is a right inverse."
  theorem: "{n : Type u'} {Î± : Type v} [fintype n] [decidable_eq n] [comm_ring Î±] (A : matrix n n Î±) (h : is_unit A.det) : A.mul Aâ»Â¹ = 1"

- doc_string: "The span of a finite subset is compact in the lattice of submodules."
  theorem: "{R : Type u_1} {M : Type u_4} [semiring R] [add_comm_monoid M] [module R M] (S : finset M) : complete_lattice.is_compact_element (submodule.span R â†‘S)"

- doc_string: "Assumes left covariance."
  theorem: "{Î± : Type u} {a b : Î±} [mul_one_class Î±] [has_zero Î±] [preorder Î±] [zero_lt.pos_mul_strict_mono Î±] (ha : a < 1) (hb : b < 1) (a0 : 0 < a) : a * b < 1"

- doc_string: "`order_emb_of_fin {a} h` sends any argument to `a`."
  theorem: "{Î± : Type u_1} [linear_order Î±] (a : Î±) (i : fin 1) : â‡‘({a}.order_emb_of_fin _) i = a"

- doc_string: "If `s` has a greatest lower bound, then it is bounded below."
  theorem: "{Î± : Type u} [preorder Î±] {s : set Î±} {a : Î±} (h : is_glb s a) : bdd_below s"

- doc_string: "The p-adic norm of 1 is 1."
  theorem: "(p : â„•) : padic_norm p 1 = 1"

- doc_string: "Subtracting an element is the same as adding by its negative.  This is a duplicate of `sub_neg_monoid.sub_eq_mul_neg` ensuring that the types unfold better."
  theorem: "{G : Type u_1} [sub_neg_monoid G] (a b : G) : a - b = a + -b"

- doc_string: "A specialized ext lemma for equality of psigma types over an indexed subtype."
  theorem: "{Î± : Sort u_1} {Î² : Sort u_2} {p : Î± â†’ Î² â†’ Prop} {xâ‚€ xâ‚ : Î£' (a : Î±), subtype (p a)} : xâ‚€.fst = xâ‚.fst â†’ â†‘(xâ‚€.snd) = â†‘(xâ‚.snd) â†’ xâ‚€ = xâ‚"

- doc_string: "Given a pullback in `C`, construct a binary product in `C/B`."
  theorem: "{C : Type u} [category_theory.category C] [category_theory.limits.has_pullbacks C] {B : C} : category_theory.limits.has_binary_products (category_theory.over B)"

- doc_string: "A version of the global `continuous_inv` suitable for dot notation."
  theorem: "{Î± : Type u} [group Î±] (g : group_topology Î±) : continuous has_inv.inv"

- doc_string: "**Alias** of `left.add_pos_of_pos_of_nonneg`."
  theorem: "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : 0 < a) (hb : 0 â‰¤ b) : 0 < a + b"

- doc_string: "If `p` is prime, and `a` doesn't divide `p^k`, but `a` does divide `p^(k+1)` then `a = p^(k+1)`."
  theorem: "{a p k : â„•} (pp : nat.prime p) (hâ‚ : Â¬a âˆ£ p ^ k) (hâ‚‚ : a âˆ£ p ^ (k + 1)) : a = p ^ (k + 1)"

- doc_string: "Deprecated: use `fun_like.congr_fun` instead."
  theorem: "{M : Type u_3} {N : Type u_4} [has_one M] [has_one N] {f g : one_hom M N} (h : f = g) (x : M) : â‡‘f x = â‡‘g x"

- doc_string: "In a nontrivial monoid with zero, zero and one are different."
  theorem: "{Mâ‚€ : Type u_1} [mul_zero_one_class Mâ‚€] [nontrivial Mâ‚€] : 0 â‰  1"

- doc_string: " `s.subtype p` converts back to `s.filter p` with `embedding.subtype`."
  theorem: "{Î± : Type u_1} {s : finset Î±} (p : Î± â†’ Prop) [decidable_pred p] : finset.map (function.embedding.subtype p) (finset.subtype p s) = finset.filter p s"

- doc_string: "Rectangles form a Ï€-system."
  theorem: "{Î± : Type u_1} {Î² : Type u_3} [measurable_space Î±] [measurable_space Î²] : is_pi_system (set.image2 has_set_prod.prod {s : set Î± | measurable_set s} {t : set Î² | measurable_set t})"

- doc_string: "Embedding a positive `fin n` results in a positive fin (n + 1)`"
  theorem: "{n : â„•} (p : fin (n + 2)) (i : fin (n + 1)) (h : 0 < i) : 0 < â‡‘(p.succ_above) i"

- doc_string: "`clog b` and `pow b` form a Galois connection."
  theorem: "{b : â„•} (hb : 1 < b) {x y : â„•} : x â‰¤ b ^ y â†” nat.clog b x â‰¤ y"

- doc_string: " This lemma characterizes discrete topological spaces as those whose singletons are neighbourhoods."
  theorem: "{X : Type u_1} [topological_space X] : discrete_topology X â†” nhds = has_pure.pure"

- doc_string: " If the domain of a `uniform_inducing` map `f` is a `separated_space`, then `f` is injective, hence it is a `uniform_embedding`."
  theorem: "{Î± : Type u_1} {Î² : Type u_2} [uniform_space Î±] [uniform_space Î²] [separated_space Î±] {f : Î± â†’ Î²} (hf : uniform_inducing f) : uniform_embedding f"

- doc_string: "**Alias** of the reverse direction of is_min_filter_dual_iff`."
  theorem: "{Î± : Type u} {Î² : Type v} [preorder Î²] {f : Î± â†’ Î²} {l : filter Î±} {a : Î±} : is_max_filter f l a â†’ is_min_filter (â‡‘order_dual.to_dual âˆ˜ f) l a"

- doc_string: "`R` is finitely presented as `R`-algebra."
  theorem: "(R : Type u_1) [comm_ring R] : algebra.finite_presentation R R"

- doc_string: " If `Î±` is a nonempty preorder with no maximal elements, then there exists a strictly monotone function `â„• â†’ Î±`."
  theorem: "(Î± : Type u) [preorder Î±] [nonempty Î±] [no_max_order Î±] : âˆƒ (f : â„• â†’ Î±), strict_mono f"

- doc_string: "**Alias** of the reverse direction of is_square_inv`."
  theorem: "{Î± : Type u_2} [division_monoid Î±] {a : Î±} : is_square a â†’ is_square aâ»Â¹"

- doc_string: "The p-adic norm of 0 is 0."
  theorem: "(p : â„•) : padic_norm p 0 = 0"

- doc_string: "`succ_above` is injective at the pivot"
  theorem: "{n : â„•} : function.injective fin.succ_above"

- doc_string: "**Alias** of sbtw_cyclic_right`."
  theorem: "{Î± : Type u_1} [circular_preorder Î±] {a b c : Î±} (h : has_sbtw.sbtw a b c) : has_sbtw.sbtw c a b"

- doc_string: " A version of `strongly_measurable_const` that assumes `f x = f y` for all `x, y`. This version works for functions between empty types."
  theorem: "{Î± : Type u_1} {Î² : Type u_2} {m : measurable_space Î±} [topological_space Î²] {f : Î± â†’ Î²} (hf : âˆ€ (x y : Î±), f x = f y) : measure_theory.strongly_measurable f"

- doc_string: "An element admitting a right inverse is right-regular."
  theorem: "{R : Type u_1} {a b : R} [monoid R] (h : a * b = 1) : is_right_regular a"

- doc_string: "**Alias** of the forward direction of measurable_iff_le_map`."
  theorem: "{Î± : Type u_1} {Î² : Type u_2} {mâ‚ : measurable_space Î±} {mâ‚‚ : measurable_space Î²} {f : Î± â†’ Î²} : measurable f â†’ mâ‚‚ â‰¤ measurable_space.map f mâ‚"

- doc_string: "Right-regular multiplication on `R` is equivalent to `Ráµáµ’áµ–`-regularity of `R` itself."
  theorem: "{R : Type u_1} [has_mul R] {a : R} : is_right_regular a â†” is_smul_regular R (mul_opposite.op a)"

- doc_string: "Two elements are related by an additive congruence relation `c` iff they are represented by the same element of the quotient by `c`."
  theorem: "{M : Type u_1} [has_add M] (c : add_con M) {a b : M} : â†‘a = â†‘b â†” â‡‘c a b"

- doc_string: "This is the same as `order_of_pos' but with one fewer explicit assumption since this is  automatic in case of a finite cancellative monoid."
  theorem: "{G : Type u} [fintype G] [left_cancel_monoid G] (x : G) : 0 < order_of x"

- doc_string: " If `P : â„¤ â†’ Prop` is a predicate such that the set `{m : P m}` is bounded below and nonempty, then this set has the least element. This lemma uses classical logic to avoid assumption `[decidable_pred P]`. See `int.least_of_bdd` for a constructive counterpart."
  theorem: "{P : â„¤ â†’ Prop} (Hbdd : âˆƒ (b : â„¤), âˆ€ (z : â„¤), P z â†’ b â‰¤ z) (Hinh : âˆƒ (z : â„¤), P z) : âˆƒ (lb : â„¤), P lb âˆ§ âˆ€ (z : â„¤), P z â†’ lb â‰¤ z"

- doc_string: "A finset is bounded below."
  theorem: "{Î± : Type u} [semilattice_inf Î±] [nonempty Î±] (s : finset Î±) : bdd_below â†‘s"

- doc_string: " Assumes left covariance. The lemma assuming right covariance is `right.one_lt_mul'`."
  theorem: "{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a b : Î±} (ha : 1 < a) (hb : 1 < b) : 1 < a * b"

- doc_string: "**Alias** of the reverse direction of antitone_to_dual_comp_iff`."
  theorem: "{Î± : Type u} {Î² : Type v} [preorder Î±] [preorder Î²] {f : Î± â†’ Î²} : monotone f â†’ antitone (â‡‘order_dual.to_dual âˆ˜ f)"

- doc_string: "If `a^(p-1) = 1 mod p`, but `a^((p-1)/q) â‰  1 mod p` for all prime factors `q` of `p-1`, then `p` is prime. This is true because `a` has order `p-1` in the multiplicative group mod `p`, so this group must itself have order `p-1`, which only happens when `p` is prime."
  theorem: "(p : â„•) (a : zmod p) (ha : a ^ (p - 1) = 1) (hd : âˆ€ (q : â„•), nat.prime q â†’ q âˆ£ p - 1 â†’ a ^ ((p - 1) / q) â‰  1) : nat.prime p"

- doc_string: " An unbounded set has zero diameter. If you would prefer to get the value âˆž, use `emetric.diam`. This lemma makes it possible to avoid side conditions in some situations"
  theorem: "{Î± : Type u} [pseudo_metric_space Î±] {s : set Î±} (h : Â¬metric.bounded s) : metric.diam s = 0"

- doc_string: "**Alias** of the reverse direction of strict_mono_to_dual_comp_iff`."
  theorem: "{Î± : Type u} {Î² : Type v} [preorder Î±] [preorder Î²] {f : Î± â†’ Î²} : strict_anti f â†’ strict_mono (â‡‘order_dual.to_dual âˆ˜ f)"

- doc_string: "**Alias** of the reverse direction of set.injective_cod_restrict`."
  theorem: "{Î± : Type u} {Î² : Type v} {t : set Î²} {f : Î± â†’ Î²} (h : âˆ€ (x : Î±), f x âˆˆ t) : function.injective f â†’ function.injective (set.cod_restrict f t h)"

- doc_string: "Properties of division with remainder for a / b."
  theorem: "(u : pnat.xgcd_type) : u.r + (u.bp + 1) * u.q = u.ap + 1"

- doc_string: "One is `M`-regular always."
  theorem: "{R : Type u_1} (M : Type u_3) [monoid R] [mul_action R M] : is_smul_regular M 1"

- doc_string: " If a reflexive relation `r : Î± â†’ Î± â†’ Prop` holds over `x y : Î±`, then it holds whether or not `x â‰  y`. Unlike `reflexive.ne_imp_iff`, this uses `[is_refl Î± r]`."
  theorem: "{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} [is_refl Î± r] {x y : Î±} : x â‰  y â†’ r x y â†” r x y"

- doc_string: "As a binary function, `fin.cons` is injective."
  theorem: "{n : â„•} {Î± : fin (n + 1) â†’ Type u} : function.injective2 fin.cons"

- doc_string: "**Alias** of the reverse direction of div_eq_one`."
  theorem: "{G : Type u_2} [group G] {a b : G} : a = b â†’ a / b = 1"

- doc_string: "**Alias** of lt_of_le_of_lt`."
  theorem: "{Î± : Type u} [preorder Î±] {a b c : Î±} : a â‰¤ b â†’ b < c â†’ a < c"

- doc_string: "**Alias** of the forward direction of sub_lt_iff_lt_add'`."
  theorem: "{Î± : Type u} [add_comm_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b c : Î±} : a - b < c â†’ a < b + c"

- doc_string: "Deprecated. Use `fun_like.coe_injective` instead."
  theorem: "{Î¹ : Type u} {Î² : Î¹ â†’ Type v} [Î  (i : Î¹), has_zero (Î² i)] : function.injective coe_fn"

- doc_string: " If zero is an element of a list `L`, then `list.prod L = 0`. If the domain is a nontrivial monoid with zero with no divisors, then this implication becomes an `iff`, see `list.prod_eq_zero_iff`."
  theorem: "{Mâ‚€ : Type u_6} [monoid_with_zero Mâ‚€] {L : list Mâ‚€} (h : 0 âˆˆ L) : L.prod = 0"

- doc_string: "Congruence relations are symmetric."
  theorem: "{M : Type u_1} [has_mul M] (c : con M) {x y : M} : â‡‘c x y â†’ â‡‘c y x"

- doc_string: " Given two maps `f : Î± â†’ Î²` and `g : Î² â†’ Î±`, `g` is a bijective map between the fixed points of `f âˆ˜ g` and the fixed points of `g âˆ˜ f`. The inverse map is `f`, see `inv_on_fixed_pts_comp`."
  theorem: "{Î± : Type u} {Î² : Type v} (f : Î± â†’ Î²) (g : Î² â†’ Î±) : set.bij_on g (function.fixed_points (f âˆ˜ g)) (function.fixed_points (g âˆ˜ f))"

- doc_string: "**Alias** of star_ring_end_self_apply`."
  theorem: "{R : Type u} [comm_semiring R] [star_ring R] (x : R) : â‡‘(star_ring_end R) (â‡‘(star_ring_end R) x) = x"

- doc_string: "If `S` is a subset of `R`, and `S` is covering, then `R` is covering as well.  See <https://stacks.math.columbia.edu/tag/00Z5> (2), or discussion after [MM92] Chapter III, Section 2, Definition 1."
  theorem: "{C : Type u} [category_theory.category C] {X : C} {S R : category_theory.sieve X} (J : category_theory.grothendieck_topology C) (Hss : S â‰¤ R) (sjx : S âˆˆ â‡‘J X) : R âˆˆ â‡‘J X"

- doc_string: "The canonical injection from the type to the free group is an injection."
  theorem: "{Î± : Type u} : function.injective free_group.of"

- doc_string: " If `Î±` has no zero divisors, then for elements `a, b : Î±`, `a * b` equals zero iff so is `b * a`."
  theorem: "{Mâ‚€ : Type u_1} [mul_zero_class Mâ‚€] [no_zero_divisors Mâ‚€] {a b : Mâ‚€} : a * b = 0 â†” b * a = 0"

- doc_string: "In a monoid, an element a divides an element b iff all associates of `a` divide `b`."
  theorem: "{Î± : Type u_1} [monoid Î±] {a b u : Î±} (hu : is_unit u) : a * u âˆ£ b â†” a âˆ£ b"

- doc_string: "Any power of an `M`-regular element is `M`-regular."
  theorem: "{R : Type u_1} {M : Type u_3} {a : R} [monoid R] [mul_action R M] (n : â„•) (ra : is_smul_regular M a) : is_smul_regular M (a ^ n)"

- doc_string: "The exponential characteristic is one iff the characteristic is zero."
  theorem: "(R : Type u) [semiring R] [nontrivial R] (p q : â„•) [char_p R p] [exp_char R q] : q = 1 â†” p = 0"

- doc_string: "Every chain is contained in a maximal chain. This generalizes Hausdorff's maximality principle."
  theorem: "{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} {c : set Î±} (hc : is_chain r c) : âˆƒ (M : set Î±), is_max_chain r M âˆ§ c âŠ† M"

- doc_string: "The frontier of a closed set has no interior point."
  theorem: "{Î± : Type u} [topological_space Î±] {s : set Î±} (h : is_closed s) : interior (frontier s) = âˆ…"

- doc_string: "A preadditive category with finite products has finite biproducts."
  theorem: "{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_finite_products C] : category_theory.limits.has_finite_biproducts C"

- doc_string: "The minimal distance to a set is uniformly continuous in point"
  theorem: "{Î± : Type u} [pseudo_metric_space Î±] (s : set Î±) : uniform_continuous (Î» (x : Î±), metric.inf_dist x s)"

- doc_string: "The main characterization theorem for multiplicative principal ordinals."
  theorem: "{o : ordinal} : ordinal.principal has_mul.mul o â†” o â‰¤ 2 âˆ¨ âˆƒ (a : ordinal), o = ordinal.omega ^ ordinal.omega ^ a"

- doc_string: "Uniformisers exist in a DVR"
  theorem: "(R : Type u) [comm_ring R] [is_domain R] [discrete_valuation_ring R] : âˆƒ (Ï– : R), irreducible Ï–"

- doc_string: " Assumes right covariance. The lemma assuming left covariance is `left.one_le_mul`."
  theorem: "{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_mul.mul) has_le.le] {a b : Î±} (ha : 1 â‰¤ a) (hb : 1 â‰¤ b) : 1 â‰¤ a * b"

- doc_string: "Assumes left covariance."
  theorem: "{Î± : Type u} {a b : Î±} [mul_zero_one_class Î±] [partial_order Î±] [zero_lt.pos_mul_mono Î±] (ha : a â‰¤ 1) (hb : b â‰¤ 1) (a0 : 0 â‰¤ a) : a * b â‰¤ 1"

- doc_string: "The evaluation map is continuous, as a joint function of `u` and `x`"
  theorem: "{Î± : Type u} {Î² : Type v} [topological_space Î±] [pseudo_metric_space Î²] : continuous (Î» (p : bounded_continuous_function Î± Î² Ã— Î±), â‡‘(p.fst) p.snd)"

- doc_string: "Mapping under `id` does not change a vector."
  theorem: "{Î± : Type u_1} {n : â„•} (v : vector Î± n) : vector.map id v = v"

- doc_string: "The product of a list of elements of a submonoid is an element of the submonoid."
  theorem: "{M : Type u_1} [monoid M] {s : set M} (hs : is_submonoid s) {l : list M} : (âˆ€ (x : M), x âˆˆ l â†’ x âˆˆ s) â†’ l.prod âˆˆ s"

- doc_string: " The `n+1`-th iterated derivative can be obtained by differentiating the `n`-th iterated derivative."
  theorem: "{ð•œ : Type u_1} [nondiscrete_normed_field ð•œ] {F : Type u_2} [normed_group F] [normed_space ð•œ F] {n : â„•} {f : ð•œ â†’ F} : iterated_deriv (n + 1) f = deriv (iterated_deriv n f)"

- doc_string: "A group homomorphism sends 1 to 1."
  theorem: "{Î± : Type u} {Î² : Type v} [group Î±] [group Î²] {f : Î± â†’ Î²} (hf : is_group_hom f) : f 1 = 1"

- doc_string: "**Alias** of the forward direction of left.inv_le_one_iff`."
  theorem: "{Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± has_add.add has_le.le] {a : Î±} : -a â‰¤ 0 â†’ 0 â‰¤ a"

- doc_string: "Can't be an instance because it would cause a loop `ufm â†’ wf_dvd_monoid â†’ ufm â†’ ...`."
  theorem: "{Î± : Type u_1} [cancel_comm_monoid_with_zero Î±] [wf_dvd_monoid Î±] [gcd_monoid Î±] : unique_factorization_monoid Î±"

- doc_string: 'A category is essentially small if and only if the underlying type of its skeleton (i.e. the "set" of isomorphism classes) is small, and it is locally small.'
  theorem: "(C : Type u) [category_theory.category C] : category_theory.essentially_small C â†” small (category_theory.skeleton C) âˆ§ category_theory.locally_small C"

- doc_string: "**Alias** of the reverse direction of lt_inv_mul_iff_mul_lt`."
  theorem: "{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b c : Î±} : a + b < c â†’ b < -a + c"

- doc_string: " The order of the `â†”` has been chosen so that `rw btw_cyclic` cycles to the right while `rw â†btw_cyclic` cycles to the left (thus following the prepended arrow)."
  theorem: "{Î± : Type u_1} [circular_preorder Î±] {a b c : Î±} : has_btw.btw a b c â†” has_btw.btw c a b"

- doc_string: "If `0 < n`, then `r 1` has order `n`."
  theorem: "{n : â„•} : order_of (dihedral_group.r 1) = n"

- doc_string: "Pullback a `nontrivial` instance along a surjective function."
  theorem: "{Î± : Type u_1} {Î² : Type u_2} [nontrivial Î²] {f : Î± â†’ Î²} (hf : function.surjective f) : nontrivial Î±"

- doc_string: "**Alias** of the reverse direction of dense_closure`."
  theorem: "{Î± : Type u} [topological_space Î±] {s : set Î±} : dense s â†’ dense (closure s)"

- doc_string: "**Number of Subsets of a Set**"
  theorem: "{Î± : Type u_1} (s : finset Î±) : s.powerset.card = 2 ^ s.card"

- doc_string: "Units of a monoid divide any element of the monoid."
  theorem: "{Î± : Type u_1} [monoid Î±] {a u : Î±} (hu : is_unit u) : u âˆ£ a"

- doc_string: "If a vector is in the same ray as its negation, that vector is zero."
  theorem: "{R : Type u_1} [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {x : M} [no_zero_smul_divisors R M] (h : same_ray R x (-x)) : x = 0"

- doc_string: "A function `f` on `fin (n + 1)` is antitone if and only if `f (i + 1) â‰¤ f i` for all `i`."
  theorem: "{n : â„•} {Î± : Type u_1} [preorder Î±] {f : fin (n + 1) â†’ Î±} : antitone f â†” âˆ€ (i : fin n), f i.succ â‰¤ f (â‡‘fin.cast_succ i)"

- doc_string: "`0` is always a square (in a monoid with zero)."
  theorem: "(M : Type u_1) [monoid_with_zero M] : is_square 0"

- doc_string: "An element `a` is regular if and only if a positive power of `a` is regular."
  theorem: "{R : Type u_1} {a : R} [monoid R] {n : â„•} (n0 : 0 < n) : is_regular (a ^ n) â†” is_regular a"

- doc_string: "If the unique morphism from `A` to the terminal object is a monomorphism, `A` is subterminal. The converse of `is_subterminal.mono_terminal_from`."
  theorem: "{C : Type uâ‚} [category_theory.category C] {A : C} [category_theory.limits.has_terminal C] [category_theory.mono (category_theory.limits.terminal.from A)] : category_theory.is_subterminal A"

- doc_string: " In a finite-dimensional vector space, the zero map has determinant `1` in dimension `0`, and `0` otherwise. We give a formula that also works in infinite dimension, where we define the determinant to be `1`."
  theorem: "{ð•œ : Type u_1} [field ð•œ] {M : Type u_2} [add_comm_group M] [module ð•œ M] : â‡‘linear_map.det 0 = 0 ^ finite_dimensional.finrank ð•œ M"

- doc_string: "The normal closure of a set is a subgroup."
  theorem: "{G : Type u_1} [group G] (s : set G) : is_subgroup (group.normal_closure s)"

- doc_string: " For any `a > 1` and a natural `n` we have `n â‰¤ a ^ n / (a - 1)`. See also `nat.cast_le_pow_sub_div_sub` for a stronger inequality with `a ^ n - 1` in the numerator."
  theorem: "{K : Type u_1} [linear_ordered_field K] {a : K} (H : 1 < a) (n : â„•) : â†‘n â‰¤ a ^ n / (a - 1)"

- doc_string: "The cosine of `Ï€ / 3` is `1 / 2`."
  theorem: " : real.cos (real.pi / 3) = 1 / 2"

- doc_string: "**Alias** of nat.sq_sub_sq`."
  theorem: "(a b : â„•) : a ^ 2 - b ^ 2 = (a + b) * (a - b)"

- doc_string: "If a category has all binary products and all equalizers, then it also has all pullbacks.    As usual, this is not an instance, since there may be a more direct way to construct    pullbacks."
  theorem: "(C : Type u) [ð’ž : category_theory.category C] [category_theory.limits.has_binary_products C] [category_theory.limits.has_equalizers C] : category_theory.limits.has_pullbacks C"

- doc_string: "A locally compact Hausdorff totally disconnected space has a basis with clopen elements."
  theorem: "{H : Type u_1} [topological_space H] [locally_compact_space H] [t2_space H] [totally_disconnected_space H] : topological_space.is_topological_basis {s : set H | is_clopen s}"

- doc_string: "The pointwise distance is controlled by the distance between functions, by definition."
  theorem: "{Î± : Type u} {Î² : Type v} [topological_space Î±] [pseudo_metric_space Î²] {f g : bounded_continuous_function Î± Î²} (x : Î±) : has_dist.dist (â‡‘f x) (â‡‘g x) â‰¤ has_dist.dist f g"

- doc_string: "`has_limits_of_size_shrink.{v u} C` tries to obtain `has_limits_of_size.{v u} C` from some other `has_limits_of_size C`."
  theorem: "(C : Type u) [category_theory.category C] [category_theory.limits.has_limits_of_size C] : category_theory.limits.has_limits_of_size C"

- doc_string: "See `lt_tsub_iff_right_of_le` for a weaker statement in a partial order."
  theorem: "{Î± : Type u_1} {a b c : Î±} [linear_order Î±] [add_comm_semigroup Î±] [has_sub Î±] [has_ordered_sub Î±] : a < b - c â†” a + c < b"

- doc_string: "Congruence relations are reflexive."
  theorem: "{M : Type u_1} [has_mul M] (c : con M) (x : M) : â‡‘c x x"

- doc_string: " We can infer `finite_dimensional K V` in the presence of `[fact (finrank K V = n + 1)]`. Declare this as a local instance where needed."
  theorem: "{K : Type u_1} {V : Type u_2} [field K] [add_comm_group V] [module K V] (n : â„•) [fact (finite_dimensional.finrank K V = n + 1)] : finite_dimensional K V"

- doc_string: "**Alias** of le_of_lt`."
  theorem: "{Î± : Type u} [preorder Î±] {a b : Î±} : a < b â†’ a â‰¤ b"

- doc_string: "Elements of an add cancel monoid are regular.  Add cancel semigroups do not appear to exist."
  theorem: "{R : Type u_1} [add_cancel_monoid R] (g : R) : is_add_regular g"

- doc_string: "See also `smul_right_injective`. TODO: provide a `no_zero_smul_divisors` instance. We can't do that here because importing that definition would create import cycles."
  theorem: "{Î± : Type u_1} [linear_ordered_add_comm_group Î±] {n : â„¤} (hn : n â‰  0) : function.injective (Î» (_x : Î±), n â€¢ _x)"

- doc_string: "Assumes right covariance. The lemma assuming left covariance is `left.add_neg_of_nonpos_of_neg`."
  theorem: "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±} (ha : a â‰¤ 0) (hb : b < 0) : a + b < 0"

- doc_string: "**Alias** of the forward direction of left.one_lt_inv_iff`."
  theorem: "{Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a : Î±} : 1 < aâ»Â¹ â†’ a < 1"

- doc_string: "**Alias** of the forward direction of directed_on_iff_directed`."
  theorem: "{Î± : Type u} {r : Î± â†’ Î± â†’ Prop} {s : set Î±} : directed_on r s â†’ directed r coe"

- doc_string: "The element `0` is right-regular if and only if `R` is trivial."
  theorem: "{R : Type u_1} [mul_zero_class R] : is_right_regular 0 â†” subsingleton R"

- doc_string: "Assumes left covariance. The lemma assuming right covariance is `right.add_neg'`."
  theorem: "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : a < 0) (hb : b < 0) : a + b < 0"

- doc_string: "A simplification of one side of an equation exploiting right distributivity in rings  and the definition of subtraction."
  theorem: "{Î± : Type u} [non_unital_non_assoc_ring Î±] {a b c d e : Î±} : a * e + c = b * e + d â†’ (a - b) * e + c = d"

- doc_string: "The empty set is collinear."
  theorem: "(k : Type u_1) {V : Type u_2} (P : Type u_3) [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] : collinear k âˆ…"

- doc_string: " Assumes right covariance. The lemma assuming left covariance is `left.one_lt_mul`."
  theorem: "{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_mul.mul) has_lt.lt] {a b : Î±} (ha : 1 < a) (hb : 1 < b) : 1 < a * b"

- doc_string: "Assumes left covariance. The lemma assuming right covariance is `right.add_neg_of_neg_of_nonpos`."
  theorem: "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : a < 0) (hb : b â‰¤ 0) : a + b < 0"

- doc_string: "If the diagonal morphism of `A` is an isomorphism, then it is subterminal. The converse of `is_subterminal.is_iso_diag`."
  theorem: "{C : Type uâ‚} [category_theory.category C] {A : C} [category_theory.limits.has_binary_product A A] [category_theory.is_iso (category_theory.limits.diag A)] : category_theory.is_subterminal A"

- doc_string: "If `A` is subterminal, its diagonal morphism is an isomorphism. The converse of `is_subterminal_of_is_iso_diag`."
  theorem: "{C : Type uâ‚} [category_theory.category C] {A : C} (hA : category_theory.is_subterminal A) [category_theory.limits.has_binary_product A A] : category_theory.is_iso (category_theory.limits.diag A)"

- doc_string: "For a perfect ring, it itself is the perfection."
  theorem: "(p : â„•) [fact (nat.prime p)] (R : Type uâ‚) [comm_semiring R] [char_p R p] [perfect_ring R p] : perfection_map p (ring_hom.id R)"

- doc_string: "If `R` has characteristic `0`, then so does Frac(R)."
  theorem: "(R : Type u_1) {K : Type u_2} [comm_ring R] [field K] [algebra R K] [is_fraction_ring R K] [char_zero R] : char_zero K"

- doc_string: "**Alias** of left.one_lt_inv_iff`."
  theorem: "{Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a : Î±} : 1 < aâ»Â¹ â†” a < 1"

- doc_string: "For the single implications with fewer assumptions, see `one_div_lt_one_div_of_lt` and  `lt_of_one_div_lt_one_div`"
  theorem: "{Î± : Type u_1} [linear_ordered_field Î±] {a b : Î±} (ha : a < 0) (hb : b < 0) : 1 / a < 1 / b â†” b < a"

- doc_string: "A convex independent family is injective."
  theorem: "{ð•œ : Type u_1} {E : Type u_2} {Î¹ : Type u_3} [ordered_semiring ð•œ] [add_comm_group E] [module ð•œ E] {p : Î¹ â†’ E} (hc : convex_independent ð•œ p) : function.injective p"

- doc_string: "Assumes left covariance."
  theorem: "{Î± : Type u} {a b : Î±} [mul_one_class Î±] [has_zero Î±] [preorder Î±] [zero_lt.pos_mul_strict_mono Î±] (ha : a â‰¤ 1) (hb : b < 1) (a0 : 0 < a) : a * b < 1"

- doc_string: "**Alias** of the reverse direction of is_max_to_dual_iff`."
  theorem: "{Î± : Type u_1} [has_le Î±] {a : Î±} : is_min a â†’ is_max (â‡‘order_dual.to_dual a)"

- doc_string: " If self-maps `f` and `g` commute, then `g` is bijective on the set of fixed points of `f âˆ˜ g`. This is a particular case of `function.bij_on_fixed_pts_comp`."
  theorem: "{Î± : Type u} {f g : Î± â†’ Î±} (h : function.commute f g) : set.bij_on g (function.fixed_points (f âˆ˜ g)) (function.fixed_points (f âˆ˜ g))"

- doc_string: "Deprecated: use `fun_like.congr_arg` instead."
  theorem: "{M : Type u_3} {N : Type u_4} [has_add M] [has_add N] (f : add_hom M N) {x y : M} (h : x = y) : â‡‘f x = â‡‘f y"

- doc_string: "`legendre_sym p (-1)` is given by `Ï‡â‚„ p`."
  theorem: "(p : â„•) [fact (nat.prime p)] (hp : p â‰  2) : zmod.legendre_sym p (-1) = â‡‘zmod.Ï‡â‚„ â†‘p"

- doc_string: "An element of a ring multiplied by the additive inverse of one is the element's additive  inverse."
  theorem: "{Î± : Type u} [mul_one_class Î±] [has_distrib_neg Î±] (a : Î±) : a * -1 = -a"

- doc_string: "**Alias** of zero_lt_three`."
  theorem: "{Î± : Type u} [ordered_semiring Î±] [nontrivial Î±] : 0 < 3"

- doc_string: "`{a}.max' _` is `a`."
  theorem: "{Î± : Type u_1} [linear_order Î±] (a : Î±) : {a}.max' _ = a"

- doc_string: " The evaluation map `C(Î±, Î²) Ã— Î± â†’ Î²` is continuous if `Î±` is locally compact.  See also `continuous_map.continuous_eval`"
  theorem: "{Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] [locally_compact_space Î±] : continuous (Î» (p : C(Î±, Î²) Ã— Î±), â‡‘(p.fst) p.snd)"

- doc_string: "An element is add-left-regular if and only if adding to it on the left a add-left-regular element is add-left-regular."
  theorem: "{R : Type u_1} {a : R} [add_semigroup R] (b : R) (ha : is_add_left_regular a) : is_add_left_regular (a + b) â†” is_add_left_regular b"

- doc_string: "Conjugation by a fixed element is continuous when `mul` is continuous."
  theorem: "{G : Type w} [topological_space G] [has_inv G] [has_mul G] [has_continuous_mul G] (g : G) : continuous (Î» (h : G), g * h * gâ»Â¹)"

- doc_string: "**Alias** of neg_sq`."
  theorem: "{R : Type uâ‚} [monoid R] [has_distrib_neg R] (a : R) : (-a) ^ 2 = a ^ 2"

- doc_string: "The uncurrying process is a continuous map between function spaces."
  theorem: "{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [topological_space Î±] [topological_space Î²] [topological_space Î³] [locally_compact_space Î±] [locally_compact_space Î²] : continuous continuous_map.uncurry"

- doc_string: "**Alias** of the reverse direction of antitone_on_to_dual_comp_iff`."
  theorem: "{Î± : Type u} {Î² : Type v} [preorder Î±] [preorder Î²] {f : Î± â†’ Î²} {s : set Î±} : monotone_on f s â†’ antitone_on (â‡‘order_dual.to_dual âˆ˜ f) s"

- doc_string: "The vector space of functions on `fin n` has finrank equal to `n`."
  theorem: "(K : Type u) [division_ring K] {n : â„•} : finite_dimensional.finrank K (fin n â†’ K) = n"

- doc_string: "The set of natural number multiples of an element of an `add_monoid` is closed under addition."
  theorem: "{M : Type u_1} [add_monoid M] {x y z : M} : y âˆˆ multiples x â†’ z âˆˆ multiples x â†’ y + z âˆˆ multiples x"

- doc_string: "Uses `left` co(ntra)variant."
  theorem: "{Î± : Type u} [group Î±] [has_le Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a : Î±} : 1 â‰¤ aâ»Â¹ â†” a â‰¤ 1"

- doc_string: " The Hausdorff distance to the empty set vanishes (if you want to have the more reasonable value âˆž instead, use `Hausdorff_edist`, which takes values in â„â‰¥0âˆž)"
  theorem: "{Î± : Type u} [pseudo_metric_space Î±] {s : set Î±} : metric.Hausdorff_dist âˆ… s = 0"

- doc_string: " The eigenspaces of a linear operator form an independent family of subspaces of `V`.  That is, any eigenspace has trivial intersection with the span of all the other eigenspaces."
  theorem: "{K : Type v} {V : Type w} [field K] [add_comm_group V] [module K V] (f : module.End K V) : complete_lattice.independent f.eigenspace"

- doc_string: "Assumes left covariance."
  theorem: "{Î± : Type u} {a b : Î±} [mul_one_class Î±] [has_zero Î±] [preorder Î±] [zero_lt.pos_mul_strict_mono Î±] (ha : 1 < a) (hb : 1 < b) (a0 : 0 < a) : 1 < a * b"

- doc_string: " `cons` and `snoc` commute. We state this lemma in a non-dependent setting, as otherwise it would involve a cast to convince Lean that the two types are equal, making it harder to use."
  theorem: "{n : â„•} {Î² : Type u_1} (a : Î²) (q : fin n â†’ Î²) (b : Î²) : fin.cons a (fin.snoc q b) = fin.snoc (fin.cons a q) b"

- doc_string: " `squarefree` is multiplicative. Note that the â†’ direction does not require `hmn` and generalizes to arbitrary commutative monoids. See `squarefree.of_mul_left` and `squarefree.of_mul_right` above for auxiliary lemmas."
  theorem: "{m n : â„•} (hmn : m.coprime n) : squarefree (m * n) â†” squarefree m âˆ§ squarefree n"

- doc_string: "If a category has all coproducts then in particular it has finite coproducts."
  theorem: "(C : Type u) [category_theory.category C] [category_theory.limits.has_coproducts C] : category_theory.limits.has_finite_coproducts C"

- doc_string: "If `s.nth n = some aâ‚™` for some value `aâ‚™`, then there is also some value `aâ‚˜` such that `s.nth = some aâ‚˜` for `m â‰¤ n`."
  theorem: "{Î± : Type u} (s : seq Î±) {aâ‚™ : Î±} {n m : â„•} (m_le_n : m â‰¤ n) (s_nth_eq_some : s.nth n = option.some aâ‚™) : âˆƒ (aâ‚˜ : Î±), s.nth m = option.some aâ‚˜"

- doc_string: "There are no perfect squares strictly between mÂ² and (m+1)Â²"
  theorem: "{n m : â„•} (hl : m * m < n) (hr : n < (m + 1) * (m + 1)) : Â¬âˆƒ (t : â„•), t * t = n"

- doc_string: "If `univ` is complete, the space is a complete space"
  theorem: "{Î± : Type u} [uniform_space Î±] (h : is_complete set.univ) : complete_space Î±"

- doc_string: "**Alias** of the reverse direction of multiset.Ico_eq_zero_iff`."
  theorem: "{Î± : Type u_1} [preorder Î±] [locally_finite_order Î±] {a b : Î±} : Â¬a < b â†’ multiset.Ico a b = 0"

- doc_string: "A finite dimensional space has positive `finrank` iff it has a nonzero element."
  theorem: "{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] : 0 < finite_dimensional.finrank K V â†” âˆƒ (x : V), x â‰  0"

- doc_string: "The multiplicity of `p : â„•` in `a : â„¤` is finite exactly when `a â‰  0`."
  theorem: "{p : â„•} [p_prime : fact (nat.prime p)] {a : â„¤} : multiplicity.finite â†‘p a â†” a â‰  0"

- doc_string: "The square of the quadratic character on nonzero arguments is `1`."
  theorem: "{F : Type u_1} [field F] [fintype F] [decidable_eq F] {a : F} (ha : a â‰  0) : char.quadratic_char F a ^ 2 = 1"

- doc_string: "Shows that the fractional parts of the stream are in `[0,1)`."
  theorem: "{K : Type u_1} {v : K} {n : â„•} [linear_ordered_field K] [floor_ring K] {ifp_n : generalized_continued_fraction.int_fract_pair K} (nth_stream_eq : generalized_continued_fraction.int_fract_pair.stream v n = option.some ifp_n) : 0 â‰¤ ifp_n.fr âˆ§ ifp_n.fr < 1"

- doc_string: "When lowered to a prop, `matrix.invertible_equiv_det_invertible` forms an `iff`."
  theorem: "{n : Type u'} {Î± : Type v} [fintype n] [decidable_eq n] [comm_ring Î±] (A : matrix n n Î±) : is_unit A â†” is_unit A.det"

- doc_string: " **Cantor's diagonal argument** implies that there are no injective functions from `set Î±` to `Î±`."
  theorem: "{Î± : Type u_1} (f : set Î± â†’ Î±) : Â¬function.injective f"

- doc_string: "**Alias** of the reverse direction of order.lt_succ_iff_not_is_max`."
  theorem: "{Î± : Type u_1} [preorder Î±] [succ_order Î±] {a : Î±} : Â¬is_max a â†’ a < order.succ a"

- doc_string: "**Alias** of the reverse direction of continuous_iff_seq_continuous`."
  theorem: "{X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] {f : X â†’ Y} [sequential_space X] : seq_continuous f â†’ continuous f"

- doc_string: "This is the same as `add_order_of_pos' but with one fewer explicit assumption since this is   automatic in case of a finite cancellative additive monoid."
  theorem: "{G : Type u} [fintype G] [add_left_cancel_monoid G] (x : G) : 0 < add_order_of x"

- doc_string: "Assumes right covariance. The lemma assuming left covariance is `left.add_nonpos`."
  theorem: "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±} (ha : a â‰¤ 0) (hb : b â‰¤ 0) : a + b â‰¤ 0"

- doc_string: "`padic_val_rat p 0` is 0 for any `p`."
  theorem: "(m : â„•) : padic_val_rat m 0 = 0"

- doc_string: "The coercion to the quotient of an additive congruence relation commutes with addition (by definition)."
  theorem: "{M : Type u_1} [has_add M] {c : add_con M} (x y : M) : â†‘(x + y) = â†‘x + â†‘y"

- doc_string: "An alternative version of `subtype.exists`. This one is useful if Lean cannot figure out `q`  when using `subtype.exists` from right to left."
  theorem: "{Î± : Sort u_1} {p : Î± â†’ Prop} {q : Î  (x : Î±), p x â†’ Prop} : (âˆƒ (x : Î±) (h : p x), q x h) â†” âˆƒ (x : {a // p a}), q â†‘x _"

- doc_string: "A variation on Fermat's little theorem. See `zmod.pow_card_sub_one_eq_one`"
  theorem: "{p : â„•} [fact (nat.prime p)] (x : zmod p) : x ^ p = x"

- doc_string: "Additive congruence relations are reflexive."
  theorem: "{M : Type u_1} [has_add M] (c : add_con M) (x : M) : â‡‘c x x"

- doc_string: "See `lt_of_tsub_lt_tsub_right` for a stronger statement in a linear order."
  theorem: "{Î± : Type u_1} [canonically_ordered_add_monoid Î±] [has_sub Î±] [has_ordered_sub Î±] {a b c : Î±} (h : c â‰¤ b) (h2 : a - c < b - c) : a < b"

- doc_string: " Theorem of bark and tree : if a set is within a (pre)connected set and its closure, then it is (pre)connected as well."
  theorem: "{Î± : Type u} [topological_space Î±] {s t : set Î±} (H : is_preconnected s) (Kst : s âŠ† t) (Ktcs : t âŠ† closure s) : is_preconnected t"

- doc_string: "An additive group homomorphism is an additive monoid homomorphism."
  theorem: "{Î± : Type u} {Î² : Type v} [add_group Î±] [add_group Î²] {f : Î± â†’ Î²} (hf : is_add_group_hom f) : is_add_monoid_hom f"

- doc_string: "Given a wide pullback in `C`, construct a product in `C/B`."
  theorem: "{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_limits_of_shape (category_theory.limits.wide_pullback_shape J) C] {B : C} : category_theory.limits.has_limits_of_shape (category_theory.discrete J) (category_theory.over B)"

- doc_string: "**Alias** of the reverse direction of measurable_iff_le_map`."
  theorem: "{Î± : Type u_1} {Î² : Type u_2} {mâ‚ : measurable_space Î±} {mâ‚‚ : measurable_space Î²} {f : Î± â†’ Î²} : mâ‚‚ â‰¤ measurable_space.map f mâ‚ â†’ measurable f"

- doc_string: "**Alias** of the forward direction of sub_nonpos`."
  theorem: "{Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±} : a - b â‰¤ 0 â†’ a â‰¤ b"

- doc_string: "`padic_val_rat p 1` is 0 for any `p`."
  theorem: "{p : â„•} : padic_val_rat p 1 = 0"

- doc_string: "A binary injective function is injective when only the right argument varies."
  theorem: "{Î± : Sort u_1} {Î² : Sort u_2} {Î³ : Sort u_3} {f : Î± â†’ Î² â†’ Î³} (hf : function.injective2 f) (a : Î±) : function.injective (f a)"

- doc_string: "A group homomorphism is a monoid homomorphism."
  theorem: "{Î± : Type u} {Î² : Type v} [group Î±] [group Î²] {f : Î± â†’ Î²} (hf : is_group_hom f) : is_monoid_hom f"

- doc_string: "Hilbert basis theorem: a polynomial ring over a noetherian ring is a noetherian ring."
  theorem: "{R : Type u} [comm_ring R] [is_noetherian_ring R] : is_noetherian_ring (polynomial R)"

- doc_string: "Left-regular multiplication on `R` is equivalent to `R`-regularity of `R` itself."
  theorem: "{R : Type u_1} [has_mul R] {a : R} : is_left_regular a â†” is_smul_regular R a"

- doc_string: " Showing one side of the equivalence between the definitions `is_dedekind_domain_inv` and `is_dedekind_domain` of Dedekind domains."
  theorem: "{A : Type u_2} [comm_ring A] [is_domain A] (h : is_dedekind_domain_inv A) : is_dedekind_domain A"

- doc_string: "**Alias** of zero_lt_four`."
  theorem: "{Î± : Type u} [ordered_semiring Î±] [nontrivial Î±] : 0 < 4"

- doc_string: "`choose n 2` is the `n`-th triangle number."
  theorem: "(n : â„•) : n.choose 2 = n * (n - 1) / 2"

- doc_string: "**Alias** of lt_of_eq_of_lt'`."
  theorem: "{Î± : Type u} [preorder Î±] {a b c : Î±} : b = c â†’ a < b â†’ a < c"

- doc_string: "Concatenating the first element of a tuple with its tail gives back the original tuple"
  theorem: "{n : â„•} {Î± : fin (n + 1) â†’ Type u} (q : Î  (i : fin (n + 1)), Î± i) : fin.snoc (fin.init q) (q (fin.last n)) = q"

- doc_string: " The type of ordinals in universe `u` is not `small.{u}`. This is the type-theoretic analog of the Burali-Forti paradox."
  theorem: " : Â¬small ordinal"

- doc_string: "An element is add-right-regular if and only if adding it on the right to a add-right-regular element is add-right-regular."
  theorem: "{R : Type u_1} {a : R} [add_semigroup R] (b : R) (ha : is_add_right_regular a) : is_add_right_regular (b + a) â†” is_add_right_regular b"

- doc_string: " Series divergence test: if `f` is a convergent series, then `f x` tends to zero along `cofinite`."
  theorem: "{Î± : Type u_1} {G : Type u_5} [topological_space G] [add_comm_group G] [topological_add_group G] {f : Î± â†’ G} (hf : summable f) : filter.tendsto f filter.cofinite (nhds 0)"

- doc_string: "An additive group homomorphism is injective if its kernel is trivial."
  theorem: "{Î± : Type u} {Î² : Type v} [add_group Î±] [add_group Î²] {f : Î± â†’ Î²} (hf : is_add_group_hom f) : function.injective f â†” âˆ€ (a : Î±), f a = 0 â†’ a = 0"

- doc_string: "`m` is not divisible by `n` iff it is between `n * k` and `n * (k + 1)` for some `k`."
  theorem: "(m : â„•) {n : â„•} (hn : 0 < n) : (âˆƒ (k : â„•), n * k < m âˆ§ m < n * (k + 1)) â†” Â¬n âˆ£ m"

- doc_string: "`X ^ n - a` is monic."
  theorem: "{R : Type u} [ring R] (a : R) {n : â„•} (h : n â‰  0) : (polynomial.X ^ n - â‡‘polynomial.C a).monic"

- doc_string: "Binet's formula as a function equality."
  theorem: " : (Î» (n : â„•), â†‘(nat.fib n)) = Î» (n : â„•), (golden_ratio ^ n - golden_conj ^ n) / real.sqrt 5"

- doc_string: "An inducing map with an open range is an open map."
  theorem: "{Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] {f : Î± â†’ Î²} (hi : inducing f) (ho : is_open (set.range f)) : is_open_map f"

- doc_string: "`fib (n + 2)` is strictly monotone."
  theorem: " : strict_mono (Î» (n : â„•), nat.fib (n + 2))"

- doc_string: "`zpow b` and `int.log b` (almost) form a Galois connection."
  theorem: "{R : Type u_1} [linear_ordered_field R] [floor_ring R] {b : â„•} (hb : 1 < b) {x : â„¤} {r : R} (hr : 0 < r) : â†‘b ^ x â‰¤ r â†” x â‰¤ int.log b r"

- doc_string: 'Add an instance to "undo" coercion transitivity into a chain of coercions, because   most simp lemmas are stated with respect to simple coercions and will not match when   part of a chain.'
  theorem: "{Î± : Sort u_1} {Î² : Sort u_2} {Î³ : Sort u_3} [has_coe Î± Î²] [has_coe_t Î² Î³] (a : Î±) : â†‘a = â†‘â†‘a"

- doc_string: " the minimal distance to the empty set is 0 (if you want to have the more reasonable value âˆž instead, use `inf_edist`, which takes values in â„â‰¥0âˆž)"
  theorem: "{Î± : Type u} [pseudo_metric_space Î±] {x : Î±} : metric.inf_dist x âˆ… = 0"

- doc_string: " Every x greater than or equal to 1 is between two successive natural-number powers of every y greater than one."
  theorem: "{Î± : Type u_1} [linear_ordered_ring Î±] [archimedean Î±] {x y : Î±} (hx : 1 â‰¤ x) (hy : 1 < y) : âˆƒ (n : â„•), y ^ n â‰¤ x âˆ§ x < y ^ (n + 1)"

- doc_string: "When there is a global minimum, every set is bounded below."
  theorem: "{Î³ : Type w} [preorder Î³] [order_bot Î³] (s : set Î³) : bdd_below s"

- doc_string: "**Alias** of the forward direction of subsingleton_iff_zero_eq_one`."
  theorem: "{Mâ‚€ : Type u_1} [mul_zero_one_class Mâ‚€] : 0 = 1 â†’ subsingleton Mâ‚€"

- doc_string: " If `m` and `n` are natural numbers, then the natural number `m^n` is even if and only if `m` is even and `n` is positive."
  theorem: "{m n : â„•} : even (m ^ n) â†” even m âˆ§ n â‰  0"

- doc_string: "Characteristic `â‰  2` and nontrivial implies that `-1 â‰  1`."
  theorem: "{R : Type u_1} [non_assoc_ring R] [nontrivial R] (hR : ring_char R â‰  2) : -1 â‰  1"

- doc_string: "Uses `left` co(ntra)variant."
  theorem: "{Î± : Type u} [group Î±] [has_le Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a : Î±} : aâ»Â¹ â‰¤ 1 â†” 1 â‰¤ a"

- doc_string: "Assumes right covariance."
  theorem: "{Î± : Type u} {a b : Î±} [mul_zero_class Î±] [preorder Î±] [zero_lt.mul_pos_strict_mono Î±] (ha : 0 < a) (hb : 0 < b) : 0 < a * b"

- doc_string: "Assumes left covariance. The lemma assuming right covariance is `right.add_neg_of_nonpos_of_neg`."
  theorem: "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b : Î±} (ha : a â‰¤ 0) (hb : b < 0) : a + b < 0"

- doc_string: "The supremum of a singleton is the element of the singleton"
  theorem: "{Î± : Type u_1} [conditionally_complete_lattice Î±] (a : Î±) : has_Sup.Sup {a} = a"

- doc_string: " If `n` has only one element, the determinant of an `n` by `n` matrix is just that element. Although `unique` implies `decidable_eq` and `fintype`, the instances might not be syntactically equal. Thus, we need to fill in the args explicitly."
  theorem: "{R : Type v} [comm_ring R] {n : Type u_1} [unique n] [decidable_eq n] [fintype n] (A : matrix n n R) : A.det = A inhabited.default inhabited.default"

- doc_string: "Any ascending central series for a group is bounded above by the upper central series."
  theorem: "{G : Type u_1} [group G] (H : â„• â†’ subgroup G) (hH : is_ascending_central_series H) (n : â„•) : H n â‰¤ upper_central_series G n"

- doc_string: "Pseudoequality is transitive: Just take the pullback. The pullback morphisms will    be epimorphisms since in an abelian category, pullbacks of epimorphisms are epimorphisms."
  theorem: "{C : Type u} [category_theory.category C] [category_theory.abelian C] {P : C} : transitive (category_theory.abelian.pseudo_equal P)"

- doc_string: "The substructure generated by a set includes the set."
  theorem: "{L : first_order.language} {M : Type w} [L.Structure M] {s : set M} : s âŠ† â†‘(â‡‘(first_order.language.substructure.closure L) s)"

- doc_string: " `is_dedekind_domain` and `is_dedekind_domain_inv` are equivalent ways to express that an integral domain is a Dedekind domain."
  theorem: "{A : Type u_2} [comm_ring A] [is_domain A] : is_dedekind_domain A â†” is_dedekind_domain_inv A"

- doc_string: "Given binary relations `r, s` with `r` contained in `s`, the smallest congruence relation    containing `s` contains the smallest congruence relation containing `r`."
  theorem: "{M : Type u_1} [has_mul M] {r s : M â†’ M â†’ Prop} (h : âˆ€ (x y : M), r x y â†’ s x y) : con_gen r â‰¤ con_gen s"

- doc_string: "Assumes right covariance."
  theorem: "{Î± : Type u} {a b : Î±} [mul_zero_one_class Î±] [partial_order Î±] [zero_lt.mul_pos_mono Î±] (ha : 1 â‰¤ a) (hb : 1 â‰¤ b) (b0 : 0 â‰¤ b) : 1 â‰¤ a * b"

- doc_string: "This is a special case of `tsub_le_iff_right`, which should be used instead of this.  This is needed to prove `has_ordered_sub (multiset Î±)`."
  theorem: "{Î± : Type u_1} [decidable_eq Î±] {s t u : multiset Î±} : s - t â‰¤ u â†” s â‰¤ u + t"

- doc_string: "See also `continuous_map.continuous_coe`"
  theorem: "{Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] [locally_compact_space Î±] : continuous coe_fn"

- doc_string: "**Alias** of dvd_mul_of_dvd_right`."
  theorem: "{Î± : Type u_1} [comm_semigroup Î±] {a b : Î±} (h : a âˆ£ b) (c : Î±) : a âˆ£ c * b"

- doc_string: "**Alias** of the reverse direction of nat.count_succ_eq_count_iff`."
  theorem: "{p : â„• â†’ Prop} [decidable_pred p] {n : â„•} : Â¬p n â†’ nat.count p (n + 1) = nat.count p n"

- doc_string: "Multiplicative congruence relations preserve division."
  theorem: "{M : Type u_1} [group M] (c : con M) {w x y z : M} : â‡‘c w x â†’ â‡‘c y z â†’ â‡‘c (w / y) (x / z)"

- doc_string: "Negation is an `add_group` homomorphism if the `add_group` is commutative."
  theorem: "{Î± : Type u} [add_comm_group Î±] : is_add_group_hom has_neg.neg"

- doc_string: "An element of an algebra over a field is algebraic if and only if it is integral."
  theorem: "{K : Type u} {A : Type v} [field K] [ring A] [algebra K A] {x : A} : is_algebraic K x â†” is_integral K x"

- doc_string: "**Alias** of dvd_mul_of_dvd_left`."
  theorem: "{Î± : Type u_1} [semigroup Î±] {a b : Î±} (h : a âˆ£ b) (c : Î±) : a âˆ£ b * c"

- doc_string: "`cyclotomic n R` comes from `cyclotomic n â„¤`."
  theorem: "(n : â„•) (R : Type u_1) [ring R] : polynomial.map (int.cast_ring_hom R) (polynomial.cyclotomic n â„¤) = polynomial.cyclotomic n R"

- doc_string: "If `ring_char F = 2`, then `quadratic_char F` takes the value `1` on nonzero elements."
  theorem: "{F : Type u_1} [field F] [fintype F] [decidable_eq F] (hF : ring_char F = 2) {a : F} (ha : a â‰  0) : char.quadratic_char F a = 1"

- doc_string: "The **Cayley-Hamilton Theorem**, that the characteristic polynomial of a matrix, applied to the matrix itself, is zero.  This holds over any commutative ring.  See `linear_map.aeval_self_charpoly` for the equivalent statement about endomorphisms."
  theorem: "{R : Type u} [comm_ring R] {n : Type w} [decidable_eq n] [fintype n] (M : matrix n n R) : â‡‘(polynomial.aeval M) M.charpoly = 0"

- doc_string: "A more convenient spelling of `polynomial.of_finsupp.inj_eq` in terms of `iff`."
  theorem: "{R : Type u} [semiring R] {a b : add_monoid_algebra R â„•} : {to_finsupp := a} = {to_finsupp := b} â†” a = b"

- doc_string: "Every nonzero natural number has a unique prime factorization"
  theorem: " : set.inj_on nat.factorization {x : â„• | x â‰  0}"

- doc_string: " If `l` is already `list.sorted` with respect to `r`, then `insertion_sort` does not change it."
  theorem: "{Î± : Type uu} {r : Î± â†’ Î± â†’ Prop} [decidable_rel r] {l : list Î±} (h : list.sorted r l) : list.insertion_sort r l = l"

- doc_string: "If `1 < x`, then `x^k` divides `x^l` if and only if `k` is at most `l`."
  theorem: "{x k l : â„•} (w : 1 < x) : x ^ k âˆ£ x ^ l â†” k â‰¤ l"

- doc_string: " Note: this lemma is specifically about `fintype.of_is_empty`. For a statement about arbitrary `fintype` instances, use `finset.univ_eq_empty`."
  theorem: "{Î± : Type u_1} [is_empty Î±] : finset.univ = âˆ…"

- doc_string: " The projection from a topological fiber bundle with a nonempty fiber to its base is a surjective map."
  theorem: "{B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z â†’ B} [topological_space Z] [nonempty F] (h : is_topological_fiber_bundle F proj) : function.surjective proj"

- doc_string: "The kernel of the natural homomorphism from an `add_monoid` to its quotient by an additive congruence relation `c` equals `c`."
  theorem: "{M : Type u_1} [add_zero_class M] (c : add_con M) : add_con.ker c.mk' = c"

- doc_string: " The projection from a topological fiber bundle with a nonempty fiber to its base is a quotient map."
  theorem: "{B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z â†’ B} [topological_space Z] [nonempty F] (h : is_topological_fiber_bundle F proj) : quotient_map proj"

- doc_string: "The closure of the open interval `(a, b)` is the closed interval `[a, b]`."
  theorem: "{Î± : Type u} [topological_space Î±] [linear_order Î±] [order_topology Î±] [densely_ordered Î±] {a b : Î±} (hab : a â‰  b) : closure (set.Ioo a b) = set.Icc a b"

- doc_string: "A version of the global `continuous_mul` suitable for dot notation."
  theorem: "{Î± : Type u} [group Î±] (g : group_topology Î±) : continuous (Î» (p : Î± Ã— Î±), p.fst * p.snd)"

- doc_string: "The union of two sets is bounded iff each of the sets is bounded."
  theorem: "{Î± : Type u} [pseudo_metric_space Î±] {s t : set Î±} : metric.bounded (s âˆª t) â†” metric.bounded s âˆ§ metric.bounded t"

- doc_string: 'The "most used" implication of `mul_and_mul_iff`, with split hypotheses, instead of `âˆ§`.'
  theorem: "{R : Type u_1} {a b : R} [semigroup R] (ab : is_regular (a * b)) (ba : is_regular (b * a)) : is_regular a âˆ§ is_regular b"

- doc_string: "Assumes right covariance."
  theorem: "{Î± : Type u} {a b : Î±} [mul_one_class Î±] [has_zero Î±] [preorder Î±] [zero_lt.mul_pos_strict_mono Î±] (ha : 1 < a) (hb : 1 < b) (b0 : 0 < b) : 1 < a * b"

- doc_string: "**Alias** of the reverse direction of order_dual.to_dual_lt_to_dual`."
  theorem: "{Î± : Type u_1} [has_lt Î±] {a b : Î±} : b < a â†’ â‡‘order_dual.to_dual a < â‡‘order_dual.to_dual b"

- doc_string: "**Alias** of the reverse direction of sub_neg`."
  theorem: "{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b : Î±} : a < b â†’ a - b < 0"

- doc_string: "The cardinality of the quaternions, as a type."
  theorem: "(R : Type u_1) [has_one R] [has_neg R] : cardinal.mk (quaternion R) = cardinal.mk R ^ 4"

- doc_string: "Modus tollens. If an implication is true, then so is its contrapositive."
  theorem: "{a b : Prop} (hâ‚ : a â†’ b) (hâ‚‚ : Â¬b) : Â¬a"

- doc_string: "Any element semiconjugates `1` to `1`."
  theorem: "{M : Type u} [mul_one_class M] (a : M) : semiconj_by a 1 1"

- doc_string: "The interpretation in terms of whether `-1` is a square in `F`"
  theorem: "{F : Type u_1} [field F] [fintype F] : is_square (-1) â†” fintype.card F % 4 â‰  3"

- doc_string: "**Alias** of the reverse direction of le_inv_mul_iff_mul_le`."
  theorem: "{Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b c : Î±} : a + b â‰¤ c â†’ b â‰¤ -a + c"

- doc_string: "**Alias** of is_totally_disconnected_of_is_totally_separated`."
  theorem: "{Î± : Type u} [topological_space Î±] {s : set Î±} (H : is_totally_separated s) : is_totally_disconnected s"

- doc_string: "For the single implications with fewer assumptions, see `one_div_lt_one_div_of_neg_of_lt` and  `lt_of_one_div_lt_one_div`"
  theorem: "{Î± : Type u_1} [linear_ordered_field Î±] {a b : Î±} (ha : a < 0) (hb : b < 0) : 1 / a â‰¤ 1 / b â†” b â‰¤ a"

- doc_string: "**Alias** of star_ring_end_self_apply`."
  theorem: "{R : Type u} [comm_semiring R] [star_ring R] (x : R) : â‡‘(star_ring_end R) (â‡‘(star_ring_end R) x) = x"

- doc_string: "`q` is the minimum factor of `mersenne p`, so `M p = 0` in `X q`."
  theorem: "(p : â„•) : â†‘(mersenne p) = 0"

- doc_string: "The identity is an isometry"
  theorem: "{Î± : Type u} [pseudo_emetric_space Î±] : isometry id"

- doc_string: "We will apply the above step recursively.  The following result is used to ensure that the process terminates."
  theorem: "(u : pnat.xgcd_type) (hr : u.r â‰  0) : sizeof u.step < sizeof u"

- doc_string: " The monomial function `x^n` tends to `+âˆž` at `+âˆž` for any positive natural `n`. A version for positive real powers exists as `tendsto_rpow_at_top`."
  theorem: "{Î± : Type u_3} [ordered_semiring Î±] {n : â„•} (hn : 1 â‰¤ n) : filter.tendsto (Î» (x : Î±), x ^ n) filter.at_top filter.at_top"

- doc_string: " If `Î±` has no zero divisors, then the product of two elements equals zero iff one of them equals zero."
  theorem: "{Mâ‚€ : Type u_1} [mul_zero_class Mâ‚€] [no_zero_divisors Mâ‚€] {a b : Mâ‚€} : a * b = 0 â†” a = 0 âˆ¨ b = 0"

- doc_string: "A list with positive sum must have positive length."
  theorem: "{M : Type u_3} [add_monoid M] [preorder M] (L : list M) (h : 0 < L.sum) : 0 < L.length"

- doc_string: " Assumes right covariance. The lemma assuming left covariance is `left.mul_lt_one'`."
  theorem: "{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_mul.mul) has_le.le] {a b : Î±} (ha : a < 1) (hb : b < 1) : a * b < 1"

- doc_string: "Assumes right covariance."
  theorem: "{Î± : Type u} {a b : Î±} [mul_one_class Î±] [has_zero Î±] [preorder Î±] [zero_lt.mul_pos_mono Î±] (ha : a â‰¤ 1) (hb : b â‰¤ 1) (b0 : 0 < b) : a * b â‰¤ 1"

- doc_string: "Some basic API lemmas"
  theorem: "{F : Type u_1} [field F] [fintype F] [decidable_eq F] (a : F) : char.quadratic_char F a = 0 â†” a = 0"

- doc_string: "**Alias** of dvd.intro`."
  theorem: "{Î± : Type u_1} [semigroup Î±] {a b : Î±} (c : Î±) (h : a * c = b) : a âˆ£ b"

- doc_string: "A closed subset of a compact set is a compact set."
  theorem: "{Î± : Type u} [topological_space Î±] {s t : set Î±} (hs : is_compact s) (ht : is_closed t) (h : t âŠ† s) : is_compact t"

- doc_string: "If a nondegenerate configuration has a unique line through any two points, then `|P| â‰¤ |L|`."
  theorem: "(P L : Type u) [has_mem P L] [configuration.has_lines P L] [fintype P] [fintype L] : fintype.card P â‰¤ fintype.card L"

- doc_string: " Note: this lemma is specifically about `fintype.of_subsingleton`. For a statement about arbitrary `fintype` instances, use either `fintype.card_le_one_iff_subsingleton` or `fintype.card_unique`."
  theorem: "{Î± : Type u_1} (a : Î±) [subsingleton Î±] : fintype.card Î± = 1"

- doc_string: "Given all wide pullbacks in `C`, construct products in `C/B`."
  theorem: "{C : Type u} [category_theory.category C] [category_theory.limits.has_wide_pullbacks C] {B : C} : category_theory.limits.has_products (category_theory.over B)"

- doc_string: "Elements of finite additive order are closed under addition."
  theorem: "{G : Type u} {x y : G} [add_comm_monoid G] (hx : is_of_fin_add_order x) (hy : is_of_fin_add_order y) : is_of_fin_add_order (x + y)"

- doc_string: "A minimal polynomial is not a unit."
  theorem: "(A : Type u_1) {B : Type u_2} [comm_ring A] [ring B] [algebra A B] (x : B) [nontrivial B] : Â¬is_unit (minpoly A x)"

- doc_string: "**Alias** of not_is_min_of_lt`."
  theorem: "{Î± : Type u_1} [preorder Î±] {a b : Î±} (h : b < a) : Â¬is_min a"

- doc_string: "**Alias** of the reverse direction of sub_nonneg`."
  theorem: "{Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±} : b â‰¤ a â†’ 0 â‰¤ a - b"

- doc_string: 'For a path `Î³`, `Î³.truncate` gives a "continuous family of paths", by which we  mean the uncurried function which maps `(tâ‚€, tâ‚, s)` to `Î³.truncate tâ‚€ tâ‚ s` is continuous.'
  theorem: "{X : Type u_1} [topological_space X] {a b : X} (Î³ : path a b) : continuous (Î» (x : â„ Ã— â„ Ã— â†¥unit_interval), â‡‘(Î³.truncate x.fst x.snd.fst) x.snd.snd)"

- doc_string: "**Alias** of the reverse direction of multiset.Icc_eq_zero_iff`."
  theorem: "{Î± : Type u_1} [preorder Î±] [locally_finite_order Î±] {a b : Î±} : Â¬a â‰¤ b â†’ multiset.Icc a b = 0"

- doc_string: "Factoring a prime gives the corresponding one-element multiset."
  theorem: "(p : nat.primes) : â†‘p.factor_multiset = prime_multiset.of_prime p"

- doc_string: "Cannot be an instance because `power_basis` cannot be a class."
  theorem: "{S : Type u_2} [comm_ring S] {K : Type u_6} [field K] [algebra K S] (pb : power_basis K S) : finite_dimensional K S"

- doc_string: "**Alias** of the forward direction of lt_sub_iff_add_lt'`."
  theorem: "{Î± : Type u} [add_comm_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b c : Î±} : b < c - a â†’ a + b < c"

- doc_string: " In a linear ordered field, for positive `a` and `b` we have `aâ»Â¹ < b â†” bâ»Â¹ < a`. See also `inv_lt_of_inv_lt` for a one-sided implication with one fewer assumption."
  theorem: "{Î± : Type u_1} [linear_ordered_field Î±] {a b : Î±} (ha : 0 < a) (hb : 0 < b) : aâ»Â¹ < b â†” bâ»Â¹ < a"

- doc_string: "In a non-trivial `mul_zero_class`, the `0` element is not left-regular."
  theorem: "{R : Type u_1} [mul_zero_class R] : Â¬is_left_regular 0 â†” nontrivial R"

- doc_string: "Negation of the condition `P : Prop` in a `dite` is the same as swapping the branches."
  theorem: "{Î± : Sort u_1} (P : Prop) [decidable P] (x : Â¬P â†’ Î±) (y : Â¬Â¬P â†’ Î±) : dite (Â¬P) x y = dite P (Î» (h : P), y _) x"

- doc_string: "**Alias** of the reverse direction of complete_lattice.is_sup_closed_compact_iff_well_founded`."
  theorem: "(Î± : Type u_1) [complete_lattice Î±] : well_founded gt â†’ complete_lattice.is_sup_closed_compact Î±"

- doc_string: "A finite dimensional space is nontrivial if it has positive `finrank`."
  theorem: "{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] (h : 0 < finite_dimensional.finrank K V) : nontrivial V"

- doc_string: "Negation of the condition `P : Prop` in a `ite` is the same as swapping the branches."
  theorem: "{Î± : Sort u_1} (P : Prop) [decidable P] (a b : Î±) : ite (Â¬P) a b = ite P b a"

- doc_string: "This can be used to turn `is_chain (â‰¥)` into `is_chain (â‰¤)` and vice-versa."
  theorem: "{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} {s : set Î±} (h : is_chain r s) : is_chain (flip r) s"

- doc_string: "Two affine subspaces are equal if they have the same points."
  theorem: "{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] : function.injective coe"

- doc_string: "**Alias** of the forward direction of inv_mul_lt_iff_lt_mul`."
  theorem: "{Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a b c : Î±} : bâ»Â¹ * a < c â†’ a < b * c"

- doc_string: "Assumes right covariance."
  theorem: "{Î± : Type u} {a b : Î±} [mul_one_class Î±] [has_zero Î±] [preorder Î±] [zero_lt.mul_pos_strict_mono Î±] (ha : a < 1) (hb : b â‰¤ 1) (b0 : 0 < b) : a * b < 1"

- doc_string: "If `0 < n`, then `i : zmod n` has order `n / gcd n i`."
  theorem: "{n : â„•} [fact (0 < n)] (i : zmod n) : order_of (dihedral_group.r i) = n / n.gcd i.val"

- doc_string: "**Alias** of the forward direction of mul_sub_mul_div_mul_neg_iff`."
  theorem: "{Î± : Type u_1} [linear_ordered_field Î±] {a b c d : Î±} (hc : c â‰  0) (hd : d â‰  0) : (a * d - b * c) / (c * d) < 0 â†’ a / c < b / d"

- doc_string: "In a preadditive category, if all binary coproducts exist, then all binary biproducts exist."
  theorem: "{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_binary_coproducts C] : category_theory.limits.has_binary_biproducts C"

- doc_string: " The prime divisors of the characteristic of a finite commutative ring are exactly the prime divisors of its cardinality."
  theorem: "{R : Type u_1} [comm_ring R] [fintype R] (p : â„•) [fact (nat.prime p)] : p âˆ£ ring_char R â†” p âˆ£ fintype.card R"

- doc_string: "**Alias** of the reverse direction of same_ray_neg_iff`."
  theorem: "{R : Type u_1} [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {x y : M} : same_ray R x y â†’ same_ray R (-x) (-y)"

- doc_string: "**Alias** of left.one_le_inv_iff`."
  theorem: "{Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± has_add.add has_le.le] {a : Î±} : 0 â‰¤ -a â†” a â‰¤ 0"

- doc_string: "The negation of a map which preserves addition, preserves addition when the target is commutative."
  theorem: "{Î± : Type u_1} {Î² : Type u_2} [has_add Î±] [add_comm_group Î²] {f : Î± â†’ Î²} (hf : is_add_hom f) : is_add_hom (Î» (a : Î±), -f a)"

- doc_string: "Congruence relations are transitive."
  theorem: "{M : Type u_1} [has_mul M] (c : con M) {x y z : M} : â‡‘c x y â†’ â‡‘c y z â†’ â‡‘c x z"

- doc_string: "**Alias** of the reverse direction of order.pred_ne_pred_iff`."
  theorem: "{Î± : Type u_1} [partial_order Î±] [pred_order Î±] {a b : Î±} [no_min_order Î±] : a â‰  b â†’ order.pred a â‰  order.pred b"

- doc_string: "A version of `right_iff_left_not_left` with explicit `r` and `s`."
  theorem: "{Î± : Type u} (r s : Î± â†’ Î± â†’ Prop) [is_nonstrict_strict_order Î± r s] {a b : Î±} : s a b â†” r a b âˆ§ Â¬r b a"

- doc_string: "**Alias** of the reverse direction of lt_sub_iff_add_lt'`."
  theorem: "{Î± : Type u} [add_comm_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b c : Î±} : a + b < c â†’ b < c - a"

- doc_string: " Bernoulli's inequality. This version works for semirings but requires additional hypotheses `0 â‰¤ a * a` and `0 â‰¤ (1 + a) * (1 + a)`."
  theorem: "{R : Type uâ‚} [ordered_semiring R] {a : R} (Hsq : 0 â‰¤ a * a) (Hsq' : 0 â‰¤ (1 + a) * (1 + a)) (H : 0 â‰¤ 2 + a) (n : â„•) : 1 + â†‘n * a â‰¤ (1 + a) ^ n"

- doc_string: " The set of numbers satisfying the Liouville condition with some exponent `p > 2` has Lebesgue measure zero."
  theorem: " : â‡‘measure_theory.measure_space.volume (â‹ƒ (p : â„) (hp : 2 < p), {x : â„ | liouville_with p x}) = 0"

- doc_string: "Any simple object in a preadditive category is indecomposable."
  theorem: "{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_binary_biproducts C] (X : C) [category_theory.simple X] : category_theory.indecomposable X"

- doc_string: "Elements of an add right cancel semigroup are add-right-regular"
  theorem: "{R : Type u_1} [add_right_cancel_semigroup R] (g : R) : is_add_right_regular g"

- doc_string: "One direction of `div_le_iff` where `b` is allowed to be `0` (but `c` must be nonnegative)"
  theorem: "{Î± : Type u_1} [linear_ordered_field Î±] {a b c : Î±} (hb : 0 â‰¤ b) (hc : 0 â‰¤ c) (h : a â‰¤ c * b) : a / b â‰¤ c"

- doc_string: "Natural division is always less than division in the field."
  theorem: "{Î± : Type u_1} [linear_ordered_field Î±] {m n : â„•} : â†‘(m / n) â‰¤ â†‘m / â†‘n"

- doc_string: "**Alias** of the reverse direction of finset.Ico_eq_empty_iff`."
  theorem: "{Î± : Type u_1} [preorder Î±] [locally_finite_order Î±] {a b : Î±} : Â¬a < b â†’ finset.Ico a b = âˆ…"

