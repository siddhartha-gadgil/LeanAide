[{"noDocExamples": [],
  "kind": "Lean.Parser.Term.app",
  "examples":
  [{"type": "Set UpperHalfPlane",
    "name": "ModularGroup.fd",
    "isProp": false,
    "doc":
    "The standard (closed) fundamental domain of the action of `SL(2,‚Ñ§)` on `‚Ñç`. ",
    "depth": 1},
   {"type": "Linarith.LinarithM Unit",
    "name": "Linarith.elimAllVarsM",
    "isProp": false,
    "doc":
    "`elimAllVarsM` eliminates all variables from the linarith state, leaving it with a set of\nground comparisons. If this succeeds without exception, the original `linarith` state is consistent.\n",
    "depth": 1},
   {"type": "Computability.FinEncoding ‚Ñï",
    "name": "Computability.finEncodingNatBool",
    "isProp": false,
    "doc": "A binary fin_encoding of ‚Ñï in bool. ",
    "depth": 1}],
  "count": 209724},
 {"noDocExamples": [],
  "kind": "Lean.Parser.Term.type",
  "examples":
  [{"type": "Type (u + 1)",
    "name": "SSet.Augmented",
    "isProp": false,
    "doc":
    "The category of augmented simplicial sets, as a particular case of\naugmented simplicial objects. ",
    "depth": 0},
   {"type": "Type (max (u + 1) u (v + 1))",
    "name": "CategoryTheory.QuivCat",
    "isProp": false,
    "doc": "Category of quivers. ",
    "depth": 0},
   {"type": "Type (u_1 + 1)",
    "name": "NatOrdinal",
    "isProp": false,
    "doc":
    "A type synonym for ordinals with natural addition and multiplication. ",
    "depth": 0}],
  "count": 185658},
 {"noDocExamples": [],
  "kind": "Lean.Parser.Term.forall",
  "examples":
  [{"type": "‚àÄ {Œ± : Prop}, Œ±",
    "name": "lcProof",
    "isProp": true,
    "doc":
    "Auxiliary unsafe constant used by the Compiler when erasing proofs from code.\n\nIt may look strange to have an axiom that says \"every proposition is true\",\nsince this is obviously unsound, but the `unsafe` marker ensures that the\nkernel will not let this through into regular proofs. The lower levels of the\ncode generator don't need proofs in terms, so this is used to stub the proofs\nout.\n",
    "depth": 1},
   {"type": "‚àÄ (n : ‚Ñï), Int.NonNeg (Int.ofNat n)",
    "name": "Int.NonNeg.mk",
    "isProp": true,
    "doc": "Sole constructor, proving that `ofNat n` is positive. ",
    "depth": 3},
   {"type":
    "‚àÄ (o : Ordinal.{u_1}), SetTheory.PGame.Numeric (Ordinal.toPGame o)",
    "name": "SetTheory.PGame.numeric_toPGame",
    "isProp": true,
    "doc": "Ordinal games are numeric. ",
    "depth": 3}],
  "count": 175205},
 {"noDocExamples": [],
  "kind": "¬´term_=_¬ª",
  "examples":
  [{"type": "Cardinal.mk ‚ÑÇ = Cardinal.continuum",
    "name": "mk_complex",
    "isProp": true,
    "doc": "The cardinality of the complex numbers, as a type. ",
    "depth": 3},
   {"type": "Cardinal.mk ‚Ñù = Cardinal.continuum",
    "name": "Cardinal.mk_real",
    "isProp": true,
    "doc": "The cardinality of the reals, as a type. ",
    "depth": 3},
   {"type": "Ordinal.lift.{max u v, u} = Ordinal.lift.{v, u}",
    "name": "Ordinal.lift_umax",
    "isProp": true,
    "doc": "`lift.{max u v, u}` equals `lift.{v, u}`. ",
    "depth": 4}],
  "count": 102087},
 {"noDocExamples": [],
  "kind": "Lean.Parser.Term.arrow",
  "examples":
  [{"type": "AlgebraicGeometry.Scheme ‚Üí Prop",
    "name": "AlgebraicGeometry.IsReduced",
    "isProp": false,
    "doc": "A scheme `X` is reduced if all `ùí™‚Çì(U)` are reduced. ",
    "depth": 1},
   {"type": "Simps.Config ‚Üí Bool",
    "name": "Simps.Config.fullyApplied",
    "isProp": false,
    "doc":
    "Generated lemmas that are fully applied, i.e. generates equalities between applied functions.\nSet this to `false` to generate equalities between functions. ",
    "depth": 1},
   {"type": "Lean.Expr ‚Üí Lean.Expr",
    "name": "SlimCheck.Decorations.addDecorations",
    "isProp": false,
    "doc":
    "Traverse the syntax of a proposition to find universal quantifiers\nquantifiers and add `NamedBinder` annotations next to them. ",
    "depth": 1}],
  "count": 95379},
 {"noDocExamples": [],
  "kind": "coeNotation",
  "examples":
  [{"type": "‚ÜëunitInterval ‚Üí ‚Ñù",
    "name": "Path.Homotopy.transAssocReparamAux",
    "isProp": false,
    "doc": "Auxiliary function for `trans_assoc_reparam`. ",
    "depth": 3},
   {"type": "‚ÜëunitInterval ‚Üí ‚ÜëunitInterval",
    "name": "unitInterval.symm",
    "isProp": false,
    "doc": "Unit interval central symmetry. ",
    "depth": 3},
   {"type": "‚ÜëunitInterval ‚Üí ‚Ñù",
    "name": "Path.Homotopy.transReflReparamAux",
    "isProp": false,
    "doc": "Auxiliary function for `trans_refl_reparam`. ",
    "depth": 3}],
  "count": 52144},
 {"noDocExamples": [],
  "kind": "Lean.Parser.Term.depArrow",
  "examples":
  [{"type": "{Œ± : Sort u} ‚Üí Œ±",
    "name": "lcUnreachable",
    "isProp": false,
    "doc":
    "Auxiliary unsafe constant used by the Compiler to mark unreachable code.\n\nLike `lcProof`, this is an `unsafe axiom`, which means that even though it is\nnot sound, the kernel will not let us use it for regular proofs.\n\nExecuting this expression to actually synthesize a value of type `Œ±` causes\n**immediate undefined behavior**, and the compiler does take advantage of this\nto optimize the code assuming that it is not called. If it is not optimized out,\nit is likely to appear as a print message saying \"unreachable code\", but this\nbehavior is not guaranteed or stable in any way.\n",
    "depth": 1},
   {"type": "{Œπ : Type u_5} ‚Üí Type u_5",
    "name": "VectorBundleCore.Index",
    "isProp": false,
    "doc":
    "The index set of a vector bundle core, as a convenience function for dot notation ",
    "depth": 1},
   {"type": "{B : Type u_2} ‚Üí Type u_2",
    "name": "VectorBundleCore.Base",
    "isProp": false,
    "doc":
    "The base space of a vector bundle core, as a convenience function for dot notation",
    "depth": 1}],
  "count": 42864},
 {"noDocExamples": [],
  "kind": "Lean.Parser.Term.proj",
  "examples":
  [{"type": "(self : Pointed) ‚Üí self.X",
    "name": "Pointed.point",
    "isProp": false,
    "doc": "the distinguished element ",
    "depth": 2},
   {"type": "{F : PFunctor} ‚Üí PFunctor.M F ‚Üí F.A",
    "name": "PFunctor.M.head",
    "isProp": false,
    "doc":
    "given a tree generated by `F`, `head` gives us the first piece of data\nit contains ",
    "depth": 3},
   {"type": "(self : PFunctor) ‚Üí self.A ‚Üí Type u",
    "name": "PFunctor.B",
    "isProp": false,
    "doc": "The child family of types ",
    "depth": 3}],
  "count": 32972},
 {"noDocExamples": [],
  "kind": "Lean.Parser.Term.explicitUniv",
  "examples":
  [{"type": "Ordinal.{u}",
    "name": "Ordinal.omega",
    "isProp": false,
    "doc":
    "`œâ` is the first infinite ordinal, defined as the order type of `‚Ñï`. ",
    "depth": 0},
   {"type": "Cardinal.{u}",
    "name": "Cardinal.continuum",
    "isProp": false,
    "doc": "Cardinality of continuum. ",
    "depth": 0},
   {"type": "PUnit.{u}",
    "name": "PUnit.unit",
    "isProp": false,
    "doc": "`PUnit.unit : PUnit` is the canonical element of the unit type. ",
    "depth": 0}],
  "count": 27822},
 {"noDocExamples": [],
  "kind": "Lean.Parser.Term.fun",
  "examples":
  [{"type": "{Œ± : Type u_1} ‚Üí (s : Set Œ±) ‚Üí (fun x => ‚Ñï) (Set.encard s)",
    "name": "Set.ncard",
    "isProp": false,
    "doc":
    "The cardinality of `s : Set Œ±` . Has the junk value `0` if `s` is infinite ",
    "depth": 5},
   {"type": "{Œº : YoungDiagram} ‚Üí CoeFun (Ssyt Œº) fun x => ‚Ñï ‚Üí ‚Ñï ‚Üí ‚Ñï",
    "name": "Ssyt.instCoeFunSsytForAllNat",
    "isProp": false,
    "doc":
    "Helper instance for when there's too many metavariables to apply `CoeFun.coe` directly. ",
    "depth": 5},
   {"type":
    "Filter.Tendsto (fun n => Stirling.stirlingSeq n) Filter.atTop (nhds (Real.sqrt Real.pi))",
    "name": "Stirling.tendsto_stirlingSeq_sqrt_pi",
    "isProp": true,
    "doc": "**Stirling's Formula** ",
    "depth": 6}],
  "count": 25585},
 {"noDocExamples": [],
  "kind": "¬´term_‚àà_¬ª",
  "examples":
  [{"type": "¬¨Class.univ ‚àà Class.univ",
    "name": "Class.univ_not_mem_univ",
    "isProp": true,
    "doc":
    "**There is no universal set.**\nThis is stated as `univ ‚àâ univ`, meaning that `univ` (the class of all sets) is proper (does not\nbelong to the class of all sets). ",
    "depth": 6},
   {"type": "‚àÄ (A : Class), Class.iota A ‚àà Class.univ",
    "name": "Class.iota_ex",
    "isProp": true,
    "doc":
    "Unlike the other set constructors, the `iota` definite descriptor\nis a set for any set input, but not constructively so, so there is no\nassociated `Class ‚Üí Set` function. ",
    "depth": 6},
   {"type": "‚àÄ {M : Type u_1} [inst : Monoid M] {x : M}, x ‚àà powers x",
    "name": "powers.self_mem",
    "isProp": true,
    "doc":
    "An element of a monoid is in the set of that element's natural number powers. ",
    "depth": 8}],
  "count": 24782},
 {"noDocExamples": [],
  "kind": "term‚Ñï",
  "examples":
  [{"type": "‚Ñï",
    "name": "System.Platform.numBits",
    "isProp": false,
    "doc":
    "Gets the word size of the platform. That is, whether the platform is 64 or 32 bits. ",
    "depth": 0},
   {"type": "‚Ñï",
    "name": "Nat.zero",
    "isProp": false,
    "doc":
    "`Nat.zero`, normally written `0 : Nat`, is the smallest natural number.\nThis is one of the two constructors of `Nat`. ",
    "depth": 0},
   {"type": "‚Ñï",
    "name": "Nat.Linear.fixedVar",
    "isProp": false,
    "doc":
    "When encoding polynomials. We use `fixedVar` for encoding numerals.\nThe denotation of `fixedVar` is always `1`. ",
    "depth": 0}],
  "count": 22643},
 {"noDocExamples": [],
  "kind": "¬´term_‚â§_¬ª",
  "examples":
  [{"type": "‚àÄ (L : List ‚Ñï), List.headI L ‚â§ List.sum L",
    "name": "List.headI_le_sum",
    "isProp": true,
    "doc": "This relies on `default ‚Ñï = 0`. ",
    "depth": 6},
   {"type": "‚àÄ {p : ‚Ñù}, p ‚â§ 0 ‚Üí ENNReal.ofReal p = 0",
    "name": "ENNReal.ofReal_of_nonpos",
    "isProp": true,
    "doc": "**Alias** of the reverse direction of `ENNReal.ofReal_eq_zero`.",
    "depth": 6},
   {"type":
    "{x : SetTheory.PGame} ‚Üí\n  x ‚â§ 0 ‚Üí (i : SetTheory.PGame.LeftMoves x) ‚Üí SetTheory.PGame.RightMoves (SetTheory.PGame.moveLeft x i)",
    "name": "SetTheory.PGame.rightResponse",
    "isProp": false,
    "doc":
    "Given a game won by the right player when they play second, provide a response to any move by\nleft. ",
    "depth": 6}],
  "count": 20225},
 {"noDocExamples": [],
  "kind": "¬´term_+_¬ª",
  "examples":
  [{"type": "‚àÄ {a : ‚Ñï}, Real.sqrt ‚Üëa ‚â§ ‚Üë(Nat.sqrt a) + 1",
    "name": "Real.real_sqrt_le_nat_sqrt_succ",
    "isProp": true,
    "doc": "The real square root is at most the natural square root plus one ",
    "depth": 8},
   {"type": "(n : ‚Ñï) ‚Üí Fin (n + 1)",
    "name": "Fin.last",
    "isProp": false,
    "doc": "The greatest value of `Fin (n+1)`. ",
    "depth": 8},
   {"type": "‚àÄ (n : ‚Ñï), List.length (List.Nat.antidiagonal n) = n + 1",
    "name": "List.Nat.length_antidiagonal",
    "isProp": true,
    "doc": "The length of the antidiagonal of `n` is `n + 1`. ",
    "depth": 8}],
  "count": 18726},
 {"noDocExamples": [],
  "kind": "¬´term_‚Üî_¬ª",
  "examples":
  [{"type":
    "{a : Prop} ‚Üí (b : Prop) ‚Üí (a ‚Üî b) ‚Üí [inst : Decidable b] ‚Üí Decidable a",
    "name": "decidable_of_iff'",
    "isProp": false,
    "doc":
    "Transfer decidability of `b` to decidability of `a`, if the propositions are equivalent.\nThis is the same as `decidable_of_iff` but the iff is flipped. ",
    "depth": 5},
   {"type": "‚àÄ (p : True ‚Üí Prop), (‚àÄ (x : True), p x) ‚Üî p True.intro",
    "name": "forall_true_left",
    "isProp": true,
    "doc": "See `IsEmpty.forall_iff` for the `False` version. ",
    "depth": 5},
   {"type": "‚àÄ {a b : Prop}, (a ‚Üî b) ‚Üí b ‚Üí a",
    "name": "Iff.mpr",
    "isProp": true,
    "doc":
    "Modus ponens for if and only if, reversed. If `a ‚Üî b` and `b`, then `a`. ",
    "depth": 5}],
  "count": 18359},
 {"noDocExamples": [],
  "kind": "¬´term_*_¬ª",
  "examples":
  [{"type": "‚àÄ (x : SetTheory.PGame), 0 * x ‚âà 0",
    "name": "SetTheory.PGame.zero_mul_equiv",
    "isProp": true,
    "doc": "`0 * x` is equivalent to `0`. ",
    "depth": 9},
   {"type":
    "‚àÄ {n : ‚Ñï} [inst : NeZero n], Fintype.card (DihedralGroup n) = 2 * n",
    "name": "DihedralGroup.card",
    "isProp": true,
    "doc": "If `0 < n`, then `DihedralGroup n` has `2n` elements.\n",
    "depth": 9},
   {"type": "(x : SetTheory.PGame) ‚Üí SetTheory.PGame.Relabelling (1 * x) x",
    "name": "SetTheory.PGame.oneMulRelabelling",
    "isProp": false,
    "doc": "`1 * x` has the same moves as `x`. ",
    "depth": 9}],
  "count": 16520},
 {"noDocExamples": [],
  "kind": "¬´term_‚ü∂_¬ª",
  "examples":
  [{"type":
    "CategoryTheory.Limits.WalkingCospan.right ‚ü∂ CategoryTheory.Limits.WalkingCospan.one",
    "name": "CategoryTheory.Limits.WalkingCospan.Hom.inr",
    "isProp": false,
    "doc": "The right arrow of the walking cospan. ",
    "depth": 5},
   {"type":
    "CategoryTheory.Limits.WalkingSpan.zero ‚ü∂ CategoryTheory.Limits.WalkingSpan.left",
    "name": "CategoryTheory.Limits.WalkingSpan.Hom.fst",
    "isProp": false,
    "doc": "The left arrow of the walking span. ",
    "depth": 5},
   {"type":
    "CategoryTheory.Limits.WalkingSpan.zero ‚ü∂ CategoryTheory.Limits.WalkingSpan.right",
    "name": "CategoryTheory.Limits.WalkingSpan.Hom.snd",
    "isProp": false,
    "doc": "The right arrow of the walking span. ",
    "depth": 5}],
  "count": 14669},
 {"noDocExamples": [],
  "kind": "¬´term_<_¬ª",
  "examples":
  [{"type": "‚àÄ (x : ‚Ñù), 0 < Real.cosh x",
    "name": "Real.cosh_pos",
    "isProp": true,
    "doc": "`Real.cosh` is always positive ",
    "depth": 6},
   {"type": "‚àÄ {n : ‚Ñï} (self : Fin n), ‚Üëself < n",
    "name": "Fin.isLt",
    "isProp": true,
    "doc": "If `i : Fin n`, then `i.2` is a proof that `i.1 < n`. ",
    "depth": 6},
   {"type": "{a : ‚Ñï} ‚Üí 1 < a ‚Üí ‚Ñï ‚Üí ‚Ñï √ó ‚Ñï",
    "name": "Pell.pell",
    "isProp": false,
    "doc":
    "The Pell sequences, i.e. the sequence of integer solutions to `x ^ 2 - d * y ^ 2 = 1`, where\n`d = a ^ 2 - 1`, defined together in mutual recursion. ",
    "depth": 7}],
  "count": 10857},
 {"noDocExamples": [],
  "kind": "term‚Ñù",
  "examples":
  [{"type": "‚Ñù",
    "name": "Real.pi",
    "isProp": false,
    "doc":
    "The number œÄ = 3.14159265... Defined here using choice as twice a zero of cos in [1,2], from\nwhich one can derive all its properties. For explicit bounds on œÄ, see `Data.Real.Pi.Bounds`. ",
    "depth": 0},
   {"type": "‚Ñù",
    "name": "goldenRatio",
    "isProp": false,
    "doc": "The golden ratio `œÜ := (1 + ‚àö5)/2`. ",
    "depth": 0},
   {"type": "‚Ñù",
    "name": "goldenConj",
    "isProp": false,
    "doc": "The conjugate of the golden ratio `œà := (1 - ‚àö5)/2`. ",
    "depth": 0}],
  "count": 9880},
 {"noDocExamples": [],
  "kind": "Lean.Parser.Term.prop",
  "examples":
  [{"type": "Prop",
    "name": "UnivLE",
    "isProp": false,
    "doc":
    "A class expressing a universe inequality. `UnivLE.{u, v}` expresses that `u ‚â§ v`.\n\nThere are (at least) two plausible definitions for `u ‚â§ v`:\n* strong: `‚àÄ Œ± : Type max u v, Small.{v} Œ±`\n* weak: `‚àÄ Œ± : Type u, Small.{v} Œ±`\n\nThe weak definition has the advantage of being transitive.\nHowever only under the strong definition do we have `Small.{v} ((Œ± : Type u) ‚Üí (Œ≤ : Type v))`,\nwhich is essential for proving that `Type v` has `Type u`-indexed limits when `u ‚â§ v`.\n\nThe strong definition implies the weaker definition (see below),\nbut we can not prove the reverse implication.\nThis is because in Lean's type theory, while `max u v` is at least at big as `u` and `v`,\nit could be bigger than both!\n",
    "depth": 0},
   {"type": "Prop",
    "name": "True",
    "isProp": false,
    "doc":
    "`True` is a proposition and has only an introduction rule, `True.intro : True`.\nIn other words, `True` is simply true, and has a canonical proof, `True.intro`\nFor more information: [Propositional Logic](https://leanprover.github.io/theorem_proving_in_lean4/propositions_and_proofs.html#propositional-logic)\n",
    "depth": 0},
   {"type": "Prop",
    "name": "False",
    "isProp": false,
    "doc":
    "`False` is the empty proposition. Thus, it has no introduction rules.\nIt represents a contradiction. `False` elimination rule, `False.rec`,\nexpresses the fact that anything follows from a contradiction.\nThis rule is sometimes called ex falso (short for ex falso sequitur quodlibet),\nor the principle of explosion.\nFor more information: [Propositional Logic](https://leanprover.github.io/theorem_proving_in_lean4/propositions_and_proofs.html#propositional-logic)\n",
    "depth": 0}],
  "count": 9679},
 {"noDocExamples": [],
  "kind": "Lean.Parser.Term.hole",
  "examples":
  [{"type": "(n : ‚Ñï) ‚Üí Finset ((_ : Fin n) √ó Fin n)",
    "name": "Equiv.Perm.finPairsLT",
    "isProp": false,
    "doc": "set of all pairs (‚ü®a, b‚ü© : Œ£ a : fin n, fin n) such that b < a ",
    "depth": 5},
   {"type": "{Œ± : Type u_7} ‚Üí {Œ≤ : Type u_8} ‚Üí Œ± √ó Œ≤ ‚Üí (_ : Œ±) √ó Œ≤",
    "name": "Prod.toSigma",
    "isProp": false,
    "doc": "Convert a product type to a Œ£-type. ",
    "depth": 5},
   {"type": "(Œ± : Type u_1) ‚Üí (_ : Œ±) √ó PUnit.{u_2 + 1} ‚âÉ Œ±",
    "name": "Equiv.sigmaPUnit",
    "isProp": false,
    "doc":
    "`PUnit` is a right identity for dependent type product up to an equivalence. ",
    "depth": 5}],
  "count": 8863},
 {"noDocExamples": [],
  "kind": "¬´term{_:_//_}¬ª",
  "examples":
  [{"type": "‚àÄ {Œ± : Sort u_1}, IsEmpty { _a // False }",
    "name": "Subtype.isEmpty_false",
    "isProp": true,
    "doc": "subtypes by false are false. ",
    "depth": 4},
   {"type": "ZFSet ‚âÉ { s // Small.{u, u + 1} ‚Üës }",
    "name": "ZFSet.toSet_equiv",
    "isProp": false,
    "doc": "`ZFSet.toSet` as an equivalence. ",
    "depth": 6},
   {"type": "{Œ± : Type u_1} ‚Üí {P : Œ± ‚Üí Prop} ‚Üí (‚àÉ x, P x) ‚Üí { x // P x }",
    "name": "Classical.subtype_of_exists",
    "isProp": false,
    "doc":
    "A version of `Classical.indefiniteDescription` which is definitionally equal to a pair ",
    "depth": 6}],
  "count": 8013},
 {"noDocExamples": [],
  "kind": "¬´term_‚â†_¬ª",
  "examples":
  [{"type": "‚àÄ (self : ‚Ñö), self.den ‚â† 0",
    "name": "Rat.den_nz",
    "isProp": true,
    "doc": "The denominator is nonzero. ",
    "depth": 5},
   {"type": "{Œ± : Type u_3} ‚Üí Nat.card Œ± ‚â† 0 ‚Üí Œ± ‚âÉ Fin (Nat.card Œ±)",
    "name": "Nat.equivFinOfCardPos",
    "isProp": false,
    "doc":
    "If the cardinality is positive, that means it is a finite type, so there is\nan equivalence between `Œ±` and `Fin (Nat.card Œ±)`. See also `Finite.equivFin`. ",
    "depth": 6},
   {"type": "‚àÄ {Œ± : Type u} {s : Set Œ±}, Nonempty ‚Üës ‚Üî s ‚â† ‚àÖ",
    "name": "Set.nonempty_iff_ne_empty'",
    "isProp": true,
    "doc": "See also `not_nonempty_iff_eq_empty'`. ",
    "depth": 7}],
  "count": 7757},
 {"noDocExamples": [],
  "kind": "¬´term_‚Ä¢_¬ª",
  "examples":
  [{"type": "‚àÄ {M : Type u} [inst : AddMonoid M] (a : M), 2 ‚Ä¢ a = a + a",
    "name": "two_nsmul",
    "isProp": true,
    "doc": "",
    "depth": 11},
   {"type": "‚àÄ (n k : ‚Ñï), Nat.factorization (n ^ k) = k ‚Ä¢ Nat.factorization n",
    "name": "Nat.factorization_pow",
    "isProp": true,
    "doc":
    "For any `p`, the power of `p` in `n^k` is `k` times the power in `n` ",
    "depth": 11},
   {"type":
    "‚àÄ {G : Type u_1} [inst : AddMonoid G] {x : G}, (Function.Injective fun n => n ‚Ä¢ x) ‚Üí ¬¨IsOfFinAddOrder x",
    "name": "not_isOfFinAddOrder_of_injective_nsmul",
    "isProp": true,
    "doc": "See also `injective_nsmul_iff_not_isOfFinAddOrder`.",
    "depth": 12}],
  "count": 7680},
 {"noDocExamples": [],
  "kind": "Lean.Parser.Term.typeAscription",
  "examples":
  [{"type":
    "‚àÄ {Œº : YoungDiagram},\n  YoungDiagram.ofRowLens (YoungDiagram.rowLens Œº) (_ : List.Sorted (fun x x_1 => x ‚â• x_1) (YoungDiagram.rowLens Œº)) = Œº",
    "name": "YoungDiagram.ofRowLens_to_rowLens_eq_self",
    "isProp": true,
    "doc": "The left_inv direction of the equivalence ",
    "depth": 6},
   {"type":
    "‚àÄ {Œ± : Type u_1} (r : Setoid Œ±), Setoid.mkClasses (Setoid.classes r) (_ : ‚àÄ (a : Œ±), ‚àÉ! b x, a ‚àà b) = r",
    "name": "Setoid.mkClasses_classes",
    "isProp": true,
    "doc":
    "The equivalence relation made from the equivalence classes of an equivalence\nrelation r equals r. ",
    "depth": 8},
   {"type":
    "‚àÄ {n : ‚Ñï},\n  Finset.map { toFun := Prod.swap, inj' := (_ : Function.Injective Prod.swap) } (Finset.Nat.antidiagonal n) =\n    Finset.Nat.antidiagonal n",
    "name": "Finset.Nat.map_swap_antidiagonal",
    "isProp": true,
    "doc": "See also `Finset.map.map_prodComm_antidiagonal`. ",
    "depth": 11}],
  "count": 7623},
 {"noDocExamples": [],
  "kind": "¬´term_‚àß_¬ª",
  "examples":
  [{"type": "‚àÄ {a b : Prop}, a ‚àß b ‚Üí a",
    "name": "And.left",
    "isProp": true,
    "doc":
    "Extract the left conjunct from a conjunction. `h : a ‚àß b` then\n`h.left`, also notated as `h.1`, is a proof of `a`. ",
    "depth": 5},
   {"type": "‚àÄ {a b : Prop}, a ‚àß b ‚Üí b",
    "name": "And.right",
    "isProp": true,
    "doc":
    "Extract the right conjunct from a conjunction. `h : a ‚àß b` then\n`h.right`, also notated as `h.2`, is a proof of `b`. ",
    "depth": 5},
   {"type": "‚àÄ {a b : Prop}, a ‚Üí b ‚Üí a ‚àß b",
    "name": "And.intro",
    "isProp": true,
    "doc":
    "`And.intro : a ‚Üí b ‚Üí a ‚àß b` is the constructor for the And operation. ",
    "depth": 6}],
  "count": 7247},
 {"noDocExamples": [],
  "kind": "Lean.Parser.Term.structInst",
  "examples":
  [{"type": "‚àÄ {Œ± : Sort u} (a : Œ±), { down := a }.down = a",
    "name": "PLift.down_up",
    "isProp": true,
    "doc": "Bijection between `Œ±` and `PLift Œ±` ",
    "depth": 7},
   {"type": "‚àÄ {Œ± : Type u} (b : ULift.{v, u} Œ±), { down := b.down } = b",
    "name": "ULift.up_down",
    "isProp": true,
    "doc": "Bijection between `Œ±` and `ULift.{v} Œ±` ",
    "depth": 7},
   {"type": "‚àÄ {Œ± : Sort u} (b : PLift Œ±), { down := b.down } = b",
    "name": "PLift.up_down",
    "isProp": true,
    "doc": "Bijection between `Œ±` and `PLift Œ±` ",
    "depth": 7}],
  "count": 7144},
 {"noDocExamples": [],
  "kind": "¬´term‚àÉ_,_¬ª",
  "examples":
  [{"type": "‚àÄ {p : ‚Ñï ‚Üí Prop}, (‚àÉ x, p x) ‚Üí WellFounded (Nat.Upto.GT p)",
    "name": "Nat.Upto.wf",
    "isProp": true,
    "doc":
    "The \"greater than\" relation on `Upto p` is well founded if (and only if) there exists a value\nsatisfying `p`. ",
    "depth": 5},
   {"type": "{p : ‚Ñï+ ‚Üí Prop} ‚Üí [inst : DecidablePred p] ‚Üí (‚àÉ n, p n) ‚Üí ‚Ñï+",
    "name": "PNat.find",
    "isProp": false,
    "doc":
    "If `p` is a (decidable) predicate on `‚Ñï+` and `hp : ‚àÉ (n : ‚Ñï+), p n` is a proof that\nthere exists some positive natural number satisfying `p`, then `PNat.find hp` is the\nsmallest positive natural number satisfying `p`. Note that `PNat.find` is protected,\nmeaning that you can't just write `find`, even if the `PNat` namespace is open.\n\nThe API for `PNat.find` is:\n\n* `PNat.find_spec` is the proof that `PNat.find hp` satisfies `p`.\n* `PNat.find_min` is the proof that if `m < PNat.find hp` then `m` does not satisfy `p`.\n* `PNat.find_min'` is the proof that if `m` does satisfy `p` then `PNat.find hp ‚â§ m`.\n",
    "depth": 6},
   {"type": "‚àÄ (p : True ‚Üí Prop), (‚àÉ x, p x) ‚Üî p True.intro",
    "name": "exists_true_left",
    "isProp": true,
    "doc": "See `IsEmpty.exists_iff` for the `False` version. ",
    "depth": 6}],
  "count": 6862},
 {"noDocExamples": [],
  "kind": "Lean.Parser.Term.sort",
  "examples":
  [{"type": "Sort u",
    "name": "PEmpty",
    "isProp": false,
    "doc":
    "The universe-polymorphic empty type. Prefer `Empty` or `False` where\npossible.\n",
    "depth": 0},
   {"type": "Sort u",
    "name": "PUnit",
    "isProp": false,
    "doc":
    "The unit type, the canonical type with one element, named `unit` or `()`.\nThis is the universe-polymorphic version of `Unit`; it is preferred to use\n`Unit` instead where applicable.\nFor more information about universe levels: [Types as objects](https://leanprover.github.io/theorem_proving_in_lean4/dependent_type_theory.html#types-as-objects)\n",
    "depth": 0},
   {"type": "Sort u ‚Üí Prop",
    "name": "Countable",
    "isProp": false,
    "doc": "A type `Œ±` is countable if there exists an injective map `Œ± ‚Üí ‚Ñï`. ",
    "depth": 1}],
  "count": 6038},
 {"noDocExamples": [],
  "kind": "¬´term_-_¬ª",
  "examples":
  [{"type":
    "‚àÄ (L : List ‚Ñï), List.sum (List.tail L) = List.sum L - List.headI L",
    "name": "List.tail_sum",
    "isProp": true,
    "doc": "This relies on `default ‚Ñï = 0`. ",
    "depth": 8},
   {"type":
    "(fun œÑ => jacobiTheta œÑ - 1) =O[Filter.comap Complex.im Filter.atTop] fun œÑ => rexp (-Real.pi * œÑ.im)",
    "name": "isBigO_at_im_infty_jacobiTheta_sub_one",
    "isProp": true,
    "doc":
    "The norm of `jacobiTheta œÑ - 1` decays exponentially as `im œÑ ‚Üí ‚àû`. ",
    "depth": 9},
   {"type": "‚àÄ {a : ENNReal}, a - ‚ä§ = 0",
    "name": "ENNReal.sub_top",
    "isProp": true,
    "doc":
    "This is a special case of `WithTop.sub_top` in the `ENNReal` namespace ",
    "depth": 9}],
  "count": 5899},
 {"noDocExamples": [],
  "kind": "¬´term_^_¬ª",
  "examples":
  [{"type": "‚àÄ {q : ‚Ñï+}, Fintype.card (LucasLehmer.X q) = ‚Üëq ^ 2",
    "name": "LucasLehmer.X.card_eq",
    "isProp": true,
    "doc": "The cardinality of `X` is `q^2`. ",
    "depth": 8},
   {"type": "LinearRecurrence.IsSolution fibRec fun x => goldenConj ^ x",
    "name": "geom_goldConj_isSol_fibRec",
    "isProp": true,
    "doc": "The geometric sequence `fun n ‚Ü¶ œà^n` is a solution of `fibRec`. ",
    "depth": 8},
   {"type": "‚àÄ (a : ‚Ñ§), ‚Üë(Int.natAbs a) ‚â§ a ^ 2",
    "name": "Int.natAbs_le_self_pow_two",
    "isProp": true,
    "doc": "**Alias** of `Int.natAbs_le_self_sq`.",
    "depth": 8}],
  "count": 5633},
 {"noDocExamples": [],
  "kind": "¬´term-_¬ª",
  "examples":
  [{"type": "goldenConj‚Åª¬π = -goldenRatio",
    "name": "inv_goldConj",
    "isProp": true,
    "doc": "The opposite of the golden ratio is the inverse of its conjugate. ",
    "depth": 5},
   {"type": "goldenRatio‚Åª¬π = -goldenConj",
    "name": "inv_gold",
    "isProp": true,
    "doc": "The inverse of the golden ratio is the opposite of its conjugate. ",
    "depth": 5},
   {"type":
    "{x : SetTheory.PGame} ‚Üí SetTheory.PGame.RightMoves x ‚âÉ SetTheory.PGame.LeftMoves (-x)",
    "name": "SetTheory.PGame.toLeftMovesNeg",
    "isProp": false,
    "doc":
    "Turns a right move for `x` into a left move for `-x` and vice versa.\n\nEven though these types are the same (not definitionally so), this is the preferred way to convert\nbetween them. ",
    "depth": 6}],
  "count": 4815},
 {"noDocExamples": [],
  "kind": "term‚Ñ§",
  "examples":
  [{"type": "‚Ñ§",
    "name": "Int.zero",
    "isProp": false,
    "doc": "The number `0 : ‚Ñ§`, as a standalone definition. ",
    "depth": 0},
   {"type": "‚Ñ§",
    "name": "Int.one",
    "isProp": false,
    "doc": "The number `1 : ‚Ñ§`, as a standalone definition. ",
    "depth": 0},
   {"type": "‚Ñ§ ‚Üí ZNum",
    "name": "ZNum.ofInt'",
    "isProp": false,
    "doc": "Converts an `Int` to a `ZNum`. ",
    "depth": 1}],
  "count": 4747},
 {"noDocExamples": [],
  "kind": "¬´term_√ó_¬ª",
  "examples":
  [{"type": "PNat.XgcdType ‚Üí ‚Ñï √ó ‚Ñï",
    "name": "PNat.XgcdType.vp",
    "isProp": false,
    "doc":
    "The map `v` gives the product of the matrix\n[[w, x], [y, z]] = [[wp + 1, x], [y, zp + 1]]\nand the vector [a, b] = [ap + 1, bp + 1].  The map\n`vp` gives [sp, tp] such that v = [sp + 1, tp + 1].\n",
    "depth": 3},
   {"type": "‚ÑÇ ‚âÉ ‚Ñù √ó ‚Ñù",
    "name": "Complex.equivRealProd",
    "isProp": false,
    "doc": "The equivalence between the complex numbers and `‚Ñù √ó ‚Ñù`. ",
    "depth": 3},
   {"type": "‚Ñï √ó ‚Ñï ‚Üí ‚Ñï √ó ‚Ñï",
    "name": "PNat.XgcdType.succ‚ÇÇ",
    "isProp": false,
    "doc": "`succ‚ÇÇ [t.1, t.2] = [t.1.succ, t.2.succ]` ",
    "depth": 3}],
  "count": 4725},
 {"noDocExamples": [],
  "kind": "¬´term_‚äÜ_¬ª",
  "examples":
  [{"type": "‚àÄ {x : ZFSet}, ZFSet.IsTransitive x ‚Üí x ‚äÜ ZFSet.powerset x",
    "name": "ZFSet.IsTransitive.subset_powerset",
    "isProp": true,
    "doc":
    "**Alias** of the forward direction of `ZFSet.isTransitive_iff_subset_powerset`.",
    "depth": 6},
   {"type": "‚àÄ {A : Class}, Class.powerset A ‚äÜ A ‚Üí A = Class.univ",
    "name": "Class.eq_univ_of_powerset_subset",
    "isProp": true,
    "doc":
    "An induction principle for sets. If every subset of a class is a member, then the class is\nuniversal. ",
    "depth": 6},
   {"type": "‚àÄ {x : ZFSet}, ZFSet.IsTransitive x ‚Üí ‚ãÉ‚ÇÄ x ‚äÜ x",
    "name": "ZFSet.IsTransitive.sUnion_subset",
    "isProp": true,
    "doc":
    "**Alias** of the forward direction of `ZFSet.isTransitive_iff_sUnion_subset`.",
    "depth": 6}],
  "count": 4351},
 {"noDocExamples": [],
  "kind": "¬´term‚ä§¬ª",
  "examples":
  [{"type": "{Œ± : Type u_1} ‚Üí Filter.Realizer ‚ä§",
    "name": "Filter.Realizer.top",
    "isProp": false,
    "doc": "`Unit` is a realizer for the top filter ",
    "depth": 5},
   {"type":
    "{C : EReal ‚Üí Sort u_1} ‚Üí C ‚ä• ‚Üí ((a : ‚Ñù) ‚Üí C ‚Üëa) ‚Üí C ‚ä§ ‚Üí (a : EReal) ‚Üí C a",
    "name": "EReal.rec",
    "isProp": false,
    "doc":
    "A recursor for `EReal` in terms of the coercion.\n\nA typical invocation looks like `induction x using EReal.rec`. Note that using `induction`\ndirectly will unfold `EReal` to `Option` which is undesirable.\n\nWhen working in term mode, note that pattern matching can be used directly. ",
    "depth": 7},
   {"type": "{Œ± : Type u_1} ‚Üí (x : WithTop Œ±) ‚Üí x ‚â† ‚ä§ ‚Üí Œ±",
    "name": "WithTop.untop",
    "isProp": false,
    "doc":
    "Deconstruct a `x : WithTop Œ±` to the underlying value in `Œ±`, given a proof that `x ‚â† ‚ä§`. ",
    "depth": 7}],
  "count": 4315},
 {"noDocExamples": [],
  "kind": "¬´term¬¨_¬ª",
  "examples":
  [{"type": "¬¨Small.{u, max (u + 1) (v + 1)} Ordinal.{max u v}",
    "name": "not_small_ordinal",
    "isProp": true,
    "doc":
    "The type of ordinals in universe `u` is not `Small.{u}`. This is the type-theoretic analog of\nthe Burali-Forti paradox. ",
    "depth": 2},
   {"type": "{p : Prop} ‚Üí ¬¨p ‚Üí Decidable p",
    "name": "Decidable.isFalse",
    "isProp": false,
    "doc": "Prove that `p` is decidable by supplying a proof of `¬¨p` ",
    "depth": 3},
   {"type": "¬¨Set.Countable Set.univ",
    "name": "Cardinal.not_countable_real",
    "isProp": true,
    "doc":
    "**Non-Denumerability of the Continuum**: The reals are not countable. ",
    "depth": 3}],
  "count": 3704},
 {"noDocExamples": [],
  "kind": "¬´term_/_¬ª",
  "examples":
  [{"type": "riemannZeta 0 = -1 / 2",
    "name": "riemannZeta_zero",
    "isProp": true,
    "doc": "We have `Œ∂(0) = -1 / 2`. ",
    "depth": 8},
   {"type": "¬¨Summable fun n => 1 / ‚Üën",
    "name": "Real.not_summable_one_div_nat_cast",
    "isProp": true,
    "doc": "Harmonic series is not unconditionally summable. ",
    "depth": 9},
   {"type": "Real.sin (Real.pi / 3) = Real.sqrt 3 / 2",
    "name": "Real.sin_pi_div_three",
    "isProp": true,
    "doc": "The sine of `œÄ / 3` is `‚àö3 / 2`. ",
    "depth": 10}],
  "count": 3690},
 {"noDocExamples": [],
  "kind": "¬´term_‚Åª¬π¬ª",
  "examples":
  [{"type": "goldenConj‚Åª¬π = -goldenRatio",
    "name": "inv_goldConj",
    "isProp": true,
    "doc": "The opposite of the golden ratio is the inverse of its conjugate. ",
    "depth": 5},
   {"type": "goldenRatio‚Åª¬π = -goldenConj",
    "name": "inv_gold",
    "isProp": true,
    "doc": "The inverse of the golden ratio is the opposite of its conjugate. ",
    "depth": 5},
   {"type": "SetTheory.PGame.Relabelling 1‚Åª¬π 1",
    "name": "SetTheory.PGame.invOne",
    "isProp": false,
    "doc": "`1‚Åª¬π` has exactly the same moves as `1`. ",
    "depth": 6}],
  "count": 3040},
 {"noDocExamples": [],
  "kind": "¬´term_‚àò_¬ª",
  "examples":
  [{"type": "Antitone (Stirling.stirlingSeq ‚àò Nat.succ)",
    "name": "Stirling.stirlingSeq'_antitone",
    "isProp": true,
    "doc": "The sequence `stirlingSeq ‚àò succ` is monotone decreasing ",
    "depth": 6},
   {"type": "Antitone (Real.log ‚àò Stirling.stirlingSeq ‚àò Nat.succ)",
    "name": "Stirling.log_stirlingSeq'_antitone",
    "isProp": true,
    "doc": "The sequence `log ‚àò stirlingSeq ‚àò succ` is monotone decreasing ",
    "depth": 7},
   {"type":
    "Cardinal.ord ‚àò Cardinal.aleph' = Ordinal.enumOrd {b | Cardinal.ord (Ordinal.card b) = b}",
    "name": "Cardinal.ord_aleph'_eq_enum_card",
    "isProp": true,
    "doc": "`ord ‚àò aleph'` enumerates the ordinals that are cardinals. ",
    "depth": 8}],
  "count": 2926},
 {"noDocExamples": [],
  "kind": "¬´term_‚Üí+*_¬ª",
  "examples":
  [{"type": "NNReal ‚Üí+* ‚Ñù",
    "name": "NNReal.toRealHom",
    "isProp": false,
    "doc":
    "Coercion `‚Ñù‚â•0 ‚Üí ‚Ñù` as a `RingHom`.\n\nPorting note: todo: what if we define `Coe ‚Ñù‚â•0 ‚Ñù` using this function? ",
    "depth": 4},
   {"type": "‚Ñï ‚Üí+* ‚Ñ§",
    "name": "Int.ofNatHom",
    "isProp": false,
    "doc": "Coercion `‚Ñï ‚Üí ‚Ñ§` as a `RingHom`. ",
    "depth": 4},
   {"type": "‚Ñù ‚Üí+* ‚ÑÇ",
    "name": "Complex.ofReal",
    "isProp": false,
    "doc": "The coercion `‚Ñù ‚Üí ‚ÑÇ` as a `RingHom`. ",
    "depth": 4}],
  "count": 2858},
 {"noDocExamples": [],
  "kind": "¬´term{_}¬ª",
  "examples":
  [{"type": "Multiset.Nat.antidiagonal 0 = {(0, 0)}",
    "name": "Multiset.Nat.antidiagonal_zero",
    "isProp": true,
    "doc": "The antidiagonal of `0` is the list `[(0, 0)]` ",
    "depth": 7},
   {"type": "Finset.Nat.antidiagonal 0 = {(0, 0)}",
    "name": "Finset.Nat.antidiagonal_zero",
    "isProp": true,
    "doc": "The antidiagonal of `0` is the list `[(0, 0)]` ",
    "depth": 7},
   {"type":
    "‚àÄ {P : Type u_2} [inst : MetricSpace P] (p : P), EuclideanGeometry.Cospherical {p}",
    "name": "EuclideanGeometry.cospherical_singleton",
    "isProp": true,
    "doc": "A single point is cospherical. ",
    "depth": 8}],
  "count": 2627},
 {"noDocExamples": [],
  "kind": "¬´term_·µí·µñ¬ª",
  "examples":
  [{"type": "(Œî : SimplexCategory·µí·µñ) ‚Üí SimplicialObject.Splitting.IndexSet Œî",
    "name": "SimplicialObject.Splitting.IndexSet.id",
    "isProp": false,
    "doc":
    "The distinguished element in `Splitting.IndexSet Œî` which corresponds to the\nidentity of `Œî`. ",
    "depth": 2},
   {"type": "SimplexCategory·µí·µñ ‚Üí Type",
    "name": "SimplicialObject.Splitting.IndexSet",
    "isProp": false,
    "doc":
    "The index set which appears in the definition of split simplicial objects. ",
    "depth": 2},
   {"type": "TopCat·µí·µñ ‚Üí TopCommRingCat ‚Üí CommRingCat",
    "name": "TopCat.continuousFunctions",
    "isProp": false,
    "doc":
    "The (bundled) commutative ring of continuous functions from a topological space\nto a topological commutative ring, with pointwise multiplication. ",
    "depth": 2}],
  "count": 2558},
 {"noDocExamples": [],
  "kind": "CategoryTheory.¬´term_‚âÖ_¬ª",
  "examples":
  [{"type": "(V : Type u) ‚Üí ULift.{u, u} V ‚âÖ V",
    "name": "CategoryTheory.uliftTrivial",
    "isProp": false,
    "doc":
    "The isomorphism between a `Type` which has been `ULift`ed to the same universe,\nand the original type.\n",
    "depth": 5},
   {"type":
    "(X : Type u) ‚Üí CategoryTheory.Limits.IsTerminal X ‚âÉ (X ‚âÖ PUnit.{u + 1})",
    "name": "CategoryTheory.Limits.Types.isTerminalEquivIsoPUnit",
    "isProp": false,
    "doc": "A type is terminal if and only if it is isomorphic to `PUnit`. ",
    "depth": 6},
   {"type": "{X Y : Type u} ‚Üí (X ‚âÖ Y) ‚Üí X ‚âÉ Y",
    "name": "CategoryTheory.Iso.toEquiv",
    "isProp": false,
    "doc": "Any isomorphism between types gives an equivalence. ",
    "depth": 7}],
  "count": 2529},
 {"noDocExamples": [],
  "kind": "Lean.Parser.Term.tuple",
  "examples":
  [{"type": "Multiset.Nat.antidiagonal 0 = {(0, 0)}",
    "name": "Multiset.Nat.antidiagonal_zero",
    "isProp": true,
    "doc": "The antidiagonal of `0` is the list `[(0, 0)]` ",
    "depth": 7},
   {"type": "Finset.Nat.antidiagonal 0 = {(0, 0)}",
    "name": "Finset.Nat.antidiagonal_zero",
    "isProp": true,
    "doc": "The antidiagonal of `0` is the list `[(0, 0)]` ",
    "depth": 7},
   {"type": "List.Nat.antidiagonal 0 = [(0, 0)]",
    "name": "List.Nat.antidiagonal_zero",
    "isProp": true,
    "doc": "The antidiagonal of `0` is the list `[(0, 0)]` ",
    "depth": 8}],
  "count": 2516},
 {"noDocExamples": [],
  "kind": "¬´term‚Äñ_‚Äñ¬ª",
  "examples":
  [{"type": "‚àÄ {Œ± : Type u_5} [self : NontriviallyNormedField Œ±], ‚àÉ x, 1 < ‚Äñx‚Äñ",
    "name": "NontriviallyNormedField.non_trivial",
    "isProp": true,
    "doc": "The norm attains a value exceeding 1. ",
    "depth": 10},
   {"type":
    "‚àÄ {Œ± : Type u_5} [inst : Norm Œ±] [inst_1 : One Œ±] [self : NormOneClass Œ±], ‚Äñ1‚Äñ = 1",
    "name": "NormOneClass.norm_one",
    "isProp": true,
    "doc": "The norm of the multiplicative identity is 1. ",
    "depth": 10},
   {"type":
    "{R : Type u_1} ‚Üí [inst : NormedRing R] ‚Üí [inst_1 : CompleteSpace R] ‚Üí (t : R) ‚Üí ‚Äñt‚Äñ < 1 ‚Üí RÀ£",
    "name": "Units.oneSub",
    "isProp": false,
    "doc":
    "In a complete normed ring, a perturbation of `1` by an element `t` of distance less than `1`\nfrom `1` is a unit.  Here we construct its `Units` structure.  ",
    "depth": 11}],
  "count": 2491},
 {"noDocExamples": [],
  "kind": "¬´term_‚âÉ_¬ª",
  "examples":
  [{"type": "‚Ñï+ ‚âÉ ‚Ñï",
    "name": "Equiv.pnatEquivNat",
    "isProp": false,
    "doc":
    "An equivalence between `‚Ñï+` and `‚Ñï` given by `PNat.natPred` and `Nat.succPNat`. ",
    "depth": 2},
   {"type": "‚Ñ§ ‚âÉ ‚Ñï",
    "name": "Equiv.intEquivNat",
    "isProp": false,
    "doc":
    "An equivalence between `‚Ñ§` and `‚Ñï`, through `‚Ñ§ ‚âÉ ‚Ñï ‚äï ‚Ñï` and `‚Ñï ‚äï ‚Ñï ‚âÉ ‚Ñï`.\n",
    "depth": 2},
   {"type": "Prop ‚âÉ Bool",
    "name": "Equiv.propEquivBool",
    "isProp": false,
    "doc": "`Prop` is noncomputably equivalent to `Bool`. ",
    "depth": 2}],
  "count": 2468},
 {"noDocExamples": [],
  "kind": "¬´term‚ä•¬ª",
  "examples":
  [{"type": "{Œ± : Type u_1} ‚Üí Filter.Realizer ‚ä•",
    "name": "Filter.Realizer.bot",
    "isProp": false,
    "doc": "`Unit` is a realizer for the bottom filter ",
    "depth": 6},
   {"type": "{Œ± : Type u_1} ‚Üí (x : WithBot Œ±) ‚Üí x ‚â† ‚ä• ‚Üí Œ±",
    "name": "WithBot.unbot",
    "isProp": false,
    "doc":
    "Deconstruct a `x : WithBot Œ±` to the underlying value in `Œ±`, given a proof that `x ‚â† ‚ä•`. ",
    "depth": 7},
   {"type":
    "{C : EReal ‚Üí Sort u_1} ‚Üí C ‚ä• ‚Üí ((a : ‚Ñù) ‚Üí C ‚Üëa) ‚Üí C ‚ä§ ‚Üí (a : EReal) ‚Üí C a",
    "name": "EReal.rec",
    "isProp": false,
    "doc":
    "A recursor for `EReal` in terms of the coercion.\n\nA typical invocation looks like `induction x using EReal.rec`. Note that using `induction`\ndirectly will unfold `EReal` to `Option` which is undesirable.\n\nWhen working in term mode, note that pattern matching can be used directly. ",
    "depth": 7}],
  "count": 2444},
 {"noDocExamples": [],
  "kind": "¬´term_‚äì_¬ª",
  "examples":
  [{"type":
    "‚àÄ (m n : ‚Ñï+), PNat.factorMultiset (PNat.gcd m n) = PNat.factorMultiset m ‚äì PNat.factorMultiset n",
    "name": "PNat.factorMultiset_gcd",
    "isProp": true,
    "doc":
    "The gcd and lcm operations on positive integers correspond\nto the inf and sup operations on multisets. ",
    "depth": 9},
   {"type":
    "{Œ± : Type u_1} ‚Üí {f g : Filter Œ±} ‚Üí Filter.Realizer f ‚Üí Filter.Realizer g ‚Üí Filter.Realizer (f ‚äì g)",
    "name": "Filter.Realizer.inf",
    "isProp": false,
    "doc": "Construct a realizer for the inf of two filters ",
    "depth": 11},
   {"type":
    "‚àÄ {Œ± : Type u_1} {m0 : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {f : Filter Œ±},\n  MeasureTheory.Measure.FiniteAtFilter Œº (f ‚äì MeasureTheory.Measure.ae Œº) ‚Üí MeasureTheory.Measure.FiniteAtFilter Œº f",
    "name": "MeasureTheory.Measure.FiniteAtFilter.of_inf_ae",
    "isProp": true,
    "doc":
    "**Alias** of the forward direction of `MeasureTheory.Measure.FiniteAtFilter.inf_ae_iff`.",
    "depth": 11}],
  "count": 2116},
 {"noDocExamples": [],
  "kind": "Set.term_''_",
  "examples":
  [{"type": "‚àÄ {Œ± : Type u_1} (s : Set Œ±), (fun x => x) '' s = s",
    "name": "Set.image_id'",
    "isProp": true,
    "doc": "A variant of `image_id` ",
    "depth": 8},
   {"type":
    "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {s : Set Œ±}, Set.Subsingleton s ‚Üí ‚àÄ (f : Œ± ‚Üí Œ≤), Set.Subsingleton (f '' s)",
    "name": "Set.Subsingleton.image",
    "isProp": true,
    "doc": "The image of a subsingleton is a subsingleton. ",
    "depth": 10},
   {"type":
    "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚Üí Œ≤) (s : Set Œ±), Set.Nontrivial (f '' s) ‚Üí Set.Nontrivial s",
    "name": "Set.nontrivial_of_image",
    "isProp": true,
    "doc": "If the image of a set is nontrivial, the set is nontrivial. ",
    "depth": 10}],
  "count": 2105},
 {"noDocExamples": [],
  "kind": "¬´term_‚äî_¬ª",
  "examples":
  [{"type":
    "‚àÄ {L : Type u_1} [inst : TopologicalSpace L] [inst_1 : Sup L] [self : ContinuousSup L],\n  Continuous fun p => p.fst ‚äî p.snd",
    "name": "ContinuousSup.continuous_sup",
    "isProp": true,
    "doc": "The supremum is continuous ",
    "depth": 11},
   {"type": "‚àÄ {Œ± : Type u} [self : SemilatticeSup Œ±] (a b : Œ±), a ‚â§ a ‚äî b",
    "name": "SemilatticeSup.le_sup_left",
    "isProp": true,
    "doc": "The supremum is an upper bound on the first argument ",
    "depth": 11},
   {"type": "‚àÄ {Œ± : Type u} [self : SemilatticeSup Œ±] (a b : Œ±), b ‚â§ a ‚äî b",
    "name": "SemilatticeSup.le_sup_right",
    "isProp": true,
    "doc": "The supremum is an upper bound on the second argument ",
    "depth": 11}],
  "count": 2040},
 {"noDocExamples": [],
  "kind": "¬´term_‚à®_¬ª",
  "examples":
  [{"type": "‚àÄ (p : Prop), p ‚à® ¬¨p",
    "name": "em",
    "isProp": true,
    "doc":
    "**Alias** of `Classical.em`.\n\n---\n\nDiaconescu's theorem: excluded middle from choice, Function extensionality and propositional extensionality. ",
    "depth": 3},
   {"type": "‚àÄ (p : Prop), p ‚à® ¬¨p",
    "name": "Classical.em",
    "isProp": true,
    "doc":
    "Diaconescu's theorem: excluded middle from choice, Function extensionality and propositional extensionality. ",
    "depth": 3},
   {"type": "‚àÄ (Œ± : Type u_3), Subsingleton Œ± ‚à® Nontrivial Œ±",
    "name": "subsingleton_or_nontrivial",
    "isProp": true,
    "doc": "A type is either a subsingleton or nontrivial. ",
    "depth": 4}],
  "count": 1972},
 {"noDocExamples": [],
  "kind": "¬´term_‚Üí‚Çó[_]_¬ª",
  "examples":
  [{"type": "‚ÑÇ ‚Üí‚Çó[‚Ñù] ‚Ñù",
    "name": "Complex.reLm",
    "isProp": false,
    "doc": "Linear map version of the real part function, from `‚ÑÇ` to `‚Ñù`. ",
    "depth": 11},
   {"type": "‚ÑÇ ‚Üí‚Çó[‚Ñù] ‚Ñù",
    "name": "Complex.imLm",
    "isProp": false,
    "doc":
    "Linear map version of the imaginary part function, from `‚ÑÇ` to `‚Ñù`. ",
    "depth": 11},
   {"type":
    "{R : Type u} ‚Üí [inst : Semiring R] ‚Üí Polynomial R ‚Üí‚Çó[R] Polynomial R",
    "name": "Polynomial.derivative",
    "isProp": false,
    "doc": "`derivative p` is the formal derivative of the polynomial `p` ",
    "depth": 13}],
  "count": 1903},
 {"noDocExamples": [],
  "kind": "¬´term_‚à©_¬ª",
  "examples":
  [{"type":
    "‚àÄ {Œ± : Type u} [inst : Preorder Œ±] {s t : Set Œ±}, BddBelow s ‚Üí BddBelow (s ‚à© t)",
    "name": "BddBelow.inter_of_left",
    "isProp": true,
    "doc": "If `s` is bounded, then so is `s ‚à© t` ",
    "depth": 11},
   {"type":
    "‚àÄ {Œ± : Type u} [inst : Preorder Œ±] {s t : Set Œ±}, BddAbove t ‚Üí BddAbove (s ‚à© t)",
    "name": "BddAbove.inter_of_right",
    "isProp": true,
    "doc": "If `t` is bounded, then so is `s ‚à© t` ",
    "depth": 11},
   {"type":
    "‚àÄ {Œ± : Type u} [inst : Preorder Œ±] {s t : Set Œ±}, BddAbove s ‚Üí BddAbove (s ‚à© t)",
    "name": "BddAbove.inter_of_left",
    "isProp": true,
    "doc": "If `s` is bounded, then so is `s ‚à© t` ",
    "depth": 11}],
  "count": 1894},
 {"noDocExamples": [],
  "kind": "Set.¬´term{_|_}¬ª",
  "examples":
  [{"type": "Set.Infinite {p | Nat.Prime p}",
    "name": "Nat.infinite_setOf_prime",
    "isProp": true,
    "doc":
    "A version of `Nat.exists_infinite_primes` using the `Set.Infinite` predicate. ",
    "depth": 4},
   {"type": "Dense {x | Liouville x}",
    "name": "dense_liouville",
    "isProp": true,
    "doc": "The set of Liouville numbers in dense. ",
    "depth": 5},
   {"type": "¬¨BddAbove {p | Nat.Prime p}",
    "name": "Nat.not_bddAbove_setOf_prime",
    "isProp": true,
    "doc":
    "A version of `Nat.exists_infinite_primes` using the `BddAbove` predicate. ",
    "depth": 6}],
  "count": 1885},
 {"noDocExamples": [],
  "kind": "Set.¬´term_‚Åª¬π'_¬ª",
  "examples":
  [{"type": "‚àÄ {s : Set ‚ÑÇ}, Set.Countable s ‚Üí Set.Countable (cexp ‚Åª¬π' s)",
    "name": "Set.Countable.preimage_cexp",
    "isProp": true,
    "doc":
    "**Alias** of the reverse direction of `Complex.countable_preimage_exp`.",
    "depth": 7},
   {"type":
    "{Œ± : Type u} ‚Üí {Œ≤ : Type v} ‚Üí (s : Finset Œ≤) ‚Üí (f : Œ± ‚Üí Œ≤) ‚Üí Set.InjOn f (f ‚Åª¬π' ‚Üës) ‚Üí Finset Œ±",
    "name": "Finset.preimage",
    "isProp": false,
    "doc":
    "Preimage of `s : Finset Œ≤` under a map `f` injective on `f ‚Åª¬π' s` as a `Finset`.  ",
    "depth": 10},
   {"type":
    "{Œ± : Type u_1} ‚Üí {Œ≤ : Type u_2} ‚Üí (t : Set Œ≤) ‚Üí (f : Œ± ‚Üí Œ≤) ‚Üí ‚Üë(f ‚Åª¬π' t) ‚Üí ‚Üët",
    "name": "Set.restrictPreimage",
    "isProp": false,
    "doc": "The restriction of a function onto the preimage of a set. ",
    "depth": 10}],
  "count": 1872},
 {"noDocExamples": [],
  "kind": "term‚ÑÇ",
  "examples":
  [{"type": "‚ÑÇ",
    "name": "Complex.I",
    "isProp": false,
    "doc": "The imaginary unit. ",
    "depth": 0},
   {"type": "‚ÑÇ ‚Üí ‚ÑÇ",
    "name": "Complex.tan",
    "isProp": false,
    "doc": "The complex tangent function, defined as `sin z / cos z` ",
    "depth": 1},
   {"type": "‚ÑÇ ‚Üí ‚ÑÇ",
    "name": "Complex.GammaIntegral",
    "isProp": false,
    "doc":
    "Euler's integral for the `Œì` function (of a complex variable `s`), defined as\n`‚à´ x in Ioi 0, exp (-x) * x ^ (s - 1)`.\n\nSee `Complex.GammaIntegral_convergent` for a proof of the convergence of the integral for\n`0 < re s`. ",
    "depth": 1}],
  "count": 1822},
 {"noDocExamples": [],
  "kind": "¬´term_‚à£_¬ª",
  "examples":
  [{"type": "Function.Injective fun x x_1 => x ‚à£ x_1",
    "name": "Nat.dvd_left_injective",
    "isProp": true,
    "doc": "`dvd` is injective in the left argument ",
    "depth": 7},
   {"type": "‚àÄ {m n : ‚Ñï}, Odd n ‚Üí m ‚à£ n ‚Üí m ‚â† 2",
    "name": "Odd.ne_two_of_dvd_nat",
    "isProp": true,
    "doc": "`2` is not a factor of an odd natural number. ",
    "depth": 8},
   {"type": "‚àÄ {a b : ‚Ñï}, a ‚à£ b ‚Üí b < a ‚Üí b = 0",
    "name": "Nat.eq_zero_of_dvd_of_lt",
    "isProp": true,
    "doc":
    "If a small natural number is divisible by a larger natural number,\nthe small number is zero. ",
    "depth": 8}],
  "count": 1431},
 {"noDocExamples": [],
  "kind": "¬´term‚àÖ¬ª",
  "examples":
  [{"type": "CategoryTheory.Limits.IsInitial ‚àÖ",
    "name": "AlgebraicGeometry.emptyIsInitial",
    "isProp": false,
    "doc":
    "The empty scheme is the initial object in the category of schemes. ",
    "depth": 3},
   {"type":
    "‚àÄ {Œ± : Type u_7} (self : MeasurableSpace Œ±), MeasurableSpace.MeasurableSet' self ‚àÖ",
    "name": "MeasurableSpace.measurableSet_empty",
    "isProp": true,
    "doc":
    "The empty set is a measurable set. Use `MeasurableSet.empty` instead. ",
    "depth": 6},
   {"type":
    "‚àÄ {Œ± : Type u_2} (self : MeasurableSpace.DynkinSystem Œ±), MeasurableSpace.DynkinSystem.Has self ‚àÖ",
    "name": "MeasurableSpace.DynkinSystem.has_empty",
    "isProp": true,
    "doc": "A Dynkin system contains the empty set. ",
    "depth": 6}],
  "count": 1427},
 {"noDocExamples": [],
  "kind": "¬´term_‚à™_¬ª",
  "examples":
  [{"type":
    "‚àÄ {Œ± : Type u_1} (s : Set Œ±) (a : Œ±), ùí´ insert a s = ùí´ s ‚à™ insert a '' ùí´ s",
    "name": "Set.powerset_insert",
    "isProp": true,
    "doc":
    "The powerset of `{a} ‚à™ s` is `ùí´ s` together with `{a} ‚à™ t` for each `t ‚àà ùí´ s`. ",
    "depth": 11},
   {"type":
    "‚àÄ {Œ± : Type u} (S T : Set Œ±), Cardinal.mk ‚Üë(S ‚à™ T) ‚â§ Cardinal.mk ‚ÜëS + Cardinal.mk ‚ÜëT",
    "name": "Cardinal.mk_union_le",
    "isProp": true,
    "doc":
    "The cardinality of a union is at most the sum of the cardinalities\nof the two sets. ",
    "depth": 12},
   {"type":
    "‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s t : Set Œ±}, Metric.Bounded s ‚Üí Metric.Bounded t ‚Üí Metric.Bounded (s ‚à™ t)",
    "name": "Metric.Bounded.union",
    "isProp": true,
    "doc": "The union of two bounded sets is bounded. ",
    "depth": 12}],
  "count": 1362},
 {"noDocExamples": [],
  "kind": "¬´term_‚Üí*_¬ª",
  "examples":
  [{"type": "Multiplicative ‚Ñù ‚Üí* ‚Ñù",
    "name": "Real.expMonoidHom",
    "isProp": false,
    "doc":
    "the exponential function as a monoid hom from `Multiplicative ‚Ñù` to `‚Ñù` ",
    "depth": 5},
   {"type": "Multiplicative ‚Ñù ‚Üí* CircleDeg1LiftÀ£",
    "name": "CircleDeg1Lift.translate",
    "isProp": false,
    "doc":
    "The map `y ‚Ü¶ x + y` as a `CircleDeg1Lift`. More precisely, we define a homomorphism from\n`Multiplicative ‚Ñù` to `CircleDeg1LiftÀ£`, so the translation by `x` is\n`translation (Multiplicative.ofAdd x)`. ",
    "depth": 5},
   {"type": "{Œ± : Type u_2} ‚Üí [inst : MulOneClass Œ±] ‚Üí Œ± ‚Üí* Set Œ±",
    "name": "Set.singletonMonoidHom",
    "isProp": false,
    "doc": "The singleton operation as a `MonoidHom`. ",
    "depth": 6}],
  "count": 1317},
 {"noDocExamples": [],
  "kind": "¬´term_‚Üí‚ÇÄ_¬ª",
  "examples":
  [{"type": "‚Ñï ‚Üí ‚Ñï ‚Üí‚ÇÄ ‚Ñï",
    "name": "Nat.factorization",
    "isProp": false,
    "doc":
    "`n.factorization` is the finitely supported function `‚Ñï ‚Üí‚ÇÄ ‚Ñï`\nmapping each prime factor of `n` to its multiplicity in `n`. ",
    "depth": 4},
   {"type": "{Œ± : Type u_1} ‚Üí (Œ± ‚Üí‚ÇÄ ‚Ñï) ‚Üí ‚Ñï",
    "name": "Finsupp.multinomial",
    "isProp": false,
    "doc":
    "Alternative multinomial definition based on a finsupp, using the support\nfor the big operations\n",
    "depth": 5},
   {"type":
    "{Œ± : Type u_13} ‚Üí {M : Type u_14} ‚Üí [inst : Zero M] ‚Üí (Œ± ‚Üí‚ÇÄ M) ‚Üí Œ± ‚Üí M",
    "name": "Finsupp.toFun",
    "isProp": false,
    "doc":
    "The underlying function of a bundled finitely supported function (aka `Finsupp`). ",
    "depth": 7}],
  "count": 1303},
 {"noDocExamples": [],
  "kind": "¬´term_‚Üí+_¬ª",
  "examples":
  [{"type": "‚Ñï ‚Üí+ PartENat",
    "name": "PartENat.natCast_AddMonoidHom",
    "isProp": false,
    "doc": "The coercion `‚Ñï ‚Üí PartENat` preserves `0` and addition. ",
    "depth": 5},
   {"type": "{Œ± : Type u_2} ‚Üí [inst : AddZeroClass Œ±] ‚Üí Œ± ‚Üí+ Set Œ±",
    "name": "Set.singletonAddMonoidHom",
    "isProp": false,
    "doc": "The singleton operation as an `AddMonoidHom`.",
    "depth": 6},
   {"type": "(Œ± : Type u_3) ‚Üí [inst : AddMonoidWithOne Œ±] ‚Üí ‚Ñï ‚Üí+ Œ±",
    "name": "Nat.castAddMonoidHom",
    "isProp": false,
    "doc": "`Nat.cast : ‚Ñï ‚Üí Œ±` as an `AddMonoidHom`. ",
    "depth": 6}],
  "count": 1286},
 {"noDocExamples": [],
  "kind": "¬´term_·µê·µí·µñ¬ª",
  "examples":
  [{"type": "{Œ± : Type u_1} ‚Üí Œ± ‚Üí Œ±·µê·µí·µñ",
    "name": "MulOpposite.op",
    "isProp": false,
    "doc": "The element of `MulOpposite Œ±` that represents `x : Œ±`. ",
    "depth": 3},
   {"type": "{Œ± : Type u_1} ‚Üí Œ±·µê·µí·µñ ‚Üí Œ±",
    "name": "MulOpposite.unop",
    "isProp": false,
    "doc": "The element of `Œ±` represented by `x : Œ±·µê·µí·µñ`. ",
    "depth": 3},
   {"type": "{Œ± : Type u_1} ‚Üí Œ± ‚âÉ Œ±·µê·µí·µñ",
    "name": "MulOpposite.opEquiv",
    "isProp": false,
    "doc": "The canonical bijection between `Œ±` and `Œ±·µê·µí·µñ`. ",
    "depth": 3}],
  "count": 1183},
 {"noDocExamples": [],
  "kind": "¬´term_‚ÜíL[_]_¬ª",
  "examples":
  [{"type": "‚Ñù ‚ÜíL[‚Ñù] ‚ÑÇ",
    "name": "Complex.ofRealClm",
    "isProp": false,
    "doc":
    "Continuous linear map version of the canonical embedding of `‚Ñù` in `‚ÑÇ`. ",
    "depth": 13},
   {"type": "‚ÑÇ ‚ÜíL[‚Ñù] ‚Ñù",
    "name": "Complex.imClm",
    "isProp": false,
    "doc":
    "Continuous linear map version of the imaginary part function, from `‚ÑÇ` to `‚Ñù`. ",
    "depth": 14},
   {"type": "‚ÑÇ ‚ÜíL[‚Ñù] ‚Ñù",
    "name": "Complex.reClm",
    "isProp": false,
    "doc":
    "Continuous linear map version of the real part function, from `‚ÑÇ` to `‚Ñù`. ",
    "depth": 14}],
  "count": 1148},
 {"noDocExamples": [],
  "kind": "Set.¬´term‚ãÉ_,_¬ª",
  "examples":
  [{"type":
    "‚àÄ {Œ± : Type u_7} (self : MeasurableSpace Œ±) (f : ‚Ñï ‚Üí Set Œ±),\n  (‚àÄ (i : ‚Ñï), MeasurableSpace.MeasurableSet' self (f i)) ‚Üí MeasurableSpace.MeasurableSet' self (‚ãÉ (i : ‚Ñï), f i)",
    "name": "MeasurableSpace.measurableSet_iUnion",
    "isProp": true,
    "doc":
    "The union of a sequence of measurable sets is a measurable set. Use a more general\n`MeasurableSet.iUnion` instead. ",
    "depth": 8},
   {"type":
    "{Œ± : Type u_1} ‚Üí {Œ≤ : Type u_2} ‚Üí (t : Œ± ‚Üí Set Œ≤) ‚Üí (i : Œ±) √ó ‚Üë(t i) ‚Üí ‚Üë(‚ãÉ (i : Œ±), t i)",
    "name": "Set.sigmaToiUnion",
    "isProp": false,
    "doc":
    "If `t` is an indexed family of sets, then there is a natural map from `Œ£ i, t i` to `‚ãÉ i, t i`\nsending `‚ü®i, x‚ü©` to `x`. ",
    "depth": 8},
   {"type":
    "‚àÄ {Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Finset Œ≤), Set.Finite (Set.range f) ‚Üí Set.Finite (‚ãÉ (a : Œ±), ‚Üë(f a))",
    "name": "Set.union_finset_finite_of_range_finite",
    "isProp": true,
    "doc": "A finite union of finsets is finite. ",
    "depth": 9}],
  "count": 1115},
 {"noDocExamples": [],
  "kind": "¬´termC(_,_)¬ª",
  "examples":
  [{"type": "C(NNReal, ‚Ñù)",
    "name": "ContinuousMap.coeNNRealReal",
    "isProp": false,
    "doc": "Embedding of `‚Ñù‚â•0` to `‚Ñù` as a bundled continuous map. ",
    "depth": 4},
   {"type": "(Œ± : Type u_1) ‚Üí [inst : TopologicalSpace Œ±] ‚Üí C(Œ±, Œ±)",
    "name": "ContinuousMap.id",
    "isProp": false,
    "doc": "The identity as a continuous map. ",
    "depth": 6},
   {"type":
    "(Œ± : Type u_1) ‚Üí {Œ≤ : Type u_2} ‚Üí [inst : TopologicalSpace Œ≤] ‚Üí C(Œ≤, Œ± ‚Üí Œ≤)",
    "name": "ContinuousMap.constPi",
    "isProp": false,
    "doc": "`Function.const Œ± b` as a bundled continuous function of `b`. ",
    "depth": 7}],
  "count": 1068},
 {"noDocExamples": [],
  "kind": "¬´term_·∂ú¬ª",
  "examples":
  [{"type": "‚Üë{‚ä•, ‚ä§}·∂ú ‚âÉ ‚Ñù",
    "name": "EReal.neTopBotEquivReal",
    "isProp": false,
    "doc":
    "The set of numbers in `EReal` that are not equal to `¬±‚àû` is equivalent to `‚Ñù`. ",
    "depth": 9},
   {"type":
    "‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±} [self : IsClosed s], IsOpen s·∂ú",
    "name": "IsClosed.isOpen_compl",
    "isProp": true,
    "doc": "The complement of a closed set is an open set. ",
    "depth": 10},
   {"type":
    "‚àÄ {Œ± : Type u_2} (self : MeasurableSpace.DynkinSystem Œ±) {a : Set Œ±},\n  MeasurableSpace.DynkinSystem.Has self a ‚Üí MeasurableSpace.DynkinSystem.Has self a·∂ú",
    "name": "MeasurableSpace.DynkinSystem.has_compl",
    "isProp": true,
    "doc": "A Dynkin system is closed under complementation. ",
    "depth": 10}],
  "count": 1046},
 {"noDocExamples": [],
  "kind": "¬´term_·µí·µà¬ª",
  "examples":
  [{"type": "{Œ± : Type u_1} ‚Üí Œ± ‚âÉ Œ±·µí·µà",
    "name": "OrderDual.toDual",
    "isProp": false,
    "doc":
    "`toDual` is the identity function to the `OrderDual` of a linear order.  ",
    "depth": 3},
   {"type": "{Œ± : Type u_1} ‚Üí WithTop Œ± ‚âÉ WithBot Œ±·µí·µà",
    "name": "WithTop.toDual",
    "isProp": false,
    "doc":
    "`WithTop.toDual` is the equivalence sending `‚ä§` to `‚ä•` and any `a : Œ±` to `toDual a : Œ±·µí·µà`.\nSee `WithTop.toDualBotEquiv` for the related order-iso.\n",
    "depth": 4},
   {"type": "{Œ± : Type u_1} ‚Üí Œ±·µí·µà ‚âÉ Œ±",
    "name": "OrderDual.ofDual",
    "isProp": false,
    "doc":
    "`ofDual` is the identity function from the `OrderDual` of a linear order.  ",
    "depth": 4}],
  "count": 1029},
 {"noDocExamples": [],
  "kind": "¬´term[_]¬ª",
  "examples":
  [{"type": "‚àÄ {Œ± : Type u_1}, List.Sublist [] []",
    "name": "List.Sublist.slnil",
    "isProp": true,
    "doc": "the base case: `[]` is a sublist of `[]` ",
    "depth": 4},
   {"type": "‚àÄ {Œ± : Type u_1} {R : Œ± ‚Üí Œ± ‚Üí Prop}, List.Pairwise R []",
    "name": "List.Pairwise.nil",
    "isProp": true,
    "doc": "All elements of the empty list are vacuously pairwise related. ",
    "depth": 5},
   {"type": "Lean.Expr ‚Üí optParam (List (List ‚Ñï)) [] ‚Üí Lean.MetaM Lean.Expr",
    "name": "ToAdditive.reorderLambda",
    "isProp": false,
    "doc":
    "Reorder lambda-binders. See doc of `reorderAttr` for the interpretation of the argument ",
    "depth": 6}],
  "count": 1027},
 {"noDocExamples": [],
  "kind": "termIfThenElse",
  "examples":
  [{"type":
    "‚àÄ {Œ± : Sort u_2} (P : Prop) [inst : Decidable P] (a b : Œ±), (if x : P then a else b) = if P then a else b",
    "name": "dite_eq_ite",
    "isProp": true,
    "doc":
    "A `dite` whose results do not actually depend on the condition may be reduced to an `ite`. ",
    "depth": 12},
   {"type":
    "‚àÄ {Œ± : Sort u_1} (P : Prop) [inst : Decidable P] (x y : Œ±), (if ¬¨P then x else y) = if P then y else x",
    "name": "ite_not",
    "isProp": true,
    "doc":
    "Negation of the condition `P : Prop` in a `ite` is the same as swapping the branches. ",
    "depth": 12},
   {"type":
    "{Œ± : Sort u_1} ‚Üí\n  {c : Prop} ‚Üí\n    [inst : Decidable c] ‚Üí\n      {motive : Œ± ‚Üí Sort u_2} ‚Üí {t e : Œ±} ‚Üí (c ‚Üí motive t) ‚Üí (¬¨c ‚Üí motive e) ‚Üí motive (if c then t else e)",
    "name": "iteInduction",
    "isProp": false,
    "doc":
    "Split an if-then-else into cases. The `split` tactic is generally easier to use than this theorem. ",
    "depth": 14}],
  "count": 999},
 {"noDocExamples": [],
  "kind": "¬´term_‚ß∏_¬ª",
  "examples":
  [{"type":
    "{Œ± : Type u_1} ‚Üí [inst : Group Œ±] ‚Üí (s : Subgroup Œ±) ‚Üí Quotient (QuotientGroup.rightRel s) ‚âÉ Œ± ‚ß∏ s",
    "name": "QuotientGroup.quotientRightRelEquivQuotientLeftRel",
    "isProp": false,
    "doc": "Right cosets are in bijection with left cosets. ",
    "depth": 9},
   {"type": "{Œ± : Type u_1} ‚Üí [inst : Group Œ±] ‚Üí {s : Subgroup Œ±} ‚Üí Œ± ‚Üí Œ± ‚ß∏ s",
    "name": "QuotientGroup.mk",
    "isProp": false,
    "doc": "The canonical map from a group `Œ±` to the quotient `Œ± ‚ß∏ s`. ",
    "depth": 9},
   {"type":
    "{Œ± : Type u_1} ‚Üí [inst : AddGroup Œ±] ‚Üí {s : AddSubgroup Œ±} ‚Üí Œ± ‚Üí Œ± ‚ß∏ s",
    "name": "QuotientAddGroup.mk",
    "isProp": false,
    "doc": "The canonical map from an `AddGroup` `Œ±` to the quotient `Œ± ‚ß∏ s`.",
    "depth": 9}],
  "count": 973},
 {"noDocExamples": [],
  "kind": "¬´term_+·µ•_¬ª",
  "examples":
  [{"type":
    "‚àÄ {M : Type u_1} (c : M) (X : Type u_2) [inst : VAdd M X] [inst_1 : TopologicalSpace X] [h : ProperConstVAdd M X],\n  IsProperMap fun x => c +·µ• x",
    "name": "isProperMap_vadd",
    "isProp": true,
    "doc": "`(c +·µ• ¬∑)` is a proper map.",
    "depth": 14},
   {"type":
    "‚àÄ {M : Type u_1} {X : Type u_2} [inst : VAdd M X] [inst_1 : TopologicalSpace M] [inst_2 : TopologicalSpace X]\n  [self : ContinuousVAdd M X], Continuous fun p => p.fst +·µ• p.snd",
    "name": "ContinuousVAdd.continuous_vadd",
    "isProp": true,
    "doc": "The additive action `(+·µ•)` is continuous. ",
    "depth": 14},
   {"type":
    "‚àÄ {M : Type u_1} {X : Type u_2} [inst : VAdd M X] [inst_1 : TopologicalSpace X] [self : ProperConstVAdd M X] (c : M),\n  IsProperMap fun x => c +·µ• x",
    "name": "ProperConstVAdd.isProperMap_vadd",
    "isProp": true,
    "doc": "`(c +·µ• ¬∑)` is a proper map. ",
    "depth": 14}],
  "count": 947},
 {"noDocExamples": [],
  "kind": "Rat.term‚Ñö",
  "examples":
  [{"type": "Div ‚Ñö",
    "name": "Rat.instDivRat",
    "isProp": false,
    "doc":
    "Division of rational numbers. Note: `div a 0 = 0`.  Written with a separate function `Rat.div`\nas a wrapper so that the definition is not unfolded at `.instance` transparency. ",
    "depth": 1},
   {"type": "Denumerable ‚Ñö",
    "name": "Rat.instDenumerableRat",
    "isProp": false,
    "doc": "**Denumerability of the Rational Numbers** ",
    "depth": 1},
   {"type": "‚Ñö ‚Üí ‚Ñï+",
    "name": "Rat.pnatDen",
    "isProp": false,
    "doc": "Denominator as `‚Ñï+`. ",
    "depth": 1}],
  "count": 891},
 {"noDocExamples": [],
  "kind": "¬´term_À£¬ª",
  "examples":
  [{"type": "{n : ‚Ñï} ‚Üí Equiv.Perm (Fin n) ‚Üí ‚Ñ§À£",
    "name": "Equiv.Perm.signAux",
    "isProp": false,
    "doc":
    "`signAux œÉ` is the sign of a permutation on `Fin n`, defined as the parity of the number of\npairs `(x‚ÇÅ, x‚ÇÇ)` such that `x‚ÇÇ < x‚ÇÅ` but `œÉ x‚ÇÅ ‚â§ œÉ x‚ÇÇ` ",
    "depth": 4},
   {"type": "{M : Type u_6} ‚Üí [inst : Monoid M] ‚Üí MÀ£ ‚Üí Equiv.Perm M",
    "name": "Units.mulRight",
    "isProp": false,
    "doc":
    "Right multiplication by a unit of a monoid is a permutation of the underlying type. ",
    "depth": 5},
   {"type": "{Œ± : Type u} ‚Üí [inst : Monoid Œ±] ‚Üí Inv Œ±À£",
    "name": "Units.instInv",
    "isProp": false,
    "doc": "The inverse of a unit in a `Monoid`. ",
    "depth": 5}],
  "count": 875},
 {"noDocExamples": [],
  "kind": "¬´term‚®Ö_,_¬ª",
  "examples":
  [{"type":
    "‚àÄ {Œ± : Type u_1} {Œ≥ : Type u_3} {Œπ : Type u_4} {u : Œπ ‚Üí UniformSpace Œ≥},\n  UniformFun.uniformSpace Œ± Œ≥ = ‚®Ö (i : Œπ), UniformFun.uniformSpace Œ± Œ≥",
    "name": "UniformFun.iInf_eq",
    "isProp": true,
    "doc":
    "If `u` is a family of uniform structures on `Œ≥`, then\n`ùí∞(Œ±, Œ≥, (‚®Ö i, u i)) = ‚®Ö i, ùí∞(Œ±, Œ≥, u i)`. ",
    "depth": 12},
   {"type":
    "{Œ± : Type u_1} ‚Üí [inst : Group Œ±] ‚Üí {Œπ : Type u_2} ‚Üí (f : Œπ ‚Üí Subgroup Œ±) ‚Üí Œ± ‚ß∏ ‚®Ö (i : Œπ), f i ‚Ü™ (i : Œπ) ‚Üí Œ± ‚ß∏ f i",
    "name": "Subgroup.quotientiInfEmbedding",
    "isProp": false,
    "doc": "The natural embedding `Œ± ‚ß∏ (‚®Ö i, f i) ‚Ü™ Œ† i, Œ± ‚ß∏ f i`. ",
    "depth": 13},
   {"type":
    "{Œ± : Type u_1} ‚Üí [inst : AddGroup Œ±] ‚Üí {Œπ : Type u_2} ‚Üí (f : Œπ ‚Üí AddSubgroup Œ±) ‚Üí Œ± ‚ß∏ ‚®Ö (i : Œπ), f i ‚Ü™ (i : Œπ) ‚Üí Œ± ‚ß∏ f i",
    "name": "AddSubgroup.quotientiInfEmbedding",
    "isProp": false,
    "doc": "The natural embedding `Œ± ‚ß∏ (‚®Ö i, f i) ‚Ü™ Œ† i, Œ± ‚ß∏ f i`.",
    "depth": 13}],
  "count": 857},
 {"noDocExamples": [],
  "kind": "¬´term‚®Ü_,_¬ª",
  "examples":
  [{"type":
    "‚àÄ {Œπ : Sort u_1} {f : Œπ ‚Üí ‚Ñù}, (‚àÄ (i : Œπ), 0 ‚â§ f i) ‚Üí 0 ‚â§ ‚®Ü (i : Œπ), f i",
    "name": "Real.iSup_nonneg",
    "isProp": true,
    "doc":
    "As `0` is the default value for `Real.sSup` of the empty set or sets which are not bounded above, it\nsuffices to show that `f i` is nonnegative to show that `0 ‚â§ ‚®Ü i, f i`.\n",
    "depth": 9},
   {"type":
    "{Œ± : Type u_1} ‚Üí\n  {Œ≤ : Type u_2} ‚Üí {f : Œ± ‚Üí Filter Œ≤} ‚Üí ((i : Œ±) ‚Üí Filter.Realizer (f i)) ‚Üí Filter.Realizer (‚®Ü (i : Œ±), f i)",
    "name": "Filter.Realizer.iSup",
    "isProp": false,
    "doc": "Construct a realizer for indexed supremum ",
    "depth": 12},
   {"type":
    "‚àÄ {Œπ : Type v} {f : Œπ ‚Üí Cardinal.{w}},\n  BddAbove (Set.range f) ‚Üí Cardinal.lift.{u, w} (iSup f) = ‚®Ü (i : Œπ), Cardinal.lift.{u, w} (f i)",
    "name": "Cardinal.lift_iSup",
    "isProp": true,
    "doc": "The lift of a supremum is the supremum of the lifts. ",
    "depth": 13}],
  "count": 854},
 {"noDocExamples": [],
  "kind": "¬´term_\\_¬ª",
  "examples":
  [{"type": "‚àÄ {Œ± : Type u_4} [self : CoheytingAlgebra Œ±] (a : Œ±), ‚ä§ \\ a = Ôø¢a",
    "name": "CoheytingAlgebra.top_sdiff",
    "isProp": true,
    "doc": "`‚ä§ \\ a` is `Ôø¢a` ",
    "depth": 11},
   {"type": "‚àÄ {Œ± : Type u_4} [self : BiheytingAlgebra Œ±] (a : Œ±), ‚ä§ \\ a = Ôø¢a",
    "name": "BiheytingAlgebra.top_sdiff",
    "isProp": true,
    "doc": "`‚ä§ \\ a` is `Ôø¢a` ",
    "depth": 12},
   {"type":
    "{Œ± : Type u_1} ‚Üí\n  [inst : GeneralizedBooleanAlgebra Œ±] ‚Üí\n    [inst_1 : DecidableEq Œ±] ‚Üí {a : Œ±} ‚Üí Finpartition a ‚Üí (b : Œ±) ‚Üí Finpartition (a \\ b)",
    "name": "Finpartition.avoid",
    "isProp": false,
    "doc": "Restricts a finpartition to avoid a given element. ",
    "depth": 12}],
  "count": 854},
 {"noDocExamples": [],
  "kind": "¬´term_‚äï_¬ª",
  "examples":
  [{"type": "‚Ñï ‚âÉ ‚Ñï ‚äï PUnit.{u_1 + 1}",
    "name": "Equiv.natEquivNatSumPUnit",
    "isProp": false,
    "doc": "The set of natural numbers is equivalent to `‚Ñï ‚äï PUnit`. ",
    "depth": 3},
   {"type": "‚Ñ§ ‚âÉ ‚Ñï ‚äï ‚Ñï",
    "name": "Equiv.intEquivNatSumNat",
    "isProp": false,
    "doc": "The type of integer numbers is equivalent to `‚Ñï ‚äï ‚Ñï`. ",
    "depth": 3},
   {"type": "Bool ‚âÉ PUnit.{u + 1} ‚äï PUnit.{v + 1}",
    "name": "Equiv.boolEquivPUnitSumPUnit",
    "isProp": false,
    "doc": "`Bool` is equivalent the sum of two `PUnit`s. ",
    "depth": 3}],
  "count": 828},
 {"noDocExamples": [],
  "kind": "¬´term_√óÀ¢_¬ª",
  "examples":
  [{"type":
    "‚àÄ {Œ± : Type u_1} {f : Filter Œ±} {p : Œ± √ó Œ± ‚Üí Prop}, (‚àÄ·∂† (i : Œ± √ó Œ±) in f √óÀ¢ f, p i) ‚Üí ‚àÄ·∂† (i : Œ±) in f, p (i, i)",
    "name": "Filter.Eventually.diag_of_prod",
    "isProp": true,
    "doc":
    "A fact that is eventually true about all pairs `l √óÀ¢ l` is eventually true about\nall diagonal pairs `(i, i)` ",
    "depth": 12},
   {"type":
    "{Œ± : Type u_1} ‚Üí {Œ≤ : Type u_2} ‚Üí (s : Set Œ±) ‚Üí (t : Set Œ≤) ‚Üí ‚Üë(s √óÀ¢ t) ‚âÉ ‚Üës √ó ‚Üët",
    "name": "Equiv.Set.prod",
    "isProp": false,
    "doc":
    "The set product of two sets is equivalent to the type product of their coercions to types. ",
    "depth": 14},
   {"type":
    "‚àÄ {Œ± : Type u_1} {Ixx : Œ± ‚Üí Œ± ‚Üí Set Œ±} {l‚ÇÅ : Filter Œ±} {l‚ÇÇ : outParam (Filter Œ±)}\n  [self : Filter.TendstoIxxClass Ixx l‚ÇÅ l‚ÇÇ], Filter.Tendsto (fun p => Ixx p.fst p.snd) (l‚ÇÅ √óÀ¢ l‚ÇÅ) (Filter.smallSets l‚ÇÇ)",
    "name": "Filter.TendstoIxxClass.tendsto_Ixx",
    "isProp": true,
    "doc":
    "`Function.uncurry Ixx` tends to `l‚ÇÇ.smallSets` along `l‚ÇÅ √óÀ¢ l‚ÇÅ`. In other words, for any\n`s ‚àà l‚ÇÇ` there exists `t ‚àà l‚ÇÅ` such that `Ixx x y ‚äÜ s` whenever `x ‚àà t` and `y ‚àà t`.\n\nUse lemmas like `Filter.Tendsto.Icc` instead. ",
    "depth": 14}],
  "count": 815},
 {"noDocExamples": [],
  "kind": "¬´term_‚Üí‚Çê[_]_¬ª",
  "examples":
  [{"type": "‚Ñù ‚Üí‚Çê[‚Ñù] ‚ÑÇ",
    "name": "Complex.ofRealAm",
    "isProp": false,
    "doc":
    "`‚Ñù`-algebra morphism version of the canonical embedding of `‚Ñù` in `‚ÑÇ`. ",
    "depth": 8},
   {"type": "‚ÑÇ ‚Üí‚Çê[‚Ñù] Quaternion ‚Ñù",
    "name": "Quaternion.ofComplex",
    "isProp": false,
    "doc": "Coercion `‚ÑÇ ‚Üí‚Çê[‚Ñù] ‚Ñç` as an algebra homomorphism. ",
    "depth": 9},
   {"type":
    "{R : Type u_1} ‚Üí [inst : CommSemiring R] ‚Üí Polynomial R ‚Üí‚Çê[R] LaurentPolynomial R",
    "name": "Polynomial.toLaurentAlg",
    "isProp": false,
    "doc":
    "The `R`-algebra map, taking a polynomial with coefficients in `R` to a Laurent polynomial\nwith coefficients in `R`. ",
    "depth": 12}],
  "count": 803},
 {"noDocExamples": [],
  "kind": "¬´term_::_¬ª",
  "examples":
  [{"type": "‚àÄ {Œ± : Type u} {a : Œ±} (as : List Œ±), List.Mem a (a :: as)",
    "name": "List.Mem.head",
    "isProp": true,
    "doc": "The head of a list is a member: `a ‚àà a :: as`. ",
    "depth": 7},
   {"type":
    "‚àÄ {Œ± : Type u} [inst : LT Œ±] (b : Œ±) (bs : List Œ±), List.lt [] (b :: bs)",
    "name": "List.lt.nil",
    "isProp": true,
    "doc": "`[]` is the smallest element in the order. ",
    "depth": 8},
   {"type":
    "‚àÄ {Œ± : Type u_1} {l‚ÇÅ l‚ÇÇ : List Œ±} (a : Œ±), List.Sublist l‚ÇÅ l‚ÇÇ ‚Üí List.Sublist l‚ÇÅ (a :: l‚ÇÇ)",
    "name": "List.Sublist.cons",
    "isProp": true,
    "doc":
    "If `l‚ÇÅ` is a subsequence of `l‚ÇÇ`, then it is also a subsequence of `a :: l‚ÇÇ`. ",
    "depth": 9}],
  "count": 800},
 {"noDocExamples": [],
  "kind": "Filter.¬´term_=·∂†[_]_¬ª",
  "examples":
  [{"type":
    "‚àÄ {Œ± : Type u_1} {m : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {f g : MeasureTheory.SimpleFunc Œ± ENNReal},\n  ‚Üëf =·∂†[MeasureTheory.Measure.ae Œº] ‚Üëg ‚Üí MeasureTheory.SimpleFunc.lintegral f Œº = MeasureTheory.SimpleFunc.lintegral g Œº",
    "name": "MeasureTheory.SimpleFunc.lintegral_congr",
    "isProp": true,
    "doc":
    "If two simple functions are equal a.e., then their `lintegral`s are equal. ",
    "depth": 12},
   {"type":
    "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {l : Filter Œ±} {f g : Œ± ‚Üí Œ≤}, f =·∂†[l] g ‚Üí ‚Üëf = ‚Üëg",
    "name": "Filter.EventuallyEq.germ_eq",
    "isProp": true,
    "doc": "**Alias** of the reverse direction of `Filter.Germ.coe_eq`.",
    "depth": 12},
   {"type":
    "‚àÄ {Œ± : Type u} {Œ≤ : Type v} {m‚ÇÅ m‚ÇÇ : Œ± ‚Üí Œ≤} {f : Filter Œ±}, m‚ÇÅ =·∂†[f] m‚ÇÇ ‚Üí Filter.map m‚ÇÅ f = Filter.map m‚ÇÇ f",
    "name": "Filter.map_congr",
    "isProp": true,
    "doc":
    "If functions `m‚ÇÅ` and `m‚ÇÇ` are eventually equal at a filter `f`, then\nthey map this filter to the same filter. ",
    "depth": 12}],
  "count": 765},
 {"noDocExamples": [],
  "kind": "¬´term‚Ñï‚àû¬ª",
  "examples":
  [{"type": "‚Ñï‚àû ‚Üí PartENat",
    "name": "PartENat.ofENat",
    "isProp": false,
    "doc": "Coercion from `‚Ñï‚àû` to `PartENat`. ",
    "depth": 1},
   {"type": "‚Ñï‚àû ‚Üí ENNReal",
    "name": "ENat.toENNReal",
    "isProp": false,
    "doc": "Coercion from `‚Ñï‚àû` to `‚Ñù‚â•0‚àû`. ",
    "depth": 1},
   {"type": "PartENat ‚âÉ ‚Ñï‚àû",
    "name": "PartENat.withTopEquiv",
    "isProp": false,
    "doc":
    "`Equiv` between `PartENat` and `‚Ñï‚àû` (for the order isomorphism see\n`withTopOrderIso`). ",
    "depth": 2}],
  "count": 754},
 {"noDocExamples": [],
  "kind": "¬´term_√ó__1¬ª",
  "examples":
  [{"type": "(n : ‚Ñï) ‚Üí Finset ((_ : Fin n) √ó Fin n)",
    "name": "Equiv.Perm.finPairsLT",
    "isProp": false,
    "doc": "set of all pairs (‚ü®a, b‚ü© : Œ£ a : fin n, fin n) such that b < a ",
    "depth": 5},
   {"type": "{Œ± : Type u_7} ‚Üí {Œ≤ : Type u_8} ‚Üí Œ± √ó Œ≤ ‚Üí (_ : Œ±) √ó Œ≤",
    "name": "Prod.toSigma",
    "isProp": false,
    "doc": "Convert a product type to a Œ£-type. ",
    "depth": 5},
   {"type": "(Œ± : Type u_1) ‚Üí (_ : Œ±) √ó PUnit.{u_2 + 1} ‚âÉ Œ±",
    "name": "Equiv.sigmaPUnit",
    "isProp": false,
    "doc":
    "`PUnit` is a right identity for dependent type product up to an equivalence. ",
    "depth": 5}],
  "count": 735},
 {"noDocExamples": [],
  "kind": "Filter.¬´term‚àÄ·∂†_In_,_¬ª",
  "examples":
  [{"type": "‚àÄ·∂† (x : ‚Ñù) in residual ‚Ñù, Liouville x",
    "name": "eventually_residual_liouville",
    "isProp": true,
    "doc": "The set of Liouville numbers is a residual set. ",
    "depth": 5},
   {"type":
    "‚àÄ {Œ± : Type u} {f : Ultrafilter Œ±} {p : Œ± ‚Üí Prop}, (‚àÉ·∂† (x : Œ±) in ‚Üëf, p x) ‚Üí ‚àÄ·∂† (x : Œ±) in ‚Üëf, p x",
    "name": "Filter.Frequently.eventually",
    "isProp": true,
    "doc":
    "**Alias** of the forward direction of `Ultrafilter.frequently_iff_eventually`.",
    "depth": 8},
   {"type":
    "‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {p : Œ± ‚Üí Prop} {a : Œ±}, (‚àÄ·∂† (y : Œ±) in nhds a, p y) ‚Üí p a",
    "name": "Filter.Eventually.self_of_nhds",
    "isProp": true,
    "doc":
    "If a predicate is true in a neighborhood of `a`, then it is true for `a`. ",
    "depth": 9}],
  "count": 714},
 {"noDocExamples": [],
  "kind": "¬´term|___|¬ª",
  "examples":
  [{"type":
    "‚àÄ (c : ‚ÑÇ) (R : ‚Ñù), Set.range (circleMap c R) = Metric.sphere c |R|",
    "name": "range_circleMap",
    "isProp": true,
    "doc":
    "The range of `circleMap c R` is the circle with center `c` and radius `|R|`. ",
    "depth": 11},
   {"type": "‚àÄ (x : ‚Ñù), 0 < x ‚Üí x ‚â§ 1 ‚Üí |Real.log x * x| < 1",
    "name": "Real.abs_log_mul_self_lt",
    "isProp": true,
    "doc": "Bound for `|log x * x|` in the interval `(0, 1]`. ",
    "depth": 12},
   {"type":
    "‚àÄ {Œ± : Type u_1} {l : Filter Œ±} {f : Œ± ‚Üí ‚Ñù},\n  ((fun x => rexp (f x)) =Œò[l] fun x => 1) ‚Üî Filter.IsBoundedUnder (fun x x_1 => x ‚â§ x_1) l fun x => |f x|",
    "name": "Real.isTheta_exp_comp_one",
    "isProp": true,
    "doc":
    "`Real.exp (f x)` is bounded away from zero and infinity along a filter `l` if and only if\n`|f x|` is bounded from above along this filter. ",
    "depth": 13}],
  "count": 673},
 {"noDocExamples": [],
  "kind": "¬´term‚Ñï+¬ª",
  "examples":
  [{"type": "‚Ñö ‚Üí ‚Ñï+",
    "name": "Rat.pnatDen",
    "isProp": false,
    "doc": "Denominator as `‚Ñï+`. ",
    "depth": 1},
   {"type": "‚Ñï+ ‚Üí Type",
    "name": "LucasLehmer.X",
    "isProp": false,
    "doc": "We construct the ring `X q` as ‚Ñ§/q‚Ñ§ + ‚àö3 ‚Ñ§/q‚Ñ§. ",
    "depth": 1},
   {"type": "‚Ñï ‚Üí ‚Ñï+",
    "name": "LucasLehmer.q",
    "isProp": false,
    "doc":
    "`q` is defined as the minimum factor of `mersenne p`, bundled as an `‚Ñï+`. ",
    "depth": 1}],
  "count": 644},
 {"noDocExamples": [],
  "kind": "¬´term_·µÉ·µí·µñ¬ª",
  "examples":
  [{"type": "{Œ± : Type u_1} ‚Üí Œ± ‚âÉ Œ±·µÉ·µí·µñ",
    "name": "AddOpposite.opEquiv",
    "isProp": false,
    "doc": "The canonical bijection between `Œ±` and `Œ±·µÉ·µí·µñ`.",
    "depth": 3},
   {"type": "{Œ± : Type u_1} ‚Üí Œ± ‚Üí Œ±·µÉ·µí·µñ",
    "name": "AddOpposite.op",
    "isProp": false,
    "doc": "The element of `Œ±·µÉ·µí·µñ` that represents `x : Œ±`.",
    "depth": 3},
   {"type": "{Œ± : Type u_1} ‚Üí Œ±·µÉ·µí·µñ ‚Üí Œ±",
    "name": "AddOpposite.unop",
    "isProp": false,
    "doc": "The element of `Œ±` represented by `x : Œ±·µÉ·µí·µñ`.",
    "depth": 3}],
  "count": 592},
 {"noDocExamples": [],
  "kind": "¬´term_++_¬ª",
  "examples":
  [{"type":
    "‚àÄ {a b : ‚Ñï}, Nat.coprime a b ‚Üí Nat.factors (a * b) ~ Nat.factors a ++ Nat.factors b",
    "name": "Nat.perm_factors_mul_of_coprime",
    "isProp": true,
    "doc":
    "For coprime `a` and `b`, the prime factors of `a * b` are the union of those of `a` and `b` ",
    "depth": 12},
   {"type":
    "‚àÄ {a b : ‚Ñï}, a ‚â† 0 ‚Üí b ‚â† 0 ‚Üí Nat.factors (a * b) ~ Nat.factors a ++ Nat.factors b",
    "name": "Nat.perm_factors_mul",
    "isProp": true,
    "doc":
    "For positive `a` and `b`, the prime factors of `a * b` are the union of those of `a` and `b` ",
    "depth": 13},
   {"type":
    "‚àÄ {Œ± : Type u} {l‚ÇÅ l‚ÇÇ : List Œ±} {n : ‚Ñï}, List.drop n (l‚ÇÅ ++ l‚ÇÇ) = List.drop n l‚ÇÅ ++ List.drop (n - List.length l‚ÇÅ) l‚ÇÇ",
    "name": "List.drop_append_eq_append_drop",
    "isProp": true,
    "doc":
    "Dropping the elements up to `n` in `l‚ÇÅ ++ l‚ÇÇ` is the same as dropping the elements up to `n`\nin `l‚ÇÅ`, dropping the elements up to `n - l‚ÇÅ.length` in `l‚ÇÇ`, and appending them. ",
    "depth": 14}],
  "count": 576},
 {"noDocExamples": [],
  "kind": "¬´term_‚âÉ‚Çó[_]_¬ª",
  "examples":
  [{"type": "‚ÑÇ ‚âÉ‚Çó[‚Ñù] ‚Ñù √ó ‚Ñù",
    "name": "Complex.equivRealProdLm",
    "isProp": false,
    "doc": "The natural `LinearEquiv` from `‚ÑÇ` to `‚Ñù √ó ‚Ñù`. ",
    "depth": 14},
   {"type": "Nonempty (‚ÑÇ ‚âÉ‚Çó[‚Ñö] ‚Ñù)",
    "name": "Complex.nonempty_linearEquiv_real",
    "isProp": true,
    "doc":
    "`‚ÑÇ` and `‚Ñù` are isomorphic as vector spaces over `‚Ñö`, or equivalently,\nas additive groups. ",
    "depth": 15},
   {"type":
    "{cd : Fin 2 ‚Üí ‚Ñ§} ‚Üí IsCoprime (cd 0) (cd 1) ‚Üí Matrix (Fin 2) (Fin 2) ‚Ñù ‚âÉ‚Çó[‚Ñù] Matrix (Fin 2) (Fin 2) ‚Ñù",
    "name": "ModularGroup.lcRow0Extend",
    "isProp": false,
    "doc":
    "Linear map sending the matrix [a, b; c, d] to the matrix [ac‚ÇÄ + bd‚ÇÄ, - ad‚ÇÄ + bc‚ÇÄ; c, d], for\nsome fixed `(c‚ÇÄ, d‚ÇÄ)`. ",
    "depth": 16}],
  "count": 559},
 {"noDocExamples": [],
  "kind": "¬´term_‚âÉo_¬ª",
  "examples":
  [{"type": "‚Ñù ‚âÉo ‚Ñù",
    "name": "Real.sinhOrderIso",
    "isProp": false,
    "doc": "`Real.sinh` as an `OrderIso`. ",
    "depth": 4},
   {"type": "EReal ‚âÉo EReal·µí·µà",
    "name": "EReal.negOrderIso",
    "isProp": false,
    "doc": "Negation as an order reversing isomorphism on `EReal`. ",
    "depth": 5},
   {"type": "(Œ± : Type u_6) ‚Üí [inst : LE Œ±] ‚Üí Œ± ‚âÉo Œ±",
    "name": "OrderIso.refl",
    "isProp": false,
    "doc": "Identity order isomorphism. ",
    "depth": 6}],
  "count": 559},
 {"noDocExamples": [],
  "kind": "¬´termŒ†‚ÇÄ_,_¬ª",
  "examples":
  [{"type":
    "{Œπ : Type u_1} ‚Üí {M : Type u_3} ‚Üí [inst : Zero M] ‚Üí (Œπ ‚Üí‚ÇÄ M) ‚Üí Œ†‚ÇÄ (x : Œπ), M",
    "name": "Finsupp.toDFinsupp",
    "isProp": false,
    "doc": "Interpret a `Finsupp` as a homogenous `DFinsupp`. ",
    "depth": 7},
   {"type":
    "{Œπ : Type u_1} ‚Üí {Œ± : Œπ ‚Üí Type u_2} ‚Üí [inst : (i : Œπ) ‚Üí Zero (Œ± i)] ‚Üí (Œ†‚ÇÄ (i : Œπ), Œ± i) ‚Üí Œ†‚ÇÄ (i : Œπ), Finset (Œ± i)",
    "name": "DFinsupp.singleton",
    "isProp": false,
    "doc": "Pointwise `Finset.singleton` bundled as a `DFinsupp`. ",
    "depth": 9},
   {"type":
    "{Œπ : Type u} ‚Üí {Œ≤ : Œπ ‚Üí Type v} ‚Üí [inst : (i : Œπ) ‚Üí Zero (Œ≤ i)] ‚Üí CoeFun (Œ†‚ÇÄ (i : Œπ), Œ≤ i) fun x => (i : Œπ) ‚Üí Œ≤ i",
    "name": "DFinsupp.instCoeFunDFinsuppForAll",
    "isProp": false,
    "doc":
    "Helper instance for when there are too many metavariables to apply `FunLike.coeFunForall`\ndirectly. ",
    "depth": 9}],
  "count": 545},
 {"noDocExamples": [],
  "kind": "Set.¬´term‚ãÇ_,_¬ª",
  "examples":
  [{"type":
    "‚àÄ {Œπ : Type u} {f : Œπ ‚Üí Ordinal.{max u v} ‚Üí Ordinal.{max u v}},\n  (‚àÄ (i : Œπ), Ordinal.IsNormal (f i)) ‚Üí Ordinal.derivFamily f = Ordinal.enumOrd (‚ãÇ (i : Œπ), Function.fixedPoints (f i))",
    "name": "Ordinal.derivFamily_eq_enumOrd",
    "isProp": true,
    "doc":
    "For a family of normal functions, `Ordinal.derivFamily` enumerates the common fixed points. ",
    "depth": 9},
   {"type":
    "‚àÄ {Œ± : Type u_1} {Œπ : Type u_4} [inst : TopologicalSpace Œ±] [inst_1 : Encodable Œπ] {s : Œπ ‚Üí Set Œ±},\n  (‚àÄ (i : Œπ), IsGŒ¥ (s i)) ‚Üí IsGŒ¥ (‚ãÇ (i : Œπ), s i)",
    "name": "isGŒ¥_iInter",
    "isProp": true,
    "doc": "The intersection of an encodable family of GŒ¥ sets is a GŒ¥ set. ",
    "depth": 10},
   {"type":
    "‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : BaireSpace Œ±] {f : ‚Ñï ‚Üí Set Œ±},\n  (‚àÄ (n : ‚Ñï), IsOpen (f n)) ‚Üí (‚àÄ (n : ‚Ñï), Dense (f n)) ‚Üí Dense (‚ãÇ (n : ‚Ñï), f n)",
    "name": "dense_iInter_of_open_nat",
    "isProp": true,
    "doc": "Definition of a Baire space. ",
    "depth": 10}],
  "count": 520},
 {"noDocExamples": [],
  "kind": "CategoryTheory.¬´term_‚âå_¬ª",
  "examples":
  [{"type": "DistLatCat ‚âå DistLatCat",
    "name": "DistLatCat.dualEquiv",
    "isProp": false,
    "doc":
    "The equivalence between `DistLatCat` and itself induced by `OrderDual` both ways. ",
    "depth": 4},
   {"type": "SemilatSupCat ‚âå SemilatInfCat",
    "name": "SemilatSupCatEquivSemilatInfCat",
    "isProp": false,
    "doc":
    "The equivalence between `SemilatSupCat` and `SemilatInfCat` induced by `OrderDual` both ways. ",
    "depth": 4},
   {"type": "TwoP ‚âå TwoP",
    "name": "TwoP.swapEquiv",
    "isProp": false,
    "doc":
    "The equivalence between `TwoP` and itself induced by `Prod.swap` both ways. ",
    "depth": 4}],
  "count": 514},
 {"noDocExamples": [],
  "kind": "¬´term‚àë'_,_¬ª",
  "examples":
  [{"type":
    "‚àÄ {Œ± : Type u_1} {f : Œ± ‚Üí ENNReal}, ‚àë' (i : Œ±), f i ‚â† ‚ä§ ‚Üí Set.Countable (Function.support f)",
    "name": "Summable.countable_support_ennreal",
    "isProp": true,
    "doc": "Finitely summable non-negative functions have countable support ",
    "depth": 12},
   {"type": "‚àÄ {s : ‚ÑÇ}, 1 < s.re ‚Üí riemannZeta s = ‚àë' (n : ‚Ñï), 1 / ‚Üën ^ s",
    "name": "zeta_eq_tsum_one_div_nat_cpow",
    "isProp": true,
    "doc":
    "Alternate formulation of `zeta_eq_tsum_one_div_nat_add_one_cpow` without the `+ 1`, using the\nfact that for `s ‚â† 0` we define `0 ^ s = 0`.  ",
    "depth": 13},
   {"type":
    "‚àÄ {s : ‚ÑÇ}, 1 < s.re ‚Üí riemannZeta s = ‚àë' (n : ‚Ñï), 1 / (‚Üën + 1) ^ s",
    "name": "zeta_eq_tsum_one_div_nat_add_one_cpow",
    "isProp": true,
    "doc":
    "The Riemann zeta function agrees with the naive Dirichlet-series definition when the latter\nconverges. (Note that this is false without the assumption: when `re s ‚â§ 1` the sum is divergent,\nand we use a different definition to obtain the analytic continuation to all `s`.) ",
    "depth": 14}],
  "count": 495},
 {"noDocExamples": [],
  "kind": "¬´term‚Äñ_‚Äñ‚Çä¬ª",
  "examples":
  [{"type":
    "‚àÄ {E : Type u_6} [inst : SeminormedAddGroup E] (a b : E), nndist a b = ‚Äña - b‚Äñ‚Çä",
    "name": "nndist_eq_nnnorm",
    "isProp": true,
    "doc": "**Alias** of `nndist_eq_nnnorm_sub`.",
    "depth": 14},
   {"type":
    "‚àÄ {E : Type u_6} [inst : SeminormedAddGroup E] (a b : E), ‚Äñb‚Äñ‚Çä ‚â§ ‚Äña‚Äñ‚Çä + ‚Äña - b‚Äñ‚Çä",
    "name": "nnnorm_le_insert",
    "isProp": true,
    "doc": "**Alias** of `nnnorm_le_nnnorm_add_nnnorm_sub`.",
    "depth": 15},
   {"type":
    "‚àÄ {Œπ : Type u_1} {E : Type u_3} [inst : SeminormedAddCommGroup E] {f : Œπ ‚Üí E},\n  (Summable fun i => ‚Äñf i‚Äñ‚Çä) ‚Üí ‚Äñ‚àë' (i : Œπ), f i‚Äñ‚Çä ‚â§ ‚àë' (i : Œπ), ‚Äñf i‚Äñ‚Çä",
    "name": "nnnorm_tsum_le",
    "isProp": true,
    "doc":
    "If `‚àë' i, ‚Äñf i‚Äñ‚Çä` is summable, then `‚Äñ‚àë' i, f i‚Äñ‚Çä ‚â§ ‚àë' i, ‚Äñf i‚Äñ‚Çä`. Note that\nwe do not assume that `‚àë' i, f i` is summable, and it might not be the case if `Œ±` is not a complete\nspace. ",
    "depth": 15}],
  "count": 490},
 {"noDocExamples": [],
  "kind": "¬´term_‚âÉ‚Çê[_]_¬ª",
  "examples":
  [{"type": "‚ÑÇ ‚âÉ‚Çê[‚Ñù] ‚ÑÇ",
    "name": "Complex.conjAe",
    "isProp": false,
    "doc":
    "`‚Ñù`-algebra isomorphism version of the complex conjugation function from `‚ÑÇ` to `‚ÑÇ` ",
    "depth": 8},
   {"type":
    "(k : Type u) ‚Üí [inst : Field k] ‚Üí AlgebraicClosure k ‚âÉ‚Çê[k] AlgebraicClosureAux k",
    "name": "AlgebraicClosure.algEquivAlgebraicClosureAux",
    "isProp": false,
    "doc":
    "The equivalence between `AlgebraicClosure` and `AlgebraicClosureAux`, which we use to transfer\nproperties of `AlgebraicClosureAux` to `AlgebraicClosure` ",
    "depth": 11},
   {"type":
    "{R : Type u_2} ‚Üí [inst : CommSemiring R] ‚Üí LaurentPolynomial R ‚âÉ‚Çê[R] LaurentPolynomial R",
    "name": "LaurentPolynomial.invert",
    "isProp": false,
    "doc": "The map which substitutes `T ‚Ü¶ T‚Åª¬π` into a Laurent polynomial. ",
    "depth": 12}],
  "count": 479},
 {"noDocExamples": [],
  "kind": "¬´term_%_¬ª",
  "examples":
  [{"type": "‚àÄ {n a : ‚Ñï}, Even n ‚Üí Even a ‚Üí Even (n % a)",
    "name": "Even.mod_even",
    "isProp": true,
    "doc": "If `n` is even and `a` is even, then `n % a` is even. ",
    "depth": 11},
   {"type": "‚àÄ {n a : ‚Ñï}, Odd n ‚Üí Even a ‚Üí Odd (n % a)",
    "name": "Odd.mod_even",
    "isProp": true,
    "doc": "If `n` is odd and `a` is even, then `n % a` is odd. ",
    "depth": 11},
   {"type": "‚àÄ {n : ‚Ñï}, n % 4 = 1 ‚Üí (-1) ^ (n / 2) = 1",
    "name": "ZMod.neg_one_pow_div_two_of_one_mod_four",
    "isProp": true,
    "doc": "If `n % 4 = 1`, then `(-1)^(n/2) = 1`. ",
    "depth": 11}],
  "count": 477},
 {"noDocExamples": [],
  "kind": "¬´term_‚âà_¬ª",
  "examples":
  [{"type":
    "‚àÄ (G : SetTheory.PGame) [inst : SetTheory.PGame.Impartial G], G ‚âà SetTheory.PGame.nim (SetTheory.PGame.grundyValue G)",
    "name": "SetTheory.PGame.equiv_nim_grundyValue",
    "isProp": true,
    "doc":
    "The Sprague-Grundy theorem which states that every impartial game is equivalent to a game of\nnim, namely the game of nim corresponding to the games Grundy value ",
    "depth": 7},
   {"type":
    "‚àÄ {x y : SetTheory.PGame}, SetTheory.PGame.Relabelling x y ‚Üí x ‚âà y",
    "name": "SetTheory.PGame.Relabelling.equiv",
    "isProp": true,
    "doc": "A relabelling lets us prove equivalence of games. ",
    "depth": 8},
   {"type": "‚àÄ (x : SetTheory.PGame), 0 * x ‚âà 0",
    "name": "SetTheory.PGame.zero_mul_equiv",
    "isProp": true,
    "doc": "`0 * x` is equivalent to `0`. ",
    "depth": 9}],
  "count": 458},
 {"noDocExamples": [],
  "kind": "CategoryTheory.¬´term_‚ä£_¬ª",
  "examples":
  [{"type": "pointedToBipointedSnd ‚ä£ bipointedToPointedSnd",
    "name": "pointedToBipointedSndBipointedToPointedSndAdjunction",
    "isProp": false,
    "doc":
    "The free/forgetful adjunction between `PointedToBipointed_snd` and `BipointedToPointed_snd`.\n",
    "depth": 6},
   {"type": "TopCat.discrete ‚ä£ CategoryTheory.forget TopCat",
    "name": "TopCat.adj‚ÇÅ",
    "isProp": false,
    "doc":
    "Equipping a type with the discrete topology is left adjoint to the forgetful functor\n`Top ‚•§ Type`. ",
    "depth": 6},
   {"type": "Compactum.free ‚ä£ Compactum.forget",
    "name": "Compactum.adj",
    "isProp": false,
    "doc": "The adjunction between `free` and `forget`. ",
    "depth": 6}],
  "count": 447},
 {"noDocExamples": [],
  "kind": "¬´term_‚âÉ+_¬ª",
  "examples":
  [{"type": "‚ÑÇ ‚âÉ+ ‚Ñù √ó ‚Ñù",
    "name": "Complex.equivRealProdAddHom",
    "isProp": false,
    "doc": "The natural `AddEquiv` from `‚ÑÇ` to `‚Ñù √ó ‚Ñù`. ",
    "depth": 5},
   {"type": "{Œ± : Type u} ‚Üí [inst : Add Œ±] ‚Üí Œ± ‚âÉ+ Œ±·µê·µí·µñ",
    "name": "MulOpposite.opAddEquiv",
    "isProp": false,
    "doc": "The function `MulOpposite.op` is an additive equivalence. ",
    "depth": 6},
   {"type": "(M : Type u_12) ‚Üí [inst : Add M] ‚Üí M ‚âÉ+ M",
    "name": "AddEquiv.refl",
    "isProp": false,
    "doc": "The identity map is an additive isomorphism.",
    "depth": 6}],
  "count": 446},
 {"noDocExamples": [],
  "kind": "¬´term_>_¬ª",
  "examples":
  [{"type":
    "‚àÄ (R : Type u_1) [inst : CommRing R] {P : Prop},\n  (‚àÄ (p : ‚Ñï), p > 0 ‚Üí MixedCharZero R p ‚Üí P) ‚Üî ‚àÄ (p : ‚Ñï), Nat.Prime p ‚Üí MixedCharZero R p ‚Üí P",
    "name": "MixedCharZero.reduce_to_p_prime",
    "isProp": true,
    "doc":
    "Reduction to `p` prime: When proving any statement `P` about mixed characteristic rings we\ncan always assume that `p` is prime.\n",
    "depth": 11},
   {"type":
    "‚àÄ (R : Type u_1) [inst : CommRing R] [inst_1 : CharZero R], IsEmpty (Algebra ‚Ñö R) ‚Üî ‚àÉ p, p > 0 ‚àß MixedCharZero R p",
    "name": "isEmpty_algebraRat_iff_mixedCharZero",
    "isProp": true,
    "doc":
    "A ring of characteristic zero is not a `‚Ñö`-algebra iff it has mixed characteristic for some `p`.\n",
    "depth": 12},
   {"type":
    "‚àÄ (b o : Ordinal.{u_1}), List.Sorted (fun x x_1 => x > x_1) (List.map Prod.fst (Ordinal.CNF b o))",
    "name": "Ordinal.CNF_sorted",
    "isProp": true,
    "doc": "The exponents of the Cantor normal form are decreasing. ",
    "depth": 12}],
  "count": 438},
 {"noDocExamples": [],
  "kind": "¬´term_‚âÉ+*_¬ª",
  "examples":
  [{"type": "FreeRing PEmpty.{u + 1} ‚âÉ+* ‚Ñ§",
    "name": "freeRingPemptyEquivInt",
    "isProp": false,
    "doc": "The free ring on the empty type is isomorphic to `‚Ñ§`. ",
    "depth": 9},
   {"type": "(R : Type u_4) ‚Üí [inst : Mul R] ‚Üí [inst_1 : Add R] ‚Üí R ‚âÉ+* R",
    "name": "RingEquiv.refl",
    "isProp": false,
    "doc": "The identity map is a ring isomorphism. ",
    "depth": 9},
   {"type":
    "{Œ± : Type u} ‚Üí [inst : NonUnitalNonAssocSemiring Œ±] ‚Üí ULift.{u_1, u} Œ± ‚âÉ+* Œ±",
    "name": "ULift.ringEquiv",
    "isProp": false,
    "doc": "The ring equivalence between `ULift Œ±` and `Œ±`.",
    "depth": 9}],
  "count": 438},
 {"noDocExamples": [],
  "kind": "¬´term_‚âÉ*_¬ª",
  "examples":
  [{"type": "(M : Type u_12) ‚Üí [inst : Mul M] ‚Üí M ‚âÉ* M",
    "name": "MulEquiv.refl",
    "isProp": false,
    "doc": "The identity map is a multiplicative isomorphism. ",
    "depth": 6},
   {"type": "{Œ± : Type u} ‚Üí [inst : Mul Œ±] ‚Üí Œ± ‚âÉ* Œ±·µÉ·µí·µñ",
    "name": "AddOpposite.opMulEquiv",
    "isProp": false,
    "doc": "The function `AddOpposite.op` is a multiplicative equivalence. ",
    "depth": 6},
   {"type": "{Œ± : Type u} ‚Üí [inst : Mul Œ±] ‚Üí ULift.{u_2, u} Œ± ‚âÉ* Œ±",
    "name": "MulEquiv.ulift",
    "isProp": false,
    "doc": "The multiplicative equivalence between `ULift Œ±` and `Œ±`.\n",
    "depth": 7}],
  "count": 433},
 {"noDocExamples": [],
  "kind": "MeasureTheory.¬´term‚àÄ·µê_‚àÇ_,_¬ª",
  "examples":
  [{"type":
    "‚àÄ {Œ± : Type u_1} {m0 : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {s t : Œ± ‚Üí Prop},\n  s =·∂†[MeasureTheory.Measure.ae Œº] t ‚Üí\n    ‚àÄ {p : Œ± ‚Üí Prop},\n      (‚àÄ·µê (x : Œ±) ‚àÇMeasureTheory.Measure.restrict Œº s, p x) ‚Üí ‚àÄ·µê (x : Œ±) ‚àÇMeasureTheory.Measure.restrict Œº t, p x",
    "name": "MeasureTheory.ae_restrict_of_ae_eq_of_ae_restrict",
    "isProp": true,
    "doc":
    "If two measurable sets are ae_eq then any proposition that is almost everywhere true on one\nis almost everywhere true on the other ",
    "depth": 14},
   {"type":
    "‚àÄ {Œ± : Type u_1} {m0 : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {s t : Œ± ‚Üí Prop},\n  s =·∂†[MeasureTheory.Measure.ae Œº] t ‚Üí\n    ‚àÄ {p : Œ± ‚Üí Prop},\n      (‚àÄ·µê (x : Œ±) ‚àÇMeasureTheory.Measure.restrict Œº s, p x) ‚Üî ‚àÄ·µê (x : Œ±) ‚àÇMeasureTheory.Measure.restrict Œº t, p x",
    "name": "MeasureTheory.ae_restrict_congr_set",
    "isProp": true,
    "doc":
    "If two measurable sets are ae_eq then any proposition that is almost everywhere true on one\nis almost everywhere true on the other ",
    "depth": 15},
   {"type":
    "‚àÄ {Œ± : Type u_1} {m0 : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {s : ‚Ñï ‚Üí Set Œ±},\n  ‚àë' (i : ‚Ñï), ‚Üë‚ÜëŒº (s i) ‚â† ‚ä§ ‚Üí ‚àÄ·µê (x : Œ±) ‚àÇŒº, ‚àÄ·∂† (n : ‚Ñï) in Filter.atTop, ¬¨x ‚àà s n",
    "name": "MeasureTheory.ae_eventually_not_mem",
    "isProp": true,
    "doc":
    "A version of the **Borel-Cantelli lemma**: if `s·µ¢` is a sequence of sets such that\n`‚àë Œº s·µ¢` exists, then for almost all `x`, `x` does not belong to almost all `s·µ¢`. ",
    "depth": 17}],
  "count": 423},
 {"noDocExamples": [],
  "kind": "¬´term_‚âÉ‚Çú_¬ª",
  "examples":
  [{"type": "EReal ‚âÉ‚Çú EReal",
    "name": "EReal.negHomeo",
    "isProp": false,
    "doc": "Negation on `EReal` as a homeomorphism ",
    "depth": 4},
   {"type": "‚Ñù ‚âÉ‚Çú ‚Ñù",
    "name": "Real.sinhHomeomorph",
    "isProp": false,
    "doc": "`Real.sinh` as a `Homeomorph`. ",
    "depth": 5},
   {"type": "(Œ± : Type u_5) ‚Üí [inst : TopologicalSpace Œ±] ‚Üí Œ± ‚âÉ‚Çú Œ±",
    "name": "Homeomorph.refl",
    "isProp": false,
    "doc": "Identity map as a homeomorphism. ",
    "depth": 6}],
  "count": 397},
 {"noDocExamples": [],
  "kind": "¬´term_^[_]¬ª",
  "examples":
  [{"type":
    "‚àÄ {Œ± : Type u} {f : Œ± ‚Üí Œ±} {x : Œ±}, Function.IsFixedPt f x ‚Üí ‚àÄ (n : ‚Ñï), Function.IsFixedPt f^[n] x",
    "name": "Function.IsFixedPt.iterate",
    "isProp": true,
    "doc":
    "If `x` is a fixed point of `f`, then it is a fixed point of `f^[n]`. ",
    "depth": 10},
   {"type":
    "‚àÄ {Œ± : Type u_1} (f : Œ± ‚Üí Œ±) (x : Œ±),\n  Function.periodicOrbit f x = Cycle.map (fun n => f^[n] x) ‚Üë(List.range (Function.minimalPeriod f x))",
    "name": "Function.periodicOrbit_eq_cycle_map",
    "isProp": true,
    "doc": "The definition of a periodic orbit, in terms of `Cycle.map`. ",
    "depth": 11},
   {"type":
    "‚àÄ {Œ± : Type u_2} [inst : MeasurableSpace Œ±] {f : Œ± ‚Üí Œ±} {Œº : MeasureTheory.Measure Œ±},\n  MeasureTheory.Conservative f Œº ‚Üí ‚àÄ (n : ‚Ñï), MeasureTheory.Conservative f^[n] Œº",
    "name": "MeasureTheory.Conservative.iterate",
    "isProp": true,
    "doc": "Iteration of a conservative system is a conservative system. ",
    "depth": 11}],
  "count": 389},
 {"noDocExamples": [],
  "kind": "¬´term_‚Üío_¬ª",
  "examples":
  [{"type": "‚Ñï ‚Üío ‚Ñï",
    "name": "rothNumberNat",
    "isProp": false,
    "doc":
    "The Roth number of a natural `N` is the largest integer `m` for which there is a subset of\n`range N` of size `m` with no arithmetic progression of length 3.\nTrivially, `rothNumberNat N ‚â§ N`, but Roth's theorem (proved in 1953) shows that\n`rothNumberNat N = o(N)` and the construction by Behrend gives a lower bound of the form\n`N * exp(-C sqrt(log(N))) ‚â§ rothNumberNat N`.\nA significant refinement of Roth's theorem by Bloom and Sisask announced in 2020 gives\n`rothNumberNat N = O(N / (log N)^(1+c))` for an absolute constant `c`. ",
    "depth": 5},
   {"type": "{Œ± : Type u_2} ‚Üí [inst : Preorder Œ±] ‚Üí Œ± ‚Üío Œ±",
    "name": "OrderHom.id",
    "isProp": false,
    "doc": "The identity function as bundled monotone function. ",
    "depth": 6},
   {"type": "{Œ± : Type u_2} ‚Üí [inst : Preorder Œ±] ‚Üí Œ± ‚Üío Œ± √ó Œ±",
    "name": "OrderHom.diag",
    "isProp": false,
    "doc": "Diagonal embedding of `Œ±` into `Œ± √ó Œ±` as an `OrderHom`. ",
    "depth": 7}],
  "count": 384},
 {"noDocExamples": [],
  "kind": "¬´term_‚Üí‚Çõ‚Çó[_]_¬ª",
  "examples":
  [{"type":
    "{R : Type u_1} ‚Üí {S : Type u_6} ‚Üí [inst : Semiring R] ‚Üí [inst_1 : Semiring S] ‚Üí (f : R ‚Üí+* S) ‚Üí R ‚Üí‚Çõ‚Çó[f] S",
    "name": "RingHom.toSemilinearMap",
    "isProp": false,
    "doc": "Interpret a `RingHom` `f` as an `f`-semilinear map. ",
    "depth": 16},
   {"type":
    "{R : Type u_1} ‚Üí\n  {M : Type u_9} ‚Üí\n    [inst : Semiring R] ‚Üí\n      [inst_1 : AddCommMonoid M] ‚Üí [inst_2 : Module R M] ‚Üí {œÉ : R ‚Üí+* R} ‚Üí [inst_3 : RingHomId œÉ] ‚Üí M ‚Üí‚Çõ‚Çó[œÉ] M",
    "name": "LinearMap.id'",
    "isProp": false,
    "doc":
    "A generalisation of `LinearMap.id` that constructs the identity function\nas a `œÉ`-semilinear map for any ring homomorphism `œÉ` which we know is the identity. ",
    "depth": 18},
   {"type":
    "{R‚ÇÅ : Type u_2} ‚Üí\n  {R‚ÇÇ : Type u_3} ‚Üí\n    {M : Type u_9} ‚Üí\n      {M‚ÇÇ : Type u_11} ‚Üí\n        [inst : Semiring R‚ÇÅ] ‚Üí\n          [inst_1 : Semiring R‚ÇÇ] ‚Üí\n            [inst_2 : AddCommMonoid M] ‚Üí\n              [inst_3 : AddCommMonoid M‚ÇÇ] ‚Üí\n                [inst_4 : Module R‚ÇÅ M] ‚Üí [inst_5 : Module R‚ÇÇ M‚ÇÇ] ‚Üí {œÉ‚ÇÅ‚ÇÇ : R‚ÇÅ ‚Üí+* R‚ÇÇ} ‚Üí Zero (M ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ)",
    "name": "LinearMap.instZeroLinearMap",
    "isProp": false,
    "doc": "The constant 0 map is linear. ",
    "depth": 23}],
  "count": 383},
 {"noDocExamples": [],
  "kind": "Function.¬´term_‚Ü™_¬ª",
  "examples":
  [{"type": "{Œ± : Type u_1} ‚Üí Œ± ‚Ü™ WithTop Œ±",
    "name": "Function.Embedding.coeWithTop",
    "isProp": false,
    "doc": "Embedding into `WithTop Œ±`. ",
    "depth": 3},
   {"type": "{Œ± : Type u_1} ‚Üí Œ± ‚Ü™ Option Œ±",
    "name": "Function.Embedding.some",
    "isProp": false,
    "doc": "Embedding into `Option Œ±` using `some`. ",
    "depth": 3},
   {"type": "‚Ñï ‚Üí ‚Ñï ‚Ü™ ‚Ñï",
    "name": "Polynomial.revAt",
    "isProp": false,
    "doc":
    "If `i ‚â§ N`, then `revAt N i` returns `N - i`, otherwise it returns `i`.\nEssentially, this embedding is only used for `i ‚â§ N`.\nThe advantage of `revAt N i` over `N - i` is that `revAt` is an involution.\n",
    "depth": 3}],
  "count": 374},
 {"noDocExamples": [],
  "kind": "¬´term_-·µ•_¬ª",
  "examples":
  [{"type":
    "‚àÄ {G : Type u_1} [inst : AddGroup G] (g1 g2 : G), g1 -·µ• g2 = g1 - g2",
    "name": "vsub_eq_sub",
    "isProp": true,
    "doc":
    "Simplify subtraction for a torsor for an `AddGroup G` over\nitself. ",
    "depth": 13},
   {"type":
    "‚àÄ {G : Type u_1} {P : Type u_2} [inst : AddGroup G] [T : AddTorsor G P] (p : P), Function.Injective fun x => p -·µ• x",
    "name": "vsub_right_injective",
    "isProp": true,
    "doc": "Subtracting a point from the point `p` is an injective\nfunction. ",
    "depth": 14},
   {"type":
    "‚àÄ {G : Type u_1} {P : Type u_2} [inst : AddGroup G] [T : AddTorsor G P] (p : P), p -·µ• p = 0",
    "name": "vsub_self",
    "isProp": true,
    "doc": "Subtracting a point from itself produces 0. ",
    "depth": 14}],
  "count": 365},
 {"noDocExamples": [],
  "kind": "¬´term‚ÅÖ_,_‚ÅÜ¬ª",
  "examples":
  [{"type": "‚àÄ {L : Type v} [self : LieRing L] (x : L), ‚ÅÖx, x‚ÅÜ = 0",
    "name": "LieRing.lie_self",
    "isProp": true,
    "doc": "A Lie ring bracket vanishes on the diagonal in L √ó L. ",
    "depth": 12},
   {"type":
    "‚àÄ {L : Type v} [self : LieRing L] (x y z : L), ‚ÅÖx, ‚ÅÖy, z‚ÅÜ‚ÅÜ = ‚ÅÖ‚ÅÖx, y‚ÅÜ, z‚ÅÜ + ‚ÅÖy, ‚ÅÖx, z‚ÅÜ‚ÅÜ",
    "name": "LieRing.leibniz_lie",
    "isProp": true,
    "doc": "A Lie ring bracket satisfies a Leibniz / Jacobi identity. ",
    "depth": 17},
   {"type":
    "‚àÄ {Œ∑ : Type u_4} [inst : Finite Œ∑] {Gs : Œ∑ ‚Üí Type u_5} [inst : (i : Œ∑) ‚Üí Group (Gs i)]\n  (H K : (i : Œ∑) ‚Üí Subgroup (Gs i)),\n  ‚ÅÖSubgroup.pi Set.univ H, Subgroup.pi Set.univ K‚ÅÜ = Subgroup.pi Set.univ fun i => ‚ÅÖH i, K i‚ÅÜ",
    "name": "Subgroup.commutator_pi_pi_of_finite",
    "isProp": true,
    "doc":
    "The commutator of a finite direct product is contained in the direct product of the commutators.\n",
    "depth": 18}],
  "count": 359},
 {"noDocExamples": [],
  "kind": "MeasureTheory.¬´term‚à´‚Åª_,_‚àÇ_¬ª",
  "examples":
  [{"type":
    "‚àÄ {Œ± : Type u_1} {m : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {f : Œ± ‚Üí ‚Ñù},\n  MeasureTheory.Integrable f ‚Üí\n    ‚à´ (a : Œ±), f a ‚àÇŒº =\n      ENNReal.toReal (‚à´‚Åª (a : Œ±), ENNReal.ofReal (f a) ‚àÇŒº) - ENNReal.toReal (‚à´‚Åª (a : Œ±), ENNReal.ofReal (-f a) ‚àÇŒº)",
    "name":
    "MeasureTheory.integral_eq_lintegral_pos_part_sub_lintegral_neg_part",
    "isProp": true,
    "doc":
    "The Bochner integral of a real-valued function `f : Œ± ‚Üí ‚Ñù` is the difference between the\nintegral of the positive part of `f` and the integral of the negative part of `f`.  ",
    "depth": 14},
   {"type":
    "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_3} [inst : MeasurableSpace Œ±] [inst_1 : MeasurableSpace Œ≤] {Œº : MeasureTheory.Measure Œ±}\n  [inst_2 : MeasureTheory.SigmaFinite Œº] {f : Œ± ‚Üí Œ≤ ‚Üí ENNReal},\n  Measurable (Function.uncurry f) ‚Üí Measurable fun y => ‚à´‚Åª (x : Œ±), f x y ‚àÇŒº",
    "name": "Measurable.lintegral_prod_left",
    "isProp": true,
    "doc":
    "The Lebesgue integral is measurable. This shows that the integrand of (the right-hand-side of)\nthe symmetric version of Tonelli's theorem is measurable.\nThis version has the argument `f` in curried form. ",
    "depth": 15},
   {"type":
    "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_3} [inst : MeasurableSpace Œ±] [inst_1 : MeasurableSpace Œ≤] {ŒΩ : MeasureTheory.Measure Œ≤}\n  [inst_2 : MeasureTheory.SigmaFinite ŒΩ] {f : Œ± ‚Üí Œ≤ ‚Üí ENNReal},\n  Measurable (Function.uncurry f) ‚Üí Measurable fun x => ‚à´‚Åª (y : Œ≤), f x y ‚àÇŒΩ",
    "name": "Measurable.lintegral_prod_right",
    "isProp": true,
    "doc":
    "The Lebesgue integral is measurable. This shows that the integrand of (the right-hand-side of)\nTonelli's theorem is measurable.\nThis version has the argument `f` in curried form. ",
    "depth": 15}],
  "count": 359},
 {"noDocExamples": [],
  "kind": "MeasureTheory.¬´term‚à´_,_‚àÇ_¬ª",
  "examples":
  [{"type":
    "‚àÄ {Œ± : Type u_1} {m : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {f : Œ± ‚Üí ‚Ñù},\n  MeasureTheory.Integrable f ‚Üí\n    ‚à´ (a : Œ±), f a ‚àÇŒº =\n      ENNReal.toReal (‚à´‚Åª (a : Œ±), ENNReal.ofReal (f a) ‚àÇŒº) - ENNReal.toReal (‚à´‚Åª (a : Œ±), ENNReal.ofReal (-f a) ‚àÇŒº)",
    "name":
    "MeasureTheory.integral_eq_lintegral_pos_part_sub_lintegral_neg_part",
    "isProp": true,
    "doc":
    "The Bochner integral of a real-valued function `f : Œ± ‚Üí ‚Ñù` is the difference between the\nintegral of the positive part of `f` and the integral of the negative part of `f`.  ",
    "depth": 14},
   {"type":
    "‚àÄ {Œ± : Type u_1} {m0 : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {f : Œ± ‚Üí ‚Ñù}\n  [inst : MeasureTheory.IsProbabilityMeasure Œº], MeasureTheory.Integrable f ‚Üí ‚àÉ x, f x ‚â§ ‚à´ (a : Œ±), f a ‚àÇŒº",
    "name": "MeasureTheory.exists_le_integral",
    "isProp": true,
    "doc":
    "**First moment method**. The minimum of an integrable function is smaller than its integral. ",
    "depth": 16},
   {"type":
    "‚àÄ {Œ± : Type u_1} {m0 : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {f : Œ± ‚Üí ‚Ñù}\n  [inst : MeasureTheory.IsProbabilityMeasure Œº], MeasureTheory.Integrable f ‚Üí ‚àÉ x, ‚à´ (a : Œ±), f a ‚àÇŒº ‚â§ f x",
    "name": "MeasureTheory.exists_integral_le",
    "isProp": true,
    "doc":
    "**First moment method**. The maximum of an integrable function is greater than its integral. ",
    "depth": 17}],
  "count": 330},
 {"noDocExamples": [],
  "kind": "termRexp",
  "examples":
  [{"type": "Filter.Tendsto rexp Filter.atTop Filter.atTop",
    "name": "Real.tendsto_exp_atTop",
    "isProp": true,
    "doc": "The real exponential function tends to `+‚àû` at `+‚àû`. ",
    "depth": 5},
   {"type": "Filter.Tendsto rexp (nhds 0) (nhds 1)",
    "name": "Real.tendsto_exp_nhds_0_nhds_1",
    "isProp": true,
    "doc": "The real exponential function tends to `1` at `0`. ",
    "depth": 7},
   {"type": "Filter.Tendsto (fun x => rexp (-x)) Filter.atTop (nhds 0)",
    "name": "Real.tendsto_exp_neg_atTop_nhds_0",
    "isProp": true,
    "doc":
    "The real exponential function tends to `0` at `-‚àû` or, equivalently, `exp(-x)` tends to `0`\nat `+‚àû` ",
    "depth": 8}],
  "count": 298},
 {"noDocExamples": [],
  "kind": "¬´term‚®Å_,_¬ª",
  "examples":
  [{"type":
    "{Œπ : Type v} ‚Üí\n  {Œ≤ : Œπ ‚Üí Type w} ‚Üí [inst : (i : Œπ) ‚Üí AddCommMonoid (Œ≤ i)] ‚Üí [inst_1 : IsEmpty Œπ] ‚Üí Unique (‚®Å (i : Œπ), Œ≤ i)",
    "name": "DirectSum.uniqueOfIsEmpty",
    "isProp": false,
    "doc": "A direct sum over an empty type is trivial. ",
    "depth": 9},
   {"type":
    "{Œπ : Type u_1} ‚Üí\n  [inst : DecidableEq Œπ] ‚Üí\n    (A : Œπ ‚Üí Type u_2) ‚Üí\n      [inst : (i : Œπ) ‚Üí AddCommMonoid (A i)] ‚Üí\n        [inst_1 : AddCommMonoid Œπ] ‚Üí [inst_2 : DirectSum.GCommSemiring A] ‚Üí CommSemiring (‚®Å (i : Œπ), A i)",
    "name": "DirectSum.commSemiring",
    "isProp": false,
    "doc": "The `CommSemiring` structure derived from `GCommSemiring A`. ",
    "depth": 11},
   {"type":
    "{Œπ : Type u_1} ‚Üí\n  [inst : DecidableEq Œπ] ‚Üí\n    (A : Œπ ‚Üí Type u_2) ‚Üí\n      [inst : (i : Œπ) ‚Üí AddCommMonoid (A i)] ‚Üí\n        [inst_1 : AddMonoid Œπ] ‚Üí [inst_2 : DirectSum.GSemiring A] ‚Üí Semiring (‚®Å (i : Œπ), A i)",
    "name": "DirectSum.semiring",
    "isProp": false,
    "doc": "The `Semiring` structure derived from `GSemiring A`. ",
    "depth": 11}],
  "count": 296},
 {"noDocExamples": [],
  "kind": "¬´term_‚â•_¬ª",
  "examples":
  [{"type":
    "‚àÄ {Œº : YoungDiagram},\n  YoungDiagram.ofRowLens (YoungDiagram.rowLens Œº) (_ : List.Sorted (fun x x_1 => x ‚â• x_1) (YoungDiagram.rowLens Œº)) = Œº",
    "name": "YoungDiagram.ofRowLens_to_rowLens_eq_self",
    "isProp": true,
    "doc": "The left_inv direction of the equivalence ",
    "depth": 6},
   {"type":
    "‚àÄ {w : List ‚Ñï} {hw : List.Sorted (fun x x_1 => x ‚â• x_1) w} (i : Fin (List.length w)),\n  YoungDiagram.rowLen (YoungDiagram.ofRowLens w hw) ‚Üëi = List.get w i",
    "name": "YoungDiagram.rowLen_ofRowLens",
    "isProp": true,
    "doc":
    "The length of the `i`th row in `ofRowLens w hw` is the `i`th entry of `w` ",
    "depth": 10},
   {"type":
    "‚àÄ {w : List ‚Ñï} {hw : List.Sorted (fun x x_1 => x ‚â• x_1) w},\n  (‚àÄ (x : ‚Ñï), x ‚àà w ‚Üí 0 < x) ‚Üí YoungDiagram.rowLens (YoungDiagram.ofRowLens w hw) = w",
    "name": "YoungDiagram.rowLens_ofRowLens_eq_self",
    "isProp": true,
    "doc": "The right_inv direction of the equivalence ",
    "depth": 10}],
  "count": 292},
 {"noDocExamples": [],
  "kind": "Lean.Parser.Term.match",
  "examples":
  [{"type":
    "‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] {a : Thunk Œ±} {Œµ : Type u_2} [self : Estimator a Œµ] (e : Œµ),\n  match EstimatorData.improve a e with\n  | none => EstimatorData.bound a e = Thunk.get a\n  | some e' => EstimatorData.bound a e < EstimatorData.bound a e'",
    "name": "Estimator.improve_spec",
    "isProp": true,
    "doc":
    "Calling `improve` either gives a strictly better bound,\nor a proof that the current bound is exact. ",
    "depth": 18},
   {"type":
    "{C : Type u_1} ‚Üí\n  [inst : CategoryTheory.Category.{u_2, u_1} C] ‚Üí\n    {B X : C} ‚Üí\n      (f : X ‚ü∂ B) ‚Üí\n        [inst_1 : CategoryTheory.EffectiveEpi f] ‚Üí\n          CategoryTheory.EffectiveEpiFamilyStruct (fun x => X) fun x =>\n            match x with\n            | PUnit.unit => f",
    "name": "CategoryTheory.EffectiveEpi_familyStruct",
    "isProp": false,
    "doc": "An `EffectiveEpiFamily` consisting of a single `EffectiveEpi`\n",
    "depth": 18},
   {"type":
    "‚àÄ {Œ± : Type u_2} [inst : PartialOrder Œ±] {Œµ : Type u_1} (a : Thunk Œ±) (p : Œ± ‚Üí Bool) [inst_1 : Estimator a Œµ]\n  [inst_2 : WellFoundedGT ‚Üë(Set.range (EstimatorData.bound a))] (e : Œµ),\n  match Estimator.improveUntil a p e with\n  | Except.error a_1 => ¬¨p (Thunk.get a) = true\n  | Except.ok e' => p (EstimatorData.bound a e') = true",
    "name": "Estimator.improveUntil_spec",
    "isProp": true,
    "doc":
    "If `Estimator.improveUntil a p e` returns `some e'`, then `bound a e'` satisfies `p`.\nOtherwise, that value `a` must not satisfy `p`.\n",
    "depth": 21}],
  "count": 286},
 {"noDocExamples": [],
  "kind": "¬´term_‚Üí‚Çô*_¬ª",
  "examples":
  [{"type": "(M : Type u_9) ‚Üí [inst : Mul M] ‚Üí M ‚Üí‚Çô* M",
    "name": "MulHom.id",
    "isProp": false,
    "doc": "The identity map from a type with multiplication to itself. ",
    "depth": 6},
   {"type": "{Œ± : Type u_2} ‚Üí [inst : Mul Œ±] ‚Üí Œ± ‚Üí‚Çô* Filter Œ±",
    "name": "Filter.pureMulHom",
    "isProp": false,
    "doc": "`pure` operation as a `MulHom`. ",
    "depth": 6},
   {"type": "{Œ± : Type u_2} ‚Üí [inst : Mul Œ±] ‚Üí Œ± ‚Üí‚Çô* Set Œ±",
    "name": "Set.singletonMulHom",
    "isProp": false,
    "doc": "The singleton operation as a `MulHom`. ",
    "depth": 6}],
  "count": 272},
 {"noDocExamples": [],
  "kind": "Asymptotics.¬´term_=O[_]_¬ª",
  "examples":
  [{"type":
    "(fun œÑ => jacobiTheta œÑ - 1) =O[Filter.comap Complex.im Filter.atTop] fun œÑ => rexp (-Real.pi * œÑ.im)",
    "name": "isBigO_at_im_infty_jacobiTheta_sub_one",
    "isProp": true,
    "doc":
    "The norm of `jacobiTheta œÑ - 1` decays exponentially as `im œÑ ‚Üí ‚àû`. ",
    "depth": 9},
   {"type": "zetaKernel‚ÇÅ =O[Filter.atTop] fun t => rexp (-Real.pi * t)",
    "name": "isBigO_atTop_zetaKernel‚ÇÅ",
    "isProp": true,
    "doc": "Bound for `zetaKernel‚ÇÅ` for large `t`. ",
    "depth": 9},
   {"type": "zetaKernel‚ÇÇ =O[Filter.atTop] fun t => rexp (-Real.pi * t)",
    "name": "isBigO_atTop_zetaKernel‚ÇÇ",
    "isProp": true,
    "doc": "Bound for `zetaKernel‚ÇÇ` for large `t`. ",
    "depth": 9}],
  "count": 267},
 {"noDocExamples": [],
  "kind": "termDepIfThenElse",
  "examples":
  [{"type":
    "‚àÄ {Œ± : Sort u_2} (P : Prop) [inst : Decidable P] (a b : Œ±), (if x : P then a else b) = if P then a else b",
    "name": "dite_eq_ite",
    "isProp": true,
    "doc":
    "A `dite` whose results do not actually depend on the condition may be reduced to an `ite`. ",
    "depth": 12},
   {"type":
    "‚àÄ {Œ± : Sort u_1} {Œ≤ : Sort u_2} (f : Œ± ‚Üí Œ≤) (P : Prop) [inst : Decidable P] (x : P ‚Üí Œ±) (y : ¬¨P ‚Üí Œ±),\n  f (dite P x y) = if h : P then f (x h) else f (y h)",
    "name": "apply_dite",
    "isProp": true,
    "doc":
    "A function applied to a `dite` is a `dite` of that function applied to each of the branches. ",
    "depth": 15},
   {"type":
    "‚àÄ {Œ± : Sort u_2} {œÉ : Œ± ‚Üí Sort u_1} (P : Prop) [inst : Decidable P] (f : P ‚Üí (a : Œ±) ‚Üí œÉ a) (g : ¬¨P ‚Üí (a : Œ±) ‚Üí œÉ a)\n  (a : Œ±), dite P f g a = if h : P then f h a else g h a",
    "name": "dite_apply",
    "isProp": true,
    "doc":
    "A 'dite' producing a `Pi` type `Œ† a, œÉ a`, applied to a value `a : Œ±` is a `dite` that applies\neither branch to `a`. ",
    "depth": 17}],
  "count": 264},
 {"noDocExamples": [],
  "kind": "¬´term_<$>_¬ª",
  "examples":
  [{"type":
    "‚àÄ {Œ± Œ≤ Œ≥ : Type u_1} (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) (a : Option Œ±) (b : Option Œ≤), Option.map‚ÇÇ f a b = Seq.seq (f <$> a) fun x => b",
    "name": "Option.map‚ÇÇ_def",
    "isProp": true,
    "doc":
    "`Option.map‚ÇÇ` in terms of monadic operations. Note that this can't be taken as the definition\nbecause of the lack of universe polymorphism. ",
    "depth": 15},
   {"type":
    "‚àÄ {Œ± Œ≤ Œ≥ : Type u_1} (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) (s : Set Œ±) (t : Set Œ≤), Set.image2 f s t = Seq.seq (f <$> s) fun x => t",
    "name": "Set.image2_def",
    "isProp": true,
    "doc":
    "`Set.image2` in terms of monadic operations. Note that this can't be taken as the definition\nbecause of the lack of universe polymorphism. ",
    "depth": 15},
   {"type":
    "‚àÄ {m : Type u_1 ‚Üí Type u_2} {Œ± Œ±_1 : Type u_1} {p : Œ±_1 ‚Üí Prop} {f : Œ± ‚Üí Œ±_1} [inst : Functor m]\n  [inst_1 : LawfulFunctor m] {x : m Œ±}, SatisfiesM (fun a => p (f a)) x ‚Üí SatisfiesM p (f <$> x)",
    "name": "SatisfiesM.map_pre",
    "isProp": true,
    "doc":
    "`SatisfiesM` distributes over `<$>`, weakest precondition version.\n(Use this for reasoning backward from the goal.)\n",
    "depth": 16}],
  "count": 241},
 {"noDocExamples": [],
  "kind": "Function.term_On_",
  "examples":
  [{"type":
    "‚àÄ {Œ± : Type u_1} {Œπ : Type u_4} {f : Œπ ‚Üí Œ±}, Function.Injective f ‚Üí Pairwise ((fun x x_1 => x ‚â† x_1) on f)",
    "name": "Function.Injective.pairwise_ne",
    "isProp": true,
    "doc":
    "**Alias** of the forward direction of `Function.injective_iff_pairwise_ne`.",
    "depth": 12},
   {"type":
    "‚àÄ {Œ± : Type u_1} {Œπ : Type u_3} [inst : CompleteLattice Œ±] {t : Œπ ‚Üí Œ±},\n  CompleteLattice.Independent t ‚Üí Pairwise (Disjoint on t)",
    "name": "CompleteLattice.Independent.pairwiseDisjoint",
    "isProp": true,
    "doc":
    "If the elements of a set are independent, then any pair within that set is disjoint. ",
    "depth": 16},
   {"type":
    "‚àÄ {Œ± : Type u_1} [inst : GeneralizedBooleanAlgebra Œ±] {f d : ‚Ñï ‚Üí Œ±},\n  Pairwise (Disjoint on d) ‚Üí partialSups d = partialSups f ‚Üí d = disjointed f",
    "name": "disjointed_unique",
    "isProp": true,
    "doc":
    "`disjointed f` is the unique sequence that is pairwise disjoint and has the same partial sups\nas `f`. ",
    "depth": 16}],
  "count": 233},
 {"noDocExamples": [],
  "kind": "List.¬´term_~_¬ª",
  "examples":
  [{"type":
    "{Œ± : Type u} ‚Üí (xs ys : List Œ±) ‚Üí xs ~ ys ‚Üí List.Nodup ys ‚Üí SlimCheck.InjectiveFunction Œ±",
    "name": "SlimCheck.InjectiveFunction.mk",
    "isProp": false,
    "doc":
    "Create an injective function from one list and a permutation of that list. ",
    "depth": 7},
   {"type": "‚àÄ {Œ± : Type uu} {a : Œ±} {l : List Œ±}, l ~ [a] ‚Üí l = [a]",
    "name": "List.Perm.eq_singleton",
    "isProp": true,
    "doc": "**Alias** of the forward direction of `List.perm_singleton`.",
    "depth": 8},
   {"type": "{Œ± : Type u} ‚Üí (xs : List Œ±) ‚Üí SlimCheck.Gen { ys // xs ~ ys }",
    "name": "SlimCheck.Gen.permutationOf",
    "isProp": false,
    "doc": "Generate a random permutation of a given list. ",
    "depth": 8}],
  "count": 231},
 {"noDocExamples": [],
  "kind": "Asymptotics.¬´term_=o[_]_¬ª",
  "examples":
  [{"type": "‚àÄ (s : ‚Ñù), (fun x => x ^ s) =o[Filter.atTop] rexp",
    "name": "isLittleO_rpow_exp_atTop",
    "isProp": true,
    "doc": "`x ^ s = o(exp x)` as `x ‚Üí ‚àû` for any real `s`. ",
    "depth": 10},
   {"type":
    "‚àÄ (k : ‚Ñ§) {b : ‚Ñù}, 0 < b ‚Üí (fun x => x ^ ‚Üëk) =o[Filter.atTop] fun x => rexp (b * x)",
    "name": "isLittleO_zpow_exp_pos_mul_atTop",
    "isProp": true,
    "doc":
    "`x ^ k = o(exp(b * x))` as `x ‚Üí ‚àû` for any integer `k` and positive `b`. ",
    "depth": 12},
   {"type":
    "‚àÄ {R : Type u_4} [inst : NormedRing R] {r : ‚Ñù}, 1 < r ‚Üí Nat.cast =o[Filter.atTop] fun n => r ^ n",
    "name": "isLittleO_coe_const_pow_of_one_lt",
    "isProp": true,
    "doc": "For a real `r > 1` we have `n = o(r ^ n)` as `n ‚Üí ‚àû`. ",
    "depth": 12}],
  "count": 229},
 {"noDocExamples": [],
  "kind": "¬´term_‚Üí·µÉ[_]_¬ª",
  "examples":
  [{"type":
    "(k : Type u_1) ‚Üí\n  {V1 : Type u_2} ‚Üí\n    (P1 : Type u_3) ‚Üí\n      [inst : Ring k] ‚Üí [inst_1 : AddCommGroup V1] ‚Üí [inst_2 : Module k V1] ‚Üí [inst_3 : AddTorsor V1 P1] ‚Üí P1 ‚Üí·µÉ[k] P1",
    "name": "AffineMap.id",
    "isProp": false,
    "doc": "Identity map as an affine map. ",
    "depth": 19},
   {"type":
    "{k : Type u_1} ‚Üí\n  {V1 : Type u_2} ‚Üí\n    {P1 : Type u_3} ‚Üí\n      [inst : Ring k] ‚Üí\n        [inst_1 : AddCommGroup V1] ‚Üí [inst_2 : Module k V1] ‚Üí [inst_3 : AddTorsor V1 P1] ‚Üí P1 ‚Üí P1 ‚Üí k ‚Üí·µÉ[k] P1",
    "name": "AffineMap.lineMap",
    "isProp": false,
    "doc":
    "The affine map from `k` to `P1` sending `0` to `p‚ÇÄ` and `1` to `p‚ÇÅ`. ",
    "depth": 21},
   {"type":
    "{Œπ : Type u_1} ‚Üí\n  {k : Type u_3} ‚Üí\n    {V : Type u_4} ‚Üí\n      {P : Type u_5} ‚Üí\n        [inst : AddCommGroup V] ‚Üí\n          [inst_1 : AddTorsor V P] ‚Üí [inst_2 : Ring k] ‚Üí [inst_3 : Module k V] ‚Üí AffineBasis Œπ k P ‚Üí P ‚Üí·µÉ[k] Œπ ‚Üí k",
    "name": "AffineBasis.coords",
    "isProp": false,
    "doc": "Barycentric coordinates as an affine map. ",
    "depth": 21}],
  "count": 220},
 {"noDocExamples": [],
  "kind": "MeasureTheory.¬´term‚à´_In_,_‚àÇ_¬ª",
  "examples":
  [{"type":
    "‚àÄ {Œ± : Type u_1} {m0 : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {f : Œ± ‚Üí ‚Ñù},\n  MeasureTheory.StronglyMeasurable f ‚Üí\n    MeasureTheory.Integrable f ‚Üí\n      (‚àÄ (s : Set Œ±), MeasurableSet s ‚Üí ‚Üë‚ÜëŒº s < ‚ä§ ‚Üí 0 ‚â§ ‚à´ (x : Œ±) in s, f x ‚àÇŒº) ‚Üí 0 ‚â§·∂†[MeasureTheory.Measure.ae Œº] f",
    "name":
    "MeasureTheory.ae_nonneg_of_forall_set_integral_nonneg_of_stronglyMeasurable",
    "isProp": true,
    "doc":
    "Don't use this lemma. Use `ae_nonneg_of_forall_set_integral_nonneg`. ",
    "depth": 20},
   {"type":
    "‚àÄ {Œ± : Type u_1} {E : Type u_3} [inst : MeasurableSpace Œ±] [inst_1 : NormedAddCommGroup E] {f : Œ± ‚Üí E} {s : Set Œ±}\n  {Œº : MeasureTheory.Measure Œ±} [inst_2 : NormedSpace ‚Ñù E],\n  (‚àÄ (x : Œ±), ¬¨x ‚àà s ‚Üí f x = 0) ‚Üí ‚à´ (x : Œ±) in s, f x ‚àÇŒº = ‚à´ (x : Œ±), f x ‚àÇŒº",
    "name": "MeasureTheory.set_integral_eq_integral_of_forall_compl_eq_zero",
    "isProp": true,
    "doc":
    "If a function vanishes on `s·∂ú`, then its integral on `s` coincides with its integral on the\nwhole space. ",
    "depth": 21},
   {"type":
    "‚àÄ {Œ± : Type u_1} [inst : MeasurableSpace Œ±] {Œº : MeasureTheory.Measure Œ±} {f g : Œ± ‚Üí ‚Ñù} {s : Set Œ±}\n  [inst_1 : MeasureTheory.SigmaFinite Œº],\n  MeasureTheory.IntegrableOn f s ‚Üí\n    MeasureTheory.IntegrableOn g s ‚Üí\n      MeasurableSet s ‚Üí\n        (‚àÄ (x : Œ±), x ‚àà s ‚Üí f x ‚â§ g x) ‚Üí\n          ‚Üë‚Üë(MeasureTheory.Measure.prod Œº MeasureTheory.volume) (regionBetween f g s) =\n            ENNReal.ofReal (‚à´ (y : Œ±) in s, (g - f) y ‚àÇŒº)",
    "name": "volume_regionBetween_eq_integral",
    "isProp": true,
    "doc":
    "If two functions are integrable on a measurable set, and one function is less than\nor equal to the other on that set, then the volume of the region\nbetween the two functions can be represented as an integral. ",
    "depth": 23}],
  "count": 220},
 {"noDocExamples": [],
  "kind": "¬´term_‚Üí._¬ª",
  "examples":
  [{"type": "(Œ± : Type u_7) ‚Üí Œ± ‚Üí. Œ±",
    "name": "PFun.id",
    "isProp": false,
    "doc": "The identity as a partial function ",
    "depth": 3},
   {"type": "Nat.Partrec.Code ‚Üí ‚Ñï ‚Üí. ‚Ñï",
    "name": "Nat.Partrec.Code.eval",
    "isProp": false,
    "doc":
    "The interpretation of a `Nat.Partrec.Code` as a partial function.\n* `Nat.Partrec.Code.zero`: The constant zero function.\n* `Nat.Partrec.Code.succ`: The successor function.\n* `Nat.Partrec.Code.left`: Left unpairing of a pair of ‚Ñï (encoded by `Nat.pair`)\n* `Nat.Partrec.Code.right`: Right unpairing of a pair of ‚Ñï (encoded by `Nat.pair`)\n* `Nat.Partrec.Code.pair`: Pairs the outputs of argument codes using `Nat.pair`.\n* `Nat.Partrec.Code.comp`: Composition of two argument codes.\n* `Nat.Partrec.Code.prec`: Primitive recursion. Given an argument of the form `Nat.pair a n`:\n  * If `n = 0`, returns `eval cf a`.\n  * If `n = succ k`, returns `eval cg (pair a (pair k (eval (prec cf cg) (pair a k))))`\n* `Nat.Partrec.Code.rfind'`: Minimization. For `f` an argument of the form `Nat.pair a m`,\n  `rfind' f m` returns the least `a` such that `f a m = 0`, if one exists and `f b m` terminates\n  for `b < a`\n",
    "depth": 3},
   {"type": "Turing.ToPartrec.Code ‚Üí List ‚Ñï ‚Üí. List ‚Ñï",
    "name": "Turing.ToPartrec.Code.eval",
    "isProp": false,
    "doc":
    "The semantics of the `Code` primitives, as partial functions `List ‚Ñï ‚Üí. List ‚Ñï`. By convention\nwe functions that return a single result return a singleton `[n]`, or in some cases `n :: v` where\n`v` will be ignored by a subsequent function.\n\n* `zero'` appends a `0` to the input. That is, `zero' v = 0 :: v`.\n* `succ` returns the successor of the head of the input, defaulting to zero if there is no head:\n  * `succ [] = [1]`\n  * `succ (n :: v) = [n + 1]`\n* `tail` returns the tail of the input\n  * `tail [] = []`\n  * `tail (n :: v) = v`\n* `cons f fs` calls `f` and `fs` on the input and conses the results:\n  * `cons f fs v = (f v).head :: fs v`\n* `comp f g` calls `f` on the output of `g`:\n  * `comp f g v = f (g v)`\n* `case f g` cases on the head of the input, calling `f` or `g` depending on whether it is zero or\n  a successor (similar to `Nat.casesOn`).\n  * `case f g [] = f []`\n  * `case f g (0 :: v) = f v`\n  * `case f g (n+1 :: v) = g (n :: v)`\n* `fix f` calls `f` repeatedly, using the head of the result of `f` to decide whether to call `f`\n  again or finish:\n  * `fix f v = []` if `f v = []`\n  * `fix f v = w` if `f v = 0 :: w`\n  * `fix f v = fix f w` if `f v = n+1 :: w` (the exact value of `n` is discarded)\n",
    "depth": 4}],
  "count": 209},
 {"noDocExamples": [],
  "kind": "MeasureTheory.¬´term_‚Üí‚Çò[_]_¬ª",
  "examples":
  [{"type":
    "{Œ± : Type u_1} ‚Üí [inst : MeasurableSpace Œ±] ‚Üí {Œº : MeasureTheory.Measure Œ±} ‚Üí (Œ± ‚Üí‚Çò[Œº] ENNReal) ‚Üí ENNReal",
    "name": "MeasureTheory.AEEqFun.lintegral",
    "isProp": false,
    "doc": "For `f : Œ± ‚Üí ‚Ñù‚â•0‚àû`, define `‚à´ [f]` to be `‚à´ f` ",
    "depth": 9},
   {"type":
    "{Œ± : Type u_1} ‚Üí\n  {Œ≤ : Type u_2} ‚Üí\n    [inst : MeasurableSpace Œ±] ‚Üí {Œº : MeasureTheory.Measure Œ±} ‚Üí [inst_1 : TopologicalSpace Œ≤] ‚Üí (Œ± ‚Üí‚Çò[Œº] Œ≤) ‚Üí Œ± ‚Üí Œ≤",
    "name": "MeasureTheory.AEEqFun.cast",
    "isProp": false,
    "doc":
    "Coercion from a space of equivalence classes of almost everywhere strongly measurable\nfunctions to functions. ",
    "depth": 11},
   {"type":
    "(Œ± : Type u_1) ‚Üí\n  {Œ≤ : Type u_2} ‚Üí\n    [inst : MeasurableSpace Œ±] ‚Üí {Œº : MeasureTheory.Measure Œ±} ‚Üí [inst_1 : TopologicalSpace Œ≤] ‚Üí Œ≤ ‚Üí Œ± ‚Üí‚Çò[Œº] Œ≤",
    "name": "MeasureTheory.AEEqFun.const",
    "isProp": false,
    "doc":
    "The equivalence class of a constant function: `[fun _ : Œ± => b]`, based on the equivalence\nrelation of being almost everywhere equal ",
    "depth": 11}],
  "count": 209},
 {"noDocExamples": [],
  "kind": "TensorProduct.¬´term_‚äó‚Çú[_]_¬ª",
  "examples":
  [{"type":
    "‚àÄ (R : Type u) (S : Type v) [inst : CommRing R] [inst_1 : CommRing S] [inst_2 : Algebra R S],\n  Submodule.span S (Set.range fun s => 1 ‚äó‚Çú[R] s - s ‚äó‚Çú[R] 1) =\n    Submodule.restrictScalars S (KaehlerDifferential.ideal R S)",
    "name": "KaehlerDifferential.submodule_span_range_eq_ideal",
    "isProp": true,
    "doc":
    "The kernel of `S ‚äó[R] S ‚Üí‚Çê[R] S` is generated by `1 ‚äó s - s ‚äó 1` as a `S`-module. ",
    "depth": 27},
   {"type":
    "‚àÄ (R : Type u_1) [inst : CommSemiring R] (M : Type u_4) (N : Type u_5) [inst_1 : AddCommMonoid M]\n  [inst_2 : AddCommMonoid N] [inst_3 : Module R M] [inst_4 : Module R N],\n  Submodule.span R {t | ‚àÉ m n, m ‚äó‚Çú[R] n = t} = ‚ä§",
    "name": "TensorProduct.span_tmul_eq_top",
    "isProp": true,
    "doc": "The simple (aka pure) elements span the tensor product. ",
    "depth": 29},
   {"type":
    "‚àÄ {R : Type u_1} [inst : CommSemiring R] {R' : Type u_2} [inst_1 : Monoid R'] {M : Type u_4} {N : Type u_5}\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid N] [inst_4 : Module R M] [inst_5 : Module R N]\n  [inst_6 : DistribMulAction R' M] [inst_7 : DistribMulAction R' N] [inst_8 : TensorProduct.CompatibleSMul R R' M N]\n  (r : R') (m : M) (n : N), (r ‚Ä¢ m) ‚äó‚Çú[R] n = m ‚äó‚Çú[R] (r ‚Ä¢ n)",
    "name": "TensorProduct.smul_tmul",
    "isProp": true,
    "doc": "`smul` can be moved from one side of the product to the other .",
    "depth": 31}],
  "count": 208},
 {"noDocExamples": [],
  "kind": "¬´term‚à´_In_.._,_¬ª",
  "examples":
  [{"type":
    "‚àÄ (n : ‚Ñï), ‚à´ (x : ‚Ñù) in 0 ..Real.pi / 2, Real.cos x ^ n = 1 / 2 * ‚à´ (x : ‚Ñù) in 0 ..Real.pi, Real.sin x ^ n",
    "name": "EulerSine.integral_cos_pow_eq",
    "isProp": true,
    "doc":
    "Relate the integral `cos x ^ n` over `[0, œÄ/2]` to the integral of `sin x ^ n` over `[0, œÄ]`,\nwhich is studied in `Data.Real.Pi.Wallis` and other places. ",
    "depth": 14},
   {"type":
    "‚àÄ {a b : ‚Ñù}, ‚à´ (x : ‚Ñù) in a..b, Real.sin x * Real.cos x = (Real.cos a ^ 2 - Real.cos b ^ 2) / 2",
    "name": "integral_sin_mul_cos‚ÇÇ",
    "isProp": true,
    "doc":
    "The integral of `sin x * cos x`, given in terms of cos¬≤.\nSee `integral_sin_mul_cos‚ÇÅ` above for the integral given in terms of sin¬≤. ",
    "depth": 15},
   {"type":
    "‚àÄ {a b : ‚Ñù}, ‚à´ (x : ‚Ñù) in a..b, Real.sin x * Real.cos x = (Real.sin b ^ 2 - Real.sin a ^ 2) / 2",
    "name": "integral_sin_mul_cos‚ÇÅ",
    "isProp": true,
    "doc":
    "The integral of `sin x * cos x`, given in terms of sin¬≤.\nSee `integral_sin_mul_cos‚ÇÇ` below for the integral given in terms of cos¬≤. ",
    "depth": 15}],
  "count": 204},
 {"noDocExamples": [],
  "kind": "¬´term_‚Üí‚Çó.[_]_¬ª",
  "examples":
  [{"type":
    "{R : Type u_1} ‚Üí\n  [inst : Ring R] ‚Üí\n    {E : Type u_2} ‚Üí\n      [inst_1 : AddCommGroup E] ‚Üí\n        [inst_2 : Module R E] ‚Üí\n          {F : Type u_3} ‚Üí [inst_3 : AddCommGroup F] ‚Üí [inst_4 : Module R F] ‚Üí (E ‚Üí‚Çó.[R] F) ‚Üí F ‚Üí‚Çó.[R] E",
    "name": "LinearPMap.inverse",
    "isProp": false,
    "doc": "The inverse of a `LinearPMap`. ",
    "depth": 17},
   {"type":
    "{R : Type u_1} ‚Üí\n  [inst : Ring R] ‚Üí\n    {E : Type u_2} ‚Üí\n      [inst_1 : AddCommGroup E] ‚Üí\n        [inst_2 : Module R E] ‚Üí\n          {F : Type u_3} ‚Üí [inst_3 : AddCommGroup F] ‚Üí [inst_4 : Module R F] ‚Üí (E ‚Üí‚Çó.[R] F) ‚Üí Submodule R (E √ó F)",
    "name": "LinearPMap.graph",
    "isProp": false,
    "doc": "The graph of a `LinearPMap` viewed as a submodule on `E √ó F`. ",
    "depth": 18},
   {"type":
    "{R : Type u_1} ‚Üí\n  [inst : Ring R] ‚Üí\n    {E : Type u_2} ‚Üí\n      [inst_1 : AddCommGroup E] ‚Üí\n        [inst_2 : Module R E] ‚Üí\n          {F : Type u_3} ‚Üí [inst_3 : AddCommGroup F] ‚Üí [inst_4 : Module R F] ‚Üí Submodule R (E √ó F) ‚Üí E ‚Üí‚Çó.[R] F",
    "name": "Submodule.toLinearPMap",
    "isProp": false,
    "doc":
    "Define a `LinearPMap` from its graph.\n\nIn the case that the submodule is not a graph of a `LinearPMap` then the underlying linear map\nis just the zero map. ",
    "depth": 18}],
  "count": 196},
 {"noDocExamples": [],
  "kind": "Filter.¬´term_‚â§·∂†[_]_¬ª",
  "examples":
  [{"type":
    "‚àÄ {Œ± : Type u_1} {_m0 : MeasurableSpace Œ±} ‚¶És s' : Set Œ±‚¶Ñ ‚¶ÉŒº ŒΩ : MeasureTheory.Measure Œ±‚¶Ñ,\n  s ‚â§·∂†[MeasureTheory.Measure.ae Œº] s' ‚Üí Œº ‚â§ ŒΩ ‚Üí MeasureTheory.Measure.restrict Œº s ‚â§ MeasureTheory.Measure.restrict ŒΩ s'",
    "name": "MeasureTheory.Measure.restrict_mono'",
    "isProp": true,
    "doc":
    "Restriction of a measure to a subset is monotone both in set and in measure. ",
    "depth": 16},
   {"type":
    "‚àÄ {Œ± : Type u_1} {m : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {f : MeasureTheory.SimpleFunc Œ± ‚Ñù},\n  MeasureTheory.Integrable ‚Üëf ‚Üí\n    0 ‚â§·∂†[MeasureTheory.Measure.ae Œº] ‚Üëf ‚Üí\n      MeasureTheory.SimpleFunc.integral Œº f = ENNReal.toReal (‚à´‚Åª (a : Œ±), ENNReal.ofReal (‚Üëf a) ‚àÇŒº)",
    "name": "MeasureTheory.SimpleFunc.integral_eq_lintegral",
    "isProp": true,
    "doc":
    "`SimpleFunc.bintegral` and `SimpleFunc.integral` agree when the integrand has type\n`Œ± ‚Üí‚Çõ ‚Ñù‚â•0‚àû`. But since `‚Ñù‚â•0‚àû` is not a `NormedSpace`, we need some form of coercion. ",
    "depth": 16},
   {"type":
    "‚àÄ {Œ± : Type u_1} [inst : MeasurableSpace Œ±] {Œº : MeasureTheory.Measure Œ±} {s t : Set Œ±},\n  s ‚â§·∂†[MeasureTheory.Measure.ae Œº] t ‚Üí ‚Üë‚ÜëŒº s ‚â§ ‚Üë‚ÜëŒº t",
    "name": "MeasureTheory.measure_mono_ae",
    "isProp": true,
    "doc": "If `s ‚äÜ t` modulo a set of measure `0`, then `Œº s ‚â§ Œº t`. ",
    "depth": 16}],
  "count": 192},
 {"noDocExamples": [],
  "kind": "¬´term_‚Üí‚Çó‚ÅÖ_‚ÅÜ_¬ª",
  "examples":
  [{"type":
    "{R : Type u} ‚Üí {L‚ÇÅ : Type v} ‚Üí [inst : CommRing R] ‚Üí [inst_1 : LieRing L‚ÇÅ] ‚Üí [inst_2 : LieAlgebra R L‚ÇÅ] ‚Üí L‚ÇÅ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÅ",
    "name": "LieHom.id",
    "isProp": false,
    "doc": "The identity map is a morphism of Lie algebras. ",
    "depth": 13},
   {"type":
    "{R : Type u} ‚Üí\n  {L‚ÇÅ : Type v} ‚Üí [inst : CommRing R] ‚Üí [inst_1 : LieRing L‚ÇÅ] ‚Üí [inst_2 : LieAlgebra R L‚ÇÅ] ‚Üí One (L‚ÇÅ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÅ)",
    "name": "LieHom.instOneLieHom",
    "isProp": false,
    "doc": "The identity map is a Lie algebra morphism. ",
    "depth": 14},
   {"type":
    "(R : Type u‚ÇÅ) ‚Üí\n  {L : Type u‚ÇÇ} ‚Üí\n    [inst : CommRing R] ‚Üí [inst_1 : LieRing L] ‚Üí [inst_2 : LieAlgebra R L] ‚Üí L ‚Üí‚Çó‚ÅÖR‚ÅÜ UniversalEnvelopingAlgebra R L",
    "name": "UniversalEnvelopingAlgebra.Œπ",
    "isProp": false,
    "doc":
    "The natural Lie algebra morphism from a Lie algebra to its universal enveloping algebra. ",
    "depth": 16}],
  "count": 188},
 {"noDocExamples": [],
  "kind": "Matrix.vecNotation",
  "examples":
  [{"type": "(Œ± Œ≤ : Type u) ‚Üí Œ± √ó Œ≤ ‚âÉ ((i : Fin 2) ‚Üí Matrix.vecCons Œ± ![Œ≤] i)",
    "name": "prodEquivPiFinTwo",
    "isProp": false,
    "doc":
    "A product space `Œ± √ó Œ≤` is equivalent to the space `Œ† i : Fin 2, Œ≥ i`, where\n`Œ≥ = Fin.cons Œ± (Fin.cons Œ≤ finZeroElim)`. See also `piFinTwoEquiv` and\n`finTwoArrowEquiv`. ",
    "depth": 12},
   {"type":
    "‚àÄ (k : Type u_1) {V : Type u_2} {P : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {p‚ÇÅ p‚ÇÇ : P}, p‚ÇÅ ‚â† p‚ÇÇ ‚Üí AffineIndependent k ![p‚ÇÅ, p‚ÇÇ]",
    "name": "affineIndependent_of_ne",
    "isProp": true,
    "doc": "Two different points are affinely independent. ",
    "depth": 19},
   {"type":
    "‚àÄ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ‚Ñù V]\n  [inst_2 : Fact (FiniteDimensional.finrank ‚Ñù V = 2)] (o : Orientation ‚Ñù V (Fin 2)) {x y : V},\n  Orientation.oangle o x y ‚â† 0 ‚àß Orientation.oangle o x y ‚â† ‚ÜëReal.pi ‚Üî LinearIndependent ‚Ñù ![x, y]",
    "name": "Orientation.oangle_ne_zero_and_ne_pi_iff_linearIndependent",
    "isProp": true,
    "doc":
    "The oriented angle between two vectors is not zero or `œÄ` if and only if those two vectors\nare linearly independent. ",
    "depth": 21}],
  "count": 184},
 {"noDocExamples": [],
  "kind": "¬´term‚Öü_¬ª",
  "examples":
  [{"type":
    "{Œ± : Type u} ‚Üí [inst : One Œ±] ‚Üí [inst_1 : Mul Œ±] ‚Üí {a : Œ±} ‚Üí [inst_2 : Invertible a] ‚Üí Invertible ‚Öüa",
    "name": "invertibleInvOf",
    "isProp": false,
    "doc": "`a` is the inverse of `‚Öüa`. ",
    "depth": 11},
   {"type":
    "‚àÄ {Œ± : Type u} [inst : MonoidWithZero Œ±] (x : Œ±) [inst_1 : Invertible x], Ring.inverse x = ‚Öüx",
    "name": "Ring.inverse_invertible",
    "isProp": true,
    "doc": "A variant of `Ring.inverse_unit`. ",
    "depth": 13},
   {"type":
    "‚àÄ {Œ± : Type u} [inst : Mul Œ±] [inst_1 : One Œ±] {a : Œ±} [self : Invertible a], a * ‚Öüa = 1",
    "name": "Invertible.mul_invOf_self",
    "isProp": true,
    "doc": "`invOf a` is a right inverse of `a` ",
    "depth": 13}],
  "count": 181},
 {"noDocExamples": [],
  "kind": "¬´term_‚äÇ_¬ª",
  "examples":
  [{"type": "‚àÄ {Œ± : Type u} {s : Set Œ±}, Set.Nonempty s ‚Üí ‚àÖ ‚äÇ s",
    "name": "Set.Nonempty.empty_ssubset",
    "isProp": true,
    "doc": "**Alias** of the reverse direction of `Set.empty_ssubset`.",
    "depth": 8},
   {"type": "‚àÄ {Œ± : Type u_1} {s : Finset Œ±}, Finset.Nonempty s ‚Üí ‚àÖ ‚äÇ s",
    "name": "Finset.Nonempty.empty_ssubset",
    "isProp": true,
    "doc": "**Alias** of the reverse direction of `Finset.empty_ssubset`.",
    "depth": 8},
   {"type":
    "‚àÄ {Œ± : Type u} [inst : HasSSubset Œ±] [inst_1 : IsIrrefl Œ± fun x x_1 => x ‚äÇ x_1] {a b : Œ±}, a ‚äÇ b ‚Üí a ‚â† b",
    "name": "HasSSubset.SSubset.ne",
    "isProp": true,
    "doc": "**Alias** of `ne_of_ssubset`.",
    "depth": 10}],
  "count": 175},
 {"noDocExamples": [],
  "kind": "Lean.Parser.Term.let",
  "examples":
  [{"type":
    "{Œ± : Type u} ‚Üí\n  {Œ≤ : Type v} ‚Üí\n    (e : Œ± ‚âÉ Œ≤) ‚Üí\n      [inst : Add Œ≤] ‚Üí\n        let mul := Equiv.add e;\n        Œ± ‚âÉ+ Œ≤",
    "name": "Equiv.addEquiv",
    "isProp": false,
    "doc":
    "An equivalence `e : Œ± ‚âÉ Œ≤` gives an additive equivalence `Œ± ‚âÉ+ Œ≤` where\nthe additive structure on `Œ±` is the one obtained by transporting an additive structure\non `Œ≤` back along `e`.",
    "depth": 9},
   {"type":
    "{Œ± : Type u} ‚Üí\n  {Œ≤ : Type v} ‚Üí\n    (e : Œ± ‚âÉ Œ≤) ‚Üí\n      [inst : Mul Œ≤] ‚Üí\n        let mul := Equiv.mul e;\n        Œ± ‚âÉ* Œ≤",
    "name": "Equiv.mulEquiv",
    "isProp": false,
    "doc":
    "An equivalence `e : Œ± ‚âÉ Œ≤` gives a multiplicative equivalence `Œ± ‚âÉ* Œ≤` where\nthe multiplicative structure on `Œ±` is the one obtained by transporting a multiplicative structure\non `Œ≤` back along `e`. ",
    "depth": 9},
   {"type":
    "{u : Lean.Level} ‚Üí\n  {Œ± :\n      let u := u;\n      Q(Type u)} ‚Üí\n    Q(AddMonoid ¬´$Œ±¬ª) ‚Üí List Q(¬´$Œ±¬ª) ‚Üí Q(¬´$Œ±¬ª)",
    "name": "Linarith.addExprs'",
    "isProp": false,
    "doc": "A type-safe analogue of `addExprs`. ",
    "depth": 10}],
  "count": 175},
 {"noDocExamples": [],
  "kind": "¬´term‚àÉ!_,_¬ª",
  "examples":
  [{"type":
    "{Œ± : Type u_1} ‚Üí [inst : Fintype Œ±] ‚Üí (p : Œ± ‚Üí Prop) ‚Üí [inst : DecidablePred p] ‚Üí (‚àÉ! a, p a) ‚Üí { a // p a }",
    "name": "Fintype.chooseX",
    "isProp": false,
    "doc":
    "Given a fintype `Œ±` and a predicate `p`, associate to a proof that there is a unique element of\n`Œ±` satisfying `p` this unique element, as an element of the corresponding subtype. ",
    "depth": 8},
   {"type":
    "{Œ± : Type u_1} ‚Üí [inst : Fintype Œ±] ‚Üí (p : Œ± ‚Üí Prop) ‚Üí [inst : DecidablePred p] ‚Üí (‚àÉ! a, p a) ‚Üí Œ±",
    "name": "Fintype.choose",
    "isProp": false,
    "doc":
    "Given a fintype `Œ±` and a predicate `p`, associate to a proof that there is a unique element of\n`Œ±` satisfying `p` this unique element, as an element of `Œ±`. ",
    "depth": 8},
   {"type":
    "‚àÄ {Œ± : Type u_1} (r : Setoid Œ±), Setoid.mkClasses (Setoid.classes r) (_ : ‚àÄ (a : Œ±), ‚àÉ! b x, a ‚àà b) = r",
    "name": "Setoid.mkClasses_classes",
    "isProp": true,
    "doc":
    "The equivalence relation made from the equivalence classes of an equivalence\nrelation r equals r. ",
    "depth": 8}],
  "count": 171},
 {"noDocExamples": [],
  "kind": "¬´term‚Ñ§‚àö_¬ª",
  "examples":
  [{"type": "{d : ‚Ñ§} ‚Üí ‚Ñ§‚àöd",
    "name": "Zsqrtd.sqrtd",
    "isProp": false,
    "doc": "The representative of `‚àöd` in the ring ",
    "depth": 2},
   {"type": "{d : ‚Ñ§} ‚Üí ‚Ñ§‚àöd ‚Üí Prop",
    "name": "Pell.IsPell",
    "isProp": false,
    "doc":
    "The property of being a solution to the Pell equation, expressed\nas a property of elements of `‚Ñ§‚àöd`. ",
    "depth": 3},
   {"type": "{d : ‚Ñ§} ‚Üí One (‚Ñ§‚àöd)",
    "name": "Zsqrtd.instOneZsqrtd",
    "isProp": false,
    "doc": "The one of the ring ",
    "depth": 3}],
  "count": 170},
 {"noDocExamples": [],
  "kind": "Complex.termCexp",
  "examples":
  [{"type": "‚àÄ {s : Set ‚ÑÇ}, Set.Countable s ‚Üí Set.Countable (cexp ‚Åª¬π' s)",
    "name": "Set.Countable.preimage_cexp",
    "isProp": true,
    "doc":
    "**Alias** of the reverse direction of `Complex.countable_preimage_exp`.",
    "depth": 7},
   {"type":
    "Filter.Tendsto cexp (Filter.comap Complex.re Filter.atBot) (nhds 0)",
    "name": "Complex.tendsto_exp_comap_re_atBot",
    "isProp": true,
    "doc": "`Complex.exp z ‚Üí 0` as `Complex.re z ‚Üí -‚àû`.",
    "depth": 10},
   {"type": "‚àÄ (x : ‚ÑÇ), HasDerivAt cexp (cexp x) x",
    "name": "Complex.hasDerivAt_exp",
    "isProp": true,
    "doc":
    "The complex exponential is everywhere differentiable, with the derivative `exp x`. ",
    "depth": 10}],
  "count": 166},
 {"noDocExamples": [],
  "kind": "Set.¬´term‚ãÉ‚ÇÄ_¬ª",
  "examples":
  [{"type":
    "‚àÄ {Œ± : Type u} [t : TopologicalSpace Œ±] {s : Set (Set Œ±)}, TopologicalSpace.IsTopologicalBasis s ‚Üí ‚ãÉ‚ÇÄ s = Set.univ",
    "name": "TopologicalSpace.IsTopologicalBasis.sUnion_eq",
    "isProp": true,
    "doc": "The sets from `s` cover the whole space. ",
    "depth": 8},
   {"type": "‚àÄ {Œ± : Type u_1} {S T : Set (Set Œ±)}, S ‚äÜ T ‚Üí ‚ãÉ‚ÇÄ S ‚äÜ ‚ãÉ‚ÇÄ T",
    "name": "Set.sUnion_mono",
    "isProp": true,
    "doc": "**Alias** of `Set.sUnion_subset_sUnion`.",
    "depth": 10},
   {"type":
    "‚àÄ {Œ± : Type u_1} {S : Set (Set Œ±)}, S ‚äÜ {‚àÖ, Set.univ} ‚Üí ‚ãÉ‚ÇÄ S ‚àà {‚àÖ, Set.univ}",
    "name": "Set.sUnion_mem_empty_univ",
    "isProp": true,
    "doc":
    "If all sets in a collection are either `‚àÖ` or `Set.univ`, then so is their union. ",
    "depth": 10}],
  "count": 159},
 {"noDocExamples": [],
  "kind": "Lean.Parser.Term.explicit",
  "examples":
  [{"type": "RingHom.LocalizationPreserves @RingHom.Finite",
    "name": "localization_finite",
    "isProp": true,
    "doc":
    "If `S` is a finite `R`-algebra, then `S' = M‚Åª¬πS` is a finite `R' = M‚Åª¬πR`-algebra. ",
    "depth": 1},
   {"type": "CategoryTheory.UnbundledHom @UniformContinuous",
    "name": "UniformSpaceCat.instUnbundledHomTypeUniformSpaceUniformContinuous",
    "isProp": true,
    "doc": "The information required to build morphisms for `UniformSpace`. ",
    "depth": 4},
   {"type":
    "‚àÄ {Œ± : Type u_1} {Œ≥ : Type u_3}, Monotone (@UniformFun.uniformSpace Œ± Œ≥)",
    "name": "UniformFun.mono",
    "isProp": true,
    "doc":
    "If `u‚ÇÅ` and `u‚ÇÇ` are two uniform structures on `Œ≥` and `u‚ÇÅ ‚â§ u‚ÇÇ`, then\n`ùí∞(Œ±, Œ≥, u‚ÇÅ) ‚â§ ùí∞(Œ±, Œ≥, u‚ÇÇ)`. ",
    "depth": 9}],
  "count": 155},
 {"noDocExamples": [],
  "kind": "¬´term_‚àÜ_¬ª",
  "examples":
  [{"type":
    "‚àÄ {Œ± : Type u_1} [inst : MeasurableSpace Œ±] {s : MeasureTheory.SignedMeasure Œ±} {u v : Set Œ±},\n  MeasurableSet u ‚Üí\n    MeasurableSet v ‚Üí\n      MeasureTheory.VectorMeasure.restrict 0 u ‚â§ MeasureTheory.VectorMeasure.restrict s u ‚Üí\n        MeasureTheory.VectorMeasure.restrict 0 v ‚â§ MeasureTheory.VectorMeasure.restrict s v ‚Üí\n          ‚Üës (u ‚àÜ v) = 0 ‚Üí ‚Üës (u \\ v) = 0 ‚àß ‚Üës (v \\ u) = 0",
    "name":
    "MeasureTheory.SignedMeasure.of_diff_eq_zero_of_symmDiff_eq_zero_positive",
    "isProp": true,
    "doc":
    "If the symmetric difference of two positive sets is a null-set, then so are the differences\nbetween the two sets. ",
    "depth": 25},
   {"type":
    "‚àÄ {Œ± : Type u_1} [inst : MeasurableSpace Œ±] {s : MeasureTheory.SignedMeasure Œ±} {u v : Set Œ±},\n  MeasurableSet u ‚Üí\n    MeasurableSet v ‚Üí\n      MeasureTheory.VectorMeasure.restrict s u ‚â§ MeasureTheory.VectorMeasure.restrict 0 u ‚Üí\n        MeasureTheory.VectorMeasure.restrict s v ‚â§ MeasureTheory.VectorMeasure.restrict 0 v ‚Üí\n          ‚Üës (u ‚àÜ v) = 0 ‚Üí ‚Üës (u \\ v) = 0 ‚àß ‚Üës (v \\ u) = 0",
    "name":
    "MeasureTheory.SignedMeasure.of_diff_eq_zero_of_symmDiff_eq_zero_negative",
    "isProp": true,
    "doc":
    "If the symmetric difference of two negative sets is a null-set, then so are the differences\nbetween the two sets. ",
    "depth": 25},
   {"type":
    "‚àÄ {Œ± : Type u_1} [inst : MeasurableSpace Œ±] {s : MeasureTheory.SignedMeasure Œ±} {i j : Set Œ±},\n  MeasurableSet i ‚Üí\n    MeasurableSet j ‚Üí\n      MeasureTheory.VectorMeasure.restrict 0 i ‚â§ MeasureTheory.VectorMeasure.restrict s i ‚àß\n          MeasureTheory.VectorMeasure.restrict s i·∂ú ‚â§ MeasureTheory.VectorMeasure.restrict 0 i·∂ú ‚Üí\n        MeasureTheory.VectorMeasure.restrict 0 j ‚â§ MeasureTheory.VectorMeasure.restrict s j ‚àß\n            MeasureTheory.VectorMeasure.restrict s j·∂ú ‚â§ MeasureTheory.VectorMeasure.restrict 0 j·∂ú ‚Üí\n          ‚Üës (i ‚àÜ j) = 0 ‚àß ‚Üës (i·∂ú ‚àÜ j·∂ú) = 0",
    "name": "MeasureTheory.SignedMeasure.of_symmDiff_compl_positive_negative",
    "isProp": true,
    "doc":
    "The symmetric difference of two Hahn decompositions has measure zero. ",
    "depth": 26}],
  "count": 152},
 {"noDocExamples": [],
  "kind": "¬´term_‚ãñ_¬ª",
  "examples":
  [{"type": "‚àÄ {a b : ‚Ñï}, a ‚ãñ b ‚Üí ‚Üëa ‚ãñ ‚Üëb",
    "name": "Covby.cast_int",
    "isProp": true,
    "doc": "**Alias** of the reverse direction of `Nat.cast_int_covby_iff`.",
    "depth": 8},
   {"type": "‚àÄ {n : ‚Ñï} {a b : Fin n}, a ‚ãñ b ‚Üí ‚Üëa ‚ãñ ‚Üëb",
    "name": "Covby.coe_fin",
    "isProp": true,
    "doc": "**Alias** of the reverse direction of `Fin.coe_covby_iff`.",
    "depth": 9},
   {"type":
    "‚àÄ {Œ± : Type u_1} [inst : LT Œ±] {a b : Œ±} [inst_1 : DenselyOrdered Œ±], ¬¨a ‚ãñ b",
    "name": "not_covby",
    "isProp": true,
    "doc": "In a dense order, nothing covers anything. ",
    "depth": 10}],
  "count": 152},
 {"noDocExamples": [],
  "kind": "¬´term‚àë·∂†_,_¬ª",
  "examples":
  [{"type":
    "‚àÄ (G : Type u) [inst : Group G] [inst_1 : Finite G],\n  ‚àë·∂† (x : ConjClasses G), Set.ncard (ConjClasses.carrier x) = Nat.card G",
    "name": "Group.sum_card_conj_classes_eq_card",
    "isProp": true,
    "doc":
    "Conjugacy classes form a partition of G, stated in terms of cardinality. ",
    "depth": 13},
   {"type":
    "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {M : Type u_5} [inst : AddCommMonoid M] {g : Œ≤ ‚Üí M} (e : Œ± ‚Üí Œ≤),\n  Function.Bijective e ‚Üí ‚àë·∂† (i : Œ±), g (e i) = ‚àë·∂† (j : Œ≤), g j",
    "name": "finsum_comp",
    "isProp": true,
    "doc":
    "See also `finsum_eq_of_bijective`, `Fintype.sum_bijective` and `Finset.sum_bij`.",
    "depth": 13},
   {"type":
    "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {M : Type u_5} [inst : AddCommMonoid M] {f : Œ± ‚Üí M} {g : Œ≤ ‚Üí M} (e : Œ± ‚Üí Œ≤),\n  Function.Bijective e ‚Üí (‚àÄ (x : Œ±), f x = g (e x)) ‚Üí ‚àë·∂† (i : Œ±), f i = ‚àë·∂† (j : Œ≤), g j",
    "name": "finsum_eq_of_bijective",
    "isProp": true,
    "doc": "See `finsum_comp`, `Fintype.sum_bijective` and `Finset.sum_bij`.",
    "depth": 15}],
  "count": 150},
 {"noDocExamples": [],
  "kind": "¬´term_‚âÉL[_]_¬ª",
  "examples":
  [{"type": "‚ÑÇ ‚âÉL[‚Ñù] ‚ÑÇ",
    "name": "Complex.conjCle",
    "isProp": false,
    "doc":
    "Continuous linear equiv version of the conj function, from `‚ÑÇ` to `‚ÑÇ`. ",
    "depth": 16},
   {"type": "‚ÑÇ ‚âÉL[‚Ñù] ‚Ñù √ó ‚Ñù",
    "name": "Complex.equivRealProdClm",
    "isProp": false,
    "doc": "The natural `ContinuousLinearEquiv` from `‚ÑÇ` to `‚Ñù √ó ‚Ñù`. ",
    "depth": 16},
   {"type": "{K : Type u_1} ‚Üí [inst : IsROrC K] ‚Üí K ‚âÉL[‚Ñù] K",
    "name": "IsROrC.conjCle",
    "isProp": false,
    "doc": "Conjugate as a continuous linear equivalence ",
    "depth": 18}],
  "count": 150},
 {"noDocExamples": [],
  "kind": "¬´term_‚á®_¬ª",
  "examples":
  [{"type": "‚àÄ {Œ± : Type u_4} [self : HeytingAlgebra Œ±] (a : Œ±), a ‚á® ‚ä• = a·∂ú",
    "name": "HeytingAlgebra.himp_bot",
    "isProp": true,
    "doc": "`a ‚á®` is right adjoint to `a ‚äì` ",
    "depth": 11},
   {"type":
    "‚àÄ {Œ± : Type u} [self : BooleanAlgebra Œ±] (x y : Œ±), x ‚á® y = y ‚äî x·∂ú",
    "name": "BooleanAlgebra.himp_eq",
    "isProp": true,
    "doc": "`x ‚á® y` is equal to `y ‚äî x·∂ú` ",
    "depth": 13},
   {"type":
    "‚àÄ {Œ± : Type u_2} [inst : GeneralizedHeytingAlgebra Œ±] {a b : Œ±}, a ‚á® b = ‚ä§ ‚Üî a ‚â§ b",
    "name": "himp_eq_top_iff",
    "isProp": true,
    "doc":
    "The **deduction theorem** in the Heyting algebra model of intuitionistic logic:\nan implication holds iff the conclusion follows from the hypothesis. ",
    "depth": 14}],
  "count": 148},
 {"noDocExamples": [],
  "kind": "¬´term_‚ÜíSL[_]_¬ª",
  "examples":
  [{"type":
    "{R : Type u_1} ‚Üí\n  {R‚ÇÇ : Type u_2} ‚Üí\n    {E : Type u_5} ‚Üí\n      {E‚ÇÇ : Type u_6} ‚Üí\n        [inst : Semiring R] ‚Üí\n          [inst_1 : Semiring R‚ÇÇ] ‚Üí\n            {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} ‚Üí\n              [inst_2 : SeminormedAddCommGroup E] ‚Üí\n                [inst_3 : SeminormedAddCommGroup E‚ÇÇ] ‚Üí\n                  [inst_4 : Module R E] ‚Üí [inst_5 : Module R‚ÇÇ E‚ÇÇ] ‚Üí (E ‚Üí‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ) ‚Üí E ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ",
    "name": "LinearIsometry.toContinuousLinearMap",
    "isProp": false,
    "doc": "Interpret a linear isometry as a continuous linear map. ",
    "depth": 25},
   {"type":
    "{R‚ÇÅ : Type u_1} ‚Üí\n  {R‚ÇÇ : Type u_2} ‚Üí\n    [inst : Semiring R‚ÇÅ] ‚Üí\n      [inst_1 : Semiring R‚ÇÇ] ‚Üí\n        {œÉ‚ÇÅ‚ÇÇ : R‚ÇÅ ‚Üí+* R‚ÇÇ} ‚Üí\n          {M‚ÇÅ : Type u_4} ‚Üí\n            [inst_2 : TopologicalSpace M‚ÇÅ] ‚Üí\n              [inst_3 : AddCommMonoid M‚ÇÅ] ‚Üí\n                {M‚ÇÇ : Type u_6} ‚Üí\n                  [inst_4 : TopologicalSpace M‚ÇÇ] ‚Üí\n                    [inst_5 : AddCommMonoid M‚ÇÇ] ‚Üí\n                      [inst_6 : Module R‚ÇÅ M‚ÇÅ] ‚Üí [inst_7 : Module R‚ÇÇ M‚ÇÇ] ‚Üí (M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) ‚Üí M‚ÇÅ ‚Üí M‚ÇÇ",
    "name": "ContinuousLinearMap.Simps.apply",
    "isProp": false,
    "doc":
    "See Note [custom simps projection]. We need to specify this projection explicitly in this case,\nbecause it is a composition of multiple projections. ",
    "depth": 27},
   {"type":
    "{R‚ÇÅ : Type u_1} ‚Üí\n  {R‚ÇÇ : Type u_2} ‚Üí\n    [inst : Semiring R‚ÇÅ] ‚Üí\n      [inst_1 : Semiring R‚ÇÇ] ‚Üí\n        {œÉ‚ÇÅ‚ÇÇ : R‚ÇÅ ‚Üí+* R‚ÇÇ} ‚Üí\n          {M‚ÇÅ : Type u_4} ‚Üí\n            [inst_2 : TopologicalSpace M‚ÇÅ] ‚Üí\n              [inst_3 : AddCommMonoid M‚ÇÅ] ‚Üí\n                {M‚ÇÇ : Type u_6} ‚Üí\n                  [inst_4 : TopologicalSpace M‚ÇÇ] ‚Üí\n                    [inst_5 : AddCommMonoid M‚ÇÇ] ‚Üí\n                      [inst_6 : Module R‚ÇÅ M‚ÇÅ] ‚Üí [inst_7 : Module R‚ÇÇ M‚ÇÇ] ‚Üí (M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) ‚Üí M‚ÇÅ ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ",
    "name": "ContinuousLinearMap.Simps.coe",
    "isProp": false,
    "doc": "See Note [custom simps projection]. ",
    "depth": 27}],
  "count": 147},
 {"noDocExamples": [],
  "kind": "Multiset.¬´term_::‚Çò_¬ª",
  "examples":
  [{"type":
    "{Œ± : Type u_1} ‚Üí\n  [inst : DecidableEq Œ±] ‚Üí\n    {Œ¥ : Œ± ‚Üí Sort v} ‚Üí (m : Multiset Œ±) ‚Üí (a : Œ±) ‚Üí Œ¥ a ‚Üí ((a : Œ±) ‚Üí a ‚àà m ‚Üí Œ¥ a) ‚Üí (a' : Œ±) ‚Üí a' ‚àà a ::‚Çò m ‚Üí Œ¥ a'",
    "name": "Multiset.Pi.cons",
    "isProp": false,
    "doc":
    "Given `Œ¥ : Œ± ‚Üí Type*`, a multiset `m` and a term `a`, as well as a term `b : Œ¥ a` and a\nfunction `f` such that `f a' : Œ¥ a'` for all `a'` in `m`, `Pi.cons m a b f` is a function `g` such\nthat `g a'' : Œ¥ a''` for all `a''` in `a ::‚Çò m`. ",
    "depth": 14},
   {"type":
    "{Œ± : Type u_1} ‚Üí\n  {C : Multiset Œ± ‚Üí Sort u_4} ‚Üí\n    C 0 ‚Üí\n      (C_cons : (a : Œ±) ‚Üí (m : Multiset Œ±) ‚Üí C m ‚Üí C (a ::‚Çò m)) ‚Üí\n        (‚àÄ (a a' : Œ±) (m : Multiset Œ±) (b : C m),\n            HEq (C_cons a (a' ::‚Çò m) (C_cons a' m b)) (C_cons a' (a ::‚Çò m) (C_cons a m b))) ‚Üí\n          (m : Multiset Œ±) ‚Üí C m",
    "name": "Multiset.rec",
    "isProp": false,
    "doc":
    "Dependent recursor on multisets.\nTODO: should be @[recursor 6], but then the definition of `Multiset.pi` fails with a stack\noverflow in `whnf`.\n",
    "depth": 18},
   {"type":
    "‚àÄ {A : Type u_2} [inst : CommRing A] [inst_1 : IsDomain A] [inst_2 : IsDedekindDomain A],\n  ¬¨IsField A ‚Üí\n    ‚àÄ {I M : Ideal A},\n      I ‚â† ‚ä• ‚Üí\n        I ‚â§ M ‚Üí\n          ‚àÄ [hM : Ideal.IsMaximal M],\n            ‚àÉ Z,\n              Multiset.prod (M ::‚Çò Multiset.map PrimeSpectrum.asIdeal Z) ‚â§ I ‚àß\n                ¬¨Multiset.prod (Multiset.map PrimeSpectrum.asIdeal Z) ‚â§ I",
    "name": "exists_multiset_prod_cons_le_and_prod_not_le",
    "isProp": true,
    "doc":
    "Specialization of `exists_primeSpectrum_prod_le_and_ne_bot_of_domain` to Dedekind domains:\nLet `I : Ideal A` be a nonzero ideal, where `A` is a Dedekind domain that is not a field.\nThen `exists_primeSpectrum_prod_le_and_ne_bot_of_domain` states we can find a product of prime\nideals that is contained within `I`. This lemma extends that result by making the product minimal:\nlet `M` be a maximal ideal that contains `I`, then the product including `M` is contained within `I`\nand the product excluding `M` is not contained within `I`. ",
    "depth": 29}],
  "count": 145},
 {"noDocExamples": [],
  "kind": "¬´term_‚Üí‚Çô+*_¬ª",
  "examples":
  [{"type": "(Œ± : Type u_5) ‚Üí [inst : NonUnitalNonAssocSemiring Œ±] ‚Üí Œ± ‚Üí‚Çô+* Œ±",
    "name": "NonUnitalRingHom.id",
    "isProp": false,
    "doc":
    "The identity non-unital ring homomorphism from a non-unital semiring to itself. ",
    "depth": 6},
   {"type":
    "(Œ± : Type u_1) ‚Üí (Œ≤ : Type u_2) ‚Üí [inst : NonUnitalNonAssocSemiring Œ≤] ‚Üí Œ≤ ‚Üí‚Çô+* Œ± ‚Üí Œ≤",
    "name": "Pi.constNonUnitalRingHom",
    "isProp": false,
    "doc": "`Function.const` as a `NonUnitalRingHom`. ",
    "depth": 7},
   {"type":
    "{R : Type u} ‚Üí\n  {S : Type v} ‚Üí [inst : NonUnitalNonAssocRing R] ‚Üí [inst_1 : NonUnitalNonAssocRing S] ‚Üí (R ‚Üí‚Çô+* S) ‚Üí NonUnitalSubring S",
    "name": "NonUnitalRingHom.range",
    "isProp": false,
    "doc":
    "The range of a ring homomorphism, as a `NonUnitalSubring` of the target.\nSee Note [range copy pattern]. ",
    "depth": 9}],
  "count": 143},
 {"noDocExamples": [],
  "kind": "Filter.¬´term‚àÉ·∂†_In_,_¬ª",
  "examples":
  [{"type":
    "‚àÄ {Œ± : Type u} {f : Ultrafilter Œ±} {p : Œ± ‚Üí Prop}, (‚àÉ·∂† (x : Œ±) in ‚Üëf, p x) ‚Üí ‚àÄ·∂† (x : Œ±) in ‚Üëf, p x",
    "name": "Filter.Frequently.eventually",
    "isProp": true,
    "doc":
    "**Alias** of the forward direction of `Ultrafilter.frequently_iff_eventually`.",
    "depth": 8},
   {"type":
    "‚àÄ {n : ‚Ñï}, n ‚â† 0 ‚Üí ‚àÄ (d : ‚Ñï), ‚àÉ·∂† (m : ‚Ñï) in Filter.atTop, m ‚â° d [MOD n]",
    "name": "Nat.frequently_modEq",
    "isProp": true,
    "doc": "Infinitely many natural numbers are equal to `d` mod `n`. ",
    "depth": 9},
   {"type":
    "‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±} {a : Œ±}, (‚àÉ·∂† (x : Œ±) in nhds a, x ‚àà s) ‚Üí a ‚àà closure s",
    "name": "Filter.Frequently.mem_closure",
    "isProp": true,
    "doc":
    "**Alias** of the reverse direction of `mem_closure_iff_frequently`.",
    "depth": 13}],
  "count": 141},
 {"noDocExamples": [],
  "kind": "MeasureTheory.¬´term‚à´‚Åª_In_,_‚àÇ_¬ª",
  "examples":
  [{"type":
    "‚àÄ {Œ± : Type u_1} {mŒ± : MeasurableSpace Œ±} (œÅ : MeasureTheory.Measure (Œ± √ó ‚Ñù)) [inst : MeasureTheory.IsFiniteMeasure œÅ]\n  (r : ‚Ñö) {s : Set Œ±},\n  MeasurableSet s ‚Üí\n    ‚à´‚Åª (a : Œ±) in s, ENNReal.ofReal (‚Üë(ProbabilityTheory.condCdf œÅ a) ‚Üër) ‚àÇMeasureTheory.Measure.fst œÅ =\n      ‚Üë‚ÜëœÅ (s √óÀ¢ Set.Iic ‚Üër)",
    "name": "ProbabilityTheory.set_lintegral_condCdf_rat",
    "isProp": true,
    "doc": "Auxiliary lemma for `set_lintegral_cond_cdf`. ",
    "depth": 18},
   {"type":
    "‚àÄ {Œ± : Type u_1} {m : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {Œπ : Type u_5} {f : Œ± ‚Üí ENNReal},\n  ‚à´‚Åª (x : Œ±), f x ‚àÇŒº ‚â† ‚ä§ ‚Üí\n    ‚àÄ {l : Filter Œπ} {s : Œπ ‚Üí Set Œ±},\n      Filter.Tendsto (‚Üë‚ÜëŒº ‚àò s) l (nhds 0) ‚Üí Filter.Tendsto (fun i => ‚à´‚Åª (x : Œ±) in s i, f x ‚àÇŒº) l (nhds 0)",
    "name": "MeasureTheory.tendsto_set_lintegral_zero",
    "isProp": true,
    "doc":
    "If `f` has finite integral, then `‚à´‚Åª x in s, f x ‚àÇŒº` is absolutely continuous in `s`: it tends\nto zero as `Œº s` tends to zero. ",
    "depth": 19},
   {"type":
    "‚àÄ {Œ± : Type u_1} [inst : MeasurableSpace Œ±] {Œº : MeasureTheory.Measure Œ±} [inst_1 : MeasureTheory.SigmaFinite Œº]\n  (C : ENNReal) {f : Œ± ‚Üí ENNReal},\n  AEMeasurable f ‚Üí (‚àÄ (s : Set Œ±), MeasurableSet s ‚Üí ‚Üë‚ÜëŒº s ‚â† ‚ä§ ‚Üí ‚à´‚Åª (x : Œ±) in s, f x ‚àÇŒº ‚â§ C) ‚Üí ‚à´‚Åª (x : Œ±), f x ‚àÇŒº ‚â§ C",
    "name": "MeasureTheory.lintegral_le_of_forall_fin_meas_le",
    "isProp": true,
    "doc":
    "If the Lebesgue integral of a function is bounded by some constant on all sets with finite\nmeasure and the measure is œÉ-finite, then the integral over the whole space is bounded by that same\nconstant. ",
    "depth": 21}],
  "count": 135},
 {"noDocExamples": [],
  "kind": "¬´term_‚Ü™o_¬ª",
  "examples":
  [{"type": "Cardinal.{v} ‚Ü™o Cardinal.{max v u}",
    "name": "Cardinal.liftOrderEmbedding",
    "isProp": false,
    "doc": "`Cardinal.lift` as an `OrderEmbedding`. ",
    "depth": 4},
   {"type": "Cardinal.{u_3} ‚Ü™o Ordinal.{u_3}",
    "name": "Cardinal.ord.orderEmbedding",
    "isProp": false,
    "doc":
    "The ordinal corresponding to a cardinal `c` is the least ordinal\nwhose cardinal is `c`. This is the order-embedding version. For the regular function, see `ord`.\n",
    "depth": 4},
   {"type": "Ordinal.{u} ‚Ü™o SetTheory.PGame",
    "name": "Ordinal.toPGameEmbedding",
    "isProp": false,
    "doc": "The order embedding version of `toPGame`. ",
    "depth": 5}],
  "count": 134},
 {"noDocExamples": [],
  "kind": "¬´term_‚âÉ·µ¢_¬ª",
  "examples":
  [{"type": "(Œ± : Type u_2) ‚Üí [inst : PseudoEMetricSpace Œ±] ‚Üí Œ± ‚âÉ·µ¢ Œ±",
    "name": "IsometryEquiv.refl",
    "isProp": false,
    "doc": "The identity isometry of a space. ",
    "depth": 6},
   {"type": "{Œ± : Type u} ‚Üí [inst : PseudoEMetricSpace Œ±] ‚Üí Group (Œ± ‚âÉ·µ¢ Œ±)",
    "name": "IsometryEquiv.instGroupIsometryEquiv",
    "isProp": false,
    "doc": "The group of isometries. ",
    "depth": 7},
   {"type":
    "{Œ± : Type u} ‚Üí {Œ≤ : Type v} ‚Üí [inst : PseudoEMetricSpace Œ±] ‚Üí [inst_1 : PseudoEMetricSpace Œ≤] ‚Üí Œ± ‚âÉ·µ¢ Œ≤ ‚Üí Œ≤ ‚âÉ·µ¢ Œ±",
    "name": "IsometryEquiv.symm",
    "isProp": false,
    "doc":
    "The inverse of an isometric isomorphism, as an isometric isomorphism. ",
    "depth": 9}],
  "count": 132},
 {"noDocExamples": [],
  "kind": "¬´term_[Œõ^_]‚ÜíL[_]_¬ª",
  "examples":
  [{"type":
    "(R : Type u_1) ‚Üí\n  (M : Type u_2) ‚Üí\n    {Œπ : Type u_6} ‚Üí\n      [inst : Semiring R] ‚Üí\n        [inst_1 : AddCommMonoid M] ‚Üí\n          [inst_2 : Module R M] ‚Üí [inst_3 : TopologicalSpace M] ‚Üí [inst_4 : Subsingleton Œπ] ‚Üí Œπ ‚Üí M[Œõ^Œπ]‚ÜíL[R]M",
    "name": "ContinuousAlternatingMap.ofSubsingleton",
    "isProp": false,
    "doc":
    "The evaluation map from `Œπ ‚Üí M` to `M` is alternating at a given `i` when `Œπ` is subsingleton.\n",
    "depth": 20},
   {"type":
    "{R : Type u_1} ‚Üí\n  {M : Type u_2} ‚Üí\n    {N : Type u_3} ‚Üí\n      {Œπ : Type u_4} ‚Üí\n        [inst : Semiring R] ‚Üí\n          [inst_1 : AddCommMonoid M] ‚Üí\n            [inst_2 : Module R M] ‚Üí\n              [inst_3 : TopologicalSpace M] ‚Üí\n                [inst_4 : AddCommMonoid N] ‚Üí\n                  [inst_5 : Module R N] ‚Üí\n                    [inst_6 : TopologicalSpace N] ‚Üí M[Œõ^Œπ]‚ÜíL[R]N ‚Üí ContinuousMultilinearMap R (fun x => M) N",
    "name": "ContinuousAlternatingMap.toContinuousMultilinearMap",
    "isProp": false,
    "doc": "Projection to `ContinuousMultilinearMap`s. ",
    "depth": 23},
   {"type":
    "{R : Type u_1} ‚Üí\n  {M : Type u_2} ‚Üí\n    {N : Type u_3} ‚Üí\n      {Œπ : Type u_4} ‚Üí\n        [inst : Semiring R] ‚Üí\n          [inst_1 : AddCommMonoid M] ‚Üí\n            [inst_2 : Module R M] ‚Üí\n              [inst_3 : TopologicalSpace M] ‚Üí\n                [inst_4 : AddCommMonoid N] ‚Üí\n                  [inst_5 : Module R N] ‚Üí [inst_6 : TopologicalSpace N] ‚Üí M[Œõ^Œπ]‚ÜíL[R]N ‚Üí AlternatingMap R M N Œπ",
    "name": "ContinuousAlternatingMap.toAlternatingMap",
    "isProp": false,
    "doc": "Projection to `AlternatingMap`s. ",
    "depth": 23}],
  "count": 129},
 {"noDocExamples": [],
  "kind": "¬´term_‚âÉ·µê_¬ª",
  "examples":
  [{"type": "ENNReal ‚âÉ·µê NNReal ‚äï Unit",
    "name": "ENNReal.ennrealEquivSum",
    "isProp": false,
    "doc": "`‚Ñù‚â•0‚àû` is `MeasurableEquiv` to `‚Ñù‚â•0 ‚äï Unit`. ",
    "depth": 5},
   {"type": "‚ÑÇ ‚âÉ·µê ‚Ñù √ó ‚Ñù",
    "name": "Complex.measurableEquivRealProd",
    "isProp": false,
    "doc": "Measurable equivalence between `‚ÑÇ` and `‚Ñù √ó ‚Ñù`. ",
    "depth": 5},
   {"type": "(Œ± : Type u_6) ‚Üí [inst : MeasurableSpace Œ±] ‚Üí Œ± ‚âÉ·µê Œ±",
    "name": "MeasurableEquiv.refl",
    "isProp": false,
    "doc": "Any measurable space is equivalent to itself. ",
    "depth": 6}],
  "count": 128},
 {"noDocExamples":
  [{"type":
    "‚àÄ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {X Y : C} (Œ± : X ‚âÖ Y), Œ± ‚â™‚â´ CategoryTheory.Iso.refl Y = Œ±",
    "name": "CategoryTheory.Iso.trans_refl",
    "isProp": true,
    "depth": 14}],
  "kind": "CategoryTheory.Iso.¬´term_‚â™‚â´_¬ª",
  "examples":
  [{"type":
    "‚àÄ {B : Type u} [inst : CategoryTheory.Bicategory B] {a b : B} (self : CategoryTheory.Bicategory.Equivalence a b),\n  CategoryTheory.Bicategory.leftZigzagIso self.unit self.counit =\n    CategoryTheory.Bicategory.leftUnitor self.hom ‚â™‚â´ (CategoryTheory.Bicategory.rightUnitor self.hom).symm",
    "name": "CategoryTheory.Bicategory.Equivalence.left_triangle",
    "isProp": true,
    "doc":
    "The composition of the unit and the counit is equal to the identity up to unitors. ",
    "depth": 19},
   {"type":
    "‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D]\n  {F G H : CategoryTheory.Functor C D} (e : F ‚âÖ G) (e' : G ‚âÖ H) (hF : CategoryTheory.IsEquivalence F),\n  CategoryTheory.IsEquivalence.ofIso e' (CategoryTheory.IsEquivalence.ofIso e hF) =\n    CategoryTheory.IsEquivalence.ofIso (e ‚â™‚â´ e') hF",
    "name": "CategoryTheory.IsEquivalence.ofIso_trans",
    "isProp": true,
    "doc":
    "Compatibility of `ofIso` with the composition of isomorphisms of functors ",
    "depth": 24}],
  "count": 128},
 {"noDocExamples":
  [{"type": "{M : Type u_1} ‚Üí [inst : Group M·µê·µí·µñ] ‚Üí Group M·µà·µê·µÉ",
    "name": "DomMulAct.instGroupDomMulAct",
    "isProp": false,
    "depth": 4},
   {"type": "{M : Type u_1} ‚Üí [inst : Inv M·µê·µí·µñ] ‚Üí Inv M·µà·µê·µÉ",
    "name": "DomMulAct.instInvDomMulAct",
    "isProp": false,
    "depth": 4}],
  "kind": "¬´term_·µà·µê·µÉ¬ª",
  "examples":
  [{"type": "{M : Type u_1} ‚Üí M ‚âÉ M·µà·µê·µÉ",
    "name": "DomMulAct.mk",
    "isProp": false,
    "doc": "Equivalence between `M` and `M·µà·µê·µÉ`. ",
    "depth": 3}],
  "count": 127},
 {"noDocExamples": [],
  "kind": "¬´term‚àè·∂†_,_¬ª",
  "examples":
  [{"type":
    "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {M : Type u_5} [inst : CommMonoid M] {g : Œ≤ ‚Üí M} (e : Œ± ‚Üí Œ≤),\n  Function.Bijective e ‚Üí ‚àè·∂† (i : Œ±), g (e i) = ‚àè·∂† (j : Œ≤), g j",
    "name": "finprod_comp",
    "isProp": true,
    "doc":
    "See also `finprod_eq_of_bijective`, `Fintype.prod_bijective` and `Finset.prod_bij`. ",
    "depth": 13},
   {"type":
    "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {M : Type u_5} [inst : CommMonoid M] {f : Œ± ‚Üí M} {g : Œ≤ ‚Üí M} (e : Œ± ‚Üí Œ≤),\n  Function.Bijective e ‚Üí (‚àÄ (x : Œ±), f x = g (e x)) ‚Üí ‚àè·∂† (i : Œ±), f i = ‚àè·∂† (j : Œ≤), g j",
    "name": "finprod_eq_of_bijective",
    "isProp": true,
    "doc":
    "See `finprod_comp`, `Fintype.prod_bijective` and `Finset.prod_bij`. ",
    "depth": 15},
   {"type":
    "‚àÄ {Œ± : Type u_1} {M : Type u_5} [inst : CommMonoid M] (s : Set Œ±), ‚àè·∂† (i : Œ±) (_ : i ‚àà s), 1 = 1",
    "name": "finprod_mem_one",
    "isProp": true,
    "doc": "The product of the constant function `1` over any set equals `1`. ",
    "depth": 16}],
  "count": 127},
 {"noDocExamples": [],
  "kind": "CategoryTheory.Limits.¬´term‚ä§__¬ª",
  "examples":
  [{"type":
    "{C : Type u‚ÇÅ} ‚Üí\n  [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] ‚Üí\n    [inst_1 : CategoryTheory.Limits.HasTerminal C] ‚Üí CategoryTheory.Limits.IsTerminal (‚ä§_ C)",
    "name": "CategoryTheory.Limits.terminalIsTerminal",
    "isProp": false,
    "doc": "A terminal object is terminal. ",
    "depth": 7},
   {"type": "‚ä§_ TopCat ‚âÖ TopCat.of PUnit.{u + 1}",
    "name": "TopCat.terminalIsoPUnit",
    "isProp": false,
    "doc": "The terminal object of `Top` is `PUnit`. ",
    "depth": 8},
   {"type":
    "{C : Type u‚ÇÅ} ‚Üí\n  [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] ‚Üí\n    [inst_1 : CategoryTheory.Limits.HasTerminal C] ‚Üí {P : C} ‚Üí CategoryTheory.Limits.IsTerminal P ‚Üí (‚ä§_ C ‚âÖ P)",
    "name": "CategoryTheory.Limits.terminalIsoIsTerminal",
    "isProp": false,
    "doc":
    "The (unique) isomorphism between the chosen terminal object and any other terminal object. ",
    "depth": 10}],
  "count": 126},
 {"noDocExamples": [],
  "kind": "¬´term_‚Üí‚Çó‚ÅÖ_,_‚ÅÜ_¬ª",
  "examples":
  [{"type":
    "{R : Type u} ‚Üí\n  {L : Type v} ‚Üí\n    {M : Type w} ‚Üí\n      [inst : CommRing R] ‚Üí\n        [inst_1 : LieRing L] ‚Üí\n          [inst_2 : AddCommGroup M] ‚Üí [inst_3 : Module R M] ‚Üí [inst_4 : LieRingModule L M] ‚Üí M ‚Üí‚Çó‚ÅÖR,L‚ÅÜ M",
    "name": "LieModuleHom.id",
    "isProp": false,
    "doc": "The identity map is a morphism of Lie modules. ",
    "depth": 20},
   {"type":
    "{R : Type u} ‚Üí\n  {L : Type v} ‚Üí\n    {M : Type w} ‚Üí\n      [inst : CommRing R] ‚Üí\n        [inst_1 : LieRing L] ‚Üí\n          [inst_2 : AddCommGroup M] ‚Üí [inst_3 : Module R M] ‚Üí [inst_4 : LieRingModule L M] ‚Üí One (M ‚Üí‚Çó‚ÅÖR,L‚ÅÜ M)",
    "name": "LieModuleHom.instOneLieModuleHom",
    "isProp": false,
    "doc": "The identity map is a Lie module morphism. ",
    "depth": 21},
   {"type":
    "{R : Type u} ‚Üí\n  {L : Type v} ‚Üí\n    {M : Type w} ‚Üí\n      {N : Type w‚ÇÅ} ‚Üí\n        [inst : CommRing R] ‚Üí\n          [inst_1 : LieRing L] ‚Üí\n            [inst_2 : AddCommGroup M] ‚Üí\n              [inst_3 : Module R M] ‚Üí\n                [inst_4 : LieRingModule L M] ‚Üí\n                  [inst_5 : AddCommGroup N] ‚Üí\n                    [inst_6 : Module R N] ‚Üí [inst_7 : LieRingModule L N] ‚Üí (M ‚Üí‚Çó‚ÅÖR,L‚ÅÜ N) ‚Üí LieSubmodule R L N",
    "name": "LieModuleHom.range",
    "isProp": false,
    "doc":
    "The range of a morphism of Lie modules `f : M ‚Üí N` is a Lie submodule of `N`.\nSee Note [range copy pattern]. ",
    "depth": 25}],
  "count": 126},
 {"noDocExamples": [],
  "kind": "¬´term_‚Üí‚Çô‚Çê[_]_¬ª",
  "examples":
  [{"type":
    "(R : Type u_1) ‚Üí\n  (A : Type u_2) ‚Üí\n    [inst : Monoid R] ‚Üí [inst_1 : NonUnitalNonAssocSemiring A] ‚Üí [inst_2 : DistribMulAction R A] ‚Üí A ‚Üí‚Çô‚Çê[R] A",
    "name": "NonUnitalAlgHom.id",
    "isProp": false,
    "doc": "The identity map as a `NonUnitalAlgHom`. ",
    "depth": 13},
   {"type":
    "(R : Type u) ‚Üí\n  {X : Type v} ‚Üí [inst : CommRing R] ‚Üí FreeNonUnitalNonAssocAlgebra R X ‚Üí‚Çô‚Çê[R] CommutatorRing (FreeLieAlgebra R X)",
    "name": "FreeLieAlgebra.mk",
    "isProp": false,
    "doc": "The quotient map as a `NonUnitalAlgHom`. ",
    "depth": 15},
   {"type":
    "(R : Type u_1) ‚Üí\n  (A : Type u_2) ‚Üí\n    [inst : CommSemiring R] ‚Üí [inst_1 : NonUnitalSemiring A] ‚Üí [inst_2 : Module R A] ‚Üí A ‚Üí‚Çô‚Çê[R] Unitization R A",
    "name": "Unitization.inrNonUnitalAlgHom",
    "isProp": false,
    "doc":
    "The coercion from a non-unital `R`-algebra `A` to its unitization `Unitization R A`\nrealized as a non-unital algebra homomorphism. ",
    "depth": 16}],
  "count": 126},
 {"noDocExamples": [],
  "kind": "¬´term_‚Üí*‚ÇÄ_¬ª",
  "examples":
  [{"type": "NNReal ‚Üí*‚ÇÄ NNReal",
    "name": "NNReal.sqrtHom",
    "isProp": false,
    "doc": "`NNReal.sqrt` as a `MonoidWithZeroHom`. ",
    "depth": 5},
   {"type": "‚Ñù ‚Üí*‚ÇÄ NNReal",
    "name": "Real.nnabs",
    "isProp": false,
    "doc": "The absolute value on `‚Ñù` as a map to `‚Ñù‚â•0`. ",
    "depth": 5},
   {"type": "‚Ñ§ ‚Üí*‚ÇÄ ‚Ñï",
    "name": "Int.natAbsHom",
    "isProp": false,
    "doc": "`Int.natAbs` as a bundled monoid with zero hom. ",
    "depth": 5}],
  "count": 125},
 {"noDocExamples": [],
  "kind": "Prefunctor.¬´term_‚•§q_¬ª",
  "examples":
  [{"type": "{V : Type u_2} ‚Üí [inst : Quiver V] ‚Üí V ‚•§q Quiver.Symmetrify V",
    "name": "Quiver.Symmetrify.of",
    "isProp": false,
    "doc": "The inclusion of a quiver in its symmetrification ",
    "depth": 6},
   {"type":
    "{B : Type u} ‚Üí [inst : Quiver B] ‚Üí B ‚•§q CategoryTheory.FreeBicategory B",
    "name": "CategoryTheory.FreeBicategory.of",
    "isProp": false,
    "doc": "Canonical prefunctor from `B` to `free_bicategory B`. ",
    "depth": 6},
   {"type": "(V : Type u_1) ‚Üí [inst : Quiver V] ‚Üí V ‚•§q V",
    "name": "Prefunctor.id",
    "isProp": false,
    "doc": "The identity morphism between quivers. ",
    "depth": 6}],
  "count": 124},
 {"noDocExamples": [],
  "kind": "¬´term_‚Ü™r_¬ª",
  "examples":
  [{"type": "{Œ± : Type u_1} ‚Üí (r : Œ± ‚Üí Œ± ‚Üí Prop) ‚Üí r ‚Ü™r r",
    "name": "RelEmbedding.refl",
    "isProp": false,
    "doc": "Identity map is a relation embedding. ",
    "depth": 6},
   {"type":
    "{Œ± : Type u_1} ‚Üí (r : Œ± ‚Üí Œ± ‚Üí Prop) ‚Üí (p : Set Œ±) ‚Üí Subrel r p ‚Ü™r r",
    "name": "Subrel.relEmbedding",
    "isProp": false,
    "doc": "The relation embedding from the inherited relation on a subset. ",
    "depth": 9},
   {"type":
    "{Œ± : Type u_1} ‚Üí {Œ≤ : Type u_2} ‚Üí (r : Œ± ‚Üí Œ± ‚Üí Prop) ‚Üí (s : Œ≤ ‚Üí Œ≤ ‚Üí Prop) ‚Üí s ‚Ü™r Sum.Lex r s",
    "name": "RelEmbedding.sumLexInr",
    "isProp": false,
    "doc": "`Sum.inr` as a relation embedding into `Sum.Lex r s`. ",
    "depth": 9}],
  "count": 121},
 {"noDocExamples": [],
  "kind": "CategoryTheory.Limits.¬´term_‚®Ø_¬ª",
  "examples":
  [{"type":
    "{C : Type u} ‚Üí\n  [inst : CategoryTheory.Category.{v, u} C] ‚Üí\n    (X : C) ‚Üí [inst_1 : CategoryTheory.Limits.HasBinaryProduct X X] ‚Üí X ‚ü∂ X ‚®Ø X",
    "name": "CategoryTheory.Limits.diag",
    "isProp": false,
    "doc": "diagonal arrow of the binary product in the category `fam I` ",
    "depth": 10},
   {"type": "(X Y : Type u) ‚Üí X ‚®Ø Y ‚âÖ X √ó Y",
    "name": "CategoryTheory.Limits.Types.binaryProductIso",
    "isProp": false,
    "doc": "The categorical binary product in `Type u` is cartesian product. ",
    "depth": 12},
   {"type": "(X Y : TopCat) ‚Üí X ‚®Ø Y ‚âÖ TopCat.of (‚ÜëX √ó ‚ÜëY)",
    "name": "TopCat.prodIsoProd",
    "isProp": false,
    "doc":
    "The homeomorphism between `X ‚®Ø Y` and the set-theoretic product of `X` and `Y`,\nequipped with the product topology.\n",
    "depth": 12}],
  "count": 120},
 {"noDocExamples": [],
  "kind": "¬´term‚Ñ§_[_]¬ª",
  "examples":
  [{"type": "{p : ‚Ñï} ‚Üí [inst : Fact (Nat.Prime p)] ‚Üí Add ‚Ñ§_[p]",
    "name": "PadicInt.instAddPadicInt",
    "isProp": false,
    "doc": "Addition on `‚Ñ§_[p]` is inherited from `‚Ñö_[p]`. ",
    "depth": 5},
   {"type": "{p : ‚Ñï} ‚Üí [hp_prime : Fact (Nat.Prime p)] ‚Üí ‚Ñ§_[p] ‚Üí ‚Ñï",
    "name": "PadicInt.zmodRepr",
    "isProp": false,
    "doc":
    "`zmod_repr x` is the unique natural number smaller than `p`\nsatisfying `‚Äñ(x - zmod_repr x : ‚Ñ§_[p])‚Äñ < 1`.\n",
    "depth": 5},
   {"type": "{p : ‚Ñï} ‚Üí [inst : Fact (Nat.Prime p)] ‚Üí Mul ‚Ñ§_[p]",
    "name": "PadicInt.instMulPadicInt",
    "isProp": false,
    "doc": "Multiplication on `‚Ñ§_[p]` is inherited from `‚Ñö_[p]`. ",
    "depth": 5}],
  "count": 120},
 {"noDocExamples": [],
  "kind": "¬´term_‚§≥_¬ª",
  "examples":
  [{"type":
    "‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : RegularSpace Œ±] {a b : Œ±}, a ‚§≥ b ‚Üí b ‚§≥ a",
    "name": "Specializes.symm",
    "isProp": true,
    "doc": "**Alias** of the forward direction of `specializes_comm`.",
    "depth": 10},
   {"type":
    "‚àÄ {X : Type u_1} [inst : TopologicalSpace X] {x y : X}, x ‚§≥ y ‚Üí y ‚àà closure {x}",
    "name": "Specializes.mem_closure",
    "isProp": true,
    "doc":
    "**Alias** of the forward direction of `specializes_iff_mem_closure`.",
    "depth": 11},
   {"type":
    "‚àÄ {X : Type u_1} [inst : TopologicalSpace X] {x y : X}, x ‚§≥ y ‚Üí pure x ‚â§ nhds y",
    "name": "Specializes.pure_le_nhds",
    "isProp": true,
    "doc": "**Alias** of the forward direction of `specializes_iff_pure`.",
    "depth": 12}],
  "count": 118},
 {"noDocExamples": [],
  "kind": "¬´term_‚âÉ‚Çó·µ¢[_]_¬ª",
  "examples":
  [{"type": "‚ÑÇ ‚âÉ‚Çó·µ¢[‚Ñù] ‚ÑÇ",
    "name": "Complex.conjLie",
    "isProp": false,
    "doc":
    "The complex-conjugation function from `‚ÑÇ` to itself is an isometric linear equivalence. ",
    "depth": 14},
   {"type": "(‚ÑÇ ‚âÉ‚Çó·µ¢[‚Ñù] ‚ÑÇ) ‚Üí { x // x ‚àà circle }",
    "name": "rotationOf",
    "isProp": false,
    "doc":
    "Takes an element of `‚ÑÇ ‚âÉ‚Çó·µ¢[‚Ñù] ‚ÑÇ` and checks if it is a rotation, returns an element of the\nunit circle. ",
    "depth": 15},
   {"type": "{K : Type u_1} ‚Üí [inst : IsROrC K] ‚Üí K ‚âÉ‚Çó·µ¢[‚Ñù] K",
    "name": "IsROrC.conjLie",
    "isProp": false,
    "doc": "Conjugate as a linear isometry ",
    "depth": 16}],
  "count": 118},
 {"noDocExamples": [],
  "kind": "Hyperreal.¬´term‚Ñù*¬ª",
  "examples":
  [{"type": "‚Ñù*",
    "name": "Hyperreal.epsilon",
    "isProp": false,
    "doc": "A sample infinitesimal hyperreal",
    "depth": 0},
   {"type": "‚Ñù*",
    "name": "Hyperreal.omega",
    "isProp": false,
    "doc": "A sample infinite hyperreal",
    "depth": 0},
   {"type": "‚Ñù* ‚Üí Prop",
    "name": "Hyperreal.InfiniteNeg",
    "isProp": false,
    "doc":
    "A hyperreal number is negative infinite if it is smaller than all real numbers ",
    "depth": 1}],
  "count": 117},
 {"noDocExamples": [],
  "kind": "CategoryTheory.Limits.¬´term‚®Å_¬ª",
  "examples":
  [{"type":
    "{J : Type} ‚Üí [inst : Fintype J] ‚Üí (f : J ‚Üí AddCommGroupCat) ‚Üí ‚®Å f ‚âÖ AddCommGroupCat.of ((j : J) ‚Üí ‚Üë(f j))",
    "name": "AddCommGroupCat.biproductIsoPi",
    "isProp": false,
    "doc":
    "We verify that the biproduct we've just defined is isomorphic to the `AddCommGroupCat` structure\non the dependent function type.\n",
    "depth": 14},
   {"type":
    "{J : Type w} ‚Üí\n  {C : Type u} ‚Üí\n    [inst : CategoryTheory.Category.{v, u} C] ‚Üí\n      [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] ‚Üí\n        (f : J ‚Üí C) ‚Üí [inst_2 : CategoryTheory.Limits.HasBiproduct f] ‚Üí (b : J) ‚Üí f b ‚ü∂ ‚®Å f",
    "name": "CategoryTheory.Limits.biproduct.Œπ",
    "isProp": false,
    "doc": "The inclusion into a summand of a biproduct. ",
    "depth": 14},
   {"type":
    "{J : Type w} ‚Üí\n  {C : Type u} ‚Üí\n    [inst : CategoryTheory.Category.{v, u} C] ‚Üí\n      [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] ‚Üí\n        (f : J ‚Üí C) ‚Üí [inst_2 : CategoryTheory.Limits.HasBiproduct f] ‚Üí ‚®Å f ‚âÖ ‚àè f",
    "name": "CategoryTheory.Limits.biproduct.isoProduct",
    "isProp": false,
    "doc":
    "The canonical isomorphism between the chosen biproduct and the chosen product. ",
    "depth": 14}],
  "count": 116},
 {"noDocExamples": [],
  "kind": "Nat.¬´term_‚â°_[MOD_]¬ª",
  "examples":
  [{"type":
    "‚àÄ {n : ‚Ñï}, n ‚â† 0 ‚Üí ‚àÄ (d : ‚Ñï), ‚àÉ·∂† (m : ‚Ñï) in Filter.atTop, m ‚â° d [MOD n]",
    "name": "Nat.frequently_modEq",
    "isProp": true,
    "doc": "Infinitely many natural numbers are equal to `d` mod `n`. ",
    "depth": 9},
   {"type": "‚àÄ {k : ‚Ñï}, k ‚â† 0 ‚Üí Set.Infinite {p | Nat.Prime p ‚àß p ‚â° 1 [MOD k]}",
    "name": "Nat.infinite_setOf_prime_modEq_one",
    "isProp": true,
    "doc":
    "For any positive `k : ‚Ñï` there are infinitely many primes `p` such that `p ‚â° 1 [MOD k]`. ",
    "depth": 10},
   {"type": "‚àÄ {n a b : ‚Ñï}, a ‚â° b [MOD n] ‚Üí ‚Üën ‚à£ ‚Üëb - ‚Üëa",
    "name": "Nat.ModEq.dvd",
    "isProp": true,
    "doc": "**Alias** of the forward direction of `Nat.modEq_iff_dvd`.",
    "depth": 11}],
  "count": 110},
 {"noDocExamples": [],
  "kind": "Submodule.¬´term_·óÆ¬ª",
  "examples":
  [{"type":
    "‚àÄ {ùïú : Type u_1} {E : Type u_2} [inst : IsROrC ùïú] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ùïú E]\n  {K : Submodule ùïú E} [inst_3 : CompleteSpace E], K·óÆ·óÆ·óÆ = K·óÆ",
    "name": "Submodule.triorthogonal_eq_orthogonal",
    "isProp": true,
    "doc": "The orthogonal complement satisfies `K·óÆ·óÆ·óÆ = K·óÆ`. ",
    "depth": 20},
   {"type":
    "‚àÄ {ùïú : Type u_1} {E : Type u_2} [inst : IsROrC ùïú] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ùïú E]\n  (K : Submodule ùïú E) [inst_3 : HasOrthogonalProjection K], K·óÆ·óÆ = K",
    "name": "Submodule.orthogonal_orthogonal",
    "isProp": true,
    "doc":
    "If `K` admits an orthogonal projection, then the orthogonal complement of its orthogonal\ncomplement is itself. ",
    "depth": 20},
   {"type":
    "‚àÄ {ùïú : Type u_1} {E : Type u_2} [inst : IsROrC ùïú] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ùïú E]\n  (K : Submodule ùïú E), IsClosed ‚ÜëK·óÆ",
    "name": "Submodule.isClosed_orthogonal",
    "isProp": true,
    "doc": "The orthogonal complement of any submodule `K` is closed. ",
    "depth": 21}],
  "count": 109},
 {"noDocExamples": [],
  "kind": "Int.¬´term‚åä_‚åã¬ª",
  "examples":
  [{"type": "‚àÄ (Œæ : ‚Ñù), Real.convergent Œæ 0 = ‚Üë‚åäŒæ‚åã",
    "name": "Real.convergent_zero",
    "isProp": true,
    "doc": "The zeroth convergent of `Œæ` is `‚åäŒæ‚åã`. ",
    "depth": 7},
   {"type":
    "‚àÄ (Œæ : ‚Ñù) (n : ‚Ñï), Real.convergent Œæ (n + 1) = ‚Üë‚åäŒæ‚åã + (Real.convergent (Int.fract Œæ)‚Åª¬π n)‚Åª¬π",
    "name": "Real.convergent_succ",
    "isProp": true,
    "doc":
    "The `(n+1)`th convergent of `Œæ` is the `n`th convergent of `1/(fract Œæ)`. ",
    "depth": 12},
   {"type":
    "‚àÄ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] {v : K},\n  (GeneralizedContinuedFraction.of v).h = ‚Üë‚åäv‚åã",
    "name": "GeneralizedContinuedFraction.of_h_eq_floor",
    "isProp": true,
    "doc": "The head term of the gcf of `v` is `‚åäv‚åã`. ",
    "depth": 13}],
  "count": 106},
 {"noDocExamples": [],
  "kind": "¬´term‚Ñö_[_]¬ª",
  "examples":
  [{"type": "{p : ‚Ñï} ‚Üí [hp : Fact (Nat.Prime p)] ‚Üí ‚Ñö_[p] ‚Üí ‚Ñö",
    "name": "padicNormE.ratNorm",
    "isProp": false,
    "doc":
    "`ratNorm q`, for a `p`-adic number `q` is the `p`-adic norm of `q`, as rational number.\n\nThe lemma `padicNormE.eq_ratNorm` asserts `‚Äñq‚Äñ = ratNorm q`. ",
    "depth": 5},
   {"type": "{p : ‚Ñï} ‚Üí [hp : Fact (Nat.Prime p)] ‚Üí ‚Ñö_[p] ‚Üí WithTop ‚Ñ§",
    "name": "Padic.addValuationDef",
    "isProp": false,
    "doc":
    "The additive `p`-adic valuation on `‚Ñö_[p]`, with values in `WithTop ‚Ñ§`. ",
    "depth": 5},
   {"type": "{p : ‚Ñï} ‚Üí [hp : Fact (Nat.Prime p)] ‚Üí ‚Ñö_[p] ‚Üí ‚Ñ§",
    "name": "Padic.valuation",
    "isProp": false,
    "doc":
    "`Padic.valuation` lifts the `p`-adic valuation on rationals to `‚Ñö_[p]`. ",
    "depth": 5}],
  "count": 102},
 {"noDocExamples": [],
  "kind": "¬´term‚à´_In_.._,_‚àÇ_¬ª",
  "examples":
  [{"type":
    "‚àÄ {E : Type u_3} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] {f g : ‚Ñù ‚Üí E} {Œº : MeasureTheory.Measure ‚Ñù}\n  {a b : ‚Ñù}, Set.EqOn f g (Set.uIcc a b) ‚Üí ‚à´ (x : ‚Ñù) in a..b, f x ‚àÇŒº = ‚à´ (x : ‚Ñù) in a..b, g x ‚àÇŒº",
    "name": "intervalIntegral.integral_congr",
    "isProp": true,
    "doc":
    "If two functions are equal in the relevant interval, their interval integrals are also equal. ",
    "depth": 18},
   {"type":
    "‚àÄ {f : ‚Ñù ‚Üí ‚Ñù} {a b : ‚Ñù} {Œº : MeasureTheory.Measure ‚Ñù},\n  0 ‚â§·∂†[MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict Œº (Œô a b))] f ‚Üí\n    IntervalIntegrable f Œº a b ‚Üí (0 < ‚à´ (x : ‚Ñù) in a..b, f x ‚àÇŒº ‚Üî a < b ‚àß 0 < ‚Üë‚ÜëŒº (Function.support f ‚à© Set.Ioc a b))",
    "name": "intervalIntegral.integral_pos_iff_support_of_nonneg_ae'",
    "isProp": true,
    "doc":
    "If `f` is nonnegative and integrable on the unordered interval `Set.uIoc a b`, then its\nintegral over `a..b` is positive if and only if `a < b` and the measure of\n`Function.support f ‚à© Set.Ioc a b` is positive. ",
    "depth": 19},
   {"type":
    "‚àÄ {f : ‚Ñù ‚Üí ‚Ñù} {a b : ‚Ñù} {Œº : MeasureTheory.Measure ‚Ñù},\n  0 ‚â§·∂†[MeasureTheory.Measure.ae Œº] f ‚Üí\n    IntervalIntegrable f Œº a b ‚Üí (0 < ‚à´ (x : ‚Ñù) in a..b, f x ‚àÇŒº ‚Üî a < b ‚àß 0 < ‚Üë‚ÜëŒº (Function.support f ‚à© Set.Ioc a b))",
    "name": "intervalIntegral.integral_pos_iff_support_of_nonneg_ae",
    "isProp": true,
    "doc":
    "If `f` is nonnegative a.e.-everywhere and it is integrable on the unordered interval\n`Set.uIoc a b`, then its integral over `a..b` is positive if and only if `a < b` and the\nmeasure of `Function.support f ‚à© Set.Ioc a b` is positive. ",
    "depth": 19}],
  "count": 101},
 {"noDocExamples": [],
  "kind": "¬´term_√ó'_¬ª",
  "examples":
  [{"type":
    "{Œ± : Type u_2} ‚Üí (Œ≤ : Œ± ‚Üí Type u_1) ‚Üí (i : Œ±) √ó' Œ≤ i ‚âÉ (i : Œ±) √ó Œ≤ i",
    "name": "Equiv.psigmaEquivSigma",
    "isProp": false,
    "doc": "A `PSigma`-type is equivalent to the corresponding `Sigma`-type. ",
    "depth": 7},
   {"type": "{Œ± : Type v} ‚Üí (P : Œ± ‚Üí Prop) ‚Üí (i : Œ±) √ó' P i ‚âÉ Subtype P",
    "name": "Equiv.psigmaEquivSubtype",
    "isProp": false,
    "doc": "A `PSigma` with `Prop` fibers is equivalent to the subtype.  ",
    "depth": 7},
   {"type":
    "(G : Type u_1) ‚Üí [inst : Group G] ‚Üí ‚Ñï ‚Üí (H : Subgroup G) √ó' Subgroup.Normal H",
    "name": "upperCentralSeriesAux",
    "isProp": false,
    "doc":
    "An auxiliary type-theoretic definition defining both the upper central series of\na group, and a proof that it is normal, all in one go. ",
    "depth": 8}],
  "count": 101},
 {"noDocExamples": [],
  "kind": "¬´term_‚âÉr_¬ª",
  "examples":
  [{"type": "{Œ± : Type u_1} ‚Üí (r : Œ± ‚Üí Œ± ‚Üí Prop) ‚Üí r ‚âÉr r",
    "name": "RelIso.refl",
    "isProp": false,
    "doc": "Identity map is a relation isomorphism. ",
    "depth": 6},
   {"type":
    "{Œ± : Type u_1} ‚Üí {Œ≤ : Type u_2} ‚Üí {r : Œ± ‚Üí Œ± ‚Üí Prop} ‚Üí {s : Œ≤ ‚Üí Œ≤ ‚Üí Prop} ‚Üí r ‚âÉr s ‚Üí r ‚Ü™r s",
    "name": "RelIso.toRelEmbedding",
    "isProp": false,
    "doc":
    "Convert a `RelIso` to a `RelEmbedding`. This function is also available as a coercion\nbut often it is easier to write `f.toRelEmbedding` than to write explicitly `r` and `s`\nin the target type. ",
    "depth": 9},
   {"type":
    "{Œ± : Type u_1} ‚Üí {Œ≤ : Type u_2} ‚Üí {r : Œ± ‚Üí Œ± ‚Üí Prop} ‚Üí {s : Œ≤ ‚Üí Œ≤ ‚Üí Prop} ‚Üí r ‚âÉr s ‚Üí r ‚âºi s",
    "name": "InitialSeg.ofIso",
    "isProp": false,
    "doc": "An order isomorphism is an initial segment ",
    "depth": 9}],
  "count": 97},
 {"noDocExamples": [],
  "kind": "FirstOrder.Language.¬´term_‚Üí·¥∏_¬ª",
  "examples":
  [{"type": "(L : FirstOrder.Language) ‚Üí L ‚Üí·¥∏ L",
    "name": "FirstOrder.Language.LHom.id",
    "isProp": false,
    "doc": "The identity language homomorphism. ",
    "depth": 3},
   {"type":
    "(L : FirstOrder.Language) ‚Üí [inst : FirstOrder.Language.IsOrdered L] ‚Üí FirstOrder.Language.order ‚Üí·¥∏ L",
    "name": "FirstOrder.Language.orderLHom",
    "isProp": false,
    "doc":
    "The language homomorphism sending the unique symbol `‚â§` of `Language.order` to `‚â§` in an ordered\nlanguage. ",
    "depth": 4},
   {"type":
    "{L : FirstOrder.Language} ‚Üí {L' : FirstOrder.Language} ‚Üí (L ‚Üí·¥∏ L') ‚Üí Prop",
    "name": "FirstOrder.Language.LHom.Injective",
    "isProp": false,
    "doc":
    "A language homomorphism is injective when all the maps between symbol types are. ",
    "depth": 5}],
  "count": 96},
 {"noDocExamples": [],
  "kind": "Set.¬´term‚ãÇ‚ÇÄ_¬ª",
  "examples":
  [{"type":
    "‚àÄ {Œ± : Type u_2} {l : Filter Œ±} [inst : Filter.IsCountablyGenerated l], Filter.cofinite ‚â§ l ‚Üí Set.Countable (‚ãÇ‚ÇÄ l.sets)·∂ú",
    "name": "Filter.countable_compl_sInter_sets",
    "isProp": true,
    "doc":
    "If `l ‚â• Filter.cofinite` is a countably generated filter, then `‚ãÇ‚ÇÄ l.sets` is cocountable. ",
    "depth": 11},
   {"type":
    "‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] {S : Set (Set Œ±)},\n  (‚àÄ (s : Set Œ±), s ‚àà S ‚Üí IsGŒ¥ s) ‚Üí Set.Countable S ‚Üí IsGŒ¥ (‚ãÇ‚ÇÄ S)",
    "name": "isGŒ¥_sInter",
    "isProp": true,
    "doc": "A countable intersection of GŒ¥ sets is a GŒ¥ set. ",
    "depth": 12},
   {"type":
    "‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_3} {f : Œ± ‚Üí Œ≤} {l : Filter Œ≤} [inst : Filter.IsCountablyGenerated l],\n  Filter.Tendsto f Filter.cofinite l ‚Üí Set.Countable (f ‚Åª¬π' ‚ãÇ‚ÇÄ l.sets)·∂ú",
    "name": "Filter.Tendsto.countable_compl_preimage_sInter_sets",
    "isProp": true,
    "doc":
    "If `f` tends to a countably generated filter `l` along `Filter.cofinite`,\nthen for all but countably many elements, `f x ‚àà ‚ãÇ‚ÇÄ l.sets`. ",
    "depth": 12}],
  "count": 95},
 {"noDocExamples": [],
  "kind": "¬´term_‚Üí‚ãÜ‚Çê[_]_¬ª",
  "examples":
  [{"type":
    "(R : Type u_2) ‚Üí\n  (A : Type u_3) ‚Üí\n    [inst : CommSemiring R] ‚Üí [inst_1 : Semiring A] ‚Üí [inst_2 : Algebra R A] ‚Üí [inst_3 : Star A] ‚Üí A ‚Üí‚ãÜ‚Çê[R] A",
    "name": "StarAlgHom.id",
    "isProp": false,
    "doc": "The identity as a `StarAlgHom`. ",
    "depth": 16},
   {"type":
    "{R : Type u_2} ‚Üí\n  {A : Type u_3} ‚Üí\n    {B : Type u_4} ‚Üí\n      [inst : CommSemiring R] ‚Üí\n        [inst_1 : Semiring A] ‚Üí\n          [inst_2 : Algebra R A] ‚Üí\n            [inst_3 : Star A] ‚Üí\n              [inst_4 : Semiring B] ‚Üí [inst_5 : Algebra R B] ‚Üí [inst_6 : Star B] ‚Üí (A ‚Üí‚ãÜ‚Çê[R] B) ‚Üí A ‚Üí B",
    "name": "StarAlgHom.Simps.apply",
    "isProp": false,
    "doc": "See Note [custom simps projection] ",
    "depth": 21},
   {"type":
    "{R : Type u_1} ‚Üí\n  {A : Type u_2} ‚Üí\n    {B : Type u_3} ‚Üí\n      [inst : CommSemiring R] ‚Üí\n        [inst_1 : Semiring A] ‚Üí\n          [inst_2 : Algebra R A] ‚Üí\n            [inst_3 : Star A] ‚Üí\n              [inst_4 : Semiring B] ‚Üí [inst_5 : Algebra R B] ‚Üí [inst_6 : Star B] ‚Üí (A ‚Üí‚ãÜ‚Çê[R] B) ‚Üí A ‚Üí‚Çê[R] B",
    "name": "StarAlgHom.toAlgHom",
    "isProp": false,
    "doc":
    "Reinterpret a unital star algebra homomorphism as a unital algebra homomorphism\nby forgetting the interaction with the star operation. ",
    "depth": 21}],
  "count": 95},
 {"noDocExamples": [],
  "kind": "¬´term_‚âÉ·µÉ[_]_¬ª",
  "examples":
  [{"type":
    "(k : Type u_1) ‚Üí\n  (P‚ÇÅ : Type u_2) ‚Üí\n    {V‚ÇÅ : Type u_6} ‚Üí\n      [inst : Ring k] ‚Üí [inst_1 : AddCommGroup V‚ÇÅ] ‚Üí [inst_2 : Module k V‚ÇÅ] ‚Üí [inst_3 : AddTorsor V‚ÇÅ P‚ÇÅ] ‚Üí P‚ÇÅ ‚âÉ·µÉ[k] P‚ÇÅ",
    "name": "AffineEquiv.refl",
    "isProp": false,
    "doc": "Identity map as an `AffineEquiv`. ",
    "depth": 19},
   {"type":
    "(k : Type u_1) ‚Üí\n  {P‚ÇÅ : Type u_2} ‚Üí\n    {V‚ÇÅ : Type u_6} ‚Üí\n      [inst : Ring k] ‚Üí\n        [inst_1 : AddCommGroup V‚ÇÅ] ‚Üí [inst_2 : Module k V‚ÇÅ] ‚Üí [inst_3 : AddTorsor V‚ÇÅ P‚ÇÅ] ‚Üí P‚ÇÅ ‚Üí V‚ÇÅ ‚âÉ·µÉ[k] P‚ÇÅ",
    "name": "AffineEquiv.vaddConst",
    "isProp": false,
    "doc":
    "The map `v ‚Ü¶ v +·µ• b` as an affine equivalence between a module `V` and an affine space `P` with\ntangent space `V`. ",
    "depth": 20},
   {"type":
    "(k : Type u_1) ‚Üí\n  (P‚ÇÅ : Type u_2) ‚Üí\n    {V‚ÇÅ : Type u_6} ‚Üí\n      [inst : Ring k] ‚Üí\n        [inst_1 : AddCommGroup V‚ÇÅ] ‚Üí [inst_2 : Module k V‚ÇÅ] ‚Üí [inst_3 : AddTorsor V‚ÇÅ P‚ÇÅ] ‚Üí V‚ÇÅ ‚Üí P‚ÇÅ ‚âÉ·µÉ[k] P‚ÇÅ",
    "name": "AffineEquiv.constVAdd",
    "isProp": false,
    "doc":
    "The map `p ‚Ü¶ v +·µ• p` as an affine automorphism of an affine space.\n\nNote that there is no need for an `AffineMap.constVAdd` as it is always an equivalence.\nThis is roughly to `DistribMulAction.toLinearEquiv` as `+·µ•` is to `‚Ä¢`. ",
    "depth": 20}],
  "count": 95},
 {"noDocExamples": [],
  "kind": "term!_",
  "examples":
  [{"type":
    "‚àÄ {Œ± : Type u} {L : List (Œ± √ó Bool)} {x : Œ±} {b : Bool},\n  FreeAddGroup.Red ((x, b) :: L) [] ‚Üî FreeAddGroup.Red L [(x, !b)]",
    "name": "FreeAddGroup.Red.cons_nil_iff_singleton",
    "isProp": true,
    "doc":
    "If `x` is a letter and `w` is a word such that `x + w` reduces to the empty word, then `w`\nreduces to `-x`.",
    "depth": 14},
   {"type":
    "‚àÄ {Œ± : Type u} {L : List (Œ± √ó Bool)} {x : Œ±} {b : Bool}, FreeGroup.Red ((x, b) :: L) [] ‚Üî FreeGroup.Red L [(x, !b)]",
    "name": "FreeGroup.Red.cons_nil_iff_singleton",
    "isProp": true,
    "doc":
    "If `x` is a letter and `w` is a word such that `xw` reduces to the empty word, then `w` reduces\nto `x‚Åª¬π` ",
    "depth": 14},
   {"type":
    "‚àÄ {Œ± : Type u} {L‚ÇÅ L‚ÇÇ : List (Œ± √ó Bool)} {x1 : Œ±} {b1 : Bool} {x2 : Œ±} {b2 : Bool},\n  (x1, b1) ‚â† (x2, b2) ‚Üí FreeGroup.Red ((x1, b1) :: L‚ÇÅ) ((x2, b2) :: L‚ÇÇ) ‚Üí FreeGroup.Red L‚ÇÅ ((x1, !b1) :: (x2, b2) :: L‚ÇÇ)",
    "name": "FreeGroup.Red.inv_of_red_of_ne",
    "isProp": true,
    "doc":
    "If `x` and `y` are distinct letters and `w‚ÇÅ w‚ÇÇ` are words such that `xw‚ÇÅ` reduces to `yw‚ÇÇ`, then\n`w‚ÇÅ` reduces to `x‚Åª¬πyw‚ÇÇ`. ",
    "depth": 17}],
  "count": 94},
 {"noDocExamples": [],
  "kind": "Lean.Parser.Term.subst",
  "examples":
  [{"type":
    "{Œ± : Sort u_1} ‚Üí\n  {C : Trunc Œ± ‚Üí Sort u_3} ‚Üí\n    (f : (a : Œ±) ‚Üí C (Trunc.mk a)) ‚Üí (‚àÄ (a b : Œ±), (_ : Trunc.mk a = Trunc.mk b) ‚ñ∏ f a = f b) ‚Üí (q : Trunc Œ±) ‚Üí C q",
    "name": "Trunc.rec",
    "isProp": false,
    "doc": "Recursion/induction principle for `Trunc`. ",
    "depth": 15},
   {"type":
    "{Œ± : Sort u} ‚Üí\n  {s : Setoid Œ±} ‚Üí\n    {motive : Quotient s ‚Üí Sort v} ‚Üí\n      (f : (a : Œ±) ‚Üí motive (Quotient.mk s a)) ‚Üí\n        (‚àÄ (a b : Œ±) (p : a ‚âà b), (_ : Quotient.mk s a = Quotient.mk s b) ‚ñ∏ f a = f b) ‚Üí (q : Quotient s) ‚Üí motive q",
    "name": "Quotient.rec",
    "isProp": false,
    "doc": "The analogue of `Quot.rec` for `Quotient`. See `Quot.rec`. ",
    "depth": 18},
   {"type":
    "{Œ± : Sort u} ‚Üí\n  {r : Œ± ‚Üí Œ± ‚Üí Prop} ‚Üí\n    {motive : Quot r ‚Üí Sort v} ‚Üí\n      (f : (a : Œ±) ‚Üí motive (Quot.mk r a)) ‚Üí\n        (‚àÄ (a b : Œ±) (p : r a b), (_ : Quot.mk r a = Quot.mk r b) ‚ñ∏ f a = f b) ‚Üí (q : Quot r) ‚Üí motive q",
    "name": "Quot.rec",
    "isProp": false,
    "doc":
    "Dependent recursion principle for `Quot`. This constructor can be tricky to use,\nso you should consider the simpler versions if they apply:\n* `Quot.lift`, for nondependent functions\n* `Quot.ind`, for theorems / proofs of propositions about quotients\n* `Quot.recOnSubsingleton`, when the target type is a `Subsingleton`\n* `Quot.hrecOn`, which uses `HEq (f a) (f b)` instead of a `sound p ‚ñ∏ f a = f b` assummption\n",
    "depth": 18}],
  "count": 93},
 {"noDocExamples": [],
  "kind": "¬´term_>>=_¬ª",
  "examples":
  [{"type":
    "{Œ± Œ≤ : Type u_1} ‚Üí\n  [inst : DecidableEq Œ≤] ‚Üí\n    (s : Set Œ±) ‚Üí [inst : Fintype ‚Üës] ‚Üí (f : Œ± ‚Üí Set Œ≤) ‚Üí ((a : Œ±) ‚Üí a ‚àà s ‚Üí Fintype ‚Üë(f a)) ‚Üí Fintype ‚Üë(s >>= f)",
    "name": "Set.fintypeBind",
    "isProp": false,
    "doc":
    "If `s : Set Œ±` is a set with `Fintype` instance and `f : Œ± ‚Üí Set Œ≤` is a function such that\neach `f a`, `a ‚àà s`, has a `Fintype` structure, then `s >>= f` has a `Fintype` structure. ",
    "depth": 16},
   {"type":
    "‚àÄ {m : Type u_1 ‚Üí Type u_2} {Œ± Œ≤ : Type u_1} {q : Œ≤ ‚Üí Prop} {x : m Œ±} [inst : Monad m] [inst_1 : LawfulMonad m]\n  {f : Œ± ‚Üí m Œ≤}, SatisfiesM (fun a => SatisfiesM q (f a)) x ‚Üí SatisfiesM q (x >>= f)",
    "name": "SatisfiesM.bind_pre",
    "isProp": true,
    "doc":
    "`SatisfiesM` distributes over `>>=`, weakest precondition version. ",
    "depth": 18},
   {"type":
    "‚àÄ {m : Type u_1 ‚Üí Type u_2} {Œ± Œ≤ : Type u_1} {p : Œ± ‚Üí Prop} {x : m Œ±} {q : Œ≤ ‚Üí Prop} [inst : Monad m]\n  [inst_1 : LawfulMonad m] {f : Œ± ‚Üí m Œ≤},\n  SatisfiesM p x ‚Üí (‚àÄ (a : Œ±), p a ‚Üí SatisfiesM q (f a)) ‚Üí SatisfiesM q (x >>= f)",
    "name": "SatisfiesM.bind",
    "isProp": true,
    "doc": "`SatisfiesM` distributes over `>>=`, general version. ",
    "depth": 19}],
  "count": 88},
 {"noDocExamples": [],
  "kind": "¬´term_‚ÜíA[_]_¬ª",
  "examples":
  [{"type":
    "{ùïú : Type u_1} ‚Üí\n  {V : Type u_3} ‚Üí\n    {W : Type u_4} ‚Üí\n      [inst : NormedAddCommGroup V] ‚Üí\n        [inst_1 : NormedAddCommGroup W] ‚Üí\n          [inst_2 : NontriviallyNormedField ùïú] ‚Üí\n            [inst_3 : NormedSpace ùïú V] ‚Üí [inst_4 : NormedSpace ùïú W] ‚Üí Norm (V ‚ÜíA[ùïú] W)",
    "name": "ContinuousAffineMap.hasNorm",
    "isProp": false,
    "doc":
    "Note that unlike the operator norm for linear maps, this norm is _not_ submultiplicative:\nwe do _not_ necessarily have `‚Äñf.comp g‚Äñ ‚â§ ‚Äñf‚Äñ * ‚Äñg‚Äñ`. See `norm_comp_le` for what we can say. ",
    "depth": 23},
   {"type":
    "{R : Type u_1} ‚Üí\n  {V : Type u_2} ‚Üí\n    {W : Type u_3} ‚Üí\n      [inst : Ring R] ‚Üí\n        [inst_1 : AddCommGroup V] ‚Üí\n          [inst_2 : Module R V] ‚Üí\n            [inst_3 : TopologicalSpace V] ‚Üí\n              [inst_4 : AddCommGroup W] ‚Üí\n                [inst_5 : Module R W] ‚Üí [inst_6 : TopologicalSpace W] ‚Üí (V ‚ÜíL[R] W) ‚Üí V ‚ÜíA[R] W",
    "name": "ContinuousLinearMap.toContinuousAffineMap",
    "isProp": false,
    "doc":
    "A continuous linear map can be regarded as a continuous affine map. ",
    "depth": 25},
   {"type":
    "{R : Type u_1} ‚Üí\n  {V : Type u_2} ‚Üí\n    {W : Type u_3} ‚Üí\n      {P : Type u_4} ‚Üí\n        {Q : Type u_5} ‚Üí\n          [inst : Ring R] ‚Üí\n            [inst_1 : AddCommGroup V] ‚Üí\n              [inst_2 : Module R V] ‚Üí\n                [inst_3 : TopologicalSpace P] ‚Üí\n                  [inst_4 : AddTorsor V P] ‚Üí\n                    [inst_5 : AddCommGroup W] ‚Üí\n                      [inst_6 : Module R W] ‚Üí\n                        [inst_7 : TopologicalSpace Q] ‚Üí [inst_8 : AddTorsor W Q] ‚Üí (P ‚ÜíA[R] Q) ‚Üí C(P, Q)",
    "name": "ContinuousAffineMap.toContinuousMap",
    "isProp": false,
    "doc":
    "Forgetting its algebraic properties, a continuous affine map is a continuous map. ",
    "depth": 29}],
  "count": 86},
 {"noDocExamples":
  [{"type": "‚àÄ {X Y : Type u} {x : X} {y : Y}, (Œ≤_ X Y).hom (x, y) = (y, x)",
    "name": "CategoryTheory.braiding_hom_apply",
    "isProp": true,
    "depth": 15},
   {"type": "‚àÄ {X Y : Type u} {x : X} {y : Y}, (Œ≤_ X Y).inv (y, x) = (x, y)",
    "name": "CategoryTheory.braiding_inv_apply",
    "isProp": true,
    "depth": 15}],
  "kind": "CategoryTheory.termŒ≤_",
  "examples":
  [{"type":
    "{C : Type u_1} ‚Üí\n  {D : Type u_2} ‚Üí\n    [inst : CategoryTheory.Category.{u_3, u_1} C] ‚Üí\n      [inst_1 : CategoryTheory.Category.{u_4, u_2} D] ‚Üí\n        [inst_2 : CategoryTheory.MonoidalCategory C] ‚Üí\n          [inst_3 : CategoryTheory.MonoidalCategory D] ‚Üí\n            (F : CategoryTheory.MonoidalFunctor C D) ‚Üí\n              [inst_4 : CategoryTheory.Faithful F.toFunctor] ‚Üí\n                [inst_5 : CategoryTheory.BraidedCategory D] ‚Üí\n                  (Œ≤ :\n                      (X Y : C) ‚Üí\n                        CategoryTheory.MonoidalCategory.tensorObj X Y ‚âÖ CategoryTheory.MonoidalCategory.tensorObj Y X) ‚Üí\n                    (‚àÄ (X Y : C),\n                        CategoryTheory.CategoryStruct.comp\n                            (CategoryTheory.LaxMonoidalFunctor.Œº F.toLaxMonoidalFunctor X Y) (F.map (Œ≤ X Y).hom) =\n                          CategoryTheory.CategoryStruct.comp (Œ≤_ (F.obj X) (F.obj Y)).hom\n                            (CategoryTheory.LaxMonoidalFunctor.Œº F.toLaxMonoidalFunctor Y X)) ‚Üí\n                      CategoryTheory.BraidedCategory C",
    "name": "CategoryTheory.braidedCategoryOfFaithful",
    "isProp": false,
    "doc":
    "Verifying the axioms for a braiding by checking that the candidate braiding is sent to a braiding\nby a faithful monoidal functor.\n",
    "depth": 33}],
  "count": 82},
 {"noDocExamples": [],
  "kind": "¬´term_‚âÉ·µ§_¬ª",
  "examples":
  [{"type": "CompareReals.Bourbaki‚Ñù ‚âÉ·µ§ ‚Ñù",
    "name": "CompareReals.compareEquiv",
    "isProp": false,
    "doc": "The uniform bijection between Bourbaki and Cauchy reals. ",
    "depth": 4},
   {"type": "(Œ± : Type u_4) ‚Üí [inst : UniformSpace Œ±] ‚Üí Œ± ‚âÉ·µ§ Œ±",
    "name": "UniformEquiv.refl",
    "isProp": false,
    "doc": "Identity map as a uniform isomorphism. ",
    "depth": 6},
   {"type": "(Œ± : Type u) ‚Üí [inst : UniformSpace Œ±] ‚Üí ULift.{v, u} Œ± ‚âÉ·µ§ Œ±",
    "name": "UniformEquiv.ulift",
    "isProp": false,
    "doc": "Uniform equivalence between `ULift Œ±` and `Œ±`. ",
    "depth": 7}],
  "count": 82},
 {"noDocExamples": [],
  "kind": "FirstOrder.Language.¬´term_‚ä®__1¬ª",
  "examples":
  [{"type":
    "(V : Type w') ‚Üí\n  [inst : FirstOrder.Language.Structure FirstOrder.Language.graph V] ‚Üí\n    [inst : V ‚ä® FirstOrder.Language.Theory.simpleGraph] ‚Üí SimpleGraph V",
    "name": "FirstOrder.Language.simpleGraphOfStructure",
    "isProp": false,
    "doc":
    "Any model of the theory of simple graphs represents a simple graph. ",
    "depth": 7},
   {"type":
    "{L : FirstOrder.Language} ‚Üí\n  (T : FirstOrder.Language.Theory L) ‚Üí\n    (M : Type w) ‚Üí\n      [inst : FirstOrder.Language.Structure L M] ‚Üí\n        [inst : M ‚ä® T] ‚Üí [inst : Nonempty M] ‚Üí FirstOrder.Language.Theory.ModelType T",
    "name": "FirstOrder.Language.Theory.ModelType.of",
    "isProp": false,
    "doc":
    "The object in the category of R-algebras associated to a type equipped with the appropriate\ntypeclasses. ",
    "depth": 9},
   {"type":
    "{L : FirstOrder.Language} ‚Üí\n  {T : FirstOrder.Language.Theory L} ‚Üí\n    {M : Type w} ‚Üí\n      [LM : FirstOrder.Language.Structure L M] ‚Üí [ne : Nonempty M] ‚Üí M ‚ä® T ‚Üí FirstOrder.Language.Theory.ModelType T",
    "name": "FirstOrder.Language.Theory.Model.bundled",
    "isProp": false,
    "doc": "Bundles `M ‚ä® T` as a `T.ModelType`. ",
    "depth": 10}],
  "count": 81},
 {"noDocExamples": [],
  "kind": "CategoryTheory.Limits.¬´term_‚äû_¬ª",
  "examples":
  [{"type": "(G H : AddCommGroupCat) ‚Üí G ‚äû H ‚âÖ AddCommGroupCat.of (‚ÜëG √ó ‚ÜëH)",
    "name": "AddCommGroupCat.biprodIsoProd",
    "isProp": false,
    "doc":
    "We verify that the biproduct in `AddCommGroupCat` is isomorphic to\nthe cartesian product of the underlying types:\n",
    "depth": 12},
   {"type":
    "{C : Type u} ‚Üí\n  [inst : CategoryTheory.Category.{v, u} C] ‚Üí\n    [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] ‚Üí\n      {X Y : C} ‚Üí [inst_2 : CategoryTheory.Limits.HasBinaryBiproduct X Y] ‚Üí Y ‚ü∂ X ‚äû Y",
    "name": "CategoryTheory.Limits.biprod.inr",
    "isProp": false,
    "doc": "The inclusion into the second summand of a binary biproduct. ",
    "depth": 13},
   {"type":
    "{C : Type u} ‚Üí\n  [inst : CategoryTheory.Category.{v, u} C] ‚Üí\n    [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] ‚Üí\n      {X Y : C} ‚Üí [inst_2 : CategoryTheory.Limits.HasBinaryBiproduct X Y] ‚Üí X ‚ü∂ X ‚äû Y",
    "name": "CategoryTheory.Limits.biprod.inl",
    "isProp": false,
    "doc": "The inclusion into the first summand of a binary biproduct. ",
    "depth": 13}],
  "count": 81},
 {"noDocExamples": [],
  "kind": "SimpleGraph.¬´term_‚Üíg_¬ª",
  "examples":
  [{"type": "{V : Type u} ‚Üí {G : SimpleGraph V} ‚Üí G ‚Üíg G",
    "name": "SimpleGraph.Hom.id",
    "isProp": false,
    "doc": "The identity homomorphism from a graph to itself. ",
    "depth": 6},
   {"type":
    "{V : Type u} ‚Üí {G : SimpleGraph V} ‚Üí (x : SimpleGraph.Subgraph G) ‚Üí SimpleGraph.Subgraph.spanningCoe x ‚Üíg G",
    "name": "SimpleGraph.Subgraph.spanningHom",
    "isProp": false,
    "doc":
    "There is an induced injective homomorphism of a subgraph of `G` as\na spanning subgraph into `G`. ",
    "depth": 8},
   {"type":
    "{V : Type u} ‚Üí\n  {V' : Type v} ‚Üí\n    {G : SimpleGraph V} ‚Üí\n      {G' : SimpleGraph V'} ‚Üí G ‚Üíg G' ‚Üí SimpleGraph.ConnectedComponent G ‚Üí SimpleGraph.ConnectedComponent G'",
    "name": "SimpleGraph.ConnectedComponent.map",
    "isProp": false,
    "doc": "The map on connected components induced by a graph homomorphism. ",
    "depth": 9}],
  "count": 81},
 {"noDocExamples": [],
  "kind": "AddCommGroup.¬´term_‚â°_[PMOD_]¬ª",
  "examples":
  [{"type":
    "‚àÄ {Œ± : Type u_1} [inst : AddCommGroup Œ±] {p a b : Œ±}, a ‚â° b [PMOD p] ‚Üí b ‚â° a [PMOD p]",
    "name": "AddCommGroup.ModEq.symm",
    "isProp": true,
    "doc": "**Alias** of the forward direction of `AddCommGroup.modEq_comm`.",
    "depth": 11},
   {"type":
    "‚àÄ {Œ± : Type u_1} [inst : AddCommGroupWithOne Œ±] [inst_1 : CharZero Œ±] {a b z : ‚Ñ§}, a ‚â° b [PMOD z] ‚Üí ‚Üëa ‚â° ‚Üëb [PMOD ‚Üëz]",
    "name": "AddCommGroup.ModEq.int_cast",
    "isProp": true,
    "doc":
    "**Alias** of the reverse direction of `AddCommGroup.int_cast_modEq_int_cast`.",
    "depth": 14},
   {"type":
    "‚àÄ {Œ± : Type u_1} [inst : AddCommGroupWithOne Œ±] [inst_1 : CharZero Œ±] {a b n : ‚Ñï}, a ‚â° b [MOD n] ‚Üí ‚Üëa ‚â° ‚Üëb [PMOD ‚Üën]",
    "name": "AddCommGroup.ModEq.nat_cast",
    "isProp": true,
    "doc":
    "**Alias** of the reverse direction of `AddCommGroup.nat_cast_modEq_nat_cast`.",
    "depth": 14}],
  "count": 80},
 {"noDocExamples":
  [{"type":
    "‚àÄ {Œ± : Type u_2} [inst : Inf Œ±] [inst_1 : HImp Œ±] (a b : Œ±), a ‚áî b = (b ‚á® a) ‚äì (a ‚á® b)",
    "name": "bihimp_def",
    "isProp": true,
    "depth": 12},
   {"type":
    "‚àÄ {Œ± : Type u_2} [inst : GeneralizedHeytingAlgebra Œ±] (a : Œ±), ‚ä§ ‚áî a = a",
    "name": "top_bihimp",
    "isProp": true,
    "depth": 12},
   {"type":
    "‚àÄ {Œ± : Type u_1} [inst : GeneralizedHeytingAlgebra Œ±], IsCommutative Œ± fun x x_1 => x ‚áî x_1",
    "name": "bihimp_isCommutative.proof_1",
    "isProp": true,
    "depth": 12}],
  "kind": "¬´term_‚áî_¬ª",
  "examples": [],
  "count": 77},
 {"noDocExamples": [],
  "kind": "¬´term_‚©ø_¬ª",
  "examples":
  [{"type":
    "‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] {a b : Œ±}, a ‚â§ b ‚Üí b ‚â§ a ‚Üí a ‚©ø b",
    "name": "LE.le.wcovby_of_le",
    "isProp": true,
    "doc": "**Alias** of `wcovby_of_le_of_le`.",
    "depth": 11},
   {"type":
    "‚àÄ {Œ± : Type u_1} [inst : PartialOrder Œ±] {a b : Œ±}, a ‚©ø b ‚Üí a = b ‚à® a ‚ãñ b",
    "name": "Wcovby.eq_or_covby",
    "isProp": true,
    "doc": "**Alias** of the forward direction of `wcovby_iff_eq_or_covby`.",
    "depth": 12},
   {"type":
    "‚àÄ {Œ± : Type u_1} [inst : PartialOrder Œ±] {a b : Œ±}, a ‚©ø b ‚Üí a ‚ãñ b ‚à® a = b",
    "name": "Wcovby.covby_or_eq",
    "isProp": true,
    "doc": "**Alias** of the forward direction of `wcovby_iff_covby_or_eq`.",
    "depth": 13}],
  "count": 77},
 {"noDocExamples": [],
  "kind": "¬´term_À¢ ∏·µê¬ª",
  "examples":
  [{"type": "{Œ± : Type u_1} ‚Üí Œ± ‚âÉ Œ±À¢ ∏·µê",
    "name": "SymAlg.sym",
    "isProp": false,
    "doc": "The element of `SymAlg Œ±` that represents `a : Œ±`. ",
    "depth": 3},
   {"type": "{Œ± : Type u_1} ‚Üí Œ±À¢ ∏·µê ‚âÉ Œ±",
    "name": "SymAlg.unsym",
    "isProp": false,
    "doc": "The element of `Œ±` represented by `x : Œ±À¢ ∏·µê`. ",
    "depth": 4},
   {"type":
    "{Œ± : Type u_1} ‚Üí [inst : Ring Œ±] ‚Üí [inst : Invertible 2] ‚Üí NonAssocRing Œ±À¢ ∏·µê",
    "name": "SymAlg.instNonAssocRingSymAlg",
    "isProp": false,
    "doc":
    "The symmetrization of a real (unital, associative) algebra is a non-associative ring. ",
    "depth": 10}],
  "count": 77},
 {"noDocExamples":
  [{"type":
    "‚àÄ {Œ± : Type u_1} (a : Array Œ±) (i : Fin (Array.size a)), Array.get a i = a[‚Üëi]",
    "name": "Array.get_eq_getElem",
    "isProp": true,
    "depth": 15}],
  "kind": "¬´term__[_]¬ª",
  "examples":
  [{"type":
    "‚àÄ {Œ± : Type u_1} (self : Array.PrefixTable Œ±) {i : ‚Ñï} (h : i < Array.size self.toArray), self.toArray[i].snd ‚â§ i",
    "name": "Array.PrefixTable.valid",
    "isProp": true,
    "doc": "Validity condition to help with termination proofs ",
    "depth": 19},
   {"type":
    "‚àÄ {Œ± Œ≤ Œ¥ : Type} [inst : CanonicallyLinearOrderedAddMonoid Œ¥] {C : Levenshtein.Cost Œ± Œ≤ Œ¥} {xs : List Œ±} {ys : List Œ≤}\n  (self : LevenshteinEstimator' C xs ys),\n  self.bound =\n    match self.pre_rev, (_ : List.reverse self.pre_rev ++ self.suff = ys) with\n    | [], split => ((‚Üëself.distances)[0], List.length ys)\n    | x, split => (List.minimum_of_length_pos (_ : 0 < List.length ‚Üëself.distances), List.length self.suff)",
    "name": "LevenshteinEstimator'.bound_eq",
    "isProp": true,
    "doc": "Predicate describing the current bound. ",
    "depth": 27}],
  "count": 77},
 {"noDocExamples": [],
  "kind": "CategoryTheory.Limits.¬´term‚ä•__¬ª",
  "examples":
  [{"type":
    "{C : Type u‚ÇÅ} ‚Üí\n  [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] ‚Üí\n    [inst_1 : CategoryTheory.Limits.HasInitial C] ‚Üí CategoryTheory.Limits.IsInitial (‚ä•_ C)",
    "name": "CategoryTheory.Limits.initialIsInitial",
    "isProp": false,
    "doc": "An initial object is initial. ",
    "depth": 7},
   {"type": "‚ä•_ TopCat ‚âÖ TopCat.of PEmpty.{u + 1}",
    "name": "TopCat.initialIsoPEmpty",
    "isProp": false,
    "doc": "The initial object of `Top` is `PEmpty`. ",
    "depth": 8},
   {"type": "‚ä•_ Type u ‚âÖ PEmpty.{u + 1}",
    "name": "CategoryTheory.Limits.Types.initialIso",
    "isProp": false,
    "doc": "The initial object in `Type u` is `PEmpty`. ",
    "depth": 8}],
  "count": 76},
 {"noDocExamples":
  [{"type": "‚àÄ {Œ± : Type u_1} [inst : SemilatticeSup Œ±] {t : Set Œ±}, ‚àÖ ‚äª t = ‚àÖ",
    "name": "Set.empty_sups",
    "isProp": true,
    "depth": 10},
   {"type": "‚àÄ {Œ± : Type u_1} [inst : SemilatticeSup Œ±] {s : Set Œ±}, s ‚äª ‚àÖ = ‚àÖ",
    "name": "Set.sups_empty",
    "isProp": true,
    "depth": 10},
   {"type":
    "‚àÄ {Œ± : Type u_1} [inst : SemilatticeSup Œ±] {s t : Set Œ±}, Set.Nonempty (s ‚äª t) ‚Üí Set.Nonempty s",
    "name": "Set.Nonempty.of_sups_left",
    "isProp": true,
    "depth": 11}],
  "kind": "¬´term_‚äª_¬ª",
  "examples": [],
  "count": 76},
 {"noDocExamples": [],
  "kind": "CategoryTheory.Limits.¬´term_‚®ø_¬ª",
  "examples":
  [{"type": "(X Y : Type u) ‚Üí X ‚®ø Y ‚âÖ X ‚äï Y",
    "name": "CategoryTheory.Limits.Types.binaryCoproductIso",
    "isProp": false,
    "doc": "The categorical binary coproduct in `Type u` is the sum `X ‚äï Y`. ",
    "depth": 10},
   {"type":
    "{C : Type u} ‚Üí\n  [inst : CategoryTheory.Category.{v, u} C] ‚Üí\n    {X Y : C} ‚Üí [inst_1 : CategoryTheory.Limits.HasBinaryCoproduct X Y] ‚Üí Y ‚ü∂ X ‚®ø Y",
    "name": "CategoryTheory.Limits.coprod.inr",
    "isProp": false,
    "doc": "The inclusion map from the second component of the coproduct. ",
    "depth": 11},
   {"type":
    "{C : Type u} ‚Üí\n  [inst : CategoryTheory.Category.{v, u} C] ‚Üí\n    {X Y : C} ‚Üí [inst_1 : CategoryTheory.Limits.HasBinaryCoproduct X Y] ‚Üí X ‚ü∂ X ‚®ø Y",
    "name": "CategoryTheory.Limits.coprod.inl",
    "isProp": false,
    "doc": "The inclusion map from the first component of the coproduct. ",
    "depth": 11}],
  "count": 76},
 {"noDocExamples":
  [{"type": "‚àÄ {Œ± : Type u_1} [inst : SemilatticeInf Œ±] {t : Set Œ±}, ‚àÖ ‚äº t = ‚àÖ",
    "name": "Set.empty_infs",
    "isProp": true,
    "depth": 10},
   {"type": "‚àÄ {Œ± : Type u_1} [inst : SemilatticeInf Œ±] {s : Set Œ±}, s ‚äº ‚àÖ = ‚àÖ",
    "name": "Set.infs_empty",
    "isProp": true,
    "depth": 10},
   {"type":
    "‚àÄ {Œ± : Type u_1} [inst : SemilatticeInf Œ±] {s t : Set Œ±}, Set.Nonempty (s ‚äº t) ‚Üí Set.Nonempty t",
    "name": "Set.Nonempty.of_infs_right",
    "isProp": true,
    "depth": 11}],
  "kind": "¬´term_‚äº_¬ª",
  "examples": [],
  "count": 75},
 {"noDocExamples": [],
  "kind": "¬´term_‚âÉ‚Çõ‚Çó[_]_¬ª",
  "examples":
  [{"type":
    "{R : Type u_1} ‚Üí\n  {M : Type u_7} ‚Üí\n    [inst : Semiring R] ‚Üí\n      [inst_1 : AddCommMonoid M] ‚Üí\n        {œÉ œÉ' : R ‚Üí+* R} ‚Üí\n          [inst_2 : RingHomInvPair œÉ œÉ'] ‚Üí\n            [inst_3 : RingHomInvPair œÉ' œÉ] ‚Üí {x : Module R M} ‚Üí (f : M ‚Üí‚Çõ‚Çó[œÉ] M) ‚Üí Function.Involutive ‚Üëf ‚Üí M ‚âÉ‚Çõ‚Çó[œÉ] M",
    "name": "LinearEquiv.ofInvolutive",
    "isProp": false,
    "doc": "An involutive linear map is a linear equivalence. ",
    "depth": 28},
   {"type":
    "{R : Type u_17} ‚Üí\n  {S : Type u_18} ‚Üí\n    [inst : Semiring R] ‚Üí\n      [inst_1 : Semiring S] ‚Üí\n        {œÉ : R ‚Üí+* S} ‚Üí\n          {œÉ' : S ‚Üí+* R} ‚Üí\n            [inst_2 : RingHomInvPair œÉ œÉ'] ‚Üí\n              [inst_3 : RingHomInvPair œÉ' œÉ] ‚Üí\n                {M : Type u_19} ‚Üí\n                  {M‚ÇÇ : Type u_20} ‚Üí\n                    [inst_4 : AddCommMonoid M] ‚Üí\n                      [inst_5 : AddCommMonoid M‚ÇÇ] ‚Üí\n                        [inst_6 : Module R M] ‚Üí [inst_7 : Module S M‚ÇÇ] ‚Üí (M ‚âÉ‚Çõ‚Çó[œÉ] M‚ÇÇ) ‚Üí M‚ÇÇ ‚Üí M",
    "name": "LinearEquiv.Simps.symm_apply",
    "isProp": false,
    "doc": "See Note [custom simps projection] ",
    "depth": 29},
   {"type":
    "{R : Type u_1} ‚Üí\n  {S : Type u_6} ‚Üí\n    {M : Type u_7} ‚Üí\n      {M‚ÇÇ : Type u_9} ‚Üí\n        [inst : Semiring R] ‚Üí\n          [inst_1 : Semiring S] ‚Üí\n            [inst_2 : AddCommMonoid M] ‚Üí\n              [inst_3 : AddCommMonoid M‚ÇÇ] ‚Üí\n                [inst_4 : Module R M] ‚Üí\n                  [inst_5 : Module S M‚ÇÇ] ‚Üí\n                    {œÉ : R ‚Üí+* S} ‚Üí\n                      {œÉ' : S ‚Üí+* R} ‚Üí\n                        [inst_6 : RingHomInvPair œÉ œÉ'] ‚Üí [inst_7 : RingHomInvPair œÉ' œÉ] ‚Üí (M ‚âÉ‚Çõ‚Çó[œÉ] M‚ÇÇ) ‚Üí M ‚âÉ M‚ÇÇ",
    "name": "LinearEquiv.toEquiv",
    "isProp": false,
    "doc": "The equivalence of types underlying a linear equivalence. ",
    "depth": 29}],
  "count": 73},
 {"noDocExamples": [],
  "kind": "¬´term_‚Üí‚ãÜ‚Çô‚Çê[_]_¬ª",
  "examples":
  [{"type":
    "(R : Type u_1) ‚Üí\n  (A : Type u_2) ‚Üí\n    [inst : Monoid R] ‚Üí\n      [inst_1 : NonUnitalNonAssocSemiring A] ‚Üí [inst_2 : DistribMulAction R A] ‚Üí [inst_3 : Star A] ‚Üí A ‚Üí‚ãÜ‚Çô‚Çê[R] A",
    "name": "NonUnitalStarAlgHom.id",
    "isProp": false,
    "doc": "The identity as a non-unital ‚ãÜ-algebra homomorphism. ",
    "depth": 16},
   {"type":
    "(R : Type u_1) ‚Üí\n  (A : Type u_2) ‚Üí\n    [inst : CommSemiring R] ‚Üí\n      [inst_1 : StarAddMonoid R] ‚Üí\n        [inst_2 : NonUnitalSemiring A] ‚Üí [inst_3 : Star A] ‚Üí [inst_4 : Module R A] ‚Üí A ‚Üí‚ãÜ‚Çô‚Çê[R] Unitization R A",
    "name": "Unitization.inrNonUnitalStarAlgHom",
    "isProp": false,
    "doc":
    "The coercion from a non-unital `R`-algebra `A` to its unitization `unitization R A`\nrealized as a non-unital star algebra homomorphism. ",
    "depth": 19},
   {"type":
    "(R : Type u_1) ‚Üí\n  (A : Type u_2) ‚Üí\n    (B : Type u_3) ‚Üí\n      [inst : Monoid R] ‚Üí\n        [inst_1 : NonUnitalNonAssocSemiring A] ‚Üí\n          [inst_2 : DistribMulAction R A] ‚Üí\n            [inst_3 : StarAddMonoid A] ‚Üí\n              [inst_4 : NonUnitalNonAssocSemiring B] ‚Üí\n                [inst_5 : DistribMulAction R B] ‚Üí [inst_6 : StarAddMonoid B] ‚Üí A ‚Üí‚ãÜ‚Çô‚Çê[R] A √ó B",
    "name": "NonUnitalStarAlgHom.inl",
    "isProp": false,
    "doc":
    "The left injection into a product is a non-unital algebra homomorphism. ",
    "depth": 20}],
  "count": 73},
 {"noDocExamples": [],
  "kind": "TypeVec.¬´term_:::_¬ª",
  "examples":
  [{"type":
    "{n : ‚Ñï} ‚Üí\n  {C : TypeVec (n + 1) ‚Üí Sort u} ‚Üí ((Œ± : TypeVec n) ‚Üí (Œ≤ : Type u_1) ‚Üí C (Œ± ::: Œ≤)) ‚Üí (Œ≥ : TypeVec (n + 1)) ‚Üí C Œ≥",
    "name": "TypeVec.append1Cases",
    "isProp": false,
    "doc": "cases on `(n+1)-length` vectors ",
    "depth": 11},
   {"type":
    "{n : ‚Ñï} ‚Üí {Œ± : TypeVec (n + 1)} ‚Üí TypeVec.Arrow (TypeVec.drop Œ± ::: TypeVec.last Œ±) Œ±",
    "name": "TypeVec.fromAppend1DropLast",
    "isProp": false,
    "doc": "stitch two bits of a vector back together ",
    "depth": 11},
   {"type":
    "{n : ‚Ñï} ‚Üí {Œ± : TypeVec (n + 1)} ‚Üí TypeVec.Arrow Œ± (TypeVec.drop Œ± ::: TypeVec.last Œ±)",
    "name": "TypeVec.toAppend1DropLast",
    "isProp": false,
    "doc": "decompose a vector into its prefix appended with its last element ",
    "depth": 11}],
  "count": 71},
 {"noDocExamples": [],
  "kind": "¬´DistribMulActionHomLocal‚â∫¬ª",
  "examples":
  [{"type":
    "(M : Type u_5) ‚Üí\n  [inst : Monoid M] ‚Üí {A : Type u_6} ‚Üí [inst_1 : AddMonoid A] ‚Üí [inst_2 : DistribMulAction M A] ‚Üí A ‚Üí+[M] A",
    "name": "DistribMulActionHom.id",
    "isProp": false,
    "doc": "The identity map as an equivariant additive monoid homomorphism. ",
    "depth": 13},
   {"type":
    "{M : Type u_5} ‚Üí\n  [inst : Monoid M] ‚Üí\n    {A : Type u_6} ‚Üí\n      [inst_1 : AddMonoid A] ‚Üí\n        [inst_2 : DistribMulAction M A] ‚Üí\n          {B : Type u_8} ‚Üí [inst_3 : AddMonoid B] ‚Üí [inst_4 : DistribMulAction M B] ‚Üí (A ‚Üí+[M] B) ‚Üí A ‚Üí+ B",
    "name": "DistribMulActionHom.toAddMonoidHom",
    "isProp": false,
    "doc":
    "Reinterpret an equivariant additive monoid homomorphism as an additive monoid homomorphism. ",
    "depth": 17},
   {"type":
    "{M : Type u_18} ‚Üí\n  (N : Type u_16) ‚Üí\n    (A : Type u_17) ‚Üí\n      [inst : Monoid N] ‚Üí\n        [inst_1 : AddMonoid A] ‚Üí\n          [inst_2 : DistribSMul M A] ‚Üí [inst_3 : DistribMulAction N A] ‚Üí [inst_4 : SMulCommClass M N A] ‚Üí M ‚Üí A ‚Üí+[N] A",
    "name": "SMulCommClass.toDistribMulActionHom",
    "isProp": false,
    "doc":
    "If `DistribMulAction` of `M` and `N` on `A` commute, then for each `c : M`, `(c ‚Ä¢ ¬∑)` is an\n`N`-action additive homomorphism. ",
    "depth": 17}],
  "count": 71},
 {"noDocExamples": [],
  "kind": "CategoryTheory.Limits.¬´term‚àê_¬ª",
  "examples":
  [{"type": "{J : Type u} ‚Üí (F : J ‚Üí Type u) ‚Üí ‚àê F ‚âÖ (j : J) √ó F j",
    "name": "CategoryTheory.Limits.Types.coproductIso",
    "isProp": false,
    "doc":
    "The categorical coproduct in `Type u` is the type theoretic coproduct `Œ£ j, F j`. ",
    "depth": 10},
   {"type":
    "{Œ± : Type} ‚Üí [inst : Fintype Œ±] ‚Üí (X : Œ± ‚Üí Stonean) ‚Üí Stonean.finiteCoproduct X ‚âÖ ‚àê X",
    "name": "Stonean.coproductIsoCoproduct",
    "isProp": false,
    "doc":
    "The isomorphism from the explicit finite coproducts to the abstract coproduct. ",
    "depth": 12},
   {"type":
    "{Œ± : Type} ‚Üí [inst : Fintype Œ±] ‚Üí (X : Œ± ‚Üí CompHaus) ‚Üí CompHaus.finiteCoproduct X ‚âÖ ‚àê X",
    "name": "CompHaus.coproductIsoCoproduct",
    "isProp": false,
    "doc":
    "The isomorphism from the explicit finite coproducts to the abstract coproduct. ",
    "depth": 12}],
  "count": 70},
 {"noDocExamples": [],
  "kind": "¬´term_‚âÉ·µÉ‚Å±[_]_¬ª",
  "examples":
  [{"type":
    "(ùïú : Type u_1) ‚Üí\n  {V : Type u_2} ‚Üí\n    (P : Type u_8) ‚Üí\n      [inst : NormedField ùïú] ‚Üí\n        [inst_1 : SeminormedAddCommGroup V] ‚Üí\n          [inst_2 : NormedSpace ùïú V] ‚Üí [inst_3 : PseudoMetricSpace P] ‚Üí [inst_4 : NormedAddTorsor V P] ‚Üí P ‚âÉ·µÉ‚Å±[ùïú] P",
    "name": "AffineIsometryEquiv.refl",
    "isProp": false,
    "doc": "Identity map as an `AffineIsometryEquiv`. ",
    "depth": 22},
   {"type":
    "(ùïú : Type u_1) ‚Üí\n  {V : Type u_2} ‚Üí\n    {P : Type u_8} ‚Üí\n      [inst : NormedField ùïú] ‚Üí\n        [inst_1 : SeminormedAddCommGroup V] ‚Üí\n          [inst_2 : NormedSpace ùïú V] ‚Üí [inst_3 : PseudoMetricSpace P] ‚Üí [inst_4 : NormedAddTorsor V P] ‚Üí P ‚Üí P ‚âÉ·µÉ‚Å±[ùïú] P",
    "name": "AffineIsometryEquiv.pointReflection",
    "isProp": false,
    "doc": "Point reflection in `x` as an affine isometric automorphism. ",
    "depth": 23},
   {"type":
    "{ùïú : Type u_1} ‚Üí\n  {V : Type u_2} ‚Üí\n    {P : Type u_8} ‚Üí\n      [inst : NormedField ùïú] ‚Üí\n        [inst_1 : SeminormedAddCommGroup V] ‚Üí\n          [inst_2 : NormedSpace ùïú V] ‚Üí\n            [inst_3 : PseudoMetricSpace P] ‚Üí [inst_4 : NormedAddTorsor V P] ‚Üí Group (P ‚âÉ·µÉ‚Å±[ùïú] P)",
    "name": "AffineIsometryEquiv.instGroupAffineIsometryEquiv",
    "isProp": false,
    "doc": "The group of affine isometries of a `NormedAddTorsor`, `P`. ",
    "depth": 23}],
  "count": 70},
 {"noDocExamples": [],
  "kind": "¬´term_‚âÉ‚Çó‚ÅÖ_‚ÅÜ_¬ª",
  "examples":
  [{"type":
    "{R : Type u} ‚Üí {L‚ÇÅ : Type v} ‚Üí [inst : CommRing R] ‚Üí [inst_1 : LieRing L‚ÇÅ] ‚Üí [inst_2 : LieAlgebra R L‚ÇÅ] ‚Üí L‚ÇÅ ‚âÉ‚Çó‚ÅÖR‚ÅÜ L‚ÇÅ",
    "name": "LieEquiv.refl",
    "isProp": false,
    "doc": "Lie algebra equivalences are reflexive. ",
    "depth": 13},
   {"type":
    "{R : Type u} ‚Üí\n  {L‚ÇÅ : Type v} ‚Üí\n    {L‚ÇÇ : Type w} ‚Üí\n      [inst : CommRing R] ‚Üí\n        [inst_1 : LieRing L‚ÇÅ] ‚Üí\n          [inst_2 : LieRing L‚ÇÇ] ‚Üí [inst_3 : LieAlgebra R L‚ÇÅ] ‚Üí [inst_4 : LieAlgebra R L‚ÇÇ] ‚Üí (L‚ÇÅ ‚âÉ‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ) ‚Üí L‚ÇÇ ‚âÉ‚Çó‚ÅÖR‚ÅÜ L‚ÇÅ",
    "name": "LieEquiv.symm",
    "isProp": false,
    "doc": "Lie algebra equivalences are symmetric. ",
    "depth": 17},
   {"type":
    "{R : Type u} ‚Üí\n  {L : Type v} ‚Üí\n    {L' : Type w} ‚Üí\n      [inst : CommRing R] ‚Üí\n        [inst_1 : LieRing L] ‚Üí\n          [inst_2 : LieAlgebra R L] ‚Üí [inst_3 : LieRing L'] ‚Üí [inst_4 : LieAlgebra R L'] ‚Üí (L ‚âÉ‚Çó‚ÅÖR‚ÅÜ L') ‚Üí L' ‚Üí L",
    "name": "LieEquiv.invFun",
    "isProp": false,
    "doc": "The inverse function of an equivalence of Lie algebras ",
    "depth": 17}],
  "count": 69},
 {"noDocExamples": [],
  "kind": "TopCat.Presheaf.¬´term__*_¬ª",
  "examples":
  [{"type":
    "{C : Type u} ‚Üí\n  [inst : CategoryTheory.Category.{v, u} C] ‚Üí\n    {X : TopCat} ‚Üí (‚Ñ± : TopCat.Presheaf C X) ‚Üí CategoryTheory.CategoryStruct.id X _* ‚Ñ± ‚âÖ ‚Ñ±",
    "name": "TopCat.Presheaf.Pushforward.id",
    "isProp": false,
    "doc":
    "The natural isomorphism between the pushforward of a presheaf along the identity continuous map\nand the original presheaf. ",
    "depth": 12},
   {"type":
    "‚àÄ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {X Y : TopCat} (f : X ‚ü∂ Y) {F : TopCat.Presheaf C X},\n  TopCat.Presheaf.IsSheaf F ‚Üí TopCat.Presheaf.IsSheaf (f _* F)",
    "name": "TopCat.Sheaf.pushforward_sheaf_of_sheaf",
    "isProp": true,
    "doc": "The pushforward of a sheaf (by a continuous map) is a sheaf.\n",
    "depth": 14},
   {"type":
    "{C : Type u_1} ‚Üí\n  [inst : CategoryTheory.Category.{u_2, u_1} C] ‚Üí\n    {X Y : AlgebraicGeometry.PresheafedSpace C} ‚Üí (H : X ‚âÖ Y) ‚Üí Y.presheaf ‚âÖ H.hom.base _* X.presheaf",
    "name": "AlgebraicGeometry.PresheafedSpace.sheafIsoOfIso",
    "isProp": false,
    "doc":
    "Isomorphic `PresheafedSpace`s have naturally isomorphic presheaves. ",
    "depth": 16}],
  "count": 69},
 {"noDocExamples": [],
  "kind": "Int.¬´term_‚â°_[ZMOD_]¬ª",
  "examples":
  [{"type": "‚àÄ {n a b : ‚Ñ§}, a ‚â° b [ZMOD n] ‚Üí n ‚à£ b - a",
    "name": "Int.ModEq.dvd",
    "isProp": true,
    "doc": "**Alias** of the forward direction of `Int.modEq_iff_dvd`.",
    "depth": 11},
   {"type": "‚àÄ {n a b : ‚Ñ§}, n ‚à£ b - a ‚Üí a ‚â° b [ZMOD n]",
    "name": "Int.modEq_of_dvd",
    "isProp": true,
    "doc": "**Alias** of the reverse direction of `Int.modEq_iff_dvd`.",
    "depth": 11},
   {"type":
    "‚àÄ {p : ‚Ñï}, Nat.Prime p ‚Üí ‚àÄ {n : ‚Ñ§}, IsCoprime n ‚Üëp ‚Üí n ^ (p - 1) ‚â° 1 [ZMOD ‚Üëp]",
    "name": "Int.ModEq.pow_card_sub_one_eq_one",
    "isProp": true,
    "doc":
    "**Fermat's Little Theorem**: for all `a : ‚Ñ§` coprime to `p`, we have\n`a ^ (p - 1) ‚â° 1 [ZMOD p]`. ",
    "depth": 13}],
  "count": 68},
 {"noDocExamples": [],
  "kind": "Asymptotics.¬´term_=Œò[_]_¬ª",
  "examples":
  [{"type":
    "‚àÄ {Œ± : Type u_1} {l : Filter Œ±} {f : Œ± ‚Üí ‚Ñù},\n  ((fun x => rexp (f x)) =Œò[l] fun x => 1) ‚Üî Filter.IsBoundedUnder (fun x x_1 => x ‚â§ x_1) l fun x => |f x|",
    "name": "Real.isTheta_exp_comp_one",
    "isProp": true,
    "doc":
    "`Real.exp (f x)` is bounded away from zero and infinity along a filter `l` if and only if\n`|f x|` is bounded from above along this filter. ",
    "depth": 13},
   {"type":
    "‚àÄ {Œ± : Type u_1} {E : Type u_3} {F' : Type u_7} [inst : Norm E] [inst_1 : SeminormedAddCommGroup F'] {f : Œ± ‚Üí E}\n  {g' : Œ± ‚Üí F'} {l : Filter Œ±}, (f =Œò[l] fun x => ‚Äñg' x‚Äñ) ‚Üí f =Œò[l] g'",
    "name": "Asymptotics.IsTheta.of_norm_right",
    "isProp": true,
    "doc":
    "**Alias** of the forward direction of `Asymptotics.isTheta_norm_right`.",
    "depth": 17},
   {"type":
    "‚àÄ {Œ± : Type u_1} {F : Type u_4} {E' : Type u_6} [inst : Norm F] [inst_1 : SeminormedAddCommGroup E'] {g : Œ± ‚Üí F}\n  {f' : Œ± ‚Üí E'} {l : Filter Œ±}, f' =Œò[l] g ‚Üí (fun x => ‚Äñf' x‚Äñ) =Œò[l] g",
    "name": "Asymptotics.IsTheta.norm_left",
    "isProp": true,
    "doc":
    "**Alias** of the reverse direction of `Asymptotics.isTheta_norm_left`.",
    "depth": 17}],
  "count": 68},
 {"noDocExamples": [],
  "kind": "CategoryTheory.Limits.¬´term‚àè_¬ª",
  "examples":
  [{"type":
    "(J : Type u) ‚Üí (f : J ‚Üí CategoryTheory.Grpd) ‚Üí CategoryTheory.Grpd.of ((j : J) ‚Üí ‚Üë(f j)) ‚âÖ ‚àè f",
    "name": "CategoryTheory.Grpd.piIsoPi",
    "isProp": false,
    "doc":
    "The product of a family of groupoids is isomorphic\nto the product object in the category of Groupoids ",
    "depth": 10},
   {"type":
    "{J : Type v} ‚Üí (F : J ‚Üí Type u) ‚Üí [inst : UnivLE.{v, u}] ‚Üí ‚àè F ‚âÖ Shrink ((j : J) ‚Üí F j)",
    "name": "CategoryTheory.Limits.Types.UnivLE.productIso",
    "isProp": false,
    "doc":
    "The categorical product in `Type u` indexed in `Type v`\nis the type theoretic product `Œ† j, F j`, after shrinking back to `Type u`. ",
    "depth": 11},
   {"type": "{J : Type v} ‚Üí (F : J ‚Üí TypeMax) ‚Üí ‚àè F ‚âÖ (j : J) ‚Üí F j",
    "name": "CategoryTheory.Limits.Types.productIso",
    "isProp": false,
    "doc":
    "The categorical product in `TypeMax.{v, u}` is the type theoretic product `Œ† j, F j`. ",
    "depth": 12}],
  "count": 67},
 {"noDocExamples": [],
  "kind": "¬´term_‚Üí‚Çó·µ¢[_]_¬ª",
  "examples":
  [{"type": "‚Ñù ‚Üí‚Çó·µ¢[‚Ñù] ‚ÑÇ",
    "name": "Complex.ofRealLi",
    "isProp": false,
    "doc": "Linear isometry version of the canonical embedding of `‚Ñù` in `‚ÑÇ`. ",
    "depth": 11},
   {"type": "{K : Type u_1} ‚Üí [inst : IsROrC K] ‚Üí ‚Ñù ‚Üí‚Çó·µ¢[‚Ñù] K",
    "name": "IsROrC.ofRealLi",
    "isProp": false,
    "doc": "The ‚Ñù ‚Üí K coercion, as a linear isometry ",
    "depth": 13},
   {"type":
    "{E : Type u_1} ‚Üí\n  [inst : NormedAddCommGroup E] ‚Üí\n    [inst_1 : InnerProductSpace ‚Ñù E] ‚Üí\n      [inst_2 : Fact (FiniteDimensional.finrank ‚Ñù E = 2)] ‚Üí Orientation ‚Ñù E (Fin 2) ‚Üí E ‚Üí‚Çó·µ¢[‚Ñù] E",
    "name": "Orientation.rightAngleRotationAux‚ÇÇ",
    "isProp": false,
    "doc":
    "Auxiliary construction for `Orientation.rightAngleRotation`, rotation by 90 degrees in an\noriented real inner product space of dimension 2. ",
    "depth": 16}],
  "count": 66},
 {"noDocExamples": [],
  "kind": "Nat.¬´term‚åä_‚åã‚Çä¬ª",
  "examples":
  [{"type":
    "‚àÄ {Œ± : Type u_2} [inst : LinearOrderedSemifield Œ±] [inst_1 : FloorSemiring Œ±] (m n : ‚Ñï), ‚åä‚Üëm / ‚Üën‚åã‚Çä = m / n",
    "name": "Nat.floor_div_eq_div",
    "isProp": true,
    "doc": "Natural division is the floor of field division. ",
    "depth": 18},
   {"type":
    "‚àÄ (u : ‚Ñï ‚Üí ‚Ñù) (l : ‚Ñù),\n  Monotone u ‚Üí\n    ‚àÄ (c : ‚Ñï ‚Üí ‚Ñù),\n      (‚àÄ (k : ‚Ñï), 1 < c k) ‚Üí\n        Filter.Tendsto c Filter.atTop (nhds 1) ‚Üí\n          (‚àÄ (k : ‚Ñï), Filter.Tendsto (fun n => u ‚åäc k ^ n‚åã‚Çä / ‚Üë‚åäc k ^ n‚åã‚Çä) Filter.atTop (nhds l)) ‚Üí\n            Filter.Tendsto (fun n => u n / ‚Üën) Filter.atTop (nhds l)",
    "name": "tendsto_div_of_monotone_of_tendsto_div_floor_pow",
    "isProp": true,
    "doc":
    "If a monotone sequence `u` is such that `u ‚åäc^n‚åã‚Çä / ‚åäc^n‚åã‚Çä` converges to a limit `l` for all\n`c > 1`, then `u n / n` tends to `l`. It is even enough to have the assumption for a sequence of\n`c`s converging to `1`. ",
    "depth": 22},
   {"type":
    "‚àÄ (N : ‚Ñï) {j : ‚Ñù},\n  0 < j ‚Üí\n    ‚àÄ {c : ‚Ñù},\n      1 < c ‚Üí\n        (Finset.sum (Finset.filter (fun x => j < ‚Üë‚åäc ^ x‚åã‚Çä) (Finset.range N)) fun i => 1 / ‚Üë‚åäc ^ i‚åã‚Çä ^ 2) ‚â§\n          c ^ 5 * (c - 1)‚Åª¬π ^ 3 / j ^ 2",
    "name": "sum_div_nat_floor_pow_sq_le_div_sq",
    "isProp": true,
    "doc":
    "The sum of `1/‚åäc^i‚åã‚Çä^2` above a threshold `j` is comparable to `1/j^2`, up to a multiplicative\nconstant. ",
    "depth": 22}],
  "count": 66},
 {"noDocExamples": [],
  "kind": "OmegaCompletePartialOrder.¬´term_‚ÜíùíÑ_¬ª",
  "examples":
  [{"type": "{Œ± : Type u} ‚Üí [inst : OmegaCompletePartialOrder Œ±] ‚Üí Œ± ‚ÜíùíÑ Œ±",
    "name": "OmegaCompletePartialOrder.ContinuousHom.id",
    "isProp": false,
    "doc": "The identity as a continuous function. ",
    "depth": 6},
   {"type":
    "{Œ± : Type u} ‚Üí\n  {Œ≤ : Type v} ‚Üí [inst : OmegaCompletePartialOrder Œ±] ‚Üí [inst_1 : OmegaCompletePartialOrder Œ≤] ‚Üí (Œ± ‚ÜíùíÑ Œ≤) ‚Üí Œ± ‚Üí Œ≤",
    "name": "OmegaCompletePartialOrder.ContinuousHom.Simps.apply",
    "isProp": false,
    "doc":
    "See Note [custom simps projection]. We specify this explicitly because we don't have a FunLike\ninstance.\n",
    "depth": 9},
   {"type":
    "{Œ± : Type u} ‚Üí {Œ≤ : Type v} ‚Üí [inst : OmegaCompletePartialOrder Œ±] ‚Üí [inst_1 : OmegaCompletePartialOrder Œ≤] ‚Üí Œ≤ ‚Üí Œ± ‚ÜíùíÑ Œ≤",
    "name": "OmegaCompletePartialOrder.ContinuousHom.const",
    "isProp": false,
    "doc": "`Function.const` is a continuous function. ",
    "depth": 9}],
  "count": 66},
 {"noDocExamples":
  [{"type":
    "{M : Type u_1} ‚Üí [inst : SubtractionMonoid M·µÉ·µí·µñ] ‚Üí SubtractionMonoid M·µà·µÉ·µÉ",
    "name": "DomAddAct.instDivisionAddMonoidDomAddAct",
    "isProp": false,
    "depth": 4},
   {"type": "{M : Type u_1} ‚Üí [inst : Add M·µÉ·µí·µñ] ‚Üí Add M·µà·µÉ·µÉ",
    "name": "DomAddAct.instAddDomAddAct",
    "isProp": false,
    "depth": 4}],
  "kind": "¬´term_·µà·µÉ·µÉ¬ª",
  "examples":
  [{"type": "{M : Type u_1} ‚Üí M ‚âÉ M·µà·µÉ·µÉ",
    "name": "DomAddAct.mk",
    "isProp": false,
    "doc": "Equivalence between `M` and `M·µà·µê·µÉ`.",
    "depth": 3}],
  "count": 65},
 {"noDocExamples":
  [{"type":
    "‚àÄ {Œ± : Type u_2} [inst : LinearOrderedRing Œ±] [inst_1 : FloorRing Œ±] (a : Œ±), ‚åäa‚åã ‚â§ ‚åàa‚åâ",
    "name": "Int.floor_le_ceil",
    "isProp": true,
    "depth": 10},
   {"type":
    "‚àÄ {Œ± : Type u_2} [inst : LinearOrderedRing Œ±] [inst_1 : FloorRing Œ±] (a : Œ±), ‚åàa‚åâ ‚â§ ‚åäa‚åã + 1",
    "name": "Int.ceil_le_floor_add_one",
    "isProp": true,
    "depth": 11}],
  "kind": "Int.¬´term‚åà_‚åâ¬ª",
  "examples":
  [{"type":
    "‚àÄ {Œæ q : ‚Ñö}, |Œæ - q| < 1 / ‚Üëq.den ^ 2 ‚Üí q.den ‚â§ Œæ.den ‚àß ‚åàŒæ * ‚Üëq.den‚åâ - 1 ‚â§ q.num ‚àß q.num ‚â§ ‚åäŒæ * ‚Üëq.den‚åã + 1",
    "name": "Rat.den_le_and_le_num_le_of_sub_lt_one_div_den_sq",
    "isProp": true,
    "doc":
    "If `Œæ` is rational, then the good rational approximations to `Œæ` have bounded\nnumerator and denominator. ",
    "depth": 17}],
  "count": 65},
 {"noDocExamples": [],
  "kind": "Relator.¬´term_‚áí_¬ª",
  "examples":
  [{"type":
    "{Œ± : Sort u_1} ‚Üí\n  {Œ≤ : Sort u_2} ‚Üí\n    {s‚ÇÅ : Setoid Œ±} ‚Üí {s‚ÇÇ : Setoid Œ≤} ‚Üí (f : Œ± ‚Üí Œ≤) ‚Üí (Setoid.r ‚áí Setoid.r) f f ‚Üí Quotient s‚ÇÅ ‚Üí Quotient s‚ÇÇ",
    "name": "Quotient.map'",
    "isProp": false,
    "doc":
    "Map a function `f : Œ± ‚Üí Œ≤` that sends equivalent elements to equivalent elements\nto a function `Quotient sa ‚Üí Quotient sb`. Useful to define unary operations on quotients. ",
    "depth": 14},
   {"type":
    "{Œ± : Sort u_1} ‚Üí\n  {Œ≤ : Sort u_2} ‚Üí {ra : Œ± ‚Üí Œ± ‚Üí Prop} ‚Üí {rb : Œ≤ ‚Üí Œ≤ ‚Üí Prop} ‚Üí (f : Œ± ‚Üí Œ≤) ‚Üí (ra ‚áí rb) f f ‚Üí Quot ra ‚Üí Quot rb",
    "name": "Quot.map",
    "isProp": false,
    "doc":
    "Map a function `f : Œ± ‚Üí Œ≤` such that `ra x y` implies `rb (f x) (f y)`\nto a map `Quot ra ‚Üí Quot rb`. ",
    "depth": 14},
   {"type":
    "{Œ± : Type u_1} ‚Üí\n  {Œ≤ : Type u_2} ‚Üí\n    {l : Filter Œ±} ‚Üí\n      {Œ≥ : Sort u_5} ‚Üí Filter.Germ l Œ≤ ‚Üí (F : (Œ± ‚Üí Œ≤) ‚Üí Œ≥) ‚Üí (Filter.EventuallyEq l ‚áí fun x x_1 => x = x_1) F F ‚Üí Œ≥",
    "name": "Filter.Germ.liftOn",
    "isProp": false,
    "doc":
    "Given a germ `f : Germ l Œ≤` and a function `F : (Œ± ‚Üí Œ≤) ‚Üí Œ≥` sending eventually equal functions\nto the same value, returns the value `F` takes on functions having germ `f` at `l`. ",
    "depth": 16}],
  "count": 64},
 {"noDocExamples": [],
  "kind": "¬´termÔø¢_¬ª",
  "examples":
  [{"type": "‚àÄ {Œ± : Type u_4} [self : CoheytingAlgebra Œ±] (a : Œ±), ‚ä§ \\ a = Ôø¢a",
    "name": "CoheytingAlgebra.top_sdiff",
    "isProp": true,
    "doc": "`‚ä§ \\ a` is `Ôø¢a` ",
    "depth": 11},
   {"type": "‚àÄ {Œ± : Type u_4} [self : BiheytingAlgebra Œ±] (a : Œ±), ‚ä§ \\ a = Ôø¢a",
    "name": "BiheytingAlgebra.top_sdiff",
    "isProp": true,
    "doc": "`‚ä§ \\ a` is `Ôø¢a` ",
    "depth": 12},
   {"type":
    "‚àÄ {Œ± : Type u_2} [inst : CoheytingAlgebra Œ±] {a b : Œ±}, Codisjoint b a ‚Üí Ôø¢a ‚â§ b",
    "name": "Codisjoint.hnot_le_left",
    "isProp": true,
    "doc":
    "**Alias** of the reverse direction of `hnot_le_iff_codisjoint_left`.",
    "depth": 17}],
  "count": 64},
 {"noDocExamples":
  [{"type":
    "‚àÄ (n : ‚Ñï), Nat.div2 (Nat.succ n) = bif Nat.bodd n then Nat.succ (Nat.div2 n) else Nat.div2 n",
    "name": "Nat.div2_succ",
    "isProp": true,
    "depth": 6},
   {"type": "‚àÄ {Œ± : Type u} (b : Bool) (a : Œ±), (bif b then a else a) = a",
    "name": "Bool.cond_self",
    "isProp": true,
    "depth": 9}],
  "kind": "boolIfThenElse",
  "examples":
  [{"type":
    "‚àÄ (p : ENNReal) (h : p ‚â§ 1), Pmf.binomial p h 1 = Pmf.map (fun x => bif x then 1 else 0) (Pmf.bernoulli p h)",
    "name": "Pmf.binomial_one_eq_bernoulli",
    "isProp": true,
    "doc":
    "The binomial distribution on one coin is the bernoully distribution. ",
    "depth": 18}],
  "count": 63},
 {"noDocExamples": [],
  "kind": "Lean.Parser.Term.let_fun",
  "examples":
  [{"type":
    "(V W : SemiNormedGroupCat) ‚Üí\n  let_fun this := fun V W => inferInstanceAs (AddGroup (NormedAddGroupHom ‚ÜëV ‚ÜëW));\n  (V ‚ü∂ W) ‚Üí+ (SemiNormedGroupCat.completion.obj V ‚ü∂ SemiNormedGroupCat.completion.obj W)",
    "name": "SemiNormedGroupCat.completion.mapHom",
    "isProp": false,
    "doc":
    "Given a normed group hom `V ‚ü∂ W`, this defines the associated morphism\nfrom the completion of `V` to the completion of `W`.\nThe difference from the definition obtained from the functoriality of completion is in that the\nmap sending a morphism `f` to the associated morphism of completions is itself additive. ",
    "depth": 20},
   {"type":
    "‚àÄ {Œπ : Type u_1} {B : Type u_2} {F : Type u_3} [inst : TopologicalSpace B] [inst_1 : TopologicalSpace F]\n  (Z : FiberBundleCore Œπ B F) (v : F),\n  (‚àÄ (i j : Œπ) (x : B),\n      x ‚àà FiberBundleCore.baseSet Z i ‚à© FiberBundleCore.baseSet Z j ‚Üí FiberBundleCore.coordChange Z i j x v = v) ‚Üí\n    Continuous\n      (let_fun this := fun x => { proj := x, snd := v };\n      this)",
    "name": "FiberBundleCore.continuous_const_section",
    "isProp": true,
    "doc":
    "If an element of `F` is invariant under all coordinate changes, then one can define a\ncorresponding section of the fiber bundle, which is continuous. This applies in particular to the\nzero section of a vector bundle. Another example (not yet defined) would be the identity\nsection of the endomorphism bundle of a vector bundle. ",
    "depth": 24},
   {"type":
    "{R : Type u‚ÇÅ} ‚Üí\n  {S : Type u‚ÇÇ} ‚Üí\n    [inst : CommRing R] ‚Üí\n      [inst_1 : CommRing S] ‚Üí\n        (f : R ‚Üí+* S) ‚Üí\n          {X : ModuleCat R} ‚Üí\n            {Y : ModuleCat S} ‚Üí\n              S ‚Üí\n                (X ‚ü∂ (CategoryTheory.ModuleCat.restrictScalars f).obj Y) ‚Üí\n                  let_fun this := Module.compHom (‚ÜëY) f;\n                  ‚ÜëX ‚Üí‚Çó[R] ‚ÜëY",
    "name": "CategoryTheory.ModuleCat.ExtendRestrictScalarsAdj.HomEquiv.evalAt",
    "isProp": false,
    "doc": "The map `S ‚Üí X ‚Üí‚Çó[R] Y` given by `fun s x => s ‚Ä¢ (g x)`\n",
    "depth": 24}],
  "count": 63},
 {"noDocExamples": [],
  "kind": "¬´term_‚â∫i_¬ª",
  "examples":
  [{"type": "EmptyRelation ‚â∫i EmptyRelation",
    "name": "PrincipalSeg.pemptyToPunit",
    "isProp": false,
    "doc":
    "Principal segment from the empty relation on `PEmpty` to the empty relation on `PUnit`. ",
    "depth": 4},
   {"type":
    "{Œ± : Type u_4} ‚Üí {Œ≤ : Type u_5} ‚Üí {r : Œ± ‚Üí Œ± ‚Üí Prop} ‚Üí {s : Œ≤ ‚Üí Œ≤ ‚Üí Prop} ‚Üí r ‚â∫i s ‚Üí Œ≤",
    "name": "PrincipalSeg.top",
    "isProp": false,
    "doc": "The supremum of the principal segment ",
    "depth": 9},
   {"type": "(fun x x_1 => x < x_1) ‚â∫i fun x x_1 => x < x_1",
    "name": "Ordinal.lift.principalSeg",
    "isProp": false,
    "doc":
    "Principal segment version of the lift operation on ordinals, embedding `ordinal.{u}` in\n`ordinal.{v}` as a principal segment when `u < v`. ",
    "depth": 10}],
  "count": 62},
 {"noDocExamples": [],
  "kind": "Lean.Parser.Term.do",
  "examples":
  [{"type":
    "‚àÄ (cf cg : Nat.Partrec.Code) (a k : ‚Ñï),\n  Nat.Partrec.Code.eval (Nat.Partrec.Code.prec cf cg) (Nat.pair a (Nat.succ k)) = do\n    let ih ‚Üê Nat.Partrec.Code.eval (Nat.Partrec.Code.prec cf cg) (Nat.pair a k)\n    Nat.Partrec.Code.eval cg (Nat.pair a (Nat.pair k ih))",
    "name": "Nat.Partrec.Code.eval_prec_succ",
    "isProp": true,
    "doc": "Helper lemma for the evaluation of `prec` in the recursive case. ",
    "depth": 12},
   {"type":
    "‚àÄ (m : Type u ‚Üí Type v) [inst : Monad m],\n  (‚àÄ {Œ± : Type u} (x : m Œ±), id <$> x = x) ‚Üí\n    (‚àÄ {Œ± Œ≤ : Type u} (x : Œ±) (f : Œ± ‚Üí m Œ≤), pure x >>= f = f x) ‚Üí\n      (‚àÄ {Œ± Œ≤ Œ≥ : Type u} (x : m Œ±) (f : Œ± ‚Üí m Œ≤) (g : Œ≤ ‚Üí m Œ≥), x >>= f >>= g = x >>= fun x => f x >>= g) ‚Üí\n        autoParam (‚àÄ {Œ± Œ≤ : Type u} (x : Œ±) (y : m Œ≤), Functor.mapConst x y = Function.const Œ≤ x <$> y) _auto‚úù ‚Üí\n          autoParam\n              (‚àÄ {Œ± Œ≤ : Type u} (x : m Œ±) (y : m Œ≤),\n                (SeqLeft.seqLeft x fun x => y) = do\n                  let a ‚Üê x\n                  let _ ‚Üê y\n                  pure a)\n              _auto‚úù¬π ‚Üí\n            autoParam\n                (‚àÄ {Œ± Œ≤ : Type u} (x : m Œ±) (y : m Œ≤),\n                  (SeqRight.seqRight x fun x => y) = do\n                    let _ ‚Üê x\n                    y)\n                _auto‚úù¬≤ ‚Üí\n              autoParam\n                  (‚àÄ {Œ± Œ≤ : Type u} (f : Œ± ‚Üí Œ≤) (x : m Œ±),\n                    (do\n                        let y ‚Üê x\n                        pure (f y)) =\n                      f <$> x)\n                  _auto‚úù¬≥ ‚Üí\n                autoParam\n                    (‚àÄ {Œ± Œ≤ : Type u} (f : m (Œ± ‚Üí Œ≤)) (x : m Œ±),\n                      (do\n                          let x_1 ‚Üê f\n                          x_1 <$> x) =\n                        Seq.seq f fun x_1 => x)\n                    _auto‚úù‚Å¥ ‚Üí\n                  LawfulMonad m",
    "name": "LawfulMonad.mk'",
    "isProp": true,
    "doc":
    "An alternative constructor for `LawfulMonad` which has more\ndefaultable fields in the common case.\n",
    "depth": 28},
   {"type":
    "Bool ‚Üí\n  List Lean.Expr ‚Üí\n    optParam Linarith.LinarithConfig\n        {\n          discharger := do\n            let __do_lift ‚Üê\n              do\n                let info ‚Üê Lean.MonadRef.mkInfoFromRefPos\n                let _ ‚Üê Lean.getCurrMacroScope\n                let _ ‚Üê Lean.getMainModule\n                pure { raw := Lean.Syntax.node1 info `Mathlib.Tactic.RingNF.ring (Lean.Syntax.atom info \"ring\") }\n            Lean.Elab.Tactic.evalTactic __do_lift.raw,\n          exfalso := true, transparency := Lean.Meta.TransparencyMode.reducible, splitHypotheses := true,\n          splitNe := false, preprocessors := none, oracle := none } ‚Üí\n      Lean.MVarId ‚Üí Lean.MetaM Unit",
    "name": "Linarith.linarith",
    "isProp": false,
    "doc":
    "`linarith only_on hyps cfg` tries to close the goal using linear arithmetic. It fails\nif it does not succeed at doing this.\n\n* `hyps` is a list of proofs of comparisons to include in the search.\n* If `only_on` is true, the search will be restricted to `hyps`. Otherwise it will use all\n  comparisons in the local context.\n* If `cfg.transparency := semireducible`,\n  it will unfold semireducible definitions when trying to match atomic expressions.\n",
    "depth": 33}],
  "count": 62},
 {"noDocExamples": [],
  "kind": "¬´term_‚Üí‚Çõ‚Çó·µ¢[_]_¬ª",
  "examples":
  [{"type":
    "{R : Type u_1} ‚Üí\n  {R‚ÇÇ : Type u_2} ‚Üí\n    [inst : Semiring R] ‚Üí\n      [inst_1 : Semiring R‚ÇÇ] ‚Üí\n        (œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ) ‚Üí\n          (E : Type u_11) ‚Üí\n            (E‚ÇÇ : Type u_12) ‚Üí\n              [inst_2 : SeminormedAddCommGroup E] ‚Üí\n                [inst_3 : SeminormedAddCommGroup E‚ÇÇ] ‚Üí\n                  [inst_4 : Module R E] ‚Üí [inst_5 : Module R‚ÇÇ E‚ÇÇ] ‚Üí (E ‚Üí‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ) ‚Üí E ‚Üí E‚ÇÇ",
    "name": "LinearIsometry.Simps.apply",
    "isProp": false,
    "doc":
    "See Note [custom simps projection]. We need to specify this projection explicitly in this case,\nbecause it is a composition of multiple projections. ",
    "depth": 23},
   {"type":
    "{R : Type u_1} ‚Üí\n  {R‚ÇÇ : Type u_2} ‚Üí\n    {E : Type u_5} ‚Üí\n      {E‚ÇÇ : Type u_6} ‚Üí\n        [inst : Semiring R] ‚Üí\n          [inst_1 : Semiring R‚ÇÇ] ‚Üí\n            {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} ‚Üí\n              [inst_2 : SeminormedAddCommGroup E] ‚Üí\n                [inst_3 : SeminormedAddCommGroup E‚ÇÇ] ‚Üí\n                  [inst_4 : Module R E] ‚Üí [inst_5 : Module R‚ÇÇ E‚ÇÇ] ‚Üí (E ‚Üí‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ) ‚Üí E ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ",
    "name": "LinearIsometry.toContinuousLinearMap",
    "isProp": false,
    "doc": "Interpret a linear isometry as a continuous linear map. ",
    "depth": 25},
   {"type":
    "{R : Type u_1} ‚Üí\n  {R‚ÇÇ : Type u_2} ‚Üí\n    {E : Type u_5} ‚Üí\n      {E‚ÇÇ : Type u_6} ‚Üí\n        [inst : Semiring R] ‚Üí\n          [inst_1 : Semiring R‚ÇÇ] ‚Üí\n            {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} ‚Üí\n              {œÉ‚ÇÇ‚ÇÅ : R‚ÇÇ ‚Üí+* R} ‚Üí\n                [inst_2 : RingHomInvPair œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÅ] ‚Üí\n                  [inst_3 : RingHomInvPair œÉ‚ÇÇ‚ÇÅ œÉ‚ÇÅ‚ÇÇ] ‚Üí\n                    [inst_4 : SeminormedAddCommGroup E] ‚Üí\n                      [inst_5 : SeminormedAddCommGroup E‚ÇÇ] ‚Üí\n                        [inst_6 : Module R E] ‚Üí [inst_7 : Module R‚ÇÇ E‚ÇÇ] ‚Üí (E ‚âÉ‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ) ‚Üí E ‚Üí‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ",
    "name": "LinearIsometryEquiv.toLinearIsometry",
    "isProp": false,
    "doc": "Reinterpret a `LinearIsometryEquiv` as a `LinearIsometry`. ",
    "depth": 29}],
  "count": 62},
 {"noDocExamples": [],
  "kind": "Vector.¬´term_::·µ•_¬ª",
  "examples":
  [{"type":
    "‚àÄ {Œ± : Type u} {n : ‚Ñï} (a : Œ±) (v : Vector Œ± n), Vector.toList (a ::·µ• v) = a :: Vector.toList v",
    "name": "Vector.toList_cons",
    "isProp": true,
    "doc":
    "`toList` of `cons` of a vector and an element is\nthe `cons` of the list obtained by `toList` and the element ",
    "depth": 11},
   {"type":
    "‚àÄ {Œ± : Type u} {n : ‚Ñï} (a : Œ±) (v : Vector Œ± n), Vector.head (a ::·µ• v) = a",
    "name": "Vector.head_cons",
    "isProp": true,
    "doc":
    "The head of a vector obtained by prepending is the element prepended. ",
    "depth": 11},
   {"type":
    "‚àÄ {Œ± : Type u_1} {ix : Fin 1} (x : Œ±), Vector.get (x ::·µ• Vector.nil) ix = x",
    "name": "Vector.get_cons_nil",
    "isProp": true,
    "doc":
    "Accessing the nth element of a vector made up\nof one element `x : Œ±` is `x` itself. ",
    "depth": 13}],
  "count": 60},
 {"noDocExamples": [],
  "kind": "¬´term_‚âÉ._¬ª",
  "examples":
  [{"type": "(Œ± : Type u_1) ‚Üí Œ± ‚âÉ. Œ±",
    "name": "PEquiv.refl",
    "isProp": false,
    "doc": "The identity map as a partial equivalence. ",
    "depth": 3},
   {"type": "{Œ± : Type u} ‚Üí {Œ≤ : Type v} ‚Üí (Œ± ‚âÉ. Œ≤) ‚Üí Œ± ‚Üí Option Œ≤",
    "name": "PEquiv.toFun",
    "isProp": false,
    "doc": "The underlying partial function of a `PEquiv` ",
    "depth": 5},
   {"type": "{Œ± : Type u_1} ‚Üí {Œ≤ : Type u_2} ‚Üí Œ± ‚âÉ Œ≤ ‚Üí Œ± ‚âÉ. Œ≤",
    "name": "Equiv.toPEquiv",
    "isProp": false,
    "doc": "Turns an `Equiv` into a `PEquiv` of the whole type. ",
    "depth": 5}],
  "count": 59},
 {"noDocExamples": [],
  "kind": "¬´term_‚âÉ‚Çõ‚Çó·µ¢[_]_¬ª",
  "examples":
  [{"type":
    "{R : Type u_1} ‚Üí\n  {R‚ÇÇ : Type u_2} ‚Üí\n    {E : Type u_5} ‚Üí\n      {E‚ÇÇ : Type u_6} ‚Üí\n        [inst : Semiring R] ‚Üí\n          [inst_1 : Semiring R‚ÇÇ] ‚Üí\n            {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} ‚Üí\n              {œÉ‚ÇÇ‚ÇÅ : R‚ÇÇ ‚Üí+* R} ‚Üí\n                [inst_2 : RingHomInvPair œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÅ] ‚Üí\n                  [inst_3 : RingHomInvPair œÉ‚ÇÇ‚ÇÅ œÉ‚ÇÅ‚ÇÇ] ‚Üí\n                    [inst_4 : SeminormedAddCommGroup E] ‚Üí\n                      [inst_5 : SeminormedAddCommGroup E‚ÇÇ] ‚Üí\n                        [inst_6 : Module R E] ‚Üí [inst_7 : Module R‚ÇÇ E‚ÇÇ] ‚Üí (E ‚âÉ‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ) ‚Üí E‚ÇÇ ‚âÉ‚Çõ‚Çó·µ¢[œÉ‚ÇÇ‚ÇÅ] E",
    "name": "LinearIsometryEquiv.symm",
    "isProp": false,
    "doc": "The inverse `LinearIsometryEquiv`. ",
    "depth": 29},
   {"type":
    "{R : Type u_1} ‚Üí\n  {R‚ÇÇ : Type u_2} ‚Üí\n    [inst : Semiring R] ‚Üí\n      [inst_1 : Semiring R‚ÇÇ] ‚Üí\n        (œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ) ‚Üí\n          {œÉ‚ÇÇ‚ÇÅ : R‚ÇÇ ‚Üí+* R} ‚Üí\n            [inst_2 : RingHomInvPair œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÅ] ‚Üí\n              [inst_3 : RingHomInvPair œÉ‚ÇÇ‚ÇÅ œÉ‚ÇÅ‚ÇÇ] ‚Üí\n                (E : Type u_11) ‚Üí\n                  (E‚ÇÇ : Type u_12) ‚Üí\n                    [inst_4 : SeminormedAddCommGroup E] ‚Üí\n                      [inst_5 : SeminormedAddCommGroup E‚ÇÇ] ‚Üí\n                        [inst_6 : Module R E] ‚Üí [inst_7 : Module R‚ÇÇ E‚ÇÇ] ‚Üí (E ‚âÉ‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ) ‚Üí E‚ÇÇ ‚Üí E",
    "name": "LinearIsometryEquiv.Simps.symm_apply",
    "isProp": false,
    "doc": "See Note [custom simps projection] ",
    "depth": 29},
   {"type":
    "{R : Type u_1} ‚Üí\n  {R‚ÇÇ : Type u_2} ‚Üí\n    {E : Type u_5} ‚Üí\n      {E‚ÇÇ : Type u_6} ‚Üí\n        [inst : Semiring R] ‚Üí\n          [inst_1 : Semiring R‚ÇÇ] ‚Üí\n            {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} ‚Üí\n              {œÉ‚ÇÇ‚ÇÅ : R‚ÇÇ ‚Üí+* R} ‚Üí\n                [inst_2 : RingHomInvPair œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÅ] ‚Üí\n                  [inst_3 : RingHomInvPair œÉ‚ÇÇ‚ÇÅ œÉ‚ÇÅ‚ÇÇ] ‚Üí\n                    [inst_4 : SeminormedAddCommGroup E] ‚Üí\n                      [inst_5 : SeminormedAddCommGroup E‚ÇÇ] ‚Üí\n                        [inst_6 : Module R E] ‚Üí [inst_7 : Module R‚ÇÇ E‚ÇÇ] ‚Üí (E ‚âÉ‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ) ‚Üí E ‚Üí‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ",
    "name": "LinearIsometryEquiv.toLinearIsometry",
    "isProp": false,
    "doc": "Reinterpret a `LinearIsometryEquiv` as a `LinearIsometry`. ",
    "depth": 29}],
  "count": 58},
 {"noDocExamples": [],
  "kind": "¬´FreimanHomLocal‚â∫¬ª",
  "examples":
  [{"type":
    "{Œ± : Type u_2} ‚Üí [inst : CommMonoid Œ±] ‚Üí (A : Set Œ±) ‚Üí (n : ‚Ñï) ‚Üí A ‚Üí*[n] Œ±",
    "name": "FreimanHom.id",
    "isProp": false,
    "doc": "The identity map from a commutative monoid to itself. ",
    "depth": 10},
   {"type":
    "{Œ± : Type u_2} ‚Üí\n  {Œ≤ : Type u_3} ‚Üí [inst : CommMonoid Œ±] ‚Üí [inst_1 : CommMonoid Œ≤] ‚Üí {A : Set Œ±} ‚Üí {n : ‚Ñï} ‚Üí CommMonoid (A ‚Üí*[n] Œ≤)",
    "name": "FreimanHom.commMonoid",
    "isProp": false,
    "doc": "`A ‚Üí*[n] Œ≤` is a `CommMonoid`. ",
    "depth": 13},
   {"type":
    "{Œ± : Type u_2} ‚Üí\n  {Œ≤ : Type u_3} ‚Üí [inst : CommMonoid Œ±] ‚Üí [inst_1 : CommMonoid Œ≤] ‚Üí {A : Set Œ±} ‚Üí {n : ‚Ñï} ‚Üí Mul (A ‚Üí*[n] Œ≤)",
    "name": "FreimanHom.instMulFreimanHom",
    "isProp": false,
    "doc": "`f * g` is the Freiman homomorphism sends `x` to `f x * g x`. ",
    "depth": 13}],
  "count": 58},
 {"noDocExamples": [],
  "kind": "Set.termŒô",
  "examples":
  [{"type":
    "‚àÄ {E : Type u_3} [inst : NormedAddCommGroup E] {f : ‚Ñù ‚Üí E} {a b : ‚Ñù} {Œº : MeasureTheory.Measure ‚Ñù},\n  IntervalIntegrable f Œº a b ‚Üí MeasureTheory.IntegrableOn f (Œô a b)",
    "name": "IntervalIntegrable.def",
    "isProp": true,
    "doc":
    "If a function is interval integrable with respect to a given measure `Œº` on `a..b` then\nit is integrable on `uIoc a b` with respect to `Œº`. ",
    "depth": 14},
   {"type":
    "‚àÄ {E : Type u_3} [inst : NormedAddCommGroup E] {f : ‚Ñù ‚Üí E} {a b : ‚Ñù} {Œº : MeasureTheory.Measure ‚Ñù},\n  IntervalIntegrable f Œº a b ‚Üî MeasureTheory.IntegrableOn f (Œô a b)",
    "name": "intervalIntegrable_iff",
    "isProp": true,
    "doc":
    "A function is interval integrable with respect to a given measure `Œº` on `a..b` if and\nonly if it is integrable on `uIoc a b` with respect to `Œº`. This is an equivalent\ndefinition of `IntervalIntegrable`. ",
    "depth": 14},
   {"type":
    "‚àÄ {a b : ‚Ñù} (n : ‚Ñï), ‚à´ (x : ‚Ñù) in Œô a b, |x - a| ^ n = |b - a| ^ (n + 1) / (‚Üën + 1)",
    "name": "integral_pow_abs_sub_uIoc",
    "isProp": true,
    "doc":
    "Integral of `|x - a| ^ n` over `Œô a b`. This integral appears in the proof of the\nPicard-Lindel√∂f/Cauchy-Lipschitz theorem. ",
    "depth": 16}],
  "count": 58},
 {"noDocExamples": [],
  "kind": "term‚Ñô",
  "examples":
  [{"type":
    "{K : Type u_1} ‚Üí\n  {V : Type u_2} ‚Üí [inst : DivisionRing K] ‚Üí [inst_1 : AddCommGroup V] ‚Üí [inst_2 : Module K V] ‚Üí ‚Ñô K V ‚Üí V",
    "name": "Projectivization.rep",
    "isProp": false,
    "doc": "Choose a representative of `v : Projectivization K V` in `V`. ",
    "depth": 11},
   {"type":
    "{K : Type u_1} ‚Üí\n  {V : Type u_2} ‚Üí [inst : DivisionRing K] ‚Üí [inst_1 : AddCommGroup V] ‚Üí [inst_2 : Module K V] ‚Üí ‚Ñô K V ‚Üí Submodule K V",
    "name": "Projectivization.submodule",
    "isProp": false,
    "doc":
    "Consider an element of the projectivization as a submodule of `V`. ",
    "depth": 12},
   {"type":
    "{K : Type u_1} ‚Üí\n  {V : Type u_2} ‚Üí\n    [inst : Field K] ‚Üí [inst_1 : AddCommGroup V] ‚Üí [inst_2 : Module K V] ‚Üí Set (‚Ñô K V) ‚Üí Projectivization.Subspace K V",
    "name": "Projectivization.Subspace.span",
    "isProp": false,
    "doc": "The span of a set of points in projective space is a subspace. ",
    "depth": 12}],
  "count": 58},
 {"noDocExamples": [],
  "kind": "¬´term_‚âºi_¬ª",
  "examples":
  [{"type": "{Œ± : Type u_1} ‚Üí (r : Œ± ‚Üí Œ± ‚Üí Prop) ‚Üí r ‚âºi r",
    "name": "InitialSeg.refl",
    "isProp": false,
    "doc": "The identity function shows that `‚âºi` is reflexive ",
    "depth": 6},
   {"type":
    "{Œ± : Type u_1} ‚Üí {Œ≤ : Type u_2} ‚Üí (r : Œ± ‚Üí Œ± ‚Üí Prop) ‚Üí (s : Œ≤ ‚Üí Œ≤ ‚Üí Prop) ‚Üí r ‚âºi Sum.Lex r s",
    "name": "InitialSeg.leAdd",
    "isProp": false,
    "doc":
    "Initial segment embedding of an order `r` into the disjoint union of `r` and `s`. ",
    "depth": 9},
   {"type":
    "{Œ± : Type u_1} ‚Üí {Œ≤ : Type u_2} ‚Üí (r : Œ± ‚Üí Œ± ‚Üí Prop) ‚Üí (s : Œ≤ ‚Üí Œ≤ ‚Üí Prop) ‚Üí [inst : IsEmpty Œ±] ‚Üí r ‚âºi s",
    "name": "InitialSeg.ofIsEmpty",
    "isProp": false,
    "doc": "Initial segment from an empty type. ",
    "depth": 9}],
  "count": 57},
 {"noDocExamples": [],
  "kind": "¬´AddFreimanHomLocal‚â∫¬ª",
  "examples":
  [{"type":
    "{Œ± : Type u_2} ‚Üí [inst : AddCommMonoid Œ±] ‚Üí (A : Set Œ±) ‚Üí (n : ‚Ñï) ‚Üí A ‚Üí+[n] Œ±",
    "name": "AddFreimanHom.id",
    "isProp": false,
    "doc": "The identity map from an additive commutative monoid to itself.",
    "depth": 10},
   {"type":
    "{Œ± : Type u_2} ‚Üí\n  [inst : AddCommMonoid Œ±] ‚Üí\n    {A : Set Œ±} ‚Üí {n : ‚Ñï} ‚Üí {Œ≤ : Type u_7} ‚Üí [inst_1 : AddCommGroup Œ≤] ‚Üí AddCommGroup (A ‚Üí+[n] Œ≤)",
    "name": "AddFreimanHom.addCommGroup",
    "isProp": false,
    "doc":
    "If `Œ≤` is an additive commutative group, then `A ‚Üí*[n] Œ≤` is an additive commutative\ngroup too.",
    "depth": 13},
   {"type":
    "{Œ± : Type u_2} ‚Üí\n  {Œ≤ : Type u_3} ‚Üí [inst : AddCommMonoid Œ±] ‚Üí [inst_1 : AddCommMonoid Œ≤] ‚Üí (A : Set Œ±) ‚Üí (n : ‚Ñï) ‚Üí (Œ± ‚Üí+ Œ≤) ‚Üí A ‚Üí+[n] Œ≤",
    "name": "AddMonoidHom.toAddFreimanHom",
    "isProp": false,
    "doc": "An `AddMonoidHom` is naturally an `AddFreimanHom`",
    "depth": 13}],
  "count": 57},
 {"noDocExamples": [],
  "kind": "¬´term_‚âÉ·µà_¬ª",
  "examples":
  [{"type": "(X : Type u_4) ‚Üí [inst : PseudoEMetricSpace X] ‚Üí X ‚âÉ·µà X",
    "name": "DilationEquiv.refl",
    "isProp": false,
    "doc": "Identity map as a `DilationEquiv`. ",
    "depth": 6},
   {"type":
    "{X : Type u_1} ‚Üí {Y : Type u_2} ‚Üí [inst : PseudoEMetricSpace X] ‚Üí [inst_1 : PseudoEMetricSpace Y] ‚Üí X ‚âÉ·µà Y ‚Üí Y ‚âÉ·µà X",
    "name": "DilationEquiv.symm",
    "isProp": false,
    "doc": "Inverse `DilationEquiv`. ",
    "depth": 9},
   {"type":
    "{X : Type u_1} ‚Üí {Y : Type u_2} ‚Üí [inst : PseudoEMetricSpace X] ‚Üí [inst_1 : PseudoEMetricSpace Y] ‚Üí X ‚âÉ·µà Y ‚Üí Y ‚Üí X",
    "name": "DilationEquiv.Simps.symm_apply",
    "isProp": false,
    "doc": "See Note [custom simps projection]. ",
    "depth": 9}],
  "count": 55},
 {"noDocExamples": [],
  "kind": "¬´term_‚Üí+*o_¬ª",
  "examples":
  [{"type":
    "(Œ± : Type u_2) ‚Üí [inst : NonAssocSemiring Œ±] ‚Üí [inst_1 : Preorder Œ±] ‚Üí Œ± ‚Üí+*o Œ±",
    "name": "OrderRingHom.id",
    "isProp": false,
    "doc": "The identity as an ordered ring homomorphism. ",
    "depth": 9},
   {"type":
    "{Œ± : Type u_6} ‚Üí\n  {Œ≤ : Type u_7} ‚Üí\n    [inst : NonAssocSemiring Œ±] ‚Üí\n      [inst_1 : Preorder Œ±] ‚Üí [inst_2 : NonAssocSemiring Œ≤] ‚Üí [inst_3 : Preorder Œ≤] ‚Üí Œ± ‚Üí+*o Œ≤ ‚Üí Œ± ‚Üí+* Œ≤",
    "name": "OrderRingHom.toRingHom",
    "isProp": false,
    "doc": "Reinterpret an ordered ring homomorphism as a ring homomorphism. ",
    "depth": 13},
   {"type":
    "{Œ± : Type u_2} ‚Üí\n  {Œ≤ : Type u_3} ‚Üí\n    [inst : NonAssocSemiring Œ±] ‚Üí\n      [inst_1 : Preorder Œ±] ‚Üí [inst_2 : NonAssocSemiring Œ≤] ‚Üí [inst_3 : Preorder Œ≤] ‚Üí Œ± ‚Üí+*o Œ≤ ‚Üí Œ± ‚Üí*‚ÇÄo Œ≤",
    "name": "OrderRingHom.toOrderMonoidWithZeroHom",
    "isProp": false,
    "doc":
    "Reinterpret an ordered ring homomorphism as an order homomorphism. ",
    "depth": 13}],
  "count": 53},
 {"noDocExamples": [],
  "kind": "IntermediateField.¬´term_‚üÆ_,,‚üØ¬ª",
  "examples":
  [{"type":
    "‚àÄ {F : Type u_1} [inst : Field F] {E : Type u_2} [inst_1 : Field E] [inst_2 : Algebra F E] (x : E),\n  CompleteLattice.IsCompactElement F‚üÆx‚üØ",
    "name": "IntermediateField.adjoin_simple_isCompactElement",
    "isProp": true,
    "doc":
    "Adjoining a single element is compact in the lattice of intermediate fields. ",
    "depth": 14},
   {"type":
    "‚àÄ (F : Type u_1) [inst : Field F] (E : Type u_2) [inst_1 : Field E] [inst_2 : Algebra F E] [inst_3 : Finite E],\n  ‚àÉ Œ±, F‚üÆŒ±‚üØ = ‚ä§",
    "name": "Field.exists_primitive_element_of_finite_top",
    "isProp": true,
    "doc": "**Primitive element theorem** assuming E is finite. ",
    "depth": 17},
   {"type":
    "‚àÄ (F : Type u_1) (E : Type u_2) [inst : Field F] [inst_1 : Field E] [inst_2 : Algebra F E]\n  [inst_3 : FiniteDimensional F E] [inst_4 : IsSeparable F E], ‚àÉ Œ±, F‚üÆŒ±‚üØ = ‚ä§",
    "name": "Field.exists_primitive_element",
    "isProp": true,
    "doc":
    "Primitive element theorem: a finite separable field extension `E` of `F` has a\nprimitive element, i.e. there is an `Œ± ‚àà E` such that `F‚üÆŒ±‚üØ = (‚ä§ : Subalgebra F E)`.",
    "depth": 18}],
  "count": 51},
 {"noDocExamples": [],
  "kind": "¬´term_‚Üí·µÉ‚Å±[_]_¬ª",
  "examples":
  [{"type":
    "{ùïú : Type u_1} ‚Üí\n  {V : Type u_2} ‚Üí\n    {P : Type u_8} ‚Üí\n      [inst : NormedField ùïú] ‚Üí\n        [inst_1 : SeminormedAddCommGroup V] ‚Üí\n          [inst_2 : NormedSpace ùïú V] ‚Üí [inst_3 : PseudoMetricSpace P] ‚Üí [inst_4 : NormedAddTorsor V P] ‚Üí P ‚Üí·µÉ‚Å±[ùïú] P",
    "name": "AffineIsometry.id",
    "isProp": false,
    "doc": "The identity affine isometry. ",
    "depth": 22},
   {"type":
    "{ùïú : Type u_1} ‚Üí\n  {V : Type u_2} ‚Üí\n    {V‚ÇÇ : Type u_4} ‚Üí\n      [inst : NormedField ùïú] ‚Üí\n        [inst_1 : SeminormedAddCommGroup V] ‚Üí\n          [inst_2 : SeminormedAddCommGroup V‚ÇÇ] ‚Üí\n            [inst_3 : NormedSpace ùïú V] ‚Üí [inst_4 : NormedSpace ùïú V‚ÇÇ] ‚Üí (V ‚Üí‚Çó·µ¢[ùïú] V‚ÇÇ) ‚Üí V ‚Üí·µÉ‚Å±[ùïú] V‚ÇÇ",
    "name": "LinearIsometry.toAffineIsometry",
    "isProp": false,
    "doc": "Reinterpret a linear isometry as an affine isometry. ",
    "depth": 23},
   {"type":
    "{ùïú : Type u_1} ‚Üí\n  {V : Type u_2} ‚Üí\n    {V‚ÇÇ : Type u_4} ‚Üí\n      {P : Type u_8} ‚Üí\n        {P‚ÇÇ : Type u_9} ‚Üí\n          [inst : NormedField ùïú] ‚Üí\n            [inst_1 : SeminormedAddCommGroup V] ‚Üí\n              [inst_2 : SeminormedAddCommGroup V‚ÇÇ] ‚Üí\n                [inst_3 : NormedSpace ùïú V] ‚Üí\n                  [inst_4 : NormedSpace ùïú V‚ÇÇ] ‚Üí\n                    [inst_5 : PseudoMetricSpace P] ‚Üí\n                      [inst_6 : PseudoMetricSpace P‚ÇÇ] ‚Üí\n                        [inst_7 : NormedAddTorsor V P] ‚Üí [inst_8 : NormedAddTorsor V‚ÇÇ P‚ÇÇ] ‚Üí (P ‚âÉ·µÉ‚Å±[ùïú] P‚ÇÇ) ‚Üí P ‚Üí·µÉ‚Å±[ùïú] P‚ÇÇ",
    "name": "AffineIsometryEquiv.toAffineIsometry",
    "isProp": false,
    "doc": "Reinterpret an `AffineIsometryEquiv` as an `AffineIsometry`. ",
    "depth": 29}],
  "count": 51},
 {"noDocExamples": [],
  "kind": "SimpleGraph.¬´term_‚âÉg_¬ª",
  "examples":
  [{"type": "{V : Type u} ‚Üí {G : SimpleGraph V} ‚Üí G ‚âÉg G",
    "name": "SimpleGraph.Iso.refl",
    "isProp": false,
    "doc": "The identity isomorphism of a graph with itself. ",
    "depth": 6},
   {"type":
    "{Œ± : Type u_1} ‚Üí [inst : Preorder Œ±] ‚Üí SimpleGraph.hasse Œ±·µí·µà ‚âÉg SimpleGraph.hasse Œ±",
    "name": "SimpleGraph.hasseDualIso",
    "isProp": false,
    "doc": "`Œ±·µí·µà` and `Œ±` have the same Hasse diagram. ",
    "depth": 7},
   {"type":
    "{V : Type u} ‚Üí (G : SimpleGraph V) ‚Üí SimpleGraph.induce Set.univ G ‚âÉg G",
    "name": "SimpleGraph.induceUnivIso",
    "isProp": false,
    "doc":
    "The graph induced on `Set.univ` is isomorphic to the original graph. ",
    "depth": 8}],
  "count": 50},
 {"noDocExamples": [],
  "kind": "¬´term‚®Ç[_]_,_¬ª",
  "examples":
  [{"type":
    "{Œπ : Type u_1} ‚Üí\n  (R : Type u_4) ‚Üí\n    [inst : CommSemiring R] ‚Üí\n      {s : Œπ ‚Üí Type u_7} ‚Üí\n        [inst_1 : (i : Œπ) ‚Üí AddCommMonoid (s i)] ‚Üí\n          [inst_2 : (i : Œπ) ‚Üí Module R (s i)] ‚Üí R ‚Üí ((i : Œπ) ‚Üí s i) ‚Üí ‚®Ç[R] (i : Œπ), s i",
    "name": "PiTensorProduct.tprodCoeff",
    "isProp": false,
    "doc":
    "`tprodCoeff R r f` with `r : R` and `f : ‚àÄ i, s i` is the tensor product of the vectors `f i`\nover all `i : Œπ`, multiplied by the coefficient `r`. Note that this is meant as an auxiliary\ndefinition for this file alone, and that one should use `tprod` defined below for most purposes. ",
    "depth": 14},
   {"type":
    "{Œπ : Type u_1} ‚Üí\n  (R : Type u_4) ‚Üí\n    [inst : CommSemiring R] ‚Üí\n      {s : Œπ ‚Üí Type u_7} ‚Üí\n        [inst_1 : (i : Œπ) ‚Üí AddCommMonoid (s i)] ‚Üí\n          [inst_2 : (i : Œπ) ‚Üí Module R (s i)] ‚Üí MultilinearMap R s (‚®Ç[R] (i : Œπ), s i)",
    "name": "PiTensorProduct.tprod",
    "isProp": false,
    "doc": "The canonical `MultilinearMap R s (‚®Ç[R] i, s i)`. ",
    "depth": 18},
   {"type":
    "{Œπ : Type u_1} ‚Üí\n  {R : Type u_4} ‚Üí\n    [inst : CommSemiring R] ‚Üí\n      {s : Œπ ‚Üí Type u_7} ‚Üí\n        [inst_1 : (i : Œπ) ‚Üí AddCommMonoid (s i)] ‚Üí\n          [inst_2 : (i : Œπ) ‚Üí Module R (s i)] ‚Üí\n            {E : Type u_9} ‚Üí\n              [inst_3 : AddCommMonoid E] ‚Üí [inst_4 : Module R E] ‚Üí MultilinearMap R s E ‚Üí (‚®Ç[R] (i : Œπ), s i) ‚Üí+ E",
    "name": "PiTensorProduct.liftAux",
    "isProp": false,
    "doc":
    "Auxiliary function to constructing a linear map `(‚®Ç[R] i, s i) ‚Üí E` given a\n`MultilinearMap R s E` with the property that its composition with the canonical\n`MultilinearMap R s (‚®Ç[R] i, s i)` is the given multilinear map. ",
    "depth": 21}],
  "count": 50},
 {"noDocExamples": [],
  "kind": "¬´term_‚Üí*‚ÇÄo_¬ª",
  "examples":
  [{"type":
    "(Œ± : Type u_2) ‚Üí [inst : Preorder Œ±] ‚Üí [inst_1 : MulZeroOneClass Œ±] ‚Üí Œ± ‚Üí*‚ÇÄo Œ±",
    "name": "OrderMonoidWithZeroHom.id",
    "isProp": false,
    "doc": "The identity map as an ordered monoid with zero homomorphism. ",
    "depth": 9},
   {"type":
    "{Œ± : Type u_2} ‚Üí\n  {Œ≤ : Type u_3} ‚Üí\n    [inst : NonAssocSemiring Œ±] ‚Üí\n      [inst_1 : Preorder Œ±] ‚Üí [inst_2 : NonAssocSemiring Œ≤] ‚Üí [inst_3 : Preorder Œ≤] ‚Üí Œ± ‚Üí+*o Œ≤ ‚Üí Œ± ‚Üí*‚ÇÄo Œ≤",
    "name": "OrderRingHom.toOrderMonoidWithZeroHom",
    "isProp": false,
    "doc":
    "Reinterpret an ordered ring homomorphism as an order homomorphism. ",
    "depth": 13},
   {"type":
    "{Œ± : Type u_2} ‚Üí\n  {Œ≤ : Type u_3} ‚Üí\n    [inst : Preorder Œ±] ‚Üí\n      [inst_1 : Preorder Œ≤] ‚Üí [inst_2 : MulZeroOneClass Œ±] ‚Üí [inst_3 : MulZeroOneClass Œ≤] ‚Üí (Œ± ‚Üí*‚ÇÄo Œ≤) ‚Üí Œ± ‚Üí*o Œ≤",
    "name": "OrderMonoidWithZeroHom.toOrderMonoidHom",
    "isProp": false,
    "doc":
    "Reinterpret an ordered monoid with zero homomorphism as an order monoid homomorphism. ",
    "depth": 13}],
  "count": 49},
 {"noDocExamples": [],
  "kind": "¬´termŒ©[_‚ÅÑ_]¬ª",
  "examples":
  [{"type":
    "(R : Type u) ‚Üí (S : Type v) ‚Üí [inst : CommRing R] ‚Üí [inst_1 : CommRing S] ‚Üí [inst_2 : Algebra R S] ‚Üí S ‚Üí‚Çó[R] Œ©[S‚ÅÑR]",
    "name": "KaehlerDifferential.DLinearMap",
    "isProp": false,
    "doc":
    "(Implementation) The underlying linear map of the derivation into `Œ©[S‚ÅÑR]`. ",
    "depth": 17},
   {"type":
    "(R : Type u) ‚Üí\n  (S : Type v) ‚Üí [inst : CommRing R] ‚Üí [inst_1 : CommRing S] ‚Üí [inst_2 : Algebra R S] ‚Üí Derivation R S (Œ©[S‚ÅÑR])",
    "name": "KaehlerDifferential.D",
    "isProp": false,
    "doc": "The universal derivation into `Œ©[S‚ÅÑR]`. ",
    "depth": 17},
   {"type":
    "{R : Type u} ‚Üí\n  {S : Type v} ‚Üí\n    [inst : CommRing R] ‚Üí\n      [inst_1 : CommRing S] ‚Üí\n        [inst_2 : Algebra R S] ‚Üí\n          {M : Type u_1} ‚Üí\n            [inst_3 : AddCommGroup M] ‚Üí\n              [inst_4 : Module R M] ‚Üí\n                [inst_5 : Module S M] ‚Üí [inst_6 : IsScalarTower R S M] ‚Üí Derivation R S M ‚Üí Œ©[S‚ÅÑR] ‚Üí‚Çó[S] M",
    "name": "Derivation.liftKaehlerDifferential",
    "isProp": false,
    "doc": "The linear map from `Œ©[S‚ÅÑR]`, associated with a derivation. ",
    "depth": 23}],
  "count": 48},
 {"noDocExamples": [],
  "kind": "¬´term_‚Üí+o_¬ª",
  "examples":
  [{"type": "Surreal ‚Üí+o SetTheory.Game",
    "name": "Surreal.toGame",
    "isProp": false,
    "doc": "Casts a `Surreal` number into a `Game`. ",
    "depth": 7},
   {"type":
    "(Œ± : Type u_2) ‚Üí [inst : Preorder Œ±] ‚Üí [inst_1 : AddZeroClass Œ±] ‚Üí Œ± ‚Üí+o Œ±",
    "name": "OrderAddMonoidHom.id",
    "isProp": false,
    "doc": "The identity map as an ordered additive monoid homomorphism.",
    "depth": 9},
   {"type":
    "{Œ± : Type u_2} ‚Üí {Œ≤ : Type u_3} ‚Üí [inst : OrderedAddCommMonoid Œ±] ‚Üí [inst_1 : OrderedAddCommMonoid Œ≤] ‚Üí Add (Œ± ‚Üí+o Œ≤)",
    "name":
    "OrderAddMonoidHom.instAddOrderAddMonoidHomToPreorderToPartialOrderToPreorderToPartialOrderToAddZeroClassToAddMonoidToAddCommMonoidToAddZeroClassToAddMonoidToAddCommMonoid",
    "isProp": false,
    "doc":
    "For two ordered additive monoid morphisms `f` and `g`, their product is the ordered\nadditive monoid morphism sending `a` to `f a + g a`.",
    "depth": 12}],
  "count": 48},
 {"noDocExamples": [],
  "kind": "¬´term_‚Üí*o_¬ª",
  "examples":
  [{"type":
    "(Œ± : Type u_2) ‚Üí [inst : Preorder Œ±] ‚Üí [inst_1 : MulOneClass Œ±] ‚Üí Œ± ‚Üí*o Œ±",
    "name": "OrderMonoidHom.id",
    "isProp": false,
    "doc": "The identity map as an ordered monoid homomorphism. ",
    "depth": 9},
   {"type":
    "{Œ± : Type u_2} ‚Üí {Œ≤ : Type u_3} ‚Üí [inst : OrderedCommMonoid Œ±] ‚Üí [inst_1 : OrderedCommMonoid Œ≤] ‚Üí Mul (Œ± ‚Üí*o Œ≤)",
    "name":
    "OrderMonoidHom.instMulOrderMonoidHomToPreorderToPartialOrderToPreorderToPartialOrderToMulOneClassToMonoidToCommMonoidToMulOneClassToMonoidToCommMonoid",
    "isProp": false,
    "doc":
    "For two ordered monoid morphisms `f` and `g`, their product is the ordered monoid morphism\nsending `a` to `f a * g a`. ",
    "depth": 12},
   {"type":
    "{Œ± : Type u_2} ‚Üí\n  {Œ≤ : Type u_3} ‚Üí\n    [inst : Preorder Œ±] ‚Üí\n      [inst_1 : Preorder Œ≤] ‚Üí [inst_2 : MulOneClass Œ±] ‚Üí [inst_3 : MulOneClass Œ≤] ‚Üí (Œ± ‚Üí*o Œ≤) ‚Üí Œ± ‚Üío Œ≤",
    "name": "OrderMonoidHom.toOrderHom",
    "isProp": false,
    "doc":
    "Reinterpret an ordered monoid homomorphism as an order homomorphism. ",
    "depth": 13}],
  "count": 48},
 {"noDocExamples": [],
  "kind": "Lean.Parser.Term.quotedName",
  "examples":
  [{"type": "CongrState ‚Üí List (Lean.TSyntax `rcasesPat)",
    "name": "CongrState.patterns",
    "isProp": false,
    "doc": "Patterns to use when doing intro. ",
    "depth": 6},
   {"type": "CongrMetaM (Option (Lean.TSyntax `rcasesPat))",
    "name": "CongrMetaM.nextPattern",
    "isProp": false,
    "doc": "Pop the next pattern from the current state. ",
    "depth": 6},
   {"type":
    "Lean.TSyntaxArray `Lean.Parser.Term.bracketedBinder ‚Üí Lean.TSyntaxArray `Lean.Parser.Term.bracketedBinder",
    "name": "Mathlib.Command.Variable.cleanBinders",
    "isProp": false,
    "doc": "Strip off whitespace and comments. ",
    "depth": 8}],
  "count": 47},
 {"noDocExamples":
  [{"type": "‚àÄ (b : Bool), (true && b) = b",
    "name": "Bool.true_and",
    "isProp": true,
    "depth": 5},
   {"type": "‚àÄ (b : Bool), (false && b) = false",
    "name": "Bool.false_and",
    "isProp": true,
    "depth": 5},
   {"type": "‚àÄ (b : Bool), (b && false) = false",
    "name": "Bool.and_false",
    "isProp": true,
    "depth": 5}],
  "kind": "¬´term_&&_¬ª",
  "examples": [],
  "count": 46},
 {"noDocExamples": [],
  "kind": "¬´term_‚âÉ‚ãÜ‚Çê[_]_¬ª",
  "examples":
  [{"type":
    "{R : Type u_2} ‚Üí\n  {A : Type u_3} ‚Üí [inst : Add A] ‚Üí [inst_1 : Mul A] ‚Üí [inst_2 : SMul R A] ‚Üí [inst_3 : Star A] ‚Üí A ‚âÉ‚ãÜ‚Çê[R] A",
    "name": "StarAlgEquiv.refl",
    "isProp": false,
    "doc": "Star algebra equivalences are reflexive. ",
    "depth": 17},
   {"type":
    "{R : Type u_2} ‚Üí\n  {A : Type u_3} ‚Üí\n    {B : Type u_4} ‚Üí\n      [inst : Add A] ‚Üí\n        [inst_1 : Add B] ‚Üí\n          [inst_2 : Mul A] ‚Üí\n            [inst_3 : Mul B] ‚Üí\n              [inst_4 : SMul R A] ‚Üí [inst_5 : SMul R B] ‚Üí [inst_6 : Star A] ‚Üí [inst_7 : Star B] ‚Üí (A ‚âÉ‚ãÜ‚Çê[R] B) ‚Üí B ‚Üí A",
    "name": "StarAlgEquiv.Simps.symm_apply",
    "isProp": false,
    "doc": "See Note [custom simps projection] ",
    "depth": 23},
   {"type":
    "{R : Type u_1} ‚Üí\n  {A : Type u_2} ‚Üí\n    {B : Type u_3} ‚Üí\n      [inst : Add A] ‚Üí\n        [inst_1 : Add B] ‚Üí\n          [inst_2 : Mul A] ‚Üí\n            [inst_3 : Mul B] ‚Üí\n              [inst_4 : SMul R A] ‚Üí [inst_5 : SMul R B] ‚Üí [inst_6 : Star A] ‚Üí [inst_7 : Star B] ‚Üí (A ‚âÉ‚ãÜ‚Çê[R] B) ‚Üí A ‚âÉ+* B",
    "name": "StarAlgEquiv.toRingEquiv",
    "isProp": false,
    "doc":
    "Reinterpret a star algebra equivalence as a `RingEquiv` by forgetting the interaction with\nthe star operation and scalar multiplication. ",
    "depth": 23}],
  "count": 46},
 {"noDocExamples": [],
  "kind": "List.¬´term_<+:_¬ª",
  "examples":
  [{"type": "‚àÄ {Œ± : Type u_1} {l : List Œ±}, l <+: [] ‚Üí l = []",
    "name": "List.eq_nil_of_prefix_nil",
    "isProp": true,
    "doc": "**Alias** of the forward direction of `List.prefix_nil`.",
    "depth": 7},
   {"type":
    "‚àÄ {Œ± : Type u_1} {l‚ÇÅ l‚ÇÇ : List Œ±}, l‚ÇÅ <:+ l‚ÇÇ ‚Üí List.reverse l‚ÇÅ <+: List.reverse l‚ÇÇ",
    "name": "List.isSuffix.reverse",
    "isProp": true,
    "doc": "**Alias** of the reverse direction of `List.reverse_prefix`.",
    "depth": 8},
   {"type":
    "‚àÄ {Œ± : Type u_1} {l‚ÇÅ l‚ÇÇ : List Œ±}, l‚ÇÅ <+: l‚ÇÇ ‚Üí List.reverse l‚ÇÅ <:+ List.reverse l‚ÇÇ",
    "name": "List.isPrefix.reverse",
    "isProp": true,
    "doc": "**Alias** of the reverse direction of `List.reverse_suffix`.",
    "depth": 8}],
  "count": 45},
 {"noDocExamples": [],
  "kind": "¬´term_‚Åª¬π'o_¬ª",
  "examples":
  [{"type":
    "{Œ± : Type u_1} ‚Üí {Œ≤ : Type u_2} ‚Üí (f : Œ± ‚Üí Œ≤) ‚Üí (s : Œ≤ ‚Üí Œ≤ ‚Üí Prop) ‚Üí f ‚Åª¬π'o s ‚Üír s",
    "name": "RelHom.preimage",
    "isProp": false,
    "doc":
    "A function is a relation homomorphism from the preimage relation of `s` to `s`. ",
    "depth": 10},
   {"type":
    "{Œ± : Sort u_3} ‚Üí {Œ≤ : Sort u_4} ‚Üí (f : Œ± ‚Üí Œ≤) ‚Üí (s : Œ≤ ‚Üí Œ≤ ‚Üí Prop) ‚Üí [H : DecidableRel s] ‚Üí DecidableRel (f ‚Åª¬π'o s)",
    "name": "Order.Preimage.decidable",
    "isProp": false,
    "doc": "The preimage of a decidable order is decidable. ",
    "depth": 10},
   {"type":
    "{X : Type u_5} ‚Üí (r : X ‚Üí X ‚Üí Prop) ‚Üí (p : X ‚Üí Prop) ‚Üí Subtype.val ‚Åª¬π'o r ‚Ü™r r",
    "name": "Subtype.relEmbedding",
    "isProp": false,
    "doc":
    "The induced relation on a subtype is an embedding under the natural inclusion. ",
    "depth": 11}],
  "count": 45},
 {"noDocExamples": [],
  "kind": "¬´term_‚âÉ+*o_¬ª",
  "examples":
  [{"type":
    "(Œ± : Type u_2) ‚Üí [inst : Mul Œ±] ‚Üí [inst_1 : Add Œ±] ‚Üí [inst_2 : LE Œ±] ‚Üí Œ± ‚âÉ+*o Œ±",
    "name": "OrderRingIso.refl",
    "isProp": false,
    "doc": "The identity map as an ordered ring isomorphism. ",
    "depth": 12},
   {"type":
    "{Œ± : Type u_2} ‚Üí\n  {Œ≤ : Type u_3} ‚Üí\n    [inst : NonAssocSemiring Œ±] ‚Üí\n      [inst_1 : Preorder Œ±] ‚Üí [inst_2 : NonAssocSemiring Œ≤] ‚Üí [inst_3 : Preorder Œ≤] ‚Üí Œ± ‚âÉ+*o Œ≤ ‚Üí Œ± ‚Üí+*o Œ≤",
    "name": "OrderRingIso.toOrderRingHom",
    "isProp": false,
    "doc":
    "Reinterpret an ordered ring isomorphism as an ordered ring homomorphism. ",
    "depth": 16},
   {"type":
    "{Œ± : Type u_2} ‚Üí\n  {Œ≤ : Type u_3} ‚Üí\n    [inst : Mul Œ±] ‚Üí\n      [inst_1 : Add Œ±] ‚Üí [inst_2 : LE Œ±] ‚Üí [inst_3 : Mul Œ≤] ‚Üí [inst_4 : Add Œ≤] ‚Üí [inst_5 : LE Œ≤] ‚Üí Œ± ‚âÉ+*o Œ≤ ‚Üí Œ≤ ‚Üí Œ±",
    "name": "OrderRingIso.Simps.symm_apply",
    "isProp": false,
    "doc": "See Note [custom simps projection] ",
    "depth": 17}],
  "count": 44},
 {"noDocExamples": [],
  "kind": "¬´term_‚Üí·µà_¬ª",
  "examples":
  [{"type": "(Œ± : Type u_6) ‚Üí [inst : PseudoEMetricSpace Œ±] ‚Üí Œ± ‚Üí·µà Œ±",
    "name": "Dilation.id",
    "isProp": false,
    "doc": "The identity is a dilation ",
    "depth": 6},
   {"type":
    "{Œ± : Type u_1} ‚Üí [inst : PseudoEMetricSpace Œ±] ‚Üí (Œ± ‚Üí·µà Œ±) ‚Üí* NNReal",
    "name": "Dilation.ratioHom",
    "isProp": false,
    "doc": "`Dilation.ratio` as a monoid homomorphism from `Œ± ‚Üí·µà Œ±` to `‚Ñù‚â•0`. ",
    "depth": 10},
   {"type":
    "{Œ± : Type u_1} ‚Üí\n  {Œ≤ : Type u_2} ‚Üí\n    {Œ≥ : Type u_3} ‚Üí\n      [inst : PseudoEMetricSpace Œ±] ‚Üí\n        [inst_1 : PseudoEMetricSpace Œ≤] ‚Üí [inst_2 : PseudoEMetricSpace Œ≥] ‚Üí Œ≤ ‚Üí·µà Œ≥ ‚Üí Œ± ‚Üí·µà Œ≤ ‚Üí Œ± ‚Üí·µà Œ≥",
    "name": "Dilation.comp",
    "isProp": false,
    "doc": "The composition of dilations is a dilation ",
    "depth": 12}],
  "count": 44},
 {"noDocExamples": [],
  "kind": "Sigma.Lex.¬´termŒ£‚Çó_,_¬ª",
  "examples":
  [{"type":
    "{Œπ : Type u_1} ‚Üí {Œ± : Œπ ‚Üí Type u_2} ‚Üí [inst : LT Œπ] ‚Üí [inst : (i : Œπ) ‚Üí LT (Œ± i)] ‚Üí LT (Œ£‚Çó (i : Œπ), Œ± i)",
    "name": "Sigma.Lex.LT",
    "isProp": false,
    "doc": "The lexicographical `<` on a sigma type. ",
    "depth": 9},
   {"type":
    "{Œπ : Type u_1} ‚Üí\n  {Œ± : Œπ ‚Üí Type u_2} ‚Üí [inst : Preorder Œπ] ‚Üí [inst : (i : Œπ) ‚Üí Preorder (Œ± i)] ‚Üí Preorder (Œ£‚Çó (i : Œπ), Œ± i)",
    "name": "Sigma.Lex.preorder",
    "isProp": false,
    "doc": "The lexicographical preorder on a sigma type. ",
    "depth": 9},
   {"type":
    "{Œπ : Type u_1} ‚Üí\n  {Œ± : Œπ ‚Üí Type u_2} ‚Üí [inst : Preorder Œπ] ‚Üí [inst : (i : Œπ) ‚Üí PartialOrder (Œ± i)] ‚Üí PartialOrder (Œ£‚Çó (i : Œπ), Œ± i)",
    "name": "Sigma.Lex.partialOrder",
    "isProp": false,
    "doc": "The lexicographical partial order on a sigma type. ",
    "depth": 9}],
  "count": 42},
 {"noDocExamples": [],
  "kind": "¬´term_‚Å∫¬ª",
  "examples":
  [{"type":
    "‚àÄ {Œ± : Type u} [inst : Lattice Œ±] [inst_1 : Group Œ±] (a : Œ±), 1 ‚â§ a ‚Üí a‚Å∫ = a",
    "name": "LatticeOrderedGroup.pos_of_one_le",
    "isProp": true,
    "doc":
    "If `a` is positive, then it is equal to its positive component `a‚Å∫`. ",
    "depth": 14},
   {"type":
    "‚àÄ {Œ± : Type u} [inst : Lattice Œ±] [inst_1 : AddGroup Œ±] (a : Œ±), 0 ‚â§ a ‚Üí a‚Å∫ = a",
    "name": "LatticeOrderedGroup.pos_of_nonneg",
    "isProp": true,
    "doc":
    "If `a` is positive, then it is equal to its positive component `a‚Å∫`.",
    "depth": 14},
   {"type":
    "‚àÄ {Œ© : Type u_1} {m0 : MeasurableSpace Œ©} {Œº : MeasureTheory.Measure Œ©} {f : ‚Ñï ‚Üí Œ© ‚Üí ‚Ñù}\n  {‚Ñ± : MeasureTheory.Filtration ‚Ñï m0} [inst : MeasureTheory.IsFiniteMeasure Œº] (a b : ‚Ñù),\n  MeasureTheory.Submartingale f ‚Ñ± Œº ‚Üí\n    ENNReal.ofReal (b - a) * ‚à´‚Åª (œâ : Œ©), MeasureTheory.upcrossings a b f œâ ‚àÇŒº ‚â§\n      ‚®Ü (N : ‚Ñï), ‚à´‚Åª (œâ : Œ©), ENNReal.ofReal (f N œâ - a)‚Å∫ ‚àÇŒº",
    "name":
    "MeasureTheory.Submartingale.mul_lintegral_upcrossings_le_lintegral_pos_part",
    "isProp": true,
    "doc":
    "A variant of Doob's upcrossing estimate obtained by taking the supremum on both sides. ",
    "depth": 24}],
  "count": 42},
 {"noDocExamples": [],
  "kind": "MeasureTheory.¬´term‚à´_,_¬ª",
  "examples":
  [{"type":
    "‚àÄ {b : ‚ÑÇ}, 0 < b.re ‚Üí (‚à´ (x : ‚Ñù), cexp (-b * ‚Üëx ^ 2)) ^ 2 = ‚ÜëReal.pi / b",
    "name": "integral_gaussian_sq_complex",
    "isProp": true,
    "doc":
    "The *square* of the Gaussian integral `‚à´ x:‚Ñù, exp (-b * x^2)` is equal to `œÄ / b`. ",
    "depth": 18},
   {"type":
    "‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] (t : ‚Ñù) (f : UnitAddCircle ‚Üí E),\n  ‚à´ (a : ‚Ñù) in Set.Ioc t (t + 1), f ‚Üëa = ‚à´ (b : UnitAddCircle), f b",
    "name": "UnitAddCircle.integral_preimage",
    "isProp": true,
    "doc":
    "The integral of an almost-everywhere strongly measurable function over `UnitAddCircle` is\nequal to the integral over an interval (t, t + 1] in `‚Ñù` of its lift to `‚Ñù`. ",
    "depth": 18},
   {"type":
    "‚àÄ {Œ© : Type u_1} [inst : MeasureTheory.MeasureSpace Œ©]\n  [inst_1 : MeasureTheory.IsProbabilityMeasure MeasureTheory.volume] (X : ‚Ñï ‚Üí Œ© ‚Üí ‚Ñù),\n  MeasureTheory.Integrable (X 0) ‚Üí\n    (‚àÄ (i : ‚Ñï), ProbabilityTheory.IdentDistrib (X i) (X 0)) ‚Üí\n      (fun n =>\n          (‚à´ (a : Œ©), Finset.sum (Finset.range n) (fun i => ProbabilityTheory.truncation (X i) ‚Üëi) a) -\n            ‚Üën * ‚à´ (a : Œ©), X 0 a) =o[Filter.atTop]\n        Nat.cast",
    "name": "ProbabilityTheory.strong_law_aux3",
    "isProp": true,
    "doc":
    "The expectation of the truncated version of `X·µ¢` behaves asymptotically like the whole\nexpectation. This follows from convergence and Ces√†ro averaging. ",
    "depth": 20}],
  "count": 42},
 {"noDocExamples":
  [{"type":
    "‚àÄ (x : ‚Ñï) (r : ‚Ñù), Metric.closedBall x r = Set.Icc ‚åà‚Üëx - r‚åâ‚Çä ‚åä‚Üëx + r‚åã‚Çä",
    "name": "Nat.closedBall_eq_Icc",
    "isProp": true,
    "depth": 12},
   {"type":
    "‚àÄ {Œ± : Type u_2} [inst : LinearOrderedSemiring Œ±] [inst_1 : FloorSemiring Œ±], ‚åà1‚åâ‚Çä = 1",
    "name": "Nat.ceil_one",
    "isProp": true,
    "depth": 12}],
  "kind": "Nat.¬´term‚åà_‚åâ‚Çä¬ª",
  "examples":
  [{"type":
    "‚àÄ {Fq : Type u_1} [inst : Fintype Fq] [inst_1 : Field Fq] {b : Polynomial Fq},\n  b ‚â† 0 ‚Üí\n    ‚àÄ {Œµ : ‚Ñù},\n      0 < Œµ ‚Üí\n        ‚àÄ (A : Fin (Nat.succ (Fintype.card Fq ^ ‚åà-Real.log Œµ / Real.log ‚Üë(Fintype.card Fq)‚åâ‚Çä)) ‚Üí Polynomial Fq),\n          ‚àÉ i‚ÇÄ i‚ÇÅ, i‚ÇÄ ‚â† i‚ÇÅ ‚àß ‚Üë(‚ÜëPolynomial.cardPowDegree (A i‚ÇÅ % b - A i‚ÇÄ % b)) < ‚ÜëPolynomial.cardPowDegree b ‚Ä¢ Œµ",
    "name": "Polynomial.exists_approx_polynomial",
    "isProp": true,
    "doc":
    "If `A` is a family of enough low-degree polynomials over a finite field,\nthere is a pair of elements in `A` (with different indices but not necessarily\ndistinct), such that the difference of their remainders is close together. ",
    "depth": 35}],
  "count": 42},
 {"noDocExamples": [],
  "kind": "¬´term‚àÆ_InC(_,_),_¬ª",
  "examples":
  [{"type":
    "‚àÄ {c w : ‚ÑÇ} {R : ‚Ñù}, w ‚àà Metric.ball c R ‚Üí (‚àÆ (z : ‚ÑÇ) in C(c, R), (z - w)‚Åª¬π) = 2 * ‚ÜëReal.pi * Complex.I",
    "name": "circleIntegral.integral_sub_inv_of_mem_ball",
    "isProp": true,
    "doc":
    "Integral $\\oint_{|z-c|=R} \\frac{dz}{z-w} = 2œÄi$ whenever $|w-c| < R$. ",
    "depth": 17},
   {"type":
    "‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚ÑÇ E] (f : (Fin 1 ‚Üí ‚ÑÇ) ‚Üí E) (c : Fin 1 ‚Üí ‚ÑÇ)\n  (R : Fin 1 ‚Üí ‚Ñù), (‚àØ (x : Fin 1 ‚Üí ‚ÑÇ) in T(c, R), f x) = ‚àÆ (z : ‚ÑÇ) in C(c 0, R 0), f fun x => z",
    "name": "torusIntegral_dim1",
    "isProp": true,
    "doc":
    "In dimension one, `torusIntegral` is the same as `circleIntegral`\n(up to the natural equivalence between `‚ÑÇ` and `Fin 1 ‚Üí ‚ÑÇ`). ",
    "depth": 18},
   {"type":
    "‚àÄ {n : ‚Ñ§}, n ‚â† -1 ‚Üí ‚àÄ (c w : ‚ÑÇ) (R : ‚Ñù), (‚àÆ (z : ‚ÑÇ) in C(c, R), (z - w) ^ n) = 0",
    "name": "circleIntegral.integral_sub_zpow_of_ne",
    "isProp": true,
    "doc":
    "If `n ‚â† -1` is an integer number, then the integral of `(z - w) ^ n` over the circle equals\nzero. ",
    "depth": 20}],
  "count": 42},
 {"noDocExamples": [],
  "kind": "¬´MulSemiringActionHomLocal‚â∫¬ª",
  "examples":
  [{"type":
    "(M : Type u_5) ‚Üí\n  [inst : Monoid M] ‚Üí {R : Type u_11} ‚Üí [inst_1 : Semiring R] ‚Üí [inst_2 : MulSemiringAction M R] ‚Üí R ‚Üí+*[M] R",
    "name": "MulSemiringActionHom.id",
    "isProp": false,
    "doc": "The identity map as an equivariant ring homomorphism. ",
    "depth": 13},
   {"type":
    "{M : Type u_5} ‚Üí\n  [inst : Monoid M] ‚Üí\n    {R : Type u_11} ‚Üí\n      [inst_1 : Semiring R] ‚Üí\n        [inst_2 : MulSemiringAction M R] ‚Üí\n          {S : Type u_13} ‚Üí [inst_3 : Semiring S] ‚Üí [inst_4 : MulSemiringAction M S] ‚Üí (R ‚Üí+*[M] S) ‚Üí R ‚Üí+* S",
    "name": "MulSemiringActionHom.toRingHom",
    "isProp": false,
    "doc":
    "Reinterpret an equivariant ring homomorphism as a ring homomorphism. ",
    "depth": 17},
   {"type":
    "{M : Type u_1} ‚Üí\n  [inst : Monoid M] ‚Üí\n    {P : Type u_2} ‚Üí\n      [inst_1 : CommSemiring P] ‚Üí\n        [inst_2 : MulSemiringAction M P] ‚Üí\n          {Q : Type u_3} ‚Üí\n            [inst_3 : CommSemiring Q] ‚Üí\n              [inst_4 : MulSemiringAction M Q] ‚Üí (P ‚Üí+*[M] Q) ‚Üí Polynomial P ‚Üí+*[M] Polynomial Q",
    "name": "MulSemiringActionHom.polynomial",
    "isProp": false,
    "doc": "An equivariant map induces an equivariant map on polynomials. ",
    "depth": 18}],
  "count": 41},
 {"noDocExamples": [],
  "kind": "PSigma.¬´termŒ£‚Çó'_,_¬ª",
  "examples":
  [{"type":
    "{Œπ : Type u_1} ‚Üí\n  {Œ± : Œπ ‚Üí Type u_2} ‚Üí [inst : LinearOrder Œπ] ‚Üí [inst : (i : Œπ) ‚Üí LinearOrder (Œ± i)] ‚Üí LinearOrder (Œ£‚Çó' (i : Œπ), Œ± i)",
    "name": "PSigma.Lex.linearOrder",
    "isProp": false,
    "doc": "Dictionary / lexicographic linear_order for pairs. ",
    "depth": 9},
   {"type":
    "{Œπ : Type u_1} ‚Üí\n  {Œ± : Œπ ‚Üí Type u_2} ‚Üí [inst : PartialOrder Œπ] ‚Üí [inst : (i : Œπ) ‚Üí PartialOrder (Œ± i)] ‚Üí PartialOrder (Œ£‚Çó' (i : Œπ), Œ± i)",
    "name": "PSigma.Lex.partialOrder",
    "isProp": false,
    "doc": "Dictionary / lexicographic partial_order for dependent pairs. ",
    "depth": 9},
   {"type":
    "{Œπ : Type u_1} ‚Üí {Œ± : Œπ ‚Üí Type u_2} ‚Üí [inst : LT Œπ] ‚Üí [inst : (i : Œπ) ‚Üí LT (Œ± i)] ‚Üí LT (Œ£‚Çó' (i : Œπ), Œ± i)",
    "name": "PSigma.Lex.lt",
    "isProp": false,
    "doc": "The lexicographical `<` on a sigma type. ",
    "depth": 9}],
  "count": 41},
 {"noDocExamples": [],
  "kind": "¬´term_‚ãä[_]_¬ª",
  "examples":
  [{"type":
    "{N : Type u_1} ‚Üí {G : Type u_2} ‚Üí [inst : Group N] ‚Üí [inst_1 : Group G] ‚Üí {œÜ : G ‚Üí* MulAut N} ‚Üí N ‚ãä[œÜ] G ‚Üí N",
    "name": "SemidirectProduct.left",
    "isProp": false,
    "doc": "The element of N ",
    "depth": 16},
   {"type":
    "{N : Type u_1} ‚Üí {G : Type u_2} ‚Üí [inst : Group N] ‚Üí [inst_1 : Group G] ‚Üí {œÜ : G ‚Üí* MulAut N} ‚Üí N ‚Üí* N ‚ãä[œÜ] G",
    "name": "SemidirectProduct.inl",
    "isProp": false,
    "doc": "The canonical map `N ‚Üí* N ‚ãä[œÜ] G` sending `n` to `‚ü®n, 1‚ü©` ",
    "depth": 16},
   {"type":
    "{N : Type u_1} ‚Üí {G : Type u_2} ‚Üí [inst : Group N] ‚Üí [inst_1 : Group G] ‚Üí {œÜ : G ‚Üí* MulAut N} ‚Üí N ‚ãä[œÜ] G ‚Üí G",
    "name": "SemidirectProduct.right",
    "isProp": false,
    "doc": "The element of G ",
    "depth": 16}],
  "count": 41},
 {"noDocExamples": [],
  "kind": "List.¬´term_<:+_¬ª",
  "examples":
  [{"type": "‚àÄ {Œ± : Type u_1} {l : List Œ±}, l <:+ [] ‚Üí l = []",
    "name": "List.eq_nil_of_suffix_nil",
    "isProp": true,
    "doc": "**Alias** of the forward direction of `List.suffix_nil`.",
    "depth": 7},
   {"type":
    "‚àÄ {Œ± : Type u_1} {l‚ÇÅ l‚ÇÇ : List Œ±}, l‚ÇÅ <:+ l‚ÇÇ ‚Üí List.reverse l‚ÇÅ <+: List.reverse l‚ÇÇ",
    "name": "List.isSuffix.reverse",
    "isProp": true,
    "doc": "**Alias** of the reverse direction of `List.reverse_prefix`.",
    "depth": 8},
   {"type":
    "‚àÄ {Œ± : Type u_1} {l‚ÇÅ l‚ÇÇ : List Œ±}, l‚ÇÅ <+: l‚ÇÇ ‚Üí List.reverse l‚ÇÅ <:+ List.reverse l‚ÇÇ",
    "name": "List.isPrefix.reverse",
    "isProp": true,
    "doc": "**Alias** of the reverse direction of `List.reverse_suffix`.",
    "depth": 8}],
  "count": 40},
 {"noDocExamples": [],
  "kind": "OreLocalization.¬´term_/‚Çí_¬ª",
  "examples":
  [{"type":
    "‚àÄ {R : Type u_1} [inst : Monoid R] {S : Submonoid R} [inst_1 : OreLocalization.OreSet S] {r r' r‚ÇÅ r‚ÇÇ : R}\n  {s t : { x // x ‚àà S }}, r * ‚Üët = r' * ‚Üët ‚Üí r‚ÇÅ * r * r‚ÇÇ /‚Çí s = r‚ÇÅ * r' * r‚ÇÇ /‚Çí s",
    "name": "OreLocalization.eq_of_num_factor_eq",
    "isProp": true,
    "doc":
    "Fractions which differ by a factor of the numerator can be proven equal if\nthose factors expand to equal elements of `R`. ",
    "depth": 25},
   {"type":
    "‚àÄ {R : Type u_1} [inst : Monoid R] {S : Submonoid R} [inst_1 : OreLocalization.OreSet S] (r : R) (s : { x // x ‚àà S })\n  (t : R) (hst : ‚Üës * t ‚àà S), r /‚Çí s = r * t /‚Çí { val := ‚Üës * t, property := hst }",
    "name": "OreLocalization.expand",
    "isProp": true,
    "doc":
    "A fraction `r /‚Çí s` is equal to its expansion by an arbitrary factor `t` if `s * t ‚àà S`. ",
    "depth": 25},
   {"type":
    "‚àÄ {R : Type u_1} [inst : Monoid R] {S : Submonoid R} [inst_1 : OreLocalization.OreSet S] (r : R)\n  (s s' : { x // x ‚àà S }), r /‚Çí s = r * ‚Üës' /‚Çí (s * s')",
    "name": "OreLocalization.expand'",
    "isProp": true,
    "doc": "A fraction is equal to its expansion by a factor from s. ",
    "depth": 26}],
  "count": 38},
 {"noDocExamples":
  [{"type":
    "‚àÄ {Œ± : Type u} [inst : Lattice Œ±] [inst_1 : AddGroup Œ±] (a : Œ±), -a ‚â§ a‚Åª",
    "name": "LatticeOrderedGroup.neg_le_neg",
    "isProp": true,
    "depth": 13},
   {"type": "‚àÄ {Œ± : Type u} [inst : Lattice Œ±] [inst_1 : AddGroup Œ±], 0‚Åª = 0",
    "name": "LatticeOrderedGroup.neg_zero",
    "isProp": true,
    "depth": 13},
   {"type":
    "‚àÄ {Œ± : Type u} [inst : Lattice Œ±] [inst_1 : AddGroup Œ±] (a : Œ±), 0 ‚â§ a‚Åª",
    "name": "LatticeOrderedGroup.neg_nonneg",
    "isProp": true,
    "depth": 13}],
  "kind": "¬´term_‚Åª¬ª",
  "examples": [],
  "count": 38},
 {"noDocExamples": [],
  "kind": "List.¬´term_<+~_¬ª",
  "examples":
  [{"type":
    "‚àÄ {Œ± : Type uu} (a : Œ±) {l‚ÇÅ l‚ÇÇ : List Œ±}, l‚ÇÅ <+~ l‚ÇÇ ‚Üí a :: l‚ÇÅ <+~ a :: l‚ÇÇ",
    "name": "List.subperm.cons",
    "isProp": true,
    "doc": "**Alias** of the reverse direction of `List.subperm_cons`.",
    "depth": 10},
   {"type":
    "‚àÄ {Œ± : Type uu} (a : Œ±) {l‚ÇÅ l‚ÇÇ : List Œ±}, a :: l‚ÇÅ <+~ a :: l‚ÇÇ ‚Üí l‚ÇÅ <+~ l‚ÇÇ",
    "name": "List.subperm.of_cons",
    "isProp": true,
    "doc": "**Alias** of the forward direction of `List.subperm_cons`.",
    "depth": 10},
   {"type":
    "‚àÄ {Œ± : Type uu} [inst : DecidableEq Œ±] {l‚ÇÅ l‚ÇÇ : List Œ±},\n  l‚ÇÅ <+~ l‚ÇÇ ‚Üî ‚àÄ (x : Œ±), x ‚àà l‚ÇÅ ‚Üí List.count x l‚ÇÅ ‚â§ List.count x l‚ÇÇ",
    "name": "List.subperm_ext_iff",
    "isProp": true,
    "doc": "The list version of `Multiset.le_iff_count`. ",
    "depth": 17}],
  "count": 38},
 {"noDocExamples": [],
  "kind": "MeasureTheory.¬´term‚à´_In_,_¬ª",
  "examples":
  [{"type":
    "‚àÄ {s : ‚ÑÇ},\n  0 < s.re ‚Üí HasDerivAt Complex.GammaIntegral (‚à´ (t : ‚Ñù) in Set.Ioi 0, ‚Üët ^ (s - 1) * (‚Üë(Real.log t) * ‚Üë(rexp (-t)))) s",
    "name": "Complex.hasDerivAt_GammaIntegral",
    "isProp": true,
    "doc":
    "The derivative of the `Œì` integral, at any `s ‚àà ‚ÑÇ` with `1 < re s`, is given by the Melllin\ntransform of `log t * exp (-t)`. ",
    "depth": 15},
   {"type":
    "‚àÄ {a b : ‚Ñù} (n : ‚Ñï), ‚à´ (x : ‚Ñù) in Œô a b, |x - a| ^ n = |b - a| ^ (n + 1) / (‚Üën + 1)",
    "name": "integral_pow_abs_sub_uIoc",
    "isProp": true,
    "doc":
    "Integral of `|x - a| ^ n` over `Œô a b`. This integral appears in the proof of the\nPicard-Lindel√∂f/Cauchy-Lipschitz theorem. ",
    "depth": 16},
   {"type":
    "‚àÄ {g g' : ‚Ñù ‚Üí ‚Ñù} {a l : ‚Ñù},\n  (‚àÄ (x : ‚Ñù), x ‚àà Set.Ici a ‚Üí HasDerivAt g (g' x) x) ‚Üí\n    (‚àÄ (x : ‚Ñù), x ‚àà Set.Ioi a ‚Üí 0 ‚â§ g' x) ‚Üí\n      Filter.Tendsto g Filter.atTop (nhds l) ‚Üí ‚à´ (x : ‚Ñù) in Set.Ioi a, g' x = l - g a",
    "name": "MeasureTheory.integral_Ioi_of_hasDerivAt_of_nonneg'",
    "isProp": true,
    "doc":
    "When a function has a limit at infinity `l`, and its derivative is nonnegative, then the\nintegral of the derivative on `(a, +‚àû)` is `l - g a` (and the derivative is integrable, see\n`integrable_on_Ioi_deriv_of_nonneg'`). Version assuming differentiability on `[a, +‚àû)`. ",
    "depth": 18}],
  "count": 38},
 {"noDocExamples": [],
  "kind": "¬´term_‚âÉ‚Çó‚ÅÖ_,_‚ÅÜ_¬ª",
  "examples":
  [{"type":
    "{R : Type u} ‚Üí\n  {L : Type v} ‚Üí\n    {M : Type w} ‚Üí\n      [inst : CommRing R] ‚Üí\n        [inst_1 : LieRing L] ‚Üí\n          [inst_2 : AddCommGroup M] ‚Üí [inst_3 : Module R M] ‚Üí [inst_4 : LieRingModule L M] ‚Üí M ‚âÉ‚Çó‚ÅÖR,L‚ÅÜ M",
    "name": "LieModuleEquiv.refl",
    "isProp": false,
    "doc": "Lie module equivalences are reflexive. ",
    "depth": 20},
   {"type":
    "{R : Type u} ‚Üí\n  {L : Type v} ‚Üí\n    {M : Type w} ‚Üí\n      {N : Type w‚ÇÅ} ‚Üí\n        [inst : CommRing R] ‚Üí\n          [inst_1 : LieRing L] ‚Üí\n            [inst_2 : AddCommGroup M] ‚Üí\n              [inst_3 : AddCommGroup N] ‚Üí\n                [inst_4 : Module R M] ‚Üí\n                  [inst_5 : Module R N] ‚Üí\n                    [inst_6 : LieRingModule L M] ‚Üí [inst_7 : LieRingModule L N] ‚Üí (M ‚âÉ‚Çó‚ÅÖR,L‚ÅÜ N) ‚Üí N ‚âÉ‚Çó‚ÅÖR,L‚ÅÜ M",
    "name": "LieModuleEquiv.symm",
    "isProp": false,
    "doc": "Lie module equivalences are symmetric. ",
    "depth": 25},
   {"type":
    "{R : Type u} ‚Üí\n  {L : Type v} ‚Üí\n    {M : Type w} ‚Üí\n      {N : Type w‚ÇÅ} ‚Üí\n        [inst : CommRing R] ‚Üí\n          [inst_1 : LieRing L] ‚Üí\n            [inst_2 : AddCommGroup M] ‚Üí\n              [inst_3 : AddCommGroup N] ‚Üí\n                [inst_4 : Module R M] ‚Üí\n                  [inst_5 : Module R N] ‚Üí\n                    [inst_6 : LieRingModule L M] ‚Üí [inst_7 : LieRingModule L N] ‚Üí (M ‚âÉ‚Çó‚ÅÖR,L‚ÅÜ N) ‚Üí M ‚âÉ N",
    "name": "LieModuleEquiv.toEquiv",
    "isProp": false,
    "doc": "View an equivalence of Lie modules as a type level equivalence. ",
    "depth": 25}],
  "count": 37},
 {"noDocExamples": [],
  "kind": "¬´MulActionHomLocal‚â∫¬ª",
  "examples":
  [{"type": "(M' : Type u_1) ‚Üí {X : Type u_2} ‚Üí [inst : SMul M' X] ‚Üí X ‚Üí[M'] X",
    "name": "MulActionHom.id",
    "isProp": false,
    "doc": "The identity map as an equivariant map. ",
    "depth": 8},
   {"type":
    "{M' : Type u_1} ‚Üí {X : Type u_2} ‚Üí [inst : SMul M' X] ‚Üí {Y : Type u_3} ‚Üí [inst_1 : SMul M' Y] ‚Üí (X ‚Üí[M'] Y) ‚Üí X ‚Üí Y",
    "name": "MulActionHom.toFun",
    "isProp": false,
    "doc": "The underlying function. ",
    "depth": 11},
   {"type":
    "{M : Type u_18} ‚Üí\n  (N : Type u_16) ‚Üí\n    (Œ± : Type u_17) ‚Üí [inst : SMul M Œ±] ‚Üí [inst_1 : SMul N Œ±] ‚Üí [inst : SMulCommClass M N Œ±] ‚Üí M ‚Üí Œ± ‚Üí[N] Œ±",
    "name": "SMulCommClass.toMulActionHom",
    "isProp": false,
    "doc":
    "If actions of `M` and `N` on `Œ±` commute, then for `c : M`, `(c ‚Ä¢ ¬∑ : Œ± ‚Üí Œ±)` is an `N`-action\nhomomorphism. ",
    "depth": 12}],
  "count": 37},
 {"noDocExamples":
  [{"type": "‚àÄ (b : Bool), (b || false) = b",
    "name": "Bool.or_false",
    "isProp": true,
    "depth": 5},
   {"type": "‚àÄ (x : Bool), (x || !x) = true",
    "name": "Bool.or_not_self",
    "isProp": true,
    "depth": 5},
   {"type": "‚àÄ (b : Bool), (b || true) = true",
    "name": "Bool.or_true",
    "isProp": true,
    "depth": 5}],
  "kind": "¬´term_||_¬ª",
  "examples": [],
  "count": 36},
 {"noDocExamples": [],
  "kind": "Submodule.¬´term_‚üÇ_¬ª",
  "examples":
  [{"type":
    "‚àÄ {ùïú : Type u_1} {E : Type u_2} [inst : IsROrC ùïú] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ùïú E]\n  {U V : Submodule ùïú E}, U ‚üÇ V ‚Üí Disjoint U V",
    "name": "Submodule.IsOrtho.disjoint",
    "isProp": true,
    "doc": "Orthogonal submodules are disjoint. ",
    "depth": 25},
   {"type":
    "‚àÄ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ‚Ñù V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] {n : ‚Ñï} (s : Affine.Simplex ‚Ñù P (n + 1)) (i : Fin (n + 2)),\n  vectorSpan ‚Ñù (s.points '' ‚Üë(Finset.erase Finset.univ i)) ‚üÇ AffineSubspace.direction (Affine.Simplex.altitude s i)",
    "name": "Affine.Simplex.vectorSpan_isOrtho_altitude_direction",
    "isProp": true,
    "doc":
    "The vector span of the opposite face lies in the direction\northogonal to an altitude. ",
    "depth": 28},
   {"type":
    "‚àÄ {ùïú : Type u_1} {E : Type u_2} [inst : IsROrC ùïú] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ùïú E]\n  {Œπ : Type u_4} {V : Œπ ‚Üí Submodule ùïú E},\n  (OrthogonalFamily ùïú (fun i => { x // x ‚àà V i }) fun i => Submodule.subtype‚Çó·µ¢ (V i)) ‚Üí\n    Pairwise ((fun x x_1 => x ‚üÇ x_1) on V)",
    "name": "OrthogonalFamily.pairwise",
    "isProp": true,
    "doc":
    "**Alias** of the forward direction of `orthogonalFamily_iff_pairwise`.",
    "depth": 31}],
  "count": 36},
 {"noDocExamples":
  [{"type": "‚àÄ {Œ± : Type u} (l : List Œ±), l ~r l",
    "name": "List.IsRotated.refl",
    "isProp": true,
    "depth": 5},
   {"type": "‚àÄ {Œ± : Type u} {l : List Œ±}, [] ~r l ‚Üî [] = l",
    "name": "List.isRotated_nil_iff'",
    "isProp": true,
    "depth": 7},
   {"type": "‚àÄ {Œ± : Type u} {l l' : List Œ±}, l ~r l' ‚Üí l ~ l'",
    "name": "List.IsRotated.perm",
    "isProp": true,
    "depth": 7}],
  "kind": "List.¬´term_~r_¬ª",
  "examples": [],
  "count": 36},
 {"noDocExamples": [],
  "kind": "MeasureTheory.¬´term‚®ç_,_‚àÇ_¬ª",
  "examples":
  [{"type":
    "‚àÄ {Œ± : Type u_1} {m0 : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {f : Œ± ‚Üí ‚Ñù}\n  [inst : MeasureTheory.IsFiniteMeasure Œº], Œº ‚â† 0 ‚Üí MeasureTheory.Integrable f ‚Üí ‚àÉ x, f x ‚â§ ‚®ç (a : Œ±), f a ‚àÇŒº",
    "name": "MeasureTheory.exists_le_average",
    "isProp": true,
    "doc":
    "**First moment method**. The minimum of an integrable function is smaller than its mean. ",
    "depth": 17},
   {"type":
    "‚àÄ {Œ± : Type u_1} {m0 : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {f : Œ± ‚Üí ‚Ñù}\n  [inst : MeasureTheory.IsFiniteMeasure Œº], Œº ‚â† 0 ‚Üí MeasureTheory.Integrable f ‚Üí ‚àÉ x, ‚®ç (a : Œ±), f a ‚àÇŒº ‚â§ f x",
    "name": "MeasureTheory.exists_average_le",
    "isProp": true,
    "doc":
    "**First moment method**. The maximum of an integrable function is greater than its mean. ",
    "depth": 18},
   {"type":
    "‚àÄ {Œ± : Type u_1} {m0 : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {f : Œ± ‚Üí ‚Ñù}\n  [inst : MeasureTheory.IsFiniteMeasure Œº], Œº ‚â† 0 ‚Üí MeasureTheory.Integrable f ‚Üí 0 < ‚Üë‚ÜëŒº {x | f x ‚â§ ‚®ç (a : Œ±), f a ‚àÇŒº}",
    "name": "MeasureTheory.measure_le_average_pos",
    "isProp": true,
    "doc":
    "**First moment method**. An integrable function is smaller than its mean on a set of positive\nmeasure. ",
    "depth": 19}],
  "count": 35},
 {"noDocExamples": [],
  "kind": "¬´term_‚ÜíCo_¬ª",
  "examples":
  [{"type":
    "(Œ± : Type u_2) ‚Üí [inst : TopologicalSpace Œ±] ‚Üí [inst_1 : Preorder Œ±] ‚Üí Œ± ‚ÜíCo Œ±",
    "name": "ContinuousOrderHom.id",
    "isProp": false,
    "doc": "`id` as a `ContinuousOrderHom`. ",
    "depth": 9},
   {"type":
    "{Œ± : Type u_2} ‚Üí\n  {Œ≤ : Type u_3} ‚Üí\n    [inst : TopologicalSpace Œ±] ‚Üí\n      [inst_1 : Preorder Œ±] ‚Üí [inst_2 : TopologicalSpace Œ≤] ‚Üí [inst_3 : Preorder Œ≤] ‚Üí (Œ± ‚ÜíCo Œ≤) ‚Üí C(Œ±, Œ≤)",
    "name": "ContinuousOrderHom.toContinuousMap",
    "isProp": false,
    "doc": "Reinterpret a `ContinuousOrderHom` as a `ContinuousMap`. ",
    "depth": 13},
   {"type":
    "{F : Type u_1} ‚Üí\n  {Œ± : Type u_2} ‚Üí\n    {Œ≤ : Type u_3} ‚Üí\n      [inst : Preorder Œ±] ‚Üí\n        [inst_1 : Preorder Œ≤] ‚Üí\n          [inst_2 : TopologicalSpace Œ±] ‚Üí\n            [inst_3 : TopologicalSpace Œ≤] ‚Üí [inst_4 : ContinuousOrderHomClass F Œ± Œ≤] ‚Üí F ‚Üí Œ± ‚ÜíCo Œ≤",
    "name": "ContinuousOrderHomClass.toContinuousOrderHom",
    "isProp": false,
    "doc":
    "Turn an element of a type `F` satisfying `ContinuousOrderHomClass F Œ± Œ≤` into an actual\n`ContinuousOrderHom`. This is declared as the default coercion from `F` to `Œ± ‚ÜíCo Œ≤`. ",
    "depth": 15}],
  "count": 35},
 {"noDocExamples": [],
  "kind": "¬´term_‚äï'_¬ª",
  "examples":
  [{"type": "(Œ± : Type u_4) ‚Üí Fintype Œ± ‚äï' Infinite Œ±",
    "name": "fintypeOrInfinite",
    "isProp": false,
    "doc":
    "Any type is (classically) either a `Fintype`, or `Infinite`.\n\nOne can obtain the relevant typeclasses via `cases fintypeOrInfinite Œ±`.\n",
    "depth": 4},
   {"type": "{Œ± : Sort u} ‚Üí {Œ≤ : Sort v} ‚Üí Œ± ‚Üí Œ± ‚äï' Œ≤",
    "name": "PSum.inl",
    "isProp": false,
    "doc":
    "Left injection into the sum type `Œ± ‚äï' Œ≤`. If `a : Œ±` then `.inl a : Œ± ‚äï' Œ≤`. ",
    "depth": 5},
   {"type": "(Œ± : Type u_3) ‚Üí [inst : Inhabited Œ±] ‚Üí Nontrivial Œ± ‚äï' Unique Œ±",
    "name": "nontrivialPSumUnique",
    "isProp": false,
    "doc": "An inhabited type is either nontrivial, or has a unique element. ",
    "depth": 5}],
  "count": 35},
 {"noDocExamples": [],
  "kind": "TypeVec.¬´term_:::__1¬ª",
  "examples":
  [{"type":
    "(n : ‚Ñï) ‚Üí\n  {Œ≤ : (v : TypeVec (n + 1)) ‚Üí (v' : TypeVec (n + 1)) ‚Üí TypeVec.Arrow v v' ‚Üí Sort u_1} ‚Üí\n    ((t : Type u_2) ‚Üí\n        (t' : Type u_3) ‚Üí\n          (f : t ‚Üí t') ‚Üí\n            (v : TypeVec n) ‚Üí (v' : TypeVec n) ‚Üí (fs : TypeVec.Arrow v v') ‚Üí Œ≤ (v ::: t) (v' ::: t') (fs ::: f)) ‚Üí\n      (v : TypeVec (n + 1)) ‚Üí (v' : TypeVec (n + 1)) ‚Üí (fs : TypeVec.Arrow v v') ‚Üí Œ≤ v v' fs",
    "name": "TypeVec.typevecCasesCons‚ÇÉ",
    "isProp": false,
    "doc":
    "cases distinction for an arrow in the category of (n+1)-length type vectors ",
    "depth": 17},
   {"type":
    "(n : ‚Ñï) ‚Üí\n  (t : Type u_1) ‚Üí\n    (t' : Type u_2) ‚Üí\n      (v : TypeVec n) ‚Üí\n        (v' : TypeVec n) ‚Üí\n          {Œ≤ : TypeVec.Arrow (v ::: t) (v' ::: t') ‚Üí Sort u_3} ‚Üí\n            ((f : t ‚Üí t') ‚Üí (fs : TypeVec.Arrow v v') ‚Üí Œ≤ (fs ::: f)) ‚Üí\n              (fs : TypeVec.Arrow (v ::: t) (v' ::: t')) ‚Üí Œ≤ fs",
    "name": "TypeVec.typevecCasesCons‚ÇÇ",
    "isProp": false,
    "doc":
    "specialized cases distinction for an arrow in the category of (n+1)-length type vectors ",
    "depth": 17},
   {"type":
    "{n : ‚Ñï} ‚Üí\n  {F : TypeVec (n + 1) ‚Üí Type u} ‚Üí\n    [inst : MvFunctor F] ‚Üí\n      [q : MvQPF F] ‚Üí\n        {Œ± : TypeVec n} ‚Üí\n          {Œ≤ : MvQPF.Fix F Œ± ‚Üí Type u} ‚Üí\n            ((x : F (Œ± ::: Sigma Œ≤)) ‚Üí Œ≤ (MvQPF.Fix.mk (MvFunctor.map (TypeVec.id ::: Sigma.fst) x))) ‚Üí\n              (x : MvQPF.Fix F Œ±) ‚Üí Œ≤ x",
    "name": "MvQPF.Fix.drec",
    "isProp": false,
    "doc": "Dependent recursor for `fix F` ",
    "depth": 23}],
  "count": 35},
 {"noDocExamples": [],
  "kind": "SimpleGraph.¬´term_‚Ü™g_¬ª",
  "examples":
  [{"type": "{V : Type u} ‚Üí {G : SimpleGraph V} ‚Üí G ‚Ü™g G",
    "name": "SimpleGraph.Embedding.refl",
    "isProp": false,
    "doc": "The identity embedding from a graph to itself. ",
    "depth": 6},
   {"type":
    "{V : Type u} ‚Üí {s : Set V} ‚Üí (G : SimpleGraph ‚Üës) ‚Üí G ‚Ü™g SimpleGraph.spanningCoe G",
    "name": "SimpleGraph.Embedding.spanningCoe",
    "isProp": false,
    "doc": "Graphs on a set of vertices embed in their `spanningCoe`. ",
    "depth": 9},
   {"type":
    "{V : Type u} ‚Üí {W : Type v} ‚Üí (f : V ‚Ü™ W) ‚Üí (G : SimpleGraph V) ‚Üí G ‚Ü™g SimpleGraph.map f G",
    "name": "SimpleGraph.Embedding.map",
    "isProp": false,
    "doc":
    "Given an injective function, there is an embedding from a graph into the mapped graph. ",
    "depth": 9}],
  "count": 34},
 {"noDocExamples": [],
  "kind": "Polynomial.¬´term_%‚Çò_¬ª",
  "examples":
  [{"type":
    "‚àÄ {R : Type u} [inst : CommRing R] {n : Type v} [inst_1 : DecidableEq n] [inst_2 : Fintype n] (M : Matrix n n R)\n  (k : ‚Ñï), M ^ k = ‚Üë(Polynomial.aeval M) (Polynomial.X ^ k %‚Çò Matrix.charpoly M)",
    "name": "Matrix.pow_eq_aeval_mod_charpoly",
    "isProp": true,
    "doc":
    "Any matrix power can be computed as the sum of matrix powers less than `Fintype.card n`.\n\nTODO: add the statement for negative powers phrased with `zpow`. ",
    "depth": 34},
   {"type":
    "‚àÄ {R : Type u} [inst : CommRing R] {n : Type v} [inst_1 : DecidableEq n] [inst_2 : Fintype n] (M : Matrix n n R)\n  (p : Polynomial R), ‚Üë(Polynomial.aeval M) p = ‚Üë(Polynomial.aeval M) (p %‚Çò Matrix.charpoly M)",
    "name": "Matrix.aeval_eq_aeval_mod_charpoly",
    "isProp": true,
    "doc":
    "Any matrix polynomial `p` is equivalent under evaluation to `p %‚Çò M.charpoly`; that is, `p`\nis equivalent to a polynomial with degree less than the dimension of the matrix. ",
    "depth": 35},
   {"type":
    "‚àÄ {R : Type u} {M : Type v} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : Module.Free R M] [inst_4 : Module.Finite R M] (f : M ‚Üí‚Çó[R] M) (k : ‚Ñï),\n  f ^ k = ‚Üë(Polynomial.aeval f) (Polynomial.X ^ k %‚Çò LinearMap.charpoly f)",
    "name": "LinearMap.pow_eq_aeval_mod_charpoly",
    "isProp": true,
    "doc":
    "Any endomorphism power can be computed as the sum of endomorphism powers less than the\ndimension of the module. ",
    "depth": 43}],
  "count": 34},
 {"noDocExamples":
  [{"type":
    "‚àÄ {M : Type w'} [inst : LE M] [h : NoTopOrder M], M ‚ä® FirstOrder.Language.noTopOrderSentence FirstOrder.Language.order",
    "name": "FirstOrder.Language.realize_noTopOrder",
    "isProp": true,
    "depth": 7},
   {"type":
    "‚àÄ {M : Type w'} [inst : LE M] [h : NoBotOrder M], M ‚ä® FirstOrder.Language.noBotOrderSentence FirstOrder.Language.order",
    "name": "FirstOrder.Language.realize_noBotOrder",
    "isProp": true,
    "depth": 7}],
  "kind": "FirstOrder.Language.¬´term_‚ä®_¬ª",
  "examples":
  [{"type":
    "‚àÄ {Œ± : Type u_1} {M : Œ± ‚Üí Type u_2} {u : Ultrafilter Œ±} {L : FirstOrder.Language}\n  [inst : (a : Œ±) ‚Üí FirstOrder.Language.Structure L (M a)] [inst_1 : ‚àÄ (a : Œ±), Nonempty (M a)]\n  (œÜ : FirstOrder.Language.Sentence L), Filter.Product (‚Üëu) M ‚ä® œÜ ‚Üî ‚àÄ·∂† (a : Œ±) in ‚Üëu, M a ‚ä® œÜ",
    "name": "FirstOrder.Language.Ultraproduct.sentence_realize",
    "isProp": true,
    "doc":
    "≈Åo≈õ's Theorem : A sentence is true in an ultraproduct if and only if the set of structures it is\ntrue in is in the ultrafilter. ",
    "depth": 16}],
  "count": 34},
 {"noDocExamples": [],
  "kind": "FirstOrder.Language.¬´term_‚âÉ·¥∏_¬ª",
  "examples":
  [{"type": "(L : FirstOrder.Language) ‚Üí L ‚âÉ·¥∏ L",
    "name": "FirstOrder.Language.LEquiv.refl",
    "isProp": false,
    "doc": "The identity equivalence from a first-order language to itself. ",
    "depth": 3},
   {"type":
    "{L : FirstOrder.Language} ‚Üí {L' : FirstOrder.Language} ‚Üí (L ‚âÉ·¥∏ L') ‚Üí (L' ‚âÉ·¥∏ L)",
    "name": "FirstOrder.Language.LEquiv.symm",
    "isProp": false,
    "doc": "The inverse of an equivalence of first-order languages. ",
    "depth": 5},
   {"type":
    "{L : FirstOrder.Language} ‚Üí\n  {L' : FirstOrder.Language} ‚Üí (L ‚âÉ·¥∏ L') ‚Üí FirstOrder.Language.Sentence L ‚âÉ FirstOrder.Language.Sentence L'",
    "name": "FirstOrder.Language.LEquiv.onSentence",
    "isProp": false,
    "doc": "Maps a sentence's symbols along a language equivalence. ",
    "depth": 6}],
  "count": 34},
 {"noDocExamples": [],
  "kind": "¬´term_/‚Çö_¬ª",
  "examples":
  [{"type": "‚àÄ {Œ± : Type u} [inst : Monoid Œ±] (u : Œ±À£), ‚Üëu‚Åª¬π = 1 /‚Çö u",
    "name": "inv_eq_one_divp",
    "isProp": true,
    "doc": "Used for `field_simp` to deal with inverses of units. ",
    "depth": 11},
   {"type":
    "‚àÄ {Œ± : Type u} [inst : Monoid Œ±] (x y : Œ±) (u : Œ±À£), x * (y /‚Çö u) = x * y /‚Çö u",
    "name": "divp_assoc'",
    "isProp": true,
    "doc":
    "`field_simp` needs the reverse direction of `divp_assoc` to move all `/‚Çö` to the right. ",
    "depth": 15},
   {"type":
    "‚àÄ {Œ± : Type u} [inst : Monoid Œ±] (u‚ÇÅ u‚ÇÇ : Œ±À£), ‚Üë(u‚ÇÅ / u‚ÇÇ) = ‚Üëu‚ÇÅ /‚Çö u‚ÇÇ",
    "name": "val_div_eq_divp",
    "isProp": true,
    "doc":
    "`field_simp` moves division inside `Œ±À£` to the right, and this lemma\nlifts the calculation to `Œ±`.\n",
    "depth": 16}],
  "count": 34},
 {"noDocExamples": [],
  "kind": "MeasureTheory.¬´term‚®ç_In_,_‚àÇ_¬ª",
  "examples":
  [{"type":
    "‚àÄ {Œ± : Type u_1} {m0 : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {s : Set Œ±} {f : Œ± ‚Üí ‚Ñù},\n  ‚Üë‚ÜëŒº s ‚â† 0 ‚Üí ‚Üë‚ÜëŒº s ‚â† ‚ä§ ‚Üí MeasureTheory.IntegrableOn f s ‚Üí ‚àÉ x, x ‚àà s ‚àß f x ‚â§ ‚®ç (a : Œ±) in s, f a ‚àÇŒº",
    "name": "MeasureTheory.exists_le_setAverage",
    "isProp": true,
    "doc":
    "**First moment method**. The minimum of an integrable function is smaller than its mean. ",
    "depth": 19},
   {"type":
    "‚àÄ {Œ± : Type u_1} {m0 : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {s : Set Œ±} {f : Œ± ‚Üí ‚Ñù},\n  ‚Üë‚ÜëŒº s ‚â† 0 ‚Üí ‚Üë‚ÜëŒº s ‚â† ‚ä§ ‚Üí MeasureTheory.IntegrableOn f s ‚Üí ‚àÉ x, x ‚àà s ‚àß ‚®ç (a : Œ±) in s, f a ‚àÇŒº ‚â§ f x",
    "name": "MeasureTheory.exists_setAverage_le",
    "isProp": true,
    "doc":
    "**First moment method**. The maximum of an integrable function is greater than its mean. ",
    "depth": 20},
   {"type":
    "‚àÄ {Œ± : Type u_1} {m0 : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {s : Set Œ±} {f : Œ± ‚Üí ‚Ñù},\n  ‚Üë‚ÜëŒº s ‚â† 0 ‚Üí ‚Üë‚ÜëŒº s ‚â† ‚ä§ ‚Üí MeasureTheory.IntegrableOn f s ‚Üí 0 < ‚Üë‚ÜëŒº {x | x ‚àà s ‚àß f x ‚â§ ‚®ç (a : Œ±) in s, f a ‚àÇŒº}",
    "name": "MeasureTheory.measure_le_setAverage_pos",
    "isProp": true,
    "doc":
    "**First moment method**. An integrable function is smaller than its mean on a set of positive\nmeasure. ",
    "depth": 21}],
  "count": 33},
 {"noDocExamples": [],
  "kind": "CategoryTheory.exp.¬´term_‚üπ_¬ª",
  "examples":
  [{"type":
    "{C : Type u} ‚Üí\n  [inst : CategoryTheory.Category.{v, u} C] ‚Üí\n    {A Y : C} ‚Üí\n      [inst_1 : CategoryTheory.Limits.HasFiniteProducts C] ‚Üí\n        [inst_2 : CategoryTheory.Exponentiable A] ‚Üí (A ‚ü∂ Y) ‚Üí (‚ä§_ C ‚ü∂ A ‚üπ Y)",
    "name": "CategoryTheory.internalizeHom",
    "isProp": false,
    "doc": "The internal element which points at the given morphism. ",
    "depth": 16},
   {"type":
    "{C : Type u} ‚Üí\n  [inst : CategoryTheory.Category.{v, u} C] ‚Üí\n    {A X Y : C} ‚Üí\n      [inst_1 : CategoryTheory.Limits.HasFiniteProducts C] ‚Üí\n        [inst_2 : CategoryTheory.Exponentiable A] ‚Üí (A ‚®Ø Y ‚ü∂ X) ‚Üí (Y ‚ü∂ A ‚üπ X)",
    "name": "CategoryTheory.CartesianClosed.curry",
    "isProp": false,
    "doc": "Currying in a cartesian closed category. ",
    "depth": 18},
   {"type":
    "{C : Type u} ‚Üí\n  [inst : CategoryTheory.Category.{v, u} C] ‚Üí\n    {A X Y : C} ‚Üí\n      [inst_1 : CategoryTheory.Limits.HasFiniteProducts C] ‚Üí\n        [inst_2 : CategoryTheory.Exponentiable A] ‚Üí (Y ‚ü∂ A ‚üπ X) ‚Üí (A ‚®Ø Y ‚ü∂ X)",
    "name": "CategoryTheory.CartesianClosed.uncurry",
    "isProp": false,
    "doc": "Uncurrying in a cartesian closed category. ",
    "depth": 18}],
  "count": 33},
 {"noDocExamples": [],
  "kind": "¬´term_‚âÉSL[_]_¬ª",
  "examples":
  [{"type":
    "{R : Type u_1} ‚Üí\n  {R‚ÇÇ : Type u_2} ‚Üí\n    {E : Type u_5} ‚Üí\n      {E‚ÇÇ : Type u_6} ‚Üí\n        [inst : Semiring R] ‚Üí\n          [inst_1 : Semiring R‚ÇÇ] ‚Üí\n            {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} ‚Üí\n              {œÉ‚ÇÇ‚ÇÅ : R‚ÇÇ ‚Üí+* R} ‚Üí\n                [inst_2 : RingHomInvPair œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÅ] ‚Üí\n                  [inst_3 : RingHomInvPair œÉ‚ÇÇ‚ÇÅ œÉ‚ÇÅ‚ÇÇ] ‚Üí\n                    [inst_4 : SeminormedAddCommGroup E] ‚Üí\n                      [inst_5 : SeminormedAddCommGroup E‚ÇÇ] ‚Üí\n                        [inst_6 : Module R E] ‚Üí [inst_7 : Module R‚ÇÇ E‚ÇÇ] ‚Üí CoeTC (E ‚âÉ‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ) (E ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ)",
    "name":
    "LinearIsometryEquiv.instCoeTCLinearIsometryEquivContinuousLinearEquivToTopologicalSpaceToUniformSpaceToPseudoMetricSpaceToAddCommMonoidToAddCommGroupToTopologicalSpaceToUniformSpaceToPseudoMetricSpaceToAddCommMonoidToAddCommGroup",
    "isProp": false,
    "doc": "Reinterpret a `LinearIsometryEquiv` as a `ContinuousLinearEquiv`. ",
    "depth": 31},
   {"type":
    "{R : Type u_1} ‚Üí\n  {R‚ÇÇ : Type u_2} ‚Üí\n    {E : Type u_5} ‚Üí\n      {E‚ÇÇ : Type u_6} ‚Üí\n        [inst : Semiring R] ‚Üí\n          [inst_1 : Semiring R‚ÇÇ] ‚Üí\n            {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} ‚Üí\n              {œÉ‚ÇÇ‚ÇÅ : R‚ÇÇ ‚Üí+* R} ‚Üí\n                [inst_2 : RingHomInvPair œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÅ] ‚Üí\n                  [inst_3 : RingHomInvPair œÉ‚ÇÇ‚ÇÅ œÉ‚ÇÅ‚ÇÇ] ‚Üí\n                    [inst_4 : SeminormedAddCommGroup E] ‚Üí\n                      [inst_5 : SeminormedAddCommGroup E‚ÇÇ] ‚Üí\n                        [inst_6 : Module R E] ‚Üí [inst_7 : Module R‚ÇÇ E‚ÇÇ] ‚Üí (E ‚âÉ‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ) ‚Üí E ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ",
    "name": "LinearIsometryEquiv.toContinuousLinearEquiv",
    "isProp": false,
    "doc": "Interpret a `LinearIsometryEquiv` as a `ContinuousLinearEquiv`. ",
    "depth": 31},
   {"type":
    "{R‚ÇÅ : Type u_1} ‚Üí\n  {R‚ÇÇ : Type u_2} ‚Üí\n    [inst : Semiring R‚ÇÅ] ‚Üí\n      [inst_1 : Semiring R‚ÇÇ] ‚Üí\n        {œÉ‚ÇÅ‚ÇÇ : R‚ÇÅ ‚Üí+* R‚ÇÇ} ‚Üí\n          {œÉ‚ÇÇ‚ÇÅ : R‚ÇÇ ‚Üí+* R‚ÇÅ} ‚Üí\n            [inst_2 : RingHomInvPair œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÅ] ‚Üí\n              [inst_3 : RingHomInvPair œÉ‚ÇÇ‚ÇÅ œÉ‚ÇÅ‚ÇÇ] ‚Üí\n                {M‚ÇÅ : Type u_4} ‚Üí\n                  [inst_4 : TopologicalSpace M‚ÇÅ] ‚Üí\n                    [inst_5 : AddCommMonoid M‚ÇÅ] ‚Üí\n                      {M‚ÇÇ : Type u_6} ‚Üí\n                        [inst_6 : TopologicalSpace M‚ÇÇ] ‚Üí\n                          [inst_7 : AddCommMonoid M‚ÇÇ] ‚Üí\n                            [inst_8 : Module R‚ÇÅ M‚ÇÅ] ‚Üí [inst_9 : Module R‚ÇÇ M‚ÇÇ] ‚Üí (M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) ‚Üí M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ",
    "name": "ContinuousLinearEquiv.toContinuousLinearMap",
    "isProp": false,
    "doc": "A continuous linear equivalence induces a continuous linear map. ",
    "depth": 33}],
  "count": 32},
 {"noDocExamples": [],
  "kind": "AlgebraicGeometry.¬´term_‚à£__¬ª",
  "examples":
  [{"type":
    "‚àÄ {P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme},\n  AlgebraicGeometry.PropertyIsLocalAtTarget P ‚Üí\n    ‚àÄ {X Y : AlgebraicGeometry.Scheme} (f : X ‚ü∂ Y) (U : TopologicalSpace.Opens ‚Üë‚ÜëY.toPresheafedSpace), P f ‚Üí P (f ‚à£_ U)",
    "name": "AlgebraicGeometry.PropertyIsLocalAtTarget.restrict",
    "isProp": true,
    "doc":
    "If `P` holds for `f : X ‚ü∂ Y`, then `P` holds for `f ‚à£_ U` for any `U`. ",
    "depth": 34},
   {"type":
    "{X Y U : AlgebraicGeometry.Scheme} ‚Üí\n  (f : X ‚ü∂ Y) ‚Üí\n    (g : U ‚ü∂ Y) ‚Üí\n      [hg : AlgebraicGeometry.IsOpenImmersion g] ‚Üí\n        CategoryTheory.Arrow.mk (f ‚à£_ AlgebraicGeometry.Scheme.Hom.opensRange g) ‚âÖ\n          CategoryTheory.Arrow.mk CategoryTheory.Limits.pullback.snd",
    "name": "AlgebraicGeometry.morphismRestrictOpensRange",
    "isProp": false,
    "doc":
    "Restricting a morphism onto the image of an open immersion is isomorphic to the base change\nalong the immersion. ",
    "depth": 35},
   {"type":
    "{X Y : AlgebraicGeometry.Scheme} ‚Üí\n  (f : X ‚ü∂ Y) ‚Üí\n    {U V : TopologicalSpace.Opens ‚Üë‚ÜëY.toPresheafedSpace} ‚Üí\n      U = V ‚Üí (CategoryTheory.Arrow.mk (f ‚à£_ U) ‚âÖ CategoryTheory.Arrow.mk (f ‚à£_ V))",
    "name": "AlgebraicGeometry.morphismRestrictEq",
    "isProp": false,
    "doc":
    "The restrictions onto two equal open sets are isomorphic. This currently has bad defeqs when\nunfolded, but it should not matter for now. Replace this definition if better defeqs are needed. ",
    "depth": 35}],
  "count": 32},
 {"noDocExamples":
  [{"type":
    "‚àÄ {V : Type u} [inst : Quiver V],\n  CategoryTheory.Groupoid.Free.of V =\n    Quiver.Symmetrify.of ‚ãôq CategoryTheory.Paths.of ‚ãôq\n      (CategoryTheory.Quotient.functor CategoryTheory.Groupoid.Free.redStep).toPrefunctor",
    "name": "CategoryTheory.Groupoid.Free.of_eq",
    "isProp": true,
    "depth": 14},
   {"type":
    "‚àÄ {U : Type u_1} {V : Type u_2} [inst : Quiver U] [inst_1 : Quiver V] (F : U ‚•§q V), ùü≠q U ‚ãôq F = F",
    "name": "Prefunctor.id_comp",
    "isProp": true,
    "depth": 15}],
  "kind": "Prefunctor.¬´term_‚ãôq_¬ª",
  "examples":
  [{"type":
    "‚àÄ {V : Type u_2} [inst : Quiver V] {V' : Type u_4} [inst_1 : Quiver V'] [inst_2 : Quiver.HasReverse V'] (œÜ : V ‚•§q V')\n  (Œ¶ : Quiver.Symmetrify V ‚•§q V'),\n  Quiver.Symmetrify.of ‚ãôq Œ¶ = œÜ ‚Üí\n    (‚àÄ {X Y : Quiver.Symmetrify V} (f : X ‚ü∂ Y), Œ¶.map (Quiver.reverse f) = Quiver.reverse (Œ¶.map f)) ‚Üí\n      Œ¶ = Quiver.Symmetrify.lift œÜ",
    "name": "Quiver.Symmetrify.lift_unique",
    "isProp": true,
    "doc":
    "`lift œÜ` is the only prefunctor extending `œÜ` and preserving reverses. ",
    "depth": 24}],
  "count": 30},
 {"noDocExamples": [],
  "kind": "Polynomial.¬´term_/‚Çò_¬ª",
  "examples":
  [{"type":
    "‚àÄ {R : Type u} [inst : CommRing R] {p q : Polynomial R},\n  Polynomial.Monic q ‚Üí\n    Polynomial.degree q ‚â§ Polynomial.degree p ‚Üí Polynomial.leadingCoeff (p /‚Çò q) = Polynomial.leadingCoeff p",
    "name": "Polynomial.leadingCoeff_divByMonic_of_monic",
    "isProp": true,
    "doc":
    "Division by a monic polynomial doesn't change the leading coefficient. ",
    "depth": 14},
   {"type":
    "‚àÄ {R : Type u_1} [inst : CommRing R] {n : ‚Ñï},\n  0 < n ‚Üí\n    Polynomial.cyclotomic n R =\n      (Polynomial.X ^ n - 1) /‚Çò Finset.prod (Nat.properDivisors n) fun i => Polynomial.cyclotomic i R",
    "name": "Polynomial.cyclotomic_eq_X_pow_sub_one_div",
    "isProp": true,
    "doc":
    "We have\n`cyclotomic n R = (X ^ k - 1) /‚Çò (‚àè i in Nat.properDivisors k, cyclotomic i K)`. ",
    "depth": 21},
   {"type":
    "‚àÄ {K : Type u_2} [inst : CommRing K] [inst_1 : IsDomain K] {Œ∂ : K} {n : ‚Ñï},\n  0 < n ‚Üí\n    IsPrimitiveRoot Œ∂ n ‚Üí\n      Polynomial.cyclotomic' n K =\n        (Polynomial.X ^ n - 1) /‚Çò Finset.prod (Nat.properDivisors n) fun i => Polynomial.cyclotomic' i K",
    "name": "Polynomial.cyclotomic'_eq_X_pow_sub_one_div",
    "isProp": true,
    "doc":
    "If there is a primitive `n`-th root of unity in `K`, then\n`cyclotomic' n K = (X ^ k - 1) /‚Çò (‚àè i in Nat.properDivisors k, cyclotomic' i K)`. ",
    "depth": 24}],
  "count": 30},
 {"noDocExamples":
  [{"type": "‚àÄ {Œ± : Type u_1} (l : List Œ±), [] <:+: l",
    "name": "List.nil_infix",
    "isProp": true,
    "depth": 5}],
  "kind": "List.¬´term_<:+:_¬ª",
  "examples":
  [{"type": "‚àÄ {Œ± : Type u_1} {l : List Œ±}, l <:+: [] ‚Üí l = []",
    "name": "List.eq_nil_of_infix_nil",
    "isProp": true,
    "doc": "**Alias** of the forward direction of `List.infix_nil`.",
    "depth": 7},
   {"type":
    "‚àÄ {Œ± : Type u_1} {l‚ÇÅ l‚ÇÇ : List Œ±}, l‚ÇÅ <:+: l‚ÇÇ ‚Üí List.reverse l‚ÇÅ <:+: List.reverse l‚ÇÇ",
    "name": "List.isInfix.reverse",
    "isProp": true,
    "doc": "**Alias** of the reverse direction of `List.reverse_infix`.",
    "depth": 8}],
  "count": 29},
 {"noDocExamples": [],
  "kind": "¬´term_==_¬ª",
  "examples":
  [{"type":
    "‚àÄ {Œ± : Type u} [inst : BEq Œ±] [self : LawfulBEq Œ±] {a : Œ±}, (a == a) = true",
    "name": "LawfulBEq.rfl",
    "isProp": true,
    "doc": "`==` is reflexive, that is, `(a == a) = true`. ",
    "depth": 10},
   {"type":
    "‚àÄ {Œ± : Type u} [inst : BEq Œ±] [self : LawfulBEq Œ±] {a b : Œ±}, (a == b) = true ‚Üí a = b",
    "name": "LawfulBEq.eq_of_beq",
    "isProp": true,
    "doc":
    "If `a == b` evaluates to `true`, then `a` and `b` are equal in the logic. ",
    "depth": 12},
   {"type":
    "‚àÄ {Œ± : Type u_1} [inst : BEq Œ±] [self : PartialEquivBEq Œ±] {a b : Œ±}, (a == b) = true ‚Üí (b == a) = true",
    "name": "PartialEquivBEq.symm",
    "isProp": true,
    "doc": "Symmetry for `BEq`. If `a == b` then `b == a`. ",
    "depth": 12}],
  "count": 28},
 {"noDocExamples":
  [{"type":
    "‚àÄ {C : Type uC} [inst : CategoryTheory.Category.{uC', uC} C] {W : CategoryTheory.MorphismProperty C} {D : Type uD}\n  [inst_1 : CategoryTheory.Category.{uD', uD} D]\n  {F G : CategoryTheory.Functor (CategoryTheory.MorphismProperty.Localization W) D}\n  (œÑ :\n    CategoryTheory.Functor.comp (CategoryTheory.MorphismProperty.Q W) F ‚ü∂\n      CategoryTheory.Functor.comp (CategoryTheory.MorphismProperty.Q W) G),\n  CategoryTheory.CategoryStruct.id (CategoryTheory.MorphismProperty.Q W) ‚ó´\n      CategoryTheory.Localization.Construction.natTransExtension œÑ =\n    œÑ",
    "name": "CategoryTheory.Localization.Construction.natTransExtension_hcomp",
    "isProp": true,
    "depth": 23},
   {"type":
    "‚àÄ {C : Type uC} [inst : CategoryTheory.Category.{uC', uC} C] {W : CategoryTheory.MorphismProperty C} {D : Type uD}\n  [inst_1 : CategoryTheory.Category.{uD', uD} D]\n  {F G : CategoryTheory.Functor (CategoryTheory.MorphismProperty.Localization W) D} {œÑ‚ÇÅ œÑ‚ÇÇ : F ‚ü∂ G},\n  CategoryTheory.CategoryStruct.id (CategoryTheory.MorphismProperty.Q W) ‚ó´ œÑ‚ÇÅ =\n      CategoryTheory.CategoryStruct.id (CategoryTheory.MorphismProperty.Q W) ‚ó´ œÑ‚ÇÇ ‚Üí\n    œÑ‚ÇÅ = œÑ‚ÇÇ",
    "name": "CategoryTheory.Localization.Construction.natTrans_hcomp_injective",
    "isProp": true,
    "depth": 26},
   {"type":
    "‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D]\n  {E : Type u‚ÇÉ} [inst_2 : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E] {F G : CategoryTheory.Functor C D}\n  {H I : CategoryTheory.Functor D E} (Œ± : F ‚âÖ G) (Œ≤ : H ‚âÖ I), (CategoryTheory.NatIso.hcomp Œ± Œ≤).hom = Œ±.hom ‚ó´ Œ≤.hom",
    "name": "CategoryTheory.NatIso.hcomp_hom",
    "isProp": true,
    "depth": 27}],
  "kind": "CategoryTheory.NatTrans.¬´term_‚ó´_¬ª",
  "examples": [],
  "count": 27},
 {"noDocExamples":
  [{"type": "‚àÄ {Œ± : Type u} (s : Stream'.WSeq Œ±), s ~ ∑ s",
    "name": "Stream'.WSeq.Equiv.refl",
    "isProp": true,
    "depth": 5},
   {"type": "‚àÄ {Œ± : Type u} (s : Stream'.WSeq Œ±), Stream'.WSeq.think s ~ ∑ s",
    "name": "Stream'.WSeq.think_equiv",
    "isProp": true,
    "depth": 6},
   {"type": "‚àÄ {Œ± : Type u} {s t : Stream'.WSeq Œ±}, s ~ ∑ t ‚Üí t ~ ∑ s",
    "name": "Stream'.WSeq.Equiv.symm",
    "isProp": true,
    "depth": 7}],
  "kind": "Stream'.WSeq.¬´term_~ ∑_¬ª",
  "examples": [],
  "count": 27},
 {"noDocExamples": [],
  "kind": "¬´term_‚ÜíCO_¬ª",
  "examples":
  [{"type": "(Œ± : Type u_2) ‚Üí [inst : TopologicalSpace Œ±] ‚Üí Œ± ‚ÜíCO Œ±",
    "name": "ContinuousOpenMap.id",
    "isProp": false,
    "doc": "`id` as a `ContinuousOpenMap`. ",
    "depth": 6},
   {"type":
    "{Œ± : Type u_2} ‚Üí\n  {Œ≤ : Type u_3} ‚Üí\n    {Œ≥ : Type u_4} ‚Üí\n      [inst : TopologicalSpace Œ±] ‚Üí\n        [inst_1 : TopologicalSpace Œ≤] ‚Üí [inst_2 : TopologicalSpace Œ≥] ‚Üí (Œ≤ ‚ÜíCO Œ≥) ‚Üí (Œ± ‚ÜíCO Œ≤) ‚Üí Œ± ‚ÜíCO Œ≥",
    "name": "ContinuousOpenMap.comp",
    "isProp": false,
    "doc": "Composition of `ContinuousOpenMap`s as a `ContinuousOpenMap`. ",
    "depth": 12},
   {"type":
    "{Œ± : Type u_2} ‚Üí\n  {Œ≤ : Type u_3} ‚Üí\n    [inst : TopologicalSpace Œ±] ‚Üí [inst_1 : TopologicalSpace Œ≤] ‚Üí (f : Œ± ‚ÜíCO Œ≤) ‚Üí (f' : Œ± ‚Üí Œ≤) ‚Üí f' = ‚Üëf ‚Üí Œ± ‚ÜíCO Œ≤",
    "name": "ContinuousOpenMap.copy",
    "isProp": false,
    "doc":
    "Copy of a `ContinuousOpenMap` with a new `ContinuousMap` equal to the old one. Useful to fix\ndefinitional equalities. ",
    "depth": 21}],
  "count": 26},
 {"noDocExamples": [],
  "kind": "SimpleGraph.¬´term_‚ñ°_¬ª",
  "examples":
  [{"type":
    "{Œ± : Type u_1} ‚Üí {Œ≤ : Type u_2} ‚Üí (G : SimpleGraph Œ±) ‚Üí (H : SimpleGraph Œ≤) ‚Üí G ‚ñ° H ‚âÉg H ‚ñ° G",
    "name": "SimpleGraph.boxProdComm",
    "isProp": false,
    "doc":
    "The box product is commutative up to isomorphism. `Equiv.prodComm` as a graph isomorphism. ",
    "depth": 10},
   {"type":
    "{Œ± : Type u_1} ‚Üí {Œ≤ : Type u_2} ‚Üí (G : SimpleGraph Œ±) ‚Üí (H : SimpleGraph Œ≤) ‚Üí Œ≤ ‚Üí G ‚Ü™g G ‚ñ° H",
    "name": "SimpleGraph.boxProdLeft",
    "isProp": false,
    "doc": "The embedding of `G` into `G ‚ñ° H` given by `b`. ",
    "depth": 10},
   {"type":
    "{Œ± : Type u_1} ‚Üí {Œ≤ : Type u_2} ‚Üí (G : SimpleGraph Œ±) ‚Üí (H : SimpleGraph Œ≤) ‚Üí Œ± ‚Üí H ‚Ü™g G ‚ñ° H",
    "name": "SimpleGraph.boxProdRight",
    "isProp": false,
    "doc": "The embedding of `H` into `G ‚ñ° H` given by `a`. ",
    "depth": 10}],
  "count": 26},
 {"noDocExamples": [],
  "kind": "¬´term_‚Üír_¬ª",
  "examples":
  [{"type": "{Œ± : Type u_1} ‚Üí (r : Œ± ‚Üí Œ± ‚Üí Prop) ‚Üí r ‚Üír r",
    "name": "RelHom.id",
    "isProp": false,
    "doc": "Identity map is a relation homomorphism. ",
    "depth": 6},
   {"type":
    "{Œ± : Type u_1} ‚Üí {Œ≤ : Type u_2} ‚Üí {r : Œ± ‚Üí Œ± ‚Üí Prop} ‚Üí {s : Œ≤ ‚Üí Œ≤ ‚Üí Prop} ‚Üí r ‚Ü™r s ‚Üí r ‚Üír s",
    "name": "RelEmbedding.toRelHom",
    "isProp": false,
    "doc": "A relation embedding is also a relation homomorphism ",
    "depth": 9},
   {"type":
    "{Œ± : Type u_5} ‚Üí {Œ≤ : Type u_6} ‚Üí {r : Œ± ‚Üí Œ± ‚Üí Prop} ‚Üí {s : Œ≤ ‚Üí Œ≤ ‚Üí Prop} ‚Üí r ‚Üír s ‚Üí Œ± ‚Üí Œ≤",
    "name": "RelHom.toFun",
    "isProp": false,
    "doc": "The underlying function of a `RelHom` ",
    "depth": 9}],
  "count": 25},
 {"noDocExamples": [],
  "kind": "Function.¬´term‚Üø_¬ª",
  "examples":
  [{"type":
    "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤]\n  [inst_2 : WeaklyLocallyCompactSpace Œ±] [inst_3 : CompactSpace Œ≤] [inst_4 : UniformSpace Œ≥] (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥),\n  Continuous ‚Üøf ‚Üí ‚àÄ (x : Œ±), TendstoUniformly f (f x) (nhds x)",
    "name": "Continuous.tendstoUniformly",
    "isProp": true,
    "doc":
    "A continuous family of functions `Œ± ‚Üí Œ≤ ‚Üí Œ≥` tends uniformly to its value at `x`\nif `Œ±` is weakly locally compact and `Œ≤` is compact. ",
    "depth": 18},
   {"type":
    "‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {p : Filter Œπ} {c : Œ≤},\n  Filter.Tendsto (‚ÜøF) (p √óÀ¢ ‚ä§) (nhds c) ‚Üî TendstoUniformly F (fun x => c) p",
    "name": "tendsto_prod_top_iff",
    "isProp": true,
    "doc":
    "Uniform convergence to a constant function is equivalent to convergence in `p √óÀ¢ ‚ä§`. ",
    "depth": 19},
   {"type":
    "‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {s : Set Œ±} {p : Filter Œπ} {c : Œ≤},\n  Filter.Tendsto (‚ÜøF) (p √óÀ¢ Filter.principal s) (nhds c) ‚Üî TendstoUniformlyOn F (fun x => c) p s",
    "name": "tendsto_prod_principal_iff",
    "isProp": true,
    "doc":
    "Uniform convergence on a set `s` to a constant function is equivalent to convergence in\n`p √óÀ¢ ùìü s`. ",
    "depth": 20}],
  "count": 24},
 {"noDocExamples":
  [{"type":
    "‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] [inst_1 : CategoryTheory.MonoidalCategory C] (X Y : C)\n  [inst_2 : CategoryTheory.ExactPairing X Y],\n  CategoryTheory.CategoryStruct.comp\n      (CategoryTheory.MonoidalCategory.tensorHom (Œ∑_ X Y) (CategoryTheory.CategoryStruct.id X))\n      (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.associator X Y X).hom\n        (CategoryTheory.MonoidalCategory.tensorHom (CategoryTheory.CategoryStruct.id X) (Œµ_ X Y))) =\n    CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.leftUnitor X).hom\n      (CategoryTheory.MonoidalCategory.rightUnitor X).inv",
    "name": "CategoryTheory.ExactPairing.evaluation_coevaluation",
    "isProp": true,
    "depth": 21},
   {"type":
    "‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] [inst_1 : CategoryTheory.MonoidalCategory C] {X Y : C}\n  [inst_2 : CategoryTheory.HasLeftDual X] [inst_3 : CategoryTheory.HasLeftDual Y] (f : X ‚ü∂ Y),\n  CategoryTheory.CategoryStruct.comp\n      (CategoryTheory.MonoidalCategory.tensorHom (CategoryTheory.CategoryStruct.id X) (·òÅf)) (Œµ_ (·òÅX) X) =\n    CategoryTheory.CategoryStruct.comp\n      (CategoryTheory.MonoidalCategory.tensorHom f (CategoryTheory.CategoryStruct.id ·òÅY)) (Œµ_ (·òÅY) Y)",
    "name": "CategoryTheory.leftAdjointMate_comp_evaluation",
    "isProp": true,
    "depth": 21}],
  "kind": "CategoryTheory.ExactPairing.termŒµ_",
  "examples":
  [{"type":
    "{C : Type u_1} ‚Üí\n  {D : Type u_2} ‚Üí\n    [inst : CategoryTheory.Category.{u_3, u_1} C] ‚Üí\n      [inst_1 : CategoryTheory.Category.{u_4, u_2} D] ‚Üí\n        [inst_2 : CategoryTheory.MonoidalCategory C] ‚Üí\n          [inst_3 : CategoryTheory.MonoidalCategory D] ‚Üí\n            (F : CategoryTheory.MonoidalFunctor C D) ‚Üí\n              [inst_4 : CategoryTheory.Faithful F.toFunctor] ‚Üí\n                {X Y : C} ‚Üí\n                  (eval :\n                      CategoryTheory.MonoidalCategory.tensorObj Y X ‚ü∂ CategoryTheory.MonoidalCategory.tensorUnit C) ‚Üí\n                    (coeval :\n                        CategoryTheory.MonoidalCategory.tensorUnit C ‚ü∂ CategoryTheory.MonoidalCategory.tensorObj X Y) ‚Üí\n                      [inst_5 : CategoryTheory.ExactPairing (F.obj X) (F.obj Y)] ‚Üí\n                        F.map eval =\n                            CategoryTheory.CategoryStruct.comp\n                              (CategoryTheory.inv (CategoryTheory.LaxMonoidalFunctor.Œº F.toLaxMonoidalFunctor Y X))\n                              (CategoryTheory.CategoryStruct.comp (Œµ_ (F.obj X) (F.obj Y)) F.Œµ) ‚Üí\n                          F.map coeval =\n                              CategoryTheory.CategoryStruct.comp (CategoryTheory.inv F.Œµ)\n                                (CategoryTheory.CategoryStruct.comp (Œ∑_ (F.obj X) (F.obj Y))\n                                  (CategoryTheory.LaxMonoidalFunctor.Œº F.toLaxMonoidalFunctor X Y)) ‚Üí\n                            CategoryTheory.ExactPairing X Y",
    "name": "CategoryTheory.exactPairingOfFaithful",
    "isProp": false,
    "doc":
    "Given candidate data for an exact pairing,\nwhich is sent by a faithful monoidal functor to an exact pairing,\nthe equations holds automatically. ",
    "depth": 34}],
  "count": 24},
 {"noDocExamples": [],
  "kind": "CategoryTheory.MonoidalOpposite.¬´term_·¥π·µí·µñ¬ª",
  "examples":
  [{"type": "{C : Type u‚ÇÅ} ‚Üí C·¥π·µí·µñ ‚Üí C",
    "name": "CategoryTheory.MonoidalOpposite.unmop",
    "isProp": false,
    "doc": "Think of an object of `C·¥π·µí·µñ` as an object of `C`. ",
    "depth": 3},
   {"type": "{C : Type u‚ÇÅ} ‚Üí C ‚Üí C·¥π·µí·µñ",
    "name": "CategoryTheory.MonoidalOpposite.mop",
    "isProp": false,
    "doc": "Think of an object of `C` as an object of `C·¥π·µí·µñ`. ",
    "depth": 3},
   {"type":
    "{C : Type u‚ÇÅ} ‚Üí\n  [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] ‚Üí\n    {X Y : C·¥π·µí·µñ} ‚Üí (X ‚ü∂ Y) ‚Üí (CategoryTheory.MonoidalOpposite.unmop X ‚ü∂ CategoryTheory.MonoidalOpposite.unmop Y)",
    "name": "Quiver.Hom.unmop",
    "isProp": false,
    "doc":
    "We can think of a morphism `f : mop X ‚ü∂ mop Y` as a morphism `X ‚ü∂ Y`. ",
    "depth": 12}],
  "count": 24},
 {"noDocExamples":
  [{"type":
    "‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] [inst_1 : CategoryTheory.MonoidalCategory C] {X Y : C}\n  [inst_2 : CategoryTheory.HasRightDual X] [inst_3 : CategoryTheory.HasRightDual Y] (f : X ‚ü∂ Y),\n  CategoryTheory.CategoryStruct.comp (Œ∑_ Y Y·òÅ)\n      (CategoryTheory.MonoidalCategory.tensorHom (CategoryTheory.CategoryStruct.id Y) (f·òÅ)) =\n    CategoryTheory.CategoryStruct.comp (Œ∑_ X X·òÅ)\n      (CategoryTheory.MonoidalCategory.tensorHom f (CategoryTheory.CategoryStruct.id X·òÅ))",
    "name": "CategoryTheory.coevaluation_comp_rightAdjointMate",
    "isProp": true,
    "depth": 20},
   {"type":
    "‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] [inst_1 : CategoryTheory.MonoidalCategory C] (X Y : C)\n  [inst_2 : CategoryTheory.ExactPairing X Y],\n  CategoryTheory.CategoryStruct.comp\n      (CategoryTheory.MonoidalCategory.tensorHom (Œ∑_ X Y) (CategoryTheory.CategoryStruct.id X))\n      (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.associator X Y X).hom\n        (CategoryTheory.MonoidalCategory.tensorHom (CategoryTheory.CategoryStruct.id X) (Œµ_ X Y))) =\n    CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.leftUnitor X).hom\n      (CategoryTheory.MonoidalCategory.rightUnitor X).inv",
    "name": "CategoryTheory.ExactPairing.evaluation_coevaluation",
    "isProp": true,
    "depth": 21}],
  "kind": "CategoryTheory.ExactPairing.termŒ∑_",
  "examples":
  [{"type":
    "{C : Type u_1} ‚Üí\n  {D : Type u_2} ‚Üí\n    [inst : CategoryTheory.Category.{u_3, u_1} C] ‚Üí\n      [inst_1 : CategoryTheory.Category.{u_4, u_2} D] ‚Üí\n        [inst_2 : CategoryTheory.MonoidalCategory C] ‚Üí\n          [inst_3 : CategoryTheory.MonoidalCategory D] ‚Üí\n            (F : CategoryTheory.MonoidalFunctor C D) ‚Üí\n              [inst_4 : CategoryTheory.Faithful F.toFunctor] ‚Üí\n                {X Y : C} ‚Üí\n                  (eval :\n                      CategoryTheory.MonoidalCategory.tensorObj Y X ‚ü∂ CategoryTheory.MonoidalCategory.tensorUnit C) ‚Üí\n                    (coeval :\n                        CategoryTheory.MonoidalCategory.tensorUnit C ‚ü∂ CategoryTheory.MonoidalCategory.tensorObj X Y) ‚Üí\n                      [inst_5 : CategoryTheory.ExactPairing (F.obj X) (F.obj Y)] ‚Üí\n                        F.map eval =\n                            CategoryTheory.CategoryStruct.comp\n                              (CategoryTheory.inv (CategoryTheory.LaxMonoidalFunctor.Œº F.toLaxMonoidalFunctor Y X))\n                              (CategoryTheory.CategoryStruct.comp (Œµ_ (F.obj X) (F.obj Y)) F.Œµ) ‚Üí\n                          F.map coeval =\n                              CategoryTheory.CategoryStruct.comp (CategoryTheory.inv F.Œµ)\n                                (CategoryTheory.CategoryStruct.comp (Œ∑_ (F.obj X) (F.obj Y))\n                                  (CategoryTheory.LaxMonoidalFunctor.Œº F.toLaxMonoidalFunctor X Y)) ‚Üí\n                            CategoryTheory.ExactPairing X Y",
    "name": "CategoryTheory.exactPairingOfFaithful",
    "isProp": false,
    "doc":
    "Given candidate data for an exact pairing,\nwhich is sent by a faithful monoidal functor to an exact pairing,\nthe equations holds automatically. ",
    "depth": 34}],
  "count": 24},
 {"noDocExamples":
  [{"type":
    "‚àÄ {R : Type u_1} [inst : Ring R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {U : Submodule R M}\n  {x : M}, x ‚â° x [SMOD U]",
    "name": "SModEq.rfl",
    "isProp": true,
    "depth": 15},
   {"type":
    "‚àÄ {R : Type u_1} [inst : Ring R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {U : Submodule R M}\n  (x : M), x ‚â° x [SMOD U]",
    "name": "SModEq.refl",
    "isProp": true,
    "depth": 15},
   {"type":
    "‚àÄ {R : Type u_4} [inst : CommRing R] {I : Ideal R} {x y : R},\n  x ‚â° y [SMOD I] ‚Üí ‚àÄ (f : Polynomial R), Polynomial.eval x f ‚â° Polynomial.eval y f [SMOD I]",
    "name": "SModEq.eval",
    "isProp": true,
    "depth": 16}],
  "kind": "¬´term_‚â°_[SMOD_]¬ª",
  "examples": [],
  "count": 23},
 {"noDocExamples": [],
  "kind": "Matrix.termGL",
  "examples":
  [{"type":
    "{n : Type u} ‚Üí\n  [inst : DecidableEq n] ‚Üí\n    [inst_1 : Fintype n] ‚Üí {R : Type v} ‚Üí [inst_2 : CommRing R] ‚Üí CoeFun (GL n R) fun x => n ‚Üí n ‚Üí R",
    "name": "Matrix.GeneralLinearGroup.instCoeFun",
    "isProp": false,
    "doc":
    "This instance is here for convenience, but is not the simp-normal form. ",
    "depth": 14},
   {"type":
    "{n : Type u} ‚Üí\n  [inst : DecidableEq n] ‚Üí\n    [inst_1 : Fintype n] ‚Üí {R : Type v} ‚Üí [inst_2 : CommRing R] ‚Üí Matrix.SpecialLinearGroup n R ‚Üí GL n R",
    "name": "Matrix.SpecialLinearGroup.coeToGL",
    "isProp": false,
    "doc":
    "The map from SL(n) to GL(n) underlying the coercion, forgetting the value of the determinant.\n",
    "depth": 14},
   {"type":
    "{n : Type u} ‚Üí\n  [inst : DecidableEq n] ‚Üí\n    [inst_1 : Fintype n] ‚Üí {R : Type v} ‚Üí [inst_2 : CommRing R] ‚Üí (A : Matrix n n R) ‚Üí IsUnit (Matrix.det A) ‚Üí GL n R",
    "name": "Matrix.GeneralLinearGroup.mk''",
    "isProp": false,
    "doc": "Given a matrix with unit determinant we get an element of `GL n R`",
    "depth": 17}],
  "count": 23},
 {"noDocExamples": [],
  "kind": "Complex.¬´term_√ó‚ÑÇ_¬ª",
  "examples":
  [{"type":
    "‚àÄ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚ÑÇ E] [inst_2 : CompleteSpace E] (f : ‚ÑÇ ‚Üí E)\n  (z w : ‚ÑÇ),\n  DifferentiableOn ‚ÑÇ f (Set.uIcc z.re w.re √ó‚ÑÇ Set.uIcc z.im w.im) ‚Üí\n    (((‚à´ (x : ‚Ñù) in z.re..w.re, f (‚Üëx + ‚Üëz.im * Complex.I)) - ‚à´ (x : ‚Ñù) in z.re..w.re, f (‚Üëx + ‚Üëw.im * Complex.I)) +\n          Complex.I ‚Ä¢ ‚à´ (y : ‚Ñù) in z.im..w.im, f (‚Üëw.re + ‚Üëy * Complex.I)) -\n        Complex.I ‚Ä¢ ‚à´ (y : ‚Ñù) in z.im..w.im, f (‚Üëz.re + ‚Üëy * Complex.I) =\n      0",
    "name": "Complex.integral_boundary_rect_eq_zero_of_differentiableOn",
    "isProp": true,
    "doc":
    "**Cauchy-Goursat theorem** for a rectangle: the integral of a complex differentiable function\nover the boundary of a rectangle equals zero. More precisely, if `f` is complex differentiable on a\nclosed rectangle, then its integral over the boundary of the rectangle equals zero. ",
    "depth": 29},
   {"type":
    "‚àÄ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚ÑÇ E] [inst_2 : CompleteSpace E] (f : ‚ÑÇ ‚Üí E)\n  (z w : ‚ÑÇ),\n  ContinuousOn f (Set.uIcc z.re w.re √ó‚ÑÇ Set.uIcc z.im w.im) ‚Üí\n    DifferentiableOn ‚ÑÇ f (Set.Ioo (min z.re w.re) (max z.re w.re) √ó‚ÑÇ Set.Ioo (min z.im w.im) (max z.im w.im)) ‚Üí\n      (((‚à´ (x : ‚Ñù) in z.re..w.re, f (‚Üëx + ‚Üëz.im * Complex.I)) - ‚à´ (x : ‚Ñù) in z.re..w.re, f (‚Üëx + ‚Üëw.im * Complex.I)) +\n            Complex.I ‚Ä¢ ‚à´ (y : ‚Ñù) in z.im..w.im, f (‚Üëw.re + ‚Üëy * Complex.I)) -\n          Complex.I ‚Ä¢ ‚à´ (y : ‚Ñù) in z.im..w.im, f (‚Üëz.re + ‚Üëy * Complex.I) =\n        0",
    "name":
    "Complex.integral_boundary_rect_eq_zero_of_continuousOn_of_differentiableOn",
    "isProp": true,
    "doc":
    "**Cauchy-Goursat theorem for a rectangle**: the integral of a complex differentiable function\nover the boundary of a rectangle equals zero. More precisely, if `f` is continuous on a closed\nrectangle and is complex differentiable on the corresponding open rectangle, then its integral over\nthe boundary of the rectangle equals zero. ",
    "depth": 30},
   {"type":
    "‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚ÑÇ E] {f : ‚ÑÇ ‚Üí E},\n  DiffContOnCl ‚ÑÇ f (Set.Iio 0 √ó‚ÑÇ Set.Iio 0) ‚Üí\n    (‚àÉ c,\n        c < 2 ‚àß\n          ‚àÉ B,\n            f =O[Filter.comap (‚ÜëComplex.abs) Filter.atTop ‚äì Filter.principal (Set.Iio 0 √ó‚ÑÇ Set.Iio 0)] fun z =>\n              rexp (B * ‚ÜëComplex.abs z ^ c)) ‚Üí\n      (‚àÄ (x : ‚Ñù), x ‚â§ 0 ‚Üí f ‚Üëx = 0) ‚Üí\n        (‚àÄ (x : ‚Ñù), x ‚â§ 0 ‚Üí f (‚Üëx * Complex.I) = 0) ‚Üí Set.EqOn f 0 {z | z.re ‚â§ 0 ‚àß z.im ‚â§ 0}",
    "name": "PhragmenLindelof.eq_zero_on_quadrant_III",
    "isProp": true,
    "doc":
    "**Phragmen-Lindel√∂f principle** in the third quadrant. Let `f : ‚ÑÇ ‚Üí E` be a function such that\n\n* `f` is differentiable in the open third quadrant and is continuous on its closure;\n* `‚Äñf z‚Äñ` is bounded from above by `A * exp(B * (abs z) ^ c)` on the open third quadrant\n  for some `A`, `B`, and `c < 2`;\n* `f` is equal to zero on the boundary of the third quadrant.\n\nThen `f` is equal to zero on the closed third quadrant. ",
    "depth": 31}],
  "count": 22},
 {"noDocExamples":
  [{"type":
    "‚àÄ {C : Type u} {X Y X' Y' : C} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.MonoidalCategory C]\n  (f : X ‚âÖ Y) (g : X' ‚âÖ Y'), (f ‚äó g).inv = CategoryTheory.MonoidalCategory.tensorHom f.inv g.inv",
    "name": "CategoryTheory.tensorIso_inv",
    "isProp": true,
    "depth": 21},
   {"type":
    "‚àÄ {C : Type u} {X Y X' Y' : C} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.MonoidalCategory C]\n  (f : X ‚âÖ Y) (g : X' ‚âÖ Y'), (f ‚äó g).hom = CategoryTheory.MonoidalCategory.tensorHom f.hom g.hom",
    "name": "CategoryTheory.tensorIso_hom",
    "isProp": true,
    "depth": 21},
   {"type":
    "‚àÄ {C : Type u_1} [inst : CategoryTheory.Category.{u_2, u_1} C] [inst_1 : CategoryTheory.MonoidalCategory C]\n  {W X Y Z : C} (f : W ‚ü∂ X) [inst_2 : CategoryTheory.IsIso f] (g : Y ‚ü∂ Z) [inst_3 : CategoryTheory.IsIso g],\n  CategoryTheory.IsIso (CategoryTheory.asIso f ‚äó CategoryTheory.asIso g).hom",
    "name": "CategoryTheory.MonoidalCategory.tensor_isIso.proof_1",
    "isProp": true,
    "depth": 22}],
  "kind": "CategoryTheory.¬´term_‚äó_¬ª",
  "examples": [],
  "count": 21},
 {"noDocExamples": [],
  "kind": "MeasureTheory.¬´term‚àÄ·µê_,_¬ª",
  "examples":
  [{"type":
    "‚àÄ (f : StieltjesFunction),\n  ‚àÄ·µê (x : ‚Ñù),\n    HasDerivAt (‚Üëf)\n      (ENNReal.toReal (MeasureTheory.Measure.rnDeriv (StieltjesFunction.measure f) MeasureTheory.volume x)) x",
    "name": "StieltjesFunction.ae_hasDerivAt",
    "isProp": true,
    "doc":
    "A Stieltjes function is almost everywhere differentiable, with derivative equal to the\nRadon-Nikodym derivative of the associated Stieltjes measure with respect to Lebesgue. ",
    "depth": 13},
   {"type":
    "‚àÄ {f : ‚Ñù ‚Üí ‚Ñù} (hf : Monotone f),\n  ‚àÄ·µê (x : ‚Ñù),\n    HasDerivAt f\n      (ENNReal.toReal\n        (MeasureTheory.Measure.rnDeriv (StieltjesFunction.measure (Monotone.stieltjesFunction hf)) MeasureTheory.volume\n          x))\n      x",
    "name": "Monotone.ae_hasDerivAt",
    "isProp": true,
    "doc":
    "A monotone function is almost everywhere differentiable, with derivative equal to the\nRadon-Nikodym derivative of the associated Stieltjes measure with respect to Lebesgue. ",
    "depth": 14},
   {"type": "‚àÄ {f : ‚Ñù ‚Üí ‚Ñù}, Monotone f ‚Üí ‚àÄ·µê (x : ‚Ñù), DifferentiableAt ‚Ñù f x",
    "name": "Monotone.ae_differentiableAt",
    "isProp": true,
    "doc":
    "A monotone real function is differentiable Lebesgue-almost everywhere. ",
    "depth": 16}],
  "count": 21},
 {"noDocExamples": [],
  "kind": "MeasureTheory.¬´term‚®ç‚Åª_,_‚àÇ_¬ª",
  "examples":
  [{"type":
    "‚àÄ {Œ± : Type u_1} {m0 : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {f : Œ± ‚Üí ENNReal},\n  Œº ‚â† 0 ‚Üí ‚à´‚Åª (a : Œ±), f a ‚àÇŒº ‚â† ‚ä§ ‚Üí ‚àÉ x, ‚®ç‚Åª (a : Œ±), f a ‚àÇŒº ‚â§ f x",
    "name": "MeasureTheory.exists_laverage_le",
    "isProp": true,
    "doc":
    "**First moment method**. The maximum of a measurable function is greater than its mean. ",
    "depth": 18},
   {"type":
    "‚àÄ {Œ± : Type u_1} {m0 : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {f : Œ± ‚Üí ENNReal}\n  [inst : MeasureTheory.IsFiniteMeasure Œº], Œº ‚â† 0 ‚Üí AEMeasurable f ‚Üí ‚àÉ x, f x ‚â§ ‚®ç‚Åª (a : Œ±), f a ‚àÇŒº",
    "name": "MeasureTheory.exists_le_laverage",
    "isProp": true,
    "doc":
    "**First moment method**. The minimum of a measurable function is smaller than its mean. ",
    "depth": 19},
   {"type":
    "‚àÄ {Œ± : Type u_1} {m0 : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {f : Œ± ‚Üí ENNReal},\n  Œº ‚â† 0 ‚Üí ‚à´‚Åª (a : Œ±), f a ‚àÇŒº ‚â† ‚ä§ ‚Üí 0 < ‚Üë‚ÜëŒº {x | ‚®ç‚Åª (a : Œ±), f a ‚àÇŒº ‚â§ f x}",
    "name": "MeasureTheory.measure_laverage_le_pos",
    "isProp": true,
    "doc":
    "**First moment method**. A measurable function is greater than its mean on a set of positive\nmeasure. ",
    "depth": 20}],
  "count": 20},
 {"noDocExamples":
  [{"type":
    "‚àÄ {Œ± : Type u_1} {a : Œ±} {n : ‚Ñï}, Sym.replicate (Nat.succ n) a = a ::‚Çõ Sym.replicate n a",
    "name": "Sym.replicate_succ",
    "isProp": true,
    "depth": 8},
   {"type":
    "‚àÄ {Œ± : Type u_1} {n : ‚Ñï} (a : Œ±) (v : Vector Œ± n), a ::‚Çõ Sym.ofVector v = Sym.ofVector (a ::·µ• v)",
    "name": "Sym.cons_of_coe_eq",
    "isProp": true,
    "depth": 10},
   {"type": "‚àÄ {Œ± : Type u_1} {n : ‚Ñï} (a : Œ±) (s : Sym Œ± n), a ‚àà a ::‚Çõ s",
    "name": "Sym.mem_cons_self",
    "isProp": true,
    "depth": 10}],
  "kind": "Sym.¬´term_::‚Çõ_¬ª",
  "examples": [],
  "count": 20},
 {"noDocExamples": [],
  "kind": "¬´term_‚ÜíL‚ãÜ[_]_¬ª",
  "examples":
  [{"type":
    "(ùïú : Type u_1) ‚Üí\n  {E : Type u_2} ‚Üí\n    [inst : IsROrC ùïú] ‚Üí [inst_1 : NormedAddCommGroup E] ‚Üí [inst_2 : InnerProductSpace ùïú E] ‚Üí E ‚ÜíL[ùïú] E ‚ÜíL‚ãÜ[ùïú] ùïú",
    "name": "innerSLFlip",
    "isProp": false,
    "doc":
    "The inner product as a continuous sesquilinear map, with the two arguments flipped. ",
    "depth": 29},
   {"type":
    "(ùïú : Type u_1) ‚Üí\n  {E : Type u_2} ‚Üí\n    [inst : IsROrC ùïú] ‚Üí [inst_1 : NormedAddCommGroup E] ‚Üí [inst_2 : InnerProductSpace ùïú E] ‚Üí E ‚ÜíL‚ãÜ[ùïú] E ‚ÜíL[ùïú] ùïú",
    "name": "innerSL",
    "isProp": false,
    "doc":
    "The inner product as a continuous sesquilinear map. Note that `toDualMap` (resp. `toDual`)\nin `InnerProductSpace.Dual` is a version of this given as a linear isometry (resp. linear\nisometric equivalence). ",
    "depth": 29},
   {"type":
    "{ùïú : Type u_1} ‚Üí\n  {E : Type u_2} ‚Üí\n    [inst : IsROrC ùïú] ‚Üí\n      [inst_1 : NormedAddCommGroup E] ‚Üí\n        [inst_2 : InnerProductSpace ùïú E] ‚Üí [inst_3 : CompleteSpace E] ‚Üí (E ‚ÜíL‚ãÜ[ùïú] E ‚ÜíL[ùïú] ùïú) ‚Üí E ‚ÜíL[ùïú] E",
    "name": "InnerProductSpace.continuousLinearMapOfBilin",
    "isProp": false,
    "doc":
    "Maps a bounded sesquilinear form to its continuous linear map,\ngiven by interpreting the form as a map `B : E ‚ÜíL‚ãÜ[ùïú] NormedSpace.Dual ùïú E`\nand dualizing the result using `toDual`.\n",
    "depth": 31}],
  "count": 19},
 {"noDocExamples": [],
  "kind": "Set.termùí´_",
  "examples":
  [{"type": "{Œ± : Type u_1} ‚Üí (S : Set Œ±) ‚Üí ‚Üë(ùí´ S) ‚âÉ Set ‚ÜëS",
    "name": "Equiv.Set.powerset",
    "isProp": false,
    "doc": "The set `ùí´ S := {x | x ‚äÜ S}` is equivalent to the type `Set S`. ",
    "depth": 7},
   {"type": "‚àÄ {Œ± : Type u} (x : Œ±), ùí´{x} = {‚àÖ, {x}}",
    "name": "Set.powerset_singleton",
    "isProp": true,
    "doc":
    "The powerset of a singleton contains only `‚àÖ` and the singleton itself. ",
    "depth": 9},
   {"type":
    "‚àÄ {Œ± : Type u_1} (s : Set Œ±) (a : Œ±), ùí´ insert a s = ùí´ s ‚à™ insert a '' ùí´ s",
    "name": "Set.powerset_insert",
    "isProp": true,
    "doc":
    "The powerset of `{a} ‚à™ s` is `ùí´ s` together with `{a} ‚à™ t` for each `t ‚àà ùí´ s`. ",
    "depth": 11}],
  "count": 18},
 {"noDocExamples": [],
  "kind": "MeasureTheory.¬´term‚®ç‚Åª_In_,_‚àÇ_¬ª",
  "examples":
  [{"type":
    "‚àÄ {Œ± : Type u_1} {m0 : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {s : Set Œ±} {f : Œ± ‚Üí ENNReal},\n  ‚Üë‚ÜëŒº s ‚â† 0 ‚Üí ‚Üë‚ÜëŒº s ‚â† ‚ä§ ‚Üí AEMeasurable f ‚Üí ‚àÉ x, x ‚àà s ‚àß f x ‚â§ ‚®ç‚Åª (a : Œ±) in s, f a ‚àÇŒº",
    "name": "MeasureTheory.exists_le_setLaverage",
    "isProp": true,
    "doc":
    "**First moment method**. The minimum of a measurable function is smaller than its mean. ",
    "depth": 21},
   {"type":
    "‚àÄ {Œ± : Type u_1} {m0 : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {s : Set Œ±} {f : Œ± ‚Üí ENNReal},\n  ‚Üë‚ÜëŒº s ‚â† 0 ‚Üí\n    MeasureTheory.NullMeasurableSet s ‚Üí ‚à´‚Åª (a : Œ±) in s, f a ‚àÇŒº ‚â† ‚ä§ ‚Üí ‚àÉ x, x ‚àà s ‚àß ‚®ç‚Åª (a : Œ±) in s, f a ‚àÇŒº ‚â§ f x",
    "name": "MeasureTheory.exists_setLaverage_le",
    "isProp": true,
    "doc":
    "**First moment method**. The maximum of a measurable function is greater than its mean. ",
    "depth": 21},
   {"type":
    "‚àÄ {Œ± : Type u_1} {m0 : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {s : Set Œ±} {f : Œ± ‚Üí ENNReal},\n  ‚Üë‚ÜëŒº s ‚â† 0 ‚Üí\n    MeasureTheory.NullMeasurableSet s ‚Üí\n      ‚à´‚Åª (a : Œ±) in s, f a ‚àÇŒº ‚â† ‚ä§ ‚Üí 0 < ‚Üë‚ÜëŒº {x | x ‚àà s ‚àß ‚®ç‚Åª (a : Œ±) in s, f a ‚àÇŒº ‚â§ f x}",
    "name": "MeasureTheory.measure_setLaverage_le_pos",
    "isProp": true,
    "doc":
    "**First moment method**. A measurable function is greater than its mean on a set of positive\nmeasure. ",
    "depth": 23}],
  "count": 18},
 {"noDocExamples": [],
  "kind": "CategoryTheory.¬´term_‚•§‚Çë_¬ª",
  "examples":
  [{"type":
    "(C : Type u‚ÇÅ) ‚Üí\n  [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] ‚Üí\n    (D : Type u‚ÇÇ) ‚Üí [inst_1 : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D] ‚Üí CategoryTheory.Functor (C ‚•§‚Çë D) (C ‚•§‚Çó D)",
    "name": "CategoryTheory.LeftExactFunctor.ofExact",
    "isProp": false,
    "doc": "Turn an exact functor into a left exact functor. ",
    "depth": 12},
   {"type":
    "{C : Type u‚ÇÅ} ‚Üí\n  [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] ‚Üí\n    {D : Type u‚ÇÇ} ‚Üí\n      [inst_1 : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D] ‚Üí\n        (F : CategoryTheory.Functor C D) ‚Üí\n          [inst_2 : CategoryTheory.Limits.PreservesFiniteLimits F] ‚Üí\n            [inst_3 : CategoryTheory.Limits.PreservesFiniteColimits F] ‚Üí C ‚•§‚Çë D",
    "name": "CategoryTheory.ExactFunctor.of",
    "isProp": false,
    "doc":
    "Turn an exact functor into an object of the category `ExactFunctor C D`. ",
    "depth": 12},
   {"type":
    "(C : Type u‚ÇÅ) ‚Üí\n  [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] ‚Üí\n    (D : Type u‚ÇÇ) ‚Üí\n      [inst_1 : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D] ‚Üí CategoryTheory.Functor (C ‚•§‚Çë D) (CategoryTheory.Functor C D)",
    "name": "CategoryTheory.ExactFunctor.forget",
    "isProp": false,
    "doc": "An exact functor is in particular a functor. ",
    "depth": 12}],
  "count": 18},
 {"noDocExamples": [],
  "kind": "¬´term_‚äá_¬ª",
  "examples":
  [{"type":
    "‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {Œπ : Type v} [hŒπ : Nonempty Œπ] (Z : Œπ ‚Üí Set Œ±),\n  Directed (fun x x_1 => x ‚äá x_1) Z ‚Üí\n    (‚àÄ (i : Œπ), Set.Nonempty (Z i)) ‚Üí\n      (‚àÄ (i : Œπ), IsCompact (Z i)) ‚Üí (‚àÄ (i : Œπ), IsClosed (Z i)) ‚Üí Set.Nonempty (‚ãÇ (i : Œπ), Z i)",
    "name": "IsCompact.nonempty_iInter_of_directed_nonempty_compact_closed",
    "isProp": true,
    "doc":
    "Cantor's intersection theorem:\nthe intersection of a directed family of nonempty compact closed sets is nonempty. ",
    "depth": 15},
   {"type":
    "‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {Œπ : Type u_3} [inst_1 : Nonempty Œπ] {V : Œπ ‚Üí Set Œ±},\n  Directed (fun x x_1 => x ‚äá x_1) V ‚Üí\n    (‚àÄ (i : Œπ), IsCompact (V i)) ‚Üí\n      (‚àÄ (i : Œπ), IsClosed (V i)) ‚Üí ‚àÄ {U : Set Œ±}, (‚àÄ (x : Œ±), x ‚àà ‚ãÇ (i : Œπ), V i ‚Üí U ‚àà nhds x) ‚Üí ‚àÉ i, V i ‚äÜ U",
    "name": "exists_subset_nhds_of_isCompact'",
    "isProp": true,
    "doc":
    "If `V : Œπ ‚Üí Set Œ±` is a decreasing family of closed compact sets then any neighborhood of\n`‚ãÇ i, V i` contains some `V i`. We assume each `V i` is compact *and* closed because `Œ±` is\nnot assumed to be Hausdorff. See `exists_subset_nhd_of_compact` for version assuming this. ",
    "depth": 18},
   {"type":
    "‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : T2Space Œ±] {Œπ : Type u_2} [inst_2 : Nonempty Œπ] {V : Œπ ‚Üí Set Œ±},\n  Directed (fun x x_1 => x ‚äá x_1) V ‚Üí\n    (‚àÄ (i : Œπ), IsCompact (V i)) ‚Üí ‚àÄ {U : Set Œ±}, (‚àÄ (x : Œ±), x ‚àà ‚ãÇ (i : Œπ), V i ‚Üí U ‚àà nhds x) ‚Üí ‚àÉ i, V i ‚äÜ U",
    "name": "exists_subset_nhds_of_isCompact",
    "isProp": true,
    "doc":
    "If `V : Œπ ‚Üí Set Œ±` is a decreasing family of compact sets then any neighborhood of\n`‚ãÇ i, V i` contains some `V i`. This is a version of `exists_subset_nhds_of_isCompact'` where we\ndon't need to assume each `V i` closed because it follows from compactness since `Œ±` is\nassumed to be Hausdorff. ",
    "depth": 18}],
  "count": 17},
 {"noDocExamples": [],
  "kind": "CategoryTheory.LaxMonoidalFunctor.¬´term_‚äó‚ãô_¬ª",
  "examples":
  [{"type":
    "{C : Type u‚ÇÅ} ‚Üí\n  [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] ‚Üí\n    [inst_1 : CategoryTheory.MonoidalCategory C] ‚Üí\n      {D : Type u‚ÇÇ} ‚Üí\n        [inst_2 : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D] ‚Üí\n          (e : C ‚âå D) ‚Üí\n            CategoryTheory.LaxMonoidalFunctor.id C ‚âÖ\n              CategoryTheory.Monoidal.laxToTransported e ‚äó‚ãô\n                (CategoryTheory.Monoidal.fromTransported e).toLaxMonoidalFunctor",
    "name": "CategoryTheory.Monoidal.transportedMonoidalUnitIso",
    "isProp": false,
    "doc": "The unit isomorphism upgrades to a monoidal isomorphism. ",
    "depth": 20},
   {"type":
    "{C : Type u‚ÇÅ} ‚Üí\n  [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] ‚Üí\n    [inst_1 : CategoryTheory.MonoidalCategory C] ‚Üí\n      {D : Type u‚ÇÇ} ‚Üí\n        [inst_2 : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D] ‚Üí\n          [inst_3 : CategoryTheory.MonoidalCategory D] ‚Üí\n            (F : CategoryTheory.MonoidalFunctor C D) ‚Üí\n              [inst_4 : CategoryTheory.IsEquivalence F.toFunctor] ‚Üí\n                CategoryTheory.LaxMonoidalFunctor.id C ‚ü∂\n                  F.toLaxMonoidalFunctor ‚äó‚ãô (CategoryTheory.monoidalInverse F).toLaxMonoidalFunctor",
    "name": "CategoryTheory.monoidalUnit",
    "isProp": false,
    "doc":
    "The unit of a monoidal equivalence can be upgraded to a monoidal natural transformation. ",
    "depth": 20},
   {"type":
    "{C : Type u‚ÇÅ} ‚Üí\n  [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] ‚Üí\n    [inst_1 : CategoryTheory.MonoidalCategory C] ‚Üí\n      {D : Type u‚ÇÇ} ‚Üí\n        [inst_2 : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D] ‚Üí\n          [inst_3 : CategoryTheory.MonoidalCategory D] ‚Üí\n            (F : CategoryTheory.MonoidalFunctor C D) ‚Üí\n              [inst_4 : CategoryTheory.IsEquivalence F.toFunctor] ‚Üí\n                (CategoryTheory.monoidalInverse F).toLaxMonoidalFunctor ‚äó‚ãô F.toLaxMonoidalFunctor ‚ü∂\n                  CategoryTheory.LaxMonoidalFunctor.id D",
    "name": "CategoryTheory.monoidalCounit",
    "isProp": false,
    "doc":
    "The counit of a monoidal equivalence can be upgraded to a monoidal natural transformation. ",
    "depth": 21}],
  "count": 17},
 {"noDocExamples":
  [{"type":
    "{C : Type u‚ÇÅ} ‚Üí\n  [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] ‚Üí\n    [inst_1 : CategoryTheory.MonoidalCategory C] ‚Üí\n      {X : C} ‚Üí [inst_2 : CategoryTheory.HasLeftDual X] ‚Üí CategoryTheory.HasRightDual ·òÅX",
    "name": "CategoryTheory.hasRightDualLeftDual",
    "isProp": false,
    "depth": 11},
   {"type":
    "{C : Type u‚ÇÅ} ‚Üí\n  [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] ‚Üí\n    [inst_1 : CategoryTheory.MonoidalCategory C] ‚Üí\n      {Y : C} ‚Üí [self : CategoryTheory.HasLeftDual Y] ‚Üí CategoryTheory.ExactPairing (·òÅY) Y",
    "name": "CategoryTheory.HasLeftDual.exact",
    "isProp": false,
    "depth": 12}],
  "kind": "CategoryTheory.¬´term·òÅ_¬ª",
  "examples":
  [{"type":
    "{C : Type u‚ÇÅ} ‚Üí\n  [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] ‚Üí\n    [inst_1 : CategoryTheory.MonoidalCategory C] ‚Üí\n      {X Y : C} ‚Üí\n        [inst_2 : CategoryTheory.HasLeftDual X] ‚Üí [inst_3 : CategoryTheory.HasLeftDual Y] ‚Üí (X ‚ü∂ Y) ‚Üí (·òÅY ‚ü∂ ·òÅX)",
    "name": "CategoryTheory.leftAdjointMate",
    "isProp": false,
    "doc": "The left adjoint mate `·òÅf : ·òÅY ‚ü∂ ·òÅX` of a morphism `f : X ‚ü∂ Y`. ",
    "depth": 15}],
  "count": 16},
 {"noDocExamples": [],
  "kind": "¬´term#[_,]¬ª",
  "examples":
  [{"type":
    "Lean.Name ‚Üí\n  List (Bool √ó Lean.Expr) ‚Üí\n    optParam (Array Lean.Expr) #[] ‚Üí optParam (Array Lean.Expr) #[] ‚Üí Lean.Elab.TermElabM Lean.Expr",
    "name": "Mathlib.Deriving.Traversable.traverseConstructor.mkFunCtor",
    "isProp": false,
    "doc":
    "`mkFunCtor ctor [(true, (arg‚ÇÅ : m type‚ÇÅ)), (false, (arg‚ÇÇ : type‚ÇÇ)), (true, (arg‚ÇÉ : m type‚ÇÉ)),\n(false, (arg‚ÇÑ : type‚ÇÑ))]` makes `fun (x‚ÇÅ : type‚ÇÅ) (x‚ÇÉ : type‚ÇÉ) => ctor x‚ÇÅ arg‚ÇÇ x‚ÇÉ arg‚ÇÑ`. ",
    "depth": 7},
   {"type":
    "Lean.Expr ‚Üí Lean.Meta.FunInfo ‚Üí optParam Bool false ‚Üí optParam (Array Bool) #[] ‚Üí Lean.MetaM (Lean.Expr √ó Lean.Expr)",
    "name": "Congr!.mkHCongrThm",
    "isProp": false,
    "doc":
    "Create a congruence lemma to prove that `HEq (f a‚ÇÅ ... a‚Çô) (f' a‚ÇÅ' ... a‚Çô')`.\nEach argument produces a `HEq a·µ¢ a·µ¢'` hypothesis, but we also supply these hypotheses the\nhypotheses that the preceding equalities have been proved (unlike in `mkHCongrWithArity`).\nThe first two arguments of the resulting theorem are for `f` and `f'`, followed by a proof\nof `f = f'`.\n\nWhen including hypotheses about previous hypotheses, we make use of dependency information\nand only include relevant equalities.\n\nThe argument `fty` denotes the type of `f`. Returns `(congrThmType, congrThmProof)`.\n\nFor the purpose of generating nicer lemmas that have a better chance at something like\n`to_additive` rewriting, this function supports generating lemmas where certain parameters\nare meant to be fixed.\n\n* If `fixedFun` is `false` (the default) then the lemma starts with three arguments for `f`, `f'`,\nand `h : f = f'`. Otherwise, if `fixedFun` is `true` then the lemma starts with just `f`.\n\n* If the `fixedParams` argument has `true` for a particular argument index, then this is a hint\nthat the congruence lemma may use the same parameter for both sides of the equality. There is\nno guarantee -- it respects it if the types are equal for that parameter (i.e., if the parameter\ndoes not depend on non-fixed parameters).\n",
    "depth": 7},
   {"type":
    "Lean.Syntax ‚Üí\n  Lean.Name ‚Üí\n    optParam Bool false ‚Üí\n      optParam (Array Simps.ProjectionRule) #[] ‚Üí\n        optParam Bool false ‚Üí Lean.CoreM (List Lean.Name √ó Array Simps.ProjectionData)",
    "name": "Simps.getRawProjections",
    "isProp": false,
    "doc":
    "Get the projections used by `simps` associated to a given structure `str`.\n\nThe returned information is also stored in the environment extension `Simps.structureExt`, which\nis given to `str`. If `str` already has this attribute, the information is read from this\nextension instead. See the documentation for this extension for the data this tactic returns.\n\nThe returned universe levels are the universe levels of the structure. For the projections there\nare three cases\n* If the declaration `{StructureName}.Simps.{projectionName}` has been declared, then the value\n  of this declaration is used (after checking that it is definitionally equal to the actual\n  projection. If you rename the projection name, the declaration should have the *new* projection\n  name.\n* You can also declare a custom projection that is a composite of multiple projections.\n* Otherwise, for every class with the `notation_class` attribute, and the structure has an\n  instance of that notation class, then the projection of that notation class is used for the\n  projection that is definitionally equal to it (if there is such a projection).\n  This means in practice that coercions to function types and sorts will be used instead of\n  a projection, if this coercion is definitionally equal to a projection. Furthermore, for\n  notation classes like `Mul` and `Zero` those projections are used instead of the\n  corresponding projection.\n  Projections for coercions and notation classes are not automatically generated if they are\n  composites of multiple projections (for example when you use `extend` without the\n  `oldStructureCmd` (does this exist?)).\n* Otherwise, the projection of the structure is chosen.\n  For example: ``getRawProjections env `Prod`` gives the default projections.\n```\n  ([u, v], [(`fst, `(Prod.fst.{u v}), [0], true, false),\n     (`snd, `(@Prod.snd.{u v}), [1], true, false)])\n```\n\nOptionally, this command accepts three optional arguments:\n* If `traceIfExists` the command will always generate a trace message when the structure already\n  has an entry in `structureExt`.\n* The `rules` argument specifies whether projections should be added, renamed, used as prefix, and\n  not used by default.\n* if `trc` is true, this tactic will trace information just as if\n  `set_option trace.simps.verbose true` was set.\n",
    "depth": 9}],
  "count": 16},
 {"noDocExamples":
  [{"type":
    "{C : Type u‚ÇÅ} ‚Üí\n  [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] ‚Üí\n    [inst_1 : CategoryTheory.MonoidalCategory C] ‚Üí\n      {X : C} ‚Üí [inst_2 : CategoryTheory.HasRightDual X] ‚Üí CategoryTheory.HasLeftDual X·òÅ",
    "name": "CategoryTheory.hasLeftDualRightDual",
    "isProp": false,
    "depth": 11},
   {"type":
    "{C : Type u‚ÇÅ} ‚Üí\n  [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] ‚Üí\n    [inst_1 : CategoryTheory.MonoidalCategory C] ‚Üí\n      {X : C} ‚Üí [self : CategoryTheory.HasRightDual X] ‚Üí CategoryTheory.ExactPairing X X·òÅ",
    "name": "CategoryTheory.HasRightDual.exact",
    "isProp": false,
    "depth": 11}],
  "kind": "CategoryTheory.¬´term_·òÅ¬ª",
  "examples":
  [{"type":
    "{C : Type u‚ÇÅ} ‚Üí\n  [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] ‚Üí\n    [inst_1 : CategoryTheory.MonoidalCategory C] ‚Üí\n      {X Y : C} ‚Üí\n        [inst_2 : CategoryTheory.HasRightDual X] ‚Üí [inst_3 : CategoryTheory.HasRightDual Y] ‚Üí (X ‚ü∂ Y) ‚Üí (Y·òÅ ‚ü∂ X·òÅ)",
    "name": "CategoryTheory.rightAdjointMate",
    "isProp": false,
    "doc": "The right adjoint mate `f·òÅ : X·òÅ ‚ü∂ Y·òÅ` of a morphism `f : X ‚ü∂ Y`. ",
    "depth": 15}],
  "count": 16},
 {"noDocExamples": [],
  "kind": "Bundle.¬´term_*·µñ_¬ª",
  "examples":
  [{"type":
    "{B : Type u_1} ‚Üí\n  {F : Type u_2} ‚Üí\n    {E : B ‚Üí Type u_3} ‚Üí {B' : Type u_4} ‚Üí (f : B' ‚Üí B) ‚Üí Bundle.TotalSpace F (f *·µñ E) ‚Üí B' √ó Bundle.TotalSpace F E",
    "name": "Bundle.pullbackTotalSpaceEmbedding",
    "isProp": false,
    "doc":
    "Natural embedding of the total space of `f *·µñ E` into `B' √ó TotalSpace F E`. ",
    "depth": 11},
   {"type":
    "{B : Type u_1} ‚Üí\n  {F : Type u_2} ‚Üí\n    {E : B ‚Üí Type u_3} ‚Üí {B' : Type u_4} ‚Üí (f : B' ‚Üí B) ‚Üí Bundle.TotalSpace F (f *·µñ E) ‚Üí Bundle.TotalSpace F E",
    "name": "Bundle.Pullback.lift",
    "isProp": false,
    "doc":
    "The base map `f : B' ‚Üí B` lifts to a canonical map on the total spaces. ",
    "depth": 11},
   {"type":
    "{B : Type u} ‚Üí\n  (F : Type v) ‚Üí\n    (E : B ‚Üí Type w‚ÇÅ) ‚Üí\n      {B' : Type w‚ÇÇ} ‚Üí\n        (f : B' ‚Üí B) ‚Üí\n          [inst : TopologicalSpace B'] ‚Üí\n            [inst : TopologicalSpace (Bundle.TotalSpace F E)] ‚Üí TopologicalSpace (Bundle.TotalSpace F (f *·µñ E))",
    "name": "Pullback.TotalSpace.topologicalSpace",
    "isProp": false,
    "doc":
    "The topology on the total space of a pullback bundle is the coarsest topology for which both\nthe projections to the base and the map to the original bundle are continuous. ",
    "depth": 13}],
  "count": 16},
 {"noDocExamples":
  [{"type":
    "‚àÄ {L : FirstOrder.Language} {T : FirstOrder.Language.Theory L} {œÜ : FirstOrder.Language.Sentence L}, œÜ ‚àà T ‚Üí T ‚ä®·µá œÜ",
    "name": "FirstOrder.Language.Theory.models_sentence_of_mem",
    "isProp": true,
    "depth": 10},
   {"type":
    "‚àÄ {L : FirstOrder.Language} {T : FirstOrder.Language.Theory L},\n  FirstOrder.Language.Theory.IsMaximal T ‚Üí ‚àÄ {œÜ : FirstOrder.Language.Sentence L}, T ‚ä®·µá œÜ ‚Üí œÜ ‚àà T",
    "name": "FirstOrder.Language.Theory.IsMaximal.mem_of_models",
    "isProp": true,
    "depth": 11}],
  "kind": "FirstOrder.Language.Theory.¬´term_‚ä®·µá_¬ª",
  "examples":
  [{"type":
    "‚àÄ {L : FirstOrder.Language} {T : FirstOrder.Language.Theory L} {œÜ : FirstOrder.Language.Sentence L},\n  T ‚ä®·µá œÜ ‚Üî ‚àÉ T0, ‚ÜëT0 ‚äÜ T ‚àß ‚ÜëT0 ‚ä®·µá œÜ",
    "name": "FirstOrder.Language.Theory.models_iff_finset_models",
    "isProp": true,
    "doc":
    "An alternative statement of the Compactness Theorem. A formula `œÜ` is modeled by a\ntheory iff there is a finite subset `T0` of the theory such that `œÜ` is modeled by `T0` ",
    "depth": 14}],
  "count": 14},
 {"noDocExamples":
  [{"type": "‚àÄ (m : ‚Ñï), m <<< 0 = m",
    "name": "Nat.shiftLeft_zero",
    "isProp": true,
    "depth": 9},
   {"type": "‚àÄ (n : ‚Ñï), 0 <<< n = 0",
    "name": "Nat.zero_shiftLeft",
    "isProp": true,
    "depth": 9}],
  "kind": "¬´term_<<<_¬ª",
  "examples":
  [{"type": "‚àÄ (m n : ‚Ñï), Nat.shiftLeft m n = m <<< n",
    "name": "Nat.shiftLeft_eq'",
    "isProp": true,
    "doc":
    "Std4 takes the unprimed name for `Nat.shiftLeft_eq m n : m <<< n = m * 2 ^ n`. ",
    "depth": 9}],
  "count": 14},
 {"noDocExamples":
  [{"type": "‚àÄ {Œ± : Type u_1} [inst : Primcodable Œ±] (p : Œ± ‚Üí Prop), p ‚â§‚ÇÄ p",
    "name": "manyOneReducible_refl",
    "isProp": true,
    "depth": 9},
   {"type":
    "‚àÄ {Œ± : Type u} [inst : Primcodable Œ±] [inst_1 : Inhabited Œ±] {p : Set Œ±}, p ‚â§‚ÇÄ toNat p",
    "name": "manyOneReducible_toNat",
    "isProp": true,
    "depth": 10},
   {"type":
    "‚àÄ {Œ± : Type u} [inst : Primcodable Œ±] [inst_1 : Inhabited Œ±] {p : Set Œ±}, toNat p ‚â§‚ÇÄ p",
    "name": "toNat_manyOneReducible",
    "isProp": true,
    "depth": 10}],
  "kind": "¬´term_‚â§‚ÇÄ_¬ª",
  "examples": [],
  "count": 14},
 {"noDocExamples":
  [{"type": "‚àÄ {Œ± : Type u_1} (a : Array Œ±) (i : ‚Ñï), Array.get? a i = a[i]?",
    "name": "Array.get?_eq_getElem?",
    "isProp": true,
    "depth": 15},
   {"type":
    "‚àÄ {Œ± : Type u_1} (a : Array Œ±) (i : ‚Ñï), a[i]? = List.get? a.data i",
    "name": "Array.getElem?_eq_data_get?",
    "isProp": true,
    "depth": 16},
   {"type": "‚àÄ {Œ± : Type u_1} (l : List Œ±) (i : ‚Ñï), l[i]? = List.get? l i",
    "name": "List.getElem?_eq_get?",
    "isProp": true,
    "depth": 16}],
  "kind": "¬´term__[_]_?¬ª",
  "examples": [],
  "count": 14},
 {"noDocExamples":
  [{"type":
    "‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] [inst_1 : CategoryTheory.MonoidalCategory C] {X : C}\n  [inst_2 : CategoryTheory.HasRightDual X], CategoryTheory.CategoryStruct.id X·òÅ = CategoryTheory.CategoryStruct.id X·òÅ",
    "name": "CategoryTheory.rightAdjointMate_id",
    "isProp": true,
    "depth": 15},
   {"type":
    "‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] [inst_1 : CategoryTheory.MonoidalCategory C] {X Y : C}\n  [inst_2 : CategoryTheory.HasRightDual X] [inst_3 : CategoryTheory.HasRightDual Y] (f : X ‚ü∂ Y),\n  CategoryTheory.CategoryStruct.comp (Œ∑_ Y Y·òÅ)\n      (CategoryTheory.MonoidalCategory.tensorHom (CategoryTheory.CategoryStruct.id Y) (f·òÅ)) =\n    CategoryTheory.CategoryStruct.comp (Œ∑_ X X·òÅ)\n      (CategoryTheory.MonoidalCategory.tensorHom f (CategoryTheory.CategoryStruct.id X·òÅ))",
    "name": "CategoryTheory.coevaluation_comp_rightAdjointMate",
    "isProp": true,
    "depth": 20}],
  "kind": "CategoryTheory.¬´term_·òÅ_1¬ª",
  "examples":
  [{"type":
    "‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] [inst_1 : CategoryTheory.MonoidalCategory C] {X Y Z : C}\n  [inst_2 : CategoryTheory.HasRightDual X] [inst_3 : CategoryTheory.HasRightDual Y]\n  [inst_4 : CategoryTheory.HasRightDual Z] {f : X ‚ü∂ Y} {g : Y ‚ü∂ Z},\n  CategoryTheory.CategoryStruct.comp f g·òÅ = CategoryTheory.CategoryStruct.comp (g·òÅ) (f·òÅ)",
    "name": "CategoryTheory.comp_rightAdjointMate",
    "isProp": true,
    "doc":
    "The composition of right adjoint mates is the adjoint mate of the composition. ",
    "depth": 22}],
  "count": 13},
 {"noDocExamples":
  [{"type":
    "‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] [inst_1 : CategoryTheory.MonoidalCategory C] {X : C}\n  [inst_2 : CategoryTheory.HasLeftDual X], (·òÅCategoryTheory.CategoryStruct.id X) = CategoryTheory.CategoryStruct.id ·òÅX",
    "name": "CategoryTheory.leftAdjointMate_id",
    "isProp": true,
    "depth": 15},
   {"type":
    "‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] [inst_1 : CategoryTheory.MonoidalCategory C] {X Y : C}\n  [inst_2 : CategoryTheory.HasLeftDual X] [inst_3 : CategoryTheory.HasLeftDual Y] (f : X ‚ü∂ Y),\n  CategoryTheory.CategoryStruct.comp\n      (CategoryTheory.MonoidalCategory.tensorHom (CategoryTheory.CategoryStruct.id X) (·òÅf)) (Œµ_ (·òÅX) X) =\n    CategoryTheory.CategoryStruct.comp\n      (CategoryTheory.MonoidalCategory.tensorHom f (CategoryTheory.CategoryStruct.id ·òÅY)) (Œµ_ (·òÅY) Y)",
    "name": "CategoryTheory.leftAdjointMate_comp_evaluation",
    "isProp": true,
    "depth": 21}],
  "kind": "CategoryTheory.¬´term·òÅ__1¬ª",
  "examples":
  [{"type":
    "‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] [inst_1 : CategoryTheory.MonoidalCategory C] {X Y Z : C}\n  [inst_2 : CategoryTheory.HasLeftDual X] [inst_3 : CategoryTheory.HasLeftDual Y]\n  [inst_4 : CategoryTheory.HasLeftDual Z] {f : X ‚ü∂ Y} {g : Y ‚ü∂ Z},\n  (·òÅCategoryTheory.CategoryStruct.comp f g) = CategoryTheory.CategoryStruct.comp (·òÅg) (·òÅf)",
    "name": "CategoryTheory.comp_leftAdjointMate",
    "isProp": true,
    "doc":
    "The composition of left adjoint mates is the adjoint mate of the composition. ",
    "depth": 22}],
  "count": 13},
 {"noDocExamples":
  [{"type": "‚àÄ {x : ZFSet}, ZFSet.IsTransitive x ‚Üí ZFSet.IsTransitive (‚ãÉ‚ÇÄ x)",
    "name": "ZFSet.IsTransitive.sUnion",
    "isProp": true,
    "depth": 4},
   {"type": "‚àÄ (x : ZFSet), ‚Üë(‚ãÉ‚ÇÄ x) = ‚ãÉ‚ÇÄ ‚Üëx",
    "name": "Class.coe_sUnion",
    "isProp": true,
    "depth": 5}],
  "kind": "ZFSet.¬´term‚ãÉ‚ÇÄ_¬ª",
  "examples":
  [{"type": "‚àÄ {x : ZFSet}, ZFSet.IsTransitive x ‚Üí ‚ãÉ‚ÇÄ x ‚äÜ x",
    "name": "ZFSet.IsTransitive.sUnion_subset",
    "isProp": true,
    "doc":
    "**Alias** of the forward direction of `ZFSet.isTransitive_iff_sUnion_subset`.",
    "depth": 6}],
  "count": 12},
 {"noDocExamples":
  [{"type": "‚àÄ (m n : ‚Ñï), Nat.shiftRight m n = m >>> n",
    "name": "Nat.shiftRight_eq",
    "isProp": true,
    "depth": 9},
   {"type": "‚àÄ (n : ‚Ñï), 0 >>> n = 0",
    "name": "Nat.zero_shiftRight",
    "isProp": true,
    "depth": 9},
   {"type": "‚àÄ {n : ‚Ñï}, n >>> 0 = n",
    "name": "Nat.shiftRight_zero",
    "isProp": true,
    "depth": 9}],
  "kind": "¬´term_>>>_¬ª",
  "examples": [],
  "count": 12},
 {"noDocExamples":
  [{"type": "‚àÄ (a : Cardinal.{u_1}), Monotone fun c => a ^< c",
    "name": "Cardinal.powerlt_mono_left",
    "isProp": true,
    "depth": 6},
   {"type":
    "‚àÄ {c : Cardinal.{u_1}}, Cardinal.aleph0 ‚â§ c ‚Üí c ^< Cardinal.aleph0 = c",
    "name": "Cardinal.powerlt_aleph0",
    "isProp": true,
    "depth": 6},
   {"type":
    "‚àÄ (c : Cardinal.{u_1}), c ^< Cardinal.aleph0 ‚â§ max c Cardinal.aleph0",
    "name": "Cardinal.powerlt_aleph0_le",
    "isProp": true,
    "depth": 7}],
  "kind": "Cardinal.¬´term_^<_¬ª",
  "examples": [],
  "count": 11},
 {"noDocExamples":
  [{"type":
    "‚àÄ {x y : CategoryTheory.Limits.WalkingParallelFamily (ULift.{w, 0} Bool)} (h : x ‚ü∂ y),\n  CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair.functor.map h =\n    match x, y, h with\n    | x, .(x), CategoryTheory.Limits.WalkingParallelFamily.Hom.id .(x) =>\n      CategoryTheory.CategoryStruct.id\n        (CategoryTheory.Limits.WalkingParallelFamily.rec CategoryTheory.Limits.WalkingParallelPair.zero\n          CategoryTheory.Limits.WalkingParallelPair.one x)\n    | .(CategoryTheory.Limits.WalkingParallelFamily.zero), .(CategoryTheory.Limits.WalkingParallelFamily.one),\n      CategoryTheory.Limits.WalkingParallelFamily.Hom.line j =>\n      bif j.down then CategoryTheory.Limits.WalkingParallelPairHom.left\n      else CategoryTheory.Limits.WalkingParallelPairHom.right",
    "name":
    "CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair_functor_map",
    "isProp": true,
    "depth": 22},
   {"type":
    "‚àÄ {X Y : CategoryTheory.Limits.WalkingParallelPair} (h : X ‚ü∂ Y),\n  CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair.inverse.map h =\n    match X, Y, h with\n    | x, .(x), CategoryTheory.Limits.WalkingParallelPairHom.id .(x) =>\n      CategoryTheory.CategoryStruct.id\n        (match x with\n        | CategoryTheory.Limits.WalkingParallelPair.zero => CategoryTheory.Limits.WalkingParallelFamily.zero\n        | CategoryTheory.Limits.WalkingParallelPair.one => CategoryTheory.Limits.WalkingParallelFamily.one)\n    | .(CategoryTheory.Limits.WalkingParallelPair.zero), .(CategoryTheory.Limits.WalkingParallelPair.one),\n      CategoryTheory.Limits.WalkingParallelPairHom.left =>\n      CategoryTheory.Limits.WalkingParallelFamily.Hom.line { down := true }\n    | .(CategoryTheory.Limits.WalkingParallelPair.zero), .(CategoryTheory.Limits.WalkingParallelPair.one),\n      CategoryTheory.Limits.WalkingParallelPairHom.right =>\n      CategoryTheory.Limits.WalkingParallelFamily.Hom.line { down := false }",
    "name":
    "CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair_inverse_map",
    "isProp": true,
    "depth": 23},
   {"type":
    "‚àÄ {Œπ Œ± : Type u_1} (U : Œπ ‚Üí Œ±) [inst : SemilatticeInf Œ±] (X : CategoryTheory.Pairwise Œπ),\n  (match X, X, CategoryTheory.CategoryStruct.id X with\n    | .(CategoryTheory.Pairwise.single i), .(CategoryTheory.Pairwise.single i),\n      CategoryTheory.Pairwise.Hom.id_single i => CategoryTheory.CategoryStruct.id (U i)\n    | .(CategoryTheory.Pairwise.pair i j), .(CategoryTheory.Pairwise.pair i j),\n      CategoryTheory.Pairwise.Hom.id_pair i j => CategoryTheory.CategoryStruct.id (U i ‚äì U j)\n    | .(CategoryTheory.Pairwise.pair i j), .(CategoryTheory.Pairwise.single i), CategoryTheory.Pairwise.Hom.left i j =>\n      CategoryTheory.homOfLE (_ : U i ‚äì U j ‚â§ U i)\n    | .(CategoryTheory.Pairwise.pair i j), .(CategoryTheory.Pairwise.single j), CategoryTheory.Pairwise.Hom.right i j =>\n      CategoryTheory.homOfLE (_ : U i ‚äì U j ‚â§ U j)) =\n    CategoryTheory.CategoryStruct.id\n      (match X with\n      | CategoryTheory.Pairwise.single i => U i\n      | CategoryTheory.Pairwise.pair i j => U i ‚äì U j)",
    "name": "CategoryTheory.Pairwise.diagram.proof_1",
    "isProp": true,
    "depth": 28}],
  "kind": "Lean.Parser.Term.inaccessible",
  "examples": [],
  "count": 11},
 {"noDocExamples": [],
  "kind": "¬´term‚àØ_InT(_,_),_¬ª",
  "examples":
  [{"type":
    "‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚ÑÇ E] (f : (Fin 1 ‚Üí ‚ÑÇ) ‚Üí E) (c : Fin 1 ‚Üí ‚ÑÇ)\n  (R : Fin 1 ‚Üí ‚Ñù), (‚àØ (x : Fin 1 ‚Üí ‚ÑÇ) in T(c, R), f x) = ‚àÆ (z : ‚ÑÇ) in C(c 0, R 0), f fun x => z",
    "name": "torusIntegral_dim1",
    "isProp": true,
    "doc":
    "In dimension one, `torusIntegral` is the same as `circleIntegral`\n(up to the natural equivalence between `‚ÑÇ` and `Fin 1 ‚Üí ‚ÑÇ`). ",
    "depth": 18},
   {"type":
    "‚àÄ {n : ‚Ñï} {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚ÑÇ E] {f : (Fin n ‚Üí ‚ÑÇ) ‚Üí E} {c : Fin n ‚Üí ‚ÑÇ}\n  {R : Fin n ‚Üí ‚Ñù} {C : ‚Ñù},\n  (‚àÄ (Œ∏ : Fin n ‚Üí ‚Ñù), ‚Äñf (torusMap c R Œ∏)‚Äñ ‚â§ C) ‚Üí\n    ‚Äñ‚àØ (x : Fin n ‚Üí ‚ÑÇ) in T(c, R), f x‚Äñ ‚â§ ((2 * Real.pi) ^ n * Finset.prod Finset.univ fun i => |R i|) * C",
    "name": "norm_torusIntegral_le_of_norm_le_const",
    "isProp": true,
    "doc":
    "If for all `Œ∏ : ‚Ñù‚Åø`, `‚Äñf (torusMap c R Œ∏)‚Äñ` is less than or equal to a constant `C : ‚Ñù`, then\n`‚Äñ‚àØ x in T(c, R), f x‚Äñ` is less than or equal to `(2 * œÄ)^n * (‚àè i, |R i|) * C`",
    "depth": 24},
   {"type":
    "‚àÄ {n : ‚Ñï} {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚ÑÇ E] [inst_2 : CompleteSpace E]\n  {f : (Fin (n + 1) ‚Üí ‚ÑÇ) ‚Üí E} {c : Fin (n + 1) ‚Üí ‚ÑÇ} {R : Fin (n + 1) ‚Üí ‚Ñù},\n  TorusIntegrable f c R ‚Üí\n    (‚àØ (x : Fin (n + 1) ‚Üí ‚ÑÇ) in T(c, R), f x) =\n      ‚àÆ (x : ‚ÑÇ) in C(c 0, R 0), ‚àØ (y : Fin n ‚Üí ‚ÑÇ) in T(c ‚àò Fin.succ, R ‚àò Fin.succ), f (Fin.cons x y)",
    "name": "torusIntegral_succ",
    "isProp": true,
    "doc":
    "Recurrent formula for `torusIntegral`, see also `torusIntegral_succAbove`. ",
    "depth": 30}],
  "count": 11},
 {"noDocExamples":
  [{"type": "‚àÄ {Œ± : Type u_1} [inst : Primcodable Œ±] (p : Œ± ‚Üí Prop), p ‚â§‚ÇÅ p",
    "name": "oneOneReducible_refl",
    "isProp": true,
    "depth": 9},
   {"type":
    "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Primcodable Œ±] [inst_1 : Primcodable Œ≤] {p : Œ± ‚Üí Prop} {q : Œ≤ ‚Üí Prop},\n  p ‚â§‚ÇÅ Sum.elim p q",
    "name": "OneOneReducible.disjoin_left",
    "isProp": true,
    "depth": 13},
   {"type":
    "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Primcodable Œ±] [inst_1 : Primcodable Œ≤] {p : Œ± ‚Üí Prop} {q : Œ≤ ‚Üí Prop},\n  p ‚â§‚ÇÅ q ‚Üí p ‚â§‚ÇÄ q",
    "name": "OneOneReducible.to_many_one",
    "isProp": true,
    "depth": 13}],
  "kind": "¬´term_‚â§‚ÇÅ_¬ª",
  "examples": [],
  "count": 11},
 {"noDocExamples": [],
  "kind": "CategoryTheory.¬´term_‚•§‚Çó_¬ª",
  "examples":
  [{"type":
    "{C : Type u‚ÇÅ} ‚Üí\n  [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] ‚Üí\n    {D : Type u‚ÇÇ} ‚Üí\n      [inst_1 : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D] ‚Üí\n        (F : CategoryTheory.Functor C D) ‚Üí [inst_2 : CategoryTheory.Limits.PreservesFiniteLimits F] ‚Üí C ‚•§‚Çó D",
    "name": "CategoryTheory.LeftExactFunctor.of",
    "isProp": false,
    "doc":
    "Turn a left exact functor into an object of the category `LeftExactFunctor C D`. ",
    "depth": 11},
   {"type":
    "(C : Type u‚ÇÅ) ‚Üí\n  [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] ‚Üí\n    (D : Type u‚ÇÇ) ‚Üí [inst_1 : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D] ‚Üí CategoryTheory.Functor (C ‚•§‚Çë D) (C ‚•§‚Çó D)",
    "name": "CategoryTheory.LeftExactFunctor.ofExact",
    "isProp": false,
    "doc": "Turn an exact functor into a left exact functor. ",
    "depth": 12},
   {"type":
    "(C : Type u‚ÇÅ) ‚Üí\n  [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] ‚Üí\n    (D : Type u‚ÇÇ) ‚Üí\n      [inst_1 : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D] ‚Üí CategoryTheory.Functor (C ‚•§‚Çó D) (CategoryTheory.Functor C D)",
    "name": "CategoryTheory.LeftExactFunctor.forget",
    "isProp": false,
    "doc": "A left exact functor is in particular a functor. ",
    "depth": 12}],
  "count": 11},
 {"noDocExamples": [],
  "kind": "CategoryTheory.¬´term_‚•§·µ£_¬ª",
  "examples":
  [{"type":
    "{C : Type u‚ÇÅ} ‚Üí\n  [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] ‚Üí\n    {D : Type u‚ÇÇ} ‚Üí\n      [inst_1 : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D] ‚Üí\n        (F : CategoryTheory.Functor C D) ‚Üí [inst_2 : CategoryTheory.Limits.PreservesFiniteColimits F] ‚Üí C ‚•§·µ£ D",
    "name": "CategoryTheory.RightExactFunctor.of",
    "isProp": false,
    "doc":
    "Turn a right exact functor into an object of the category `RightExactFunctor C D`. ",
    "depth": 11},
   {"type":
    "(C : Type u‚ÇÅ) ‚Üí\n  [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] ‚Üí\n    (D : Type u‚ÇÇ) ‚Üí\n      [inst_1 : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D] ‚Üí CategoryTheory.Functor (C ‚•§·µ£ D) (CategoryTheory.Functor C D)",
    "name": "CategoryTheory.RightExactFunctor.forget",
    "isProp": false,
    "doc": "A right exact functor is in particular a functor. ",
    "depth": 12},
   {"type":
    "(C : Type u‚ÇÅ) ‚Üí\n  [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] ‚Üí\n    (D : Type u‚ÇÇ) ‚Üí [inst_1 : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D] ‚Üí CategoryTheory.Functor (C ‚•§‚Çë D) (C ‚•§·µ£ D)",
    "name": "CategoryTheory.RightExactFunctor.ofExact",
    "isProp": false,
    "doc": "Turn an exact functor into a left exact functor. ",
    "depth": 12}],
  "count": 11},
 {"noDocExamples":
  [{"type":
    "‚àÄ {U : Type u_1} [inst : Quiver U] [inst_1 : Quiver.HasReverse U], Prefunctor.MapReverse (ùü≠q U)",
    "name": "Prefunctor.mapReverseId",
    "isProp": true,
    "depth": 10},
   {"type":
    "‚àÄ {U : Type u_1} [inst : Quiver U] [inst_1 : Quiver.HasReverse U], Prefunctor.MapReverse (ùü≠q U)",
    "name": "Prefunctor.mapReverseId.proof_1",
    "isProp": true,
    "depth": 10},
   {"type":
    "‚àÄ {V : Type u} [inst : Quiver V],\n  CategoryTheory.freeGroupoidFunctor (ùü≠q V) = CategoryTheory.Functor.id (CategoryTheory.FreeGroupoid V)",
    "name": "CategoryTheory.Groupoid.Free.freeGroupoidFunctor_id",
    "isProp": true,
    "depth": 11}],
  "kind": "Prefunctor.¬´termùü≠q¬ª",
  "examples": [],
  "count": 11},
 {"noDocExamples":
  [{"type": "‚àÄ {Œ± : Type u} (s : Stream' Œ±), [] ++‚Çõ s = s",
    "name": "Stream'.nil_append_stream",
    "isProp": true,
    "depth": 7},
   {"type":
    "‚àÄ {Œ± : Type u} (l : List Œ±) (h : l ‚â† []), Stream'.cycle l h = l ++‚Çõ Stream'.cycle l h",
    "name": "Stream'.cycle_eq",
    "isProp": true,
    "depth": 8},
   {"type":
    "‚àÄ {Œ± : Type u} (l : List Œ±) (s : Stream' Œ±), ‚Üë(l ++‚Çõ s) = Stream'.Seq.append ‚Üël ‚Üës",
    "name": "Stream'.Seq.ofStream_append",
    "isProp": true,
    "depth": 9}],
  "kind": "Stream'.¬´term_++‚Çõ_¬ª",
  "examples": [],
  "count": 11},
 {"noDocExamples": [],
  "kind": "CategoryTheory.¬´term_‚•§+_¬ª",
  "examples":
  [{"type":
    "{C : Type u_1} ‚Üí\n  {D : Type u_2} ‚Üí\n    [inst : CategoryTheory.Category.{u_3, u_1} C] ‚Üí\n      [inst_1 : CategoryTheory.Category.{u_4, u_2} D] ‚Üí\n        [inst_2 : CategoryTheory.Preadditive C] ‚Üí\n          [inst_3 : CategoryTheory.Preadditive D] ‚Üí\n            (F : CategoryTheory.Functor C D) ‚Üí [inst_4 : CategoryTheory.Functor.Additive F] ‚Üí C ‚•§+ D",
    "name": "CategoryTheory.AdditiveFunctor.of",
    "isProp": false,
    "doc":
    "Turn an additive functor into an object of the category `AdditiveFunctor C D`. ",
    "depth": 15},
   {"type":
    "(C : Type u_1) ‚Üí\n  (D : Type u_2) ‚Üí\n    [inst : CategoryTheory.Category.{u_3, u_1} C] ‚Üí\n      [inst_1 : CategoryTheory.Category.{u_4, u_2} D] ‚Üí\n        [inst_2 : CategoryTheory.Preadditive C] ‚Üí\n          [inst_3 : CategoryTheory.Preadditive D] ‚Üí CategoryTheory.Functor (C ‚•§+ D) (CategoryTheory.Functor C D)",
    "name": "CategoryTheory.AdditiveFunctor.forget",
    "isProp": false,
    "doc": "An additive functor is in particular a functor. ",
    "depth": 16},
   {"type":
    "(C : Type u‚ÇÅ) ‚Üí\n  (D : Type u‚ÇÇ) ‚Üí\n    [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] ‚Üí\n      [inst_1 : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D] ‚Üí\n        [inst_2 : CategoryTheory.Preadditive C] ‚Üí\n          [inst_3 : CategoryTheory.Preadditive D] ‚Üí\n            [inst_4 : CategoryTheory.Limits.HasZeroObject C] ‚Üí\n              [inst_5 : CategoryTheory.Limits.HasZeroObject D] ‚Üí\n                [inst_6 : CategoryTheory.Limits.HasBinaryBiproducts C] ‚Üí CategoryTheory.Functor (C ‚•§‚Çó D) (C ‚•§+ D)",
    "name": "CategoryTheory.AdditiveFunctor.ofLeftExact",
    "isProp": false,
    "doc": "Turn a left exact functor into an additive functor. ",
    "depth": 17}],
  "count": 11},
 {"noDocExamples": [],
  "kind": "MeasureTheory.¬´term‚à´‚Åª_In_,_¬ª",
  "examples":
  [{"type":
    "‚àÄ (t : ‚Ñù) (f : UnitAddCircle ‚Üí ENNReal), ‚à´‚Åª (a : ‚Ñù) in Set.Ioc t (t + 1), f ‚Üëa = ‚à´‚Åª (b : UnitAddCircle), f b",
    "name": "UnitAddCircle.lintegral_preimage",
    "isProp": true,
    "doc":
    "The integral of a measurable function over `UnitAddCircle` is equal to the integral over an\ninterval (t, t + 1] in `‚Ñù` of its lift to `‚Ñù`. ",
    "depth": 15},
   {"type":
    "‚àÄ (T : ‚Ñù) [hT : Fact (0 < T)] (t : ‚Ñù) (f : AddCircle T ‚Üí ENNReal),\n  ‚à´‚Åª (a : ‚Ñù) in Set.Ioc t (t + T), f ‚Üëa = ‚à´‚Åª (b : AddCircle T), f b",
    "name": "AddCircle.lintegral_preimage",
    "isProp": true,
    "doc":
    "The lower integral of a function over `AddCircle T` is equal to the lower integral over an\ninterval (t, t + T] in `‚Ñù` of its lift to `‚Ñù`. ",
    "depth": 17},
   {"type":
    "‚àÄ {Œ± : Type u_1} [inst : MeasurableSpace Œ±] {f : Œ± ‚Üí ‚Ñù} (Œº : MeasureTheory.Measure Œ±)\n  [inst_1 : MeasureTheory.SigmaFinite Œº],\n  0 ‚â§ f ‚Üí Measurable f ‚Üí ‚à´‚Åª (œâ : Œ±), ENNReal.ofReal (f œâ) ‚àÇŒº = ‚à´‚Åª (t : ‚Ñù) in Set.Ioi 0, ‚Üë‚ÜëŒº {a | t < f a}",
    "name": "lintegral_eq_lintegral_meas_lt",
    "isProp": true,
    "doc":
    "The standard case of the layer cake formula / Cavalieri's principle / tail probability formula:\n\nFor a nonnegative function `f` on a sigma-finite measure space, the Lebesgue integral of `f` can\nbe written (roughly speaking) as: `‚à´‚Åª f ‚àÇŒº = ‚à´‚Åª t in (0).. ‚àû, Œº {œâ | f(œâ) > t}`.\n\nSee `lintegral_eq_lintegral_meas_le` for a version with sets of the form `{œâ | f(œâ) ‚â• t}`\ninstead. ",
    "depth": 17}],
  "count": 10},
 {"noDocExamples":
  [{"type":
    "‚àÄ {Œ± : Type u} (s‚ÇÅ : Stream' Œ±), Stream'.even s‚ÇÅ ‚ãà Stream'.odd s‚ÇÅ = s‚ÇÅ",
    "name": "Stream'.interleave_even_odd",
    "isProp": true,
    "depth": 8},
   {"type":
    "‚àÄ {Œ± : Type u} (s‚ÇÅ s‚ÇÇ : Stream' Œ±), Stream'.tail s‚ÇÅ ‚ãà Stream'.tail s‚ÇÇ = Stream'.tail (Stream'.tail (s‚ÇÅ ‚ãà s‚ÇÇ))",
    "name": "Stream'.interleave_tail_tail",
    "isProp": true,
    "depth": 9},
   {"type":
    "‚àÄ {Œ± : Type u} (s‚ÇÅ s‚ÇÇ : Stream' Œ±), Stream'.tail (s‚ÇÅ ‚ãà s‚ÇÇ) = s‚ÇÇ ‚ãà Stream'.tail s‚ÇÅ",
    "name": "Stream'.tail_interleave",
    "isProp": true,
    "depth": 9}],
  "kind": "Stream'.¬´term_‚ãà_¬ª",
  "examples": [],
  "count": 9},
 {"noDocExamples":
  [{"type":
    "‚àÄ {R : Type u_1} {M : Type u_2} [inst : CommSemiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (x : M),\n  ‚ÜëTensorAlgebra.toDirectSum (‚Üë(TensorAlgebra.Œπ R) x) =\n    ‚Üë(DirectSum.of (fun n => TensorPower R n M) 1) (‚®Ç‚Çú[R] (x_1 : Fin 1), x)",
    "name": "TensorAlgebra.toDirectSum_Œπ",
    "isProp": true,
    "depth": 39},
   {"type":
    "‚àÄ {Œπ : Type u_1} {Œπ‚ÇÇ : Type u_2} {R : Type u_4} [inst : CommSemiring R] {M : Type u_8} [inst_1 : AddCommMonoid M]\n  [inst_2 : Module R M] (e : Œπ ‚âÉ Œπ‚ÇÇ) (f : Œπ ‚Üí M),\n  ‚Üë(PiTensorProduct.reindex R M e) (‚Üë(PiTensorProduct.tprod R) f) = ‚®Ç‚Çú[R] (i : Œπ‚ÇÇ), f (‚Üëe.symm i)",
    "name": "PiTensorProduct.reindex_tprod",
    "isProp": true,
    "depth": 43}],
  "kind": "PiTensorProduct.¬´term‚®Ç‚Çú[_]_,_¬ª",
  "examples":
  [{"type":
    "‚àÄ {R : Type u_1} {M : Type u_2} [inst : CommSemiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (n : ‚Ñï)\n  (x : Fin n ‚Üí M),\n  List.prod (List.map (fun a => GradedMonoid.mk 1 (‚®Ç‚Çú[R] (x_1 : Fin 1), x a)) (List.finRange n)) =\n    GradedMonoid.mk n (‚Üë(PiTensorProduct.tprod R) x)",
    "name": "TensorPower.list_prod_gradedMonoid_mk_single",
    "isProp": true,
    "doc":
    "The product of tensor products made of a single vector is the same as a single product of\nall the vectors. ",
    "depth": 36}],
  "count": 7},
 {"noDocExamples":
  [{"type": "‚ãÇ‚ÇÄ ‚àÖ = ‚àÖ",
    "name": "ZFSet.sInter_empty",
    "isProp": true,
    "depth": 5},
   {"type": "‚àÄ {x : ZFSet}, ZFSet.Nonempty x ‚Üí ‚Üë(‚ãÇ‚ÇÄ x) = ‚ãÇ‚ÇÄ ‚Üëx",
    "name": "Class.coe_sInter",
    "isProp": true,
    "depth": 6},
   {"type": "‚àÄ {x : ZFSet}, ‚ãÇ‚ÇÄ {x} = x",
    "name": "ZFSet.sInter_singleton",
    "isProp": true,
    "depth": 8}],
  "kind": "ZFSet.¬´term‚ãÇ‚ÇÄ_¬ª",
  "examples": [],
  "count": 7},
 {"noDocExamples": [],
  "kind": "¬´term_‚âÉ‚Çó·µ¢‚ãÜ[_]_¬ª",
  "examples":
  [{"type":
    "(ùïú : Type u_1) ‚Üí\n  {E : Type u_2} ‚Üí\n    [inst : CommSemiring ùïú] ‚Üí\n      [inst_1 : StarRing ùïú] ‚Üí\n        [inst_2 : SeminormedAddCommGroup E] ‚Üí\n          [inst_3 : StarAddMonoid E] ‚Üí\n            [inst_4 : NormedStarGroup E] ‚Üí [inst_5 : Module ùïú E] ‚Üí [inst_6 : StarModule ùïú E] ‚Üí E ‚âÉ‚Çó·µ¢‚ãÜ[ùïú] E",
    "name": "star‚Çó·µ¢",
    "isProp": false,
    "doc": "`star` bundled as a linear isometric equivalence ",
    "depth": 23},
   {"type":
    "(ùïú : Type u_1) ‚Üí\n  (E : Type u_2) ‚Üí\n    [inst : IsROrC ùïú] ‚Üí\n      [inst_1 : NormedAddCommGroup E] ‚Üí\n        [inst_2 : InnerProductSpace ùïú E] ‚Üí [inst_3 : CompleteSpace E] ‚Üí E ‚âÉ‚Çó·µ¢‚ãÜ[ùïú] NormedSpace.Dual ùïú E",
    "name": "InnerProductSpace.toDual",
    "isProp": false,
    "doc":
    "Fr√©chet-Riesz representation: any `‚Ñì` in the dual of a Hilbert space `E` is of the form\n`fun u => ‚ü™y, u‚ü´` for some `y : E`, i.e. `toDualMap` is surjective.\n",
    "depth": 25},
   {"type":
    "‚àÄ {M : Type u} [inst : NormedRing M] [inst_1 : StarRing M] [inst_2 : CstarRing M] [inst_3 : Module ‚ÑÇ M]\n  [inst_4 : NormedAlgebra ‚ÑÇ M] [inst_5 : StarModule ‚ÑÇ M] [self : WStarAlgebra M],\n  ‚àÉ X x x_1 x_2, Nonempty (NormedSpace.Dual ‚ÑÇ X ‚âÉ‚Çó·µ¢‚ãÜ[‚ÑÇ] M)",
    "name": "WStarAlgebra.exists_predual",
    "isProp": true,
    "doc":
    "There is a Banach space `X` whose dual is isometrically (conjugate-linearly) isomorphic\nto the `WStarAlgebra`. ",
    "depth": 31}],
  "count": 5},
 {"noDocExamples":
  [{"type":
    "‚àÄ {Œ© : Type u_1} [inst : MeasureTheory.MeasureSpace Œ©]\n  [inst_1 : MeasureTheory.IsProbabilityMeasure MeasureTheory.volume] {X : Œ© ‚Üí ‚Ñù},\n  MeasureTheory.AEStronglyMeasurable X MeasureTheory.volume ‚Üí\n    ProbabilityTheory.evariance X MeasureTheory.volume =\n      (‚à´‚Åª (œâ : Œ©), ‚Üë(‚ÄñX œâ‚Äñ‚Çä ^ 2)) - ENNReal.ofReal ((‚à´ (a : Œ©), X a) ^ 2)",
    "name": "ProbabilityTheory.evariance_def'",
    "isProp": true,
    "depth": 22}],
  "kind": "MeasureTheory.¬´term‚à´‚Åª_,_¬ª",
  "examples":
  [{"type":
    "‚àÄ (t : ‚Ñù) (f : UnitAddCircle ‚Üí ENNReal), ‚à´‚Åª (a : ‚Ñù) in Set.Ioc t (t + 1), f ‚Üëa = ‚à´‚Åª (b : UnitAddCircle), f b",
    "name": "UnitAddCircle.lintegral_preimage",
    "isProp": true,
    "doc":
    "The integral of a measurable function over `UnitAddCircle` is equal to the integral over an\ninterval (t, t + 1] in `‚Ñù` of its lift to `‚Ñù`. ",
    "depth": 15},
   {"type":
    "‚àÄ (T : ‚Ñù) [hT : Fact (0 < T)] (t : ‚Ñù) (f : AddCircle T ‚Üí ENNReal),\n  ‚à´‚Åª (a : ‚Ñù) in Set.Ioc t (t + T), f ‚Üëa = ‚à´‚Åª (b : AddCircle T), f b",
    "name": "AddCircle.lintegral_preimage",
    "isProp": true,
    "doc":
    "The lower integral of a function over `AddCircle T` is equal to the lower integral over an\ninterval (t, t + T] in `‚Ñù` of its lift to `‚Ñù`. ",
    "depth": 17}],
  "count": 5},
 {"noDocExamples":
  [{"type":
    "‚àÄ {Œ± : Type u} [inst : Lattice Œ±] [inst_1 : AddGroup Œ±] (a : Œ±), |(-a)| = |a|",
    "name": "LatticeOrderedGroup.abs_neg",
    "isProp": true,
    "depth": 15}],
  "kind": "Lean.Parser.Term.paren",
  "examples":
  [{"type":
    "‚àÄ {Œ± : Type u} [inst : Lattice Œ±] [inst_1 : AddGroup Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun x x_1 => x + x_1) fun x x_1 => x ‚â§ x_1]\n  [inst_3 : CovariantClass Œ± Œ± (Function.swap fun x x_1 => x + x_1) fun x x_1 => x ‚â§ x_1] (a : Œ±), |(|a|)| = |a|",
    "name": "LatticeOrderedGroup.abs_abs",
    "isProp": true,
    "doc": "The unary operation of taking the absolute value is idempotent.",
    "depth": 19},
   {"type":
    "‚àÄ {Œ± : Type u} [inst : Lattice Œ±] [inst_1 : Group Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun x x_1 => x * x_1) fun x x_1 => x ‚â§ x_1]\n  [inst_3 : CovariantClass Œ± Œ± (Function.swap fun x x_1 => x * x_1) fun x x_1 => x ‚â§ x_1] (a : Œ±), |(|a|)| = |a|",
    "name": "LatticeOrderedGroup.mabs_mabs",
    "isProp": true,
    "doc": "The unary operation of taking the absolute value is idempotent. ",
    "depth": 19}],
  "count": 5},
 {"noDocExamples":
  [{"type":
    "‚àÄ {Œ± : Type u_1} [inst : MeasurableSpace Œ±] {Œº : MeasureTheory.Measure Œ±} {p : Œ± ‚Üí Prop},\n  (‚àÉ·µê (a : Œ±) ‚àÇŒº, p a) ‚Üî ‚Üë‚ÜëŒº {a | p a} ‚â† 0",
    "name": "MeasureTheory.frequently_ae_iff",
    "isProp": true,
    "depth": 12},
   {"type":
    "‚àÄ {Œ± : Type u_1} [inst : MeasurableSpace Œ±] {Œº : MeasureTheory.Measure Œ±} {s : Set Œ±},\n  (‚àÉ·µê (a : Œ±) ‚àÇŒº, a ‚àà s) ‚Üî ‚Üë‚ÜëŒº s ‚â† 0",
    "name": "MeasureTheory.frequently_ae_mem_iff",
    "isProp": true,
    "depth": 14}],
  "kind": "MeasureTheory.¬´term‚àÉ·µê_‚àÇ_,_¬ª",
  "examples":
  [{"type":
    "‚àÄ {Œ± : Type u_2} [inst : MeasurableSpace Œ±] {f : Œ± ‚Üí Œ±} {s : Set Œ±} {Œº : MeasureTheory.Measure Œ±},\n  MeasureTheory.Conservative f Œº ‚Üí\n    MeasurableSet s ‚Üí ‚Üë‚ÜëŒº s ‚â† 0 ‚Üí ‚àÉ·µê (x : Œ±) ‚àÇŒº, x ‚àà s ‚àß ‚àÉ·∂† (n : ‚Ñï) in Filter.atTop, f^[n] x ‚àà s",
    "name":
    "MeasureTheory.Conservative.frequently_ae_mem_and_frequently_image_mem",
    "isProp": true,
    "doc":
    "If `f` is a conservative self-map and `s` is a measurable set of positive measure, then\n`Œº.ae`-frequently we have `x ‚àà s` and `s` returns to `s` under infinitely many iterations of `f`. ",
    "depth": 21}],
  "count": 5},
 {"noDocExamples":
  [{"type": "‚ãÇ‚ÇÄ ‚àÖ = Class.univ",
    "name": "Class.sInter_empty",
    "isProp": true,
    "depth": 5},
   {"type": "‚àÄ {x : ZFSet}, ZFSet.Nonempty x ‚Üí ‚Üë(‚ãÇ‚ÇÄ x) = ‚ãÇ‚ÇÄ ‚Üëx",
    "name": "Class.coe_sInter",
    "isProp": true,
    "depth": 6},
   {"type": "‚àÄ {x : Class} {y : ZFSet}, (‚ãÇ‚ÇÄ x) y ‚Üî ‚àÄ (z : ZFSet), x z ‚Üí y ‚àà z",
    "name": "Class.sInter_apply",
    "isProp": true,
    "depth": 10}],
  "kind": "Class.¬´term‚ãÇ‚ÇÄ_¬ª",
  "examples": [],
  "count": 5},
 {"noDocExamples":
  [{"type": "‚àÄ {Œ± : Type u} (s : Stream' Œ±), Stream'.pure id ‚äõ s = s",
    "name": "Stream'.identity",
    "isProp": true,
    "depth": 9},
   {"type":
    "‚àÄ {Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Œ≤) (s : Stream' Œ±), Stream'.map f s = Stream'.pure f ‚äõ s",
    "name": "Stream'.map_eq_apply",
    "isProp": true,
    "depth": 10},
   {"type":
    "‚àÄ {Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Œ≤) (a : Œ±), Stream'.pure f ‚äõ Stream'.pure a = Stream'.pure (f a)",
    "name": "Stream'.homomorphism",
    "isProp": true,
    "depth": 11}],
  "kind": "Stream'.¬´term_‚äõ_¬ª",
  "examples": [],
  "count": 5},
 {"noDocExamples":
  [{"type":
    "‚àÄ {m : Type u ‚Üí Type v} [inst : Monad m] [inst_1 : LawfulMonad m] {Œ± : Type u_1} {Œ≤ : Type u} (f : Œ± ‚Üí m Œ≤),\n  f >=> pure = f",
    "name": "fish_pure",
    "isProp": true,
    "depth": 15},
   {"type":
    "‚àÄ (m : Type u_1 ‚Üí Type u_1) [inst : Monad m] [inst_1 : LawfulMonad m] {X Y : CategoryTheory.KleisliCat m} (f : X ‚ü∂ Y),\n  f >=> pure = pure >=> f",
    "name": "CategoryTheory.eq.proof_5",
    "isProp": true,
    "depth": 15},
   {"type":
    "‚àÄ {m : Type u ‚Üí Type v} [inst : Monad m] [inst_1 : LawfulMonad m] {Œ± Œ≤ : Type u} (f : Œ± ‚Üí m Œ≤), pure >=> f = f",
    "name": "fish_pipe",
    "isProp": true,
    "depth": 15}],
  "kind": "¬´term_>=>_¬ª",
  "examples": [],
  "count": 4},
 {"noDocExamples":
  [{"type": "‚àÄ (x : ZFSet), ‚Üë(‚ãÉ‚ÇÄ x) = ‚ãÉ‚ÇÄ ‚Üëx",
    "name": "Class.coe_sUnion",
    "isProp": true,
    "depth": 5},
   {"type": "‚ãÉ‚ÇÄ ‚àÖ = ‚àÖ",
    "name": "Class.sUnion_empty",
    "isProp": true,
    "depth": 5},
   {"type": "‚àÄ {x : Class} {y : ZFSet}, (‚ãÉ‚ÇÄ x) y ‚Üî ‚àÉ z, x z ‚àß y ‚àà z",
    "name": "Class.sUnion_apply",
    "isProp": true,
    "depth": 11}],
  "kind": "Class.¬´term‚ãÉ‚ÇÄ_¬ª",
  "examples": [],
  "count": 4},
 {"noDocExamples":
  [{"type": "‚àÄ (x : PSet), PSet.toSet (‚ãÉ‚ÇÄ x) = ‚ãÉ‚ÇÄ (PSet.toSet '' PSet.toSet x)",
    "name": "PSet.toSet_sUnion",
    "isProp": true,
    "depth": 7},
   {"type":
    "‚àÄ (x x_1 : PSet), PSet.Equiv x x_1 ‚Üí PSet.Arity.Equiv (‚ãÉ‚ÇÄ x) (‚ãÉ‚ÇÄ x_1)",
    "name": "ZFSet.sUnion.proof_1",
    "isProp": true,
    "depth": 8},
   {"type": "‚àÄ {x y : PSet}, y ‚àà ‚ãÉ‚ÇÄ x ‚Üî ‚àÉ z, z ‚àà x ‚àß y ‚àà z",
    "name": "PSet.mem_sUnion",
    "isProp": true,
    "depth": 12}],
  "kind": "PSet.¬´term‚ãÉ‚ÇÄ_¬ª",
  "examples": [],
  "count": 4},
 {"noDocExamples":
  [{"type":
    "‚àÄ {Œ± : Type u_1} [inst : BEq Œ±] [inst_1 : LawfulBEq Œ±] (a : Œ±), (a != a) = false",
    "name": "bne_self_eq_false",
    "isProp": true,
    "depth": 10},
   {"type": "‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] (a : Œ±), (a != a) = false",
    "name": "bne_self_eq_false'",
    "isProp": true,
    "depth": 13},
   {"type":
    "‚àÄ {Œ± : Type u_1} [inst : BEq Œ±] [inst_1 : LawfulBEq Œ±] (a b : Œ±), (a != b) = true ‚Üî a ‚â† b",
    "name": "bne_iff_ne",
    "isProp": true,
    "depth": 13}],
  "kind": "¬´term_!=_¬ª",
  "examples": [],
  "count": 3},
 {"noDocExamples":
  [{"type":
    "‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] [inst_1 : CategoryTheory.MonoidalCategory C] {D : Type u‚ÇÇ}\n  [inst_2 : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D] [inst_3 : CategoryTheory.MonoidalCategory D] {E : Type u‚ÇÉ}\n  [inst_4 : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E] [inst_5 : CategoryTheory.MonoidalCategory E]\n  (F : CategoryTheory.MonoidalFunctor C D) (G : CategoryTheory.MonoidalFunctor D E),\n  (F ‚äó‚ãô G).toLaxMonoidalFunctor = F.toLaxMonoidalFunctor ‚äó‚ãô G.toLaxMonoidalFunctor",
    "name": "CategoryTheory.MonoidalFunctor.comp_toLaxMonoidalFunctor",
    "isProp": true,
    "depth": 25}],
  "kind": "CategoryTheory.MonoidalFunctor.¬´term_‚äó‚ãô_¬ª",
  "examples":
  [{"type":
    "{M : Type u} ‚Üí\n  [inst : Monoid M] ‚Üí\n    {N : Type u} ‚Üí\n      [inst_1 : Monoid N] ‚Üí\n        {K : Type u} ‚Üí\n          [inst_2 : Monoid K] ‚Üí\n            (F : M ‚Üí* N) ‚Üí\n              (G : N ‚Üí* K) ‚Üí\n                CategoryTheory.Discrete.monoidalFunctor F ‚äó‚ãô CategoryTheory.Discrete.monoidalFunctor G ‚âÖ\n                  CategoryTheory.Discrete.monoidalFunctor (MonoidHom.comp G F)",
    "name": "CategoryTheory.Discrete.monoidalFunctorComp",
    "isProp": false,
    "doc":
    "The monoidal natural isomorphism corresponding to composing two multiplicative morphisms.\n",
    "depth": 22},
   {"type":
    "{M : Type u} ‚Üí\n  [inst : AddMonoid M] ‚Üí\n    {N : Type u} ‚Üí\n      [inst_1 : AddMonoid N] ‚Üí\n        {K : Type u} ‚Üí\n          [inst_2 : AddMonoid K] ‚Üí\n            (F : M ‚Üí+ N) ‚Üí\n              (G : N ‚Üí+ K) ‚Üí\n                CategoryTheory.Discrete.addMonoidalFunctor F ‚äó‚ãô CategoryTheory.Discrete.addMonoidalFunctor G ‚âÖ\n                  CategoryTheory.Discrete.addMonoidalFunctor (AddMonoidHom.comp G F)",
    "name": "CategoryTheory.Discrete.addMonoidalFunctorComp",
    "isProp": false,
    "doc":
    "The monoidal natural isomorphism corresponding to\ncomposing two additive morphisms.",
    "depth": 22}],
  "count": 3},
 {"noDocExamples":
  [{"type": "‚àÄ (F A : Class), F ‚Ä≤ A ‚àà Class.univ",
    "name": "Class.fval_ex",
    "isProp": true,
    "depth": 7},
   {"type":
    "‚àÄ (x : ZFSet), ¬¨‚àÖ ‚àà x ‚Üí ‚àÄ (y : ZFSet), y ‚àà x ‚Üí ‚Üë(ZFSet.choice x) ‚Ä≤ ‚Üëy ‚àà ‚Üëy",
    "name": "ZFSet.choice_mem",
    "isProp": true,
    "depth": 10},
   {"type":
    "‚àÄ {f : ZFSet ‚Üí ZFSet} [H : PSet.Definable 1 f] {x y : ZFSet}, y ‚àà x ‚Üí ‚Üë(ZFSet.map f x) ‚Ä≤ ‚Üëy = ‚Üë(f y)",
    "name": "ZFSet.map_fval",
    "isProp": true,
    "depth": 13}],
  "kind": "Class.¬´term_‚Ä≤_¬ª",
  "examples": [],
  "count": 3},
 {"noDocExamples":
  [{"type":
    "‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] (f : ‚Ñù ‚Üí E) (a b : ‚Ñù),\n  ‚®ç (x : ‚Ñù) in a..b, f x = ‚®ç (x : ‚Ñù) in b..a, f x",
    "name": "interval_average_symm",
    "isProp": true,
    "depth": 15},
   {"type":
    "‚àÄ (f : ‚Ñù ‚Üí ‚Ñù) (a b : ‚Ñù), ‚®ç (x : ‚Ñù) in a..b, f x = (‚à´ (x : ‚Ñù) in a..b, f x) / (b - a)",
    "name": "interval_average_eq_div",
    "isProp": true,
    "depth": 16},
   {"type":
    "‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] (f : ‚Ñù ‚Üí E) (a b : ‚Ñù),\n  ‚®ç (x : ‚Ñù) in a..b, f x = (b - a)‚Åª¬π ‚Ä¢ ‚à´ (x : ‚Ñù) in a..b, f x",
    "name": "interval_average_eq",
    "isProp": true,
    "depth": 22}],
  "kind": "¬´term‚®ç_In_.._,_¬ª",
  "examples": [],
  "count": 3},
 {"noDocExamples": [],
  "kind": "¬´term_‚âÉ‚Çó‚ãÜ[_]_¬ª",
  "examples":
  [{"type":
    "(R : Type u_1) ‚Üí\n  {A : Type u_2} ‚Üí\n    [inst : CommSemiring R] ‚Üí\n      [inst_1 : StarRing R] ‚Üí\n        [inst_2 : AddCommMonoid A] ‚Üí\n          [inst_3 : StarAddMonoid A] ‚Üí [inst_4 : Module R A] ‚Üí [inst_5 : StarModule R A] ‚Üí A ‚âÉ‚Çó‚ãÜ[R] A",
    "name": "starLinearEquiv",
    "isProp": false,
    "doc":
    "If `A` is a module over a commutative `R` with compatible actions,\nthen `star` is a semilinear equivalence. ",
    "depth": 22},
   {"type":
    "(m : Type u_2) ‚Üí\n  (n : Type u_3) ‚Üí\n    (R : Type u_7) ‚Üí\n      (Œ± : Type v) ‚Üí\n        [inst : CommSemiring R] ‚Üí\n          [inst_1 : StarRing R] ‚Üí\n            [inst_2 : AddCommMonoid Œ±] ‚Üí\n              [inst_3 : StarAddMonoid Œ±] ‚Üí\n                [inst_4 : Module R Œ±] ‚Üí [inst_5 : StarModule R Œ±] ‚Üí Matrix m n Œ± ‚âÉ‚Çó‚ãÜ[R] Matrix n m Œ±",
    "name": "Matrix.conjTransposeLinearEquiv",
    "isProp": false,
    "doc": "`Matrix.conjTranspose` as a `LinearMap` ",
    "depth": 24},
   {"type":
    "{ùïú : Type u_1} ‚Üí\n  {E : Type u_2} ‚Üí\n    {F : Type u_3} ‚Üí\n      [inst : IsROrC ùïú] ‚Üí\n        [inst_1 : NormedAddCommGroup E] ‚Üí\n          [inst_2 : NormedAddCommGroup F] ‚Üí\n            [inst_3 : InnerProductSpace ùïú E] ‚Üí\n              [inst_4 : InnerProductSpace ùïú F] ‚Üí\n                [inst_5 : FiniteDimensional ùïú E] ‚Üí [inst_6 : FiniteDimensional ùïú F] ‚Üí (E ‚Üí‚Çó[ùïú] F) ‚âÉ‚Çó‚ãÜ[ùïú] F ‚Üí‚Çó[ùïú] E",
    "name": "LinearMap.adjoint",
    "isProp": false,
    "doc":
    "The adjoint of an operator from the finite-dimensional inner product space `E` to the\nfinite-dimensional inner product space `F`. ",
    "depth": 32}],
  "count": 3},
 {"noDocExamples": [],
  "kind": "¬´term_‚Üí‚Çó‚ãÜ[_]_¬ª",
  "examples":
  [{"type":
    "{ùïú : Type u_1} ‚Üí\n  {E : Type u_2} ‚Üí\n    [inst : IsROrC ùïú] ‚Üí [inst_1 : NormedAddCommGroup E] ‚Üí [inst_2 : InnerProductSpace ùïú E] ‚Üí E ‚Üí‚Çó[ùïú] E ‚Üí‚Çó‚ãÜ[ùïú] ùïú",
    "name": "sesqFormOfInner",
    "isProp": false,
    "doc":
    "The inner product as a sesquilinear form.\n\nNote that in the case `ùïú = ‚Ñù` this is a bilinear form. ",
    "depth": 26},
   {"type":
    "(ùïú : Type u_1) ‚Üí\n  {E : Type u_2} ‚Üí\n    [inst : IsROrC ùïú] ‚Üí [inst_1 : NormedAddCommGroup E] ‚Üí [inst_2 : InnerProductSpace ùïú E] ‚Üí E ‚Üí‚Çó‚ãÜ[ùïú] E ‚Üí‚Çó[ùïú] ùïú",
    "name": "inner‚Çõ‚Çó",
    "isProp": false,
    "doc": "The inner product as a sesquilinear map. ",
    "depth": 26}],
  "count": 2},
 {"noDocExamples": [],
  "kind": "¬´term_‚Üí‚Çó·µ¢‚ãÜ[_]_¬ª",
  "examples":
  [{"type":
    "(ùïú : Type u_1) ‚Üí\n  (E : Type u_2) ‚Üí\n    [inst : IsROrC ùïú] ‚Üí\n      [inst_1 : NormedAddCommGroup E] ‚Üí [inst_2 : InnerProductSpace ùïú E] ‚Üí E ‚Üí‚Çó·µ¢‚ãÜ[ùïú] NormedSpace.Dual ùïú E",
    "name": "InnerProductSpace.toDualMap",
    "isProp": false,
    "doc":
    "An element `x` of an inner product space `E` induces an element of the dual space `Dual ùïú E`,\nthe map `fun y => ‚ü™x, y‚ü´`; moreover this operation is a conjugate-linear isometric embedding of `E`\ninto `Dual ùïú E`.\nIf `E` is complete, this operation is surjective, hence a conjugate-linear isometric equivalence;\nsee `toDual`.\n",
    "depth": 21}],
  "count": 1},
 {"noDocExamples": [],
  "kind": "¬´term_‚âÉL‚ãÜ[_]_¬ª",
  "examples":
  [{"type":
    "(R : Type u_1) ‚Üí\n  {A : Type u_2} ‚Üí\n    [inst : CommSemiring R] ‚Üí\n      [inst_1 : StarRing R] ‚Üí\n        [inst_2 : AddCommMonoid A] ‚Üí\n          [inst_3 : StarAddMonoid A] ‚Üí\n            [inst_4 : Module R A] ‚Üí\n              [inst_5 : StarModule R A] ‚Üí [inst_6 : TopologicalSpace A] ‚Üí [inst_7 : ContinuousStar A] ‚Üí A ‚âÉL‚ãÜ[R] A",
    "name": "starL",
    "isProp": false,
    "doc":
    "If `A` is a topological module over a commutative `R` with compatible actions,\nthen `star` is a continuous semilinear equivalence. ",
    "depth": 26}],
  "count": 1},
 {"noDocExamples":
  [{"type":
    "‚àÄ {Cont : Type u_1} {Elem : Type u_2} {Dom : Cont ‚Üí ‚Ñï ‚Üí Prop} {n : ‚Ñï} [inst : GetElem Cont ‚Ñï Elem Dom] (a : Cont)\n  (i : Fin n) [inst_1 : Decidable (Dom a ‚Üëi)] [inst_2 : Inhabited Elem], a[i]! = a[‚Üëi]!",
    "name": "getElem!_fin",
    "isProp": true,
    "depth": 22}],
  "kind": "¬´term__[_]_!¬ª",
  "examples": [],
  "count": 1}]