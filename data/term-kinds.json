[{"noDocExamples": [],
  "kind": "Lean.Parser.Term.app",
  "examples":
  [{"term": "Set UpperHalfPlane",
    "name": "ModularGroup.fd",
    "doc":
    "The standard (closed) fundamental domain of the action of `SL(2,‚Ñ§)` on `‚Ñç`. ",
    "depth": 1},
   {"term": "Linarith.LinarithM Unit",
    "name": "Linarith.elimAllVarsM",
    "doc":
    "`elimAllVarsM` eliminates all variables from the linarith state, leaving it with a set of\nground comparisons. If this succeeds without exception, the original `linarith` state is consistent.\n",
    "depth": 1},
   {"term": "Computability.FinEncoding ‚Ñï",
    "name": "Computability.finEncodingNatBool",
    "doc": "A binary fin_encoding of ‚Ñï in bool. ",
    "depth": 1},
   {"term": "ProofWidgets.Component ProofWidgets.PenroseDiagramProps",
    "name": "ProofWidgets.PenroseDiagram",
    "doc":
    "Displays the given diagram using [Penrose](https://penrose.cs.cmu.edu/). The website contains\nexplanations of how to write domain (`dsl`), style (`sty`), and substance (`sub`) programs.\n\nThe diagram may also contain embedded HTML trees which are specified in `embeds`. Each embed is HTML\ntogether with the name of an object `x` in the substance program which *must* be assigned\nan `x.textBox : Rectangle` field in the style program. This rectangle will be replaced with the HTML\ntree.\n\nThe following additional constants are prepended to the style program:\n```penrose\ntheme {\n  color foreground\n  color tooltipBackground\n  color tooltipForeground\n  color tooltipBorder\n}\n```\nand can be accessed as, for example, `theme.foreground` in the provided `sty` in order to match\nthe editor theme. ",
    "depth": 1},
   {"term": "List Char",
    "name": "System.FilePath.pathSeparators",
    "doc": "The list of all possible separators. ",
    "depth": 1}],
  "count": 209724},
 {"noDocExamples": [],
  "kind": "Lean.Parser.Term.type",
  "examples":
  [{"term": "Type (u + 1)",
    "name": "SSet.Augmented",
    "doc":
    "The category of augmented simplicial sets, as a particular case of\naugmented simplicial objects. ",
    "depth": 0},
   {"term": "Type (max (u + 1) u (v + 1))",
    "name": "CategoryTheory.QuivCat",
    "doc": "Category of quivers. ",
    "depth": 0},
   {"term": "Type (u_1 + 1)",
    "name": "NatOrdinal",
    "doc":
    "A type synonym for ordinals with natural addition and multiplication. ",
    "depth": 0},
   {"term": "Type",
    "name": "SetTheory.PGame.Domineering.Board",
    "doc": "A Domineering board is an arbitrary finite subset of `‚Ñ§ √ó ‚Ñ§`. ",
    "depth": 0},
   {"term": "Type",
    "name": "PNat",
    "doc":
    "`‚Ñï+` is the type of positive natural numbers. It is defined as a subtype,\nand the VM representation of `‚Ñï+` is the same as `‚Ñï` because the proof\nis not stored. ",
    "depth": 0}],
  "count": 185658},
 {"noDocExamples": [],
  "kind": "Lean.Parser.Term.forall",
  "examples":
  [{"term": "‚àÄ {Œ± : Prop}, Œ±",
    "name": "lcProof",
    "doc":
    "Auxiliary unsafe constant used by the Compiler when erasing proofs from code.\n\nIt may look strange to have an axiom that says \"every proposition is true\",\nsince this is obviously unsound, but the `unsafe` marker ensures that the\nkernel will not let this through into regular proofs. The lower levels of the\ncode generator don't need proofs in terms, so this is used to stub the proofs\nout.\n",
    "depth": 1},
   {"term": "‚àÄ (n : ‚Ñï), Int.NonNeg (Int.ofNat n)",
    "name": "Int.NonNeg.mk",
    "doc": "Sole constructor, proving that `ofNat n` is positive. ",
    "depth": 3},
   {"term":
    "‚àÄ (o : Ordinal.{u_1}), SetTheory.PGame.Numeric (Ordinal.toPGame o)",
    "name": "SetTheory.PGame.numeric_toPGame",
    "doc": "Ordinal games are numeric. ",
    "depth": 3},
   {"term": "‚àÄ {Œ± : Type u_1} [inst : Nontrivial Œ±], Nonempty Œ±",
    "name": "Nontrivial.to_nonempty",
    "doc":
    "See Note [lower instance priority]\n\nNote that since this and `nonempty_of_inhabited` are the most \"obvious\" way to find a nonempty\ninstance if no direct instance can be found, we give this a higher priority than the usual `100`.\n",
    "depth": 3},
   {"term": "‚àÄ {n : ‚Ñï}, Nat.le n n",
    "name": "Nat.le.refl",
    "doc": "Less-equal is reflexive: `n ‚â§ n` ",
    "depth": 3}],
  "count": 175205},
 {"noDocExamples": [],
  "kind": "¬´term_=_¬ª",
  "examples":
  [{"term": "Cardinal.mk ‚ÑÇ = Cardinal.continuum",
    "name": "mk_complex",
    "doc": "The cardinality of the complex numbers, as a type. ",
    "depth": 3},
   {"term": "Cardinal.mk ‚Ñù = Cardinal.continuum",
    "name": "Cardinal.mk_real",
    "doc": "The cardinality of the reals, as a type. ",
    "depth": 3},
   {"term": "Ordinal.lift.{max u v, u} = Ordinal.lift.{v, u}",
    "name": "Ordinal.lift_umax",
    "doc": "`lift.{max u v, u}` equals `lift.{v, u}`. ",
    "depth": 4},
   {"term": "‚àÄ (a : Cardinal.{u}), Cardinal.lift.{0, u} a = a",
    "name": "Cardinal.lift_uzero",
    "doc": "A cardinal lifted to the zero universe equals itself. ",
    "depth": 4},
   {"term": "Cardinal.lift.{max u v, u} = Cardinal.lift.{v, u}",
    "name": "Cardinal.lift_umax",
    "doc": "`lift.{max u v, u}` equals `lift.{v, u}`. ",
    "depth": 4}],
  "count": 102087},
 {"noDocExamples": [],
  "kind": "Lean.Parser.Term.arrow",
  "examples":
  [{"term": "AlgebraicGeometry.Scheme ‚Üí Prop",
    "name": "AlgebraicGeometry.IsReduced",
    "doc": "A scheme `X` is reduced if all `ùí™‚Çì(U)` are reduced. ",
    "depth": 1},
   {"term": "Simps.Config ‚Üí Bool",
    "name": "Simps.Config.fullyApplied",
    "doc":
    "Generated lemmas that are fully applied, i.e. generates equalities between applied functions.\nSet this to `false` to generate equalities between functions. ",
    "depth": 1},
   {"term": "Lean.Expr ‚Üí Lean.Expr",
    "name": "SlimCheck.Decorations.addDecorations",
    "doc":
    "Traverse the syntax of a proposition to find universal quantifiers\nquantifiers and add `NamedBinder` annotations next to them. ",
    "depth": 1},
   {"term": "Type u_1 ‚Üí Type u_1",
    "name": "CompleteDistribLattice",
    "doc":
    "A complete distributive lattice is a complete lattice whose `‚äî` and `‚äì` respectively\ndistribute over `‚®Ö` and `‚®Ü`. ",
    "depth": 1},
   {"term": "Type u ‚Üí Type u",
    "name": "HasSSubset",
    "doc": "Notation type class for the strict subset relation `‚äÇ`. ",
    "depth": 1}],
  "count": 95379},
 {"noDocExamples": [],
  "kind": "coeNotation",
  "examples":
  [{"term": "‚ÜëunitInterval ‚Üí ‚Ñù",
    "name": "Path.Homotopy.transAssocReparamAux",
    "doc": "Auxiliary function for `trans_assoc_reparam`. ",
    "depth": 3},
   {"term": "‚ÜëunitInterval ‚Üí ‚ÜëunitInterval",
    "name": "unitInterval.symm",
    "doc": "Unit interval central symmetry. ",
    "depth": 3},
   {"term": "‚ÜëunitInterval ‚Üí ‚Ñù",
    "name": "Path.Homotopy.transReflReparamAux",
    "doc": "Auxiliary function for `trans_refl_reparam`. ",
    "depth": 3},
   {"term": "(A : FintypeCat) ‚Üí TopologicalSpace ‚ÜëA",
    "name": "FintypeCat.botTopology",
    "doc": "Finite types are given the discrete topology. ",
    "depth": 4},
   {"term": "{X : TopCat} ‚Üí ‚ÜëX ‚Üí Type u",
    "name": "TopologicalSpace.OpenNhds",
    "doc":
    "The type of open neighbourhoods of a point `x` in a (bundled) topological space. ",
    "depth": 4}],
  "count": 52144},
 {"noDocExamples": [],
  "kind": "Lean.Parser.Term.depArrow",
  "examples":
  [{"term": "{Œ± : Sort u} ‚Üí Œ±",
    "name": "lcUnreachable",
    "doc":
    "Auxiliary unsafe constant used by the Compiler to mark unreachable code.\n\nLike `lcProof`, this is an `unsafe axiom`, which means that even though it is\nnot sound, the kernel will not let us use it for regular proofs.\n\nExecuting this expression to actually synthesize a value of type `Œ±` causes\n**immediate undefined behavior**, and the compiler does take advantage of this\nto optimize the code assuming that it is not called. If it is not optimized out,\nit is likely to appear as a print message saying \"unreachable code\", but this\nbehavior is not guaranteed or stable in any way.\n",
    "depth": 1},
   {"term": "{Œπ : Type u_5} ‚Üí Type u_5",
    "name": "VectorBundleCore.Index",
    "doc":
    "The index set of a vector bundle core, as a convenience function for dot notation ",
    "depth": 1},
   {"term": "{B : Type u_2} ‚Üí Type u_2",
    "name": "VectorBundleCore.Base",
    "doc":
    "The base space of a vector bundle core, as a convenience function for dot notation",
    "depth": 1},
   {"term": "{Œ± : Type u_2} ‚Üí Bornology Œ±",
    "name": "Bornology.cofinite",
    "doc": "The cofinite filter as a bornology ",
    "depth": 2},
   {"term": "(n : ‚Ñï) ‚Üí Composition n",
    "name": "Composition.ones",
    "doc": "The composition made of blocks all of size `1`. ",
    "depth": 2}],
  "count": 42864},
 {"noDocExamples": [],
  "kind": "Lean.Parser.Term.proj",
  "examples":
  [{"term": "(self : Pointed) ‚Üí self.X",
    "name": "Pointed.point",
    "doc": "the distinguished element ",
    "depth": 2},
   {"term": "{F : PFunctor} ‚Üí PFunctor.M F ‚Üí F.A",
    "name": "PFunctor.M.head",
    "doc":
    "given a tree generated by `F`, `head` gives us the first piece of data\nit contains ",
    "depth": 3},
   {"term": "(self : PFunctor) ‚Üí self.A ‚Üí Type u",
    "name": "PFunctor.B",
    "doc": "The child family of types ",
    "depth": 3},
   {"term": "{P : PFunctor} ‚Üí PFunctor.W P ‚Üí P.A",
    "name": "PFunctor.W.head",
    "doc": "root element of a W tree ",
    "depth": 3},
   {"term": "‚àÄ (self : WellOrder), IsWellOrder self.Œ± self.r",
    "name": "WellOrder.wo",
    "doc": "The proposition that `r` is a well-ordering for `Œ±`. ",
    "depth": 4}],
  "count": 32972},
 {"noDocExamples": [],
  "kind": "Lean.Parser.Term.explicitUniv",
  "examples":
  [{"term": "Ordinal.{u}",
    "name": "Ordinal.omega",
    "doc":
    "`œâ` is the first infinite ordinal, defined as the order type of `‚Ñï`. ",
    "depth": 0},
   {"term": "Cardinal.{u}",
    "name": "Cardinal.continuum",
    "doc": "Cardinality of continuum. ",
    "depth": 0},
   {"term": "PUnit.{u}",
    "name": "PUnit.unit",
    "doc": "`PUnit.unit : PUnit` is the canonical element of the unit type. ",
    "depth": 0},
   {"term": "Ordinal.{max (u + 1) v}",
    "name": "Ordinal.univ",
    "doc":
    "`univ.{u v}` is the order type of the ordinals of `Type u` as a member\nof `Ordinal.{v}` (when `u < v`). It is an inaccessible cardinal. ",
    "depth": 0},
   {"term": "Cardinal.{u}",
    "name": "Cardinal.aleph0",
    "doc": "`‚Ñµ‚ÇÄ` is the smallest infinite cardinal. ",
    "depth": 0}],
  "count": 27822},
 {"noDocExamples": [],
  "kind": "Lean.Parser.Term.fun",
  "examples":
  [{"term": "{Œ± : Type u_1} ‚Üí (s : Set Œ±) ‚Üí (fun x => ‚Ñï) (Set.encard s)",
    "name": "Set.ncard",
    "doc":
    "The cardinality of `s : Set Œ±` . Has the junk value `0` if `s` is infinite ",
    "depth": 5},
   {"term": "{Œº : YoungDiagram} ‚Üí CoeFun (Ssyt Œº) fun x => ‚Ñï ‚Üí ‚Ñï ‚Üí ‚Ñï",
    "name": "Ssyt.instCoeFunSsytForAllNat",
    "doc":
    "Helper instance for when there's too many metavariables to apply `CoeFun.coe` directly. ",
    "depth": 5},
   {"term":
    "Filter.Tendsto (fun n => Stirling.stirlingSeq n) Filter.atTop (nhds (Real.sqrt Real.pi))",
    "name": "Stirling.tendsto_stirlingSeq_sqrt_pi",
    "doc": "**Stirling's Formula** ",
    "depth": 6},
   {"term": "{Œ± : Type u_1} ‚Üí (s : Set Œ±) ‚Üí (fun x => ‚Ñï‚àû) (PartENat.card ‚Üës)",
    "name": "Set.encard",
    "doc": "The cardinality of a set as a term in `‚Ñï‚àû` ",
    "depth": 6},
   {"term":
    "{E : Type u_4} ‚Üí [inst : AddGroup E] ‚Üí CoeFun (NonarchAddGroupSeminorm E) fun x => E ‚Üí ‚Ñù",
    "name":
    "NonarchAddGroupSeminorm.instCoeFunNonarchAddGroupSeminormForAllReal",
    "doc":
    "Helper instance for when there's too many metavariables to apply `FunLike.hasCoeToFun`. ",
    "depth": 6}],
  "count": 25585},
 {"noDocExamples": [],
  "kind": "¬´term_‚àà_¬ª",
  "examples":
  [{"term": "¬¨Class.univ ‚àà Class.univ",
    "name": "Class.univ_not_mem_univ",
    "doc":
    "**There is no universal set.**\nThis is stated as `univ ‚àâ univ`, meaning that `univ` (the class of all sets) is proper (does not\nbelong to the class of all sets). ",
    "depth": 6},
   {"term": "‚àÄ (A : Class), Class.iota A ‚àà Class.univ",
    "name": "Class.iota_ex",
    "doc":
    "Unlike the other set constructors, the `iota` definite descriptor\nis a set for any set input, but not constructively so, so there is no\nassociated `Class ‚Üí Set` function. ",
    "depth": 6},
   {"term": "‚àÄ {M : Type u_1} [inst : Monoid M] {x : M}, x ‚àà powers x",
    "name": "powers.self_mem",
    "doc":
    "An element of a monoid is in the set of that element's natural number powers. ",
    "depth": 8},
   {"term": "‚àÄ {M : Type u_1} [inst : AddMonoid M] {x : M}, x ‚àà multiples x",
    "name": "multiples.self_mem",
    "doc":
    "An element of an `AddMonoid` is in the set of that element's natural number multiples.",
    "depth": 8},
   {"term": "‚àÄ {Œ± : Type u_1} (self : Filter Œ±), Set.univ ‚àà self.sets",
    "name": "Filter.univ_sets",
    "doc": "The set `Set.univ` belongs to any filter. ",
    "depth": 8}],
  "count": 24782},
 {"noDocExamples": [],
  "kind": "term‚Ñï",
  "examples":
  [{"term": "‚Ñï",
    "name": "System.Platform.numBits",
    "doc":
    "Gets the word size of the platform. That is, whether the platform is 64 or 32 bits. ",
    "depth": 0},
   {"term": "‚Ñï",
    "name": "Nat.zero",
    "doc":
    "`Nat.zero`, normally written `0 : Nat`, is the smallest natural number.\nThis is one of the two constructors of `Nat`. ",
    "depth": 0},
   {"term": "‚Ñï",
    "name": "Nat.Linear.fixedVar",
    "doc":
    "When encoding polynomials. We use `fixedVar` for encoding numerals.\nThe denotation of `fixedVar` is always `1`. ",
    "depth": 0},
   {"term": "‚Ñï",
    "name": "Ordnode.ratio",
    "doc":
    "**Internal use only**\n\nThe ratio between an outer and inner sibling of the\nheavier subtree in an unbalanced setting. It determines\nwhether a double or single rotation should be performed\nto restore balance. It is corresponds with the inverse\nof `Œ±` in Adam's article. ",
    "depth": 0},
   {"term": "‚Ñï",
    "name": "Ordnode.delta",
    "doc":
    "**Internal use only**\n\nThe maximal relative difference between the sizes of\ntwo trees, it corresponds with the `w` in Adams' paper.\n\nAccording to the Haskell comment, only `(delta, ratio)` settings\nof `(3, 2)` and `(4, 2)` will work, and the proofs in\n`Ordset.lean` assume `delta := 3` and `ratio := 2`. ",
    "depth": 0}],
  "count": 22643},
 {"noDocExamples": [],
  "kind": "¬´term_‚â§_¬ª",
  "examples":
  [{"term": "‚àÄ (L : List ‚Ñï), List.headI L ‚â§ List.sum L",
    "name": "List.headI_le_sum",
    "doc": "This relies on `default ‚Ñï = 0`. ",
    "depth": 6},
   {"term": "‚àÄ {p : ‚Ñù}, p ‚â§ 0 ‚Üí ENNReal.ofReal p = 0",
    "name": "ENNReal.ofReal_of_nonpos",
    "doc": "**Alias** of the reverse direction of `ENNReal.ofReal_eq_zero`.",
    "depth": 6},
   {"term":
    "{x : SetTheory.PGame} ‚Üí\n  x ‚â§ 0 ‚Üí (i : SetTheory.PGame.LeftMoves x) ‚Üí SetTheory.PGame.RightMoves (SetTheory.PGame.moveLeft x i)",
    "name": "SetTheory.PGame.rightResponse",
    "doc":
    "Given a game won by the right player when they play second, provide a response to any move by\nleft. ",
    "depth": 6},
   {"term": "‚àÄ {a : ‚Ñï}, ‚Üë(Nat.sqrt a) ‚â§ Real.sqrt ‚Üëa",
    "name": "Real.nat_sqrt_le_real_sqrt",
    "doc": "The natural square root is at most the real square root ",
    "depth": 6},
   {"term": "‚àÄ {s : Substring}, Substring.Valid s ‚Üí s.startPos ‚â§ s.stopPos",
    "name": "Substring.Valid.le",
    "doc": "The stop position of a substring is at least the start. ",
    "depth": 6}],
  "count": 20225},
 {"noDocExamples": [],
  "kind": "¬´term_+_¬ª",
  "examples":
  [{"term": "‚àÄ {a : ‚Ñï}, Real.sqrt ‚Üëa ‚â§ ‚Üë(Nat.sqrt a) + 1",
    "name": "Real.real_sqrt_le_nat_sqrt_succ",
    "doc": "The real square root is at most the natural square root plus one ",
    "depth": 8},
   {"term": "(n : ‚Ñï) ‚Üí Fin (n + 1)",
    "name": "Fin.last",
    "doc": "The greatest value of `Fin (n+1)`. ",
    "depth": 8},
   {"term": "‚àÄ (n : ‚Ñï), List.length (List.Nat.antidiagonal n) = n + 1",
    "name": "List.Nat.length_antidiagonal",
    "doc": "The length of the antidiagonal of `n` is `n + 1`. ",
    "depth": 8},
   {"term": "‚àÄ (n : ‚Ñï), Finset.card (Finset.Nat.antidiagonal n) = n + 1",
    "name": "Finset.Nat.card_antidiagonal",
    "doc": "The cardinality of the antidiagonal of `n` is `n + 1`. ",
    "depth": 8},
   {"term": "{n : ‚Ñï} ‚Üí Fin (n + 2) ‚Üí Fin (n + 1)",
    "name": "Fin.castPred",
    "doc":
    "`castPred` embeds `i : Fin (n + 2)` into `Fin (n + 1)`\nby lowering just `last (n + 1)` to `last n`. ",
    "depth": 9}],
  "count": 18726},
 {"noDocExamples": [],
  "kind": "¬´term_‚Üî_¬ª",
  "examples":
  [{"term":
    "{a : Prop} ‚Üí (b : Prop) ‚Üí (a ‚Üî b) ‚Üí [inst : Decidable b] ‚Üí Decidable a",
    "name": "decidable_of_iff'",
    "doc":
    "Transfer decidability of `b` to decidability of `a`, if the propositions are equivalent.\nThis is the same as `decidable_of_iff` but the iff is flipped. ",
    "depth": 5},
   {"term": "‚àÄ (p : True ‚Üí Prop), (‚àÄ (x : True), p x) ‚Üî p True.intro",
    "name": "forall_true_left",
    "doc": "See `IsEmpty.forall_iff` for the `False` version. ",
    "depth": 5},
   {"term": "‚àÄ {a b : Prop}, (a ‚Üî b) ‚Üí b ‚Üí a",
    "name": "Iff.mpr",
    "doc":
    "Modus ponens for if and only if, reversed. If `a ‚Üî b` and `b`, then `a`. ",
    "depth": 5},
   {"term": "‚àÄ {a : Prop}, ¬¨¬¨a ‚Üî a",
    "name": "Classical.not_not",
    "doc":
    "The Double Negation Theorem: `¬¨¬¨P` is equivalent to `P`.\nThe left-to-right direction, double negation elimination (DNE),\nis classically true but not constructively. ",
    "depth": 5},
   {"term":
    "{b : Prop} ‚Üí (a : Prop) ‚Üí (a ‚Üî b) ‚Üí [inst : Decidable a] ‚Üí Decidable b",
    "name": "decidable_of_iff",
    "doc":
    "Transfer decidability of `a` to decidability of `b`, if the propositions are equivalent.\n**Important**: this function should be used instead of `rw` on `decidable b`, because the\nkernel will get stuck reducing the usage of `propext` otherwise,\nand `dec_trivial` will not work. ",
    "depth": 5}],
  "count": 18359},
 {"noDocExamples": [],
  "kind": "¬´term_*_¬ª",
  "examples":
  [{"term": "‚àÄ (x : SetTheory.PGame), 0 * x ‚âà 0",
    "name": "SetTheory.PGame.zero_mul_equiv",
    "doc": "`0 * x` is equivalent to `0`. ",
    "depth": 9},
   {"term":
    "‚àÄ {n : ‚Ñï} [inst : NeZero n], Fintype.card (DihedralGroup n) = 2 * n",
    "name": "DihedralGroup.card",
    "doc": "If `0 < n`, then `DihedralGroup n` has `2n` elements.\n",
    "depth": 9},
   {"term": "(x : SetTheory.PGame) ‚Üí SetTheory.PGame.Relabelling (1 * x) x",
    "name": "SetTheory.PGame.oneMulRelabelling",
    "doc": "`1 * x` has the same moves as `x`. ",
    "depth": 9},
   {"term":
    "(fun œÑ => jacobiTheta œÑ - 1) =O[Filter.comap Complex.im Filter.atTop] fun œÑ => rexp (-Real.pi * œÑ.im)",
    "name": "isBigO_at_im_infty_jacobiTheta_sub_one",
    "doc":
    "The norm of `jacobiTheta œÑ - 1` decays exponentially as `im œÑ ‚Üí ‚àû`. ",
    "depth": 9},
   {"term": "‚àÄ (x : SetTheory.PGame), 1 * x ‚âà x",
    "name": "SetTheory.PGame.one_mul_equiv",
    "doc": "`1 * x` is equivalent to `x`. ",
    "depth": 9}],
  "count": 16520},
 {"noDocExamples": [],
  "kind": "¬´term_‚ü∂_¬ª",
  "examples":
  [{"term":
    "CategoryTheory.Limits.WalkingCospan.right ‚ü∂ CategoryTheory.Limits.WalkingCospan.one",
    "name": "CategoryTheory.Limits.WalkingCospan.Hom.inr",
    "doc": "The right arrow of the walking cospan. ",
    "depth": 5},
   {"term":
    "CategoryTheory.Limits.WalkingSpan.zero ‚ü∂ CategoryTheory.Limits.WalkingSpan.left",
    "name": "CategoryTheory.Limits.WalkingSpan.Hom.fst",
    "doc": "The left arrow of the walking span. ",
    "depth": 5},
   {"term":
    "CategoryTheory.Limits.WalkingSpan.zero ‚ü∂ CategoryTheory.Limits.WalkingSpan.right",
    "name": "CategoryTheory.Limits.WalkingSpan.Hom.snd",
    "doc": "The right arrow of the walking span. ",
    "depth": 5},
   {"term":
    "CategoryTheory.Limits.WalkingCospan.left ‚ü∂ CategoryTheory.Limits.WalkingCospan.one",
    "name": "CategoryTheory.Limits.WalkingCospan.Hom.inl",
    "doc": "The left arrow of the walking cospan. ",
    "depth": 5},
   {"term": "(X : CategoryTheory.Limits.WalkingCospan) ‚Üí X ‚ü∂ X",
    "name": "CategoryTheory.Limits.WalkingCospan.Hom.id",
    "doc": "The identity arrows of the walking cospan. ",
    "depth": 6}],
  "count": 14669},
 {"noDocExamples": [],
  "kind": "¬´term_<_¬ª",
  "examples":
  [{"term": "‚àÄ (x : ‚Ñù), 0 < Real.cosh x",
    "name": "Real.cosh_pos",
    "doc": "`Real.cosh` is always positive ",
    "depth": 6},
   {"term": "‚àÄ {n : ‚Ñï} (self : Fin n), ‚Üëself < n",
    "name": "Fin.isLt",
    "doc": "If `i : Fin n`, then `i.2` is a proof that `i.1 < n`. ",
    "depth": 6},
   {"term": "{a : ‚Ñï} ‚Üí 1 < a ‚Üí ‚Ñï ‚Üí ‚Ñï √ó ‚Ñï",
    "name": "Pell.pell",
    "doc":
    "The Pell sequences, i.e. the sequence of integer solutions to `x ^ 2 - d * y ^ 2 = 1`, where\n`d = a ^ 2 - 1`, defined together in mutual recursion. ",
    "depth": 7},
   {"term": "‚àÄ {n : ‚Ñï}, Fin n ‚Üí 0 < n",
    "name": "Fin.size_pos",
    "doc":
    "If you actually have an element of `Fin n`, then the `n` is always positive ",
    "depth": 7},
   {"term": "{a : ‚Ñï} ‚Üí 1 < a ‚Üí ‚Ñï ‚Üí ‚Ñ§",
    "name": "Pell.yz",
    "doc": "The Pell `y` sequence, considered as an integer sequence.",
    "depth": 7}],
  "count": 10857},
 {"noDocExamples": [],
  "kind": "term‚Ñù",
  "examples":
  [{"term": "‚Ñù",
    "name": "Real.pi",
    "doc":
    "The number œÄ = 3.14159265... Defined here using choice as twice a zero of cos in [1,2], from\nwhich one can derive all its properties. For explicit bounds on œÄ, see `Data.Real.Pi.Bounds`. ",
    "depth": 0},
   {"term": "‚Ñù",
    "name": "goldenRatio",
    "doc": "The golden ratio `œÜ := (1 + ‚àö5)/2`. ",
    "depth": 0},
   {"term": "‚Ñù",
    "name": "goldenConj",
    "doc": "The conjugate of the golden ratio `œà := (1 - ‚àö5)/2`. ",
    "depth": 0},
   {"term": "‚Ñù ‚Üí Real.Angle",
    "name": "Real.Angle.coe",
    "doc": "The canonical map from `‚Ñù` to the quotient `Angle`. ",
    "depth": 1},
   {"term": "MetricSpace ‚Ñù",
    "name": "Real.metricSpace",
    "doc": "Instantiate the reals as a metric space. ",
    "depth": 1}],
  "count": 9880},
 {"noDocExamples": [],
  "kind": "Lean.Parser.Term.prop",
  "examples":
  [{"term": "Prop",
    "name": "UnivLE",
    "doc":
    "A class expressing a universe inequality. `UnivLE.{u, v}` expresses that `u ‚â§ v`.\n\nThere are (at least) two plausible definitions for `u ‚â§ v`:\n* strong: `‚àÄ Œ± : Type max u v, Small.{v} Œ±`\n* weak: `‚àÄ Œ± : Type u, Small.{v} Œ±`\n\nThe weak definition has the advantage of being transitive.\nHowever only under the strong definition do we have `Small.{v} ((Œ± : Type u) ‚Üí (Œ≤ : Type v))`,\nwhich is essential for proving that `Type v` has `Type u`-indexed limits when `u ‚â§ v`.\n\nThe strong definition implies the weaker definition (see below),\nbut we can not prove the reverse implication.\nThis is because in Lean's type theory, while `max u v` is at least at big as `u` and `v`,\nit could be bigger than both!\n",
    "depth": 0},
   {"term": "Prop",
    "name": "True",
    "doc":
    "`True` is a proposition and has only an introduction rule, `True.intro : True`.\nIn other words, `True` is simply true, and has a canonical proof, `True.intro`\nFor more information: [Propositional Logic](https://leanprover.github.io/theorem_proving_in_lean4/propositions_and_proofs.html#propositional-logic)\n",
    "depth": 0},
   {"term": "Prop",
    "name": "False",
    "doc":
    "`False` is the empty proposition. Thus, it has no introduction rules.\nIt represents a contradiction. `False` elimination rule, `False.rec`,\nexpresses the fact that anything follows from a contradiction.\nThis rule is sometimes called ex falso (short for ex falso sequitur quodlibet),\nor the principle of explosion.\nFor more information: [Propositional Logic](https://leanprover.github.io/theorem_proving_in_lean4/propositions_and_proofs.html#propositional-logic)\n",
    "depth": 0},
   {"term": "Prop",
    "name": "RiemannHypothesis",
    "doc":
    "A formal statement of the Riemann hypothesis ‚Äì constructing a term of this type is worth a\nmillion dollars. ",
    "depth": 0},
   {"term": "Prop",
    "name": "AlgebraicGeometry.ŒìSpec.uh_functor_op2",
    "doc": "opposite of identity functor ",
    "depth": 0}],
  "count": 9679},
 {"noDocExamples": [],
  "kind": "Lean.Parser.Term.hole",
  "examples":
  [{"term": "(n : ‚Ñï) ‚Üí Finset ((_ : Fin n) √ó Fin n)",
    "name": "Equiv.Perm.finPairsLT",
    "doc": "set of all pairs (‚ü®a, b‚ü© : Œ£ a : fin n, fin n) such that b < a ",
    "depth": 5},
   {"term": "{Œ± : Type u_7} ‚Üí {Œ≤ : Type u_8} ‚Üí Œ± √ó Œ≤ ‚Üí (_ : Œ±) √ó Œ≤",
    "name": "Prod.toSigma",
    "doc": "Convert a product type to a Œ£-type. ",
    "depth": 5},
   {"term": "(Œ± : Type u_1) ‚Üí (_ : Œ±) √ó PUnit.{u_2 + 1} ‚âÉ Œ±",
    "name": "Equiv.sigmaPUnit",
    "doc":
    "`PUnit` is a right identity for dependent type product up to an equivalence. ",
    "depth": 5},
   {"term": "{Œ± : Type u} ‚Üí {Œ≤ : Type v} ‚Üí List (Œ± √ó Œ≤) ‚Üí List ((_ : Œ±) √ó Œ≤)",
    "name": "SlimCheck.TotalFunction.List.toFinmap'",
    "doc": "Create a `finmap` from a list of pairs. ",
    "depth": 6},
   {"term": "(Œ± : Type u_1) ‚Üí (Œ≤ : Type u_2) ‚Üí (_ : Œ±) √ó Œ≤ ‚âÉ Œ± √ó Œ≤",
    "name": "Equiv.sigmaEquivProd",
    "doc": "`Sigma` type with a constant fiber is equivalent to the product. ",
    "depth": 6}],
  "count": 8863},
 {"noDocExamples": [],
  "kind": "¬´term{_:_//_}¬ª",
  "examples":
  [{"term": "‚àÄ {Œ± : Sort u_1}, IsEmpty { _a // False }",
    "name": "Subtype.isEmpty_false",
    "doc": "subtypes by false are false. ",
    "depth": 4},
   {"term": "ZFSet ‚âÉ { s // Small.{u, u + 1} ‚Üës }",
    "name": "ZFSet.toSet_equiv",
    "doc": "`ZFSet.toSet` as an equivalence. ",
    "depth": 6},
   {"term": "{Œ± : Type u_1} ‚Üí {P : Œ± ‚Üí Prop} ‚Üí (‚àÉ x, P x) ‚Üí { x // P x }",
    "name": "Classical.subtype_of_exists",
    "doc":
    "A version of `Classical.indefiniteDescription` which is definitionally equal to a pair ",
    "depth": 6},
   {"term":
    "{Œ± : Type u_1} ‚Üí {P : Œ± ‚Üí Prop} ‚Üí [encA : Encodable Œ±] ‚Üí { a // P a } ‚Üí ‚Ñï",
    "name": "Encodable.encodeSubtype",
    "doc":
    "Explicit encoding function for a decidable subtype of an encodable type ",
    "depth": 7},
   {"term":
    "‚àÄ {Œ± : Sort u_4} [inst : Finite Œ±] {p : Œ± ‚Üí Prop}, Finite { x // p x }",
    "name": "Subtype.finite",
    "doc": "This instance also provides `[Finite s]` for `s : Set Œ±`. ",
    "depth": 7}],
  "count": 8013},
 {"noDocExamples": [],
  "kind": "¬´term_‚â†_¬ª",
  "examples":
  [{"term": "‚àÄ (self : ‚Ñö), self.den ‚â† 0",
    "name": "Rat.den_nz",
    "doc": "The denominator is nonzero. ",
    "depth": 5},
   {"term": "{Œ± : Type u_3} ‚Üí Nat.card Œ± ‚â† 0 ‚Üí Œ± ‚âÉ Fin (Nat.card Œ±)",
    "name": "Nat.equivFinOfCardPos",
    "doc":
    "If the cardinality is positive, that means it is a finite type, so there is\nan equivalence between `Œ±` and `Fin (Nat.card Œ±)`. See also `Finite.equivFin`. ",
    "depth": 6},
   {"term": "‚àÄ {Œ± : Type u} {s : Set Œ±}, Nonempty ‚Üës ‚Üî s ‚â† ‚àÖ",
    "name": "Set.nonempty_iff_ne_empty'",
    "doc": "See also `not_nonempty_iff_eq_empty'`. ",
    "depth": 7},
   {"term": "‚àÄ {Œ± : Type u} {s : Set Œ±}, Set.Nonempty s ‚Üí s ‚â† ‚àÖ",
    "name": "Set.Nonempty.ne_empty",
    "doc":
    "**Alias** of the forward direction of `Set.nonempty_iff_ne_empty`.\n\n---\n\nSee also `Set.not_nonempty_iff_eq_empty`. ",
    "depth": 7},
   {"term":
    "‚àÄ {d : ‚Ñ§}, 0 ‚â§ d ‚Üí ‚àÄ (a : Pell.Solution‚ÇÅ d), Pell.Solution‚ÇÅ.x a ‚â† 0",
    "name": "Pell.Solution‚ÇÅ.x_ne_zero",
    "doc": "A solution has `x ‚â† 0`. ",
    "depth": 7}],
  "count": 7757},
 {"noDocExamples": [],
  "kind": "¬´term_‚Ä¢_¬ª",
  "examples":
  [{"term": "‚àÄ {M : Type u} [inst : AddMonoid M] (a : M), 2 ‚Ä¢ a = a + a",
    "name": "two_nsmul",
    "doc": "",
    "depth": 11},
   {"term": "‚àÄ (n k : ‚Ñï), Nat.factorization (n ^ k) = k ‚Ä¢ Nat.factorization n",
    "name": "Nat.factorization_pow",
    "doc":
    "For any `p`, the power of `p` in `n^k` is `k` times the power in `n` ",
    "depth": 11},
   {"term":
    "‚àÄ {G : Type u_1} [inst : AddMonoid G] {x : G}, (Function.Injective fun n => n ‚Ä¢ x) ‚Üí ¬¨IsOfFinAddOrder x",
    "name": "not_isOfFinAddOrder_of_injective_nsmul",
    "doc": "See also `injective_nsmul_iff_not_isOfFinAddOrder`.",
    "depth": 12},
   {"term":
    "{M : Type u} ‚Üí [inst : AddMonoid M] ‚Üí (x : M) ‚Üí (n : ‚Ñï) ‚Üí n ‚Ä¢ x = 0 ‚Üí n ‚â† 0 ‚Üí AddUnits M",
    "name": "AddUnits.ofNSMulEqZero",
    "doc": "If `n ‚Ä¢ x = 0`, `n ‚â† 0`, then `x` is an additive unit.",
    "depth": 13},
   {"term":
    "‚àÄ {Œ± : Type u_2} [inst : AddMonoid Œ±] (m : Œ±), Even m ‚Üí ‚àÉ c, m = 2 ‚Ä¢ c",
    "name": "Even.exists_two_nsmul",
    "doc": "Alias of the forwards direction of `even_iff_exists_two_nsmul`.",
    "depth": 13}],
  "count": 7680},
 {"noDocExamples": [],
  "kind": "Lean.Parser.Term.typeAscription",
  "examples":
  [{"term":
    "‚àÄ {Œº : YoungDiagram},\n  YoungDiagram.ofRowLens (YoungDiagram.rowLens Œº) (_ : List.Sorted (fun x x_1 => x ‚â• x_1) (YoungDiagram.rowLens Œº)) = Œº",
    "name": "YoungDiagram.ofRowLens_to_rowLens_eq_self",
    "doc": "The left_inv direction of the equivalence ",
    "depth": 6},
   {"term":
    "‚àÄ {Œ± : Type u_1} (r : Setoid Œ±), Setoid.mkClasses (Setoid.classes r) (_ : ‚àÄ (a : Œ±), ‚àÉ! b x, a ‚àà b) = r",
    "name": "Setoid.mkClasses_classes",
    "doc":
    "The equivalence relation made from the equivalence classes of an equivalence\nrelation r equals r. ",
    "depth": 8},
   {"term":
    "‚àÄ {n : ‚Ñï},\n  Finset.map { toFun := Prod.swap, inj' := (_ : Function.Injective Prod.swap) } (Finset.Nat.antidiagonal n) =\n    Finset.Nat.antidiagonal n",
    "name": "Finset.Nat.map_swap_antidiagonal",
    "doc": "See also `Finset.map.map_prodComm_antidiagonal`. ",
    "depth": 11},
   {"term":
    "‚àÄ {Œ± : Type u_2} [inst : LinearOrder Œ±] (a : Œ±), Finset.min' {a} (_ : Finset.Nonempty {a}) = a",
    "name": "Finset.min'_singleton",
    "doc": "`{a}.min' _` is `a`. ",
    "depth": 11},
   {"term":
    "‚àÄ {n n' : ‚Ñï} (i : Fin n) (h : Nat.succ n = Nat.succ n'), Fin.cast h (Fin.succ i) = Fin.succ (Fin.cast (_ : n = n') i)",
    "name": "Fin.cast_succ_eq",
    "doc":
    "The cast of the successor is the successor of the cast. See `Fin.succ_cast_eq` for rewriting in\nthe reverse direction. ",
    "depth": 11}],
  "count": 7623},
 {"noDocExamples": [],
  "kind": "¬´term_‚àß_¬ª",
  "examples":
  [{"term": "‚àÄ {a b : Prop}, a ‚àß b ‚Üí a",
    "name": "And.left",
    "doc":
    "Extract the left conjunct from a conjunction. `h : a ‚àß b` then\n`h.left`, also notated as `h.1`, is a proof of `a`. ",
    "depth": 5},
   {"term": "‚àÄ {a b : Prop}, a ‚àß b ‚Üí b",
    "name": "And.right",
    "doc":
    "Extract the right conjunct from a conjunction. `h : a ‚àß b` then\n`h.right`, also notated as `h.2`, is a proof of `b`. ",
    "depth": 5},
   {"term": "‚àÄ {a b : Prop}, a ‚Üí b ‚Üí a ‚àß b",
    "name": "And.intro",
    "doc":
    "`And.intro : a ‚Üí b ‚Üí a ‚àß b` is the constructor for the And operation. ",
    "depth": 6},
   {"term":
    "{p q : Prop} ‚Üí SlimCheck.TestResult p ‚Üí SlimCheck.TestResult q ‚Üí SlimCheck.TestResult (p ‚àß q)",
    "name": "SlimCheck.TestResult.and",
    "doc":
    "Combine the test result for properties `p` and `q` to create a test for their conjunction. ",
    "depth": 7},
   {"term": "‚àÄ {a b c : Prop}, a ‚àß b ‚àß c ‚Üí b ‚àß c ‚àß a",
    "name": "And.rotate",
    "doc": "**Alias** of the forward direction of `and_rotate`.",
    "depth": 7}],
  "count": 7247},
 {"noDocExamples": [],
  "kind": "Lean.Parser.Term.structInst",
  "examples":
  [{"term": "‚àÄ {Œ± : Sort u} (a : Œ±), { down := a }.down = a",
    "name": "PLift.down_up",
    "doc": "Bijection between `Œ±` and `PLift Œ±` ",
    "depth": 7},
   {"term": "‚àÄ {Œ± : Type u} (b : ULift.{v, u} Œ±), { down := b.down } = b",
    "name": "ULift.up_down",
    "doc": "Bijection between `Œ±` and `ULift.{v} Œ±` ",
    "depth": 7},
   {"term": "‚àÄ {Œ± : Sort u} (b : PLift Œ±), { down := b.down } = b",
    "name": "PLift.up_down",
    "doc": "Bijection between `Œ±` and `PLift Œ±` ",
    "depth": 7},
   {"term": "‚àÄ {Œ± : Type u} (a : Œ±), { down := a }.down = a",
    "name": "ULift.down_up",
    "doc": "Bijection between `Œ±` and `ULift.{v} Œ±` ",
    "depth": 7},
   {"term":
    "‚àÄ {Œ± : Type u_1} (o : Part Œ±), { Dom := o.Dom, get := fun h => Part.get o h } = o",
    "name": "Part.eta",
    "doc": "`Part` eta expansion ",
    "depth": 9}],
  "count": 7144},
 {"noDocExamples": [],
  "kind": "¬´term‚àÉ_,_¬ª",
  "examples":
  [{"term": "‚àÄ {p : ‚Ñï ‚Üí Prop}, (‚àÉ x, p x) ‚Üí WellFounded (Nat.Upto.GT p)",
    "name": "Nat.Upto.wf",
    "doc":
    "The \"greater than\" relation on `Upto p` is well founded if (and only if) there exists a value\nsatisfying `p`. ",
    "depth": 5},
   {"term": "{p : ‚Ñï+ ‚Üí Prop} ‚Üí [inst : DecidablePred p] ‚Üí (‚àÉ n, p n) ‚Üí ‚Ñï+",
    "name": "PNat.find",
    "doc":
    "If `p` is a (decidable) predicate on `‚Ñï+` and `hp : ‚àÉ (n : ‚Ñï+), p n` is a proof that\nthere exists some positive natural number satisfying `p`, then `PNat.find hp` is the\nsmallest positive natural number satisfying `p`. Note that `PNat.find` is protected,\nmeaning that you can't just write `find`, even if the `PNat` namespace is open.\n\nThe API for `PNat.find` is:\n\n* `PNat.find_spec` is the proof that `PNat.find hp` satisfies `p`.\n* `PNat.find_min` is the proof that if `m < PNat.find hp` then `m` does not satisfy `p`.\n* `PNat.find_min'` is the proof that if `m` does satisfy `p` then `PNat.find hp ‚â§ m`.\n",
    "depth": 6},
   {"term": "‚àÄ (p : True ‚Üí Prop), (‚àÉ x, p x) ‚Üî p True.intro",
    "name": "exists_true_left",
    "doc": "See `IsEmpty.exists_iff` for the `False` version. ",
    "depth": 6},
   {"term": "{p : ‚Ñï ‚Üí Prop} ‚Üí [inst : DecidablePred p] ‚Üí (‚àÉ n, p n) ‚Üí ‚Ñï",
    "name": "Nat.find",
    "doc":
    "If `p` is a (decidable) predicate on `‚Ñï` and `hp : ‚àÉ (n : ‚Ñï), p n` is a proof that\nthere exists some natural number satisfying `p`, then `nat.find hp` is the\nsmallest natural number satisfying `p`. Note that `nat.find` is protected,\nmeaning that you can't just write `find`, even if the `nat` namespace is open.\n\nThe API for `nat.find` is:\n\n* `nat.find_spec` is the proof that `nat.find hp` satisfies `p`.\n* `nat.find_min` is the proof that if `m < nat.find hp` then `m` does not satisfy `p`.\n* `nat.find_min'` is the proof that if `m` does satisfy `p` then `nat.find hp ‚â§ m`.\n",
    "depth": 6},
   {"term":
    "{p : Bool ‚Üí Prop} ‚Üí [inst : (b : Bool) ‚Üí Decidable (p b)] ‚Üí Decidable (‚àÉ b, p b)",
    "name": "Bool.decidableExistsBool",
    "doc":
    "If `p b` is decidable for all `b : Bool`, then `‚àÉ b, p b` is decidable ",
    "depth": 6}],
  "count": 6862},
 {"noDocExamples": [],
  "kind": "Lean.Parser.Term.sort",
  "examples":
  [{"term": "Sort u",
    "name": "PEmpty",
    "doc":
    "The universe-polymorphic empty type. Prefer `Empty` or `False` where\npossible.\n",
    "depth": 0},
   {"term": "Sort u",
    "name": "PUnit",
    "doc":
    "The unit type, the canonical type with one element, named `unit` or `()`.\nThis is the universe-polymorphic version of `Unit`; it is preferred to use\n`Unit` instead where applicable.\nFor more information about universe levels: [Types as objects](https://leanprover.github.io/theorem_proving_in_lean4/dependent_type_theory.html#types-as-objects)\n",
    "depth": 0},
   {"term": "Sort u ‚Üí Prop",
    "name": "Countable",
    "doc": "A type `Œ±` is countable if there exists an injective map `Œ± ‚Üí ‚Ñï`. ",
    "depth": 1},
   {"term": "Sort u ‚Üí Type u",
    "name": "PLift",
    "doc": "Universe lifting operation from `Sort u` to `Type u`. ",
    "depth": 1},
   {"term": "Sort u ‚Üí Sort (max 1 u)",
    "name": "Erased",
    "doc":
    "`Erased Œ±` is the same as `Œ±`, except that the elements\nof `Erased Œ±` are erased in the VM in the same way as types\nand proofs. This can be used to track data without storing it\nliterally. ",
    "depth": 1}],
  "count": 6038},
 {"noDocExamples": [],
  "kind": "¬´term_-_¬ª",
  "examples":
  [{"term":
    "‚àÄ (L : List ‚Ñï), List.sum (List.tail L) = List.sum L - List.headI L",
    "name": "List.tail_sum",
    "doc": "This relies on `default ‚Ñï = 0`. ",
    "depth": 8},
   {"term":
    "(fun œÑ => jacobiTheta œÑ - 1) =O[Filter.comap Complex.im Filter.atTop] fun œÑ => rexp (-Real.pi * œÑ.im)",
    "name": "isBigO_at_im_infty_jacobiTheta_sub_one",
    "doc":
    "The norm of `jacobiTheta œÑ - 1` decays exponentially as `im œÑ ‚Üí ‚àû`. ",
    "depth": 9},
   {"term": "‚àÄ {a : ENNReal}, a - ‚ä§ = 0",
    "name": "ENNReal.sub_top",
    "doc":
    "This is a special case of `WithTop.sub_top` in the `ENNReal` namespace ",
    "depth": 9},
   {"term": "‚àÄ {s : Set ‚Ñù}, Metric.Bounded s ‚Üí Metric.diam s = sSup s - sInf s",
    "name": "Real.diam_eq",
    "doc":
    "For a bounded set `s : Set ‚Ñù`, its `Metric.diam` is equal to `sSup s - sInf s`. ",
    "depth": 9},
   {"term":
    "‚àÄ {s : Set ‚Ñù}, Metric.Bounded s ‚Üí EMetric.diam s = ENNReal.ofReal (sSup s - sInf s)",
    "name": "Real.ediam_eq",
    "doc":
    "For a bounded set `s : Set ‚Ñù`, its `EMetric.diam` is equal to `sSup s - sInf s` reinterpreted as\n`‚Ñù‚â•0‚àû`. ",
    "depth": 10}],
  "count": 5899},
 {"noDocExamples": [],
  "kind": "¬´term_^_¬ª",
  "examples":
  [{"term": "‚àÄ {q : ‚Ñï+}, Fintype.card (LucasLehmer.X q) = ‚Üëq ^ 2",
    "name": "LucasLehmer.X.card_eq",
    "doc": "The cardinality of `X` is `q^2`. ",
    "depth": 8},
   {"term": "LinearRecurrence.IsSolution fibRec fun x => goldenConj ^ x",
    "name": "geom_goldConj_isSol_fibRec",
    "doc": "The geometric sequence `fun n ‚Ü¶ œà^n` is a solution of `fibRec`. ",
    "depth": 8},
   {"term": "‚àÄ (a : ‚Ñ§), ‚Üë(Int.natAbs a) ‚â§ a ^ 2",
    "name": "Int.natAbs_le_self_pow_two",
    "doc": "**Alias** of `Int.natAbs_le_self_sq`.",
    "depth": 8},
   {"term": "‚àÄ (b : ‚Ñ§), b ‚â§ b ^ 2",
    "name": "Int.le_self_pow_two",
    "doc": "**Alias** of `Int.le_self_sq`.",
    "depth": 8},
   {"term": "LinearRecurrence.IsSolution fibRec fun x => goldenRatio ^ x",
    "name": "geom_gold_isSol_fibRec",
    "doc": "The geometric sequence `fun n ‚Ü¶ œÜ^n` is a solution of `fibRec`. ",
    "depth": 8}],
  "count": 5633},
 {"noDocExamples": [],
  "kind": "¬´term-_¬ª",
  "examples":
  [{"term": "goldenConj‚Åª¬π = -goldenRatio",
    "name": "inv_goldConj",
    "doc": "The opposite of the golden ratio is the inverse of its conjugate. ",
    "depth": 5},
   {"term": "goldenRatio‚Åª¬π = -goldenConj",
    "name": "inv_gold",
    "doc": "The inverse of the golden ratio is the opposite of its conjugate. ",
    "depth": 5},
   {"term":
    "{x : SetTheory.PGame} ‚Üí SetTheory.PGame.RightMoves x ‚âÉ SetTheory.PGame.LeftMoves (-x)",
    "name": "SetTheory.PGame.toLeftMovesNeg",
    "doc":
    "Turns a right move for `x` into a left move for `-x` and vice versa.\n\nEven though these types are the same (not definitionally so), this is the preferred way to convert\nbetween them. ",
    "depth": 6},
   {"term":
    "{x : SetTheory.PGame} ‚Üí SetTheory.PGame.LeftMoves x ‚âÉ SetTheory.PGame.RightMoves (-x)",
    "name": "SetTheory.PGame.toRightMovesNeg",
    "doc":
    "Turns a left move for `x` into a right move for `-x` and vice versa.\n\nEven though these types are the same (not definitionally so), this is the preferred way to convert\nbetween them. ",
    "depth": 6},
   {"term": "riemannZeta 0 = -1 / 2",
    "name": "riemannZeta_zero",
    "doc": "We have `Œ∂(0) = -1 / 2`. ",
    "depth": 8}],
  "count": 4815},
 {"noDocExamples": [],
  "kind": "term‚Ñ§",
  "examples":
  [{"term": "‚Ñ§",
    "name": "Int.zero",
    "doc": "The number `0 : ‚Ñ§`, as a standalone definition. ",
    "depth": 0},
   {"term": "‚Ñ§",
    "name": "Int.one",
    "doc": "The number `1 : ‚Ñ§`, as a standalone definition. ",
    "depth": 0},
   {"term": "‚Ñ§ ‚Üí ZNum",
    "name": "ZNum.ofInt'",
    "doc": "Converts an `Int` to a `ZNum`. ",
    "depth": 1},
   {"term": "‚Ñï ‚Üí ‚Ñ§",
    "name": "Int.ofNat",
    "doc": "A natural number is an integer (`0` to `‚àû`). ",
    "depth": 1},
   {"term": "‚Ñö ‚Üí ‚Ñ§",
    "name": "Rat.floor",
    "doc":
    "The floor of a rational number `a` is the largest integer less than or equal to `a`. ",
    "depth": 1}],
  "count": 4747},
 {"noDocExamples": [],
  "kind": "¬´term_√ó_¬ª",
  "examples":
  [{"term": "PNat.XgcdType ‚Üí ‚Ñï √ó ‚Ñï",
    "name": "PNat.XgcdType.vp",
    "doc":
    "The map `v` gives the product of the matrix\n[[w, x], [y, z]] = [[wp + 1, x], [y, zp + 1]]\nand the vector [a, b] = [ap + 1, bp + 1].  The map\n`vp` gives [sp, tp] such that v = [sp + 1, tp + 1].\n",
    "depth": 3},
   {"term": "‚ÑÇ ‚âÉ ‚Ñù √ó ‚Ñù",
    "name": "Complex.equivRealProd",
    "doc": "The equivalence between the complex numbers and `‚Ñù √ó ‚Ñù`. ",
    "depth": 3},
   {"term": "‚Ñï √ó ‚Ñï ‚Üí ‚Ñï √ó ‚Ñï",
    "name": "PNat.XgcdType.succ‚ÇÇ",
    "doc": "`succ‚ÇÇ [t.1, t.2] = [t.1.succ, t.2.succ]` ",
    "depth": 3},
   {"term": "ONote ‚Üí ONote √ó ‚Ñï",
    "name": "ONote.split'",
    "doc":
    "Calculate division and remainder of `o` mod œâ.\n`split' o = (a, n)` means `o = œâ * a + n`. ",
    "depth": 3},
   {"term": "‚Ñï ‚Üí ‚Ñï √ó ‚Ñï",
    "name": "Nat.unpair",
    "doc": "Unpairing function for the natural numbers. ",
    "depth": 3}],
  "count": 4725},
 {"noDocExamples": [],
  "kind": "¬´term_‚äÜ_¬ª",
  "examples":
  [{"term": "‚àÄ {x : ZFSet}, ZFSet.IsTransitive x ‚Üí x ‚äÜ ZFSet.powerset x",
    "name": "ZFSet.IsTransitive.subset_powerset",
    "doc":
    "**Alias** of the forward direction of `ZFSet.isTransitive_iff_subset_powerset`.",
    "depth": 6},
   {"term": "‚àÄ {A : Class}, Class.powerset A ‚äÜ A ‚Üí A = Class.univ",
    "name": "Class.eq_univ_of_powerset_subset",
    "doc":
    "An induction principle for sets. If every subset of a class is a member, then the class is\nuniversal. ",
    "depth": 6},
   {"term": "‚àÄ {x : ZFSet}, ZFSet.IsTransitive x ‚Üí ‚ãÉ‚ÇÄ x ‚äÜ x",
    "name": "ZFSet.IsTransitive.sUnion_subset",
    "doc":
    "**Alias** of the forward direction of `ZFSet.isTransitive_iff_sUnion_subset`.",
    "depth": 6},
   {"term":
    "‚àÄ {M : Type u_1} [inst : AddMonoid M] {s : Set M}, s ‚äÜ AddMonoid.Closure s",
    "name": "AddMonoid.subset_closure",
    "doc":
    "A subset of an `AddMonoid` is contained in the `AddSubmonoid` it generates.",
    "depth": 8},
   {"term":
    "‚àÄ {X : Type u_1} [inst : TopologicalSpace X] {s : Set X}, seqClosure s ‚äÜ closure s",
    "name": "seqClosure_subset_closure",
    "doc":
    "The sequential closure of a set is contained in the closure of that set.\nThe converse is not true. ",
    "depth": 8}],
  "count": 4351},
 {"noDocExamples": [],
  "kind": "¬´term‚ä§¬ª",
  "examples":
  [{"term": "{Œ± : Type u_1} ‚Üí Filter.Realizer ‚ä§",
    "name": "Filter.Realizer.top",
    "doc": "`Unit` is a realizer for the top filter ",
    "depth": 5},
   {"term":
    "{C : EReal ‚Üí Sort u_1} ‚Üí C ‚ä• ‚Üí ((a : ‚Ñù) ‚Üí C ‚Üëa) ‚Üí C ‚ä§ ‚Üí (a : EReal) ‚Üí C a",
    "name": "EReal.rec",
    "doc":
    "A recursor for `EReal` in terms of the coercion.\n\nA typical invocation looks like `induction x using EReal.rec`. Note that using `induction`\ndirectly will unfold `EReal` to `Option` which is undesirable.\n\nWhen working in term mode, note that pattern matching can be used directly. ",
    "depth": 7},
   {"term": "{Œ± : Type u_1} ‚Üí (x : WithTop Œ±) ‚Üí x ‚â† ‚ä§ ‚Üí Œ±",
    "name": "WithTop.untop",
    "doc":
    "Deconstruct a `x : WithTop Œ±` to the underlying value in `Œ±`, given a proof that `x ‚â† ‚ä§`. ",
    "depth": 7},
   {"term":
    "‚àÄ {Œ± : Type u_1} {G : SimpleGraph Œ±}, SimpleGraph.IsAcyclic G ‚Üí SimpleGraph.girth G = ‚ä§",
    "name": "SimpleGraph.IsAcyclic.girth_eq_top",
    "doc": "**Alias** of the reverse direction of `SimpleGraph.girth_eq_top`.",
    "depth": 7},
   {"term":
    "{C : ENNReal ‚Üí Sort u_3} ‚Üí C ‚ä§ ‚Üí ((x : NNReal) ‚Üí C ‚Üëx) ‚Üí (x : ENNReal) ‚Üí C x",
    "name": "ENNReal.recTopCoe",
    "doc": "A version of `WithTop.recTopCoe` that uses `ENNReal.some`. ",
    "depth": 8}],
  "count": 4315},
 {"noDocExamples": [],
  "kind": "¬´term¬¨_¬ª",
  "examples":
  [{"term": "¬¨Small.{u, max (u + 1) (v + 1)} Ordinal.{max u v}",
    "name": "not_small_ordinal",
    "doc":
    "The type of ordinals in universe `u` is not `Small.{u}`. This is the type-theoretic analog of\nthe Burali-Forti paradox. ",
    "depth": 2},
   {"term": "{p : Prop} ‚Üí ¬¨p ‚Üí Decidable p",
    "name": "Decidable.isFalse",
    "doc": "Prove that `p` is decidable by supplying a proof of `¬¨p` ",
    "depth": 3},
   {"term": "¬¨Set.Countable Set.univ",
    "name": "Cardinal.not_countable_real",
    "doc":
    "**Non-Denumerability of the Continuum**: The reals are not countable. ",
    "depth": 3},
   {"term": "‚àÄ (p : Prop), p ‚à® ¬¨p",
    "name": "em",
    "doc":
    "**Alias** of `Classical.em`.\n\n---\n\nDiaconescu's theorem: excluded middle from choice, Function extensionality and propositional extensionality. ",
    "depth": 3},
   {"term": "¬¨IsField ‚Ñ§",
    "name": "Int.not_isField",
    "doc": "`‚Ñ§` with its usual ring structure is not a field. ",
    "depth": 3}],
  "count": 3704},
 {"noDocExamples": [],
  "kind": "¬´term_/_¬ª",
  "examples":
  [{"term": "riemannZeta 0 = -1 / 2",
    "name": "riemannZeta_zero",
    "doc": "We have `Œ∂(0) = -1 / 2`. ",
    "depth": 8},
   {"term": "¬¨Summable fun n => 1 / ‚Üën",
    "name": "Real.not_summable_one_div_nat_cast",
    "doc": "Harmonic series is not unconditionally summable. ",
    "depth": 9},
   {"term": "Real.sin (Real.pi / 3) = Real.sqrt 3 / 2",
    "name": "Real.sin_pi_div_three",
    "doc": "The sine of `œÄ / 3` is `‚àö3 / 2`. ",
    "depth": 10},
   {"term": "Real.cos (Real.pi / 6) = Real.sqrt 3 / 2",
    "name": "Real.cos_pi_div_six",
    "doc": "The cosine of `œÄ / 6` is `‚àö3 / 2`. ",
    "depth": 10},
   {"term": "‚àÄ (x : ‚Ñù), Real.cosh x = (rexp x + rexp (-x)) / 2",
    "name": "Real.cosh_eq",
    "doc": "The definition of `cosh` in terms of `exp`. ",
    "depth": 10}],
  "count": 3690},
 {"noDocExamples": [],
  "kind": "¬´term_‚Åª¬π¬ª",
  "examples":
  [{"term": "goldenConj‚Åª¬π = -goldenRatio",
    "name": "inv_goldConj",
    "doc": "The opposite of the golden ratio is the inverse of its conjugate. ",
    "depth": 5},
   {"term": "goldenRatio‚Åª¬π = -goldenConj",
    "name": "inv_gold",
    "doc": "The inverse of the golden ratio is the opposite of its conjugate. ",
    "depth": 5},
   {"term": "SetTheory.PGame.Relabelling 1‚Åª¬π 1",
    "name": "SetTheory.PGame.invOne",
    "doc": "`1‚Åª¬π` has exactly the same moves as `1`. ",
    "depth": 6},
   {"term": "¬¨Summable fun n => (‚Üën)‚Åª¬π",
    "name": "Real.not_summable_nat_cast_inv",
    "doc": "Harmonic series is not unconditionally summable. ",
    "depth": 7},
   {"term": "‚àÄ {p : ‚Ñï} [inst : Fact (Nat.Prime p)], padicNorm p ‚Üëp = (‚Üëp)‚Åª¬π",
    "name": "padicNorm.padicNorm_p_of_prime",
    "doc":
    "The `p`-adic norm of `p` is `p‚Åª¬π` if `p` is prime.\n\nSee also `padicNorm.padicNorm_p` for a version assuming `1 < p`. ",
    "depth": 9}],
  "count": 3040},
 {"noDocExamples": [],
  "kind": "¬´term_‚àò_¬ª",
  "examples":
  [{"term": "Antitone (Stirling.stirlingSeq ‚àò Nat.succ)",
    "name": "Stirling.stirlingSeq'_antitone",
    "doc": "The sequence `stirlingSeq ‚àò succ` is monotone decreasing ",
    "depth": 6},
   {"term": "Antitone (Real.log ‚àò Stirling.stirlingSeq ‚àò Nat.succ)",
    "name": "Stirling.log_stirlingSeq'_antitone",
    "doc": "The sequence `log ‚àò stirlingSeq ‚àò succ` is monotone decreasing ",
    "depth": 7},
   {"term":
    "Cardinal.ord ‚àò Cardinal.aleph' = Ordinal.enumOrd {b | Cardinal.ord (Ordinal.card b) = b}",
    "name": "Cardinal.ord_aleph'_eq_enum_card",
    "doc": "`ord ‚àò aleph'` enumerates the ordinals that are cardinals. ",
    "depth": 8},
   {"term":
    "{C : Type u} ‚Üí\n  CategoryTheory.FreeMonoidalCategory C ‚Üí\n    CategoryTheory.FreeMonoidalCategory.NormalMonoidalObject C ‚Üí\n      (CategoryTheory.Discrete ‚àò CategoryTheory.FreeMonoidalCategory.NormalMonoidalObject) C",
    "name": "CategoryTheory.FreeMonoidalCategory.normalizeObj",
    "doc": "Auxiliary definition for `normalize`. ",
    "depth": 9},
   {"term":
    "(C : Type u) ‚Üí\n  CategoryTheory.Functor (CategoryTheory.FreeMonoidalCategory C)\n    ((CategoryTheory.Discrete ‚àò CategoryTheory.FreeMonoidalCategory.NormalMonoidalObject) C)",
    "name": "CategoryTheory.FreeMonoidalCategory.fullNormalize",
    "doc":
    "The normalization functor for the free monoidal category over `C`. ",
    "depth": 9}],
  "count": 2926},
 {"noDocExamples": [],
  "kind": "¬´term_‚Üí+*_¬ª",
  "examples":
  [{"term": "NNReal ‚Üí+* ‚Ñù",
    "name": "NNReal.toRealHom",
    "doc":
    "Coercion `‚Ñù‚â•0 ‚Üí ‚Ñù` as a `RingHom`.\n\nPorting note: todo: what if we define `Coe ‚Ñù‚â•0 ‚Ñù` using this function? ",
    "depth": 4},
   {"term": "‚Ñï ‚Üí+* ‚Ñ§",
    "name": "Int.ofNatHom",
    "doc": "Coercion `‚Ñï ‚Üí ‚Ñ§` as a `RingHom`. ",
    "depth": 4},
   {"term": "‚Ñù ‚Üí+* ‚ÑÇ",
    "name": "Complex.ofReal",
    "doc": "The coercion `‚Ñù ‚Üí ‚ÑÇ` as a `RingHom`. ",
    "depth": 4},
   {"term": "Unique (‚Ñù ‚Üí+* ‚Ñù)",
    "name": "Real.RingHom.unique",
    "doc": "There exists no nontrivial ring homomorphism `‚Ñù ‚Üí+* ‚Ñù`. ",
    "depth": 5},
   {"term": "(Œ± : Type u_5) ‚Üí [inst : NonAssocSemiring Œ±] ‚Üí Œ± ‚Üí+* Œ±",
    "name": "RingHom.id",
    "doc": "The identity ring homomorphism from a semiring to itself. ",
    "depth": 6}],
  "count": 2858},
 {"noDocExamples": [],
  "kind": "¬´term{_}¬ª",
  "examples":
  [{"term": "Multiset.Nat.antidiagonal 0 = {(0, 0)}",
    "name": "Multiset.Nat.antidiagonal_zero",
    "doc": "The antidiagonal of `0` is the list `[(0, 0)]` ",
    "depth": 7},
   {"term": "Finset.Nat.antidiagonal 0 = {(0, 0)}",
    "name": "Finset.Nat.antidiagonal_zero",
    "doc": "The antidiagonal of `0` is the list `[(0, 0)]` ",
    "depth": 7},
   {"term":
    "‚àÄ {P : Type u_2} [inst : MetricSpace P] (p : P), EuclideanGeometry.Cospherical {p}",
    "name": "EuclideanGeometry.cospherical_singleton",
    "doc": "A single point is cospherical. ",
    "depth": 8},
   {"term":
    "‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {x : Œ±}, Metric.Bounded {x}",
    "name": "Metric.bounded_singleton",
    "doc": "A singleton is bounded ",
    "depth": 8},
   {"term":
    "‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±], TotallyDisconnectedSpace Œ± ‚Üî ‚àÄ (x : Œ±), connectedComponent x = {x}",
    "name": "totallyDisconnectedSpace_iff_connectedComponent_singleton",
    "doc":
    "A space is totally disconnected iff its connected components are singletons. ",
    "depth": 9}],
  "count": 2627},
 {"noDocExamples": [],
  "kind": "¬´term_·µí·µñ¬ª",
  "examples":
  [{"term": "(Œî : SimplexCategory·µí·µñ) ‚Üí SimplicialObject.Splitting.IndexSet Œî",
    "name": "SimplicialObject.Splitting.IndexSet.id",
    "doc":
    "The distinguished element in `Splitting.IndexSet Œî` which corresponds to the\nidentity of `Œî`. ",
    "depth": 2},
   {"term": "SimplexCategory·µí·µñ ‚Üí Type",
    "name": "SimplicialObject.Splitting.IndexSet",
    "doc":
    "The index set which appears in the definition of split simplicial objects. ",
    "depth": 2},
   {"term": "TopCat·µí·µñ ‚Üí TopCommRingCat ‚Üí CommRingCat",
    "name": "TopCat.continuousFunctions",
    "doc":
    "The (bundled) commutative ring of continuous functions from a topological space\nto a topological commutative ring, with pointwise multiplication. ",
    "depth": 2},
   {"term": "{Œ± : Sort u} ‚Üí Œ± ‚âÉ Œ±·µí·µñ",
    "name": "Opposite.equivToOpposite",
    "doc": "The type-level equivalence between a type and its opposite. ",
    "depth": 3},
   {"term": "{Œ± : Sort u} ‚Üí Œ± ‚Üí Œ±·µí·µñ",
    "name": "Opposite.op",
    "doc": "The canonical map `Œ± ‚Üí Œ±·µí·µñ`. ",
    "depth": 3}],
  "count": 2558},
 {"noDocExamples": [],
  "kind": "CategoryTheory.¬´term_‚âÖ_¬ª",
  "examples":
  [{"term": "(V : Type u) ‚Üí ULift.{u, u} V ‚âÖ V",
    "name": "CategoryTheory.uliftTrivial",
    "doc":
    "The isomorphism between a `Type` which has been `ULift`ed to the same universe,\nand the original type.\n",
    "depth": 5},
   {"term":
    "(X : Type u) ‚Üí CategoryTheory.Limits.IsTerminal X ‚âÉ (X ‚âÖ PUnit.{u + 1})",
    "name": "CategoryTheory.Limits.Types.isTerminalEquivIsoPUnit",
    "doc": "A type is terminal if and only if it is isomorphic to `PUnit`. ",
    "depth": 6},
   {"term": "{X Y : Type u} ‚Üí (X ‚âÖ Y) ‚Üí X ‚âÉ Y",
    "name": "CategoryTheory.Iso.toEquiv",
    "doc": "Any isomorphism between types gives an equivalence. ",
    "depth": 7},
   {"term": "{Œ± Œ≤ : PartialFun} ‚Üí Œ± ‚âÉ Œ≤ ‚Üí (Œ± ‚âÖ Œ≤)",
    "name": "PartialFun.Iso.mk",
    "doc":
    "Constructs a partial function isomorphism between types from an equivalence between them. ",
    "depth": 7},
   {"term": "{X Y : Type u} ‚Üí X ‚âÉ Y ‚âÉ (X ‚âÖ Y)",
    "name": "equivEquivIso",
    "doc":
    "Equivalences (between types in the same universe) are the same as (equivalent to) isomorphisms\nof types. ",
    "depth": 7}],
  "count": 2529},
 {"noDocExamples": [],
  "kind": "Lean.Parser.Term.tuple",
  "examples":
  [{"term": "Multiset.Nat.antidiagonal 0 = {(0, 0)}",
    "name": "Multiset.Nat.antidiagonal_zero",
    "doc": "The antidiagonal of `0` is the list `[(0, 0)]` ",
    "depth": 7},
   {"term": "Finset.Nat.antidiagonal 0 = {(0, 0)}",
    "name": "Finset.Nat.antidiagonal_zero",
    "doc": "The antidiagonal of `0` is the list `[(0, 0)]` ",
    "depth": 7},
   {"term": "List.Nat.antidiagonal 0 = [(0, 0)]",
    "name": "List.Nat.antidiagonal_zero",
    "doc": "The antidiagonal of `0` is the list `[(0, 0)]` ",
    "depth": 8},
   {"term":
    "{C : Type u_1} ‚Üí\n  [inst : CategoryTheory.Category.{u_2, u_1} C] ‚Üí\n    {Œ± : Unit ‚Üí C} ‚Üí CategoryTheory.EffectiveEpiFamilyStruct Œ± fun x => CategoryTheory.CategoryStruct.id (Œ± ())",
    "name": "CategoryTheory.effectiveEpiFamilyStructId",
    "doc": "The effective epi family structure on the identity ",
    "depth": 9},
   {"term":
    "{q p : Prop} ‚Üí (q ‚Üí p) ‚Üí SlimCheck.TestResult p ‚Üí optParam (Unit ‚äï' (p ‚Üí q)) (PSum.inl ()) ‚Üí SlimCheck.TestResult q",
    "name": "SlimCheck.TestResult.imp",
    "doc":
    "If `q ‚Üí p`, then `¬¨ p ‚Üí ¬¨ q` which means that testing `p` can allow us\nto find counter-examples to `q`. ",
    "depth": 9}],
  "count": 2516},
 {"noDocExamples": [],
  "kind": "¬´term‚Äñ_‚Äñ¬ª",
  "examples":
  [{"term": "‚àÄ {Œ± : Type u_5} [self : NontriviallyNormedField Œ±], ‚àÉ x, 1 < ‚Äñx‚Äñ",
    "name": "NontriviallyNormedField.non_trivial",
    "doc": "The norm attains a value exceeding 1. ",
    "depth": 10},
   {"term":
    "‚àÄ {Œ± : Type u_5} [inst : Norm Œ±] [inst_1 : One Œ±] [self : NormOneClass Œ±], ‚Äñ1‚Äñ = 1",
    "name": "NormOneClass.norm_one",
    "doc": "The norm of the multiplicative identity is 1. ",
    "depth": 10},
   {"term":
    "{R : Type u_1} ‚Üí [inst : NormedRing R] ‚Üí [inst_1 : CompleteSpace R] ‚Üí (t : R) ‚Üí ‚Äñt‚Äñ < 1 ‚Üí RÀ£",
    "name": "Units.oneSub",
    "doc":
    "In a complete normed ring, a perturbation of `1` by an element `t` of distance less than `1`\nfrom `1` is a unit.  Here we construct its `Units` structure.  ",
    "depth": 11},
   {"term":
    "‚àÄ (V : Type u_1) [inst : SeminormedAddCommGroup V], ‚ÄñNormedAddGroupHom.id V‚Äñ ‚â§ 1",
    "name": "NormedAddGroupHom.norm_id_le",
    "doc":
    "The norm of the identity is at most `1`. It is in fact `1`, except when the norm of every\nelement vanishes, where it is `0`. (Since we are working with seminorms this can happen even if the\nspace is non-trivial.) It means that one can not do better than an inequality in general. ",
    "depth": 11},
   {"term":
    "{p : ‚Ñï} ‚Üí [hp : Fact (Nat.Prime p)] ‚Üí {u : ‚Ñö_[p]} ‚Üí ‚Äñu‚Äñ = 1 ‚Üí ‚Ñ§_[p]À£",
    "name": "PadicInt.mkUnits",
    "doc": "A `p`-adic number `u` with `‚Äñu‚Äñ = 1` is a unit of `‚Ñ§_[p]`. ",
    "depth": 12}],
  "count": 2491},
 {"noDocExamples": [],
  "kind": "¬´term_‚âÉ_¬ª",
  "examples":
  [{"term": "‚Ñï+ ‚âÉ ‚Ñï",
    "name": "Equiv.pnatEquivNat",
    "doc":
    "An equivalence between `‚Ñï+` and `‚Ñï` given by `PNat.natPred` and `Nat.succPNat`. ",
    "depth": 2},
   {"term": "‚Ñ§ ‚âÉ ‚Ñï",
    "name": "Equiv.intEquivNat",
    "doc":
    "An equivalence between `‚Ñ§` and `‚Ñï`, through `‚Ñ§ ‚âÉ ‚Ñï ‚äï ‚Ñï` and `‚Ñï ‚äï ‚Ñï ‚âÉ ‚Ñï`.\n",
    "depth": 2},
   {"term": "Prop ‚âÉ Bool",
    "name": "Equiv.propEquivBool",
    "doc": "`Prop` is noncomputably equivalent to `Bool`. ",
    "depth": 2},
   {"term": "PartENat ‚âÉ ‚Ñï‚àû",
    "name": "PartENat.withTopEquiv",
    "doc":
    "`Equiv` between `PartENat` and `‚Ñï‚àû` (for the order isomorphism see\n`withTopOrderIso`). ",
    "depth": 2},
   {"term": "‚Ñù ‚âÉ ‚Ñù",
    "name": "Real.sinhEquiv",
    "doc": "`Real.sinh` as an `Equiv`. ",
    "depth": 2}],
  "count": 2468},
 {"noDocExamples": [],
  "kind": "¬´term‚ä•¬ª",
  "examples":
  [{"term": "{Œ± : Type u_1} ‚Üí Filter.Realizer ‚ä•",
    "name": "Filter.Realizer.bot",
    "doc": "`Unit` is a realizer for the bottom filter ",
    "depth": 6},
   {"term": "{Œ± : Type u_1} ‚Üí (x : WithBot Œ±) ‚Üí x ‚â† ‚ä• ‚Üí Œ±",
    "name": "WithBot.unbot",
    "doc":
    "Deconstruct a `x : WithBot Œ±` to the underlying value in `Œ±`, given a proof that `x ‚â† ‚ä•`. ",
    "depth": 7},
   {"term":
    "{C : EReal ‚Üí Sort u_1} ‚Üí C ‚ä• ‚Üí ((a : ‚Ñù) ‚Üí C ‚Üëa) ‚Üí C ‚ä§ ‚Üí (a : EReal) ‚Üí C a",
    "name": "EReal.rec",
    "doc":
    "A recursor for `EReal` in terms of the coercion.\n\nA typical invocation looks like `induction x using EReal.rec`. Note that using `induction`\ndirectly will unfold `EReal` to `Option` which is undesirable.\n\nWhen working in term mode, note that pattern matching can be used directly. ",
    "depth": 7},
   {"term":
    "‚àÄ {Œ± : Type u}, TopologicalSpace.induced pure Ultrafilter.topologicalSpace = ‚ä•",
    "name": "induced_topology_pure",
    "doc":
    "The map `pure : Œ± ‚Üí Ultrafilter Œ±` induces on `Œ±` the discrete topology. ",
    "depth": 8},
   {"term":
    "{Œ± : Type u_1} ‚Üí {C : WithBot Œ± ‚Üí Sort u_5} ‚Üí C ‚ä• ‚Üí ((a : Œ±) ‚Üí C ‚Üëa) ‚Üí (n : WithBot Œ±) ‚Üí C n",
    "name": "WithBot.recBotCoe",
    "doc": "Recursor for `WithBot` using the preferred forms `‚ä•` and `‚Üëa`. ",
    "depth": 8}],
  "count": 2444},
 {"noDocExamples": [],
  "kind": "¬´term_‚äì_¬ª",
  "examples":
  [{"term":
    "‚àÄ (m n : ‚Ñï+), PNat.factorMultiset (PNat.gcd m n) = PNat.factorMultiset m ‚äì PNat.factorMultiset n",
    "name": "PNat.factorMultiset_gcd",
    "doc":
    "The gcd and lcm operations on positive integers correspond\nto the inf and sup operations on multisets. ",
    "depth": 9},
   {"term":
    "{Œ± : Type u_1} ‚Üí {f g : Filter Œ±} ‚Üí Filter.Realizer f ‚Üí Filter.Realizer g ‚Üí Filter.Realizer (f ‚äì g)",
    "name": "Filter.Realizer.inf",
    "doc": "Construct a realizer for the inf of two filters ",
    "depth": 11},
   {"term":
    "‚àÄ {Œ± : Type u_1} {m0 : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {f : Filter Œ±},\n  MeasureTheory.Measure.FiniteAtFilter Œº (f ‚äì MeasureTheory.Measure.ae Œº) ‚Üí MeasureTheory.Measure.FiniteAtFilter Œº f",
    "name": "MeasureTheory.Measure.FiniteAtFilter.of_inf_ae",
    "doc":
    "**Alias** of the forward direction of `MeasureTheory.Measure.FiniteAtFilter.inf_ae_iff`.",
    "depth": 11},
   {"term": "‚àÄ {Œ± : Type u} [self : SemilatticeInf Œ±] (a b : Œ±), a ‚äì b ‚â§ b",
    "name": "SemilatticeInf.inf_le_right",
    "doc": "The infimum is a lower bound on the second argument ",
    "depth": 11},
   {"term": "‚àÄ {Œ± : Type u} [self : SemilatticeInf Œ±] (a b : Œ±), a ‚äì b ‚â§ a",
    "name": "SemilatticeInf.inf_le_left",
    "doc": "The infimum is a lower bound on the first argument ",
    "depth": 11}],
  "count": 2116},
 {"noDocExamples": [],
  "kind": "Set.term_''_",
  "examples":
  [{"term": "‚àÄ {Œ± : Type u_1} (s : Set Œ±), (fun x => x) '' s = s",
    "name": "Set.image_id'",
    "doc": "A variant of `image_id` ",
    "depth": 8},
   {"term":
    "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {s : Set Œ±}, Set.Subsingleton s ‚Üí ‚àÄ (f : Œ± ‚Üí Œ≤), Set.Subsingleton (f '' s)",
    "name": "Set.Subsingleton.image",
    "doc": "The image of a subsingleton is a subsingleton. ",
    "depth": 10},
   {"term":
    "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚Üí Œ≤) (s : Set Œ±), Set.Nontrivial (f '' s) ‚Üí Set.Nontrivial s",
    "name": "Set.nontrivial_of_image",
    "doc": "If the image of a set is nontrivial, the set is nontrivial. ",
    "depth": 10},
   {"term":
    "{Œ± : Type u_1} ‚Üí {Œ≤ : Type u_2} ‚Üí (f : Œ± ‚Üí Œ≤) ‚Üí (s : Set Œ±) ‚Üí ‚Üës ‚Üí ‚Üë(f '' s)",
    "name": "Set.imageFactorization",
    "doc":
    "Restriction of `f` to `s` factors through `s.imageFactorization f : s ‚Üí f '' s`. ",
    "depth": 10},
   {"term":
    "{Œ± : Type u_1} ‚Üí {Œ≤ : Type u_2} ‚Üí (f : Œ± ‚Üí Œ≤) ‚Üí (s : Set Œ±) ‚Üí Set.InjOn f s ‚Üí ‚Üës ‚âÉ ‚Üë(f '' s)",
    "name": "Equiv.Set.imageOfInjOn",
    "doc":
    "If a function `f` is injective on a set `s`, then `s` is equivalent to `f '' s`. ",
    "depth": 11}],
  "count": 2105},
 {"noDocExamples": [],
  "kind": "¬´term_‚äî_¬ª",
  "examples":
  [{"term":
    "‚àÄ {L : Type u_1} [inst : TopologicalSpace L] [inst_1 : Sup L] [self : ContinuousSup L],\n  Continuous fun p => p.fst ‚äî p.snd",
    "name": "ContinuousSup.continuous_sup",
    "doc": "The supremum is continuous ",
    "depth": 11},
   {"term": "‚àÄ {Œ± : Type u} [self : SemilatticeSup Œ±] (a b : Œ±), a ‚â§ a ‚äî b",
    "name": "SemilatticeSup.le_sup_left",
    "doc": "The supremum is an upper bound on the first argument ",
    "depth": 11},
   {"term": "‚àÄ {Œ± : Type u} [self : SemilatticeSup Œ±] (a b : Œ±), b ‚â§ a ‚äî b",
    "name": "SemilatticeSup.le_sup_right",
    "doc": "The supremum is an upper bound on the second argument ",
    "depth": 11},
   {"term":
    "‚àÄ {Œ± : Type u} [inst : SemilatticeSup Œ±] {a b : Œ±}, b ‚â§ a ‚Üí a ‚äî b = a",
    "name": "sup_of_le_left",
    "doc": "**Alias** of the reverse direction of `sup_eq_left`.",
    "depth": 12},
   {"term":
    "‚àÄ {Œ± : Type u} [inst : SemilatticeSup Œ±] {a b : Œ±}, a ‚äî b = b ‚Üí a ‚â§ b",
    "name": "le_of_sup_eq",
    "doc": "**Alias** of the forward direction of `sup_eq_right`.",
    "depth": 12}],
  "count": 2040},
 {"noDocExamples": [],
  "kind": "¬´term_‚à®_¬ª",
  "examples":
  [{"term": "‚àÄ (p : Prop), p ‚à® ¬¨p",
    "name": "em",
    "doc":
    "**Alias** of `Classical.em`.\n\n---\n\nDiaconescu's theorem: excluded middle from choice, Function extensionality and propositional extensionality. ",
    "depth": 3},
   {"term": "‚àÄ (p : Prop), p ‚à® ¬¨p",
    "name": "Classical.em",
    "doc":
    "Diaconescu's theorem: excluded middle from choice, Function extensionality and propositional extensionality. ",
    "depth": 3},
   {"term": "‚àÄ (Œ± : Type u_3), Subsingleton Œ± ‚à® Nontrivial Œ±",
    "name": "subsingleton_or_nontrivial",
    "doc": "A type is either a subsingleton or nontrivial. ",
    "depth": 4},
   {"term": "‚àÄ (p : Prop) [inst : Decidable p], p ‚à® ¬¨p",
    "name": "dec_em",
    "doc": "**Alias** of `Decidable.em`.",
    "depth": 4},
   {"term": "‚àÄ {a b : Prop}, a ‚Üí a ‚à® b",
    "name": "Or.inl",
    "doc":
    "`Or.inl` is \"left injection\" into an `Or`. If `h : a` then `Or.inl h : a ‚à® b`. ",
    "depth": 5}],
  "count": 1972},
 {"noDocExamples": [],
  "kind": "¬´term_‚Üí‚Çó[_]_¬ª",
  "examples":
  [{"term": "‚ÑÇ ‚Üí‚Çó[‚Ñù] ‚Ñù",
    "name": "Complex.reLm",
    "doc": "Linear map version of the real part function, from `‚ÑÇ` to `‚Ñù`. ",
    "depth": 11},
   {"term": "‚ÑÇ ‚Üí‚Çó[‚Ñù] ‚Ñù",
    "name": "Complex.imLm",
    "doc":
    "Linear map version of the imaginary part function, from `‚ÑÇ` to `‚Ñù`. ",
    "depth": 11},
   {"term":
    "{R : Type u} ‚Üí [inst : Semiring R] ‚Üí Polynomial R ‚Üí‚Çó[R] Polynomial R",
    "name": "Polynomial.derivative",
    "doc": "`derivative p` is the formal derivative of the polynomial `p` ",
    "depth": 13},
   {"term":
    "{R : Type u_1} ‚Üí [inst : Semiring R] ‚Üí ‚Ñï ‚Üí Polynomial R ‚Üí‚Çó[R] Polynomial R",
    "name": "Polynomial.hasseDeriv",
    "doc":
    "The `k`th Hasse derivative of a polynomial `‚àë a_i X^i` is `‚àë (i.choose k) a_i X^(i-k)`.\nIt satisfies `k! * (hasse_deriv k f) = derivative^[k] f`. ",
    "depth": 14},
   {"term": "{R : Type u_1} ‚Üí [inst : Semiring R] ‚Üí R ‚Üí Polynomial R ‚Üí‚Çó[R] R",
    "name": "Polynomial.leval",
    "doc": "`Polynomial.eval` as linear map ",
    "depth": 14}],
  "count": 1903},
 {"noDocExamples": [],
  "kind": "¬´term_‚à©_¬ª",
  "examples":
  [{"term":
    "‚àÄ {Œ± : Type u} [inst : Preorder Œ±] {s t : Set Œ±}, BddBelow s ‚Üí BddBelow (s ‚à© t)",
    "name": "BddBelow.inter_of_left",
    "doc": "If `s` is bounded, then so is `s ‚à© t` ",
    "depth": 11},
   {"term":
    "‚àÄ {Œ± : Type u} [inst : Preorder Œ±] {s t : Set Œ±}, BddAbove t ‚Üí BddAbove (s ‚à© t)",
    "name": "BddAbove.inter_of_right",
    "doc": "If `t` is bounded, then so is `s ‚à© t` ",
    "depth": 11},
   {"term":
    "‚àÄ {Œ± : Type u} [inst : Preorder Œ±] {s t : Set Œ±}, BddAbove s ‚Üí BddAbove (s ‚à© t)",
    "name": "BddAbove.inter_of_left",
    "doc": "If `s` is bounded, then so is `s ‚à© t` ",
    "depth": 11},
   {"term":
    "‚àÄ {Œ± : Type u} [inst : Preorder Œ±] {s t : Set Œ±}, BddBelow t ‚Üí BddBelow (s ‚à© t)",
    "name": "BddBelow.inter_of_right",
    "doc": "If `t` is bounded, then so is `s ‚à© t` ",
    "depth": 11},
   {"term":
    "‚àÄ {S : Set Ordinal.{u}}, Set.Unbounded (fun x x_1 => x < x_1) S ‚Üí ‚àÄ (a : Ordinal.{u}), Set.Nonempty (S ‚à© Set.Ici a)",
    "name": "Ordinal.enumOrd_def'_nonempty",
    "doc": "The set in `enumOrd_def'` is nonempty. ",
    "depth": 12}],
  "count": 1894},
 {"noDocExamples": [],
  "kind": "Set.¬´term{_|_}¬ª",
  "examples":
  [{"term": "Set.Infinite {p | Nat.Prime p}",
    "name": "Nat.infinite_setOf_prime",
    "doc":
    "A version of `Nat.exists_infinite_primes` using the `Set.Infinite` predicate. ",
    "depth": 4},
   {"term": "Dense {x | Liouville x}",
    "name": "dense_liouville",
    "doc": "The set of Liouville numbers in dense. ",
    "depth": 5},
   {"term": "¬¨BddAbove {p | Nat.Prime p}",
    "name": "Nat.not_bddAbove_setOf_prime",
    "doc":
    "A version of `Nat.exists_infinite_primes` using the `BddAbove` predicate. ",
    "depth": 6},
   {"term": "Set.InjOn Nat.factorization {x | x ‚â† 0}",
    "name": "Nat.factorization_inj",
    "doc": "Every nonzero natural number has a unique prime factorization ",
    "depth": 7},
   {"term": "‚àÄ {b : ‚Ñï}, 1 ‚â§ b ‚Üí Set.Infinite {n | Nat.FermatPsp n b}",
    "name": "Nat.infinite_setOf_pseudoprimes",
    "doc": "Infinite set variant of `Nat.exists_infinite_pseudoprimes`\n",
    "depth": 7}],
  "count": 1885},
 {"noDocExamples": [],
  "kind": "Set.¬´term_‚Åª¬π'_¬ª",
  "examples":
  [{"term": "‚àÄ {s : Set ‚ÑÇ}, Set.Countable s ‚Üí Set.Countable (cexp ‚Åª¬π' s)",
    "name": "Set.Countable.preimage_cexp",
    "doc":
    "**Alias** of the reverse direction of `Complex.countable_preimage_exp`.",
    "depth": 7},
   {"term":
    "{Œ± : Type u} ‚Üí {Œ≤ : Type v} ‚Üí (s : Finset Œ≤) ‚Üí (f : Œ± ‚Üí Œ≤) ‚Üí Set.InjOn f (f ‚Åª¬π' ‚Üës) ‚Üí Finset Œ±",
    "name": "Finset.preimage",
    "doc":
    "Preimage of `s : Finset Œ≤` under a map `f` injective on `f ‚Åª¬π' s` as a `Finset`.  ",
    "depth": 10},
   {"term":
    "{Œ± : Type u_1} ‚Üí {Œ≤ : Type u_2} ‚Üí (t : Set Œ≤) ‚Üí (f : Œ± ‚Üí Œ≤) ‚Üí ‚Üë(f ‚Åª¬π' t) ‚Üí ‚Üët",
    "name": "Set.restrictPreimage",
    "doc": "The restriction of a function onto the preimage of a set. ",
    "depth": 10},
   {"term":
    "‚àÄ {Œ± : Type u_6} {Œ≤ : Type u_7} {f : Œ± ‚Üí Œ≤},\n  Function.Surjective f ‚Üí ‚àÄ (s : Set Œ≤), Set.Subsingleton (f ‚Åª¬π' s) ‚Üí Set.Subsingleton s",
    "name": "Set.subsingleton_of_preimage",
    "doc":
    "If the preimage of a set under a surjective map is a subsingleton,\nthe set is a subsingleton. ",
    "depth": 11},
   {"term":
    "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {s : Set Œ≤},\n  Set.Subsingleton s ‚Üí ‚àÄ {f : Œ± ‚Üí Œ≤}, Function.Injective f ‚Üí Set.Subsingleton (f ‚Åª¬π' s)",
    "name": "Set.Subsingleton.preimage",
    "doc":
    "The preimage of a subsingleton under an injective map is a subsingleton. ",
    "depth": 11}],
  "count": 1872},
 {"noDocExamples": [],
  "kind": "term‚ÑÇ",
  "examples":
  [{"term": "‚ÑÇ",
    "name": "Complex.I",
    "doc": "The imaginary unit. ",
    "depth": 0},
   {"term": "‚ÑÇ ‚Üí ‚ÑÇ",
    "name": "Complex.tan",
    "doc": "The complex tangent function, defined as `sin z / cos z` ",
    "depth": 1},
   {"term": "‚ÑÇ ‚Üí ‚ÑÇ",
    "name": "Complex.GammaIntegral",
    "doc":
    "Euler's integral for the `Œì` function (of a complex variable `s`), defined as\n`‚à´ x in Ioi 0, exp (-x) * x ^ (s - 1)`.\n\nSee `Complex.GammaIntegral_convergent` for a proof of the convergence of the integral for\n`0 < re s`. ",
    "depth": 1},
   {"term": "‚ÑÇ ‚Üí ‚ÑÇ",
    "name": "riemannCompletedZeta‚ÇÄ",
    "doc":
    "The completed Riemann zeta function with its poles removed, `Œõ(s) + 1 / s - 1 / (s - 1)`. ",
    "depth": 1},
   {"term": "‚ÑÇ ‚Üí ‚ÑÇ",
    "name": "Complex.exp",
    "doc": "The complex exponential function, defined via its Taylor series ",
    "depth": 1}],
  "count": 1822},
 {"noDocExamples": [],
  "kind": "¬´term_‚à£_¬ª",
  "examples":
  [{"term": "Function.Injective fun x x_1 => x ‚à£ x_1",
    "name": "Nat.dvd_left_injective",
    "doc": "`dvd` is injective in the left argument ",
    "depth": 7},
   {"term": "‚àÄ {m n : ‚Ñï}, Odd n ‚Üí m ‚à£ n ‚Üí m ‚â† 2",
    "name": "Odd.ne_two_of_dvd_nat",
    "doc": "`2` is not a factor of an odd natural number. ",
    "depth": 8},
   {"term": "‚àÄ {a b : ‚Ñï}, a ‚à£ b ‚Üí b < a ‚Üí b = 0",
    "name": "Nat.eq_zero_of_dvd_of_lt",
    "doc":
    "If a small natural number is divisible by a larger natural number,\nthe small number is zero. ",
    "depth": 8},
   {"term": "‚àÄ {a b : ‚Ñ§}, a ‚à£ b ‚Üí Int.natAbs b < Int.natAbs a ‚Üí b = 0",
    "name": "Int.eq_zero_of_dvd_of_natAbs_lt_natAbs",
    "doc":
    "If an integer with larger absolute value divides an integer, it is\nzero. ",
    "depth": 8},
   {"term": "‚àÄ {n : ‚Ñï}, IsPrimePow n ‚Üî ‚àÉ! p, Nat.Prime p ‚àß p ‚à£ n",
    "name": "isPrimePow_iff_unique_prime_dvd",
    "doc":
    "An equivalent definition for prime powers: `n` is a prime power iff there is a unique prime\ndividing it. ",
    "depth": 9}],
  "count": 1431},
 {"noDocExamples": [],
  "kind": "¬´term‚àÖ¬ª",
  "examples":
  [{"term": "CategoryTheory.Limits.IsInitial ‚àÖ",
    "name": "AlgebraicGeometry.emptyIsInitial",
    "doc":
    "The empty scheme is the initial object in the category of schemes. ",
    "depth": 3},
   {"term":
    "‚àÄ {Œ± : Type u_7} (self : MeasurableSpace Œ±), MeasurableSpace.MeasurableSet' self ‚àÖ",
    "name": "MeasurableSpace.measurableSet_empty",
    "doc":
    "The empty set is a measurable set. Use `MeasurableSet.empty` instead. ",
    "depth": 6},
   {"term":
    "‚àÄ {Œ± : Type u_2} (self : MeasurableSpace.DynkinSystem Œ±), MeasurableSpace.DynkinSystem.Has self ‚àÖ",
    "name": "MeasurableSpace.DynkinSystem.has_empty",
    "doc": "A Dynkin system contains the empty set. ",
    "depth": 6},
   {"term": "‚àÄ {Œ± : Type u} {s : Set Œ±}, Nonempty ‚Üës ‚Üî s ‚â† ‚àÖ",
    "name": "Set.nonempty_iff_ne_empty'",
    "doc": "See also `not_nonempty_iff_eq_empty'`. ",
    "depth": 7},
   {"term": "‚àÄ {Œ± : Type u} {s : Set Œ±}, Set.Nonempty s ‚Üí s ‚â† ‚àÖ",
    "name": "Set.Nonempty.ne_empty",
    "doc":
    "**Alias** of the forward direction of `Set.nonempty_iff_ne_empty`.\n\n---\n\nSee also `Set.not_nonempty_iff_eq_empty`. ",
    "depth": 7}],
  "count": 1427},
 {"noDocExamples": [],
  "kind": "¬´term_‚à™_¬ª",
  "examples":
  [{"term":
    "‚àÄ {Œ± : Type u_1} (s : Set Œ±) (a : Œ±), ùí´ insert a s = ùí´ s ‚à™ insert a '' ùí´ s",
    "name": "Set.powerset_insert",
    "doc":
    "The powerset of `{a} ‚à™ s` is `ùí´ s` together with `{a} ‚à™ t` for each `t ‚àà ùí´ s`. ",
    "depth": 11},
   {"term":
    "‚àÄ {Œ± : Type u} (S T : Set Œ±), Cardinal.mk ‚Üë(S ‚à™ T) ‚â§ Cardinal.mk ‚ÜëS + Cardinal.mk ‚ÜëT",
    "name": "Cardinal.mk_union_le",
    "doc":
    "The cardinality of a union is at most the sum of the cardinalities\nof the two sets. ",
    "depth": 12},
   {"term":
    "‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s t : Set Œ±}, Metric.Bounded s ‚Üí Metric.Bounded t ‚Üí Metric.Bounded (s ‚à™ t)",
    "name": "Metric.Bounded.union",
    "doc": "The union of two bounded sets is bounded. ",
    "depth": 12},
   {"term":
    "‚àÄ {Œ± : Type u_1} {A B : Set (Finset Œ±)} {r : ‚Ñï}, Set.Sized r A ‚àß Set.Sized r B ‚Üí Set.Sized r (A ‚à™ B)",
    "name": "Set.sized.union",
    "doc": "**Alias** of the reverse direction of `Set.sized_union`.",
    "depth": 12},
   {"term":
    "‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s t : Set Œ±}, Metric.Bounded (s ‚à™ t) ‚Üî Metric.Bounded s ‚àß Metric.Bounded t",
    "name": "Metric.bounded_union",
    "doc": "The union of two sets is bounded iff each of the sets is bounded. ",
    "depth": 12}],
  "count": 1362},
 {"noDocExamples": [],
  "kind": "¬´term_‚Üí*_¬ª",
  "examples":
  [{"term": "Multiplicative ‚Ñù ‚Üí* ‚Ñù",
    "name": "Real.expMonoidHom",
    "doc":
    "the exponential function as a monoid hom from `Multiplicative ‚Ñù` to `‚Ñù` ",
    "depth": 5},
   {"term": "Multiplicative ‚Ñù ‚Üí* CircleDeg1LiftÀ£",
    "name": "CircleDeg1Lift.translate",
    "doc":
    "The map `y ‚Ü¶ x + y` as a `CircleDeg1Lift`. More precisely, we define a homomorphism from\n`Multiplicative ‚Ñù` to `CircleDeg1LiftÀ£`, so the translation by `x` is\n`translation (Multiplicative.ofAdd x)`. ",
    "depth": 5},
   {"term": "{Œ± : Type u_2} ‚Üí [inst : MulOneClass Œ±] ‚Üí Œ± ‚Üí* Set Œ±",
    "name": "Set.singletonMonoidHom",
    "doc": "The singleton operation as a `MonoidHom`. ",
    "depth": 6},
   {"term": "{Œ± : Type u_2} ‚Üí [inst : MulOneClass Œ±] ‚Üí Œ± ‚Üí* Filter Œ±",
    "name": "Filter.pureMonoidHom",
    "doc": "`pure` as a `MonoidHom`. ",
    "depth": 6},
   {"term": "(M : Type u_9) ‚Üí [inst : MulOneClass M] ‚Üí M ‚Üí* M",
    "name": "MonoidHom.id",
    "doc": "The identity map from a monoid to itself. ",
    "depth": 6}],
  "count": 1317},
 {"noDocExamples": [],
  "kind": "¬´term_‚Üí‚ÇÄ_¬ª",
  "examples":
  [{"term": "‚Ñï ‚Üí ‚Ñï ‚Üí‚ÇÄ ‚Ñï",
    "name": "Nat.factorization",
    "doc":
    "`n.factorization` is the finitely supported function `‚Ñï ‚Üí‚ÇÄ ‚Ñï`\nmapping each prime factor of `n` to its multiplicity in `n`. ",
    "depth": 4},
   {"term": "{Œ± : Type u_1} ‚Üí (Œ± ‚Üí‚ÇÄ ‚Ñï) ‚Üí ‚Ñï",
    "name": "Finsupp.multinomial",
    "doc":
    "Alternative multinomial definition based on a finsupp, using the support\nfor the big operations\n",
    "depth": 5},
   {"term":
    "{Œ± : Type u_13} ‚Üí {M : Type u_14} ‚Üí [inst : Zero M] ‚Üí (Œ± ‚Üí‚ÇÄ M) ‚Üí Œ± ‚Üí M",
    "name": "Finsupp.toFun",
    "doc":
    "The underlying function of a bundled finitely supported function (aka `Finsupp`). ",
    "depth": 7},
   {"term":
    "{Œ± : Type u_1} ‚Üí {M : Type u_5} ‚Üí [inst : Zero M] ‚Üí (Œ± ‚Üí‚ÇÄ M) ‚Üí Finset (Œ± √ó M)",
    "name": "Finsupp.graph",
    "doc":
    "The graph of a finitely supported function over its support, i.e. the finset of input and output\npairs with non-zero outputs. ",
    "depth": 7},
   {"term":
    "{Œπ : Type u_1} ‚Üí {Œ± : Type u_2} ‚Üí [inst : Zero Œ±] ‚Üí (Œπ ‚Üí‚ÇÄ Œ±) ‚Üí Œπ ‚Üí‚ÇÄ Finset Œ±",
    "name": "Finsupp.rangeSingleton",
    "doc": "Pointwise `Singleton.singleton` bundled as a `Finsupp`. ",
    "depth": 7}],
  "count": 1303},
 {"noDocExamples": [],
  "kind": "¬´term_‚Üí+_¬ª",
  "examples":
  [{"term": "‚Ñï ‚Üí+ PartENat",
    "name": "PartENat.natCast_AddMonoidHom",
    "doc": "The coercion `‚Ñï ‚Üí PartENat` preserves `0` and addition. ",
    "depth": 5},
   {"term": "{Œ± : Type u_2} ‚Üí [inst : AddZeroClass Œ±] ‚Üí Œ± ‚Üí+ Set Œ±",
    "name": "Set.singletonAddMonoidHom",
    "doc": "The singleton operation as an `AddMonoidHom`.",
    "depth": 6},
   {"term": "(Œ± : Type u_3) ‚Üí [inst : AddMonoidWithOne Œ±] ‚Üí ‚Ñï ‚Üí+ Œ±",
    "name": "Nat.castAddMonoidHom",
    "doc": "`Nat.cast : ‚Ñï ‚Üí Œ±` as an `AddMonoidHom`. ",
    "depth": 6},
   {"term": "{Œ± : Type u} ‚Üí [inst : AddMonoid Œ±] ‚Üí Œ± ‚Üí+ WithTop Œ±",
    "name": "WithTop.addHom",
    "doc": "Coercion from `Œ±` to `WithTop Œ±` as an `AddMonoidHom`. ",
    "depth": 6},
   {"term": "‚ÑÇ ‚Üí+ ‚Ñù",
    "name": "Complex.reAddGroupHom",
    "doc":
    "The \"real part\" map, considered as an additive group homomorphism. ",
    "depth": 6}],
  "count": 1286},
 {"noDocExamples": [],
  "kind": "¬´term_·µê·µí·µñ¬ª",
  "examples":
  [{"term": "{Œ± : Type u_1} ‚Üí Œ± ‚Üí Œ±·µê·µí·µñ",
    "name": "MulOpposite.op",
    "doc": "The element of `MulOpposite Œ±` that represents `x : Œ±`. ",
    "depth": 3},
   {"term": "{Œ± : Type u_1} ‚Üí Œ±·µê·µí·µñ ‚Üí Œ±",
    "name": "MulOpposite.unop",
    "doc": "The element of `Œ±` represented by `x : Œ±·µê·µí·µñ`. ",
    "depth": 3},
   {"term": "{Œ± : Type u_1} ‚Üí Œ± ‚âÉ Œ±·µê·µí·µñ",
    "name": "MulOpposite.opEquiv",
    "doc": "The canonical bijection between `Œ±` and `Œ±·µê·µí·µñ`. ",
    "depth": 3},
   {"term":
    "{E : Type u_6} ‚Üí [inst : SeminormedAddGroup E] ‚Üí SeminormedAddGroup E·µê·µí·µñ",
    "name": "MulOpposite.seminormedAddGroup",
    "doc":
    "The (additive) norm on the multiplicative opposite is the same as the norm on the original type.\n\nNote that we do not provide this more generally as `Norm E·µê·µí·µñ`, as this is not always a good\nchoice of norm in the multiplicative `SeminormedGroup E` case.\n\nWe could repeat this instance to provide a `[SeminormedGroup E] : SeminormedGroup E·µÉ·µí·µñ` instance,\nbut that case would likely never be used.\n",
    "depth": 4},
   {"term":
    "{M : Type u_1} ‚Üí [inst : TopologicalSpace M] ‚Üí TopologicalSpace M·µê·µí·µñ",
    "name": "MulOpposite.instTopologicalSpaceMulOpposite",
    "doc":
    "Put the same topological space structure on the opposite monoid as on the original space. ",
    "depth": 4}],
  "count": 1183},
 {"noDocExamples": [],
  "kind": "¬´term_‚ÜíL[_]_¬ª",
  "examples":
  [{"term": "‚Ñù ‚ÜíL[‚Ñù] ‚ÑÇ",
    "name": "Complex.ofRealClm",
    "doc":
    "Continuous linear map version of the canonical embedding of `‚Ñù` in `‚ÑÇ`. ",
    "depth": 13},
   {"term": "‚ÑÇ ‚ÜíL[‚Ñù] ‚Ñù",
    "name": "Complex.imClm",
    "doc":
    "Continuous linear map version of the imaginary part function, from `‚ÑÇ` to `‚Ñù`. ",
    "depth": 14},
   {"term": "‚ÑÇ ‚ÜíL[‚Ñù] ‚Ñù",
    "name": "Complex.reClm",
    "doc":
    "Continuous linear map version of the real part function, from `‚ÑÇ` to `‚Ñù`. ",
    "depth": 14},
   {"term": "{K : Type u_1} ‚Üí [inst : IsROrC K] ‚Üí ‚Ñù ‚ÜíL[‚Ñù] K",
    "name": "IsROrC.ofRealClm",
    "doc": "The `‚Ñù ‚Üí K` coercion, as a continuous linear map ",
    "depth": 15},
   {"term": "{K : Type u_1} ‚Üí [inst : IsROrC K] ‚Üí K ‚ÜíL[‚Ñù] ‚Ñù",
    "name": "IsROrC.imClm",
    "doc":
    "The imaginary part in an `IsROrC` field, as a continuous linear map. ",
    "depth": 18}],
  "count": 1148},
 {"noDocExamples": [],
  "kind": "Set.¬´term‚ãÉ_,_¬ª",
  "examples":
  [{"term":
    "‚àÄ {Œ± : Type u_7} (self : MeasurableSpace Œ±) (f : ‚Ñï ‚Üí Set Œ±),\n  (‚àÄ (i : ‚Ñï), MeasurableSpace.MeasurableSet' self (f i)) ‚Üí MeasurableSpace.MeasurableSet' self (‚ãÉ (i : ‚Ñï), f i)",
    "name": "MeasurableSpace.measurableSet_iUnion",
    "doc":
    "The union of a sequence of measurable sets is a measurable set. Use a more general\n`MeasurableSet.iUnion` instead. ",
    "depth": 8},
   {"term":
    "{Œ± : Type u_1} ‚Üí {Œ≤ : Type u_2} ‚Üí (t : Œ± ‚Üí Set Œ≤) ‚Üí (i : Œ±) √ó ‚Üë(t i) ‚Üí ‚Üë(‚ãÉ (i : Œ±), t i)",
    "name": "Set.sigmaToiUnion",
    "doc":
    "If `t` is an indexed family of sets, then there is a natural map from `Œ£ i, t i` to `‚ãÉ i, t i`\nsending `‚ü®i, x‚ü©` to `x`. ",
    "depth": 8},
   {"term":
    "‚àÄ {Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Finset Œ≤), Set.Finite (Set.range f) ‚Üí Set.Finite (‚ãÉ (a : Œ±), ‚Üë(f a))",
    "name": "Set.union_finset_finite_of_range_finite",
    "doc": "A finite union of finsets is finite. ",
    "depth": 9},
   {"term":
    "‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] {Œπ : Type u_2} [inst_1 : Countable Œπ] {s : Œπ ‚Üí Set Œ±},\n  (‚àÄ (n : Œπ), MeasureTheory.AnalyticSet (s n)) ‚Üí MeasureTheory.AnalyticSet (‚ãÉ (n : Œπ), s n)",
    "name": "MeasureTheory.AnalyticSet.iUnion",
    "doc": "A countable union of analytic sets is analytic. ",
    "depth": 10},
   {"term":
    "‚àÄ {Œ± : Type u_3} [inst : TopologicalSpace Œ±] [self : SigmaCompactSpace Œ±],\n  ‚àÉ K, (‚àÄ (n : ‚Ñï), IsCompact (K n)) ‚àß ‚ãÉ (n : ‚Ñï), K n = Set.univ",
    "name": "SigmaCompactSpace.exists_compact_covering",
    "doc":
    "In a œÉ-compact space, there exists (by definition) a countable collection of compact subspaces\nthat cover the entire space. ",
    "depth": 11}],
  "count": 1115},
 {"noDocExamples": [],
  "kind": "¬´termC(_,_)¬ª",
  "examples":
  [{"term": "C(NNReal, ‚Ñù)",
    "name": "ContinuousMap.coeNNRealReal",
    "doc": "Embedding of `‚Ñù‚â•0` to `‚Ñù` as a bundled continuous map. ",
    "depth": 4},
   {"term": "(Œ± : Type u_1) ‚Üí [inst : TopologicalSpace Œ±] ‚Üí C(Œ±, Œ±)",
    "name": "ContinuousMap.id",
    "doc": "The identity as a continuous map. ",
    "depth": 6},
   {"term":
    "(Œ± : Type u_1) ‚Üí {Œ≤ : Type u_2} ‚Üí [inst : TopologicalSpace Œ≤] ‚Üí C(Œ≤, Œ± ‚Üí Œ≤)",
    "name": "ContinuousMap.constPi",
    "doc": "`Function.const Œ± b` as a bundled continuous function of `b`. ",
    "depth": 7},
   {"term":
    "{R : Type u_1} ‚Üí [inst : TopologicalSpace R] ‚Üí [inst_1 : Star R] ‚Üí [inst_2 : ContinuousStar R] ‚Üí C(R, R)",
    "name": "starContinuousMap",
    "doc": "The star operation bundled as a continuous map. ",
    "depth": 8},
   {"term":
    "(X : Type u_1) ‚Üí [inst : TopologicalSpace X] ‚Üí C(X, TopologicalSpace.Opens X ‚Üí Prop)",
    "name": "TopologicalSpace.productOfMemOpens",
    "doc":
    "The continuous map from `X` to the product of copies of the Sierpinski space, (one copy for each\nopen subset `u` of `X`). The `u` coordinate of `productOfMemOpens x` is given by `x ‚àà u`.\n",
    "depth": 8}],
  "count": 1068},
 {"noDocExamples": [],
  "kind": "¬´term_·∂ú¬ª",
  "examples":
  [{"term": "‚Üë{‚ä•, ‚ä§}·∂ú ‚âÉ ‚Ñù",
    "name": "EReal.neTopBotEquivReal",
    "doc":
    "The set of numbers in `EReal` that are not equal to `¬±‚àû` is equivalent to `‚Ñù`. ",
    "depth": 9},
   {"term":
    "‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±} [self : IsClosed s], IsOpen s·∂ú",
    "name": "IsClosed.isOpen_compl",
    "doc": "The complement of a closed set is an open set. ",
    "depth": 10},
   {"term":
    "‚àÄ {Œ± : Type u_2} (self : MeasurableSpace.DynkinSystem Œ±) {a : Set Œ±},\n  MeasurableSpace.DynkinSystem.Has self a ‚Üí MeasurableSpace.DynkinSystem.Has self a·∂ú",
    "name": "MeasurableSpace.DynkinSystem.has_compl",
    "doc": "A Dynkin system is closed under complementation. ",
    "depth": 10},
   {"term":
    "‚àÄ {Œ± : Type u_2} [inst : Bornology Œ±] {s : Set Œ±}, Bornology.IsBounded s ‚Üí Bornology.IsCobounded s·∂ú",
    "name": "Bornology.IsBounded.compl",
    "doc":
    "**Alias** of the reverse direction of `Bornology.isCobounded_compl_iff`.",
    "depth": 10},
   {"term":
    "‚àÄ {Œ± : Type u_2} [inst : Bornology Œ±] {s : Set Œ±}, Bornology.IsCobounded s ‚Üí Bornology.IsBounded s·∂ú",
    "name": "Bornology.IsCobounded.compl",
    "doc":
    "**Alias** of the reverse direction of `Bornology.isBounded_compl_iff`.",
    "depth": 10}],
  "count": 1046},
 {"noDocExamples": [],
  "kind": "¬´term_·µí·µà¬ª",
  "examples":
  [{"term": "{Œ± : Type u_1} ‚Üí Œ± ‚âÉ Œ±·µí·µà",
    "name": "OrderDual.toDual",
    "doc":
    "`toDual` is the identity function to the `OrderDual` of a linear order.  ",
    "depth": 3},
   {"term": "{Œ± : Type u_1} ‚Üí WithTop Œ± ‚âÉ WithBot Œ±·µí·µà",
    "name": "WithTop.toDual",
    "doc":
    "`WithTop.toDual` is the equivalence sending `‚ä§` to `‚ä•` and any `a : Œ±` to `toDual a : Œ±·µí·µà`.\nSee `WithTop.toDualBotEquiv` for the related order-iso.\n",
    "depth": 4},
   {"term": "{Œ± : Type u_1} ‚Üí Œ±·µí·µà ‚âÉ Œ±",
    "name": "OrderDual.ofDual",
    "doc":
    "`ofDual` is the identity function from the `OrderDual` of a linear order.  ",
    "depth": 4},
   {"term":
    "{Œ± : Type u_1} ‚Üí [inst : NormedLatticeAddCommGroup Œ±] ‚Üí NormedLatticeAddCommGroup Œ±·µí·µà",
    "name": "OrderDual.normedLatticeAddCommGroup",
    "doc":
    "Let `Œ±` be a normed lattice ordered group, then the order dual is also a\nnormed lattice ordered group.\n",
    "depth": 4},
   {"term": "{Œ± : Type u_1} ‚Üí WithBot Œ± ‚âÉ WithTop Œ±·µí·µà",
    "name": "WithBot.toDual",
    "doc":
    "`WithBot.toDual` is the equivalence sending `‚ä•` to `‚ä§` and any `a : Œ±` to `toDual a : Œ±·µí·µà`.\nSee `WithBot.toDual_top_equiv` for the related order-iso.\n",
    "depth": 4}],
  "count": 1029},
 {"noDocExamples": [],
  "kind": "¬´term[_]¬ª",
  "examples":
  [{"term": "‚àÄ {Œ± : Type u_1}, List.Sublist [] []",
    "name": "List.Sublist.slnil",
    "doc": "the base case: `[]` is a sublist of `[]` ",
    "depth": 4},
   {"term": "‚àÄ {Œ± : Type u_1} {R : Œ± ‚Üí Œ± ‚Üí Prop}, List.Pairwise R []",
    "name": "List.Pairwise.nil",
    "doc": "All elements of the empty list are vacuously pairwise related. ",
    "depth": 5},
   {"term": "Lean.Expr ‚Üí optParam (List (List ‚Ñï)) [] ‚Üí Lean.MetaM Lean.Expr",
    "name": "ToAdditive.reorderLambda",
    "doc":
    "Reorder lambda-binders. See doc of `reorderAttr` for the interpretation of the argument ",
    "depth": 6},
   {"term": "Lean.Expr ‚Üí optParam (List (List ‚Ñï)) [] ‚Üí Lean.MetaM Lean.Expr",
    "name": "ToAdditive.reorderForall",
    "doc":
    "Reorder pi-binders. See doc of `reorderAttr` for the interpretation of the argument ",
    "depth": 6},
   {"term": "‚àÄ {Œ± : Type u_1} {l : List Œ±}, l <+: [] ‚Üí l = []",
    "name": "List.eq_nil_of_prefix_nil",
    "doc": "**Alias** of the forward direction of `List.prefix_nil`.",
    "depth": 7}],
  "count": 1027},
 {"noDocExamples": [],
  "kind": "termIfThenElse",
  "examples":
  [{"term":
    "‚àÄ {Œ± : Sort u_2} (P : Prop) [inst : Decidable P] (a b : Œ±), (if x : P then a else b) = if P then a else b",
    "name": "dite_eq_ite",
    "doc":
    "A `dite` whose results do not actually depend on the condition may be reduced to an `ite`. ",
    "depth": 12},
   {"term":
    "‚àÄ {Œ± : Sort u_1} (P : Prop) [inst : Decidable P] (x y : Œ±), (if ¬¨P then x else y) = if P then y else x",
    "name": "ite_not",
    "doc":
    "Negation of the condition `P : Prop` in a `ite` is the same as swapping the branches. ",
    "depth": 12},
   {"term":
    "{Œ± : Sort u_1} ‚Üí\n  {c : Prop} ‚Üí\n    [inst : Decidable c] ‚Üí\n      {motive : Œ± ‚Üí Sort u_2} ‚Üí {t e : Œ±} ‚Üí (c ‚Üí motive t) ‚Üí (¬¨c ‚Üí motive e) ‚Üí motive (if c then t else e)",
    "name": "iteInduction",
    "doc":
    "Split an if-then-else into cases. The `split` tactic is generally easier to use than this theorem. ",
    "depth": 14},
   {"term":
    "‚àÄ {Œ± : Sort u} {f : Œ± ‚Üí Œ±},\n  Function.Involutive f ‚Üí ‚àÄ (P : Prop) [inst : Decidable P] (x : Œ±), f (if P then x else f x) = if ¬¨P then x else f x",
    "name": "Function.Involutive.ite_not",
    "doc":
    "Involuting an `ite` of an involuted value `x : Œ±` negates the `Prop` condition in the `ite`. ",
    "depth": 14},
   {"term":
    "‚àÄ {Œ± : Sort u_1} {Œ≤ : Sort u_2} (f : Œ± ‚Üí Œ≤) (P : Prop) [inst : Decidable P] (x y : Œ±),\n  f (if P then x else y) = if P then f x else f y",
    "name": "apply_ite",
    "doc":
    "A function applied to a `ite` is a `ite` of that function applied to each of the branches. ",
    "depth": 15}],
  "count": 999},
 {"noDocExamples": [],
  "kind": "¬´term_‚ß∏_¬ª",
  "examples":
  [{"term":
    "{Œ± : Type u_1} ‚Üí [inst : Group Œ±] ‚Üí (s : Subgroup Œ±) ‚Üí Quotient (QuotientGroup.rightRel s) ‚âÉ Œ± ‚ß∏ s",
    "name": "QuotientGroup.quotientRightRelEquivQuotientLeftRel",
    "doc": "Right cosets are in bijection with left cosets. ",
    "depth": 9},
   {"term": "{Œ± : Type u_1} ‚Üí [inst : Group Œ±] ‚Üí {s : Subgroup Œ±} ‚Üí Œ± ‚Üí Œ± ‚ß∏ s",
    "name": "QuotientGroup.mk",
    "doc": "The canonical map from a group `Œ±` to the quotient `Œ± ‚ß∏ s`. ",
    "depth": 9},
   {"term":
    "{Œ± : Type u_1} ‚Üí [inst : AddGroup Œ±] ‚Üí {s : AddSubgroup Œ±} ‚Üí Œ± ‚Üí Œ± ‚ß∏ s",
    "name": "QuotientAddGroup.mk",
    "doc": "The canonical map from an `AddGroup` `Œ±` to the quotient `Œ± ‚ß∏ s`.",
    "depth": 9},
   {"term":
    "{Œ± : Type u_1} ‚Üí [inst : AddGroup Œ±] ‚Üí (s : AddSubgroup Œ±) ‚Üí Quotient (QuotientAddGroup.rightRel s) ‚âÉ Œ± ‚ß∏ s",
    "name": "QuotientAddGroup.quotientRightRelEquivQuotientLeftRel",
    "doc": "Right cosets are in bijection with left cosets.",
    "depth": 9},
   {"term":
    "‚àÄ {G : Type u_1} [inst : Group G], Group.IsNilpotent (G ‚ß∏ Subgroup.center G) ‚Üí Group.IsNilpotent G",
    "name": "of_quotient_center_nilpotent",
    "doc": "If the quotient by `center G` is nilpotent, then so is G. ",
    "depth": 10}],
  "count": 973},
 {"noDocExamples": [],
  "kind": "¬´term_+·µ•_¬ª",
  "examples":
  [{"term":
    "‚àÄ {M : Type u_1} (c : M) (X : Type u_2) [inst : VAdd M X] [inst_1 : TopologicalSpace X] [h : ProperConstVAdd M X],\n  IsProperMap fun x => c +·µ• x",
    "name": "isProperMap_vadd",
    "doc": "`(c +·µ• ¬∑)` is a proper map.",
    "depth": 14},
   {"term":
    "‚àÄ {M : Type u_1} {X : Type u_2} [inst : VAdd M X] [inst_1 : TopologicalSpace M] [inst_2 : TopologicalSpace X]\n  [self : ContinuousVAdd M X], Continuous fun p => p.fst +·µ• p.snd",
    "name": "ContinuousVAdd.continuous_vadd",
    "doc": "The additive action `(+·µ•)` is continuous. ",
    "depth": 14},
   {"term":
    "‚àÄ {M : Type u_1} {X : Type u_2} [inst : VAdd M X] [inst_1 : TopologicalSpace X] [self : ProperConstVAdd M X] (c : M),\n  IsProperMap fun x => c +·µ• x",
    "name": "ProperConstVAdd.isProperMap_vadd",
    "doc": "`(c +·µ• ¬∑)` is a proper map. ",
    "depth": 14},
   {"term":
    "‚àÄ {Œì : Type u_1} {T : Type u_2} [inst : TopologicalSpace T] [inst_1 : VAdd Œì T] [self : ContinuousConstVAdd Œì T]\n  (Œ≥ : Œì), Continuous fun x => Œ≥ +·µ• x",
    "name": "ContinuousConstVAdd.continuous_const_vadd",
    "doc":
    "The additive action `(+·µ•) : Œì ‚Üí T ‚Üí T` is continuous in the second argument. ",
    "depth": 14},
   {"term":
    "‚àÄ {G : Type u_10} {P : Type u_11} [inst : AddMonoid G] [self : AddAction G P] (p : P), 0 +·µ• p = p",
    "name": "AddAction.zero_vadd",
    "doc": "Zero is a neutral element for `+·µ•` ",
    "depth": 15}],
  "count": 947},
 {"noDocExamples": [],
  "kind": "Rat.term‚Ñö",
  "examples":
  [{"term": "Div ‚Ñö",
    "name": "Rat.instDivRat",
    "doc":
    "Division of rational numbers. Note: `div a 0 = 0`.  Written with a separate function `Rat.div`\nas a wrapper so that the definition is not unfolded at `.instance` transparency. ",
    "depth": 1},
   {"term": "Denumerable ‚Ñö",
    "name": "Rat.instDenumerableRat",
    "doc": "**Denumerability of the Rational Numbers** ",
    "depth": 1},
   {"term": "‚Ñö ‚Üí ‚Ñï+",
    "name": "Rat.pnatDen",
    "doc": "Denominator as `‚Ñï+`. ",
    "depth": 1},
   {"term": "‚Ñö ‚Üí ‚Ñ§",
    "name": "Rat.floor",
    "doc":
    "The floor of a rational number `a` is the largest integer less than or equal to `a`. ",
    "depth": 1},
   {"term": "‚Ñö ‚Üí NNRat",
    "name": "Rat.toNNRat",
    "doc":
    "Reinterpret a rational number `q` as a non-negative rational number. Returns `0` if `q ‚â§ 0`. ",
    "depth": 1}],
  "count": 891},
 {"noDocExamples": [],
  "kind": "¬´term_À£¬ª",
  "examples":
  [{"term": "{n : ‚Ñï} ‚Üí Equiv.Perm (Fin n) ‚Üí ‚Ñ§À£",
    "name": "Equiv.Perm.signAux",
    "doc":
    "`signAux œÉ` is the sign of a permutation on `Fin n`, defined as the parity of the number of\npairs `(x‚ÇÅ, x‚ÇÇ)` such that `x‚ÇÇ < x‚ÇÅ` but `œÉ x‚ÇÅ ‚â§ œÉ x‚ÇÇ` ",
    "depth": 4},
   {"term": "{M : Type u_6} ‚Üí [inst : Monoid M] ‚Üí MÀ£ ‚Üí Equiv.Perm M",
    "name": "Units.mulRight",
    "doc":
    "Right multiplication by a unit of a monoid is a permutation of the underlying type. ",
    "depth": 5},
   {"term": "{Œ± : Type u} ‚Üí [inst : Monoid Œ±] ‚Üí Inv Œ±À£",
    "name": "Units.instInv",
    "doc": "The inverse of a unit in a `Monoid`. ",
    "depth": 5},
   {"term": "(p : ‚Ñï) ‚Üí (LucasLehmer.X (LucasLehmer.q p))À£",
    "name": "LucasLehmer.œâUnit",
    "doc": "`œâ` as an element of the group of units. ",
    "depth": 5},
   {"term": "{Œ± : Type u} ‚Üí [inst : Monoid Œ±] ‚Üí Œ±À£ ‚Üí Œ±",
    "name": "Units.inv",
    "doc": "The inverse value of `val` in the base `Monoid`. ",
    "depth": 5}],
  "count": 875},
 {"noDocExamples": [],
  "kind": "¬´term‚®Ö_,_¬ª",
  "examples":
  [{"term":
    "‚àÄ {Œ± : Type u_1} {Œ≥ : Type u_3} {Œπ : Type u_4} {u : Œπ ‚Üí UniformSpace Œ≥},\n  UniformFun.uniformSpace Œ± Œ≥ = ‚®Ö (i : Œπ), UniformFun.uniformSpace Œ± Œ≥",
    "name": "UniformFun.iInf_eq",
    "doc":
    "If `u` is a family of uniform structures on `Œ≥`, then\n`ùí∞(Œ±, Œ≥, (‚®Ö i, u i)) = ‚®Ö i, ùí∞(Œ±, Œ≥, u i)`. ",
    "depth": 12},
   {"term":
    "{Œ± : Type u_1} ‚Üí [inst : Group Œ±] ‚Üí {Œπ : Type u_2} ‚Üí (f : Œπ ‚Üí Subgroup Œ±) ‚Üí Œ± ‚ß∏ ‚®Ö (i : Œπ), f i ‚Ü™ (i : Œπ) ‚Üí Œ± ‚ß∏ f i",
    "name": "Subgroup.quotientiInfEmbedding",
    "doc": "The natural embedding `Œ± ‚ß∏ (‚®Ö i, f i) ‚Ü™ Œ† i, Œ± ‚ß∏ f i`. ",
    "depth": 13},
   {"term":
    "{Œ± : Type u_1} ‚Üí [inst : AddGroup Œ±] ‚Üí {Œπ : Type u_2} ‚Üí (f : Œπ ‚Üí AddSubgroup Œ±) ‚Üí Œ± ‚ß∏ ‚®Ö (i : Œπ), f i ‚Ü™ (i : Œπ) ‚Üí Œ± ‚ß∏ f i",
    "name": "AddSubgroup.quotientiInfEmbedding",
    "doc": "The natural embedding `Œ± ‚ß∏ (‚®Ö i, f i) ‚Ü™ Œ† i, Œ± ‚ß∏ f i`.",
    "depth": 13},
   {"term":
    "‚àÄ (M : Type u_1) (Œ± : Type u_2) [inst : Group M] [inst_1 : MulAction M Œ±] {Œπ : Sort u_3} {s : Œπ ‚Üí Set Œ±},\n  fixingSubgroup M (‚ãÉ (i : Œπ), s i) = ‚®Ö (i : Œπ), fixingSubgroup M (s i)",
    "name": "fixingSubgroup_iUnion",
    "doc": "Fixing subgroup of iUnion is intersection ",
    "depth": 14},
   {"term":
    "‚àÄ {Œ± : Type u_1} [inst : CompleteLattice Œ±] {p q : Prop} {s : p ‚Üí q ‚Üí Œ±},\n  ‚®Ö (h‚ÇÅ : p) (h‚ÇÇ : q), s h‚ÇÅ h‚ÇÇ = ‚®Ö (h : p ‚àß q), s (_ : p) (_ : q)",
    "name": "iInf_and'",
    "doc":
    "The symmetric case of `iInf_and`, useful for rewriting into an infimum over a conjunction ",
    "depth": 14}],
  "count": 857},
 {"noDocExamples": [],
  "kind": "¬´term‚®Ü_,_¬ª",
  "examples":
  [{"term":
    "‚àÄ {Œπ : Sort u_1} {f : Œπ ‚Üí ‚Ñù}, (‚àÄ (i : Œπ), 0 ‚â§ f i) ‚Üí 0 ‚â§ ‚®Ü (i : Œπ), f i",
    "name": "Real.iSup_nonneg",
    "doc":
    "As `0` is the default value for `Real.sSup` of the empty set or sets which are not bounded above, it\nsuffices to show that `f i` is nonnegative to show that `0 ‚â§ ‚®Ü i, f i`.\n",
    "depth": 9},
   {"term":
    "{Œ± : Type u_1} ‚Üí\n  {Œ≤ : Type u_2} ‚Üí {f : Œ± ‚Üí Filter Œ≤} ‚Üí ((i : Œ±) ‚Üí Filter.Realizer (f i)) ‚Üí Filter.Realizer (‚®Ü (i : Œ±), f i)",
    "name": "Filter.Realizer.iSup",
    "doc": "Construct a realizer for indexed supremum ",
    "depth": 12},
   {"term":
    "‚àÄ {Œπ : Type v} {f : Œπ ‚Üí Cardinal.{w}},\n  BddAbove (Set.range f) ‚Üí Cardinal.lift.{u, w} (iSup f) = ‚®Ü (i : Œπ), Cardinal.lift.{u, w} (f i)",
    "name": "Cardinal.lift_iSup",
    "doc": "The lift of a supremum is the supremum of the lifts. ",
    "depth": 13},
   {"term":
    "‚àÄ {Œ± : Type u_1} [inst : UniformSpace Œ±] [inst_1 : CompactSpace Œ±], uniformity Œ± = ‚®Ü (x : Œ±), nhds (x, x)",
    "name": "compactSpace_uniformity",
    "doc":
    "On a compact uniform space, the topology determines the uniform structure, entourages are\nexactly the neighborhoods of the diagonal. ",
    "depth": 13},
   {"term":
    "‚àÄ {Œ± : Type ua} [inst : UniformSpace Œ±], ‚®Ü (x : Œ±), nhds (x, x) ‚â§ uniformity Œ±",
    "name": "iSup_nhds_le_uniformity",
    "doc": "Entourages are neighborhoods of the diagonal. ",
    "depth": 13}],
  "count": 854},
 {"noDocExamples": [],
  "kind": "¬´term_\\_¬ª",
  "examples":
  [{"term": "‚àÄ {Œ± : Type u_4} [self : CoheytingAlgebra Œ±] (a : Œ±), ‚ä§ \\ a = Ôø¢a",
    "name": "CoheytingAlgebra.top_sdiff",
    "doc": "`‚ä§ \\ a` is `Ôø¢a` ",
    "depth": 11},
   {"term": "‚àÄ {Œ± : Type u_4} [self : BiheytingAlgebra Œ±] (a : Œ±), ‚ä§ \\ a = Ôø¢a",
    "name": "BiheytingAlgebra.top_sdiff",
    "doc": "`‚ä§ \\ a` is `Ôø¢a` ",
    "depth": 12},
   {"term":
    "{Œ± : Type u_1} ‚Üí\n  [inst : GeneralizedBooleanAlgebra Œ±] ‚Üí\n    [inst_1 : DecidableEq Œ±] ‚Üí {a : Œ±} ‚Üí Finpartition a ‚Üí (b : Œ±) ‚Üí Finpartition (a \\ b)",
    "name": "Finpartition.avoid",
    "doc": "Restricts a finpartition to avoid a given element. ",
    "depth": 12},
   {"term":
    "‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s t : Set Œ±}, IsCompact s ‚Üí IsOpen t ‚Üí IsCompact (s \\ t)",
    "name": "IsCompact.diff",
    "doc":
    "The set difference of a compact set and an open set is a compact set. ",
    "depth": 12},
   {"term":
    "‚àÄ {Œ± : Type u} [self : BooleanAlgebra Œ±] (x y : Œ±), x \\ y = x ‚äì y·∂ú",
    "name": "BooleanAlgebra.sdiff_eq",
    "doc": "`x \\ y` is equal to `x ‚äì y·∂ú` ",
    "depth": 12}],
  "count": 854},
 {"noDocExamples": [],
  "kind": "¬´term_‚äï_¬ª",
  "examples":
  [{"term": "‚Ñï ‚âÉ ‚Ñï ‚äï PUnit.{u_1 + 1}",
    "name": "Equiv.natEquivNatSumPUnit",
    "doc": "The set of natural numbers is equivalent to `‚Ñï ‚äï PUnit`. ",
    "depth": 3},
   {"term": "‚Ñ§ ‚âÉ ‚Ñï ‚äï ‚Ñï",
    "name": "Equiv.intEquivNatSumNat",
    "doc": "The type of integer numbers is equivalent to `‚Ñï ‚äï ‚Ñï`. ",
    "depth": 3},
   {"term": "Bool ‚âÉ PUnit.{u + 1} ‚äï PUnit.{v + 1}",
    "name": "Equiv.boolEquivPUnitSumPUnit",
    "doc": "`Bool` is equivalent the sum of two `PUnit`s. ",
    "depth": 3},
   {"term": "WType.NatŒ± ‚âÉ PUnit.{u + 1} ‚äï PUnit.{u_1 + 1}",
    "name": "WType.NatŒ±EquivPUnitSumPUnit",
    "doc":
    "`WType.NatŒ±` is equivalent to `PUnit ‚äï PUnit`.\nThis is useful when considering the associated polynomial endofunctor.\n",
    "depth": 3},
   {"term": "‚Ñï ‚äï PUnit.{u_1 + 1} ‚âÉ ‚Ñï",
    "name": "Equiv.natSumPUnitEquivNat",
    "doc": "`‚Ñï ‚äï PUnit` is equivalent to `‚Ñï`. ",
    "depth": 4}],
  "count": 828},
 {"noDocExamples": [],
  "kind": "¬´term_√óÀ¢_¬ª",
  "examples":
  [{"term":
    "‚àÄ {Œ± : Type u_1} {f : Filter Œ±} {p : Œ± √ó Œ± ‚Üí Prop}, (‚àÄ·∂† (i : Œ± √ó Œ±) in f √óÀ¢ f, p i) ‚Üí ‚àÄ·∂† (i : Œ±) in f, p (i, i)",
    "name": "Filter.Eventually.diag_of_prod",
    "doc":
    "A fact that is eventually true about all pairs `l √óÀ¢ l` is eventually true about\nall diagonal pairs `(i, i)` ",
    "depth": 12},
   {"term":
    "{Œ± : Type u_1} ‚Üí {Œ≤ : Type u_2} ‚Üí (s : Set Œ±) ‚Üí (t : Set Œ≤) ‚Üí ‚Üë(s √óÀ¢ t) ‚âÉ ‚Üës √ó ‚Üët",
    "name": "Equiv.Set.prod",
    "doc":
    "The set product of two sets is equivalent to the type product of their coercions to types. ",
    "depth": 14},
   {"term":
    "‚àÄ {Œ± : Type u_1} {Ixx : Œ± ‚Üí Œ± ‚Üí Set Œ±} {l‚ÇÅ : Filter Œ±} {l‚ÇÇ : outParam (Filter Œ±)}\n  [self : Filter.TendstoIxxClass Ixx l‚ÇÅ l‚ÇÇ], Filter.Tendsto (fun p => Ixx p.fst p.snd) (l‚ÇÅ √óÀ¢ l‚ÇÅ) (Filter.smallSets l‚ÇÇ)",
    "name": "Filter.TendstoIxxClass.tendsto_Ixx",
    "doc":
    "`Function.uncurry Ixx` tends to `l‚ÇÇ.smallSets` along `l‚ÇÅ √óÀ¢ l‚ÇÅ`. In other words, for any\n`s ‚àà l‚ÇÇ` there exists `t ‚àà l‚ÇÅ` such that `Ixx x y ‚äÜ s` whenever `x ‚àà t` and `y ‚àà t`.\n\nUse lemmas like `Filter.Tendsto.Icc` instead. ",
    "depth": 14},
   {"term":
    "‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {s : Set Œ±} {t : Set Œ≤},\n  Dense s ‚Üí Dense t ‚Üí Dense (s √óÀ¢ t)",
    "name": "Dense.prod",
    "doc": "The product of two dense sets is a dense set. ",
    "depth": 16},
   {"term":
    "‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {s : Set Œ±} {t : Set Œ≤},\n  IsOpen (s √óÀ¢ t) ‚Üî IsOpen s ‚àß IsOpen t ‚à® s = ‚àÖ ‚à® t = ‚àÖ",
    "name": "isOpen_prod_iff'",
    "doc":
    "A product set is open in a product space if and only if each factor is open, or one of them is\nempty ",
    "depth": 16}],
  "count": 815},
 {"noDocExamples": [],
  "kind": "¬´term_‚Üí‚Çê[_]_¬ª",
  "examples":
  [{"term": "‚Ñù ‚Üí‚Çê[‚Ñù] ‚ÑÇ",
    "name": "Complex.ofRealAm",
    "doc":
    "`‚Ñù`-algebra morphism version of the canonical embedding of `‚Ñù` in `‚ÑÇ`. ",
    "depth": 8},
   {"term": "‚ÑÇ ‚Üí‚Çê[‚Ñù] Quaternion ‚Ñù",
    "name": "Quaternion.ofComplex",
    "doc": "Coercion `‚ÑÇ ‚Üí‚Çê[‚Ñù] ‚Ñç` as an algebra homomorphism. ",
    "depth": 9},
   {"term":
    "{R : Type u_1} ‚Üí [inst : CommSemiring R] ‚Üí Polynomial R ‚Üí‚Çê[R] LaurentPolynomial R",
    "name": "Polynomial.toLaurentAlg",
    "doc":
    "The `R`-algebra map, taking a polynomial with coefficients in `R` to a Laurent polynomial\nwith coefficients in `R`. ",
    "depth": 12},
   {"term": "‚ÑÇ ‚Üí‚Çê[‚Ñù] CliffordAlgebra CliffordAlgebraComplex.Q",
    "name": "CliffordAlgebraComplex.ofComplex",
    "doc":
    "Intermediate result for `CliffordAlgebraComplex.equiv`: `‚ÑÇ` can be converted to\n`CliffordAlgebraComplex.Q` above can be converted to. ",
    "depth": 12},
   {"term": "{K : Type u_1} ‚Üí [inst : IsROrC K] ‚Üí ‚Ñù ‚Üí‚Çê[‚Ñù] K",
    "name": "IsROrC.ofRealAm",
    "doc": "The `‚Ñù ‚Üí K` coercion, as a linear map ",
    "depth": 12}],
  "count": 803},
 {"noDocExamples": [],
  "kind": "¬´term_::_¬ª",
  "examples":
  [{"term": "‚àÄ {Œ± : Type u} {a : Œ±} (as : List Œ±), List.Mem a (a :: as)",
    "name": "List.Mem.head",
    "doc": "The head of a list is a member: `a ‚àà a :: as`. ",
    "depth": 7},
   {"term":
    "‚àÄ {Œ± : Type u} [inst : LT Œ±] (b : Œ±) (bs : List Œ±), List.lt [] (b :: bs)",
    "name": "List.lt.nil",
    "doc": "`[]` is the smallest element in the order. ",
    "depth": 8},
   {"term":
    "‚àÄ {Œ± : Type u_1} {l‚ÇÅ l‚ÇÇ : List Œ±} (a : Œ±), List.Sublist l‚ÇÅ l‚ÇÇ ‚Üí List.Sublist l‚ÇÅ (a :: l‚ÇÇ)",
    "name": "List.Sublist.cons",
    "doc":
    "If `l‚ÇÅ` is a subsequence of `l‚ÇÇ`, then it is also a subsequence of `a :: l‚ÇÇ`. ",
    "depth": 9},
   {"term":
    "‚àÄ {Œ± : Type u} {a : Œ±} (b : Œ±) {as : List Œ±}, List.Mem a as ‚Üí List.Mem a (b :: as)",
    "name": "List.Mem.tail",
    "doc":
    "A member of the tail of a list is a member of the list: `a ‚àà l ‚Üí a ‚àà b :: l`. ",
    "depth": 9},
   {"term":
    "‚àÄ {Œ± : Type uu} (a : Œ±) {l‚ÇÅ l‚ÇÇ : List Œ±}, l‚ÇÅ <+~ l‚ÇÇ ‚Üí a :: l‚ÇÅ <+~ a :: l‚ÇÇ",
    "name": "List.subperm.cons",
    "doc": "**Alias** of the reverse direction of `List.subperm_cons`.",
    "depth": 10}],
  "count": 800},
 {"noDocExamples": [],
  "kind": "Filter.¬´term_=·∂†[_]_¬ª",
  "examples":
  [{"term":
    "‚àÄ {Œ± : Type u_1} {m : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {f g : MeasureTheory.SimpleFunc Œ± ENNReal},\n  ‚Üëf =·∂†[MeasureTheory.Measure.ae Œº] ‚Üëg ‚Üí MeasureTheory.SimpleFunc.lintegral f Œº = MeasureTheory.SimpleFunc.lintegral g Œº",
    "name": "MeasureTheory.SimpleFunc.lintegral_congr",
    "doc":
    "If two simple functions are equal a.e., then their `lintegral`s are equal. ",
    "depth": 12},
   {"term":
    "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {l : Filter Œ±} {f g : Œ± ‚Üí Œ≤}, f =·∂†[l] g ‚Üí ‚Üëf = ‚Üëg",
    "name": "Filter.EventuallyEq.germ_eq",
    "doc": "**Alias** of the reverse direction of `Filter.Germ.coe_eq`.",
    "depth": 12},
   {"term":
    "‚àÄ {Œ± : Type u} {Œ≤ : Type v} {m‚ÇÅ m‚ÇÇ : Œ± ‚Üí Œ≤} {f : Filter Œ±}, m‚ÇÅ =·∂†[f] m‚ÇÇ ‚Üí Filter.map m‚ÇÅ f = Filter.map m‚ÇÇ f",
    "name": "Filter.map_congr",
    "doc":
    "If functions `m‚ÇÅ` and `m‚ÇÇ` are eventually equal at a filter `f`, then\nthey map this filter to the same filter. ",
    "depth": 12},
   {"term":
    "‚àÄ {Œ± : Type u_1} [inst : MeasurableSpace Œ±] {Œº : MeasureTheory.Measure Œ±} {s t : Set Œ±},\n  s =·∂†[MeasureTheory.Measure.ae Œº] t ‚Üí ‚Üë‚ÜëŒº s = ‚Üë‚ÜëŒº t",
    "name": "Filter.EventuallyEq.measure_eq",
    "doc":
    "**Alias** of `MeasureTheory.measure_congr`.\n\n---\n\nIf two sets are equal modulo a set of measure zero, then `Œº s = Œº t`. ",
    "depth": 13},
   {"term":
    "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {l : Filter Œ±} {f : Œ± ‚Üí Œ≤} [inst : Nonempty Œ≤],\n  Filter.EventuallyConst f l ‚Üí ‚àÉ c, f =·∂†[l] fun x => c",
    "name": "Filter.EventuallyConst.eventuallyEq_const",
    "doc":
    "**Alias** of the forward direction of `Filter.eventuallyConst_iff_exists_eventuallyEq`.",
    "depth": 13}],
  "count": 765},
 {"noDocExamples": [],
  "kind": "¬´term‚Ñï‚àû¬ª",
  "examples":
  [{"term": "‚Ñï‚àû ‚Üí PartENat",
    "name": "PartENat.ofENat",
    "doc": "Coercion from `‚Ñï‚àû` to `PartENat`. ",
    "depth": 1},
   {"term": "‚Ñï‚àû ‚Üí ENNReal",
    "name": "ENat.toENNReal",
    "doc": "Coercion from `‚Ñï‚àû` to `‚Ñù‚â•0‚àû`. ",
    "depth": 1},
   {"term": "PartENat ‚âÉ ‚Ñï‚àû",
    "name": "PartENat.withTopEquiv",
    "doc":
    "`Equiv` between `PartENat` and `‚Ñï‚àû` (for the order isomorphism see\n`withTopOrderIso`). ",
    "depth": 2},
   {"term": "{Œ± : Type u_1} ‚Üí SimpleGraph Œ± ‚Üí ‚Ñï‚àû",
    "name": "SimpleGraph.girth",
    "doc":
    "The girth of a simple graph is the length of its smallest cycle, or `‚àû` if the graph is acyclic.\n",
    "depth": 3},
   {"term": "{Œ± : Type u_1} ‚Üí [inst : LT Œ±] ‚Üí Set Œ± ‚Üí ‚Ñï‚àû",
    "name": "Set.chainHeight",
    "doc":
    "The maximal length of a strictly ascending sequence in a partial order. ",
    "depth": 4}],
  "count": 754},
 {"noDocExamples": [],
  "kind": "¬´term_√ó__1¬ª",
  "examples":
  [{"term": "(n : ‚Ñï) ‚Üí Finset ((_ : Fin n) √ó Fin n)",
    "name": "Equiv.Perm.finPairsLT",
    "doc": "set of all pairs (‚ü®a, b‚ü© : Œ£ a : fin n, fin n) such that b < a ",
    "depth": 5},
   {"term": "{Œ± : Type u_7} ‚Üí {Œ≤ : Type u_8} ‚Üí Œ± √ó Œ≤ ‚Üí (_ : Œ±) √ó Œ≤",
    "name": "Prod.toSigma",
    "doc": "Convert a product type to a Œ£-type. ",
    "depth": 5},
   {"term": "(Œ± : Type u_1) ‚Üí (_ : Œ±) √ó PUnit.{u_2 + 1} ‚âÉ Œ±",
    "name": "Equiv.sigmaPUnit",
    "doc":
    "`PUnit` is a right identity for dependent type product up to an equivalence. ",
    "depth": 5},
   {"term": "{Œ± : Type u} ‚Üí {Œ≤ : Type v} ‚Üí List (Œ± √ó Œ≤) ‚Üí List ((_ : Œ±) √ó Œ≤)",
    "name": "SlimCheck.TotalFunction.List.toFinmap'",
    "doc": "Create a `finmap` from a list of pairs. ",
    "depth": 6},
   {"term": "{Œ± : Type u} ‚Üí List Œ± ‚âÉ (n : ‚Ñï) √ó (Fin n ‚Üí Œ±)",
    "name": "List.equivSigmaTuple",
    "doc":
    "Lists are equivalent to the sigma type of tuples of a given length. ",
    "depth": 6}],
  "count": 735},
 {"noDocExamples": [],
  "kind": "Filter.¬´term‚àÄ·∂†_In_,_¬ª",
  "examples":
  [{"term": "‚àÄ·∂† (x : ‚Ñù) in residual ‚Ñù, Liouville x",
    "name": "eventually_residual_liouville",
    "doc": "The set of Liouville numbers is a residual set. ",
    "depth": 5},
   {"term":
    "‚àÄ {Œ± : Type u} {f : Ultrafilter Œ±} {p : Œ± ‚Üí Prop}, (‚àÉ·∂† (x : Œ±) in ‚Üëf, p x) ‚Üí ‚àÄ·∂† (x : Œ±) in ‚Üëf, p x",
    "name": "Filter.Frequently.eventually",
    "doc":
    "**Alias** of the forward direction of `Ultrafilter.frequently_iff_eventually`.",
    "depth": 8},
   {"term":
    "‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {p : Œ± ‚Üí Prop} {a : Œ±}, (‚àÄ·∂† (y : Œ±) in nhds a, p y) ‚Üí p a",
    "name": "Filter.Eventually.self_of_nhds",
    "doc":
    "If a predicate is true in a neighborhood of `a`, then it is true for `a`. ",
    "depth": 9},
   {"term":
    "‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : PreconnectedSpace Œ±] (P : Œ± ‚Üí Œ± ‚Üí Prop),\n  (‚àÄ (x : Œ±), ‚àÄ·∂† (y : Œ±) in nhds x, P x y) ‚Üí Transitive P ‚Üí Symmetric P ‚Üí ‚àÄ (x y : Œ±), P x y",
    "name": "PreconnectedSpace.induction‚ÇÇ",
    "doc":
    "In a preconnected space, if a symmetric transitive relation `P x y` is true for `y` close\nenough to `x`, then it holds for all `x, y`. This is a version of the fact that, if an equivalence\nrelation has open classes, then it has a single equivalence class. ",
    "depth": 11},
   {"term":
    "‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {p : Œ± ‚Üí Prop} {a : Œ±},\n  (‚àÄ·∂† (y : Œ±) in nhds a, p y) ‚Üí ‚àÄ·∂† (y : Œ±) in nhds a, ‚àÄ·∂† (x : Œ±) in nhds y, p x",
    "name": "Filter.Eventually.eventually_nhds",
    "doc":
    "If a predicate is true in a neighbourhood of `a`, then for `y` sufficiently close\nto `a` this predicate is true in a neighbourhood of `y`. ",
    "depth": 12}],
  "count": 714},
 {"noDocExamples": [],
  "kind": "¬´term|___|¬ª",
  "examples":
  [{"term":
    "‚àÄ (c : ‚ÑÇ) (R : ‚Ñù), Set.range (circleMap c R) = Metric.sphere c |R|",
    "name": "range_circleMap",
    "doc":
    "The range of `circleMap c R` is the circle with center `c` and radius `|R|`. ",
    "depth": 11},
   {"term": "‚àÄ (x : ‚Ñù), 0 < x ‚Üí x ‚â§ 1 ‚Üí |Real.log x * x| < 1",
    "name": "Real.abs_log_mul_self_lt",
    "doc": "Bound for `|log x * x|` in the interval `(0, 1]`. ",
    "depth": 12},
   {"term":
    "‚àÄ {Œ± : Type u_1} {l : Filter Œ±} {f : Œ± ‚Üí ‚Ñù},\n  ((fun x => rexp (f x)) =Œò[l] fun x => 1) ‚Üî Filter.IsBoundedUnder (fun x x_1 => x ‚â§ x_1) l fun x => |f x|",
    "name": "Real.isTheta_exp_comp_one",
    "doc":
    "`Real.exp (f x)` is bounded away from zero and infinity along a filter `l` if and only if\n`|f x|` is bounded from above along this filter. ",
    "depth": 13},
   {"term": "‚àÄ (Œæ : ‚Ñö), Set.Finite {q | |Œæ - q| < 1 / ‚Üëq.den ^ 2}",
    "name": "Rat.finite_rat_abs_sub_lt_one_div_den_sq",
    "doc":
    "A rational number has only finitely many good rational approximations. ",
    "depth": 13},
   {"term":
    "‚àÄ {Œæ : ‚Ñù} {q : ‚Ñö}, |Œæ - ‚Üëq| < 1 / (2 * ‚Üëq.den ^ 2) ‚Üí ‚àÉ n, q = Real.convergent Œæ n",
    "name": "Real.exists_rat_eq_convergent",
    "doc":
    "The main result, *Legendre's Theorem* on rational approximation:\nif `Œæ` is a real number and `q` is a rational number such that `|Œæ - q| < 1/(2*q.den^2)`,\nthen `q` is a convergent of the continued fraction expansion of `Œæ`.\nThis version uses `Real.convergent`. ",
    "depth": 13}],
  "count": 673},
 {"noDocExamples": [],
  "kind": "¬´term‚Ñï+¬ª",
  "examples":
  [{"term": "‚Ñö ‚Üí ‚Ñï+",
    "name": "Rat.pnatDen",
    "doc": "Denominator as `‚Ñï+`. ",
    "depth": 1},
   {"term": "‚Ñï+ ‚Üí Type",
    "name": "LucasLehmer.X",
    "doc": "We construct the ring `X q` as ‚Ñ§/q‚Ñ§ + ‚àö3 ‚Ñ§/q‚Ñ§. ",
    "depth": 1},
   {"term": "‚Ñï ‚Üí ‚Ñï+",
    "name": "LucasLehmer.q",
    "doc":
    "`q` is defined as the minimum factor of `mersenne p`, bundled as an `‚Ñï+`. ",
    "depth": 1},
   {"term": "Nat.Primes ‚Üí ‚Ñï+",
    "name": "Nat.Primes.toPNat",
    "doc": "The canonical map from `Nat.Primes` to `‚Ñï+` ",
    "depth": 1},
   {"term": "PNat.XgcdType ‚Üí ‚Ñï+",
    "name": "PNat.XgcdType.b",
    "doc": "`b = bp + 1` ",
    "depth": 1}],
  "count": 644},
 {"noDocExamples": [],
  "kind": "¬´term_·µÉ·µí·µñ¬ª",
  "examples":
  [{"term": "{Œ± : Type u_1} ‚Üí Œ± ‚âÉ Œ±·µÉ·µí·µñ",
    "name": "AddOpposite.opEquiv",
    "doc": "The canonical bijection between `Œ±` and `Œ±·µÉ·µí·µñ`.",
    "depth": 3},
   {"term": "{Œ± : Type u_1} ‚Üí Œ± ‚Üí Œ±·µÉ·µí·µñ",
    "name": "AddOpposite.op",
    "doc": "The element of `Œ±·µÉ·µí·µñ` that represents `x : Œ±`.",
    "depth": 3},
   {"term": "{Œ± : Type u_1} ‚Üí Œ±·µÉ·µí·µñ ‚Üí Œ±",
    "name": "AddOpposite.unop",
    "doc": "The element of `Œ±` represented by `x : Œ±·µÉ·µí·µñ`.",
    "depth": 3},
   {"term": "{Œ± : Type u_2} ‚Üí [inst : EMetricSpace Œ±] ‚Üí EMetricSpace Œ±·µÉ·µí·µñ",
    "name": "instEMetricSpaceAddOpposite",
    "doc":
    "EMetric space instance on the additive opposite of an emetric space.",
    "depth": 4},
   {"term":
    "{M : Type u_1} ‚Üí [inst : TopologicalSpace M] ‚Üí TopologicalSpace M·µÉ·µí·µñ",
    "name": "AddOpposite.instTopologicalSpaceAddOpposite",
    "doc":
    "Put the same topological space structure on the opposite monoid as on the original\nspace.",
    "depth": 4}],
  "count": 592},
 {"noDocExamples": [],
  "kind": "¬´term_++_¬ª",
  "examples":
  [{"term":
    "‚àÄ {a b : ‚Ñï}, Nat.coprime a b ‚Üí Nat.factors (a * b) ~ Nat.factors a ++ Nat.factors b",
    "name": "Nat.perm_factors_mul_of_coprime",
    "doc":
    "For coprime `a` and `b`, the prime factors of `a * b` are the union of those of `a` and `b` ",
    "depth": 12},
   {"term":
    "‚àÄ {a b : ‚Ñï}, a ‚â† 0 ‚Üí b ‚â† 0 ‚Üí Nat.factors (a * b) ~ Nat.factors a ++ Nat.factors b",
    "name": "Nat.perm_factors_mul",
    "doc":
    "For positive `a` and `b`, the prime factors of `a * b` are the union of those of `a` and `b` ",
    "depth": 13},
   {"term":
    "‚àÄ {Œ± : Type u} {l‚ÇÅ l‚ÇÇ : List Œ±} {n : ‚Ñï}, List.drop n (l‚ÇÅ ++ l‚ÇÇ) = List.drop n l‚ÇÅ ++ List.drop (n - List.length l‚ÇÅ) l‚ÇÇ",
    "name": "List.drop_append_eq_append_drop",
    "doc":
    "Dropping the elements up to `n` in `l‚ÇÅ ++ l‚ÇÇ` is the same as dropping the elements up to `n`\nin `l‚ÇÅ`, dropping the elements up to `n - l‚ÇÅ.length` in `l‚ÇÇ`, and appending them. ",
    "depth": 14},
   {"term":
    "‚àÄ {Œ± : Type u} {l‚ÇÅ l‚ÇÇ : List Œ±} {n : ‚Ñï}, List.take n (l‚ÇÅ ++ l‚ÇÇ) = List.take n l‚ÇÅ ++ List.take (n - List.length l‚ÇÅ) l‚ÇÇ",
    "name": "List.take_append_eq_append_take",
    "doc":
    "Taking the first `n` elements in `l‚ÇÅ ++ l‚ÇÇ` is the same as appending the first `n` elements\nof `l‚ÇÅ` to the first `n - l‚ÇÅ.length` elements of `l‚ÇÇ`. ",
    "depth": 14},
   {"term":
    "{Œ± : Type} ‚Üí {ds‚ÇÅ ds‚ÇÇ : List ‚Ñï} ‚Üí [inst : Mul Œ±] ‚Üí Holor Œ± ds‚ÇÅ ‚Üí Holor Œ± ds‚ÇÇ ‚Üí Holor Œ± (ds‚ÇÅ ++ ds‚ÇÇ)",
    "name": "Holor.mul",
    "doc": "The tensor product of two holors. ",
    "depth": 14}],
  "count": 576},
 {"noDocExamples": [],
  "kind": "¬´term_‚âÉ‚Çó[_]_¬ª",
  "examples":
  [{"term": "‚ÑÇ ‚âÉ‚Çó[‚Ñù] ‚Ñù √ó ‚Ñù",
    "name": "Complex.equivRealProdLm",
    "doc": "The natural `LinearEquiv` from `‚ÑÇ` to `‚Ñù √ó ‚Ñù`. ",
    "depth": 14},
   {"term": "Nonempty (‚ÑÇ ‚âÉ‚Çó[‚Ñö] ‚Ñù)",
    "name": "Complex.nonempty_linearEquiv_real",
    "doc":
    "`‚ÑÇ` and `‚Ñù` are isomorphic as vector spaces over `‚Ñö`, or equivalently,\nas additive groups. ",
    "depth": 15},
   {"term":
    "{cd : Fin 2 ‚Üí ‚Ñ§} ‚Üí IsCoprime (cd 0) (cd 1) ‚Üí Matrix (Fin 2) (Fin 2) ‚Ñù ‚âÉ‚Çó[‚Ñù] Matrix (Fin 2) (Fin 2) ‚Ñù",
    "name": "ModularGroup.lcRow0Extend",
    "doc":
    "Linear map sending the matrix [a, b; c, d] to the matrix [ac‚ÇÄ + bd‚ÇÄ, - ad‚ÇÄ + bc‚ÇÄ; c, d], for\nsome fixed `(c‚ÇÄ, d‚ÇÄ)`. ",
    "depth": 16},
   {"term":
    "{Œ± : Type u_2} ‚Üí {Œ≤ : Type u_3} ‚Üí (FreeAbelianGroup Œ± ‚âÉ‚Çó[‚Ñ§] FreeAbelianGroup Œ≤) ‚Üí Œ± ‚âÉ Œ≤",
    "name": "FreeAbelianGroup.Equiv.ofFreeAbelianGroupLinearEquiv",
    "doc":
    "Isomorphic free abelian groups (as modules) have equivalent bases. ",
    "depth": 17},
   {"term":
    "(R : Type u_1) ‚Üí (V : Type u_18) ‚Üí (V‚ÇÇ : Type u_19) ‚Üí [inst : Semiring R] ‚Üí (V √ó V‚ÇÇ ‚Üí R) ‚âÉ‚Çó[R] V ‚Üí V‚ÇÇ ‚Üí R",
    "name": "LinearEquiv.curry",
    "doc":
    "Linear equivalence between a curried and uncurried function.\nDiffers from `TensorProduct.curry`. ",
    "depth": 18}],
  "count": 559},
 {"noDocExamples": [],
  "kind": "¬´term_‚âÉo_¬ª",
  "examples":
  [{"term": "‚Ñù ‚âÉo ‚Ñù",
    "name": "Real.sinhOrderIso",
    "doc": "`Real.sinh` as an `OrderIso`. ",
    "depth": 4},
   {"term": "EReal ‚âÉo EReal·µí·µà",
    "name": "EReal.negOrderIso",
    "doc": "Negation as an order reversing isomorphism on `EReal`. ",
    "depth": 5},
   {"term": "(Œ± : Type u_6) ‚Üí [inst : LE Œ±] ‚Üí Œ± ‚âÉo Œ±",
    "name": "OrderIso.refl",
    "doc": "Identity order isomorphism. ",
    "depth": 6},
   {"term": "{R : Type u} ‚Üí [inst : Preorder R] ‚Üí R ‚âÉo Tropical R",
    "name": "Tropical.tropOrderIso",
    "doc":
    "Reinterpret `x : R` as an element of `Tropical R`, preserving the order. ",
    "depth": 6},
   {"term":
    "{Œ± : Type u_1} ‚Üí [inst : Preorder Œ±] ‚Üí Œ± ‚âÉo WithLowerSetTopology Œ±",
    "name": "WithLowerSetTopology.toLowerSetOrderIso",
    "doc": "`toLower` as an `OrderIso` ",
    "depth": 6}],
  "count": 559},
 {"noDocExamples": [],
  "kind": "¬´termŒ†‚ÇÄ_,_¬ª",
  "examples":
  [{"term":
    "{Œπ : Type u_1} ‚Üí {M : Type u_3} ‚Üí [inst : Zero M] ‚Üí (Œπ ‚Üí‚ÇÄ M) ‚Üí Œ†‚ÇÄ (x : Œπ), M",
    "name": "Finsupp.toDFinsupp",
    "doc": "Interpret a `Finsupp` as a homogenous `DFinsupp`. ",
    "depth": 7},
   {"term":
    "{Œπ : Type u_1} ‚Üí {Œ± : Œπ ‚Üí Type u_2} ‚Üí [inst : (i : Œπ) ‚Üí Zero (Œ± i)] ‚Üí (Œ†‚ÇÄ (i : Œπ), Œ± i) ‚Üí Œ†‚ÇÄ (i : Œπ), Finset (Œ± i)",
    "name": "DFinsupp.singleton",
    "doc": "Pointwise `Finset.singleton` bundled as a `DFinsupp`. ",
    "depth": 9},
   {"term":
    "{Œπ : Type u} ‚Üí {Œ≤ : Œπ ‚Üí Type v} ‚Üí [inst : (i : Œπ) ‚Üí Zero (Œ≤ i)] ‚Üí CoeFun (Œ†‚ÇÄ (i : Œπ), Œ≤ i) fun x => (i : Œπ) ‚Üí Œ≤ i",
    "name": "DFinsupp.instCoeFunDFinsuppForAll",
    "doc":
    "Helper instance for when there are too many metavariables to apply `FunLike.coeFunForall`\ndirectly. ",
    "depth": 9},
   {"term":
    "{Œπ : Type u} ‚Üí\n  {Œ≤ : Œπ ‚Üí Type v} ‚Üí\n    [inst : (i : Œπ) ‚Üí Zero (Œ≤ i)] ‚Üí (p : Œπ ‚Üí Prop) ‚Üí [inst_1 : DecidablePred p] ‚Üí (Œ†‚ÇÄ (i : Œπ), Œ≤ i) ‚Üí Œ†‚ÇÄ (i : Œπ), Œ≤ i",
    "name": "DFinsupp.filter",
    "doc":
    "`Filter p f` is the function which is `f i` if `p i` is true and 0 otherwise. ",
    "depth": 10},
   {"term":
    "{Œπ : Type u} ‚Üí\n  {Œ≤ : Œπ ‚Üí Type v} ‚Üí [dec : DecidableEq Œπ] ‚Üí [inst : (i : Œπ) ‚Üí Zero (Œ≤ i)] ‚Üí (i : Œπ) ‚Üí Œ≤ i ‚Üí Œ†‚ÇÄ (i : Œπ), Œ≤ i",
    "name": "DFinsupp.single",
    "doc":
    "The function `single i b : Œ†‚ÇÄ i, Œ≤ i` sends `i` to `b`\nand all other points to `0`. ",
    "depth": 10}],
  "count": 545},
 {"noDocExamples": [],
  "kind": "Set.¬´term‚ãÇ_,_¬ª",
  "examples":
  [{"term":
    "‚àÄ {Œπ : Type u} {f : Œπ ‚Üí Ordinal.{max u v} ‚Üí Ordinal.{max u v}},\n  (‚àÄ (i : Œπ), Ordinal.IsNormal (f i)) ‚Üí Ordinal.derivFamily f = Ordinal.enumOrd (‚ãÇ (i : Œπ), Function.fixedPoints (f i))",
    "name": "Ordinal.derivFamily_eq_enumOrd",
    "doc":
    "For a family of normal functions, `Ordinal.derivFamily` enumerates the common fixed points. ",
    "depth": 9},
   {"term":
    "‚àÄ {Œ± : Type u_1} {Œπ : Type u_4} [inst : TopologicalSpace Œ±] [inst_1 : Encodable Œπ] {s : Œπ ‚Üí Set Œ±},\n  (‚àÄ (i : Œπ), IsGŒ¥ (s i)) ‚Üí IsGŒ¥ (‚ãÇ (i : Œπ), s i)",
    "name": "isGŒ¥_iInter",
    "doc": "The intersection of an encodable family of GŒ¥ sets is a GŒ¥ set. ",
    "depth": 10},
   {"term":
    "‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : BaireSpace Œ±] {f : ‚Ñï ‚Üí Set Œ±},\n  (‚àÄ (n : ‚Ñï), IsOpen (f n)) ‚Üí (‚àÄ (n : ‚Ñï), Dense (f n)) ‚Üí Dense (‚ãÇ (n : ‚Ñï), f n)",
    "name": "dense_iInter_of_open_nat",
    "doc": "Definition of a Baire space. ",
    "depth": 10},
   {"term":
    "‚àÄ {Œ± : Type u_1} {Œπ : Sort u_4} {s : Œπ ‚Üí Set Œ±} {t : Set Œ±} (i : Œπ), s i ‚äÜ t ‚Üí ‚ãÇ (i : Œπ), s i ‚äÜ t",
    "name": "Set.iInter_subset_of_subset",
    "doc":
    "This rather trivial consequence of `iInter_subset`is convenient with `apply`, and has `i`\nexplicit for this purpose. ",
    "depth": 11},
   {"term":
    "‚àÄ {Œ± : Type u_1} {Œπ : Sort u_4} {Œπ' : Sort u_5} {s : Œπ ‚Üí Œπ' ‚Üí Set Œ±},\n  ‚ãÉ (j : Œπ'), ‚ãÇ (i : Œπ), s i j ‚äÜ ‚ãÇ (i : Œπ), ‚ãÉ (j : Œπ'), s i j",
    "name": "Set.iUnion_iInter_subset",
    "doc":
    "An equality version of this lemma is `iUnion_iInter_of_monotone` in `Data.Set.Finite`. ",
    "depth": 12}],
  "count": 520},
 {"noDocExamples": [],
  "kind": "CategoryTheory.¬´term_‚âå_¬ª",
  "examples":
  [{"term": "DistLatCat ‚âå DistLatCat",
    "name": "DistLatCat.dualEquiv",
    "doc":
    "The equivalence between `DistLatCat` and itself induced by `OrderDual` both ways. ",
    "depth": 4},
   {"term": "SemilatSupCat ‚âå SemilatInfCat",
    "name": "SemilatSupCatEquivSemilatInfCat",
    "doc":
    "The equivalence between `SemilatSupCat` and `SemilatInfCat` induced by `OrderDual` both ways. ",
    "depth": 4},
   {"term": "TwoP ‚âå TwoP",
    "name": "TwoP.swapEquiv",
    "doc":
    "The equivalence between `TwoP` and itself induced by `Prod.swap` both ways. ",
    "depth": 4},
   {"term": "BoolRingCat ‚âå BoolAlgCat",
    "name": "boolRingCatEquivBoolAlgCat",
    "doc":
    "The equivalence between Boolean rings and Boolean algebras. This is actually an isomorphism. ",
    "depth": 4},
   {"term": "FinPartOrd ‚âå FinPartOrd",
    "name": "FinPartOrd.dualEquiv",
    "doc":
    "The equivalence between `FinPartOrd` and itself induced by `OrderDual` both ways. ",
    "depth": 4}],
  "count": 514},
 {"noDocExamples": [],
  "kind": "¬´term‚àë'_,_¬ª",
  "examples":
  [{"term":
    "‚àÄ {Œ± : Type u_1} {f : Œ± ‚Üí ENNReal}, ‚àë' (i : Œ±), f i ‚â† ‚ä§ ‚Üí Set.Countable (Function.support f)",
    "name": "Summable.countable_support_ennreal",
    "doc": "Finitely summable non-negative functions have countable support ",
    "depth": 12},
   {"term": "‚àÄ {s : ‚ÑÇ}, 1 < s.re ‚Üí riemannZeta s = ‚àë' (n : ‚Ñï), 1 / ‚Üën ^ s",
    "name": "zeta_eq_tsum_one_div_nat_cpow",
    "doc":
    "Alternate formulation of `zeta_eq_tsum_one_div_nat_add_one_cpow` without the `+ 1`, using the\nfact that for `s ‚â† 0` we define `0 ^ s = 0`.  ",
    "depth": 13},
   {"term":
    "‚àÄ {s : ‚ÑÇ}, 1 < s.re ‚Üí riemannZeta s = ‚àë' (n : ‚Ñï), 1 / (‚Üën + 1) ^ s",
    "name": "zeta_eq_tsum_one_div_nat_add_one_cpow",
    "doc":
    "The Riemann zeta function agrees with the naive Dirichlet-series definition when the latter\nconverges. (Note that this is false without the assumption: when `re s ‚â§ 1` the sum is divergent,\nand we use a different definition to obtain the analytic continuation to all `s`.) ",
    "depth": 14},
   {"term": "‚àÄ {k : ‚Ñï}, 1 < k ‚Üí riemannZeta ‚Üëk = ‚àë' (n : ‚Ñï), 1 / ‚Üën ^ k",
    "name": "zeta_nat_eq_tsum_of_gt_one",
    "doc":
    "Special case of `zeta_eq_tsum_one_div_nat_cpow` when the argument is in `‚Ñï`, so the power\nfunction can be expressed using na√Øve `pow` rather than `cpow`. ",
    "depth": 14},
   {"term":
    "‚àÄ (f : ‚Ñï ‚Üí NNReal), Filter.Tendsto (fun i => ‚àë' (k : ‚Ñï), f (k + i)) Filter.atTop (nhds 0)",
    "name": "NNReal.tendsto_sum_nat_add",
    "doc":
    "For `f : ‚Ñï ‚Üí ‚Ñù‚â•0`, then `‚àë' k, f (k + i)` tends to zero. This does not require a summability\nassumption on `f`, as otherwise all sums are zero. ",
    "depth": 14}],
  "count": 495},
 {"noDocExamples": [],
  "kind": "¬´term‚Äñ_‚Äñ‚Çä¬ª",
  "examples":
  [{"term":
    "‚àÄ {E : Type u_6} [inst : SeminormedAddGroup E] (a b : E), nndist a b = ‚Äña - b‚Äñ‚Çä",
    "name": "nndist_eq_nnnorm",
    "doc": "**Alias** of `nndist_eq_nnnorm_sub`.",
    "depth": 14},
   {"term":
    "‚àÄ {E : Type u_6} [inst : SeminormedAddGroup E] (a b : E), ‚Äñb‚Äñ‚Çä ‚â§ ‚Äña‚Äñ‚Çä + ‚Äña - b‚Äñ‚Çä",
    "name": "nnnorm_le_insert",
    "doc": "**Alias** of `nnnorm_le_nnnorm_add_nnnorm_sub`.",
    "depth": 15},
   {"term":
    "‚àÄ {Œπ : Type u_1} {E : Type u_3} [inst : SeminormedAddCommGroup E] {f : Œπ ‚Üí E},\n  (Summable fun i => ‚Äñf i‚Äñ‚Çä) ‚Üí ‚Äñ‚àë' (i : Œπ), f i‚Äñ‚Çä ‚â§ ‚àë' (i : Œπ), ‚Äñf i‚Äñ‚Çä",
    "name": "nnnorm_tsum_le",
    "doc":
    "If `‚àë' i, ‚Äñf i‚Äñ‚Çä` is summable, then `‚Äñ‚àë' i, f i‚Äñ‚Çä ‚â§ ‚àë' i, ‚Äñf i‚Äñ‚Çä`. Note that\nwe do not assume that `‚àë' i, f i` is summable, and it might not be the case if `Œ±` is not a complete\nspace. ",
    "depth": 15},
   {"term":
    "‚àÄ {E : Type u_6} [inst : SeminormedAddGroup E] (a b : E), ‚Äña‚Äñ‚Çä ‚â§ ‚Äñb‚Äñ‚Çä + ‚Äña - b‚Äñ‚Çä",
    "name": "nnnorm_le_insert'",
    "doc": "**Alias** of `nnnorm_le_nnnorm_add_nnnorm_sub'`.",
    "depth": 15},
   {"term":
    "‚àÄ {Œπ : Type u_4} {œÄ : Œπ ‚Üí Type u_9} [inst : Fintype Œπ] [inst_1 : (i : Œπ) ‚Üí SeminormedGroup (œÄ i)] (f : (i : Œπ) ‚Üí œÄ i),\n  (Finset.sum Finset.univ fun i => ‚Äñf i‚Äñ‚Çä) ‚â§ Fintype.card Œπ ‚Ä¢ ‚Äñf‚Äñ‚Çä",
    "name": "Pi.sum_nnnorm_apply_le_nnnorm'",
    "doc":
    "The $L^1$ norm is less than the $L^\\infty$ norm scaled by the cardinality. ",
    "depth": 16}],
  "count": 490},
 {"noDocExamples": [],
  "kind": "¬´term_‚âÉ‚Çê[_]_¬ª",
  "examples":
  [{"term": "‚ÑÇ ‚âÉ‚Çê[‚Ñù] ‚ÑÇ",
    "name": "Complex.conjAe",
    "doc":
    "`‚Ñù`-algebra isomorphism version of the complex conjugation function from `‚ÑÇ` to `‚ÑÇ` ",
    "depth": 8},
   {"term":
    "(k : Type u) ‚Üí [inst : Field k] ‚Üí AlgebraicClosure k ‚âÉ‚Çê[k] AlgebraicClosureAux k",
    "name": "AlgebraicClosure.algEquivAlgebraicClosureAux",
    "doc":
    "The equivalence between `AlgebraicClosure` and `AlgebraicClosureAux`, which we use to transfer\nproperties of `AlgebraicClosureAux` to `AlgebraicClosure` ",
    "depth": 11},
   {"term":
    "{R : Type u_2} ‚Üí [inst : CommSemiring R] ‚Üí LaurentPolynomial R ‚âÉ‚Çê[R] LaurentPolynomial R",
    "name": "LaurentPolynomial.invert",
    "doc": "The map which substitutes `T ‚Ü¶ T‚Åª¬π` into a Laurent polynomial. ",
    "depth": 12},
   {"term":
    "(R : Type u) ‚Üí [inst : CommSemiring R] ‚Üí Polynomial R ‚âÉ‚Çê[R] AddMonoidAlgebra R ‚Ñï",
    "name": "Polynomial.toFinsuppIsoAlg",
    "doc":
    "Algebra isomorphism between `R[X]` and `AddMonoidAlgebra R ‚Ñï`. This is just an\nimplementation detail, but it can be useful to transfer results from `Finsupp` to polynomials. ",
    "depth": 12},
   {"term":
    "(R : Type u) ‚Üí [inst : CommSemiring R] ‚Üí MvPolynomial PUnit.{u_2 + 1} R ‚âÉ‚Çê[R] Polynomial R",
    "name": "MvPolynomial.pUnitAlgEquiv",
    "doc":
    "The ring isomorphism between multivariable polynomials in a single variable and\npolynomials over the ground ring.\n",
    "depth": 12}],
  "count": 479},
 {"noDocExamples": [],
  "kind": "¬´term_%_¬ª",
  "examples":
  [{"term": "‚àÄ {n a : ‚Ñï}, Even n ‚Üí Even a ‚Üí Even (n % a)",
    "name": "Even.mod_even",
    "doc": "If `n` is even and `a` is even, then `n % a` is even. ",
    "depth": 11},
   {"term": "‚àÄ {n a : ‚Ñï}, Odd n ‚Üí Even a ‚Üí Odd (n % a)",
    "name": "Odd.mod_even",
    "doc": "If `n` is odd and `a` is even, then `n % a` is odd. ",
    "depth": 11},
   {"term": "‚àÄ {n : ‚Ñï}, n % 4 = 1 ‚Üí (-1) ^ (n / 2) = 1",
    "name": "ZMod.neg_one_pow_div_two_of_one_mod_four",
    "doc": "If `n % 4 = 1`, then `(-1)^(n/2) = 1`. ",
    "depth": 11},
   {"term": "‚àÄ {n : ‚Ñï}, n % 4 = 3 ‚Üí (-1) ^ (n / 2) = -1",
    "name": "ZMod.neg_one_pow_div_two_of_three_mod_four",
    "doc": "If `n % 4 = 3`, then `(-1)^(n/2) = -1`. ",
    "depth": 11},
   {"term":
    "‚àÄ {a b : ‚Ñï}, a % 4 = 1 ‚Üí Odd b ‚Üí jacobiSym (‚Üëa) b = jacobiSym (‚Üëb) a",
    "name": "jacobiSym.quadratic_reciprocity_one_mod_four",
    "doc":
    "The Law of Quadratic Reciprocity for the Jacobi symbol: if `a` and `b` are natural numbers\nwith `a % 4 = 1` and `b` odd, then `J(a | b) = J(b | a)`. ",
    "depth": 11}],
  "count": 477},
 {"noDocExamples": [],
  "kind": "¬´term_‚âà_¬ª",
  "examples":
  [{"term":
    "‚àÄ (G : SetTheory.PGame) [inst : SetTheory.PGame.Impartial G], G ‚âà SetTheory.PGame.nim (SetTheory.PGame.grundyValue G)",
    "name": "SetTheory.PGame.equiv_nim_grundyValue",
    "doc":
    "The Sprague-Grundy theorem which states that every impartial game is equivalent to a game of\nnim, namely the game of nim corresponding to the games Grundy value ",
    "depth": 7},
   {"term":
    "‚àÄ {x y : SetTheory.PGame}, SetTheory.PGame.Relabelling x y ‚Üí x ‚âà y",
    "name": "SetTheory.PGame.Relabelling.equiv",
    "doc": "A relabelling lets us prove equivalence of games. ",
    "depth": 8},
   {"term": "‚àÄ (x : SetTheory.PGame), 0 * x ‚âà 0",
    "name": "SetTheory.PGame.zero_mul_equiv",
    "doc": "`0 * x` is equivalent to `0`. ",
    "depth": 9},
   {"term": "‚àÄ (x : SetTheory.PGame), 1 * x ‚âà x",
    "name": "SetTheory.PGame.one_mul_equiv",
    "doc": "`1 * x` is equivalent to `x`. ",
    "depth": 9},
   {"term": "‚àÄ (x : SetTheory.PGame), x + 0 ‚âà x",
    "name": "SetTheory.PGame.add_zero_equiv",
    "doc": "`x + 0` is equivalent to `x`. ",
    "depth": 9}],
  "count": 458},
 {"noDocExamples": [],
  "kind": "CategoryTheory.¬´term_‚ä£_¬ª",
  "examples":
  [{"term": "pointedToBipointedSnd ‚ä£ bipointedToPointedSnd",
    "name": "pointedToBipointedSndBipointedToPointedSndAdjunction",
    "doc":
    "The free/forgetful adjunction between `PointedToBipointed_snd` and `BipointedToPointed_snd`.\n",
    "depth": 6},
   {"term": "TopCat.discrete ‚ä£ CategoryTheory.forget TopCat",
    "name": "TopCat.adj‚ÇÅ",
    "doc":
    "Equipping a type with the discrete topology is left adjoint to the forgetful functor\n`Top ‚•§ Type`. ",
    "depth": 6},
   {"term": "Compactum.free ‚ä£ Compactum.forget",
    "name": "Compactum.adj",
    "doc": "The adjunction between `free` and `forget`. ",
    "depth": 6},
   {"term": "typeToStonean ‚ä£ CategoryTheory.forget Stonean",
    "name": "Stonean.stoneCechAdjunction",
    "doc":
    "The Stone-Cech compactification functor is left adjoint to the forgetful functor. ",
    "depth": 6},
   {"term": "typeToPointed ‚ä£ CategoryTheory.forget Pointed",
    "name": "typeToPointedForgetAdjunction",
    "doc": "`typeToPointed` is the free functor. ",
    "depth": 6}],
  "count": 447},
 {"noDocExamples": [],
  "kind": "¬´term_‚âÉ+_¬ª",
  "examples":
  [{"term": "‚ÑÇ ‚âÉ+ ‚Ñù √ó ‚Ñù",
    "name": "Complex.equivRealProdAddHom",
    "doc": "The natural `AddEquiv` from `‚ÑÇ` to `‚Ñù √ó ‚Ñù`. ",
    "depth": 5},
   {"term": "{Œ± : Type u} ‚Üí [inst : Add Œ±] ‚Üí Œ± ‚âÉ+ Œ±·µê·µí·µñ",
    "name": "MulOpposite.opAddEquiv",
    "doc": "The function `MulOpposite.op` is an additive equivalence. ",
    "depth": 6},
   {"term": "(M : Type u_12) ‚Üí [inst : Add M] ‚Üí M ‚âÉ+ M",
    "name": "AddEquiv.refl",
    "doc": "The identity map is an additive isomorphism.",
    "depth": 6},
   {"term": "(M : Type u_1) ‚Üí [inst : Add M] ‚Üí M ‚âÉ+ M·µÉ·µí·µñ·µÉ·µí·µñ",
    "name": "AddEquiv.opOp",
    "doc": "A additive monoid is isomorphic to the opposite of its opposite.",
    "depth": 7},
   {"term": "{Œ± : Type u} ‚Üí [inst : Add Œ±] ‚Üí ULift.{u_2, u} Œ± ‚âÉ+ Œ±",
    "name": "AddEquiv.ulift",
    "doc": "The additive equivalence between `ULift Œ±` and `Œ±`.",
    "depth": 7}],
  "count": 446},
 {"noDocExamples": [],
  "kind": "¬´term_>_¬ª",
  "examples":
  [{"term":
    "‚àÄ (R : Type u_1) [inst : CommRing R] {P : Prop},\n  (‚àÄ (p : ‚Ñï), p > 0 ‚Üí MixedCharZero R p ‚Üí P) ‚Üî ‚àÄ (p : ‚Ñï), Nat.Prime p ‚Üí MixedCharZero R p ‚Üí P",
    "name": "MixedCharZero.reduce_to_p_prime",
    "doc":
    "Reduction to `p` prime: When proving any statement `P` about mixed characteristic rings we\ncan always assume that `p` is prime.\n",
    "depth": 11},
   {"term":
    "‚àÄ (R : Type u_1) [inst : CommRing R] [inst_1 : CharZero R], IsEmpty (Algebra ‚Ñö R) ‚Üî ‚àÉ p, p > 0 ‚àß MixedCharZero R p",
    "name": "isEmpty_algebraRat_iff_mixedCharZero",
    "doc":
    "A ring of characteristic zero is not a `‚Ñö`-algebra iff it has mixed characteristic for some `p`.\n",
    "depth": 12},
   {"term":
    "‚àÄ (b o : Ordinal.{u_1}), List.Sorted (fun x x_1 => x > x_1) (List.map Prod.fst (Ordinal.CNF b o))",
    "name": "Ordinal.CNF_sorted",
    "doc": "The exponents of the Cantor normal form are decreasing. ",
    "depth": 12},
   {"term":
    "‚àÄ {Œ± : Type u} [inst : LT Œ±] [inst_1 : WellFoundedGT Œ±] (a : Œ±), Acc (fun x x_1 => x > x_1) a",
    "name": "WellFoundedGT.apply",
    "doc": "All values are accessible under the well-founded `>`. ",
    "depth": 12},
   {"term":
    "‚àÄ {Œ± : Type u_1} {r : Œ± ‚Üí Œ± ‚Üí Prop} [inst : IsStrictOrder Œ± r], WellFounded r ‚Üî IsEmpty ((fun x x_1 => x > x_1) ‚Ü™r r)",
    "name": "RelEmbedding.wellFounded_iff_no_descending_seq",
    "doc":
    "A relation is well-founded iff it doesn't have any infinite decreasing sequence. ",
    "depth": 13}],
  "count": 438},
 {"noDocExamples": [],
  "kind": "¬´term_‚âÉ+*_¬ª",
  "examples":
  [{"term": "FreeRing PEmpty.{u + 1} ‚âÉ+* ‚Ñ§",
    "name": "freeRingPemptyEquivInt",
    "doc": "The free ring on the empty type is isomorphic to `‚Ñ§`. ",
    "depth": 9},
   {"term": "(R : Type u_4) ‚Üí [inst : Mul R] ‚Üí [inst_1 : Add R] ‚Üí R ‚âÉ+* R",
    "name": "RingEquiv.refl",
    "doc": "The identity map is a ring isomorphism. ",
    "depth": 9},
   {"term":
    "{Œ± : Type u} ‚Üí [inst : NonUnitalNonAssocSemiring Œ±] ‚Üí ULift.{u_1, u} Œ± ‚âÉ+* Œ±",
    "name": "ULift.ringEquiv",
    "doc": "The ring equivalence between `ULift Œ±` and `Œ±`.",
    "depth": 9},
   {"term":
    "{R : Type u} ‚Üí [inst : NonUnitalNonAssocSemiring R] ‚Üí [inst_1 : StarRing R] ‚Üí R ‚âÉ+* R·µê·µí·µñ",
    "name": "starRingEquiv",
    "doc": "`star` as a `RingEquiv` from `R` to `R·µê·µí·µñ` ",
    "depth": 9},
   {"term": "FreeRing PUnit.{u + 1} ‚âÉ+* Polynomial ‚Ñ§",
    "name": "freeRingPunitEquivPolynomialInt",
    "doc": "The free ring on a type with one term is isomorphic to `‚Ñ§[X]`. ",
    "depth": 9}],
  "count": 438},
 {"noDocExamples": [],
  "kind": "¬´term_‚âÉ*_¬ª",
  "examples":
  [{"term": "(M : Type u_12) ‚Üí [inst : Mul M] ‚Üí M ‚âÉ* M",
    "name": "MulEquiv.refl",
    "doc": "The identity map is a multiplicative isomorphism. ",
    "depth": 6},
   {"term": "{Œ± : Type u} ‚Üí [inst : Mul Œ±] ‚Üí Œ± ‚âÉ* Œ±·µÉ·µí·µñ",
    "name": "AddOpposite.opMulEquiv",
    "doc": "The function `AddOpposite.op` is a multiplicative equivalence. ",
    "depth": 6},
   {"term": "{Œ± : Type u} ‚Üí [inst : Mul Œ±] ‚Üí ULift.{u_2, u} Œ± ‚âÉ* Œ±",
    "name": "MulEquiv.ulift",
    "doc": "The multiplicative equivalence between `ULift Œ±` and `Œ±`.\n",
    "depth": 7},
   {"term": "(M : Type u_1) ‚Üí [inst : Mul M] ‚Üí M ‚âÉ* M·µê·µí·µñ·µê·µí·µñ",
    "name": "MulEquiv.opOp",
    "doc": "A monoid is isomorphic to the opposite of its opposite. ",
    "depth": 7},
   {"term": "SignType ‚âÉ* Fin 3",
    "name": "SignType.fin3Equiv",
    "doc": "`SignType` is equivalent to `Fin 3`. ",
    "depth": 7}],
  "count": 433},
 {"noDocExamples": [],
  "kind": "MeasureTheory.¬´term‚àÄ·µê_‚àÇ_,_¬ª",
  "examples":
  [{"term":
    "‚àÄ {Œ± : Type u_1} {m0 : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {s t : Œ± ‚Üí Prop},\n  s =·∂†[MeasureTheory.Measure.ae Œº] t ‚Üí\n    ‚àÄ {p : Œ± ‚Üí Prop},\n      (‚àÄ·µê (x : Œ±) ‚àÇMeasureTheory.Measure.restrict Œº s, p x) ‚Üí ‚àÄ·µê (x : Œ±) ‚àÇMeasureTheory.Measure.restrict Œº t, p x",
    "name": "MeasureTheory.ae_restrict_of_ae_eq_of_ae_restrict",
    "doc":
    "If two measurable sets are ae_eq then any proposition that is almost everywhere true on one\nis almost everywhere true on the other ",
    "depth": 14},
   {"term":
    "‚àÄ {Œ± : Type u_1} {m0 : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {s t : Œ± ‚Üí Prop},\n  s =·∂†[MeasureTheory.Measure.ae Œº] t ‚Üí\n    ‚àÄ {p : Œ± ‚Üí Prop},\n      (‚àÄ·µê (x : Œ±) ‚àÇMeasureTheory.Measure.restrict Œº s, p x) ‚Üî ‚àÄ·µê (x : Œ±) ‚àÇMeasureTheory.Measure.restrict Œº t, p x",
    "name": "MeasureTheory.ae_restrict_congr_set",
    "doc":
    "If two measurable sets are ae_eq then any proposition that is almost everywhere true on one\nis almost everywhere true on the other ",
    "depth": 15},
   {"term":
    "‚àÄ {Œ± : Type u_1} {m0 : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {s : ‚Ñï ‚Üí Set Œ±},\n  ‚àë' (i : ‚Ñï), ‚Üë‚ÜëŒº (s i) ‚â† ‚ä§ ‚Üí ‚àÄ·µê (x : Œ±) ‚àÇŒº, ‚àÄ·∂† (n : ‚Ñï) in Filter.atTop, ¬¨x ‚àà s n",
    "name": "MeasureTheory.ae_eventually_not_mem",
    "doc":
    "A version of the **Borel-Cantelli lemma**: if `s·µ¢` is a sequence of sets such that\n`‚àë Œº s·µ¢` exists, then for almost all `x`, `x` does not belong to almost all `s·µ¢`. ",
    "depth": 17},
   {"term":
    "‚àÄ {Œ± : Type u_1} {m : MeasurableSpace Œ±} {f : Œ± ‚Üí Œ±} {s : Set Œ±} {Œº : MeasureTheory.Measure Œ±},\n  QuasiErgodic f ‚Üí\n    MeasureTheory.NullMeasurableSet s ‚Üí\n      f ‚Åª¬π' s =·∂†[MeasureTheory.Measure.ae Œº] s ‚Üí (‚àÄ·µê (x : Œ±) ‚àÇŒº, x ‚àà s) ‚à® ‚àÄ·µê (x : Œ±) ‚àÇŒº, ¬¨x ‚àà s",
    "name": "QuasiErgodic.ae_mem_or_ae_nmem‚ÇÄ",
    "doc":
    "For a quasi ergodic map, sets that are almost invariant (rather than strictly invariant) are\nstill either almost empty or full. ",
    "depth": 18},
   {"term":
    "‚àÄ {Œ± : Type u_1} {m : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {f : ‚Ñï ‚Üí Œ± ‚Üí ENNReal},\n  (‚àÄ (n : ‚Ñï), AEMeasurable (f n)) ‚Üí\n    (‚àÄ·µê (x : Œ±) ‚àÇŒº, Monotone fun n => f n x) ‚Üí ‚à´‚Åª (a : Œ±), ‚®Ü (n : ‚Ñï), f n a ‚àÇŒº = ‚®Ü (n : ‚Ñï), ‚à´‚Åª (a : Œ±), f n a ‚àÇŒº",
    "name": "MeasureTheory.lintegral_iSup'",
    "doc":
    "Monotone convergence theorem -- sometimes called Beppo-Levi convergence. Version with\nae_measurable functions. ",
    "depth": 18}],
  "count": 423},
 {"noDocExamples": [],
  "kind": "¬´term_‚âÉ‚Çú_¬ª",
  "examples":
  [{"term": "EReal ‚âÉ‚Çú EReal",
    "name": "EReal.negHomeo",
    "doc": "Negation on `EReal` as a homeomorphism ",
    "depth": 4},
   {"term": "‚Ñù ‚âÉ‚Çú ‚Ñù",
    "name": "Real.sinhHomeomorph",
    "doc": "`Real.sinh` as a `Homeomorph`. ",
    "depth": 5},
   {"term": "(Œ± : Type u_5) ‚Üí [inst : TopologicalSpace Œ±] ‚Üí Œ± ‚âÉ‚Çú Œ±",
    "name": "Homeomorph.refl",
    "doc": "Identity map as a homeomorphism. ",
    "depth": 6},
   {"term": "{M : Type u_1} ‚Üí [inst : TopologicalSpace M] ‚Üí M ‚âÉ‚Çú M·µÉ·µí·µñ",
    "name": "AddOpposite.opHomeomorph",
    "doc": "`AddOpposite.op` as a homeomorphism.",
    "depth": 6},
   {"term": "{M : Type u_1} ‚Üí [inst : TopologicalSpace M] ‚Üí M ‚âÉ‚Çú M·µê·µí·µñ",
    "name": "MulOpposite.opHomeomorph",
    "doc": "`MulOpposite.op` as a homeomorphism. ",
    "depth": 6}],
  "count": 397},
 {"noDocExamples": [],
  "kind": "¬´term_^[_]¬ª",
  "examples":
  [{"term":
    "‚àÄ {Œ± : Type u} {f : Œ± ‚Üí Œ±} {x : Œ±}, Function.IsFixedPt f x ‚Üí ‚àÄ (n : ‚Ñï), Function.IsFixedPt f^[n] x",
    "name": "Function.IsFixedPt.iterate",
    "doc":
    "If `x` is a fixed point of `f`, then it is a fixed point of `f^[n]`. ",
    "depth": 10},
   {"term":
    "‚àÄ {Œ± : Type u_1} (f : Œ± ‚Üí Œ±) (x : Œ±),\n  Function.periodicOrbit f x = Cycle.map (fun n => f^[n] x) ‚Üë(List.range (Function.minimalPeriod f x))",
    "name": "Function.periodicOrbit_eq_cycle_map",
    "doc": "The definition of a periodic orbit, in terms of `Cycle.map`. ",
    "depth": 11},
   {"term":
    "‚àÄ {Œ± : Type u_2} [inst : MeasurableSpace Œ±] {f : Œ± ‚Üí Œ±} {Œº : MeasureTheory.Measure Œ±},\n  MeasureTheory.Conservative f Œº ‚Üí ‚àÄ (n : ‚Ñï), MeasureTheory.Conservative f^[n] Œº",
    "name": "MeasureTheory.Conservative.iterate",
    "doc": "Iteration of a conservative system is a conservative system. ",
    "depth": 11},
   {"term":
    "‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] {f : Œ± ‚Üí Œ±} {x : Œ±}, StrictMono f ‚Üí f x < x ‚Üí StrictAnti fun n => f^[n] x",
    "name": "StrictMono.strictAnti_iterate_of_map_lt",
    "doc":
    "If `f` is a strictly antitone map and `f x < x` at some point `x`, then the iterates `f^[n] x`\nform a strictly antitone sequence. ",
    "depth": 12},
   {"term":
    "‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] {f : Œ± ‚Üí Œ±} {x : Œ±}, Monotone f ‚Üí x ‚â§ f x ‚Üí Monotone fun n => f^[n] x",
    "name": "Monotone.monotone_iterate_of_le_map",
    "doc":
    "If `f` is a monotone map and `x ‚â§ f x` at some point `x`, then the iterates `f^[n] x` form\na monotone sequence. ",
    "depth": 12}],
  "count": 389},
 {"noDocExamples": [],
  "kind": "¬´term_‚Üío_¬ª",
  "examples":
  [{"term": "‚Ñï ‚Üío ‚Ñï",
    "name": "rothNumberNat",
    "doc":
    "The Roth number of a natural `N` is the largest integer `m` for which there is a subset of\n`range N` of size `m` with no arithmetic progression of length 3.\nTrivially, `rothNumberNat N ‚â§ N`, but Roth's theorem (proved in 1953) shows that\n`rothNumberNat N = o(N)` and the construction by Behrend gives a lower bound of the form\n`N * exp(-C sqrt(log(N))) ‚â§ rothNumberNat N`.\nA significant refinement of Roth's theorem by Bloom and Sisask announced in 2020 gives\n`rothNumberNat N = O(N / (log N)^(1+c))` for an absolute constant `c`. ",
    "depth": 5},
   {"term": "{Œ± : Type u_2} ‚Üí [inst : Preorder Œ±] ‚Üí Œ± ‚Üío Œ±",
    "name": "OrderHom.id",
    "doc": "The identity function as bundled monotone function. ",
    "depth": 6},
   {"term": "{Œ± : Type u_2} ‚Üí [inst : Preorder Œ±] ‚Üí Œ± ‚Üío Œ± √ó Œ±",
    "name": "OrderHom.diag",
    "doc": "Diagonal embedding of `Œ±` into `Œ± √ó Œ±` as an `OrderHom`. ",
    "depth": 7},
   {"term": "{Œ± : Type u_1} ‚Üí Finset (Option Œ±) ‚Üío Finset Œ±",
    "name": "Finset.eraseNone",
    "doc":
    "Given `s : Finset (Option Œ±)`, `eraseNone s : Finset Œ±` is the set of `x : Œ±` such that\n`some x ‚àà s`. ",
    "depth": 7},
   {"term": "{Œ± : Type u_1} ‚Üí [inst : Preorder Œ±] ‚Üí (‚Ñï ‚Üío Œ±) ‚Üí Œ±",
    "name": "monotonicSequenceLimit",
    "doc":
    "The constant value of an eventually-constant monotone sequence `a‚ÇÄ ‚â§ a‚ÇÅ ‚â§ a‚ÇÇ ‚â§ ...` in a\npartially-ordered type. ",
    "depth": 8}],
  "count": 384},
 {"noDocExamples": [],
  "kind": "¬´term_‚Üí‚Çõ‚Çó[_]_¬ª",
  "examples":
  [{"term":
    "{R : Type u_1} ‚Üí {S : Type u_6} ‚Üí [inst : Semiring R] ‚Üí [inst_1 : Semiring S] ‚Üí (f : R ‚Üí+* S) ‚Üí R ‚Üí‚Çõ‚Çó[f] S",
    "name": "RingHom.toSemilinearMap",
    "doc": "Interpret a `RingHom` `f` as an `f`-semilinear map. ",
    "depth": 16},
   {"term":
    "{R : Type u_1} ‚Üí\n  {M : Type u_9} ‚Üí\n    [inst : Semiring R] ‚Üí\n      [inst_1 : AddCommMonoid M] ‚Üí [inst_2 : Module R M] ‚Üí {œÉ : R ‚Üí+* R} ‚Üí [inst_3 : RingHomId œÉ] ‚Üí M ‚Üí‚Çõ‚Çó[œÉ] M",
    "name": "LinearMap.id'",
    "doc":
    "A generalisation of `LinearMap.id` that constructs the identity function\nas a `œÉ`-semilinear map for any ring homomorphism `œÉ` which we know is the identity. ",
    "depth": 18},
   {"term":
    "{R‚ÇÅ : Type u_2} ‚Üí\n  {R‚ÇÇ : Type u_3} ‚Üí\n    {M : Type u_9} ‚Üí\n      {M‚ÇÇ : Type u_11} ‚Üí\n        [inst : Semiring R‚ÇÅ] ‚Üí\n          [inst_1 : Semiring R‚ÇÇ] ‚Üí\n            [inst_2 : AddCommMonoid M] ‚Üí\n              [inst_3 : AddCommMonoid M‚ÇÇ] ‚Üí\n                [inst_4 : Module R‚ÇÅ M] ‚Üí [inst_5 : Module R‚ÇÇ M‚ÇÇ] ‚Üí {œÉ‚ÇÅ‚ÇÇ : R‚ÇÅ ‚Üí+* R‚ÇÇ} ‚Üí Zero (M ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ)",
    "name": "LinearMap.instZeroLinearMap",
    "doc": "The constant 0 map is linear. ",
    "depth": 23},
   {"term":
    "{R : Type u_1} ‚Üí\n  {M : Type u_5} ‚Üí\n    [inst : CommSemiring R] ‚Üí\n      [inst_1 : AddCommMonoid M] ‚Üí [inst_2 : Module R M] ‚Üí {I : R ‚Üí+* R} ‚Üí (M ‚Üí‚Çó[R] M ‚Üí‚Çõ‚Çó[I] R) ‚Üí Module.End R M ‚Üí Prop",
    "name": "LinearMap.IsSelfAdjoint",
    "doc":
    "An endomorphism of a module is self-adjoint with respect to a bilinear form if it serves as an\nadjoint for itself. ",
    "depth": 23},
   {"term":
    "{R‚ÇÅ : Type u_2} ‚Üí\n  {R‚ÇÇ : Type u_3} ‚Üí\n    {M : Type u_9} ‚Üí\n      {N‚ÇÇ : Type u_14} ‚Üí\n        [inst : Semiring R‚ÇÅ] ‚Üí\n          [inst_1 : Semiring R‚ÇÇ] ‚Üí\n            [inst_2 : AddCommMonoid M] ‚Üí\n              [inst_3 : AddCommGroup N‚ÇÇ] ‚Üí\n                [inst_4 : Module R‚ÇÅ M] ‚Üí [inst_5 : Module R‚ÇÇ N‚ÇÇ] ‚Üí {œÉ‚ÇÅ‚ÇÇ : R‚ÇÅ ‚Üí+* R‚ÇÇ} ‚Üí Sub (M ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] N‚ÇÇ)",
    "name": "LinearMap.instSubLinearMapToAddCommMonoid",
    "doc": "The subtraction of two linear maps is linear. ",
    "depth": 23}],
  "count": 383},
 {"noDocExamples": [],
  "kind": "Function.¬´term_‚Ü™_¬ª",
  "examples":
  [{"term": "{Œ± : Type u_1} ‚Üí Œ± ‚Ü™ WithTop Œ±",
    "name": "Function.Embedding.coeWithTop",
    "doc": "Embedding into `WithTop Œ±`. ",
    "depth": 3},
   {"term": "{Œ± : Type u_1} ‚Üí Œ± ‚Ü™ Option Œ±",
    "name": "Function.Embedding.some",
    "doc": "Embedding into `Option Œ±` using `some`. ",
    "depth": 3},
   {"term": "‚Ñï ‚Üí ‚Ñï ‚Ü™ ‚Ñï",
    "name": "Polynomial.revAt",
    "doc":
    "If `i ‚â§ N`, then `revAt N i` returns `N - i`, otherwise it returns `i`.\nEssentially, this embedding is only used for `i ‚â§ N`.\nThe advantage of `revAt N i` over `N - i` is that `revAt` is an involution.\n",
    "depth": 3},
   {"term": "{œÉ : Type u} ‚Üí œÉ ‚Ü™ Cardinal.{u}",
    "name": "embeddingToCardinal",
    "doc": "An embedding of any type to the set of cardinals. ",
    "depth": 3},
   {"term": "(Œ± : Sort u_1) ‚Üí Œ± ‚Ü™ Œ±",
    "name": "Function.Embedding.refl",
    "doc": "The identity map as a `Function.Embedding`. ",
    "depth": 3}],
  "count": 374},
 {"noDocExamples": [],
  "kind": "¬´term_-·µ•_¬ª",
  "examples":
  [{"term":
    "‚àÄ {G : Type u_1} [inst : AddGroup G] (g1 g2 : G), g1 -·µ• g2 = g1 - g2",
    "name": "vsub_eq_sub",
    "doc":
    "Simplify subtraction for a torsor for an `AddGroup G` over\nitself. ",
    "depth": 13},
   {"term":
    "‚àÄ {G : Type u_1} {P : Type u_2} [inst : AddGroup G] [T : AddTorsor G P] (p : P), Function.Injective fun x => p -·µ• x",
    "name": "vsub_right_injective",
    "doc": "Subtracting a point from the point `p` is an injective\nfunction. ",
    "depth": 14},
   {"term":
    "‚àÄ {G : Type u_1} {P : Type u_2} [inst : AddGroup G] [T : AddTorsor G P] (p : P), p -·µ• p = 0",
    "name": "vsub_self",
    "doc": "Subtracting a point from itself produces 0. ",
    "depth": 14},
   {"term":
    "‚àÄ {G : Type u_1} {P : Type u_2} [inst : AddGroup G] [T : AddTorsor G P] (p : P), Function.Injective fun x => x -·µ• p",
    "name": "vsub_left_injective",
    "doc": "Subtracting the point `p` is an injective function. ",
    "depth": 14},
   {"term":
    "‚àÄ {G : Type u_1} {P : Type u_2} [inst : AddGroup G] [T : AddTorsor G P] (p1 p2 : P), -(p1 -·µ• p2) = p2 -·µ• p1",
    "name": "neg_vsub_eq_vsub_rev",
    "doc":
    "Subtracting two points in the reverse order produces the negation\nof subtracting them. ",
    "depth": 16}],
  "count": 365},
 {"noDocExamples": [],
  "kind": "¬´term‚ÅÖ_,_‚ÅÜ¬ª",
  "examples":
  [{"term": "‚àÄ {L : Type v} [self : LieRing L] (x : L), ‚ÅÖx, x‚ÅÜ = 0",
    "name": "LieRing.lie_self",
    "doc": "A Lie ring bracket vanishes on the diagonal in L √ó L. ",
    "depth": 12},
   {"term":
    "‚àÄ {L : Type v} [self : LieRing L] (x y z : L), ‚ÅÖx, ‚ÅÖy, z‚ÅÜ‚ÅÜ = ‚ÅÖ‚ÅÖx, y‚ÅÜ, z‚ÅÜ + ‚ÅÖy, ‚ÅÖx, z‚ÅÜ‚ÅÜ",
    "name": "LieRing.leibniz_lie",
    "doc": "A Lie ring bracket satisfies a Leibniz / Jacobi identity. ",
    "depth": 17},
   {"term":
    "‚àÄ {Œ∑ : Type u_4} [inst : Finite Œ∑] {Gs : Œ∑ ‚Üí Type u_5} [inst : (i : Œ∑) ‚Üí Group (Gs i)]\n  (H K : (i : Œ∑) ‚Üí Subgroup (Gs i)),\n  ‚ÅÖSubgroup.pi Set.univ H, Subgroup.pi Set.univ K‚ÅÜ = Subgroup.pi Set.univ fun i => ‚ÅÖH i, K i‚ÅÜ",
    "name": "Subgroup.commutator_pi_pi_of_finite",
    "doc":
    "The commutator of a finite direct product is contained in the direct product of the commutators.\n",
    "depth": 18},
   {"term":
    "‚àÄ {Œ∑ : Type u_4} {Gs : Œ∑ ‚Üí Type u_5} [inst : (i : Œ∑) ‚Üí Group (Gs i)] (H K : (i : Œ∑) ‚Üí Subgroup (Gs i)),\n  ‚ÅÖSubgroup.pi Set.univ H, Subgroup.pi Set.univ K‚ÅÜ ‚â§ Subgroup.pi Set.univ fun i => ‚ÅÖH i, K i‚ÅÜ",
    "name": "Subgroup.commutator_pi_pi_le",
    "doc":
    "The commutator of direct product is contained in the direct product of the commutators.\n\nSee `commutator_pi_pi_of_finite` for equality given `Fintype Œ∑`.\n",
    "depth": 18},
   {"term":
    "‚àÄ {G : Type u_1} [inst : Group G] {H‚ÇÅ H‚ÇÇ H‚ÇÉ : Subgroup G}, ‚ÅÖ‚ÅÖH‚ÇÇ, H‚ÇÉ‚ÅÜ, H‚ÇÅ‚ÅÜ = ‚ä• ‚Üí ‚ÅÖ‚ÅÖH‚ÇÉ, H‚ÇÅ‚ÅÜ, H‚ÇÇ‚ÅÜ = ‚ä• ‚Üí ‚ÅÖ‚ÅÖH‚ÇÅ, H‚ÇÇ‚ÅÜ, H‚ÇÉ‚ÅÜ = ‚ä•",
    "name": "Subgroup.commutator_commutator_eq_bot_of_rotate",
    "doc": "**The Three Subgroups Lemma** (via the Hall-Witt identity) ",
    "depth": 18}],
  "count": 359},
 {"noDocExamples": [],
  "kind": "MeasureTheory.¬´term‚à´‚Åª_,_‚àÇ_¬ª",
  "examples":
  [{"term":
    "‚àÄ {Œ± : Type u_1} {m : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {f : Œ± ‚Üí ‚Ñù},\n  MeasureTheory.Integrable f ‚Üí\n    ‚à´ (a : Œ±), f a ‚àÇŒº =\n      ENNReal.toReal (‚à´‚Åª (a : Œ±), ENNReal.ofReal (f a) ‚àÇŒº) - ENNReal.toReal (‚à´‚Åª (a : Œ±), ENNReal.ofReal (-f a) ‚àÇŒº)",
    "name":
    "MeasureTheory.integral_eq_lintegral_pos_part_sub_lintegral_neg_part",
    "doc":
    "The Bochner integral of a real-valued function `f : Œ± ‚Üí ‚Ñù` is the difference between the\nintegral of the positive part of `f` and the integral of the negative part of `f`.  ",
    "depth": 14},
   {"term":
    "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_3} [inst : MeasurableSpace Œ±] [inst_1 : MeasurableSpace Œ≤] {Œº : MeasureTheory.Measure Œ±}\n  [inst_2 : MeasureTheory.SigmaFinite Œº] {f : Œ± ‚Üí Œ≤ ‚Üí ENNReal},\n  Measurable (Function.uncurry f) ‚Üí Measurable fun y => ‚à´‚Åª (x : Œ±), f x y ‚àÇŒº",
    "name": "Measurable.lintegral_prod_left",
    "doc":
    "The Lebesgue integral is measurable. This shows that the integrand of (the right-hand-side of)\nthe symmetric version of Tonelli's theorem is measurable.\nThis version has the argument `f` in curried form. ",
    "depth": 15},
   {"term":
    "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_3} [inst : MeasurableSpace Œ±] [inst_1 : MeasurableSpace Œ≤] {ŒΩ : MeasureTheory.Measure Œ≤}\n  [inst_2 : MeasureTheory.SigmaFinite ŒΩ] {f : Œ± ‚Üí Œ≤ ‚Üí ENNReal},\n  Measurable (Function.uncurry f) ‚Üí Measurable fun x => ‚à´‚Åª (y : Œ≤), f x y ‚àÇŒΩ",
    "name": "Measurable.lintegral_prod_right",
    "doc":
    "The Lebesgue integral is measurable. This shows that the integrand of (the right-hand-side of)\nTonelli's theorem is measurable.\nThis version has the argument `f` in curried form. ",
    "depth": 15},
   {"term":
    "‚àÄ {Œ± : Type u_1} {m : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {f : ‚Ñï ‚Üí Œ± ‚Üí ENNReal},\n  (‚àÄ (n : ‚Ñï), AEMeasurable (f n)) ‚Üí\n    ‚à´‚Åª (a : Œ±), Filter.liminf (fun n => f n a) Filter.atTop ‚àÇŒº ‚â§\n      Filter.liminf (fun n => ‚à´‚Åª (a : Œ±), f n a ‚àÇŒº) Filter.atTop",
    "name": "MeasureTheory.lintegral_liminf_le'",
    "doc": "Known as Fatou's lemma, version with `AEMeasurable` functions ",
    "depth": 16},
   {"term":
    "‚àÄ {Œ± : Type u_1} {m : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {f : MeasureTheory.SimpleFunc Œ± ‚Ñù},\n  MeasureTheory.Integrable ‚Üëf ‚Üí\n    0 ‚â§·∂†[MeasureTheory.Measure.ae Œº] ‚Üëf ‚Üí\n      MeasureTheory.SimpleFunc.integral Œº f = ENNReal.toReal (‚à´‚Åª (a : Œ±), ENNReal.ofReal (‚Üëf a) ‚àÇŒº)",
    "name": "MeasureTheory.SimpleFunc.integral_eq_lintegral",
    "doc":
    "`SimpleFunc.bintegral` and `SimpleFunc.integral` agree when the integrand has type\n`Œ± ‚Üí‚Çõ ‚Ñù‚â•0‚àû`. But since `‚Ñù‚â•0‚àû` is not a `NormedSpace`, we need some form of coercion. ",
    "depth": 16}],
  "count": 359},
 {"noDocExamples": [],
  "kind": "MeasureTheory.¬´term‚à´_,_‚àÇ_¬ª",
  "examples":
  [{"term":
    "‚àÄ {Œ± : Type u_1} {m : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {f : Œ± ‚Üí ‚Ñù},\n  MeasureTheory.Integrable f ‚Üí\n    ‚à´ (a : Œ±), f a ‚àÇŒº =\n      ENNReal.toReal (‚à´‚Åª (a : Œ±), ENNReal.ofReal (f a) ‚àÇŒº) - ENNReal.toReal (‚à´‚Åª (a : Œ±), ENNReal.ofReal (-f a) ‚àÇŒº)",
    "name":
    "MeasureTheory.integral_eq_lintegral_pos_part_sub_lintegral_neg_part",
    "doc":
    "The Bochner integral of a real-valued function `f : Œ± ‚Üí ‚Ñù` is the difference between the\nintegral of the positive part of `f` and the integral of the negative part of `f`.  ",
    "depth": 14},
   {"term":
    "‚àÄ {Œ± : Type u_1} {m0 : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {f : Œ± ‚Üí ‚Ñù}\n  [inst : MeasureTheory.IsProbabilityMeasure Œº], MeasureTheory.Integrable f ‚Üí ‚àÉ x, f x ‚â§ ‚à´ (a : Œ±), f a ‚àÇŒº",
    "name": "MeasureTheory.exists_le_integral",
    "doc":
    "**First moment method**. The minimum of an integrable function is smaller than its integral. ",
    "depth": 16},
   {"term":
    "‚àÄ {Œ± : Type u_1} {m0 : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {f : Œ± ‚Üí ‚Ñù}\n  [inst : MeasureTheory.IsProbabilityMeasure Œº], MeasureTheory.Integrable f ‚Üí ‚àÉ x, ‚à´ (a : Œ±), f a ‚àÇŒº ‚â§ f x",
    "name": "MeasureTheory.exists_integral_le",
    "doc":
    "**First moment method**. The maximum of an integrable function is greater than its integral. ",
    "depth": 17},
   {"term":
    "‚àÄ {Œ± : Type u_1} {m0 : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {f : Œ± ‚Üí ‚Ñù}\n  [inst : MeasureTheory.IsProbabilityMeasure Œº], MeasureTheory.Integrable f ‚Üí 0 < ‚Üë‚ÜëŒº {x | f x ‚â§ ‚à´ (a : Œ±), f a ‚àÇŒº}",
    "name": "MeasureTheory.measure_le_integral_pos",
    "doc":
    "**First moment method**. An integrable function is smaller than its integral on a set of\npositive measure. ",
    "depth": 18},
   {"term":
    "‚àÄ {Œ© : Type u_1} [inst : Nonempty Œ©] {m0 : MeasurableSpace Œ©} (Œº : MeasureTheory.FiniteMeasure Œ©) {E : Type u_2}\n  [inst_1 : NormedAddCommGroup E] [inst_2 : NormedSpace ‚Ñù E],\n  Œº ‚â† 0 ‚Üí ‚àÄ (f : Œ© ‚Üí E), MeasureTheory.average (‚ÜëŒº) f = ‚à´ (œâ : Œ©), f œâ ‚àÇ‚Üë(MeasureTheory.FiniteMeasure.normalize Œº)",
    "name": "MeasureTheory.FiniteMeasure.average_eq_integral_normalize",
    "doc":
    "Averaging with respect to a finite measure is the same as integrating against\n`MeasureTheory.FiniteMeasure.normalize`. ",
    "depth": 18}],
  "count": 330},
 {"noDocExamples": [],
  "kind": "termRexp",
  "examples":
  [{"term": "Filter.Tendsto rexp Filter.atTop Filter.atTop",
    "name": "Real.tendsto_exp_atTop",
    "doc": "The real exponential function tends to `+‚àû` at `+‚àû`. ",
    "depth": 5},
   {"term": "Filter.Tendsto rexp (nhds 0) (nhds 1)",
    "name": "Real.tendsto_exp_nhds_0_nhds_1",
    "doc": "The real exponential function tends to `1` at `0`. ",
    "depth": 7},
   {"term": "Filter.Tendsto (fun x => rexp (-x)) Filter.atTop (nhds 0)",
    "name": "Real.tendsto_exp_neg_atTop_nhds_0",
    "doc":
    "The real exponential function tends to `0` at `-‚àû` or, equivalently, `exp(-x)` tends to `0`\nat `+‚àû` ",
    "depth": 8},
   {"term": "Complex.GammaIntegral = mellin fun x => ‚Üë(rexp (-x))",
    "name": "Complex.GammaIntegral_eq_mellin",
    "doc": "Rewrite the Gamma integral as an example of a Mellin transform. ",
    "depth": 8},
   {"term":
    "(fun œÑ => jacobiTheta œÑ - 1) =O[Filter.comap Complex.im Filter.atTop] fun œÑ => rexp (-Real.pi * œÑ.im)",
    "name": "isBigO_at_im_infty_jacobiTheta_sub_one",
    "doc":
    "The norm of `jacobiTheta œÑ - 1` decays exponentially as `im œÑ ‚Üí ‚àû`. ",
    "depth": 9}],
  "count": 298},
 {"noDocExamples": [],
  "kind": "¬´term‚®Å_,_¬ª",
  "examples":
  [{"term":
    "{Œπ : Type v} ‚Üí\n  {Œ≤ : Œπ ‚Üí Type w} ‚Üí [inst : (i : Œπ) ‚Üí AddCommMonoid (Œ≤ i)] ‚Üí [inst_1 : IsEmpty Œπ] ‚Üí Unique (‚®Å (i : Œπ), Œ≤ i)",
    "name": "DirectSum.uniqueOfIsEmpty",
    "doc": "A direct sum over an empty type is trivial. ",
    "depth": 9},
   {"term":
    "{Œπ : Type u_1} ‚Üí\n  [inst : DecidableEq Œπ] ‚Üí\n    (A : Œπ ‚Üí Type u_2) ‚Üí\n      [inst : (i : Œπ) ‚Üí AddCommMonoid (A i)] ‚Üí\n        [inst_1 : AddCommMonoid Œπ] ‚Üí [inst_2 : DirectSum.GCommSemiring A] ‚Üí CommSemiring (‚®Å (i : Œπ), A i)",
    "name": "DirectSum.commSemiring",
    "doc": "The `CommSemiring` structure derived from `GCommSemiring A`. ",
    "depth": 11},
   {"term":
    "{Œπ : Type u_1} ‚Üí\n  [inst : DecidableEq Œπ] ‚Üí\n    (A : Œπ ‚Üí Type u_2) ‚Üí\n      [inst : (i : Œπ) ‚Üí AddCommMonoid (A i)] ‚Üí\n        [inst_1 : AddMonoid Œπ] ‚Üí [inst_2 : DirectSum.GSemiring A] ‚Üí Semiring (‚®Å (i : Œπ), A i)",
    "name": "DirectSum.semiring",
    "doc": "The `Semiring` structure derived from `GSemiring A`. ",
    "depth": 11},
   {"term":
    "{Œπ : Type u_1} ‚Üí {M : Type u_3} ‚Üí [inst : Semiring M] ‚Üí AddMonoidAlgebra M Œπ ‚Üí ‚®Å (x : Œπ), M",
    "name": "AddMonoidAlgebra.toDirectSum",
    "doc": "Interpret an `AddMonoidAlgebra` as a homogenous `DirectSum`. ",
    "depth": 12},
   {"term":
    "(M : Type v) ‚Üí\n  (Œπ : optParam (Type u_1) PUnit.{u_1 + 1}) ‚Üí [inst : AddCommMonoid M] ‚Üí [inst_1 : Unique Œπ] ‚Üí (‚®Å (x : Œπ), M) ‚âÉ+ M",
    "name": "DirectSum.id",
    "doc":
    "The natural equivalence between `‚®Å _ : Œπ, M` and `M` when `Unique Œπ`. ",
    "depth": 13}],
  "count": 296},
 {"noDocExamples": [],
  "kind": "¬´term_‚â•_¬ª",
  "examples":
  [{"term":
    "‚àÄ {Œº : YoungDiagram},\n  YoungDiagram.ofRowLens (YoungDiagram.rowLens Œº) (_ : List.Sorted (fun x x_1 => x ‚â• x_1) (YoungDiagram.rowLens Œº)) = Œº",
    "name": "YoungDiagram.ofRowLens_to_rowLens_eq_self",
    "doc": "The left_inv direction of the equivalence ",
    "depth": 6},
   {"term":
    "‚àÄ {w : List ‚Ñï} {hw : List.Sorted (fun x x_1 => x ‚â• x_1) w} (i : Fin (List.length w)),\n  YoungDiagram.rowLen (YoungDiagram.ofRowLens w hw) ‚Üëi = List.get w i",
    "name": "YoungDiagram.rowLen_ofRowLens",
    "doc":
    "The length of the `i`th row in `ofRowLens w hw` is the `i`th entry of `w` ",
    "depth": 10},
   {"term":
    "‚àÄ {w : List ‚Ñï} {hw : List.Sorted (fun x x_1 => x ‚â• x_1) w},\n  (‚àÄ (x : ‚Ñï), x ‚àà w ‚Üí 0 < x) ‚Üí YoungDiagram.rowLens (YoungDiagram.ofRowLens w hw) = w",
    "name": "YoungDiagram.rowLens_ofRowLens_eq_self",
    "doc": "The right_inv direction of the equivalence ",
    "depth": 10},
   {"term":
    "‚àÄ {w : List ‚Ñï} {hw : List.Sorted (fun x x_1 => x ‚â• x_1) w},\n  (‚àÄ (x : ‚Ñï), x ‚àà w ‚Üí 0 < x) ‚Üí List.length (YoungDiagram.rowLens (YoungDiagram.ofRowLens w hw)) = List.length w",
    "name": "YoungDiagram.rowLens_length_ofRowLens",
    "doc": "The number of rows in `ofRowLens w hw` is the length of `w` ",
    "depth": 10},
   {"term":
    "(w : List ‚Ñï) ‚Üí List.Sorted (fun x x_1 => x ‚â• x_1) w ‚Üí YoungDiagram",
    "name": "YoungDiagram.ofRowLens",
    "doc": "Young diagram from a sorted list ",
    "depth": 10}],
  "count": 292},
 {"noDocExamples": [],
  "kind": "Lean.Parser.Term.match",
  "examples":
  [{"term":
    "‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] {a : Thunk Œ±} {Œµ : Type u_2} [self : Estimator a Œµ] (e : Œµ),\n  match EstimatorData.improve a e with\n  | none => EstimatorData.bound a e = Thunk.get a\n  | some e' => EstimatorData.bound a e < EstimatorData.bound a e'",
    "name": "Estimator.improve_spec",
    "doc":
    "Calling `improve` either gives a strictly better bound,\nor a proof that the current bound is exact. ",
    "depth": 18},
   {"term":
    "{C : Type u_1} ‚Üí\n  [inst : CategoryTheory.Category.{u_2, u_1} C] ‚Üí\n    {B X : C} ‚Üí\n      (f : X ‚ü∂ B) ‚Üí\n        [inst_1 : CategoryTheory.EffectiveEpi f] ‚Üí\n          CategoryTheory.EffectiveEpiFamilyStruct (fun x => X) fun x =>\n            match x with\n            | PUnit.unit => f",
    "name": "CategoryTheory.EffectiveEpi_familyStruct",
    "doc": "An `EffectiveEpiFamily` consisting of a single `EffectiveEpi`\n",
    "depth": 18},
   {"term":
    "‚àÄ {Œ± : Type u_2} [inst : PartialOrder Œ±] {Œµ : Type u_1} (a : Thunk Œ±) (p : Œ± ‚Üí Bool) [inst_1 : Estimator a Œµ]\n  [inst_2 : WellFoundedGT ‚Üë(Set.range (EstimatorData.bound a))] (e : Œµ),\n  match Estimator.improveUntil a p e with\n  | Except.error a_1 => ¬¨p (Thunk.get a) = true\n  | Except.ok e' => p (EstimatorData.bound a e') = true",
    "name": "Estimator.improveUntil_spec",
    "doc":
    "If `Estimator.improveUntil a p e` returns `some e'`, then `bound a e'` satisfies `p`.\nOtherwise, that value `a` must not satisfy `p`.\n",
    "depth": 21},
   {"term":
    "‚àÄ {Œ± : Type u_2} [inst : PartialOrder Œ±] {Œµ : Type u_1} (a : Thunk Œ±) (p : Œ± ‚Üí Bool) [inst_1 : Estimator a Œµ]\n  [inst_2 : WellFoundedGT ‚Üë(Set.range (EstimatorData.bound a))] (e : Œµ) (r : Bool),\n  match Estimator.improveUntilAux a p e r with\n  | Except.error a_1 => ¬¨p (Thunk.get a) = true\n  | Except.ok e' => p (EstimatorData.bound a e') = true",
    "name": "Estimator.improveUntilAux_spec",
    "doc":
    "If `Estimator.improveUntil a p e` returns `some e'`, then `bound a e'` satisfies `p`.\nOtherwise, that value `a` must not satisfy `p`.\n",
    "depth": 22},
   {"term":
    "‚àÄ {Œ± Œ≤ Œ¥ : Type} [inst : CanonicallyLinearOrderedAddMonoid Œ¥] {C : Levenshtein.Cost Œ± Œ≤ Œ¥} {xs : List Œ±} {ys : List Œ≤}\n  (self : LevenshteinEstimator' C xs ys),\n  self.bound =\n    match self.pre_rev, (_ : List.reverse self.pre_rev ++ self.suff = ys) with\n    | [], split => ((‚Üëself.distances)[0], List.length ys)\n    | x, split => (List.minimum_of_length_pos (_ : 0 < List.length ‚Üëself.distances), List.length self.suff)",
    "name": "LevenshteinEstimator'.bound_eq",
    "doc": "Predicate describing the current bound. ",
    "depth": 27}],
  "count": 286},
 {"noDocExamples": [],
  "kind": "¬´term_‚Üí‚Çô*_¬ª",
  "examples":
  [{"term": "(M : Type u_9) ‚Üí [inst : Mul M] ‚Üí M ‚Üí‚Çô* M",
    "name": "MulHom.id",
    "doc": "The identity map from a type with multiplication to itself. ",
    "depth": 6},
   {"term": "{Œ± : Type u_2} ‚Üí [inst : Mul Œ±] ‚Üí Œ± ‚Üí‚Çô* Filter Œ±",
    "name": "Filter.pureMulHom",
    "doc": "`pure` operation as a `MulHom`. ",
    "depth": 6},
   {"term": "{Œ± : Type u_2} ‚Üí [inst : Mul Œ±] ‚Üí Œ± ‚Üí‚Çô* Set Œ±",
    "name": "Set.singletonMulHom",
    "doc": "The singleton operation as a `MulHom`. ",
    "depth": 6},
   {"term": "{Œ± : Type u} ‚Üí FreeMagma Œ± ‚Üí‚Çô* FreeSemigroup Œ±",
    "name": "FreeMagma.toFreeSemigroup",
    "doc":
    "The canonical multiplicative morphism from `FreeMagma Œ±` to `FreeSemigroup Œ±`. ",
    "depth": 6},
   {"term": "{Œ± : Type u} ‚Üí [inst : Mul Œ±] ‚Üí Œ± ‚Üí‚Çô* WithOne Œ±",
    "name": "WithOne.coeMulHom",
    "doc": "`WithOne.coe` as a bundled morphism ",
    "depth": 6}],
  "count": 272},
 {"noDocExamples": [],
  "kind": "Asymptotics.¬´term_=O[_]_¬ª",
  "examples":
  [{"term":
    "(fun œÑ => jacobiTheta œÑ - 1) =O[Filter.comap Complex.im Filter.atTop] fun œÑ => rexp (-Real.pi * œÑ.im)",
    "name": "isBigO_at_im_infty_jacobiTheta_sub_one",
    "doc":
    "The norm of `jacobiTheta œÑ - 1` decays exponentially as `im œÑ ‚Üí ‚àû`. ",
    "depth": 9},
   {"term": "zetaKernel‚ÇÅ =O[Filter.atTop] fun t => rexp (-Real.pi * t)",
    "name": "isBigO_atTop_zetaKernel‚ÇÅ",
    "doc": "Bound for `zetaKernel‚ÇÅ` for large `t`. ",
    "depth": 9},
   {"term": "zetaKernel‚ÇÇ =O[Filter.atTop] fun t => rexp (-Real.pi * t)",
    "name": "isBigO_atTop_zetaKernel‚ÇÇ",
    "doc": "Bound for `zetaKernel‚ÇÇ` for large `t`. ",
    "depth": 9},
   {"term":
    "‚àÄ (a : ‚Ñù), zetaKernel‚ÇÇ =O[nhdsWithin 0 (Set.Ioi 0)] fun t => t ^ a",
    "name": "isBigO_zero_zetaKernel‚ÇÇ_rpow",
    "doc": "Weaker but more usable bound for `zetaKernel‚ÇÇ` for `t ‚Üí 0`. ",
    "depth": 10},
   {"term":
    "zetaKernel‚ÇÇ =O[nhdsWithin 0 (Set.Ioi 0)] fun t => rexp (-Real.pi / t) / Real.sqrt t",
    "name": "isBigO_zero_zetaKernel‚ÇÇ",
    "doc": "Precise but awkward-to-use bound for `zetaKernel‚ÇÇ` for `t ‚Üí 0`. ",
    "depth": 11}],
  "count": 267},
 {"noDocExamples": [],
  "kind": "termDepIfThenElse",
  "examples":
  [{"term":
    "‚àÄ {Œ± : Sort u_2} (P : Prop) [inst : Decidable P] (a b : Œ±), (if x : P then a else b) = if P then a else b",
    "name": "dite_eq_ite",
    "doc":
    "A `dite` whose results do not actually depend on the condition may be reduced to an `ite`. ",
    "depth": 12},
   {"term":
    "‚àÄ {Œ± : Sort u_1} {Œ≤ : Sort u_2} (f : Œ± ‚Üí Œ≤) (P : Prop) [inst : Decidable P] (x : P ‚Üí Œ±) (y : ¬¨P ‚Üí Œ±),\n  f (dite P x y) = if h : P then f (x h) else f (y h)",
    "name": "apply_dite",
    "doc":
    "A function applied to a `dite` is a `dite` of that function applied to each of the branches. ",
    "depth": 15},
   {"term":
    "‚àÄ {Œ± : Sort u_2} {œÉ : Œ± ‚Üí Sort u_1} (P : Prop) [inst : Decidable P] (f : P ‚Üí (a : Œ±) ‚Üí œÉ a) (g : ¬¨P ‚Üí (a : Œ±) ‚Üí œÉ a)\n  (a : Œ±), dite P f g a = if h : P then f h a else g h a",
    "name": "dite_apply",
    "doc":
    "A 'dite' producing a `Pi` type `Œ† a, œÉ a`, applied to a value `a : Œ±` is a `dite` that applies\neither branch to `a`. ",
    "depth": 17},
   {"term":
    "‚àÄ {Œ± : Sort u_3} {Œ≤ : Sort u_4} {Œ≥ : Sort u_2} (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) (P : Prop) [inst : Decidable P] (a : P ‚Üí Œ±) (b : ¬¨P ‚Üí Œ±)\n  (c : P ‚Üí Œ≤) (d : ¬¨P ‚Üí Œ≤), f (dite P a b) (dite P c d) = if h : P then f (a h) (c h) else f (b h) (d h)",
    "name": "apply_dite‚ÇÇ",
    "doc":
    "A two-argument function applied to two `dite`s is a `dite` of that two-argument function\napplied to each of the branches. ",
    "depth": 19},
   {"term":
    "‚àÄ {J : Type w} {C : Type u} [inst : CategoryTheory.Category.{v, u} C]\n  [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] {F : J ‚Üí C} (self : CategoryTheory.Limits.Bicone F) (j j' : J),\n  CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Bicone.Œπ self j) (CategoryTheory.Limits.Bicone.œÄ self j') =\n    if h : j = j' then CategoryTheory.eqToHom (_ : F j = F j') else 0",
    "name": "CategoryTheory.Limits.Bicone.Œπ_œÄ",
    "doc":
    "A `c : Bicone F` is:\n* an object `c.pt` and\n* morphisms `œÄ j : pt ‚ü∂ F j` and `Œπ j : F j ‚ü∂ pt` for each `j`,\n* such that `Œπ j ‚â´ œÄ j'` is the identity when `j = j'` and zero otherwise.\n",
    "depth": 20}],
  "count": 264},
 {"noDocExamples": [],
  "kind": "¬´term_<$>_¬ª",
  "examples":
  [{"term":
    "‚àÄ {Œ± Œ≤ Œ≥ : Type u_1} (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) (a : Option Œ±) (b : Option Œ≤), Option.map‚ÇÇ f a b = Seq.seq (f <$> a) fun x => b",
    "name": "Option.map‚ÇÇ_def",
    "doc":
    "`Option.map‚ÇÇ` in terms of monadic operations. Note that this can't be taken as the definition\nbecause of the lack of universe polymorphism. ",
    "depth": 15},
   {"term":
    "‚àÄ {Œ± Œ≤ Œ≥ : Type u_1} (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) (s : Set Œ±) (t : Set Œ≤), Set.image2 f s t = Seq.seq (f <$> s) fun x => t",
    "name": "Set.image2_def",
    "doc":
    "`Set.image2` in terms of monadic operations. Note that this can't be taken as the definition\nbecause of the lack of universe polymorphism. ",
    "depth": 15},
   {"term":
    "‚àÄ {m : Type u_1 ‚Üí Type u_2} {Œ± Œ±_1 : Type u_1} {p : Œ±_1 ‚Üí Prop} {f : Œ± ‚Üí Œ±_1} [inst : Functor m]\n  [inst_1 : LawfulFunctor m] {x : m Œ±}, SatisfiesM (fun a => p (f a)) x ‚Üí SatisfiesM p (f <$> x)",
    "name": "SatisfiesM.map_pre",
    "doc":
    "`SatisfiesM` distributes over `<$>`, weakest precondition version.\n(Use this for reasoning backward from the goal.)\n",
    "depth": 16},
   {"term":
    "‚àÄ {t : Type u ‚Üí Type u} [inst : Traversable t] [self : LawfulTraversable t] {Œ± Œ≤ : Type u} (f : Œ± ‚Üí Œ≤) (x : t Œ±),\n  traverse (pure ‚àò f) x = id.mk (f <$> x)",
    "name": "LawfulTraversable.traverse_eq_map_id",
    "doc": "An axiom for `traverse` involving `pure : Œ≤ ‚Üí Id Œ≤`. ",
    "depth": 18},
   {"term":
    "‚àÄ {m : Type u_1 ‚Üí Type u_2} {Œ± : Type u_1} {p : Œ± ‚Üí Prop} {Œ±_1 : Type u_1} {q : Œ±_1 ‚Üí Prop} {f : Œ± ‚Üí Œ±_1}\n  [inst : Functor m] [inst_1 : LawfulFunctor m] {x : m Œ±},\n  SatisfiesM p x ‚Üí (‚àÄ {a : Œ±}, p a ‚Üí q (f a)) ‚Üí SatisfiesM q (f <$> x)",
    "name": "SatisfiesM.map",
    "doc": "`SatisfiesM` distributes over `<$>`, general version. ",
    "depth": 18}],
  "count": 241},
 {"noDocExamples": [],
  "kind": "Function.term_On_",
  "examples":
  [{"term":
    "‚àÄ {Œ± : Type u_1} {Œπ : Type u_4} {f : Œπ ‚Üí Œ±}, Function.Injective f ‚Üí Pairwise ((fun x x_1 => x ‚â† x_1) on f)",
    "name": "Function.Injective.pairwise_ne",
    "doc":
    "**Alias** of the forward direction of `Function.injective_iff_pairwise_ne`.",
    "depth": 12},
   {"term":
    "‚àÄ {Œ± : Type u_1} {Œπ : Type u_3} [inst : CompleteLattice Œ±] {t : Œπ ‚Üí Œ±},\n  CompleteLattice.Independent t ‚Üí Pairwise (Disjoint on t)",
    "name": "CompleteLattice.Independent.pairwiseDisjoint",
    "doc":
    "If the elements of a set are independent, then any pair within that set is disjoint. ",
    "depth": 16},
   {"term":
    "‚àÄ {Œ± : Type u_1} [inst : GeneralizedBooleanAlgebra Œ±] {f d : ‚Ñï ‚Üí Œ±},\n  Pairwise (Disjoint on d) ‚Üí partialSups d = partialSups f ‚Üí d = disjointed f",
    "name": "disjointed_unique",
    "doc":
    "`disjointed f` is the unique sequence that is pairwise disjoint and has the same partial sups\nas `f`. ",
    "depth": 16},
   {"term":
    "‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_3} {Œ≥ : Type u_4} {rŒ± : Œ± ‚Üí Œ± ‚Üí Prop} {rŒ≤ : Œ≤ ‚Üí Œ≤ ‚Üí Prop} {f : Œ≥ ‚Üí Œ±} {g : Œ≥ ‚Üí Œ≤},\n  WellFounded (rŒ± on f) ‚Üí\n    (‚àÄ (a : Œ±), Set.WellFoundedOn (f ‚Åª¬π' {a}) (rŒ≤ on g)) ‚Üí WellFounded (Prod.Lex rŒ± rŒ≤ on fun c => (f c, g c))",
    "name": "WellFounded.prod_lex_of_wellFoundedOn_fiber",
    "doc":
    "Stronger version of `WellFounded.prod_lex`. Instead of requiring `rŒ≤ on g` to be well-founded,\nwe only require it to be well-founded on fibers of `f`.",
    "depth": 17},
   {"term":
    "‚àÄ {Œπ : Type u_1} {Œ≥ : Type u_4} {œÄ : Œπ ‚Üí Type u_5} {rŒπ : Œπ ‚Üí Œπ ‚Üí Prop} {rœÄ : (i : Œπ) ‚Üí œÄ i ‚Üí œÄ i ‚Üí Prop} {f : Œ≥ ‚Üí Œπ}\n  {g : (i : Œπ) ‚Üí Œ≥ ‚Üí œÄ i},\n  WellFounded (rŒπ on f) ‚Üí\n    (‚àÄ (i : Œπ), Set.WellFoundedOn (f ‚Åª¬π' {i}) (rœÄ i on g i)) ‚Üí\n      WellFounded (Sigma.Lex rŒπ rœÄ on fun c => { fst := f c, snd := g (f c) c })",
    "name": "WellFounded.sigma_lex_of_wellFoundedOn_fiber",
    "doc":
    "Stronger version of `PSigma.lex_wf`. Instead of requiring `rœÄ on g` to be well-founded, we only\nrequire it to be well-founded on fibers of `f`.",
    "depth": 17}],
  "count": 233},
 {"noDocExamples": [],
  "kind": "List.¬´term_~_¬ª",
  "examples":
  [{"term":
    "{Œ± : Type u} ‚Üí (xs ys : List Œ±) ‚Üí xs ~ ys ‚Üí List.Nodup ys ‚Üí SlimCheck.InjectiveFunction Œ±",
    "name": "SlimCheck.InjectiveFunction.mk",
    "doc":
    "Create an injective function from one list and a permutation of that list. ",
    "depth": 7},
   {"term": "‚àÄ {Œ± : Type uu} {a : Œ±} {l : List Œ±}, l ~ [a] ‚Üí l = [a]",
    "name": "List.Perm.eq_singleton",
    "doc": "**Alias** of the forward direction of `List.perm_singleton`.",
    "depth": 8},
   {"term": "{Œ± : Type u} ‚Üí (xs : List Œ±) ‚Üí SlimCheck.Gen { ys // xs ~ ys }",
    "name": "SlimCheck.Gen.permutationOf",
    "doc": "Generate a random permutation of a given list. ",
    "depth": 8},
   {"term": "‚àÄ {Œ± : Type uu} {a : Œ±} {l : List Œ±}, [a] ~ l ‚Üí [a] = l",
    "name": "List.Perm.singleton_eq",
    "doc": "**Alias** of the forward direction of `List.singleton_perm`.",
    "depth": 9},
   {"term":
    "‚àÄ {n : ‚Ñï} {l : List ‚Ñï}, List.prod l = n ‚Üí (‚àÄ (p : ‚Ñï), p ‚àà l ‚Üí Nat.Prime p) ‚Üí l ~ Nat.factors n",
    "name": "Nat.factors_unique",
    "doc": "**Fundamental theorem of arithmetic**",
    "depth": 11}],
  "count": 231},
 {"noDocExamples": [],
  "kind": "Asymptotics.¬´term_=o[_]_¬ª",
  "examples":
  [{"term": "‚àÄ (s : ‚Ñù), (fun x => x ^ s) =o[Filter.atTop] rexp",
    "name": "isLittleO_rpow_exp_atTop",
    "doc": "`x ^ s = o(exp x)` as `x ‚Üí ‚àû` for any real `s`. ",
    "depth": 10},
   {"term":
    "‚àÄ (k : ‚Ñ§) {b : ‚Ñù}, 0 < b ‚Üí (fun x => x ^ ‚Üëk) =o[Filter.atTop] fun x => rexp (b * x)",
    "name": "isLittleO_zpow_exp_pos_mul_atTop",
    "doc":
    "`x ^ k = o(exp(b * x))` as `x ‚Üí ‚àû` for any integer `k` and positive `b`. ",
    "depth": 12},
   {"term":
    "‚àÄ {R : Type u_4} [inst : NormedRing R] {r : ‚Ñù}, 1 < r ‚Üí Nat.cast =o[Filter.atTop] fun n => r ^ n",
    "name": "isLittleO_coe_const_pow_of_one_lt",
    "doc": "For a real `r > 1` we have `n = o(r ^ n)` as `n ‚Üí ‚àû`. ",
    "depth": 12},
   {"term":
    "‚àÄ (k : ‚Ñï) {b : ‚Ñù}, 0 < b ‚Üí (fun x => x ^ ‚Üëk) =o[Filter.atTop] fun x => rexp (b * x)",
    "name": "isLittleO_pow_exp_pos_mul_atTop",
    "doc":
    "`x ^ k = o(exp(b * x))` as `x ‚Üí ‚àû` for any natural `k` and positive `b`. ",
    "depth": 12},
   {"term":
    "‚àÄ (s : ‚Ñù) {b : ‚Ñù}, 0 < b ‚Üí (fun x => x ^ s) =o[Filter.atTop] fun x => rexp (b * x)",
    "name": "isLittleO_rpow_exp_pos_mul_atTop",
    "doc":
    "`x ^ s = o(exp(b * x))` as `x ‚Üí ‚àû` for any real `s` and positive `b`. ",
    "depth": 12}],
  "count": 229},
 {"noDocExamples": [],
  "kind": "¬´term_‚Üí·µÉ[_]_¬ª",
  "examples":
  [{"term":
    "(k : Type u_1) ‚Üí\n  {V1 : Type u_2} ‚Üí\n    (P1 : Type u_3) ‚Üí\n      [inst : Ring k] ‚Üí [inst_1 : AddCommGroup V1] ‚Üí [inst_2 : Module k V1] ‚Üí [inst_3 : AddTorsor V1 P1] ‚Üí P1 ‚Üí·µÉ[k] P1",
    "name": "AffineMap.id",
    "doc": "Identity map as an affine map. ",
    "depth": 19},
   {"term":
    "{k : Type u_1} ‚Üí\n  {V1 : Type u_2} ‚Üí\n    {P1 : Type u_3} ‚Üí\n      [inst : Ring k] ‚Üí\n        [inst_1 : AddCommGroup V1] ‚Üí [inst_2 : Module k V1] ‚Üí [inst_3 : AddTorsor V1 P1] ‚Üí P1 ‚Üí P1 ‚Üí k ‚Üí·µÉ[k] P1",
    "name": "AffineMap.lineMap",
    "doc":
    "The affine map from `k` to `P1` sending `0` to `p‚ÇÄ` and `1` to `p‚ÇÅ`. ",
    "depth": 21},
   {"term":
    "{Œπ : Type u_1} ‚Üí\n  {k : Type u_3} ‚Üí\n    {V : Type u_4} ‚Üí\n      {P : Type u_5} ‚Üí\n        [inst : AddCommGroup V] ‚Üí\n          [inst_1 : AddTorsor V P] ‚Üí [inst_2 : Ring k] ‚Üí [inst_3 : Module k V] ‚Üí AffineBasis Œπ k P ‚Üí P ‚Üí·µÉ[k] Œπ ‚Üí k",
    "name": "AffineBasis.coords",
    "doc": "Barycentric coordinates as an affine map. ",
    "depth": 21},
   {"term":
    "{k : Type u_2} ‚Üí\n  {V1 : Type u_3} ‚Üí\n    {P1 : Type u_4} ‚Üí\n      [inst : CommRing k] ‚Üí\n        [inst_1 : AddCommGroup V1] ‚Üí [inst_2 : AddTorsor V1 P1] ‚Üí [inst_3 : Module k V1] ‚Üí P1 ‚Üí k ‚Üí P1 ‚Üí·µÉ[k] P1",
    "name": "AffineMap.homothety",
    "doc":
    "`homothety c r` is the homothety (also known as dilation) about `c` with scale factor `r`. ",
    "depth": 21},
   {"term":
    "{k : Type u_1} ‚Üí\n  {V‚ÇÅ : Type u_2} ‚Üí\n    {V‚ÇÇ : Type u_3} ‚Üí\n      [inst : Ring k] ‚Üí\n        [inst_1 : AddCommGroup V‚ÇÅ] ‚Üí\n          [inst_2 : Module k V‚ÇÅ] ‚Üí [inst_3 : AddCommGroup V‚ÇÇ] ‚Üí [inst_4 : Module k V‚ÇÇ] ‚Üí (V‚ÇÅ ‚Üí‚Çó[k] V‚ÇÇ) ‚Üí V‚ÇÅ ‚Üí·µÉ[k] V‚ÇÇ",
    "name": "LinearMap.toAffineMap",
    "doc": "Reinterpret a linear map as an affine map. ",
    "depth": 21}],
  "count": 220},
 {"noDocExamples": [],
  "kind": "MeasureTheory.¬´term‚à´_In_,_‚àÇ_¬ª",
  "examples":
  [{"term":
    "‚àÄ {Œ± : Type u_1} {m0 : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {f : Œ± ‚Üí ‚Ñù},\n  MeasureTheory.StronglyMeasurable f ‚Üí\n    MeasureTheory.Integrable f ‚Üí\n      (‚àÄ (s : Set Œ±), MeasurableSet s ‚Üí ‚Üë‚ÜëŒº s < ‚ä§ ‚Üí 0 ‚â§ ‚à´ (x : Œ±) in s, f x ‚àÇŒº) ‚Üí 0 ‚â§·∂†[MeasureTheory.Measure.ae Œº] f",
    "name":
    "MeasureTheory.ae_nonneg_of_forall_set_integral_nonneg_of_stronglyMeasurable",
    "doc":
    "Don't use this lemma. Use `ae_nonneg_of_forall_set_integral_nonneg`. ",
    "depth": 20},
   {"term":
    "‚àÄ {Œ± : Type u_1} {E : Type u_3} [inst : MeasurableSpace Œ±] [inst_1 : NormedAddCommGroup E] {f : Œ± ‚Üí E} {s : Set Œ±}\n  {Œº : MeasureTheory.Measure Œ±} [inst_2 : NormedSpace ‚Ñù E],\n  (‚àÄ (x : Œ±), ¬¨x ‚àà s ‚Üí f x = 0) ‚Üí ‚à´ (x : Œ±) in s, f x ‚àÇŒº = ‚à´ (x : Œ±), f x ‚àÇŒº",
    "name": "MeasureTheory.set_integral_eq_integral_of_forall_compl_eq_zero",
    "doc":
    "If a function vanishes on `s·∂ú`, then its integral on `s` coincides with its integral on the\nwhole space. ",
    "depth": 21},
   {"term":
    "‚àÄ {Œ± : Type u_1} [inst : MeasurableSpace Œ±] {Œº : MeasureTheory.Measure Œ±} {f g : Œ± ‚Üí ‚Ñù} {s : Set Œ±}\n  [inst_1 : MeasureTheory.SigmaFinite Œº],\n  MeasureTheory.IntegrableOn f s ‚Üí\n    MeasureTheory.IntegrableOn g s ‚Üí\n      MeasurableSet s ‚Üí\n        (‚àÄ (x : Œ±), x ‚àà s ‚Üí f x ‚â§ g x) ‚Üí\n          ‚Üë‚Üë(MeasureTheory.Measure.prod Œº MeasureTheory.volume) (regionBetween f g s) =\n            ENNReal.ofReal (‚à´ (y : Œ±) in s, (g - f) y ‚àÇŒº)",
    "name": "volume_regionBetween_eq_integral",
    "doc":
    "If two functions are integrable on a measurable set, and one function is less than\nor equal to the other on that set, then the volume of the region\nbetween the two functions can be represented as an integral. ",
    "depth": 23},
   {"term":
    "‚àÄ {Œ± : Type u_1} {G : Type u_5} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace ‚Ñù G] {m : MeasurableSpace Œ±}\n  {Œº : MeasureTheory.Measure Œ±} {Œπ : Type u_6} {f : Œ± ‚Üí G},\n  MeasureTheory.HasFiniteIntegral f ‚Üí\n    ‚àÄ {l : Filter Œπ} {s : Œπ ‚Üí Set Œ±},\n      Filter.Tendsto (‚Üë‚ÜëŒº ‚àò s) l (nhds 0) ‚Üí Filter.Tendsto (fun i => ‚à´ (x : Œ±) in s i, f x ‚àÇŒº) l (nhds 0)",
    "name": "MeasureTheory.HasFiniteIntegral.tendsto_set_integral_nhds_zero",
    "doc":
    "If `f` has finite integral, then `‚à´ x in s, f x ‚àÇŒº` is absolutely continuous in `s`: it tends\nto zero as `Œº s` tends to zero. ",
    "depth": 23},
   {"term":
    "‚àÄ {Œ± : Type u_1} {G : Type u_5} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace ‚Ñù G] {m : MeasurableSpace Œ±}\n  {Œº : MeasureTheory.Measure Œ±} {Œπ : Type u_6} {f : Œ± ‚Üí G},\n  MeasureTheory.Integrable f ‚Üí\n    ‚àÄ {l : Filter Œπ} {s : Œπ ‚Üí Set Œ±},\n      Filter.Tendsto (‚Üë‚ÜëŒº ‚àò s) l (nhds 0) ‚Üí Filter.Tendsto (fun i => ‚à´ (x : Œ±) in s i, f x ‚àÇŒº) l (nhds 0)",
    "name": "MeasureTheory.Integrable.tendsto_set_integral_nhds_zero",
    "doc":
    "If `f` is integrable, then `‚à´ x in s, f x ‚àÇŒº` is absolutely continuous in `s`: it tends\nto zero as `Œº s` tends to zero. ",
    "depth": 23}],
  "count": 220},
 {"noDocExamples": [],
  "kind": "¬´term_‚Üí._¬ª",
  "examples":
  [{"term": "(Œ± : Type u_7) ‚Üí Œ± ‚Üí. Œ±",
    "name": "PFun.id",
    "doc": "The identity as a partial function ",
    "depth": 3},
   {"term": "Nat.Partrec.Code ‚Üí ‚Ñï ‚Üí. ‚Ñï",
    "name": "Nat.Partrec.Code.eval",
    "doc":
    "The interpretation of a `Nat.Partrec.Code` as a partial function.\n* `Nat.Partrec.Code.zero`: The constant zero function.\n* `Nat.Partrec.Code.succ`: The successor function.\n* `Nat.Partrec.Code.left`: Left unpairing of a pair of ‚Ñï (encoded by `Nat.pair`)\n* `Nat.Partrec.Code.right`: Right unpairing of a pair of ‚Ñï (encoded by `Nat.pair`)\n* `Nat.Partrec.Code.pair`: Pairs the outputs of argument codes using `Nat.pair`.\n* `Nat.Partrec.Code.comp`: Composition of two argument codes.\n* `Nat.Partrec.Code.prec`: Primitive recursion. Given an argument of the form `Nat.pair a n`:\n  * If `n = 0`, returns `eval cf a`.\n  * If `n = succ k`, returns `eval cg (pair a (pair k (eval (prec cf cg) (pair a k))))`\n* `Nat.Partrec.Code.rfind'`: Minimization. For `f` an argument of the form `Nat.pair a m`,\n  `rfind' f m` returns the least `a` such that `f a m = 0`, if one exists and `f b m` terminates\n  for `b < a`\n",
    "depth": 3},
   {"term": "Turing.ToPartrec.Code ‚Üí List ‚Ñï ‚Üí. List ‚Ñï",
    "name": "Turing.ToPartrec.Code.eval",
    "doc":
    "The semantics of the `Code` primitives, as partial functions `List ‚Ñï ‚Üí. List ‚Ñï`. By convention\nwe functions that return a single result return a singleton `[n]`, or in some cases `n :: v` where\n`v` will be ignored by a subsequent function.\n\n* `zero'` appends a `0` to the input. That is, `zero' v = 0 :: v`.\n* `succ` returns the successor of the head of the input, defaulting to zero if there is no head:\n  * `succ [] = [1]`\n  * `succ (n :: v) = [n + 1]`\n* `tail` returns the tail of the input\n  * `tail [] = []`\n  * `tail (n :: v) = v`\n* `cons f fs` calls `f` and `fs` on the input and conses the results:\n  * `cons f fs v = (f v).head :: fs v`\n* `comp f g` calls `f` on the output of `g`:\n  * `comp f g v = f (g v)`\n* `case f g` cases on the head of the input, calling `f` or `g` depending on whether it is zero or\n  a successor (similar to `Nat.casesOn`).\n  * `case f g [] = f []`\n  * `case f g (0 :: v) = f v`\n  * `case f g (n+1 :: v) = g (n :: v)`\n* `fix f` calls `f` repeatedly, using the head of the result of `f` to decide whether to call `f`\n  again or finish:\n  * `fix f v = []` if `f v = []`\n  * `fix f v = w` if `f v = 0 :: w`\n  * `fix f v = fix f w` if `f v = n+1 :: w` (the exact value of `n` is discarded)\n",
    "depth": 4},
   {"term": "Turing.ToPartrec.Cont ‚Üí List ‚Ñï ‚Üí. List ‚Ñï",
    "name": "Turing.ToPartrec.Cont.eval",
    "doc": "The semantics of a continuation. ",
    "depth": 4},
   {"term": "{Œ± : Type u_1} ‚Üí {Œ≤ : Type u_2} ‚Üí (Œ± ‚Üí. Œ≤) ‚Üí Set Œ≤",
    "name": "PFun.ran",
    "doc":
    "The range of a partial function is the set of values\n`f x` where `x` is in the domain of `f`. ",
    "depth": 5}],
  "count": 209},
 {"noDocExamples": [],
  "kind": "MeasureTheory.¬´term_‚Üí‚Çò[_]_¬ª",
  "examples":
  [{"term":
    "{Œ± : Type u_1} ‚Üí [inst : MeasurableSpace Œ±] ‚Üí {Œº : MeasureTheory.Measure Œ±} ‚Üí (Œ± ‚Üí‚Çò[Œº] ENNReal) ‚Üí ENNReal",
    "name": "MeasureTheory.AEEqFun.lintegral",
    "doc": "For `f : Œ± ‚Üí ‚Ñù‚â•0‚àû`, define `‚à´ [f]` to be `‚à´ f` ",
    "depth": 9},
   {"term":
    "{Œ± : Type u_1} ‚Üí\n  {Œ≤ : Type u_2} ‚Üí\n    [inst : MeasurableSpace Œ±] ‚Üí {Œº : MeasureTheory.Measure Œ±} ‚Üí [inst_1 : TopologicalSpace Œ≤] ‚Üí (Œ± ‚Üí‚Çò[Œº] Œ≤) ‚Üí Œ± ‚Üí Œ≤",
    "name": "MeasureTheory.AEEqFun.cast",
    "doc":
    "Coercion from a space of equivalence classes of almost everywhere strongly measurable\nfunctions to functions. ",
    "depth": 11},
   {"term":
    "(Œ± : Type u_1) ‚Üí\n  {Œ≤ : Type u_2} ‚Üí\n    [inst : MeasurableSpace Œ±] ‚Üí {Œº : MeasureTheory.Measure Œ±} ‚Üí [inst_1 : TopologicalSpace Œ≤] ‚Üí Œ≤ ‚Üí Œ± ‚Üí‚Çò[Œº] Œ≤",
    "name": "MeasureTheory.AEEqFun.const",
    "doc":
    "The equivalence class of a constant function: `[fun _ : Œ± => b]`, based on the equivalence\nrelation of being almost everywhere equal ",
    "depth": 11},
   {"term":
    "{Œ± : Type u_1} ‚Üí\n  {Œ≤ : Type u_2} ‚Üí\n    [inst : MeasurableSpace Œ±] ‚Üí\n      {Œº : MeasureTheory.Measure Œ±} ‚Üí\n        [inst_1 : TopologicalSpace Œ≤] ‚Üí (Œ± ‚Üí‚Çò[Œº] Œ≤) ‚Üí Filter.Germ (MeasureTheory.Measure.ae Œº) Œ≤",
    "name": "MeasureTheory.AEEqFun.toGerm",
    "doc":
    "Interpret `f : Œ± ‚Üí‚Çò[Œº] Œ≤` as a germ at `Œº.ae` forgetting that `f` is almost everywhere\nstrongly measurable. ",
    "depth": 11},
   {"term":
    "{Œ± : Type u_1} ‚Üí\n  {Œ≤ : Type u_2} ‚Üí\n    [inst : MeasurableSpace Œ±] ‚Üí\n      {Œº : MeasureTheory.Measure Œ±} ‚Üí [inst_1 : TopologicalSpace Œ≤] ‚Üí CoeFun (Œ± ‚Üí‚Çò[Œº] Œ≤) fun x => Œ± ‚Üí Œ≤",
    "name": "MeasureTheory.AEEqFun.instCoeFun",
    "doc": "A measurable representative of an `AEEqFun` [f] ",
    "depth": 12}],
  "count": 209},
 {"noDocExamples":
  [{"term":
    "‚àÄ {R : Type u} [inst : CommSemiring R] {A : Type v‚ÇÅ} [inst_1 : Semiring A] [inst_2 : Algebra R A] {B : Type v‚ÇÇ}\n  [inst_3 : Semiring B] [inst_4 : Algebra R B], 1 = 1 ‚äó‚Çú[R] 1",
    "name": "Algebra.TensorProduct.one_def",
    "depth": 21}],
  "kind": "TensorProduct.¬´term_‚äó‚Çú[_]_¬ª",
  "examples":
  [{"term":
    "‚àÄ (R : Type u) (S : Type v) [inst : CommRing R] [inst_1 : CommRing S] [inst_2 : Algebra R S],\n  Submodule.span S (Set.range fun s => 1 ‚äó‚Çú[R] s - s ‚äó‚Çú[R] 1) =\n    Submodule.restrictScalars S (KaehlerDifferential.ideal R S)",
    "name": "KaehlerDifferential.submodule_span_range_eq_ideal",
    "doc":
    "The kernel of `S ‚äó[R] S ‚Üí‚Çê[R] S` is generated by `1 ‚äó s - s ‚äó 1` as a `S`-module. ",
    "depth": 27},
   {"term":
    "‚àÄ (R : Type u_1) [inst : CommSemiring R] (M : Type u_4) (N : Type u_5) [inst_1 : AddCommMonoid M]\n  [inst_2 : AddCommMonoid N] [inst_3 : Module R M] [inst_4 : Module R N],\n  Submodule.span R {t | ‚àÉ m n, m ‚äó‚Çú[R] n = t} = ‚ä§",
    "name": "TensorProduct.span_tmul_eq_top",
    "doc": "The simple (aka pure) elements span the tensor product. ",
    "depth": 29},
   {"term":
    "‚àÄ {R : Type u_1} [inst : CommSemiring R] {R' : Type u_2} [inst_1 : Monoid R'] {M : Type u_4} {N : Type u_5}\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid N] [inst_4 : Module R M] [inst_5 : Module R N]\n  [inst_6 : DistribMulAction R' M] [inst_7 : DistribMulAction R' N] [inst_8 : TensorProduct.CompatibleSMul R R' M N]\n  (r : R') (m : M) (n : N), (r ‚Ä¢ m) ‚äó‚Çú[R] n = m ‚äó‚Çú[R] (r ‚Ä¢ n)",
    "name": "TensorProduct.smul_tmul",
    "doc": "`smul` can be moved from one side of the product to the other .",
    "depth": 31},
   {"term":
    "{R : Type u} ‚Üí\n  {S : Type uS} ‚Üí\n    [inst : CommSemiring R] ‚Üí\n      [inst_1 : CommSemiring S] ‚Üí\n        [inst_2 : Algebra R S] ‚Üí\n          {A : Type v‚ÇÅ} ‚Üí\n            [inst_3 : Semiring A] ‚Üí\n              [inst_4 : Algebra R A] ‚Üí\n                [inst_5 : Algebra S A] ‚Üí\n                  [inst_6 : IsScalarTower R S A] ‚Üí\n                    {B : Type v‚ÇÇ} ‚Üí\n                      [inst_7 : Semiring B] ‚Üí\n                        [inst_8 : Algebra R B] ‚Üí\n                          {C : Type v‚ÇÉ} ‚Üí\n                            [inst_9 : Semiring C] ‚Üí\n                              [inst_10 : Algebra S C] ‚Üí\n                                (f : TensorProduct R A B ‚Üí‚Çó[S] C) ‚Üí\n                                  (‚àÄ (a‚ÇÅ a‚ÇÇ : A) (b‚ÇÅ b‚ÇÇ : B),\n                                      ‚Üëf ((a‚ÇÅ * a‚ÇÇ) ‚äó‚Çú[R] (b‚ÇÅ * b‚ÇÇ)) = ‚Üëf (a‚ÇÅ ‚äó‚Çú[R] b‚ÇÅ) * ‚Üëf (a‚ÇÇ ‚äó‚Çú[R] b‚ÇÇ)) ‚Üí\n                                    (‚àÄ (r : S), ‚Üëf (‚Üë(algebraMap S A) r ‚äó‚Çú[R] 1) = ‚Üë(algebraMap S C) r) ‚Üí\n                                      TensorProduct R A B ‚Üí‚Çê[S] C",
    "name": "Algebra.TensorProduct.algHomOfLinearMapTensorProduct",
    "doc":
    "Build an algebra morphism from a linear map out of a tensor product,\nand evidence of multiplicativity on pure tensors.\n",
    "depth": 45}],
  "count": 208},
 {"noDocExamples": [],
  "kind": "¬´term‚à´_In_.._,_¬ª",
  "examples":
  [{"term":
    "‚àÄ (n : ‚Ñï), ‚à´ (x : ‚Ñù) in 0 ..Real.pi / 2, Real.cos x ^ n = 1 / 2 * ‚à´ (x : ‚Ñù) in 0 ..Real.pi, Real.sin x ^ n",
    "name": "EulerSine.integral_cos_pow_eq",
    "doc":
    "Relate the integral `cos x ^ n` over `[0, œÄ/2]` to the integral of `sin x ^ n` over `[0, œÄ]`,\nwhich is studied in `Data.Real.Pi.Wallis` and other places. ",
    "depth": 14},
   {"term":
    "‚àÄ {a b : ‚Ñù}, ‚à´ (x : ‚Ñù) in a..b, Real.sin x * Real.cos x = (Real.cos a ^ 2 - Real.cos b ^ 2) / 2",
    "name": "integral_sin_mul_cos‚ÇÇ",
    "doc":
    "The integral of `sin x * cos x`, given in terms of cos¬≤.\nSee `integral_sin_mul_cos‚ÇÅ` above for the integral given in terms of sin¬≤. ",
    "depth": 15},
   {"term":
    "‚àÄ {a b : ‚Ñù}, ‚à´ (x : ‚Ñù) in a..b, Real.sin x * Real.cos x = (Real.sin b ^ 2 - Real.sin a ^ 2) / 2",
    "name": "integral_sin_mul_cos‚ÇÅ",
    "doc":
    "The integral of `sin x * cos x`, given in terms of sin¬≤.\nSee `integral_sin_mul_cos‚ÇÇ` below for the integral given in terms of cos¬≤. ",
    "depth": 15},
   {"term":
    "‚àÄ {f : ‚Ñù ‚Üí ‚Ñù} {a b : ‚Ñù},\n  IntervalIntegrable f MeasureTheory.volume a b ‚Üí (‚àÄ (x : ‚Ñù), 0 < f x) ‚Üí a < b ‚Üí 0 < ‚à´ (x : ‚Ñù) in a..b, f x",
    "name": "intervalIntegral.intervalIntegral_pos_of_pos",
    "doc":
    "If `f : ‚Ñù ‚Üí ‚Ñù` is strictly positive everywhere, and integrable on `(a, b]` for real numbers\n`a < b`, then its integral over `a..b` is strictly positive. (See `interval_integral_pos_of_pos_on`\nfor a version only assuming positivity of `f` on `(a, b)` rather than everywhere.) ",
    "depth": 17},
   {"term":
    "‚àÄ {f : ‚Ñù ‚Üí ‚Ñù} {a b : ‚Ñù},\n  IntervalIntegrable f MeasureTheory.volume a b ‚Üí\n    (‚àÄ (x : ‚Ñù), x ‚àà Set.Ioo a b ‚Üí 0 < f x) ‚Üí a < b ‚Üí 0 < ‚à´ (x : ‚Ñù) in a..b, f x",
    "name": "intervalIntegral.intervalIntegral_pos_of_pos_on",
    "doc":
    "If `f : ‚Ñù ‚Üí ‚Ñù` is integrable on `(a, b]` for real numbers `a < b`, and positive on the interior\nof the interval, then its integral over `a..b` is strictly positive. ",
    "depth": 17}],
  "count": 204},
 {"noDocExamples": [],
  "kind": "¬´term_‚Üí‚Çó.[_]_¬ª",
  "examples":
  [{"term":
    "{R : Type u_1} ‚Üí\n  [inst : Ring R] ‚Üí\n    {E : Type u_2} ‚Üí\n      [inst_1 : AddCommGroup E] ‚Üí\n        [inst_2 : Module R E] ‚Üí\n          {F : Type u_3} ‚Üí [inst_3 : AddCommGroup F] ‚Üí [inst_4 : Module R F] ‚Üí (E ‚Üí‚Çó.[R] F) ‚Üí F ‚Üí‚Çó.[R] E",
    "name": "LinearPMap.inverse",
    "doc": "The inverse of a `LinearPMap`. ",
    "depth": 17},
   {"term":
    "{R : Type u_1} ‚Üí\n  [inst : Ring R] ‚Üí\n    {E : Type u_2} ‚Üí\n      [inst_1 : AddCommGroup E] ‚Üí\n        [inst_2 : Module R E] ‚Üí\n          {F : Type u_3} ‚Üí [inst_3 : AddCommGroup F] ‚Üí [inst_4 : Module R F] ‚Üí (E ‚Üí‚Çó.[R] F) ‚Üí Submodule R (E √ó F)",
    "name": "LinearPMap.graph",
    "doc": "The graph of a `LinearPMap` viewed as a submodule on `E √ó F`. ",
    "depth": 18},
   {"term":
    "{R : Type u_1} ‚Üí\n  [inst : Ring R] ‚Üí\n    {E : Type u_2} ‚Üí\n      [inst_1 : AddCommGroup E] ‚Üí\n        [inst_2 : Module R E] ‚Üí\n          {F : Type u_3} ‚Üí [inst_3 : AddCommGroup F] ‚Üí [inst_4 : Module R F] ‚Üí Submodule R (E √ó F) ‚Üí E ‚Üí‚Çó.[R] F",
    "name": "Submodule.toLinearPMap",
    "doc":
    "Define a `LinearPMap` from its graph.\n\nIn the case that the submodule is not a graph of a `LinearPMap` then the underlying linear map\nis just the zero map. ",
    "depth": 18},
   {"term":
    "{R : Type u_1} ‚Üí\n  [inst : Ring R] ‚Üí\n    {E : Type u_2} ‚Üí\n      [inst_1 : AddCommGroup E] ‚Üí\n        [inst_2 : Module R E] ‚Üí\n          {F : Type u_3} ‚Üí\n            [inst_3 : AddCommGroup F] ‚Üí [inst_4 : Module R F] ‚Üí (E ‚Üí‚Çó.[R] F) ‚Üí (E ‚Üí‚Çó.[R] F) ‚Üí Submodule R E",
    "name": "LinearPMap.eqLocus",
    "doc":
    "Given two partial linear maps `f`, `g`, the set of points `x` such that\nboth `f` and `g` are defined at `x` and `f x = g x` form a submodule. ",
    "depth": 18},
   {"term":
    "{R : Type u_1} ‚Üí\n  [inst : Ring R] ‚Üí\n    {E : Type u_2} ‚Üí\n      [inst_1 : AddCommGroup E] ‚Üí\n        [inst_2 : Module R E] ‚Üí\n          {F : Type u_3} ‚Üí [inst_3 : AddCommGroup F] ‚Üí [inst_4 : Module R F] ‚Üí (E ‚Üí‚Çó.[R] F) ‚Üí Submodule R E ‚Üí E ‚Üí‚Çó.[R] F",
    "name": "LinearPMap.domRestrict",
    "doc":
    "Restrict a partially defined linear map to a submodule of `E` contained in `f.domain`. ",
    "depth": 18}],
  "count": 196},
 {"noDocExamples": [],
  "kind": "Filter.¬´term_‚â§·∂†[_]_¬ª",
  "examples":
  [{"term":
    "‚àÄ {Œ± : Type u_1} {_m0 : MeasurableSpace Œ±} ‚¶És s' : Set Œ±‚¶Ñ ‚¶ÉŒº ŒΩ : MeasureTheory.Measure Œ±‚¶Ñ,\n  s ‚â§·∂†[MeasureTheory.Measure.ae Œº] s' ‚Üí Œº ‚â§ ŒΩ ‚Üí MeasureTheory.Measure.restrict Œº s ‚â§ MeasureTheory.Measure.restrict ŒΩ s'",
    "name": "MeasureTheory.Measure.restrict_mono'",
    "doc":
    "Restriction of a measure to a subset is monotone both in set and in measure. ",
    "depth": 16},
   {"term":
    "‚àÄ {Œ± : Type u_1} {m : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {f : MeasureTheory.SimpleFunc Œ± ‚Ñù},\n  MeasureTheory.Integrable ‚Üëf ‚Üí\n    0 ‚â§·∂†[MeasureTheory.Measure.ae Œº] ‚Üëf ‚Üí\n      MeasureTheory.SimpleFunc.integral Œº f = ENNReal.toReal (‚à´‚Åª (a : Œ±), ENNReal.ofReal (‚Üëf a) ‚àÇŒº)",
    "name": "MeasureTheory.SimpleFunc.integral_eq_lintegral",
    "doc":
    "`SimpleFunc.bintegral` and `SimpleFunc.integral` agree when the integrand has type\n`Œ± ‚Üí‚Çõ ‚Ñù‚â•0‚àû`. But since `‚Ñù‚â•0‚àû` is not a `NormedSpace`, we need some form of coercion. ",
    "depth": 16},
   {"term":
    "‚àÄ {Œ± : Type u_1} [inst : MeasurableSpace Œ±] {Œº : MeasureTheory.Measure Œ±} {s t : Set Œ±},\n  s ‚â§·∂†[MeasureTheory.Measure.ae Œº] t ‚Üí ‚Üë‚ÜëŒº s ‚â§ ‚Üë‚ÜëŒº t",
    "name": "MeasureTheory.measure_mono_ae",
    "doc": "If `s ‚äÜ t` modulo a set of measure `0`, then `Œº s ‚â§ Œº t`. ",
    "depth": 16},
   {"term":
    "‚àÄ {Œ± : Type u_1} [inst : MeasurableSpace Œ±] {Œº : MeasureTheory.Measure Œ±} {s t : Set Œ±},\n  s ‚â§·∂†[MeasureTheory.Measure.ae Œº] t ‚Üí ‚Üë‚ÜëŒº s ‚â§ ‚Üë‚ÜëŒº t",
    "name": "Filter.EventuallyLE.measure_le",
    "doc":
    "**Alias** of `MeasureTheory.measure_mono_ae`.\n\n---\n\nIf `s ‚äÜ t` modulo a set of measure `0`, then `Œº s ‚â§ Œº t`. ",
    "depth": 16},
   {"term":
    "‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : LE Œ≤] {f g : Œ± ‚Üí Œ≤} {a : Œ±},\n  f ‚â§·∂†[nhds a] g ‚Üí ‚àÄ·∂† (y : Œ±) in nhds a, f ‚â§·∂†[nhds y] g",
    "name": "Filter.EventuallyLE.eventuallyLE_nhds",
    "doc":
    "If `f x ‚â§ g x` in a neighbourhood of `a`, then for `y` sufficiently close to `a` we have\n`f x ‚â§ g x` in a neighbourhood of `y`. ",
    "depth": 17}],
  "count": 192},
 {"noDocExamples": [],
  "kind": "¬´term_‚Üí‚Çó‚ÅÖ_‚ÅÜ_¬ª",
  "examples":
  [{"term":
    "{R : Type u} ‚Üí {L‚ÇÅ : Type v} ‚Üí [inst : CommRing R] ‚Üí [inst_1 : LieRing L‚ÇÅ] ‚Üí [inst_2 : LieAlgebra R L‚ÇÅ] ‚Üí L‚ÇÅ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÅ",
    "name": "LieHom.id",
    "doc": "The identity map is a morphism of Lie algebras. ",
    "depth": 13},
   {"term":
    "{R : Type u} ‚Üí\n  {L‚ÇÅ : Type v} ‚Üí [inst : CommRing R] ‚Üí [inst_1 : LieRing L‚ÇÅ] ‚Üí [inst_2 : LieAlgebra R L‚ÇÅ] ‚Üí One (L‚ÇÅ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÅ)",
    "name": "LieHom.instOneLieHom",
    "doc": "The identity map is a Lie algebra morphism. ",
    "depth": 14},
   {"term":
    "(R : Type u‚ÇÅ) ‚Üí\n  {L : Type u‚ÇÇ} ‚Üí\n    [inst : CommRing R] ‚Üí [inst_1 : LieRing L] ‚Üí [inst_2 : LieAlgebra R L] ‚Üí L ‚Üí‚Çó‚ÅÖR‚ÅÜ UniversalEnvelopingAlgebra R L",
    "name": "UniversalEnvelopingAlgebra.Œπ",
    "doc":
    "The natural Lie algebra morphism from a Lie algebra to its universal enveloping algebra. ",
    "depth": 16},
   {"term":
    "{R : Type u} ‚Üí\n  {L : Type v} ‚Üí\n    {L' : Type w‚ÇÇ} ‚Üí\n      [inst : CommRing R] ‚Üí\n        [inst_1 : LieRing L] ‚Üí\n          [inst_2 : LieAlgebra R L] ‚Üí [inst_3 : LieRing L'] ‚Üí [inst_4 : LieAlgebra R L'] ‚Üí (L ‚Üí‚Çó‚ÅÖR‚ÅÜ L') ‚Üí LieIdeal R L'",
    "name": "LieHom.idealRange",
    "doc":
    "The range of a morphism of Lie algebras as an ideal in the codomain. ",
    "depth": 17},
   {"term":
    "{R : Type u} ‚Üí\n  {L : Type v} ‚Üí\n    {L' : Type w‚ÇÇ} ‚Üí\n      [inst : CommRing R] ‚Üí\n        [inst_1 : LieRing L] ‚Üí\n          [inst_2 : LieAlgebra R L] ‚Üí [inst_3 : LieRing L'] ‚Üí [inst_4 : LieAlgebra R L'] ‚Üí (L ‚Üí‚Çó‚ÅÖR‚ÅÜ L') ‚Üí LieIdeal R L",
    "name": "LieHom.ker",
    "doc":
    "The kernel of a morphism of Lie algebras, as an ideal in the domain. ",
    "depth": 17}],
  "count": 188},
 {"noDocExamples": [],
  "kind": "Matrix.vecNotation",
  "examples":
  [{"term": "(Œ± Œ≤ : Type u) ‚Üí Œ± √ó Œ≤ ‚âÉ ((i : Fin 2) ‚Üí Matrix.vecCons Œ± ![Œ≤] i)",
    "name": "prodEquivPiFinTwo",
    "doc":
    "A product space `Œ± √ó Œ≤` is equivalent to the space `Œ† i : Fin 2, Œ≥ i`, where\n`Œ≥ = Fin.cons Œ± (Fin.cons Œ≤ finZeroElim)`. See also `piFinTwoEquiv` and\n`finTwoArrowEquiv`. ",
    "depth": 12},
   {"term":
    "‚àÄ (k : Type u_1) {V : Type u_2} {P : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {p‚ÇÅ p‚ÇÇ : P}, p‚ÇÅ ‚â† p‚ÇÇ ‚Üí AffineIndependent k ![p‚ÇÅ, p‚ÇÇ]",
    "name": "affineIndependent_of_ne",
    "doc": "Two different points are affinely independent. ",
    "depth": 19},
   {"term":
    "‚àÄ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ‚Ñù V]\n  [inst_2 : Fact (FiniteDimensional.finrank ‚Ñù V = 2)] (o : Orientation ‚Ñù V (Fin 2)) {x y : V},\n  Orientation.oangle o x y ‚â† 0 ‚àß Orientation.oangle o x y ‚â† ‚ÜëReal.pi ‚Üî LinearIndependent ‚Ñù ![x, y]",
    "name": "Orientation.oangle_ne_zero_and_ne_pi_iff_linearIndependent",
    "doc":
    "The oriented angle between two vectors is not zero or `œÄ` if and only if those two vectors\nare linearly independent. ",
    "depth": 21},
   {"term":
    "‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {p‚ÇÅ p‚ÇÇ p‚ÇÉ : P}, Collinear k {p‚ÇÅ, p‚ÇÇ, p‚ÇÉ} ‚Üî ¬¨AffineIndependent k ![p‚ÇÅ, p‚ÇÇ, p‚ÇÉ]",
    "name": "collinear_iff_not_affineIndependent_set",
    "doc":
    "Three points are collinear if and only if they are not affinely independent. ",
    "depth": 21},
   {"term":
    "‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {p‚ÇÅ p‚ÇÇ p‚ÇÉ : P}, AffineIndependent k ![p‚ÇÅ, p‚ÇÇ, p‚ÇÉ] ‚Üî ¬¨Collinear k {p‚ÇÅ, p‚ÇÇ, p‚ÇÉ}",
    "name": "affineIndependent_iff_not_collinear_set",
    "doc":
    "Three points are affinely independent if and only if they are not collinear. ",
    "depth": 21}],
  "count": 184},
 {"noDocExamples": [],
  "kind": "¬´term‚Öü_¬ª",
  "examples":
  [{"term":
    "{Œ± : Type u} ‚Üí [inst : One Œ±] ‚Üí [inst_1 : Mul Œ±] ‚Üí {a : Œ±} ‚Üí [inst_2 : Invertible a] ‚Üí Invertible ‚Öüa",
    "name": "invertibleInvOf",
    "doc": "`a` is the inverse of `‚Öüa`. ",
    "depth": 11},
   {"term":
    "‚àÄ {Œ± : Type u} [inst : MonoidWithZero Œ±] (x : Œ±) [inst_1 : Invertible x], Ring.inverse x = ‚Öüx",
    "name": "Ring.inverse_invertible",
    "doc": "A variant of `Ring.inverse_unit`. ",
    "depth": 13},
   {"term":
    "‚àÄ {Œ± : Type u} [inst : Mul Œ±] [inst_1 : One Œ±] {a : Œ±} [self : Invertible a], a * ‚Öüa = 1",
    "name": "Invertible.mul_invOf_self",
    "doc": "`invOf a` is a right inverse of `a` ",
    "depth": 13},
   {"term":
    "‚àÄ {Œ± : Type u} [inst : Mul Œ±] [inst_1 : One Œ±] {a : Œ±} [self : Invertible a], ‚Öüa * a = 1",
    "name": "Invertible.invOf_mul_self",
    "doc": "`invOf a` is a left inverse of `a` ",
    "depth": 14},
   {"term":
    "{Œ± : Type u} ‚Üí [inst : MulOneClass Œ±] ‚Üí {r : Œ±} ‚Üí (hr : Invertible r) ‚Üí (s si : Œ±) ‚Üí s = r ‚Üí si = ‚Öür ‚Üí Invertible s",
    "name": "Invertible.copy'",
    "doc":
    "If `r` is invertible and `s = r` and `si = ‚Öür`, then `s` is invertible with `‚Öüs = si`. ",
    "depth": 15}],
  "count": 181},
 {"noDocExamples": [],
  "kind": "¬´term_‚äÇ_¬ª",
  "examples":
  [{"term": "‚àÄ {Œ± : Type u} {s : Set Œ±}, Set.Nonempty s ‚Üí ‚àÖ ‚äÇ s",
    "name": "Set.Nonempty.empty_ssubset",
    "doc": "**Alias** of the reverse direction of `Set.empty_ssubset`.",
    "depth": 8},
   {"term": "‚àÄ {Œ± : Type u_1} {s : Finset Œ±}, Finset.Nonempty s ‚Üí ‚àÖ ‚äÇ s",
    "name": "Finset.Nonempty.empty_ssubset",
    "doc": "**Alias** of the reverse direction of `Finset.empty_ssubset`.",
    "depth": 8},
   {"term":
    "‚àÄ {Œ± : Type u} [inst : HasSSubset Œ±] [inst_1 : IsIrrefl Œ± fun x x_1 => x ‚äÇ x_1] {a b : Œ±}, a ‚äÇ b ‚Üí a ‚â† b",
    "name": "HasSSubset.SSubset.ne",
    "doc": "**Alias** of `ne_of_ssubset`.",
    "depth": 10},
   {"term":
    "‚àÄ {Œ± : Type u} [inst : HasSSubset Œ±] [inst_1 : IsIrrefl Œ± fun x x_1 => x ‚äÇ x_1] {a : Œ±}, ¬¨a ‚äÇ a",
    "name": "HasSSubset.SSubset.false",
    "doc": "**Alias** of `ssubset_irrfl`.",
    "depth": 10},
   {"term":
    "‚àÄ {Œ± : Type u} [inst : HasSSubset Œ±] [inst_1 : IsIrrefl Œ± fun x x_1 => x ‚äÇ x_1] {a b : Œ±}, a ‚äÇ b ‚Üí b ‚â† a",
    "name": "HasSSubset.SSubset.ne'",
    "doc": "**Alias** of `ne_of_ssuperset`.",
    "depth": 10}],
  "count": 175},
 {"noDocExamples": [],
  "kind": "Lean.Parser.Term.let",
  "examples":
  [{"term":
    "{Œ± : Type u} ‚Üí\n  {Œ≤ : Type v} ‚Üí\n    (e : Œ± ‚âÉ Œ≤) ‚Üí\n      [inst : Add Œ≤] ‚Üí\n        let mul := Equiv.add e;\n        Œ± ‚âÉ+ Œ≤",
    "name": "Equiv.addEquiv",
    "doc":
    "An equivalence `e : Œ± ‚âÉ Œ≤` gives an additive equivalence `Œ± ‚âÉ+ Œ≤` where\nthe additive structure on `Œ±` is the one obtained by transporting an additive structure\non `Œ≤` back along `e`.",
    "depth": 9},
   {"term":
    "{Œ± : Type u} ‚Üí\n  {Œ≤ : Type v} ‚Üí\n    (e : Œ± ‚âÉ Œ≤) ‚Üí\n      [inst : Mul Œ≤] ‚Üí\n        let mul := Equiv.mul e;\n        Œ± ‚âÉ* Œ≤",
    "name": "Equiv.mulEquiv",
    "doc":
    "An equivalence `e : Œ± ‚âÉ Œ≤` gives a multiplicative equivalence `Œ± ‚âÉ* Œ≤` where\nthe multiplicative structure on `Œ±` is the one obtained by transporting a multiplicative structure\non `Œ≤` back along `e`. ",
    "depth": 9},
   {"term":
    "{u : Lean.Level} ‚Üí\n  {Œ± :\n      let u := u;\n      Q(Type u)} ‚Üí\n    Q(AddMonoid ¬´$Œ±¬ª) ‚Üí List Q(¬´$Œ±¬ª) ‚Üí Q(¬´$Œ±¬ª)",
    "name": "Linarith.addExprs'",
    "doc": "A type-safe analogue of `addExprs`. ",
    "depth": 10},
   {"term":
    "{u : Lean.Level} ‚Üí\n  (Œ± :\n      let u := u;\n      Q(Type u)) ‚Üí\n    Q(Semiring ¬´$Œ±¬ª) ‚Üí ‚Ñï ‚Üí Q(¬´$Œ±¬ª)",
    "name": "Qq.ofNatQ",
    "doc": "Typesafe conversion of `n : ‚Ñï` to `Q($Œ±)`. ",
    "depth": 10},
   {"term":
    "{u : Lean.Level} ‚Üí\n  {Œ± :\n      let u := u;\n      Q(Type u)} ‚Üí\n    Q(AddMonoid ¬´$Œ±¬ª) ‚Üí Q(¬´$Œ±¬ª) ‚Üí List Q(¬´$Œ±¬ª) ‚Üí Q(¬´$Œ±¬ª)",
    "name": "Linarith.addExprs'.go",
    "doc": "Inner loop for `addExprs'`. ",
    "depth": 10}],
  "count": 175},
 {"noDocExamples": [],
  "kind": "¬´term‚àÉ!_,_¬ª",
  "examples":
  [{"term":
    "{Œ± : Type u_1} ‚Üí [inst : Fintype Œ±] ‚Üí (p : Œ± ‚Üí Prop) ‚Üí [inst : DecidablePred p] ‚Üí (‚àÉ! a, p a) ‚Üí { a // p a }",
    "name": "Fintype.chooseX",
    "doc":
    "Given a fintype `Œ±` and a predicate `p`, associate to a proof that there is a unique element of\n`Œ±` satisfying `p` this unique element, as an element of the corresponding subtype. ",
    "depth": 8},
   {"term":
    "{Œ± : Type u_1} ‚Üí [inst : Fintype Œ±] ‚Üí (p : Œ± ‚Üí Prop) ‚Üí [inst : DecidablePred p] ‚Üí (‚àÉ! a, p a) ‚Üí Œ±",
    "name": "Fintype.choose",
    "doc":
    "Given a fintype `Œ±` and a predicate `p`, associate to a proof that there is a unique element of\n`Œ±` satisfying `p` this unique element, as an element of `Œ±`. ",
    "depth": 8},
   {"term":
    "‚àÄ {Œ± : Type u_1} (r : Setoid Œ±), Setoid.mkClasses (Setoid.classes r) (_ : ‚àÄ (a : Œ±), ‚àÉ! b x, a ‚àà b) = r",
    "name": "Setoid.mkClasses_classes",
    "doc":
    "The equivalence relation made from the equivalence classes of an equivalence\nrelation r equals r. ",
    "depth": 8},
   {"term": "‚àÄ {n : ‚Ñï}, IsPrimePow n ‚Üî ‚àÉ! p, Nat.Prime p ‚àß p ‚à£ n",
    "name": "isPrimePow_iff_unique_prime_dvd",
    "doc":
    "An equivalent definition for prime powers: `n` is a prime power iff there is a unique prime\ndividing it. ",
    "depth": 9},
   {"term":
    "‚àÄ {R : Type u} [inst : CommSemiring R], (‚àÉ! I, Ideal.IsMaximal I) ‚Üí LocalRing R",
    "name": "LocalRing.of_unique_max_ideal",
    "doc": "A semiring is local if it has a unique maximal ideal. ",
    "depth": 9}],
  "count": 171},
 {"noDocExamples": [],
  "kind": "¬´term‚Ñ§‚àö_¬ª",
  "examples":
  [{"term": "{d : ‚Ñ§} ‚Üí ‚Ñ§‚àöd",
    "name": "Zsqrtd.sqrtd",
    "doc": "The representative of `‚àöd` in the ring ",
    "depth": 2},
   {"term": "{d : ‚Ñ§} ‚Üí ‚Ñ§‚àöd ‚Üí Prop",
    "name": "Pell.IsPell",
    "doc":
    "The property of being a solution to the Pell equation, expressed\nas a property of elements of `‚Ñ§‚àöd`. ",
    "depth": 3},
   {"term": "{d : ‚Ñ§} ‚Üí One (‚Ñ§‚àöd)",
    "name": "Zsqrtd.instOneZsqrtd",
    "doc": "The one of the ring ",
    "depth": 3},
   {"term": "{d : ‚Ñ§} ‚Üí Neg (‚Ñ§‚àöd)",
    "name": "Zsqrtd.instNegZsqrtd",
    "doc": "Negation in `‚Ñ§‚àöd` ",
    "depth": 3},
   {"term": "{d : ‚Ñ§} ‚Üí Star (‚Ñ§‚àöd)",
    "name": "Zsqrtd.instStarZsqrtd",
    "doc": "Conjugation in `‚Ñ§‚àöd`. The conjugate of `a + b ‚àöd` is `a - b ‚àöd`. ",
    "depth": 3}],
  "count": 170},
 {"noDocExamples": [],
  "kind": "Complex.termCexp",
  "examples":
  [{"term": "‚àÄ {s : Set ‚ÑÇ}, Set.Countable s ‚Üí Set.Countable (cexp ‚Åª¬π' s)",
    "name": "Set.Countable.preimage_cexp",
    "doc":
    "**Alias** of the reverse direction of `Complex.countable_preimage_exp`.",
    "depth": 7},
   {"term":
    "Filter.Tendsto cexp (Filter.comap Complex.re Filter.atBot) (nhds 0)",
    "name": "Complex.tendsto_exp_comap_re_atBot",
    "doc": "`Complex.exp z ‚Üí 0` as `Complex.re z ‚Üí -‚àû`.",
    "depth": 10},
   {"term": "‚àÄ (x : ‚ÑÇ), HasDerivAt cexp (cexp x) x",
    "name": "Complex.hasDerivAt_exp",
    "doc":
    "The complex exponential is everywhere differentiable, with the derivative `exp x`. ",
    "depth": 10},
   {"term":
    "‚àÄ {l : Filter ‚ÑÇ}, Complex.IsExpCmpFilter l ‚Üí ‚àÄ (a : ‚ÑÇ) {b : ‚Ñù}, 0 < b ‚Üí (fun z => z ^ a) =o[l] fun z => cexp (‚Üëb * z)",
    "name": "Complex.IsExpCmpFilter.isLittleO_cpow_exp",
    "doc":
    "If `l : Filter ‚ÑÇ` is an \"exponential comparison filter\", then for any complex `a` and any\npositive real `b`, we have `(fun z ‚Ü¶ z ^ a) =o[l] (fun z ‚Ü¶ exp (b * z))`. ",
    "depth": 14},
   {"term":
    "‚àÄ {l : Filter ‚ÑÇ}, Complex.IsExpCmpFilter l ‚Üí ‚àÄ (a : ‚ÑÇ) {b : ‚Ñù}, b < 0 ‚Üí (fun z => cexp (‚Üëb * z)) =o[l] fun z => z ^ a",
    "name": "Complex.IsExpCmpFilter.isLittleO_exp_cpow",
    "doc":
    "If `l : Filter ‚ÑÇ` is an \"exponential comparison filter\", then for any complex `a` and any\nnegative real `b`, we have `(fun z ‚Ü¶ exp (b * z)) =o[l] (fun z ‚Ü¶ z ^ a)`. ",
    "depth": 15}],
  "count": 166},
 {"noDocExamples": [],
  "kind": "Set.¬´term‚ãÉ‚ÇÄ_¬ª",
  "examples":
  [{"term":
    "‚àÄ {Œ± : Type u} [t : TopologicalSpace Œ±] {s : Set (Set Œ±)}, TopologicalSpace.IsTopologicalBasis s ‚Üí ‚ãÉ‚ÇÄ s = Set.univ",
    "name": "TopologicalSpace.IsTopologicalBasis.sUnion_eq",
    "doc": "The sets from `s` cover the whole space. ",
    "depth": 8},
   {"term": "‚àÄ {Œ± : Type u_1} {S T : Set (Set Œ±)}, S ‚äÜ T ‚Üí ‚ãÉ‚ÇÄ S ‚äÜ ‚ãÉ‚ÇÄ T",
    "name": "Set.sUnion_mono",
    "doc": "**Alias** of `Set.sUnion_subset_sUnion`.",
    "depth": 10},
   {"term":
    "‚àÄ {Œ± : Type u_1} {S : Set (Set Œ±)}, S ‚äÜ {‚àÖ, Set.univ} ‚Üí ‚ãÉ‚ÇÄ S ‚àà {‚àÖ, Set.univ}",
    "name": "Set.sUnion_mem_empty_univ",
    "doc":
    "If all sets in a collection are either `‚àÖ` or `Set.univ`, then so is their union. ",
    "depth": 10},
   {"term":
    "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : UniformSpace Œ≤] {ùîñ : Set (Set Œ±)} [inst_1 : T2Space Œ≤],\n  ‚ãÉ‚ÇÄ ùîñ = Set.univ ‚Üí T2Space (UniformOnFun Œ± Œ≤ ùîñ)",
    "name": "UniformOnFun.t2Space_of_covering",
    "doc": "If `ùîñ` covers `Œ±`, then the topology of `ùîñ`-convergence is T‚ÇÇ. ",
    "depth": 11},
   {"term":
    "‚àÄ {Œ± : Type u} {s : Set (Set Œ±)}, Set.Countable s ‚Üí (‚àÄ (a : Set Œ±), a ‚àà s ‚Üí Set.Countable a) ‚Üí Set.Countable (‚ãÉ‚ÇÄ s)",
    "name": "Set.Countable.sUnion",
    "doc": "**Alias** of the reverse direction of `Set.Countable.sUnion_iff`.",
    "depth": 12}],
  "count": 159},
 {"noDocExamples":
  [{"term": "RingHom.StableUnderComposition @RingHom.Finite",
    "name": "RingHom.finite_stableUnderComposition",
    "depth": 1},
   {"term": "RingHom.StableUnderBaseChange @RingHom.Finite",
    "name": "RingHom.finite_stableUnderBaseChange",
    "depth": 1}],
  "kind": "Lean.Parser.Term.explicit",
  "examples":
  [{"term": "RingHom.LocalizationPreserves @RingHom.Finite",
    "name": "localization_finite",
    "doc":
    "If `S` is a finite `R`-algebra, then `S' = M‚Åª¬πS` is a finite `R' = M‚Åª¬πR`-algebra. ",
    "depth": 1},
   {"term": "CategoryTheory.UnbundledHom @UniformContinuous",
    "name": "UniformSpaceCat.instUnbundledHomTypeUniformSpaceUniformContinuous",
    "doc": "The information required to build morphisms for `UniformSpace`. ",
    "depth": 4},
   {"term":
    "‚àÄ {Œ± : Type u_1} {Œ≥ : Type u_3}, Monotone (@UniformFun.uniformSpace Œ± Œ≥)",
    "name": "UniformFun.mono",
    "doc":
    "If `u‚ÇÅ` and `u‚ÇÇ` are two uniform structures on `Œ≥` and `u‚ÇÅ ‚â§ u‚ÇÇ`, then\n`ùí∞(Œ±, Œ≥, u‚ÇÅ) ‚â§ ùí∞(Œ±, Œ≥, u‚ÇÇ)`. ",
    "depth": 9}],
  "count": 155},
 {"noDocExamples":
  [{"term":
    "‚àÄ {Œ± : Type u_2} [inst : Sup Œ±] [inst_1 : SDiff Œ±] (a b : Œ±), a ‚àÜ b = a \\ b ‚äî b \\ a",
    "name": "symmDiff_def",
    "depth": 12}],
  "kind": "¬´term_‚àÜ_¬ª",
  "examples":
  [{"term":
    "‚àÄ {Œ± : Type u_1} [inst : MeasurableSpace Œ±] {s : MeasureTheory.SignedMeasure Œ±} {u v : Set Œ±},\n  MeasurableSet u ‚Üí\n    MeasurableSet v ‚Üí\n      MeasureTheory.VectorMeasure.restrict 0 u ‚â§ MeasureTheory.VectorMeasure.restrict s u ‚Üí\n        MeasureTheory.VectorMeasure.restrict 0 v ‚â§ MeasureTheory.VectorMeasure.restrict s v ‚Üí\n          ‚Üës (u ‚àÜ v) = 0 ‚Üí ‚Üës (u \\ v) = 0 ‚àß ‚Üës (v \\ u) = 0",
    "name":
    "MeasureTheory.SignedMeasure.of_diff_eq_zero_of_symmDiff_eq_zero_positive",
    "doc":
    "If the symmetric difference of two positive sets is a null-set, then so are the differences\nbetween the two sets. ",
    "depth": 25},
   {"term":
    "‚àÄ {Œ± : Type u_1} [inst : MeasurableSpace Œ±] {s : MeasureTheory.SignedMeasure Œ±} {u v : Set Œ±},\n  MeasurableSet u ‚Üí\n    MeasurableSet v ‚Üí\n      MeasureTheory.VectorMeasure.restrict s u ‚â§ MeasureTheory.VectorMeasure.restrict 0 u ‚Üí\n        MeasureTheory.VectorMeasure.restrict s v ‚â§ MeasureTheory.VectorMeasure.restrict 0 v ‚Üí\n          ‚Üës (u ‚àÜ v) = 0 ‚Üí ‚Üës (u \\ v) = 0 ‚àß ‚Üës (v \\ u) = 0",
    "name":
    "MeasureTheory.SignedMeasure.of_diff_eq_zero_of_symmDiff_eq_zero_negative",
    "doc":
    "If the symmetric difference of two negative sets is a null-set, then so are the differences\nbetween the two sets. ",
    "depth": 25},
   {"term":
    "‚àÄ {Œ± : Type u_1} [inst : MeasurableSpace Œ±] {s : MeasureTheory.SignedMeasure Œ±} {i j : Set Œ±},\n  MeasurableSet i ‚Üí\n    MeasurableSet j ‚Üí\n      MeasureTheory.VectorMeasure.restrict 0 i ‚â§ MeasureTheory.VectorMeasure.restrict s i ‚àß\n          MeasureTheory.VectorMeasure.restrict s i·∂ú ‚â§ MeasureTheory.VectorMeasure.restrict 0 i·∂ú ‚Üí\n        MeasureTheory.VectorMeasure.restrict 0 j ‚â§ MeasureTheory.VectorMeasure.restrict s j ‚àß\n            MeasureTheory.VectorMeasure.restrict s j·∂ú ‚â§ MeasureTheory.VectorMeasure.restrict 0 j·∂ú ‚Üí\n          ‚Üës (i ‚àÜ j) = 0 ‚àß ‚Üës (i·∂ú ‚àÜ j·∂ú) = 0",
    "name": "MeasureTheory.SignedMeasure.of_symmDiff_compl_positive_negative",
    "doc":
    "The symmetric difference of two Hahn decompositions has measure zero. ",
    "depth": 26},
   {"term":
    "‚àÄ {F : Type u_1} {Œ± : Type u_3} {Œ≤ : Type u_4} [inst : BooleanAlgebra Œ±] [inst_1 : BooleanAlgebra Œ≤]\n  [inst_2 : BoundedLatticeHomClass F Œ± Œ≤] (f : F) (a b : Œ±), ‚Üëf (a ‚àÜ b) = ‚Üëf a ‚àÜ ‚Üëf b",
    "name": "map_symmDiff'",
    "doc": "Special case of `map_symmDiff` for boolean algebras. ",
    "depth": 31}],
  "count": 152},
 {"noDocExamples": [],
  "kind": "¬´term_‚ãñ_¬ª",
  "examples":
  [{"term": "‚àÄ {a b : ‚Ñï}, a ‚ãñ b ‚Üí ‚Üëa ‚ãñ ‚Üëb",
    "name": "Covby.cast_int",
    "doc": "**Alias** of the reverse direction of `Nat.cast_int_covby_iff`.",
    "depth": 8},
   {"term": "‚àÄ {n : ‚Ñï} {a b : Fin n}, a ‚ãñ b ‚Üí ‚Üëa ‚ãñ ‚Üëb",
    "name": "Covby.coe_fin",
    "doc": "**Alias** of the reverse direction of `Fin.coe_covby_iff`.",
    "depth": 9},
   {"term":
    "‚àÄ {Œ± : Type u_1} [inst : LT Œ±] {a b : Œ±} [inst_1 : DenselyOrdered Œ±], ¬¨a ‚ãñ b",
    "name": "not_covby",
    "doc": "In a dense order, nothing covers anything. ",
    "depth": 10},
   {"term":
    "‚àÄ {Œ± : Type u_1} [inst : PartialOrder Œ±] [inst_1 : OrderTop Œ±] {a : Œ±}, IsCoatom a ‚Üí a ‚ãñ ‚ä§",
    "name": "IsCoatom.covby_top",
    "doc": "**Alias** of the reverse direction of `covby_top_iff`.",
    "depth": 12},
   {"term":
    "‚àÄ {Œ± : Type u_1} [inst : PartialOrder Œ±] {a b : Œ±}, a ‚©ø b ‚Üí a = b ‚à® a ‚ãñ b",
    "name": "Wcovby.eq_or_covby",
    "doc": "**Alias** of the forward direction of `wcovby_iff_eq_or_covby`.",
    "depth": 12}],
  "count": 152},
 {"noDocExamples": [],
  "kind": "¬´term‚àë·∂†_,_¬ª",
  "examples":
  [{"term":
    "‚àÄ (G : Type u) [inst : Group G] [inst_1 : Finite G],\n  ‚àë·∂† (x : ConjClasses G), Set.ncard (ConjClasses.carrier x) = Nat.card G",
    "name": "Group.sum_card_conj_classes_eq_card",
    "doc":
    "Conjugacy classes form a partition of G, stated in terms of cardinality. ",
    "depth": 13},
   {"term":
    "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {M : Type u_5} [inst : AddCommMonoid M] {g : Œ≤ ‚Üí M} (e : Œ± ‚Üí Œ≤),\n  Function.Bijective e ‚Üí ‚àë·∂† (i : Œ±), g (e i) = ‚àë·∂† (j : Œ≤), g j",
    "name": "finsum_comp",
    "doc":
    "See also `finsum_eq_of_bijective`, `Fintype.sum_bijective` and `Finset.sum_bij`.",
    "depth": 13},
   {"term":
    "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {M : Type u_5} [inst : AddCommMonoid M] {f : Œ± ‚Üí M} {g : Œ≤ ‚Üí M} (e : Œ± ‚Üí Œ≤),\n  Function.Bijective e ‚Üí (‚àÄ (x : Œ±), f x = g (e x)) ‚Üí ‚àë·∂† (i : Œ±), f i = ‚àë·∂† (j : Œ≤), g j",
    "name": "finsum_eq_of_bijective",
    "doc": "See `finsum_comp`, `Fintype.sum_bijective` and `Finset.sum_bij`.",
    "depth": 15},
   {"term":
    "‚àÄ {Œ± : Type u_1} {M : Type u_5} [inst : AddCommMonoid M] (s : Set Œ±), ‚àë·∂† (i : Œ±) (_ : i ‚àà s), 0 = 0",
    "name": "finsum_mem_zero",
    "doc": "The product of the constant function `0` over any set equals `0`.",
    "depth": 16},
   {"term":
    "‚àÄ {Œ± : Type u_1} {M : Type u_5} [inst : AddCommMonoid M] {f : Œ± ‚Üí M}, ‚àë·∂† (i : Œ±) (_ : i ‚àà ‚àÖ), f i = 0",
    "name": "finsum_mem_empty",
    "doc": "The sum of any function over an empty set is `0`.",
    "depth": 16}],
  "count": 150},
 {"noDocExamples": [],
  "kind": "¬´term_‚âÉL[_]_¬ª",
  "examples":
  [{"term": "‚ÑÇ ‚âÉL[‚Ñù] ‚ÑÇ",
    "name": "Complex.conjCle",
    "doc":
    "Continuous linear equiv version of the conj function, from `‚ÑÇ` to `‚ÑÇ`. ",
    "depth": 16},
   {"term": "‚ÑÇ ‚âÉL[‚Ñù] ‚Ñù √ó ‚Ñù",
    "name": "Complex.equivRealProdClm",
    "doc": "The natural `ContinuousLinearEquiv` from `‚ÑÇ` to `‚Ñù √ó ‚Ñù`. ",
    "depth": 16},
   {"term": "{K : Type u_1} ‚Üí [inst : IsROrC K] ‚Üí K ‚âÉL[‚Ñù] K",
    "name": "IsROrC.conjCle",
    "doc": "Conjugate as a continuous linear equivalence ",
    "depth": 18},
   {"term":
    "(R : Type u_1) ‚Üí [inst : Ring R] ‚Üí [inst_1 : TopologicalSpace R] ‚Üí [inst_2 : ContinuousMul R] ‚Üí RÀ£ ‚âÉ R ‚âÉL[R] R",
    "name": "ContinuousLinearEquiv.unitsEquivAut",
    "doc":
    "Continuous linear equivalences `R ‚âÉL[R] R` are enumerated by `RÀ£`. ",
    "depth": 21},
   {"term":
    "{R‚ÇÅ : Type u_1} ‚Üí\n  [inst : Semiring R‚ÇÅ] ‚Üí\n    {M‚ÇÅ : Type u_4} ‚Üí\n      [inst_1 : TopologicalSpace M‚ÇÅ] ‚Üí\n        [inst_2 : AddCommMonoid M‚ÇÅ] ‚Üí [inst_3 : Module R‚ÇÅ M‚ÇÅ] ‚Üí ULift.{u_10, u_4} M‚ÇÅ ‚âÉL[R‚ÇÅ] M‚ÇÅ",
    "name": "ContinuousLinearEquiv.ulift",
    "doc":
    "The continuous linear equivalence between `ULift M‚ÇÅ` and `M‚ÇÅ`.\n\nThis is a continuous version of `ULift.moduleEquiv`. ",
    "depth": 22}],
  "count": 150},
 {"noDocExamples": [],
  "kind": "¬´term_‚á®_¬ª",
  "examples":
  [{"term": "‚àÄ {Œ± : Type u_4} [self : HeytingAlgebra Œ±] (a : Œ±), a ‚á® ‚ä• = a·∂ú",
    "name": "HeytingAlgebra.himp_bot",
    "doc": "`a ‚á®` is right adjoint to `a ‚äì` ",
    "depth": 11},
   {"term":
    "‚àÄ {Œ± : Type u} [self : BooleanAlgebra Œ±] (x y : Œ±), x ‚á® y = y ‚äî x·∂ú",
    "name": "BooleanAlgebra.himp_eq",
    "doc": "`x ‚á® y` is equal to `y ‚äî x·∂ú` ",
    "depth": 13},
   {"term":
    "‚àÄ {Œ± : Type u_2} [inst : GeneralizedHeytingAlgebra Œ±] {a b : Œ±}, a ‚á® b = ‚ä§ ‚Üî a ‚â§ b",
    "name": "himp_eq_top_iff",
    "doc":
    "The **deduction theorem** in the Heyting algebra model of intuitionistic logic:\nan implication holds iff the conclusion follows from the hypothesis. ",
    "depth": 14},
   {"term":
    "‚àÄ {Œ± : Type u} [self : CompleteAtomicBooleanAlgebra Œ±] (x y : Œ±), x ‚á® y = y ‚äî x·∂ú",
    "name": "CompleteAtomicBooleanAlgebra.himp_eq",
    "doc": "`x ‚á® y` is equal to `y ‚äî x·∂ú` ",
    "depth": 14},
   {"term":
    "‚àÄ {Œ± : Type u_2} [inst : GeneralizedHeytingAlgebra Œ±] {a b c : Œ±}, Codisjoint a c ‚Üí b ‚â§ a ‚Üí c ‚á® b ‚â§ a",
    "name": "Codisjoint.himp_le_of_right_le",
    "doc": "See `himp_le` for a stronger version in Boolean algebras. ",
    "depth": 16}],
  "count": 148},
 {"noDocExamples": [],
  "kind": "¬´term_‚ÜíSL[_]_¬ª",
  "examples":
  [{"term":
    "{R : Type u_1} ‚Üí\n  {R‚ÇÇ : Type u_2} ‚Üí\n    {E : Type u_5} ‚Üí\n      {E‚ÇÇ : Type u_6} ‚Üí\n        [inst : Semiring R] ‚Üí\n          [inst_1 : Semiring R‚ÇÇ] ‚Üí\n            {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} ‚Üí\n              [inst_2 : SeminormedAddCommGroup E] ‚Üí\n                [inst_3 : SeminormedAddCommGroup E‚ÇÇ] ‚Üí\n                  [inst_4 : Module R E] ‚Üí [inst_5 : Module R‚ÇÇ E‚ÇÇ] ‚Üí (E ‚Üí‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ) ‚Üí E ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ",
    "name": "LinearIsometry.toContinuousLinearMap",
    "doc": "Interpret a linear isometry as a continuous linear map. ",
    "depth": 25},
   {"term":
    "{R‚ÇÅ : Type u_1} ‚Üí\n  {R‚ÇÇ : Type u_2} ‚Üí\n    [inst : Semiring R‚ÇÅ] ‚Üí\n      [inst_1 : Semiring R‚ÇÇ] ‚Üí\n        {œÉ‚ÇÅ‚ÇÇ : R‚ÇÅ ‚Üí+* R‚ÇÇ} ‚Üí\n          {M‚ÇÅ : Type u_4} ‚Üí\n            [inst_2 : TopologicalSpace M‚ÇÅ] ‚Üí\n              [inst_3 : AddCommMonoid M‚ÇÅ] ‚Üí\n                {M‚ÇÇ : Type u_6} ‚Üí\n                  [inst_4 : TopologicalSpace M‚ÇÇ] ‚Üí\n                    [inst_5 : AddCommMonoid M‚ÇÇ] ‚Üí\n                      [inst_6 : Module R‚ÇÅ M‚ÇÅ] ‚Üí [inst_7 : Module R‚ÇÇ M‚ÇÇ] ‚Üí (M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) ‚Üí M‚ÇÅ ‚Üí M‚ÇÇ",
    "name": "ContinuousLinearMap.Simps.apply",
    "doc":
    "See Note [custom simps projection]. We need to specify this projection explicitly in this case,\nbecause it is a composition of multiple projections. ",
    "depth": 27},
   {"term":
    "{R‚ÇÅ : Type u_1} ‚Üí\n  {R‚ÇÇ : Type u_2} ‚Üí\n    [inst : Semiring R‚ÇÅ] ‚Üí\n      [inst_1 : Semiring R‚ÇÇ] ‚Üí\n        {œÉ‚ÇÅ‚ÇÇ : R‚ÇÅ ‚Üí+* R‚ÇÇ} ‚Üí\n          {M‚ÇÅ : Type u_4} ‚Üí\n            [inst_2 : TopologicalSpace M‚ÇÅ] ‚Üí\n              [inst_3 : AddCommMonoid M‚ÇÅ] ‚Üí\n                {M‚ÇÇ : Type u_6} ‚Üí\n                  [inst_4 : TopologicalSpace M‚ÇÇ] ‚Üí\n                    [inst_5 : AddCommMonoid M‚ÇÇ] ‚Üí\n                      [inst_6 : Module R‚ÇÅ M‚ÇÅ] ‚Üí [inst_7 : Module R‚ÇÇ M‚ÇÇ] ‚Üí (M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) ‚Üí M‚ÇÅ ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ",
    "name": "ContinuousLinearMap.Simps.coe",
    "doc": "See Note [custom simps projection]. ",
    "depth": 27},
   {"term":
    "{R‚ÇÅ : Type u_1} ‚Üí\n  {R‚ÇÇ : Type u_2} ‚Üí\n    [inst : Semiring R‚ÇÅ] ‚Üí\n      [inst_1 : Semiring R‚ÇÇ] ‚Üí\n        {œÉ‚ÇÅ‚ÇÇ : R‚ÇÅ ‚Üí+* R‚ÇÇ} ‚Üí\n          {M‚ÇÅ : Type u_4} ‚Üí\n            [inst_2 : TopologicalSpace M‚ÇÅ] ‚Üí\n              [inst_3 : AddCommMonoid M‚ÇÅ] ‚Üí\n                {M‚ÇÇ : Type u_6} ‚Üí\n                  [inst_4 : TopologicalSpace M‚ÇÇ] ‚Üí\n                    [inst_5 : AddCommMonoid M‚ÇÇ] ‚Üí\n                      [inst_6 : Module R‚ÇÅ M‚ÇÅ] ‚Üí [inst_7 : Module R‚ÇÇ M‚ÇÇ] ‚Üí Zero (M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ)",
    "name": "ContinuousLinearMap.zero",
    "doc": "The continuous map that is constantly zero. ",
    "depth": 27},
   {"term":
    "{R‚ÇÅ : Type u_1} ‚Üí\n  {R‚ÇÇ : Type u_2} ‚Üí\n    [inst : Semiring R‚ÇÅ] ‚Üí\n      [inst_1 : Semiring R‚ÇÇ] ‚Üí\n        {œÉ‚ÇÅ‚ÇÇ : R‚ÇÅ ‚Üí+* R‚ÇÇ} ‚Üí\n          {M‚ÇÅ : Type u_4} ‚Üí\n            [inst_2 : TopologicalSpace M‚ÇÅ] ‚Üí\n              [inst_3 : AddCommMonoid M‚ÇÅ] ‚Üí\n                {M‚ÇÇ : Type u_6} ‚Üí\n                  [inst_4 : TopologicalSpace M‚ÇÇ] ‚Üí\n                    [inst_5 : AddCommMonoid M‚ÇÇ] ‚Üí\n                      [inst_6 : Module R‚ÇÅ M‚ÇÅ] ‚Üí [inst_7 : Module R‚ÇÇ M‚ÇÇ] ‚Üí Coe (M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (M‚ÇÅ ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ)",
    "name": "ContinuousLinearMap.LinearMap.coe",
    "doc": "Coerce continuous linear maps to linear maps. ",
    "depth": 28}],
  "count": 147},
 {"noDocExamples":
  [{"term": "‚àÄ (n : ‚Ñï), Multiset.range (Nat.succ n) = n ::‚Çò Multiset.range n",
    "name": "Multiset.range_succ",
    "depth": 5},
   {"term": "Multiset.Nodup (True ::‚Çò {False})",
    "name": "Prop.fintype.proof_1",
    "depth": 6}],
  "kind": "Multiset.¬´term_::‚Çò_¬ª",
  "examples":
  [{"term":
    "{Œ± : Type u_1} ‚Üí\n  [inst : DecidableEq Œ±] ‚Üí\n    {Œ¥ : Œ± ‚Üí Sort v} ‚Üí (m : Multiset Œ±) ‚Üí (a : Œ±) ‚Üí Œ¥ a ‚Üí ((a : Œ±) ‚Üí a ‚àà m ‚Üí Œ¥ a) ‚Üí (a' : Œ±) ‚Üí a' ‚àà a ::‚Çò m ‚Üí Œ¥ a'",
    "name": "Multiset.Pi.cons",
    "doc":
    "Given `Œ¥ : Œ± ‚Üí Type*`, a multiset `m` and a term `a`, as well as a term `b : Œ¥ a` and a\nfunction `f` such that `f a' : Œ¥ a'` for all `a'` in `m`, `Pi.cons m a b f` is a function `g` such\nthat `g a'' : Œ¥ a''` for all `a''` in `a ::‚Çò m`. ",
    "depth": 14},
   {"term":
    "{Œ± : Type u_1} ‚Üí\n  {C : Multiset Œ± ‚Üí Sort u_4} ‚Üí\n    C 0 ‚Üí\n      (C_cons : (a : Œ±) ‚Üí (m : Multiset Œ±) ‚Üí C m ‚Üí C (a ::‚Çò m)) ‚Üí\n        (‚àÄ (a a' : Œ±) (m : Multiset Œ±) (b : C m),\n            HEq (C_cons a (a' ::‚Çò m) (C_cons a' m b)) (C_cons a' (a ::‚Çò m) (C_cons a m b))) ‚Üí\n          (m : Multiset Œ±) ‚Üí C m",
    "name": "Multiset.rec",
    "doc":
    "Dependent recursor on multisets.\nTODO: should be @[recursor 6], but then the definition of `Multiset.pi` fails with a stack\noverflow in `whnf`.\n",
    "depth": 18},
   {"term":
    "‚àÄ {A : Type u_2} [inst : CommRing A] [inst_1 : IsDomain A] [inst_2 : IsDedekindDomain A],\n  ¬¨IsField A ‚Üí\n    ‚àÄ {I M : Ideal A},\n      I ‚â† ‚ä• ‚Üí\n        I ‚â§ M ‚Üí\n          ‚àÄ [hM : Ideal.IsMaximal M],\n            ‚àÉ Z,\n              Multiset.prod (M ::‚Çò Multiset.map PrimeSpectrum.asIdeal Z) ‚â§ I ‚àß\n                ¬¨Multiset.prod (Multiset.map PrimeSpectrum.asIdeal Z) ‚â§ I",
    "name": "exists_multiset_prod_cons_le_and_prod_not_le",
    "doc":
    "Specialization of `exists_primeSpectrum_prod_le_and_ne_bot_of_domain` to Dedekind domains:\nLet `I : Ideal A` be a nonzero ideal, where `A` is a Dedekind domain that is not a field.\nThen `exists_primeSpectrum_prod_le_and_ne_bot_of_domain` states we can find a product of prime\nideals that is contained within `I`. This lemma extends that result by making the product minimal:\nlet `M` be a maximal ideal that contains `I`, then the product including `M` is contained within `I`\nand the product excluding `M` is not contained within `I`. ",
    "depth": 29}],
  "count": 145},
 {"noDocExamples": [],
  "kind": "¬´term_‚Üí‚Çô+*_¬ª",
  "examples":
  [{"term": "(Œ± : Type u_5) ‚Üí [inst : NonUnitalNonAssocSemiring Œ±] ‚Üí Œ± ‚Üí‚Çô+* Œ±",
    "name": "NonUnitalRingHom.id",
    "doc":
    "The identity non-unital ring homomorphism from a non-unital semiring to itself. ",
    "depth": 6},
   {"term":
    "(Œ± : Type u_1) ‚Üí (Œ≤ : Type u_2) ‚Üí [inst : NonUnitalNonAssocSemiring Œ≤] ‚Üí Œ≤ ‚Üí‚Çô+* Œ± ‚Üí Œ≤",
    "name": "Pi.constNonUnitalRingHom",
    "doc": "`Function.const` as a `NonUnitalRingHom`. ",
    "depth": 7},
   {"term":
    "{R : Type u} ‚Üí\n  {S : Type v} ‚Üí [inst : NonUnitalNonAssocRing R] ‚Üí [inst_1 : NonUnitalNonAssocRing S] ‚Üí (R ‚Üí‚Çô+* S) ‚Üí NonUnitalSubring S",
    "name": "NonUnitalRingHom.range",
    "doc":
    "The range of a ring homomorphism, as a `NonUnitalSubring` of the target.\nSee Note [range copy pattern]. ",
    "depth": 9},
   {"term":
    "{Œ± : Type u_5} ‚Üí {Œ≤ : Type u_6} ‚Üí [inst : NonAssocSemiring Œ±] ‚Üí [inst_1 : NonAssocSemiring Œ≤] ‚Üí (Œ± ‚Üí+* Œ≤) ‚Üí Œ± ‚Üí‚Çô+* Œ≤",
    "name": "RingHom.toNonUnitalRingHom",
    "doc":
    "Reinterpret a ring homomorphism `f : Œ± ‚Üí+* Œ≤` as a non-unital ring homomorphism `Œ± ‚Üí‚Çô+* Œ≤`. The\n`simp`-normal form is `(f : Œ± ‚Üí‚Çô+* Œ≤)`. ",
    "depth": 9},
   {"term":
    "{Œ± : Type u_5} ‚Üí\n  {Œ≤ : Type u_6} ‚Üí [inst : NonUnitalNonAssocSemiring Œ±] ‚Üí [inst_1 : NonUnitalNonAssocSemiring Œ≤] ‚Üí (Œ± ‚Üí‚Çô+* Œ≤) ‚Üí Œ± ‚Üí‚Çô* Œ≤",
    "name": "NonUnitalRingHom.toMulHom",
    "doc":
    "Reinterpret a non-unital ring homomorphism `f : Œ± ‚Üí‚Çô+* Œ≤` as a semigroup\nhomomorphism `Œ± ‚Üí‚Çô* Œ≤`. The `simp`-normal form is `(f : Œ± ‚Üí‚Çô* Œ≤)`. ",
    "depth": 9}],
  "count": 143},
 {"noDocExamples": [],
  "kind": "Filter.¬´term‚àÉ·∂†_In_,_¬ª",
  "examples":
  [{"term":
    "‚àÄ {Œ± : Type u} {f : Ultrafilter Œ±} {p : Œ± ‚Üí Prop}, (‚àÉ·∂† (x : Œ±) in ‚Üëf, p x) ‚Üí ‚àÄ·∂† (x : Œ±) in ‚Üëf, p x",
    "name": "Filter.Frequently.eventually",
    "doc":
    "**Alias** of the forward direction of `Ultrafilter.frequently_iff_eventually`.",
    "depth": 8},
   {"term":
    "‚àÄ {n : ‚Ñï}, n ‚â† 0 ‚Üí ‚àÄ (d : ‚Ñï), ‚àÉ·∂† (m : ‚Ñï) in Filter.atTop, m ‚â° d [MOD n]",
    "name": "Nat.frequently_modEq",
    "doc": "Infinitely many natural numbers are equal to `d` mod `n`. ",
    "depth": 9},
   {"term":
    "‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±} {a : Œ±}, (‚àÉ·∂† (x : Œ±) in nhds a, x ‚àà s) ‚Üí a ‚àà closure s",
    "name": "Filter.Frequently.mem_closure",
    "doc":
    "**Alias** of the reverse direction of `mem_closure_iff_frequently`.",
    "depth": 13},
   {"term":
    "‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] (x : Œ±) (C : Set Œ±),\n  AccPt x (Filter.principal C) ‚Üî ‚àÉ·∂† (y : Œ±) in nhds x, y ‚â† x ‚àß y ‚àà C",
    "name": "accPt_iff_frequently",
    "doc":
    "`x` is an accumulation point of a set `C` iff\nthere are points near `x` in `C` and different from `x`.",
    "depth": 14},
   {"term":
    "‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±}, IsClosed s ‚Üî ‚àÄ (x : Œ±), (‚àÉ·∂† (y : Œ±) in nhds x, y ‚àà s) ‚Üí x ‚àà s",
    "name": "isClosed_iff_frequently",
    "doc":
    "A set `s` is closed iff for every point `x`, if there is a point `y` close to `x` that belongs\nto `s` then `x` is in `s`. ",
    "depth": 14}],
  "count": 141},
 {"noDocExamples": [],
  "kind": "MeasureTheory.¬´term‚à´‚Åª_In_,_‚àÇ_¬ª",
  "examples":
  [{"term":
    "‚àÄ {Œ± : Type u_1} {mŒ± : MeasurableSpace Œ±} (œÅ : MeasureTheory.Measure (Œ± √ó ‚Ñù)) [inst : MeasureTheory.IsFiniteMeasure œÅ]\n  (r : ‚Ñö) {s : Set Œ±},\n  MeasurableSet s ‚Üí\n    ‚à´‚Åª (a : Œ±) in s, ENNReal.ofReal (‚Üë(ProbabilityTheory.condCdf œÅ a) ‚Üër) ‚àÇMeasureTheory.Measure.fst œÅ =\n      ‚Üë‚ÜëœÅ (s √óÀ¢ Set.Iic ‚Üër)",
    "name": "ProbabilityTheory.set_lintegral_condCdf_rat",
    "doc": "Auxiliary lemma for `set_lintegral_cond_cdf`. ",
    "depth": 18},
   {"term":
    "‚àÄ {Œ± : Type u_1} {m : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {Œπ : Type u_5} {f : Œ± ‚Üí ENNReal},\n  ‚à´‚Åª (x : Œ±), f x ‚àÇŒº ‚â† ‚ä§ ‚Üí\n    ‚àÄ {l : Filter Œπ} {s : Œπ ‚Üí Set Œ±},\n      Filter.Tendsto (‚Üë‚ÜëŒº ‚àò s) l (nhds 0) ‚Üí Filter.Tendsto (fun i => ‚à´‚Åª (x : Œ±) in s i, f x ‚àÇŒº) l (nhds 0)",
    "name": "MeasureTheory.tendsto_set_lintegral_zero",
    "doc":
    "If `f` has finite integral, then `‚à´‚Åª x in s, f x ‚àÇŒº` is absolutely continuous in `s`: it tends\nto zero as `Œº s` tends to zero. ",
    "depth": 19},
   {"term":
    "‚àÄ {Œ± : Type u_1} [inst : MeasurableSpace Œ±] {Œº : MeasureTheory.Measure Œ±} [inst_1 : MeasureTheory.SigmaFinite Œº]\n  (C : ENNReal) {f : Œ± ‚Üí ENNReal},\n  AEMeasurable f ‚Üí (‚àÄ (s : Set Œ±), MeasurableSet s ‚Üí ‚Üë‚ÜëŒº s ‚â† ‚ä§ ‚Üí ‚à´‚Åª (x : Œ±) in s, f x ‚àÇŒº ‚â§ C) ‚Üí ‚à´‚Åª (x : Œ±), f x ‚àÇŒº ‚â§ C",
    "name": "MeasureTheory.lintegral_le_of_forall_fin_meas_le",
    "doc":
    "If the Lebesgue integral of a function is bounded by some constant on all sets with finite\nmeasure and the measure is œÉ-finite, then the integral over the whole space is bounded by that same\nconstant. ",
    "depth": 21},
   {"term":
    "‚àÄ {Œ± : Type u_1} {m0 : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {s : Set Œ±} {f : Œ± ‚Üí ENNReal},\n  ‚Üë‚ÜëŒº s ‚â† 0 ‚Üí\n    MeasureTheory.NullMeasurableSet s ‚Üí ‚à´‚Åª (a : Œ±) in s, f a ‚àÇŒº ‚â† ‚ä§ ‚Üí ‚àÉ x, x ‚àà s ‚àß ‚®ç‚Åª (a : Œ±) in s, f a ‚àÇŒº ‚â§ f x",
    "name": "MeasureTheory.exists_setLaverage_le",
    "doc":
    "**First moment method**. The maximum of a measurable function is greater than its mean. ",
    "depth": 21},
   {"term":
    "‚àÄ {Œ± : Type u_1} [inst : MeasurableSpace Œ±] {Œº : MeasureTheory.Measure Œ±} {f g : Œ± ‚Üí ‚Ñù} {s : Set Œ±}\n  [inst_1 : MeasureTheory.SigmaFinite Œº],\n  AEMeasurable f ‚Üí\n    AEMeasurable g ‚Üí\n      MeasurableSet s ‚Üí\n        ‚Üë‚Üë(MeasureTheory.Measure.prod Œº MeasureTheory.volume) (regionBetween f g s) =\n          ‚à´‚Åª (y : Œ±) in s, ENNReal.ofReal ((g - f) y) ‚àÇŒº",
    "name": "volume_regionBetween_eq_lintegral",
    "doc":
    "The volume of the region between two almost everywhere measurable functions on a measurable set\ncan be represented as a Lebesgue integral. ",
    "depth": 22}],
  "count": 135},
 {"noDocExamples": [],
  "kind": "¬´term_‚Ü™o_¬ª",
  "examples":
  [{"term": "Cardinal.{v} ‚Ü™o Cardinal.{max v u}",
    "name": "Cardinal.liftOrderEmbedding",
    "doc": "`Cardinal.lift` as an `OrderEmbedding`. ",
    "depth": 4},
   {"term": "Cardinal.{u_3} ‚Ü™o Ordinal.{u_3}",
    "name": "Cardinal.ord.orderEmbedding",
    "doc":
    "The ordinal corresponding to a cardinal `c` is the least ordinal\nwhose cardinal is `c`. This is the order-embedding version. For the regular function, see `ord`.\n",
    "depth": 4},
   {"term": "Ordinal.{u} ‚Ü™o SetTheory.PGame",
    "name": "Ordinal.toPGameEmbedding",
    "doc": "The order embedding version of `toPGame`. ",
    "depth": 5},
   {"term": "Ordinal.{u_1} ‚Ü™o Surreal",
    "name": "Ordinal.toSurreal",
    "doc": "Converts an ordinal into the corresponding surreal. ",
    "depth": 5},
   {"term": "(n : ‚Ñï) ‚Üí Fin n ‚Ü™o ‚Ñï",
    "name": "Fin.valOrderEmbedding",
    "doc": "The inclusion map `Fin n ‚Üí ‚Ñï` is an order embedding. ",
    "depth": 6}],
  "count": 134},
 {"noDocExamples": [],
  "kind": "¬´term_‚âÉ·µ¢_¬ª",
  "examples":
  [{"term": "(Œ± : Type u_2) ‚Üí [inst : PseudoEMetricSpace Œ±] ‚Üí Œ± ‚âÉ·µ¢ Œ±",
    "name": "IsometryEquiv.refl",
    "doc": "The identity isometry of a space. ",
    "depth": 6},
   {"term": "{Œ± : Type u} ‚Üí [inst : PseudoEMetricSpace Œ±] ‚Üí Group (Œ± ‚âÉ·µ¢ Œ±)",
    "name": "IsometryEquiv.instGroupIsometryEquiv",
    "doc": "The group of isometries. ",
    "depth": 7},
   {"term":
    "{Œ± : Type u} ‚Üí {Œ≤ : Type v} ‚Üí [inst : PseudoEMetricSpace Œ±] ‚Üí [inst_1 : PseudoEMetricSpace Œ≤] ‚Üí Œ± ‚âÉ·µ¢ Œ≤ ‚Üí Œ≤ ‚âÉ·µ¢ Œ±",
    "name": "IsometryEquiv.symm",
    "doc":
    "The inverse of an isometric isomorphism, as an isometric isomorphism. ",
    "depth": 9},
   {"term":
    "{Œ± : Type u} ‚Üí {Œ≤ : Type v} ‚Üí [inst : PseudoEMetricSpace Œ±] ‚Üí [inst_1 : PseudoEMetricSpace Œ≤] ‚Üí Œ± ‚âÉ·µ¢ Œ≤ ‚Üí Œ± ‚Üí Œ≤",
    "name": "IsometryEquiv.Simps.apply",
    "doc":
    "See Note [custom simps projection]. We need to specify this projection explicitly in this case,\nbecause it is a composition of multiple projections. ",
    "depth": 9},
   {"term":
    "{Œ± : Type u} ‚Üí {Œ≤ : Type v} ‚Üí [inst : PseudoEMetricSpace Œ±] ‚Üí [inst_1 : PseudoEMetricSpace Œ≤] ‚Üí Œ± ‚âÉ·µ¢ Œ≤ ‚Üí Œ≤ ‚Üí Œ±",
    "name": "IsometryEquiv.Simps.symm_apply",
    "doc": "See Note [custom simps projection] ",
    "depth": 9}],
  "count": 132},
 {"noDocExamples": [],
  "kind": "¬´term_[Œõ^_]‚ÜíL[_]_¬ª",
  "examples":
  [{"term":
    "(R : Type u_1) ‚Üí\n  (M : Type u_2) ‚Üí\n    {Œπ : Type u_6} ‚Üí\n      [inst : Semiring R] ‚Üí\n        [inst_1 : AddCommMonoid M] ‚Üí\n          [inst_2 : Module R M] ‚Üí [inst_3 : TopologicalSpace M] ‚Üí [inst_4 : Subsingleton Œπ] ‚Üí Œπ ‚Üí M[Œõ^Œπ]‚ÜíL[R]M",
    "name": "ContinuousAlternatingMap.ofSubsingleton",
    "doc":
    "The evaluation map from `Œπ ‚Üí M` to `M` is alternating at a given `i` when `Œπ` is subsingleton.\n",
    "depth": 20},
   {"term":
    "{R : Type u_1} ‚Üí\n  {M : Type u_2} ‚Üí\n    {N : Type u_3} ‚Üí\n      {Œπ : Type u_4} ‚Üí\n        [inst : Semiring R] ‚Üí\n          [inst_1 : AddCommMonoid M] ‚Üí\n            [inst_2 : Module R M] ‚Üí\n              [inst_3 : TopologicalSpace M] ‚Üí\n                [inst_4 : AddCommMonoid N] ‚Üí\n                  [inst_5 : Module R N] ‚Üí\n                    [inst_6 : TopologicalSpace N] ‚Üí M[Œõ^Œπ]‚ÜíL[R]N ‚Üí ContinuousMultilinearMap R (fun x => M) N",
    "name": "ContinuousAlternatingMap.toContinuousMultilinearMap",
    "doc": "Projection to `ContinuousMultilinearMap`s. ",
    "depth": 23},
   {"term":
    "{R : Type u_1} ‚Üí\n  {M : Type u_2} ‚Üí\n    {N : Type u_3} ‚Üí\n      {Œπ : Type u_4} ‚Üí\n        [inst : Semiring R] ‚Üí\n          [inst_1 : AddCommMonoid M] ‚Üí\n            [inst_2 : Module R M] ‚Üí\n              [inst_3 : TopologicalSpace M] ‚Üí\n                [inst_4 : AddCommMonoid N] ‚Üí\n                  [inst_5 : Module R N] ‚Üí [inst_6 : TopologicalSpace N] ‚Üí M[Œõ^Œπ]‚ÜíL[R]N ‚Üí AlternatingMap R M N Œπ",
    "name": "ContinuousAlternatingMap.toAlternatingMap",
    "doc": "Projection to `AlternatingMap`s. ",
    "depth": 23},
   {"term":
    "(R : Type u_1) ‚Üí\n  (M : Type u_2) ‚Üí\n    {N : Type u_4} ‚Üí\n      (Œπ : Type u_6) ‚Üí\n        [inst : Semiring R] ‚Üí\n          [inst_1 : AddCommMonoid M] ‚Üí\n            [inst_2 : Module R M] ‚Üí\n              [inst_3 : TopologicalSpace M] ‚Üí\n                [inst_4 : AddCommMonoid N] ‚Üí\n                  [inst_5 : Module R N] ‚Üí [inst_6 : TopologicalSpace N] ‚Üí [inst_7 : IsEmpty Œπ] ‚Üí N ‚Üí M[Œõ^Œπ]‚ÜíL[R]N",
    "name": "ContinuousAlternatingMap.constOfIsEmpty",
    "doc": "The constant map is alternating when `Œπ` is empty. ",
    "depth": 24},
   {"term":
    "{R : Type u_1} ‚Üí\n  {M : Type u_2} ‚Üí\n    {Œπ : Type u_6} ‚Üí\n      [inst : Semiring R] ‚Üí\n        [inst_1 : AddCommMonoid M] ‚Üí\n          [inst_2 : Module R M] ‚Üí\n            [inst_3 : TopologicalSpace M] ‚Üí\n              {Œπ' : Type u_7} ‚Üí\n                {M' : Œπ' ‚Üí Type u_8} ‚Üí\n                  [inst_4 : (i : Œπ') ‚Üí AddCommMonoid (M' i)] ‚Üí\n                    [inst_5 : (i : Œπ') ‚Üí TopologicalSpace (M' i)] ‚Üí\n                      [inst_6 : (i : Œπ') ‚Üí Module R (M' i)] ‚Üí\n                        ((i : Œπ') ‚Üí M[Œõ^Œπ]‚ÜíL[R]M' i) ‚Üí M[Œõ^Œπ]‚ÜíL[R]((i : Œπ') ‚Üí M' i)",
    "name": "ContinuousAlternatingMap.pi",
    "doc":
    "Combine a family of continuous alternating maps with the same domain and codomains `M' i` into a\ncontinuous alternating map taking values in the space of functions `Œ† i, M' i`. ",
    "depth": 25}],
  "count": 129},
 {"noDocExamples": [],
  "kind": "¬´term_‚âÉ·µê_¬ª",
  "examples":
  [{"term": "ENNReal ‚âÉ·µê NNReal ‚äï Unit",
    "name": "ENNReal.ennrealEquivSum",
    "doc": "`‚Ñù‚â•0‚àû` is `MeasurableEquiv` to `‚Ñù‚â•0 ‚äï Unit`. ",
    "depth": 5},
   {"term": "‚ÑÇ ‚âÉ·µê ‚Ñù √ó ‚Ñù",
    "name": "Complex.measurableEquivRealProd",
    "doc": "Measurable equivalence between `‚ÑÇ` and `‚Ñù √ó ‚Ñù`. ",
    "depth": 5},
   {"term": "(Œ± : Type u_6) ‚Üí [inst : MeasurableSpace Œ±] ‚Üí Œ± ‚âÉ·µê Œ±",
    "name": "MeasurableEquiv.refl",
    "doc": "Any measurable space is equivalent to itself. ",
    "depth": 6},
   {"term":
    "(G : Type u_4) ‚Üí [inst : MeasurableSpace G] ‚Üí [inst_1 : InvolutiveInv G] ‚Üí [inst_2 : MeasurableInv G] ‚Üí G ‚âÉ·µê G",
    "name": "MeasurableEquiv.inv",
    "doc":
    "Inversion as a measurable automorphism of a group or group with zero. ",
    "depth": 8},
   {"term": "‚ÑÇ ‚âÉ·µê (Fin 2 ‚Üí ‚Ñù)",
    "name": "Complex.measurableEquivPi",
    "doc": "Measurable equivalence between `‚ÑÇ` and `‚Ñù¬≤ = Fin 2 ‚Üí ‚Ñù`. ",
    "depth": 8}],
  "count": 128},
 {"noDocExamples":
  [{"term":
    "‚àÄ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {X Y : C} (Œ± : X ‚âÖ Y), Œ± ‚â™‚â´ CategoryTheory.Iso.refl Y = Œ±",
    "name": "CategoryTheory.Iso.trans_refl",
    "depth": 14},
   {"term":
    "‚àÄ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {X Y : C} (Œ± : X ‚âÖ Y), CategoryTheory.Iso.refl X ‚â™‚â´ Œ± = Œ±",
    "name": "CategoryTheory.Iso.refl_trans",
    "depth": 14},
   {"term":
    "‚àÄ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {X Y : C} (Œ± : X ‚âÖ Y), Œ± ‚â™‚â´ Œ±.symm = CategoryTheory.Iso.refl X",
    "name": "CategoryTheory.Iso.self_symm_id",
    "depth": 14}],
  "kind": "CategoryTheory.Iso.¬´term_‚â™‚â´_¬ª",
  "examples":
  [{"term":
    "‚àÄ {B : Type u} [inst : CategoryTheory.Bicategory B] {a b : B} (self : CategoryTheory.Bicategory.Equivalence a b),\n  CategoryTheory.Bicategory.leftZigzagIso self.unit self.counit =\n    CategoryTheory.Bicategory.leftUnitor self.hom ‚â™‚â´ (CategoryTheory.Bicategory.rightUnitor self.hom).symm",
    "name": "CategoryTheory.Bicategory.Equivalence.left_triangle",
    "doc":
    "The composition of the unit and the counit is equal to the identity up to unitors. ",
    "depth": 19},
   {"term":
    "‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D]\n  {F G H : CategoryTheory.Functor C D} (e : F ‚âÖ G) (e' : G ‚âÖ H) (hF : CategoryTheory.IsEquivalence F),\n  CategoryTheory.IsEquivalence.ofIso e' (CategoryTheory.IsEquivalence.ofIso e hF) =\n    CategoryTheory.IsEquivalence.ofIso (e ‚â™‚â´ e') hF",
    "name": "CategoryTheory.IsEquivalence.ofIso_trans",
    "doc":
    "Compatibility of `ofIso` with the composition of isomorphisms of functors ",
    "depth": 24}],
  "count": 128},
 {"noDocExamples":
  [{"term": "{M : Type u_1} ‚Üí [inst : Group M·µê·µí·µñ] ‚Üí Group M·µà·µê·µÉ",
    "name": "DomMulAct.instGroupDomMulAct",
    "depth": 4},
   {"term": "{M : Type u_1} ‚Üí [inst : Inv M·µê·µí·µñ] ‚Üí Inv M·µà·µê·µÉ",
    "name": "DomMulAct.instInvDomMulAct",
    "depth": 4},
   {"term":
    "{M : Type u_1} ‚Üí [inst : DivisionMonoid M·µê·µí·µñ] ‚Üí DivisionMonoid M·µà·µê·µÉ",
    "name": "DomMulAct.instDivisionMonoidDomMulAct",
    "depth": 4},
   {"term":
    "{M : Type u_1} ‚Üí [inst : RightCancelSemigroup M·µê·µí·µñ] ‚Üí RightCancelSemigroup M·µà·µê·µÉ",
    "name": "DomMulAct.instRightCancelSemigroupDomMulAct",
    "depth": 4}],
  "kind": "¬´term_·µà·µê·µÉ¬ª",
  "examples":
  [{"term": "{M : Type u_1} ‚Üí M ‚âÉ M·µà·µê·µÉ",
    "name": "DomMulAct.mk",
    "doc": "Equivalence between `M` and `M·µà·µê·µÉ`. ",
    "depth": 3}],
  "count": 127},
 {"noDocExamples": [],
  "kind": "¬´term‚àè·∂†_,_¬ª",
  "examples":
  [{"term":
    "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {M : Type u_5} [inst : CommMonoid M] {g : Œ≤ ‚Üí M} (e : Œ± ‚Üí Œ≤),\n  Function.Bijective e ‚Üí ‚àè·∂† (i : Œ±), g (e i) = ‚àè·∂† (j : Œ≤), g j",
    "name": "finprod_comp",
    "doc":
    "See also `finprod_eq_of_bijective`, `Fintype.prod_bijective` and `Finset.prod_bij`. ",
    "depth": 13},
   {"term":
    "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {M : Type u_5} [inst : CommMonoid M] {f : Œ± ‚Üí M} {g : Œ≤ ‚Üí M} (e : Œ± ‚Üí Œ≤),\n  Function.Bijective e ‚Üí (‚àÄ (x : Œ±), f x = g (e x)) ‚Üí ‚àè·∂† (i : Œ±), f i = ‚àè·∂† (j : Œ≤), g j",
    "name": "finprod_eq_of_bijective",
    "doc":
    "See `finprod_comp`, `Fintype.prod_bijective` and `Finset.prod_bij`. ",
    "depth": 15},
   {"term":
    "‚àÄ {Œ± : Type u_1} {M : Type u_5} [inst : CommMonoid M] (s : Set Œ±), ‚àè·∂† (i : Œ±) (_ : i ‚àà s), 1 = 1",
    "name": "finprod_mem_one",
    "doc": "The product of the constant function `1` over any set equals `1`. ",
    "depth": 16},
   {"term":
    "‚àÄ {Œ± : Type u_1} {M : Type u_5} [inst : CommMonoid M] {f : Œ± ‚Üí M}, ‚àè·∂† (i : Œ±) (_ : i ‚àà ‚àÖ), f i = 1",
    "name": "finprod_mem_empty",
    "doc": "The product of any function over an empty set is `1`. ",
    "depth": 16},
   {"term":
    "‚àÄ {Œ± : Type u_1} {M : Type u_5} [inst : CommMonoid M] {f : Œ± ‚Üí M} {a : Œ±}, ‚àè·∂† (i : Œ±) (_ : i ‚àà {a}), f i = f a",
    "name": "finprod_mem_singleton",
    "doc": "The product of `f i` over `i ‚àà {a}` equals `f a`. ",
    "depth": 17}],
  "count": 127},
 {"noDocExamples": [],
  "kind": "CategoryTheory.Limits.¬´term‚ä§__¬ª",
  "examples":
  [{"term":
    "{C : Type u‚ÇÅ} ‚Üí\n  [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] ‚Üí\n    [inst_1 : CategoryTheory.Limits.HasTerminal C] ‚Üí CategoryTheory.Limits.IsTerminal (‚ä§_ C)",
    "name": "CategoryTheory.Limits.terminalIsTerminal",
    "doc": "A terminal object is terminal. ",
    "depth": 7},
   {"term": "‚ä§_ TopCat ‚âÖ TopCat.of PUnit.{u + 1}",
    "name": "TopCat.terminalIsoPUnit",
    "doc": "The terminal object of `Top` is `PUnit`. ",
    "depth": 8},
   {"term":
    "{C : Type u‚ÇÅ} ‚Üí\n  [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] ‚Üí\n    [inst_1 : CategoryTheory.Limits.HasTerminal C] ‚Üí {P : C} ‚Üí CategoryTheory.Limits.IsTerminal P ‚Üí (‚ä§_ C ‚âÖ P)",
    "name": "CategoryTheory.Limits.terminalIsoIsTerminal",
    "doc":
    "The (unique) isomorphism between the chosen terminal object and any other terminal object. ",
    "depth": 10},
   {"term": "‚ä§_ Type u ‚âÖ PUnit.{u + 1}",
    "name": "CategoryTheory.Limits.Types.terminalIso",
    "doc": "The terminal object in `Type u` is `PUnit`. ",
    "depth": 10},
   {"term":
    "(C : Type u‚ÇÅ) ‚Üí\n  [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] ‚Üí\n    [inst_1 : CategoryTheory.Limits.HasTerminal C] ‚Üí CategoryTheory.Subterminals C ‚âå CategoryTheory.MonoOver (‚ä§_ C)",
    "name": "CategoryTheory.subterminalsEquivMonoOverTerminal",
    "doc":
    "The category of subterminal objects is equivalent to the category of monomorphisms to the terminal\nobject (which is in turn equivalent to the subobjects of the terminal object).\n",
    "depth": 10}],
  "count": 126},
 {"noDocExamples": [],
  "kind": "¬´term_‚Üí‚Çó‚ÅÖ_,_‚ÅÜ_¬ª",
  "examples":
  [{"term":
    "{R : Type u} ‚Üí\n  {L : Type v} ‚Üí\n    {M : Type w} ‚Üí\n      [inst : CommRing R] ‚Üí\n        [inst_1 : LieRing L] ‚Üí\n          [inst_2 : AddCommGroup M] ‚Üí [inst_3 : Module R M] ‚Üí [inst_4 : LieRingModule L M] ‚Üí M ‚Üí‚Çó‚ÅÖR,L‚ÅÜ M",
    "name": "LieModuleHom.id",
    "doc": "The identity map is a morphism of Lie modules. ",
    "depth": 20},
   {"term":
    "{R : Type u} ‚Üí\n  {L : Type v} ‚Üí\n    {M : Type w} ‚Üí\n      [inst : CommRing R] ‚Üí\n        [inst_1 : LieRing L] ‚Üí\n          [inst_2 : AddCommGroup M] ‚Üí [inst_3 : Module R M] ‚Üí [inst_4 : LieRingModule L M] ‚Üí One (M ‚Üí‚Çó‚ÅÖR,L‚ÅÜ M)",
    "name": "LieModuleHom.instOneLieModuleHom",
    "doc": "The identity map is a Lie module morphism. ",
    "depth": 21},
   {"term":
    "{R : Type u} ‚Üí\n  {L : Type v} ‚Üí\n    {M : Type w} ‚Üí\n      {N : Type w‚ÇÅ} ‚Üí\n        [inst : CommRing R] ‚Üí\n          [inst_1 : LieRing L] ‚Üí\n            [inst_2 : AddCommGroup M] ‚Üí\n              [inst_3 : Module R M] ‚Üí\n                [inst_4 : LieRingModule L M] ‚Üí\n                  [inst_5 : AddCommGroup N] ‚Üí\n                    [inst_6 : Module R N] ‚Üí [inst_7 : LieRingModule L N] ‚Üí (M ‚Üí‚Çó‚ÅÖR,L‚ÅÜ N) ‚Üí LieSubmodule R L N",
    "name": "LieModuleHom.range",
    "doc":
    "The range of a morphism of Lie modules `f : M ‚Üí N` is a Lie submodule of `N`.\nSee Note [range copy pattern]. ",
    "depth": 25},
   {"term":
    "{R : Type u} ‚Üí\n  {L : Type v} ‚Üí\n    {M : Type w} ‚Üí\n      {N : Type w‚ÇÅ} ‚Üí\n        [inst : CommRing R] ‚Üí\n          [inst_1 : LieRing L] ‚Üí\n            [inst_2 : AddCommGroup M] ‚Üí\n              [inst_3 : AddCommGroup N] ‚Üí\n                [inst_4 : Module R M] ‚Üí\n                  [inst_5 : Module R N] ‚Üí\n                    [inst_6 : LieRingModule L M] ‚Üí [inst_7 : LieRingModule L N] ‚Üí Zero (M ‚Üí‚Çó‚ÅÖR,L‚ÅÜ N)",
    "name": "LieModuleHom.instZeroLieModuleHom",
    "doc": "The constant 0 map is a Lie module morphism. ",
    "depth": 25},
   {"term":
    "{R : Type u} ‚Üí\n  {L : Type v} ‚Üí\n    {M : Type w} ‚Üí\n      {N : Type w‚ÇÅ} ‚Üí\n        [inst : CommRing R] ‚Üí\n          [inst_1 : LieRing L] ‚Üí\n            [inst_2 : AddCommGroup M] ‚Üí\n              [inst_3 : Module R M] ‚Üí\n                [inst_4 : LieRingModule L M] ‚Üí\n                  [inst_5 : AddCommGroup N] ‚Üí\n                    [inst_6 : Module R N] ‚Üí [inst_7 : LieRingModule L N] ‚Üí (M ‚Üí‚Çó‚ÅÖR,L‚ÅÜ N) ‚Üí LieSubmodule R L M",
    "name": "LieModuleHom.ker",
    "doc":
    "The kernel of a morphism of Lie algebras, as an ideal in the domain. ",
    "depth": 25}],
  "count": 126},
 {"noDocExamples": [],
  "kind": "¬´term_‚Üí‚Çô‚Çê[_]_¬ª",
  "examples":
  [{"term":
    "(R : Type u_1) ‚Üí\n  (A : Type u_2) ‚Üí\n    [inst : Monoid R] ‚Üí [inst_1 : NonUnitalNonAssocSemiring A] ‚Üí [inst_2 : DistribMulAction R A] ‚Üí A ‚Üí‚Çô‚Çê[R] A",
    "name": "NonUnitalAlgHom.id",
    "doc": "The identity map as a `NonUnitalAlgHom`. ",
    "depth": 13},
   {"term":
    "(R : Type u) ‚Üí\n  {X : Type v} ‚Üí [inst : CommRing R] ‚Üí FreeNonUnitalNonAssocAlgebra R X ‚Üí‚Çô‚Çê[R] CommutatorRing (FreeLieAlgebra R X)",
    "name": "FreeLieAlgebra.mk",
    "doc": "The quotient map as a `NonUnitalAlgHom`. ",
    "depth": 15},
   {"term":
    "(R : Type u_1) ‚Üí\n  (A : Type u_2) ‚Üí\n    [inst : CommSemiring R] ‚Üí [inst_1 : NonUnitalSemiring A] ‚Üí [inst_2 : Module R A] ‚Üí A ‚Üí‚Çô‚Çê[R] Unitization R A",
    "name": "Unitization.inrNonUnitalAlgHom",
    "doc":
    "The coercion from a non-unital `R`-algebra `A` to its unitization `Unitization R A`\nrealized as a non-unital algebra homomorphism. ",
    "depth": 16},
   {"term":
    "{R : Type u} ‚Üí\n  {A : Type v} ‚Üí\n    {B : Type w} ‚Üí\n      [inst : Monoid R] ‚Üí\n        [inst_1 : NonUnitalNonAssocSemiring A] ‚Üí\n          [inst_2 : DistribMulAction R A] ‚Üí\n            [inst_3 : NonUnitalNonAssocSemiring B] ‚Üí [inst_4 : DistribMulAction R B] ‚Üí (A ‚Üí‚Çô‚Çê[R] B) ‚Üí A ‚Üí B",
    "name": "NonUnitalAlgHom.Simps.apply",
    "doc": "See Note [custom simps projection] ",
    "depth": 17},
   {"term":
    "(R : Type u) ‚Üí\n  (A : Type v) ‚Üí\n    (B : Type w) ‚Üí\n      [inst : Monoid R] ‚Üí\n        [inst_1 : NonUnitalNonAssocSemiring A] ‚Üí\n          [inst_2 : DistribMulAction R A] ‚Üí\n            [inst_3 : NonUnitalNonAssocSemiring B] ‚Üí [inst_4 : DistribMulAction R B] ‚Üí A ‚Üí‚Çô‚Çê[R] A √ó B",
    "name": "NonUnitalAlgHom.inl",
    "doc":
    "The left injection into a product is a non-unital algebra homomorphism. ",
    "depth": 17}],
  "count": 126},
 {"noDocExamples": [],
  "kind": "¬´term_‚Üí*‚ÇÄ_¬ª",
  "examples":
  [{"term": "NNReal ‚Üí*‚ÇÄ NNReal",
    "name": "NNReal.sqrtHom",
    "doc": "`NNReal.sqrt` as a `MonoidWithZeroHom`. ",
    "depth": 5},
   {"term": "‚Ñù ‚Üí*‚ÇÄ NNReal",
    "name": "Real.nnabs",
    "doc": "The absolute value on `‚Ñù` as a map to `‚Ñù‚â•0`. ",
    "depth": 5},
   {"term": "‚Ñ§ ‚Üí*‚ÇÄ ‚Ñï",
    "name": "Int.natAbsHom",
    "doc": "`Int.natAbs` as a bundled monoid with zero hom. ",
    "depth": 5},
   {"term": "‚ÑÇ ‚Üí*‚ÇÄ ‚Ñù",
    "name": "Complex.normSq",
    "doc": "The norm squared function. ",
    "depth": 5},
   {"term": "(M : Type u_9) ‚Üí [inst : MulZeroOneClass M] ‚Üí M ‚Üí*‚ÇÄ M",
    "name": "MonoidWithZeroHom.id",
    "doc": "The identity map from a `MonoidWithZero` to itself. ",
    "depth": 6}],
  "count": 125},
 {"noDocExamples": [],
  "kind": "Prefunctor.¬´term_‚•§q_¬ª",
  "examples":
  [{"term": "{V : Type u_2} ‚Üí [inst : Quiver V] ‚Üí V ‚•§q Quiver.Symmetrify V",
    "name": "Quiver.Symmetrify.of",
    "doc": "The inclusion of a quiver in its symmetrification ",
    "depth": 6},
   {"term":
    "{B : Type u} ‚Üí [inst : Quiver B] ‚Üí B ‚•§q CategoryTheory.FreeBicategory B",
    "name": "CategoryTheory.FreeBicategory.of",
    "doc": "Canonical prefunctor from `B` to `free_bicategory B`. ",
    "depth": 6},
   {"term": "(V : Type u_1) ‚Üí [inst : Quiver V] ‚Üí V ‚•§q V",
    "name": "Prefunctor.id",
    "doc": "The identity morphism between quivers. ",
    "depth": 6},
   {"term": "{V : Type u‚ÇÅ} ‚Üí [inst : Quiver V] ‚Üí V ‚•§q CategoryTheory.Paths V",
    "name": "CategoryTheory.Paths.of",
    "doc":
    "The inclusion of a quiver `V` into its path category, as a prefunctor.\n",
    "depth": 7},
   {"term":
    "(V : Type u_1) ‚Üí [inst : Quiver V] ‚Üí V ‚•§q CategoryTheory.FreeGroupoid V",
    "name": "CategoryTheory.Groupoid.Free.of",
    "doc":
    "The inclusion of the quiver on `V` to the underlying quiver on `FreeGroupoid V`",
    "depth": 8}],
  "count": 124},
 {"noDocExamples": [],
  "kind": "¬´term_‚Ü™r_¬ª",
  "examples":
  [{"term": "{Œ± : Type u_1} ‚Üí (r : Œ± ‚Üí Œ± ‚Üí Prop) ‚Üí r ‚Ü™r r",
    "name": "RelEmbedding.refl",
    "doc": "Identity map is a relation embedding. ",
    "depth": 6},
   {"term":
    "{Œ± : Type u_1} ‚Üí (r : Œ± ‚Üí Œ± ‚Üí Prop) ‚Üí (p : Set Œ±) ‚Üí Subrel r p ‚Ü™r r",
    "name": "Subrel.relEmbedding",
    "doc": "The relation embedding from the inherited relation on a subset. ",
    "depth": 9},
   {"term":
    "{Œ± : Type u_1} ‚Üí {Œ≤ : Type u_2} ‚Üí (r : Œ± ‚Üí Œ± ‚Üí Prop) ‚Üí (s : Œ≤ ‚Üí Œ≤ ‚Üí Prop) ‚Üí s ‚Ü™r Sum.Lex r s",
    "name": "RelEmbedding.sumLexInr",
    "doc": "`Sum.inr` as a relation embedding into `Sum.Lex r s`. ",
    "depth": 9},
   {"term":
    "{Œ± : Type u_1} ‚Üí {Œ≤ : Type u_2} ‚Üí {r : Œ± ‚Üí Œ± ‚Üí Prop} ‚Üí {s : Œ≤ ‚Üí Œ≤ ‚Üí Prop} ‚Üí r ‚âÉr s ‚Üí r ‚Ü™r s",
    "name": "RelIso.toRelEmbedding",
    "doc":
    "Convert a `RelIso` to a `RelEmbedding`. This function is also available as a coercion\nbut often it is easier to write `f.toRelEmbedding` than to write explicitly `r` and `s`\nin the target type. ",
    "depth": 9},
   {"term":
    "{Œ± : Type u_1} ‚Üí {Œ≤ : Type u_2} ‚Üí {r : Œ± ‚Üí Œ± ‚Üí Prop} ‚Üí {s : Œ≤ ‚Üí Œ≤ ‚Üí Prop} ‚Üí r ‚Ü™r s ‚Üí r ‚Üír s",
    "name": "RelEmbedding.toRelHom",
    "doc": "A relation embedding is also a relation homomorphism ",
    "depth": 9}],
  "count": 121},
 {"noDocExamples": [],
  "kind": "CategoryTheory.Limits.¬´term_‚®Ø_¬ª",
  "examples":
  [{"term":
    "{C : Type u} ‚Üí\n  [inst : CategoryTheory.Category.{v, u} C] ‚Üí\n    (X : C) ‚Üí [inst_1 : CategoryTheory.Limits.HasBinaryProduct X X] ‚Üí X ‚ü∂ X ‚®Ø X",
    "name": "CategoryTheory.Limits.diag",
    "doc": "diagonal arrow of the binary product in the category `fam I` ",
    "depth": 10},
   {"term": "(X Y : Type u) ‚Üí X ‚®Ø Y ‚âÖ X √ó Y",
    "name": "CategoryTheory.Limits.Types.binaryProductIso",
    "doc": "The categorical binary product in `Type u` is cartesian product. ",
    "depth": 12},
   {"term": "(X Y : TopCat) ‚Üí X ‚®Ø Y ‚âÖ TopCat.of (‚ÜëX √ó ‚ÜëY)",
    "name": "TopCat.prodIsoProd",
    "doc":
    "The homeomorphism between `X ‚®Ø Y` and the set-theoretic product of `X` and `Y`,\nequipped with the product topology.\n",
    "depth": 12},
   {"term":
    "{C : Type u} ‚Üí\n  [inst : CategoryTheory.Category.{v, u} C] ‚Üí\n    [inst_1 : CategoryTheory.Limits.HasTerminal C] ‚Üí\n      (P : C) ‚Üí [inst_2 : CategoryTheory.Limits.HasBinaryProduct P (‚ä§_ C)] ‚Üí P ‚®Ø ‚ä§_ C ‚âÖ P",
    "name": "CategoryTheory.Limits.prod.rightUnitor",
    "doc":
    "The right unitor isomorphism for binary products with the terminal object. ",
    "depth": 12},
   {"term":
    "{C : Type u‚ÇÅ} ‚Üí\n  [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] ‚Üí\n    {A : C} ‚Üí CategoryTheory.IsSubterminal A ‚Üí [inst_1 : CategoryTheory.Limits.HasBinaryProduct A A] ‚Üí A ‚®Ø A ‚âÖ A",
    "name": "CategoryTheory.IsSubterminal.isoDiag",
    "doc": "If `A` is subterminal, it is isomorphic to `A ‚®Ø A`. ",
    "depth": 12}],
  "count": 120},
 {"noDocExamples": [],
  "kind": "¬´term‚Ñ§_[_]¬ª",
  "examples":
  [{"term": "{p : ‚Ñï} ‚Üí [inst : Fact (Nat.Prime p)] ‚Üí Add ‚Ñ§_[p]",
    "name": "PadicInt.instAddPadicInt",
    "doc": "Addition on `‚Ñ§_[p]` is inherited from `‚Ñö_[p]`. ",
    "depth": 5},
   {"term": "{p : ‚Ñï} ‚Üí [hp_prime : Fact (Nat.Prime p)] ‚Üí ‚Ñ§_[p] ‚Üí ‚Ñï",
    "name": "PadicInt.zmodRepr",
    "doc":
    "`zmod_repr x` is the unique natural number smaller than `p`\nsatisfying `‚Äñ(x - zmod_repr x : ‚Ñ§_[p])‚Äñ < 1`.\n",
    "depth": 5},
   {"term": "{p : ‚Ñï} ‚Üí [inst : Fact (Nat.Prime p)] ‚Üí Mul ‚Ñ§_[p]",
    "name": "PadicInt.instMulPadicInt",
    "doc": "Multiplication on `‚Ñ§_[p]` is inherited from `‚Ñö_[p]`. ",
    "depth": 5},
   {"term": "{p : ‚Ñï} ‚Üí [inst : Fact (Nat.Prime p)] ‚Üí Zero ‚Ñ§_[p]",
    "name": "PadicInt.instZeroPadicInt",
    "doc": "Zero on `‚Ñ§_[p]` is inherited from `‚Ñö_[p]`. ",
    "depth": 5},
   {"term": "{p : ‚Ñï} ‚Üí [hp : Fact (Nat.Prime p)] ‚Üí ‚Ñ§_[p] ‚Üí ‚Ñ§",
    "name": "PadicInt.valuation",
    "doc":
    "`PadicInt.valuation` lifts the `p`-adic valuation on `‚Ñö` to `‚Ñ§_[p]`.  ",
    "depth": 5}],
  "count": 120},
 {"noDocExamples": [],
  "kind": "¬´term_‚§≥_¬ª",
  "examples":
  [{"term":
    "‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : RegularSpace Œ±] {a b : Œ±}, a ‚§≥ b ‚Üí b ‚§≥ a",
    "name": "Specializes.symm",
    "doc": "**Alias** of the forward direction of `specializes_comm`.",
    "depth": 10},
   {"term":
    "‚àÄ {X : Type u_1} [inst : TopologicalSpace X] {x y : X}, x ‚§≥ y ‚Üí y ‚àà closure {x}",
    "name": "Specializes.mem_closure",
    "doc":
    "**Alias** of the forward direction of `specializes_iff_mem_closure`.",
    "depth": 11},
   {"term":
    "‚àÄ {X : Type u_1} [inst : TopologicalSpace X] {x y : X}, x ‚§≥ y ‚Üí pure x ‚â§ nhds y",
    "name": "Specializes.pure_le_nhds",
    "doc": "**Alias** of the forward direction of `specializes_iff_pure`.",
    "depth": 12},
   {"term":
    "‚àÄ {X : Type u_1} [inst : TopologicalSpace X] {x y : X}, x ‚§≥ y ‚Üí nhds x ‚â§ nhds y",
    "name": "Specializes.nhds_le_nhds",
    "doc": "**Alias** of the forward direction of `specializes_iff_nhds`.",
    "depth": 12},
   {"term":
    "‚àÄ {X : Type u_1} [inst : TopologicalSpace X] {x y : X}, x ‚§≥ y ‚Üí closure {y} ‚äÜ closure {x}",
    "name": "Specializes.closure_subset",
    "doc":
    "**Alias** of the forward direction of `specializes_iff_closure_subset`.",
    "depth": 12}],
  "count": 118},
 {"noDocExamples": [],
  "kind": "¬´term_‚âÉ‚Çó·µ¢[_]_¬ª",
  "examples":
  [{"term": "‚ÑÇ ‚âÉ‚Çó·µ¢[‚Ñù] ‚ÑÇ",
    "name": "Complex.conjLie",
    "doc":
    "The complex-conjugation function from `‚ÑÇ` to itself is an isometric linear equivalence. ",
    "depth": 14},
   {"term": "(‚ÑÇ ‚âÉ‚Çó·µ¢[‚Ñù] ‚ÑÇ) ‚Üí { x // x ‚àà circle }",
    "name": "rotationOf",
    "doc":
    "Takes an element of `‚ÑÇ ‚âÉ‚Çó·µ¢[‚Ñù] ‚ÑÇ` and checks if it is a rotation, returns an element of the\nunit circle. ",
    "depth": 15},
   {"term": "{K : Type u_1} ‚Üí [inst : IsROrC K] ‚Üí K ‚âÉ‚Çó·µ¢[‚Ñù] K",
    "name": "IsROrC.conjLie",
    "doc": "Conjugate as a linear isometry ",
    "depth": 16},
   {"term": "Quaternion ‚Ñù ‚âÉ‚Çó·µ¢[‚Ñù] EuclideanSpace ‚Ñù (Fin 4)",
    "name": "Quaternion.linearIsometryEquivTuple",
    "doc": "`QuaternionAlgebra.linearEquivTuple` as a `LinearIsometryEquiv`. ",
    "depth": 17},
   {"term":
    "{F : Type u_6} ‚Üí\n  [inst : NormedAddCommGroup F] ‚Üí [inst_1 : InnerProductSpace ‚Ñù F] ‚Üí OrthonormalBasis (Fin 2) ‚Ñù F ‚Üí ‚ÑÇ ‚âÉ‚Çó·µ¢[‚Ñù] F",
    "name": "Complex.isometryOfOrthonormal",
    "doc":
    "The isometry between `‚ÑÇ` and a two-dimensional real inner product space given by a basis. ",
    "depth": 18}],
  "count": 118},
 {"noDocExamples": [],
  "kind": "Hyperreal.¬´term‚Ñù*¬ª",
  "examples":
  [{"term": "‚Ñù*",
    "name": "Hyperreal.epsilon",
    "doc": "A sample infinitesimal hyperreal",
    "depth": 0},
   {"term": "‚Ñù*",
    "name": "Hyperreal.omega",
    "doc": "A sample infinite hyperreal",
    "depth": 0},
   {"term": "‚Ñù* ‚Üí Prop",
    "name": "Hyperreal.InfiniteNeg",
    "doc":
    "A hyperreal number is negative infinite if it is smaller than all real numbers ",
    "depth": 1},
   {"term": "‚Ñù* ‚Üí ‚Ñù",
    "name": "Hyperreal.st",
    "doc": "Standard part function: like a \"round\" to ‚Ñù instead of ‚Ñ§ ",
    "depth": 1},
   {"term": "‚Ñù* ‚Üí Prop",
    "name": "Hyperreal.Infinitesimal",
    "doc": "A hyperreal number is infinitesimal if its standard part is 0 ",
    "depth": 1}],
  "count": 117},
 {"noDocExamples": [],
  "kind": "CategoryTheory.Limits.¬´term‚®Å_¬ª",
  "examples":
  [{"term":
    "{J : Type} ‚Üí [inst : Fintype J] ‚Üí (f : J ‚Üí AddCommGroupCat) ‚Üí ‚®Å f ‚âÖ AddCommGroupCat.of ((j : J) ‚Üí ‚Üë(f j))",
    "name": "AddCommGroupCat.biproductIsoPi",
    "doc":
    "We verify that the biproduct we've just defined is isomorphic to the `AddCommGroupCat` structure\non the dependent function type.\n",
    "depth": 14},
   {"term":
    "{J : Type w} ‚Üí\n  {C : Type u} ‚Üí\n    [inst : CategoryTheory.Category.{v, u} C] ‚Üí\n      [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] ‚Üí\n        (f : J ‚Üí C) ‚Üí [inst_2 : CategoryTheory.Limits.HasBiproduct f] ‚Üí (b : J) ‚Üí f b ‚ü∂ ‚®Å f",
    "name": "CategoryTheory.Limits.biproduct.Œπ",
    "doc": "The inclusion into a summand of a biproduct. ",
    "depth": 14},
   {"term":
    "{J : Type w} ‚Üí\n  {C : Type u} ‚Üí\n    [inst : CategoryTheory.Category.{v, u} C] ‚Üí\n      [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] ‚Üí\n        (f : J ‚Üí C) ‚Üí [inst_2 : CategoryTheory.Limits.HasBiproduct f] ‚Üí ‚®Å f ‚âÖ ‚àè f",
    "name": "CategoryTheory.Limits.biproduct.isoProduct",
    "doc":
    "The canonical isomorphism between the chosen biproduct and the chosen product. ",
    "depth": 14},
   {"term":
    "{J : Type w} ‚Üí\n  {C : Type u} ‚Üí\n    [inst : CategoryTheory.Category.{v, u} C] ‚Üí\n      [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] ‚Üí\n        (f : J ‚Üí C) ‚Üí [inst_2 : CategoryTheory.Limits.HasBiproduct f] ‚Üí ‚®Å f ‚âÖ ‚àê f",
    "name": "CategoryTheory.Limits.biproduct.isoCoproduct",
    "doc":
    "The canonical isomorphism between the chosen biproduct and the chosen coproduct. ",
    "depth": 14},
   {"term":
    "{J : Type w} ‚Üí\n  {C : Type u} ‚Üí\n    [inst : CategoryTheory.Category.{v, u} C] ‚Üí\n      [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] ‚Üí [inst_2 : Unique J] ‚Üí (f : J ‚Üí C) ‚Üí ‚®Å f ‚âÖ f default",
    "name": "CategoryTheory.Limits.biproductUniqueIso",
    "doc":
    "A biproduct over an index type with exactly one term is just the object over that term. ",
    "depth": 15}],
  "count": 116},
 {"noDocExamples": [],
  "kind": "Nat.¬´term_‚â°_[MOD_]¬ª",
  "examples":
  [{"term":
    "‚àÄ {n : ‚Ñï}, n ‚â† 0 ‚Üí ‚àÄ (d : ‚Ñï), ‚àÉ·∂† (m : ‚Ñï) in Filter.atTop, m ‚â° d [MOD n]",
    "name": "Nat.frequently_modEq",
    "doc": "Infinitely many natural numbers are equal to `d` mod `n`. ",
    "depth": 9},
   {"term": "‚àÄ {k : ‚Ñï}, k ‚â† 0 ‚Üí Set.Infinite {p | Nat.Prime p ‚àß p ‚â° 1 [MOD k]}",
    "name": "Nat.infinite_setOf_prime_modEq_one",
    "doc":
    "For any positive `k : ‚Ñï` there are infinitely many primes `p` such that `p ‚â° 1 [MOD k]`. ",
    "depth": 10},
   {"term": "‚àÄ {n a b : ‚Ñï}, a ‚â° b [MOD n] ‚Üí ‚Üën ‚à£ ‚Üëb - ‚Üëa",
    "name": "Nat.ModEq.dvd",
    "doc": "**Alias** of the forward direction of `Nat.modEq_iff_dvd`.",
    "depth": 11},
   {"term": "‚àÄ {x n : ‚Ñï}, Nat.coprime x n ‚Üí x ^ Nat.totient n ‚â° 1 [MOD n]",
    "name": "Nat.ModEq.pow_totient",
    "doc":
    "The **Fermat-Euler totient theorem**. `ZMod.pow_totient` is an alternative statement\nof the same theorem. ",
    "depth": 11},
   {"term": "‚àÄ {n a b : ‚Ñï}, ‚Üën ‚à£ ‚Üëb - ‚Üëa ‚Üí a ‚â° b [MOD n]",
    "name": "Nat.modEq_of_dvd",
    "doc": "**Alias** of the reverse direction of `Nat.modEq_iff_dvd`.",
    "depth": 11}],
  "count": 110},
 {"noDocExamples": [],
  "kind": "Submodule.¬´term_·óÆ¬ª",
  "examples":
  [{"term":
    "‚àÄ {ùïú : Type u_1} {E : Type u_2} [inst : IsROrC ùïú] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ùïú E]\n  {K : Submodule ùïú E} [inst_3 : CompleteSpace E], K·óÆ·óÆ·óÆ = K·óÆ",
    "name": "Submodule.triorthogonal_eq_orthogonal",
    "doc": "The orthogonal complement satisfies `K·óÆ·óÆ·óÆ = K·óÆ`. ",
    "depth": 20},
   {"term":
    "‚àÄ {ùïú : Type u_1} {E : Type u_2} [inst : IsROrC ùïú] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ùïú E]\n  (K : Submodule ùïú E) [inst_3 : HasOrthogonalProjection K], K·óÆ·óÆ = K",
    "name": "Submodule.orthogonal_orthogonal",
    "doc":
    "If `K` admits an orthogonal projection, then the orthogonal complement of its orthogonal\ncomplement is itself. ",
    "depth": 20},
   {"term":
    "‚àÄ {ùïú : Type u_1} {E : Type u_2} [inst : IsROrC ùïú] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ùïú E]\n  (K : Submodule ùïú E), IsClosed ‚ÜëK·óÆ",
    "name": "Submodule.isClosed_orthogonal",
    "doc": "The orthogonal complement of any submodule `K` is closed. ",
    "depth": 21},
   {"term":
    "‚àÄ {ùïú : Type u_1} {E : Type u_2} [inst : IsROrC ùïú] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ùïú E]\n  {v : Set E},\n  Orthonormal ùïú Subtype.val ‚Üí ((‚àÄ (u : Set E), u ‚äá v ‚Üí Orthonormal ùïú Subtype.val ‚Üí u = v) ‚Üî (Submodule.span ùïú v)·óÆ = ‚ä•)",
    "name": "maximal_orthonormal_iff_orthogonalComplement_eq_bot",
    "doc":
    "An orthonormal set in an `InnerProductSpace` is maximal, if and only if the orthogonal\ncomplement of its span is empty. ",
    "depth": 22},
   {"term":
    "‚àÄ {ùïú : Type u_1} {E : Type u_2} [inst : IsROrC ùïú] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ùïú E]\n  (K : Submodule ùïú E), K ‚äì K·óÆ = ‚ä•",
    "name": "Submodule.inf_orthogonal_eq_bot",
    "doc": "`K` and `K·óÆ` have trivial intersection. ",
    "depth": 22}],
  "count": 109},
 {"noDocExamples": [],
  "kind": "Int.¬´term‚åä_‚åã¬ª",
  "examples":
  [{"term": "‚àÄ (Œæ : ‚Ñù), Real.convergent Œæ 0 = ‚Üë‚åäŒæ‚åã",
    "name": "Real.convergent_zero",
    "doc": "The zeroth convergent of `Œæ` is `‚åäŒæ‚åã`. ",
    "depth": 7},
   {"term":
    "‚àÄ (Œæ : ‚Ñù) (n : ‚Ñï), Real.convergent Œæ (n + 1) = ‚Üë‚åäŒæ‚åã + (Real.convergent (Int.fract Œæ)‚Åª¬π n)‚Åª¬π",
    "name": "Real.convergent_succ",
    "doc":
    "The `(n+1)`th convergent of `Œæ` is the `n`th convergent of `1/(fract Œæ)`. ",
    "depth": 12},
   {"term":
    "‚àÄ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] {v : K},\n  (GeneralizedContinuedFraction.of v).h = ‚Üë‚åäv‚åã",
    "name": "GeneralizedContinuedFraction.of_h_eq_floor",
    "doc": "The head term of the gcf of `v` is `‚åäv‚åã`. ",
    "depth": 13},
   {"term":
    "‚àÄ {Œ± : Type u_2} [inst : LinearOrderedRing Œ±] [inst_1 : FloorRing Œ±] {a : Œ±}, 0 < Int.fract a ‚Üî a ‚â† ‚Üë‚åäa‚åã",
    "name": "Int.fract_pos",
    "doc": "The fractional part of `a` is positive if and only if `a ‚â† ‚åäa‚åã`. ",
    "depth": 16},
   {"term":
    "‚àÄ {Œæ q : ‚Ñö}, |Œæ - q| < 1 / ‚Üëq.den ^ 2 ‚Üí q.den ‚â§ Œæ.den ‚àß ‚åàŒæ * ‚Üëq.den‚åâ - 1 ‚â§ q.num ‚àß q.num ‚â§ ‚åäŒæ * ‚Üëq.den‚åã + 1",
    "name": "Rat.den_le_and_le_num_le_of_sub_lt_one_div_den_sq",
    "doc":
    "If `Œæ` is rational, then the good rational approximations to `Œæ` have bounded\nnumerator and denominator. ",
    "depth": 17}],
  "count": 106},
 {"noDocExamples": [],
  "kind": "¬´term‚Ñö_[_]¬ª",
  "examples":
  [{"term": "{p : ‚Ñï} ‚Üí [hp : Fact (Nat.Prime p)] ‚Üí ‚Ñö_[p] ‚Üí ‚Ñö",
    "name": "padicNormE.ratNorm",
    "doc":
    "`ratNorm q`, for a `p`-adic number `q` is the `p`-adic norm of `q`, as rational number.\n\nThe lemma `padicNormE.eq_ratNorm` asserts `‚Äñq‚Äñ = ratNorm q`. ",
    "depth": 5},
   {"term": "{p : ‚Ñï} ‚Üí [hp : Fact (Nat.Prime p)] ‚Üí ‚Ñö_[p] ‚Üí WithTop ‚Ñ§",
    "name": "Padic.addValuationDef",
    "doc":
    "The additive `p`-adic valuation on `‚Ñö_[p]`, with values in `WithTop ‚Ñ§`. ",
    "depth": 5},
   {"term": "{p : ‚Ñï} ‚Üí [hp : Fact (Nat.Prime p)] ‚Üí ‚Ñö_[p] ‚Üí ‚Ñ§",
    "name": "Padic.valuation",
    "doc":
    "`Padic.valuation` lifts the `p`-adic valuation on rationals to `‚Ñö_[p]`. ",
    "depth": 5},
   {"term": "{p : ‚Ñï} ‚Üí [inst : Fact (Nat.Prime p)] ‚Üí PadicSeq p ‚Üí ‚Ñö_[p]",
    "name": "Padic.mk",
    "doc": "Builds the equivalence class of a Cauchy sequence of rationals. ",
    "depth": 5},
   {"term": "(p : ‚Ñï) ‚Üí [inst : Fact (Nat.Prime p)] ‚Üí Subring ‚Ñö_[p]",
    "name": "PadicInt.subring",
    "doc": "The `p`-adic integers as a subring of `‚Ñö_[p]`. ",
    "depth": 6}],
  "count": 102},
 {"noDocExamples": [],
  "kind": "¬´term‚à´_In_.._,_‚àÇ_¬ª",
  "examples":
  [{"term":
    "‚àÄ {E : Type u_3} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] {f g : ‚Ñù ‚Üí E} {Œº : MeasureTheory.Measure ‚Ñù}\n  {a b : ‚Ñù}, Set.EqOn f g (Set.uIcc a b) ‚Üí ‚à´ (x : ‚Ñù) in a..b, f x ‚àÇŒº = ‚à´ (x : ‚Ñù) in a..b, g x ‚àÇŒº",
    "name": "intervalIntegral.integral_congr",
    "doc":
    "If two functions are equal in the relevant interval, their interval integrals are also equal. ",
    "depth": 18},
   {"term":
    "‚àÄ {f : ‚Ñù ‚Üí ‚Ñù} {a b : ‚Ñù} {Œº : MeasureTheory.Measure ‚Ñù},\n  0 ‚â§·∂†[MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict Œº (Œô a b))] f ‚Üí\n    IntervalIntegrable f Œº a b ‚Üí (0 < ‚à´ (x : ‚Ñù) in a..b, f x ‚àÇŒº ‚Üî a < b ‚àß 0 < ‚Üë‚ÜëŒº (Function.support f ‚à© Set.Ioc a b))",
    "name": "intervalIntegral.integral_pos_iff_support_of_nonneg_ae'",
    "doc":
    "If `f` is nonnegative and integrable on the unordered interval `Set.uIoc a b`, then its\nintegral over `a..b` is positive if and only if `a < b` and the measure of\n`Function.support f ‚à© Set.Ioc a b` is positive. ",
    "depth": 19},
   {"term":
    "‚àÄ {f : ‚Ñù ‚Üí ‚Ñù} {a b : ‚Ñù} {Œº : MeasureTheory.Measure ‚Ñù},\n  0 ‚â§·∂†[MeasureTheory.Measure.ae Œº] f ‚Üí\n    IntervalIntegrable f Œº a b ‚Üí (0 < ‚à´ (x : ‚Ñù) in a..b, f x ‚àÇŒº ‚Üî a < b ‚àß 0 < ‚Üë‚ÜëŒº (Function.support f ‚à© Set.Ioc a b))",
    "name": "intervalIntegral.integral_pos_iff_support_of_nonneg_ae",
    "doc":
    "If `f` is nonnegative a.e.-everywhere and it is integrable on the unordered interval\n`Set.uIoc a b`, then its integral over `a..b` is positive if and only if `a < b` and the\nmeasure of `Function.support f ‚à© Set.Ioc a b` is positive. ",
    "depth": 19},
   {"term":
    "‚àÄ {E : Type u_3} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] {a b‚ÇÅ b‚ÇÇ : ‚Ñù} {Œº : MeasureTheory.Measure ‚Ñù}\n  {f : ‚Ñù ‚Üí E} [inst_2 : MeasureTheory.NoAtoms Œº],\n  IntervalIntegrable f Œº b‚ÇÅ b‚ÇÇ ‚Üí a ‚àà Set.uIcc b‚ÇÅ b‚ÇÇ ‚Üí ContinuousOn (fun b => ‚à´ (x : ‚Ñù) in a..b, f x ‚àÇŒº) (Set.uIcc b‚ÇÅ b‚ÇÇ)",
    "name": "intervalIntegral.continuousOn_primitive_interval'",
    "doc":
    "Note: this assumes that `f` is `IntervalIntegrable`, in contrast to some other lemmas here. ",
    "depth": 21},
   {"term":
    "‚àÄ {f g : ‚Ñù ‚Üí ‚Ñù} {a b : ‚Ñù} {Œº : MeasureTheory.Measure ‚Ñù},\n  a ‚â§ b ‚Üí\n    IntervalIntegrable f Œº a b ‚Üí\n      IntervalIntegrable g Œº a b ‚Üí\n        f ‚â§·∂†[MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict Œº (Set.Ioc a b))] g ‚Üí\n          ‚Üë‚Üë(MeasureTheory.Measure.restrict Œº (Set.Ioc a b)) {x | f x < g x} ‚â† 0 ‚Üí\n            ‚à´ (x : ‚Ñù) in a..b, f x ‚àÇŒº < ‚à´ (x : ‚Ñù) in a..b, g x ‚àÇŒº",
    "name":
    "intervalIntegral.integral_lt_integral_of_ae_le_of_measure_setOf_lt_ne_zero",
    "doc":
    "If `f` and `g` are two functions that are interval integrable on `a..b`, `a ‚â§ b`,\n`f x ‚â§ g x` for a.e. `x ‚àà Set.Ioc a b`, and `f x < g x` on a subset of `Set.Ioc a b`\nof nonzero measure, then `‚à´ x in a..b, f x ‚àÇŒº < ‚à´ x in a..b, g x ‚àÇŒº`. ",
    "depth": 22}],
  "count": 101},
 {"noDocExamples": [],
  "kind": "¬´term_√ó'_¬ª",
  "examples":
  [{"term":
    "{Œ± : Type u_2} ‚Üí (Œ≤ : Œ± ‚Üí Type u_1) ‚Üí (i : Œ±) √ó' Œ≤ i ‚âÉ (i : Œ±) √ó Œ≤ i",
    "name": "Equiv.psigmaEquivSigma",
    "doc": "A `PSigma`-type is equivalent to the corresponding `Sigma`-type. ",
    "depth": 7},
   {"term": "{Œ± : Type v} ‚Üí (P : Œ± ‚Üí Prop) ‚Üí (i : Œ±) √ó' P i ‚âÉ Subtype P",
    "name": "Equiv.psigmaEquivSubtype",
    "doc": "A `PSigma` with `Prop` fibers is equivalent to the subtype.  ",
    "depth": 7},
   {"term":
    "(G : Type u_1) ‚Üí [inst : Group G] ‚Üí ‚Ñï ‚Üí (H : Subgroup G) √ó' Subgroup.Normal H",
    "name": "upperCentralSeriesAux",
    "doc":
    "An auxiliary type-theoretic definition defining both the upper central series of\na group, and a proof that it is normal, all in one go. ",
    "depth": 8},
   {"term":
    "{Œ± : Type u_4} ‚Üí [inst : Fintype Œ±] ‚Üí {P : Œ± ‚Üí Prop} ‚Üí [inst : DecidablePred P] ‚Üí (‚àÉ a, P a) ‚Üí Trunc ((a : Œ±) √ó' P a)",
    "name": "truncSigmaOfExists",
    "doc":
    "By iterating over the elements of a fintype, we can lift an existential statement `‚àÉ a, P a`\nto `Trunc (Œ£' a, P a)`, containing data.\n",
    "depth": 9},
   {"term":
    "{Œ± : Sort u_2} ‚Üí (Œ≤ : Œ± ‚Üí Sort u_1) ‚Üí (i : Œ±) √ó' Œ≤ i ‚âÉ (i : PLift Œ±) √ó PLift (Œ≤ i.down)",
    "name": "Equiv.psigmaEquivSigmaPLift",
    "doc": "A `PSigma`-type is equivalent to the corresponding `Sigma`-type. ",
    "depth": 9}],
  "count": 101},
 {"noDocExamples": [],
  "kind": "¬´term_‚âÉr_¬ª",
  "examples":
  [{"term": "{Œ± : Type u_1} ‚Üí (r : Œ± ‚Üí Œ± ‚Üí Prop) ‚Üí r ‚âÉr r",
    "name": "RelIso.refl",
    "doc": "Identity map is a relation isomorphism. ",
    "depth": 6},
   {"term":
    "{Œ± : Type u_1} ‚Üí {Œ≤ : Type u_2} ‚Üí {r : Œ± ‚Üí Œ± ‚Üí Prop} ‚Üí {s : Œ≤ ‚Üí Œ≤ ‚Üí Prop} ‚Üí r ‚âÉr s ‚Üí r ‚Ü™r s",
    "name": "RelIso.toRelEmbedding",
    "doc":
    "Convert a `RelIso` to a `RelEmbedding`. This function is also available as a coercion\nbut often it is easier to write `f.toRelEmbedding` than to write explicitly `r` and `s`\nin the target type. ",
    "depth": 9},
   {"term":
    "{Œ± : Type u_1} ‚Üí {Œ≤ : Type u_2} ‚Üí {r : Œ± ‚Üí Œ± ‚Üí Prop} ‚Üí {s : Œ≤ ‚Üí Œ≤ ‚Üí Prop} ‚Üí r ‚âÉr s ‚Üí r ‚âºi s",
    "name": "InitialSeg.ofIso",
    "doc": "An order isomorphism is an initial segment ",
    "depth": 9},
   {"term":
    "{Œ± : Type u_1} ‚Üí {Œ≤ : Type u_2} ‚Üí {r : Œ± ‚Üí Œ± ‚Üí Prop} ‚Üí {s : Œ≤ ‚Üí Œ≤ ‚Üí Prop} ‚Üí r ‚âÉr s ‚Üí s ‚âÉr r",
    "name": "RelIso.symm",
    "doc": "Inverse map of a relation isomorphism is a relation isomorphism. ",
    "depth": 9},
   {"term":
    "{Œ± : Type u_1} ‚Üí {Œ≤ : Type u_2} ‚Üí {r : Œ± ‚Üí Œ± ‚Üí Prop} ‚Üí {s : Œ≤ ‚Üí Œ≤ ‚Üí Prop} ‚Üí r ‚âÉr s ‚Üí Œ≤ ‚Üí Œ±",
    "name": "RelIso.Simps.symm_apply",
    "doc": "See Note [custom simps projection]. ",
    "depth": 9}],
  "count": 97},
 {"noDocExamples": [],
  "kind": "FirstOrder.Language.¬´term_‚Üí·¥∏_¬ª",
  "examples":
  [{"term": "(L : FirstOrder.Language) ‚Üí L ‚Üí·¥∏ L",
    "name": "FirstOrder.Language.LHom.id",
    "doc": "The identity language homomorphism. ",
    "depth": 3},
   {"term":
    "(L : FirstOrder.Language) ‚Üí [inst : FirstOrder.Language.IsOrdered L] ‚Üí FirstOrder.Language.order ‚Üí·¥∏ L",
    "name": "FirstOrder.Language.orderLHom",
    "doc":
    "The language homomorphism sending the unique symbol `‚â§` of `Language.order` to `‚â§` in an ordered\nlanguage. ",
    "depth": 4},
   {"term":
    "{L : FirstOrder.Language} ‚Üí {L' : FirstOrder.Language} ‚Üí (L ‚Üí·¥∏ L') ‚Üí Prop",
    "name": "FirstOrder.Language.LHom.Injective",
    "doc":
    "A language homomorphism is injective when all the maps between symbol types are. ",
    "depth": 5},
   {"term":
    "{L : FirstOrder.Language} ‚Üí\n  {L' : FirstOrder.Language} ‚Üí (L ‚Üí·¥∏ L') ‚Üí FirstOrder.Language.Theory L ‚Üí FirstOrder.Language.Theory L'",
    "name": "FirstOrder.Language.LHom.onTheory",
    "doc": "Maps a theory's symbols along a language map. ",
    "depth": 5},
   {"term":
    "{L : FirstOrder.Language} ‚Üí {L' : FirstOrder.Language} ‚Üí L ‚Üí·¥∏ FirstOrder.Language.sum L L'",
    "name": "FirstOrder.Language.LHom.sumInl",
    "doc": "The inclusion of the left factor into the sum of two languages. ",
    "depth": 5}],
  "count": 96},
 {"noDocExamples": [],
  "kind": "Set.¬´term‚ãÇ‚ÇÄ_¬ª",
  "examples":
  [{"term":
    "‚àÄ {Œ± : Type u_2} {l : Filter Œ±} [inst : Filter.IsCountablyGenerated l], Filter.cofinite ‚â§ l ‚Üí Set.Countable (‚ãÇ‚ÇÄ l.sets)·∂ú",
    "name": "Filter.countable_compl_sInter_sets",
    "doc":
    "If `l ‚â• Filter.cofinite` is a countably generated filter, then `‚ãÇ‚ÇÄ l.sets` is cocountable. ",
    "depth": 11},
   {"term":
    "‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] {S : Set (Set Œ±)},\n  (‚àÄ (s : Set Œ±), s ‚àà S ‚Üí IsGŒ¥ s) ‚Üí Set.Countable S ‚Üí IsGŒ¥ (‚ãÇ‚ÇÄ S)",
    "name": "isGŒ¥_sInter",
    "doc": "A countable intersection of GŒ¥ sets is a GŒ¥ set. ",
    "depth": 12},
   {"term":
    "‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_3} {f : Œ± ‚Üí Œ≤} {l : Filter Œ≤} [inst : Filter.IsCountablyGenerated l],\n  Filter.Tendsto f Filter.cofinite l ‚Üí Set.Countable (f ‚Åª¬π' ‚ãÇ‚ÇÄ l.sets)·∂ú",
    "name": "Filter.Tendsto.countable_compl_preimage_sInter_sets",
    "doc":
    "If `f` tends to a countably generated filter `l` along `Filter.cofinite`,\nthen for all but countably many elements, `f x ‚àà ‚ãÇ‚ÇÄ l.sets`. ",
    "depth": 12},
   {"term":
    "‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [self : AlexandrovDiscrete Œ±] (s : Set (Set Œ±)),\n  (‚àÄ (t : Set Œ±), t ‚àà s ‚Üí IsOpen t) ‚Üí IsOpen (‚ãÇ‚ÇÄ s)",
    "name": "AlexandrovDiscrete.isOpen_sInter",
    "doc":
    "The intersection of a family of open sets is an open set. Use `isOpen_sInter` in the root\nnamespace instead. ",
    "depth": 13},
   {"term":
    "‚àÄ {Œ± : Type u_2} {l : Filter Œ±} [self : CountableInterFilter l] (S : Set (Set Œ±)),\n  Set.Countable S ‚Üí (‚àÄ (s : Set Œ±), s ‚àà S ‚Üí s ‚àà l) ‚Üí ‚ãÇ‚ÇÄ S ‚àà l",
    "name": "CountableInterFilter.countable_sInter_mem",
    "doc":
    "For a countable collection of sets `s ‚àà l`, their intersection belongs to `l` as well. ",
    "depth": 14}],
  "count": 95},
 {"noDocExamples": [],
  "kind": "¬´term_‚Üí‚ãÜ‚Çê[_]_¬ª",
  "examples":
  [{"term":
    "(R : Type u_2) ‚Üí\n  (A : Type u_3) ‚Üí\n    [inst : CommSemiring R] ‚Üí [inst_1 : Semiring A] ‚Üí [inst_2 : Algebra R A] ‚Üí [inst_3 : Star A] ‚Üí A ‚Üí‚ãÜ‚Çê[R] A",
    "name": "StarAlgHom.id",
    "doc": "The identity as a `StarAlgHom`. ",
    "depth": 16},
   {"term":
    "{R : Type u_2} ‚Üí\n  {A : Type u_3} ‚Üí\n    {B : Type u_4} ‚Üí\n      [inst : CommSemiring R] ‚Üí\n        [inst_1 : Semiring A] ‚Üí\n          [inst_2 : Algebra R A] ‚Üí\n            [inst_3 : Star A] ‚Üí\n              [inst_4 : Semiring B] ‚Üí [inst_5 : Algebra R B] ‚Üí [inst_6 : Star B] ‚Üí (A ‚Üí‚ãÜ‚Çê[R] B) ‚Üí A ‚Üí B",
    "name": "StarAlgHom.Simps.apply",
    "doc": "See Note [custom simps projection] ",
    "depth": 21},
   {"term":
    "{R : Type u_1} ‚Üí\n  {A : Type u_2} ‚Üí\n    {B : Type u_3} ‚Üí\n      [inst : CommSemiring R] ‚Üí\n        [inst_1 : Semiring A] ‚Üí\n          [inst_2 : Algebra R A] ‚Üí\n            [inst_3 : Star A] ‚Üí\n              [inst_4 : Semiring B] ‚Üí [inst_5 : Algebra R B] ‚Üí [inst_6 : Star B] ‚Üí (A ‚Üí‚ãÜ‚Çê[R] B) ‚Üí A ‚Üí‚Çê[R] B",
    "name": "StarAlgHom.toAlgHom",
    "doc":
    "Reinterpret a unital star algebra homomorphism as a unital algebra homomorphism\nby forgetting the interaction with the star operation. ",
    "depth": 21},
   {"term":
    "{R : Type u_2} ‚Üí\n  {A : Type u_3} ‚Üí\n    {B : Type u_4} ‚Üí\n      [inst : CommSemiring R] ‚Üí\n        [inst_1 : Semiring A] ‚Üí\n          [inst_2 : Algebra R A] ‚Üí\n            [inst_3 : Star A] ‚Üí\n              [inst_4 : Semiring B] ‚Üí [inst_5 : Algebra R B] ‚Üí [inst_6 : Star B] ‚Üí (A ‚Üí‚ãÜ‚Çê[R] B) ‚Üí A ‚Üí‚ãÜ‚Çô‚Çê[R] B",
    "name": "StarAlgHom.toNonUnitalStarAlgHom",
    "doc": "A unital morphism of ‚ãÜ-algebras is a `NonUnitalStarAlgHom`. ",
    "depth": 22},
   {"term":
    "(R : Type u_1) ‚Üí\n  (A : Type u_2) ‚Üí\n    (B : Type u_3) ‚Üí\n      [inst : CommSemiring R] ‚Üí\n        [inst_1 : Semiring A] ‚Üí\n          [inst_2 : Algebra R A] ‚Üí\n            [inst_3 : Star A] ‚Üí [inst_4 : Semiring B] ‚Üí [inst_5 : Algebra R B] ‚Üí [inst_6 : Star B] ‚Üí A √ó B ‚Üí‚ãÜ‚Çê[R] B",
    "name": "StarAlgHom.snd",
    "doc": "The second projection of a product is a ‚ãÜ-algebra homomorphism. ",
    "depth": 23}],
  "count": 95},
 {"noDocExamples": [],
  "kind": "¬´term_‚âÉ·µÉ[_]_¬ª",
  "examples":
  [{"term":
    "(k : Type u_1) ‚Üí\n  (P‚ÇÅ : Type u_2) ‚Üí\n    {V‚ÇÅ : Type u_6} ‚Üí\n      [inst : Ring k] ‚Üí [inst_1 : AddCommGroup V‚ÇÅ] ‚Üí [inst_2 : Module k V‚ÇÅ] ‚Üí [inst_3 : AddTorsor V‚ÇÅ P‚ÇÅ] ‚Üí P‚ÇÅ ‚âÉ·µÉ[k] P‚ÇÅ",
    "name": "AffineEquiv.refl",
    "doc": "Identity map as an `AffineEquiv`. ",
    "depth": 19},
   {"term":
    "(k : Type u_1) ‚Üí\n  {P‚ÇÅ : Type u_2} ‚Üí\n    {V‚ÇÅ : Type u_6} ‚Üí\n      [inst : Ring k] ‚Üí\n        [inst_1 : AddCommGroup V‚ÇÅ] ‚Üí [inst_2 : Module k V‚ÇÅ] ‚Üí [inst_3 : AddTorsor V‚ÇÅ P‚ÇÅ] ‚Üí P‚ÇÅ ‚Üí V‚ÇÅ ‚âÉ·µÉ[k] P‚ÇÅ",
    "name": "AffineEquiv.vaddConst",
    "doc":
    "The map `v ‚Ü¶ v +·µ• b` as an affine equivalence between a module `V` and an affine space `P` with\ntangent space `V`. ",
    "depth": 20},
   {"term":
    "(k : Type u_1) ‚Üí\n  (P‚ÇÅ : Type u_2) ‚Üí\n    {V‚ÇÅ : Type u_6} ‚Üí\n      [inst : Ring k] ‚Üí\n        [inst_1 : AddCommGroup V‚ÇÅ] ‚Üí [inst_2 : Module k V‚ÇÅ] ‚Üí [inst_3 : AddTorsor V‚ÇÅ P‚ÇÅ] ‚Üí V‚ÇÅ ‚Üí P‚ÇÅ ‚âÉ·µÉ[k] P‚ÇÅ",
    "name": "AffineEquiv.constVAdd",
    "doc":
    "The map `p ‚Ü¶ v +·µ• p` as an affine automorphism of an affine space.\n\nNote that there is no need for an `AffineMap.constVAdd` as it is always an equivalence.\nThis is roughly to `DistribMulAction.toLinearEquiv` as `+·µ•` is to `‚Ä¢`. ",
    "depth": 20},
   {"term":
    "(k : Type u_1) ‚Üí\n  {P‚ÇÅ : Type u_2} ‚Üí\n    {V‚ÇÅ : Type u_6} ‚Üí\n      [inst : Ring k] ‚Üí\n        [inst_1 : AddCommGroup V‚ÇÅ] ‚Üí [inst_2 : Module k V‚ÇÅ] ‚Üí [inst_3 : AddTorsor V‚ÇÅ P‚ÇÅ] ‚Üí P‚ÇÅ ‚Üí P‚ÇÅ ‚âÉ·µÉ[k] V‚ÇÅ",
    "name": "AffineEquiv.constVSub",
    "doc": "`p' ‚Ü¶ p -·µ• p'` as an equivalence. ",
    "depth": 20},
   {"term":
    "(k : Type u_1) ‚Üí\n  {P‚ÇÅ : Type u_2} ‚Üí\n    {V‚ÇÅ : Type u_6} ‚Üí\n      [inst : Ring k] ‚Üí\n        [inst_1 : AddCommGroup V‚ÇÅ] ‚Üí [inst_2 : Module k V‚ÇÅ] ‚Üí [inst_3 : AddTorsor V‚ÇÅ P‚ÇÅ] ‚Üí P‚ÇÅ ‚Üí P‚ÇÅ ‚âÉ·µÉ[k] P‚ÇÅ",
    "name": "AffineEquiv.pointReflection",
    "doc": "Point reflection in `x` as a permutation. ",
    "depth": 20}],
  "count": 95},
 {"noDocExamples":
  [{"term": "(!true) = false", "name": "Bool.not_true", "depth": 3}],
  "kind": "term!_",
  "examples":
  [{"term":
    "‚àÄ {Œ± : Type u} {L : List (Œ± √ó Bool)} {x : Œ±} {b : Bool},\n  FreeAddGroup.Red ((x, b) :: L) [] ‚Üî FreeAddGroup.Red L [(x, !b)]",
    "name": "FreeAddGroup.Red.cons_nil_iff_singleton",
    "doc":
    "If `x` is a letter and `w` is a word such that `x + w` reduces to the empty word, then `w`\nreduces to `-x`.",
    "depth": 14},
   {"term":
    "‚àÄ {Œ± : Type u} {L : List (Œ± √ó Bool)} {x : Œ±} {b : Bool}, FreeGroup.Red ((x, b) :: L) [] ‚Üî FreeGroup.Red L [(x, !b)]",
    "name": "FreeGroup.Red.cons_nil_iff_singleton",
    "doc":
    "If `x` is a letter and `w` is a word such that `xw` reduces to the empty word, then `w` reduces\nto `x‚Åª¬π` ",
    "depth": 14},
   {"term":
    "‚àÄ {Œ± : Type u} {L‚ÇÅ L‚ÇÇ : List (Œ± √ó Bool)} {x1 : Œ±} {b1 : Bool} {x2 : Œ±} {b2 : Bool},\n  (x1, b1) ‚â† (x2, b2) ‚Üí FreeGroup.Red ((x1, b1) :: L‚ÇÅ) ((x2, b2) :: L‚ÇÇ) ‚Üí FreeGroup.Red L‚ÇÅ ((x1, !b1) :: (x2, b2) :: L‚ÇÇ)",
    "name": "FreeGroup.Red.inv_of_red_of_ne",
    "doc":
    "If `x` and `y` are distinct letters and `w‚ÇÅ w‚ÇÇ` are words such that `xw‚ÇÅ` reduces to `yw‚ÇÇ`, then\n`w‚ÇÅ` reduces to `x‚Åª¬πyw‚ÇÇ`. ",
    "depth": 17},
   {"term":
    "‚àÄ {Œ± : Type u} {L‚ÇÅ L‚ÇÇ : List (Œ± √ó Bool)} {x1 : Œ±} {b1 : Bool} {x2 : Œ±} {b2 : Bool},\n  (x1, b1) ‚â† (x2, b2) ‚Üí\n    FreeAddGroup.Red ((x1, b1) :: L‚ÇÅ) ((x2, b2) :: L‚ÇÇ) ‚Üí FreeAddGroup.Red L‚ÇÅ ((x1, !b1) :: (x2, b2) :: L‚ÇÇ)",
    "name": "FreeAddGroup.Red.neg_of_red_of_ne",
    "doc":
    "If `x` and `y` are distinct letters and `w‚ÇÅ w‚ÇÇ` are words such that `x + w‚ÇÅ` reduces\nto `y + w‚ÇÇ`, then `w‚ÇÅ` reduces to `-x + y + w‚ÇÇ`.",
    "depth": 17}],
  "count": 94},
 {"noDocExamples": [],
  "kind": "Lean.Parser.Term.subst",
  "examples":
  [{"term":
    "{Œ± : Sort u_1} ‚Üí\n  {C : Trunc Œ± ‚Üí Sort u_3} ‚Üí\n    (f : (a : Œ±) ‚Üí C (Trunc.mk a)) ‚Üí (‚àÄ (a b : Œ±), (_ : Trunc.mk a = Trunc.mk b) ‚ñ∏ f a = f b) ‚Üí (q : Trunc Œ±) ‚Üí C q",
    "name": "Trunc.rec",
    "doc": "Recursion/induction principle for `Trunc`. ",
    "depth": 15},
   {"term":
    "{Œ± : Sort u} ‚Üí\n  {s : Setoid Œ±} ‚Üí\n    {motive : Quotient s ‚Üí Sort v} ‚Üí\n      (f : (a : Œ±) ‚Üí motive (Quotient.mk s a)) ‚Üí\n        (‚àÄ (a b : Œ±) (p : a ‚âà b), (_ : Quotient.mk s a = Quotient.mk s b) ‚ñ∏ f a = f b) ‚Üí (q : Quotient s) ‚Üí motive q",
    "name": "Quotient.rec",
    "doc": "The analogue of `Quot.rec` for `Quotient`. See `Quot.rec`. ",
    "depth": 18},
   {"term":
    "{Œ± : Sort u} ‚Üí\n  {r : Œ± ‚Üí Œ± ‚Üí Prop} ‚Üí\n    {motive : Quot r ‚Üí Sort v} ‚Üí\n      (f : (a : Œ±) ‚Üí motive (Quot.mk r a)) ‚Üí\n        (‚àÄ (a b : Œ±) (p : r a b), (_ : Quot.mk r a = Quot.mk r b) ‚ñ∏ f a = f b) ‚Üí (q : Quot r) ‚Üí motive q",
    "name": "Quot.rec",
    "doc":
    "Dependent recursion principle for `Quot`. This constructor can be tricky to use,\nso you should consider the simpler versions if they apply:\n* `Quot.lift`, for nondependent functions\n* `Quot.ind`, for theorems / proofs of propositions about quotients\n* `Quot.recOnSubsingleton`, when the target type is a `Subsingleton`\n* `Quot.hrecOn`, which uses `HEq (f a) (f b)` instead of a `sound p ‚ñ∏ f a = f b` assummption\n",
    "depth": 18},
   {"term":
    "{Œ± : Sort u} ‚Üí\n  {r : Œ± ‚Üí Œ± ‚Üí Prop} ‚Üí\n    {motive : Quot r ‚Üí Sort v} ‚Üí\n      (q : Quot r) ‚Üí\n        (f : (a : Œ±) ‚Üí motive (Quot.mk r a)) ‚Üí\n          (‚àÄ (a b : Œ±) (p : r a b), (_ : Quot.mk r a = Quot.mk r b) ‚ñ∏ f a = f b) ‚Üí motive q",
    "name": "Quot.recOn'",
    "doc":
    "Dependent recursion principle for `Quot`. This constructor can be tricky to use,\nso you should consider the simpler versions if they apply:\n* `Quot.lift`, for nondependent functions\n* `Quot.ind`, for theorems / proofs of propositions about quotients\n* `Quot.recOnSubsingleton`, when the target type is a `Subsingleton`\n* `Quot.hrecOn`, which uses `HEq (f a) (f b)` instead of a `sound p ‚ñ∏ f a = f b` assummption\n",
    "depth": 19},
   {"term":
    "‚àÄ {Œ± : Sort u_2} {Œ≤ : Sort u_3} (P : Œ± ‚Üí Sort u_1) (e : Œ± ‚âÉ Œ≤) (f : (b : Œ≤) ‚Üí P (‚Üëe.symm b)) (x : Œ±),\n  ‚Üë(Equiv.piCongrLeft' P e).symm f x = (_ : ‚Üëe.symm (‚Üëe x) = x) ‚ñ∏ f (‚Üëe x)",
    "name": "Equiv.piCongrLeft'_symm_apply",
    "doc":
    "Note: the \"obvious\" statement `(piCongrLeft' P e).symm g a = g (e a)` doesn't typecheck: the\nLHS would have type `P a` while the RHS would have type `P (e.symm (e a))`. For that reason,\nwe have to explicitly substitute along `e.symm (e a) = a` in the statement of this lemma. ",
    "depth": 27}],
  "count": 93},
 {"noDocExamples":
  [{"term":
    "‚àÄ {Œ± : Type u} (c : Computation (Stream'.WSeq Œ±)),\n  Stream'.WSeq.destruct (Stream'.WSeq.flatten c) = c >>= Stream'.WSeq.destruct",
    "name": "Stream'.WSeq.destruct_flatten",
    "depth": 9}],
  "kind": "¬´term_>>=_¬ª",
  "examples":
  [{"term":
    "{Œ± Œ≤ : Type u_1} ‚Üí\n  [inst : DecidableEq Œ≤] ‚Üí\n    (s : Set Œ±) ‚Üí [inst : Fintype ‚Üës] ‚Üí (f : Œ± ‚Üí Set Œ≤) ‚Üí ((a : Œ±) ‚Üí a ‚àà s ‚Üí Fintype ‚Üë(f a)) ‚Üí Fintype ‚Üë(s >>= f)",
    "name": "Set.fintypeBind",
    "doc":
    "If `s : Set Œ±` is a set with `Fintype` instance and `f : Œ± ‚Üí Set Œ≤` is a function such that\neach `f a`, `a ‚àà s`, has a `Fintype` structure, then `s >>= f` has a `Fintype` structure. ",
    "depth": 16},
   {"term":
    "‚àÄ {m : Type u_1 ‚Üí Type u_2} {Œ± Œ≤ : Type u_1} {q : Œ≤ ‚Üí Prop} {x : m Œ±} [inst : Monad m] [inst_1 : LawfulMonad m]\n  {f : Œ± ‚Üí m Œ≤}, SatisfiesM (fun a => SatisfiesM q (f a)) x ‚Üí SatisfiesM q (x >>= f)",
    "name": "SatisfiesM.bind_pre",
    "doc":
    "`SatisfiesM` distributes over `>>=`, weakest precondition version. ",
    "depth": 18},
   {"term":
    "‚àÄ {m : Type u_1 ‚Üí Type u_2} {Œ± Œ≤ : Type u_1} {p : Œ± ‚Üí Prop} {x : m Œ±} {q : Œ≤ ‚Üí Prop} [inst : Monad m]\n  [inst_1 : LawfulMonad m] {f : Œ± ‚Üí m Œ≤},\n  SatisfiesM p x ‚Üí (‚àÄ (a : Œ±), p a ‚Üí SatisfiesM q (f a)) ‚Üí SatisfiesM q (x >>= f)",
    "name": "SatisfiesM.bind",
    "doc": "`SatisfiesM` distributes over `>>=`, general version. ",
    "depth": 19},
   {"term":
    "‚àÄ (m : Type u ‚Üí Type v) [inst : Monad m],\n  (‚àÄ {Œ± : Type u} (x : m Œ±), id <$> x = x) ‚Üí\n    (‚àÄ {Œ± Œ≤ : Type u} (x : Œ±) (f : Œ± ‚Üí m Œ≤), pure x >>= f = f x) ‚Üí\n      (‚àÄ {Œ± Œ≤ Œ≥ : Type u} (x : m Œ±) (f : Œ± ‚Üí m Œ≤) (g : Œ≤ ‚Üí m Œ≥), x >>= f >>= g = x >>= fun x => f x >>= g) ‚Üí\n        autoParam (‚àÄ {Œ± Œ≤ : Type u} (x : Œ±) (y : m Œ≤), Functor.mapConst x y = Function.const Œ≤ x <$> y) _auto‚úù ‚Üí\n          autoParam\n              (‚àÄ {Œ± Œ≤ : Type u} (x : m Œ±) (y : m Œ≤),\n                (SeqLeft.seqLeft x fun x => y) = do\n                  let a ‚Üê x\n                  let _ ‚Üê y\n                  pure a)\n              _auto‚úù¬π ‚Üí\n            autoParam\n                (‚àÄ {Œ± Œ≤ : Type u} (x : m Œ±) (y : m Œ≤),\n                  (SeqRight.seqRight x fun x => y) = do\n                    let _ ‚Üê x\n                    y)\n                _auto‚úù¬≤ ‚Üí\n              autoParam\n                  (‚àÄ {Œ± Œ≤ : Type u} (f : Œ± ‚Üí Œ≤) (x : m Œ±),\n                    (do\n                        let y ‚Üê x\n                        pure (f y)) =\n                      f <$> x)\n                  _auto‚úù¬≥ ‚Üí\n                autoParam\n                    (‚àÄ {Œ± Œ≤ : Type u} (f : m (Œ± ‚Üí Œ≤)) (x : m Œ±),\n                      (do\n                          let x_1 ‚Üê f\n                          x_1 <$> x) =\n                        Seq.seq f fun x_1 => x)\n                    _auto‚úù‚Å¥ ‚Üí\n                  LawfulMonad m",
    "name": "LawfulMonad.mk'",
    "doc":
    "An alternative constructor for `LawfulMonad` which has more\ndefaultable fields in the common case.\n",
    "depth": 28}],
  "count": 88},
 {"noDocExamples": [],
  "kind": "¬´term_‚ÜíA[_]_¬ª",
  "examples":
  [{"term":
    "{ùïú : Type u_1} ‚Üí\n  {V : Type u_3} ‚Üí\n    {W : Type u_4} ‚Üí\n      [inst : NormedAddCommGroup V] ‚Üí\n        [inst_1 : NormedAddCommGroup W] ‚Üí\n          [inst_2 : NontriviallyNormedField ùïú] ‚Üí\n            [inst_3 : NormedSpace ùïú V] ‚Üí [inst_4 : NormedSpace ùïú W] ‚Üí Norm (V ‚ÜíA[ùïú] W)",
    "name": "ContinuousAffineMap.hasNorm",
    "doc":
    "Note that unlike the operator norm for linear maps, this norm is _not_ submultiplicative:\nwe do _not_ necessarily have `‚Äñf.comp g‚Äñ ‚â§ ‚Äñf‚Äñ * ‚Äñg‚Äñ`. See `norm_comp_le` for what we can say. ",
    "depth": 23},
   {"term":
    "{R : Type u_1} ‚Üí\n  {V : Type u_2} ‚Üí\n    {W : Type u_3} ‚Üí\n      [inst : Ring R] ‚Üí\n        [inst_1 : AddCommGroup V] ‚Üí\n          [inst_2 : Module R V] ‚Üí\n            [inst_3 : TopologicalSpace V] ‚Üí\n              [inst_4 : AddCommGroup W] ‚Üí\n                [inst_5 : Module R W] ‚Üí [inst_6 : TopologicalSpace W] ‚Üí (V ‚ÜíL[R] W) ‚Üí V ‚ÜíA[R] W",
    "name": "ContinuousLinearMap.toContinuousAffineMap",
    "doc":
    "A continuous linear map can be regarded as a continuous affine map. ",
    "depth": 25},
   {"term":
    "{R : Type u_1} ‚Üí\n  {V : Type u_2} ‚Üí\n    {W : Type u_3} ‚Üí\n      {P : Type u_4} ‚Üí\n        {Q : Type u_5} ‚Üí\n          [inst : Ring R] ‚Üí\n            [inst_1 : AddCommGroup V] ‚Üí\n              [inst_2 : Module R V] ‚Üí\n                [inst_3 : TopologicalSpace P] ‚Üí\n                  [inst_4 : AddTorsor V P] ‚Üí\n                    [inst_5 : AddCommGroup W] ‚Üí\n                      [inst_6 : Module R W] ‚Üí\n                        [inst_7 : TopologicalSpace Q] ‚Üí [inst_8 : AddTorsor W Q] ‚Üí (P ‚ÜíA[R] Q) ‚Üí C(P, Q)",
    "name": "ContinuousAffineMap.toContinuousMap",
    "doc":
    "Forgetting its algebraic properties, a continuous affine map is a continuous map. ",
    "depth": 29},
   {"term":
    "(R : Type u_1) ‚Üí\n  {V : Type u_2} ‚Üí\n    {W : Type u_3} ‚Üí\n      (P : Type u_4) ‚Üí\n        {Q : Type u_5} ‚Üí\n          [inst : Ring R] ‚Üí\n            [inst_1 : AddCommGroup V] ‚Üí\n              [inst_2 : Module R V] ‚Üí\n                [inst_3 : TopologicalSpace P] ‚Üí\n                  [inst_4 : AddTorsor V P] ‚Üí\n                    [inst_5 : AddCommGroup W] ‚Üí\n                      [inst_6 : Module R W] ‚Üí [inst_7 : TopologicalSpace Q] ‚Üí [inst_8 : AddTorsor W Q] ‚Üí Q ‚Üí P ‚ÜíA[R] Q",
    "name": "ContinuousAffineMap.const",
    "doc": "The constant map is a continuous affine map. ",
    "depth": 29},
   {"term":
    "{R : Type u_1} ‚Üí\n  {V : Type u_2} ‚Üí\n    {W : Type u_3} ‚Üí\n      {P : Type u_4} ‚Üí\n        {Q : Type u_5} ‚Üí\n          [inst : Ring R] ‚Üí\n            [inst_1 : AddCommGroup V] ‚Üí\n              [inst_2 : Module R V] ‚Üí\n                [inst_3 : TopologicalSpace P] ‚Üí\n                  [inst_4 : AddTorsor V P] ‚Üí\n                    [inst_5 : AddCommGroup W] ‚Üí\n                      [inst_6 : Module R W] ‚Üí\n                        [inst_7 : TopologicalSpace Q] ‚Üí [inst_8 : AddTorsor W Q] ‚Üí CoeFun (P ‚ÜíA[R] Q) fun x => P ‚Üí Q",
    "name": "ContinuousAffineMap.instCoeFunContinuousAffineMapForAll",
    "doc":
    "Helper instance for when there's too many metavariables to apply\n`FunLike.hasCoeToFun` directly. ",
    "depth": 30}],
  "count": 86},
 {"noDocExamples":
  [{"term": "‚àÄ {X Y : Type u} {x : X} {y : Y}, (Œ≤_ X Y).hom (x, y) = (y, x)",
    "name": "CategoryTheory.braiding_hom_apply",
    "depth": 15},
   {"term": "‚àÄ {X Y : Type u} {x : X} {y : Y}, (Œ≤_ X Y).inv (y, x) = (x, y)",
    "name": "CategoryTheory.braiding_inv_apply",
    "depth": 15},
   {"term":
    "‚àÄ (C : Type u) [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Limits.HasTerminal C]\n  [inst_2 : CategoryTheory.Limits.HasBinaryProducts C] (X Y : C), Œ≤_ X Y = CategoryTheory.Limits.prod.braiding X Y",
    "name": "CategoryTheory.symmetricOfHasFiniteProducts_braiding",
    "depth": 17},
   {"term":
    "‚àÄ (C : Type u‚ÇÅ) [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] [inst_1 : CategoryTheory.MonoidalCategory C]\n  [inst_2 : CategoryTheory.BraidedCategory C] (X : C),\n  CategoryTheory.CategoryStruct.comp (Œ≤_ (CategoryTheory.MonoidalCategory.tensorUnit C) X).hom\n      (CategoryTheory.MonoidalCategory.rightUnitor X).hom =\n    (CategoryTheory.MonoidalCategory.leftUnitor X).hom",
    "name": "CategoryTheory.braiding_rightUnitor",
    "depth": 17}],
  "kind": "CategoryTheory.termŒ≤_",
  "examples":
  [{"term":
    "{C : Type u_1} ‚Üí\n  {D : Type u_2} ‚Üí\n    [inst : CategoryTheory.Category.{u_3, u_1} C] ‚Üí\n      [inst_1 : CategoryTheory.Category.{u_4, u_2} D] ‚Üí\n        [inst_2 : CategoryTheory.MonoidalCategory C] ‚Üí\n          [inst_3 : CategoryTheory.MonoidalCategory D] ‚Üí\n            (F : CategoryTheory.MonoidalFunctor C D) ‚Üí\n              [inst_4 : CategoryTheory.Faithful F.toFunctor] ‚Üí\n                [inst_5 : CategoryTheory.BraidedCategory D] ‚Üí\n                  (Œ≤ :\n                      (X Y : C) ‚Üí\n                        CategoryTheory.MonoidalCategory.tensorObj X Y ‚âÖ CategoryTheory.MonoidalCategory.tensorObj Y X) ‚Üí\n                    (‚àÄ (X Y : C),\n                        CategoryTheory.CategoryStruct.comp\n                            (CategoryTheory.LaxMonoidalFunctor.Œº F.toLaxMonoidalFunctor X Y) (F.map (Œ≤ X Y).hom) =\n                          CategoryTheory.CategoryStruct.comp (Œ≤_ (F.obj X) (F.obj Y)).hom\n                            (CategoryTheory.LaxMonoidalFunctor.Œº F.toLaxMonoidalFunctor Y X)) ‚Üí\n                      CategoryTheory.BraidedCategory C",
    "name": "CategoryTheory.braidedCategoryOfFaithful",
    "doc":
    "Verifying the axioms for a braiding by checking that the candidate braiding is sent to a braiding\nby a faithful monoidal functor.\n",
    "depth": 33}],
  "count": 82},
 {"noDocExamples": [],
  "kind": "¬´term_‚âÉ·µ§_¬ª",
  "examples":
  [{"term": "CompareReals.Bourbaki‚Ñù ‚âÉ·µ§ ‚Ñù",
    "name": "CompareReals.compareEquiv",
    "doc": "The uniform bijection between Bourbaki and Cauchy reals. ",
    "depth": 4},
   {"term": "(Œ± : Type u_4) ‚Üí [inst : UniformSpace Œ±] ‚Üí Œ± ‚âÉ·µ§ Œ±",
    "name": "UniformEquiv.refl",
    "doc": "Identity map as a uniform isomorphism. ",
    "depth": 6},
   {"term": "(Œ± : Type u) ‚Üí [inst : UniformSpace Œ±] ‚Üí ULift.{v, u} Œ± ‚âÉ·µ§ Œ±",
    "name": "UniformEquiv.ulift",
    "doc": "Uniform equivalence between `ULift Œ±` and `Œ±`. ",
    "depth": 7},
   {"term": "(Œ± : Type u) ‚Üí [inst : UniformSpace Œ±] ‚Üí Œ± √ó PUnit.{u_4 + 1} ‚âÉ·µ§ Œ±",
    "name": "UniformEquiv.prodPunit",
    "doc": "`Œ± √ó {*}` is uniformly isomorphic to `Œ±`. ",
    "depth": 8},
   {"term": "(Œ± : Type u) ‚Üí [inst : UniformSpace Œ±] ‚Üí PUnit.{u_4 + 1} √ó Œ± ‚âÉ·µ§ Œ±",
    "name": "UniformEquiv.punitProd",
    "doc": "`{*} √ó Œ±` is uniformly isomorphic to `Œ±`. ",
    "depth": 8}],
  "count": 82},
 {"noDocExamples": [],
  "kind": "FirstOrder.Language.¬´term_‚ä®__1¬ª",
  "examples":
  [{"term":
    "(V : Type w') ‚Üí\n  [inst : FirstOrder.Language.Structure FirstOrder.Language.graph V] ‚Üí\n    [inst : V ‚ä® FirstOrder.Language.Theory.simpleGraph] ‚Üí SimpleGraph V",
    "name": "FirstOrder.Language.simpleGraphOfStructure",
    "doc":
    "Any model of the theory of simple graphs represents a simple graph. ",
    "depth": 7},
   {"term":
    "{L : FirstOrder.Language} ‚Üí\n  (T : FirstOrder.Language.Theory L) ‚Üí\n    (M : Type w) ‚Üí\n      [inst : FirstOrder.Language.Structure L M] ‚Üí\n        [inst : M ‚ä® T] ‚Üí [inst : Nonempty M] ‚Üí FirstOrder.Language.Theory.ModelType T",
    "name": "FirstOrder.Language.Theory.ModelType.of",
    "doc":
    "The object in the category of R-algebras associated to a type equipped with the appropriate\ntypeclasses. ",
    "depth": 9},
   {"term":
    "{L : FirstOrder.Language} ‚Üí\n  {T : FirstOrder.Language.Theory L} ‚Üí\n    {M : Type w} ‚Üí\n      [LM : FirstOrder.Language.Structure L M] ‚Üí [ne : Nonempty M] ‚Üí M ‚ä® T ‚Üí FirstOrder.Language.Theory.ModelType T",
    "name": "FirstOrder.Language.Theory.Model.bundled",
    "doc": "Bundles `M ‚ä® T` as a `T.ModelType`. ",
    "depth": 10},
   {"term":
    "{L : FirstOrder.Language} ‚Üí\n  (T : FirstOrder.Language.Theory L) ‚Üí\n    (M : Type w') ‚Üí\n      [inst : FirstOrder.Language.Structure L M] ‚Üí\n        [inst_1 : Nonempty M] ‚Üí [inst : M ‚ä® T] ‚Üí (Œ± : Type w) ‚Üí Set (FirstOrder.Language.Theory.CompleteType T Œ±)",
    "name": "FirstOrder.Language.Theory.realizedTypes",
    "doc":
    "A complete type `p` is realized in a particular structure when there is some\ntuple `v` whose type is `p`. ",
    "depth": 11},
   {"term":
    "{L : FirstOrder.Language} ‚Üí\n  (T : FirstOrder.Language.Theory L) ‚Üí\n    {Œ± : Type w} ‚Üí\n      {M : Type w'} ‚Üí\n        [inst : FirstOrder.Language.Structure L M] ‚Üí\n          [inst_1 : Nonempty M] ‚Üí [inst : M ‚ä® T] ‚Üí (Œ± ‚Üí M) ‚Üí FirstOrder.Language.Theory.CompleteType T Œ±",
    "name": "FirstOrder.Language.Theory.typeOf",
    "doc":
    "The set of all formulas true at a tuple in a structure forms a complete type. ",
    "depth": 11}],
  "count": 81},
 {"noDocExamples": [],
  "kind": "CategoryTheory.Limits.¬´term_‚äû_¬ª",
  "examples":
  [{"term": "(G H : AddCommGroupCat) ‚Üí G ‚äû H ‚âÖ AddCommGroupCat.of (‚ÜëG √ó ‚ÜëH)",
    "name": "AddCommGroupCat.biprodIsoProd",
    "doc":
    "We verify that the biproduct in `AddCommGroupCat` is isomorphic to\nthe cartesian product of the underlying types:\n",
    "depth": 12},
   {"term":
    "{C : Type u} ‚Üí\n  [inst : CategoryTheory.Category.{v, u} C] ‚Üí\n    [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] ‚Üí\n      {X Y : C} ‚Üí [inst_2 : CategoryTheory.Limits.HasBinaryBiproduct X Y] ‚Üí Y ‚ü∂ X ‚äû Y",
    "name": "CategoryTheory.Limits.biprod.inr",
    "doc": "The inclusion into the second summand of a binary biproduct. ",
    "depth": 13},
   {"term":
    "{C : Type u} ‚Üí\n  [inst : CategoryTheory.Category.{v, u} C] ‚Üí\n    [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] ‚Üí\n      {X Y : C} ‚Üí [inst_2 : CategoryTheory.Limits.HasBinaryBiproduct X Y] ‚Üí X ‚ü∂ X ‚äû Y",
    "name": "CategoryTheory.Limits.biprod.inl",
    "doc": "The inclusion into the first summand of a binary biproduct. ",
    "depth": 13},
   {"term":
    "{C : Type u} ‚Üí\n  [inst : CategoryTheory.Category.{v, u} C] ‚Üí\n    [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] ‚Üí\n      {X Y : C} ‚Üí [inst_2 : CategoryTheory.Limits.HasBinaryBiproduct X Y] ‚Üí X ‚äû Y ‚ü∂ Y",
    "name": "CategoryTheory.Limits.biprod.snd",
    "doc": "The projection onto the second summand of a binary biproduct. ",
    "depth": 14},
   {"term":
    "{C : Type u} ‚Üí\n  [inst : CategoryTheory.Category.{v, u} C] ‚Üí\n    [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] ‚Üí\n      {X Y : C} ‚Üí [inst_2 : CategoryTheory.Limits.HasBinaryBiproduct X Y] ‚Üí CategoryTheory.Limits.IsZero X ‚Üí (Y ‚âÖ X ‚äû Y)",
    "name": "CategoryTheory.Limits.isoZeroBiprod",
    "doc": "If `X` is a zero object, `Y ‚âÖ X ‚äû Y` for any `Y`. ",
    "depth": 14}],
  "count": 81},
 {"noDocExamples": [],
  "kind": "SimpleGraph.¬´term_‚Üíg_¬ª",
  "examples":
  [{"term": "{V : Type u} ‚Üí {G : SimpleGraph V} ‚Üí G ‚Üíg G",
    "name": "SimpleGraph.Hom.id",
    "doc": "The identity homomorphism from a graph to itself. ",
    "depth": 6},
   {"term":
    "{V : Type u} ‚Üí {G : SimpleGraph V} ‚Üí (x : SimpleGraph.Subgraph G) ‚Üí SimpleGraph.Subgraph.spanningCoe x ‚Üíg G",
    "name": "SimpleGraph.Subgraph.spanningHom",
    "doc":
    "There is an induced injective homomorphism of a subgraph of `G` as\na spanning subgraph into `G`. ",
    "depth": 8},
   {"term":
    "{V : Type u} ‚Üí\n  {V' : Type v} ‚Üí\n    {G : SimpleGraph V} ‚Üí\n      {G' : SimpleGraph V'} ‚Üí G ‚Üíg G' ‚Üí SimpleGraph.ConnectedComponent G ‚Üí SimpleGraph.ConnectedComponent G'",
    "name": "SimpleGraph.ConnectedComponent.map",
    "doc": "The map on connected components induced by a graph homomorphism. ",
    "depth": 9},
   {"term":
    "{V : Type u} ‚Üí {W : Type v} ‚Üí {G : SimpleGraph V} ‚Üí {G' : SimpleGraph W} ‚Üí G ‚Ü™g G' ‚Üí G ‚Üíg G'",
    "name": "SimpleGraph.Embedding.toHom",
    "doc": "An embedding of graphs gives rise to a homomorphism of graphs. ",
    "depth": 9},
   {"term":
    "{V : Type u} ‚Üí\n  {W : Type v} ‚Üí {G : SimpleGraph V} ‚Üí {G' : SimpleGraph W} ‚Üí G ‚Üíg G' ‚Üí SimpleGraph.Dart G ‚Üí SimpleGraph.Dart G'",
    "name": "SimpleGraph.Hom.mapDart",
    "doc": "The map between darts induced by a homomorphism. ",
    "depth": 9}],
  "count": 81},
 {"noDocExamples": [],
  "kind": "AddCommGroup.¬´term_‚â°_[PMOD_]¬ª",
  "examples":
  [{"term":
    "‚àÄ {Œ± : Type u_1} [inst : AddCommGroup Œ±] {p a b : Œ±}, a ‚â° b [PMOD p] ‚Üí b ‚â° a [PMOD p]",
    "name": "AddCommGroup.ModEq.symm",
    "doc": "**Alias** of the forward direction of `AddCommGroup.modEq_comm`.",
    "depth": 11},
   {"term":
    "‚àÄ {Œ± : Type u_1} [inst : AddCommGroupWithOne Œ±] [inst_1 : CharZero Œ±] {a b z : ‚Ñ§}, a ‚â° b [PMOD z] ‚Üí ‚Üëa ‚â° ‚Üëb [PMOD ‚Üëz]",
    "name": "AddCommGroup.ModEq.int_cast",
    "doc":
    "**Alias** of the reverse direction of `AddCommGroup.int_cast_modEq_int_cast`.",
    "depth": 14},
   {"term":
    "‚àÄ {Œ± : Type u_1} [inst : AddCommGroupWithOne Œ±] [inst_1 : CharZero Œ±] {a b n : ‚Ñï}, a ‚â° b [MOD n] ‚Üí ‚Üëa ‚â° ‚Üëb [PMOD ‚Üën]",
    "name": "AddCommGroup.ModEq.nat_cast",
    "doc":
    "**Alias** of the reverse direction of `AddCommGroup.nat_cast_modEq_nat_cast`.",
    "depth": 14},
   {"term":
    "‚àÄ {Œ± : Type u_1} [inst : AddCommGroupWithOne Œ±] [inst_1 : CharZero Œ±] {a b z : ‚Ñ§}, ‚Üëa ‚â° ‚Üëb [PMOD ‚Üëz] ‚Üí a ‚â° b [PMOD z]",
    "name": "AddCommGroup.ModEq.of_int_cast",
    "doc":
    "**Alias** of the forward direction of `AddCommGroup.int_cast_modEq_int_cast`.",
    "depth": 14},
   {"term":
    "‚àÄ {Œ± : Type u_1} [inst : AddCommGroupWithOne Œ±] [inst_1 : CharZero Œ±] {a b n : ‚Ñï}, ‚Üëa ‚â° ‚Üëb [PMOD ‚Üën] ‚Üí a ‚â° b [MOD n]",
    "name": "Nat.ModEq.of_nat_cast",
    "doc":
    "**Alias** of the forward direction of `AddCommGroup.nat_cast_modEq_nat_cast`.",
    "depth": 14}],
  "count": 80},
 {"noDocExamples":
  [{"term":
    "‚àÄ {Œ± : Type u_2} [inst : Inf Œ±] [inst_1 : HImp Œ±] (a b : Œ±), a ‚áî b = (b ‚á® a) ‚äì (a ‚á® b)",
    "name": "bihimp_def",
    "depth": 12},
   {"term":
    "‚àÄ {Œ± : Type u_2} [inst : GeneralizedHeytingAlgebra Œ±] (a : Œ±), ‚ä§ ‚áî a = a",
    "name": "top_bihimp",
    "depth": 12},
   {"term":
    "‚àÄ {Œ± : Type u_1} [inst : GeneralizedHeytingAlgebra Œ±], IsCommutative Œ± fun x x_1 => x ‚áî x_1",
    "name": "bihimp_isCommutative.proof_1",
    "depth": 12},
   {"term":
    "‚àÄ {Œ± : Type u_2} [inst : GeneralizedHeytingAlgebra Œ±], IsCommutative Œ± fun x x_1 => x ‚áî x_1",
    "name": "bihimp_isCommutative",
    "depth": 12},
   {"term":
    "‚àÄ {Œ± : Type u_2} [inst : GeneralizedHeytingAlgebra Œ±] (a : Œ±), a ‚áî a = ‚ä§",
    "name": "bihimp_self",
    "depth": 12}],
  "kind": "¬´term_‚áî_¬ª",
  "examples": [],
  "count": 77},
 {"noDocExamples": [],
  "kind": "¬´term_‚©ø_¬ª",
  "examples":
  [{"term":
    "‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] {a b : Œ±}, a ‚â§ b ‚Üí b ‚â§ a ‚Üí a ‚©ø b",
    "name": "LE.le.wcovby_of_le",
    "doc": "**Alias** of `wcovby_of_le_of_le`.",
    "depth": 11},
   {"term":
    "‚àÄ {Œ± : Type u_1} [inst : PartialOrder Œ±] {a b : Œ±}, a ‚©ø b ‚Üí a = b ‚à® a ‚ãñ b",
    "name": "Wcovby.eq_or_covby",
    "doc": "**Alias** of the forward direction of `wcovby_iff_eq_or_covby`.",
    "depth": 12},
   {"term":
    "‚àÄ {Œ± : Type u_1} [inst : PartialOrder Œ±] {a b : Œ±}, a ‚©ø b ‚Üí a ‚ãñ b ‚à® a = b",
    "name": "Wcovby.covby_or_eq",
    "doc": "**Alias** of the forward direction of `wcovby_iff_covby_or_eq`.",
    "depth": 13},
   {"term":
    "‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] {a b : Œ±}, a ‚â§ b ‚Üí (¬¨a ‚©ø b ‚Üî ‚àÉ c, a < c ‚àß c < b)",
    "name": "not_wcovby_iff",
    "doc":
    "If `a ‚â§ b`, then `b` does not cover `a` iff there's an element in between. ",
    "depth": 15},
   {"term":
    "‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] {a b : Œ±}, a ‚©ø b ‚Üí ‚ÜëOrderDual.toDual b ‚©ø ‚ÜëOrderDual.toDual a",
    "name": "Wcovby.toDual",
    "doc": "**Alias** of the reverse direction of `toDual_wcovby_toDual_iff`.",
    "depth": 15}],
  "count": 77},
 {"noDocExamples":
  [{"term":
    "{Œ± : Type u_1} ‚Üí [inst : AddCommSemigroup Œ±] ‚Üí AddCommSemigroup Œ±À¢ ∏·µê",
    "name": "SymAlg.addCommSemigroup",
    "depth": 4},
   {"term": "{Œ± : Type u_1} ‚Üí [inst : Inhabited Œ±] ‚Üí Inhabited Œ±À¢ ∏·µê",
    "name": "SymAlg.instInhabitedSymAlg",
    "depth": 4}],
  "kind": "¬´term_À¢ ∏·µê¬ª",
  "examples":
  [{"term": "{Œ± : Type u_1} ‚Üí Œ± ‚âÉ Œ±À¢ ∏·µê",
    "name": "SymAlg.sym",
    "doc": "The element of `SymAlg Œ±` that represents `a : Œ±`. ",
    "depth": 3},
   {"term": "{Œ± : Type u_1} ‚Üí Œ±À¢ ∏·µê ‚âÉ Œ±",
    "name": "SymAlg.unsym",
    "doc": "The element of `Œ±` represented by `x : Œ±À¢ ∏·µê`. ",
    "depth": 4},
   {"term":
    "{Œ± : Type u_1} ‚Üí [inst : Ring Œ±] ‚Üí [inst : Invertible 2] ‚Üí NonAssocRing Œ±À¢ ∏·µê",
    "name": "SymAlg.instNonAssocRingSymAlg",
    "doc":
    "The symmetrization of a real (unital, associative) algebra is a non-associative ring. ",
    "depth": 10}],
  "count": 77},
 {"noDocExamples":
  [{"term":
    "‚àÄ {Œ± : Type u_1} (a : Array Œ±) (i : Fin (Array.size a)), Array.get a i = a[‚Üëi]",
    "name": "Array.get_eq_getElem",
    "depth": 15},
   {"term":
    "‚àÄ {Œ± : Type u_1} {i : ‚Ñï} (a : Array Œ±) (h : i < Array.size a), a[i] ‚àà a.data",
    "name": "Array.getElem_mem_data",
    "depth": 17},
   {"term":
    "‚àÄ {Œ± : Type u} (a : Œ±) (as : List Œ±) (h : 0 < List.length (a :: as)), (a :: as)[0] = a",
    "name": "List.cons_getElem_zero",
    "depth": 17}],
  "kind": "¬´term__[_]¬ª",
  "examples":
  [{"term":
    "‚àÄ {Œ± : Type u_1} (self : Array.PrefixTable Œ±) {i : ‚Ñï} (h : i < Array.size self.toArray), self.toArray[i].snd ‚â§ i",
    "name": "Array.PrefixTable.valid",
    "doc": "Validity condition to help with termination proofs ",
    "depth": 19},
   {"term":
    "‚àÄ {Œ± Œ≤ Œ¥ : Type} [inst : CanonicallyLinearOrderedAddMonoid Œ¥] {C : Levenshtein.Cost Œ± Œ≤ Œ¥} {xs : List Œ±} {ys : List Œ≤}\n  (self : LevenshteinEstimator' C xs ys),\n  self.bound =\n    match self.pre_rev, (_ : List.reverse self.pre_rev ++ self.suff = ys) with\n    | [], split => ((‚Üëself.distances)[0], List.length ys)\n    | x, split => (List.minimum_of_length_pos (_ : 0 < List.length ‚Üëself.distances), List.length self.suff)",
    "name": "LevenshteinEstimator'.bound_eq",
    "doc": "Predicate describing the current bound. ",
    "depth": 27}],
  "count": 77},
 {"noDocExamples": [],
  "kind": "CategoryTheory.Limits.¬´term‚ä•__¬ª",
  "examples":
  [{"term":
    "{C : Type u‚ÇÅ} ‚Üí\n  [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] ‚Üí\n    [inst_1 : CategoryTheory.Limits.HasInitial C] ‚Üí CategoryTheory.Limits.IsInitial (‚ä•_ C)",
    "name": "CategoryTheory.Limits.initialIsInitial",
    "doc": "An initial object is initial. ",
    "depth": 7},
   {"term": "‚ä•_ TopCat ‚âÖ TopCat.of PEmpty.{u + 1}",
    "name": "TopCat.initialIsoPEmpty",
    "doc": "The initial object of `Top` is `PEmpty`. ",
    "depth": 8},
   {"term": "‚ä•_ Type u ‚âÖ PEmpty.{u + 1}",
    "name": "CategoryTheory.Limits.Types.initialIso",
    "doc": "The initial object in `Type u` is `PEmpty`. ",
    "depth": 8},
   {"term":
    "{C : Type u‚ÇÅ} ‚Üí\n  [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] ‚Üí [inst_1 : CategoryTheory.Limits.HasInitial C] ‚Üí (P : C) ‚Üí ‚ä•_ C ‚ü∂ P",
    "name": "CategoryTheory.Limits.initial.to",
    "doc": "The map to an object from the initial object. ",
    "depth": 10},
   {"term":
    "{C : Type u‚ÇÅ} ‚Üí\n  [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] ‚Üí\n    [inst_1 : CategoryTheory.Limits.HasInitial C] ‚Üí {P : C} ‚Üí CategoryTheory.Limits.IsInitial P ‚Üí (‚ä•_ C ‚âÖ P)",
    "name": "CategoryTheory.Limits.initialIsoIsInitial",
    "doc":
    "The (unique) isomorphism between the chosen initial object and any other initial object. ",
    "depth": 10}],
  "count": 76},
 {"noDocExamples":
  [{"term": "‚àÄ {Œ± : Type u_1} [inst : SemilatticeSup Œ±] {t : Set Œ±}, ‚àÖ ‚äª t = ‚àÖ",
    "name": "Set.empty_sups",
    "depth": 10},
   {"term": "‚àÄ {Œ± : Type u_1} [inst : SemilatticeSup Œ±] {s : Set Œ±}, s ‚äª ‚àÖ = ‚àÖ",
    "name": "Set.sups_empty",
    "depth": 10},
   {"term":
    "‚àÄ {Œ± : Type u_1} [inst : SemilatticeSup Œ±] {s t : Set Œ±}, Set.Nonempty (s ‚äª t) ‚Üí Set.Nonempty s",
    "name": "Set.Nonempty.of_sups_left",
    "depth": 11},
   {"term":
    "‚àÄ {Œ± : Type u_1} [inst : SemilatticeSup Œ±] {s t : Set Œ±}, Set.Nonempty (s ‚äª t) ‚Üí Set.Nonempty t",
    "name": "Set.Nonempty.of_sups_right",
    "depth": 11},
   {"term":
    "‚àÄ {Œ± : Type u_1} [inst : SemilatticeSup Œ±] (s t : Set Œ±), s ‚äª t = t ‚äª s",
    "name": "Set.sups_comm",
    "depth": 11}],
  "kind": "¬´term_‚äª_¬ª",
  "examples": [],
  "count": 76},
 {"noDocExamples": [],
  "kind": "CategoryTheory.Limits.¬´term_‚®ø_¬ª",
  "examples":
  [{"term": "(X Y : Type u) ‚Üí X ‚®ø Y ‚âÖ X ‚äï Y",
    "name": "CategoryTheory.Limits.Types.binaryCoproductIso",
    "doc": "The categorical binary coproduct in `Type u` is the sum `X ‚äï Y`. ",
    "depth": 10},
   {"term":
    "{C : Type u} ‚Üí\n  [inst : CategoryTheory.Category.{v, u} C] ‚Üí\n    {X Y : C} ‚Üí [inst_1 : CategoryTheory.Limits.HasBinaryCoproduct X Y] ‚Üí Y ‚ü∂ X ‚®ø Y",
    "name": "CategoryTheory.Limits.coprod.inr",
    "doc": "The inclusion map from the second component of the coproduct. ",
    "depth": 11},
   {"term":
    "{C : Type u} ‚Üí\n  [inst : CategoryTheory.Category.{v, u} C] ‚Üí\n    {X Y : C} ‚Üí [inst_1 : CategoryTheory.Limits.HasBinaryCoproduct X Y] ‚Üí X ‚ü∂ X ‚®ø Y",
    "name": "CategoryTheory.Limits.coprod.inl",
    "doc": "The inclusion map from the first component of the coproduct. ",
    "depth": 11},
   {"term":
    "{C : Type u} ‚Üí\n  [inst : CategoryTheory.Category.{v, u} C] ‚Üí\n    (X : C) ‚Üí [inst_1 : CategoryTheory.Limits.HasBinaryCoproduct X X] ‚Üí X ‚®ø X ‚ü∂ X",
    "name": "CategoryTheory.Limits.codiag",
    "doc": "codiagonal arrow of the binary coproduct ",
    "depth": 11},
   {"term":
    "{C : Type u_1} ‚Üí\n  [inst : CategoryTheory.Category.{u_2, u_1} C] ‚Üí\n    [inst_1 : CategoryTheory.Limits.HasZeroObject C] ‚Üí\n      [inst_2 : CategoryTheory.Limits.HasZeroMorphisms C] ‚Üí (X : C) ‚Üí X ‚®ø 0 ‚âÖ X",
    "name": "CategoryTheory.Limits.coprodZeroIso",
    "doc": "A zero object is a right unit for categorical coproduct. ",
    "depth": 14}],
  "count": 76},
 {"noDocExamples":
  [{"term": "‚àÄ {Œ± : Type u_1} [inst : SemilatticeInf Œ±] {t : Set Œ±}, ‚àÖ ‚äº t = ‚àÖ",
    "name": "Set.empty_infs",
    "depth": 10},
   {"term": "‚àÄ {Œ± : Type u_1} [inst : SemilatticeInf Œ±] {s : Set Œ±}, s ‚äº ‚àÖ = ‚àÖ",
    "name": "Set.infs_empty",
    "depth": 10},
   {"term":
    "‚àÄ {Œ± : Type u_1} [inst : SemilatticeInf Œ±] {s t : Set Œ±}, Set.Nonempty (s ‚äº t) ‚Üí Set.Nonempty t",
    "name": "Set.Nonempty.of_infs_right",
    "depth": 11},
   {"term":
    "‚àÄ {Œ± : Type u_1} [inst : SemilatticeInf Œ±] (s t : Set Œ±), s ‚äº t = t ‚äº s",
    "name": "Set.infs_comm",
    "depth": 11},
   {"term":
    "‚àÄ {Œ± : Type u_1} [inst : SemilatticeInf Œ±] {s t : Set Œ±}, Set.Nonempty (s ‚äº t) ‚Üí Set.Nonempty s",
    "name": "Set.Nonempty.of_infs_left",
    "depth": 11}],
  "kind": "¬´term_‚äº_¬ª",
  "examples": [],
  "count": 75},
 {"noDocExamples": [],
  "kind": "¬´term_‚âÉ‚Çõ‚Çó[_]_¬ª",
  "examples":
  [{"term":
    "{R : Type u_1} ‚Üí\n  {M : Type u_7} ‚Üí\n    [inst : Semiring R] ‚Üí\n      [inst_1 : AddCommMonoid M] ‚Üí\n        {œÉ œÉ' : R ‚Üí+* R} ‚Üí\n          [inst_2 : RingHomInvPair œÉ œÉ'] ‚Üí\n            [inst_3 : RingHomInvPair œÉ' œÉ] ‚Üí {x : Module R M} ‚Üí (f : M ‚Üí‚Çõ‚Çó[œÉ] M) ‚Üí Function.Involutive ‚Üëf ‚Üí M ‚âÉ‚Çõ‚Çó[œÉ] M",
    "name": "LinearEquiv.ofInvolutive",
    "doc": "An involutive linear map is a linear equivalence. ",
    "depth": 28},
   {"term":
    "{R : Type u_17} ‚Üí\n  {S : Type u_18} ‚Üí\n    [inst : Semiring R] ‚Üí\n      [inst_1 : Semiring S] ‚Üí\n        {œÉ : R ‚Üí+* S} ‚Üí\n          {œÉ' : S ‚Üí+* R} ‚Üí\n            [inst_2 : RingHomInvPair œÉ œÉ'] ‚Üí\n              [inst_3 : RingHomInvPair œÉ' œÉ] ‚Üí\n                {M : Type u_19} ‚Üí\n                  {M‚ÇÇ : Type u_20} ‚Üí\n                    [inst_4 : AddCommMonoid M] ‚Üí\n                      [inst_5 : AddCommMonoid M‚ÇÇ] ‚Üí\n                        [inst_6 : Module R M] ‚Üí [inst_7 : Module S M‚ÇÇ] ‚Üí (M ‚âÉ‚Çõ‚Çó[œÉ] M‚ÇÇ) ‚Üí M‚ÇÇ ‚Üí M",
    "name": "LinearEquiv.Simps.symm_apply",
    "doc": "See Note [custom simps projection] ",
    "depth": 29},
   {"term":
    "{R : Type u_1} ‚Üí\n  {S : Type u_6} ‚Üí\n    {M : Type u_7} ‚Üí\n      {M‚ÇÇ : Type u_9} ‚Üí\n        [inst : Semiring R] ‚Üí\n          [inst_1 : Semiring S] ‚Üí\n            [inst_2 : AddCommMonoid M] ‚Üí\n              [inst_3 : AddCommMonoid M‚ÇÇ] ‚Üí\n                [inst_4 : Module R M] ‚Üí\n                  [inst_5 : Module S M‚ÇÇ] ‚Üí\n                    {œÉ : R ‚Üí+* S} ‚Üí\n                      {œÉ' : S ‚Üí+* R} ‚Üí\n                        [inst_6 : RingHomInvPair œÉ œÉ'] ‚Üí [inst_7 : RingHomInvPair œÉ' œÉ] ‚Üí (M ‚âÉ‚Çõ‚Çó[œÉ] M‚ÇÇ) ‚Üí M ‚âÉ M‚ÇÇ",
    "name": "LinearEquiv.toEquiv",
    "doc": "The equivalence of types underlying a linear equivalence. ",
    "depth": 29},
   {"term":
    "{R : Type u_16} ‚Üí\n  {S : Type u_17} ‚Üí\n    [inst : Semiring R] ‚Üí\n      [inst_1 : Semiring S] ‚Üí\n        {œÉ : R ‚Üí+* S} ‚Üí\n          {œÉ' : S ‚Üí+* R} ‚Üí\n            [inst_2 : RingHomInvPair œÉ œÉ'] ‚Üí\n              [inst_3 : RingHomInvPair œÉ' œÉ] ‚Üí\n                {M : Type u_18} ‚Üí\n                  {M‚ÇÇ : Type u_19} ‚Üí\n                    [inst_4 : AddCommMonoid M] ‚Üí\n                      [inst_5 : AddCommMonoid M‚ÇÇ] ‚Üí\n                        [inst_6 : Module R M] ‚Üí [inst_7 : Module S M‚ÇÇ] ‚Üí (M ‚âÉ‚Çõ‚Çó[œÉ] M‚ÇÇ) ‚Üí M ‚âÉ+ M‚ÇÇ",
    "name": "LinearEquiv.toAddEquiv",
    "doc":
    "The additive equivalence of types underlying a linear equivalence. ",
    "depth": 29},
   {"term":
    "{R : Type u_1} ‚Üí\n  {S : Type u_6} ‚Üí\n    {M : Type u_7} ‚Üí\n      {M‚ÇÇ : Type u_9} ‚Üí\n        [inst : Semiring R] ‚Üí\n          [inst_1 : Semiring S] ‚Üí\n            [inst_2 : AddCommMonoid M] ‚Üí\n              [inst_3 : AddCommMonoid M‚ÇÇ] ‚Üí\n                {module_M : Module R M} ‚Üí\n                  {module_S_M‚ÇÇ : Module S M‚ÇÇ} ‚Üí\n                    {œÉ : R ‚Üí+* S} ‚Üí\n                      {œÉ' : S ‚Üí+* R} ‚Üí\n                        {re‚ÇÅ : RingHomInvPair œÉ œÉ'} ‚Üí {re‚ÇÇ : RingHomInvPair œÉ' œÉ} ‚Üí (M ‚âÉ‚Çõ‚Çó[œÉ] M‚ÇÇ) ‚Üí M‚ÇÇ ‚âÉ‚Çõ‚Çó[œÉ'] M",
    "name": "LinearEquiv.symm",
    "doc": "Linear equivalences are symmetric. ",
    "depth": 29}],
  "count": 73},
 {"noDocExamples": [],
  "kind": "¬´term_‚Üí‚ãÜ‚Çô‚Çê[_]_¬ª",
  "examples":
  [{"term":
    "(R : Type u_1) ‚Üí\n  (A : Type u_2) ‚Üí\n    [inst : Monoid R] ‚Üí\n      [inst_1 : NonUnitalNonAssocSemiring A] ‚Üí [inst_2 : DistribMulAction R A] ‚Üí [inst_3 : Star A] ‚Üí A ‚Üí‚ãÜ‚Çô‚Çê[R] A",
    "name": "NonUnitalStarAlgHom.id",
    "doc": "The identity as a non-unital ‚ãÜ-algebra homomorphism. ",
    "depth": 16},
   {"term":
    "(R : Type u_1) ‚Üí\n  (A : Type u_2) ‚Üí\n    [inst : CommSemiring R] ‚Üí\n      [inst_1 : StarAddMonoid R] ‚Üí\n        [inst_2 : NonUnitalSemiring A] ‚Üí [inst_3 : Star A] ‚Üí [inst_4 : Module R A] ‚Üí A ‚Üí‚ãÜ‚Çô‚Çê[R] Unitization R A",
    "name": "Unitization.inrNonUnitalStarAlgHom",
    "doc":
    "The coercion from a non-unital `R`-algebra `A` to its unitization `unitization R A`\nrealized as a non-unital star algebra homomorphism. ",
    "depth": 19},
   {"term":
    "(R : Type u_1) ‚Üí\n  (A : Type u_2) ‚Üí\n    (B : Type u_3) ‚Üí\n      [inst : Monoid R] ‚Üí\n        [inst_1 : NonUnitalNonAssocSemiring A] ‚Üí\n          [inst_2 : DistribMulAction R A] ‚Üí\n            [inst_3 : StarAddMonoid A] ‚Üí\n              [inst_4 : NonUnitalNonAssocSemiring B] ‚Üí\n                [inst_5 : DistribMulAction R B] ‚Üí [inst_6 : StarAddMonoid B] ‚Üí A ‚Üí‚ãÜ‚Çô‚Çê[R] A √ó B",
    "name": "NonUnitalStarAlgHom.inl",
    "doc":
    "The left injection into a product is a non-unital algebra homomorphism. ",
    "depth": 20},
   {"term":
    "(R : Type u_1) ‚Üí\n  (A : Type u_2) ‚Üí\n    (B : Type u_3) ‚Üí\n      [inst : Monoid R] ‚Üí\n        [inst_1 : NonUnitalNonAssocSemiring A] ‚Üí\n          [inst_2 : DistribMulAction R A] ‚Üí\n            [inst_3 : StarAddMonoid A] ‚Üí\n              [inst_4 : NonUnitalNonAssocSemiring B] ‚Üí\n                [inst_5 : DistribMulAction R B] ‚Üí [inst_6 : StarAddMonoid B] ‚Üí B ‚Üí‚ãÜ‚Çô‚Çê[R] A √ó B",
    "name": "NonUnitalStarAlgHom.inr",
    "doc":
    "The right injection into a product is a non-unital algebra homomorphism. ",
    "depth": 20},
   {"term":
    "{R : Type u_1} ‚Üí\n  {A : Type u_2} ‚Üí\n    {B : Type u_3} ‚Üí\n      [inst : Monoid R] ‚Üí\n        [inst_1 : NonUnitalNonAssocSemiring A] ‚Üí\n          [inst_2 : DistribMulAction R A] ‚Üí\n            [inst_3 : Star A] ‚Üí\n              [inst_4 : NonUnitalNonAssocSemiring B] ‚Üí\n                [inst_5 : DistribMulAction R B] ‚Üí [inst_6 : Star B] ‚Üí (A ‚Üí‚ãÜ‚Çô‚Çê[R] B) ‚Üí A ‚Üí B",
    "name": "NonUnitalStarAlgHom.Simps.apply",
    "doc": "See Note [custom simps projection] ",
    "depth": 21}],
  "count": 73},
 {"noDocExamples": [],
  "kind": "TypeVec.¬´term_:::_¬ª",
  "examples":
  [{"term":
    "{n : ‚Ñï} ‚Üí\n  {C : TypeVec (n + 1) ‚Üí Sort u} ‚Üí ((Œ± : TypeVec n) ‚Üí (Œ≤ : Type u_1) ‚Üí C (Œ± ::: Œ≤)) ‚Üí (Œ≥ : TypeVec (n + 1)) ‚Üí C Œ≥",
    "name": "TypeVec.append1Cases",
    "doc": "cases on `(n+1)-length` vectors ",
    "depth": 11},
   {"term":
    "{n : ‚Ñï} ‚Üí {Œ± : TypeVec (n + 1)} ‚Üí TypeVec.Arrow (TypeVec.drop Œ± ::: TypeVec.last Œ±) Œ±",
    "name": "TypeVec.fromAppend1DropLast",
    "doc": "stitch two bits of a vector back together ",
    "depth": 11},
   {"term":
    "{n : ‚Ñï} ‚Üí {Œ± : TypeVec (n + 1)} ‚Üí TypeVec.Arrow Œ± (TypeVec.drop Œ± ::: TypeVec.last Œ±)",
    "name": "TypeVec.toAppend1DropLast",
    "doc": "decompose a vector into its prefix appended with its last element ",
    "depth": 11},
   {"term":
    "(n : ‚Ñï) ‚Üí\n  {Œ≤ : TypeVec (n + 1) ‚Üí Sort u_1} ‚Üí ((t : Type u_2) ‚Üí (v : TypeVec n) ‚Üí Œ≤ (v ::: t)) ‚Üí (v : TypeVec (n + 1)) ‚Üí Œ≤ v",
    "name": "TypeVec.casesCons",
    "doc": "cases distinction for (n+1)-length type vector ",
    "depth": 11},
   {"term":
    "{n : ‚Ñï} ‚Üí (Œ± : TypeVec n) ‚Üí {Œ≤ : Type u_1} ‚Üí (Œ≤ ‚Üí Prop) ‚Üí ‚¶Éi : Fin2 (n + 1)‚¶Ñ ‚Üí (Œ± ::: Œ≤) i ‚Üí Prop",
    "name": "TypeVec.PredLast",
    "doc":
    "`PredLast Œ± p x` predicates `p` of the last element of `x : Œ±.append1 Œ≤`. ",
    "depth": 12}],
  "count": 71},
 {"noDocExamples": [],
  "kind": "¬´DistribMulActionHomLocal‚â∫¬ª",
  "examples":
  [{"term":
    "(M : Type u_5) ‚Üí\n  [inst : Monoid M] ‚Üí {A : Type u_6} ‚Üí [inst_1 : AddMonoid A] ‚Üí [inst_2 : DistribMulAction M A] ‚Üí A ‚Üí+[M] A",
    "name": "DistribMulActionHom.id",
    "doc": "The identity map as an equivariant additive monoid homomorphism. ",
    "depth": 13},
   {"term":
    "{M : Type u_5} ‚Üí\n  [inst : Monoid M] ‚Üí\n    {A : Type u_6} ‚Üí\n      [inst_1 : AddMonoid A] ‚Üí\n        [inst_2 : DistribMulAction M A] ‚Üí\n          {B : Type u_8} ‚Üí [inst_3 : AddMonoid B] ‚Üí [inst_4 : DistribMulAction M B] ‚Üí (A ‚Üí+[M] B) ‚Üí A ‚Üí+ B",
    "name": "DistribMulActionHom.toAddMonoidHom",
    "doc":
    "Reinterpret an equivariant additive monoid homomorphism as an additive monoid homomorphism. ",
    "depth": 17},
   {"term":
    "{M : Type u_18} ‚Üí\n  (N : Type u_16) ‚Üí\n    (A : Type u_17) ‚Üí\n      [inst : Monoid N] ‚Üí\n        [inst_1 : AddMonoid A] ‚Üí\n          [inst_2 : DistribSMul M A] ‚Üí [inst_3 : DistribMulAction N A] ‚Üí [inst_4 : SMulCommClass M N A] ‚Üí M ‚Üí A ‚Üí+[N] A",
    "name": "SMulCommClass.toDistribMulActionHom",
    "doc":
    "If `DistribMulAction` of `M` and `N` on `A` commute, then for each `c : M`, `(c ‚Ä¢ ¬∑)` is an\n`N`-action additive homomorphism. ",
    "depth": 17},
   {"term":
    "{Œ± : Type u_1} ‚Üí\n  {M : Type u_5} ‚Üí\n    {R : Type u_11} ‚Üí\n      [inst : Semiring R] ‚Üí [inst_1 : AddCommMonoid M] ‚Üí [inst_2 : DistribMulAction R M] ‚Üí Œ± ‚Üí M ‚Üí+[R] Œ± ‚Üí‚ÇÄ M",
    "name": "Finsupp.DistribMulActionHom.single",
    "doc":
    "`Finsupp.single` as a `DistribMulActionHom`.\n\nSee also `Finsupp.lsingle` for the version as a linear map. ",
    "depth": 17},
   {"term":
    "{M : Type u_5} ‚Üí\n  [inst : Monoid M] ‚Üí\n    {A : Type u_6} ‚Üí\n      [inst_1 : AddMonoid A] ‚Üí\n        [inst_2 : DistribMulAction M A] ‚Üí\n          {B : Type u_8} ‚Üí\n            [inst_3 : AddMonoid B] ‚Üí\n              [inst_4 : DistribMulAction M B] ‚Üí\n                {F : Type u_16} ‚Üí [inst_5 : DistribMulActionHomClass F M A B] ‚Üí F ‚Üí A ‚Üí+[M] B",
    "name": "DistribMulActionHomClass.toDistribMulActionHom",
    "doc":
    "Turn an element of a type `F` satisfying `SMulHomClass F M X Y` into an actual\n`MulActionHom`. This is declared as the default coercion from `F` to `MulActionHom M X Y`. ",
    "depth": 19}],
  "count": 71},
 {"noDocExamples": [],
  "kind": "CategoryTheory.Limits.¬´term‚àê_¬ª",
  "examples":
  [{"term": "{J : Type u} ‚Üí (F : J ‚Üí Type u) ‚Üí ‚àê F ‚âÖ (j : J) √ó F j",
    "name": "CategoryTheory.Limits.Types.coproductIso",
    "doc":
    "The categorical coproduct in `Type u` is the type theoretic coproduct `Œ£ j, F j`. ",
    "depth": 10},
   {"term":
    "{Œ± : Type} ‚Üí [inst : Fintype Œ±] ‚Üí (X : Œ± ‚Üí Stonean) ‚Üí Stonean.finiteCoproduct X ‚âÖ ‚àê X",
    "name": "Stonean.coproductIsoCoproduct",
    "doc":
    "The isomorphism from the explicit finite coproducts to the abstract coproduct. ",
    "depth": 12},
   {"term":
    "{Œ± : Type} ‚Üí [inst : Fintype Œ±] ‚Üí (X : Œ± ‚Üí CompHaus) ‚Üí CompHaus.finiteCoproduct X ‚âÖ ‚àê X",
    "name": "CompHaus.coproductIsoCoproduct",
    "doc":
    "The isomorphism from the explicit finite coproducts to the abstract coproduct. ",
    "depth": 12},
   {"term":
    "{Œπ : Type v} ‚Üí (Œ± : Œπ ‚Üí TopCatMax) ‚Üí ‚àê Œ± ‚âÖ TopCat.of ((i : Œπ) √ó ‚Üë(Œ± i))",
    "name": "TopCat.sigmaIsoSigma",
    "doc":
    "The coproduct is homeomorphic to the disjoint union of the topological spaces.\n",
    "depth": 12},
   {"term":
    "{Œ± : Type} ‚Üí [inst : Fintype Œ±] ‚Üí (X : Œ± ‚Üí Profinite) ‚Üí Profinite.finiteCoproduct X ‚âÖ ‚àê X",
    "name": "Profinite.coproductIsoCoproduct",
    "doc":
    "The isomorphism from the explicit finite coproducts to the abstract coproduct. ",
    "depth": 12}],
  "count": 70},
 {"noDocExamples": [],
  "kind": "¬´term_‚âÉ·µÉ‚Å±[_]_¬ª",
  "examples":
  [{"term":
    "(ùïú : Type u_1) ‚Üí\n  {V : Type u_2} ‚Üí\n    (P : Type u_8) ‚Üí\n      [inst : NormedField ùïú] ‚Üí\n        [inst_1 : SeminormedAddCommGroup V] ‚Üí\n          [inst_2 : NormedSpace ùïú V] ‚Üí [inst_3 : PseudoMetricSpace P] ‚Üí [inst_4 : NormedAddTorsor V P] ‚Üí P ‚âÉ·µÉ‚Å±[ùïú] P",
    "name": "AffineIsometryEquiv.refl",
    "doc": "Identity map as an `AffineIsometryEquiv`. ",
    "depth": 22},
   {"term":
    "(ùïú : Type u_1) ‚Üí\n  {V : Type u_2} ‚Üí\n    {P : Type u_8} ‚Üí\n      [inst : NormedField ùïú] ‚Üí\n        [inst_1 : SeminormedAddCommGroup V] ‚Üí\n          [inst_2 : NormedSpace ùïú V] ‚Üí [inst_3 : PseudoMetricSpace P] ‚Üí [inst_4 : NormedAddTorsor V P] ‚Üí P ‚Üí P ‚âÉ·µÉ‚Å±[ùïú] P",
    "name": "AffineIsometryEquiv.pointReflection",
    "doc": "Point reflection in `x` as an affine isometric automorphism. ",
    "depth": 23},
   {"term":
    "{ùïú : Type u_1} ‚Üí\n  {V : Type u_2} ‚Üí\n    {P : Type u_8} ‚Üí\n      [inst : NormedField ùïú] ‚Üí\n        [inst_1 : SeminormedAddCommGroup V] ‚Üí\n          [inst_2 : NormedSpace ùïú V] ‚Üí\n            [inst_3 : PseudoMetricSpace P] ‚Üí [inst_4 : NormedAddTorsor V P] ‚Üí Group (P ‚âÉ·µÉ‚Å±[ùïú] P)",
    "name": "AffineIsometryEquiv.instGroupAffineIsometryEquiv",
    "doc": "The group of affine isometries of a `NormedAddTorsor`, `P`. ",
    "depth": 23},
   {"term":
    "(ùïú : Type u_1) ‚Üí\n  {V : Type u_2} ‚Üí\n    (P : Type u_8) ‚Üí\n      [inst : NormedField ùïú] ‚Üí\n        [inst_1 : SeminormedAddCommGroup V] ‚Üí\n          [inst_2 : NormedSpace ùïú V] ‚Üí [inst_3 : PseudoMetricSpace P] ‚Üí [inst_4 : NormedAddTorsor V P] ‚Üí V ‚Üí P ‚âÉ·µÉ‚Å±[ùïú] P",
    "name": "AffineIsometryEquiv.constVAdd",
    "doc":
    "Translation by `v` (that is, the map `p ‚Ü¶ v +·µ• p`) as an affine isometric automorphism of `P`.\n",
    "depth": 23},
   {"term":
    "(ùïú : Type u_1) ‚Üí\n  {V : Type u_2} ‚Üí\n    {P : Type u_8} ‚Üí\n      [inst : NormedField ùïú] ‚Üí\n        [inst_1 : SeminormedAddCommGroup V] ‚Üí\n          [inst_2 : NormedSpace ùïú V] ‚Üí [inst_3 : PseudoMetricSpace P] ‚Üí [inst_4 : NormedAddTorsor V P] ‚Üí P ‚Üí P ‚âÉ·µÉ‚Å±[ùïú] V",
    "name": "AffineIsometryEquiv.constVSub",
    "doc": "`p' ‚Ü¶ p -·µ• p'` as an affine isometric equivalence. ",
    "depth": 23}],
  "count": 70},
 {"noDocExamples": [],
  "kind": "¬´term_‚âÉ‚Çó‚ÅÖ_‚ÅÜ_¬ª",
  "examples":
  [{"term":
    "{R : Type u} ‚Üí {L‚ÇÅ : Type v} ‚Üí [inst : CommRing R] ‚Üí [inst_1 : LieRing L‚ÇÅ] ‚Üí [inst_2 : LieAlgebra R L‚ÇÅ] ‚Üí L‚ÇÅ ‚âÉ‚Çó‚ÅÖR‚ÅÜ L‚ÇÅ",
    "name": "LieEquiv.refl",
    "doc": "Lie algebra equivalences are reflexive. ",
    "depth": 13},
   {"term":
    "{R : Type u} ‚Üí\n  {L‚ÇÅ : Type v} ‚Üí\n    {L‚ÇÇ : Type w} ‚Üí\n      [inst : CommRing R] ‚Üí\n        [inst_1 : LieRing L‚ÇÅ] ‚Üí\n          [inst_2 : LieRing L‚ÇÇ] ‚Üí [inst_3 : LieAlgebra R L‚ÇÅ] ‚Üí [inst_4 : LieAlgebra R L‚ÇÇ] ‚Üí (L‚ÇÅ ‚âÉ‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ) ‚Üí L‚ÇÇ ‚âÉ‚Çó‚ÅÖR‚ÅÜ L‚ÇÅ",
    "name": "LieEquiv.symm",
    "doc": "Lie algebra equivalences are symmetric. ",
    "depth": 17},
   {"term":
    "{R : Type u} ‚Üí\n  {L : Type v} ‚Üí\n    {L' : Type w} ‚Üí\n      [inst : CommRing R] ‚Üí\n        [inst_1 : LieRing L] ‚Üí\n          [inst_2 : LieAlgebra R L] ‚Üí [inst_3 : LieRing L'] ‚Üí [inst_4 : LieAlgebra R L'] ‚Üí (L ‚âÉ‚Çó‚ÅÖR‚ÅÜ L') ‚Üí L' ‚Üí L",
    "name": "LieEquiv.invFun",
    "doc": "The inverse function of an equivalence of Lie algebras ",
    "depth": 17},
   {"term":
    "{R : Type u} ‚Üí\n  {A‚ÇÅ : Type v} ‚Üí\n    {A‚ÇÇ : Type w} ‚Üí\n      [inst : CommRing R] ‚Üí\n        [inst_1 : Ring A‚ÇÅ] ‚Üí\n          [inst_2 : Ring A‚ÇÇ] ‚Üí [inst_3 : Algebra R A‚ÇÅ] ‚Üí [inst_4 : Algebra R A‚ÇÇ] ‚Üí (A‚ÇÅ ‚âÉ‚Çê[R] A‚ÇÇ) ‚Üí A‚ÇÅ ‚âÉ‚Çó‚ÅÖR‚ÅÜ A‚ÇÇ",
    "name": "AlgEquiv.toLieEquiv",
    "doc":
    "An equivalence of associative algebras is an equivalence of associated Lie algebras. ",
    "depth": 17},
   {"term":
    "{R : Type u} ‚Üí\n  [inst : CommRing R] ‚Üí\n    {n : Type w} ‚Üí\n      [inst_1 : DecidableEq n] ‚Üí\n        [inst_2 : Fintype n] ‚Üí (P : Matrix n n R) ‚Üí Invertible P ‚Üí Matrix n n R ‚âÉ‚Çó‚ÅÖR‚ÅÜ Matrix n n R",
    "name": "Matrix.lieConj",
    "doc":
    "An invertible matrix induces a Lie algebra equivalence from the space of matrices to itself. ",
    "depth": 20}],
  "count": 69},
 {"noDocExamples": [],
  "kind": "TopCat.Presheaf.¬´term__*_¬ª",
  "examples":
  [{"term":
    "{C : Type u} ‚Üí\n  [inst : CategoryTheory.Category.{v, u} C] ‚Üí\n    {X : TopCat} ‚Üí (‚Ñ± : TopCat.Presheaf C X) ‚Üí CategoryTheory.CategoryStruct.id X _* ‚Ñ± ‚âÖ ‚Ñ±",
    "name": "TopCat.Presheaf.Pushforward.id",
    "doc":
    "The natural isomorphism between the pushforward of a presheaf along the identity continuous map\nand the original presheaf. ",
    "depth": 12},
   {"term":
    "‚àÄ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {X Y : TopCat} (f : X ‚ü∂ Y) {F : TopCat.Presheaf C X},\n  TopCat.Presheaf.IsSheaf F ‚Üí TopCat.Presheaf.IsSheaf (f _* F)",
    "name": "TopCat.Sheaf.pushforward_sheaf_of_sheaf",
    "doc": "The pushforward of a sheaf (by a continuous map) is a sheaf.\n",
    "depth": 14},
   {"term":
    "{C : Type u_1} ‚Üí\n  [inst : CategoryTheory.Category.{u_2, u_1} C] ‚Üí\n    {X Y : AlgebraicGeometry.PresheafedSpace C} ‚Üí (H : X ‚âÖ Y) ‚Üí Y.presheaf ‚âÖ H.hom.base _* X.presheaf",
    "name": "AlgebraicGeometry.PresheafedSpace.sheafIsoOfIso",
    "doc":
    "Isomorphic `PresheafedSpace`s have naturally isomorphic presheaves. ",
    "depth": 16},
   {"term":
    "{C : Type u} ‚Üí\n  [inst : CategoryTheory.Category.{v, u} C] ‚Üí\n    {X Y : TopCat} ‚Üí {f g : X ‚ü∂ Y} ‚Üí f = g ‚Üí (‚Ñ± : TopCat.Presheaf C X) ‚Üí f _* ‚Ñ± ‚âÖ g _* ‚Ñ±",
    "name": "TopCat.Presheaf.pushforwardEq",
    "doc":
    "An equality of continuous maps induces a natural isomorphism between the pushforwards of a presheaf\nalong those maps.\n",
    "depth": 16},
   {"term":
    "{C : Type u_1} ‚Üí\n  [inst : CategoryTheory.Category.{u_2, u_1} C] ‚Üí\n    {X Y : AlgebraicGeometry.PresheafedSpace C} ‚Üí (H : ‚ÜëX ‚âÖ ‚ÜëY) ‚Üí (H.hom _* X.presheaf ‚âÖ Y.presheaf) ‚Üí (X ‚âÖ Y)",
    "name": "AlgebraicGeometry.PresheafedSpace.isoOfComponents",
    "doc":
    "An isomorphism of `PresheafedSpace`s is a homeomorphism of the underlying space, and a\nnatural transformation between the sheaves.\n",
    "depth": 16}],
  "count": 69},
 {"noDocExamples": [],
  "kind": "Int.¬´term_‚â°_[ZMOD_]¬ª",
  "examples":
  [{"term": "‚àÄ {n a b : ‚Ñ§}, a ‚â° b [ZMOD n] ‚Üí n ‚à£ b - a",
    "name": "Int.ModEq.dvd",
    "doc": "**Alias** of the forward direction of `Int.modEq_iff_dvd`.",
    "depth": 11},
   {"term": "‚àÄ {n a b : ‚Ñ§}, n ‚à£ b - a ‚Üí a ‚â° b [ZMOD n]",
    "name": "Int.modEq_of_dvd",
    "doc": "**Alias** of the reverse direction of `Int.modEq_iff_dvd`.",
    "depth": 11},
   {"term":
    "‚àÄ {p : ‚Ñï}, Nat.Prime p ‚Üí ‚àÄ {n : ‚Ñ§}, IsCoprime n ‚Üëp ‚Üí n ^ (p - 1) ‚â° 1 [ZMOD ‚Üëp]",
    "name": "Int.ModEq.pow_card_sub_one_eq_one",
    "doc":
    "**Fermat's Little Theorem**: for all `a : ‚Ñ§` coprime to `p`, we have\n`a ^ (p - 1) ‚â° 1 [ZMOD p]`. ",
    "depth": 13},
   {"term":
    "‚àÄ {m a b c : ‚Ñ§}, 0 < m ‚Üí a * c ‚â° b * c [ZMOD m] ‚Üí a ‚â° b [ZMOD m / ‚Üë(Int.gcd m c)]",
    "name": "Int.ModEq.cancel_right_div_gcd",
    "doc":
    "To cancel a common factor `c` from a `ModEq` we must divide the modulus `m` by `gcd m c`. ",
    "depth": 15},
   {"term":
    "‚àÄ {m a b c : ‚Ñ§}, 0 < m ‚Üí c * a ‚â° c * b [ZMOD m] ‚Üí a ‚â° b [ZMOD m / ‚Üë(Int.gcd m c)]",
    "name": "Int.ModEq.cancel_left_div_gcd",
    "doc":
    "To cancel a common factor `c` from a `ModEq` we must divide the modulus `m` by `gcd m c`. ",
    "depth": 15}],
  "count": 68},
 {"noDocExamples": [],
  "kind": "Asymptotics.¬´term_=Œò[_]_¬ª",
  "examples":
  [{"term":
    "‚àÄ {Œ± : Type u_1} {l : Filter Œ±} {f : Œ± ‚Üí ‚Ñù},\n  ((fun x => rexp (f x)) =Œò[l] fun x => 1) ‚Üî Filter.IsBoundedUnder (fun x x_1 => x ‚â§ x_1) l fun x => |f x|",
    "name": "Real.isTheta_exp_comp_one",
    "doc":
    "`Real.exp (f x)` is bounded away from zero and infinity along a filter `l` if and only if\n`|f x|` is bounded from above along this filter. ",
    "depth": 13},
   {"term":
    "‚àÄ {Œ± : Type u_1} {E : Type u_3} {F' : Type u_7} [inst : Norm E] [inst_1 : SeminormedAddCommGroup F'] {f : Œ± ‚Üí E}\n  {g' : Œ± ‚Üí F'} {l : Filter Œ±}, (f =Œò[l] fun x => ‚Äñg' x‚Äñ) ‚Üí f =Œò[l] g'",
    "name": "Asymptotics.IsTheta.of_norm_right",
    "doc":
    "**Alias** of the forward direction of `Asymptotics.isTheta_norm_right`.",
    "depth": 17},
   {"term":
    "‚àÄ {Œ± : Type u_1} {F : Type u_4} {E' : Type u_6} [inst : Norm F] [inst_1 : SeminormedAddCommGroup E'] {g : Œ± ‚Üí F}\n  {f' : Œ± ‚Üí E'} {l : Filter Œ±}, f' =Œò[l] g ‚Üí (fun x => ‚Äñf' x‚Äñ) =Œò[l] g",
    "name": "Asymptotics.IsTheta.norm_left",
    "doc":
    "**Alias** of the reverse direction of `Asymptotics.isTheta_norm_left`.",
    "depth": 17},
   {"term":
    "‚àÄ {Œ± : Type u_1} {F : Type u_4} {E' : Type u_6} [inst : Norm F] [inst_1 : SeminormedAddCommGroup E'] {g : Œ± ‚Üí F}\n  {f' : Œ± ‚Üí E'} {l : Filter Œ±}, (fun x => ‚Äñf' x‚Äñ) =Œò[l] g ‚Üí f' =Œò[l] g",
    "name": "Asymptotics.IsTheta.of_norm_left",
    "doc":
    "**Alias** of the forward direction of `Asymptotics.isTheta_norm_left`.",
    "depth": 17},
   {"term":
    "‚àÄ {Œ± : Type u_1} {E : Type u_3} {F' : Type u_7} [inst : Norm E] [inst_1 : SeminormedAddCommGroup F'] {f : Œ± ‚Üí E}\n  {g' : Œ± ‚Üí F'} {l : Filter Œ±}, f =Œò[l] g' ‚Üí f =Œò[l] fun x => ‚Äñg' x‚Äñ",
    "name": "Asymptotics.IsTheta.norm_right",
    "doc":
    "**Alias** of the reverse direction of `Asymptotics.isTheta_norm_right`.",
    "depth": 17}],
  "count": 68},
 {"noDocExamples": [],
  "kind": "CategoryTheory.Limits.¬´term‚àè_¬ª",
  "examples":
  [{"term":
    "(J : Type u) ‚Üí (f : J ‚Üí CategoryTheory.Grpd) ‚Üí CategoryTheory.Grpd.of ((j : J) ‚Üí ‚Üë(f j)) ‚âÖ ‚àè f",
    "name": "CategoryTheory.Grpd.piIsoPi",
    "doc":
    "The product of a family of groupoids is isomorphic\nto the product object in the category of Groupoids ",
    "depth": 10},
   {"term":
    "{J : Type v} ‚Üí (F : J ‚Üí Type u) ‚Üí [inst : UnivLE.{v, u}] ‚Üí ‚àè F ‚âÖ Shrink ((j : J) ‚Üí F j)",
    "name": "CategoryTheory.Limits.Types.UnivLE.productIso",
    "doc":
    "The categorical product in `Type u` indexed in `Type v`\nis the type theoretic product `Œ† j, F j`, after shrinking back to `Type u`. ",
    "depth": 11},
   {"term": "{J : Type v} ‚Üí (F : J ‚Üí TypeMax) ‚Üí ‚àè F ‚âÖ (j : J) ‚Üí F j",
    "name": "CategoryTheory.Limits.Types.productIso",
    "doc":
    "The categorical product in `TypeMax.{v, u}` is the type theoretic product `Œ† j, F j`. ",
    "depth": 12},
   {"term":
    "{Œπ : Type v} ‚Üí (Œ± : Œπ ‚Üí TopCatMax) ‚Üí ‚àè Œ± ‚âÖ TopCat.of ((i : Œπ) ‚Üí ‚Üë(Œ± i))",
    "name": "TopCat.piIsoPi",
    "doc":
    "The product is homeomorphic to the product of the underlying spaces,\nequipped with the product topology.\n",
    "depth": 12},
   {"term":
    "{C : Type u‚ÇÅ} ‚Üí\n  [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] ‚Üí\n    {Œ± : Type u_1} ‚Üí\n      (Z : Œ± ‚Üí C) ‚Üí [inst_1 : CategoryTheory.Limits.HasCoproduct Z] ‚Üí Opposite.op (‚àê Z) ‚âÖ ‚àè fun z => Opposite.op (Z z)",
    "name": "CategoryTheory.Limits.opCoproductIsoProduct",
    "doc":
    "The isomorphism from the opposite of the coproduct to the product. ",
    "depth": 13}],
  "count": 67},
 {"noDocExamples": [],
  "kind": "¬´term_‚Üí‚Çó·µ¢[_]_¬ª",
  "examples":
  [{"term": "‚Ñù ‚Üí‚Çó·µ¢[‚Ñù] ‚ÑÇ",
    "name": "Complex.ofRealLi",
    "doc": "Linear isometry version of the canonical embedding of `‚Ñù` in `‚ÑÇ`. ",
    "depth": 11},
   {"term": "{K : Type u_1} ‚Üí [inst : IsROrC K] ‚Üí ‚Ñù ‚Üí‚Çó·µ¢[‚Ñù] K",
    "name": "IsROrC.ofRealLi",
    "doc": "The ‚Ñù ‚Üí K coercion, as a linear isometry ",
    "depth": 13},
   {"term":
    "{E : Type u_1} ‚Üí\n  [inst : NormedAddCommGroup E] ‚Üí\n    [inst_1 : InnerProductSpace ‚Ñù E] ‚Üí\n      [inst_2 : Fact (FiniteDimensional.finrank ‚Ñù E = 2)] ‚Üí Orientation ‚Ñù E (Fin 2) ‚Üí E ‚Üí‚Çó·µ¢[‚Ñù] E",
    "name": "Orientation.rightAngleRotationAux‚ÇÇ",
    "doc":
    "Auxiliary construction for `Orientation.rightAngleRotation`, rotation by 90 degrees in an\noriented real inner product space of dimension 2. ",
    "depth": 16},
   {"term":
    "{R : Type u_1} ‚Üí\n  {E : Type u_5} ‚Üí [inst : Semiring R] ‚Üí [inst_1 : SeminormedAddCommGroup E] ‚Üí [inst_2 : Module R E] ‚Üí E ‚Üí‚Çó·µ¢[R] E",
    "name": "LinearIsometry.id",
    "doc": "The identity linear isometry. ",
    "depth": 16},
   {"term":
    "{V : Type u_1} ‚Üí\n  [inst : NormedAddCommGroup V] ‚Üí\n    [inst_1 : InnerProductSpace ‚Ñù V] ‚Üí\n      [inst_2 : Fact (FiniteDimensional.finrank ‚Ñù V = 2)] ‚Üí Orientation ‚Ñù V (Fin 2) ‚Üí Real.Angle ‚Üí V ‚Üí‚Çó·µ¢[‚Ñù] V",
    "name": "Orientation.rotationAux",
    "doc":
    "Auxiliary construction to build a rotation by the oriented angle `Œ∏`. ",
    "depth": 17}],
  "count": 66},
 {"noDocExamples":
  [{"term":
    "‚àÄ (x : ‚Ñï) (r : ‚Ñù), Metric.closedBall x r = Set.Icc ‚åà‚Üëx - r‚åâ‚Çä ‚åä‚Üëx + r‚åã‚Çä",
    "name": "Nat.closedBall_eq_Icc",
    "depth": 12},
   {"term":
    "‚àÄ {Œ± : Type u_2} [inst : LinearOrderedRing Œ±] [inst_1 : FloorRing Œ±] (a : Œ±), Int.toNat ‚åäa‚åã = ‚åäa‚åã‚Çä",
    "name": "Int.floor_toNat",
    "depth": 12}],
  "kind": "Nat.¬´term‚åä_‚åã‚Çä¬ª",
  "examples":
  [{"term":
    "‚àÄ {Œ± : Type u_2} [inst : LinearOrderedSemifield Œ±] [inst_1 : FloorSemiring Œ±] (m n : ‚Ñï), ‚åä‚Üëm / ‚Üën‚åã‚Çä = m / n",
    "name": "Nat.floor_div_eq_div",
    "doc": "Natural division is the floor of field division. ",
    "depth": 18},
   {"term":
    "‚àÄ (u : ‚Ñï ‚Üí ‚Ñù) (l : ‚Ñù),\n  Monotone u ‚Üí\n    ‚àÄ (c : ‚Ñï ‚Üí ‚Ñù),\n      (‚àÄ (k : ‚Ñï), 1 < c k) ‚Üí\n        Filter.Tendsto c Filter.atTop (nhds 1) ‚Üí\n          (‚àÄ (k : ‚Ñï), Filter.Tendsto (fun n => u ‚åäc k ^ n‚åã‚Çä / ‚Üë‚åäc k ^ n‚åã‚Çä) Filter.atTop (nhds l)) ‚Üí\n            Filter.Tendsto (fun n => u n / ‚Üën) Filter.atTop (nhds l)",
    "name": "tendsto_div_of_monotone_of_tendsto_div_floor_pow",
    "doc":
    "If a monotone sequence `u` is such that `u ‚åäc^n‚åã‚Çä / ‚åäc^n‚åã‚Çä` converges to a limit `l` for all\n`c > 1`, then `u n / n` tends to `l`. It is even enough to have the assumption for a sequence of\n`c`s converging to `1`. ",
    "depth": 22},
   {"term":
    "‚àÄ (N : ‚Ñï) {j : ‚Ñù},\n  0 < j ‚Üí\n    ‚àÄ {c : ‚Ñù},\n      1 < c ‚Üí\n        (Finset.sum (Finset.filter (fun x => j < ‚Üë‚åäc ^ x‚åã‚Çä) (Finset.range N)) fun i => 1 / ‚Üë‚åäc ^ i‚åã‚Çä ^ 2) ‚â§\n          c ^ 5 * (c - 1)‚Åª¬π ^ 3 / j ^ 2",
    "name": "sum_div_nat_floor_pow_sq_le_div_sq",
    "doc":
    "The sum of `1/‚åäc^i‚åã‚Çä^2` above a threshold `j` is comparable to `1/j^2`, up to a multiplicative\nconstant. ",
    "depth": 22}],
  "count": 66},
 {"noDocExamples": [],
  "kind": "OmegaCompletePartialOrder.¬´term_‚ÜíùíÑ_¬ª",
  "examples":
  [{"term": "{Œ± : Type u} ‚Üí [inst : OmegaCompletePartialOrder Œ±] ‚Üí Œ± ‚ÜíùíÑ Œ±",
    "name": "OmegaCompletePartialOrder.ContinuousHom.id",
    "doc": "The identity as a continuous function. ",
    "depth": 6},
   {"term":
    "{Œ± : Type u} ‚Üí\n  {Œ≤ : Type v} ‚Üí [inst : OmegaCompletePartialOrder Œ±] ‚Üí [inst_1 : OmegaCompletePartialOrder Œ≤] ‚Üí (Œ± ‚ÜíùíÑ Œ≤) ‚Üí Œ± ‚Üí Œ≤",
    "name": "OmegaCompletePartialOrder.ContinuousHom.Simps.apply",
    "doc":
    "See Note [custom simps projection]. We specify this explicitly because we don't have a FunLike\ninstance.\n",
    "depth": 9},
   {"term":
    "{Œ± : Type u} ‚Üí {Œ≤ : Type v} ‚Üí [inst : OmegaCompletePartialOrder Œ±] ‚Üí [inst_1 : OmegaCompletePartialOrder Œ≤] ‚Üí Œ≤ ‚Üí Œ± ‚ÜíùíÑ Œ≤",
    "name": "OmegaCompletePartialOrder.ContinuousHom.const",
    "doc": "`Function.const` is a continuous function. ",
    "depth": 9},
   {"term":
    "{Œ± : Type u} ‚Üí [inst : OmegaCompletePartialOrder Œ±] ‚Üí {Œ≤ Œ≥ : Type v} ‚Üí (Œ≤ ‚Üí Œ≥) ‚Üí (Œ± ‚ÜíùíÑ Part Œ≤) ‚Üí Œ± ‚ÜíùíÑ Part Œ≥",
    "name": "OmegaCompletePartialOrder.ContinuousHom.map",
    "doc": "`Part.map` as a continuous function. ",
    "depth": 10},
   {"term":
    "{Œ± : Type u} ‚Üí [inst : OmegaCompletePartialOrder Œ±] ‚Üí {Œ≤ Œ≥ : Type v} ‚Üí (Œ± ‚ÜíùíÑ Part (Œ≤ ‚Üí Œ≥)) ‚Üí (Œ± ‚ÜíùíÑ Part Œ≤) ‚Üí Œ± ‚ÜíùíÑ Part Œ≥",
    "name": "OmegaCompletePartialOrder.ContinuousHom.seq",
    "doc": "`Part.seq` as a continuous function. ",
    "depth": 10}],
  "count": 66},
 {"noDocExamples":
  [{"term":
    "{M : Type u_1} ‚Üí [inst : SubtractionMonoid M·µÉ·µí·µñ] ‚Üí SubtractionMonoid M·µà·µÉ·µÉ",
    "name": "DomAddAct.instDivisionAddMonoidDomAddAct",
    "depth": 4},
   {"term": "{M : Type u_1} ‚Üí [inst : Add M·µÉ·µí·µñ] ‚Üí Add M·µà·µÉ·µÉ",
    "name": "DomAddAct.instAddDomAddAct",
    "depth": 4},
   {"term":
    "{M : Type u_1} ‚Üí [inst : AddRightCancelSemigroup M·µÉ·µí·µñ] ‚Üí AddRightCancelSemigroup M·µà·µÉ·µÉ",
    "name": "DomAddAct.instAddRightCancelSemigroupDomAddAct",
    "depth": 4},
   {"term": "{M : Type u_1} ‚Üí [inst : AddMonoid M·µÉ·µí·µñ] ‚Üí AddMonoid M·µà·µÉ·µÉ",
    "name": "DomAddAct.instAddMonoidDomAddAct",
    "depth": 4}],
  "kind": "¬´term_·µà·µÉ·µÉ¬ª",
  "examples":
  [{"term": "{M : Type u_1} ‚Üí M ‚âÉ M·µà·µÉ·µÉ",
    "name": "DomAddAct.mk",
    "doc": "Equivalence between `M` and `M·µà·µê·µÉ`.",
    "depth": 3}],
  "count": 65},
 {"noDocExamples":
  [{"term":
    "‚àÄ {Œ± : Type u_2} [inst : LinearOrderedRing Œ±] [inst_1 : FloorRing Œ±] (a : Œ±), ‚åäa‚åã ‚â§ ‚åàa‚åâ",
    "name": "Int.floor_le_ceil",
    "depth": 10},
   {"term":
    "‚àÄ {Œ± : Type u_2} [inst : LinearOrderedRing Œ±] [inst_1 : FloorRing Œ±] (a : Œ±), ‚åàa‚åâ ‚â§ ‚åäa‚åã + 1",
    "name": "Int.ceil_le_floor_add_one",
    "depth": 11},
   {"term": "‚àÄ (x : ‚Ñ§) (r : ‚Ñù), Metric.ball x r = Set.Ioo ‚åä‚Üëx - r‚åã ‚åà‚Üëx + r‚åâ",
    "name": "Int.ball_eq_Ioo",
    "depth": 12},
   {"term":
    "‚àÄ (x : ‚Ñ§) (r : ‚Ñù), Metric.closedBall x r = Set.Icc ‚åà‚Üëx - r‚åâ ‚åä‚Üëx + r‚åã",
    "name": "Int.closedBall_eq_Icc",
    "depth": 12}],
  "kind": "Int.¬´term‚åà_‚åâ¬ª",
  "examples":
  [{"term":
    "‚àÄ {Œæ q : ‚Ñö}, |Œæ - q| < 1 / ‚Üëq.den ^ 2 ‚Üí q.den ‚â§ Œæ.den ‚àß ‚åàŒæ * ‚Üëq.den‚åâ - 1 ‚â§ q.num ‚àß q.num ‚â§ ‚åäŒæ * ‚Üëq.den‚åã + 1",
    "name": "Rat.den_le_and_le_num_le_of_sub_lt_one_div_den_sq",
    "doc":
    "If `Œæ` is rational, then the good rational approximations to `Œæ` have bounded\nnumerator and denominator. ",
    "depth": 17}],
  "count": 65},
 {"noDocExamples": [],
  "kind": "Relator.¬´term_‚áí_¬ª",
  "examples":
  [{"term":
    "{Œ± : Sort u_1} ‚Üí\n  {Œ≤ : Sort u_2} ‚Üí\n    {s‚ÇÅ : Setoid Œ±} ‚Üí {s‚ÇÇ : Setoid Œ≤} ‚Üí (f : Œ± ‚Üí Œ≤) ‚Üí (Setoid.r ‚áí Setoid.r) f f ‚Üí Quotient s‚ÇÅ ‚Üí Quotient s‚ÇÇ",
    "name": "Quotient.map'",
    "doc":
    "Map a function `f : Œ± ‚Üí Œ≤` that sends equivalent elements to equivalent elements\nto a function `Quotient sa ‚Üí Quotient sb`. Useful to define unary operations on quotients. ",
    "depth": 14},
   {"term":
    "{Œ± : Sort u_1} ‚Üí\n  {Œ≤ : Sort u_2} ‚Üí {ra : Œ± ‚Üí Œ± ‚Üí Prop} ‚Üí {rb : Œ≤ ‚Üí Œ≤ ‚Üí Prop} ‚Üí (f : Œ± ‚Üí Œ≤) ‚Üí (ra ‚áí rb) f f ‚Üí Quot ra ‚Üí Quot rb",
    "name": "Quot.map",
    "doc":
    "Map a function `f : Œ± ‚Üí Œ≤` such that `ra x y` implies `rb (f x) (f y)`\nto a map `Quot ra ‚Üí Quot rb`. ",
    "depth": 14},
   {"term":
    "{Œ± : Type u_1} ‚Üí\n  {Œ≤ : Type u_2} ‚Üí\n    {l : Filter Œ±} ‚Üí\n      {Œ≥ : Sort u_5} ‚Üí Filter.Germ l Œ≤ ‚Üí (F : (Œ± ‚Üí Œ≤) ‚Üí Œ≥) ‚Üí (Filter.EventuallyEq l ‚áí fun x x_1 => x = x_1) F F ‚Üí Œ≥",
    "name": "Filter.Germ.liftOn",
    "doc":
    "Given a germ `f : Germ l Œ≤` and a function `F : (Œ± ‚Üí Œ≤) ‚Üí Œ≥` sending eventually equal functions\nto the same value, returns the value `F` takes on functions having germ `f` at `l`. ",
    "depth": 16},
   {"term":
    "{Œ± : Sort u_1} ‚Üí\n  {Œ≤ : Sort u_2} ‚Üí\n    {Œ≥ : Sort u_3} ‚Üí\n      {s‚ÇÅ : Setoid Œ±} ‚Üí\n        {s‚ÇÇ : Setoid Œ≤} ‚Üí\n          {s‚ÇÉ : Setoid Œ≥} ‚Üí\n            (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) ‚Üí (Setoid.r ‚áí Setoid.r ‚áí Setoid.r) f f ‚Üí Quotient s‚ÇÅ ‚Üí Quotient s‚ÇÇ ‚Üí Quotient s‚ÇÉ",
    "name": "Quotient.map‚ÇÇ'",
    "doc": "A version of `Quotient.map‚ÇÇ` using curly braces and unification. ",
    "depth": 17},
   {"term":
    "{Œ± : Type u_1} ‚Üí\n  {Œ≤ : Type u_2} ‚Üí\n    {Œ≥ : Type u_3} ‚Üí\n      {Œ¥ : Type u_4} ‚Üí\n        {l : Filter Œ±} ‚Üí\n          {lc : Filter Œ≥} ‚Üí\n            (F : (Œ± ‚Üí Œ≤) ‚Üí Œ≥ ‚Üí Œ¥) ‚Üí\n              (Filter.EventuallyEq l ‚áí Filter.EventuallyEq lc) F F ‚Üí Filter.Germ l Œ≤ ‚Üí Filter.Germ lc Œ¥",
    "name": "Filter.Germ.map'",
    "doc":
    "Given a map `F : (Œ± ‚Üí Œ≤) ‚Üí (Œ≥ ‚Üí Œ¥)` that sends functions eventually equal at `l` to functions\neventually equal at `lc`, returns a map from `Germ l Œ≤` to `Germ lc Œ¥`. ",
    "depth": 17}],
  "count": 64},
 {"noDocExamples": [],
  "kind": "¬´termÔø¢_¬ª",
  "examples":
  [{"term": "‚àÄ {Œ± : Type u_4} [self : CoheytingAlgebra Œ±] (a : Œ±), ‚ä§ \\ a = Ôø¢a",
    "name": "CoheytingAlgebra.top_sdiff",
    "doc": "`‚ä§ \\ a` is `Ôø¢a` ",
    "depth": 11},
   {"term": "‚àÄ {Œ± : Type u_4} [self : BiheytingAlgebra Œ±] (a : Œ±), ‚ä§ \\ a = Ôø¢a",
    "name": "BiheytingAlgebra.top_sdiff",
    "doc": "`‚ä§ \\ a` is `Ôø¢a` ",
    "depth": 12},
   {"term":
    "‚àÄ {Œ± : Type u_2} [inst : CoheytingAlgebra Œ±] {a b : Œ±}, Codisjoint b a ‚Üí Ôø¢a ‚â§ b",
    "name": "Codisjoint.hnot_le_left",
    "doc":
    "**Alias** of the reverse direction of `hnot_le_iff_codisjoint_left`.",
    "depth": 17},
   {"term":
    "‚àÄ {Œ± : Type u_2} [inst : CoheytingAlgebra Œ±] {a b : Œ±}, Codisjoint a b ‚Üí Ôø¢a ‚â§ b",
    "name": "Codisjoint.hnot_le_right",
    "doc":
    "**Alias** of the reverse direction of `hnot_le_iff_codisjoint_right`.",
    "depth": 17},
   {"term":
    "{Œ± : Type u_2} ‚Üí\n  {Œ≤ : Type u_3} ‚Üí\n    [inst : Sup Œ±] ‚Üí\n      [inst_1 : Inf Œ±] ‚Üí\n        [inst_2 : Top Œ±] ‚Üí\n          [inst_3 : Bot Œ±] ‚Üí\n            [inst_4 : HNot Œ±] ‚Üí\n              [inst_5 : SDiff Œ±] ‚Üí\n                [inst_6 : CoheytingAlgebra Œ≤] ‚Üí\n                  (f : Œ± ‚Üí Œ≤) ‚Üí\n                    Function.Injective f ‚Üí\n                      (‚àÄ (a b : Œ±), f (a ‚äî b) = f a ‚äî f b) ‚Üí\n                        (‚àÄ (a b : Œ±), f (a ‚äì b) = f a ‚äì f b) ‚Üí\n                          f ‚ä§ = ‚ä§ ‚Üí\n                            f ‚ä• = ‚ä• ‚Üí\n                              (‚àÄ (a : Œ±), f (Ôø¢a) = Ôø¢f a) ‚Üí (‚àÄ (a b : Œ±), f (a \\ b) = f a \\ f b) ‚Üí CoheytingAlgebra Œ±",
    "name": "Function.Injective.coheytingAlgebra",
    "doc": "Pullback a `CoheytingAlgebra` along an injection. ",
    "depth": 26}],
  "count": 64},
 {"noDocExamples":
  [{"term":
    "‚àÄ (n : ‚Ñï), Nat.div2 (Nat.succ n) = bif Nat.bodd n then Nat.succ (Nat.div2 n) else Nat.div2 n",
    "name": "Nat.div2_succ",
    "depth": 6},
   {"term": "‚àÄ {Œ± : Type u} (b : Bool) (a : Œ±), (bif b then a else a) = a",
    "name": "Bool.cond_self",
    "depth": 9},
   {"term":
    "‚àÄ (f : Bool ‚Üí Bool ‚Üí Bool), f false false = false ‚Üí ‚àÄ (m : ‚Ñï), Nat.bitwise' f m 0 = bif f true false then m else 0",
    "name": "Nat.bitwise'_zero_right",
    "depth": 9},
   {"term": "‚àÄ (n : ‚Ñï), n % 2 = bif Nat.bodd n then 1 else 0",
    "name": "Nat.mod_two_of_bodd",
    "depth": 9}],
  "kind": "boolIfThenElse",
  "examples":
  [{"term":
    "‚àÄ (p : ENNReal) (h : p ‚â§ 1), Pmf.binomial p h 1 = Pmf.map (fun x => bif x then 1 else 0) (Pmf.bernoulli p h)",
    "name": "Pmf.binomial_one_eq_bernoulli",
    "doc":
    "The binomial distribution on one coin is the bernoully distribution. ",
    "depth": 18}],
  "count": 63},
 {"noDocExamples": [],
  "kind": "Lean.Parser.Term.let_fun",
  "examples":
  [{"term":
    "(V W : SemiNormedGroupCat) ‚Üí\n  let_fun this := fun V W => inferInstanceAs (AddGroup (NormedAddGroupHom ‚ÜëV ‚ÜëW));\n  (V ‚ü∂ W) ‚Üí+ (SemiNormedGroupCat.completion.obj V ‚ü∂ SemiNormedGroupCat.completion.obj W)",
    "name": "SemiNormedGroupCat.completion.mapHom",
    "doc":
    "Given a normed group hom `V ‚ü∂ W`, this defines the associated morphism\nfrom the completion of `V` to the completion of `W`.\nThe difference from the definition obtained from the functoriality of completion is in that the\nmap sending a morphism `f` to the associated morphism of completions is itself additive. ",
    "depth": 20},
   {"term":
    "‚àÄ {Œπ : Type u_1} {B : Type u_2} {F : Type u_3} [inst : TopologicalSpace B] [inst_1 : TopologicalSpace F]\n  (Z : FiberBundleCore Œπ B F) (v : F),\n  (‚àÄ (i j : Œπ) (x : B),\n      x ‚àà FiberBundleCore.baseSet Z i ‚à© FiberBundleCore.baseSet Z j ‚Üí FiberBundleCore.coordChange Z i j x v = v) ‚Üí\n    Continuous\n      (let_fun this := fun x => { proj := x, snd := v };\n      this)",
    "name": "FiberBundleCore.continuous_const_section",
    "doc":
    "If an element of `F` is invariant under all coordinate changes, then one can define a\ncorresponding section of the fiber bundle, which is continuous. This applies in particular to the\nzero section of a vector bundle. Another example (not yet defined) would be the identity\nsection of the endomorphism bundle of a vector bundle. ",
    "depth": 24},
   {"term":
    "{R : Type u‚ÇÅ} ‚Üí\n  {S : Type u‚ÇÇ} ‚Üí\n    [inst : CommRing R] ‚Üí\n      [inst_1 : CommRing S] ‚Üí\n        (f : R ‚Üí+* S) ‚Üí\n          {X : ModuleCat R} ‚Üí\n            {Y : ModuleCat S} ‚Üí\n              S ‚Üí\n                (X ‚ü∂ (CategoryTheory.ModuleCat.restrictScalars f).obj Y) ‚Üí\n                  let_fun this := Module.compHom (‚ÜëY) f;\n                  ‚ÜëX ‚Üí‚Çó[R] ‚ÜëY",
    "name": "CategoryTheory.ModuleCat.ExtendRestrictScalarsAdj.HomEquiv.evalAt",
    "doc": "The map `S ‚Üí X ‚Üí‚Çó[R] Y` given by `fun s x => s ‚Ä¢ (g x)`\n",
    "depth": 24},
   {"term":
    "‚àÄ {R : Type u} {œÉ : Type u_1} [inst : CommSemiring R] {M : MvPolynomial œÉ R ‚Üí Prop} (p : MvPolynomial œÉ R),\n  (‚àÄ (a : R), M (‚ÜëMvPolynomial.C a)) ‚Üí\n    (‚àÄ (a : œÉ ‚Üí‚ÇÄ ‚Ñï) (b : R) (f : (œÉ ‚Üí‚ÇÄ ‚Ñï) ‚Üí‚ÇÄ R),\n        ¬¨a ‚àà f.support ‚Üí\n          b ‚â† 0 ‚Üí\n            M f ‚Üí\n              M\n                ((let_fun this := ‚Üë(MvPolynomial.monomial a) b;\n                  this) +\n                  f)) ‚Üí\n      M p",
    "name": "MvPolynomial.induction_on'''",
    "doc":
    "Similar to `MvPolynomial.induction_on` but only a weak form of `h_add` is required.",
    "depth": 35},
   {"term":
    "‚àÄ {R : Type u} {œÉ : Type u_1} [inst : CommSemiring R] {M : MvPolynomial œÉ R ‚Üí Prop} (p : MvPolynomial œÉ R),\n  (‚àÄ (a : R), M (‚ÜëMvPolynomial.C a)) ‚Üí\n    (‚àÄ (a : œÉ ‚Üí‚ÇÄ ‚Ñï) (b : R) (f : (œÉ ‚Üí‚ÇÄ ‚Ñï) ‚Üí‚ÇÄ R),\n        ¬¨a ‚àà f.support ‚Üí\n          b ‚â† 0 ‚Üí\n            M f ‚Üí\n              M (‚Üë(MvPolynomial.monomial a) b) ‚Üí\n                M\n                  ((let_fun this := ‚Üë(MvPolynomial.monomial a) b;\n                    this) +\n                    f)) ‚Üí\n      (‚àÄ (p : MvPolynomial œÉ R) (n : œÉ), M p ‚Üí M (p * MvPolynomial.X n)) ‚Üí M p",
    "name": "MvPolynomial.induction_on''",
    "doc":
    "Similar to `MvPolynomial.induction_on` but only a yet weaker form of `h_add` is required.",
    "depth": 36}],
  "count": 63},
 {"noDocExamples": [],
  "kind": "¬´term_‚â∫i_¬ª",
  "examples":
  [{"term": "EmptyRelation ‚â∫i EmptyRelation",
    "name": "PrincipalSeg.pemptyToPunit",
    "doc":
    "Principal segment from the empty relation on `PEmpty` to the empty relation on `PUnit`. ",
    "depth": 4},
   {"term":
    "{Œ± : Type u_4} ‚Üí {Œ≤ : Type u_5} ‚Üí {r : Œ± ‚Üí Œ± ‚Üí Prop} ‚Üí {s : Œ≤ ‚Üí Œ≤ ‚Üí Prop} ‚Üí r ‚â∫i s ‚Üí Œ≤",
    "name": "PrincipalSeg.top",
    "doc": "The supremum of the principal segment ",
    "depth": 9},
   {"term": "(fun x x_1 => x < x_1) ‚â∫i fun x x_1 => x < x_1",
    "name": "Ordinal.lift.principalSeg",
    "doc":
    "Principal segment version of the lift operation on ordinals, embedding `ordinal.{u}` in\n`ordinal.{v}` as a principal segment when `u < v`. ",
    "depth": 10},
   {"term":
    "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {r : Œ± ‚Üí Œ± ‚Üí Prop} {s : Œ≤ ‚Üí Œ≤ ‚Üí Prop} [inst : IsWellOrder Œ≤ s], Subsingleton (r ‚â∫i s)",
    "name": "PrincipalSeg.instSubsingletonPrincipalSeg",
    "doc":
    "Given a well order `s`, there is a most one principal segment embedding of `r` into `s`. ",
    "depth": 10},
   {"term":
    "{Œ± : Type u_1} ‚Üí\n  {Œ≤ : Type u_2} ‚Üí\n    {s : Œ≤ ‚Üí Œ≤ ‚Üí Prop} ‚Üí (r : Œ± ‚Üí Œ± ‚Üí Prop) ‚Üí [inst : IsEmpty Œ±] ‚Üí {b : Œ≤} ‚Üí (‚àÄ (b' : Œ≤), ¬¨s b' b) ‚Üí r ‚â∫i s",
    "name": "PrincipalSeg.ofIsEmpty",
    "doc":
    "Principal segment from an empty type into a type with a minimal element. ",
    "depth": 11}],
  "count": 62},
 {"noDocExamples":
  [{"term":
    "‚àÄ (m n k : ‚Ñï),\n  Nat.psub m (n + k) = do\n    let __do_lift ‚Üê Nat.psub m n\n    Nat.psub __do_lift k",
    "name": "Nat.psub_add",
    "depth": 12},
   {"term":
    "‚àÄ {f : Turing.ToPartrec.Code} {k : Turing.ToPartrec.Cont} {v : List ‚Ñï},\n  Turing.ToPartrec.Code.Ok f ‚Üí\n    Turing.eval Turing.ToPartrec.step (Turing.ToPartrec.stepNormal f (Turing.ToPartrec.Cont.fix f k) v) = do\n      let v ‚Üê Turing.ToPartrec.Code.eval (Turing.ToPartrec.Code.fix f) v\n      Turing.eval Turing.ToPartrec.step (Turing.ToPartrec.Cfg.ret k v)",
    "name": "Turing.ToPartrec.cont_eval_fix",
    "depth": 12}],
  "kind": "Lean.Parser.Term.do",
  "examples":
  [{"term":
    "‚àÄ (cf cg : Nat.Partrec.Code) (a k : ‚Ñï),\n  Nat.Partrec.Code.eval (Nat.Partrec.Code.prec cf cg) (Nat.pair a (Nat.succ k)) = do\n    let ih ‚Üê Nat.Partrec.Code.eval (Nat.Partrec.Code.prec cf cg) (Nat.pair a k)\n    Nat.Partrec.Code.eval cg (Nat.pair a (Nat.pair k ih))",
    "name": "Nat.Partrec.Code.eval_prec_succ",
    "doc": "Helper lemma for the evaluation of `prec` in the recursive case. ",
    "depth": 12},
   {"term":
    "‚àÄ (m : Type u ‚Üí Type v) [inst : Monad m],\n  (‚àÄ {Œ± : Type u} (x : m Œ±), id <$> x = x) ‚Üí\n    (‚àÄ {Œ± Œ≤ : Type u} (x : Œ±) (f : Œ± ‚Üí m Œ≤), pure x >>= f = f x) ‚Üí\n      (‚àÄ {Œ± Œ≤ Œ≥ : Type u} (x : m Œ±) (f : Œ± ‚Üí m Œ≤) (g : Œ≤ ‚Üí m Œ≥), x >>= f >>= g = x >>= fun x => f x >>= g) ‚Üí\n        autoParam (‚àÄ {Œ± Œ≤ : Type u} (x : Œ±) (y : m Œ≤), Functor.mapConst x y = Function.const Œ≤ x <$> y) _auto‚úù ‚Üí\n          autoParam\n              (‚àÄ {Œ± Œ≤ : Type u} (x : m Œ±) (y : m Œ≤),\n                (SeqLeft.seqLeft x fun x => y) = do\n                  let a ‚Üê x\n                  let _ ‚Üê y\n                  pure a)\n              _auto‚úù¬π ‚Üí\n            autoParam\n                (‚àÄ {Œ± Œ≤ : Type u} (x : m Œ±) (y : m Œ≤),\n                  (SeqRight.seqRight x fun x => y) = do\n                    let _ ‚Üê x\n                    y)\n                _auto‚úù¬≤ ‚Üí\n              autoParam\n                  (‚àÄ {Œ± Œ≤ : Type u} (f : Œ± ‚Üí Œ≤) (x : m Œ±),\n                    (do\n                        let y ‚Üê x\n                        pure (f y)) =\n                      f <$> x)\n                  _auto‚úù¬≥ ‚Üí\n                autoParam\n                    (‚àÄ {Œ± Œ≤ : Type u} (f : m (Œ± ‚Üí Œ≤)) (x : m Œ±),\n                      (do\n                          let x_1 ‚Üê f\n                          x_1 <$> x) =\n                        Seq.seq f fun x_1 => x)\n                    _auto‚úù‚Å¥ ‚Üí\n                  LawfulMonad m",
    "name": "LawfulMonad.mk'",
    "doc":
    "An alternative constructor for `LawfulMonad` which has more\ndefaultable fields in the common case.\n",
    "depth": 28},
   {"term":
    "Bool ‚Üí\n  List Lean.Expr ‚Üí\n    optParam Linarith.LinarithConfig\n        {\n          discharger := do\n            let __do_lift ‚Üê\n              do\n                let info ‚Üê Lean.MonadRef.mkInfoFromRefPos\n                let _ ‚Üê Lean.getCurrMacroScope\n                let _ ‚Üê Lean.getMainModule\n                pure { raw := Lean.Syntax.node1 info `Mathlib.Tactic.RingNF.ring (Lean.Syntax.atom info \"ring\") }\n            Lean.Elab.Tactic.evalTactic __do_lift.raw,\n          exfalso := true, transparency := Lean.Meta.TransparencyMode.reducible, splitHypotheses := true,\n          splitNe := false, preprocessors := none, oracle := none } ‚Üí\n      Lean.MVarId ‚Üí Lean.MetaM Unit",
    "name": "Linarith.linarith",
    "doc":
    "`linarith only_on hyps cfg` tries to close the goal using linear arithmetic. It fails\nif it does not succeed at doing this.\n\n* `hyps` is a list of proofs of comparisons to include in the search.\n* If `only_on` is true, the search will be restricted to `hyps`. Otherwise it will use all\n  comparisons in the local context.\n* If `cfg.transparency := semireducible`,\n  it will unfold semireducible definitions when trying to match atomic expressions.\n",
    "depth": 33}],
  "count": 62},
 {"noDocExamples": [],
  "kind": "¬´term_‚Üí‚Çõ‚Çó·µ¢[_]_¬ª",
  "examples":
  [{"term":
    "{R : Type u_1} ‚Üí\n  {R‚ÇÇ : Type u_2} ‚Üí\n    [inst : Semiring R] ‚Üí\n      [inst_1 : Semiring R‚ÇÇ] ‚Üí\n        (œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ) ‚Üí\n          (E : Type u_11) ‚Üí\n            (E‚ÇÇ : Type u_12) ‚Üí\n              [inst_2 : SeminormedAddCommGroup E] ‚Üí\n                [inst_3 : SeminormedAddCommGroup E‚ÇÇ] ‚Üí\n                  [inst_4 : Module R E] ‚Üí [inst_5 : Module R‚ÇÇ E‚ÇÇ] ‚Üí (E ‚Üí‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ) ‚Üí E ‚Üí E‚ÇÇ",
    "name": "LinearIsometry.Simps.apply",
    "doc":
    "See Note [custom simps projection]. We need to specify this projection explicitly in this case,\nbecause it is a composition of multiple projections. ",
    "depth": 23},
   {"term":
    "{R : Type u_1} ‚Üí\n  {R‚ÇÇ : Type u_2} ‚Üí\n    {E : Type u_5} ‚Üí\n      {E‚ÇÇ : Type u_6} ‚Üí\n        [inst : Semiring R] ‚Üí\n          [inst_1 : Semiring R‚ÇÇ] ‚Üí\n            {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} ‚Üí\n              [inst_2 : SeminormedAddCommGroup E] ‚Üí\n                [inst_3 : SeminormedAddCommGroup E‚ÇÇ] ‚Üí\n                  [inst_4 : Module R E] ‚Üí [inst_5 : Module R‚ÇÇ E‚ÇÇ] ‚Üí (E ‚Üí‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ) ‚Üí E ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ",
    "name": "LinearIsometry.toContinuousLinearMap",
    "doc": "Interpret a linear isometry as a continuous linear map. ",
    "depth": 25},
   {"term":
    "{R : Type u_1} ‚Üí\n  {R‚ÇÇ : Type u_2} ‚Üí\n    {E : Type u_5} ‚Üí\n      {E‚ÇÇ : Type u_6} ‚Üí\n        [inst : Semiring R] ‚Üí\n          [inst_1 : Semiring R‚ÇÇ] ‚Üí\n            {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} ‚Üí\n              {œÉ‚ÇÇ‚ÇÅ : R‚ÇÇ ‚Üí+* R} ‚Üí\n                [inst_2 : RingHomInvPair œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÅ] ‚Üí\n                  [inst_3 : RingHomInvPair œÉ‚ÇÇ‚ÇÅ œÉ‚ÇÅ‚ÇÇ] ‚Üí\n                    [inst_4 : SeminormedAddCommGroup E] ‚Üí\n                      [inst_5 : SeminormedAddCommGroup E‚ÇÇ] ‚Üí\n                        [inst_6 : Module R E] ‚Üí [inst_7 : Module R‚ÇÇ E‚ÇÇ] ‚Üí (E ‚âÉ‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ) ‚Üí E ‚Üí‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ",
    "name": "LinearIsometryEquiv.toLinearIsometry",
    "doc": "Reinterpret a `LinearIsometryEquiv` as a `LinearIsometry`. ",
    "depth": 29},
   {"term":
    "{R : Type u_1} ‚Üí\n  {R‚ÇÇ : Type u_2} ‚Üí\n    {E : Type u_5} ‚Üí\n      {E‚ÇÇ : Type u_6} ‚Üí\n        [inst : Semiring R] ‚Üí\n          [inst_1 : Semiring R‚ÇÇ] ‚Üí\n            {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} ‚Üí\n              [inst_2 : SeminormedAddCommGroup E] ‚Üí\n                [inst_3 : SeminormedAddCommGroup E‚ÇÇ] ‚Üí\n                  [inst_4 : Module R E] ‚Üí [inst_5 : Module R‚ÇÇ E‚ÇÇ] ‚Üí (f : E ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ) ‚Üí Isometry ‚Üëf ‚Üí E ‚Üí‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ",
    "name": "LinearMap.toLinearIsometry",
    "doc":
    "Construct a `LinearIsometry` from a `LinearMap` satisfying `Isometry`. ",
    "depth": 30},
   {"term":
    "{R : Type u_1} ‚Üí\n  {R‚ÇÇ : Type u_2} ‚Üí\n    {R‚ÇÉ : Type u_3} ‚Üí\n      {E : Type u_5} ‚Üí\n        {E‚ÇÇ : Type u_6} ‚Üí\n          {E‚ÇÉ : Type u_7} ‚Üí\n            [inst : Semiring R] ‚Üí\n              [inst_1 : Semiring R‚ÇÇ] ‚Üí\n                [inst_2 : Semiring R‚ÇÉ] ‚Üí\n                  {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} ‚Üí\n                    {œÉ‚ÇÅ‚ÇÉ : R ‚Üí+* R‚ÇÉ} ‚Üí\n                      {œÉ‚ÇÇ‚ÇÉ : R‚ÇÇ ‚Üí+* R‚ÇÉ} ‚Üí\n                        [inst_3 : RingHomCompTriple œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÉ œÉ‚ÇÅ‚ÇÉ] ‚Üí\n                          [inst_4 : SeminormedAddCommGroup E] ‚Üí\n                            [inst_5 : SeminormedAddCommGroup E‚ÇÇ] ‚Üí\n                              [inst_6 : SeminormedAddCommGroup E‚ÇÉ] ‚Üí\n                                [inst_7 : Module R E] ‚Üí\n                                  [inst_8 : Module R‚ÇÇ E‚ÇÇ] ‚Üí\n                                    [inst_9 : Module R‚ÇÉ E‚ÇÉ] ‚Üí (E‚ÇÇ ‚Üí‚Çõ‚Çó·µ¢[œÉ‚ÇÇ‚ÇÉ] E‚ÇÉ) ‚Üí (E ‚Üí‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ) ‚Üí E ‚Üí‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÉ] E‚ÇÉ",
    "name": "LinearIsometry.comp",
    "doc": "Composition of linear isometries. ",
    "depth": 32}],
  "count": 62},
 {"noDocExamples": [],
  "kind": "Vector.¬´term_::·µ•_¬ª",
  "examples":
  [{"term":
    "‚àÄ {Œ± : Type u} {n : ‚Ñï} (a : Œ±) (v : Vector Œ± n), Vector.toList (a ::·µ• v) = a :: Vector.toList v",
    "name": "Vector.toList_cons",
    "doc":
    "`toList` of `cons` of a vector and an element is\nthe `cons` of the list obtained by `toList` and the element ",
    "depth": 11},
   {"term":
    "‚àÄ {Œ± : Type u} {n : ‚Ñï} (a : Œ±) (v : Vector Œ± n), Vector.head (a ::·µ• v) = a",
    "name": "Vector.head_cons",
    "doc":
    "The head of a vector obtained by prepending is the element prepended. ",
    "depth": 11},
   {"term":
    "‚àÄ {Œ± : Type u_1} {ix : Fin 1} (x : Œ±), Vector.get (x ::·µ• Vector.nil) ix = x",
    "name": "Vector.get_cons_nil",
    "doc":
    "Accessing the nth element of a vector made up\nof one element `x : Œ±` is `x` itself. ",
    "depth": 13},
   {"term":
    "‚àÄ {Œ± : Type u} {Œ≤ : Type v} {n : ‚Ñï} (f : Œ± ‚Üí Œ≤) (a : Œ±) (v : Vector Œ± n),\n  Vector.map f (a ::·µ• v) = f a ::·µ• Vector.map f v",
    "name": "Vector.map_cons",
    "doc": "`map` is natural with respect to `cons`. ",
    "depth": 13},
   {"term":
    "‚àÄ {Œ± : Type u} {n : ‚Ñï} (a : Œ±) (v : Vector Œ± n), Vector.tail (a ::·µ• v) = v",
    "name": "Vector.tail_cons",
    "doc":
    "The tail of a vector obtained by prepending is the vector prepended. to ",
    "depth": 14}],
  "count": 60},
 {"noDocExamples": [],
  "kind": "¬´term_‚âÉ._¬ª",
  "examples":
  [{"term": "(Œ± : Type u_1) ‚Üí Œ± ‚âÉ. Œ±",
    "name": "PEquiv.refl",
    "doc": "The identity map as a partial equivalence. ",
    "depth": 3},
   {"term": "{Œ± : Type u} ‚Üí {Œ≤ : Type v} ‚Üí (Œ± ‚âÉ. Œ≤) ‚Üí Œ± ‚Üí Option Œ≤",
    "name": "PEquiv.toFun",
    "doc": "The underlying partial function of a `PEquiv` ",
    "depth": 5},
   {"term": "{Œ± : Type u_1} ‚Üí {Œ≤ : Type u_2} ‚Üí Œ± ‚âÉ Œ≤ ‚Üí Œ± ‚âÉ. Œ≤",
    "name": "Equiv.toPEquiv",
    "doc": "Turns an `Equiv` into a `PEquiv` of the whole type. ",
    "depth": 5},
   {"term": "{Œ± : Type u} ‚Üí {Œ≤ : Type v} ‚Üí (Œ± ‚âÉ. Œ≤) ‚Üí Œ≤ ‚âÉ. Œ±",
    "name": "PEquiv.symm",
    "doc": "The inverse partial equivalence. ",
    "depth": 5},
   {"term": "{Œ± : Type u} ‚Üí {Œ≤ : Type v} ‚Üí (Œ± ‚âÉ. Œ≤) ‚Üí Œ≤ ‚Üí Option Œ±",
    "name": "PEquiv.invFun",
    "doc": "The partial inverse of `toFun` ",
    "depth": 5}],
  "count": 59},
 {"noDocExamples": [],
  "kind": "¬´term_‚âÉ‚Çõ‚Çó·µ¢[_]_¬ª",
  "examples":
  [{"term":
    "{R : Type u_1} ‚Üí\n  {R‚ÇÇ : Type u_2} ‚Üí\n    {E : Type u_5} ‚Üí\n      {E‚ÇÇ : Type u_6} ‚Üí\n        [inst : Semiring R] ‚Üí\n          [inst_1 : Semiring R‚ÇÇ] ‚Üí\n            {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} ‚Üí\n              {œÉ‚ÇÇ‚ÇÅ : R‚ÇÇ ‚Üí+* R} ‚Üí\n                [inst_2 : RingHomInvPair œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÅ] ‚Üí\n                  [inst_3 : RingHomInvPair œÉ‚ÇÇ‚ÇÅ œÉ‚ÇÅ‚ÇÇ] ‚Üí\n                    [inst_4 : SeminormedAddCommGroup E] ‚Üí\n                      [inst_5 : SeminormedAddCommGroup E‚ÇÇ] ‚Üí\n                        [inst_6 : Module R E] ‚Üí [inst_7 : Module R‚ÇÇ E‚ÇÇ] ‚Üí (E ‚âÉ‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ) ‚Üí E‚ÇÇ ‚âÉ‚Çõ‚Çó·µ¢[œÉ‚ÇÇ‚ÇÅ] E",
    "name": "LinearIsometryEquiv.symm",
    "doc": "The inverse `LinearIsometryEquiv`. ",
    "depth": 29},
   {"term":
    "{R : Type u_1} ‚Üí\n  {R‚ÇÇ : Type u_2} ‚Üí\n    [inst : Semiring R] ‚Üí\n      [inst_1 : Semiring R‚ÇÇ] ‚Üí\n        (œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ) ‚Üí\n          {œÉ‚ÇÇ‚ÇÅ : R‚ÇÇ ‚Üí+* R} ‚Üí\n            [inst_2 : RingHomInvPair œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÅ] ‚Üí\n              [inst_3 : RingHomInvPair œÉ‚ÇÇ‚ÇÅ œÉ‚ÇÅ‚ÇÇ] ‚Üí\n                (E : Type u_11) ‚Üí\n                  (E‚ÇÇ : Type u_12) ‚Üí\n                    [inst_4 : SeminormedAddCommGroup E] ‚Üí\n                      [inst_5 : SeminormedAddCommGroup E‚ÇÇ] ‚Üí\n                        [inst_6 : Module R E] ‚Üí [inst_7 : Module R‚ÇÇ E‚ÇÇ] ‚Üí (E ‚âÉ‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ) ‚Üí E‚ÇÇ ‚Üí E",
    "name": "LinearIsometryEquiv.Simps.symm_apply",
    "doc": "See Note [custom simps projection] ",
    "depth": 29},
   {"term":
    "{R : Type u_1} ‚Üí\n  {R‚ÇÇ : Type u_2} ‚Üí\n    {E : Type u_5} ‚Üí\n      {E‚ÇÇ : Type u_6} ‚Üí\n        [inst : Semiring R] ‚Üí\n          [inst_1 : Semiring R‚ÇÇ] ‚Üí\n            {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} ‚Üí\n              {œÉ‚ÇÇ‚ÇÅ : R‚ÇÇ ‚Üí+* R} ‚Üí\n                [inst_2 : RingHomInvPair œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÅ] ‚Üí\n                  [inst_3 : RingHomInvPair œÉ‚ÇÇ‚ÇÅ œÉ‚ÇÅ‚ÇÇ] ‚Üí\n                    [inst_4 : SeminormedAddCommGroup E] ‚Üí\n                      [inst_5 : SeminormedAddCommGroup E‚ÇÇ] ‚Üí\n                        [inst_6 : Module R E] ‚Üí [inst_7 : Module R‚ÇÇ E‚ÇÇ] ‚Üí (E ‚âÉ‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ) ‚Üí E ‚Üí‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ",
    "name": "LinearIsometryEquiv.toLinearIsometry",
    "doc": "Reinterpret a `LinearIsometryEquiv` as a `LinearIsometry`. ",
    "depth": 29},
   {"term":
    "{R : Type u_1} ‚Üí\n  {R‚ÇÇ : Type u_2} ‚Üí\n    {E : Type u_5} ‚Üí\n      {E‚ÇÇ : Type u_6} ‚Üí\n        [inst : Semiring R] ‚Üí\n          [inst_1 : Semiring R‚ÇÇ] ‚Üí\n            {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} ‚Üí\n              {œÉ‚ÇÇ‚ÇÅ : R‚ÇÇ ‚Üí+* R} ‚Üí\n                [inst_2 : RingHomInvPair œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÅ] ‚Üí\n                  [inst_3 : RingHomInvPair œÉ‚ÇÇ‚ÇÅ œÉ‚ÇÅ‚ÇÇ] ‚Üí\n                    [inst_4 : SeminormedAddCommGroup E] ‚Üí\n                      [inst_5 : SeminormedAddCommGroup E‚ÇÇ] ‚Üí\n                        [inst_6 : Module R E] ‚Üí [inst_7 : Module R‚ÇÇ E‚ÇÇ] ‚Üí (E ‚âÉ‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ) ‚Üí E ‚âÉ·µ¢ E‚ÇÇ",
    "name": "LinearIsometryEquiv.toIsometryEquiv",
    "doc": "Reinterpret a `LinearIsometryEquiv` as an `IsometryEquiv`. ",
    "depth": 29},
   {"term":
    "{R : Type u_1} ‚Üí\n  {R‚ÇÇ : Type u_2} ‚Üí\n    [inst : Semiring R] ‚Üí\n      [inst_1 : Semiring R‚ÇÇ] ‚Üí\n        (œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ) ‚Üí\n          {œÉ‚ÇÇ‚ÇÅ : R‚ÇÇ ‚Üí+* R} ‚Üí\n            [inst_2 : RingHomInvPair œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÅ] ‚Üí\n              [inst_3 : RingHomInvPair œÉ‚ÇÇ‚ÇÅ œÉ‚ÇÅ‚ÇÇ] ‚Üí\n                (E : Type u_11) ‚Üí\n                  (E‚ÇÇ : Type u_12) ‚Üí\n                    [inst_4 : SeminormedAddCommGroup E] ‚Üí\n                      [inst_5 : SeminormedAddCommGroup E‚ÇÇ] ‚Üí\n                        [inst_6 : Module R E] ‚Üí [inst_7 : Module R‚ÇÇ E‚ÇÇ] ‚Üí (E ‚âÉ‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ) ‚Üí E ‚Üí E‚ÇÇ",
    "name": "LinearIsometryEquiv.Simps.apply",
    "doc":
    "See Note [custom simps projection]. We need to specify this projection explicitly in this case,\nbecause it is a composition of multiple projections. ",
    "depth": 29}],
  "count": 58},
 {"noDocExamples": [],
  "kind": "¬´FreimanHomLocal‚â∫¬ª",
  "examples":
  [{"term":
    "{Œ± : Type u_2} ‚Üí [inst : CommMonoid Œ±] ‚Üí (A : Set Œ±) ‚Üí (n : ‚Ñï) ‚Üí A ‚Üí*[n] Œ±",
    "name": "FreimanHom.id",
    "doc": "The identity map from a commutative monoid to itself. ",
    "depth": 10},
   {"term":
    "{Œ± : Type u_2} ‚Üí\n  {Œ≤ : Type u_3} ‚Üí [inst : CommMonoid Œ±] ‚Üí [inst_1 : CommMonoid Œ≤] ‚Üí {A : Set Œ±} ‚Üí {n : ‚Ñï} ‚Üí CommMonoid (A ‚Üí*[n] Œ≤)",
    "name": "FreimanHom.commMonoid",
    "doc": "`A ‚Üí*[n] Œ≤` is a `CommMonoid`. ",
    "depth": 13},
   {"term":
    "{Œ± : Type u_2} ‚Üí\n  {Œ≤ : Type u_3} ‚Üí [inst : CommMonoid Œ±] ‚Üí [inst_1 : CommMonoid Œ≤] ‚Üí {A : Set Œ±} ‚Üí {n : ‚Ñï} ‚Üí Mul (A ‚Üí*[n] Œ≤)",
    "name": "FreimanHom.instMulFreimanHom",
    "doc": "`f * g` is the Freiman homomorphism sends `x` to `f x * g x`. ",
    "depth": 13},
   {"term":
    "{Œ± : Type u_2} ‚Üí\n  [inst : CommMonoid Œ±] ‚Üí {A : Set Œ±} ‚Üí {n : ‚Ñï} ‚Üí {Œ≤ : Type u_7} ‚Üí [inst_1 : CommGroup Œ≤] ‚Üí CommGroup (A ‚Üí*[n] Œ≤)",
    "name": "FreimanHom.commGroup",
    "doc":
    "If `Œ≤` is a commutative group, then `A ‚Üí*[n] Œ≤` is a commutative group too. ",
    "depth": 13},
   {"term":
    "{Œ± : Type u_2} ‚Üí\n  {A : Set Œ±} ‚Üí {Œ≤ : Type u_7} ‚Üí [inst : CommMonoid Œ±] ‚Üí [inst_1 : CommMonoid Œ≤] ‚Üí {n : ‚Ñï} ‚Üí (A ‚Üí*[n] Œ≤) ‚Üí Œ± ‚Üí Œ≤",
    "name": "FreimanHom.toFun",
    "doc": "The underlying function. ",
    "depth": 13}],
  "count": 58},
 {"noDocExamples": [],
  "kind": "Set.termŒô",
  "examples":
  [{"term":
    "‚àÄ {E : Type u_3} [inst : NormedAddCommGroup E] {f : ‚Ñù ‚Üí E} {a b : ‚Ñù} {Œº : MeasureTheory.Measure ‚Ñù},\n  IntervalIntegrable f Œº a b ‚Üí MeasureTheory.IntegrableOn f (Œô a b)",
    "name": "IntervalIntegrable.def",
    "doc":
    "If a function is interval integrable with respect to a given measure `Œº` on `a..b` then\nit is integrable on `uIoc a b` with respect to `Œº`. ",
    "depth": 14},
   {"term":
    "‚àÄ {E : Type u_3} [inst : NormedAddCommGroup E] {f : ‚Ñù ‚Üí E} {a b : ‚Ñù} {Œº : MeasureTheory.Measure ‚Ñù},\n  IntervalIntegrable f Œº a b ‚Üî MeasureTheory.IntegrableOn f (Œô a b)",
    "name": "intervalIntegrable_iff",
    "doc":
    "A function is interval integrable with respect to a given measure `Œº` on `a..b` if and\nonly if it is integrable on `uIoc a b` with respect to `Œº`. This is an equivalent\ndefinition of `IntervalIntegrable`. ",
    "depth": 14},
   {"term":
    "‚àÄ {a b : ‚Ñù} (n : ‚Ñï), ‚à´ (x : ‚Ñù) in Œô a b, |x - a| ^ n = |b - a| ^ (n + 1) / (‚Üën + 1)",
    "name": "integral_pow_abs_sub_uIoc",
    "doc":
    "Integral of `|x - a| ^ n` over `Œô a b`. This integral appears in the proof of the\nPicard-Lindel√∂f/Cauchy-Lipschitz theorem. ",
    "depth": 16},
   {"term":
    "‚àÄ {f : ‚Ñù ‚Üí ‚Ñù} {a b : ‚Ñù} {Œº : MeasureTheory.Measure ‚Ñù},\n  0 ‚â§·∂†[MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict Œº (Œô a b))] f ‚Üí\n    IntervalIntegrable f Œº a b ‚Üí (0 < ‚à´ (x : ‚Ñù) in a..b, f x ‚àÇŒº ‚Üî a < b ‚àß 0 < ‚Üë‚ÜëŒº (Function.support f ‚à© Set.Ioc a b))",
    "name": "intervalIntegral.integral_pos_iff_support_of_nonneg_ae'",
    "doc":
    "If `f` is nonnegative and integrable on the unordered interval `Set.uIoc a b`, then its\nintegral over `a..b` is positive if and only if `a < b` and the measure of\n`Function.support f ‚à© Set.Ioc a b` is positive. ",
    "depth": 19},
   {"term":
    "‚àÄ {Œ± : Type u_1} {m0 : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} [inst : LinearOrder Œ±] {a b : Œ±} {P : Œ± ‚Üí Prop},\n  (‚àÄ·µê (x : Œ±) ‚àÇMeasureTheory.Measure.restrict Œº (Œô a b), P x) ‚Üî\n    (‚àÄ·µê (x : Œ±) ‚àÇMeasureTheory.Measure.restrict Œº (Set.Ioc a b), P x) ‚àß\n      ‚àÄ·µê (x : Œ±) ‚àÇMeasureTheory.Measure.restrict Œº (Set.Ioc b a), P x",
    "name": "MeasureTheory.ae_restrict_uIoc_iff",
    "doc": "See also `MeasureTheory.ae_uIoc_iff`. ",
    "depth": 22}],
  "count": 58},
 {"noDocExamples": [],
  "kind": "term‚Ñô",
  "examples":
  [{"term":
    "{K : Type u_1} ‚Üí\n  {V : Type u_2} ‚Üí [inst : DivisionRing K] ‚Üí [inst_1 : AddCommGroup V] ‚Üí [inst_2 : Module K V] ‚Üí ‚Ñô K V ‚Üí V",
    "name": "Projectivization.rep",
    "doc": "Choose a representative of `v : Projectivization K V` in `V`. ",
    "depth": 11},
   {"term":
    "{K : Type u_1} ‚Üí\n  {V : Type u_2} ‚Üí [inst : DivisionRing K] ‚Üí [inst_1 : AddCommGroup V] ‚Üí [inst_2 : Module K V] ‚Üí ‚Ñô K V ‚Üí Submodule K V",
    "name": "Projectivization.submodule",
    "doc":
    "Consider an element of the projectivization as a submodule of `V`. ",
    "depth": 12},
   {"term":
    "{K : Type u_1} ‚Üí\n  {V : Type u_2} ‚Üí\n    [inst : Field K] ‚Üí [inst_1 : AddCommGroup V] ‚Üí [inst_2 : Module K V] ‚Üí Set (‚Ñô K V) ‚Üí Projectivization.Subspace K V",
    "name": "Projectivization.Subspace.span",
    "doc": "The span of a set of points in projective space is a subspace. ",
    "depth": 12},
   {"term":
    "{K : Type u_1} ‚Üí\n  {V : Type u_2} ‚Üí [inst : Field K] ‚Üí [inst_1 : AddCommGroup V] ‚Üí [inst_2 : Module K V] ‚Üí Set (‚Ñô K V) ‚Üí Set (‚Ñô K V)",
    "name": "Projectivization.Subspace.spanCarrier",
    "doc":
    "The span of a set of points in a projective space is defined inductively to be the set of points\nwhich contains the original set, and contains all points determined by the (nonzero) sum of two\nnonzero vectors, each of which determine points in the span. ",
    "depth": 12},
   {"term":
    "{K : Type u_1} ‚Üí\n  {V : Type u_2} ‚Üí\n    [inst : Field K] ‚Üí [inst_1 : AddCommGroup V] ‚Üí [inst_2 : Module K V] ‚Üí Projectivization.Subspace K V ‚Üí Set (‚Ñô K V)",
    "name": "Projectivization.Subspace.carrier",
    "doc": "The set of points. ",
    "depth": 12}],
  "count": 58},
 {"noDocExamples": [],
  "kind": "¬´term_‚âºi_¬ª",
  "examples":
  [{"term": "{Œ± : Type u_1} ‚Üí (r : Œ± ‚Üí Œ± ‚Üí Prop) ‚Üí r ‚âºi r",
    "name": "InitialSeg.refl",
    "doc": "The identity function shows that `‚âºi` is reflexive ",
    "depth": 6},
   {"term":
    "{Œ± : Type u_1} ‚Üí {Œ≤ : Type u_2} ‚Üí (r : Œ± ‚Üí Œ± ‚Üí Prop) ‚Üí (s : Œ≤ ‚Üí Œ≤ ‚Üí Prop) ‚Üí r ‚âºi Sum.Lex r s",
    "name": "InitialSeg.leAdd",
    "doc":
    "Initial segment embedding of an order `r` into the disjoint union of `r` and `s`. ",
    "depth": 9},
   {"term":
    "{Œ± : Type u_1} ‚Üí {Œ≤ : Type u_2} ‚Üí (r : Œ± ‚Üí Œ± ‚Üí Prop) ‚Üí (s : Œ≤ ‚Üí Œ≤ ‚Üí Prop) ‚Üí [inst : IsEmpty Œ±] ‚Üí r ‚âºi s",
    "name": "InitialSeg.ofIsEmpty",
    "doc": "Initial segment from an empty type. ",
    "depth": 9},
   {"term":
    "{Œ± : Type u_1} ‚Üí {Œ≤ : Type u_2} ‚Üí {r : Œ± ‚Üí Œ± ‚Üí Prop} ‚Üí {s : Œ≤ ‚Üí Œ≤ ‚Üí Prop} ‚Üí r ‚âÉr s ‚Üí r ‚âºi s",
    "name": "InitialSeg.ofIso",
    "doc": "An order isomorphism is an initial segment ",
    "depth": 9},
   {"term": "(fun x x_1 => x < x_1) ‚âºi fun x x_1 => x < x_1",
    "name": "Ordinal.lift.initialSeg",
    "doc":
    "Initial segment version of the lift operation on ordinals, embedding `ordinal.{u}` in\n`ordinal.{v}` as an initial segment when `u ‚â§ v`. ",
    "depth": 10}],
  "count": 57},
 {"noDocExamples": [],
  "kind": "¬´AddFreimanHomLocal‚â∫¬ª",
  "examples":
  [{"term":
    "{Œ± : Type u_2} ‚Üí [inst : AddCommMonoid Œ±] ‚Üí (A : Set Œ±) ‚Üí (n : ‚Ñï) ‚Üí A ‚Üí+[n] Œ±",
    "name": "AddFreimanHom.id",
    "doc": "The identity map from an additive commutative monoid to itself.",
    "depth": 10},
   {"term":
    "{Œ± : Type u_2} ‚Üí\n  [inst : AddCommMonoid Œ±] ‚Üí\n    {A : Set Œ±} ‚Üí {n : ‚Ñï} ‚Üí {Œ≤ : Type u_7} ‚Üí [inst_1 : AddCommGroup Œ≤] ‚Üí AddCommGroup (A ‚Üí+[n] Œ≤)",
    "name": "AddFreimanHom.addCommGroup",
    "doc":
    "If `Œ≤` is an additive commutative group, then `A ‚Üí*[n] Œ≤` is an additive commutative\ngroup too.",
    "depth": 13},
   {"term":
    "{Œ± : Type u_2} ‚Üí\n  {Œ≤ : Type u_3} ‚Üí [inst : AddCommMonoid Œ±] ‚Üí [inst_1 : AddCommMonoid Œ≤] ‚Üí (A : Set Œ±) ‚Üí (n : ‚Ñï) ‚Üí (Œ± ‚Üí+ Œ≤) ‚Üí A ‚Üí+[n] Œ≤",
    "name": "AddMonoidHom.toAddFreimanHom",
    "doc": "An `AddMonoidHom` is naturally an `AddFreimanHom`",
    "depth": 13},
   {"term":
    "{Œ± : Type u_2} ‚Üí\n  {Œ≤ : Type u_3} ‚Üí\n    [inst : AddCommMonoid Œ±] ‚Üí [inst_1 : AddCommMonoid Œ≤] ‚Üí {A : Set Œ±} ‚Üí {n : ‚Ñï} ‚Üí AddCommMonoid (A ‚Üí+[n] Œ≤)",
    "name": "AddFreimanHom.addCommMonoid",
    "doc": "`Œ± ‚Üí+[n] Œ≤` is an `AddCommMonoid`.",
    "depth": 13},
   {"term":
    "{Œ± : Type u_2} ‚Üí\n  {Œ≤ : Type u_3} ‚Üí [inst : AddCommMonoid Œ±] ‚Üí [inst_1 : AddCommMonoid Œ≤] ‚Üí {A : Set Œ±} ‚Üí {n : ‚Ñï} ‚Üí Add (A ‚Üí+[n] Œ≤)",
    "name": "AddFreimanHom.instAddFreimanHom",
    "doc": "`f + g` is the Freiman homomorphism sending `x` to `f x + g x`.",
    "depth": 13}],
  "count": 57},
 {"noDocExamples": [],
  "kind": "¬´term_‚âÉ·µà_¬ª",
  "examples":
  [{"term": "(X : Type u_4) ‚Üí [inst : PseudoEMetricSpace X] ‚Üí X ‚âÉ·µà X",
    "name": "DilationEquiv.refl",
    "doc": "Identity map as a `DilationEquiv`. ",
    "depth": 6},
   {"term":
    "{X : Type u_1} ‚Üí {Y : Type u_2} ‚Üí [inst : PseudoEMetricSpace X] ‚Üí [inst_1 : PseudoEMetricSpace Y] ‚Üí X ‚âÉ·µà Y ‚Üí Y ‚âÉ·µà X",
    "name": "DilationEquiv.symm",
    "doc": "Inverse `DilationEquiv`. ",
    "depth": 9},
   {"term":
    "{X : Type u_1} ‚Üí {Y : Type u_2} ‚Üí [inst : PseudoEMetricSpace X] ‚Üí [inst_1 : PseudoEMetricSpace Y] ‚Üí X ‚âÉ·µà Y ‚Üí Y ‚Üí X",
    "name": "DilationEquiv.Simps.symm_apply",
    "doc": "See Note [custom simps projection]. ",
    "depth": 9},
   {"term":
    "{X : Type u_1} ‚Üí [inst : PseudoEMetricSpace X] ‚Üí (X ‚âÉ·µà X) ‚Üí* Equiv.Perm X",
    "name": "DilationEquiv.toPerm",
    "doc": "`DilationEquiv.toEquiv` as a monoid homomorphism. ",
    "depth": 12},
   {"term":
    "{X : Type u_1} ‚Üí [inst : PseudoEMetricSpace X] ‚Üí (X ‚âÉ·µà X) ‚Üí* NNReal",
    "name": "DilationEquiv.ratioHom",
    "doc": "`Dilation.ratio` as a monoid homomorphism. ",
    "depth": 12}],
  "count": 55},
 {"noDocExamples": [],
  "kind": "¬´term_‚Üí+*o_¬ª",
  "examples":
  [{"term":
    "(Œ± : Type u_2) ‚Üí [inst : NonAssocSemiring Œ±] ‚Üí [inst_1 : Preorder Œ±] ‚Üí Œ± ‚Üí+*o Œ±",
    "name": "OrderRingHom.id",
    "doc": "The identity as an ordered ring homomorphism. ",
    "depth": 9},
   {"term":
    "{Œ± : Type u_6} ‚Üí\n  {Œ≤ : Type u_7} ‚Üí\n    [inst : NonAssocSemiring Œ±] ‚Üí\n      [inst_1 : Preorder Œ±] ‚Üí [inst_2 : NonAssocSemiring Œ≤] ‚Üí [inst_3 : Preorder Œ≤] ‚Üí Œ± ‚Üí+*o Œ≤ ‚Üí Œ± ‚Üí+* Œ≤",
    "name": "OrderRingHom.toRingHom",
    "doc": "Reinterpret an ordered ring homomorphism as a ring homomorphism. ",
    "depth": 13},
   {"term":
    "{Œ± : Type u_2} ‚Üí\n  {Œ≤ : Type u_3} ‚Üí\n    [inst : NonAssocSemiring Œ±] ‚Üí\n      [inst_1 : Preorder Œ±] ‚Üí [inst_2 : NonAssocSemiring Œ≤] ‚Üí [inst_3 : Preorder Œ≤] ‚Üí Œ± ‚Üí+*o Œ≤ ‚Üí Œ± ‚Üí*‚ÇÄo Œ≤",
    "name": "OrderRingHom.toOrderMonoidWithZeroHom",
    "doc":
    "Reinterpret an ordered ring homomorphism as an order homomorphism. ",
    "depth": 13},
   {"term":
    "{Œ± : Type u_2} ‚Üí\n  {Œ≤ : Type u_3} ‚Üí\n    [inst : NonAssocSemiring Œ±] ‚Üí\n      [inst_1 : Preorder Œ±] ‚Üí [inst_2 : NonAssocSemiring Œ≤] ‚Üí [inst_3 : Preorder Œ≤] ‚Üí Œ± ‚Üí+*o Œ≤ ‚Üí Œ± ‚Üí+o Œ≤",
    "name": "OrderRingHom.toOrderAddMonoidHom",
    "doc":
    "Reinterpret an ordered ring homomorphism as an ordered additive monoid homomorphism. ",
    "depth": 14},
   {"term":
    "{F : Type u_1} ‚Üí\n  {Œ± : Type u_2} ‚Üí\n    {Œ≤ : Type u_3} ‚Üí\n      [inst : NonAssocSemiring Œ±] ‚Üí\n        [inst_1 : Preorder Œ±] ‚Üí\n          [inst_2 : NonAssocSemiring Œ≤] ‚Üí [inst_3 : Preorder Œ≤] ‚Üí [inst_4 : OrderRingHomClass F Œ± Œ≤] ‚Üí F ‚Üí Œ± ‚Üí+*o Œ≤",
    "name": "OrderRingHomClass.toOrderRingHom",
    "doc":
    "Turn an element of a type `F` satisfying `OrderRingHomClass F Œ± Œ≤` into an actual\n`OrderRingHom`. This is declared as the default coercion from `F` to `Œ± ‚Üí+*o Œ≤`. ",
    "depth": 15}],
  "count": 53},
 {"noDocExamples": [],
  "kind": "IntermediateField.¬´term_‚üÆ_,,‚üØ¬ª",
  "examples":
  [{"term":
    "‚àÄ {F : Type u_1} [inst : Field F] {E : Type u_2} [inst_1 : Field E] [inst_2 : Algebra F E] (x : E),\n  CompleteLattice.IsCompactElement F‚üÆx‚üØ",
    "name": "IntermediateField.adjoin_simple_isCompactElement",
    "doc":
    "Adjoining a single element is compact in the lattice of intermediate fields. ",
    "depth": 14},
   {"term":
    "‚àÄ (F : Type u_1) [inst : Field F] (E : Type u_2) [inst_1 : Field E] [inst_2 : Algebra F E] [inst_3 : Finite E],\n  ‚àÉ Œ±, F‚üÆŒ±‚üØ = ‚ä§",
    "name": "Field.exists_primitive_element_of_finite_top",
    "doc": "**Primitive element theorem** assuming E is finite. ",
    "depth": 17},
   {"term":
    "‚àÄ (F : Type u_1) (E : Type u_2) [inst : Field F] [inst_1 : Field E] [inst_2 : Algebra F E]\n  [inst_3 : FiniteDimensional F E] [inst_4 : IsSeparable F E], ‚àÉ Œ±, F‚üÆŒ±‚üØ = ‚ä§",
    "name": "Field.exists_primitive_element",
    "doc":
    "Primitive element theorem: a finite separable field extension `E` of `F` has a\nprimitive element, i.e. there is an `Œ± ‚àà E` such that `F‚üÆŒ±‚üØ = (‚ä§ : Subalgebra F E)`.",
    "depth": 18},
   {"term":
    "‚àÄ (F : Type u_1) [inst : Field F] (E : Type u_2) [inst_1 : Field E] [inst_2 : Algebra F E] [inst_3 : Finite F]\n  [inst_4 : FiniteDimensional F E], ‚àÉ Œ±, F‚üÆŒ±‚üØ = ‚ä§",
    "name": "Field.exists_primitive_element_of_finite_bot",
    "doc":
    "Primitive element theorem for finite dimensional extension of a finite field. ",
    "depth": 18},
   {"term":
    "(F : Type u_1) ‚Üí\n  [inst : Field F] ‚Üí {E : Type u_2} ‚Üí [inst_1 : Field E] ‚Üí [inst_2 : Algebra F E] ‚Üí (Œ± : E) ‚Üí { x // x ‚àà F‚üÆŒ±‚üØ }",
    "name": "IntermediateField.AdjoinSimple.gen",
    "doc": "generator of `F‚üÆŒ±‚üØ` ",
    "depth": 19}],
  "count": 51},
 {"noDocExamples": [],
  "kind": "¬´term_‚Üí·µÉ‚Å±[_]_¬ª",
  "examples":
  [{"term":
    "{ùïú : Type u_1} ‚Üí\n  {V : Type u_2} ‚Üí\n    {P : Type u_8} ‚Üí\n      [inst : NormedField ùïú] ‚Üí\n        [inst_1 : SeminormedAddCommGroup V] ‚Üí\n          [inst_2 : NormedSpace ùïú V] ‚Üí [inst_3 : PseudoMetricSpace P] ‚Üí [inst_4 : NormedAddTorsor V P] ‚Üí P ‚Üí·µÉ‚Å±[ùïú] P",
    "name": "AffineIsometry.id",
    "doc": "The identity affine isometry. ",
    "depth": 22},
   {"term":
    "{ùïú : Type u_1} ‚Üí\n  {V : Type u_2} ‚Üí\n    {V‚ÇÇ : Type u_4} ‚Üí\n      [inst : NormedField ùïú] ‚Üí\n        [inst_1 : SeminormedAddCommGroup V] ‚Üí\n          [inst_2 : SeminormedAddCommGroup V‚ÇÇ] ‚Üí\n            [inst_3 : NormedSpace ùïú V] ‚Üí [inst_4 : NormedSpace ùïú V‚ÇÇ] ‚Üí (V ‚Üí‚Çó·µ¢[ùïú] V‚ÇÇ) ‚Üí V ‚Üí·µÉ‚Å±[ùïú] V‚ÇÇ",
    "name": "LinearIsometry.toAffineIsometry",
    "doc": "Reinterpret a linear isometry as an affine isometry. ",
    "depth": 23},
   {"term":
    "{ùïú : Type u_1} ‚Üí\n  {V : Type u_2} ‚Üí\n    {V‚ÇÇ : Type u_4} ‚Üí\n      {P : Type u_8} ‚Üí\n        {P‚ÇÇ : Type u_9} ‚Üí\n          [inst : NormedField ùïú] ‚Üí\n            [inst_1 : SeminormedAddCommGroup V] ‚Üí\n              [inst_2 : SeminormedAddCommGroup V‚ÇÇ] ‚Üí\n                [inst_3 : NormedSpace ùïú V] ‚Üí\n                  [inst_4 : NormedSpace ùïú V‚ÇÇ] ‚Üí\n                    [inst_5 : PseudoMetricSpace P] ‚Üí\n                      [inst_6 : PseudoMetricSpace P‚ÇÇ] ‚Üí\n                        [inst_7 : NormedAddTorsor V P] ‚Üí [inst_8 : NormedAddTorsor V‚ÇÇ P‚ÇÇ] ‚Üí (P ‚âÉ·µÉ‚Å±[ùïú] P‚ÇÇ) ‚Üí P ‚Üí·µÉ‚Å±[ùïú] P‚ÇÇ",
    "name": "AffineIsometryEquiv.toAffineIsometry",
    "doc": "Reinterpret an `AffineIsometryEquiv` as an `AffineIsometry`. ",
    "depth": 29},
   {"term":
    "{ùïú : Type u_1} ‚Üí\n  {V : Type u_2} ‚Üí\n    {V‚ÇÇ : Type u_4} ‚Üí\n      {P : Type u_8} ‚Üí\n        {P‚ÇÇ : Type u_9} ‚Üí\n          [inst : NormedField ùïú] ‚Üí\n            [inst_1 : SeminormedAddCommGroup V] ‚Üí\n              [inst_2 : SeminormedAddCommGroup V‚ÇÇ] ‚Üí\n                [inst_3 : NormedSpace ùïú V] ‚Üí\n                  [inst_4 : NormedSpace ùïú V‚ÇÇ] ‚Üí\n                    [inst_5 : PseudoMetricSpace P] ‚Üí\n                      [inst_6 : PseudoMetricSpace P‚ÇÇ] ‚Üí\n                        [inst_7 : NormedAddTorsor V P] ‚Üí [inst_8 : NormedAddTorsor V‚ÇÇ P‚ÇÇ] ‚Üí (P ‚Üí·µÉ‚Å±[ùïú] P‚ÇÇ) ‚Üí V ‚Üí‚Çó·µ¢[ùïú] V‚ÇÇ",
    "name": "AffineIsometry.linearIsometry",
    "doc":
    "The underlying linear map of an affine isometry is in fact a linear isometry. ",
    "depth": 29},
   {"term":
    "{E : Type u_2} ‚Üí\n  [inst : NormedAddCommGroup E] ‚Üí\n    [inst_1 : NormedSpace ‚Ñù E] ‚Üí\n      [inst_2 : StrictConvexSpace ‚Ñù E] ‚Üí\n        {F : Type u_3} ‚Üí\n          [inst_3 : NormedAddCommGroup F] ‚Üí\n            [inst_4 : NormedSpace ‚Ñù F] ‚Üí\n              {PF : Type u} ‚Üí\n                {PE : Type u_4} ‚Üí\n                  [inst_5 : MetricSpace PF] ‚Üí\n                    [inst_6 : MetricSpace PE] ‚Üí\n                      [inst_7 : NormedAddTorsor F PF] ‚Üí\n                        [inst_8 : NormedAddTorsor E PE] ‚Üí {f : PF ‚Üí PE} ‚Üí Isometry f ‚Üí PF ‚Üí·µÉ‚Å±[‚Ñù] PE",
    "name": "Isometry.affineIsometryOfStrictConvexSpace",
    "doc":
    "An isometry of `NormedAddTorsor`s for real normed spaces, strictly convex in the case of\nthe codomain, is an affine isometry.  Unlike Mazur-Ulam, this does not require the isometry to\nbe surjective. ",
    "depth": 29}],
  "count": 51},
 {"noDocExamples": [],
  "kind": "SimpleGraph.¬´term_‚âÉg_¬ª",
  "examples":
  [{"term": "{V : Type u} ‚Üí {G : SimpleGraph V} ‚Üí G ‚âÉg G",
    "name": "SimpleGraph.Iso.refl",
    "doc": "The identity isomorphism of a graph with itself. ",
    "depth": 6},
   {"term":
    "{Œ± : Type u_1} ‚Üí [inst : Preorder Œ±] ‚Üí SimpleGraph.hasse Œ±·µí·µà ‚âÉg SimpleGraph.hasse Œ±",
    "name": "SimpleGraph.hasseDualIso",
    "doc": "`Œ±·µí·µà` and `Œ±` have the same Hasse diagram. ",
    "depth": 7},
   {"term":
    "{V : Type u} ‚Üí (G : SimpleGraph V) ‚Üí SimpleGraph.induce Set.univ G ‚âÉg G",
    "name": "SimpleGraph.induceUnivIso",
    "doc":
    "The graph induced on `Set.univ` is isomorphic to the original graph. ",
    "depth": 8},
   {"term":
    "{V : Type u} ‚Üí {W : Type v} ‚Üí {G : SimpleGraph V} ‚Üí {G' : SimpleGraph W} ‚Üí G ‚âÉg G' ‚Üí G ‚Ü™g G'",
    "name": "SimpleGraph.Iso.toEmbedding",
    "doc": "An isomorphism of graphs gives rise to an embedding of graphs. ",
    "depth": 9},
   {"term":
    "{V : Type u} ‚Üí {W : Type v} ‚Üí {G : SimpleGraph V} ‚Üí {G' : SimpleGraph W} ‚Üí G ‚âÉg G' ‚Üí G' ‚âÉg G",
    "name": "SimpleGraph.Iso.symm",
    "doc": "The inverse of a graph isomorphism. ",
    "depth": 9}],
  "count": 50},
 {"noDocExamples": [],
  "kind": "¬´term‚®Ç[_]_,_¬ª",
  "examples":
  [{"term":
    "{Œπ : Type u_1} ‚Üí\n  (R : Type u_4) ‚Üí\n    [inst : CommSemiring R] ‚Üí\n      {s : Œπ ‚Üí Type u_7} ‚Üí\n        [inst_1 : (i : Œπ) ‚Üí AddCommMonoid (s i)] ‚Üí\n          [inst_2 : (i : Œπ) ‚Üí Module R (s i)] ‚Üí R ‚Üí ((i : Œπ) ‚Üí s i) ‚Üí ‚®Ç[R] (i : Œπ), s i",
    "name": "PiTensorProduct.tprodCoeff",
    "doc":
    "`tprodCoeff R r f` with `r : R` and `f : ‚àÄ i, s i` is the tensor product of the vectors `f i`\nover all `i : Œπ`, multiplied by the coefficient `r`. Note that this is meant as an auxiliary\ndefinition for this file alone, and that one should use `tprod` defined below for most purposes. ",
    "depth": 14},
   {"term":
    "{Œπ : Type u_1} ‚Üí\n  (R : Type u_4) ‚Üí\n    [inst : CommSemiring R] ‚Üí\n      {s : Œπ ‚Üí Type u_7} ‚Üí\n        [inst_1 : (i : Œπ) ‚Üí AddCommMonoid (s i)] ‚Üí\n          [inst_2 : (i : Œπ) ‚Üí Module R (s i)] ‚Üí MultilinearMap R s (‚®Ç[R] (i : Œπ), s i)",
    "name": "PiTensorProduct.tprod",
    "doc": "The canonical `MultilinearMap R s (‚®Ç[R] i, s i)`. ",
    "depth": 18},
   {"term":
    "{Œπ : Type u_1} ‚Üí\n  {R : Type u_4} ‚Üí\n    [inst : CommSemiring R] ‚Üí\n      {s : Œπ ‚Üí Type u_7} ‚Üí\n        [inst_1 : (i : Œπ) ‚Üí AddCommMonoid (s i)] ‚Üí\n          [inst_2 : (i : Œπ) ‚Üí Module R (s i)] ‚Üí\n            {E : Type u_9} ‚Üí\n              [inst_3 : AddCommMonoid E] ‚Üí [inst_4 : Module R E] ‚Üí MultilinearMap R s E ‚Üí (‚®Ç[R] (i : Œπ), s i) ‚Üí+ E",
    "name": "PiTensorProduct.liftAux",
    "doc":
    "Auxiliary function to constructing a linear map `(‚®Ç[R] i, s i) ‚Üí E` given a\n`MultilinearMap R s E` with the property that its composition with the canonical\n`MultilinearMap R s (‚®Ç[R] i, s i)` is the given multilinear map. ",
    "depth": 21},
   {"term":
    "(Œπ : Type u_1) ‚Üí\n  {R : Type u_4} ‚Üí\n    [inst : CommSemiring R] ‚Üí\n      {M : Type u_8} ‚Üí\n        [inst_1 : AddCommMonoid M] ‚Üí [inst_2 : Module R M] ‚Üí [inst_3 : IsEmpty Œπ] ‚Üí (‚®Ç[R] (x : Œπ), M) ‚âÉ‚Çó[R] R",
    "name": "PiTensorProduct.isEmptyEquiv",
    "doc":
    "The tensor product over an empty index type `Œπ` is isomorphic to the base ring. ",
    "depth": 21},
   {"term":
    "{Œπ : Type u_1} ‚Üí\n  {R : Type u_4} ‚Üí\n    [inst : CommSemiring R] ‚Üí\n      {M : Type u_8} ‚Üí\n        [inst_1 : AddCommMonoid M] ‚Üí [inst_2 : Module R M] ‚Üí [inst_3 : Subsingleton Œπ] ‚Üí Œπ ‚Üí (‚®Ç[R] (x : Œπ), M) ‚âÉ‚Çó[R] M",
    "name": "PiTensorProduct.subsingletonEquiv",
    "doc": "Tensor product of `M` over a singleton set is equivalent to `M`\n",
    "depth": 22}],
  "count": 50},
 {"noDocExamples": [],
  "kind": "¬´term_‚Üí*‚ÇÄo_¬ª",
  "examples":
  [{"term":
    "(Œ± : Type u_2) ‚Üí [inst : Preorder Œ±] ‚Üí [inst_1 : MulZeroOneClass Œ±] ‚Üí Œ± ‚Üí*‚ÇÄo Œ±",
    "name": "OrderMonoidWithZeroHom.id",
    "doc": "The identity map as an ordered monoid with zero homomorphism. ",
    "depth": 9},
   {"term":
    "{Œ± : Type u_2} ‚Üí\n  {Œ≤ : Type u_3} ‚Üí\n    [inst : NonAssocSemiring Œ±] ‚Üí\n      [inst_1 : Preorder Œ±] ‚Üí [inst_2 : NonAssocSemiring Œ≤] ‚Üí [inst_3 : Preorder Œ≤] ‚Üí Œ± ‚Üí+*o Œ≤ ‚Üí Œ± ‚Üí*‚ÇÄo Œ≤",
    "name": "OrderRingHom.toOrderMonoidWithZeroHom",
    "doc":
    "Reinterpret an ordered ring homomorphism as an order homomorphism. ",
    "depth": 13},
   {"term":
    "{Œ± : Type u_2} ‚Üí\n  {Œ≤ : Type u_3} ‚Üí\n    [inst : Preorder Œ±] ‚Üí\n      [inst_1 : Preorder Œ≤] ‚Üí [inst_2 : MulZeroOneClass Œ±] ‚Üí [inst_3 : MulZeroOneClass Œ≤] ‚Üí (Œ± ‚Üí*‚ÇÄo Œ≤) ‚Üí Œ± ‚Üí*o Œ≤",
    "name": "OrderMonoidWithZeroHom.toOrderMonoidHom",
    "doc":
    "Reinterpret an ordered monoid with zero homomorphism as an order monoid homomorphism. ",
    "depth": 13},
   {"term":
    "{Œ± : Type u_2} ‚Üí\n  {Œ≤ : Type u_3} ‚Üí\n    [inst : LinearOrderedCommMonoidWithZero Œ±] ‚Üí [inst_1 : LinearOrderedCommMonoidWithZero Œ≤] ‚Üí Mul (Œ± ‚Üí*‚ÇÄo Œ≤)",
    "name":
    "OrderMonoidWithZeroHom.instMulOrderMonoidWithZeroHomToPreorderToPartialOrderToOrderedCommMonoidToLinearOrderedCommMonoidToPreorderToPartialOrderToOrderedCommMonoidToLinearOrderedCommMonoidToMulZeroOneClassToMonoidWithZeroToCommMonoidWithZeroToMulZeroOneClassToMonoidWithZeroToCommMonoidWithZero",
    "doc":
    "For two ordered monoid morphisms `f` and `g`, their product is the ordered monoid morphism\nsending `a` to `f a * g a`. ",
    "depth": 14},
   {"term":
    "{F : Type u_1} ‚Üí\n  {Œ± : Type u_2} ‚Üí\n    {Œ≤ : Type u_3} ‚Üí\n      [inst : Preorder Œ±] ‚Üí\n        [inst_1 : Preorder Œ≤] ‚Üí\n          [inst_2 : MulZeroOneClass Œ±] ‚Üí\n            [inst_3 : MulZeroOneClass Œ≤] ‚Üí [inst_4 : OrderMonoidWithZeroHomClass F Œ± Œ≤] ‚Üí F ‚Üí Œ± ‚Üí*‚ÇÄo Œ≤",
    "name": "OrderMonoidWithZeroHomClass.toOrderMonoidWithZeroHom",
    "doc":
    "Turn an element of a type `F` satisfying `OrderMonoidWithZeroHomClass F Œ± Œ≤` into an actual\n`OrderMonoidWithZeroHom`. This is declared as the default coercion from `F` to `Œ± ‚Üí+*‚ÇÄo Œ≤`. ",
    "depth": 15}],
  "count": 49},
 {"noDocExamples": [],
  "kind": "¬´termŒ©[_‚ÅÑ_]¬ª",
  "examples":
  [{"term":
    "(R : Type u) ‚Üí (S : Type v) ‚Üí [inst : CommRing R] ‚Üí [inst_1 : CommRing S] ‚Üí [inst_2 : Algebra R S] ‚Üí S ‚Üí‚Çó[R] Œ©[S‚ÅÑR]",
    "name": "KaehlerDifferential.DLinearMap",
    "doc":
    "(Implementation) The underlying linear map of the derivation into `Œ©[S‚ÅÑR]`. ",
    "depth": 17},
   {"term":
    "(R : Type u) ‚Üí\n  (S : Type v) ‚Üí [inst : CommRing R] ‚Üí [inst_1 : CommRing S] ‚Üí [inst_2 : Algebra R S] ‚Üí Derivation R S (Œ©[S‚ÅÑR])",
    "name": "KaehlerDifferential.D",
    "doc": "The universal derivation into `Œ©[S‚ÅÑR]`. ",
    "depth": 17},
   {"term":
    "{R : Type u} ‚Üí\n  {S : Type v} ‚Üí\n    [inst : CommRing R] ‚Üí\n      [inst_1 : CommRing S] ‚Üí\n        [inst_2 : Algebra R S] ‚Üí\n          {M : Type u_1} ‚Üí\n            [inst_3 : AddCommGroup M] ‚Üí\n              [inst_4 : Module R M] ‚Üí\n                [inst_5 : Module S M] ‚Üí [inst_6 : IsScalarTower R S M] ‚Üí Derivation R S M ‚Üí Œ©[S‚ÅÑR] ‚Üí‚Çó[S] M",
    "name": "Derivation.liftKaehlerDifferential",
    "doc": "The linear map from `Œ©[S‚ÅÑR]`, associated with a derivation. ",
    "depth": 23},
   {"term":
    "(R : Type u) ‚Üí\n  (S : Type v) ‚Üí\n    [inst : CommRing R] ‚Üí\n      [inst_1 : CommRing S] ‚Üí [inst_2 : Algebra R S] ‚Üí ((S ‚Üí‚ÇÄ S) ‚ß∏ KaehlerDifferential.kerTotal R S) ‚âÉ‚Çó[S] Œ©[S‚ÅÑR]",
    "name": "KaehlerDifferential.quotKerTotalEquiv",
    "doc":
    "`Œ©[S‚ÅÑR]` is isomorphic to `S` copies of `S` with kernel `KaehlerDifferential.kerTotal`. ",
    "depth": 23},
   {"term":
    "(R : Type u) ‚Üí\n  [inst : CommRing R] ‚Üí\n    (A : Type u_2) ‚Üí\n      (B : Type u_3) ‚Üí\n        [inst_1 : CommRing A] ‚Üí\n          [inst_2 : CommRing B] ‚Üí\n            [inst_3 : Algebra R A] ‚Üí\n              [inst_4 : Algebra R B] ‚Üí\n                [inst_5 : Algebra A B] ‚Üí [inst_6 : IsScalarTower R A B] ‚Üí TensorProduct A B (Œ©[A‚ÅÑR]) ‚Üí‚Çó[B] Œ©[B‚ÅÑR]",
    "name": "KaehlerDifferential.mapBaseChange",
    "doc":
    "The lift of the map `Œ©[A‚ÅÑR] ‚Üí‚Çó[A] Œ©[B‚ÅÑR]` to the base change along `A ‚Üí B`.\nThis is the first map in the exact sequence `B ‚äó[A] Œ©[A‚ÅÑR] ‚Üí Œ©[B‚ÅÑR] ‚Üí Œ©[B‚ÅÑA] ‚Üí 0`. ",
    "depth": 26}],
  "count": 48},
 {"noDocExamples": [],
  "kind": "¬´term_‚Üí+o_¬ª",
  "examples":
  [{"term": "Surreal ‚Üí+o SetTheory.Game",
    "name": "Surreal.toGame",
    "doc": "Casts a `Surreal` number into a `Game`. ",
    "depth": 7},
   {"term":
    "(Œ± : Type u_2) ‚Üí [inst : Preorder Œ±] ‚Üí [inst_1 : AddZeroClass Œ±] ‚Üí Œ± ‚Üí+o Œ±",
    "name": "OrderAddMonoidHom.id",
    "doc": "The identity map as an ordered additive monoid homomorphism.",
    "depth": 9},
   {"term":
    "{Œ± : Type u_2} ‚Üí {Œ≤ : Type u_3} ‚Üí [inst : OrderedAddCommMonoid Œ±] ‚Üí [inst_1 : OrderedAddCommMonoid Œ≤] ‚Üí Add (Œ± ‚Üí+o Œ≤)",
    "name":
    "OrderAddMonoidHom.instAddOrderAddMonoidHomToPreorderToPartialOrderToPreorderToPartialOrderToAddZeroClassToAddMonoidToAddCommMonoidToAddZeroClassToAddMonoidToAddCommMonoid",
    "doc":
    "For two ordered additive monoid morphisms `f` and `g`, their product is the ordered\nadditive monoid morphism sending `a` to `f a + g a`.",
    "depth": 12},
   {"term":
    "{Œ± : Type u_2} ‚Üí\n  {Œ≤ : Type u_3} ‚Üí\n    [inst : Preorder Œ±] ‚Üí [inst_1 : Preorder Œ≤] ‚Üí [inst_2 : AddZeroClass Œ±] ‚Üí [inst_3 : AddZeroClass Œ≤] ‚Üí Zero (Œ± ‚Üí+o Œ≤)",
    "name": "OrderAddMonoidHom.instZeroOrderAddMonoidHom",
    "doc": "`0` is the homomorphism sending all elements to `0`.",
    "depth": 13},
   {"term":
    "{Œ± : Type u_2} ‚Üí\n  {Œ≤ : Type u_3} ‚Üí\n    [inst : Preorder Œ±] ‚Üí\n      [inst_1 : Preorder Œ≤] ‚Üí [inst_2 : AddZeroClass Œ±] ‚Üí [inst_3 : AddZeroClass Œ≤] ‚Üí (Œ± ‚Üí+o Œ≤) ‚Üí Œ± ‚Üío Œ≤",
    "name": "OrderAddMonoidHom.toOrderHom",
    "doc":
    "Reinterpret an ordered additive monoid homomorphism as an order homomorphism.",
    "depth": 13}],
  "count": 48},
 {"noDocExamples": [],
  "kind": "¬´term_‚Üí*o_¬ª",
  "examples":
  [{"term":
    "(Œ± : Type u_2) ‚Üí [inst : Preorder Œ±] ‚Üí [inst_1 : MulOneClass Œ±] ‚Üí Œ± ‚Üí*o Œ±",
    "name": "OrderMonoidHom.id",
    "doc": "The identity map as an ordered monoid homomorphism. ",
    "depth": 9},
   {"term":
    "{Œ± : Type u_2} ‚Üí {Œ≤ : Type u_3} ‚Üí [inst : OrderedCommMonoid Œ±] ‚Üí [inst_1 : OrderedCommMonoid Œ≤] ‚Üí Mul (Œ± ‚Üí*o Œ≤)",
    "name":
    "OrderMonoidHom.instMulOrderMonoidHomToPreorderToPartialOrderToPreorderToPartialOrderToMulOneClassToMonoidToCommMonoidToMulOneClassToMonoidToCommMonoid",
    "doc":
    "For two ordered monoid morphisms `f` and `g`, their product is the ordered monoid morphism\nsending `a` to `f a * g a`. ",
    "depth": 12},
   {"term":
    "{Œ± : Type u_2} ‚Üí\n  {Œ≤ : Type u_3} ‚Üí\n    [inst : Preorder Œ±] ‚Üí\n      [inst_1 : Preorder Œ≤] ‚Üí [inst_2 : MulOneClass Œ±] ‚Üí [inst_3 : MulOneClass Œ≤] ‚Üí (Œ± ‚Üí*o Œ≤) ‚Üí Œ± ‚Üío Œ≤",
    "name": "OrderMonoidHom.toOrderHom",
    "doc":
    "Reinterpret an ordered monoid homomorphism as an order homomorphism. ",
    "depth": 13},
   {"term":
    "{Œ± : Type u_2} ‚Üí\n  {Œ≤ : Type u_3} ‚Üí\n    [inst : Preorder Œ±] ‚Üí [inst_1 : Preorder Œ≤] ‚Üí [inst_2 : MulOneClass Œ±] ‚Üí [inst_3 : MulOneClass Œ≤] ‚Üí One (Œ± ‚Üí*o Œ≤)",
    "name": "OrderMonoidHom.instOneOrderMonoidHom",
    "doc": "`1` is the homomorphism sending all elements to `1`. ",
    "depth": 13},
   {"term":
    "{Œ± : Type u_2} ‚Üí\n  {Œ≤ : Type u_3} ‚Üí\n    [inst : Preorder Œ±] ‚Üí\n      [inst_1 : Preorder Œ≤] ‚Üí [inst_2 : MulZeroOneClass Œ±] ‚Üí [inst_3 : MulZeroOneClass Œ≤] ‚Üí (Œ± ‚Üí*‚ÇÄo Œ≤) ‚Üí Œ± ‚Üí*o Œ≤",
    "name": "OrderMonoidWithZeroHom.toOrderMonoidHom",
    "doc":
    "Reinterpret an ordered monoid with zero homomorphism as an order monoid homomorphism. ",
    "depth": 13}],
  "count": 48},
 {"noDocExamples": [],
  "kind": "Lean.Parser.Term.quotedName",
  "examples":
  [{"term": "CongrState ‚Üí List (Lean.TSyntax `rcasesPat)",
    "name": "CongrState.patterns",
    "doc": "Patterns to use when doing intro. ",
    "depth": 6},
   {"term": "CongrMetaM (Option (Lean.TSyntax `rcasesPat))",
    "name": "CongrMetaM.nextPattern",
    "doc": "Pop the next pattern from the current state. ",
    "depth": 6},
   {"term":
    "Lean.TSyntaxArray `Lean.Parser.Term.bracketedBinder ‚Üí Lean.TSyntaxArray `Lean.Parser.Term.bracketedBinder",
    "name": "Mathlib.Command.Variable.cleanBinders",
    "doc": "Strip off whitespace and comments. ",
    "depth": 8},
   {"term":
    "Lean.TSyntax `Lean.Parser.Term.bracketedBinder ‚Üí Lean.Elab.TermElabM (Option Lean.MVarId)",
    "name": "Mathlib.Command.Variable.pendingActionableSynthMVar",
    "doc":
    "Find a synthetic typeclass metavariable with no expr metavariables in its type. ",
    "depth": 8},
   {"term":
    "Mathlib.Notation3.MatchState ‚Üí Array (Lean.TSyntax `Std.ExtendedBinder.extBinderParenthesized)",
    "name": "Mathlib.Notation3.MatchState.getBinders",
    "doc":
    "Get the accumulated array of delaborated terms for a given foldr/foldl.\nReturns `#[]` if nothing has been pushed yet. ",
    "depth": 8}],
  "count": 47},
 {"noDocExamples":
  [{"term": "‚àÄ (b : Bool), (true && b) = b",
    "name": "Bool.true_and",
    "depth": 5},
   {"term": "‚àÄ (b : Bool), (false && b) = false",
    "name": "Bool.false_and",
    "depth": 5},
   {"term": "‚àÄ (b : Bool), (b && false) = false",
    "name": "Bool.and_false",
    "depth": 5},
   {"term": "‚àÄ (b : Bool), (b && b) = b", "name": "Bool.and_self", "depth": 5},
   {"term": "‚àÄ (b : Bool), (b && true) = b",
    "name": "Bool.and_true",
    "depth": 5}],
  "kind": "¬´term_&&_¬ª",
  "examples": [],
  "count": 46},
 {"noDocExamples": [],
  "kind": "¬´term_‚âÉ‚ãÜ‚Çê[_]_¬ª",
  "examples":
  [{"term":
    "{R : Type u_2} ‚Üí\n  {A : Type u_3} ‚Üí [inst : Add A] ‚Üí [inst_1 : Mul A] ‚Üí [inst_2 : SMul R A] ‚Üí [inst_3 : Star A] ‚Üí A ‚âÉ‚ãÜ‚Çê[R] A",
    "name": "StarAlgEquiv.refl",
    "doc": "Star algebra equivalences are reflexive. ",
    "depth": 17},
   {"term":
    "{R : Type u_2} ‚Üí\n  {A : Type u_3} ‚Üí\n    {B : Type u_4} ‚Üí\n      [inst : Add A] ‚Üí\n        [inst_1 : Add B] ‚Üí\n          [inst_2 : Mul A] ‚Üí\n            [inst_3 : Mul B] ‚Üí\n              [inst_4 : SMul R A] ‚Üí [inst_5 : SMul R B] ‚Üí [inst_6 : Star A] ‚Üí [inst_7 : Star B] ‚Üí (A ‚âÉ‚ãÜ‚Çê[R] B) ‚Üí B ‚Üí A",
    "name": "StarAlgEquiv.Simps.symm_apply",
    "doc": "See Note [custom simps projection] ",
    "depth": 23},
   {"term":
    "{R : Type u_1} ‚Üí\n  {A : Type u_2} ‚Üí\n    {B : Type u_3} ‚Üí\n      [inst : Add A] ‚Üí\n        [inst_1 : Add B] ‚Üí\n          [inst_2 : Mul A] ‚Üí\n            [inst_3 : Mul B] ‚Üí\n              [inst_4 : SMul R A] ‚Üí [inst_5 : SMul R B] ‚Üí [inst_6 : Star A] ‚Üí [inst_7 : Star B] ‚Üí (A ‚âÉ‚ãÜ‚Çê[R] B) ‚Üí A ‚âÉ+* B",
    "name": "StarAlgEquiv.toRingEquiv",
    "doc":
    "Reinterpret a star algebra equivalence as a `RingEquiv` by forgetting the interaction with\nthe star operation and scalar multiplication. ",
    "depth": 23},
   {"term":
    "{R : Type u_2} ‚Üí\n  {A : Type u_3} ‚Üí\n    {B : Type u_4} ‚Üí\n      [inst : Add A] ‚Üí\n        [inst_1 : Add B] ‚Üí\n          [inst_2 : Mul A] ‚Üí\n            [inst_3 : Mul B] ‚Üí\n              [inst_4 : SMul R A] ‚Üí\n                [inst_5 : SMul R B] ‚Üí [inst_6 : Star A] ‚Üí [inst_7 : Star B] ‚Üí (A ‚âÉ‚ãÜ‚Çê[R] B) ‚Üí B ‚âÉ‚ãÜ‚Çê[R] A",
    "name": "StarAlgEquiv.symm",
    "doc": "Star algebra equivalences are symmetric. ",
    "depth": 23},
   {"term":
    "{R : Type u_2} ‚Üí\n  {A : Type u_3} ‚Üí\n    {B : Type u_4} ‚Üí\n      [inst : Add A] ‚Üí\n        [inst_1 : Add B] ‚Üí\n          [inst_2 : Mul A] ‚Üí\n            [inst_3 : Mul B] ‚Üí\n              [inst_4 : SMul R A] ‚Üí [inst_5 : SMul R B] ‚Üí [inst_6 : Star A] ‚Üí [inst_7 : Star B] ‚Üí (A ‚âÉ‚ãÜ‚Çê[R] B) ‚Üí A ‚Üí B",
    "name": "StarAlgEquiv.Simps.apply",
    "doc": "See Note [custom simps projection] ",
    "depth": 23}],
  "count": 46},
 {"noDocExamples":
  [{"term": "‚àÄ {Œ± : Type u_1} {l : List Œ±}, l <+: l",
    "name": "List.prefix_rfl",
    "depth": 5},
   {"term": "‚àÄ {Œ± : Type u_1} (l : List Œ±), [] <+: l",
    "name": "List.nil_prefix",
    "depth": 5}],
  "kind": "List.¬´term_<+:_¬ª",
  "examples":
  [{"term": "‚àÄ {Œ± : Type u_1} {l : List Œ±}, l <+: [] ‚Üí l = []",
    "name": "List.eq_nil_of_prefix_nil",
    "doc": "**Alias** of the forward direction of `List.prefix_nil`.",
    "depth": 7},
   {"term":
    "‚àÄ {Œ± : Type u_1} {l‚ÇÅ l‚ÇÇ : List Œ±}, l‚ÇÅ <:+ l‚ÇÇ ‚Üí List.reverse l‚ÇÅ <+: List.reverse l‚ÇÇ",
    "name": "List.isSuffix.reverse",
    "doc": "**Alias** of the reverse direction of `List.reverse_prefix`.",
    "depth": 8},
   {"term":
    "‚àÄ {Œ± : Type u_1} {l‚ÇÅ l‚ÇÇ : List Œ±}, l‚ÇÅ <+: l‚ÇÇ ‚Üí List.reverse l‚ÇÅ <:+ List.reverse l‚ÇÇ",
    "name": "List.isPrefix.reverse",
    "doc": "**Alias** of the reverse direction of `List.reverse_suffix`.",
    "depth": 8}],
  "count": 45},
 {"noDocExamples": [],
  "kind": "¬´term_‚Åª¬π'o_¬ª",
  "examples":
  [{"term":
    "{Œ± : Type u_1} ‚Üí {Œ≤ : Type u_2} ‚Üí (f : Œ± ‚Üí Œ≤) ‚Üí (s : Œ≤ ‚Üí Œ≤ ‚Üí Prop) ‚Üí f ‚Åª¬π'o s ‚Üír s",
    "name": "RelHom.preimage",
    "doc":
    "A function is a relation homomorphism from the preimage relation of `s` to `s`. ",
    "depth": 10},
   {"term":
    "{Œ± : Sort u_3} ‚Üí {Œ≤ : Sort u_4} ‚Üí (f : Œ± ‚Üí Œ≤) ‚Üí (s : Œ≤ ‚Üí Œ≤ ‚Üí Prop) ‚Üí [H : DecidableRel s] ‚Üí DecidableRel (f ‚Åª¬π'o s)",
    "name": "Order.Preimage.decidable",
    "doc": "The preimage of a decidable order is decidable. ",
    "depth": 10},
   {"term":
    "{X : Type u_5} ‚Üí (r : X ‚Üí X ‚Üí Prop) ‚Üí (p : X ‚Üí Prop) ‚Üí Subtype.val ‚Åª¬π'o r ‚Ü™r r",
    "name": "Subtype.relEmbedding",
    "doc":
    "The induced relation on a subtype is an embedding under the natural inclusion. ",
    "depth": 11},
   {"term":
    "{Œ± : Type u_1} ‚Üí {Œ≤ : Type u_2} ‚Üí (f : Œ± ‚âÉ Œ≤) ‚Üí (s : Œ≤ ‚Üí Œ≤ ‚Üí Prop) ‚Üí ‚Üëf ‚Åª¬π'o s ‚âÉr s",
    "name": "RelIso.preimage",
    "doc":
    "Any equivalence lifts to a relation isomorphism between `s` and its preimage. ",
    "depth": 15},
   {"term":
    "{Œ± : Type u_1} ‚Üí {Œ≤ : Type u_2} ‚Üí (f : Œ± ‚Ü™ Œ≤) ‚Üí (s : Œ≤ ‚Üí Œ≤ ‚Üí Prop) ‚Üí ‚Üëf ‚Åª¬π'o s ‚Ü™r s",
    "name": "RelEmbedding.preimage",
    "doc":
    "If `f` is injective, then it is a relation embedding from the\npreimage relation of `s` to `s`. ",
    "depth": 16}],
  "count": 45},
 {"noDocExamples": [],
  "kind": "¬´term_‚âÉ+*o_¬ª",
  "examples":
  [{"term":
    "(Œ± : Type u_2) ‚Üí [inst : Mul Œ±] ‚Üí [inst_1 : Add Œ±] ‚Üí [inst_2 : LE Œ±] ‚Üí Œ± ‚âÉ+*o Œ±",
    "name": "OrderRingIso.refl",
    "doc": "The identity map as an ordered ring isomorphism. ",
    "depth": 12},
   {"term":
    "{Œ± : Type u_2} ‚Üí\n  {Œ≤ : Type u_3} ‚Üí\n    [inst : NonAssocSemiring Œ±] ‚Üí\n      [inst_1 : Preorder Œ±] ‚Üí [inst_2 : NonAssocSemiring Œ≤] ‚Üí [inst_3 : Preorder Œ≤] ‚Üí Œ± ‚âÉ+*o Œ≤ ‚Üí Œ± ‚Üí+*o Œ≤",
    "name": "OrderRingIso.toOrderRingHom",
    "doc":
    "Reinterpret an ordered ring isomorphism as an ordered ring homomorphism. ",
    "depth": 16},
   {"term":
    "{Œ± : Type u_2} ‚Üí\n  {Œ≤ : Type u_3} ‚Üí\n    [inst : Mul Œ±] ‚Üí\n      [inst_1 : Add Œ±] ‚Üí [inst_2 : LE Œ±] ‚Üí [inst_3 : Mul Œ≤] ‚Üí [inst_4 : Add Œ≤] ‚Üí [inst_5 : LE Œ≤] ‚Üí Œ± ‚âÉ+*o Œ≤ ‚Üí Œ≤ ‚Üí Œ±",
    "name": "OrderRingIso.Simps.symm_apply",
    "doc": "See Note [custom simps projection] ",
    "depth": 17},
   {"term":
    "{Œ± : Type u_2} ‚Üí\n  {Œ≤ : Type u_3} ‚Üí\n    [inst : Mul Œ±] ‚Üí\n      [inst_1 : Add Œ±] ‚Üí [inst_2 : LE Œ±] ‚Üí [inst_3 : Mul Œ≤] ‚Üí [inst_4 : Add Œ≤] ‚Üí [inst_5 : LE Œ≤] ‚Üí Œ± ‚âÉ+*o Œ≤ ‚Üí Œ≤ ‚âÉ+*o Œ±",
    "name": "OrderRingIso.symm",
    "doc":
    "The inverse of an ordered ring isomorphism as an ordered ring isomorphism. ",
    "depth": 17},
   {"term":
    "{Œ± : Type u_2} ‚Üí\n  {Œ≤ : Type u_3} ‚Üí\n    [inst : Mul Œ±] ‚Üí\n      [inst_1 : Add Œ±] ‚Üí [inst_2 : LE Œ±] ‚Üí [inst_3 : Mul Œ≤] ‚Üí [inst_4 : Add Œ≤] ‚Üí [inst_5 : LE Œ≤] ‚Üí Œ± ‚âÉ+*o Œ≤ ‚Üí Œ± ‚âÉo Œ≤",
    "name": "OrderRingIso.toOrderIso",
    "doc": "Reinterpret an ordered ring isomorphism as an order isomorphism. ",
    "depth": 17}],
  "count": 44},
 {"noDocExamples": [],
  "kind": "¬´term_‚Üí·µà_¬ª",
  "examples":
  [{"term": "(Œ± : Type u_6) ‚Üí [inst : PseudoEMetricSpace Œ±] ‚Üí Œ± ‚Üí·µà Œ±",
    "name": "Dilation.id",
    "doc": "The identity is a dilation ",
    "depth": 6},
   {"term":
    "{Œ± : Type u_1} ‚Üí [inst : PseudoEMetricSpace Œ±] ‚Üí (Œ± ‚Üí·µà Œ±) ‚Üí* NNReal",
    "name": "Dilation.ratioHom",
    "doc": "`Dilation.ratio` as a monoid homomorphism from `Œ± ‚Üí·µà Œ±` to `‚Ñù‚â•0`. ",
    "depth": 10},
   {"term":
    "{Œ± : Type u_1} ‚Üí\n  {Œ≤ : Type u_2} ‚Üí\n    {Œ≥ : Type u_3} ‚Üí\n      [inst : PseudoEMetricSpace Œ±] ‚Üí\n        [inst_1 : PseudoEMetricSpace Œ≤] ‚Üí [inst_2 : PseudoEMetricSpace Œ≥] ‚Üí Œ≤ ‚Üí·µà Œ≥ ‚Üí Œ± ‚Üí·µà Œ≤ ‚Üí Œ± ‚Üí·µà Œ≥",
    "name": "Dilation.comp",
    "doc": "The composition of dilations is a dilation ",
    "depth": 12},
   {"term":
    "{Œ± : Type u_6} ‚Üí\n  {Œ≤ : Type u_7} ‚Üí\n    [inst : PseudoMetricSpace Œ±] ‚Üí\n      [inst_1 : PseudoMetricSpace Œ≤] ‚Üí\n        (f : Œ± ‚Üí Œ≤) ‚Üí (‚àÉ r, r ‚â† 0 ‚àß ‚àÄ (x y : Œ±), dist (f x) (f y) = ‚Üër * dist x y) ‚Üí Œ± ‚Üí·µà Œ≤",
    "name": "Dilation.mkOfDistEq",
    "doc":
    "Alternative `Dilation` constructor when the distance hypothesis is over `dist` ",
    "depth": 18},
   {"term":
    "{Œ± : Type u_6} ‚Üí\n  {Œ≤ : Type u_7} ‚Üí\n    [inst : PseudoMetricSpace Œ±] ‚Üí\n      [inst_1 : PseudoMetricSpace Œ≤] ‚Üí\n        (f : Œ± ‚Üí Œ≤) ‚Üí (‚àÉ r, r ‚â† 0 ‚àß ‚àÄ (x y : Œ±), nndist (f x) (f y) = r * nndist x y) ‚Üí Œ± ‚Üí·µà Œ≤",
    "name": "Dilation.mkOfNNDistEq",
    "doc":
    "Alternative `Dilation` constructor when the distance hypothesis is over `nndist` ",
    "depth": 18}],
  "count": 44},
 {"noDocExamples": [],
  "kind": "Sigma.Lex.¬´termŒ£‚Çó_,_¬ª",
  "examples":
  [{"term":
    "{Œπ : Type u_1} ‚Üí {Œ± : Œπ ‚Üí Type u_2} ‚Üí [inst : LT Œπ] ‚Üí [inst : (i : Œπ) ‚Üí LT (Œ± i)] ‚Üí LT (Œ£‚Çó (i : Œπ), Œ± i)",
    "name": "Sigma.Lex.LT",
    "doc": "The lexicographical `<` on a sigma type. ",
    "depth": 9},
   {"term":
    "{Œπ : Type u_1} ‚Üí\n  {Œ± : Œπ ‚Üí Type u_2} ‚Üí [inst : Preorder Œπ] ‚Üí [inst : (i : Œπ) ‚Üí Preorder (Œ± i)] ‚Üí Preorder (Œ£‚Çó (i : Œπ), Œ± i)",
    "name": "Sigma.Lex.preorder",
    "doc": "The lexicographical preorder on a sigma type. ",
    "depth": 9},
   {"term":
    "{Œπ : Type u_1} ‚Üí\n  {Œ± : Œπ ‚Üí Type u_2} ‚Üí [inst : Preorder Œπ] ‚Üí [inst : (i : Œπ) ‚Üí PartialOrder (Œ± i)] ‚Üí PartialOrder (Œ£‚Çó (i : Œπ), Œ± i)",
    "name": "Sigma.Lex.partialOrder",
    "doc": "The lexicographical partial order on a sigma type. ",
    "depth": 9},
   {"term":
    "{Œπ : Type u_1} ‚Üí {Œ± : Œπ ‚Üí Type u_2} ‚Üí [inst : LT Œπ] ‚Üí [inst : (i : Œπ) ‚Üí LE (Œ± i)] ‚Üí LE (Œ£‚Çó (i : Œπ), Œ± i)",
    "name": "Sigma.Lex.LE",
    "doc": "The lexicographical `‚â§` on a sigma type. ",
    "depth": 9},
   {"term":
    "{Œπ : Type u_1} ‚Üí\n  {Œ± : Œπ ‚Üí Type u_2} ‚Üí [inst : LinearOrder Œπ] ‚Üí [inst : (i : Œπ) ‚Üí LinearOrder (Œ± i)] ‚Üí LinearOrder (Œ£‚Çó (i : Œπ), Œ± i)",
    "name": "Sigma.Lex.linearOrder",
    "doc": "The lexicographical linear order on a sigma type. ",
    "depth": 9}],
  "count": 42},
 {"noDocExamples":
  [{"term":
    "‚àÄ {Œ± : Type u} [inst : Lattice Œ±] [inst_1 : AddGroup Œ±] (a : Œ±), a ‚â§ a‚Å∫",
    "name": "LatticeOrderedGroup.le_pos",
    "depth": 12}],
  "kind": "¬´term_‚Å∫¬ª",
  "examples":
  [{"term":
    "‚àÄ {Œ± : Type u} [inst : Lattice Œ±] [inst_1 : Group Œ±] (a : Œ±), 1 ‚â§ a ‚Üí a‚Å∫ = a",
    "name": "LatticeOrderedGroup.pos_of_one_le",
    "doc":
    "If `a` is positive, then it is equal to its positive component `a‚Å∫`. ",
    "depth": 14},
   {"term":
    "‚àÄ {Œ± : Type u} [inst : Lattice Œ±] [inst_1 : AddGroup Œ±] (a : Œ±), 0 ‚â§ a ‚Üí a‚Å∫ = a",
    "name": "LatticeOrderedGroup.pos_of_nonneg",
    "doc":
    "If `a` is positive, then it is equal to its positive component `a‚Å∫`.",
    "depth": 14},
   {"term":
    "‚àÄ {Œ© : Type u_1} {m0 : MeasurableSpace Œ©} {Œº : MeasureTheory.Measure Œ©} {f : ‚Ñï ‚Üí Œ© ‚Üí ‚Ñù}\n  {‚Ñ± : MeasureTheory.Filtration ‚Ñï m0} [inst : MeasureTheory.IsFiniteMeasure Œº] (a b : ‚Ñù),\n  MeasureTheory.Submartingale f ‚Ñ± Œº ‚Üí\n    ENNReal.ofReal (b - a) * ‚à´‚Åª (œâ : Œ©), MeasureTheory.upcrossings a b f œâ ‚àÇŒº ‚â§\n      ‚®Ü (N : ‚Ñï), ‚à´‚Åª (œâ : Œ©), ENNReal.ofReal (f N œâ - a)‚Å∫ ‚àÇŒº",
    "name":
    "MeasureTheory.Submartingale.mul_lintegral_upcrossings_le_lintegral_pos_part",
    "doc":
    "A variant of Doob's upcrossing estimate obtained by taking the supremum on both sides. ",
    "depth": 24},
   {"term":
    "‚àÄ {Œ© : Type u_1} {m0 : MeasurableSpace Œ©} {Œº : MeasureTheory.Measure Œ©} {f : ‚Ñï ‚Üí Œ© ‚Üí ‚Ñù}\n  {‚Ñ± : MeasureTheory.Filtration ‚Ñï m0} [inst : MeasureTheory.IsFiniteMeasure Œº] (a b : ‚Ñù),\n  MeasureTheory.Submartingale f ‚Ñ± Œº ‚Üí\n    ‚àÄ (N : ‚Ñï),\n      (b - a) * ‚à´ (x : Œ©), ‚Üë(MeasureTheory.upcrossingsBefore a b f N x) ‚àÇŒº ‚â§ ‚à´ (x : Œ©), (fun œâ => (f N œâ - a)‚Å∫) x ‚àÇŒº",
    "name":
    "MeasureTheory.Submartingale.mul_integral_upcrossingsBefore_le_integral_pos_part",
    "doc":
    "**Doob's upcrossing estimate**: given a real valued discrete submartingale `f` and real\nvalues `a` and `b`, we have `(b - a) * ùîº[upcrossingsBefore a b f N] ‚â§ ùîº[(f N - a)‚Å∫]` where\n`upcrossingsBefore a b f N` is the number of times the process `f` crossed from below `a` to above\n`b` before the time `N`. ",
    "depth": 27}],
  "count": 42},
 {"noDocExamples": [],
  "kind": "MeasureTheory.¬´term‚à´_,_¬ª",
  "examples":
  [{"term":
    "‚àÄ {b : ‚ÑÇ}, 0 < b.re ‚Üí (‚à´ (x : ‚Ñù), cexp (-b * ‚Üëx ^ 2)) ^ 2 = ‚ÜëReal.pi / b",
    "name": "integral_gaussian_sq_complex",
    "doc":
    "The *square* of the Gaussian integral `‚à´ x:‚Ñù, exp (-b * x^2)` is equal to `œÄ / b`. ",
    "depth": 18},
   {"term":
    "‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] (t : ‚Ñù) (f : UnitAddCircle ‚Üí E),\n  ‚à´ (a : ‚Ñù) in Set.Ioc t (t + 1), f ‚Üëa = ‚à´ (b : UnitAddCircle), f b",
    "name": "UnitAddCircle.integral_preimage",
    "doc":
    "The integral of an almost-everywhere strongly measurable function over `UnitAddCircle` is\nequal to the integral over an interval (t, t + 1] in `‚Ñù` of its lift to `‚Ñù`. ",
    "depth": 18},
   {"term":
    "‚àÄ {Œ© : Type u_1} [inst : MeasureTheory.MeasureSpace Œ©]\n  [inst_1 : MeasureTheory.IsProbabilityMeasure MeasureTheory.volume] (X : ‚Ñï ‚Üí Œ© ‚Üí ‚Ñù),\n  MeasureTheory.Integrable (X 0) ‚Üí\n    (‚àÄ (i : ‚Ñï), ProbabilityTheory.IdentDistrib (X i) (X 0)) ‚Üí\n      (fun n =>\n          (‚à´ (a : Œ©), Finset.sum (Finset.range n) (fun i => ProbabilityTheory.truncation (X i) ‚Üëi) a) -\n            ‚Üën * ‚à´ (a : Œ©), X 0 a) =o[Filter.atTop]\n        Nat.cast",
    "name": "ProbabilityTheory.strong_law_aux3",
    "doc":
    "The expectation of the truncated version of `X·µ¢` behaves asymptotically like the whole\nexpectation. This follows from convergence and Ces√†ro averaging. ",
    "depth": 20},
   {"term":
    "‚àÄ {Œ© : Type u_1} {m : MeasurableSpace Œ©} {‚Ñô : MeasureTheory.Measure Œ©} [inst : MeasureTheory.IsFiniteMeasure ‚Ñô]\n  {X : Œ© ‚Üí ‚Ñù} [inst : MeasureTheory.HasPDF X ‚Ñô],\n  ‚à´ (x : ‚Ñù), x * ENNReal.toReal (MeasureTheory.pdf X ‚Ñô x) = ‚à´ (x : Œ©), X x ‚àÇ‚Ñô",
    "name": "MeasureTheory.pdf.integral_mul_eq_integral",
    "doc":
    "If `X` is a real-valued random variable that has pdf `f`, then the expectation of `X` equals\n`‚à´ x, x * f x ‚àÇŒª` where `Œª` is the Lebesgue measure. ",
    "depth": 20},
   {"term":
    "‚àÄ {Œ© : Type u_1} [inst : MeasureTheory.MeasureSpace Œ©]\n  [inst_1 : MeasureTheory.IsProbabilityMeasure MeasureTheory.volume] (X : ‚Ñï ‚Üí Œ© ‚Üí ‚Ñù),\n  MeasureTheory.Integrable (X 0) ‚Üí\n    (Pairwise fun i j => ProbabilityTheory.IndepFun (X i) (X j)) ‚Üí\n      (‚àÄ (i : ‚Ñï), ProbabilityTheory.IdentDistrib (X i) (X 0)) ‚Üí\n        ‚àÄ·µê (œâ : Œ©),\n          Filter.Tendsto (fun n => (Finset.sum (Finset.range n) fun i => X i œâ) / ‚Üën) Filter.atTop\n            (nhds (‚à´ (a : Œ©), X 0 a))",
    "name": "ProbabilityTheory.strong_law_ae",
    "doc":
    "**Strong law of large numbers**, almost sure version: if `X n` is a sequence of independent\nidentically distributed integrable real-valued random variables, then `‚àë i in range n, X i / n`\nconverges almost surely to `ùîº[X 0]`. We give here the strong version, due to Etemadi, that only\nrequires pairwise independence. ",
    "depth": 21}],
  "count": 42},
 {"noDocExamples":
  [{"term":
    "‚àÄ (x : ‚Ñï) (r : ‚Ñù), Metric.closedBall x r = Set.Icc ‚åà‚Üëx - r‚åâ‚Çä ‚åä‚Üëx + r‚åã‚Çä",
    "name": "Nat.closedBall_eq_Icc",
    "depth": 12},
   {"term":
    "‚àÄ {Œ± : Type u_2} [inst : LinearOrderedSemiring Œ±] [inst_1 : FloorSemiring Œ±], ‚åà1‚åâ‚Çä = 1",
    "name": "Nat.ceil_one",
    "depth": 12},
   {"term":
    "‚àÄ {Œ± : Type u_2} [inst : LinearOrderedRing Œ±] [inst_1 : FloorRing Œ±] (a : Œ±), Int.toNat ‚åàa‚åâ = ‚åàa‚åâ‚Çä",
    "name": "Int.ceil_toNat",
    "depth": 12},
   {"term":
    "‚àÄ {Œ± : Type u_2} [inst : LinearOrderedSemiring Œ±] [inst_1 : FloorSemiring Œ±] (a : Œ±), a ‚â§ ‚Üë‚åàa‚åâ‚Çä",
    "name": "Nat.le_ceil",
    "depth": 12}],
  "kind": "Nat.¬´term‚åà_‚åâ‚Çä¬ª",
  "examples":
  [{"term":
    "‚àÄ {Fq : Type u_1} [inst : Fintype Fq] [inst_1 : Field Fq] {b : Polynomial Fq},\n  b ‚â† 0 ‚Üí\n    ‚àÄ {Œµ : ‚Ñù},\n      0 < Œµ ‚Üí\n        ‚àÄ (A : Fin (Nat.succ (Fintype.card Fq ^ ‚åà-Real.log Œµ / Real.log ‚Üë(Fintype.card Fq)‚åâ‚Çä)) ‚Üí Polynomial Fq),\n          ‚àÉ i‚ÇÄ i‚ÇÅ, i‚ÇÄ ‚â† i‚ÇÅ ‚àß ‚Üë(‚ÜëPolynomial.cardPowDegree (A i‚ÇÅ % b - A i‚ÇÄ % b)) < ‚ÜëPolynomial.cardPowDegree b ‚Ä¢ Œµ",
    "name": "Polynomial.exists_approx_polynomial",
    "doc":
    "If `A` is a family of enough low-degree polynomials over a finite field,\nthere is a pair of elements in `A` (with different indices but not necessarily\ndistinct), such that the difference of their remainders is close together. ",
    "depth": 35}],
  "count": 42},
 {"noDocExamples": [],
  "kind": "¬´term‚àÆ_InC(_,_),_¬ª",
  "examples":
  [{"term":
    "‚àÄ {c w : ‚ÑÇ} {R : ‚Ñù}, w ‚àà Metric.ball c R ‚Üí (‚àÆ (z : ‚ÑÇ) in C(c, R), (z - w)‚Åª¬π) = 2 * ‚ÜëReal.pi * Complex.I",
    "name": "circleIntegral.integral_sub_inv_of_mem_ball",
    "doc":
    "Integral $\\oint_{|z-c|=R} \\frac{dz}{z-w} = 2œÄi$ whenever $|w-c| < R$. ",
    "depth": 17},
   {"term":
    "‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚ÑÇ E] (f : (Fin 1 ‚Üí ‚ÑÇ) ‚Üí E) (c : Fin 1 ‚Üí ‚ÑÇ)\n  (R : Fin 1 ‚Üí ‚Ñù), (‚àØ (x : Fin 1 ‚Üí ‚ÑÇ) in T(c, R), f x) = ‚àÆ (z : ‚ÑÇ) in C(c 0, R 0), f fun x => z",
    "name": "torusIntegral_dim1",
    "doc":
    "In dimension one, `torusIntegral` is the same as `circleIntegral`\n(up to the natural equivalence between `‚ÑÇ` and `Fin 1 ‚Üí ‚ÑÇ`). ",
    "depth": 18},
   {"term":
    "‚àÄ {n : ‚Ñ§}, n ‚â† -1 ‚Üí ‚àÄ (c w : ‚ÑÇ) (R : ‚Ñù), (‚àÆ (z : ‚ÑÇ) in C(c, R), (z - w) ^ n) = 0",
    "name": "circleIntegral.integral_sub_zpow_of_ne",
    "doc":
    "If `n ‚â† -1` is an integer number, then the integral of `(z - w) ^ n` over the circle equals\nzero. ",
    "depth": 20},
   {"term":
    "‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚ÑÇ E] [inst_2 : CompleteSpace E] {f f' : ‚ÑÇ ‚Üí E}\n  {c : ‚ÑÇ} {R : ‚Ñù},\n  (‚àÄ (z : ‚ÑÇ), z ‚àà Metric.sphere c |R| ‚Üí HasDerivWithinAt f (f' z) (Metric.sphere c |R|) z) ‚Üí\n    (‚àÆ (z : ‚ÑÇ) in C(c, R), f' z) = 0",
    "name": "circleIntegral.integral_eq_zero_of_hasDerivWithinAt'",
    "doc":
    "If `f' : ‚ÑÇ ‚Üí E` is a derivative of a complex differentiable function on the circle\n`Metric.sphere c |R|`, then `‚àÆ z in C(c, R), f' z = 0`. ",
    "depth": 21},
   {"term":
    "‚àÄ {n : ‚Ñ§} {c w : ‚ÑÇ} {R : ‚Ñù}, n < 0 ‚Üí w ‚àà Metric.sphere c |R| ‚Üí (‚àÆ (z : ‚ÑÇ) in C(c, R), (z - w) ^ n) = 0",
    "name": "circleIntegral.integral_sub_zpow_of_undef",
    "doc":
    "If `n < 0` and `|w - c| = |R|`, then `(z - w) ^ n` is not circle integrable on the circle with\ncenter `c` and radius `|R|`, so the integral `‚àÆ z in C(c, R), (z - w) ^ n` is equal to zero. ",
    "depth": 21}],
  "count": 42},
 {"noDocExamples": [],
  "kind": "¬´MulSemiringActionHomLocal‚â∫¬ª",
  "examples":
  [{"term":
    "(M : Type u_5) ‚Üí\n  [inst : Monoid M] ‚Üí {R : Type u_11} ‚Üí [inst_1 : Semiring R] ‚Üí [inst_2 : MulSemiringAction M R] ‚Üí R ‚Üí+*[M] R",
    "name": "MulSemiringActionHom.id",
    "doc": "The identity map as an equivariant ring homomorphism. ",
    "depth": 13},
   {"term":
    "{M : Type u_5} ‚Üí\n  [inst : Monoid M] ‚Üí\n    {R : Type u_11} ‚Üí\n      [inst_1 : Semiring R] ‚Üí\n        [inst_2 : MulSemiringAction M R] ‚Üí\n          {S : Type u_13} ‚Üí [inst_3 : Semiring S] ‚Üí [inst_4 : MulSemiringAction M S] ‚Üí (R ‚Üí+*[M] S) ‚Üí R ‚Üí+* S",
    "name": "MulSemiringActionHom.toRingHom",
    "doc":
    "Reinterpret an equivariant ring homomorphism as a ring homomorphism. ",
    "depth": 17},
   {"term":
    "{M : Type u_1} ‚Üí\n  [inst : Monoid M] ‚Üí\n    {P : Type u_2} ‚Üí\n      [inst_1 : CommSemiring P] ‚Üí\n        [inst_2 : MulSemiringAction M P] ‚Üí\n          {Q : Type u_3} ‚Üí\n            [inst_3 : CommSemiring Q] ‚Üí\n              [inst_4 : MulSemiringAction M Q] ‚Üí (P ‚Üí+*[M] Q) ‚Üí Polynomial P ‚Üí+*[M] Polynomial Q",
    "name": "MulSemiringActionHom.polynomial",
    "doc": "An equivariant map induces an equivariant map on polynomials. ",
    "depth": 18},
   {"term":
    "{M : Type u_5} ‚Üí\n  [inst : Monoid M] ‚Üí\n    {R : Type u_11} ‚Üí\n      [inst_1 : Semiring R] ‚Üí\n        [inst_2 : MulSemiringAction M R] ‚Üí\n          {S : Type u_13} ‚Üí\n            [inst_3 : Semiring S] ‚Üí\n              [inst_4 : MulSemiringAction M S] ‚Üí\n                {F : Type u_16} ‚Üí [inst_5 : MulSemiringActionHomClass F M R S] ‚Üí F ‚Üí R ‚Üí+*[M] S",
    "name": "MulSemiringActionHomClass.toMulSemiringActionHom",
    "doc":
    "Turn an element of a type `F` satisfying `MulSemiringActionHomClass F M R S` into an actual\n`MulSemiringActionHom`. This is declared as the default coercion from `F` to\n`MulSemiringActionHom M X Y`. ",
    "depth": 19},
   {"term":
    "{M : Type u_5} ‚Üí\n  [inst : Monoid M] ‚Üí\n    {R : Type u_11} ‚Üí\n      [inst_1 : Semiring R] ‚Üí\n        [inst_2 : MulSemiringAction M R] ‚Üí\n          {S : Type u_13} ‚Üí [inst_3 : Semiring S] ‚Üí [inst_4 : MulSemiringAction M S] ‚Üí (R ‚Üí+*[M] S) ‚Üí R ‚Üí+[M] S",
    "name": "MulSemiringActionHom.toDistribMulActionHom",
    "doc":
    "Reinterpret an equivariant ring homomorphism as an equivariant additive monoid homomorphism. ",
    "depth": 19}],
  "count": 41},
 {"noDocExamples": [],
  "kind": "PSigma.¬´termŒ£‚Çó'_,_¬ª",
  "examples":
  [{"term":
    "{Œπ : Type u_1} ‚Üí\n  {Œ± : Œπ ‚Üí Type u_2} ‚Üí [inst : LinearOrder Œπ] ‚Üí [inst : (i : Œπ) ‚Üí LinearOrder (Œ± i)] ‚Üí LinearOrder (Œ£‚Çó' (i : Œπ), Œ± i)",
    "name": "PSigma.Lex.linearOrder",
    "doc": "Dictionary / lexicographic linear_order for pairs. ",
    "depth": 9},
   {"term":
    "{Œπ : Type u_1} ‚Üí\n  {Œ± : Œπ ‚Üí Type u_2} ‚Üí [inst : PartialOrder Œπ] ‚Üí [inst : (i : Œπ) ‚Üí PartialOrder (Œ± i)] ‚Üí PartialOrder (Œ£‚Çó' (i : Œπ), Œ± i)",
    "name": "PSigma.Lex.partialOrder",
    "doc": "Dictionary / lexicographic partial_order for dependent pairs. ",
    "depth": 9},
   {"term":
    "{Œπ : Type u_1} ‚Üí {Œ± : Œπ ‚Üí Type u_2} ‚Üí [inst : LT Œπ] ‚Üí [inst : (i : Œπ) ‚Üí LT (Œ± i)] ‚Üí LT (Œ£‚Çó' (i : Œπ), Œ± i)",
    "name": "PSigma.Lex.lt",
    "doc": "The lexicographical `<` on a sigma type. ",
    "depth": 9},
   {"term":
    "{Œπ : Type u_1} ‚Üí {Œ± : Œπ ‚Üí Type u_2} ‚Üí [inst : LT Œπ] ‚Üí [inst : (i : Œπ) ‚Üí LE (Œ± i)] ‚Üí LE (Œ£‚Çó' (i : Œπ), Œ± i)",
    "name": "PSigma.Lex.le",
    "doc": "The lexicographical `‚â§` on a sigma type. ",
    "depth": 9},
   {"term":
    "{Œπ : Type u_1} ‚Üí\n  {Œ± : Œπ ‚Üí Type u_2} ‚Üí\n    [inst : PartialOrder Œπ] ‚Üí\n      [inst_1 : OrderTop Œπ] ‚Üí\n        [inst_2 : (i : Œπ) ‚Üí Preorder (Œ± i)] ‚Üí [inst_3 : OrderTop (Œ± ‚ä§)] ‚Üí OrderTop (Œ£‚Çó' (i : Œπ), Œ± i)",
    "name": "PSigma.Lex.orderTop",
    "doc": "The lexicographical linear order on a sigma type. ",
    "depth": 16}],
  "count": 41},
 {"noDocExamples": [],
  "kind": "¬´term_‚ãä[_]_¬ª",
  "examples":
  [{"term":
    "{N : Type u_1} ‚Üí {G : Type u_2} ‚Üí [inst : Group N] ‚Üí [inst_1 : Group G] ‚Üí {œÜ : G ‚Üí* MulAut N} ‚Üí N ‚ãä[œÜ] G ‚Üí N",
    "name": "SemidirectProduct.left",
    "doc": "The element of N ",
    "depth": 16},
   {"term":
    "{N : Type u_1} ‚Üí {G : Type u_2} ‚Üí [inst : Group N] ‚Üí [inst_1 : Group G] ‚Üí {œÜ : G ‚Üí* MulAut N} ‚Üí N ‚Üí* N ‚ãä[œÜ] G",
    "name": "SemidirectProduct.inl",
    "doc": "The canonical map `N ‚Üí* N ‚ãä[œÜ] G` sending `n` to `‚ü®n, 1‚ü©` ",
    "depth": 16},
   {"term":
    "{N : Type u_1} ‚Üí {G : Type u_2} ‚Üí [inst : Group N] ‚Üí [inst_1 : Group G] ‚Üí {œÜ : G ‚Üí* MulAut N} ‚Üí N ‚ãä[œÜ] G ‚Üí G",
    "name": "SemidirectProduct.right",
    "doc": "The element of G ",
    "depth": 16},
   {"term":
    "{N : Type u_1} ‚Üí {G : Type u_2} ‚Üí [inst : Group N] ‚Üí [inst_1 : Group G] ‚Üí {œÜ : G ‚Üí* MulAut N} ‚Üí G ‚Üí* N ‚ãä[œÜ] G",
    "name": "SemidirectProduct.inr",
    "doc": "The canonical map `G ‚Üí* N ‚ãä[œÜ] G` sending `g` to `‚ü®1, g‚ü©` ",
    "depth": 16},
   {"term":
    "{N : Type u_1} ‚Üí {G : Type u_2} ‚Üí [inst : Group N] ‚Üí [inst_1 : Group G] ‚Üí {œÜ : G ‚Üí* MulAut N} ‚Üí N ‚ãä[œÜ] G ‚Üí* G",
    "name": "SemidirectProduct.rightHom",
    "doc": "The canonical projection map `N ‚ãä[œÜ] G ‚Üí* G`, as a group hom. ",
    "depth": 16}],
  "count": 41},
 {"noDocExamples":
  [{"term": "‚àÄ {Œ± : Type u_1} (l : List Œ±), l <:+ l",
    "name": "List.suffix_refl",
    "depth": 5},
   {"term": "‚àÄ {Œ± : Type u_1} {l : List Œ±}, l <:+ l",
    "name": "List.suffix_rfl",
    "depth": 5}],
  "kind": "List.¬´term_<:+_¬ª",
  "examples":
  [{"term": "‚àÄ {Œ± : Type u_1} {l : List Œ±}, l <:+ [] ‚Üí l = []",
    "name": "List.eq_nil_of_suffix_nil",
    "doc": "**Alias** of the forward direction of `List.suffix_nil`.",
    "depth": 7},
   {"term":
    "‚àÄ {Œ± : Type u_1} {l‚ÇÅ l‚ÇÇ : List Œ±}, l‚ÇÅ <:+ l‚ÇÇ ‚Üí List.reverse l‚ÇÅ <+: List.reverse l‚ÇÇ",
    "name": "List.isSuffix.reverse",
    "doc": "**Alias** of the reverse direction of `List.reverse_prefix`.",
    "depth": 8},
   {"term":
    "‚àÄ {Œ± : Type u_1} {l‚ÇÅ l‚ÇÇ : List Œ±}, l‚ÇÅ <+: l‚ÇÇ ‚Üí List.reverse l‚ÇÅ <:+ List.reverse l‚ÇÇ",
    "name": "List.isPrefix.reverse",
    "doc": "**Alias** of the reverse direction of `List.reverse_suffix`.",
    "depth": 8}],
  "count": 40},
 {"noDocExamples": [],
  "kind": "OreLocalization.¬´term_/‚Çí_¬ª",
  "examples":
  [{"term":
    "‚àÄ {R : Type u_1} [inst : Monoid R] {S : Submonoid R} [inst_1 : OreLocalization.OreSet S] {r r' r‚ÇÅ r‚ÇÇ : R}\n  {s t : { x // x ‚àà S }}, r * ‚Üët = r' * ‚Üët ‚Üí r‚ÇÅ * r * r‚ÇÇ /‚Çí s = r‚ÇÅ * r' * r‚ÇÇ /‚Çí s",
    "name": "OreLocalization.eq_of_num_factor_eq",
    "doc":
    "Fractions which differ by a factor of the numerator can be proven equal if\nthose factors expand to equal elements of `R`. ",
    "depth": 25},
   {"term":
    "‚àÄ {R : Type u_1} [inst : Monoid R] {S : Submonoid R} [inst_1 : OreLocalization.OreSet S] (r : R) (s : { x // x ‚àà S })\n  (t : R) (hst : ‚Üës * t ‚àà S), r /‚Çí s = r * t /‚Çí { val := ‚Üës * t, property := hst }",
    "name": "OreLocalization.expand",
    "doc":
    "A fraction `r /‚Çí s` is equal to its expansion by an arbitrary factor `t` if `s * t ‚àà S`. ",
    "depth": 25},
   {"term":
    "‚àÄ {R : Type u_1} [inst : Monoid R] {S : Submonoid R} [inst_1 : OreLocalization.OreSet S] (r : R)\n  (s s' : { x // x ‚àà S }), r /‚Çí s = r * ‚Üës' /‚Çí (s * s')",
    "name": "OreLocalization.expand'",
    "doc": "A fraction is equal to its expansion by a factor from s. ",
    "depth": 26},
   {"term":
    "‚àÄ {R : Type u_1} [inst : Monoid R] {S : Submonoid R} [inst_1 : OreLocalization.OreSet S] (r‚ÇÅ r‚ÇÇ : R)\n  (s‚ÇÅ s‚ÇÇ : { x // x ‚àà S }) (r' : R) (s' : { x // x ‚àà S }),\n  r‚ÇÇ * ‚Üës' = ‚Üës‚ÇÅ * r' ‚Üí r‚ÇÅ /‚Çí s‚ÇÅ * (r‚ÇÇ /‚Çí s‚ÇÇ) = r‚ÇÅ * r' /‚Çí (s‚ÇÇ * s')",
    "name": "OreLocalization.oreDiv_mul_char",
    "doc":
    "A characterization lemma for the multiplication on the Ore localization, allowing for a choice\nof Ore numerator and Ore denominator. ",
    "depth": 30},
   {"term":
    "‚àÄ {R : Type u_1} [inst : Semiring R] {S : Submonoid R} [inst_1 : OreLocalization.OreSet S] {r r' : R}\n  (s s' : { x // x ‚àà S }) (rb : R) (sb : { x // x ‚àà S }),\n  ‚Üës * ‚Üësb = ‚Üës' * rb ‚Üí r /‚Çí s + r' /‚Çí s' = (r * ‚Üësb + r' * rb) /‚Çí (s * sb)",
    "name": "OreLocalization.oreDiv_add_char",
    "doc":
    "A characterization of the addition on the Ore localizaion, allowing for arbitrary Ore\nnumerator and Ore denominator. ",
    "depth": 32}],
  "count": 38},
 {"noDocExamples":
  [{"term":
    "‚àÄ {Œ± : Type u} [inst : Lattice Œ±] [inst_1 : AddGroup Œ±] (a : Œ±), -a ‚â§ a‚Åª",
    "name": "LatticeOrderedGroup.neg_le_neg",
    "depth": 13},
   {"term": "‚àÄ {Œ± : Type u} [inst : Lattice Œ±] [inst_1 : AddGroup Œ±], 0‚Åª = 0",
    "name": "LatticeOrderedGroup.neg_zero",
    "depth": 13},
   {"term":
    "‚àÄ {Œ± : Type u} [inst : Lattice Œ±] [inst_1 : AddGroup Œ±] (a : Œ±), 0 ‚â§ a‚Åª",
    "name": "LatticeOrderedGroup.neg_nonneg",
    "depth": 13},
   {"term":
    "‚àÄ {Œ± : Type u} [inst : Lattice Œ±] [inst_1 : Group Œ±] (a : Œ±), a‚Åª = a‚Åª¬π‚Å∫",
    "name": "LatticeOrderedGroup.neg_eq_pos_inv",
    "depth": 13},
   {"term":
    "‚àÄ {Œ± : Type u} [inst : Lattice Œ±] [inst_1 : Group Œ±] (a : Œ±), a‚Åª¬π ‚â§ a‚Åª",
    "name": "LatticeOrderedGroup.inv_le_neg",
    "depth": 13}],
  "kind": "¬´term_‚Åª¬ª",
  "examples": [],
  "count": 38},
 {"noDocExamples":
  [{"term": "‚àÄ {Œ± : Type uu} (l : List Œ±), l <+~ l",
    "name": "List.Subperm.refl",
    "depth": 5},
   {"term": "‚àÄ {Œ± : Type uu} {l : List Œ±}, [] <+~ l",
    "name": "List.nil_subperm",
    "depth": 5}],
  "kind": "List.¬´term_<+~_¬ª",
  "examples":
  [{"term":
    "‚àÄ {Œ± : Type uu} (a : Œ±) {l‚ÇÅ l‚ÇÇ : List Œ±}, l‚ÇÅ <+~ l‚ÇÇ ‚Üí a :: l‚ÇÅ <+~ a :: l‚ÇÇ",
    "name": "List.subperm.cons",
    "doc": "**Alias** of the reverse direction of `List.subperm_cons`.",
    "depth": 10},
   {"term":
    "‚àÄ {Œ± : Type uu} (a : Œ±) {l‚ÇÅ l‚ÇÇ : List Œ±}, a :: l‚ÇÅ <+~ a :: l‚ÇÇ ‚Üí l‚ÇÅ <+~ l‚ÇÇ",
    "name": "List.subperm.of_cons",
    "doc": "**Alias** of the forward direction of `List.subperm_cons`.",
    "depth": 10},
   {"term":
    "‚àÄ {Œ± : Type uu} [inst : DecidableEq Œ±] {l‚ÇÅ l‚ÇÇ : List Œ±},\n  l‚ÇÅ <+~ l‚ÇÇ ‚Üî ‚àÄ (x : Œ±), x ‚àà l‚ÇÅ ‚Üí List.count x l‚ÇÅ ‚â§ List.count x l‚ÇÇ",
    "name": "List.subperm_ext_iff",
    "doc": "The list version of `Multiset.le_iff_count`. ",
    "depth": 17}],
  "count": 38},
 {"noDocExamples": [],
  "kind": "MeasureTheory.¬´term‚à´_In_,_¬ª",
  "examples":
  [{"term":
    "‚àÄ {s : ‚ÑÇ},\n  0 < s.re ‚Üí HasDerivAt Complex.GammaIntegral (‚à´ (t : ‚Ñù) in Set.Ioi 0, ‚Üët ^ (s - 1) * (‚Üë(Real.log t) * ‚Üë(rexp (-t)))) s",
    "name": "Complex.hasDerivAt_GammaIntegral",
    "doc":
    "The derivative of the `Œì` integral, at any `s ‚àà ‚ÑÇ` with `1 < re s`, is given by the Melllin\ntransform of `log t * exp (-t)`. ",
    "depth": 15},
   {"term":
    "‚àÄ {a b : ‚Ñù} (n : ‚Ñï), ‚à´ (x : ‚Ñù) in Œô a b, |x - a| ^ n = |b - a| ^ (n + 1) / (‚Üën + 1)",
    "name": "integral_pow_abs_sub_uIoc",
    "doc":
    "Integral of `|x - a| ^ n` over `Œô a b`. This integral appears in the proof of the\nPicard-Lindel√∂f/Cauchy-Lipschitz theorem. ",
    "depth": 16},
   {"term":
    "‚àÄ {g g' : ‚Ñù ‚Üí ‚Ñù} {a l : ‚Ñù},\n  (‚àÄ (x : ‚Ñù), x ‚àà Set.Ici a ‚Üí HasDerivAt g (g' x) x) ‚Üí\n    (‚àÄ (x : ‚Ñù), x ‚àà Set.Ioi a ‚Üí 0 ‚â§ g' x) ‚Üí\n      Filter.Tendsto g Filter.atTop (nhds l) ‚Üí ‚à´ (x : ‚Ñù) in Set.Ioi a, g' x = l - g a",
    "name": "MeasureTheory.integral_Ioi_of_hasDerivAt_of_nonneg'",
    "doc":
    "When a function has a limit at infinity `l`, and its derivative is nonnegative, then the\nintegral of the derivative on `(a, +‚àû)` is `l - g a` (and the derivative is integrable, see\n`integrable_on_Ioi_deriv_of_nonneg'`). Version assuming differentiability on `[a, +‚àû)`. ",
    "depth": 18},
   {"term":
    "‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] (t : ‚Ñù) (f : UnitAddCircle ‚Üí E),\n  ‚à´ (a : ‚Ñù) in Set.Ioc t (t + 1), f ‚Üëa = ‚à´ (b : UnitAddCircle), f b",
    "name": "UnitAddCircle.integral_preimage",
    "doc":
    "The integral of an almost-everywhere strongly measurable function over `UnitAddCircle` is\nequal to the integral over an interval (t, t + 1] in `‚Ñù` of its lift to `‚Ñù`. ",
    "depth": 18},
   {"term":
    "‚àÄ {g g' : ‚Ñù ‚Üí ‚Ñù} {a l : ‚Ñù},\n  (‚àÄ (x : ‚Ñù), x ‚àà Set.Ici a ‚Üí HasDerivAt g (g' x) x) ‚Üí\n    (‚àÄ (x : ‚Ñù), x ‚àà Set.Ioi a ‚Üí g' x ‚â§ 0) ‚Üí\n      Filter.Tendsto g Filter.atTop (nhds l) ‚Üí ‚à´ (x : ‚Ñù) in Set.Ioi a, g' x = l - g a",
    "name": "MeasureTheory.integral_Ioi_of_hasDerivAt_of_nonpos'",
    "doc":
    "When a function has a limit at infinity `l`, and its derivative is nonpositive, then the\nintegral of the derivative on `(a, +‚àû)` is `l - g a` (and the derivative is integrable, see\n`integrable_on_Ioi_deriv_of_nonneg'`). Version assuming differentiability on `[a, +‚àû)`. ",
    "depth": 18}],
  "count": 38},
 {"noDocExamples": [],
  "kind": "¬´term_‚âÉ‚Çó‚ÅÖ_,_‚ÅÜ_¬ª",
  "examples":
  [{"term":
    "{R : Type u} ‚Üí\n  {L : Type v} ‚Üí\n    {M : Type w} ‚Üí\n      [inst : CommRing R] ‚Üí\n        [inst_1 : LieRing L] ‚Üí\n          [inst_2 : AddCommGroup M] ‚Üí [inst_3 : Module R M] ‚Üí [inst_4 : LieRingModule L M] ‚Üí M ‚âÉ‚Çó‚ÅÖR,L‚ÅÜ M",
    "name": "LieModuleEquiv.refl",
    "doc": "Lie module equivalences are reflexive. ",
    "depth": 20},
   {"term":
    "{R : Type u} ‚Üí\n  {L : Type v} ‚Üí\n    {M : Type w} ‚Üí\n      {N : Type w‚ÇÅ} ‚Üí\n        [inst : CommRing R] ‚Üí\n          [inst_1 : LieRing L] ‚Üí\n            [inst_2 : AddCommGroup M] ‚Üí\n              [inst_3 : AddCommGroup N] ‚Üí\n                [inst_4 : Module R M] ‚Üí\n                  [inst_5 : Module R N] ‚Üí\n                    [inst_6 : LieRingModule L M] ‚Üí [inst_7 : LieRingModule L N] ‚Üí (M ‚âÉ‚Çó‚ÅÖR,L‚ÅÜ N) ‚Üí N ‚âÉ‚Çó‚ÅÖR,L‚ÅÜ M",
    "name": "LieModuleEquiv.symm",
    "doc": "Lie module equivalences are symmetric. ",
    "depth": 25},
   {"term":
    "{R : Type u} ‚Üí\n  {L : Type v} ‚Üí\n    {M : Type w} ‚Üí\n      {N : Type w‚ÇÅ} ‚Üí\n        [inst : CommRing R] ‚Üí\n          [inst_1 : LieRing L] ‚Üí\n            [inst_2 : AddCommGroup M] ‚Üí\n              [inst_3 : AddCommGroup N] ‚Üí\n                [inst_4 : Module R M] ‚Üí\n                  [inst_5 : Module R N] ‚Üí\n                    [inst_6 : LieRingModule L M] ‚Üí [inst_7 : LieRingModule L N] ‚Üí (M ‚âÉ‚Çó‚ÅÖR,L‚ÅÜ N) ‚Üí M ‚âÉ N",
    "name": "LieModuleEquiv.toEquiv",
    "doc": "View an equivalence of Lie modules as a type level equivalence. ",
    "depth": 25},
   {"term":
    "{R : Type u} ‚Üí\n  {L : Type v} ‚Üí\n    {M : Type w} ‚Üí\n      {N : Type w‚ÇÅ} ‚Üí\n        [inst : CommRing R] ‚Üí\n          [inst_1 : LieRing L] ‚Üí\n            [inst_2 : AddCommGroup M] ‚Üí\n              [inst_3 : AddCommGroup N] ‚Üí\n                [inst_4 : Module R M] ‚Üí\n                  [inst_5 : Module R N] ‚Üí\n                    [inst_6 : LieRingModule L M] ‚Üí [inst_7 : LieRingModule L N] ‚Üí (M ‚âÉ‚Çó‚ÅÖR,L‚ÅÜ N) ‚Üí N ‚Üí M",
    "name": "LieModuleEquiv.invFun",
    "doc": "The inverse function of an equivalence of Lie modules ",
    "depth": 25},
   {"term":
    "{R : Type u} ‚Üí\n  {L : Type v} ‚Üí\n    {M : Type w} ‚Üí\n      {N : Type w‚ÇÅ} ‚Üí\n        [inst : CommRing R] ‚Üí\n          [inst_1 : LieRing L] ‚Üí\n            [inst_2 : AddCommGroup M] ‚Üí\n              [inst_3 : AddCommGroup N] ‚Üí\n                [inst_4 : Module R M] ‚Üí\n                  [inst_5 : Module R N] ‚Üí\n                    [inst_6 : LieRingModule L M] ‚Üí [inst_7 : LieRingModule L N] ‚Üí (M ‚âÉ‚Çó‚ÅÖR,L‚ÅÜ N) ‚Üí M ‚âÉ‚Çó[R] N",
    "name": "LieModuleEquiv.toLinearEquiv",
    "doc": "View an equivalence of Lie modules as a linear equivalence. ",
    "depth": 28}],
  "count": 37},
 {"noDocExamples": [],
  "kind": "¬´MulActionHomLocal‚â∫¬ª",
  "examples":
  [{"term": "(M' : Type u_1) ‚Üí {X : Type u_2} ‚Üí [inst : SMul M' X] ‚Üí X ‚Üí[M'] X",
    "name": "MulActionHom.id",
    "doc": "The identity map as an equivariant map. ",
    "depth": 8},
   {"term":
    "{M' : Type u_1} ‚Üí {X : Type u_2} ‚Üí [inst : SMul M' X] ‚Üí {Y : Type u_3} ‚Üí [inst_1 : SMul M' Y] ‚Üí (X ‚Üí[M'] Y) ‚Üí X ‚Üí Y",
    "name": "MulActionHom.toFun",
    "doc": "The underlying function. ",
    "depth": 11},
   {"term":
    "{M : Type u_18} ‚Üí\n  (N : Type u_16) ‚Üí\n    (Œ± : Type u_17) ‚Üí [inst : SMul M Œ±] ‚Üí [inst_1 : SMul N Œ±] ‚Üí [inst : SMulCommClass M N Œ±] ‚Üí M ‚Üí Œ± ‚Üí[N] Œ±",
    "name": "SMulCommClass.toMulActionHom",
    "doc":
    "If actions of `M` and `N` on `Œ±` commute, then for `c : M`, `(c ‚Ä¢ ¬∑ : Œ± ‚Üí Œ±)` is an `N`-action\nhomomorphism. ",
    "depth": 12},
   {"term": "{Œ± : Type u} ‚Üí [inst : Group Œ±] ‚Üí (H : Subgroup Œ±) ‚Üí Œ± ‚Üí[Œ±] Œ± ‚ß∏ H",
    "name": "MulActionHom.toQuotient",
    "doc": "The canonical map to the left cosets. ",
    "depth": 12},
   {"term":
    "{X : Type u_2} ‚Üí\n  {Y : Type u_3} ‚Üí\n    {M : Type u_5} ‚Üí\n      {F : Type u_16} ‚Üí [inst : SMul M X] ‚Üí [inst_1 : SMul M Y] ‚Üí [inst_2 : SMulHomClass F M X Y] ‚Üí F ‚Üí X ‚Üí[M] Y",
    "name": "SMulHomClass.toMulActionHom",
    "doc":
    "Turn an element of a type `F` satisfying `SMulHomClass F M X Y` into an actual\n`MulActionHom`. This is declared as the default coercion from `F` to `MulActionHom M X Y`. ",
    "depth": 13}],
  "count": 37},
 {"noDocExamples":
  [{"term": "‚àÄ (b : Bool), (b || false) = b",
    "name": "Bool.or_false",
    "depth": 5},
   {"term": "‚àÄ (x : Bool), (x || !x) = true",
    "name": "Bool.or_not_self",
    "depth": 5},
   {"term": "‚àÄ (b : Bool), (b || true) = true",
    "name": "Bool.or_true",
    "depth": 5},
   {"term": "‚àÄ (b : Bool), (false || b) = b",
    "name": "Bool.false_or",
    "depth": 5},
   {"term": "‚àÄ (b : Bool), (true || b) = true",
    "name": "Bool.true_or",
    "depth": 5}],
  "kind": "¬´term_||_¬ª",
  "examples": [],
  "count": 36},
 {"noDocExamples": [],
  "kind": "Submodule.¬´term_‚üÇ_¬ª",
  "examples":
  [{"term":
    "‚àÄ {ùïú : Type u_1} {E : Type u_2} [inst : IsROrC ùïú] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ùïú E]\n  {U V : Submodule ùïú E}, U ‚üÇ V ‚Üí Disjoint U V",
    "name": "Submodule.IsOrtho.disjoint",
    "doc": "Orthogonal submodules are disjoint. ",
    "depth": 25},
   {"term":
    "‚àÄ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ‚Ñù V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] {n : ‚Ñï} (s : Affine.Simplex ‚Ñù P (n + 1)) (i : Fin (n + 2)),\n  vectorSpan ‚Ñù (s.points '' ‚Üë(Finset.erase Finset.univ i)) ‚üÇ AffineSubspace.direction (Affine.Simplex.altitude s i)",
    "name": "Affine.Simplex.vectorSpan_isOrtho_altitude_direction",
    "doc":
    "The vector span of the opposite face lies in the direction\northogonal to an altitude. ",
    "depth": 28},
   {"term":
    "‚àÄ {ùïú : Type u_1} {E : Type u_2} [inst : IsROrC ùïú] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ùïú E]\n  {Œπ : Type u_4} {V : Œπ ‚Üí Submodule ùïú E},\n  (OrthogonalFamily ùïú (fun i => { x // x ‚àà V i }) fun i => Submodule.subtype‚Çó·µ¢ (V i)) ‚Üí\n    Pairwise ((fun x x_1 => x ‚üÇ x_1) on V)",
    "name": "OrthogonalFamily.pairwise",
    "doc":
    "**Alias** of the forward direction of `orthogonalFamily_iff_pairwise`.",
    "depth": 31},
   {"term":
    "‚àÄ {ùïú : Type u_1} {E : Type u_2} [inst : IsROrC ùïú] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ùïú E]\n  {Œπ : Type u_4} {V : Œπ ‚Üí Submodule ùïú E},\n  (OrthogonalFamily ùïú (fun i => { x // x ‚àà V i }) fun i => Submodule.subtype‚Çó·µ¢ (V i)) ‚Üí ‚àÄ {i j : Œπ}, i ‚â† j ‚Üí V i ‚üÇ V j",
    "name": "OrthogonalFamily.isOrtho",
    "doc":
    "Two submodules in an orthogonal family with different indices are orthogonal. ",
    "depth": 31},
   {"term":
    "‚àÄ {ùïú : Type u_1} {E : Type u_2} [inst : IsROrC ùïú] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ùïú E]\n  {Œπ : Type u_4} {V : Œπ ‚Üí Submodule ùïú E},\n  Pairwise ((fun x x_1 => x ‚üÇ x_1) on V) ‚Üí\n    OrthogonalFamily ùïú (fun i => { x // x ‚àà V i }) fun i => Submodule.subtype‚Çó·µ¢ (V i)",
    "name": "OrthogonalFamily.of_pairwise",
    "doc":
    "**Alias** of the reverse direction of `orthogonalFamily_iff_pairwise`.",
    "depth": 31}],
  "count": 36},
 {"noDocExamples":
  [{"term": "‚àÄ {Œ± : Type u} (l : List Œ±), l ~r l",
    "name": "List.IsRotated.refl",
    "depth": 5},
   {"term": "‚àÄ {Œ± : Type u} {l : List Œ±}, [] ~r l ‚Üî [] = l",
    "name": "List.isRotated_nil_iff'",
    "depth": 7},
   {"term": "‚àÄ {Œ± : Type u} {l l' : List Œ±}, l ~r l' ‚Üí l ~ l'",
    "name": "List.IsRotated.perm",
    "depth": 7},
   {"term": "‚àÄ {Œ± : Type u} {l : List Œ±}, l ~r [] ‚Üî l = []",
    "name": "List.isRotated_nil_iff",
    "depth": 7},
   {"term": "‚àÄ {Œ± : Type u} {l l' : List Œ±}, l ~r l' ‚Üí l' ~r l",
    "name": "List.IsRotated.symm",
    "depth": 7}],
  "kind": "List.¬´term_~r_¬ª",
  "examples": [],
  "count": 36},
 {"noDocExamples": [],
  "kind": "MeasureTheory.¬´term‚®ç_,_‚àÇ_¬ª",
  "examples":
  [{"term":
    "‚àÄ {Œ± : Type u_1} {m0 : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {f : Œ± ‚Üí ‚Ñù}\n  [inst : MeasureTheory.IsFiniteMeasure Œº], Œº ‚â† 0 ‚Üí MeasureTheory.Integrable f ‚Üí ‚àÉ x, f x ‚â§ ‚®ç (a : Œ±), f a ‚àÇŒº",
    "name": "MeasureTheory.exists_le_average",
    "doc":
    "**First moment method**. The minimum of an integrable function is smaller than its mean. ",
    "depth": 17},
   {"term":
    "‚àÄ {Œ± : Type u_1} {m0 : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {f : Œ± ‚Üí ‚Ñù}\n  [inst : MeasureTheory.IsFiniteMeasure Œº], Œº ‚â† 0 ‚Üí MeasureTheory.Integrable f ‚Üí ‚àÉ x, ‚®ç (a : Œ±), f a ‚àÇŒº ‚â§ f x",
    "name": "MeasureTheory.exists_average_le",
    "doc":
    "**First moment method**. The maximum of an integrable function is greater than its mean. ",
    "depth": 18},
   {"term":
    "‚àÄ {Œ± : Type u_1} {m0 : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {f : Œ± ‚Üí ‚Ñù}\n  [inst : MeasureTheory.IsFiniteMeasure Œº], Œº ‚â† 0 ‚Üí MeasureTheory.Integrable f ‚Üí 0 < ‚Üë‚ÜëŒº {x | f x ‚â§ ‚®ç (a : Œ±), f a ‚àÇŒº}",
    "name": "MeasureTheory.measure_le_average_pos",
    "doc":
    "**First moment method**. An integrable function is smaller than its mean on a set of positive\nmeasure. ",
    "depth": 19},
   {"term":
    "‚àÄ {Œ± : Type u_1} {m0 : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {N : Set Œ±} {f : Œ± ‚Üí ‚Ñù}\n  [inst : MeasureTheory.IsFiniteMeasure Œº],\n  Œº ‚â† 0 ‚Üí MeasureTheory.Integrable f ‚Üí ‚Üë‚ÜëŒº N = 0 ‚Üí ‚àÉ x, ¬¨x ‚àà N ‚àß f x ‚â§ ‚®ç (a : Œ±), f a ‚àÇŒº",
    "name": "MeasureTheory.exists_not_mem_null_le_average",
    "doc":
    "**First moment method**. The minimum of an integrable function is smaller than its mean, while\navoiding a null set. ",
    "depth": 20},
   {"term":
    "‚àÄ {Œ± : Type u_1} {m0 : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {f : Œ± ‚Üí ‚Ñù}\n  [inst : MeasureTheory.IsFiniteMeasure Œº], Œº ‚â† 0 ‚Üí MeasureTheory.Integrable f ‚Üí 0 < ‚Üë‚ÜëŒº {x | ‚®ç (a : Œ±), f a ‚àÇŒº ‚â§ f x}",
    "name": "MeasureTheory.measure_average_le_pos",
    "doc":
    "**First moment method**. An integrable function is greater than its mean on a set of positive\nmeasure. ",
    "depth": 20}],
  "count": 35},
 {"noDocExamples": [],
  "kind": "¬´term_‚ÜíCo_¬ª",
  "examples":
  [{"term":
    "(Œ± : Type u_2) ‚Üí [inst : TopologicalSpace Œ±] ‚Üí [inst_1 : Preorder Œ±] ‚Üí Œ± ‚ÜíCo Œ±",
    "name": "ContinuousOrderHom.id",
    "doc": "`id` as a `ContinuousOrderHom`. ",
    "depth": 9},
   {"term":
    "{Œ± : Type u_2} ‚Üí\n  {Œ≤ : Type u_3} ‚Üí\n    [inst : TopologicalSpace Œ±] ‚Üí\n      [inst_1 : Preorder Œ±] ‚Üí [inst_2 : TopologicalSpace Œ≤] ‚Üí [inst_3 : Preorder Œ≤] ‚Üí (Œ± ‚ÜíCo Œ≤) ‚Üí C(Œ±, Œ≤)",
    "name": "ContinuousOrderHom.toContinuousMap",
    "doc": "Reinterpret a `ContinuousOrderHom` as a `ContinuousMap`. ",
    "depth": 13},
   {"term":
    "{F : Type u_1} ‚Üí\n  {Œ± : Type u_2} ‚Üí\n    {Œ≤ : Type u_3} ‚Üí\n      [inst : Preorder Œ±] ‚Üí\n        [inst_1 : Preorder Œ≤] ‚Üí\n          [inst_2 : TopologicalSpace Œ±] ‚Üí\n            [inst_3 : TopologicalSpace Œ≤] ‚Üí [inst_4 : ContinuousOrderHomClass F Œ± Œ≤] ‚Üí F ‚Üí Œ± ‚ÜíCo Œ≤",
    "name": "ContinuousOrderHomClass.toContinuousOrderHom",
    "doc":
    "Turn an element of a type `F` satisfying `ContinuousOrderHomClass F Œ± Œ≤` into an actual\n`ContinuousOrderHom`. This is declared as the default coercion from `F` to `Œ± ‚ÜíCo Œ≤`. ",
    "depth": 15},
   {"term":
    "{Œ± : Type u_2} ‚Üí\n  {Œ≤ : Type u_3} ‚Üí\n    {Œ≥ : Type u_4} ‚Üí\n      [inst : TopologicalSpace Œ±] ‚Üí\n        [inst_1 : Preorder Œ±] ‚Üí\n          [inst_2 : TopologicalSpace Œ≤] ‚Üí\n            [inst_3 : Preorder Œ≤] ‚Üí\n              [inst_4 : TopologicalSpace Œ≥] ‚Üí [inst_5 : Preorder Œ≥] ‚Üí (Œ≤ ‚ÜíCo Œ≥) ‚Üí (Œ± ‚ÜíCo Œ≤) ‚Üí Œ± ‚ÜíCo Œ≥",
    "name": "ContinuousOrderHom.comp",
    "doc": "Composition of `ContinuousOrderHom`s as a `ContinuousOrderHom`. ",
    "depth": 17},
   {"term":
    "{Œ± : Type u_2} ‚Üí\n  {Œ≤ : Type u_3} ‚Üí\n    [inst : TopologicalSpace Œ±] ‚Üí\n      [inst_1 : Preorder Œ±] ‚Üí\n        [inst_2 : TopologicalSpace Œ≤] ‚Üí [inst_3 : Preorder Œ≤] ‚Üí (f : Œ± ‚ÜíCo Œ≤) ‚Üí (f' : Œ± ‚Üí Œ≤) ‚Üí f' = ‚Üëf ‚Üí Œ± ‚ÜíCo Œ≤",
    "name": "ContinuousOrderHom.copy",
    "doc":
    "Copy of a `ContinuousOrderHom` with a new `ContinuousMap` equal to the old one. Useful to fix\ndefinitional equalities. ",
    "depth": 27}],
  "count": 35},
 {"noDocExamples": [],
  "kind": "¬´term_‚äï'_¬ª",
  "examples":
  [{"term": "(Œ± : Type u_4) ‚Üí Fintype Œ± ‚äï' Infinite Œ±",
    "name": "fintypeOrInfinite",
    "doc":
    "Any type is (classically) either a `Fintype`, or `Infinite`.\n\nOne can obtain the relevant typeclasses via `cases fintypeOrInfinite Œ±`.\n",
    "depth": 4},
   {"term": "{Œ± : Sort u} ‚Üí {Œ≤ : Sort v} ‚Üí Œ± ‚Üí Œ± ‚äï' Œ≤",
    "name": "PSum.inl",
    "doc":
    "Left injection into the sum type `Œ± ‚äï' Œ≤`. If `a : Œ±` then `.inl a : Œ± ‚äï' Œ≤`. ",
    "depth": 5},
   {"term": "(Œ± : Type u_3) ‚Üí [inst : Inhabited Œ±] ‚Üí Nontrivial Œ± ‚äï' Unique Œ±",
    "name": "nontrivialPSumUnique",
    "doc": "An inhabited type is either nontrivial, or has a unique element. ",
    "depth": 5},
   {"term": "{Œ± : Sort u} ‚Üí {Œ≤ : Sort v} ‚Üí Œ≤ ‚Üí Œ± ‚äï' Œ≤",
    "name": "PSum.inr",
    "doc":
    "Right injection into the sum type `Œ± ‚äï' Œ≤`. If `b : Œ≤` then `.inr b : Œ± ‚äï' Œ≤`. ",
    "depth": 5},
   {"term": "{p q : Prop} ‚Üí Unit ‚äï' (p ‚Üí q) ‚Üí Unit ‚äï' p ‚Üí Unit ‚äï' q",
    "name": "SlimCheck.TestResult.combine",
    "doc": "Applicative combinator proof carrying test results. ",
    "depth": 6}],
  "count": 35},
 {"noDocExamples":
  [{"term":
    "‚àÄ {n : ‚Ñï} {Œ± : TypeVec n} {Œ≤ : Type u_1}, (TypeVec.id ::: id) = TypeVec.id",
    "name": "TypeVec.appendFun_id_id",
    "depth": 15}],
  "kind": "TypeVec.¬´term_:::__1¬ª",
  "examples":
  [{"term":
    "(n : ‚Ñï) ‚Üí\n  {Œ≤ : (v : TypeVec (n + 1)) ‚Üí (v' : TypeVec (n + 1)) ‚Üí TypeVec.Arrow v v' ‚Üí Sort u_1} ‚Üí\n    ((t : Type u_2) ‚Üí\n        (t' : Type u_3) ‚Üí\n          (f : t ‚Üí t') ‚Üí\n            (v : TypeVec n) ‚Üí (v' : TypeVec n) ‚Üí (fs : TypeVec.Arrow v v') ‚Üí Œ≤ (v ::: t) (v' ::: t') (fs ::: f)) ‚Üí\n      (v : TypeVec (n + 1)) ‚Üí (v' : TypeVec (n + 1)) ‚Üí (fs : TypeVec.Arrow v v') ‚Üí Œ≤ v v' fs",
    "name": "TypeVec.typevecCasesCons‚ÇÉ",
    "doc":
    "cases distinction for an arrow in the category of (n+1)-length type vectors ",
    "depth": 17},
   {"term":
    "(n : ‚Ñï) ‚Üí\n  (t : Type u_1) ‚Üí\n    (t' : Type u_2) ‚Üí\n      (v : TypeVec n) ‚Üí\n        (v' : TypeVec n) ‚Üí\n          {Œ≤ : TypeVec.Arrow (v ::: t) (v' ::: t') ‚Üí Sort u_3} ‚Üí\n            ((f : t ‚Üí t') ‚Üí (fs : TypeVec.Arrow v v') ‚Üí Œ≤ (fs ::: f)) ‚Üí\n              (fs : TypeVec.Arrow (v ::: t) (v' ::: t')) ‚Üí Œ≤ fs",
    "name": "TypeVec.typevecCasesCons‚ÇÇ",
    "doc":
    "specialized cases distinction for an arrow in the category of (n+1)-length type vectors ",
    "depth": 17},
   {"term":
    "{n : ‚Ñï} ‚Üí\n  {F : TypeVec (n + 1) ‚Üí Type u} ‚Üí\n    [inst : MvFunctor F] ‚Üí\n      [q : MvQPF F] ‚Üí\n        {Œ± : TypeVec n} ‚Üí\n          {Œ≤ : MvQPF.Fix F Œ± ‚Üí Type u} ‚Üí\n            ((x : F (Œ± ::: Sigma Œ≤)) ‚Üí Œ≤ (MvQPF.Fix.mk (MvFunctor.map (TypeVec.id ::: Sigma.fst) x))) ‚Üí\n              (x : MvQPF.Fix F Œ±) ‚Üí Œ≤ x",
    "name": "MvQPF.Fix.drec",
    "doc": "Dependent recursor for `fix F` ",
    "depth": 23},
   {"term":
    "‚àÄ {n : ‚Ñï} {F : TypeVec (n + 1) ‚Üí Type u} [mvf : MvFunctor F] [q : MvQPF F] {Œ± : TypeVec n}\n  (r : MvQPF.Cofix F Œ± ‚Üí MvQPF.Cofix F Œ± ‚Üí Prop),\n  (‚àÄ (x y : MvQPF.Cofix F Œ±),\n      r x y ‚Üí\n        MvFunctor.map (TypeVec.id ::: Quot.mk r) (MvQPF.Cofix.dest x) =\n          MvFunctor.map (TypeVec.id ::: Quot.mk r) (MvQPF.Cofix.dest y)) ‚Üí\n    ‚àÄ (x y : MvQPF.Cofix F Œ±), r x y ‚Üí x = y",
    "name": "MvQPF.Cofix.bisim_rel",
    "doc":
    "Bisimulation principle using `map` and `Quot.mk` to match and relate children of two trees. ",
    "depth": 25}],
  "count": 35},
 {"noDocExamples": [],
  "kind": "SimpleGraph.¬´term_‚Ü™g_¬ª",
  "examples":
  [{"term": "{V : Type u} ‚Üí {G : SimpleGraph V} ‚Üí G ‚Ü™g G",
    "name": "SimpleGraph.Embedding.refl",
    "doc": "The identity embedding from a graph to itself. ",
    "depth": 6},
   {"term":
    "{V : Type u} ‚Üí {s : Set V} ‚Üí (G : SimpleGraph ‚Üës) ‚Üí G ‚Ü™g SimpleGraph.spanningCoe G",
    "name": "SimpleGraph.Embedding.spanningCoe",
    "doc": "Graphs on a set of vertices embed in their `spanningCoe`. ",
    "depth": 9},
   {"term":
    "{V : Type u} ‚Üí {W : Type v} ‚Üí (f : V ‚Ü™ W) ‚Üí (G : SimpleGraph V) ‚Üí G ‚Ü™g SimpleGraph.map f G",
    "name": "SimpleGraph.Embedding.map",
    "doc":
    "Given an injective function, there is an embedding from a graph into the mapped graph. ",
    "depth": 9},
   {"term":
    "{V : Type u} ‚Üí {W : Type v} ‚Üí {G : SimpleGraph V} ‚Üí {G' : SimpleGraph W} ‚Üí G ‚âÉg G' ‚Üí G ‚Ü™g G'",
    "name": "SimpleGraph.Iso.toEmbedding",
    "doc": "An isomorphism of graphs gives rise to an embedding of graphs. ",
    "depth": 9},
   {"term":
    "{V : Type u} ‚Üí {G : SimpleGraph V} ‚Üí (s : Set V) ‚Üí SimpleGraph.induce s G ‚Ü™g G",
    "name": "SimpleGraph.Embedding.induce",
    "doc":
    "Induced graphs embed in the original graph.\n\nNote that if `G.induce s = ‚ä§` (i.e., if `s` is a clique) then this gives the embedding of a\ncomplete graph. ",
    "depth": 9}],
  "count": 34},
 {"noDocExamples":
  [{"term":
    "‚àÄ {R : Type u} [inst : Ring R] {q : Polynomial R} (p : Polynomial R), ¬¨Polynomial.Monic q ‚Üí p %‚Çò q = p",
    "name": "Polynomial.modByMonic_eq_of_not_monic",
    "depth": 11}],
  "kind": "Polynomial.¬´term_%‚Çò_¬ª",
  "examples":
  [{"term":
    "‚àÄ {R : Type u} [inst : CommRing R] {n : Type v} [inst_1 : DecidableEq n] [inst_2 : Fintype n] (M : Matrix n n R)\n  (k : ‚Ñï), M ^ k = ‚Üë(Polynomial.aeval M) (Polynomial.X ^ k %‚Çò Matrix.charpoly M)",
    "name": "Matrix.pow_eq_aeval_mod_charpoly",
    "doc":
    "Any matrix power can be computed as the sum of matrix powers less than `Fintype.card n`.\n\nTODO: add the statement for negative powers phrased with `zpow`. ",
    "depth": 34},
   {"term":
    "‚àÄ {R : Type u} [inst : CommRing R] {n : Type v} [inst_1 : DecidableEq n] [inst_2 : Fintype n] (M : Matrix n n R)\n  (p : Polynomial R), ‚Üë(Polynomial.aeval M) p = ‚Üë(Polynomial.aeval M) (p %‚Çò Matrix.charpoly M)",
    "name": "Matrix.aeval_eq_aeval_mod_charpoly",
    "doc":
    "Any matrix polynomial `p` is equivalent under evaluation to `p %‚Çò M.charpoly`; that is, `p`\nis equivalent to a polynomial with degree less than the dimension of the matrix. ",
    "depth": 35},
   {"term":
    "‚àÄ {R : Type u} {M : Type v} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : Module.Free R M] [inst_4 : Module.Finite R M] (f : M ‚Üí‚Çó[R] M) (k : ‚Ñï),\n  f ^ k = ‚Üë(Polynomial.aeval f) (Polynomial.X ^ k %‚Çò LinearMap.charpoly f)",
    "name": "LinearMap.pow_eq_aeval_mod_charpoly",
    "doc":
    "Any endomorphism power can be computed as the sum of endomorphism powers less than the\ndimension of the module. ",
    "depth": 43},
   {"term":
    "‚àÄ {R : Type u} {M : Type v} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : Module.Free R M] [inst_4 : Module.Finite R M] (f : M ‚Üí‚Çó[R] M) (p : Polynomial R),\n  ‚Üë(Polynomial.aeval f) p = ‚Üë(Polynomial.aeval f) (p %‚Çò LinearMap.charpoly f)",
    "name": "LinearMap.aeval_eq_aeval_mod_charpoly",
    "doc":
    "Any endomorphism polynomial `p` is equivalent under evaluation to `p %‚Çò f.charpoly`; that is,\n`p` is equivalent to a polynomial with degree less than the dimension of the module. ",
    "depth": 44}],
  "count": 34},
 {"noDocExamples":
  [{"term":
    "‚àÄ {M : Type w'} [inst : LE M] [h : NoTopOrder M], M ‚ä® FirstOrder.Language.noTopOrderSentence FirstOrder.Language.order",
    "name": "FirstOrder.Language.realize_noTopOrder",
    "depth": 7},
   {"term":
    "‚àÄ {M : Type w'} [inst : LE M] [h : NoBotOrder M], M ‚ä® FirstOrder.Language.noBotOrderSentence FirstOrder.Language.order",
    "name": "FirstOrder.Language.realize_noBotOrder",
    "depth": 7},
   {"term":
    "‚àÄ {M : Type w'} [inst : Preorder M] [h : DenselyOrdered M],\n  M ‚ä® FirstOrder.Language.denselyOrderedSentence FirstOrder.Language.order",
    "name": "FirstOrder.Language.realize_denselyOrdered",
    "depth": 8},
   {"term":
    "‚àÄ {M : Type w'} [inst : LE M], M ‚ä® FirstOrder.Language.noTopOrderSentence FirstOrder.Language.order ‚Üî NoTopOrder M",
    "name": "FirstOrder.Language.realize_noTopOrder_iff",
    "depth": 8}],
  "kind": "FirstOrder.Language.¬´term_‚ä®_¬ª",
  "examples":
  [{"term":
    "‚àÄ {Œ± : Type u_1} {M : Œ± ‚Üí Type u_2} {u : Ultrafilter Œ±} {L : FirstOrder.Language}\n  [inst : (a : Œ±) ‚Üí FirstOrder.Language.Structure L (M a)] [inst_1 : ‚àÄ (a : Œ±), Nonempty (M a)]\n  (œÜ : FirstOrder.Language.Sentence L), Filter.Product (‚Üëu) M ‚ä® œÜ ‚Üî ‚àÄ·∂† (a : Œ±) in ‚Üëu, M a ‚ä® œÜ",
    "name": "FirstOrder.Language.Ultraproduct.sentence_realize",
    "doc":
    "≈Åo≈õ's Theorem : A sentence is true in an ultraproduct if and only if the set of structures it is\ntrue in is in the ultrafilter. ",
    "depth": 16}],
  "count": 34},
 {"noDocExamples": [],
  "kind": "FirstOrder.Language.¬´term_‚âÉ·¥∏_¬ª",
  "examples":
  [{"term": "(L : FirstOrder.Language) ‚Üí L ‚âÉ·¥∏ L",
    "name": "FirstOrder.Language.LEquiv.refl",
    "doc": "The identity equivalence from a first-order language to itself. ",
    "depth": 3},
   {"term":
    "{L : FirstOrder.Language} ‚Üí {L' : FirstOrder.Language} ‚Üí (L ‚âÉ·¥∏ L') ‚Üí (L' ‚âÉ·¥∏ L)",
    "name": "FirstOrder.Language.LEquiv.symm",
    "doc": "The inverse of an equivalence of first-order languages. ",
    "depth": 5},
   {"term":
    "{L : FirstOrder.Language} ‚Üí\n  {L' : FirstOrder.Language} ‚Üí (L ‚âÉ·¥∏ L') ‚Üí FirstOrder.Language.Sentence L ‚âÉ FirstOrder.Language.Sentence L'",
    "name": "FirstOrder.Language.LEquiv.onSentence",
    "doc": "Maps a sentence's symbols along a language equivalence. ",
    "depth": 6},
   {"term":
    "(L : FirstOrder.Language) ‚Üí (Œ± : Type w') ‚Üí [ie : IsEmpty Œ±] ‚Üí L ‚âÉ·¥∏ FirstOrder.Language.withConstants L Œ±",
    "name": "FirstOrder.Language.LEquiv.addEmptyConstants",
    "doc": "The language map removing an empty constant set.  ",
    "depth": 6},
   {"term":
    "{L : FirstOrder.Language} ‚Üí\n  {L' : FirstOrder.Language} ‚Üí {L'' : FirstOrder.Language} ‚Üí (L ‚âÉ·¥∏ L') ‚Üí (L' ‚âÉ·¥∏ L'') ‚Üí (L ‚âÉ·¥∏ L'')",
    "name": "FirstOrder.Language.LEquiv.trans",
    "doc": "The composition of equivalences of first-order languages. ",
    "depth": 7}],
  "count": 34},
 {"noDocExamples":
  [{"term": "‚àÄ {Œ± : Type u} [inst : Monoid Œ±] (u : Œ±À£), ‚Üëu /‚Çö u = 1",
    "name": "divp_self",
    "depth": 10}],
  "kind": "¬´term_/‚Çö_¬ª",
  "examples":
  [{"term": "‚àÄ {Œ± : Type u} [inst : Monoid Œ±] (u : Œ±À£), ‚Üëu‚Åª¬π = 1 /‚Çö u",
    "name": "inv_eq_one_divp",
    "doc": "Used for `field_simp` to deal with inverses of units. ",
    "depth": 11},
   {"term":
    "‚àÄ {Œ± : Type u} [inst : Monoid Œ±] (x y : Œ±) (u : Œ±À£), x * (y /‚Çö u) = x * y /‚Çö u",
    "name": "divp_assoc'",
    "doc":
    "`field_simp` needs the reverse direction of `divp_assoc` to move all `/‚Çö` to the right. ",
    "depth": 15},
   {"term":
    "‚àÄ {Œ± : Type u} [inst : Monoid Œ±] (u‚ÇÅ u‚ÇÇ : Œ±À£), ‚Üë(u‚ÇÅ / u‚ÇÇ) = ‚Üëu‚ÇÅ /‚Çö u‚ÇÇ",
    "name": "val_div_eq_divp",
    "doc":
    "`field_simp` moves division inside `Œ±À£` to the right, and this lemma\nlifts the calculation to `Œ±`.\n",
    "depth": 16},
   {"term": "‚àÄ {Œ± : Type u} [inst : Monoid Œ±] (u : Œ±À£), ‚Üë(1 / u) = 1 /‚Çö u",
    "name": "inv_eq_one_divp'",
    "doc":
    "Used for `field_simp` to deal with inverses of units. This form of the lemma\nis essential since `field_simp` likes to use `inv_eq_one_div` to rewrite\n`‚Üëu‚Åª¬π = ‚Üë(1 / u)`.\n",
    "depth": 17}],
  "count": 34},
 {"noDocExamples": [],
  "kind": "MeasureTheory.¬´term‚®ç_In_,_‚àÇ_¬ª",
  "examples":
  [{"term":
    "‚àÄ {Œ± : Type u_1} {m0 : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {s : Set Œ±} {f : Œ± ‚Üí ‚Ñù},\n  ‚Üë‚ÜëŒº s ‚â† 0 ‚Üí ‚Üë‚ÜëŒº s ‚â† ‚ä§ ‚Üí MeasureTheory.IntegrableOn f s ‚Üí ‚àÉ x, x ‚àà s ‚àß f x ‚â§ ‚®ç (a : Œ±) in s, f a ‚àÇŒº",
    "name": "MeasureTheory.exists_le_setAverage",
    "doc":
    "**First moment method**. The minimum of an integrable function is smaller than its mean. ",
    "depth": 19},
   {"term":
    "‚àÄ {Œ± : Type u_1} {m0 : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {s : Set Œ±} {f : Œ± ‚Üí ‚Ñù},\n  ‚Üë‚ÜëŒº s ‚â† 0 ‚Üí ‚Üë‚ÜëŒº s ‚â† ‚ä§ ‚Üí MeasureTheory.IntegrableOn f s ‚Üí ‚àÉ x, x ‚àà s ‚àß ‚®ç (a : Œ±) in s, f a ‚àÇŒº ‚â§ f x",
    "name": "MeasureTheory.exists_setAverage_le",
    "doc":
    "**First moment method**. The maximum of an integrable function is greater than its mean. ",
    "depth": 20},
   {"term":
    "‚àÄ {Œ± : Type u_1} {m0 : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {s : Set Œ±} {f : Œ± ‚Üí ‚Ñù},\n  ‚Üë‚ÜëŒº s ‚â† 0 ‚Üí ‚Üë‚ÜëŒº s ‚â† ‚ä§ ‚Üí MeasureTheory.IntegrableOn f s ‚Üí 0 < ‚Üë‚ÜëŒº {x | x ‚àà s ‚àß f x ‚â§ ‚®ç (a : Œ±) in s, f a ‚àÇŒº}",
    "name": "MeasureTheory.measure_le_setAverage_pos",
    "doc":
    "**First moment method**. An integrable function is smaller than its mean on a set of positive\nmeasure. ",
    "depth": 21},
   {"term":
    "‚àÄ {Œ± : Type u_1} {m0 : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {s : Set Œ±} {f : Œ± ‚Üí ‚Ñù},\n  ‚Üë‚ÜëŒº s ‚â† 0 ‚Üí ‚Üë‚ÜëŒº s ‚â† ‚ä§ ‚Üí MeasureTheory.IntegrableOn f s ‚Üí 0 < ‚Üë‚ÜëŒº {x | x ‚àà s ‚àß ‚®ç (a : Œ±) in s, f a ‚àÇŒº ‚â§ f x}",
    "name": "MeasureTheory.measure_setAverage_le_pos",
    "doc":
    "**First moment method**. An integrable function is greater than its mean on a set of positive\nmeasure. ",
    "depth": 22},
   {"term":
    "‚àÄ {Œ± : Type u_1} {E : Type u_2} {m0 : MeasurableSpace Œ±} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E]\n  [inst_2 : CompleteSpace E] {Œº : MeasureTheory.Measure Œ±} {s : Set E} {t : Set Œ±} {f : Œ± ‚Üí E},\n  Convex ‚Ñù s ‚Üí\n    ‚Üë‚ÜëŒº t ‚â† 0 ‚Üí\n      ‚Üë‚ÜëŒº t ‚â† ‚ä§ ‚Üí\n        (‚àÄ·µê (x : Œ±) ‚àÇMeasureTheory.Measure.restrict Œº t, f x ‚àà s) ‚Üí\n          MeasureTheory.IntegrableOn f t ‚Üí ‚®ç (x : Œ±) in t, f x ‚àÇŒº ‚àà closure s",
    "name": "Convex.set_average_mem_closure",
    "doc":
    "If `Œº` is a non-zero finite measure on `Œ±`, `s` is a convex set in `E`, and `f` is an integrable\nfunction sending `Œº`-a.e. points to `s`, then the average value of `f` belongs to `closure s`:\n`‚®ç x, f x ‚àÇŒº ‚àà s`. See also `Convex.centerMass_mem` for a finite sum version of this lemma. ",
    "depth": 24}],
  "count": 33},
 {"noDocExamples": [],
  "kind": "CategoryTheory.exp.¬´term_‚üπ_¬ª",
  "examples":
  [{"term":
    "{C : Type u} ‚Üí\n  [inst : CategoryTheory.Category.{v, u} C] ‚Üí\n    {A Y : C} ‚Üí\n      [inst_1 : CategoryTheory.Limits.HasFiniteProducts C] ‚Üí\n        [inst_2 : CategoryTheory.Exponentiable A] ‚Üí (A ‚ü∂ Y) ‚Üí (‚ä§_ C ‚ü∂ A ‚üπ Y)",
    "name": "CategoryTheory.internalizeHom",
    "doc": "The internal element which points at the given morphism. ",
    "depth": 16},
   {"term":
    "{C : Type u} ‚Üí\n  [inst : CategoryTheory.Category.{v, u} C] ‚Üí\n    {A X Y : C} ‚Üí\n      [inst_1 : CategoryTheory.Limits.HasFiniteProducts C] ‚Üí\n        [inst_2 : CategoryTheory.Exponentiable A] ‚Üí (A ‚®Ø Y ‚ü∂ X) ‚Üí (Y ‚ü∂ A ‚üπ X)",
    "name": "CategoryTheory.CartesianClosed.curry",
    "doc": "Currying in a cartesian closed category. ",
    "depth": 18},
   {"term":
    "{C : Type u} ‚Üí\n  [inst : CategoryTheory.Category.{v, u} C] ‚Üí\n    {A X Y : C} ‚Üí\n      [inst_1 : CategoryTheory.Limits.HasFiniteProducts C] ‚Üí\n        [inst_2 : CategoryTheory.Exponentiable A] ‚Üí (Y ‚ü∂ A ‚üπ X) ‚Üí (A ‚®Ø Y ‚ü∂ X)",
    "name": "CategoryTheory.CartesianClosed.uncurry",
    "doc": "Uncurrying in a cartesian closed category. ",
    "depth": 18},
   {"term":
    "{C : Type u} ‚Üí\n  [inst : CategoryTheory.Category.{v, u} C] ‚Üí\n    {X : C} ‚Üí\n      [inst_1 : CategoryTheory.Limits.HasFiniteProducts C] ‚Üí\n        [inst_2 : CategoryTheory.Exponentiable (‚ä§_ C)] ‚Üí (‚ä§_ C) ‚üπ X ‚âÖ X",
    "name": "CategoryTheory.expTerminalIsoSelf",
    "doc":
    "Show that the exponential of the terminal object is isomorphic to itself, i.e. `X^1 ‚âÖ X`.\n\nThe typeclass argument is explicit: any instance can be used.\n",
    "depth": 19},
   {"term":
    "{C : Type u} ‚Üí\n  [inst : CategoryTheory.Category.{v, u} C] ‚Üí\n    (B : C) ‚Üí\n      [inst_1 : CategoryTheory.Limits.HasFiniteProducts C] ‚Üí\n        {I : C} ‚Üí CategoryTheory.Limits.IsInitial I ‚Üí [inst_2 : CategoryTheory.CartesianClosed C] ‚Üí I ‚üπ B ‚âÖ ‚ä§_ C",
    "name": "CategoryTheory.powZero",
    "doc":
    "If an initial object `0` exists in a CCC then `0^B ‚âÖ 1` for any `B`. ",
    "depth": 21}],
  "count": 33},
 {"noDocExamples": [],
  "kind": "¬´term_‚âÉSL[_]_¬ª",
  "examples":
  [{"term":
    "{R : Type u_1} ‚Üí\n  {R‚ÇÇ : Type u_2} ‚Üí\n    {E : Type u_5} ‚Üí\n      {E‚ÇÇ : Type u_6} ‚Üí\n        [inst : Semiring R] ‚Üí\n          [inst_1 : Semiring R‚ÇÇ] ‚Üí\n            {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} ‚Üí\n              {œÉ‚ÇÇ‚ÇÅ : R‚ÇÇ ‚Üí+* R} ‚Üí\n                [inst_2 : RingHomInvPair œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÅ] ‚Üí\n                  [inst_3 : RingHomInvPair œÉ‚ÇÇ‚ÇÅ œÉ‚ÇÅ‚ÇÇ] ‚Üí\n                    [inst_4 : SeminormedAddCommGroup E] ‚Üí\n                      [inst_5 : SeminormedAddCommGroup E‚ÇÇ] ‚Üí\n                        [inst_6 : Module R E] ‚Üí [inst_7 : Module R‚ÇÇ E‚ÇÇ] ‚Üí CoeTC (E ‚âÉ‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ) (E ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ)",
    "name":
    "LinearIsometryEquiv.instCoeTCLinearIsometryEquivContinuousLinearEquivToTopologicalSpaceToUniformSpaceToPseudoMetricSpaceToAddCommMonoidToAddCommGroupToTopologicalSpaceToUniformSpaceToPseudoMetricSpaceToAddCommMonoidToAddCommGroup",
    "doc": "Reinterpret a `LinearIsometryEquiv` as a `ContinuousLinearEquiv`. ",
    "depth": 31},
   {"term":
    "{R : Type u_1} ‚Üí\n  {R‚ÇÇ : Type u_2} ‚Üí\n    {E : Type u_5} ‚Üí\n      {E‚ÇÇ : Type u_6} ‚Üí\n        [inst : Semiring R] ‚Üí\n          [inst_1 : Semiring R‚ÇÇ] ‚Üí\n            {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} ‚Üí\n              {œÉ‚ÇÇ‚ÇÅ : R‚ÇÇ ‚Üí+* R} ‚Üí\n                [inst_2 : RingHomInvPair œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÅ] ‚Üí\n                  [inst_3 : RingHomInvPair œÉ‚ÇÇ‚ÇÅ œÉ‚ÇÅ‚ÇÇ] ‚Üí\n                    [inst_4 : SeminormedAddCommGroup E] ‚Üí\n                      [inst_5 : SeminormedAddCommGroup E‚ÇÇ] ‚Üí\n                        [inst_6 : Module R E] ‚Üí [inst_7 : Module R‚ÇÇ E‚ÇÇ] ‚Üí (E ‚âÉ‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ) ‚Üí E ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ",
    "name": "LinearIsometryEquiv.toContinuousLinearEquiv",
    "doc": "Interpret a `LinearIsometryEquiv` as a `ContinuousLinearEquiv`. ",
    "depth": 31},
   {"term":
    "{R‚ÇÅ : Type u_1} ‚Üí\n  {R‚ÇÇ : Type u_2} ‚Üí\n    [inst : Semiring R‚ÇÅ] ‚Üí\n      [inst_1 : Semiring R‚ÇÇ] ‚Üí\n        {œÉ‚ÇÅ‚ÇÇ : R‚ÇÅ ‚Üí+* R‚ÇÇ} ‚Üí\n          {œÉ‚ÇÇ‚ÇÅ : R‚ÇÇ ‚Üí+* R‚ÇÅ} ‚Üí\n            [inst_2 : RingHomInvPair œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÅ] ‚Üí\n              [inst_3 : RingHomInvPair œÉ‚ÇÇ‚ÇÅ œÉ‚ÇÅ‚ÇÇ] ‚Üí\n                {M‚ÇÅ : Type u_4} ‚Üí\n                  [inst_4 : TopologicalSpace M‚ÇÅ] ‚Üí\n                    [inst_5 : AddCommMonoid M‚ÇÅ] ‚Üí\n                      {M‚ÇÇ : Type u_6} ‚Üí\n                        [inst_6 : TopologicalSpace M‚ÇÇ] ‚Üí\n                          [inst_7 : AddCommMonoid M‚ÇÇ] ‚Üí\n                            [inst_8 : Module R‚ÇÅ M‚ÇÅ] ‚Üí [inst_9 : Module R‚ÇÇ M‚ÇÇ] ‚Üí (M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) ‚Üí M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ",
    "name": "ContinuousLinearEquiv.toContinuousLinearMap",
    "doc": "A continuous linear equivalence induces a continuous linear map. ",
    "depth": 33},
   {"term":
    "{R‚ÇÅ : Type u_1} ‚Üí\n  {R‚ÇÇ : Type u_2} ‚Üí\n    [inst : Semiring R‚ÇÅ] ‚Üí\n      [inst_1 : Semiring R‚ÇÇ] ‚Üí\n        {œÉ‚ÇÅ‚ÇÇ : R‚ÇÅ ‚Üí+* R‚ÇÇ} ‚Üí\n          {œÉ‚ÇÇ‚ÇÅ : R‚ÇÇ ‚Üí+* R‚ÇÅ} ‚Üí\n            [inst_2 : RingHomInvPair œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÅ] ‚Üí\n              [inst_3 : RingHomInvPair œÉ‚ÇÇ‚ÇÅ œÉ‚ÇÅ‚ÇÇ] ‚Üí\n                {M‚ÇÅ : Type u_4} ‚Üí\n                  [inst_4 : TopologicalSpace M‚ÇÅ] ‚Üí\n                    [inst_5 : AddCommMonoid M‚ÇÅ] ‚Üí\n                      {M‚ÇÇ : Type u_6} ‚Üí\n                        [inst_6 : TopologicalSpace M‚ÇÇ] ‚Üí\n                          [inst_7 : AddCommMonoid M‚ÇÇ] ‚Üí\n                            [inst_8 : Module R‚ÇÅ M‚ÇÅ] ‚Üí [inst_9 : Module R‚ÇÇ M‚ÇÇ] ‚Üí (M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) ‚Üí M‚ÇÇ ‚âÉSL[œÉ‚ÇÇ‚ÇÅ] M‚ÇÅ",
    "name": "ContinuousLinearEquiv.symm",
    "doc":
    "The inverse of a continuous linear equivalence as a continuous linear equivalence",
    "depth": 33},
   {"term":
    "{R‚ÇÅ : Type u_1} ‚Üí\n  {R‚ÇÇ : Type u_2} ‚Üí\n    [inst : Semiring R‚ÇÅ] ‚Üí\n      [inst_1 : Semiring R‚ÇÇ] ‚Üí\n        {œÉ‚ÇÅ‚ÇÇ : R‚ÇÅ ‚Üí+* R‚ÇÇ} ‚Üí\n          {œÉ‚ÇÇ‚ÇÅ : R‚ÇÇ ‚Üí+* R‚ÇÅ} ‚Üí\n            [inst_2 : RingHomInvPair œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÅ] ‚Üí\n              [inst_3 : RingHomInvPair œÉ‚ÇÇ‚ÇÅ œÉ‚ÇÅ‚ÇÇ] ‚Üí\n                {M‚ÇÅ : Type u_4} ‚Üí\n                  [inst_4 : TopologicalSpace M‚ÇÅ] ‚Üí\n                    [inst_5 : AddCommMonoid M‚ÇÅ] ‚Üí\n                      {M‚ÇÇ : Type u_6} ‚Üí\n                        [inst_6 : TopologicalSpace M‚ÇÇ] ‚Üí\n                          [inst_7 : AddCommMonoid M‚ÇÇ] ‚Üí\n                            [inst_8 : Module R‚ÇÅ M‚ÇÅ] ‚Üí [inst_9 : Module R‚ÇÇ M‚ÇÇ] ‚Üí (M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) ‚Üí M‚ÇÅ ‚âÉ‚Çú M‚ÇÇ",
    "name": "ContinuousLinearEquiv.toHomeomorph",
    "doc": "A continuous linear equivalence induces a homeomorphism. ",
    "depth": 33}],
  "count": 32},
 {"noDocExamples": [],
  "kind": "AlgebraicGeometry.¬´term_‚à£__¬ª",
  "examples":
  [{"term":
    "‚àÄ {P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme},\n  AlgebraicGeometry.PropertyIsLocalAtTarget P ‚Üí\n    ‚àÄ {X Y : AlgebraicGeometry.Scheme} (f : X ‚ü∂ Y) (U : TopologicalSpace.Opens ‚Üë‚ÜëY.toPresheafedSpace), P f ‚Üí P (f ‚à£_ U)",
    "name": "AlgebraicGeometry.PropertyIsLocalAtTarget.restrict",
    "doc":
    "If `P` holds for `f : X ‚ü∂ Y`, then `P` holds for `f ‚à£_ U` for any `U`. ",
    "depth": 34},
   {"term":
    "{X Y U : AlgebraicGeometry.Scheme} ‚Üí\n  (f : X ‚ü∂ Y) ‚Üí\n    (g : U ‚ü∂ Y) ‚Üí\n      [hg : AlgebraicGeometry.IsOpenImmersion g] ‚Üí\n        CategoryTheory.Arrow.mk (f ‚à£_ AlgebraicGeometry.Scheme.Hom.opensRange g) ‚âÖ\n          CategoryTheory.Arrow.mk CategoryTheory.Limits.pullback.snd",
    "name": "AlgebraicGeometry.morphismRestrictOpensRange",
    "doc":
    "Restricting a morphism onto the image of an open immersion is isomorphic to the base change\nalong the immersion. ",
    "depth": 35},
   {"term":
    "{X Y : AlgebraicGeometry.Scheme} ‚Üí\n  (f : X ‚ü∂ Y) ‚Üí\n    {U V : TopologicalSpace.Opens ‚Üë‚ÜëY.toPresheafedSpace} ‚Üí\n      U = V ‚Üí (CategoryTheory.Arrow.mk (f ‚à£_ U) ‚âÖ CategoryTheory.Arrow.mk (f ‚à£_ V))",
    "name": "AlgebraicGeometry.morphismRestrictEq",
    "doc":
    "The restrictions onto two equal open sets are isomorphic. This currently has bad defeqs when\nunfolded, but it should not matter for now. Replace this definition if better defeqs are needed. ",
    "depth": 35},
   {"term":
    "‚àÄ {P : AlgebraicGeometry.AffineTargetMorphismProperty},\n  AlgebraicGeometry.AffineTargetMorphismProperty.IsLocal P ‚Üí\n    ‚àÄ {X Y : AlgebraicGeometry.Scheme} [inst : AlgebraicGeometry.IsAffine Y] (f : X ‚ü∂ Y)\n      (r : ‚Üë(Y.presheaf.obj (Opposite.op ‚ä§))), P f ‚Üí P (f ‚à£_ AlgebraicGeometry.Scheme.basicOpen Y r)",
    "name":
    "AlgebraicGeometry.AffineTargetMorphismProperty.IsLocal.toBasicOpen",
    "doc":
    "`P` is stable under restriction to basic open set of global sections. ",
    "depth": 36},
   {"term":
    "{X Y : AlgebraicGeometry.Scheme} ‚Üí\n  (f : X ‚ü∂ Y) ‚Üí\n    (U : TopologicalSpace.Opens ‚Üë‚ÜëY.toPresheafedSpace) ‚Üí\n      (x :\n          ‚Üë‚Üë(AlgebraicGeometry.Scheme.restrict X\n                      (_ :\n                        OpenEmbedding\n                          ‚Üë(TopologicalSpace.Opens.inclusion\n                              ((TopologicalSpace.Opens.map f.val.base).obj\n                                U)))).toLocallyRingedSpace.toSheafedSpace.toPresheafedSpace) ‚Üí\n        CategoryTheory.Arrow.mk (AlgebraicGeometry.PresheafedSpace.stalkMap (f ‚à£_ U).val x) ‚âÖ\n          CategoryTheory.Arrow.mk (AlgebraicGeometry.PresheafedSpace.stalkMap f.val ‚Üëx)",
    "name": "AlgebraicGeometry.morphismRestrictStalkMap",
    "doc":
    "The stalk map of a restriction of a morphism is isomorphic to the stalk map of the original map.\n",
    "depth": 47}],
  "count": 32},
 {"noDocExamples":
  [{"term":
    "‚àÄ {V : Type u} [inst : Quiver V],\n  CategoryTheory.Groupoid.Free.of V =\n    Quiver.Symmetrify.of ‚ãôq CategoryTheory.Paths.of ‚ãôq\n      (CategoryTheory.Quotient.functor CategoryTheory.Groupoid.Free.redStep).toPrefunctor",
    "name": "CategoryTheory.Groupoid.Free.of_eq",
    "depth": 14},
   {"term":
    "‚àÄ {U : Type u_1} {V : Type u_2} [inst : Quiver U] [inst_1 : Quiver V] (F : U ‚•§q V), ùü≠q U ‚ãôq F = F",
    "name": "Prefunctor.id_comp",
    "depth": 15},
   {"term":
    "‚àÄ {U : Type u_1} {V : Type u_2} [inst : Quiver U] [inst_1 : Quiver V] (F : U ‚•§q V), F ‚ãôq ùü≠q V = F",
    "name": "Prefunctor.comp_id",
    "depth": 15},
   {"term":
    "‚àÄ {V : Type u‚ÇÅ} [inst : Quiver V] {C : Type u_1} [inst_1 : CategoryTheory.Category.{u_2, u_1} C] (œÜ : V ‚•§q C),\n  CategoryTheory.Paths.of ‚ãôq (CategoryTheory.Paths.lift œÜ).toPrefunctor = œÜ",
    "name": "CategoryTheory.Paths.lift_spec",
    "depth": 16}],
  "kind": "Prefunctor.¬´term_‚ãôq_¬ª",
  "examples":
  [{"term":
    "‚àÄ {V : Type u_2} [inst : Quiver V] {V' : Type u_4} [inst_1 : Quiver V'] [inst_2 : Quiver.HasReverse V'] (œÜ : V ‚•§q V')\n  (Œ¶ : Quiver.Symmetrify V ‚•§q V'),\n  Quiver.Symmetrify.of ‚ãôq Œ¶ = œÜ ‚Üí\n    (‚àÄ {X Y : Quiver.Symmetrify V} (f : X ‚ü∂ Y), Œ¶.map (Quiver.reverse f) = Quiver.reverse (Œ¶.map f)) ‚Üí\n      Œ¶ = Quiver.Symmetrify.lift œÜ",
    "name": "Quiver.Symmetrify.lift_unique",
    "doc":
    "`lift œÜ` is the only prefunctor extending `œÜ` and preserving reverses. ",
    "depth": 24}],
  "count": 30},
 {"noDocExamples":
  [{"term":
    "‚àÄ {R : Type u} [inst : CommRing R] (p q : Polynomial R), Polynomial.degree (p /‚Çò q) ‚â§ Polynomial.degree p",
    "name": "Polynomial.degree_divByMonic_le",
    "depth": 12}],
  "kind": "Polynomial.¬´term_/‚Çò_¬ª",
  "examples":
  [{"term":
    "‚àÄ {R : Type u} [inst : CommRing R] {p q : Polynomial R},\n  Polynomial.Monic q ‚Üí\n    Polynomial.degree q ‚â§ Polynomial.degree p ‚Üí Polynomial.leadingCoeff (p /‚Çò q) = Polynomial.leadingCoeff p",
    "name": "Polynomial.leadingCoeff_divByMonic_of_monic",
    "doc":
    "Division by a monic polynomial doesn't change the leading coefficient. ",
    "depth": 14},
   {"term":
    "‚àÄ {R : Type u_1} [inst : CommRing R] {n : ‚Ñï},\n  0 < n ‚Üí\n    Polynomial.cyclotomic n R =\n      (Polynomial.X ^ n - 1) /‚Çò Finset.prod (Nat.properDivisors n) fun i => Polynomial.cyclotomic i R",
    "name": "Polynomial.cyclotomic_eq_X_pow_sub_one_div",
    "doc":
    "We have\n`cyclotomic n R = (X ^ k - 1) /‚Çò (‚àè i in Nat.properDivisors k, cyclotomic i K)`. ",
    "depth": 21},
   {"term":
    "‚àÄ {K : Type u_2} [inst : CommRing K] [inst_1 : IsDomain K] {Œ∂ : K} {n : ‚Ñï},\n  0 < n ‚Üí\n    IsPrimitiveRoot Œ∂ n ‚Üí\n      Polynomial.cyclotomic' n K =\n        (Polynomial.X ^ n - 1) /‚Çò Finset.prod (Nat.properDivisors n) fun i => Polynomial.cyclotomic' i K",
    "name": "Polynomial.cyclotomic'_eq_X_pow_sub_one_div",
    "doc":
    "If there is a primitive `n`-th root of unity in `K`, then\n`cyclotomic' n K = (X ^ k - 1) /‚Çò (‚àè i in Nat.properDivisors k, cyclotomic' i K)`. ",
    "depth": 24},
   {"term":
    "‚àÄ {K : Type u_1} [inst : Field K] (f : Polynomial K) (a : K),\n  Polynomial.eval a (‚ÜëPolynomial.derivative f) ‚â† 0 ‚Üí\n    IsCoprime (Polynomial.X - ‚ÜëPolynomial.C a) (f /‚Çò (Polynomial.X - ‚ÜëPolynomial.C a))",
    "name": "Polynomial.isCoprime_of_is_root_of_eval_derivative_ne_zero",
    "doc":
    "If `f` is a polynomial over a field, and `a : K` satisfies `f' a ‚â† 0`,\nthen `f / (X - a)` is coprime with `X - a`.\nNote that we do not assume `f a = 0`, because `f / (X - a) = (f - f a) / (X - a)`. ",
    "depth": 27}],
  "count": 30},
 {"noDocExamples":
  [{"term": "‚àÄ {Œ± : Type u_1} (l : List Œ±), [] <:+: l",
    "name": "List.nil_infix",
    "depth": 5},
   {"term": "‚àÄ {Œ± : Type u_1} {l : List Œ±}, l <:+: l",
    "name": "List.infix_rfl",
    "depth": 5},
   {"term": "‚àÄ {Œ± : Type u_1} (l : List Œ±), l <:+: l",
    "name": "List.infix_refl",
    "depth": 5}],
  "kind": "List.¬´term_<:+:_¬ª",
  "examples":
  [{"term": "‚àÄ {Œ± : Type u_1} {l : List Œ±}, l <:+: [] ‚Üí l = []",
    "name": "List.eq_nil_of_infix_nil",
    "doc": "**Alias** of the forward direction of `List.infix_nil`.",
    "depth": 7},
   {"term":
    "‚àÄ {Œ± : Type u_1} {l‚ÇÅ l‚ÇÇ : List Œ±}, l‚ÇÅ <:+: l‚ÇÇ ‚Üí List.reverse l‚ÇÅ <:+: List.reverse l‚ÇÇ",
    "name": "List.isInfix.reverse",
    "doc": "**Alias** of the reverse direction of `List.reverse_infix`.",
    "depth": 8}],
  "count": 29},
 {"noDocExamples":
  [{"term": "‚àÄ (a b : ‚Ñï), ((a == b) = true) = (a = b)",
    "name": "Nat.beq_eq_true_eq",
    "depth": 10}],
  "kind": "¬´term_==_¬ª",
  "examples":
  [{"term":
    "‚àÄ {Œ± : Type u} [inst : BEq Œ±] [self : LawfulBEq Œ±] {a : Œ±}, (a == a) = true",
    "name": "LawfulBEq.rfl",
    "doc": "`==` is reflexive, that is, `(a == a) = true`. ",
    "depth": 10},
   {"term":
    "‚àÄ {Œ± : Type u} [inst : BEq Œ±] [self : LawfulBEq Œ±] {a b : Œ±}, (a == b) = true ‚Üí a = b",
    "name": "LawfulBEq.eq_of_beq",
    "doc":
    "If `a == b` evaluates to `true`, then `a` and `b` are equal in the logic. ",
    "depth": 12},
   {"term":
    "‚àÄ {Œ± : Type u_1} [inst : BEq Œ±] [self : PartialEquivBEq Œ±] {a b : Œ±}, (a == b) = true ‚Üí (b == a) = true",
    "name": "PartialEquivBEq.symm",
    "doc": "Symmetry for `BEq`. If `a == b` then `b == a`. ",
    "depth": 12},
   {"term":
    "‚àÄ {Œ± : Type u_1} [inst : BEq Œ±] [self : PartialEquivBEq Œ±] {a b c : Œ±},\n  (a == b) = true ‚Üí (b == c) = true ‚Üí (a == c) = true",
    "name": "PartialEquivBEq.trans",
    "doc": "Transitivity for `BEq`. If `a == b` and `b == c` then `a == c`. ",
    "depth": 14}],
  "count": 28},
 {"noDocExamples":
  [{"term":
    "‚àÄ {C : Type uC} [inst : CategoryTheory.Category.{uC', uC} C] {W : CategoryTheory.MorphismProperty C} {D : Type uD}\n  [inst_1 : CategoryTheory.Category.{uD', uD} D]\n  {F G : CategoryTheory.Functor (CategoryTheory.MorphismProperty.Localization W) D}\n  (œÑ :\n    CategoryTheory.Functor.comp (CategoryTheory.MorphismProperty.Q W) F ‚ü∂\n      CategoryTheory.Functor.comp (CategoryTheory.MorphismProperty.Q W) G),\n  CategoryTheory.CategoryStruct.id (CategoryTheory.MorphismProperty.Q W) ‚ó´\n      CategoryTheory.Localization.Construction.natTransExtension œÑ =\n    œÑ",
    "name": "CategoryTheory.Localization.Construction.natTransExtension_hcomp",
    "depth": 23},
   {"term":
    "‚àÄ {C : Type uC} [inst : CategoryTheory.Category.{uC', uC} C] {W : CategoryTheory.MorphismProperty C} {D : Type uD}\n  [inst_1 : CategoryTheory.Category.{uD', uD} D]\n  {F G : CategoryTheory.Functor (CategoryTheory.MorphismProperty.Localization W) D} {œÑ‚ÇÅ œÑ‚ÇÇ : F ‚ü∂ G},\n  CategoryTheory.CategoryStruct.id (CategoryTheory.MorphismProperty.Q W) ‚ó´ œÑ‚ÇÅ =\n      CategoryTheory.CategoryStruct.id (CategoryTheory.MorphismProperty.Q W) ‚ó´ œÑ‚ÇÇ ‚Üí\n    œÑ‚ÇÅ = œÑ‚ÇÇ",
    "name": "CategoryTheory.Localization.Construction.natTrans_hcomp_injective",
    "depth": 26},
   {"term":
    "‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D]\n  {E : Type u‚ÇÉ} [inst_2 : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E] {F G : CategoryTheory.Functor C D}\n  {H I : CategoryTheory.Functor D E} (Œ± : F ‚âÖ G) (Œ≤ : H ‚âÖ I), (CategoryTheory.NatIso.hcomp Œ± Œ≤).hom = Œ±.hom ‚ó´ Œ≤.hom",
    "name": "CategoryTheory.NatIso.hcomp_hom",
    "depth": 27},
   {"term":
    "‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D]\n  {E : Type u‚ÇÉ} [inst_2 : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E] {F G : CategoryTheory.Functor C D}\n  {H : CategoryTheory.Functor D E} (Œ± : F ‚ü∂ G) (X : C),\n  CategoryTheory.NatTrans.app (Œ± ‚ó´ CategoryTheory.CategoryStruct.id H) X = H.map (CategoryTheory.NatTrans.app Œ± X)",
    "name": "CategoryTheory.NatTrans.hcomp_id_app",
    "depth": 27},
   {"term":
    "‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D]\n  {E : Type u‚ÇÉ} [inst_2 : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E] {F G : CategoryTheory.Functor C D}\n  {H : CategoryTheory.Functor E C} (Œ± : F ‚ü∂ G) (X : E),\n  CategoryTheory.NatTrans.app (CategoryTheory.CategoryStruct.id H ‚ó´ Œ±) X = CategoryTheory.NatTrans.app Œ± (H.obj X)",
    "name": "CategoryTheory.NatTrans.id_hcomp_app",
    "depth": 27}],
  "kind": "CategoryTheory.NatTrans.¬´term_‚ó´_¬ª",
  "examples": [],
  "count": 27},
 {"noDocExamples":
  [{"term": "‚àÄ {Œ± : Type u} (s : Stream'.WSeq Œ±), s ~ ∑ s",
    "name": "Stream'.WSeq.Equiv.refl",
    "depth": 5},
   {"term": "‚àÄ {Œ± : Type u} (s : Stream'.WSeq Œ±), Stream'.WSeq.think s ~ ∑ s",
    "name": "Stream'.WSeq.think_equiv",
    "depth": 6},
   {"term": "‚àÄ {Œ± : Type u} {s t : Stream'.WSeq Œ±}, s ~ ∑ t ‚Üí t ~ ∑ s",
    "name": "Stream'.WSeq.Equiv.symm",
    "depth": 7},
   {"term":
    "‚àÄ {Œ± : Type u} (s : Stream'.WSeq Œ±), Stream'.WSeq.join (Stream'.WSeq.ret s) ~ ∑ s",
    "name": "Stream'.WSeq.join_ret",
    "depth": 8},
   {"term":
    "‚àÄ {Œ± : Type u} {s t : Stream'.WSeq Œ±}, s ~ ∑ t ‚Üí (Stream'.WSeq.Productive s ‚Üî Stream'.WSeq.Productive t)",
    "name": "Stream'.WSeq.productive_congr",
    "depth": 8}],
  "kind": "Stream'.WSeq.¬´term_~ ∑_¬ª",
  "examples": [],
  "count": 27},
 {"noDocExamples":
  [{"term":
    "(Œ± : Type u_2) ‚Üí [inst : TopologicalSpace Œ±] ‚Üí Inhabited (Œ± ‚ÜíCO Œ±)",
    "name": "ContinuousOpenMap.instInhabitedContinuousOpenMap",
    "depth": 7},
   {"term":
    "{Œ± : Type u_6} ‚Üí {Œ≤ : Type u_7} ‚Üí [inst : TopologicalSpace Œ±] ‚Üí [inst_1 : TopologicalSpace Œ≤] ‚Üí (Œ± ‚ÜíCO Œ≤) ‚Üí C(Œ±, Œ≤)",
    "name": "ContinuousOpenMap.toContinuousMap",
    "depth": 9}],
  "kind": "¬´term_‚ÜíCO_¬ª",
  "examples":
  [{"term": "(Œ± : Type u_2) ‚Üí [inst : TopologicalSpace Œ±] ‚Üí Œ± ‚ÜíCO Œ±",
    "name": "ContinuousOpenMap.id",
    "doc": "`id` as a `ContinuousOpenMap`. ",
    "depth": 6},
   {"term":
    "{Œ± : Type u_2} ‚Üí\n  {Œ≤ : Type u_3} ‚Üí\n    {Œ≥ : Type u_4} ‚Üí\n      [inst : TopologicalSpace Œ±] ‚Üí\n        [inst_1 : TopologicalSpace Œ≤] ‚Üí [inst_2 : TopologicalSpace Œ≥] ‚Üí (Œ≤ ‚ÜíCO Œ≥) ‚Üí (Œ± ‚ÜíCO Œ≤) ‚Üí Œ± ‚ÜíCO Œ≥",
    "name": "ContinuousOpenMap.comp",
    "doc": "Composition of `ContinuousOpenMap`s as a `ContinuousOpenMap`. ",
    "depth": 12},
   {"term":
    "{Œ± : Type u_2} ‚Üí\n  {Œ≤ : Type u_3} ‚Üí\n    [inst : TopologicalSpace Œ±] ‚Üí [inst_1 : TopologicalSpace Œ≤] ‚Üí (f : Œ± ‚ÜíCO Œ≤) ‚Üí (f' : Œ± ‚Üí Œ≤) ‚Üí f' = ‚Üëf ‚Üí Œ± ‚ÜíCO Œ≤",
    "name": "ContinuousOpenMap.copy",
    "doc":
    "Copy of a `ContinuousOpenMap` with a new `ContinuousMap` equal to the old one. Useful to fix\ndefinitional equalities. ",
    "depth": 21}],
  "count": 26},
 {"noDocExamples": [],
  "kind": "SimpleGraph.¬´term_‚ñ°_¬ª",
  "examples":
  [{"term":
    "{Œ± : Type u_1} ‚Üí {Œ≤ : Type u_2} ‚Üí (G : SimpleGraph Œ±) ‚Üí (H : SimpleGraph Œ≤) ‚Üí G ‚ñ° H ‚âÉg H ‚ñ° G",
    "name": "SimpleGraph.boxProdComm",
    "doc":
    "The box product is commutative up to isomorphism. `Equiv.prodComm` as a graph isomorphism. ",
    "depth": 10},
   {"term":
    "{Œ± : Type u_1} ‚Üí {Œ≤ : Type u_2} ‚Üí (G : SimpleGraph Œ±) ‚Üí (H : SimpleGraph Œ≤) ‚Üí Œ≤ ‚Üí G ‚Ü™g G ‚ñ° H",
    "name": "SimpleGraph.boxProdLeft",
    "doc": "The embedding of `G` into `G ‚ñ° H` given by `b`. ",
    "depth": 10},
   {"term":
    "{Œ± : Type u_1} ‚Üí {Œ≤ : Type u_2} ‚Üí (G : SimpleGraph Œ±) ‚Üí (H : SimpleGraph Œ≤) ‚Üí Œ± ‚Üí H ‚Ü™g G ‚ñ° H",
    "name": "SimpleGraph.boxProdRight",
    "doc": "The embedding of `H` into `G ‚ñ° H` given by `a`. ",
    "depth": 10},
   {"term":
    "{Œ± : Type u_1} ‚Üí\n  {Œ≤ : Type u_2} ‚Üí\n    {Œ≥ : Type u_3} ‚Üí (G : SimpleGraph Œ±) ‚Üí (H : SimpleGraph Œ≤) ‚Üí (I : SimpleGraph Œ≥) ‚Üí G ‚ñ° H ‚ñ° I ‚âÉg G ‚ñ° (H ‚ñ° I)",
    "name": "SimpleGraph.boxProdAssoc",
    "doc":
    "The box product is associative up to isomorphism. `Equiv.prodAssoc` as a graph isomorphism. ",
    "depth": 14},
   {"term":
    "{Œ± : Type u_1} ‚Üí\n  {Œ≤ : Type u_2} ‚Üí\n    (G : SimpleGraph Œ±) ‚Üí\n      {H : SimpleGraph Œ≤} ‚Üí {b‚ÇÅ b‚ÇÇ : Œ≤} ‚Üí (a : Œ±) ‚Üí SimpleGraph.Walk H b‚ÇÅ b‚ÇÇ ‚Üí SimpleGraph.Walk (G ‚ñ° H) (a, b‚ÇÅ) (a, b‚ÇÇ)",
    "name": "SimpleGraph.Walk.boxProdRight",
    "doc": "Turn a walk on `H` into a walk on `G ‚ñ° H`. ",
    "depth": 15}],
  "count": 26},
 {"noDocExamples": [],
  "kind": "¬´term_‚Üír_¬ª",
  "examples":
  [{"term": "{Œ± : Type u_1} ‚Üí (r : Œ± ‚Üí Œ± ‚Üí Prop) ‚Üí r ‚Üír r",
    "name": "RelHom.id",
    "doc": "Identity map is a relation homomorphism. ",
    "depth": 6},
   {"term":
    "{Œ± : Type u_1} ‚Üí {Œ≤ : Type u_2} ‚Üí {r : Œ± ‚Üí Œ± ‚Üí Prop} ‚Üí {s : Œ≤ ‚Üí Œ≤ ‚Üí Prop} ‚Üí r ‚Ü™r s ‚Üí r ‚Üír s",
    "name": "RelEmbedding.toRelHom",
    "doc": "A relation embedding is also a relation homomorphism ",
    "depth": 9},
   {"term":
    "{Œ± : Type u_5} ‚Üí {Œ≤ : Type u_6} ‚Üí {r : Œ± ‚Üí Œ± ‚Üí Prop} ‚Üí {s : Œ≤ ‚Üí Œ≤ ‚Üí Prop} ‚Üí r ‚Üír s ‚Üí Œ± ‚Üí Œ≤",
    "name": "RelHom.toFun",
    "doc": "The underlying function of a `RelHom` ",
    "depth": 9},
   {"term":
    "{Œ± : Type u_1} ‚Üí {Œ≤ : Type u_2} ‚Üí (f : Œ± ‚Üí Œ≤) ‚Üí (s : Œ≤ ‚Üí Œ≤ ‚Üí Prop) ‚Üí f ‚Åª¬π'o s ‚Üír s",
    "name": "RelHom.preimage",
    "doc":
    "A function is a relation homomorphism from the preimage relation of `s` to `s`. ",
    "depth": 10},
   {"term":
    "{Œ± : Type u_1} ‚Üí {Œ≤ : Type u_2} ‚Üí {r : Œ± ‚Üí Œ± ‚Üí Prop} ‚Üí {s : Œ≤ ‚Üí Œ≤ ‚Üí Prop} ‚Üí r ‚Üír s ‚Üí Function.swap r ‚Üír Function.swap s",
    "name": "RelHom.swap",
    "doc":
    "A relation homomorphism is also a relation homomorphism between dual relations. ",
    "depth": 11}],
  "count": 25},
 {"noDocExamples": [],
  "kind": "Function.¬´term‚Üø_¬ª",
  "examples":
  [{"term":
    "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤]\n  [inst_2 : WeaklyLocallyCompactSpace Œ±] [inst_3 : CompactSpace Œ≤] [inst_4 : UniformSpace Œ≥] (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥),\n  Continuous ‚Üøf ‚Üí ‚àÄ (x : Œ±), TendstoUniformly f (f x) (nhds x)",
    "name": "Continuous.tendstoUniformly",
    "doc":
    "A continuous family of functions `Œ± ‚Üí Œ≤ ‚Üí Œ≥` tends uniformly to its value at `x`\nif `Œ±` is weakly locally compact and `Œ≤` is compact. ",
    "depth": 18},
   {"term":
    "‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {p : Filter Œπ} {c : Œ≤},\n  Filter.Tendsto (‚ÜøF) (p √óÀ¢ ‚ä§) (nhds c) ‚Üî TendstoUniformly F (fun x => c) p",
    "name": "tendsto_prod_top_iff",
    "doc":
    "Uniform convergence to a constant function is equivalent to convergence in `p √óÀ¢ ‚ä§`. ",
    "depth": 19},
   {"term":
    "‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {s : Set Œ±} {p : Filter Œπ} {c : Œ≤},\n  Filter.Tendsto (‚ÜøF) (p √óÀ¢ Filter.principal s) (nhds c) ‚Üî TendstoUniformlyOn F (fun x => c) p s",
    "name": "tendsto_prod_principal_iff",
    "doc":
    "Uniform convergence on a set `s` to a constant function is equivalent to convergence in\n`p √óÀ¢ ùìü s`. ",
    "depth": 20},
   {"term":
    "‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {p : Filter Œπ} {p' : Filter Œ±} {c : Œ≤},\n  Filter.Tendsto (‚ÜøF) (p √óÀ¢ p') (nhds c) ‚Üî TendstoUniformlyOnFilter F (fun x => c) p p'",
    "name": "tendsto_prod_filter_iff",
    "doc":
    "Uniform convergence on a filter `p'` to a constant function is equivalent to convergence in\n`p √óÀ¢ p'`. ",
    "depth": 20},
   {"term":
    "‚àÄ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {x y : X} {Œ≥ : Y ‚Üí Path x y}\n  {f : Y ‚Üí ‚Ñù}, Continuous ‚ÜøŒ≥ ‚Üí Continuous f ‚Üí Continuous fun t => Path.extend (Œ≥ t) (f t)",
    "name": "Continuous.path_extend",
    "doc": "See Note [continuity lemma statement]. ",
    "depth": 21}],
  "count": 24},
 {"noDocExamples":
  [{"term":
    "‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] [inst_1 : CategoryTheory.MonoidalCategory C] (X Y : C)\n  [inst_2 : CategoryTheory.ExactPairing X Y],\n  CategoryTheory.CategoryStruct.comp\n      (CategoryTheory.MonoidalCategory.tensorHom (Œ∑_ X Y) (CategoryTheory.CategoryStruct.id X))\n      (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.associator X Y X).hom\n        (CategoryTheory.MonoidalCategory.tensorHom (CategoryTheory.CategoryStruct.id X) (Œµ_ X Y))) =\n    CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.leftUnitor X).hom\n      (CategoryTheory.MonoidalCategory.rightUnitor X).inv",
    "name": "CategoryTheory.ExactPairing.evaluation_coevaluation",
    "depth": 21},
   {"term":
    "‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] [inst_1 : CategoryTheory.MonoidalCategory C] {X Y : C}\n  [inst_2 : CategoryTheory.HasLeftDual X] [inst_3 : CategoryTheory.HasLeftDual Y] (f : X ‚ü∂ Y),\n  CategoryTheory.CategoryStruct.comp\n      (CategoryTheory.MonoidalCategory.tensorHom (CategoryTheory.CategoryStruct.id X) (·òÅf)) (Œµ_ (·òÅX) X) =\n    CategoryTheory.CategoryStruct.comp\n      (CategoryTheory.MonoidalCategory.tensorHom f (CategoryTheory.CategoryStruct.id ·òÅY)) (Œµ_ (·òÅY) Y)",
    "name": "CategoryTheory.leftAdjointMate_comp_evaluation",
    "depth": 21},
   {"term":
    "‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] [inst_1 : CategoryTheory.MonoidalCategory C] (X Y : C)\n  [inst_2 : CategoryTheory.ExactPairing X Y],\n  CategoryTheory.CategoryStruct.comp\n      (CategoryTheory.MonoidalCategory.tensorHom (CategoryTheory.CategoryStruct.id Y) (Œ∑_ X Y))\n      (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.associator Y X Y).inv\n        (CategoryTheory.MonoidalCategory.tensorHom (Œµ_ X Y) (CategoryTheory.CategoryStruct.id Y))) =\n    CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.rightUnitor Y).hom\n      (CategoryTheory.MonoidalCategory.leftUnitor Y).inv",
    "name": "CategoryTheory.ExactPairing.coevaluation_evaluation",
    "depth": 21},
   {"term":
    "‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] [inst_1 : CategoryTheory.MonoidalCategory C] {X Y : C}\n  [inst_2 : CategoryTheory.HasRightDual X] [inst_3 : CategoryTheory.HasRightDual Y] (f : X ‚ü∂ Y),\n  CategoryTheory.CategoryStruct.comp\n      (CategoryTheory.MonoidalCategory.tensorHom (f·òÅ) (CategoryTheory.CategoryStruct.id X)) (Œµ_ X X·òÅ) =\n    CategoryTheory.CategoryStruct.comp\n      (CategoryTheory.MonoidalCategory.tensorHom (CategoryTheory.CategoryStruct.id Y·òÅ) f) (Œµ_ Y Y·òÅ)",
    "name": "CategoryTheory.rightAdjointMate_comp_evaluation",
    "depth": 23}],
  "kind": "CategoryTheory.ExactPairing.termŒµ_",
  "examples":
  [{"term":
    "{C : Type u_1} ‚Üí\n  {D : Type u_2} ‚Üí\n    [inst : CategoryTheory.Category.{u_3, u_1} C] ‚Üí\n      [inst_1 : CategoryTheory.Category.{u_4, u_2} D] ‚Üí\n        [inst_2 : CategoryTheory.MonoidalCategory C] ‚Üí\n          [inst_3 : CategoryTheory.MonoidalCategory D] ‚Üí\n            (F : CategoryTheory.MonoidalFunctor C D) ‚Üí\n              [inst_4 : CategoryTheory.Faithful F.toFunctor] ‚Üí\n                {X Y : C} ‚Üí\n                  (eval :\n                      CategoryTheory.MonoidalCategory.tensorObj Y X ‚ü∂ CategoryTheory.MonoidalCategory.tensorUnit C) ‚Üí\n                    (coeval :\n                        CategoryTheory.MonoidalCategory.tensorUnit C ‚ü∂ CategoryTheory.MonoidalCategory.tensorObj X Y) ‚Üí\n                      [inst_5 : CategoryTheory.ExactPairing (F.obj X) (F.obj Y)] ‚Üí\n                        F.map eval =\n                            CategoryTheory.CategoryStruct.comp\n                              (CategoryTheory.inv (CategoryTheory.LaxMonoidalFunctor.Œº F.toLaxMonoidalFunctor Y X))\n                              (CategoryTheory.CategoryStruct.comp (Œµ_ (F.obj X) (F.obj Y)) F.Œµ) ‚Üí\n                          F.map coeval =\n                              CategoryTheory.CategoryStruct.comp (CategoryTheory.inv F.Œµ)\n                                (CategoryTheory.CategoryStruct.comp (Œ∑_ (F.obj X) (F.obj Y))\n                                  (CategoryTheory.LaxMonoidalFunctor.Œº F.toLaxMonoidalFunctor X Y)) ‚Üí\n                            CategoryTheory.ExactPairing X Y",
    "name": "CategoryTheory.exactPairingOfFaithful",
    "doc":
    "Given candidate data for an exact pairing,\nwhich is sent by a faithful monoidal functor to an exact pairing,\nthe equations holds automatically. ",
    "depth": 34}],
  "count": 24},
 {"noDocExamples":
  [{"term":
    "{C : Type u‚ÇÅ} ‚Üí [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] ‚Üí CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C·¥π·µí·µñ",
    "name": "CategoryTheory.MonoidalOpposite.monoidalOppositeCategory",
    "depth": 4},
   {"term":
    "{C : Type u‚ÇÅ} ‚Üí\n  [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] ‚Üí\n    [inst_1 : CategoryTheory.MonoidalCategory C] ‚Üí CategoryTheory.MonoidalCategory C·¥π·µí·µñ",
    "name": "CategoryTheory.monoidalCategoryMop",
    "depth": 6}],
  "kind": "CategoryTheory.MonoidalOpposite.¬´term_·¥π·µí·µñ¬ª",
  "examples":
  [{"term": "{C : Type u‚ÇÅ} ‚Üí C·¥π·µí·µñ ‚Üí C",
    "name": "CategoryTheory.MonoidalOpposite.unmop",
    "doc": "Think of an object of `C·¥π·µí·µñ` as an object of `C`. ",
    "depth": 3},
   {"term": "{C : Type u‚ÇÅ} ‚Üí C ‚Üí C·¥π·µí·µñ",
    "name": "CategoryTheory.MonoidalOpposite.mop",
    "doc": "Think of an object of `C` as an object of `C·¥π·µí·µñ`. ",
    "depth": 3},
   {"term":
    "{C : Type u‚ÇÅ} ‚Üí\n  [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] ‚Üí\n    {X Y : C·¥π·µí·µñ} ‚Üí (X ‚ü∂ Y) ‚Üí (CategoryTheory.MonoidalOpposite.unmop X ‚ü∂ CategoryTheory.MonoidalOpposite.unmop Y)",
    "name": "Quiver.Hom.unmop",
    "doc":
    "We can think of a morphism `f : mop X ‚ü∂ mop Y` as a morphism `X ‚ü∂ Y`. ",
    "depth": 12}],
  "count": 24},
 {"noDocExamples":
  [{"term":
    "‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] [inst_1 : CategoryTheory.MonoidalCategory C] {X Y : C}\n  [inst_2 : CategoryTheory.HasRightDual X] [inst_3 : CategoryTheory.HasRightDual Y] (f : X ‚ü∂ Y),\n  CategoryTheory.CategoryStruct.comp (Œ∑_ Y Y·òÅ)\n      (CategoryTheory.MonoidalCategory.tensorHom (CategoryTheory.CategoryStruct.id Y) (f·òÅ)) =\n    CategoryTheory.CategoryStruct.comp (Œ∑_ X X·òÅ)\n      (CategoryTheory.MonoidalCategory.tensorHom f (CategoryTheory.CategoryStruct.id X·òÅ))",
    "name": "CategoryTheory.coevaluation_comp_rightAdjointMate",
    "depth": 20},
   {"term":
    "‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] [inst_1 : CategoryTheory.MonoidalCategory C] (X Y : C)\n  [inst_2 : CategoryTheory.ExactPairing X Y],\n  CategoryTheory.CategoryStruct.comp\n      (CategoryTheory.MonoidalCategory.tensorHom (Œ∑_ X Y) (CategoryTheory.CategoryStruct.id X))\n      (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.associator X Y X).hom\n        (CategoryTheory.MonoidalCategory.tensorHom (CategoryTheory.CategoryStruct.id X) (Œµ_ X Y))) =\n    CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.leftUnitor X).hom\n      (CategoryTheory.MonoidalCategory.rightUnitor X).inv",
    "name": "CategoryTheory.ExactPairing.evaluation_coevaluation",
    "depth": 21},
   {"term":
    "‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] [inst_1 : CategoryTheory.MonoidalCategory C] (X Y : C)\n  [inst_2 : CategoryTheory.ExactPairing X Y],\n  CategoryTheory.CategoryStruct.comp\n      (CategoryTheory.MonoidalCategory.tensorHom (CategoryTheory.CategoryStruct.id Y) (Œ∑_ X Y))\n      (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.associator Y X Y).inv\n        (CategoryTheory.MonoidalCategory.tensorHom (Œµ_ X Y) (CategoryTheory.CategoryStruct.id Y))) =\n    CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.rightUnitor Y).hom\n      (CategoryTheory.MonoidalCategory.leftUnitor Y).inv",
    "name": "CategoryTheory.ExactPairing.coevaluation_evaluation",
    "depth": 21},
   {"term":
    "‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] [inst_1 : CategoryTheory.MonoidalCategory C] {X Y : C}\n  [inst_2 : CategoryTheory.HasLeftDual X] [inst_3 : CategoryTheory.HasLeftDual Y] (f : X ‚ü∂ Y),\n  CategoryTheory.CategoryStruct.comp (Œ∑_ (·òÅY) Y)\n      (CategoryTheory.MonoidalCategory.tensorHom (·òÅf) (CategoryTheory.CategoryStruct.id Y)) =\n    CategoryTheory.CategoryStruct.comp (Œ∑_ (·òÅX) X)\n      (CategoryTheory.MonoidalCategory.tensorHom (CategoryTheory.CategoryStruct.id ·òÅX) f)",
    "name": "CategoryTheory.coevaluation_comp_leftAdjointMate",
    "depth": 22}],
  "kind": "CategoryTheory.ExactPairing.termŒ∑_",
  "examples":
  [{"term":
    "{C : Type u_1} ‚Üí\n  {D : Type u_2} ‚Üí\n    [inst : CategoryTheory.Category.{u_3, u_1} C] ‚Üí\n      [inst_1 : CategoryTheory.Category.{u_4, u_2} D] ‚Üí\n        [inst_2 : CategoryTheory.MonoidalCategory C] ‚Üí\n          [inst_3 : CategoryTheory.MonoidalCategory D] ‚Üí\n            (F : CategoryTheory.MonoidalFunctor C D) ‚Üí\n              [inst_4 : CategoryTheory.Faithful F.toFunctor] ‚Üí\n                {X Y : C} ‚Üí\n                  (eval :\n                      CategoryTheory.MonoidalCategory.tensorObj Y X ‚ü∂ CategoryTheory.MonoidalCategory.tensorUnit C) ‚Üí\n                    (coeval :\n                        CategoryTheory.MonoidalCategory.tensorUnit C ‚ü∂ CategoryTheory.MonoidalCategory.tensorObj X Y) ‚Üí\n                      [inst_5 : CategoryTheory.ExactPairing (F.obj X) (F.obj Y)] ‚Üí\n                        F.map eval =\n                            CategoryTheory.CategoryStruct.comp\n                              (CategoryTheory.inv (CategoryTheory.LaxMonoidalFunctor.Œº F.toLaxMonoidalFunctor Y X))\n                              (CategoryTheory.CategoryStruct.comp (Œµ_ (F.obj X) (F.obj Y)) F.Œµ) ‚Üí\n                          F.map coeval =\n                              CategoryTheory.CategoryStruct.comp (CategoryTheory.inv F.Œµ)\n                                (CategoryTheory.CategoryStruct.comp (Œ∑_ (F.obj X) (F.obj Y))\n                                  (CategoryTheory.LaxMonoidalFunctor.Œº F.toLaxMonoidalFunctor X Y)) ‚Üí\n                            CategoryTheory.ExactPairing X Y",
    "name": "CategoryTheory.exactPairingOfFaithful",
    "doc":
    "Given candidate data for an exact pairing,\nwhich is sent by a faithful monoidal functor to an exact pairing,\nthe equations holds automatically. ",
    "depth": 34}],
  "count": 24},
 {"noDocExamples":
  [{"term":
    "‚àÄ {R : Type u_1} [inst : Ring R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {U : Submodule R M}\n  {x : M}, x ‚â° x [SMOD U]",
    "name": "SModEq.rfl",
    "depth": 15},
   {"term":
    "‚àÄ {R : Type u_1} [inst : Ring R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {U : Submodule R M}\n  (x : M), x ‚â° x [SMOD U]",
    "name": "SModEq.refl",
    "depth": 15},
   {"term":
    "‚àÄ {R : Type u_4} [inst : CommRing R] {I : Ideal R} {x y : R},\n  x ‚â° y [SMOD I] ‚Üí ‚àÄ (f : Polynomial R), Polynomial.eval x f ‚â° Polynomial.eval y f [SMOD I]",
    "name": "SModEq.eval",
    "depth": 16},
   {"term":
    "‚àÄ {R : Type u_1} [inst : Ring R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {U : Submodule R M}\n  {x y : M}, x ‚â° y [SMOD U] ‚Üí y ‚â° x [SMOD U]",
    "name": "SModEq.symm",
    "depth": 17},
   {"term":
    "‚àÄ {R : Type u_1} [inst : Ring R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {x y : M},\n  x ‚â° y [SMOD ‚ä§]",
    "name": "SModEq.top",
    "depth": 17}],
  "kind": "¬´term_‚â°_[SMOD_]¬ª",
  "examples": [],
  "count": 23},
 {"noDocExamples": [],
  "kind": "Matrix.termGL",
  "examples":
  [{"term":
    "{n : Type u} ‚Üí\n  [inst : DecidableEq n] ‚Üí\n    [inst_1 : Fintype n] ‚Üí {R : Type v} ‚Üí [inst_2 : CommRing R] ‚Üí CoeFun (GL n R) fun x => n ‚Üí n ‚Üí R",
    "name": "Matrix.GeneralLinearGroup.instCoeFun",
    "doc":
    "This instance is here for convenience, but is not the simp-normal form. ",
    "depth": 14},
   {"term":
    "{n : Type u} ‚Üí\n  [inst : DecidableEq n] ‚Üí\n    [inst_1 : Fintype n] ‚Üí {R : Type v} ‚Üí [inst_2 : CommRing R] ‚Üí Matrix.SpecialLinearGroup n R ‚Üí GL n R",
    "name": "Matrix.SpecialLinearGroup.coeToGL",
    "doc":
    "The map from SL(n) to GL(n) underlying the coercion, forgetting the value of the determinant.\n",
    "depth": 14},
   {"term":
    "{n : Type u} ‚Üí\n  [inst : DecidableEq n] ‚Üí\n    [inst_1 : Fintype n] ‚Üí {R : Type v} ‚Üí [inst_2 : CommRing R] ‚Üí (A : Matrix n n R) ‚Üí IsUnit (Matrix.det A) ‚Üí GL n R",
    "name": "Matrix.GeneralLinearGroup.mk''",
    "doc": "Given a matrix with unit determinant we get an element of `GL n R`",
    "depth": 17},
   {"term":
    "{n : Type u} ‚Üí\n  [inst : DecidableEq n] ‚Üí\n    [inst_1 : Fintype n] ‚Üí\n      {R : Type v} ‚Üí [inst_2 : CommRing R] ‚Üí (A : Matrix n n R) ‚Üí Invertible (Matrix.det A) ‚Üí GL n R",
    "name": "Matrix.GeneralLinearGroup.mk'",
    "doc":
    "Given a matrix with invertible determinant we get an element of `GL n R`",
    "depth": 17},
   {"term":
    "(n : Type u) ‚Üí\n  (R : Type v) ‚Üí [inst : DecidableEq n] ‚Üí [inst_1 : Fintype n] ‚Üí [inst_2 : LinearOrderedCommRing R] ‚Üí Subgroup (GL n R)",
    "name": "Matrix.GLPos",
    "doc":
    "This is the subgroup of `nxn` matrices with entries over a\nlinear ordered ring and positive determinant. ",
    "depth": 18}],
  "count": 23},
 {"noDocExamples": [],
  "kind": "Complex.¬´term_√ó‚ÑÇ_¬ª",
  "examples":
  [{"term":
    "‚àÄ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚ÑÇ E] [inst_2 : CompleteSpace E] (f : ‚ÑÇ ‚Üí E)\n  (z w : ‚ÑÇ),\n  DifferentiableOn ‚ÑÇ f (Set.uIcc z.re w.re √ó‚ÑÇ Set.uIcc z.im w.im) ‚Üí\n    (((‚à´ (x : ‚Ñù) in z.re..w.re, f (‚Üëx + ‚Üëz.im * Complex.I)) - ‚à´ (x : ‚Ñù) in z.re..w.re, f (‚Üëx + ‚Üëw.im * Complex.I)) +\n          Complex.I ‚Ä¢ ‚à´ (y : ‚Ñù) in z.im..w.im, f (‚Üëw.re + ‚Üëy * Complex.I)) -\n        Complex.I ‚Ä¢ ‚à´ (y : ‚Ñù) in z.im..w.im, f (‚Üëz.re + ‚Üëy * Complex.I) =\n      0",
    "name": "Complex.integral_boundary_rect_eq_zero_of_differentiableOn",
    "doc":
    "**Cauchy-Goursat theorem** for a rectangle: the integral of a complex differentiable function\nover the boundary of a rectangle equals zero. More precisely, if `f` is complex differentiable on a\nclosed rectangle, then its integral over the boundary of the rectangle equals zero. ",
    "depth": 29},
   {"term":
    "‚àÄ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚ÑÇ E] [inst_2 : CompleteSpace E] (f : ‚ÑÇ ‚Üí E)\n  (z w : ‚ÑÇ),\n  ContinuousOn f (Set.uIcc z.re w.re √ó‚ÑÇ Set.uIcc z.im w.im) ‚Üí\n    DifferentiableOn ‚ÑÇ f (Set.Ioo (min z.re w.re) (max z.re w.re) √ó‚ÑÇ Set.Ioo (min z.im w.im) (max z.im w.im)) ‚Üí\n      (((‚à´ (x : ‚Ñù) in z.re..w.re, f (‚Üëx + ‚Üëz.im * Complex.I)) - ‚à´ (x : ‚Ñù) in z.re..w.re, f (‚Üëx + ‚Üëw.im * Complex.I)) +\n            Complex.I ‚Ä¢ ‚à´ (y : ‚Ñù) in z.im..w.im, f (‚Üëw.re + ‚Üëy * Complex.I)) -\n          Complex.I ‚Ä¢ ‚à´ (y : ‚Ñù) in z.im..w.im, f (‚Üëz.re + ‚Üëy * Complex.I) =\n        0",
    "name":
    "Complex.integral_boundary_rect_eq_zero_of_continuousOn_of_differentiableOn",
    "doc":
    "**Cauchy-Goursat theorem for a rectangle**: the integral of a complex differentiable function\nover the boundary of a rectangle equals zero. More precisely, if `f` is continuous on a closed\nrectangle and is complex differentiable on the corresponding open rectangle, then its integral over\nthe boundary of the rectangle equals zero. ",
    "depth": 30},
   {"term":
    "‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚ÑÇ E] {f : ‚ÑÇ ‚Üí E},\n  DiffContOnCl ‚ÑÇ f (Set.Iio 0 √ó‚ÑÇ Set.Iio 0) ‚Üí\n    (‚àÉ c,\n        c < 2 ‚àß\n          ‚àÉ B,\n            f =O[Filter.comap (‚ÜëComplex.abs) Filter.atTop ‚äì Filter.principal (Set.Iio 0 √ó‚ÑÇ Set.Iio 0)] fun z =>\n              rexp (B * ‚ÜëComplex.abs z ^ c)) ‚Üí\n      (‚àÄ (x : ‚Ñù), x ‚â§ 0 ‚Üí f ‚Üëx = 0) ‚Üí\n        (‚àÄ (x : ‚Ñù), x ‚â§ 0 ‚Üí f (‚Üëx * Complex.I) = 0) ‚Üí Set.EqOn f 0 {z | z.re ‚â§ 0 ‚àß z.im ‚â§ 0}",
    "name": "PhragmenLindelof.eq_zero_on_quadrant_III",
    "doc":
    "**Phragmen-Lindel√∂f principle** in the third quadrant. Let `f : ‚ÑÇ ‚Üí E` be a function such that\n\n* `f` is differentiable in the open third quadrant and is continuous on its closure;\n* `‚Äñf z‚Äñ` is bounded from above by `A * exp(B * (abs z) ^ c)` on the open third quadrant\n  for some `A`, `B`, and `c < 2`;\n* `f` is equal to zero on the boundary of the third quadrant.\n\nThen `f` is equal to zero on the closed third quadrant. ",
    "depth": 31},
   {"term":
    "‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚ÑÇ E] {f : ‚ÑÇ ‚Üí E},\n  DiffContOnCl ‚ÑÇ f (Set.Ioi 0 √ó‚ÑÇ Set.Ioi 0) ‚Üí\n    (‚àÉ c,\n        c < 2 ‚àß\n          ‚àÉ B,\n            f =O[Filter.comap (‚ÜëComplex.abs) Filter.atTop ‚äì Filter.principal (Set.Ioi 0 √ó‚ÑÇ Set.Ioi 0)] fun z =>\n              rexp (B * ‚ÜëComplex.abs z ^ c)) ‚Üí\n      (‚àÄ (x : ‚Ñù), 0 ‚â§ x ‚Üí f ‚Üëx = 0) ‚Üí\n        (‚àÄ (x : ‚Ñù), 0 ‚â§ x ‚Üí f (‚Üëx * Complex.I) = 0) ‚Üí Set.EqOn f 0 {z | 0 ‚â§ z.re ‚àß 0 ‚â§ z.im}",
    "name": "PhragmenLindelof.eq_zero_on_quadrant_I",
    "doc":
    "**Phragmen-Lindel√∂f principle** in the first quadrant. Let `f : ‚ÑÇ ‚Üí E` be a function such that\n\n* `f` is differentiable in the open first quadrant and is continuous on its closure;\n* `‚Äñf z‚Äñ` is bounded from above by `A * exp(B * (abs z) ^ c)` on the open first quadrant\n  for some `A`, `B`, and `c < 2`;\n* `f` is equal to zero on the boundary of the first quadrant.\n\nThen `f` is equal to zero on the closed first quadrant. ",
    "depth": 31},
   {"term":
    "‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚ÑÇ E] {f : ‚ÑÇ ‚Üí E},\n  DiffContOnCl ‚ÑÇ f (Set.Iio 0 √ó‚ÑÇ Set.Ioi 0) ‚Üí\n    (‚àÉ c,\n        c < 2 ‚àß\n          ‚àÉ B,\n            f =O[Filter.comap (‚ÜëComplex.abs) Filter.atTop ‚äì Filter.principal (Set.Iio 0 √ó‚ÑÇ Set.Ioi 0)] fun z =>\n              rexp (B * ‚ÜëComplex.abs z ^ c)) ‚Üí\n      (‚àÄ (x : ‚Ñù), x ‚â§ 0 ‚Üí f ‚Üëx = 0) ‚Üí\n        (‚àÄ (x : ‚Ñù), 0 ‚â§ x ‚Üí f (‚Üëx * Complex.I) = 0) ‚Üí Set.EqOn f 0 {z | z.re ‚â§ 0 ‚àß 0 ‚â§ z.im}",
    "name": "PhragmenLindelof.eq_zero_on_quadrant_II",
    "doc":
    "**Phragmen-Lindel√∂f principle** in the second quadrant. Let `f : ‚ÑÇ ‚Üí E` be a function such that\n\n* `f` is differentiable in the open second quadrant and is continuous on its closure;\n* `‚Äñf z‚Äñ` is bounded from above by `A * exp(B * (abs z) ^ c)` on the open second quadrant\n  for some `A`, `B`, and `c < 2`;\n* `f` is equal to zero on the boundary of the second quadrant.\n\nThen `f` is equal to zero on the closed second quadrant. ",
    "depth": 31}],
  "count": 22},
 {"noDocExamples":
  [{"term":
    "‚àÄ {C : Type u} {X Y X' Y' : C} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.MonoidalCategory C]\n  (f : X ‚âÖ Y) (g : X' ‚âÖ Y'), (f ‚äó g).inv = CategoryTheory.MonoidalCategory.tensorHom f.inv g.inv",
    "name": "CategoryTheory.tensorIso_inv",
    "depth": 21},
   {"term":
    "‚àÄ {C : Type u} {X Y X' Y' : C} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.MonoidalCategory C]\n  (f : X ‚âÖ Y) (g : X' ‚âÖ Y'), (f ‚äó g).hom = CategoryTheory.MonoidalCategory.tensorHom f.hom g.hom",
    "name": "CategoryTheory.tensorIso_hom",
    "depth": 21},
   {"term":
    "‚àÄ {C : Type u_1} [inst : CategoryTheory.Category.{u_2, u_1} C] [inst_1 : CategoryTheory.MonoidalCategory C]\n  {W X Y Z : C} (f : W ‚ü∂ X) [inst_2 : CategoryTheory.IsIso f] (g : Y ‚ü∂ Z) [inst_3 : CategoryTheory.IsIso g],\n  CategoryTheory.IsIso (CategoryTheory.asIso f ‚äó CategoryTheory.asIso g).hom",
    "name": "CategoryTheory.MonoidalCategory.tensor_isIso.proof_1",
    "depth": 22},
   {"term":
    "‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] [inst_1 : CategoryTheory.MonoidalCategory C]\n  (X Y : CategoryTheory.Center C) (U : C),\n  CategoryTheory.HalfBraiding.Œ≤ (CategoryTheory.MonoidalCategory.tensorObj X Y).snd U =\n    CategoryTheory.MonoidalCategory.associator X.fst Y.fst U ‚â™‚â´\n      (CategoryTheory.Iso.refl X.fst ‚äó CategoryTheory.HalfBraiding.Œ≤ Y.snd U) ‚â™‚â´\n        (CategoryTheory.MonoidalCategory.associator X.fst U Y.fst).symm ‚â™‚â´\n          (CategoryTheory.HalfBraiding.Œ≤ X.snd U ‚äó CategoryTheory.Iso.refl Y.fst) ‚â™‚â´\n            CategoryTheory.MonoidalCategory.associator U X.fst Y.fst",
    "name": "CategoryTheory.Center.tensor_Œ≤",
    "depth": 29},
   {"term":
    "‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] [inst_1 : CategoryTheory.MonoidalCategory C]\n  (X Y : CategoryTheory.Center C) (U : C),\n  CategoryTheory.HalfBraiding.Œ≤ (CategoryTheory.Center.tensorObj X Y).snd U =\n    CategoryTheory.MonoidalCategory.associator X.fst Y.fst U ‚â™‚â´\n      (CategoryTheory.Iso.refl X.fst ‚äó CategoryTheory.HalfBraiding.Œ≤ Y.snd U) ‚â™‚â´\n        (CategoryTheory.MonoidalCategory.associator X.fst U Y.fst).symm ‚â™‚â´\n          (CategoryTheory.HalfBraiding.Œ≤ X.snd U ‚äó CategoryTheory.Iso.refl Y.fst) ‚â™‚â´\n            CategoryTheory.MonoidalCategory.associator U X.fst Y.fst",
    "name": "CategoryTheory.Center.tensorObj_snd_Œ≤",
    "depth": 29}],
  "kind": "CategoryTheory.¬´term_‚äó_¬ª",
  "examples": [],
  "count": 21},
 {"noDocExamples": [],
  "kind": "MeasureTheory.¬´term‚àÄ·µê_,_¬ª",
  "examples":
  [{"term":
    "‚àÄ (f : StieltjesFunction),\n  ‚àÄ·µê (x : ‚Ñù),\n    HasDerivAt (‚Üëf)\n      (ENNReal.toReal (MeasureTheory.Measure.rnDeriv (StieltjesFunction.measure f) MeasureTheory.volume x)) x",
    "name": "StieltjesFunction.ae_hasDerivAt",
    "doc":
    "A Stieltjes function is almost everywhere differentiable, with derivative equal to the\nRadon-Nikodym derivative of the associated Stieltjes measure with respect to Lebesgue. ",
    "depth": 13},
   {"term":
    "‚àÄ {f : ‚Ñù ‚Üí ‚Ñù} (hf : Monotone f),\n  ‚àÄ·µê (x : ‚Ñù),\n    HasDerivAt f\n      (ENNReal.toReal\n        (MeasureTheory.Measure.rnDeriv (StieltjesFunction.measure (Monotone.stieltjesFunction hf)) MeasureTheory.volume\n          x))\n      x",
    "name": "Monotone.ae_hasDerivAt",
    "doc":
    "A monotone function is almost everywhere differentiable, with derivative equal to the\nRadon-Nikodym derivative of the associated Stieltjes measure with respect to Lebesgue. ",
    "depth": 14},
   {"term": "‚àÄ {f : ‚Ñù ‚Üí ‚Ñù}, Monotone f ‚Üí ‚àÄ·µê (x : ‚Ñù), DifferentiableAt ‚Ñù f x",
    "name": "Monotone.ae_differentiableAt",
    "doc":
    "A monotone real function is differentiable Lebesgue-almost everywhere. ",
    "depth": 16},
   {"term":
    "‚àÄ {f : ‚Ñù ‚Üí ‚Ñù} {s : Set ‚Ñù}, MonotoneOn f s ‚Üí ‚àÄ·µê (x : ‚Ñù), x ‚àà s ‚Üí DifferentiableWithinAt ‚Ñù f s x",
    "name": "MonotoneOn.ae_differentiableWithinAt_of_mem",
    "doc":
    "A real function which is monotone on a set is differentiable Lebesgue-almost everywhere on\nthis set. This version does not assume that `s` is measurable. For a formulation with\n`volume.restrict s` assuming that `s` is measurable, see `MonotoneOn.ae_differentiableWithinAt`.\n",
    "depth": 19},
   {"term":
    "‚àÄ {f : ‚Ñù ‚Üí ‚Ñù} {s : Set ‚Ñù}, LocallyBoundedVariationOn f s ‚Üí ‚àÄ·µê (x : ‚Ñù), x ‚àà s ‚Üí DifferentiableWithinAt ‚Ñù f s x",
    "name": "LocallyBoundedVariationOn.ae_differentiableWithinAt_of_mem_real",
    "doc":
    "A bounded variation function into `‚Ñù` is differentiable almost everywhere. Superseded by\n`ae_differentiableWithinAt_of_mem`. ",
    "depth": 19}],
  "count": 21},
 {"noDocExamples": [],
  "kind": "MeasureTheory.¬´term‚®ç‚Åª_,_‚àÇ_¬ª",
  "examples":
  [{"term":
    "‚àÄ {Œ± : Type u_1} {m0 : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {f : Œ± ‚Üí ENNReal},\n  Œº ‚â† 0 ‚Üí ‚à´‚Åª (a : Œ±), f a ‚àÇŒº ‚â† ‚ä§ ‚Üí ‚àÉ x, ‚®ç‚Åª (a : Œ±), f a ‚àÇŒº ‚â§ f x",
    "name": "MeasureTheory.exists_laverage_le",
    "doc":
    "**First moment method**. The maximum of a measurable function is greater than its mean. ",
    "depth": 18},
   {"term":
    "‚àÄ {Œ± : Type u_1} {m0 : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {f : Œ± ‚Üí ENNReal}\n  [inst : MeasureTheory.IsFiniteMeasure Œº], Œº ‚â† 0 ‚Üí AEMeasurable f ‚Üí ‚àÉ x, f x ‚â§ ‚®ç‚Åª (a : Œ±), f a ‚àÇŒº",
    "name": "MeasureTheory.exists_le_laverage",
    "doc":
    "**First moment method**. The minimum of a measurable function is smaller than its mean. ",
    "depth": 19},
   {"term":
    "‚àÄ {Œ± : Type u_1} {m0 : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {f : Œ± ‚Üí ENNReal},\n  Œº ‚â† 0 ‚Üí ‚à´‚Åª (a : Œ±), f a ‚àÇŒº ‚â† ‚ä§ ‚Üí 0 < ‚Üë‚ÜëŒº {x | ‚®ç‚Åª (a : Œ±), f a ‚àÇŒº ‚â§ f x}",
    "name": "MeasureTheory.measure_laverage_le_pos",
    "doc":
    "**First moment method**. A measurable function is greater than its mean on a set of positive\nmeasure. ",
    "depth": 20},
   {"term":
    "‚àÄ {Œ± : Type u_1} {m0 : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {N : Set Œ±} {f : Œ± ‚Üí ENNReal},\n  Œº ‚â† 0 ‚Üí ‚à´‚Åª (a : Œ±), f a ‚àÇŒº ‚â† ‚ä§ ‚Üí ‚Üë‚ÜëŒº N = 0 ‚Üí ‚àÉ x, ¬¨x ‚àà N ‚àß ‚®ç‚Åª (a : Œ±), f a ‚àÇŒº ‚â§ f x",
    "name": "MeasureTheory.exists_not_mem_null_laverage_le",
    "doc":
    "**First moment method**. The maximum of a measurable function is greater than its mean, while\navoiding a null set. ",
    "depth": 21},
   {"term":
    "‚àÄ {Œ± : Type u_1} {m0 : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {f : Œ± ‚Üí ENNReal}\n  [inst : MeasureTheory.IsFiniteMeasure Œº], Œº ‚â† 0 ‚Üí AEMeasurable f ‚Üí 0 < ‚Üë‚ÜëŒº {x | f x ‚â§ ‚®ç‚Åª (a : Œ±), f a ‚àÇŒº}",
    "name": "MeasureTheory.measure_le_laverage_pos",
    "doc":
    "**First moment method**. A measurable function is smaller than its mean on a set of positive\nmeasure. ",
    "depth": 21}],
  "count": 20},
 {"noDocExamples":
  [{"term":
    "‚àÄ {Œ± : Type u_1} {a : Œ±} {n : ‚Ñï}, Sym.replicate (Nat.succ n) a = a ::‚Çõ Sym.replicate n a",
    "name": "Sym.replicate_succ",
    "depth": 8},
   {"term":
    "‚àÄ {Œ± : Type u_1} {n : ‚Ñï} (a : Œ±) (v : Vector Œ± n), a ::‚Çõ Sym.ofVector v = Sym.ofVector (a ::·µ• v)",
    "name": "Sym.cons_of_coe_eq",
    "depth": 10},
   {"term": "‚àÄ {Œ± : Type u_1} {n : ‚Ñï} (a : Œ±) (s : Sym Œ± n), a ‚àà a ::‚Çõ s",
    "name": "Sym.mem_cons_self",
    "depth": 10},
   {"term":
    "‚àÄ {Œ± : Type u_1} {n : ‚Ñï} (a : Œ±) (v : Vector Œ± n), Sym.ofVector (a ::·µ• v) = a ::‚Çõ Sym.ofVector v",
    "name": "Sym.ofVector_cons",
    "depth": 11},
   {"term":
    "‚àÄ {Œ± : Type u_1} {n : ‚Ñï} (s : Sym Œ± n) (a : Œ±), ‚Üë(a ::‚Çõ s) = a ::‚Çò ‚Üës",
    "name": "Sym.coe_cons",
    "depth": 11}],
  "kind": "Sym.¬´term_::‚Çõ_¬ª",
  "examples": [],
  "count": 20},
 {"noDocExamples": [],
  "kind": "¬´term_‚ÜíL‚ãÜ[_]_¬ª",
  "examples":
  [{"term":
    "(ùïú : Type u_1) ‚Üí\n  {E : Type u_2} ‚Üí\n    [inst : IsROrC ùïú] ‚Üí [inst_1 : NormedAddCommGroup E] ‚Üí [inst_2 : InnerProductSpace ùïú E] ‚Üí E ‚ÜíL[ùïú] E ‚ÜíL‚ãÜ[ùïú] ùïú",
    "name": "innerSLFlip",
    "doc":
    "The inner product as a continuous sesquilinear map, with the two arguments flipped. ",
    "depth": 29},
   {"term":
    "(ùïú : Type u_1) ‚Üí\n  {E : Type u_2} ‚Üí\n    [inst : IsROrC ùïú] ‚Üí [inst_1 : NormedAddCommGroup E] ‚Üí [inst_2 : InnerProductSpace ùïú E] ‚Üí E ‚ÜíL‚ãÜ[ùïú] E ‚ÜíL[ùïú] ùïú",
    "name": "innerSL",
    "doc":
    "The inner product as a continuous sesquilinear map. Note that `toDualMap` (resp. `toDual`)\nin `InnerProductSpace.Dual` is a version of this given as a linear isometry (resp. linear\nisometric equivalence). ",
    "depth": 29},
   {"term":
    "{ùïú : Type u_1} ‚Üí\n  {E : Type u_2} ‚Üí\n    [inst : IsROrC ùïú] ‚Üí\n      [inst_1 : NormedAddCommGroup E] ‚Üí\n        [inst_2 : InnerProductSpace ùïú E] ‚Üí [inst_3 : CompleteSpace E] ‚Üí (E ‚ÜíL‚ãÜ[ùïú] E ‚ÜíL[ùïú] ùïú) ‚Üí E ‚ÜíL[ùïú] E",
    "name": "InnerProductSpace.continuousLinearMapOfBilin",
    "doc":
    "Maps a bounded sesquilinear form to its continuous linear map,\ngiven by interpreting the form as a map `B : E ‚ÜíL‚ãÜ[ùïú] NormedSpace.Dual ùïú E`\nand dualizing the result using `toDual`.\n",
    "depth": 31},
   {"term":
    "{ùïú : Type u_1} ‚Üí\n  {E : Type u_2} ‚Üí\n    {F : Type u_3} ‚Üí\n      [inst : IsROrC ùïú] ‚Üí\n        [inst_1 : NormedAddCommGroup E] ‚Üí\n          [inst_2 : NormedAddCommGroup F] ‚Üí\n            [inst_3 : InnerProductSpace ùïú E] ‚Üí\n              [inst_4 : InnerProductSpace ùïú F] ‚Üí [inst_5 : CompleteSpace E] ‚Üí (E ‚ÜíL[ùïú] F) ‚ÜíL‚ãÜ[ùïú] F ‚ÜíL[ùïú] E",
    "name": "ContinuousLinearMap.adjointAux",
    "doc":
    "The adjoint, as a continuous conjugate-linear map. This is only meant as an auxiliary\ndefinition for the main definition `adjoint`, where this is bundled as a conjugate-linear isometric\nequivalence. ",
    "depth": 35},
   {"term":
    "{ùïú : Type u_1} ‚Üí\n  {E : Type u_2} ‚Üí\n    [inst : IsROrC ùïú] ‚Üí\n      [inst_1 : NormedAddCommGroup E] ‚Üí\n        [inst_2 : InnerProductSpace ùïú E] ‚Üí\n          {E' : Type u_4} ‚Üí\n            [inst_3 : NormedAddCommGroup E'] ‚Üí\n              [inst_4 : InnerProductSpace ùïú E'] ‚Üí (E ‚ÜíL[ùïú] E') ‚ÜíL[ùïú] E' ‚ÜíL‚ãÜ[ùïú] E ‚ÜíL[ùïú] ùïú",
    "name": "ContinuousLinearMap.toSesqForm",
    "doc":
    "Given `f : E ‚ÜíL[ùïú] E'`, construct the continuous sesquilinear form `fun x y ‚Ü¶ ‚ü™x, A y‚ü´`, given\nas a continuous linear map. ",
    "depth": 42}],
  "count": 19},
 {"noDocExamples":
  [{"term": "‚àÄ {Œ± : Type u} {s : Set Œ±}, Set.Nonempty (ùí´ s)",
    "name": "Set.powerset_nonempty",
    "depth": 5}],
  "kind": "Set.termùí´_",
  "examples":
  [{"term": "{Œ± : Type u_1} ‚Üí (S : Set Œ±) ‚Üí ‚Üë(ùí´ S) ‚âÉ Set ‚ÜëS",
    "name": "Equiv.Set.powerset",
    "doc": "The set `ùí´ S := {x | x ‚äÜ S}` is equivalent to the type `Set S`. ",
    "depth": 7},
   {"term": "‚àÄ {Œ± : Type u} (x : Œ±), ùí´{x} = {‚àÖ, {x}}",
    "name": "Set.powerset_singleton",
    "doc":
    "The powerset of a singleton contains only `‚àÖ` and the singleton itself. ",
    "depth": 9},
   {"term":
    "‚àÄ {Œ± : Type u_1} (s : Set Œ±) (a : Œ±), ùí´ insert a s = ùí´ s ‚à™ insert a '' ùí´ s",
    "name": "Set.powerset_insert",
    "doc":
    "The powerset of `{a} ‚à™ s` is `ùí´ s` together with `{a} ‚à™ t` for each `t ‚àà ùí´ s`. ",
    "depth": 11},
   {"term":
    "‚àÄ {Œ± : Type u} (s : Set Œ±), Cardinal.mk ‚Üë(ùí´ s) = 2 ^ Cardinal.mk ‚Üës",
    "name": "Cardinal.mk_powerset",
    "doc":
    "A variant of `Cardinal.mk_set` expressed in terms of a `Set` instead of a `Type`. ",
    "depth": 11}],
  "count": 18},
 {"noDocExamples":
  [{"term":
    "‚àÄ {Œ± : Type u_1} {m0 : MeasurableSpace Œ±} (Œº : MeasureTheory.Measure Œ±) (f : Œ± ‚Üí ENNReal) (s : Set Œ±),\n  ‚®ç‚Åª (x : Œ±) in s, f x ‚àÇŒº = (‚à´‚Åª (x : Œ±) in s, f x ‚àÇŒº) / ‚Üë‚ÜëŒº s",
    "name": "MeasureTheory.setLaverage_eq",
    "depth": 14}],
  "kind": "MeasureTheory.¬´term‚®ç‚Åª_In_,_‚àÇ_¬ª",
  "examples":
  [{"term":
    "‚àÄ {Œ± : Type u_1} {m0 : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {s : Set Œ±} {f : Œ± ‚Üí ENNReal},\n  ‚Üë‚ÜëŒº s ‚â† 0 ‚Üí ‚Üë‚ÜëŒº s ‚â† ‚ä§ ‚Üí AEMeasurable f ‚Üí ‚àÉ x, x ‚àà s ‚àß f x ‚â§ ‚®ç‚Åª (a : Œ±) in s, f a ‚àÇŒº",
    "name": "MeasureTheory.exists_le_setLaverage",
    "doc":
    "**First moment method**. The minimum of a measurable function is smaller than its mean. ",
    "depth": 21},
   {"term":
    "‚àÄ {Œ± : Type u_1} {m0 : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {s : Set Œ±} {f : Œ± ‚Üí ENNReal},\n  ‚Üë‚ÜëŒº s ‚â† 0 ‚Üí\n    MeasureTheory.NullMeasurableSet s ‚Üí ‚à´‚Åª (a : Œ±) in s, f a ‚àÇŒº ‚â† ‚ä§ ‚Üí ‚àÉ x, x ‚àà s ‚àß ‚®ç‚Åª (a : Œ±) in s, f a ‚àÇŒº ‚â§ f x",
    "name": "MeasureTheory.exists_setLaverage_le",
    "doc":
    "**First moment method**. The maximum of a measurable function is greater than its mean. ",
    "depth": 21},
   {"term":
    "‚àÄ {Œ± : Type u_1} {m0 : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {s : Set Œ±} {f : Œ± ‚Üí ENNReal},\n  ‚Üë‚ÜëŒº s ‚â† 0 ‚Üí\n    MeasureTheory.NullMeasurableSet s ‚Üí\n      ‚à´‚Åª (a : Œ±) in s, f a ‚àÇŒº ‚â† ‚ä§ ‚Üí 0 < ‚Üë‚ÜëŒº {x | x ‚àà s ‚àß ‚®ç‚Åª (a : Œ±) in s, f a ‚àÇŒº ‚â§ f x}",
    "name": "MeasureTheory.measure_setLaverage_le_pos",
    "doc":
    "**First moment method**. A measurable function is greater than its mean on a set of positive\nmeasure. ",
    "depth": 23},
   {"term":
    "‚àÄ {Œ± : Type u_1} {m0 : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {s : Set Œ±} {f : Œ± ‚Üí ENNReal},\n  ‚Üë‚ÜëŒº s ‚â† 0 ‚Üí ‚Üë‚ÜëŒº s ‚â† ‚ä§ ‚Üí AEMeasurable f ‚Üí 0 < ‚Üë‚ÜëŒº {x | x ‚àà s ‚àß f x ‚â§ ‚®ç‚Åª (a : Œ±) in s, f a ‚àÇŒº}",
    "name": "MeasureTheory.measure_le_setLaverage_pos",
    "doc":
    "**First moment method**. A measurable function is smaller than its mean on a set of positive\nmeasure. ",
    "depth": 23}],
  "count": 18},
 {"noDocExamples": [],
  "kind": "CategoryTheory.¬´term_‚•§‚Çë_¬ª",
  "examples":
  [{"term":
    "(C : Type u‚ÇÅ) ‚Üí\n  [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] ‚Üí\n    (D : Type u‚ÇÇ) ‚Üí [inst_1 : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D] ‚Üí CategoryTheory.Functor (C ‚•§‚Çë D) (C ‚•§‚Çó D)",
    "name": "CategoryTheory.LeftExactFunctor.ofExact",
    "doc": "Turn an exact functor into a left exact functor. ",
    "depth": 12},
   {"term":
    "{C : Type u‚ÇÅ} ‚Üí\n  [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] ‚Üí\n    {D : Type u‚ÇÇ} ‚Üí\n      [inst_1 : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D] ‚Üí\n        (F : CategoryTheory.Functor C D) ‚Üí\n          [inst_2 : CategoryTheory.Limits.PreservesFiniteLimits F] ‚Üí\n            [inst_3 : CategoryTheory.Limits.PreservesFiniteColimits F] ‚Üí C ‚•§‚Çë D",
    "name": "CategoryTheory.ExactFunctor.of",
    "doc":
    "Turn an exact functor into an object of the category `ExactFunctor C D`. ",
    "depth": 12},
   {"term":
    "(C : Type u‚ÇÅ) ‚Üí\n  [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] ‚Üí\n    (D : Type u‚ÇÇ) ‚Üí\n      [inst_1 : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D] ‚Üí CategoryTheory.Functor (C ‚•§‚Çë D) (CategoryTheory.Functor C D)",
    "name": "CategoryTheory.ExactFunctor.forget",
    "doc": "An exact functor is in particular a functor. ",
    "depth": 12},
   {"term":
    "(C : Type u‚ÇÅ) ‚Üí\n  [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] ‚Üí\n    (D : Type u‚ÇÇ) ‚Üí [inst_1 : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D] ‚Üí CategoryTheory.Functor (C ‚•§‚Çë D) (C ‚•§·µ£ D)",
    "name": "CategoryTheory.RightExactFunctor.ofExact",
    "doc": "Turn an exact functor into a left exact functor. ",
    "depth": 12},
   {"term":
    "(C : Type u‚ÇÅ) ‚Üí\n  (D : Type u‚ÇÇ) ‚Üí\n    [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] ‚Üí\n      [inst_1 : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D] ‚Üí\n        [inst_2 : CategoryTheory.Preadditive C] ‚Üí\n          [inst_3 : CategoryTheory.Preadditive D] ‚Üí\n            [inst_4 : CategoryTheory.Limits.HasZeroObject C] ‚Üí\n              [inst_5 : CategoryTheory.Limits.HasZeroObject D] ‚Üí\n                [inst_6 : CategoryTheory.Limits.HasBinaryBiproducts C] ‚Üí CategoryTheory.Functor (C ‚•§‚Çë D) (C ‚•§+ D)",
    "name": "CategoryTheory.AdditiveFunctor.ofExact",
    "doc": "Turn an exact functor into an additive functor. ",
    "depth": 17}],
  "count": 18},
 {"noDocExamples": [],
  "kind": "¬´term_‚äá_¬ª",
  "examples":
  [{"term":
    "‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {Œπ : Type v} [hŒπ : Nonempty Œπ] (Z : Œπ ‚Üí Set Œ±),\n  Directed (fun x x_1 => x ‚äá x_1) Z ‚Üí\n    (‚àÄ (i : Œπ), Set.Nonempty (Z i)) ‚Üí\n      (‚àÄ (i : Œπ), IsCompact (Z i)) ‚Üí (‚àÄ (i : Œπ), IsClosed (Z i)) ‚Üí Set.Nonempty (‚ãÇ (i : Œπ), Z i)",
    "name": "IsCompact.nonempty_iInter_of_directed_nonempty_compact_closed",
    "doc":
    "Cantor's intersection theorem:\nthe intersection of a directed family of nonempty compact closed sets is nonempty. ",
    "depth": 15},
   {"term":
    "‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {Œπ : Type u_3} [inst_1 : Nonempty Œπ] {V : Œπ ‚Üí Set Œ±},\n  Directed (fun x x_1 => x ‚äá x_1) V ‚Üí\n    (‚àÄ (i : Œπ), IsCompact (V i)) ‚Üí\n      (‚àÄ (i : Œπ), IsClosed (V i)) ‚Üí ‚àÄ {U : Set Œ±}, (‚àÄ (x : Œ±), x ‚àà ‚ãÇ (i : Œπ), V i ‚Üí U ‚àà nhds x) ‚Üí ‚àÉ i, V i ‚äÜ U",
    "name": "exists_subset_nhds_of_isCompact'",
    "doc":
    "If `V : Œπ ‚Üí Set Œ±` is a decreasing family of closed compact sets then any neighborhood of\n`‚ãÇ i, V i` contains some `V i`. We assume each `V i` is compact *and* closed because `Œ±` is\nnot assumed to be Hausdorff. See `exists_subset_nhd_of_compact` for version assuming this. ",
    "depth": 18},
   {"term":
    "‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : T2Space Œ±] {Œπ : Type u_2} [inst_2 : Nonempty Œπ] {V : Œπ ‚Üí Set Œ±},\n  Directed (fun x x_1 => x ‚äá x_1) V ‚Üí\n    (‚àÄ (i : Œπ), IsCompact (V i)) ‚Üí ‚àÄ {U : Set Œ±}, (‚àÄ (x : Œ±), x ‚àà ‚ãÇ (i : Œπ), V i ‚Üí U ‚àà nhds x) ‚Üí ‚àÉ i, V i ‚äÜ U",
    "name": "exists_subset_nhds_of_isCompact",
    "doc":
    "If `V : Œπ ‚Üí Set Œ±` is a decreasing family of compact sets then any neighborhood of\n`‚ãÇ i, V i` contains some `V i`. This is a version of `exists_subset_nhds_of_isCompact'` where we\ndon't need to assume each `V i` closed because it follows from compactness since `Œ±` is\nassumed to be Hausdorff. ",
    "depth": 18},
   {"term":
    "‚àÄ {Œ± : Type u_1} {Œπ : Type u_5} {m : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} [inst : Countable Œπ]\n  {s : Œπ ‚Üí Set Œ±},\n  (‚àÄ (i : Œπ), MeasurableSet (s i)) ‚Üí\n    Directed (fun x x_1 => x ‚äá x_1) s ‚Üí (‚àÉ i, ‚Üë‚ÜëŒº (s i) ‚â† ‚ä§) ‚Üí ‚Üë‚ÜëŒº (‚ãÇ (i : Œπ), s i) = ‚®Ö (i : Œπ), ‚Üë‚ÜëŒº (s i)",
    "name": "MeasureTheory.measure_iInter_eq_iInf",
    "doc":
    "Continuity from above: the measure of the intersection of a decreasing sequence of measurable\nsets is the infimum of the measures. ",
    "depth": 18},
   {"term":
    "‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±} {Œπ : Type v} [hŒπ : Nonempty Œπ],\n  IsCompact s ‚Üí\n    ‚àÄ (Z : Œπ ‚Üí Set Œ±),\n      (‚àÄ (i : Œπ), IsClosed (Z i)) ‚Üí s ‚à© ‚ãÇ (i : Œπ), Z i = ‚àÖ ‚Üí Directed (fun x x_1 => x ‚äá x_1) Z ‚Üí ‚àÉ i, s ‚à© Z i = ‚àÖ",
    "name": "IsCompact.elim_directed_family_closed",
    "doc":
    "For every directed family of closed sets whose intersection avoids a compact set,\nthere exists a single element of the family which itself avoids this compact set. ",
    "depth": 19}],
  "count": 17},
 {"noDocExamples": [],
  "kind": "CategoryTheory.LaxMonoidalFunctor.¬´term_‚äó‚ãô_¬ª",
  "examples":
  [{"term":
    "{C : Type u‚ÇÅ} ‚Üí\n  [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] ‚Üí\n    [inst_1 : CategoryTheory.MonoidalCategory C] ‚Üí\n      {D : Type u‚ÇÇ} ‚Üí\n        [inst_2 : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D] ‚Üí\n          (e : C ‚âå D) ‚Üí\n            CategoryTheory.LaxMonoidalFunctor.id C ‚âÖ\n              CategoryTheory.Monoidal.laxToTransported e ‚äó‚ãô\n                (CategoryTheory.Monoidal.fromTransported e).toLaxMonoidalFunctor",
    "name": "CategoryTheory.Monoidal.transportedMonoidalUnitIso",
    "doc": "The unit isomorphism upgrades to a monoidal isomorphism. ",
    "depth": 20},
   {"term":
    "{C : Type u‚ÇÅ} ‚Üí\n  [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] ‚Üí\n    [inst_1 : CategoryTheory.MonoidalCategory C] ‚Üí\n      {D : Type u‚ÇÇ} ‚Üí\n        [inst_2 : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D] ‚Üí\n          [inst_3 : CategoryTheory.MonoidalCategory D] ‚Üí\n            (F : CategoryTheory.MonoidalFunctor C D) ‚Üí\n              [inst_4 : CategoryTheory.IsEquivalence F.toFunctor] ‚Üí\n                CategoryTheory.LaxMonoidalFunctor.id C ‚ü∂\n                  F.toLaxMonoidalFunctor ‚äó‚ãô (CategoryTheory.monoidalInverse F).toLaxMonoidalFunctor",
    "name": "CategoryTheory.monoidalUnit",
    "doc":
    "The unit of a monoidal equivalence can be upgraded to a monoidal natural transformation. ",
    "depth": 20},
   {"term":
    "{C : Type u‚ÇÅ} ‚Üí\n  [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] ‚Üí\n    [inst_1 : CategoryTheory.MonoidalCategory C] ‚Üí\n      {D : Type u‚ÇÇ} ‚Üí\n        [inst_2 : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D] ‚Üí\n          [inst_3 : CategoryTheory.MonoidalCategory D] ‚Üí\n            (F : CategoryTheory.MonoidalFunctor C D) ‚Üí\n              [inst_4 : CategoryTheory.IsEquivalence F.toFunctor] ‚Üí\n                (CategoryTheory.monoidalInverse F).toLaxMonoidalFunctor ‚äó‚ãô F.toLaxMonoidalFunctor ‚ü∂\n                  CategoryTheory.LaxMonoidalFunctor.id D",
    "name": "CategoryTheory.monoidalCounit",
    "doc":
    "The counit of a monoidal equivalence can be upgraded to a monoidal natural transformation. ",
    "depth": 21},
   {"term":
    "{C : Type u‚ÇÅ} ‚Üí\n  [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] ‚Üí\n    [inst_1 : CategoryTheory.MonoidalCategory C] ‚Üí\n      {D : Type u‚ÇÇ} ‚Üí\n        [inst_2 : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D] ‚Üí\n          (e : C ‚âå D) ‚Üí\n            (CategoryTheory.Monoidal.fromTransported e).toLaxMonoidalFunctor ‚äó‚ãô\n                CategoryTheory.Monoidal.laxToTransported e ‚âÖ\n              CategoryTheory.LaxMonoidalFunctor.id (CategoryTheory.Monoidal.Transported e)",
    "name": "CategoryTheory.Monoidal.transportedMonoidalCounitIso",
    "doc": "The counit isomorphism upgrades to a monoidal isomorphism. ",
    "depth": 24},
   {"term":
    "{C : Type u‚ÇÅ} ‚Üí\n  [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] ‚Üí\n    [inst_1 : CategoryTheory.MonoidalCategory C] ‚Üí\n      {D : Type u‚ÇÇ} ‚Üí\n        [inst_2 : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D] ‚Üí\n          [inst_3 : CategoryTheory.MonoidalCategory D] ‚Üí\n            {E : Type u‚ÇÉ} ‚Üí\n              [inst_4 : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E] ‚Üí\n                [inst_5 : CategoryTheory.MonoidalCategory E] ‚Üí\n                  {F G : CategoryTheory.LaxMonoidalFunctor C D} ‚Üí\n                    {H K : CategoryTheory.LaxMonoidalFunctor D E} ‚Üí\n                      CategoryTheory.MonoidalNatTrans F G ‚Üí\n                        CategoryTheory.MonoidalNatTrans H K ‚Üí CategoryTheory.MonoidalNatTrans (F ‚äó‚ãô H) (G ‚äó‚ãô K)",
    "name": "CategoryTheory.MonoidalNatTrans.hcomp",
    "doc": "Horizontal composition of monoidal natural transformations. ",
    "depth": 28}],
  "count": 17},
 {"noDocExamples":
  [{"term":
    "{C : Type u‚ÇÅ} ‚Üí\n  [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] ‚Üí\n    [inst_1 : CategoryTheory.MonoidalCategory C] ‚Üí\n      {X : C} ‚Üí [inst_2 : CategoryTheory.HasLeftDual X] ‚Üí CategoryTheory.HasRightDual ·òÅX",
    "name": "CategoryTheory.hasRightDualLeftDual",
    "depth": 11},
   {"term":
    "{C : Type u‚ÇÅ} ‚Üí\n  [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] ‚Üí\n    [inst_1 : CategoryTheory.MonoidalCategory C] ‚Üí\n      {Y : C} ‚Üí [self : CategoryTheory.HasLeftDual Y] ‚Üí CategoryTheory.ExactPairing (·òÅY) Y",
    "name": "CategoryTheory.HasLeftDual.exact",
    "depth": 12},
   {"term":
    "‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] [inst_1 : CategoryTheory.MonoidalCategory C] {X : C}\n  [inst_2 : CategoryTheory.HasLeftDual X], (·òÅX)·òÅ = X",
    "name": "CategoryTheory.rightDual_leftDual",
    "depth": 14},
   {"term":
    "‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] [inst_1 : CategoryTheory.MonoidalCategory C] {X : C}\n  [inst_2 : CategoryTheory.HasRightDual X], ·òÅX·òÅ = X",
    "name": "CategoryTheory.leftDual_rightDual",
    "depth": 14}],
  "kind": "CategoryTheory.¬´term·òÅ_¬ª",
  "examples":
  [{"term":
    "{C : Type u‚ÇÅ} ‚Üí\n  [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] ‚Üí\n    [inst_1 : CategoryTheory.MonoidalCategory C] ‚Üí\n      {X Y : C} ‚Üí\n        [inst_2 : CategoryTheory.HasLeftDual X] ‚Üí [inst_3 : CategoryTheory.HasLeftDual Y] ‚Üí (X ‚ü∂ Y) ‚Üí (·òÅY ‚ü∂ ·òÅX)",
    "name": "CategoryTheory.leftAdjointMate",
    "doc": "The left adjoint mate `·òÅf : ·òÅY ‚ü∂ ·òÅX` of a morphism `f : X ‚ü∂ Y`. ",
    "depth": 15}],
  "count": 16},
 {"noDocExamples": [],
  "kind": "¬´term#[_,]¬ª",
  "examples":
  [{"term":
    "Lean.Name ‚Üí\n  List (Bool √ó Lean.Expr) ‚Üí\n    optParam (Array Lean.Expr) #[] ‚Üí optParam (Array Lean.Expr) #[] ‚Üí Lean.Elab.TermElabM Lean.Expr",
    "name": "Mathlib.Deriving.Traversable.traverseConstructor.mkFunCtor",
    "doc":
    "`mkFunCtor ctor [(true, (arg‚ÇÅ : m type‚ÇÅ)), (false, (arg‚ÇÇ : type‚ÇÇ)), (true, (arg‚ÇÉ : m type‚ÇÉ)),\n(false, (arg‚ÇÑ : type‚ÇÑ))]` makes `fun (x‚ÇÅ : type‚ÇÅ) (x‚ÇÉ : type‚ÇÉ) => ctor x‚ÇÅ arg‚ÇÇ x‚ÇÉ arg‚ÇÑ`. ",
    "depth": 7},
   {"term":
    "Lean.Expr ‚Üí Lean.Meta.FunInfo ‚Üí optParam Bool false ‚Üí optParam (Array Bool) #[] ‚Üí Lean.MetaM (Lean.Expr √ó Lean.Expr)",
    "name": "Congr!.mkHCongrThm",
    "doc":
    "Create a congruence lemma to prove that `HEq (f a‚ÇÅ ... a‚Çô) (f' a‚ÇÅ' ... a‚Çô')`.\nEach argument produces a `HEq a·µ¢ a·µ¢'` hypothesis, but we also supply these hypotheses the\nhypotheses that the preceding equalities have been proved (unlike in `mkHCongrWithArity`).\nThe first two arguments of the resulting theorem are for `f` and `f'`, followed by a proof\nof `f = f'`.\n\nWhen including hypotheses about previous hypotheses, we make use of dependency information\nand only include relevant equalities.\n\nThe argument `fty` denotes the type of `f`. Returns `(congrThmType, congrThmProof)`.\n\nFor the purpose of generating nicer lemmas that have a better chance at something like\n`to_additive` rewriting, this function supports generating lemmas where certain parameters\nare meant to be fixed.\n\n* If `fixedFun` is `false` (the default) then the lemma starts with three arguments for `f`, `f'`,\nand `h : f = f'`. Otherwise, if `fixedFun` is `true` then the lemma starts with just `f`.\n\n* If the `fixedParams` argument has `true` for a particular argument index, then this is a hint\nthat the congruence lemma may use the same parameter for both sides of the equality. There is\nno guarantee -- it respects it if the types are equal for that parameter (i.e., if the parameter\ndoes not depend on non-fixed parameters).\n",
    "depth": 7},
   {"term":
    "Lean.Syntax ‚Üí\n  Lean.Name ‚Üí\n    optParam Bool false ‚Üí\n      optParam (Array Simps.ProjectionRule) #[] ‚Üí\n        optParam Bool false ‚Üí Lean.CoreM (List Lean.Name √ó Array Simps.ProjectionData)",
    "name": "Simps.getRawProjections",
    "doc":
    "Get the projections used by `simps` associated to a given structure `str`.\n\nThe returned information is also stored in the environment extension `Simps.structureExt`, which\nis given to `str`. If `str` already has this attribute, the information is read from this\nextension instead. See the documentation for this extension for the data this tactic returns.\n\nThe returned universe levels are the universe levels of the structure. For the projections there\nare three cases\n* If the declaration `{StructureName}.Simps.{projectionName}` has been declared, then the value\n  of this declaration is used (after checking that it is definitionally equal to the actual\n  projection. If you rename the projection name, the declaration should have the *new* projection\n  name.\n* You can also declare a custom projection that is a composite of multiple projections.\n* Otherwise, for every class with the `notation_class` attribute, and the structure has an\n  instance of that notation class, then the projection of that notation class is used for the\n  projection that is definitionally equal to it (if there is such a projection).\n  This means in practice that coercions to function types and sorts will be used instead of\n  a projection, if this coercion is definitionally equal to a projection. Furthermore, for\n  notation classes like `Mul` and `Zero` those projections are used instead of the\n  corresponding projection.\n  Projections for coercions and notation classes are not automatically generated if they are\n  composites of multiple projections (for example when you use `extend` without the\n  `oldStructureCmd` (does this exist?)).\n* Otherwise, the projection of the structure is chosen.\n  For example: ``getRawProjections env `Prod`` gives the default projections.\n```\n  ([u, v], [(`fst, `(Prod.fst.{u v}), [0], true, false),\n     (`snd, `(@Prod.snd.{u v}), [1], true, false)])\n```\n\nOptionally, this command accepts three optional arguments:\n* If `traceIfExists` the command will always generate a trace message when the structure already\n  has an entry in `structureExt`.\n* The `rules` argument specifies whether projections should be added, renamed, used as prefix, and\n  not used by default.\n* if `trc` is true, this tactic will trace information just as if\n  `set_option trace.simps.verbose true` was set.\n",
    "depth": 9},
   {"term":
    "Lean.MVarId ‚Üí\n  Lean.Meta.Simp.Context ‚Üí\n    optParam (Option Lean.Meta.Simp.Discharge) none ‚Üí\n      optParam Bool true ‚Üí\n        optParam (Array Lean.FVarId) #[] ‚Üí\n          optParam Lean.Meta.Simp.UsedSimps ‚àÖ ‚Üí\n            Lean.MetaM (Option (Array Lean.FVarId √ó Lean.MVarId) √ó Lean.Meta.Simp.UsedSimps)",
    "name": "Mathlib.Deriving.Traversable.simpFunctorGoal",
    "doc": "Simplify the goal `m` using `functor_norm`. ",
    "depth": 13},
   {"term":
    "Lean.Name ‚Üí\n  (Lean.MVarId ‚Üí Lean.Elab.TermElabM Unit) ‚Üí\n    optParam (List Lean.Elab.DerivingHandlerNoArgs) [] ‚Üí\n      (optParam (Lean.Name ‚Üí Lean.Expr ‚Üí Lean.Elab.TermElabM Lean.Expr) fun n arg =>\n          liftM (Lean.Meta.mkAppM n #[arg])) ‚Üí\n        Lean.Elab.DerivingHandlerNoArgs",
    "name": "Mathlib.Deriving.Traversable.higherOrderDeriveHandler",
    "doc": "Make the new deriving handler depends on other deriving handlers. ",
    "depth": 20}],
  "count": 16},
 {"noDocExamples":
  [{"term":
    "{C : Type u‚ÇÅ} ‚Üí\n  [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] ‚Üí\n    [inst_1 : CategoryTheory.MonoidalCategory C] ‚Üí\n      {X : C} ‚Üí [inst_2 : CategoryTheory.HasRightDual X] ‚Üí CategoryTheory.HasLeftDual X·òÅ",
    "name": "CategoryTheory.hasLeftDualRightDual",
    "depth": 11},
   {"term":
    "{C : Type u‚ÇÅ} ‚Üí\n  [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] ‚Üí\n    [inst_1 : CategoryTheory.MonoidalCategory C] ‚Üí\n      {X : C} ‚Üí [self : CategoryTheory.HasRightDual X] ‚Üí CategoryTheory.ExactPairing X X·òÅ",
    "name": "CategoryTheory.HasRightDual.exact",
    "depth": 11},
   {"term":
    "‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] [inst_1 : CategoryTheory.MonoidalCategory C] {X : C}\n  [inst_2 : CategoryTheory.HasLeftDual X], (·òÅX)·òÅ = X",
    "name": "CategoryTheory.rightDual_leftDual",
    "depth": 14},
   {"term":
    "‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] [inst_1 : CategoryTheory.MonoidalCategory C] {X : C}\n  [inst_2 : CategoryTheory.HasRightDual X], ·òÅX·òÅ = X",
    "name": "CategoryTheory.leftDual_rightDual",
    "depth": 14}],
  "kind": "CategoryTheory.¬´term_·òÅ¬ª",
  "examples":
  [{"term":
    "{C : Type u‚ÇÅ} ‚Üí\n  [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] ‚Üí\n    [inst_1 : CategoryTheory.MonoidalCategory C] ‚Üí\n      {X Y : C} ‚Üí\n        [inst_2 : CategoryTheory.HasRightDual X] ‚Üí [inst_3 : CategoryTheory.HasRightDual Y] ‚Üí (X ‚ü∂ Y) ‚Üí (Y·òÅ ‚ü∂ X·òÅ)",
    "name": "CategoryTheory.rightAdjointMate",
    "doc": "The right adjoint mate `f·òÅ : X·òÅ ‚ü∂ Y·òÅ` of a morphism `f : X ‚ü∂ Y`. ",
    "depth": 15}],
  "count": 16},
 {"noDocExamples":
  [{"term":
    "‚àÄ {B : Type u_1} {E : B ‚Üí Type u_3} {B' : Type u_4} {f : B' ‚Üí B} {x : B'} [inst : Nonempty (E (f x))],\n  Nonempty ((f *·µñ E) x)",
    "name": "Bundle.instNonemptyPullback",
    "depth": 12}],
  "kind": "Bundle.¬´term_*·µñ_¬ª",
  "examples":
  [{"term":
    "{B : Type u_1} ‚Üí\n  {F : Type u_2} ‚Üí\n    {E : B ‚Üí Type u_3} ‚Üí {B' : Type u_4} ‚Üí (f : B' ‚Üí B) ‚Üí Bundle.TotalSpace F (f *·µñ E) ‚Üí B' √ó Bundle.TotalSpace F E",
    "name": "Bundle.pullbackTotalSpaceEmbedding",
    "doc":
    "Natural embedding of the total space of `f *·µñ E` into `B' √ó TotalSpace F E`. ",
    "depth": 11},
   {"term":
    "{B : Type u_1} ‚Üí\n  {F : Type u_2} ‚Üí\n    {E : B ‚Üí Type u_3} ‚Üí {B' : Type u_4} ‚Üí (f : B' ‚Üí B) ‚Üí Bundle.TotalSpace F (f *·µñ E) ‚Üí Bundle.TotalSpace F E",
    "name": "Bundle.Pullback.lift",
    "doc":
    "The base map `f : B' ‚Üí B` lifts to a canonical map on the total spaces. ",
    "depth": 11},
   {"term":
    "{B : Type u} ‚Üí\n  (F : Type v) ‚Üí\n    (E : B ‚Üí Type w‚ÇÅ) ‚Üí\n      {B' : Type w‚ÇÇ} ‚Üí\n        (f : B' ‚Üí B) ‚Üí\n          [inst : TopologicalSpace B'] ‚Üí\n            [inst : TopologicalSpace (Bundle.TotalSpace F E)] ‚Üí TopologicalSpace (Bundle.TotalSpace F (f *·µñ E))",
    "name": "Pullback.TotalSpace.topologicalSpace",
    "doc":
    "The topology on the total space of a pullback bundle is the coarsest topology for which both\nthe projections to the base and the map to the original bundle are continuous. ",
    "depth": 13},
   {"term":
    "{B : Type u_1} ‚Üí\n  (F : Type u_2) ‚Üí\n    (E : B ‚Üí Type u_3) ‚Üí\n      {B' : Type u_4} ‚Üí\n        (f : B' ‚Üí B) ‚Üí\n          [inst : TopologicalSpace B'] ‚Üí\n            [inst : TopologicalSpace (Bundle.TotalSpace F E)] ‚Üí TopologicalSpace (Bundle.TotalSpace F (f *·µñ E))",
    "name": "pullbackTopology",
    "doc":
    "Definition of `Pullback.TotalSpace.topologicalSpace`, which we make irreducible. ",
    "depth": 13}],
  "count": 16},
 {"noDocExamples":
  [{"term":
    "‚àÄ {L : FirstOrder.Language} {T : FirstOrder.Language.Theory L} {œÜ : FirstOrder.Language.Sentence L}, œÜ ‚àà T ‚Üí T ‚ä®·µá œÜ",
    "name": "FirstOrder.Language.Theory.models_sentence_of_mem",
    "depth": 10},
   {"term":
    "‚àÄ {L : FirstOrder.Language} {T : FirstOrder.Language.Theory L},\n  FirstOrder.Language.Theory.IsMaximal T ‚Üí ‚àÄ {œÜ : FirstOrder.Language.Sentence L}, T ‚ä®·µá œÜ ‚Üí œÜ ‚àà T",
    "name": "FirstOrder.Language.Theory.IsMaximal.mem_of_models",
    "depth": 11},
   {"term":
    "‚àÄ {L : FirstOrder.Language} {T : FirstOrder.Language.Theory L} {œÜ : FirstOrder.Language.Sentence L},\n  T ‚ä®·µá œÜ ‚Üî ‚àÄ (M : FirstOrder.Language.Theory.ModelType T), ‚ÜëM ‚ä® œÜ",
    "name": "FirstOrder.Language.Theory.models_sentence_iff",
    "depth": 11},
   {"term":
    "‚àÄ {L : FirstOrder.Language} {T : FirstOrder.Language.Theory L},\n  FirstOrder.Language.Theory.IsComplete T ‚Üí\n    ‚àÄ (œÜ : FirstOrder.Language.Sentence L), T ‚ä®·µá FirstOrder.Language.Formula.not œÜ ‚Üî ¬¨T ‚ä®·µá œÜ",
    "name": "FirstOrder.Language.Theory.IsComplete.models_not_iff",
    "depth": 11}],
  "kind": "FirstOrder.Language.Theory.¬´term_‚ä®·µá_¬ª",
  "examples":
  [{"term":
    "‚àÄ {L : FirstOrder.Language} {T : FirstOrder.Language.Theory L} {œÜ : FirstOrder.Language.Sentence L},\n  T ‚ä®·µá œÜ ‚Üî ‚àÉ T0, ‚ÜëT0 ‚äÜ T ‚àß ‚ÜëT0 ‚ä®·µá œÜ",
    "name": "FirstOrder.Language.Theory.models_iff_finset_models",
    "doc":
    "An alternative statement of the Compactness Theorem. A formula `œÜ` is modeled by a\ntheory iff there is a finite subset `T0` of the theory such that `œÜ` is modeled by `T0` ",
    "depth": 14}],
  "count": 14},
 {"noDocExamples":
  [{"term": "‚àÄ (m : ‚Ñï), m <<< 0 = m", "name": "Nat.shiftLeft_zero", "depth": 9},
   {"term": "‚àÄ (n : ‚Ñï), 0 <<< n = 0", "name": "Nat.zero_shiftLeft", "depth": 9},
   {"term": "‚àÄ (n : ‚Ñï), 1 <<< n = 2 ^ n",
    "name": "Nat.one_shiftLeft",
    "depth": 9},
   {"term": "‚àÄ {m : ‚Ñï} (n : ‚Ñï), Nat.shiftLeft' false m n = m <<< n",
    "name": "Nat.shiftLeft'_false",
    "depth": 9}],
  "kind": "¬´term_<<<_¬ª",
  "examples":
  [{"term": "‚àÄ (m n : ‚Ñï), Nat.shiftLeft m n = m <<< n",
    "name": "Nat.shiftLeft_eq'",
    "doc":
    "Std4 takes the unprimed name for `Nat.shiftLeft_eq m n : m <<< n = m * 2 ^ n`. ",
    "depth": 9}],
  "count": 14},
 {"noDocExamples":
  [{"term": "‚àÄ {Œ± : Type u_1} [inst : Primcodable Œ±] (p : Œ± ‚Üí Prop), p ‚â§‚ÇÄ p",
    "name": "manyOneReducible_refl",
    "depth": 9},
   {"term":
    "‚àÄ {Œ± : Type u} [inst : Primcodable Œ±] [inst_1 : Inhabited Œ±] {p : Set Œ±}, p ‚â§‚ÇÄ toNat p",
    "name": "manyOneReducible_toNat",
    "depth": 10},
   {"term":
    "‚àÄ {Œ± : Type u} [inst : Primcodable Œ±] [inst_1 : Inhabited Œ±] {p : Set Œ±}, toNat p ‚â§‚ÇÄ p",
    "name": "toNat_manyOneReducible",
    "depth": 10},
   {"term":
    "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Primcodable Œ±] [inst_1 : Primcodable Œ≤] {p : Œ± ‚Üí Prop} {q : Œ≤ ‚Üí Prop},\n  p ‚â§‚ÇÅ q ‚Üí p ‚â§‚ÇÄ q",
    "name": "OneOneReducible.to_many_one",
    "depth": 13},
   {"term":
    "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Primcodable Œ±] [inst_1 : Primcodable Œ≤] {p : Œ± ‚Üí Prop} {q : Œ≤ ‚Üí Prop},\n  p ‚â§‚ÇÄ q ‚Üí ComputablePred q ‚Üí ComputablePred p",
    "name": "ComputablePred.computable_of_manyOneReducible",
    "depth": 13}],
  "kind": "¬´term_‚â§‚ÇÄ_¬ª",
  "examples": [],
  "count": 14},
 {"noDocExamples":
  [{"term": "‚àÄ {Œ± : Type u_1} (a : Array Œ±) (i : ‚Ñï), Array.get? a i = a[i]?",
    "name": "Array.get?_eq_getElem?",
    "depth": 15},
   {"term":
    "‚àÄ {Œ± : Type u_1} (a : Array Œ±) (i : ‚Ñï), a[i]? = List.get? a.data i",
    "name": "Array.getElem?_eq_data_get?",
    "depth": 16},
   {"term": "‚àÄ {Œ± : Type u_1} (l : List Œ±) (i : ‚Ñï), l[i]? = List.get? l i",
    "name": "List.getElem?_eq_get?",
    "depth": 16},
   {"term":
    "‚àÄ {Œ± : Type u_1} (a : Array Œ±) (x : Œ±), (Array.push a x)[Array.size a]? = some x",
    "name": "Array.get?_push_eq",
    "depth": 16},
   {"term":
    "‚àÄ {Œ± : Type u_1} (a : Array Œ±) (i : ‚Ñï) (h : i < Array.size a), a[i]? = some a[i]",
    "name": "Array.getElem?_eq_getElem",
    "depth": 17}],
  "kind": "¬´term__[_]_?¬ª",
  "examples": [],
  "count": 14},
 {"noDocExamples":
  [{"term":
    "‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] [inst_1 : CategoryTheory.MonoidalCategory C] {X : C}\n  [inst_2 : CategoryTheory.HasRightDual X], CategoryTheory.CategoryStruct.id X·òÅ = CategoryTheory.CategoryStruct.id X·òÅ",
    "name": "CategoryTheory.rightAdjointMate_id",
    "depth": 15},
   {"term":
    "‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] [inst_1 : CategoryTheory.MonoidalCategory C] {X Y : C}\n  [inst_2 : CategoryTheory.HasRightDual X] [inst_3 : CategoryTheory.HasRightDual Y] (f : X ‚ü∂ Y),\n  CategoryTheory.CategoryStruct.comp (Œ∑_ Y Y·òÅ)\n      (CategoryTheory.MonoidalCategory.tensorHom (CategoryTheory.CategoryStruct.id Y) (f·òÅ)) =\n    CategoryTheory.CategoryStruct.comp (Œ∑_ X X·òÅ)\n      (CategoryTheory.MonoidalCategory.tensorHom f (CategoryTheory.CategoryStruct.id X·òÅ))",
    "name": "CategoryTheory.coevaluation_comp_rightAdjointMate",
    "depth": 20},
   {"term":
    "‚àÄ {C : Type u_2} [inst : CategoryTheory.Category.{u_1, u_2} C] [inst_1 : CategoryTheory.MonoidalCategory C]\n  {X Y‚ÇÅ Y‚ÇÇ : C} (p‚ÇÅ : CategoryTheory.ExactPairing X Y‚ÇÅ) (p‚ÇÇ : CategoryTheory.ExactPairing X Y‚ÇÇ),\n  CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.id X·òÅ) (CategoryTheory.CategoryStruct.id X·òÅ) =\n    CategoryTheory.CategoryStruct.id Y‚ÇÇ",
    "name": "CategoryTheory.rightDualIso.proof_2",
    "depth": 21},
   {"term":
    "‚àÄ {C : Type u_2} [inst : CategoryTheory.Category.{u_1, u_2} C] [inst_1 : CategoryTheory.MonoidalCategory C]\n  {X Y‚ÇÅ Y‚ÇÇ : C} (p‚ÇÅ : CategoryTheory.ExactPairing X Y‚ÇÅ) (p‚ÇÇ : CategoryTheory.ExactPairing X Y‚ÇÇ),\n  CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.id X·òÅ) (CategoryTheory.CategoryStruct.id X·òÅ) =\n    CategoryTheory.CategoryStruct.id Y‚ÇÅ",
    "name": "CategoryTheory.rightDualIso.proof_1",
    "depth": 21}],
  "kind": "CategoryTheory.¬´term_·òÅ_1¬ª",
  "examples":
  [{"term":
    "‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] [inst_1 : CategoryTheory.MonoidalCategory C] {X Y Z : C}\n  [inst_2 : CategoryTheory.HasRightDual X] [inst_3 : CategoryTheory.HasRightDual Y]\n  [inst_4 : CategoryTheory.HasRightDual Z] {f : X ‚ü∂ Y} {g : Y ‚ü∂ Z},\n  CategoryTheory.CategoryStruct.comp f g·òÅ = CategoryTheory.CategoryStruct.comp (g·òÅ) (f·òÅ)",
    "name": "CategoryTheory.comp_rightAdjointMate",
    "doc":
    "The composition of right adjoint mates is the adjoint mate of the composition. ",
    "depth": 22}],
  "count": 13},
 {"noDocExamples":
  [{"term":
    "‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] [inst_1 : CategoryTheory.MonoidalCategory C] {X : C}\n  [inst_2 : CategoryTheory.HasLeftDual X], (·òÅCategoryTheory.CategoryStruct.id X) = CategoryTheory.CategoryStruct.id ·òÅX",
    "name": "CategoryTheory.leftAdjointMate_id",
    "depth": 15},
   {"term":
    "‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] [inst_1 : CategoryTheory.MonoidalCategory C] {X Y : C}\n  [inst_2 : CategoryTheory.HasLeftDual X] [inst_3 : CategoryTheory.HasLeftDual Y] (f : X ‚ü∂ Y),\n  CategoryTheory.CategoryStruct.comp\n      (CategoryTheory.MonoidalCategory.tensorHom (CategoryTheory.CategoryStruct.id X) (·òÅf)) (Œµ_ (·òÅX) X) =\n    CategoryTheory.CategoryStruct.comp\n      (CategoryTheory.MonoidalCategory.tensorHom f (CategoryTheory.CategoryStruct.id ·òÅY)) (Œµ_ (·òÅY) Y)",
    "name": "CategoryTheory.leftAdjointMate_comp_evaluation",
    "depth": 21},
   {"term":
    "‚àÄ {C : Type u_2} [inst : CategoryTheory.Category.{u_1, u_2} C] [inst_1 : CategoryTheory.MonoidalCategory C]\n  {X‚ÇÅ X‚ÇÇ Y : C} (p‚ÇÅ : CategoryTheory.ExactPairing X‚ÇÅ Y) (p‚ÇÇ : CategoryTheory.ExactPairing X‚ÇÇ Y),\n  CategoryTheory.CategoryStruct.comp (·òÅCategoryTheory.CategoryStruct.id Y) (·òÅCategoryTheory.CategoryStruct.id Y) =\n    CategoryTheory.CategoryStruct.id X‚ÇÅ",
    "name": "CategoryTheory.leftDualIso.proof_1",
    "depth": 21},
   {"term":
    "‚àÄ {C : Type u_2} [inst : CategoryTheory.Category.{u_1, u_2} C] [inst_1 : CategoryTheory.MonoidalCategory C]\n  {X‚ÇÅ X‚ÇÇ Y : C} (p‚ÇÅ : CategoryTheory.ExactPairing X‚ÇÅ Y) (p‚ÇÇ : CategoryTheory.ExactPairing X‚ÇÇ Y),\n  CategoryTheory.CategoryStruct.comp (·òÅCategoryTheory.CategoryStruct.id Y) (·òÅCategoryTheory.CategoryStruct.id Y) =\n    CategoryTheory.CategoryStruct.id X‚ÇÇ",
    "name": "CategoryTheory.leftDualIso.proof_2",
    "depth": 21}],
  "kind": "CategoryTheory.¬´term·òÅ__1¬ª",
  "examples":
  [{"term":
    "‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] [inst_1 : CategoryTheory.MonoidalCategory C] {X Y Z : C}\n  [inst_2 : CategoryTheory.HasLeftDual X] [inst_3 : CategoryTheory.HasLeftDual Y]\n  [inst_4 : CategoryTheory.HasLeftDual Z] {f : X ‚ü∂ Y} {g : Y ‚ü∂ Z},\n  (·òÅCategoryTheory.CategoryStruct.comp f g) = CategoryTheory.CategoryStruct.comp (·òÅg) (·òÅf)",
    "name": "CategoryTheory.comp_leftAdjointMate",
    "doc":
    "The composition of left adjoint mates is the adjoint mate of the composition. ",
    "depth": 22}],
  "count": 13},
 {"noDocExamples":
  [{"term": "‚àÄ {x : ZFSet}, ZFSet.IsTransitive x ‚Üí ZFSet.IsTransitive (‚ãÉ‚ÇÄ x)",
    "name": "ZFSet.IsTransitive.sUnion",
    "depth": 4},
   {"term": "‚àÄ (x : ZFSet), ‚Üë(‚ãÉ‚ÇÄ x) = ‚ãÉ‚ÇÄ ‚Üëx",
    "name": "Class.coe_sUnion",
    "depth": 5},
   {"term": "‚ãÉ‚ÇÄ ‚àÖ = ‚àÖ", "name": "ZFSet.sUnion_empty", "depth": 5},
   {"term": "‚àÄ {x : ZFSet}, ZFSet.IsTransitive x ‚Üî ‚ãÉ‚ÇÄ x ‚äÜ x",
    "name": "ZFSet.isTransitive_iff_sUnion_subset",
    "depth": 6}],
  "kind": "ZFSet.¬´term‚ãÉ‚ÇÄ_¬ª",
  "examples":
  [{"term": "‚àÄ {x : ZFSet}, ZFSet.IsTransitive x ‚Üí ‚ãÉ‚ÇÄ x ‚äÜ x",
    "name": "ZFSet.IsTransitive.sUnion_subset",
    "doc":
    "**Alias** of the forward direction of `ZFSet.isTransitive_iff_sUnion_subset`.",
    "depth": 6}],
  "count": 12},
 {"noDocExamples":
  [{"term": "‚àÄ (m n : ‚Ñï), Nat.shiftRight m n = m >>> n",
    "name": "Nat.shiftRight_eq",
    "depth": 9},
   {"term": "‚àÄ (n : ‚Ñï), 0 >>> n = 0",
    "name": "Nat.zero_shiftRight",
    "depth": 9},
   {"term": "‚àÄ {n : ‚Ñï}, n >>> 0 = n",
    "name": "Nat.shiftRight_zero",
    "depth": 9},
   {"term":
    "‚àÄ (m n : ‚Ñï), Int.shiftr (Int.negSucc m) ‚Üën = Int.negSucc (m >>> n)",
    "name": "Int.shiftr_negSucc",
    "depth": 10},
   {"term": "‚àÄ (m n : ‚Ñï), Int.shiftr ‚Üëm ‚Üën = ‚Üë(m >>> n)",
    "name": "Int.shiftr_coe_nat",
    "depth": 10}],
  "kind": "¬´term_>>>_¬ª",
  "examples": [],
  "count": 12},
 {"noDocExamples":
  [{"term": "‚àÄ (a : Cardinal.{u_1}), Monotone fun c => a ^< c",
    "name": "Cardinal.powerlt_mono_left",
    "depth": 6},
   {"term":
    "‚àÄ {c : Cardinal.{u_1}}, Cardinal.aleph0 ‚â§ c ‚Üí c ^< Cardinal.aleph0 = c",
    "name": "Cardinal.powerlt_aleph0",
    "depth": 6},
   {"term":
    "‚àÄ (c : Cardinal.{u_1}), c ^< Cardinal.aleph0 ‚â§ max c Cardinal.aleph0",
    "name": "Cardinal.powerlt_aleph0_le",
    "depth": 7},
   {"term": "‚àÄ {a : Cardinal.{u_1}}, a ^< 0 = 0",
    "name": "Cardinal.powerlt_zero",
    "depth": 7},
   {"term": "‚àÄ {a b c : Cardinal.{u_1}}, b ‚â§ c ‚Üí a ^< b ‚â§ a ^< c",
    "name": "Cardinal.powerlt_le_powerlt_left",
    "depth": 8}],
  "kind": "Cardinal.¬´term_^<_¬ª",
  "examples": [],
  "count": 11},
 {"noDocExamples":
  [{"term":
    "‚àÄ {x y : CategoryTheory.Limits.WalkingParallelFamily (ULift.{w, 0} Bool)} (h : x ‚ü∂ y),\n  CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair.functor.map h =\n    match x, y, h with\n    | x, .(x), CategoryTheory.Limits.WalkingParallelFamily.Hom.id .(x) =>\n      CategoryTheory.CategoryStruct.id\n        (CategoryTheory.Limits.WalkingParallelFamily.rec CategoryTheory.Limits.WalkingParallelPair.zero\n          CategoryTheory.Limits.WalkingParallelPair.one x)\n    | .(CategoryTheory.Limits.WalkingParallelFamily.zero), .(CategoryTheory.Limits.WalkingParallelFamily.one),\n      CategoryTheory.Limits.WalkingParallelFamily.Hom.line j =>\n      bif j.down then CategoryTheory.Limits.WalkingParallelPairHom.left\n      else CategoryTheory.Limits.WalkingParallelPairHom.right",
    "name":
    "CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair_functor_map",
    "depth": 22},
   {"term":
    "‚àÄ {X Y : CategoryTheory.Limits.WalkingParallelPair} (h : X ‚ü∂ Y),\n  CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair.inverse.map h =\n    match X, Y, h with\n    | x, .(x), CategoryTheory.Limits.WalkingParallelPairHom.id .(x) =>\n      CategoryTheory.CategoryStruct.id\n        (match x with\n        | CategoryTheory.Limits.WalkingParallelPair.zero => CategoryTheory.Limits.WalkingParallelFamily.zero\n        | CategoryTheory.Limits.WalkingParallelPair.one => CategoryTheory.Limits.WalkingParallelFamily.one)\n    | .(CategoryTheory.Limits.WalkingParallelPair.zero), .(CategoryTheory.Limits.WalkingParallelPair.one),\n      CategoryTheory.Limits.WalkingParallelPairHom.left =>\n      CategoryTheory.Limits.WalkingParallelFamily.Hom.line { down := true }\n    | .(CategoryTheory.Limits.WalkingParallelPair.zero), .(CategoryTheory.Limits.WalkingParallelPair.one),\n      CategoryTheory.Limits.WalkingParallelPairHom.right =>\n      CategoryTheory.Limits.WalkingParallelFamily.Hom.line { down := false }",
    "name":
    "CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair_inverse_map",
    "depth": 23},
   {"term":
    "‚àÄ {Œπ Œ± : Type u_1} (U : Œπ ‚Üí Œ±) [inst : SemilatticeInf Œ±] (X : CategoryTheory.Pairwise Œπ),\n  (match X, X, CategoryTheory.CategoryStruct.id X with\n    | .(CategoryTheory.Pairwise.single i), .(CategoryTheory.Pairwise.single i),\n      CategoryTheory.Pairwise.Hom.id_single i => CategoryTheory.CategoryStruct.id (U i)\n    | .(CategoryTheory.Pairwise.pair i j), .(CategoryTheory.Pairwise.pair i j),\n      CategoryTheory.Pairwise.Hom.id_pair i j => CategoryTheory.CategoryStruct.id (U i ‚äì U j)\n    | .(CategoryTheory.Pairwise.pair i j), .(CategoryTheory.Pairwise.single i), CategoryTheory.Pairwise.Hom.left i j =>\n      CategoryTheory.homOfLE (_ : U i ‚äì U j ‚â§ U i)\n    | .(CategoryTheory.Pairwise.pair i j), .(CategoryTheory.Pairwise.single j), CategoryTheory.Pairwise.Hom.right i j =>\n      CategoryTheory.homOfLE (_ : U i ‚äì U j ‚â§ U j)) =\n    CategoryTheory.CategoryStruct.id\n      (match X with\n      | CategoryTheory.Pairwise.single i => U i\n      | CategoryTheory.Pairwise.pair i j => U i ‚äì U j)",
    "name": "CategoryTheory.Pairwise.diagram.proof_1",
    "depth": 28},
   {"term":
    "‚àÄ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] (I : CategoryTheory.Limits.MulticospanIndex C)\n  [inst_1 : CategoryTheory.Limits.HasProduct I.left] [inst_2 : CategoryTheory.Limits.HasProduct I.right]\n  {X Y : CategoryTheory.Limits.WalkingParallelPair} (h : X ‚ü∂ Y),\n  (CategoryTheory.Limits.MulticospanIndex.parallelPairDiagram I).map h =\n    match X, Y, h with\n    | x, .(x), CategoryTheory.Limits.WalkingParallelPairHom.id .(x) =>\n      CategoryTheory.CategoryStruct.id\n        (match x with\n        | CategoryTheory.Limits.WalkingParallelPair.zero => ‚àè I.left\n        | CategoryTheory.Limits.WalkingParallelPair.one => ‚àè I.right)\n    | .(CategoryTheory.Limits.WalkingParallelPair.zero), .(CategoryTheory.Limits.WalkingParallelPair.one),\n      CategoryTheory.Limits.WalkingParallelPairHom.left => CategoryTheory.Limits.MulticospanIndex.fstPiMap I\n    | .(CategoryTheory.Limits.WalkingParallelPair.zero), .(CategoryTheory.Limits.WalkingParallelPair.one),\n      CategoryTheory.Limits.WalkingParallelPairHom.right => CategoryTheory.Limits.MulticospanIndex.sndPiMap I",
    "name": "CategoryTheory.Limits.MulticospanIndex.parallelPairDiagram_map",
    "depth": 32},
   {"term":
    "‚àÄ {Œπ Œ± : Type u_1} (U : Œπ ‚Üí Œ±) [inst : SemilatticeInf Œ±] {X Y Z : CategoryTheory.Pairwise Œπ} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z),\n  (match X, Z, CategoryTheory.CategoryStruct.comp f g with\n    | .(CategoryTheory.Pairwise.single i), .(CategoryTheory.Pairwise.single i),\n      CategoryTheory.Pairwise.Hom.id_single i => CategoryTheory.CategoryStruct.id (U i)\n    | .(CategoryTheory.Pairwise.pair i j), .(CategoryTheory.Pairwise.pair i j),\n      CategoryTheory.Pairwise.Hom.id_pair i j => CategoryTheory.CategoryStruct.id (U i ‚äì U j)\n    | .(CategoryTheory.Pairwise.pair i j), .(CategoryTheory.Pairwise.single i), CategoryTheory.Pairwise.Hom.left i j =>\n      CategoryTheory.homOfLE (_ : U i ‚äì U j ‚â§ U i)\n    | .(CategoryTheory.Pairwise.pair i j), .(CategoryTheory.Pairwise.single j), CategoryTheory.Pairwise.Hom.right i j =>\n      CategoryTheory.homOfLE (_ : U i ‚äì U j ‚â§ U j)) =\n    CategoryTheory.CategoryStruct.comp\n      (match X, Y, f with\n      | .(CategoryTheory.Pairwise.single i), .(CategoryTheory.Pairwise.single i),\n        CategoryTheory.Pairwise.Hom.id_single i => CategoryTheory.CategoryStruct.id (U i)\n      | .(CategoryTheory.Pairwise.pair i j), .(CategoryTheory.Pairwise.pair i j),\n        CategoryTheory.Pairwise.Hom.id_pair i j => CategoryTheory.CategoryStruct.id (U i ‚äì U j)\n      | .(CategoryTheory.Pairwise.pair i j), .(CategoryTheory.Pairwise.single i),\n        CategoryTheory.Pairwise.Hom.left i j => CategoryTheory.homOfLE (_ : U i ‚äì U j ‚â§ U i)\n      | .(CategoryTheory.Pairwise.pair i j), .(CategoryTheory.Pairwise.single j),\n        CategoryTheory.Pairwise.Hom.right i j => CategoryTheory.homOfLE (_ : U i ‚äì U j ‚â§ U j))\n      (match Y, Z, g with\n      | .(CategoryTheory.Pairwise.single i), .(CategoryTheory.Pairwise.single i),\n        CategoryTheory.Pairwise.Hom.id_single i => CategoryTheory.CategoryStruct.id (U i)\n      | .(CategoryTheory.Pairwise.pair i j), .(CategoryTheory.Pairwise.pair i j),\n        CategoryTheory.Pairwise.Hom.id_pair i j => CategoryTheory.CategoryStruct.id (U i ‚äì U j)\n      | .(CategoryTheory.Pairwise.pair i j), .(CategoryTheory.Pairwise.single i),\n        CategoryTheory.Pairwise.Hom.left i j => CategoryTheory.homOfLE (_ : U i ‚äì U j ‚â§ U i)\n      | .(CategoryTheory.Pairwise.pair i j), .(CategoryTheory.Pairwise.single j),\n        CategoryTheory.Pairwise.Hom.right i j => CategoryTheory.homOfLE (_ : U i ‚äì U j ‚â§ U j))",
    "name": "CategoryTheory.Pairwise.diagram.proof_2",
    "depth": 33}],
  "kind": "Lean.Parser.Term.inaccessible",
  "examples": [],
  "count": 11},
 {"noDocExamples":
  [{"term":
    "‚àÄ {n : ‚Ñï} (a : ‚ÑÇ) (f : (Fin n ‚Üí ‚ÑÇ) ‚Üí ‚ÑÇ) (c : Fin n ‚Üí ‚ÑÇ) (R : Fin n ‚Üí ‚Ñù),\n  (‚àØ (x : Fin n ‚Üí ‚ÑÇ) in T(c, R), a * f x) = a * ‚àØ (x : Fin n ‚Üí ‚ÑÇ) in T(c, R), f x",
    "name": "torusIntegral_const_mul",
    "depth": 17}],
  "kind": "¬´term‚àØ_InT(_,_),_¬ª",
  "examples":
  [{"term":
    "‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚ÑÇ E] (f : (Fin 1 ‚Üí ‚ÑÇ) ‚Üí E) (c : Fin 1 ‚Üí ‚ÑÇ)\n  (R : Fin 1 ‚Üí ‚Ñù), (‚àØ (x : Fin 1 ‚Üí ‚ÑÇ) in T(c, R), f x) = ‚àÆ (z : ‚ÑÇ) in C(c 0, R 0), f fun x => z",
    "name": "torusIntegral_dim1",
    "doc":
    "In dimension one, `torusIntegral` is the same as `circleIntegral`\n(up to the natural equivalence between `‚ÑÇ` and `Fin 1 ‚Üí ‚ÑÇ`). ",
    "depth": 18},
   {"term":
    "‚àÄ {n : ‚Ñï} {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚ÑÇ E] {f : (Fin n ‚Üí ‚ÑÇ) ‚Üí E} {c : Fin n ‚Üí ‚ÑÇ}\n  {R : Fin n ‚Üí ‚Ñù} {C : ‚Ñù},\n  (‚àÄ (Œ∏ : Fin n ‚Üí ‚Ñù), ‚Äñf (torusMap c R Œ∏)‚Äñ ‚â§ C) ‚Üí\n    ‚Äñ‚àØ (x : Fin n ‚Üí ‚ÑÇ) in T(c, R), f x‚Äñ ‚â§ ((2 * Real.pi) ^ n * Finset.prod Finset.univ fun i => |R i|) * C",
    "name": "norm_torusIntegral_le_of_norm_le_const",
    "doc":
    "If for all `Œ∏ : ‚Ñù‚Åø`, `‚Äñf (torusMap c R Œ∏)‚Äñ` is less than or equal to a constant `C : ‚Ñù`, then\n`‚Äñ‚àØ x in T(c, R), f x‚Äñ` is less than or equal to `(2 * œÄ)^n * (‚àè i, |R i|) * C`",
    "depth": 24},
   {"term":
    "‚àÄ {n : ‚Ñï} {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚ÑÇ E] [inst_2 : CompleteSpace E]\n  {f : (Fin (n + 1) ‚Üí ‚ÑÇ) ‚Üí E} {c : Fin (n + 1) ‚Üí ‚ÑÇ} {R : Fin (n + 1) ‚Üí ‚Ñù},\n  TorusIntegrable f c R ‚Üí\n    (‚àØ (x : Fin (n + 1) ‚Üí ‚ÑÇ) in T(c, R), f x) =\n      ‚àÆ (x : ‚ÑÇ) in C(c 0, R 0), ‚àØ (y : Fin n ‚Üí ‚ÑÇ) in T(c ‚àò Fin.succ, R ‚àò Fin.succ), f (Fin.cons x y)",
    "name": "torusIntegral_succ",
    "doc":
    "Recurrent formula for `torusIntegral`, see also `torusIntegral_succAbove`. ",
    "depth": 30},
   {"term":
    "‚àÄ {n : ‚Ñï} {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚ÑÇ E] [inst_2 : CompleteSpace E]\n  {f : (Fin (n + 1) ‚Üí ‚ÑÇ) ‚Üí E} {c : Fin (n + 1) ‚Üí ‚ÑÇ} {R : Fin (n + 1) ‚Üí ‚Ñù},\n  TorusIntegrable f c R ‚Üí\n    ‚àÄ (i : Fin (n + 1)),\n      (‚àØ (x : Fin (n + 1) ‚Üí ‚ÑÇ) in T(c, R), f x) =\n        ‚àÆ (x : ‚ÑÇ) in C(c i, R i),\n          ‚àØ (y : Fin n ‚Üí ‚ÑÇ) in T(c ‚àò Fin.succAbove i, R ‚àò Fin.succAbove i), f (Fin.insertNth i x y)",
    "name": "torusIntegral_succAbove",
    "doc":
    "Recurrent formula for `torusIntegral`, see also `torusIntegral_succ`. ",
    "depth": 32}],
  "count": 11},
 {"noDocExamples":
  [{"term": "‚àÄ {Œ± : Type u_1} [inst : Primcodable Œ±] (p : Œ± ‚Üí Prop), p ‚â§‚ÇÅ p",
    "name": "oneOneReducible_refl",
    "depth": 9},
   {"term":
    "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Primcodable Œ±] [inst_1 : Primcodable Œ≤] {p : Œ± ‚Üí Prop} {q : Œ≤ ‚Üí Prop},\n  p ‚â§‚ÇÅ Sum.elim p q",
    "name": "OneOneReducible.disjoin_left",
    "depth": 13},
   {"term":
    "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Primcodable Œ±] [inst_1 : Primcodable Œ≤] {p : Œ± ‚Üí Prop} {q : Œ≤ ‚Üí Prop},\n  p ‚â§‚ÇÅ q ‚Üí p ‚â§‚ÇÄ q",
    "name": "OneOneReducible.to_many_one",
    "depth": 13},
   {"term":
    "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Primcodable Œ±] [inst_1 : Primcodable Œ≤] {p : Œ± ‚Üí Prop} {q : Œ≤ ‚Üí Prop},\n  q ‚â§‚ÇÅ Sum.elim p q",
    "name": "OneOneReducible.disjoin_right",
    "depth": 13},
   {"term":
    "‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Primcodable Œ±] [inst_1 : Primcodable Œ≤] {p : Œ± ‚Üí Prop} {q : Œ≤ ‚Üí Prop},\n  p ‚â§‚ÇÅ q ‚Üí ComputablePred q ‚Üí ComputablePred p",
    "name": "ComputablePred.computable_of_oneOneReducible",
    "depth": 13}],
  "kind": "¬´term_‚â§‚ÇÅ_¬ª",
  "examples": [],
  "count": 11},
 {"noDocExamples":
  [{"term":
    "(C : Type u‚ÇÅ) ‚Üí\n  [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] ‚Üí\n    (D : Type u‚ÇÇ) ‚Üí\n      [inst_1 : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D] ‚Üí\n        CategoryTheory.Category.{max u‚ÇÅ v‚ÇÇ, max (max (max u‚ÇÇ u‚ÇÅ) v‚ÇÇ) v‚ÇÅ} (C ‚•§‚Çó D)",
    "name": "CategoryTheory.instCategoryLeftExactFunctor",
    "depth": 9}],
  "kind": "CategoryTheory.¬´term_‚•§‚Çó_¬ª",
  "examples":
  [{"term":
    "{C : Type u‚ÇÅ} ‚Üí\n  [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] ‚Üí\n    {D : Type u‚ÇÇ} ‚Üí\n      [inst_1 : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D] ‚Üí\n        (F : CategoryTheory.Functor C D) ‚Üí [inst_2 : CategoryTheory.Limits.PreservesFiniteLimits F] ‚Üí C ‚•§‚Çó D",
    "name": "CategoryTheory.LeftExactFunctor.of",
    "doc":
    "Turn a left exact functor into an object of the category `LeftExactFunctor C D`. ",
    "depth": 11},
   {"term":
    "(C : Type u‚ÇÅ) ‚Üí\n  [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] ‚Üí\n    (D : Type u‚ÇÇ) ‚Üí [inst_1 : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D] ‚Üí CategoryTheory.Functor (C ‚•§‚Çë D) (C ‚•§‚Çó D)",
    "name": "CategoryTheory.LeftExactFunctor.ofExact",
    "doc": "Turn an exact functor into a left exact functor. ",
    "depth": 12},
   {"term":
    "(C : Type u‚ÇÅ) ‚Üí\n  [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] ‚Üí\n    (D : Type u‚ÇÇ) ‚Üí\n      [inst_1 : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D] ‚Üí CategoryTheory.Functor (C ‚•§‚Çó D) (CategoryTheory.Functor C D)",
    "name": "CategoryTheory.LeftExactFunctor.forget",
    "doc": "A left exact functor is in particular a functor. ",
    "depth": 12},
   {"term":
    "(C : Type u‚ÇÅ) ‚Üí\n  (D : Type u‚ÇÇ) ‚Üí\n    [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] ‚Üí\n      [inst_1 : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D] ‚Üí\n        [inst_2 : CategoryTheory.Preadditive C] ‚Üí\n          [inst_3 : CategoryTheory.Preadditive D] ‚Üí\n            [inst_4 : CategoryTheory.Limits.HasZeroObject C] ‚Üí\n              [inst_5 : CategoryTheory.Limits.HasZeroObject D] ‚Üí\n                [inst_6 : CategoryTheory.Limits.HasBinaryBiproducts C] ‚Üí CategoryTheory.Functor (C ‚•§‚Çó D) (C ‚•§+ D)",
    "name": "CategoryTheory.AdditiveFunctor.ofLeftExact",
    "doc": "Turn a left exact functor into an additive functor. ",
    "depth": 17}],
  "count": 11},
 {"noDocExamples":
  [{"term":
    "(C : Type u‚ÇÅ) ‚Üí\n  [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] ‚Üí\n    (D : Type u‚ÇÇ) ‚Üí\n      [inst_1 : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D] ‚Üí\n        CategoryTheory.Category.{max u‚ÇÅ v‚ÇÇ, max (max (max u‚ÇÇ u‚ÇÅ) v‚ÇÇ) v‚ÇÅ} (C ‚•§·µ£ D)",
    "name": "CategoryTheory.instCategoryRightExactFunctor",
    "depth": 9}],
  "kind": "CategoryTheory.¬´term_‚•§·µ£_¬ª",
  "examples":
  [{"term":
    "{C : Type u‚ÇÅ} ‚Üí\n  [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] ‚Üí\n    {D : Type u‚ÇÇ} ‚Üí\n      [inst_1 : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D] ‚Üí\n        (F : CategoryTheory.Functor C D) ‚Üí [inst_2 : CategoryTheory.Limits.PreservesFiniteColimits F] ‚Üí C ‚•§·µ£ D",
    "name": "CategoryTheory.RightExactFunctor.of",
    "doc":
    "Turn a right exact functor into an object of the category `RightExactFunctor C D`. ",
    "depth": 11},
   {"term":
    "(C : Type u‚ÇÅ) ‚Üí\n  [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] ‚Üí\n    (D : Type u‚ÇÇ) ‚Üí\n      [inst_1 : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D] ‚Üí CategoryTheory.Functor (C ‚•§·µ£ D) (CategoryTheory.Functor C D)",
    "name": "CategoryTheory.RightExactFunctor.forget",
    "doc": "A right exact functor is in particular a functor. ",
    "depth": 12},
   {"term":
    "(C : Type u‚ÇÅ) ‚Üí\n  [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] ‚Üí\n    (D : Type u‚ÇÇ) ‚Üí [inst_1 : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D] ‚Üí CategoryTheory.Functor (C ‚•§‚Çë D) (C ‚•§·µ£ D)",
    "name": "CategoryTheory.RightExactFunctor.ofExact",
    "doc": "Turn an exact functor into a left exact functor. ",
    "depth": 12},
   {"term":
    "(C : Type u‚ÇÅ) ‚Üí\n  (D : Type u‚ÇÇ) ‚Üí\n    [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] ‚Üí\n      [inst_1 : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D] ‚Üí\n        [inst_2 : CategoryTheory.Preadditive C] ‚Üí\n          [inst_3 : CategoryTheory.Preadditive D] ‚Üí\n            [inst_4 : CategoryTheory.Limits.HasZeroObject C] ‚Üí\n              [inst_5 : CategoryTheory.Limits.HasZeroObject D] ‚Üí\n                [inst_6 : CategoryTheory.Limits.HasBinaryBiproducts C] ‚Üí CategoryTheory.Functor (C ‚•§·µ£ D) (C ‚•§+ D)",
    "name": "CategoryTheory.AdditiveFunctor.ofRightExact",
    "doc": "Turn a right exact functor into an additive functor. ",
    "depth": 17}],
  "count": 11},
 {"noDocExamples":
  [{"term":
    "‚àÄ {U : Type u_1} [inst : Quiver U] [inst_1 : Quiver.HasReverse U], Prefunctor.MapReverse (ùü≠q U)",
    "name": "Prefunctor.mapReverseId",
    "depth": 10},
   {"term":
    "‚àÄ {U : Type u_1} [inst : Quiver U] [inst_1 : Quiver.HasReverse U], Prefunctor.MapReverse (ùü≠q U)",
    "name": "Prefunctor.mapReverseId.proof_1",
    "depth": 10},
   {"term":
    "‚àÄ {V : Type u} [inst : Quiver V],\n  CategoryTheory.freeGroupoidFunctor (ùü≠q V) = CategoryTheory.Functor.id (CategoryTheory.FreeGroupoid V)",
    "name": "CategoryTheory.Groupoid.Free.freeGroupoidFunctor_id",
    "depth": 11},
   {"term": "‚àÄ (V : Type u_1) [inst : Quiver V] (X : V), (ùü≠q V).obj X = X",
    "name": "Prefunctor.id_obj",
    "depth": 11},
   {"term":
    "‚àÄ (V : Type u_1) [inst : Quiver V] {X Y : V} (f : X ‚ü∂ Y), (ùü≠q V).map f = f",
    "name": "Prefunctor.id_map",
    "depth": 15}],
  "kind": "Prefunctor.¬´termùü≠q¬ª",
  "examples": [],
  "count": 11},
 {"noDocExamples":
  [{"term": "‚àÄ {Œ± : Type u} (s : Stream' Œ±), [] ++‚Çõ s = s",
    "name": "Stream'.nil_append_stream",
    "depth": 7},
   {"term":
    "‚àÄ {Œ± : Type u} (l : List Œ±) (h : l ‚â† []), Stream'.cycle l h = l ++‚Çõ Stream'.cycle l h",
    "name": "Stream'.cycle_eq",
    "depth": 8},
   {"term":
    "‚àÄ {Œ± : Type u} (l : List Œ±) (s : Stream' Œ±), ‚Üë(l ++‚Çõ s) = Stream'.Seq.append ‚Üël ‚Üës",
    "name": "Stream'.Seq.ofStream_append",
    "depth": 9},
   {"term":
    "‚àÄ {Œ± : Type u} (l : List Œ±) (s : Stream' Œ±), Stream'.drop (List.length l) (l ++‚Çõ s) = s",
    "name": "Stream'.drop_append_stream",
    "depth": 9},
   {"term":
    "‚àÄ {Œ± : Type u} (n : ‚Ñï) (s : Stream' Œ±), Stream'.take n s ++‚Çõ Stream'.drop n s = s",
    "name": "Stream'.append_take_drop",
    "depth": 10}],
  "kind": "Stream'.¬´term_++‚Çõ_¬ª",
  "examples": [],
  "count": 11},
 {"noDocExamples": [],
  "kind": "CategoryTheory.¬´term_‚•§+_¬ª",
  "examples":
  [{"term":
    "{C : Type u_1} ‚Üí\n  {D : Type u_2} ‚Üí\n    [inst : CategoryTheory.Category.{u_3, u_1} C] ‚Üí\n      [inst_1 : CategoryTheory.Category.{u_4, u_2} D] ‚Üí\n        [inst_2 : CategoryTheory.Preadditive C] ‚Üí\n          [inst_3 : CategoryTheory.Preadditive D] ‚Üí\n            (F : CategoryTheory.Functor C D) ‚Üí [inst_4 : CategoryTheory.Functor.Additive F] ‚Üí C ‚•§+ D",
    "name": "CategoryTheory.AdditiveFunctor.of",
    "doc":
    "Turn an additive functor into an object of the category `AdditiveFunctor C D`. ",
    "depth": 15},
   {"term":
    "(C : Type u_1) ‚Üí\n  (D : Type u_2) ‚Üí\n    [inst : CategoryTheory.Category.{u_3, u_1} C] ‚Üí\n      [inst_1 : CategoryTheory.Category.{u_4, u_2} D] ‚Üí\n        [inst_2 : CategoryTheory.Preadditive C] ‚Üí\n          [inst_3 : CategoryTheory.Preadditive D] ‚Üí CategoryTheory.Functor (C ‚•§+ D) (CategoryTheory.Functor C D)",
    "name": "CategoryTheory.AdditiveFunctor.forget",
    "doc": "An additive functor is in particular a functor. ",
    "depth": 16},
   {"term":
    "(C : Type u‚ÇÅ) ‚Üí\n  (D : Type u‚ÇÇ) ‚Üí\n    [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] ‚Üí\n      [inst_1 : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D] ‚Üí\n        [inst_2 : CategoryTheory.Preadditive C] ‚Üí\n          [inst_3 : CategoryTheory.Preadditive D] ‚Üí\n            [inst_4 : CategoryTheory.Limits.HasZeroObject C] ‚Üí\n              [inst_5 : CategoryTheory.Limits.HasZeroObject D] ‚Üí\n                [inst_6 : CategoryTheory.Limits.HasBinaryBiproducts C] ‚Üí CategoryTheory.Functor (C ‚•§‚Çó D) (C ‚•§+ D)",
    "name": "CategoryTheory.AdditiveFunctor.ofLeftExact",
    "doc": "Turn a left exact functor into an additive functor. ",
    "depth": 17},
   {"term":
    "(C : Type u‚ÇÅ) ‚Üí\n  (D : Type u‚ÇÇ) ‚Üí\n    [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] ‚Üí\n      [inst_1 : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D] ‚Üí\n        [inst_2 : CategoryTheory.Preadditive C] ‚Üí\n          [inst_3 : CategoryTheory.Preadditive D] ‚Üí\n            [inst_4 : CategoryTheory.Limits.HasZeroObject C] ‚Üí\n              [inst_5 : CategoryTheory.Limits.HasZeroObject D] ‚Üí\n                [inst_6 : CategoryTheory.Limits.HasBinaryBiproducts C] ‚Üí CategoryTheory.Functor (C ‚•§·µ£ D) (C ‚•§+ D)",
    "name": "CategoryTheory.AdditiveFunctor.ofRightExact",
    "doc": "Turn a right exact functor into an additive functor. ",
    "depth": 17},
   {"term":
    "(C : Type u‚ÇÅ) ‚Üí\n  (D : Type u‚ÇÇ) ‚Üí\n    [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] ‚Üí\n      [inst_1 : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D] ‚Üí\n        [inst_2 : CategoryTheory.Preadditive C] ‚Üí\n          [inst_3 : CategoryTheory.Preadditive D] ‚Üí\n            [inst_4 : CategoryTheory.Limits.HasZeroObject C] ‚Üí\n              [inst_5 : CategoryTheory.Limits.HasZeroObject D] ‚Üí\n                [inst_6 : CategoryTheory.Limits.HasBinaryBiproducts C] ‚Üí CategoryTheory.Functor (C ‚•§‚Çë D) (C ‚•§+ D)",
    "name": "CategoryTheory.AdditiveFunctor.ofExact",
    "doc": "Turn an exact functor into an additive functor. ",
    "depth": 17}],
  "count": 11},
 {"noDocExamples": [],
  "kind": "MeasureTheory.¬´term‚à´‚Åª_In_,_¬ª",
  "examples":
  [{"term":
    "‚àÄ (t : ‚Ñù) (f : UnitAddCircle ‚Üí ENNReal), ‚à´‚Åª (a : ‚Ñù) in Set.Ioc t (t + 1), f ‚Üëa = ‚à´‚Åª (b : UnitAddCircle), f b",
    "name": "UnitAddCircle.lintegral_preimage",
    "doc":
    "The integral of a measurable function over `UnitAddCircle` is equal to the integral over an\ninterval (t, t + 1] in `‚Ñù` of its lift to `‚Ñù`. ",
    "depth": 15},
   {"term":
    "‚àÄ (T : ‚Ñù) [hT : Fact (0 < T)] (t : ‚Ñù) (f : AddCircle T ‚Üí ENNReal),\n  ‚à´‚Åª (a : ‚Ñù) in Set.Ioc t (t + T), f ‚Üëa = ‚à´‚Åª (b : AddCircle T), f b",
    "name": "AddCircle.lintegral_preimage",
    "doc":
    "The lower integral of a function over `AddCircle T` is equal to the lower integral over an\ninterval (t, t + T] in `‚Ñù` of its lift to `‚Ñù`. ",
    "depth": 17},
   {"term":
    "‚àÄ {Œ± : Type u_1} [inst : MeasurableSpace Œ±] {f : Œ± ‚Üí ‚Ñù} (Œº : MeasureTheory.Measure Œ±)\n  [inst_1 : MeasureTheory.SigmaFinite Œº],\n  0 ‚â§ f ‚Üí Measurable f ‚Üí ‚à´‚Åª (œâ : Œ±), ENNReal.ofReal (f œâ) ‚àÇŒº = ‚à´‚Åª (t : ‚Ñù) in Set.Ioi 0, ‚Üë‚ÜëŒº {a | t < f a}",
    "name": "lintegral_eq_lintegral_meas_lt",
    "doc":
    "The standard case of the layer cake formula / Cavalieri's principle / tail probability formula:\n\nFor a nonnegative function `f` on a sigma-finite measure space, the Lebesgue integral of `f` can\nbe written (roughly speaking) as: `‚à´‚Åª f ‚àÇŒº = ‚à´‚Åª t in (0).. ‚àû, Œº {œâ | f(œâ) > t}`.\n\nSee `lintegral_eq_lintegral_meas_le` for a version with sets of the form `{œâ | f(œâ) ‚â• t}`\ninstead. ",
    "depth": 17},
   {"term":
    "‚àÄ {Œ± : Type u_1} [inst : MeasurableSpace Œ±] {f : Œ± ‚Üí ‚Ñù} (Œº : MeasureTheory.Measure Œ±)\n  [inst_1 : MeasureTheory.SigmaFinite Œº],\n  0 ‚â§ f ‚Üí Measurable f ‚Üí ‚à´‚Åª (œâ : Œ±), ENNReal.ofReal (f œâ) ‚àÇŒº = ‚à´‚Åª (t : ‚Ñù) in Set.Ioi 0, ‚Üë‚ÜëŒº {a | t ‚â§ f a}",
    "name": "MeasureTheory.lintegral_eq_lintegral_meas_le",
    "doc":
    "The standard case of the layer cake formula / Cavalieri's principle / tail probability formula:\n\nFor a nonnegative function `f` on a sigma-finite measure space, the Lebesgue integral of `f` can\nbe written (roughly speaking) as: `‚à´‚Åª f ‚àÇŒº = ‚à´‚Åª t in (0).. ‚àû, Œº {œâ | f(œâ) ‚â• t}`.\n\nSee `lintegral_eq_lintegral_meas_lt` for a version with sets of the form `{œâ | f(œâ) > t}`\ninstead. ",
    "depth": 17},
   {"term":
    "‚àÄ {Œ± : Type u_1} [inst : MeasurableSpace Œ±] {f : Œ± ‚Üí ‚Ñù} (Œº : MeasureTheory.Measure Œ±)\n  [inst_1 : MeasureTheory.SigmaFinite Œº],\n  0 ‚â§ f ‚Üí\n    Measurable f ‚Üí\n      ‚àÄ {p : ‚Ñù},\n        0 < p ‚Üí\n          ‚à´‚Åª (œâ : Œ±), ENNReal.ofReal (f œâ ^ p) ‚àÇŒº =\n            ENNReal.ofReal p * ‚à´‚Åª (t : ‚Ñù) in Set.Ioi 0, ‚Üë‚ÜëŒº {a | t < f a} * ENNReal.ofReal (t ^ (p - 1))",
    "name": "lintegral_rpow_eq_lintegral_meas_lt_mul",
    "doc":
    "An application of the layer cake formula / Cavalieri's principle / tail probability formula:\n\nFor a nonnegative function `f` on a sigma-finite measure space, the Lebesgue integral of `f` can\nbe written (roughly speaking) as: `‚à´‚Åª f^p ‚àÇŒº = p * ‚à´‚Åª t in (0).. ‚àû, t^(p-1) * Œº {œâ | f(œâ) > t}`.\n\nSee `lintegral_rpow_eq_lintegral_meas_le_mul` for a version with sets of the form `{œâ | f(œâ) ‚â• t}`\ninstead. ",
    "depth": 22}],
  "count": 10},
 {"noDocExamples":
  [{"term":
    "‚àÄ {Œ± : Type u} (s‚ÇÅ : Stream' Œ±), Stream'.even s‚ÇÅ ‚ãà Stream'.odd s‚ÇÅ = s‚ÇÅ",
    "name": "Stream'.interleave_even_odd",
    "depth": 8},
   {"term":
    "‚àÄ {Œ± : Type u} (s‚ÇÅ s‚ÇÇ : Stream' Œ±), Stream'.tail s‚ÇÅ ‚ãà Stream'.tail s‚ÇÇ = Stream'.tail (Stream'.tail (s‚ÇÅ ‚ãà s‚ÇÇ))",
    "name": "Stream'.interleave_tail_tail",
    "depth": 9},
   {"term":
    "‚àÄ {Œ± : Type u} (s‚ÇÅ s‚ÇÇ : Stream' Œ±), Stream'.tail (s‚ÇÅ ‚ãà s‚ÇÇ) = s‚ÇÇ ‚ãà Stream'.tail s‚ÇÅ",
    "name": "Stream'.tail_interleave",
    "depth": 9},
   {"term": "‚àÄ {Œ± : Type u} (s‚ÇÅ s‚ÇÇ : Stream' Œ±), Stream'.even (s‚ÇÅ ‚ãà s‚ÇÇ) = s‚ÇÅ",
    "name": "Stream'.even_interleave",
    "depth": 9},
   {"term":
    "‚àÄ {Œ± : Type u} {a : Œ±} {s‚ÇÅ : Stream' Œ±} (s‚ÇÇ : Stream' Œ±), a ‚àà s‚ÇÅ ‚Üí a ‚àà s‚ÇÅ ‚ãà s‚ÇÇ",
    "name": "Stream'.mem_interleave_left",
    "depth": 10}],
  "kind": "Stream'.¬´term_‚ãà_¬ª",
  "examples": [],
  "count": 9},
 {"noDocExamples":
  [{"term":
    "‚àÄ {R : Type u_1} {M : Type u_2} [inst : CommSemiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (x : M),\n  ‚ÜëTensorAlgebra.toDirectSum (‚Üë(TensorAlgebra.Œπ R) x) =\n    ‚Üë(DirectSum.of (fun n => TensorPower R n M) 1) (‚®Ç‚Çú[R] (x_1 : Fin 1), x)",
    "name": "TensorAlgebra.toDirectSum_Œπ",
    "depth": 39},
   {"term":
    "‚àÄ {Œπ : Type u_1} {Œπ‚ÇÇ : Type u_2} {R : Type u_4} [inst : CommSemiring R] {M : Type u_8} [inst_1 : AddCommMonoid M]\n  [inst_2 : Module R M] (e : Œπ ‚âÉ Œπ‚ÇÇ) (f : Œπ ‚Üí M),\n  ‚Üë(PiTensorProduct.reindex R M e) (‚Üë(PiTensorProduct.tprod R) f) = ‚®Ç‚Çú[R] (i : Œπ‚ÇÇ), f (‚Üëe.symm i)",
    "name": "PiTensorProduct.reindex_tprod",
    "depth": 43},
   {"term":
    "‚àÄ {Œπ : Type u_1} {Œπ‚ÇÇ : Type u_2} (R : Type u_4) [inst : CommSemiring R] (M : Type u_8) [inst_1 : AddCommMonoid M]\n  [inst_2 : Module R M] (a : Œπ ‚äï Œπ‚ÇÇ ‚Üí M),\n  ‚Üë(LinearEquiv.symm (PiTensorProduct.tmulEquiv R M)) (‚®Ç‚Çú[R] (i : Œπ ‚äï Œπ‚ÇÇ), a i) =\n    (‚®Ç‚Çú[R] (i : Œπ), a (Sum.inl i)) ‚äó‚Çú[R] ‚®Ç‚Çú[R] (i : Œπ‚ÇÇ), a (Sum.inr i)",
    "name": "PiTensorProduct.tmulEquiv_symm_apply",
    "depth": 45},
   {"term":
    "‚àÄ {Œπ : Type u_1} {Œπ‚ÇÇ : Type u_2} (R : Type u_4) [inst : CommSemiring R] (M : Type u_8) [inst_1 : AddCommMonoid M]\n  [inst_2 : Module R M] (a : Œπ ‚Üí M) (b : Œπ‚ÇÇ ‚Üí M),\n  ‚Üë(PiTensorProduct.tmulEquiv R M) ((‚®Ç‚Çú[R] (i : Œπ), a i) ‚äó‚Çú[R] ‚®Ç‚Çú[R] (i : Œπ‚ÇÇ), b i) = ‚®Ç‚Çú[R] (i : Œπ ‚äï Œπ‚ÇÇ), Sum.elim a b i",
    "name": "PiTensorProduct.tmulEquiv_apply",
    "depth": 47}],
  "kind": "PiTensorProduct.¬´term‚®Ç‚Çú[_]_,_¬ª",
  "examples":
  [{"term":
    "‚àÄ {R : Type u_1} {M : Type u_2} [inst : CommSemiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (n : ‚Ñï)\n  (x : Fin n ‚Üí M),\n  List.prod (List.map (fun a => GradedMonoid.mk 1 (‚®Ç‚Çú[R] (x_1 : Fin 1), x a)) (List.finRange n)) =\n    GradedMonoid.mk n (‚Üë(PiTensorProduct.tprod R) x)",
    "name": "TensorPower.list_prod_gradedMonoid_mk_single",
    "doc":
    "The product of tensor products made of a single vector is the same as a single product of\nall the vectors. ",
    "depth": 36}],
  "count": 7},
 {"noDocExamples":
  [{"term": "‚ãÇ‚ÇÄ ‚àÖ = ‚àÖ", "name": "ZFSet.sInter_empty", "depth": 5},
   {"term": "‚àÄ {x : ZFSet}, ZFSet.Nonempty x ‚Üí ‚Üë(‚ãÇ‚ÇÄ x) = ‚ãÇ‚ÇÄ ‚Üëx",
    "name": "Class.coe_sInter",
    "depth": 6},
   {"term": "‚àÄ {x : ZFSet}, ‚ãÇ‚ÇÄ {x} = x",
    "name": "ZFSet.sInter_singleton",
    "depth": 8},
   {"term":
    "‚àÄ {x : ZFSet}, ZFSet.Nonempty x ‚Üí ZFSet.toSet (‚ãÇ‚ÇÄ x) = ‚ãÇ‚ÇÄ (ZFSet.toSet '' ZFSet.toSet x)",
    "name": "ZFSet.toSet_sInter",
    "depth": 8},
   {"term": "‚àÄ {x y z : ZFSet}, y ‚àà ‚ãÇ‚ÇÄ x ‚Üí z ‚àà x ‚Üí y ‚àà z",
    "name": "ZFSet.mem_of_mem_sInter",
    "depth": 10}],
  "kind": "ZFSet.¬´term‚ãÇ‚ÇÄ_¬ª",
  "examples": [],
  "count": 7},
 {"noDocExamples":
  [{"term":
    "‚àÄ {M : Type u} [inst : NormedRing M] [inst_1 : StarRing M] [inst_2 : CstarRing M] [inst_3 : Module ‚ÑÇ M]\n  [inst_4 : NormedAlgebra ‚ÑÇ M] [inst_5 : StarModule ‚ÑÇ M],\n  (‚àÉ X x x_1 x_2, Nonempty (NormedSpace.Dual ‚ÑÇ X ‚âÉ‚Çó·µ¢‚ãÜ[‚ÑÇ] M)) ‚Üí WStarAlgebra M",
    "name": "WStarAlgebra.mk",
    "depth": 31}],
  "kind": "¬´term_‚âÉ‚Çó·µ¢‚ãÜ[_]_¬ª",
  "examples":
  [{"term":
    "(ùïú : Type u_1) ‚Üí\n  {E : Type u_2} ‚Üí\n    [inst : CommSemiring ùïú] ‚Üí\n      [inst_1 : StarRing ùïú] ‚Üí\n        [inst_2 : SeminormedAddCommGroup E] ‚Üí\n          [inst_3 : StarAddMonoid E] ‚Üí\n            [inst_4 : NormedStarGroup E] ‚Üí [inst_5 : Module ùïú E] ‚Üí [inst_6 : StarModule ùïú E] ‚Üí E ‚âÉ‚Çó·µ¢‚ãÜ[ùïú] E",
    "name": "star‚Çó·µ¢",
    "doc": "`star` bundled as a linear isometric equivalence ",
    "depth": 23},
   {"term":
    "(ùïú : Type u_1) ‚Üí\n  (E : Type u_2) ‚Üí\n    [inst : IsROrC ùïú] ‚Üí\n      [inst_1 : NormedAddCommGroup E] ‚Üí\n        [inst_2 : InnerProductSpace ùïú E] ‚Üí [inst_3 : CompleteSpace E] ‚Üí E ‚âÉ‚Çó·µ¢‚ãÜ[ùïú] NormedSpace.Dual ùïú E",
    "name": "InnerProductSpace.toDual",
    "doc":
    "Fr√©chet-Riesz representation: any `‚Ñì` in the dual of a Hilbert space `E` is of the form\n`fun u => ‚ü™y, u‚ü´` for some `y : E`, i.e. `toDualMap` is surjective.\n",
    "depth": 25},
   {"term":
    "‚àÄ {M : Type u} [inst : NormedRing M] [inst_1 : StarRing M] [inst_2 : CstarRing M] [inst_3 : Module ‚ÑÇ M]\n  [inst_4 : NormedAlgebra ‚ÑÇ M] [inst_5 : StarModule ‚ÑÇ M] [self : WStarAlgebra M],\n  ‚àÉ X x x_1 x_2, Nonempty (NormedSpace.Dual ‚ÑÇ X ‚âÉ‚Çó·µ¢‚ãÜ[‚ÑÇ] M)",
    "name": "WStarAlgebra.exists_predual",
    "doc":
    "There is a Banach space `X` whose dual is isometrically (conjugate-linearly) isomorphic\nto the `WStarAlgebra`. ",
    "depth": 31},
   {"term":
    "{ùïú : Type u_1} ‚Üí\n  {E : Type u_2} ‚Üí\n    {F : Type u_3} ‚Üí\n      [inst : IsROrC ùïú] ‚Üí\n        [inst_1 : NormedAddCommGroup E] ‚Üí\n          [inst_2 : NormedAddCommGroup F] ‚Üí\n            [inst_3 : InnerProductSpace ùïú E] ‚Üí\n              [inst_4 : InnerProductSpace ùïú F] ‚Üí\n                [inst_5 : CompleteSpace E] ‚Üí [inst_6 : CompleteSpace F] ‚Üí (E ‚ÜíL[ùïú] F) ‚âÉ‚Çó·µ¢‚ãÜ[ùïú] F ‚ÜíL[ùïú] E",
    "name": "ContinuousLinearMap.adjoint",
    "doc":
    "The adjoint of a bounded operator from Hilbert space `E` to Hilbert space `F`. ",
    "depth": 35}],
  "count": 5},
 {"noDocExamples":
  [{"term":
    "‚àÄ {Œ© : Type u_1} [inst : MeasureTheory.MeasureSpace Œ©]\n  [inst_1 : MeasureTheory.IsProbabilityMeasure MeasureTheory.volume] {X : Œ© ‚Üí ‚Ñù},\n  MeasureTheory.AEStronglyMeasurable X MeasureTheory.volume ‚Üí\n    ProbabilityTheory.evariance X MeasureTheory.volume =\n      (‚à´‚Åª (œâ : Œ©), ‚Üë(‚ÄñX œâ‚Äñ‚Çä ^ 2)) - ENNReal.ofReal ((‚à´ (a : Œ©), X a) ^ 2)",
    "name": "ProbabilityTheory.evariance_def'",
    "depth": 22},
   {"term":
    "‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] [inst_2 : FiniteDimensional ‚Ñù E]\n  [inst_3 : MeasureTheory.MeasureSpace E] [inst_4 : BorelSpace E]\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure MeasureTheory.volume] {r : ‚Ñù},\n  ‚Üë(FiniteDimensional.finrank ‚Ñù E) < r ‚Üí ‚à´‚Åª (x : E), ENNReal.ofReal ((1 + ‚Äñx‚Äñ) ^ (-r)) < ‚ä§",
    "name": "finite_integral_one_add_norm",
    "depth": 22},
   {"term":
    "‚àÄ {Œ© : Type u_1} {m : MeasurableSpace Œ©} {‚Ñô : MeasureTheory.Measure Œ©} [inst : MeasureTheory.IsFiniteMeasure ‚Ñô]\n  {X : Œ© ‚Üí ‚Ñù} {f : ‚Ñù ‚Üí ‚Ñù} {g : ‚Ñù ‚Üí ENNReal},\n  MeasureTheory.pdf X ‚Ñô =·∂†[MeasureTheory.Measure.ae MeasureTheory.volume] g ‚Üí\n    ‚à´‚Åª (x : ‚Ñù), ‚Üë‚Äñf x‚Äñ‚Çä * g x ‚â† ‚ä§ ‚Üí\n      MeasureTheory.HasFiniteIntegral fun x => f x * ENNReal.toReal (MeasureTheory.pdf X ‚Ñô x)",
    "name": "MeasureTheory.pdf.hasFiniteIntegral_mul",
    "depth": 25}],
  "kind": "MeasureTheory.¬´term‚à´‚Åª_,_¬ª",
  "examples":
  [{"term":
    "‚àÄ (t : ‚Ñù) (f : UnitAddCircle ‚Üí ENNReal), ‚à´‚Åª (a : ‚Ñù) in Set.Ioc t (t + 1), f ‚Üëa = ‚à´‚Åª (b : UnitAddCircle), f b",
    "name": "UnitAddCircle.lintegral_preimage",
    "doc":
    "The integral of a measurable function over `UnitAddCircle` is equal to the integral over an\ninterval (t, t + 1] in `‚Ñù` of its lift to `‚Ñù`. ",
    "depth": 15},
   {"term":
    "‚àÄ (T : ‚Ñù) [hT : Fact (0 < T)] (t : ‚Ñù) (f : AddCircle T ‚Üí ENNReal),\n  ‚à´‚Åª (a : ‚Ñù) in Set.Ioc t (t + T), f ‚Üëa = ‚à´‚Åª (b : AddCircle T), f b",
    "name": "AddCircle.lintegral_preimage",
    "doc":
    "The lower integral of a function over `AddCircle T` is equal to the lower integral over an\ninterval (t, t + T] in `‚Ñù` of its lift to `‚Ñù`. ",
    "depth": 17}],
  "count": 5},
 {"noDocExamples":
  [{"term":
    "‚àÄ {Œ± : Type u} [inst : Lattice Œ±] [inst_1 : AddGroup Œ±] (a : Œ±), |(-a)| = |a|",
    "name": "LatticeOrderedGroup.abs_neg",
    "depth": 15},
   {"term":
    "‚àÄ {Œ± : Type u_1} [inst : AddGroup Œ±] [inst_1 : LinearOrder Œ±] (a : Œ±), |(-a)| = |a|",
    "name": "abs_neg",
    "depth": 15},
   {"term":
    "‚àÄ {Œ± : Type u_1} [inst : AddGroup Œ±] [inst_1 : LinearOrder Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun x x_1 => x + x_1) fun x x_1 => x ‚â§ x_1] (a : Œ±), |(|a|)| = |a|",
    "name": "abs_abs",
    "depth": 17}],
  "kind": "Lean.Parser.Term.paren",
  "examples":
  [{"term":
    "‚àÄ {Œ± : Type u} [inst : Lattice Œ±] [inst_1 : AddGroup Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun x x_1 => x + x_1) fun x x_1 => x ‚â§ x_1]\n  [inst_3 : CovariantClass Œ± Œ± (Function.swap fun x x_1 => x + x_1) fun x x_1 => x ‚â§ x_1] (a : Œ±), |(|a|)| = |a|",
    "name": "LatticeOrderedGroup.abs_abs",
    "doc": "The unary operation of taking the absolute value is idempotent.",
    "depth": 19},
   {"term":
    "‚àÄ {Œ± : Type u} [inst : Lattice Œ±] [inst_1 : Group Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun x x_1 => x * x_1) fun x x_1 => x ‚â§ x_1]\n  [inst_3 : CovariantClass Œ± Œ± (Function.swap fun x x_1 => x * x_1) fun x x_1 => x ‚â§ x_1] (a : Œ±), |(|a|)| = |a|",
    "name": "LatticeOrderedGroup.mabs_mabs",
    "doc": "The unary operation of taking the absolute value is idempotent. ",
    "depth": 19}],
  "count": 5},
 {"noDocExamples":
  [{"term":
    "‚àÄ {Œ± : Type u_1} [inst : MeasurableSpace Œ±] {Œº : MeasureTheory.Measure Œ±} {p : Œ± ‚Üí Prop},\n  (‚àÉ·µê (a : Œ±) ‚àÇŒº, p a) ‚Üî ‚Üë‚ÜëŒº {a | p a} ‚â† 0",
    "name": "MeasureTheory.frequently_ae_iff",
    "depth": 12},
   {"term":
    "‚àÄ {Œ± : Type u_1} [inst : MeasurableSpace Œ±] {Œº : MeasureTheory.Measure Œ±} {s : Set Œ±},\n  (‚àÉ·µê (a : Œ±) ‚àÇŒº, a ‚àà s) ‚Üî ‚Üë‚ÜëŒº s ‚â† 0",
    "name": "MeasureTheory.frequently_ae_mem_iff",
    "depth": 14},
   {"term":
    "‚àÄ {Œ± : Type u_1} {m : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {f g : Œ± ‚Üí ENNReal},\n  AEMeasurable g ‚Üí\n    ‚à´‚Åª (x : Œ±), f x ‚àÇŒº ‚â† ‚ä§ ‚Üí\n      f ‚â§·∂†[MeasureTheory.Measure.ae Œº] g ‚Üí (‚àÉ·µê (x : Œ±) ‚àÇŒº, f x ‚â† g x) ‚Üí ‚à´‚Åª (x : Œ±), f x ‚àÇŒº < ‚à´‚Åª (x : Œ±), g x ‚àÇŒº",
    "name": "MeasureTheory.lintegral_strict_mono_of_ae_le_of_frequently_ae_lt",
    "depth": 19},
   {"term":
    "‚àÄ {Œ± : Type u_1} {m0 : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {Œ≤ : Type u_8} [inst : TopologicalSpace Œ≤]\n  [inst_1 : T1Space Œ≤] [inst_2 : TopologicalSpace.SecondCountableTopology Œ≤] [inst_3 : Nonempty Œ≤] {f : Œ± ‚Üí Œ≤},\n  (‚àÄ (b : Œ≤), ‚àÉ·µê (x : Œ±) ‚àÇŒº, f x ‚â† b) ‚Üí\n    ‚àÉ a b, a ‚â† b ‚àß (‚àÄ (s : Set Œ≤), s ‚àà nhds a ‚Üí 0 < ‚Üë‚ÜëŒº (f ‚Åª¬π' s)) ‚àß ‚àÄ (t : Set Œ≤), t ‚àà nhds b ‚Üí 0 < ‚Üë‚ÜëŒº (f ‚Åª¬π' t)",
    "name": "MeasureTheory.exists_ne_forall_mem_nhds_pos_measure_preimage",
    "depth": 29}],
  "kind": "MeasureTheory.¬´term‚àÉ·µê_‚àÇ_,_¬ª",
  "examples":
  [{"term":
    "‚àÄ {Œ± : Type u_2} [inst : MeasurableSpace Œ±] {f : Œ± ‚Üí Œ±} {s : Set Œ±} {Œº : MeasureTheory.Measure Œ±},\n  MeasureTheory.Conservative f Œº ‚Üí\n    MeasurableSet s ‚Üí ‚Üë‚ÜëŒº s ‚â† 0 ‚Üí ‚àÉ·µê (x : Œ±) ‚àÇŒº, x ‚àà s ‚àß ‚àÉ·∂† (n : ‚Ñï) in Filter.atTop, f^[n] x ‚àà s",
    "name":
    "MeasureTheory.Conservative.frequently_ae_mem_and_frequently_image_mem",
    "doc":
    "If `f` is a conservative self-map and `s` is a measurable set of positive measure, then\n`Œº.ae`-frequently we have `x ‚àà s` and `s` returns to `s` under infinitely many iterations of `f`. ",
    "depth": 21}],
  "count": 5},
 {"noDocExamples":
  [{"term": "‚ãÇ‚ÇÄ ‚àÖ = Class.univ", "name": "Class.sInter_empty", "depth": 5},
   {"term": "‚àÄ {x : ZFSet}, ZFSet.Nonempty x ‚Üí ‚Üë(‚ãÇ‚ÇÄ x) = ‚ãÇ‚ÇÄ ‚Üëx",
    "name": "Class.coe_sInter",
    "depth": 6},
   {"term": "‚àÄ {x : Class} {y : ZFSet}, (‚ãÇ‚ÇÄ x) y ‚Üî ‚àÄ (z : ZFSet), x z ‚Üí y ‚àà z",
    "name": "Class.sInter_apply",
    "depth": 10},
   {"term": "‚àÄ {x y z : Class}, y ‚àà ‚ãÇ‚ÇÄ x ‚Üí z ‚àà x ‚Üí y ‚àà z",
    "name": "Class.mem_of_mem_sInter",
    "depth": 10},
   {"term":
    "‚àÄ {x y : Class}, Set.Nonempty x ‚Üí (y ‚àà ‚ãÇ‚ÇÄ x ‚Üî ‚àÄ (z : Class), z ‚àà x ‚Üí y ‚àà z)",
    "name": "Class.mem_sInter",
    "depth": 11}],
  "kind": "Class.¬´term‚ãÇ‚ÇÄ_¬ª",
  "examples": [],
  "count": 5},
 {"noDocExamples":
  [{"term": "‚àÄ {Œ± : Type u} (s : Stream' Œ±), Stream'.pure id ‚äõ s = s",
    "name": "Stream'.identity",
    "depth": 9},
   {"term":
    "‚àÄ {Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Œ≤) (s : Stream' Œ±), Stream'.map f s = Stream'.pure f ‚äõ s",
    "name": "Stream'.map_eq_apply",
    "depth": 10},
   {"term":
    "‚àÄ {Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Œ≤) (a : Œ±), Stream'.pure f ‚äõ Stream'.pure a = Stream'.pure (f a)",
    "name": "Stream'.homomorphism",
    "depth": 11},
   {"term":
    "‚àÄ {Œ± : Type u} {Œ≤ : Type v} (fs : Stream' (Œ± ‚Üí Œ≤)) (a : Œ±), fs ‚äõ Stream'.pure a = (Stream'.pure fun f => f a) ‚äõ fs",
    "name": "Stream'.interchange",
    "depth": 11},
   {"term":
    "‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œ¥ : Type w} (g : Stream' (Œ≤ ‚Üí Œ¥)) (f : Stream' (Œ± ‚Üí Œ≤)) (s : Stream' Œ±),\n  Stream'.pure Function.comp ‚äõ g ‚äõ f ‚äõ s = g ‚äõ (f ‚äõ s)",
    "name": "Stream'.composition",
    "depth": 19}],
  "kind": "Stream'.¬´term_‚äõ_¬ª",
  "examples": [],
  "count": 5},
 {"noDocExamples":
  [{"term":
    "‚àÄ {m : Type u ‚Üí Type v} [inst : Monad m] [inst_1 : LawfulMonad m] {Œ± : Type u_1} {Œ≤ : Type u} (f : Œ± ‚Üí m Œ≤),\n  f >=> pure = f",
    "name": "fish_pure",
    "depth": 15},
   {"term":
    "‚àÄ (m : Type u_1 ‚Üí Type u_1) [inst : Monad m] [inst_1 : LawfulMonad m] {X Y : CategoryTheory.KleisliCat m} (f : X ‚ü∂ Y),\n  f >=> pure = pure >=> f",
    "name": "CategoryTheory.eq.proof_5",
    "depth": 15},
   {"term":
    "‚àÄ {m : Type u ‚Üí Type v} [inst : Monad m] [inst_1 : LawfulMonad m] {Œ± Œ≤ : Type u} (f : Œ± ‚Üí m Œ≤), pure >=> f = f",
    "name": "fish_pipe",
    "depth": 15},
   {"term":
    "‚àÄ {m : Type u ‚Üí Type v} [inst : Monad m] [inst_1 : LawfulMonad m] {Œ± : Type u_1} {Œ≤ Œ≥ œÜ : Type u} (f : Œ± ‚Üí m Œ≤)\n  (g : Œ≤ ‚Üí m Œ≥) (h : Œ≥ ‚Üí m œÜ), (f >=> g) >=> h = f >=> g >=> h",
    "name": "fish_assoc",
    "depth": 21}],
  "kind": "¬´term_>=>_¬ª",
  "examples": [],
  "count": 4},
 {"noDocExamples":
  [{"term": "‚àÄ (x : ZFSet), ‚Üë(‚ãÉ‚ÇÄ x) = ‚ãÉ‚ÇÄ ‚Üëx",
    "name": "Class.coe_sUnion",
    "depth": 5},
   {"term": "‚ãÉ‚ÇÄ ‚àÖ = ‚àÖ", "name": "Class.sUnion_empty", "depth": 5},
   {"term": "‚àÄ {x : Class} {y : ZFSet}, (‚ãÉ‚ÇÄ x) y ‚Üî ‚àÉ z, x z ‚àß y ‚àà z",
    "name": "Class.sUnion_apply",
    "depth": 11},
   {"term": "‚àÄ {x y : Class}, y ‚àà ‚ãÉ‚ÇÄ x ‚Üî ‚àÉ z, z ‚àà x ‚àß y ‚àà z",
    "name": "Class.mem_sUnion",
    "depth": 12}],
  "kind": "Class.¬´term‚ãÉ‚ÇÄ_¬ª",
  "examples": [],
  "count": 4},
 {"noDocExamples":
  [{"term": "‚àÄ (x : PSet), PSet.toSet (‚ãÉ‚ÇÄ x) = ‚ãÉ‚ÇÄ (PSet.toSet '' PSet.toSet x)",
    "name": "PSet.toSet_sUnion",
    "depth": 7},
   {"term":
    "‚àÄ (x x_1 : PSet), PSet.Equiv x x_1 ‚Üí PSet.Arity.Equiv (‚ãÉ‚ÇÄ x) (‚ãÉ‚ÇÄ x_1)",
    "name": "ZFSet.sUnion.proof_1",
    "depth": 8},
   {"term": "‚àÄ {x y : PSet}, y ‚àà ‚ãÉ‚ÇÄ x ‚Üî ‚àÉ z, z ‚àà x ‚àß y ‚àà z",
    "name": "PSet.mem_sUnion",
    "depth": 12},
   {"term":
    "‚àÄ {Œ± Œ≤ : Type u} (A : Œ± ‚Üí PSet) (B : Œ≤ ‚Üí PSet),\n  (‚àÄ (a : Œ±), ‚àÉ b, PSet.Equiv (A a) (B b)) ‚Üí\n    ‚àÄ (a : PSet.Type (‚ãÉ‚ÇÄ PSet.mk Œ± A)), ‚àÉ b, PSet.Equiv (PSet.Func (‚ãÉ‚ÇÄ PSet.mk Œ± A) a) (PSet.Func (‚ãÉ‚ÇÄ PSet.mk Œ≤ B) b)",
    "name": "ZFSet.sUnion_lem",
    "depth": 15}],
  "kind": "PSet.¬´term‚ãÉ‚ÇÄ_¬ª",
  "examples": [],
  "count": 4},
 {"noDocExamples":
  [{"term":
    "‚àÄ {Œ± : Type u_1} [inst : BEq Œ±] [inst_1 : LawfulBEq Œ±] (a : Œ±), (a != a) = false",
    "name": "bne_self_eq_false",
    "depth": 10},
   {"term": "‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] (a : Œ±), (a != a) = false",
    "name": "bne_self_eq_false'",
    "depth": 13},
   {"term":
    "‚àÄ {Œ± : Type u_1} [inst : BEq Œ±] [inst_1 : LawfulBEq Œ±] (a b : Œ±), (a != b) = true ‚Üî a ‚â† b",
    "name": "bne_iff_ne",
    "depth": 13}],
  "kind": "¬´term_!=_¬ª",
  "examples": [],
  "count": 3},
 {"noDocExamples":
  [{"term":
    "‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] [inst_1 : CategoryTheory.MonoidalCategory C] {D : Type u‚ÇÇ}\n  [inst_2 : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D] [inst_3 : CategoryTheory.MonoidalCategory D] {E : Type u‚ÇÉ}\n  [inst_4 : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E] [inst_5 : CategoryTheory.MonoidalCategory E]\n  (F : CategoryTheory.MonoidalFunctor C D) (G : CategoryTheory.MonoidalFunctor D E),\n  (F ‚äó‚ãô G).toLaxMonoidalFunctor = F.toLaxMonoidalFunctor ‚äó‚ãô G.toLaxMonoidalFunctor",
    "name": "CategoryTheory.MonoidalFunctor.comp_toLaxMonoidalFunctor",
    "depth": 25}],
  "kind": "CategoryTheory.MonoidalFunctor.¬´term_‚äó‚ãô_¬ª",
  "examples":
  [{"term":
    "{M : Type u} ‚Üí\n  [inst : Monoid M] ‚Üí\n    {N : Type u} ‚Üí\n      [inst_1 : Monoid N] ‚Üí\n        {K : Type u} ‚Üí\n          [inst_2 : Monoid K] ‚Üí\n            (F : M ‚Üí* N) ‚Üí\n              (G : N ‚Üí* K) ‚Üí\n                CategoryTheory.Discrete.monoidalFunctor F ‚äó‚ãô CategoryTheory.Discrete.monoidalFunctor G ‚âÖ\n                  CategoryTheory.Discrete.monoidalFunctor (MonoidHom.comp G F)",
    "name": "CategoryTheory.Discrete.monoidalFunctorComp",
    "doc":
    "The monoidal natural isomorphism corresponding to composing two multiplicative morphisms.\n",
    "depth": 22},
   {"term":
    "{M : Type u} ‚Üí\n  [inst : AddMonoid M] ‚Üí\n    {N : Type u} ‚Üí\n      [inst_1 : AddMonoid N] ‚Üí\n        {K : Type u} ‚Üí\n          [inst_2 : AddMonoid K] ‚Üí\n            (F : M ‚Üí+ N) ‚Üí\n              (G : N ‚Üí+ K) ‚Üí\n                CategoryTheory.Discrete.addMonoidalFunctor F ‚äó‚ãô CategoryTheory.Discrete.addMonoidalFunctor G ‚âÖ\n                  CategoryTheory.Discrete.addMonoidalFunctor (AddMonoidHom.comp G F)",
    "name": "CategoryTheory.Discrete.addMonoidalFunctorComp",
    "doc":
    "The monoidal natural isomorphism corresponding to\ncomposing two additive morphisms.",
    "depth": 22}],
  "count": 3},
 {"noDocExamples":
  [{"term": "‚àÄ (F A : Class), F ‚Ä≤ A ‚àà Class.univ",
    "name": "Class.fval_ex",
    "depth": 7},
   {"term":
    "‚àÄ (x : ZFSet), ¬¨‚àÖ ‚àà x ‚Üí ‚àÄ (y : ZFSet), y ‚àà x ‚Üí ‚Üë(ZFSet.choice x) ‚Ä≤ ‚Üëy ‚àà ‚Üëy",
    "name": "ZFSet.choice_mem",
    "depth": 10},
   {"term":
    "‚àÄ {f : ZFSet ‚Üí ZFSet} [H : PSet.Definable 1 f] {x y : ZFSet}, y ‚àà x ‚Üí ‚Üë(ZFSet.map f x) ‚Ä≤ ‚Üëy = ‚Üë(f y)",
    "name": "ZFSet.map_fval",
    "depth": 13}],
  "kind": "Class.¬´term_‚Ä≤_¬ª",
  "examples": [],
  "count": 3},
 {"noDocExamples":
  [{"term":
    "‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] (f : ‚Ñù ‚Üí E) (a b : ‚Ñù),\n  ‚®ç (x : ‚Ñù) in a..b, f x = ‚®ç (x : ‚Ñù) in b..a, f x",
    "name": "interval_average_symm",
    "depth": 15},
   {"term":
    "‚àÄ (f : ‚Ñù ‚Üí ‚Ñù) (a b : ‚Ñù), ‚®ç (x : ‚Ñù) in a..b, f x = (‚à´ (x : ‚Ñù) in a..b, f x) / (b - a)",
    "name": "interval_average_eq_div",
    "depth": 16},
   {"term":
    "‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] (f : ‚Ñù ‚Üí E) (a b : ‚Ñù),\n  ‚®ç (x : ‚Ñù) in a..b, f x = (b - a)‚Åª¬π ‚Ä¢ ‚à´ (x : ‚Ñù) in a..b, f x",
    "name": "interval_average_eq",
    "depth": 22}],
  "kind": "¬´term‚®ç_In_.._,_¬ª",
  "examples": [],
  "count": 3},
 {"noDocExamples": [],
  "kind": "¬´term_‚âÉ‚Çó‚ãÜ[_]_¬ª",
  "examples":
  [{"term":
    "(R : Type u_1) ‚Üí\n  {A : Type u_2} ‚Üí\n    [inst : CommSemiring R] ‚Üí\n      [inst_1 : StarRing R] ‚Üí\n        [inst_2 : AddCommMonoid A] ‚Üí\n          [inst_3 : StarAddMonoid A] ‚Üí [inst_4 : Module R A] ‚Üí [inst_5 : StarModule R A] ‚Üí A ‚âÉ‚Çó‚ãÜ[R] A",
    "name": "starLinearEquiv",
    "doc":
    "If `A` is a module over a commutative `R` with compatible actions,\nthen `star` is a semilinear equivalence. ",
    "depth": 22},
   {"term":
    "(m : Type u_2) ‚Üí\n  (n : Type u_3) ‚Üí\n    (R : Type u_7) ‚Üí\n      (Œ± : Type v) ‚Üí\n        [inst : CommSemiring R] ‚Üí\n          [inst_1 : StarRing R] ‚Üí\n            [inst_2 : AddCommMonoid Œ±] ‚Üí\n              [inst_3 : StarAddMonoid Œ±] ‚Üí\n                [inst_4 : Module R Œ±] ‚Üí [inst_5 : StarModule R Œ±] ‚Üí Matrix m n Œ± ‚âÉ‚Çó‚ãÜ[R] Matrix n m Œ±",
    "name": "Matrix.conjTransposeLinearEquiv",
    "doc": "`Matrix.conjTranspose` as a `LinearMap` ",
    "depth": 24},
   {"term":
    "{ùïú : Type u_1} ‚Üí\n  {E : Type u_2} ‚Üí\n    {F : Type u_3} ‚Üí\n      [inst : IsROrC ùïú] ‚Üí\n        [inst_1 : NormedAddCommGroup E] ‚Üí\n          [inst_2 : NormedAddCommGroup F] ‚Üí\n            [inst_3 : InnerProductSpace ùïú E] ‚Üí\n              [inst_4 : InnerProductSpace ùïú F] ‚Üí\n                [inst_5 : FiniteDimensional ùïú E] ‚Üí [inst_6 : FiniteDimensional ùïú F] ‚Üí (E ‚Üí‚Çó[ùïú] F) ‚âÉ‚Çó‚ãÜ[ùïú] F ‚Üí‚Çó[ùïú] E",
    "name": "LinearMap.adjoint",
    "doc":
    "The adjoint of an operator from the finite-dimensional inner product space `E` to the\nfinite-dimensional inner product space `F`. ",
    "depth": 32}],
  "count": 3},
 {"noDocExamples": [],
  "kind": "¬´term_‚Üí‚Çó‚ãÜ[_]_¬ª",
  "examples":
  [{"term":
    "{ùïú : Type u_1} ‚Üí\n  {E : Type u_2} ‚Üí\n    [inst : IsROrC ùïú] ‚Üí [inst_1 : NormedAddCommGroup E] ‚Üí [inst_2 : InnerProductSpace ùïú E] ‚Üí E ‚Üí‚Çó[ùïú] E ‚Üí‚Çó‚ãÜ[ùïú] ùïú",
    "name": "sesqFormOfInner",
    "doc":
    "The inner product as a sesquilinear form.\n\nNote that in the case `ùïú = ‚Ñù` this is a bilinear form. ",
    "depth": 26},
   {"term":
    "(ùïú : Type u_1) ‚Üí\n  {E : Type u_2} ‚Üí\n    [inst : IsROrC ùïú] ‚Üí [inst_1 : NormedAddCommGroup E] ‚Üí [inst_2 : InnerProductSpace ùïú E] ‚Üí E ‚Üí‚Çó‚ãÜ[ùïú] E ‚Üí‚Çó[ùïú] ùïú",
    "name": "inner‚Çõ‚Çó",
    "doc": "The inner product as a sesquilinear map. ",
    "depth": 26}],
  "count": 2},
 {"noDocExamples": [],
  "kind": "¬´term_‚Üí‚Çó·µ¢‚ãÜ[_]_¬ª",
  "examples":
  [{"term":
    "(ùïú : Type u_1) ‚Üí\n  (E : Type u_2) ‚Üí\n    [inst : IsROrC ùïú] ‚Üí\n      [inst_1 : NormedAddCommGroup E] ‚Üí [inst_2 : InnerProductSpace ùïú E] ‚Üí E ‚Üí‚Çó·µ¢‚ãÜ[ùïú] NormedSpace.Dual ùïú E",
    "name": "InnerProductSpace.toDualMap",
    "doc":
    "An element `x` of an inner product space `E` induces an element of the dual space `Dual ùïú E`,\nthe map `fun y => ‚ü™x, y‚ü´`; moreover this operation is a conjugate-linear isometric embedding of `E`\ninto `Dual ùïú E`.\nIf `E` is complete, this operation is surjective, hence a conjugate-linear isometric equivalence;\nsee `toDual`.\n",
    "depth": 21}],
  "count": 1},
 {"noDocExamples": [],
  "kind": "¬´term_‚âÉL‚ãÜ[_]_¬ª",
  "examples":
  [{"term":
    "(R : Type u_1) ‚Üí\n  {A : Type u_2} ‚Üí\n    [inst : CommSemiring R] ‚Üí\n      [inst_1 : StarRing R] ‚Üí\n        [inst_2 : AddCommMonoid A] ‚Üí\n          [inst_3 : StarAddMonoid A] ‚Üí\n            [inst_4 : Module R A] ‚Üí\n              [inst_5 : StarModule R A] ‚Üí [inst_6 : TopologicalSpace A] ‚Üí [inst_7 : ContinuousStar A] ‚Üí A ‚âÉL‚ãÜ[R] A",
    "name": "starL",
    "doc":
    "If `A` is a topological module over a commutative `R` with compatible actions,\nthen `star` is a continuous semilinear equivalence. ",
    "depth": 26}],
  "count": 1},
 {"noDocExamples":
  [{"term":
    "‚àÄ {Cont : Type u_1} {Elem : Type u_2} {Dom : Cont ‚Üí ‚Ñï ‚Üí Prop} {n : ‚Ñï} [inst : GetElem Cont ‚Ñï Elem Dom] (a : Cont)\n  (i : Fin n) [inst_1 : Decidable (Dom a ‚Üëi)] [inst_2 : Inhabited Elem], a[i]! = a[‚Üëi]!",
    "name": "getElem!_fin",
    "depth": 22}],
  "kind": "¬´term__[_]_!¬ª",
  "examples": [],
  "count": 1}]