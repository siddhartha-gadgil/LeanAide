[{"noDocExamples": [],
  "kind": "Lean.Parser.Term.app",
  "examples":
  [{"type": "RingHom.LocalizationPreserves @RingHom.Finite",
    "name": "localization_finite",
    "isProp": true,
    "doc":
    "If `S` is a finite `R`-algebra, then `S' = Mâ»Â¹S` is a finite `R' = Mâ»Â¹R`-algebra. ",
    "depth": 1},
   {"type": "Irrational goldenRatio",
    "name": "gold_irrational",
    "isProp": true,
    "doc": "The golden ratio is irrational. ",
    "depth": 1},
   {"type": "Irrational goldenConj",
    "name": "goldConj_irrational",
    "isProp": true,
    "doc": "The conjugate of the golden ratio is irrational. ",
    "depth": 1}],
  "count": 218088},
 {"noDocExamples": [],
  "kind": "Lean.Parser.Term.type",
  "examples":
  [{"type":
    "âˆ€ {R : Type u_1} [inst : MulZeroClass R] {a : R} [inst_1 : Nontrivial R], IsRegular a â†’ a â‰  0",
    "name": "IsRegular.ne_zero",
    "isProp": true,
    "doc": "A regular element of a `Nontrivial` `MulZeroClass` is non-zero. ",
    "depth": 10},
   {"type": "AlgebraicGeometry.Scheme â†’ AlgebraicGeometry.Scheme â†’ Type u_1",
    "name": "AlgebraicGeometry.Scheme.Hom",
    "isProp": false,
    "doc":
    "A morphism between schemes is a morphism between the underlying locally ringed spaces. ",
    "depth": 2},
   {"type":
    "âˆ€ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] (J : CategoryTheory.GrothendieckTopology C),\n  (âˆ€ (X : C), CategoryTheory.Presieve.IsSheaf J (CategoryTheory.yoneda.obj X)) â†’ CategoryTheory.Sheaf.Subcanonical J",
    "name": "CategoryTheory.Sheaf.Subcanonical.of_yoneda_isSheaf",
    "isProp": true,
    "doc":
    "If every functor `yoneda.obj X` is a `J`-sheaf, then `J` is subcanonical. ",
    "depth": 17}],
  "count": 193747},
 {"noDocExamples": [],
  "kind": "Lean.Parser.Term.forall",
  "examples":
  [{"type": "âˆ€ {Î± : Prop}, Î±",
    "name": "lcProof",
    "isProp": true,
    "doc":
    "Auxiliary unsafe constant used by the Compiler when erasing proofs from code.\n\nIt may look strange to have an axiom that says \"every proposition is true\",\nsince this is obviously unsound, but the `unsafe` marker ensures that the\nkernel will not let this through into regular proofs. The lower levels of the\ncode generator don't need proofs in terms, so this is used to stub the proofs\nout.\n",
    "depth": 1},
   {"type": "âˆ€ (n : â„•), Int.NonNeg (Int.ofNat n)",
    "name": "Int.NonNeg.mk",
    "isProp": true,
    "doc": "Sole constructor, proving that `ofNat n` is positive. ",
    "depth": 3},
   {"type":
    "âˆ€ (o : Ordinal.{u_1}), SetTheory.PGame.Numeric (Ordinal.toPGame o)",
    "name": "SetTheory.PGame.numeric_toPGame",
    "isProp": true,
    "doc": "Ordinal games are numeric. ",
    "depth": 3}],
  "count": 182029},
 {"noDocExamples": [],
  "kind": "Â«term_=_Â»",
  "examples":
  [{"type": "Cardinal.mk â„‚ = Cardinal.continuum",
    "name": "mk_complex",
    "isProp": true,
    "doc": "The cardinality of the complex numbers, as a type. ",
    "depth": 3},
   {"type": "Cardinal.mk â„ = Cardinal.continuum",
    "name": "Cardinal.mk_real",
    "isProp": true,
    "doc": "The cardinality of the reals, as a type. ",
    "depth": 3},
   {"type": "Ordinal.lift.{max u v, u} = Ordinal.lift.{v, u}",
    "name": "Ordinal.lift_umax",
    "isProp": true,
    "doc": "`lift.{max u v, u}` equals `lift.{v, u}`. ",
    "depth": 4}],
  "count": 108525},
 {"noDocExamples": [],
  "kind": "Lean.Parser.Term.arrow",
  "examples":
  [{"type":
    "âˆ€ {R : Type u_1} [inst : MulZeroClass R] {a : R} [inst_1 : Nontrivial R], IsRegular a â†’ a â‰  0",
    "name": "IsRegular.ne_zero",
    "isProp": true,
    "doc": "A regular element of a `Nontrivial` `MulZeroClass` is non-zero. ",
    "depth": 10},
   {"type":
    "âˆ€ {m : â„•}, 2 â‰¤ m â†’ âˆ€ (n : â„•), (Finset.sum (Finset.range n) fun k => m ^ k) = (m ^ n - 1) / (m - 1)",
    "name": "Nat.geomSum_eq",
    "isProp": true,
    "doc":
    "If all the elements of a finset of naturals are less than `n`, then the sum of their powers of\n`m â‰¥ 2` is less than `m ^ n`. ",
    "depth": 14},
   {"type": "AlgebraicGeometry.Scheme â†’ AlgebraicGeometry.Scheme â†’ Type u_1",
    "name": "AlgebraicGeometry.Scheme.Hom",
    "isProp": false,
    "doc":
    "A morphism between schemes is a morphism between the underlying locally ringed spaces. ",
    "depth": 2}],
  "count": 99857},
 {"noDocExamples": [],
  "kind": "Lean.Parser.Term.depArrow",
  "examples":
  [{"type": "(X : Type u) â†’ [inst : TopologicalSpace X] â†’ Prop",
    "name": "CompletelyRegularSpace",
    "isProp": false,
    "doc":
    "A space is completely regular if points can be separated from closed sets via\ncontinuous functions to the unit interval. ",
    "depth": 3},
   {"type": "{Î± : Type u} â†’ Î± â†’ List Î± â†’ Prop",
    "name": "List.Mem",
    "isProp": false,
    "doc":
    "`a âˆˆ l` is a predicate which asserts that `a` is in the list `l`.\nUnlike `elem`, this uses `=` instead of `==` and is suited for mathematical reasoning.\n* `a âˆˆ [x, y, z] â†” a = x âˆ¨ a = y âˆ¨ a = z`\n",
    "depth": 4},
   {"type":
    "{Î± : Type u_1} â†’ GeneralizedContinuedFraction Î± â†’ Stream'.Seq (GeneralizedContinuedFraction.Pair Î±)",
    "name": "GeneralizedContinuedFraction.s",
    "isProp": false,
    "doc": "Sequence of partial numerator and denominator pairs. ",
    "depth": 4}],
  "count": 45052},
 {"noDocExamples": [],
  "kind": "Lean.Parser.Term.proj",
  "examples":
  [{"type":
    "âˆ€ {F : PFunctor.{u}} (self : PFunctor.MIntl F), PFunctor.Approx.AllAgree self.approx",
    "name": "PFunctor.MIntl.consistent",
    "isProp": true,
    "doc": "Each approximation agrees with the next ",
    "depth": 5},
   {"type":
    "âˆ€ {V : Type u} {G : SimpleGraph V} (self : SimpleGraph.Partition G), âˆ€ s âˆˆ self.parts, IsAntichain G.Adj s",
    "name": "SimpleGraph.Partition.independent",
    "isProp": true,
    "doc":
    "`independent`: a proof that each element of `parts` doesn't have a pair of adjacent vertices.\n",
    "depth": 11},
   {"type":
    "âˆ€ {b o : Ordinal.{u}} {x : Ordinal.{u} Ã— Ordinal.{u}}, x âˆˆ Ordinal.CNF b o â†’ 0 < x.2",
    "name": "Ordinal.CNF_lt_snd",
    "isProp": true,
    "doc": "Every coefficient in a Cantor normal form is positive. ",
    "depth": 11}],
  "count": 36155},
 {"noDocExamples": [],
  "kind": "coeNotation",
  "examples":
  [{"type":
    "âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {M : Type u_3} {H : Type u_4} [inst : NontriviallyNormedField ğ•œ]\n  [inst_1 : NormedAddCommGroup E] [inst_2 : NormedSpace ğ•œ E] [inst_3 : TopologicalSpace H] [inst_4 : TopologicalSpace M]\n  (f : PartialHomeomorph M H) (I : ModelWithCorners ğ•œ E H) {t : Set M},\n  t âŠ† f.source â†’ â†‘(PartialEquiv.symm (PartialHomeomorph.extend f I)) âˆ˜ â†‘(PartialHomeomorph.extend f I) '' t = t",
    "name": "PartialHomeomorph.extend_left_inv'",
    "isProp": true,
    "doc": "Variant of `f.extend_left_inv I`, stated in terms of images. ",
    "depth": 32},
   {"type":
    "{C : Type u} â†’\n  [inst : CategoryTheory.Category.{v, u} C] â†’\n    [inst_1 : CategoryTheory.Limits.HasColimits C] â†’ (X : AlgebraicGeometry.PresheafedSpace C) â†’ â†‘â†‘X â†’ C",
    "name": "AlgebraicGeometry.PresheafedSpace.stalk",
    "isProp": false,
    "doc": "The stalk at `x` of a `PresheafedSpace`.\n",
    "depth": 9},
   {"type":
    "âˆ€ {s : â„‚} {N : â„•} (Ï‡ : DirichletCharacter â„‚ N) (hs : 1 < s.re),\n  Filter.Tendsto (fun n => Finset.prod (Nat.primesBelow n) fun p => (1 - Ï‡ â†‘p * â†‘p ^ (-s))â»Â¹) Filter.atTop\n    (nhds (âˆ‘' (n : â„•), (dirichletSummandHom Ï‡ (_ : s â‰  0)) n))",
    "name": "dirichletLSeries_eulerProduct",
    "isProp": true,
    "doc": "The Euler product for Dirichlet L-series, valid for `s.re > 1`. ",
    "depth": 26}],
  "count": 30909},
 {"noDocExamples": [],
  "kind": "Lean.Parser.Term.explicitUniv",
  "examples":
  [{"type":
    "âˆ€ {C : Type u_1} [inst : CategoryTheory.Category.{u_2, u_1} C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  [inst_2 : CategoryTheory.Limits.HasFiniteProducts C] [inst_3 : CategoryTheory.Limits.HasKernels C]\n  [inst_4 : CategoryTheory.NormalMonoCategory C] {X Y : C} (f g : X âŸ¶ Y),\n  CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.parallelPair f g)",
    "name": "CategoryTheory.NormalMonoCategory.hasLimit_parallelPair",
    "isProp": true,
    "doc": "The equalizer of `f` and `g` exists. ",
    "depth": 17},
   {"type":
    "âˆ€ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] (J : CategoryTheory.GrothendieckTopology C),\n  (âˆ€ (X : C), CategoryTheory.Presieve.IsSheaf J (CategoryTheory.yoneda.obj X)) â†’ CategoryTheory.Sheaf.Subcanonical J",
    "name": "CategoryTheory.Sheaf.Subcanonical.of_yoneda_isSheaf",
    "isProp": true,
    "doc":
    "If every functor `yoneda.obj X` is a `J`-sheaf, then `J` is subcanonical. ",
    "depth": 17},
   {"type":
    "{C : Type u} â†’\n  [inst : CategoryTheory.Category.{v, u} C] â†’\n    [inst_1 : CategoryTheory.Limits.HasColimits C] â†’ (X : AlgebraicGeometry.PresheafedSpace C) â†’ â†‘â†‘X â†’ C",
    "name": "AlgebraicGeometry.PresheafedSpace.stalk",
    "isProp": false,
    "doc": "The stalk at `x` of a `PresheafedSpace`.\n",
    "depth": 9}],
  "count": 30708},
 {"noDocExamples": [],
  "kind": "Lean.Parser.Term.fun",
  "examples":
  [{"type": "âˆ€ (n : â„•), RePred fun c => (Nat.Partrec.Code.eval c n).Dom",
    "name": "ComputablePred.halting_problem_re",
    "isProp": true,
    "doc": "The Halting problem is recursively enumerable ",
    "depth": 6},
   {"type":
    "âˆ€ {Î¼ : YoungDiagram},\n  YoungDiagram.ofRowLens (YoungDiagram.rowLens Î¼) (_ : List.Sorted (fun x x_1 => x â‰¥ x_1) (YoungDiagram.rowLens Î¼)) = Î¼",
    "name": "YoungDiagram.ofRowLens_to_rowLens_eq_self",
    "isProp": true,
    "doc": "The left_inv direction of the equivalence ",
    "depth": 6},
   {"type": "âˆ€ {Î± : Type u_1}, (Sym2.map fun x => x) = id",
    "name": "Sym2.map_id'",
    "isProp": true,
    "doc":
    "Note: `Sym2.map_id` will not simplify `Sym2.map id z` due to `Sym2.map_congr`. ",
    "depth": 6}],
  "count": 27129},
 {"noDocExamples": [],
  "kind": "termâ„•",
  "examples":
  [{"type":
    "âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p â†’ IsCyclic Î±",
    "name": "isCyclic_of_prime_card",
    "isProp": true,
    "doc": "A finite group of prime order is cyclic. ",
    "depth": 10},
   {"type":
    "âˆ€ {m : â„•}, 2 â‰¤ m â†’ âˆ€ (n : â„•), (Finset.sum (Finset.range n) fun k => m ^ k) = (m ^ n - 1) / (m - 1)",
    "name": "Nat.geomSum_eq",
    "isProp": true,
    "doc":
    "If all the elements of a finset of naturals are less than `n`, then the sum of their powers of\n`m â‰¥ 2` is less than `m ^ n`. ",
    "depth": 14},
   {"type":
    "{G : Type u_1} â†’ [inst : AddGroup G] â†’ AddSubgroup G â†’ AddSubgroup G â†’ â„•",
    "name": "AddSubgroup.relindex",
    "isProp": false,
    "doc":
    "The relative index of a subgroup as a natural number,\nand returns 0 if the relative index is infinite.",
    "depth": 6}],
  "count": 23623},
 {"noDocExamples": [],
  "kind": "Â«term_â‰¤_Â»",
  "examples":
  [{"type": "âˆ€ (L : List â„•), List.headI L â‰¤ List.sum L",
    "name": "List.headI_le_sum",
    "isProp": true,
    "doc": "This relies on `default â„• = 0`. ",
    "depth": 6},
   {"type": "âˆ€ {p : â„•} (n : â„•), padicValNat p n â‰¤ Nat.log p n",
    "name": "padicValNat_le_nat_log",
    "isProp": true,
    "doc":
    "The p-adic valuation of `n` is less than or equal to its logarithm w.r.t `p`.",
    "depth": 6},
   {"type": "âˆ€ {p : â„}, p â‰¤ 0 â†’ ENNReal.ofReal p = 0",
    "name": "ENNReal.ofReal_of_nonpos",
    "isProp": true,
    "doc": "**Alias** of the reverse direction of `ENNReal.ofReal_eq_zero`.",
    "depth": 6}],
  "count": 21386},
 {"noDocExamples": [],
  "kind": "Â«term_â†”_Â»",
  "examples":
  [{"type": "âˆ€ (p : True â†’ Prop), (âˆ€ (x : True), p x) â†” p True.intro",
    "name": "forall_true_left",
    "isProp": true,
    "doc": "See `IsEmpty.forall_iff` for the `False` version. ",
    "depth": 5},
   {"type": "âˆ€ {a b : Prop}, (a â†” b) â†’ b â†’ a",
    "name": "Iff.mpr",
    "isProp": true,
    "doc":
    "Modus ponens for if and only if, reversed. If `a â†” b` and `b`, then `a`. ",
    "depth": 5},
   {"type": "âˆ€ {a : Prop}, Â¬Â¬a â†” a",
    "name": "Classical.not_not",
    "isProp": true,
    "doc":
    "The Double Negation Theorem: `Â¬Â¬P` is equivalent to `P`.\nThe left-to-right direction, double negation elimination (DNE),\nis classically true but not constructively. ",
    "depth": 5}],
  "count": 19764},
 {"noDocExamples": [],
  "kind": "Â«term_+_Â»",
  "examples":
  [{"type": "âˆ€ {a : â„•}, Real.sqrt â†‘a â‰¤ â†‘(Nat.sqrt a) + 1",
    "name": "Real.real_sqrt_le_nat_sqrt_succ",
    "isProp": true,
    "doc": "The real square root is at most the natural square root plus one ",
    "depth": 8},
   {"type": "âˆ€ (n : â„•), List.length (List.Nat.antidiagonal n) = n + 1",
    "name": "List.Nat.length_antidiagonal",
    "isProp": true,
    "doc": "The length of the antidiagonal of `n` is `n + 1`. ",
    "depth": 8},
   {"type": "âˆ€ (n : â„•), Finset.card (Finset.antidiagonal n) = n + 1",
    "name": "Finset.Nat.card_antidiagonal",
    "isProp": true,
    "doc": "The cardinality of the antidiagonal of `n` is `n + 1`. ",
    "depth": 8}],
  "count": 19615},
 {"noDocExamples": [],
  "kind": "Â«term_*_Â»",
  "examples":
  [{"type": "âˆ€ (x : SetTheory.PGame), 0 * x â‰ˆ 0",
    "name": "SetTheory.PGame.zero_mul_equiv",
    "isProp": true,
    "doc": "`0 * x` is equivalent to `0`. ",
    "depth": 9},
   {"type":
    "âˆ€ {n : â„•} [inst : NeZero n], Fintype.card (DihedralGroup n) = 2 * n",
    "name": "DihedralGroup.card",
    "isProp": true,
    "doc": "If `0 < n`, then `DihedralGroup n` has `2n` elements.\n",
    "depth": 9},
   {"type":
    "(fun Ï„ => jacobiTheta Ï„ - 1) =O[Filter.comap Complex.im Filter.atTop] fun Ï„ => Real.exp (-Real.pi * Ï„.im)",
    "name": "isBigO_at_im_infty_jacobiTheta_sub_one",
    "isProp": true,
    "doc":
    "The norm of `jacobiTheta Ï„ - 1` decays exponentially as `im Ï„ â†’ âˆ`. ",
    "depth": 9}],
  "count": 17249},
 {"noDocExamples": [],
  "kind": "Â«term_âŸ¶_Â»",
  "examples":
  [{"type":
    "âˆ€ {C : Type u_1} [inst : CategoryTheory.Category.{u_2, u_1} C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  [inst_2 : CategoryTheory.Limits.HasFiniteProducts C] [inst_3 : CategoryTheory.Limits.HasKernels C]\n  [inst_4 : CategoryTheory.NormalMonoCategory C] {X Y : C} (f g : X âŸ¶ Y),\n  CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.parallelPair f g)",
    "name": "CategoryTheory.NormalMonoCategory.hasLimit_parallelPair",
    "isProp": true,
    "doc": "The equalizer of `f` and `g` exists. ",
    "depth": 17},
   {"type":
    "{C : Type uâ‚} â†’\n  [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] â†’\n    {X A : C} â†’ (f : A âŸ¶ X) â†’ [inst_1 : CategoryTheory.Mono f] â†’ CategoryTheory.Subobject X",
    "name": "CategoryTheory.Subobject.mk",
    "isProp": false,
    "doc": "Convenience constructor for a subobject. ",
    "depth": 11},
   {"type": "{X Y Z : Type u} â†’ (X âŸ¶ Z) â†’ (Y âŸ¶ Z) â†’ Type u",
    "name": "CategoryTheory.Limits.Types.PullbackObj",
    "isProp": false,
    "doc":
    "The usual explicit pullback in the category of types, as a subtype of the product.\nThe full `LimitCone` data is bundled as `pullbackLimitCone f g`.\n",
    "depth": 11}],
  "count": 15781},
 {"noDocExamples": [],
  "kind": "Â«term_âˆˆ_Â»",
  "examples":
  [{"type": "âˆ€ (A : Class), Class.iota A âˆˆ Class.univ",
    "name": "Class.iota_ex",
    "isProp": true,
    "doc":
    "Unlike the other set constructors, the `iota` definite descriptor\nis a set for any set input, but not constructively so, so there is no\nassociated `Class â†’ Set` function. ",
    "depth": 6},
   {"type": "âˆ€ {M : Type u_1} [inst : Monoid M] {x : M}, x âˆˆ powers x",
    "name": "powers.self_mem",
    "isProp": true,
    "doc":
    "An element of a monoid is in the set of that element's natural number powers. ",
    "depth": 8},
   {"type": "âˆ€ {M : Type u_1} [inst : AddMonoid M] {x : M}, x âˆˆ multiples x",
    "name": "multiples.self_mem",
    "isProp": true,
    "doc":
    "An element of an `AddMonoid` is in the set of that element's natural number multiples.",
    "depth": 8}],
  "count": 15141},
 {"noDocExamples": [],
  "kind": "Â«term_<_Â»",
  "examples":
  [{"type": "0 < 1",
    "name": "Nat.one_pos",
    "isProp": true,
    "doc": "**Alias** of `Nat.zero_lt_one`.",
    "depth": 5},
   {"type": "âˆ€ (x : â„), 0 < Real.cosh x",
    "name": "Real.cosh_pos",
    "isProp": true,
    "doc": "`Real.cosh` is always positive ",
    "depth": 6},
   {"type": "âˆ€ {n : â„•} (self : Fin n), â†‘self < n",
    "name": "Fin.isLt",
    "isProp": true,
    "doc": "If `i : Fin n`, then `i.2` is a proof that `i.1 < n`. ",
    "depth": 6}],
  "count": 11431},
 {"noDocExamples": [],
  "kind": "termâ„",
  "examples":
  [{"type":
    "âˆ€ {E : Type u_3} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace â„ E] {a b : â„}\n  {f f' : â„ â†’ â„} {g : â„ â†’ E},\n  ContinuousOn f (Set.uIcc a b) â†’\n    (âˆ€ x âˆˆ Set.Ioo (min a b) (max a b), HasDerivWithinAt f (f' x) (Set.Ioi x) x) â†’\n      ContinuousOn f' (Set.uIcc a b) â†’\n        ContinuousOn g (f '' Set.uIcc a b) â†’ âˆ« (x : â„) in a..b, f' x â€¢ (g âˆ˜ f) x = âˆ« (u : â„) in f a..f b, g u",
    "name": "intervalIntegral.integral_comp_smul_deriv''",
    "isProp": true,
    "doc":
    "Change of variables for continuous integrands. If `f` is continuous on `[a, b]` and has\ncontinuous right-derivative `f'` in `(a, b)`, and `g` is continuous on `f '' [a, b]` then we can\nsubstitute `u = f x` to get `âˆ« x in a..b, f' x â€¢ (g âˆ˜ f) x = âˆ« u in f a..f b, g u`.\n",
    "depth": 35},
   {"type":
    "{G : Type u_1} â†’ [inst : AddGroup G] â†’ [inst : TopologicalSpace G] â†’ Set G â†’ Set (TopologicalSpace.Compacts G â†’ â„)",
    "name": "MeasureTheory.Measure.haar.addHaarProduct",
    "isProp": false,
    "doc": "additive version of `MeasureTheory.Measure.haar.haarProduct`",
    "depth": 8},
   {"type":
    "âˆ€ {Î± : Type u_1} [inst : Nonempty Î±] [inst : SemilatticeSup Î±] [inst_1 : NoMaxOrder Î±] {Î² : Type u_5}\n  [inst_2 : SeminormedAddCommGroup Î²] {f : Î± â†’ Î²} {b : Î²},\n  Filter.Tendsto f Filter.atTop (nhds b) â†” âˆ€ (Îµ : â„), 0 < Îµ â†’ âˆƒ N, âˆ€ (n : Î±), N < n â†’ â€–f n - bâ€– < Îµ",
    "name": "NormedAddCommGroup.tendsto_atTop'",
    "isProp": true,
    "doc":
    "A variant of `NormedAddCommGroup.tendsto_atTop` that\nuses `âˆƒ N, âˆ€ n > N, ...` rather than `âˆƒ N, âˆ€ n â‰¥ N, ...`\n",
    "depth": 27}],
  "count": 10257},
 {"noDocExamples": [],
  "kind": "Lean.Parser.Term.prop",
  "examples":
  [{"type": "âˆ€ {Î± : Prop}, Î±",
    "name": "lcProof",
    "isProp": true,
    "doc":
    "Auxiliary unsafe constant used by the Compiler when erasing proofs from code.\n\nIt may look strange to have an axiom that says \"every proposition is true\",\nsince this is obviously unsound, but the `unsafe` marker ensures that the\nkernel will not let this through into regular proofs. The lower levels of the\ncode generator don't need proofs in terms, so this is used to stub the proofs\nout.\n",
    "depth": 1},
   {"type": "(X : Type u) â†’ [inst : TopologicalSpace X] â†’ Prop",
    "name": "CompletelyRegularSpace",
    "isProp": false,
    "doc":
    "A space is completely regular if points can be separated from closed sets via\ncontinuous functions to the unit interval. ",
    "depth": 3},
   {"type":
    "(ğ•œ : Type u_1) â†’\n  {E : Type u_2} â†’ [inst : OrderedSemiring ğ•œ] â†’ [inst : AddCommMonoid E] â†’ [inst : SMul ğ•œ E] â†’ Set E â†’ Prop",
    "name": "Convex",
    "isProp": false,
    "doc": "Convexity of sets. ",
    "depth": 7}],
  "count": 10062},
 {"noDocExamples": [],
  "kind": "Std.Tactic.Coe.coeFunNotation",
  "examples":
  [{"type": "âˆ€ {Î± : Type u_1} (f : Poly Î±), IsPoly â‡‘f",
    "name": "Poly.isPoly",
    "isProp": true,
    "doc": "The underlying function of a `Poly` is a polynomial ",
    "depth": 9},
   {"type": "âˆ€ {Î± : Sort u} {Î² : Sort v}, Function.Injective fun e => â‡‘e",
    "name": "Equiv.coe_fn_injective",
    "isProp": true,
    "doc": "The map `(r â‰ƒ s) â†’ (r â†’ s)` is injective. ",
    "depth": 11},
   {"type":
    "âˆ€ {Î± : Type u_1} [inst : Subsingleton Î±] (e : Equiv.Perm Î±), â‡‘e = id",
    "name": "Equiv.Perm.coe_subsingleton",
    "isProp": true,
    "doc":
    "This cannot be a `simp` lemmas as it incorrectly matches against `e : Î± â‰ƒ synonym Î±`, when\n`synonym Î±` is semireducible. This makes a mess of `Multiplicative.ofAdd` etc. ",
    "depth": 11}],
  "count": 9937},
 {"noDocExamples": [],
  "kind": "Lean.Parser.Term.hole",
  "examples":
  [{"type":
    "âˆ€ {Î¼ : YoungDiagram},\n  YoungDiagram.ofRowLens (YoungDiagram.rowLens Î¼) (_ : List.Sorted (fun x x_1 => x â‰¥ x_1) (YoungDiagram.rowLens Î¼)) = Î¼",
    "name": "YoungDiagram.ofRowLens_to_rowLens_eq_self",
    "isProp": true,
    "doc": "The left_inv direction of the equivalence ",
    "depth": 6},
   {"type":
    "âˆ€ {Î± : Sort u_1} {p : Î± â†’ Prop} {q : (x : Î±) â†’ p x â†’ Prop},\n  (âˆ€ (x : Î±) (h : p x), q x h) â†” âˆ€ (x : { a // p a }), q â†‘x (_ : p â†‘x)",
    "name": "Subtype.forall'",
    "isProp": true,
    "doc":
    "An alternative version of `Subtype.forall`. This one is useful if Lean cannot figure out `q`\nwhen using `Subtype.forall` from right to left. ",
    "depth": 11},
   {"type":
    "âˆ€ {Î± : Type u_1} {s : Set (Set Î±)} (hs : IsPiSystem s),\n  MeasurableSpace.generateFrom s =\n    MeasurableSpace.DynkinSystem.toMeasurableSpace (MeasurableSpace.DynkinSystem.generate s)\n      (_ :\n        âˆ€ (tâ‚ tâ‚‚ : Set Î±),\n          MeasurableSpace.DynkinSystem.Has (MeasurableSpace.DynkinSystem.generate s) tâ‚ â†’\n            MeasurableSpace.DynkinSystem.Has (MeasurableSpace.DynkinSystem.generate s) tâ‚‚ â†’\n              MeasurableSpace.DynkinSystem.Has (MeasurableSpace.DynkinSystem.generate s) (tâ‚ âˆ© tâ‚‚))",
    "name": "MeasurableSpace.DynkinSystem.generateFrom_eq",
    "isProp": true,
    "doc":
    "**Dynkin's Ï€-Î» theorem**:\nGiven a collection of sets closed under binary intersections, then the Dynkin system it\ngenerates is equal to the Ïƒ-algebra it generates.\nThis result is known as the Ï€-Î» theorem.\nA collection of sets closed under binary intersection is called a Ï€-system (often requiring\nadditionally that it is non-empty, but we drop this condition in the formalization).\n",
    "depth": 12}],
  "count": 8555},
 {"noDocExamples": [],
  "kind": "Â«term_â‰ _Â»",
  "examples":
  [{"type": "âˆ€ (self : â„š), self.den â‰  0",
    "name": "Rat.den_nz",
    "isProp": true,
    "doc": "The denominator is nonzero. ",
    "depth": 5},
   {"type": "âˆ€ {a b : â„•}, b < a â†’ a â‰  b",
    "name": "Nat.ne_of_lt'",
    "isProp": true,
    "doc": "**Alias** of `Nat.ne_of_gt`.",
    "depth": 7},
   {"type":
    "âˆ€ {Mâ‚€ : Type u_2} [inst : MonoidWithZero Mâ‚€] [inst_1 : Nontrivial Mâ‚€] (u : Mâ‚€Ë£), â†‘u â‰  0",
    "name": "Units.ne_zero",
    "isProp": true,
    "doc":
    "An element of the unit group of a nonzero monoid with zero represented as an element\nof the monoid is nonzero. ",
    "depth": 10}],
  "count": 8300},
 {"noDocExamples": [],
  "kind": "Â«term_â€¢_Â»",
  "examples":
  [{"type": "âˆ€ {M : Type u} [inst : AddMonoid M] (a : M), 2 â€¢ a = a + a",
    "name": "two_nsmul",
    "isProp": true,
    "doc": "",
    "depth": 11},
   {"type": "âˆ€ (n k : â„•), Nat.factorization (n ^ k) = k â€¢ Nat.factorization n",
    "name": "Nat.factorization_pow",
    "isProp": true,
    "doc":
    "For any `p`, the power of `p` in `n^k` is `k` times the power in `n` ",
    "depth": 11},
   {"type":
    "âˆ€ {G : Type u_1} [inst : AddMonoid G] {x : G}, (Function.Injective fun n => n â€¢ x) â†’ Â¬IsOfFinAddOrder x",
    "name": "not_isOfFinAddOrder_of_injective_nsmul",
    "isProp": true,
    "doc": "See also `injective_nsmul_iff_not_isOfFinAddOrder`.",
    "depth": 12}],
  "count": 8191},
 {"noDocExamples": [],
  "kind": "Lean.Parser.Term.typeAscription",
  "examples":
  [{"type":
    "âˆ€ {Î¼ : YoungDiagram},\n  YoungDiagram.ofRowLens (YoungDiagram.rowLens Î¼) (_ : List.Sorted (fun x x_1 => x â‰¥ x_1) (YoungDiagram.rowLens Î¼)) = Î¼",
    "name": "YoungDiagram.ofRowLens_to_rowLens_eq_self",
    "isProp": true,
    "doc": "The left_inv direction of the equivalence ",
    "depth": 6},
   {"type":
    "âˆ€ {Î± : Type u_1} (r : Setoid Î±), Setoid.mkClasses (Setoid.classes r) (_ : âˆ€ (a : Î±), âˆƒ! b x, a âˆˆ b) = r",
    "name": "Setoid.mkClasses_classes",
    "isProp": true,
    "doc":
    "The equivalence relation made from the equivalence classes of an equivalence\nrelation r equals r. ",
    "depth": 8},
   {"type": "âˆ€ {n m : â„•} (h : Fin n = Fin m), cast h = Fin.cast (_ : n = m)",
    "name": "Fin.cast_eq_cast'",
    "isProp": true,
    "doc":
    "A reversed version of `Fin.cast_eq_cast` that is easier to rewrite with. ",
    "depth": 9}],
  "count": 8063},
 {"noDocExamples": [],
  "kind": "Lean.Parser.Term.structInst",
  "examples":
  [{"type": "âˆ€ {Î± : Sort u} (a : Î±), { down := a }.down = a",
    "name": "PLift.down_up",
    "isProp": true,
    "doc": "Bijection between `Î±` and `PLift Î±` ",
    "depth": 7},
   {"type": "âˆ€ {Î± : Type u} (b : ULift.{v, u} Î±), { down := b.down } = b",
    "name": "ULift.up_down",
    "isProp": true,
    "doc": "Bijection between `Î±` and `ULift.{v} Î±` ",
    "depth": 7},
   {"type": "âˆ€ {Î± : Sort u} (b : PLift Î±), { down := b.down } = b",
    "name": "PLift.up_down",
    "isProp": true,
    "doc": "Bijection between `Î±` and `PLift Î±` ",
    "depth": 7}],
  "count": 7614},
 {"noDocExamples": [],
  "kind": "Std.Tactic.Coe.coeSortNotation",
  "examples":
  [{"type": "âˆ€ {a : â„}, DiscreteTopology â†¥(AddSubgroup.zmultiples a)",
    "name":
    "Int.instDiscreteTopologySubtypeRealMemAddSubgroupInstAddGroupRealInstMembershipInstSetLikeAddSubgroupZmultiplesInstTopologicalSpaceSubtypeToTopologicalSpaceToUniformSpacePseudoMetricSpace",
    "isProp": true,
    "doc":
    "This is a special case of `NormedSpace.discreteTopology_zmultiples`. It exists only to simplify\ndependencies. ",
    "depth": 13},
   {"type":
    "{S : Type u_5} â†’\n  [inst : Semiring S] â†’\n    {M : Type u_6} â†’\n      [inst_1 : AddCommMonoid M] â†’\n        [inst_2 : Module S M] â†’ {m : Submodule S M} â†’ {f : M â†’â‚—[S] M} â†’ LinearMap.IsProj m f â†’ M â†’â‚—[S] â†¥m",
    "name": "LinearMap.IsProj.codRestrict",
    "isProp": false,
    "doc":
    "Restriction of the codomain of a projection of onto a subspace `p` to `p` instead of the whole\nspace.\n",
    "depth": 26},
   {"type":
    "{R : Type u_1} â†’\n  [inst : CommRing R] â†’\n    (S : Submonoid R) â†’\n      {M : Type u_2} â†’\n        {M'' : Type u_4} â†’\n          [inst_1 : AddCommMonoid M] â†’\n            [inst_2 : AddCommMonoid M''] â†’\n              [inst_3 : Module R M] â†’\n                [inst_4 : Module R M''] â†’\n                  (M â†’â‚—[R] M'') â†’\n                    (âˆ€ (x : â†¥S), IsUnit ((algebraMap R (Module.End R M'')) â†‘x)) â†’ LocalizedModule S M â†’ M''",
    "name": "LocalizedModule.lift'",
    "isProp": false,
    "doc":
    "If `g` is a linear map `M â†’ M''` such that all scalar multiplication by `s : S` is invertible, then\nthere is a linear map `LocalizedModule S M â†’ M''`.\n",
    "depth": 33}],
  "count": 6493},
 {"noDocExamples": [],
  "kind": "Â«term_âˆ§_Â»",
  "examples":
  [{"type": "âˆ€ {a b : Prop}, a âˆ§ b â†’ a",
    "name": "And.left",
    "isProp": true,
    "doc":
    "Extract the left conjunct from a conjunction. `h : a âˆ§ b` then\n`h.left`, also notated as `h.1`, is a proof of `a`. ",
    "depth": 5},
   {"type": "âˆ€ {a b : Prop}, a âˆ§ b â†’ b",
    "name": "And.right",
    "isProp": true,
    "doc":
    "Extract the right conjunct from a conjunction. `h : a âˆ§ b` then\n`h.right`, also notated as `h.2`, is a proof of `b`. ",
    "depth": 5},
   {"type": "âˆ€ {a b : Prop}, a â†’ b â†’ a âˆ§ b",
    "name": "And.intro",
    "isProp": true,
    "doc":
    "`And.intro : a â†’ b â†’ a âˆ§ b` is the constructor for the And operation. ",
    "depth": 6}],
  "count": 6343},
 {"noDocExamples": [],
  "kind": "Lean.Parser.Term.sort",
  "examples":
  [{"type": "{Î± : Sort u} â†’ {Î² : Sort v} â†’ (Î± â†’ Î²) â†’ PLift Î± â†’ PLift Î²",
    "name": "PLift.map",
    "isProp": false,
    "doc": "Functorial action. ",
    "depth": 5},
   {"type":
    "{Î¹ : Sort u_1} â†’ {Î± : Î¹ â†’ Sort u_2} â†’ [inst : Unique Î¹] â†’ Î± default â†’ (i : Î¹) â†’ Î± i",
    "name": "uniqueElim",
    "isProp": false,
    "doc": "Given one value over a unique, we get a dependent function. ",
    "depth": 8},
   {"type":
    "âˆ€ {F : Sort u_1} {Î± : outParam (Sort u_2)} {Î² : outParam (Î± â†’ Sort u_3)} [self : FunLike F Î± Î²],\n  Function.Injective FunLike.coe",
    "name": "FunLike.coe_injective'",
    "isProp": true,
    "doc": "The coercion to functions must be injective. ",
    "depth": 9}],
  "count": 6275},
 {"noDocExamples": [],
  "kind": "Â«term_-_Â»",
  "examples":
  [{"type":
    "âˆ€ (L : List â„•), List.sum (List.tail L) = List.sum L - List.headI L",
    "name": "List.tail_sum",
    "isProp": true,
    "doc": "This relies on `default â„• = 0`. ",
    "depth": 8},
   {"type":
    "(fun Ï„ => jacobiTheta Ï„ - 1) =O[Filter.comap Complex.im Filter.atTop] fun Ï„ => Real.exp (-Real.pi * Ï„.im)",
    "name": "isBigO_at_im_infty_jacobiTheta_sub_one",
    "isProp": true,
    "doc":
    "The norm of `jacobiTheta Ï„ - 1` decays exponentially as `im Ï„ â†’ âˆ`. ",
    "depth": 9},
   {"type": "âˆ€ {a : ENNReal}, a - âŠ¤ = 0",
    "name": "ENNReal.sub_top",
    "isProp": true,
    "doc":
    "This is a special case of `WithTop.sub_top` in the `ENNReal` namespace ",
    "depth": 9}],
  "count": 6266},
 {"noDocExamples": [],
  "kind": "Â«term_^_Â»",
  "examples":
  [{"type": "âˆ€ {q : â„•+}, Fintype.card (LucasLehmer.X q) = â†‘q ^ 2",
    "name": "LucasLehmer.X.card_eq",
    "isProp": true,
    "doc": "The cardinality of `X` is `q^2`. ",
    "depth": 8},
   {"type": "LinearRecurrence.IsSolution fibRec fun x => goldenConj ^ x",
    "name": "geom_goldConj_isSol_fibRec",
    "isProp": true,
    "doc": "The geometric sequence `fun n â†¦ Ïˆ^n` is a solution of `fibRec`. ",
    "depth": 8},
   {"type": "âˆ€ (a : â„¤), â†‘(Int.natAbs a) â‰¤ a ^ 2",
    "name": "Int.natAbs_le_self_pow_two",
    "isProp": true,
    "doc": "**Alias** of `Int.natAbs_le_self_sq`.",
    "depth": 8}],
  "count": 5999},
 {"noDocExamples": [],
  "kind": "Std.ExtendedBinder.Â«termâˆ€__,_Â»",
  "examples":
  [{"type": "âˆ€ (S : Set â„), (âˆ€ x âˆˆ S, x â‰¤ 0) â†’ sSup S â‰¤ 0",
    "name": "Real.sSup_nonpos",
    "isProp": true,
    "doc":
    "As `0` is the default value for `Real.sSup` of the empty set, it suffices to show that `S` is\nbounded above by `0` to show that `sSup S â‰¤ 0`.\n",
    "depth": 9},
   {"type": "âˆ€ (S : Set â„), (âˆ€ x âˆˆ S, x â‰¤ 0) â†’ sInf S â‰¤ 0",
    "name": "Real.sInf_nonpos",
    "isProp": true,
    "doc":
    "As `0` is the default value for `Real.sInf` of the empty set or sets which are not bounded below, it\nsuffices to show that `S` is bounded above by `0` to show that `sInf S â‰¤ 0`.\n",
    "depth": 9},
   {"type":
    "âˆ€ {Î± : Type u_1} (M : Matroid Î±), âˆ€ X âŠ† M.E, Matroid.ExistsMaximalSubsetProperty M.Indep X",
    "name": "Matroid.existsMaximalSubsetProperty_indep",
    "isProp": true,
    "doc": "Matroids obey the maximality axiom ",
    "depth": 9}],
  "count": 5718},
 {"noDocExamples": [],
  "kind": "Â«termâˆƒ_,_Â»",
  "examples":
  [{"type": "âˆ€ {p : â„• â†’ Prop}, (âˆƒ x, p x) â†’ WellFounded (Nat.Upto.GT p)",
    "name": "Nat.Upto.wf",
    "isProp": true,
    "doc":
    "The \"greater than\" relation on `Upto p` is well founded if (and only if) there exists a value\nsatisfying `p`. ",
    "depth": 5},
   {"type": "âˆ€ (p : True â†’ Prop), (âˆƒ (x : True), p x) â†” p True.intro",
    "name": "exists_true_left",
    "isProp": true,
    "doc": "See `IsEmpty.exists_iff` for the `False` version. ",
    "depth": 6},
   {"type":
    "âˆ€ (G : Type u_1) [inst : Monoid G], Â¬Monoid.IsTorsion G â†” âˆƒ g, Â¬IsOfFinOrder g",
    "name": "Monoid.not_isTorsion_iff",
    "isProp": true,
    "doc":
    "A monoid is not a torsion monoid if it has an element of infinite order. ",
    "depth": 9}],
  "count": 5673},
 {"noDocExamples": [],
  "kind": "termâ„¤",
  "examples":
  [{"type":
    "âˆ€ {a b c : â„¤}, a % b = c â†’ Int.natAbs (a - c) < Int.natAbs b â†’ a = c",
    "name": "Int.eq_of_mod_eq_of_natAbs_sub_lt_natAbs",
    "isProp": true,
    "doc":
    "If two integers are congruent to a sufficiently large modulus,\nthey are equal. ",
    "depth": 14},
   {"type":
    "âˆ€ {R : Type u_1} {Î¹ : Type u_2} {A : Type u_3} {B : Type u_4} [inst : CommSemiring Î¹] [inst_1 : Module Î¹ (Additive â„¤Ë£)]\n  [inst_2 : DecidableEq Î¹] [inst_3 : CommRing R] [inst_4 : Ring A] [inst_5 : Ring B] [inst_6 : Algebra R A]\n  [inst_7 : Algebra R B] (ğ’œ : Î¹ â†’ Submodule R A) (â„¬ : Î¹ â†’ Submodule R B) [inst_8 : GradedAlgebra ğ’œ]\n  [inst_9 : GradedAlgebra â„¬] {jâ‚ : Î¹} (aâ‚ : A) (bâ‚ : â†¥(â„¬ jâ‚)) (aâ‚‚ : â†¥(ğ’œ 0)) (bâ‚‚ : B),\n  aâ‚ áµâŠ—â‚œ[R] â†‘bâ‚ * â†‘aâ‚‚ áµâŠ—â‚œ[R] bâ‚‚ = (aâ‚ * â†‘aâ‚‚) áµâŠ—â‚œ[R] (â†‘bâ‚ * bâ‚‚)",
    "name": "GradedTensorProduct.tmul_coe_mul_zero_coe_tmul",
    "isProp": true,
    "doc": "A special case for when `aâ‚‚` has grade 0. ",
    "depth": 44},
   {"type": "â„¤ â†’ â„¤",
    "name": "Int.div2",
    "isProp": false,
    "doc": "`div2 n = n/2`",
    "depth": 1}],
  "count": 5211},
 {"noDocExamples": [],
  "kind": "Â«term-_Â»",
  "examples":
  [{"type": "goldenConjâ»Â¹ = -goldenRatio",
    "name": "inv_goldConj",
    "isProp": true,
    "doc": "The opposite of the golden ratio is the inverse of its conjugate. ",
    "depth": 5},
   {"type": "goldenRatioâ»Â¹ = -goldenConj",
    "name": "inv_gold",
    "isProp": true,
    "doc": "The inverse of the golden ratio is the opposite of its conjugate. ",
    "depth": 5},
   {"type": "âˆ€ (n : â„•), padicValRat 2 (harmonic n) = -â†‘(Nat.log 2 n)",
    "name": "padicValRat_two_harmonic",
    "isProp": true,
    "doc":
    "The 2-adic valuation of the n-th harmonic number is the negative of the logarithm\nof n. ",
    "depth": 9}],
  "count": 5085},
 {"noDocExamples": [],
  "kind": "Â«term_Ã—_Â»",
  "examples":
  [{"type":
    "âˆ€ {b o : Ordinal.{u}} {x : Ordinal.{u} Ã— Ordinal.{u}}, x âˆˆ Ordinal.CNF b o â†’ 0 < x.2",
    "name": "Ordinal.CNF_lt_snd",
    "isProp": true,
    "doc": "Every coefficient in a Cantor normal form is positive. ",
    "depth": 11},
   {"type":
    "(C : Type uâ‚) â†’\n  [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] â†’\n    (D : Type uâ‚) â†’ [inst : CategoryTheory.Category.{vâ‚, uâ‚} D] â†’ CategoryTheory.Category.{vâ‚, uâ‚} (C Ã— D)",
    "name": "CategoryTheory.uniformProd",
    "isProp": false,
    "doc":
    "`Category.uniformProd C D` is an additional instance specialised so both factors have the same\nuniverse levels. This helps typeclass resolution.\n",
    "depth": 7},
   {"type":
    "âˆ€ {Î± : Type u_1} {Î² : Type u_3} [inst : MeasurableSpace Î±] [inst_1 : MeasurableSpace Î²] {Î¼ : MeasureTheory.Measure Î±}\n  [inst_2 : MeasureTheory.SFinite Î¼] {f : Î± Ã— Î² â†’ ENNReal}, Measurable f â†’ Measurable fun y => âˆ«â» (x : Î±), f (x, y) âˆ‚Î¼",
    "name": "Measurable.lintegral_prod_left'",
    "isProp": true,
    "doc":
    "The Lebesgue integral is measurable. This shows that the integrand of (the right-hand-side of)\nthe symmetric version of Tonelli's theorem is measurable. ",
    "depth": 17}],
  "count": 4961},
 {"noDocExamples": [],
  "kind": "Â«term_âŠ†_Â»",
  "examples":
  [{"type": "âˆ€ {x : ZFSet}, ZFSet.IsTransitive x â†’ x âŠ† ZFSet.powerset x",
    "name": "ZFSet.IsTransitive.subset_powerset",
    "isProp": true,
    "doc":
    "**Alias** of the forward direction of `ZFSet.isTransitive_iff_subset_powerset`.",
    "depth": 6},
   {"type": "âˆ€ {A : Class}, Class.powerset A âŠ† A â†’ A = Class.univ",
    "name": "Class.eq_univ_of_powerset_subset",
    "isProp": true,
    "doc":
    "An induction principle for sets. If every subset of a class is a member, then the class is\nuniversal. ",
    "depth": 6},
   {"type": "âˆ€ {x : ZFSet}, ZFSet.IsTransitive x â†’ â‹ƒâ‚€ x âŠ† x",
    "name": "ZFSet.IsTransitive.sUnion_subset",
    "isProp": true,
    "doc":
    "**Alias** of the forward direction of `ZFSet.isTransitive_iff_sUnion_subset`.",
    "depth": 6}],
  "count": 4702},
 {"noDocExamples": [],
  "kind": "Â«termâŠ¤Â»",
  "examples":
  [{"type":
    "âˆ€ {Î± : Type u_1} [inst : Monoid Î±], Monoid.IsTorsionFree Î± â†’ Monoid.minOrder Î± = âŠ¤",
    "name": "Monoid.IsTorsionFree.minOrder",
    "isProp": true,
    "doc": "**Alias** of the reverse direction of `Monoid.minOrder_eq_top`.",
    "depth": 7},
   {"type":
    "âˆ€ {Î± : Type u_1} {G : SimpleGraph Î±}, SimpleGraph.IsAcyclic G â†’ SimpleGraph.girth G = âŠ¤",
    "name": "SimpleGraph.IsAcyclic.girth_eq_top",
    "isProp": true,
    "doc": "**Alias** of the reverse direction of `SimpleGraph.girth_eq_top`.",
    "depth": 7},
   {"type":
    "âˆ€ {Î± : Type u} [inst : Subsingleton Î±] (l : Filter Î±) [inst : Filter.NeBot l], l = âŠ¤",
    "name": "Filter.eq_top_of_neBot",
    "isProp": true,
    "doc":
    "There are only two filters on a `subsingleton`: `âŠ¥` and `âŠ¤`. If the type is empty, then they are\nequal. ",
    "depth": 8}],
  "count": 4497},
 {"noDocExamples": [],
  "kind": "Â«term_/_Â»",
  "examples":
  [{"type": "riemannZeta 0 = -1 / 2",
    "name": "riemannZeta_zero",
    "isProp": true,
    "doc": "We have `Î¶(0) = -1 / 2`. ",
    "depth": 8},
   {"type": "Â¬Summable fun n => 1 / â†‘n",
    "name": "Real.not_summable_one_div_nat_cast",
    "isProp": true,
    "doc": "Harmonic series is not unconditionally summable. ",
    "depth": 9},
   {"type": "Real.sin (Real.pi / 3) = Real.sqrt 3 / 2",
    "name": "Real.sin_pi_div_three",
    "isProp": true,
    "doc": "The sine of `Ï€ / 3` is `âˆš3 / 2`. ",
    "depth": 10}],
  "count": 3866},
 {"noDocExamples": [],
  "kind": "Â«term_â»Â¹Â»",
  "examples":
  [{"type": "goldenConjâ»Â¹ = -goldenRatio",
    "name": "inv_goldConj",
    "isProp": true,
    "doc": "The opposite of the golden ratio is the inverse of its conjugate. ",
    "depth": 5},
   {"type": "goldenRatioâ»Â¹ = -goldenConj",
    "name": "inv_gold",
    "isProp": true,
    "doc": "The inverse of the golden ratio is the opposite of its conjugate. ",
    "depth": 5},
   {"type": "âˆ€ {p : â„•}, 1 < p â†’ padicNorm p â†‘p = (â†‘p)â»Â¹",
    "name": "padicNorm.padicNorm_p",
    "isProp": true,
    "doc":
    "The `p`-adic norm of `p` is `pâ»Â¹` if `p > 1`.\n\nSee also `padicNorm.padicNorm_p_of_prime` for a version assuming `p` is prime. ",
    "depth": 9}],
  "count": 3271},
 {"noDocExamples": [],
  "kind": "Â«term_âˆ˜_Â»",
  "examples":
  [{"type": "Antitone (Stirling.stirlingSeq âˆ˜ Nat.succ)",
    "name": "Stirling.stirlingSeq'_antitone",
    "isProp": true,
    "doc": "The sequence `stirlingSeq âˆ˜ succ` is monotone decreasing ",
    "depth": 6},
   {"type": "Antitone (Real.log âˆ˜ Stirling.stirlingSeq âˆ˜ Nat.succ)",
    "name": "Stirling.log_stirlingSeq'_antitone",
    "isProp": true,
    "doc": "The sequence `log âˆ˜ stirlingSeq âˆ˜ succ` is monotone decreasing ",
    "depth": 7},
   {"type":
    "Cardinal.ord âˆ˜ Cardinal.aleph' = Ordinal.enumOrd {b | Cardinal.ord (Ordinal.card b) = b}",
    "name": "Cardinal.ord_aleph'_eq_enum_card",
    "isProp": true,
    "doc": "`ord âˆ˜ aleph'` enumerates the ordinals that are cardinals. ",
    "depth": 8}],
  "count": 3034},
 {"noDocExamples": [],
  "kind": "Â«term_â†’+*_Â»",
  "examples":
  [{"type":
    "{R : Type u} â†’ {S : Type v} â†’ [inst : Semiring R] â†’ [inst_1 : Semiring S] â†’ (R â†’+* S) â†’ Polynomial R â†’ Polynomial S",
    "name": "Polynomial.map",
    "isProp": false,
    "doc": "`map f p` maps a polynomial `p` across a ring hom `f` ",
    "depth": 9},
   {"type":
    "{R : Type u_1} â†’ {S : Type u_2} â†’ [inst : Semiring R] â†’ [inst_1 : Semiring S] â†’ (R â†’+* S) â†’ S â†’ Polynomial R â†’ S",
    "name": "Polynomial.evalâ‚‚",
    "isProp": false,
    "doc":
    "Evaluate a polynomial `p` given a ring hom `f` from the scalar ring\nto the target and a value `x` for the variable in the target ",
    "depth": 9},
   {"type":
    "{R : Type uâ‚} â†’ {S : Type uâ‚‚} â†’ [inst : Ring R] â†’ [inst_1 : Ring S] â†’ (R â†’+* S) â†’ ModuleCat S â†’ ModuleCat R",
    "name": "ModuleCat.RestrictScalars.obj'",
    "isProp": false,
    "doc":
    "Any `S`-module M is also an `R`-module via a ring homomorphism `f : R âŸ¶ S` by defining\n`r â€¢ m := f r â€¢ m` (`Module.compHom`). This is called restriction of scalars. ",
    "depth": 10}],
  "count": 2899},
 {"noDocExamples": [],
  "kind": "Â«term{_}Â»",
  "examples":
  [{"type": "Multiset.Nat.antidiagonal 0 = {(0, 0)}",
    "name": "Multiset.Nat.antidiagonal_zero",
    "isProp": true,
    "doc": "The antidiagonal of `0` is the list `[(0, 0)]` ",
    "depth": 7},
   {"type": "Finset.antidiagonal 0 = {(0, 0)}",
    "name": "Finset.Nat.antidiagonal_zero",
    "isProp": true,
    "doc": "The antidiagonal of `0` is the list `[(0, 0)]` ",
    "depth": 7},
   {"type":
    "âˆ€ {P : Type u_2} [inst : MetricSpace P] (p : P), EuclideanGeometry.Cospherical {p}",
    "name": "EuclideanGeometry.cospherical_singleton",
    "isProp": true,
    "doc": "A single point is cospherical. ",
    "depth": 8}],
  "count": 2799},
 {"noDocExamples": [],
  "kind": "Â«termÂ¬_Â»",
  "examples":
  [{"type": "Â¬Small.{u, max (u + 1) (v + 1)} Ordinal.{max u v}",
    "name": "not_small_ordinal",
    "isProp": true,
    "doc":
    "The type of ordinals in universe `u` is not `Small.{u}`. This is the type-theoretic analog of\nthe Burali-Forti paradox. ",
    "depth": 2},
   {"type": "Â¬Set.Countable Set.univ",
    "name": "Cardinal.not_countable_real",
    "isProp": true,
    "doc":
    "**Non-Denumerability of the Continuum**: The reals are not countable. ",
    "depth": 3},
   {"type": "âˆ€ (p : Prop), p âˆ¨ Â¬p",
    "name": "em",
    "isProp": true,
    "doc":
    "**Alias** of `Classical.em`.\n\n---\n\nDiaconescu's theorem: excluded middle from choice, Function extensionality and propositional extensionality. ",
    "depth": 3}],
  "count": 2789},
 {"noDocExamples": [],
  "kind": "Â«term_áµ’áµ–Â»",
  "examples":
  [{"type":
    "{C : Type uâ‚} â†’\n  [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] â†’\n    {D : Type uâ‚‚} â†’\n      [inst_1 : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D] â†’\n        {J : Type w} â†’\n          [inst_2 : CategoryTheory.Category.{w', w} J] â†’\n            (K : CategoryTheory.Functor J Cáµ’áµ–) â†’\n              (F : CategoryTheory.Functor C D) â†’\n                [inst_3 : CategoryTheory.Limits.PreservesLimit K.leftOp F] â†’\n                  CategoryTheory.Limits.PreservesColimit K F.op",
    "name": "CategoryTheory.Limits.preservesColimitOp",
    "isProp": false,
    "doc":
    "If `F : C â¥¤ D` preserves limits of `K.left_op : Jáµ’áµ– â¥¤ C`, then `F.op : Cáµ’áµ– â¥¤ Dáµ’áµ–` preserves\ncolimits of `K : J â¥¤ Cáµ’áµ–`. ",
    "depth": 18},
   {"type":
    "âˆ€ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] (P : CategoryTheory.Functor Cáµ’áµ– (Type (max v u))) {X : C}\n  (S : CategoryTheory.Sieve X),\n  CategoryTheory.Presieve.IsSheafFor P S.arrows â†”\n    Nonempty\n      (CategoryTheory.Limits.IsLimit\n        (CategoryTheory.Limits.Fork.ofÎ¹ (CategoryTheory.Equalizer.forkMap P S.arrows)\n          (_ :\n            CategoryTheory.CategoryStruct.comp (CategoryTheory.Equalizer.forkMap P S.arrows)\n                (CategoryTheory.Equalizer.Sieve.firstMap P S) =\n              CategoryTheory.CategoryStruct.comp (CategoryTheory.Equalizer.forkMap P S.arrows)\n                (CategoryTheory.Equalizer.Sieve.secondMap P S))))",
    "name": "CategoryTheory.Equalizer.Sieve.equalizer_sheaf_condition",
    "isProp": true,
    "doc":
    "`P` is a sheaf for `S`, iff the fork given by `w` is an equalizer. ",
    "depth": 20},
   {"type":
    "(S : CategoryTheory.Functor Type uáµ’áµ– (Type u)) â†’\n  CategoryTheory.Presieve.IsSheaf CategoryTheory.typesGrothendieckTopology S â†’\n    (Î± : Type u) â†’ (Î± â†’ S.obj (Opposite.op PUnit.{u + 1})) â†’ S.obj (Opposite.op Î±)",
    "name": "CategoryTheory.typesGlue",
    "isProp": false,
    "doc":
    "Given a sheaf `S` on the category of types, construct a map\n`(Î± â†’ S(*)) â†’ S(Î±)` that is inverse to `eval`. ",
    "depth": 14}],
  "count": 2746},
 {"noDocExamples": [],
  "kind": "CategoryTheory.Â«term_â‰…_Â»",
  "examples":
  [{"type":
    "{C : Type u} â†’\n  [inst : CategoryTheory.Category.{v, u} C] â†’\n    {X Y : C} â†’ CategoryTheory.Limits.IsZero X â†’ CategoryTheory.Limits.IsInitial Y â†’ (X â‰… Y)",
    "name": "CategoryTheory.Limits.IsZero.isoIsInitial",
    "isProp": false,
    "doc":
    "The (unique) isomorphism between any initial object and the zero object. ",
    "depth": 10},
   {"type": "{X Y : Stonean} â†’ CoeSort.coe X â‰ƒâ‚œ CoeSort.coe Y â†’ (X â‰… Y)",
    "name": "Stonean.isoOfHomeo",
    "isProp": false,
    "doc": "Construct an isomorphism from a homeomorphism. ",
    "depth": 11},
   {"type":
    "(C : Type u) â†’\n  (A : Type u_1) â†’\n    [inst : CategoryTheory.Category.{v, u} C] â†’\n      [inst_1 : AddMonoid A] â†’\n        [inst_2 : CategoryTheory.HasShift C A] â†’ CategoryTheory.shiftFunctor C 0 â‰… CategoryTheory.Functor.id C",
    "name": "CategoryTheory.shiftFunctorZero",
    "isProp": false,
    "doc": "Shifting by zero is the identity functor. ",
    "depth": 13}],
  "count": 2731},
 {"noDocExamples": [],
  "kind": "Lean.Parser.Term.tuple",
  "examples":
  [{"type": "Multiset.Nat.antidiagonal 0 = {(0, 0)}",
    "name": "Multiset.Nat.antidiagonal_zero",
    "isProp": true,
    "doc": "The antidiagonal of `0` is the list `[(0, 0)]` ",
    "depth": 7},
   {"type": "Finset.antidiagonal 0 = {(0, 0)}",
    "name": "Finset.Nat.antidiagonal_zero",
    "isProp": true,
    "doc": "The antidiagonal of `0` is the list `[(0, 0)]` ",
    "depth": 7},
   {"type": "List.Nat.antidiagonal 0 = [(0, 0)]",
    "name": "List.Nat.antidiagonal_zero",
    "isProp": true,
    "doc": "The antidiagonal of `0` is the list `[(0, 0)]` ",
    "depth": 8}],
  "count": 2693},
 {"noDocExamples": [],
  "kind": "Â«termâ€–_â€–Â»",
  "examples":
  [{"type": "âˆ€ {Î± : Type u_5} [self : NontriviallyNormedField Î±], âˆƒ x, 1 < â€–xâ€–",
    "name": "NontriviallyNormedField.non_trivial",
    "isProp": true,
    "doc": "The norm attains a value exceeding 1. ",
    "depth": 10},
   {"type":
    "âˆ€ {Î± : Type u_5} [inst : Norm Î±] [inst_1 : One Î±] [self : NormOneClass Î±], â€–1â€– = 1",
    "name": "NormOneClass.norm_one",
    "isProp": true,
    "doc": "The norm of the multiplicative identity is 1. ",
    "depth": 10},
   {"type":
    "âˆ€ (V : Type u_1) [inst : SeminormedAddCommGroup V], â€–NormedAddGroupHom.id Vâ€– â‰¤ 1",
    "name": "NormedAddGroupHom.norm_id_le",
    "isProp": true,
    "doc":
    "The norm of the identity is at most `1`. It is in fact `1`, except when the norm of every\nelement vanishes, where it is `0`. (Since we are working with seminorms this can happen even if the\nspace is non-trivial.) It means that one can not do better than an inequality in general. ",
    "depth": 11}],
  "count": 2616},
 {"noDocExamples": [],
  "kind": "Â«term_â‰ƒ_Â»",
  "examples":
  [{"type": "List Unit â‰ƒ â„•",
    "name": "Equiv.listUnitEquiv",
    "isProp": false,
    "doc":
    "The type lists on unit is canonically equivalent to the natural numbers. ",
    "depth": 3},
   {"type": "Bool â‰ƒ PUnit.{u + 1} âŠ• PUnit.{v + 1}",
    "name": "Equiv.boolEquivPUnitSumPUnit",
    "isProp": false,
    "doc": "`Bool` is equivalent the sum of two `PUnit`s. ",
    "depth": 3},
   {"type": "{Î± : Type u_1} â†’ Î± â‰ƒ Specialization Î±",
    "name": "Specialization.toEquiv",
    "isProp": false,
    "doc":
    "`toEquiv` is the \"identity\" function to the `Specialization` of a type. ",
    "depth": 3}],
  "count": 2594},
 {"noDocExamples": [],
  "kind": "Â«termâŠ¥Â»",
  "examples":
  [{"type": "âˆ€ {Î± : Type u} {f : Filter Î±} [self : Filter.NeBot f], f â‰  âŠ¥",
    "name": "Filter.NeBot.ne'",
    "isProp": true,
    "doc": "The filter is nontrivial: `f â‰  âŠ¥` or equivalently, `âˆ… âˆ‰ f`. ",
    "depth": 8},
   {"type":
    "âˆ€ {Î± : Type u_1} [t : TopologicalSpace Î±] [self : DiscreteTopology Î±], t = âŠ¥",
    "name": "DiscreteTopology.eq_bot",
    "isProp": true,
    "doc":
    "The `TopologicalSpace` structure on a type with discrete topology is equal to `âŠ¥`. ",
    "depth": 8},
   {"type": "âˆ€ {Î± : Type u_1}, âŠ¥ = 0",
    "name": "Multiset.bot_eq_zero",
    "isProp": true,
    "doc": "This is a `rfl` and `simp` version of `bot_eq_zero`. ",
    "depth": 10}],
  "count": 2508},
 {"noDocExamples": [],
  "kind": "Set.term_''_",
  "examples":
  [{"type": "âˆ€ {Î± : Type u_1} (s : Set Î±), (fun x => x) '' s = s",
    "name": "Set.image_id'",
    "isProp": true,
    "doc": "A variant of `image_id` ",
    "depth": 8},
   {"type":
    "âˆ€ {Î± : Type u_1} {s : Set Î±} {f : Î± â†’ Î±}, Set.EqOn f id s â†’ f '' s = s",
    "name": "Set.EqOn.image_eq_self",
    "isProp": true,
    "doc": "Variant of `EqOn.image_eq`, for one function being the identity. ",
    "depth": 10},
   {"type":
    "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {s : Set Î±}, Set.Subsingleton s â†’ âˆ€ (f : Î± â†’ Î²), Set.Subsingleton (f '' s)",
    "name": "Set.Subsingleton.image",
    "isProp": true,
    "doc": "The image of a subsingleton is a subsingleton. ",
    "depth": 10}],
  "count": 2298},
 {"noDocExamples": [],
  "kind": "Â«term_âŠ“_Â»",
  "examples":
  [{"type":
    "âˆ€ (m n : â„•+), PNat.factorMultiset (PNat.gcd m n) = PNat.factorMultiset m âŠ“ PNat.factorMultiset n",
    "name": "PNat.factorMultiset_gcd",
    "isProp": true,
    "doc":
    "The gcd and lcm operations on positive integers correspond\nto the inf and sup operations on multisets. ",
    "depth": 9},
   {"type":
    "âˆ€ {Î± : Type u_1} {m0 : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {f : Filter Î±},\n  MeasureTheory.Measure.FiniteAtFilter Î¼ (f âŠ“ MeasureTheory.Measure.ae Î¼) â†’ MeasureTheory.Measure.FiniteAtFilter Î¼ f",
    "name": "MeasureTheory.Measure.FiniteAtFilter.of_inf_ae",
    "isProp": true,
    "doc":
    "**Alias** of the forward direction of `MeasureTheory.Measure.FiniteAtFilter.inf_ae_iff`.",
    "depth": 11},
   {"type": "âˆ€ {Î± : Type u} [self : SemilatticeInf Î±] (a b : Î±), a âŠ“ b â‰¤ b",
    "name": "SemilatticeInf.inf_le_right",
    "isProp": true,
    "doc": "The infimum is a lower bound on the second argument ",
    "depth": 11}],
  "count": 2194},
 {"noDocExamples": [],
  "kind": "Â«term_âŠ”_Â»",
  "examples":
  [{"type":
    "âˆ€ {L : Type u_1} [inst : TopologicalSpace L] [inst_1 : Sup L] [self : ContinuousSup L], Continuous fun p => p.1 âŠ” p.2",
    "name": "ContinuousSup.continuous_sup",
    "isProp": true,
    "doc": "The supremum is continuous ",
    "depth": 11},
   {"type": "âˆ€ {Î± : Type u} [self : SemilatticeSup Î±] (a b : Î±), a â‰¤ a âŠ” b",
    "name": "SemilatticeSup.le_sup_left",
    "isProp": true,
    "doc": "The supremum is an upper bound on the first argument ",
    "depth": 11},
   {"type": "âˆ€ {Î± : Type u} [self : SemilatticeSup Î±] (a b : Î±), b â‰¤ a âŠ” b",
    "name": "SemilatticeSup.le_sup_right",
    "isProp": true,
    "doc": "The supremum is an upper bound on the second argument ",
    "depth": 11}],
  "count": 2122},
 {"noDocExamples": [],
  "kind": "Â«term_âˆ¨_Â»",
  "examples":
  [{"type": "UnivLE.{u, v} âˆ¨ UnivLE.{v, u}",
    "name": "univLE_total",
    "isProp": true,
    "doc":
    "Together with transitivity, this shows UnivLE \"IsTotalPreorder\". ",
    "depth": 2},
   {"type": "âˆ€ (p : Prop), p âˆ¨ Â¬p",
    "name": "em",
    "isProp": true,
    "doc":
    "**Alias** of `Classical.em`.\n\n---\n\nDiaconescu's theorem: excluded middle from choice, Function extensionality and propositional extensionality. ",
    "depth": 3},
   {"type": "âˆ€ (p : Prop), p âˆ¨ Â¬p",
    "name": "Classical.em",
    "isProp": true,
    "doc":
    "Diaconescu's theorem: excluded middle from choice, Function extensionality and propositional extensionality. ",
    "depth": 3}],
  "count": 2085},
 {"noDocExamples": [],
  "kind": "Â«term_â†’â‚—[_]_Â»",
  "examples":
  [{"type": "{R : Type u} â†’ [inst : Semiring R] â†’ â„• â†’ R â†’â‚—[R] Polynomial R",
    "name": "Polynomial.monomial",
    "isProp": false,
    "doc": "`monomial s a` is the monomial `a * X^s` ",
    "depth": 14},
   {"type":
    "âˆ€ {R : Type u} [inst : Semiring R] [self : StrongRankCondition R] {n m : â„•} (f : (Fin n â†’ R) â†’â‚—[R] Fin m â†’ R),\n  Function.Injective â‡‘f â†’ n â‰¤ m",
    "name": "StrongRankCondition.le_of_fin_injective",
    "isProp": true,
    "doc": "Any injective linear map from `Râ¿` to `Ráµ` guarantees `n â‰¤ m`. ",
    "depth": 24},
   {"type":
    "{S : Type u_5} â†’\n  [inst : Semiring S] â†’\n    {M : Type u_6} â†’\n      [inst_1 : AddCommMonoid M] â†’\n        [inst_2 : Module S M] â†’ {m : Submodule S M} â†’ {f : M â†’â‚—[S] M} â†’ LinearMap.IsProj m f â†’ M â†’â‚—[S] â†¥m",
    "name": "LinearMap.IsProj.codRestrict",
    "isProp": false,
    "doc":
    "Restriction of the codomain of a projection of onto a subspace `p` to `p` instead of the whole\nspace.\n",
    "depth": 26}],
  "count": 2072},
 {"noDocExamples": [],
  "kind": "Set.Â«term{_|_}Â»",
  "examples":
  [{"type": "Set.Infinite {p | Nat.Prime p}",
    "name": "Nat.infinite_setOf_prime",
    "isProp": true,
    "doc":
    "A version of `Nat.exists_infinite_primes` using the `Set.Infinite` predicate. ",
    "depth": 4},
   {"type": "Dense {x | Liouville x}",
    "name": "dense_liouville",
    "isProp": true,
    "doc": "The set of Liouville numbers in dense. ",
    "depth": 5},
   {"type": "Â¬BddAbove {p | Nat.Prime p}",
    "name": "Nat.not_bddAbove_setOf_prime",
    "isProp": true,
    "doc":
    "A version of `Nat.exists_infinite_primes` using the `BddAbove` predicate. ",
    "depth": 6}],
  "count": 2032},
 {"noDocExamples": [],
  "kind": "Set.Â«term_â»Â¹'_Â»",
  "examples":
  [{"type":
    "âˆ€ {s : Set â„‚}, Set.Countable s â†’ Set.Countable (Complex.exp â»Â¹' s)",
    "name": "Set.Countable.preimage_cexp",
    "isProp": true,
    "doc":
    "**Alias** of the reverse direction of `Complex.countable_preimage_exp`.",
    "depth": 7},
   {"type":
    "âˆ€ {M : Type u_1} [inst : AddMonoid M] {N : Type u_3} [inst_1 : AddMonoid N] {f : M â†’ N},\n  IsAddMonoidHom f â†’ âˆ€ {s : Set N}, IsAddSubmonoid s â†’ IsAddSubmonoid (f â»Â¹' s)",
    "name": "IsAddSubmonoid.preimage",
    "isProp": true,
    "doc":
    "The preimage of an `AddSubmonoid` under an `AddMonoid` hom is\nan `AddSubmonoid` of the domain.",
    "depth": 13},
   {"type":
    "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (U : Set Î±),\n  ConnectedComponents.mk â»Â¹' (ConnectedComponents.mk '' U) = â‹ƒ x âˆˆ U, connectedComponent x",
    "name": "connectedComponents_preimage_image",
    "isProp": true,
    "doc":
    "The preimage of the image of a set under the quotient map to `connectedComponents Î±`\nis the union of the connected components of the elements in it. ",
    "depth": 13}],
  "count": 2001},
 {"noDocExamples": [],
  "kind": "Â«term_âˆ©_Â»",
  "examples":
  [{"type":
    "âˆ€ {Î± : Type u} [inst : Preorder Î±] {s t : Set Î±}, BddBelow s â†’ BddBelow (s âˆ© t)",
    "name": "BddBelow.inter_of_left",
    "isProp": true,
    "doc": "If `s` is bounded, then so is `s âˆ© t` ",
    "depth": 11},
   {"type":
    "âˆ€ {Î± : Type u} [inst : Preorder Î±] {s t : Set Î±}, BddAbove t â†’ BddAbove (s âˆ© t)",
    "name": "BddAbove.inter_of_right",
    "isProp": true,
    "doc": "If `t` is bounded, then so is `s âˆ© t` ",
    "depth": 11},
   {"type":
    "âˆ€ {Î± : Type u} [inst : Preorder Î±] {s t : Set Î±}, BddAbove s â†’ BddAbove (s âˆ© t)",
    "name": "BddAbove.inter_of_left",
    "isProp": true,
    "doc": "If `s` is bounded, then so is `s âˆ© t` ",
    "depth": 11}],
  "count": 1984},
 {"noDocExamples": [],
  "kind": "termâ„‚",
  "examples":
  [{"type":
    "âˆ€ {s : â„‚} {N : â„•} (Ï‡ : DirichletCharacter â„‚ N) (hs : 1 < s.re),\n  Filter.Tendsto (fun n => Finset.prod (Nat.primesBelow n) fun p => (1 - Ï‡ â†‘p * â†‘p ^ (-s))â»Â¹) Filter.atTop\n    (nhds (âˆ‘' (n : â„•), (dirichletSummandHom Ï‡ (_ : s â‰  0)) n))",
    "name": "dirichletLSeries_eulerProduct",
    "isProp": true,
    "doc": "The Euler product for Dirichlet L-series, valid for `s.re > 1`. ",
    "depth": 26},
   {"type":
    "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {a b C : â„} {f : â„‚ â†’ E} {z : â„‚},\n  DiffContOnCl â„‚ f (Complex.re â»Â¹' Set.Ioo a b) â†’\n    (âˆƒ c < Real.pi / (b - a),\n        âˆƒ B,\n          f =O[Filter.comap (abs âˆ˜ Complex.im) Filter.atTop âŠ“ Filter.principal (Complex.re â»Â¹' Set.Ioo a b)] fun z =>\n            Real.exp (B * Real.exp (c * |z.im|))) â†’\n      (âˆ€ (z : â„‚), z.re = a â†’ â€–f zâ€– â‰¤ C) â†’ (âˆ€ (z : â„‚), z.re = b â†’ â€–f zâ€– â‰¤ C) â†’ a â‰¤ z.re â†’ z.re â‰¤ b â†’ â€–f zâ€– â‰¤ C",
    "name": "PhragmenLindelof.vertical_strip",
    "isProp": true,
    "doc":
    "**Phragmen-LindelÃ¶f principle** in a strip `U = {z : â„‚ | a < re z < b}`.\nLet `f : â„‚ â†’ E` be a function such that\n\n* `f` is differentiable on `U` and is continuous on its closure;\n* `â€–f zâ€–` is bounded from above by `A * exp(B * exp(c * |im z|))` on `U` for some `c < Ï€ / (b - a)`;\n* `â€–f zâ€–` is bounded from above by a constant `C` on the boundary of `U`.\n\nThen `â€–f zâ€–` is bounded by the same constant on the closed strip\n`{z : â„‚ | a â‰¤ re z â‰¤ b}`. Moreover, it suffices to verify the second assumption\nonly for sufficiently large values of `|im z|`.\n",
    "depth": 28},
   {"type":
    "âˆ€ {E : Type u_1} {V : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {f : V â†’ E}\n  [inst_2 : NormedAddCommGroup V] [inst_3 : MeasurableSpace V] [inst_4 : BorelSpace V] [inst_5 : InnerProductSpace â„ V]\n  [inst_6 : FiniteDimensional â„ V],\n  Continuous f â†’\n    HasCompactSupport f â†’\n      Filter.Tendsto (fun w => âˆ« (v : V), â†‘(Real.fourierChar (Multiplicative.ofAdd (-inner v w))) â€¢ f v)\n        (Filter.cocompact V) (nhds 0)",
    "name":
    "tendsto_integral_exp_inner_smul_cocompact_of_continuous_compact_support",
    "isProp": true,
    "doc":
    "Riemann-Lebesgue Lemma for continuous and compactly-supported functions: the integral\n`âˆ« v, exp (-2 * Ï€ * âŸªw, vâŸ« * I) â€¢ f v` tends to 0 wrt `cocompact V`. Note that this is primarily\nof interest as a preparatory step for the more general result\n`tendsto_integral_exp_inner_smul_cocompact` in which `f` can be arbitrary. ",
    "depth": 47}],
  "count": 1922},
 {"noDocExamples": [],
  "kind": "Std.ExtendedBinder.Â«termâˆƒ__,_Â»",
  "examples":
  [{"type":
    "âˆ€ (R : Type u_1) [inst : CommRing R] [inst_1 : CharZero R], IsEmpty (Algebra â„š R) â†” âˆƒ p > 0, MixedCharZero R p",
    "name": "isEmpty_algebraRat_iff_mixedCharZero",
    "isProp": true,
    "doc":
    "A ring of characteristic zero is not a `â„š`-algebra iff it has mixed characteristic for some `p`.\n",
    "depth": 12},
   {"type":
    "âˆ€ {Î± : Type u_3} [self : Denumerable Î±] (n : â„•), âˆƒ a âˆˆ Encodable.decode n, Encodable.encode a = n",
    "name": "Denumerable.decode_inv",
    "isProp": true,
    "doc": "`decode` and `encode` are inverses. ",
    "depth": 12},
   {"type":
    "âˆ€ {P : Type u_2} [inst : Preorder P] (self : Order.Cofinal P) (x : P), âˆƒ y âˆˆ self.carrier, x â‰¤ y",
    "name": "Order.Cofinal.mem_gt",
    "isProp": true,
    "doc": "The `Cofinal` contains arbitrarily large elements. ",
    "depth": 13}],
  "count": 1889},
 {"noDocExamples": [],
  "kind": "Â«term{_:_//_}Â»",
  "examples":
  [{"type": "âˆ€ {Î± : Sort u_1}, IsEmpty { _a // False }",
    "name": "Subtype.isEmpty_false",
    "isProp": true,
    "doc": "subtypes by false are false. ",
    "depth": 4},
   {"type":
    "{K : Type u_1} â†’\n  [inst : Field K] â†’\n    [inst_1 : NumberField K] â†’\n      ({ w // NumberField.InfinitePlace.IsReal w } â†’ â„) Ã— ({ w // NumberField.InfinitePlace.IsComplex w } â†’ â„‚) â†’ â„",
    "name": "NumberField.mixedEmbedding.convexBodySumFun",
    "isProp": false,
    "doc":
    "The function that sends `x : ({w // IsReal w} â†’ â„) Ã— ({w // IsComplex w} â†’ â„‚)` to\n`âˆ‘ w, â€–x.1 wâ€– + 2 * âˆ‘ w, â€–x.2 wâ€–`. It defines a norm and it used to define `convexBodySum`. ",
    "depth": 12},
   {"type":
    "{Î± : Type u_1} â†’ (l : List Î±) â†’ List.Nodup l â†’ (âˆ€ (x : Î±), x âˆˆ l) â†’ { f // Function.Bijective f }",
    "name": "List.Nodup.getBijectionOfForallMemList",
    "isProp": false,
    "doc":
    "If `l` lists all the elements of `Î±` without duplicates, then `List.get` defines\na bijection `Fin l.length â†’ Î±`.  See `List.Nodup.getEquivOfForallMemList`\nfor a version giving an equivalence when there is decidable equality. ",
    "depth": 12}],
  "count": 1759},
 {"noDocExamples": [],
  "kind": "Â«termâˆ…Â»",
  "examples":
  [{"type": "âˆ€ {X : Type u_1} [inst : TopologicalSpace X], IsSigmaCompact âˆ…",
    "name": "isSigmaCompact_empty",
    "isProp": true,
    "doc": "The empty set is Ïƒ-compact. ",
    "depth": 6},
   {"type": "âˆ€ {X : Type u_4} [inst : TopologicalSpace X], IsMeagre âˆ…",
    "name": "meagre_empty",
    "isProp": true,
    "doc": "The empty set is meagre. ",
    "depth": 6},
   {"type":
    "âˆ€ {Î± : Type u_7} (self : MeasurableSpace Î±), MeasurableSpace.MeasurableSet' self âˆ…",
    "name": "MeasurableSpace.measurableSet_empty",
    "isProp": true,
    "doc":
    "The empty set is a measurable set. Use `MeasurableSet.empty` instead. ",
    "depth": 6}],
  "count": 1527},
 {"noDocExamples": [],
  "kind": "Â«term_âˆ£_Â»",
  "examples":
  [{"type": "Function.Injective fun x x_1 => x âˆ£ x_1",
    "name": "Nat.dvd_left_injective",
    "isProp": true,
    "doc": "`dvd` is injective in the left argument ",
    "depth": 7},
   {"type": "âˆ€ {m n : â„•}, Odd n â†’ m âˆ£ n â†’ m â‰  2",
    "name": "Odd.ne_two_of_dvd_nat",
    "isProp": true,
    "doc": "`2` is not a factor of an odd natural number. ",
    "depth": 8},
   {"type": "âˆ€ {a b : â„•}, a âˆ£ b â†’ b < a â†’ b = 0",
    "name": "Nat.eq_zero_of_dvd_of_lt",
    "isProp": true,
    "doc":
    "If a small natural number is divisible by a larger natural number,\nthe small number is zero. ",
    "depth": 8}],
  "count": 1526},
 {"noDocExamples": [],
  "kind": "Â«term_â†’*_Â»",
  "examples":
  [{"type":
    "{Î¹ : Type u_1} â†’ {Î· : Type v} â†’ (R : Type w) â†’ (Î¹ â†’ Î·) â†’ [inst : MulOneClass R] â†’ (Î¹ â†’ R) â†’* Î· â†’ R",
    "name": "Function.ExtendByOne.hom",
    "isProp": false,
    "doc": "`Function.extend s f 1` as a bundled hom. ",
    "depth": 10},
   {"type": "{Î± : Type u_8} â†’ [inst : DivisionCommMonoid Î±] â†’ Î± Ã— Î± â†’* Î±",
    "name": "divMonoidHom",
    "isProp": false,
    "doc": "Division as a monoid homomorphism. ",
    "depth": 11},
   {"type":
    "(G : Type u_1) â†’ [inst : Group G] â†’ [inst_1 : Subgroup.FiniteIndex (Subgroup.center G)] â†’ G â†’* â†¥(Subgroup.center G)",
    "name": "MonoidHom.transferCenterPow",
    "isProp": false,
    "doc": "The transfer homomorphism `G â†’* center G`. ",
    "depth": 16}],
  "count": 1514},
 {"noDocExamples": [],
  "kind": "Â«term_âˆª_Â»",
  "examples":
  [{"type":
    "âˆ€ {Î± : Type u_1} (s : Set Î±) (a : Î±), ğ’« insert a s = ğ’« s âˆª insert a '' ğ’« s",
    "name": "Set.powerset_insert",
    "isProp": true,
    "doc":
    "The powerset of `{a} âˆª s` is `ğ’« s` together with `{a} âˆª t` for each `t âˆˆ ğ’« s`. ",
    "depth": 11},
   {"type":
    "âˆ€ {Î± : Type u} (S T : Set Î±), Cardinal.mk â†‘(S âˆª T) â‰¤ Cardinal.mk â†‘S + Cardinal.mk â†‘T",
    "name": "Cardinal.mk_union_le",
    "isProp": true,
    "doc":
    "The cardinality of a union is at most the sum of the cardinalities\nof the two sets. ",
    "depth": 12},
   {"type":
    "âˆ€ {Î± : Type u_1} {A B : Set (Finset Î±)} {r : â„•}, Set.Sized r A âˆ§ Set.Sized r B â†’ Set.Sized r (A âˆª B)",
    "name": "Set.sized.union",
    "isProp": true,
    "doc": "**Alias** of the reverse direction of `Set.sized_union`.",
    "depth": 12}],
  "count": 1415},
 {"noDocExamples": [],
  "kind": "Â«term_â†’+_Â»",
  "examples":
  [{"type":
    "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : AddGroup Î±] [inst_1 : SubtractionMonoid Î²] (f : Î± â†’+ Î²) (g h : Î±),\n  f (g - h) = f g - f h",
    "name": "AddMonoidHom.map_sub",
    "isProp": true,
    "doc": "Additive group homomorphisms preserve subtraction.",
    "depth": 26},
   {"type":
    "âˆ€ {Î¹ : Type u} {Î² : Î¹ â†’ Type v} [dec : DecidableEq Î¹] [inst : (i : Î¹) â†’ AddZeroClass (Î² i)] {Î³ : Type w}\n  [inst_1 : AddZeroClass Î³] â¦ƒf g : (Î â‚€ (i : Î¹), Î² i) â†’+ Î³â¦„,\n  (âˆ€ (i : Î¹) (y : Î² i), f (DFinsupp.single i y) = g (DFinsupp.single i y)) â†’ f = g",
    "name": "DFinsupp.addHom_ext",
    "isProp": true,
    "doc":
    "If two additive homomorphisms from `Î â‚€ i, Î² i` are equal on each `single a b`, then\nthey are equal. ",
    "depth": 34},
   {"type": "{Î± : Type u_8} â†’ [inst : SubtractionCommMonoid Î±] â†’ Î± Ã— Î± â†’+ Î±",
    "name": "subAddMonoidHom",
    "isProp": false,
    "doc": "Subtraction as an additive monoid homomorphism.",
    "depth": 11}],
  "count": 1375},
 {"noDocExamples": [],
  "kind": "Â«term_â†’â‚€_Â»",
  "examples":
  [{"type":
    "âˆ€ {Î± : Type u_1} {M : Type u_8} {N : Type u_10} [inst : AddZeroClass M] [inst_1 : CommMonoid N] {f g : Î± â†’â‚€ M}\n  {h : Î± â†’ M â†’ N},\n  (âˆ€ (a : Î±), h a 0 = 1) â†’\n    (âˆ€ (a : Î±) (bâ‚ bâ‚‚ : M), h a (bâ‚ + bâ‚‚) = h a bâ‚ * h a bâ‚‚) â†’\n      Finsupp.prod (f + g) h = Finsupp.prod f h * Finsupp.prod g h",
    "name": "Finsupp.prod_add_index'",
    "isProp": true,
    "doc":
    "Taking the product under `h` is an additive-to-multiplicative homomorphism of finsupps,\nif `h` is an additive-to-multiplicative homomorphism.\nThis is a more specialized version of `Finsupp.prod_add_index` with simpler hypotheses. ",
    "depth": 23},
   {"type": "â„• â†’ â„• â†’â‚€ â„•",
    "name": "Nat.factorization",
    "isProp": false,
    "doc":
    "`n.factorization` is the finitely supported function `â„• â†’â‚€ â„•`\nmapping each prime factor of `n` to its multiplicity in `n`. ",
    "depth": 4},
   {"type":
    "{Î¹ : Type u_1} â†’ {Î· : Î¹ â†’ Type u_4} â†’ {N : Type u_5} â†’ [inst : Zero N] â†’ ((i : Î¹) Ã— Î· i â†’â‚€ N) â‰ƒ Î â‚€ (i : Î¹), Î· i â†’â‚€ N",
    "name": "sigmaFinsuppEquivDFinsupp",
    "isProp": false,
    "doc":
    "`Finsupp.split` is an equivalence between `(Î£ i, Î· i) â†’â‚€ N` and `Î â‚€ i, (Î· i â†’â‚€ N)`. ",
    "depth": 12}],
  "count": 1292},
 {"noDocExamples": [],
  "kind": "Â«term_âˆ‰_Â»",
  "examples":
  [{"type": "Class.univ âˆ‰ Class.univ",
    "name": "Class.univ_not_mem_univ",
    "isProp": true,
    "doc":
    "**There is no universal set.**\nThis is stated as `univ âˆ‰ univ`, meaning that `univ` (the class of all sets) is proper (does not\nbelong to the class of all sets). ",
    "depth": 6},
   {"type": "âˆ€ {Î± : Type u_1} {r : Setoid Î±}, âˆ… âˆ‰ Setoid.classes r",
    "name": "Setoid.empty_not_mem_classes",
    "isProp": true,
    "doc": "The empty set is not an equivalence class. ",
    "depth": 9},
   {"type":
    "âˆ€ {A : Set â„•} [inst : DecidablePred fun x => x âˆˆ A], 1 âˆ‰ A â†’ schnirelmannDensity A = 0",
    "name": "schnirelmannDensity_eq_zero_of_one_not_mem",
    "isProp": true,
    "doc": "The Schnirelmann density of a set not containing `1` is `0`. ",
    "depth": 9}],
  "count": 1196},
 {"noDocExamples": [],
  "kind": "Â«term_â†’L[_]_Â»",
  "examples":
  [{"type":
    "âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {f : E â†’ â„} {a : E} {f' : E â†’L[â„] â„},\n  IsLocalMin f a â†’ HasFDerivAt f f' a â†’ f' = 0",
    "name": "IsLocalMin.hasFDerivAt_eq_zero",
    "isProp": true,
    "doc":
    "**Fermat's Theorem**: the derivative of a function at a local minimum equals zero. ",
    "depth": 25},
   {"type":
    "âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {f : E â†’ F}\n  {f' : E â†’L[ğ•œ] F} {x : E} {s : Set E}, nhdsWithin x (s \\ {x}) = âŠ¥ â†’ HasFDerivWithinAt f f' s x",
    "name": "HasFDerivWithinAt.of_nhdsWithin_eq_bot",
    "isProp": true,
    "doc":
    "If `x` is isolated in `s`, then `f` has any derivative at `x` within `s`,\nas this statement is empty. ",
    "depth": 27},
   {"type":
    "âˆ€ {Î¹ : Type u} {E : Type v} {F : Type w} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E]\n  [inst_2 : NormedAddCommGroup F] [inst_3 : NormedSpace â„ F] {I J : BoxIntegral.Box Î¹} [inst_4 : Fintype Î¹]\n  {l : BoxIntegral.IntegrationParams} {f : (Î¹ â†’ â„) â†’ E} {vol : BoxIntegral.BoxAdditiveMap Î¹ (E â†’L[â„] F) âŠ¤}\n  [inst_5 : CompleteSpace F], BoxIntegral.Integrable I l f vol â†’ J â‰¤ I â†’ BoxIntegral.Integrable J l f vol",
    "name": "BoxIntegral.Integrable.to_subbox",
    "isProp": true,
    "doc":
    "If `f` is integrable on a box `I`, then it is integrable on any subbox of `I`. ",
    "depth": 29}],
  "count": 1150},
 {"noDocExamples": [],
  "kind": "Set.Â«termâ‹ƒ_,_Â»",
  "examples":
  [{"type":
    "âˆ€ {Î± : Type u_7} (self : MeasurableSpace Î±) (f : â„• â†’ Set Î±),\n  (âˆ€ (i : â„•), MeasurableSpace.MeasurableSet' self (f i)) â†’ MeasurableSpace.MeasurableSet' self (â‹ƒ i, f i)",
    "name": "MeasurableSpace.measurableSet_iUnion",
    "isProp": true,
    "doc":
    "The union of a sequence of measurable sets is a measurable set. Use a more general\n`MeasurableSet.iUnion` instead. ",
    "depth": 8},
   {"type":
    "âˆ€ {X : Type u_4} [inst : TopologicalSpace X] {s : â„• â†’ Set X}, (âˆ€ (n : â„•), IsMeagre (s n)) â†’ IsMeagre (â‹ƒ n, s n)",
    "name": "meagre_iUnion",
    "isProp": true,
    "doc": "A countable union of meagre sets is meagre. ",
    "depth": 8},
   {"type":
    "âˆ€ {X : Type u_4} [inst : TopologicalSpace X] (self : CompactExhaustion X),\n  â‹ƒ n, CompactExhaustion.toFun self n = Set.univ",
    "name": "CompactExhaustion.iUnion_eq'",
    "isProp": true,
    "doc":
    "The union of all sets in a compact exhaustion equals the entire space. ",
    "depth": 11}],
  "count": 1143},
 {"noDocExamples": [],
  "kind": "Â«term_á¶œÂ»",
  "examples":
  [{"type":
    "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {s : Set Î±}, DirSupClosed sá¶œ â†’ DirSupInacc s",
    "name": "DirSupClosed.of_compl",
    "isProp": true,
    "doc": "**Alias** of the forward direction of `dirSupClosed_compl`.",
    "depth": 10},
   {"type":
    "âˆ€ {Î± : Type u_2} [inst : Bornology Î±] {s : Set Î±}, Bornology.IsBounded sá¶œ â†’ Bornology.IsCobounded s",
    "name": "Bornology.IsBounded.of_compl",
    "isProp": true,
    "doc":
    "**Alias** of the forward direction of `Bornology.isBounded_compl_iff`.",
    "depth": 10},
   {"type":
    "âˆ€ {Î± : Type u} [inst : Infinite Î±] {s : Set Î±}, Set.Finite s â†’ sá¶œ âˆˆ Filter.hyperfilter Î±",
    "name": "Set.Finite.compl_mem_hyperfilter",
    "isProp": true,
    "doc": "**Alias** of `Filter.compl_mem_hyperfilter_of_finite`.",
    "depth": 11}],
  "count": 1138},
 {"noDocExamples": [],
  "kind": "Â«term[_]Â»",
  "examples":
  [{"type": "âˆ€ {Î± : Type u_1}, List.Sublist [] []",
    "name": "List.Sublist.slnil",
    "isProp": true,
    "doc": "the base case: `[]` is a sublist of `[]` ",
    "depth": 4},
   {"type": "âˆ€ {Î± : Type u_1}, List.Perm [] []",
    "name": "List.Perm.nil",
    "isProp": true,
    "doc": "`[] ~ []` ",
    "depth": 4},
   {"type": "âˆ€ {Î± : Type u_1} {R : Î± â†’ Î± â†’ Prop}, List.Pairwise R []",
    "name": "List.Pairwise.nil",
    "isProp": true,
    "doc": "All elements of the empty list are vacuously pairwise related. ",
    "depth": 5}],
  "count": 1132},
 {"noDocExamples": [],
  "kind": "Â«term_áµáµ’áµ–Â»",
  "examples":
  [{"type":
    "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] [inst_1 : Group Î±] [inst_2 : TopologicalGroup Î±], TopologicalGroup Î±áµáµ’áµ–",
    "name":
    "instTopologicalGroupMulOppositeInstTopologicalSpaceMulOppositeGroup",
    "isProp": true,
    "doc":
    "If multiplication is continuous in `Î±`, then it also is in `Î±áµáµ’áµ–`. ",
    "depth": 8},
   {"type":
    "âˆ€ (R : Type u_2) [inst : MonoidWithZero R], nonZeroSMulDivisors Ráµáµ’áµ– R = Submonoid.op (nonZeroDivisors R)",
    "name": "nonZeroSMulDivisors_mulOpposite_eq_op_nonZeroDivisors",
    "isProp": true,
    "doc":
    "The non-zero `â€¢`-divisors with `â€¢` as right multiplication correspond with the non-zero\ndivisors. Note that the `MulOpposite` is needed because we defined `nonZeroDivisors` with\nmultiplication on the right. ",
    "depth": 10},
   {"type":
    "{G : Type v} â†’ [inst : Group G] â†’ [inst_1 : PseudoEMetricSpace G] â†’ [inst : IsometricSMul Gáµáµ’áµ– G] â†’ G â†’ G â‰ƒáµ¢ G",
    "name": "IsometryEquiv.mulRight",
    "isProp": false,
    "doc": "Multiplication `y â†¦ y * x` as an `IsometryEquiv`. ",
    "depth": 11}],
  "count": 1100},
 {"noDocExamples": [],
  "kind": "Â«termC(_,_)Â»",
  "examples":
  [{"type":
    "{Î¹ : Type u_4} â†’\n  {X : Î¹ â†’ Type u_2} â†’\n    {Y : Î¹ â†’ Type u_3} â†’\n      [inst : (i : Î¹) â†’ TopologicalSpace (X i)] â†’\n        [inst_1 : (i : Î¹) â†’ TopologicalSpace (Y i)] â†’\n          {fâ‚€ fâ‚ : (i : Î¹) â†’ C(X i, Y i)} â†’\n            ((i : Î¹) â†’ ContinuousMap.Homotopy (fâ‚€ i) (fâ‚ i)) â†’\n              ContinuousMap.Homotopy (ContinuousMap.piMap fâ‚€) (ContinuousMap.piMap fâ‚)",
    "name": "ContinuousMap.Homotopy.piMap",
    "isProp": false,
    "doc":
    "Given a family of homotopies `F i` between `fâ‚€ i : C(X i, Y i)` and `fâ‚ i : C(X i, Y i)`,\nreturns a homotopy between `ContinuousMap.piMap fâ‚€` and `ContinuousMap.piMap fâ‚`. ",
    "depth": 17},
   {"type":
    "(R : Type u_2) â†’\n  [inst : CommSemiring R] â†’\n    (A : Type u_3) â†’\n      [inst_1 : TopologicalSpace A] â†’\n        [inst_2 : Semiring A] â†’\n          [inst_3 : Algebra R A] â†’\n            [inst_4 : TopologicalSemiring A] â†’\n              {Î± : Type u_5} â†’\n                {Î² : Type u_6} â†’\n                  [inst_5 : TopologicalSpace Î±] â†’ [inst_6 : TopologicalSpace Î²] â†’ C(Î±, Î²) â†’ C(Î², A) â†’â‚[R] C(Î±, A)",
    "name": "ContinuousMap.compRightAlgHom",
    "isProp": false,
    "doc":
    "Precomposition of functions into a normed ring by a continuous map is an algebra homomorphism.\n",
    "depth": 23},
   {"type":
    "âˆ€ {X : Type u_1} {Y : Type u_2} {Z : Type u_3} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y]\n  [inst_2 : TopologicalSpace Z] {f : C(X, Y)} (hf : QuotientMap â‡‘f) (g : C(X, Z)) (h : Function.FactorsThrough â‡‘g â‡‘f),\n  ContinuousMap.comp (QuotientMap.lift hf g h) f = g",
    "name": "QuotientMap.lift_comp",
    "isProp": true,
    "doc":
    "The obvious triangle induced by `QuotientMap.lift`Â commutes:\n```\n     g\n  X --â†’ Z\n  |   â†—\nf |  / hf.lift g h\n  v /\n  Y\n```\n",
    "depth": 24}],
  "count": 1088},
 {"noDocExamples": [],
  "kind": "termIfThenElse",
  "examples":
  [{"type":
    "âˆ€ {P : Prop} {Î± : Sort u_1} {a b : Î±} [inst : Decidable P], (if x : P then a else b) = if P then a else b",
    "name": "dite_eq_ite",
    "isProp": true,
    "doc":
    "A `dite` whose results do not actually depend on the condition may be reduced to an `ite`. ",
    "depth": 12},
   {"type":
    "âˆ€ {Î± : Sort u_1} (P : Prop) {x : Decidable P} (x_1 y : Î±), (if Â¬P then x_1 else y) = if P then y else x_1",
    "name": "ite_not",
    "isProp": true,
    "doc":
    "Negation of the condition `P : Prop` in a `ite` is the same as swapping the branches. ",
    "depth": 12},
   {"type":
    "âˆ€ {Î± : Sort u} {f : Î± â†’ Î±},\n  Function.Involutive f â†’ âˆ€ (P : Prop) [inst : Decidable P] (x : Î±), f (if P then x else f x) = if Â¬P then x else f x",
    "name": "Function.Involutive.ite_not",
    "isProp": true,
    "doc":
    "Involuting an `ite` of an involuted value `x : Î±` negates the `Prop` condition in the `ite`. ",
    "depth": 14}],
  "count": 1056},
 {"noDocExamples": [],
  "kind": "Â«term_Ë£Â»",
  "examples":
  [{"type":
    "âˆ€ {Mâ‚€ : Type u_2} [inst : MonoidWithZero Mâ‚€] [inst_1 : Nontrivial Mâ‚€] (u : Mâ‚€Ë£), â†‘u â‰  0",
    "name": "Units.ne_zero",
    "isProp": true,
    "doc":
    "An element of the unit group of a nonzero monoid with zero represented as an element\nof the monoid is nonzero. ",
    "depth": 10},
   {"type":
    "âˆ€ {R : Type u_1} {Î¹ : Type u_2} {A : Type u_3} {B : Type u_4} [inst : CommSemiring Î¹] [inst_1 : Module Î¹ (Additive â„¤Ë£)]\n  [inst_2 : DecidableEq Î¹] [inst_3 : CommRing R] [inst_4 : Ring A] [inst_5 : Ring B] [inst_6 : Algebra R A]\n  [inst_7 : Algebra R B] (ğ’œ : Î¹ â†’ Submodule R A) (â„¬ : Î¹ â†’ Submodule R B) [inst_8 : GradedAlgebra ğ’œ]\n  [inst_9 : GradedAlgebra â„¬] {jâ‚ : Î¹} (aâ‚ : A) (bâ‚ : â†¥(â„¬ jâ‚)) (aâ‚‚ : â†¥(ğ’œ 0)) (bâ‚‚ : B),\n  aâ‚ áµâŠ—â‚œ[R] â†‘bâ‚ * â†‘aâ‚‚ áµâŠ—â‚œ[R] bâ‚‚ = (aâ‚ * â†‘aâ‚‚) áµâŠ—â‚œ[R] (â†‘bâ‚ * bâ‚‚)",
    "name": "GradedTensorProduct.tmul_coe_mul_zero_coe_tmul",
    "isProp": true,
    "doc": "A special case for when `aâ‚‚` has grade 0. ",
    "depth": 44},
   {"type":
    "{R : Type u_1} â†’ [inst : NormedRing R] â†’ [inst_1 : CompleteSpace R] â†’ (x : RË£) â†’ (t : R) â†’ â€–tâ€– < â€–â†‘xâ»Â¹â€–â»Â¹ â†’ RË£",
    "name": "Units.add",
    "isProp": false,
    "doc":
    "In a complete normed ring, a perturbation of a unit `x` by an element `t` of distance less than\n`â€–xâ»Â¹â€–â»Â¹` from `x` is a unit.  Here we construct its `Units` structure. ",
    "depth": 19}],
  "count": 1026},
 {"noDocExamples": [],
  "kind": "Â«term_+áµ¥_Â»",
  "examples":
  [{"type":
    "âˆ€ {M : Type u_1} (c : M) (X : Type u_2) [inst : VAdd M X] [inst_1 : TopologicalSpace X] [h : ProperConstVAdd M X],\n  IsProperMap fun x => c +áµ¥ x",
    "name": "isProperMap_vadd",
    "isProp": true,
    "doc": "`(c +áµ¥ Â·)` is a proper map.",
    "depth": 14},
   {"type":
    "âˆ€ {M : Type u_1} {X : Type u_2} [inst : VAdd M X] [inst_1 : TopologicalSpace M] [inst_2 : TopologicalSpace X]\n  [self : ContinuousVAdd M X], Continuous fun p => p.1 +áµ¥ p.2",
    "name": "ContinuousVAdd.continuous_vadd",
    "isProp": true,
    "doc": "The additive action `(+áµ¥)` is continuous. ",
    "depth": 14},
   {"type":
    "âˆ€ {M : Type u_1} {X : Type u_2} [inst : VAdd M X] [inst_1 : TopologicalSpace X] [self : ProperConstVAdd M X] (c : M),\n  IsProperMap fun x => c +áµ¥ x",
    "name": "ProperConstVAdd.isProperMap_vadd",
    "isProp": true,
    "doc": "`(c +áµ¥ Â·)` is a proper map. ",
    "depth": 14}],
  "count": 1010},
 {"noDocExamples": [],
  "kind": "Â«term_áµ’áµˆÂ»",
  "examples":
  [{"type":
    "{Î± : Type u_1} â†’ [inst : Preorder Î±] â†’ [inst_1 : LocallyFiniteOrder Î±] â†’ LocallyFiniteOrder Î±áµ’áµˆ",
    "name": "OrderDual.locallyFiniteOrder",
    "isProp": false,
    "doc":
    "Note we define `Icc (toDual a) (toDual b)` as `Icc Î± _ _ b a` (which has type `Finset Î±` not\n`Finset Î±áµ’áµˆ`!) instead of `(Icc b a).map toDual.toEmbedding` as this means the\nfollowing is defeq:\n```\nlemma this : (Icc (toDual (toDual a)) (toDual (toDual b)) : _) = (Icc a b : _) := rfl\n```\n",
    "depth": 6},
   {"type":
    "âˆ€ {Î± : Type u_2} [inst : SemilatticeInf Î±] {a : Î±áµ’áµˆ}, SupIrred a â†’ InfIrred (OrderDual.ofDual a)",
    "name": "SupIrred.ofDual",
    "isProp": true,
    "doc": "**Alias** of the reverse direction of `infIrred_ofDual`.",
    "depth": 14},
   {"type":
    "{Î± : Type u_2} â†’ {Î² : Type u_3} â†’ [inst : Preorder Î±] â†’ [inst_1 : Preorder Î²] â†’ Î± â†ªo Î² â†’ Î±áµ’áµˆ â†ªo Î²áµ’áµˆ",
    "name": "OrderEmbedding.dual",
    "isProp": false,
    "doc":
    "An order embedding is also an order embedding between dual orders. ",
    "depth": 10}],
  "count": 976},
 {"noDocExamples": [],
  "kind": "Â«term_\\_Â»",
  "examples":
  [{"type": "âˆ€ (N : â„•), (Nat.smoothNumbers N)á¶œ \\ {0} âŠ† {n | N â‰¤ n}",
    "name": "Nat.smoothNumbers_compl",
    "isProp": true,
    "doc": "The non-zero non-`N`-smooth numbers are `â‰¥ N`. ",
    "depth": 10},
   {"type":
    "âˆ€ {A : Set â„•} [inst : DecidablePred fun x => x âˆˆ A] [inst_1 : DecidablePred fun x => x âˆˆ A \\ {0}],\n  schnirelmannDensity (A \\ {0}) = schnirelmannDensity A",
    "name": "schnirelmannDensity_diff_singleton_zero",
    "isProp": true,
    "doc": "The Schnirelmann density is unaffected by removing `0`. ",
    "depth": 12},
   {"type":
    "âˆ€ {X : Type u} [inst : TopologicalSpace X] {s t : Set X}, IsCompact s â†’ IsOpen t â†’ IsCompact (s \\ t)",
    "name": "IsCompact.diff",
    "isProp": true,
    "doc":
    "The set difference of a compact set and an open set is a compact set. ",
    "depth": 12}],
  "count": 971},
 {"noDocExamples": [],
  "kind": "Â«term_â§¸_Â»",
  "examples":
  [{"type":
    "âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : Fact (âˆ€ (I : Ideal R), I â‰  âŠ¤ â†’ CharZero (R â§¸ I))] (n : â„•+), â†‘â†‘n = â†‘â†‘n",
    "name": "EqualCharZero.pnatCast_eq_natCast",
    "isProp": true,
    "doc":
    "Internal: Not intended to be used outside this local construction. ",
    "depth": 18},
   {"type":
    "âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : MeasurableSpace G] [inst_2 : TopologicalSpace G]\n  [inst_3 : TopologicalGroup G] [inst_4 : BorelSpace G] {Î“ : Subgroup G} [inst_5 : MeasurableSpace (G â§¸ Î“)]\n  [inst_6 : BorelSpace (G â§¸ Î“)], MeasurableSMul G (G â§¸ Î“)",
    "name": "QuotientGroup.measurableSMul",
    "isProp": true,
    "doc":
    "Measurability of the action of the topological group `G` on the left-coset space `G/Î“`. ",
    "depth": 20},
   {"type":
    "{Î± : Type u_1} â†’\n  [inst : Group Î±] â†’\n    {s t : Subgroup Î±} â†’ (H : Subgroup Î±) â†’ s â‰¤ t â†’ â†¥H â§¸ Subgroup.subgroupOf s H â†’ â†¥H â§¸ Subgroup.subgroupOf t H",
    "name": "Subgroup.quotientSubgroupOfMapOfLE",
    "isProp": false,
    "doc":
    "If `s â‰¤ t`, then there is a map `H â§¸ s.subgroupOf H â†’ H â§¸ t.subgroupOf H`. ",
    "depth": 22}],
  "count": 967},
 {"noDocExamples": [],
  "kind": "Â«term_::_Â»",
  "examples":
  [{"type": "âˆ€ {Î± : Type u} {a : Î±} (as : List Î±), List.Mem a (a :: as)",
    "name": "List.Mem.head",
    "isProp": true,
    "doc": "The head of a list is a member: `a âˆˆ a :: as`. ",
    "depth": 7},
   {"type":
    "âˆ€ {Î± : Type u} [inst : LT Î±] (b : Î±) (bs : List Î±), List.lt [] (b :: bs)",
    "name": "List.lt.nil",
    "isProp": true,
    "doc": "`[]` is the smallest element in the order. ",
    "depth": 8},
   {"type":
    "âˆ€ {Î± : Type u_1} {lâ‚ lâ‚‚ : List Î±} (a : Î±), List.Sublist lâ‚ lâ‚‚ â†’ List.Sublist lâ‚ (a :: lâ‚‚)",
    "name": "List.Sublist.cons",
    "isProp": true,
    "doc":
    "If `lâ‚` is a subsequence of `lâ‚‚`, then it is also a subsequence of `a :: lâ‚‚`. ",
    "depth": 9}],
  "count": 932},
 {"noDocExamples": [],
  "kind": "Â«termâ¨†_,_Â»",
  "examples":
  [{"type": "âˆ€ {Î¹ : Sort u_1} {f : Î¹ â†’ â„}, (âˆ€ (i : Î¹), 0 â‰¤ f i) â†’ 0 â‰¤ â¨† i, f i",
    "name": "Real.iSup_nonneg",
    "isProp": true,
    "doc":
    "As `0` is the default value for `Real.sSup` of the empty set or sets which are not bounded above, it\nsuffices to show that `f i` is nonnegative to show that `0 â‰¤ â¨† i, f i`.\n",
    "depth": 9},
   {"type":
    "âˆ€ {Î± : Type u_1} [inst : UniformSpace Î±] [inst_1 : CompactSpace Î±], uniformity Î± = â¨† x, nhds (x, x)",
    "name": "compactSpace_uniformity",
    "isProp": true,
    "doc":
    "On a compact uniform space, the topology determines the uniform structure, entourages are\nexactly the neighborhoods of the diagonal. ",
    "depth": 13},
   {"type":
    "âˆ€ {Î± : Type ua} [inst : UniformSpace Î±], â¨† x, nhds (x, x) â‰¤ uniformity Î±",
    "name": "iSup_nhds_le_uniformity",
    "isProp": true,
    "doc": "Entourages are neighborhoods of the diagonal. ",
    "depth": 13}],
  "count": 917},
 {"noDocExamples": [],
  "kind": "Â«termâ¨…_,_Â»",
  "examples":
  [{"type": "âˆ€ {Î¹ : Sort u_1}, â¨… i, 0 = 0",
    "name": "Nat.iInf_const_zero",
    "isProp": true,
    "doc": "This combines `Nat.iInf_of_empty` with `ciInf_const`. ",
    "depth": 8},
   {"type":
    "âˆ€ {Î± : Type u_1} {Î³ : Type u_3} {Î¹ : Type u_4} {u : Î¹ â†’ UniformSpace Î³},\n  UniformFun.uniformSpace Î± Î³ = â¨… i, UniformFun.uniformSpace Î± Î³",
    "name": "UniformFun.iInf_eq",
    "isProp": true,
    "doc":
    "If `u` is a family of uniform structures on `Î³`, then\n`ğ’°(Î±, Î³, (â¨… i, u i)) = â¨… i, ğ’°(Î±, Î³, u i)`. ",
    "depth": 12},
   {"type":
    "âˆ€ {Î± : Type u_1} {Î³ : Type u_3} {Î¹ : Type u_4} {ğ”– : Set (Set Î±)} {u : Î¹ â†’ UniformSpace Î³},\n  UniformOnFun.uniformSpace Î± Î³ ğ”– = â¨… i, UniformOnFun.uniformSpace Î± Î³ ğ”–",
    "name": "UniformOnFun.iInf_eq",
    "isProp": true,
    "doc":
    "If `u` is a family of uniform structures on `Î³`, then\n`ğ’±(Î±, Î³, ğ”–, (â¨… i, u i)) = â¨… i, ğ’±(Î±, Î³, ğ”–, u i)`. ",
    "depth": 14}],
  "count": 900},
 {"noDocExamples": [],
  "kind": "Â«term_âŠ•_Â»",
  "examples":
  [{"type": "Bool â‰ƒ PUnit.{u + 1} âŠ• PUnit.{v + 1}",
    "name": "Equiv.boolEquivPUnitSumPUnit",
    "isProp": false,
    "doc": "`Bool` is equivalent the sum of two `PUnit`s. ",
    "depth": 3},
   {"type": "WType.NatÎ± â‰ƒ PUnit.{u + 1} âŠ• PUnit.{u_1 + 1}",
    "name": "WType.NatÎ±EquivPUnitSumPUnit",
    "isProp": false,
    "doc":
    "`WType.NatÎ±` is equivalent to `PUnit âŠ• PUnit`.\nThis is useful when considering the associated polynomial endofunctor.\n",
    "depth": 3},
   {"type": "{Î± : Type u_1} â†’ {Î² : Type u_2} â†’ Î± âŠ• Î² â†’ Option Î²",
    "name": "Sum.getRight?",
    "isProp": false,
    "doc": "Check if a sum is `inr` and if so, retrieve its contents. ",
    "depth": 5}],
  "count": 895},
 {"noDocExamples": [],
  "kind": "Â«term_â†’â‚[_]_Â»",
  "examples":
  [{"type":
    "(R : Type u_2) â†’\n  [inst : CommSemiring R] â†’\n    (A : Type u_3) â†’\n      [inst_1 : TopologicalSpace A] â†’\n        [inst_2 : Semiring A] â†’\n          [inst_3 : Algebra R A] â†’\n            [inst_4 : TopologicalSemiring A] â†’\n              {Î± : Type u_5} â†’\n                {Î² : Type u_6} â†’\n                  [inst_5 : TopologicalSpace Î±] â†’ [inst_6 : TopologicalSpace Î²] â†’ C(Î±, Î²) â†’ C(Î², A) â†’â‚[R] C(Î±, A)",
    "name": "ContinuousMap.compRightAlgHom",
    "isProp": false,
    "doc":
    "Precomposition of functions into a normed ring by a continuous map is an algebra homomorphism.\n",
    "depth": 23},
   {"type":
    "{R : Type u1} â†’\n  [inst : CommRing R] â†’\n    {M : Type u2} â†’\n      [inst_1 : AddCommGroup M] â†’\n        [inst_2 : Module R M] â†’\n          [inst_3 : Module Ráµáµ’áµ– M] â†’ [inst_4 : IsCentralScalar R M] â†’ ExteriorAlgebra R M â†’â‚[R] TrivSqZeroExt R M",
    "name": "ExteriorAlgebra.toTrivSqZeroExt",
    "isProp": false,
    "doc":
    "The canonical map from `ExteriorAlgebra R M` into `TrivSqZeroExt R M` that sends\n`ExteriorAlgebra.Î¹` to `TrivSqZeroExt.inr`. ",
    "depth": 27},
   {"type":
    "âˆ€ {R : Type uR} {S : Type uS} {A : Type uA} {B : Type uB} {C : Type uC} [inst : CommSemiring R] [inst_1 : Semiring A]\n  [inst_2 : Algebra R A] [inst_3 : Semiring B] [inst_4 : Algebra R B] [inst_5 : Semiring C] [inst_6 : Algebra R C]\n  [inst_7 : CommSemiring S] [inst_8 : Algebra S A] [inst_9 : Algebra R S] [inst_10 : Algebra S C]\n  [inst_11 : IsScalarTower R S A] [inst_12 : IsScalarTower R S C] â¦ƒf g : TensorProduct R A B â†’â‚[S] Câ¦„,\n  AlgHom.comp f Algebra.TensorProduct.includeLeft = AlgHom.comp g Algebra.TensorProduct.includeLeft â†’\n    AlgHom.comp (AlgHom.restrictScalars R f) Algebra.TensorProduct.includeRight =\n        AlgHom.comp (AlgHom.restrictScalars R g) Algebra.TensorProduct.includeRight â†’\n      f = g",
    "name": "Algebra.TensorProduct.ext",
    "isProp": true,
    "doc":
    "A version of `TensorProduct.ext` for `AlgHom`.\n\nUsing this as the `@[ext]` lemma instead of `Algebra.TensorProduct.ext'` allows `ext` to apply\nlemmas specific to `A â†’â‚[S] _` and `B â†’â‚[R] _`; notably this allows recursion into nested tensor\nproducts of algebras.\n\nSee note [partially-applied ext lemmas]. ",
    "depth": 48}],
  "count": 895},
 {"noDocExamples": [],
  "kind": "Rat.termâ„š",
  "examples":
  [{"type":
    "{Î± : Type u_1} â†’ [inst : AddCommMonoid Î±] â†’ [inst_1 : Module â„š Î±] â†’ Module NNRat Î±",
    "name":
    "NNRat.instModuleNNRatToSemiringToDivisionSemiringToSemifieldToLinearOrderedSemifieldInstNNRatCanonicallyLinearOrderedSemifield",
    "isProp": false,
    "doc": "A `Module` over `â„š` restricts to a `Module` over `â„šâ‰¥0`. ",
    "depth": 10},
   {"type":
    "âˆ€ {p : â„•+} {K : Type u} [inst : Field K] [inst_1 : CharZero K] {Î¶ : K} [hp : Fact (Nat.Prime â†‘p)]\n  [h : IsCyclotomicExtension {p} â„š K] (hÎ¶ : IsPrimitiveRoot Î¶ â†‘p), Prime (IsPrimitiveRoot.toInteger hÎ¶ - 1)",
    "name": "IsPrimitiveRoot.zeta_sub_one_prime'",
    "isProp": true,
    "doc": "`Î¶ - 1` is prime if `Î¶` is a primitive `p`-th root of unity. ",
    "depth": 30},
   {"type": "â†¥(NumberField.ringOfIntegers â„š) â‰ƒ+* â„¤",
    "name": "Rat.ringOfIntegersEquiv",
    "isProp": false,
    "doc": "The ring of integers of `â„š` as a number field is just `â„¤`. ",
    "depth": 24}],
  "count": 883},
 {"noDocExamples": [],
  "kind": "Filter.Â«term_=á¶ [_]_Â»",
  "examples":
  [{"type":
    "âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {f g : MeasureTheory.SimpleFunc Î± ENNReal},\n  â†‘f =á¶ [MeasureTheory.Measure.ae Î¼] â†‘g â†’ MeasureTheory.SimpleFunc.lintegral f Î¼ = MeasureTheory.SimpleFunc.lintegral g Î¼",
    "name": "MeasureTheory.SimpleFunc.lintegral_congr",
    "isProp": true,
    "doc":
    "If two simple functions are equal a.e., then their `lintegral`s are equal. ",
    "depth": 12},
   {"type":
    "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {l : Filter Î±} {f g : Î± â†’ Î²}, f =á¶ [l] g â†’ â†‘f = â†‘g",
    "name": "Filter.EventuallyEq.germ_eq",
    "isProp": true,
    "doc": "**Alias** of the reverse direction of `Filter.Germ.coe_eq`.",
    "depth": 12},
   {"type":
    "âˆ€ {Î± : Type u} {Î² : Type v} {mâ‚ mâ‚‚ : Î± â†’ Î²} {f : Filter Î±}, mâ‚ =á¶ [f] mâ‚‚ â†’ Filter.map mâ‚ f = Filter.map mâ‚‚ f",
    "name": "Filter.map_congr",
    "isProp": true,
    "doc":
    "If functions `mâ‚` and `mâ‚‚` are eventually equal at a filter `f`, then\nthey map this filter to the same filter. ",
    "depth": 12}],
  "count": 882},
 {"noDocExamples": [],
  "kind": "Â«term_Ã—Ë¢_Â»",
  "examples":
  [{"type":
    "âˆ€ {Î± : Type u_1} {f : Filter Î±} {p : Î± Ã— Î± â†’ Prop}, (âˆ€á¶  (i : Î± Ã— Î±) in f Ã—Ë¢ f, p i) â†’ âˆ€á¶  (i : Î±) in f, p (i, i)",
    "name": "Filter.Eventually.diag_of_prod",
    "isProp": true,
    "doc":
    "A fact that is eventually true about all pairs `l Ã—Ë¢ l` is eventually true about\nall diagonal pairs `(i, i)` ",
    "depth": 12},
   {"type":
    "âˆ€ {Î± : Type u_1} {Ixx : Î± â†’ Î± â†’ Set Î±} {lâ‚ : Filter Î±} {lâ‚‚ : outParam (Filter Î±)}\n  [self : Filter.TendstoIxxClass Ixx lâ‚ lâ‚‚], Filter.Tendsto (fun p => Ixx p.1 p.2) (lâ‚ Ã—Ë¢ lâ‚) (Filter.smallSets lâ‚‚)",
    "name": "Filter.TendstoIxxClass.tendsto_Ixx",
    "isProp": true,
    "doc":
    "`Function.uncurry Ixx` tends to `lâ‚‚.smallSets` along `lâ‚ Ã—Ë¢ lâ‚`. In other words, for any\n`s âˆˆ lâ‚‚` there exists `t âˆˆ lâ‚` such that `Ixx x y âŠ† s` whenever `x âˆˆ t` and `y âˆˆ t`.\n\nUse lemmas like `Filter.Tendsto.Icc` instead. ",
    "depth": 14},
   {"type":
    "âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²] {s : Set Î±} {t : Set Î²},\n  IsOpen (s Ã—Ë¢ t) â†” IsOpen s âˆ§ IsOpen t âˆ¨ s = âˆ… âˆ¨ t = âˆ…",
    "name": "isOpen_prod_iff'",
    "isProp": true,
    "doc":
    "A product set is open in a product space if and only if each factor is open, or one of them is\nempty ",
    "depth": 16}],
  "count": 865},
 {"noDocExamples": [],
  "kind": "Filter.Â«termâˆ€á¶ _In_,_Â»",
  "examples":
  [{"type": "âˆ€á¶  (x : â„) in residual â„, Liouville x",
    "name": "eventually_residual_liouville",
    "isProp": true,
    "doc": "The set of Liouville numbers is a residual set. ",
    "depth": 5},
   {"type":
    "âˆ€ {Î± : Type u} {f : Ultrafilter Î±} {p : Î± â†’ Prop}, (âˆƒá¶  (x : Î±) in â†‘f, p x) â†’ âˆ€á¶  (x : Î±) in â†‘f, p x",
    "name": "Filter.Frequently.eventually",
    "isProp": true,
    "doc":
    "**Alias** of the forward direction of `Ultrafilter.frequently_iff_eventually`.",
    "depth": 8},
   {"type":
    "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {p : Î± â†’ Prop} {a : Î±}, (âˆ€á¶  (y : Î±) in nhds a, p y) â†’ p a",
    "name": "Filter.Eventually.self_of_nhds",
    "isProp": true,
    "doc":
    "If a predicate is true in a neighborhood of `a`, then it is true for `a`. ",
    "depth": 9}],
  "count": 788},
 {"noDocExamples": [],
  "kind": "Â«termâ„•âˆÂ»",
  "examples":
  [{"type":
    "âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {E : Type uE} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {f : E â†’ F}\n  {n : â„•âˆ}, ContDiff ğ•œ n f â†” HasFTaylorSeriesUpTo n f (ftaylorSeries ğ•œ f)",
    "name": "contDiff_iff_ftaylorSeries",
    "isProp": true,
    "doc":
    "When a function is `C^n` in a set `s` of unique differentiability, it admits\n`ftaylorSeriesWithin ğ•œ f s` as a Taylor series up to order `n` in `s`. ",
    "depth": 22},
   {"type": "â„•âˆ â†’*â‚€ â„•",
    "name": "ENat.toNat",
    "isProp": false,
    "doc": "Conversion of `â„•âˆ` to `â„•` sending `âˆ` to `0`. ",
    "depth": 8},
   {"type":
    "âˆ€ {ğ•‚ : Type u_1} [inst : IsROrC ğ•‚] {E' : Type u_2} [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedSpace ğ•‚ E']\n  {F' : Type u_3} [inst_3 : NormedAddCommGroup F'] [inst_4 : NormedSpace ğ•‚ F'] {f : E' â†’ F'} {n : â„•âˆ},\n  HasCompactSupport f â†’ ContDiff ğ•‚ n f â†’ 1 â‰¤ n â†’ âˆƒ C, LipschitzWith C f",
    "name": "ContDiff.lipschitzWith_of_hasCompactSupport",
    "isProp": true,
    "doc": "A `C^1` function with compact support is Lipschitz. ",
    "depth": 24}],
  "count": 765},
 {"noDocExamples": [],
  "kind": "Â«term|___|Â»",
  "examples":
  [{"type":
    "âˆ€ (c : â„‚) (R : â„), Set.range (circleMap c R) = Metric.sphere c |R|",
    "name": "range_circleMap",
    "isProp": true,
    "doc":
    "The range of `circleMap c R` is the circle with center `c` and radius `|R|`. ",
    "depth": 11},
   {"type": "âˆ€ (x : â„), 0 < x â†’ x â‰¤ 1 â†’ |Real.log x * x| < 1",
    "name": "Real.abs_log_mul_self_lt",
    "isProp": true,
    "doc": "Bound for `|log x * x|` in the interval `(0, 1]`. ",
    "depth": 12},
   {"type":
    "âˆ€ {Î± : Type u_1} {l : Filter Î±} {f : Î± â†’ â„},\n  ((fun x => Real.exp (f x)) =Î˜[l] fun x => 1) â†” Filter.IsBoundedUnder (fun x x_1 => x â‰¤ x_1) l fun x => |f x|",
    "name": "Real.isTheta_exp_comp_one",
    "isProp": true,
    "doc":
    "`Real.exp (f x)` is bounded away from zero and infinity along a filter `l` if and only if\n`|f x|` is bounded from above along this filter. ",
    "depth": 13}],
  "count": 711},
 {"noDocExamples": [],
  "kind": "Â«term_Ã—__1Â»",
  "examples":
  [{"type":
    "{Î¹ : Type u_1} â†’ {Î· : Î¹ â†’ Type u_4} â†’ {N : Type u_5} â†’ [inst : Zero N] â†’ ((i : Î¹) Ã— Î· i â†’â‚€ N) â‰ƒ Î â‚€ (i : Î¹), Î· i â†’â‚€ N",
    "name": "sigmaFinsuppEquivDFinsupp",
    "isProp": false,
    "doc":
    "`Finsupp.split` is an equivalence between `(Î£ i, Î· i) â†’â‚€ N` and `Î â‚€ i, (Î· i â†’â‚€ N)`. ",
    "depth": 12},
   {"type":
    "{J : Type v} â†’\n  [inst : CategoryTheory.SmallCategory J] â†’\n    (F : CategoryTheory.Functor J TypeMax) â†’ (j : J) Ã— F.obj j â†’ (j : J) Ã— F.obj j â†’ Prop",
    "name": "CategoryTheory.Limits.Types.FilteredColimit.Rel",
    "isProp": false,
    "doc":
    "An alternative relation on `Î£ j, F.obj j`,\nwhich generates the same equivalence relation as we use to define the colimit in `Type` above,\nbut that is more convenient when working with filtered colimits.\n\nElements in `F.obj j` and `F.obj j'` are equivalent if there is some `k : J` to the right\nwhere their images are equal.\n",
    "depth": 15},
   {"type":
    "{Î± : Type u_1} â†’\n  {Î² : Type u_2} â†’\n    (f : Î± â†’ Î²) â†’\n      {p : Î± â†’ Prop} â†’ {q : Î² â†’ Prop} â†’ (âˆ€ (x : Î±), p x â†” q (f x)) â†’ (y : Subtype q) Ã— { x // f x = â†‘y } â‰ƒ Subtype p",
    "name": "Equiv.sigmaSubtypeFiberEquivSubtype",
    "isProp": false,
    "doc":
    "If for each `x` we have `p x â†” q (f x)`, then `Î£ y : {y // q y}, f â»Â¹' {y}` is equivalent\nto `{x // p x}`. ",
    "depth": 16}],
  "count": 709},
 {"noDocExamples": [],
  "kind": "Â«termâ„•+Â»",
  "examples":
  [{"type":
    "âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : Fact (âˆ€ (I : Ideal R), I â‰  âŠ¤ â†’ CharZero (R â§¸ I))] (n : â„•+), â†‘â†‘n = â†‘â†‘n",
    "name": "EqualCharZero.pnatCast_eq_natCast",
    "isProp": true,
    "doc":
    "Internal: Not intended to be used outside this local construction. ",
    "depth": 18},
   {"type":
    "âˆ€ {p : â„•+} {K : Type u} [inst : Field K] [inst_1 : CharZero K] {Î¶ : K} [hp : Fact (Nat.Prime â†‘p)]\n  [h : IsCyclotomicExtension {p} â„š K] (hÎ¶ : IsPrimitiveRoot Î¶ â†‘p), Prime (IsPrimitiveRoot.toInteger hÎ¶ - 1)",
    "name": "IsPrimitiveRoot.zeta_sub_one_prime'",
    "isProp": true,
    "doc": "`Î¶ - 1` is prime if `Î¶` is a primitive `p`-th root of unity. ",
    "depth": 30},
   {"type": "â„•+ â†’ â„•+ â†’ â„•+",
    "name": "PNat.gcdA'",
    "isProp": false,
    "doc": "Final value of `a / d` ",
    "depth": 2}],
  "count": 627},
 {"noDocExamples": [],
  "kind": "Â«term_â‰ƒâ‚—[_]_Â»",
  "examples":
  [{"type": "Nonempty (â„‚ â‰ƒâ‚—[â„š] â„)",
    "name": "Complex.nonempty_linearEquiv_real",
    "isProp": true,
    "doc":
    "`â„‚` and `â„` are isomorphic as vector spaces over `â„š`, or equivalently,\nas additive groups. ",
    "depth": 15},
   {"type":
    "{R : Type u_3} â†’ [inst : CommRing R] â†’ (câ‚ câ‚‚ : R) â†’ QuaternionAlgebra R câ‚ câ‚‚ â‰ƒâ‚—[R] Fin 4 â†’ R",
    "name": "QuaternionAlgebra.linearEquivTuple",
    "isProp": false,
    "doc": "`QuaternionAlgebra.equivTuple` as a linear equivalence. ",
    "depth": 19},
   {"type":
    "{R : Type u_1} â†’ [inst : CommRing R] â†’ PolynomialModule R R â‰ƒâ‚—[Polynomial R] Polynomial R",
    "name": "PolynomialModule.equivPolynomialSelf",
    "isProp": false,
    "doc":
    "`PolynomialModule R R` is isomorphic to `R[X]` as an `R[X]` module. ",
    "depth": 20}],
  "count": 606},
 {"noDocExamples": [],
  "kind": "Â«term_++_Â»",
  "examples":
  [{"type":
    "âˆ€ {a b : â„•}, Nat.Coprime a b â†’ List.Perm (Nat.factors (a * b)) (Nat.factors a ++ Nat.factors b)",
    "name": "Nat.perm_factors_mul_of_coprime",
    "isProp": true,
    "doc":
    "For coprime `a` and `b`, the prime factors of `a * b` are the union of those of `a` and `b` ",
    "depth": 12},
   {"type":
    "âˆ€ {a b : â„•}, a â‰  0 â†’ b â‰  0 â†’ List.Perm (Nat.factors (a * b)) (Nat.factors a ++ Nat.factors b)",
    "name": "Nat.perm_factors_mul",
    "isProp": true,
    "doc":
    "For positive `a` and `b`, the prime factors of `a * b` are the union of those of `a` and `b` ",
    "depth": 13},
   {"type":
    "âˆ€ {Î± : Type u_1} {n : â„•} {lâ‚ lâ‚‚ : List Î±}, List.drop n (lâ‚ ++ lâ‚‚) = List.drop n lâ‚ ++ List.drop (n - List.length lâ‚) lâ‚‚",
    "name": "List.drop_append_eq_append_drop",
    "isProp": true,
    "doc":
    "Dropping the elements up to `n` in `lâ‚ ++ lâ‚‚` is the same as dropping the elements up to `n`\nin `lâ‚`, dropping the elements up to `n - lâ‚.length` in `lâ‚‚`, and appending them. ",
    "depth": 14}],
  "count": 594},
 {"noDocExamples": [],
  "kind": "Â«term_â‰ƒo_Â»",
  "examples":
  [{"type": "EReal â‰ƒo ERealáµ’áµˆ",
    "name": "EReal.negOrderIso",
    "isProp": false,
    "doc": "Negation as an order reversing isomorphism on `EReal`. ",
    "depth": 5},
   {"type":
    "{Î± : Type u_1} â†’ [inst : Preorder Î±] â†’ Topology.WithLowerSet Î± â‰ƒo Î±",
    "name": "Topology.WithLowerSet.ofLowerSetOrderIso",
    "isProp": false,
    "doc": "`ofLowerSet` as an `OrderIso` ",
    "depth": 7},
   {"type": "(Î± : Type u_1) â†’ Setoid Î± â‰ƒo { C // Setoid.IsPartition C }",
    "name": "Setoid.Partition.orderIso",
    "isProp": false,
    "doc":
    "The order-preserving bijection between equivalence relations on a type `Î±`, and\npartitions of `Î±` into subsets. ",
    "depth": 8}],
  "count": 569},
 {"noDocExamples": [],
  "kind": "Set.Â«termâ‹‚_,_Â»",
  "examples":
  [{"type":
    "âˆ€ {Î¹ : Type u} {f : Î¹ â†’ Ordinal.{max u v} â†’ Ordinal.{max u v}},\n  (âˆ€ (i : Î¹), Ordinal.IsNormal (f i)) â†’ Ordinal.derivFamily f = Ordinal.enumOrd (â‹‚ i, Function.fixedPoints (f i))",
    "name": "Ordinal.derivFamily_eq_enumOrd",
    "isProp": true,
    "doc":
    "For a family of normal functions, `Ordinal.derivFamily` enumerates the common fixed points. ",
    "depth": 9},
   {"type":
    "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : BaireSpace Î±] {f : â„• â†’ Set Î±},\n  (âˆ€ (n : â„•), IsOpen (f n)) â†’ (âˆ€ (n : â„•), Dense (f n)) â†’ Dense (â‹‚ n, f n)",
    "name": "dense_iInter_of_isOpen_nat",
    "isProp": true,
    "doc": "Definition of a Baire space. ",
    "depth": 10},
   {"type":
    "âˆ€ {X : Type u_1} {Î¹ : Type u_3} [inst : TopologicalSpace X] [inst_1 : Encodable Î¹] {s : Î¹ â†’ Set X},\n  (âˆ€ (i : Î¹), IsGÎ´ (s i)) â†’ IsGÎ´ (â‹‚ i, s i)",
    "name": "isGÎ´_iInter",
    "isProp": true,
    "doc": "The intersection of an encodable family of GÎ´ sets is a GÎ´ set. ",
    "depth": 10}],
  "count": 561},
 {"noDocExamples": [],
  "kind": "Â«term_áµƒáµ’áµ–Â»",
  "examples":
  [{"type":
    "âˆ€ {M : Type u_1} {X : Type u_2} [inst : TopologicalSpace M] [inst_1 : TopologicalSpace X] [inst_2 : VAdd M X]\n  [inst_3 : ContinuousVAdd M X] [inst_4 : VAdd Máµƒáµ’áµ– X] [inst_5 : IsCentralVAdd M X], ContinuousVAdd Máµƒáµ’áµ– X",
    "name": "ContinuousVAdd.op",
    "isProp": true,
    "doc":
    "If an additive action is central, then its right action is continuous when its left\naction is.",
    "depth": 14},
   {"type": "{Î± : Type u_1} â†’ Î±áµƒáµ’áµ– â†’ Î±",
    "name": "AddOpposite.unop",
    "isProp": false,
    "doc": "The element of `Î±` represented by `x : Î±áµƒáµ’áµ–`.",
    "depth": 3},
   {"type":
    "{M : Type u_1} â†’ [inst : AddZeroClass M] â†’ AddSubmonoid M â‰ƒ AddSubmonoid Máµƒáµ’áµ–",
    "name": "AddSubmonoid.opEquiv",
    "isProp": false,
    "doc":
    "A additive submonoid `H` of `G` determines an additive submonoid\n`H.op` of the opposite group `Gáµáµ’áµ–`.",
    "depth": 6}],
  "count": 554},
 {"noDocExamples": [],
  "kind": "Â«termÎ â‚€_,_Â»",
  "examples":
  [{"type":
    "âˆ€ {Î¹ : Type u} {Î² : Î¹ â†’ Type v} [dec : DecidableEq Î¹] [inst : (i : Î¹) â†’ AddZeroClass (Î² i)] {Î³ : Type w}\n  [inst_1 : AddZeroClass Î³] â¦ƒf g : (Î â‚€ (i : Î¹), Î² i) â†’+ Î³â¦„,\n  (âˆ€ (i : Î¹) (y : Î² i), f (DFinsupp.single i y) = g (DFinsupp.single i y)) â†’ f = g",
    "name": "DFinsupp.addHom_ext",
    "isProp": true,
    "doc":
    "If two additive homomorphisms from `Î â‚€ i, Î² i` are equal on each `single a b`, then\nthey are equal. ",
    "depth": 34},
   {"type":
    "{Î¹ : Type u} â†’ {Î² : Î¹ â†’ Type v} â†’ [inst : (i : Î¹) â†’ Zero (Î² i)] â†’ CoeFun (Î â‚€ (i : Î¹), Î² i) fun x => (i : Î¹) â†’ Î² i",
    "name": "DFinsupp.instCoeFunDFinsuppForAll",
    "isProp": false,
    "doc":
    "Helper instance for when there are too many metavariables to apply `FunLike.coeFunForall`\ndirectly. ",
    "depth": 9},
   {"type":
    "âˆ€ {Î¹ : Type u_1} {Ï€ : Î¹ â†’ Type u_2} [inst : âˆ€ (i : Î¹), Infinite (Ï€ i)] [inst : (i : Î¹) â†’ Zero (Ï€ i)]\n  [inst_1 : Nonempty Î¹], Infinite (Î â‚€ (i : Î¹), Ï€ i)",
    "name": "DFinsupp.infinite_of_right",
    "isProp": true,
    "doc":
    "See `DFinsupp.infinite_of_exists_right` for the case that only one `Ï€ Î¹` is infinite. ",
    "depth": 10}],
  "count": 544},
 {"noDocExamples": [],
  "kind": "CategoryTheory.Â«term_â‰Œ_Â»",
  "examples":
  [{"type": "AlgebraicGeometry.AffineScheme â‰Œ CommRingCatáµ’áµ–",
    "name": "AlgebraicGeometry.AffineScheme.equivCommRingCat",
    "isProp": false,
    "doc":
    "The category of affine schemes is equivalent to the category of commutative rings. ",
    "depth": 4},
   {"type":
    "{C : Type uâ‚} â†’\n  {D : Type uâ‚‚} â†’\n    [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] â†’\n      [inst_1 : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D] â†’ (C â‰Œ D) â†’ CategoryTheory.Functor D C",
    "name": "CategoryTheory.Equivalence.inverse",
    "isProp": false,
    "doc": "A functor in the other direction ",
    "depth": 9},
   {"type":
    "{C : Type uâ‚} â†’\n  [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] â†’\n    [inst_1 : CategoryTheory.MonoidalCategory C] â†’\n      {D : Type uâ‚‚} â†’ [inst_2 : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D] â†’ (C â‰Œ D) â†’ CategoryTheory.MonoidalCategory D",
    "name": "CategoryTheory.Monoidal.transport",
    "isProp": false,
    "doc":
    "Transport a monoidal structure along an equivalence of (plain) categories.\n",
    "depth": 10}],
  "count": 541},
 {"noDocExamples": [],
  "kind": "Â«termâˆ‘'_,_Â»",
  "examples":
  [{"type":
    "âˆ€ {Î± : Type u_1} {f : Î± â†’ ENNReal}, âˆ‘' (i : Î±), f i â‰  âŠ¤ â†’ Set.Countable (Function.support f)",
    "name": "Summable.countable_support_ennreal",
    "isProp": true,
    "doc": "Finitely summable non-negative functions have countable support ",
    "depth": 14},
   {"type":
    "âˆ€ (f : â„• â†’ NNReal), Filter.Tendsto (fun i => âˆ‘' (k : â„•), f (k + i)) Filter.atTop (nhds 0)",
    "name": "NNReal.tendsto_sum_nat_add",
    "isProp": true,
    "doc":
    "For `f : â„• â†’ â„â‰¥0`, then `âˆ‘' k, f (k + i)` tends to zero. This does not require a summability\nassumption on `f`, as otherwise all sums are zero. ",
    "depth": 14},
   {"type":
    "âˆ€ {Î¹ : Type u_1} {E : Type u_3} [inst : SeminormedAddCommGroup E] {f : Î¹ â†’ E},\n  (Summable fun i => â€–f iâ€–) â†’ â€–âˆ‘' (i : Î¹), f iâ€– â‰¤ âˆ‘' (i : Î¹), â€–f iâ€–",
    "name": "norm_tsum_le_tsum_norm",
    "isProp": true,
    "doc":
    "If `âˆ‘' i, â€–f iâ€–` is summable, then `â€–âˆ‘' i, f iâ€– â‰¤ (âˆ‘' i, â€–f iâ€–)`. Note that we do not assume\nthat `âˆ‘' i, f i` is summable, and it might not be the case if `Î±` is not a complete space. ",
    "depth": 15}],
  "count": 525},
 {"noDocExamples": [],
  "kind": "Â«term_â‰ƒ*_Â»",
  "examples":
  [{"type":
    "{M : Type u_6} â†’\n  {N : Type u_7} â†’ [inst : Mul M] â†’ [inst_1 : Mul N] â†’ (f : M â‰ƒ N) â†’ (âˆ€ (x y : M), f (x * y) = f x * f y) â†’ M â‰ƒ* N",
    "name": "MulEquiv.mk'",
    "isProp": false,
    "doc":
    "Makes a multiplicative isomorphism from a bijection which preserves multiplication. ",
    "depth": 19},
   {"type":
    "âˆ€ {M : Type u_6} {N : Type u_7} [inst : Mul M] [inst_1 : Mul N] {f g : M â‰ƒ* N}, (âˆ€ (x : M), f x = g x) â†’ f = g",
    "name": "MulEquiv.ext",
    "isProp": true,
    "doc":
    "Two multiplicative isomorphisms agree if they are defined by the\nsame underlying function. ",
    "depth": 25},
   {"type":
    "{M : Type u_12} â†’ {N : Type u_13} â†’ [inst : Mul M] â†’ [inst_1 : Mul N] â†’ M â‰ƒ* N â†’ M â†’â‚™* N",
    "name": "MulEquiv.toMulHom",
    "isProp": false,
    "doc": "The `MulHom` underlying a `MulEquiv`. ",
    "depth": 9}],
  "count": 522},
 {"noDocExamples": [],
  "kind": "Â«term_â‰ƒâ‚[_]_Â»",
  "examples":
  [{"type": "{K : Type u_1} â†’ [inst : IsROrC K] â†’ K â‰ƒâ‚[â„] K",
    "name": "IsROrC.conjAe",
    "isProp": false,
    "doc": "Conjugate as an `â„`-algebra equivalence ",
    "depth": 13},
   {"type":
    "{R : Type u_3} â†’ [inst : CommRing R] â†’ Quaternion R â‰ƒâ‚[R] (Quaternion R)áµáµ’áµ–",
    "name": "Quaternion.starAe",
    "isProp": false,
    "doc": "Quaternion conjugate as an `AlgEquiv` to the opposite ring. ",
    "depth": 15},
   {"type":
    "âˆ€ {R : Type wâ‚} {A : Type wâ‚‚} {B : Type wâ‚ƒ} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A]\n  [inst_3 : CommRing B] [inst_4 : Algebra R B],\n  Algebra.FinitePresentation R A â†’ (A â‰ƒâ‚[R] B) â†’ Algebra.FinitePresentation R B",
    "name": "Algebra.FinitePresentation.equiv",
    "isProp": true,
    "doc": "If `e : A â‰ƒâ‚[R] B` and `A` is finitely presented, then so is `B`. ",
    "depth": 18}],
  "count": 522},
 {"noDocExamples": [],
  "kind": "Â«termâ€–_â€–â‚ŠÂ»",
  "examples":
  [{"type":
    "âˆ€ {E : Type u_6} [inst : SeminormedAddGroup E] (a b : E), nndist a b = â€–a - bâ€–â‚Š",
    "name": "nndist_eq_nnnorm",
    "isProp": true,
    "doc": "**Alias** of `nndist_eq_nnnorm_sub`.",
    "depth": 14},
   {"type":
    "âˆ€ {E : Type u_6} [inst : SeminormedAddGroup E] (a b : E), â€–bâ€–â‚Š â‰¤ â€–aâ€–â‚Š + â€–a - bâ€–â‚Š",
    "name": "nnnorm_le_insert",
    "isProp": true,
    "doc": "**Alias** of `nnnorm_le_nnnorm_add_nnnorm_sub`.",
    "depth": 15},
   {"type":
    "âˆ€ {Î¹ : Type u_1} {E : Type u_3} [inst : SeminormedAddCommGroup E] {f : Î¹ â†’ E},\n  (Summable fun i => â€–f iâ€–â‚Š) â†’ â€–âˆ‘' (i : Î¹), f iâ€–â‚Š â‰¤ âˆ‘' (i : Î¹), â€–f iâ€–â‚Š",
    "name": "nnnorm_tsum_le",
    "isProp": true,
    "doc":
    "If `âˆ‘' i, â€–f iâ€–â‚Š` is summable, then `â€–âˆ‘' i, f iâ€–â‚Š â‰¤ âˆ‘' i, â€–f iâ€–â‚Š`. Note that\nwe do not assume that `âˆ‘' i, f i` is summable, and it might not be the case if `Î±` is not a complete\nspace. ",
    "depth": 15}],
  "count": 513},
 {"noDocExamples": [],
  "kind": "Â«term_%_Â»",
  "examples":
  [{"type": "âˆ€ {n a : â„•}, Even n â†’ Even a â†’ Even (n % a)",
    "name": "Even.mod_even",
    "isProp": true,
    "doc": "If `n` is even and `a` is even, then `n % a` is even. ",
    "depth": 11},
   {"type": "âˆ€ {n a : â„•}, Odd n â†’ Even a â†’ Odd (n % a)",
    "name": "Odd.mod_even",
    "isProp": true,
    "doc": "If `n` is odd and `a` is even, then `n % a` is odd. ",
    "depth": 11},
   {"type": "âˆ€ {n : â„•}, n % 4 = 1 â†’ (-1) ^ (n / 2) = 1",
    "name": "ZMod.neg_one_pow_div_two_of_one_mod_four",
    "isProp": true,
    "doc": "If `n % 4 = 1`, then `(-1)^(n/2) = 1`. ",
    "depth": 11}],
  "count": 506},
 {"noDocExamples": [],
  "kind": "MeasureTheory.Â«termâˆ€áµ_âˆ‚_,_Â»",
  "examples":
  [{"type":
    "âˆ€ {Î± : Type u_2} {m0 : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {s t : Î± â†’ Prop},\n  s =á¶ [MeasureTheory.Measure.ae Î¼] t â†’\n    âˆ€ {p : Î± â†’ Prop},\n      (âˆ€áµ (x : Î±) âˆ‚MeasureTheory.Measure.restrict Î¼ s, p x) â†’ âˆ€áµ (x : Î±) âˆ‚MeasureTheory.Measure.restrict Î¼ t, p x",
    "name": "MeasureTheory.ae_restrict_of_ae_eq_of_ae_restrict",
    "isProp": true,
    "doc":
    "If two measurable sets are ae_eq then any proposition that is almost everywhere true on one\nis almost everywhere true on the other ",
    "depth": 14},
   {"type":
    "âˆ€ {Î± : Type u_2} {m0 : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {s t : Î± â†’ Prop},\n  s =á¶ [MeasureTheory.Measure.ae Î¼] t â†’\n    âˆ€ {p : Î± â†’ Prop},\n      (âˆ€áµ (x : Î±) âˆ‚MeasureTheory.Measure.restrict Î¼ s, p x) â†” âˆ€áµ (x : Î±) âˆ‚MeasureTheory.Measure.restrict Î¼ t, p x",
    "name": "MeasureTheory.ae_restrict_congr_set",
    "isProp": true,
    "doc":
    "If two measurable sets are ae_eq then any proposition that is almost everywhere true on one\nis almost everywhere true on the other ",
    "depth": 15},
   {"type":
    "âˆ€ {Î± : Type u_1} {m0 : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {f : Î± â†’ ENNReal},\n  AEMeasurable f â†’\n    (âˆ€áµ (x : Î±) âˆ‚Î¼, f x â‰  0) â†’\n      (âˆ€áµ (x : Î±) âˆ‚Î¼, f x â‰  âŠ¤) â†’ MeasureTheory.Measure.AbsolutelyContinuous Î¼ (MeasureTheory.Measure.withDensity Î¼ f)",
    "name": "MeasureTheory.withDensity_absolutelyContinuous'",
    "isProp": true,
    "doc":
    "If `f` is almost everywhere positive and finite, then `Î¼ â‰ª Î¼.withDensity f`. See also\n`withDensity_absolutelyContinuous` for the reverse direction, which always holds. ",
    "depth": 16}],
  "count": 487},
 {"noDocExamples": [],
  "kind": "Â«term_â‰ƒ+_Â»",
  "examples":
  [{"type":
    "{Î± : Type u_2} â†’ {Î² : Type u_3} â†’ FreeAbelianGroup Î± â‰ƒ+ FreeAbelianGroup Î² â†’ Î± â‰ƒ Î²",
    "name": "FreeAbelianGroup.Equiv.ofFreeAbelianGroupEquiv",
    "isProp": false,
    "doc":
    "Isomorphic free abelian groups (as additive groups) have equivalent bases. ",
    "depth": 11},
   {"type":
    "{F : Type u_1} â†’\n  {Î± : Type u_2} â†’\n    {Î² : Type u_3} â†’ [inst : Add Î±] â†’ [inst_1 : Add Î²] â†’ [inst_2 : AddEquivClass F Î± Î²] â†’ CoeTC F (Î± â‰ƒ+ Î²)",
    "name": "instCoeTCAddEquiv",
    "isProp": false,
    "doc":
    "Any type satisfying `AddEquivClass` can be cast into `AddEquiv` via\n`AddEquivClass.toAddEquiv`. ",
    "depth": 11},
   {"type":
    "{G : Type u_1} â†’\n  {H : Type u_2} â†’ [inst : MulOneClass G] â†’ [inst_1 : AddZeroClass H] â†’ Additive G â‰ƒ+ H â‰ƒ (G â‰ƒ* Multiplicative H)",
    "name": "AddEquiv.toMultiplicative'",
    "isProp": false,
    "doc": "Reinterpret `Additive G â‰ƒ+ H` as `G â‰ƒ* Multiplicative H`. ",
    "depth": 11}],
  "count": 477},
 {"noDocExamples": [],
  "kind": "Â«term_â‰ƒ+*_Â»",
  "examples":
  [{"type":
    "{R : Type u_4} â†’\n  {S : Type u_5} â†’ [inst : Mul R] â†’ [inst_1 : Mul S] â†’ [inst_2 : Add R] â†’ [inst_3 : Add S] â†’ R â‰ƒ+* S â†’ S â‰ƒ+* R",
    "name": "RingEquiv.symm",
    "isProp": false,
    "doc": "The inverse of a ring isomorphism is a ring isomorphism. ",
    "depth": 13},
   {"type":
    "{X Y : Type u_1} â†’\n  [inst : CommSemiring X] â†’ [inst_1 : CommSemiring Y] â†’ X â‰ƒ+* Y â†’ (CommSemiRingCat.of X â‰… CommSemiRingCat.of Y)",
    "name": "RingEquiv.toCommSemiRingCatIso",
    "isProp": false,
    "doc":
    "Ring equivalence are isomorphisms in category of commutative semirings\n",
    "depth": 14},
   {"type":
    "{R : Type u_2} â†’\n  [inst : Semiring R] â†’ {Ïƒ : Type u_3} â†’ [inst_1 : Fintype Ïƒ] â†’ HahnSeries (Ïƒ â†’â‚€ â„•) R â‰ƒ+* MvPowerSeries Ïƒ R",
    "name": "HahnSeries.toMvPowerSeries",
    "isProp": false,
    "doc":
    "The ring `HahnSeries (Ïƒ â†’â‚€ â„•) R` is isomorphic to `MvPowerSeries Ïƒ R` for a `Fintype` `Ïƒ`.\nWe take the index set of the hahn series to be `Finsupp` rather than `pi`,\neven though we assume `Fintype Ïƒ` as this is more natural for alignment with `MvPowerSeries`.\nAfter importing `Algebra.Order.Pi` the ring `HahnSeries (Ïƒ â†’ â„•) R` could be constructed instead.\n ",
    "depth": 17}],
  "count": 457},
 {"noDocExamples": [],
  "kind": "Â«term_â‰ˆ_Â»",
  "examples":
  [{"type":
    "âˆ€ (G : SetTheory.PGame) [inst : SetTheory.PGame.Impartial G], G â‰ˆ SetTheory.PGame.nim (SetTheory.PGame.grundyValue G)",
    "name": "SetTheory.PGame.equiv_nim_grundyValue",
    "isProp": true,
    "doc":
    "The Sprague-Grundy theorem which states that every impartial game is equivalent to a game of\nnim, namely the game of nim corresponding to the games Grundy value ",
    "depth": 7},
   {"type":
    "âˆ€ {x y : SetTheory.PGame}, SetTheory.PGame.Relabelling x y â†’ x â‰ˆ y",
    "name": "SetTheory.PGame.Relabelling.equiv",
    "isProp": true,
    "doc": "A relabelling lets us prove equivalence of games. ",
    "depth": 8},
   {"type": "âˆ€ (x : SetTheory.PGame), 0 * x â‰ˆ 0",
    "name": "SetTheory.PGame.zero_mul_equiv",
    "isProp": true,
    "doc": "`0 * x` is equivalent to `0`. ",
    "depth": 9}],
  "count": 454},
 {"noDocExamples": [],
  "kind": "CategoryTheory.Â«term_âŠ£_Â»",
  "examples":
  [{"type": "CategoryTheory.Cat.free âŠ£ CategoryTheory.Quiv.forget",
    "name": "CategoryTheory.Quiv.adj",
    "isProp": false,
    "doc":
    "The adjunction between forming the free category on a quiver, and forgetting a category to a quiver.\n",
    "depth": 6},
   {"type": "CompHaus.toProfinite âŠ£ profiniteToCompHaus",
    "name": "Profinite.toProfiniteAdjToCompHaus",
    "isProp": false,
    "doc":
    "The adjunction between CompHaus.to_Profinite and Profinite.to_CompHaus ",
    "depth": 6},
   {"type":
    "{C : Type u} â†’\n  [inst : CategoryTheory.Category.{v, u} C] â†’\n    (T : CategoryTheory.Monad C) â†’\n      CategoryTheory.Kleisli.Adjunction.toKleisli T âŠ£ CategoryTheory.Kleisli.Adjunction.fromKleisli T",
    "name": "CategoryTheory.Kleisli.Adjunction.adj",
    "isProp": false,
    "doc":
    "The Kleisli adjunction which gives rise to the monad `(T, Î·_ T, Î¼_ T)`.\ncf Lemma 5.2.11 of [Riehl][riehl2017]. ",
    "depth": 10}],
  "count": 447},
 {"noDocExamples": [],
  "kind": "Â«term_^[_]Â»",
  "examples":
  [{"type":
    "âˆ€ {Î± : Type u} {f : Î± â†’ Î±} {x : Î±}, Function.IsFixedPt f x â†’ âˆ€ (n : â„•), Function.IsFixedPt f^[n] x",
    "name": "Function.IsFixedPt.iterate",
    "isProp": true,
    "doc":
    "If `x` is a fixed point of `f`, then it is a fixed point of `f^[n]`. ",
    "depth": 10},
   {"type":
    "âˆ€ {Î± : Type u_1} (f : Î± â†’ Î±) (x : Î±),\n  Function.periodicOrbit f x = Cycle.map (fun n => f^[n] x) â†‘(List.range (Function.minimalPeriod f x))",
    "name": "Function.periodicOrbit_eq_cycle_map",
    "isProp": true,
    "doc": "The definition of a periodic orbit, in terms of `Cycle.map`. ",
    "depth": 11},
   {"type":
    "âˆ€ {Î± : Type u_2} [inst : MeasurableSpace Î±] {f : Î± â†’ Î±} {Î¼ : MeasureTheory.Measure Î±},\n  MeasureTheory.Conservative f Î¼ â†’ âˆ€ (n : â„•), MeasureTheory.Conservative f^[n] Î¼",
    "name": "MeasureTheory.Conservative.iterate",
    "isProp": true,
    "doc": "Iteration of a conservative system is a conservative system. ",
    "depth": 11}],
  "count": 422},
 {"noDocExamples": [],
  "kind": "Â«term_â‰ƒâ‚œ_Â»",
  "examples":
  [{"type": "{M : Type u_1} â†’ [inst : TopologicalSpace M] â†’ M â‰ƒâ‚œ Máµáµ’áµ–",
    "name": "MulOpposite.opHomeomorph",
    "isProp": false,
    "doc": "`MulOpposite.op` as a homeomorphism. ",
    "depth": 6},
   {"type": "{X : Type u} â†’ [inst : TopologicalSpace X] â†’ ULift.{v, u} X â‰ƒâ‚œ X",
    "name": "Homeomorph.ulift",
    "isProp": false,
    "doc": "`ULift X` is homeomorphic to `X`. ",
    "depth": 7},
   {"type": "{X Y : Stonean} â†’ CoeSort.coe X â‰ƒâ‚œ CoeSort.coe Y â†’ (X â‰… Y)",
    "name": "Stonean.isoOfHomeo",
    "isProp": false,
    "doc": "Construct an isomorphism from a homeomorphism. ",
    "depth": 11}],
  "count": 418},
 {"noDocExamples": [],
  "kind": "MeasureTheory.Â«termâˆ«â»_,_âˆ‚_Â»",
  "examples":
  [{"type":
    "âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {f : Î± â†’ â„},\n  MeasureTheory.Integrable f â†’\n    âˆ« (a : Î±), f a âˆ‚Î¼ =\n      ENNReal.toReal (âˆ«â» (a : Î±), ENNReal.ofReal (f a) âˆ‚Î¼) - ENNReal.toReal (âˆ«â» (a : Î±), ENNReal.ofReal (-f a) âˆ‚Î¼)",
    "name":
    "MeasureTheory.integral_eq_lintegral_pos_part_sub_lintegral_neg_part",
    "isProp": true,
    "doc":
    "The Bochner integral of a real-valued function `f : Î± â†’ â„` is the difference between the\nintegral of the positive part of `f` and the integral of the negative part of `f`.  ",
    "depth": 14},
   {"type":
    "âˆ€ {Î± : Type u_1} {Î² : Type u_3} [inst : MeasurableSpace Î±] [inst_1 : MeasurableSpace Î²] {Î¼ : MeasureTheory.Measure Î±}\n  [inst_2 : MeasureTheory.SFinite Î¼] {f : Î± â†’ Î² â†’ ENNReal},\n  Measurable (Function.uncurry f) â†’ Measurable fun y => âˆ«â» (x : Î±), f x y âˆ‚Î¼",
    "name": "Measurable.lintegral_prod_left",
    "isProp": true,
    "doc":
    "The Lebesgue integral is measurable. This shows that the integrand of (the right-hand-side of)\nthe symmetric version of Tonelli's theorem is measurable.\nThis version has the argument `f` in curried form. ",
    "depth": 15},
   {"type":
    "âˆ€ {Î± : Type u_1} {Î² : Type u_3} [inst : MeasurableSpace Î±] [inst_1 : MeasurableSpace Î²] {Î½ : MeasureTheory.Measure Î²}\n  [inst_2 : MeasureTheory.SFinite Î½] {f : Î± â†’ Î² â†’ ENNReal},\n  Measurable (Function.uncurry f) â†’ Measurable fun x => âˆ«â» (y : Î²), f x y âˆ‚Î½",
    "name": "Measurable.lintegral_prod_right",
    "isProp": true,
    "doc":
    "The Lebesgue integral is measurable. This shows that the integrand of (the right-hand-side of)\nTonelli's theorem is measurable.\nThis version has the argument `f` in curried form. ",
    "depth": 15}],
  "count": 404},
 {"noDocExamples": [],
  "kind": "MeasureTheory.Â«termâˆ«_,_âˆ‚_Â»",
  "examples":
  [{"type":
    "âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {f : Î± â†’ â„},\n  MeasureTheory.Integrable f â†’\n    âˆ« (a : Î±), f a âˆ‚Î¼ =\n      ENNReal.toReal (âˆ«â» (a : Î±), ENNReal.ofReal (f a) âˆ‚Î¼) - ENNReal.toReal (âˆ«â» (a : Î±), ENNReal.ofReal (-f a) âˆ‚Î¼)",
    "name":
    "MeasureTheory.integral_eq_lintegral_pos_part_sub_lintegral_neg_part",
    "isProp": true,
    "doc":
    "The Bochner integral of a real-valued function `f : Î± â†’ â„` is the difference between the\nintegral of the positive part of `f` and the integral of the negative part of `f`.  ",
    "depth": 14},
   {"type":
    "âˆ€ {Î± : Type u_1} {m0 : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {f : Î± â†’ â„}\n  [inst : MeasureTheory.IsProbabilityMeasure Î¼], MeasureTheory.Integrable f â†’ âˆƒ x, f x â‰¤ âˆ« (a : Î±), f a âˆ‚Î¼",
    "name": "MeasureTheory.exists_le_integral",
    "isProp": true,
    "doc":
    "**First moment method**. The minimum of an integrable function is smaller than its integral. ",
    "depth": 16},
   {"type":
    "âˆ€ {Î± : Type u_1} {m0 : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {f : Î± â†’ â„}\n  [inst : MeasureTheory.IsProbabilityMeasure Î¼], MeasureTheory.Integrable f â†’ âˆƒ x, âˆ« (a : Î±), f a âˆ‚Î¼ â‰¤ f x",
    "name": "MeasureTheory.exists_integral_le",
    "isProp": true,
    "doc":
    "**First moment method**. The maximum of an integrable function is greater than its integral. ",
    "depth": 17}],
  "count": 398},
 {"noDocExamples": [],
  "kind": "Â«term_â†’â‚›â‚—[_]_Â»",
  "examples":
  [{"type":
    "{R : Type u_1} â†’\n  {M : Type u_5} â†’\n    {Mâ‚ : Type u_6} â†’\n      [inst : CommSemiring R] â†’\n        [inst_1 : AddCommMonoid M] â†’\n          [inst_2 : Module R M] â†’\n            [inst_3 : AddCommMonoid Mâ‚] â†’\n              [inst_4 : Module R Mâ‚] â†’\n                {I : R â†’+* R} â†’ (M â†’â‚—[R] M â†’â‚›â‚—[I] R) â†’ (Mâ‚ â†’â‚—[R] Mâ‚ â†’â‚›â‚—[I] R) â†’ (M â†’â‚—[R] Mâ‚) â†’ (Mâ‚ â†’â‚—[R] M) â†’ Prop",
    "name": "LinearMap.IsAdjointPair",
    "isProp": false,
    "doc":
    "Given a pair of modules equipped with bilinear forms, this is the condition for a pair of\nmaps between them to be mutually adjoint. ",
    "depth": 27},
   {"type":
    "{R : Type u_1} â†’\n  {Râ‚‚ : Type u_2} â†’\n    {E : Type u_5} â†’\n      {Eâ‚‚ : Type u_6} â†’\n        [inst : Semiring R] â†’\n          [inst_1 : Semiring Râ‚‚] â†’\n            {Ïƒâ‚â‚‚ : R â†’+* Râ‚‚} â†’\n              [inst_2 : SeminormedAddCommGroup E] â†’\n                [inst_3 : SeminormedAddCommGroup Eâ‚‚] â†’\n                  [inst_4 : Module R E] â†’ [inst_5 : Module Râ‚‚ Eâ‚‚] â†’ (f : E â†’â‚›â‚—[Ïƒâ‚â‚‚] Eâ‚‚) â†’ Isometry â‡‘f â†’ E â†’â‚›â‚—áµ¢[Ïƒâ‚â‚‚] Eâ‚‚",
    "name": "LinearMap.toLinearIsometry",
    "isProp": false,
    "doc":
    "Construct a `LinearIsometry` from a `LinearMap` satisfying `Isometry`. ",
    "depth": 30},
   {"type":
    "âˆ€ {K : Type u_1} {V : Type u_2} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {L : Type u_3}\n  {W : Type u_4} [inst_3 : DivisionRing L] [inst_4 : AddCommGroup W] [inst_5 : Module L W] {Ïƒ : K â†’+* L} {Ï„ : L â†’+* K}\n  [inst_6 : RingHomInvPair Ïƒ Ï„] (f : V â†’â‚›â‚—[Ïƒ] W) (hf : Function.Injective â‡‘f),\n  Function.Injective (Projectivization.map f hf)",
    "name": "Projectivization.map_injective",
    "isProp": true,
    "doc":
    "Mapping with respect to a semilinear map over an isomorphism of fields yields\nan injective map on projective spaces. ",
    "depth": 33}],
  "count": 391},
 {"noDocExamples": [],
  "kind": "Â«term_â†’o_Â»",
  "examples":
  [{"type": "{Î± : Type u_2} â†’ [inst : Preorder Î±] â†’ Î± â†’o Î±",
    "name": "OrderHom.id",
    "isProp": false,
    "doc": "The identity function as bundled monotone function. ",
    "depth": 6},
   {"type":
    "{Î± : Type u_2} â†’ {Î² : Type u_3} â†’ [inst : Preorder Î±] â†’ [inst_1 : Preorder Î²] â†’ (Î± â†’o Î²) â†’ Î± â†’ Î²",
    "name": "OrderHom.Simps.coe",
    "isProp": false,
    "doc":
    "See Note [custom simps projection]. We give this manually so that we use `toFun` as the\nprojection directly instead. ",
    "depth": 9},
   {"type":
    "{Î± : Type u_2} â†’ {Î² : Type u_3} â†’ [inst : Preorder Î±] â†’ [inst_1 : Preorder Î²] â†’ (Î± â†’o Î²) â‰ƒ (Î±áµ’áµˆ â†’o Î²áµ’áµˆ)",
    "name": "OrderHom.dual",
    "isProp": false,
    "doc":
    "Reinterpret a bundled monotone function as a monotone function between dual orders. ",
    "depth": 10}],
  "count": 386},
 {"noDocExamples": [],
  "kind": "Function.Â«term_â†ª_Â»",
  "examples":
  [{"type":
    "âˆ€ {Î¹ : Type u} (Î² : Î¹ â†’ Type v) [I : Nonempty Î¹], âˆƒ i, Nonempty ((j : Î¹) â†’ Î² i â†ª Î² j)",
    "name": "Function.Embedding.min_injective",
    "isProp": true,
    "doc":
    "The cardinals are well-ordered. We express it here by the fact that in any set of cardinals\nthere is an element that injects into the others.\nSee `Cardinal.conditionallyCompleteLinearOrderBot` for (one of) the lattice instances. ",
    "depth": 10},
   {"type": "(Î± : Sort u_1) â†’ Î± â†ª Î±",
    "name": "Function.Embedding.refl",
    "isProp": false,
    "doc": "The identity map as a `Function.Embedding`. ",
    "depth": 3},
   {"type": "{Î± : Sort u} â†’ {Î² : Sort v} â†’ Î± â‰ƒ Î² â†’ Î± â†ª Î²",
    "name": "Equiv.toEmbedding",
    "isProp": false,
    "doc":
    "Convert an `Î± â‰ƒ Î²` to `Î± â†ª Î²`.\n\nThis is also available as a coercion `Equiv.coeEmbedding`.\nThe explicit `Equiv.toEmbedding` version is preferred though, since the coercion can have issues\ninferring the type of the resulting embedding. For example:\n\n```lean\n-- Works:\nexample (s : Finset (Fin 3)) (f : Equiv.Perm (Fin 3)) : s.map f.toEmbedding = s.map f := by simp\n-- Error, `f` has type `Fin 3 â‰ƒ Fin 3` but is expected to have type `Fin 3 â†ª ?m_1 : Type ?`\nexample (s : Finset (Fin 3)) (f : Equiv.Perm (Fin 3)) : s.map f = s.map f.toEmbedding := by simp\n```\n",
    "depth": 5}],
  "count": 386},
 {"noDocExamples": [],
  "kind": "Â«termâ…_,_â†Â»",
  "examples":
  [{"type": "âˆ€ {L : Type v} [self : LieRing L] (x : L), â…x, xâ† = 0",
    "name": "LieRing.lie_self",
    "isProp": true,
    "doc": "A Lie ring bracket vanishes on the diagonal in L Ã— L. ",
    "depth": 12},
   {"type":
    "âˆ€ {L : Type v} [self : LieRing L] (x y z : L), â…x, â…y, zâ†â† = â…â…x, yâ†, zâ† + â…y, â…x, zâ†â†",
    "name": "LieRing.leibniz_lie",
    "isProp": true,
    "doc": "A Lie ring bracket satisfies a Leibniz / Jacobi identity. ",
    "depth": 17},
   {"type":
    "âˆ€ {Î· : Type u_4} [inst : Finite Î·] {Gs : Î· â†’ Type u_5} [inst : (i : Î·) â†’ Group (Gs i)]\n  (H K : (i : Î·) â†’ Subgroup (Gs i)),\n  â…Subgroup.pi Set.univ H, Subgroup.pi Set.univ Kâ† = Subgroup.pi Set.univ fun i => â…H i, K iâ†",
    "name": "Subgroup.commutator_pi_pi_of_finite",
    "isProp": true,
    "doc":
    "The commutator of a finite direct product is contained in the direct product of the commutators.\n",
    "depth": 18}],
  "count": 378},
 {"noDocExamples": [],
  "kind": "Quotient.Â«termâŸ¦_âŸ§Â»",
  "examples":
  [{"type":
    "âˆ€ {Î± : Sort u} {s : Setoid Î±} {motive : Quotient s â†’ Prop}, (âˆ€ (a : Î±), motive âŸ¦aâŸ§) â†’ âˆ€ (q : Quotient s), motive q",
    "name": "Quotient.ind",
    "isProp": true,
    "doc":
    "The analogue of `Quot.ind`: every element of `Quotient s` is of the form `Quotient.mk s a`. ",
    "depth": 9},
   {"type": "âˆ€ {Î± : Sort u} {s : Setoid Î±} {a b : Î±}, a â‰ˆ b â†’ âŸ¦aâŸ§ = âŸ¦bâŸ§",
    "name": "Quotient.sound",
    "isProp": true,
    "doc":
    "The analogue of `Quot.sound`: If `a` and `b` are related by the equivalence relation,\nthen they have equal equivalence classes.\n",
    "depth": 10},
   {"type":
    "âˆ€ {Î± : Sort u} {s : Setoid Î±} {motive : Quotient s â†’ Prop} (q : Quotient s), (âˆ€ (a : Î±), motive âŸ¦aâŸ§) â†’ motive q",
    "name": "Quotient.inductionOn",
    "isProp": true,
    "doc":
    "The analogue of `Quot.inductionOn`: every element of `Quotient s` is of the form `Quotient.mk s a`. ",
    "depth": 10}],
  "count": 373},
 {"noDocExamples": [],
  "kind": "Â«term_-áµ¥_Â»",
  "examples":
  [{"type":
    "âˆ€ {G : Type u_1} [inst : AddGroup G] (g1 g2 : G), g1 -áµ¥ g2 = g1 - g2",
    "name": "vsub_eq_sub",
    "isProp": true,
    "doc":
    "Simplify subtraction for a torsor for an `AddGroup G` over\nitself. ",
    "depth": 13},
   {"type":
    "âˆ€ {G : Type u_1} {P : Type u_2} [inst : AddGroup G] [T : AddTorsor G P] (p : P), Function.Injective fun x => p -áµ¥ x",
    "name": "vsub_right_injective",
    "isProp": true,
    "doc": "Subtracting a point from the point `p` is an injective\nfunction. ",
    "depth": 14},
   {"type":
    "âˆ€ {G : Type u_1} {P : Type u_2} [inst : AddGroup G] [T : AddTorsor G P] (p : P), p -áµ¥ p = 0",
    "name": "vsub_self",
    "isProp": true,
    "doc": "Subtracting a point from itself produces 0. ",
    "depth": 14}],
  "count": 366},
 {"noDocExamples": [],
  "kind": "LinearMap.compNotation",
  "examples":
  [{"type":
    "âˆ€ {R : Type u} [inst : Semiring R] {P : Type v} [inst_1 : AddCommMonoid P] [inst_2 : Module R P],\n  (âˆ€ (f : (P â†’â‚€ R) â†’â‚—[R] P), Function.Surjective â‡‘f â†’ âˆƒ h, f âˆ˜â‚— h = LinearMap.id) â†’ Module.Projective R P",
    "name": "Module.Projective.of_lifting_property''",
    "isProp": true,
    "doc":
    "A module which satisfies the universal property is projective: If all surjections of\n`R`-modules `(P â†’â‚€ R) â†’â‚—[R] P` have `R`-linear left inverse maps, then `P` is\nprojective. ",
    "depth": 33},
   {"type":
    "âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] {f g : V â†’â‚—[K] V}, f âˆ˜â‚— g = LinearMap.id â†” g âˆ˜â‚— f = LinearMap.id",
    "name": "LinearMap.comp_eq_id_comm",
    "isProp": true,
    "doc":
    "In a finite-dimensional space, linear maps are inverse to each other on one side if and only if\nthey are inverse to each other on the other side. ",
    "depth": 33},
   {"type":
    "âˆ€ {R : Type u} {A : Type v} [inst : CommSemiring R] [inst_1 : AddCommMonoid A] [inst_2 : Module R A]\n  [self : Coalgebra R A], LinearMap.rTensor A Coalgebra.counit âˆ˜â‚— Coalgebra.comul = (TensorProduct.mk R R A) 1",
    "name": "Coalgebra.rTensor_counit_comp_comul",
    "isProp": true,
    "doc": "The counit satisfies the left counitality law ",
    "depth": 34}],
  "count": 338},
 {"noDocExamples": [],
  "kind": "Lean.Parser.Term.match",
  "examples":
  [{"type":
    "âˆ€ {Î± : Type u_2} [inst : Preorder Î±] {a : Thunk Î±} {Îµ : Type u_1} [self : Estimator a Îµ] (e : Îµ),\n  match EstimatorData.improve a e with\n  | none => EstimatorData.bound a e = Thunk.get a\n  | some e' => EstimatorData.bound a e < EstimatorData.bound a e'",
    "name": "Estimator.improve_spec",
    "isProp": true,
    "doc":
    "Calling `improve` either gives a strictly better bound,\nor a proof that the current bound is exact. ",
    "depth": 18},
   {"type":
    "âˆ€ {Î± Î² Î´ : Type} [inst : CanonicallyLinearOrderedAddCommMonoid Î´] {C : Levenshtein.Cost Î± Î² Î´} {xs : List Î±}\n  {ys : List Î²} (self : LevenshteinEstimator' C xs ys),\n  self.bound =\n    match self.pre_rev, (_ : List.reverse self.pre_rev ++ self.suff = ys) with\n    | [], split => ((â†‘self.distances)[0], List.length ys)\n    | x, split => (List.minimum_of_length_pos (_ : 0 < List.length â†‘self.distances), List.length self.suff)",
    "name": "LevenshteinEstimator'.bound_eq",
    "isProp": true,
    "doc": "Predicate describing the current bound. ",
    "depth": 27},
   {"type":
    "{C : Type u_1} â†’\n  [inst : CategoryTheory.Category.{u_2, u_1} C] â†’\n    {B X : C} â†’\n      (f : X âŸ¶ B) â†’\n        [inst_1 : CategoryTheory.EffectiveEpi f] â†’\n          CategoryTheory.EffectiveEpiFamilyStruct (fun x => X) fun x =>\n            match x with\n            | PUnit.unit => f",
    "name": "CategoryTheory.effectiveEpiFamilyStructSingletonOfEffectiveEpi",
    "isProp": false,
    "doc": "An `EffectiveEpiFamily` consisting of a single `EffectiveEpi`\n",
    "depth": 18}],
  "count": 308},
 {"noDocExamples": [],
  "kind": "Â«term_â†’â‚™*_Â»",
  "examples":
  [{"type": "{Î± : Type u} â†’ [inst : Mul Î±] â†’ Î± â†’â‚™* WithOne Î±",
    "name": "WithOne.coeMulHom",
    "isProp": false,
    "doc": "`WithOne.coe` as a bundled morphism ",
    "depth": 6},
   {"type":
    "{M : Type u_3} â†’ {N : Type u_4} â†’ [inst : Mul M] â†’ [inst_1 : CommSemigroup N] â†’ Mul (M â†’â‚™* N)",
    "name": "MulHom.instMulMulHomToMulToCommMagma",
    "isProp": false,
    "doc":
    "Given two mul morphisms `f`, `g` to a commutative semigroup, `f * g` is the mul morphism\nsending `x` to `f x * g x`. ",
    "depth": 9},
   {"type":
    "{M : Type u_12} â†’ {N : Type u_13} â†’ [inst : Mul M] â†’ [inst_1 : Mul N] â†’ M â‰ƒ* N â†’ M â†’â‚™* N",
    "name": "MulEquiv.toMulHom",
    "isProp": false,
    "doc": "The `MulHom` underlying a `MulEquiv`. ",
    "depth": 9}],
  "count": 279},
 {"noDocExamples": [],
  "kind": "Asymptotics.Â«term_=O[_]_Â»",
  "examples":
  [{"type":
    "(fun Ï„ => jacobiTheta Ï„ - 1) =O[Filter.comap Complex.im Filter.atTop] fun Ï„ => Real.exp (-Real.pi * Ï„.im)",
    "name": "isBigO_at_im_infty_jacobiTheta_sub_one",
    "isProp": true,
    "doc":
    "The norm of `jacobiTheta Ï„ - 1` decays exponentially as `im Ï„ â†’ âˆ`. ",
    "depth": 9},
   {"type": "zetaKernelâ‚ =O[Filter.atTop] fun t => Real.exp (-Real.pi * t)",
    "name": "isBigO_atTop_zetaKernelâ‚",
    "isProp": true,
    "doc": "Bound for `zetaKernelâ‚` for large `t`. ",
    "depth": 9},
   {"type": "zetaKernelâ‚‚ =O[Filter.atTop] fun t => Real.exp (-Real.pi * t)",
    "name": "isBigO_atTop_zetaKernelâ‚‚",
    "isProp": true,
    "doc": "Bound for `zetaKernelâ‚‚` for large `t`. ",
    "depth": 9}],
  "count": 278},
 {"noDocExamples": [],
  "kind": "termDepIfThenElse",
  "examples":
  [{"type":
    "âˆ€ {P : Prop} {Î± : Sort u_1} {a b : Î±} [inst : Decidable P], (if x : P then a else b) = if P then a else b",
    "name": "dite_eq_ite",
    "isProp": true,
    "doc":
    "A `dite` whose results do not actually depend on the condition may be reduced to an `ite`. ",
    "depth": 12},
   {"type":
    "âˆ€ {Î± : Sort u_1} {Î² : Sort u_2} (f : Î± â†’ Î²) (P : Prop) [inst : Decidable P] (x : P â†’ Î±) (y : Â¬P â†’ Î±),\n  f (dite P x y) = if h : P then f (x h) else f (y h)",
    "name": "apply_dite",
    "isProp": true,
    "doc":
    "A function applied to a `dite` is a `dite` of that function applied to each of the branches. ",
    "depth": 15},
   {"type":
    "âˆ€ {Î± : Sort u_2} {Ïƒ : Î± â†’ Sort u_1} (P : Prop) [inst : Decidable P] (f : P â†’ (a : Î±) â†’ Ïƒ a) (g : Â¬P â†’ (a : Î±) â†’ Ïƒ a)\n  (a : Î±), dite P f g a = if h : P then f h a else g h a",
    "name": "dite_apply",
    "isProp": true,
    "doc":
    "A 'dite' producing a `Pi` type `Î  a, Ïƒ a`, applied to a value `a : Î±` is a `dite` that applies\neither branch to `a`. ",
    "depth": 17}],
  "count": 275},
 {"noDocExamples": [],
  "kind": "Finsupp.funâ‚€",
  "examples":
  [{"type": "âˆ€ {p : â„•}, Nat.Prime p â†’ Nat.factorization p = funâ‚€ | p => 1",
    "name": "Nat.Prime.factorization",
    "isProp": true,
    "doc":
    "The only prime factor of prime `p` is `p` itself, with multiplicity `1` ",
    "depth": 8},
   {"type":
    "âˆ€ {p k : â„•}, Nat.Prime p â†’ Nat.factorization (p ^ k) = funâ‚€ | p => k",
    "name": "Nat.Prime.factorization_pow",
    "isProp": true,
    "doc":
    "For prime `p` the only prime factor of `p^k` is `p` with multiplicity `k` ",
    "depth": 12},
   {"type":
    "âˆ€ {n p k : â„•}, n â‰  0 â†’ (Nat.factorization n = funâ‚€ | p => k) â†’ n = p ^ k",
    "name": "Nat.eq_pow_of_factorization_eq_single",
    "isProp": true,
    "doc":
    "If the factorization of `n` contains just one number `p` then `n` is a power of `p` ",
    "depth": 12}],
  "count": 264},
 {"noDocExamples": [],
  "kind": "Asymptotics.Â«term_=o[_]_Â»",
  "examples":
  [{"type": "âˆ€ (s : â„), (fun x => x ^ s) =o[Filter.atTop] Real.exp",
    "name": "isLittleO_rpow_exp_atTop",
    "isProp": true,
    "doc": "`x ^ s = o(exp x)` as `x â†’ âˆ` for any real `s`. ",
    "depth": 10},
   {"type":
    "âˆ€ {R : Type u_4} [inst : NormedRing R] {r : â„}, 1 < r â†’ Nat.cast =o[Filter.atTop] fun n => r ^ n",
    "name": "isLittleO_coe_const_pow_of_one_lt",
    "isProp": true,
    "doc": "For a real `r > 1` we have `n = o(r ^ n)` as `n â†’ âˆ`. ",
    "depth": 12},
   {"type":
    "âˆ€ (k : â„•) {b : â„}, 0 < b â†’ (fun x => x ^ k) =o[Filter.atTop] fun x => Real.exp (b * x)",
    "name": "isLittleO_pow_exp_pos_mul_atTop",
    "isProp": true,
    "doc":
    "`x ^ k = o(exp(b * x))` as `x â†’ âˆ` for any natural `k` and positive `b`. ",
    "depth": 12}],
  "count": 247},
 {"noDocExamples": [],
  "kind": "TensorProduct.Â«term_âŠ—â‚œ[_]_Â»",
  "examples":
  [{"type":
    "âˆ€ (R : Type u) (S : Type v) [inst : CommRing R] [inst_1 : CommRing S] [inst_2 : Algebra R S],\n  Submodule.span S (Set.range fun s => 1 âŠ—â‚œ[R] s - s âŠ—â‚œ[R] 1) =\n    Submodule.restrictScalars S (KaehlerDifferential.ideal R S)",
    "name": "KaehlerDifferential.submodule_span_range_eq_ideal",
    "isProp": true,
    "doc":
    "The kernel of `S âŠ—[R] S â†’â‚[R] S` is generated by `1 âŠ— s - s âŠ— 1` as a `S`-module. ",
    "depth": 27},
   {"type":
    "âˆ€ (R : Type u_1) [inst : CommSemiring R] (M : Type u_4) (N : Type u_5) [inst_1 : AddCommMonoid M]\n  [inst_2 : AddCommMonoid N] [inst_3 : Module R M] [inst_4 : Module R N],\n  Submodule.span R {t | âˆƒ m n, m âŠ—â‚œ[R] n = t} = âŠ¤",
    "name": "TensorProduct.span_tmul_eq_top",
    "isProp": true,
    "doc": "The simple (aka pure) elements span the tensor product. ",
    "depth": 29},
   {"type":
    "âˆ€ {R : Type u_1} [inst : CommSemiring R] {R' : Type u_2} [inst_1 : Monoid R'] {M : Type u_4} {N : Type u_5}\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid N] [inst_4 : Module R M] [inst_5 : Module R N]\n  [inst_6 : DistribMulAction R' M] [inst_7 : DistribMulAction R' N] [inst_8 : TensorProduct.CompatibleSMul R R' M N]\n  (r : R') (m : M) (n : N), (r â€¢ m) âŠ—â‚œ[R] n = m âŠ—â‚œ[R] (r â€¢ n)",
    "name": "TensorProduct.smul_tmul",
    "isProp": true,
    "doc": "`smul` can be moved from one side of the product to the other .",
    "depth": 31}],
  "count": 239},
 {"noDocExamples": [],
  "kind": "Function.term_On_",
  "examples":
  [{"type":
    "âˆ€ {Î± : Type u_1} {Î¹ : Type u_4} {f : Î¹ â†’ Î±}, Function.Injective f â†’ Pairwise ((fun x x_1 => x â‰  x_1) on f)",
    "name": "Function.Injective.pairwise_ne",
    "isProp": true,
    "doc":
    "**Alias** of the forward direction of `Function.injective_iff_pairwise_ne`.",
    "depth": 12},
   {"type":
    "âˆ€ {Î± : Type u_2} (self : MeasurableSpace.DynkinSystem Î±) {f : â„• â†’ Set Î±},\n  Pairwise (Disjoint on f) â†’\n    (âˆ€ (i : â„•), MeasurableSpace.DynkinSystem.Has self (f i)) â†’ MeasurableSpace.DynkinSystem.Has self (â‹ƒ i, f i)",
    "name": "MeasurableSpace.DynkinSystem.has_iUnion_nat",
    "isProp": true,
    "doc":
    "A Dynkin system is closed under countable union of pairwise disjoint sets. Use a more general\n`MeasurableSpace.DynkinSystem.has_iUnion` instead.",
    "depth": 15},
   {"type":
    "âˆ€ {Î± : Type u} {Î² : Type v} {f : Î² â†’ Set Î±},\n  Pairwise (Disjoint on f) â†’\n    âˆ€ {s : Set Î±}, (âˆ€ (t : Î²), f t âŠ† s) â†’ Set.Countable s â†’ Set.Countable {t | Set.Nonempty (f t)}",
    "name": "Set.countable_setOf_nonempty_of_disjoint",
    "isProp": true,
    "doc":
    "If a family of disjoint sets is included in a countable set, then only countably many of\nthem are nonempty. ",
    "depth": 15}],
  "count": 238},
 {"noDocExamples": [],
  "kind": "MeasureTheory.Â«termâˆ«_In_,_âˆ‚_Â»",
  "examples":
  [{"type":
    "âˆ€ {Î± : Type u_1} {m0 : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {f : Î± â†’ â„},\n  MeasureTheory.StronglyMeasurable f â†’\n    MeasureTheory.Integrable f â†’\n      (âˆ€ (s : Set Î±), MeasurableSet s â†’ â†‘â†‘Î¼ s < âŠ¤ â†’ 0 â‰¤ âˆ« (x : Î±) in s, f x âˆ‚Î¼) â†’ 0 â‰¤á¶ [MeasureTheory.Measure.ae Î¼] f",
    "name":
    "MeasureTheory.ae_nonneg_of_forall_set_integral_nonneg_of_stronglyMeasurable",
    "isProp": true,
    "doc":
    "Don't use this lemma. Use `ae_nonneg_of_forall_set_integral_nonneg`. ",
    "depth": 20},
   {"type":
    "âˆ€ {Î± : Type u_1} {E : Type u_3} [inst : MeasurableSpace Î±] [inst_1 : NormedAddCommGroup E] {f : Î± â†’ E} {s : Set Î±}\n  {Î¼ : MeasureTheory.Measure Î±} [inst_2 : NormedSpace â„ E],\n  f =á¶ [MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict Î¼ sá¶œ)] 0 â†’ âˆ« (Ï‰ : Î±) in s, f Ï‰ âˆ‚Î¼ = âˆ« (Ï‰ : Î±), f Ï‰ âˆ‚Î¼",
    "name": "MeasureTheory.set_integral_eq_integral_of_ae_restrict_eq_zero",
    "isProp": true,
    "doc":
    "If a function equals zero almost everywhere w.r.t. restriction of the measure to `sá¶œ`, then its\nintegral on `s` coincides with its integral on the whole space. ",
    "depth": 21},
   {"type":
    "âˆ€ {Î± : Type u_1} {E : Type u_3} [inst : MeasurableSpace Î±] [inst_1 : NormedAddCommGroup E] {f : Î± â†’ E} {s : Set Î±}\n  {Î¼ : MeasureTheory.Measure Î±} [inst_2 : NormedSpace â„ E],\n  (âˆ€ x âˆ‰ s, f x = 0) â†’ âˆ« (x : Î±) in s, f x âˆ‚Î¼ = âˆ« (x : Î±), f x âˆ‚Î¼",
    "name": "MeasureTheory.set_integral_eq_integral_of_forall_compl_eq_zero",
    "isProp": true,
    "doc":
    "If a function vanishes on `sá¶œ`, then its integral on `s` coincides with its integral on the\nwhole space. ",
    "depth": 21}],
  "count": 235},
 {"noDocExamples": [],
  "kind": "Â«term_<$>_Â»",
  "examples":
  [{"type":
    "âˆ€ (P : PFunctor.{u}) {Î± Î² : Type v} (f : Î± â†’ Î²) (x : â†‘P Î±), f <$> x = PFunctor.map P f x",
    "name": "PFunctor.map_eq_map",
    "isProp": true,
    "doc":
    "We prefer `PFunctor.map` to `Functor.map` because it is universe-polymorphic. ",
    "depth": 14},
   {"type":
    "âˆ€ {Î± Î² Î³ : Type u} (f : Î± â†’ Î² â†’ Î³) (a : Option Î±) (b : Option Î²), Option.mapâ‚‚ f a b = Seq.seq (f <$> a) fun x => b",
    "name": "Option.mapâ‚‚_def",
    "isProp": true,
    "doc":
    "`Option.mapâ‚‚` in terms of monadic operations. Note that this can't be taken as the definition\nbecause of the lack of universe polymorphism. ",
    "depth": 15},
   {"type":
    "âˆ€ {Î± Î² Î³ : Type u} (f : Î± â†’ Î² â†’ Î³) (s : Set Î±) (t : Set Î²), Set.image2 f s t = Seq.seq (f <$> s) fun x => t",
    "name": "Set.image2_def",
    "isProp": true,
    "doc":
    "`Set.image2` in terms of monadic operations. Note that this can't be taken as the definition\nbecause of the lack of universe polymorphism. ",
    "depth": 15}],
  "count": 232},
 {"noDocExamples": [],
  "kind": "Â«term_â‰¥_Â»",
  "examples":
  [{"type":
    "âˆ€ {Î¼ : YoungDiagram},\n  YoungDiagram.ofRowLens (YoungDiagram.rowLens Î¼) (_ : List.Sorted (fun x x_1 => x â‰¥ x_1) (YoungDiagram.rowLens Î¼)) = Î¼",
    "name": "YoungDiagram.ofRowLens_to_rowLens_eq_self",
    "isProp": true,
    "doc": "The left_inv direction of the equivalence ",
    "depth": 6},
   {"type":
    "âˆ€ {w : List â„•} {hw : List.Sorted (fun x x_1 => x â‰¥ x_1) w} (i : Fin (List.length w)),\n  YoungDiagram.rowLen (YoungDiagram.ofRowLens w hw) â†‘i = List.get w i",
    "name": "YoungDiagram.rowLen_ofRowLens",
    "isProp": true,
    "doc":
    "The length of the `i`th row in `ofRowLens w hw` is the `i`th entry of `w` ",
    "depth": 10},
   {"type":
    "âˆ€ {w : List â„•} {hw : List.Sorted (fun x x_1 => x â‰¥ x_1) w},\n  (âˆ€ x âˆˆ w, 0 < x) â†’ YoungDiagram.rowLens (YoungDiagram.ofRowLens w hw) = w",
    "name": "YoungDiagram.rowLens_ofRowLens_eq_self",
    "isProp": true,
    "doc": "The right_inv direction of the equivalence ",
    "depth": 10}],
  "count": 230},
 {"noDocExamples": [],
  "kind": "Â«term_â†’áµƒ[_]_Â»",
  "examples":
  [{"type":
    "âˆ€ {k : Type u_1} {V1 : Type u_2} {P1 : Type u_3} {V2 : Type u_4} {P2 : Type u_5} [inst : Ring k]\n  [inst_1 : AddCommGroup V1] [inst_2 : Module k V1] [inst_3 : AddTorsor V1 P1] [inst_4 : AddCommGroup V2]\n  [inst_5 : Module k V2] [inst_6 : AddTorsor V2 P2] {f g : P1 â†’áµƒ[k] P2}, (âˆ€ (p : P1), f p = g p) â†’ f = g",
    "name": "AffineMap.ext",
    "isProp": true,
    "doc": "Two affine maps are equal if they coerce to the same function. ",
    "depth": 36},
   {"type":
    "âˆ€ {ğ•œ : Type u_1} {V : Type u_2} {Vâ‚‚ : Type u_4} {P : Type u_8} {Pâ‚‚ : Type u_9} [inst : NormedField ğ•œ]\n  [inst_1 : SeminormedAddCommGroup V] [inst_2 : SeminormedAddCommGroup Vâ‚‚] [inst_3 : NormedSpace ğ•œ V]\n  [inst_4 : NormedSpace ğ•œ Vâ‚‚] [inst_5 : PseudoMetricSpace P] [inst_6 : PseudoMetricSpace Pâ‚‚]\n  [inst_7 : NormedAddTorsor V P] [inst_8 : NormedAddTorsor Vâ‚‚ Pâ‚‚] {f : P â†’áµƒ[ğ•œ] Pâ‚‚}, IsOpenMap â‡‘f.linear â†” IsOpenMap â‡‘f",
    "name": "AffineMap.isOpenMap_linear_iff",
    "isProp": true,
    "doc":
    "If `f` is an affine map, then its linear part is an open map iff `f` is an open map. ",
    "depth": 37},
   {"type":
    "{k : Type u_1} â†’\n  {Vâ‚ : Type u_2} â†’\n    {Vâ‚‚ : Type u_3} â†’\n      [inst : Ring k] â†’\n        [inst_1 : AddCommGroup Vâ‚] â†’\n          [inst_2 : Module k Vâ‚] â†’ [inst_3 : AddCommGroup Vâ‚‚] â†’ [inst_4 : Module k Vâ‚‚] â†’ (Vâ‚ â†’â‚—[k] Vâ‚‚) â†’ Vâ‚ â†’áµƒ[k] Vâ‚‚",
    "name": "LinearMap.toAffineMap",
    "isProp": false,
    "doc": "Reinterpret a linear map as an affine map. ",
    "depth": 21}],
  "count": 219},
 {"noDocExamples": [],
  "kind": "Â«term_[Î›^_]â†’â‚—[_]_Â»",
  "examples":
  [{"type":
    "{R : Type u_1} â†’\n  {M : Type u_2} â†’\n    {N : Type u_3} â†’\n      {Î¹ : Type u_4} â†’\n        [inst : Semiring R] â†’\n          [inst_1 : AddCommMonoid M] â†’\n            [inst_2 : Module R M] â†’\n              [inst_3 : TopologicalSpace M] â†’\n                [inst_4 : AddCommMonoid N] â†’\n                  [inst_5 : Module R N] â†’ [inst_6 : TopologicalSpace N] â†’ M[Î›^Î¹]â†’L[R]N â†’ M [Î›^Î¹]â†’â‚—[R] N",
    "name": "ContinuousAlternatingMap.toAlternatingMap",
    "isProp": false,
    "doc": "Projection to `AlternatingMap`s. ",
    "depth": 23},
   {"type":
    "{R : Type u_1} â†’\n  [inst : Semiring R] â†’\n    {M : Type u_2} â†’\n      [inst_1 : AddCommMonoid M] â†’\n        [inst_2 : Module R M] â†’\n          {N : Type u_3} â†’\n            [inst_3 : AddCommMonoid N] â†’\n              [inst_4 : Module R N] â†’\n                {Î¹ : Type u_7} â†’\n                  {S : Type u_10} â†’\n                    [inst_5 : Semiring S] â†’\n                      [inst_6 : Module S N] â†’ [inst_7 : SMulCommClass R S N] â†’ Module S (M [Î›^Î¹]â†’â‚—[R] N)",
    "name": "AlternatingMap.module",
    "isProp": false,
    "doc":
    "The space of multilinear maps over an algebra over `R` is a module over `R`, for the pointwise\naddition and scalar multiplication. ",
    "depth": 25},
   {"type":
    "âˆ€ {R : Type u_1} [inst : Semiring R] {M : Type u_2} [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {N : Type u_3}\n  [inst_3 : AddCommMonoid N] [inst_4 : Module R N] {Î¹ : Type u_7} {Mâ‚‚ : Type u_10} [inst_5 : AddCommMonoid Mâ‚‚]\n  [inst_6 : Module R Mâ‚‚] (f : M [Î›^Î¹]â†’â‚—[R] N) (g : Mâ‚‚ â‰ƒâ‚—[R] M), AlternatingMap.compLinearMap f â†‘g = 0 â†” f = 0",
    "name": "AlternatingMap.compLinearEquiv_eq_zero_iff",
    "isProp": true,
    "doc":
    "Composing an alternating map with the same linear equiv on each argument gives the zero map\nif and only if the alternating map is the zero map. ",
    "depth": 34}],
  "count": 218},
 {"noDocExamples": [],
  "kind": "Â«term_â†’._Â»",
  "examples":
  [{"type": "{Î± : Type u_1} â†’ {Î² : Type u_2} â†’ (Î± â†’. Î²) â†’ Set Î² â†’ Set Î±",
    "name": "PFun.preimage",
    "isProp": false,
    "doc": "Preimage of a set under a partial function. ",
    "depth": 5},
   {"type": "{Î± : Type u_1} â†’ {Î² : Type u_2} â†’ (Î± â†’. Î² âŠ• Î±) â†’ Î± â†’. Î²",
    "name": "PFun.fix",
    "isProp": false,
    "doc":
    "First return map. Transforms a partial function `f : Î± â†’. Î² âŠ• Î±` into the partial function\n`Î± â†’. Î²` which sends `a : Î±` to the first value in `Î²` it hits by iterating `f`, if such a value\nexists. By abusing notation to illustrate, either `f a` is in the `Î²` part of `Î² âŠ• Î±` (in which\ncase `f.fix a` returns `f a`), or it is undefined (in which case `f.fix a` is undefined as well), or\nit is in the `Î±` part of `Î² âŠ• Î±` (in which case we repeat the procedure, so `f.fix a` will return\n`f.fix (f a)`). ",
    "depth": 6},
   {"type":
    "{Î± : Type u_1} â†’ {Î² : Type u_2} â†’ [inst : TopologicalSpace Î±] â†’ [inst : TopologicalSpace Î²] â†’ (Î± â†’. Î²) â†’ Prop",
    "name": "PContinuous",
    "isProp": false,
    "doc": "Continuity of a partial function ",
    "depth": 7}],
  "count": 209},
 {"noDocExamples": [],
  "kind": "Â«termâˆ«_In_.._,_Â»",
  "examples":
  [{"type":
    "âˆ€ (n : â„•), âˆ« (x : â„) in 0 ..Real.pi / 2, Real.cos x ^ n = 1 / 2 * âˆ« (x : â„) in 0 ..Real.pi, Real.sin x ^ n",
    "name": "EulerSine.integral_cos_pow_eq",
    "isProp": true,
    "doc":
    "Relate the integral `cos x ^ n` over `[0, Ï€/2]` to the integral of `sin x ^ n` over `[0, Ï€]`,\nwhich is studied in `Data.Real.Pi.Wallis` and other places. ",
    "depth": 14},
   {"type":
    "âˆ€ {a b : â„}, âˆ« (x : â„) in a..b, Real.sin x * Real.cos x = (Real.cos a ^ 2 - Real.cos b ^ 2) / 2",
    "name": "integral_sin_mul_cosâ‚‚",
    "isProp": true,
    "doc":
    "The integral of `sin x * cos x`, given in terms of cosÂ².\nSee `integral_sin_mul_cosâ‚` above for the integral given in terms of sinÂ². ",
    "depth": 15},
   {"type":
    "âˆ€ {a b : â„}, âˆ« (x : â„) in a..b, Real.sin x * Real.cos x = (Real.sin b ^ 2 - Real.sin a ^ 2) / 2",
    "name": "integral_sin_mul_cosâ‚",
    "isProp": true,
    "doc":
    "The integral of `sin x * cos x`, given in terms of sinÂ².\nSee `integral_sin_mul_cosâ‚‚` below for the integral given in terms of cosÂ². ",
    "depth": 15}],
  "count": 207},
 {"noDocExamples": [],
  "kind": "Filter.Â«term_â‰¤á¶ [_]_Â»",
  "examples":
  [{"type":
    "âˆ€ {Î± : Type u_2} {_m0 : MeasurableSpace Î±} â¦ƒs s' : Set Î±â¦„ â¦ƒÎ¼ Î½ : MeasureTheory.Measure Î±â¦„,\n  s â‰¤á¶ [MeasureTheory.Measure.ae Î¼] s' â†’ Î¼ â‰¤ Î½ â†’ MeasureTheory.Measure.restrict Î¼ s â‰¤ MeasureTheory.Measure.restrict Î½ s'",
    "name": "MeasureTheory.Measure.restrict_mono'",
    "isProp": true,
    "doc":
    "Restriction of a measure to a subset is monotone both in set and in measure. ",
    "depth": 16},
   {"type":
    "âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {f : MeasureTheory.SimpleFunc Î± â„},\n  MeasureTheory.Integrable â†‘f â†’\n    0 â‰¤á¶ [MeasureTheory.Measure.ae Î¼] â†‘f â†’\n      MeasureTheory.SimpleFunc.integral Î¼ f = ENNReal.toReal (âˆ«â» (a : Î±), ENNReal.ofReal (â†‘f a) âˆ‚Î¼)",
    "name": "MeasureTheory.SimpleFunc.integral_eq_lintegral",
    "isProp": true,
    "doc":
    "`SimpleFunc.bintegral` and `SimpleFunc.integral` agree when the integrand has type\n`Î± â†’â‚› â„â‰¥0âˆ`. But since `â„â‰¥0âˆ` is not a `NormedSpace`, we need some form of coercion. ",
    "depth": 16},
   {"type":
    "âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] {Î¼ : MeasureTheory.Measure Î±} {s t : Set Î±},\n  s â‰¤á¶ [MeasureTheory.Measure.ae Î¼] t â†’ â†‘â†‘Î¼ s â‰¤ â†‘â†‘Î¼ t",
    "name": "MeasureTheory.measure_mono_ae",
    "isProp": true,
    "doc": "If `s âŠ† t` modulo a set of measure `0`, then `Î¼ s â‰¤ Î¼ t`. ",
    "depth": 16}],
  "count": 205},
 {"noDocExamples": [],
  "kind": "Â«term_â†’â‚—.[_]_Â»",
  "examples":
  [{"type":
    "{ğ•œ : Type u_1} â†’\n  {E : Type u_2} â†’\n    {F : Type u_3} â†’\n      [inst : IsROrC ğ•œ] â†’\n        [inst_1 : NormedAddCommGroup E] â†’\n          [inst_2 : InnerProductSpace ğ•œ E] â†’\n            [inst_3 : NormedAddCommGroup F] â†’ [inst_4 : InnerProductSpace ğ•œ F] â†’ (E â†’â‚—.[ğ•œ] F) â†’ (F â†’â‚—.[ğ•œ] E) â†’ Prop",
    "name": "LinearPMap.IsFormalAdjoint",
    "isProp": false,
    "doc":
    "An operator `T` is a formal adjoint of `S` if for all `x` in the domain of `T` and `y` in the\ndomain of `S`, we have that `âŸªT x, yâŸ« = âŸªx, S yâŸ«`. ",
    "depth": 23},
   {"type":
    "âˆ€ {R : Type u_1} [inst : Ring R] {E : Type u_2} [inst_1 : AddCommGroup E] [inst_2 : Module R E] {F : Type u_3}\n  [inst_3 : AddCommGroup F] [inst_4 : Module R F] (f : E â†’â‚—.[R] F),\n  LinearPMap.graph (-f) = Submodule.map (LinearMap.prodMap LinearMap.id (-LinearMap.id)) (LinearPMap.graph f)",
    "name": "LinearPMap.neg_graph",
    "isProp": true,
    "doc": "The graph of `-f` as a pushforward. ",
    "depth": 28},
   {"type":
    "âˆ€ {R : Type u_1} [inst : Ring R] {E : Type u_2} [inst_1 : AddCommGroup E] [inst_2 : Module R E] {F : Type u_3}\n  [inst_3 : AddCommGroup F] [inst_4 : Module R F] (f : E â†’â‚—.[R] F) (x : â†¥f.domain), (â†‘x, â†‘f x) âˆˆ LinearPMap.graph f",
    "name": "LinearPMap.mem_graph",
    "isProp": true,
    "doc": "The tuple `(x, f x)` is contained in the graph of `f`. ",
    "depth": 28}],
  "count": 194},
 {"noDocExamples": [],
  "kind": "Â«term_âŠ‚_Â»",
  "examples":
  [{"type": "âˆ€ {Î± : Type u} {s : Set Î±}, Set.Nonempty s â†’ âˆ… âŠ‚ s",
    "name": "Set.Nonempty.empty_ssubset",
    "isProp": true,
    "doc": "**Alias** of the reverse direction of `Set.empty_ssubset`.",
    "depth": 8},
   {"type": "âˆ€ {Î± : Type u_1} {s : Finset Î±}, Finset.Nonempty s â†’ âˆ… âŠ‚ s",
    "name": "Finset.Nonempty.empty_ssubset",
    "isProp": true,
    "doc": "**Alias** of the reverse direction of `Finset.empty_ssubset`.",
    "depth": 8},
   {"type":
    "âˆ€ {Î± : Type u} [inst : HasSSubset Î±] [inst_1 : IsIrrefl Î± fun x x_1 => x âŠ‚ x_1] {a b : Î±}, a âŠ‚ b â†’ a â‰  b",
    "name": "HasSSubset.SSubset.ne",
    "isProp": true,
    "doc": "**Alias** of `ne_of_ssubset`.",
    "depth": 10}],
  "count": 193},
 {"noDocExamples": [],
  "kind": "MeasureTheory.Â«term_â†’â‚˜[_]_Â»",
  "examples":
  [{"type":
    "{Î± : Type u_1} â†’ [inst : MeasurableSpace Î±] â†’ {Î¼ : MeasureTheory.Measure Î±} â†’ (Î± â†’â‚˜[Î¼] ENNReal) â†’ ENNReal",
    "name": "MeasureTheory.AEEqFun.lintegral",
    "isProp": false,
    "doc": "For `f : Î± â†’ â„â‰¥0âˆ`, define `âˆ« [f]` to be `âˆ« f` ",
    "depth": 9},
   {"type":
    "{Î± : Type u_1} â†’\n  {Î² : Type u_2} â†’\n    [inst : MeasurableSpace Î±] â†’ {Î¼ : MeasureTheory.Measure Î±} â†’ [inst_1 : TopologicalSpace Î²] â†’ (Î± â†’â‚˜[Î¼] Î²) â†’ Î± â†’ Î²",
    "name": "MeasureTheory.AEEqFun.cast",
    "isProp": false,
    "doc":
    "Coercion from a space of equivalence classes of almost everywhere strongly measurable\nfunctions to functions. ",
    "depth": 11},
   {"type":
    "(Î± : Type u_1) â†’\n  {Î² : Type u_2} â†’\n    [inst : MeasurableSpace Î±] â†’ {Î¼ : MeasureTheory.Measure Î±} â†’ [inst_1 : TopologicalSpace Î²] â†’ Î² â†’ Î± â†’â‚˜[Î¼] Î²",
    "name": "MeasureTheory.AEEqFun.const",
    "isProp": false,
    "doc":
    "The equivalence class of a constant function: `[fun _ : Î± => b]`, based on the equivalence\nrelation of being almost everywhere equal ",
    "depth": 11}],
  "count": 193},
 {"noDocExamples": [],
  "kind": "Â«termâ…Ÿ_Â»",
  "examples":
  [{"type":
    "âˆ€ {Î± : Type u} [inst : Mul Î±] [inst_1 : One Î±] {a : Î±} [self : Invertible a], â…Ÿa * a = 1",
    "name": "Invertible.invOf_mul_self",
    "isProp": true,
    "doc": "`invOf a` is a left inverse of `a` ",
    "depth": 14},
   {"type":
    "âˆ€ {Î± : Type u} [inst : Monoid Î±] (a b : Î±) [inst_1 : Invertible a] [inst_2 : Invertible b], a = b â†’ â…Ÿa = â…Ÿb",
    "name": "Invertible.congr",
    "isProp": true,
    "doc": "If `a` is invertible and `a = b`, then `â…Ÿa = â…Ÿb`. ",
    "depth": 16},
   {"type":
    "âˆ€ {k : Type u} [inst : Field k] {G : GroupCat} [inst_1 : IsAlgClosed k] [inst_2 : Fintype â†‘G]\n  [inst_3 : Invertible â†‘(Fintype.card â†‘G)] (V W : FdRep k â†‘G) [inst_4 : CategoryTheory.Simple V]\n  [inst_5 : CategoryTheory.Simple W],\n  (â…Ÿâ†‘(Fintype.card â†‘G) â€¢ Finset.sum Finset.univ fun g => FdRep.character V g * FdRep.character W gâ»Â¹) =\n    if Nonempty (V â‰… W) then 1 else 0",
    "name": "FdRep.char_orthonormal",
    "isProp": true,
    "doc":
    "Orthogonality of characters for irreducible representations of finite group over an\nalgebraically closed field whose characteristic doesn't divide the order of the group. ",
    "depth": 26}],
  "count": 189},
 {"noDocExamples": [],
  "kind": "Â«term_â†’â‚—â…_â†_Â»",
  "examples":
  [{"type":
    "(R : Type u) â†’\n  (Î¹ : Type v) â†’\n    [inst : CommRing R] â†’\n      (L : Î¹ â†’ Type w) â†’\n        [inst_1 : (i : Î¹) â†’ LieRing (L i)] â†’\n          [inst_2 : (i : Î¹) â†’ LieAlgebra R (L i)] â†’\n            [inst_3 : DecidableEq Î¹] â†’ (j : Î¹) â†’ L j â†’â‚—â…Râ† DirectSum Î¹ fun i => L i",
    "name": "DirectSum.lieAlgebraOf",
    "isProp": false,
    "doc":
    "The inclusion of each component into the direct sum as morphism of Lie algebras. ",
    "depth": 22},
   {"type":
    "{R : Type u_1} â†’\n  {L : Type u_2} â†’\n    {L' : Type u_3} â†’\n      [inst : CommRing R] â†’\n        [inst_1 : LieRing L] â†’\n          [inst_2 : LieAlgebra R L] â†’\n            [inst_3 : LieRing L'] â†’\n              [inst_4 : LieAlgebra R L'] â†’ (f : L â†’â‚—â…Râ† L') â†’ (L â§¸ LieHom.ker f) â‰ƒâ‚—â…Râ† â†¥(LieHom.range f)",
    "name": "LieHom.quotKerEquivRange",
    "isProp": false,
    "doc": "The first isomorphism theorem for morphisms of Lie algebras. ",
    "depth": 28},
   {"type":
    "âˆ€ {R : Type u_1} {L : Type u_2} {L' : Type u_3} [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L]\n  [inst_3 : LieRing L'] [inst_4 : LieAlgebra R L'] (self : L â†’â‚—â…Râ† L') {x y : L},\n  AddHom.toFun self.toAddHom â…x, yâ† = â…AddHom.toFun self.toAddHom x, AddHom.toFun self.toAddHom yâ†",
    "name": "LieHom.map_lie'",
    "isProp": true,
    "doc": "A morphism of Lie algebras is compatible with brackets. ",
    "depth": 29}],
  "count": 188},
 {"noDocExamples": [],
  "kind": "Matrix.vecNotation",
  "examples":
  [{"type":
    "âˆ€ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {pâ‚ pâ‚‚ pâ‚ƒ : P}, AffineIndependent k ![pâ‚, pâ‚‚, pâ‚ƒ] â†” Â¬Collinear k {pâ‚, pâ‚‚, pâ‚ƒ}",
    "name": "affineIndependent_iff_not_collinear_set",
    "isProp": true,
    "doc":
    "Three points are affinely independent if and only if they are not collinear. ",
    "depth": 21},
   {"type":
    "âˆ€ {K : Type u_2} {V : Type u_3} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  (u v : Projectivization K V), Projectivization.Dependent ![u, v] â†” u = v",
    "name": "Projectivization.dependent_pair_iff_eq",
    "isProp": true,
    "doc":
    "Two points in a projective space are dependent if and only if they are equal. ",
    "depth": 22},
   {"type":
    "âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] {pâ‚ pâ‚‚ pâ‚ƒ : P},\n  EuclideanGeometry.Cospherical {pâ‚, pâ‚‚, pâ‚ƒ} â†’ pâ‚ â‰  pâ‚‚ â†’ pâ‚ â‰  pâ‚ƒ â†’ pâ‚‚ â‰  pâ‚ƒ â†’ AffineIndependent â„ ![pâ‚, pâ‚‚, pâ‚ƒ]",
    "name": "EuclideanGeometry.Cospherical.affineIndependent_of_ne",
    "isProp": true,
    "doc": "The three points of a cospherical set are affinely independent. ",
    "depth": 23}],
  "count": 187},
 {"noDocExamples": [],
  "kind": "Â«term_>_Â»",
  "examples":
  [{"type":
    "âˆ€ (b o : Ordinal.{u_1}), List.Sorted (fun x x_1 => x > x_1) (List.map Prod.fst (Ordinal.CNF b o))",
    "name": "Ordinal.CNF_sorted",
    "isProp": true,
    "doc": "The exponents of the Cantor normal form are decreasing. ",
    "depth": 12},
   {"type":
    "âˆ€ {Î± : Type u} [inst : LT Î±] [inst_1 : WellFoundedGT Î±] (a : Î±), Acc (fun x x_1 => x > x_1) a",
    "name": "WellFoundedGT.apply",
    "isProp": true,
    "doc": "All values are accessible under the well-founded `>`. ",
    "depth": 12},
   {"type": "âˆ€ {n : â„•}, n > 0 â†’ âˆ€ {i j : â„•}, i â‰¤ j â†’ n ^ i â‰¤ n ^ j",
    "name": "Nat.pow_le_pow_right",
    "isProp": true,
    "doc": "**Alias** of `Nat.pow_le_pow_of_le_right`.",
    "depth": 13}],
  "count": 187},
 {"noDocExamples": [],
  "kind": "Lean.Parser.Term.let",
  "examples":
  [{"type":
    "Lean.Expr â†’\n  Lean.MetaM\n    ((u : Lean.Level) Ã—\n      (Î± :\n        let u := u;\n        Q(Type u)) Ã—\n        Q(Â«$Î±Â»))",
    "name": "Qq.inferTypeQ'",
    "isProp": false,
    "doc":
    "Variant of `inferTypeQ` that yields a type in `Type u` rather than `Sort u`.\nThrows an error if the type is a `Prop` or if it's otherwise not possible to represent\nthe universe as `Type u` (for example due to universe level metavariables). ",
    "depth": 10},
   {"type":
    "{u : Lean.Level} â†’\n  â„• â†’\n    {Î± :\n        let u := u;\n        Q(Type u)} â†’\n      Q(Semiring Â«$Î±Â») â†’ Q(Â«$Î±Â») â†’ Q(Â«$Î±Â»)",
    "name": "Linarith.mulExpr'",
    "isProp": false,
    "doc": "A typesafe version of `mulExpr`. ",
    "depth": 11},
   {"type":
    "{Î± : Type u} â†’\n  {Î² : Type v} â†’\n    (R : Type u_1) â†’\n      [inst : Semiring R] â†’\n        (e : Î± â‰ƒ Î²) â†’\n          [inst_1 : AddCommMonoid Î²] â†’\n            let addCommMonoid := Equiv.addCommMonoid e;\n            [inst_2 : Module R Î²] â†’ Module R Î±",
    "name": "Equiv.module",
    "isProp": false,
    "doc": "Transfer `Module` across an `Equiv` ",
    "depth": 12}],
  "count": 184},
 {"noDocExamples": [],
  "kind": "Â«term_â‹–_Â»",
  "examples":
  [{"type": "âˆ€ {a b : â„•}, a â‹– b â†’ â†‘a â‹– â†‘b",
    "name": "Covby.cast_int",
    "isProp": true,
    "doc": "**Alias** of the reverse direction of `Nat.cast_int_covby_iff`.",
    "depth": 8},
   {"type": "âˆ€ {n : â„•} {a b : Fin n}, a â‹– b â†’ â†‘a â‹– â†‘b",
    "name": "Covby.coe_fin",
    "isProp": true,
    "doc": "**Alias** of the reverse direction of `Fin.coe_covby_iff`.",
    "depth": 9},
   {"type":
    "âˆ€ {Î± : Type u_1} [inst : LT Î±] {a b : Î±} [inst_1 : DenselyOrdered Î±], Â¬a â‹– b",
    "name": "not_covby",
    "isProp": true,
    "doc": "In a dense order, nothing covers anything. ",
    "depth": 10}],
  "count": 181},
 {"noDocExamples": [],
  "kind": "Â«termâˆƒ!_,_Â»",
  "examples":
  [{"type":
    "âˆ€ {Î± : Type u_1} (r : Setoid Î±), Setoid.mkClasses (Setoid.classes r) (_ : âˆ€ (a : Î±), âˆƒ! b x, a âˆˆ b) = r",
    "name": "Setoid.mkClasses_classes",
    "isProp": true,
    "doc":
    "The equivalence relation made from the equivalence classes of an equivalence\nrelation r equals r. ",
    "depth": 8},
   {"type":
    "âˆ€ {Î± : Sort u_1} {Î² : Sort u_2} {f : Î± â†’ Î²}, Function.Bijective f â†’ âˆ€ (b : Î²), âˆƒ! a, f a = b",
    "name": "Function.Bijective.existsUnique",
    "isProp": true,
    "doc":
    "Shorthand for using projection notation with `Function.bijective_iff_existsUnique`. ",
    "depth": 10},
   {"type":
    "âˆ€ {Î± : Sort u_1} {r : Î± â†’ Î± â†’ Prop},\n  Symmetric r â†’ ((âˆ€ (a : Î±), âˆƒ! b, r a b) â†” âˆƒ f, Function.Involutive f âˆ§ âˆ€ {a b : Î±}, r a b â†” f a = b)",
    "name": "Symmetric.forall_existsUnique_iff",
    "isProp": true,
    "doc":
    "A symmetric relation `r : Î± â†’ Î± â†’ Prop` is \"function-like\"\n(for each `a` there exists a unique `b` such that `r a b`)\nif and only if it is `(f Â· = Â·)` for some involutive function `f`. ",
    "depth": 13}],
  "count": 181},
 {"noDocExamples": [],
  "kind": "Set.Â«termâ‹ƒâ‚€_Â»",
  "examples":
  [{"type":
    "âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] {s : Set (Set Î±)}, TopologicalSpace.IsTopologicalBasis s â†’ â‹ƒâ‚€ s = Set.univ",
    "name": "TopologicalSpace.IsTopologicalBasis.sUnion_eq",
    "isProp": true,
    "doc": "The sets from `s` cover the whole space. ",
    "depth": 8},
   {"type": "âˆ€ {Î± : Type u_1} {S T : Set (Set Î±)}, S âŠ† T â†’ â‹ƒâ‚€ S âŠ† â‹ƒâ‚€ T",
    "name": "Set.sUnion_mono",
    "isProp": true,
    "doc": "**Alias** of `Set.sUnion_subset_sUnion`.",
    "depth": 10},
   {"type":
    "âˆ€ {Î± : Type u_1} {S : Set (Set Î±)}, S âŠ† {âˆ…, Set.univ} â†’ â‹ƒâ‚€ S âˆˆ {âˆ…, Set.univ}",
    "name": "Set.sUnion_mem_empty_univ",
    "isProp": true,
    "doc":
    "If all sets in a collection are either `âˆ…` or `Set.univ`, then so is their union. ",
    "depth": 10}],
  "count": 171},
 {"noDocExamples": [],
  "kind": "Â«termâ„¤âˆš_Â»",
  "examples":
  [{"type": "âˆ€ {d : â„¤} {a : â„¤âˆšd}, Zsqrtd.norm a = 1 â†” a âˆˆ unitary (â„¤âˆšd)",
    "name": "Zsqrtd.norm_eq_one_iff_mem_unitary",
    "isProp": true,
    "doc":
    "An element of `â„¤âˆšd` has norm equal to `1` if and only if it is contained in the submonoid\nof unitary elements. ",
    "depth": 13},
   {"type": "{d : â„¤} â†’ â„¤âˆšd",
    "name": "Zsqrtd.sqrtd",
    "isProp": false,
    "doc": "The representative of `âˆšd` in the ring ",
    "depth": 2},
   {"type": "{d : â„¤} â†’ Zero (â„¤âˆšd)",
    "name": "Zsqrtd.instZeroZsqrtd",
    "isProp": false,
    "doc": "The zero of the ring ",
    "depth": 3}],
  "count": 162},
 {"noDocExamples":
  [{"type":
    "âˆ€ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {X Y : C} (Î± : X â‰… Y), Î± â‰ªâ‰« CategoryTheory.Iso.refl Y = Î±",
    "name": "CategoryTheory.Iso.trans_refl",
    "isProp": true,
    "depth": 14}],
  "kind": "CategoryTheory.Iso.Â«term_â‰ªâ‰«_Â»",
  "examples":
  [{"type":
    "âˆ€ {B : Type u} [inst : CategoryTheory.Bicategory B] {a b : B} (self : CategoryTheory.Bicategory.Equivalence a b),\n  CategoryTheory.Bicategory.leftZigzagIso self.unit self.counit =\n    CategoryTheory.Bicategory.leftUnitor self.hom â‰ªâ‰« (CategoryTheory.Bicategory.rightUnitor self.hom).symm",
    "name": "CategoryTheory.Bicategory.Equivalence.left_triangle",
    "isProp": true,
    "doc":
    "The composition of the unit and the counit is equal to the identity up to unitors. ",
    "depth": 19},
   {"type":
    "âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] {D : Type uâ‚‚} [inst_1 : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D]\n  {F G H : CategoryTheory.Functor C D} (e : F â‰… G) (e' : G â‰… H) (hF : CategoryTheory.IsEquivalence F),\n  CategoryTheory.IsEquivalence.ofIso e' (CategoryTheory.IsEquivalence.ofIso e hF) =\n    CategoryTheory.IsEquivalence.ofIso (e â‰ªâ‰« e') hF",
    "name": "CategoryTheory.IsEquivalence.ofIso_trans",
    "isProp": true,
    "doc":
    "Compatibility of `ofIso` with the composition of isomorphisms of functors ",
    "depth": 24}],
  "count": 160},
 {"noDocExamples": [],
  "kind": "Â«term_âˆ†_Â»",
  "examples":
  [{"type":
    "âˆ€ {r s : â„},\n  Real.IsConjugateExponent r s â†’ {x | âˆƒ k > 0, beattySeq r k = x} âˆ† {x | âˆƒ k > 0, beattySeq' s k = x} = {n | 0 < n}",
    "name": "beattySeq_symmDiff_beattySeq'_pos",
    "isProp": true,
    "doc":
    "Generalization of Rayleigh's theorem on Beatty sequences. Let `r` be a real number greater\nthan 1, and `1/r + 1/s = 1`. Then `Bâº_r` and `Bâº'_s` partition the positive integers. ",
    "depth": 17},
   {"type":
    "âˆ€ {r s : â„},\n  Real.IsConjugateExponent r s â†’\n    Irrational r â†’ {x | âˆƒ k > 0, beattySeq r k = x} âˆ† {x | âˆƒ k > 0, beattySeq s k = x} = {n | 0 < n}",
    "name": "Irrational.beattySeq_symmDiff_beattySeq_pos",
    "isProp": true,
    "doc":
    "**Rayleigh's theorem** on Beatty sequences. Let `r` be an irrational number greater than 1, and\n`1/r + 1/s = 1`. Then `Bâº_r` and `Bâº_s` partition the positive integers. ",
    "depth": 18},
   {"type":
    "âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] {s : MeasureTheory.SignedMeasure Î±} {u v : Set Î±},\n  MeasurableSet u â†’\n    MeasurableSet v â†’\n      MeasureTheory.VectorMeasure.restrict 0 u â‰¤ MeasureTheory.VectorMeasure.restrict s u â†’\n        MeasureTheory.VectorMeasure.restrict 0 v â‰¤ MeasureTheory.VectorMeasure.restrict s v â†’\n          â†‘s (u âˆ† v) = 0 â†’ â†‘s (u \\ v) = 0 âˆ§ â†‘s (v \\ u) = 0",
    "name":
    "MeasureTheory.SignedMeasure.of_diff_eq_zero_of_symmDiff_eq_zero_positive",
    "isProp": true,
    "doc":
    "If the symmetric difference of two positive sets is a null-set, then so are the differences\nbetween the two sets. ",
    "depth": 25}],
  "count": 159},
 {"noDocExamples": [],
  "kind": "MeasureTheory.Â«termâˆ«â»_In_,_âˆ‚_Â»",
  "examples":
  [{"type":
    "âˆ€ {Î± : Type u_1} {mÎ± : MeasurableSpace Î±} (Ï : MeasureTheory.Measure (Î± Ã— â„)) [inst : MeasureTheory.IsFiniteMeasure Ï]\n  (r : â„š) {s : Set Î±},\n  MeasurableSet s â†’\n    âˆ«â» (a : Î±) in s, ENNReal.ofReal (â†‘(ProbabilityTheory.condCdf Ï a) â†‘r) âˆ‚MeasureTheory.Measure.fst Ï =\n      â†‘â†‘Ï (s Ã—Ë¢ Set.Iic â†‘r)",
    "name": "ProbabilityTheory.set_lintegral_condCdf_rat",
    "isProp": true,
    "doc": "Auxiliary lemma for `set_lintegral_cond_cdf`. ",
    "depth": 18},
   {"type":
    "âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {Î¹ : Type u_5} {f : Î± â†’ ENNReal},\n  âˆ«â» (x : Î±), f x âˆ‚Î¼ â‰  âŠ¤ â†’\n    âˆ€ {l : Filter Î¹} {s : Î¹ â†’ Set Î±},\n      Filter.Tendsto (â†‘â†‘Î¼ âˆ˜ s) l (nhds 0) â†’ Filter.Tendsto (fun i => âˆ«â» (x : Î±) in s i, f x âˆ‚Î¼) l (nhds 0)",
    "name": "MeasureTheory.tendsto_set_lintegral_zero",
    "isProp": true,
    "doc":
    "If `f` has finite integral, then `âˆ«â» x in s, f x âˆ‚Î¼` is absolutely continuous in `s`: it tends\nto zero as `Î¼ s` tends to zero. ",
    "depth": 19},
   {"type":
    "âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] {Î¼ : MeasureTheory.Measure Î±} [inst_1 : MeasureTheory.SigmaFinite Î¼]\n  (C : ENNReal) {f : Î± â†’ ENNReal},\n  AEMeasurable f â†’ (âˆ€ (s : Set Î±), MeasurableSet s â†’ â†‘â†‘Î¼ s â‰  âŠ¤ â†’ âˆ«â» (x : Î±) in s, f x âˆ‚Î¼ â‰¤ C) â†’ âˆ«â» (x : Î±), f x âˆ‚Î¼ â‰¤ C",
    "name": "MeasureTheory.lintegral_le_of_forall_fin_meas_le",
    "isProp": true,
    "doc":
    "If the Lebesgue integral of a function is bounded by some constant on all sets with finite\nmeasure and the measure is Ïƒ-finite, then the integral over the whole space is bounded by that same\nconstant. ",
    "depth": 21}],
  "count": 156},
 {"noDocExamples": [],
  "kind": "Multiset.Â«term_::â‚˜_Â»",
  "examples":
  [{"type":
    "{Î± : Type u_1} â†’\n  [inst : DecidableEq Î±] â†’\n    {Î´ : Î± â†’ Sort v} â†’ (m : Multiset Î±) â†’ (a : Î±) â†’ Î´ a â†’ ((a : Î±) â†’ a âˆˆ m â†’ Î´ a) â†’ (a' : Î±) â†’ a' âˆˆ a ::â‚˜ m â†’ Î´ a'",
    "name": "Multiset.Pi.cons",
    "isProp": false,
    "doc":
    "Given `Î´ : Î± â†’ Type*`, a multiset `m` and a term `a`, as well as a term `b : Î´ a` and a\nfunction `f` such that `f a' : Î´ a'` for all `a'` in `m`, `Pi.cons m a b f` is a function `g` such\nthat `g a'' : Î´ a''` for all `a''` in `a ::â‚˜ m`. ",
    "depth": 14},
   {"type":
    "{Î± : Type u_1} â†’\n  {C : Multiset Î± â†’ Sort u_3} â†’\n    C 0 â†’\n      (C_cons : (a : Î±) â†’ (m : Multiset Î±) â†’ C m â†’ C (a ::â‚˜ m)) â†’\n        (âˆ€ (a a' : Î±) (m : Multiset Î±) (b : C m),\n            HEq (C_cons a (a' ::â‚˜ m) (C_cons a' m b)) (C_cons a' (a ::â‚˜ m) (C_cons a m b))) â†’\n          (m : Multiset Î±) â†’ C m",
    "name": "Multiset.rec",
    "isProp": false,
    "doc":
    "Dependent recursor on multisets.\nTODO: should be @[recursor 6], but then the definition of `Multiset.pi` fails with a stack\noverflow in `whnf`.\n",
    "depth": 18},
   {"type":
    "âˆ€ {A : Type u_2} [inst : CommRing A] [inst_1 : IsDomain A] [inst_2 : IsDedekindDomain A],\n  Â¬IsField A â†’\n    âˆ€ {I M : Ideal A},\n      I â‰  âŠ¥ â†’\n        I â‰¤ M â†’\n          âˆ€ [hM : Ideal.IsMaximal M],\n            âˆƒ Z,\n              Multiset.prod (M ::â‚˜ Multiset.map PrimeSpectrum.asIdeal Z) â‰¤ I âˆ§\n                Â¬Multiset.prod (Multiset.map PrimeSpectrum.asIdeal Z) â‰¤ I",
    "name": "exists_multiset_prod_cons_le_and_prod_not_le",
    "isProp": true,
    "doc":
    "Specialization of `exists_primeSpectrum_prod_le_and_ne_bot_of_domain` to Dedekind domains:\nLet `I : Ideal A` be a nonzero ideal, where `A` is a Dedekind domain that is not a field.\nThen `exists_primeSpectrum_prod_le_and_ne_bot_of_domain` states we can find a product of prime\nideals that is contained within `I`. This lemma extends that result by making the product minimal:\nlet `M` be a maximal ideal that contains `I`, then the product including `M` is contained within `I`\nand the product excluding `M` is not contained within `I`. ",
    "depth": 29}],
  "count": 153},
 {"noDocExamples": [],
  "kind": "Â«term_â‰ƒáµ_Â»",
  "examples":
  [{"type":
    "{Î± : Type u_1} â†’ {Î² : Type u_2} â†’ [inst : MeasurableSpace Î±] â†’ [inst_1 : MeasurableSpace Î²] â†’ Î± â‰ƒáµ Î² â†’ Î² â†’ Î±",
    "name": "MeasurableEquiv.Simps.symm_apply",
    "isProp": false,
    "doc": "See Note [custom simps projection] ",
    "depth": 9},
   {"type":
    "(Î± : Type u_8) â†’ (Î² : Type u_9) â†’ [inst : Unique Î±] â†’ [inst : MeasurableSpace Î²] â†’ (Î± â†’ Î²) â‰ƒáµ Î²",
    "name": "MeasurableEquiv.funUnique",
    "isProp": false,
    "doc":
    "If `Î±` has a unique term, then the type of function `Î± â†’ Î²` is measurably equivalent to `Î²`. ",
    "depth": 9},
   {"type":
    "{G : Type u_1} â†’ [inst : MeasurableSpace G] â†’ [inst_1 : Group G] â†’ [inst_2 : MeasurableMul G] â†’ G â†’ G â‰ƒáµ G",
    "name": "MeasurableEquiv.divRight",
    "isProp": false,
    "doc": "`equiv.divRight` as a `MeasurableEquiv`. ",
    "depth": 10}],
  "count": 153},
 {"noDocExamples": [],
  "kind": "Â«term_â†’â‚—â…_,_â†_Â»",
  "examples":
  [{"type":
    "{R : Type u} â†’\n  {L : Type v} â†’\n    {M : Type w} â†’\n      {N : Type wâ‚} â†’\n        [inst : CommRing R] â†’\n          [inst_1 : LieRing L] â†’\n            [inst_2 : LieAlgebra R L] â†’\n              [inst_3 : AddCommGroup M] â†’\n                [inst_4 : Module R M] â†’\n                  [inst_5 : LieRingModule L M] â†’\n                    [inst_6 : LieModule R L M] â†’\n                      [inst_7 : AddCommGroup N] â†’\n                        [inst_8 : Module R N] â†’\n                          [inst_9 : LieRingModule L N] â†’\n                            [inst_10 : LieModule R L N] â†’\n                              (M â†’â‚—â…R,Lâ† N) â†’\n                                â†¥â†‘(LieModule.maxTrivSubmodule R L M) â†’â‚—â…R,Lâ† â†¥â†‘(LieModule.maxTrivSubmodule R L N)",
    "name": "LieModule.maxTrivHom",
    "isProp": false,
    "doc": "`maxTrivSubmodule` is functorial. ",
    "depth": 40},
   {"type":
    "âˆ€ {R : Type u} {L : Type v} {M : Type w} [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L]\n  [inst_3 : AddCommGroup M] [inst_4 : Module R M] [inst_5 : LieRingModule L M] [inst_6 : LieModule R L M]\n  (N : LieSubmodule R L M) â¦ƒf g : M â§¸ N â†’â‚—â…R,Lâ† Mâ¦„,\n  LieModuleHom.comp f (LieSubmodule.Quotient.mk' N) = LieModuleHom.comp g (LieSubmodule.Quotient.mk' N) â†’ f = g",
    "name": "LieSubmodule.Quotient.lieModuleHom_ext",
    "isProp": true,
    "doc":
    "Two `LieModuleHom`s from a quotient lie module are equal if their compositions with\n`LieSubmodule.Quotient.mk'` are equal.\n\nSee note [partially-applied ext lemmas]. ",
    "depth": 42},
   {"type":
    "{R : Type u} â†’\n  {L : Type v} â†’\n    {M : Type w} â†’\n      [inst : CommRing R] â†’\n        [inst_1 : LieRing L] â†’\n          [inst_2 : AddCommGroup M] â†’ [inst_3 : Module R M] â†’ [inst_4 : LieRingModule L M] â†’ M â†’â‚—â…R,Lâ† M",
    "name": "LieModuleHom.id",
    "isProp": false,
    "doc": "The identity map is a morphism of Lie modules. ",
    "depth": 20}],
  "count": 153},
 {"noDocExamples": [],
  "kind": "Â«term_â‰ƒL[_]_Â»",
  "examples":
  [{"type":
    "âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F]\n  (p : FormalMultilinearSeries ğ•œ E F) (i : E â‰ƒL[ğ•œ] F),\n  FormalMultilinearSeries.leftInv (FormalMultilinearSeries.removeZero p) i = FormalMultilinearSeries.leftInv p i",
    "name": "FormalMultilinearSeries.leftInv_removeZero",
    "isProp": true,
    "doc":
    "The left inverse does not depend on the zeroth coefficient of a formal multilinear\nseries. ",
    "depth": 36},
   {"type":
    "{Râ‚ : Type u_1} â†’\n  [inst : Semiring Râ‚] â†’\n    (Mâ‚ : Type u_4) â†’\n      [inst_1 : TopologicalSpace Mâ‚] â†’ [inst_2 : AddCommMonoid Mâ‚] â†’ [inst_3 : Module Râ‚ Mâ‚] â†’ Group (Mâ‚ â‰ƒL[Râ‚] Mâ‚)",
    "name": "ContinuousLinearEquiv.automorphismGroup",
    "isProp": false,
    "doc":
    "The continuous linear equivalences from `M` to itself form a group under composition. ",
    "depth": 23},
   {"type":
    "(Î¹ : Type u_1) â†’ (ğ•œ : Type u_3) â†’ [inst : IsROrC ğ•œ] â†’ [inst_1 : Fintype Î¹] â†’ EuclideanSpace ğ•œ Î¹ â‰ƒL[ğ•œ] Î¹ â†’ ğ•œ",
    "name": "EuclideanSpace.equiv",
    "isProp": false,
    "doc": "A shorthand for `PiLp.continuousLinearEquiv`. ",
    "depth": 25}],
  "count": 150},
 {"noDocExamples": [],
  "kind": "Â«term_â‡¨_Â»",
  "examples":
  [{"type":
    "âˆ€ {Î± : Type u} [self : BooleanAlgebra Î±] (x y : Î±), x â‡¨ y = y âŠ” xá¶œ",
    "name": "BooleanAlgebra.himp_eq",
    "isProp": true,
    "doc": "`x â‡¨ y` is equal to `y âŠ” xá¶œ` ",
    "depth": 13},
   {"type":
    "âˆ€ {Î± : Type u} [self : CompleteAtomicBooleanAlgebra Î±] (x y : Î±), x â‡¨ y = y âŠ” xá¶œ",
    "name": "CompleteAtomicBooleanAlgebra.himp_eq",
    "isProp": true,
    "doc": "`x â‡¨ y` is equal to `y âŠ” xá¶œ` ",
    "depth": 14},
   {"type":
    "âˆ€ {Î± : Type u_2} [inst : GeneralizedHeytingAlgebra Î±] {a b c : Î±}, Codisjoint a c â†’ b â‰¤ a â†’ c â‡¨ b â‰¤ a",
    "name": "Codisjoint.himp_le_of_right_le",
    "isProp": true,
    "doc": "See `himp_le` for a stronger version in Boolean algebras. ",
    "depth": 16}],
  "count": 148},
 {"noDocExamples": [],
  "kind": "Filter.Â«termâˆƒá¶ _In_,_Â»",
  "examples":
  [{"type":
    "âˆ€ {Î± : Type u} {f : Ultrafilter Î±} {p : Î± â†’ Prop}, (âˆƒá¶  (x : Î±) in â†‘f, p x) â†’ âˆ€á¶  (x : Î±) in â†‘f, p x",
    "name": "Filter.Frequently.eventually",
    "isProp": true,
    "doc":
    "**Alias** of the forward direction of `Ultrafilter.frequently_iff_eventually`.",
    "depth": 8},
   {"type":
    "âˆ€ {n : â„•}, n â‰  0 â†’ âˆ€ (d : â„•), âˆƒá¶  (m : â„•) in Filter.atTop, m â‰¡ d [MOD n]",
    "name": "Nat.frequently_modEq",
    "isProp": true,
    "doc": "Infinitely many natural numbers are equal to `d` mod `n`. ",
    "depth": 9},
   {"type":
    "âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} {a : Î±}, (âˆƒá¶  (x : Î±) in nhds a, x âˆˆ s) â†’ a âˆˆ closure s",
    "name": "Filter.Frequently.mem_closure",
    "isProp": true,
    "doc":
    "**Alias** of the reverse direction of `mem_closure_iff_frequently`.",
    "depth": 13}],
  "count": 148},
 {"noDocExamples": [],
  "kind": "Â«term_â†’â‚™+*_Â»",
  "examples":
  [{"type":
    "(Î± : Type u_1) â†’ (Î² : Type u_2) â†’ [inst : NonUnitalNonAssocSemiring Î²] â†’ Î² â†’â‚™+* Î± â†’ Î²",
    "name": "Pi.constNonUnitalRingHom",
    "isProp": false,
    "doc": "`Function.const` as a `NonUnitalRingHom`. ",
    "depth": 7},
   {"type":
    "{R : Type u} â†’\n  {S : Type v} â†’\n    [inst : NonUnitalNonAssocRing R] â†’ [inst_1 : NonUnitalNonAssocRing S] â†’ (R â†’â‚™+* S) â†’ (R â†’â‚™+* S) â†’ NonUnitalSubring R",
    "name": "NonUnitalRingHom.eqLocus",
    "isProp": false,
    "doc":
    "The `NonUnitalSubring` of elements `x : R` such that `f x = g x`, i.e.,\nthe equalizer of f and g as a `NonUnitalSubring` of R ",
    "depth": 10},
   {"type":
    "{Î± : Type u_1} â†’\n  {Î² : Type u_2} â†’\n    [inst : NonUnitalNonAssocSemiring Î±] â†’ [inst_1 : NonUnitalNonAssocSemiring Î²] â†’ (Î±áµáµ’áµ– â†’â‚™+* Î²áµáµ’áµ–) â‰ƒ (Î± â†’â‚™+* Î²)",
    "name": "NonUnitalRingHom.unop",
    "isProp": false,
    "doc":
    "The 'unopposite' of a non-unital ring hom `Î±áµáµ’áµ– â†’â‚™+* Î²áµáµ’áµ–`. Inverse to\n`NonUnitalRingHom.op`. ",
    "depth": 11}],
  "count": 144},
 {"noDocExamples": [],
  "kind": "Lean.Parser.Term.explicit",
  "examples":
  [{"type": "RingHom.LocalizationPreserves @RingHom.Finite",
    "name": "localization_finite",
    "isProp": true,
    "doc":
    "If `S` is a finite `R`-algebra, then `S' = Mâ»Â¹S` is a finite `R' = Mâ»Â¹R`-algebra. ",
    "depth": 1},
   {"type": "CategoryTheory.UnbundledHom @UniformContinuous",
    "name": "UniformSpaceCat.instUnbundledHomTypeUniformSpaceUniformContinuous",
    "isProp": true,
    "doc": "The information required to build morphisms for `UniformSpace`. ",
    "depth": 4},
   {"type":
    "âˆ€ {Î± : Type u_1} {Î³ : Type u_3}, Monotone (@UniformFun.uniformSpace Î± Î³)",
    "name": "UniformFun.mono",
    "isProp": true,
    "doc":
    "If `uâ‚` and `uâ‚‚` are two uniform structures on `Î³` and `uâ‚ â‰¤ uâ‚‚`, then\n`ğ’°(Î±, Î³, uâ‚) â‰¤ ğ’°(Î±, Î³, uâ‚‚)`. ",
    "depth": 9}],
  "count": 140},
 {"noDocExamples": [],
  "kind": "Â«term_â†ªo_Â»",
  "examples":
  [{"type": "Ordinal.{u_1} â†ªo Surreal",
    "name": "Ordinal.toSurreal",
    "isProp": false,
    "doc": "Converts an ordinal into the corresponding surreal. ",
    "depth": 5},
   {"type": "(V : Type u_3) â†’ SimpleGraph V â†ªo Set (Sym2 V)",
    "name": "SimpleGraph.edgeSetEmbedding",
    "isProp": false,
    "doc":
    "The edges of G consist of the unordered pairs of vertices related by\n`G.Adj`. This is the order embedding; for the edge set of a particular graph, see\n`SimpleGraph.edgeSet`.\n\nThe way `edgeSet` is defined is such that `mem_edgeSet` is proved by `refl`.\n(That is, `âŸ¦(v, w)âŸ§ âˆˆ G.edgeSet` is definitionally equal to `G.Adj v w`.)\n",
    "depth": 6},
   {"type": "â„•âˆ â†ªo ENNReal",
    "name": "ENat.toENNRealOrderEmbedding",
    "isProp": false,
    "doc": "Coercion `â„•âˆ â†’ â„â‰¥0âˆ` as an `OrderEmbedding`. ",
    "depth": 8}],
  "count": 139},
 {"noDocExamples": [],
  "kind": "Â«term_â†’SL[_]_Â»",
  "examples":
  [{"type":
    "{Râ‚ : Type u_1} â†’\n  {Râ‚‚ : Type u_2} â†’\n    [inst : Semiring Râ‚] â†’\n      [inst_1 : Semiring Râ‚‚] â†’\n        {Ïƒâ‚â‚‚ : Râ‚ â†’+* Râ‚‚} â†’\n          {Mâ‚ : Type u_4} â†’\n            [inst_2 : TopologicalSpace Mâ‚] â†’\n              [inst_3 : AddCommMonoid Mâ‚] â†’\n                {Mâ‚‚ : Type u_6} â†’\n                  [inst_4 : TopologicalSpace Mâ‚‚] â†’\n                    [inst_5 : AddCommMonoid Mâ‚‚] â†’\n                      [inst_6 : Module Râ‚ Mâ‚] â†’ [inst_7 : Module Râ‚‚ Mâ‚‚] â†’ Zero (Mâ‚ â†’SL[Ïƒâ‚â‚‚] Mâ‚‚)",
    "name": "ContinuousLinearMap.zero",
    "isProp": false,
    "doc": "The continuous map that is constantly zero. ",
    "depth": 27},
   {"type":
    "âˆ€ {Râ‚ : Type u_1} {Râ‚‚ : Type u_2} [inst : Semiring Râ‚] [inst_1 : Semiring Râ‚‚] {Ïƒâ‚â‚‚ : Râ‚ â†’+* Râ‚‚} {Mâ‚ : Type u_4}\n  [inst_2 : TopologicalSpace Mâ‚] [inst_3 : AddCommMonoid Mâ‚] {Mâ‚‚ : Type u_6} [inst_4 : TopologicalSpace Mâ‚‚]\n  [inst_5 : AddCommMonoid Mâ‚‚] [inst_6 : Module Râ‚ Mâ‚] [inst_7 : Module Râ‚‚ Mâ‚‚] [inst_8 : RingHomSurjective Ïƒâ‚â‚‚]\n  [inst_9 : TopologicalSpace Râ‚] [inst_10 : TopologicalSpace Râ‚‚] [inst_11 : ContinuousSMul Râ‚ Mâ‚]\n  [inst_12 : ContinuousAdd Mâ‚] [inst_13 : ContinuousSMul Râ‚‚ Mâ‚‚] [inst_14 : ContinuousAdd Mâ‚‚] (f : Mâ‚ â†’SL[Ïƒâ‚â‚‚] Mâ‚‚)\n  (s : Submodule Râ‚ Mâ‚),\n  Submodule.map (â†‘f) (Submodule.topologicalClosure s) â‰¤ Submodule.topologicalClosure (Submodule.map (â†‘f) s)",
    "name": "Submodule.topologicalClosure_map",
    "isProp": true,
    "doc":
    "Under a continuous linear map, the image of the `TopologicalClosure` of a submodule is\ncontained in the `TopologicalClosure` of its image. ",
    "depth": 40},
   {"type":
    "{Râ‚ : Type u_1} â†’\n  {Râ‚‚ : Type u_2} â†’\n    [inst : Semiring Râ‚] â†’\n      [inst_1 : Semiring Râ‚‚] â†’\n        {Ïƒâ‚â‚‚ : Râ‚ â†’+* Râ‚‚} â†’\n          {Mâ‚ : Type u_4} â†’\n            [inst_2 : TopologicalSpace Mâ‚] â†’\n              [inst_3 : AddCommMonoid Mâ‚] â†’\n                {Mâ‚‚ : Type u_6} â†’\n                  [inst_4 : TopologicalSpace Mâ‚‚] â†’\n                    [inst_5 : AddCommMonoid Mâ‚‚] â†’\n                      [inst_6 : Module Râ‚ Mâ‚] â†’ [inst_7 : Module Râ‚‚ Mâ‚‚] â†’ (Mâ‚ â†’SL[Ïƒâ‚â‚‚] Mâ‚‚) â†’ Mâ‚ â†’â‚›â‚—[Ïƒâ‚â‚‚] Mâ‚‚",
    "name": "ContinuousLinearMap.Simps.coe",
    "isProp": false,
    "doc": "See Note [custom simps projection]. ",
    "depth": 27}],
  "count": 134},
 {"noDocExamples": [],
  "kind": "Â«term_â‰ƒáµ¢_Â»",
  "examples":
  [{"type":
    "{V : Type u_2} â†’\n  {P : Type u_3} â†’\n    [inst : SeminormedAddCommGroup V] â†’ [inst_1 : PseudoMetricSpace P] â†’ [inst_2 : NormedAddTorsor V P] â†’ P â†’ P â‰ƒáµ¢ V",
    "name": "IsometryEquiv.constVSub",
    "isProp": false,
    "doc":
    "Isometry between the tangent space `V` of a (semi)normed add torsor `P` and `P` given by\nsubtraction from `x : P`. ",
    "depth": 10},
   {"type":
    "{G : Type v} â†’ [inst : AddGroup G] â†’ [inst_1 : PseudoEMetricSpace G] â†’ [inst : IsometricVAdd G G] â†’ G â†’ G â‰ƒáµ¢ G",
    "name": "IsometryEquiv.addLeft",
    "isProp": false,
    "doc": "Addition `y â†¦ x + y` as an `IsometryEquiv`.",
    "depth": 10},
   {"type":
    "{G : Type v} â†’ [inst : Group G] â†’ [inst_1 : PseudoEMetricSpace G] â†’ [inst : IsometricSMul Gáµáµ’áµ– G] â†’ G â†’ G â‰ƒáµ¢ G",
    "name": "IsometryEquiv.mulRight",
    "isProp": false,
    "doc": "Multiplication `y â†¦ y * x` as an `IsometryEquiv`. ",
    "depth": 11}],
  "count": 132},
 {"noDocExamples": [],
  "kind": "Â«term_â†’â‚™â‚[_]_Â»",
  "examples":
  [{"type":
    "{S : Type u_1} â†’\n  {R : Type u_2} â†’\n    {A : Type u_3} â†’\n      [inst : CommSemiring R] â†’\n        [inst_1 : NonUnitalNonAssocSemiring A] â†’\n          [inst_2 : Module R A] â†’\n            [inst_3 : SetLike S A] â†’\n              [inst_4 : NonUnitalSubsemiringClass S A] â†’ [hSR : SMulMemClass S R A] â†’ (s : S) â†’ â†¥s â†’â‚™â‚[R] A",
    "name": "NonUnitalSubalgebraClass.subtype",
    "isProp": false,
    "doc": "Embedding of a non-unital subalgebra into the non-unital algebra. ",
    "depth": 25},
   {"type":
    "âˆ€ (k : Type uâ‚) {G : Type uâ‚‚} [inst : Semiring k] [inst_1 : Add G] {A : Type uâ‚ƒ} [inst_2 : NonUnitalNonAssocSemiring A]\n  [inst_3 : DistribMulAction k A] {Ï†â‚ Ï†â‚‚ : AddMonoidAlgebra k G â†’â‚™â‚[k] A},\n  (âˆ€ (x : G), Ï†â‚ (AddMonoidAlgebra.single x 1) = Ï†â‚‚ (AddMonoidAlgebra.single x 1)) â†’ Ï†â‚ = Ï†â‚‚",
    "name": "AddMonoidAlgebra.nonUnitalAlgHom_ext",
    "isProp": true,
    "doc":
    "A non_unital `k`-algebra homomorphism from `k[G]` is uniquely defined by its\nvalues on the functions `single a 1`. ",
    "depth": 29},
   {"type":
    "(R : Type u) â†’\n  (A : Type v) â†’\n    (B : Type w) â†’\n      [inst : Monoid R] â†’\n        [inst_1 : NonUnitalNonAssocSemiring A] â†’\n          [inst_2 : DistribMulAction R A] â†’\n            [inst_3 : NonUnitalNonAssocSemiring B] â†’ [inst_4 : DistribMulAction R B] â†’ B â†’â‚™â‚[R] A Ã— B",
    "name": "NonUnitalAlgHom.inr",
    "isProp": false,
    "doc":
    "The right injection into a product is a non-unital algebra homomorphism. ",
    "depth": 17}],
  "count": 128},
 {"noDocExamples": [],
  "kind": "Â«term_[Î›^_]â†’L[_]_Â»",
  "examples":
  [{"type":
    "{R : Type u_1} â†’\n  {M : Type u_2} â†’\n    {N : Type u_3} â†’\n      {Î¹ : Type u_4} â†’\n        [inst : Semiring R] â†’\n          [inst_1 : AddCommMonoid M] â†’\n            [inst_2 : Module R M] â†’\n              [inst_3 : TopologicalSpace M] â†’\n                [inst_4 : AddCommMonoid N] â†’\n                  [inst_5 : Module R N] â†’ [inst_6 : TopologicalSpace N] â†’ M[Î›^Î¹]â†’L[R]N â†’ M [Î›^Î¹]â†’â‚—[R] N",
    "name": "ContinuousAlternatingMap.toAlternatingMap",
    "isProp": false,
    "doc": "Projection to `AlternatingMap`s. ",
    "depth": 23},
   {"type":
    "{R : Type u_1} â†’\n  {M : Type u_2} â†’\n    {N : Type u_4} â†’\n      {Î¹ : Type u_6} â†’\n        [inst : Semiring R] â†’\n          [inst_1 : AddCommMonoid M] â†’\n            [inst_2 : Module R M] â†’\n              [inst_3 : TopologicalSpace M] â†’\n                [inst_4 : AddCommMonoid N] â†’\n                  [inst_5 : Module R N] â†’\n                    [inst_6 : TopologicalSpace N] â†’\n                      [inst_7 : ContinuousAdd N] â†’ M[Î›^Î¹]â†’L[R]N â†’+ ContinuousMultilinearMap R (fun x => M) N",
    "name": "ContinuousAlternatingMap.toMultilinearAddHom",
    "isProp": false,
    "doc":
    "Projection to `ContinuousMultilinearMap`s as a bundled `AddMonoidHom`. ",
    "depth": 28},
   {"type":
    "{R : Type u_1} â†’\n  {M : Type u_2} â†’\n    {N : Type u_4} â†’\n      {Î¹ : Type u_6} â†’\n        [inst : Semiring R] â†’\n          [inst_1 : AddCommMonoid M] â†’\n            [inst_2 : Module R M] â†’\n              [inst_3 : TopologicalSpace M] â†’\n                [inst_4 : AddCommMonoid N] â†’\n                  [inst_5 : Module R N] â†’\n                    [inst_6 : TopologicalSpace N] â†’ [inst_7 : ContinuousAdd N] â†’ (Î¹ â†’ M) â†’ M[Î›^Î¹]â†’L[R]N â†’+ N",
    "name": "ContinuousAlternatingMap.applyAddHom",
    "isProp": false,
    "doc":
    "Evaluation of a `ContinuousAlternatingMap` at a vector as an `AddMonoidHom`. ",
    "depth": 29}],
  "count": 128},
 {"noDocExamples": [],
  "kind": "Â«term_â†’*â‚€_Â»",
  "examples":
  [{"type": "â„•âˆ â†’*â‚€ â„•",
    "name": "ENat.toNat",
    "isProp": false,
    "doc": "Conversion of `â„•âˆ` to `â„•` sending `âˆ` to `0`. ",
    "depth": 8},
   {"type": "{Î± : Type u_1} â†’ [inst : LinearOrderedRing Î±] â†’ Î± â†’*â‚€ Î±",
    "name": "absHom",
    "isProp": false,
    "doc": "`abs` as a `MonoidWithZeroHom`. ",
    "depth": 10},
   {"type":
    "âˆ€ {M : Type u_9} {N : Type u_10} [inst : MulZeroOneClass M] [inst_1 : MulZeroOneClass N] (self : M â†’*â‚€ N) (x y : M),\n  ZeroHom.toFun (â†‘self) (x * y) = ZeroHom.toFun (â†‘self) x * ZeroHom.toFun (â†‘self) y",
    "name": "MonoidWithZeroHom.map_mul'",
    "isProp": true,
    "doc": "The proposition that the function preserves multiplication ",
    "depth": 17}],
  "count": 127},
 {"noDocExamples": [],
  "kind": "Â«term_â‰ƒâ‚—áµ¢[_]_Â»",
  "examples":
  [{"type":
    "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : InnerProductSpace â„ E]\n  [inst_2 : Fact (FiniteDimensional.finrank â„ E = 2)] (o : Orientation â„ E (Fin 2)) (Ï† : E â‰ƒâ‚—áµ¢[â„] E),\n  0 < LinearMap.det â†‘Ï†.toLinearEquiv â†’\n    LinearIsometryEquiv.trans (Orientation.rightAngleRotation o) Ï† =\n      LinearIsometryEquiv.trans Ï† (Orientation.rightAngleRotation o)",
    "name": "Orientation.linearIsometryEquiv_comp_rightAngleRotation'",
    "isProp": true,
    "doc": "`J` commutes with any positively-oriented isometric automorphism. ",
    "depth": 40},
   {"type":
    "{E : Type u_1} â†’\n  {F : Type u_3} â†’\n    [inst : NormedAddCommGroup E] â†’\n      [inst_1 : NormedSpace â„ E] â†’\n        [inst_2 : NormedAddCommGroup F] â†’ [inst_3 : NormedSpace â„ F] â†’ (f : E â‰ƒáµ¢ F) â†’ f 0 = 0 â†’ E â‰ƒâ‚—áµ¢[â„] F",
    "name": "IsometryEquiv.toRealLinearIsometryEquivOfMapZero",
    "isProp": false,
    "doc":
    "**Mazur-Ulam Theorem**: if `f` is an isometric bijection between two normed vector spaces\nover `â„` and `f 0 = 0`, then `f` is a linear isometry equivalence. ",
    "depth": 24},
   {"type":
    "{Î¹ : Type u_1} â†’\n  {ğ•œ : Type u_2} â†’\n    [inst : IsROrC ğ•œ] â†’\n      {E : Type u_3} â†’\n        [inst_1 : NormedAddCommGroup E] â†’\n          [inst_2 : InnerProductSpace ğ•œ E] â†’ HilbertBasis Î¹ ğ•œ E â†’ E â‰ƒâ‚—áµ¢[ğ•œ] â†¥(lp (fun i => ğ•œ) 2)",
    "name": "HilbertBasis.repr",
    "isProp": false,
    "doc":
    "The linear isometric equivalence implementing identifying the Hilbert space with `â„“Â²`. ",
    "depth": 34}],
  "count": 125},
 {"noDocExamples": [],
  "kind": "CategoryTheory.Limits.Â«term_â¨¯_Â»",
  "examples":
  [{"type":
    "{C : Type uâ‚} â†’\n  [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] â†’\n    {A : C} â†’ CategoryTheory.IsSubterminal A â†’ [inst_1 : CategoryTheory.Limits.HasBinaryProduct A A] â†’ A â¨¯ A â‰… A",
    "name": "CategoryTheory.IsSubterminal.isoDiag",
    "isProp": false,
    "doc": "If `A` is subterminal, it is isomorphic to `A â¨¯ A`. ",
    "depth": 12},
   {"type":
    "{C : Type u} â†’\n  [inst : CategoryTheory.Category.{v, u} C] â†’\n    {X Y : C} â†’ [inst_1 : CategoryTheory.Limits.HasBinaryProduct X Y] â†’ X â¨¯ Y âŸ¶ X",
    "name": "CategoryTheory.Limits.prod.fst",
    "isProp": false,
    "doc": "The projection map to the first component of the product. ",
    "depth": 12},
   {"type":
    "{C : Type u} â†’\n  [inst : CategoryTheory.Category.{v, u} C] â†’\n    {X Y : C} â†’ [inst_1 : CategoryTheory.Limits.HasBinaryProduct X Y] â†’ X â¨¯ Y âŸ¶ Y",
    "name": "CategoryTheory.Limits.prod.snd",
    "isProp": false,
    "doc": "The projection map to the second component of the product. ",
    "depth": 12}],
  "count": 123},
 {"noDocExamples": [],
  "kind": "Â«term_â¤³_Â»",
  "examples":
  [{"type":
    "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : RegularSpace X] {a b : X}, a â¤³ b â†’ b â¤³ a",
    "name": "Specializes.symm",
    "isProp": true,
    "doc": "**Alias** of the forward direction of `specializes_comm`.",
    "depth": 10},
   {"type":
    "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {x y : X}, x â¤³ y â†’ y âˆˆ closure {x}",
    "name": "Specializes.mem_closure",
    "isProp": true,
    "doc":
    "**Alias** of the forward direction of `specializes_iff_mem_closure`.",
    "depth": 11},
   {"type":
    "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {x y : X}, x â¤³ y â†’ pure x â‰¤ nhds y",
    "name": "Specializes.pure_le_nhds",
    "isProp": true,
    "doc": "**Alias** of the forward direction of `specializes_iff_pure`.",
    "depth": 12}],
  "count": 123},
 {"noDocExamples": [],
  "kind": "Prefunctor.Â«term_â¥¤q_Â»",
  "examples":
  [{"type":
    "âˆ€ {U : Type u_1} {V : Type u_2} [inst : Quiver U] [inst_1 : Quiver V] [inst_2 : Quiver.HasReverse U]\n  [inst_3 : Quiver.HasReverse V] {Ï† : U â¥¤q V} [self : Prefunctor.MapReverse Ï†] {u v : U} (e : u âŸ¶ v),\n  Ï†.map (Quiver.reverse e) = Quiver.reverse (Ï†.map e)",
    "name": "Prefunctor.MapReverse.map_reverse'",
    "isProp": true,
    "doc": "The image of a reverse is the reverse of the image. ",
    "depth": 22},
   {"type":
    "{B : Type u} â†’ [inst : Quiver B] â†’ B â¥¤q CategoryTheory.FreeBicategory B",
    "name": "CategoryTheory.FreeBicategory.of",
    "isProp": false,
    "doc": "Canonical prefunctor from `B` to `free_bicategory B`. ",
    "depth": 6},
   {"type": "(V : Type u_1) â†’ [inst : Quiver V] â†’ V â¥¤q V",
    "name": "Prefunctor.id",
    "isProp": false,
    "doc": "The identity morphism between quivers. ",
    "depth": 6}],
  "count": 122},
 {"noDocExamples": [],
  "kind": "CategoryTheory.Limits.Â«termâŠ¤__Â»",
  "examples":
  [{"type":
    "{C : Type u} â†’\n  [inst : CategoryTheory.Category.{v, u} C] â†’\n    [inst_1 : CategoryTheory.Limits.HasFiniteProducts C] â†’ CategoryTheory.Exponentiable (âŠ¤_ C)",
    "name": "CategoryTheory.terminalExponentiable",
    "isProp": false,
    "doc":
    "The terminal object is always exponentiable.\nThis isn't an instance because most of the time we'll prove cartesian closed for all objects\nat once, rather than just for this one.\n",
    "depth": 10},
   {"type":
    "âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] [inst_1 : CategoryTheory.Limits.HasInitial C]\n  [inst_2 : CategoryTheory.Limits.HasTerminal C],\n  CategoryTheory.Mono (CategoryTheory.Limits.initial.to (âŠ¤_ C)) â†’ CategoryTheory.Limits.InitialMonoClass C",
    "name": "CategoryTheory.Limits.InitialMonoClass.of_terminal",
    "isProp": true,
    "doc":
    "To show a category is an `InitialMonoClass` it suffices to show the unique morphism from the\ninitial object to a terminal object is a monomorphism. ",
    "depth": 11},
   {"type":
    "{C : Type uâ‚} â†’\n  [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] â†’ [inst_1 : CategoryTheory.Limits.HasTerminal C] â†’ (P : C) â†’ P âŸ¶ âŠ¤_ C",
    "name": "CategoryTheory.Limits.terminal.from",
    "isProp": false,
    "doc": "The map from an object to the terminal object. ",
    "depth": 10}],
  "count": 122},
 {"noDocExamples": [],
  "kind": "Â«term_â†ªr_Â»",
  "examples":
  [{"type":
    "{Î± : Type u_1} â†’ {Î² : Type u_2} â†’ (r : Î± â†’ Î± â†’ Prop) â†’ (s : Î² â†’ Î² â†’ Prop) â†’ r â†ªr Sum.Lex r s",
    "name": "RelEmbedding.sumLexInl",
    "isProp": false,
    "doc": "`Sum.inl` as a relation embedding into `Sum.Lex r s`. ",
    "depth": 9},
   {"type":
    "{X : Type u_5} â†’ (r : X â†’ X â†’ Prop) â†’ (p : X â†’ Prop) â†’ Subtype.val â»Â¹'o r â†ªr r",
    "name": "Subtype.relEmbedding",
    "isProp": false,
    "doc":
    "The induced relation on a subtype is an embedding under the natural inclusion. ",
    "depth": 11},
   {"type":
    "{Î± : Type u_1} â†’ {Î² : Type u_2} â†’ (r : Î± â†’ Î± â†’ Prop) â†’ (s : Î² â†’ Î² â†’ Prop) â†’ r â†ªr Sum.LiftRel r s",
    "name": "RelEmbedding.sumLiftRelInl",
    "isProp": false,
    "doc": "`Sum.inl` as a relation embedding into `Sum.LiftRel r s`. ",
    "depth": 11}],
  "count": 121},
 {"noDocExamples": [],
  "kind": "Hyperreal.Â«termâ„*Â»",
  "examples":
  [{"type": "â„*",
    "name": "Hyperreal.epsilon",
    "isProp": false,
    "doc": "A sample infinitesimal hyperreal",
    "depth": 0},
   {"type": "â„*",
    "name": "Hyperreal.omega",
    "isProp": false,
    "doc": "A sample infinite hyperreal",
    "depth": 0},
   {"type": "â„* â†’ Prop",
    "name": "Hyperreal.InfiniteNeg",
    "isProp": false,
    "doc":
    "A hyperreal number is negative infinite if it is smaller than all real numbers ",
    "depth": 1}],
  "count": 117},
 {"noDocExamples": [],
  "kind": "CategoryTheory.Limits.Â«termâ¨_Â»",
  "examples":
  [{"type":
    "{J : Type w} â†’\n  {C : Type u} â†’\n    [inst : CategoryTheory.Category.{v, u} C] â†’\n      [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] â†’\n        (f : J â†’ C) â†’ [inst_2 : CategoryTheory.Limits.HasBiproduct f] â†’ â¨ f â‰… âˆ f",
    "name": "CategoryTheory.Limits.biproduct.isoCoproduct",
    "isProp": false,
    "doc":
    "The canonical isomorphism between the chosen biproduct and the chosen coproduct. ",
    "depth": 14},
   {"type":
    "{J : Type w} â†’\n  {C : Type u} â†’\n    [inst : CategoryTheory.Category.{v, u} C] â†’\n      [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] â†’\n        (f : J â†’ C) â†’ [inst_2 : CategoryTheory.Limits.HasBiproduct f] â†’ (b : J) â†’ â¨ f âŸ¶ f b",
    "name": "CategoryTheory.Limits.biproduct.Ï€",
    "isProp": false,
    "doc": "The projection onto a summand of a biproduct. ",
    "depth": 15},
   {"type":
    "{C : Type uâ‚} â†’\n  [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] â†’\n    [inst_1 : CategoryTheory.Preadditive C] â†’\n      (M : CategoryTheory.Mat_ C) â†’ M â‰… â¨ fun i => (CategoryTheory.Mat_.embedding C).obj (CategoryTheory.Mat_.X M i)",
    "name": "CategoryTheory.Mat_.isoBiproductEmbedding",
    "isProp": false,
    "doc":
    "Every object in `Mat_ C` is isomorphic to the biproduct of its summands.\n",
    "depth": 16}],
  "count": 113},
 {"noDocExamples": [],
  "kind": "Nat.Â«term_â‰¡_[MOD_]Â»",
  "examples":
  [{"type":
    "âˆ€ {n : â„•}, n â‰  0 â†’ âˆ€ (d : â„•), âˆƒá¶  (m : â„•) in Filter.atTop, m â‰¡ d [MOD n]",
    "name": "Nat.frequently_modEq",
    "isProp": true,
    "doc": "Infinitely many natural numbers are equal to `d` mod `n`. ",
    "depth": 9},
   {"type": "âˆ€ {k : â„•}, k â‰  0 â†’ Set.Infinite {p | Nat.Prime p âˆ§ p â‰¡ 1 [MOD k]}",
    "name": "Nat.infinite_setOf_prime_modEq_one",
    "isProp": true,
    "doc":
    "For any positive `k : â„•` there are infinitely many primes `p` such that `p â‰¡ 1 [MOD k]`. ",
    "depth": 10},
   {"type": "âˆ€ {n a b : â„•}, a â‰¡ b [MOD n] â†’ â†‘n âˆ£ â†‘b - â†‘a",
    "name": "Nat.ModEq.dvd",
    "isProp": true,
    "doc": "**Alias** of the forward direction of `Nat.modEq_iff_dvd`.",
    "depth": 11}],
  "count": 112},
 {"noDocExamples": [],
  "kind": "Â«termâ„¤_[_]Â»",
  "examples":
  [{"type": "{p : â„•} â†’ [inst : Fact (Nat.Prime p)] â†’ Mul â„¤_[p]",
    "name": "PadicInt.instMulPadicInt",
    "isProp": false,
    "doc": "Multiplication on `â„¤_[p]` is inherited from `â„š_[p]`. ",
    "depth": 5},
   {"type": "{p : â„•} â†’ [inst : Fact (Nat.Prime p)] â†’ Zero â„¤_[p]",
    "name": "PadicInt.instZeroPadicInt",
    "isProp": false,
    "doc": "Zero on `â„¤_[p]` is inherited from `â„š_[p]`. ",
    "depth": 5},
   {"type": "{p : â„•} â†’ [hp : Fact (Nat.Prime p)] â†’ â„¤_[p] â†’ â„¤",
    "name": "PadicInt.valuation",
    "isProp": false,
    "doc":
    "`PadicInt.valuation` lifts the `p`-adic valuation on `â„š` to `â„¤_[p]`.  ",
    "depth": 5}],
  "count": 112},
 {"noDocExamples": [],
  "kind": "term!_",
  "examples":
  [{"type": "âˆ€ (x y : Bool), (!(x && y)) = (!x || !y)",
    "name": "Bool.not_and",
    "isProp": true,
    "doc": "De Morgan's law for boolean and ",
    "depth": 7},
   {"type": "âˆ€ {x y : Bool}, (!x) = !y â†” x = y",
    "name": "Bool.not_inj'",
    "isProp": true,
    "doc": "**Alias** of `Bool.not_inj_iff`.",
    "depth": 7},
   {"type": "âˆ€ (x y : Bool), (!(x || y)) = (!x && !y)",
    "name": "Bool.not_or",
    "isProp": true,
    "doc": "De Morgan's law for boolean or ",
    "depth": 7}],
  "count": 111},
 {"noDocExamples":
  [{"type": "{M : Type u_1} â†’ [inst : DivInvMonoid Máµáµ’áµ–] â†’ DivInvMonoid Máµˆáµáµƒ",
    "name": "DomMulAct.instDivInvMonoidDomMulAct",
    "isProp": false,
    "depth": 4},
   {"type":
    "âˆ€ {M : Type u_1} {Î± : Type u_3} {N : Type u_4} {Î² : Type u_2} [inst : SMul M Î±] [inst_1 : SMul N Î±]\n  [inst_2 : SMulCommClass M N Î±] [inst_3 : SMul N Î²] (c : Máµˆáµáµƒ) (f : Î± â†’[N] Î²) (a : Î±),\n  (c â€¢ f) a = f (DomMulAct.mk.symm c â€¢ a)",
    "name": "DomMulAct.smul_mulActionHom_apply",
    "isProp": true,
    "depth": 28}],
  "kind": "Â«term_áµˆáµáµƒÂ»",
  "examples":
  [{"type": "{M : Type u_1} â†’ M â‰ƒ Máµˆáµáµƒ",
    "name": "DomMulAct.mk",
    "isProp": false,
    "doc": "Equivalence between `M` and `Máµˆáµáµƒ`. ",
    "depth": 3}],
  "count": 111},
 {"noDocExamples": [],
  "kind": "Â«term_Ã—'_Â»",
  "examples":
  [{"type":
    "(M : Type u_1) â†’\n  (N : Type u_2) â†’\n    (Î± : Type u_5) â†’\n      [inst : AddMonoid M] â†’\n        [inst_1 : AddMonoid N] â†’\n          AddAction (M Ã— N) Î± â‰ƒ (x : AddAction M Î±) Ã—' (x_1 : AddAction N Î±) Ã—' VAddCommClass M N Î±",
    "name": "AddAction.prodEquiv",
    "isProp": false,
    "doc":
    "An `AddAction` by a product monoid is equivalent to\ncommuting `AddAction`s by the factors.",
    "depth": 16},
   {"type":
    "âˆ€ {Î± : Sort u_1} {Î² : Sort u_3} {p : Î± â†’ Î² â†’ Prop} {xâ‚€ xâ‚ : (a : Î±) Ã—' Subtype (p a)},\n  xâ‚€.fst = xâ‚.fst â†’ â†‘xâ‚€.snd = â†‘xâ‚.snd â†’ xâ‚€ = xâ‚",
    "name": "PSigma.subtype_ext",
    "isProp": true,
    "doc":
    "A specialized ext lemma for equality of `PSigma` types over an indexed subtype. ",
    "depth": 17},
   {"type":
    "{V : Type u} â†’\n  [inst : CategoryTheory.Category.{v, u} V] â†’\n    [inst_1 : CategoryTheory.Limits.HasZeroMorphisms V] â†’\n      CochainComplex.MkStruct V â†’\n        (Xâ‚€ : V) Ã—'\n          (Xâ‚ : V) Ã—' (Xâ‚‚ : V) Ã—' (dâ‚€ : Xâ‚€ âŸ¶ Xâ‚) Ã—' (dâ‚ : Xâ‚ âŸ¶ Xâ‚‚) Ã—' CategoryTheory.CategoryStruct.comp dâ‚€ dâ‚ = 0",
    "name": "CochainComplex.MkStruct.flat",
    "isProp": false,
    "doc": "Flatten to a tuple. ",
    "depth": 24}],
  "count": 111},
 {"noDocExamples": [],
  "kind": "Int.Â«termâŒŠ_âŒ‹Â»",
  "examples":
  [{"type": "âˆ€ (Î¾ : â„), Real.convergent Î¾ 0 = â†‘âŒŠÎ¾âŒ‹",
    "name": "Real.convergent_zero",
    "isProp": true,
    "doc": "The zeroth convergent of `Î¾` is `âŒŠÎ¾âŒ‹`. ",
    "depth": 7},
   {"type":
    "âˆ€ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] {v : K},\n  (GeneralizedContinuedFraction.of v).h = â†‘âŒŠvâŒ‹",
    "name": "GeneralizedContinuedFraction.of_h_eq_floor",
    "isProp": true,
    "doc": "The head term of the gcf of `v` is `âŒŠvâŒ‹`. ",
    "depth": 12},
   {"type":
    "âˆ€ (Î¾ : â„) (n : â„•), Real.convergent Î¾ (n + 1) = â†‘âŒŠÎ¾âŒ‹ + (Real.convergent (Int.fract Î¾)â»Â¹ n)â»Â¹",
    "name": "Real.convergent_succ",
    "isProp": true,
    "doc":
    "The `(n+1)`th convergent of `Î¾` is the `n`th convergent of `1/(fract Î¾)`. ",
    "depth": 12}],
  "count": 107},
 {"noDocExamples": [],
  "kind": "Submodule.Â«term_á—®Â»",
  "examples":
  [{"type":
    "âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {K : Submodule ğ•œ E} [inst_3 : CompleteSpace E], Ká—®á—®á—® = Ká—®",
    "name": "Submodule.triorthogonal_eq_orthogonal",
    "isProp": true,
    "doc": "The orthogonal complement satisfies `Ká—®á—®á—® = Ká—®`. ",
    "depth": 20},
   {"type":
    "âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  (K : Submodule ğ•œ E) [inst_3 : HasOrthogonalProjection K], Ká—®á—® = K",
    "name": "Submodule.orthogonal_orthogonal",
    "isProp": true,
    "doc":
    "If `K` admits an orthogonal projection, then the orthogonal complement of its orthogonal\ncomplement is itself. ",
    "depth": 20},
   {"type":
    "âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  (K : Submodule ğ•œ E), IsClosed â†‘Ká—®",
    "name": "Submodule.isClosed_orthogonal",
    "isProp": true,
    "doc": "The orthogonal complement of any submodule `K` is closed. ",
    "depth": 21}],
  "count": 107},
 {"noDocExamples": [],
  "kind": "Â«termâˆ«_In_.._,_âˆ‚_Â»",
  "examples":
  [{"type":
    "âˆ€ {E : Type u_3} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {f g : â„ â†’ E} {Î¼ : MeasureTheory.Measure â„}\n  {a b : â„}, Set.EqOn f g (Set.uIcc a b) â†’ âˆ« (x : â„) in a..b, f x âˆ‚Î¼ = âˆ« (x : â„) in a..b, g x âˆ‚Î¼",
    "name": "intervalIntegral.integral_congr",
    "isProp": true,
    "doc":
    "If two functions are equal in the relevant interval, their interval integrals are also equal. ",
    "depth": 18},
   {"type":
    "âˆ€ {f : â„ â†’ â„} {a b : â„} {Î¼ : MeasureTheory.Measure â„},\n  0 â‰¤á¶ [MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict Î¼ (Î™ a b))] f â†’\n    IntervalIntegrable f Î¼ a b â†’ (0 < âˆ« (x : â„) in a..b, f x âˆ‚Î¼ â†” a < b âˆ§ 0 < â†‘â†‘Î¼ (Function.support f âˆ© Set.Ioc a b))",
    "name": "intervalIntegral.integral_pos_iff_support_of_nonneg_ae'",
    "isProp": true,
    "doc":
    "If `f` is nonnegative and integrable on the unordered interval `Set.uIoc a b`, then its\nintegral over `a..b` is positive if and only if `a < b` and the measure of\n`Function.support f âˆ© Set.Ioc a b` is positive. ",
    "depth": 19},
   {"type":
    "âˆ€ {f : â„ â†’ â„} {a b : â„} {Î¼ : MeasureTheory.Measure â„},\n  0 â‰¤á¶ [MeasureTheory.Measure.ae Î¼] f â†’\n    IntervalIntegrable f Î¼ a b â†’ (0 < âˆ« (x : â„) in a..b, f x âˆ‚Î¼ â†” a < b âˆ§ 0 < â†‘â†‘Î¼ (Function.support f âˆ© Set.Ioc a b))",
    "name": "intervalIntegral.integral_pos_iff_support_of_nonneg_ae",
    "isProp": true,
    "doc":
    "If `f` is nonnegative a.e.-everywhere and it is integrable on the unordered interval\n`Set.uIoc a b`, then its integral over `a..b` is positive if and only if `a < b` and the\nmeasure of `Function.support f âˆ© Set.Ioc a b` is positive. ",
    "depth": 19}],
  "count": 101},
 {"noDocExamples": [],
  "kind": "Â«termâ„š_[_]Â»",
  "examples":
  [{"type": "{p : â„•} â†’ [inst : Fact (Nat.Prime p)] â†’ PadicSeq p â†’ â„š_[p]",
    "name": "Padic.mk",
    "isProp": false,
    "doc": "Builds the equivalence class of a Cauchy sequence of rationals. ",
    "depth": 5},
   {"type":
    "âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)] {q r : â„š_[p]},\n  padicNormE q â‰  padicNormE r â†’ padicNormE (q + r) = max (padicNormE q) (padicNormE r)",
    "name": "padicNormE.add_eq_max_of_ne'",
    "isProp": true,
    "doc":
    "Theorems about `padicNormE` are named with a `'` so the names do not conflict with the\nequivalent theorems about `norm` (`â€– â€–`). ",
    "depth": 26},
   {"type": "{p : â„•} â†’ [inst : Fact (Nat.Prime p)] â†’ â„¤_[p] â†’+* â„š_[p]",
    "name": "PadicInt.Coe.ringHom",
    "isProp": false,
    "doc": "The coercion from `â„¤_[p]` to `â„š_[p]` as a ring homomorphism. ",
    "depth": 10}],
  "count": 99},
 {"noDocExamples": [],
  "kind": "Â«term_âŠ¼_Â»",
  "examples":
  [{"type":
    "âˆ€ {Î± : Type u_1} [inst : DistribLattice Î±] [inst_1 : DecidableEq Î±] (s t : Finset Î±),\n  Finset.card s * Finset.card t â‰¤ Finset.card (s âŠ¼ t) * Finset.card (s âŠ» t)",
    "name": "Finset.le_card_infs_mul_card_sups",
    "isProp": true,
    "doc":
    "An inequality of Daykin. Interestingly, any lattice in which this inequality holds is\ndistributive. ",
    "depth": 18},
   {"type":
    "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : DistribLattice Î±] [inst_1 : DecidableEq Î±]\n  [inst_2 : LinearOrderedCommSemiring Î²] [inst_3 : ExistsAddOfLE Î²] (fâ‚ fâ‚‚ fâ‚ƒ fâ‚„ : Î± â†’ Î²),\n  0 â‰¤ fâ‚ â†’\n    0 â‰¤ fâ‚‚ â†’\n      0 â‰¤ fâ‚ƒ â†’\n        0 â‰¤ fâ‚„ â†’\n          (âˆ€ (a b : Î±), fâ‚ a * fâ‚‚ b â‰¤ fâ‚ƒ (a âŠ“ b) * fâ‚„ (a âŠ” b)) â†’\n            âˆ€ (s t : Finset Î±),\n              ((Finset.sum s fun a => fâ‚ a) * Finset.sum t fun a => fâ‚‚ a) â‰¤\n                (Finset.sum (s âŠ¼ t) fun a => fâ‚ƒ a) * Finset.sum (s âŠ» t) fun a => fâ‚„ a",
    "name": "four_functions_theorem",
    "isProp": true,
    "doc":
    "The **Four Functions Theorem**, aka **Ahlswede-Daykin Inequality**. ",
    "depth": 31},
   {"type":
    "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : DecidableEq Î±] [inst_1 : LinearOrderedCommSemiring Î²] [inst_2 : ExistsAddOfLE Î²]\n  {fâ‚ fâ‚‚ fâ‚ƒ fâ‚„ : Finset Î± â†’ Î²} (u : Finset Î±),\n  0 â‰¤ fâ‚ â†’\n    0 â‰¤ fâ‚‚ â†’\n      0 â‰¤ fâ‚ƒ â†’\n        0 â‰¤ fâ‚„ â†’\n          (âˆ€ â¦ƒs : Finset Î±â¦„, s âŠ† u â†’ âˆ€ â¦ƒt : Finset Î±â¦„, t âŠ† u â†’ fâ‚ s * fâ‚‚ t â‰¤ fâ‚ƒ (s âˆ© t) * fâ‚„ (s âˆª t)) â†’\n            âˆ€ {ğ’œ â„¬ : Finset (Finset Î±)},\n              ğ’œ âŠ† Finset.powerset u â†’\n                â„¬ âŠ† Finset.powerset u â†’\n                  ((Finset.sum ğ’œ fun s => fâ‚ s) * Finset.sum â„¬ fun s => fâ‚‚ s) â‰¤\n                    (Finset.sum (ğ’œ âŠ¼ â„¬) fun s => fâ‚ƒ s) * Finset.sum (ğ’œ âŠ» â„¬) fun s => fâ‚„ s",
    "name": "Finset.four_functions_theorem",
    "isProp": true,
    "doc":
    "The **Four Functions Theorem** on a powerset algebra. See `four_functions_theorem` for the\nfinite distributive lattice generalisation. ",
    "depth": 38}],
  "count": 99},
 {"noDocExamples": [],
  "kind": "Â«term_â†’â‹†â‚[_]_Â»",
  "examples":
  [{"type":
    "âˆ€ {R : Type u_1} {A : Type u_2} {B : Type u_3} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A]\n  [inst_3 : Star A] [inst_4 : Semiring B] [inst_5 : Algebra R B] [inst_6 : Star B] (self : A â†’â‹†â‚[R] B) (x : A),\n  OneHom.toFun (â†‘â†‘â†‘self.toAlgHom) (star x) = star (OneHom.toFun (â†‘â†‘â†‘self.toAlgHom) x)",
    "name": "StarAlgHom.map_star'",
    "isProp": true,
    "doc":
    "By definition, a â‹†-algebra homomorphism preserves the `star` operation. ",
    "depth": 30},
   {"type":
    "(R : Type u_2) â†’\n  (A : Type u_3) â†’\n    [inst : CommSemiring R] â†’ [inst_1 : Semiring A] â†’ [inst_2 : Algebra R A] â†’ [inst_3 : Star A] â†’ A â†’â‹†â‚[R] A",
    "name": "StarAlgHom.id",
    "isProp": false,
    "doc": "The identity as a `StarAlgHom`. ",
    "depth": 16},
   {"type":
    "{R : Type u_1} â†’\n  {A : Type u_2} â†’\n    {B : Type u_3} â†’\n      {C : Type u_4} â†’\n        [inst : CommSemiring R] â†’\n          [inst_1 : Semiring A] â†’\n            [inst_2 : Algebra R A] â†’\n              [inst_3 : Star A] â†’\n                [inst_4 : Semiring B] â†’\n                  [inst_5 : Algebra R B] â†’\n                    [inst_6 : Star B] â†’\n                      [inst_7 : Semiring C] â†’\n                        [inst_8 : Algebra R C] â†’ [inst_9 : Star C] â†’ (A â†’â‹†â‚[R] B) â†’ (A â†’â‹†â‚[R] C) â†’ A â†’â‹†â‚[R] B Ã— C",
    "name": "StarAlgHom.prod",
    "isProp": false,
    "doc": "The `Pi.prod` of two morphisms is a morphism. ",
    "depth": 26}],
  "count": 98},
 {"noDocExamples": [],
  "kind": "Â«term_âŠ»_Â»",
  "examples":
  [{"type":
    "âˆ€ {Î± : Type u_1} [inst : DistribLattice Î±] [inst_1 : DecidableEq Î±] (s t : Finset Î±),\n  Finset.card s * Finset.card t â‰¤ Finset.card (s âŠ¼ t) * Finset.card (s âŠ» t)",
    "name": "Finset.le_card_infs_mul_card_sups",
    "isProp": true,
    "doc":
    "An inequality of Daykin. Interestingly, any lattice in which this inequality holds is\ndistributive. ",
    "depth": 18},
   {"type":
    "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : DistribLattice Î±] [inst_1 : DecidableEq Î±]\n  [inst_2 : LinearOrderedCommSemiring Î²] [inst_3 : ExistsAddOfLE Î²] (fâ‚ fâ‚‚ fâ‚ƒ fâ‚„ : Î± â†’ Î²),\n  0 â‰¤ fâ‚ â†’\n    0 â‰¤ fâ‚‚ â†’\n      0 â‰¤ fâ‚ƒ â†’\n        0 â‰¤ fâ‚„ â†’\n          (âˆ€ (a b : Î±), fâ‚ a * fâ‚‚ b â‰¤ fâ‚ƒ (a âŠ“ b) * fâ‚„ (a âŠ” b)) â†’\n            âˆ€ (s t : Finset Î±),\n              ((Finset.sum s fun a => fâ‚ a) * Finset.sum t fun a => fâ‚‚ a) â‰¤\n                (Finset.sum (s âŠ¼ t) fun a => fâ‚ƒ a) * Finset.sum (s âŠ» t) fun a => fâ‚„ a",
    "name": "four_functions_theorem",
    "isProp": true,
    "doc":
    "The **Four Functions Theorem**, aka **Ahlswede-Daykin Inequality**. ",
    "depth": 31},
   {"type":
    "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : DecidableEq Î±] [inst_1 : LinearOrderedCommSemiring Î²] [inst_2 : ExistsAddOfLE Î²]\n  {fâ‚ fâ‚‚ fâ‚ƒ fâ‚„ : Finset Î± â†’ Î²} (u : Finset Î±),\n  0 â‰¤ fâ‚ â†’\n    0 â‰¤ fâ‚‚ â†’\n      0 â‰¤ fâ‚ƒ â†’\n        0 â‰¤ fâ‚„ â†’\n          (âˆ€ â¦ƒs : Finset Î±â¦„, s âŠ† u â†’ âˆ€ â¦ƒt : Finset Î±â¦„, t âŠ† u â†’ fâ‚ s * fâ‚‚ t â‰¤ fâ‚ƒ (s âˆ© t) * fâ‚„ (s âˆª t)) â†’\n            âˆ€ {ğ’œ â„¬ : Finset (Finset Î±)},\n              ğ’œ âŠ† Finset.powerset u â†’\n                â„¬ âŠ† Finset.powerset u â†’\n                  ((Finset.sum ğ’œ fun s => fâ‚ s) * Finset.sum â„¬ fun s => fâ‚‚ s) â‰¤\n                    (Finset.sum (ğ’œ âŠ¼ â„¬) fun s => fâ‚ƒ s) * Finset.sum (ğ’œ âŠ» â„¬) fun s => fâ‚„ s",
    "name": "Finset.four_functions_theorem",
    "isProp": true,
    "doc":
    "The **Four Functions Theorem** on a powerset algebra. See `four_functions_theorem` for the\nfinite distributive lattice generalisation. ",
    "depth": 38}],
  "count": 97},
 {"noDocExamples": [],
  "kind": "Â«term_â‰ƒáµƒ[_]_Â»",
  "examples":
  [{"type":
    "(k : Type u_1) â†’\n  {Pâ‚ : Type u_2} â†’\n    {Vâ‚ : Type u_6} â†’\n      [inst : Ring k] â†’\n        [inst_1 : AddCommGroup Vâ‚] â†’ [inst_2 : Module k Vâ‚] â†’ [inst_3 : AddTorsor Vâ‚ Pâ‚] â†’ Pâ‚ â†’ Pâ‚ â‰ƒáµƒ[k] Pâ‚",
    "name": "AffineEquiv.pointReflection",
    "isProp": false,
    "doc": "Point reflection in `x` as a permutation. ",
    "depth": 20},
   {"type":
    "(k : Type u_1) â†’\n  (Pâ‚ : Type u_2) â†’\n    {Vâ‚ : Type u_6} â†’\n      [inst : Ring k] â†’\n        [inst_1 : AddCommGroup Vâ‚] â†’\n          [inst_2 : Module k Vâ‚] â†’ [inst_3 : AddTorsor Vâ‚ Pâ‚] â†’ Multiplicative Vâ‚ â†’* Pâ‚ â‰ƒáµƒ[k] Pâ‚",
    "name": "AffineEquiv.constVAddHom",
    "isProp": false,
    "doc": "A more bundled version of `AffineEquiv.constVAdd`. ",
    "depth": 24},
   {"type":
    "{R : Type u_10} â†’\n  {V : Type u_11} â†’\n    {P : Type u_12} â†’\n      [inst : CommRing R] â†’\n        [inst_1 : AddCommGroup V] â†’ [inst_2 : Module R V] â†’ [inst_3 : AddTorsor V P] â†’ P â†’ RË£ â†’* P â‰ƒáµƒ[R] P",
    "name": "AffineEquiv.homothetyUnitsMulHom",
    "isProp": false,
    "doc":
    "Fixing a point in affine space, homothety about this point gives a group homomorphism from (the\ncentre of) the units of the scalars into the group of affine equivalences. ",
    "depth": 25}],
  "count": 97},
 {"noDocExamples": [],
  "kind": "Â«term_â‰ƒr_Â»",
  "examples":
  [{"type": "{Î± : Type u_1} â†’ (r : Î± â†’ Î± â†’ Prop) â†’ r â‰ƒr r",
    "name": "RelIso.refl",
    "isProp": false,
    "doc": "Identity map is a relation isomorphism. ",
    "depth": 6},
   {"type":
    "{Î± : Type u_1} â†’ {Î² : Type u_2} â†’ {r : Î± â†’ Î± â†’ Prop} â†’ {s : Î² â†’ Î² â†’ Prop} â†’ r â‰ƒr s â†’ s â‰ƒr r",
    "name": "RelIso.symm",
    "isProp": false,
    "doc": "Inverse map of a relation isomorphism is a relation isomorphism. ",
    "depth": 9},
   {"type":
    "{Î± : Type u_1} â†’ {Î² : Type u_2} â†’ {r : Î± â†’ Î± â†’ Prop} â†’ {s : Î² â†’ Î² â†’ Prop} â†’ r â‰ƒr s â†’ Î² â†’ Î±",
    "name": "RelIso.Simps.symm_apply",
    "isProp": false,
    "doc": "See Note [custom simps projection]. ",
    "depth": 9}],
  "count": 96},
 {"noDocExamples": [],
  "kind": "Set.Â«termâ‹‚â‚€_Â»",
  "examples":
  [{"type":
    "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {S : Set (Set X)}, (âˆ€ s âˆˆ S, IsGÎ´ s) â†’ Set.Countable S â†’ IsGÎ´ (â‹‚â‚€ S)",
    "name": "isGÎ´_sInter",
    "isProp": true,
    "doc": "A countable intersection of GÎ´ sets is a GÎ´ set. ",
    "depth": 12},
   {"type":
    "âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [self : AlexandrovDiscrete Î±] (S : Set (Set Î±)),\n  (âˆ€ s âˆˆ S, IsOpen s) â†’ IsOpen (â‹‚â‚€ S)",
    "name": "AlexandrovDiscrete.isOpen_sInter",
    "isProp": true,
    "doc":
    "The intersection of a family of open sets is an open set. Use `isOpen_sInter` in the root\nnamespace instead. ",
    "depth": 13},
   {"type":
    "âˆ€ {Î± : Type u_2} {l : Filter Î±} [self : CountableInterFilter l] (S : Set (Set Î±)),\n  Set.Countable S â†’ (âˆ€ s âˆˆ S, s âˆˆ l) â†’ â‹‚â‚€ S âˆˆ l",
    "name": "CountableInterFilter.countable_sInter_mem",
    "isProp": true,
    "doc":
    "For a countable collection of sets `s âˆˆ l`, their intersection belongs to `l` as well. ",
    "depth": 14}],
  "count": 95},
 {"noDocExamples": [],
  "kind": "FirstOrder.Language.Â«term_â†’á´¸_Â»",
  "examples":
  [{"type": "(L : FirstOrder.Language) â†’ L â†’á´¸ L",
    "name": "FirstOrder.Language.LHom.id",
    "isProp": false,
    "doc": "The identity language homomorphism. ",
    "depth": 3},
   {"type":
    "(L : FirstOrder.Language) â†’ [inst : FirstOrder.Language.IsOrdered L] â†’ FirstOrder.Language.order â†’á´¸ L",
    "name": "FirstOrder.Language.orderLHom",
    "isProp": false,
    "doc":
    "The language homomorphism sending the unique symbol `â‰¤` of `Language.order` to `â‰¤` in an ordered\nlanguage. ",
    "depth": 4},
   {"type":
    "{L : FirstOrder.Language} â†’ {L' : FirstOrder.Language} â†’ (L â†’á´¸ L') â†’ Prop",
    "name": "FirstOrder.Language.LHom.Injective",
    "isProp": false,
    "doc":
    "A language homomorphism is injective when all the maps between symbol types are. ",
    "depth": 5}],
  "count": 92},
 {"noDocExamples": [],
  "kind": "Â«term_â‰ƒáµ¤_Â»",
  "examples":
  [{"type":
    "{Î± : Type u_1} â†’\n  [inst : UniformSpace Î±] â†’ [inst_1 : CompleteSpace Î±] â†’ [inst_2 : SeparatedSpace Î±] â†’ UniformSpace.Completion Î± â‰ƒáµ¤ Î±",
    "name": "UniformSpace.Completion.UniformCompletion.completeEquivSelf",
    "isProp": false,
    "doc":
    "The uniform bijection between a complete space and its uniform completion. ",
    "depth": 10},
   {"type":
    "âˆ€ {Î± : Type u_4} {Î² : Type u_5} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] (self : Î± â‰ƒáµ¤ Î²),\n  UniformContinuous self.invFun",
    "name": "UniformEquiv.uniformContinuous_invFun",
    "isProp": true,
    "doc": "Uniform continuity of the inverse ",
    "depth": 12},
   {"type": "CompareReals.Bourbakiâ„ â‰ƒáµ¤ â„",
    "name": "CompareReals.compareEquiv",
    "isProp": false,
    "doc": "The uniform bijection between Bourbaki and Cauchy reals. ",
    "depth": 4}],
  "count": 92},
 {"noDocExamples": [],
  "kind": "CategoryTheory.Limits.Â«term_âŠ_Â»",
  "examples":
  [{"type":
    "{C : Type u} â†’\n  [inst : CategoryTheory.Category.{v, u} C] â†’\n    [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] â†’\n      {X Y : C} â†’ [inst_2 : CategoryTheory.Limits.HasBinaryBiproduct X Y] â†’ X âŸ¶ X âŠ Y",
    "name": "CategoryTheory.Limits.biprod.inl",
    "isProp": false,
    "doc": "The inclusion into the first summand of a binary biproduct. ",
    "depth": 13},
   {"type":
    "{C : Type u} â†’\n  [inst : CategoryTheory.Category.{v, u} C] â†’\n    [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] â†’\n      (X Y : C) â†’ [inst_2 : CategoryTheory.Limits.HasBinaryBiproduct X Y] â†’ X âŠ Y â‰… X â¨¿ Y",
    "name": "CategoryTheory.Limits.biprod.isoCoprod",
    "isProp": false,
    "doc":
    "The canonical isomorphism between the chosen biproduct and the chosen coproduct. ",
    "depth": 14},
   {"type":
    "{C : Type u_1} â†’\n  [inst : CategoryTheory.Category.{u_3, u_1} C] â†’\n    [inst_1 : CategoryTheory.Preadditive C] â†’\n      {S : CategoryTheory.ShortComplex C} â†’\n        CategoryTheory.ShortComplex.Splitting S â†’\n          [inst_2 : CategoryTheory.Limits.HasBinaryBiproduct S.Xâ‚ S.Xâ‚ƒ] â†’ S.Xâ‚‚ â‰… S.Xâ‚ âŠ S.Xâ‚ƒ",
    "name": "CategoryTheory.ShortComplex.Splitting.isoBinaryBiproduct",
    "isProp": false,
    "doc":
    "The isomorphism `S.Xâ‚‚ â‰… S.Xâ‚ âŠ S.Xâ‚ƒ` induced by a splitting of the short complex `S`. ",
    "depth": 15}],
  "count": 90},
 {"noDocExamples": [],
  "kind": "Lean.Parser.Term.subst",
  "examples":
  [{"type":
    "{Î± : Sort u} â†’\n  {r : Î± â†’ Î± â†’ Prop} â†’\n    {motive : Quot r â†’ Sort v} â†’\n      (f : (a : Î±) â†’ motive (Quot.mk r a)) â†’\n        (âˆ€ (a b : Î±) (p : r a b), (_ : Quot.mk r a = Quot.mk r b) â–¸ f a = f b) â†’ (q : Quot r) â†’ motive q",
    "name": "Quot.rec",
    "isProp": false,
    "doc":
    "Dependent recursion principle for `Quot`. This constructor can be tricky to use,\nso you should consider the simpler versions if they apply:\n* `Quot.lift`, for nondependent functions\n* `Quot.ind`, for theorems / proofs of propositions about quotients\n* `Quot.recOnSubsingleton`, when the target type is a `Subsingleton`\n* `Quot.hrecOn`, which uses `HEq (f a) (f b)` instead of a `sound p â–¸ f a = f b` assummption\n",
    "depth": 18},
   {"type":
    "âˆ€ {Î² : Sort u_1} {Î± : Sort u_2} (P : Î² â†’ Sort w) (e : Î± â‰ƒ Î²) (f : (a : Î±) â†’ P (e a)) (b : Î²),\n  (Equiv.piCongrLeft P e) f b = (_ : e (e.symm b) = b) â–¸ f (e.symm b)",
    "name": "Equiv.piCongrLeft_apply",
    "isProp": true,
    "doc":
    "Note: the \"obvious\" statement `(piCongrLeft P e) f b = f (e.symm b)` doesn't typecheck: the\nLHS would have type `P b` while the RHS would have type `P (e (e.symm b))`. For that reason,\nwe have to explicitly substitute along `e (e.symm b) = b` in the statement of this lemma. ",
    "depth": 27},
   {"type":
    "{Î± : Sort u_1} â†’\n  {C : Trunc Î± â†’ Sort u_3} â†’\n    (f : (a : Î±) â†’ C (Trunc.mk a)) â†’ (âˆ€ (a b : Î±), (_ : Trunc.mk a = Trunc.mk b) â–¸ f a = f b) â†’ (q : Trunc Î±) â†’ C q",
    "name": "Trunc.rec",
    "isProp": false,
    "doc": "Recursion/induction principle for `Trunc`. ",
    "depth": 15}],
  "count": 90},
 {"noDocExamples": [],
  "kind": "SimpleGraph.Â«term_â†’g_Â»",
  "examples":
  [{"type":
    "âˆ€ {V : Type u} {W : Type v} {G : SimpleGraph V} {F : SimpleGraph W} [inst : Finite W],\n  ((G' : SimpleGraph.Subgraph G) â†’ Set.Finite G'.verts â†’ SimpleGraph.Subgraph.coe G' â†’g F) â†’ Nonempty (G â†’g F)",
    "name": "SimpleGraph.nonempty_hom_of_forall_finite_subgraph_hom",
    "isProp": true,
    "doc":
    "If every finite subgraph of a graph `G` has a homomorphism to a finite graph `F`, then there is\na homomorphism from the whole of `G` to `F`. ",
    "depth": 16},
   {"type":
    "âˆ€ {V : Type u} {V' : Type v} {G : SimpleGraph V} {G' : SimpleGraph V'} {f : G â†’g G'} {u : V}\n  {p : SimpleGraph.Walk G u u},\n  Function.Injective â‡‘f â†’ SimpleGraph.Walk.IsCycle p â†’ SimpleGraph.Walk.IsCycle (SimpleGraph.Walk.map f p)",
    "name": "SimpleGraph.Walk.map_isCycle_of_injective",
    "isProp": true,
    "doc":
    "**Alias** of the reverse direction of `SimpleGraph.Walk.map_isCycle_iff_of_injective`.",
    "depth": 24},
   {"type":
    "âˆ€ {V : Type u} {V' : Type v} {G : SimpleGraph V} {G' : SimpleGraph V'} {u v : V} (p : SimpleGraph.Walk G u v)\n  {f : G â†’g G'} (f' : G â†’g G') (h : f = f'),\n  SimpleGraph.Walk.map f p = SimpleGraph.Walk.copy (SimpleGraph.Walk.map f' p) (_ : f' u = f u) (_ : f' v = f v)",
    "name": "SimpleGraph.Walk.map_eq_of_eq",
    "isProp": true,
    "doc":
    "Unlike categories, for graphs vertex equality is an important notion, so needing to be able to\nwork with equality of graph homomorphisms is a necessary evil. ",
    "depth": 34}],
  "count": 89},
 {"noDocExamples":
  [{"type":
    "âˆ€ {Î± : Type u_1} (a : Array Î±) (i : Fin (Array.size a)), Array.get a i = a[â†‘i]",
    "name": "Array.get_eq_getElem",
    "isProp": true,
    "depth": 15}],
  "kind": "Â«term__[_]Â»",
  "examples":
  [{"type":
    "âˆ€ {Î± : Type u_1} (self : Array.PrefixTable Î±) {i : â„•} (h : i < Array.size self.toArray), self.toArray[i].2 â‰¤ i",
    "name": "Array.PrefixTable.valid",
    "isProp": true,
    "doc": "Validity condition to help with termination proofs ",
    "depth": 19},
   {"type":
    "âˆ€ {Î± Î² Î´ : Type} [inst : CanonicallyLinearOrderedAddCommMonoid Î´] {C : Levenshtein.Cost Î± Î² Î´} {xs : List Î±}\n  {ys : List Î²} (self : LevenshteinEstimator' C xs ys),\n  self.bound =\n    match self.pre_rev, (_ : List.reverse self.pre_rev ++ self.suff = ys) with\n    | [], split => ((â†‘self.distances)[0], List.length ys)\n    | x, split => (List.minimum_of_length_pos (_ : 0 < List.length â†‘self.distances), List.length self.suff)",
    "name": "LevenshteinEstimator'.bound_eq",
    "isProp": true,
    "doc": "Predicate describing the current bound. ",
    "depth": 27}],
  "count": 88},
 {"noDocExamples": [],
  "kind": "Â«term_>>=_Â»",
  "examples":
  [{"type":
    "âˆ€ {m : Type u_1 â†’ Type u_2} {Î± Î² : Type u_1} {q : Î² â†’ Prop} {x : m Î±} [inst : Monad m] [inst_1 : LawfulMonad m]\n  {f : Î± â†’ m Î²}, SatisfiesM (fun a => SatisfiesM q (f a)) x â†’ SatisfiesM q (x >>= f)",
    "name": "SatisfiesM.bind_pre",
    "isProp": true,
    "doc":
    "`SatisfiesM` distributes over `>>=`, weakest precondition version. ",
    "depth": 18},
   {"type":
    "âˆ€ {m : Type u_1 â†’ Type u_2} {Î± Î² : Type u_1} {p : Î± â†’ Prop} {x : m Î±} {q : Î² â†’ Prop} [inst : Monad m]\n  [inst_1 : LawfulMonad m] {f : Î± â†’ m Î²},\n  SatisfiesM p x â†’ (âˆ€ (a : Î±), p a â†’ SatisfiesM q (f a)) â†’ SatisfiesM q (x >>= f)",
    "name": "SatisfiesM.bind",
    "isProp": true,
    "doc": "`SatisfiesM` distributes over `>>=`, general version. ",
    "depth": 19},
   {"type":
    "{Î± Î² : Type u_1} â†’\n  [inst : DecidableEq Î²] â†’\n    (s : Set Î±) â†’ [inst : Fintype â†‘s] â†’ (f : Î± â†’ Set Î²) â†’ ((a : Î±) â†’ a âˆˆ s â†’ Fintype â†‘(f a)) â†’ Fintype â†‘(s >>= f)",
    "name": "Set.fintypeBind",
    "isProp": false,
    "doc":
    "If `s : Set Î±` is a set with `Fintype` instance and `f : Î± â†’ Set Î²` is a function such that\neach `f a`, `a âˆˆ s`, has a `Fintype` structure, then `s >>= f` has a `Fintype` structure. ",
    "depth": 16}],
  "count": 88},
 {"noDocExamples": [],
  "kind": "Â«term_â†’A[_]_Â»",
  "examples":
  [{"type":
    "{ğ•œ : Type u_1} â†’\n  {V : Type u_3} â†’\n    {W : Type u_4} â†’\n      [inst : NormedAddCommGroup V] â†’\n        [inst_1 : NormedAddCommGroup W] â†’\n          [inst_2 : NontriviallyNormedField ğ•œ] â†’\n            [inst_3 : NormedSpace ğ•œ V] â†’ [inst_4 : NormedSpace ğ•œ W] â†’ Norm (V â†’A[ğ•œ] W)",
    "name": "ContinuousAffineMap.hasNorm",
    "isProp": false,
    "doc":
    "Note that unlike the operator norm for linear maps, this norm is _not_ submultiplicative:\nwe do _not_ necessarily have `â€–f.comp gâ€– â‰¤ â€–fâ€– * â€–gâ€–`. See `norm_comp_le` for what we can say. ",
    "depth": 23},
   {"type":
    "âˆ€ {ğ•œ : Type u_1} {V : Type u_2} {W : Type u_3} [inst : NontriviallyNormedField ğ•œ] [inst_1 : NormedAddCommGroup V]\n  [inst_2 : NormedSpace ğ•œ V] [inst_3 : NormedAddCommGroup W] [inst_4 : NormedSpace ğ•œ W] {n : â„•âˆ} (f : V â†’A[ğ•œ] W),\n  ContDiff ğ•œ n â‡‘f",
    "name": "ContinuousAffineMap.contDiff",
    "isProp": true,
    "doc": "A continuous affine map between normed vector spaces is smooth. ",
    "depth": 33},
   {"type":
    "(R : Type u_1) â†’\n  {V : Type u_2} â†’\n    {W : Type u_3} â†’\n      (P : Type u_4) â†’\n        {Q : Type u_5} â†’\n          [inst : Ring R] â†’\n            [inst_1 : AddCommGroup V] â†’\n              [inst_2 : Module R V] â†’\n                [inst_3 : TopologicalSpace P] â†’\n                  [inst_4 : AddTorsor V P] â†’\n                    [inst_5 : AddCommGroup W] â†’\n                      [inst_6 : Module R W] â†’ [inst_7 : TopologicalSpace Q] â†’ [inst_8 : AddTorsor W Q] â†’ Q â†’ P â†’A[R] Q",
    "name": "ContinuousAffineMap.const",
    "isProp": false,
    "doc": "The constant map is a continuous affine map. ",
    "depth": 29}],
  "count": 86},
 {"noDocExamples": [],
  "kind": "Â«term_â©¿_Â»",
  "examples":
  [{"type": "âˆ€ {Î± : Type u_1} {s t : Finset Î±}, s â©¿ t â†’ s.val â©¿ t.val",
    "name": "wcovby.finset_val",
    "isProp": true,
    "doc": "**Alias** of the reverse direction of `Finset.val_wcovby_val`.",
    "depth": 10},
   {"type":
    "âˆ€ {Î± : Type u_1} [inst : Preorder Î±] {a b : Î±}, a â‰¤ b â†’ b â‰¤ a â†’ a â©¿ b",
    "name": "LE.le.wcovby_of_le",
    "isProp": true,
    "doc": "**Alias** of `wcovby_of_le_of_le`.",
    "depth": 11},
   {"type":
    "âˆ€ {Î± : Type u_1} [inst : PartialOrder Î±] {a b : Î±}, a â©¿ b â†’ a = b âˆ¨ a â‹– b",
    "name": "Wcovby.eq_or_covby",
    "isProp": true,
    "doc": "**Alias** of the forward direction of `wcovby_iff_eq_or_covby`.",
    "depth": 12}],
  "count": 86},
 {"noDocExamples": [],
  "kind": "CategoryTheory.Limits.Â«term_â¨¿_Â»",
  "examples":
  [{"type":
    "{C : Type u} â†’\n  [inst : CategoryTheory.Category.{v, u} C] â†’\n    [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] â†’\n      (X Y : C) â†’ [inst_2 : CategoryTheory.Limits.HasBinaryBiproduct X Y] â†’ X âŠ Y â‰… X â¨¿ Y",
    "name": "CategoryTheory.Limits.biprod.isoCoprod",
    "isProp": false,
    "doc":
    "The canonical isomorphism between the chosen biproduct and the chosen coproduct. ",
    "depth": 14},
   {"type":
    "{C : Type u_1} â†’\n  [inst : CategoryTheory.Category.{u_2, u_1} C] â†’\n    [inst_1 : CategoryTheory.Limits.HasZeroObject C] â†’\n      [inst_2 : CategoryTheory.Limits.HasZeroMorphisms C] â†’ (X : C) â†’ 0 â¨¿ X â‰… X",
    "name": "CategoryTheory.Limits.zeroCoprodIso",
    "isProp": false,
    "doc": "A zero object is a left unit for categorical coproduct. ",
    "depth": 15},
   {"type":
    "{C : Type u} â†’\n  [inst : CategoryTheory.Category.{v, u} C] â†’\n    [inst_1 : CategoryTheory.Limits.HasBinaryCoproducts C] â†’\n      (X Y : C) â†’\n        CategoryTheory.Limits.coprod.functor.obj (X â¨¿ Y) â‰…\n          CategoryTheory.Functor.comp (CategoryTheory.Limits.coprod.functor.obj Y)\n            (CategoryTheory.Limits.coprod.functor.obj X)",
    "name": "CategoryTheory.Limits.coprod.functorLeftComp",
    "isProp": false,
    "doc": "The coproduct functor can be decomposed. ",
    "depth": 18}],
  "count": 86},
 {"noDocExamples":
  [{"type": "âˆ€ {X Y : Type u} {x : X} {y : Y}, (Î²_ X Y).hom (x, y) = (y, x)",
    "name": "CategoryTheory.braiding_hom_apply",
    "isProp": true,
    "depth": 16},
   {"type": "âˆ€ {X Y : Type u} {x : X} {y : Y}, (Î²_ X Y).inv (y, x) = (x, y)",
    "name": "CategoryTheory.braiding_inv_apply",
    "isProp": true,
    "depth": 16}],
  "kind": "CategoryTheory.termÎ²_",
  "examples":
  [{"type":
    "{C : Type u_1} â†’\n  {D : Type u_2} â†’\n    [inst : CategoryTheory.Category.{u_3, u_1} C] â†’\n      [inst_1 : CategoryTheory.Category.{u_4, u_2} D] â†’\n        [inst_2 : CategoryTheory.MonoidalCategory C] â†’\n          [inst_3 : CategoryTheory.MonoidalCategory D] â†’\n            (F : CategoryTheory.MonoidalFunctor C D) â†’\n              [inst_4 : CategoryTheory.Faithful F.toFunctor] â†’\n                [inst_5 : CategoryTheory.BraidedCategory D] â†’\n                  (Î² :\n                      (X Y : C) â†’\n                        CategoryTheory.MonoidalCategory.tensorObj X Y â‰… CategoryTheory.MonoidalCategory.tensorObj Y X) â†’\n                    (âˆ€ (X Y : C),\n                        CategoryTheory.CategoryStruct.comp\n                            (CategoryTheory.LaxMonoidalFunctor.Î¼ F.toLaxMonoidalFunctor X Y) (F.map (Î² X Y).hom) =\n                          CategoryTheory.CategoryStruct.comp (Î²_ (F.obj X) (F.obj Y)).hom\n                            (CategoryTheory.LaxMonoidalFunctor.Î¼ F.toLaxMonoidalFunctor Y X)) â†’\n                      CategoryTheory.BraidedCategory C",
    "name": "CategoryTheory.braidedCategoryOfFaithful",
    "isProp": false,
    "doc":
    "Verifying the axioms for a braiding by checking that the candidate braiding is sent to a braiding\nby a faithful monoidal functor.\n",
    "depth": 33}],
  "count": 86},
 {"noDocExamples": [],
  "kind": "AddCommGroup.Â«term_â‰¡_[PMOD_]Â»",
  "examples":
  [{"type":
    "âˆ€ {Î± : Type u_1} [inst : AddCommGroup Î±] {p a b : Î±}, a â‰¡ b [PMOD p] â†’ b â‰¡ a [PMOD p]",
    "name": "AddCommGroup.ModEq.symm",
    "isProp": true,
    "doc": "**Alias** of the forward direction of `AddCommGroup.modEq_comm`.",
    "depth": 11},
   {"type":
    "âˆ€ {Î± : Type u_1} [inst : AddCommGroupWithOne Î±] [inst_1 : CharZero Î±] {a b z : â„¤}, a â‰¡ b [PMOD z] â†’ â†‘a â‰¡ â†‘b [PMOD â†‘z]",
    "name": "AddCommGroup.ModEq.int_cast",
    "isProp": true,
    "doc":
    "**Alias** of the reverse direction of `AddCommGroup.int_cast_modEq_int_cast`.",
    "depth": 14},
   {"type":
    "âˆ€ {Î± : Type u_1} [inst : AddCommGroupWithOne Î±] [inst_1 : CharZero Î±] {a b n : â„•}, a â‰¡ b [MOD n] â†’ â†‘a â‰¡ â†‘b [PMOD â†‘n]",
    "name": "AddCommGroup.ModEq.nat_cast",
    "isProp": true,
    "doc":
    "**Alias** of the reverse direction of `AddCommGroup.nat_cast_modEq_nat_cast`.",
    "depth": 14}],
  "count": 80},
 {"noDocExamples": [],
  "kind": "FirstOrder.Language.Â«term_âŠ¨__1Â»",
  "examples":
  [{"type":
    "(V : Type w') â†’\n  [inst : FirstOrder.Language.Structure FirstOrder.Language.graph V] â†’\n    [inst : V âŠ¨ FirstOrder.Language.Theory.simpleGraph] â†’ SimpleGraph V",
    "name": "FirstOrder.Language.simpleGraphOfStructure",
    "isProp": false,
    "doc":
    "Any model of the theory of simple graphs represents a simple graph. ",
    "depth": 7},
   {"type":
    "{L : FirstOrder.Language} â†’\n  (T : FirstOrder.Language.Theory L) â†’\n    (M : Type w) â†’\n      [inst : FirstOrder.Language.Structure L M] â†’\n        [inst : M âŠ¨ T] â†’ [inst : Nonempty M] â†’ FirstOrder.Language.Theory.ModelType T",
    "name": "FirstOrder.Language.Theory.ModelType.of",
    "isProp": false,
    "doc":
    "The object in the category of R-algebras associated to a type equipped with the appropriate\ntypeclasses. ",
    "depth": 9},
   {"type":
    "{L : FirstOrder.Language} â†’\n  (T : FirstOrder.Language.Theory L) â†’\n    (M : Type w') â†’\n      [inst : FirstOrder.Language.Structure L M] â†’\n        [inst_1 : Nonempty M] â†’ [inst : M âŠ¨ T] â†’ (Î± : Type w) â†’ Set (FirstOrder.Language.Theory.CompleteType T Î±)",
    "name": "FirstOrder.Language.Theory.realizedTypes",
    "isProp": false,
    "doc":
    "A complete type `p` is realized in a particular structure when there is some\ntuple `v` whose type is `p`. ",
    "depth": 11}],
  "count": 80},
 {"noDocExamples": [],
  "kind": "Asymptotics.Â«term_=Î˜[_]_Â»",
  "examples":
  [{"type":
    "âˆ€ {Î± : Type u_1} {l : Filter Î±} {f : Î± â†’ â„},\n  ((fun x => Real.exp (f x)) =Î˜[l] fun x => 1) â†” Filter.IsBoundedUnder (fun x x_1 => x â‰¤ x_1) l fun x => |f x|",
    "name": "Real.isTheta_exp_comp_one",
    "isProp": true,
    "doc":
    "`Real.exp (f x)` is bounded away from zero and infinity along a filter `l` if and only if\n`|f x|` is bounded from above along this filter. ",
    "depth": 13},
   {"type":
    "âˆ€ {Î± : Type u_1} {E : Type u_3} {F' : Type u_7} [inst : Norm E] [inst_1 : SeminormedAddCommGroup F'] {f : Î± â†’ E}\n  {g' : Î± â†’ F'} {l : Filter Î±}, (f =Î˜[l] fun x => â€–g' xâ€–) â†’ f =Î˜[l] g'",
    "name": "Asymptotics.IsTheta.of_norm_right",
    "isProp": true,
    "doc":
    "**Alias** of the forward direction of `Asymptotics.isTheta_norm_right`.",
    "depth": 17},
   {"type":
    "âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : Nonempty Î±] {T : â„• â†’ â„} {g : â„ â†’ â„} {a b : Î± â†’ â„} {r : Î± â†’ â„• â†’ â„•},\n  AkraBazziRecurrence T g a b r â†’ T =Î˜[Filter.atTop] AkraBazziRecurrence.asympBound g a b",
    "name": "AkraBazziRecurrence.isTheta_asympBound",
    "isProp": true,
    "doc":
    "The **Akra-Bazzi theorem**: `T âˆˆ Î˜(n^p (1 + âˆ‘_u^n g(u) / u^{p+1}))` ",
    "depth": 17}],
  "count": 77},
 {"noDocExamples":
  [{"type":
    "âˆ€ {Î± : Type u_2} [inst : Inf Î±] [inst_1 : HImp Î±] (a b : Î±), a â‡” b = (b â‡¨ a) âŠ“ (a â‡¨ b)",
    "name": "bihimp_def",
    "isProp": true,
    "depth": 12},
   {"type":
    "âˆ€ {Î± : Type u_2} [inst : GeneralizedHeytingAlgebra Î±], IsCommutative Î± fun x x_1 => x â‡” x_1",
    "name": "bihimp_isCommutative",
    "isProp": true,
    "depth": 12},
   {"type":
    "âˆ€ {Î± : Type u_2} [inst : GeneralizedHeytingAlgebra Î±] (a b : Î±), a â‡” (a â‡¨ b) = a âŠ“ b",
    "name": "bihimp_himp_eq_inf",
    "isProp": true,
    "depth": 13}],
  "kind": "Â«term_â‡”_Â»",
  "examples": [],
  "count": 76},
 {"noDocExamples": [],
  "kind": "Â«term_Ë¢Ê¸áµÂ»",
  "examples":
  [{"type": "{Î± : Type u_1} â†’ Î± â‰ƒ Î±Ë¢Ê¸áµ",
    "name": "SymAlg.sym",
    "isProp": false,
    "doc": "The element of `SymAlg Î±` that represents `a : Î±`. ",
    "depth": 3},
   {"type": "{Î± : Type u_1} â†’ Î±Ë¢Ê¸áµ â‰ƒ Î±",
    "name": "SymAlg.unsym",
    "isProp": false,
    "doc": "The element of `Î±` represented by `x : Î±Ë¢Ê¸áµ`. ",
    "depth": 4},
   {"type":
    "{Î± : Type u_1} â†’ [inst : Ring Î±] â†’ [inst : Invertible 2] â†’ NonAssocRing Î±Ë¢Ê¸áµ",
    "name": "SymAlg.instNonAssocRingSymAlg",
    "isProp": false,
    "doc":
    "The symmetrization of a real (unital, associative) algebra is a non-associative ring. ",
    "depth": 10}],
  "count": 75},
 {"noDocExamples": [],
  "kind": "CategoryTheory.Limits.Â«termâˆ_Â»",
  "examples":
  [{"type":
    "{J : Type w} â†’\n  {C : Type u} â†’\n    [inst : CategoryTheory.Category.{v, u} C] â†’\n      [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] â†’\n        (f : J â†’ C) â†’ [inst_2 : CategoryTheory.Limits.HasBiproduct f] â†’ â¨ f â‰… âˆ f",
    "name": "CategoryTheory.Limits.biproduct.isoCoproduct",
    "isProp": false,
    "doc":
    "The canonical isomorphism between the chosen biproduct and the chosen coproduct. ",
    "depth": 14},
   {"type":
    "{C : Type u} â†’\n  [inst : CategoryTheory.Category.{v, u} C] â†’\n    (I : CategoryTheory.Limits.MultispanIndex C) â†’\n      [inst_1 : CategoryTheory.Limits.HasMulticoequalizer I] â†’\n        [inst_2 : CategoryTheory.Limits.HasCoproduct I.left] â†’\n          [inst_3 : CategoryTheory.Limits.HasCoproduct I.right] â†’ âˆ I.right âŸ¶ CategoryTheory.Limits.multicoequalizer I",
    "name": "CategoryTheory.Limits.Multicoequalizer.sigmaÏ€",
    "isProp": false,
    "doc": "The canonical projection `âˆ I.right âŸ¶ multicoequalizer I`. ",
    "depth": 16},
   {"type":
    "{Î± : Type} â†’ [inst : Fintype Î±] â†’ (X : Î± â†’ CompHaus) â†’ â†‘(CompHaus.finiteCoproduct X).toTop â‰ƒâ‚œ â†‘(âˆ X).toTop",
    "name": "CompHaus.coproductHomeoCoproduct",
    "isProp": false,
    "doc":
    "The homeomorphism from the explicit finite coproducts to the abstract coproduct. ",
    "depth": 18}],
  "count": 75},
 {"noDocExamples": [],
  "kind": "Â«term_â‰ƒâ‚›â‚—[_]_Â»",
  "examples":
  [{"type":
    "{R : Type u_16} â†’\n  {S : Type u_17} â†’\n    [inst : Semiring R] â†’\n      [inst_1 : Semiring S] â†’\n        {Ïƒ : R â†’+* S} â†’\n          {Ïƒ' : S â†’+* R} â†’\n            [inst_2 : RingHomInvPair Ïƒ Ïƒ'] â†’\n              [inst_3 : RingHomInvPair Ïƒ' Ïƒ] â†’\n                {M : Type u_18} â†’\n                  {Mâ‚‚ : Type u_19} â†’\n                    [inst_4 : AddCommMonoid M] â†’\n                      [inst_5 : AddCommMonoid Mâ‚‚] â†’\n                        [inst_6 : Module R M] â†’ [inst_7 : Module S Mâ‚‚] â†’ (M â‰ƒâ‚›â‚—[Ïƒ] Mâ‚‚) â†’ M â‰ƒ+ Mâ‚‚",
    "name": "LinearEquiv.toAddEquiv",
    "isProp": false,
    "doc":
    "The additive equivalence of types underlying a linear equivalence. ",
    "depth": 29},
   {"type":
    "{R : Type u_1} â†’\n  {S : Type u_6} â†’\n    {M : Type u_7} â†’\n      {Mâ‚‚ : Type u_9} â†’\n        [inst : Semiring R] â†’\n          [inst_1 : Semiring S] â†’\n            [inst_2 : AddCommMonoid M] â†’\n              [inst_3 : AddCommMonoid Mâ‚‚] â†’\n                {module_M : Module R M} â†’\n                  {module_S_Mâ‚‚ : Module S Mâ‚‚} â†’\n                    {Ïƒ : R â†’+* S} â†’\n                      {Ïƒ' : S â†’+* R} â†’\n                        {reâ‚ : RingHomInvPair Ïƒ Ïƒ'} â†’ {reâ‚‚ : RingHomInvPair Ïƒ' Ïƒ} â†’ (M â‰ƒâ‚›â‚—[Ïƒ] Mâ‚‚) â†’ Mâ‚‚ â‰ƒâ‚›â‚—[Ïƒ'] M",
    "name": "LinearEquiv.symm",
    "isProp": false,
    "doc": "Linear equivalences are symmetric. ",
    "depth": 29},
   {"type":
    "{R : Type u_17} â†’\n  {S : Type u_18} â†’\n    [inst : Semiring R] â†’\n      [inst_1 : Semiring S] â†’\n        {Ïƒ : R â†’+* S} â†’\n          {Ïƒ' : S â†’+* R} â†’\n            [inst_2 : RingHomInvPair Ïƒ Ïƒ'] â†’\n              [inst_3 : RingHomInvPair Ïƒ' Ïƒ] â†’\n                {M : Type u_19} â†’\n                  {Mâ‚‚ : Type u_20} â†’\n                    [inst_4 : AddCommMonoid M] â†’\n                      [inst_5 : AddCommMonoid Mâ‚‚] â†’\n                        [inst_6 : Module R M] â†’ [inst_7 : Module S Mâ‚‚] â†’ (M â‰ƒâ‚›â‚—[Ïƒ] Mâ‚‚) â†’ M â†’ Mâ‚‚",
    "name": "LinearEquiv.Simps.apply",
    "isProp": false,
    "doc": "See Note [custom simps projection] ",
    "depth": 29}],
  "count": 74},
 {"noDocExamples": [],
  "kind": "Â«term_â†’â‹†â‚™â‚[_]_Â»",
  "examples":
  [{"type":
    "(R : Type u_1) â†’\n  (A : Type u_2) â†’\n    [inst : Monoid R] â†’\n      [inst_1 : NonUnitalNonAssocSemiring A] â†’ [inst_2 : DistribMulAction R A] â†’ [inst_3 : Star A] â†’ A â†’â‹†â‚™â‚[R] A",
    "name": "NonUnitalStarAlgHom.id",
    "isProp": false,
    "doc": "The identity as a non-unital â‹†-algebra homomorphism. ",
    "depth": 16},
   {"type":
    "(R : Type u_1) â†’\n  (A : Type u_2) â†’\n    [inst : CommSemiring R] â†’\n      [inst_1 : StarAddMonoid R] â†’\n        [inst_2 : NonUnitalSemiring A] â†’ [inst_3 : Star A] â†’ [inst_4 : Module R A] â†’ A â†’â‹†â‚™â‚[R] Unitization R A",
    "name": "Unitization.inrNonUnitalStarAlgHom",
    "isProp": false,
    "doc":
    "The coercion from a non-unital `R`-algebra `A` to its unitization `unitization R A`\nrealized as a non-unital star algebra homomorphism. ",
    "depth": 19},
   {"type":
    "(R : Type u_1) â†’\n  (A : Type u_2) â†’\n    (B : Type u_3) â†’\n      [inst : Monoid R] â†’\n        [inst_1 : NonUnitalNonAssocSemiring A] â†’\n          [inst_2 : DistribMulAction R A] â†’\n            [inst_3 : StarAddMonoid A] â†’\n              [inst_4 : NonUnitalNonAssocSemiring B] â†’\n                [inst_5 : DistribMulAction R B] â†’ [inst_6 : StarAddMonoid B] â†’ A â†’â‹†â‚™â‚[R] A Ã— B",
    "name": "NonUnitalStarAlgHom.inl",
    "isProp": false,
    "doc":
    "The left injection into a product is a non-unital algebra homomorphism. ",
    "depth": 20}],
  "count": 74},
 {"noDocExamples": [],
  "kind": "Lean.Parser.Term.let_fun",
  "examples":
  [{"type":
    "âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] {Î¹ : Type u_3} {s : Finset Î¹} {wâ‚ wâ‚‚ : Î¹ â†’ â„} (p : Î¹ â†’ P),\n  (Finset.sum s fun i => wâ‚ i) = 1 â†’\n    (Finset.sum s fun i => wâ‚‚ i) = 1 â†’\n      let_fun aâ‚ := (Finset.affineCombination â„ s p) wâ‚;\n      let_fun aâ‚‚ := (Finset.affineCombination â„ s p) wâ‚‚;\n      dist aâ‚ aâ‚‚ * dist aâ‚ aâ‚‚ =\n        (-Finset.sum s fun iâ‚ =>\n              Finset.sum s fun iâ‚‚ => (wâ‚ - wâ‚‚) iâ‚ * (wâ‚ - wâ‚‚) iâ‚‚ * (dist (p iâ‚) (p iâ‚‚) * dist (p iâ‚) (p iâ‚‚))) /\n          2",
    "name": "EuclideanGeometry.dist_affineCombination",
    "isProp": true,
    "doc":
    "The distance between two points given with `affineCombination`,\nin terms of the pairwise distances between the points in that\ncombination. ",
    "depth": 39},
   {"type":
    "(V W : SemiNormedGroupCat) â†’\n  let_fun this := fun V W => inferInstanceAs (AddGroup (NormedAddGroupHom â†‘V â†‘W));\n  (V âŸ¶ W) â†’+ (SemiNormedGroupCat.completion.obj V âŸ¶ SemiNormedGroupCat.completion.obj W)",
    "name": "SemiNormedGroupCat.completion.mapHom",
    "isProp": false,
    "doc":
    "Given a normed group hom `V âŸ¶ W`, this defines the associated morphism\nfrom the completion of `V` to the completion of `W`.\nThe difference from the definition obtained from the functoriality of completion is in that the\nmap sending a morphism `f` to the associated morphism of completions is itself additive. ",
    "depth": 20},
   {"type":
    "âˆ€ {Î¹ : Type u_1} {B : Type u_2} {F : Type u_3} [inst : TopologicalSpace B] [inst_1 : TopologicalSpace F]\n  (Z : FiberBundleCore Î¹ B F) (v : F),\n  (âˆ€ (i j : Î¹),\n      âˆ€ x âˆˆ FiberBundleCore.baseSet Z i âˆ© FiberBundleCore.baseSet Z j, FiberBundleCore.coordChange Z i j x v = v) â†’\n    Continuous\n      (let_fun this := fun x => { proj := x, snd := v };\n      this)",
    "name": "FiberBundleCore.continuous_const_section",
    "isProp": true,
    "doc":
    "If an element of `F` is invariant under all coordinate changes, then one can define a\ncorresponding section of the fiber bundle, which is continuous. This applies in particular to the\nzero section of a vector bundle. Another example (not yet defined) would be the identity\nsection of the endomorphism bundle of a vector bundle. ",
    "depth": 24}],
  "count": 72},
 {"noDocExamples": [],
  "kind": "CategoryTheory.Limits.Â«termâˆ_Â»",
  "examples":
  [{"type":
    "{Î¹ : Type v} â†’ (Î± : Î¹ â†’ TopCatMax) â†’ âˆ Î± â‰… TopCat.of ((i : Î¹) â†’ â†‘(Î± i))",
    "name": "TopCat.piIsoPi",
    "isProp": false,
    "doc":
    "The product is homeomorphic to the product of the underlying spaces,\nequipped with the product topology.\n",
    "depth": 12},
   {"type":
    "{C : Type u} â†’\n  [inst : CategoryTheory.Category.{v, u} C] â†’\n    {J : Type w} â†’\n      [inst_1 : CategoryTheory.SmallCategory J] â†’\n        [inst_2 : CategoryTheory.Limits.HasLimitsOfSize.{w, w, v, u} C] â†’\n          (F : CategoryTheory.Functor J C) â†’ CategoryTheory.Limits.limit F âŸ¶ âˆ fun j => F.obj j",
    "name": "CategoryTheory.Limits.limitSubobjectProduct",
    "isProp": false,
    "doc": "A limit can be realised as a subobject of a product. ",
    "depth": 19},
   {"type":
    "âˆ€ {Î² : Type v} {f g : Î² â†’ Type v} (Î± : (j : Î²) â†’ f j âŸ¶ g j) (b : Î²) (x : âˆ fun b => f b),\n  CategoryTheory.Limits.Pi.Ï€ g b (CategoryTheory.Limits.Pi.map Î± x) = Î± b (CategoryTheory.Limits.Pi.Ï€ f b x)",
    "name": "CategoryTheory.Limits.Types.pi_map_Ï€_apply'",
    "isProp": true,
    "doc":
    "A restatement of `Types.Limit.map_Ï€_apply` that uses `Pi.Ï€` and `Pi.map`,\nwith specialized universes. ",
    "depth": 20}],
  "count": 71},
 {"noDocExamples": [],
  "kind": "TypeVec.Â«term_:::_Â»",
  "examples":
  [{"type":
    "{n : â„•} â†’\n  {C : TypeVec.{u_1} (n + 1) â†’ Sort u} â†’\n    ((Î± : TypeVec.{u_1} n) â†’ (Î² : Type u_1) â†’ C (Î± ::: Î²)) â†’ (Î³ : TypeVec.{u_1} (n + 1)) â†’ C Î³",
    "name": "TypeVec.append1Cases",
    "isProp": false,
    "doc": "cases on `(n+1)-length` vectors ",
    "depth": 11},
   {"type":
    "{n : â„•} â†’ {Î± : TypeVec.{u_1} (n + 1)} â†’ TypeVec.Arrow (TypeVec.drop Î± ::: TypeVec.last Î±) Î±",
    "name": "TypeVec.fromAppend1DropLast",
    "isProp": false,
    "doc": "stitch two bits of a vector back together ",
    "depth": 11},
   {"type":
    "{n : â„•} â†’ {Î± : TypeVec.{u_1} (n + 1)} â†’ TypeVec.Arrow Î± (TypeVec.drop Î± ::: TypeVec.last Î±)",
    "name": "TypeVec.toAppend1DropLast",
    "isProp": false,
    "doc": "decompose a vector into its prefix appended with its last element ",
    "depth": 11}],
  "count": 71},
 {"noDocExamples": [],
  "kind": "Â«DistribMulActionHomLocalâ‰ºÂ»",
  "examples":
  [{"type":
    "âˆ€ {M : Type u_5} [inst : Monoid M] {A : Type u_6} [inst_1 : AddMonoid A] [inst_2 : DistribMulAction M A] {B : Type u_8}\n  [inst_3 : AddMonoid B] [inst_4 : DistribMulAction M B] (self : A â†’+[M] B),\n  MulActionHom.toFun self.toMulActionHom 0 = 0",
    "name": "DistribMulActionHom.map_zero'",
    "isProp": true,
    "doc": "The proposition that the function preserves 0 ",
    "depth": 23},
   {"type":
    "{M : Type u_5} â†’\n  [inst : Monoid M] â†’\n    {R : Type u_11} â†’\n      [inst_1 : Semiring R] â†’\n        [inst_2 : MulSemiringAction M R] â†’\n          {S : Type u_13} â†’ [inst_3 : Semiring S] â†’ [inst_4 : MulSemiringAction M S] â†’ (R â†’+*[M] S) â†’ R â†’+[M] S",
    "name": "MulSemiringActionHom.toDistribMulActionHom",
    "isProp": false,
    "doc":
    "Reinterpret an equivariant ring homomorphism as an equivariant additive monoid homomorphism. ",
    "depth": 19},
   {"type":
    "{M : Type u_5} â†’\n  [inst : Monoid M] â†’\n    {A : Type u_6} â†’\n      [inst_1 : AddMonoid A] â†’\n        [inst_2 : DistribMulAction M A] â†’\n          {B : Type u_8} â†’ [inst_3 : AddMonoid B] â†’ [inst_4 : DistribMulAction M B] â†’ (A â†’+[M] B) â†’ A â†’[M] B",
    "name": "DistribMulActionHom.toMulActionHom",
    "isProp": false,
    "doc":
    "Reinterpret an equivariant additive monoid homomorphism as an equivariant function. ",
    "depth": 19}],
  "count": 70},
 {"noDocExamples": [],
  "kind": "Â«term_â‰ƒáµƒâ±[_]_Â»",
  "examples":
  [{"type":
    "(ğ•œ : Type u_1) â†’\n  {V : Type u_2} â†’\n    (P : Type u_8) â†’\n      [inst : NormedField ğ•œ] â†’\n        [inst_1 : SeminormedAddCommGroup V] â†’\n          [inst_2 : NormedSpace ğ•œ V] â†’ [inst_3 : PseudoMetricSpace P] â†’ [inst_4 : NormedAddTorsor V P] â†’ P â‰ƒáµƒâ±[ğ•œ] P",
    "name": "AffineIsometryEquiv.refl",
    "isProp": false,
    "doc": "Identity map as an `AffineIsometryEquiv`. ",
    "depth": 22},
   {"type":
    "(ğ•œ : Type u_1) â†’\n  {V : Type u_2} â†’\n    {P : Type u_8} â†’\n      [inst : NormedField ğ•œ] â†’\n        [inst_1 : SeminormedAddCommGroup V] â†’\n          [inst_2 : NormedSpace ğ•œ V] â†’ [inst_3 : PseudoMetricSpace P] â†’ [inst_4 : NormedAddTorsor V P] â†’ P â†’ P â‰ƒáµƒâ±[ğ•œ] P",
    "name": "AffineIsometryEquiv.pointReflection",
    "isProp": false,
    "doc": "Point reflection in `x` as an affine isometric automorphism. ",
    "depth": 23},
   {"type":
    "{ğ•œ : Type u_1} â†’\n  {V : Type u_2} â†’\n    {P : Type u_8} â†’\n      [inst : NormedField ğ•œ] â†’\n        [inst_1 : SeminormedAddCommGroup V] â†’\n          [inst_2 : NormedSpace ğ•œ V] â†’\n            [inst_3 : PseudoMetricSpace P] â†’ [inst_4 : NormedAddTorsor V P] â†’ Group (P â‰ƒáµƒâ±[ğ•œ] P)",
    "name": "AffineIsometryEquiv.instGroupAffineIsometryEquiv",
    "isProp": false,
    "doc": "The group of affine isometries of a `NormedAddTorsor`, `P`. ",
    "depth": 23}],
  "count": 70},
 {"noDocExamples": [],
  "kind": "CategoryTheory.Limits.Â«termâŠ¥__Â»",
  "examples":
  [{"type":
    "{C : Type uâ‚} â†’\n  [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] â†’\n    [inst_1 : CategoryTheory.Limits.HasInitial C] â†’ CategoryTheory.Limits.IsInitial (âŠ¥_ C)",
    "name": "CategoryTheory.Limits.initialIsInitial",
    "isProp": false,
    "doc": "An initial object is initial. ",
    "depth": 7},
   {"type": "âŠ¥_ TopCat â‰… TopCat.of PEmpty.{u + 1}",
    "name": "TopCat.initialIsoPEmpty",
    "isProp": false,
    "doc": "The initial object of `Top` is `PEmpty`. ",
    "depth": 8},
   {"type": "âŠ¥_ Type u â‰… PEmpty.{u + 1}",
    "name": "CategoryTheory.Limits.Types.initialIso",
    "isProp": false,
    "doc": "The initial object in `Type u` is `PEmpty`. ",
    "depth": 8}],
  "count": 69},
 {"noDocExamples": [],
  "kind": "Nat.Â«termâŒŠ_âŒ‹â‚ŠÂ»",
  "examples":
  [{"type":
    "âˆ€ {Î± : Type u_2} [inst : LinearOrderedSemifield Î±] [inst_1 : FloorSemiring Î±] (m n : â„•), âŒŠâ†‘m / â†‘nâŒ‹â‚Š = m / n",
    "name": "Nat.floor_div_eq_div",
    "isProp": true,
    "doc": "Natural division is the floor of field division. ",
    "depth": 17},
   {"type":
    "âˆ€ (u : â„• â†’ â„) (l : â„),\n  Monotone u â†’\n    âˆ€ (c : â„• â†’ â„),\n      (âˆ€ (k : â„•), 1 < c k) â†’\n        Filter.Tendsto c Filter.atTop (nhds 1) â†’\n          (âˆ€ (k : â„•), Filter.Tendsto (fun n => u âŒŠc k ^ nâŒ‹â‚Š / â†‘âŒŠc k ^ nâŒ‹â‚Š) Filter.atTop (nhds l)) â†’\n            Filter.Tendsto (fun n => u n / â†‘n) Filter.atTop (nhds l)",
    "name": "tendsto_div_of_monotone_of_tendsto_div_floor_pow",
    "isProp": true,
    "doc":
    "If a monotone sequence `u` is such that `u âŒŠc^nâŒ‹â‚Š / âŒŠc^nâŒ‹â‚Š` converges to a limit `l` for all\n`c > 1`, then `u n / n` tends to `l`. It is even enough to have the assumption for a sequence of\n`c`s converging to `1`. ",
    "depth": 22},
   {"type":
    "âˆ€ (N : â„•) {j : â„},\n  0 < j â†’\n    âˆ€ {c : â„},\n      1 < c â†’\n        (Finset.sum (Finset.filter (fun x => j < â†‘âŒŠc ^ xâŒ‹â‚Š) (Finset.range N)) fun i => 1 / â†‘âŒŠc ^ iâŒ‹â‚Š ^ 2) â‰¤\n          c ^ 5 * (c - 1)â»Â¹ ^ 3 / j ^ 2",
    "name": "sum_div_nat_floor_pow_sq_le_div_sq",
    "isProp": true,
    "doc":
    "The sum of `1/âŒŠc^iâŒ‹â‚Š^2` above a threshold `j` is comparable to `1/j^2`, up to a multiplicative\nconstant. ",
    "depth": 22}],
  "count": 69},
 {"noDocExamples": [],
  "kind": "Â«term_â‰ƒâ‚—â…_â†_Â»",
  "examples":
  [{"type":
    "{R : Type u} â†’ {Lâ‚ : Type v} â†’ [inst : CommRing R] â†’ [inst_1 : LieRing Lâ‚] â†’ [inst_2 : LieAlgebra R Lâ‚] â†’ Lâ‚ â‰ƒâ‚—â…Râ† Lâ‚",
    "name": "LieEquiv.refl",
    "isProp": false,
    "doc": "Lie algebra equivalences are reflexive. ",
    "depth": 13},
   {"type":
    "âˆ€ {R : Type u} {L : Type v} {L' : Type w} [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L]\n  [inst_3 : LieRing L'] [inst_4 : LieAlgebra R L'] (self : L â‰ƒâ‚—â…Râ† L'), Function.RightInverse self.invFun self.toFun",
    "name": "LieEquiv.right_inv",
    "isProp": true,
    "doc":
    "The inverse function of an equivalence of Lie algebras is a right inverse of the underlying\nfunction. ",
    "depth": 24},
   {"type":
    "{R : Type u} â†’\n  {L : Type v} â†’\n    {L' : Type w} â†’\n      [inst : CommRing R] â†’\n        [inst_1 : LieRing L] â†’\n          [inst_2 : LieAlgebra R L] â†’ [inst_3 : LieRing L'] â†’ [inst_4 : LieAlgebra R L'] â†’ (L â‰ƒâ‚—â…Râ† L') â†’ L' â†’ L",
    "name": "LieEquiv.invFun",
    "isProp": false,
    "doc": "The inverse function of an equivalence of Lie algebras ",
    "depth": 17}],
  "count": 69},
 {"noDocExamples": [],
  "kind": "Int.Â«term_â‰¡_[ZMOD_]Â»",
  "examples":
  [{"type": "âˆ€ {n a b : â„¤}, a â‰¡ b [ZMOD n] â†’ n âˆ£ b - a",
    "name": "Int.ModEq.dvd",
    "isProp": true,
    "doc": "**Alias** of the forward direction of `Int.modEq_iff_dvd`.",
    "depth": 11},
   {"type": "âˆ€ {n a b : â„¤}, n âˆ£ b - a â†’ a â‰¡ b [ZMOD n]",
    "name": "Int.modEq_of_dvd",
    "isProp": true,
    "doc": "**Alias** of the reverse direction of `Int.modEq_iff_dvd`.",
    "depth": 11},
   {"type":
    "âˆ€ {p : â„•}, Nat.Prime p â†’ âˆ€ {n : â„¤}, IsCoprime n â†‘p â†’ n ^ (p - 1) â‰¡ 1 [ZMOD â†‘p]",
    "name": "Int.ModEq.pow_card_sub_one_eq_one",
    "isProp": true,
    "doc":
    "**Fermat's Little Theorem**: for all `a : â„¤` coprime to `p`, we have\n`a ^ (p - 1) â‰¡ 1 [ZMOD p]`. ",
    "depth": 13}],
  "count": 68},
 {"noDocExamples": [],
  "kind": "Â«term_â†’â‚—áµ¢[_]_Â»",
  "examples":
  [{"type":
    "âˆ€ {Î¹ : Type u_1} {ğ•œ : Type u_2} [inst : IsROrC ğ•œ] {E : Type u_3} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : InnerProductSpace ğ•œ E] [cplt : CompleteSpace E] {G : Î¹ â†’ Type u_4}\n  [inst_3 : (i : Î¹) â†’ NormedAddCommGroup (G i)] [inst_4 : (i : Î¹) â†’ InnerProductSpace ğ•œ (G i)]\n  {V : (i : Î¹) â†’ G i â†’â‚—áµ¢[ğ•œ] E} (hV : OrthogonalFamily ğ•œ G V) [inst_5 : âˆ€ (i : Î¹), CompleteSpace (G i)],\n  LinearMap.range (OrthogonalFamily.linearIsometry hV).toLinearMap =\n    Submodule.topologicalClosure (â¨† i, LinearMap.range (V i).toLinearMap)",
    "name": "OrthogonalFamily.range_linearIsometry",
    "isProp": true,
    "doc":
    "The canonical linear isometry from the `lp 2` of a mutually orthogonal family of subspaces of\n`E` into E, has range the closure of the span of the subspaces. ",
    "depth": 42},
   {"type": "{K : Type u_1} â†’ [inst : IsROrC K] â†’ â„ â†’â‚—áµ¢[â„] K",
    "name": "IsROrC.ofRealLi",
    "isProp": false,
    "doc": "The â„ â†’ K coercion, as a linear isometry ",
    "depth": 13},
   {"type":
    "{R : Type u_1} â†’\n  {E : Type u_5} â†’ [inst : Semiring R] â†’ [inst_1 : SeminormedAddCommGroup E] â†’ [inst_2 : Module R E] â†’ E â†’â‚—áµ¢[R] E",
    "name": "LinearIsometry.id",
    "isProp": false,
    "doc": "The identity linear isometry. ",
    "depth": 16}],
  "count": 66},
 {"noDocExamples":
  [{"type":
    "âˆ€ {Î± : Type u_2} [inst : LinearOrderedRing Î±] [inst_1 : FloorRing Î±] (a : Î±), âŒŠaâŒ‹ â‰¤ âŒˆaâŒ‰",
    "name": "Int.floor_le_ceil",
    "isProp": true,
    "depth": 10},
   {"type":
    "âˆ€ {Î± : Type u_2} [inst : LinearOrderedRing Î±] [inst_1 : FloorRing Î±] (a : Î±), âŒˆaâŒ‰ â‰¤ âŒŠaâŒ‹ + 1",
    "name": "Int.ceil_le_floor_add_one",
    "isProp": true,
    "depth": 11}],
  "kind": "Int.Â«termâŒˆ_âŒ‰Â»",
  "examples":
  [{"type":
    "âˆ€ {Î¾ q : â„š}, |Î¾ - q| < 1 / â†‘q.den ^ 2 â†’ q.den â‰¤ Î¾.den âˆ§ âŒˆÎ¾ * â†‘q.denâŒ‰ - 1 â‰¤ q.num âˆ§ q.num â‰¤ âŒŠÎ¾ * â†‘q.denâŒ‹ + 1",
    "name": "Rat.den_le_and_le_num_le_of_sub_lt_one_div_den_sq",
    "isProp": true,
    "doc":
    "If `Î¾` is rational, then the good rational approximations to `Î¾` have bounded\nnumerator and denominator. ",
    "depth": 17}],
  "count": 66},
 {"noDocExamples": [],
  "kind": "TopCat.Presheaf.Â«term__*_Â»",
  "examples":
  [{"type":
    "{C : Type u} â†’\n  [inst : CategoryTheory.Category.{v, u} C] â†’\n    {X : TopCat} â†’ (â„± : TopCat.Presheaf C X) â†’ CategoryTheory.CategoryStruct.id X _* â„± â‰… â„±",
    "name": "TopCat.Presheaf.Pushforward.id",
    "isProp": false,
    "doc":
    "The natural isomorphism between the pushforward of a presheaf along the identity continuous map\nand the original presheaf. ",
    "depth": 12},
   {"type":
    "âˆ€ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {X Y : TopCat} (f : X âŸ¶ Y) {F : TopCat.Presheaf C X},\n  TopCat.Presheaf.IsSheaf F â†’ TopCat.Presheaf.IsSheaf (f _* F)",
    "name": "TopCat.Sheaf.pushforward_sheaf_of_sheaf",
    "isProp": true,
    "doc": "The pushforward of a sheaf (by a continuous map) is a sheaf.\n",
    "depth": 14},
   {"type":
    "{C : Type u_1} â†’\n  [inst : CategoryTheory.Category.{u_2, u_1} C] â†’\n    {X Y : AlgebraicGeometry.PresheafedSpace C} â†’ (H : X â‰… Y) â†’ Y.presheaf â‰… H.hom.base _* X.presheaf",
    "name": "AlgebraicGeometry.PresheafedSpace.sheafIsoOfIso",
    "isProp": false,
    "doc":
    "Isomorphic `PresheafedSpace`s have naturally isomorphic presheaves. ",
    "depth": 16}],
  "count": 66},
 {"noDocExamples": [],
  "kind": "OmegaCompletePartialOrder.Â«term_â†’ğ’„_Â»",
  "examples":
  [{"type":
    "âˆ€ {Î± : Type u} {Î² : Type v} [inst : OmegaCompletePartialOrder Î±] [inst_1 : OmegaCompletePartialOrder Î²] (self : Î± â†’ğ’„ Î²),\n  OmegaCompletePartialOrder.Continuous self.toOrderHom",
    "name": "OmegaCompletePartialOrder.ContinuousHom.cont",
    "isProp": true,
    "doc":
    "The underlying function of a `ContinuousHom` is continuous, i.e. it preserves `Ï‰Sup` ",
    "depth": 11},
   {"type":
    "{Î± : Type u} â†’\n  {Î² : Type v} â†’\n    [inst : OmegaCompletePartialOrder Î±] â†’\n      [inst_1 : OmegaCompletePartialOrder Î²] â†’ OmegaCompletePartialOrder.Chain (Î± â†’ğ’„ Î²) â†’ Î± â†’ğ’„ Î²",
    "name": "OmegaCompletePartialOrder.ContinuousHom.Ï‰Sup",
    "isProp": false,
    "doc":
    "The `Ï‰Sup` operator for continuous functions, which takes the pointwise countable supremum\nof the functions in the `Ï‰`-chain. ",
    "depth": 12},
   {"type":
    "âˆ€ {Î± : Type u} {Î² : Type v} [inst : OmegaCompletePartialOrder Î±] [inst_1 : OmegaCompletePartialOrder Î²]\n  (câ‚€ : OmegaCompletePartialOrder.Chain (Î± â†’ğ’„ Î²)) (câ‚ : OmegaCompletePartialOrder.Chain Î±) (z : Î²),\n  (âˆ€ (i j : â„•), (câ‚€ i) (câ‚ j) â‰¤ z) â†” âˆ€ (i : â„•), (câ‚€ i) (câ‚ i) â‰¤ z",
    "name": "OmegaCompletePartialOrder.ContinuousHom.forall_forall_merge",
    "isProp": true,
    "doc":
    "When proving that a chain of applications is below a bound `z`, it suffices to consider the\nfunctions and values being selected from the same index in the chains.\n\nThis lemma is more specific than necessary, i.e. `câ‚€` only needs to be a\nchain of monotone functions, but it is only used with continuous functions. ",
    "depth": 32}],
  "count": 66},
 {"noDocExamples": [],
  "kind": "Lean.Parser.Term.do",
  "examples":
  [{"type":
    "âˆ€ (cf cg : Nat.Partrec.Code) (a k : â„•),\n  Nat.Partrec.Code.eval (Nat.Partrec.Code.prec cf cg) (Nat.pair a (Nat.succ k)) = do\n    let ih â† Nat.Partrec.Code.eval (Nat.Partrec.Code.prec cf cg) (Nat.pair a k)\n    Nat.Partrec.Code.eval cg (Nat.pair a (Nat.pair k ih))",
    "name": "Nat.Partrec.Code.eval_prec_succ",
    "isProp": true,
    "doc": "Helper lemma for the evaluation of `prec` in the recursive case. ",
    "depth": 12},
   {"type":
    "âˆ€ (m : Type u â†’ Type v) [inst : Monad m],\n  (âˆ€ {Î± : Type u} (x : m Î±), id <$> x = x) â†’\n    (âˆ€ {Î± Î² : Type u} (x : Î±) (f : Î± â†’ m Î²), pure x >>= f = f x) â†’\n      (âˆ€ {Î± Î² Î³ : Type u} (x : m Î±) (f : Î± â†’ m Î²) (g : Î² â†’ m Î³), x >>= f >>= g = x >>= fun x => f x >>= g) â†’\n        autoParam (âˆ€ {Î± Î² : Type u} (x : Î±) (y : m Î²), Functor.mapConst x y = Function.const Î² x <$> y) _autoâœ â†’\n          autoParam\n              (âˆ€ {Î± Î² : Type u} (x : m Î±) (y : m Î²),\n                (SeqLeft.seqLeft x fun x => y) = do\n                  let a â† x\n                  let _ â† y\n                  pure a)\n              _autoâœÂ¹ â†’\n            autoParam\n                (âˆ€ {Î± Î² : Type u} (x : m Î±) (y : m Î²),\n                  (SeqRight.seqRight x fun x => y) = do\n                    let _ â† x\n                    y)\n                _autoâœÂ² â†’\n              autoParam\n                  (âˆ€ {Î± Î² : Type u} (f : Î± â†’ Î²) (x : m Î±),\n                    (do\n                        let y â† x\n                        pure (f y)) =\n                      f <$> x)\n                  _autoâœÂ³ â†’\n                autoParam\n                    (âˆ€ {Î± Î² : Type u} (f : m (Î± â†’ Î²)) (x : m Î±),\n                      (do\n                          let x_1 â† f\n                          x_1 <$> x) =\n                        Seq.seq f fun x_1 => x)\n                    _autoâœâ´ â†’\n                  LawfulMonad m",
    "name": "LawfulMonad.mk'",
    "isProp": true,
    "doc":
    "An alternative constructor for `LawfulMonad` which has more\ndefaultable fields in the common case.\n",
    "depth": 28},
   {"type":
    "Bool â†’\n  List Lean.Expr â†’\n    optParam Linarith.LinarithConfig\n        {\n          discharger := do\n            let __do_lift â†\n              do\n                let info â† Lean.MonadRef.mkInfoFromRefPos\n                let _ â† Lean.getCurrMacroScope\n                let _ â† Lean.getMainModule\n                pure\n                    {\n                      raw :=\n                        Lean.Syntax.node2 info `Mathlib.Tactic.Ring.ring1 (Lean.Syntax.atom info \"ring1\")\n                          (Lean.Syntax.node info `null #[]) }\n            Lean.Elab.Tactic.evalTactic __do_lift.raw,\n          exfalso := true, transparency := Lean.Meta.TransparencyMode.reducible, splitHypotheses := true,\n          splitNe := false, preprocessors := none, oracle := none } â†’\n      Lean.MVarId â†’ Lean.MetaM Unit",
    "name": "Linarith.linarith",
    "isProp": false,
    "doc":
    "`linarith only_on hyps cfg` tries to close the goal using linear arithmetic. It fails\nif it does not succeed at doing this.\n\n* `hyps` is a list of proofs of comparisons to include in the search.\n* If `only_on` is true, the search will be restricted to `hyps`. Otherwise it will use all\n  comparisons in the local context.\n* If `cfg.transparency := semireducible`,\n  it will unfold semireducible definitions when trying to match atomic expressions.\n",
    "depth": 33}],
  "count": 64},
 {"noDocExamples": [],
  "kind": "Relator.Â«term_â‡’_Â»",
  "examples":
  [{"type":
    "{Î± : Sort u_1} â†’\n  {Î² : Sort u_2} â†’\n    {sâ‚ : Setoid Î±} â†’ {sâ‚‚ : Setoid Î²} â†’ (f : Î± â†’ Î²) â†’ (Setoid.r â‡’ Setoid.r) f f â†’ Quotient sâ‚ â†’ Quotient sâ‚‚",
    "name": "Quotient.map'",
    "isProp": false,
    "doc":
    "Map a function `f : Î± â†’ Î²` that sends equivalent elements to equivalent elements\nto a function `Quotient sa â†’ Quotient sb`. Useful to define unary operations on quotients. ",
    "depth": 14},
   {"type":
    "{Î± : Sort u_1} â†’\n  {Î² : Sort u_2} â†’ {ra : Î± â†’ Î± â†’ Prop} â†’ {rb : Î² â†’ Î² â†’ Prop} â†’ (f : Î± â†’ Î²) â†’ (ra â‡’ rb) f f â†’ Quot ra â†’ Quot rb",
    "name": "Quot.map",
    "isProp": false,
    "doc":
    "Map a function `f : Î± â†’ Î²` such that `ra x y` implies `rb (f x) (f y)`\nto a map `Quot ra â†’ Quot rb`. ",
    "depth": 14},
   {"type":
    "{Î± : Type u_1} â†’\n  {Î² : Type u_2} â†’\n    {l : Filter Î±} â†’\n      {Î³ : Sort u_5} â†’ Filter.Germ l Î² â†’ (F : (Î± â†’ Î²) â†’ Î³) â†’ (Filter.EventuallyEq l â‡’ fun x x_1 => x = x_1) F F â†’ Î³",
    "name": "Filter.Germ.liftOn",
    "isProp": false,
    "doc":
    "Given a germ `f : Germ l Î²` and a function `F : (Î± â†’ Î²) â†’ Î³` sending eventually equal functions\nto the same value, returns the value `F` takes on functions having germ `f` at `l`. ",
    "depth": 16}],
  "count": 64},
 {"noDocExamples": [],
  "kind": "Â«termï¿¢_Â»",
  "examples":
  [{"type":
    "âˆ€ {Î± : Type u_2} [inst : CoheytingAlgebra Î±] {a b : Î±}, Codisjoint b a â†’ ï¿¢a â‰¤ b",
    "name": "Codisjoint.hnot_le_left",
    "isProp": true,
    "doc":
    "**Alias** of the reverse direction of `hnot_le_iff_codisjoint_left`.",
    "depth": 15},
   {"type":
    "âˆ€ {Î± : Type u_2} [inst : CoheytingAlgebra Î±] {a b : Î±}, Codisjoint a b â†’ ï¿¢a â‰¤ b",
    "name": "Codisjoint.hnot_le_right",
    "isProp": true,
    "doc":
    "**Alias** of the reverse direction of `hnot_le_iff_codisjoint_right`.",
    "depth": 15},
   {"type": "âˆ€ {Î± : Type u_4} [self : CoheytingAlgebra Î±] (a : Î±), âŠ¤ \\ a = ï¿¢a",
    "name": "CoheytingAlgebra.top_sdiff",
    "isProp": true,
    "doc": "`âŠ¤ \\ a` is `ï¿¢a` ",
    "depth": 17}],
  "count": 63},
 {"noDocExamples": [],
  "kind": "Â«term_&&_Â»",
  "examples":
  [{"type": "âˆ€ (x y : Bool), (!(x && y)) = (!x || !y)",
    "name": "Bool.not_and",
    "isProp": true,
    "doc": "De Morgan's law for boolean and ",
    "depth": 7},
   {"type": "âˆ€ (x y : Bool), (!(x || y)) = (!x && !y)",
    "name": "Bool.not_or",
    "isProp": true,
    "doc": "De Morgan's law for boolean or ",
    "depth": 7},
   {"type":
    "âˆ€ {m x y : Bool}, (x && m) = (y && m) âˆ§ (x || m) = (y || m) â†” x = y",
    "name": "Bool.and_or_inj_right'",
    "isProp": true,
    "doc": "**Alias** of `Bool.and_or_inj_right_iff`.",
    "depth": 11}],
  "count": 63},
 {"noDocExamples":
  [{"type":
    "âˆ€ (n : â„•), Nat.div2 (Nat.succ n) = bif Nat.bodd n then Nat.succ (Nat.div2 n) else Nat.div2 n",
    "name": "Nat.div2_succ",
    "isProp": true,
    "depth": 6},
   {"type": "âˆ€ {Î± : Type u} (b : Bool) (a : Î±), (bif b then a else a) = a",
    "name": "Bool.cond_self",
    "isProp": true,
    "depth": 9}],
  "kind": "boolIfThenElse",
  "examples":
  [{"type":
    "âˆ€ (p : ENNReal) (h : p â‰¤ 1), PMF.binomial p h 1 = PMF.map (fun x => bif x then 1 else 0) (PMF.bernoulli p h)",
    "name": "PMF.binomial_one_eq_bernoulli",
    "isProp": true,
    "doc":
    "The binomial distribution on one coin is the bernoully distribution. ",
    "depth": 18}],
  "count": 63},
 {"noDocExamples": [],
  "kind": "Â«term_â†’â‚›â‚—áµ¢[_]_Â»",
  "examples":
  [{"type":
    "{R : Type u_1} â†’\n  {Râ‚‚ : Type u_2} â†’\n    {E : Type u_5} â†’\n      {Eâ‚‚ : Type u_6} â†’\n        [inst : Semiring R] â†’\n          [inst_1 : Semiring Râ‚‚] â†’\n            {Ïƒâ‚â‚‚ : R â†’+* Râ‚‚} â†’\n              [inst_2 : SeminormedAddCommGroup E] â†’\n                [inst_3 : SeminormedAddCommGroup Eâ‚‚] â†’\n                  [inst_4 : Module R E] â†’ [inst_5 : Module Râ‚‚ Eâ‚‚] â†’ (f : E â†’â‚›â‚—[Ïƒâ‚â‚‚] Eâ‚‚) â†’ Isometry â‡‘f â†’ E â†’â‚›â‚—áµ¢[Ïƒâ‚â‚‚] Eâ‚‚",
    "name": "LinearMap.toLinearIsometry",
    "isProp": false,
    "doc":
    "Construct a `LinearIsometry` from a `LinearMap` satisfying `Isometry`. ",
    "depth": 30},
   {"type":
    "âˆ€ {R : Type u_1} {Râ‚‚ : Type u_2} {E : Type u_5} {Eâ‚‚ : Type u_6} [inst : Semiring R] [inst_1 : Semiring Râ‚‚]\n  {Ïƒâ‚â‚‚ : R â†’+* Râ‚‚} [inst_2 : SeminormedAddCommGroup E] [inst_3 : SeminormedAddCommGroup Eâ‚‚] [inst_4 : Module R E]\n  [inst_5 : Module Râ‚‚ Eâ‚‚] {Î¹ : Type u_11} (b : Basis Î¹ R E) {fâ‚ fâ‚‚ : E â†’â‚›â‚—áµ¢[Ïƒâ‚â‚‚] Eâ‚‚},\n  (âˆ€ (i : Î¹), fâ‚ (b i) = fâ‚‚ (b i)) â†’ fâ‚ = fâ‚‚",
    "name": "Basis.ext_linearIsometry",
    "isProp": true,
    "doc":
    "Two linear isometries are equal if they are equal on basis vectors. ",
    "depth": 49},
   {"type":
    "{R : Type u_1} â†’\n  {Râ‚‚ : Type u_2} â†’\n    [inst : Semiring R] â†’\n      [inst_1 : Semiring Râ‚‚] â†’\n        (Ïƒâ‚â‚‚ : R â†’+* Râ‚‚) â†’\n          (E : Type u_11) â†’\n            (Eâ‚‚ : Type u_12) â†’\n              [inst_2 : SeminormedAddCommGroup E] â†’\n                [inst_3 : SeminormedAddCommGroup Eâ‚‚] â†’\n                  [inst_4 : Module R E] â†’ [inst_5 : Module Râ‚‚ Eâ‚‚] â†’ (E â†’â‚›â‚—áµ¢[Ïƒâ‚â‚‚] Eâ‚‚) â†’ E â†’ Eâ‚‚",
    "name": "LinearIsometry.Simps.apply",
    "isProp": false,
    "doc":
    "See Note [custom simps projection]. We need to specify this projection explicitly in this case,\nbecause it is a composition of multiple projections. ",
    "depth": 23}],
  "count": 61},
 {"noDocExamples": [],
  "kind": "Â«term_â‰ºi_Â»",
  "examples":
  [{"type": "EmptyRelation â‰ºi EmptyRelation",
    "name": "PrincipalSeg.pemptyToPunit",
    "isProp": false,
    "doc":
    "Principal segment from the empty relation on `PEmpty` to the empty relation on `PUnit`. ",
    "depth": 4},
   {"type":
    "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {r : Î± â†’ Î± â†’ Prop} {s : Î² â†’ Î² â†’ Prop} [inst : IsWellOrder Î² s], Subsingleton (r â‰ºi s)",
    "name": "PrincipalSeg.instSubsingletonPrincipalSeg",
    "isProp": true,
    "doc":
    "Given a well order `s`, there is a most one principal segment embedding of `r` into `s`. ",
    "depth": 10},
   {"type":
    "{Î± Î² : Ordinal.{u_3}} â†’ Î± < Î² â†’ (fun x x_1 => x < x_1) â‰ºi fun x x_1 => x < x_1",
    "name": "Ordinal.principalSegOut",
    "isProp": false,
    "doc":
    "Given two ordinals `Î± < Î²`, then `principalSegOut Î± Î²` is the principal segment embedding\nof `Î±` to `Î²`, as map from a model type for `Î±` to a model type for `Î²`. ",
    "depth": 21}],
  "count": 60},
 {"noDocExamples": [],
  "kind": "AlgebraicGeometry.Â«term_â»Â¹áµ_Â»",
  "examples":
  [{"type":
    "{X Y : AlgebraicGeometry.Scheme} â†’\n  (f : X âŸ¶ Y) â†’ (U : TopologicalSpace.Opens â†‘â†‘Y.toPresheafedSpace) â†’ X âˆ£_áµ¤ fâ»Â¹áµ U âŸ¶ Y âˆ£_áµ¤ U",
    "name": "AlgebraicGeometry.morphismRestrict",
    "isProp": false,
    "doc":
    "The restriction of a morphism `X âŸ¶ Y` onto `X |_{f â»Â¹ U} âŸ¶ Y |_ U`. ",
    "depth": 30},
   {"type":
    "{X Y : AlgebraicGeometry.Scheme} â†’\n  (f : X âŸ¶ Y) â†’\n    [inst : CategoryTheory.IsIso f] â†’ (U : TopologicalSpace.Opens â†‘â†‘Y.toPresheafedSpace) â†’ X âˆ£_áµ¤ fâ»Â¹áµ U â‰… Y âˆ£_áµ¤ U",
    "name": "AlgebraicGeometry.Scheme.restrictMapIso",
    "isProp": false,
    "doc": "The restriction of an isomorphism onto an open set. ",
    "depth": 31},
   {"type":
    "{X Y : AlgebraicGeometry.Scheme} â†’\n  (f : X âŸ¶ Y) â†’\n    (U : TopologicalSpace.Opens â†‘â†‘Y.toPresheafedSpace) â†’\n      CategoryTheory.Limits.pullback f (AlgebraicGeometry.Scheme.Î¹Opens U) â‰… X âˆ£_áµ¤ fâ»Â¹áµ U",
    "name": "AlgebraicGeometry.pullbackRestrictIsoRestrict",
    "isProp": false,
    "doc":
    "Given a morphism `f : X âŸ¶ Y` and an open set `U âŠ† Y`, we have `X Ã—[Y] U â‰… X |_{f â»Â¹ U}` ",
    "depth": 36}],
  "count": 60},
 {"noDocExamples":
  [{"type":
    "âˆ€ {M : Type u_1} [inst : Add Máµƒáµ’áµ–] [inst_1 : IsRightCancelAdd Máµƒáµ’áµ–], IsRightCancelAdd Máµˆáµƒáµƒ",
    "name": "DomAddAct.instIsAddRightCancelDomAddActInstAddDomAddAct",
    "isProp": true,
    "depth": 6},
   {"type":
    "âˆ€ {M : Type u_1} [inst : Neg M] (a : Máµˆáµƒáµƒ), DomAddAct.mk.symm (-a) = -DomAddAct.mk.symm a",
    "name": "DomAddAct.symm_mk_neg",
    "isProp": true,
    "depth": 14}],
  "kind": "Â«term_áµˆáµƒáµƒÂ»",
  "examples":
  [{"type": "{M : Type u_1} â†’ M â‰ƒ Máµˆáµƒáµƒ",
    "name": "DomAddAct.mk",
    "isProp": false,
    "doc": "Equivalence between `M` and `Máµˆáµáµƒ`.",
    "depth": 3}],
  "count": 60},
 {"noDocExamples": [],
  "kind": "Â«term_â‰ƒ._Â»",
  "examples":
  [{"type": "(Î± : Type u_1) â†’ Î± â‰ƒ. Î±",
    "name": "PEquiv.refl",
    "isProp": false,
    "doc": "The identity map as a partial equivalence. ",
    "depth": 3},
   {"type": "{Î± : Type u} â†’ {Î² : Type v} â†’ (Î± â‰ƒ. Î²) â†’ Î² â‰ƒ. Î±",
    "name": "PEquiv.symm",
    "isProp": false,
    "doc": "The inverse partial equivalence. ",
    "depth": 5},
   {"type": "{Î± : Type u} â†’ {Î² : Type v} â†’ (Î± â‰ƒ. Î²) â†’ Î² â†’ Option Î±",
    "name": "PEquiv.invFun",
    "isProp": false,
    "doc": "The partial inverse of `toFun` ",
    "depth": 5}],
  "count": 59},
 {"noDocExamples": [],
  "kind": "MeasureTheory.Â«termâˆ«_In_,_Â»",
  "examples":
  [{"type":
    "âˆ€ {s : â„‚},\n  0 < s.re â†’\n    HasDerivAt Complex.GammaIntegral (âˆ« (t : â„) in Set.Ioi 0, â†‘t ^ (s - 1) * (â†‘(Real.log t) * â†‘(Real.exp (-t)))) s",
    "name": "Complex.hasDerivAt_GammaIntegral",
    "isProp": true,
    "doc":
    "The derivative of the `Î“` integral, at any `s âˆˆ â„‚` with `1 < re s`, is given by the Melllin\ntransform of `log t * exp (-t)`. ",
    "depth": 15},
   {"type":
    "âˆ€ {a b : â„} (n : â„•), âˆ« (x : â„) in Î™ a b, |x - a| ^ n = |b - a| ^ (n + 1) / (â†‘n + 1)",
    "name": "integral_pow_abs_sub_uIoc",
    "isProp": true,
    "doc":
    "Integral of `|x - a| ^ n` over `Î™ a b`. This integral appears in the proof of the\nPicard-LindelÃ¶f/Cauchy-Lipschitz theorem. ",
    "depth": 16},
   {"type":
    "âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] {Î¼ : MeasureTheory.Measure Î±} {f : Î± â†’ â„},\n  MeasureTheory.Integrable f â†’\n    0 â‰¤á¶ [MeasureTheory.Measure.ae Î¼] f â†’ âˆ« (Ï‰ : Î±), f Ï‰ âˆ‚Î¼ = âˆ« (t : â„) in Set.Ioi 0, ENNReal.toReal (â†‘â†‘Î¼ {a | t < f a})",
    "name": "MeasureTheory.Integrable.integral_eq_integral_meas_lt",
    "isProp": true,
    "doc":
    "The standard case of the layer cake formula / Cavalieri's principle / tail probability formula:\n\nFor an integrable a.e.-nonnegative real-valued function `f`, the Bochner integral of `f` can be\nwritten (roughly speaking) as: `âˆ« f âˆ‚Î¼ = âˆ« t in 0..âˆ, Î¼ {Ï‰ | f(Ï‰) > t}`.\n\nSee `lintegral_eq_lintegral_meas_lt` for a version with Lebesgue integral `âˆ«â»` instead. ",
    "depth": 17}],
  "count": 58},
 {"noDocExamples": [],
  "kind": "Set.termÎ™",
  "examples":
  [{"type":
    "âˆ€ {E : Type u_3} [inst : NormedAddCommGroup E] {f : â„ â†’ E} {a b : â„} {Î¼ : MeasureTheory.Measure â„},\n  IntervalIntegrable f Î¼ a b â†’ MeasureTheory.IntegrableOn f (Î™ a b)",
    "name": "IntervalIntegrable.def",
    "isProp": true,
    "doc":
    "If a function is interval integrable with respect to a given measure `Î¼` on `a..b` then\nit is integrable on `uIoc a b` with respect to `Î¼`. ",
    "depth": 14},
   {"type":
    "âˆ€ {E : Type u_3} [inst : NormedAddCommGroup E] {f : â„ â†’ E} {a b : â„} {Î¼ : MeasureTheory.Measure â„},\n  IntervalIntegrable f Î¼ a b â†” MeasureTheory.IntegrableOn f (Î™ a b)",
    "name": "intervalIntegrable_iff",
    "isProp": true,
    "doc":
    "A function is interval integrable with respect to a given measure `Î¼` on `a..b` if and\nonly if it is integrable on `uIoc a b` with respect to `Î¼`. This is an equivalent\ndefinition of `IntervalIntegrable`. ",
    "depth": 14},
   {"type":
    "âˆ€ {a b : â„} (n : â„•), âˆ« (x : â„) in Î™ a b, |x - a| ^ n = |b - a| ^ (n + 1) / (â†‘n + 1)",
    "name": "integral_pow_abs_sub_uIoc",
    "isProp": true,
    "doc":
    "Integral of `|x - a| ^ n` over `Î™ a b`. This integral appears in the proof of the\nPicard-LindelÃ¶f/Cauchy-Lipschitz theorem. ",
    "depth": 16}],
  "count": 58},
 {"noDocExamples": [],
  "kind": "Â«term_â‰ƒáµˆ_Â»",
  "examples":
  [{"type": "(X : Type u_4) â†’ [inst : PseudoEMetricSpace X] â†’ X â‰ƒáµˆ X",
    "name": "DilationEquiv.refl",
    "isProp": false,
    "doc": "Identity map as a `DilationEquiv`. ",
    "depth": 6},
   {"type":
    "{X : Type u_1} â†’ {Y : Type u_2} â†’ [inst : PseudoEMetricSpace X] â†’ [inst_1 : PseudoEMetricSpace Y] â†’ X â‰ƒáµˆ Y â†’ Y â‰ƒáµˆ X",
    "name": "DilationEquiv.symm",
    "isProp": false,
    "doc": "Inverse `DilationEquiv`. ",
    "depth": 9},
   {"type":
    "{X : Type u_1} â†’ {Y : Type u_2} â†’ [inst : PseudoEMetricSpace X] â†’ [inst_1 : PseudoEMetricSpace Y] â†’ X â‰ƒáµˆ Y â†’ Y â†’ X",
    "name": "DilationEquiv.Simps.symm_apply",
    "isProp": false,
    "doc": "See Note [custom simps projection]. ",
    "depth": 9}],
  "count": 57},
 {"noDocExamples": [],
  "kind": "Vector.Â«term_::áµ¥_Â»",
  "examples":
  [{"type":
    "âˆ€ {Î± : Type u} {n : â„•} (a : Î±) (v : Vector Î± n), Vector.toList (a ::áµ¥ v) = a :: Vector.toList v",
    "name": "Vector.toList_cons",
    "isProp": true,
    "doc":
    "`toList` of `cons` of a vector and an element is\nthe `cons` of the list obtained by `toList` and the element ",
    "depth": 11},
   {"type":
    "âˆ€ {Î± : Type u} {n : â„•} (a : Î±) (v : Vector Î± n), Vector.head (a ::áµ¥ v) = a",
    "name": "Vector.head_cons",
    "isProp": true,
    "doc":
    "The head of a vector obtained by prepending is the element prepended. ",
    "depth": 11},
   {"type":
    "âˆ€ {Î± : Type u_1} {ix : Fin 1} (x : Î±), Vector.get (x ::áµ¥ Vector.nil) ix = x",
    "name": "Vector.get_cons_nil",
    "isProp": true,
    "doc":
    "Accessing the nth element of a vector made up\nof one element `x : Î±` is `x` itself. ",
    "depth": 13}],
  "count": 57},
 {"noDocExamples": [],
  "kind": "Â«FreimanHomLocalâ‰ºÂ»",
  "examples":
  [{"type":
    "{Î± : Type u_2} â†’ [inst : CommMonoid Î±] â†’ (A : Set Î±) â†’ (n : â„•) â†’ A â†’*[n] Î±",
    "name": "FreimanHom.id",
    "isProp": false,
    "doc": "The identity map from a commutative monoid to itself. ",
    "depth": 10},
   {"type":
    "{Î± : Type u_2} â†’\n  {Î² : Type u_3} â†’ [inst : CommMonoid Î±] â†’ [inst_1 : CommMonoid Î²] â†’ {A : Set Î±} â†’ {n : â„•} â†’ CommMonoid (A â†’*[n] Î²)",
    "name": "FreimanHom.commMonoid",
    "isProp": false,
    "doc": "`A â†’*[n] Î²` is a `CommMonoid`. ",
    "depth": 13},
   {"type":
    "{Î± : Type u_2} â†’\n  {Î² : Type u_3} â†’ [inst : CommMonoid Î±] â†’ [inst_1 : CommMonoid Î²] â†’ {A : Set Î±} â†’ {n : â„•} â†’ Mul (A â†’*[n] Î²)",
    "name": "FreimanHom.instMulFreimanHom",
    "isProp": false,
    "doc": "`f * g` is the Freiman homomorphism sends `x` to `f x * g x`. ",
    "depth": 13}],
  "count": 57},
 {"noDocExamples": [],
  "kind": "Â«term_â‰ƒâ‚›â‚—áµ¢[_]_Â»",
  "examples":
  [{"type":
    "{R : Type u_1} â†’\n  {Râ‚‚ : Type u_2} â†’\n    {E : Type u_5} â†’\n      {Eâ‚‚ : Type u_6} â†’\n        [inst : Semiring R] â†’\n          [inst_1 : Semiring Râ‚‚] â†’\n            {Ïƒâ‚â‚‚ : R â†’+* Râ‚‚} â†’\n              {Ïƒâ‚‚â‚ : Râ‚‚ â†’+* R} â†’\n                [inst_2 : RingHomInvPair Ïƒâ‚â‚‚ Ïƒâ‚‚â‚] â†’\n                  [inst_3 : RingHomInvPair Ïƒâ‚‚â‚ Ïƒâ‚â‚‚] â†’\n                    [inst_4 : SeminormedAddCommGroup E] â†’\n                      [inst_5 : SeminormedAddCommGroup Eâ‚‚] â†’\n                        [inst_6 : Module R E] â†’ [inst_7 : Module Râ‚‚ Eâ‚‚] â†’ (E â‰ƒâ‚›â‚—áµ¢[Ïƒâ‚â‚‚] Eâ‚‚) â†’ Eâ‚‚ â‰ƒâ‚›â‚—áµ¢[Ïƒâ‚‚â‚] E",
    "name": "LinearIsometryEquiv.symm",
    "isProp": false,
    "doc": "The inverse `LinearIsometryEquiv`. ",
    "depth": 29},
   {"type":
    "{R : Type u_1} â†’\n  {Râ‚‚ : Type u_2} â†’\n    [inst : Semiring R] â†’\n      [inst_1 : Semiring Râ‚‚] â†’\n        (Ïƒâ‚â‚‚ : R â†’+* Râ‚‚) â†’\n          {Ïƒâ‚‚â‚ : Râ‚‚ â†’+* R} â†’\n            [inst_2 : RingHomInvPair Ïƒâ‚â‚‚ Ïƒâ‚‚â‚] â†’\n              [inst_3 : RingHomInvPair Ïƒâ‚‚â‚ Ïƒâ‚â‚‚] â†’\n                (E : Type u_11) â†’\n                  (Eâ‚‚ : Type u_12) â†’\n                    [inst_4 : SeminormedAddCommGroup E] â†’\n                      [inst_5 : SeminormedAddCommGroup Eâ‚‚] â†’\n                        [inst_6 : Module R E] â†’ [inst_7 : Module Râ‚‚ Eâ‚‚] â†’ (E â‰ƒâ‚›â‚—áµ¢[Ïƒâ‚â‚‚] Eâ‚‚) â†’ Eâ‚‚ â†’ E",
    "name": "LinearIsometryEquiv.Simps.symm_apply",
    "isProp": false,
    "doc": "See Note [custom simps projection] ",
    "depth": 29},
   {"type":
    "{R : Type u_1} â†’\n  {Râ‚‚ : Type u_2} â†’\n    {E : Type u_5} â†’\n      {Eâ‚‚ : Type u_6} â†’\n        [inst : Semiring R] â†’\n          [inst_1 : Semiring Râ‚‚] â†’\n            {Ïƒâ‚â‚‚ : R â†’+* Râ‚‚} â†’\n              {Ïƒâ‚‚â‚ : Râ‚‚ â†’+* R} â†’\n                [inst_2 : RingHomInvPair Ïƒâ‚â‚‚ Ïƒâ‚‚â‚] â†’\n                  [inst_3 : RingHomInvPair Ïƒâ‚‚â‚ Ïƒâ‚â‚‚] â†’\n                    [inst_4 : SeminormedAddCommGroup E] â†’\n                      [inst_5 : SeminormedAddCommGroup Eâ‚‚] â†’\n                        [inst_6 : Module R E] â†’ [inst_7 : Module Râ‚‚ Eâ‚‚] â†’ (E â‰ƒâ‚›â‚—áµ¢[Ïƒâ‚â‚‚] Eâ‚‚) â†’ E â†’â‚›â‚—áµ¢[Ïƒâ‚â‚‚] Eâ‚‚",
    "name": "LinearIsometryEquiv.toLinearIsometry",
    "isProp": false,
    "doc": "Reinterpret a `LinearIsometryEquiv` as a `LinearIsometry`. ",
    "depth": 29}],
  "count": 57},
 {"noDocExamples": [],
  "kind": "Â«AddFreimanHomLocalâ‰ºÂ»",
  "examples":
  [{"type":
    "{Î± : Type u_2} â†’ [inst : AddCommMonoid Î±] â†’ (A : Set Î±) â†’ (n : â„•) â†’ A â†’+[n] Î±",
    "name": "AddFreimanHom.id",
    "isProp": false,
    "doc": "The identity map from an additive commutative monoid to itself.",
    "depth": 10},
   {"type":
    "{Î± : Type u_2} â†’\n  {G : Type u_6} â†’ [inst : AddCommMonoid Î±] â†’ [inst_1 : AddCommGroup G] â†’ {A : Set Î±} â†’ {n : â„•} â†’ Sub (A â†’+[n] G)",
    "name": "AddFreimanHom.instSubFreimanHomToAddCommMonoid",
    "isProp": false,
    "doc":
    "If `f` and `g` are additive Freiman homomorphisms to an additive commutative group,\nthen `f - g` is the additive Freiman homomorphism sending `x` to `f x - g x`",
    "depth": 13},
   {"type":
    "{Î± : Type u_2} â†’\n  {Î² : Type u_3} â†’ [inst : AddCommMonoid Î±] â†’ [inst_1 : AddCommMonoid Î²] â†’ {A : Set Î±} â†’ {n : â„•} â†’ Zero (A â†’+[n] Î²)",
    "name": "AddFreimanHom.instZeroFreimanHom",
    "isProp": false,
    "doc": "`0` is the Freiman homomorphism sending everything to `0`.",
    "depth": 13}],
  "count": 56},
 {"noDocExamples": [],
  "kind": "Â«term_â‰¼i_Â»",
  "examples":
  [{"type": "{Î± : Type u_1} â†’ (r : Î± â†’ Î± â†’ Prop) â†’ r â‰¼i r",
    "name": "InitialSeg.refl",
    "isProp": false,
    "doc": "The identity function shows that `â‰¼i` is reflexive ",
    "depth": 6},
   {"type":
    "{Î± : Type u_1} â†’ {Î² : Type u_2} â†’ {r : Î± â†’ Î± â†’ Prop} â†’ {s : Î² â†’ Î² â†’ Prop} â†’ r â‰ƒr s â†’ r â‰¼i s",
    "name": "InitialSeg.ofIso",
    "isProp": false,
    "doc": "An order isomorphism is an initial segment ",
    "depth": 9},
   {"type": "(fun x x_1 => x < x_1) â‰¼i fun x x_1 => x < x_1",
    "name": "Cardinal.alephIdx.initialSeg",
    "isProp": false,
    "doc":
    "The `aleph'` index function, which gives the ordinal index of a cardinal.\n(The `aleph'` part is because unlike `aleph` this counts also the\nfinite stages. So `alephIdx n = n`, `alephIdx Ï‰ = Ï‰`,\n`alephIdx â„µâ‚ = Ï‰ + 1` and so on.)\nIn this definition, we register additionally that this function is an initial segment,\ni.e., it is order preserving and its range is an initial segment of the ordinals.\nFor the basic function version, see `alephIdx`.\nFor an upgraded version stating that the range is everything, see `AlephIdx.rel_iso`. ",
    "depth": 10}],
  "count": 55},
 {"noDocExamples": [],
  "kind": "MeasureTheory.Â«termâˆ«_,_Â»",
  "examples":
  [{"type":
    "âˆ€ (Î¼ : â„) {v : NNReal}, v â‰  0 â†’ âˆ« (x : â„), ProbabilityTheory.gaussianPdfReal Î¼ v x = 1",
    "name": "ProbabilityTheory.integral_gaussianPdfReal_eq_one",
    "isProp": true,
    "doc":
    "The gaussian distribution pdf integrates to 1 when the variance is not zero.  ",
    "depth": 14},
   {"type":
    "âˆ€ {b : â„‚}, 0 < b.re â†’ (âˆ« (x : â„), Complex.exp (-b * â†‘x ^ 2)) ^ 2 = â†‘Real.pi / b",
    "name": "integral_gaussian_sq_complex",
    "isProp": true,
    "doc":
    "The *square* of the Gaussian integral `âˆ« x:â„, exp (-b * x^2)` is equal to `Ï€ / b`. ",
    "depth": 18},
   {"type":
    "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] (t : â„) (f : UnitAddCircle â†’ E),\n  âˆ« (a : â„) in Set.Ioc t (t + 1), f â†‘a = âˆ« (b : UnitAddCircle), f b",
    "name": "UnitAddCircle.integral_preimage",
    "isProp": true,
    "doc":
    "The integral of an almost-everywhere strongly measurable function over `UnitAddCircle` is\nequal to the integral over an interval (t, t + 1] in `â„` of its lift to `â„`. ",
    "depth": 18}],
  "count": 55},
 {"noDocExamples": [],
  "kind": "Â«term_â†’+*o_Â»",
  "examples":
  [{"type":
    "{Î± : Type u_6} â†’\n  {Î² : Type u_7} â†’\n    [inst : NonAssocSemiring Î±] â†’\n      [inst_1 : Preorder Î±] â†’ [inst_2 : NonAssocSemiring Î²] â†’ [inst_3 : Preorder Î²] â†’ Î± â†’+*o Î² â†’ Î± â†’+* Î²",
    "name": "OrderRingHom.toRingHom",
    "isProp": false,
    "doc": "Reinterpret an ordered ring homomorphism as a ring homomorphism. ",
    "depth": 13},
   {"type":
    "{Î± : Type u_2} â†’\n  {Î² : Type u_3} â†’\n    [inst : NonAssocSemiring Î±] â†’\n      [inst_1 : Preorder Î±] â†’ [inst_2 : NonAssocSemiring Î²] â†’ [inst_3 : Preorder Î²] â†’ Î± â†’+*o Î² â†’ Î± â†’*â‚€o Î²",
    "name": "OrderRingHom.toOrderMonoidWithZeroHom",
    "isProp": false,
    "doc":
    "Reinterpret an ordered ring homomorphism as an order homomorphism. ",
    "depth": 13},
   {"type":
    "{Î± : Type u_2} â†’\n  {Î² : Type u_3} â†’\n    [inst : NonAssocSemiring Î±] â†’\n      [inst_1 : Preorder Î±] â†’ [inst_2 : NonAssocSemiring Î²] â†’ [inst_3 : Preorder Î²] â†’ Î± â†’+*o Î² â†’ Î± â†’+o Î²",
    "name": "OrderRingHom.toOrderAddMonoidHom",
    "isProp": false,
    "doc":
    "Reinterpret an ordered ring homomorphism as an ordered additive monoid homomorphism. ",
    "depth": 14}],
  "count": 52},
 {"noDocExamples": [],
  "kind": "Â«term_â†’áµƒâ±[_]_Â»",
  "examples":
  [{"type":
    "{ğ•œ : Type u_1} â†’\n  {V : Type u_2} â†’\n    {P : Type u_8} â†’\n      [inst : NormedField ğ•œ] â†’\n        [inst_1 : SeminormedAddCommGroup V] â†’\n          [inst_2 : NormedSpace ğ•œ V] â†’ [inst_3 : PseudoMetricSpace P] â†’ [inst_4 : NormedAddTorsor V P] â†’ P â†’áµƒâ±[ğ•œ] P",
    "name": "AffineIsometry.id",
    "isProp": false,
    "doc": "The identity affine isometry. ",
    "depth": 22},
   {"type":
    "{ğ•œ : Type u_1} â†’\n  {V : Type u_2} â†’\n    {Vâ‚‚ : Type u_4} â†’\n      [inst : NormedField ğ•œ] â†’\n        [inst_1 : SeminormedAddCommGroup V] â†’\n          [inst_2 : SeminormedAddCommGroup Vâ‚‚] â†’\n            [inst_3 : NormedSpace ğ•œ V] â†’ [inst_4 : NormedSpace ğ•œ Vâ‚‚] â†’ (V â†’â‚—áµ¢[ğ•œ] Vâ‚‚) â†’ V â†’áµƒâ±[ğ•œ] Vâ‚‚",
    "name": "LinearIsometry.toAffineIsometry",
    "isProp": false,
    "doc": "Reinterpret a linear isometry as an affine isometry. ",
    "depth": 23},
   {"type":
    "{ğ•œ : Type u_1} â†’\n  {V : Type u_2} â†’\n    {Vâ‚‚ : Type u_4} â†’\n      {P : Type u_8} â†’\n        {Pâ‚‚ : Type u_9} â†’\n          [inst : NormedField ğ•œ] â†’\n            [inst_1 : SeminormedAddCommGroup V] â†’\n              [inst_2 : SeminormedAddCommGroup Vâ‚‚] â†’\n                [inst_3 : NormedSpace ğ•œ V] â†’\n                  [inst_4 : NormedSpace ğ•œ Vâ‚‚] â†’\n                    [inst_5 : PseudoMetricSpace P] â†’\n                      [inst_6 : PseudoMetricSpace Pâ‚‚] â†’\n                        [inst_7 : NormedAddTorsor V P] â†’ [inst_8 : NormedAddTorsor Vâ‚‚ Pâ‚‚] â†’ (P â‰ƒáµƒâ±[ğ•œ] Pâ‚‚) â†’ P â†’áµƒâ±[ğ•œ] Pâ‚‚",
    "name": "AffineIsometryEquiv.toAffineIsometry",
    "isProp": false,
    "doc": "Reinterpret an `AffineIsometryEquiv` as an `AffineIsometry`. ",
    "depth": 29}],
  "count": 51},
 {"noDocExamples": [],
  "kind": "Â«term_â‰ƒâ‚—â…_,_â†_Â»",
  "examples":
  [{"type":
    "{R : Type u} â†’\n  {L : Type v} â†’\n    {M : Type w} â†’\n      [inst : CommRing R] â†’\n        [inst_1 : LieRing L] â†’\n          [inst_2 : AddCommGroup M] â†’ [inst_3 : Module R M] â†’ [inst_4 : LieRingModule L M] â†’ M â‰ƒâ‚—â…R,Lâ† M",
    "name": "LieModuleEquiv.refl",
    "isProp": false,
    "doc": "Lie module equivalences are reflexive. ",
    "depth": 20},
   {"type":
    "{R : Type u} â†’\n  {L : Type v} â†’\n    {M : Type w} â†’\n      {N : Type wâ‚} â†’\n        [inst : CommRing R] â†’\n          [inst_1 : LieRing L] â†’\n            [inst_2 : AddCommGroup M] â†’\n              [inst_3 : AddCommGroup N] â†’\n                [inst_4 : Module R M] â†’\n                  [inst_5 : Module R N] â†’\n                    [inst_6 : LieRingModule L M] â†’ [inst_7 : LieRingModule L N] â†’ (M â‰ƒâ‚—â…R,Lâ† N) â†’ M â‰ƒ N",
    "name": "LieModuleEquiv.toEquiv",
    "isProp": false,
    "doc": "View an equivalence of Lie modules as a type level equivalence. ",
    "depth": 25},
   {"type":
    "{R : Type u} â†’\n  {L : Type v} â†’\n    {M : Type w} â†’\n      {N : Type wâ‚} â†’\n        [inst : CommRing R] â†’\n          [inst_1 : LieRing L] â†’\n            [inst_2 : AddCommGroup M] â†’\n              [inst_3 : AddCommGroup N] â†’\n                [inst_4 : Module R M] â†’\n                  [inst_5 : Module R N] â†’\n                    [inst_6 : LieRingModule L M] â†’ [inst_7 : LieRingModule L N] â†’ (M â‰ƒâ‚—â…R,Lâ† N) â†’ N â†’ M",
    "name": "LieModuleEquiv.invFun",
    "isProp": false,
    "doc": "The inverse function of an equivalence of Lie modules ",
    "depth": 25}],
  "count": 50},
 {"noDocExamples": [],
  "kind": "SimpleGraph.Â«term_â‰ƒg_Â»",
  "examples":
  [{"type": "{V : Type u} â†’ {G : SimpleGraph V} â†’ G â‰ƒg G",
    "name": "SimpleGraph.Iso.refl",
    "isProp": false,
    "doc": "The identity isomorphism of a graph with itself. ",
    "depth": 6},
   {"type":
    "{Î± : Type u_1} â†’ [inst : Preorder Î±] â†’ SimpleGraph.hasse Î±áµ’áµˆ â‰ƒg SimpleGraph.hasse Î±",
    "name": "SimpleGraph.hasseDualIso",
    "isProp": false,
    "doc": "`Î±áµ’áµˆ` and `Î±` have the same Hasse diagram. ",
    "depth": 7},
   {"type":
    "{V : Type u} â†’ (G : SimpleGraph V) â†’ SimpleGraph.induce Set.univ G â‰ƒg G",
    "name": "SimpleGraph.induceUnivIso",
    "isProp": false,
    "doc":
    "The graph induced on `Set.univ` is isomorphic to the original graph. ",
    "depth": 8}],
  "count": 50},
 {"noDocExamples": [],
  "kind": "Â«term_â†’*â‚€o_Â»",
  "examples":
  [{"type":
    "âˆ€ {Î± : Type u_6} {Î² : Type u_7} [inst : Preorder Î±] [inst_1 : Preorder Î²] [inst_2 : MulZeroOneClass Î±]\n  [inst_3 : MulZeroOneClass Î²] (self : Î± â†’*â‚€o Î²), Monotone self.toFun",
    "name": "OrderMonoidWithZeroHom.monotone'",
    "isProp": true,
    "doc": "An `OrderMonoidWithZeroHom` is a monotone function. ",
    "depth": 17},
   {"type":
    "(Î± : Type u_2) â†’ [inst : Preorder Î±] â†’ [inst_1 : MulZeroOneClass Î±] â†’ Î± â†’*â‚€o Î±",
    "name": "OrderMonoidWithZeroHom.id",
    "isProp": false,
    "doc": "The identity map as an ordered monoid with zero homomorphism. ",
    "depth": 9},
   {"type":
    "{Î± : Type u_2} â†’\n  {Î² : Type u_3} â†’\n    [inst : NonAssocSemiring Î±] â†’\n      [inst_1 : Preorder Î±] â†’ [inst_2 : NonAssocSemiring Î²] â†’ [inst_3 : Preorder Î²] â†’ Î± â†’+*o Î² â†’ Î± â†’*â‚€o Î²",
    "name": "OrderRingHom.toOrderMonoidWithZeroHom",
    "isProp": false,
    "doc":
    "Reinterpret an ordered ring homomorphism as an order homomorphism. ",
    "depth": 13}],
  "count": 49},
 {"noDocExamples": [],
  "kind": "Lean.Parser.Term.quotedName",
  "examples":
  [{"type": "CongrState â†’ List (Lean.TSyntax `rcasesPat)",
    "name": "CongrState.patterns",
    "isProp": false,
    "doc": "Patterns to use when doing intro. ",
    "depth": 6},
   {"type": "CongrMetaM (Option (Lean.TSyntax `rcasesPat))",
    "name": "CongrMetaM.nextPattern",
    "isProp": false,
    "doc": "Pop the next pattern from the current state. ",
    "depth": 6},
   {"type":
    "Lean.TSyntaxArray `Lean.Parser.Term.bracketedBinder â†’ Lean.TSyntaxArray `Lean.Parser.Term.bracketedBinder",
    "name": "Mathlib.Command.Variable.cleanBinders",
    "isProp": false,
    "doc": "Strip off whitespace and comments. ",
    "depth": 8}],
  "count": 48},
 {"noDocExamples": [],
  "kind": "Â«term_â†’+o_Â»",
  "examples":
  [{"type":
    "(Î± : Type u_2) â†’ [inst : Preorder Î±] â†’ [inst_1 : AddZeroClass Î±] â†’ Î± â†’+o Î±",
    "name": "OrderAddMonoidHom.id",
    "isProp": false,
    "doc": "The identity map as an ordered additive monoid homomorphism.",
    "depth": 9},
   {"type":
    "{Î± : Type u_2} â†’ {Î² : Type u_3} â†’ [inst : OrderedAddCommMonoid Î±] â†’ [inst_1 : OrderedAddCommMonoid Î²] â†’ Add (Î± â†’+o Î²)",
    "name":
    "OrderAddMonoidHom.instAddOrderAddMonoidHomToPreorderToPartialOrderToPreorderToPartialOrderToAddZeroClassToAddMonoidToAddCommMonoidToAddZeroClassToAddMonoidToAddCommMonoid",
    "isProp": false,
    "doc":
    "For two ordered additive monoid morphisms `f` and `g`, their product is the ordered\nadditive monoid morphism sending `a` to `f a + g a`.",
    "depth": 12},
   {"type":
    "{Î± : Type u_2} â†’\n  {Î² : Type u_3} â†’\n    [inst : Preorder Î±] â†’ [inst_1 : Preorder Î²] â†’ [inst_2 : AddZeroClass Î±] â†’ [inst_3 : AddZeroClass Î²] â†’ Zero (Î± â†’+o Î²)",
    "name": "OrderAddMonoidHom.instZeroOrderAddMonoidHom",
    "isProp": false,
    "doc": "`0` is the homomorphism sending all elements to `0`.",
    "depth": 13}],
  "count": 48},
 {"noDocExamples": [],
  "kind": "Â«term_â†’*o_Â»",
  "examples":
  [{"type":
    "(Î± : Type u_2) â†’ [inst : Preorder Î±] â†’ [inst_1 : MulOneClass Î±] â†’ Î± â†’*o Î±",
    "name": "OrderMonoidHom.id",
    "isProp": false,
    "doc": "The identity map as an ordered monoid homomorphism. ",
    "depth": 9},
   {"type":
    "{Î± : Type u_2} â†’ {Î² : Type u_3} â†’ [inst : OrderedCommMonoid Î±] â†’ [inst_1 : OrderedCommMonoid Î²] â†’ Mul (Î± â†’*o Î²)",
    "name":
    "OrderMonoidHom.instMulOrderMonoidHomToPreorderToPartialOrderToPreorderToPartialOrderToMulOneClassToMonoidToCommMonoidToMulOneClassToMonoidToCommMonoid",
    "isProp": false,
    "doc":
    "For two ordered monoid morphisms `f` and `g`, their product is the ordered monoid morphism\nsending `a` to `f a * g a`. ",
    "depth": 12},
   {"type":
    "{Î± : Type u_2} â†’\n  {Î² : Type u_3} â†’\n    [inst : Preorder Î±] â†’\n      [inst_1 : Preorder Î²] â†’ [inst_2 : MulOneClass Î±] â†’ [inst_3 : MulOneClass Î²] â†’ (Î± â†’*o Î²) â†’ Î± â†’o Î²",
    "name": "OrderMonoidHom.toOrderHom",
    "isProp": false,
    "doc":
    "Reinterpret an ordered monoid homomorphism as an order homomorphism. ",
    "depth": 13}],
  "count": 48},
 {"noDocExamples": [],
  "kind": "List.Â«term_<+:_Â»",
  "examples":
  [{"type": "âˆ€ {Î± : Type u_1} {l : List Î±}, l <+: [] â†’ l = []",
    "name": "List.eq_nil_of_prefix_nil",
    "isProp": true,
    "doc": "**Alias** of the forward direction of `List.prefix_nil`.",
    "depth": 7},
   {"type":
    "âˆ€ {Î± : Type u_1} {lâ‚ lâ‚‚ : List Î±}, lâ‚ <:+ lâ‚‚ â†’ List.reverse lâ‚ <+: List.reverse lâ‚‚",
    "name": "List.isSuffix.reverse",
    "isProp": true,
    "doc": "**Alias** of the reverse direction of `List.reverse_prefix`.",
    "depth": 8},
   {"type":
    "âˆ€ {Î± : Type u_1} {lâ‚ lâ‚‚ : List Î±}, lâ‚ <+: lâ‚‚ â†’ List.reverse lâ‚ <:+ List.reverse lâ‚‚",
    "name": "List.isPrefix.reverse",
    "isProp": true,
    "doc": "**Alias** of the reverse direction of `List.reverse_suffix`.",
    "depth": 8}],
  "count": 48},
 {"noDocExamples": [],
  "kind": "Â«term_||_Â»",
  "examples":
  [{"type": "âˆ€ (x y : Bool), (!(x && y)) = (!x || !y)",
    "name": "Bool.not_and",
    "isProp": true,
    "doc": "De Morgan's law for boolean and ",
    "depth": 7},
   {"type": "âˆ€ (x y : Bool), (!(x || y)) = (!x && !y)",
    "name": "Bool.not_or",
    "isProp": true,
    "doc": "De Morgan's law for boolean or ",
    "depth": 7},
   {"type":
    "âˆ€ {m x y : Bool}, (x && m) = (y && m) âˆ§ (x || m) = (y || m) â†” x = y",
    "name": "Bool.and_or_inj_right'",
    "isProp": true,
    "doc": "**Alias** of `Bool.and_or_inj_right_iff`.",
    "depth": 11}],
  "count": 48},
 {"noDocExamples": [],
  "kind": "Â«term_â‰ƒâ‹†â‚[_]_Â»",
  "examples":
  [{"type":
    "âˆ€ {R : Type u_1} {A : Type u_2} {B : Type u_3} [inst : Add A] [inst_1 : Add B] [inst_2 : Mul A] [inst_3 : Mul B]\n  [inst_4 : SMul R A] [inst_5 : SMul R B] [inst_6 : Star A] [inst_7 : Star B] (self : A â‰ƒâ‹†â‚[R] B) (r : R) (a : A),\n  Equiv.toFun self.toEquiv (r â€¢ a) = r â€¢ Equiv.toFun self.toEquiv a",
    "name": "StarAlgEquiv.map_smul'",
    "isProp": true,
    "doc":
    "By definition, a â‹†-algebra equivalence commutes with the action of scalars. ",
    "depth": 31},
   {"type":
    "{R : Type u_2} â†’\n  {A : Type u_3} â†’\n    {B : Type u_4} â†’\n      [inst : Add A] â†’\n        [inst_1 : Add B] â†’\n          [inst_2 : Mul A] â†’\n            [inst_3 : Mul B] â†’\n              [inst_4 : SMul R A] â†’\n                [inst_5 : SMul R B] â†’ [inst_6 : Star A] â†’ [inst_7 : Star B] â†’ (A â‰ƒâ‹†â‚[R] B) â†’ B â‰ƒâ‹†â‚[R] A",
    "name": "StarAlgEquiv.symm",
    "isProp": false,
    "doc": "Star algebra equivalences are symmetric. ",
    "depth": 23},
   {"type":
    "{R : Type u_2} â†’\n  {A : Type u_3} â†’\n    {B : Type u_4} â†’\n      [inst : Add A] â†’\n        [inst_1 : Add B] â†’\n          [inst_2 : Mul A] â†’\n            [inst_3 : Mul B] â†’\n              [inst_4 : SMul R A] â†’ [inst_5 : SMul R B] â†’ [inst_6 : Star A] â†’ [inst_7 : Star B] â†’ (A â‰ƒâ‹†â‚[R] B) â†’ A â†’ B",
    "name": "StarAlgEquiv.Simps.apply",
    "isProp": false,
    "doc": "See Note [custom simps projection] ",
    "depth": 23}],
  "count": 47},
 {"noDocExamples": [],
  "kind": "Â«termÎ©[_â„_]Â»",
  "examples":
  [{"type":
    "(R : Type u) â†’ (S : Type v) â†’ [inst : CommRing R] â†’ [inst_1 : CommRing S] â†’ [inst_2 : Algebra R S] â†’ S â†’â‚—[R] Î©[Sâ„R]",
    "name": "KaehlerDifferential.DLinearMap",
    "isProp": false,
    "doc":
    "(Implementation) The underlying linear map of the derivation into `Î©[Sâ„R]`. ",
    "depth": 17},
   {"type":
    "(R : Type u) â†’\n  (S : Type v) â†’ [inst : CommRing R] â†’ [inst_1 : CommRing S] â†’ [inst_2 : Algebra R S] â†’ Derivation R S (Î©[Sâ„R])",
    "name": "KaehlerDifferential.D",
    "isProp": false,
    "doc": "The universal derivation into `Î©[Sâ„R]`. ",
    "depth": 17},
   {"type":
    "{R : Type u} â†’\n  {S : Type v} â†’\n    [inst : CommRing R] â†’\n      [inst_1 : CommRing S] â†’\n        [inst_2 : Algebra R S] â†’\n          {M : Type u_1} â†’\n            [inst_3 : AddCommGroup M] â†’\n              [inst_4 : Module R M] â†’\n                [inst_5 : Module S M] â†’ [inst_6 : IsScalarTower R S M] â†’ Derivation R S M â†’ Î©[Sâ„R] â†’â‚—[S] M",
    "name": "Derivation.liftKaehlerDifferential",
    "isProp": false,
    "doc": "The linear map from `Î©[Sâ„R]`, associated with a derivation. ",
    "depth": 23}],
  "count": 46},
 {"noDocExamples": [],
  "kind": "QuadraticForm.Isometry.Â«term_â†’qáµ¢_Â»",
  "examples":
  [{"type":
    "{R : Type u_2} â†’\n  {M : Type u_3} â†’\n    [inst : CommSemiring R] â†’ [inst_1 : AddCommMonoid M] â†’ [inst_2 : Module R M] â†’ (Q : QuadraticForm R M) â†’ Q â†’qáµ¢ Q",
    "name": "QuadraticForm.Isometry.id",
    "isProp": false,
    "doc": "The identity isometry from a quadratic form to itself. ",
    "depth": 16},
   {"type":
    "{R : Type u} â†’\n  [inst : CommRing R] â†’\n    {X : Type v} â†’\n      [inst_1 : AddCommGroup X] â†’\n        [inst_2 : Module R X] â†’\n          {Qâ‚ Qâ‚‚ : QuadraticForm R X} â†’ (Qâ‚ â†’qáµ¢ Qâ‚‚) â†’ (QuadraticModuleCat.of Qâ‚ âŸ¶ QuadraticModuleCat.of Qâ‚‚)",
    "name": "QuadraticModuleCat.ofHom",
    "isProp": false,
    "doc": "Typecheck a `QuadraticForm.Isometry` as a morphism in `Module R`. ",
    "depth": 18},
   {"type":
    "{R : Type u} â†’ [inst : CommRing R] â†’ {V W : QuadraticModuleCat R} â†’ QuadraticModuleCat.Hom V W â†’ V.form â†’qáµ¢ W.form",
    "name": "QuadraticModuleCat.Hom.toIsometry",
    "isProp": false,
    "doc": "The underlying isometry ",
    "depth": 18}],
  "count": 44},
 {"noDocExamples": [],
  "kind": "Â«term_â†’áµˆ_Â»",
  "examples":
  [{"type":
    "{Î± : Type u_1} â†’ [inst : PseudoEMetricSpace Î±] â†’ (Î± â†’áµˆ Î±) â†’* NNReal",
    "name": "Dilation.ratioHom",
    "isProp": false,
    "doc": "`Dilation.ratio` as a monoid homomorphism from `Î± â†’áµˆ Î±` to `â„â‰¥0`. ",
    "depth": 10},
   {"type":
    "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : PseudoEMetricSpace Î±] [inst_1 : PseudoEMetricSpace Î²]\n  [inst_2 : PseudoEMetricSpace Î³] {g : Î² â†’áµˆ Î³} {f : Î± â†’áµˆ Î²},\n  (âˆƒ x y, edist x y â‰  0 âˆ§ edist x y â‰  âŠ¤) â†’ Dilation.ratio (Dilation.comp g f) = Dilation.ratio g * Dilation.ratio f",
    "name": "Dilation.ratio_comp'",
    "isProp": true,
    "doc":
    "Ratio of the composition `g.comp f` of two dilations is the product of their ratios. We assume\nthat there exist two points in `Î±` at extended distance neither `0` nor `âˆ` because otherwise\n`Dilation.ratio (g.comp f) = Dilation.ratio f = 1` while `Dilation.ratio g` can be any number. This\nversion works for most general spaces, see also `Dilation.ratio_comp` for a version assuming that\n`Î±` is a nontrivial metric space. ",
    "depth": 22},
   {"type": "(Î± : Type u_6) â†’ [inst : PseudoEMetricSpace Î±] â†’ Î± â†’áµˆ Î±",
    "name": "Dilation.id",
    "isProp": false,
    "doc": "The identity is a dilation ",
    "depth": 6}],
  "count": 44},
 {"noDocExamples":
  [{"type":
    "âˆ€ (x : â„•) (r : â„), Metric.closedBall x r = Set.Icc âŒˆâ†‘x - râŒ‰â‚Š âŒŠâ†‘x + râŒ‹â‚Š",
    "name": "Nat.closedBall_eq_Icc",
    "isProp": true,
    "depth": 12},
   {"type":
    "âˆ€ {Î± : Type u_2} [inst : LinearOrderedSemiring Î±] [inst_1 : FloorSemiring Î±], âŒˆ1âŒ‰â‚Š = 1",
    "name": "Nat.ceil_one",
    "isProp": true,
    "depth": 12}],
  "kind": "Nat.Â«termâŒˆ_âŒ‰â‚ŠÂ»",
  "examples":
  [{"type":
    "âˆ€ {Fq : Type u_1} [inst : Fintype Fq] [inst_1 : Field Fq] {b : Polynomial Fq},\n  b â‰  0 â†’\n    âˆ€ {Îµ : â„},\n      0 < Îµ â†’\n        âˆ€ (A : Fin (Nat.succ (Fintype.card Fq ^ âŒˆ-Real.log Îµ / Real.log â†‘(Fintype.card Fq)âŒ‰â‚Š)) â†’ Polynomial Fq),\n          âˆƒ iâ‚€ iâ‚, iâ‚€ â‰  iâ‚ âˆ§ â†‘(Polynomial.cardPowDegree (A iâ‚ % b - A iâ‚€ % b)) < Polynomial.cardPowDegree b â€¢ Îµ",
    "name": "Polynomial.exists_approx_polynomial",
    "isProp": true,
    "doc":
    "If `A` is a family of enough low-degree polynomials over a finite field,\nthere is a pair of elements in `A` (with different indices but not necessarily\ndistinct), such that the difference of their remainders is close together. ",
    "depth": 35}],
  "count": 43},
 {"noDocExamples": [],
  "kind": "Â«term_âºÂ»",
  "examples":
  [{"type":
    "âˆ€ {Î± : Type u} [inst : Lattice Î±] [inst_1 : Group Î±] (a : Î±), 1 â‰¤ a â†’ aâº = a",
    "name": "LatticeOrderedGroup.pos_of_one_le",
    "isProp": true,
    "doc":
    "If `a` is positive, then it is equal to its positive component `aâº`. ",
    "depth": 14},
   {"type":
    "âˆ€ {Î± : Type u} [inst : Lattice Î±] [inst_1 : AddGroup Î±] (a : Î±), 0 â‰¤ a â†’ aâº = a",
    "name": "LatticeOrderedGroup.pos_of_nonneg",
    "isProp": true,
    "doc":
    "If `a` is positive, then it is equal to its positive component `aâº`.",
    "depth": 14},
   {"type":
    "âˆ€ {Î© : Type u_1} {m0 : MeasurableSpace Î©} {Î¼ : MeasureTheory.Measure Î©} {f : â„• â†’ Î© â†’ â„}\n  {â„± : MeasureTheory.Filtration â„• m0} [inst : MeasureTheory.IsFiniteMeasure Î¼] (a b : â„),\n  MeasureTheory.Submartingale f â„± Î¼ â†’\n    ENNReal.ofReal (b - a) * âˆ«â» (Ï‰ : Î©), MeasureTheory.upcrossings a b f Ï‰ âˆ‚Î¼ â‰¤\n      â¨† N, âˆ«â» (Ï‰ : Î©), ENNReal.ofReal (f N Ï‰ - a)âº âˆ‚Î¼",
    "name":
    "MeasureTheory.Submartingale.mul_lintegral_upcrossings_le_lintegral_pos_part",
    "isProp": true,
    "doc":
    "A variant of Doob's upcrossing estimate obtained by taking the supremum on both sides. ",
    "depth": 24}],
  "count": 42},
 {"noDocExamples": [],
  "kind": "Â«termâˆ®_InC(_,_),_Â»",
  "examples":
  [{"type":
    "âˆ€ {c w : â„‚} {R : â„}, w âˆˆ Metric.ball c R â†’ (âˆ® (z : â„‚) in C(c, R), (z - w)â»Â¹) = 2 * â†‘Real.pi * Complex.I",
    "name": "circleIntegral.integral_sub_inv_of_mem_ball",
    "isProp": true,
    "doc":
    "Integral $\\oint_{|z-c|=R} \\frac{dz}{z-w} = 2Ï€i$ whenever $|w-c| < R$. ",
    "depth": 17},
   {"type":
    "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] (f : (Fin 1 â†’ â„‚) â†’ E) (c : Fin 1 â†’ â„‚)\n  (R : Fin 1 â†’ â„), (âˆ¯ (x : Fin 1 â†’ â„‚) in T(c, R), f x) = âˆ® (z : â„‚) in C(c 0, R 0), f fun x => z",
    "name": "torusIntegral_dim1",
    "isProp": true,
    "doc":
    "In dimension one, `torusIntegral` is the same as `circleIntegral`\n(up to the natural equivalence between `â„‚` and `Fin 1 â†’ â„‚`). ",
    "depth": 18},
   {"type":
    "âˆ€ {n : â„¤}, n â‰  -1 â†’ âˆ€ (c w : â„‚) (R : â„), (âˆ® (z : â„‚) in C(c, R), (z - w) ^ n) = 0",
    "name": "circleIntegral.integral_sub_zpow_of_ne",
    "isProp": true,
    "doc":
    "If `n â‰  -1` is an integer number, then the integral of `(z - w) ^ n` over the circle equals\nzero. ",
    "depth": 20}],
  "count": 42},
 {"noDocExamples": [],
  "kind": "Â«term_â‰ƒ+*o_Â»",
  "examples":
  [{"type":
    "{Î± : Type u_2} â†’\n  {Î² : Type u_3} â†’\n    [inst : Mul Î±] â†’\n      [inst_1 : Add Î±] â†’ [inst_2 : LE Î±] â†’ [inst_3 : Mul Î²] â†’ [inst_4 : Add Î²] â†’ [inst_5 : LE Î²] â†’ Î± â‰ƒ+*o Î² â†’ Î± â‰ƒo Î²",
    "name": "OrderRingIso.toOrderIso",
    "isProp": false,
    "doc": "Reinterpret an ordered ring isomorphism as an order isomorphism. ",
    "depth": 17},
   {"type":
    "âˆ€ {Î± : Type u_2} {Î² : Type u_3} [inst : Mul Î±] [inst_1 : Add Î±] [inst_2 : LE Î±] [inst_3 : Mul Î²] [inst_4 : Add Î²]\n  [inst_5 : LE Î²] (f : Î± â‰ƒ+*o Î²), f.toFun = â‡‘f",
    "name": "OrderRingIso.toFun_eq_coe",
    "isProp": true,
    "doc":
    "Helper instance for when there's too many metavariables to apply `FunLike.has_coe_to_fun`\ndirectly. ",
    "depth": 32},
   {"type":
    "{Î± : Type u_2} â†’\n  {Î² : Type u_3} â†’\n    [inst : Mul Î±] â†’\n      [inst_1 : Add Î±] â†’ [inst_2 : LE Î±] â†’ [inst_3 : Mul Î²] â†’ [inst_4 : Add Î²] â†’ [inst_5 : LE Î²] â†’ Î± â‰ƒ+*o Î² â†’ Î² â‰ƒ+*o Î±",
    "name": "OrderRingIso.symm",
    "isProp": false,
    "doc":
    "The inverse of an ordered ring isomorphism as an ordered ring isomorphism. ",
    "depth": 17}],
  "count": 42},
 {"noDocExamples": [],
  "kind": "Â«term_â‹Š[_]_Â»",
  "examples":
  [{"type":
    "{N : Type u_1} â†’ {G : Type u_2} â†’ [inst : Group N] â†’ [inst_1 : Group G] â†’ {Ï† : G â†’* MulAut N} â†’ N â‹Š[Ï†] G â†’ N",
    "name": "SemidirectProduct.left",
    "isProp": false,
    "doc": "The element of N ",
    "depth": 16},
   {"type":
    "{N : Type u_1} â†’ {G : Type u_2} â†’ [inst : Group N] â†’ [inst_1 : Group G] â†’ {Ï† : G â†’* MulAut N} â†’ N â†’* N â‹Š[Ï†] G",
    "name": "SemidirectProduct.inl",
    "isProp": false,
    "doc": "The canonical map `N â†’* N â‹Š[Ï†] G` sending `n` to `âŸ¨n, 1âŸ©` ",
    "depth": 16},
   {"type":
    "{N : Type u_1} â†’ {G : Type u_2} â†’ [inst : Group N] â†’ [inst_1 : Group G] â†’ {Ï† : G â†’* MulAut N} â†’ N â‹Š[Ï†] G â†’ G",
    "name": "SemidirectProduct.right",
    "isProp": false,
    "doc": "The element of G ",
    "depth": 16}],
  "count": 41},
 {"noDocExamples": [],
  "kind": "List.Â«term_<:+_Â»",
  "examples":
  [{"type": "âˆ€ {Î± : Type u_1} {l : List Î±}, l <:+ [] â†’ l = []",
    "name": "List.eq_nil_of_suffix_nil",
    "isProp": true,
    "doc": "**Alias** of the forward direction of `List.suffix_nil`.",
    "depth": 7},
   {"type":
    "âˆ€ {Î± : Type u_1} {lâ‚ lâ‚‚ : List Î±}, lâ‚ <:+ lâ‚‚ â†’ List.reverse lâ‚ <+: List.reverse lâ‚‚",
    "name": "List.isSuffix.reverse",
    "isProp": true,
    "doc": "**Alias** of the reverse direction of `List.reverse_prefix`.",
    "depth": 8},
   {"type":
    "âˆ€ {Î± : Type u_1} {lâ‚ lâ‚‚ : List Î±}, lâ‚ <+: lâ‚‚ â†’ List.reverse lâ‚ <:+ List.reverse lâ‚‚",
    "name": "List.isPrefix.reverse",
    "isProp": true,
    "doc": "**Alias** of the reverse direction of `List.reverse_suffix`.",
    "depth": 8}],
  "count": 41},
 {"noDocExamples": [],
  "kind": "Â«MulSemiringActionHomLocalâ‰ºÂ»",
  "examples":
  [{"type":
    "(M : Type u_5) â†’\n  [inst : Monoid M] â†’ {R : Type u_11} â†’ [inst_1 : Semiring R] â†’ [inst_2 : MulSemiringAction M R] â†’ R â†’+*[M] R",
    "name": "MulSemiringActionHom.id",
    "isProp": false,
    "doc": "The identity map as an equivariant ring homomorphism. ",
    "depth": 13},
   {"type":
    "{M : Type u_5} â†’\n  [inst : Monoid M] â†’\n    {R : Type u_11} â†’\n      [inst_1 : Semiring R] â†’\n        [inst_2 : MulSemiringAction M R] â†’\n          {S : Type u_13} â†’ [inst_3 : Semiring S] â†’ [inst_4 : MulSemiringAction M S] â†’ (R â†’+*[M] S) â†’ R â†’+* S",
    "name": "MulSemiringActionHom.toRingHom",
    "isProp": false,
    "doc":
    "Reinterpret an equivariant ring homomorphism as a ring homomorphism. ",
    "depth": 17},
   {"type":
    "{M : Type u_1} â†’\n  [inst : Monoid M] â†’\n    {P : Type u_2} â†’\n      [inst_1 : CommSemiring P] â†’\n        [inst_2 : MulSemiringAction M P] â†’\n          {Q : Type u_3} â†’\n            [inst_3 : CommSemiring Q] â†’\n              [inst_4 : MulSemiringAction M Q] â†’ (P â†’+*[M] Q) â†’ Polynomial P â†’+*[M] Polynomial Q",
    "name": "MulSemiringActionHom.polynomial",
    "isProp": false,
    "doc": "An equivariant map induces an equivariant map on polynomials. ",
    "depth": 18}],
  "count": 41},
 {"noDocExamples": [],
  "kind": "Polynomial.Â«term_%â‚˜_Â»",
  "examples":
  [{"type":
    "âˆ€ {R : Type u} [inst : CommRing R] {n : Type v} [inst_1 : DecidableEq n] [inst_2 : Fintype n] (M : Matrix n n R)\n  (k : â„•), M ^ k = (Polynomial.aeval M) (Polynomial.X ^ k %â‚˜ Matrix.charpoly M)",
    "name": "Matrix.pow_eq_aeval_mod_charpoly",
    "isProp": true,
    "doc":
    "Any matrix power can be computed as the sum of matrix powers less than `Fintype.card n`.\n\nTODO: add the statement for negative powers phrased with `zpow`. ",
    "depth": 34},
   {"type":
    "âˆ€ {R : Type u} [inst : CommRing R] {n : Type v} [inst_1 : DecidableEq n] [inst_2 : Fintype n] (M : Matrix n n R)\n  (p : Polynomial R), (Polynomial.aeval M) p = (Polynomial.aeval M) (p %â‚˜ Matrix.charpoly M)",
    "name": "Matrix.aeval_eq_aeval_mod_charpoly",
    "isProp": true,
    "doc":
    "Any matrix polynomial `p` is equivalent under evaluation to `p %â‚˜ M.charpoly`; that is, `p`\nis equivalent to a polynomial with degree less than the dimension of the matrix. ",
    "depth": 35},
   {"type":
    "âˆ€ {R : Type u} {M : Type v} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : Module.Free R M] [inst_4 : Module.Finite R M] (f : M â†’â‚—[R] M) (k : â„•),\n  f ^ k = (Polynomial.aeval f) (Polynomial.X ^ k %â‚˜ LinearMap.charpoly f)",
    "name": "LinearMap.pow_eq_aeval_mod_charpoly",
    "isProp": true,
    "doc":
    "Any endomorphism power can be computed as the sum of endomorphism powers less than the\ndimension of the module. ",
    "depth": 43}],
  "count": 38},
 {"noDocExamples": [],
  "kind": "OreLocalization.Â«term_/â‚’_Â»",
  "examples":
  [{"type":
    "âˆ€ {R : Type u_1} [inst : Monoid R] {S : Submonoid R} [inst_1 : OreLocalization.OreSet S] {r r' râ‚ râ‚‚ : R} {s t : â†¥S},\n  r * â†‘t = r' * â†‘t â†’ râ‚ * r * râ‚‚ /â‚’ s = râ‚ * r' * râ‚‚ /â‚’ s",
    "name": "OreLocalization.eq_of_num_factor_eq",
    "isProp": true,
    "doc":
    "Fractions which differ by a factor of the numerator can be proven equal if\nthose factors expand to equal elements of `R`. ",
    "depth": 25},
   {"type":
    "âˆ€ {R : Type u_1} [inst : Monoid R] {S : Submonoid R} [inst_1 : OreLocalization.OreSet S] (r : R) (s : â†¥S) (t : R)\n  (hst : â†‘s * t âˆˆ S), r /â‚’ s = r * t /â‚’ { val := â†‘s * t, property := hst }",
    "name": "OreLocalization.expand",
    "isProp": true,
    "doc":
    "A fraction `r /â‚’ s` is equal to its expansion by an arbitrary factor `t` if `s * t âˆˆ S`. ",
    "depth": 25},
   {"type":
    "âˆ€ {R : Type u_1} [inst : Monoid R] {S : Submonoid R} [inst_1 : OreLocalization.OreSet S] (r : R) (s s' : â†¥S),\n  r /â‚’ s = r * â†‘s' /â‚’ (s * s')",
    "name": "OreLocalization.expand'",
    "isProp": true,
    "doc": "A fraction is equal to its expansion by a factor from s. ",
    "depth": 26}],
  "count": 38},
 {"noDocExamples":
  [{"type":
    "âˆ€ {Î± : Type u} [inst : Lattice Î±] [inst_1 : AddGroup Î±] (a : Î±), -a â‰¤ aâ»",
    "name": "LatticeOrderedGroup.neg_le_neg",
    "isProp": true,
    "depth": 13},
   {"type": "âˆ€ {Î± : Type u} [inst : Lattice Î±] [inst_1 : AddGroup Î±], 0â» = 0",
    "name": "LatticeOrderedGroup.neg_zero",
    "isProp": true,
    "depth": 13},
   {"type":
    "âˆ€ {Î± : Type u} [inst : Lattice Î±] [inst_1 : AddGroup Î±] (a : Î±), 0 â‰¤ aâ»",
    "name": "LatticeOrderedGroup.neg_nonneg",
    "isProp": true,
    "depth": 13}],
  "kind": "Â«term_â»Â»",
  "examples": [],
  "count": 38},
 {"noDocExamples":
  [{"type":
    "âˆ€ {C : Type u} {X Y X' Y' : C} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.MonoidalCategory C]\n  (f : X â‰… Y) (g : X' â‰… Y'), (f âŠ— g).inv = CategoryTheory.MonoidalCategory.tensorHom f.inv g.inv",
    "name": "CategoryTheory.tensorIso_inv",
    "isProp": true,
    "depth": 21},
   {"type":
    "âˆ€ {C : Type u} {X Y X' Y' : C} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.MonoidalCategory C]\n  (f : X â‰… Y) (g : X' â‰… Y'), (f âŠ— g).hom = CategoryTheory.MonoidalCategory.tensorHom f.hom g.hom",
    "name": "CategoryTheory.tensorIso_hom",
    "isProp": true,
    "depth": 21},
   {"type":
    "âˆ€ {C : Type u_1} [inst : CategoryTheory.Category.{u_2, u_1} C] [inst_1 : CategoryTheory.MonoidalCategory C]\n  (P : C â†’ Prop) (X : CategoryTheory.FullSubcategory P),\n  (CategoryTheory.MonoidalCategory.rightUnitor X.obj).hom =\n    ((CategoryTheory.Iso.refl (CategoryTheory.MonoidalCategory.tensorObj X.obj (ğŸ™_ C)) â‰ªâ‰«\n          (CategoryTheory.Iso.refl X.obj âŠ— CategoryTheory.Iso.refl (ğŸ™_ C))) â‰ªâ‰«\n        CategoryTheory.MonoidalCategory.rightUnitor X.obj).hom",
    "name": "CategoryTheory.MonoidalCategory.fullMonoidalSubcategory.proof_8",
    "isProp": true,
    "depth": 21}],
  "kind": "CategoryTheory.Â«term_âŠ—_Â»",
  "examples": [],
  "count": 38},
 {"noDocExamples": [],
  "kind": "Submodule.Â«term_âŸ‚_Â»",
  "examples":
  [{"type":
    "âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {U V : Submodule ğ•œ E}, U âŸ‚ V â†’ Disjoint U V",
    "name": "Submodule.IsOrtho.disjoint",
    "isProp": true,
    "doc": "Orthogonal submodules are disjoint. ",
    "depth": 25},
   {"type":
    "âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] {n : â„•} (s : Affine.Simplex â„ P (n + 1)) (i : Fin (n + 2)),\n  vectorSpan â„ (s.points '' â†‘(Finset.erase Finset.univ i)) âŸ‚ AffineSubspace.direction (Affine.Simplex.altitude s i)",
    "name": "Affine.Simplex.vectorSpan_isOrtho_altitude_direction",
    "isProp": true,
    "doc":
    "The vector span of the opposite face lies in the direction\northogonal to an altitude. ",
    "depth": 28},
   {"type":
    "âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {Î¹ : Type u_4} {V : Î¹ â†’ Submodule ğ•œ E},\n  (OrthogonalFamily ğ•œ (fun i => â†¥(V i)) fun i => Submodule.subtypeâ‚—áµ¢ (V i)) â†’ Pairwise ((fun x x_1 => x âŸ‚ x_1) on V)",
    "name": "OrthogonalFamily.pairwise",
    "isProp": true,
    "doc":
    "**Alias** of the forward direction of `orthogonalFamily_iff_pairwise`.",
    "depth": 31}],
  "count": 36},
 {"noDocExamples":
  [{"type": "âˆ€ {Î± : Type u} (l : List Î±), l ~r l",
    "name": "List.IsRotated.refl",
    "isProp": true,
    "depth": 5},
   {"type": "âˆ€ {Î± : Type u} {l : List Î±}, [] ~r l â†” [] = l",
    "name": "List.isRotated_nil_iff'",
    "isProp": true,
    "depth": 7},
   {"type": "âˆ€ {Î± : Type u} {l l' : List Î±}, l ~r l' â†’ List.Perm l l'",
    "name": "List.IsRotated.perm",
    "isProp": true,
    "depth": 7}],
  "kind": "List.Â«term_~r_Â»",
  "examples": [],
  "count": 36},
 {"noDocExamples": [],
  "kind": "Â«MulActionHomLocalâ‰ºÂ»",
  "examples":
  [{"type": "(M' : Type u_1) â†’ {X : Type u_2} â†’ [inst : SMul M' X] â†’ X â†’[M'] X",
    "name": "MulActionHom.id",
    "isProp": false,
    "doc": "The identity map as an equivariant map. ",
    "depth": 8},
   {"type": "{Î± : Type u} â†’ [inst : Group Î±] â†’ (H : Subgroup Î±) â†’ Î± â†’[Î±] Î± â§¸ H",
    "name": "MulActionHom.toQuotient",
    "isProp": false,
    "doc": "The canonical map to the left cosets. ",
    "depth": 12},
   {"type":
    "{X : Type u_2} â†’\n  {Y : Type u_3} â†’\n    {M : Type u_5} â†’\n      {F : Type u_16} â†’ [inst : SMul M X] â†’ [inst_1 : SMul M Y] â†’ [inst_2 : SMulHomClass F M X Y] â†’ F â†’ X â†’[M] Y",
    "name": "SMulHomClass.toMulActionHom",
    "isProp": false,
    "doc":
    "Turn an element of a type `F` satisfying `SMulHomClass F M X Y` into an actual\n`MulActionHom`. This is declared as the default coercion from `F` to `MulActionHom M X Y`. ",
    "depth": 13}],
  "count": 36},
 {"noDocExamples": [],
  "kind": "SimpleGraph.Â«term_â†ªg_Â»",
  "examples":
  [{"type": "{V : Type u} â†’ {G : SimpleGraph V} â†’ G â†ªg G",
    "name": "SimpleGraph.Embedding.refl",
    "isProp": false,
    "doc": "The identity embedding from a graph to itself. ",
    "depth": 6},
   {"type":
    "{V : Type u} â†’ {s : Set V} â†’ (G : SimpleGraph â†‘s) â†’ G â†ªg SimpleGraph.spanningCoe G",
    "name": "SimpleGraph.Embedding.spanningCoe",
    "isProp": false,
    "doc": "Graphs on a set of vertices embed in their `spanningCoe`. ",
    "depth": 9},
   {"type":
    "{V : Type u} â†’ {W : Type v} â†’ (f : V â†ª W) â†’ (G : SimpleGraph V) â†’ G â†ªg SimpleGraph.map f G",
    "name": "SimpleGraph.Embedding.map",
    "isProp": false,
    "doc":
    "Given an injective function, there is an embedding from a graph into the mapped graph. ",
    "depth": 9}],
  "count": 36},
 {"noDocExamples":
  [{"type":
    "âˆ€ {M : Type w'} [inst : LE M] [h : NoTopOrder M], M âŠ¨ FirstOrder.Language.noTopOrderSentence FirstOrder.Language.order",
    "name": "FirstOrder.Language.realize_noTopOrder",
    "isProp": true,
    "depth": 7},
   {"type":
    "âˆ€ {M : Type w'} [inst : LE M] [h : NoBotOrder M], M âŠ¨ FirstOrder.Language.noBotOrderSentence FirstOrder.Language.order",
    "name": "FirstOrder.Language.realize_noBotOrder",
    "isProp": true,
    "depth": 7}],
  "kind": "FirstOrder.Language.Â«term_âŠ¨_Â»",
  "examples":
  [{"type":
    "âˆ€ {Î± : Type u_1} {M : Î± â†’ Type u_2} {u : Ultrafilter Î±} {L : FirstOrder.Language}\n  [inst : (a : Î±) â†’ FirstOrder.Language.Structure L (M a)] [inst_1 : âˆ€ (a : Î±), Nonempty (M a)]\n  (Ï† : FirstOrder.Language.Sentence L), Filter.Product (â†‘u) M âŠ¨ Ï† â†” âˆ€á¶  (a : Î±) in â†‘u, M a âŠ¨ Ï†",
    "name": "FirstOrder.Language.Ultraproduct.sentence_realize",
    "isProp": true,
    "doc":
    "**ÅoÅ›'s Theorem**: A sentence is true in an ultraproduct if and only if the set of structures\nit is true in is in the ultrafilter. ",
    "depth": 16}],
  "count": 35},
 {"noDocExamples": [],
  "kind": "Â«term_==_Â»",
  "examples":
  [{"type":
    "âˆ€ {Î± : Type u} [inst : BEq Î±] [self : LawfulBEq Î±] {a : Î±}, (a == a) = true",
    "name": "LawfulBEq.rfl",
    "isProp": true,
    "doc": "`==` is reflexive, that is, `(a == a) = true`. ",
    "depth": 10},
   {"type":
    "âˆ€ {Î± : Type u} [inst : BEq Î±] [self : LawfulBEq Î±] {a b : Î±}, (a == b) = true â†’ a = b",
    "name": "LawfulBEq.eq_of_beq",
    "isProp": true,
    "doc":
    "If `a == b` evaluates to `true`, then `a` and `b` are equal in the logic. ",
    "depth": 12},
   {"type":
    "âˆ€ {Î± : Type u_1} [inst : BEq Î±] [self : PartialEquivBEq Î±] {a b : Î±}, (a == b) = true â†’ (b == a) = true",
    "name": "PartialEquivBEq.symm",
    "isProp": true,
    "doc": "Symmetry for `BEq`. If `a == b` then `b == a`. ",
    "depth": 12}],
  "count": 35},
 {"noDocExamples": [],
  "kind": "MeasureTheory.Â«termâ¨_,_âˆ‚_Â»",
  "examples":
  [{"type":
    "âˆ€ {Î± : Type u_1} {m0 : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {f : Î± â†’ â„}\n  [inst : MeasureTheory.IsFiniteMeasure Î¼], Î¼ â‰  0 â†’ MeasureTheory.Integrable f â†’ âˆƒ x, f x â‰¤ â¨ (a : Î±), f a âˆ‚Î¼",
    "name": "MeasureTheory.exists_le_average",
    "isProp": true,
    "doc":
    "**First moment method**. The minimum of an integrable function is smaller than its mean. ",
    "depth": 17},
   {"type":
    "âˆ€ {Î± : Type u_1} {m0 : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {f : Î± â†’ â„}\n  [inst : MeasureTheory.IsFiniteMeasure Î¼], Î¼ â‰  0 â†’ MeasureTheory.Integrable f â†’ âˆƒ x, â¨ (a : Î±), f a âˆ‚Î¼ â‰¤ f x",
    "name": "MeasureTheory.exists_average_le",
    "isProp": true,
    "doc":
    "**First moment method**. The maximum of an integrable function is greater than its mean. ",
    "depth": 18},
   {"type":
    "âˆ€ {Î± : Type u_1} {m0 : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {f : Î± â†’ â„}\n  [inst : MeasureTheory.IsFiniteMeasure Î¼], Î¼ â‰  0 â†’ MeasureTheory.Integrable f â†’ 0 < â†‘â†‘Î¼ {x | f x â‰¤ â¨ (a : Î±), f a âˆ‚Î¼}",
    "name": "MeasureTheory.measure_le_average_pos",
    "isProp": true,
    "doc":
    "**First moment method**. An integrable function is smaller than its mean on a set of positive\nmeasure. ",
    "depth": 19}],
  "count": 35},
 {"noDocExamples": [],
  "kind": "Â«term_â†’Co_Â»",
  "examples":
  [{"type":
    "(Î± : Type u_2) â†’ [inst : TopologicalSpace Î±] â†’ [inst_1 : Preorder Î±] â†’ Î± â†’Co Î±",
    "name": "ContinuousOrderHom.id",
    "isProp": false,
    "doc": "`id` as a `ContinuousOrderHom`. ",
    "depth": 9},
   {"type":
    "{Î± : Type u_2} â†’\n  {Î² : Type u_3} â†’\n    [inst : TopologicalSpace Î±] â†’\n      [inst_1 : Preorder Î±] â†’ [inst_2 : TopologicalSpace Î²] â†’ [inst_3 : Preorder Î²] â†’ (Î± â†’Co Î²) â†’ C(Î±, Î²)",
    "name": "ContinuousOrderHom.toContinuousMap",
    "isProp": false,
    "doc": "Reinterpret a `ContinuousOrderHom` as a `ContinuousMap`. ",
    "depth": 13},
   {"type":
    "{F : Type u_1} â†’\n  {Î± : Type u_2} â†’\n    {Î² : Type u_3} â†’\n      [inst : Preorder Î±] â†’\n        [inst_1 : Preorder Î²] â†’\n          [inst_2 : TopologicalSpace Î±] â†’\n            [inst_3 : TopologicalSpace Î²] â†’ [inst_4 : ContinuousOrderHomClass F Î± Î²] â†’ F â†’ Î± â†’Co Î²",
    "name": "ContinuousOrderHomClass.toContinuousOrderHom",
    "isProp": false,
    "doc":
    "Turn an element of a type `F` satisfying `ContinuousOrderHomClass F Î± Î²` into an actual\n`ContinuousOrderHom`. This is declared as the default coercion from `F` to `Î± â†’Co Î²`. ",
    "depth": 15}],
  "count": 35},
 {"noDocExamples": [],
  "kind": "TypeVec.Â«term_:::__1Â»",
  "examples":
  [{"type":
    "(n : â„•) â†’\n  {Î² : (v : TypeVec.{u_2} (n + 1)) â†’ (v' : TypeVec.{u_3} (n + 1)) â†’ TypeVec.Arrow v v' â†’ Sort u_1} â†’\n    ((t : Type u_2) â†’\n        (t' : Type u_3) â†’\n          (f : t â†’ t') â†’\n            (v : TypeVec.{u_2} n) â†’\n              (v' : TypeVec.{u_3} n) â†’ (fs : TypeVec.Arrow v v') â†’ Î² (v ::: t) (v' ::: t') (fs ::: f)) â†’\n      (v : TypeVec.{u_2} (n + 1)) â†’ (v' : TypeVec.{u_3} (n + 1)) â†’ (fs : TypeVec.Arrow v v') â†’ Î² v v' fs",
    "name": "TypeVec.typevecCasesConsâ‚ƒ",
    "isProp": false,
    "doc":
    "cases distinction for an arrow in the category of (n+1)-length type vectors ",
    "depth": 17},
   {"type":
    "(n : â„•) â†’\n  (t : Type u_1) â†’\n    (t' : Type u_2) â†’\n      (v : TypeVec.{u_1} n) â†’\n        (v' : TypeVec.{u_2} n) â†’\n          {Î² : TypeVec.Arrow (v ::: t) (v' ::: t') â†’ Sort u_3} â†’\n            ((f : t â†’ t') â†’ (fs : TypeVec.Arrow v v') â†’ Î² (fs ::: f)) â†’\n              (fs : TypeVec.Arrow (v ::: t) (v' ::: t')) â†’ Î² fs",
    "name": "TypeVec.typevecCasesConsâ‚‚",
    "isProp": false,
    "doc":
    "specialized cases distinction for an arrow in the category of (n+1)-length type vectors ",
    "depth": 17},
   {"type":
    "{n : â„•} â†’\n  {F : TypeVec.{u} (n + 1) â†’ Type u} â†’\n    [inst : MvFunctor F] â†’\n      [q : MvQPF F] â†’\n        {Î± : TypeVec.{u} n} â†’\n          {Î² : MvQPF.Fix F Î± â†’ Type u} â†’\n            ((x : F (Î± ::: Sigma Î²)) â†’ Î² (MvQPF.Fix.mk (MvFunctor.map (TypeVec.id ::: Sigma.fst) x))) â†’\n              (x : MvQPF.Fix F Î±) â†’ Î² x",
    "name": "MvQPF.Fix.drec",
    "isProp": false,
    "doc": "Dependent recursor for `fix F` ",
    "depth": 23}],
  "count": 35},
 {"noDocExamples": [],
  "kind": "Polynomial.Â«term_/â‚˜_Â»",
  "examples":
  [{"type":
    "âˆ€ {R : Type u} [inst : CommRing R] {p q : Polynomial R},\n  Polynomial.Monic q â†’\n    Polynomial.degree q â‰¤ Polynomial.degree p â†’ Polynomial.leadingCoeff (p /â‚˜ q) = Polynomial.leadingCoeff p",
    "name": "Polynomial.leadingCoeff_divByMonic_of_monic",
    "isProp": true,
    "doc":
    "Division by a monic polynomial doesn't change the leading coefficient. ",
    "depth": 14},
   {"type":
    "âˆ€ {R : Type u_1} [inst : CommRing R] {n : â„•},\n  0 < n â†’\n    Polynomial.cyclotomic n R =\n      (Polynomial.X ^ n - 1) /â‚˜ Finset.prod (Nat.properDivisors n) fun i => Polynomial.cyclotomic i R",
    "name": "Polynomial.cyclotomic_eq_X_pow_sub_one_div",
    "isProp": true,
    "doc":
    "We have\n`cyclotomic n R = (X ^ k - 1) /â‚˜ (âˆ i in Nat.properDivisors k, cyclotomic i K)`. ",
    "depth": 21},
   {"type":
    "âˆ€ {K : Type u_2} [inst : CommRing K] [inst_1 : IsDomain K] {Î¶ : K} {n : â„•},\n  0 < n â†’\n    IsPrimitiveRoot Î¶ n â†’\n      Polynomial.cyclotomic' n K =\n        (Polynomial.X ^ n - 1) /â‚˜ Finset.prod (Nat.properDivisors n) fun i => Polynomial.cyclotomic' i K",
    "name": "Polynomial.cyclotomic'_eq_X_pow_sub_one_div",
    "isProp": true,
    "doc":
    "If there is a primitive `n`-th root of unity in `K`, then\n`cyclotomic' n K = (X ^ k - 1) /â‚˜ (âˆ i in Nat.properDivisors k, cyclotomic' i K)`. ",
    "depth": 24}],
  "count": 35},
 {"noDocExamples": [],
  "kind": "Sigma.Lex.Â«termÎ£â‚—_,_Â»",
  "examples":
  [{"type":
    "{Î¹ : Type u_1} â†’ {Î± : Î¹ â†’ Type u_2} â†’ [inst : LT Î¹] â†’ [inst : (i : Î¹) â†’ LT (Î± i)] â†’ LT (Î£â‚— (i : Î¹), Î± i)",
    "name": "Sigma.Lex.LT",
    "isProp": false,
    "doc": "The lexicographical `<` on a sigma type. ",
    "depth": 9},
   {"type":
    "{Î¹ : Type u_1} â†’\n  {Î± : Î¹ â†’ Type u_2} â†’ [inst : Preorder Î¹] â†’ [inst : (i : Î¹) â†’ Preorder (Î± i)] â†’ Preorder (Î£â‚— (i : Î¹), Î± i)",
    "name": "Sigma.Lex.preorder",
    "isProp": false,
    "doc": "The lexicographical preorder on a sigma type. ",
    "depth": 9},
   {"type":
    "{Î¹ : Type u_1} â†’\n  {Î± : Î¹ â†’ Type u_2} â†’ [inst : Preorder Î¹] â†’ [inst : (i : Î¹) â†’ PartialOrder (Î± i)] â†’ PartialOrder (Î£â‚— (i : Î¹), Î± i)",
    "name": "Sigma.Lex.partialOrder",
    "isProp": false,
    "doc": "The lexicographical partial order on a sigma type. ",
    "depth": 9}],
  "count": 35},
 {"noDocExamples": [],
  "kind": "Â«term_/â‚š_Â»",
  "examples":
  [{"type": "âˆ€ {Î± : Type u} [inst : Monoid Î±] (u : Î±Ë£), â†‘uâ»Â¹ = 1 /â‚š u",
    "name": "inv_eq_one_divp",
    "isProp": true,
    "doc": "Used for `field_simp` to deal with inverses of units. ",
    "depth": 11},
   {"type":
    "âˆ€ {Î± : Type u} [inst : Monoid Î±] (x y : Î±) (u : Î±Ë£), x * (y /â‚š u) = x * y /â‚š u",
    "name": "divp_assoc'",
    "isProp": true,
    "doc":
    "`field_simp` needs the reverse direction of `divp_assoc` to move all `/â‚š` to the right. ",
    "depth": 15},
   {"type":
    "âˆ€ {Î± : Type u} [inst : Monoid Î±] (uâ‚ uâ‚‚ : Î±Ë£), â†‘(uâ‚ / uâ‚‚) = â†‘uâ‚ /â‚š uâ‚‚",
    "name": "val_div_eq_divp",
    "isProp": true,
    "doc":
    "`field_simp` moves division inside `Î±Ë£` to the right, and this lemma\nlifts the calculation to `Î±`.\n",
    "depth": 16}],
  "count": 34},
 {"noDocExamples": [],
  "kind": "PSigma.Â«termÎ£â‚—'_,_Â»",
  "examples":
  [{"type":
    "{Î¹ : Type u_1} â†’\n  {Î± : Î¹ â†’ Type u_2} â†’ [inst : LinearOrder Î¹] â†’ [inst : (i : Î¹) â†’ LinearOrder (Î± i)] â†’ LinearOrder (Î£â‚—' (i : Î¹), Î± i)",
    "name": "PSigma.Lex.linearOrder",
    "isProp": false,
    "doc": "Dictionary / lexicographic linear_order for pairs. ",
    "depth": 9},
   {"type":
    "{Î¹ : Type u_1} â†’\n  {Î± : Î¹ â†’ Type u_2} â†’ [inst : PartialOrder Î¹] â†’ [inst : (i : Î¹) â†’ PartialOrder (Î± i)] â†’ PartialOrder (Î£â‚—' (i : Î¹), Î± i)",
    "name": "PSigma.Lex.partialOrder",
    "isProp": false,
    "doc": "Dictionary / lexicographic partial_order for dependent pairs. ",
    "depth": 9},
   {"type":
    "{Î¹ : Type u_1} â†’ {Î± : Î¹ â†’ Type u_2} â†’ [inst : LT Î¹] â†’ [inst : (i : Î¹) â†’ LT (Î± i)] â†’ LT (Î£â‚—' (i : Î¹), Î± i)",
    "name": "PSigma.Lex.lt",
    "isProp": false,
    "doc": "The lexicographical `<` on a sigma type. ",
    "depth": 9}],
  "count": 34},
 {"noDocExamples": [],
  "kind": "FirstOrder.Language.Â«term_â‰ƒá´¸_Â»",
  "examples":
  [{"type": "(L : FirstOrder.Language) â†’ L â‰ƒá´¸ L",
    "name": "FirstOrder.Language.LEquiv.refl",
    "isProp": false,
    "doc": "The identity equivalence from a first-order language to itself. ",
    "depth": 3},
   {"type":
    "{L : FirstOrder.Language} â†’ {L' : FirstOrder.Language} â†’ (L â‰ƒá´¸ L') â†’ (L' â‰ƒá´¸ L)",
    "name": "FirstOrder.Language.LEquiv.symm",
    "isProp": false,
    "doc": "The inverse of an equivalence of first-order languages. ",
    "depth": 5},
   {"type":
    "{L : FirstOrder.Language} â†’\n  {L' : FirstOrder.Language} â†’ (L â‰ƒá´¸ L') â†’ FirstOrder.Language.Sentence L â‰ƒ FirstOrder.Language.Sentence L'",
    "name": "FirstOrder.Language.LEquiv.onSentence",
    "isProp": false,
    "doc": "Maps a sentence's symbols along a language equivalence. ",
    "depth": 6}],
  "count": 34},
 {"noDocExamples": [],
  "kind": "CategoryTheory.exp.Â«term_âŸ¹_Â»",
  "examples":
  [{"type":
    "{C : Type u} â†’\n  [inst : CategoryTheory.Category.{v, u} C] â†’\n    {A Y : C} â†’\n      [inst_1 : CategoryTheory.Limits.HasFiniteProducts C] â†’\n        [inst_2 : CategoryTheory.Exponentiable A] â†’ (A âŸ¶ Y) â†’ (âŠ¤_ C âŸ¶ A âŸ¹ Y)",
    "name": "CategoryTheory.internalizeHom",
    "isProp": false,
    "doc": "The internal element which points at the given morphism. ",
    "depth": 16},
   {"type":
    "{C : Type u} â†’\n  [inst : CategoryTheory.Category.{v, u} C] â†’\n    {X : C} â†’\n      [inst_1 : CategoryTheory.Limits.HasFiniteProducts C] â†’\n        [inst_2 : CategoryTheory.Exponentiable (âŠ¤_ C)] â†’ (âŠ¤_ C) âŸ¹ X â‰… X",
    "name": "CategoryTheory.expTerminalIsoSelf",
    "isProp": false,
    "doc":
    "Show that the exponential of the terminal object is isomorphic to itself, i.e. `X^1 â‰… X`.\n\nThe typeclass argument is explicit: any instance can be used.\n",
    "depth": 19},
   {"type":
    "âˆ€ {C : Type uâ‚} {D : Type uâ‚‚} [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] [inst_1 : CategoryTheory.Category.{vâ‚, uâ‚‚} D]\n  (i : CategoryTheory.Functor D C) [inst_2 : CategoryTheory.Limits.HasFiniteProducts C]\n  [inst_3 : CategoryTheory.CartesianClosed C],\n  (âˆ€ (B : D) (A : C), (A âŸ¹ i.obj B) âˆˆ CategoryTheory.Functor.essImage i) â†’ CategoryTheory.ExponentialIdeal i",
    "name": "CategoryTheory.ExponentialIdeal.mk'",
    "isProp": true,
    "doc":
    "To show `i` is an exponential ideal it suffices to show that `A âŸ¹ iB` is \"in\" `D` for any `A` in\n`C` and `B` in `D`.\n",
    "depth": 24}],
  "count": 33},
 {"noDocExamples": [],
  "kind": "MeasureTheory.Â«termâ¨_In_,_âˆ‚_Â»",
  "examples":
  [{"type":
    "âˆ€ {Î± : Type u_1} {m0 : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {s : Set Î±} {f : Î± â†’ â„},\n  â†‘â†‘Î¼ s â‰  0 â†’ â†‘â†‘Î¼ s â‰  âŠ¤ â†’ MeasureTheory.IntegrableOn f s â†’ âˆƒ x âˆˆ s, f x â‰¤ â¨ (a : Î±) in s, f a âˆ‚Î¼",
    "name": "MeasureTheory.exists_le_setAverage",
    "isProp": true,
    "doc":
    "**First moment method**. The minimum of an integrable function is smaller than its mean. ",
    "depth": 19},
   {"type":
    "âˆ€ {Î± : Type u_1} {m0 : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {s : Set Î±} {f : Î± â†’ â„},\n  â†‘â†‘Î¼ s â‰  0 â†’ â†‘â†‘Î¼ s â‰  âŠ¤ â†’ MeasureTheory.IntegrableOn f s â†’ âˆƒ x âˆˆ s, â¨ (a : Î±) in s, f a âˆ‚Î¼ â‰¤ f x",
    "name": "MeasureTheory.exists_setAverage_le",
    "isProp": true,
    "doc":
    "**First moment method**. The maximum of an integrable function is greater than its mean. ",
    "depth": 20},
   {"type":
    "âˆ€ {Î± : Type u_1} {m0 : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {s : Set Î±} {f : Î± â†’ â„},\n  â†‘â†‘Î¼ s â‰  0 â†’ â†‘â†‘Î¼ s â‰  âŠ¤ â†’ MeasureTheory.IntegrableOn f s â†’ 0 < â†‘â†‘Î¼ {x | x âˆˆ s âˆ§ f x â‰¤ â¨ (a : Î±) in s, f a âˆ‚Î¼}",
    "name": "MeasureTheory.measure_le_setAverage_pos",
    "isProp": true,
    "doc":
    "**First moment method**. An integrable function is smaller than its mean on a set of positive\nmeasure. ",
    "depth": 21}],
  "count": 33},
 {"noDocExamples": [],
  "kind": "Â«term_â»Â¹'o_Â»",
  "examples":
  [{"type":
    "{Î± : Type u_1} â†’ {Î² : Type u_2} â†’ (f : Î± â†’ Î²) â†’ (s : Î² â†’ Î² â†’ Prop) â†’ f â»Â¹'o s â†’r s",
    "name": "RelHom.preimage",
    "isProp": false,
    "doc":
    "A function is a relation homomorphism from the preimage relation of `s` to `s`. ",
    "depth": 10},
   {"type":
    "{Î± : Sort u_3} â†’ {Î² : Sort u_4} â†’ (f : Î± â†’ Î²) â†’ (s : Î² â†’ Î² â†’ Prop) â†’ [H : DecidableRel s] â†’ DecidableRel (f â»Â¹'o s)",
    "name": "Order.Preimage.decidable",
    "isProp": false,
    "doc": "The preimage of a decidable order is decidable. ",
    "depth": 10},
   {"type":
    "{X : Type u_5} â†’ (r : X â†’ X â†’ Prop) â†’ (p : X â†’ Prop) â†’ Subtype.val â»Â¹'o r â†ªr r",
    "name": "Subtype.relEmbedding",
    "isProp": false,
    "doc":
    "The induced relation on a subtype is an embedding under the natural inclusion. ",
    "depth": 11}],
  "count": 33},
 {"noDocExamples": [],
  "kind": "Â«term_âŠ•'_Â»",
  "examples":
  [{"type": "(Î± : Type u_4) â†’ Fintype Î± âŠ•' Infinite Î±",
    "name": "fintypeOrInfinite",
    "isProp": false,
    "doc":
    "Any type is (classically) either a `Fintype`, or `Infinite`.\n\nOne can obtain the relevant typeclasses via `cases fintypeOrInfinite Î±`.\n",
    "depth": 4},
   {"type": "{Î± : Sort u} â†’ {Î² : Sort v} â†’ Î± â†’ Î± âŠ•' Î²",
    "name": "PSum.inl",
    "isProp": false,
    "doc":
    "Left injection into the sum type `Î± âŠ•' Î²`. If `a : Î±` then `.inl a : Î± âŠ•' Î²`. ",
    "depth": 5},
   {"type": "(Î± : Type u_3) â†’ [inst : Inhabited Î±] â†’ Nontrivial Î± âŠ•' Unique Î±",
    "name": "nontrivialPSumUnique",
    "isProp": false,
    "doc": "An inhabited type is either nontrivial, or has a unique element. ",
    "depth": 5}],
  "count": 33},
 {"noDocExamples": [],
  "kind": "AlgebraicGeometry.Â«term_âˆ£__Â»",
  "examples":
  [{"type":
    "âˆ€ {P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme},\n  AlgebraicGeometry.PropertyIsLocalAtTarget P â†’\n    âˆ€ {X Y : AlgebraicGeometry.Scheme} (f : X âŸ¶ Y) (U : TopologicalSpace.Opens â†‘â†‘Y.toPresheafedSpace), P f â†’ P (f âˆ£_ U)",
    "name": "AlgebraicGeometry.PropertyIsLocalAtTarget.restrict",
    "isProp": true,
    "doc":
    "If `P` holds for `f : X âŸ¶ Y`, then `P` holds for `f âˆ£_ U` for any `U`. ",
    "depth": 34},
   {"type":
    "âˆ€ {P : AlgebraicGeometry.AffineTargetMorphismProperty},\n  AlgebraicGeometry.AffineTargetMorphismProperty.IsLocal P â†’\n    âˆ€ {X Y : AlgebraicGeometry.Scheme} [inst : AlgebraicGeometry.IsAffine Y] (f : X âŸ¶ Y)\n      (r : â†‘(Y.presheaf.obj (Opposite.op âŠ¤))), P f â†’ P (f âˆ£_ Y.basicOpen r)",
    "name":
    "AlgebraicGeometry.AffineTargetMorphismProperty.IsLocal.toBasicOpen",
    "isProp": true,
    "doc":
    "`P` is stable under restriction to basic open set of global sections. ",
    "depth": 36},
   {"type":
    "âˆ€ {P : AlgebraicGeometry.AffineTargetMorphismProperty},\n  AlgebraicGeometry.AffineTargetMorphismProperty.IsLocal P â†’\n    âˆ€ {X Y : AlgebraicGeometry.Scheme} [inst : AlgebraicGeometry.IsAffine Y] (f : X âŸ¶ Y)\n      (s : Finset â†‘(Y.presheaf.obj (Opposite.op âŠ¤))),\n      Ideal.span â†‘s = âŠ¤ â†’ (âˆ€ (r : { x // x âˆˆ s }), P (f âˆ£_ Y.basicOpen â†‘r)) â†’ P f",
    "name":
    "AlgebraicGeometry.AffineTargetMorphismProperty.IsLocal.ofBasicOpenCover",
    "isProp": true,
    "doc":
    "`P` for `f` if `P` holds for `f` restricted to basic sets of a spanning set of the global\nsections ",
    "depth": 50}],
  "count": 32},
 {"noDocExamples": [],
  "kind": "Â«term_â‰ƒSL[_]_Â»",
  "examples":
  [{"type":
    "âˆ€ {R : Type u_1} {S : Type u_2} [inst : Semiring R] [inst_1 : Semiring S] {Ïƒ : R â†’+* S} {Ïƒ' : S â†’+* R}\n  [inst_2 : RingHomInvPair Ïƒ Ïƒ'] [inst_3 : RingHomInvPair Ïƒ' Ïƒ] {M : Type u_3} [inst_4 : TopologicalSpace M]\n  [inst_5 : AddCommMonoid M] {Mâ‚‚ : Type u_4} [inst_6 : TopologicalSpace Mâ‚‚] [inst_7 : AddCommMonoid Mâ‚‚]\n  [inst_8 : Module R M] [inst_9 : Module S Mâ‚‚] (self : M â‰ƒSL[Ïƒ] Mâ‚‚), Continuous self.invFun",
    "name": "ContinuousLinearEquiv.continuous_invFun",
    "isProp": true,
    "doc":
    "Continuous linear equivalences between modules. We only put the type classes that are necessary\nfor the definition, although in applications `M` and `Mâ‚‚` will be topological modules over the\ntopological semiring `R`. ",
    "depth": 36},
   {"type":
    "{R : Type u_1} â†’\n  {Râ‚‚ : Type u_2} â†’\n    {E : Type u_5} â†’\n      {Eâ‚‚ : Type u_6} â†’\n        [inst : Semiring R] â†’\n          [inst_1 : Semiring Râ‚‚] â†’\n            {Ïƒâ‚â‚‚ : R â†’+* Râ‚‚} â†’\n              {Ïƒâ‚‚â‚ : Râ‚‚ â†’+* R} â†’\n                [inst_2 : RingHomInvPair Ïƒâ‚â‚‚ Ïƒâ‚‚â‚] â†’\n                  [inst_3 : RingHomInvPair Ïƒâ‚‚â‚ Ïƒâ‚â‚‚] â†’\n                    [inst_4 : SeminormedAddCommGroup E] â†’\n                      [inst_5 : SeminormedAddCommGroup Eâ‚‚] â†’\n                        [inst_6 : Module R E] â†’ [inst_7 : Module Râ‚‚ Eâ‚‚] â†’ (E â‰ƒâ‚›â‚—áµ¢[Ïƒâ‚â‚‚] Eâ‚‚) â†’ E â‰ƒSL[Ïƒâ‚â‚‚] Eâ‚‚",
    "name": "LinearIsometryEquiv.toContinuousLinearEquiv",
    "isProp": false,
    "doc": "Interpret a `LinearIsometryEquiv` as a `ContinuousLinearEquiv`. ",
    "depth": 31},
   {"type":
    "{Râ‚ : Type u_1} â†’\n  {Râ‚‚ : Type u_2} â†’\n    [inst : Semiring Râ‚] â†’\n      [inst_1 : Semiring Râ‚‚] â†’\n        {Ïƒâ‚â‚‚ : Râ‚ â†’+* Râ‚‚} â†’\n          {Ïƒâ‚‚â‚ : Râ‚‚ â†’+* Râ‚} â†’\n            [inst_2 : RingHomInvPair Ïƒâ‚â‚‚ Ïƒâ‚‚â‚] â†’\n              [inst_3 : RingHomInvPair Ïƒâ‚‚â‚ Ïƒâ‚â‚‚] â†’\n                {Mâ‚ : Type u_4} â†’\n                  [inst_4 : TopologicalSpace Mâ‚] â†’\n                    [inst_5 : AddCommMonoid Mâ‚] â†’\n                      {Mâ‚‚ : Type u_6} â†’\n                        [inst_6 : TopologicalSpace Mâ‚‚] â†’\n                          [inst_7 : AddCommMonoid Mâ‚‚] â†’\n                            [inst_8 : Module Râ‚ Mâ‚] â†’ [inst_9 : Module Râ‚‚ Mâ‚‚] â†’ (Mâ‚ â‰ƒSL[Ïƒâ‚â‚‚] Mâ‚‚) â†’ Mâ‚‚ â†’ Mâ‚",
    "name": "ContinuousLinearEquiv.Simps.symm_apply",
    "isProp": false,
    "doc": "See Note [custom simps projection] ",
    "depth": 33}],
  "count": 32},
 {"noDocExamples":
  [{"type": "âˆ€ {Î± : Type u_1} (l : List Î±), [] <:+: l",
    "name": "List.nil_infix",
    "isProp": true,
    "depth": 5}],
  "kind": "List.Â«term_<:+:_Â»",
  "examples":
  [{"type": "âˆ€ {Î± : Type u_1} {l : List Î±}, l <:+: [] â†’ l = []",
    "name": "List.eq_nil_of_infix_nil",
    "isProp": true,
    "doc": "**Alias** of the forward direction of `List.infix_nil`.",
    "depth": 7},
   {"type":
    "âˆ€ {Î± : Type u_1} {lâ‚ lâ‚‚ : List Î±}, lâ‚ <:+: lâ‚‚ â†’ List.reverse lâ‚ <:+: List.reverse lâ‚‚",
    "name": "List.isInfix.reverse",
    "isProp": true,
    "doc": "**Alias** of the reverse direction of `List.reverse_infix`.",
    "depth": 8}],
  "count": 30},
 {"noDocExamples": [],
  "kind": "Â«term_<<<_Â»",
  "examples":
  [{"type": "âˆ€ (m n : â„•), Nat.shiftLeft m n = m <<< n",
    "name": "Nat.shiftLeft_eq'",
    "isProp": true,
    "doc":
    "Std4 takes the unprimed name for `Nat.shiftLeft_eq m n : m <<< n = m * 2 ^ n`. ",
    "depth": 9},
   {"type": "âˆ€ (m n : â„•), m <<< (n + 1) = (2 * m) <<< n",
    "name": "Nat.shiftLeft_succ_inside",
    "isProp": true,
    "doc": "Shiftleft on successor with multiple moved inside. ",
    "depth": 11},
   {"type": "âˆ€ (m n : â„•), m <<< (n + 1) = 2 * m <<< n",
    "name": "Nat.shiftLeft_succ",
    "isProp": true,
    "doc": "Shiftleft on successor with multiple moved to outside. ",
    "depth": 11}],
  "count": 30},
 {"noDocExamples":
  [{"type":
    "âˆ€ {V : Type u} [inst : Quiver V],\n  CategoryTheory.Groupoid.Free.of V =\n    Quiver.Symmetrify.of â‹™q CategoryTheory.Paths.of â‹™q\n      (CategoryTheory.Quotient.functor CategoryTheory.Groupoid.Free.redStep).toPrefunctor",
    "name": "CategoryTheory.Groupoid.Free.of_eq",
    "isProp": true,
    "depth": 14},
   {"type":
    "âˆ€ {U : Type u_1} {V : Type u_2} [inst : Quiver U] [inst_1 : Quiver V] (F : U â¥¤q V), ğŸ­q U â‹™q F = F",
    "name": "Prefunctor.id_comp",
    "isProp": true,
    "depth": 15}],
  "kind": "Prefunctor.Â«term_â‹™q_Â»",
  "examples":
  [{"type":
    "âˆ€ {V : Type u_2} [inst : Quiver V] {V' : Type u_4} [inst_1 : Quiver V'] [inst_2 : Quiver.HasReverse V'] (Ï† : V â¥¤q V')\n  (Î¦ : Quiver.Symmetrify V â¥¤q V'),\n  Quiver.Symmetrify.of â‹™q Î¦ = Ï† â†’\n    (âˆ€ {X Y : Quiver.Symmetrify V} (f : X âŸ¶ Y), Î¦.map (Quiver.reverse f) = Quiver.reverse (Î¦.map f)) â†’\n      Î¦ = Quiver.Symmetrify.lift Ï†",
    "name": "Quiver.Symmetrify.lift_unique",
    "isProp": true,
    "doc":
    "`lift Ï†` is the only prefunctor extending `Ï†` and preserving reverses. ",
    "depth": 24}],
  "count": 29},
 {"noDocExamples": [],
  "kind": "SimpleGraph.Â«term_â–¡_Â»",
  "examples":
  [{"type":
    "{Î± : Type u_1} â†’ {Î² : Type u_2} â†’ (G : SimpleGraph Î±) â†’ (H : SimpleGraph Î²) â†’ G â–¡ H â‰ƒg H â–¡ G",
    "name": "SimpleGraph.boxProdComm",
    "isProp": false,
    "doc":
    "The box product is commutative up to isomorphism. `Equiv.prodComm` as a graph isomorphism. ",
    "depth": 10},
   {"type":
    "{Î± : Type u_1} â†’ {Î² : Type u_2} â†’ (G : SimpleGraph Î±) â†’ (H : SimpleGraph Î²) â†’ Î² â†’ G â†ªg G â–¡ H",
    "name": "SimpleGraph.boxProdLeft",
    "isProp": false,
    "doc": "The embedding of `G` into `G â–¡ H` given by `b`. ",
    "depth": 10},
   {"type":
    "{Î± : Type u_1} â†’ {Î² : Type u_2} â†’ (G : SimpleGraph Î±) â†’ (H : SimpleGraph Î²) â†’ Î± â†’ H â†ªg G â–¡ H",
    "name": "SimpleGraph.boxProdRight",
    "isProp": false,
    "doc": "The embedding of `H` into `G â–¡ H` given by `a`. ",
    "depth": 10}],
  "count": 27},
 {"noDocExamples":
  [{"type": "âˆ€ {Î± : Type u} (s : Stream'.WSeq Î±), s ~Ê· s",
    "name": "Stream'.WSeq.Equiv.refl",
    "isProp": true,
    "depth": 5},
   {"type": "âˆ€ {Î± : Type u} (s : Stream'.WSeq Î±), Stream'.WSeq.think s ~Ê· s",
    "name": "Stream'.WSeq.think_equiv",
    "isProp": true,
    "depth": 6},
   {"type": "âˆ€ {Î± : Type u} {s t : Stream'.WSeq Î±}, s ~Ê· t â†’ t ~Ê· s",
    "name": "Stream'.WSeq.Equiv.symm",
    "isProp": true,
    "depth": 7}],
  "kind": "Stream'.WSeq.Â«term_~Ê·_Â»",
  "examples": [],
  "count": 27},
 {"noDocExamples": [],
  "kind": "MeasureTheory.Â«termâˆ€áµ_,_Â»",
  "examples":
  [{"type":
    "âˆ€ (f : StieltjesFunction),\n  âˆ€áµ (x : â„),\n    HasDerivAt (â†‘f)\n      (ENNReal.toReal (MeasureTheory.Measure.rnDeriv (StieltjesFunction.measure f) MeasureTheory.volume x)) x",
    "name": "StieltjesFunction.ae_hasDerivAt",
    "isProp": true,
    "doc":
    "A Stieltjes function is almost everywhere differentiable, with derivative equal to the\nRadon-Nikodym derivative of the associated Stieltjes measure with respect to Lebesgue. ",
    "depth": 13},
   {"type":
    "âˆ€ {f : â„ â†’ â„} (hf : Monotone f),\n  âˆ€áµ (x : â„),\n    HasDerivAt f\n      (ENNReal.toReal\n        (MeasureTheory.Measure.rnDeriv (StieltjesFunction.measure (Monotone.stieltjesFunction hf)) MeasureTheory.volume\n          x))\n      x",
    "name": "Monotone.ae_hasDerivAt",
    "isProp": true,
    "doc":
    "A monotone function is almost everywhere differentiable, with derivative equal to the\nRadon-Nikodym derivative of the associated Stieltjes measure with respect to Lebesgue. ",
    "depth": 14},
   {"type": "âˆ€ {f : â„ â†’ â„}, Monotone f â†’ âˆ€áµ (x : â„), DifferentiableAt â„ f x",
    "name": "Monotone.ae_differentiableAt",
    "isProp": true,
    "doc":
    "A monotone real function is differentiable Lebesgue-almost everywhere. ",
    "depth": 16}],
  "count": 26},
 {"noDocExamples": [],
  "kind": "Â«term_â†’CO_Â»",
  "examples":
  [{"type": "(Î± : Type u_2) â†’ [inst : TopologicalSpace Î±] â†’ Î± â†’CO Î±",
    "name": "ContinuousOpenMap.id",
    "isProp": false,
    "doc": "`id` as a `ContinuousOpenMap`. ",
    "depth": 6},
   {"type":
    "{Î± : Type u_2} â†’\n  {Î² : Type u_3} â†’\n    {Î³ : Type u_4} â†’\n      [inst : TopologicalSpace Î±] â†’\n        [inst_1 : TopologicalSpace Î²] â†’ [inst_2 : TopologicalSpace Î³] â†’ (Î² â†’CO Î³) â†’ (Î± â†’CO Î²) â†’ Î± â†’CO Î³",
    "name": "ContinuousOpenMap.comp",
    "isProp": false,
    "doc": "Composition of `ContinuousOpenMap`s as a `ContinuousOpenMap`. ",
    "depth": 12},
   {"type":
    "{Î± : Type u_2} â†’\n  {Î² : Type u_3} â†’\n    [inst : TopologicalSpace Î±] â†’ [inst_1 : TopologicalSpace Î²] â†’ (f : Î± â†’CO Î²) â†’ (f' : Î± â†’ Î²) â†’ f' = â‡‘f â†’ Î± â†’CO Î²",
    "name": "ContinuousOpenMap.copy",
    "isProp": false,
    "doc":
    "Copy of a `ContinuousOpenMap` with a new `ContinuousMap` equal to the old one. Useful to fix\ndefinitional equalities. ",
    "depth": 21}],
  "count": 26},
 {"noDocExamples":
  [{"type":
    "âˆ€ {Î± : Type u_1} {M : Matroid Î±} [inst : Matroid.Finite M], Matroid.Finite Mï¹¡",
    "name": "Matroid.dual_finite",
    "isProp": true,
    "depth": 6},
   {"type":
    "âˆ€ {Î± : Type u_1} {M : Matroid Î±} [inst : Matroid.Nonempty M], Matroid.Nonempty Mï¹¡",
    "name": "Matroid.dual_nonempty",
    "isProp": true,
    "depth": 6},
   {"type":
    "âˆ€ {Î± : Type u_1} (M : Matroid Î±) [h : Matroid.RkPos Mï¹¡], Â¬M.Base M.E",
    "name": "Matroid.ground_not_base",
    "isProp": true,
    "depth": 7}],
  "kind": "Matroid.Â«term_ï¹¡Â»",
  "examples": [],
  "count": 25},
 {"noDocExamples": [],
  "kind": "Function.Â«termâ†¿_Â»",
  "examples":
  [{"type":
    "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²]\n  [inst_2 : WeaklyLocallyCompactSpace Î±] [inst_3 : CompactSpace Î²] [inst_4 : UniformSpace Î³] (f : Î± â†’ Î² â†’ Î³),\n  Continuous â†¿f â†’ âˆ€ (x : Î±), TendstoUniformly f (f x) (nhds x)",
    "name": "Continuous.tendstoUniformly",
    "isProp": true,
    "doc":
    "A continuous family of functions `Î± â†’ Î² â†’ Î³` tends uniformly to its value at `x`\nif `Î±` is weakly locally compact and `Î²` is compact. ",
    "depth": 18},
   {"type":
    "âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {p : Filter Î¹} {c : Î²},\n  Filter.Tendsto (â†¿F) (p Ã—Ë¢ âŠ¤) (nhds c) â†” TendstoUniformly F (fun x => c) p",
    "name": "tendsto_prod_top_iff",
    "isProp": true,
    "doc":
    "Uniform convergence to a constant function is equivalent to convergence in `p Ã—Ë¢ âŠ¤`. ",
    "depth": 19},
   {"type":
    "âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {s : Set Î±} {p : Filter Î¹} {c : Î²},\n  Filter.Tendsto (â†¿F) (p Ã—Ë¢ Filter.principal s) (nhds c) â†” TendstoUniformlyOn F (fun x => c) p s",
    "name": "tendsto_prod_principal_iff",
    "isProp": true,
    "doc":
    "Uniform convergence on a set `s` to a constant function is equivalent to convergence in\n`p Ã—Ë¢ ğ“Ÿ s`. ",
    "depth": 20}],
  "count": 24},
 {"noDocExamples": [],
  "kind": "CategoryTheory.MonoidalOpposite.Â«term_á´¹áµ’áµ–Â»",
  "examples":
  [{"type": "{C : Type uâ‚} â†’ Cá´¹áµ’áµ– â†’ C",
    "name": "CategoryTheory.MonoidalOpposite.unmop",
    "isProp": false,
    "doc": "Think of an object of `Cá´¹áµ’áµ–` as an object of `C`. ",
    "depth": 3},
   {"type": "{C : Type uâ‚} â†’ C â†’ Cá´¹áµ’áµ–",
    "name": "CategoryTheory.MonoidalOpposite.mop",
    "isProp": false,
    "doc": "Think of an object of `C` as an object of `Cá´¹áµ’áµ–`. ",
    "depth": 3},
   {"type":
    "{C : Type uâ‚} â†’\n  [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] â†’\n    {X Y : Cá´¹áµ’áµ–} â†’ (X âŸ¶ Y) â†’ (CategoryTheory.MonoidalOpposite.unmop X âŸ¶ CategoryTheory.MonoidalOpposite.unmop Y)",
    "name": "Quiver.Hom.unmop",
    "isProp": false,
    "doc":
    "We can think of a morphism `f : mop X âŸ¶ mop Y` as a morphism `X âŸ¶ Y`. ",
    "depth": 12}],
  "count": 24},
 {"noDocExamples": [],
  "kind": "Â«term_â†’r_Â»",
  "examples":
  [{"type":
    "âˆ€ {Î± : Type u_1} {Î² : Type u_2} {r : Î± â†’ Î± â†’ Prop} {s : Î² â†’ Î² â†’ Prop} [inst : IsTrichotomous Î± r] [inst : IsIrrefl Î² s]\n  (f : r â†’r s), Function.Injective â‡‘f",
    "name": "RelHom.injective_of_increasing",
    "isProp": true,
    "doc": "An increasing function is injective ",
    "depth": 20},
   {"type": "{Î± : Type u_1} â†’ (r : Î± â†’ Î± â†’ Prop) â†’ r â†’r r",
    "name": "RelHom.id",
    "isProp": false,
    "doc": "Identity map is a relation homomorphism. ",
    "depth": 6},
   {"type":
    "{Î± : Type u_1} â†’ {Î² : Type u_2} â†’ {r : Î± â†’ Î± â†’ Prop} â†’ {s : Î² â†’ Î² â†’ Prop} â†’ r â†ªr s â†’ r â†’r s",
    "name": "RelEmbedding.toRelHom",
    "isProp": false,
    "doc": "A relation embedding is also a relation homomorphism ",
    "depth": 9}],
  "count": 24},
 {"noDocExamples":
  [{"type":
    "âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] [inst_1 : CategoryTheory.MonoidalCategory C] (X Y : C)\n  [inst_2 : CategoryTheory.ExactPairing X Y],\n  CategoryTheory.CategoryStruct.comp\n      (CategoryTheory.MonoidalCategory.tensorHom (Î·_ X Y) (CategoryTheory.CategoryStruct.id X))\n      (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.associator X Y X).hom\n        (CategoryTheory.MonoidalCategory.tensorHom (CategoryTheory.CategoryStruct.id X) (Îµ_ X Y))) =\n    CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.leftUnitor X).hom\n      (CategoryTheory.MonoidalCategory.rightUnitor X).inv",
    "name": "CategoryTheory.ExactPairing.evaluation_coevaluation",
    "isProp": true,
    "depth": 22},
   {"type":
    "âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] [inst_1 : CategoryTheory.MonoidalCategory C] {X Y : C}\n  [inst_2 : CategoryTheory.HasLeftDual X] [inst_3 : CategoryTheory.HasLeftDual Y] (f : X âŸ¶ Y),\n  CategoryTheory.CategoryStruct.comp\n      (CategoryTheory.MonoidalCategory.tensorHom (CategoryTheory.CategoryStruct.id X) (á˜f)) (Îµ_ (á˜X) X) =\n    CategoryTheory.CategoryStruct.comp\n      (CategoryTheory.MonoidalCategory.tensorHom f (CategoryTheory.CategoryStruct.id á˜Y)) (Îµ_ (á˜Y) Y)",
    "name": "CategoryTheory.leftAdjointMate_comp_evaluation",
    "isProp": true,
    "depth": 22}],
  "kind": "CategoryTheory.ExactPairing.termÎµ_",
  "examples":
  [{"type":
    "{C : Type u_1} â†’\n  {D : Type u_2} â†’\n    [inst : CategoryTheory.Category.{u_3, u_1} C] â†’\n      [inst_1 : CategoryTheory.Category.{u_4, u_2} D] â†’\n        [inst_2 : CategoryTheory.MonoidalCategory C] â†’\n          [inst_3 : CategoryTheory.MonoidalCategory D] â†’\n            (F : CategoryTheory.MonoidalFunctor C D) â†’\n              [inst_4 : CategoryTheory.Faithful F.toFunctor] â†’\n                {X Y : C} â†’\n                  (eval : CategoryTheory.MonoidalCategory.tensorObj Y X âŸ¶ ğŸ™_ C) â†’\n                    (coeval : ğŸ™_ C âŸ¶ CategoryTheory.MonoidalCategory.tensorObj X Y) â†’\n                      [inst_5 : CategoryTheory.ExactPairing (F.obj X) (F.obj Y)] â†’\n                        F.map eval =\n                            CategoryTheory.CategoryStruct.comp\n                              (CategoryTheory.inv (CategoryTheory.LaxMonoidalFunctor.Î¼ F.toLaxMonoidalFunctor Y X))\n                              (CategoryTheory.CategoryStruct.comp (Îµ_ (F.obj X) (F.obj Y)) F.Îµ) â†’\n                          F.map coeval =\n                              CategoryTheory.CategoryStruct.comp (CategoryTheory.inv F.Îµ)\n                                (CategoryTheory.CategoryStruct.comp (Î·_ (F.obj X) (F.obj Y))\n                                  (CategoryTheory.LaxMonoidalFunctor.Î¼ F.toLaxMonoidalFunctor X Y)) â†’\n                            CategoryTheory.ExactPairing X Y",
    "name": "CategoryTheory.exactPairingOfFaithful",
    "isProp": false,
    "doc":
    "Given candidate data for an exact pairing,\nwhich is sent by a faithful monoidal functor to an exact pairing,\nthe equations holds automatically. ",
    "depth": 34}],
  "count": 24},
 {"noDocExamples":
  [{"type":
    "âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] [inst_1 : CategoryTheory.MonoidalCategory C] {X Y : C}\n  [inst_2 : CategoryTheory.HasRightDual X] [inst_3 : CategoryTheory.HasRightDual Y] (f : X âŸ¶ Y),\n  CategoryTheory.CategoryStruct.comp (Î·_ Y Yá˜)\n      (CategoryTheory.MonoidalCategory.tensorHom (CategoryTheory.CategoryStruct.id Y) (fá˜)) =\n    CategoryTheory.CategoryStruct.comp (Î·_ X Xá˜)\n      (CategoryTheory.MonoidalCategory.tensorHom f (CategoryTheory.CategoryStruct.id Xá˜))",
    "name": "CategoryTheory.coevaluation_comp_rightAdjointMate",
    "isProp": true,
    "depth": 21},
   {"type":
    "âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] [inst_1 : CategoryTheory.MonoidalCategory C] {X Y : C}\n  [inst_2 : CategoryTheory.HasLeftDual X] [inst_3 : CategoryTheory.HasLeftDual Y] (f : X âŸ¶ Y),\n  CategoryTheory.CategoryStruct.comp (Î·_ (á˜Y) Y)\n      (CategoryTheory.MonoidalCategory.tensorHom (á˜f) (CategoryTheory.CategoryStruct.id Y)) =\n    CategoryTheory.CategoryStruct.comp (Î·_ (á˜X) X)\n      (CategoryTheory.MonoidalCategory.tensorHom (CategoryTheory.CategoryStruct.id á˜X) f)",
    "name": "CategoryTheory.coevaluation_comp_leftAdjointMate",
    "isProp": true,
    "depth": 22}],
  "kind": "CategoryTheory.ExactPairing.termÎ·_",
  "examples":
  [{"type":
    "{C : Type u_1} â†’\n  {D : Type u_2} â†’\n    [inst : CategoryTheory.Category.{u_3, u_1} C] â†’\n      [inst_1 : CategoryTheory.Category.{u_4, u_2} D] â†’\n        [inst_2 : CategoryTheory.MonoidalCategory C] â†’\n          [inst_3 : CategoryTheory.MonoidalCategory D] â†’\n            (F : CategoryTheory.MonoidalFunctor C D) â†’\n              [inst_4 : CategoryTheory.Faithful F.toFunctor] â†’\n                {X Y : C} â†’\n                  (eval : CategoryTheory.MonoidalCategory.tensorObj Y X âŸ¶ ğŸ™_ C) â†’\n                    (coeval : ğŸ™_ C âŸ¶ CategoryTheory.MonoidalCategory.tensorObj X Y) â†’\n                      [inst_5 : CategoryTheory.ExactPairing (F.obj X) (F.obj Y)] â†’\n                        F.map eval =\n                            CategoryTheory.CategoryStruct.comp\n                              (CategoryTheory.inv (CategoryTheory.LaxMonoidalFunctor.Î¼ F.toLaxMonoidalFunctor Y X))\n                              (CategoryTheory.CategoryStruct.comp (Îµ_ (F.obj X) (F.obj Y)) F.Îµ) â†’\n                          F.map coeval =\n                              CategoryTheory.CategoryStruct.comp (CategoryTheory.inv F.Îµ)\n                                (CategoryTheory.CategoryStruct.comp (Î·_ (F.obj X) (F.obj Y))\n                                  (CategoryTheory.LaxMonoidalFunctor.Î¼ F.toLaxMonoidalFunctor X Y)) â†’\n                            CategoryTheory.ExactPairing X Y",
    "name": "CategoryTheory.exactPairingOfFaithful",
    "isProp": false,
    "doc":
    "Given candidate data for an exact pairing,\nwhich is sent by a faithful monoidal functor to an exact pairing,\nthe equations holds automatically. ",
    "depth": 34}],
  "count": 24},
 {"noDocExamples":
  [{"type":
    "âˆ€ {R : Type u_1} [inst : Ring R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {U : Submodule R M}\n  {x : M}, x â‰¡ x [SMOD U]",
    "name": "SModEq.rfl",
    "isProp": true,
    "depth": 15},
   {"type":
    "âˆ€ {R : Type u_1} [inst : Ring R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {U : Submodule R M}\n  (x : M), x â‰¡ x [SMOD U]",
    "name": "SModEq.refl",
    "isProp": true,
    "depth": 15},
   {"type":
    "âˆ€ {R : Type u_4} [inst : CommRing R] {I : Ideal R} {x y : R},\n  x â‰¡ y [SMOD I] â†’ âˆ€ (f : Polynomial R), Polynomial.eval x f â‰¡ Polynomial.eval y f [SMOD I]",
    "name": "SModEq.eval",
    "isProp": true,
    "depth": 16}],
  "kind": "Â«term_â‰¡_[SMOD_]Â»",
  "examples": [],
  "count": 23},
 {"noDocExamples":
  [{"type":
    "âˆ€ {Î± : Type u_1} {a : Î±} {n : â„•}, Sym.replicate (Nat.succ n) a = a ::â‚› Sym.replicate n a",
    "name": "Sym.replicate_succ",
    "isProp": true,
    "depth": 8},
   {"type":
    "âˆ€ {Î± : Type u_1} {n : â„•} (a : Î±) (v : Vector Î± n), a ::â‚› Sym.ofVector v = Sym.ofVector (a ::áµ¥ v)",
    "name": "Sym.cons_of_coe_eq",
    "isProp": true,
    "depth": 10},
   {"type": "âˆ€ {Î± : Type u_1} {n : â„•} (a : Î±) (s : Sym Î± n), a âˆˆ a ::â‚› s",
    "name": "Sym.mem_cons_self",
    "isProp": true,
    "depth": 10}],
  "kind": "Sym.Â«term_::â‚›_Â»",
  "examples": [],
  "count": 23},
 {"noDocExamples": [],
  "kind": "Matrix.termGL",
  "examples":
  [{"type":
    "{n : Type u} â†’\n  [inst : DecidableEq n] â†’\n    [inst_1 : Fintype n] â†’ {R : Type v} â†’ [inst_2 : CommRing R] â†’ Matrix.SpecialLinearGroup n R â†’ GL n R",
    "name": "Matrix.SpecialLinearGroup.coeToGL",
    "isProp": false,
    "doc":
    "The map from SL(n) to GL(n) underlying the coercion, forgetting the value of the determinant.\n",
    "depth": 14},
   {"type":
    "{n : Type u} â†’\n  [inst : DecidableEq n] â†’\n    [inst_1 : Fintype n] â†’\n      {R : Type v} â†’ [inst_2 : CommRing R] â†’ (A : Matrix n n R) â†’ Invertible (Matrix.det A) â†’ GL n R",
    "name": "Matrix.GeneralLinearGroup.mk'",
    "isProp": false,
    "doc":
    "Given a matrix with invertible determinant we get an element of `GL n R`",
    "depth": 17},
   {"type":
    "{n : Type u} â†’\n  [inst : DecidableEq n] â†’\n    [inst_1 : Fintype n] â†’ {K : Type u_1} â†’ [inst_2 : Field K] â†’ (A : Matrix n n K) â†’ Matrix.det A â‰  0 â†’ GL n K",
    "name": "Matrix.GeneralLinearGroup.mkOfDetNeZero",
    "isProp": false,
    "doc":
    "Given a matrix with non-zero determinant over a field, we get an element of `GL n K`",
    "depth": 18}],
  "count": 23},
 {"noDocExamples":
  [{"type": "âˆ€ (p q : Num), Num.lxor p q = p ^^^ q",
    "name": "Num.lxor_eq_xor",
    "isProp": true,
    "depth": 9},
   {"type": "âˆ€ {n : â„•}, Function.Injective fun m => m ^^^ n",
    "name": "Nat.xor_left_injective",
    "isProp": true,
    "depth": 9}],
  "kind": "Â«term_^^^_Â»",
  "examples":
  [{"type":
    "âˆ€ (n m : â„•), SetTheory.PGame.grundyValue (SetTheory.PGame.nim â†‘n + SetTheory.PGame.nim â†‘m) = â†‘(n ^^^ m)",
    "name": "SetTheory.PGame.grundyValue_nim_add_nim",
    "isProp": true,
    "doc":
    "The Grundy value of the sum of two nim games with natural numbers of piles equals their bitwise\nxor. ",
    "depth": 12}],
  "count": 23},
 {"noDocExamples":
  [{"type": "âˆ€ (n : â„¤), 0 >>> n = 0",
    "name": "Int.zero_shiftRight",
    "isProp": true,
    "depth": 9},
   {"type": "âˆ€ (m n : â„•), Nat.shiftRight m n = m >>> n",
    "name": "Nat.shiftRight_eq",
    "isProp": true,
    "depth": 9}],
  "kind": "Â«term_>>>_Â»",
  "examples":
  [{"type": "âˆ€ (m n : â„•), m >>> (n + 1) = (m / 2) >>> n",
    "name": "Nat.shiftRight_succ_inside",
    "isProp": true,
    "doc": "Shiftright on successor with division moved inside. ",
    "depth": 11}],
  "count": 22},
 {"noDocExamples": [],
  "kind": "Complex.Â«term_Ã—â„‚_Â»",
  "examples":
  [{"type":
    "âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] (f : â„‚ â†’ E)\n  (z w : â„‚),\n  DifferentiableOn â„‚ f (Set.uIcc z.re w.re Ã—â„‚ Set.uIcc z.im w.im) â†’\n    (((âˆ« (x : â„) in z.re..w.re, f (â†‘x + â†‘z.im * Complex.I)) - âˆ« (x : â„) in z.re..w.re, f (â†‘x + â†‘w.im * Complex.I)) +\n          Complex.I â€¢ âˆ« (y : â„) in z.im..w.im, f (â†‘w.re + â†‘y * Complex.I)) -\n        Complex.I â€¢ âˆ« (y : â„) in z.im..w.im, f (â†‘z.re + â†‘y * Complex.I) =\n      0",
    "name": "Complex.integral_boundary_rect_eq_zero_of_differentiableOn",
    "isProp": true,
    "doc":
    "**Cauchy-Goursat theorem** for a rectangle: the integral of a complex differentiable function\nover the boundary of a rectangle equals zero. More precisely, if `f` is complex differentiable on a\nclosed rectangle, then its integral over the boundary of the rectangle equals zero. ",
    "depth": 29},
   {"type":
    "âˆ€ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] [inst_2 : CompleteSpace E] (f : â„‚ â†’ E)\n  (z w : â„‚),\n  ContinuousOn f (Set.uIcc z.re w.re Ã—â„‚ Set.uIcc z.im w.im) â†’\n    DifferentiableOn â„‚ f (Set.Ioo (min z.re w.re) (max z.re w.re) Ã—â„‚ Set.Ioo (min z.im w.im) (max z.im w.im)) â†’\n      (((âˆ« (x : â„) in z.re..w.re, f (â†‘x + â†‘z.im * Complex.I)) - âˆ« (x : â„) in z.re..w.re, f (â†‘x + â†‘w.im * Complex.I)) +\n            Complex.I â€¢ âˆ« (y : â„) in z.im..w.im, f (â†‘w.re + â†‘y * Complex.I)) -\n          Complex.I â€¢ âˆ« (y : â„) in z.im..w.im, f (â†‘z.re + â†‘y * Complex.I) =\n        0",
    "name":
    "Complex.integral_boundary_rect_eq_zero_of_continuousOn_of_differentiableOn",
    "isProp": true,
    "doc":
    "**Cauchy-Goursat theorem for a rectangle**: the integral of a complex differentiable function\nover the boundary of a rectangle equals zero. More precisely, if `f` is continuous on a closed\nrectangle and is complex differentiable on the corresponding open rectangle, then its integral over\nthe boundary of the rectangle equals zero. ",
    "depth": 30},
   {"type":
    "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {f : â„‚ â†’ E},\n  DiffContOnCl â„‚ f (Set.Iio 0 Ã—â„‚ Set.Iio 0) â†’\n    (âˆƒ c < 2,\n        âˆƒ B,\n          f =O[Bornology.cobounded â„‚ âŠ“ Filter.principal (Set.Iio 0 Ã—â„‚ Set.Iio 0)] fun z =>\n            Real.exp (B * Complex.abs z ^ c)) â†’\n      (âˆ€ x â‰¤ 0, f â†‘x = 0) â†’ (âˆ€ x â‰¤ 0, f (â†‘x * Complex.I) = 0) â†’ Set.EqOn f 0 {z | z.re â‰¤ 0 âˆ§ z.im â‰¤ 0}",
    "name": "PhragmenLindelof.eq_zero_on_quadrant_III",
    "isProp": true,
    "doc":
    "**Phragmen-LindelÃ¶f principle** in the third quadrant. Let `f : â„‚ â†’ E` be a function such that\n\n* `f` is differentiable in the open third quadrant and is continuous on its closure;\n* `â€–f zâ€–` is bounded from above by `A * exp(B * (abs z) ^ c)` on the open third quadrant\n  for some `A`, `B`, and `c < 2`;\n* `f` is equal to zero on the boundary of the third quadrant.\n\nThen `f` is equal to zero on the closed third quadrant. ",
    "depth": 31}],
  "count": 22},
 {"noDocExamples":
  [{"type":
    "âˆ€ {R : Type u_1} [inst : CommRing R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M] (f g : M â‰ƒâ‚—[R] M),\n  LinearEquiv.det (f â‰ªâ‰«â‚— g) = LinearEquiv.det g * LinearEquiv.det f",
    "name": "LinearEquiv.det_trans",
    "isProp": true,
    "depth": 41},
   {"type":
    "âˆ€ {M : Type u_7} {Mâ‚‚ : Type u_9} {Mâ‚ƒ : Type u_10} [inst : AddCommMonoid M] [inst_1 : AddCommMonoid Mâ‚‚]\n  [inst_2 : AddCommMonoid Mâ‚ƒ] (e : M â‰ƒ+ Mâ‚‚) (eâ‚‚ : Mâ‚‚ â‰ƒ+ Mâ‚ƒ),\n  AddEquiv.toNatLinearEquiv e â‰ªâ‰«â‚— AddEquiv.toNatLinearEquiv eâ‚‚ = AddEquiv.toNatLinearEquiv (AddEquiv.trans e eâ‚‚)",
    "name": "AddEquiv.toNatLinearEquiv_trans",
    "isProp": true,
    "depth": 41}],
  "kind": "LinearEquiv.transNotation",
  "examples":
  [{"type":
    "âˆ€ {R : Type u_1} [inst : CommRing R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {M' : Type u_3}\n  [inst_3 : AddCommGroup M'] [inst_4 : Module R M'] (f : M â‰ƒâ‚—[R] M) (e : M â‰ƒâ‚—[R] M'),\n  LinearEquiv.det (LinearEquiv.symm e â‰ªâ‰«â‚— f â‰ªâ‰«â‚— e) = LinearEquiv.det f",
    "name": "LinearEquiv.det_conj",
    "isProp": true,
    "doc":
    "Conjugating a linear equiv by a linear equiv does not change its determinant. ",
    "depth": 46}],
  "count": 21},
 {"noDocExamples": [],
  "kind": "Set.termğ’«_",
  "examples":
  [{"type": "âˆ€ {Î± : Type u} (x : Î±), ğ’«{x} = {âˆ…, {x}}",
    "name": "Set.powerset_singleton",
    "isProp": true,
    "doc":
    "The powerset of a singleton contains only `âˆ…` and the singleton itself. ",
    "depth": 9},
   {"type":
    "âˆ€ {Î± : Type u} (s : Set Î±), Cardinal.mk â†‘(ğ’« s) = 2 ^ Cardinal.mk â†‘s",
    "name": "Cardinal.mk_powerset",
    "isProp": true,
    "doc":
    "A variant of `Cardinal.mk_set` expressed in terms of a `Set` instead of a `Type`. ",
    "depth": 11},
   {"type": "âˆ€ {Î± : Type u_1}, GaloisConnection (fun x => â‹ƒâ‚€ x) fun x => ğ’« x",
    "name": "Set.sUnion_powerset_gc",
    "isProp": true,
    "doc": "`â‹ƒâ‚€` and `ğ’«` form a Galois connection. ",
    "depth": 13}],
  "count": 21},
 {"noDocExamples": [],
  "kind": "MeasureTheory.Â«termâˆ«â‹¯âˆ«â»__,_âˆ‚_Â»",
  "examples":
  [{"type":
    "âˆ€ {Î´ : Type u_1} {Ï€ : Î´ â†’ Type u_3} [inst : (x : Î´) â†’ MeasurableSpace (Ï€ x)] (Î¼ : (i : Î´) â†’ MeasureTheory.Measure (Ï€ i))\n  [inst_1 : DecidableEq Î´] {s : Finset Î´} {x y : (i : Î´) â†’ Ï€ i} (f : ((i : Î´) â†’ Ï€ i) â†’ ENNReal),\n  (âˆ€ i âˆ‰ s, x i = y i) â†’ (âˆ«â‹¯âˆ«â»_s, f âˆ‚Î¼) x = (âˆ«â‹¯âˆ«â»_s, f âˆ‚Î¼) y",
    "name": "MeasureTheory.lmarginal_congr",
    "isProp": true,
    "doc": "The marginal distribution is independent of the variables in `s`. ",
    "depth": 21},
   {"type":
    "âˆ€ {Î´ : Type u_1} {Ï€ : Î´ â†’ Type u_3} [inst : (x : Î´) â†’ MeasurableSpace (Ï€ x)] {Î¼ : (i : Î´) â†’ MeasureTheory.Measure (Ï€ i)}\n  [inst_1 : âˆ€ (i : Î´), MeasureTheory.SigmaFinite (Î¼ i)] [inst_2 : DecidableEq Î´] {s : Finset Î´}\n  (f : ((i : Î´) â†’ Ï€ i) â†’ ENNReal),\n  Measurable f â†’\n    âˆ€ {i : Î´}, i âˆ‰ s â†’ âˆ«â‹¯âˆ«â»_insert i s, f âˆ‚Î¼ = âˆ«â‹¯âˆ«â»_s, fun x => âˆ«â» (xáµ¢ : Ï€ i), f (Function.update x i xáµ¢) âˆ‚Î¼ i âˆ‚Î¼",
    "name": "MeasureTheory.lmarginal_insert'",
    "isProp": true,
    "doc":
    "Peel off a single integral from a `lmarginal` integral at the end (compare with\n`lmarginal_insert`, which peels off an integral at the beginning). ",
    "depth": 25},
   {"type":
    "âˆ€ {Î´ : Type u_1} {Ï€ : Î´ â†’ Type u_3} [inst : (x : Î´) â†’ MeasurableSpace (Ï€ x)] {Î¼ : (i : Î´) â†’ MeasureTheory.Measure (Ï€ i)}\n  [inst_1 : âˆ€ (i : Î´), MeasureTheory.SigmaFinite (Î¼ i)] [inst_2 : DecidableEq Î´] {s : Finset Î´}\n  (f : ((i : Î´) â†’ Ï€ i) â†’ ENNReal),\n  Measurable f â†’\n    âˆ€ {i : Î´}, i âˆˆ s â†’ âˆ«â‹¯âˆ«â»_s, f âˆ‚Î¼ = âˆ«â‹¯âˆ«â»_Finset.erase s i, fun x => âˆ«â» (xáµ¢ : Ï€ i), f (Function.update x i xáµ¢) âˆ‚Î¼ i âˆ‚Î¼",
    "name": "MeasureTheory.lmarginal_erase'",
    "isProp": true,
    "doc":
    "Peel off a single integral from a `lmarginal` integral at the end (compare with\n`lmarginal_erase`, which peels off an integral at the beginning). ",
    "depth": 25}],
  "count": 20},
 {"noDocExamples": [],
  "kind": "MeasureTheory.Â«termâ¨â»_,_âˆ‚_Â»",
  "examples":
  [{"type":
    "âˆ€ {Î± : Type u_1} {m0 : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {f : Î± â†’ ENNReal},\n  Î¼ â‰  0 â†’ âˆ«â» (a : Î±), f a âˆ‚Î¼ â‰  âŠ¤ â†’ âˆƒ x, â¨â» (a : Î±), f a âˆ‚Î¼ â‰¤ f x",
    "name": "MeasureTheory.exists_laverage_le",
    "isProp": true,
    "doc":
    "**First moment method**. The maximum of a measurable function is greater than its mean. ",
    "depth": 18},
   {"type":
    "âˆ€ {Î± : Type u_1} {m0 : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {f : Î± â†’ ENNReal}\n  [inst : MeasureTheory.IsFiniteMeasure Î¼], Î¼ â‰  0 â†’ AEMeasurable f â†’ âˆƒ x, f x â‰¤ â¨â» (a : Î±), f a âˆ‚Î¼",
    "name": "MeasureTheory.exists_le_laverage",
    "isProp": true,
    "doc":
    "**First moment method**. The minimum of a measurable function is smaller than its mean. ",
    "depth": 19},
   {"type":
    "âˆ€ {Î± : Type u_1} {m0 : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {f : Î± â†’ ENNReal},\n  Î¼ â‰  0 â†’ âˆ«â» (a : Î±), f a âˆ‚Î¼ â‰  âŠ¤ â†’ 0 < â†‘â†‘Î¼ {x | â¨â» (a : Î±), f a âˆ‚Î¼ â‰¤ f x}",
    "name": "MeasureTheory.measure_laverage_le_pos",
    "isProp": true,
    "doc":
    "**First moment method**. A measurable function is greater than its mean on a set of positive\nmeasure. ",
    "depth": 20}],
  "count": 20},
 {"noDocExamples": [],
  "kind": "Â«term_â†’Lâ‹†[_]_Â»",
  "examples":
  [{"type":
    "(ğ•œ : Type u_1) â†’\n  {E : Type u_2} â†’\n    [inst : IsROrC ğ•œ] â†’ [inst_1 : NormedAddCommGroup E] â†’ [inst_2 : InnerProductSpace ğ•œ E] â†’ E â†’L[ğ•œ] E â†’Lâ‹†[ğ•œ] ğ•œ",
    "name": "innerSLFlip",
    "isProp": false,
    "doc":
    "The inner product as a continuous sesquilinear map, with the two arguments flipped. ",
    "depth": 29},
   {"type":
    "(ğ•œ : Type u_1) â†’\n  {E : Type u_2} â†’\n    [inst : IsROrC ğ•œ] â†’ [inst_1 : NormedAddCommGroup E] â†’ [inst_2 : InnerProductSpace ğ•œ E] â†’ E â†’Lâ‹†[ğ•œ] E â†’L[ğ•œ] ğ•œ",
    "name": "innerSL",
    "isProp": false,
    "doc":
    "The inner product as a continuous sesquilinear map. Note that `toDualMap` (resp. `toDual`)\nin `InnerProductSpace.Dual` is a version of this given as a linear isometry (resp. linear\nisometric equivalence). ",
    "depth": 29},
   {"type":
    "{ğ•œ : Type u_1} â†’\n  {E : Type u_2} â†’\n    [inst : IsROrC ğ•œ] â†’\n      [inst_1 : NormedAddCommGroup E] â†’\n        [inst_2 : InnerProductSpace ğ•œ E] â†’ [inst_3 : CompleteSpace E] â†’ (E â†’Lâ‹†[ğ•œ] E â†’L[ğ•œ] ğ•œ) â†’ E â†’L[ğ•œ] E",
    "name": "InnerProductSpace.continuousLinearMapOfBilin",
    "isProp": false,
    "doc":
    "Maps a bounded sesquilinear form to its continuous linear map,\ngiven by interpreting the form as a map `B : E â†’Lâ‹†[ğ•œ] NormedSpace.Dual ğ•œ E`\nand dualizing the result using `toDual`.\n",
    "depth": 31}],
  "count": 19},
 {"noDocExamples":
  [{"type":
    "âˆ€ {C : Type uC} [inst : CategoryTheory.Category.{uC', uC} C] {W : CategoryTheory.MorphismProperty C} {D : Type uD}\n  [inst_1 : CategoryTheory.Category.{uD', uD} D]\n  {F G : CategoryTheory.Functor (CategoryTheory.MorphismProperty.Localization W) D}\n  (Ï„ :\n    CategoryTheory.Functor.comp (CategoryTheory.MorphismProperty.Q W) F âŸ¶\n      CategoryTheory.Functor.comp (CategoryTheory.MorphismProperty.Q W) G),\n  CategoryTheory.CategoryStruct.id (CategoryTheory.MorphismProperty.Q W) â—«\n      CategoryTheory.Localization.Construction.natTransExtension Ï„ =\n    Ï„",
    "name": "CategoryTheory.Localization.Construction.natTransExtension_hcomp",
    "isProp": true,
    "depth": 23},
   {"type":
    "âˆ€ {C : Type uC} [inst : CategoryTheory.Category.{uC', uC} C] {W : CategoryTheory.MorphismProperty C} {D : Type uD}\n  [inst_1 : CategoryTheory.Category.{uD', uD} D]\n  {F G : CategoryTheory.Functor (CategoryTheory.MorphismProperty.Localization W) D} {Ï„â‚ Ï„â‚‚ : F âŸ¶ G},\n  CategoryTheory.CategoryStruct.id (CategoryTheory.MorphismProperty.Q W) â—« Ï„â‚ =\n      CategoryTheory.CategoryStruct.id (CategoryTheory.MorphismProperty.Q W) â—« Ï„â‚‚ â†’\n    Ï„â‚ = Ï„â‚‚",
    "name": "CategoryTheory.Localization.Construction.natTrans_hcomp_injective",
    "isProp": true,
    "depth": 26},
   {"type":
    "âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] {D : Type uâ‚‚} [inst_1 : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D]\n  {E : Type uâ‚ƒ} [inst_2 : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E] {F G : CategoryTheory.Functor C D}\n  {H I : CategoryTheory.Functor D E} (Î± : F â‰… G) (Î² : H â‰… I), (CategoryTheory.NatIso.hcomp Î± Î²).hom = Î±.hom â—« Î².hom",
    "name": "CategoryTheory.NatIso.hcomp_hom",
    "isProp": true,
    "depth": 27}],
  "kind": "CategoryTheory.NatTrans.Â«term_â—«_Â»",
  "examples": [],
  "count": 19},
 {"noDocExamples": [],
  "kind": "CategoryTheory.Â«term_â¥¤â‚‘_Â»",
  "examples":
  [{"type":
    "(C : Type uâ‚) â†’\n  [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] â†’\n    (D : Type uâ‚‚) â†’ [inst_1 : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D] â†’ CategoryTheory.Functor (C â¥¤â‚‘ D) (C â¥¤â‚— D)",
    "name": "CategoryTheory.LeftExactFunctor.ofExact",
    "isProp": false,
    "doc": "Turn an exact functor into a left exact functor. ",
    "depth": 12},
   {"type":
    "{C : Type uâ‚} â†’\n  [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] â†’\n    {D : Type uâ‚‚} â†’\n      [inst_1 : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D] â†’\n        (F : CategoryTheory.Functor C D) â†’\n          [inst_2 : CategoryTheory.Limits.PreservesFiniteLimits F] â†’\n            [inst_3 : CategoryTheory.Limits.PreservesFiniteColimits F] â†’ C â¥¤â‚‘ D",
    "name": "CategoryTheory.ExactFunctor.of",
    "isProp": false,
    "doc":
    "Turn an exact functor into an object of the category `ExactFunctor C D`. ",
    "depth": 12},
   {"type":
    "(C : Type uâ‚) â†’\n  [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] â†’\n    (D : Type uâ‚‚) â†’\n      [inst_1 : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D] â†’ CategoryTheory.Functor (C â¥¤â‚‘ D) (CategoryTheory.Functor C D)",
    "name": "CategoryTheory.ExactFunctor.forget",
    "isProp": false,
    "doc": "An exact functor is in particular a functor. ",
    "depth": 12}],
  "count": 18},
 {"noDocExamples": [],
  "kind": "MeasureTheory.Â«termâ¨â»_In_,_âˆ‚_Â»",
  "examples":
  [{"type":
    "âˆ€ {Î± : Type u_1} {m0 : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {s : Set Î±} {f : Î± â†’ ENNReal},\n  â†‘â†‘Î¼ s â‰  0 â†’ â†‘â†‘Î¼ s â‰  âŠ¤ â†’ AEMeasurable f â†’ âˆƒ x âˆˆ s, f x â‰¤ â¨â» (a : Î±) in s, f a âˆ‚Î¼",
    "name": "MeasureTheory.exists_le_setLaverage",
    "isProp": true,
    "doc":
    "**First moment method**. The minimum of a measurable function is smaller than its mean. ",
    "depth": 21},
   {"type":
    "âˆ€ {Î± : Type u_1} {m0 : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {s : Set Î±} {f : Î± â†’ ENNReal},\n  â†‘â†‘Î¼ s â‰  0 â†’ MeasureTheory.NullMeasurableSet s â†’ âˆ«â» (a : Î±) in s, f a âˆ‚Î¼ â‰  âŠ¤ â†’ âˆƒ x âˆˆ s, â¨â» (a : Î±) in s, f a âˆ‚Î¼ â‰¤ f x",
    "name": "MeasureTheory.exists_setLaverage_le",
    "isProp": true,
    "doc":
    "**First moment method**. The maximum of a measurable function is greater than its mean. ",
    "depth": 21},
   {"type":
    "âˆ€ {Î± : Type u_1} {m0 : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {s : Set Î±} {f : Î± â†’ ENNReal},\n  â†‘â†‘Î¼ s â‰  0 â†’\n    MeasureTheory.NullMeasurableSet s â†’\n      âˆ«â» (a : Î±) in s, f a âˆ‚Î¼ â‰  âŠ¤ â†’ 0 < â†‘â†‘Î¼ {x | x âˆˆ s âˆ§ â¨â» (a : Î±) in s, f a âˆ‚Î¼ â‰¤ f x}",
    "name": "MeasureTheory.measure_setLaverage_le_pos",
    "isProp": true,
    "doc":
    "**First moment method**. A measurable function is greater than its mean on a set of positive\nmeasure. ",
    "depth": 23}],
  "count": 18},
 {"noDocExamples": [],
  "kind": "MeasureTheory.Â«termâˆ«â»_In_,_Â»",
  "examples":
  [{"type":
    "âˆ€ {x r : â„}, x â‰¤ 0 â†’ âˆ«â» (y : â„) in Set.Iio x, ProbabilityTheory.exponentialPdf r y = 0",
    "name": "ProbabilityTheory.lintegral_exponentialPdf_of_nonpos",
    "isProp": true,
    "doc":
    "the Lebesgue-Integral of the exponential PDF over nonpositive Reals equals 0",
    "depth": 12},
   {"type":
    "âˆ€ (t : â„) (f : UnitAddCircle â†’ ENNReal), âˆ«â» (a : â„) in Set.Ioc t (t + 1), f â†‘a = âˆ«â» (b : UnitAddCircle), f b",
    "name": "UnitAddCircle.lintegral_preimage",
    "isProp": true,
    "doc":
    "The integral of a measurable function over `UnitAddCircle` is equal to the integral over an\ninterval (t, t + 1] in `â„` of its lift to `â„`. ",
    "depth": 15},
   {"type":
    "âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] {f : Î± â†’ â„} (Î¼ : MeasureTheory.Measure Î±),\n  0 â‰¤á¶ [MeasureTheory.Measure.ae Î¼] f â†’\n    AEMeasurable f â†’ âˆ«â» (Ï‰ : Î±), ENNReal.ofReal (f Ï‰) âˆ‚Î¼ = âˆ«â» (t : â„) in Set.Ioi 0, â†‘â†‘Î¼ {a | t â‰¤ f a}",
    "name": "MeasureTheory.lintegral_eq_lintegral_meas_le",
    "isProp": true,
    "doc":
    "The standard case of the layer cake formula / Cavalieri's principle / tail probability formula:\n\nFor a nonnegative function `f` on a measure space, the Lebesgue integral of `f` can\nbe written (roughly speaking) as: `âˆ«â» f âˆ‚Î¼ = âˆ«â» t in 0..âˆ, Î¼ {Ï‰ | f(Ï‰) â‰¥ t}`.\n\nSee `lintegral_eq_lintegral_meas_lt` for a version with sets of the form `{Ï‰ | f(Ï‰) > t}`\ninstead. ",
    "depth": 16}],
  "count": 17},
 {"noDocExamples":
  [{"type": "âˆ€ (x : â„•), 0 &&& x = 0",
    "name": "Nat.zero_and",
    "isProp": true,
    "depth": 9},
   {"type": "âˆ€ (p q : PosNum), PosNum.land p q = p &&& q",
    "name": "PosNum.land_eq_and",
    "isProp": true,
    "depth": 9},
   {"type": "âˆ€ (p q : Num), Num.land p q = p &&& q",
    "name": "Num.land_eq_and",
    "isProp": true,
    "depth": 9}],
  "kind": "Â«term_&&&_Â»",
  "examples": [],
  "count": 17},
 {"noDocExamples": [],
  "kind": "Â«term#[_,]Â»",
  "examples":
  [{"type":
    "Lean.Name â†’\n  List (Bool Ã— Lean.Expr) â†’\n    optParam (Array Lean.Expr) #[] â†’ optParam (Array Lean.Expr) #[] â†’ Lean.Elab.TermElabM Lean.Expr",
    "name": "Mathlib.Deriving.Traversable.traverseConstructor.mkFunCtor",
    "isProp": false,
    "doc":
    "`mkFunCtor ctor [(true, (argâ‚ : m typeâ‚)), (false, (argâ‚‚ : typeâ‚‚)), (true, (argâ‚ƒ : m typeâ‚ƒ)),\n(false, (argâ‚„ : typeâ‚„))]` makes `fun (xâ‚ : typeâ‚) (xâ‚ƒ : typeâ‚ƒ) => ctor xâ‚ argâ‚‚ xâ‚ƒ argâ‚„`. ",
    "depth": 7},
   {"type":
    "Lean.Syntax â†’\n  Lean.Name â†’\n    optParam Bool false â†’\n      optParam (Array Simps.ProjectionRule) #[] â†’\n        optParam Bool false â†’ Lean.CoreM (List Lean.Name Ã— Array Simps.ProjectionData)",
    "name": "Simps.getRawProjections",
    "isProp": false,
    "doc":
    "Get the projections used by `simps` associated to a given structure `str`.\n\nThe returned information is also stored in the environment extension `Simps.structureExt`, which\nis given to `str`. If `str` already has this attribute, the information is read from this\nextension instead. See the documentation for this extension for the data this tactic returns.\n\nThe returned universe levels are the universe levels of the structure. For the projections there\nare three cases\n* If the declaration `{StructureName}.Simps.{projectionName}` has been declared, then the value\n  of this declaration is used (after checking that it is definitionally equal to the actual\n  projection. If you rename the projection name, the declaration should have the *new* projection\n  name.\n* You can also declare a custom projection that is a composite of multiple projections.\n* Otherwise, for every class with the `notation_class` attribute, and the structure has an\n  instance of that notation class, then the projection of that notation class is used for the\n  projection that is definitionally equal to it (if there is such a projection).\n  This means in practice that coercions to function types and sorts will be used instead of\n  a projection, if this coercion is definitionally equal to a projection. Furthermore, for\n  notation classes like `Mul` and `Zero` those projections are used instead of the\n  corresponding projection.\n  Projections for coercions and notation classes are not automatically generated if they are\n  composites of multiple projections (for example when you use `extend` without the\n  `oldStructureCmd` (does this exist?)).\n* Otherwise, the projection of the structure is chosen.\n  For example: ``getRawProjections env `Prod`` gives the default projections.\n```\n  ([u, v], [(`fst, `(Prod.fst.{u v}), [0], true, false),\n     (`snd, `(@Prod.snd.{u v}), [1], true, false)])\n```\n\nOptionally, this command accepts three optional arguments:\n* If `traceIfExists` the command will always generate a trace message when the structure already\n  has an entry in `structureExt`.\n* The `rules` argument specifies whether projections should be added, renamed, used as prefix, and\n  not used by default.\n* if `trc` is true, this tactic will trace information just as if\n  `set_option trace.simps.verbose true` was set.\n",
    "depth": 9},
   {"type":
    "Lean.MVarId â†’\n  Lean.Meta.Simp.Context â†’\n    optParam (Option Lean.Meta.Simp.Discharge) none â†’\n      optParam Bool true â†’\n        optParam (Array Lean.FVarId) #[] â†’\n          optParam Lean.Meta.Simp.UsedSimps âˆ… â†’\n            Lean.MetaM (Option (Array Lean.FVarId Ã— Lean.MVarId) Ã— Lean.Meta.Simp.UsedSimps)",
    "name": "Mathlib.Deriving.Traversable.simpFunctorGoal",
    "isProp": false,
    "doc": "Simplify the goal `m` using `functor_norm`. ",
    "depth": 13}],
  "count": 17},
 {"noDocExamples":
  [{"type":
    "âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] [inst_1 : CategoryTheory.MonoidalCategory C] {X : C}\n  [inst_2 : CategoryTheory.HasRightDual X], á˜Xá˜ = X",
    "name": "CategoryTheory.leftDual_rightDual",
    "isProp": true,
    "depth": 14},
   {"type":
    "âˆ€ {C : Type u_4} {D : Type u_2} [inst : CategoryTheory.Groupoid C] [inst_1 : CategoryTheory.Category.{u_1, u_2} D]\n  [inst_2 : CategoryTheory.MonoidalCategory D] [inst_3 : CategoryTheory.LeftRigidCategory D]\n  (F : CategoryTheory.Functor C D) (X : C),\n  (á˜F.map (CategoryTheory.inv (CategoryTheory.CategoryStruct.id X))) = CategoryTheory.CategoryStruct.id á˜(F.obj X)",
    "name": "CategoryTheory.Monoidal.functorHasLeftDual.proof_1",
    "isProp": true,
    "depth": 24}],
  "kind": "CategoryTheory.Â«termá˜_Â»",
  "examples":
  [{"type":
    "{C : Type uâ‚} â†’\n  [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] â†’\n    [inst_1 : CategoryTheory.MonoidalCategory C] â†’\n      {X Y : C} â†’\n        [inst_2 : CategoryTheory.HasLeftDual X] â†’ [inst_3 : CategoryTheory.HasLeftDual Y] â†’ (X âŸ¶ Y) â†’ (á˜Y âŸ¶ á˜X)",
    "name": "CategoryTheory.leftAdjointMate",
    "isProp": false,
    "doc": "The left adjoint mate `á˜f : á˜Y âŸ¶ á˜X` of a morphism `f : X âŸ¶ Y`. ",
    "depth": 15}],
  "count": 16},
 {"noDocExamples":
  [{"type":
    "{C : Type uâ‚} â†’\n  [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] â†’\n    [inst_1 : CategoryTheory.MonoidalCategory C] â†’\n      {X : C} â†’ [self : CategoryTheory.HasRightDual X] â†’ CategoryTheory.ExactPairing X Xá˜",
    "name": "CategoryTheory.HasRightDual.exact",
    "isProp": false,
    "depth": 11},
   {"type":
    "âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] [inst_1 : CategoryTheory.MonoidalCategory C] {X : C}\n  [inst_2 : CategoryTheory.HasLeftDual X], (á˜X)á˜ = X",
    "name": "CategoryTheory.rightDual_leftDual",
    "isProp": true,
    "depth": 14}],
  "kind": "CategoryTheory.Â«term_á˜Â»",
  "examples":
  [{"type":
    "{C : Type uâ‚} â†’\n  [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] â†’\n    [inst_1 : CategoryTheory.MonoidalCategory C] â†’\n      {X Y : C} â†’\n        [inst_2 : CategoryTheory.HasRightDual X] â†’ [inst_3 : CategoryTheory.HasRightDual Y] â†’ (X âŸ¶ Y) â†’ (Yá˜ âŸ¶ Xá˜)",
    "name": "CategoryTheory.rightAdjointMate",
    "isProp": false,
    "doc": "The right adjoint mate `fá˜ : Xá˜ âŸ¶ Yá˜` of a morphism `f : X âŸ¶ Y`. ",
    "depth": 15}],
  "count": 16},
 {"noDocExamples":
  [{"type": "âˆ€ {Î± : Type u_1} {a : Array Î±}, a[Array.size a]? = none",
    "name": "Array.get?_size",
    "isProp": true,
    "depth": 15},
   {"type": "âˆ€ {Î± : Type u_1} (a : Array Î±) (i : â„•), Array.get? a i = a[i]?",
    "name": "Array.get?_eq_getElem?",
    "isProp": true,
    "depth": 15},
   {"type":
    "âˆ€ {Î± : Type u_1} (a : Array Î±) (i : â„•), a[i]? = List.get? a.data i",
    "name": "Array.getElem?_eq_data_get?",
    "isProp": true,
    "depth": 16}],
  "kind": "Â«term__[_]_?Â»",
  "examples": [],
  "count": 16},
 {"noDocExamples": [],
  "kind": "CategoryTheory.LaxMonoidalFunctor.Â«term_âŠ—â‹™_Â»",
  "examples":
  [{"type":
    "{C : Type uâ‚} â†’\n  [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] â†’\n    [inst_1 : CategoryTheory.MonoidalCategory C] â†’\n      {D : Type uâ‚‚} â†’\n        [inst_2 : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D] â†’\n          (e : C â‰Œ D) â†’\n            CategoryTheory.LaxMonoidalFunctor.id C â‰…\n              (CategoryTheory.Monoidal.toTransported e).toLaxMonoidalFunctor âŠ—â‹™\n                (CategoryTheory.Monoidal.fromTransported e).toLaxMonoidalFunctor",
    "name": "CategoryTheory.Monoidal.transportedMonoidalUnitIso",
    "isProp": false,
    "doc": "The unit isomorphism upgrades to a monoidal isomorphism. ",
    "depth": 20},
   {"type":
    "{C : Type uâ‚} â†’\n  [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] â†’\n    [inst_1 : CategoryTheory.MonoidalCategory C] â†’\n      {D : Type uâ‚‚} â†’\n        [inst_2 : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D] â†’\n          [inst_3 : CategoryTheory.MonoidalCategory D] â†’\n            (F : CategoryTheory.MonoidalFunctor C D) â†’\n              [inst_4 : CategoryTheory.IsEquivalence F.toFunctor] â†’\n                CategoryTheory.LaxMonoidalFunctor.id C âŸ¶\n                  F.toLaxMonoidalFunctor âŠ—â‹™ (CategoryTheory.monoidalInverse F).toLaxMonoidalFunctor",
    "name": "CategoryTheory.monoidalUnit",
    "isProp": false,
    "doc":
    "The unit of a monoidal equivalence can be upgraded to a monoidal natural transformation. ",
    "depth": 20},
   {"type":
    "{C : Type uâ‚} â†’\n  [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] â†’\n    [inst_1 : CategoryTheory.MonoidalCategory C] â†’\n      {D : Type uâ‚‚} â†’\n        [inst_2 : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D] â†’\n          [inst_3 : CategoryTheory.MonoidalCategory D] â†’\n            (F : CategoryTheory.MonoidalFunctor C D) â†’\n              [inst_4 : CategoryTheory.IsEquivalence F.toFunctor] â†’\n                (CategoryTheory.monoidalInverse F).toLaxMonoidalFunctor âŠ—â‹™ F.toLaxMonoidalFunctor âŸ¶\n                  CategoryTheory.LaxMonoidalFunctor.id D",
    "name": "CategoryTheory.monoidalCounit",
    "isProp": false,
    "doc":
    "The counit of a monoidal equivalence can be upgraded to a monoidal natural transformation. ",
    "depth": 21}],
  "count": 16},
 {"noDocExamples": [],
  "kind": "Â«term_âŠ‡_Â»",
  "examples":
  [{"type":
    "âˆ€ {X : Type u} [inst : TopologicalSpace X] {Î¹ : Type v} [hÎ¹ : Nonempty Î¹] (t : Î¹ â†’ Set X),\n  Directed (fun x x_1 => x âŠ‡ x_1) t â†’\n    (âˆ€ (i : Î¹), Set.Nonempty (t i)) â†’\n      (âˆ€ (i : Î¹), IsCompact (t i)) â†’ (âˆ€ (i : Î¹), IsClosed (t i)) â†’ Set.Nonempty (â‹‚ i, t i)",
    "name": "IsCompact.nonempty_iInter_of_directed_nonempty_compact_closed",
    "isProp": true,
    "doc":
    "Cantor's intersection theorem:\nthe intersection of a directed family of nonempty compact closed sets is nonempty. ",
    "depth": 15},
   {"type":
    "âˆ€ {X : Type u} {Î¹ : Type u_1} [inst : TopologicalSpace X] [inst_1 : Nonempty Î¹] {V : Î¹ â†’ Set X},\n  Directed (fun x x_1 => x âŠ‡ x_1) V â†’\n    (âˆ€ (i : Î¹), IsCompact (V i)) â†’\n      (âˆ€ (i : Î¹), IsClosed (V i)) â†’ âˆ€ {U : Set X}, (âˆ€ x âˆˆ â‹‚ i, V i, U âˆˆ nhds x) â†’ âˆƒ i, V i âŠ† U",
    "name": "exists_subset_nhds_of_isCompact'",
    "isProp": true,
    "doc":
    "If `V : Î¹ â†’ Set X` is a decreasing family of closed compact sets then any neighborhood of\n`â‹‚ i, V i` contains some `V i`. We assume each `V i` is compact *and* closed because `X` is\nnot assumed to be Hausdorff. See `exists_subset_nhd_of_compact` for version assuming this. ",
    "depth": 18},
   {"type":
    "âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T2Space X] {Î¹ : Type u_4} [inst_2 : Nonempty Î¹] {V : Î¹ â†’ Set X},\n  Directed (fun x x_1 => x âŠ‡ x_1) V â†’\n    (âˆ€ (i : Î¹), IsCompact (V i)) â†’ âˆ€ {U : Set X}, (âˆ€ x âˆˆ â‹‚ i, V i, U âˆˆ nhds x) â†’ âˆƒ i, V i âŠ† U",
    "name": "exists_subset_nhds_of_isCompact",
    "isProp": true,
    "doc":
    "If `V : Î¹ â†’ Set X` is a decreasing family of compact sets then any neighborhood of\n`â‹‚ i, V i` contains some `V i`. This is a version of `exists_subset_nhds_of_isCompact'` where we\ndon't need to assume each `V i` closed because it follows from compactness since `X` is\nassumed to be Hausdorff. ",
    "depth": 18}],
  "count": 15},
 {"noDocExamples":
  [{"type":
    "âˆ€ {L : FirstOrder.Language} {T : FirstOrder.Language.Theory L} {Ï† : FirstOrder.Language.Sentence L}, Ï† âˆˆ T â†’ T âŠ¨áµ‡ Ï†",
    "name": "FirstOrder.Language.Theory.models_sentence_of_mem",
    "isProp": true,
    "depth": 10},
   {"type":
    "âˆ€ {L : FirstOrder.Language} {T : FirstOrder.Language.Theory L},\n  FirstOrder.Language.Theory.IsMaximal T â†’ âˆ€ {Ï† : FirstOrder.Language.Sentence L}, T âŠ¨áµ‡ Ï† â†’ Ï† âˆˆ T",
    "name": "FirstOrder.Language.Theory.IsMaximal.mem_of_models",
    "isProp": true,
    "depth": 11}],
  "kind": "FirstOrder.Language.Theory.Â«term_âŠ¨áµ‡_Â»",
  "examples":
  [{"type":
    "âˆ€ {L : FirstOrder.Language} {T : FirstOrder.Language.Theory L} {Ï† : FirstOrder.Language.Sentence L},\n  T âŠ¨áµ‡ Ï† â†” âˆƒ T0, â†‘T0 âŠ† T âˆ§ â†‘T0 âŠ¨áµ‡ Ï†",
    "name": "FirstOrder.Language.Theory.models_iff_finset_models",
    "isProp": true,
    "doc":
    "An alternative statement of the Compactness Theorem. A formula `Ï†` is modeled by a\ntheory iff there is a finite subset `T0` of the theory such that `Ï†` is modeled by `T0` ",
    "depth": 14}],
  "count": 14},
 {"noDocExamples":
  [{"type": "âˆ€ {Î± : Type u_1} [inst : Primcodable Î±] (p : Î± â†’ Prop), p â‰¤â‚€ p",
    "name": "manyOneReducible_refl",
    "isProp": true,
    "depth": 9},
   {"type":
    "âˆ€ {Î± : Type u} [inst : Primcodable Î±] [inst_1 : Inhabited Î±] {p : Set Î±}, p â‰¤â‚€ toNat p",
    "name": "manyOneReducible_toNat",
    "isProp": true,
    "depth": 10},
   {"type":
    "âˆ€ {Î± : Type u} [inst : Primcodable Î±] [inst_1 : Inhabited Î±] {p : Set Î±}, toNat p â‰¤â‚€ p",
    "name": "toNat_manyOneReducible",
    "isProp": true,
    "depth": 10}],
  "kind": "Â«term_â‰¤â‚€_Â»",
  "examples": [],
  "count": 14},
 {"noDocExamples": [],
  "kind": "AlgebraicGeometry.Â«term_âˆ£_áµ¤_Â»",
  "examples":
  [{"type":
    "{X : AlgebraicGeometry.Scheme} â†’ (U : TopologicalSpace.Opens â†‘â†‘X.toPresheafedSpace) â†’ X âˆ£_áµ¤ U âŸ¶ X",
    "name": "AlgebraicGeometry.Scheme.Î¹Opens",
    "isProp": false,
    "doc": "The restriction of a scheme to an open subset. ",
    "depth": 27},
   {"type":
    "(X : AlgebraicGeometry.Scheme) â†’ {U V : TopologicalSpace.Opens â†‘â†‘X.toPresheafedSpace} â†’ U = V â†’ (X âˆ£_áµ¤ U â‰… X âˆ£_áµ¤ V)",
    "name": "AlgebraicGeometry.Scheme.restrictIsoOfEq",
    "isProp": false,
    "doc": "If `U = V`, then `X âˆ£_ U` is isomorphic to `X âˆ£_ V`. ",
    "depth": 29},
   {"type":
    "{X Y : AlgebraicGeometry.Scheme} â†’\n  (f : X âŸ¶ Y) â†’ (U : TopologicalSpace.Opens â†‘â†‘Y.toPresheafedSpace) â†’ X âˆ£_áµ¤ fâ»Â¹áµ U âŸ¶ Y âˆ£_áµ¤ U",
    "name": "AlgebraicGeometry.morphismRestrict",
    "isProp": false,
    "doc":
    "The restriction of a morphism `X âŸ¶ Y` onto `X |_{f â»Â¹ U} âŸ¶ Y |_ U`. ",
    "depth": 30}],
  "count": 14},
 {"noDocExamples":
  [{"type": "âˆ€ (p q : PosNum), PosNum.lor p q = p ||| q",
    "name": "PosNum.lor_eq_or",
    "isProp": true,
    "depth": 9},
   {"type": "âˆ€ (x : â„•), 0 ||| x = x",
    "name": "Nat.or_zero",
    "isProp": true,
    "depth": 9}],
  "kind": "Â«term_|||_Â»",
  "examples":
  [{"type":
    "âˆ€ {x y n m : â„•}, x < 2 ^ n â†’ y < 2 ^ m â†’ y <<< n ||| x < 2 ^ (n + m)",
    "name": "Nat.append_lt",
    "isProp": true,
    "doc":
    "Note that the LHS is the expression used within `Std.BitVec.append`, hence the name. ",
    "depth": 16}],
  "count": 13},
 {"noDocExamples":
  [{"type":
    "âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] [inst_1 : CategoryTheory.MonoidalCategory C] {X : C}\n  [inst_2 : CategoryTheory.HasRightDual X], CategoryTheory.CategoryStruct.id Xá˜ = CategoryTheory.CategoryStruct.id Xá˜",
    "name": "CategoryTheory.rightAdjointMate_id",
    "isProp": true,
    "depth": 15},
   {"type":
    "âˆ€ {C : Type u_2} [inst : CategoryTheory.Category.{u_1, u_2} C] [inst_1 : CategoryTheory.MonoidalCategory C]\n  {X Yâ‚ Yâ‚‚ : C} (pâ‚ : CategoryTheory.ExactPairing X Yâ‚) (pâ‚‚ : CategoryTheory.ExactPairing X Yâ‚‚),\n  CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.id Xá˜) (CategoryTheory.CategoryStruct.id Xá˜) =\n    CategoryTheory.CategoryStruct.id Yâ‚‚",
    "name": "CategoryTheory.rightDualIso.proof_2",
    "isProp": true,
    "depth": 21}],
  "kind": "CategoryTheory.Â«term_á˜_1Â»",
  "examples":
  [{"type":
    "âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] [inst_1 : CategoryTheory.MonoidalCategory C] {X Y Z : C}\n  [inst_2 : CategoryTheory.HasRightDual X] [inst_3 : CategoryTheory.HasRightDual Y]\n  [inst_4 : CategoryTheory.HasRightDual Z] {f : X âŸ¶ Y} {g : Y âŸ¶ Z},\n  CategoryTheory.CategoryStruct.comp f gá˜ = CategoryTheory.CategoryStruct.comp (gá˜) (fá˜)",
    "name": "CategoryTheory.comp_rightAdjointMate",
    "isProp": true,
    "doc":
    "The composition of right adjoint mates is the adjoint mate of the composition. ",
    "depth": 22}],
  "count": 13},
 {"noDocExamples": [],
  "kind": "Bundle.Â«term_*áµ–_Â»",
  "examples":
  [{"type":
    "{B : Type u_1} â†’\n  {F : Type u_2} â†’\n    {E : B â†’ Type u_3} â†’ {B' : Type u_4} â†’ (f : B' â†’ B) â†’ Bundle.TotalSpace F (f *áµ– E) â†’ B' Ã— Bundle.TotalSpace F E",
    "name": "Bundle.pullbackTotalSpaceEmbedding",
    "isProp": false,
    "doc":
    "Natural embedding of the total space of `f *áµ– E` into `B' Ã— TotalSpace F E`. ",
    "depth": 11},
   {"type":
    "{B : Type u_1} â†’\n  {F : Type u_2} â†’\n    {E : B â†’ Type u_3} â†’ {B' : Type u_4} â†’ (f : B' â†’ B) â†’ Bundle.TotalSpace F (f *áµ– E) â†’ Bundle.TotalSpace F E",
    "name": "Bundle.Pullback.lift",
    "isProp": false,
    "doc":
    "The base map `f : B' â†’ B` lifts to a canonical map on the total spaces. ",
    "depth": 11},
   {"type":
    "{B : Type u} â†’\n  (F : Type v) â†’\n    (E : B â†’ Type wâ‚) â†’\n      {B' : Type wâ‚‚} â†’\n        (f : B' â†’ B) â†’\n          [inst : TopologicalSpace B'] â†’\n            [inst : TopologicalSpace (Bundle.TotalSpace F E)] â†’ TopologicalSpace (Bundle.TotalSpace F (f *áµ– E))",
    "name": "Pullback.TotalSpace.topologicalSpace",
    "isProp": false,
    "doc":
    "The topology on the total space of a pullback bundle is the coarsest topology for which both\nthe projections to the base and the map to the original bundle are continuous. ",
    "depth": 13}],
  "count": 13},
 {"noDocExamples": [],
  "kind": "GradedTensorProduct.Â«term_áµâŠ—â‚œ[_]_Â»",
  "examples":
  [{"type":
    "âˆ€ {R : Type u_1} {Î¹ : Type u_2} {A : Type u_3} {B : Type u_4} [inst : CommSemiring Î¹] [inst_1 : Module Î¹ (Additive â„¤Ë£)]\n  [inst_2 : DecidableEq Î¹] [inst_3 : CommRing R] [inst_4 : Ring A] [inst_5 : Ring B] [inst_6 : Algebra R A]\n  [inst_7 : Algebra R B] (ğ’œ : Î¹ â†’ Submodule R A) (â„¬ : Î¹ â†’ Submodule R B) [inst_8 : GradedAlgebra ğ’œ]\n  [inst_9 : GradedAlgebra â„¬] {iâ‚‚ : Î¹} (aâ‚ : A) (bâ‚ : â†¥(â„¬ 0)) (aâ‚‚ : â†¥(ğ’œ iâ‚‚)) (bâ‚‚ : B),\n  aâ‚ áµâŠ—â‚œ[R] â†‘bâ‚ * â†‘aâ‚‚ áµâŠ—â‚œ[R] bâ‚‚ = (aâ‚ * â†‘aâ‚‚) áµâŠ—â‚œ[R] (â†‘bâ‚ * bâ‚‚)",
    "name": "GradedTensorProduct.tmul_zero_coe_mul_coe_tmul",
    "isProp": true,
    "doc": "A special case for when `bâ‚` has grade 0. ",
    "depth": 44},
   {"type":
    "âˆ€ {R : Type u_1} {Î¹ : Type u_2} {A : Type u_3} {B : Type u_4} [inst : CommSemiring Î¹] [inst_1 : Module Î¹ (Additive â„¤Ë£)]\n  [inst_2 : DecidableEq Î¹] [inst_3 : CommRing R] [inst_4 : Ring A] [inst_5 : Ring B] [inst_6 : Algebra R A]\n  [inst_7 : Algebra R B] (ğ’œ : Î¹ â†’ Submodule R A) (â„¬ : Î¹ â†’ Submodule R B) [inst_8 : GradedAlgebra ğ’œ]\n  [inst_9 : GradedAlgebra â„¬] {jâ‚ : Î¹} (aâ‚ : A) (bâ‚ : â†¥(â„¬ jâ‚)) (aâ‚‚ : â†¥(ğ’œ 0)) (bâ‚‚ : B),\n  aâ‚ áµâŠ—â‚œ[R] â†‘bâ‚ * â†‘aâ‚‚ áµâŠ—â‚œ[R] bâ‚‚ = (aâ‚ * â†‘aâ‚‚) áµâŠ—â‚œ[R] (â†‘bâ‚ * bâ‚‚)",
    "name": "GradedTensorProduct.tmul_coe_mul_zero_coe_tmul",
    "isProp": true,
    "doc": "A special case for when `aâ‚‚` has grade 0. ",
    "depth": 44},
   {"type":
    "âˆ€ {R : Type u_1} {Î¹ : Type u_2} {A : Type u_3} {B : Type u_4} [inst : CommSemiring Î¹] [inst_1 : Module Î¹ (Additive â„¤Ë£)]\n  [inst_2 : DecidableEq Î¹] [inst_3 : CommRing R] [inst_4 : Ring A] [inst_5 : Ring B] [inst_6 : Algebra R A]\n  [inst_7 : Algebra R B] (ğ’œ : Î¹ â†’ Submodule R A) (â„¬ : Î¹ â†’ Submodule R B) [inst_8 : GradedAlgebra ğ’œ]\n  [inst_9 : GradedAlgebra â„¬] {jâ‚ iâ‚‚ : Î¹} (aâ‚ : A) (bâ‚ : â†¥(â„¬ jâ‚)) (aâ‚‚ : â†¥(ğ’œ iâ‚‚)) (bâ‚‚ : B),\n  aâ‚ áµâŠ—â‚œ[R] â†‘bâ‚ * â†‘aâ‚‚ áµâŠ—â‚œ[R] bâ‚‚ = (-1) ^ (jâ‚ * iâ‚‚) â€¢ (aâ‚ * â†‘aâ‚‚) áµâŠ—â‚œ[R] (â†‘bâ‚ * bâ‚‚)",
    "name": "GradedTensorProduct.tmul_coe_mul_coe_tmul",
    "isProp": true,
    "doc":
    "The characterization of this multiplication on partially homogenous elements. ",
    "depth": 48}],
  "count": 13},
 {"noDocExamples":
  [{"type":
    "âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] [inst_1 : CategoryTheory.MonoidalCategory C] {X : C}\n  [inst_2 : CategoryTheory.HasLeftDual X], (á˜CategoryTheory.CategoryStruct.id X) = CategoryTheory.CategoryStruct.id á˜X",
    "name": "CategoryTheory.leftAdjointMate_id",
    "isProp": true,
    "depth": 15},
   {"type":
    "âˆ€ {C : Type u_2} [inst : CategoryTheory.Category.{u_1, u_2} C] [inst_1 : CategoryTheory.MonoidalCategory C]\n  {Xâ‚ Xâ‚‚ Y : C} (pâ‚ : CategoryTheory.ExactPairing Xâ‚ Y) (pâ‚‚ : CategoryTheory.ExactPairing Xâ‚‚ Y),\n  CategoryTheory.CategoryStruct.comp (á˜CategoryTheory.CategoryStruct.id Y) (á˜CategoryTheory.CategoryStruct.id Y) =\n    CategoryTheory.CategoryStruct.id Xâ‚",
    "name": "CategoryTheory.leftDualIso.proof_1",
    "isProp": true,
    "depth": 21}],
  "kind": "CategoryTheory.Â«termá˜__1Â»",
  "examples":
  [{"type":
    "âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] [inst_1 : CategoryTheory.MonoidalCategory C] {X Y Z : C}\n  [inst_2 : CategoryTheory.HasLeftDual X] [inst_3 : CategoryTheory.HasLeftDual Y]\n  [inst_4 : CategoryTheory.HasLeftDual Z] {f : X âŸ¶ Y} {g : Y âŸ¶ Z},\n  (á˜CategoryTheory.CategoryStruct.comp f g) = CategoryTheory.CategoryStruct.comp (á˜g) (á˜f)",
    "name": "CategoryTheory.comp_leftAdjointMate",
    "isProp": true,
    "doc":
    "The composition of left adjoint mates is the adjoint mate of the composition. ",
    "depth": 22}],
  "count": 13},
 {"noDocExamples":
  [{"type": "âˆ€ {x : ZFSet}, ZFSet.IsTransitive x â†’ ZFSet.IsTransitive (â‹ƒâ‚€ x)",
    "name": "ZFSet.IsTransitive.sUnion",
    "isProp": true,
    "depth": 4},
   {"type": "âˆ€ (x : ZFSet), â†‘(â‹ƒâ‚€ x) = â‹ƒâ‚€ â†‘x",
    "name": "Class.coe_sUnion",
    "isProp": true,
    "depth": 5}],
  "kind": "ZFSet.Â«termâ‹ƒâ‚€_Â»",
  "examples":
  [{"type": "âˆ€ {x : ZFSet}, ZFSet.IsTransitive x â†’ â‹ƒâ‚€ x âŠ† x",
    "name": "ZFSet.IsTransitive.sUnion_subset",
    "isProp": true,
    "doc":
    "**Alias** of the forward direction of `ZFSet.isTransitive_iff_sUnion_subset`.",
    "depth": 6}],
  "count": 12},
 {"noDocExamples":
  [{"type": "âˆ€ {Î± : Type u} (s : Stream' Î±), [] ++â‚› s = s",
    "name": "Stream'.nil_append_stream",
    "isProp": true,
    "depth": 7},
   {"type":
    "âˆ€ {Î± : Type u} (l : List Î±) (h : l â‰  []), Stream'.cycle l h = l ++â‚› Stream'.cycle l h",
    "name": "Stream'.cycle_eq",
    "isProp": true,
    "depth": 8},
   {"type":
    "âˆ€ {Î± : Type u} (l : List Î±) (s : Stream' Î±), â†‘(l ++â‚› s) = Stream'.Seq.append â†‘l â†‘s",
    "name": "Stream'.Seq.ofStream_append",
    "isProp": true,
    "depth": 9}],
  "kind": "Stream'.Â«term_++â‚›_Â»",
  "examples": [],
  "count": 11},
 {"noDocExamples": [],
  "kind": "Â«termâˆ¯_InT(_,_),_Â»",
  "examples":
  [{"type":
    "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] (f : (Fin 1 â†’ â„‚) â†’ E) (c : Fin 1 â†’ â„‚)\n  (R : Fin 1 â†’ â„), (âˆ¯ (x : Fin 1 â†’ â„‚) in T(c, R), f x) = âˆ® (z : â„‚) in C(c 0, R 0), f fun x => z",
    "name": "torusIntegral_dim1",
    "isProp": true,
    "doc":
    "In dimension one, `torusIntegral` is the same as `circleIntegral`\n(up to the natural equivalence between `â„‚` and `Fin 1 â†’ â„‚`). ",
    "depth": 18},
   {"type":
    "âˆ€ {n : â„•} {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {f : (Fin n â†’ â„‚) â†’ E} {c : Fin n â†’ â„‚}\n  {R : Fin n â†’ â„} {C : â„},\n  (âˆ€ (Î¸ : Fin n â†’ â„), â€–f (torusMap c R Î¸)â€– â‰¤ C) â†’\n    â€–âˆ¯ (x : Fin n â†’ â„‚) in T(c, R), f xâ€– â‰¤ ((2 * Real.pi) ^ n * Finset.prod Finset.univ fun i => |R i|) * C",
    "name": "norm_torusIntegral_le_of_norm_le_const",
    "isProp": true,
    "doc":
    "If for all `Î¸ : â„â¿`, `â€–f (torusMap c R Î¸)â€–` is less than or equal to a constant `C : â„`, then\n`â€–âˆ¯ x in T(c, R), f xâ€–` is less than or equal to `(2 * Ï€)^n * (âˆ i, |R i|) * C`",
    "depth": 24},
   {"type":
    "âˆ€ {n : â„•} {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„‚ E] {f : (Fin (n + 1) â†’ â„‚) â†’ E}\n  {c : Fin (n + 1) â†’ â„‚} {R : Fin (n + 1) â†’ â„},\n  TorusIntegrable f c R â†’\n    (âˆ¯ (x : Fin (n + 1) â†’ â„‚) in T(c, R), f x) =\n      âˆ® (x : â„‚) in C(c 0, R 0), âˆ¯ (y : Fin n â†’ â„‚) in T(c âˆ˜ Fin.succ, R âˆ˜ Fin.succ), f (Fin.cons x y)",
    "name": "torusIntegral_succ",
    "isProp": true,
    "doc":
    "Recurrent formula for `torusIntegral`, see also `torusIntegral_succAbove`. ",
    "depth": 29}],
  "count": 11},
 {"noDocExamples": [],
  "kind": "CategoryTheory.Â«term_â¥¤áµ£_Â»",
  "examples":
  [{"type":
    "{C : Type uâ‚} â†’\n  [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] â†’\n    {D : Type uâ‚‚} â†’\n      [inst_1 : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D] â†’\n        (F : CategoryTheory.Functor C D) â†’ [inst_2 : CategoryTheory.Limits.PreservesFiniteColimits F] â†’ C â¥¤áµ£ D",
    "name": "CategoryTheory.RightExactFunctor.of",
    "isProp": false,
    "doc":
    "Turn a right exact functor into an object of the category `RightExactFunctor C D`. ",
    "depth": 11},
   {"type":
    "(C : Type uâ‚) â†’\n  [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] â†’\n    (D : Type uâ‚‚) â†’\n      [inst_1 : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D] â†’ CategoryTheory.Functor (C â¥¤áµ£ D) (CategoryTheory.Functor C D)",
    "name": "CategoryTheory.RightExactFunctor.forget",
    "isProp": false,
    "doc": "A right exact functor is in particular a functor. ",
    "depth": 12},
   {"type":
    "(C : Type uâ‚) â†’\n  [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] â†’\n    (D : Type uâ‚‚) â†’ [inst_1 : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D] â†’ CategoryTheory.Functor (C â¥¤â‚‘ D) (C â¥¤áµ£ D)",
    "name": "CategoryTheory.RightExactFunctor.ofExact",
    "isProp": false,
    "doc": "Turn an exact functor into a left exact functor. ",
    "depth": 12}],
  "count": 11},
 {"noDocExamples":
  [{"type": "âˆ€ {Î± : Type u_1} [inst : Primcodable Î±] (p : Î± â†’ Prop), p â‰¤â‚ p",
    "name": "oneOneReducible_refl",
    "isProp": true,
    "depth": 9},
   {"type":
    "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : Primcodable Î±] [inst_1 : Primcodable Î²] {p : Î± â†’ Prop} {q : Î² â†’ Prop},\n  p â‰¤â‚ Sum.elim p q",
    "name": "OneOneReducible.disjoin_left",
    "isProp": true,
    "depth": 13},
   {"type":
    "âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : Primcodable Î±] [inst_1 : Primcodable Î²] {p : Î± â†’ Prop} {q : Î² â†’ Prop},\n  p â‰¤â‚ q â†’ p â‰¤â‚€ q",
    "name": "OneOneReducible.to_many_one",
    "isProp": true,
    "depth": 13}],
  "kind": "Â«term_â‰¤â‚_Â»",
  "examples": [],
  "count": 11},
 {"noDocExamples":
  [{"type": "âˆ€ (a : Cardinal.{u_1}), Monotone fun c => a ^< c",
    "name": "Cardinal.powerlt_mono_left",
    "isProp": true,
    "depth": 6},
   {"type":
    "âˆ€ {c : Cardinal.{u_1}}, Cardinal.aleph0 â‰¤ c â†’ c ^< Cardinal.aleph0 = c",
    "name": "Cardinal.powerlt_aleph0",
    "isProp": true,
    "depth": 6},
   {"type":
    "âˆ€ (c : Cardinal.{u_1}), c ^< Cardinal.aleph0 â‰¤ max c Cardinal.aleph0",
    "name": "Cardinal.powerlt_aleph0_le",
    "isProp": true,
    "depth": 7}],
  "kind": "Cardinal.Â«term_^<_Â»",
  "examples": [],
  "count": 11},
 {"noDocExamples": [],
  "kind": "CategoryTheory.Â«term_â¥¤â‚—_Â»",
  "examples":
  [{"type":
    "{C : Type uâ‚} â†’\n  [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] â†’\n    {D : Type uâ‚‚} â†’\n      [inst_1 : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D] â†’\n        (F : CategoryTheory.Functor C D) â†’ [inst_2 : CategoryTheory.Limits.PreservesFiniteLimits F] â†’ C â¥¤â‚— D",
    "name": "CategoryTheory.LeftExactFunctor.of",
    "isProp": false,
    "doc":
    "Turn a left exact functor into an object of the category `LeftExactFunctor C D`. ",
    "depth": 11},
   {"type":
    "(C : Type uâ‚) â†’\n  [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] â†’\n    (D : Type uâ‚‚) â†’ [inst_1 : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D] â†’ CategoryTheory.Functor (C â¥¤â‚‘ D) (C â¥¤â‚— D)",
    "name": "CategoryTheory.LeftExactFunctor.ofExact",
    "isProp": false,
    "doc": "Turn an exact functor into a left exact functor. ",
    "depth": 12},
   {"type":
    "(C : Type uâ‚) â†’\n  [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] â†’\n    (D : Type uâ‚‚) â†’\n      [inst_1 : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D] â†’ CategoryTheory.Functor (C â¥¤â‚— D) (CategoryTheory.Functor C D)",
    "name": "CategoryTheory.LeftExactFunctor.forget",
    "isProp": false,
    "doc": "A left exact functor is in particular a functor. ",
    "depth": 12}],
  "count": 11},
 {"noDocExamples":
  [{"type":
    "âˆ€ {U : Type u_1} [inst : Quiver U] [inst_1 : Quiver.HasReverse U], Prefunctor.MapReverse (ğŸ­q U)",
    "name": "Prefunctor.mapReverseId",
    "isProp": true,
    "depth": 10},
   {"type":
    "âˆ€ {V : Type u} [inst : Quiver V],\n  CategoryTheory.freeGroupoidFunctor (ğŸ­q V) = CategoryTheory.Functor.id (CategoryTheory.FreeGroupoid V)",
    "name": "CategoryTheory.Groupoid.Free.freeGroupoidFunctor_id",
    "isProp": true,
    "depth": 11},
   {"type": "âˆ€ (V : Type u_1) [inst : Quiver V] (X : V), (ğŸ­q V).obj X = X",
    "name": "Prefunctor.id_obj",
    "isProp": true,
    "depth": 11}],
  "kind": "Prefunctor.Â«termğŸ­qÂ»",
  "examples": [],
  "count": 10},
 {"noDocExamples": [],
  "kind": "CategoryTheory.Â«term_â¥¤+_Â»",
  "examples":
  [{"type":
    "{C : Type u_1} â†’\n  {D : Type u_2} â†’\n    [inst : CategoryTheory.Category.{u_3, u_1} C] â†’\n      [inst_1 : CategoryTheory.Category.{u_4, u_2} D] â†’\n        [inst_2 : CategoryTheory.Preadditive C] â†’\n          [inst_3 : CategoryTheory.Preadditive D] â†’\n            (F : CategoryTheory.Functor C D) â†’ [inst_4 : CategoryTheory.Functor.Additive F] â†’ C â¥¤+ D",
    "name": "CategoryTheory.AdditiveFunctor.of",
    "isProp": false,
    "doc":
    "Turn an additive functor into an object of the category `AdditiveFunctor C D`. ",
    "depth": 15},
   {"type":
    "(C : Type u_1) â†’\n  (D : Type u_2) â†’\n    [inst : CategoryTheory.Category.{u_3, u_1} C] â†’\n      [inst_1 : CategoryTheory.Category.{u_4, u_2} D] â†’\n        [inst_2 : CategoryTheory.Preadditive C] â†’\n          [inst_3 : CategoryTheory.Preadditive D] â†’ CategoryTheory.Functor (C â¥¤+ D) (CategoryTheory.Functor C D)",
    "name": "CategoryTheory.AdditiveFunctor.forget",
    "isProp": false,
    "doc": "An additive functor is in particular a functor. ",
    "depth": 16},
   {"type":
    "(C : Type uâ‚) â†’\n  (D : Type uâ‚‚) â†’\n    [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] â†’\n      [inst_1 : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D] â†’\n        [inst_2 : CategoryTheory.Preadditive C] â†’\n          [inst_3 : CategoryTheory.Preadditive D] â†’\n            [inst_4 : CategoryTheory.Limits.HasZeroObject C] â†’\n              [inst_5 : CategoryTheory.Limits.HasZeroObject D] â†’\n                [inst_6 : CategoryTheory.Limits.HasBinaryBiproducts C] â†’ CategoryTheory.Functor (C â¥¤â‚— D) (C â¥¤+ D)",
    "name": "CategoryTheory.AdditiveFunctor.ofLeftExact",
    "isProp": false,
    "doc": "Turn a left exact functor into an additive functor. ",
    "depth": 17}],
  "count": 10},
 {"noDocExamples":
  [{"type":
    "âˆ€ {x y : CategoryTheory.Limits.WalkingParallelFamily (ULift.{w, 0} Bool)} (h : x âŸ¶ y),\n  CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair.functor.map h =\n    match x, y, h with\n    | x, .(x), CategoryTheory.Limits.WalkingParallelFamily.Hom.id .(x) =>\n      CategoryTheory.CategoryStruct.id\n        (CategoryTheory.Limits.WalkingParallelFamily.rec CategoryTheory.Limits.WalkingParallelPair.zero\n          CategoryTheory.Limits.WalkingParallelPair.one x)\n    | .(CategoryTheory.Limits.WalkingParallelFamily.zero), .(CategoryTheory.Limits.WalkingParallelFamily.one),\n      CategoryTheory.Limits.WalkingParallelFamily.Hom.line j =>\n      bif j.down then CategoryTheory.Limits.WalkingParallelPairHom.left\n      else CategoryTheory.Limits.WalkingParallelPairHom.right",
    "name":
    "CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair_functor_map",
    "isProp": true,
    "depth": 22},
   {"type":
    "âˆ€ {X Y : CategoryTheory.Limits.WalkingParallelPair} (h : X âŸ¶ Y),\n  CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair.inverse.map h =\n    match X, Y, h with\n    | x, .(x), CategoryTheory.Limits.WalkingParallelPairHom.id .(x) =>\n      CategoryTheory.CategoryStruct.id\n        (match x with\n        | CategoryTheory.Limits.WalkingParallelPair.zero => CategoryTheory.Limits.WalkingParallelFamily.zero\n        | CategoryTheory.Limits.WalkingParallelPair.one => CategoryTheory.Limits.WalkingParallelFamily.one)\n    | .(CategoryTheory.Limits.WalkingParallelPair.zero), .(CategoryTheory.Limits.WalkingParallelPair.one),\n      CategoryTheory.Limits.WalkingParallelPairHom.left =>\n      CategoryTheory.Limits.WalkingParallelFamily.Hom.line { down := true }\n    | .(CategoryTheory.Limits.WalkingParallelPair.zero), .(CategoryTheory.Limits.WalkingParallelPair.one),\n      CategoryTheory.Limits.WalkingParallelPairHom.right =>\n      CategoryTheory.Limits.WalkingParallelFamily.Hom.line { down := false }",
    "name":
    "CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair_inverse_map",
    "isProp": true,
    "depth": 23},
   {"type":
    "âˆ€ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] (I : CategoryTheory.Limits.MulticospanIndex C)\n  [inst_1 : CategoryTheory.Limits.HasProduct I.left] [inst_2 : CategoryTheory.Limits.HasProduct I.right]\n  {X Y : CategoryTheory.Limits.WalkingParallelPair} (h : X âŸ¶ Y),\n  (CategoryTheory.Limits.MulticospanIndex.parallelPairDiagram I).map h =\n    match X, Y, h with\n    | x, .(x), CategoryTheory.Limits.WalkingParallelPairHom.id .(x) =>\n      CategoryTheory.CategoryStruct.id\n        (match x with\n        | CategoryTheory.Limits.WalkingParallelPair.zero => âˆ I.left\n        | CategoryTheory.Limits.WalkingParallelPair.one => âˆ I.right)\n    | .(CategoryTheory.Limits.WalkingParallelPair.zero), .(CategoryTheory.Limits.WalkingParallelPair.one),\n      CategoryTheory.Limits.WalkingParallelPairHom.left => CategoryTheory.Limits.MulticospanIndex.fstPiMap I\n    | .(CategoryTheory.Limits.WalkingParallelPair.zero), .(CategoryTheory.Limits.WalkingParallelPair.one),\n      CategoryTheory.Limits.WalkingParallelPairHom.right => CategoryTheory.Limits.MulticospanIndex.sndPiMap I",
    "name": "CategoryTheory.Limits.MulticospanIndex.parallelPairDiagram_map",
    "isProp": true,
    "depth": 32}],
  "kind": "Lean.Parser.Term.inaccessible",
  "examples": [],
  "count": 9},
 {"noDocExamples": [],
  "kind": "MeasureTheory.Â«termâˆ«â»_,_Â»",
  "examples":
  [{"type":
    "âˆ€ (r : â„), 0 < r â†’ âˆ«â» (x : â„), ProbabilityTheory.exponentialPdf r x = 1",
    "name": "ProbabilityTheory.lintegral_exponentialPdf_eq_one",
    "isProp": true,
    "doc": "The Pdf of the exponential Distribution integrates to 1",
    "depth": 9},
   {"type":
    "âˆ€ (Î¼ : â„) {v : NNReal}, v â‰  0 â†’ âˆ«â» (x : â„), ENNReal.ofReal (ProbabilityTheory.gaussianPdfReal Î¼ v x) = 1",
    "name": "ProbabilityTheory.lintegral_gaussianPdfReal_eq_one",
    "isProp": true,
    "doc":
    "The gaussian distribution pdf integrates to 1 when the variance is not zero.  ",
    "depth": 11},
   {"type":
    "âˆ€ (t : â„) (f : UnitAddCircle â†’ ENNReal), âˆ«â» (a : â„) in Set.Ioc t (t + 1), f â†‘a = âˆ«â» (b : UnitAddCircle), f b",
    "name": "UnitAddCircle.lintegral_preimage",
    "isProp": true,
    "doc":
    "The integral of a measurable function over `UnitAddCircle` is equal to the integral over an\ninterval (t, t + 1] in `â„` of its lift to `â„`. ",
    "depth": 15}],
  "count": 9},
 {"noDocExamples":
  [{"type":
    "âˆ€ {Î± : Type u} (sâ‚ : Stream' Î±), Stream'.even sâ‚ â‹ˆ Stream'.odd sâ‚ = sâ‚",
    "name": "Stream'.interleave_even_odd",
    "isProp": true,
    "depth": 8},
   {"type":
    "âˆ€ {Î± : Type u} (sâ‚ sâ‚‚ : Stream' Î±), Stream'.tail sâ‚ â‹ˆ Stream'.tail sâ‚‚ = Stream'.tail (Stream'.tail (sâ‚ â‹ˆ sâ‚‚))",
    "name": "Stream'.interleave_tail_tail",
    "isProp": true,
    "depth": 9},
   {"type":
    "âˆ€ {Î± : Type u} (sâ‚ sâ‚‚ : Stream' Î±), Stream'.tail (sâ‚ â‹ˆ sâ‚‚) = sâ‚‚ â‹ˆ Stream'.tail sâ‚",
    "name": "Stream'.tail_interleave",
    "isProp": true,
    "depth": 9}],
  "kind": "Stream'.Â«term_â‹ˆ_Â»",
  "examples": [],
  "count": 9},
 {"noDocExamples":
  [{"type": "âˆ€ (b : Bool), (Bool.toNat b != 1) = !b",
    "name": "Bool.toNat_bne_one",
    "isProp": true,
    "depth": 7},
   {"type": "âˆ€ (b : Bool), (Bool.toNat b != 0) = b",
    "name": "Bool.toNat_bne_zero",
    "isProp": true,
    "depth": 7},
   {"type": "âˆ€ (n : â„•), Nat.bodd n = (n &&& 1 != 0)",
    "name": "Nat.bodd_eq_and_one_ne_zero",
    "isProp": true,
    "depth": 10}],
  "kind": "Â«term_!=_Â»",
  "examples": [],
  "count": 7},
 {"noDocExamples":
  [{"type": "â‹‚â‚€ âˆ… = âˆ…",
    "name": "ZFSet.sInter_empty",
    "isProp": true,
    "depth": 5},
   {"type": "âˆ€ {x : ZFSet}, ZFSet.Nonempty x â†’ â†‘(â‹‚â‚€ x) = â‹‚â‚€ â†‘x",
    "name": "Class.coe_sInter",
    "isProp": true,
    "depth": 6},
   {"type": "âˆ€ {x : ZFSet}, â‹‚â‚€ {x} = x",
    "name": "ZFSet.sInter_singleton",
    "isProp": true,
    "depth": 8}],
  "kind": "ZFSet.Â«termâ‹‚â‚€_Â»",
  "examples": [],
  "count": 7},
 {"noDocExamples":
  [{"type":
    "âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] {Î¼ : MeasureTheory.Measure Î±} {p : Î± â†’ Prop},\n  (âˆƒáµ (a : Î±) âˆ‚Î¼, p a) â†” â†‘â†‘Î¼ {a | p a} â‰  0",
    "name": "MeasureTheory.frequently_ae_iff",
    "isProp": true,
    "depth": 12},
   {"type":
    "âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] {Î¼ : MeasureTheory.Measure Î±} {s : Set Î±},\n  (âˆƒáµ (a : Î±) âˆ‚Î¼, a âˆˆ s) â†” â†‘â†‘Î¼ s â‰  0",
    "name": "MeasureTheory.frequently_ae_mem_iff",
    "isProp": true,
    "depth": 14}],
  "kind": "MeasureTheory.Â«termâˆƒáµ_âˆ‚_,_Â»",
  "examples":
  [{"type":
    "âˆ€ {Î± : Type u_2} [inst : MeasurableSpace Î±] {f : Î± â†’ Î±} {s : Set Î±} {Î¼ : MeasureTheory.Measure Î±},\n  MeasureTheory.Conservative f Î¼ â†’\n    MeasurableSet s â†’ â†‘â†‘Î¼ s â‰  0 â†’ âˆƒáµ (x : Î±) âˆ‚Î¼, x âˆˆ s âˆ§ âˆƒá¶  (n : â„•) in Filter.atTop, f^[n] x âˆˆ s",
    "name":
    "MeasureTheory.Conservative.frequently_ae_mem_and_frequently_image_mem",
    "isProp": true,
    "doc":
    "If `f` is a conservative self-map and `s` is a measurable set of positive measure, then\n`Î¼.ae`-frequently we have `x âˆˆ s` and `s` returns to `s` under infinitely many iterations of `f`. ",
    "depth": 21}],
  "count": 5},
 {"noDocExamples":
  [{"type": "â‹‚â‚€ âˆ… = Class.univ",
    "name": "Class.sInter_empty",
    "isProp": true,
    "depth": 5},
   {"type": "âˆ€ {x : ZFSet}, ZFSet.Nonempty x â†’ â†‘(â‹‚â‚€ x) = â‹‚â‚€ â†‘x",
    "name": "Class.coe_sInter",
    "isProp": true,
    "depth": 6},
   {"type": "âˆ€ {x : Class} {y : ZFSet}, (â‹‚â‚€ x) y â†” âˆ€ (z : ZFSet), x z â†’ y âˆˆ z",
    "name": "Class.sInter_apply",
    "isProp": true,
    "depth": 10}],
  "kind": "Class.Â«termâ‹‚â‚€_Â»",
  "examples": [],
  "count": 5},
 {"noDocExamples": [],
  "kind": "Â«term_â‰ƒâ‚—áµ¢â‹†[_]_Â»",
  "examples":
  [{"type":
    "(ğ•œ : Type u_1) â†’\n  {E : Type u_2} â†’\n    [inst : CommSemiring ğ•œ] â†’\n      [inst_1 : StarRing ğ•œ] â†’\n        [inst_2 : SeminormedAddCommGroup E] â†’\n          [inst_3 : StarAddMonoid E] â†’\n            [inst_4 : NormedStarGroup E] â†’ [inst_5 : Module ğ•œ E] â†’ [inst_6 : StarModule ğ•œ E] â†’ E â‰ƒâ‚—áµ¢â‹†[ğ•œ] E",
    "name": "starâ‚—áµ¢",
    "isProp": false,
    "doc": "`star` bundled as a linear isometric equivalence ",
    "depth": 23},
   {"type":
    "(ğ•œ : Type u_1) â†’\n  (E : Type u_2) â†’\n    [inst : IsROrC ğ•œ] â†’\n      [inst_1 : NormedAddCommGroup E] â†’\n        [inst_2 : InnerProductSpace ğ•œ E] â†’ [inst_3 : CompleteSpace E] â†’ E â‰ƒâ‚—áµ¢â‹†[ğ•œ] NormedSpace.Dual ğ•œ E",
    "name": "InnerProductSpace.toDual",
    "isProp": false,
    "doc":
    "FrÃ©chet-Riesz representation: any `â„“` in the dual of a Hilbert space `E` is of the form\n`fun u => âŸªy, uâŸ«` for some `y : E`, i.e. `toDualMap` is surjective.\n",
    "depth": 31},
   {"type":
    "{ğ•œ : Type u_1} â†’\n  {E : Type u_2} â†’\n    {F : Type u_3} â†’\n      [inst : IsROrC ğ•œ] â†’\n        [inst_1 : NormedAddCommGroup E] â†’\n          [inst_2 : NormedAddCommGroup F] â†’\n            [inst_3 : InnerProductSpace ğ•œ E] â†’\n              [inst_4 : InnerProductSpace ğ•œ F] â†’\n                [inst_5 : CompleteSpace E] â†’ [inst_6 : CompleteSpace F] â†’ (E â†’L[ğ•œ] F) â‰ƒâ‚—áµ¢â‹†[ğ•œ] F â†’L[ğ•œ] E",
    "name": "ContinuousLinearMap.adjoint",
    "isProp": false,
    "doc":
    "The adjoint of a bounded operator from Hilbert space `E` to Hilbert space `F`. ",
    "depth": 35}],
  "count": 5},
 {"noDocExamples":
  [{"type": "âˆ€ {Î± : Type u} (s : Stream' Î±), Stream'.pure id âŠ› s = s",
    "name": "Stream'.identity",
    "isProp": true,
    "depth": 9},
   {"type":
    "âˆ€ {Î± : Type u} {Î² : Type v} (f : Î± â†’ Î²) (s : Stream' Î±), Stream'.map f s = Stream'.pure f âŠ› s",
    "name": "Stream'.map_eq_apply",
    "isProp": true,
    "depth": 10},
   {"type":
    "âˆ€ {Î± : Type u} {Î² : Type v} (f : Î± â†’ Î²) (a : Î±), Stream'.pure f âŠ› Stream'.pure a = Stream'.pure (f a)",
    "name": "Stream'.homomorphism",
    "isProp": true,
    "depth": 11}],
  "kind": "Stream'.Â«term_âŠ›_Â»",
  "examples": [],
  "count": 5},
 {"noDocExamples":
  [{"type":
    "âˆ€ {Î± : Type u} [inst : Lattice Î±] [inst_1 : AddGroup Î±] (a : Î±), |(-a)| = |a|",
    "name": "LatticeOrderedGroup.abs_neg",
    "isProp": true,
    "depth": 15}],
  "kind": "Lean.Parser.Term.paren",
  "examples":
  [{"type":
    "âˆ€ {Î± : Type u} [inst : Lattice Î±] [inst_1 : AddGroup Î±]\n  [inst_2 : CovariantClass Î± Î± (fun x x_1 => x + x_1) fun x x_1 => x â‰¤ x_1]\n  [inst_3 : CovariantClass Î± Î± (Function.swap fun x x_1 => x + x_1) fun x x_1 => x â‰¤ x_1] (a : Î±), |(|a|)| = |a|",
    "name": "LatticeOrderedGroup.abs_abs",
    "isProp": true,
    "doc": "The unary operation of taking the absolute value is idempotent.",
    "depth": 19},
   {"type":
    "âˆ€ {Î± : Type u} [inst : Lattice Î±] [inst_1 : Group Î±]\n  [inst_2 : CovariantClass Î± Î± (fun x x_1 => x * x_1) fun x x_1 => x â‰¤ x_1]\n  [inst_3 : CovariantClass Î± Î± (Function.swap fun x x_1 => x * x_1) fun x x_1 => x â‰¤ x_1] (a : Î±), |(|a|)| = |a|",
    "name": "LatticeOrderedGroup.mabs_mabs",
    "isProp": true,
    "doc": "The unary operation of taking the absolute value is idempotent. ",
    "depth": 19}],
  "count": 5},
 {"noDocExamples":
  [{"type":
    "âˆ€ {m : Type u â†’ Type v} [inst : Monad m] [inst_1 : LawfulMonad m] {Î± : Type u_1} {Î² : Type u} (f : Î± â†’ m Î²),\n  f >=> pure = f",
    "name": "fish_pure",
    "isProp": true,
    "depth": 15},
   {"type":
    "âˆ€ (m : Type u_1 â†’ Type u_1) [inst : Monad m] [inst_1 : LawfulMonad m] {X Y : CategoryTheory.KleisliCat m} (f : X âŸ¶ Y),\n  f >=> pure = pure >=> f",
    "name": "CategoryTheory.eq.proof_5",
    "isProp": true,
    "depth": 15},
   {"type":
    "âˆ€ {m : Type u â†’ Type v} [inst : Monad m] [inst_1 : LawfulMonad m] {Î± Î² : Type u} (f : Î± â†’ m Î²), pure >=> f = f",
    "name": "fish_pipe",
    "isProp": true,
    "depth": 15}],
  "kind": "Â«term_>=>_Â»",
  "examples": [],
  "count": 4},
 {"noDocExamples":
  [{"type": "âˆ€ (x : ZFSet), â†‘(â‹ƒâ‚€ x) = â‹ƒâ‚€ â†‘x",
    "name": "Class.coe_sUnion",
    "isProp": true,
    "depth": 5},
   {"type": "â‹ƒâ‚€ âˆ… = âˆ…",
    "name": "Class.sUnion_empty",
    "isProp": true,
    "depth": 5},
   {"type": "âˆ€ {x : Class} {y : ZFSet}, (â‹ƒâ‚€ x) y â†” âˆƒ z, x z âˆ§ y âˆˆ z",
    "name": "Class.sUnion_apply",
    "isProp": true,
    "depth": 11}],
  "kind": "Class.Â«termâ‹ƒâ‚€_Â»",
  "examples": [],
  "count": 4},
 {"noDocExamples":
  [{"type": "âˆ€ (x : PSet), PSet.toSet (â‹ƒâ‚€ x) = â‹ƒâ‚€ (PSet.toSet '' PSet.toSet x)",
    "name": "PSet.toSet_sUnion",
    "isProp": true,
    "depth": 7},
   {"type":
    "âˆ€ (x x_1 : PSet), PSet.Equiv x x_1 â†’ PSet.Arity.Equiv (â‹ƒâ‚€ x) (â‹ƒâ‚€ x_1)",
    "name": "ZFSet.sUnion.proof_1",
    "isProp": true,
    "depth": 8},
   {"type": "âˆ€ {x y : PSet}, y âˆˆ â‹ƒâ‚€ x â†” âˆƒ z âˆˆ x, y âˆˆ z",
    "name": "PSet.mem_sUnion",
    "isProp": true,
    "depth": 12}],
  "kind": "PSet.Â«termâ‹ƒâ‚€_Â»",
  "examples": [],
  "count": 4},
 {"noDocExamples":
  [{"type": "âˆ€ (F A : Class), F â€² A âˆˆ Class.univ",
    "name": "Class.fval_ex",
    "isProp": true,
    "depth": 7},
   {"type": "âˆ€ (x : ZFSet), âˆ… âˆ‰ x â†’ âˆ€ y âˆˆ x, â†‘(ZFSet.choice x) â€² â†‘y âˆˆ â†‘y",
    "name": "ZFSet.choice_mem",
    "isProp": true,
    "depth": 10},
   {"type":
    "âˆ€ {f : ZFSet â†’ ZFSet} [H : PSet.Definable 1 f] {x y : ZFSet}, y âˆˆ x â†’ â†‘(ZFSet.map f x) â€² â†‘y = â†‘(f y)",
    "name": "ZFSet.map_fval",
    "isProp": true,
    "depth": 13}],
  "kind": "Class.Â«term_â€²_Â»",
  "examples": [],
  "count": 3},
 {"noDocExamples": [],
  "kind": "Â«term_â‰ƒâ‚—â‹†[_]_Â»",
  "examples":
  [{"type":
    "(R : Type u_1) â†’\n  {A : Type u_2} â†’\n    [inst : CommSemiring R] â†’\n      [inst_1 : StarRing R] â†’\n        [inst_2 : AddCommMonoid A] â†’\n          [inst_3 : StarAddMonoid A] â†’ [inst_4 : Module R A] â†’ [inst_5 : StarModule R A] â†’ A â‰ƒâ‚—â‹†[R] A",
    "name": "starLinearEquiv",
    "isProp": false,
    "doc":
    "If `A` is a module over a commutative `R` with compatible actions,\nthen `star` is a semilinear equivalence. ",
    "depth": 22},
   {"type":
    "(m : Type u_2) â†’\n  (n : Type u_3) â†’\n    (R : Type u_7) â†’\n      (Î± : Type v) â†’\n        [inst : CommSemiring R] â†’\n          [inst_1 : StarRing R] â†’\n            [inst_2 : AddCommMonoid Î±] â†’\n              [inst_3 : StarAddMonoid Î±] â†’\n                [inst_4 : Module R Î±] â†’ [inst_5 : StarModule R Î±] â†’ Matrix m n Î± â‰ƒâ‚—â‹†[R] Matrix n m Î±",
    "name": "Matrix.conjTransposeLinearEquiv",
    "isProp": false,
    "doc": "`Matrix.conjTranspose` as a `LinearMap` ",
    "depth": 24},
   {"type":
    "{ğ•œ : Type u_1} â†’\n  {E : Type u_2} â†’\n    {F : Type u_3} â†’\n      [inst : IsROrC ğ•œ] â†’\n        [inst_1 : NormedAddCommGroup E] â†’\n          [inst_2 : NormedAddCommGroup F] â†’\n            [inst_3 : InnerProductSpace ğ•œ E] â†’\n              [inst_4 : InnerProductSpace ğ•œ F] â†’\n                [inst_5 : FiniteDimensional ğ•œ E] â†’ [inst_6 : FiniteDimensional ğ•œ F] â†’ (E â†’â‚—[ğ•œ] F) â‰ƒâ‚—â‹†[ğ•œ] F â†’â‚—[ğ•œ] E",
    "name": "LinearMap.adjoint",
    "isProp": false,
    "doc":
    "The adjoint of an operator from the finite-dimensional inner product space `E` to the\nfinite-dimensional inner product space `F`. ",
    "depth": 32}],
  "count": 3},
 {"noDocExamples":
  [{"type":
    "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] (f : â„ â†’ E) (a b : â„),\n  â¨ (x : â„) in a..b, f x = â¨ (x : â„) in b..a, f x",
    "name": "interval_average_symm",
    "isProp": true,
    "depth": 15},
   {"type":
    "âˆ€ (f : â„ â†’ â„) (a b : â„), â¨ (x : â„) in a..b, f x = (âˆ« (x : â„) in a..b, f x) / (b - a)",
    "name": "interval_average_eq_div",
    "isProp": true,
    "depth": 16},
   {"type":
    "âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] (f : â„ â†’ E) (a b : â„),\n  â¨ (x : â„) in a..b, f x = (b - a)â»Â¹ â€¢ âˆ« (x : â„) in a..b, f x",
    "name": "interval_average_eq",
    "isProp": true,
    "depth": 22}],
  "kind": "Â«termâ¨_In_.._,_Â»",
  "examples": [],
  "count": 3},
 {"noDocExamples":
  [{"type":
    "âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] [inst_1 : CategoryTheory.MonoidalCategory C] {D : Type uâ‚‚}\n  [inst_2 : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D] [inst_3 : CategoryTheory.MonoidalCategory D] {E : Type uâ‚ƒ}\n  [inst_4 : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E] [inst_5 : CategoryTheory.MonoidalCategory E]\n  (F : CategoryTheory.MonoidalFunctor C D) (G : CategoryTheory.MonoidalFunctor D E),\n  (F âŠ—â‹™ G).toLaxMonoidalFunctor = F.toLaxMonoidalFunctor âŠ—â‹™ G.toLaxMonoidalFunctor",
    "name": "CategoryTheory.MonoidalFunctor.comp_toLaxMonoidalFunctor",
    "isProp": true,
    "depth": 25}],
  "kind": "CategoryTheory.MonoidalFunctor.Â«term_âŠ—â‹™_Â»",
  "examples":
  [{"type":
    "{M : Type u} â†’\n  [inst : Monoid M] â†’\n    {N : Type u'} â†’\n      [inst_1 : Monoid N] â†’\n        {K : Type u} â†’\n          [inst_2 : Monoid K] â†’\n            (F : M â†’* N) â†’\n              (G : N â†’* K) â†’\n                CategoryTheory.Discrete.monoidalFunctor F âŠ—â‹™ CategoryTheory.Discrete.monoidalFunctor G â‰…\n                  CategoryTheory.Discrete.monoidalFunctor (MonoidHom.comp G F)",
    "name": "CategoryTheory.Discrete.monoidalFunctorComp",
    "isProp": false,
    "doc":
    "The monoidal natural isomorphism corresponding to composing two multiplicative morphisms.\n",
    "depth": 22},
   {"type":
    "{M : Type u} â†’\n  [inst : AddMonoid M] â†’\n    {N : Type u'} â†’\n      [inst_1 : AddMonoid N] â†’\n        {K : Type u} â†’\n          [inst_2 : AddMonoid K] â†’\n            (F : M â†’+ N) â†’\n              (G : N â†’+ K) â†’\n                CategoryTheory.Discrete.addMonoidalFunctor F âŠ—â‹™ CategoryTheory.Discrete.addMonoidalFunctor G â‰…\n                  CategoryTheory.Discrete.addMonoidalFunctor (AddMonoidHom.comp G F)",
    "name": "CategoryTheory.Discrete.addMonoidalFunctorComp",
    "isProp": false,
    "doc":
    "The monoidal natural isomorphism corresponding to\ncomposing two additive morphisms.",
    "depth": 22}],
  "count": 3},
 {"noDocExamples": [],
  "kind": "Â«term_â†’â‚—â‹†[_]_Â»",
  "examples":
  [{"type":
    "{ğ•œ : Type u_1} â†’\n  {E : Type u_2} â†’\n    [inst : IsROrC ğ•œ] â†’ [inst_1 : NormedAddCommGroup E] â†’ [inst_2 : InnerProductSpace ğ•œ E] â†’ E â†’â‚—[ğ•œ] E â†’â‚—â‹†[ğ•œ] ğ•œ",
    "name": "sesqFormOfInner",
    "isProp": false,
    "doc":
    "The inner product as a sesquilinear form.\n\nNote that in the case `ğ•œ = â„` this is a bilinear form. ",
    "depth": 26},
   {"type":
    "(ğ•œ : Type u_1) â†’\n  {E : Type u_2} â†’\n    [inst : IsROrC ğ•œ] â†’ [inst_1 : NormedAddCommGroup E] â†’ [inst_2 : InnerProductSpace ğ•œ E] â†’ E â†’â‚—â‹†[ğ•œ] E â†’â‚—[ğ•œ] ğ•œ",
    "name": "innerâ‚›â‚—",
    "isProp": false,
    "doc": "The inner product as a sesquilinear map. ",
    "depth": 26}],
  "count": 2},
 {"noDocExamples": [],
  "kind": "Â«term_â‰ƒLâ‹†[_]_Â»",
  "examples":
  [{"type":
    "(R : Type u_1) â†’\n  {A : Type u_2} â†’\n    [inst : CommSemiring R] â†’\n      [inst_1 : StarRing R] â†’\n        [inst_2 : AddCommMonoid A] â†’\n          [inst_3 : StarAddMonoid A] â†’\n            [inst_4 : Module R A] â†’\n              [inst_5 : StarModule R A] â†’ [inst_6 : TopologicalSpace A] â†’ [inst_7 : ContinuousStar A] â†’ A â‰ƒLâ‹†[R] A",
    "name": "starL",
    "isProp": false,
    "doc":
    "If `A` is a topological module over a commutative `R` with compatible actions,\nthen `star` is a continuous semilinear equivalence. ",
    "depth": 26}],
  "count": 1},
 {"noDocExamples":
  [{"type":
    "âˆ€ {Cont : Type u_1} {Elem : Type u_2} {Dom : Cont â†’ â„• â†’ Prop} {n : â„•} [inst : GetElem Cont â„• Elem Dom] (a : Cont)\n  (i : Fin n) [inst_1 : Decidable (Dom a â†‘i)] [inst_2 : Inhabited Elem], a[i]! = a[â†‘i]!",
    "name": "getElem!_fin",
    "isProp": true,
    "depth": 22}],
  "kind": "Â«term__[_]_!Â»",
  "examples": [],
  "count": 1},
 {"noDocExamples": [],
  "kind": "Â«term_â†’â‚—áµ¢â‹†[_]_Â»",
  "examples":
  [{"type":
    "(ğ•œ : Type u_1) â†’\n  (E : Type u_2) â†’\n    [inst : IsROrC ğ•œ] â†’\n      [inst_1 : NormedAddCommGroup E] â†’ [inst_2 : InnerProductSpace ğ•œ E] â†’ E â†’â‚—áµ¢â‹†[ğ•œ] NormedSpace.Dual ğ•œ E",
    "name": "InnerProductSpace.toDualMap",
    "isProp": false,
    "doc":
    "An element `x` of an inner product space `E` induces an element of the dual space `Dual ğ•œ E`,\nthe map `fun y => âŸªx, yâŸ«`; moreover this operation is a conjugate-linear isometric embedding of `E`\ninto `Dual ğ•œ E`.\nIf `E` is complete, this operation is surjective, hence a conjugate-linear isometric equivalence;\nsee `toDual`.\n",
    "depth": 30}],
  "count": 1},
 {"noDocExamples":
  [{"type":
    "âˆ€ {Î´ : Type u_1} {Î´' : Type u_2} {Ï€ : Î´ â†’ Type u_3} [inst : (x : Î´) â†’ MeasurableSpace (Ï€ x)]\n  {Î¼ : (i : Î´) â†’ MeasureTheory.Measure (Ï€ i)} [inst_1 : âˆ€ (i : Î´), MeasureTheory.SigmaFinite (Î¼ i)]\n  [inst_2 : DecidableEq Î´] [inst_3 : DecidableEq Î´'] {e : Î´' â†’ Î´},\n  Function.Injective e â†’\n    âˆ€ (s : Finset Î´') {f : ((i : Î´') â†’ Ï€ (e i)) â†’ ENNReal},\n      Measurable f â†’\n        âˆ€ (x : (i : Î´) â†’ Ï€ i),\n          (âˆ«â‹¯âˆ«â»_Finset.image e s, f âˆ˜ fun x => (fun {x_1} => x) âˆ˜' e âˆ‚Î¼) x =\n            (âˆ«â‹¯âˆ«â»_s, f âˆ‚(fun {x} => Î¼) âˆ˜' e) ((fun {x_1} => x) âˆ˜' e)",
    "name": "MeasureTheory.lmarginal_image",
    "isProp": true,
    "depth": 27}],
  "kind": "Function.Â«term_âˆ˜'_Â»",
  "examples": [],
  "count": 1}]