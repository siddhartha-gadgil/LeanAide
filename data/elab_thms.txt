{Î± : Type u} [pseudo_metric_space Î±] (x y z : Î±) : has_nndist.nndist x z â‰¤ has_nndist.nndist x y + has_nndist.nndist y z
{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b : Î±} : a - b < 0 â†” a < b
{Î± : Type u} {a b : Î±} [mul_one_class Î±] [has_zero Î±] [preorder Î±] [zero_lt.pos_mul_mono Î±] (ha : a â‰¤ 1) (hb : b â‰¤ 1) (a0 : 0 < a) : a * b â‰¤ 1
{R : Type u_1} [add_monoid R] (a : add_units R) : is_add_regular â†‘a
{G : Type u_1} [add_group G] [fintype G] (p : â„•) [hp : fact (nat.prime p)] (hdvd : p âˆ£ fintype.card G) : âˆƒ (x : G), add_order_of x = p
{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b c : Î±} : a - c < b â†’ a < b + c
{R : Type u_1} {Î¹ : Type u_4} [linear_ordered_field R] [fintype Î¹] {f : Î¹ â†’ R} (hf : f âˆˆ std_simplex R Î¹) (x : Î¹) : f x âˆˆ set.Icc 0 1
(Î“â‚€ : Type u_1) [linear_ordered_comm_group_with_zero Î“â‚€] : directed ge (Î» (Î³â‚€ : Î“â‚€Ë£), filter.principal {Î³ : Î“â‚€ | Î³ < â†‘Î³â‚€})
(p : â„•) [fact (nat.prime p)] (a : â„¤) : zmod.legendre_sym p a = 0 â†” â†‘a = 0
{Î± : Type u} [pseudo_metric_space Î±] {s t : set Î±} : 0 â‰¤ metric.Hausdorff_dist s t
{R : Type u_1} {a : R} [cancel_monoid_with_zero R] [nontrivial R] : is_regular a â†” a â‰  0
{r p : nnreal} : â†‘(r - p) = â†‘r - â†‘p
{G : Type u_1} [group G] (H : â„• â†’ subgroup G) (hH : is_descending_central_series H) (n : â„•) : lower_central_series G n â‰¤ H n
{Î± : Type u_1} [measurable_space Î±] {f : â„• â†’ Î± â†’ ennreal} {g : Î± â†’ ennreal} (hf : âˆ€ (i : â„•), measurable (f i)) (lim : filter.tendsto f filter.at_top (nhds g)) : measurable g
(R : Type u_1) [comm_ring R] [local_ring R] (q : â„•) [char_R_q : char_p R q] : q = 0 âˆ¨ is_prime_pow q
{R : Type u_1} {a : R} [monoid R] (n : â„•) (rla : is_left_regular a) : is_left_regular (a ^ n)
 : real.cos (real.pi / 6) ^ 2 = 3 / 4
{R : Type u_1} {a : R} [monoid R] {n : â„•} (n0 : 0 < n) : is_right_regular (a ^ n) â†” is_right_regular a
{Î± : Sort u_1} {Î² : Sort u_2} {Î³ : Sort u_3} {f : Î± â†’ Î² â†’ Î³} (hf : function.injective2 f) (b : Î²) : function.injective (Î» (a : Î±), f a b)
{Î± : Type u_1} (f : Î± â†’ Î±) (x : Î±) : function.is_periodic_pt f 0 x
{Î± : Type u_1} [preorder Î±] [order_top Î±] {a : Î±} : is_coatom a â†’ is_atom (â‡‘order_dual.to_dual a)
{Î± : Type u_1} {Î² : Type u_2} [nontrivial Î±] {f : Î± â†’ Î²} (hf : function.injective f) (y : Î²) : âˆƒ (x : Î±), f x â‰  y
{M : Type u_1} [add_monoid M] (x : M) : is_add_submonoid (multiples x)
{Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] {f : Î± â†’ Î²} (open_map : is_open_map f) (cont : continuous f) (surj : function.surjective f) : quotient_map f
 : set.unbounded has_lt.lt {b : ordinal | b.card.ord = b âˆ§ ordinal.omega â‰¤ b}
{p : â„•} (hp : nat.prime p) {R : Type u_1} [comm_ring R] [is_domain R] {n : â„•} (hn : n â‰  0) (h : irreducible (polynomial.cyclotomic (p ^ n) R)) : irreducible (polynomial.cyclotomic p R)
{M : Type u_3} {N : Type u_4} [has_zero M] [has_zero N] {f g : zero_hom M N} (h : f = g) (x : M) : â‡‘f x = â‡‘g x
{b : â„•} {l : list â„•} (hl : âˆ€ (x : â„•), x âˆˆ l â†’ x < b + 2) : nat.of_digits (b + 2) l < (b + 2) ^ l.length
{n : â„•} (p : fin (n + 1)) (i : fin n) : p < â‡‘(p.succ_above) i â†” p â‰¤ â‡‘fin.cast_succ i
(R : Type u_1) [ring R] : algebra_map â„¤ R = int.cast_ring_hom R
{n : â„•} : n % 2 = 1 â†” n % 4 = 1 âˆ¨ n % 4 = 3
(ð•œ : Type u_1) (E : Type u_2) [is_R_or_C ð•œ] [inner_product_space ð•œ E] : galois_connection submodule.orthogonal submodule.orthogonal
{R : Type u_1} {S : Type u_2} [comm_ring R] [comm_ring S] (y : R) [algebra R S] [is_localization.away y S] [H : ideal.is_jacobson R] : ideal.is_jacobson S
{Î± : Type u_1} {Î² : Type u_2} [mul_one_class Î±] [comm_group Î²] {f : Î± â†’ Î²} (hf : is_monoid_hom f) : is_monoid_hom (Î» (a : Î±), (f a)â»Â¹)
(R : Type u) [semiring R] (q : â„•) [hp : char_p R 0] [hq : exp_char R q] : q = 1
{Î± : Type u_1} [linear_ordered_field Î±] {a b c d : Î±} (hc : c â‰  0) (hd : d â‰  0) : a / c â‰¤ b / d â†’ (a * d - b * c) / (c * d) â‰¤ 0
{C : Type u} [category_theory.category C] [category_theory.preadditive C] {J : Type v} [fintype J] (f : J â†’ C) [category_theory.limits.has_product f] : category_theory.limits.has_biproduct f
{Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± (function.swap has_mul.mul) has_lt.lt] {a : Î±} : 1 < aâ»Â¹ â†” a < 1
{Î± : Type u} [ring Î±] {a b : Î±} : a âˆ£ a + b â†” a âˆ£ b
{p : Prop} (a : erased p) : p
{G : Type u_1} [div_inv_monoid G] (a b : G) : a / b = a * bâ»Â¹
(x : â„¤) : â†‘(x.nat_abs) ^ 2 = x ^ 2
 : real.sin (real.pi / 6) = 1 / 2
{Î± : Type u} {Î² : Type v} (f : Î± â†’ Î²) (g : Î² â†’ Î±) : set.maps_to f (function.fixed_points (g âˆ˜ f)) (function.fixed_points (f âˆ˜ g))
(C : Type u) [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_finite_biproducts C] : category_theory.limits.has_binary_biproducts C
{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b c : Î±} : b < -a + c â†’ a + b < c
{Î± : Type u_1} [normed_division_ring Î±] {a : Î±} (ha : a â‰  0) : filter.tendsto (has_mul.mul a) (filter.comap has_norm.norm filter.at_top) (filter.comap has_norm.norm filter.at_top)
{Î± : Type u_1} [has_mul Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {b c : Î±} (bc : b < c) (a : Î±) : a * b < a * c
{Î± : Type u} [preorder Î±] (a : Î±) : a â‰¤ a
{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a b : Î±} (ha : a < 1) (hb : b < 1) : a * b < 1
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] (X : C) : category_theory.simple X â†” is_simple_order (category_theory.subobject X)
{Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} : monotone (set.image f)
 : filter.tendsto (Î» (x : â„), real.exp (-x)) filter.at_top (nhds 0)
{Î± : Type u} [preorder Î±] {x y : Î±} (h : x = y) : y â‰¤ x
{ð•œ : Type u_1} {E : Type u_3} [normed_field ð•œ] [add_comm_group E] [module ð•œ E] {A : set E} (hA : balanced ð•œ A) : absorbs ð•œ A A
{Î± : Sort u_1} {Î² : Sort u_2} {f : Î± â†’ Î²} (hf : function.bijective f) (b : Î²) : âˆƒ! (a : Î±), f a = b
{Î± : Type u} [preorder Î±] {a b : Î±} : a = b â†’ a â‰¤ b
{x y z : â„¤} (h : pythagorean_triple x y z) (k : â„¤) : pythagorean_triple (k * x) (k * y) (k * z)
{Î± : Type u_1} {Î¹ : Sort u_3} [conditionally_complete_lattice Î±] {f : Î¹ â†’ Î±} (H : bdd_above (set.range f)) (c : Î¹) : f c â‰¤ supr f
{Î± : Type u_1} [partial_order Î±] [succ_order Î±] {a : Î±} : is_max a â†’ order.succ a = a
{F : Type u_3} [field F] [fintype F] (hF : ring_char F â‰  2) {a : F} (ha : a â‰  0) : is_square a â†” a ^ (fintype.card F / 2) = 1
(p n : â„•) : witt_polynomial p (zmod (p ^ (n + 1))) (n + 1) = â‡‘(mv_polynomial.expand p) (witt_polynomial p (zmod (p ^ (n + 1))) n)
{F : Type u_1} [field F] [fintype F] [decidable_eq F] (hF : ring_char F â‰  2) : char.quadratic_char F (-1) = â‡‘zmod.Ï‡â‚„ â†‘(fintype.card F)
{C : Type u} [category_theory.category C] [category_theory.abelian C] {P : C} (a : category_theory.over P) : â†‘a = 0 â†” a.hom = 0
{a b c : Prop} : a âˆ§ (b âˆ¨ c) â†” a âˆ§ b âˆ¨ a âˆ§ c
{Î± : Type u_1} {P : Î± â†’ Prop} : antitone (Î» (s : set Î±), âˆ€ (x : Î±), x âˆˆ s â†’ P x)
{Î± : Type u} [preorder Î±] {a b c : Î±} : b < c â†’ a < b â†’ a < c
{a b c : Prop} : (a âˆ¨ b) âˆ§ c â†” a âˆ§ c âˆ¨ b âˆ§ c
{G : Type u_1} {s : set G} [group G] : is_normal_subgroup (group.normal_closure s)
{ð•œ : Type u_1} [nondiscrete_normed_field ð•œ] {E : Type u_2} [normed_group E] [normed_space ð•œ E] {n : with_top â„•} : cont_diff ð•œ n id
{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b c : Î±} : a < b + c â†’ a - c < b
{Î± : Type u} [preorder Î±] {a b c : Î±} : a â‰¤ b â†’ b â‰¤ c â†’ a â‰¤ c
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [topological_space Î±] [topological_space Î²] [topological_space Î³] [locally_compact_space (Î± Ã— Î²)] : continuous continuous_map.curry
{Î± : Type u} {a b : Î±} [mul_zero_one_class Î±] [partial_order Î±] [zero_lt.mul_pos_mono Î±] (ha : a â‰¤ 1) (hb : b â‰¤ 1) (b0 : 0 < b) : a * b â‰¤ 1
{Î± : Type u} [preorder Î±] {s t : set Î±} (h : bdd_above t) : bdd_above (s âˆ© t)
{Î± : Type u} [topological_space Î±] {s : set Î±} (H : is_preconnected s) : is_preconnected (closure s)
{F : Type u} [field F] {n : â„•} : (polynomial.X ^ n - 1).separable â†” â†‘n â‰  0
{Î± : Type u} [partial_order Î±] {a b : Î±} : a â‰¤ b â†’ b â‰¤ a â†’ a = b
{Î± : Type u} : dense_embedding has_pure.pure
{k : Type u_1} [division_ring k] {Î¹ : Type u_4} (s : finset Î¹) (h : â†‘(s.card) â‰  0) : s.sum (Î» (i : Î¹), finset.centroid_weights k s i) = 1
{Î± : Type u} [preorder Î±] {a b : Î±} (h : a < b) : Â¬b â‰¤ a
{M : Type u_1} [add_monoid M] (u : add_units M) (a : M) : is_add_unit (â†‘u + a) â†” is_add_unit a
{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b : Î±} (ha : a < 0) (hb : b â‰¤ 0) : a + b < 0
{R : Type u_1} {a b : R} [comm_semigroup R] : is_regular (a * b) â†” is_regular a âˆ§ is_regular b
{Î± : Type u_1} {p : Prop} {q : Î± â†’ Prop} : p â†’ âˆ€ (x : Î±), q x â†” âˆ€ (x : Î±), p â†’ q x
{Î± : Type u} [topological_space Î±] [linear_order Î±] [order_topology Î±] [densely_ordered Î±] {a b : Î±} (hab : a â‰  b) : closure (set.Ico a b) = set.Icc a b
{Î± : Type u} [topological_space Î±] {s : set Î±} : is_closed (frontier s)
{Î± : Sort u_1} (P : Prop) [decidable P] (a b : Î±) : dite P (Î» (h : P), a) (Î» (h : Â¬P), b) = ite P a b
{Î± : Type u} {f g : Î± â†’ Î±} (h : function.commute f g) : set.bij_on f (function.fixed_points (f âˆ˜ g)) (function.fixed_points (f âˆ˜ g))
{Î± : Type u} {Î² : Type v} [preorder Î²] {f : Î± â†’ Î²} {l : filter Î±} {a : Î±} : is_max_filter (â‡‘order_dual.to_dual âˆ˜ f) l a â†’ is_min_filter f l a
{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a b : Î±} (ha : a < 1) (hb : b < 1) : a * b < 1
{M : Type u_1} [monoid M] (c : con M) (n : â„•) {w x : M} : â‡‘c w x â†’ â‡‘c (w ^ n) (x ^ n)
{Î± : Type u_1} {M : Type u_5} [has_zero M] {b : M} (h : b â‰  0) : function.injective (Î» (a : Î±), finsupp.single a b)
{R : Type u_2} {Î“â‚€ : Type u_3} [ring R] [linear_ordered_comm_monoid_with_zero Î“â‚€] {vâ‚ vâ‚‚ : valuation R Î“â‚€} : vâ‚ = vâ‚‚ â†” âˆ€ (r : R), â‡‘vâ‚ r = â‡‘vâ‚‚ r
{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : a â‰¤ 0) (hb : b â‰¤ 0) : a + b â‰¤ 0
{R : Type u_1} [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {x y : M} : same_ray R (-x) (-y) â†’ same_ray R x y
{a b c : Prop} : a âˆ¨ b âˆ§ c â†” (a âˆ¨ b) âˆ§ (a âˆ¨ c)
{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a b : Î±} (ha : a < 1) (hb : b < 1) : a * b < 1
{Î± : Type u} [preorder Î±] {a b : Î±} (h : a < b) : Â¬b < a
{G : Type u} {y : G} [add_monoid G] {x : G} (h : add_commute x y) (hx : is_of_fin_add_order x) (hy : is_of_fin_add_order y) : is_of_fin_add_order (x + y)
{M : Type u} [monoid M] {x y : M} (hxy : x âˆ£ y) {n : â„•} (hn : n â‰  0) : x âˆ£ y ^ n
{Î± : Type u} [pseudo_metric_space Î±] {s : set Î±} {x y : Î±} : metric.inf_dist x s â‰¤ metric.inf_dist y s + has_dist.dist x y
{R : Type u_1} {M : Type u_3} {a b : R} [monoid R] [mul_action R M] (h : a * b = 1) : is_smul_regular M b
{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] : is_noetherian K V â†” module.finite K V
{Î± : Type u} [partial_order Î±] {a b : Î±} : a â‰¤ b â†’ a â‰  b â†’ a < b
{Mâ‚€ : Type u_1} [mul_zero_class Mâ‚€] [no_zero_divisors Mâ‚€] {a b : Mâ‚€} : a * b â‰  0 â†” b * a â‰  0
{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±} (ha : 0 â‰¤ a) (hb : 0 < b) : 0 < a + b
{Î± : Type u} [add_comm_group Î±] [has_le Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b c : Î±} : a - b â‰¤ c â†’ a â‰¤ b + c
{Î± : Type u} [pseudo_metric_space Î±] {s : set Î±} : metric.Hausdorff_dist s s = 0
{Î± : Type u_1} [linear_order Î±] {s : set Î±} : Â¬bdd_above s â†” âˆ€ (x : Î±), âˆƒ (y : Î±) (H : y âˆˆ s), x < y
{n : Type u'} {Î± : Type v} [fintype n] [decidable_eq n] [comm_ring Î±] {A B : matrix n n Î±} (h : A.mul B = 1) : Aâ»Â¹ = B
 : category_theory.ess_surj Compactum_to_CompHaus
{M : Type u_1} [mul_one_class M] {c : con M} : â†‘1 = 1
{R : Type u_1} [mul_zero_class R] (h : is_regular 0) : subsingleton R
{Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a : Î±} : aâ»Â¹ < 1 â†” 1 < a
{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a b : Î±} (ha : a < 1) (hb : b â‰¤ 1) : a * b < 1
{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} (hr : well_founded r) : well_founded (relation.cut_expand r)
{Î± : Type u} {Î² : Type v} [group Î±] [group Î²] {f : Î± â†’ Î²} (hf : is_group_hom f) : function.injective f â†” âˆ€ (a : Î±), f a = 1 â†’ a = 1
{R : Type u} [comm_ring R] [is_domain R] (a : R) (n : â„•) : polynomial.root_multiplicity a ((polynomial.X - â‡‘polynomial.C a) ^ n) = n
{Î± : Type u} [pseudo_metric_space Î±] {s : set Î±} : metric.Hausdorff_dist s âˆ… = 0
{Î± : Type u_1} [linear_ordered_field Î±] {a b : Î±} (ha : 0 < a) (hb : 0 < b) : 1 / a â‰¤ 1 / b â†” b â‰¤ a
{F : Type u_3} [field F] [fintype F] (hF : ring_char F = 2) (a : F) : is_square a
 : â‡‘measure_theory.measure_space.volume {x : â„ | liouville x} = 0
{M : Type u_1} [monoid M] {s t : set M} (ht : is_submonoid t) (h : s âŠ† t) : monoid.closure s âŠ† t
(a : â„¤) : â†‘(a.nat_abs) â‰¤ a ^ 2
{M : Type u_3} [monoid M] [preorder M] (L : list M) (h : 1 < L.prod) : 0 < L.length
{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a b : Î±} (ha : a â‰¤ 1) (hb : b < 1) : a * b < 1
{Î± : Type u} [non_unital_ring Î±] {a b c : Î±} (h : a âˆ£ b) : a âˆ£ b + c â†” a âˆ£ c
{Î± : Type u} {Î² : Type v} [mul_one_class Î±] [group Î²] {f : Î± â†’ Î²} (hf : is_mul_hom f) : is_monoid_hom f
{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b c : Î±} : a < b + c â†’ -b + a < c
(Î± : Type u) [t : topological_space Î±] [topological_space.separable_space Î±] [nonempty Î±] : dense_range (topological_space.dense_seq Î±)
{Î± : Type u} [pseudo_metric_space Î±] (s : set Î±) : lipschitz_with 1 (Î» (x : Î±), metric.inf_nndist x s)
{M : Type u_3} [monoid M] (L : list M) (h : L.prod â‰  1) : 0 < L.length
{Î± : Type u} [topological_space Î±] [t2_space Î±] [compact_space Î±] : totally_disconnected_space Î± â†” totally_separated_space Î±
{Î² : Type u_2} {f g : Î² â†’ nnreal} (hgf : âˆ€ (b : Î²), g b â‰¤ f b) : summable f â†’ summable g
{Î± : Type u_1} [partial_order Î±] (c : closure_operator Î±) (x : Î±) : x â‰¤ â‡‘c x
{Î± : Type u} {Î² : Type v} {f : Î± â†’ Î²} (h : function.injective f) (s : set Î±) : set.inj_on f s
{n : Type u_2} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] (M : matrix n n R) : M.transpose.det = M.det
{Î± : Type u_1} [linear_ordered_field Î±] {a b : Î±} (ha : 0 < a) (hb : 0 < b) : aâ»Â¹ < bâ»Â¹ â†” b < a
{Î± : Type u_1} {r s : Î± â†’ Î± â†’ Prop} (h : âˆ€ (x y : Î±), r x y â†’ s x y) : eqv_gen.setoid r â‰¤ eqv_gen.setoid s
{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_mul.mul) has_lt.lt] {a b : Î±} (ha : a < 1) (hb : b â‰¤ 1) : a * b < 1
(a b : â„•) {c : â„•} (hc : 0 < c) : c * a / (c * b) = a / b
{B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] : is_topological_fiber_bundle F prod.fst
(R : Type u_1) (M : Type u_2) [semiring R] [nontrivial M] [add_comm_monoid M] [module R M] : nontrivial R
{Î± : Type u} {Î² : Type v} {f : Î± â†’ Î²} {g : Î² â†’ Î±} (hf : function.injective f) (hg : function.injective g) : âˆƒ (h : Î± â†’ Î²), function.bijective h
{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_mul.mul) has_le.le] {a b : Î±} (ha : a â‰¤ 1) (hb : b â‰¤ 1) : a * b â‰¤ 1
{Î± : Type u} {Lâ‚ Lâ‚‚ : list (Î± Ã— bool)} : free_group.red.step Lâ‚ Lâ‚‚ â†’ Lâ‚‚.length + 2 = Lâ‚.length
{F : Type u_1} [field F] [fintype F] [decidable_eq F] {a : F} (ha : a â‰  0) : char.quadratic_char F a = 1 âˆ¨ char.quadratic_char F a = -1
{R : Type u_1} {a : R} [semigroup R] (b : R) (ha : is_left_regular a) : is_left_regular (a * b) â†” is_left_regular b
{Î± : Type u} [group Î±] [has_le Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a b c : Î±} : a * b â‰¤ c â†’ b â‰¤ aâ»Â¹ * c
(x y : â„•) : â†‘(x.gcd y) = â†‘x * x.gcd_a y + â†‘y * x.gcd_b y
{a b : ereal} (h : -a â‰¤ b) : -b â‰¤ a
{X : Type u_1} [topological_space X] [sequential_space X] {s : set X} : is_seq_closed s â†” is_closed s
{R : Type u_1} [comm_ring R] {a b : R} : a ^ 4 + 4 * b ^ 4 = ((a - b) ^ 2 + b ^ 2) * ((a + b) ^ 2 + b ^ 2)
{Î± : Type u} {a b : Î±} [mul_one_class Î±] [has_zero Î±] [preorder Î±] [zero_lt.pos_mul_strict_mono Î±] (ha : 1 â‰¤ a) (hb : 1 < b) (a0 : 0 < a) : 1 < a * b
{n n' : â„•} (m : â„•) (i : fin n') (h : n' = n) : â‡‘(fin.nat_add m) (â‡‘(fin.cast h) i) = â‡‘(fin.cast _) (â‡‘(fin.nat_add m) i)
{Î± : Type u_1} [measurable_space Î±] {f : â„• â†’ Î± â†’ nnreal} {g : Î± â†’ nnreal} (hf : âˆ€ (i : â„•), measurable (f i)) (lim : filter.tendsto f filter.at_top (nhds g)) : measurable g
{Î± : Type u} {a b : Î±} [mul_one_class Î±] [has_zero Î±] [preorder Î±] [zero_lt.pos_mul_mono Î±] (ha : 1 < a) (hb : 1 â‰¤ b) (a0 : 0 < a) : 1 < a * b
{Î± : Sort u} {Î² : Sort v} {Î³ : Sort w} {g : Î² â†’ Î³} (hg : function.surjective g) : function.surjective (function.comp g)
{Mâ‚€ : Type u_1} [mul_zero_class Mâ‚€] [no_zero_divisors Mâ‚€] {a b : Mâ‚€} : a * b â‰  0 â†” a â‰  0 âˆ§ b â‰  0
{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a b : Î±} (ha : a < 1) (hb : b < 1) : a * b < 1
{R : Type u_1} {a b : R} [semigroup R] (ab : is_left_regular (a * b)) : is_left_regular b
{Î± : Type u} {a b : Î±} [mul_one_class Î±] [has_zero Î±] [preorder Î±] [zero_lt.mul_pos_strict_mono Î±] (ha : a < 1) (hb : b < 1) (b0 : 0 < b) : a * b < 1
{Î± : Type u} [pseudo_metric_space Î±] (s : set Î±) : lipschitz_with 1 (Î» (x : Î±), metric.inf_dist x s)
{G : Type u_1} [group G] [fintype G] : monoid.is_torsion G
{Î± : Type u} [infinite Î±] : nonempty (field Î±)
{Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a : Î±} : aâ»Â¹ < 1 â†” 1 < a
{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b : Î±} (ha : 0 < a) (hb : 0 â‰¤ b) : 0 < a + b
{Î± : Type u} [preorder Î±] {a b c : Î±} : b < c â†’ a = b â†’ a < c
{Î± : Type u} {f : Î± â†’ Î±} {x : Î±} (hf : function.is_fixed_pt f x) : f x = x
 : golden_ratioâ»Â¹ = -golden_conj
{Gâ‚€ : Type u_2} [group_with_zero Gâ‚€] (a : Gâ‚€) : a * a / a = a
{Î± : Type u_1} [monoid Î±] {p q : Î±} (hp : irreducible p) (hq : irreducible q) : p âˆ£ q â†’ q âˆ£ p
{Î± : Type u} [group Î±] [fintype Î±] {p : â„•} [hp : fact (nat.prime p)] (h : fintype.card Î± = p) : is_cyclic Î±
{Mâ‚€ : Type u_1} [cancel_monoid_with_zero Mâ‚€] {a b : Mâ‚€} (hâ‚ : b â‰  1) (hâ‚‚ : a * b = a) : a = 0
{ð•œ : Type u_1} {E : Type u_2} [ordered_ring ð•œ] [add_comm_group E] [module ð•œ E] (Q : affine_subspace ð•œ E) : convex ð•œ â†‘Q
{a b c : â„•} (h : a % c = b % c) : (a - b) % c = 0
{n : â„•} {Î± : Type u_1} {v w : vector Î± n} (h : âˆ€ (m : fin n), v.nth m = w.nth m) : v = w
{R : Type u} [field R] [star_ring R] (x y : R) : has_star.star (x / y) = has_star.star x / has_star.star y
(k : Type u_1) [division_ring k] {Î¹ : Type u_4} (s : finset Î¹) : finset.centroid_weights_indicator k s = â†‘s.indicator (finset.centroid_weights k s)
{Î± : Type u} {p : Î± â†’ Prop} {a : Î±} (h : a âˆˆ {x : Î± | p x}) : p a
{n : â„•} {Î± : fin (n + 1) â†’ Type u} (q : Î  (i : fin (n + 1)), Î± i) (z : Î± 0) : fin.tail (function.update q 0 z) = fin.tail q
{Î± : Type u_1} [decidable_eq Î±] : monotone finset.shadow
(R : Type u_1) (A : Type u_2) [comm_semiring R] : pi.const_ring_hom A R = algebra_map R (A â†’ R)
(n : â„•) : â†‘(n.totient) = â†‘n * n.factors.to_finset.prod (Î» (p : â„•), 1 - (â†‘p)â»Â¹)
{Î± : Type u} [preorder Î±] [no_max_order Î±] (a : Î±) : âˆƒ (f : â„• â†’ Î±), strict_mono f âˆ§ f 0 = a
(z : upper_half_plane) : filter.tendsto (Î» (p : fin 2 â†’ â„¤), â‡‘complex.norm_sq (â†‘(p 0) * â†‘z + â†‘(p 1))) filter.cofinite filter.at_top
{Î± : Type u} [partial_order Î±] {a b : Î±} (hab : a â‰¤ b) (hba : Â¬a < b) : a = b
{Î± : Type u} {Î² : Type v} {s : set Î±} {f : Î± â†’ Î²} : set.inj_on f s â†’ function.injective (s.restrict f)
{Î± : Type u_1} {f g : poly Î±} : (âˆ€ (x : Î± â†’ â„•), â‡‘f x = â‡‘g x) â†’ f = g
{m n : â„•} : m âˆ£ m + n â†” m âˆ£ n
{R : Type u_1} {a b : R} [monoid R] (h : b * a = 1) : is_left_regular a
(p : â„•) [fact (nat.prime p)] : â†‘((p - 1).factorial) = -1
{Î± : Type u} {Î² : Type v} [preorder Î²] {f : Î± â†’ Î²} {s : set Î±} {a : Î±} : is_min_on (â‡‘order_dual.to_dual âˆ˜ f) s a â†’ is_max_on f s a
{Î± : Type u_1} [normed_division_ring Î±] {a : Î±} (ha : a â‰  0) : filter.tendsto (Î» (x : Î±), x * a) (filter.comap has_norm.norm filter.at_top) (filter.comap has_norm.norm filter.at_top)
{R : Type u_1} {a : R} [monoid R] (ua : is_unit a) : is_regular a
{X : Type u_2} {Y : Type u_3} [topological_space X] [topological_space Y] [topological_space.pseudo_metrizable_space Y] {f : X â†’ Y} (hf : inducing f) : topological_space.pseudo_metrizable_space X
{R : Type u_1} [comm_ring R] {a b : quaternion R} (h : commute a b) : commute (â‡‘quaternion.conj a) (â‡‘quaternion.conj b)
{G : Type u_1} [group G] [hN : nontrivial G] : monoid.is_torsion G â†’ Â¬monoid.is_torsion_free G
{Î± : Type u_1} : sym2.map (Î» (x : Î±), x) = id
{R : Type u_1} [mul_zero_class R] : is_left_regular 0 â†” subsingleton R
{Î± : Type u_1} [linear_order Î±] {r s : Î±} : {r}.to_colex â‰¤ {s}.to_colex â†” r â‰¤ s
{Î± : Type u} {Î² : Type v} [add_group Î±] [add_group Î²] {f : Î± â†’ Î²} (hf : is_add_group_hom f) (a : Î±) : f (-a) = -f a
{Î± : Type u_1} (o : part Î±) : {dom := o.dom, get := Î» (h : o.dom), o.get h} = o
{Î± : Type u_1} [preorder Î±] [add_comm_semigroup Î±] [has_sub Î±] [has_ordered_sub Î±] {a b : Î±} : a + b - a â‰¤ b
{Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a : Î±} : 1 < aâ»Â¹ â†” a < 1
 : ring_hom.localization_preserves ring_hom.finite
{Î± : Type u} {Lâ‚ Lâ‚‚ : list (Î± Ã— bool)} [decidable_eq Î±] (H : free_group.red Lâ‚ Lâ‚‚) : free_group.red Lâ‚‚ (free_group.reduce Lâ‚)
{Î± : Type u_1} [has_add Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {b c : Î±} (bc : b < c) (a : Î±) : a + b < a + c
{X : Type u_2} {Y : Type u_3} [emetric_space X] [emetric_space Y] {K : nnreal} {f : X â†’ Y} (h : lipschitz_with K f) : dimH (set.range f) â‰¤ dimH set.univ
{Î± : Type u_1} [add_semigroup Î±] (x y : Î±) : ((Î» (_x : Î±), _x + x) âˆ˜ Î» (_x : Î±), _x + y) = Î» (_x : Î±), _x + (y + x)
{B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] : is_trivial_topological_fiber_bundle F prod.fst
(K : Type u_1) (L : Type u_2) [field K] [field L] [algebra K L] [finite_dimensional K L] : algebra.is_integral K L
(k : Type u_1) {V1 : Type u_2} {P1 : Type u_3} [ring k] [add_comm_group V1] [module k V1] [add_torsor V1 P1] (p : P1) : â‡‘(affine_map.id k P1) p = p
{Î± : Sort u_1} {Î² : Sort u_2} {Î³ : Sort u_3} {f : Î± â†’ Î² â†’ Î³} (hf : function.injective2 f) [nonempty Î±] : function.injective (Î» (b : Î²) (a : Î±), f a b)
(R : Type u) [comm_ring R] : galois_connection (Î» (s : set R), prime_spectrum.zero_locus s) (Î» (t : (set (prime_spectrum R))áµ’áµˆ), â†‘(prime_spectrum.vanishing_ideal t))
{Î± : Type u} (r : Î± â†’ Î± â†’ Prop) [is_antisymm Î± r] {a b : Î±} : r a b â†’ r b a â†’ b = a
{f : â„• â†’ nnreal} {r : nnreal} : has_sum f r â†” filter.tendsto (Î» (n : â„•), (finset.range n).sum (Î» (i : â„•), f i)) filter.at_top (nhds r)
{Î± : Type u} [comm_semiring Î±] {p p' : Î±} {ps ps' : â„•} : p = p' â†’ ps = ps' â†’ p ^ ps = p' ^ ps'
(p : â„•) [fact (nat.prime p)] (hp : p â‰  2) (a : â„¤) : â†‘({x : zmod p | x ^ 2 = â†‘a}.to_finset.card) = zmod.legendre_sym p a + 1
{Î± : Type u} [preorder Î±] {a : Î±} : a â‰¤ a
(P L : Type u) [has_mem P L] [configuration.has_points P L] [fintype P] [fintype L] : fintype.card L â‰¤ fintype.card P
{R : Type u_1} {a : R} [monoid R] {n 