{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b : Î±} : a - b < 0 â†” a < b
{R : Type u_1} [add_monoid R] (a : add_units R) : is_add_regular â†‘a
{G : Type u_1} [add_group G] [fintype G] (p : â„•) [hp : fact (nat.prime p)] (hdvd : p âˆ£ fintype.card G) : âˆƒ (x : G), add_order_of x = p
{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b c : Î±} : a - c < b â†’ a < b + c
{Î± : Type u} {Î² : Type v} {Î³ : Type u_1} [topological_space Î±] [topological_space Î²] [topological_space Î³] {f : Î± â†’ Î³} (hf : continuous f) : continuous (Î» (x : Î± Ã— Î²), f x.fst)
{r p : nnreal} : â†‘(r - p) = â†‘r - â†‘p
{G : Type u_1} [group G] (H : â„• â†’ subgroup G) (hH : is_descending_central_series H) (n : â„•) : lower_central_series G n â‰¤ H n
{Î± : Type u} [preorder Î±] {f : â„¤ â†’ Î±} (hf : antitone f) (n : â„¤) {x : Î±} (h1 : f (n + 1) < x) (h2 : x < f n) (a : â„¤) : f a â‰  x
{G : Type u_1} [group G] (H : subgroup G) {x : G} : x âˆˆ H â†’ xâ»Â¹ âˆˆ H
 : real.cos (real.pi / 6) ^ 2 = 3 / 4
{Î± : Sort u_1} {Î² : Sort u_2} {Î³ : Sort u_3} {f : Î± â†’ Î² â†’ Î³} (hf : function.injective2 f) (b : Î²) : function.injective (Î» (a : Î±), f a b)
{Î± : Type u_1} (f : Î± â†’ Î±) (x : Î±) : function.is_periodic_pt f 0 x
{Î± : Type u_1} {Î² : Type u_2} [nontrivial Î±] {f : Î± â†’ Î²} (hf : function.injective f) (y : Î²) : âˆƒ (x : Î±), f x â‰  y
{M : Type u_1} [add_monoid M] (x : M) : is_add_submonoid (multiples x)
{Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] {f : Î± â†’ Î²} (open_map : is_open_map f) (cont : continuous f) (surj : function.surjective f) : quotient_map f
 : set.unbounded has_lt.lt {b : ordinal | b.card.ord = b âˆ§ ordinal.omega â‰¤ b}
{b : â„•} {l : list â„•} (hl : âˆ€ (x : â„•), x âˆˆ l â†’ x < b + 2) : nat.of_digits (b + 2) l < (b + 2) ^ l.length
{n : â„•} : n % 2 = 1 â†” n % 4 = 1 âˆ¨ n % 4 = 3
{M : Type u_1} [has_add M] {s : set M} : s âŠ† â†‘(add_subsemigroup.closure s)
{Î± : Type u_1} {Î² : Type u_2} [mul_one_class Î±] [comm_group Î²] {f : Î± â†’ Î²} (hf : is_monoid_hom f) : is_monoid_hom (Î» (a : Î±), (f a)â»Â¹)
{C : Type u} [category_theory.category C] [category_theory.preadditive C] {J : Type v} [fintype J] (f : J â†’ C) [category_theory.limits.has_product f] : category_theory.limits.has_biproduct f
{Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± (function.swap has_mul.mul) has_lt.lt] {a : Î±} : 1 < aâ»Â¹ â†” a < 1
{Î± : Type u} [ring Î±] {a b : Î±} : a âˆ£ a + b â†” a âˆ£ b
{p : Prop} (a : erased p) : p
{G : Type u_1} [div_inv_monoid G] (a b : G) : a / b = a * bâ»Â¹
(x : â„¤) : â†‘(x.nat_abs) ^ 2 = x ^ 2
 : real.sin (real.pi / 6) = 1 / 2
{Î± : Type u} {Î² : Type v} (f : Î± â†’ Î²) (g : Î² â†’ Î±) : set.maps_to f (function.fixed_points (g âˆ˜ f)) (function.fixed_points (f âˆ˜ g))
(C : Type u) [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_finite_biproducts C] : category_theory.limits.has_binary_biproducts C
{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b c : Î±} : b < -a + c â†’ a + b < c
{Î± : Type u} [preorder Î±] (a : Î±) : a â‰¤ a
 : filter.tendsto (Î» (x : â„), real.exp (-x)) filter.at_top (nhds 0)
{Î± : Type u} [preorder Î±] {x y : Î±} (h : x = y) : y â‰¤ x
{Î± : Type u} [preorder Î±] {a b : Î±} : a = b â†’ a â‰¤ b
{x y z : â„¤} (h : pythagorean_triple x y z) (k : â„¤) : pythagorean_triple (k * x) (k * y) (k * z)
{Î± : Type u_1} [partial_order Î±] [succ_order Î±] {a : Î±} : is_max a â†’ order.succ a = a
{C : Type u} [category_theory.category C] [category_theory.abelian C] {P : C} (a : category_theory.over P) : â†‘a = 0 â†” a.hom = 0
{a b c : Prop} : a âˆ§ (b âˆ¨ c) â†” a âˆ§ b âˆ¨ a âˆ§ c
{Î± : Type u_1} {P : Î± â†’ Prop} : antitone (Î» (s : set Î±), âˆ€ (x : Î±), x âˆˆ s â†’ P x)
{Î± : Type u} [preorder Î±] {a b c : Î±} : b < c â†’ a < b â†’ a < c
{M : Type u_1} [mul_one_class M] (S : submonoid M) : submonoid.closure â†‘S = S
{a b c : Prop} : (a âˆ¨ b){Î± : Type u} [preorder Î±] {a b : Î±} (h : a < b) : Â¬b < a
{G : Type u} {y : G} [add_monoid G] {x : G} (h : add_commute x y) (hx : is_of_fin_add_order x) (hy : is_of_fin_add_order y) : is_of_fin_add_order (x + y)
{M : Type u_1} [has_add M] {S T : add_subsemigroup M} (h : âˆ€ (x : M), x âˆˆ S â†” x âˆˆ T) : S = T
{Î± : Type u} [partial_order Î±] {a b : Î±} : a â‰¤ b â†’ a â‰  b â†’ a < b
{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±} (ha : 0 â‰¤ a) (hb : 0 < b) : 0 < a + b
{Î± : Type u} [add_comm_group Î±] [has_le Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b c : Î±} : a - b â‰¤ c â†’ a â‰¤ b + c
{Î± : Type u_1} [linear_order Î±] {s : set Î±} : Â¬bdd_above s â†” âˆ€ (x : Î±), âˆƒ (y : Î±) (H : y âˆˆ s), x < y
{n : Type u'} {Î± : Type v} [fintype n] [decidable_eq n] [comm_ring Î±] {A B : matrix n n Î±} (h : A.mul B = 1) : Aâ»Â¹ = B
 : category_theory.ess_surj Compactum_to_CompHaus
{G : Type u_1} [add_group G] (H : add_subgroup G) {x y : G} : x âˆˆ H â†’ y âˆˆ H â†’ x + y âˆˆ H
{M : Type u_1} [mul_one_class M] {c : con M} : â†‘1 = 1
{R : Type u_1} [mul_zero_class R] (h : is_regular 0) : subsingleton R
{Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a : Î±} : aâ»Â¹ < 1 â†” 1 < a
 : multiset.nat.antidiagonal 0 = {(0, 0)}
{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} (hr : well_founded r) : well_founded (relation.cut_expand r)
{Î± : Type u} {Î² : Type v} [group Î±] [group Î²] {f : Î± â†’ Î²} (hf : is_group_hom f) : function.injective f â†” âˆ€ (a : Î±), f a = 1 â†’ a = 1
(a : â„¤) : â†‘(a.nat_abs) â‰¤ a ^ 2
{M : Type u_3} [monoid M] [preorder M] (L : list M) (h : 1 < L.prod) : 0 < L.length
{Î± : Type u} {Î² : Type v} [mul_one_class Î±] [group Î²] {f : Î± â†’ Î²} (hf : is_mul_hom f) : is_monoid_hom f
{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b c : Î±} : a < b + c â†’ -b + a < c
(Î± : Type u) [t : topological_space Î±] [topological_space.separable_space Î±] [nonempty Î±] : dense_range (topological_space.dense_seq Î±)
{M : Type u_3} [monoid M] (L : list M) (h : L.prod â‰  1) : 0 < L.length
{Î± : Type u_1} {ð’œ : finset (finset Î±)} {Aâ‚ Aâ‚‚ : finset Î±} {râ‚ râ‚‚ : â„•} (hâ‚ : Aâ‚ âˆˆ ð’œ.slice râ‚) (hâ‚‚ : Aâ‚‚ âˆˆ ð’œ.slice râ‚‚) : râ‚ â‰  râ‚‚ â†’ Aâ‚ â‰  Aâ‚‚
{G : Type u_1} [group G] (K : subgroup G) : subgroup.closure â†‘K = K
{Î² : Type u_2} {f g : Î² â†’ nnreal} (hgf : âˆ€ (b : Î²), g b â‰¤ f b) : summable f â†’ summable g
{Î± : Type u} {Î² : Type v} {f : Î± â†’ Î²} (h : function.injective f) (s : set Î±) : set.inj_on f s
{n : Type u_2} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] (M : matrix n n R) : M.transpose.det = M.det
{Î± : Type u_1} {r s : Î± â†’ Î± â†’ Prop} (h : âˆ€ (x y : Î±), r x y â†’ s x y) : eqv_gen.setoid r â‰¤ eqv_gen.setoid s
{B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] : is_topological_fiber_bundle F prod.fst
(R : Type u_1) (M : Type u_2) [semiring R] [nontrivial M] [add_comm_monoid M] [module R M] : nontrivial R
{M : Type u_1} [has_mul M] {s : set M} {S : subsemigroup M} : subsemigroup.closure s â‰¤ S â†” s âŠ† â†‘S
{Î± : Type u} {Lâ‚ Lâ‚‚ : list (Î± Ã— bool)} : free_group.red.step Lâ‚ Lâ‚‚ â†’ Lâ‚‚.length + 2 = Lâ‚.length
{R : Type u_1} {a : R} [semigroup R] (b : R) (ha : is_left_regular a) : is_left_regular (a * b) â†” is_left_regular b
(x y : â„•) : â†‘(x.gcd y) = â†‘x * x.gcd_a y + â†‘y * x.gcd_b y
{Î± : Sort u} {Î² : Sort v} {Î³ : Sort w} {g : Î² â†’ Î³} (hg : function.surjective g) : function.surjective (function.comp g)
{R : Type u_1} {a b : R} [semigroup R] (ab : is_left_regular (a * b)) : is_left_regular b
(n a : â„•) : finset.image (Î» (_x : â„•), _x % a) (finset.Ico n (n + a)) = finset.range a
{Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a : Î±} : aâ»Â¹ < 1 â†” 1 < a
{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b : Î±} (ha : 0 < a) (hb : 0 â‰¤ b) : 0 < a + b
{Î± : Ty{Î± : Type u} [comm_semiring Î±] {p p' : Î±} {ps ps' : â„•} : p = p' â†’ ps = ps' â†’ p ^ ps = p' ^ ps'
{Î± : Type u} [preorder Î±] {a : Î±} : a â‰¤ a
{G : Type u_1} [add_group G] (K : add_subgroup G) : add_subgroup.closure â†‘K = K
{Î± : Type u} [add_comm_group Î±] [has_le Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b c : Î±} : a â‰¤ b + c â†’ a - b â‰¤ c
{R : Type u_1} [mul_zero_class R] [nR : nontrivial R] : Â¬is_right_regular 0
{Î± : Type u} {Î² : Type v} [group Î±] [group Î²] {f : Î± â†’ Î²} (hf : is_group_hom f) (a : Î±) : f aâ»Â¹ = (f a)â»Â¹
{f : ordinal â†’ ordinal} (H : ordinal.is_normal f) : set.unbounded has_lt.lt (function.fixed_points f)
{H : Type u_1} [topological_space H] {x : H} : charted_space.chart_at H x = local_homeomorph.refl H
{R : Type u_1} {a b : R} [add_monoid R] (h : b + a = 0) : is_add_left_regular a
{Î± : Type u} [preorder Î±] {s : set Î±} {a : Î±} (h : is_least s a) : bdd_below s
{G : Type u_2} [add_group G] {a b : G} : a = b â†’ a - b = 0
{Î± : Type u} [preorder Î±] {a b c : Î±} : b â‰¤ c â†’ a < b â†’ a < c
(C : Type u) [category_theory.category C] [category_theory.limits.has_terminal C] [category_theory.limits.has_pullbacks C] : category_theory.limits.has_binary_products C
{Î± : Type u} [preorder Î±] {s t : set Î±} (h : bdd_above s) : bdd_above (s âˆ© t)
{Î± : Type u_1} [uniform_space Î±] (x : Î±) : nhds (x, x) â‰¤ uniformity Î±
{p : â„•} : padic_val_int p 1 = 0
(R : Type u_1) [ring R] : polynomial.cyclotomic 2 R = polynomial.X + 1
{Î± : Type u_1} [partial_order Î±] [pred_order Î±] {a : Î±} : is_min a â†’ order.pred a = a
{Î± : Type u} {Lâ‚ Lâ‚‚ : list (Î± Ã— bool)} [decidable_eq Î±] (H : free_group.mk Lâ‚ = free_group.mk Lâ‚‚) : free_group.reduce Lâ‚ = free_group.reduce Lâ‚‚
{G : Type u_1} [add_group G] [topological_space G] [topological_add_group G] {H : add_subgroup G} (h_1_int : 0 âˆˆ interior â†‘H) : is_open â†‘H
{R : Type u} [comm_group R] [star_semigroup R] (x y : R) : has_star.star (x / y) = has_star.star x / has_star.star y
{R : Type u_1} {M : Type u_3} [monoid_with_zero R] [has_zero M] [mul_action_with_zero R M] [sM : subsingleton M] : is_smul_regular M 0
{B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] : is_trivial_topological_fiber_bundle F prod.snd
{M : Type u_1} [monoid M] {x : M} : 1 âˆˆ powers x
{Î± : Type u} [preorder Î±] {a b c : Î±} : b â‰¤ c â†’ a â‰¤ b â†’ a â‰¤ c
{Î± : Type u} {Î² : Î± â†’ Type u} {Îº : cardinal} (hÎº : cardinal.sum (Î» (a : Î±), Îº ^ cardinal.mk (Î² a)) â‰¤ Îº) : cardinal.mk (W_type Î²) â‰¤ Îº
{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_initial C] : category_theory.limits.has_zero_object C
(n : â„•) : âˆƒ (p : â„•), n â‰¤ p âˆ§ nat.prime p
{S : Type u_1} [has_add S] (a : S) : add_commute a a
{M : Type u_1} [monoid M] {Î³ : Type u_2} [monoid Î³] {f : M â†’ Î³} (hf : is_monoid_hom f) : is_submonoid (set.range f)
{Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b c : Î±} : b â‰¤ -a + c â†’ a + b â‰¤ c
{R : Type u_1} {M : Type u_3} [monoid_with_zero R] [has_zero M] [mul_action_with_zero R M] [nM : nontrivial M] : Â¬is_smul_regular M 0
{Î± : Type u} [has_subset Î±] {a b : Î±} [is_antisymm Î± has_subset.subset] (h : a âŠ† b) (h' : b âŠ† a) : a = b
{J : Type uâ‚} [category_theory.category J] [nonempty J] (h : âˆ€ (jâ‚ jâ‚‚ : J), category_theory.zigzag jâ‚ jâ‚‚) : category_theory.is_connected J
{P : â„¤ â†’ Prop} {m : â„¤} (h0 : P m) (h1 : âˆ€ (n : â„¤), n â‰¤ m â†’ P n â†’ P (n - 1)) (n : â„¤) : n â‰¤ m â†’ P n
{Î± : Type u} {Î² : Type v} [add_group Î±] [add_group Î²] {f : Î± â†’ Î²} (hf : âˆ€ (x y : Î±), f (x + y) = f x + f y) : is_add_group_hom f
{R : Type u_1} (M : Type u_3) {a : R} [monoid R] [mul_action R M] (ua : is_unit a) : is_smul_regular M a
{Î± : Type u_1} {Î² : Type u_2} (f : Î± â†’ Î²) : function.injective (quotient.lift f _)
{Î± : Type u_1} {Î² : Type u_2} [uniform_space Î±] (f : Î² â†’ Î±) (l : filter Î²) : filter.tendsto (Î» (x : Î²), (f x, f x)) l (uniformity Î±)
{Î± : Type u_1} [decidable_eq Î±] : âˆ….shadow = âˆ…
{M : Type u_3} [monoid M] [preorder M] (L : list M) (h : L.prod < 1) : 0 < L.length
{Î± : Type u_1} [topological_space Î±] {s t : set Î±} (hs : is_GÎ´ s) (ht : is_GÎ´ t) : is_GÎ´ (s âˆª t)
 : Â¬summable (Î» (n : â„•), 1 / â†‘n)
{Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± has_add.add has_le.le] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±} : a â‰¤ -b â†’ b â‰¤ -a
{Î± : Type u} [partial_order Î±] {a b : Î±} (h : a â‰¤ b) : b = a âˆ¨ a < b
{S : set â„•} (hb : 0 âˆˆ S) (h_ind : âˆ€ (k : â„•), k âˆˆ S â†’ k + 1 âˆˆ S) (n : â„•) : n âˆˆ S
{Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± has_add.add has_le.le] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±} : -a â‰¤ -b â†’ b â‰¤ a
{Î± : Type u_1} [topological_space Î±] {U : set Î±} {hU : is_open U} : â†‘âŸ¨U, hUâŸ© = U
{n : â„•} (a : fin (n + 1)) : â†‘(a.val) = a
{Î¹ : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core Î¹ B F) : is_open_map Z.proj
{G : Type u} [group G] {x : G} (hx : is_of_fin_order x) : is_of_fin_order xâ»Â¹
{Î± : Type u} [linear_order Î±] {x y : Î±} : x < y âˆ¨ y < x â†” x â‰  y
(n : â„•) : âˆƒ (a b c d : â„•), a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n
{Î± : Type u_1} {Î² : Type u_2} [uniform_space Î±] [uniform_space Î²] [compact_space Î±] [separated_space Î±] {f : Î± â†’ Î²} (h : continuous f) : uniform_continuous f
{Î± : Type u_2} {Î² : Type u_3} {f : Î± â†’ Î²} (hf : function.injective f) : filter.tendsto f filter.cofinite filter.cofinite
{Î± : Type u} {f g : Î± â†’ Î±} (h : function.commute f g) : set.inv_on f g (function.fixed_points (f âˆ˜ g)) (function.fixed_points (f âˆ˜ g))
{B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z â†’ B} [topological_space Z] (h : is_topological_fiber_bundle F proj) : continuous proj
(C : Type u) [category_theory.category C] [category_theory.limits.has_initial C] [category_theory.limits.has_pushouts C] : category_theory.limits.has_binary_coproducts C
{R : Type u_1} [comm_ring R] (g : matrix.special_linear_group (fin 2) R) : is_coprime (â†‘g 1 0) (â†‘g 1 1)
(Î± : Type u) [preorder Î±] [nonempty Î±] [no_min_order Î±] [no_max_order Î±] : âˆƒ (f : â„¤ â†’ Î±), strict_anti f
{R : Type u} [non_assoc_semiring R] (s : set R) : â†‘(subsemiring.closure s) = â†‘(add_submonoid.closure â†‘(submonoid.closure s))
{b m d : â„•} (hb : 2 â‰¤ b) (hd : d âˆˆ b.digits m) : d < b
{C : Type u} [category_theory.category C] [category_theory.limits.has_binary_products C] [category_theory.limits.has_pullbacks C] : category_theory.limits.has_equalizers C
{Î± : Type u_1} [preorder Î±] [succ_order Î±] {a b : Î±} [no_max_order Î±] : a < b â†’ order.succ a < order.succ b
{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a b : Î±} (ha : 1 < a) (hb : 1 < b) : 1 < a * b
{p : â„•} : summable (Î» (n : â„•), (â†‘n ^ p)â»Â¹) â†” 1 < p
{Î± : Type u_1} [add_semigroup Î±] (x y : Î±) : has_add.add x âˆ˜ has_add.add y = has_add.add (x + y)
{b : â„•} {S : set â„•} (hb : b âˆˆ S) (h_ind : âˆ€ (k : â„•), k âˆˆ S â†’ k + 1 âˆˆ S) {n : â„•} (hbn : b â‰¤ n) : n âˆˆ S
{n : â„•} : 0 < n â†’ 0 < szemeredi_regularity.step_bound n
{M : Type u_1} [add_monoid M] {x : M} : x âˆˆ multiples x
 : filter.tendsto complex.exp (filter.comap complex.re filter.at_top) (filter.comap complex.abs filter.at_top)
{Î± : Type u_1} {Î² : Type u_2} {r : Î± â†’ Î± â†’ Prop} {s : Î² â†’ Î² â†’ Prop} : function.injective coe_fn
{C : Type u} [category_theory.category C] [category_theory.limits.has_finite_coproducts C] [category_theory.limits.has_coequalizers C] : category_theory.limits.has_finite_colimits C
{G : Type u} {x : G} [add_monoid G] : 0 < add_order_of x â†” is_of_fin_add_order x
{Î± : Type u_1} {Î² : Type u_2} [add_comm_monoid Î±] [topological_space Î±] : has_sum (Î» (b : Î²), 0) 0
{Î“ : Type u_1} [inhabited Î“] (l : turing.list_blank Î“) : âˆƒ (a : Î“) (l' : turing.list_blank Î“), l = turing.list_blank.cons a l'
{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} (h : reflexive r) {x y : Î±} : x â‰  y â†’ r x y â†” r x y
(G : Type u_1) [group G] : is_ascending_central_series (upper_central_series G)
{p : â„•} [fact (nat.prime p)] : p % 2 = 1 â†” p â‰  2
{Î± : Type u} {Î² : Type v} {Î³ : Type w} (g : Î² â†’ Î³) (f : Î± â†’ Î²) : list.map g âˆ˜ list.map f = list.map (g âˆ˜ f)
{R : Type u_1} [mul_zero_class R] : Â¬is_right_regular 0 â†” nontrivial R
{Î± : Type u_1} [is_empty Î±] (s : finset Î±) : s = âˆ…
{Î± : Type u} [preorder Î±] {s : set Î±} {a : Î±} (h : is_lub s a) : bdd_above s
{Î± : Sort u_1} {Î² : Sort u_2} {Î³ : Sort u_3} {f : Î± â†’ Î² â†’ Î³} (hf : function.injective2 f) [nonempty Î²] : function.injective f
{Î± : Type u_1} [linear_order Î±] [topological_space Î±] [compact_Icc_space Î±] {a b : Î±} : is_compact (set.interval a b)
{o : ordinal} : ordinal.principal has_add.add o â†” o = 0 âˆ¨ âˆƒ (a : ordinal), o = ordinal.omega ^ a
{Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] [covariant_class Î± Î± (function.swap has_mul.mul) has_lt.lt] {a b : Î±} : aâ»Â¹ < b â†’ bâ»Â¹ < a
{M : Type u} [monoid M] (a : M) : a ^ 2 = a * a
{M : Type u_1} [has_mul M] (S : subsemigroup M) : subsemigroup.closure â†‘S = S
{R : Type u_1} [comm_ring R] [fintype R] (p : â„•) [fact (nat.prime p)] (hp : p âˆ£ fintype.card R) : Â¬is_unit â†‘p
{Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± has_add.add has_le.le] {a : Î±} : -a â‰¤ 0 â†” 0 â‰¤ a
{n p k : â„•} (hn : n â‰  0) (h : n.factorization = finsupp.single p k) : n = p ^ k
{Î± : Type u_1} [preorder Î±] [locally_finite_order Î±] {a b : Î±} : Â¬a â‰¤ b â†’ finset.Icc a b = âˆ…
 : well_founded nat.lt
{M : Type u_3} [add_monoid M] (L : list M) (h : L.sum â‰  0) : 0 < L.length
{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a b : Î±} (ha : 1 < a) (hb : 1 < b) : 1 < a * b
{Î± : Type u_1} {s t : set Î±} : s = t â†’ s âŠ† t
{Î± : Type u_1} [decidable_eq Î±] (s : multiset Î±) : s - 0 = s
{n : Type u'} {Î± : Type v} [fintype n] [decidable_eq n] [comm_ring Î±] (A : matrix n n Î±) : Aâ»Â¹ = ring.inverse A
{Mâ‚€ : Type u_1} [monoid_with_zero Mâ‚€] (x : Mâ‚€) (h : Â¬is_unit x) : ring.inverse x = 0
{ð•œ : Type u_1} {E : Type u_2} {Î¹ : Type u_3} [ordered_semiring ð•œ] [add_comm_group E] [module ð•œ E] [subsingleton Î¹] (p : Î¹ â†’ E) : convex_independent ð•œ p
{Î± : Type u_2} [monoid Î±] (m : Î±) : (âˆƒ (c : Î±), m = c ^ 2) â†’ is_square m
{C : Type u} [category_theory.category C] [category_theory.preadditive C] {J : Type v} [fintype J] (f : J â†’ C) [category_theory.limits.has_coproduct f] : category_theory.limits.has_biproduct f
 : golden_conjâ»Â¹ = -golden_ratio
{Î± : Type u} [preorder Î±] [no_min_order Î±] (a : Î±) : âˆƒ (f : â„• â†’ Î±), strict_anti f âˆ§ f 0 = a
{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a : Î±} : 0 < -a â†” a < 0
{C : Type uâ‚} [category_theory.category C] {A : C} (hA : category_theory.is_subterminal A) {T : C} (hT : category_theory.limits.is_terminal T) : category_theory.mono (hT.from A)
{M : Type u_1} [monoid M] (s : submonoid M) {l : list M} (hl : âˆ€ (x : M), x âˆˆ l â†’ x âˆˆ s) : l.prod âˆˆ s
{H : Type u} [topological_space H] (G : structure_groupoid H) : closed_under_restriction G â†” id_restr_groupoid â‰¤ G
{R : Type u_1} {a b : R} [add_semigroup R] (ab : is_add_right_regular (b + a)) : is_add_right_regular b
{Î¹ : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core Î¹ B F) (b : B) : continuous (bundle.total_space_mk b)
(Î± : Type u) [preorder Î±] [nonempty Î±] [no_min_order Î±] [no_max_order Î±] : âˆƒ (f : â„¤ â†’ Î±), strict_mono f
{Î± : Sort u_1} {Î² : Sort u_2} (f : Î± â†’ Î²) : nonempty Î± â†’ nonempty Î²
{b : â„•} {l : list â„•} (hb : 2 â‰¤ b) (hl : âˆ€ (x : â„•), x âˆˆ l â†’ x < b) : nat.of_digits b l < b ^ l.length
{G : Type u} [add_group G] (a x : G) : add_semiconj_by a x (a + x + -a)
{Î± : Type u_1} {Î² : Type u_2} {r : Î± â†’ Î± â†’ Prop} {s : Î² â†’ Î² â†’ Prop} : function.injective coe_fn
{p : nat_ordinal â†’ Prop} (i : nat_ordinal) (h : âˆ€ (j : nat_ordinal), (âˆ€ (k : nat_ordinal), k < j â†’ p k) â†’ p j) : p i
{Î± : Type u_1} [semigroup Î±] (x y : Î±) : ((Î» (_x : Î±), _x * x) âˆ˜ Î» (_x : Î±), _x * y) = Î» (_x : Î±), _x * (y * x)
 : primrec (Î» (a : (â„• Ã— nat.partrec.code) Ã— â„•), nat.partrec.code.evaln a.fst.fst a.fst.snd a.snd)
{n : Type u} [decidable_eq n] [fintype n] {R : Type v} [linear_ordered_comm_ring R] (g : matrix.special_linear_group n R) : â†‘â†‘â†‘g = â†‘g
{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±} (ha : 0 < a) (hb : 0 < b) : 0 < a + b
{Î± : Type u_1} {R : Î± â†’ Î± â†’ Prop} [decidable_rel R] {l : list Î±} : list.pairwise R l â†’ list.pw_filter R l = l
{Î± : Type u} {Î² : Type v} {Î³ : Type w} (h : Î² â†’ Î³) (g : Î± â†’ Î²) (l : list Î±) : list.map (h âˆ˜ g) l = list.map h (list.map g l)
{ð’œ : Type u_1} [category_theory.category ð’œ] [category_theory.preadditive ð’œ] [category_theory.limits.has_kernels ð’œ] [category_theory.limits.has_images ð’œ] [category_theory.limits.has_binary_biproducts ð’œ] (A B : ð’œ) : category_theory.exact category_theory.limits.biprod.inl category_theory.limits.biprod.snd
{Î± : Type u_1} [decidable_eq Î±] [fintype Î±] : monotone finset.up_shadow
{Î± : Type u_1} [semigroup_with_zero Î±] {a : Î±} : 0 âˆ£ a â†” a = 0
{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b c : Î±} : -b + a < c â†’ a < b + c
{Î± : Type u_1} [circular_preorder Î±] {a b c : Î±} (h : has_sbtw.sbtw a b c) : Â¬has_btw.btw c b a
{Î± : Type u_1} [has_add Î±] [has_le Î±] [contravariant_class Î± Î± has_add.add has_le.le] {a b c : Î±} (bc : a + b â‰¤ a + c) : b â‰¤ c
{Î± : Type u} {L : list (Î± Ã— bool)} [decidable_eq Î±] : free_group.mk (free_group.reduce L) = free_group.mk L
{p : â„•} : padic_val_nat p 1 = 0
{Î± : Sort u_1} {p : Î± â†’ Prop} (x : subtype p) : p â†‘x
{Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] (s : set Î±) : continuous (Î» (F : C(Î±, Î²)), continuous_map.restrict s F)
{m : Type u_2} {n : Type u_3} {Î± : Type v} (M : matrix m n Î±) (i : m) (j : n) : M.transpose j i = M i j
{G : Type w} [topological_space G] [has_neg G] [has_add G] [has_continuous_add G] (g : G) : continuous (Î» (h : G), g + h + -g)
{Î± : Type u_1} {M : Type u_5} [comm_monoid M] (s : set Î±) : finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), 1)) = 1
{M : Type u_1} [add_monoid M] {x : M} : 0 âˆˆ multiples x
{Î± : Type u_1} [semigroup Î±] (x y : Î±) : has_mul.mul x âˆ˜ has_mul.mul y = has_mul.mul (x * y)
{Gâ‚€ : Type u_2} [group_with_zero Gâ‚€] (a : Gâ‚€) : a / (a / a) = a
{Î± : Type u_1} {o p : part Î±} (H : âˆ€ (a : Î±), a âˆˆ o â†” a âˆˆ p) : o = p
{Î± : Type u_1} {Î² : Type u_2} {r : Î± â†’ Î± â†’ Prop} {s : Î² â†’ Î² â†’ Prop} : function.injective coe_fn
{Î± : Type u} [has_add Î±] : is_add_hom id
(R : Type u) [semiring R] [nontrivial R] [no_zero_divisors R] {p : â„•} [hp : char_p R p] (p_ne_zero : p â‰  0) : nat.prime p
{Î± : Type u_1} [semigroup Î±] {a b c : Î±} : a âˆ£ b â†’ b âˆ£ c â†’ a âˆ£ c
{Î± : Type uu} (r : Î± â†’ Î± â†’ Prop) [decidable_rel r] [is_total Î± r] [is_trans Î± r] (l : list Î±) : list.sorted r (list.insertion_sort r l)
{Î± : Type u} {Î² : Type v} (f : Î± â†’ Î²) (g : Î² â†’ Î±) : set.inv_on f g (function.fixed_points (f âˆ˜ g)) (function.fixed_points (g âˆ˜ f))
{a b c : â„¤} (h : a % b = c) : b âˆ£ a - c
{c c' : Î£ (n : â„•), composition n} : c = c' â†” c.snd.blocks = c'.snd.blocks
{Î± : Type u_1} [semiring Î±] {m n : â„•} (h : m âˆ£ n) : â†‘m âˆ£ â†‘n
{M : Type u_1} [add_zero_class M] (S : add_submonoid M) {x y : M} : x âˆˆ S â†’ y âˆˆ S â†’ x + y âˆˆ S
{G : Type u} [add_group G] {x : G} (hx : is_of_fin_add_order x) : is_of_fin_add_order (-x)
{M : Type u_1} [comm_monoid M] (S : submonoid M) (m : multiset M) (hm : âˆ€ (a : M), a âˆˆ m â†’ a âˆˆ S) : m.prod âˆˆ S
(R : Type u_1) [comm_ring R] [fintype R] (p : â„•) [fact (nat.prime p)] : is_unit â†‘p â†” Â¬p âˆ£ ring_char R
{Î± : Type u} [topological_space Î±] {s : set Î±} : dense (closure s) â†’ dense s
{X : Type u_1} [topological_space X] {Î± : Type u_2} {Î² : Type u_3} (f : X â†’ Î±) (g : Î± â†’ Î²) (h : is_locally_constant (g âˆ˜ f)) (inj : function.injective g) : is_locally_constant f
{a b c : â„¤} (habc : a âˆ£ b * c) (hab : a.gcd b = 1) : a âˆ£ c
 : real.sin (real.pi / 3) ^ 2 = 3 / 4
 : is_cyclic (quaternion_group 1)
{S : Type u_1} [semigroup S] {a b c : S} (hac : commute a c) (hbc : commute b c) : commute (a * b) c
{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : 0 < a) (hb : 0 â‰¤ b) : 0 < a + b
 : real.cos (real.pi / 6) = real.sqrt 3 / 2
{Î± : Sort u_1} (r : Î± â†’ Î± â†’ Prop) : function.surjective (quot.mk r)
{Î³ : Type u_1} [non_unital_non_assoc_semiring Î³] (x : Î³) : is_add_monoid_hom (Î» (y : Î³), x * y)
{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b : Î±} (ha : a â‰¤ 0) (hb : b < 0) : a + b < 0
{Î± : Type u} [topological_space Î±] {s : set Î±} : is_clopen s â†’ frontier s = âˆ…
{R : Type uâ‚} {L : Type uâ‚‚} [comm_ring R] [lie_ring L] [lie_algebra R L] [is_noetherian R L] : lie_algebra.is_engelian R L
{R : Type v} [comm_ring R] (A : matrix (fin 1) (fin 1) R) : A.det = A 0 0
{M : Type u_4} [topological_space M] [add_monoid M] [has_continuous_add M] {U : set M} (hU : U âˆˆ nhds 0) : âˆƒ (V : set M), is_open V âˆ§ 0 âˆˆ V âˆ§ V + V âŠ† U
 : strict_mono real.sinh
{Î± : Type u} {L : list (Î± Ã— bool)} [decidable_eq Î±] : free_group.red L (free_group.reduce L)
{n : â„•} (a : fin (n + 1)) : â†‘â†‘a = a
{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} (h : reflexive r) {x y : Î±} (hr : x â‰  y â†’ r x y) : r x y
{R : Type u_1} (M : Type u_3) [has_zero R] [has_zero M] [smul_with_zero R M] (r : R) : r â€¢ 0 = 0
{G : Type u_1} [group G] (H : subgroup G) {x y : G} (hx : x âˆˆ H) (hy : y âˆˆ H) : x / y âˆˆ H
 : irrational golden_ratio
{Î± : Type u} [preorder Î±] {a b c : Î±} (hab : a = b) (hbc : b < c) : a < c
(L : list â„•) (h : âˆ€ (i : â„•), i âˆˆ L â†’ 1 â‰¤ i) : L.length â‰¤ L.sum
{Î± : Type u} [group Î±] [has_le Î±] [covariant_class Î± Î± has_mul.mul has_le.le] [covariant_class Î± Î± (function.swap has_mul.mul) has_le.le] {a b : Î±} : a â‰¤ bâ»Â¹ â†’ b â‰¤ aâ»Â¹
{Î± : Type u_1} {Î² : Type u_2} [add_group Î±] [add_comm_group Î²] {f : Î± â†’ Î²} (hf : is_add_group_hom f) : is_add_group_hom (Î» (a : Î±), -f a)
{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a b : Î±} (ha : 1 â‰¤ a) (hb : 1 â‰¤ b) : 1 â‰¤ a * b
{Î± : Type u_1} [circular_preorder Î±] {a b c : Î±} (h : has_btw.btw a b c) : Â¬has_sbtw.sbtw c b a
{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : 0 < a) (hb : 0 < b) : 0 < a + b
(C : Type u) [category_theory.category C] [category_theory.limits.has_finite_colimits C] : category_theory.limits.has_finite_wide_pushouts C
{M : Type u_1} [has_add M] (S : add_subsemigroup M) {x y : M} : x âˆˆ S â†’ y âˆˆ S â†’ x + y âˆˆ S
(b : â„¤) : b â‰¤ b ^ 2
{C : Type u} [category_theory.category C] [category_theory.limits.coproducts_disjoint C] : category_theory.limits.initial_mono_class C
{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_cokernels C] : category_theory.limits.has_coequalizers C
{Î³ : Type w} [preorder Î³] [order_top Î³] (s : set Î³) : bdd_above s
{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a b : Î±} (ha : 1 â‰¤ a) (hb : 1 â‰¤ b) : 1 â‰¤ a * b
{G : Type u_1} [group G] {H K : subgroup G} (h : âˆ€ (x : G), x âˆˆ H â†” x âˆˆ K) : H = K
{Î± : Type u} [preorder Î±] {a b : Î±} (h : a < b) : a â‰  b
{Î¹ : Type u} (f : Î¹ â†’ cardinal) : bdd_above (set.range f)
{S : Type u} [has_add S] {a x y : S} (h : add_semiconj_by a x y) : a + x = y + a
{a : â„•} : real.sqrt â†‘a â‰¤ â†‘(nat.sqrt a) + 1
{Î“ : Type u_4} [group Î“] {T : Type u_5} [topological_space T] [mul_action Î“ T] [has_continuous_const_smul Î“ T] : is_open_map quotient.mk
{x y z : â„¤} (k : â„¤) (hk : k â‰  0) : pythagorean_triple (k * x) (k * y) (k * z) â†” pythagorean_triple x y z
{n a : â„•} (h : a < n + 1) : â†‘a.val = a
 : cardinal.ord âˆ˜ cardinal.aleph = ordinal.enum_ord {b : ordinal | b.card.ord = b âˆ§ ordinal.omega â‰¤ b}
{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_finite_coproducts C] : category_theory.limits.has_finite_biproducts C
{Î± : Type u_1} (f : Î± â†’ nnreal) : filter.tendsto (Î» (s : finset Î±), âˆ‘' (b : {x // x âˆ‰ s}), f â†‘b) filter.at_top (nhds 0)
{n : â„•} (a : zmod n) : â†‘â†‘a = a
{R : Type u_1} {a : R} [mul_zero_class R] [nontrivial R] (la : is_regular a) : a â‰  0
{G : Type w} [topological_space G] [has_neg G] [has_add G] [has_continuous_add G] [has_continuous_neg G] (h : G) : continuous (Î» (g : G), g + h + -g)
{Î± : Type u} {Î² : Type v} [topological_space Î±] [topological_space Î²] : is_open_map prod.fst
{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_kernels C] : category_theory.limits.has_equalizers C
{R : Type u_1} [cancel_monoid R] (g : R) : is_regular g
{Î± : Type u_1} {Î² : Type u_2} [add_zero_class Î±] [add_comm_group Î²] {f : Î± â†’ Î²} (hf : is_add_monoid_hom f) : is_add_monoid_hom (Î» (a : Î±), -f a)
{Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] {i : Î± â†’ Î²} (di : dense_inducing i) [topological_space.separable_space Î±] : topological_space.separable_space Î²
{Î± : Sort u} {Î² : Î± â†’ Sort v} {fâ‚ fâ‚‚ : Î  (x : Î±), Î² x} (h : âˆ€ (x : Î±), fâ‚ x = fâ‚‚ x) : fâ‚ = fâ‚‚
(p : â„•) (a : â„¤) [hp : fact (nat.prime p)] : â†‘(zmod.legendre_sym p a) = â†‘a ^ (p / 2)
{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_mul.mul) has_lt.lt] {a b : Î±} (ha : 1 < a) (hb : 1 â‰¤ b) : 1 < a * b
{Î± : Type u} [add_group Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a : Î±} (h : 0 â‰¤ a) : -a â‰¤ a
{p : â„•} : padic_val_nat p 0 = 0
{G : Type u_1} [group G] {k : set G} : k âŠ† â†‘(subgroup.closure k)
{ð’œ : Type u_1} [category_theory.category ð’œ] [category_theory.preadditive ð’œ] [category_theory.limits.has_kernels ð’œ] [category_theory.limits.has_images ð’œ] [category_theory.limits.has_binary_biproducts ð’œ] (A B : ð’œ) : category_theory.exact category_theory.limits.biprod.inr category_theory.limits.biprod.fst
{Î± : Type u} [has_subset Î±] {a b : Î±} [is_refl Î± has_subset.subset] : a = b â†’ a âŠ† b
(R : Type u_1) (M : Type u_2) [semiring R] [subsingleton R] [add_comm_monoid M] [module R M] : subsingleton M
{Î± : Type u} [preorder Î±] {a b : Î±} (h : a < b) : Â¬b < a
(n : â„•) (R : Type u_1) [ring R] [nontrivial R] : polynomial.cyclotomic n R â‰  0
{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a : Î±} : -a < 0 â†” 0 < a
{R : Type u_1} {a b : R} [add_semigroup R] (ab : is_add_left_regular (a + b)) : is_add_left_regular b
(Î± : Type u) [preorder Î±] [nonempty Î±] [no_min_order Î±] : âˆƒ (f : â„• â†’ Î±), strict_anti f
{Î± : Type u} {Lâ‚ Lâ‚‚ Lâ‚ƒ : list (Î± Ã— bool)} : free_group.red Lâ‚ Lâ‚‚ â†’ free_group.red Lâ‚ Lâ‚ƒ â†’ relation.join free_group.red Lâ‚‚ Lâ‚ƒ
{R : Type u_1} {a b : R} [semigroup R] (lra : is_left_regular a) (lrb : is_left_regular b) : is_left_regular (a * b)
(k : Type u_1) (V : Type u_2) (P : Type u_3) [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] : â†‘âŠ¤ = set.univ
{R : Type u_1} [left_cancel_semigroup R] (g : R) : is_left_regular g
{B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z â†’ B} [topological_space Z] (h : is_topological_fiber_bundle F proj) : is_open_map proj
{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_binary_products C] : category_theory.limits.has_binary_biproducts C
{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : a < 0) (hb : b < 0) : a + b < 0
{H : Type u_1} [topological_space H] {e : local_homeomorph H H} : e âˆˆ charted_space.atlas H H â†” e = local_homeomorph.refl H
(C : Type u) [category_theory.category C] [category_theory.limits.has_finite_limits C] : category_theory.limits.has_finite_wide_pullbacks C
{n : â„•} {x : â„• Ã— â„•} : x âˆˆ finset.nat.antidiagonal n â†” x.fst + x.snd = n
{R : Type u_1} [mul_zero_class R] : is_regular 0 â†” subsingleton R
(C : Type u) [category_theory.category C] [category_theory.limits.has_products C] : category_theory.limits.has_finite_products C
{Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space.separable_space Î±] [topological_space Î²] {f : Î± â†’ Î²} (h : dense_range f) (h' : continuous f) : topological_space.separable_space Î²
{G : Type w} [topological_space G] [has_neg G] [has_add G] [has_continuous_add G] [has_continuous_neg G] : continuous (Î» (g : G Ã— G), g.fst + g.snd + -g.fst)
{Î± : Sort u_1} {Î² : Sort u_2} (f : Î± â†’ Î²) (P : Prop) [decidable P] (a b : Î±) : f (ite P a b) = ite P (f a) (f b)
{p : â„•} (hp : 1 < p) : padic_norm p â†‘p = 1 / â†‘p
{S : Type u_1} [has_add S] {a b : S} (h : add_commute a b) : add_commute b a
{Î± : Type u} : dense_range has_pure.pure
{k : â„•} {A : finset â„•} (hâ‚ : âˆ€ {x : â„•}, x âˆˆ A â†’ x < k) : A.sum (has_pow.pow 2) < 2 ^ k
{Î± : Type u_1} [circular_preorder Î±] {a b c : Î±} (h : has_sbtw.sbtw a b c) : Â¬has_sbtw.sbtw c b a
(n : â„•) : n.factorization = 0 â†” n = 0 âˆ¨ n = 1
{Î± : Type u_1} [partial_order Î±] [succ_order Î±] {a b : Î±} [no_max_order Î±] : a â‰  b â†’ order.succ a â‰  order.succ b
{Î± : Type u_1} [preorder Î±] [add_comm_semigroup Î±] [has_sub Î±] [has_ordered_sub Î±] {a b : Î±} : b - (b - a) â‰¤ a
{Î± : Type u_1} {Î² : Type u_2} {p : Î± â†’ Î² â†’ Prop} {xâ‚€ xâ‚ : Î£ (a : Î±), subtype (p a)} : xâ‚€.fst = xâ‚.fst â†’ â†‘(xâ‚€.snd) = â†‘(xâ‚.snd) â†’ xâ‚€ = xâ‚
{Î± : Type u_1} [bornology Î±] {p : Î± â†’ Prop} : bornology.is_bounded {x : Î± | p x} â†’ bounded_space (subtype p)
{Mâ‚€ : Type u_1} [mul_zero_one_class Mâ‚€] : 0 â‰  1 âˆ¨ âˆ€ (a : Mâ‚€), a = 0
{Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] {e : Î± â†’ Î²} (de : dense_embedding e) [topological_space.separable_space Î±] : topological_space.separable_space Î²
(S : Type u_1) [ring S] (a : â„•) : â†‘(a.desc_factorial 2) = â†‘a * (â†‘a - 1)
{Î± : Type u_1} [circular_preorder Î±] {a b c d : Î±} (hbc : has_sbtw.sbtw a b c) (hcd : has_sbtw.sbtw a c d) : has_sbtw.sbtw a b d
{Î± : Type u_1} (n : â„•) (x : Î±) : function.is_periodic_pt id n x
{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b : Î±} (ha : a < 0) (hb : b < 0) : a + b < 0
{M : Type u_1} [add_comm_monoid M] (S : add_submonoid M) (m : multiset M) (hm : âˆ€ (a : M), a âˆˆ m â†’ a âˆˆ S) : m.sum âˆˆ S
 : irrational golden_conj
(Î¹ : Type u_3) : well_founded has_lt.lt
{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} [is_refl Î± r] [is_antisymm Î± r] {a b : Î±} : antisymm_rel r a b â†’ a = b
{n : â„•} {a b : fin n} : â†‘a â‰¤ â†‘b â†” a â‰¤ b
{Î± : Type u_1} [preorder Î±] [pred_order Î±] {a b : Î±} [no_min_order Î±] : a < b â†’ order.pred a < order.pred b
{G : Type u} [add_monoid G] : is_of_fin_add_order 0
{R : Type u_1} {a b : R} [add_semigroup R] (lra : is_add_left_regular a) (lrb : is_add_left_regular b) : is_add_left_regular (a + b)
{p : ordinal â†’ Prop} (i : ordinal) (h : âˆ€ (j : ordinal), (âˆ€ (k : ordinal), k < j â†’ p k) â†’ p j) : p i
 : function.injective real.sinh
{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a : Î±} : 0 < -a â†” a < 0
(Î± : Sort u_1) [s : setoid Î±] : function.surjective quotient.mk
{S : Type u_1} [has_mul S] (a : S) : commute a a
{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a : Î±} : -a < 0 â†” 0 < a
{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : a < 0) (hb : b â‰¤ 0) : a + b < 0
{Î± : Type u} [group Î±] [has_lt Î±] [covariant_c(f : â„• â†’ nnreal) : filter.tendsto (Î» (i : â„•), âˆ‘' (k : â„•), f (k + i)) filter.at_top (nhds 0)
{R : Type u_1} [add_left_cancel_semigroup R] (g : R) : is_add_left_regular g
{Î± : Type u} [linear_order Î±] {a b c : Î±} : set.interval a c âŠ† set.interval a b âˆª set.interval b c
{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b : Î±} (ha : a < 0) (hb : b < 0) : a + b < 0
{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a : Î±} : 0 < -a â†’ a < 0
{B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] : is_topological_fiber_bundle F prod.snd
 : filter.tendsto (Î» (x : â„), x ^ (1 / x)) filter.at_top (nhds 1)
{C : Type u} [category_theory.category C] [category_theory.limits.has_binary_products C] [category_theory.limits.has_terminal C] : category_theory.limits.has_finite_products C
{Î± : Type u} [preorder Î±] {a b : Î±} : a â‰¤ b â†’ Â¬b â‰¤ a â†’ a < b
{Î¹ : Type u_1} {Î± : Type u_3} [preorder Î¹] [linear_order Î±] {u : Î¹ â†’ Î±} (h : monotone u) (H : Â¬bdd_below (set.range u)) : filter.tendsto u filter.at_bot filter.at_bot
{Î± : Type u_1} [circular_preorder Î±] {a b c : Î±} (h : has_btw.btw a b c) : has_btw.btw c a b
{Î± : Type u_1} {a b c : Î±} [linear_order Î±] [add_comm_semigroup Î±] [has_sub Î±] [has_ordered_sub Î±] (h : a - c < b - c) : a < b
 : filter.tendsto real.log filter.at_top filter.at_top
{Î± : Type u_1} {p : Î± â†’ Prop} (s : finset {x // p x}) {a : Î±} (h : Â¬p a) : a âˆ‰ finset.map (function.embedding.subtype (Î» (x : Î±), p x)) s
{p : â„•} [p_prime : fact (nat.prime p)] {b : â„•} (dvd : p âˆ£ b) : padic_val_nat p (b / p) = padic_val_nat p b - 1
{Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} {c : Î±} [semiring Î±] [add_group Î²] (h : function.antiperiodic f c) : function.periodic f (2 * c)
{Î± : Type u_1} : subsingleton (option Î±) â†” is_empty Î±
{Î¹ : Type u_1} (f g : Î¹ â†’ cardinal) (H : âˆ€ (i : Î¹), f i < g i) : cardinal.sum f < cardinal.prod g
{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : 0 < a) (hb : 0 < b) : 0 < a + b
{R : Type u_1} [rack R] {x y z : R} : shelf.act x (shelf.act y z) = shelf.act (shelf.act x y) z â†” shelf.act x z = z
{a : Prop} : Â¬Â¬a â†” a
(Î± : Type u) [t : topological_space Î±] [topological_space.separable_space Î±] [nonempty Î±] : âˆƒ (u : â„• â†’ Î±), dense_range u
{G : Type u} [group G] {x : G} : is_of_fin_order xâ»Â¹ â†” is_of_fin_order x
{Î± : Type u_1} {M : Type u_5} [has_zero M] (a : Î±) : function.injective (finsupp.single a)
{Î± : Type u} [preorder Î±] {s : set Î±} : Â¬bdd_above s â†” âˆ€ (x : Î±), âˆƒ (y : Î±) (H : y âˆˆ s), Â¬y â‰¤ x
{x y z : â„¤} : pythagorean_triple x y z â†” pythagorean_triple y x z
{P : â„• â†’ Prop} {m : â„•} (h0 : P m) (h1 : âˆ€ (n : â„•), m â‰¤ n â†’ P n â†’ P (n + 1)) (n : â„•) : m â‰¤ n â†’ P n
{G : Type u} [add_group G] {x : G} : is_of_fin_add_order (-x) â†” is_of_fin_add_order x
 : filter.tendsto (Î» (N : â„•), formal_multilinear_series.comp_partial_sum_target 0 N N) filter.at_top filter.at_top
{n : â„•} {a b : fin n} : â†‘a < â†‘b â†” a < b
{G : Type u_1} [group G] (K : subgroup G) {k : set G} : subgroup.closure k â‰¤ K â†” k âŠ† â†‘K
{Î³ : Type u_1} [non_unital_non_assoc_semiring Î³] (x : Î³) : is_add_monoid_hom (Î» (y : Î³), y * x)
{Î± : Type u} [partial_order Î±] {a b : Î±} : a â‰¤ b â†’ a < b âˆ¨ a = b
{Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] [locally_compact_space Î±] (a : Î±) : continuous (Î» (f : C(Î±, Î²)), â‡‘f a)
{Î± : Type u_1} [preorder Î±] [pred_order Î±] {a b : Î±} [no_min_order Î±] : order.pred a < order.pred b â†’ a < b
(M : Type u_1) (N : Type u_2) (Î± : Type u_3) [has_vadd M Î±] [has_vadd N Î±] [vadd_comm_class M N Î±] : vadd_comm_class N M Î±
{Î± : Type u_1} {p : Î± â†’ Prop} (s : finset {x // p x}) {a : Î±} (h : a âˆˆ finset.map (function.embedding.subtype (Î» (x : Î±), p x)) s) : p a
{M : Type u_1} [has_mul M] {S T : subsemigroup M} (h : âˆ€ (x : M), x âˆˆ S â†” x âˆˆ T) : S = T
{p : â„•} (z : â„¤) (hp : p â‰  1) (hz : z â‰  0) : padic_val_rat p â†‘z = â†‘((multiplicity â†‘p z).get _)
{Î± : Type u} [topological_space Î±] {s t : set Î±} (hs : dense s) (ht : dense t) (hso : is_open s) : dense (s âˆ© t)
{M : Type u} [add_zero_class M] (a : M) : add_semiconj_by a 0 0
{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±} (ha : 0 â‰¤ a) (hb : 0 â‰¤ b) : 0 â‰¤ a + b
{M : Type u_1} [mul_one_class M] (S : submonoid M) : 1 âˆˆ S
{Î± : Type u_1} [comm_semiring Î±] (t : tree Î±) (râ‚ râ‚‚ : tactic.ring2.csring_expr) (H : tactic.ring2.horner_expr.of_csexpr râ‚ = tactic.ring2.horner_expr.of_csexpr râ‚‚) : tactic.ring2.csring_expr.eval t râ‚ = tactic.ring2.csring_expr.eval t râ‚‚
{R : Type u_1} [non_assoc_semiring R] [nontrivial R] (hR : ring_char R â‰  2) : 2 â‰  0
{Î± : Type u} (f : fin 0 â†’ Î±) : list.of_fn f = list.nil
{G : Type u_1} [add_group G] {H K : add_subgroup G} (h : âˆ€ (x : G), x âˆˆ H â†” x âˆˆ K) : H = K
 : Â¬summable (Î» (n : â„•), (â†‘n)â»Â¹)
(C : Type u) [ð’ž : category_theory.category C] [category_theory.limits.has_binary_coproducts C] [category_theory.limits.has_coequalizers C] : category_theory.limits.has_pushouts C
{Î± : Type u_1} {Î² : Type u_2} [group Î±] [comm_group Î²] {f : Î± â†’ Î²} (hf : is_group_hom f) : is_group_hom (Î» (a : Î±), (f a)â»Â¹)
{R : Type u_8} [ordered_semiring R] [nontrivial R] (l : list R) (h : âˆ€ (a : R), a âˆˆ l â†’ 0 < a) : 0 < l.prod
{G : Type u_1} [group G] [topological_space G] [topological_group G] {H : subgroup G} (h_1_int : 1 âˆˆ interior â†‘H) : is_open â†‘H
{Î± : Type u} (f : Î± â†’ Type (max u v)) : Â¬function.surjective f
{Î± : Type u_1} {Î² : Type u_2} [has_mul Î±] [comm_group Î²] {f : Î± â†’ Î²} (hf : is_mul_hom f) : is_mul_hom (Î» (a : Î±), (f a)â»Â¹)
{M : Type u_1} [monoid M] (x : M) : is_submonoid (powers x)
{M : Type u} [add_zero_class M] (x : M) : add_semiconj_by 0 x x
{Î± : Type u} [preorder Î±] {s t : set Î±} (h : bdd_below t) : bdd_below (s âˆ© t)
{C : Type uâ‚} [category_theory.category C] {A : C} [category_theory.limits.has_terminal C] (hA : category_theory.is_subterminal A) : category_theory.mono (category_theory.limits.terminal.from A)
(p : â„• â†’ Prop) [decidable_pred p] (n : â„•) : nat.count p n = fintype.card {k // k < n âˆ§ p k}
{M : Type u_1} [add_monoid M] {Î³ : Type u_2} [add_monoid Î³] {f : M â†’ Î³} (hf : is_add_monoid_hom f) : is_add_submonoid (set.range f)
 : function.injective has_dvd.dvd
{X : Type u_1} [topological_space X] (s : set X) : seq_closure s âŠ† closure s
{Î± : Type u} {Î² : Type v} [setoid Î±] [topological_space Î±] {f : Î² â†’ Î±} (hf : dense_range f) : dense_range (quotient.mk âˆ˜ f)
{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b : Î±} (ha : 0 â‰¤ a) (hb : 0 < b) : 0 < a + b
{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} : is_max_chain r (max_chain r)
{p n : â„•} : padic_val_rat p â†‘n = â†‘(padic_val_nat p n)
{P : Type u_1} [preorder P] (s t : order.pfilter P) (h : â†‘s = â†‘t) : s = t
{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : 0 â‰¤ a) (hb : 0 â‰¤ b) : 0 â‰¤ a + b
{n : â„•} {x : â„• Ã— â„•} : x âˆˆ multiset.nat.antidiagonal n â†” x.fst + x.snd = n
{Î¹ : Type u} (f : Î¹ â†’ ordinal) : bdd_above (set.range f)
{Î± : Type u} (r : Î± â†’ Î± â†’ Prop) [is_partial_order Î± r] : âˆƒ (s : Î± â†’ Î± â†’ Prop) (_x : is_linear_order Î± s), r â‰¤ s
{S : Type u_1} [semigroup S] {a b c : S} (hab : commute a b) (hac : commute a c) : commute a (b * c)
{Î± : Type u_1} {M : Type u_5} [add_comm_monoid M] {f : Î± â†’ M} : finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ âˆ…), f i)) = 0
 : pythagorean_triple 0 0 0
{R : Type u} [comm_semiring R] [nontrivial R] {p : fin 2 â†’ R} (h : is_coprime (p 0) (p 1)) : p â‰  0
{Î± : Type u} [group Î±] [fintype Î±] {p : â„•} [hp : fact (nat.prime p)] (h : fintype.card Î± = p) : is_simple_group Î±
(f : bool â†’ bool) (x : bool) : f (f (f x)) = f x
{Î± : Type u} [partial_order Î±] {a b : Î±} : a â‰¤ b â†’ b â‰¤ a â†’ b = a
{R :{Î± : Type u} [group Î±] [has_le Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a : Î±} : aâ»Â¹ â‰¤ 1 â†” 1 â‰¤ a
{R : Type u_1} {a b : R} [semigroup R] (ab : is_right_regular (b * a)) : is_right_regular b
{b : â„•} (hb : 1 < b) {x y : â„•} (hy : 0 < y) : b ^ x â‰¤ y â†” x â‰¤ nat.log b y
{Î± : Type u} {a b c d : Î±} [preorder Î±] (hca : c â‰¤ a) (hbd : b â‰¤ d) : a â‰¤ b â†’ c â‰¤ d
{Î± : Type u} {Î² : Type v} [topological_space Î±] [topological_space Î²] {f : Î± â†’ Î²} (hf : continuous f) : filter.comap f (filter.cocompact Î²) â‰¤ filter.cocompact Î±
{Î± : Type u_1} [circular_preorder Î±] {a b c : Î±} (habc : has_btw.btw a b c) (hcba : Â¬has_btw.btw c b a) : has_sbtw.sbtw a b c
{Î± : Type u_1} {s : finset Î±} {p : Î± â†’ Prop} [decidable_pred p] (h : âˆ€ (x : Î±), x âˆˆ s â†’ p x) : finset.map (function.embedding.subtype p) (finset.subtype p s) = s
{Î± : Type u_2} [semiring Î±] {a : Î±} : odd a â†’ (âˆƒ (b : Î±), a = bit1 b)
(p : â„•) [p_prime : fact (nat.prime p)] {q r : â„•} (hq : q â‰  0) (hr : r â‰  0) : padic_val_nat p (q * r) = padic_val_nat p q + padic_val_nat p r
{G : Type u_1} [add_group G] (H : add_subgroup G) {x : G} : x âˆˆ H â†’ -x âˆˆ H
{C : Type uâ‚} [category_theory.category C] [category_theory.limits.has_initial C] (h : âˆ€ (X : C), category_theory.mono (category_theory.limits.initial.to X)) : category_theory.limits.initial_mono_class C
{H : Type u} [topological_space H] (G : structure_groupoid H) : local_homeomorph.refl H âˆˆ structure_groupoid.maximal_atlas H G
{Î± : Type u_1} {f : Î± â†’ Î±} {x : Î±} (hf : function.is_fixed_pt f x) (n : â„•) : function.is_periodic_pt f n x
{Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a : Î±} : aâ»Â¹ < 1 â†” 1 < a
{Î± : Type u_1} {p : Î± â†’ Prop} : set.range coe = {x : Î± | p x}
{R : Type u_1} {a b : R} [add_semigroup R] : is_add_regular (a + b) âˆ§ is_add_regular (b + a) â†” is_add_regular a âˆ§ is_add_regular b
{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b c : Î±} : -b + a < c â†’ a < b + c
{R : Type uâ‚} [comm_ring R] (a b : R) : a ^ 2 - b ^ 2 = (a + b) * (a - b)
{Î± : Type u} [partial_order Î±] {a b : Î±} (hab : a â‰¤ b) (hba : Â¬a < b) : b = a
{G : Type u_1} [add_comm_group G] (K : add_subgroup G) (g : multiset G) : (âˆ€ (a : G), a âˆˆ g â†’ a âˆˆ K) â†’ g.sum âˆˆ K
(n : â„•) : filter.tendsto (Î» (x : â„), real.exp x / x ^ n) filter.at_top filter.at_top
{M : Type u_1} [has_mul M] {c d : con M} (H : setoid.r = setoid.r) : c = d
{R : Type u_4} [linear_ordered_ring R] (a : R) : 0 â‰¤ a ^ 2
{n : â„•} (i j : Î£ (a : composition n), composition a.length) : i = j â†” i.fst.blocks = j.fst.blocks âˆ§ i.snd.blocks = j.snd.blocks
{G : Type u_1} [group G] : is_descending_central_series (lower_central_series G)
{Î± : Type u} [topological_space Î±] {s t : set Î±} (hs : is_compact s) (ht : is_open t) : is_compact (s  t)
{Î± : Type u_1} [circular_preorder Î±] {a b c : Î±} : has_sbtw.sbtw a b c â†” has_sbtw.sbtw c a b
{R : Type u_1} [comm_ring R] [char_zero R] : function.injective (Î» (n : â„•), polynomial.cyclotomic n R)
{Î± : Type u_1} [decidable_eq Î±] [fintype Î±] : âˆ….up_shadow = âˆ…
{p : â„•} : padic_val_int p 0 = 0
{M : Type u_1} [add_zero_class M] {c : add_con M} : â†‘0 = 0
{a b c : â„¤} (habc : a âˆ£ b * c) (hab : a.gcd c = 1) : a âˆ£ b
{Mâ‚€ : Type u_1} [mul_zero_one_class Mâ‚€] (h : 0 = 1) (a : Mâ‚€) : a = 0
{Î± : Type u} {Î² : Type v} {Î³ : Type u_1} [topological_space Î±] [topological_space Î²] [topological_space Î³] {f : Î² â†’ Î³} (hf : continuous f) : continuous (Î» (x : Î± Ã— Î²), f x.snd)
 : category_theory.faithful Compactum_to_CompHaus
{a b c : Prop} : a âˆ§ b âˆ¨ c â†” (a âˆ¨ c) âˆ§ (b âˆ¨ c)
{M : Type u_1} [monoid M] {x : M} : x âˆˆ powers x
{R : Type v} [comm_ring R] {A : matrix (fin 0) (fin 0) R} : A.det = 1
{M : Type u_1} [add_monoid M] (a : M) (u : add_units M) : is_add_unit (a + â†‘u) â†” is_add_unit a
(a : cardinal) : a < 2 ^ a
{Î· : Type u_1} {Gs : Î· â†’ Type u_2} [Î  (i : Î·), add_monoid (Gs i)] {x : Î  (i : Î·), Gs i} (h : is_of_fin_add_order x) (i : Î{Î± : Type u} {lâ‚ lâ‚‚ : list Î±} (i : â„•) : list.take (lâ‚.length + i) (lâ‚ ++ lâ‚‚) = lâ‚ ++ list.take i lâ‚‚
{Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b c : Î±} : a + b â‰¤ c â†’ a â‰¤ c - b
{Î± : Type u} [has_mul Î±] : is_mul_hom id
{Î² : Type u_2} [topological_space Î²] {Îº : Type u_5} {f : Îº â†’ Î²} (hf : function.surjective f) : dense_range f
{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : 0 â‰¤ a) (hb : 0 â‰¤ b) : 0 â‰¤ a + b
{Î± : Type u_1} [linear_order Î±] {r s : Î±} : {r}.to_colex < {s}.to_colex â†” r < s
{n : â„•} [fact (0 < n)] : fintype.card (dihedral_group n) = 2 * n
{Î± : Type u} [topological_space Î±] [locally_compact_space Î±] {K : set Î±} (hK : is_compact K) : âˆƒ (K' : set Î±), is_compact K' âˆ§ K âŠ† interior K'
{C : Type u} [category_theory.category C] [category_theory.limits.has_products C] [category_theory.limits.has_equalizers C] : category_theory.limits.has_limits C
(C : Type u) [category_theory.category C] [âˆ€ {X Y : C}, category_theory.limits.has_limit (category_theory.limits.pair X Y)] : category_theory.limits.has_binary_products C
{X : Type u_1} [tX : topological_space X] {s t : set X} (ts : t âŠ† s) : subtype.topological_space = topological_space.induced (set.inclusion ts) subtype.topological_space
{Î± : Type u_1} {p : Î± â†’ Prop} [decidable_pred p] {s : finset Î±} (h : âˆ€ (x : Î±), x âˆˆ s â†’ Â¬p x) : finset.filter p s = âˆ…
{a b : â„•} (w : a âˆ£ b) (h : b < a) : b = 0
{S : Type u_1} [has_add S] {a b : S} (h : add_commute a b) : a + b = b + a
{Î± : Type u_1} [circular_preorder Î±] {a b c : Î±} (h : has_sbtw.sbtw a b c) : has_sbtw.sbtw b c a
{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b : Î±} : -a < b â†’ -b < a
{Mâ‚€ : Type u_1} [mul_zero_one_class Mâ‚€] : 0 = 1 â†” subsingleton Mâ‚€
{Î± : Type u_1} [decidable_eq Î±] {ð’œ : finset (finset Î±)} {s : finset Î±} : s âˆˆ ð’œ.shadow â†” âˆƒ (t : finset Î±) (H : t âˆˆ ð’œ), s âŠ† t âˆ§ t.card = s.card + 1
{Î± : Type u} {f g : Î± â†’ Î±} {x : Î±} (hf : function.is_fixed_pt f x) (h : function.left_inverse g f) : function.is_fixed_pt g x
{Î± : Sort u_1} {p : Î± â†’ Prop} {q : Î  (x : Î±), p x â†’ Prop} : (âˆ€ (x : Î±) (h : p x), q x h) â†” âˆ€ (x : {a // p a}), q â†‘x _
{G : Type u} [monoid G] : is_of_fin_order 1
{n : Type u'} {Î± : Type v} [fintype n] [decidable_eq n] [comm_ring Î±] {A B : matrix n n Î±} (h : B.mul A = 1) : Aâ»Â¹ = B
{Mâ‚€ : Type u_1} [mul_zero_class Mâ‚€] : has_mul.mul 0 = function.const Mâ‚€ 0
{Î± : Type u} [ordered_semiring Î±] [nontrivial Î±] : 0 < 1
{M : Type u_1} [mul_one_class M] {s : set M} : s âŠ† â†‘(submonoid.closure s)
{M : Type u_1} [has_add M] {s : set M} {S : add_subsemigroup M} : add_subsemigroup.closure s â‰¤ S â†” s âŠ† â†‘S
 : finset.nat.antidiagonal 0 = {(0, 0)}
{Î± : Type u} {L : list (Î± Ã— bool)} : free_group.red list.nil L â†” L = list.nil
{Î± : Type u} [group Î±] [has_le Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a : Î±} : 1 â‰¤ aâ»Â¹ â†” a â‰¤ 1
{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a : Î±} : -a < 0 â†” 0 < a
{Î± : Type u} {Î² : Type v} [group Î±] [mul_action Î± Î²] [has_faithful_smul Î± Î²] : function.injective mul_action.to_perm
{Î± : Type u} {Î² : Type v} {f : Î± â†’ Î²} {lâ‚ : filter Î±} {lâ‚‚ : filter Î²} : filter.tendsto f lâ‚ lâ‚‚ â†’ lâ‚ â‰¤ filter.comap f lâ‚‚
{G : Type u_1} [group G] (K : subgroup G) {l : list G} : (âˆ€ (x : G), x âˆˆ l â†’ x âˆˆ K) â†’ l.prod âˆˆ K
{a : â„•} : â†‘(nat.sqrt a) â‰¤ real.sqrt â†‘a
{m n : â„•} : (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n
{Î± : Type u} [has_subset Î±] {a b : Î±} [is_refl Î± has_subset.subset] : a = b â†’ b âŠ† a
{Î± : Type u} [group Î±] : is_group_hom id
{Î± : Type u_1} {Î¹ : Type u_2} {f : Î¹ â†’ Î±} : function.injective f â†’ pairwise (ne on f)
{Î± : Type u_1} {n : â„•} (s : sym Î± n) : sym.map (Î» (x : Î±), x) s = s
{Î± : Type u} [preorder Î±] {a b c : Î±} : b = c â†’ a â‰¤ b â†’ a â‰¤ c
{n : Type u'} {Î± : Type v} [fintype n] [decidable_eq n] [comm_ring Î±] {v : n â†’ Î±} : is_unit (matrix.diagonal v) â†” is_unit v
{Î± : Type u_1} [has_add Î±] [has_lt Î±] [contravariant_class Î± Î± has_add.add has_lt.lt] {a b c : Î±} (bc : a + b < a + c) : b < c
{Î± : Type u} [ring Î±] {a b : Î±} : a âˆ£ b + a â†” a âˆ£ b
{Î± : Type u} [topological_space Î±] {s t : set Î±} (hs : dense s) (ht : dense t) (hto : is_open t) : dense (s âˆ© t)
{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : a â‰¤ 0) (hb : b â‰¤ 0) : a + b â‰¤ 0
{M : Type u_1} [mul_one_class M] {s : set M} {S : submonoid M} : submonoid.closure s â‰¤ S â†” s âŠ† â†‘S
{Î± : Type u_1} (f : Î± â†’ set Î±) : Â¬function.surjective f
{Î± : Type u_1} [topological_space Î±] {s : set Î±} (h : is_open s) : is_GÎ´ s
{Î± : Type u} {Î² : Type v} {f : Î± â†’ Î²} {b : Î²} {l : list Î±} : b âˆˆ list.map f l â†’ (âˆƒ (a : Î±), a âˆˆ l âˆ§ f a = b)
{R : Type u_1} {a b : R} [add_semigroup R] (rra : is_add_right_regular a) (rrb : is_add_right_regular b) : is_add_right_regular (a + b)
{Î± : Type u_1} {Î² : Type u_2} {l : filter Î±} {f : Î± â†’ Î²} {lb : filter Î²} : filter.tendsto f l lb â†’ â†‘f.tendsto lb
{Î± : Type u_1} [preorder Î±] [has_add Î±] [has_sub Î±] [has_ordered_sub Î±] {a b : Î±} : a + b - b â‰¤ a
{G : Type u_1} [group G] [fintype G] (p : â„•) [hp : fact (nat.prime p)] (hdvd : p âˆ£ fintype.card G) : âˆƒ (x : G), order_of x = p
{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b c : Î±} : a + b < c â†’ a < c - b
{S : set ordinal} (f : ordinal â†’ ordinal) (hS : set.unbounded has_lt.lt S) : strict_mono f âˆ§ set.range f = S â†” f = ordinal.enum_ord S
{R : Type u_1} {a b : R} [semigroup R] : is_regular (a * b) âˆ§ is_regular (b * a) â†” is_regular a âˆ§ is_regular b
{p q : â„•} [p_prime : fact (nat.prime p)] [q_prime : fact (nat.prime q)] (neq : p â‰  q) : padic_norm p â†‘q = 1
{Î± : Type u_1} [linear_order Î±] (s : finset Î±) (hâ‚‚ : 1 < s.card) : s.min' _ < s.max' _
{X : Type u_1} [topological_space X] (hX : âˆ€ {x y : X}, x â‰  y â†’ (âˆƒ (U : set X) (h_clopen : is_clopen U), x âˆˆ U âˆ§ y âˆ‰ U)) : is_totally_disconnected set.univ
{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_mul.mul) has_le.le] {a b : Î±} (ha : 1 â‰¤ a) (hb : 1 < b) : 1 < a * b
(p : Prop) [decidable p] : p âˆ¨ Â¬p
{M : Type u_1} [add_monoid M] (s : add_submonoid M) {l : list M} (hl : âˆ€ (x : M), x âˆˆ l â†’ x âˆˆ s) : l.sum âˆˆ s
{G : Type u_1} [group G] (H : subgroup G) : 1 âˆˆ H
{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±} (ha : a < 0) (hb : b < 0) : a + b < 0
{Î± : Type u_1} [subsingleton Î±] (s : finset Î±) : s.card â‰¤ 1
{R : Type u_1} {a b : R} [add_monoid R] (h : a + b = 0) : is_add_right_regular a
{Î± : Sort u} : well_founded empty_relation
(u : pnat.xgcd_type) (hr : u.r â‰  0) : u.step.v = u.v.swap
(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P) : s âŠ† span_points k s
{Î± : Type u_1} [preorder Î±] [succ_order Î±] {a b : Î±} [no_max_order Î±] : order.succ a < order.succ b â†’ a < b
{Î“ : Type u_1} [inhabited Î“] (l : turing.list_blank Î“) : turing.list_blank.cons l.head l.tail = l
{b x c : ordinal} (b1 : 1 < b) (x0 : 0 < x) : b ^ c â‰¤ x â†” c â‰¤ ordinal.log b x
 : function.injective fin
{R : Type u_1} {M : Type u_2} [comm_semiring R] [add_comm_monoid M] [module R M] (s : set R) : submodule.torsion_by_set R M s = submodule.torsion_by_set R M â†‘(ideal.span s)
{M : Type u_1} [mul_one_class M] (c : con M) : con.ker c.mk' = c
{n : â„•} {x : â„• Ã— â„•} : x âˆˆ list.nat.antidiagonal n â†” x.fst + x.snd = n
(Î± : Type u_1) [has_zero Î±] [has_one Î±] (n : â„•) : matrix.circulant (Î» (i : fin n), ite (â†‘i = 0) 1 0) = 1
{M : Type u} [monoid M] (a : M) : a ^ 2 = a * a
{M : Type u_1} [has_add M] {c d : add_con M} (H : setoid.r = setoid{C : Type uâ‚} [category_theory.category C] {A T : C} (hT : category_theory.limits.is_terminal T) [category_theory.mono (hT.from A)] : category_theory.is_subterminal A
{Î± : Type u} [topological_space Î±] [locally_compact_space Î±] (x : Î±) : âˆƒ (K : set Î±), is_compact K âˆ§ K âˆˆ nhds x
{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a b : Î±} (ha : 1 < a) (hb : 1 â‰¤ b) : 1 < a * b
(n a b : â„•) : n < a âˆ¨ b â‰¤ n âˆ¨ n âˆˆ list.Ico a b
{C : Type u} [category_theory.category C] [category_theory.limits.has_finite_wide_pullbacks C] {B : C} : category_theory.limits.has_finite_products (category_theory.over B)
{Î± : Type u} [mul_one_class Î±] : is_monoid_hom id
(p : â„•) [fact (nat.prime p)] : padic_norm p â†‘p = 1 / â†‘p
{p : â„•} [fact (nat.prime p)] (hp : p % 4 = 1) : âˆƒ (a b : â„•), a ^ 2 + b ^ 2 = p
{S : Type u_1} [has_mul S] {a b : S} (h : commute a b) : commute b a
{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a : Î±} : -a < 0 â†’ 0 < a
{C : Type u} [category_theory.category C] [category_theory.limits.has_coproducts C] [category_theory.limits.has_coequalizers C] : category_theory.limits.has_colimits C
{Î± : Type u} [group Î±] [has_le Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a : Î±} : aâ»Â¹ â‰¤ 1 â†’ 1 â‰¤ a
{Î± : Type u_1} (L L' : list (list Î±)) : L = L' â†” L.join = L'.join âˆ§ list.map list.length L = list.map list.length L'
{Î± : Type u_1} (r : setoid Î±) : eqv_gen.setoid setoid.r = r
{S : Type u_1} [add_semigroup S] {a b c : S} (hab : add_commute a b) (hac : add_commute a c) : add_commute a (b + c)
 : function.surjective real.sinh
{Î± : Type u_1} [topological_space Î±] [baire_space Î±] {s : set Î±} : s âˆˆ residual Î± â†” âˆƒ (t : set Î±) (H : t âŠ† s), is_GÎ´ t âˆ§ dense t
{Î± : Type u} [topological_space Î±] {f : filter Î±} {a : Î±} : f â‰¤ nhds a â†” âˆ€ (s : set Î±), a âˆˆ s â†’ is_open s â†’ s âˆˆ f
{M : Type u_1} [has_add M] {c d : add_con M} : setoid.r = setoid.r â†” c = d
{Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±} : a â‰¤ b â†’ a - b â‰¤ 0
{R : Type u_1} {a : R} [add_monoid R] (ua : is_add_unit a) : is_add_regular a
{M : Type u_1} [add_zero_class M] {s : set M} {S : add_submonoid M} : add_submonoid.closure s â‰¤ S â†” s âŠ† â†‘S
{Î± : Type u} {m : â„•} (x : Î±) (u : fin m.succ â†’ Î±) : matrix.vec_cons x u 1 = matrix.vec_head u
{Î± : Type u_1} {Î² : Type u_2} [nontrivial Î±] {f : Î± â†’ Î²} (hf : function.injective f) : nontrivial Î²
(r n : â„•) : n.choose r â‰¤ n.choose (n / 2)
{Î± : Type u} [add_zero_class Î±] : is_add_monoid_hom id
{f : â„• â†’ â„•} (hf : function.injective f) : filter.tendsto f filter.at_top filter.at_top
{Î± : Type u_1} (v : vector Î± 1) : v.tail = vector.nil
{Î± : Type u_1} {A B : finset Î±} (i : â„•) (hâ‚ : i + B.card â‰¤ A.card) (hâ‚‚ : B âŠ† A) : âˆƒ (C : finset Î±), B âŠ† C âˆ§ C âŠ† A âˆ§ C.card = i + B.card
{R : Type u_1} [add_zero_class R] : is_add_regular 0
{R : Type u_1} [mul_zero_class R] [nontrivial R] : Â¬is_regular 0
{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b : Î±} (ha : 0 â‰¤ a) (hb : 0 < b) : 0 < a + b
{p q r : Prop} (hâ‚ : implies p q) (hâ‚‚ : implies q r) : implies p r
{Î± : Type u} [partial_order Î±] [decidable_rel has_le.le] {a b : Î±} (hab : a â‰¤ b) : a < b âˆ¨ a = b
{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b : Î±} : a - b < 0 â†’ a < b
{Î± : Type u} [preorder Î±] {a b c : Î±} (hab : a â‰¤ b) (hbc : b = c) : a â‰¤ c
{C : Type u} [category_theory.category C] [category_theory.preadditive C] (X Y : C) [category_theory.limits.has_binary_coproduct X Y] : category_theory.limits.has_binary_biproduct X Y
(C : Type u) [category_theory.category C] [âˆ€ {X Y : C}, category_theory.limits.has_colimit (category_theory.limits.pair X Y)] : category_theory.limits.has_binary_coproducts C
{n : â„•} {p q : â„• Ã— â„•} (hp : p âˆˆ finset.nat.antidiagonal n) (hq : q âˆˆ finset.nat.antidiagonal n) : p = q â†” p.fst = q.fst
{n : â„•} [hpos : fact (0 < n)] (i : zmod (2 * n)) : order_of (quaternion_group.xa i) = 4
{R : Type u_1} {a b : R} [add_comm_semigroup R] : is_add_regular (a + b) â†” is_add_regular a âˆ§ is_add_regular b
{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a b : Î±} (ha : 1 â‰¤ a) (hb : 1 < b) : 1 < a * b
{Î± : Type u} {f g : Î± â†’ Î±} {x : Î±} (hfg : function.is_fixed_pt (f âˆ˜ g) x) (hg : function.is_fixed_pt g x) : function.is_fixed_pt f x
{Î± : Type u} {Lâ‚ Lâ‚‚ : list (Î± Ã— bool)} [decidable_eq Î±] (H : free_group.red Lâ‚ Lâ‚‚) : free_group.reduce Lâ‚ = free_group.reduce Lâ‚‚
{Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] [covariant_class Î± Î± (function.swap has_mul.mul) has_lt.lt] {a b : Î±} : a < bâ»Â¹ â†’ b < aâ»Â¹
{m n : â„•} : (âˆ€ (a : â„•), a âˆ£ m â†” a âˆ£ n) â†” m = n
{n : â„•} {Î± : Type u_1} {v : vector Î± (n + 1)} : v.reverse.head = v.last
{Î± : Type u} [preorder Î±] {a b c : Î±} : a â‰¤ b â†’ b â‰¤ c â†’ a â‰¤ c
{Î± : Type u} [add_group Î±] : is_add_group_hom id
{M : Type u_1} [comm_monoid M] {s : set M} (hs : is_submonoid s) (m : multiset M) : (âˆ€ (a : M), a âˆˆ m â†’ a âˆˆ s) â†’ m.prod âˆˆ s
{R : Type u_1} [ordered_semiring R] [nontrivial R] : char_zero R
{Î± : Type u} : dense_inducing has_pure.pure
 : exp_neg_inv_glue.f_aux 0 = exp_neg_inv_glue
{Î± : Type u_1} {A B : set (finset Î±)} {r : â„•} : set.sized r A âˆ§ set.sized r B â†’ set.sized r (A âˆª B)
{n : â„•} (i : zmod n) : order_of (dihedral_group.sr i) = 2
{Î± : Sort u} {Î² : Sort v} : function.injective coe_fn
{Î± : Type u_1} [preorder Î±] [succ_order Î±] {a b : Î±} [no_max_order Î±] : order.succ a â‰¤ order.succ b â†’ a â‰¤ b
{m n : â„•} : m âˆ£ n + m â†” m âˆ£ n
{Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±} : 0 â‰¤ a - b â†’ b â‰¤ a
{p : â„• â†’ Prop} [decidable_pred p] {n : â„•} : p n â†’ nat.count p (n + 1) = nat.count p n + 1
(a b : â„•) : a - b.succ = a - b - 1
{n : â„•} [fact (0 < n)] (a : zmod n) : â†‘(a.val) = a
{Mâ‚€ : Type u_6} [monoid_with_zero Mâ‚€] [nontrivial Mâ‚€] [no_zero_divisors Mâ‚€] {L : list Mâ‚€} : L.prod = 0 â†” 0 âˆˆ L
{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_mul.mul) has_le.le] {a b : Î±} (ha : 1 < a) (hb : 1 < b) : 1 < a * b
{R : Type u_1} [right_cancel_semigroup R] (g : R) : is_right_regular g
{Î± : Type u} [uniform_space Î±] {f : filter Î±} {x : Î±} (hf : cauchy f) (adhs : cluster_pt x f) : f â‰¤ nhds x
{p : â„•} : summable (Î» (n : â„•), 1 / â†‘n ^ p) â†” 1 < p
{Î± : Type u_1} [preorder Î±] [nonempty Î±] [no_min_order Î±] : infinite Î±
{Î± : Type u_2} [preorder Î±] [no_max_order Î±] : filter.at_top â‰¤ filter.cofinite
{p : â„• â†’ Prop} : (âˆƒ (x : â„•), p x) â†’ well_founded (nat.upto.gt p)
{Î± : Type u} {lâ‚ lâ‚‚ : list Î±} {n : â„•} : list.drop n (lâ‚ ++ lâ‚‚) = list.drop n lâ‚ ++ list.drop (n - lâ‚.length) lâ‚‚
{G : Type u_1} [add_group G] (H : add_subgroup G) : 0 âˆˆ H
{Î± : Type u_1} (A : finset Î±) (i : â„•) (hâ‚ : i â‰¤ A.card) : âˆƒ (B : finset Î±), B âŠ† A âˆ§ B.card = i
{Î± : Type u} [topological_space Î±] : dense_range stone_cech_unit
{J : Type uâ‚} [category_theory.category J] [category_theory.is_connected J] (jâ‚ jâ‚‚ : J) : category_theory.zigzag jâ‚ jâ‚‚
{Î± : Type u} [group Î±] [has_le Î±] [covariant_class Î± Î± (function.swap has_mul.mul) has_le.le] {a : Î±} : 1 â‰¤ aâ»Â¹ â†” a â‰¤ 1
{n : Type u'} {Î± : Type v} [fintype n] [decidable_eq n] [comm_ring Î±] (A : matrix n n Î±) (h : is_unit A.det) : A.mul Aâ»Â¹ = 1
{Î± : Type u} [preorder Î±] {s : set Î±} {a : Î±} (h : is_glb s a) : bdd_below s
(p : â„•) : padic_norm p 1 = 1
{G : Type u_1} [sub_neg_monoid G] (a b : G) : a - b = a + -b
{Î± : Sort u_1} {Î² : Sort u_2} {p : Î± â†’ Î² â†’ Prop} {xâ‚€ xâ‚ : Î£' (a : Î±), subtype (p a)} : xâ‚€.fst = xâ‚.fst â†’ â†‘(xâ‚€.snd) = â†‘(xâ‚.snd) â†’ xâ‚€ = xâ‚
{C : Type u} [category_theory.category C] [category_theory.limits.has_pullbacks C] {B : C} : category_theory.limits.has_binary_products (category_theory.over B)
{Î± : Type u} [group Î±] (g : group_topology Î±) : continuous has_inv.inv
{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : 0 < a) (hb : 0 â‰¤ b) : 0 < a + b
{a p k : â„•} (pp : nat.prime p) (hâ‚ : Â¬a âˆ£ p ^ k) (hâ‚‚ : a âˆ£ p ^ (k + 1)) : a = p ^ (k + 1)
{Mâ‚€ : Type u_1} [mul_zero_one_class Mâ‚€] [nontrivial Mâ‚€] : 0 â‰  1
{Î± : Type u_1} {s : finset Î±} (p : Î± â†’ Prop) [decidable_pred p] : finset.map (function.embedding.subtype p) (finset.subtype p s) = finset.filter p s
{b : â„•} (hb : 1 < b) {x y : â„•} : x â‰¤ b ^ y â†” nat.clog b x â‰¤ y
{Î± : Type u_1} {Î² : Type u_2} [uniform_space Î±] [uniform_space Î²] [separated_space Î±] {f : Î± â†’ Î²} (hf : uniform_inducing f) : uniform_embedding f
(Î± : Type u) [preorder Î±] [nonempty Î±] [no_max_order Î±] : âˆƒ (f : â„• â†’ Î±), strict_mono f
{Î± : Type u_2} [division_monoid Î±] {a : Î±} : is_square a â†’ is_square aâ»Â¹
{Î± : Type u_1} {ð’œ : finset (finset Î±)} {r : â„•} : set.sized r â†‘(ð’œ.slice r)
(R : Type u_1) [ring R] : polynomial.cyclotomic 1 R = polynomial.X - 1
(p : â„•) : padic_norm p 0 = 0
{Î± : Type u_1} [circular_preorder Î±] {a b c : Î±} (h : has_sbtw.sbtw a b c) : has_sbtw.sbtw c a b
{R : Type u_1} [has_mul R] {a : R} : is_right_regular a â†” is_smul_regular R (mul_opposite.op a)
{G : Type u} [fintype G] [left_cancel_monoid G] (x : G) : 0 < order_of x
{P : â„¤ â†’ Prop} (Hbdd : âˆƒ (b : â„¤), âˆ€ (z : â„¤), P z â†’ b â‰¤ z) (Hinh : âˆƒ (z : â„¤), P z) : âˆƒ (lb : â„¤), P lb âˆ§ âˆ€ (z : â„¤), P z â†’ lb â‰¤ z
{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a b : Î±} (ha : 1 < a) (hb : 1 < b) : 1 < a * b
{Î± : Type u_1} {Î² : Type u_2} [infinite Î±] [fintype Î²] (f : Î± â†’ Î²) : âˆƒ (x y : Î±), x â‰  y âˆ§ f x = f y
{Î± : Type u_1} {M : Type u_5} [has_zero M] : function.injective coe_fn
{Î± : Type u} [has_subset Î±] [is_trans Î± has_subset.subset] {a b c : Î±} : a âŠ† b â†’ b âŠ† c â†’ a âŠ† c
{n : â„•} {Î± : Type u_1} [preorder Î±] {f g : fin n â†’ Î±} (hf : strict_mono f) (hg : strict_mono g) (h : set.range f = set.range g) : f = g
{R : Type u_1} [fintype R] [comm_ring R] [is_reduced R] [char_p R 2] (a : R) : is_square a
 : filter.tendsto (Î» (n : â„•), (finset.range n).sum (Î» (i : â„•), 1 / (â†‘i + 1))) filter.at_top filter.at_top
{Î¹ : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core Î¹ B F) : is_topological_fiber_bundle F Z.proj
(H : Type u) (M : Type u_2) [topological_space H] [topological_space M] [charted_space H M] [locally_compact_space H] : locally_compact_space M
{a b : Prop} : Â¬(a âˆ¨ b) â†” Â¬a âˆ§ Â¬b
{Î± : Type u_1} [decidable_eq Î±] {ð’œ : finset (finset Î±)} {r : â„•} (hð’œ : set.sized r â†‘ð’œ) : set.sized (r - 1) â†‘(ð’œ.shadow)
{M : Type u_1} [add_monoid M] {s : set M} (hs : is_add_submonoid s) {l : list M} : (âˆ€ (x : M), x âˆˆ l â†’ x âˆˆ s) â†’ l.sum âˆˆ s
{R : Type u_1} {a : R} [mul_zero_class R] [nontrivial R] (la : is_left_regular a) : a â‰  0
(Î± : Type u_1) : subsingleton Î± âˆ¨ nontrivial Î±
{Î± : Type u} {Î² : Type v} {t : set Î²} {f : Î± â†’ Î²} (h : âˆ€ (x : Î±), f x âˆˆ t) : function.injective f â†’ function.injective (set.cod_restrict f t h)
{R : Type u_1} (M : Type u_3) [monoid R] [mul_action R M] : is_smul_regular M 1
{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} [is_refl Î± r] {x y : Î±} : x â‰  y â†’ r x y â†” r x y
{G : Type u_2} [group G] {a b : G} : a = b â†’ a / b = 1
{Î± : Type u} [preorder Î±] {a b c : Î±} : a â‰¤ b â†’ b < c â†’ a < c
{Î± : Type u} [add_comm_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b c : Î±} : a - b < c â†’ a < b + c
{Î¹ : Type u} {Î² : Î¹ â†’ Type v} [Î  (i : Î¹), has_zero (Î² i)] : function.injective coe_fn
{Mâ‚€ : Type u_6} [monoid_with_zero Mâ‚€] {L : list Mâ‚€} (h : 0 âˆˆ L) : L.prod = 0
{Î± : Type u} {Î² : Type v} (f : Î± â†’ Î²) (g : Î² â†’ Î±) : set.bij_on g (function.fixed_points (f âˆ˜ g)) (function.fixed_points (g âˆ˜ f))
{n : â„•} : fin_succ_equiv' 0 = fin_succ_equiv n
{Î± : Type u} : function.injective free_group.of
{p : â„•} (hp : 1 < p) : padic_norm p â†‘p < 1
{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} {c : set Î±} (hc : is_chain r c) : âˆƒ (M : set Î±), is_max_chain r M âˆ§ c âŠ† M
{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_finite_products C] : category_theory.limits.has_finite_biproducts C
{o : ordinal} : ordinal.principal has_mul.mul o â†” o â‰¤ 2 âˆ¨ âˆƒ (a : ordinal), o = ordinal.omega ^ ordinal.omega ^ a
{Î± : Type u} {Î² : Type v} {fa : Î± â†’ Î±} {fb : Î² â†’ Î²} {g : Î± â†’ Î²} (h : function.semiconj g fa fb) : set.maps_to g (function.fixed_points fa) (function.fixed_points fb)
{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_mul.mul) has_le.le] {a b : Î±} (ha : 1 â‰¤ a) (hb : 1 â‰¤ b) : 1 â‰¤ a * b
{Î± : Type u} [group Î±] [has_le Î±] [covariant_class Î± Î± has_mul.mul has_le.le] [covariant_class Î± Î± (function.swap has_mul.mul) has_le.le] {a b : Î±} : aâ»Â¹ â‰¤ b â†’ bâ»Â¹ â‰¤ a
{Î± : Type u_1} {n : â„•} (v : vector Î± n) : vector.map id v = v
{M : Type u_1} [monoid M] {s : set M} (hs : is_submonoid s) {l : list M} : (âˆ€ (x : M), x âˆˆ l â†’ x âˆˆ s) â†’ l.prod âˆˆ s
{Î± : Type u} {Î² : Type v} [group Î±] [group Î²] {f : Î± â†’ Î²} (hf : is_group_hom f) : f 1 = 1
{Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± has_add.add has_le.le] {a : Î±} : -a â‰¤ 0 â†’ 0 â‰¤ a
{G : Type u_1} [add_group G] (K : add_subgroup G) {l : list G} : (âˆ€ (x : G), x âˆˆ l â†’ x âˆˆ K) â†’ l.sum âˆˆ K
(C : Type u) [category_theory.category C] : category_theory.essentially_small C â†” small (category_theory.skeleton C) âˆ§ category_theory.locally_small C
{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b c : Î±} : a + b < c â†’ b < -a + c
{Î± : Type u_1} [circular_preorder Î±] {a b c : Î±} : has_btw.btw a b c â†” has_btw.btw c a b
{n : â„•} : order_of (dihedral_group.r 1) = n
{Î± : Type u_1} {Î² : Type u_2} [nontrivial Î²] {f : Î± â†’ Î²} (hf : function.surjective f) : nontrivial Î±
{Î± : Type u} [topological_space Î±] {s : set Î±} : dense s â†’ dense (closure s)
{Î± : Type u_1} (s : finset Î±) : s.powerset.card = 2 ^ s.card
{Î± : Type u_1} [monoid Î±] {a u : Î±} (hu : is_unit u) : u âˆ£ a
(M : Type u_1) [monoid_with_zero M] : is_square 0
{C : Type uâ‚} [category_theory.category C] {A : C} [category_theory.limits.has_terminal C] [category_theory.mono (category_theory.limits.terminal.from A)] : category_theory.is_subterminal A
 : real.cos (real.pi / 3) = 1 / 2
(a b : â„•) : a ^ 2 - b ^ 2 = (a + b) * (a - b)
{Î± : Type u_2} {Î² : Type u_3} {f : Î± â†’ Î²} (hf : function.injective f) : filter.comap f filter.cofinite = filter.cofinite
{M : Type u_1} [add_zero_class M] (S : add_submonoid M) : add_submonoid.closure â†‘S = S
(C : Type u) [ð’ž : category_theory.category C] [category_theory.limits.has_binary_products C] [category_theory.limits.has_equalizers C] : category_theory.limits.has_pullbacks C
(C : Type u) [category_theory.category C] [category_theory.limits.has_limits_of_size C] : category_theory.limits.has_limits_of_size C
{Î± : Type u_1} {a b c : Î±} [linear_order Î±] [add_comm_semigroup Î±] [has_sub Î±] [has_ordered_sub Î±] : a < b - c â†” a + c < b
{Î± : Type u} [preorder Î±] {a b : Î±} : a < b â†’ a â‰¤ b
{R : Type u_1} [add_cancel_monoid R] (g : R) : is_add_regular g
{Î± : Type u_1} [linear_ordered_add_comm_group Î±] {n : â„¤} (hn : n â‰  0) : function.injective (Î» (_x : Î±), n â€¢ _x)
{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±} (ha : a â‰¤ 0) (hb : b < 0) : a + b < 0
{Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a : Î±} : 1 < aâ»Â¹ â†’ a < 1
{Î± : Type u} {r : Î± â†’ Î± â†’ Prop} {s : set Î±} : directed_on r s â†’ directed r coe
{R : Type u_1} [mul_zero_class R] : is_right_regular 0 â†” subsingleton R
{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : a < 0) (hb : b < 0) : a + b < 0
{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_mul.mul) has_lt.lt] {a b : Î±} (ha : 1 < a) (hb : 1 < b) : 1 < a * b
{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : a < 0) (hb : b â‰¤ 0) : a + b < 0
{C : Type uâ‚} [category_theory.category C] {A : C} [category_theory.limits.has_binary_product A A] [category_theory.is_iso (category_theory.limits.diag A)] : category_theory.is_subterminal A
{C : Type uâ‚} [category_theory.category C] {A : C} (hA : category_theory.is_subterminal A) [category_theory.limits.has_binary_product A A] : category_theory.is_iso (category_theory.limits.diag A)
{Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a : Î±} : 1 < aâ»Â¹ â†” a < 1
 : irrational (real.sqrt 2)
{Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_2} [fintype Î¹] : filter.Coprod (Î» (i : Î¹), filter.cofinite) = filter.cofinite
{Î± : Type uâ‚} {Î² : Type uâ‚‚} [topological_space Î±] [uniform_space Î²] : continuous_map.compact_open = continuous_map.compact_convergence_topology
{Î± : Type u} [preorder Î±] {f : â„¤ â†’ Î±} (hf : monotone f) (n : â„¤) {x : Î±} (h1 : f n < x) (h2 : x < f (n + 1)) (a : â„¤) : f a â‰  x
{ð•œ : Type u_1} {E : Type u_2} {Î¹ : Type u_3} [ordered_semiring ð•œ] [add_comm_group E] [module ð•œ E] {p : Î¹ â†’ E} (hc : convex_independent ð•œ p) : function.injective p
{Î± : Type u} {f g : Î± â†’ Î±} (h : function.commute f g) : set.bij_on g (function.fixed_points (f âˆ˜ g)) (function.fixed_points (f âˆ˜ g))
{Î± : Type u} [ordered_semiring Î±] [nontrivial Î±] : 0 < 3
{Î± : Type u_1} [linear_order Î±] (a : Î±) : {a}.max' _ = a
{R : Type u_1} {a : R} [add_semigroup R] (b : R) (ha : is_add_left_regular a) : is_add_left_regular (a + b) â†” is_add_left_regular b
{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [topological_space Î±] [topological_space Î²] [topological_space Î³] [locally_compact_space Î±] [locally_compact_space Î²] : continuous continuous_map.uncurry
{M : Type u_1} [add_monoid M] {x y z : M} : y âˆˆ multiples x â†’ z âˆˆ multiples x â†’ y + z âˆˆ multiples x
{Î± : Type u} [group Î±] [has_le Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a : Î±} : 1 â‰¤ aâ»Â¹ â†” a â‰¤ 1
{m n : â„•} (hmn : m.coprime n) : squarefree (m * n) â†” squarefree m âˆ§ squarefree n
(C : Type u) [category_theory.category C] [category_theory.limits.has_coproducts C] : category_theory.limits.has_finite_coproducts C
{Î± : Type u} [uniform_space Î±] (h : is_complete set.univ) : complete_space Î±
{Î± : Type u_1} [preorder Î±] [locally_finite_order Î±] {a b : Î±} : Â¬a < b â†’ multiset.Ico a b = 0
{p : â„•} [p_prime : fact (nat.prime p)] {a : â„¤} : multiplicity.finite â†‘p a â†” a â‰  0
{n : Type u'} {Î± : Type v} [fintype n] [decidable_eq n] [comm_ring Î±] (A : matrix n n Î±) : is_unit A â†” is_unit A.det
{Î± : Type u_1} (f : set Î± â†’ Î±) : Â¬function.injective f
{Î± : Type u_1} [preorder Î±] [succ_order Î±] {a : Î±} : Â¬is_max a â†’ a < order.succ a
{G : Type u} [fintype G] [add_left_cancel_monoid G] (x : G) : 0 < add_order_of x
{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±} (ha : a â‰¤ 0) (hb : b â‰¤ 0) : a + b â‰¤ 0
{M : Type u_1} [has_mul M] {s : set M} : s âŠ† â†‘(subsemigroup.closure s)
(m : â„•) : padic_val_rat m 0 = 0
{M : Type u_1} [has_add M] {c : add_con M} (x y : M) : â†‘(x + y) = â†‘x + â†‘y
{Î± : Sort u_1} {p : Î± â†’ Prop} {q : Î  (x : Î±), p x â†’ Prop} : (âˆƒ (x : Î±) (h : p x), q x h) â†” âˆƒ (x : {a // p a}), q â†‘x _
{Î± : Type u} [topological_space Î±] {s t : set Î±} (H : is_preconnected s) (Kst : s âŠ† t) (Ktcs : t âŠ† closure s) : is_preconnected t
{Î± : Type u} {Î² : Type v} [add_group Î±] [add_group Î²] {f : Î± â†’ Î²} (hf : is_add_group_hom f) : is_add_monoid_hom f
{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_limits_of_shape (category_theory.limits.wide_pullback_{Î± : Type u} {Î² : Type v} [add_group Î±] [add_group Î²] {f : Î± â†’ Î²} (hf : is_add_group_hom f) : function.injective f â†” âˆ€ (a : Î±), f a = 0 â†’ a = 0
 : (Î» (n : â„•), â†‘(nat.fib n)) = Î» (n : â„•), (golden_ratio ^ n - golden_conj ^ n) / real.sqrt 5
{Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] {f : Î± â†’ Î²} (hi : inducing f) (ho : is_open (set.range f)) : is_open_map f
 : strict_mono (Î» (n : â„•), nat.fib (n + 2))
{Î± : Type u_1} {n : â„•} {s t : finset Î±} : s âˆˆ finset.powerset_len n t â†” s âŠ† t âˆ§ s.card = n
{G : Type u_1} [add_group G] (H : add_subgroup G) {x y : G} (hx : x âˆˆ H) (hy : y âˆˆ H) : x - y âˆˆ H
{Î³ : Type w} [preorder Î³] [order_bot Î³] (s : set Î³) : bdd_below s
{Mâ‚€ : Type u_1} [mul_zero_one_class Mâ‚€] : 0 = 1 â†’ subsingleton Mâ‚€
{m n : â„•} : even (m ^ n) â†” even m âˆ§ n â‰  0
{Î± : Type u} [group Î±] [has_le Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a : Î±} : aâ»Â¹ â‰¤ 1 â†” 1 â‰¤ a
{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b : Î±} (ha : a â‰¤ 0) (hb : b < 0) : a + b < 0
{R : Type v} [comm_ring R] {n : Type u_1} [unique n] [decidable_eq n] [fintype n] (A : matrix n n R) : A.det = A inhabited.default inhabited.default
{G : Type u_1} [group G] (H : â„• â†’ subgroup G) (hH : is_ascending_central_series H) (n : â„•) : H n â‰¤ upper_central_series G n
{C : Type u} [category_theory.category C] [category_theory.abelian C] {P : C} : transitive (category_theory.abelian.pseudo_equal P)
{M : Type u_1} [has_mul M] {r s : M â†’ M â†’ Prop} (h : âˆ€ (x y : M), r x y â†’ s x y) : con_gen r â‰¤ con_gen s
{Î± : Type u_1} [decidable_eq Î±] {s t u : multiset Î±} : s - t â‰¤ u â†” s â‰¤ u + t
{Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] [locally_compact_space Î±] : continuous coe_fn
{Î± : Type u_1} [comm_semigroup Î±] {a b : Î±} (h : a âˆ£ b) (c : Î±) : a âˆ£ c * b
{p : â„• â†’ Prop} [decidable_pred p] {n : â„•} : Â¬p n â†’ nat.count p (n + 1) = nat.count p n
{Î± : Type u} [add_comm_group Î±] : is_add_group_hom has_neg.neg
{Î± : Type u_1} [semigroup Î±] {a b : Î±} (h : a âˆ£ b) (c : Î±) : a âˆ£ b * c
{R : Type u} [semiring R] {a b : add_monoid_algebra R â„•} : {to_finsupp := a} = {to_finsupp := b} â†” a = b
{M : Type u_1} [add_comm_monoid M] {s : set M} (hs : is_add_submonoid s) (m : multiset M) : (âˆ€ (a : M), a âˆˆ m â†’ a âˆˆ s) â†’ m.sum âˆˆ s
{p : â„•} (hp : 1 < p) : padic_val_rat p â†‘p = 1
{Î± : Type u} {lâ‚ lâ‚‚ : list Î±} {n : â„•} : list.take n (lâ‚ ++ lâ‚‚) = list.take n lâ‚ ++ list.take (n - lâ‚.length) lâ‚‚
 : set.inj_on nat.factorization {x : â„• | x â‰  0}
{Î± : Type uu} {r : Î± â†’ Î± â†’ Prop} [decidable_rel r] {l : list Î±} (h : list.sorted r l) : list.insertion_sort r l = l
{Î± : Type u} [has_subset Î±] {a b : Î±} [is_antisymm Î± has_subset.subset] (h : a âŠ† b) (h' : b âŠ† a) : b = a
{x k l : â„•} (w : 1 < x) : x ^ k âˆ£ x ^ l â†” k â‰¤ l
{Î± : Type u_1} [is_empty Î±] : finset.univ = âˆ…
{B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z â†’ B} [topological_space Z] [nonempty F] (h : is_topological_fiber_bundle F proj) : function.surjective proj
{M : Type u_1} [add_zero_class M] (c : add_con M) : add_con.ker c.mk' = c
{B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z â†’ B} [topological_space Z] [nonempty F] (h : is_topological_fiber_bundle F proj) : quotient_map proj
{Î± : Type u} [group Î±] (g : group_topology Î±) : continuous (Î» (p : Î± Ã— Î±), p.fst * p.snd)
{R : Type u_1} {a b : R} [semigroup R] (ab : is_regular (a * b)) (ba : is_regular (b * a)) : is_regular a âˆ§ is_regular b
{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b : Î±} : a < b â†’ a - b < 0
(R : Type u_1) [has_one R] [has_neg R] : cardinal.mk (quaternion R) = cardinal.mk R ^ 4
{a b : Prop} (hâ‚ : a â†’ b) (hâ‚‚ : Â¬b) : Â¬a
{M : Type u} [mul_one_class M] (a : M) : semiconj_by a 1 1
{Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b c : Î±} : a + b â‰¤ c â†’ b â‰¤ -a + c
{Î± : Type u} [topological_space Î±] {s : set Î±} (H : is_totally_separated s) : is_totally_disconnected s
(p : â„•) : â†‘(mersenne p) = 0
{Î± : Type u_3} [ordered_semiring Î±] {n : â„•} (hn : 1 â‰¤ n) : filter.tendsto (Î» (x : Î±), x ^ n) filter.at_top filter.at_top
{M : Type u_3} [add_monoid M] [preorder M] (L : list M) (h : 0 < L.sum) : 0 < L.length
{p : â„•} {z : â„¤} : padic_val_rat p â†‘z = â†‘(padic_val_int p z)
{C : Type u} [category_theory.category C] [category_theory.limits.has_wide_pullbacks C] {B : C} : category_theory.limits.has_products (category_theory.over B)
{G : Type u} {x y : G} [add_comm_monoid G] (hx : is_of_fin_add_order x) (hy : is_of_fin_add_order y) : is_of_fin_add_order (x + y)
{Î± : Type u_1} [preorder Î±] {a b : Î±} (h : b < a) : Â¬is_min a
{Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±} : b â‰¤ a â†’ 0 â‰¤ a - b
{Î± : Type u_1} [preorder Î±] [locally_finite_order Î±] {a b : Î±} : Â¬a â‰¤ b â†’ multiset.Icc a b = 0
(p : nat.primes) : â†‘p.factor_multiset = prime_multiset.of_prime p
{Î± : Type u} [add_comm_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b c : Î±} : b < c - a â†’ a + b < c
{Î± : Type u_1} [fintype Î±] {ð’œ : finset (finset Î±)} {r : â„•} : set.sized r â†‘ð’œ â†’ ð’œ âŠ† finset.powerset_len r finset.univ
{R : Type u_1} [mul_zero_class R] : Â¬is_left_regular 0 â†” nontrivial R
{Î± : Sort u_1} (P : Prop) [decidable P] (x : Â¬P â†’ Î±) (y : Â¬Â¬P â†’ Î±) : dite (Â¬P) x y = dite P (Î» (h : P), y _) x
{Î± : Sort u_1} (P : Prop) [decidable P] (a b : Î±) : ite (Â¬P) a b = ite P b a
{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} {s : set Î±} (h : is_chain r s) : is_chain (flip r) s
{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] : function.injective coe
{n : â„•} [fact (0 < n)] (i : zmod n) : order_of (dihedral_group.r i) = n / n.gcd i.val
{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_binary_coproducts C] : category_theory.limits.has_binary_biproducts C
{R : Type u_1} [comm_ring R] [fintype R] (p : â„•) [fact (nat.prime p)] : p âˆ£ ring_char R â†” p âˆ£ fintype.card R
{Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± has_add.add has_le.le] {a : Î±} : 0 â‰¤ -a â†” a â‰¤ 0
{Î± : Type u_1} {Î² : Type u_2} [has_add Î±] [add_comm_group Î²] {f : Î± â†’ Î²} (hf : is_add_hom f) : is_add_hom (Î» (a : Î±), -f a)
{Î± : Type u_1} [partial_order Î±] [pred_order Î±] {a b : Î±} [no_min_order Î±] : a â‰  b â†’ order.pred a â‰  order.pred b
{Î± : Type u} (r s : Î± â†’ Î± â†’ Prop) [is_nonstrict_strict_order Î± r s] {a b : Î±} : s a b â†” r a b âˆ§ Â¬r b a
{Î± : Type u} [add_comm_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b c : Î±} : a + b < c â†’ b < c - a
{R : Type uâ‚} [ordered_semiring R] {a : R} (Hsq : 0 â‰¤ a * a) (Hsq' : 0 â‰¤ (1 + a) * (1 + a)) (H : 0 â‰¤ 2 + a) (n : â„•) : 1 + â†‘n * a â‰¤ (1 + a) ^ n
{Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± has_add.add has_le.le] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±} : -a â‰¤ b â†’ -b â‰¤ a
{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_binary_biproducts C] (X : C) [category_theory.simple X] : category_theory.indecomposable X
{R : Type u_1} [add_right_cancel_semigroup R] (g : R) : is_add_right_regular g
{G : Type u_1} [add_group G] (K : add_subgroup G) {k : set G} : add_subgroup.closure k â‰¤ K â†” k âŠ† â†‘K
{Î± : Type u_1} [preorder Î±] [locally_finite_order Î±] {a b : Î±} : Â¬a < b â†’ finset.Ico a b = âˆ…
