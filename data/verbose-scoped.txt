Mathlib/RingTheory/OreLocalization/Basic.lean:scoped syntax:1075 term noWs atomic("[" term "â»Â¹" noWs "]") : term
Mathlib/Algebra/BigOperators/Basic.lean:scoped syntax (name := bigsum) "âˆ‘ " extBinder ", " term:67 : term
Mathlib/Algebra/BigOperators/Basic.lean:scoped syntax (name := bigprod) "âˆ " extBinder ", " term:67 : term
Mathlib/Algebra/BigOperators/Basic.lean:scoped syntax (name := bigsumin) "âˆ‘ " extBinder " in " term ", " term:67 : term
Mathlib/Algebra/BigOperators/Basic.lean:scoped syntax (name := bigprodin) "âˆ " extBinder " in " term ", " term:67 : term
Mathlib/RingTheory/WittVector/StructurePolynomial.lean:scoped[Witt] notation "W_" => wittPolynomial p
Mathlib/RingTheory/WittVector/StructurePolynomial.lean:scoped[Witt] notation "W" => wittPolynomial p _
Mathlib/RingTheory/WittVector/Isocrystal.lean:scoped[Isocrystal] notation "K(" p ", " k ")" => FractionRing (WittVector p k)
Mathlib/RingTheory/WittVector/Isocrystal.lean:scoped[Isocrystal] notation "Ï†(" p ", " k ")" => WittVector.FractionRing.frobeniusRingHom p k
Mathlib/RingTheory/WittVector/Isocrystal.lean:scoped[Isocrystal] notation "Î¦(" p ", " k ")" => WittVector.Isocrystal.frobenius p k
Mathlib/RingTheory/WittVector/Isocrystal.lean:scoped[Isocrystal] notation:50 M " â†’á¶ â±[" p ", " k "] " Mâ‚‚ => WittVector.IsocrystalHom p k M Mâ‚‚
Mathlib/RingTheory/WittVector/Isocrystal.lean:scoped[Isocrystal] notation:50 M " â‰ƒá¶ â±[" p ", " k "] " Mâ‚‚ => WittVector.IsocrystalEquiv p k M Mâ‚‚
Mathlib/RingTheory/WittVector/WittPolynomial.lean:scoped[Witt] notation "W_" => wittPolynomial p
Mathlib/RingTheory/WittVector/WittPolynomial.lean:scoped[Witt] notation "W" => wittPolynomial p _
Mathlib/RingTheory/NonZeroDivisors.lean:scoped[nonZeroDivisors] notation:9000 R "â°" => nonZeroDivisors R
Mathlib/RingTheory/NonZeroDivisors.lean:scoped[nonZeroSMulDivisors] notation:9000 R "â°[" M "]" => nonZeroSMulDivisors R M
Mathlib/RingTheory/Valuation/Basic.lean:scoped[DiscreteValuation] notation "â„•â‚˜â‚€" => WithZero (Multiplicative â„•)
Mathlib/RingTheory/Valuation/Basic.lean:scoped[DiscreteValuation] notation "â„¤â‚˜â‚€" => WithZero (Multiplicative â„¤)
Mathlib/RingTheory/PowerSeries/Derivative.lean:scoped notation "dâ„dX" => derivative
Mathlib/RingTheory/PowerSeries/Basic.lean:scoped notation:9000 R "âŸ¦XâŸ§" => PowerSeries R
Mathlib/Combinatorics/SetFamily/Compression/UV.lean:scoped[FinsetFamily] notation "ğ“’ " => UV.compression
Mathlib/Combinatorics/SetFamily/Compression/Down.lean:scoped[FinsetFamily] notation "ğ““ " => Down.compression
Mathlib/AlgebraicGeometry/EllipticCurve/Weierstrass.lean:scoped[PolynomialPolynomial] notation "Y" => Polynomial.X
Mathlib/AlgebraicGeometry/EllipticCurve/Weierstrass.lean:scoped[PolynomialPolynomial] notation R "[X][Y]" => Polynomial (Polynomial R)
Mathlib/AlgebraicGeometry/EllipticCurve/Point.lean:scoped[WeierstrassCurve] notation W "âŸ®" S "âŸ¯" => Point (baseChange W S)
Mathlib/AlgebraicTopology/SimplexCategory.lean:scoped[Simplicial] notation "[" n "]" => SimplexCategory.mk n
Mathlib/AlgebraicTopology/SimplicialSet.lean:scoped[Simplicial] notation "Î”[" n "]" => SSet.standardSimplex.obj (SimplexCategory.mk n)
Mathlib/AlgebraicTopology/SimplicialSet.lean:scoped[Simplicial] notation "âˆ‚Î”[" n "]" => SSet.boundary n
Mathlib/AlgebraicTopology/SimplicialSet.lean:scoped[Simplicial] notation "Î›[" n ", " i "]" => SSet.horn (n : â„•) i
Mathlib/AlgebraicTopology/FundamentalGroupoid/Basic.lean:scoped notation "Ï€" => FundamentalGroupoid.fundamentalGroupoidFunctor
Mathlib/AlgebraicTopology/FundamentalGroupoid/Basic.lean:scoped notation "Ï€â‚“" => FundamentalGroupoid.fundamentalGroupoidFunctor.obj
Mathlib/AlgebraicTopology/FundamentalGroupoid/Basic.lean:scoped notation "Ï€â‚˜" => FundamentalGroupoid.fundamentalGroupoidFunctor.map
Mathlib/AlgebraicTopology/DoldKan/Notations.lean:scoped[DoldKan] notation "K[" X "]" => AlgebraicTopology.AlternatingFaceMapComplex.obj X
Mathlib/AlgebraicTopology/DoldKan/Notations.lean:scoped[DoldKan] notation "N[" X "]" => AlgebraicTopology.NormalizedMooreComplex.obj X
Mathlib/Topology/UniformSpace/Separation.lean:scoped[Uniformity] notation "ğ“¢" => separationRel
Mathlib/Topology/UniformSpace/Basic.lean:scoped[Uniformity] notation "ğ“¤[" u "]" => @uniformity _ u
Mathlib/Topology/UniformSpace/Basic.lean:scoped[Uniformity] notation "ğ“¤" => uniformity
Mathlib/Topology/UniformSpace/Basic.lean:scoped[Uniformity] notation "UniformContinuous[" uâ‚ ", " uâ‚‚ "]" => @UniformContinuous _ _ uâ‚ uâ‚‚
Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean:scoped[UniformConvergence] notation:25 Î± " â†’áµ¤ " Î²:0 => UniformFun Î± Î²
Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean:scoped[UniformConvergence] notation:25 Î± " â†’áµ¤[" ğ”– "] " Î²:0 => UniformOnFun Î± Î² ğ”–
Mathlib/Topology/ContinuousFunction/ZeroAtInfty.lean:scoped[ZeroAtInfty] notation (priority := 2000) "Câ‚€(" Î± ", " Î² ")" => ZeroAtInftyContinuousMap Î± Î²
Mathlib/Topology/ContinuousFunction/ZeroAtInfty.lean:scoped[ZeroAtInfty] notation Î± " â†’Câ‚€ " Î² => ZeroAtInftyContinuousMap Î± Î²
Mathlib/Topology/UnitInterval.lean:scoped[unitInterval] notation "I" => unitInterval
Mathlib/Topology/UnitInterval.lean:scoped notation "Ïƒ" => unitInterval.symm
Mathlib/Topology/Compactification/OnePoint.lean:scoped notation "âˆ" => OnePoint.infty
Mathlib/Topology/Sheaves/Presheaf.lean:scoped[AlgebraicGeometry] notation:80 x " |_â‚— " U " âŸª" e "âŸ« " =>
Mathlib/Topology/Homotopy/HomotopyGroup.lean:scoped[Topology] notation "I^" N => N â†’ I
Mathlib/Topology/Homotopy/HomotopyGroup.lean:scoped[Topology.Homotopy] notation "Î©" => LoopSpace
Mathlib/Topology/Homotopy/HomotopyGroup.lean:scoped[Topology.Homotopy] notation "Î©^" => GenLoop
Mathlib/Topology/Homotopy/HomotopyGroup.lean:scoped[Topology] notation "Ï€_" => HomotopyGroup.Pi
Mathlib/Topology/Homotopy/HSpaces.lean:scoped[HSpaces] notation x "â‹€" y => HSpace.hmul (x, y)
Mathlib/Topology/Basic.lean:scoped[Topology] notation (name := IsOpen_of) "IsOpen[" t "]" => @IsOpen _ t
Mathlib/Topology/Basic.lean:scoped[Topology] notation (name := IsClosed_of) "IsClosed[" t "]" => @IsClosed _ t
Mathlib/Topology/Basic.lean:scoped[Topology] notation (name := closure_of) "closure[" t "]" => @closure _ t
Mathlib/Topology/Basic.lean:scoped[Topology] notation "ğ“" => nhds
Mathlib/Topology/Basic.lean:scoped[Topology] notation "ğ“[" s "] " x:100 => nhdsWithin x s
Mathlib/Topology/Basic.lean:scoped[Topology] notation "ğ“[â‰ ] " x:100 => nhdsWithin x (@singleton _ (Set _) instSingletonSet x)á¶œ
Mathlib/Topology/Basic.lean:scoped[Topology] notation "ğ“[â‰¥] " x:100 => nhdsWithin x (Set.Ici x)
Mathlib/Topology/Basic.lean:scoped[Topology] notation "ğ“[â‰¤] " x:100 => nhdsWithin x (Set.Iic x)
Mathlib/Topology/Basic.lean:scoped[Topology] notation "ğ“[>] " x:100 => nhdsWithin x (Set.Ioi x)
Mathlib/Topology/Basic.lean:scoped[Topology] notation "ğ“[<] " x:100 => nhdsWithin x (Set.Iio x)
Mathlib/Topology/Basic.lean:scoped[Topology] notation (name := Continuous_of) "Continuous[" tâ‚ ", " tâ‚‚ "]" =>
Mathlib/ModelTheory/Basic.lean:scoped[FirstOrder] notation:25 A " â†’[" L "] " B => FirstOrder.Language.Hom L A B
Mathlib/ModelTheory/Basic.lean:scoped[FirstOrder] notation:25 A " â†ª[" L "] " B => FirstOrder.Language.Embedding L A B
Mathlib/ModelTheory/Basic.lean:scoped[FirstOrder] notation:25 A " â‰ƒ[" L "] " B => FirstOrder.Language.Equiv L A B
Mathlib/ModelTheory/LanguageMap.lean:scoped[FirstOrder] notation:95 L "[[" Î± "]]" => Language.withConstants L Î±
Mathlib/ModelTheory/ElementaryMaps.lean:scoped[FirstOrder] notation:25 A " â†ªâ‚‘[" L "] " B => FirstOrder.Language.ElementaryEmbedding L A B
Mathlib/Algebra/Star/Basic.lean:scoped[ComplexConjugate] notation "conj" => starRingEnd _
Mathlib/Algebra/BigOperators/Finprod.lean:scoped[BigOperators] notation3"âˆ‘á¶  "(...)", "r:67:(scoped f => finsum f) => r
Mathlib/Algebra/BigOperators/Finprod.lean:scoped[BigOperators] notation3"âˆá¶  "(...)", "r:67:(scoped f => finprod f) => r
Mathlib/Algebra/MonoidAlgebra/Basic.lean:scoped[AddMonoidAlgebra] notation:9000 R:max "[" A "]" => AddMonoidAlgebra R A
Mathlib/Algebra/DualNumber.lean:scoped[DualNumber] notation "Îµ" => DualNumber.eps
Mathlib/Algebra/Quaternion.lean:scoped[Quaternion] notation "â„[" R "," a "," b "]" => QuaternionAlgebra R a b
Mathlib/Algebra/Quaternion.lean:scoped[Quaternion] notation "â„[" R "]" => Quaternion R
Mathlib/Algebra/DirectSum/Basic.lean:scoped[DirectSum] notation3 "â¨ "(...)", "r:(scoped f => DirectSum _ f) => r
Mathlib/Algebra/Category/ModuleCat/Basic.lean:scoped[ModuleCat] notation "â†Ÿ" f:1024 => ModuleCat.asHom f
Mathlib/Algebra/Category/ModuleCat/Basic.lean:scoped[ModuleCat] notation "â†¾" f:1024 => ModuleCat.asHomRight f
Mathlib/Algebra/Category/ModuleCat/Basic.lean:scoped[ModuleCat] notation "â†¿" f:1024 => ModuleCat.asHomLeft f
Mathlib/SetTheory/Cardinal/Ordinal.lean:scoped notation "Ï‰_" o => ord <| aleph o
Mathlib/SetTheory/Cardinal/Ordinal.lean:scoped notation "Ï‰â‚" => ord <| aleph 1
Mathlib/SetTheory/Cardinal/Basic.lean:scoped notation "â„µâ‚€" => Cardinal.aleph0
Mathlib/SetTheory/Cardinal/Continuum.lean:scoped notation "ğ” " => Cardinal.continuum
Mathlib/SetTheory/Ordinal/Basic.lean:scoped notation "Ï‰" => Ordinal.omega
Mathlib/LinearAlgebra/PiTensorProduct.lean:scoped[TensorProduct] notation3:100"â¨‚["R"] "(...)", "r:(scoped f => PiTensorProduct R f) => r
Mathlib/LinearAlgebra/AffineSpace/Basic.lean:scoped[Affine] notation "AffineSpace" => AddTorsor
Mathlib/LinearAlgebra/TensorPower.lean:scoped[TensorProduct] notation:100 "â¨‚[" R "]^" n:arg => TensorPower R n
Mathlib/LinearAlgebra/Projectivization/Basic.lean:scoped[LinearAlgebra.Projectivization] notation "â„™" => Projectivization
Mathlib/LinearAlgebra/TensorProduct.lean:scoped[TensorProduct] notation:100 M " âŠ—[" R "] " N:100 => TensorProduct R M N
Mathlib/LinearAlgebra/Matrix/SpecialLinearGroup.lean:scoped[MatrixGroups] notation "SL(" n ", " R ")" => Matrix.SpecialLinearGroup (Fin n) R
Mathlib/CategoryTheory/Types.lean:scoped notation "â†¾" f:200 => CategoryTheory.asHom f
Mathlib/CategoryTheory/Functor/Basic.lean:scoped [CategoryTheory] notation "ğŸ­" => Functor.id -- Type this as `\sb1`
Mathlib/CategoryTheory/Monoidal/Category.lean:scoped notation "ğŸ™_ " C:max => (MonoidalCategoryStruct.tensorUnit : C)
Mathlib/CategoryTheory/Monoidal/Category.lean:scoped notation "Î±_" => MonoidalCategoryStruct.associator
Mathlib/CategoryTheory/Monoidal/Category.lean:scoped notation "Î»_" => MonoidalCategoryStruct.leftUnitor
Mathlib/CategoryTheory/Monoidal/Category.lean:scoped notation "Ï_" => MonoidalCategoryStruct.rightUnitor
Mathlib/CategoryTheory/Category/Basic.lean:scoped notation "ğŸ™" => CategoryStruct.id  -- type as \b1
Mathlib/CategoryTheory/Bicategory/Basic.lean:scoped notation "Î±_" => Bicategory.associator
Mathlib/CategoryTheory/Bicategory/Basic.lean:scoped notation "Î»_" => Bicategory.leftUnitor
Mathlib/CategoryTheory/Bicategory/Basic.lean:scoped notation "Ï_" => Bicategory.rightUnitor
Mathlib/Probability/ConditionalProbability.lean:scoped notation Î¼ "[" s "|" t "]" => ProbabilityTheory.cond Î¼ t s
Mathlib/Probability/ConditionalProbability.lean:scoped notation:60 Î¼ "[|" t "]" => ProbabilityTheory.cond Î¼ t
Mathlib/Probability/Notation.lean:scoped[ProbabilityTheory] notation "ğ”¼[" X "|" m "]" =>
Mathlib/Probability/Notation.lean:scoped[ProbabilityTheory] notation P "[" X "]" => âˆ« x, â†‘(X x) âˆ‚P
Mathlib/Probability/Notation.lean:scoped[ProbabilityTheory] notation "ğ”¼[" X "]" => âˆ« a, (X : _ â†’ _) a
Mathlib/Probability/Notation.lean:scoped[ProbabilityTheory] notation P "âŸ¦" s "|" m "âŸ§" =>
Mathlib/Probability/Notation.lean:scoped[ProbabilityTheory] notation:50 X " =â‚â‚› " Y:50 => X =áµ[MeasureTheory.MeasureSpace.volume] Y
Mathlib/Probability/Notation.lean:scoped[ProbabilityTheory] notation:50 X " â‰¤â‚â‚› " Y:50 => X â‰¤áµ[MeasureTheory.MeasureSpace.volume] Y
Mathlib/Probability/Notation.lean:scoped[ProbabilityTheory] notation "âˆ‚" P "/âˆ‚" Q:100 => MeasureTheory.Measure.rnDeriv P Q
Mathlib/Probability/Notation.lean:scoped[ProbabilityTheory] notation "â„™" => MeasureTheory.MeasureSpace.volume
Mathlib/Probability/Variance.lean:scoped notation "eVar[" X "]" => ProbabilityTheory.evariance X MeasureTheory.MeasureSpace.volume
Mathlib/Probability/Variance.lean:scoped notation "Var[" X "]" => ProbabilityTheory.variance X MeasureTheory.MeasureSpace.volume
Mathlib/Data/Polynomial/Laurent.lean:scoped[LaurentPolynomial] notation:9000 R "[T;Tâ»Â¹]" => LaurentPolynomial R
Mathlib/Data/Polynomial/Basic.lean:scoped[Polynomial] notation:9000 R "[X]" => Polynomial R
Mathlib/Data/Num/Bitwise.lean:scoped notation a "::" b => bit a b
Mathlib/Data/Num/Bitwise.lean:scoped notation a "::" b => bit a b
Mathlib/Data/Complex/Module.lean:scoped[ComplexStarModule] notation "â„œ" => realPart
Mathlib/Data/Complex/Module.lean:scoped[ComplexStarModule] notation "â„‘" => imaginaryPart
Mathlib/Data/Complex/Exponential.lean:scoped notation "cexp" => Complex.exp
Mathlib/Data/Complex/Exponential.lean:scoped notation "rexp" => Real.exp
Mathlib/Data/Nat/Factorial/DoubleFactorial.lean:scoped notation:10000 n "â€¼" => Nat.doubleFactorial n
Mathlib/Data/Nat/Factorial/Basic.lean:scoped notation:10000 n "!" => Nat.factorial n
Mathlib/Data/Nat/Factorial/SuperFactorial.lean:scoped notation "sf" n:60 => Nat.superFactorial n
Mathlib/Data/Nat/Totient.lean:scoped notation "Ï†" => Nat.totient
Mathlib/Data/Rat/NNRat.lean:scoped[NNRat] notation "â„šâ‰¥0" => NNRat
Mathlib/Data/Sym/Basic.lean:scoped notation a " :: " b => cons' a b
Mathlib/Data/Real/ENNReal.lean:scoped[ENNReal] notation "â„â‰¥0âˆ" => ENNReal
Mathlib/Data/Real/ENNReal.lean:scoped[ENNReal] notation "âˆ" => (âŠ¤ : ENNReal)
Mathlib/Data/Real/NNReal.lean:scoped notation "â„â‰¥0" => NNReal
Mathlib/Data/Set/Intervals/UnorderedInterval.lean:scoped[Interval] notation "[[" a ", " b "]]" => Set.uIcc a b
Mathlib/Data/Vector3.lean:scoped notation a " :: " b => cons a b
Mathlib/Data/Bundle.lean:scoped notation:max "Ï€" F':max E':max => Bundle.TotalSpace.proj (F := F') (E := E')
Mathlib/Data/List/Func.lean:scoped notation as " {" m " â†¦ " a "}" => List.Func.set a as m
Mathlib/MeasureTheory/Function/ConditionalExpectation/Basic.lean:scoped notation Î¼ "[" f "|" m "]" => MeasureTheory.condexp m Î¼ f
Mathlib/MeasureTheory/Function/LpSpace.lean:scoped notation:25 Î±' " â†’â‚[" Î¼ "] " E => MeasureTheory.Lp (Î± := Î±') E 1 Î¼
Mathlib/MeasureTheory/Function/LpSpace.lean:scoped notation:25 Î±' " â†’â‚‚[" Î¼ "] " E => MeasureTheory.Lp (Î± := Î±') E 2 Î¼
Mathlib/MeasureTheory/Function/StronglyMeasurable/Basic.lean:scoped notation "StronglyMeasurable[" m "]" => @MeasureTheory.StronglyMeasurable _ _ _ m
Mathlib/MeasureTheory/MeasurableSpace/Defs.lean:scoped notation "MeasurableSet[" m "]" => @MeasurableSet _ m
Mathlib/MeasureTheory/MeasurableSpace/Defs.lean:scoped notation "Measurable[" m "]" => @Measurable _ _ m _
Mathlib/MeasureTheory/Measure/Hausdorff.lean:scoped[MeasureTheory] notation "Î¼H[" d "]" => MeasureTheory.Measure.hausdorffMeasure d
Mathlib/Order/Filter/Basic.lean:scoped notation "ğ“Ÿ" => Filter.principal
Mathlib/Order/LocallyFinite.lean:scoped[FinsetInterval] notation "[[" a ", " b "]]" => Finset.uIcc a b
Mathlib/Analysis/Complex/UnitDisc/Basic.lean:scoped[UnitDisc] notation "ğ”»" => Complex.UnitDisc
Mathlib/Analysis/Complex/UpperHalfPlane/Basic.lean:scoped[UpperHalfPlane] notation "â„" => UpperHalfPlane
Mathlib/Analysis/InnerProductSpace/Basic.lean:scoped[RealInnerProductSpace] notation "âŸª" x ", " y "âŸ«" => @inner â„ _ _ x y
Mathlib/Analysis/InnerProductSpace/Basic.lean:scoped[ComplexInnerProductSpace] notation "âŸª" x ", " y "âŸ«" => @inner â„‚ _ _ x y
Mathlib/Analysis/BoxIntegral/Partition/Additive.lean:scoped notation:25 Î¹ " â†’áµ‡áµƒ " M => BoxIntegral.BoxAdditiveMap Î¹ M âŠ¤
Mathlib/Analysis/BoxIntegral/Partition/Additive.lean:scoped notation:25 Î¹ " â†’áµ‡áµƒ[" I "] " M => BoxIntegral.BoxAdditiveMap Î¹ M I
Mathlib/Analysis/Distribution/SchwartzSpace.lean:scoped[SchwartzSpace] notation "ğ“¢(" E ", " F ")" => SchwartzMap E F
Mathlib/Analysis/Fourier/FourierTransform.lean:scoped[FourierTransform] notation e "[" x "]" => (e (Multiplicative.ofAdd x) : â„‚)
Mathlib/Analysis/Fourier/FourierTransform.lean:scoped[FourierTransform] notation "ğ“•" => Real.fourierIntegral
Mathlib/Analysis/Convolution.lean:scoped[Convolution] notation:67 f " â‹†[" L:67 ", " Î¼:67 "] " g:66 => convolution f g L Î¼
Mathlib/Analysis/Calculus/Gradient/Basic.lean:scoped[Gradient] notation "âˆ‡" => gradient
Mathlib/Analysis/NormedSpace/Star/Multiplier.lean:scoped[MultiplierAlgebra] notation "ğ“œ(" ğ•œ ", " A ")" => DoubleCentralizer ğ•œ A
Mathlib/Analysis/NormedSpace/lpSpace.lean:scoped[lp] notation "â„“^âˆ(" Î¹ ", " E ")" => lp (fun i : Î¹ => E) âˆ
Mathlib/Analysis/NormedSpace/lpSpace.lean:scoped[lp] notation "â„“^âˆ(" Î¹ ")" => lp (fun i : Î¹ => â„) âˆ
Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean:scoped notation "Ï€" => Real.pi
Mathlib/Analysis/Quaternion.lean:scoped[Quaternion] notation "â„" => Quaternion â„
Mathlib/Analysis/Convex/Segment.lean:scoped[Convex] notation (priority := high) "[" x "-[" ğ•œ "]" y "]" => segment ğ•œ x y
Mathlib/Analysis/Asymptotics/AsymptoticEquivalent.lean:scoped notation:50 u " ~[" l:50 "] " v:50 => Asymptotics.IsEquivalent l u v
Mathlib/Dynamics/OmegaLimit.lean:scoped[omegaLimit] notation "Ï‰" => omegaLimit
Mathlib/Dynamics/OmegaLimit.lean:scoped[omegaLimit] notation "Ï‰âº" => omegaLimit Filter.atTop
Mathlib/Dynamics/OmegaLimit.lean:scoped[omegaLimit] notation "Ï‰â»" => omegaLimit Filter.atBot
Mathlib/Geometry/Euclidean/Angle/Oriented/Affine.lean:scoped notation "âˆ¡" => EuclideanGeometry.oangle
Mathlib/Geometry/Euclidean/Angle/Unoriented/Affine.lean:scoped notation "âˆ " => EuclideanGeometry.angle
Mathlib/Geometry/Manifold/Diffeomorph.lean:scoped[Manifold] notation M " â‰ƒâ‚˜^" n:1000 "âŸ®" I ", " J "âŸ¯ " N => Diffeomorph I J M N n
Mathlib/Geometry/Manifold/Diffeomorph.lean:scoped[Manifold] notation M " â‰ƒâ‚˜âŸ®" I ", " J "âŸ¯ " N => Diffeomorph I J M N âŠ¤
Mathlib/Geometry/Manifold/Algebra/Monoid.lean:scoped[LieGroup] notation "ğ‘³" => smoothLeftMul
Mathlib/Geometry/Manifold/Algebra/Monoid.lean:scoped[LieGroup] notation "ğ‘¹" => smoothRightMul
Mathlib/Geometry/Manifold/VectorBundle/SmoothSection.lean:scoped[Manifold] notation "Câ‚›^" n "âŸ®" I "; " F ", " V "âŸ¯" => ContMDiffSection I F n V
Mathlib/Geometry/Manifold/DerivationBundle.lean:scoped[Derivation] notation "C^" n "âŸ®" I ", " M "; " ğ•œ "âŸ¯âŸ¨" x "âŸ©" => PointedSmoothMap ğ•œ I M n x
Mathlib/Geometry/Manifold/DerivationBundle.lean:scoped[Manifold] notation "ğ’…" => fdifferential
Mathlib/Geometry/Manifold/DerivationBundle.lean:scoped[Manifold] notation "ğ’…â‚•" => hfdifferential
Mathlib/Geometry/Manifold/ContMDiffMap.lean:scoped[Manifold] notation "C^" n "âŸ®" I ", " M "; " I' ", " M' "âŸ¯" => ContMDiffMap I I' M M' n
Mathlib/Geometry/Manifold/SmoothManifoldWithCorners.lean:scoped[Manifold] notation "âˆ" => (âŠ¤ : â„•âˆ)
Mathlib/Geometry/Manifold/SmoothManifoldWithCorners.lean:scoped[Manifold] notation "ğ“˜(" ğ•œ ", " E ")" => modelWithCornersSelf ğ•œ E
Mathlib/Geometry/Manifold/SmoothManifoldWithCorners.lean:scoped[Manifold] notation "ğ“˜(" ğ•œ ")" => modelWithCornersSelf ğ•œ ğ•œ
Mathlib/NumberTheory/LegendreSymbol/JacobiSymbol.lean:scoped[NumberTheorySymbols] notation "J(" a " | " b ")" => jacobiSym a b
Mathlib/NumberTheory/VonMangoldt.lean:scoped[Nat.ArithmeticFunction] notation "Î›" => Nat.ArithmeticFunction.vonMangoldt
Mathlib/NumberTheory/Modular.lean:scoped[Modular] notation "ğ’Ÿ" => ModularGroup.fd
Mathlib/NumberTheory/Modular.lean:scoped[Modular] notation "ğ’Ÿáµ’" => ModularGroup.fdo
Mathlib/NumberTheory/ModularForms/SlashActions.lean:scoped[ModularForm] notation:100 f " âˆ£[" k ";" Î³ "] " a:100 => SlashAction.map Î³ k a f
Mathlib/NumberTheory/ModularForms/SlashActions.lean:scoped[ModularForm] notation:100 f " âˆ£[" k "] " a:100 => SlashAction.map â„‚ k a f
Mathlib/NumberTheory/ArithmeticFunction.lean:scoped[Nat.ArithmeticFunction] notation "Î¶" => Nat.ArithmeticFunction.zeta
Mathlib/NumberTheory/ArithmeticFunction.lean:scoped[Nat.ArithmeticFunction] notation "Ïƒ" => Nat.ArithmeticFunction.sigma
Mathlib/NumberTheory/ArithmeticFunction.lean:scoped[Nat.ArithmeticFunction] notation "Î©" => Nat.ArithmeticFunction.cardFactors
Mathlib/NumberTheory/ArithmeticFunction.lean:scoped[Nat.ArithmeticFunction] notation "Ï‰" => Nat.ArithmeticFunction.cardDistinctFactors
Mathlib/NumberTheory/ArithmeticFunction.lean:scoped[Nat.ArithmeticFunction] notation "Î¼" => Nat.ArithmeticFunction.moebius
Mathlib/NumberTheory/Dioph.lean:scoped notation:35 x " Dâˆ§ " y => Dioph.inter x y
Mathlib/NumberTheory/Dioph.lean:scoped notation:35 x " Dâˆ¨ " y => Dioph.union x y
Mathlib/NumberTheory/Dioph.lean:scoped notation:30 "Dâˆƒ" => Dioph.vec_ex1_dioph
Mathlib/NumberTheory/Dioph.lean:scoped notation " Dâ‰¡ " => Dioph.modEq_dioph
Mathlib/NumberTheory/PrimeCounting.lean:scoped notation "Ï€" => Nat.primeCounting
Mathlib/NumberTheory/PrimeCounting.lean:scoped notation "Ï€'" => Nat.primeCounting'
Mathlib/NumberTheory/NumberField/Basic.lean:scoped notation "ğ“" => NumberField.ringOfIntegers
