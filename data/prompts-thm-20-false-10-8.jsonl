{"text":"If every proper closed subset of a topological space is compact, then the space itself is compact.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The intersection of two open compact subsets of a quasi-separated space is compact.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u_3} [inst : TopologicalSpace Î±] [self : QuasiSeparatedSpace Î±] (U V : Set Î±),\\n  IsOpen U â†’ IsCompact U â†’ IsOpen V â†’ IsCompact V â†’ IsCompact (U âˆ© V)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a compact set is included in a measurable set, then so is its closure. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_2} [inst : MeasurableSpace G] [inst_1 : TopologicalSpace G] [inst_2 : BorelSpace G] [inst_3 : Group G]\\n  [inst_4 : TopologicalGroup G] {k s : Set G}, IsCompact k â†’ MeasurableSet s â†’ k âŠ† s â†’ closure k âŠ† s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A subspace is dense iff its topological closure is the entire space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : TopologicalSpace M] [inst_2 : AddCommMonoid M]\\n  [inst_3 : Module R M] [inst_4 : ContinuousConstSMul R M] [inst_5 : ContinuousAdd M] {s : Submodule R M},\\n  Dense â†‘s â†” Submodule.topologicalClosure s = âŠ¤\"},\n {\"role\": \"user\", \"content\": \"The product of two compact spaces is compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : CompactSpace X]\\n  [inst_3 : CompactSpace Y], CompactSpace (X Ã— Y)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The intersection of a compact set and a closed set is a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {X : Type u} [inst : TopologicalSpace X] {s t : Set X}, IsCompact s â†’ IsClosed t â†’ IsCompact (s âˆ© t)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a nonempty locally compact space, there exists a compact set with nonempty interior. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : WeaklyLocallyCompactSpace Î±] [inst_2 : Nonempty Î±],\\n  Nonempty (TopologicalSpace.PositiveCompacts Î±)\"},\n {\"role\": \"user\", \"content\": \"In a `T2Space`, every compact set is closed. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T2Space X] {s : Set X}, IsCompact s â†’ IsClosed s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The intersection of a closed set and a compact set is a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {X : Type u} [inst : TopologicalSpace X] {s t : Set X}, IsCompact t â†’ IsClosed s â†’ IsCompact (s âˆ© t)\"},\n {\"role\": \"user\",\n  \"content\": \"A closed subset of a compact set is a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {X : Type u} [inst : TopologicalSpace X] {s t : Set X}, IsCompact s â†’ IsClosed t â†’ t âŠ† s â†’ IsCompact t\"},\n {\"role\": \"user\", \"content\": \"In a Noetherian space, all sets are compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace.NoetherianSpace Î±] (s : Set Î±), IsCompact s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For any topological space `X`, its one point compactification is a compact space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X)\"},\n {\"role\": \"user\",\n  \"content\": \"In a compact space, the type of closed subsets is compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u} [inst : EMetricSpace Î±] [inst_1 : CompactSpace Î±], CompactSpace (TopologicalSpace.Closeds Î±)\"},\n {\"role\": \"user\", \"content\": \"The underlying topological space is compact.\"},\n {\"role\": \"assistant\",\n  \"content\": \"âˆ€ (self : CompHaus), CompactSpace â†‘self.toTop\"},\n {\"role\": \"user\", \"content\": \"Finite topological spaces are compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {X : Type u} [inst : TopologicalSpace X] [inst_1 : Finite X], CompactSpace X\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If every proper closed subset of a topological space is compact, then the space itself is compact.\"}]"}
{"text":"Every prime that is `1` greater than a multiple of `4` can be expressed as the sum of two squares.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Lagrange's **four squares theorem** for a prime number. Use `Nat.sum_four_squares` instead. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {p : â„•}, Nat.Prime p â†’ âˆƒ a b c d, a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = p\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Note that most of the lemmas about powers of two refer to it as `sq`. \"},\n {\"role\": \"assistant\",\n  \"content\": \"âˆ€ {M : Type u} [inst : Monoid M] (a : M), a ^ 2 = a * a\"},\n {\"role\": \"user\", \"content\": \"**Euler's four-square identity**. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] (a b c d x y z w : R),\\n  (a * x - b * y - c * z - d * w) ^ 2 + (a * y + b * x + c * w - d * z) ^ 2 + (a * z - b * w + c * x + d * y) ^ 2 +\\n      (a * w + b * z - c * y + d * x) ^ 2 =\\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2)\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\", \"content\": \"Set.InjOn Nat.factorization {x | x â‰  0}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"`2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare 2 â†” p % 8 = 1 âˆ¨ p % 8 = 7)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 â‰  3`. \"},\n {\"role\": \"assistant\",\n  \"content\": \"âˆ€ {p n : â„•}, Nat.Prime p â†’ p âˆ£ n â†’ IsSquare (-1) â†’ p % 4 â‰  3\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a finite field of characteristic `2`, all elements are squares. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {F : Type u_3} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 â†’ âˆ€ (a : F), IsSquare a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The special case of Graham's conjecture where all numbers are squarefree. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {n : â„•} (f : â„• â†’ â„•), (âˆ€ k < n, Squarefree (f k)) â†’ Nat.GrahamConjecture n f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"**Euler's four-square identity**, a version for natural numbers. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ (a b c d x y z w : â„•),\\n  Int.natAbs (â†‘a * â†‘x - â†‘b * â†‘y - â†‘c * â†‘z - â†‘d * â†‘w) ^ 2 + Int.natAbs (â†‘a * â†‘y + â†‘b * â†‘x + â†‘c * â†‘w - â†‘d * â†‘z) ^ 2 +\\n        Int.natAbs (â†‘a * â†‘z - â†‘b * â†‘w + â†‘c * â†‘x + â†‘d * â†‘y) ^ 2 +\\n      Int.natAbs (â†‘a * â†‘w + â†‘b * â†‘z - â†‘c * â†‘y + â†‘d * â†‘x) ^ 2 =\\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A prime natural number is prime in `â„¤[i]` if and only if it is `3` mod `4` \"},\n {\"role\": \"assistant\",\n  \"content\": \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], Prime â†‘p â†” p % 4 = 3\"},\n {\"role\": \"user\", \"content\": \"**Four squares theorem** \"},\n {\"role\": \"assistant\",\n  \"content\": \"âˆ€ (n : â„•), âˆƒ a b c d, a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. \"},\n {\"role\": \"assistant\",\n  \"content\": \"âˆ€ {n : â„•}, IsSquare (-1) â†’ âˆƒ x y, n = x ^ 2 + y ^ 2\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every prime that is `1` greater than a multiple of `4` can be expressed as the sum of two squares.\"}]"}
{"text":"The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"The product of the factors is the original number \"},\n {\"role\": \"assistant\",\n  \"content\": \"âˆ€ (n : â„•+), PrimeMultiset.prod (PNat.factorMultiset n) = n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a finite field of characteristic `2`, all elements are squares. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {F : Type u_3} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 â†’ âˆ€ (a : F), IsSquare a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Commutativity of a square is preserved when taking quotients by an ideal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u} {S : Type v} [inst : CommRing R] [inst_1 : CommRing S] {R' : Type u_5} {S' : Type u_6}\\n  [inst_2 : CommRing R'] [inst_3 : CommRing S'] {f : R â†’+* S} {f' : R' â†’+* S'} {g : R â†’+* R'} {g' : S â†’+* S'}\\n  (hfg : RingHom.comp f' g = RingHom.comp g' f) (I : Ideal S'),\\n  let leq := (_ : Ideal.comap f (Ideal.comap g' I) â‰¤ Ideal.comap g (Ideal.comap f' I));\\n  RingHom.comp (Ideal.quotientMap I g' (_ : Ideal.comap g' I â‰¤ Ideal.comap g' I))\\n      (Ideal.quotientMap (Ideal.comap g' I) f\\n        (_ : Ideal.comap f (Ideal.comap g' I) â‰¤ Ideal.comap f (Ideal.comap g' I))) =\\n    RingHom.comp (Ideal.quotientMap I f' (_ : Ideal.comap f' I â‰¤ Ideal.comap f' I))\\n      (Ideal.quotientMap (Ideal.comap f' I) g leq)\"},\n {\"role\": \"user\",\n  \"content\": \"The product of two positive elements is positive. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u} [self : StrictOrderedRing Î±] (a b : Î±), 0 < a â†’ 0 < b â†’ 0 < a * b\"},\n {\"role\": \"user\",\n  \"content\":\n  \"We relate a finite product over primes to an infinite sum over smooth numbers. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u_1} [inst : NormedCommRing R] [inst_1 : CompleteSpace R] {f : â„• â†’ R},\\n  f 1 = 1 â†’\\n    (âˆ€ {m n : â„•}, Nat.Coprime m n â†’ f (m * n) = f m * f n) â†’\\n      (âˆ€ {p : â„•}, Nat.Prime p â†’ Summable fun n => â€–f (p ^ n)â€–) â†’\\n        âˆ€ (N : â„•),\\n          (Summable fun m => â€–f â†‘mâ€–) âˆ§\\n            HasSum (fun m => f â†‘m) (Finset.prod (Nat.primesBelow N) fun p => âˆ‘' (n : â„•), f (p ^ n))\"},\n {\"role\": \"user\", \"content\": \"Multiplication is commutative. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u_5} [self : SeminormedCommRing Î±] (x y : Î±), x * y = y * x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The scalar quadruple product identity, related to the Binet-Cauchy identity. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] (u v w x : Fin 3 â†’ R),\\n  Matrix.dotProduct ((crossProduct u) v) ((crossProduct w) x) =\\n    Matrix.dotProduct u w * Matrix.dotProduct v x - Matrix.dotProduct u x * Matrix.dotProduct v w\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The special case of Graham's conjecture where all numbers are squarefree. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {n : â„•} (f : â„• â†’ â„•), (âˆ€ k < n, Squarefree (f k)) â†’ Nat.GrahamConjecture n f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Representation of a difference of two squares in a commutative ring as a product. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type x} [inst : CommRing R] (a b : R), a * a - b * b = (a + b) * (a - b)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Pythagorean theorem, if-and-if vector inner product form using square roots. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {F : Type u_3} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] {x y : F},\\n  â€–x + yâ€– = Real.sqrt (â€–xâ€– * â€–xâ€– + â€–yâ€– * â€–yâ€–) â†” inner x y = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"role\": \"assistant\",\n  \"content\": \"âˆ€ {m n : â„•}, (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n\"},\n {\"role\": \"user\",\n  \"content\": \"Expressing the product of two polynomials as a double sum. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u} [inst : Semiring R] {p q : Polynomial R},\\n  p * q =\\n    Finset.sum (Polynomial.support p) fun i =>\\n      Polynomial.sum q fun j a => (Polynomial.monomial (i + j)) (Polynomial.coeff p i * a)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The product of two Chebyshev polynomials is the sum of two other Chebyshev polynomials. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ (R : Type u_1) [inst : CommRing R] (m k : â„•),\\n  2 * Polynomial.Chebyshev.T R m * Polynomial.Chebyshev.T R (m + k) =\\n    Polynomial.Chebyshev.T R (2 * m + k) + Polynomial.Chebyshev.T R k\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. \"},\n {\"role\": \"assistant\",\n  \"content\": \"âˆ€ {n : â„•}, IsSquare (-1) â†’ âˆƒ x y, n = x ^ 2 + y ^ 2\"},\n {\"role\": \"user\", \"content\": \"**Four squares theorem** \"},\n {\"role\": \"assistant\",\n  \"content\": \"âˆ€ (n : â„•), âˆƒ a b c d, a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n\"},\n {\"role\": \"user\", \"content\": \"**Euler's four-square identity**. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] (a b c d x y z w : R),\\n  (a * x - b * y - c * z - d * w) ^ 2 + (a * y + b * x + c * w - d * z) ^ 2 + (a * z - b * w + c * x + d * y) ^ 2 +\\n      (a * w + b * z - c * y + d * x) ^ 2 =\\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"**Euler's four-square identity**, a version for natural numbers. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ (a b c d x y z w : â„•),\\n  Int.natAbs (â†‘a * â†‘x - â†‘b * â†‘y - â†‘c * â†‘z - â†‘d * â†‘w) ^ 2 + Int.natAbs (â†‘a * â†‘y + â†‘b * â†‘x + â†‘c * â†‘w - â†‘d * â†‘z) ^ 2 +\\n        Int.natAbs (â†‘a * â†‘z - â†‘b * â†‘w + â†‘c * â†‘x + â†‘d * â†‘y) ^ 2 +\\n      Int.natAbs (â†‘a * â†‘w + â†‘b * â†‘z - â†‘c * â†‘y + â†‘d * â†‘x) ^ 2 =\\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2)\"},\n {\"role\": \"user\",\n  \"content\": \"The sum of two squares is zero iff both elements are zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {x y : Î±}, x * x + y * y = 0 â†” x = 0 âˆ§ y = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares.\"}]"}
{"text":"A ring with all elements idempotent is commutative.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Commuting elements of finite order are closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : Monoid G] {x y : G}, Commute x y â†’ IsOfFinOrder x â†’ IsOfFinOrder y â†’ IsOfFinOrder (x * y)\"},\n {\"role\": \"user\", \"content\": \"An abelian category is idempotent complete. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ (D : Type u_2) [inst : CategoryTheory.Category.{u_3, u_2} D] [inst_1 : CategoryTheory.Abelian D],\\n  CategoryTheory.IsIdempotentComplete D\"},\n {\"role\": \"user\",\n  \"content\": \"Composition of non-unital ring homomorphisms is associative. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u_2} {Î² : Type u_3} {Î³ : Type u_4} [inst : NonUnitalNonAssocSemiring Î±]\\n  [inst_1 : NonUnitalNonAssocSemiring Î²] [inst_2 : NonUnitalNonAssocSemiring Î³] {Î´ : Type u_5}\\n  {x : NonUnitalNonAssocSemiring Î´} (f : Î± â†’â‚™+* Î²) (g : Î² â†’â‚™+* Î³) (h : Î³ â†’â‚™+* Î´),\\n  NonUnitalRingHom.comp (NonUnitalRingHom.comp h g) f = NonUnitalRingHom.comp h (NonUnitalRingHom.comp g f)\"},\n {\"role\": \"user\", \"content\": \"Fields are commutative. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u} [inst : Semiring R], IsField R â†’ âˆ€ (x y : R), x * y = y * x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The additive inverse of one multiplied by an element of a ring is the element's additive\\ninverse. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u} [inst : MulOneClass Î±] [inst_1 : HasDistribNeg Î±] (a : Î±), -1 * a = -a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"An element of a ring multiplied by the additive inverse of one is the element's additive\\ninverse. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u} [inst : MulOneClass Î±] [inst_1 : HasDistribNeg Î±] (a : Î±), a * -1 = -a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A finitely generated idempotent ideal is generated by an idempotent element \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] (I : Ideal R),\\n  Ideal.FG I â†’ (IsIdempotentElem I â†” âˆƒ e, IsIdempotentElem e âˆ§ I = Submodule.span R {e})\"},\n {\"role\": \"user\", \"content\": \"The ring homomorphism is an isometry. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Râ‚ : Type u_5} {Râ‚‚ : Type u_6} [inst : Semiring Râ‚] [inst_1 : Semiring Râ‚‚] [inst_2 : Norm Râ‚] [inst_3 : Norm Râ‚‚]\\n  {Ïƒ : Râ‚ â†’+* Râ‚‚} [self : RingHomIsometric Ïƒ] {x : Râ‚}, â€–Ïƒ xâ€– = â€–xâ€–\"},\n {\"role\": \"user\", \"content\": \"Multiplication is commutative \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î¹ : Type u_1} {A : Î¹ â†’ Type u_2} [inst : AddCommMonoid Î¹] [inst_1 : (i : Î¹) â†’ AddCommMonoid (A i)]\\n  [self : DirectSum.GCommSemiring A] (a b : GradedMonoid A), a * b = b * a\"},\n {\"role\": \"user\", \"content\": \"Multiplication is commutative. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u_5} [self : SeminormedCommRing Î±] (x y : Î±), x * y = y * x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"By definition, a ring isomorphism preserves the additive structure. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {F : Type u_7} {R : outParam (Type u_8)} {S : outParam (Type u_9)} [inst : Mul R] [inst_1 : Add R] [inst_2 : Mul S]\\n  [inst_3 : Add S] [self : RingEquivClass F R S] (f : F) (a b : R), f (a + b) = f a + f b\"},\n {\"role\": \"user\",\n  \"content\": \"Multiplication is commutative in a commutative semigroup. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u_2} [self : StrictOrderedCommRing Î±] (a b : Î±), a * b = b * a\"},\n {\"role\": \"user\", \"content\": \"Equivalence closure is idempotent. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u_1} (r : Î± â†’ Î± â†’ Prop), EqvGen.Setoid (Setoid.Rel (EqvGen.Setoid r)) = EqvGen.Setoid r\"},\n {\"role\": \"user\", \"content\": \"A ring isomorphism sends zero to zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u_4} {S : Type u_5} [inst : NonUnitalNonAssocSemiring R] [inst_1 : NonUnitalNonAssocSemiring S]\\n  (f : R â‰ƒ+* S), f 0 = 0\"},\n {\"role\": \"user\", \"content\": \"A ring isomorphism sends one to one. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u_4} {S : Type u_5} [inst : NonAssocSemiring R] [inst_1 : NonAssocSemiring S] (f : R â‰ƒ+* S), f 1 = 1\"},\n {\"role\": \"user\", \"content\": \"Any element commutes with itself.\"},\n {\"role\": \"assistant\",\n  \"content\": \"âˆ€ {S : Type u_2} [inst : Add S] (a : S), AddCommute a a\"},\n {\"role\": \"user\", \"content\": \"Any element commutes with itself. \"},\n {\"role\": \"assistant\",\n  \"content\": \"âˆ€ {S : Type u_2} [inst : Mul S] (a : S), Commute a a\"},\n {\"role\": \"user\", \"content\": \"A ring isomorphism preserves addition. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u_4} {S : Type u_5} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R â‰ƒ+* S)\\n  (x y : R), e (x + y) = e x + e y\"},\n {\"role\": \"user\", \"content\": \"A ring isomorphism preserves multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u_4} {S : Type u_5} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R â‰ƒ+* S)\\n  (x y : R), e (x * y) = e x * e y\"},\n {\"role\": \"user\",\n  \"content\": \"Multiplication in a boolean ring is idempotent. \"},\n {\"role\": \"assistant\",\n  \"content\": \"âˆ€ {Î± : Type u_4} [self : BooleanRing Î±] (a : Î±), a * a = a\"},\n {\"role\": \"user\",\n  \"content\": \"A ring with all elements idempotent is commutative.\"}]"}
{"text":"There are infinitely many pairs of primes that differ exactly by `2`.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"The only divisors of prime powers are prime powers. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u_1} [inst : CancelCommMonoidWithZero Î±] [dec_irr : (p : Associates Î±) â†’ Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid Î±] [dec : DecidableEq Î±] [dec' : DecidableEq (Associates Î±)] {a p : Associates Î±},\\n  Irreducible p â†’\\n    âˆ€ [inst_2 : (n : â„•) â†’ Decidable (a âˆ£ p ^ n)] {n : â„•} (h : a âˆ£ p ^ n),\\n      a = p ^ Nat.find (_ : âˆƒ n, (fun n => a âˆ£ p ^ n) n)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The finite field `F` has even cardinality iff it has characteristic `2`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {F : Type u_3} [inst : Field F] [inst_1 : Fintype F], ringChar F = 2 â†” Fintype.card F % 2 = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For any positive `k : â„•` there are infinitely many primes `p` such that `p â‰¡ 1 [MOD k]`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {k : â„•}, k â‰  0 â†’ Set.Infinite {p | Nat.Prime p âˆ§ p â‰¡ 1 [MOD k]}\"},\n {\"role\": \"user\",\n  \"content\": \"Infinitely many natural numbers are equal to `d` mod `n`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {n : â„•}, n â‰  0 â†’ âˆ€ (d : â„•), âˆƒá¶  (m : â„•) in Filter.atTop, m â‰¡ d [MOD n]\"},\n {\"role\": \"user\", \"content\": \"The multiplicity of prime `p` in `p` is `1` \"},\n {\"role\": \"assistant\",\n  \"content\": \"âˆ€ {p : â„•}, Nat.Prime p â†’ (Nat.factorization p) p = 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"role\": \"assistant\",\n  \"content\": \"âˆ€ (n : â„•), Nat.factorization n = 0 â†” n = 0 âˆ¨ n = 1\"},\n {\"role\": \"user\",\n  \"content\": \"In a group of exponent two, all elements commute. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], Monoid.exponent G = 2 â†’ âˆ€ (x y : G), x * y = y * x\"},\n {\"role\": \"user\", \"content\": \"`2` is not a factor of an odd natural number. \"},\n {\"role\": \"assistant\", \"content\": \"âˆ€ {m n : â„•}, Odd n â†’ m âˆ£ n â†’ m â‰  2\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"role\": \"assistant\",\n  \"content\": \"âˆ€ {m n : â„•}, (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A prime natural number is prime in `â„¤[i]` if and only if it is `3` mod `4` \"},\n {\"role\": \"assistant\",\n  \"content\": \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], Prime â†‘p â†” p % 4 = 3\"},\n {\"role\": \"user\",\n  \"content\": \"Two (finite) â„¤-bases have the same discriminant. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ (A : Type u) {Î¹ : Type w} [inst : DecidableEq Î¹] [inst_1 : CommRing A] [inst_2 : Fintype Î¹] (b b' : Basis Î¹ â„¤ A),\\n  Algebra.discr â„¤ â‡‘b = Algebra.discr â„¤ â‡‘b'\"},\n {\"role\": \"user\",\n  \"content\": \"In a group of exponent two, every element is its own inverse. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], Monoid.exponent G = 2 â†’ âˆ€ (x : G), xâ»Â¹ = x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"role\": \"assistant\",\n  \"content\": \"âˆ€ {m n : â„•}, (âˆ€ (a : â„•), a âˆ£ m â†” a âˆ£ n) â†” m = n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"`2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p â‰  2 â†’ (IsSquare 2 â†” p % 8 = 1 âˆ¨ p % 8 = 7)\"},\n {\"role\": \"user\", \"content\": \"An inequality involving `2`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u_2} [inst : LinearOrderedField Î±] {a : Î±}, 2 â‰¤ a â†’ (1 - 1 / a)â»Â¹ â‰¤ 2\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\", \"content\": \"Set.InjOn Nat.factorization {x | x â‰  0}\"},\n {\"role\": \"user\",\n  \"content\": \"A prime `p` satisfies `p % 2 = 1` if and only if `p â‰  2`. \"},\n {\"role\": \"assistant\",\n  \"content\": \"âˆ€ {p : â„•} [inst : Fact (Nat.Prime p)], p % 2 = 1 â†” p â‰  2\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a finite field of characteristic `2`, all elements are squares. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {F : Type u_3} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 â†’ âˆ€ (a : F), IsSquare a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"There are infinitely many pairs of primes that differ exactly by `2`.\"}]"}
{"text":"Every finite division ring is a field.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"A subfield is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {K : Type u} [inst : Field K] (s : Subfield K) {x y : K}, x âˆˆ s â†’ y âˆˆ s â†’ x * y âˆˆ s\"},\n {\"role\": \"user\",\n  \"content\": \"An intermediate field is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {K : Type u_1} {L : Type u_2} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\\n  {x y : L}, x âˆˆ S â†’ y âˆˆ S â†’ x * y âˆˆ S\"},\n {\"role\": \"user\",\n  \"content\": \"Any infinite type can be endowed a field structure. \"},\n {\"role\": \"assistant\",\n  \"content\": \"âˆ€ {Î± : Type u} [inst : Infinite Î±], Nonempty (Field Î±)\"},\n {\"role\": \"user\",\n  \"content\": \"A normed division ring is a topological division ring. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u_1} [inst : NormedDivisionRing Î±], TopologicalDivisionRing Î±\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a finite field of characteristic `2`, all elements are squares. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {F : Type u_3} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 â†’ âˆ€ (a : F), IsSquare a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The quotient of a ring by an ideal is a field iff the ideal is maximal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I â†” IsField (R â§¸ I)\"},\n {\"role\": \"user\",\n  \"content\": \"An algebraically closed field is also separably closed. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ (k : Type u) [inst : Field k] [inst_1 : IsAlgClosed k], IsSepClosed k\"},\n {\"role\": \"user\",\n  \"content\": \"All ideals in a division (semi)ring are trivial. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {K : Type u} [inst : DivisionSemiring K] (I : Ideal K), I = âŠ¥ âˆ¨ I = âŠ¤\"},\n {\"role\": \"user\",\n  \"content\": \"A field extension is algebraic if it is finite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ (K : Type u_1) (A : Type u_5) [inst : Field K] [inst_1 : Ring A] [inst_2 : Algebra K A]\\n  [inst_3 : FiniteDimensional K A], Algebra.IsAlgebraic K A\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A finite subgroup of the unit group of an integral domain is cyclic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u_1} {G : Type u_2} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\\n  (f : G â†’* R), Function.Injective â‡‘f â†’ IsCyclic G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A module over a division ring is noetherian if and only if it is finitely generated. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\\n  IsNoetherian K V â†” Module.Finite K V\"},\n {\"role\": \"user\",\n  \"content\": \"A linear ordered field that is a floor ring is archimedean. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ (Î± : Type u_2) [inst : LinearOrderedField Î±] [inst_1 : FloorRing Î±], Archimedean Î±\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A field is perfect if every irreducible polynomial is separable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {K : Type u_1} [inst : Field K] [self : PerfectField K] {f : Polynomial K}, Irreducible f â†’ Polynomial.Separable f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A finite subgroup of the units of an integral domain is cyclic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (S : Subgroup RË£) [inst_2 : Finite â†¥S], IsCyclic â†¥S\"},\n {\"role\": \"user\", \"content\": \"A subfield is closed under division. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {K : Type u} [inst : Field K] (s : Subfield K) {x y : K}, x âˆˆ s â†’ y âˆˆ s â†’ x / y âˆˆ s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A cyclotomic finite extension of a number field is a number field. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ (S : Set â„•+) (K : Type w) (L : Type z) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] [h : NumberField K]\\n  [inst_3 : Finite â†‘S] [inst : IsCyclotomicExtension S K L], NumberField L\"},\n {\"role\": \"user\", \"content\": \"A field is a valuation ring. \"},\n {\"role\": \"assistant\",\n  \"content\": \"âˆ€ (K : Type u) [inst : Field K], ValuationRing K\"},\n {\"role\": \"user\",\n  \"content\": \"An intermediate field is closed under division. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {K : Type u_1} {L : Type u_2} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\\n  {x y : L}, x âˆˆ S â†’ y âˆˆ S â†’ x / y âˆˆ S\"},\n {\"role\": \"user\", \"content\": \"A finite field has prime power cardinality. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u_1} [inst : Fintype Î±] [inst_1 : Field Î±], IsPrimePow (Fintype.card Î±)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A finite domain is a field. See also `littleWedderburn` and `Fintype.divisionRingOfIsDomain`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ (D : Type u_1) [inst : Finite D] [inst : Ring D] [inst_1 : IsDomain D], IsField D\"},\n {\"role\": \"user\", \"content\": \"Every finite division ring is a field.\"}]"}
{"text":"If each of two types can be mapped injectively into the other, then there is a bijection between them.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The dimensions of the domain and range of an injective linear map are equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : Ring K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Vâ‚‚ : Type v'}\\n  [inst_3 : AddCommGroup Vâ‚‚] [inst_4 : Module K Vâ‚‚] {f : V â†’â‚—[K] Vâ‚‚},\\n  Function.Injective â‡‘f â†’ FiniteDimensional.finrank K â†¥(LinearMap.range f) = FiniteDimensional.finrank K V\"},\n {\"role\": \"user\", \"content\": \"An epimorphism is surjective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u_1} {M : Type u_2} {Râ‚‚ : Type u_3} {Mâ‚‚ : Type u_4} [inst : Ring R] [inst_1 : Ring Râ‚‚]\\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommGroup Mâ‚‚] [inst_4 : Module R M] [inst_5 : Module Râ‚‚ Mâ‚‚] {Ï„â‚â‚‚ : R â†’+* Râ‚‚}\\n  [inst_6 : RingHomSurjective Ï„â‚â‚‚] {f : M â†’â‚›â‚—[Ï„â‚â‚‚] Mâ‚‚},\\n  (âˆ€ (u v : Mâ‚‚ â†’â‚—[Râ‚‚] Mâ‚‚ â§¸ LinearMap.range f), LinearMap.comp u f = LinearMap.comp v f â†’ u = v) â†’ LinearMap.range f = âŠ¤\"},\n {\"role\": \"user\",\n  \"content\": \"The induced map from the quotient by the kernel is injective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u} {S : Type v} [inst : CommRing R] [inst_1 : CommRing S] (f : R â†’+* S),\\n  Function.Injective â‡‘(RingHom.kerLift f)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If the equalizer of two morphisms is an epimorphism, then the two morphisms are equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {X Y : C} {f g : X âŸ¶ Y}\\n  [inst_1 : CategoryTheory.Limits.HasEqualizer f g]\\n  [inst_2 : CategoryTheory.Epi (CategoryTheory.Limits.equalizer.Î¹ f g)], f = g\"},\n {\"role\": \"user\",\n  \"content\": \"The two coercions to functions are jointly injective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {E : Sort u_1} {Î± : outParam (Sort u_2)} {Î² : outParam (Sort u_3)} [self : EquivLike E Î± Î²] (e g : E),\\n  EquivLike.coe e = EquivLike.coe g â†’ EquivLike.inv e = EquivLike.inv g â†’ e = g\"},\n {\"role\": \"user\",\n  \"content\": \"Composing with a surjective linear map is injective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u_1} [inst : Semiring R] {M : Type u_2} [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {N : Type u_3}\\n  [inst_3 : AddCommMonoid N] [inst_4 : Module R N] {Î¹ : Type u_7} {Mâ‚‚ : Type u_10} [inst_5 : AddCommMonoid Mâ‚‚]\\n  [inst_6 : Module R Mâ‚‚] (f : Mâ‚‚ â†’â‚—[R] M),\\n  Function.Surjective â‡‘f â†’ Function.Injective fun g => AlternatingMap.compLinearMap g f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A scheme where the children of each set are pairwise disjoint induces an injective map. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î² : Type u_1} {Î± : Type u_2} {A : List Î² â†’ Set Î±},\\n  CantorScheme.Disjoint A â†’ Function.Injective (CantorScheme.inducedMap A).snd\"},\n {\"role\": \"user\",\n  \"content\":\n  \"On a finite-dimensional space, a linear map is injective if and only if it is surjective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] {f : V â†’â‚—[K] V}, Function.Injective â‡‘f â†” Function.Surjective â‡‘f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The map sending a congruence relation to its underlying binary relation is injective. \"},\n {\"role\": \"assistant\",\n  \"content\": \"âˆ€ {M : Type u_1} [inst : Mul M] {c d : Con M}, â‡‘c = â‡‘d â†’ c = d\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In any concrete category, injective morphisms are monomorphisms. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.ConcreteCategory C] {X Y : C}\\n  (f : X âŸ¶ Y), Function.Injective â‡‘f â†’ CategoryTheory.Mono f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The map sending a congruence relation to its underlying equivalence relation is injective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {M : Type u_1} [inst : Mul M] {c d : Con M}, c.toSetoid = d.toSetoid â†’ c = d\"},\n {\"role\": \"user\",\n  \"content\":\n  \"On a finite-dimensional space, an injective linear map is surjective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] {f : V â†’â‚—[K] V}, Function.Injective â‡‘f â†’ Function.Surjective â‡‘f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If two partial homeomorphisms are equivalent, so are their inverses. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²]\\n  {e e' : PartialHomeomorph Î± Î²}, e â‰ˆ e' â†’ PartialHomeomorph.symm e â‰ˆ PartialHomeomorph.symm e'\"},\n {\"role\": \"user\",\n  \"content\": \"An equivalence of categories transfers enough injectives. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {C : Type uâ‚} {D : Type uâ‚‚} [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] [inst_1 : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D]\\n  (e : CategoryTheory.Functor C D) [inst_2 : CategoryTheory.IsEquivalence e]\\n  [inst_3 : CategoryTheory.EnoughInjectives D], CategoryTheory.EnoughInjectives C\"},\n {\"role\": \"user\", \"content\": \"All maps in the diagram are injective \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î¹ : Type u_1} {G : Î¹ â†’ Type u_2} {H : Type u_3} [inst : (i : Î¹) â†’ Group (G i)] [inst_1 : Group H]\\n  {Ï† : (i : Î¹) â†’ H â†’* G i}, Monoid.PushoutI.NormalWord.Transversal Ï† â†’ âˆ€ (i : Î¹), Function.Injective â‡‘(Ï† i)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For functions on finite sets, they are bijections iff they map universes into universes. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : Fintype Î±] [inst_1 : Fintype Î²] (f : Î± â†’ Î²),\\n  Function.Bijective f â†” Multiset.map f Finset.univ.val = Finset.univ.val\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A morphism in `Type u` is an isomorphism if and only if it is bijective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {X Y : Type u} (f : X âŸ¶ Y), CategoryTheory.IsIso f â†” Function.Bijective f\"},\n {\"role\": \"user\", \"content\": \"A monomorphism is injective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u_1} {Râ‚‚ : Type u_3} {M : Type u_9} {Mâ‚‚ : Type u_12} [inst : Semiring R] [inst_1 : Semiring Râ‚‚]\\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid Mâ‚‚] [inst_4 : Module R M] [inst_5 : Module Râ‚‚ Mâ‚‚] {Ï„â‚â‚‚ : R â†’+* Râ‚‚}\\n  {f : M â†’â‚›â‚—[Ï„â‚â‚‚] Mâ‚‚},\\n  (âˆ€ (u v : â†¥(LinearMap.ker f) â†’â‚—[R] M), LinearMap.comp f u = LinearMap.comp f v â†’ u = v) â†’ LinearMap.ker f = âŠ¥\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a bounded linear map is a bijection, then its inverse is also a bounded linear map. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {ð•œ : Type u_1} [inst : NontriviallyNormedField ð•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace ð•œ E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ð•œ F]\\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (e : E â‰ƒâ‚—[ð•œ] F),\\n  Continuous â‡‘e â†’ Continuous â‡‘(LinearEquiv.symm e)\"},\n {\"role\": \"user\",\n  \"content\": \"If a linear map is surjective, then its dual is injective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u} [inst : CommSemiring R] {Mâ‚ : Type v} {Mâ‚‚ : Type v'} [inst_1 : AddCommMonoid Mâ‚] [inst_2 : Module R Mâ‚]\\n  [inst_3 : AddCommMonoid Mâ‚‚] [inst_4 : Module R Mâ‚‚] {f : Mâ‚ â†’â‚—[R] Mâ‚‚},\\n  Function.Surjective â‡‘f â†’ Function.Injective â‡‘(LinearMap.dualMap f)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If each of two types can be mapped injectively into the other, then there is a bijection between them.\"}]"}
{"text":"A finite graph in which every pair of vertices have precisely one common neighbour contains a vertex that is adjacent to all other vertices.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"The complete graph on `n` vertices has `n.choose 2` edges. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {V : Type u} [inst : Fintype V] [inst_1 : DecidableEq V],\\n  Finset.card (SimpleGraph.edgeFinset âŠ¤) = Nat.choose (Fintype.card V) 2\"},\n {\"role\": \"user\", \"content\": \"Any element commutes with itself. \"},\n {\"role\": \"assistant\",\n  \"content\": \"âˆ€ {S : Type u_2} [inst : Mul S] (a : S), Commute a a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"This lemma characterizes discrete topological spaces as those whose singletons are\\nneighbourhoods. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±], DiscreteTopology Î± â†” âˆ€ (x : Î±), nhds x = pure x\"},\n {\"role\": \"user\",\n  \"content\": \"A space with discrete topology is a locally connected space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ (Î± : Type u_3) [inst : TopologicalSpace Î±] [inst_1 : DiscreteTopology Î±], LocallyConnectedSpace Î±\"},\n {\"role\": \"user\", \"content\": \"A finite union of finsets is finite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} (f : Î± â†’ Finset Î²), Set.Finite (Set.range f) â†’ Set.Finite (â‹ƒ a, â†‘(f a))\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A linear equivalence which preserves a finite spanning set must have finite order. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u_1} {M : Type u_2} [inst : CommSemiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {Î¦ : Set M},\\n  Set.Finite Î¦ â†’ Submodule.span R Î¦ = âŠ¤ â†’ âˆ€ {e : M â‰ƒâ‚—[R] M}, Set.MapsTo (â‡‘e) Î¦ Î¦ â†’ IsOfFinOrder e\"},\n {\"role\": \"user\", \"content\": \"Graph is acyclic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {V : Type u} {G : SimpleGraph V}, SimpleGraph.IsTree G â†’ SimpleGraph.IsAcyclic G\"},\n {\"role\": \"user\",\n  \"content\": \"Any graph on `n` vertices has at most `n.choose 2` edges. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {V : Type u} {G : SimpleGraph V} [inst : Fintype â†‘(SimpleGraph.edgeSet G)] [inst_1 : Fintype V]\\n  [inst_2 : DecidableEq V], Finset.card (SimpleGraph.edgeFinset G) â‰¤ Nat.choose (Fintype.card V) 2\"},\n {\"role\": \"user\", \"content\": \"Graph is connected. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {V : Type u} {G : SimpleGraph V}, SimpleGraph.IsTree G â†’ SimpleGraph.Connected G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every finite subset of a linearly independent set is linearly independent. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u_2} {M : Type u_4} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (s : Set M),\\n  LinearIndependent (Î¹ := { x // x âˆˆ s }) R Subtype.val â†’ âˆ€ (t : Finset â†‘s), LinearIndependent R Subtype.val\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The maximum degree in the graph is at least the degree of any particular vertex. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj] (v : V),\\n  SimpleGraph.degree G v â‰¤ SimpleGraph.maxDegree G\"},\n {\"role\": \"user\",\n  \"content\": \"A point with a finite neighborhood has to be isolated. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T1Space X] (x : X) {s : Set X},\\n  s âˆˆ nhds x â†’ Set.Finite s â†’ IsOpen {x}\"},\n {\"role\": \"user\",\n  \"content\": \"A clique is a set of vertices whose induced graph is complete. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u_1} (G : SimpleGraph Î±) {s : Set Î±}, SimpleGraph.IsClique G s â†” SimpleGraph.induce s G = âŠ¤\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every finite subset of an algebraically independent set is algebraically independent. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u_3} {A : Type u_5} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] (s : Set A),\\n  AlgebraicIndependent R Subtype.val â†’ âˆ€ (t : Finset â†‘s), AlgebraicIndependent R Subtype.val\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In an infinite graph, the set of components out of a finite set is nonempty. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {V : Type u} (G : SimpleGraph V) [inst : Infinite V] (K : Finset V), Nonempty (SimpleGraph.ComponentCompl G â†‘K)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The minimum degree in the graph is at most the degree of any particular vertex. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj] (v : V),\\n  SimpleGraph.minDegree G â‰¤ SimpleGraph.degree G v\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A locally finite preconnected infinite graph has at least one end. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {V : Type} (G : SimpleGraph V) [inst : SimpleGraph.LocallyFinite G] [inst : Fact (SimpleGraph.Preconnected G)]\\n  [inst : Infinite V], Set.Nonempty (SimpleGraph.end G)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A finite graph in which every pair of vertices have precisely one common neighbour contains a vertex that is adjacent to all other vertices.\"}]"}
{"text":"The number of partitions with odd parts is equal to the number of partitions with distinct parts.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\", \"content\": \"Set.InjOn Nat.factorization {x | x â‰  0}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The finite field `F` has even cardinality iff it has characteristic `2`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {F : Type u_3} [inst : Field F] [inst_1 : Fintype F], ringChar F = 2 â†” Fintype.card F % 2 = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If x âˆˆ Î± is in 2 elements of a set of sets partitioning Î±, those 2 sets are equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u_1} {c : Set (Set Î±)},\\n  (âˆ€ (a : Î±), âˆƒ! b x, a âˆˆ b) â†’ âˆ€ {x : Î±} {b b' : Set Î±}, b âˆˆ c â†’ x âˆˆ b â†’ b' âˆˆ c â†’ x âˆˆ b' â†’ b = b'\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Conjugacy classes form a partition of G, stated in terms of cardinality. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ (G : Type u) [inst : Group G] [inst_1 : Fintype (ConjClasses G)] [inst_2 : Fintype G]\\n  [inst_3 : (x : ConjClasses G) â†’ Fintype â†‘(ConjClasses.carrier x)],\\n  (Finset.sum Finset.univ fun x => Finset.card (Set.toFinset (ConjClasses.carrier x))) = Fintype.card G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If we can partition a product into subsets that cancel out, then the whole product cancels. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î² : Type u} {Î± : Type v} {s : Finset Î±} {f : Î± â†’ Î²} [inst : CommMonoid Î²] (R : Setoid Î±)\\n  [inst_1 : DecidableRel Setoid.r],\\n  (âˆ€ x âˆˆ s, (Finset.prod (Finset.filter (fun y => y â‰ˆ x) s) fun a => f a) = 1) â†’ (Finset.prod s fun x => f x) = 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Distinct elements of a set of sets partitioning Î± are disjoint. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u_1} {c : Set (Set Î±)}, (âˆ€ (a : Î±), âˆƒ! b x, a âˆˆ b) â†’ Set.PairwiseDisjoint c id\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"role\": \"assistant\",\n  \"content\": \"âˆ€ {m n : â„•}, (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The functions in the partition of unity add up to at most `1` everywhere. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î¹ : Type uÎ¹} {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {H : Type uH}\\n  [inst_2 : TopologicalSpace H] {I : ModelWithCorners â„ E H} {M : Type uM} [inst_3 : TopologicalSpace M]\\n  [inst_4 : ChartedSpace H M] {s : optParam (Set M) Set.univ} (self : SmoothPartitionOfUnity Î¹ I M s) (x : M),\\n  (finsum fun i => (SmoothPartitionOfUnity.toFun s self i) x) â‰¤ 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"role\": \"assistant\",\n  \"content\": \"âˆ€ {m n : â„•}, (âˆ€ (a : â„•), a âˆ£ m â†” a âˆ£ n) â†” m = n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If we can partition a sum into subsets that cancel out, then the whole sum cancels.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î² : Type u} {Î± : Type v} {s : Finset Î±} {f : Î± â†’ Î²} [inst : AddCommMonoid Î²] (R : Setoid Î±)\\n  [inst_1 : DecidableRel Setoid.r],\\n  (âˆ€ x âˆˆ s, (Finset.sum (Finset.filter (fun y => y â‰ˆ x) s) fun a => f a) = 0) â†’ (Finset.sum s fun x => f x) = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The indices of `Quotient.out'` and `IndexedPartition.out` are equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î¹ : Type u_1} {Î± : Type u_2} {s : Î¹ â†’ Set Î±} (hs : IndexedPartition s) (x : IndexedPartition.Quotient hs),\\n  IndexedPartition.index hs (Quotient.out' x) = IndexedPartition.index hs ((IndexedPartition.out hs) x)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The functions in the partition of unity add up to `1` at any point of `s`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î¹ : Type uÎ¹} {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {H : Type uH}\\n  [inst_2 : TopologicalSpace H] {I : ModelWithCorners â„ E H} {M : Type uM} [inst_3 : TopologicalSpace M]\\n  [inst_4 : ChartedSpace H M] {s : optParam (Set M) Set.univ} (self : SmoothPartitionOfUnity Î¹ I M s),\\n  âˆ€ x âˆˆ s, (finsum fun i => (SmoothPartitionOfUnity.toFun s self i) x) = 1\"},\n {\"role\": \"user\",\n  \"content\": \"The convolution of two even functions is also even. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {ð•œ : Type uð•œ} {G : Type uG} {E : Type uE} {E' : Type uE'} {F : Type uF} [inst : NormedAddCommGroup E]\\n  [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedAddCommGroup F] {f : G â†’ E} {g : G â†’ E'} {x : G}\\n  [inst_3 : NontriviallyNormedField ð•œ] [inst_4 : NormedSpace ð•œ E] [inst_5 : NormedSpace ð•œ E'] [inst_6 : NormedSpace ð•œ F]\\n  (L : E â†’L[ð•œ] E' â†’L[ð•œ] F) [inst_7 : MeasurableSpace G] {Î¼ : MeasureTheory.Measure G} [inst_8 : NormedSpace â„ F]\\n  [inst_9 : AddCommGroup G] [inst_10 : MeasureTheory.Measure.IsAddLeftInvariant Î¼]\\n  [inst_11 : MeasureTheory.Measure.IsNegInvariant Î¼] [inst_12 : MeasurableNeg G] [inst_13 : MeasurableAdd G],\\n  (âˆ€áµ (x : G) âˆ‚Î¼, f (-x) = f x) â†’ (âˆ€áµ (x : G) âˆ‚Î¼, g (-x) = g x) â†’ convolution f g L (-x) = convolution f g L x\"},\n {\"role\": \"user\",\n  \"content\": \"All the functions in the partition of unity are nonnegative. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î¹ : Type uÎ¹} {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {H : Type uH}\\n  [inst_2 : TopologicalSpace H] {I : ModelWithCorners â„ E H} {M : Type uM} [inst_3 : TopologicalSpace M]\\n  [inst_4 : ChartedSpace H M] {s : optParam (Set M) Set.univ} (self : SmoothPartitionOfUnity Î¹ I M s) (i : Î¹) (x : M),\\n  0 â‰¤ (SmoothPartitionOfUnity.toFun s self i) x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A sum can be partitioned into a sum of sums, each equivalent under a setoid.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î² : Type u} {Î± : Type v} {s : Finset Î±} {f : Î± â†’ Î²} [inst : AddCommMonoid Î²] (R : Setoid Î±)\\n  [inst_1 : DecidableRel Setoid.r],\\n  (Finset.sum s fun x => f x) =\\n    Finset.sum (Finset.image Quotient.mk'' s) fun xbar =>\\n      Finset.sum (Finset.filter (fun x => âŸ¦xâŸ§ = xbar) s) fun y => f y\"},\n {\"role\": \"user\", \"content\": \"Equivalence classes partition the type. \"},\n {\"role\": \"assistant\",\n  \"content\": \"âˆ€ {Î± : Type u_1} {r : Setoid Î±} (a : Î±), âˆƒ! b x, a âˆˆ b\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The increment partition has energy greater than the original one by a known fixed amount. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u_1} [inst : Fintype Î±] {P : Finpartition Finset.univ} {G : SimpleGraph Î±} {Îµ : â„} [inst_1 : Nonempty Î±]\\n  (hP : Finpartition.IsEquipartition P),\\n  7 â‰¤ Finset.card P.parts â†’\\n    100 < 4 ^ Finset.card P.parts * Îµ ^ 5 â†’\\n      Finset.card P.parts * 16 ^ Finset.card P.parts â‰¤ Fintype.card Î± â†’\\n        Â¬Finpartition.IsUniform P G Îµ â†’\\n          Îµ â‰¤ 1 â†’\\n            â†‘(Finpartition.energy P G) + Îµ ^ 5 / 4 â‰¤ â†‘(Finpartition.energy (SzemerediRegularity.increment hP G Îµ) G)\"},\n {\"role\": \"user\",\n  \"content\": \"A finpartition gives rise to a setoid partition \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u_1} (f : Finpartition Set.univ), Setoid.IsPartition â†‘f.parts\"},\n {\"role\": \"user\", \"content\": \"The partition is supremum-independent \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u_1} [inst : Lattice Î±] [inst_1 : OrderBot Î±] {a : Î±} (self : Finpartition a), Finset.SupIndep self.parts id\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The increment partition has a prescribed (very big) size in terms of the original partition. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u_1} [inst : Fintype Î±] {P : Finpartition Finset.univ} {hP : Finpartition.IsEquipartition P}\\n  {G : SimpleGraph Î±} {Îµ : â„},\\n  Finset.card P.parts * 16 ^ Finset.card P.parts â‰¤ Fintype.card Î± â†’\\n    Â¬Finpartition.IsUniform P G Îµ â†’\\n      Finset.card (SzemerediRegularity.increment hP G Îµ).parts = SzemerediRegularity.stepBound (Finset.card P.parts)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The number of partitions with odd parts is equal to the number of partitions with distinct parts.\"}]"}
{"text":"Every non-empty poset in which every chain has an upper bound contains a maximal element.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"The intrinsic interior of a nonempty convex set is nonempty. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {V : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : NormedSpace â„ V] [inst_2 : FiniteDimensional â„ V] {s : Set V},\\n  Convex â„ s â†’ Set.Nonempty s â†’ Set.Nonempty (intrinsicInterior â„ s)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a (nontrivial) complex Banach algebra, every element has nonempty spectrum. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {A : Type u_2} [inst : NormedRing A] [inst_1 : NormedAlgebra â„‚ A] [inst_2 : CompleteSpace A] [inst_3 : Nontrivial A]\\n  (a : A), Set.Nonempty (spectrum â„‚ a)\"},\n {\"role\": \"user\", \"content\": \"A nonempty convex set is connected. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {E : Type u_3} [inst : AddCommGroup E] [inst_1 : Module â„ E] [inst_2 : TopologicalSpace E]\\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul â„ E] {s : Set E},\\n  Convex â„ s â†’ Set.Nonempty s â†’ IsConnected s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a directed order, the union of two sets is bounded above if and only if both sets are. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u} [inst : Preorder Î±] [inst_1 : IsDirected Î± fun x x_1 => x â‰¤ x_1] {s t : Set Î±},\\n  BddAbove (s âˆª t) â†” BddAbove s âˆ§ BddAbove t\"},\n {\"role\": \"user\",\n  \"content\": \"Any element of a set is more than the set infimum. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u_9} [self : CompleteSemilatticeInf Î±] (s : Set Î±), âˆ€ a âˆˆ s, sInf s â‰¤ a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A sequentially compact set in a uniform space is totally bounded. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {X : Type u_1} [inst : UniformSpace X] {s : Set X}, IsSeqCompact s â†’ TotallyBounded s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any uncountable closed set in a second countable space contains a nonempty perfect subset.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {C : Set Î±} [inst_1 : SecondCountableTopology Î±],\\n  IsClosed C â†’ Â¬Set.Countable C â†’ âˆƒ D, Perfect D âˆ§ Set.Nonempty D âˆ§ D âŠ† C\"},\n {\"role\": \"user\",\n  \"content\": \"Every set open in the upper topology is a upper set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u_1} [inst : Preorder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : Topology.IsUpper Î±] {s : Set Î±},\\n  IsOpen s â†’ IsUpperSet s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a directed order, the union of bounded above sets is bounded above. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u} [inst : Preorder Î±] [inst_1 : IsDirected Î± fun x x_1 => x â‰¤ x_1] {s t : Set Î±},\\n  BddAbove s â†’ BddAbove t â†’ BddAbove (s âˆª t)\"},\n {\"role\": \"user\", \"content\": \"A chain of lifts has an upper bound. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {F : Type u_1} {E : Type u_2} {K : Type u_3} [inst : Field F] [inst_1 : Field E] [inst_2 : Field K]\\n  [inst_3 : Algebra F E] [inst_4 : Algebra F K] (c : Set (IntermediateField.Lifts F E K)),\\n  IsChain (fun x x_1 => x â‰¤ x_1) c â†’ âˆƒ ub, âˆ€ a âˆˆ c, a â‰¤ ub\"},\n {\"role\": \"user\", \"content\": \"A finite set is bounded above.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u} [inst : Preorder Î±] [inst_1 : IsDirected Î± fun x x_1 => x â‰¤ x_1] [inst_2 : Nonempty Î±] {s : Set Î±},\\n  Set.Finite s â†’ BddAbove s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A finite union of sets which are all bounded above is still bounded above.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : Preorder Î±] [inst_1 : IsDirected Î± fun x x_1 => x â‰¤ x_1] [inst_2 : Nonempty Î±]\\n  {I : Set Î²} {S : Î² â†’ Set Î±}, Set.Finite I â†’ (BddAbove (â‹ƒ i âˆˆ I, S i) â†” âˆ€ i âˆˆ I, BddAbove (S i))\"},\n {\"role\": \"user\",\n  \"content\": \"When there is a global maximum, every set is bounded above. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u} [inst : Preorder Î±] [inst_1 : OrderTop Î±] (s : Set Î±), BddAbove s\"},\n {\"role\": \"user\", \"content\": \"Any upper bound is more than the set supremum. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u_1} [self : CompleteBooleanAlgebra Î±] (s : Set Î±) (a : Î±), (âˆ€ b âˆˆ s, b â‰¤ a) â†’ sSup s â‰¤ a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every chain is contained in a maximal chain. This generalizes Hausdorff's maximality principle.\\n\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} {c : Set Î±}, IsChain r c â†’ âˆƒ M, IsMaxChain r M âˆ§ c âŠ† M\"},\n {\"role\": \"user\",\n  \"content\":\n  \"**Zorn's lemma**\\n\\nIf every chain has an upper bound, then there exists a maximal element. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop},\\n  (âˆ€ (c : Set Î±), IsChain r c â†’ âˆƒ ub, âˆ€ a âˆˆ c, r a ub) â†’\\n    (âˆ€ {a b c : Î±}, r a b â†’ r b c â†’ r a c) â†’ âˆƒ m, âˆ€ (a : Î±), r m a â†’ r a m\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every non-empty poset in which every chain has an upper bound contains a maximal element.\"}]"}
{"text":"A group whose automorphism group is cyclic is Abelian.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"Abelian groups have nilpotency class at most one \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_2} [inst : CommGroup G], Group.nilpotencyClass G â‰¤ 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Subgroups of additive torsion-free groups are additively torsion-free.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G], AddMonoid.IsTorsionFree G â†’ âˆ€ (H : AddSubgroup G), AddMonoid.IsTorsionFree â†¥H\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The torsion submonoid of an abelian group equals the torsion subgroup as a submonoid. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ (G : Type u_1) [inst : CommGroup G], CommMonoid.torsion G = (CommGroup.torsion G).toSubmonoid\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A nilpotent Lie algebra with a representation whose trace form is non-singular is Abelian. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ (R : Type u_1) (L : Type u_3) (M : Type u_4) [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L]\\n  [inst_3 : AddCommGroup M] [inst_4 : Module R M] [inst_5 : LieRingModule L M] [inst_6 : LieModule R L M]\\n  [inst_7 : Module.Free R M] [inst_8 : Module.Finite R M] [inst_9 : LieAlgebra.IsNilpotent R L] [inst_10 : IsDomain R]\\n  [inst_11 : IsPrincipalIdealRing R], LinearMap.ker (LieModule.traceForm R L M) = âŠ¥ â†’ IsLieAbelian L\"},\n {\"role\": \"user\", \"content\": \"An abelian category is idempotent complete. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ (D : Type u_2) [inst : CategoryTheory.Category.{u_3, u_2} D] [inst_1 : CategoryTheory.Abelian D],\\n  CategoryTheory.IsIdempotentComplete D\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The right regular action of an additive group on itself is transitive.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_2} [inst : AddGroup G], AddAction.IsPretransitive Gáµƒáµ’áµ– G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Subgroups of additive torsion groups are additive torsion groups.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G], AddMonoid.IsTorsion G â†’ âˆ€ (H : AddSubgroup G), AddMonoid.IsTorsion â†¥H\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A group is finitely generated if and only if it is finitely generated as a monoid. \"},\n {\"role\": \"assistant\",\n  \"content\": \"âˆ€ {G : Type u_3} [inst : Group G], Group.FG G â†” Monoid.FG G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The quotient by the center of a group of cardinality `p ^ 2` is cyclic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {p : â„•} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\\n  Fintype.card G = p ^ 2 â†’ IsCyclic (G â§¸ Subgroup.center G)\"},\n {\"role\": \"user\",\n  \"content\": \"Subgroups of torsion groups are torsion groups. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsion â†¥H\"},\n {\"role\": \"user\", \"content\": \"Finite groups are torsion groups. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The product of group homomorphisms is a group homomorphism if the target is commutative. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : Group Î±] [inst_1 : CommGroup Î²] {f g : Î± â†’ Î²},\\n  IsGroupHom f â†’ IsGroupHom g â†’ IsGroupHom fun a => f a * g a\"},\n {\"role\": \"user\", \"content\": \"A group homomorphism is a monoid homomorphism. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : Group Î±] [inst_1 : Group Î²] {f : Î± â†’ Î²}, IsGroupHom f â†’ IsMonoidHom f\"},\n {\"role\": \"user\", \"content\": \"The torsion subgroup is cylic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ (K : Type u_1) [inst : Field K] [inst_1 : NumberField K], IsCyclic â†¥(NumberField.Units.torsion K)\"},\n {\"role\": \"user\", \"content\": \"Every subgroup of `â„¤` is cyclic. \"},\n {\"role\": \"assistant\",\n  \"content\": \"âˆ€ (H : AddSubgroup â„¤), âˆƒ a, H = AddSubgroup.closure {a}\"},\n {\"role\": \"user\", \"content\": \"Abelian groups are nilpotent \"},\n {\"role\": \"assistant\",\n  \"content\": \"âˆ€ {G : Type u_2} [inst : CommGroup G], Group.IsNilpotent G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A finite subgroup of the units of an integral domain is cyclic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (S : Subgroup RË£) [inst_2 : Finite â†¥S], IsCyclic â†¥S\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is cyclic.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsAddCyclic Î±\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A finite subgroup of the unit group of an integral domain is cyclic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u_1} {G : Type u_2} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\\n  (f : G â†’* R), Function.Injective â‡‘f â†’ IsCyclic G\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is cyclic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p â†’ IsCyclic Î±\"},\n {\"role\": \"user\",\n  \"content\": \"A group whose automorphism group is cyclic is Abelian.\"}]"}
{"text":"A uniformly continuous function of a uniformly continuous function is uniformly continuous.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A constant sequence of functions is uniformly integrable in the probability sense. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_3} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±}\\n  [inst : NormedAddCommGroup Î²] {p : ENNReal} {g : Î± â†’ Î²},\\n  1 â‰¤ p â†’ p â‰  âŠ¤ â†’ MeasureTheory.Memâ„’p g p â†’ MeasureTheory.UniformIntegrable (fun x => g) p Î¼\"},\n {\"role\": \"user\",\n  \"content\": \"A continuous function is bounded above on a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : TopologicalSpace Î²]\\n  [inst_3 : ClosedIciTopology Î±] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\\n  IsCompact K â†’ ContinuousOn f K â†’ BddAbove (f '' K)\"},\n {\"role\": \"user\",\n  \"content\": \"Each function of an equicontinuous family is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î¹ : Type u_1} {X : Type u_3} {Î± : Type u_6} [inst : TopologicalSpace X] [inst_1 : UniformSpace Î±] {F : Î¹ â†’ X â†’ Î±},\\n  Equicontinuous F â†’ âˆ€ (i : Î¹), Continuous (F i)\"},\n {\"role\": \"user\", \"content\": \"A Lipschitz function is uniformly continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoEMetricSpace Î±] [inst_1 : PseudoEMetricSpace Î²] {K : NNReal} {f : Î± â†’ Î²},\\n  LipschitzWith K f â†’ UniformContinuous f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A sequentially continuous function defined on a sequential space is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : SequentialSpace X]\\n  {f : X â†’ Y}, SeqContinuous f â†’ Continuous f\"},\n {\"role\": \"user\", \"content\": \"Uniform continuity of the function \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u_4} {Î² : Type u_5} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] (self : Î± â‰ƒáµ¤ Î²),\\n  UniformContinuous self.toFun\"},\n {\"role\": \"user\", \"content\": \"A constant function is uniformly integrable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_3} {m : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±)\\n  [inst : NormedAddCommGroup Î²] {p : ENNReal} {g : Î± â†’ Î²},\\n  1 â‰¤ p â†’ p â‰  âŠ¤ â†’ MeasureTheory.Memâ„’p g p â†’ MeasureTheory.UnifIntegrable (fun x => g) p Î¼\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A function which can be locally uniformly approximated by continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} [inst_1 : TopologicalSpace Î±],\\n  (âˆ€ (x : Î±), âˆ€ u âˆˆ uniformity Î², âˆƒ t âˆˆ nhds x, âˆƒ F, ContinuousAt F x âˆ§ âˆ€ y âˆˆ t, (f y, F y) âˆˆ u) â†’ Continuous f\"},\n {\"role\": \"user\",\n  \"content\": \"A locally uniform limit of continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\\n  [inst_1 : TopologicalSpace Î±],\\n  TendstoLocallyUniformly F f p â†’ (âˆ€á¶  (n : Î¹) in p, Continuous (F n)) â†’ âˆ€ [inst_2 : Filter.NeBot p], Continuous f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A function which can be uniformly approximated by continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} [inst_1 : TopologicalSpace Î±],\\n  (âˆ€ u âˆˆ uniformity Î², âˆƒ F, Continuous F âˆ§ âˆ€ (y : Î±), (f y, F y) âˆˆ u) â†’ Continuous f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Each function of a uniformly equicontinuous family is uniformly continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î¹ : Type u_1} {Î± : Type u_6} {Î² : Type u_7} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {F : Î¹ â†’ Î² â†’ Î±},\\n  UniformEquicontinuous F â†’ âˆ€ (i : Î¹), UniformContinuous (F i)\"},\n {\"role\": \"user\",\n  \"content\": \"A uniform limit of continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\\n  [inst_1 : TopologicalSpace Î±],\\n  TendstoUniformly F f p â†’ (âˆ€á¶  (n : Î¹) in p, Continuous (F n)) â†’ âˆ€ [inst_2 : Filter.NeBot p], Continuous f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A uniformly continuous function of a uniformly continuous function is uniformly continuous.\"}]"}
{"text":"A uniformly continuous function of a uniformly continuous function is uniformly continuous.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A constant sequence of functions is uniformly integrable in the probability sense. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_3} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±}\\n  [inst : NormedAddCommGroup Î²] {p : ENNReal} {g : Î± â†’ Î²},\\n  1 â‰¤ p â†’ p â‰  âŠ¤ â†’ MeasureTheory.Memâ„’p g p â†’ MeasureTheory.UniformIntegrable (fun x => g) p Î¼\"},\n {\"role\": \"user\",\n  \"content\": \"A continuous function is bounded above on a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : LinearOrder Î±] [inst_1 : TopologicalSpace Î±] [inst_2 : TopologicalSpace Î²]\\n  [inst_3 : ClosedIciTopology Î±] [inst_4 : Nonempty Î±] {f : Î² â†’ Î±} {K : Set Î²},\\n  IsCompact K â†’ ContinuousOn f K â†’ BddAbove (f '' K)\"},\n {\"role\": \"user\",\n  \"content\": \"Each function of an equicontinuous family is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î¹ : Type u_1} {X : Type u_3} {Î± : Type u_6} [inst : TopologicalSpace X] [inst_1 : UniformSpace Î±] {F : Î¹ â†’ X â†’ Î±},\\n  Equicontinuous F â†’ âˆ€ (i : Î¹), Continuous (F i)\"},\n {\"role\": \"user\", \"content\": \"A Lipschitz function is uniformly continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoEMetricSpace Î±] [inst_1 : PseudoEMetricSpace Î²] {K : NNReal} {f : Î± â†’ Î²},\\n  LipschitzWith K f â†’ UniformContinuous f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A sequentially continuous function defined on a sequential space is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : SequentialSpace X]\\n  {f : X â†’ Y}, SeqContinuous f â†’ Continuous f\"},\n {\"role\": \"user\", \"content\": \"Uniform continuity of the function \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u_4} {Î² : Type u_5} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] (self : Î± â‰ƒáµ¤ Î²),\\n  UniformContinuous self.toFun\"},\n {\"role\": \"user\", \"content\": \"A constant function is uniformly integrable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î¹ : Type u_3} {m : MeasurableSpace Î±} (Î¼ : MeasureTheory.Measure Î±)\\n  [inst : NormedAddCommGroup Î²] {p : ENNReal} {g : Î± â†’ Î²},\\n  1 â‰¤ p â†’ p â‰  âŠ¤ â†’ MeasureTheory.Memâ„’p g p â†’ MeasureTheory.UnifIntegrable (fun x => g) p Î¼\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A function which can be locally uniformly approximated by continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} [inst_1 : TopologicalSpace Î±],\\n  (âˆ€ (x : Î±), âˆ€ u âˆˆ uniformity Î², âˆƒ t âˆˆ nhds x, âˆƒ F, ContinuousAt F x âˆ§ âˆ€ y âˆˆ t, (f y, F y) âˆˆ u) â†’ Continuous f\"},\n {\"role\": \"user\",\n  \"content\": \"A locally uniform limit of continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\\n  [inst_1 : TopologicalSpace Î±],\\n  TendstoLocallyUniformly F f p â†’ (âˆ€á¶  (n : Î¹) in p, Continuous (F n)) â†’ âˆ€ [inst_2 : Filter.NeBot p], Continuous f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A function which can be uniformly approximated by continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : UniformSpace Î²] {f : Î± â†’ Î²} [inst_1 : TopologicalSpace Î±],\\n  (âˆ€ u âˆˆ uniformity Î², âˆƒ F, Continuous F âˆ§ âˆ€ (y : Î±), (f y, F y) âˆˆ u) â†’ Continuous f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Each function of a uniformly equicontinuous family is uniformly continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î¹ : Type u_1} {Î± : Type u_6} {Î² : Type u_7} [inst : UniformSpace Î±] [inst_1 : UniformSpace Î²] {F : Î¹ â†’ Î² â†’ Î±},\\n  UniformEquicontinuous F â†’ âˆ€ (i : Î¹), UniformContinuous (F i)\"},\n {\"role\": \"user\",\n  \"content\": \"A uniform limit of continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} {Î¹ : Type x} [inst : UniformSpace Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : Filter Î¹}\\n  [inst_1 : TopologicalSpace Î±],\\n  TendstoUniformly F f p â†’ (âˆ€á¶  (n : Î¹) in p, Continuous (F n)) â†’ âˆ€ [inst_2 : Filter.NeBot p], Continuous f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A uniformly continuous function of a uniformly continuous function is uniformly continuous.\"}]"}
{"text":"A topological space is normal if and only if any two disjoint closed subsets can be separated by a continuous function.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For any topological space `X`, its one point compactification is a compact space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The only open sets in the indiscrete topology are the empty set and the whole space. \"},\n {\"role\": \"assistant\",\n  \"content\": \"âˆ€ {Î± : Type u_1} (U : Set Î±), IsOpen U â†” U = âˆ… âˆ¨ U = Set.univ\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The intersection of two open compact subsets of a quasi-separated space is compact.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u_3} [inst : TopologicalSpace Î±] [self : QuasiSeparatedSpace Î±] (U V : Set Î±),\\n  IsOpen U â†’ IsCompact U â†’ IsOpen V â†’ IsCompact V â†’ IsCompact (U âˆ© V)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The product of a countable family of separable spaces is a separable space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î¹ : Type u_1} {X : Î¹ â†’ Type u_2} [inst : (i : Î¹) â†’ TopologicalSpace (X i)]\\n  [inst_1 : âˆ€ (i : Î¹), TopologicalSpace.SeparableSpace (X i)] [inst_2 : Countable Î¹],\\n  TopologicalSpace.SeparableSpace ((i : Î¹) â†’ X i)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A subspace is dense iff its topological closure is the entire space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : TopologicalSpace M] [inst_2 : AddCommMonoid M]\\n  [inst_3 : Module R M] [inst_4 : ContinuousConstSMul R M] [inst_5 : ContinuousAdd M] {s : Submodule R M},\\n  Dense â†‘s â†” Submodule.topologicalClosure s = âŠ¤\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any two points in a path-connected space must be joined by a continuous path. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {X : Type u_4} [inst : TopologicalSpace X] [self : PathConnectedSpace X] (x y : X), Joined x y\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A linear order with order topology is a completely normal Hausdorff topological space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {X : Type u_1} [inst : LinearOrder X] [inst_1 : TopologicalSpace X] [inst : OrderTopology X], T5Space X\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a separable space, a family of nonempty disjoint open sets is countable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : TopologicalSpace.SeparableSpace Î±] {Î¹ : Type u_1} {s : Î¹ â†’ Set Î±}\\n  {a : Set Î¹}, Set.PairwiseDisjoint a s â†’ (âˆ€ i âˆˆ a, IsOpen (s i)) â†’ (âˆ€ i âˆˆ a, Set.Nonempty (s i)) â†’ Set.Countable a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any continuous function on compact Hausdorff spaces is a closed map. \"},\n {\"role\": \"assistant\",\n  \"content\": \"âˆ€ {X Y : CompHaus} (f : X âŸ¶ Y), IsClosedMap â‡‘f\"},\n {\"role\": \"user\",\n  \"content\": \"The product of two separable spaces is a separable space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] {Î² : Type u_1} [inst : TopologicalSpace Î²]\\n  [inst_1 : TopologicalSpace.SeparableSpace Î±] [inst_2 : TopologicalSpace.SeparableSpace Î²],\\n  TopologicalSpace.SeparableSpace (Î± Ã— Î²)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every two points in a Hausdorff space admit disjoint open neighbourhoods. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {X : Type u} [inst : TopologicalSpace X] [self : T2Space X] (x y : X),\\n  x â‰  y â†’ âˆƒ u v, IsOpen u âˆ§ IsOpen v âˆ§ x âˆˆ u âˆ§ y âˆˆ v âˆ§ Disjoint u v\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two disjoint sets in a normal space admit disjoint neighbourhoods. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {X : Type u} [inst : TopologicalSpace X] [self : NormalSpace X] (s t : Set X),\\n  IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’ SeparatedNhds s t\"},\n {\"role\": \"user\", \"content\": \"Finite topological spaces are compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {X : Type u} [inst : TopologicalSpace X] [inst_1 : Finite X], CompactSpace X\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A regular topological space with second countable topology is a normal space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : RegularSpace X] [inst_2 : SecondCountableTopology X],\\n  NormalSpace X\"},\n {\"role\": \"user\",\n  \"content\": \"A space with discrete topology is a locally connected space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ (Î± : Type u_3) [inst : TopologicalSpace Î±] [inst_1 : DiscreteTopology Î±], LocallyConnectedSpace Î±\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A topological space with discrete topology is separable iff it is countable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u} [t : TopologicalSpace Î±] [inst : DiscreteTopology Î±], TopologicalSpace.SeparableSpace Î± â†” Countable Î±\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A topological space is normal if and only if any two disjoint closed subsets can be separated by a continuous function.\"}]"}
{"text":"If a function from the unit interval to itself has a point of period three, then it has points of all positive periods.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any three points in an orthocentric system are affinely independent. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] {s : Set P},\\n  EuclideanGeometry.OrthocentricSystem s â†’\\n    âˆ€ {p : Fin 3 â†’ P}, Set.range p âŠ† s â†’ Function.Injective p â†’ AffineIndependent â„ p\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `f` sends two periodic points `x` and `y` of positive periods to the same point,\\nthen `x = y`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u_1} {f : Î± â†’ Î±} {x y : Î±} {m n : â„•},\\n  Function.IsPeriodicPt f m x â†’ Function.IsPeriodicPt f n y â†’ 0 < m â†’ 0 < n â†’ f x = f y â†’ x = y\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Right multiplication by a positive element is strictly monotone. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u_2} [self : CanonicallyLinearOrderedSemifield Î±] (a b c : Î±), a < b â†’ 0 < c â†’ a * c < b * c\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If three points are not collinear, the angle between them is positive. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] {pâ‚ pâ‚‚ pâ‚ƒ : P}, Â¬Collinear â„ {pâ‚, pâ‚‚, pâ‚ƒ} â†’ 0 < EuclideanGeometry.angle pâ‚ pâ‚‚ pâ‚ƒ\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a point lies in the affine span of two points, those three points are collinear. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] {pâ‚ pâ‚‚ pâ‚ƒ : P}, pâ‚ âˆˆ affineSpan k {pâ‚‚, pâ‚ƒ} â†’ Collinear k {pâ‚, pâ‚‚, pâ‚ƒ}\"},\n {\"role\": \"user\", \"content\": \"A continuous, periodic function is bounded. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {f : â„ â†’ Î±} {c : â„},\\n  Function.Periodic f c â†’ c â‰  0 â†’ Continuous f â†’ Bornology.IsBounded (Set.range f)\"},\n {\"role\": \"user\",\n  \"content\": \"If the angle between three points is Ï€, they are collinear. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] {pâ‚ pâ‚‚ pâ‚ƒ : P}, EuclideanGeometry.angle pâ‚ pâ‚‚ pâ‚ƒ = Real.pi â†’ Collinear â„ {pâ‚, pâ‚‚, pâ‚ƒ}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If two functions are equal in the relevant interval, their interval integrals are also equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {E : Type u_3} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] {f g : â„ â†’ E} {Î¼ : MeasureTheory.Measure â„}\\n  {a b : â„}, Set.EqOn f g (Set.uIcc a b) â†’ âˆ« (x : â„) in a..b, f x âˆ‚Î¼ = âˆ« (x : â„) in a..b, g x âˆ‚Î¼\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If three points are not collinear, the sine of the angle between them is positive. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] {pâ‚ pâ‚‚ pâ‚ƒ : P},\\n  Â¬Collinear â„ {pâ‚, pâ‚‚, pâ‚ƒ} â†’ 0 < Real.sin (EuclideanGeometry.angle pâ‚ pâ‚‚ pâ‚ƒ)\"},\n {\"role\": \"user\", \"content\": \"Three points are coplanar. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ (k : Type u_1) {V : Type u_2} {P : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] (pâ‚ pâ‚‚ pâ‚ƒ : P), Coplanar k {pâ‚, pâ‚‚, pâ‚ƒ}\"},\n {\"role\": \"user\",\n  \"content\": \"A continuous, periodic function has compact range. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {f : â„ â†’ Î±} {c : â„},\\n  Function.Periodic f c â†’ c â‰  0 â†’ Continuous f â†’ IsCompact (Set.range f)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any three points in a cospherical set are affinely independent. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] {s : Set P},\\n  EuclideanGeometry.Cospherical s â†’\\n    âˆ€ {pâ‚ pâ‚‚ pâ‚ƒ : P}, pâ‚ âˆˆ s â†’ pâ‚‚ âˆˆ s â†’ pâ‚ƒ âˆˆ s â†’ pâ‚ â‰  pâ‚‚ â†’ pâ‚ â‰  pâ‚ƒ â†’ pâ‚‚ â‰  pâ‚ƒ â†’ AffineIndependent â„ ![pâ‚, pâ‚‚, pâ‚ƒ]\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If three points lie in the affine span of two points, the first three points are collinear. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] {pâ‚ pâ‚‚ pâ‚ƒ pâ‚„ pâ‚… : P},\\n  pâ‚ âˆˆ affineSpan k {pâ‚„, pâ‚…} â†’ pâ‚‚ âˆˆ affineSpan k {pâ‚„, pâ‚…} â†’ pâ‚ƒ âˆˆ affineSpan k {pâ‚„, pâ‚…} â†’ Collinear k {pâ‚, pâ‚‚, pâ‚ƒ}\"},\n {\"role\": \"user\", \"content\": \"For the identity map, all points are periodic. \"},\n {\"role\": \"assistant\",\n  \"content\": \"âˆ€ {Î± : Type u_1} (n : â„•) (x : Î±), Function.IsPeriodicPt id n x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A fixed point of `f` is a periodic point of `f` of any prescribed period. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u_1} {f : Î± â†’ Î±} {x : Î±}, Function.IsFixedPt f x â†’ âˆ€ (n : â„•), Function.IsPeriodicPt f n x\"},\n {\"role\": \"user\", \"content\": \"Any point is a periodic point of period `0`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u_1} (f : Î± â†’ Î±) (x : Î±), Function.IsPeriodicPt f 0 x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a function from the unit interval to itself has a point of period three, then it has points of all positive periods.\"}]"}
{"text":"A terminal object in a category is unique up to unique isomorphism.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The (unique) isomorphism between the chosen terminal object and any other terminal object. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"{C : Type uâ‚} â†’\\n  [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] â†’\\n    [inst_1 : CategoryTheory.Limits.HasTerminal C] â†’ {P : C} â†’ CategoryTheory.Limits.IsTerminal P â†’ (âŠ¤_ C â‰… P)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any category with pullbacks and terminal object has binary products. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ (C : Type u) [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Limits.HasTerminal C]\\n  [inst_2 : CategoryTheory.Limits.HasPullbacks C], CategoryTheory.Limits.HasBinaryProducts C\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A strong mono category is a category in which every monomorphism is strong. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [self : CategoryTheory.StrongMonoCategory C] {X Y : C}\\n  (f : X âŸ¶ Y) [inst_1 : CategoryTheory.Mono f], CategoryTheory.StrongMono f\"},\n {\"role\": \"user\",\n  \"content\": \"A nonzero epimorphism from a simple object is an isomorphism. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Abelian C] {X Y : C}\\n  [inst_2 : CategoryTheory.Simple X] {f : X âŸ¶ Y} [inst_3 : CategoryTheory.Epi f], f â‰  0 â†’ CategoryTheory.IsIso f\"},\n {\"role\": \"user\",\n  \"content\": \"A nonzero monomorphism to a simple object is an isomorphism. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] {X Y : C}\\n  [inst_2 : CategoryTheory.Simple Y] {f : X âŸ¶ Y} [inst_3 : CategoryTheory.Mono f], f â‰  0 â†’ CategoryTheory.IsIso f\"},\n {\"role\": \"user\", \"content\": \"The category `D` has isomorphic objects equal \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] {D : Type uâ‚‚} [inst_1 : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D]\\n  {F : CategoryTheory.Functor D C}, CategoryTheory.IsSkeletonOf C D F â†’ CategoryTheory.Skeletal D\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A category in which coimage-image comparisons are all isomorphisms has images. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Preadditive C]\\n  [inst_2 : CategoryTheory.Limits.HasKernels C] [inst_3 : CategoryTheory.Limits.HasCokernels C]\\n  [inst_4 : âˆ€ {X Y : C} (f : X âŸ¶ Y), CategoryTheory.IsIso (CategoryTheory.Abelian.coimageImageComparison f)],\\n  CategoryTheory.Limits.HasImages C\"},\n {\"role\": \"user\",\n  \"content\": \"Any morphism from a terminal object is split mono. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] {X Y : C},\\n  CategoryTheory.Limits.IsTerminal X â†’ âˆ€ (f : X âŸ¶ Y), CategoryTheory.IsSplitMono f\"},\n {\"role\": \"user\", \"content\": \"An abelian category is idempotent complete. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ (D : Type u_2) [inst : CategoryTheory.Category.{u_3, u_2} D] [inst_1 : CategoryTheory.Abelian D],\\n  CategoryTheory.IsIdempotentComplete D\"},\n {\"role\": \"user\",\n  \"content\": \"A category with finite biproducts has a zero object. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ (C : Type u) [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\\n  [inst_2 : CategoryTheory.Limits.HasFiniteBiproducts C], CategoryTheory.Limits.HasZeroObject C\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If there are zero morphisms, any terminal object is a zero object. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], CategoryTheory.Limits.HasZeroObject C\"},\n {\"role\": \"user\", \"content\": \"Any morphism from a terminal object is mono. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] {X Y : C},\\n  CategoryTheory.Limits.IsTerminal X â†’ âˆ€ (f : X âŸ¶ Y), CategoryTheory.Mono f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The subcategory of subterminal objects is an exponential ideal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] [inst_1 : CategoryTheory.Limits.HasFiniteProducts C]\\n  [inst_2 : CategoryTheory.CartesianClosed C], CategoryTheory.ExponentialIdeal (CategoryTheory.subterminalInclusion C)\"},\n {\"role\": \"user\",\n  \"content\": \"Any two morphisms to a terminal object are equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] {X Y : C},\\n  CategoryTheory.Limits.IsTerminal X â†’ âˆ€ (f g : Y âŸ¶ X), f = g\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A terminal object in a category is unique up to unique isomorphism.\"}]"}
{"text":"The complement of the union of two sets is the intersection of their complements.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a compact set is covered by two open sets, then we can cover it by two compact subsets. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T2Space X] {K U V : Set X},\\n  IsCompact K â†’ IsOpen U â†’ IsOpen V â†’ K âŠ† U âˆª V â†’ âˆƒ Kâ‚ Kâ‚‚, IsCompact Kâ‚ âˆ§ IsCompact Kâ‚‚ âˆ§ Kâ‚ âŠ† U âˆ§ Kâ‚‚ âŠ† V âˆ§ K = Kâ‚ âˆª Kâ‚‚\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a directed order, the union of two sets is bounded above if and only if both sets are. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u} [inst : Preorder Î±] [inst_1 : IsDirected Î± fun x x_1 => x â‰¤ x_1] {s t : Set Î±},\\n  BddAbove (s âˆª t) â†” BddAbove s âˆ§ BddAbove t\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The supremum of two subspaces is equal to the span of their union. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  (S T : Set (Projectivization K V)),\\n  Projectivization.Subspace.span (S âˆª T) = Projectivization.Subspace.span S âŠ” Projectivization.Subspace.span T\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The union of all sets in a compact exhaustion equals the entire space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {X : Type u_4} [inst : TopologicalSpace X] (self : CompactExhaustion X),\\n  â‹ƒ n, CompactExhaustion.toFun self n = Set.univ\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a codirected order, the union of two sets is bounded below if and only if both sets are. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u} [inst : Preorder Î±] [inst_1 : IsDirected Î± fun x x_1 => x â‰¥ x_1] {s t : Set Î±},\\n  BddBelow (s âˆª t) â†” BddBelow s âˆ§ BddBelow t\"},\n {\"role\": \"user\",\n  \"content\": \"The span of a union of sets is the sup of their spans. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ (k : Type u_1) (V : Type u_2) {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [S : AddTorsor V P] (s t : Set P), affineSpan k (s âˆª t) = affineSpan k s âŠ” affineSpan k t\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The intersection of a disjoint covering by two open sets of a clopen set will be clopen. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {X : Type u} [inst : TopologicalSpace X] {s a b : Set X},\\n  IsClopen s â†’ s âŠ† a âˆª b â†’ IsOpen a â†’ IsOpen b â†’ Disjoint a b â†’ IsClopen (s âˆ© a)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If two sets intersect, the diameter of the union is bounded by the sum of the diameters. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s t : Set Î±},\\n  Set.Nonempty (s âˆ© t) â†’ Metric.diam (s âˆª t) â‰¤ Metric.diam s + Metric.diam t\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The set difference of a compact set and an open set is a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {X : Type u} [inst : TopologicalSpace X] {s t : Set X}, IsCompact s â†’ IsOpen t â†’ IsCompact (s \\\\ t)\"},\n {\"role\": \"user\",\n  \"content\": \"The disjoint union of two compact spaces is compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : CompactSpace X]\\n  [inst_3 : CompactSpace Y], CompactSpace (X âŠ• Y)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The intersection of a preperfect set and an open set is preperfect. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {C U : Set Î±}, Preperfect C â†’ IsOpen U â†’ Preperfect (U âˆ© C)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The cardinality of a union is at most the sum of the cardinalities\\nof the two sets. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u} (S T : Set Î±), Cardinal.mk â†‘(S âˆª T) â‰¤ Cardinal.mk â†‘S + Cardinal.mk â†‘T\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If two sets belong to a filter, then their intersection belongs to the filter as well. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u_1} (self : Filter Î±) {x y : Set Î±}, x âˆˆ self.sets â†’ y âˆˆ self.sets â†’ x âˆ© y âˆˆ self.sets\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The intersection of a closed set and a compact set is a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {X : Type u} [inst : TopologicalSpace X] {s t : Set X}, IsCompact t â†’ IsClosed s â†’ IsCompact (s âˆ© t)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The indicator of a disjoint union of two sets is the sum of the indicators of the sets. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u_1} {E : Type u_2} {m0 : MeasurableSpace Î±} {p : ENNReal} {Î¼ : MeasureTheory.Measure Î±}\\n  [inst : NormedAddCommGroup E] {s t : Set Î±} (hs : MeasurableSet s) (ht : MeasurableSet t) (hÎ¼s : â†‘â†‘Î¼ s â‰  âŠ¤)\\n  (hÎ¼t : â†‘â†‘Î¼ t â‰  âŠ¤),\\n  s âˆ© t = âˆ… â†’\\n    âˆ€ (c : E),\\n      MeasureTheory.indicatorConstLp p (_ : MeasurableSet (s âˆª t)) (_ : â†‘â†‘Î¼ (s âˆª t) â‰  âŠ¤) c =\\n        MeasureTheory.indicatorConstLp p hs hÎ¼s c + MeasureTheory.indicatorConstLp p ht hÎ¼t c\"},\n {\"role\": \"user\", \"content\": \"The union of two bounded sets is bounded. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {ð•œ : Type u_1} {E : Type u_3} [inst : SeminormedRing ð•œ] [inst_1 : SMul ð•œ E] [inst_2 : Zero E]\\n  [inst_3 : TopologicalSpace E] {sâ‚ sâ‚‚ : Set E},\\n  Bornology.IsVonNBounded ð•œ sâ‚ â†’ Bornology.IsVonNBounded ð•œ sâ‚‚ â†’ Bornology.IsVonNBounded ð•œ (sâ‚ âˆª sâ‚‚)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The intersection of a compact set and a closed set is a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {X : Type u} [inst : TopologicalSpace X] {s t : Set X}, IsCompact s â†’ IsClosed t â†’ IsCompact (s âˆ© t)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The complement of a set has the same frontier as the original set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] (s : Set Î±), frontier sá¶œ = frontier s\"},\n {\"role\": \"user\", \"content\": \"The complement of a closed set is an open set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {s : Set Î±} [self : IsClosed s], IsOpen sá¶œ\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The complement of the union of two sets is the intersection of their complements.\"}]"}
{"text":"The sum of the cubes of two positive integers is never equal to the cube of a third integer.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If the angle between three points is `-Ï€ / 2`, the first two points are not equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank â„ V = 2)] [inst_4 : Module.Oriented â„ V (Fin 2)]\\n  {pâ‚ pâ‚‚ pâ‚ƒ : P}, EuclideanGeometry.oangle pâ‚ pâ‚‚ pâ‚ƒ = â†‘(-Real.pi / 2) â†’ pâ‚ â‰  pâ‚‚\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If the sign of the angle between three points is nonzero, the first two points are not\\nequal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank â„ V = 2)] [inst_4 : Module.Oriented â„ V (Fin 2)]\\n  {pâ‚ pâ‚‚ pâ‚ƒ : P}, Real.Angle.sign (EuclideanGeometry.oangle pâ‚ pâ‚‚ pâ‚ƒ) â‰  0 â†’ pâ‚ â‰  pâ‚‚\"},\n {\"role\": \"user\", \"content\": \"A sort of triangle inequality. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u_2} [inst : LinearOrder Î±] [inst_1 : LocallyFiniteOrder Î±] {a b c : Î±},\\n  Finset.uIcc a c âŠ† Finset.uIcc a b âˆª Finset.uIcc b c\"},\n {\"role\": \"user\",\n  \"content\": \"The n-th harmonic number is not an integer for n â‰¥ 2. \"},\n {\"role\": \"assistant\",\n  \"content\": \"âˆ€ {n : â„•}, 2 â‰¤ n â†’ Â¬Rat.isInt (harmonic n) = true\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If the sign of the angle between three points is positive, the last two points are not\\nequal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank â„ V = 2)] [inst_4 : Module.Oriented â„ V (Fin 2)]\\n  {pâ‚ pâ‚‚ pâ‚ƒ : P}, Real.Angle.sign (EuclideanGeometry.oangle pâ‚ pâ‚‚ pâ‚ƒ) = 1 â†’ pâ‚ƒ â‰  pâ‚‚\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If the sign of the angle between three points is negative, the first two points are not\\nequal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank â„ V = 2)] [inst_4 : Module.Oriented â„ V (Fin 2)]\\n  {pâ‚ pâ‚‚ pâ‚ƒ : P}, Real.Angle.sign (EuclideanGeometry.oangle pâ‚ pâ‚‚ pâ‚ƒ) = -1 â†’ pâ‚ â‰  pâ‚‚\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If the angle between three points is `-Ï€ / 2`, the first and third points are not equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank â„ V = 2)] [inst_4 : Module.Oriented â„ V (Fin 2)]\\n  {pâ‚ pâ‚‚ pâ‚ƒ : P}, EuclideanGeometry.oangle pâ‚ pâ‚‚ pâ‚ƒ = â†‘(-Real.pi / 2) â†’ pâ‚ â‰  pâ‚ƒ\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If the angle between three points is `Ï€ / 2`, the first two points are not equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank â„ V = 2)] [inst_4 : Module.Oriented â„ V (Fin 2)]\\n  {pâ‚ pâ‚‚ pâ‚ƒ : P}, EuclideanGeometry.oangle pâ‚ pâ‚‚ pâ‚ƒ = â†‘(Real.pi / 2) â†’ pâ‚ â‰  pâ‚‚\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If the angle between three points is nonzero, the first two points are not equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank â„ V = 2)] [inst_4 : Module.Oriented â„ V (Fin 2)]\\n  {pâ‚ pâ‚‚ pâ‚ƒ : P}, EuclideanGeometry.oangle pâ‚ pâ‚‚ pâ‚ƒ â‰  0 â†’ pâ‚ â‰  pâ‚‚\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If the angle between three points is `Ï€`, the first and third points are not equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank â„ V = 2)] [inst_4 : Module.Oriented â„ V (Fin 2)]\\n  {pâ‚ pâ‚‚ pâ‚ƒ : P}, EuclideanGeometry.oangle pâ‚ pâ‚‚ pâ‚ƒ = â†‘Real.pi â†’ pâ‚ â‰  pâ‚ƒ\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If the angle between three points is `Ï€`, the first two points are not equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank â„ V = 2)] [inst_4 : Module.Oriented â„ V (Fin 2)]\\n  {pâ‚ pâ‚‚ pâ‚ƒ : P}, EuclideanGeometry.oangle pâ‚ pâ‚‚ pâ‚ƒ = â†‘Real.pi â†’ pâ‚ â‰  pâ‚‚\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If the angle between three points is nonzero, the first and third points are not equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank â„ V = 2)] [inst_4 : Module.Oriented â„ V (Fin 2)]\\n  {pâ‚ pâ‚‚ pâ‚ƒ : P}, EuclideanGeometry.oangle pâ‚ pâ‚‚ pâ‚ƒ â‰  0 â†’ pâ‚ â‰  pâ‚ƒ\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If the angle between three points is `Ï€ / 2`, the first and third points are not equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank â„ V = 2)] [inst_4 : Module.Oriented â„ V (Fin 2)]\\n  {pâ‚ pâ‚‚ pâ‚ƒ : P}, EuclideanGeometry.oangle pâ‚ pâ‚‚ pâ‚ƒ = â†‘(Real.pi / 2) â†’ pâ‚ â‰  pâ‚ƒ\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If the sign of the angle between three points is positive, the first two points are not\\nequal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank â„ V = 2)] [inst_4 : Module.Oriented â„ V (Fin 2)]\\n  {pâ‚ pâ‚‚ pâ‚ƒ : P}, Real.Angle.sign (EuclideanGeometry.oangle pâ‚ pâ‚‚ pâ‚ƒ) = 1 â†’ pâ‚ â‰  pâ‚‚\"},\n {\"role\": \"user\",\n  \"content\": \"There are no perfect squares strictly between mÂ² and (m+1)Â² \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {n m : â„•}, m * m < n â†’ n < (m + 1) * (m + 1) â†’ Â¬âˆƒ t, t * t = n\"},\n {\"role\": \"user\",\n  \"content\": \"The sum of two squares is zero iff both elements are zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {x y : Î±}, x * x + y * y = 0 â†” x = 0 âˆ§ y = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The sum of the cubes of two positive integers is never equal to the cube of a third integer.\"}]"}
{"text":"If every element of a group `G` has order `2`, then every pair of elements of `G` commutes.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `a` commutes with both `b` and `c`, then it commutes with their sum.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {S : Type u_2} [inst : AddSemigroup S] {a b c : S}, AddCommute a b â†’ AddCommute a c â†’ AddCommute a (b + c)\"},\n {\"role\": \"user\",\n  \"content\": \"A normal element of a star monoid commutes with its adjoint. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u_1} [inst : Mul R] [inst_1 : Star R] {x : R} [self : IsStarNormal x], Commute (star x) x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ (G : Type u_1) [inst : Group G] [inst_1 : Finite â†‘(commutatorSet G)], Finite â†¥(commutator G)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The composition of two group homomorphisms is a group homomorphism. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : Group Î±] [inst_1 : Group Î²] {f : Î± â†’ Î²},\\n  IsGroupHom f â†’ âˆ€ {Î³ : Type u_1} [inst_2 : Group Î³] {g : Î² â†’ Î³}, IsGroupHom g â†’ IsGroupHom (g âˆ˜ f)\"},\n {\"role\": \"user\",\n  \"content\": \"The center of a group acts commutatively on that group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], SMulCommClass G (â†¥(Subgroup.center G)) G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Commuting elements of finite additive order are closed under addition.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : AddMonoid G] {x y : G},\\n  AddCommute x y â†’ IsOfFinAddOrder x â†’ IsOfFinAddOrder y â†’ IsOfFinAddOrder (x + y)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `a` commutes with both `b` and `c`, then it commutes with their product. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {S : Type u_2} [inst : Semigroup S] {a b c : S}, Commute a b â†’ Commute a c â†’ Commute a (b * c)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If both `a` and `b` commute with `c`, then their product commutes with `c`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {S : Type u_2} [inst : Semigroup S] {a b c : S}, Commute a c â†’ Commute b c â†’ Commute (a * b) c\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Self-adjoint elements commute if and only if their product is self-adjoint. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u_3} [inst : Mul R] [inst_1 : StarMul R] {x y : R},\\n  IsSelfAdjoint x â†’ IsSelfAdjoint y â†’ (Commute x y â†” IsSelfAdjoint (x * y))\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If both `a` and `b` commute with `c`, then their product commutes with `c`.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {S : Type u_2} [inst : AddSemigroup S] {a b c : S}, AddCommute a c â†’ AddCommute b c â†’ AddCommute (a + b) c\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If an element in a group has order two, then it is its own inverse. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {x : G}, orderOf x = 2 â†’ xâ»Â¹ = x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Commuting elements of finite order are closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : Monoid G] {x y : G}, Commute x y â†’ IsOfFinOrder x â†’ IsOfFinOrder y â†’ IsOfFinOrder (x * y)\"},\n {\"role\": \"user\",\n  \"content\": \"If `a` commutes with `b`, then `b` commutes with `a`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {S : Type u_2} [inst : Mul S] {a b : S}, Commute a b â†’ Commute b a\"},\n {\"role\": \"user\",\n  \"content\": \"If `a` commutes with `b`, then `b` commutes with `a`.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {S : Type u_2} [inst : Add S] {a b : S}, AddCommute a b â†’ AddCommute b a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If n is odd, then the Dihedral group of order $2n$ has $n(n+3)$ pairs of commuting elements. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {n : â„•}, Odd n â†’ Nat.card { p // Commute p.1 p.2 } = n * (n + 3)\"},\n {\"role\": \"user\",\n  \"content\": \"Elements of disjoint, normal subgroups commute. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (Hâ‚ Hâ‚‚ : Subgroup G),\\n  Subgroup.Normal Hâ‚ â†’ Subgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ Commute x y\"},\n {\"role\": \"user\", \"content\": \"Elements of disjoint, normal subgroups commute.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] (Hâ‚ Hâ‚‚ : AddSubgroup G),\\n  AddSubgroup.Normal Hâ‚ â†’ AddSubgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ AddCommute x y\"},\n {\"role\": \"user\", \"content\": \"Any element commutes with itself. \"},\n {\"role\": \"assistant\",\n  \"content\": \"âˆ€ {S : Type u_2} [inst : Mul S] (a : S), Commute a a\"},\n {\"role\": \"user\", \"content\": \"Any element commutes with itself.\"},\n {\"role\": \"assistant\",\n  \"content\": \"âˆ€ {S : Type u_2} [inst : Add S] (a : S), AddCommute a a\"},\n {\"role\": \"user\",\n  \"content\": \"In a group of exponent two, all elements commute. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], Monoid.exponent G = 2 â†’ âˆ€ (x y : G), x * y = y * x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If every element of a group `G` has order `2`, then every pair of elements of `G` commutes.\"}]"}
{"text":"The product of two consecutive natural numbers is even.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"The sum of two finite adÃ¨les is a finite adÃ¨le. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u_1} {K : Type u_2} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\\n  [inst_3 : Field K] [inst_4 : Algebra R K] [inst_5 : IsFractionRing R K]\\n  {x y : DedekindDomain.ProdAdicCompletions R K},\\n  DedekindDomain.ProdAdicCompletions.IsFiniteAdele x â†’\\n    DedekindDomain.ProdAdicCompletions.IsFiniteAdele y â†’ DedekindDomain.ProdAdicCompletions.IsFiniteAdele (x + y)\"},\n {\"role\": \"user\",\n  \"content\": \"The product of non-negative elements is non-negative. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u} [self : OrderedRing Î±] (a b : Î±), 0 â‰¤ a â†’ 0 â‰¤ b â†’ 0 â‰¤ a * b\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a small natural number is divisible by a larger natural number,\\nthe small number is zero. \"},\n {\"role\": \"assistant\", \"content\": \"âˆ€ {a b : â„•}, a âˆ£ b â†’ b < a â†’ b = 0\"},\n {\"role\": \"user\",\n  \"content\": \"The product of two finite adÃ¨les is a finite adÃ¨le. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u_1} {K : Type u_2} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\\n  [inst_3 : Field K] [inst_4 : Algebra R K] [inst_5 : IsFractionRing R K]\\n  {x y : DedekindDomain.ProdAdicCompletions R K},\\n  DedekindDomain.ProdAdicCompletions.IsFiniteAdele x â†’\\n    DedekindDomain.ProdAdicCompletions.IsFiniteAdele y â†’ DedekindDomain.ProdAdicCompletions.IsFiniteAdele (x * y)\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\", \"content\": \"Set.InjOn Nat.factorization {x | x â‰  0}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two positive naturals are equal if their prime padic valuations are equal \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ (a b : â„•), a â‰  0 â†’ b â‰  0 â†’ (a = b â†” âˆ€ (p : â„•), Nat.Prime p â†’ padicValNat p a = padicValNat p b)\"},\n {\"role\": \"user\", \"content\": \"the condition on the two integers \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {n : â„¤} (self : CochainComplex.HomComplex.Triplet n), self.p + n = self.q\"},\n {\"role\": \"user\",\n  \"content\": \"A natural number is odd iff it has residue `1` or `3` mod `4`\"},\n {\"role\": \"assistant\",\n  \"content\": \"âˆ€ {n : â„•}, n % 2 = 1 â†” n % 4 = 1 âˆ¨ n % 4 = 3\"},\n {\"role\": \"user\", \"content\": \"A product of finite numbers is still finite \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î¹ : Type u_1} {R : Type u_8} [inst : CommMonoidWithZero R] [inst_1 : NoZeroDivisors R] [inst_2 : Nontrivial R]\\n  [inst_3 : DecidableEq R] [inst_4 : LT R] {s : Finset Î¹} {f : Î¹ â†’ WithTop R},\\n  (âˆ€ i âˆˆ s, f i â‰  âŠ¤) â†’ (Finset.prod s fun i => f i) < âŠ¤\"},\n {\"role\": \"user\", \"content\": \"`2` is not a factor of an odd natural number. \"},\n {\"role\": \"assistant\", \"content\": \"âˆ€ {m n : â„•}, Odd n â†’ m âˆ£ n â†’ m â‰  2\"},\n {\"role\": \"user\",\n  \"content\": \"The product of two positive elements is positive. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u} [self : StrictOrderedRing Î±] (a b : Î±), 0 < a â†’ 0 < b â†’ 0 < a * b\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"role\": \"assistant\",\n  \"content\": \"âˆ€ {m n : â„•}, (âˆ€ (a : â„•), a âˆ£ m â†” a âˆ£ n) â†” m = n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2\"},\n {\"role\": \"user\",\n  \"content\": \"The convolution of two even functions is also even. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {ð•œ : Type uð•œ} {G : Type uG} {E : Type uE} {E' : Type uE'} {F : Type uF} [inst : NormedAddCommGroup E]\\n  [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedAddCommGroup F] {f : G â†’ E} {g : G â†’ E'} {x : G}\\n  [inst_3 : NontriviallyNormedField ð•œ] [inst_4 : NormedSpace ð•œ E] [inst_5 : NormedSpace ð•œ E'] [inst_6 : NormedSpace ð•œ F]\\n  (L : E â†’L[ð•œ] E' â†’L[ð•œ] F) [inst_7 : MeasurableSpace G] {Î¼ : MeasureTheory.Measure G} [inst_8 : NormedSpace â„ F]\\n  [inst_9 : AddCommGroup G] [inst_10 : MeasureTheory.Measure.IsAddLeftInvariant Î¼]\\n  [inst_11 : MeasureTheory.Measure.IsNegInvariant Î¼] [inst_12 : MeasurableNeg G] [inst_13 : MeasurableAdd G],\\n  (âˆ€áµ (x : G) âˆ‚Î¼, f (-x) = f x) â†’ (âˆ€áµ (x : G) âˆ‚Î¼, g (-x) = g x) â†’ convolution f g L (-x) = convolution f g L x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"role\": \"assistant\",\n  \"content\": \"âˆ€ {m n : â„•}, (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n\"},\n {\"role\": \"user\",\n  \"content\": \"The product of two consecutive natural numbers is even.\"}]"}
{"text":"Every index 2 subgroup of a group is normal.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"Subgroups of torsion groups are torsion groups. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsion â†¥H\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The normal closure of s is the smallest normal subgroup containing s. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {s t : Set G}, IsNormalSubgroup t â†’ s âŠ† t â†’ Group.normalClosure s âŠ† t\"},\n {\"role\": \"user\", \"content\": \"The additive subgroup has finite index \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_2} [inst : AddGroup G] {H : AddSubgroup G} [self : AddSubgroup.FiniteIndex H], AddSubgroup.index H â‰  0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If an element in a group has order two, then it is its own inverse. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {x : G}, orderOf x = 2 â†’ xâ»Â¹ = x\"},\n {\"role\": \"user\",\n  \"content\": \"In a group of exponent two, every element is its own inverse. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], Monoid.exponent G = 2 â†’ âˆ€ (x : G), xâ»Â¹ = x\"},\n {\"role\": \"user\", \"content\": \"A subgroup is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x âˆˆ H â†’ y âˆˆ H â†’ x * y âˆˆ H\"},\n {\"role\": \"user\", \"content\": \"A subgroup is closed under division. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {M : Type u_5} {S : Type u_6} [inst : DivInvMonoid M] [inst_1 : SetLike S M] [hSM : SubgroupClass S M] {H : S}\\n  {x y : M}, x âˆˆ H â†’ y âˆˆ H â†’ x / y âˆˆ H\"},\n {\"role\": \"user\",\n  \"content\": \"In a group of exponent two, all elements commute. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], Monoid.exponent G = 2 â†’ âˆ€ (x y : G), x * y = y * x\"},\n {\"role\": \"user\",\n  \"content\": \"Two subgroups are equal if they have the same elements. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {H K : Subgroup G}, (âˆ€ (x : G), x âˆˆ H â†” x âˆˆ K) â†’ H = K\"},\n {\"role\": \"user\", \"content\": \"A subgroup contains the group's 1. \"},\n {\"role\": \"assistant\",\n  \"content\": \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), 1 âˆˆ H\"},\n {\"role\": \"user\", \"content\": \"Any normal subgroup is either `âŠ¥` or `âŠ¤` \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [self : IsSimpleGroup G] (H : Subgroup G), Subgroup.Normal H â†’ H = âŠ¥ âˆ¨ H = âŠ¤\"},\n {\"role\": \"user\", \"content\": \"The normal closure of a set is a subgroup. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (s : Set G), IsSubgroup (Group.normalClosure s)\"},\n {\"role\": \"user\", \"content\": \"The normal closure of s is a normal subgroup. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} {s : Set G} [inst : Group G], IsNormalSubgroup (Group.normalClosure s)\"},\n {\"role\": \"user\", \"content\": \"Elements of disjoint, normal subgroups commute.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] (Hâ‚ Hâ‚‚ : AddSubgroup G),\\n  AddSubgroup.Normal Hâ‚ â†’ AddSubgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ AddCommute x y\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The topological closure of a normal additive subgroup is normal.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G] (N : AddSubgroup G)\\n  [inst_3 : AddSubgroup.Normal N], AddSubgroup.Normal (AddSubgroup.topologicalClosure N)\"},\n {\"role\": \"user\",\n  \"content\": \"Elements of disjoint, normal subgroups commute. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (Hâ‚ Hâ‚‚ : Subgroup G),\\n  Subgroup.Normal Hâ‚ â†’ Subgroup.Normal Hâ‚‚ â†’ Disjoint Hâ‚ Hâ‚‚ â†’ âˆ€ (x y : G), x âˆˆ Hâ‚ â†’ y âˆˆ Hâ‚‚ â†’ Commute x y\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a group that satisfies the normalizer condition, every maximal subgroup is normal \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G â†’ IsCoatom H â†’ Subgroup.Normal H\"},\n {\"role\": \"user\",\n  \"content\": \"The topological closure of a normal subgroup is normal.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N)\"},\n {\"role\": \"user\", \"content\": \"The subgroup has finite index \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.FiniteIndex H], Subgroup.index H â‰  0\"},\n {\"role\": \"user\", \"content\": \"Every index 2 subgroup of a group is normal.\"}]"}
{"text":"Every free group is torsion free.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"Torsion submonoids are torsion. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : CommMonoid G], Monoid.IsTorsion â†¥(CommMonoid.torsion G)\"},\n {\"role\": \"user\",\n  \"content\": \"The group exponent exists for any bounded torsion group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : Group G],\\n  Monoid.IsTorsion G â†’ Set.Finite (Set.range fun g => orderOf g) â†’ Monoid.ExponentExists G\"},\n {\"role\": \"user\",\n  \"content\": \"Finite additive groups are additive torsion groups.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Finite G], AddMonoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\": \"A nontrivial additive torsion group is not torsion-free.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsion G â†’ Â¬AddMonoid.IsTorsionFree G\"},\n {\"role\": \"user\",\n  \"content\": \"Additive torsion groups are closed under extensions.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} {H : Type u_2} [inst : AddGroup G] {N : AddSubgroup G} [inst_1 : AddGroup H] {f : G â†’+ H},\\n  N = AddMonoidHom.ker f â†’ AddMonoid.IsTorsion H â†’ AddMonoid.IsTorsion â†¥N â†’ AddMonoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Subgroups of additive torsion groups are additive torsion groups.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G], AddMonoid.IsTorsion G â†’ âˆ€ (H : AddSubgroup G), AddMonoid.IsTorsion â†¥H\"},\n {\"role\": \"user\",\n  \"content\": \"If a group exponent exists, the group is torsion. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], Monoid.ExponentExists G â†’ Monoid.IsTorsion G\"},\n {\"role\": \"user\", \"content\": \"The torsion subgroup is cylic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ (K : Type u_1) [inst : Field K] [inst_1 : NumberField K], IsCyclic â†¥(NumberField.Units.torsion K)\"},\n {\"role\": \"user\",\n  \"content\": \"A nontrivial torsion-free additive group is not torsion.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsionFree G â†’ Â¬AddMonoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Quotienting a group by its additive torsion subgroup yields an additive torsion free group.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ (G : Type u_1) [inst : AddCommGroup G], AddMonoid.IsTorsionFree (G â§¸ AddCommGroup.torsion G)\"},\n {\"role\": \"user\",\n  \"content\": \"A nontrivial torsion group is not torsion-free. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G â†’ Â¬Monoid.IsTorsionFree G\"},\n {\"role\": \"user\",\n  \"content\": \"Subgroups of torsion groups are torsion groups. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsion â†¥H\"},\n {\"role\": \"user\", \"content\": \"Torsion groups are closed under extensions. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G â†’* H},\\n  N = MonoidHom.ker f â†’ Monoid.IsTorsion H â†’ Monoid.IsTorsion â†¥N â†’ Monoid.IsTorsion G\"},\n {\"role\": \"user\", \"content\": \"Finite groups are torsion groups. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Quotienting a group by its torsion subgroup yields a torsion free group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G â§¸ CommGroup.torsion G)\"},\n {\"role\": \"user\",\n  \"content\": \"A nontrivial torsion-free group is not torsion. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G â†’ Â¬Monoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Subgroups of additive torsion-free groups are additively torsion-free.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G], AddMonoid.IsTorsionFree G â†’ âˆ€ (H : AddSubgroup G), AddMonoid.IsTorsionFree â†¥H\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Direct products of additive torsion free groups are torsion free.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î· : Type u_3} {Gs : Î· â†’ Type u_4} [inst : (i : Î·) â†’ AddGroup (Gs i)],\\n  (âˆ€ (i : Î·), AddMonoid.IsTorsionFree (Gs i)) â†’ AddMonoid.IsTorsionFree ((i : Î·) â†’ Gs i)\"},\n {\"role\": \"user\",\n  \"content\": \"Direct products of torsion free groups are torsion free. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î· : Type u_3} {Gs : Î· â†’ Type u_4} [inst : (i : Î·) â†’ Group (Gs i)],\\n  (âˆ€ (i : Î·), Monoid.IsTorsionFree (Gs i)) â†’ Monoid.IsTorsionFree ((i : Î·) â†’ Gs i)\"},\n {\"role\": \"user\",\n  \"content\": \"Subgroups of torsion-free groups are torsion-free. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsionFree â†¥H\"},\n {\"role\": \"user\", \"content\": \"Every free group is torsion free.\"}]"}
{"text":"Every natural number greater than `1` is divisible by a prime number.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"No zero divisors. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u_2} [self : CanonicallyOrderedCommSemiring Î±] {a b : Î±}, a * b = 0 â†’ a = 0 âˆ¨ b = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The only prime divisor of positive prime power `p^k` is `p` itself \"},\n {\"role\": \"assistant\",\n  \"content\": \"âˆ€ {k p : â„•}, k â‰  0 â†’ Nat.Prime p â†’ (p ^ k).primeFactors = {p}\"},\n {\"role\": \"user\",\n  \"content\": \"Exactly `n / p` naturals in `(0, n]` are multiples of `p`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ (n p : â„•), Finset.card (Finset.filter (fun x => p âˆ£ x) (Finset.Ioc 0 n)) = n / p\"},\n {\"role\": \"user\", \"content\": \"The multiplicity of prime `p` in `p` is `1` \"},\n {\"role\": \"assistant\",\n  \"content\": \"âˆ€ {p : â„•}, Nat.Prime p â†’ (Nat.factorization p) p = 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The product of the prime factors of `n` that are less than `N` is an `N`-smooth number. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ (n N : â„•), List.prod (List.filter (fun x => decide (x < N)) (Nat.factors n)) âˆˆ Nat.smoothNumbers N\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For any positive `k : â„•` there are infinitely many primes `p` such that `p â‰¡ 1 [MOD k]`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {k : â„•}, k â‰  0 â†’ Set.Infinite {p | Nat.Prime p âˆ§ p â‰¡ 1 [MOD k]}\"},\n {\"role\": \"user\",\n  \"content\": \"All composite numbers are Fermat pseudoprimes to base 1.\\n\"},\n {\"role\": \"assistant\",\n  \"content\": \"âˆ€ {n : â„•}, 1 < n â†’ Â¬Nat.Prime n â†’ Nat.FermatPsp n 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A natural number `m` divides the sum `n + m` if and only if `m` divides `n`.\"},\n {\"role\": \"assistant\", \"content\": \"âˆ€ {m n : â„•}, m âˆ£ n + m â†” m âˆ£ n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"role\": \"assistant\",\n  \"content\": \"âˆ€ (n : â„•), Nat.factorization n = 0 â†” n = 0 âˆ¨ n = 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A natural number `m` divides the sum `m + n` if and only if `m` divides `n`.\"},\n {\"role\": \"assistant\", \"content\": \"âˆ€ {m n : â„•}, m âˆ£ m + n â†” m âˆ£ n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"role\": \"assistant\",\n  \"content\": \"âˆ€ {m n : â„•}, (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n\"},\n {\"role\": \"user\",\n  \"content\": \"Exactly `n / p` naturals in `[1, n]` are multiples of `p`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ (n p : â„•), Finset.card (Finset.filter (fun e => p âˆ£ e + 1) (Finset.range n)) = n / p\"},\n {\"role\": \"user\",\n  \"content\": \"Infinitely many natural numbers are equal to `d` mod `n`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {n : â„•}, n â‰  0 â†’ âˆ€ (d : â„•), âˆƒá¶  (m : â„•) in Filter.atTop, m â‰¡ d [MOD n]\"},\n {\"role\": \"user\",\n  \"content\": \"The only divisors of prime powers are prime powers. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u_1} [inst : CancelCommMonoidWithZero Î±] [dec_irr : (p : Associates Î±) â†’ Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid Î±] [dec : DecidableEq Î±] [dec' : DecidableEq (Associates Î±)] {a p : Associates Î±},\\n  Irreducible p â†’\\n    âˆ€ [inst_2 : (n : â„•) â†’ Decidable (a âˆ£ p ^ n)] {n : â„•} (h : a âˆ£ p ^ n),\\n      a = p ^ Nat.find (_ : âˆƒ n, (fun n => a âˆ£ p ^ n) n)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A prime natural number is prime in `â„¤[i]` if and only if it is `3` mod `4` \"},\n {\"role\": \"assistant\",\n  \"content\": \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)], Prime â†‘p â†” p % 4 = 3\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"role\": \"assistant\",\n  \"content\": \"âˆ€ {m n : â„•}, (âˆ€ (a : â„•), a âˆ£ m â†” a âˆ£ n) â†” m = n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a small natural number is divisible by a larger natural number,\\nthe small number is zero. \"},\n {\"role\": \"assistant\", \"content\": \"âˆ€ {a b : â„•}, a âˆ£ b â†’ b < a â†’ b = 0\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\", \"content\": \"Set.InjOn Nat.factorization {x | x â‰  0}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every natural number greater than `1` is divisible by a prime number.\"}]"}
{"text":"A finite torsion-free group is trivial","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Quotienting by the torsion submodule gives a torsion-free module. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M],\\n  Submodule.torsion R (M â§¸ Submodule.torsion R M) = âŠ¥\"},\n {\"role\": \"user\",\n  \"content\": \"The group exponent exists for any bounded torsion group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : Group G],\\n  Monoid.IsTorsion G â†’ Set.Finite (Set.range fun g => orderOf g) â†’ Monoid.ExponentExists G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a finite group is the direct product of its Sylow groups, it is nilpotent \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [hG : Group G] [inst : Fintype G],\\n  ((p : { x // x âˆˆ (Fintype.card G).primeFactors }) â†’ (P : Sylow (â†‘p) G) â†’ â†¥â†‘P) â‰ƒ* G â†’ Group.IsNilpotent G\"},\n {\"role\": \"user\",\n  \"content\": \"Additive torsion groups are closed under extensions.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} {H : Type u_2} [inst : AddGroup G] {N : AddSubgroup G} [inst_1 : AddGroup H] {f : G â†’+ H},\\n  N = AddMonoidHom.ker f â†’ AddMonoid.IsTorsion H â†’ AddMonoid.IsTorsion â†¥N â†’ AddMonoid.IsTorsion G\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is simple.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsSimpleAddGroup Î±\"},\n {\"role\": \"user\",\n  \"content\": \"Finite additive groups are additive torsion groups.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Finite G], AddMonoid.IsTorsion G\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is simple. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsSimpleGroup Î±\"},\n {\"role\": \"user\", \"content\": \"A semisimple Abelian Lie algebra is trivial. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ (R : Type u) (L : Type v) [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L]\\n  [inst : LieAlgebra.IsSemisimple R L] [h : IsLieAbelian L], Subsingleton L\"},\n {\"role\": \"user\",\n  \"content\": \"A nontrivial torsion group is not torsion-free. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G â†’ Â¬Monoid.IsTorsionFree G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Direct products of additive torsion free groups are torsion free.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î· : Type u_3} {Gs : Î· â†’ Type u_4} [inst : (i : Î·) â†’ AddGroup (Gs i)],\\n  (âˆ€ (i : Î·), AddMonoid.IsTorsionFree (Gs i)) â†’ AddMonoid.IsTorsionFree ((i : Î·) â†’ Gs i)\"},\n {\"role\": \"user\",\n  \"content\": \"Subgroups of torsion groups are torsion groups. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsion â†¥H\"},\n {\"role\": \"user\",\n  \"content\": \"A nontrivial torsion-free additive group is not torsion.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsionFree G â†’ Â¬AddMonoid.IsTorsion G\"},\n {\"role\": \"user\", \"content\": \"Torsion groups are closed under extensions. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G â†’* H},\\n  N = MonoidHom.ker f â†’ Monoid.IsTorsion H â†’ Monoid.IsTorsion â†¥N â†’ Monoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Subgroups of additive torsion-free groups are additively torsion-free.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G], AddMonoid.IsTorsionFree G â†’ âˆ€ (H : AddSubgroup G), AddMonoid.IsTorsionFree â†¥H\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Quotienting a group by its additive torsion subgroup yields an additive torsion free group.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ (G : Type u_1) [inst : AddCommGroup G], AddMonoid.IsTorsionFree (G â§¸ AddCommGroup.torsion G)\"},\n {\"role\": \"user\",\n  \"content\": \"Direct products of torsion free groups are torsion free. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î· : Type u_3} {Gs : Î· â†’ Type u_4} [inst : (i : Î·) â†’ Group (Gs i)],\\n  (âˆ€ (i : Î·), Monoid.IsTorsionFree (Gs i)) â†’ Monoid.IsTorsionFree ((i : Î·) â†’ Gs i)\"},\n {\"role\": \"user\",\n  \"content\": \"A nontrivial torsion-free group is not torsion. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G â†’ Â¬Monoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Quotienting a group by its torsion subgroup yields a torsion free group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G â§¸ CommGroup.torsion G)\"},\n {\"role\": \"user\",\n  \"content\": \"Subgroups of torsion-free groups are torsion-free. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsionFree â†¥H\"},\n {\"role\": \"user\", \"content\": \"Finite groups are torsion groups. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\"},\n {\"role\": \"user\", \"content\": \"A finite torsion-free group is trivial\"}]"}
{"text":"Every finite division ring is a field.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Quotienting by the torsion submodule gives a torsion-free module. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M],\\n  Submodule.torsion R (M â§¸ Submodule.torsion R M) = âŠ¥\"},\n {\"role\": \"user\",\n  \"content\": \"The group exponent exists for any bounded torsion group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : Group G],\\n  Monoid.IsTorsion G â†’ Set.Finite (Set.range fun g => orderOf g) â†’ Monoid.ExponentExists G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a finite group is the direct product of its Sylow groups, it is nilpotent \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [hG : Group G] [inst : Fintype G],\\n  ((p : { x // x âˆˆ (Fintype.card G).primeFactors }) â†’ (P : Sylow (â†‘p) G) â†’ â†¥â†‘P) â‰ƒ* G â†’ Group.IsNilpotent G\"},\n {\"role\": \"user\",\n  \"content\": \"Additive torsion groups are closed under extensions.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} {H : Type u_2} [inst : AddGroup G] {N : AddSubgroup G} [inst_1 : AddGroup H] {f : G â†’+ H},\\n  N = AddMonoidHom.ker f â†’ AddMonoid.IsTorsion H â†’ AddMonoid.IsTorsion â†¥N â†’ AddMonoid.IsTorsion G\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is simple.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsSimpleAddGroup Î±\"},\n {\"role\": \"user\",\n  \"content\": \"Finite additive groups are additive torsion groups.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] [inst_1 : Finite G], AddMonoid.IsTorsion G\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is simple. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsSimpleGroup Î±\"},\n {\"role\": \"user\", \"content\": \"A semisimple Abelian Lie algebra is trivial. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ (R : Type u) (L : Type v) [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L]\\n  [inst : LieAlgebra.IsSemisimple R L] [h : IsLieAbelian L], Subsingleton L\"},\n {\"role\": \"user\",\n  \"content\": \"A nontrivial torsion group is not torsion-free. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G â†’ Â¬Monoid.IsTorsionFree G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Direct products of additive torsion free groups are torsion free.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î· : Type u_3} {Gs : Î· â†’ Type u_4} [inst : (i : Î·) â†’ AddGroup (Gs i)],\\n  (âˆ€ (i : Î·), AddMonoid.IsTorsionFree (Gs i)) â†’ AddMonoid.IsTorsionFree ((i : Î·) â†’ Gs i)\"},\n {\"role\": \"user\",\n  \"content\": \"Subgroups of torsion groups are torsion groups. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsion â†¥H\"},\n {\"role\": \"user\",\n  \"content\": \"A nontrivial torsion-free additive group is not torsion.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsionFree G â†’ Â¬AddMonoid.IsTorsion G\"},\n {\"role\": \"user\", \"content\": \"Torsion groups are closed under extensions. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G â†’* H},\\n  N = MonoidHom.ker f â†’ Monoid.IsTorsion H â†’ Monoid.IsTorsion â†¥N â†’ Monoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Subgroups of additive torsion-free groups are additively torsion-free.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G], AddMonoid.IsTorsionFree G â†’ âˆ€ (H : AddSubgroup G), AddMonoid.IsTorsionFree â†¥H\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Quotienting a group by its additive torsion subgroup yields an additive torsion free group.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ (G : Type u_1) [inst : AddCommGroup G], AddMonoid.IsTorsionFree (G â§¸ AddCommGroup.torsion G)\"},\n {\"role\": \"user\",\n  \"content\": \"Direct products of torsion free groups are torsion free. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î· : Type u_3} {Gs : Î· â†’ Type u_4} [inst : (i : Î·) â†’ Group (Gs i)],\\n  (âˆ€ (i : Î·), Monoid.IsTorsionFree (Gs i)) â†’ Monoid.IsTorsionFree ((i : Î·) â†’ Gs i)\"},\n {\"role\": \"user\",\n  \"content\": \"A nontrivial torsion-free group is not torsion. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G â†’ Â¬Monoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Quotienting a group by its torsion subgroup yields a torsion free group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G â§¸ CommGroup.torsion G)\"},\n {\"role\": \"user\",\n  \"content\": \"Subgroups of torsion-free groups are torsion-free. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsionFree â†¥H\"},\n {\"role\": \"user\", \"content\": \"Finite groups are torsion groups. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\"},\n {\"role\": \"user\", \"content\": \"A finite torsion-free group is trivial\"}]"}
{"text":"Every finite topological space is compact.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"All hom spaces are finite dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {k G : Type u} [inst : Field k] [inst_1 : Monoid G] (V W : FdRep k G), FiniteDimensional k (V âŸ¶ W)\"},\n {\"role\": \"user\", \"content\": \"A finite space is bounded. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u_4} [inst : Bornology Î±] [inst_1 : Finite Î±], BoundedSpace Î±\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a nonempty locally compact space, there exists a compact set with nonempty interior. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : WeaklyLocallyCompactSpace Î±] [inst_2 : Nonempty Î±],\\n  Nonempty (TopologicalSpace.PositiveCompacts Î±)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A sequentially compact set in a uniform space is totally bounded. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {X : Type u_1} [inst : UniformSpace X] {s : Set X}, IsSeqCompact s â†’ TotallyBounded s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any continuous bijection of compact Hausdorff spaces is an isomorphism. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {X Y : CompHaus} (f : X âŸ¶ Y), Function.Bijective â‡‘f â†’ CategoryTheory.IsIso f\"},\n {\"role\": \"user\",\n  \"content\": \"In a compact space, the type of closed subsets is compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u} [inst : EMetricSpace Î±] [inst_1 : CompactSpace Î±], CompactSpace (TopologicalSpace.Closeds Î±)\"},\n {\"role\": \"user\",\n  \"content\": \"The disjoint union of two compact spaces is compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : CompactSpace X]\\n  [inst_3 : CompactSpace Y], CompactSpace (X âŠ• Y)\"},\n {\"role\": \"user\", \"content\": \"Convex hull of a finite set is compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {E : Type u_3} [inst : AddCommGroup E] [inst_1 : Module â„ E] [inst_2 : TopologicalSpace E]\\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul â„ E] {s : Set E},\\n  Set.Finite s â†’ IsCompact ((convexHull â„) s)\"},\n {\"role\": \"user\", \"content\": \"In a `T2Space`, every compact set is closed. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T2Space X] {s : Set X}, IsCompact s â†’ IsClosed s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every open cover of a paracompact space assumes a locally finite refinement. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {X : Type v} [inst : TopologicalSpace X] [self : ParacompactSpace X] (Î± : Type v) (s : Î± â†’ Set X),\\n  (âˆ€ (a : Î±), IsOpen (s a)) â†’\\n    â‹ƒ a, s a = Set.univ â†’\\n      âˆƒ Î² t, âˆƒ (_ : âˆ€ (b : Î²), IsOpen (t b)) (_ : â‹ƒ b, t b = Set.univ), LocallyFinite t âˆ§ âˆ€ (b : Î²), âˆƒ a, t b âŠ† s a\"},\n {\"role\": \"user\", \"content\": \"The product of two compact spaces is compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : CompactSpace X]\\n  [inst_3 : CompactSpace Y], CompactSpace (X Ã— Y)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `X` is a compact space, then any discrete quotient of `X` is finite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {X : Type u_2} [inst : TopologicalSpace X] (S : DiscreteQuotient X) [inst_1 : CompactSpace X],\\n  Finite (Quotient S.toSetoid)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A measure which is finite on compact sets in a locally compact space is locally finite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u_1} {m0 : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} [inst : TopologicalSpace Î±]\\n  [inst_1 : WeaklyLocallyCompactSpace Î±] [inst_2 : MeasureTheory.IsFiniteMeasureOnCompacts Î¼],\\n  MeasureTheory.IsLocallyFiniteMeasure Î¼\"},\n {\"role\": \"user\", \"content\": \"In a Noetherian space, all sets are compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace.NoetherianSpace Î±] (s : Set Î±), IsCompact s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For any topological space `X`, its one point compactification is a compact space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X)\"},\n {\"role\": \"user\", \"content\": \"A compact discrete space is finite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X] [inst : DiscreteTopology X], Finite X\"},\n {\"role\": \"user\", \"content\": \"The underlying topological space is compact.\"},\n {\"role\": \"assistant\",\n  \"content\": \"âˆ€ (self : CompHaus), CompactSpace â†‘self.toTop\"},\n {\"role\": \"user\", \"content\": \"Finite topological spaces are compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {X : Type u} [inst : TopologicalSpace X] [inst_1 : Finite X], CompactSpace X\"},\n {\"role\": \"user\", \"content\": \"Every finite topological space is compact.\"}]"}
{"text":"Every surjective homomorphism from a finitely generated free group to itself is injective.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The natural homomorphism from a monoid to its quotient by a congruence relation is\\nsurjective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {M : Type u_1} [inst : MulOneClass M] {c : Con M}, Function.Surjective â‡‘(Con.mk' c)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any continuous bijection of compact Hausdorff spaces is an isomorphism. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {X Y : CompHaus} (f : X âŸ¶ Y), Function.Bijective â‡‘f â†’ CategoryTheory.IsIso f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"On a finite-dimensional space, a linear map is injective if and only if it is surjective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] {f : V â†’â‚—[K] V}, Function.Injective â‡‘f â†” Function.Surjective â‡‘f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Composing with a family of surjective linear maps is injective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type uR} {Î¹ : Type uÎ¹} {Mâ‚ : Î¹ â†’ Type vâ‚} {Mâ‚‚ : Type vâ‚‚} [inst : Semiring R]\\n  [inst_1 : (i : Î¹) â†’ AddCommMonoid (Mâ‚ i)] [inst_2 : AddCommMonoid Mâ‚‚] [inst_3 : (i : Î¹) â†’ Module R (Mâ‚ i)]\\n  [inst_4 : Module R Mâ‚‚] {Mâ‚' : Î¹ â†’ Type u_1} [inst_5 : (i : Î¹) â†’ AddCommMonoid (Mâ‚' i)]\\n  [inst_6 : (i : Î¹) â†’ Module R (Mâ‚' i)] (f : (i : Î¹) â†’ Mâ‚ i â†’â‚—[R] Mâ‚' i),\\n  (âˆ€ (i : Î¹), Function.Surjective â‡‘(f i)) â†’ Function.Injective fun g => MultilinearMap.compLinearMap g f\"},\n {\"role\": \"user\", \"content\": \"A monomorphism is injective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u_1} {Râ‚‚ : Type u_3} {M : Type u_9} {Mâ‚‚ : Type u_12} [inst : Semiring R] [inst_1 : Semiring Râ‚‚]\\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid Mâ‚‚] [inst_4 : Module R M] [inst_5 : Module Râ‚‚ Mâ‚‚] {Ï„â‚â‚‚ : R â†’+* Râ‚‚}\\n  {f : M â†’â‚›â‚—[Ï„â‚â‚‚] Mâ‚‚},\\n  (âˆ€ (u v : â†¥(LinearMap.ker f) â†’â‚—[R] M), LinearMap.comp f u = LinearMap.comp f v â†’ u = v) â†’ LinearMap.ker f = âŠ¥\"},\n {\"role\": \"user\",\n  \"content\": \"A group homomorphism sends inverses to inverses. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : Group Î±] [inst_1 : Group Î²] {f : Î± â†’ Î²}, IsGroupHom f â†’ âˆ€ (a : Î±), f aâ»Â¹ = (f a)â»Â¹\"},\n {\"role\": \"user\",\n  \"content\": \"Composing with a surjective linear map is injective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u_1} [inst : Semiring R] {M : Type u_2} [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {N : Type u_3}\\n  [inst_3 : AddCommMonoid N] [inst_4 : Module R N] {Î¹ : Type u_7} {Mâ‚‚ : Type u_10} [inst_5 : AddCommMonoid Mâ‚‚]\\n  [inst_6 : Module R Mâ‚‚] (f : Mâ‚‚ â†’â‚—[R] M),\\n  Function.Surjective â‡‘f â†’ Function.Injective fun g => AlternatingMap.compLinearMap g f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A monoid homomorphism `f` induces an injective homomorphism on the quotient by `f`'s kernel. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {M : Type u_1} {P : Type u_3} [inst : MulOneClass M] [inst_1 : MulOneClass P] (f : M â†’* P),\\n  Function.Injective â‡‘(Con.kerLift f)\"},\n {\"role\": \"user\", \"content\": \"The ring homomorphism is surjective \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Râ‚ : Type u_1} {Râ‚‚ : Type u_2} [inst : Semiring Râ‚] [inst_1 : Semiring Râ‚‚] {Ïƒ : Râ‚ â†’+* Râ‚‚}\\n  [self : RingHomSurjective Ïƒ], Function.Surjective â‡‘Ïƒ\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The induced algebra morphism from the quotient by the kernel is injective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Râ‚ : Type u_1} {A : Type u_3} {B : Type u_4} [inst : CommSemiring Râ‚] [inst_1 : CommRing A] [inst_2 : CommRing B]\\n  [inst_3 : Algebra Râ‚ A] [inst_4 : Algebra Râ‚ B] (f : A â†’â‚[Râ‚] B), Function.Injective â‡‘(Ideal.kerLiftAlg f)\"},\n {\"role\": \"user\", \"content\": \"Group homomorphisms preserve inverse. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_6} {H : Type u_7} {F : Type u_8} [inst : Group G] [inst_1 : DivisionMonoid H]\\n  [inst_2 : MonoidHomClass F G H] (f : F) (a : G), f aâ»Â¹ = (f a)â»Â¹\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any surjective endomorphism of a Noetherian module is bijective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsNoetherian R M] (f : M â†’â‚—[R] M), Function.Surjective â‡‘f â†’ Function.Bijective â‡‘f\"},\n {\"role\": \"user\",\n  \"content\": \"Any injective endomorphism of an Artinian module is bijective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsArtinian R M] (f : M â†’â‚—[R] M), Function.Injective â‡‘f â†’ Function.Bijective â‡‘f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any injective polynomial map over an algebraic extension of a finite field is surjective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î¹ : Type u_1} {K : Type u_2} {R : Type u_3} [inst : Field K] [inst_1 : Finite K] [inst_2 : CommRing R]\\n  [inst_3 : Finite Î¹] [inst_4 : Algebra K R],\\n  Algebra.IsAlgebraic K R â†’\\n    âˆ€ (ps : Î¹ â†’ MvPolynomial Î¹ R),\\n      (Function.Injective fun v i => (MvPolynomial.eval v) (ps i)) â†’\\n        Function.Surjective fun v i => (MvPolynomial.eval v) (ps i)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"On a finite-dimensional space, an injective linear map is surjective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] {f : V â†’â‚—[K] V}, Function.Injective â‡‘f â†’ Function.Surjective â‡‘f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"An additive group homomorphism is injective if its kernel is trivial.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : AddGroup Î±] [inst_1 : AddGroup Î²] {f : Î± â†’ Î²},\\n  IsAddGroupHom f â†’ (Function.Injective f â†” âˆ€ (a : Î±), f a = 0 â†’ a = 0)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any injective endomorphism of an Artinian module is surjective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsArtinian R M] (f : M â†’â‚—[R] M), Function.Injective â‡‘f â†’ Function.Surjective â‡‘f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any surjective endomorphism of a Noetherian module is injective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsNoetherian R M] (f : M â†’â‚—[R] M), Function.Surjective â‡‘f â†’ Function.Injective â‡‘f\"},\n {\"role\": \"user\",\n  \"content\": \"A group homomorphism is injective iff its kernel is trivial. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : Group Î±] [inst_1 : Group Î²] {f : Î± â†’ Î²},\\n  IsGroupHom f â†’ (Function.Injective f â†” âˆ€ (a : Î±), f a = 1 â†’ a = 1)\"},\n {\"role\": \"user\",\n  \"content\": \"Every graph homomorphism from a complete graph is injective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {V : Type u} {W : Type v} {G' : SimpleGraph W} (f : âŠ¤ â†’g G'), Function.Injective â‡‘f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every surjective homomorphism from a finitely generated free group to itself is injective.\"}]"}
{"text":"Every positive even integer can be written as the sum of two primes.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"A minimal polynomial is prime. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\\n  IsIntegral A x â†’ Prime (minpoly A x)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"role\": \"assistant\",\n  \"content\": \"âˆ€ (n : â„•), Nat.factorization n = 0 â†” n = 0 âˆ¨ n = 1\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is simple. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsSimpleGroup Î±\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For any positive `k : â„•` there are infinitely many primes `p` such that `p â‰¡ 1 [MOD k]`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {k : â„•}, k â‰  0 â†’ Set.Infinite {p | Nat.Prime p âˆ§ p â‰¡ 1 [MOD k]}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If two integers are congruent to a sufficiently large modulus,\\nthey are equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {a b c : â„¤}, a % b = c â†’ Int.natAbs (a - c) < Int.natAbs b â†’ a = c\"},\n {\"role\": \"user\",\n  \"content\": \"Any common divisor of both elements is a divisor of the GCD. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u_2} [inst : CancelCommMonoidWithZero Î±] [self : GCDMonoid Î±] {a b c : Î±}, a âˆ£ c â†’ a âˆ£ b â†’ a âˆ£ gcd c b\"},\n {\"role\": \"user\",\n  \"content\":\n  \"There is a rational power between any two positive elements of an archimedean ordered field. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {n : â„•} {Î± : Type u_1} [inst : LinearOrderedField Î±] [inst_1 : Archimedean Î±],\\n  n â‰  0 â†’ âˆ€ {x y : Î±}, x < y â†’ 0 < y â†’ âˆƒ q, 0 < q âˆ§ x < â†‘q ^ n âˆ§ â†‘q ^ n < y\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The numerator and denominator are coprime: it is in \\\"reduced form\\\". \"},\n {\"role\": \"assistant\",\n  \"content\": \"âˆ€ (self : â„š), Nat.Coprime (Int.natAbs self.num) self.den\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a product lies in the prime ideal, then at least one element lies in the prime ideal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u} [inst : Semiring Î±] {I : Ideal Î±} [self : Ideal.IsPrime I] {x y : Î±}, x * y âˆˆ I â†’ x âˆˆ I âˆ¨ y âˆˆ I\"},\n {\"role\": \"user\",\n  \"content\": \"The product of two positive elements is positive. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u} [self : StrictOrderedRing Î±] (a b : Î±), 0 < a â†’ 0 < b â†’ 0 < a * b\"},\n {\"role\": \"user\",\n  \"content\":\n  \"We relate a finite product over primes to an infinite sum over smooth numbers. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u_1} [inst : NormedCommRing R] [inst_1 : CompleteSpace R] {f : â„• â†’ R},\\n  f 1 = 1 â†’\\n    (âˆ€ {m n : â„•}, Nat.Coprime m n â†’ f (m * n) = f m * f n) â†’\\n      (âˆ€ {p : â„•}, Nat.Prime p â†’ Summable fun n => â€–f (p ^ n)â€–) â†’\\n        âˆ€ (N : â„•),\\n          (Summable fun m => â€–f â†‘mâ€–) âˆ§\\n            HasSum (fun m => f â†‘m) (Finset.prod (Nat.primesBelow N) fun p => âˆ‘' (n : â„•), f (p ^ n))\"},\n {\"role\": \"user\",\n  \"content\": \"The only divisors of prime powers are prime powers. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u_1} [inst : CancelCommMonoidWithZero Î±] [dec_irr : (p : Associates Î±) â†’ Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid Î±] [dec : DecidableEq Î±] [dec' : DecidableEq (Associates Î±)] {a p : Associates Î±},\\n  Irreducible p â†’\\n    âˆ€ [inst_2 : (n : â„•) â†’ Decidable (a âˆ£ p ^ n)] {n : â„•} (h : a âˆ£ p ^ n),\\n      a = p ^ Nat.find (_ : âˆƒ n, (fun n => a âˆ£ p ^ n) n)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"role\": \"assistant\",\n  \"content\": \"âˆ€ {m n : â„•}, (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two positive naturals are equal if their prime padic valuations are equal \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ (a b : â„•), a â‰  0 â†’ b â‰  0 â†’ (a = b â†” âˆ€ (p : â„•), Nat.Prime p â†’ padicValNat p a = padicValNat p b)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"role\": \"assistant\",\n  \"content\": \"âˆ€ {m n : â„•}, (âˆ€ (a : â„•), a âˆ£ m â†” a âˆ£ n) â†” m = n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\", \"content\": \"Set.InjOn Nat.factorization {x | x â‰  0}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every positive even integer can be written as the sum of two primes.\"}]"}
{"text":"Every matrix satisfies its own characteristic polynomial.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"The eigenvalues of a positive definite matrix are positive \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {n : Type u_2} {ð•œ : Type u_4} [inst : Fintype n] [inst_1 : IsROrC ð•œ] [inst_2 : DecidableEq n] {A : Matrix n n ð•œ}\\n  (hA : Matrix.PosDef A) (i : n), 0 < Matrix.IsHermitian.eigenvalues (_ : Matrix.IsHermitian A) i\"},\n {\"role\": \"user\",\n  \"content\": \"The determinant of a permutation matrix equals its sign. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {n : Type u_2} [inst : DecidableEq n] [inst_1 : Fintype n] {R : Type v} [inst_2 : CommRing R] (Ïƒ : Equiv.Perm n),\\n  Matrix.det (PEquiv.toMatrix (Equiv.toPEquiv Ïƒ)) = â†‘â†‘(Equiv.Perm.sign Ïƒ)\"},\n {\"role\": \"user\",\n  \"content\": \"If a matrix has a repeated row, the determinant will be zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {n : Type u_2} [inst : DecidableEq n] [inst_1 : Fintype n] {R : Type v} [inst_2 : CommRing R] {M : Matrix n n R}\\n  {i j : n}, i â‰  j â†’ M i = M j â†’ Matrix.det M = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a matrix has a repeated column, the determinant will be zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {n : Type u_2} [inst : DecidableEq n] [inst_1 : Fintype n] {R : Type v} [inst_2 : CommRing R] {M : Matrix n n R}\\n  {i j : n}, i â‰  j â†’ (âˆ€ (k : n), M k i = M k j) â†’ Matrix.det M = 0\"},\n {\"role\": \"user\", \"content\": \"A minimal polynomial is prime. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\\n  IsIntegral A x â†’ Prime (minpoly A x)\"},\n {\"role\": \"user\", \"content\": \"Every Lie algebra is a module over itself. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u} {L : Type v} [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L], LieModule R L L\"},\n {\"role\": \"user\",\n  \"content\": \"The degree of a minimal polynomial is positive. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : Nontrivial B], IsIntegral A x â†’ 0 < Polynomial.degree (minpoly A x)\"},\n {\"role\": \"user\", \"content\": \"A minimal polynomial is irreducible. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x â†’ Irreducible (minpoly A x)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A nonzero Hermitian matrix has an eigenvector with nonzero eigenvalue. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {ð•œ : Type u_1} [inst : IsROrC ð•œ] {n : Type u_2} [inst_1 : Fintype n] [inst_2 : DecidableEq n] {A : Matrix n n ð•œ},\\n  Matrix.IsHermitian A â†’ A â‰  0 â†’ âˆƒ v t, t â‰  0 âˆ§ v â‰  0 âˆ§ Matrix.mulVec A v = t â€¢ v\"},\n {\"role\": \"user\", \"content\": \"A minimal polynomial is monic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B},\\n  IsIntegral A x â†’ Polynomial.Monic (minpoly A x)\"},\n {\"role\": \"user\", \"content\": \"Every zero matrix is diagonal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u_1} {n : Type u_4} [inst : Zero Î±], Matrix.IsDiag 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If every coefficient of a polynomial is in an ideal `I`, then so is the polynomial itself \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u} [inst : CommSemiring R] (I : Ideal (Polynomial R)) (p : Polynomial R),\\n  (âˆ€ (n : â„•), Polynomial.coeff p n âˆˆ Ideal.comap Polynomial.C I) â†’ p âˆˆ I\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every polynomial is the sum of its weighted homogeneous components. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u_1} {M : Type u_2} [inst : CommSemiring R] {Ïƒ : Type u_3} [inst_1 : AddCommMonoid M] (w : Ïƒ â†’ M)\\n  (Ï† : MvPolynomial Ïƒ R), (finsum fun m => (MvPolynomial.weightedHomogeneousComponent w m) Ï†) = Ï†\"},\n {\"role\": \"user\",\n  \"content\":\n  \"`charpoly f` is the characteristic polynomial of the matrix of `f` in any basis. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u} {M : Type v} [inst : CommRing R] [inst_1 : Nontrivial R] [inst_2 : AddCommGroup M] [inst_3 : Module R M]\\n  [inst_4 : Module.Free R M] [inst_5 : Module.Finite R M] (f : M â†’â‚—[R] M) {Î¹ : Type w} [inst_6 : DecidableEq Î¹]\\n  [inst_7 : Fintype Î¹] (b : Basis Î¹ R M), Matrix.charpoly ((LinearMap.toMatrix b b) f) = LinearMap.charpoly f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The minimal polynomial of a nonzero element has nonzero constant coefficient. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\\n  IsIntegral A x â†’ x â‰  0 â†’ Polynomial.coeff (minpoly A x) 0 â‰  0\"},\n {\"role\": \"user\",\n  \"content\": \"Every polynomial is a polynomial in finitely many variables. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Ïƒ : Type u_1} {R : Type u_4} [inst : CommSemiring R] (p : MvPolynomial Ïƒ R),\\n  âˆƒ n f, âˆƒ (_ : Function.Injective f), âˆƒ q, p = (MvPolynomial.rename f) q\"},\n {\"role\": \"user\", \"content\": \"Every identity matrix is diagonal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u_1} {n : Type u_4} [inst : DecidableEq n] [inst_1 : Zero Î±] [inst_2 : One Î±], Matrix.IsDiag 1\"},\n {\"role\": \"user\",\n  \"content\": \"Every matrix satisfies its own characteristic polynomial.\"}]"}
{"text":"The square root of an irrational number is irrational.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"An algebraic integer whose conjugates are all of norm one is a root of unity. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ (K : Type u_1) [inst : Field K] [inst_1 : NumberField K] (A : Type u_2) [inst_2 : NormedField A]\\n  [inst_3 : IsAlgClosed A] [inst_4 : NormedAlgebra â„š A] {x : K},\\n  IsIntegral â„¤ x â†’ (âˆ€ (Ï† : K â†’+* A), â€–Ï† xâ€– = 1) â†’ âˆƒ n, âˆƒ (_ : 0 < n), x ^ n = 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Let `r` be an irrational number. Then `Bâº_r` and `Bâº'_r` are equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {r : â„}, Irrational r â†’ {x | âˆƒ k > 0, beattySeq' r k = x} = {x | âˆƒ k > 0, beattySeq r k = x}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Rational numbers are dense in a linear ordered archimedean field. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {ð•œ : Type u_1} [inst : LinearOrderedField ð•œ] [inst_1 : TopologicalSpace ð•œ] [inst_2 : OrderTopology ð•œ]\\n  [inst_3 : Archimedean ð•œ], DenseRange Rat.cast\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every terminating continued fraction corresponds to a rational number. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] {v : K},\\n  GeneralizedContinuedFraction.Terminates (GeneralizedContinuedFraction.of v) â†’ âˆƒ q, v = â†‘q\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `x^n`, `n > 0`, is integer and is not the `n`-th power of an integer, then\\n`x` is irrational. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {x : â„} (n : â„•) (m : â„¤), x ^ n = â†‘m â†’ (Â¬âˆƒ y, x = â†‘y) â†’ 0 < n â†’ Irrational x\"},\n {\"role\": \"user\", \"content\": \"The complex numbers are not countable. \"},\n {\"role\": \"assistant\", \"content\": \"Â¬Set.Countable Set.univ\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A quadratic has no root if its discriminant has no square root. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] {a b c : R},\\n  (âˆ€ (s : R), discrim a b c â‰  s ^ 2) â†’ âˆ€ (x : R), a * x * x + b * x + c â‰  0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A rational number has only finitely many good rational approximations. \"},\n {\"role\": \"assistant\",\n  \"content\": \"âˆ€ (Î¾ : â„š), Set.Finite {q | |Î¾ - q| < 1 / â†‘q.den ^ 2}\"},\n {\"role\": \"user\",\n  \"content\": \"Every finite convergent corresponds to a rational number. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K) (n : â„•),\\n  âˆƒ q, GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n = â†‘q\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `x + y` is irrational, then at least one of `x` and `y` is irrational. \"},\n {\"role\": \"assistant\",\n  \"content\": \"âˆ€ {x y : â„}, Irrational (x + y) â†’ Irrational x âˆ¨ Irrational y\"},\n {\"role\": \"user\",\n  \"content\": \"The continued fraction of a rational number terminates. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ (q : â„š), GeneralizedContinuedFraction.Terminates (GeneralizedContinuedFraction.of q)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"There is an irrational number `r` between any two reals `x < r < y`. \"},\n {\"role\": \"assistant\",\n  \"content\": \"âˆ€ {x y : â„}, x < y â†’ âˆƒ r, Irrational r âˆ§ x < r âˆ§ r < y\"},\n {\"role\": \"user\",\n  \"content\": \"If a rational is not a p-adic integer, it is not an integer. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ (p : â„•) {a : â„š} [hp : Fact (Nat.Prime p)], 1 < padicNorm p a â†’ Â¬Rat.isInt a = true\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A number satisfying the Liouville condition with exponent `p > 1` is an irrational number. \"},\n {\"role\": \"assistant\",\n  \"content\": \"âˆ€ {p x : â„}, LiouvilleWith p x â†’ 1 < p â†’ Irrational x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The real square root is at most the natural square root plus one \"},\n {\"role\": \"assistant\",\n  \"content\": \"âˆ€ {a : â„•}, Real.sqrt â†‘a â‰¤ â†‘(Nat.sqrt a) + 1\"},\n {\"role\": \"user\",\n  \"content\": \"The natural square root is at most the real square root \"},\n {\"role\": \"assistant\", \"content\": \"âˆ€ {a : â„•}, â†‘(Nat.sqrt a) â‰¤ Real.sqrt â†‘a\"},\n {\"role\": \"user\", \"content\": \"The golden ratio is irrational. \"},\n {\"role\": \"assistant\", \"content\": \"Irrational goldenRatio\"},\n {\"role\": \"user\", \"content\": \"**Irrationality of the Square Root of 2** \"},\n {\"role\": \"assistant\", \"content\": \"Irrational (Real.sqrt 2)\"},\n {\"role\": \"user\",\n  \"content\": \"The conjugate of the golden ratio is irrational. \"},\n {\"role\": \"assistant\", \"content\": \"Irrational goldenConj\"},\n {\"role\": \"user\", \"content\": \"A transcendental real number is irrational. \"},\n {\"role\": \"assistant\",\n  \"content\": \"âˆ€ {r : â„}, Transcendental â„š r â†’ Irrational r\"},\n {\"role\": \"user\",\n  \"content\": \"The square root of an irrational number is irrational.\"}]"}
{"text":"If the square of a number is even, the number itself is even.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"`2` is a square in `F` iff `#F` is not congruent to `3` or `5` mod `8`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F], IsSquare 2 â†” Fintype.card F % 8 â‰  3 âˆ§ Fintype.card F % 8 â‰  5\"},\n {\"role\": \"user\", \"content\": \"**Four squares theorem** \"},\n {\"role\": \"assistant\",\n  \"content\": \"âˆ€ (n : â„•), âˆƒ a b c d, a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n\"},\n {\"role\": \"user\", \"content\": \"The square of the symbol is 1 if `p âˆ¤ a`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ (p : â„•) [inst : Fact (Nat.Prime p)] {a : â„¤}, â†‘a â‰  0 â†’ legendreSym p a ^ 2 = 1\"},\n {\"role\": \"user\", \"content\": \"**Euler's four-square identity**. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] (a b c d x y z w : R),\\n  (a * x - b * y - c * z - d * w) ^ 2 + (a * y + b * x + c * w - d * z) ^ 2 + (a * z - b * w + c * x + d * y) ^ 2 +\\n      (a * w + b * z - c * y + d * x) ^ 2 =\\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A square has a lifting if and only if its (right) adjoint square has a lifting. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {C : Type u_1} {D : Type u_2} [inst : CategoryTheory.Category.{u_3, u_1} C]\\n  [inst_1 : CategoryTheory.Category.{u_4, u_2} D] {G : CategoryTheory.Functor C D} {F : CategoryTheory.Functor D C}\\n  {A B : C} {X Y : D} {i : A âŸ¶ B} {p : X âŸ¶ Y} {u : G.obj A âŸ¶ X} {v : G.obj B âŸ¶ Y}\\n  (sq : CategoryTheory.CommSq u (G.map i) p v) (adj : G âŠ£ F),\\n  CategoryTheory.CommSq.HasLift\\n      (_ :\\n        CategoryTheory.CommSq ((CategoryTheory.Adjunction.homEquiv adj A X) u) i (F.map p)\\n          ((CategoryTheory.Adjunction.homEquiv adj B Y) v)) â†”\\n    CategoryTheory.CommSq.HasLift sq\"},\n {\"role\": \"user\",\n  \"content\": \"The square of `J(a | b)` is `1` when `a` and `b` are coprime. \"},\n {\"role\": \"assistant\",\n  \"content\": \"âˆ€ {a : â„¤} {b : â„•}, Int.gcd a â†‘b = 1 â†’ jacobiSym a b ^ 2 = 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The sum over the values of the quadratic character is zero when the characteristic is odd. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] [inst_2 : DecidableEq F],\\n  ringChar F â‰  2 â†’ (Finset.sum Finset.univ fun a => (quadraticChar F) a) = 0\"},\n {\"role\": \"user\",\n  \"content\": \"The square of a quadratic character is the trivial character. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] {R' : Type v} [inst_1 : CommRing R'] {Ï‡ : MulChar R R'},\\n  MulChar.IsQuadratic Ï‡ â†’ Ï‡ ^ 2 = 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"role\": \"assistant\",\n  \"content\": \"âˆ€ {m n : â„•}, (âˆ€ (a : â„•), a âˆ£ m â†” a âˆ£ n) â†” m = n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The `n`th power of a quadratic character is itself, when `n` is odd. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] {R' : Type v} [inst_1 : CommRing R'] {Ï‡ : MulChar R R'},\\n  MulChar.IsQuadratic Ï‡ â†’ âˆ€ {n : â„•}, Odd n â†’ Ï‡ ^ n = Ï‡\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Commutativity of a square is preserved when taking quotients by an ideal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u} {S : Type v} [inst : CommRing R] [inst_1 : CommRing S] {R' : Type u_5} {S' : Type u_6}\\n  [inst_2 : CommRing R'] [inst_3 : CommRing S'] {f : R â†’+* S} {f' : R' â†’+* S'} {g : R â†’+* R'} {g' : S â†’+* S'}\\n  (hfg : RingHom.comp f' g = RingHom.comp g' f) (I : Ideal S'),\\n  let leq := (_ : Ideal.comap f (Ideal.comap g' I) â‰¤ Ideal.comap g (Ideal.comap f' I));\\n  RingHom.comp (Ideal.quotientMap I g' (_ : Ideal.comap g' I â‰¤ Ideal.comap g' I))\\n      (Ideal.quotientMap (Ideal.comap g' I) f\\n        (_ : Ideal.comap f (Ideal.comap g' I) â‰¤ Ideal.comap f (Ideal.comap g' I))) =\\n    RingHom.comp (Ideal.quotientMap I f' (_ : Ideal.comap f' I â‰¤ Ideal.comap f' I))\\n      (Ideal.quotientMap (Ideal.comap f' I) g leq)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The special case of Graham's conjecture where all numbers are squarefree. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {n : â„•} (f : â„• â†’ â„•), (âˆ€ k < n, Squarefree (f k)) â†’ Nat.GrahamConjecture n f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The square of the quadratic character on nonzero arguments is `1`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] [inst_2 : DecidableEq F] {a : F},\\n  a â‰  0 â†’ (quadraticChar F) a ^ 2 = 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. \"},\n {\"role\": \"assistant\",\n  \"content\": \"âˆ€ {n : â„•}, IsSquare (-1) â†’ âˆƒ x y, n = x ^ 2 + y ^ 2\"},\n {\"role\": \"user\",\n  \"content\":\n  \"**Euler's four-square identity**, a version for natural numbers. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ (a b c d x y z w : â„•),\\n  Int.natAbs (â†‘a * â†‘x - â†‘b * â†‘y - â†‘c * â†‘z - â†‘d * â†‘w) ^ 2 + Int.natAbs (â†‘a * â†‘y + â†‘b * â†‘x + â†‘c * â†‘w - â†‘d * â†‘z) ^ 2 +\\n        Int.natAbs (â†‘a * â†‘z - â†‘b * â†‘w + â†‘c * â†‘x + â†‘d * â†‘y) ^ 2 +\\n      Int.natAbs (â†‘a * â†‘w + â†‘b * â†‘z - â†‘c * â†‘y + â†‘d * â†‘x) ^ 2 =\\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a finite field of characteristic `2`, all elements are squares. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {F : Type u_3} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 â†’ âˆ€ (a : F), IsSquare a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"role\": \"assistant\",\n  \"content\": \"âˆ€ {m n : â„•}, (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n\"},\n {\"role\": \"user\",\n  \"content\": \"The convolution of two even functions is also even. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {ð•œ : Type uð•œ} {G : Type uG} {E : Type uE} {E' : Type uE'} {F : Type uF} [inst : NormedAddCommGroup E]\\n  [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedAddCommGroup F] {f : G â†’ E} {g : G â†’ E'} {x : G}\\n  [inst_3 : NontriviallyNormedField ð•œ] [inst_4 : NormedSpace ð•œ E] [inst_5 : NormedSpace ð•œ E'] [inst_6 : NormedSpace ð•œ F]\\n  (L : E â†’L[ð•œ] E' â†’L[ð•œ] F) [inst_7 : MeasurableSpace G] {Î¼ : MeasureTheory.Measure G} [inst_8 : NormedSpace â„ F]\\n  [inst_9 : AddCommGroup G] [inst_10 : MeasureTheory.Measure.IsAddLeftInvariant Î¼]\\n  [inst_11 : MeasureTheory.Measure.IsNegInvariant Î¼] [inst_12 : MeasurableNeg G] [inst_13 : MeasurableAdd G],\\n  (âˆ€áµ (x : G) âˆ‚Î¼, f (-x) = f x) â†’ (âˆ€áµ (x : G) âˆ‚Î¼, g (-x) = g x) â†’ convolution f g L (-x) = convolution f g L x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2\"},\n {\"role\": \"user\",\n  \"content\": \"The sum of two squares is zero iff both elements are zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u} [inst : LinearOrderedRing Î±] {x y : Î±}, x * x + y * y = 0 â†” x = 0 âˆ§ y = 0\"},\n {\"role\": \"user\",\n  \"content\": \"If the square of a number is even, the number itself is even.\"}]"}
{"text":"In a finite commutative ring, all prime ideals are maximal.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The unique maximal ideal of the localization at `I.primeCompl` lies over the ideal `I`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u_1} [inst : CommSemiring R] {I : Ideal R} [hI : Ideal.IsPrime I],\\n  Ideal.comap (algebraMap R (Localization.AtPrime I)) (LocalRing.maximalIdeal (Localization (Ideal.primeCompl I))) = I\"},\n {\"role\": \"user\",\n  \"content\": \"The only constant in a maximal ideal over a field is `0`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u} [inst : Ring R],\\n  IsField R â†’ âˆ€ (I : Ideal (Polynomial R)) [hI : Ideal.IsMaximal I] (x : R), Polynomial.C x âˆˆ I â†’ x = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The prime spectrum of a commutative ring is a compact topological space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u} [inst : CommRing R], CompactSpace (PrimeSpectrum R)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The variable of the power series ring over an integral domain is prime.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R], Prime PowerSeries.X\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The `Ideal.closure` of a maximal ideal in a complete normed ring is the ideal itself. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] {I : Ideal R}, Ideal.IsMaximal I â†’ Ideal.closure I = I\"},\n {\"role\": \"user\",\n  \"content\": \"The kernel of a homomorphism to a field is a maximal ideal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u_1} {K : Type u_2} {F : Type u_3} [inst : Ring R] [inst_1 : Field K] [inst_2 : RingHomClass F R K] (f : F),\\n  Function.Surjective â‡‘f â†’ Ideal.IsMaximal (RingHom.ker f)\"},\n {\"role\": \"user\",\n  \"content\": \"This ideal is maximal in the collection of proper ideals. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {P : Type u_1} [inst : LE P] {I : Order.Ideal P} [self : Order.Ideal.IsMaximal I] â¦ƒJ : Order.Ideal Pâ¦„,\\n  I < J â†’ â†‘J = Set.univ\"},\n {\"role\": \"user\",\n  \"content\": \"The category of commutative rings has all limits. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"CategoryTheory.Limits.HasLimitsOfSize.{v, v, max u v, max (u + 1) (v + 1)} CommRingCatMax\"},\n {\"role\": \"user\",\n  \"content\": \"When a ring is not a field, the maximal ideals are nontrivial. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u_1} [inst : CommSemiring R] [inst_1 : Nontrivial R] {M : Ideal R}, Ideal.IsMaximal M â†’ Â¬IsField R â†’ M â‰  âŠ¥\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A ring is Noetherian if and only if all its ideals are finitely-generated. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ (R : Type u_1) [inst : Semiring R], IsNoetherianRing R â†” âˆ€ (I : Ideal R), Ideal.FG I\"},\n {\"role\": \"user\", \"content\": \"Any finitely generated ideal is principal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] [self : IsBezout R] (I : Ideal R), Ideal.FG I â†’ Submodule.IsPrincipal I\"},\n {\"role\": \"user\",\n  \"content\": \"Krull's theorem: a nontrivial ring has a maximal ideal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ (Î± : Type u) [inst : Semiring Î±] [inst_1 : Nontrivial Î±], âˆƒ M, Ideal.IsMaximal M\"},\n {\"role\": \"user\",\n  \"content\": \"Maximal ideals in complete normed rings are closed. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] {I : Ideal R} [hI : Ideal.IsMaximal I], IsClosed â†‘I\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The quotient of a ring by an ideal is a field iff the ideal is maximal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I â†” IsField (R â§¸ I)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If the quotient by an ideal is a field, then the ideal is maximal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] (I : Ideal R), IsField (R â§¸ I) â†’ Ideal.IsMaximal I\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If all prime ideals in a commutative ring are principal, so are all other ideals. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u} [inst : CommRing R],\\n  (âˆ€ (P : Ideal R), Ideal.IsPrime P â†’ Submodule.IsPrincipal P) â†’ IsPrincipalIdealRing R\"},\n {\"role\": \"user\",\n  \"content\": \"In a finite commutative ring, all prime ideals are maximal.\"}]"}
{"text":"A topological space $X$ is Hausdorff if and only if the diagonal is a closed set in $X Ã— X$.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any continuous bijection of compact Hausdorff spaces is an isomorphism. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {X Y : CompHaus} (f : X âŸ¶ Y), Function.Bijective â‡‘f â†’ CategoryTheory.IsIso f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For any topological space `X`, its one point compactification is a compact space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A linear order with order topology is a completely normal Hausdorff topological space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {X : Type u_1} [inst : LinearOrder X] [inst_1 : TopologicalSpace X] [inst : OrderTopology X], T5Space X\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The Hausdorff distance between two sets and their closures coincide \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s t : Set Î±},\\n  Metric.hausdorffDist (closure s) (closure t) = Metric.hausdorffDist s t\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A continuous injective map from a compact space to a Hausdorff space is a closed embedding. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : CompactSpace X]\\n  [inst_3 : T2Space Y] {f : X â†’ Y}, Continuous f â†’ Function.Injective f â†’ ClosedEmbedding f\"},\n {\"role\": \"user\",\n  \"content\": \"A weakly locally compact Hausdorff space is locally compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : WeaklyLocallyCompactSpace X] [inst_2 : T2Space X],\\n  LocallyCompactSpace X\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A continuous surjective map from a compact space to a Hausdorff space is a quotient map. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : CompactSpace X]\\n  [inst_3 : T2Space Y] {f : X â†’ Y}, Function.Surjective f â†’ Continuous f â†’ QuotientMap f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two closed sets are at zero Hausdorff edistance if and only if they coincide \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoEMetricSpace Î±] {s t : Set Î±},\\n  IsClosed s â†’ IsClosed t â†’ (EMetric.hausdorffEdist s t = 0 â†” s = t)\"},\n {\"role\": \"user\", \"content\": \"Stonean spaces are Hausdorff. \"},\n {\"role\": \"assistant\", \"content\": \"âˆ€ (X : Stonean), T2Space (CoeSort.coe X)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any continuous function on compact Hausdorff spaces is a closed map. \"},\n {\"role\": \"assistant\",\n  \"content\": \"âˆ€ {X Y : CompHaus} (f : X âŸ¶ Y), IsClosedMap â‡‘f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A locally compact Hausdorff space is totally disconnected\\nif and only if it is totally separated. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {H : Type u_3} [inst : TopologicalSpace H] [inst_1 : LocallyCompactSpace H] [inst_2 : T2Space H],\\n  TotallyDisconnectedSpace H â†” TotallySeparatedSpace H\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A locally compact Hausdorff totally disconnected space has a basis with clopen elements. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {H : Type u_3} [inst : TopologicalSpace H] [inst_1 : LocallyCompactSpace H] [inst_2 : T2Space H]\\n  [inst_3 : TotallyDisconnectedSpace H], TopologicalSpace.IsTopologicalBasis {s | IsClopen s}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two closed sets are at zero Hausdorff distance if and only if they coincide \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {s t : Set Î±},\\n  IsClosed s â†’ IsClosed t â†’ EMetric.hausdorffEdist s t â‰  âŠ¤ â†’ (Metric.hausdorffDist s t = 0 â†” s = t)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a complete space, the type of closed subsets is complete for the\\nHausdorff edistance. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u} [inst : EMetricSpace Î±] [inst_1 : CompleteSpace Î±], CompleteSpace (TopologicalSpace.Closeds Î±)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every two points in a Hausdorff space admit disjoint open neighbourhoods. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {X : Type u} [inst : TopologicalSpace X] [self : T2Space X] (x y : X),\\n  x â‰  y â†’ âˆƒ u v, IsOpen u âˆ§ IsOpen v âˆ§ x âˆˆ u âˆ§ y âˆˆ v âˆ§ Disjoint u v\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A continuous map from a compact space to a Hausdorff space is a closed map. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : CompactSpace X]\\n  [inst_3 : T2Space Y] {f : X â†’ Y}, Continuous f â†’ IsClosedMap f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A topological space $X$ is Hausdorff if and only if the diagonal is a closed set in $X Ã— X$.\"}]"}
{"text":"If every point of a subset of a topological space is contained in some open set, the subset itself is open.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The first projection in a product of topological spaces sends open sets to open sets. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : TopologicalSpace Î²], IsOpenMap Prod.fst\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A subspace is dense iff its topological closure is the entire space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : TopologicalSpace M] [inst_2 : AddCommMonoid M]\\n  [inst_3 : Module R M] [inst_4 : ContinuousConstSMul R M] [inst_5 : ContinuousAdd M] {s : Submodule R M},\\n  Dense â†‘s â†” Submodule.topologicalClosure s = âŠ¤\"},\n {\"role\": \"user\",\n  \"content\": \"In a compact space, the type of closed subsets is compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u} [inst : EMetricSpace Î±] [inst_1 : CompactSpace Î±], CompactSpace (TopologicalSpace.Closeds Î±)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The only open sets in the indiscrete topology are the empty set and the whole space. \"},\n {\"role\": \"assistant\",\n  \"content\": \"âˆ€ {Î± : Type u_1} (U : Set Î±), IsOpen U â†” U = âˆ… âˆ¨ U = Set.univ\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any uncountable closed set in a second countable space contains a nonempty perfect subset.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {C : Set Î±} [inst_1 : SecondCountableTopology Î±],\\n  IsClosed C â†’ Â¬Set.Countable C â†’ âˆƒ D, Perfect D âˆ§ Set.Nonempty D âˆ§ D âŠ† C\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A nonempty open subset of a preirreducible subspace is dense in the subspace. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {S U : Set X},\\n  IsPreirreducible S â†’ IsOpen U â†’ Set.Nonempty (S âˆ© U) â†’ S âŠ† closure (S âˆ© U)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Points of a finite set can be separated by open sets from each other. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T2Space X] {s : Set X},\\n  Set.Finite s â†’ âˆƒ U, (âˆ€ (x : X), x âˆˆ U x âˆ§ IsOpen (U x)) âˆ§ Set.PairwiseDisjoint s U\"},\n {\"role\": \"user\",\n  \"content\": \"Subsets of a given closed subset form a closed set \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u} [inst : EMetricSpace Î±] {s : Set Î±}, IsClosed s â†’ IsClosed {t | â†‘t âŠ† s}\"},\n {\"role\": \"user\",\n  \"content\": \"In a (pre)irreducible space, a nonempty open set is dense. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {X : Type u_1} [inst : TopologicalSpace X] {s : Set X} [inst_1 : PreirreducibleSpace X],\\n  IsOpen s â†’ Set.Nonempty s â†’ Dense s\"},\n {\"role\": \"user\", \"content\": \"The closure of every open set is open. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {X : Type u} [inst : TopologicalSpace X] [self : ExtremallyDisconnected X] (U : Set X), IsOpen U â†’ IsOpen (closure U)\"},\n {\"role\": \"user\",\n  \"content\": \"A closed subset of a compact set is a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {X : Type u} [inst : TopologicalSpace X] {s t : Set X}, IsCompact s â†’ IsClosed t â†’ t âŠ† s â†’ IsCompact t\"},\n {\"role\": \"user\",\n  \"content\":\n  \"An open set in the indiscrete topology is either empty or the whole space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u_5} [t : TopologicalSpace Î±], t = âŠ¤ â†’ âˆ€ (U : TopologicalSpace.Opens Î±), U = âŠ¥ âˆ¨ U = âŠ¤\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Characterization of when a subset of the space of points is open. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ (L : Type u_1) [inst : CompleteLattice L] (U : Set (Locale.PT L)), IsOpen U â†” âˆƒ u, {x | x u} = U\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If every point of a subset of a topological space is contained in some open set, the subset itself is open.\"}]"}
{"text":"Every non-identity element of a free group is of infinite order.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every nonarchimedean ring is naturally a nonarchimedean additive group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ (R : Type u_1) [inst : Ring R] [inst_1 : TopologicalSpace R] [t : NonarchimedeanRing R], NonarchimedeanAddGroup R\"},\n {\"role\": \"user\",\n  \"content\": \"Subgroups of torsion-free groups are torsion-free. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsionFree â†¥H\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Inverses of elements of finite additive order\\nhave finite additive order.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G] {x : G}, IsOfFinAddOrder (-x) â†” IsOfFinAddOrder x\"},\n {\"role\": \"user\", \"content\": \"0 is of finite order in any additive monoid.\"},\n {\"role\": \"assistant\",\n  \"content\": \"âˆ€ {G : Type u_1} [inst : AddMonoid G], IsOfFinAddOrder 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A nontrivial monoid is not torsion-free if any nontrivial element has finite order. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : Monoid G], Â¬Monoid.IsTorsionFree G â†” âˆƒ g, g â‰  1 âˆ§ IsOfFinOrder g\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is simple. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsSimpleGroup Î±\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The Nielsen-Schreier theorem: a subgroup of a free group is free. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u} [inst : Group G] [inst_1 : IsFreeGroup G] (H : Subgroup G), IsFreeGroup â†¥H\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is cyclic.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u} [inst : AddGroup Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)],\\n  Fintype.card Î± = p â†’ IsAddCyclic Î±\"},\n {\"role\": \"user\", \"content\": \"1 is of finite order in any monoid. \"},\n {\"role\": \"assistant\",\n  \"content\": \"âˆ€ {G : Type u_1} [inst : Monoid G], IsOfFinOrder 1\"},\n {\"role\": \"user\",\n  \"content\": \"The free product of free groups is itself a free group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î¹ : Type u_4} (G : Î¹ â†’ Type u_5) [inst : (i : Î¹) â†’ Group (G i)] [inst_1 : âˆ€ (i : Î¹), IsFreeGroup (G i)],\\n  IsFreeGroup (Monoid.CoprodI G)\"},\n {\"role\": \"user\",\n  \"content\": \"Elements of finite order are closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : CommMonoid G] {x y : G}, IsOfFinOrder x â†’ IsOfFinOrder y â†’ IsOfFinOrder (x * y)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The image of an element of finite additive order has finite additive order.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} {H : Type u_2} [inst : AddMonoid G] [inst_1 : AddMonoid H] (f : G â†’+ H) {x : G},\\n  IsOfFinAddOrder x â†’ IsOfFinAddOrder (f x)\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is cyclic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p â†’ IsCyclic Î±\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A group element has finite additive order iff its order is positive.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : AddMonoid G] {x : G}, 0 < addOrderOf x â†” IsOfFinAddOrder x\"},\n {\"role\": \"user\",\n  \"content\": \"Elements of finite order are of finite order in submonoids.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : AddMonoid G] {H : AddSubmonoid G} {x : â†¥H}, IsOfFinAddOrder â†‘x â†” IsOfFinAddOrder x\"},\n {\"role\": \"user\",\n  \"content\": \"The image of an element of finite order has finite order. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} {H : Type u_2} [inst : Monoid G] [inst_1 : Monoid H] (f : G â†’* H) {x : G},\\n  IsOfFinOrder x â†’ IsOfFinOrder (f x)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A monoid is not a torsion monoid if it has an element of infinite order. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ (G : Type u_1) [inst : Monoid G], Â¬Monoid.IsTorsion G â†” âˆƒ g, Â¬IsOfFinOrder g\"},\n {\"role\": \"user\",\n  \"content\": \"A group element has finite order iff its order is positive. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x â†” IsOfFinOrder x\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u_1} [self : LinearOrderedCommGroupWithZero Î±] (a : Î±), a â‰  0 â†’ a * aâ»Â¹ = 1\"},\n {\"role\": \"user\",\n  \"content\": \"Inverses of elements of finite order have finite order. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder xâ»Â¹ â†” IsOfFinOrder x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every non-identity element of a free group is of infinite order.\"}]"}
{"text":"An element of a discrete valuation ring is a unit if and only if it has a valuation of zero.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `v` is an additive valuation on a division ring then `v(x) = âŠ¤` iff `x = 0`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {K : Type u_1} [inst : DivisionRing K] {Î“â‚€ : Type u_4} [inst_1 : LinearOrderedAddCommMonoidWithTop Î“â‚€]\\n  [inst_2 : Nontrivial Î“â‚€] (v : AddValuation K Î“â‚€) {x : K}, v x = âŠ¤ â†” x = 0\"},\n {\"role\": \"user\",\n  \"content\": \"Nonzero divisors have valuation greater than zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\\n  (v : IsDedekindDomain.HeightOneSpectrum R) (x : â†¥(nonZeroDivisors R)),\\n  0 < IsDedekindDomain.HeightOneSpectrum.intValuationDef v â†‘x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a normed ring, the powers of an element x with `â€–xâ€– < 1` tend to zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u_4} [inst : NormedRing R] {x : R}, â€–xâ€– < 1 â†’ Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a monoid with zero, either zero and one are nonequal, or zero is the only element. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Mâ‚€ : Type u_2} [inst : MulZeroOneClass Mâ‚€], 0 â‰  1 âˆ¨ âˆ€ (a : Mâ‚€), a = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A subring of a ring with no zero divisors has no zero divisors. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u_1} [inst : Ring R] [inst_1 : NoZeroDivisors R] (s : Subring R), NoZeroDivisors â†¥s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The sum of a nontrivial subgroup of the units of a field is zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {K : Type u_1} [inst : Ring K] [inst_1 : NoZeroDivisors K] {G : Subgroup KË£} [inst_2 : Fintype â†¥G],\\n  G â‰  âŠ¥ â†’ (Finset.sum Finset.univ fun x => â†‘â†‘x) = 0\"},\n {\"role\": \"user\", \"content\": \"Nonzero divisors have nonzero valuation. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\\n  (v : IsDedekindDomain.HeightOneSpectrum R) (x : â†¥(nonZeroDivisors R)),\\n  IsDedekindDomain.HeightOneSpectrum.intValuationDef v â†‘x â‰  0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a monoid with zero, zero equals one if and only if all elements of that semiring\\nare equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Mâ‚€ : Type u_2} [inst : MulZeroOneClass Mâ‚€], 0 = 1 â†” Subsingleton Mâ‚€\"},\n {\"role\": \"user\",\n  \"content\": \"An element is in the kernel if and only if it maps to zero.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u} {S : Type v} {F : Type u_1} [inst : Semiring R] [inst_1 : Semiring S] [rcf : RingHomClass F R S] (f : F)\\n  {r : R}, r âˆˆ RingHom.ker f â†” f r = 0\"},\n {\"role\": \"user\", \"content\": \"Nonzero elements have nonzero adic valuation. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\\n  (v : IsDedekindDomain.HeightOneSpectrum R) (x : R), x â‰  0 â†’ IsDedekindDomain.HeightOneSpectrum.intValuationDef v x â‰  0\"},\n {\"role\": \"user\", \"content\": \"The `v`-adic valuation of `0 : R` equals 0. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\\n  (v : IsDedekindDomain.HeightOneSpectrum R), IsDedekindDomain.HeightOneSpectrum.intValuationDef v 0 = 0\"},\n {\"role\": \"user\", \"content\": \"A non-unital subring contains the ring's 0. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u} [inst : NonUnitalNonAssocRing R] (s : NonUnitalSubring R), 0 âˆˆ s\"},\n {\"role\": \"user\",\n  \"content\": \"A nonzero ideal has an element of minimal norm. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u_1} {S : Type u_2} [inst : EuclideanDomain R] [inst_1 : CommRing S] [inst_2 : IsDomain S]\\n  [inst_3 : Algebra R S] (abv : AbsoluteValue R â„¤) (I : â†¥(nonZeroDivisors (Ideal S))),\\n  âˆƒ b âˆˆ â†‘I, b â‰  0 âˆ§ âˆ€ c âˆˆ â†‘I, abv ((Algebra.norm R) c) < abv ((Algebra.norm R) b) â†’ c = 0\"},\n {\"role\": \"user\",\n  \"content\": \"A ring is a `â„š`-algebra iff it has equal characteristic zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ (R : Type u_1) [inst : CommRing R], Nonempty (Algebra â„š R) â†” âˆ€ (I : Ideal R), I â‰  âŠ¤ â†’ CharZero (R â§¸ I)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a monoid with zero, if zero equals one, then zero is the only element. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Mâ‚€ : Type u_2} [inst : MulZeroOneClass Mâ‚€], 0 = 1 â†’ âˆ€ (a : Mâ‚€), a = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A product of ideals in an integral domain is zero if and only if one of the terms is zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u_2} [inst : CommRing R] [inst_1 : IsDomain R] {s : Multiset (Ideal R)},\\n  Multiset.prod s = âŠ¥ â†” âˆƒ I âˆˆ s, I = âŠ¥\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `v` is a valuation on a division ring then `v(x) = 0` iff `x = 0`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {K : Type u_1} [inst : DivisionRing K] {Î“â‚€ : Type u_4} [inst_1 : LinearOrderedCommMonoidWithZero Î“â‚€]\\n  [inst_2 : Nontrivial Î“â‚€] (v : Valuation K Î“â‚€) {x : K}, v x = 0 â†” x = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"An element of a discrete valuation ring is a unit if and only if it has a valuation of zero.\"}]"}
{"text":"For any two relatively prime positive integers $a$ and $b$, every sufficiently large natural number $N$ can be written as a linear combination $ax + by$ of $a$ and $b$, where both $x$ and $y$ are natural numbers.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Rational numbers are dense in a linear ordered archimedean field. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {ð•œ : Type u_1} [inst : LinearOrderedField ð•œ] [inst_1 : TopologicalSpace ð•œ] [inst_2 : OrderTopology ð•œ]\\n  [inst_3 : Archimedean ð•œ], DenseRange Rat.cast\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `p` is a prime factor of `a` then `p` is also a prime factor of `a * b` for any `b > 0` \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {p a b : â„•}, p âˆˆ Nat.factors a â†’ b â‰  0 â†’ p âˆˆ Nat.factors (a * b)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If two integers are congruent to a sufficiently large modulus,\\nthey are equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {a b c : â„¤}, a % b = c â†’ Int.natAbs (a - c) < Int.natAbs b â†’ a = c\"},\n {\"role\": \"user\",\n  \"content\":\n  \"There is a rational power between any two positive elements of an archimedean ordered field. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {n : â„•} {Î± : Type u_1} [inst : LinearOrderedField Î±] [inst_1 : Archimedean Î±],\\n  n â‰  0 â†’ âˆ€ {x y : Î±}, x < y â†’ 0 < y â†’ âˆƒ q, 0 < q âˆ§ x < â†‘q ^ n âˆ§ â†‘q ^ n < y\"},\n {\"role\": \"user\", \"content\": \"For `a â‰¤ b`, there is a `c` so `b = a * c`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u_1} [self : CanonicallyOrderedCommMonoid Î±] {a b : Î±}, a â‰¤ b â†’ âˆƒ c, b = a * c\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"role\": \"assistant\",\n  \"content\": \"âˆ€ {m n : â„•}, (âˆ€ (a : â„•), a âˆ£ m â†” a âˆ£ n) â†” m = n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `p` is a prime factor of `b` then `p` is also a prime factor of `a * b` for any `a > 0` \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {p a b : â„•}, p âˆˆ Nat.factors b â†’ a â‰  0 â†’ p âˆˆ Nat.factors (a * b)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For coprime `a` and `b`, the prime factors of `a * b` are the union of those of `a` and `b` \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {a b : â„•}, Nat.Coprime a b â†’ List.Perm (Nat.factors (a * b)) (Nat.factors a ++ Nat.factors b)\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\", \"content\": \"Set.InjOn Nat.factorization {x | x â‰  0}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"role\": \"assistant\",\n  \"content\": \"âˆ€ {m n : â„•}, (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"We relate a finite product over primes to an infinite sum over smooth numbers. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u_1} [inst : NormedCommRing R] [inst_1 : CompleteSpace R] {f : â„• â†’ R},\\n  f 1 = 1 â†’\\n    (âˆ€ {m n : â„•}, Nat.Coprime m n â†’ f (m * n) = f m * f n) â†’\\n      (âˆ€ {p : â„•}, Nat.Prime p â†’ Summable fun n => â€–f (p ^ n)â€–) â†’\\n        âˆ€ (N : â„•),\\n          (Summable fun m => â€–f â†‘mâ€–) âˆ§\\n            HasSum (fun m => f â†‘m) (Finset.prod (Nat.primesBelow N) fun p => âˆ‘' (n : â„•), f (p ^ n))\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For positive `a` and `b`, the prime factors of `a * b` are the union of those of `a` and `b` \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {a b : â„•}, a â‰  0 â†’ b â‰  0 â†’ List.Perm (Nat.factors (a * b)) (Nat.factors a ++ Nat.factors b)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {a b x y u v : â„•}, a = x ^ 2 + y ^ 2 â†’ b = u ^ 2 + v ^ 2 â†’ âˆƒ r s, a * b = r ^ 2 + s ^ 2\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For any two relatively prime positive integers $a$ and $b$, every sufficiently large natural number $N$ can be written as a linear combination $ax + by$ of $a$ and $b$, where both $x$ and $y$ are natural numbers.\"}]"}
{"text":"Every field is a ring.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"The characteristic of a finite ring cannot be zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ (R : Type u_1) [inst : NonAssocRing R] (p : â„•) [inst : CharP R p] [inst : Finite R], p â‰  0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If two rings are isomorphic, and the second is a domain, then so is the first. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {A : Type u_7} (B : Type u_8) [inst : Semiring A] [inst_1 : Semiring B] [inst_2 : IsDomain B], A â‰ƒ* B â†’ IsDomain A\"},\n {\"role\": \"user\", \"content\": \"A subring contains the ring's 1. \"},\n {\"role\": \"assistant\",\n  \"content\": \"âˆ€ {R : Type u} [inst : Ring R] (s : Subring R), 1 âˆˆ s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The quotient of a ring by an ideal is a field iff the ideal is maximal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I â†” IsField (R â§¸ I)\"},\n {\"role\": \"user\", \"content\": \"Every ring involution must be its own inverse \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {F : Type u_2} {R : outParam (Type u_3)} [inst : Semiring R] [self : RingInvoClass F R] (f : F) (x : R),\\n  MulOpposite.unop (f (MulOpposite.unop (f x))) = x\"},\n {\"role\": \"user\", \"content\": \"A seminormed ring is a topological ring. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u_1} [inst : NonUnitalSeminormedRing Î±], TopologicalRing Î±\"},\n {\"role\": \"user\",\n  \"content\": \"When a ring is not a field, the maximal ideals are nontrivial. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u_1} [inst : CommSemiring R] [inst_1 : Nontrivial R] {M : Ideal R}, Ideal.IsMaximal M â†’ Â¬IsField R â†’ M â‰  âŠ¥\"},\n {\"role\": \"user\", \"content\": \"A subring contains the ring's 0. \"},\n {\"role\": \"assistant\",\n  \"content\": \"âˆ€ {R : Type u} [inst : Ring R] (s : Subring R), 0 âˆˆ s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A field is perfect if every irreducible polynomial is separable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {K : Type u_1} [inst : Field K] [self : PerfectField K] {f : Polynomial K}, Irreducible f â†’ Polynomial.Separable f\"},\n {\"role\": \"user\",\n  \"content\": \"Stalks of a locally ringed space are local rings. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ (self : AlgebraicGeometry.LocallyRingedSpace) (x : â†‘â†‘self.toPresheafedSpace),\\n  LocalRing â†‘(TopCat.Presheaf.stalk self.presheaf x)\"},\n {\"role\": \"user\",\n  \"content\": \"The ring of integers of a number field is not a field. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ (K : Type u_1) [inst : Field K] [nf : NumberField K], Â¬IsField â†¥(NumberField.ringOfIntegers K)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For a semiring to be a field, it must have two distinct elements. \"},\n {\"role\": \"assistant\",\n  \"content\": \"âˆ€ {R : Type u} [inst : Semiring R], IsField R â†’ âˆƒ x y, x â‰  y\"},\n {\"role\": \"user\",\n  \"content\": \"All ideals in a division (semi)ring are trivial. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {K : Type u} [inst : DivisionSemiring K] (I : Ideal K), I = âŠ¥ âˆ¨ I = âŠ¤\"},\n {\"role\": \"user\", \"content\": \"The category of rings has all limits. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"CategoryTheory.Limits.HasLimitsOfSize.{v, v, max u v, max (u + 1) (v + 1)} CommSemiRingCatMax\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A perfect field of characteristic `p` (prime) is a perfect ring. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ (K : Type u_1) [inst : Field K] [inst_1 : PerfectField K] (p : â„•) [hp : Fact (Nat.Prime p)] [inst_2 : CharP K p],\\n  PerfectRing K p\"},\n {\"role\": \"user\", \"content\": \"Fields are commutative. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u} [inst : Semiring R], IsField R â†’ âˆ€ (x y : R), x * y = y * x\"},\n {\"role\": \"user\",\n  \"content\": \"A linear ordered field that is a floor ring is archimedean. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ (Î± : Type u_2) [inst : LinearOrderedField Î±] [inst_1 : FloorRing Î±], Archimedean Î±\"},\n {\"role\": \"user\", \"content\": \"An intermediate field contains the ring's 1. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {K : Type u_1} {L : Type u_2} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\\n  1 âˆˆ S\"},\n {\"role\": \"user\", \"content\": \"An intermediate field contains the ring's 0. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {K : Type u_1} {L : Type u_2} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\\n  0 âˆˆ S\"},\n {\"role\": \"user\", \"content\": \"A field is a valuation ring. \"},\n {\"role\": \"assistant\",\n  \"content\": \"âˆ€ (K : Type u) [inst : Field K], ValuationRing K\"},\n {\"role\": \"user\", \"content\": \"Every field is a ring.\"}]"}
{"text":"The set of units in a ring forms a group.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Multivariate formal power series over a local ring form a local ring. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Ïƒ : Type u_1} {R : Type u_2} [inst : CommRing R] [inst_1 : LocalRing R], LocalRing (MvPowerSeries Ïƒ R)\"},\n {\"role\": \"user\",\n  \"content\": \"The subring generated by a set includes the set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u} [inst : Ring R] {s : Set R}, s âŠ† â†‘(Subring.closure s)\"},\n {\"role\": \"user\", \"content\": \"A unit in a monoid is regular. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u_1} [inst : Monoid R] {a : R}, IsUnit a â†’ IsRegular a\"},\n {\"role\": \"user\",\n  \"content\": \"Subgroups of torsion groups are torsion groups. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsion â†¥H\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is cyclic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u} [inst : Group Î±] [inst_1 : Fintype Î±] {p : â„•} [hp : Fact (Nat.Prime p)], Fintype.card Î± = p â†’ IsCyclic Î±\"},\n {\"role\": \"user\", \"content\": \"The normal closure of a set is a subgroup. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] (s : Set G), IsSubgroup (Group.normalClosure s)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A group is finitely generated if and only if it is finitely generated as a monoid. \"},\n {\"role\": \"assistant\",\n  \"content\": \"âˆ€ {G : Type u_3} [inst : Group G], Group.FG G â†” Monoid.FG G\"},\n {\"role\": \"user\", \"content\": \"A seminormed ring is a topological ring. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u_1} [inst : NonUnitalSeminormedRing Î±], TopologicalRing Î±\"},\n {\"role\": \"user\", \"content\": \"A subring contains the ring's 1. \"},\n {\"role\": \"assistant\",\n  \"content\": \"âˆ€ {R : Type u} [inst : Ring R] (s : Subring R), 1 âˆˆ s\"},\n {\"role\": \"user\",\n  \"content\": \"A normed division ring is a topological division ring. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î± : Type u_1} [inst : NormedDivisionRing Î±], TopologicalDivisionRing Î±\"},\n {\"role\": \"user\", \"content\": \"A subring contains the ring's 0. \"},\n {\"role\": \"assistant\",\n  \"content\": \"âˆ€ {R : Type u} [inst : Ring R] (s : Subring R), 0 âˆˆ s\"},\n {\"role\": \"user\",\n  \"content\": \"The subgroup generated by a set includes the set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] {k : Set G}, k âŠ† â†‘(Subgroup.closure k)\"},\n {\"role\": \"user\", \"content\": \"The unit circle in `â„‚` is a Lie group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"LieGroup (modelWithCornersSelf â„ (EuclideanSpace â„ (Fin 1))) â†¥circle\"},\n {\"role\": \"user\",\n  \"content\": \"The center of a group acts commutatively on that group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], SMulCommClass G (â†¥(Subgroup.center G)) G\"},\n {\"role\": \"user\", \"content\": \"Finite groups are torsion groups. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A finite subgroup of the unit group of an integral domain is cyclic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u_1} {G : Type u_2} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\\n  (f : G â†’* R), Function.Injective â‡‘f â†’ IsCyclic G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A finite subgroup of the units of an integral domain is cyclic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (S : Subgroup RË£) [inst_2 : Finite â†¥S], IsCyclic â†¥S\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The group of units of a complete normed ring is an open subset of the ring. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R], IsOpen {x | IsUnit x}\"},\n {\"role\": \"user\",\n  \"content\": \"The units of a complete normed ring form a Lie group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] {ð•œ : Type u_2} [inst_2 : NontriviallyNormedField ð•œ]\\n  [inst_3 : NormedAlgebra ð•œ R], LieGroup (modelWithCornersSelf ð•œ R) RË£\"},\n {\"role\": \"user\", \"content\": \"The set of units in a ring forms a group.\"}]"}
{"text":"If the direct product of two groups is torsion free then each of the groups is torsion free.","fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Quotienting by the torsion submodule gives a torsion-free module. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M],\\n  Submodule.torsion R (M â§¸ Submodule.torsion R M) = âŠ¥\"},\n {\"role\": \"user\",\n  \"content\": \"The free product of free groups is itself a free group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î¹ : Type u_4} (G : Î¹ â†’ Type u_5) [inst : (i : Î¹) â†’ Group (G i)] [inst_1 : âˆ€ (i : Î¹), IsFreeGroup (G i)],\\n  IsFreeGroup (Monoid.CoprodI G)\"},\n {\"role\": \"user\", \"content\": \"The torsion subgroup is cylic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ (K : Type u_1) [inst : Field K] [inst_1 : NumberField K], IsCyclic â†¥(NumberField.Units.torsion K)\"},\n {\"role\": \"user\",\n  \"content\": \"A nontrivial torsion group is not torsion-free. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G â†’ Â¬Monoid.IsTorsionFree G\"},\n {\"role\": \"user\", \"content\": \"Torsion submonoids are torsion. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : CommMonoid G], Monoid.IsTorsion â†¥(CommMonoid.torsion G)\"},\n {\"role\": \"user\",\n  \"content\": \"Additive torsion groups are closed under extensions.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} {H : Type u_2} [inst : AddGroup G] {N : AddSubgroup G} [inst_1 : AddGroup H] {f : G â†’+ H},\\n  N = AddMonoidHom.ker f â†’ AddMonoid.IsTorsion H â†’ AddMonoid.IsTorsion â†¥N â†’ AddMonoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The torsion submonoid of an abelian group equals the torsion subgroup as a submonoid. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ (G : Type u_1) [inst : CommGroup G], CommMonoid.torsion G = (CommGroup.torsion G).toSubmonoid\"},\n {\"role\": \"user\",\n  \"content\": \"The image of a quotient is torsion iff the group is torsion. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G â†’* H},\\n  Function.Surjective â‡‘f â†’ N = MonoidHom.ker f â†’ Monoid.IsTorsion â†¥N â†’ (Monoid.IsTorsion H â†” Monoid.IsTorsion G)\"},\n {\"role\": \"user\",\n  \"content\": \"A nontrivial torsion-free group is not torsion. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G â†’ Â¬Monoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\": \"If a group exponent exists, the group is torsion. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], Monoid.ExponentExists G â†’ Monoid.IsTorsion G\"},\n {\"role\": \"user\", \"content\": \"Finite groups are torsion groups. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Subgroups of additive torsion groups are additive torsion groups.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G], AddMonoid.IsTorsion G â†’ âˆ€ (H : AddSubgroup G), AddMonoid.IsTorsion â†¥H\"},\n {\"role\": \"user\",\n  \"content\": \"Subgroups of torsion groups are torsion groups. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsion â†¥H\"},\n {\"role\": \"user\", \"content\": \"Torsion groups are closed under extensions. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G â†’* H},\\n  N = MonoidHom.ker f â†’ Monoid.IsTorsion H â†’ Monoid.IsTorsion â†¥N â†’ Monoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Quotienting a group by its additive torsion subgroup yields an additive torsion free group.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ (G : Type u_1) [inst : AddCommGroup G], AddMonoid.IsTorsionFree (G â§¸ AddCommGroup.torsion G)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Quotienting a group by its torsion subgroup yields a torsion free group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G â§¸ CommGroup.torsion G)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Subgroups of additive torsion-free groups are additively torsion-free.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : AddGroup G], AddMonoid.IsTorsionFree G â†’ âˆ€ (H : AddSubgroup G), AddMonoid.IsTorsionFree â†¥H\"},\n {\"role\": \"user\",\n  \"content\": \"Subgroups of torsion-free groups are torsion-free. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G â†’ âˆ€ (H : Subgroup G), Monoid.IsTorsionFree â†¥H\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Direct products of additive torsion free groups are torsion free.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î· : Type u_3} {Gs : Î· â†’ Type u_4} [inst : (i : Î·) â†’ AddGroup (Gs i)],\\n  (âˆ€ (i : Î·), AddMonoid.IsTorsionFree (Gs i)) â†’ AddMonoid.IsTorsionFree ((i : Î·) â†’ Gs i)\"},\n {\"role\": \"user\",\n  \"content\": \"Direct products of torsion free groups are torsion free. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"âˆ€ {Î· : Type u_3} {Gs : Î· â†’ Type u_4} [inst : (i : Î·) â†’ Group (Gs i)],\\n  (âˆ€ (i : Î·), Monoid.IsTorsionFree (Gs i)) â†’ Monoid.IsTorsionFree ((i : Î·) â†’ Gs i)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If the direct product of two groups is torsion free then each of the groups is torsion free.\"}]"}
